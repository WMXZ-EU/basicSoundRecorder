
.vsteensy/build/basicSoundRecorder_T36.elf:     file format elf32-littlearm

SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
00013548 l    d  .fini	00000000 .fini
0001354c l    d  .ARM.exidx	00000000 .ARM.exidx
1fff0000 l    d  .usbdescriptortable	00000000 .usbdescriptortable
1fff0200 l    d  .dmabuffers	00000000 .dmabuffers
1fff0bd0 l    d  .usbbuffers	00000000 .usbbuffers
1fff0f30 l    d  .data	00000000 .data
1fff1da8 l    d  .bss	00000000 .bss
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 mk20dx128.c
00009418 l     F .text	0000000c startup_default_early_hook
00009424 l     F .text	00000002 startup_default_late_hook
00000000 l    df *ABS*	00000000 crtstuff.c
00000410 l     F .text	00000000 __do_global_dtors_aux
1fff1da8 l       .bss	00000000 completed.8605
00000434 l     F .text	00000000 frame_dummy
1fff1dac l       .bss	00000000 object.8610
00013534 l     O .text	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 acq.cpp
000006e4 l     F .text	00000058 acq_isr()
0000073c l     F .text	00000028 _GLOBAL__sub_I_acq_count
1fff0200 l     O .dmabuffers	00000800 tdm_rx_buffer
1fff1dcc l     O .bss	00000400 acq_rx_buffer
1fff21cc l     O .bss	00000008 dma
00000000 l    df *ABS*	00000000 main.cpp
1fff21d8 l     O .bss	00000004 checkToCloseFile(short, unsigned long)::to
1fff21dc l     O .bss	00000004 loop::t0
1fff21e0 l     O .bss	00000002 loop::status
00000000 l    df *ABS*	00000000 menu.cpp
00000b7c l     F .text	00000024 File::dec_refcount() [clone .isra.15]
00000000 l    df *ABS*	00000000 mTime.cpp
00012825 l     O .text	0000000c monthDays
00000000 l    df *ABS*	00000000 filing.cpp
00001844 l     F .text	00000002 __tcf_0
00001908 l     F .text	00000024 File::dec_refcount() [clone .isra.23]
000021e4 l     F .text	000000bc _GLOBAL__sub_I_data_buffer
1fff2228 l     O .bss	00000004 isd
1fff0f38 l     O .data	00000004 checkDiskSpace()::isd_
20017a30 l     O .bss	00000200 saveData(short)::header
200180fc l     O .bss	00000050 saveData(short)::fileName
2001814c l     O .bss	00000004 saveData(short)::dirFlag
2001815c l     O .bss	00000050 saveData(short)::dirName
200181ac l     O .bss	00001000 dummy_buffer
00000000 l    df *ABS*	00000000 adc.cpp
00002538 l     F .text	00000014 _GLOBAL__sub_I_gain
00000000 l    df *ABS*	00000000 utils.cpp
00000000 l    df *ABS*	00000000 WireKinetis.cpp
00002892 l       .text	00000000 L_1161_delayMicroseconds
000028a0 l       .text	00000000 L_1175_delayMicroseconds
000028e8 l       .text	00000000 L_1220_delayMicroseconds
00002b78 l       .text	00000000 L_2399_delayMicroseconds
2001a1c4 l     O .bss	00000001 TwoWire::isr()::receiving
00000000 l    df *ABS*	00000000 SPI.cpp
00002be8 l     F .text	00000022 DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]
00000000 l    df *ABS*	00000000 SD.cpp
00003488 l     F .text	00000064 _GLOBAL__sub_I_SD
00000000 l    df *ABS*	00000000 FsUtf.cpp
00000000 l    df *ABS*	00000000 FsGetPartitionInfo.cpp
00012af8 l     O .text	00000010 FsGetPartitionInfo::mbdpGuid
00000000 l    df *ABS*	00000000 FsStructs.cpp
00000000 l    df *ABS*	00000000 FsCache.cpp
00000000 l    df *ABS*	00000000 upcase.cpp
00012b12 l     O .text	0000012c lookupTable
00012c3e l     O .text	000000d4 mapTable
00000000 l    df *ABS*	00000000 FsName.cpp
00000000 l    df *ABS*	00000000 ExFatFormatter.cpp
00000000 l    df *ABS*	00000000 ExFatName.cpp
00000000 l    df *ABS*	00000000 ExFatFile.cpp
00000000 l    df *ABS*	00000000 ExFatPartition.cpp
00000000 l    df *ABS*	00000000 ExFatVolume.cpp
00000000 l    df *ABS*	00000000 ExFatFileWrite.cpp
00004cec l     F .text	0000002e exFatDirChecksum(unsigned char const*, unsigned short)
00000000 l    df *ABS*	00000000 FatFormatter.cpp
00005634 l     F .text	00000028 initFatDirCallback(unsigned long, void*)
00000000 l    df *ABS*	00000000 FatName.cpp
00000000 l    df *ABS*	00000000 FatFile.cpp
00000000 l    df *ABS*	00000000 FatPartition.cpp
00000000 l    df *ABS*	00000000 FatVolume.cpp
00000000 l    df *ABS*	00000000 FatFileLFN.cpp
00006dd6 l     F .text	0000001e FatFile::lfnChecksum(unsigned char*) [clone .isra.14]
00000000 l    df *ABS*	00000000 FsFile.cpp
00000000 l    df *ABS*	00000000 FsVolume.cpp
00000000 l    df *ABS*	00000000 FsNew.cpp
00000000 l    df *ABS*	00000000 SdSpiCard.cpp
000077b4 l     F .text	00000006 SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]
000077ba l     F .text	00000006 SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]
00000000 l    df *ABS*	00000000 SdioTeensy.cpp
00007f9c l     F .text	00000028 sdIrs()
00007fc4 l     F .text	00000018 isBusyCommandComplete()
00007fdc l     F .text	00000010 isBusyCommandInhibit()
00007fec l     F .text	00000014 isBusyDat()
00008000 l     F .text	0000000c isBusyDMA()
0000800c l     F .text	00000014 isBusyFifoRead()
00008020 l     F .text	00000014 isBusyFifoWrite()
00008034 l     F .text	00000018 isBusyTransferComplete()
0000804c l     F .text	00000098 setSdclk(unsigned long)
00008148 l     F .text	00000024 waitTimeout(bool (*)())
0000816c l     F .text	00000040 yieldTimeout(bool (*)())
000081dc l     F .text	00000054 cardCommand(unsigned long, unsigned long)
00008230 l     F .text	00000020 statusCMD13()
00008250 l     F .text	00000010 isBusyCMD13()
00008264 l     F .text	00000068 readReg16(unsigned long, void*)
000082cc l     F .text	00000020 waitDmaStatus() [clone .part.4]
000082ec l     F .text	0000009c rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)
000084c4 l     F .text	0000005c waitTransferComplete()
00008860 l     F .text	00000098 cardCMD6(unsigned long, unsigned char*)
2001a6a0 l     O .bss	00000001 m_version2
2001a6a1 l     O .bss	00000010 m_cid
2001a6b4 l     O .bss	00000004 m_busyFcn
2001a6b8 l     O .bss	00000001 m_highCapacity
2001a6bc l     O .bss	00000004 m_ocr
2001a6c0 l     O .bss	00000004 m_rca
2001a6c4 l     O .bss	00000001 m_transferActive
2001a6c8 l     O .bss	00000004 m_irqstat
1fff1338 l     O .data	00000001 m_errorCode
2001a6cc l     O .bss	00000001 m_initDone
2001a6cd l     O .bss	00000010 m_csd
2001a6dd l     O .bss	00000001 m_dmaBusy
2001a6e0 l     O .bss	00000004 m_sdClkKhz
2001a6e4 l     O .bss	00000004 m_errorLine
00000000 l    df *ABS*	00000000 memcpy-armv7m.o
00000000 l    df *ABS*	00000000 memset.o
00000000 l    df *ABS*	00000000 usb_serial.c
2001a6e9 l     O .bss	00000001 tx_noautoflush
2001a6ec l     O .bss	00000004 tx_packet
2001a6f0 l     O .bss	00000001 transmit_previous_timeout
2001a6f4 l     O .bss	00000004 rx_packet
00000000 l    df *ABS*	00000000 pins_teensy.c
00009494 l     F .text	00000002 startup_default_middle_hook
00000000 l    df *ABS*	00000000 usb_mem.c
1fff1340 l     O .data	00000004 usb_buffer_available
00000000 l    df *ABS*	00000000 usb_dev.c
00009730 l     F .text	00000040 endpoint0_transmit
2001a700 l     O .bss	00000004 ep0_tx_ptr
2001a704 l     O .bss	00000010 rx_last
2001a714 l     O .bss	00000004 tx_state
2001a718 l     O .bss	00000040 ep0_rx0_buf
2001a758 l     O .bss	00000010 rx_first
2001a768 l     O .bss	00000001 ep0_tx_bdt_bank
2001a76c l     O .bss	00000040 ep0_rx1_buf
2001a7ac l     O .bss	00000010 tx_first
1fff0000 l     O .usbdescriptortable	000000a0 table
2001a7bc l     O .bss	00000010 tx_last
2001a7cc l     O .bss	00000008 setup
2001a7d4 l     O .bss	00000002 ep0_tx_len
2001a7d7 l     O .bss	00000008 reply_buffer
2001a7e0 l     O .bss	00000001 ep0_tx_data_toggle
00000000 l    df *ABS*	00000000 yield.cpp
2001a7e1 l     O .bss	00000001 yield::running
00000000 l    df *ABS*	00000000 DMAChannel.cpp
00000000 l    df *ABS*	00000000 EventResponder.cpp
00000000 l    df *ABS*	00000000 usb_inst.cpp
00000000 l    df *ABS*	00000000 Print.cpp
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 Stream.cpp
00000000 l    df *ABS*	00000000 serialEvent.cpp
00000000 l    df *ABS*	00000000 new.cpp
00000000 l    df *ABS*	00000000 analog.c
2001a811 l     O .bss	00000001 calibrating
1fff1359 l     O .data	00000001 analog_config_bits
2001a812 l     O .bss	00000001 analog_reference_internal
1fff135a l     O .data	00000001 analog_num_average
00000000 l    df *ABS*	00000000 usb_desc.c
1fff135b l     O .data	00000012 device_descriptor
1fff1386 l     O .data	00000043 config_descriptor
00000000 l    df *ABS*	00000000 nonstd.c
00000000 l    df *ABS*	00000000 atexit_arm.cc
00000000 l    df *ABS*	00000000 _lshrdi3.o
00000000 l    df *ABS*	00000000 _arm_addsubdf3.o
00000000 l    df *ABS*	00000000 _arm_muldivdf3.o
00000000 l    df *ABS*	00000000 _arm_cmpdf2.o
00000000 l    df *ABS*	00000000 _arm_unorddf2.o
00000000 l    df *ABS*	00000000 _arm_fixdfsi.o
00000000 l    df *ABS*	00000000 _arm_fixunsdfsi.o
00000000 l    df *ABS*	00000000 _arm_truncdfsf2.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 cxa_atexit.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 locale.c
0000b2f0 l     F .text	00000018 __get_current_locale
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 lib_a-memchr.o
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 sscanf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 lib_a-strlen.o
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strtod.c
0000c0fc l     F .text	00000038 sulp
00013120 l     O .text	00000014 fpi.6173
00013144 l     O .text	00000014 fpinan.6209
00013158 l     O .text	00000028 tinytens
00000000 l    df *ABS*	00000000 strtol.c
0000d030 l     F .text	00000136 _strtol_l.isra.0
00000000 l    df *ABS*	00000000 vfprintf.c
00013180 l     O .text	00000010 zeroes.7258
000131d4 l     O .text	00000010 blanks.7257
00000000 l    df *ABS*	00000000 vfscanf.c
000131e4 l     O .text	00000022 basefix.7328
00000000 l    df *ABS*	00000000 vdprintf.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0000f84c l     F .text	00000014 register_fini
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 dtoa.c
0000f86c l     F .text	00000128 quorem
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
00010a60 l     F .text	000000a8 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 localeconv.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mprec.c
00013518 l     O .text	0000000c p05.6087
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strtoll.c
00011bc8 l     F .text	000001ac _strtoll_l.isra.0
00000000 l    df *ABS*	00000000 strtoul.c
00011d98 l     F .text	00000168 _strtoul_l.isra.0
00000000 l    df *ABS*	00000000 strtoull.c
00011f24 l     F .text	000001ec _strtoull_l.isra.0
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 vfscanf.c
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vasnprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 impure.c
1fff1400 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 ctype_.c
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.19/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crti.o
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.19/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crtn.o
00000000 l    df *ABS*	00000000 FsDateTime.cpp
00000000 l    df *ABS*	00000000 avr_emulation.cpp
00000000 l    df *ABS*	00000000 HardwareSerial.cpp
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 
1fff1da8 l       .bss	00000000 __bss_start__
2001a860 l       .bss	00000000 __bss_end__
00000000 l       *UND*	00000000 software_init_hook
00000000 l       *UND*	00000000 hardware_init_hook
00000000 l       *UND*	00000000 __stack
00005cc8  w    F .text	00000026 FatPartition::cacheSync()
00009410  w    F .text	00000006 adc0_isr
00000a9a  w    F .text	00000066 SDFile::getModifyTime(DateTimeFields&)
000038dc g     F .text	000000a4 toUpcase(unsigned short)
00001aa8 g     F .text	00000034 pushData(unsigned long*)
0000ae14 g     F .text	0000002c .hidden __aeabi_dcmpun
000091ac g     F .text	0000001c usb_serial_available
00001320 g     F .text	000001b4 menu()
00011ae8 g     F .text	0000005e __any_on
0000add8 g     F .text	00000012 .hidden __aeabi_dcmple
000022a8  w    F .text	0000004a i2c_class::write16(unsigned char, unsigned short, unsigned short)
00006a28 g     F .text	0000002e FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)
0000ad14 g     F .text	0000007a .hidden __cmpdf2
000087e8 g     F .text	00000078 SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)
00009f7c  w    F .text	000000d8 yield
1fff1dc8 g     O .bss	00000004 acq_miss
00006868 g     F .text	000001c0 FatFile::write(void const*, unsigned int)
0000ad14 g     F .text	0000007a .hidden __eqdf2
00007724  w    F .text	00000002 SdSpiCard::~SdSpiCard()
0000a2a4 g     F .text	000000a6 Print::printNumber64(unsigned long long, unsigned char, unsigned char)
1fff136e g     O .data	00000018 usb_string_manufacturer_name_default
000067fe g     F .text	00000068 FatFile::truncate()
1fff11bc g     O .data	0000013c Wire1
00003ae0 g     F .text	00000458 ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)
20018158 g     O .bss	00000004 clusterSize
0000a884 g     F .text	0000005a .hidden __floatdidf
000014d4 g     F .text	00000024 newHour()
000093dc  w    F .text	00000034 hard_fault_isr
00009410  w    F .text	00000006 dma_ch6_isr
0000192c  w    F .text	00000054 MySpiClass::deactivate()
2001a690 g     O .bss	00000004 FsDateTime::callback
00003024  w    F .text	000000d8 SPIClass::dma_rxisr()
0000337e  w    F .text	00000050 SdBase<FsVolume>::restart()
00005704 g     F .text	0000005c FatFormatter::initPbs()
0000a1e4 g     F .text	00000020 Print::println()
0000271c g     F .text	00000114 TwoWire::isr()
00009410  w    F .text	00000006 uart0_lon_isr
00004374 g     F .text	000000d0 ExFatFile::seekSet(unsigned long long)
000097cc g     F .text	00000078 usb_rx_memory
00007708  w    F .text	00000004 SdSpiCard::errorCode() const
000009e6  w    F .text	0000000c File::flush()
00000a34  w    F .text	00000066 SDFile::getCreateTime(DateTimeFields&)
00009410  w    F .text	00000006 dma_ch8_isr
0000bad0 g     F .text	00000002 __malloc_unlock
000077d4 g     F .text	00000026 SdSpiCard::spiStart()
00000f94  w    F .text	00000088 SDFile::openNextFile(unsigned char)
2001a69c g     O .bss	00000004 FsVolume::m_cwv
000062ec g     F .text	000000a8 FatFile::open(FatFile*, char const*, int)
2001a1c0 g     O .bss	00000004 SerNum
0000a3e4 g     F .text	000000b8 analog_init
000018f4  w    F .text	00000014 MySpiClass::begin(SdSpiConfig)
00009844 g     F .text	00000080 usb_tx
0000d010 g     F .text	00000020 _strtod_r
00009410  w    F .text	00000006 portcd_isr
00001a78  w    F .text	00000016 MySpiClass::setSckSpeed(unsigned long)
0000f6fc g     F .text	0000004a _vdprintf_r
000063d6 g     F .text	00000020 FatFile::getCreateDateTime(unsigned short*, unsigned short*)
00002db4 g     F .text	000000a4 SPIClass::setSCK(unsigned char)
00001dcc g     F .text	00000418 saveData(short)
0000a558 g     F .text	00000018 .hidden __aeabi_llsr
0001259c  w    O .text	0000005c vtable for SDFile
000122f4 g     F .text	00000082 _sfread_r
0000ba04 g     F .text	000000c6 memmove
0000b32c g     F .text	00000014 __locale_ctype_ptr
00008e50 g     F .text	00000060 SdioCard::stopTransmission(bool)
00011260 g     F .text	0000004c _Balloc
00009410  w    F .text	00000006 can1_rx_warn_isr
00013554 g       .ARM.exidx	00000000 __exidx_end
00009410  w    F .text	00000006 dma_error_isr
00003344  w    F .text	0000003a SdBase<FsVolume>::cardBegin(SdSpiConfig)
00006be6 g     F .text	00000046 FatPartition::freeChain(unsigned long)
2001a7f4 g     O .bss	00000001 EventResponder::runningFromYield
000079ba g     F .text	0000007c SdSpiCard::cardCommand(unsigned char, unsigned long)
00002bc4 g     F .text	0000000c i2c0_isr
0000178c  w    F .text	0000009c MySpiClass::activate()
0000a1ba g     F .text	00000028 Print::write(unsigned char const*, unsigned int)
0000ad04 g     F .text	0000008a .hidden __gtdf2
0000b294 g     F .text	0000000c __errno
00000c88  w    F .text	0000000a SDFile::isDirectory()
00005254 g     F .text	00000112 ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
000009be  w    F .text	0000000c File::write(unsigned char const*, unsigned int)
00009410  w    F .text	00000006 portd_isr
00001124 g     F .text	0000001c saveParameters()
00009410  w    F .text	00000006 enet_error_isr
00007a36  w    F .text	0000001e SdSpiCard::cardAcmd(unsigned char, unsigned long)
00012964 g     O .text	00000020 TwoWire::i2c2_hardware
00000ba0  w    F .text	0000001c File::~File()
2001a7e4 g     O .bss	00000004 EventResponder::firstInterrupt
000111e4 g     F .text	00000004 __localeconv_l
00007726  w    F .text	0000000e SdSpiCard::~SdSpiCard()
00003a32 g     F .text	0000001c ExFatFormatter::writeUpcaseUnicode(unsigned short)
000004a0 g     F .text	00000028 acq_startClocks()
000074ba g     F .text	00000062 FsBaseFile::FsBaseFile(FsBaseFile const&)
00009410  w    F .text	00000006 tpm1_isr
00004c80 g     F .text	00000018 ExFatPartition::rootLength()
00000ec6  w    F .text	00000036 SDFile::setCreateTime(DateTimeFields const&)
0000770c  w    F .text	00000004 SdSpiCard::errorData() const
0000a1ac  w    F .text	00000008 usb_serial_class::write(unsigned char const*, unsigned int)
00012e88 g     O .text	00000200 digital_pin_to_info_PGM
00000478 g     F .text	00000028 acq_stopClocks()
2001a85c g     O .bss	00000004 errno
00007c08 g     F .text	00000038 SdSpiCard::readOCR(unsigned long*)
00004a0c g     F .text	0000003e ExFatPartition::fatGet(unsigned long, unsigned long*)
0000bf7c g     F .text	00000004 __seofread
00013554 g       .ARM.exidx	00000000 _etext
000030fc g     F .text	00000010 _spi_dma_rxISR0()
00001d68 g     F .text	0000005c listDisks()
1fff1da8 g       .bss	00000000 _sbss
00005760 g     F .text	0000005c FatFormatter::writeMbr()
00001b20 g     F .text	0000001c sdCsInit(unsigned char)
00003432 g     F .text	00000054 SDClass::mediaPresent()
0000ada0 g     F .text	00000010 .hidden __aeabi_cdcmple
000080f0 g     F .text	0000000c SdioCard::errorData() const
00000d36  w    F .text	00000018 FsBaseFile::peek()
00008728 g     F .text	000000c0 SdioCard::writeSector(unsigned long, unsigned char const*)
00009410  w    F .text	00000006 porte_isr
00000858 g     F .text	00000160 loop
00009410  w    F .text	00000006 portb_isr
00009410  w    F .text	00000006 spi1_isr
00009410  w    F .text	00000006 uart3_status_isr
00004148 g     F .text	0000007c ExFatFile::parsePathName(char const*, ExName_t*, char const**)
00009410  w    F .text	00000006 mcm_isr
00008c54 g     F .text	000000c4 SdioCard::readData(unsigned char*)
00007852 g     F .text	00000060 SdSpiCard::readData(unsigned char*, unsigned int)
00002910 g     F .text	000000f8 TwoWire::endTransmission(unsigned char)
2001a7e8 g     O .bss	00000004 EventResponder::lastInterrupt
00009410  w    F .text	00000006 uart1_status_isr
0000751c g     F .text	00000028 FsBaseFile::close()
00008f3c g     F .text	000001a6 memcpy
00009410  w    F .text	00000006 randnum_isr
00011048 g     F .text	00000180 __hexnan
0000ad90 g     F .text	00000020 .hidden __aeabi_cdrcmple
000009ca  w    F .text	0000000c File::available()
000019a8  w    F .text	00000014 Print::println(unsigned long)
000034ec g     F .text	00000094 FsUtf::cpToMb(unsigned long, char*, char*)
00001094 g     F .text	00000090 storeConfig(unsigned short*, int)
00004af2 g     F .text	0000005e ExFatPartition::freeChain(unsigned long)
00005fa4 g     F .text	00000028 FatFile::peek()
0000d190 g     F .text	000016e4 _svfprintf_r
0000a814 g     F .text	00000022 .hidden __floatsidf
1fff21e8  w    O .bss	00000001 SDFile::name()::zeroterm
2001a6fc g     O .bss	00000004 systick_millis_count
0000ad0c g     F .text	00000082 .hidden __ltdf2
000051ae g     F .text	000000a6 ExFatFile::rename(ExFatFile*, char const*)
000093dc  w    F .text	00000034 bus_fault_isr
00000b40  w    F .text	0000003c SDFile::truncate(unsigned long long)
00002830 g     F .text	000000e0 TwoWire::wait_idle()
00009410  w    F .text	00000006 watchdog_isr
0000af70 g     F .text	00000000 .hidden __aeabi_uldivmod
00002bd0 g     F .text	0000000c i2c1_isr
2001a7df g     O .bss	00000001 usb_configuration
00009410  w    F .text	00000006 dma_ch11_isr
00001786  w    F .text	00000006 SdCardInterface::status()
00008eb0 g     F .text	0000001c SdioCard::syncDevice()
000085a8 g     F .text	00000094 SdioCard::writeData(unsigned char const*)
00000000  w      *UND*	00000000 __fini_array_end
2001a7f5 g     O .bss	00000001 SPCRemulation::pinout
00000c54  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::available()
1fff21ea g     O .bss	00000020 store
00005fcc g     F .text	0000003a FatFile::readDirCache(bool)
00011a40 g     F .text	00000060 __ratio
00002bdc g     F .text	0000000c i2c2_isr
1fff136e  w    O .data	00000018 usb_string_manufacturer_name
2001a854 g     O .bss	00000008 usb_rx_byte_count_data
00009410  w    F .text	00000006 pit1_isr
0000b340 g     F .text	00000010 malloc
00009410  w    F .text	00000006 dma_ch4_isr
00012944 g     O .text	00000020 TwoWire::i2c1_hardware
00009410  w    F .text	00000006 software_isr
000077c0  w    F .text	00000014 SysCall::curTimeMS()
000033ce g     F .text	00000064 SDClass::format(int, char, Print&)
0001254c  w    O .text	00000024 vtable for FsFile
000111c8 g     F .text	0000001c iswspace
00009410  w    F .text	00000006 dma_ch7_isr
000025c8  w    F .text	0000001e TwoWire::read()
00013428 g     O .text	000000c8 __mprec_tens
00009ee8 g     F .text	00000094 usb_init
00007720  w    F .text	00000004 SdSpiCard::type() const
0000ae90 g     F .text	00000040 .hidden __fixunsdfsi
00009410  w    F .text	00000006 lptmr_isr
00000dcc  w    F .text	00000058 SDFile::seek(unsigned long long, int)
2001a81c g     O .bss	00000004 __malloc_top_pad
00009474 g     F .text	00000020 rtc_set
000122b8 g     F .text	0000003a __ssrefill_r
000078b2 g     F .text	0000006a SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
00005366 g     F .text	000000be ExFatFile::truncate()
1fff0f30 g     O .data	00000000 .hidden __dso_handle
0000a7f4 g     F .text	0000001e .hidden __aeabi_ui2d
000111e8 g     F .text	0000001c _localeconv_r
1fff0f3c g     O .data	00000004 sd_str
00012110 g     F .text	00000024 _strtoull_r
00009458 g     F .text	00000010 attachInterruptVector
00011474 g     F .text	00000012 __i2b
1fff0f30 g       .data	00000000 _sdata
00012924 g     O .text	00000020 TwoWire::i2c0_hardware
000058c0 g     F .text	000001a8 FatFormatter::makeFat32()
0000afa0 g     F .text	000002e2 .hidden __udivmoddi4
0000a570 g     F .text	00000000 .hidden __aeabi_drsub
00005cee g     F .text	00000036 FatFile::addCluster()
0000beb4 g     F .text	00000024 _sbrk_r
00007c40 g     F .text	00000036 SdSpiCard::readRegister(unsigned char, void*)
000081bc g     F .text	00000020 SdioCard::type() const
000001d0 g     F .text	000001f0 ResetHandler
00009128 g     F .text	0000004c usb_serial_getchar
00009410  w    F .text	00000006 can1_bus_off_isr
000019dc  w    F .text	00000018 FsVolume::clusterCount() const
00009410  w    F .text	00000006 ftm2_isr
00000b00  w    F .text	00000040 SDFile::name()
2001a848 g     O .bss	00000008 usb_cdc_line_coding
00009498 g     F .text	00000040 digitalWrite
2001a7ec g     O .bss	00000004 EventResponder::lastYield
00009410  w    F .text	00000006 uart5_status_isr
00009410  w    F .text	00000006 lpuart0_status_isr
00004122 g     F .text	00000026 ExFatFile::openRoot(ExFatVolume*)
000130b2 g     O .text	00000004 usb_endpoint_config_table
00009410  w    F .text	00000006 dma_ch9_isr
00000764  w    F .text	0000001c Print::write(char const*)
00000d7a  w    F .text	00000020 StreamFile<FsBaseFile, unsigned long long>::read()
00009410  w    F .text	00000006 pit2_isr
000039c8 g     F .text	00000028 ExFatFormatter::syncUpcase()
00000e90  w    F .text	00000036 SDFile::setModifyTime(DateTimeFields const&)
0000adc4 g     F .text	00000012 .hidden __aeabi_dcmplt
00012a6c g     O .text	0000005c SPISettings::ctar_clock_table
2001a818 g     O .bss	00000004 __malloc_max_sbrked_mem
00000bd0  w    F .text	00000018 SDFile::position()
000094d8 g     F .text	00000064 pinMode
0000254c g     F .text	00000034 getTeensySerial()
00007e96 g     F .text	00000028 SdSpiCard::writeStop()
000096ec g     F .text	00000044 usb_free
00009410  w    F .text	00000006 i2c3_isr
0000a838 g     F .text	0000003a .hidden __extendsfdf2
0000e874 g     F .text	00000e88 __ssvfscanf_r
0000ab34 g     F .text	000001d0 .hidden __aeabi_ddiv
00000d62  w    F .text	00000018 FsBaseFile::read(void*, unsigned int)
0000a57c g     F .text	00000276 .hidden __adddf3
1fff0f44 g     O .data	0000013c Wire2
0000079c g     F .text	00000030 checkToCloseFile(short, unsigned long)
00007f0a g     F .text	0000002c SdSpiCard::writeData(unsigned char const*)
000009d6  w    F .text	00000010 File::peek()
00006c2c g     F .text	0000005c FatPartition::freeClusterCount()
0000101c  w    F .text	00000078 SDClass::open(char const*, unsigned char)
000118b4 g     F .text	000000d0 __b2d
000022f2 g     F .text	00000002 adc_init()
0001354c g       .ARM.exidx	00000000 __exidx_start
0000a8e0 g     F .text	00000254 .hidden __aeabi_dmul
0000046c  w    F .text	0000000c DMAChannel::~DMAChannel()
00007dd4 g     F .text	00000030 SdSpiCard::writeStart(unsigned long)
00009410  w    F .text	00000006 pit0_isr
2001a7f0 g     O .bss	00000004 EventResponder::firstYield
0001310c g     O .text	00000004 _global_impure_ptr
00000780  w    F .text	00000008 Print::print(unsigned long)
00009410  w    F .text	00000006 can1_error_isr
00003580 g     F .text	00000084 FsUtf::mbToCp(char const*, char const*, unsigned long*)
00000f1a  w    F .text	00000018 StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)
00000f58  w    F .text	0000003c SDFile::SDFile(FsFile const&)
0000bad4 g     F .text	000003de _realloc_r
00000d9a  w    F .text	0000000a SDFile::read(void*, unsigned int)
0000b2a0 g     F .text	00000050 __libc_init_array
2001a860 g       .bss	00000000 __bss_end
00000c92  w    F .text	00000028 SDFile::rewindDirectory()
000025bc  w    F .text	0000000c TwoWire::available()
00009410  w    F .text	00000006 can0_wakeup_isr
0000484e g     F .text	0000000e ExFatFile::open(ExFatVolume*, char const*, int)
000080fc g     F .text	0000001c SdioCard::readCID(CID*)
00013324 g     O .text	00000100 __hexdig
00004fca g     F .text	000000de ExFatFile::addDirCluster()
00009410  w    F .text	00000006 flash_cmd_isr
00007d1c g     F .text	00000076 SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)
00007ebe g     F .text	0000004c SdSpiCard::writeData(unsigned char, unsigned char const*)
000134f0 g     O .text	00000028 __mprec_bigtens
00011340 g     F .text	00000098 __s2b
00002a08 g     F .text	000001bc TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)
0000a194  w    F .text	00000004 usb_serial_class::clear()
0000a7f4 g     F .text	0000001e .hidden __floatunsidf
00009410  w    F .text	00000006 uart2_status_isr
00009428 g     F .text	0000002c _sbrk
00001828  w    F .text	0000001c MySpiClass::send(unsigned char)
00011708 g     F .text	00000042 __mcmp
00012ac8 g     O .text	00000030 vtable for SDClass
1fff133c g     O .data	00000004 __brkval
2001a6f8 g     O .bss	00000001 usb_cdc_line_rtsdtr
00009394 g     F .text	00000048 usb_serial_flush_callback
00013524 g     F .text	00000000 _init
00005db0 g     F .text	0000001e FatFile::cacheDirEntry(unsigned char)
00009410  w    F .text	00000006 svcall_isr
000031a6  w    F .text	00000056 SDClass::remove(char const*)
00000ccc  w    F .text	00000026 SDFile::close()
00009410  w    F .text	00000006 dma_ch15_isr
00000cf4  w    F .text	00000024 SDFile::~SDFile()
0000aed0 g     F .text	0000009e .hidden __aeabi_d2f
00012984 g     O .text	00000024 vtable for TwoWire
00009410  w    F .text	00000006 uart1_error_isr
000107cc g     F .text	00000028 __libc_fini_array
0000c138 g     F .text	00000ed8 _strtod_l
00011018 g     F .text	00000030 __match
00009410  w    F .text	00000006 usbhs_phy_isr
2001a860 g       .bss	00000000 _ebss
000086b0 g     F .text	00000078 SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
1fff220c g     O .bss	00000004 hour_
00000e38  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::flush()
000022a0  w    F .text	00000008 TwoWire::write(int)
00001752  w    F .text	00000034 BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)
000113d8 g     F .text	00000040 __hi0bits
00004096 g     F .text	00000038 ExFatFile::dirCache(unsigned char, unsigned char)
0000ae40 g     F .text	0000004e .hidden __fixdfsi
000050a8 g     F .text	00000048 ExFatFile::mkdir(ExFatFile*, ExName_t*)
00009410 g     F .text	00000006 unused_isr
00000f58  w    F .text	0000003c SDFile::SDFile(FsFile const&)
00009410  w    F .text	00000006 spi0_isr
00009410  w    F .text	00000006 dma_ch3_isr
0000310c  w    F .text	00000002 SDClass::~SDClass()
00004c98 g     F .text	00000054 ExFatVolume::chdir(char const*)
0000046c  w    F .text	0000000c DMAChannel::~DMAChannel()
200191bc g     O .bss	00001000 diskBuffer
20017c34 g     O .bss	000004c8 sdx
0000708c g     F .text	00000092 FatFile::makeUniqueSfn(FatName_t*)
00000ba0  w    F .text	0000001c File::~File()
00001b58 g     F .text	00000210 storage_configure()
00005a68 g     F .text	000000a0 FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)
00005b22 g     F .text	00000028 FatFile::getLfnChar(DirLfn_t*, unsigned char)
0000a3e0 g     F .text	00000004 operator delete(void*, unsigned int)
00009410  w    F .text	00000006 flash_error_isr
0000a558 g     F .text	00000018 .hidden __lshrdi3
0000a57c g     F .text	00000276 .hidden __aeabi_dadd
1fff2210 g     O .bss	00000014 file
0000ad0c g     F .text	00000082 .hidden __ledf2
00009410  w    F .text	00000006 uart5_error_isr
00009410  w    F .text	00000006 rtc_seconds_isr
000129d8 g     O .text	00000094 SPIClass::spi0_hardware
00009410  w    F .text	00000006 pdb_isr
000115b8 g     F .text	000000a0 __pow5mult
0000620c g     F .text	0000004e FatFile::rmdir()
0000a874 g     F .text	0000006a .hidden __aeabi_ul2d
000093dc  w    F .text	00000034 usage_fault_isr
00009410  w    F .text	00000006 dac1_isr
00000000 g     O .text	000001d0 _VectorsFlash
00006b66 g     F .text	00000080 FatPartition::allocateCluster(unsigned long, unsigned long*)
00009410  w    F .text	00000006 dma_ch14_isr
0000a13e  w    F .text	00000006 MillisTimer::enableTimerInterrupt(bool)
0000310e  w    F .text	00000044 SDClass::exists(char const*)
00000000  w      *UND*	00000000 __deregister_frame_info
2001a850 g     O .bss	00000004 usb_cdc_line_rtsdtr_millis
00000788  w    F .text	00000014 Print::println(char const*)
0000a184 g     F .text	00000010 systick_isr
000006c4 g     F .text	0000001e extract(void*, void*)
000012d4 g     F .text	0000004c menuGet3Int(int*, int*, int*)
00009410  w    F .text	00000006 rtc_alarm_isr
200191ac g     O .bss	0000000c mySpi
00007cb6 g     F .text	00000066 SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)
00009410  w    F .text	00000006 dma_ch2_isr
1fff1348 g     O .data	00000010 Serial
00009410  w    F .text	00000006 ftm1_isr
0000a1b4  w    F .text	00000006 usb_serial_class::write(unsigned char)
000075c2 g     F .text	0000005e FsBaseFile::openNext(FsBaseFile*, int)
00009418  w    F .text	0000000c startup_early_hook
00007f36 g     F .text	00000048 SdSpiCard::writeSingle(unsigned long, unsigned char const*)
00009410  w    F .text	00000006 dma_ch13_isr
00004d40 g     F .text	00000092 ExFatFile::addCluster()
00012570  w    O .text	0000002c vtable for File
00009410  w    F .text	00000006 uart2_error_isr
000032d8  w    F .text	00000036 SDClass::usedSize()
00009174 g     F .text	00000038 usb_serial_peekchar
0000ae00 g     F .text	00000012 .hidden __aeabi_dcmpgt
00001140 g     F .text	000000d4 printMenu()
0000b900 g     F .text	00000000 memchr
00006b0a g     F .text	0000005c FatPartition::fatPut(unsigned long, unsigned long)
1fff13e4 g     O .data	00000016 usb_string_serial_number_default
000093dc g     F .text	00000034 fault_isr
00010890 g     F .text	000001d0 _free_r
00008520 g     F .text	00000088 SdioCard::readStop()
0000388e g     F .text	0000004e FsCache::get(unsigned long, unsigned char)
0000b308 g     F .text	0000001c __locale_mb_cur_max
0000adec g     F .text	00000012 .hidden __aeabi_dcmpge
00009410  w    F .text	00000006 usb_charge_isr
00006f64 g     F .text	00000128 FatFile::makeSFN(FatName_t*)
0000a1a4  w    F .text	00000004 usb_serial_class::flush()
00003a4e g     F .text	00000090 ExFatFormatter::writeUpcase(unsigned long)
00012234 g     F .text	00000082 _sungetc_r
00009410  w    F .text	00000006 cmt_isr
0000a578 g     F .text	0000027a .hidden __aeabi_dsub
00006c88 g     F .text	00000108 FatPartition::init(BlockDeviceInterface*, unsigned char)
00009410  w    F .text	00000006 usbhs_isr
1fff1da4 g     O .data	00000004 __malloc_sbrk_base
0000a19c  w    F .text	00000004 usb_serial_class::read()
00009410  w    F .text	00000006 ftm3_isr
00011d74 g     F .text	00000024 _strtoll_r
00009410  w    F .text	00000006 tsi0_isr
00007408 g     F .text	000000b2 FatFile::remove()
0000a874 g     F .text	0000006a .hidden __floatundidf
20017c30 g     O .bss	00000004 msd
00009454  w    F .text	00000002 __cxa_pure_virtual
000022f4 g     F .text	00000002 adcStatus()
00011658 g     F .text	000000ae __lshift
00006510 g     F .text	000000aa FatFile::mkdir(FatFile*, char const*, bool)
000004e0 g     F .text	00000014 acq_stop()
00009410  w    F .text	00000006 spi2_isr
00012134 g     F .text	00000100 __ssprint_r
000123f0 g     F .text	0000005e _vasnprintf_r
0000a3da  w    F .text	00000002 serialEvent()
2001a769 g     O .bss	00000001 usb_reboot_timer
0000f7a8 g     F .text	000000a4 __register_exitproc
00004794 g     F .text	000000ba ExFatFile::open(ExFatFile*, char const*, int)
0000c05c g     F .text	000000a0 strncmp
00000e4c  w    F .text	00000044 FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
000050f0 g     F .text	000000be ExFatFile::mkdir(ExFatFile*, char const*, bool)
000057bc g     F .text	00000104 FatFormatter::makeFat16()
000091c8 g     F .text	00000030 usb_serial_flush_input
00004b50 g     F .text	00000064 ExFatPartition::freeClusterCount()
00011488 g     F .text	00000130 __multiply
1fff1dc4 g     O .bss	00000004 acq_count
000092d8 g     F .text	00000016 usb_serial_putchar
00000022 g       *ABS*	00000000 _teensy_model_identifier
2001a820 g     O .bss	00000028 __malloc_current_mallinfo
00011984 g     F .text	000000ba __d2b
2001a7f8 g     O .bss	00000018 HardwareSerial::s_serials_with_serial_events
00009410  w    F .text	00000006 can0_bus_off_isr
000081ac  w    F .text	0000000e SdioCard::~SdioCard()
00001a6c  w    F .text	0000000c SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)
2001a7d6 g     O .bss	00000001 usb_rx_memory_needed
0000863c g     F .text	00000074 SdioCard::writeStart(unsigned long)
00011f00 g     F .text	00000024 _strtoul_r
000098c4 g     F .text	00000624 usb_isr
0000b288 g     F .text	0000000c __cxa_atexit
000041c4 g     F .text	00000184 ExFatFile::read(void*, unsigned int)
2001a1bc g     O .bss	00000004 i2c
0000a814 g     F .text	00000022 .hidden __aeabi_i2d
00000d58  w    F .text	0000000a SDFile::peek()
00003842 g     F .text	0000004c FsCache::sync()
1fff12f8 g     O .data	00000040 SPI
0000b9a0 g     F .text	00000062 memcmp
00013088  w    O .text	00000028 vtable for usb_serial_class
00006e90 g     F .text	000000d4 FatFile::createLFN(unsigned short, FatName_t*, unsigned char)
00009410  w    F .text	00000006 uart3_error_isr
00001b3c g     F .text	0000001c sdCsWrite(unsigned char, bool)
0000bf24 g     F .text	00000058 sscanf
0000b284  w    F .text	00000002 .hidden __aeabi_ldiv0
00004e58 g     F .text	00000052 ExFatFile::rmdir()
00001298 g     F .text	0000003c menuGetInt(int*)
00009410  w    F .text	00000006 porta_isr
000019bc  w    F .text	00000020 FsVolume::bytesPerCluster() const
0000ab34 g     F .text	000001d0 .hidden __divdf3
00011aa0 g     F .text	00000046 __copybits
1fff0bd0 g     O .usbbuffers	00000360 usb_buffer_memory
00007734 g     F .text	00000080 SdSpiCard::sectorCount()
00009410  w    F .text	00000006 low_voltage_isr
1fff1998 g     O .data	00000408 __malloc_av_
00009410  w    F .text	00000006 can0_error_isr
1fff21d4 g     O .bss	00000004 max_write
000095a4 g     F .text	0000010c _init_Teensyduino_internal_
00000e42  w    F .text	0000000a SDFile::flush()
0000a8e0 g     F .text	00000254 .hidden __muldf3
00009338 g     F .text	0000005c usb_serial_flush_output
00009410  w    F .text	00000006 dma_ch12_isr
0000bacc g     F .text	00000002 __malloc_lock
00003f84 g     F .text	000000b0 ExFatFile::getName8(char*, unsigned int)
00000000  w      *UND*	00000000 __fini_array_start
00009410  w    F .text	00000006 can1_wakeup_isr
1fff0a00 g     O .dmabuffers	000001d0 _VectorsRam
0000565c g     F .text	000000a8 FatFormatter::initFatDir(unsigned char, unsigned long)
00012450 g     F .text	0000005e _calloc_r
00009410  w    F .text	00000006 pit3_isr
00002c0c g     F .text	00000078 SPIClass::begin()
1fff0f34 g     O .data	00000004 t_acq
1fff1344 g     O .data	00000001 yield_active_check_flags
00009410  w    F .text	00000006 enet_rx_isr
00004f8c g     F .text	0000003e ExFatFile::sync()
000065ba g     F .text	00000196 FatFile::rename(FatFile*, char const*)
00008ecc g     F .text	00000070 SdioCard::isBusy()
00009410  w    F .text	00000006 portc_isr
00007d92 g     F .text	00000026 SdSpiCard::readStop()
000090e4 g     F .text	00000000 memset
00001a90 g     F .text	00000018 getCount()
0000a34a g     F .text	00000010 main
1fff21e4 g     O .bss	00000004 max_count
20018150 g     O .bss	00000008 rawData
2001a814 g     O .bss	00000004 __malloc_max_total_mem
0000488a g     F .text	000000a6 ExFatPartition::bitmapFind(unsigned long, unsigned long)
00001dc4 g     F .text	00000006 checkReboot()
00005424 g     F .text	00000210 ExFatFile::write(void const*, unsigned int)
000093dc  w    F .text	00000034 memmanage_fault_isr
000037b4 g     F .text	0000008e lbaToMbrChs(unsigned char*, unsigned long, unsigned long)
000063a2 g     F .text	00000034 FatFile::dirEntry(DirFat_t*)
00000c5e  w    F .text	0000000a SDFile::available()
00000f3c  w    F .text	0000001c File::close()
0000a49c g     F .text	00000070 usb_init_serialnumber
000016e4 g     F .text	00000036 setRTCTime(int, int, int, int, int, int)
0000d168 g     F .text	00000024 _strtol_r
0000aed0 g     F .text	0000009e .hidden __truncdfsf2
00013548 g       .text	00000000 __init_array_end
0000f998 g     F .text	00000e34 _dtoa_r
0000b360 g     F .text	00000570 _malloc_r
2001a810 g     O .bss	00000001 HardwareSerial::s_count_serials_with_serial_events
00009410  w    F .text	00000006 debugmonitor_isr
0000f760 g     F .text	0000001a __ascii_wctomb
00000d2c  w    F .text	0000000a SDFile::isOpen()
000074ba g     F .text	00000062 FsBaseFile::FsBaseFile(FsBaseFile const&)
0000a884 g     F .text	0000005a .hidden __aeabi_l2d
2001a698 g     O .bss	00000004 FatVolume::m_cwv
000019a0  w    F .text	00000008 Print::print(char const*)
00012378 g     F .text	00000078 __submore
0000a394 g     F .text	00000046 Stream::readBytesUntil(char, char*, unsigned int)
00002e58 g     F .text	000001cc SPIClass::transfer(void const*, void*, unsigned int)
6200ede2 g       *ABS*	00000000 __rtc_localtime
0000953c g     F .text	0000003c micros
00000000  w      *UND*	00000000 __libc_fini
00009410  w    F .text	00000006 cmp1_isr
00009410  w    F .text	00000006 ftm0_isr
00004eac g     F .text	000000e0 ExFatFile::syncDir()
0000265c g     F .text	00000034 TwoWire::setClock(unsigned long)
000107f4 g     F .text	0000009c _malloc_trim_r
1fff13e0 g     O .data	00000004 string0
000091f8 g     F .text	000000e0 usb_serial_write
00009424  w    F .text	00000002 startup_late_hook
00000c00  w    F .text	00000054 FsBaseFile::available() const
0000a1a0  w    F .text	00000004 usb_serial_class::available()
1fff1358 g     O .data	00000001 _serialEvent_default
0000625c g     F .text	00000080 FatFile::sync()
00000538 g     F .text	0000018c acq_init(int)
00006df4 g     F .text	0000009c FatFile::cmpName(unsigned short, FatName_t*, unsigned char)
000031fc  w    F .text	0000004e SDClass::mkdir(char const*)
00004d1a  w    F .text	00000026 ExFatPartition::cacheSync()
1fff13ca  w    O .data	00000016 usb_string_product_name
00009578 g     F .text	0000002a delay
0000ad14 g     F .text	0000007a .hidden __nedf2
00009410  w    F .text	00000006 tpm0_isr
2001a7e2 g     O .bss	00000002 dma_channel_allocated_mask
00004102 g     F .text	00000020 ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)
00000da4  w    F .text	00000028 FsBaseFile::seekSet(unsigned long long)
00013548 g     F .fini	00000000 _fini
00000e24  w    F .text	00000014 FsBaseFile::sync()
000025fe g     F .text	00000026 TwoWire::write(unsigned char)
000129a8 g     O .text	0000002e SPISettings::ctar_div_table
00007c86 g     F .text	00000030 SdSpiCard::readStart(unsigned long)
0000485c g     F .text	0000002e ExFatFile::openNext(ExFatFile*, int)
0000791c g     F .text	00000076 SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)
0000bed8 g     F .text	0000004c sprintf
0000a204 g     F .text	0000001a Print::printf(char const*, ...)
00009410  w    F .text	00000006 i2s0_rx_isr
00009410  w    F .text	00000006 uart4_error_isr
0000a294 g     F .text	00000010 Print::print(long)
000062dc g     F .text	00000010 FatFile::close()
00000d18  w    F .text	00000014 SDFile::~SDFile()
0000f860 g     F .text	0000000c atexit
00008144  w    F .text	00000002 SdioCard::~SdioCard()
00000d4e  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::peek()
00000a18  w    F .text	0000001c File::write(unsigned char)
0000f77c g     F .text	0000002c _write_r
2001a1c8 g     O .bss	000004c8 SD
000014f8 g     F .text	0000012c breakTime(unsigned long, tmElements_t&)
000083ec g     F .text	000000d8 SdioCard::erase(unsigned long, unsigned long)
00006a80  w    F .text	00000020 FsCache::clear()
00009410  w    F .text	00000006 can0_message_isr
00002c84 g     F .text	0000009c SPIClass::setMOSI(unsigned char)
00011bbc g     F .text	0000000c nanf
1fff1828 g     O .data	00000004 _impure_ptr
00012504  w    O .text	00000024 vtable for Stream
00009410  w    F .text	00000006 can1_message_isr
00004348 g     F .text	0000002c ExFatFile::peek()
00012528  w    O .text	00000024 vtable for StreamFile<FsBaseFile, unsigned long long>
00011204 g     F .text	0000005c _mbrtowc_r
00009410  w    F .text	00000006 nmi_isr
1fff1080 g     O .data	0000013c Wire
00001a0c  w    F .text	00000060 SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)
00000f32  w    F .text	0000000a SDFile::write(void const*, unsigned int)
000076dc g     F .text	00000028 FsVolume::open(char const*, int)
000080e4 g     F .text	0000000c SdioCard::errorCode() const
00006394 g     F .text	0000000e FatFile::open(FatVolume*, char const*, int)
00000f10  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)
1fff222c g     O .bss	00000004 diskSize
00013530 g       .text	00000000 __preinit_array_end
00001846 g     F .text	00000076 dateTime(unsigned short*, unsigned short*, unsigned char*)
00007724  w    F .text	00000002 SdSpiCard::~SdSpiCard()
00009410  w    F .text	00000006 sdhc_isr
00004bb4 g     F .text	000000cc ExFatPartition::init(BlockDeviceInterface*, unsigned char)
000049d6 g     F .text	00000036 ExFatPartition::dirCache(DirPos_t*, unsigned char)
00007e04 g     F .text	00000092 SdSpiCard::erase(unsigned long, unsigned long)
0000b8d0 g     F .text	0000002a __ascii_mbtowc
00007820 g     F .text	00000032 SdSpiCard::isBusy()
00011860 g     F .text	00000054 __ulp
00012dc8 g     O .text	00000060 vtable for SdSpiCard
00007c7e  w    F .text	00000008 SdSpiCard::readCID(CID*)
000025e6  w    F .text	00000016 TwoWire::peek()
000025fc  w    F .text	00000002 TwoWire::flush()
000007cc g     F .text	0000008c setup
000130b8 g     O .text	00000054 usb_descriptor_list
00009770 g     F .text	00000038 usb_rx
00008260 g     F .text	00000004 SdioCard::status()
00009410  w    F .text	00000006 dma_ch10_isr
000018bc  w    F .text	00000014 MySpiClass::send(unsigned char const*, unsigned int)
000063f6 g     F .text	00000020 FatFile::getModifyDateTime(unsigned short*, unsigned short*)
000009bc  w    F .text	00000002 Print::flush()
00000cba  w    F .text	00000012 FsBaseFile::isOpen() const
0000ae90 g     F .text	00000040 .hidden __aeabi_d2uiz
00009410  w    F .text	00000006 uart0_error_isr
00000c68  w    F .text	00000020 FsBaseFile::isDir() const
00003152  w    F .text	00000054 SDClass::rmdir(char const*)
00012834  w    O .text	00000028 vtable for MySpiClass
000096b0 g     F .text	0000003c usb_malloc
00005e2c g     F .text	00000178 FatFile::read(void*, unsigned int)
00009410  w    F .text	00000006 i2s0_isr
00005dce g     F .text	00000030 FatFile::openRoot(FatVolume*)
2001a694 g     O .bss	00000004 ExFatVolume::m_cwv
000019f4  w    F .text	00000018 FsVolume::freeClusterCount() const
20030000 g       .bss	00000000 _estack
00007704 g     F .text	00000004 operator new(unsigned int, unsigned long*)
00007c76  w    F .text	00000008 SdSpiCard::readCSD(csd_t*)
0000a0fc g     F .text	00000034 DMAChannel::release()
000009f2  w    F .text	00000026 File::read()
000092f0 g     F .text	00000048 usb_serial_write_buffer_free
00007992 g     F .text	00000028 SdSpiCard::waitNotBusy(unsigned short)
000077fa g     F .text	00000026 SdSpiCard::spiStop()
00009410  w    F .text	00000006 enet_timer_isr
00007120 g     F .text	00000250 FatFile::open(FatFile*, FatName_t*, int)
0000adb0 g     F .text	00000012 .hidden __aeabi_dcmpeq
00001624 g     F .text	000000c0 makeTime(tmElements_t const&)
00002624 g     F .text	00000038 TwoWire::write(unsigned char const*, unsigned int)
00000bbc  w    F .text	00000014 File::~File()
00002580 g     F .text	0000003c _write
1fff1da8 g       .data	00000000 _edata
00004ab8 g     F .text	0000003a ExFatPartition::fatPut(unsigned long, unsigned long)
00008144  w    F .text	00000002 SdioCard::~SdioCard()
00009410  w    F .text	00000006 i2s0_tx_isr
00009410  w    F .text	00000006 adc1_isr
00003980 g     F .text	00000048 FsName::get16()
00007db8 g     F .text	0000001c SdSpiCard::syncDevice()
00004034 g     F .text	00000062 ExFatFile::hashName(ExName_t*)
00005d24 g     F .text	0000008c FatFile::addDirCluster()
00006416 g     F .text	000000fa FatFile::mkdir(FatFile*, FatName_t*)
0000a1a8  w    F .text	00000004 usb_serial_class::availableForWrite()
00009410  w    F .text	00000006 cmp0_isr
00001980  w    F .text	00000020 MySpiClass::receive()
00006a56 g     F .text	0000002a FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)
0000a50c g     F .text	00000040 ultoa
0000310c  w    F .text	00000002 SDClass::~SDClass()
00007a54 g     F .text	000001b4 SdSpiCard::begin(SdSpiConfig)
00002690 g     F .text	0000008c TwoWire::begin()
00007544 g     F .text	0000007e FsBaseFile::open(FsVolume*, char const*, int)
0000a130  w    F .text	0000000e MillisTimer::disableTimerInterrupt()
0000a3dc g     F .text	00000004 operator new(unsigned int)
0000a144 g     F .text	0000003c EventResponder::runFromInterrupt()
00001214 g     F .text	00000084 printMenuEntries()
1fff1da0 g     O .data	00000004 __malloc_trim_threshold
0000a198  w    F .text	00000004 usb_serial_class::peek()
0001174c g     F .text	00000114 __mdiff
00008134 g     F .text	00000010 SdioCard::readOCR(unsigned long*)
0000ae40 g     F .text	0000004e .hidden __aeabi_d2iz
00004a74 g     F .text	00000044 ExFatPartition::dirSeek(DirPos_t*, unsigned long)
2001a6e8 g     O .bss	00000001 usb_cdc_transmit_flush_timer
00005bd4 g     F .text	000000f0 FatFile::getName8(char*, unsigned int)
00004444 g     F .text	00000350 ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)
00009410  w    F .text	00000006 pit_isr
00008520 g     F .text	00000088 SdioCard::writeStop()
00007f7e  w    F .text	0000001c SdSpiCard::writeSector(unsigned long, unsigned char const*)
00011b48 g     F .text	00000072 __sccl
000040ce g     F .text	00000014 ExFatFile::close()
00013210 g     O .text	00000101 _ctype_
00009410  w    F .text	00000006 dac0_isr
00007710  w    F .text	00000010 SdSpiCard::readSector(unsigned long, unsigned char*)
000022f8 g     F .text	00000240 adc_enable(unsigned int, unsigned long)
00013530 g       .text	00000000 __init_array_start
0000b284  w    F .text	00000002 .hidden __aeabi_idiv0
00009410  w    F .text	00000006 can1_tx_warn_isr
0000ae14 g     F .text	0000002c .hidden __unorddf2
200191b8 g     O .bss	00000004 disk_count
000039f0 g     F .text	00000042 ExFatFormatter::writeUpcaseByte(unsigned char)
00003604 g     F .text	000001b0 FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)
0000324a  w    F .text	00000068 SDClass::rename(char const*, char const*)
00009410  w    F .text	00000006 uart0_status_isr
00006d90 g     F .text	00000046 FatVolume::chdir(char const*)
000004c8 g     F .text	00000018 acq_start()
00009410  w    F .text	00000006 mcg_isr
0000a35c g     F .text	00000038 Stream::timedRead()
00000400 g     O .text	00000010 flashconfigbytes
0000a054 g     F .text	000000a8 DMAChannel::begin(bool)
0000bf80 g     F .text	000000dc strlen
00005dfe g     F .text	0000002e FatFile::openCluster(FatFile*)
0000b324 g     F .text	00000006 __locale_ctype_ptr_l
0000330e  w    F .text	00000036 SdBase<FsVolume>::begin(SdioConfig)
0000ada0 g     F .text	00000010 .hidden __aeabi_cdcmpeq
0000ad04 g     F .text	0000008a .hidden __gedf2
00006006 g     F .text	000000ac FatFile::seekSet(unsigned long)
00007370 g     F .text	00000098 FatFile::parsePathName(char const*, FatName_t*, char const**)
00010b08 g     F .text	00000510 __gethex
1fff13ca g     O .data	00000016 usb_string_product_name_default
0000f748 g     F .text	00000018 vdprintf
00009410  w    F .text	00000006 dma_ch1_isr
00008388 g     F .text	00000064 SdioCard::sectorCount()
00007620 g     F .text	000000bc FsVolume::begin(BlockDeviceInterface*)
000018d0  w    F .text	00000024 MySpiClass::receive(unsigned char*, unsigned int)
000097a8 g     F .text	00000024 usb_tx_packet_count
00006174 g     F .text	00000098 FatFile::openNext(FatFile*, int)
1fff2224 g     O .bss	00000004 diskSpace
000004f4 g     F .text	00000044 mckl_init(int, int, int)
00009494  w    F .text	00000002 startup_middle_hook
00012e28 g     O .text	00000060 vtable for SdioCard
0000a838 g     F .text	0000003a .hidden __aeabi_f2d
00009410  w    F .text	00000006 dma_ch5_isr
00005cc4 g     F .text	00000004 FatFile::getName(char*, unsigned int)
00009410  w    F .text	00000006 can0_rx_warn_isr
00001a6c  w    F .text	0000000c SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)
00009410  w    F .text	00000006 can0_tx_warn_isr
00009410  w    F .text	00000006 uart4_status_isr
00008d18 g     F .text	00000074 SdioCard::readStart(unsigned long)
00000000  w      *UND*	00000000 _Jv_RegisterClasses
00005b08  w    F .text	0000001a FatFile::cacheDir(unsigned short)
0000a578 g     F .text	0000027a .hidden __subdf3
00001adc g     F .text	00000044 pullData(unsigned long*, unsigned long)
00013530 g       .text	00000000 __preinit_array_start
00004930 g     F .text	000000a6 ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)
00000efc  w    F .text	00000014 FsBaseFile::write(void const*, unsigned int)
1fff2230 g     O .bss	00025800 data_buffer
00011418 g     F .text	0000005a __lo0bits
00004a4a g     F .text	0000002a ExFatPartition::chainSize(unsigned long)
000060b2 g     F .text	000000c2 FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)
00006750 g     F .text	000000ae FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
1fff0f40 g     O .data	00000004 stdPrint
0000171a  w    F .text	00000038 BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)
0000a54c g     F .text	0000000a __aeabi_atexit
00000000  w      *UND*	00000000 __register_frame_info
00009468 g     F .text	0000000c rtc_get
00004dd2 g     F .text	00000086 ExFatFile::remove()
00009410  w    F .text	00000006 cmp2_isr
0000a180 g     F .text	00000004 pendablesrvreq_isr
000032b2  w    F .text	00000026 SDClass::totalSize()
000009b8  w    F .text	00000004 Print::availableForWrite()
1fff182c g     O .data	0000016c __global_locale
00009410  w    F .text	00000006 wakeup_isr
00002d20 g     F .text	00000094 SPIClass::setMISO(unsigned char)
000088f8 g     F .text	0000035c SdioCard::begin(SdioConfig)
000040e2 g     F .text	00000020 ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)
00009410  w    F .text	00000006 cmp3_isr
0000a21e g     F .text	00000076 Print::printNumber(unsigned long, unsigned char, unsigned char)
00006aa0 g     F .text	0000006a FatPartition::fatGet(unsigned long, unsigned long*)
0000b350 g     F .text	00000010 free
00009410  w    F .text	00000006 tpm2_isr
00003f38 g     F .text	0000004c ExFatFile::cmpName(DirName_t const*, ExName_t*)
000112c0 g     F .text	00000080 __multadd
000112ac g     F .text	00000012 _Bfree
00000be8  w    F .text	00000018 SDFile::size()
00005b4a g     F .text	00000088 FatFile::getSFN(char*, unsigned int)
00009410  w    F .text	00000006 dma_ch0_isr
00000cf4  w    F .text	00000024 SDFile::~SDFile()
1fff13e4  w    O .data	00000016 usb_string_serial_number
00009410  w    F .text	00000006 enet_tx_isr
00008d8c g     F .text	000000c4 SdioCard::readSector(unsigned long, unsigned char*)
00008118 g     F .text	0000001c SdioCard::readCSD(csd_t*)



Disassembly of section .text:

00000000 <_VectorsFlash>:
  return fsFmtTime(str, time);
}
//------------------------------------------------------------------------------
char* fsFmtTimeZone(char* str, int8_t tz) {
  char sign;
  if (tz & 0X80) {
       0:	... ............
    if (tz & 0X40) {
      sign = '-';
      10:	................
    } else {
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      str = fsFmtField(str, 15*(tz%4), 0);
      20:	................
      30:	................
      str = fsFmtField(str, tz/4, ':');
      40:	................
      *--str = sign;
      50:	................
    }
    *--str = 'C';
    *--str = 'T';
    *--str = 'U';
      60:	................
      70:	................
      80:	................
      90:	................
      a0:	.+...+..........
      b0:	................
      c0:	................
      d0:	................
      e0:	................
      f0:	................
     100:	................
     110:	................
     120:	................
     130:	................
     140:	................
     150:	................
     160:	.........+......
     170:	................
     180:	................
     190:	................
     1a0:	................
     1b0:	................
     1c0:	................

000001d0 <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d0:	ldr	r3, [pc, #356]	; (338 <ResetHandler+0x168>)
     1d2:	movw	r2, #50464	; 0xc520
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
     1d6:	push	{r4, lr}
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d8:	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
     1da:	movw	r2, #55592	; 0xd928
     1de:	strh	r2, [r3, #0]
	__asm__ volatile ("nop");
     1e0:	nop
	__asm__ volatile ("nop");
     1e2:	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
     1e4:	bl	9418 <startup_early_hook>
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1e8:	ldr	r3, [pc, #336]	; (33c <ResetHandler+0x16c>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     1ea:	ldr	r1, [pc, #340]	; (340 <ResetHandler+0x170>)
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1ec:	mov.w	r2, #184549376	; 0xb000000
     1f0:	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
     1f2:	ldr	r2, [pc, #336]	; (344 <ResetHandler+0x174>)
     1f4:	str	r2, [r3, #8]
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
     1f6:	ldr	r2, [pc, #336]	; (348 <ResetHandler+0x178>)
     1f8:	str	r2, [r3, #12]
	SIM_SCGC4 = SIM_SCGC4_USBOTG | 0xF0000030;
	SIM_SCGC5 = 0x00003F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_ADC0 | SIM_SCGC6_TPM0 | SIM_SCGC6_TPM1 | SIM_SCGC6_TPM2 | SIM_SCGC6_FTFL;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SCB_CPACR = 0x00F00000;
     1fa:	ldr	r3, [pc, #336]	; (34c <ResetHandler+0x17c>)
     1fc:	mov.w	r2, #15728640	; 0xf00000
     200:	str	r2, [r3, #0]
#endif
#if defined(__MK66FX1M0__)
	LMEM_PCCCR = 0x85000003;
     202:	ldr	r3, [pc, #332]	; (350 <ResetHandler+0x180>)
     204:	ldr	r2, [pc, #332]	; (354 <ResetHandler+0x184>)
     206:	str	r2, [r3, #0]
		RTC_SR = 0;
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     208:	ldr	r3, [pc, #332]	; (358 <ResetHandler+0x188>)
     20a:	ldrb	r2, [r3, #0]
     20c:	lsls	r0, r2, #28
     20e:	ittt	mi
     210:	ldrbmi	r2, [r3, #0]
     212:	orrmi.w	r2, r2, #8
     216:	strbmi	r2, [r3, #0]

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     218:	ldr	r3, [pc, #320]	; (35c <ResetHandler+0x18c>)
     21a:	movs	r2, #170	; 0xaa
     21c:	strb	r2, [r3, #0]
     21e:	ldr	r2, [pc, #320]	; (360 <ResetHandler+0x190>)
     220:	ldr	r3, [pc, #320]	; (364 <ResetHandler+0x194>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     222:	cmp	r3, r1
     224:	bcs.n	230 <ResetHandler+0x60>
     226:	ldr.w	r0, [r2, #4]!
     22a:	str.w	r0, [r3], #4
     22e:	b.n	222 <ResetHandler+0x52>
     230:	ldr	r3, [pc, #308]	; (368 <ResetHandler+0x198>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     232:	ldr	r2, [pc, #312]	; (36c <ResetHandler+0x19c>)
     234:	movs	r1, #0
     236:	cmp	r3, r2
     238:	bcs.n	240 <ResetHandler+0x70>
     23a:	str.w	r1, [r3], #4
     23e:	b.n	236 <ResetHandler+0x66>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     240:	ldr	r2, [pc, #300]	; (370 <ResetHandler+0x1a0>)
     242:	ldr	r0, [pc, #304]	; (374 <ResetHandler+0x1a4>)
     244:	movs	r3, #0
     246:	ldr.w	r1, [r0, r3, lsl #2]
     24a:	str.w	r1, [r2, r3, lsl #2]
     24e:	adds	r3, #1
     250:	cmp	r3, #116	; 0x74
     252:	bne.n	246 <ResetHandler+0x76>
     254:	ldr	r3, [pc, #288]	; (378 <ResetHandler+0x1a8>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     256:	ldr	r2, [pc, #292]	; (37c <ResetHandler+0x1ac>)
     258:	movs	r1, #128	; 0x80
     25a:	strb.w	r1, [r3], #1
     25e:	cmp	r3, r2
     260:	bne.n	25a <ResetHandler+0x8a>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     262:	ldr	r3, [pc, #284]	; (380 <ResetHandler+0x1b0>)
     264:	ldr	r2, [pc, #264]	; (370 <ResetHandler+0x1a0>)
     266:	str	r2, [r3, #0]
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     268:	ldr	r3, [pc, #280]	; (384 <ResetHandler+0x1b4>)
     26a:	movs	r2, #138	; 0x8a
     26c:	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     26e:	sub.w	r3, r3, #4096	; 0x1000
     272:	movs	r2, #36	; 0x24
     274:	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     276:	movs	r2, #160	; 0xa0
     278:	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     27a:	ldrb	r2, [r3, #6]
     27c:	lsls	r1, r2, #30
     27e:	bpl.n	27a <ResetHandler+0xaa>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     280:	ldrb	r2, [r3, #6]
     282:	lsls	r2, r2, #27
     284:	bmi.n	280 <ResetHandler+0xb0>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     286:	ldr	r2, [pc, #256]	; (388 <ResetHandler+0x1b8>)
     288:	ldrb	r3, [r2, #6]
     28a:	and.w	r3, r3, #12
     28e:	cmp	r3, #8
     290:	ldr	r3, [pc, #244]	; (388 <ResetHandler+0x1b8>)
     292:	bne.n	288 <ResetHandler+0xb8>
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(2);
    #elif F_CPU == 120000000
	MCG_C5 = MCG_C5_PRDIV0(1);
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(14);
    #elif F_CPU == 96000000 || F_CPU == 48000000 || F_CPU == 24000000
	MCG_C5 = MCG_C5_PRDIV0(1);
     294:	movs	r2, #1
     296:	strb	r2, [r3, #4]
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(8);
     298:	movs	r2, #72	; 0x48
     29a:	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     29c:	ldrb	r2, [r3, #6]
     29e:	lsls	r4, r2, #26
     2a0:	bpl.n	29c <ResetHandler+0xcc>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     2a2:	ldr	r1, [pc, #228]	; (388 <ResetHandler+0x1b8>)
     2a4:	ldrb	r2, [r1, #6]
     2a6:	ldr	r3, [pc, #224]	; (388 <ResetHandler+0x1b8>)
     2a8:	lsls	r0, r2, #25
     2aa:	bpl.n	2a4 <ResetHandler+0xd4>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC;
#elif F_CPU == 96000000
	// config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash, USB = 96 / 2
	#if F_BUS == 48000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(3);
     2ac:	ldr	r2, [pc, #220]	; (38c <ResetHandler+0x1bc>)
     2ae:	ldr	r1, [pc, #224]	; (390 <ResetHandler+0x1c0>)
     2b0:	str	r1, [r2, #0]
	#elif F_BUS == 96000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(0) | SIM_CLKDIV1_OUTDIV4(3);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1);
     2b2:	movs	r1, #2
     2b4:	str	r1, [r2, #4]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     2b6:	movs	r2, #32
     2b8:	strb	r2, [r3, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     2ba:	ldrb	r2, [r3, #6]
     2bc:	and.w	r2, r2, #12
     2c0:	cmp	r2, #12
     2c2:	bne.n	2ba <ResetHandler+0xea>
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#else
	// USB uses PLL clock
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     2c4:	ldr	r3, [pc, #204]	; (394 <ResetHandler+0x1c4>)
     2c6:	ldr	r2, [pc, #208]	; (398 <ResetHandler+0x1c8>)
     2c8:	str	r2, [r3, #0]
#endif

#if defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started.  For Teensy 3.6
	// we don't do this early.  See comment above about slow rising power.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     2ca:	ldr	r2, [pc, #208]	; (39c <ResetHandler+0x1cc>)
     2cc:	ldr	r4, [pc, #208]	; (3a0 <ResetHandler+0x1d0>)
     2ce:	ldr	r3, [r2, #0]
     2d0:	ands.w	r3, r3, #256	; 0x100
		RTC_SR = 0;
     2d4:	ittt	eq
     2d6:	streq	r3, [r4, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     2d8:	moveq.w	r3, #5376	; 0x1500
     2dc:	streq	r3, [r2, #0]
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2de:	ldr	r3, [pc, #196]	; (3a4 <ResetHandler+0x1d4>)
     2e0:	ldr	r2, [pc, #196]	; (3a8 <ResetHandler+0x1d8>)
     2e2:	str	r2, [r3, #0]
	SYST_CVR = 0;
     2e4:	movs	r2, #0
     2e6:	str	r2, [r3, #4]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2e8:	movs	r2, #7
     2ea:	str.w	r2, [r3, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2ee:	ldr	r2, [pc, #188]	; (3ac <ResetHandler+0x1dc>)
     2f0:	str.w	r2, [r3, #3340]	; 0xd0c

	//init_pins();
	__enable_irq();
     2f4:	cpsie	i

	_init_Teensyduino_internal_();
     2f6:	bl	95a4 <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     2fa:	ldr	r3, [r4, #0]
     2fc:	lsls	r2, r3, #31
     2fe:	bpl.n	30c <ResetHandler+0x13c>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     300:	ldr	r0, [pc, #172]	; (3b0 <ResetHandler+0x1e0>)
     302:	bl	9474 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     306:	ldr	r3, [pc, #172]	; (3b4 <ResetHandler+0x1e4>)
     308:	ldr	r2, [pc, #172]	; (3b8 <ResetHandler+0x1e8>)
     30a:	str	r2, [r3, #0]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     30c:	ldr	r3, [pc, #172]	; (3bc <ResetHandler+0x1ec>)
     30e:	ldrb	r3, [r3, #0]
     310:	lsls	r3, r3, #25
     312:	bpl.n	328 <ResetHandler+0x158>
     314:	ldr	r4, [pc, #156]	; (3b4 <ResetHandler+0x1e4>)
     316:	ldr	r3, [pc, #160]	; (3b8 <ResetHandler+0x1e8>)
     318:	ldr	r2, [r4, #0]
     31a:	cmp	r2, r3
     31c:	bne.n	328 <ResetHandler+0x158>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     31e:	ldr	r0, [pc, #144]	; (3b0 <ResetHandler+0x1e0>)
     320:	bl	9474 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     324:	movs	r3, #0
     326:	str	r3, [r4, #0]
	}
#endif

	startup_late_hook();
     328:	bl	9424 <startup_late_hook>
	__libc_init_array();
     32c:	bl	b2a0 <__libc_init_array>

	main();
     330:	bl	a34a <main>
     334:	b.n	334 <ResetHandler+0x164>
     336:	nop
     338:	.word	0x4005200e
     33c:	.word	0x40048030
     340:	.word	0x1fff1da8
     344:	.word	0x00043f82
     348:	.word	0x2b000001
     34c:	.word	0xe000ed88
     350:	.word	0xe0082000
     354:	.word	0x85000003
     358:	.word	0x4007d002
     35c:	.word	0x4007e000
     360:	.word	0x00013550
     364:	.word	0x1fff0f30
     368:	.word	0x1fff1da8
     36c:	.word	0x2001a860
     370:	.word	0x1fff0a00
     374:	.word	0x00000000
     378:	.word	0xe000e400
     37c:	.word	0xe000e464
     380:	.word	0xe000ed08
     384:	.word	0x40065000
     388:	.word	0x40064000
     38c:	.word	0x40048044
     390:	.word	0x01030000
     394:	.word	0x40048004
     398:	.word	0x000510c0
     39c:	.word	0x4003d010
     3a0:	.word	0x4003d014
     3a4:	.word	0xe000e014
     3a8:	.word	0x000176ff
     3ac:	.word	0x20200000
     3b0:	.word	0x6200ede2
     3b4:	.word	0x4003e01c
     3b8:	.word	0x5a94c3a5
     3bc:	.word	0x4007f000
     3c0:	.word	0xffffffff
     3c4:	.word	0xffffffff
     3c8:	.word	0xffffffff
     3cc:	.word	0xffffffff
     3d0:	.word	0xffffffff
     3d4:	.word	0xffffffff
     3d8:	.word	0xffffffff
     3dc:	.word	0xffffffff
     3e0:	.word	0xffffffff
     3e4:	.word	0xffffffff
     3e8:	.word	0xffffffff
     3ec:	.word	0xffffffff
     3f0:	.word	0xffffffff
     3f4:	.word	0xffffffff
     3f8:	.word	0xffffffff
     3fc:	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	................

00000410 <__do_global_dtors_aux>:
     410:	push	{r4, lr}
     412:	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
     414:	ldrb	r3, [r4, #0]
     416:	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
     41a:	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
     41e:	nop.w
     422:	movs	r3, #1
     424:	strb	r3, [r4, #0]
     426:	pop	{r4, pc}
     428:	.word	0x1fff1da8
     42c:	.word	0x00000000
     430:	.word	0x0001354c

00000434 <frame_dummy>:
     434:	ldr	r3, [pc, #32]	; (458 <frame_dummy+0x24>)
     436:	push	{r4, lr}
     438:	cbz	r3, 442 <frame_dummy+0xe>
     43a:	ldr	r1, [pc, #32]	; (45c <frame_dummy+0x28>)
     43c:	ldr	r0, [pc, #32]	; (460 <frame_dummy+0x2c>)
     43e:	nop.w
     442:	ldr	r0, [pc, #32]	; (464 <frame_dummy+0x30>)
     444:	ldr	r3, [r0, #0]
     446:	cbnz	r3, 44a <frame_dummy+0x16>
     448:	pop	{r4, pc}
     44a:	ldr	r3, [pc, #28]	; (468 <frame_dummy+0x34>)
     44c:	cmp	r3, #0
     44e:	beq.n	448 <frame_dummy+0x14>
     450:	ldmia.w	sp!, {r4, lr}
     454:	bx	r3
     456:	nop
     458:	.word	0x00000000
     45c:	.word	0x1fff1dac
     460:	.word	0x0001354c
     464:	.word	0x1fff1da8
     468:	.word	0x00000000

0000046c <DMAChannel::~DMAChannel()>:
	}
	DMAChannel & operator = (const DMASetting &rhs) {
		copy_tcd(TCD, rhs.TCD);
		return *this;
	}
	~DMAChannel() {
     46c:	push	{r4, lr}
     46e:	mov	r4, r0
		release();
     470:	bl	a0fc <DMAChannel::release()>
	}
     474:	mov	r0, r4
     476:	pop	{r4, pc}

00000478 <acq_stopClocks()>:
    const int32_t fsamp0=(((F_PLL*MCLK_MULT)/MCLK_DIV)/512);

    
    void acq_stopClocks(void)
    {
        SIM_SCGC6 &= ~SIM_SCGC6_DMAMUX;
     478:	ldr	r3, [pc, #28]	; (498 <acq_stopClocks()+0x20>)
        SIM_SCGC7 &= ~SIM_SCGC7_DMA;
     47a:	ldr	r1, [pc, #32]	; (49c <acq_stopClocks()+0x24>)
    const int32_t fsamp0=(((F_PLL*MCLK_MULT)/MCLK_DIV)/512);

    
    void acq_stopClocks(void)
    {
        SIM_SCGC6 &= ~SIM_SCGC6_DMAMUX;
     47c:	ldr	r2, [r3, #0]
     47e:	bic.w	r2, r2, #2
     482:	str	r2, [r3, #0]
        SIM_SCGC7 &= ~SIM_SCGC7_DMA;
     484:	ldr	r2, [r1, #0]
     486:	bic.w	r2, r2, #2
     48a:	str	r2, [r1, #0]
        SIM_SCGC6 &= ~SIM_SCGC6_I2S;
     48c:	ldr	r2, [r3, #0]
     48e:	bic.w	r2, r2, #32768	; 0x8000
     492:	str	r2, [r3, #0]
     494:	bx	lr
     496:	nop
     498:	.word	0x4004803c
     49c:	.word	0x40048040

000004a0 <acq_startClocks()>:
    }

    void acq_startClocks(void)
    {
    SIM_SCGC6 |= SIM_SCGC6_I2S;
     4a0:	ldr	r3, [pc, #28]	; (4c0 <acq_startClocks()+0x20>)
    SIM_SCGC7 |= SIM_SCGC7_DMA;
     4a2:	ldr	r1, [pc, #32]	; (4c4 <acq_startClocks()+0x24>)
        SIM_SCGC6 &= ~SIM_SCGC6_I2S;
    }

    void acq_startClocks(void)
    {
    SIM_SCGC6 |= SIM_SCGC6_I2S;
     4a4:	ldr	r2, [r3, #0]
     4a6:	orr.w	r2, r2, #32768	; 0x8000
     4aa:	str	r2, [r3, #0]
    SIM_SCGC7 |= SIM_SCGC7_DMA;
     4ac:	ldr	r2, [r1, #0]
     4ae:	orr.w	r2, r2, #2
     4b2:	str	r2, [r1, #0]
    SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
     4b4:	ldr	r2, [r3, #0]
     4b6:	orr.w	r2, r2, #2
     4ba:	str	r2, [r3, #0]
     4bc:	bx	lr
     4be:	nop
     4c0:	.word	0x4004803c
     4c4:	.word	0x40048040

000004c8 <acq_start()>:
    }

    void acq_start(void)
    {
     4c8:	push	{r3, lr}
        acq_startClocks();
     4ca:	bl	4a0 <acq_startClocks()>
        //DMA_SERQ = dma.channel;
        I2S0_RCSR |= (I2S_RCSR_RE | I2S_RCSR_BCE);
     4ce:	ldr	r2, [pc, #12]	; (4dc <acq_start()+0x14>)
     4d0:	ldr	r3, [r2, #0]
     4d2:	orr.w	r3, r3, #2415919104	; 0x90000000
     4d6:	str	r3, [r2, #0]
     4d8:	pop	{r3, pc}
     4da:	nop
     4dc:	.word	0x4002f080

000004e0 <acq_stop()>:
    }

    void acq_stop(void)
    {
        I2S0_RCSR &= ~(I2S_RCSR_RE | I2S_RCSR_BCE);
     4e0:	ldr	r2, [pc, #12]	; (4f0 <acq_stop()+0x10>)
     4e2:	ldr	r3, [r2, #0]
     4e4:	bic.w	r3, r3, #2415919104	; 0x90000000
     4e8:	str	r3, [r2, #0]
        acq_stopClocks();
     4ea:	b.w	478 <acq_stopClocks()>
     4ee:	nop
     4f0:	.word	0x4002f080

000004f4 <mckl_init(int, int, int)>:
    }

    void mckl_init(int src, int mult, int div)
    {
     4f4:	push	{r4, lr}
        SIM_SCGC6 |= SIM_SCGC6_I2S;
     4f6:	ldr	r4, [pc, #52]	; (52c <mckl_init(int, int, int)+0x38>)
     4f8:	ldr	r3, [r4, #0]
        // enable MCLK output
        I2S0_MDR = I2S_MDR_FRACT((mult-1)) | I2S_MDR_DIVIDE((div-1));
     4fa:	subs	r1, #1
        acq_stopClocks();
    }

    void mckl_init(int src, int mult, int div)
    {
        SIM_SCGC6 |= SIM_SCGC6_I2S;
     4fc:	orr.w	r3, r3, #32768	; 0x8000
        // enable MCLK output
        I2S0_MDR = I2S_MDR_FRACT((mult-1)) | I2S_MDR_DIVIDE((div-1));
     500:	lsls	r1, r1, #12
     502:	subs	r2, #1
        acq_stopClocks();
    }

    void mckl_init(int src, int mult, int div)
    {
        SIM_SCGC6 |= SIM_SCGC6_I2S;
     504:	str	r3, [r4, #0]
        // enable MCLK output
        I2S0_MDR = I2S_MDR_FRACT((mult-1)) | I2S_MDR_DIVIDE((div-1));
     506:	and.w	r1, r1, #1044480	; 0xff000
     50a:	ubfx	r2, r2, #0, #12
     50e:	ldr	r3, [pc, #32]	; (530 <mckl_init(int, int, int)+0x3c>)
     510:	orrs	r2, r1
     512:	str	r2, [r3, #0]
        while(I2S0_MCR & I2S_MCR_DUF);
     514:	ldr	r2, [pc, #28]	; (534 <mckl_init(int, int, int)+0x40>)
     516:	ldr	r3, [r2, #0]
     518:	cmp	r3, #0
     51a:	blt.n	516 <mckl_init(int, int, int)+0x22>
        I2S0_MCR = I2S_MCR_MICS(src) | I2S_MCR_MOE;
     51c:	lsls	r0, r0, #24
     51e:	and.w	r0, r0, #50331648	; 0x3000000
     522:	ldr	r3, [pc, #16]	; (534 <mckl_init(int, int, int)+0x40>)
     524:	orr.w	r0, r0, #1073741824	; 0x40000000
     528:	str	r0, [r3, #0]
     52a:	pop	{r4, pc}
     52c:	.word	0x4004803c
     530:	.word	0x4002f104
     534:	.word	0x4002f100

00000538 <acq_init(int)>:

    }

    void acq_init(int fsamp)
    {
     538:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        Serial.printf("%d %d\n",fsamp,fsamp0);
     53c:	mov	r2, r0
     53e:	ldr	r3, [pc, #284]	; (65c <acq_init(int)+0x124>)
     540:	ldr	r1, [pc, #284]	; (660 <acq_init(int)+0x128>)
     542:	ldr	r0, [pc, #288]	; (664 <acq_init(int)+0x12c>)

        acq_startClocks();

        #if I2S_CONFIG==0
            CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
     544:	ldr.w	r9, [pc, #364]	; 6b4 <acq_init(int)+0x17c>
        	CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK
     548:	ldr	r7, [pc, #284]	; (668 <acq_init(int)+0x130>)
            CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
     54a:	ldr.w	r8, [pc, #364]	; 6b8 <acq_init(int)+0x180>
            CORE_PIN35_CONFIG = PORT_PCR_MUX(4) | PORT_PCR_SRE | PORT_PCR_DSE;  //pin35, PTC8,   I2S0_MCLK (SLEW rate (SRE)?)
            CORE_PIN36_CONFIG = PORT_PCR_MUX(4);  //pin36, PTC9,   I2S0_RX_BCLK
            CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
            CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
        #endif
        I2S0_RCSR=0;
     54e:	ldr	r6, [pc, #284]	; (66c <acq_init(int)+0x134>)

    }

    void acq_init(int fsamp)
    {
        Serial.printf("%d %d\n",fsamp,fsamp0);
     550:	bl	a204 <Print::printf(char const*, ...)>

        acq_startClocks();
     554:	bl	4a0 <acq_startClocks()>

        #if I2S_CONFIG==0
            CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
        	CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK
            CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
            CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  //pin 13, PTC5,  I2S0_RXD0
     558:	ldr	r3, [pc, #276]	; (670 <acq_init(int)+0x138>)
        Serial.printf("%d %d\n",fsamp,fsamp0);

        acq_startClocks();

        #if I2S_CONFIG==0
            CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
     55a:	mov.w	r5, #1536	; 0x600
            CORE_PIN35_CONFIG = PORT_PCR_MUX(4) | PORT_PCR_SRE | PORT_PCR_DSE;  //pin35, PTC8,   I2S0_MCLK (SLEW rate (SRE)?)
            CORE_PIN36_CONFIG = PORT_PCR_MUX(4);  //pin36, PTC9,   I2S0_RX_BCLK
            CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
            CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
        #endif
        I2S0_RCSR=0;
     55e:	movs	r4, #0

        #if I2S_CONFIG==0
            CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
        	CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK
            CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
            CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  //pin 13, PTC5,  I2S0_RXD0
     560:	mov.w	r2, #1024	; 0x400
        Serial.printf("%d %d\n",fsamp,fsamp0);

        acq_startClocks();

        #if I2S_CONFIG==0
            CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
     564:	str.w	r5, [r9]
            CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
            CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
        #endif
        I2S0_RCSR=0;

        mckl_init(MCLK_SRC, MCLK_MULT, MCLK_DIV);
     568:	movs	r1, #1

        acq_startClocks();

        #if I2S_CONFIG==0
            CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
        	CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK
     56a:	str	r5, [r7, #0]
            CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
            CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
        #endif
        I2S0_RCSR=0;

        mckl_init(MCLK_SRC, MCLK_MULT, MCLK_DIV);
     56c:	movs	r0, #3
        acq_startClocks();

        #if I2S_CONFIG==0
            CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
        	CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK
            CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
     56e:	str.w	r5, [r8]
            CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  //pin 13, PTC5,  I2S0_RXD0
     572:	str	r2, [r3, #0]
            CORE_PIN35_CONFIG = PORT_PCR_MUX(4) | PORT_PCR_SRE | PORT_PCR_DSE;  //pin35, PTC8,   I2S0_MCLK (SLEW rate (SRE)?)
            CORE_PIN36_CONFIG = PORT_PCR_MUX(4);  //pin36, PTC9,   I2S0_RX_BCLK
            CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
            CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
        #endif
        I2S0_RCSR=0;
     574:	str	r4, [r6, #0]

        mckl_init(MCLK_SRC, MCLK_MULT, MCLK_DIV);
     576:	movs	r2, #2
     578:	bl	4f4 <mckl_init(int, int, int)>
        #endif
        
        I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
#else
	// configure transmitter
	I2S0_TMR = 0;
     57c:	ldr	r3, [pc, #244]	; (674 <acq_init(int)+0x13c>)
	I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV(3);
     57e:	ldr	r2, [pc, #248]	; (678 <acq_init(int)+0x140>)
        #endif
        
        I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
#else
	// configure transmitter
	I2S0_TMR = 0;
     580:	str	r4, [r3, #0]
	I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
     582:	movs	r1, #1
     584:	str.w	r1, [r3, #-92]
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV(3);
	I2S0_TCR3 = I2S_TCR3_TCE;
	I2S0_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(31) | I2S_TCR4_MF
		| I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD;
	I2S0_TCR5 = I2S_TCR5_WNW(31) | I2S_TCR5_W0W(31) | I2S_TCR5_FBT(31);
     588:	ldr.w	lr, [pc, #304]	; 6bc <acq_init(int)+0x184>
#else
	// configure transmitter
	I2S0_TMR = 0;
	I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV(3);
     58c:	str.w	r2, [r3, #-88]
	I2S0_TCR3 = I2S_TCR3_TCE;
     590:	mov.w	r0, #65536	; 0x10000
	I2S0_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(31) | I2S_TCR4_MF
		| I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD;
     594:	ldr	r2, [pc, #228]	; (67c <acq_init(int)+0x144>)
	// configure transmitter
	I2S0_TMR = 0;
	I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV(3);
	I2S0_TCR3 = I2S_TCR3_TCE;
     596:	str.w	r0, [r3, #-84]

	// configure receiver (sync'd to transmitter clocks)
	I2S0_RMR = 0;
	I2S0_RCR1 = I2S_RCR1_RFW(1);
	I2S0_RCR2 = I2S_RCR2_SYNC(1) | I2S_TCR2_BCP | I2S_RCR2_MSEL(1)
		| I2S_RCR2_BCD | I2S_RCR2_DIV(3);
     59a:	ldr.w	ip, [pc, #292]	; 6c0 <acq_init(int)+0x188>
	I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV(3);
	I2S0_TCR3 = I2S_TCR3_TCE;
	I2S0_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(31) | I2S_TCR4_MF
		| I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD;
     59e:	str.w	r2, [r3, #-80]
	I2S0_TCR5 = I2S_TCR5_WNW(31) | I2S_TCR5_W0W(31) | I2S_TCR5_FBT(31);
     5a2:	ldr	r3, [pc, #220]	; (680 <acq_init(int)+0x148>)
     5a4:	str.w	r3, [lr]

	// configure receiver (sync'd to transmitter clocks)
	I2S0_RMR = 0;
     5a8:	str.w	r4, [lr, #204]	; 0xcc
	I2S0_RCR1 = I2S_RCR1_RFW(1);
     5ac:	str.w	r1, [lr, #112]	; 0x70
	I2S0_RCR2 = I2S_RCR2_SYNC(1) | I2S_TCR2_BCP | I2S_RCR2_MSEL(1)
		| I2S_RCR2_BCD | I2S_RCR2_DIV(3);
     5b0:	str.w	ip, [lr, #116]	; 0x74
	I2S0_RCR3 = I2S_RCR3_RCE;
     5b4:	str.w	r0, [lr, #120]	; 0x78
	I2S0_RCR4 = I2S_RCR4_FRSZ(1) | I2S_RCR4_SYWD(31) | I2S_RCR4_MF
		| I2S_RCR4_FSE | I2S_RCR4_FSP | I2S_RCR4_FSD;
     5b8:	ldr	r0, [pc, #200]	; (684 <acq_init(int)+0x14c>)
     5ba:	str	r2, [r0, #0]
	I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
     5bc:	ldr	r2, [pc, #200]	; (688 <acq_init(int)+0x150>)
     5be:	str	r3, [r2, #0]

    CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
    CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
	CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK

	I2S0_TCSR = I2S_TCSR_SR;
     5c0:	ldr	r3, [pc, #200]	; (68c <acq_init(int)+0x154>)
	I2S0_RCR3 = I2S_RCR3_RCE;
	I2S0_RCR4 = I2S_RCR4_FRSZ(1) | I2S_RCR4_SYWD(31) | I2S_RCR4_MF
		| I2S_RCR4_FSE | I2S_RCR4_FSP | I2S_RCR4_FSD;
	I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);

    CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
     5c2:	str.w	r5, [r9]
    CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
	CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK

	I2S0_TCSR = I2S_TCSR_SR;
     5c6:	mov.w	r2, #16777216	; 0x1000000
	I2S0_RCR4 = I2S_RCR4_FRSZ(1) | I2S_RCR4_SYWD(31) | I2S_RCR4_MF
		| I2S_RCR4_FSE | I2S_RCR4_FSP | I2S_RCR4_FSD;
	I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);

    CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
    CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
     5ca:	str.w	r5, [r8]
	CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK
     5ce:	str	r5, [r7, #0]

	I2S0_TCSR = I2S_TCSR_SR;
     5d0:	str	r2, [r3, #0]
	I2S0_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;
     5d2:	ldr	r2, [pc, #188]	; (690 <acq_init(int)+0x158>)
     5d4:	str	r2, [r3, #0]

#endif
// configuration of DMA
        dma.TCD->SADDR = &I2S0_RDR0;
     5d6:	ldr	r2, [pc, #188]	; (694 <acq_init(int)+0x15c>)
        dma.TCD->SOFF = 0;
        dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
	    dma.TCD->NBYTES_MLOFFNO = 4;
        dma.TCD->SLAST = 0;
        dma.TCD->DADDR = tdm_rx_buffer;
     5d8:	ldr	r5, [pc, #188]	; (698 <acq_init(int)+0x160>)
	I2S0_TCSR = I2S_TCSR_SR;
	I2S0_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;

#endif
// configuration of DMA
        dma.TCD->SADDR = &I2S0_RDR0;
     5da:	ldr	r3, [r2, #0]
     5dc:	adds	r0, #16
     5de:	str	r0, [r3, #0]
        dma.TCD->SOFF = 0;
        dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
     5e0:	movw	r0, #514	; 0x202
     5e4:	strh	r0, [r3, #6]
	    dma.TCD->NBYTES_MLOFFNO = 4;
     5e6:	movs	r0, #4
     5e8:	str	r0, [r3, #8]
        dma.TCD->SLAST = 0;
        dma.TCD->DADDR = tdm_rx_buffer;
        dma.TCD->DOFF = 4;
     5ea:	strh	r0, [r3, #20]
        dma.TCD->CITER_ELINKNO = 2*NBUF_I2S;
     5ec:	mov.w	r0, #512	; 0x200
        dma.TCD->SADDR = &I2S0_RDR0;
        dma.TCD->SOFF = 0;
        dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
	    dma.TCD->NBYTES_MLOFFNO = 4;
        dma.TCD->SLAST = 0;
        dma.TCD->DADDR = tdm_rx_buffer;
     5f0:	str	r5, [r3, #16]
	I2S0_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;

#endif
// configuration of DMA
        dma.TCD->SADDR = &I2S0_RDR0;
        dma.TCD->SOFF = 0;
     5f2:	strh	r4, [r3, #4]
        dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
	    dma.TCD->NBYTES_MLOFFNO = 4;
        dma.TCD->SLAST = 0;
        dma.TCD->DADDR = tdm_rx_buffer;
        dma.TCD->DOFF = 4;
        dma.TCD->CITER_ELINKNO = 2*NBUF_I2S;
     5f4:	strh	r0, [r3, #22]
        dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
     5f6:	ldr	r5, [pc, #164]	; (69c <acq_init(int)+0x164>)
        dma.TCD->BITER_ELINKNO = 2*NBUF_I2S;
     5f8:	strh	r0, [r3, #30]
        dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
     5fa:	movs	r0, #6
     5fc:	strh	r0, [r3, #28]
// configuration of DMA
        dma.TCD->SADDR = &I2S0_RDR0;
        dma.TCD->SOFF = 0;
        dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
	    dma.TCD->NBYTES_MLOFFNO = 4;
        dma.TCD->SLAST = 0;
     5fe:	str	r4, [r3, #12]
        dma.TCD->DADDR = tdm_rx_buffer;
        dma.TCD->DOFF = 4;
        dma.TCD->CITER_ELINKNO = 2*NBUF_I2S;
        dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
     600:	str	r5, [r3, #24]
	// 32 bits.  If a channel is configured for 200 transfers

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
     602:	ldrb	r3, [r2, #4]
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void attachInterrupt(void (*isr)(void), uint8_t prio) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
     604:	ldr	r5, [pc, #152]	; (6a0 <acq_init(int)+0x168>)
	// 32 bits.  If a channel is configured for 200 transfers

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
     606:	add.w	r3, r3, #1073741824	; 0x40000000
     60a:	add.w	r3, r3, #135168	; 0x21000
		*mux = 0;
		*mux = (source & 63) | DMAMUX_ENABLE;
     60e:	movs	r0, #140	; 0x8c

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
		*mux = 0;
     610:	strb	r4, [r3, #0]
		*mux = (source & 63) | DMAMUX_ENABLE;
     612:	strb	r0, [r3, #0]
        dma.TCD->BITER_ELINKNO = 2*NBUF_I2S;
        dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
        //
        dma.triggerAtHardwareEvent(DMAMUX_SOURCE_I2S0_RX);
        NVIC_SET_PRIORITY(DMAMUX_SOURCE_I2S0_RX,I2S_SAI_PRIO);
     614:	ldr	r3, [pc, #140]	; (6a4 <acq_init(int)+0x16c>)
     616:	movs	r0, #64	; 0x40
     618:	strb	r0, [r3, #0]
        //
        I2S0_RCSR =  I2S_RCSR_FRDE | I2S_RCSR_FR;
     61a:	ldr	r3, [pc, #140]	; (6a8 <acq_init(int)+0x170>)
     61c:	str	r3, [r6, #0]
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void attachInterrupt(void (*isr)(void), uint8_t prio) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
     61e:	ldrb	r0, [r2, #4]
     620:	ldr	r3, [pc, #136]	; (6ac <acq_init(int)+0x174>)
     622:	add.w	r4, r0, #16
	// configure receiver (sync'd to transmitter clocks)
	I2S0_RMR = 0;
	I2S0_RCR1 = I2S_RCR1_RFW(1);
	I2S0_RCR2 = I2S_RCR2_SYNC(1) | I2S_TCR2_BCP | I2S_RCR2_MSEL(1)
		| I2S_RCR2_BCD | I2S_RCR2_DIV(3);
	I2S0_RCR3 = I2S_RCR3_RCE;
     626:	add.w	lr, lr, #120	; 0x78
     62a:	str.w	r5, [r3, r4, lsl #2]
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
     62e:	asrs	r3, r0, #5
     630:	lsls	r3, r3, #2
     632:	add.w	r3, r3, #3758096384	; 0xe0000000
     636:	add.w	r3, r3, #57600	; 0xe100
     63a:	and.w	r0, r0, #31
     63e:	lsls	r1, r0
     640:	str	r1, [r3, #0]
		NVIC_SET_PRIORITY(IRQ_DMA_CH0 + channel, prio);
     642:	ldrb	r3, [r2, #4]
     644:	add.w	r3, r3, #3758096384	; 0xe0000000
     648:	add.w	r3, r3, #58368	; 0xe400
     64c:	movs	r1, #80	; 0x50
     64e:	strb	r1, [r3, #0]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
     650:	ldr	r3, [pc, #92]	; (6b0 <acq_init(int)+0x178>)
     652:	ldrb	r2, [r2, #4]
     654:	strb	r2, [r3, #0]
     656:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
     65a:	nop
     65c:	.word	0x00016e36
     660:	.word	0x000124b0
     664:	.word	0x1fff1348
     668:	.word	0x4004b00c
     66c:	.word	0x4002f080
     670:	.word	0x4004b014
     674:	.word	0x4002f060
     678:	.word	0x07000003
     67c:	.word	0x00011f1b
     680:	.word	0x1f1f1f00
     684:	.word	0x4002f090
     688:	.word	0x4002f094
     68c:	.word	0x4002f000
     690:	.word	0x90000001
     694:	.word	0x1fff21cc
     698:	.word	0x1fff0200
     69c:	.word	0xfffff800
     6a0:	.word	0x000006e5
     6a4:	.word	0xe000e40c
     6a8:	.word	0x02000001
     6ac:	.word	0x1fff0a00
     6b0:	.word	0x4000801b
     6b4:	.word	0x4004b018
     6b8:	.word	0x4004b008
     6bc:	.word	0x4002f014
     6c0:	.word	0x47000003

000006c4 <extract(void*, void*)>:


const int adc_shift=8;
#if ADC_STEREO // have stereo I2S
    void extract(void *out, void *inp)
    {   
     6c4:	push	{r4, lr}
     6c6:	movs	r3, #0
        int32_t *dout = (int32_t *) out;
        int32_t *din  = (int32_t *) inp;
        for(int ii=0; ii < NSAMP; ii++)
        {   dout[0+ii*NCHAN_ACQ] = din[0+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     6c8:	ldr	r2, [r1, r3]
     6ca:	asrs	r2, r2, #8
     6cc:	str	r2, [r0, r3]
            dout[1+ii*NCHAN_ACQ] = din[1+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     6ce:	adds	r2, r1, r3
     6d0:	adds	r4, r0, r3
     6d2:	ldr	r2, [r2, #4]
     6d4:	adds	r3, #8
     6d6:	asrs	r2, r2, #8
#if ADC_STEREO // have stereo I2S
    void extract(void *out, void *inp)
    {   
        int32_t *dout = (int32_t *) out;
        int32_t *din  = (int32_t *) inp;
        for(int ii=0; ii < NSAMP; ii++)
     6d8:	cmp.w	r3, #1024	; 0x400
        {   dout[0+ii*NCHAN_ACQ] = din[0+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
            dout[1+ii*NCHAN_ACQ] = din[1+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     6dc:	str	r2, [r4, #4]
#if ADC_STEREO // have stereo I2S
    void extract(void *out, void *inp)
    {   
        int32_t *dout = (int32_t *) out;
        int32_t *din  = (int32_t *) inp;
        for(int ii=0; ii < NSAMP; ii++)
     6de:	bne.n	6c8 <extract(void*, void*)+0x4>
        {   dout[0+ii*NCHAN_ACQ] = din[0+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
            dout[1+ii*NCHAN_ACQ] = din[1+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
        }
    }
     6e0:	pop	{r4, pc}
     6e2:	Address 0x000006e2 is out of bounds.


000006e4 <acq_isr()>:
        }
    }
#endif

    void acq_isr(void)
    {
     6e4:	push	{r3, lr}
     6e6:	ldr	r3, [pc, #60]	; (724 <acq_isr()+0x40>)
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
     6e8:	ldr	r2, [pc, #60]	; (728 <acq_isr()+0x44>)
     6ea:	ldrb	r1, [r3, #4]
     6ec:	strb	r1, [r2, #0]
        uint32_t daddr;
        uint32_t *src;

        dma.clearInterrupt();
        asm volatile("dsb");
     6ee:	dsb	sy
     6f2:	ldr	r3, [r3, #0]

        #if IMXRT_CACHE_ENABLED >=1
            arm_dcache_delete((void*)src, sizeof(tdm_rx_buffer) / 2);
        #endif

        extract((void *) acq_rx_buffer, (void *) src);
     6f4:	ldr	r0, [pc, #52]	; (72c <acq_isr()+0x48>)
	}
	void * sourceAddress(void) {
		return (void *)(TCD->SADDR);
	}
	void * destinationAddress(void) {
		return (void *)(TCD->DADDR);
     6f6:	ldr	r1, [r3, #16]

        dma.clearInterrupt();
        asm volatile("dsb");
        daddr = (uint32_t) dma.destinationAddress();

        if (daddr < (uint32_t) &tdm_rx_buffer[NBUF_I2S]) {
     6f8:	ldr	r3, [pc, #52]	; (730 <acq_isr()+0x4c>)
            // need to remove data from the second half
            src = &tdm_rx_buffer[NBUF_I2S];
        } else {
            // DMA is receiving to the second half of the buffer
            // need to remove data from the first half
            src = &tdm_rx_buffer[0];
     6fa:	sub.w	r2, r3, #1024	; 0x400

        #if IMXRT_CACHE_ENABLED >=1
            arm_dcache_delete((void*)src, sizeof(tdm_rx_buffer) / 2);
        #endif

        extract((void *) acq_rx_buffer, (void *) src);
     6fe:	cmp	r1, r3
     700:	ite	cc
     702:	movcc	r1, r3
     704:	movcs	r1, r2
     706:	bl	6c4 <extract(void*, void*)>
        if(!pushData(acq_rx_buffer)) acq_miss++;
     70a:	ldr	r0, [pc, #32]	; (72c <acq_isr()+0x48>)
     70c:	bl	1aa8 <pushData(unsigned long*)>
     710:	cbnz	r0, 71a <acq_isr()+0x36>
     712:	ldr	r2, [pc, #32]	; (734 <acq_isr()+0x50>)
     714:	ldr	r3, [r2, #0]
     716:	adds	r3, #1
     718:	str	r3, [r2, #0]
        acq_count++;
     71a:	ldr	r2, [pc, #28]	; (738 <acq_isr()+0x54>)
     71c:	ldr	r3, [r2, #0]
     71e:	adds	r3, #1
     720:	str	r3, [r2, #0]
     722:	pop	{r3, pc}
     724:	.word	0x1fff21cc
     728:	.word	0x4000801f
     72c:	.word	0x1fff1dcc
     730:	.word	0x1fff0600
     734:	.word	0x1fff1dc8
     738:	.word	0x1fff1dc4

0000073c <_GLOBAL__sub_I_acq_count>:
    }
     73c:	push	{r4, lr}
	/*************************************************/
	/**    Channel Allocation                       **/
	/*************************************************/

	DMAChannel() {
		begin();
     73e:	ldr	r4, [pc, #24]	; (758 <_GLOBAL__sub_I_acq_count+0x1c>)
     740:	movs	r1, #0
     742:	mov	r0, r4
     744:	bl	a054 <DMAChannel::begin(bool)>
#include "acq.h"
#include "adc.h"

/********************************************************************************/
#include "DMAChannel.h"
static DMAChannel dma;
     748:	mov	r0, r4
     74a:	ldr	r2, [pc, #16]	; (75c <_GLOBAL__sub_I_acq_count+0x20>)
     74c:	ldr	r1, [pc, #16]	; (760 <_GLOBAL__sub_I_acq_count+0x24>)
        #endif

        extract((void *) acq_rx_buffer, (void *) src);
        if(!pushData(acq_rx_buffer)) acq_miss++;
        acq_count++;
    }
     74e:	ldmia.w	sp!, {r4, lr}
#include "acq.h"
#include "adc.h"

/********************************************************************************/
#include "DMAChannel.h"
static DMAChannel dma;
     752:	b.w	a54c <__aeabi_atexit>
     756:	nop
     758:	.word	0x1fff21cc
     75c:	.word	0x1fff0f30
     760:	.word	0x0000046d

00000764 <Print::write(char const*)>:
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     764:	push	{r4, r5, r6, lr}
     766:	mov	r4, r0
     768:	mov	r0, r1
     76a:	mov	r5, r1
     76c:	bl	bf80 <strlen>
     770:	ldr	r3, [r4, #0]
     772:	mov	r2, r0
     774:	mov	r1, r5
     776:	mov	r0, r4
     778:	ldr	r3, [r3, #4]
     77a:	ldmia.w	sp!, {r4, r5, r6, lr}
     77e:	bx	r3

00000780 <Print::print(unsigned long)>:

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
     780:	movs	r3, #0
     782:	movs	r2, #10
     784:	b.w	a21e <Print::printNumber(unsigned long, unsigned char, unsigned char)>

00000788 <Print::println(char const*)>:
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     788:	push	{r3, r4, r5, lr}
     78a:	mov	r5, r0
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
     78c:	bl	764 <Print::write(char const*)>
     790:	mov	r4, r0
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     792:	mov	r0, r5
     794:	bl	a1e4 <Print::println()>
     798:	add	r0, r4
     79a:	pop	{r3, r4, r5, pc}

0000079c <checkToCloseFile(short, unsigned long)>:

uint32_t t_start;

/* check if we should close file */
int16_t checkToCloseFile(int16_t status, uint32_t t_acq)
{ if((status == OPENED) || (status == RUNNING))
     79c:	push	{r3, r4, r5, lr}
     79e:	subs	r3, r0, #1
     7a0:	uxth	r3, r3
     7a2:	cmp	r3, #1
     7a4:	mov	r5, r0
     7a6:	mov	r4, r1
     7a8:	bhi.n	7c2 <checkToCloseFile(short, unsigned long)+0x26>
  { //
    static uint32_t to =0;
    uint32_t tx=rtc_get();
     7aa:	bl	9468 <rtc_get>
    tx %= t_acq;
    if(tx<to) status = DOCLOSE; // time wrapped, file must be closed
     7ae:	ldr	r3, [pc, #24]	; (7c8 <checkToCloseFile(short, unsigned long)+0x2c>)
int16_t checkToCloseFile(int16_t status, uint32_t t_acq)
{ if((status == OPENED) || (status == RUNNING))
  { //
    static uint32_t to =0;
    uint32_t tx=rtc_get();
    tx %= t_acq;
     7b0:	udiv	r1, r0, r4
    if(tx<to) status = DOCLOSE; // time wrapped, file must be closed
     7b4:	ldr	r2, [r3, #0]
int16_t checkToCloseFile(int16_t status, uint32_t t_acq)
{ if((status == OPENED) || (status == RUNNING))
  { //
    static uint32_t to =0;
    uint32_t tx=rtc_get();
    tx %= t_acq;
     7b6:	mls	r0, r1, r4, r0
    if(tx<to) status = DOCLOSE; // time wrapped, file must be closed
     7ba:	cmp	r0, r2
     7bc:	it	cc
     7be:	movcc	r5, #3
    to=tx;
     7c0:	str	r0, [r3, #0]
  } 
  return status;
}
     7c2:	mov	r0, r5
     7c4:	pop	{r3, r4, r5, pc}
     7c6:	nop
     7c8:	.word	0x1fff21d8

000007cc <setup>:

void setup()
{
     7cc:	push	{r3, r4, r5, lr}
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     7ce:	ldr	r0, [pc, #100]	; (834 <setup+0x68>)
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     7d0:	ldr	r4, [pc, #100]	; (838 <setup+0x6c>)
     7d2:	ldr	r5, [pc, #104]	; (83c <setup+0x70>)
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     7d4:	ldr	r1, [pc, #104]	; (840 <setup+0x74>)
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     7d6:	ldrb	r3, [r4, #0]
     7d8:	cmp	r3, #0
     7da:	beq.n	7d6 <setup+0xa>
     7dc:	ldrb	r3, [r5, #0]
     7de:	lsls	r3, r3, #31
     7e0:	bpl.n	7d6 <setup+0xa>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     7e2:	ldr	r3, [r0, #0]
     7e4:	ldr	r2, [r1, #0]
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     7e6:	subs	r3, r3, r2
     7e8:	cmp	r3, #14
     7ea:	bls.n	7d6 <setup+0xa>
  while(!Serial) continue;
  Serial.println("basic Sound Recorder Version: " __DATE__  " " __TIME__ );
     7ec:	ldr	r1, [pc, #84]	; (844 <setup+0x78>)
     7ee:	ldr	r0, [pc, #88]	; (848 <setup+0x7c>)
     7f0:	bl	788 <Print::println(char const*)>
  SerNum = getTeensySerial();
     7f4:	bl	254c <getTeensySerial()>
     7f8:	ldr	r3, [pc, #80]	; (84c <setup+0x80>)
	size_t print(uint64_t n)			{ return printNumber64(n, 10, 0); }

	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
     7fa:	movs	r2, #16
     7fc:	mov	r1, r0
     7fe:	str	r0, [r3, #0]
     800:	movs	r3, #0
     802:	ldr	r0, [pc, #68]	; (848 <setup+0x7c>)
     804:	bl	a21e <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	size_t println(uint64_t n)			{ return print(n) + println(); }

	size_t println(unsigned char n, int base)	{ return print(n, base) + println(); }
	size_t println(int n, int base)			{ return print(n, base) + println(); }
	size_t println(unsigned int n, int base)	{ return print(n, base) + println(); }
	size_t println(long n, int base)		{ return print(n, base) + println(); }
     808:	ldr	r0, [pc, #60]	; (848 <setup+0x7c>)
     80a:	bl	a1e4 <Print::println()>
  Serial.println((int32_t)SerNum,HEX);

  storage_configure();
     80e:	bl	1b58 <storage_configure()>

  adc_init();
     812:	bl	22f2 <adc_init()>
  acq_init(FSAMP);
     816:	movw	r0, #48000	; 0xbb80
     81a:	bl	538 <acq_init(int)>
  adc_enable(0);
     81e:	ldr	r1, [pc, #48]	; (850 <setup+0x84>)
     820:	movs	r0, #0
     822:	bl	22f8 <adc_enable(unsigned int, unsigned long)>

  #if START_MODE==CLOSED
    acq_start(); 
     826:	bl	4c8 <acq_start()>
  #endif

  Serial.println("End of Setup");
     82a:	ldr	r1, [pc, #40]	; (854 <setup+0x88>)
     82c:	ldr	r0, [pc, #24]	; (848 <setup+0x7c>)
     82e:	bl	788 <Print::println(char const*)>
     832:	pop	{r3, r4, r5, pc}
     834:	.word	0x2001a6fc
     838:	.word	0x2001a7df
     83c:	.word	0x2001a6f8
     840:	.word	0x2001a850
     844:	.word	0x000124b7
     848:	.word	0x1fff1348
     84c:	.word	0x2001a1c0
     850:	.word	0x0ac44000
     854:	.word	0x000124ea

00000858 <loop>:
}

void loop()
{ static int16_t status=START_MODE; 
     858:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

  if(status==MUST_REBOOT) status=checkReboot(); // hapens only if microSD card write fails: reboot if space on disk
     85c:	ldr	r4, [pc, #296]	; (988 <loop+0x130>)
     85e:	ldrsh.w	r3, [r4]
     862:	adds	r3, #2

  Serial.println("End of Setup");
}

void loop()
{ static int16_t status=START_MODE; 
     864:	sub	sp, #20

  if(status==MUST_REBOOT) status=checkReboot(); // hapens only if microSD card write fails: reboot if space on disk
     866:	bne.n	86e <loop+0x16>
     868:	bl	1dc4 <checkReboot()>
     86c:	strh	r0, [r4, #0]

  // normal operation
  int16_t ch=menu();  // check if we have serial line command (0: no input; 1: start; -1: stop)
     86e:	bl	1320 <menu()>

  if(ch>0 && status==STOPPED)  // was stopped, should run now 
     872:	cmp	r0, #0
     874:	ble.n	88e <loop+0x36>
     876:	ldrsh.w	r3, [r4]
     87a:	adds	r3, #1
     87c:	bne.n	8a2 <loop+0x4a>
  { 
    status=CLOSED; acq_start(); adcStatus();
     87e:	ldr	r3, [pc, #264]	; (988 <loop+0x130>)
     880:	movs	r2, #0
     882:	strh	r2, [r3, #0]
     884:	bl	4c8 <acq_start()>
     888:	bl	22f4 <adcStatus()>
     88c:	b.n	8a2 <loop+0x4a>
  }  
  
  if(ch<0 && status>=CLOSED)  // was running, should stop now
     88e:	beq.n	8a2 <loop+0x4a>
     890:	ldrsh.w	r3, [r4]
     894:	cmp	r3, #0
     896:	blt.n	8a2 <loop+0x4a>
  { 
    status=MUSTSTOP;  acq_stop();  
     898:	ldr	r3, [pc, #236]	; (988 <loop+0x130>)
     89a:	movs	r2, #4
     89c:	strh	r2, [r3, #0]
     89e:	bl	4e0 <acq_stop()>
  } 

  if(status > CLOSED) // RUNNING
     8a2:	ldrsh.w	r0, [r4]
     8a6:	cmp	r0, #0
     8a8:	ble.n	8b6 <loop+0x5e>
  {
    status = checkToCloseFile(status, (uint32_t) t_acq); // check if we reached file size or aquisition time
     8aa:	ldr	r3, [pc, #224]	; (98c <loop+0x134>)
     8ac:	ldr	r1, [r3, #0]
     8ae:	bl	79c <checkToCloseFile(short, unsigned long)>
     8b2:	ldr	r3, [pc, #212]	; (988 <loop+0x130>)
     8b4:	strh	r0, [r3, #0]
  }

  if(status >= CLOSED) // NOT STOPPED
     8b6:	ldrsh.w	r3, [r4]
     8ba:	ldr	r5, [pc, #212]	; (990 <loop+0x138>)
     8bc:	cmp	r3, #0
     8be:	blt.n	8f0 <loop+0x98>
  {
    uint32_t mc = getCount();
     8c0:	bl	1a90 <getCount()>
    if(mc>max_count) max_count=mc;
     8c4:	ldr	r3, [pc, #204]	; (994 <loop+0x13c>)
     8c6:	ldr	r2, [r3, #0]
     8c8:	cmp	r0, r2
     8ca:	it	hi
     8cc:	strhi	r0, [r3, #0]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     8ce:	ldr	r3, [r5, #0]
     8d0:	str	r3, [sp, #4]
    //
    uint32_t to=millis();
    status = saveData(status);  
     8d2:	ldrsh.w	r0, [r4]
	return ret;
     8d6:	ldr	r6, [sp, #4]
     8d8:	bl	1dcc <saveData(short)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     8dc:	ldr	r3, [r5, #0]
    uint32_t dt=millis()-to;
    if(max_write<dt) max_write=dt;
     8de:	ldr	r2, [pc, #184]	; (998 <loop+0x140>)
     8e0:	str	r3, [sp, #0]
	return ret;
     8e2:	ldr	r3, [sp, #0]
     8e4:	ldr	r1, [r2, #0]
  {
    uint32_t mc = getCount();
    if(mc>max_count) max_count=mc;
    //
    uint32_t to=millis();
    status = saveData(status);  
     8e6:	strh	r0, [r4, #0]
    uint32_t dt=millis()-to;
     8e8:	subs	r3, r3, r6
    if(max_write<dt) max_write=dt;
     8ea:	cmp	r3, r1
     8ec:	it	hi
     8ee:	strhi	r3, [r2, #0]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     8f0:	ldr	r3, [r5, #0]
  }

  static uint32_t t0;
  if(millis()-t0>1000)
     8f2:	ldr	r2, [pc, #168]	; (99c <loop+0x144>)
     8f4:	str	r3, [sp, #8]
	return ret;
     8f6:	ldr	r3, [sp, #8]
     8f8:	ldr	r1, [r2, #0]
     8fa:	subs	r3, r3, r1
     8fc:	cmp.w	r3, #1000	; 0x3e8
     900:	mov	r9, r2
     902:	bls.n	982 <loop+0x12a>
  {
    if(status>=CLOSED)
     904:	ldrsh.w	r3, [r4]
     908:	ldr	r6, [pc, #136]	; (994 <loop+0x13c>)
     90a:	ldr	r4, [pc, #140]	; (998 <loop+0x140>)
     90c:	ldr.w	r8, [pc, #164]	; 9b4 <loop+0x15c>
     910:	ldr	r7, [pc, #140]	; (9a0 <loop+0x148>)
     912:	cmp	r3, #0
     914:	blt.n	96c <loop+0x114>
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
     916:	ldr	r1, [pc, #140]	; (9a4 <loop+0x14c>)
     918:	ldr	r0, [pc, #140]	; (9a8 <loop+0x150>)
     91a:	bl	764 <Print::write(char const*)>
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
     91e:	ldr	r3, [pc, #104]	; (988 <loop+0x130>)
     920:	ldr	r0, [pc, #132]	; (9a8 <loop+0x150>)
     922:	ldrsh.w	r1, [r3]
     926:	bl	a294 <Print::print(long)>
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
     92a:	ldr	r1, [pc, #128]	; (9ac <loop+0x154>)
     92c:	ldr	r0, [pc, #120]	; (9a8 <loop+0x150>)
     92e:	bl	764 <Print::write(char const*)>
    {
      Serial.print("\nLoop: ");
        Serial.print(status); Serial.print(" : "); 
        Serial.print(acq_count); Serial.print(" ");
     932:	ldr.w	r1, [r8]
     936:	ldr	r0, [pc, #112]	; (9a8 <loop+0x150>)
     938:	bl	780 <Print::print(unsigned long)>
     93c:	ldr	r1, [pc, #112]	; (9b0 <loop+0x158>)
     93e:	ldr	r0, [pc, #104]	; (9a8 <loop+0x150>)
     940:	bl	764 <Print::write(char const*)>
        Serial.print(acq_miss); Serial.print(" ");
     944:	ldr	r1, [r7, #0]
     946:	ldr	r0, [pc, #96]	; (9a8 <loop+0x150>)
     948:	bl	780 <Print::print(unsigned long)>
     94c:	ldr	r1, [pc, #96]	; (9b0 <loop+0x158>)
     94e:	ldr	r0, [pc, #88]	; (9a8 <loop+0x150>)
     950:	bl	764 <Print::write(char const*)>
        Serial.print(max_count); Serial.print(" ");
     954:	ldr	r1, [r6, #0]
     956:	ldr	r0, [pc, #80]	; (9a8 <loop+0x150>)
     958:	bl	780 <Print::print(unsigned long)>
     95c:	ldr	r1, [pc, #80]	; (9b0 <loop+0x158>)
     95e:	ldr	r0, [pc, #72]	; (9a8 <loop+0x150>)
     960:	bl	764 <Print::write(char const*)>
        Serial.print(max_write);
     964:	ldr	r1, [r4, #0]
     966:	ldr	r0, [pc, #64]	; (9a8 <loop+0x150>)
     968:	bl	780 <Print::print(unsigned long)>
    }
    acq_count=0;
     96c:	movs	r3, #0
     96e:	str.w	r3, [r8]
    acq_miss=0;
     972:	str	r3, [r7, #0]
    max_count=0;
     974:	str	r3, [r6, #0]
    max_write=0;
     976:	str	r3, [r4, #0]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     978:	ldr	r3, [r5, #0]
     97a:	str	r3, [sp, #12]
	return ret;
     97c:	ldr	r3, [sp, #12]
    t0=millis();
     97e:	str.w	r3, [r9]
  }
     982:	add	sp, #20
     984:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     988:	.word	0x1fff21e0
     98c:	.word	0x1fff0f34
     990:	.word	0x2001a6fc
     994:	.word	0x1fff21e4
     998:	.word	0x1fff21d4
     99c:	.word	0x1fff21dc
     9a0:	.word	0x1fff1dc8
     9a4:	.word	0x000124f7
     9a8:	.word	0x1fff1348
     9ac:	.word	0x000124ff
     9b0:	.word	0x00012501
     9b4:	.word	0x1fff1dc4

000009b8 <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
     9b8:	movs	r0, #0
     9ba:	bx	lr

000009bc <Print::flush()>:
	virtual void flush()				{ }
     9bc:	bx	lr

000009be <File::write(unsigned char const*, unsigned int)>:
		return (f) ? f->read(buf, nbyte) : 0;
	}
	
	// override print version
	virtual size_t write(const uint8_t *buf, size_t size) {
		return (f) ? f->write((void*)buf, size) : 0;
     9be:	ldr	r0, [r0, #16]
     9c0:	cbz	r0, 9c8 <File::write(unsigned char const*, unsigned int)+0xa>
     9c2:	ldr	r3, [r0, #0]
     9c4:	ldr	r3, [r3, #12]
     9c6:	bx	r3
	}
     9c8:	bx	lr

000009ca <File::available()>:

	size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
	}
	int available() {
		return (f) ? f->available() : 0;
     9ca:	ldr	r0, [r0, #16]
     9cc:	cbz	r0, 9d4 <File::available()+0xa>
     9ce:	ldr	r3, [r0, #0]
     9d0:	ldr	r3, [r3, #16]
     9d2:	bx	r3
	}
     9d4:	bx	lr

000009d6 <File::peek()>:
	int peek() {
		return (f) ? f->peek() : -1;
     9d6:	ldr	r0, [r0, #16]
     9d8:	cbz	r0, 9e0 <File::peek()+0xa>
     9da:	ldr	r3, [r0, #0]
     9dc:	ldr	r3, [r3, #20]
     9de:	bx	r3
	}
     9e0:	mov.w	r0, #4294967295
     9e4:	bx	lr

000009e6 <File::flush()>:
	void flush() {
		if (f) f->flush();
     9e6:	ldr	r0, [r0, #16]
     9e8:	cbz	r0, 9f0 <File::flush()+0xa>
     9ea:	ldr	r3, [r0, #0]
     9ec:	ldr	r3, [r3, #24]
     9ee:	bx	r3
     9f0:	bx	lr

000009f2 <File::read()>:
		return (f) ? f->setModifyTime(tm) : false;
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
     9f2:	push	{r0, r1, r2, lr}
		if (!f) return -1;
     9f4:	ldr	r0, [r0, #16]
     9f6:	cbnz	r0, 9fe <File::read()+0xc>
     9f8:	mov.w	r0, #4294967295
     9fc:	b.n	a12 <File::read()+0x20>
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
     9fe:	ldr	r3, [r0, #0]
     a00:	movs	r2, #1
     a02:	ldr	r3, [r3, #8]
     a04:	add.w	r1, sp, #7
     a08:	blx	r3
     a0a:	cmp	r0, #0
     a0c:	beq.n	9f8 <File::read()+0x6>
		return b;
     a0e:	ldrb.w	r0, [sp, #7]
	}
     a12:	add	sp, #12
     a14:	ldr.w	pc, [sp], #4

00000a18 <File::write(unsigned char)>:
	size_t write(uint8_t b) {
     a18:	push	{r0, r1, r2, lr}
		return (f) ? f->write(&b, 1) : 0;
     a1a:	ldr	r0, [r0, #16]
		if (!f) return -1;
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
		return b;
	}
	size_t write(uint8_t b) {
     a1c:	strb.w	r1, [sp, #7]
		return (f) ? f->write(&b, 1) : 0;
     a20:	cbz	r0, a2e <File::write(unsigned char)+0x16>
     a22:	ldr	r3, [r0, #0]
     a24:	movs	r2, #1
     a26:	ldr	r3, [r3, #12]
     a28:	add.w	r1, sp, #7
     a2c:	blx	r3
	}
     a2e:	add	sp, #12
     a30:	ldr.w	pc, [sp], #4

00000a34 <SDFile::getCreateTime(DateTimeFields&)>:
		return File();
	}
	virtual void rewindDirectory(void) {
		sdfatfile.rewindDirectory();
	}
	virtual bool getCreateTime(DateTimeFields &tm) {
     a34:	push	{r0, r1, r4, lr}
     a36:	mov	r3, r0
   * \param[out] ptime Packed time for directory entry.
   *
   * \return true for success or false for failure.
   */
  bool getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    return m_fFile ? m_fFile->getCreateDateTime(pdate, ptime) :
     a38:	ldr	r0, [r0, #80]	; 0x50
     a3a:	mov	r4, r1
           m_xFile ? m_xFile->getCreateDateTime(pdate, ptime) : false;
     a3c:	cbz	r0, a4a <SDFile::getCreateTime(DateTimeFields&)+0x16>
     a3e:	add.w	r2, sp, #6
     a42:	add	r1, sp, #4
     a44:	bl	63d6 <FatFile::getCreateDateTime(unsigned short*, unsigned short*)>
     a48:	b.n	a5c <SDFile::getCreateTime(DateTimeFields&)+0x28>
     a4a:	ldr	r0, [r3, #84]	; 0x54
     a4c:	cbnz	r0, a52 <SDFile::getCreateTime(DateTimeFields&)+0x1e>
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getCreateDateTime(&fat_date, &fat_time)) return false;
     a4e:	movs	r0, #0
     a50:	b.n	a96 <SDFile::getCreateTime(DateTimeFields&)+0x62>
     a52:	add.w	r2, sp, #6
     a56:	add	r1, sp, #4
     a58:	bl	40e2 <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)>
     a5c:	cmp	r0, #0
     a5e:	beq.n	a4e <SDFile::getCreateTime(DateTimeFields&)+0x1a>
		if ((fat_date == 0) && (fat_time == 0)) return false;
     a60:	ldrh.w	r3, [sp, #4]
     a64:	ldrh.w	r2, [sp, #6]
     a68:	cbnz	r3, a6e <SDFile::getCreateTime(DateTimeFields&)+0x3a>
     a6a:	cmp	r2, #0
     a6c:	beq.n	a4e <SDFile::getCreateTime(DateTimeFields&)+0x1a>
		tm.sec = FS_SECOND(fat_time);
     a6e:	and.w	r1, r2, #31
     a72:	lsls	r1, r1, #1
     a74:	strb	r1, [r4, #0]
		tm.min = FS_MINUTE(fat_time);
     a76:	ubfx	r1, r2, #5, #6
		tm.hour = FS_HOUR(fat_time);
     a7a:	asrs	r2, r2, #11
     a7c:	strb	r2, [r4, #2]
		tm.mday = FS_DAY(fat_date);
     a7e:	and.w	r2, r3, #31
     a82:	strb	r2, [r4, #4]
		tm.mon = FS_MONTH(fat_date) - 1;
     a84:	ubfx	r2, r3, #5, #4
		tm.year = FS_YEAR(fat_date) - 1900;
     a88:	asrs	r3, r3, #9
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     a8a:	subs	r2, #1
		tm.year = FS_YEAR(fat_date) - 1900;
     a8c:	add.w	r3, r3, #1872	; 0x750
	virtual bool getCreateTime(DateTimeFields &tm) {
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getCreateDateTime(&fat_date, &fat_time)) return false;
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
     a90:	strb	r1, [r4, #1]
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     a92:	strb	r2, [r4, #5]
		tm.year = FS_YEAR(fat_date) - 1900;
     a94:	strb	r3, [r4, #6]
		return true;
	}
     a96:	add	sp, #8
     a98:	pop	{r4, pc}

00000a9a <SDFile::getModifyTime(DateTimeFields&)>:
	virtual bool getModifyTime(DateTimeFields &tm) {
     a9a:	push	{r0, r1, r4, lr}
     a9c:	mov	r3, r0
   * \param[out] ptime Packed time for directory entry.
   *
   * \return true for success or false for failure.
   */
  bool getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    return m_fFile ? m_fFile->getModifyDateTime(pdate, ptime) :
     a9e:	ldr	r0, [r0, #80]	; 0x50
     aa0:	mov	r4, r1
           m_xFile ? m_xFile->getModifyDateTime(pdate, ptime) : false;
     aa2:	cbz	r0, ab0 <SDFile::getModifyTime(DateTimeFields&)+0x16>
     aa4:	add.w	r2, sp, #6
     aa8:	add	r1, sp, #4
     aaa:	bl	63f6 <FatFile::getModifyDateTime(unsigned short*, unsigned short*)>
     aae:	b.n	ac2 <SDFile::getModifyTime(DateTimeFields&)+0x28>
     ab0:	ldr	r0, [r3, #84]	; 0x54
     ab2:	cbnz	r0, ab8 <SDFile::getModifyTime(DateTimeFields&)+0x1e>
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getModifyDateTime(&fat_date, &fat_time)) return false;
     ab4:	movs	r0, #0
     ab6:	b.n	afc <SDFile::getModifyTime(DateTimeFields&)+0x62>
     ab8:	add.w	r2, sp, #6
     abc:	add	r1, sp, #4
     abe:	bl	4102 <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)>
     ac2:	cmp	r0, #0
     ac4:	beq.n	ab4 <SDFile::getModifyTime(DateTimeFields&)+0x1a>
		if ((fat_date == 0) && (fat_time == 0)) return false;
     ac6:	ldrh.w	r3, [sp, #4]
     aca:	ldrh.w	r2, [sp, #6]
     ace:	cbnz	r3, ad4 <SDFile::getModifyTime(DateTimeFields&)+0x3a>
     ad0:	cmp	r2, #0
     ad2:	beq.n	ab4 <SDFile::getModifyTime(DateTimeFields&)+0x1a>
		tm.sec = FS_SECOND(fat_time);
     ad4:	and.w	r1, r2, #31
     ad8:	lsls	r1, r1, #1
     ada:	strb	r1, [r4, #0]
		tm.min = FS_MINUTE(fat_time);
     adc:	ubfx	r1, r2, #5, #6
		tm.hour = FS_HOUR(fat_time);
     ae0:	asrs	r2, r2, #11
     ae2:	strb	r2, [r4, #2]
		tm.mday = FS_DAY(fat_date);
     ae4:	and.w	r2, r3, #31
     ae8:	strb	r2, [r4, #4]
		tm.mon = FS_MONTH(fat_date) - 1;
     aea:	ubfx	r2, r3, #5, #4
		tm.year = FS_YEAR(fat_date) - 1900;
     aee:	asrs	r3, r3, #9
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     af0:	subs	r2, #1
		tm.year = FS_YEAR(fat_date) - 1900;
     af2:	add.w	r3, r3, #1872	; 0x750
	virtual bool getModifyTime(DateTimeFields &tm) {
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getModifyDateTime(&fat_date, &fat_time)) return false;
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
     af6:	strb	r1, [r4, #1]
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     af8:	strb	r2, [r4, #5]
		tm.year = FS_YEAR(fat_date) - 1900;
     afa:	strb	r3, [r4, #6]
		return true;
	}
     afc:	add	sp, #8
     afe:	pop	{r4, pc}

00000b00 <SDFile::name()>:
		}
	}
	virtual bool isOpen() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
     b00:	push	{r3, r4, r5, lr}
		if (!filename) {
     b02:	ldr	r5, [r0, #88]	; 0x58
		}
	}
	virtual bool isOpen() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
     b04:	mov	r4, r0
		if (!filename) {
     b06:	cbnz	r5, b38 <SDFile::name()+0x38>
			filename = (char *)malloc(MAX_FILENAME_LEN);
     b08:	mov.w	r0, #256	; 0x100
     b0c:	bl	b340 <malloc>
     b10:	mov	r1, r0
     b12:	str	r0, [r4, #88]	; 0x58
			if (filename) {
     b14:	cbz	r0, b34 <SDFile::name()+0x34>
   *             must be at least 13 bytes long.  The file's name will be
   *             truncated if the file's name is too long.
   * \return The length of the returned string.
   */
  size_t getName(char* name, size_t len) {
    *name = 0;
     b16:	strb	r5, [r0, #0]
    return m_fFile ? m_fFile->getName(name, len) :
     b18:	ldr	r0, [r4, #80]	; 0x50
           m_xFile ? m_xFile->getName(name, len) : 0;
     b1a:	cbz	r0, b26 <SDFile::name()+0x26>
     b1c:	mov.w	r2, #256	; 0x100
     b20:	bl	5cc4 <FatFile::getName(char*, unsigned int)>
     b24:	b.n	b38 <SDFile::name()+0x38>
     b26:	ldr	r0, [r4, #84]	; 0x54
     b28:	cbz	r0, b38 <SDFile::name()+0x38>
   * \param[in] size The size of the array in characters.
   * \return the name length.
   */
  size_t getName(char* name, size_t size) {
#if USE_UTF8_LONG_NAMES
    return getName8(name, size);
     b2a:	mov.w	r2, #256	; 0x100
     b2e:	bl	3f84 <ExFatFile::getName8(char*, unsigned int)>
     b32:	b.n	b38 <SDFile::name()+0x38>
				sdfatfile.getName(filename, MAX_FILENAME_LEN);
			} else {
				static char zeroterm = 0;
				filename = &zeroterm;
     b34:	ldr	r3, [pc, #4]	; (b3c <SDFile::name()+0x3c>)
     b36:	str	r3, [r4, #88]	; 0x58
			}
		}
		return filename;
	}
     b38:	ldr	r0, [r4, #88]	; 0x58
     b3a:	pop	{r3, r4, r5, pc}
     b3c:	.word	0x1fff21e8

00000b40 <SDFile::truncate(unsigned long long)>:
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
		return sdfatfile.read(buf, nbyte);
	}
	virtual bool truncate(uint64_t size=0) {
     b40:	push	{r4, r6, r7, lr}
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     b42:	ldr	r4, [r0, #80]	; 0x50
           m_xFile ? m_xFile->truncate(length) : false;
     b44:	cbz	r4, b62 <SDFile::truncate(unsigned long long)+0x22>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     b46:	cmp	r3, #1
     b48:	it	eq
     b4a:	cmpeq	r2, #0
     b4c:	bcs.n	b78 <SDFile::truncate(unsigned long long)+0x38>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint32_t length) {
    return seekSet(length) && truncate();
     b4e:	mov	r1, r2
     b50:	mov	r0, r4
     b52:	bl	6006 <FatFile::seekSet(unsigned long)>
     b56:	cbz	r0, b78 <SDFile::truncate(unsigned long long)+0x38>
     b58:	mov	r0, r4
     b5a:	bl	67fe <FatFile::truncate()>
     b5e:	cbz	r0, b78 <SDFile::truncate(unsigned long long)+0x38>
     b60:	pop	{r4, r6, r7, pc}
           m_xFile ? m_xFile->truncate(length) : false;
     b62:	ldr	r4, [r0, #84]	; 0x54
     b64:	cbz	r4, b78 <SDFile::truncate(unsigned long long)+0x38>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
     b66:	mov	r0, r4
     b68:	bl	4374 <ExFatFile::seekSet(unsigned long long)>
     b6c:	cbz	r0, b78 <SDFile::truncate(unsigned long long)+0x38>
     b6e:	mov	r0, r4
		return sdfatfile.truncate(size);
	}
     b70:	ldmia.w	sp!, {r4, r6, r7, lr}
     b74:	b.w	5366 <ExFatFile::truncate()>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     b78:	movs	r0, #0
     b7a:	pop	{r4, r6, r7, pc}

00000b7c <File::dec_refcount() [clone .isra.15]>:
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	using Print::write;
private:
	void dec_refcount() {
     b7c:	push	{r4, lr}
     b7e:	mov	r4, r0
		if (--(f->refcount) == 0) {
     b80:	ldr	r0, [r0, #0]
     b82:	ldr	r3, [r0, #4]
     b84:	subs	r3, #1
     b86:	str	r3, [r0, #4]
     b88:	cbnz	r3, b9a <File::dec_refcount() [clone .isra.15]+0x1e>
			f->close();
     b8a:	ldr	r3, [r0, #0]
     b8c:	ldr	r3, [r3, #44]	; 0x2c
     b8e:	blx	r3
			delete f;
     b90:	ldr	r0, [r4, #0]
     b92:	cbz	r0, b9a <File::dec_refcount() [clone .isra.15]+0x1e>
     b94:	ldr	r3, [r0, #0]
     b96:	ldr	r3, [r3, #4]
     b98:	blx	r3
		}
		f = nullptr;
     b9a:	movs	r3, #0
     b9c:	str	r3, [r4, #0]
     b9e:	pop	{r4, pc}

00000ba0 <File::~File()>:
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
     ba0:	ldr	r3, [pc, #20]	; (bb8 <File::~File()+0x18>)
     ba2:	push	{r4, lr}
     ba4:	str	r3, [r0, #0]
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
     ba6:	ldr	r3, [r0, #16]
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
     ba8:	mov	r4, r0
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
     baa:	cbz	r3, bb2 <File::~File()+0x12>
     bac:	adds	r0, #16
     bae:	bl	b7c <File::dec_refcount() [clone .isra.15]>
	}
     bb2:	mov	r0, r4
     bb4:	pop	{r4, pc}
     bb6:	nop
     bb8:	.word	0x00012578

00000bbc <File::~File()>:
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
     bbc:	push	{r4, lr}
     bbe:	mov	r4, r0
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
	}
     bc0:	bl	ba0 <File::~File()>
     bc4:	mov	r0, r4
     bc6:	movs	r1, #20
     bc8:	bl	a3e0 <operator delete(void*, unsigned int)>
     bcc:	mov	r0, r4
     bce:	pop	{r4, pc}

00000bd0 <SDFile::position()>:
    return m_fFile ? m_fFile->contiguousRange(bgnSector, endSector) :
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
     bd0:	ldr	r3, [r0, #80]	; 0x50
           m_xFile ? m_xFile->curPosition() : 0;
     bd2:	cbz	r3, bda <SDFile::position()+0xa>
     bd4:	ldr	r0, [r3, #20]
     bd6:	movs	r1, #0
     bd8:	bx	lr
     bda:	ldr	r3, [r0, #84]	; 0x54
     bdc:	cbz	r3, be4 <SDFile::position()+0x14>
   *
   * \return true for success or false for failure.
   */
  bool contiguousRange(uint32_t* bgnSector, uint32_t* endSector);
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {return m_curPosition;}
     bde:	ldmia.w	r3, {r0, r1}
     be2:	bx	lr
     be4:	mov	r0, r3
     be6:	b.n	bd6 <SDFile::position()+0x6>

00000be8 <SDFile::size()>:
    return m_fFile ? m_fFile->fgets(str, num, delim) :
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
     be8:	ldr	r3, [r0, #80]	; 0x50
           m_xFile ? m_xFile->fileSize() : 0;
     bea:	cbz	r3, bf2 <SDFile::size()+0xa>
     bec:	ldr	r0, [r3, #28]
     bee:	movs	r1, #0
     bf0:	bx	lr
     bf2:	ldr	r3, [r0, #84]	; 0x54
     bf4:	cbz	r3, bfc <SDFile::size()+0x14>
   * If no data is read, fgets() returns zero for EOF or -1 if an error
   * occurred.
   */
  int fgets(char* str, int num, char* delim = nullptr);
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {return m_validLength;}
     bf6:	ldr	r0, [r3, #16]
     bf8:	ldr	r1, [r3, #20]
     bfa:	bx	lr
     bfc:	mov	r0, r3
     bfe:	b.n	bee <SDFile::size()+0x6>

00000c00 <FsBaseFile::available() const>:
  operator bool() const {return isOpen();}
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
    return m_fFile ? m_fFile->available() :
     c00:	ldr	r2, [r0, #56]	; 0x38
    */
  operator bool() const {return isOpen();}
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
     c02:	push	{r4, r5, lr}
    return m_fFile ? m_fFile->available() :
           m_xFile ? m_xFile->available() : 0;
     c04:	cbz	r2, c20 <FsBaseFile::available() const+0x20>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available32() const {
    return isFile() ? fileSize() - curPosition() : 0;
     c06:	ldrb	r3, [r2, #0]
     c08:	and.w	r3, r3, #8
     c0c:	and.w	r0, r3, #255	; 0xff
     c10:	cbz	r3, c52 <FsBaseFile::available() const+0x52>
     c12:	ldr	r3, [r2, #28]
     c14:	ldr	r0, [r2, #20]
   * Zero is returned for directory files.
   *
   */
  int available() const {
    uint32_t n = available32();
    return n > INT_MAX ? INT_MAX : n;
     c16:	subs	r0, r3, r0
     c18:	bpl.n	c52 <FsBaseFile::available() const+0x52>
     c1a:	mvn.w	r0, #2147483648	; 0x80000000
     c1e:	b.n	c52 <FsBaseFile::available() const+0x52>
     c20:	ldr	r0, [r0, #60]	; 0x3c
     c22:	cbz	r0, c52 <FsBaseFile::available() const+0x52>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint64_t available64() {
    return isFile() ? fileSize() - curPosition() : 0;
     c24:	ldrb.w	r3, [r0, #49]	; 0x31
     c28:	lsls	r3, r3, #28
     c2a:	bpl.n	c3c <FsBaseFile::available() const+0x3c>
     c2c:	ldrd	r4, r5, [r0, #16]
     c30:	ldrd	r2, r3, [r0]
     c34:	subs	r0, r4, r2
     c36:	sbc.w	r1, r5, r3
     c3a:	b.n	c40 <FsBaseFile::available() const+0x40>
     c3c:	movs	r0, #0
     c3e:	movs	r1, #0
   * Zero is returned for directory files.
   *
   */
  int available() {
    uint64_t n = available64();
    return n > INT_MAX ? INT_MAX : n;
     c40:	movs	r3, #0
     c42:	mvn.w	r2, #2147483648	; 0x80000000
     c46:	cmp	r3, r1
     c48:	it	eq
     c4a:	cmpeq	r2, r0
     c4c:	bcs.n	c52 <FsBaseFile::available() const+0x52>
     c4e:	mov	r0, r2
     c50:	pop	{r4, r5, pc}
  }
     c52:	pop	{r4, r5, pc}

00000c54 <StreamFile<FsBaseFile, unsigned long long>::available()>:
  StreamFile() {}

  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
     c54:	push	{r3, lr}
    return BaseFile::available();
     c56:	adds	r0, #16
     c58:	bl	c00 <FsBaseFile::available() const>
  }
     c5c:	pop	{r3, pc}

00000c5e <SDFile::available()>:
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
		return sdfatfile.peek();
	}
	virtual int available() {
     c5e:	push	{r3, lr}

  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
    return BaseFile::available();
     c60:	adds	r0, #24
     c62:	bl	c00 <FsBaseFile::available() const>
		return sdfatfile.available();
	}
     c66:	pop	{r3, pc}

00000c68 <FsBaseFile::isDir() const>:
    return m_xFile ? m_xFile->isContiguous() : false;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  }
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_fFile ? m_fFile->isDir() :
     c68:	ldr	r3, [r0, #56]	; 0x38
           m_xFile ? m_xFile->isDir() : false;
     c6a:	cbz	r3, c74 <FsBaseFile::isDir() const+0xc>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
    /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  /** \return True if this is a directory. */
  bool isDir() const {return m_attributes & FILE_ATTR_DIR;}
     c6c:	ldrb	r3, [r3, #0]
     c6e:	tst.w	r3, #112	; 0x70
     c72:	b.n	c80 <FsBaseFile::isDir() const+0x18>
     c74:	ldr	r0, [r0, #60]	; 0x3c
     c76:	cbz	r0, c86 <FsBaseFile::isDir() const+0x1e>
   */
  bool isBusy();
  /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
  /** \return True if this is a directory. */
  bool isDir() const  {return m_attributes & FILE_ATTR_DIR;}
     c78:	ldrb.w	r3, [r0, #49]	; 0x31
     c7c:	tst.w	r3, #80	; 0x50
     c80:	ite	ne
     c82:	movne	r0, #1
     c84:	moveq	r0, #0
  }
     c86:	bx	lr

00000c88 <SDFile::isDirectory()>:
				filename = &zeroterm;
			}
		}
		return filename;
	}
	virtual boolean isDirectory(void) {
     c88:	push	{r3, lr}
  }
  /** This function reports if the current file is a directory or not.
  * \return true if the file is a directory.
  */
  bool isDirectory() {
    return BaseFile::isDir();
     c8a:	adds	r0, #24
     c8c:	bl	c68 <FsBaseFile::isDir() const>
		return sdfatfile.isDirectory();
	}
     c90:	pop	{r3, pc}

00000c92 <SDFile::rewindDirectory()>:
	virtual File openNextFile(uint8_t mode=0) {
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
		return File();
	}
	virtual void rewindDirectory(void) {
     c92:	push	{r4, lr}
     c94:	mov	r4, r0
  int read() {
    return BaseFile::read();
  }
  /** Rewind a file if it is a directory */
  void rewindDirectory() {
    if (BaseFile::isDir()) {
     c96:	adds	r0, #24
     c98:	bl	c68 <FsBaseFile::isDir() const>
     c9c:	cbz	r0, cb8 <SDFile::rewindDirectory()+0x26>
    return m_fFile ? m_fFile->rename(dirFile->m_fFile, newPath) :
           m_xFile ? m_xFile->rename(dirFile->m_xFile, newPath) : false;
  }
  /** Set the file's current position to zero. */
  void rewind() {
    if (m_fFile) m_fFile->rewind();
     c9e:	ldr	r0, [r4, #80]	; 0x50
     ca0:	cbz	r0, ca8 <SDFile::rewindDirectory()+0x16>
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
     ca2:	movs	r1, #0
     ca4:	bl	6006 <FatFile::seekSet(unsigned long)>
    if (m_xFile) m_xFile->rewind();
     ca8:	ldr	r0, [r4, #84]	; 0x54
     caa:	cbz	r0, cb8 <SDFile::rewindDirectory()+0x26>
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
     cac:	movs	r2, #0
     cae:	movs	r3, #0
		sdfatfile.rewindDirectory();
	}
     cb0:	ldmia.w	sp!, {r4, lr}
     cb4:	b.w	4374 <ExFatFile::seekSet(unsigned long long)>
     cb8:	pop	{r4, pc}

00000cba <FsBaseFile::isOpen() const>:
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     cba:	ldr	r3, [r0, #56]	; 0x38
     cbc:	cbnz	r3, cc8 <FsBaseFile::isOpen() const+0xe>
     cbe:	ldr	r0, [r0, #60]	; 0x3c
     cc0:	adds	r0, #0
     cc2:	it	ne
     cc4:	movne	r0, #1
     cc6:	bx	lr
     cc8:	movs	r0, #1
     cca:	bx	lr

00000ccc <SDFile::close()>:
		return sdfatfile.curPosition();
	}
	virtual uint64_t size() {
		return sdfatfile.size();
	}
	virtual void close() {
     ccc:	push	{r4, lr}
     cce:	mov	r4, r0
		if (filename) {
     cd0:	ldr	r0, [r0, #88]	; 0x58
     cd2:	cbz	r0, cdc <SDFile::close()+0x10>
			free(filename);
     cd4:	bl	b350 <free>
			filename = nullptr;
     cd8:	movs	r3, #0
     cda:	str	r3, [r4, #88]	; 0x58
		}
		if (sdfatfile.isOpen()) {
     cdc:	adds	r4, #24
     cde:	mov	r0, r4
     ce0:	bl	cba <FsBaseFile::isOpen() const>
     ce4:	cbz	r0, cf0 <SDFile::close()+0x24>
			sdfatfile.close();
     ce6:	mov	r0, r4
		}
	}
     ce8:	ldmia.w	sp!, {r4, lr}
		if (filename) {
			free(filename);
			filename = nullptr;
		}
		if (sdfatfile.isOpen()) {
			sdfatfile.close();
     cec:	b.w	751c <FsBaseFile::close()>
     cf0:	pop	{r4, pc}
     cf2:	Address 0x00000cf2 is out of bounds.


00000cf4 <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     cf4:	push	{r4, lr}
     cf6:	ldr	r3, [pc, #24]	; (d10 <SDFile::~SDFile()+0x1c>)
     cf8:	str	r3, [r0, #0]
     cfa:	mov	r4, r0
		close();
     cfc:	bl	ccc <SDFile::close()>
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     d00:	ldr	r3, [pc, #16]	; (d14 <SDFile::~SDFile()+0x20>)
     d02:	str	r3, [r4, #8]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     d04:	add.w	r0, r4, #24
     d08:	bl	751c <FsBaseFile::close()>
	}
     d0c:	mov	r0, r4
     d0e:	pop	{r4, pc}
     d10:	.word	0x000125a4
     d14:	.word	0x00012530

00000d18 <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     d18:	push	{r4, lr}
     d1a:	mov	r4, r0
		close();
	}
     d1c:	bl	cf4 <SDFile::~SDFile()>
     d20:	mov	r0, r4
     d22:	movs	r1, #92	; 0x5c
     d24:	bl	a3e0 <operator delete(void*, unsigned int)>
     d28:	mov	r0, r4
     d2a:	pop	{r4, pc}

00000d2c <SDFile::isOpen()>:
		}
		if (sdfatfile.isOpen()) {
			sdfatfile.close();
		}
	}
	virtual bool isOpen() {
     d2c:	push	{r3, lr}
		return sdfatfile.isOpen();
     d2e:	adds	r0, #24
     d30:	bl	cba <FsBaseFile::isOpen() const>
	}
     d34:	pop	{r3, pc}

00000d36 <FsBaseFile::peek()>:
  uint64_t position() const {return curPosition();}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
     d36:	mov	r3, r0
    return m_fFile ? m_fFile->peek() :
     d38:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->peek() : -1;
     d3a:	cbz	r0, d40 <FsBaseFile::peek()+0xa>
     d3c:	b.w	5fa4 <FatFile::peek()>
     d40:	ldr	r0, [r3, #60]	; 0x3c
     d42:	cbz	r0, d48 <FsBaseFile::peek()+0x12>
     d44:	b.w	4348 <ExFatFile::peek()>
  }
     d48:	mov.w	r0, #4294967295
     d4c:	bx	lr

00000d4e <StreamFile<FsBaseFile, unsigned long long>::peek()>:
  const char* name() const {return "use getName()";}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
     d4e:	push	{r3, lr}
    return BaseFile::peek();
     d50:	adds	r0, #16
     d52:	bl	d36 <FsBaseFile::peek()>
  }
     d56:	pop	{r3, pc}

00000d58 <SDFile::peek()>:
		close();
	}
	virtual size_t write(const void *buf, size_t size) {
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
     d58:	push	{r3, lr}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    return BaseFile::peek();
     d5a:	adds	r0, #24
     d5c:	bl	d36 <FsBaseFile::peek()>
		return sdfatfile.peek();
	}
     d60:	pop	{r3, pc}

00000d62 <FsBaseFile::read(void*, unsigned int)>:
   * if end of file is reached.
   * If an error occurs, read() returns -1.  Possible errors include
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
     d62:	mov	r3, r0
    return m_fFile ? m_fFile->read(buf, count) :
     d64:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->read(buf, count) : -1;
     d66:	cbz	r0, d6c <FsBaseFile::read(void*, unsigned int)+0xa>
     d68:	b.w	5e2c <FatFile::read(void*, unsigned int)>
     d6c:	ldr	r0, [r3, #60]	; 0x3c
     d6e:	cbz	r0, d74 <FsBaseFile::read(void*, unsigned int)+0x12>
     d70:	b.w	41c4 <ExFatFile::read(void*, unsigned int)>
  }
     d74:	mov.w	r0, #4294967295
     d78:	bx	lr

00000d7a <StreamFile<FsBaseFile, unsigned long long>::read()>:
  /** Read the next byte from a file.
   *
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
     d7a:	push	{r0, r1, r2, lr}
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
     d7c:	movs	r2, #1
     d7e:	add.w	r1, sp, #7
     d82:	adds	r0, #16
     d84:	bl	d62 <FsBaseFile::read(void*, unsigned int)>
     d88:	cmp	r0, #1
     d8a:	ite	eq
     d8c:	ldrbeq.w	r0, [sp, #7]
     d90:	movne.w	r0, #4294967295
    return BaseFile::read();
  }
     d94:	add	sp, #12
     d96:	ldr.w	pc, [sp], #4

00000d9a <SDFile::read(void*, unsigned int)>:
		return sdfatfile.available();
	}
	virtual void flush() {
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
     d9a:	push	{r3, lr}
		return sdfatfile.read(buf, nbyte);
     d9c:	adds	r0, #24
     d9e:	bl	d62 <FsBaseFile::read(void*, unsigned int)>
	}
     da2:	pop	{r3, pc}

00000da4 <FsBaseFile::seekSet(unsigned long long)>:
   *
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
     da4:	push	{r4, r6, r7}
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     da6:	ldr	r4, [r0, #56]	; 0x38
           m_xFile ? m_xFile->seekSet(pos) : false;
     da8:	cbz	r4, dbc <FsBaseFile::seekSet(unsigned long long)+0x18>
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     daa:	cmp	r3, #1
     dac:	it	eq
     dae:	cmpeq	r2, #0
     db0:	bcs.n	dc6 <FsBaseFile::seekSet(unsigned long long)+0x22>
     db2:	mov	r0, r4
     db4:	mov	r1, r2
           m_xFile ? m_xFile->seekSet(pos) : false;
  }
     db6:	pop	{r4, r6, r7}
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     db8:	b.w	6006 <FatFile::seekSet(unsigned long)>
           m_xFile ? m_xFile->seekSet(pos) : false;
     dbc:	ldr	r0, [r0, #60]	; 0x3c
     dbe:	cbz	r0, dc6 <FsBaseFile::seekSet(unsigned long long)+0x22>
  }
     dc0:	pop	{r4, r6, r7}
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     dc2:	b.w	4374 <ExFatFile::seekSet(unsigned long long)>
  }
     dc6:	movs	r0, #0
     dc8:	pop	{r4, r6, r7}
     dca:	bx	lr

00000dcc <SDFile::seek(unsigned long long, int)>:
	virtual bool truncate(uint64_t size=0) {
		return sdfatfile.truncate(size);
	}
	virtual bool seek(uint64_t pos, int mode = SeekSet) {
     dcc:	push	{r3, r4, r5, lr}
     dce:	mov	r1, r0
     dd0:	ldr	r0, [sp, #16]
     dd2:	mov	r4, r2
     dd4:	mov	r5, r3
		if (mode == SeekSet) return sdfatfile.seekSet(pos);
     dd6:	cbnz	r0, dde <SDFile::seek(unsigned long long, int)+0x12>
     dd8:	add.w	r0, r1, #24
     ddc:	b.n	e1a <SDFile::seek(unsigned long long, int)+0x4e>
		if (mode == SeekCur) return sdfatfile.seekCur(pos);
     dde:	cmp	r0, #1
     de0:	bne.n	df8 <SDFile::seek(unsigned long long, int)+0x2c>
    return m_fFile ? m_fFile->contiguousRange(bgnSector, endSector) :
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
     de2:	ldr	r3, [r1, #80]	; 0x50
     de4:	add.w	r0, r1, #24
           m_xFile ? m_xFile->curPosition() : 0;
     de8:	cbz	r3, dee <SDFile::seek(unsigned long long, int)+0x22>
     dea:	ldr	r2, [r3, #20]
     dec:	b.n	e14 <SDFile::seek(unsigned long long, int)+0x48>
     dee:	ldr	r3, [r1, #84]	; 0x54
     df0:	cbz	r3, e12 <SDFile::seek(unsigned long long, int)+0x46>
   *
   * \return true for success or false for failure.
   */
  bool contiguousRange(uint32_t* bgnSector, uint32_t* endSector);
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {return m_curPosition;}
     df2:	ldrd	r2, r3, [r3]
     df6:	b.n	e16 <SDFile::seek(unsigned long long, int)+0x4a>
		if (mode == SeekEnd) return sdfatfile.seekEnd(pos);
     df8:	cmp	r0, #2
     dfa:	bne.n	e20 <SDFile::seek(unsigned long long, int)+0x54>
    return m_fFile ? m_fFile->fgets(str, num, delim) :
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
     dfc:	ldr	r3, [r1, #80]	; 0x50
     dfe:	add.w	r0, r1, #24
           m_xFile ? m_xFile->fileSize() : 0;
     e02:	cbz	r3, e08 <SDFile::seek(unsigned long long, int)+0x3c>
     e04:	ldr	r2, [r3, #28]
     e06:	b.n	e14 <SDFile::seek(unsigned long long, int)+0x48>
     e08:	ldr	r3, [r1, #84]	; 0x54
     e0a:	cbz	r3, e12 <SDFile::seek(unsigned long long, int)+0x46>
   * If no data is read, fgets() returns zero for EOF or -1 if an error
   * occurred.
   */
  int fgets(char* str, int num, char* delim = nullptr);
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {return m_validLength;}
     e0c:	ldrd	r2, r3, [r3, #16]
     e10:	b.n	e16 <SDFile::seek(unsigned long long, int)+0x4a>
     e12:	movs	r2, #0
     e14:	movs	r3, #0
   * Can't be used for directory files since file size is not defined.
   * \param[in] offset The new position in bytes from end-of-file.
   * \return true for success or false for failure.
   */
  bool seekEnd(int64_t offset = 0) {
    return seekSet(fileSize() + offset);
     e16:	adds	r2, r2, r4
     e18:	adcs	r3, r5
     e1a:	bl	da4 <FsBaseFile::seekSet(unsigned long long)>
     e1e:	pop	{r3, r4, r5, pc}
		return false;
     e20:	movs	r0, #0
	}
     e22:	pop	{r3, r4, r5, pc}

00000e24 <FsBaseFile::sync()>:
  /** The sync() call causes all modified data and directory fields
   * to be written to the storage device.
   *
   * \return true for success or false for failure.
   */
  bool sync() {
     e24:	mov	r3, r0
    return m_fFile ? m_fFile->sync() :
     e26:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->sync() : false;
     e28:	cbz	r0, e2e <FsBaseFile::sync()+0xa>
     e2a:	b.w	625c <FatFile::sync()>
     e2e:	ldr	r0, [r3, #60]	; 0x3c
     e30:	cbz	r0, e36 <FsBaseFile::sync()+0x12>
     e32:	b.w	4f8c <ExFatFile::sync()>
  }
     e36:	bx	lr

00000e38 <StreamFile<FsBaseFile, unsigned long long>::flush()>:
   */
  int available() {
    return BaseFile::available();
  }
  /** Ensure that any bytes written to the file are saved to the SD card. */
  void flush() {
     e38:	push	{r3, lr}
    BaseFile::sync();
     e3a:	adds	r0, #16
     e3c:	bl	e24 <FsBaseFile::sync()>
     e40:	pop	{r3, pc}

00000e42 <SDFile::flush()>:
		return sdfatfile.peek();
	}
	virtual int available() {
		return sdfatfile.available();
	}
	virtual void flush() {
     e42:	push	{r3, lr}
     e44:	adds	r0, #24
     e46:	bl	e24 <FsBaseFile::sync()>
     e4a:	pop	{r3, pc}

00000e4c <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
   * Modify and access timestamps may be overwritten if a date time callback
   * function has been set by dateTimeCallback().
   *
   * \return true for success or false for failure.
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
     e4c:	push	{r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
     e4e:	ldr.w	lr, [r0, #56]	; 0x38
   * Modify and access timestamps may be overwritten if a date time callback
   * function has been set by dateTimeCallback().
   *
   * \return true for success or false for failure.
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
     e52:	ldrb.w	r4, [sp, #20]
     e56:	ldrb.w	r5, [sp, #24]
     e5a:	ldrb.w	r6, [sp, #28]
     e5e:	ldrb.w	r7, [sp, #32]
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     e62:	cmp.w	lr, #0
     e66:	beq.n	e7a <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x2e>
     e68:	str	r7, [sp, #32]
     e6a:	str	r6, [sp, #28]
     e6c:	str	r5, [sp, #24]
     e6e:	str	r4, [sp, #20]
     e70:	mov	r0, lr
  }
     e72:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     e76:	b.w	6750 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
     e7a:	ldr	r0, [r0, #60]	; 0x3c
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     e7c:	cbz	r0, e8e <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x42>
     e7e:	str	r7, [sp, #32]
     e80:	str	r6, [sp, #28]
     e82:	str	r5, [sp, #24]
     e84:	str	r4, [sp, #20]
  }
     e86:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     e8a:	b.w	5254 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
  }
     e8e:	pop	{r4, r5, r6, r7, pc}

00000e90 <SDFile::setModifyTime(DateTimeFields const&)>:
	virtual bool setCreateTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
	virtual bool setModifyTime(const DateTimeFields &tm) {
     e90:	push	{r0, r1, r2, r3, r4, lr}
		if (tm.year < 80 || tm.year > 207) return false;
     e92:	ldrb	r2, [r1, #6]
     e94:	sub.w	r3, r2, #80	; 0x50
     e98:	lsls	r3, r3, #24
     e9a:	bmi.n	ec0 <SDFile::setModifyTime(DateTimeFields const&)+0x30>
		return sdfatfile.timestamp(T_WRITE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
     e9c:	ldrb	r4, [r1, #0]
     e9e:	ldrb	r3, [r1, #5]
     ea0:	str	r4, [sp, #12]
     ea2:	ldrb	r4, [r1, #1]
     ea4:	str	r4, [sp, #8]
     ea6:	ldrb	r4, [r1, #2]
     ea8:	str	r4, [sp, #4]
     eaa:	ldrb	r1, [r1, #4]
     eac:	str	r1, [sp, #0]
     eae:	adds	r3, #1
     eb0:	uxtb	r3, r3
     eb2:	addw	r2, r2, #1900	; 0x76c
     eb6:	movs	r1, #4
     eb8:	adds	r0, #24
     eba:	bl	e4c <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
     ebe:	b.n	ec2 <SDFile::setModifyTime(DateTimeFields const&)+0x32>
		if (tm.year < 80 || tm.year > 207) return false;
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
	virtual bool setModifyTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
     ec0:	movs	r0, #0
		return sdfatfile.timestamp(T_WRITE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
     ec2:	add	sp, #16
     ec4:	pop	{r4, pc}

00000ec6 <SDFile::setCreateTime(DateTimeFields const&)>:
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
		tm.year = FS_YEAR(fat_date) - 1900;
		return true;
	}
	virtual bool setCreateTime(const DateTimeFields &tm) {
     ec6:	push	{r0, r1, r2, r3, r4, lr}
		if (tm.year < 80 || tm.year > 207) return false;
     ec8:	ldrb	r2, [r1, #6]
     eca:	sub.w	r3, r2, #80	; 0x50
     ece:	lsls	r3, r3, #24
     ed0:	bmi.n	ef6 <SDFile::setCreateTime(DateTimeFields const&)+0x30>
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
     ed2:	ldrb	r4, [r1, #0]
     ed4:	ldrb	r3, [r1, #5]
     ed6:	str	r4, [sp, #12]
     ed8:	ldrb	r4, [r1, #1]
     eda:	str	r4, [sp, #8]
     edc:	ldrb	r4, [r1, #2]
     ede:	str	r4, [sp, #4]
     ee0:	ldrb	r1, [r1, #4]
     ee2:	str	r1, [sp, #0]
     ee4:	adds	r3, #1
     ee6:	uxtb	r3, r3
     ee8:	addw	r2, r2, #1900	; 0x76c
     eec:	movs	r1, #2
     eee:	adds	r0, #24
     ef0:	bl	e4c <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
     ef4:	b.n	ef8 <SDFile::setCreateTime(DateTimeFields const&)+0x32>
		tm.mon = FS_MONTH(fat_date) - 1;
		tm.year = FS_YEAR(fat_date) - 1900;
		return true;
	}
	virtual bool setCreateTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
     ef6:	movs	r0, #0
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
     ef8:	add	sp, #16
     efa:	pop	{r4, pc}

00000efc <FsBaseFile::write(void const*, unsigned int)>:
   * \param[in] count Number of bytes to write.
   *
   * \return For success write() returns the number of bytes written, always
   * \a nbyte.  If an error occurs, write() returns zero and writeError is set.
   */
  size_t write(const void* buf, size_t count) {
     efc:	mov	r3, r0
    return m_fFile ? m_fFile->write(buf, count) :
     efe:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->write(buf, count) : 0;
     f00:	cbz	r0, f06 <FsBaseFile::write(void const*, unsigned int)+0xa>
     f02:	b.w	6868 <FatFile::write(void const*, unsigned int)>
     f06:	ldr	r0, [r3, #60]	; 0x3c
     f08:	cbz	r0, f0e <FsBaseFile::write(void const*, unsigned int)+0x12>
     f0a:	b.w	5424 <ExFatFile::write(void const*, unsigned int)>
  }
     f0e:	bx	lr

00000f10 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)>:
   * \param[in] size Number of bytes to write.
   *
   * \return For success write() returns the number of bytes written, always
   * \a size.
   */
  size_t write(const uint8_t* buffer, size_t size) {
     f10:	push	{r3, lr}
    return BaseFile::write(buffer, size);
     f12:	adds	r0, #16
     f14:	bl	efc <FsBaseFile::write(void const*, unsigned int)>
  }
     f18:	pop	{r3, pc}

00000f1a <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)>:
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {
     f1a:	push	{r0, r1, r2, lr}
     f1c:	add	r3, sp, #8
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {return write(&b, 1);}
     f1e:	movs	r2, #1
     f20:	strb.w	r1, [r3, #-1]!
     f24:	adds	r0, #16
     f26:	mov	r1, r3
     f28:	bl	efc <FsBaseFile::write(void const*, unsigned int)>
    return BaseFile::write(b);
  }
     f2c:	add	sp, #12
     f2e:	ldr.w	pc, [sp], #4

00000f32 <SDFile::write(void const*, unsigned int)>:
	friend class SDClass;
public:
	virtual ~SDFile(void) {
		close();
	}
	virtual size_t write(const void *buf, size_t size) {
     f32:	push	{r3, lr}
		return sdfatfile.write(buf, size);
     f34:	adds	r0, #24
     f36:	bl	efc <FsBaseFile::write(void const*, unsigned int)>
	}
     f3a:	pop	{r3, pc}

00000f3c <File::close()>:
		return (f) ? f->position() : 0;
	}
	uint64_t size() {
		return (f) ? f->size() : 0;
	}
	void close() {
     f3c:	push	{r4, lr}
     f3e:	mov	r4, r0
		if (f) {
     f40:	ldr	r0, [r0, #16]
     f42:	cbz	r0, f56 <File::close()+0x1a>
			f->close();
     f44:	ldr	r3, [r0, #0]
     f46:	ldr	r3, [r3, #44]	; 0x2c
     f48:	blx	r3
			dec_refcount();
     f4a:	add.w	r0, r4, #16
		}
	}
     f4e:	ldmia.w	sp!, {r4, lr}
		return (f) ? f->size() : 0;
	}
	void close() {
		if (f) {
			f->close();
			dec_refcount();
     f52:	b.w	b7c <File::dec_refcount() [clone .isra.15]>
     f56:	pop	{r4, pc}

00000f58 <SDFile::SDFile(FsFile const&)>:
	// Classes derived from File are never meant to be constructed
	// anywhere other than open() in the parent FS class and
	// openNextFile() while traversing a directory.
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
     f58:	push	{r3, r4, r5, lr}
// FileImpl instances are automatically deleted when the last referencing
// File is closed or goes out of scope.  The refcount variable is meant to
// be maintained by File class instances, never access by FileImpl functions.
// The FileImpl functions are meant to be called only by use of File instances.
//
class FileImpl {
     f5a:	movs	r5, #0
     f5c:	ldr	r3, [pc, #40]	; (f88 <SDFile::SDFile(FsFile const&)+0x30>)
     f5e:	str	r5, [r0, #4]
     f60:	str	r3, [r0, #0]
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
     f62:	ldrb	r3, [r1, #4]
     f64:	strb	r3, [r0, #12]
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
     f66:	ldr	r3, [pc, #36]	; (f8c <SDFile::SDFile(FsFile const&)+0x34>)
     f68:	str	r3, [r0, #8]
     f6a:	ldr	r3, [r1, #8]
     f6c:	str	r3, [r0, #16]
     f6e:	ldrb	r3, [r1, #12]
     f70:	strb	r3, [r0, #20]
     f72:	mov	r4, r0
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     f74:	adds	r1, #16
     f76:	adds	r0, #24
     f78:	bl	74ba <FsBaseFile::FsBaseFile(FsBaseFile const&)>
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     f7c:	ldr	r3, [pc, #16]	; (f90 <SDFile::SDFile(FsFile const&)+0x38>)
     f7e:	str	r3, [r4, #8]
     f80:	str	r5, [r4, #88]	; 0x58
     f82:	mov	r0, r4
     f84:	pop	{r3, r4, r5, pc}
     f86:	nop
     f88:	.word	0x000125a4
     f8c:	.word	0x0001250c
     f90:	.word	0x00012554

00000f94 <SDFile::openNextFile(unsigned char)>:
		return filename;
	}
	virtual boolean isDirectory(void) {
		return sdfatfile.isDirectory();
	}
	virtual File openNextFile(uint8_t mode=0) {
     f94:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     f98:	sub	sp, #84	; 0x54
{
  public:
	constexpr Print() : write_error(0) {}
     f9a:	movs	r5, #0
     f9c:	add.w	r8, sp, #80	; 0x50
     fa0:	ldr	r3, [pc, #108]	; (1010 <SDFile::openNextFile(unsigned char)+0x7c>)
     fa2:	str.w	r3, [r8, #-80]!
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
     fa6:	mov	r2, r5
     fa8:	adds	r1, #24
     faa:	mov	r4, r0
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     fac:	mov.w	r6, #1000	; 0x3e8
     fb0:	add	r0, sp, #16
     fb2:	strb.w	r5, [sp, #4]
     fb6:	str	r6, [sp, #8]
     fb8:	strb.w	r5, [sp, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
     fbc:	str	r5, [sp, #72]	; 0x48
     fbe:	str	r5, [sp, #76]	; 0x4c
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
     fc0:	bl	75c2 <FsBaseFile::openNext(FsBaseFile*, int)>
  FsBaseFile& operator=(const FsBaseFile& from);
  /** The parenthesis operator.
    *
    * \return true if a file is open.
    */
  operator bool() const {return isOpen();}
     fc4:	add	r0, sp, #16
     fc6:	bl	cba <FsBaseFile::isOpen() const>
     fca:	ldr.w	r9, [pc, #76]	; 1018 <SDFile::openNextFile(unsigned char)+0x84>
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
     fce:	cbz	r0, ff2 <SDFile::openNextFile(unsigned char)+0x5e>
     fd0:	movs	r0, #92	; 0x5c
     fd2:	bl	a3dc <operator new(unsigned int)>
     fd6:	mov	r7, r0
     fd8:	mov	r1, r8
     fda:	bl	f58 <SDFile::SDFile(FsFile const&)>
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
		if (f) f->refcount++;
     fde:	ldr	r3, [r7, #4]
     fe0:	strb	r5, [r4, #4]
     fe2:	adds	r3, #1
     fe4:	str	r6, [r4, #8]
     fe6:	strb	r5, [r4, #12]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
     fe8:	str.w	r9, [r4]
		f = file;
     fec:	str	r7, [r4, #16]
		if (f) f->refcount++;
     fee:	str	r3, [r7, #4]
     ff0:	b.n	ffe <SDFile::openNextFile(unsigned char)+0x6a>
     ff2:	strb	r0, [r4, #4]
     ff4:	str	r6, [r4, #8]
     ff6:	strb	r0, [r4, #12]
//
class File final : public Stream {
public:
	// Empty constructor, used when a program creates a File variable
	// but does not immediately assign or initialize it.
	constexpr File() : f(nullptr) { }
     ff8:	str.w	r9, [r4]
     ffc:	str	r0, [r4, #16]
     ffe:	ldr	r3, [pc, #20]	; (1014 <SDFile::openNextFile(unsigned char)+0x80>)
    1000:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
    1002:	add	r0, sp, #16
    1004:	bl	751c <FsBaseFile::close()>
		return File();
	}
    1008:	mov	r0, r4
    100a:	add	sp, #84	; 0x54
    100c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    1010:	.word	0x00012554
    1014:	.word	0x00012530
    1018:	.word	0x00012578

0000101c <SDClass::open(char const*, unsigned char)>:
class SDClass : public FS
{
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
    101c:	push	{r4, r5, r6, lr}
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
    101e:	cmp	r3, #1
class SDClass : public FS
{
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
    1020:	sub	sp, #80	; 0x50
    1022:	mov	r4, r0
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
    1024:	beq.n	1032 <SDClass::open(char const*, unsigned char)+0x16>
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
    1026:	cmp	r3, #2
    1028:	movw	r3, #514	; 0x202
    102c:	it	ne
    102e:	movne	r3, #0
    1030:	b.n	1036 <SDClass::open(char const*, unsigned char)+0x1a>
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
    1032:	movw	r3, #16898	; 0x4202
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
    1036:	adds	r1, #4
    1038:	mov	r0, sp
    103a:	bl	76dc <FsVolume::open(char const*, int)>
  FsBaseFile& operator=(const FsBaseFile& from);
  /** The parenthesis operator.
    *
    * \return true if a file is open.
    */
  operator bool() const {return isOpen();}
    103e:	add	r0, sp, #16
    1040:	bl	cba <FsBaseFile::isOpen() const>
    1044:	ldr	r6, [pc, #68]	; (108c <SDClass::open(char const*, unsigned char)+0x70>)
		if (file) return File(new SDFile(file));
    1046:	cbz	r0, 106e <SDClass::open(char const*, unsigned char)+0x52>
    1048:	movs	r0, #92	; 0x5c
    104a:	bl	a3dc <operator new(unsigned int)>
    104e:	mov	r1, sp
    1050:	mov	r5, r0
    1052:	bl	f58 <SDFile::SDFile(FsFile const&)>
    1056:	movs	r3, #0
    1058:	strb	r3, [r4, #4]
    105a:	strb	r3, [r4, #12]
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
		if (f) f->refcount++;
    105c:	ldr	r3, [r5, #4]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
    105e:	str	r6, [r4, #0]
    1060:	mov.w	r2, #1000	; 0x3e8
		f = file;
		if (f) f->refcount++;
    1064:	adds	r3, #1
    1066:	str	r2, [r4, #8]
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
    1068:	str	r5, [r4, #16]
		if (f) f->refcount++;
    106a:	str	r3, [r5, #4]
    106c:	b.n	107c <SDClass::open(char const*, unsigned char)+0x60>
    106e:	mov.w	r3, #1000	; 0x3e8
    1072:	strb	r0, [r4, #4]
    1074:	str	r3, [r4, #8]
    1076:	strb	r0, [r4, #12]
//
class File final : public Stream {
public:
	// Empty constructor, used when a program creates a File variable
	// but does not immediately assign or initialize it.
	constexpr File() : f(nullptr) { }
    1078:	str	r6, [r4, #0]
    107a:	str	r0, [r4, #16]
    107c:	ldr	r3, [pc, #16]	; (1090 <SDClass::open(char const*, unsigned char)+0x74>)
    107e:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
    1080:	add	r0, sp, #16
    1082:	bl	751c <FsBaseFile::close()>
		return File();
	}
    1086:	mov	r0, r4
    1088:	add	sp, #80	; 0x50
    108a:	pop	{r4, r5, r6, pc}
    108c:	.word	0x00012578
    1090:	.word	0x00012530

00001094 <storeConfig(unsigned short*, int)>:
uint16_t store[16];

extern  int t_acq;

void storeConfig(uint16_t *store, int ns)
{ 
    1094:	push	{r4, r5, r6, lr}
    1096:	sub	sp, #56	; 0x38
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    1098:	ldr	r3, [pc, #120]	; (1114 <storeConfig(unsigned short*, int)+0x80>)
    109a:	str	r3, [sp, #4]
    109c:	mov.w	r2, #1000	; 0x3e8
    10a0:	movs	r3, #0
    10a2:	strb.w	r3, [sp, #8]
    10a6:	str	r2, [sp, #12]
    10a8:	strb.w	r3, [sp, #16]
    10ac:	str	r3, [sp, #20]
uint16_t store[16];

extern  int t_acq;

void storeConfig(uint16_t *store, int ns)
{ 
    10ae:	mov	r5, r0
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    char text[32];
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
    10b0:	movs	r3, #2
uint16_t store[16];

extern  int t_acq;

void storeConfig(uint16_t *store, int ns)
{ 
    10b2:	mov	r6, r1
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    char text[32];
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
    10b4:	ldr	r2, [pc, #96]	; (1118 <storeConfig(unsigned short*, int)+0x84>)
    10b6:	ldr	r1, [pc, #100]	; (111c <storeConfig(unsigned short*, int)+0x88>)
    10b8:	add	r0, sp, #24
    10ba:	bl	101c <SDClass::open(char const*, unsigned char)>
	}
#ifdef FILE_USE_MOVE
	// Move assignment.
	File& operator = (const File&& file) {
		//Serial.println("File move assignment");
		if (file.f) file.f->refcount++;
    10be:	ldr	r3, [sp, #40]	; 0x28
    10c0:	cbz	r3, 10c8 <storeConfig(unsigned short*, int)+0x34>
    10c2:	ldr	r2, [r3, #4]
    10c4:	adds	r2, #1
    10c6:	str	r2, [r3, #4]
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
    10c8:	ldr	r3, [sp, #20]
    10ca:	cbz	r3, 10d2 <storeConfig(unsigned short*, int)+0x3e>
    10cc:	add	r0, sp, #20
    10ce:	bl	b7c <File::dec_refcount() [clone .isra.15]>
		f = file.f;
    10d2:	ldr	r3, [sp, #40]	; 0x28
    10d4:	str	r3, [sp, #20]
    10d6:	add	r0, sp, #24
    10d8:	bl	ba0 <File::~File()>
      for(int ii=0; ii<ns; ii++)
    10dc:	movs	r4, #0
    10de:	cmp	r4, r6
    10e0:	bge.n	1102 <storeConfig(unsigned short*, int)+0x6e>
      { sprintf(text,"%10d\r\n",(int) store[ii]); configFile.write((uint8_t*)text,strlen(text)); }
    10e2:	ldrh.w	r2, [r5, r4, lsl #1]
    10e6:	ldr	r1, [pc, #56]	; (1120 <storeConfig(unsigned short*, int)+0x8c>)
    10e8:	add	r0, sp, #24
    10ea:	bl	bed8 <sprintf>
    10ee:	add	r0, sp, #24
    10f0:	bl	bf80 <strlen>
    10f4:	add	r1, sp, #24
    10f6:	mov	r2, r0
    10f8:	add	r0, sp, #4
    10fa:	bl	9be <File::write(unsigned char const*, unsigned int)>
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    char text[32];
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
      for(int ii=0; ii<ns; ii++)
    10fe:	adds	r4, #1
    1100:	b.n	10de <storeConfig(unsigned short*, int)+0x4a>
      { sprintf(text,"%10d\r\n",(int) store[ii]); configFile.write((uint8_t*)text,strlen(text)); }
    configFile.close();
    1102:	add	r0, sp, #4
    1104:	bl	f3c <File::close()>

void storeConfig(uint16_t *store, int ns)
{ 
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    1108:	add	r0, sp, #4
    110a:	bl	ba0 <File::~File()>
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
      for(int ii=0; ii<ns; ii++)
      { sprintf(text,"%10d\r\n",(int) store[ii]); configFile.write((uint8_t*)text,strlen(text)); }
    configFile.close();
  
}
    110e:	add	sp, #56	; 0x38
    1110:	pop	{r4, r5, r6, pc}
    1112:	nop
    1114:	.word	0x00012578
    1118:	.word	0x000125f8
    111c:	.word	0x20017c34
    1120:	.word	0x00012604

00001124 <saveParameters()>:
    configFile.close();
}

void saveParameters(void)
{
  store[0]= 1;
    1124:	ldr	r0, [pc, #16]	; (1138 <saveParameters()+0x14>)
    1126:	movs	r3, #1
    1128:	strh	r3, [r0, #0]
  store[2]= t_acq;
    112a:	ldr	r3, [pc, #16]	; (113c <saveParameters()+0x18>)

  storeConfig(store, 16);
    112c:	movs	r1, #16
}

void saveParameters(void)
{
  store[0]= 1;
  store[2]= t_acq;
    112e:	ldr	r3, [r3, #0]
    1130:	strh	r3, [r0, #4]

  storeConfig(store, 16);
    1132:	b.w	1094 <storeConfig(unsigned short*, int)>
    1136:	nop
    1138:	.word	0x1fff21ea
    113c:	.word	0x1fff0f34

00001140 <printMenu()>:
  }
}


void printMenu(void)
{
    1140:	push	{r4, lr}
  Serial.println("\n Menu");
    1142:	ldr	r4, [pc, #144]	; (11d4 <printMenu()+0x94>)
    1144:	ldr	r1, [pc, #144]	; (11d8 <printMenu()+0x98>)
    1146:	mov	r0, r4
    1148:	bl	788 <Print::println(char const*)>
  Serial.println(" ':h'  : print help");
    114c:	ldr	r1, [pc, #140]	; (11dc <printMenu()+0x9c>)
    114e:	mov	r0, r4
    1150:	bl	788 <Print::println(char const*)>
  Serial.println(" ':s'  : start acquisition");
    1154:	ldr	r1, [pc, #136]	; (11e0 <printMenu()+0xa0>)
    1156:	mov	r0, r4
    1158:	bl	788 <Print::println(char const*)>
  Serial.println(" ':e'  : stop acquisition");
    115c:	ldr	r1, [pc, #132]	; (11e4 <printMenu()+0xa4>)
    115e:	mov	r0, r4
    1160:	bl	788 <Print::println(char const*)>
  Serial.println(" ':w'  : write parameters to microSD card");
    1164:	ldr	r1, [pc, #128]	; (11e8 <printMenu()+0xa8>)
    1166:	mov	r0, r4
    1168:	bl	788 <Print::println(char const*)>
  Serial.println(" ':l'  : list disks");
    116c:	ldr	r1, [pc, #124]	; (11ec <printMenu()+0xac>)
    116e:	mov	r0, r4
    1170:	bl	788 <Print::println(char const*)>
  Serial.println(" ':r'  : reset MTP");
    1174:	ldr	r1, [pc, #120]	; (11f0 <printMenu()+0xb0>)
    1176:	mov	r0, r4
    1178:	bl	788 <Print::println(char const*)>
  Serial.println(" ':b'  : reboot CPU");
    117c:	ldr	r1, [pc, #116]	; (11f4 <printMenu()+0xb4>)
    117e:	mov	r0, r4
    1180:	bl	788 <Print::println(char const*)>
//  Serial.println(" ':d'  : dump Index List (testing)");
  Serial.println();
    1184:	mov	r0, r4
    1186:	bl	a1e4 <Print::println()>
  Serial.println(" '?p'  : show all parameters");
    118a:	ldr	r1, [pc, #108]	; (11f8 <printMenu()+0xb8>)
    118c:	mov	r0, r4
    118e:	bl	788 <Print::println(char const*)>
  Serial.println(" '?d'  : get date");
    1192:	ldr	r1, [pc, #104]	; (11fc <printMenu()+0xbc>)
    1194:	mov	r0, r4
    1196:	bl	788 <Print::println(char const*)>
  Serial.println(" '?t'  : get time");
    119a:	ldr	r1, [pc, #100]	; (1200 <printMenu()+0xc0>)
    119c:	mov	r0, r4
    119e:	bl	788 <Print::println(char const*)>
  Serial.println(" '?a'  : get file duration (s)");
    11a2:	ldr	r1, [pc, #96]	; (1204 <printMenu()+0xc4>)
    11a4:	mov	r0, r4
    11a6:	bl	788 <Print::println(char const*)>
  Serial.println();
    11aa:	mov	r0, r4
    11ac:	bl	a1e4 <Print::println()>
  Serial.println(" '!d yyyy/mm/dd<cr>'  : set date");
    11b0:	ldr	r1, [pc, #84]	; (1208 <printMenu()+0xc8>)
    11b2:	mov	r0, r4
    11b4:	bl	788 <Print::println(char const*)>
  Serial.println(" '!t hh:mm:ss<cr>'    : set time");
    11b8:	ldr	r1, [pc, #80]	; (120c <printMenu()+0xcc>)
    11ba:	mov	r0, r4
    11bc:	bl	788 <Print::println(char const*)>
  Serial.println(" '!a val<cr>'  : set file duration (s)");
    11c0:	mov	r0, r4
    11c2:	ldr	r1, [pc, #76]	; (1210 <printMenu()+0xd0>)
    11c4:	bl	788 <Print::println(char const*)>
  Serial.println();
    11c8:	mov	r0, r4
}
    11ca:	ldmia.w	sp!, {r4, lr}
  Serial.println(" '?a'  : get file duration (s)");
  Serial.println();
  Serial.println(" '!d yyyy/mm/dd<cr>'  : set date");
  Serial.println(" '!t hh:mm:ss<cr>'    : set time");
  Serial.println(" '!a val<cr>'  : set file duration (s)");
  Serial.println();
    11ce:	b.w	a1e4 <Print::println()>
    11d2:	nop
    11d4:	.word	0x1fff1348
    11d8:	.word	0x0001260b
    11dc:	.word	0x00012612
    11e0:	.word	0x00012626
    11e4:	.word	0x00012641
    11e8:	.word	0x0001265b
    11ec:	.word	0x00012685
    11f0:	.word	0x00012699
    11f4:	.word	0x000126ac
    11f8:	.word	0x000126c0
    11fc:	.word	0x000126dd
    1200:	.word	0x000126ef
    1204:	.word	0x00012701
    1208:	.word	0x00012720
    120c:	.word	0x00012741
    1210:	.word	0x00012762

00001214 <printMenuEntries()>:
}

void printMenuEntries(void)
{
    1214:	push	{r0, r1, r2, r3, r4, lr}
    tmElements_t tm;
    breakTime(rtc_get(), tm);

  Serial.println("CVAS_V3 Version: " __DATE__  " " __TIME__ );
    1216:	ldr	r4, [pc, #96]	; (1278 <printMenuEntries()+0x64>)
}

void printMenuEntries(void)
{
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    1218:	bl	9468 <rtc_get>
    121c:	add	r1, sp, #8
    121e:	bl	14f8 <breakTime(unsigned long, tmElements_t&)>

  Serial.println("CVAS_V3 Version: " __DATE__  " " __TIME__ );
    1222:	ldr	r1, [pc, #88]	; (127c <printMenuEntries()+0x68>)
    1224:	mov	r0, r4
    1226:	bl	788 <Print::println(char const*)>
  Serial.printf("Teensy: %d: %06x\n",teensy,SerNum);
    122a:	ldr	r3, [pc, #84]	; (1280 <printMenuEntries()+0x6c>)
    122c:	ldr	r1, [pc, #84]	; (1284 <printMenuEntries()+0x70>)
    122e:	ldr	r3, [r3, #0]
    1230:	movs	r2, #36	; 0x24
    1232:	mov	r0, r4
    1234:	bl	a204 <Print::printf(char const*, ...)>
  Serial.printf("Date d = %04d/%02d/%02d\n",tmYearToCalendar(tm.Year), tm.Month, tm.Day); 
    1238:	ldrb.w	r2, [sp, #14]
    123c:	ldrb.w	r1, [sp, #12]
    1240:	ldrb.w	r3, [sp, #13]
    1244:	str	r1, [sp, #0]
    1246:	addw	r2, r2, #1970	; 0x7b2
    124a:	ldr	r1, [pc, #60]	; (1288 <printMenuEntries()+0x74>)
    124c:	mov	r0, r4
    124e:	bl	a204 <Print::printf(char const*, ...)>
  Serial.printf("Time t = %02d:%02d:%02d\n",tm.Hour, tm.Minute, tm.Second); 
    1252:	ldrb.w	r1, [sp, #8]
    1256:	ldrb.w	r3, [sp, #9]
    125a:	ldrb.w	r2, [sp, #10]
    125e:	str	r1, [sp, #0]
    1260:	mov	r0, r4
    1262:	ldr	r1, [pc, #40]	; (128c <printMenuEntries()+0x78>)
    1264:	bl	a204 <Print::printf(char const*, ...)>
  Serial.printf("T_acq a = %d\n",t_acq); 
    1268:	ldr	r3, [pc, #36]	; (1290 <printMenuEntries()+0x7c>)
    126a:	ldr	r1, [pc, #40]	; (1294 <printMenuEntries()+0x80>)
    126c:	ldr	r2, [r3, #0]
    126e:	mov	r0, r4
    1270:	bl	a204 <Print::printf(char const*, ...)>
}
    1274:	add	sp, #16
    1276:	pop	{r4, pc}
    1278:	.word	0x1fff1348
    127c:	.word	0x00012789
    1280:	.word	0x2001a1c0
    1284:	.word	0x000127af
    1288:	.word	0x000127c1
    128c:	.word	0x000127da
    1290:	.word	0x1fff0f34
    1294:	.word	0x000127f3

00001298 <menuGetInt(int*)>:

int menuGetInt(int *val)
{ char buffer[40];
    1298:	push	{r4, lr}
    129a:	mov	r4, r0
    129c:	sub	sp, #40	; 0x28
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    129e:	bl	91ac <usb_serial_available>
  while(!Serial.available());
    12a2:	cmp	r0, #0
    12a4:	beq.n	129e <menuGetInt(int*)+0x6>
  int count = Serial.readBytesUntil('\r',buffer,40);
    12a6:	mov	r2, sp
    12a8:	movs	r3, #40	; 0x28
    12aa:	movs	r1, #13
    12ac:	ldr	r0, [pc, #28]	; (12cc <menuGetInt(int*)+0x34>)
    12ae:	bl	a394 <Stream::readBytesUntil(char, char*, unsigned int)>
  buffer[count]=0;
    12b2:	add	r3, sp, #40	; 0x28
    12b4:	add	r0, r3
    12b6:	movs	r3, #0
    12b8:	strb.w	r3, [r0, #-40]
//  Serial.println(buffer);
  return sscanf(buffer,"%d",val);
    12bc:	mov	r2, r4
    12be:	ldr	r1, [pc, #16]	; (12d0 <menuGetInt(int*)+0x38>)
    12c0:	mov	r0, sp
    12c2:	bl	bf24 <sscanf>
}
    12c6:	add	sp, #40	; 0x28
    12c8:	pop	{r4, pc}
    12ca:	nop
    12cc:	.word	0x1fff1348
    12d0:	.word	0x00012880

000012d4 <menuGet3Int(int*, int*, int*)>:

int menuGet3Int(int *val1, int *val2, int *val3)
{ char buffer[40];
    12d4:	push	{r4, r5, r6, lr}
    12d6:	mov	r4, r0
    12d8:	sub	sp, #64	; 0x40
    12da:	mov	r5, r1
    12dc:	mov	r6, r2
    12de:	bl	91ac <usb_serial_available>
  while(!Serial.available());
    12e2:	cmp	r0, #0
    12e4:	beq.n	12de <menuGet3Int(int*, int*, int*)+0xa>
  int count = Serial.readBytesUntil('\r',buffer,40);
    12e6:	add	r2, sp, #24
    12e8:	movs	r3, #40	; 0x28
    12ea:	movs	r1, #13
    12ec:	ldr	r0, [pc, #40]	; (1318 <menuGet3Int(int*, int*, int*)+0x44>)
    12ee:	bl	a394 <Stream::readBytesUntil(char, char*, unsigned int)>
  buffer[count]=0;
    12f2:	add	r3, sp, #64	; 0x40
    12f4:	add	r0, r3
    12f6:	movs	r3, #0
    12f8:	strb.w	r3, [r0, #-40]
//  Serial.println(buffer);
  char c1,c2;
  return sscanf(buffer,"%d%c%d%c%d",val1,&c1,val2,&c2,val3);
    12fc:	add.w	r3, sp, #23
    1300:	str	r3, [sp, #4]
    1302:	str	r6, [sp, #8]
    1304:	str	r5, [sp, #0]
    1306:	add.w	r3, sp, #22
    130a:	mov	r2, r4
    130c:	ldr	r1, [pc, #12]	; (131c <menuGet3Int(int*, int*, int*)+0x48>)
    130e:	add	r0, sp, #24
    1310:	bl	bf24 <sscanf>
}
    1314:	add	sp, #64	; 0x40
    1316:	pop	{r4, r5, r6, pc}
    1318:	.word	0x1fff1348
    131c:	.word	0x00012801

00001320 <menu()>:
#if defined (KINETISK) 
#define CPU_RESTART 
#endif

int16_t menu(void)
{
    1320:	push	{r4, lr}
    1322:	sub	sp, #32
    1324:	bl	91ac <usb_serial_available>
  if(!Serial.available()) return 0;
    1328:	cmp	r0, #0
    132a:	beq.w	14a8 <menu()+0x188>
        virtual int read() { return usb_serial_getchar(); }
    132e:	bl	9128 <usb_serial_getchar>

  char ch=Serial.read();
    1332:	uxtb	r0, r0
  if(ch==':')
    1334:	cmp	r0, #58	; 0x3a
    1336:	bne.n	13b8 <menu()+0x98>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    1338:	bl	91ac <usb_serial_available>
  { while(!Serial.available()) ; ch=Serial.read();
    133c:	cmp	r0, #0
    133e:	beq.n	1338 <menu()+0x18>
        virtual int read() { return usb_serial_getchar(); }
    1340:	bl	9128 <usb_serial_getchar>
    1344:	uxtb	r0, r0

    if(ch=='s') { Serial.print("\n"); Serial.print("start"); return  +1;} // start acq
    1346:	cmp	r0, #115	; 0x73
    1348:	bne.n	135e <menu()+0x3e>
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
    134a:	ldr	r1, [pc, #356]	; (14b0 <menu()+0x190>)
    134c:	ldr	r0, [pc, #356]	; (14b4 <menu()+0x194>)
    134e:	bl	764 <Print::write(char const*)>
    1352:	ldr	r1, [pc, #356]	; (14b8 <menu()+0x198>)
    1354:	ldr	r0, [pc, #348]	; (14b4 <menu()+0x194>)
    1356:	bl	764 <Print::write(char const*)>
    135a:	movs	r0, #1
    135c:	b.n	14aa <menu()+0x18a>
    else if(ch=='e') { Serial.print("\n"); Serial.print("stop");  return  -1;} // end acq
    135e:	cmp	r0, #101	; 0x65
    1360:	bne.n	1378 <menu()+0x58>
    1362:	ldr	r1, [pc, #332]	; (14b0 <menu()+0x190>)
    1364:	ldr	r0, [pc, #332]	; (14b4 <menu()+0x194>)
    1366:	bl	764 <Print::write(char const*)>
    136a:	ldr	r1, [pc, #336]	; (14bc <menu()+0x19c>)
    136c:	ldr	r0, [pc, #324]	; (14b4 <menu()+0x194>)
    136e:	bl	764 <Print::write(char const*)>
    1372:	mov.w	r0, #4294967295
    1376:	b.n	14aa <menu()+0x18a>
    else if(ch=='h') { printMenu(); return 0;} 
    1378:	cmp	r0, #104	; 0x68
    137a:	bne.n	1382 <menu()+0x62>
    137c:	bl	1140 <printMenu()>
    1380:	b.n	14a8 <menu()+0x188>
    else if(ch=='w') { saveParameters(); return 0;} 
    1382:	cmp	r0, #119	; 0x77
    1384:	bne.n	138c <menu()+0x6c>
    1386:	bl	1124 <saveParameters()>
    138a:	b.n	14a8 <menu()+0x188>
    else if(ch=='l') { listDisks(); return 0;} 
    138c:	cmp	r0, #108	; 0x6c
    138e:	bne.n	1396 <menu()+0x76>
    1390:	bl	1d68 <listDisks()>
    1394:	b.n	14a8 <menu()+0x188>
    else if(ch=='b') { Serial.print("\n"); Serial.print("rebooting CPU"); Serial.flush(); delay(100); CPU_RESTART; return 0;} 
    1396:	cmp	r0, #98	; 0x62
    1398:	bne.w	14a8 <menu()+0x188>
    139c:	ldr	r1, [pc, #272]	; (14b0 <menu()+0x190>)
    139e:	ldr	r0, [pc, #276]	; (14b4 <menu()+0x194>)
    13a0:	bl	764 <Print::write(char const*)>
    13a4:	ldr	r1, [pc, #280]	; (14c0 <menu()+0x1a0>)
    13a6:	ldr	r0, [pc, #268]	; (14b4 <menu()+0x194>)
    13a8:	bl	764 <Print::write(char const*)>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    13ac:	bl	9338 <usb_serial_flush_output>
    13b0:	movs	r0, #100	; 0x64
    13b2:	bl	9578 <delay>
    13b6:	b.n	14a8 <menu()+0x188>
  }
  else if(ch=='?') // get info
    13b8:	cmp	r0, #63	; 0x3f
    13ba:	bne.n	1426 <menu()+0x106>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    13bc:	bl	91ac <usb_serial_available>
  {
    while(!Serial.available()) ; ch=Serial.read();
    13c0:	cmp	r0, #0
    13c2:	beq.n	13bc <menu()+0x9c>
        virtual int read() { return usb_serial_getchar(); }
    13c4:	bl	9128 <usb_serial_getchar>
    13c8:	uxtb	r4, r0

    tmElements_t tm;
    breakTime(rtc_get(), tm);
    13ca:	bl	9468 <rtc_get>
    13ce:	add	r1, sp, #24
    13d0:	bl	14f8 <breakTime(unsigned long, tmElements_t&)>

    if(ch=='p') { printMenuEntries(); return 0;} 
    13d4:	cmp	r4, #112	; 0x70
    13d6:	bne.n	13de <menu()+0xbe>
    13d8:	bl	1214 <printMenuEntries()>
    13dc:	b.n	14a8 <menu()+0x188>
    else if(ch=='d') { Serial.printf("%04d/%02d/%02d\n",tmYearToCalendar(tm.Year), tm.Month, tm.Day); return  0;} // display date
    13de:	cmp	r4, #100	; 0x64
    13e0:	bne.n	13f8 <menu()+0xd8>
    13e2:	ldrb.w	r2, [sp, #30]
    13e6:	ldrb.w	r1, [sp, #28]
    13ea:	str	r1, [sp, #0]
    13ec:	ldrb.w	r3, [sp, #29]
    13f0:	ldr	r1, [pc, #208]	; (14c4 <menu()+0x1a4>)
    13f2:	addw	r2, r2, #1970	; 0x7b2
    13f6:	b.n	140c <menu()+0xec>
    else if(ch=='t') { Serial.printf("%02d:%02d:%02d\n",tm.Hour, tm.Minute, tm.Second); return  0;} // display time
    13f8:	cmp	r4, #116	; 0x74
    13fa:	bne.n	1414 <menu()+0xf4>
    13fc:	ldrb.w	r1, [sp, #24]
    1400:	str	r1, [sp, #0]
    1402:	ldrb.w	r3, [sp, #25]
    1406:	ldrb.w	r2, [sp, #26]
    140a:	ldr	r1, [pc, #188]	; (14c8 <menu()+0x1a8>)
    140c:	ldr	r0, [pc, #164]	; (14b4 <menu()+0x194>)
    140e:	bl	a204 <Print::printf(char const*, ...)>
    1412:	b.n	14a8 <menu()+0x188>
    else if(ch=='a') { Serial.printf("%d\n",t_acq); return  0;} // file size
    1414:	cmp	r4, #97	; 0x61
    1416:	bne.n	14a8 <menu()+0x188>
    1418:	ldr	r3, [pc, #176]	; (14cc <menu()+0x1ac>)
    141a:	ldr	r1, [pc, #180]	; (14d0 <menu()+0x1b0>)
    141c:	ldr	r2, [r3, #0]
    141e:	ldr	r0, [pc, #148]	; (14b4 <menu()+0x194>)
    1420:	bl	a204 <Print::printf(char const*, ...)>
    1424:	b.n	14a8 <menu()+0x188>
  }
  else if(ch=='!') // set 
    1426:	cmp	r0, #33	; 0x21
    1428:	bne.n	14a8 <menu()+0x188>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    142a:	bl	91ac <usb_serial_available>
  { 
    while(!Serial.available()) ;
    142e:	cmp	r0, #0
    1430:	beq.n	142a <menu()+0x10a>
        virtual int read() { return usb_serial_getchar(); }
    1432:	bl	9128 <usb_serial_getchar>
    ch=Serial.read();
    1436:	uxtb	r0, r0
    if(ch=='d') // set date
    1438:	cmp	r0, #100	; 0x64
    143a:	bne.n	1468 <menu()+0x148>
    { int year,month,day;
      menuGet3Int(&year,&month,&day);
    143c:	add	r2, sp, #20
    143e:	add	r1, sp, #16
    1440:	add	r0, sp, #12
    1442:	bl	12d4 <menuGet3Int(int*, int*, int*)>
      tmElements_t tm;
      breakTime(rtc_get(), tm);
    1446:	bl	9468 <rtc_get>
    144a:	add	r1, sp, #24
    144c:	bl	14f8 <breakTime(unsigned long, tmElements_t&)>

      setRTCTime(tm.Hour, tm.Minute, tm.Second, day, month, year);
    1450:	ldr	r3, [sp, #12]
    1452:	str	r3, [sp, #4]
    1454:	ldr	r3, [sp, #16]
    1456:	str	r3, [sp, #0]
    1458:	ldrb.w	r2, [sp, #24]
    145c:	ldrb.w	r1, [sp, #25]
    1460:	ldrb.w	r0, [sp, #26]
    1464:	ldr	r3, [sp, #20]
    1466:	b.n	1498 <menu()+0x178>
      return  0;
    } 
    else if(ch=='t') // set time
    1468:	cmp	r0, #116	; 0x74
    146a:	bne.n	149e <menu()+0x17e>
    { int hour,minutes,seconds;
      menuGet3Int(&hour,&minutes,&seconds);
    146c:	add	r2, sp, #20
    146e:	add	r1, sp, #16
    1470:	add	r0, sp, #12
    1472:	bl	12d4 <menuGet3Int(int*, int*, int*)>

      tmElements_t tm;
      breakTime(rtc_get(), tm);
    1476:	bl	9468 <rtc_get>
    147a:	add	r1, sp, #24
    147c:	bl	14f8 <breakTime(unsigned long, tmElements_t&)>
      setRTCTime(hour, minutes, seconds, tm.Day, tm.Month, tmYearToCalendar(tm.Year));
    1480:	ldrb.w	r2, [sp, #30]
    1484:	ldrb.w	r3, [sp, #28]
    1488:	addw	r2, r2, #1970	; 0x7b2
    148c:	str	r2, [sp, #4]
    148e:	ldrb.w	r2, [sp, #29]
    1492:	str	r2, [sp, #0]
    1494:	add	r0, sp, #12
    1496:	ldmia	r0, {r0, r1, r2}
    1498:	bl	16e4 <setRTCTime(int, int, int, int, int, int)>
    149c:	b.n	14a8 <menu()+0x188>
      return  0;
    } 
    else if(ch=='a') { menuGetInt(&t_acq); return  0;} // file size
    149e:	cmp	r0, #97	; 0x61
    14a0:	bne.n	14a8 <menu()+0x188>
    14a2:	ldr	r0, [pc, #40]	; (14cc <menu()+0x1ac>)
    14a4:	bl	1298 <menuGetInt(int*)>
    14a8:	movs	r0, #0
  }
  return 0;
}
    14aa:	add	sp, #32
    14ac:	pop	{r4, pc}
    14ae:	nop
    14b0:	.word	0x00012da8
    14b4:	.word	0x1fff1348
    14b8:	.word	0x0001280c
    14bc:	.word	0x00012812
    14c0:	.word	0x00012817
    14c4:	.word	0x000127ca
    14c8:	.word	0x000127e3
    14cc:	.word	0x1fff0f34
    14d0:	.word	0x000127fd

000014d4 <newHour()>:
    return 1;
}

int32_t hour_ = 0;
int16_t newHour(void)
{   uint32_t tx=rtc_get();
    14d4:	push	{r3, lr}
    14d6:	bl	9468 <rtc_get>
    int32_t h_ = (int32_t) tx/SECS_PER_HOUR;  // use hours since 1970 as measures
    14da:	mov.w	r3, #3600	; 0xe10
    14de:	udiv	r0, r0, r3
    if(hour_== h_) return 0;
    14e2:	ldr	r3, [pc, #16]	; (14f4 <newHour()+0x20>)
    14e4:	ldr	r2, [r3, #0]
    14e6:	cmp	r0, r2
    hour_ = h_;
    14e8:	itte	ne
    14ea:	strne	r0, [r3, #0]
    return 1;
    14ec:	movne	r0, #1

int32_t hour_ = 0;
int16_t newHour(void)
{   uint32_t tx=rtc_get();
    int32_t h_ = (int32_t) tx/SECS_PER_HOUR;  // use hours since 1970 as measures
    if(hour_== h_) return 0;
    14ee:	moveq	r0, #0
    hour_ = h_;
    return 1;
}
    14f0:	pop	{r3, pc}
    14f2:	nop
    14f4:	.word	0x1fff220c

000014f8 <breakTime(unsigned long, tmElements_t&)>:
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    14f8:	movs	r3, #60	; 0x3c
/* functions to convert to and from system time */
/* These are for interfacing with time services and are not normally needed in a sketch */

static  const uint8_t monthDays[]={31,28,31,30,31,30,31,31,30,31,30,31}; // API starts months from 1, this array starts from 0
 
void breakTime(uint32_t timeInput, tmElements_t &tm){
    14fa:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    14fe:	udiv	r4, r0, r3
    1502:	mls	r2, r3, r4, r0
    1506:	strb	r2, [r1, #0]
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    1508:	udiv	r2, r4, r3
    150c:	mls	r3, r3, r2, r4
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    1510:	movs	r4, #24
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    1512:	strb	r3, [r1, #1]
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    1514:	mov.w	r3, #3600	; 0xe10
    1518:	udiv	r3, r0, r3
    151c:	udiv	r2, r3, r4
    1520:	mls	r3, r4, r2, r3
    1524:	strb	r3, [r1, #2]
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    1526:	movs	r2, #7
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
    1528:	ldr	r3, [pc, #240]	; (161c <breakTime(unsigned long, tmElements_t&)+0x124>)
    152a:	udiv	r0, r0, r3
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    152e:	adds	r3, r0, #4
    1530:	udiv	r2, r3, r2
    1534:	rsb	r2, r2, r2, lsl #3
    1538:	subs	r3, r3, r2
    153a:	adds	r3, #1
    153c:	movs	r4, #0
    153e:	strb	r3, [r1, #3]
  
  year = 0;  
  days = 0;
    1540:	mov	r2, r4
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    1542:	movw	r8, #365	; 0x16d
    1546:	mov.w	lr, #100	; 0x64
    154a:	mov.w	ip, #400	; 0x190
    154e:	uxtb	r6, r4
    1550:	addw	r3, r6, #1970	; 0x7b2
    1554:	ands.w	r7, r3, #3
    1558:	bne.n	1578 <breakTime(unsigned long, tmElements_t&)+0x80>
    155a:	sdiv	r5, r3, lr
    155e:	mls	r5, lr, r5, r3
    1562:	cbnz	r5, 157e <breakTime(unsigned long, tmElements_t&)+0x86>
    1564:	sdiv	r5, r3, ip
    1568:	mls	r5, ip, r5, r3
    156c:	cmp	r5, #0
    156e:	ite	ne
    1570:	movne	r5, r8
    1572:	moveq.w	r5, #366	; 0x16e
    1576:	b.n	1582 <breakTime(unsigned long, tmElements_t&)+0x8a>
    1578:	movw	r5, #365	; 0x16d
    157c:	b.n	1582 <breakTime(unsigned long, tmElements_t&)+0x8a>
    157e:	mov.w	r5, #366	; 0x16e
    1582:	add	r2, r5
    1584:	cmp	r0, r2
    1586:	add.w	r4, r4, #1
    158a:	bcs.n	154e <breakTime(unsigned long, tmElements_t&)+0x56>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
    158c:	strb	r6, [r1, #6]
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    158e:	cbnz	r7, 15b6 <breakTime(unsigned long, tmElements_t&)+0xbe>
    1590:	movs	r5, #100	; 0x64
    1592:	sdiv	r4, r3, r5
    1596:	mls	r4, r5, r4, r3
    159a:	cbnz	r4, 15bc <breakTime(unsigned long, tmElements_t&)+0xc4>
    159c:	mov.w	r5, #400	; 0x190
    15a0:	sdiv	r4, r3, r5
    15a4:	mls	r4, r5, r4, r3
    15a8:	cmp	r4, #0
    15aa:	movw	r4, #365	; 0x16d
    15ae:	it	eq
    15b0:	moveq.w	r4, #366	; 0x16e
    15b4:	b.n	15c0 <breakTime(unsigned long, tmElements_t&)+0xc8>
    15b6:	movw	r4, #365	; 0x16d
    15ba:	b.n	15c0 <breakTime(unsigned long, tmElements_t&)+0xc8>
    15bc:	mov.w	r4, #366	; 0x16e
  time  -= days; // now it is days in this year, starting at 0
    15c0:	subs	r2, r2, r4
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    15c2:	movs	r6, #100	; 0x64
    15c4:	mov.w	r4, #400	; 0x190
        monthLength=29;
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    15c8:	ldr.w	lr, [pc, #84]	; 1620 <breakTime(unsigned long, tmElements_t&)+0x128>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
  time  -= days; // now it is days in this year, starting at 0
    15cc:	subs	r0, r0, r2
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    15ce:	sdiv	r2, r3, r6
    15d2:	mls	r6, r6, r2, r3
    15d6:	sdiv	r2, r3, r4
    15da:	mls	r3, r4, r2, r3
    15de:	movs	r2, #0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
    15e0:	cmp	r2, #1
    15e2:	uxtb	r5, r2
    15e4:	bne.n	15f4 <breakTime(unsigned long, tmElements_t&)+0xfc>
      if (LEAP_YEAR(year)) {
    15e6:	cbnz	r7, 15fa <breakTime(unsigned long, tmElements_t&)+0x102>
    15e8:	cbnz	r6, 15fe <breakTime(unsigned long, tmElements_t&)+0x106>
        monthLength=29;
    15ea:	cmp	r3, #0
    15ec:	ite	ne
    15ee:	movne	r4, #28
    15f0:	moveq	r4, #29
    15f2:	b.n	1600 <breakTime(unsigned long, tmElements_t&)+0x108>
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    15f4:	ldrb.w	r4, [r2, lr]
    15f8:	b.n	1600 <breakTime(unsigned long, tmElements_t&)+0x108>
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
        monthLength=29;
      } else {
        monthLength=28;
    15fa:	movs	r4, #28
    15fc:	b.n	1600 <breakTime(unsigned long, tmElements_t&)+0x108>
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
        monthLength=29;
    15fe:	movs	r4, #29
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    1600:	cmp	r4, r0
    1602:	bhi.n	1610 <breakTime(unsigned long, tmElements_t&)+0x118>
    1604:	adds	r2, #1
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    1606:	cmp	r2, #12
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
      time -= monthLength;
    1608:	sub.w	r0, r0, r4
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    160c:	bne.n	15e0 <breakTime(unsigned long, tmElements_t&)+0xe8>
    160e:	mov	r5, r2
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    1610:	adds	r5, #1
  tm.Day = time + 1;     // day of month
    1612:	adds	r0, #1
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    1614:	strb	r5, [r1, #5]
  tm.Day = time + 1;     // day of month
    1616:	strb	r0, [r1, #4]
    1618:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    161c:	.word	0x00015180
    1620:	.word	0x00012825

00001624 <makeTime(tmElements_t const&)>:
}

uint32_t makeTime(const tmElements_t &tm){   
    1624:	push	{r4, r5, r6, r7, lr}
  
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
    1626:	ldr	r3, [pc, #176]	; (16d8 <makeTime(tmElements_t const&)+0xb4>)
    1628:	ldrb	r2, [r0, #6]
    162a:	movw	r1, #1970	; 0x7b2
    162e:	muls	r3, r2
  for (i = 0; i < tm.Year; i++) {
    if (LEAP_YEAR(i)) {
    1630:	movs	r5, #100	; 0x64
    1632:	mov.w	r6, #400	; 0x190
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
  for (i = 0; i < tm.Year; i++) {
    1636:	subw	r4, r1, #1970	; 0x7b2
    163a:	cmp	r2, r4
    163c:	ble.n	1662 <makeTime(tmElements_t const&)+0x3e>
    if (LEAP_YEAR(i)) {
    163e:	lsls	r4, r1, #30
    1640:	bne.n	165e <makeTime(tmElements_t const&)+0x3a>
    1642:	sdiv	r4, r1, r5
    1646:	mls	r4, r5, r4, r1
    164a:	cbnz	r4, 1656 <makeTime(tmElements_t const&)+0x32>
    164c:	sdiv	r4, r1, r6
    1650:	mls	r4, r6, r4, r1
    1654:	cbnz	r4, 165e <makeTime(tmElements_t const&)+0x3a>
      seconds += SECS_PER_DAY;   // add extra days for leap years
    1656:	add.w	r3, r3, #86016	; 0x15000
    165a:	add.w	r3, r3, #384	; 0x180
    165e:	adds	r1, #1
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
  for (i = 0; i < tm.Year; i++) {
    1660:	b.n	1636 <makeTime(tmElements_t const&)+0x12>
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    1662:	addw	r2, r2, #1970	; 0x7b2
    1666:	movs	r4, #100	; 0x64
    1668:	mov.w	r5, #400	; 0x190
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    166c:	ldrb	r6, [r0, #5]
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
      seconds += SECS_PER_DAY * 29;
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    166e:	ldr	r7, [pc, #108]	; (16dc <makeTime(tmElements_t const&)+0xb8>)
    1670:	ldr.w	lr, [pc, #108]	; 16e0 <makeTime(tmElements_t const&)+0xbc>
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    1674:	sdiv	r1, r2, r4
    1678:	mls	r4, r4, r1, r2
    167c:	sdiv	r1, r2, r5
    1680:	mls	r5, r5, r1, r2
    1684:	movs	r1, #1
    1686:	and.w	r2, r2, #3
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    168a:	cmp	r6, r1
    168c:	ble.n	16b2 <makeTime(tmElements_t const&)+0x8e>
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    168e:	cmp	r1, #2
    1690:	bne.n	16a2 <makeTime(tmElements_t const&)+0x7e>
    1692:	cbnz	r2, 16a2 <makeTime(tmElements_t const&)+0x7e>
    1694:	cbnz	r4, 1698 <makeTime(tmElements_t const&)+0x74>
    1696:	cbnz	r5, 16a2 <makeTime(tmElements_t const&)+0x7e>
      seconds += SECS_PER_DAY * 29;
    1698:	add.w	r3, r3, #2490368	; 0x260000
    169c:	add.w	r3, r3, #15232	; 0x3b80
    16a0:	b.n	16ae <makeTime(tmElements_t const&)+0x8a>
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    16a2:	add.w	ip, r7, r1
    16a6:	ldrb.w	ip, [ip, #-1]
    16aa:	mla	r3, lr, ip, r3
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    16ae:	adds	r1, #1
    16b0:	b.n	168a <makeTime(tmElements_t const&)+0x66>
  }
  seconds+= (tm.Day-1) * SECS_PER_DAY;
  seconds+= tm.Hour * SECS_PER_HOUR;
  seconds+= tm.Minute * SECS_PER_MIN;
  seconds+= tm.Second;
  return seconds; 
    16b2:	ldrb	r2, [r0, #1]
    16b4:	ldrb	r1, [r0, #2]
    16b6:	rsb	r2, r2, r2, lsl #4
    16ba:	mov.w	r4, #3600	; 0xe10
    16be:	lsls	r2, r2, #2
    16c0:	mla	r2, r4, r1, r2
    16c4:	ldrb	r1, [r0, #0]
    16c6:	add	r2, r1
    16c8:	ldrb	r1, [r0, #4]
    16ca:	ldr	r0, [pc, #20]	; (16e0 <makeTime(tmElements_t const&)+0xbc>)
    16cc:	subs	r1, #1
    16ce:	mla	r0, r0, r1, r2
}
    16d2:	add	r0, r3
    16d4:	pop	{r4, r5, r6, r7, pc}
    16d6:	nop
    16d8:	.word	0x01e13380
    16dc:	.word	0x00012825
    16e0:	.word	0x00015180

000016e4 <setRTCTime(int, int, int, int, int, int)>:

extern "C" void rtc_set(uint32_t tt);

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
    16e4:	push	{r0, r1, r4, lr}
    16e6:	ldr	r4, [sp, #20]
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
    16e8:	strb.w	r0, [sp, #2]
extern "C" void rtc_set(uint32_t tt);

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
 // year can be given as full four digit year or two digts (2010 or 10 for 2010);  
 // it is converted to years since 1970
  if( yr > 99)
    16ec:	cmp	r4, #99	; 0x63
  tm.Year = yr;
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;
    16ee:	add	r0, sp, #8

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
 // year can be given as full four digit year or two digts (2010 or 10 for 2010);  
 // it is converted to years since 1970
  if( yr > 99)
      yr = yr - 1970;
    16f0:	ite	gt
    16f2:	subwgt	r4, r4, #1970	; 0x7b2
  else
      yr += 30;  
    16f6:	addle	r4, #30
  
  tmElements_t tm;
  tm.Year = yr;
    16f8:	strb.w	r4, [sp, #6]
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;
    16fc:	strb.w	r2, [r0, #-8]!
  else
      yr += 30;  
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
    1700:	ldr	r4, [sp, #16]
  tm.Day = dy;
    1702:	strb.w	r3, [sp, #4]
  tm.Hour = hr;
  tm.Minute = min;
    1706:	strb.w	r1, [sp, #1]
  else
      yr += 30;  
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
    170a:	strb.w	r4, [sp, #5]
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;

  uint32_t tt = makeTime(tm);
    170e:	bl	1624 <makeTime(tmElements_t const&)>
  rtc_set(tt); // for RTC
    1712:	bl	9474 <rtc_set>
}
    1716:	add	sp, #8
    1718:	pop	{r4, pc}

0000171a <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)>:
   * \param[out] dst Pointer to the location that will receive the data.
   * \param[in] callback Function to be called with each sector's data
   * \param[in] context Pointer to be passed to the callback function
   * \return true for success or false for failure.
   */
  virtual bool readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
    171a:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    171e:	ldr	r5, [sp, #32]
    1720:	mov	r7, r0
    1722:	mov	r6, r2
    1724:	add.w	r9, r3, r1
    1728:	mov	r4, r1
   void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
    172a:	cmp	r4, r9
    172c:	beq.n	174c <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x32>
       if (!readSector(sector + i, dst)) return false;
    172e:	ldr	r3, [r7, #0]
    1730:	mov	r2, r6
    1732:	ldr	r3, [r3, #12]
    1734:	mov	r1, r4
    1736:	mov	r0, r7
    1738:	blx	r3
    173a:	add.w	r8, r4, #1
    173e:	cbz	r0, 174e <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x34>
       callback(sector + i, dst, context);
    1740:	mov	r0, r4
    1742:	ldr	r2, [sp, #36]	; 0x24
    1744:	mov	r1, r6
    1746:	blx	r5
   * \param[in] context Pointer to be passed to the callback function
   * \return true for success or false for failure.
   */
  virtual bool readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
   void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
    1748:	mov	r4, r8
    174a:	b.n	172a <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x10>
       if (!readSector(sector + i, dst)) return false;
       callback(sector + i, dst, context);
     }
     return true;
    174c:	movs	r0, #1
  }
    174e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00001752 <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)>:
   * \param[in] ns Number of sectors to be written.
   * \param[in] callback Function to be called for each sector's data
   * \param[in] context Context to pass to callback function
   * \return true for success or false for failure.
   */
  virtual bool writeSectorsCallback(uint32_t sector, size_t ns,
    1752:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1756:	mov	r5, r0
    1758:	mov	r7, r3
    175a:	add.w	r8, r2, r1
    175e:	mov	r4, r1
   const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
    1760:	cmp	r4, r8
    1762:	beq.n	1780 <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x2e>
       if (!writeSector(sector + i, callback(sector + i, context))) return false;
    1764:	ldr	r3, [r5, #0]
    1766:	ldr	r1, [sp, #24]
    1768:	ldr	r6, [r3, #32]
    176a:	mov	r0, r4
    176c:	blx	r7
    176e:	mov	r1, r4
    1770:	mov	r2, r0
    1772:	mov	r0, r5
    1774:	blx	r6
    1776:	adds	r4, #1
    1778:	cmp	r0, #0
    177a:	bne.n	1760 <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0xe>
    177c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     }
    return true;
    1780:	movs	r0, #1
  }
    1782:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00001786 <SdCardInterface::status()>:
   * \return The number of 512 byte data sectors in the card
   *         or zero if an error occurs.
   */
  virtual uint32_t sectorCount() = 0;
  /** \return card status. */
  virtual uint32_t status() {return 0XFFFFFFFF;}
    1786:	mov.w	r0, #4294967295
    178a:	bx	lr

0000178c <MySpiClass::activate()>:
    public:
        // Initialize the SPI bus.
        void begin(SdSpiConfig config) {  (void) config; SPI.begin(); }

        // Activate SPI hardware with correct speed and mode.
        void activate() { if(doTransactions) SPI.beginTransaction(m_spiSettings); }
    178c:	ldrb	r3, [r0, #8]
    178e:	push	{r4, r5, lr}
    1790:	cmp	r3, #0
    1792:	beq.n	1808 <MySpiClass::activate()+0x7c>

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    1794:	ldr	r3, [pc, #116]	; (180c <MySpiClass::activate()+0x80>)
    1796:	ldr	r2, [r0, #4]
    1798:	ldrb	r1, [r3, #11]
    179a:	cmp	r1, #0
    179c:	beq.n	17f0 <MySpiClass::activate()+0x64>
			__disable_irq();
    179e:	cpsid	i
			if (interruptMasksUsed & 0x01) {
    17a0:	ldrb	r1, [r3, #11]
    17a2:	lsls	r1, r1, #31
    17a4:	bpl.n	17b2 <MySpiClass::activate()+0x26>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    17a6:	ldr	r0, [pc, #104]	; (1810 <MySpiClass::activate()+0x84>)
    17a8:	ldr	r1, [r3, #12]
    17aa:	ldr	r4, [r0, #0]
    17ac:	ands	r1, r4
    17ae:	str	r1, [r3, #28]
				NVIC_ICER0 = interruptSave[0];
    17b0:	str	r1, [r0, #0]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    17b2:	ldrb	r1, [r3, #11]
    17b4:	ldr	r4, [pc, #84]	; (180c <MySpiClass::activate()+0x80>)
    17b6:	lsls	r5, r1, #30
    17b8:	bpl.n	17c6 <MySpiClass::activate()+0x3a>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    17ba:	ldr	r0, [pc, #88]	; (1814 <MySpiClass::activate()+0x88>)
    17bc:	ldr	r1, [r4, #16]
    17be:	ldr	r5, [r0, #0]
    17c0:	ands	r1, r5
    17c2:	str	r1, [r4, #32]
				NVIC_ICER1 = interruptSave[1];
    17c4:	str	r1, [r0, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    17c6:	ldrb	r1, [r3, #11]
    17c8:	ldr	r4, [pc, #64]	; (180c <MySpiClass::activate()+0x80>)
    17ca:	lsls	r0, r1, #29
    17cc:	bpl.n	17da <MySpiClass::activate()+0x4e>
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    17ce:	ldr	r0, [pc, #72]	; (1818 <MySpiClass::activate()+0x8c>)
    17d0:	ldr	r1, [r4, #20]
    17d2:	ldr	r5, [r0, #0]
    17d4:	ands	r1, r5
    17d6:	str	r1, [r4, #36]	; 0x24
				NVIC_ICER2 = interruptSave[2];
    17d8:	str	r1, [r0, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    17da:	ldrb	r1, [r3, #11]
    17dc:	ldr	r4, [pc, #44]	; (180c <MySpiClass::activate()+0x80>)
    17de:	lsls	r1, r1, #28
    17e0:	bpl.n	17ee <MySpiClass::activate()+0x62>
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
    17e2:	ldr	r0, [pc, #56]	; (181c <MySpiClass::activate()+0x90>)
    17e4:	ldr	r1, [r4, #24]
    17e6:	ldr	r5, [r0, #0]
    17e8:	ands	r1, r5
    17ea:	str	r1, [r4, #40]	; 0x28
				NVIC_ICER3 = interruptSave[3];
    17ec:	str	r1, [r0, #0]
			}
			#endif
			__enable_irq();
    17ee:	cpsie	i
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    17f0:	ldr	r3, [r3, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
    17f2:	ldr	r1, [r3, #12]
    17f4:	cmp	r1, r2
    17f6:	beq.n	1808 <MySpiClass::activate()+0x7c>
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
    17f8:	ldr	r1, [pc, #36]	; (1820 <MySpiClass::activate()+0x94>)
    17fa:	str	r1, [r3, #0]
			port().CTAR0 = settings.ctar;
    17fc:	str	r2, [r3, #12]
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
    17fe:	orr.w	r2, r2, #1073741824	; 0x40000000
    1802:	str	r2, [r3, #16]
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    1804:	ldr	r2, [pc, #28]	; (1824 <MySpiClass::activate()+0x98>)
    1806:	str	r2, [r3, #0]
    1808:	pop	{r4, r5, pc}
    180a:	nop
    180c:	.word	0x1fff12f8
    1810:	.word	0xe000e180
    1814:	.word	0xe000e184
    1818:	.word	0xe000e188
    181c:	.word	0xe000e18c
    1820:	.word	0x003f4001
    1824:	.word	0x803f0000

00001828 <MySpiClass::send(unsigned char)>:

        // Receive a byte.
        uint8_t receive() { return SPI.transfer(0XFF); }

        // Send a byte.
        void send(uint8_t data) { SPI.transfer(data); }
    1828:	ldr	r3, [pc, #20]	; (1840 <MySpiClass::send(unsigned char)+0x18>)
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    182a:	ldr	r3, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    182c:	mov.w	r2, #2147483648	; 0x80000000
    1830:	str	r2, [r3, #44]	; 0x2c
		port().PUSHR = data;
    1832:	str	r1, [r3, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    1834:	ldr	r2, [r3, #44]	; 0x2c
    1836:	cmp	r2, #0
    1838:	bge.n	1834 <MySpiClass::send(unsigned char)+0xc>
		return port().POPR;
    183a:	ldr	r3, [r3, #56]	; 0x38
    183c:	bx	lr
    183e:	nop
    1840:	.word	0x1fff12f8

00001844 <__tcf_0>:
    const char *sd_str[]={"sd1"};
    const int cs[] = {10 };

    const int nsd = sizeof(cs)/sizeof(int);

    SDClass sdx[nsd];
    1844:	bx	lr

00001846 <dateTime(unsigned short*, unsigned short*, unsigned char*)>:
    uint32_t diskSpace[nsd];
    uint32_t clusterSize[nsd];

// Call back for file timestamps.  Only called for file create and sync(). needed by SDFat-beta
void dateTime(uint16_t* date, uint16_t* time, uint8_t* ms10) 
{       
    1846:	push	{r0, r1, r4, r5, r6, lr}
    1848:	mov	r5, r2
    184a:	mov	r4, r1
    184c:	mov	r6, r0
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    184e:	bl	9468 <rtc_get>
    1852:	mov	r1, sp
    1854:	bl	14f8 <breakTime(unsigned long, tmElements_t&)>
 * \param[in] day [1,31]
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
    1858:	ldrb.w	r3, [sp, #6]

    *date = FS_DATE(tmYearToCalendar(tm.Year),tm.Month, tm.Day);
    185c:	ldrb.w	r2, [sp, #5]
    1860:	ldrb.w	r1, [sp, #4]
    1864:	subs	r3, #10
    1866:	uxth	r3, r3
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    1868:	cmp	r3, #127	; 0x7f
    186a:	bhi.n	1880 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3a>
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
    186c:	cmp	r2, #12
    186e:	bhi.n	1880 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3a>
    1870:	cmp	r1, #31
    1872:	bhi.n	1880 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3a>
         year << 9 | month << 5 | day;
    1874:	orr.w	r1, r1, r2, lsl #5
    1878:	orr.w	r3, r1, r3, lsl #9
    187c:	uxth	r3, r3
    187e:	b.n	1882 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3c>
    1880:	movs	r3, #0
    1882:	strh	r3, [r6, #0]
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    1884:	ldrb.w	r3, [sp, #2]
    1888:	ldrb.w	r1, [sp, #1]
    188c:	ldrb.w	r2, [sp]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    1890:	cmp	r3, #23
    1892:	bhi.n	18aa <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
 * \param[in] second [0,59]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
    1894:	cmp	r1, #59	; 0x3b
    1896:	bhi.n	18aa <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
    1898:	cmp	r2, #59	; 0x3b
    189a:	bhi.n	18aa <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
         hour << 11 | minute << 5 | second >> 1;
    189c:	lsls	r1, r1, #5
    189e:	orr.w	r3, r1, r3, lsl #11
    18a2:	orr.w	r3, r3, r2, lsr #1
    18a6:	uxth	r3, r3
    18a8:	b.n	18ac <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x66>
    18aa:	movs	r3, #0
    *ms10 = tm.Second & 1 ? 100 : 0;
    18ac:	ands.w	r2, r2, #1
    18b0:	it	ne
    18b2:	movne	r2, #100	; 0x64
{       
    tmElements_t tm;
    breakTime(rtc_get(), tm);

    *date = FS_DATE(tmYearToCalendar(tm.Year),tm.Month, tm.Day);
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    18b4:	strh	r3, [r4, #0]
    *ms10 = tm.Second & 1 ? 100 : 0;
    18b6:	strb	r2, [r5, #0]
}
    18b8:	add	sp, #8
    18ba:	pop	{r4, r5, r6, pc}

000018bc <MySpiClass::send(unsigned char const*, unsigned int)>:
        { memset(buf, 0XFF, count); SPI.transfer(buf, count); return 0; }

        // Send multiple bytes.
        // Replace this function if your board has multiple byte send.
        void send(const uint8_t* buf, size_t count) 
        {  SPI.transfer((void *)buf, (void *) dummy_buffer, count); }
    18bc:	mov	r3, r2
    18be:	ldr	r0, [pc, #8]	; (18c8 <MySpiClass::send(unsigned char const*, unsigned int)+0xc>)
    18c0:	ldr	r2, [pc, #8]	; (18cc <MySpiClass::send(unsigned char const*, unsigned int)+0x10>)
    18c2:	b.w	2e58 <SPIClass::transfer(void const*, void*, unsigned int)>
    18c6:	nop
    18c8:	.word	0x1fff12f8
    18cc:	.word	0x200181ac

000018d0 <MySpiClass::receive(unsigned char*, unsigned int)>:
        // Send a byte.
        void send(uint8_t data) { SPI.transfer(data); }

        // Receive multiple bytes.  
        // Replace this function if your board has multiple byte receive.
        uint8_t receive(uint8_t* buf, size_t count) 
    18d0:	push	{r3, r4, r5, lr}
    18d2:	mov	r4, r1
    18d4:	mov	r5, r2
        { memset(buf, 0XFF, count); SPI.transfer(buf, count); return 0; }
    18d6:	movs	r1, #255	; 0xff
    18d8:	mov	r0, r4
    18da:	bl	90e4 <memset>
		port().PUSHR = data | SPI_PUSHR_CTAS(1);
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
	}

	void inline transfer(void *buf, size_t count) {transfer(buf, buf, count);}
    18de:	mov	r3, r5
    18e0:	mov	r2, r4
    18e2:	mov	r1, r4
    18e4:	ldr	r0, [pc, #8]	; (18f0 <MySpiClass::receive(unsigned char*, unsigned int)+0x20>)
    18e6:	bl	2e58 <SPIClass::transfer(void const*, void*, unsigned int)>
    18ea:	movs	r0, #0
    18ec:	pop	{r3, r4, r5, pc}
    18ee:	nop
    18f0:	.word	0x1fff12f8

000018f4 <MySpiClass::begin(SdSpiConfig)>:
     * 
     */

    public:
        // Initialize the SPI bus.
        void begin(SdSpiConfig config) {  (void) config; SPI.begin(); }
    18f4:	sub	sp, #16
    18f6:	add	r0, sp, #16
    18f8:	stmdb	r0, {r1, r2, r3}
    18fc:	ldr	r0, [pc, #4]	; (1904 <MySpiClass::begin(SdSpiConfig)+0x10>)
    18fe:	add	sp, #16
    1900:	b.w	2c0c <SPIClass::begin()>
    1904:	.word	0x1fff12f8

00001908 <File::dec_refcount() [clone .isra.23]>:
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	using Print::write;
private:
	void dec_refcount() {
    1908:	push	{r4, lr}
    190a:	mov	r4, r0
		if (--(f->refcount) == 0) {
    190c:	ldr	r0, [r0, #0]
    190e:	ldr	r3, [r0, #4]
    1910:	subs	r3, #1
    1912:	str	r3, [r0, #4]
    1914:	cbnz	r3, 1926 <File::dec_refcount() [clone .isra.23]+0x1e>
			f->close();
    1916:	ldr	r3, [r0, #0]
    1918:	ldr	r3, [r3, #44]	; 0x2c
    191a:	blx	r3
			delete f;
    191c:	ldr	r0, [r4, #0]
    191e:	cbz	r0, 1926 <File::dec_refcount() [clone .isra.23]+0x1e>
    1920:	ldr	r3, [r0, #0]
    1922:	ldr	r3, [r3, #4]
    1924:	blx	r3
		}
		f = nullptr;
    1926:	movs	r3, #0
    1928:	str	r3, [r4, #0]
    192a:	pop	{r4, pc}

0000192c <MySpiClass::deactivate()>:

        // Activate SPI hardware with correct speed and mode.
        void activate() { if(doTransactions) SPI.beginTransaction(m_spiSettings); }
        // Deactivate SPI hardware.
        void deactivate() { if(doTransactions) SPI.endTransaction(); }
    192c:	ldrb	r3, [r0, #8]
    192e:	cbz	r3, 196a <MySpiClass::deactivate()+0x3e>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    1930:	ldr	r3, [pc, #56]	; (196c <MySpiClass::deactivate()+0x40>)
    1932:	ldrb	r2, [r3, #11]
    1934:	cbz	r2, 196a <MySpiClass::deactivate()+0x3e>
			if (interruptMasksUsed & 0x01) {
    1936:	lsls	r0, r2, #31
				NVIC_ISER0 = interruptSave[0];
    1938:	ittt	mi
    193a:	ldrmi	r2, [pc, #52]	; (1970 <MySpiClass::deactivate()+0x44>)
    193c:	ldrmi	r1, [r3, #28]
    193e:	strmi	r1, [r2, #0]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    1940:	ldrb	r2, [r3, #11]
    1942:	lsls	r1, r2, #30
				NVIC_ISER1 = interruptSave[1];
    1944:	itttt	mi
    1946:	ldrmi	r2, [pc, #36]	; (196c <MySpiClass::deactivate()+0x40>)
    1948:	ldrmi	r1, [r2, #32]
    194a:	ldrmi	r2, [pc, #40]	; (1974 <MySpiClass::deactivate()+0x48>)
    194c:	strmi	r1, [r2, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    194e:	ldrb	r2, [r3, #11]
    1950:	lsls	r2, r2, #29
				NVIC_ISER2 = interruptSave[2];
    1952:	itttt	mi
    1954:	ldrmi	r2, [pc, #20]	; (196c <MySpiClass::deactivate()+0x40>)
    1956:	ldrmi	r1, [r2, #36]	; 0x24
    1958:	ldrmi	r2, [pc, #28]	; (1978 <MySpiClass::deactivate()+0x4c>)
    195a:	strmi	r1, [r2, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    195c:	ldrb	r3, [r3, #11]
    195e:	lsls	r3, r3, #28
				NVIC_ISER3 = interruptSave[3];
    1960:	itttt	mi
    1962:	ldrmi	r3, [pc, #8]	; (196c <MySpiClass::deactivate()+0x40>)
    1964:	ldrmi	r2, [r3, #40]	; 0x28
    1966:	ldrmi	r3, [pc, #20]	; (197c <MySpiClass::deactivate()+0x50>)
    1968:	strmi	r2, [r3, #0]
    196a:	bx	lr
    196c:	.word	0x1fff12f8
    1970:	.word	0xe000e100
    1974:	.word	0xe000e104
    1978:	.word	0xe000e108
    197c:	.word	0xe000e10c

00001980 <MySpiClass::receive()>:

        // Receive a byte.
        uint8_t receive() { return SPI.transfer(0XFF); }
    1980:	ldr	r3, [pc, #24]	; (199c <MySpiClass::receive()+0x1c>)
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    1982:	ldr	r3, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    1984:	mov.w	r2, #2147483648	; 0x80000000
    1988:	str	r2, [r3, #44]	; 0x2c
		port().PUSHR = data;
    198a:	movs	r2, #255	; 0xff
    198c:	str	r2, [r3, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    198e:	ldr	r2, [r3, #44]	; 0x2c
    1990:	cmp	r2, #0
    1992:	bge.n	198e <MySpiClass::receive()+0xe>
		return port().POPR;
    1994:	ldr	r0, [r3, #56]	; 0x38
    1996:	uxtb	r0, r0
    1998:	bx	lr
    199a:	nop
    199c:	.word	0x1fff12f8

000019a0 <Print::print(char const*)>:
    19a0:	push	{r3, lr}
    19a2:	bl	764 <Print::write(char const*)>
    19a6:	pop	{r3, pc}

000019a8 <Print::println(unsigned long)>:

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
    19a8:	push	{r3, r4, r5, lr}
    19aa:	mov	r5, r0
    19ac:	bl	780 <Print::print(unsigned long)>
    19b0:	mov	r4, r0
    19b2:	mov	r0, r5
    19b4:	bl	a1e4 <Print::println()>
    19b8:	add	r0, r4
    19ba:	pop	{r3, r4, r5, pc}

000019bc <FsVolume::bytesPerCluster() const>:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  uint32_t __attribute__((error("use sectorsPerCluster()"))) blocksPerCluster();
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
    19bc:	ldr.w	r3, [r0, #1152]	; 0x480
           m_xVol ? m_xVol->bytesPerCluster() : 0;
    19c0:	cbz	r3, 19d0 <FsVolume::bytesPerCluster() const+0x14>
    19c2:	ldrb	r0, [r3, #6]
    19c4:	mov.w	r3, #512	; 0x200
    19c8:	lsl.w	r0, r3, r0
    19cc:	uxth	r0, r0
    19ce:	bx	lr
    19d0:	ldr.w	r0, [r0, #1156]	; 0x484
    19d4:	cbz	r0, 19da <FsVolume::bytesPerCluster() const+0x1e>
    19d6:	ldr.w	r0, [r0, #1084]	; 0x43c
  }
    19da:	bx	lr

000019dc <FsVolume::clusterCount() const>:
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    19dc:	ldr.w	r3, [r0, #1152]	; 0x480
           m_xVol ? m_xVol->clusterCount() : 0;
    19e0:	cbz	r3, 19e8 <FsVolume::clusterCount() const+0xc>
  uint8_t* cacheClear() {
    return m_cache.clear();
  }
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_lastCluster - 1;
    19e2:	ldr	r0, [r3, #28]
    19e4:	subs	r0, #1
    19e6:	bx	lr
    19e8:	ldr.w	r0, [r0, #1156]	; 0x484
    19ec:	cbz	r0, 19f2 <FsVolume::clusterCount() const+0x16>
    19ee:	ldr.w	r0, [r0, #1072]	; 0x430
  }
    19f2:	bx	lr

000019f4 <FsVolume::freeClusterCount() const>:
  uint8_t fatType() const {
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    19f4:	mov	r3, r0
    return m_fVol ? m_fVol->freeClusterCount() :
    19f6:	ldr.w	r0, [r0, #1152]	; 0x480
           m_xVol ? m_xVol->freeClusterCount() : 0;
    19fa:	cbz	r0, 1a00 <FsVolume::freeClusterCount() const+0xc>
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
    19fc:	b.w	6c2c <FatPartition::freeClusterCount()>
           m_xVol ? m_xVol->freeClusterCount() : 0;
    1a00:	ldr.w	r0, [r3, #1156]	; 0x484
    1a04:	cbz	r0, 1a0a <FsVolume::freeClusterCount() const+0x16>
    1a06:	b.w	4b50 <ExFatPartition::freeClusterCount()>
  }
    1a0a:	bx	lr

00001a0c <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)>:
	}
	SPISettings() {
		init_AlwaysInline(4000000, MSBFIRST, SPI_MODE0);
	}
private:
	void init_MightInline(uint32_t clock, uint8_t bitOrder, uint8_t dataMode) {
    1a0c:	push	{r4, r5, r6, r7, lr}
		init_AlwaysInline(clock, bitOrder, dataMode);
	}
	void init_AlwaysInline(uint32_t clock, uint8_t bitOrder, uint8_t dataMode)
	  __attribute__((__always_inline__)) {
		uint32_t t, c = SPI_CTAR_FMSZ(7);
		if (bitOrder == LSBFIRST) c |= SPI_CTAR_LSBFE;
    1a0e:	cmp	r2, #0
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    1a10:	ldr	r6, [pc, #76]	; (1a60 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x54>)
    1a12:	ldr	r7, [pc, #80]	; (1a64 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x58>)
		init_AlwaysInline(clock, bitOrder, dataMode);
	}
	void init_AlwaysInline(uint32_t clock, uint8_t bitOrder, uint8_t dataMode)
	  __attribute__((__always_inline__)) {
		uint32_t t, c = SPI_CTAR_FMSZ(7);
		if (bitOrder == LSBFIRST) c |= SPI_CTAR_LSBFE;
    1a14:	ite	ne
    1a16:	movne.w	r4, #939524096	; 0x38000000
    1a1a:	moveq.w	r4, #956301312	; 0x39000000
				t = SPI_CTAR_PBR(2) | SPI_CTAR_BR(7) | SPI_CTAR_CSSCK(6);
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
    1a1e:	movs	r2, #0
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    1a20:	ldrh.w	r5, [r6, r2, lsl #1]
    1a24:	sdiv	r5, r7, r5
    1a28:	cmp	r1, r5
    1a2a:	bcc.n	1a36 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x2a>
			}
		}
		if (dataMode & 0x08) {
    1a2c:	lsls	r1, r3, #28
    1a2e:	bpl.n	1a40 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x34>
			c |= SPI_CTAR_CPOL;
    1a30:	orr.w	r4, r4, #67108864	; 0x4000000
    1a34:	b.n	1a40 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x34>
				t = SPI_CTAR_PBR(2) | SPI_CTAR_BR(7) | SPI_CTAR_CSSCK(6);
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
    1a36:	adds	r5, r2, #1
    1a38:	cmp	r5, #23
    1a3a:	beq.n	1a2c <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x20>
    1a3c:	mov	r2, r5
    1a3e:	b.n	1a20 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x14>
				t = ctar_clock_table[i];
    1a40:	ldr	r1, [pc, #36]	; (1a68 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x5c>)
			}
		}
		if (dataMode & 0x08) {
			c |= SPI_CTAR_CPOL;
		}
		if (dataMode & 0x04) {
    1a42:	lsls	r3, r3, #29
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
				t = ctar_clock_table[i];
    1a44:	ldr.w	r2, [r1, r2, lsl #2]
			}
		}
		if (dataMode & 0x08) {
			c |= SPI_CTAR_CPOL;
		}
		if (dataMode & 0x04) {
    1a48:	bpl.n	1a5a <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x4e>
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
    1a4a:	bic.w	r3, r2, #61440	; 0xf000
    1a4e:	lsrs	r2, r2, #4
    1a50:	and.w	r2, r2, #3840	; 0xf00
		}
		if (dataMode & 0x08) {
			c |= SPI_CTAR_CPOL;
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
    1a54:	orr.w	r4, r4, #33554432	; 0x2000000
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
    1a58:	orrs	r2, r3
		}
		ctar = c | t;
    1a5a:	orrs	r2, r4
    1a5c:	str	r2, [r0, #0]
    1a5e:	pop	{r4, r5, r6, r7, pc}
    1a60:	.word	0x000129a8
    1a64:	.word	0x02dc6c00
    1a68:	.word	0x00012a6c

00001a6c <SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)>:
#define SPI_HAS_NOTUSINGINTERRUPT 1
#define SPI_ATOMIC_VERSION 1

class SPISettings {
public:
	SPISettings(uint32_t clock, uint8_t bitOrder, uint8_t dataMode) {
    1a6c:	push	{r4, lr}
    1a6e:	mov	r4, r0
		if (__builtin_constant_p(clock)) {
			init_AlwaysInline(clock, bitOrder, dataMode);
		} else {
			init_MightInline(clock, bitOrder, dataMode);
    1a70:	bl	1a0c <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)>
		}
	}
    1a74:	mov	r0, r4
    1a76:	pop	{r4, pc}

00001a78 <MySpiClass::setSckSpeed(unsigned long)>:
        // Replace this function if your board has multiple byte send.
        void send(const uint8_t* buf, size_t count) 
        {  SPI.transfer((void *)buf, (void *) dummy_buffer, count); }

        // Save SPISettings for new max SCK frequency
        void setSckSpeed(uint32_t maxSck) {  m_spiSettings = SPISettings(maxSck, MSBFIRST, SPI_MODE0); }
    1a78:	push	{r0, r1, r4, lr}
    1a7a:	movs	r3, #0
    1a7c:	mov	r4, r0
    1a7e:	movs	r2, #1
    1a80:	add	r0, sp, #4
    1a82:	bl	1a6c <SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)>
    1a86:	ldr	r3, [sp, #4]
    1a88:	str	r3, [r4, #4]
    1a8a:	add	sp, #8
    1a8c:	pop	{r4, pc}
    1a8e:	Address 0x00001a8e is out of bounds.


00001a90 <getCount()>:

    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    1a90:	ldr	r2, [pc, #16]	; (1aa4 <getCount()+0x14>)
    1a92:	ldrh	r3, [r2, #0]
    1a94:	ldrh	r0, [r2, #2]
            {  
                /**
                 * @brief get number of data blocks in storage
                 * 
                 */
                if(front_ >= rear_) return front_ - rear_; return front_+ MAXBUF -rear_; 
    1a96:	cmp	r3, r0
    1a98:	it	cc
    1a9a:	addcc	r3, #150	; 0x96
    1a9c:	subs	r0, r3, r0
    1a9e:	uxth	r0, r0

    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    1aa0:	bx	lr
    1aa2:	nop
    1aa4:	.word	0x20018150

00001aa8 <pushData(unsigned long*)>:
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    1aa8:	push	{r3, r4, r5, lr}
            { 
                /** 
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
    1aaa:	ldr	r5, [pc, #44]	; (1ad8 <pushData(unsigned long*)+0x30>)
    1aac:	ldrh	r4, [r5, #0]
                if(f >= MAXBUF) f=0;
                if(f == rear_) return 0;
    1aae:	ldrh	r3, [r5, #2]
            { 
                /** 
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
    1ab0:	adds	r4, #1
    1ab2:	uxth	r4, r4
                if(f >= MAXBUF) f=0;
    1ab4:	cmp	r4, #150	; 0x96
    1ab6:	it	cs
    1ab8:	movcs	r4, #0
                if(f == rear_) return 0;
    1aba:	cmp	r3, r4
    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    1abc:	mov	r1, r0
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
                if(f >= MAXBUF) f=0;
                if(f == rear_) return 0;
    1abe:	beq.n	1ad4 <pushData(unsigned long*)+0x2c>

                uint32_t *ptr= data_buffer+f*NBUF_ACQ;
                memcpy(ptr,src,NBUF_ACQ*4);
    1ac0:	ldr	r0, [r5, #4]
    1ac2:	mov.w	r2, #1024	; 0x400
    1ac6:	add.w	r0, r0, r4, lsl #10
    1aca:	bl	8f3c <memcpy>
                front_ = f;
    1ace:	strh	r4, [r5, #0]
                return 1;
    1ad0:	movs	r0, #1
    1ad2:	pop	{r3, r4, r5, pc}
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
                if(f >= MAXBUF) f=0;
                if(f == rear_) return 0;
    1ad4:	movs	r0, #0
    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    1ad6:	pop	{r3, r4, r5, pc}
    1ad8:	.word	0x20018150

00001adc <pullData(unsigned long*, unsigned long)>:
    uint16_t pullData(uint32_t * dst, uint32_t ndbl) {return rawData.pull(dst,ndbl);}
    1adc:	push	{r4, r5, r6, lr}
                /** 
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
    1ade:	ldr	r6, [pc, #60]	; (1b1c <pullData(unsigned long*, unsigned long)+0x40>)
    1ae0:	ldrh	r4, [r6, #2]
                if(r == (front_/ndbl)) return 0;
    1ae2:	ldrh	r3, [r6, #0]
                /** 
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
    1ae4:	udiv	r4, r4, r1
                if(r == (front_/ndbl)) return 0;
    1ae8:	udiv	r3, r3, r1
    1aec:	cmp	r4, r3

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    uint16_t pullData(uint32_t * dst, uint32_t ndbl) {return rawData.pull(dst,ndbl);}
    1aee:	mov	r5, r1
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
                if(r == (front_/ndbl)) return 0;
    1af0:	beq.n	1b18 <pullData(unsigned long*, unsigned long)+0x3c>
    1af2:	lsls	r2, r1, #10

                uint32_t *ptr= data_buffer + r*ndbl*NBUF_ACQ;
                memcpy(dst,ptr,ndbl*NBUF_ACQ*4);
    1af4:	ldr	r1, [r6, #4]
    1af6:	mla	r1, r2, r4, r1
    1afa:	bl	8f3c <memcpy>
                if(++r >= (MAXBUF/ndbl)) r=0;
    1afe:	adds	r1, r4, #1
    1b00:	uxth	r1, r1
    1b02:	movs	r3, #150	; 0x96
    1b04:	udiv	r3, r3, r5
    1b08:	cmp	r1, r3
    1b0a:	it	cs
    1b0c:	movcs	r1, #0
                rear_ = r*ndbl;
    1b0e:	smulbb	r1, r5, r1
    1b12:	strh	r1, [r6, #2]
                return 1;
    1b14:	movs	r0, #1
    1b16:	pop	{r4, r5, r6, pc}
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
                if(r == (front_/ndbl)) return 0;
    1b18:	movs	r0, #0

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    uint16_t pullData(uint32_t * dst, uint32_t ndbl) {return rawData.pull(dst,ndbl);}
    1b1a:	pop	{r4, r5, r6, pc}
    1b1c:	.word	0x20018150

00001b20 <sdCsInit(unsigned char)>:
};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}

void sdCsInit(SdCsPin_t pin) { pinMode(pin, OUTPUT); digitalWriteFast(pin, HIGH);}
    1b20:	push	{r4, lr}
    1b22:	movs	r1, #1
    1b24:	mov	r4, r0
    1b26:	bl	94d8 <pinMode>
			}
			#endif
		}
	} else {
		if (val) {
			*portSetRegister(pin) = digitalPinToBitMask(pin);
    1b2a:	ldr	r3, [pc, #12]	; (1b38 <sdCsInit(unsigned char)+0x18>)
    1b2c:	ldr.w	r3, [r3, r4, lsl #3]
    1b30:	movs	r2, #1
    1b32:	strb.w	r2, [r3, #128]	; 0x80
    1b36:	pop	{r4, pc}
    1b38:	.word	0x00012e88

00001b3c <sdCsWrite(unsigned char, bool)>:
void sdCsWrite(SdCsPin_t pin, bool level) { digitalWriteFast(pin, level); }
    1b3c:	ldr	r2, [pc, #20]	; (1b54 <sdCsWrite(unsigned char, bool)+0x18>)
    1b3e:	movs	r3, #1
    1b40:	ldr.w	r2, [r2, r0, lsl #3]
				CORE_PIN63_PORTCLEAR = CORE_PIN63_BITMASK;
			}
			#endif
		}
	} else {
		if (val) {
    1b44:	cbz	r1, 1b4c <sdCsWrite(unsigned char, bool)+0x10>
			*portSetRegister(pin) = digitalPinToBitMask(pin);
    1b46:	strb.w	r3, [r2, #128]	; 0x80
    1b4a:	bx	lr
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
    1b4c:	strb.w	r3, [r2, #256]	; 0x100
    1b50:	bx	lr
    1b52:	nop
    1b54:	.word	0x00012e88

00001b58 <storage_configure()>:
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    *ms10 = tm.Second & 1 ? 100 : 0;
}

void storage_configure()
{
    1b58:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    #if defined SD_SCK
      SPI.setMOSI(SD_MOSI);
    1b5c:	movs	r1, #7
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    *ms10 = tm.Second & 1 ? 100 : 0;
}

void storage_configure()
{
    1b5e:	sub	sp, #56	; 0x38
    #if defined SD_SCK
      SPI.setMOSI(SD_MOSI);
    1b60:	ldr	r0, [pc, #452]	; (1d28 <storage_configure()+0x1d0>)
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    1b62:	ldr	r5, [pc, #456]	; (1d2c <storage_configure()+0x1d4>)
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    1b64:	ldr.w	r8, [pc, #508]	; 1d64 <storage_configure()+0x20c>
    1b68:	bl	2c84 <SPIClass::setMOSI(unsigned char)>
      SPI.setMISO(SD_MISO);
    1b6c:	movs	r1, #12
    1b6e:	ldr	r0, [pc, #440]	; (1d28 <storage_configure()+0x1d0>)
    1b70:	bl	2d20 <SPIClass::setMISO(unsigned char)>
      SPI.setSCK(SD_SCK);
    1b74:	movs	r1, #14
    1b76:	ldr	r0, [pc, #432]	; (1d28 <storage_configure()+0x1d0>)
    1b78:	bl	2db4 <SPIClass::setSCK(unsigned char)>
    #endif

    // Set Time callback
    FsDateTime::callback = dateTime;
    1b7c:	ldr	r3, [pc, #432]	; (1d30 <storage_configure()+0x1d8>)
    1b7e:	ldr	r2, [pc, #436]	; (1d34 <storage_configure()+0x1dc>)
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    1b80:	ldr	r0, [pc, #436]	; (1d38 <storage_configure()+0x1e0>)
    1b82:	str	r2, [r3, #0]
    1b84:	movs	r1, #0
    1b86:	bl	a294 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    1b8a:	ldr	r0, [pc, #428]	; (1d38 <storage_configure()+0x1e0>)
    1b8c:	bl	a1e4 <Print::println()>
                Serial.println("No sdio storage"); 
            }
      }
      else if(cs[ii]<BUILTIN_SDCARD)
      { 
            sdCsInit(cs[ii]);
    1b90:	movs	r0, #10
    1b92:	bl	1b20 <sdCsInit(unsigned char)>
            delay(100);
    1b96:	movs	r0, #100	; 0x64
    1b98:	bl	9578 <delay>
    1b9c:	movs	r6, #0
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    1b9e:	mov.w	ip, #10
    spiConfigBackupOptions = spiConfig.options;
    1ba2:	mov.w	lr, #0
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    1ba6:	ldr	r3, [pc, #404]	; (1d3c <storage_configure()+0x1e4>)
    1ba8:	str	r3, [sp, #28]
    1baa:	strb.w	ip, [sp, #20]
    1bae:	strb.w	lr, [sp, #21]
    1bb2:	str.w	r8, [sp, #24]
    1bb6:	add	r2, sp, #20
    1bb8:	ldmia	r2, {r0, r1, r2}
    1bba:	add	r4, sp, #32
    1bbc:	stmia.w	r4, {r0, r1, r2}
    1bc0:	str	r3, [sp, #40]	; 0x28
    1bc2:	strb.w	ip, [sp, #32]
    1bc6:	strb.w	lr, [sp, #33]	; 0x21
    1bca:	str.w	r8, [sp, #36]	; 0x24
    1bce:	ldmia.w	r4, {r0, r1, r2}
    1bd2:	str.w	r3, [r5, #1212]	; 0x4bc
    1bd6:	add	r3, sp, #44	; 0x2c
    1bd8:	stmia.w	r3, {r0, r1, r2}
   *
   * \param[in] config SPI configuration.
   * \return generic card pointer.
   */
  SdCard* newCard(SdSpiConfig config) {
    m_spiCard.begin(config);
    1bdc:	ldr	r4, [pc, #352]	; (1d40 <storage_configure()+0x1e8>)
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    1bde:	strb.w	ip, [r5, #1204]	; 0x4b4
    spiConfigBackupOptions = spiConfig.options;
    1be2:	strb.w	lr, [r5, #1205]	; 0x4b5
    spiConfigBackupClock = spiConfig.maxSck;
    1be6:	str.w	r8, [r5, #1208]	; 0x4b8
    1bea:	ldmia	r3, {r1, r2, r3}
    1bec:	mov	r0, r4
    1bee:	bl	7a54 <SdSpiCard::begin(SdSpiConfig)>
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    m_card = m_cardFactory.newCard(spiConfig);
    return m_card && !m_card->errorCode();
    1bf2:	ldrb.w	r9, [r5, #1199]	; 0x4af
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    m_card = m_cardFactory.newCard(spiConfig);
    1bf6:	str.w	r4, [r5, #1168]	; 0x490
    1bfa:	uxth	r7, r6
    return m_card && !m_card->errorCode();
    1bfc:	cmp.w	r9, #0
    1c00:	beq.n	1c0c <storage_configure()+0xb4>
            uint16_t tries=0;
            while(!sdx[ii].sdfs.begin(SdSpiConfig(cs[ii], SHARED_SPI, SPI_SPEED, &mySpi)) && tries<10)
    1c02:	cmp	r7, #9
    1c04:	ite	hi
    1c06:	movhi	r4, #0
    1c08:	movls	r4, #1
    1c0a:	b.n	1c1c <storage_configure()+0xc4>
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    1c0c:	mov	r1, r4
    1c0e:	subw	r0, r4, #1180	; 0x49c
    1c12:	bl	7620 <FsVolume::begin(BlockDeviceInterface*)>
    1c16:	cmp	r0, #0
    1c18:	beq.n	1c02 <storage_configure()+0xaa>
    1c1a:	mov	r4, r9
    1c1c:	adds	r6, #1
    1c1e:	cbz	r4, 1c3a <storage_configure()+0xe2>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    1c20:	mov	r1, r7
    1c22:	ldr	r0, [pc, #276]	; (1d38 <storage_configure()+0x1e0>)
    1c24:	bl	a294 <Print::print(long)>
            { Serial.print(tries); Serial.print(" "); tries++; delay(1000); } 
    1c28:	ldr	r1, [pc, #280]	; (1d44 <storage_configure()+0x1ec>)
    1c2a:	ldr	r0, [pc, #268]	; (1d38 <storage_configure()+0x1e0>)
    1c2c:	bl	19a0 <Print::print(char const*)>
    1c30:	mov.w	r0, #1000	; 0x3e8
    1c34:	bl	9578 <delay>
      else if(cs[ii]<BUILTIN_SDCARD)
      { 
            sdCsInit(cs[ii]);
            delay(100);
            uint16_t tries=0;
            while(!sdx[ii].sdfs.begin(SdSpiConfig(cs[ii], SHARED_SPI, SPI_SPEED, &mySpi)) && tries<10)
    1c38:	b.n	1b9e <storage_configure()+0x46>
            { Serial.print(tries); Serial.print(" "); tries++; delay(1000); } 

            if(tries<10) 
    1c3a:	cmp	r7, #9
    1c3c:	ldr	r6, [pc, #264]	; (1d48 <storage_configure()+0x1f0>)
    1c3e:	ldr	r5, [pc, #268]	; (1d4c <storage_configure()+0x1f4>)
    1c40:	ldr	r7, [pc, #268]	; (1d50 <storage_configure()+0x1f8>)
    1c42:	bls.n	1c56 <storage_configure()+0xfe>
            {
                status=1;
            }
            else
            {
                Serial.println("No spi storage");
    1c44:	ldr	r1, [pc, #268]	; (1d54 <storage_configure()+0x1fc>)
    1c46:	ldr	r0, [pc, #240]	; (1d38 <storage_configure()+0x1e0>)
    1c48:	bl	788 <Print::println(char const*)>
      }
      else
      {
            diskSize[ii]=0;
            diskSpace[ii]=0;
            clusterSize[ii]=1;
    1c4c:	movs	r3, #1
            diskSpace[ii]=diskSize[ii]=sdx[ii].sdfs.freeClusterCount();
            Serial.println(diskSize[ii]) ;Serial.print(" ");
      }
      else
      {
            diskSize[ii]=0;
    1c4e:	str	r4, [r6, #0]
            diskSpace[ii]=0;
    1c50:	str	r4, [r5, #0]
            clusterSize[ii]=1;
    1c52:	str	r3, [r7, #0]
      }
    }
}
    1c54:	b.n	1d22 <storage_configure()+0x1ca>
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
		  * (uint64_t)sdfs.bytesPerCluster();
	}
	uint64_t totalSize() {
		return (uint64_t)sdfs.clusterCount() * (uint64_t)sdfs.bytesPerCluster();
    1c56:	ldr	r0, [pc, #256]	; (1d58 <storage_configure()+0x200>)
    1c58:	bl	19dc <FsVolume::clusterCount() const>
    1c5c:	mov	sl, r0
    1c5e:	ldr	r0, [pc, #248]	; (1d58 <storage_configure()+0x200>)
    1c60:	bl	19bc <FsVolume::bytesPerCluster() const>
    1c64:	umull	r8, r9, sl, r0
	}
	bool rmdir(const char *filepath) {
		return sdfs.rmdir(filepath);
	}
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
    1c68:	ldr	r0, [pc, #236]	; (1d58 <storage_configure()+0x200>)
    1c6a:	bl	19f4 <FsVolume::freeClusterCount() const>
    1c6e:	rsb	sl, r0, sl
		  * (uint64_t)sdfs.bytesPerCluster();
    1c72:	ldr	r0, [pc, #228]	; (1d58 <storage_configure()+0x200>)
    1c74:	bl	19bc <FsVolume::bytesPerCluster() const>
    1c78:	umull	r2, r3, sl, r0
    1c7c:	strd	r2, r3, [sp, #8]
      if (status)
      {
            uint64_t totalSize = sdx[ii].totalSize();
            uint64_t usedSize  = sdx[ii].usedSize();

            Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]); 
    1c80:	ldr	r3, [pc, #216]	; (1d5c <storage_configure()+0x204>)
    1c82:	ldr	r1, [pc, #220]	; (1d60 <storage_configure()+0x208>)
    1c84:	ldr	r3, [r3, #0]
    1c86:	str	r3, [sp, #0]
    1c88:	mov	r2, r4
    1c8a:	movs	r3, #10
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
	size_t print(int64_t n);
	size_t print(uint64_t n)			{ return printNumber64(n, 10, 0); }
    1c8c:	mov.w	sl, #10
    1c90:	ldr	r0, [pc, #164]	; (1d38 <storage_configure()+0x1e0>)
    1c92:	bl	a204 <Print::printf(char const*, ...)>
    1c96:	mov	r2, r8
    1c98:	mov	r3, r9
    1c9a:	str	r4, [sp, #4]
    1c9c:	str.w	sl, [sp]
    1ca0:	ldr	r0, [pc, #148]	; (1d38 <storage_configure()+0x1e0>)
    1ca2:	bl	a2a4 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
            Serial.print(totalSize); Serial.print(" "); Serial.println(usedSize);
    1ca6:	ldr	r1, [pc, #156]	; (1d44 <storage_configure()+0x1ec>)
    1ca8:	ldr	r0, [pc, #140]	; (1d38 <storage_configure()+0x1e0>)
    1caa:	bl	19a0 <Print::print(char const*)>
    1cae:	ldrd	r2, r3, [sp, #8]
    1cb2:	str	r4, [sp, #4]
    1cb4:	str.w	sl, [sp]
    1cb8:	ldr	r0, [pc, #124]	; (1d38 <storage_configure()+0x1e0>)
    1cba:	bl	a2a4 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
	size_t println(int64_t n)			{ return print(n) + println(); }
	size_t println(uint64_t n)			{ return print(n) + println(); }
    1cbe:	ldr	r0, [pc, #120]	; (1d38 <storage_configure()+0x1e0>)
    1cc0:	bl	a1e4 <Print::println()>

            Serial.print(sdx[ii].sdfs.clusterCount()); Serial.print(" "); 
    1cc4:	ldr	r0, [pc, #144]	; (1d58 <storage_configure()+0x200>)
    1cc6:	bl	19dc <FsVolume::clusterCount() const>
    1cca:	mov	r1, r0
    1ccc:	ldr	r0, [pc, #104]	; (1d38 <storage_configure()+0x1e0>)
    1cce:	bl	780 <Print::print(unsigned long)>
    1cd2:	ldr	r1, [pc, #112]	; (1d44 <storage_configure()+0x1ec>)
    1cd4:	ldr	r0, [pc, #96]	; (1d38 <storage_configure()+0x1e0>)
    1cd6:	bl	19a0 <Print::print(char const*)>
            Serial.print(sdx[ii].sdfs.freeClusterCount()); Serial.print(" ");
    1cda:	ldr	r0, [pc, #124]	; (1d58 <storage_configure()+0x200>)
    1cdc:	bl	19f4 <FsVolume::freeClusterCount() const>
    1ce0:	mov	r1, r0
    1ce2:	ldr	r0, [pc, #84]	; (1d38 <storage_configure()+0x1e0>)
    1ce4:	bl	780 <Print::print(unsigned long)>
    1ce8:	ldr	r1, [pc, #88]	; (1d44 <storage_configure()+0x1ec>)
    1cea:	ldr	r0, [pc, #76]	; (1d38 <storage_configure()+0x1e0>)
    1cec:	bl	19a0 <Print::print(char const*)>

            clusterSize[ii] = sdx[ii].sdfs.bytesPerCluster()/512; // count sectors
    1cf0:	ldr	r0, [pc, #100]	; (1d58 <storage_configure()+0x200>)
    1cf2:	bl	19bc <FsVolume::bytesPerCluster() const>
    1cf6:	lsrs	r1, r0, #9
            Serial.println(clusterSize[ii]) ;Serial.print(" ");
    1cf8:	ldr	r0, [pc, #60]	; (1d38 <storage_configure()+0x1e0>)
            Serial.print(totalSize); Serial.print(" "); Serial.println(usedSize);

            Serial.print(sdx[ii].sdfs.clusterCount()); Serial.print(" "); 
            Serial.print(sdx[ii].sdfs.freeClusterCount()); Serial.print(" ");

            clusterSize[ii] = sdx[ii].sdfs.bytesPerCluster()/512; // count sectors
    1cfa:	str	r1, [r7, #0]
            Serial.println(clusterSize[ii]) ;Serial.print(" ");
    1cfc:	bl	19a8 <Print::println(unsigned long)>
    1d00:	ldr	r1, [pc, #64]	; (1d44 <storage_configure()+0x1ec>)
    1d02:	ldr	r0, [pc, #52]	; (1d38 <storage_configure()+0x1e0>)
    1d04:	bl	19a0 <Print::print(char const*)>

            diskSpace[ii]=diskSize[ii]=sdx[ii].sdfs.freeClusterCount();
    1d08:	ldr	r0, [pc, #76]	; (1d58 <storage_configure()+0x200>)
    1d0a:	bl	19f4 <FsVolume::freeClusterCount() const>
    1d0e:	mov	r1, r0
    1d10:	str	r0, [r6, #0]
    1d12:	str	r0, [r5, #0]
            Serial.println(diskSize[ii]) ;Serial.print(" ");
    1d14:	ldr	r0, [pc, #32]	; (1d38 <storage_configure()+0x1e0>)
    1d16:	bl	19a8 <Print::println(unsigned long)>
    1d1a:	ldr	r1, [pc, #40]	; (1d44 <storage_configure()+0x1ec>)
    1d1c:	ldr	r0, [pc, #24]	; (1d38 <storage_configure()+0x1e0>)
    1d1e:	bl	19a0 <Print::print(char const*)>
            diskSize[ii]=0;
            diskSpace[ii]=0;
            clusterSize[ii]=1;
      }
    }
}
    1d22:	add	sp, #56	; 0x38
    1d24:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1d28:	.word	0x1fff12f8
    1d2c:	.word	0x20017c34
    1d30:	.word	0x2001a690
    1d34:	.word	0x00001847
    1d38:	.word	0x1fff1348
    1d3c:	.word	0x200191ac
    1d40:	.word	0x200180d4
    1d44:	.word	0x00012501
    1d48:	.word	0x1fff222c
    1d4c:	.word	0x1fff2224
    1d50:	.word	0x20018158
    1d54:	.word	0x0001285c
    1d58:	.word	0x20017c38
    1d5c:	.word	0x1fff0f3c
    1d60:	.word	0x0001286b
    1d64:	.word	0x01f78a40

00001d68 <listDisks()>:

void listDisks(void)
{
    1d68:	push	{r0, r1, r2, r4, r5, lr}
    for(int ii=0;ii<nsd;ii++)
    {
        Serial.print("\n"); 
    1d6a:	ldr	r4, [pc, #60]	; (1da8 <listDisks()+0x40>)
    1d6c:	ldr	r5, [pc, #60]	; (1dac <listDisks()+0x44>)
    1d6e:	mov	r0, r4
    1d70:	mov	r1, r5
    1d72:	bl	19a0 <Print::print(char const*)>
        Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]);
    1d76:	ldr	r3, [pc, #56]	; (1db0 <listDisks()+0x48>)
    1d78:	ldr	r1, [pc, #56]	; (1db4 <listDisks()+0x4c>)
    1d7a:	ldr	r3, [r3, #0]
    1d7c:	str	r3, [sp, #0]
    1d7e:	movs	r2, #0
    1d80:	movs	r3, #10
    1d82:	mov	r0, r4
    1d84:	bl	a204 <Print::printf(char const*, ...)>
        Serial.printf("%d %d",sdx[ii].sdfs.freeClusterCount(),diskSize[ii]);
    1d88:	ldr	r0, [pc, #44]	; (1db8 <listDisks()+0x50>)
    1d8a:	bl	19f4 <FsVolume::freeClusterCount() const>
    1d8e:	ldr	r3, [pc, #44]	; (1dbc <listDisks()+0x54>)
    1d90:	ldr	r1, [pc, #44]	; (1dc0 <listDisks()+0x58>)
    1d92:	ldr	r3, [r3, #0]
    1d94:	mov	r2, r0
    1d96:	mov	r0, r4
    1d98:	bl	a204 <Print::printf(char const*, ...)>
    }
    Serial.print("\n"); 
    1d9c:	mov	r1, r5
    1d9e:	mov	r0, r4
    1da0:	bl	19a0 <Print::print(char const*)>
}
    1da4:	add	sp, #12
    1da6:	pop	{r4, r5, pc}
    1da8:	.word	0x1fff1348
    1dac:	.word	0x00012da8
    1db0:	.word	0x1fff0f3c
    1db4:	.word	0x0001286b
    1db8:	.word	0x20017c38
    1dbc:	.word	0x1fff222c
    1dc0:	.word	0x0001287d

00001dc4 <checkReboot()>:
{
    int ii=0;
    while((ii<nsd) && (diskSpace[ii]<MIN_SPACE)) ii++;
    if(ii<nsd) CPU_RESTART;
    return -1;
}
    1dc4:	mov.w	r0, #4294967295
    1dc8:	bx	lr
    1dca:	Address 0x00001dca is out of bounds.


00001dcc <saveData(short)>:
    return 1;
}

/* main data filing routine */
int16_t saveData(int16_t status)
{   static char dirName[80];
    1dcc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    static char fileName[80];
    static char header[512];
    static int dirFlag=0;

    if(status<CLOSED) return status; // we are stopped: don't do anything
    1dd0:	subs	r4, r0, #0
    return 1;
}

/* main data filing routine */
int16_t saveData(int16_t status)
{   static char dirName[80];
    1dd2:	sub	sp, #84	; 0x54
    static char fileName[80];
    static char header[512];
    static int dirFlag=0;

    if(status<CLOSED) return status; // we are stopped: don't do anything
    1dd4:	blt.w	1f92 <saveData(short)+0x1c6>

    //fetch data from circular buffer
    if(pullData(diskBuffer,NDBL))
    1dd8:	movs	r1, #4
    1dda:	ldr	r0, [pc, #672]	; (207c <saveData(short)+0x2b0>)
    1ddc:	bl	1adc <pullData(unsigned long*, unsigned long)>
    1de0:	cmp	r0, #0
    1de2:	beq.n	1edc <saveData(short)+0x110>
    {   disk_count++;
    1de4:	ldr	r2, [pc, #664]	; (2080 <saveData(short)+0x2b4>)
    1de6:	ldr	r3, [r2, #0]
    1de8:	adds	r3, #1
    1dea:	str	r3, [r2, #0]
        if(status==CLOSED) // file closed: should open
    1dec:	cbnz	r4, 1e30 <saveData(short)+0x64>
        bool doTransactions=true;

};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}
    1dee:	ldr	r3, [pc, #660]	; (2084 <saveData(short)+0x2b8>)

static SDClass *checkDiskSpace(void)
{   static int isd_ = nsd;

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
    1df0:	ldr	r7, [pc, #660]	; (2088 <saveData(short)+0x2bc>)
    1df2:	ldr.w	r9, [pc, #744]	; 20dc <saveData(short)+0x310>
        bool doTransactions=true;

};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}
    1df6:	movs	r2, #1
    1df8:	strb	r2, [r3, #8]
    1dfa:	mov	r8, r3
    1dfc:	mov	r5, r7

static SDClass *checkDiskSpace(void)
{   static int isd_ = nsd;

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
    1dfe:	ldr	r4, [r7, #0]
    1e00:	ldr	r6, [pc, #644]	; (2088 <saveData(short)+0x2bc>)
    1e02:	cmp	r4, #0
    1e04:	bgt.n	1f04 <saveData(short)+0x138>
    1e06:	ldr.w	r3, [r9, r4, lsl #2]
    1e0a:	cmp	r3, #0
    1e0c:	beq.w	1f96 <saveData(short)+0x1ca>
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    1e10:	ldr	r0, [pc, #632]	; (208c <saveData(short)+0x2c0>)
    1e12:	mov.w	r3, #1224	; 0x4c8
    1e16:	mla	r0, r3, r4, r0
    1e1a:	adds	r0, #4
    1e1c:	bl	19f4 <FsVolume::freeClusterCount() const>
    1e20:	ldr	r3, [pc, #620]	; (2090 <saveData(short)+0x2c4>)
    1e22:	cmp.w	r0, #307200	; 0x4b000
    1e26:	str.w	r0, [r3, r4, lsl #2]
    1e2a:	bcc.w	1f96 <saveData(short)+0x1ca>
    1e2e:	b.n	1f04 <saveData(short)+0x138>
            {
               return MUST_REBOOT; // if file open fails: don't do anything
            }
        }
        //
        if(status==OPENED) // file is open: write first record (header)
    1e30:	cmp	r4, #1
    1e32:	bne.n	1ec2 <saveData(short)+0xf6>
     * @param header is pointer to header
     * 
     */
    #define MAGIC "WMXZ"
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    1e34:	bl	9468 <rtc_get>
    1e38:	add	r1, sp, #24
    1e3a:	bl	14f8 <breakTime(unsigned long, tmElements_t&)>

    int nd=sprintf(header,"%s%04d%02d%02d_%02d%02d%02d",
            MAGIC,tmYearToCalendar(tm.Year),tm.Month,tm.Day,tm.Hour,tm.Minute,tm.Second);
    1e3e:	ldrb.w	r2, [sp, #24]
    1e42:	str	r2, [sp, #16]
    1e44:	ldrb.w	r2, [sp, #25]
    1e48:	str	r2, [sp, #12]
    1e4a:	ldrb.w	r2, [sp, #26]
    1e4e:	ldr	r5, [pc, #580]	; (2094 <saveData(short)+0x2c8>)
    1e50:	ldrb.w	r3, [sp, #30]
    1e54:	str	r2, [sp, #8]
    1e56:	ldrb.w	r2, [sp, #28]
    1e5a:	str	r2, [sp, #4]
    1e5c:	ldrb.w	r2, [sp, #29]
    1e60:	str	r2, [sp, #0]
    1e62:	addw	r3, r3, #1970	; 0x7b2
    1e66:	ldr	r2, [pc, #560]	; (2098 <saveData(short)+0x2cc>)
    1e68:	ldr	r1, [pc, #560]	; (209c <saveData(short)+0x2d0>)
    1e6a:	mov	r0, r5
    1e6c:	bl	bed8 <sprintf>
    char *ptr = header+(nd+1);
    1e70:	adds	r0, #1

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    1e72:	movs	r2, #4
    1e74:	str	r2, [r5, r0]
    iptr[1] = (int32_t)SerNum;      // serial number
    1e76:	ldr	r2, [pc, #552]	; (20a0 <saveData(short)+0x2d4>)
    tmElements_t tm;
    breakTime(rtc_get(), tm);

    int nd=sprintf(header,"%s%04d%02d%02d_%02d%02d%02d",
            MAGIC,tmYearToCalendar(tm.Year),tm.Month,tm.Day,tm.Hour,tm.Minute,tm.Second);
    char *ptr = header+(nd+1);
    1e78:	adds	r3, r5, r0

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    iptr[1] = (int32_t)SerNum;      // serial number
    1e7a:	ldr	r2, [r2, #0]
    1e7c:	str	r2, [r3, #4]
    iptr[2] = FSAMP;
    1e7e:	movw	r2, #48000	; 0xbb80
    1e82:	str	r2, [r3, #8]
    iptr[3] = NCHAN_ACQ;
    iptr[4] = t_acq;
    1e84:	ldr	r2, [pc, #540]	; (20a4 <saveData(short)+0x2d8>)
    1e86:	ldr	r2, [r2, #0]
    1e88:	str	r2, [r3, #16]

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    iptr[1] = (int32_t)SerNum;      // serial number
    iptr[2] = FSAMP;
    iptr[3] = NCHAN_ACQ;
    1e8a:	movs	r4, #2
    iptr[4] = t_acq;
    iptr[5] = 0;
    1e8c:	movs	r2, #0

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    iptr[1] = (int32_t)SerNum;      // serial number
    iptr[2] = FSAMP;
    iptr[3] = NCHAN_ACQ;
    1e8e:	str	r4, [r3, #12]
    iptr[4] = t_acq;
    iptr[5] = 0;
    1e90:	str	r2, [r3, #20]

    uint32_t *uptr = (uint32_t*) header;
    uptr[127] = 0x55555555;
    1e92:	movs	r3, #85	; 0x55
    1e94:	strb.w	r3, [r5, #508]	; 0x1fc
    1e98:	strb.w	r3, [r5, #509]	; 0x1fd
    1e9c:	strb.w	r3, [r5, #510]	; 0x1fe
    1ea0:	strb.w	r3, [r5, #511]	; 0x1ff
    1ea4:	ldr	r3, [pc, #512]	; (20a8 <saveData(short)+0x2dc>)
    1ea6:	ldr	r0, [r3, #16]
	virtual size_t write(const uint8_t *buf, size_t size) {
		return (f) ? f->write((void*)buf, size) : 0;
	}

	size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    1ea8:	cbnz	r0, 1eb0 <saveData(short)+0xe4>
                file = msd->open(fileName, FILE_WRITE_BEGIN); 
                if(file) 
                    status = OPENED; 
                else 
                {   Serial.println("Failing open file");
                    return MUST_REBOOT; 
    1eaa:	mvn.w	r0, #1
    1eae:	b.n	21ba <saveData(short)+0x3ee>
    1eb0:	ldr	r3, [r0, #0]
    1eb2:	mov.w	r2, #512	; 0x200
    1eb6:	ldr	r3, [r3, #12]
    1eb8:	mov	r1, r5
    1eba:	blx	r3
            }
        }
        //
        if(status==OPENED) // file is open: write first record (header)
        {   makeHeader(header);
            if(file.write((const void*)header,512) < 512) return MUST_REBOOT; else status=2;
    1ebc:	cmp.w	r0, #512	; 0x200
    1ec0:	bcc.n	1eaa <saveData(short)+0xde>
    1ec2:	ldr	r3, [pc, #484]	; (20a8 <saveData(short)+0x2dc>)
    1ec4:	ldr	r0, [r3, #16]
    1ec6:	cmp	r0, #0
    1ec8:	beq.n	1eaa <saveData(short)+0xde>
    1eca:	ldr	r3, [r0, #0]
    1ecc:	ldr	r1, [pc, #428]	; (207c <saveData(short)+0x2b0>)
    1ece:	ldr	r3, [r3, #12]
    1ed0:	mov.w	r2, #4096	; 0x1000
    1ed4:	blx	r3
        }
        //
        if(status>=RUNNING) // file is open, header written: store data records
        {   
            if(file.write((const void *)diskBuffer,4*MAX_DISK_BUFFER) < 4*MAX_DISK_BUFFER) return MUST_REBOOT;
    1ed6:	cmp.w	r0, #4096	; 0x1000
    1eda:	bcc.n	1eaa <saveData(short)+0xde>
        }
    }
    // following is done independent of data availability
    if(status==DOCLOSE) // should close file
    1edc:	cmp	r4, #3
    1ede:	bne.n	1eee <saveData(short)+0x122>
    {
        // writes are done, so enable again transaction activations
        file.flush();
    1ee0:	ldr	r0, [pc, #452]	; (20a8 <saveData(short)+0x2dc>)
    1ee2:	bl	9e6 <File::flush()>
        file.close();
    1ee6:	ldr	r0, [pc, #448]	; (20a8 <saveData(short)+0x2dc>)
    1ee8:	bl	f3c <File::close()>
    1eec:	b.n	1f8e <saveData(short)+0x1c2>
        status = CLOSED;
    }
    if(status==MUSTSTOP) // should close file and stop
    1eee:	cmp	r4, #4
    1ef0:	bne.n	1f92 <saveData(short)+0x1c6>
    {   
        file.flush();
    1ef2:	ldr	r0, [pc, #436]	; (20a8 <saveData(short)+0x2dc>)
    1ef4:	bl	9e6 <File::flush()>
        file.close();
    1ef8:	ldr	r0, [pc, #428]	; (20a8 <saveData(short)+0x2dc>)
    1efa:	bl	f3c <File::close()>
        status = STOPPED;
    1efe:	mov.w	r0, #4294967295
    1f02:	b.n	21ba <saveData(short)+0x3ee>
        bool doTransactions=true;

};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}
    1f04:	movs	r3, #0
    1f06:	strb.w	r3, [r8, #8]

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    doTransactions(false);
    if(isd<nsd) 
    1f0a:	ldr	r3, [r6, #0]
    1f0c:	ldr	r4, [pc, #376]	; (2088 <saveData(short)+0x2bc>)
    1f0e:	cmp	r3, #0
    1f10:	bgt.n	1f4c <saveData(short)+0x180>
    {   sdx[isd].sdfs.chvol();
    1f12:	ldr	r5, [pc, #376]	; (208c <saveData(short)+0x2c0>)
    bool chdir(const char* path) {
    return m_fVol ? m_fVol->chdir(path) :
           m_xVol ? m_xVol->chdir(path) : false;
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
    1f14:	ldr	r2, [pc, #404]	; (20ac <saveData(short)+0x2e0>)
        Serial.println(); Serial.print(isd);
    1f16:	ldr	r0, [pc, #408]	; (20b0 <saveData(short)+0x2e4>)
    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    doTransactions(false);
    if(isd<nsd) 
    {   sdx[isd].sdfs.chvol();
    1f18:	mov.w	r7, #1224	; 0x4c8
    1f1c:	mla	r3, r7, r3, r5
    1f20:	adds	r3, #4
    1f22:	str	r3, [r2, #0]
        Serial.println(); Serial.print(isd);
    1f24:	bl	a1e4 <Print::println()>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    1f28:	ldr	r1, [r4, #0]
    1f2a:	ldr	r0, [pc, #388]	; (20b0 <saveData(short)+0x2e4>)
    1f2c:	bl	a294 <Print::print(long)>
        Serial.print(": "); Serial.print(sdx[isd].sdfs.freeClusterCount());
    1f30:	ldr	r1, [pc, #384]	; (20b4 <saveData(short)+0x2e8>)
    1f32:	ldr	r0, [pc, #380]	; (20b0 <saveData(short)+0x2e4>)
    1f34:	bl	19a0 <Print::print(char const*)>
    1f38:	ldr	r0, [r4, #0]
    1f3a:	mla	r0, r7, r0, r5
    1f3e:	adds	r0, #4
    1f40:	bl	19f4 <FsVolume::freeClusterCount() const>
    1f44:	mov	r1, r0
    1f46:	ldr	r0, [pc, #360]	; (20b0 <saveData(short)+0x2e4>)
    1f48:	bl	780 <Print::print(unsigned long)>
    }
    //
    if(isd != isd_) hour_=0; // set hour_ to zero to trigger creation of directories in new disk
    1f4c:	ldr	r2, [pc, #360]	; (20b8 <saveData(short)+0x2ec>)
    1f4e:	ldr	r3, [r6, #0]
    1f50:	ldr	r1, [r2, #0]
    isd_=isd;
    1f52:	str	r3, [r2, #0]
    {   sdx[isd].sdfs.chvol();
        Serial.println(); Serial.print(isd);
        Serial.print(": "); Serial.print(sdx[isd].sdfs.freeClusterCount());
    }
    //
    if(isd != isd_) hour_=0; // set hour_ to zero to trigger creation of directories in new disk
    1f54:	cmp	r3, r1
    1f56:	it	ne
    1f58:	ldrne	r1, [pc, #352]	; (20bc <saveData(short)+0x2f0>)
    //fetch data from circular buffer
    if(pullData(diskBuffer,NDBL))
    {   disk_count++;
        if(status==CLOSED) // file closed: should open
        {   //doTransactions(true);
            if(!(msd=checkDiskSpace())) return MUST_REBOOT;
    1f5a:	ldr	r5, [pc, #356]	; (20c0 <saveData(short)+0x2f4>)
    {   sdx[isd].sdfs.chvol();
        Serial.println(); Serial.print(isd);
        Serial.print(": "); Serial.print(sdx[isd].sdfs.freeClusterCount());
    }
    //
    if(isd != isd_) hour_=0; // set hour_ to zero to trigger creation of directories in new disk
    1f5c:	itt	ne
    1f5e:	movne	r0, #0
    1f60:	strne	r0, [r1, #0]
    isd_=isd;
    if(isd==nsd) return (SDClass *) 0; else return &sdx[isd];
    1f62:	cmp	r3, #1
    1f64:	ittte	ne
    1f66:	ldrne	r2, [pc, #292]	; (208c <saveData(short)+0x2c0>)
    1f68:	movne.w	r1, #1224	; 0x4c8
    1f6c:	mlane	r3, r1, r3, r2
    1f70:	moveq	r3, #0
    //fetch data from circular buffer
    if(pullData(diskBuffer,NDBL))
    {   disk_count++;
        if(status==CLOSED) // file closed: should open
        {   //doTransactions(true);
            if(!(msd=checkDiskSpace())) return MUST_REBOOT;
    1f72:	str	r3, [r5, #0]
    1f74:	cmp	r3, #0
    1f76:	beq.n	1eaa <saveData(short)+0xde>
            //
            if(newDirectory(dirName,dirFlag)) 
    1f78:	ldr	r4, [pc, #328]	; (20c4 <saveData(short)+0x2f8>)
    1f7a:	ldr	r7, [r4, #0]
    isd_=isd;
    if(isd==nsd) return (SDClass *) 0; else return &sdx[isd];
}

static int16_t newDirectory(char *dirName, int dirFlag)
{ if(newHour())
    1f7c:	bl	14d4 <newHour()>
    1f80:	cbnz	r0, 1f9e <saveData(short)+0x1d2>
            if(newDirectory(dirName,dirFlag)) 
            {   if(!msd->sdfs.exists(dirName) && !msd->sdfs.mkdir(dirName)) dirFlag++;          
                if(!msd->sdfs.chdir(dirName)) dirFlag++; else dirFlag=0;
            }
            //
            if(dirFlag>5) return MUST_REBOOT;   // too many directory errors
    1f82:	ldr	r3, [r4, #0]
    1f84:	cmp	r3, #5
    1f86:	bgt.n	1eaa <saveData(short)+0xde>
            if(dirFlag>0) return CLOSED;        // create new directory with different name
    1f88:	cmp	r3, #0
    1f8a:	ble.w	212a <saveData(short)+0x35e>
    1f8e:	movs	r0, #0
    1f90:	b.n	21ba <saveData(short)+0x3ee>
    1f92:	mov	r0, r4
    1f94:	b.n	21ba <saveData(short)+0x3ee>
static SDClass *checkDiskSpace(void)
{   static int isd_ = nsd;

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    1f96:	ldr	r3, [r5, #0]
    1f98:	adds	r3, #1
    1f9a:	str	r3, [r5, #0]
    1f9c:	b.n	1dfe <saveData(short)+0x32>

static int16_t newDirectory(char *dirName, int dirFlag)
{ if(newHour())
    {   
        tmElements_t tm;
        breakTime(rtc_get(), tm);
    1f9e:	bl	9468 <rtc_get>
    1fa2:	add	r1, sp, #24
    1fa4:	bl	14f8 <breakTime(unsigned long, tmElements_t&)>
    1fa8:	ldr	r2, [pc, #244]	; (20a0 <saveData(short)+0x2d4>)
    1faa:	ldrb.w	lr, [sp, #26]
    1fae:	ldrb.w	r0, [sp, #28]
    1fb2:	ldrb.w	r1, [sp, #29]
    1fb6:	ldrb.w	r3, [sp, #30]
        if(!dirFlag)
    1fba:	cbnz	r7, 1fd8 <saveData(short)+0x20c>
        {
            sprintf(dirName, "/%s%06x_%04d%02d%02d/%02d/", 
                          DirPrefix,(unsigned int)SerNum,
                                  tmYearToCalendar(tm.Year),tm.Month, tm.Day, tm.Hour);
    1fbc:	addw	r3, r3, #1970	; 0x7b2
    1fc0:	str	r0, [sp, #8]
    1fc2:	str	r1, [sp, #4]
    1fc4:	str.w	lr, [sp, #12]
    1fc8:	str	r3, [sp, #0]
    1fca:	ldr	r3, [r2, #0]
    1fcc:	ldr	r1, [pc, #248]	; (20c8 <saveData(short)+0x2fc>)
    1fce:	ldr	r2, [pc, #252]	; (20cc <saveData(short)+0x300>)
    1fd0:	ldr	r0, [pc, #252]	; (20d0 <saveData(short)+0x304>)
    1fd2:	bl	bed8 <sprintf>
    1fd6:	b.n	1ff4 <saveData(short)+0x228>
        }
        else
        {
            sprintf(dirName, "/%s%06x_%04d%02d%02d/%02d_%02d/", 
                          DirPrefix,(unsigned int)SerNum,
                                  tmYearToCalendar(tm.Year),tm.Month, tm.Day, tm.Hour,dirFlag);
    1fd8:	addw	r3, r3, #1970	; 0x7b2
    1fdc:	str	r0, [sp, #8]
    1fde:	str	r1, [sp, #4]
    1fe0:	str	r7, [sp, #16]
    1fe2:	str.w	lr, [sp, #12]
    1fe6:	str	r3, [sp, #0]
    1fe8:	ldr	r3, [r2, #0]
    1fea:	ldr	r1, [pc, #232]	; (20d4 <saveData(short)+0x308>)
    1fec:	ldr	r2, [pc, #220]	; (20cc <saveData(short)+0x300>)
    1fee:	ldr	r0, [pc, #224]	; (20d0 <saveData(short)+0x304>)
    1ff0:	bl	bed8 <sprintf>
        }

        //
        Serial.print("\n"); Serial.print(dirName);
    1ff4:	ldr	r1, [pc, #224]	; (20d8 <saveData(short)+0x30c>)
    1ff6:	ldr	r0, [pc, #184]	; (20b0 <saveData(short)+0x2e4>)
    1ff8:	bl	19a0 <Print::print(char const*)>
    1ffc:	ldr	r1, [pc, #208]	; (20d0 <saveData(short)+0x304>)
    1ffe:	ldr	r0, [pc, #176]	; (20b0 <saveData(short)+0x2e4>)
    2000:	bl	19a0 <Print::print(char const*)>
        if(status==CLOSED) // file closed: should open
        {   //doTransactions(true);
            if(!(msd=checkDiskSpace())) return MUST_REBOOT;
            //
            if(newDirectory(dirName,dirFlag)) 
            {   if(!msd->sdfs.exists(dirName) && !msd->sdfs.mkdir(dirName)) dirFlag++;          
    2004:	ldr	r3, [r5, #0]
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
    2006:	ldr.w	r1, [r3, #1156]	; 0x484
           m_xVol ? m_xVol->exists(path) : false;
    200a:	cbz	r1, 2024 <saveData(short)+0x258>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    200c:	movs	r3, #0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    200e:	ldr	r2, [pc, #192]	; (20d0 <saveData(short)+0x304>)
    2010:	strb.w	r3, [sp, #24]
    2014:	add	r0, sp, #24
    2016:	strb.w	r3, [sp, #25]
    201a:	strb.w	r3, [sp, #26]
    201e:	bl	6394 <FatFile::open(FatVolume*, char const*, int)>
    2022:	b.n	2068 <saveData(short)+0x29c>
    2024:	ldr.w	r0, [r3, #1160]	; 0x488
    2028:	cbnz	r0, 2050 <saveData(short)+0x284>
    202a:	ldr	r3, [r5, #0]
   * \param[in] pFlag Create missing parent directories if true.
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
    202c:	ldr.w	r1, [r3, #1156]	; 0x484
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
    2030:	cbz	r1, 206e <saveData(short)+0x2a2>
    2032:	movs	r3, #0
    2034:	strb.w	r3, [sp, #24]
    2038:	strb.w	r3, [sp, #25]
    203c:	strb.w	r3, [sp, #26]
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    2040:	ldr	r2, [pc, #140]	; (20d0 <saveData(short)+0x304>)
    2042:	movs	r3, #1
    2044:	add.w	r1, r1, #1096	; 0x448
    2048:	add	r0, sp, #24
    204a:	bl	6510 <FatFile::mkdir(FatFile*, char const*, bool)>
    204e:	b.n	20fa <saveData(short)+0x32e>
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    2050:	strb.w	r1, [sp, #73]	; 0x49
    2054:	strb.w	r1, [sp, #74]	; 0x4a
    2058:	strb.w	r1, [sp, #75]	; 0x4b
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    205c:	mov	r3, r1
    205e:	ldr	r2, [pc, #112]	; (20d0 <saveData(short)+0x304>)
    2060:	mov	r1, r0
    2062:	add	r0, sp, #24
    2064:	bl	484e <ExFatFile::open(ExFatVolume*, char const*, int)>
    2068:	cmp	r0, #0
    206a:	bne.n	20fe <saveData(short)+0x332>
    206c:	b.n	202a <saveData(short)+0x25e>
    206e:	ldr.w	r0, [r3, #1160]	; 0x488
    2072:	cbnz	r0, 20e0 <saveData(short)+0x314>
    2074:	ldr	r3, [r4, #0]
    2076:	adds	r3, #1
    2078:	str	r3, [r4, #0]
    207a:	b.n	20fe <saveData(short)+0x332>
    207c:	.word	0x200191bc
    2080:	.word	0x200191b8
    2084:	.word	0x200191ac
    2088:	.word	0x1fff2228
    208c:	.word	0x20017c34
    2090:	.word	0x1fff2224
    2094:	.word	0x20017a30
    2098:	.word	0x000128e8
    209c:	.word	0x000128ed
    20a0:	.word	0x2001a1c0
    20a4:	.word	0x1fff0f34
    20a8:	.word	0x1fff2210
    20ac:	.word	0x2001a69c
    20b0:	.word	0x1fff1348
    20b4:	.word	0x00012500
    20b8:	.word	0x1fff0f38
    20bc:	.word	0x1fff220c
    20c0:	.word	0x20017c30
    20c4:	.word	0x2001814c
    20c8:	.word	0x00012885
    20cc:	.word	0x00012883
    20d0:	.word	0x2001815c
    20d4:	.word	0x000128a0
    20d8:	.word	0x00012da8
    20dc:	.word	0x1fff222c
    20e0:	strb.w	r1, [sp, #73]	; 0x49
    20e4:	strb.w	r1, [sp, #74]	; 0x4a
    20e8:	strb.w	r1, [sp, #75]	; 0x4b
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    20ec:	movs	r3, #1
    20ee:	add.w	r1, r0, #1096	; 0x448
    20f2:	ldr	r2, [pc, #204]	; (21c0 <saveData(short)+0x3f4>)
    20f4:	add	r0, sp, #24
    20f6:	bl	50f0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
    20fa:	cmp	r0, #0
    20fc:	beq.n	2074 <saveData(short)+0x2a8>
                if(!msd->sdfs.chdir(dirName)) dirFlag++; else dirFlag=0;
    20fe:	ldr	r3, [r5, #0]
   * Set volume working directory.
   * \param[in] path Path for volume working directory.
   * \return true for success or false for failure.
   */
    bool chdir(const char* path) {
    return m_fVol ? m_fVol->chdir(path) :
    2100:	ldr.w	r0, [r3, #1156]	; 0x484
           m_xVol ? m_xVol->chdir(path) : false;
    2104:	cbz	r0, 210e <saveData(short)+0x342>
    2106:	ldr	r1, [pc, #184]	; (21c0 <saveData(short)+0x3f4>)
    2108:	bl	6d90 <FatVolume::chdir(char const*)>
    210c:	b.n	2120 <saveData(short)+0x354>
    210e:	ldr.w	r0, [r3, #1160]	; 0x488
    2112:	cbnz	r0, 211a <saveData(short)+0x34e>
    2114:	ldr	r3, [r4, #0]
    2116:	adds	r3, #1
    2118:	b.n	2126 <saveData(short)+0x35a>
    211a:	ldr	r1, [pc, #164]	; (21c0 <saveData(short)+0x3f4>)
    211c:	bl	4c98 <ExFatVolume::chdir(char const*)>
    2120:	cmp	r0, #0
    2122:	beq.n	2114 <saveData(short)+0x348>
    2124:	movs	r3, #0
    2126:	str	r3, [r4, #0]
    2128:	b.n	1f82 <saveData(short)+0x1b6>

}
static int16_t newFileName(char *fileName)
{
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    212a:	bl	9468 <rtc_get>
    212e:	add	r1, sp, #24
    2130:	bl	14f8 <breakTime(unsigned long, tmElements_t&)>
	sprintf(fileName, "%s_%02d%02d%02d.bin", FilePrefix, tm.Hour, tm.Minute, tm.Second);
    2134:	ldrb.w	r2, [sp, #24]
    2138:	str	r2, [sp, #4]
    213a:	ldrb.w	r2, [sp, #25]
    213e:	ldrb.w	r3, [sp, #26]
    2142:	str	r2, [sp, #0]
    2144:	ldr	r1, [pc, #124]	; (21c4 <saveData(short)+0x3f8>)
    2146:	ldr	r2, [pc, #128]	; (21c8 <saveData(short)+0x3fc>)
    2148:	ldr	r0, [pc, #128]	; (21cc <saveData(short)+0x400>)
    214a:	bl	bed8 <sprintf>
    //
    Serial.print("\n"); Serial.print(isd); Serial.print(": ");Serial.print(fileName);
    214e:	ldr	r1, [pc, #128]	; (21d0 <saveData(short)+0x404>)
    2150:	ldr	r0, [pc, #128]	; (21d4 <saveData(short)+0x408>)
    2152:	bl	19a0 <Print::print(char const*)>
    2156:	ldr	r1, [r6, #0]
    2158:	ldr	r0, [pc, #120]	; (21d4 <saveData(short)+0x408>)
    215a:	bl	a294 <Print::print(long)>
    215e:	ldr	r1, [pc, #120]	; (21d8 <saveData(short)+0x40c>)
    2160:	ldr	r0, [pc, #112]	; (21d4 <saveData(short)+0x408>)
    2162:	bl	19a0 <Print::print(char const*)>
    2166:	ldr	r1, [pc, #100]	; (21cc <saveData(short)+0x400>)
    2168:	ldr	r0, [pc, #104]	; (21d4 <saveData(short)+0x408>)
    216a:	bl	19a0 <Print::print(char const*)>
            if(dirFlag>5) return MUST_REBOOT;   // too many directory errors
            if(dirFlag>0) return CLOSED;        // create new directory with different name

            if(newFileName(fileName))
            {   
                file = msd->open(fileName, FILE_WRITE_BEGIN); 
    216e:	ldr	r1, [r5, #0]
    2170:	ldr	r2, [pc, #88]	; (21cc <saveData(short)+0x400>)
    2172:	ldr	r3, [r1, #0]
    2174:	add	r0, sp, #24
    2176:	ldr	r4, [r3, #0]
    2178:	movs	r3, #2
    217a:	blx	r4
	}
#ifdef FILE_USE_MOVE
	// Move assignment.
	File& operator = (const File&& file) {
		//Serial.println("File move assignment");
		if (file.f) file.f->refcount++;
    217c:	ldr	r3, [sp, #40]	; 0x28
    217e:	cbz	r3, 2186 <saveData(short)+0x3ba>
    2180:	ldr	r2, [r3, #4]
    2182:	adds	r2, #1
    2184:	str	r2, [r3, #4]
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
    2186:	ldr	r4, [pc, #84]	; (21dc <saveData(short)+0x410>)
    2188:	ldr	r3, [r4, #16]
    218a:	cbz	r3, 2194 <saveData(short)+0x3c8>
    218c:	add.w	r0, r4, #16
    2190:	bl	1908 <File::dec_refcount() [clone .isra.23]>
		f = file.f;
    2194:	ldr	r3, [sp, #40]	; 0x28
    2196:	str	r3, [r4, #16]
    2198:	add	r0, sp, #24
    219a:	bl	ba0 <File::~File()>
    219e:	ldr	r0, [r4, #16]
			f->close();
			dec_refcount();
		}
	}
	operator bool() {
		return (f) ? f->isOpen() : false;
    21a0:	cbnz	r0, 21ac <saveData(short)+0x3e0>
                if(file) 
                    status = OPENED; 
                else 
                {   Serial.println("Failing open file");
    21a2:	ldr	r1, [pc, #60]	; (21e0 <saveData(short)+0x414>)
    21a4:	ldr	r0, [pc, #44]	; (21d4 <saveData(short)+0x408>)
    21a6:	bl	788 <Print::println(char const*)>
    21aa:	b.n	1eaa <saveData(short)+0xde>
    21ac:	ldr	r3, [r0, #0]
    21ae:	ldr	r3, [r3, #48]	; 0x30
    21b0:	blx	r3
            if(dirFlag>0) return CLOSED;        // create new directory with different name

            if(newFileName(fileName))
            {   
                file = msd->open(fileName, FILE_WRITE_BEGIN); 
                if(file) 
    21b2:	cmp	r0, #0
    21b4:	bne.w	1e34 <saveData(short)+0x68>
    21b8:	b.n	21a2 <saveData(short)+0x3d6>
        file.flush();
        file.close();
        status = STOPPED;
    }
    return status;
}
    21ba:	add	sp, #84	; 0x54
    21bc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    21c0:	.word	0x2001815c
    21c4:	.word	0x000128c2
    21c8:	.word	0x000128c0
    21cc:	.word	0x200180fc
    21d0:	.word	0x00012da8
    21d4:	.word	0x1fff1348
    21d8:	.word	0x00012500
    21dc:	.word	0x1fff2210
    21e0:	.word	0x000128d6

000021e4 <_GLOBAL__sub_I_data_buffer>:
    21e4:	push	{r3, r4, r5, lr}
            { /**
             * @brief Constructor
             * @param buffer is pointer to data store
             * 
             */
                data_buffer=buffer; front_=rear_=0;
    21e6:	ldr	r3, [pc, #128]	; (2268 <_GLOBAL__sub_I_data_buffer+0x84>)
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    21e8:	ldr	r0, [pc, #128]	; (226c <_GLOBAL__sub_I_data_buffer+0x88>)

/****************************** Filing Utility *******************************************/

extern int t_acq;

File file=NULL; // is used by saveData and saveNAD
    21ea:	ldr	r5, [pc, #132]	; (2270 <_GLOBAL__sub_I_data_buffer+0x8c>)
            { /**
             * @brief Constructor
             * @param buffer is pointer to data store
             * 
             */
                data_buffer=buffer; front_=rear_=0;
    21ec:	ldr	r2, [pc, #132]	; (2274 <_GLOBAL__sub_I_data_buffer+0x90>)
    21ee:	str	r2, [r3, #4]
    21f0:	movs	r4, #0
    21f2:	strh	r4, [r3, #2]
    21f4:	strh	r4, [r3, #0]
    21f6:	mov.w	r3, #1000	; 0x3e8

/****************************** Filing Utility *******************************************/

extern int t_acq;

File file=NULL; // is used by saveData and saveNAD
    21fa:	mov	r2, r5
    21fc:	strb	r4, [r0, #4]
    21fe:	str	r3, [r0, #8]
    2200:	strb	r4, [r0, #12]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
    2202:	ldr	r3, [pc, #116]	; (2278 <_GLOBAL__sub_I_data_buffer+0x94>)
    2204:	ldr	r1, [pc, #116]	; (227c <_GLOBAL__sub_I_data_buffer+0x98>)
    2206:	str	r3, [r0, #0]
		f = file;
    2208:	str	r4, [r0, #16]
    220a:	bl	a54c <__aeabi_atexit>
// This is a simple driver based on the the standard SPI.h library.
// You can write a driver entirely independent of SPI.h.
// It can be optimized for your board or a different SPI port can be used.
// The driver must be derived from SdSpiBaseClass.
// See: SdFat/src/SpiDriver/SdSpiBaseClass.h
class MySpiClass : public SdSpiBaseClass {
    220e:	ldr	r3, [pc, #112]	; (2280 <_GLOBAL__sub_I_data_buffer+0x9c>)
    2210:	ldr	r2, [pc, #112]	; (2284 <_GLOBAL__sub_I_data_buffer+0xa0>)
    2212:	str	r2, [r3, #0]
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
		}
		ctar = c | t;
    2214:	ldr	r2, [pc, #112]	; (2288 <_GLOBAL__sub_I_data_buffer+0xa4>)
    2216:	str	r2, [r3, #4]
    2218:	movs	r2, #1
    221a:	strb	r2, [r3, #8]


class SDClass : public FS
{
public:
	SDClass() { }
    221c:	ldr	r3, [pc, #108]	; (228c <_GLOBAL__sub_I_data_buffer+0xa8>)
    221e:	ldr	r1, [pc, #112]	; (2290 <_GLOBAL__sub_I_data_buffer+0xac>)
#else  // HAS_SDIO_CLASS
class SdSpiCard {
#endif  // HAS_SDIO_CLASS
 public:
  /** Construct an instance of SdSpiCard. */
  SdSpiCard() {}
    2220:	strb.w	r2, [r3, #1197]	; 0x4ad
    2224:	movs	r2, #41	; 0x29
    2226:	str	r1, [r3, #0]
    2228:	strb.w	r2, [r3, #1199]	; 0x4af
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    222c:	ldr	r1, [pc, #100]	; (2294 <_GLOBAL__sub_I_data_buffer+0xb0>)
    222e:	str.w	r1, [r3, #1172]	; 0x494
    2232:	movs	r2, #255	; 0xff
    2234:	ldr	r1, [pc, #96]	; (2298 <_GLOBAL__sub_I_data_buffer+0xb4>)
    2236:	strb.w	r2, [r3, #1221]	; 0x4c5
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    223a:	strb.w	r4, [r3, #1180]	; 0x49c
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    223e:	strb.w	r4, [r3, #1181]	; 0x49d
    2242:	strb.w	r4, [r3, #1202]	; 0x4b2
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    2246:	strb.w	r4, [r3, #1216]	; 0x4c0
    224a:	str.w	r1, [r3, #1184]	; 0x4a0
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() {}
    224e:	str.w	r4, [r3, #1156]	; 0x484
    2252:	str.w	r4, [r3, #1160]	; 0x488
    2256:	strb.w	r4, [r3, #1220]	; 0x4c4
    const char *sd_str[]={"sd1"};
    const int cs[] = {10 };

    const int nsd = sizeof(cs)/sizeof(int);

    SDClass sdx[nsd];
    225a:	mov	r2, r5
    225c:	mov	r0, r4
    225e:	ldr	r1, [pc, #60]	; (229c <_GLOBAL__sub_I_data_buffer+0xb8>)
        file.flush();
        file.close();
        status = STOPPED;
    }
    return status;
}
    2260:	ldmia.w	sp!, {r3, r4, r5, lr}
    const char *sd_str[]={"sd1"};
    const int cs[] = {10 };

    const int nsd = sizeof(cs)/sizeof(int);

    SDClass sdx[nsd];
    2264:	b.w	a54c <__aeabi_atexit>
    2268:	.word	0x20018150
    226c:	.word	0x1fff2210
    2270:	.word	0x1fff0f30
    2274:	.word	0x1fff2230
    2278:	.word	0x00012578
    227c:	.word	0x00000ba1
    2280:	.word	0x200191ac
    2284:	.word	0x0001283c
    2288:	.word	0x38011001
    228c:	.word	0x20017c34
    2290:	.word	0x00012ad0
    2294:	.word	0x00012e30
    2298:	.word	0x00012dd0
    229c:	.word	0x00001845

000022a0 <TwoWire::write(int)>:
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
	}
	size_t write(int n) {
		return write((uint8_t)n);
    22a0:	ldr	r3, [r0, #0]
    22a2:	uxtb	r1, r1
    22a4:	ldr	r3, [r3, #0]
    22a6:	bx	r3

000022a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>:
        val = wire->read()<<8;
        val |= wire->read();
        return val;
    }
    
    uint8_t write16(uint8_t addr, uint16_t reg, uint16_t val) 
    22a8:	push	{r3, r4, r5, r6, r7, lr}
    22aa:	mov	r6, r3
    { 
        wire->beginTransmission(addr);
    22ac:	ldr	r3, [r0, #0]
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
		transmitting = 1;
    22ae:	movs	r5, #1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    22b0:	lsls	r1, r1, #1
    22b2:	strb.w	r1, [r3, #163]	; 0xa3
		transmitting = 1;
    22b6:	strb.w	r5, [r3, #302]	; 0x12e
		txBufferLength = 1;
    22ba:	strb.w	r5, [r3, #301]	; 0x12d
        val = wire->read()<<8;
        val |= wire->read();
        return val;
    }
    
    uint8_t write16(uint8_t addr, uint16_t reg, uint16_t val) 
    22be:	mov	r4, r0
    22c0:	mov	r7, r2
    { 
        wire->beginTransmission(addr);
        wire->write(reg >> 8);
    22c2:	lsrs	r1, r2, #8
    22c4:	ldr	r0, [r0, #0]
    22c6:	bl	22a0 <TwoWire::write(int)>
        wire->write(reg);
    22ca:	mov	r1, r7
    22cc:	ldr	r0, [r4, #0]
    22ce:	bl	22a0 <TwoWire::write(int)>
        wire->write(val >> 8);
    22d2:	lsrs	r1, r6, #8
    22d4:	ldr	r0, [r4, #0]
    22d6:	bl	22a0 <TwoWire::write(int)>
        wire->write(val);
    22da:	mov	r1, r6
    22dc:	ldr	r0, [r4, #0]
    22de:	bl	22a0 <TwoWire::write(int)>
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    22e2:	mov	r1, r5
    22e4:	ldr	r0, [r4, #0]
    22e6:	bl	2910 <TwoWire::endTransmission(unsigned char)>
        return (wire->endTransmission() == 0) ;
    }
    22ea:	clz	r0, r0
    22ee:	lsrs	r0, r0, #5
    22f0:	pop	{r3, r4, r5, r6, r7, pc}

000022f2 <adc_init()>:
    22f2:	bx	lr

000022f4 <adcStatus()>:
    static uint8_t addr = SGTL5000_I2C_ADDR_CS_LOW;
    i2c_class i2c(&Wire);
    
    void adc_init(void) {  }
    void setAGain(int8_t again) {  }
    void adcStatus(void) {  }
    22f4:	bx	lr
    22f6:	Address 0x000022f6 is out of bounds.


000022f8 <adc_enable(unsigned int, unsigned long)>:

    bool adc_enable(const unsigned extMCLK, const uint32_t pllFreq) 
    {
    22f8:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        wire->setSDA(sda);
    }

    uint8_t exist(uint8_t addr)
    {
        wire->beginTransmission(addr);
    22fc:	ldr	r6, [pc, #548]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    22fe:	mov	r5, r0
    2300:	ldr	r0, [r6, #0]
    2302:	mov	r7, r1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2304:	movs	r4, #20
		transmitting = 1;
    2306:	movs	r1, #1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2308:	strb.w	r4, [r0, #163]	; 0xa3
		transmitting = 1;
    230c:	strb.w	r1, [r0, #302]	; 0x12e
		txBufferLength = 1;
    2310:	strb.w	r1, [r0, #301]	; 0x12d
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    2314:	bl	2910 <TwoWire::endTransmission(unsigned char)>
        if(!i2c.exist(addr)) Serial.println("No I2C address found");
    2318:	cbz	r0, 2328 <adc_enable(unsigned int, unsigned long)+0x30>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    231a:	mov	r1, r4
    231c:	ldr	r0, [pc, #520]	; (2528 <adc_enable(unsigned int, unsigned long)+0x230>)
    231e:	bl	91f8 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    2322:	ldr	r0, [pc, #520]	; (252c <adc_enable(unsigned int, unsigned long)+0x234>)
    2324:	bl	a1e4 <Print::println()>
    }

    uint16_t read16(uint8_t addr, uint16_t reg) 
    { 
        unsigned int val;
        wire->beginTransmission(addr);
    2328:	ldr	r0, [r6, #0]
    232a:	ldr.w	r8, [pc, #504]	; 2524 <adc_enable(unsigned int, unsigned long)+0x22c>
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    232e:	movs	r3, #20
		transmitting = 1;
    2330:	movs	r4, #1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2332:	strb.w	r3, [r0, #163]	; 0xa3
        wire->write(reg >> 8);
    2336:	movs	r1, #0
		transmitting = 1;
    2338:	strb.w	r4, [r0, #302]	; 0x12e
		txBufferLength = 1;
    233c:	strb.w	r4, [r0, #301]	; 0x12d
    2340:	bl	22a0 <TwoWire::write(int)>
        wire->write(reg);
    2344:	movs	r1, #6
    2346:	ldr	r0, [r6, #0]
    2348:	bl	22a0 <TwoWire::write(int)>
        if (wire->endTransmission(false) != 0) return 0;
    234c:	movs	r1, #0
    234e:	ldr	r0, [r6, #0]
    2350:	bl	2910 <TwoWire::endTransmission(unsigned char)>
    2354:	cbnz	r0, 238c <adc_enable(unsigned int, unsigned long)+0x94>
	uint8_t requestFrom(int address, int quantity, int sendStop) {
		return requestFrom((uint8_t)address, (uint8_t)quantity,
			(uint8_t)(sendStop ? 1 : 0));
	}
	uint8_t requestFrom(int address, int quantity) {
		return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)1);
    2356:	mov	r3, r4
    2358:	mov	r2, r4
    235a:	movs	r1, #10
    235c:	ldr.w	r0, [r8]
    2360:	bl	2a08 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
        if (wire->requestFrom((int)addr, 1) < 1) return 0;
    2364:	cbz	r0, 238c <adc_enable(unsigned int, unsigned long)+0x94>
        val = wire->read()<<8;
    2366:	ldr.w	r0, [r8]
    236a:	ldr	r3, [r0, #0]
    236c:	ldr	r3, [r3, #20]
    236e:	blx	r3
    2370:	lsls	r6, r0, #8
        val |= wire->read();
    2372:	ldr.w	r0, [r8]
    2376:	ldr	r3, [r0, #0]
    2378:	ldr	r3, [r3, #20]
    237a:	blx	r3
        return val;
    237c:	orrs	r0, r6
    237e:	uxth	r0, r0
 
        //Check if we are in Master Mode and if the Teensy had a reset:
        unsigned int n = i2c.read16(addr,CHIP_I2S_CTRL);
        if ( (extMCLK > 0) && (n == (0x0030 | (1<<7))) ) {
    2380:	cbz	r5, 238c <adc_enable(unsigned int, unsigned long)+0x94>
    2382:	cmp	r0, #176	; 0xb0
    2384:	bne.n	238c <adc_enable(unsigned int, unsigned long)+0x94>
            //Yes. Do not initialize.
            return true;
    2386:	mov	r0, r4
    2388:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        }

        int r = i2c.write16(addr,CHIP_ANA_POWER, 0x4060);  // VDDD is externally driven with 1.8V
    238c:	movw	r3, #16480	; 0x4060
    2390:	movs	r2, #48	; 0x30
    2392:	movs	r1, #10
    2394:	ldr	r0, [pc, #396]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    2396:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        if (!r) return false;
    239a:	cbnz	r0, 23a2 <adc_enable(unsigned int, unsigned long)+0xaa>
    239c:	movs	r0, #0
    239e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        i2c.write16(addr,CHIP_LINREG_CTRL, 0x006C);  // VDDA & VDDIO both over 3.1V
    23a2:	movs	r3, #108	; 0x6c
    23a4:	movs	r2, #38	; 0x26
    23a6:	movs	r1, #10
    23a8:	ldr	r0, [pc, #376]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    23aa:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_REF_CTRL, 0x01F2); // VAG=1.575, normal ramp, +12.5% bias current
    23ae:	mov.w	r3, #498	; 0x1f2
    23b2:	movs	r2, #40	; 0x28
    23b4:	movs	r1, #10
    23b6:	ldr	r0, [pc, #364]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    23b8:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_LINE_OUT_CTRL, 0x0F22); // LO_VAGCNTRL=1.65V, OUT_CURRENT=0.54mA
    23bc:	movw	r3, #3874	; 0xf22
    23c0:	movs	r2, #44	; 0x2c
    23c2:	movs	r1, #10
    23c4:	ldr	r0, [pc, #348]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    23c6:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_SHORT_CTRL, 0x4446);  // allow up to 125mA
    23ca:	movw	r3, #17478	; 0x4446
    23ce:	movs	r2, #60	; 0x3c
    23d0:	movs	r1, #10
    23d2:	ldr	r0, [pc, #336]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    23d4:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_ANA_CTRL, 0x0137);  // enable zero cross detectors
    23d8:	movw	r3, #311	; 0x137
    23dc:	movs	r2, #36	; 0x24
    23de:	movs	r1, #10
    23e0:	ldr	r0, [pc, #320]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    23e2:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
            
        if (extMCLK > 0) {
    23e6:	cbz	r5, 244c <adc_enable(unsigned int, unsigned long)+0x154>
            //SGTL is I2S Master
            //Datasheet Pg. 14: Using the PLL - Asynchronous SYS_MCLK input
            if (extMCLK > 17000000) {
    23e8:	ldr	r3, [pc, #324]	; (2530 <adc_enable(unsigned int, unsigned long)+0x238>)
                i2c.write16(addr,CHIP_CLK_TOP_CTRL, 1);
            } else {
                i2c.write16(addr,CHIP_CLK_TOP_CTRL, 0);
    23ea:	ldr	r0, [pc, #312]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
        i2c.write16(addr,CHIP_ANA_CTRL, 0x0137);  // enable zero cross detectors
            
        if (extMCLK > 0) {
            //SGTL is I2S Master
            //Datasheet Pg. 14: Using the PLL - Asynchronous SYS_MCLK input
            if (extMCLK > 17000000) {
    23ec:	cmp	r5, r3
                i2c.write16(addr,CHIP_CLK_TOP_CTRL, 1);
    23ee:	ite	hi
    23f0:	movhi	r3, #1
            } else {
                i2c.write16(addr,CHIP_CLK_TOP_CTRL, 0);
    23f2:	movls	r3, #0
    23f4:	movs	r2, #52	; 0x34
    23f6:	movs	r1, #10
    23f8:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
            }

            uint32_t int_divisor = (pllFreq / extMCLK) & 0x1f;
    23fc:	udiv	r3, r7, r5
            uint32_t frac_divisor = (uint32_t)((((float)pllFreq / extMCLK) - int_divisor) * 2048.0f) & 0x7ff;
            
            i2c.write16(addr,CHIP_PLL_CTRL, (int_divisor << 11) | frac_divisor);		
    2400:	vmov	s15, r7
    2404:	vcvt.f32.u32	s14, s15
    2408:	vmov	s15, r5
    240c:	vcvt.f32.u32	s13, s15
                i2c.write16(addr,CHIP_CLK_TOP_CTRL, 1);
            } else {
                i2c.write16(addr,CHIP_CLK_TOP_CTRL, 0);
            }

            uint32_t int_divisor = (pllFreq / extMCLK) & 0x1f;
    2410:	and.w	r3, r3, #31
            uint32_t frac_divisor = (uint32_t)((((float)pllFreq / extMCLK) - int_divisor) * 2048.0f) & 0x7ff;
            
            i2c.write16(addr,CHIP_PLL_CTRL, (int_divisor << 11) | frac_divisor);		
    2414:	vdiv.f32	s15, s14, s13
    2418:	movs	r1, #10
    241a:	ldr	r0, [pc, #264]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    241c:	vmov	s14, r3
    2420:	vcvt.f32.s32	s14, s14
    2424:	vsub.f32	s15, s15, s14
    2428:	vldr	s14, [pc, #264]	; 2534 <adc_enable(unsigned int, unsigned long)+0x23c>
    242c:	vmul.f32	s15, s15, s14
    2430:	vcvt.u32.f32	s15, s15
    2434:	vmov	r2, s15
    2438:	ubfx	r2, r2, #0, #11
    243c:	orr.w	r3, r2, r3, lsl #11
    2440:	movs	r2, #50	; 0x32
    2442:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
            i2c.write16(addr,CHIP_ANA_POWER, 0x40FF | (1<<10) | (1<<8) ); // power up: lineout, hp, adc, dac, PLL_POWERUP, VCOAMP_POWERUP
    2446:	movw	r3, #17919	; 0x45ff
    244a:	b.n	2450 <adc_enable(unsigned int, unsigned long)+0x158>
        } else {
            //SGTL is I2S Slave
            i2c.write16(addr,CHIP_ANA_POWER, 0x40FF); // power up: lineout, hp, adc, dac
    244c:	movw	r3, #16639	; 0x40ff
    2450:	movs	r2, #48	; 0x30
    2452:	movs	r1, #10
    2454:	ldr	r0, [pc, #204]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    2456:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        }

        i2c.write16(addr,CHIP_DIG_POWER, 0x0073); // power up all digital stuff
    245a:	movs	r3, #115	; 0x73
    245c:	movs	r2, #2
    245e:	movs	r1, #10
    2460:	ldr	r0, [pc, #192]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    2462:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        delay(400);
    2466:	mov.w	r0, #400	; 0x190
    246a:	bl	9578 <delay>
        i2c.write16(addr,CHIP_LINE_OUT_VOL, 0x1D1D); // default approx 1.3 volts peak-to-peak
    246e:	movw	r3, #7453	; 0x1d1d
    2472:	movs	r2, #46	; 0x2e
    2474:	movs	r1, #10
    2476:	ldr	r0, [pc, #172]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    2478:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        
        if (extMCLK > 0) { 
    247c:	cbz	r5, 248e <adc_enable(unsigned int, unsigned long)+0x196>
            //SGTL is I2S Master
            i2c.write16(addr,CHIP_CLK_CTRL, 0x0004 | 0x03);  // 44.1 kHz, 256*Fs, use PLL
    247e:	movs	r3, #7
    2480:	movs	r2, #4
    2482:	movs	r1, #10
    2484:	ldr	r0, [pc, #156]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    2486:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
            i2c.write16(addr,CHIP_I2S_CTRL, 0x0030 | (1<<7)); // SCLK=64*Fs, 16bit, I2S format
    248a:	movs	r3, #176	; 0xb0
    248c:	b.n	249c <adc_enable(unsigned int, unsigned long)+0x1a4>
        } else {
            //SGTL is I2S Slave
            i2c.write16(addr,CHIP_CLK_CTRL, 0x0004);  // 44.1 kHz, 256*Fs
    248e:	movs	r3, #4
    2490:	mov	r2, r3
    2492:	movs	r1, #10
    2494:	ldr	r0, [pc, #140]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    2496:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
            i2c.write16(addr,CHIP_I2S_CTRL, 0x0030); // SCLK=64*Fs, 16bit, I2S format
    249a:	movs	r3, #48	; 0x30
    249c:	movs	r2, #6
    249e:	movs	r1, #10
    24a0:	ldr	r0, [pc, #128]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    24a2:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        }

        // default signal routing is ok?
        i2c.write16(addr,CHIP_SSS_CTRL, 0x0010); // ADC->I2S, I2S->DAC
    24a6:	movs	r2, #10
    24a8:	mov	r1, r2
    24aa:	movs	r3, #16
    24ac:	ldr	r0, [pc, #116]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    24ae:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_ADCDAC_CTRL, 0x0000); // disable dac mute
    24b2:	movs	r3, #0
    24b4:	movs	r2, #14
    24b6:	movs	r1, #10
    24b8:	ldr	r0, [pc, #104]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    24ba:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_DAC_VOL, 0x3C3C); // digital gain, 0dB
    24be:	movw	r3, #15420	; 0x3c3c
    24c2:	movs	r2, #16
    24c4:	movs	r1, #10
    24c6:	ldr	r0, [pc, #92]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    24c8:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_ANA_HP_CTRL, 0x7F7F); // set volume (lowest level)
    24cc:	movw	r3, #32639	; 0x7f7f
    24d0:	movs	r2, #34	; 0x22
    24d2:	movs	r1, #10
    24d4:	ldr	r0, [pc, #76]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    24d6:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_ANA_CTRL, 0x0036);  // enable zero cross detectors
    24da:	movs	r3, #54	; 0x36
    24dc:	movs	r2, #36	; 0x24
    24de:	movs	r1, #10
    24e0:	ldr	r0, [pc, #64]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    24e2:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        uint16_t ana_ctrl=0x0036;

        return i2c.write16(addr,0x002A, 0x0173) // mic preamp gain = +40dB
    24e6:	movw	r3, #371	; 0x173
    24ea:	movs	r2, #42	; 0x2a
    24ec:	movs	r1, #10
    24ee:	ldr	r0, [pc, #52]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    24f0:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
                && i2c.write16(addr,0x0020, 0x088)     // input gain +12dB (is this enough?)
                && i2c.write16(addr,0x0024, ana_ctrl & ~(1<<2)); // enable mic
    24f4:	cmp	r0, #0
    24f6:	beq.w	239c <adc_enable(unsigned int, unsigned long)+0xa4>
        i2c.write16(addr,CHIP_ANA_HP_CTRL, 0x7F7F); // set volume (lowest level)
        i2c.write16(addr,CHIP_ANA_CTRL, 0x0036);  // enable zero cross detectors
        uint16_t ana_ctrl=0x0036;

        return i2c.write16(addr,0x002A, 0x0173) // mic preamp gain = +40dB
                && i2c.write16(addr,0x0020, 0x088)     // input gain +12dB (is this enough?)
    24fa:	movs	r3, #136	; 0x88
    24fc:	movs	r2, #32
    24fe:	movs	r1, #10
    2500:	ldr	r0, [pc, #32]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    2502:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
    2506:	cmp	r0, #0
    2508:	beq.w	239c <adc_enable(unsigned int, unsigned long)+0xa4>
                && i2c.write16(addr,0x0024, ana_ctrl & ~(1<<2)); // enable mic
    250c:	movs	r3, #50	; 0x32
    250e:	movs	r2, #36	; 0x24
    2510:	movs	r1, #10
    2512:	ldr	r0, [pc, #16]	; (2524 <adc_enable(unsigned int, unsigned long)+0x22c>)
    2514:	bl	22a8 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
    2518:	adds	r0, #0
    251a:	it	ne
    251c:	movne	r0, #1
    251e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2522:	nop
    2524:	.word	0x2001a1bc
    2528:	.word	0x0001290d
    252c:	.word	0x1fff1348
    2530:	.word	0x01036640
    2534:	.word	0x45000000

00002538 <_GLOBAL__sub_I_gain>:
class i2c_class
{ TwoWire *wire;
    public:

    i2c_class(TwoWire *wire) 
    {   this->wire = wire;
    2538:	ldr	r3, [pc, #8]	; (2544 <_GLOBAL__sub_I_gain+0xc>)
    253a:	ldr	r0, [pc, #12]	; (2548 <_GLOBAL__sub_I_gain+0x10>)
    253c:	str	r0, [r3, #0]
        wire->begin();
    253e:	b.w	2690 <TwoWire::begin()>
    2542:	nop
    2544:	.word	0x2001a1bc
    2548:	.word	0x1fff1080

0000254c <getTeensySerial()>:

#else
  uint32_t getTeensySerial(void) 
  {
    uint32_t num = 0;
    __disable_irq();
    254c:	cpsid	i
      FTFL_FSTAT = FTFL_FSTAT_CCIF;
      while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
      num = *(uint32_t *)&FTFL_FCCOB7;
    #elif defined(HAS_KINETIS_FLASH_FTFE)
      kinetis_hsrun_disable();
      FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    254e:	ldr	r3, [pc, #32]	; (2570 <getTeensySerial()+0x24>)
      *(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    2550:	ldr	r1, [pc, #32]	; (2574 <getTeensySerial()+0x28>)
      FTFL_FSTAT = FTFL_FSTAT_CCIF;
      while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
      num = *(uint32_t *)&FTFL_FCCOB7;
    #elif defined(HAS_KINETIS_FLASH_FTFE)
      kinetis_hsrun_disable();
      FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    2552:	movs	r2, #112	; 0x70
    2554:	strb	r2, [r3, #0]
      *(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    2556:	ldr	r2, [pc, #32]	; (2578 <getTeensySerial()+0x2c>)
    2558:	str	r1, [r2, #0]
      FTFL_FSTAT = FTFL_FSTAT_CCIF;
    255a:	movs	r2, #128	; 0x80
    255c:	strb	r2, [r3, #0]
      while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    255e:	ldrb	r2, [r3, #0]
    2560:	lsls	r2, r2, #24
    2562:	bpl.n	255e <getTeensySerial()+0x12>
      num = *(uint32_t *)&FTFL_FCCOBB;
    2564:	ldr	r3, [pc, #20]	; (257c <getTeensySerial()+0x30>)
    2566:	ldr	r0, [r3, #0]
      kinetis_hsrun_enable();
    #endif
    __enable_irq();
    2568:	cpsie	i
    return num & 0xFFFFFF;
  }
    256a:	bic.w	r0, r0, #4278190080	; 0xff000000
    256e:	bx	lr
    2570:	.word	0x40020000
    2574:	.word	0x41070000
    2578:	.word	0x40020004
    257c:	.word	0x4002000c

00002580 <_write>:
  int _write(int file, const void *buf, size_t len) {
    // https://forum.pjrc.com/threads/28473-Quick-Guide-Using-printf()-on-Teensy-ARM
    Print *out;
  
    // Send both stdout and stderr to stdPrint
    if (file == stdout->_file || file == stderr->_file) {
    2580:	ldr	r3, [pc, #48]	; (25b4 <_write+0x34>)
    2582:	ldr	r3, [r3, #0]
#include "usb_serial.h"
Print *stdPrint = &Serial;

extern "C"
{
  int _write(int file, const void *buf, size_t len) {
    2584:	push	{r4}
    // https://forum.pjrc.com/threads/28473-Quick-Guide-Using-printf()-on-Teensy-ARM
    Print *out;
  
    // Send both stdout and stderr to stdPrint
    if (file == stdout->_file || file == stderr->_file) {
    2586:	ldr	r4, [r3, #8]
    2588:	ldrsh.w	r4, [r4, #14]
    258c:	cmp	r4, r0
    258e:	beq.n	259a <_write+0x1a>
    2590:	ldr	r3, [r3, #12]
    2592:	ldrsh.w	r3, [r3, #14]
    2596:	cmp	r0, r3
    2598:	bne.n	259e <_write+0x1e>
      out = stdPrint;
    259a:	ldr	r3, [pc, #28]	; (25b8 <_write+0x38>)
    259c:	ldr	r0, [r3, #0]
    } else {
      out = (Print *)file;
    }
  
    if (out == nullptr) {
    259e:	cbz	r0, 25aa <_write+0x2a>
      return len;
    }
  
    // Don't check for len == 0 for returning early, in case there's side effects
    return out->write((const uint8_t *)buf, len);
    25a0:	ldr	r3, [r0, #0]
  }
    25a2:	ldr.w	r4, [sp], #4
    if (out == nullptr) {
      return len;
    }
  
    // Don't check for len == 0 for returning early, in case there's side effects
    return out->write((const uint8_t *)buf, len);
    25a6:	ldr	r3, [r3, #4]
    25a8:	bx	r3
  }
    25aa:	mov	r0, r2
    25ac:	ldr.w	r4, [sp], #4
    25b0:	bx	lr
    25b2:	nop
    25b4:	.word	0x1fff1828
    25b8:	.word	0x1fff0f40

000025bc <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    25bc:	ldrb.w	r2, [r0, #161]	; 0xa1
    25c0:	ldrb.w	r0, [r0, #160]	; 0xa0
	}
    25c4:	subs	r0, r2, r0
    25c6:	bx	lr

000025c8 <TwoWire::read()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    25c8:	ldrb.w	r3, [r0, #160]	; 0xa0
    25cc:	ldrb.w	r2, [r0, #161]	; 0xa1
    25d0:	cmp	r2, r3
		return rxBuffer[rxBufferIndex++];
    25d2:	itttt	hi
    25d4:	addhi	r2, r3, #1
    25d6:	addhi	r3, r3, r0
    25d8:	strbhi.w	r2, [r0, #160]	; 0xa0
    25dc:	ldrbhi	r0, [r3, #24]
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    25de:	it	ls
    25e0:	movls.w	r0, #4294967295
		return rxBuffer[rxBufferIndex++];
	}
    25e4:	bx	lr

000025e6 <TwoWire::peek()>:
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    25e6:	ldrb.w	r3, [r0, #160]	; 0xa0
    25ea:	ldrb.w	r2, [r0, #161]	; 0xa1
    25ee:	cmp	r2, r3
		return rxBuffer[rxBufferIndex];
    25f0:	itte	hi
    25f2:	addhi	r3, r3, r0
    25f4:	ldrbhi	r0, [r3, #24]
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    25f6:	movls.w	r0, #4294967295
		return rxBuffer[rxBufferIndex];
	}
    25fa:	bx	lr

000025fc <TwoWire::flush()>:
	virtual void flush(void) {
    25fc:	bx	lr

000025fe <TwoWire::write(unsigned char)>:
//  I2C0_C2      // I2C Control Register 2
//  I2C0_FLT     // I2C Programmable Input Glitch Filter register

size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
    25fe:	ldrh.w	r3, [r0, #302]	; 0x12e
    2602:	cbz	r3, 2610 <TwoWire::write(unsigned char)+0x12>
		if (txBufferLength >= BUFFER_LENGTH+1) {
    2604:	ldrb.w	r3, [r0, #301]	; 0x12d
    2608:	cmp	r3, #136	; 0x88
    260a:	bls.n	2614 <TwoWire::write(unsigned char)+0x16>
	// format warnings are too pedantic - disable until newer toolchain offers better...
	// https://forum.pjrc.com/threads/62473?p=256873&viewfull=1#post256873
	int printf(const char *format, ...) /*__attribute__ ((format (printf, 2, 3)))*/;
	int printf(const __FlashStringHelper *format, ...);
  protected:
	void setWriteError(int err = 1) { write_error = err; }
    260c:	movs	r3, #1
    260e:	strb	r3, [r0, #4]
			setWriteError();
			return 0;
    2610:	movs	r0, #0
    2612:	bx	lr
		}
		txBuffer[txBufferLength++] = data;
    2614:	adds	r2, r3, #1
    2616:	add	r3, r0
    2618:	strb.w	r2, [r0, #301]	; 0x12d
    261c:	strb.w	r1, [r3, #163]	; 0xa3
		return 1;
    2620:	movs	r0, #1
    2622:	bx	lr

00002624 <TwoWire::write(unsigned char const*, unsigned int)>:
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    2624:	push	{r3, r4, r5, lr}
    2626:	mov	r4, r0
	if (transmitting || slave_mode) {
    2628:	ldrh.w	r0, [r0, #302]	; 0x12e
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    262c:	mov	r5, r2
	if (transmitting || slave_mode) {
    262e:	cbz	r0, 265a <TwoWire::write(unsigned char const*, unsigned int)+0x36>
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
    2630:	ldrb.w	r3, [r4, #301]	; 0x12d
    2634:	rsb	r2, r3, #137	; 0x89
		if (quantity > avail) {
    2638:	cmp	r5, r2
    263a:	ittt	hi
    263c:	movhi	r0, #1
    263e:	movhi	r5, r2
    2640:	strbhi	r0, [r4, #4]
			quantity = avail;
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
    2642:	add.w	r0, r4, #163	; 0xa3
    2646:	add	r0, r3
    2648:	mov	r2, r5
    264a:	bl	8f3c <memcpy>
		txBufferLength += quantity;
    264e:	ldrb.w	r3, [r4, #301]	; 0x12d
    2652:	add	r3, r5
    2654:	strb.w	r3, [r4, #301]	; 0x12d
    2658:	mov	r0, r5
		return quantity;
	}
	return 0;
}
    265a:	pop	{r3, r4, r5, pc}

0000265c <TwoWire::setClock(unsigned long)>:
	//pinMode(4, OUTPUT);
}

void TwoWire::setClock(uint32_t frequency)
{
	if (!(hardware.clock_gate_register & hardware.clock_gate_mask)) return;
    265c:	ldr	r3, [r0, #20]
    265e:	ldr	r2, [r3, #0]
    2660:	ldr	r3, [r3, #4]
    2662:	ldr	r2, [r2, #0]
    2664:	tst	r2, r3
    2666:	beq.n	2686 <TwoWire::setClock(unsigned long)+0x2a>
	} else {
		port().F = I2C_F_DIV56; // 0.96 MHz
	}
	port().FLT = 4;
#elif F_BUS == 48000000
	if (frequency < 400000) {
    2668:	ldr	r3, [pc, #28]	; (2688 <TwoWire::setClock(unsigned long)+0x2c>)
    266a:	cmp	r1, r3
    266c:	ldr	r3, [r0, #16]
    266e:	bhi.n	2674 <TwoWire::setClock(unsigned long)+0x18>
		port().F = 0x27;	// 100 kHz
    2670:	movs	r2, #39	; 0x27
    2672:	b.n	267e <TwoWire::setClock(unsigned long)+0x22>
	} else if (frequency < 1000000) {
    2674:	ldr	r2, [pc, #20]	; (268c <TwoWire::setClock(unsigned long)+0x30>)
    2676:	cmp	r1, r2
		port().F = 0x1A; // 400 kHz
    2678:	ite	ls
    267a:	movls	r2, #26
	} else {
		port().F = 0x0D; // 1 MHz
    267c:	movhi	r2, #13
    267e:	strb	r2, [r3, #1]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    2680:	ldr	r3, [r0, #16]
	}
	port().FLT = 4;
    2682:	movs	r2, #4
    2684:	strb	r2, [r3, #6]
    2686:	bx	lr
    2688:	.word	0x00061a7f
    268c:	.word	0x000f423f

00002690 <TwoWire::begin()>:

void sda_rising_isr0(void);
void sda_rising_isr1(void);

void TwoWire::begin(void)
{
    2690:	push	{r4, r5, r6, lr}
	//serial_begin(BAUD2DIV(115200));
	//serial_print("\nWire Begin\n");

	rxBufferIndex = 0;
    2692:	movs	r3, #0
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    2694:	ldr	r5, [r0, #20]
void TwoWire::begin(void)
{
	//serial_begin(BAUD2DIV(115200));
	//serial_print("\nWire Begin\n");

	rxBufferIndex = 0;
    2696:	strb.w	r3, [r0, #160]	; 0xa0
	rxBufferLength = 0;
    269a:	strb.w	r3, [r0, #161]	; 0xa1
	txBufferIndex = 0;
    269e:	strb.w	r3, [r0, #300]	; 0x12c
	txBufferLength = 0;
    26a2:	strb.w	r3, [r0, #301]	; 0x12d
	transmitting = 0;
    26a6:	strb.w	r3, [r0, #302]	; 0x12e
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
    26aa:	strb.w	r3, [r0, #303]	; 0x12f
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    26ae:	ldr	r1, [r5, #0]
    26b0:	ldr	r2, [r5, #4]
    26b2:	ldr	r6, [r1, #0]
	rxBufferIndex = 0;
	rxBufferLength = 0;
	txBufferIndex = 0;
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
    26b4:	str.w	r3, [r0, #308]	; 0x134
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    26b8:	orrs	r2, r6
	rxBufferLength = 0;
	txBufferIndex = 0;
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
    26ba:	str.w	r3, [r0, #312]	; 0x138
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    26be:	str	r2, [r1, #0]
    26c0:	ldr	r2, [r0, #16]
	port().C1 = 0;
    26c2:	strb	r3, [r2, #2]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    26c4:	ldr	r6, [r0, #20]
    26c6:	ldrb.w	r1, [r0, #305]	; 0x131
    26ca:	ldr	r2, [pc, #72]	; (2714 <TwoWire::begin()+0x84>)
    26cc:	add	r1, r6
    26ce:	ldrb	r5, [r1, #8]
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    26d0:	ldrb	r3, [r1, #13]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    26d2:	add.w	r5, r2, r5, lsl #3
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    26d6:	lsls	r3, r3, #8
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    26d8:	ldr	r5, [r5, #4]
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    26da:	and.w	r3, r3, #1792	; 0x700
    26de:	orr.w	r3, r3, #100	; 0x64
    26e2:	str	r3, [r5, #0]
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    26e4:	ldrb.w	r3, [r0, #306]	; 0x132
    26e8:	add	r3, r6
    26ea:	ldrb	r1, [r3, #18]
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    26ec:	ldrb	r3, [r3, #23]
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    26ee:	add.w	r2, r2, r1, lsl #3
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    26f2:	lsls	r3, r3, #8
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    26f4:	ldr	r2, [r2, #4]
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	setClock(100000);
    26f6:	ldr	r1, [pc, #32]	; (2718 <TwoWire::begin()+0x88>)
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    26f8:	and.w	r3, r3, #1792	; 0x700
    26fc:	orr.w	r3, r3, #100	; 0x64
    2700:	str	r3, [r2, #0]
	setClock(100000);
    2702:	bl	265c <TwoWire::setClock(unsigned long)>
    2706:	ldr	r3, [r0, #16]
	port().C2 = I2C_C2_HDRS;
    2708:	movs	r2, #32
    270a:	strb	r2, [r3, #5]
    270c:	ldr	r3, [r0, #16]
	port().C1 = I2C_C1_IICEN;
    270e:	movs	r2, #128	; 0x80
    2710:	strb	r2, [r3, #2]
    2712:	pop	{r4, r5, r6, pc}
    2714:	.word	0x00012e88
    2718:	.word	0x000186a0

0000271c <TwoWire::isr()>:
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    271c:	push	{r3, r4, r5, lr}
    271e:	ldr	r2, [r0, #16]
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
    2720:	ldrb	r5, [r2, #3]
    2722:	uxtb	r5, r5
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    2724:	tst.w	r5, #16
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    2728:	mov	r4, r0
    272a:	and.w	r3, r5, #64	; 0x40
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    272e:	bne.n	2738 <TwoWire::isr()+0x1c>


		}
		if (!(status & I2C_S_IAAS)) return;
	}
	if (status & I2C_S_IAAS) {
    2730:	and.w	r1, r3, #255	; 0xff
    2734:	cbnz	r3, 2742 <TwoWire::isr()+0x26>
    2736:	b.n	2790 <TwoWire::isr()+0x74>

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
		// Arbitration Lost
		port().S = I2C_S_ARBL;
    2738:	movs	r1, #16
    273a:	strb	r1, [r2, #3]
		if (receiving && rxBufferLength > 0) {
			// TODO: does this detect the STOP condition in slave receive mode?


		}
		if (!(status & I2C_S_IAAS)) return;
    273c:	cmp	r3, #0
    273e:	bne.n	2730 <TwoWire::isr()+0x14>
    2740:	pop	{r3, r4, r5, pc}
	}
	if (status & I2C_S_IAAS) {
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
    2742:	and.w	r5, r5, #4
    2746:	and.w	r2, r5, #255	; 0xff
    274a:	ldr	r3, [pc, #224]	; (282c <TwoWire::isr()+0x110>)
    274c:	cbz	r5, 2784 <TwoWire::isr()+0x68>
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    274e:	movs	r2, #0
    2750:	strb	r2, [r3, #0]
			txBufferLength = 0;
			if (user_onRequest != NULL) {
    2752:	ldr.w	r3, [r4, #308]	; 0x134
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
			txBufferLength = 0;
    2756:	strb.w	r2, [r4, #301]	; 0x12d
			if (user_onRequest != NULL) {
    275a:	cbz	r3, 275e <TwoWire::isr()+0x42>
				user_onRequest();
    275c:	blx	r3
			}
			if (txBufferLength == 0) {
    275e:	ldrb.w	r3, [r4, #301]	; 0x12d
    2762:	cbnz	r3, 276e <TwoWire::isr()+0x52>
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    2764:	movs	r2, #1
    2766:	strb.w	r2, [r4, #301]	; 0x12d
				txBuffer[0] = 0;
    276a:	strb.w	r3, [r4, #163]	; 0xa3
    276e:	ldr	r3, [r4, #16]
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    2770:	movs	r2, #208	; 0xd0
    2772:	strb	r2, [r3, #2]
    2774:	ldr	r3, [r4, #16]
			port().D = txBuffer[0];
    2776:	ldrb.w	r2, [r4, #163]	; 0xa3
    277a:	strb	r2, [r3, #4]
			txBufferIndex = 1;
    277c:	movs	r3, #1
    277e:	strb.w	r3, [r4, #300]	; 0x12c
    2782:	b.n	2822 <TwoWire::isr()+0x106>
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    2784:	movs	r1, #1
    2786:	strb	r1, [r3, #0]
			rxBufferLength = 0;
    2788:	strb.w	r2, [r4, #161]	; 0xa1
    278c:	ldr	r3, [r4, #16]
    278e:	b.n	27ee <TwoWire::isr()+0xd2>
    2790:	ldr	r2, [r4, #16]
		}
		port().S = I2C_S_IICIF;
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
    2792:	ldrb	r3, [r2, #6]
    2794:	uxtb	r3, r3
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
    2796:	and.w	r0, r3, #96	; 0x60
    279a:	cmp	r0, #96	; 0x60
    279c:	bne.n	27b4 <TwoWire::isr()+0x98>
		port().FLT = c1 & ~I2C_FLT_STOPIE;
    279e:	and.w	r3, r3, #223	; 0xdf
    27a2:	strb	r3, [r2, #6]
		if (user_onReceive != NULL) {
    27a4:	ldr.w	r3, [r4, #312]	; 0x138
    27a8:	cbz	r3, 27b4 <TwoWire::isr()+0x98>
			rxBufferIndex = 0;
    27aa:	strb.w	r1, [r4, #160]	; 0xa0
			user_onReceive(rxBufferLength);
    27ae:	ldrb.w	r0, [r4, #161]	; 0xa1
    27b2:	blx	r3
    27b4:	ldr	r3, [r4, #16]
		}
	}
	#endif
	c1 = port().C1;
    27b6:	ldrb	r2, [r3, #2]
	if (c1 & I2C_C1_TX) {
    27b8:	and.w	r2, r2, #16
    27bc:	and.w	r1, r2, #255	; 0xff
    27c0:	cbz	r2, 27f8 <TwoWire::isr()+0xdc>
		// Continue Slave Transmit
		//serial_print("t");
		if ((status & I2C_S_RXAK) == 0) {
    27c2:	ands.w	r5, r5, #1
    27c6:	bne.n	27ee <TwoWire::isr()+0xd2>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
    27c8:	ldrb.w	r2, [r4, #300]	; 0x12c
    27cc:	ldrb.w	r1, [r4, #301]	; 0x12d
    27d0:	cmp	r1, r2
				port().D = txBuffer[txBufferIndex++];
    27d2:	itttt	hi
    27d4:	addhi	r1, r2, #1
    27d6:	addhi	r2, r2, r4
    27d8:	strbhi.w	r1, [r4, #300]	; 0x12c
    27dc:	ldrbhi.w	r2, [r2, #163]	; 0xa3
    27e0:	ite	hi
    27e2:	strbhi	r2, [r3, #4]
			} else {
				port().D = 0;
    27e4:	strbls	r5, [r3, #4]
    27e6:	ldr	r3, [r4, #16]
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    27e8:	movs	r2, #208	; 0xd0
    27ea:	strb	r2, [r3, #2]
    27ec:	b.n	2822 <TwoWire::isr()+0x106>
		} else {
			//serial_print("*");
			// Master did not ACK previous byte
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    27ee:	movs	r2, #192	; 0xc0
    27f0:	strb	r2, [r3, #2]
    27f2:	ldr	r3, [r4, #16]
			data = port().D;
    27f4:	ldrb	r3, [r3, #4]
    27f6:	b.n	2822 <TwoWire::isr()+0x106>
		}
	} else {
		// Continue Slave Receive
		irqcount = 0;
    27f8:	strb.w	r1, [r4, #304]	; 0x130
		#ifdef WIRE_HAS_STOP_INTERRUPT
		port().FLT |= I2C_FLT_STOPIE;
    27fc:	ldrb	r2, [r3, #6]
    27fe:	orr.w	r2, r2, #32
    2802:	strb	r2, [r3, #6]
    2804:	ldr	r3, [r4, #16]
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    2806:	ldrb	r2, [r3, #4]
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    2808:	ldrb.w	r3, [r4, #161]	; 0xa1
    280c:	cmp	r3, #135	; 0x87
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    280e:	uxtb	r2, r2
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    2810:	bhi.n	2822 <TwoWire::isr()+0x106>
    2812:	ldr	r1, [pc, #24]	; (282c <TwoWire::isr()+0x110>)
    2814:	ldrb	r1, [r1, #0]
    2816:	cbz	r1, 2822 <TwoWire::isr()+0x106>
			rxBuffer[rxBufferLength++] = data;
    2818:	adds	r1, r3, #1
    281a:	add	r3, r4
    281c:	strb.w	r1, [r4, #161]	; 0xa1
    2820:	strb	r2, [r3, #24]
    2822:	ldr	r3, [r4, #16]
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    2824:	movs	r2, #2
    2826:	strb	r2, [r3, #3]
    2828:	pop	{r3, r4, r5, pc}
    282a:	nop
    282c:	.word	0x2001a1c4

00002830 <TwoWire::wait_idle()>:
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    2830:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2834:	ldr	r5, [pc, #208]	; (2908 <L_1220_delayMicroseconds+0x20>)
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    2836:	ldr	r7, [pc, #212]	; (290c <L_1220_delayMicroseconds+0x24>)
    2838:	ldr	r3, [r5, #0]
    283a:	str	r3, [sp, #0]
	return ret;
    283c:	ldr.w	r8, [sp]
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    2840:	mov	r4, r0
	bool reset=false;
    2842:	movs	r1, #0
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    2844:	movs	r6, #160	; 0xa0
    2846:	ldr	r2, [r4, #16]
	uint8_t i2c_status(void) {
		return port().S;
    2848:	ldrb	r3, [r2, #3]
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    284a:	lsls	r3, r3, #26
    284c:	bpl.n	2900 <L_1220_delayMicroseconds+0x18>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    284e:	ldr	r3, [r5, #0]
    2850:	str	r3, [sp, #4]
	return ret;
    2852:	ldr	r3, [sp, #4]
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
    2854:	rsb	r3, r8, r3
#if 1
		if (waited > 15 && !reset) {
    2858:	cmp	r3, #15
    285a:	bls.n	2846 <TwoWire::wait_idle()+0x16>
    285c:	cmp	r1, #0
    285e:	bne.n	28f0 <L_1220_delayMicroseconds+0x8>
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
    2860:	ldr	r2, [r4, #20]
    2862:	ldrb.w	r3, [r4, #305]	; 0x131
    2866:	add	r3, r2
			pinMode(sda_pin, INPUT_DISABLE);
    2868:	movs	r1, #5
    286a:	ldrb	r0, [r3, #8]
    286c:	bl	94d8 <pinMode>
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    2870:	ldr	r2, [r4, #20]
    2872:	ldrb.w	r3, [r4, #305]	; 0x131
    2876:	add	r3, r2
			pinMode(scl_pin, OUTPUT);
    2878:	movs	r1, #1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    287a:	ldrb.w	sl, [r3, #18]
			pinMode(scl_pin, OUTPUT);
    287e:	mov	r0, sl
    2880:	bl	94d8 <pinMode>
    2884:	mov.w	r9, #9
			for (int i=0; i < 9; i++) {
				digitalWrite(scl_pin, LOW);
    2888:	movs	r1, #0
    288a:	mov	r0, sl
    288c:	bl	9498 <digitalWrite>
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    2890:	mov	r3, r6

00002892 <L_1161_delayMicroseconds>:
    2892:	subs	r3, #1
    2894:	bne.n	2892 <L_1161_delayMicroseconds>
				delayMicroseconds(5);
				digitalWrite(scl_pin, HIGH);
    2896:	movs	r1, #1
    2898:	mov	r0, sl
    289a:	bl	9498 <digitalWrite>
    289e:	mov	r3, r6

000028a0 <L_1175_delayMicroseconds>:
    28a0:	subs	r3, #1
    28a2:	bne.n	28a0 <L_1175_delayMicroseconds>
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
			pinMode(scl_pin, OUTPUT);
			for (int i=0; i < 9; i++) {
    28a4:	subs.w	r9, r9, #1
    28a8:	bne.n	2888 <TwoWire::wait_idle()+0x58>
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    28aa:	ldr	r0, [r4, #20]
    28ac:	ldrb.w	r2, [r4, #305]	; 0x131
    28b0:	add	r2, r0
    28b2:	ldrb	r1, [r2, #8]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    28b4:	ldrb	r3, [r2, #13]
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    28b6:	add.w	r1, r7, r1, lsl #3
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    28ba:	lsls	r3, r3, #8
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    28bc:	ldr	r1, [r1, #4]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    28be:	and.w	r3, r3, #1792	; 0x700
    28c2:	orr.w	r3, r3, #100	; 0x64
    28c6:	str	r3, [r1, #0]
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    28c8:	ldrb.w	r3, [r4, #306]	; 0x132
    28cc:	add	r3, r0
    28ce:	ldrb	r2, [r3, #18]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    28d0:	ldrb	r3, [r3, #23]
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    28d2:	add.w	r2, r7, r2, lsl #3
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    28d6:	lsls	r3, r3, #8
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    28d8:	ldr	r2, [r2, #4]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    28da:	and.w	r3, r3, #1792	; 0x700
    28de:	orr.w	r3, r3, #100	; 0x64
    28e2:	str	r3, [r2, #0]
    28e4:	mov.w	r3, #320	; 0x140

000028e8 <L_1220_delayMicroseconds>:
    28e8:	subs	r3, #1
    28ea:	bne.n	28e8 <L_1220_delayMicroseconds>
	while (i2c_status() & I2C_S_BUSY) {
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
    28ec:	movs	r1, #1
    28ee:	b.n	2846 <TwoWire::wait_idle()+0x16>
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			delayMicroseconds(10);
			continue;
		}
#endif
		if (waited > 16) {
    28f0:	cmp	r3, #16
    28f2:	beq.n	2846 <TwoWire::wait_idle()+0x16>
			// bus stuck busy too long
			port().C1 = 0;
    28f4:	movs	r0, #0
    28f6:	strb	r0, [r2, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    28f8:	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    28fa:	movs	r2, #128	; 0x80
    28fc:	strb	r2, [r3, #2]
			//Serial.println("abort");
			//return 4; // timeout waiting for bus
			return false;
    28fe:	b.n	2902 <L_1220_delayMicroseconds+0x1a>
		}
	}
	return true;
    2900:	movs	r0, #1
}
    2902:	add	sp, #8
    2904:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2908:	.word	0x2001a6fc
    290c:	.word	0x00012e88

00002910 <TwoWire::endTransmission(unsigned char)>:

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    2910:	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    2914:	ldr	r3, [r0, #16]
	uint8_t i, status, ret=0;
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    2916:	movs	r2, #18
    2918:	strb	r2, [r3, #3]
    291a:	ldr	r2, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    291c:	ldrb	r3, [r2, #2]
    291e:	and.w	r3, r3, #32
	}
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    2922:	mov	r4, r0
    2924:	mov	r5, r1
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    2926:	and.w	r6, r3, #255	; 0xff
    292a:	cbz	r3, 2932 <TwoWire::endTransmission(unsigned char)+0x22>
		// we are already the bus master, so send a repeated start
		//Serial.print("rstart:");
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    292c:	movs	r3, #180	; 0xb4
    292e:	strb	r3, [r2, #2]
    2930:	b.n	2944 <TwoWire::endTransmission(unsigned char)+0x34>
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    2932:	bl	2830 <TwoWire::wait_idle()>
    2936:	cmp	r0, #0
    2938:	beq.n	29fc <TwoWire::endTransmission(unsigned char)+0xec>
    293a:	ldr	r3, [r4, #16]
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    293c:	strb.w	r6, [r4, #303]	; 0x12f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    2940:	movs	r2, #176	; 0xb0
    2942:	strb	r2, [r3, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2944:	ldr	r3, [pc, #188]	; (2a04 <TwoWire::endTransmission(unsigned char)+0xf4>)
    2946:	ldr	r1, [r4, #16]
    2948:	ldr	r2, [r3, #0]
    294a:	str	r2, [sp, #0]
	return ret;
    294c:	ldr	r6, [sp, #0]
	uint8_t i2c_status(void) {
		return port().S;
    294e:	ldrb	r2, [r1, #3]
	}
	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    2950:	and.w	r2, r2, #32
    2954:	and.w	r0, r2, #255	; 0xff
    2958:	cmp	r2, #0
    295a:	beq.n	29e8 <TwoWire::endTransmission(unsigned char)+0xd8>
    295c:	movs	r0, #0
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    295e:	movs	r7, #2
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
    2960:	ldrb.w	r2, [r4, #301]	; 0x12d
    2964:	uxtb	r1, r0
    2966:	cmp	r2, r1
    2968:	bls.n	29d6 <TwoWire::endTransmission(unsigned char)+0xc6>
		port().D = txBuffer[i];
    296a:	adds	r6, r4, r1
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    296c:	ldr	r2, [r4, #16]
    296e:	ldrb.w	r6, [r6, #163]	; 0xa3
    2972:	strb	r6, [r2, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2974:	ldr	r2, [r3, #0]
    2976:	str	r2, [sp, #12]
	return ret;
    2978:	ldr.w	r8, [sp, #12]
    297c:	ldr	r6, [r4, #16]
	uint8_t i2c_status(void) {
		return port().S;
    297e:	ldrb	r2, [r6, #3]
    2980:	uxtb	r2, r2
		//Serial.write('^');
		wait_begin = millis();
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
    2982:	and.w	lr, r2, #2
    2986:	and.w	ip, lr, #255	; 0xff
    298a:	cmp.w	lr, #0
    298e:	bne.n	29a8 <TwoWire::endTransmission(unsigned char)+0x98>
			if (!(status & I2C_S_BUSY)) break;
    2990:	lsls	r2, r2, #26
    2992:	bpl.n	29a8 <TwoWire::endTransmission(unsigned char)+0x98>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2994:	ldr	r2, [r3, #0]
    2996:	str	r2, [sp, #8]
	return ret;
    2998:	ldr	r2, [sp, #8]
			if (millis() - wait_begin > 5) {
    299a:	rsb	r2, r8, r2
    299e:	cmp	r2, #5
    29a0:	bls.n	297e <TwoWire::endTransmission(unsigned char)+0x6e>
				port().C1 = 0;
    29a2:	strb.w	ip, [r6, #2]
    29a6:	b.n	29f6 <TwoWire::endTransmission(unsigned char)+0xe6>
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    29a8:	strb	r7, [r6, #3]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    29aa:	ldr	r6, [r4, #16]
	uint8_t i2c_status(void) {
		return port().S;
    29ac:	ldrb	r2, [r6, #3]
    29ae:	uxtb	r2, r2
		//Serial.write('$');
		status = i2c_status();
		if ((status & I2C_S_ARBL)) {
    29b0:	tst.w	r2, #16
    29b4:	bne.n	29bc <TwoWire::endTransmission(unsigned char)+0xac>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("endTransmission err4\n");
			ret = 4; // 4:other error
			break;
		}
		if (!(status & I2C_S_BUSY)) {
    29b6:	tst.w	r2, #32
    29ba:	bne.n	29c4 <TwoWire::endTransmission(unsigned char)+0xb4>
			// suddenly lost control of the bus!
			port().C1 = I2C_C1_IICEN;
    29bc:	movs	r3, #128	; 0x80
    29be:	strb	r3, [r6, #2]
			//Serial.printf("endTransmission err5\n");
			ret = 4; // 4:other error
    29c0:	movs	r0, #4
    29c2:	b.n	29d8 <TwoWire::endTransmission(unsigned char)+0xc8>
			break;
		}
		if (status & I2C_S_RXAK) {
    29c4:	lsls	r2, r2, #31
    29c6:	add.w	r0, r0, #1
    29ca:	bpl.n	2960 <TwoWire::endTransmission(unsigned char)+0x50>
			if (i == 0) {
				//Serial.printf("endTransmission err6\n");
				ret = 2; // 2:received NACK on transmit of address
			} else {
				//Serial.printf("endTransmission err7\n");
				ret = 3; // 3:received NACK on transmit of data 
    29cc:	cmp	r1, #0
    29ce:	ite	eq
    29d0:	moveq	r0, #2
    29d2:	movne	r0, #3
    29d4:	b.n	29da <TwoWire::endTransmission(unsigned char)+0xca>
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
	uint8_t i, status, ret=0;
    29d6:	movs	r0, #0
			}
			sendStop = 1;
			break;
		}
	}
	if (sendStop) {
    29d8:	cbz	r5, 29e0 <TwoWire::endTransmission(unsigned char)+0xd0>
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    29da:	ldr	r3, [r4, #16]
		// send the stop condition
		port().C1 = I2C_C1_IICEN;
    29dc:	movs	r2, #128	; 0x80
    29de:	strb	r2, [r3, #2]
		// TODO: do we wait for this somehow?
	}
	transmitting = 0;
    29e0:	movs	r3, #0
    29e2:	strb.w	r3, [r4, #302]	; 0x12e
    29e6:	b.n	29fe <TwoWire::endTransmission(unsigned char)+0xee>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    29e8:	ldr	r2, [r3, #0]
    29ea:	str	r2, [sp, #4]
	return ret;
    29ec:	ldr	r2, [sp, #4]
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		//Serial.write('*') ;
		if (millis() - wait_begin > 4) {
    29ee:	subs	r2, r2, r6
    29f0:	cmp	r2, #4
    29f2:	bls.n	294e <TwoWire::endTransmission(unsigned char)+0x3e>
			port().C1 = 0;
    29f4:	strb	r0, [r1, #2]
    29f6:	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    29f8:	movs	r2, #128	; 0x80
    29fa:	strb	r2, [r3, #2]
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
    29fc:	movs	r0, #4
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    29fe:	add	sp, #16
    2a00:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2a04:	.word	0x2001a6fc

00002a08 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>:


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    2a08:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    2a0c:	mov	r9, r3
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
	uint32_t wait_begin;

	rxBufferIndex = 0;
    2a0e:	movs	r3, #0
    2a10:	strb.w	r3, [r0, #160]	; 0xa0
	rxBufferLength = 0;
    2a14:	strb.w	r3, [r0, #161]	; 0xa1
    2a18:	ldr	r3, [r0, #16]
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    2a1a:	mov	r7, r2

	rxBufferIndex = 0;
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    2a1c:	movs	r2, #18
    2a1e:	strb	r2, [r3, #3]
    2a20:	ldr	r2, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    2a22:	ldrb	r3, [r2, #2]
    2a24:	and.w	r3, r3, #32
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    2a28:	sub	sp, #36	; 0x24
    2a2a:	mov	r5, r0
    2a2c:	mov	r8, r1
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    2a2e:	and.w	r4, r3, #255	; 0xff
    2a32:	cbz	r3, 2a3a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x32>
		// we are already the bus master, so send a repeated start
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    2a34:	movs	r3, #180	; 0xb4
    2a36:	strb	r3, [r2, #2]
    2a38:	b.n	2a4e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x46>
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    2a3a:	bl	2830 <TwoWire::wait_idle()>
    2a3e:	cmp	r0, #0
    2a40:	beq.w	2bb6 <L_2399_delayMicroseconds+0x3e>
    2a44:	ldr	r3, [r5, #16]
			//Serial.printf("requestFrom err1\n");
			return 0; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    2a46:	strb.w	r4, [r5, #303]	; 0x12f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    2a4a:	movs	r2, #176	; 0xb0
    2a4c:	strb	r2, [r3, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2a4e:	ldr	r6, [pc, #368]	; (2bc0 <L_2399_delayMicroseconds+0x48>)
    2a50:	ldr	r2, [r5, #16]
    2a52:	ldr	r3, [r6, #0]
    2a54:	str	r3, [sp, #0]
	return ret;
    2a56:	ldr	r1, [sp, #0]
	uint8_t i2c_status(void) {
		return port().S;
    2a58:	ldrb	r3, [r2, #3]
    2a5a:	and.w	r3, r3, #32

	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    2a5e:	and.w	r4, r3, #255	; 0xff
    2a62:	cbnz	r3, 2a72 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x6a>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2a64:	ldr	r3, [r6, #0]
    2a66:	str	r3, [sp, #4]
	return ret;
    2a68:	ldr	r3, [sp, #4]
		if (millis() - wait_begin > 4) {
    2a6a:	subs	r3, r3, r1
    2a6c:	cmp	r3, #4
    2a6e:	bls.n	2a58 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x50>
    2a70:	b.n	2aa2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x9a>
			//Serial.printf("requestFrom err2\n");
			return 0; // error generating start condition
		}
	}
	// send the address
	port().D = (address << 1) | 1;
    2a72:	mov.w	r8, r8, lsl #1
    2a76:	orr.w	r8, r8, #1
    2a7a:	uxtb.w	r8, r8
    2a7e:	strb.w	r8, [r2, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2a82:	ldr	r3, [r6, #0]
    2a84:	str	r3, [sp, #8]
	return ret;
    2a86:	ldr	r1, [sp, #8]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    2a88:	ldr	r2, [r5, #16]
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    2a8a:	ldrb	r3, [r2, #3]
    2a8c:	and.w	r3, r3, #2
    2a90:	and.w	r4, r3, #255	; 0xff
    2a94:	cbnz	r3, 2aaa <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xa2>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2a96:	ldr	r3, [r6, #0]
    2a98:	str	r3, [sp, #12]
	return ret;
    2a9a:	ldr	r3, [sp, #12]
		if (millis() - wait_begin > 5) {
    2a9c:	subs	r3, r3, r1
    2a9e:	cmp	r3, #5
    2aa0:	bls.n	2a8a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x82>
			port().C1 = 0;
    2aa2:	strb	r4, [r2, #2]
    2aa4:	ldr	r3, [r5, #16]
			port().C1 = I2C_C1_IICEN;
    2aa6:	movs	r2, #128	; 0x80
    2aa8:	b.n	2acc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xc4>
			//Serial.printf("requestFrom err3\n");
			return 0; // clock stretch too long (during address)
		}
	}
	port().S = I2C_S_IICIF;
    2aaa:	movs	r3, #2
    2aac:	strb	r3, [r2, #3]
    2aae:	ldr	r3, [r5, #16]
	uint8_t i2c_status(void) {
		return port().S;
    2ab0:	ldrb	r0, [r3, #3]
	status = i2c_status();
	if ((status & I2C_S_RXAK) || (status & I2C_S_ARBL)) {
    2ab2:	ands.w	r4, r0, #17
    2ab6:	beq.n	2ac0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xb8>
		// the slave device did not acknowledge
		// or we lost bus arbitration to another master
		port().C1 = I2C_C1_IICEN;
    2ab8:	movs	r2, #128	; 0x80
    2aba:	strb	r2, [r3, #2]
		//Serial.printf("requestFrom err4\n");
		return 0;
    2abc:	movs	r4, #0
    2abe:	b.n	2bb6 <L_2399_delayMicroseconds+0x3e>
	}
	if (length == 0) {
    2ac0:	cbnz	r7, 2ad0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xc8>
		// TODO: does anybody really do zero length reads?
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
    2ac2:	cmp.w	r9, #0
    2ac6:	ite	ne
    2ac8:	movne	r2, #128	; 0x80
    2aca:	moveq	r2, #160	; 0xa0
    2acc:	strb	r2, [r3, #2]
		//Serial.printf("requestFrom err5\n");
		return 0;
    2ace:	b.n	2bb6 <L_2399_delayMicroseconds+0x3e>
	} else if (length == 1) {
    2ad0:	cmp	r7, #1
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    2ad2:	ite	eq
    2ad4:	moveq	r2, #168	; 0xa8
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
    2ad6:	movne	r2, #160	; 0xa0
    2ad8:	strb	r2, [r3, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    2ada:	ldr	r3, [r5, #16]
	}
	tmp = port().D; // initiate the first receive
    2adc:	ldrb	r3, [r3, #4]


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
    2ade:	movs	r0, #0
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    2ae0:	movs	r1, #2
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    2ae2:	movs	r4, #168	; 0xa8
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
	}
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
    2ae4:	cmp	r7, #1
    2ae6:	ldr	r2, [r5, #16]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2ae8:	ldr	r3, [r6, #0]
    2aea:	beq.n	2b44 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x13c>
    2aec:	str	r3, [sp, #16]
	return ret;
    2aee:	ldr.w	ip, [sp, #16]
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
    2af2:	ldrb	r3, [r2, #3]
    2af4:	and.w	r3, r3, #2
    2af8:	and.w	lr, r3, #255	; 0xff
    2afc:	cbnz	r3, 2b12 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x10a>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2afe:	ldr	r3, [r6, #0]
    2b00:	str	r3, [sp, #20]
	return ret;
    2b02:	ldr	r3, [sp, #20]
			if (millis() - wait_begin > 5) {
    2b04:	rsb	r3, ip, r3
    2b08:	cmp	r3, #5
    2b0a:	bls.n	2af2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xea>
				port().C1 = 0;
    2b0c:	strb.w	lr, [r2, #2]
    2b10:	b.n	2baa <L_2399_delayMicroseconds+0x32>
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    2b12:	strb	r1, [r2, #3]
    2b14:	ldr	r2, [r5, #16]
		status = port().S;
    2b16:	ldrb	r3, [r2, #3]
    2b18:	uxtb	r3, r3
		if ((status & I2C_S_ARBL)) {
    2b1a:	tst.w	r3, #16
    2b1e:	bne.n	2bb4 <L_2399_delayMicroseconds+0x3c>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7a\n");
			return count;
		}
		if (!(status & I2C_S_BUSY)) {
    2b20:	lsls	r3, r3, #26
    2b22:	bpl.n	2bb4 <L_2399_delayMicroseconds+0x3c>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
    2b24:	subs	r7, #1
    2b26:	uxtb	r7, r7
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    2b28:	cmp	r7, #1
    2b2a:	it	eq
    2b2c:	strbeq	r4, [r2, #2]
    2b2e:	ldr	r3, [r5, #16]
		if (count < BUFFER_LENGTH) {
    2b30:	cmp	r0, #135	; 0x87
			rxBuffer[count++] = port().D;
    2b32:	itttt	ls
    2b34:	addls	r2, r0, #1
    2b36:	addls	r0, r0, r5
    2b38:	ldrbls	r3, [r3, #4]
    2b3a:	strbls	r3, [r0, #24]
		} else {
			tmp = port().D;
    2b3c:	ite	hi
    2b3e:	ldrbhi	r3, [r3, #4]
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
		if (count < BUFFER_LENGTH) {
			rxBuffer[count++] = port().D;
    2b40:	uxtbls	r0, r2
    2b42:	b.n	2ae4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xdc>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2b44:	str	r3, [sp, #24]
	return ret;
    2b46:	ldr	r4, [sp, #24]
		} else {
			tmp = port().D;
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    2b48:	ldrb	r3, [r2, #3]
    2b4a:	and.w	r3, r3, #2
    2b4e:	and.w	r1, r3, #255	; 0xff
    2b52:	cbnz	r3, 2b64 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x15c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2b54:	ldr	r3, [r6, #0]
    2b56:	str	r3, [sp, #28]
	return ret;
    2b58:	ldr	r3, [sp, #28]
		if (millis() - wait_begin > 5) {
    2b5a:	subs	r3, r3, r4
    2b5c:	cmp	r3, #5
    2b5e:	bls.n	2b48 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x140>
			port().C1 = 0;
    2b60:	strb	r1, [r2, #2]
    2b62:	b.n	2baa <L_2399_delayMicroseconds+0x32>
			rxBufferLength = count;
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
		}
	}
	port().S = I2C_S_IICIF;
    2b64:	movs	r3, #2
    2b66:	strb	r3, [r2, #3]
    2b68:	ldr	r2, [r5, #16]
	status = port().S;
    2b6a:	ldrb	r3, [r2, #3]
    2b6c:	uxtb	r3, r3
	if ((status & I2C_S_ARBL)) {
    2b6e:	lsls	r1, r3, #27
    2b70:	bpl.n	2b88 <L_2399_delayMicroseconds+0x10>
		// we lost bus arbitration to another master
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//digitalWriteFast(13, HIGH);
		port().S = I2C_S_ARBL;
    2b72:	movs	r3, #16
    2b74:	strb	r3, [r2, #3]
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    2b76:	movs	r3, #160	; 0xa0

00002b78 <L_2399_delayMicroseconds>:
    2b78:	subs	r3, #1
    2b7a:	bne.n	2b78 <L_2399_delayMicroseconds>
    2b7c:	ldr	r2, [r5, #16]
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
    2b7e:	ldrb	r3, [r2, #2]
    2b80:	and.w	r3, r3, #247	; 0xf7
    2b84:	strb	r3, [r2, #2]
    2b86:	b.n	2bb4 <L_2399_delayMicroseconds+0x3c>
		//Serial.printf("requestFrom err9a\n");
		return count;
	}
	if (!(status & I2C_S_BUSY)) {
    2b88:	lsls	r3, r3, #26
    2b8a:	bpl.n	2bb4 <L_2399_delayMicroseconds+0x3c>
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    2b8c:	movs	r3, #176	; 0xb0
    2b8e:	strb	r3, [r2, #2]
	if (count < BUFFER_LENGTH) {
    2b90:	cmp	r0, #135	; 0x87
    2b92:	ldr	r3, [r5, #16]
		rxBuffer[count++] = port().D;
    2b94:	itttt	ls
    2b96:	addls	r2, r0, #1
    2b98:	addls	r0, r0, r5
    2b9a:	ldrbls	r3, [r3, #4]
    2b9c:	strbls	r3, [r0, #24]
	} else {
		tmp = port().D;
    2b9e:	ite	hi
    2ba0:	ldrbhi	r3, [r3, #4]
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
	if (count < BUFFER_LENGTH) {
		rxBuffer[count++] = port().D;
    2ba2:	uxtbls	r0, r2
#if F_CPU > 120000000
	__asm__("nop");
	__asm__("nop");
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
    2ba4:	cmp.w	r9, #0
    2ba8:	beq.n	2bb0 <L_2399_delayMicroseconds+0x38>
    2baa:	ldr	r3, [r5, #16]
    2bac:	movs	r2, #128	; 0x80
    2bae:	strb	r2, [r3, #2]
	rxBufferLength = count;
    2bb0:	strb.w	r0, [r5, #161]	; 0xa1
    2bb4:	mov	r4, r0
	return count;
}
    2bb6:	mov	r0, r4
    2bb8:	add	sp, #36	; 0x24
    2bba:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    2bbe:	nop
    2bc0:	.word	0x2001a6fc

00002bc4 <i2c0_isr>:
#define MAKE_CONST(x) (__builtin_constant_p(x) ? (x) : (x))

#ifdef WIRE_IMPLEMENT_WIRE
constexpr uintptr_t i2c0_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C0));
TwoWire Wire(i2c0_addr, TwoWire::i2c0_hardware);
void i2c0_isr(void) { Wire.isr(); }
    2bc4:	ldr	r0, [pc, #4]	; (2bcc <i2c0_isr+0x8>)
    2bc6:	b.w	271c <TwoWire::isr()>
    2bca:	nop
    2bcc:	.word	0x1fff1080

00002bd0 <i2c1_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE1
constexpr uintptr_t i2c1_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C1));
TwoWire Wire1(i2c1_addr, TwoWire::i2c1_hardware);
void i2c1_isr(void) { Wire1.isr(); }
    2bd0:	ldr	r0, [pc, #4]	; (2bd8 <i2c1_isr+0x8>)
    2bd2:	b.w	271c <TwoWire::isr()>
    2bd6:	nop
    2bd8:	.word	0x1fff11bc

00002bdc <i2c2_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE2
constexpr uintptr_t i2c2_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C2));
TwoWire Wire2(i2c2_addr, TwoWire::i2c2_hardware);
void i2c2_isr(void) { Wire2.isr(); }
    2bdc:	ldr	r0, [pc, #4]	; (2be4 <i2c2_isr+0x8>)
    2bde:	b.w	271c <TwoWire::isr()>
    2be2:	nop
    2be4:	.word	0x1fff0f44

00002be8 <DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]>:

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    2be8:	ldrh	r3, [r0, #30]
    2bea:	lsls	r3, r3, #16
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    2bec:	itttt	mi
    2bee:	ldrhmi	r3, [r0, #30]
    2bf0:	ubfxmi	r1, r1, #0, #9
    2bf4:	andmi.w	r3, r3, #65024	; 0xfe00
    2bf8:	orrmi	r1, r3
#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
    2bfa:	it	pl
    2bfc:	ubfxpl	r1, r1, #0, #15
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    2c00:	strh	r1, [r0, #30]
	}
	tcd->CITER = tcd->BITER; 
    2c02:	ldrh	r3, [r0, #30]
    2c04:	uxth	r3, r3
    2c06:	strh	r3, [r0, #22]
    2c08:	bx	lr
    2c0a:	Address 0x00002c0a is out of bounds.


00002c0c <SPIClass::begin()>:
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
	const SPI_Hardware_t & hardware() { return *(const SPI_Hardware_t *)hardware_addr; }
    2c0c:	ldr	r3, [r0, #4]

void SPIClass::begin()
{
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    2c0e:	ldr	r1, [r3, #0]
    2c10:	ldr	r2, [r3, #4]
SPIClass SPI2((uintptr_t)&KINETISK_SPI2, (uintptr_t)&SPIClass::spi2_hardware);
#endif


void SPIClass::begin()
{
    2c12:	push	{r4, lr}
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    2c14:	ldr	r4, [r1, #0]
    2c16:	orrs	r2, r4
    2c18:	str	r2, [r1, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    2c1a:	ldr	r2, [r0, #0]
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
    2c1c:	ldr	r1, [pc, #84]	; (2c74 <SPIClass::begin()+0x68>)
    2c1e:	str	r1, [r2, #0]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    2c20:	ldr	r1, [pc, #84]	; (2c78 <SPIClass::begin()+0x6c>)
    2c22:	str	r1, [r2, #12]
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    2c24:	add.w	r1, r1, #1073741824	; 0x40000000
    2c28:	str	r1, [r2, #16]
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
    2c2a:	ldr	r1, [pc, #80]	; (2c7c <SPIClass::begin()+0x70>)
    2c2c:	str	r1, [r2, #0]
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2c2e:	ldrb	r1, [r0, #9]
    2c30:	ldr	r2, [pc, #76]	; (2c80 <SPIClass::begin()+0x74>)
    2c32:	adds	r4, r3, r1
	*reg = hardware().mosi_mux[mosi_pin_index];
    2c34:	adds	r1, #12
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2c36:	ldrb.w	r4, [r4, #44]	; 0x2c
	*reg = hardware().mosi_mux[mosi_pin_index];
    2c3a:	ldr.w	r1, [r3, r1, lsl #2]
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2c3e:	add.w	r4, r2, r4, lsl #3
    2c42:	ldr	r4, [r4, #4]
	*reg = hardware().mosi_mux[mosi_pin_index];
    2c44:	str	r1, [r4, #0]
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2c46:	ldrb	r1, [r0, #8]
    2c48:	adds	r4, r3, r1
	*reg= hardware().miso_mux[miso_pin_index];
    2c4a:	add.w	r1, r3, r1, lsl #2
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2c4e:	ldrb	r4, [r4, #24]
	*reg= hardware().miso_mux[miso_pin_index];
    2c50:	ldr	r1, [r1, #28]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2c52:	add.w	r4, r2, r4, lsl #3
    2c56:	ldr	r4, [r4, #4]
	*reg= hardware().miso_mux[miso_pin_index];
    2c58:	str	r1, [r4, #0]
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2c5a:	ldrb	r1, [r0, #10]
    2c5c:	adds	r0, r3, r1
	*reg = hardware().sck_mux[sck_pin_index];
    2c5e:	add.w	r3, r3, r1, lsl #2
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2c62:	ldrb.w	r0, [r0, #64]	; 0x40
	*reg = hardware().sck_mux[sck_pin_index];
    2c66:	ldr	r3, [r3, #68]	; 0x44
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2c68:	add.w	r2, r2, r0, lsl #3
    2c6c:	ldr	r2, [r2, #4]
	*reg = hardware().sck_mux[sck_pin_index];
    2c6e:	str	r3, [r2, #0]
    2c70:	pop	{r4, pc}
    2c72:	nop
    2c74:	.word	0x001f4001
    2c78:	.word	0x38001001
    2c7c:	.word	0x801f0000
    2c80:	.word	0x00012e88

00002c84 <SPIClass::setMOSI(unsigned char)>:
	return 0;
}

void SPIClass::setMOSI(uint8_t pin)
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2c84:	ldr	r3, [r0, #4]
    2c86:	ldr	r2, [pc, #140]	; (2d14 <SPIClass::setMOSI(unsigned char)+0x90>)
    2c88:	cmp	r2, r3
	}
	return 0;
}

void SPIClass::setMOSI(uint8_t pin)
{
    2c8a:	push	{r4, r5, r6, lr}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2c8c:	bne.n	2cc0 <SPIClass::setMOSI(unsigned char)+0x3c>
		pinout = newpinout;
#endif
	}
	inline void setMOSI_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 11) pinout &= ~3;
    2c8e:	cmp	r1, #11
    2c90:	bne.n	2c9c <SPIClass::setMOSI(unsigned char)+0x18>
    2c92:	ldr	r4, [pc, #132]	; (2d18 <SPIClass::setMOSI(unsigned char)+0x94>)
    2c94:	ldrb	r2, [r4, #0]
    2c96:	bic.w	r2, r2, #3
    2c9a:	b.n	2cbe <SPIClass::setMOSI(unsigned char)+0x3a>
		if (pin == 7)  pinout = (pinout & ~0x3) | 1;
    2c9c:	cmp	r1, #7
    2c9e:	bne.n	2cae <SPIClass::setMOSI(unsigned char)+0x2a>
    2ca0:	ldr	r4, [pc, #116]	; (2d18 <SPIClass::setMOSI(unsigned char)+0x94>)
    2ca2:	ldrb	r2, [r4, #0]
    2ca4:	bic.w	r2, r2, #3
    2ca8:	orr.w	r2, r2, #1
    2cac:	b.n	2cbe <SPIClass::setMOSI(unsigned char)+0x3a>
		if (pin == 28) pinout = (pinout & ~0x3) | 2;
    2cae:	cmp	r1, #28
    2cb0:	bne.n	2cc0 <SPIClass::setMOSI(unsigned char)+0x3c>
    2cb2:	ldr	r4, [pc, #100]	; (2d18 <SPIClass::setMOSI(unsigned char)+0x94>)
    2cb4:	ldrb	r2, [r4, #0]
    2cb6:	bic.w	r2, r2, #3
    2cba:	orr.w	r2, r2, #2
    2cbe:	strb	r2, [r4, #0]
		SPCR.setMOSI_soft(pin);
	}
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
    2cc0:	ldrb	r2, [r0, #9]
    2cc2:	add	r2, r3
    2cc4:	ldrb.w	r4, [r2, #44]	; 0x2c
    2cc8:	cmp	r1, r4
    2cca:	beq.n	2d10 <SPIClass::setMOSI(unsigned char)+0x8c>
    2ccc:	add.w	r5, r3, #43	; 0x2b
    2cd0:	movs	r2, #0
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
    2cd2:	ldrb.w	r6, [r5, #1]!
    2cd6:	cmp	r6, r1
    2cd8:	bne.n	2d0a <SPIClass::setMOSI(unsigned char)+0x86>
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    2cda:	ldr	r1, [r3, #0]
    2cdc:	ldr	r5, [r1, #0]
    2cde:	ldr	r1, [r3, #4]
    2ce0:	tst	r5, r1
    2ce2:	beq.n	2d06 <SPIClass::setMOSI(unsigned char)+0x82>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2ce4:	ldr	r1, [pc, #52]	; (2d1c <SPIClass::setMOSI(unsigned char)+0x98>)
    2ce6:	add.w	r4, r1, r4, lsl #3
					*reg = 0;
    2cea:	movs	r5, #0
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2cec:	ldr	r4, [r4, #4]
					*reg = 0;
    2cee:	str	r5, [r4, #0]
					reg = portConfigRegister(hardware().mosi_pin[i]);
    2cf0:	adds	r4, r3, r2
    2cf2:	ldrb.w	r4, [r4, #44]	; 0x2c
    2cf6:	add.w	r1, r1, r4, lsl #3
					*reg = hardware().mosi_mux[i];
    2cfa:	add.w	r4, r2, #12
			if  (pin == hardware().mosi_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().mosi_pin[i]);
    2cfe:	ldr	r1, [r1, #4]
					*reg = hardware().mosi_mux[i];
    2d00:	ldr.w	r3, [r3, r4, lsl #2]
    2d04:	str	r3, [r1, #0]
				}	
				mosi_pin_index = i;
    2d06:	strb	r2, [r0, #9]
				return;
    2d08:	pop	{r4, r5, r6, pc}
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setMOSI_soft(pin);
	}
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
    2d0a:	adds	r2, #1
    2d0c:	cmp	r2, #4
    2d0e:	bne.n	2cd2 <SPIClass::setMOSI(unsigned char)+0x4e>
    2d10:	pop	{r4, r5, r6, pc}
    2d12:	nop
    2d14:	.word	0x000129d8
    2d18:	.word	0x2001a7f5
    2d1c:	.word	0x00012e88

00002d20 <SPIClass::setMISO(unsigned char)>:
	}
}

void SPIClass::setMISO(uint8_t pin)
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2d20:	ldr	r3, [r0, #4]
    2d22:	ldr	r2, [pc, #132]	; (2da8 <SPIClass::setMISO(unsigned char)+0x88>)
    2d24:	cmp	r2, r3
		}
	}
}

void SPIClass::setMISO(uint8_t pin)
{
    2d26:	push	{r4, r5, r6, lr}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2d28:	bne.n	2d5c <SPIClass::setMISO(unsigned char)+0x3c>
		pinout = newpinout;
#endif
	}
	inline void setMISO_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 12) pinout &= ~0xc;
    2d2a:	cmp	r1, #12
    2d2c:	bne.n	2d38 <SPIClass::setMISO(unsigned char)+0x18>
    2d2e:	ldr	r4, [pc, #124]	; (2dac <SPIClass::setMISO(unsigned char)+0x8c>)
    2d30:	ldrb	r2, [r4, #0]
    2d32:	bic.w	r2, r2, #12
    2d36:	b.n	2d5a <SPIClass::setMISO(unsigned char)+0x3a>
		if (pin == 8)  pinout = (pinout & ~0xc) | 4;
    2d38:	cmp	r1, #8
    2d3a:	bne.n	2d4a <SPIClass::setMISO(unsigned char)+0x2a>
    2d3c:	ldr	r4, [pc, #108]	; (2dac <SPIClass::setMISO(unsigned char)+0x8c>)
    2d3e:	ldrb	r2, [r4, #0]
    2d40:	bic.w	r2, r2, #12
    2d44:	orr.w	r2, r2, #4
    2d48:	b.n	2d5a <SPIClass::setMISO(unsigned char)+0x3a>
		if (pin == 39) pinout = (pinout & ~0xc) | 8;
    2d4a:	cmp	r1, #39	; 0x27
    2d4c:	bne.n	2d5c <SPIClass::setMISO(unsigned char)+0x3c>
    2d4e:	ldr	r4, [pc, #92]	; (2dac <SPIClass::setMISO(unsigned char)+0x8c>)
    2d50:	ldrb	r2, [r4, #0]
    2d52:	bic.w	r2, r2, #12
    2d56:	orr.w	r2, r2, #8
    2d5a:	strb	r2, [r4, #0]
		SPCR.setMISO_soft(pin);
	}
	if (pin != hardware().miso_pin[miso_pin_index]) {
    2d5c:	ldrb	r2, [r0, #8]
    2d5e:	add	r2, r3
    2d60:	ldrb	r4, [r2, #24]
    2d62:	cmp	r1, r4
    2d64:	beq.n	2da6 <SPIClass::setMISO(unsigned char)+0x86>
    2d66:	add.w	r5, r3, #23
    2d6a:	movs	r2, #0
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
			if  (pin == hardware().miso_pin[i]) {
    2d6c:	ldrb.w	r6, [r5, #1]!
    2d70:	cmp	r6, r1
    2d72:	bne.n	2da0 <SPIClass::setMISO(unsigned char)+0x80>
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    2d74:	ldr	r1, [r3, #0]
    2d76:	ldr	r5, [r1, #0]
    2d78:	ldr	r1, [r3, #4]
    2d7a:	tst	r5, r1
    2d7c:	beq.n	2d9c <SPIClass::setMISO(unsigned char)+0x7c>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2d7e:	ldr	r1, [pc, #48]	; (2db0 <SPIClass::setMISO(unsigned char)+0x90>)
    2d80:	add.w	r4, r1, r4, lsl #3
					*reg = 0;
    2d84:	movs	r5, #0
	if (pin != hardware().miso_pin[miso_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2d86:	ldr	r4, [r4, #4]
					*reg = 0;
    2d88:	str	r5, [r4, #0]
					reg = portConfigRegister(hardware().miso_pin[i]);
    2d8a:	adds	r4, r3, r2
					*reg = hardware().miso_mux[i];
    2d8c:	add.w	r3, r3, r2, lsl #2
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().miso_pin[i]);
    2d90:	ldrb	r4, [r4, #24]
					*reg = hardware().miso_mux[i];
    2d92:	ldr	r3, [r3, #28]
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().miso_pin[i]);
    2d94:	add.w	r1, r1, r4, lsl #3
    2d98:	ldr	r1, [r1, #4]
					*reg = hardware().miso_mux[i];
    2d9a:	str	r3, [r1, #0]
				}	
				miso_pin_index = i;
    2d9c:	strb	r2, [r0, #8]
				return;
    2d9e:	pop	{r4, r5, r6, pc}
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setMISO_soft(pin);
	}
	if (pin != hardware().miso_pin[miso_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
    2da0:	adds	r2, #1
    2da2:	cmp	r2, #4
    2da4:	bne.n	2d6c <SPIClass::setMISO(unsigned char)+0x4c>
    2da6:	pop	{r4, r5, r6, pc}
    2da8:	.word	0x000129d8
    2dac:	.word	0x2001a7f5
    2db0:	.word	0x00012e88

00002db4 <SPIClass::setSCK(unsigned char)>:
	}
}

void SPIClass::setSCK(uint8_t pin)
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2db4:	ldr	r3, [r0, #4]
    2db6:	ldr	r2, [pc, #148]	; (2e4c <SPIClass::setSCK(unsigned char)+0x98>)
    2db8:	cmp	r2, r3
		}
	}
}

void SPIClass::setSCK(uint8_t pin)
{
    2dba:	push	{r4, r5, lr}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2dbc:	bne.n	2df0 <SPIClass::setSCK(unsigned char)+0x3c>
		pinout = newpinout;
#endif
	}
	inline void setSCK_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 13) pinout &= ~0x30;
    2dbe:	cmp	r1, #13
    2dc0:	bne.n	2dcc <SPIClass::setSCK(unsigned char)+0x18>
    2dc2:	ldr	r4, [pc, #140]	; (2e50 <SPIClass::setSCK(unsigned char)+0x9c>)
    2dc4:	ldrb	r2, [r4, #0]
    2dc6:	bic.w	r2, r2, #48	; 0x30
    2dca:	b.n	2dee <SPIClass::setSCK(unsigned char)+0x3a>
		if (pin == 14) pinout = (pinout & ~0x30) | 0x10;
    2dcc:	cmp	r1, #14
    2dce:	bne.n	2dde <SPIClass::setSCK(unsigned char)+0x2a>
    2dd0:	ldr	r4, [pc, #124]	; (2e50 <SPIClass::setSCK(unsigned char)+0x9c>)
    2dd2:	ldrb	r2, [r4, #0]
    2dd4:	bic.w	r2, r2, #48	; 0x30
    2dd8:	orr.w	r2, r2, #16
    2ddc:	b.n	2dee <SPIClass::setSCK(unsigned char)+0x3a>
		if (pin == 27) pinout = (pinout & ~0x30) | 0x20;
    2dde:	cmp	r1, #27
    2de0:	bne.n	2df0 <SPIClass::setSCK(unsigned char)+0x3c>
    2de2:	ldr	r4, [pc, #108]	; (2e50 <SPIClass::setSCK(unsigned char)+0x9c>)
    2de4:	ldrb	r2, [r4, #0]
    2de6:	bic.w	r2, r2, #48	; 0x30
    2dea:	orr.w	r2, r2, #32
    2dee:	strb	r2, [r4, #0]
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
    2df0:	ldrb	r2, [r0, #10]
    2df2:	add	r2, r3
    2df4:	ldrb.w	r4, [r2, #64]	; 0x40
    2df8:	cmp	r1, r4
    2dfa:	beq.n	2e4a <SPIClass::setSCK(unsigned char)+0x96>
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
    2dfc:	ldrb.w	r2, [r3, #64]	; 0x40
    2e00:	cmp	r2, r1
    2e02:	beq.n	2e18 <SPIClass::setSCK(unsigned char)+0x64>
    2e04:	ldrb.w	r2, [r3, #65]	; 0x41
    2e08:	cmp	r2, r1
    2e0a:	beq.n	2e1c <SPIClass::setSCK(unsigned char)+0x68>
    2e0c:	ldrb.w	r2, [r3, #66]	; 0x42
    2e10:	cmp	r2, r1
    2e12:	bne.n	2e4a <SPIClass::setSCK(unsigned char)+0x96>
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
    2e14:	movs	r2, #2
    2e16:	b.n	2e1e <SPIClass::setSCK(unsigned char)+0x6a>
			if  (pin == hardware().sck_pin[i]) {
    2e18:	movs	r2, #0
    2e1a:	b.n	2e1e <SPIClass::setSCK(unsigned char)+0x6a>
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
    2e1c:	movs	r2, #1
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    2e1e:	ldr	r1, [r3, #0]
    2e20:	ldr	r5, [r1, #0]
    2e22:	ldr	r1, [r3, #4]
    2e24:	tst	r5, r1
    2e26:	beq.n	2e48 <SPIClass::setSCK(unsigned char)+0x94>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2e28:	ldr	r1, [pc, #40]	; (2e54 <SPIClass::setSCK(unsigned char)+0xa0>)
    2e2a:	add.w	r4, r1, r4, lsl #3
					*reg = 0;
    2e2e:	movs	r5, #0
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2e30:	ldr	r4, [r4, #4]
					*reg = 0;
    2e32:	str	r5, [r4, #0]
					reg = portConfigRegister(hardware().sck_pin[i]);
    2e34:	adds	r4, r3, r2
					*reg = hardware().sck_mux[i];
    2e36:	add.w	r3, r3, r2, lsl #2
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().sck_pin[i]);
    2e3a:	ldrb.w	r4, [r4, #64]	; 0x40
					*reg = hardware().sck_mux[i];
    2e3e:	ldr	r3, [r3, #68]	; 0x44
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().sck_pin[i]);
    2e40:	add.w	r1, r1, r4, lsl #3
    2e44:	ldr	r1, [r1, #4]
					*reg = hardware().sck_mux[i];
    2e46:	str	r3, [r1, #0]
				}	
				sck_pin_index = i;
    2e48:	strb	r2, [r0, #10]
    2e4a:	pop	{r4, r5, pc}
    2e4c:	.word	0x000129d8
    2e50:	.word	0x2001a7f5
    2e54:	.word	0x00012e88

00002e58 <SPIClass::transfer(void const*, void*, unsigned int)>:
		}
	}
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{
    2e58:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	if (count == 0) return;
    2e5c:	cmp	r3, #0
    2e5e:	beq.w	301a <SPIClass::transfer(void const*, void*, unsigned int)+0x1c2>
    2e62:	ldr	r4, [r0, #0]
    2e64:	ldr	r6, [pc, #440]	; (3020 <SPIClass::transfer(void const*, void*, unsigned int)+0x1c8>)
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    2e66:	ldr	r5, [r4, #12]
		const uint8_t *p_write = (const uint8_t *)buf;
		uint8_t *p_read = (uint8_t *)retbuf;
		size_t count_read = count;

		// Lets clear the reader queue
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);
    2e68:	str	r6, [r4, #0]

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    2e6a:	tst.w	r5, #16777216	; 0x1000000
    2e6e:	and.w	r5, r3, #1
    2e72:	bne.n	2f50 <SPIClass::transfer(void const*, void*, unsigned int)+0xf8>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2e74:	cbz	r5, 2e9c <SPIClass::transfer(void const*, void*, unsigned int)+0x44>
		    if (p_write) {
    2e76:	cbz	r1, 2e8a <SPIClass::transfer(void const*, void*, unsigned int)+0x32>
    2e78:	adds	r5, r1, #1
    2e7a:	ldrb	r1, [r1, #0]
				if (count > 1)
    2e7c:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2e7e:	it	ne
    2e80:	orrne.w	r1, r1, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    2e84:	str	r1, [r4, #52]	; 0x34
    2e86:	mov	r1, r5
    2e88:	b.n	2e98 <SPIClass::transfer(void const*, void*, unsigned int)+0x40>
    2e8a:	ldrb.w	r5, [r0, #44]	; 0x2c
			} else {
				if (count > 1)
    2e8e:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2e90:	it	ne
    2e92:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    2e96:	str	r5, [r4, #52]	; 0x34
			}
			count--;
    2e98:	subs	r6, r3, #1
    2e9a:	b.n	2e9e <SPIClass::transfer(void const*, void*, unsigned int)+0x46>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2e9c:	mov	r6, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    2e9e:	ldrb.w	r4, [r0, #44]	; 0x2c
    2ea2:	orr.w	r4, r4, r4, lsl #8

		while (count > 0) {
    2ea6:	cmp	r6, #0
    2ea8:	beq.n	2f28 <SPIClass::transfer(void const*, void*, unsigned int)+0xd0>
			// Push out the next byte; 
		    if (p_write) {
    2eaa:	cbz	r1, 2eba <SPIClass::transfer(void const*, void*, unsigned int)+0x62>
		    	w = (*p_write++) << 8;
    2eac:	mov	r5, r1
				w |= *p_write++;
    2eae:	ldrb	r1, [r1, #1]
	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;

		while (count > 0) {
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
    2eb0:	ldrb.w	r4, [r5], #2
				w |= *p_write++;
    2eb4:	orr.w	r4, r1, r4, lsl #8
    2eb8:	mov	r1, r5
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2eba:	ldr	r5, [r0, #4]
    2ebc:	ldr	r7, [r0, #0]
    2ebe:	ldrb	r5, [r5, #8]
			if (count == 2)
    2ec0:	cmp	r6, #2
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2ec2:	add.w	r5, r5, #4294967295
    2ec6:	mov.w	r5, r5, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    2eca:	ite	eq
    2ecc:	orreq.w	lr, r4, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2ed0:	orrne.w	lr, r4, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2ed4:	uxth	r5, r5
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2ed6:	str.w	lr, [r7, #52]	; 0x34
			count -= 2; // how many bytes to output.
    2eda:	subs	r6, #2
    2edc:	ldr.w	lr, [r0]
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    2ee0:	ldr.w	r7, [lr, #44]	; 0x2c
				if (sr & 0xF0)  {
    2ee4:	tst.w	r7, #240	; 0xf0
    2ee8:	beq.n	2f14 <SPIClass::transfer(void const*, void*, unsigned int)+0xbc>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    2eea:	tst.w	r3, #1
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    2eee:	ldr.w	ip, [lr, #56]	; 0x38
					if (count_read & 1) {
    2ef2:	beq.n	2f00 <SPIClass::transfer(void const*, void*, unsigned int)+0xa8>
						if (p_read) {
    2ef4:	cbz	r2, 2efc <SPIClass::transfer(void const*, void*, unsigned int)+0xa4>
							*p_read++ = w;  // Read any pending RX bytes in
    2ef6:	strb.w	ip, [r2]
    2efa:	adds	r2, #1
						} 
						count_read--;
    2efc:	subs	r3, #1
    2efe:	b.n	2f14 <SPIClass::transfer(void const*, void*, unsigned int)+0xbc>
					} else {
						if (p_read) {
    2f00:	cbz	r2, 2f12 <SPIClass::transfer(void const*, void*, unsigned int)+0xba>
							*p_read++ = w >> 8;
    2f02:	mov	lr, r2
    2f04:	mov.w	r8, ip, asr #8
    2f08:	strb.w	r8, [lr], #2
							*p_read++ = (w & 0xff);
    2f0c:	strb.w	ip, [r2, #1]
    2f10:	mov	r2, lr
						}
						count_read -= 2;
    2f12:	subs	r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    2f14:	and.w	r7, r7, #61440	; 0xf000
    2f18:	cmp	r7, r5
    2f1a:	bhi.n	2edc <SPIClass::transfer(void const*, void*, unsigned int)+0x84>
    2f1c:	b.n	2ea6 <SPIClass::transfer(void const*, void*, unsigned int)+0x4e>
    2f1e:	ldr	r1, [r0, #0]

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
    2f20:	ldr	r4, [r1, #44]	; 0x2c
			if (sr & 0xF0)  {
    2f22:	tst.w	r4, #240	; 0xf0
    2f26:	bne.n	2f2e <SPIClass::transfer(void const*, void*, unsigned int)+0xd6>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    2f28:	cmp	r3, #0
    2f2a:	bne.n	2f1e <SPIClass::transfer(void const*, void*, unsigned int)+0xc6>
    2f2c:	b.n	301a <SPIClass::transfer(void const*, void*, unsigned int)+0x1c2>
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    2f2e:	ldr	r4, [r1, #56]	; 0x38
				if (count_read & 1) {
    2f30:	lsls	r1, r3, #31
    2f32:	bpl.n	2f3e <SPIClass::transfer(void const*, void*, unsigned int)+0xe6>
					if (p_read)
    2f34:	cbz	r2, 2f3a <SPIClass::transfer(void const*, void*, unsigned int)+0xe2>
						*p_read++ = w;  // Read any pending RX bytes in
    2f36:	strb	r4, [r2, #0]
    2f38:	adds	r2, #1
					count_read--;
    2f3a:	subs	r3, #1
    2f3c:	b.n	2f28 <SPIClass::transfer(void const*, void*, unsigned int)+0xd0>
				} else {
					if (p_read) {
    2f3e:	cbz	r2, 2f4c <SPIClass::transfer(void const*, void*, unsigned int)+0xf4>
						*p_read++ = w >> 8;
    2f40:	mov	r1, r2
    2f42:	asrs	r5, r4, #8
    2f44:	strb.w	r5, [r1], #2
						*p_read++ = (w & 0xff);
    2f48:	strb	r4, [r2, #1]
    2f4a:	mov	r2, r1
					}
					count_read -= 2;
    2f4c:	subs	r3, #2
    2f4e:	b.n	2f28 <SPIClass::transfer(void const*, void*, unsigned int)+0xd0>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2f50:	cbz	r5, 2f78 <SPIClass::transfer(void const*, void*, unsigned int)+0x120>
		    if (p_write) {
    2f52:	cbz	r1, 2f66 <SPIClass::transfer(void const*, void*, unsigned int)+0x10e>
    2f54:	adds	r5, r1, #1
    2f56:	ldrb	r1, [r1, #0]
				if (count > 1)
    2f58:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2f5a:	it	ne
    2f5c:	orrne.w	r1, r1, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    2f60:	str	r1, [r4, #52]	; 0x34
    2f62:	mov	r1, r5
    2f64:	b.n	2f74 <SPIClass::transfer(void const*, void*, unsigned int)+0x11c>
    2f66:	ldrb.w	r5, [r0, #44]	; 0x2c
			} else {
				if (count > 1)
    2f6a:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2f6c:	it	ne
    2f6e:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    2f72:	str	r5, [r4, #52]	; 0x34
			}
			count--;
    2f74:	subs	r6, r3, #1
    2f76:	b.n	2f7a <SPIClass::transfer(void const*, void*, unsigned int)+0x122>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2f78:	mov	r6, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w = _transferWriteFill;
    2f7a:	ldrb.w	r7, [r0, #44]	; 0x2c

		while (count > 0) {
    2f7e:	cmp	r6, #0
    2f80:	beq.n	2ff2 <SPIClass::transfer(void const*, void*, unsigned int)+0x19a>
			// Push out the next byte; 
		    if (p_write) {
    2f82:	cbz	r1, 2f8e <SPIClass::transfer(void const*, void*, unsigned int)+0x136>
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
    2f84:	ldrb	r7, [r1, #1]
    2f86:	ldrb	r4, [r1, #0]
    2f88:	adds	r1, #2
    2f8a:	orr.w	r7, r4, r7, lsl #8
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2f8e:	ldr	r4, [r0, #4]
    2f90:	ldr	r5, [r0, #0]
    2f92:	ldrb	r4, [r4, #8]
			if (count == 2)
    2f94:	cmp	r6, #2
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2f96:	add.w	r4, r4, #4294967295
    2f9a:	mov.w	r4, r4, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    2f9e:	ite	eq
    2fa0:	orreq.w	lr, r7, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2fa4:	orrne.w	lr, r7, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2fa8:	uxth	r4, r4
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2faa:	str.w	lr, [r5, #52]	; 0x34
			count -= 2; // how many bytes to output.
    2fae:	subs	r6, #2
    2fb0:	ldr	r5, [r0, #0]
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    2fb2:	ldr.w	lr, [r5, #44]	; 0x2c
				if (sr & 0xF0)  {
    2fb6:	tst.w	lr, #240	; 0xf0
    2fba:	beq.n	2fde <SPIClass::transfer(void const*, void*, unsigned int)+0x186>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    2fbc:	tst.w	r3, #1
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    2fc0:	ldr	r5, [r5, #56]	; 0x38
					if (count_read & 1) {
    2fc2:	beq.n	2fce <SPIClass::transfer(void const*, void*, unsigned int)+0x176>
						if (p_read) {
    2fc4:	cbz	r2, 2fca <SPIClass::transfer(void const*, void*, unsigned int)+0x172>
							*p_read++ = w;  // Read any pending RX bytes in
    2fc6:	strb	r5, [r2, #0]
    2fc8:	adds	r2, #1
						} 
						count_read--;
    2fca:	subs	r3, #1
    2fcc:	b.n	2fde <SPIClass::transfer(void const*, void*, unsigned int)+0x186>
					} else {
						if (p_read) {
    2fce:	cbz	r2, 2fdc <SPIClass::transfer(void const*, void*, unsigned int)+0x184>
							*p_read++ = (w & 0xff);
    2fd0:	mov	ip, r2
    2fd2:	strb.w	r5, [ip], #2
							*p_read++ = w >> 8;
    2fd6:	asrs	r5, r5, #8
    2fd8:	strb	r5, [r2, #1]
    2fda:	mov	r2, ip
						}
						count_read -= 2;
    2fdc:	subs	r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    2fde:	and.w	lr, lr, #61440	; 0xf000
    2fe2:	cmp	lr, r4
    2fe4:	bhi.n	2fb0 <SPIClass::transfer(void const*, void*, unsigned int)+0x158>
    2fe6:	b.n	2f7e <SPIClass::transfer(void const*, void*, unsigned int)+0x126>
    2fe8:	ldr	r1, [r0, #0]

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
    2fea:	ldr	r4, [r1, #44]	; 0x2c
			if (sr & 0xF0)  {
    2fec:	tst.w	r4, #240	; 0xf0
    2ff0:	bne.n	2ff8 <SPIClass::transfer(void const*, void*, unsigned int)+0x1a0>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    2ff2:	cmp	r3, #0
    2ff4:	bne.n	2fe8 <SPIClass::transfer(void const*, void*, unsigned int)+0x190>
    2ff6:	b.n	301a <SPIClass::transfer(void const*, void*, unsigned int)+0x1c2>
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
				if (count_read & 1) {
    2ff8:	lsls	r4, r3, #31

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    2ffa:	ldr	r1, [r1, #56]	; 0x38
				if (count_read & 1) {
    2ffc:	bpl.n	3008 <SPIClass::transfer(void const*, void*, unsigned int)+0x1b0>
					if (p_read)
    2ffe:	cbz	r2, 3004 <SPIClass::transfer(void const*, void*, unsigned int)+0x1ac>
						*p_read++ = w;  // Read any pending RX bytes in
    3000:	strb	r1, [r2, #0]
    3002:	adds	r2, #1
					count_read--;
    3004:	subs	r3, #1
    3006:	b.n	2ff2 <SPIClass::transfer(void const*, void*, unsigned int)+0x19a>
				} else {
					if (p_read) {
    3008:	cbz	r2, 3016 <SPIClass::transfer(void const*, void*, unsigned int)+0x1be>
						*p_read++ = (w & 0xff);
    300a:	mov	r4, r2
    300c:	strb.w	r1, [r4], #2
						*p_read++ = w >> 8;
    3010:	asrs	r1, r1, #8
    3012:	strb	r1, [r2, #1]
    3014:	mov	r2, r4
					}
					count_read -= 2;
    3016:	subs	r3, #2
    3018:	b.n	2ff2 <SPIClass::transfer(void const*, void*, unsigned int)+0x19a>
    301a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    301e:	nop
    3020:	.word	0x801f0400

00003024 <SPIClass::dma_rxisr()>:


//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
    3024:	push	{r4, r5, r6, lr}
    3026:	ldr	r3, [r0, #56]	; 0x38
    3028:	ldrb	r2, [r3, #4]
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    302a:	ldr	r3, [pc, #192]	; (30ec <SPIClass::dma_rxisr()+0xc8>)
    302c:	strb	r2, [r3, #0]
    302e:	ldr	r3, [r0, #52]	; 0x34
    3030:	ldrb	r2, [r3, #4]
	bool complete(void) {
		if (TCD->CSR & DMA_TCD_CSR_DONE) return true;
		return false;
	}
	void clearComplete(void) {
		DMA_CDNE = channel;
    3032:	ldr	r3, [pc, #188]	; (30f0 <SPIClass::dma_rxisr()+0xcc>)
    3034:	strb	r2, [r3, #0]
    3036:	ldr	r2, [r0, #56]	; 0x38
    3038:	ldrb	r2, [r2, #4]
    303a:	strb	r2, [r3, #0]
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
    303c:	ldr	r2, [r0, #48]	; 0x30


//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
    303e:	mov	r4, r0
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
    3040:	cmp	r2, #0
    3042:	beq.n	30c4 <SPIClass::dma_rxisr()+0xa0>
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
    3044:	ldr	r3, [r0, #4]
    3046:	ldr	r1, [r3, #12]
    3048:	cmp	r2, r1
    304a:	bls.n	3054 <SPIClass::dma_rxisr()+0x30>
			_dma_count_remaining -= hardware().max_dma_count;
    304c:	subs	r2, r2, r1
    304e:	str	r2, [r0, #48]	; 0x30
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    3050:	movs	r1, #1
    3052:	b.n	3076 <SPIClass::dma_rxisr()+0x52>
    3054:	ldr	r3, [r0, #52]	; 0x34
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
			_dma_count_remaining -= hardware().max_dma_count;
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
    3056:	subs	r1, r2, #1
    3058:	ldr	r0, [r3, #0]
    305a:	bl	2be8 <DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]>
    305e:	ldr	r3, [r4, #56]	; 0x38
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
    3060:	ldr	r1, [r4, #48]	; 0x30
    3062:	ldr	r0, [r3, #0]
    3064:	bl	2be8 <DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]>
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    3068:	ldr	r1, [r4, #48]	; 0x30
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    306a:	movs	r3, #0
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    306c:	adds.w	r1, r1, #4294967295
    3070:	it	ne
    3072:	movne	r1, #1
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    3074:	str	r3, [r4, #48]	; 0x30
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
    3076:	ldr	r3, [r4, #52]	; 0x34
    3078:	ldr	r3, [r3, #0]
    307a:	ldr	r0, [r3, #0]
    307c:	add.w	r2, r4, #44	; 0x2c
    3080:	cmp	r0, r2
    3082:	ldr	r2, [r4, #0]
    3084:	bne.n	3092 <SPIClass::dma_rxisr()+0x6e>
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    3086:	ldr	r3, [r2, #12]
    3088:	ldrb.w	r3, [r4, #44]	; 0x2c
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    308c:	orr.w	r3, r3, #2147483648	; 0x80000000
    3090:	b.n	30b0 <SPIClass::dma_rxisr()+0x8c>
			} else  {
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    3092:	ldr	r0, [r2, #12]
    3094:	tst.w	r0, #1073741824	; 0x40000000
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    3098:	ldr	r0, [r3, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    309a:	itete	ne
    309c:	ldrne	r5, [r3, #0]
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    309e:	ldreq	r5, [r3, #0]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    30a0:	ldrhne	r0, [r0, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
    30a2:	ldrbeq	r0, [r0, #0]
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    30a4:	ite	ne
    30a6:	addne	r5, #2
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    30a8:	addeq	r5, #1
    30aa:	str	r5, [r3, #0]
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    30ac:	orr.w	r3, r0, #2147483648	; 0x80000000
    30b0:	str	r3, [r2, #52]	; 0x34
    30b2:	ldr	r3, [r4, #56]	; 0x38
    30b4:	ldrb	r2, [r3, #4]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    30b6:	ldr	r3, [pc, #60]	; (30f4 <SPIClass::dma_rxisr()+0xd0>)
    30b8:	strb	r2, [r3, #0]
			}
		}
		_dmaRX->enable();
		if (should_reenable_tx)
    30ba:	cbz	r1, 30e8 <SPIClass::dma_rxisr()+0xc4>
    30bc:	ldr	r2, [r4, #52]	; 0x34
    30be:	ldrb	r2, [r2, #4]
    30c0:	strb	r2, [r3, #0]
    30c2:	pop	{r4, r5, r6, pc}
    30c4:	ldr	r3, [r0, #0]
			_dmaTX->enable();
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    30c6:	ldr	r1, [pc, #48]	; (30f8 <SPIClass::dma_rxisr()+0xd4>)
		_dmaRX->enable();
		if (should_reenable_tx)
			_dmaTX->enable();
	} else {

		port().RSER = 0;
    30c8:	str	r2, [r3, #48]	; 0x30
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    30ca:	str	r1, [r3, #44]	; 0x2c
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    30cc:	ldr	r1, [r3, #12]
    30ce:	bic.w	r1, r1, #1073741824	; 0x40000000
    30d2:	str	r1, [r3, #12]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    30d4:	movs	r3, #3
    30d6:	strb.w	r3, [r0, #45]	; 0x2d
		_dma_event_responder->triggerEvent();
    30da:	ldr	r0, [r0, #60]	; 0x3c
    30dc:	ldr	r3, [r0, #0]
    30de:	mov	r1, r2
    30e0:	ldr	r3, [r3, #0]

	}
}
    30e2:	ldmia.w	sp!, {r4, r5, r6, lr}
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    30e6:	bx	r3
    30e8:	pop	{r4, r5, r6, pc}
    30ea:	nop
    30ec:	.word	0x4000801f
    30f0:	.word	0x4000801c
    30f4:	.word	0x4000801b
    30f8:	.word	0xff0f0000

000030fc <_spi_dma_rxISR0()>:
};
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    30fc:	push	{r3, lr}
    30fe:	ldr	r0, [pc, #8]	; (3108 <_spi_dma_rxISR0()+0xc>)
    3100:	bl	3024 <SPIClass::dma_rxisr()>
    3104:	pop	{r3, pc}
    3106:	nop
    3108:	.word	0x1fff12f8

0000310c <SDClass::~SDClass()>:
	char *filename;
};



class SDClass : public FS
    310c:	bx	lr

0000310e <SDClass::exists(char const*)>:
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
		if (file) return File(new SDFile(file));
		return File();
	}
	bool exists(const char *filepath) {
    310e:	push	{lr}
    3110:	mov	r2, r1
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
    3112:	ldr.w	r1, [r0, #1156]	; 0x484
    3116:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->exists(path) : false;
    3118:	cbz	r1, 3130 <SDClass::exists(char const*)+0x22>
    311a:	movs	r3, #0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    311c:	mov	r0, sp
    311e:	strb.w	r3, [sp]
    3122:	strb.w	r3, [sp, #1]
    3126:	strb.w	r3, [sp, #2]
    312a:	bl	6394 <FatFile::open(FatVolume*, char const*, int)>
    312e:	b.n	314c <SDClass::exists(char const*)+0x3e>
    3130:	ldr.w	r0, [r0, #1160]	; 0x488
    3134:	cbz	r0, 314c <SDClass::exists(char const*)+0x3e>
    3136:	strb.w	r1, [sp, #49]	; 0x31
    313a:	strb.w	r1, [sp, #50]	; 0x32
    313e:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    3142:	mov	r3, r1
    3144:	mov	r1, r0
    3146:	mov	r0, sp
    3148:	bl	484e <ExFatFile::open(ExFatVolume*, char const*, int)>
		return sdfs.exists(filepath);
	}
    314c:	add	sp, #60	; 0x3c
    314e:	ldr.w	pc, [sp], #4

00003152 <SDClass::rmdir(char const*)>:
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
    3152:	push	{lr}
    3154:	mov	r2, r1
   * The subdirectory file will be removed only if it is empty.
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char *path) {
    return m_fVol ? m_fVol->rmdir(path) :
    3156:	ldr.w	r1, [r0, #1156]	; 0x484
    315a:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->rmdir(path) : false;
    315c:	cbz	r1, 317c <SDClass::rmdir(char const*)+0x2a>
    315e:	movs	r3, #0
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char* path) {
    FatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
    3160:	mov	r0, sp
    3162:	strb.w	r3, [sp]
    3166:	strb.w	r3, [sp, #1]
    316a:	strb.w	r3, [sp, #2]
    316e:	bl	6394 <FatFile::open(FatVolume*, char const*, int)>
    3172:	cbz	r0, 31a0 <SDClass::rmdir(char const*)+0x4e>
    3174:	mov	r0, sp
    3176:	bl	620c <FatFile::rmdir()>
    317a:	b.n	31a0 <SDClass::rmdir(char const*)+0x4e>
    317c:	ldr.w	r0, [r0, #1160]	; 0x488
    3180:	cbz	r0, 31a0 <SDClass::rmdir(char const*)+0x4e>
    3182:	strb.w	r1, [sp, #49]	; 0x31
    3186:	strb.w	r1, [sp, #50]	; 0x32
    318a:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char* path) {
    ExFatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
    318e:	mov	r3, r1
    3190:	mov	r1, r0
    3192:	mov	r0, sp
    3194:	bl	484e <ExFatFile::open(ExFatVolume*, char const*, int)>
    3198:	cbz	r0, 31a0 <SDClass::rmdir(char const*)+0x4e>
    319a:	mov	r0, sp
    319c:	bl	4e58 <ExFatFile::rmdir()>
		return sdfs.rmdir(filepath);
	}
    31a0:	add	sp, #60	; 0x3c
    31a2:	ldr.w	pc, [sp], #4

000031a6 <SDClass::remove(char const*)>:
		return sdfs.mkdir(filepath);
	}
	bool rename(const char *oldfilepath, const char *newfilepath) {
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
    31a6:	push	{lr}
    31a8:	mov	r2, r1
  * \param[in] path A path with a valid 8.3 DOS name for the file.
  *
   * \return true for success or false for failure.
  */
  bool remove(const char *path) {
    return m_fVol ? m_fVol->remove(path) :
    31aa:	ldr.w	r1, [r0, #1156]	; 0x484
    31ae:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->remove(path) : false;
    31b0:	cbz	r1, 31d2 <SDClass::remove(char const*)+0x2c>
    31b2:	movs	r3, #0
    31b4:	strb.w	r3, [sp]
    31b8:	strb.w	r3, [sp, #1]
    31bc:	strb.w	r3, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    31c0:	mov	r0, sp
    31c2:	movs	r3, #1
    31c4:	bl	6394 <FatFile::open(FatVolume*, char const*, int)>
    31c8:	cbz	r0, 31f6 <SDClass::remove(char const*)+0x50>
    31ca:	mov	r0, sp
    31cc:	bl	7408 <FatFile::remove()>
    31d0:	b.n	31f6 <SDClass::remove(char const*)+0x50>
    31d2:	ldr.w	r0, [r0, #1160]	; 0x488
    31d6:	cbz	r0, 31f6 <SDClass::remove(char const*)+0x50>
    31d8:	strb.w	r1, [sp, #49]	; 0x31
    31dc:	strb.w	r1, [sp, #50]	; 0x32
    31e0:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    31e4:	movs	r3, #1
    31e6:	mov	r1, r0
    31e8:	mov	r0, sp
    31ea:	bl	484e <ExFatFile::open(ExFatVolume*, char const*, int)>
    31ee:	cbz	r0, 31f6 <SDClass::remove(char const*)+0x50>
    31f0:	mov	r0, sp
    31f2:	bl	4dd2 <ExFatFile::remove()>
		return sdfs.remove(filepath);
	}
    31f6:	add	sp, #60	; 0x3c
    31f8:	ldr.w	pc, [sp], #4

000031fc <SDClass::mkdir(char const*)>:
		return File();
	}
	bool exists(const char *filepath) {
		return sdfs.exists(filepath);
	}
	bool mkdir(const char *filepath) {
    31fc:	push	{r4, lr}
   * \param[in] pFlag Create missing parent directories if true.
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
    31fe:	ldr.w	r4, [r0, #1156]	; 0x484
    3202:	sub	sp, #56	; 0x38
    3204:	mov	r2, r1
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
    3206:	cbz	r4, 3224 <SDClass::mkdir(char const*)+0x28>
    3208:	movs	r3, #0
    320a:	strb.w	r3, [sp]
    320e:	strb.w	r3, [sp, #1]
    3212:	strb.w	r3, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    3216:	add.w	r1, r4, #1096	; 0x448
    321a:	movs	r3, #1
    321c:	mov	r0, sp
    321e:	bl	6510 <FatFile::mkdir(FatFile*, char const*, bool)>
    3222:	b.n	3246 <SDClass::mkdir(char const*)+0x4a>
    3224:	ldr.w	r1, [r0, #1160]	; 0x488
    3228:	cbz	r1, 3244 <SDClass::mkdir(char const*)+0x48>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    322a:	movs	r3, #1
    322c:	add.w	r1, r1, #1096	; 0x448
    3230:	mov	r0, sp
    3232:	strb.w	r4, [sp, #49]	; 0x31
    3236:	strb.w	r4, [sp, #50]	; 0x32
    323a:	strb.w	r4, [sp, #51]	; 0x33
    323e:	bl	50f0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
    3242:	b.n	3246 <SDClass::mkdir(char const*)+0x4a>
    3244:	mov	r0, r1
		return sdfs.mkdir(filepath);
	}
    3246:	add	sp, #56	; 0x38
    3248:	pop	{r4, pc}

0000324a <SDClass::rename(char const*, char const*)>:
	bool rename(const char *oldfilepath, const char *newfilepath) {
    324a:	push	{r4, r5, lr}
   * a file object that was opened before the rename() call.
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    return m_fVol ? m_fVol->rename(oldPath, newPath) :
    324c:	ldr.w	r3, [r0, #1156]	; 0x484
    3250:	sub	sp, #60	; 0x3c
    3252:	mov	r5, r2
           m_xVol ? m_xVol->rename(oldPath, newPath) : false;
    3254:	cbz	r3, 3282 <SDClass::rename(char const*, char const*)+0x38>
    3256:	movs	r2, #0
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend FatFile;
  static FatVolume* cwv() {return m_cwv;}
  FatFile* vwd() {return &m_vwd;}
    3258:	add.w	r4, r3, #1096	; 0x448
    325c:	strb.w	r2, [sp]
    3260:	strb.w	r2, [sp, #1]
    3264:	strb.w	r2, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    FatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    3268:	mov	r3, r2
    326a:	mov	r0, sp
    326c:	mov	r2, r1
    326e:	mov	r1, r4
    3270:	bl	62ec <FatFile::open(FatFile*, char const*, int)>
    3274:	cbz	r0, 32ae <SDClass::rename(char const*, char const*)+0x64>
    3276:	mov	r2, r5
    3278:	mov	r1, r4
    327a:	mov	r0, sp
    327c:	bl	65ba <FatFile::rename(FatFile*, char const*)>
    3280:	b.n	32ae <SDClass::rename(char const*, char const*)+0x64>
    3282:	ldr.w	r0, [r0, #1160]	; 0x488
    3286:	cbz	r0, 32ae <SDClass::rename(char const*, char const*)+0x64>
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend ExFatFile;
  static ExFatVolume* cwv() {return m_cwv;}
  ExFatFile* vwd() {return &m_vwd;}
    3288:	add.w	r4, r0, #1096	; 0x448
   *
   * \return true for success or false for failure.
   */
  bool rename(const char* oldPath, const char* newPath) {
    ExFatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    328c:	mov	r2, r1
    328e:	mov	r0, sp
    3290:	mov	r1, r4
    3292:	strb.w	r3, [sp, #49]	; 0x31
    3296:	strb.w	r3, [sp, #50]	; 0x32
    329a:	strb.w	r3, [sp, #51]	; 0x33
    329e:	bl	4794 <ExFatFile::open(ExFatFile*, char const*, int)>
    32a2:	cbz	r0, 32ae <SDClass::rename(char const*, char const*)+0x64>
    32a4:	mov	r2, r5
    32a6:	mov	r1, r4
    32a8:	mov	r0, sp
    32aa:	bl	51ae <ExFatFile::rename(ExFatFile*, char const*)>
		return sdfs.rename(oldfilepath, newfilepath);
	}
    32ae:	add	sp, #60	; 0x3c
    32b0:	pop	{r4, r5, pc}

000032b2 <SDClass::totalSize()>:
	}
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
		  * (uint64_t)sdfs.bytesPerCluster();
	}
	uint64_t totalSize() {
    32b2:	mov	r3, r0
    32b4:	push	{r4, lr}
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    32b6:	ldr.w	r2, [r3, #1156]	; 0x484
		return (uint64_t)sdfs.clusterCount() * (uint64_t)sdfs.bytesPerCluster();
    32ba:	adds	r0, #4
           m_xVol ? m_xVol->clusterCount() : 0;
    32bc:	cbz	r2, 32c4 <SDClass::totalSize()+0x12>
    32be:	ldr	r4, [r2, #28]
    32c0:	subs	r4, #1
    32c2:	b.n	32ce <SDClass::totalSize()+0x1c>
    32c4:	ldr.w	r4, [r3, #1160]	; 0x488
    32c8:	cbz	r4, 32ce <SDClass::totalSize()+0x1c>
    32ca:	ldr.w	r4, [r4, #1072]	; 0x430
    32ce:	bl	19bc <FsVolume::bytesPerCluster() const>
	}
    32d2:	umull	r0, r1, r4, r0
    32d6:	pop	{r4, pc}

000032d8 <SDClass::usedSize()>:
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
		return sdfs.rmdir(filepath);
	}
	uint64_t usedSize() {
    32d8:	push	{r3, r4, r5, lr}
    32da:	mov	r3, r0
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
    32dc:	adds	r5, r0, #4
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    32de:	ldr.w	r0, [r0, #1156]	; 0x484
           m_xVol ? m_xVol->clusterCount() : 0;
    32e2:	cbz	r0, 32ee <SDClass::usedSize()+0x16>
    32e4:	ldr	r4, [r0, #28]
    32e6:	subs	r4, #1
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
    32e8:	bl	6c2c <FatPartition::freeClusterCount()>
    32ec:	b.n	3300 <SDClass::usedSize()+0x28>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    32ee:	ldr.w	r0, [r3, #1160]	; 0x488
    32f2:	cbz	r0, 32fe <SDClass::usedSize()+0x26>
    32f4:	ldr.w	r4, [r0, #1072]	; 0x430
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
           m_xVol ? m_xVol->freeClusterCount() : 0;
    32f8:	bl	4b50 <ExFatPartition::freeClusterCount()>
    32fc:	b.n	3300 <SDClass::usedSize()+0x28>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    32fe:	mov	r4, r0
    3300:	subs	r4, r4, r0
		  * (uint64_t)sdfs.bytesPerCluster();
    3302:	mov	r0, r5
    3304:	bl	19bc <FsVolume::bytesPerCluster() const>
	}
    3308:	umull	r0, r1, r4, r0
    330c:	pop	{r3, r4, r5, pc}

0000330e <SdBase<FsVolume>::begin(SdioConfig)>:
  /** Initialize SD card and file system for SDIO mode.
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    330e:	push	{r3, r4, r5, lr}
   * \param[in] config SDIO configuration.
   * \return generic card pointer or nullptr if SDIO is not supported.
   */
  SdCard* newCard(SdioConfig config) {
#if HAS_SDIO_CLASS
    m_sdioCard.begin(config);
    3310:	add.w	r5, r0, #1168	; 0x490
    3314:	mov	r4, r0
    spiConfigBackupPin = 255;
    3316:	movs	r3, #255	; 0xff
    3318:	strb.w	r3, [r0, #1200]	; 0x4b0
    sdioConfigBackup = sdioConfig;
    331c:	strb.w	r1, [r0, #1212]	; 0x4bc
    3320:	mov	r0, r5
    3322:	bl	88f8 <SdioCard::begin(SdioConfig)>
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdioConfig sdioConfig) {
    m_card = m_cardFactory.newCard(sdioConfig);
    3326:	str.w	r5, [r4, #1164]	; 0x48c
    return m_card && !m_card->errorCode();
    332a:	mov	r0, r5
    332c:	bl	80e4 <SdioCard::errorCode() const>
    3330:	cbnz	r0, 3340 <SdBase<FsVolume>::begin(SdioConfig)+0x32>
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
    3332:	ldr.w	r1, [r4, #1164]	; 0x48c
    3336:	mov	r0, r4
  }
    3338:	ldmia.w	sp!, {r3, r4, r5, lr}
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
    333c:	b.w	7620 <FsVolume::begin(BlockDeviceInterface*)>
  }
    3340:	movs	r0, #0
    3342:	pop	{r3, r4, r5, pc}

00003344 <SdBase<FsVolume>::cardBegin(SdSpiConfig)>:
  /** Initialize SD card in SPI mode.
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    3344:	push	{r4, r5, r6, lr}
    3346:	sub	sp, #32
    3348:	mov	r6, r0
    334a:	add	r0, sp, #4
    334c:	stmia.w	r0, {r1, r2, r3}
    3350:	ldmia	r0, {r0, r1, r2}
    3352:	add	r5, sp, #20
    3354:	stmia.w	r5, {r0, r1, r3}
   *
   * \param[in] config SPI configuration.
   * \return generic card pointer.
   */
  SdCard* newCard(SdSpiConfig config) {
    m_spiCard.begin(config);
    3358:	addw	r4, r6, #1180	; 0x49c
    335c:	ldmia.w	r5, {r1, r2, r3}
    3360:	mov	r0, r4
    3362:	bl	7a54 <SdSpiCard::begin(SdSpiConfig)>
    m_card = m_cardFactory.newCard(spiConfig);
    3366:	str.w	r4, [r6, #1164]	; 0x48c
    return m_card && !m_card->errorCode();
    336a:	cbz	r4, 3378 <SdBase<FsVolume>::cardBegin(SdSpiConfig)+0x34>
    336c:	ldrb.w	r0, [r6, #1195]	; 0x4ab
    3370:	clz	r0, r0
    3374:	lsrs	r0, r0, #5
    3376:	b.n	337a <SdBase<FsVolume>::cardBegin(SdSpiConfig)+0x36>
    3378:	mov	r0, r4
  }
    337a:	add	sp, #32
    337c:	pop	{r4, r5, r6, pc}

0000337e <SdBase<FsVolume>::restart()>:
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
  }
  //----------------------------------------------------------------------------
  /** Restart library with same config, used after media removed and replaced */
  bool restart() {
    337e:	push	{r4, r5, lr}
    if (spiConfigBackupPin == 255) {
    3380:	ldrb.w	r3, [r0, #1200]	; 0x4b0
    3384:	cmp	r3, #255	; 0xff
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
  }
  //----------------------------------------------------------------------------
  /** Restart library with same config, used after media removed and replaced */
  bool restart() {
    3386:	sub	sp, #20
    3388:	mov	r4, r0
    if (spiConfigBackupPin == 255) {
    338a:	bne.n	3396 <SdBase<FsVolume>::restart()+0x18>
      return begin(sdioConfigBackup);
    338c:	ldrb.w	r1, [r0, #1212]	; 0x4bc
    3390:	bl	330e <SdBase<FsVolume>::begin(SdioConfig)>
    3394:	b.n	33ca <SdBase<FsVolume>::restart()+0x4c>
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
    3396:	ldr.w	r1, [r0, #1204]	; 0x4b4
    339a:	ldr.w	r2, [r0, #1208]	; 0x4b8
    339e:	ldrb.w	r5, [r0, #1201]	; 0x4b1
    33a2:	strb.w	r3, [sp, #4]
    33a6:	strb.w	r5, [sp, #5]
    33aa:	str	r1, [sp, #8]
    33ac:	str	r2, [sp, #12]
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    33ae:	add	r3, sp, #16
    33b0:	ldmdb	r3, {r1, r2, r3}
    33b4:	bl	3344 <SdBase<FsVolume>::cardBegin(SdSpiConfig)>
    33b8:	cbz	r0, 33ca <SdBase<FsVolume>::restart()+0x4c>
    33ba:	ldr.w	r1, [r4, #1164]	; 0x48c
    33be:	mov	r0, r4
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
      return begin(spiConfig);
    }
  }
    33c0:	add	sp, #20
    33c2:	ldmia.w	sp!, {r4, r5, lr}
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    33c6:	b.w	7620 <FsVolume::begin(BlockDeviceInterface*)>
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
      return begin(spiConfig);
    }
  }
    33ca:	add	sp, #20
    33cc:	pop	{r4, r5, pc}

000033ce <SDClass::format(int, char, Print&)>:
	}
}
#endif

bool SDClass::format(int type, char progressChar, Print& pr)
{
    33ce:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    33d2:	ldr.w	r4, [r0, #1168]	; 0x490
    33d6:	sub	sp, #48	; 0x30
    33d8:	mov	r6, r0
    33da:	mov	r7, r3
	SdCard *card = sdfs.card();
	if (!card) return false; // no SD card
    33dc:	cbnz	r4, 33e2 <SDClass::format(int, char, Print&)+0x14>
    33de:	movs	r0, #0
    33e0:	b.n	342c <SDClass::format(int, char, Print&)+0x5e>
	uint32_t sectors = card->sectorCount();
    33e2:	ldr	r3, [r4, #0]
    33e4:	mov	r0, r4
    33e6:	ldr	r3, [r3, #24]
    33e8:	blx	r3
	if (sectors <= 12288) return false; // card too small
    33ea:	cmp.w	r0, #12288	; 0x3000

bool SDClass::format(int type, char progressChar, Print& pr)
{
	SdCard *card = sdfs.card();
	if (!card) return false; // no SD card
	uint32_t sectors = card->sectorCount();
    33ee:	mov	r8, r0
	if (sectors <= 12288) return false; // card too small
    33f0:	bls.n	33de <SDClass::format(int, char, Print&)+0x10>
	uint8_t *buf = (uint8_t *)malloc(512);
    33f2:	mov.w	r0, #512	; 0x200
    33f6:	bl	b340 <malloc>
	if (!buf) return false; // unable to allocate memory
    33fa:	mov	r5, r0
    33fc:	cmp	r0, #0
    33fe:	beq.n	33de <SDClass::format(int, char, Print&)+0x10>
	bool ret;
	if (sectors > 67108864) {
    3400:	cmp.w	r8, #67108864	; 0x4000000
#ifdef __arm__
		ExFatFormatter exFatFormatter;
		ret = exFatFormatter.format(card, buf, &pr);
    3404:	mov	r2, r0
    3406:	mov	r3, r7
    3408:	mov	r1, r4
    340a:	add	r0, sp, #4
	uint32_t sectors = card->sectorCount();
	if (sectors <= 12288) return false; // card too small
	uint8_t *buf = (uint8_t *)malloc(512);
	if (!buf) return false; // unable to allocate memory
	bool ret;
	if (sectors > 67108864) {
    340c:	bls.n	3414 <SDClass::format(int, char, Print&)+0x46>
#ifdef __arm__
		ExFatFormatter exFatFormatter;
		ret = exFatFormatter.format(card, buf, &pr);
    340e:	bl	3ae0 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>
    3412:	b.n	3418 <SDClass::format(int, char, Print&)+0x4a>
#else
		ret = false;
#endif
	} else {
		FatFormatter fatFormatter;
		ret = fatFormatter.format(card, buf, &pr);
    3414:	bl	5a68 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>
    3418:	mov	r4, r0
	}
	free(buf);
    341a:	mov	r0, r5
    341c:	bl	b350 <free>
	if (ret) {
    3420:	cmp	r4, #0
    3422:	beq.n	33de <SDClass::format(int, char, Print&)+0x10>
		// TODO: Is begin() really necessary?  Is a quicker way possible?
		sdfs.restart(); // TODO: is sdfs.volumeBegin() enough??
    3424:	adds	r0, r6, #4
    3426:	bl	337e <SdBase<FsVolume>::restart()>
    342a:	movs	r0, #1
	}
	return ret;
}
    342c:	add	sp, #48	; 0x30
    342e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00003432 <SDClass::mediaPresent()>:
	}
	return false;
}

bool SDClass::mediaPresent()
{
    3432:	push	{r4, r5, lr}
    3434:	ldr.w	r4, [r0, #1168]	; 0x490
    3438:	sub	sp, #20
    343a:	mov	r5, r0
	//Serial.print("mediaPresent: ");
	bool ret;
	SdCard *card = sdfs.card();
	if (card) {
    343c:	cbz	r4, 347c <SDClass::mediaPresent()+0x4a>
		if (cardPreviouslyPresent) {
    343e:	ldrb.w	r3, [r0, #1220]	; 0x4c4
    3442:	cbz	r3, 3474 <SDClass::mediaPresent()+0x42>
			#ifdef BUILTIN_SDCARD
			uint32_t s;
			if (csPin_ == BUILTIN_SDCARD) {
    3444:	ldrb.w	r3, [r0, #1221]	; 0x4c5
    3448:	cmp	r3, #254	; 0xfe
    344a:	beq.n	3458 <SDClass::mediaPresent()+0x26>
			const uint32_t s = 0xFFFFFFFF;
			#endif
			if (s == 0xFFFFFFFF) {
				// SPI doesn't have 32 bit status, read CID register
				cid_t cid;
				ret = card->readCID(&cid);
    344c:	ldr	r3, [r4, #0]
    344e:	mov	r1, sp
    3450:	ldr	r3, [r3, #56]	; 0x38
    3452:	mov	r0, r4
    3454:	blx	r3
    3456:	b.n	347e <SDClass::mediaPresent()+0x4c>
		if (cardPreviouslyPresent) {
			#ifdef BUILTIN_SDCARD
			uint32_t s;
			if (csPin_ == BUILTIN_SDCARD) {
				#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
				card->syncDevice();
    3458:	ldr	r3, [r4, #0]
    345a:	mov	r0, r4
    345c:	ldr	r3, [r3, #28]
    345e:	blx	r3
				#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
				s = card->status();
    3460:	ldr	r3, [r4, #0]
    3462:	mov	r0, r4
    3464:	ldr	r3, [r3, #68]	; 0x44
    3466:	blx	r3
			} else s = 0xFFFFFFFF;
			#else
			const uint32_t s = 0xFFFFFFFF;
			#endif
			if (s == 0xFFFFFFFF) {
    3468:	adds	r3, r0, #1
    346a:	beq.n	344c <SDClass::mediaPresent()+0x1a>
				// SPI doesn't have 32 bit status, read CID register
				cid_t cid;
				ret = card->readCID(&cid);
				//Serial.print(ret ? "CID=ok" : "CID=unreadable");
			} else if (s == 0) {
    346c:	adds	r0, #0
    346e:	it	ne
    3470:	movne	r0, #1
    3472:	b.n	347e <SDClass::mediaPresent()+0x4c>
			if ((csPin_ == BUILTIN_SDCARD) && !digitalReadFast(_SD_DAT3))
				ret = false;
			else
			#endif
			{
				ret = sdfs.restart();
    3474:	adds	r0, #4
    3476:	bl	337e <SdBase<FsVolume>::restart()>
    347a:	b.n	347e <SDClass::mediaPresent()+0x4c>
			}
			//Serial.print(ret ? "begin ok" : "begin nope");
		}
	} else {
		//Serial.print("no card");
		ret = false;
    347c:	mov	r0, r4
	}
	//Serial.println();
	cardPreviouslyPresent = ret;
    347e:	strb.w	r0, [r5, #1220]	; 0x4c4
	return ret;
}
    3482:	add	sp, #20
    3484:	pop	{r4, r5, pc}
    3486:	Address 0x00003486 is out of bounds.


00003488 <_GLOBAL__sub_I_SD>:


class SDClass : public FS
{
public:
	SDClass() { }
    3488:	ldr	r0, [pc, #72]	; (34d4 <_GLOBAL__sub_I_SD+0x4c>)
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    348a:	ldr	r2, [pc, #76]	; (34d8 <_GLOBAL__sub_I_SD+0x50>)
    348c:	str.w	r2, [r0, #1172]	; 0x494
    3490:	ldr	r2, [pc, #72]	; (34dc <_GLOBAL__sub_I_SD+0x54>)
    3492:	ldr	r3, [pc, #76]	; (34e0 <_GLOBAL__sub_I_SD+0x58>)
    3494:	str.w	r2, [r0, #1184]	; 0x4a0
    3498:	movs	r2, #1
    349a:	str	r3, [r0, #0]
    349c:	strb.w	r2, [r0, #1197]	; 0x4ad
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() {}
    34a0:	movs	r3, #0
    34a2:	movs	r2, #41	; 0x29
    34a4:	str.w	r3, [r0, #1156]	; 0x484
    34a8:	str.w	r3, [r0, #1160]	; 0x488
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    34ac:	strb.w	r3, [r0, #1180]	; 0x49c
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    34b0:	strb.w	r3, [r0, #1181]	; 0x49d
    34b4:	strb.w	r2, [r0, #1199]	; 0x4af
    34b8:	strb.w	r3, [r0, #1202]	; 0x4b2
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    34bc:	strb.w	r3, [r0, #1216]	; 0x4c0
    34c0:	strb.w	r3, [r0, #1220]	; 0x4c4
 */

#include <Arduino.h>
#include <SD.h>

SDClass SD;
    34c4:	ldr	r2, [pc, #28]	; (34e4 <_GLOBAL__sub_I_SD+0x5c>)
    34c6:	ldr	r1, [pc, #32]	; (34e8 <_GLOBAL__sub_I_SD+0x60>)
    34c8:	movs	r3, #255	; 0xff
    34ca:	strb.w	r3, [r0, #1221]	; 0x4c5
    34ce:	b.w	a54c <__aeabi_atexit>
    34d2:	nop
    34d4:	.word	0x2001a1c8
    34d8:	.word	0x00012e30
    34dc:	.word	0x00012dd0
    34e0:	.word	0x00012ad0
    34e4:	.word	0x1fff0f30
    34e8:	.word	0x0000310d

000034ec <FsUtf::cpToMb(unsigned long, char*, char*)>:
#include "FsUtf.h"
namespace FsUtf {
  //----------------------------------------------------------------------------
  char* cpToMb(uint32_t cp, char* str, char* end) {
    size_t n = end - str;
    if (cp < 0X80) {
    34ec:	cmp	r0, #127	; 0x7f
 */
#include "FsUtf.h"
namespace FsUtf {
  //----------------------------------------------------------------------------
  char* cpToMb(uint32_t cp, char* str, char* end) {
    size_t n = end - str;
    34ee:	sub.w	r2, r2, r1
    if (cp < 0X80) {
    34f2:	bhi.n	34fe <FsUtf::cpToMb(unsigned long, char*, char*)+0x12>
      if (n < 1) goto fail;
    34f4:	cmp	r2, #0
    34f6:	beq.n	3578 <FsUtf::cpToMb(unsigned long, char*, char*)+0x8c>
      *(str++) = static_cast<uint8_t>(cp);
    34f8:	strb	r0, [r1, #0]
    34fa:	adds	r0, r1, #1
    34fc:	bx	lr
    } else if (cp < 0X800) {
    34fe:	cmp.w	r0, #2048	; 0x800
    3502:	bcs.n	3520 <FsUtf::cpToMb(unsigned long, char*, char*)+0x34>
      if (n < 2) goto fail;
    3504:	cmp	r2, #1
    3506:	bls.n	357c <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    3508:	lsrs	r3, r0, #6
    350a:	mov	r2, r1
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    350c:	and.w	r0, r0, #63	; 0x3f
    if (cp < 0X80) {
      if (n < 1) goto fail;
      *(str++) = static_cast<uint8_t>(cp);
    } else if (cp < 0X800) {
      if (n < 2) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    3510:	orn	r3, r3, #63	; 0x3f
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    3514:	orn	r0, r0, #127	; 0x7f
    if (cp < 0X80) {
      if (n < 1) goto fail;
      *(str++) = static_cast<uint8_t>(cp);
    } else if (cp < 0X800) {
      if (n < 2) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    3518:	strb.w	r3, [r2], #2
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    351c:	strb	r0, [r1, #1]
    351e:	b.n	3578 <FsUtf::cpToMb(unsigned long, char*, char*)+0x8c>
    } else if (cp < 0X10000) {
    3520:	cmp.w	r0, #65536	; 0x10000
    3524:	bcs.n	354a <FsUtf::cpToMb(unsigned long, char*, char*)+0x5e>
      if (n < 3) goto fail;
    3526:	cmp	r2, #2
    3528:	bls.n	357c <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 12)         | 0XE0);
    352a:	lsrs	r3, r0, #12
    352c:	orn	r3, r3, #31
    3530:	strb	r3, [r1, #0]
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    3532:	ubfx	r3, r0, #6, #6
    3536:	orn	r3, r3, #127	; 0x7f
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    353a:	and.w	r0, r0, #63	; 0x3f
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    } else if (cp < 0X10000) {
      if (n < 3) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 12)         | 0XE0);
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    353e:	strb	r3, [r1, #1]
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    3540:	orn	r3, r0, #127	; 0x7f
    3544:	strb	r3, [r1, #2]
    3546:	adds	r0, r1, #3
    3548:	bx	lr
    } else {
       if (n < 4) goto fail;
    354a:	cmp	r2, #3
    354c:	bls.n	357c <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 18)         | 0XF0);
    354e:	lsrs	r3, r0, #18
    3550:	orn	r3, r3, #15
    3554:	strb	r3, [r1, #0]
      *(str++) = static_cast<uint8_t>(((cp >> 12) & 0X3F)| 0X80);
    3556:	ubfx	r3, r0, #12, #6
    355a:	orn	r3, r3, #127	; 0x7f
    355e:	strb	r3, [r1, #1]
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    3560:	ubfx	r3, r0, #6, #6
    3564:	orn	r3, r3, #127	; 0x7f
    3568:	strb	r3, [r1, #2]
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    356a:	and.w	r3, r0, #63	; 0x3f
    356e:	orn	r3, r3, #127	; 0x7f
    3572:	strb	r3, [r1, #3]
    3574:	adds	r0, r1, #4
    3576:	bx	lr
    }
    return str;

   fail:
    return nullptr;
    3578:	mov	r0, r2
    357a:	bx	lr
    357c:	movs	r0, #0
  }
    357e:	bx	lr

00003580 <FsUtf::mbToCp(char const*, char const*, unsigned long*)>:
  //----------------------------------------------------------------------------
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    size_t n;
    uint32_t cp;
    if (str >= end) {
    3580:	cmp	r0, r1
   fail:
    return nullptr;
  }
  //----------------------------------------------------------------------------
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    3582:	push	{r4, r5, lr}
    size_t n;
    uint32_t cp;
    if (str >= end) {
    3584:	bcs.n	35f4 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
      return nullptr;
    }
    uint8_t ch = str[0];
    3586:	ldrb	r3, [r0, #0]
    if ((ch & 0X80) == 0) {
    3588:	lsls	r4, r3, #24
    358a:	bmi.n	3592 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x12>
      *rtn = ch;
    358c:	str	r3, [r2, #0]
      return str + 1;
    358e:	adds	r4, r0, #1
    3590:	b.n	35fa <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x7a>
    }
    if ((ch & 0XE0) == 0XC0) {
    3592:	and.w	r4, r3, #224	; 0xe0
    3596:	cmp	r4, #192	; 0xc0
    3598:	bne.n	35a2 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x22>
      cp = ch & 0X1F;
    359a:	and.w	r3, r3, #31
      n = 2;
    359e:	movs	r4, #2
    35a0:	b.n	35c0 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x40>
    } else if ((ch & 0XF0) == 0XE0) {
    35a2:	and.w	r4, r3, #240	; 0xf0
    35a6:	cmp	r4, #224	; 0xe0
    35a8:	bne.n	35b2 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x32>
      cp = ch & 0X0F;
    35aa:	and.w	r3, r3, #15
      n = 3;
    35ae:	movs	r4, #3
    35b0:	b.n	35c0 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x40>
    } else if ((ch & 0XF8) == 0XF0) {
    35b2:	and.w	r4, r3, #248	; 0xf8
    35b6:	cmp	r4, #240	; 0xf0
    35b8:	bne.n	35f4 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
      cp = ch & 0X07;
    35ba:	and.w	r3, r3, #7
      n = 4;
    35be:	movs	r4, #4
    } else {
      return nullptr;
    }
    if ((str + n) > end) {
    35c0:	add	r4, r0
    35c2:	cmp	r1, r4
    35c4:	bcc.n	35f4 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
    35c6:	adds	r0, #1
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
      ch = str[i];
    35c8:	ldrb.w	r1, [r0], #1
      if ((ch & 0XC0) != 0X80) {
    35cc:	and.w	r5, r1, #192	; 0xc0
    35d0:	cmp	r5, #128	; 0x80
    35d2:	bne.n	35f4 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
        return nullptr;
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    35d4:	and.w	r1, r1, #63	; 0x3f
      return nullptr;
    }
    if ((str + n) > end) {
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
    35d8:	cmp	r0, r4
      ch = str[i];
      if ((ch & 0XC0) != 0X80) {
        return nullptr;
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    35da:	orr.w	r3, r1, r3, lsl #6
      return nullptr;
    }
    if ((str + n) > end) {
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
    35de:	bne.n	35c8 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x48>
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    }
    // Don't allow over long as ASCII.
    if (cp < 0X80 || !isValidCp(cp)) {
    35e0:	ldr	r1, [pc, #28]	; (3600 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x80>)
    35e2:	sub.w	r0, r3, #128	; 0x80
    35e6:	cmp	r0, r1
    35e8:	bhi.n	35f4 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
  /** Check for a valid code point.
   * \param[in] cp code point.
   * \return true if valid else false.
   */
  inline bool isValidCp(uint32_t cp) {
    return cp <= 0x10FFFF && (cp < 0XD800 || cp > 0XDFFF);
    35ea:	sub.w	r1, r3, #55296	; 0xd800
    35ee:	cmp.w	r1, #2048	; 0x800
    35f2:	bcs.n	35f8 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x78>
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    size_t n;
    uint32_t cp;
    if (str >= end) {
      return nullptr;
    35f4:	movs	r4, #0
    35f6:	b.n	35fa <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x7a>
    }
    // Don't allow over long as ASCII.
    if (cp < 0X80 || !isValidCp(cp)) {
      return nullptr;
    }
    *rtn = cp;
    35f8:	str	r3, [r2, #0]
    return str + n;
  }
    35fa:	mov	r0, r4
    35fc:	pop	{r4, r5, pc}
    35fe:	nop
    3600:	.word	0x0010ff7f

00003604 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>:
#include "FsGetPartitionInfo.h"
namespace FsGetPartitionInfo {
  static const uint8_t mbdpGuid[16] PROGMEM = {0xA2, 0xA0, 0xD0, 0xEB, 0xE5, 0xB9, 0x33, 0x44, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7};

  voltype_t getPartitionInfo(BlockDeviceInterface *blockDev, uint8_t part, uint8_t *secBuf,
      uint32_t *pfirstLBA, uint32_t *psectorCount, uint32_t *pmbrLBA, uint8_t *pmbrPart) {
    3604:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3608:	add	r6, sp, #48	; 0x30
    360a:	mov	r5, r0
    360c:	mov	r4, r2
    360e:	mov	sl, r3
    3610:	ldmia.w	r6, {r6, r7, r8}
    uint32_t firstLBA;
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    3614:	str	r1, [sp, #4]
    3616:	cbnz	r1, 361c <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x18>
    3618:	movs	r0, #0
    361a:	b.n	37a4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    361c:	cmp.w	sl, #0
    3620:	beq.n	3618 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    part--; // zero base it.

    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    3622:	ldr	r3, [r0, #0]
    3624:	movs	r1, #0
    3626:	ldr	r3, [r3, #12]
    3628:	blx	r3
    362a:	cmp	r0, #0
    362c:	beq.n	3618 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    part--; // zero base it.
    362e:	ldr	r3, [sp, #4]
    3630:	add.w	r9, r3, #4294967295
    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    mbr = reinterpret_cast<MbrSector_t*>(secBuf);

    // First check for GPT vs MBR
    mp = &mbr->part[0];
    if (mp->type == 0xee) {
    3634:	ldrb.w	r3, [r4, #450]	; 0x1c2
    3638:	cmp	r3, #238	; 0xee
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    part--; // zero base it.
    363a:	uxtb.w	r9, r9
    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    mbr = reinterpret_cast<MbrSector_t*>(secBuf);

    // First check for GPT vs MBR
    mp = &mbr->part[0];
    if (mp->type == 0xee) {
    363e:	bne.n	36c0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xbc>
      // This is a GPT initialized Disk assume validation done earlier.
      if (!blockDev->readSector(1, secBuf)) return INVALID_VOL; 
    3640:	ldr	r3, [r5, #0]
    3642:	mov	r2, r4
    3644:	ldr	r3, [r3, #12]
    3646:	movs	r1, #1
    3648:	mov	r0, r5
    364a:	blx	r3
    364c:	cmp	r0, #0
    364e:	beq.n	3618 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      GPTPartitionHeader_t* gptph = reinterpret_cast<GPTPartitionHeader_t*>(secBuf);
      // Lets do a little validation of this data.
      if (!gptph || (memcmp(gptph->signature, F("EFI PART"), 8) != 0))  return INVALID_VOL;
    3650:	movs	r2, #8
    3652:	ldr	r1, [pc, #344]	; (37ac <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a8>)
    3654:	mov	r0, r4
    3656:	bl	b9a0 <memcmp>
    365a:	cmp	r0, #0
    365c:	bne.n	3618 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      uint32_t numberPartitions = getLe32(gptph->numberPartitions);
      if (part > numberPartitions)  return INVALID_VOL;
    365e:	ldr	r3, [r4, #80]	; 0x50
    3660:	cmp	r9, r3
    3662:	bhi.n	3618 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>

      // We will overload the mbr part to give clue where GPT data is stored for this volume
      uint32_t mbrLBA = 2 + (part >> 2);
    3664:	mov.w	r1, r9, asr #2
    3668:	adds	r1, #2
      uint8_t mbrPart = part & 0x3;
    366a:	and.w	r9, r9, #3
      if (pmbrLBA) *pmbrLBA = mbrLBA;
    366e:	cbz	r7, 3672 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x6e>
    3670:	str	r1, [r7, #0]
      if (pmbrPart) *pmbrPart =mbrPart;
    3672:	cmp.w	r8, #0
    3676:	beq.n	367c <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x78>
    3678:	strb.w	r9, [r8]
      if (!blockDev->readSector(mbrLBA, secBuf)) return INVALID_VOL; 
    367c:	ldr	r3, [r5, #0]
    367e:	mov	r2, r4
    3680:	ldr	r3, [r3, #12]
    3682:	mov	r0, r5
    3684:	blx	r3
    3686:	cmp	r0, #0
    3688:	beq.n	3618 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      GPTPartitionEntrySector_t *gptes = reinterpret_cast<GPTPartitionEntrySector_t*>(secBuf);
      GPTPartitionEntryItem_t *gptei = &gptes->items[mbrPart];

      // Mow extract the data...
      firstLBA = getLe64(gptei->firstLBA);
    368a:	mov.w	r0, r9, lsl #7
    368e:	add.w	r3, r0, #32
    3692:	ldr	r2, [r4, r3]
      sectorCount = 1 + getLe64(gptei->lastLBA) - getLe64(gptei->firstLBA);
    3694:	add.w	r3, r0, #40	; 0x28
    3698:	ldr	r3, [r4, r3]
    369a:	adds	r3, #1
    369c:	subs	r3, r3, r2
      if ((firstLBA == 0) && (sectorCount == 1)) return INVALID_VOL;
    369e:	cbnz	r2, 36a4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xa0>
    36a0:	cmp	r3, #1
    36a2:	beq.n	3618 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      
      *pfirstLBA = firstLBA;
    36a4:	str.w	r2, [sl]
      if (psectorCount) *psectorCount = sectorCount;
    36a8:	cbz	r6, 36ac <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xa8>
    36aa:	str	r3, [r6, #0]

      if (memcmp((uint8_t *)gptei->partitionTypeGUID, mbdpGuid, 16) != 0) return OTHER_VOL;
    36ac:	movs	r2, #16
    36ae:	ldr	r1, [pc, #256]	; (37b0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1ac>)
    36b0:	add	r0, r4
    36b2:	bl	b9a0 <memcmp>
    36b6:	cmp	r0, #0
    36b8:	ite	eq
    36ba:	moveq	r0, #3
    36bc:	movne	r0, #4
    36be:	b.n	37a4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    }
    // So we are now looking a MBR type setups. 
    // Extended support we need to walk through the partitions to see if there is an extended partition
    // that we need to walk into. 
    // short cut:
    if (part < 4) {
    36c0:	cmp.w	r9, #3
    36c4:	bhi.n	3706 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
      // try quick way through
      mp = &mbr->part[part];
      if (((mp->boot == 0) || (mp->boot == 0X80)) && (mp->type != 0) && (mp->type != 0xf)) {
    36c6:	add.w	r3, r4, r9, lsl #4
    36ca:	ldrb.w	r2, [r3, #446]	; 0x1be
    36ce:	lsls	r2, r2, #25
    36d0:	bne.n	3706 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
    36d2:	ldrb.w	r3, [r3, #450]	; 0x1c2
    36d6:	cbz	r3, 3706 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
    36d8:	cmp	r3, #15
    36da:	beq.n	3706 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
        *pfirstLBA = getLe32(mp->relativeSectors);
    36dc:	add.w	r3, r9, #28
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    36e0:	add.w	r4, r4, r3, lsl #4
    36e4:	ldr.w	r3, [r4, #6]
    36e8:	str.w	r3, [sl]
        if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
    36ec:	cbz	r6, 36f4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xf0>
    36ee:	ldr.w	r3, [r4, #10]
    36f2:	str	r3, [r6, #0]
        if (pmbrLBA) *pmbrLBA = 0;
    36f4:	cbz	r7, 36fa <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xf6>
    36f6:	movs	r3, #0
    36f8:	str	r3, [r7, #0]
        if (pmbrPart) *pmbrPart = part; // zero based. 
    36fa:	cmp.w	r8, #0
    36fe:	beq.n	3734 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x130>
    3700:	strb.w	r9, [r8]
    3704:	b.n	3734 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x130>
    3706:	mov	r1, r4
#include "FsGetPartitionInfo.h"
namespace FsGetPartitionInfo {
  static const uint8_t mbdpGuid[16] PROGMEM = {0xA2, 0xA0, 0xD0, 0xEB, 0xE5, 0xB9, 0x33, 0x44, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7};

  voltype_t getPartitionInfo(BlockDeviceInterface *blockDev, uint8_t part, uint8_t *secBuf,
      uint32_t *pfirstLBA, uint32_t *psectorCount, uint32_t *pmbrLBA, uint8_t *pmbrPart) {
    3708:	movs	r3, #0

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
      mp = &mbr->part[index_part];
      if ((mp->boot != 0 && mp->boot != 0X80) || mp->type == 0 || index_part > part) return INVALID_VOL;
    370a:	ldrb.w	r0, [r1, #446]	; 0x1be
    370e:	lsls	r0, r0, #25
    3710:	uxtb	r2, r3
    3712:	bne.n	3618 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    3714:	ldrb.w	r0, [r1, #450]	; 0x1c2
    3718:	cmp	r0, #0
    371a:	beq.w	3618 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    371e:	cmp	r9, r2
    3720:	bcc.w	3618 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      if (mp->type == 0xf) break;
    3724:	cmp	r0, #15
    3726:	beq.n	3738 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x134>
    3728:	adds	r3, #1
      }
    }  

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
    372a:	cmp	r3, #4
    372c:	add.w	r1, r1, #16
    3730:	bne.n	370a <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x106>
    3732:	b.n	3618 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      if (((mp->boot == 0) || (mp->boot == 0X80)) && (mp->type != 0) && (mp->type != 0xf)) {
        *pfirstLBA = getLe32(mp->relativeSectors);
        if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
        if (pmbrLBA) *pmbrLBA = 0;
        if (pmbrPart) *pmbrPart = part; // zero based. 
        return MBR_VOL;
    3734:	movs	r0, #1
    3736:	b.n	37a4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    }  

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
      mp = &mbr->part[index_part];
    3738:	add.w	r3, r4, r3, lsl #4
    373c:	adds	r2, #1
    373e:	ldr.w	r9, [r3, #454]	; 0x1c6
    3742:	uxtb.w	fp, r2
    if (index_part == 4) return INVALID_VOL; // no extended partition found. 

    // Our partition if it exists is in extended partition. 
    uint32_t next_mbr = getLe32(mp->relativeSectors);
    for(;;) {
      if (!blockDev->readSector(next_mbr, secBuf)) return INVALID_VOL;
    3746:	ldr	r3, [r5, #0]
    3748:	mov	r2, r4
    374a:	ldr	r3, [r3, #12]
    374c:	mov	r1, r9
    374e:	mov	r0, r5
    3750:	blx	r3
    3752:	cmp	r0, #0
    3754:	beq.w	3618 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      mbr = reinterpret_cast<MbrSector_t*>(secBuf);

      if (index_part == part) break; // should be at that entry
    3758:	ldr	r3, [sp, #4]
    375a:	cmp	r3, fp
    375c:	beq.n	377e <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x17a>
      // else we need to see if it points to others...
      mp = &mbr->part[1];
      uint32_t  relSec = getLe32(mp->relativeSectors);
      //Serial.printf("    Check for next: type: %u start:%u\n ", mp->type, volumeStartSector);
      if ((mp->type == 5) && relSec) {
    375e:	ldrb.w	r2, [r4, #466]	; 0x1d2
    3762:	ldr.w	r3, [r4, #470]	; 0x1d6
    3766:	cmp	r2, #5
    3768:	bne.w	3618 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    376c:	add.w	r2, fp, #1
    3770:	uxtb.w	fp, r2
    3774:	cmp	r3, #0
    3776:	beq.w	3618 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
        next_mbr = next_mbr + relSec;
    377a:	add	r9, r3

    if (index_part == 4) return INVALID_VOL; // no extended partition found. 

    // Our partition if it exists is in extended partition. 
    uint32_t next_mbr = getLe32(mp->relativeSectors);
    for(;;) {
    377c:	b.n	3746 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x142>
      } else return INVALID_VOL;
    }
   
    // If we are here than we should hopefully be at start of segment...
    mp = &mbr->part[0];
    *pfirstLBA = getLe32(mp->relativeSectors) + next_mbr;
    377e:	ldr.w	r3, [r4, #454]	; 0x1c6
    3782:	add	r3, r9
    3784:	str.w	r3, [sl]
    if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
    3788:	cbz	r6, 3790 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x18c>
    378a:	ldr.w	r3, [r4, #458]	; 0x1ca
    378e:	str	r3, [r6, #0]
    if (pmbrLBA) *pmbrLBA = next_mbr;
    3790:	cbz	r7, 3796 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x192>
    3792:	str.w	r9, [r7]
    if (pmbrPart) *pmbrPart = 0; // zero based. 
    3796:	cmp.w	r8, #0
    379a:	beq.n	37a2 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x19e>
    379c:	movs	r3, #0
    379e:	strb.w	r3, [r8]
    return EXT_VOL;
    37a2:	movs	r0, #2
  }
    37a4:	add	sp, #12
    37a6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    37aa:	nop
    37ac:	.word	0x00012b08
    37b0:	.word	0x00012af8

000037b4 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>:
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    37b4:	cmp.w	r1, #256	; 0x100
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsStructs.h"
// bgnLba = relSector;
// endLba = relSector + partSize - 1;
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba) {
    37b8:	push	{r4, r5, lr}
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    37ba:	bhi.n	37ca <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x16>
  if (capacityMB <= 16) {
    37bc:	cmp	r1, #16
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    37be:	mov.w	r4, #32
  if (capacityMB <= 16) {
    37c2:	bls.n	37ee <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x3a>
    numberOfHeads = 2;
  } else if (capacityMB <= 32) {
    37c4:	cmp	r1, #32
    37c6:	bls.n	37f2 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x3e>
    37c8:	b.n	37cc <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x18>
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    37ca:	movs	r4, #63	; 0x3f
  if (capacityMB <= 16) {
    numberOfHeads = 2;
  } else if (capacityMB <= 32) {
    numberOfHeads = 4;
  } else if (capacityMB <= 128) {
    37cc:	cmp	r1, #128	; 0x80
    37ce:	bls.n	37f6 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x42>
    numberOfHeads = 8;
  } else if (capacityMB <= 504) {
    37d0:	cmp.w	r1, #504	; 0x1f8
    37d4:	bls.n	37fa <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x46>
    numberOfHeads = 16;
  } else if (capacityMB <= 1008) {
    37d6:	cmp.w	r1, #1008	; 0x3f0
    37da:	bls.n	37fe <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x4a>
    numberOfHeads = 32;
  } else if (capacityMB <= 2016) {
    37dc:	cmp.w	r1, #2016	; 0x7e0
    37e0:	bls.n	3802 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x4e>
    numberOfHeads = 64;
  } else if (capacityMB <= 4032) {
    37e2:	cmp.w	r1, #4032	; 0xfc0
    numberOfHeads = 128;
  } else {
    numberOfHeads = 255;
    37e6:	ite	ls
    37e8:	movls	r3, #128	; 0x80
    37ea:	movhi	r3, #255	; 0xff
    37ec:	b.n	3804 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
  if (capacityMB <= 16) {
    numberOfHeads = 2;
    37ee:	movs	r3, #2
    37f0:	b.n	3804 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 32) {
    numberOfHeads = 4;
    37f2:	movs	r3, #4
    37f4:	b.n	3804 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 128) {
    numberOfHeads = 8;
    37f6:	movs	r3, #8
    37f8:	b.n	3804 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 504) {
    numberOfHeads = 16;
    37fa:	movs	r3, #16
    37fc:	b.n	3804 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 1008) {
    numberOfHeads = 32;
    37fe:	movs	r3, #32
    3800:	b.n	3804 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 2016) {
    numberOfHeads = 64;
    3802:	movs	r3, #64	; 0x40
  } else if (capacityMB <= 4032) {
    numberOfHeads = 128;
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
    3804:	smulbb	r3, r3, r4
    3808:	udiv	r5, r2, r3
  if (c <= 1023) {
    380c:	cmp.w	r5, #1024	; 0x400
    3810:	bcs.n	382a <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x76>
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
    3812:	udiv	r1, r2, r4
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    3816:	mls	r3, r3, r5, r2
    s = (lba % sectorsPerTrack) + 1;
    381a:	mls	r2, r4, r1, r2
    381e:	adds	r2, #1
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    3820:	udiv	r3, r3, r4
    s = (lba % sectorsPerTrack) + 1;
    3824:	uxtb	r2, r2
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    3826:	uxtb	r3, r3
    3828:	b.n	3832 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x7e>
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    h = 254;
    s = 63;
    382a:	movs	r2, #63	; 0x3f
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    h = 254;
    382c:	movs	r3, #254	; 0xfe
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    382e:	movw	r5, #1023	; 0x3ff
    h = 254;
    s = 63;
  }
  chs[0] = h;
    3832:	strb	r3, [r0, #0]
  chs[1] = ((c >> 2) & 0XC0) | s;
    3834:	lsrs	r3, r5, #2
    3836:	bic.w	r3, r3, #63	; 0x3f
    383a:	orrs	r2, r3
    383c:	strb	r2, [r0, #1]
  chs[2] = c;
    383e:	strb	r5, [r0, #2]
    3840:	pop	{r4, r5, pc}

00003842 <FsCache::sync()>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    3842:	push	{r3, r4, r5, r6, r7, lr}
  if (m_status & CACHE_STATUS_DIRTY) {
    3844:	ldrb	r3, [r0, #0]
    3846:	lsls	r2, r3, #31

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    3848:	mov	r4, r0
  if (m_status & CACHE_STATUS_DIRTY) {
    384a:	bpl.n	3888 <FsCache::sync()+0x46>
    if (!m_blockDev->writeSector(m_sector, m_buffer)) {
    384c:	ldr	r0, [r0, #4]
    384e:	ldr	r1, [r4, #12]
    3850:	ldr	r3, [r0, #0]
    3852:	add.w	r6, r4, #16
    3856:	ldr	r3, [r3, #32]
    3858:	mov	r2, r6
    385a:	blx	r3
    385c:	mov	r5, r0
    385e:	cbnz	r0, 3864 <FsCache::sync()+0x22>
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;

 fail:
  return false;
    3860:	movs	r5, #0
    3862:	b.n	388a <FsCache::sync()+0x48>
    if (!m_blockDev->writeSector(m_sector, m_buffer)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
    3864:	ldrb	r3, [r4, #0]
    3866:	lsls	r3, r3, #30
    3868:	bmi.n	3874 <FsCache::sync()+0x32>
      if (!m_blockDev->writeSector(sector, m_buffer)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
    386a:	ldrb	r3, [r4, #0]
    386c:	bic.w	r3, r3, #1
    3870:	strb	r3, [r4, #0]
    3872:	b.n	388a <FsCache::sync()+0x48>
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
      uint32_t sector = m_sector + m_mirrorOffset;
      if (!m_blockDev->writeSector(sector, m_buffer)) {
    3874:	adds	r0, r4, #4
    3876:	ldmia	r0, {r0, r1, r7}
    3878:	ldr	r3, [r0, #0]
    387a:	mov	r2, r6
    387c:	ldr	r3, [r3, #32]
    387e:	add	r1, r7
    3880:	blx	r3
    3882:	cmp	r0, #0
    3884:	bne.n	386a <FsCache::sync()+0x28>
    3886:	b.n	3860 <FsCache::sync()+0x1e>
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;
    3888:	movs	r5, #1

 fail:
  return false;
}
    388a:	mov	r0, r5
    388c:	pop	{r3, r4, r5, r6, r7, pc}

0000388e <FsCache::get(unsigned long, unsigned char)>:
#define DBG_FILE "FsCache.cpp"
#include "DebugMacros.h"
#include "FsCache.h"
//------------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
  if (!m_blockDev) {
    388e:	ldr	r3, [r0, #4]
 */
#define DBG_FILE "FsCache.cpp"
#include "DebugMacros.h"
#include "FsCache.h"
//------------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
    3890:	push	{r4, r5, r6, lr}
    3892:	mov	r4, r0
    3894:	mov	r6, r1
    3896:	mov	r5, r2
  if (!m_blockDev) {
    3898:	cbnz	r3, 389e <FsCache::get(unsigned long, unsigned char)+0x10>
  }
  m_status |= option & CACHE_STATUS_MASK;
  return m_buffer;

 fail:
  return nullptr;
    389a:	movs	r0, #0
    389c:	pop	{r4, r5, r6, pc}
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
  if (!m_blockDev) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_sector != sector) {
    389e:	ldr	r3, [r0, #12]
    38a0:	cmp	r3, r1
    38a2:	beq.n	38cc <FsCache::get(unsigned long, unsigned char)+0x3e>
    if (!sync()) {
    38a4:	bl	3842 <FsCache::sync()>
    38a8:	cmp	r0, #0
    38aa:	beq.n	389a <FsCache::get(unsigned long, unsigned char)+0xc>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
    38ac:	lsls	r3, r5, #29
    38ae:	bpl.n	38b8 <FsCache::get(unsigned long, unsigned char)+0x2a>
      if (!m_blockDev->readSector(sector, m_buffer)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status = 0;
    38b0:	movs	r3, #0
    38b2:	strb	r3, [r4, #0]
    m_sector = sector;
    38b4:	str	r6, [r4, #12]
    38b6:	b.n	38cc <FsCache::get(unsigned long, unsigned char)+0x3e>
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
      if (!m_blockDev->readSector(sector, m_buffer)) {
    38b8:	ldr	r0, [r4, #4]
    38ba:	ldr	r3, [r0, #0]
    38bc:	add.w	r2, r4, #16
    38c0:	ldr	r3, [r3, #12]
    38c2:	mov	r1, r6
    38c4:	blx	r3
    38c6:	cmp	r0, #0
    38c8:	bne.n	38b0 <FsCache::get(unsigned long, unsigned char)+0x22>
    38ca:	b.n	389a <FsCache::get(unsigned long, unsigned char)+0xc>
      }
    }
    m_status = 0;
    m_sector = sector;
  }
  m_status |= option & CACHE_STATUS_MASK;
    38cc:	ldrb	r3, [r4, #0]
    38ce:	mov	r0, r4
    38d0:	and.w	r5, r5, #3
    38d4:	orrs	r5, r3
    38d6:	strb.w	r5, [r0], #16
  return m_buffer;

 fail:
  return nullptr;
}
    38da:	pop	{r4, r5, r6, pc}

000038dc <toUpcase(unsigned short)>:
}
//------------------------------------------------------------------------------
uint16_t toUpcase(uint16_t chr) {
  uint16_t i, first;
  // Optimize for simple ASCII.
  if (chr < 127) {
    38dc:	cmp	r0, #126	; 0x7e
    }
  }
  return left;
}
//------------------------------------------------------------------------------
uint16_t toUpcase(uint16_t chr) {
    38de:	push	{r4, r5, lr}
  uint16_t i, first;
  // Optimize for simple ASCII.
  if (chr < 127) {
    38e0:	bhi.n	38f0 <toUpcase(unsigned short)+0x14>
    return chr - ('a' <= chr && chr <= 'z' ? 'a' - 'A' : 0);
    38e2:	sub.w	r3, r0, #97	; 0x61
    38e6:	cmp	r3, #25
    38e8:	ite	hi
    38ea:	movhi	r3, #0
    38ec:	movls	r3, #32
    38ee:	b.n	3932 <toUpcase(unsigned short)+0x56>
    38f0:	ldr	r5, [pc, #132]	; (3978 <toUpcase(unsigned short)+0x9c>)
    38f2:	movs	r4, #53	; 0x35
    38f4:	movs	r3, #0
//------------------------------------------------------------------------------
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    38f6:	subs	r2, r4, r3
    38f8:	cmp	r2, #1
    38fa:	ldr	r1, [pc, #124]	; (3978 <toUpcase(unsigned short)+0x9c>)
    38fc:	bls.n	3910 <toUpcase(unsigned short)+0x34>
    mid = left + (right - left)/2;
    38fe:	add.w	r2, r3, r2, lsr #1
    if (readTable16(table[mid].key) <= key) {
    3902:	ldrh.w	r1, [r5, r2, lsl #2]
    3906:	cmp	r1, r0
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    mid = left + (right - left)/2;
    3908:	ite	hi
    390a:	movhi	r4, r2
    390c:	movls	r3, r2
    390e:	b.n	38f6 <toUpcase(unsigned short)+0x1a>
  // Optimize for simple ASCII.
  if (chr < 127) {
    return chr - ('a' <= chr && chr <= 'z' ? 'a' - 'A' : 0);
  }
  i = searchPair16(reinterpret_cast<const pair16_t*>(mapTable), MAP_DIM, chr);
  first = readTable16(mapTable[i].base);
    3910:	uxth	r2, r3
    3912:	ldrh.w	r3, [r1, r2, lsl #2]
  if (first <= chr && (chr - first)  < readTable8(mapTable[i].count)) {
    3916:	cmp	r0, r3
    3918:	bcc.n	3946 <toUpcase(unsigned short)+0x6a>
    391a:	add.w	r2, r1, r2, lsl #2
    391e:	subs	r3, r0, r3
    3920:	ldrb	r1, [r2, #3]
    3922:	cmp	r3, r1
    3924:	bge.n	3946 <toUpcase(unsigned short)+0x6a>
    int8_t off = readTable8(mapTable[i].off);
    3926:	ldrsb.w	r2, [r2, #2]
    if (off == 1) {
    392a:	cmp	r2, #1
    392c:	bne.n	3936 <toUpcase(unsigned short)+0x5a>
      return chr - ((chr - first) & 1);
    392e:	and.w	r3, r3, #1
    3932:	subs	r0, r0, r3
    3934:	b.n	3942 <toUpcase(unsigned short)+0x66>
    }
    return chr + (off ? off : -0x1C60);
    3936:	cbz	r2, 393c <toUpcase(unsigned short)+0x60>
    3938:	uxth	r2, r2
    393a:	b.n	3940 <toUpcase(unsigned short)+0x64>
    393c:	movw	r2, #58272	; 0xe3a0
    3940:	add	r0, r2
    3942:	uxth	r0, r0
    3944:	pop	{r4, r5, pc}
    3946:	ldr	r5, [pc, #52]	; (397c <toUpcase(unsigned short)+0xa0>)
    3948:	movs	r4, #75	; 0x4b
    394a:	movs	r3, #0
//------------------------------------------------------------------------------
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    394c:	subs	r2, r4, r3
    394e:	cmp	r2, #1
    3950:	ldr	r1, [pc, #40]	; (397c <toUpcase(unsigned short)+0xa0>)
    3952:	bls.n	3966 <toUpcase(unsigned short)+0x8a>
    mid = left + (right - left)/2;
    3954:	add.w	r2, r3, r2, lsr #1
    if (readTable16(table[mid].key) <= key) {
    3958:	ldrh.w	r1, [r5, r2, lsl #2]
    395c:	cmp	r1, r0
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    mid = left + (right - left)/2;
    395e:	ite	hi
    3960:	movhi	r4, r2
    3962:	movls	r3, r2
    3964:	b.n	394c <toUpcase(unsigned short)+0x70>
      return chr - ((chr - first) & 1);
    }
    return chr + (off ? off : -0x1C60);
  }
  i = searchPair16(lookupTable, LOOKUP_DIM, chr);
  if (readTable16(lookupTable[i].key) == chr) {
    3966:	uxth	r3, r3
    3968:	ldrh.w	r2, [r1, r3, lsl #2]
    396c:	cmp	r2, r0
    return readTable16(lookupTable[i].val);
    396e:	itt	eq
    3970:	addeq.w	r3, r1, r3, lsl #2
    3974:	ldrheq	r0, [r3, #2]
  }
  return chr;
}
    3976:	pop	{r4, r5, pc}
    3978:	.word	0x00012c3e
    397c:	.word	0x00012b12

00003980 <FsName::get16()>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsName.h"
#include "FsUtf.h"
#if USE_UTF8_LONG_NAMES
uint16_t FsName::get16() {
    3980:	push	{r0, r1, r4, lr}
    3982:	mov	r4, r0
  uint16_t rtn;
  if (ls) {
    3984:	ldrh	r0, [r0, #12]
    3986:	cbz	r0, 398e <FsName::get16()+0xe>
    rtn = ls;
    ls = 0;
    3988:	movs	r3, #0
    398a:	strh	r3, [r4, #12]
    398c:	b.n	39c4 <FsName::get16()+0x44>
  } else if (next >= end) {
    398e:	ldr	r3, [r4, #4]
    3990:	ldr	r1, [r4, #8]
    3992:	cmp	r3, r1
    3994:	bcs.n	39c4 <FsName::get16()+0x44>
    rtn = 0;
  } else {
    uint32_t cp;
    const char* ptr = FsUtf::mbToCp(next, end, &cp);
    3996:	add	r2, sp, #4
    3998:	mov	r0, r3
    399a:	bl	3580 <FsUtf::mbToCp(char const*, char const*, unsigned long*)>
    if (!ptr) {
    399e:	cbz	r0, 39c0 <FsName::get16()+0x40>
      goto fail;
    }
    next = ptr;
    39a0:	str	r0, [r4, #4]
    if (cp <= 0XFFFF) {
    39a2:	ldr	r0, [sp, #4]
    39a4:	cmp.w	r0, #65536	; 0x10000
      rtn = cp;
    } else {
      ls = FsUtf::lowSurrogate(cp);
    39a8:	itttt	cs
    39aa:	ubfxcs	r3, r0, #0, #10
  /** High surrogate for a code point.
   * \param{in} cp code point.
   * \return high surrogate.
   */
  inline uint16_t highSurrogate(uint32_t cp) {
    return (cp >> 10) + (0XD800 - (0X10000 >> 10));
    39ae:	lsrcs	r0, r0, #10
    39b0:	subcs.w	r3, r3, #9216	; 0x2400
    39b4:	subcs.w	r0, r0, #10304	; 0x2840
    39b8:	it	cs
    39ba:	strhcs	r3, [r4, #12]
    39bc:	uxth	r0, r0
    39be:	b.n	39c4 <FsName::get16()+0x44>
    }
  }
  return rtn;

 fail:
  return 0XFFFF;
    39c0:	movw	r0, #65535	; 0xffff
}
    39c4:	add	sp, #8
    39c6:	pop	{r4, pc}

000039c8 <ExFatFormatter::syncUpcase()>:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::syncUpcase() {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    39c8:	ldr	r3, [r0, #8]
    39ca:	ubfx	r3, r3, #0, #9
 fail:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::syncUpcase() {
    39ce:	mov	r1, r0
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  if (!index) {
    39d0:	cbz	r3, 39ec <ExFatFormatter::syncUpcase()+0x24>
    return true;
  }
  for (size_t i = index; i < BYTES_PER_SECTOR; i++) {
    m_secBuf[i] = 0;
    39d2:	movs	r0, #0
    39d4:	ldr	r2, [r1, #16]
    39d6:	strb	r0, [r2, r3]
bool ExFatFormatter::syncUpcase() {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  if (!index) {
    return true;
  }
  for (size_t i = index; i < BYTES_PER_SECTOR; i++) {
    39d8:	adds	r3, #1
    39da:	cmp.w	r3, #512	; 0x200
    39de:	bne.n	39d4 <ExFatFormatter::syncUpcase()+0xc>
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
    39e0:	ldr	r0, [r1, #12]
    39e2:	ldr	r2, [r1, #16]
    39e4:	ldr	r3, [r0, #0]
    39e6:	ldr	r1, [r1, #0]
    39e8:	ldr	r3, [r3, #32]
    39ea:	bx	r3
}
    39ec:	movs	r0, #1
    39ee:	bx	lr

000039f0 <ExFatFormatter::writeUpcaseByte(unsigned char)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    39f0:	ldr	r2, [r0, #8]
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
    39f2:	mov	r3, r0
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    39f4:	ubfx	r2, r2, #0, #9
  m_secBuf[index] = b;
    39f8:	ldr	r0, [r0, #16]
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
    39fa:	push	{r4}
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  m_secBuf[index] = b;
    39fc:	strb	r1, [r0, r2]
  m_upcaseChecksum = exFatChecksum(m_upcaseChecksum, b);
    39fe:	ldr	r0, [r3, #4]
    3a00:	add.w	r1, r1, r0, ror #1
    3a04:	str	r1, [r3, #4]
  m_upcaseSize++;
    3a06:	ldr	r1, [r3, #8]
    3a08:	adds	r1, #1
    3a0a:	str	r1, [r3, #8]
  if (index == SECTOR_MASK) {
    3a0c:	movw	r1, #511	; 0x1ff
    3a10:	cmp	r2, r1
    3a12:	bne.n	3a2a <ExFatFormatter::writeUpcaseByte(unsigned char)+0x3a>
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
    3a14:	ldr	r0, [r3, #12]
    3a16:	ldr	r1, [r3, #0]
    3a18:	ldr	r2, [r0, #0]
    3a1a:	ldr	r4, [r2, #32]
    3a1c:	adds	r2, r1, #1
    3a1e:	str	r2, [r3, #0]
    3a20:	ldr	r2, [r3, #16]
    3a22:	mov	r3, r4
  }
  return true;
}
    3a24:	ldr.w	r4, [sp], #4
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  m_secBuf[index] = b;
  m_upcaseChecksum = exFatChecksum(m_upcaseChecksum, b);
  m_upcaseSize++;
  if (index == SECTOR_MASK) {
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
    3a28:	bx	r3
  }
  return true;
}
    3a2a:	movs	r0, #1
    3a2c:	ldr.w	r4, [sp], #4
    3a30:	bx	lr

00003a32 <ExFatFormatter::writeUpcaseUnicode(unsigned short)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
    3a32:	push	{r3, r4, r5, lr}
    3a34:	mov	r4, r1
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    3a36:	uxtb	r1, r1
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
  }
  return true;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
    3a38:	mov	r5, r0
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    3a3a:	bl	39f0 <ExFatFormatter::writeUpcaseByte(unsigned char)>
    3a3e:	cbz	r0, 3a4c <ExFatFormatter::writeUpcaseUnicode(unsigned short)+0x1a>
    3a40:	lsrs	r1, r4, #8
    3a42:	mov	r0, r5
}
    3a44:	ldmia.w	sp!, {r3, r4, r5, lr}
  }
  return true;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    3a48:	b.w	39f0 <ExFatFormatter::writeUpcaseByte(unsigned char)>
}
    3a4c:	pop	{r3, r4, r5, pc}

00003a4e <ExFatFormatter::writeUpcase(unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcase(uint32_t sector) {
    3a4e:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t n;
  uint32_t ns;
  uint32_t ch = 0;
  uint16_t uc;

  m_upcaseSize = 0;
    3a50:	movs	r4, #0
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;
    3a52:	stmia.w	r0, {r1, r4}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcase(uint32_t sector) {
    3a56:	mov	r7, r0
  uint32_t n;
  uint32_t ns;
  uint32_t ch = 0;
  uint16_t uc;

  m_upcaseSize = 0;
    3a58:	str	r4, [r0, #8]
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    uc = toUpcase(ch);
    3a5a:	uxth	r0, r4
    3a5c:	bl	38dc <toUpcase(unsigned short)>
    if (uc != ch) {
    3a60:	cmp	r0, r4
  m_upcaseSize = 0;
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    uc = toUpcase(ch);
    3a62:	mov	r6, r0
    if (uc != ch) {
    3a64:	beq.n	3a7c <ExFatFormatter::writeUpcase(unsigned long)+0x2e>
      if (!writeUpcaseUnicode(uc)) {
    3a66:	mov	r1, r0
    3a68:	mov	r0, r7
    3a6a:	bl	3a32 <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    3a6e:	cbz	r0, 3ada <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    3a70:	adds	r5, r4, #1

  m_upcaseSize = 0;
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    3a72:	cmp.w	r5, #65536	; 0x10000
    3a76:	bcs.n	3a90 <ExFatFormatter::writeUpcase(unsigned long)+0x42>
    3a78:	mov	r4, r5
    3a7a:	b.n	3a5a <ExFatFormatter::writeUpcase(unsigned long)+0xc>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
    3a7c:	adds	r5, r4, #1
    3a7e:	cmp.w	r5, #65536	; 0x10000
    3a82:	bcs.n	3a9a <ExFatFormatter::writeUpcase(unsigned long)+0x4c>
    3a84:	uxth	r0, r5
    3a86:	bl	38dc <toUpcase(unsigned short)>
    3a8a:	cmp	r5, r0
    3a8c:	bne.n	3a9a <ExFatFormatter::writeUpcase(unsigned long)+0x4c>
    3a8e:	b.n	3ad6 <ExFatFormatter::writeUpcase(unsigned long)+0x88>
          }
        }
      }
    }
  }
  if (!syncUpcase()) {
    3a90:	mov	r0, r7
  }
  return true;

 fail:
  return false;
}
    3a92:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
          }
        }
      }
    }
  }
  if (!syncUpcase()) {
    3a96:	b.w	39c8 <ExFatFormatter::syncUpcase()>
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
      ns = n - ch;
    3a9a:	subs	r4, r5, r4
      if (ns >= MINIMUM_UPCASE_SKIP) {
    3a9c:	cmp.w	r4, #512	; 0x200
    3aa0:	bcc.n	3abc <ExFatFormatter::writeUpcase(unsigned long)+0x6e>
        if (!writeUpcaseUnicode(0XFFFF) || !writeUpcaseUnicode(ns)) {
    3aa2:	movw	r1, #65535	; 0xffff
    3aa6:	mov	r0, r7
    3aa8:	bl	3a32 <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    3aac:	cbz	r0, 3ada <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
    3aae:	uxth	r1, r4
    3ab0:	mov	r0, r7
    3ab2:	bl	3a32 <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    3ab6:	cmp	r0, #0
    3ab8:	bne.n	3a72 <ExFatFormatter::writeUpcase(unsigned long)+0x24>
    3aba:	b.n	3ada <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
      ns = n - ch;
      if (ns >= MINIMUM_UPCASE_SKIP) {
    3abc:	mov	r4, r6
          DBG_FAIL_MACRO;
          goto fail;
        }
        ch = n;
      } else {
        while (ch < n) {
    3abe:	cmp	r5, r4
    3ac0:	bhi.n	3ac6 <ExFatFormatter::writeUpcase(unsigned long)+0x78>
    3ac2:	mov	r5, r4
    3ac4:	b.n	3a72 <ExFatFormatter::writeUpcase(unsigned long)+0x24>
          if (!writeUpcaseUnicode(ch++)) {
    3ac6:	uxth	r1, r4
    3ac8:	mov	r0, r7
    3aca:	bl	3a32 <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    3ace:	adds	r4, #1
    3ad0:	cmp	r0, #0
    3ad2:	bne.n	3abe <ExFatFormatter::writeUpcase(unsigned long)+0x70>
    3ad4:	b.n	3ada <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
    3ad6:	adds	r5, #1
    3ad8:	b.n	3a7e <ExFatFormatter::writeUpcase(unsigned long)+0x30>
  }
  return true;

 fail:
  return false;
}
    3ada:	movs	r0, #0
    3adc:	pop	{r3, r4, r5, r6, r7, pc}
    3ade:	Address 0x00003ade is out of bounds.


00003ae0 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>:
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    3ae0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3ae4:	mov	r7, r3
  uint32_t volumeLength;
  uint32_t sectorCount;
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
    3ae6:	mov	r3, r0
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    3ae8:	sub	sp, #28
  uint32_t volumeLength;
  uint32_t sectorCount;
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
    3aea:	str	r1, [r3, #12]
  m_secBuf = secBuf;
    3aec:	str	r2, [r3, #16]
  sectorCount = dev->sectorCount();
    3aee:	ldr	r3, [r1, #0]
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    3af0:	str	r0, [sp, #4]
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    3af2:	ldr	r3, [r3, #24]
    3af4:	mov	r0, r1
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    3af6:	mov	r5, r1
    3af8:	mov	r4, r2
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    3afa:	blx	r3
  // Min size is 512 MB
  if (sectorCount < 0X100000) {
    3afc:	cmp.w	r0, #1048576	; 0x100000
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    3b00:	mov	r9, r0
  // Min size is 512 MB
  if (sectorCount < 0X100000) {
    3b02:	bcs.n	3b14 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x34>
    writeMsg(pr, "Device is too small\r\n");
    3b04:	cmp	r7, #0
    3b06:	beq.w	3d2e <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x24e>
    3b0a:	ldr	r1, [pc, #584]	; (3d54 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x274>)
    3b0c:	mov	r0, r7
    3b0e:	bl	764 <Print::write(char const*)>
    3b12:	b.n	3d26 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x246>
    3b14:	movs	r6, #0
    3b16:	movs	r3, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
    3b18:	adds	r6, #1
    3b1a:	uxtb	r6, r6
    3b1c:	cmp	r6, #32
    3b1e:	mov.w	r3, r3, lsl #1
    3b22:	beq.n	3b30 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x50>
    3b24:	cmp	r9, r3
    3b26:	bhi.n	3b18 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x38>
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
    3b28:	cmp	r6, #28
    3b2a:	bhi.n	3b30 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x50>
    3b2c:	movs	r3, #8
    3b2e:	b.n	3b38 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x58>
    3b30:	sub.w	r8, r6, #11
    3b34:	ubfx	r3, r8, #1, #8
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
    3b38:	cmp	r6, #26
    3b3a:	it	hi
    3b3c:	addhi	r6, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
    3b3e:	str	r3, [sp, #8]
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
    3b40:	ittte	hi
    3b42:	asrhi	r6, r6, #1
    3b44:	movhi	r3, #1
    3b46:	lslhi	r3, r6
    3b48:	movls.w	r3, #8192	; 0x2000
    3b4c:	str	r3, [sp, #0]
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
    3b4e:	ldr	r3, [sp, #0]
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    3b50:	ldr	r2, [sp, #8]
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
    3b52:	lsls	r6, r3, #1
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
    3b54:	lsls	r3, r3, #2
    3b56:	rsb	sl, r3, r9
    3b5a:	str	r3, [sp, #16]
    3b5c:	ldr	r3, [sp, #8]
    3b5e:	lsr.w	r3, sl, r3
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    3b62:	lsl.w	sl, r3, r2

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3b66:	movs	r1, #0
    3b68:	mov.w	r2, #512	; 0x200
    3b6c:	mov	r0, r4
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
    3b6e:	str	r3, [sp, #12]
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3b70:	bl	90e4 <memset>
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
  mbr->part->type = 7;
    3b74:	movs	r3, #7
    3b76:	strb.w	r3, [r4, #450]	; 0x1c2
  mbr->part->endCHS[0] = 0XFE;
    3b7a:	movs	r3, #254	; 0xfe
    3b7c:	strb.w	r3, [r4, #451]	; 0x1c3
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
    3b80:	mov.w	fp, #1
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
  mbr->part->type = 7;
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
    3b84:	movs	r3, #255	; 0xff
  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
    3b86:	mov.w	r8, #0
  mbr->part->type = 7;
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
    3b8a:	strb.w	r3, [r4, #452]	; 0x1c4
  mbr->part->endCHS[2] = 0XFF;
    3b8e:	strb.w	r3, [r4, #453]	; 0x1c5
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
    3b92:	strb.w	fp, [r4, #447]	; 0x1bf
  mbr->part->beginCHS[1] = 1;
    3b96:	strb.w	fp, [r4, #448]	; 0x1c0
  mbr->part->beginCHS[2] = 0;
    3b9a:	strb.w	r8, [r4, #449]	; 0x1c1
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3b9e:	movw	r3, #43605	; 0xaa55
    3ba2:	strh.w	r3, [r4, #510]	; 0x1fe
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
  setLe32(mbr->part->relativeSectors, partitionOffset);
  setLe32(mbr->part->totalSectors, volumeLength);
  setLe16(mbr->signature, MBR_SIGNATURE);
  if (!dev->writeSector(0, secBuf)) {
    3ba6:	ldr	r3, [r5, #0]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3ba8:	str.w	r6, [r4, #454]	; 0x1c6
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    3bac:	add	sl, r6
    3bae:	str.w	sl, [r4, #458]	; 0x1ca
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
  setLe32(mbr->part->relativeSectors, partitionOffset);
  setLe32(mbr->part->totalSectors, volumeLength);
  setLe16(mbr->signature, MBR_SIGNATURE);
  if (!dev->writeSector(0, secBuf)) {
    3bb2:	ldr	r3, [r3, #32]
    3bb4:	mov	r2, r4
    3bb6:	mov	r1, r8
    3bb8:	mov	r0, r5
    3bba:	blx	r3
    3bbc:	cmp	r0, #0
    3bbe:	beq.w	3d24 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Partition Boot sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3bc2:	mov.w	r2, #512	; 0x200
    3bc6:	mov	r1, r8
    3bc8:	mov	r0, r4
    3bca:	bl	90e4 <memset>
  pbs = reinterpret_cast<ExFatPbs_t*>(secBuf);
  pbs->jmpInstruction[0] = 0XEB;
    3bce:	movs	r3, #235	; 0xeb
    3bd0:	strb	r3, [r4, #0]
  pbs->jmpInstruction[1] = 0X76;
    3bd2:	movs	r3, #118	; 0x76
    3bd4:	strb	r3, [r4, #1]
  pbs->jmpInstruction[2] = 0X90;
    3bd6:	movs	r3, #144	; 0x90
    3bd8:	strb	r3, [r4, #2]
  pbs->oemName[0] = 'E';
    3bda:	movs	r3, #69	; 0x45
    3bdc:	strb	r3, [r4, #3]
  pbs->oemName[1] = 'X';
    3bde:	movs	r3, #88	; 0x58
    3be0:	strb	r3, [r4, #4]
  pbs->oemName[2] = 'F';
    3be2:	movs	r3, #70	; 0x46
    3be4:	strb	r3, [r4, #5]
  pbs->oemName[3] = 'A';
    3be6:	movs	r3, #65	; 0x41
    3be8:	strb	r3, [r4, #6]
  pbs->oemName[4] = 'T';
    3bea:	movs	r3, #84	; 0x54
    3bec:	strb	r3, [r4, #7]
  pbs->oemName[5] = ' ';
    3bee:	movs	r3, #32
    3bf0:	strb	r3, [r4, #8]
  pbs->oemName[6] = ' ';
    3bf2:	strb	r3, [r4, #9]
  pbs->oemName[7] = ' ';
    3bf4:	strb	r3, [r4, #10]
    3bf6:	ldr	r3, [sp, #0]
    3bf8:	str	r3, [r4, #80]	; 0x50
    3bfa:	str	r3, [r4, #84]	; 0x54
    3bfc:	ldr	r3, [sp, #12]
    3bfe:	str	r3, [r4, #92]	; 0x5c
    3c00:	movs	r3, #4
    3c02:	str	r3, [r4, #96]	; 0x60
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3c04:	mov.w	r3, #256	; 0x100
    3c08:	strh.w	r3, [r4, #104]	; 0x68
  setLe32(pbs->bpb.clusterCount, clusterCount);
  setLe32(pbs->bpb.rootDirectoryCluster, ROOT_CLUSTER);
  setLe32(pbs->bpb.volumeSerialNumber, sectorCount);
  setLe16(pbs->bpb.fileSystemRevision, 0X100);
  setLe16(pbs->bpb.volumeFlags, 0);
  pbs->bpb.bytesPerSectorShift = BYTES_PER_SECTOR_SHIFT;
    3c0c:	movs	r3, #9
    3c0e:	strb.w	r3, [r4, #108]	; 0x6c
  pbs->bpb.sectorsPerClusterShift = sectorsPerClusterShift;
    3c12:	ldrb.w	r3, [sp, #8]
    3c16:	strb.w	r3, [r4, #109]	; 0x6d
  pbs->bpb.numberOfFats = 1;
  pbs->bpb.driveSelect = 0X80;
    3c1a:	movs	r3, #128	; 0x80
    3c1c:	strb.w	r3, [r4, #111]	; 0x6f

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    3c20:	str	r6, [r4, #64]	; 0x40
    3c22:	str.w	r8, [r4, #68]	; 0x44
    3c26:	str.w	sl, [r4, #72]	; 0x48
    3c2a:	str.w	r8, [r4, #76]	; 0x4c
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3c2e:	str	r6, [r4, #88]	; 0x58
    3c30:	str.w	r9, [r4, #100]	; 0x64
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3c34:	strh.w	r8, [r4, #106]	; 0x6a
  setLe32(pbs->bpb.volumeSerialNumber, sectorCount);
  setLe16(pbs->bpb.fileSystemRevision, 0X100);
  setLe16(pbs->bpb.volumeFlags, 0);
  pbs->bpb.bytesPerSectorShift = BYTES_PER_SECTOR_SHIFT;
  pbs->bpb.sectorsPerClusterShift = sectorsPerClusterShift;
  pbs->bpb.numberOfFats = 1;
    3c38:	strb.w	fp, [r4, #110]	; 0x6e
  pbs->bpb.driveSelect = 0X80;
  pbs->bpb.percentInUse = 0;
    3c3c:	strb.w	r8, [r4, #112]	; 0x70
    3c40:	add.w	r3, r4, #119	; 0x77
    3c44:	addw	r2, r4, #509	; 0x1fd

  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
    3c48:	movs	r1, #244	; 0xf4
    3c4a:	strb.w	r1, [r3, #1]!
  pbs->bpb.numberOfFats = 1;
  pbs->bpb.driveSelect = 0X80;
  pbs->bpb.percentInUse = 0;

  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    3c4e:	cmp	r3, r2
    3c50:	bne.n	3c4a <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x16a>
    3c52:	movw	r3, #43605	; 0xaa55
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    3c56:	mov.w	r9, #0
    3c5a:	strh.w	r3, [r4, #510]	; 0x1fe
  ExFatPbs_t* pbs;
  DirUpcase_t* dup;
  DirBitmap_t* dbm;
  DirLabel_t* label;
  uint32_t bitmapSize;
  uint32_t checksum = 0;
    3c5e:	mov	r8, r9
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    if (i == offsetof(ExFatPbs_t, bpb.volumeFlags[0]) ||
    3c60:	sub.w	r3, r9, #106	; 0x6a
    3c64:	cmp	r3, #1
    3c66:	bls.n	3c76 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x196>
        i == offsetof(ExFatPbs_t, bpb.volumeFlags[1]) ||
    3c68:	cmp.w	r9, #112	; 0x70
  uint8_t  mustBeZero2[2];
  uint8_t  unicode3[4];
} DirLfn_t;
//=============================================================================
inline uint32_t exFatChecksum(uint32_t sum, uint8_t data) {
  return (sum << 31) + (sum >> 1) + data;
    3c6c:	itt	ne
    3c6e:	ldrbne.w	r3, [r4, r9]
    3c72:	addne.w	r8, r3, r8, ror #1
  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    3c76:	add.w	r9, r9, #1
    3c7a:	cmp.w	r9, #512	; 0x200
    3c7e:	bne.n	3c60 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x180>
      continue;
    }
    checksum = exFatChecksum(checksum, secBuf[i]);
  }
  sector = partitionOffset;
  if (!dev->writeSector(sector, secBuf)  ||
    3c80:	ldr	r3, [r5, #0]
    3c82:	mov	r2, r4
    3c84:	ldr	r3, [r3, #32]
    3c86:	mov	r1, r6
    3c88:	mov	r0, r5
    3c8a:	blx	r3
    3c8c:	cmp	r0, #0
    3c8e:	beq.n	3d24 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3c90:	ldr	r3, [r5, #0]
    3c92:	mov	r2, r4
    3c94:	ldr	r3, [r3, #32]
    3c96:	add.w	r1, r6, #12
    3c9a:	mov	r0, r5
    3c9c:	blx	r3
      continue;
    }
    checksum = exFatChecksum(checksum, secBuf[i]);
  }
  sector = partitionOffset;
  if (!dev->writeSector(sector, secBuf)  ||
    3c9e:	cmp	r0, #0
    3ca0:	beq.n	3d24 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3ca2:	mov	r2, r9
    3ca4:	movs	r1, #0
    3ca6:	mov	r0, r4
    3ca8:	bl	90e4 <memset>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3cac:	movw	r3, #43605	; 0xaa55
    3cb0:	strh.w	r3, [r4, #510]	; 0x1fe
    3cb4:	subs	r3, r4, #1
  if (!dev->writeSector(sector, secBuf)  ||
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector++;
    3cb6:	add.w	sl, r6, #1
    3cba:	add.w	r9, r6, #9
    3cbe:	str	r3, [sp, #20]
    3cc0:	addw	fp, r4, #511	; 0x1ff
  ExFatPbs_t* pbs;
  DirUpcase_t* dup;
  DirBitmap_t* dbm;
  DirLabel_t* label;
  uint32_t bitmapSize;
  uint32_t checksum = 0;
    3cc4:	ldr	r3, [sp, #20]
  uint8_t  mustBeZero2[2];
  uint8_t  unicode3[4];
} DirLfn_t;
//=============================================================================
inline uint32_t exFatChecksum(uint32_t sum, uint8_t data) {
  return (sum << 31) + (sum >> 1) + data;
    3cc6:	ldrb.w	r2, [r3, #1]!
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    3cca:	cmp	fp, r3
    3ccc:	add.w	r8, r2, r8, ror #1
    3cd0:	bne.n	3cc6 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x1e6>
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    3cd2:	ldr	r3, [r5, #0]
    3cd4:	mov	r2, r4
    3cd6:	ldr	r3, [r3, #32]
    3cd8:	mov	r1, sl
    3cda:	mov	r0, r5
    3cdc:	blx	r3
    3cde:	cbz	r0, 3d24 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3ce0:	ldr	r3, [r5, #0]
    3ce2:	mov	r2, r4
    3ce4:	ldr	r3, [r3, #32]
    3ce6:	add.w	r1, sl, #12
    3cea:	mov	r0, r5
    3cec:	blx	r3
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    3cee:	cbz	r0, 3d24 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    sector++;
    3cf0:	add.w	sl, sl, #1
  }
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    3cf4:	cmp	sl, r9
    3cf6:	bne.n	3cc4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x1e4>
      goto fail;
    }
    sector++;
  }
  // Write OEM Parameter Sector and reserved sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3cf8:	mov.w	r2, #512	; 0x200
    3cfc:	movs	r1, #0
    3cfe:	mov	r0, r4
    3d00:	bl	90e4 <memset>
    3d04:	add.w	sl, r6, #11
    3d08:	ldr	r3, [sp, #20]
    3d0a:	ldrb.w	r2, [r3, #1]!
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    3d0e:	cmp	fp, r3
    3d10:	add.w	r8, r2, r8, ror #1
    3d14:	bne.n	3d0a <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x22a>
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    3d16:	ldr	r3, [r5, #0]
    3d18:	mov	r2, r4
    3d1a:	ldr	r3, [r3, #32]
    3d1c:	mov	r1, r9
    3d1e:	mov	r0, r5
    3d20:	blx	r3
    3d22:	cbnz	r0, 3d34 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x254>
  }
  writeMsg(pr, "Format done\r\n");
  return true;

 fail:
  writeMsg(pr, "Format failed\r\n");
    3d24:	cbz	r7, 3d2e <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x24e>
    3d26:	ldr	r1, [pc, #48]	; (3d58 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x278>)
    3d28:	mov	r0, r7
    3d2a:	bl	764 <Print::write(char const*)>
  return false;
    3d2e:	mov.w	sl, #0
    3d32:	b.n	3f18 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x438>
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3d34:	ldr	r3, [r5, #0]
    3d36:	mov	r2, r4
    3d38:	ldr	r3, [r3, #32]
    3d3a:	add.w	r1, r9, #12
    3d3e:	mov	r0, r5
    3d40:	blx	r3
  memset(secBuf, 0, BYTES_PER_SECTOR);
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    3d42:	cmp	r0, #0
    3d44:	beq.n	3d24 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    sector++;
    3d46:	add.w	r3, r9, #1
    }
    sector++;
  }
  // Write OEM Parameter Sector and reserved sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  for (int j = 0; j < 2; j++) {
    3d4a:	cmp	r3, sl
    3d4c:	beq.n	3d5c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x27c>
    3d4e:	mov	r9, r3
    3d50:	b.n	3d08 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x228>
    3d52:	nop
    3d54:	.word	0x00012d12
    3d58:	.word	0x00012d6b
    3d5c:	subs	r3, r4, #4
    3d5e:	add.w	r2, r4, #508	; 0x1fc
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3d62:	str.w	r8, [r3, #4]!
      goto fail;
    }
    sector++;
  }
  // Write Boot CheckSum Sector.
  for (size_t i = 0; i < BYTES_PER_SECTOR; i += 4) {
    3d66:	cmp	r2, r3
    3d68:	bne.n	3d62 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x282>
    setLe32(secBuf + i, checksum);
  }
  if (!dev->writeSector(sector, secBuf)  ||
    3d6a:	ldr	r3, [r5, #0]
    3d6c:	mov	r2, r4
    3d6e:	ldr	r3, [r3, #32]
    3d70:	mov	r1, sl
    3d72:	mov	r0, r5
    3d74:	blx	r3
    3d76:	cmp	r0, #0
    3d78:	beq.n	3d24 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3d7a:	ldr	r3, [r5, #0]
    3d7c:	mov	r2, r4
    3d7e:	ldr	r3, [r3, #32]
    3d80:	add.w	r1, r9, #13
    3d84:	mov	r0, r5
    3d86:	blx	r3
  }
  // Write Boot CheckSum Sector.
  for (size_t i = 0; i < BYTES_PER_SECTOR; i += 4) {
    setLe32(secBuf + i, checksum);
  }
  if (!dev->writeSector(sector, secBuf)  ||
    3d88:	cmp	r0, #0
    3d8a:	beq.n	3d24 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
    3d8c:	cbz	r7, 3d96 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2b6>
    3d8e:	ldr	r1, [pc, #400]	; (3f20 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x440>)
    3d90:	mov	r0, r7
    3d92:	bl	764 <Print::write(char const*)>
  sector = partitionOffset + fatOffset;
    3d96:	ldr	r3, [sp, #0]
    3d98:	add	r6, r3
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3d9a:	ldr	r3, [sp, #12]

  memset(secBuf, 0, BYTES_PER_SECTOR);
    3d9c:	mov.w	r2, #512	; 0x200
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3da0:	mov.w	r9, r3, lsl #2

  memset(secBuf, 0, BYTES_PER_SECTOR);
    3da4:	movs	r1, #0
    3da6:	mov	r0, r4
    3da8:	bl	90e4 <memset>
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3dac:	addw	r9, r9, #519	; 0x207

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
    3db0:	movs	r3, #248	; 0xf8
    3db2:	strb	r3, [r4, #0]
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3db4:	mov.w	sl, r9, lsr #9
    3db8:	mov	r3, r4
    3dba:	add.w	r2, r4, #19

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    secBuf[i] = 0XFF;
    3dbe:	movs	r1, #255	; 0xff
    3dc0:	strb.w	r1, [r3, #1]!
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    3dc4:	cmp	r2, r3
    3dc6:	bne.n	3dc0 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2e0>
    secBuf[i] = 0XFF;
  }
  for (uint32_t i = 0; i < ns; i++) {
    if (i%(ns/32) == 0) {
    3dc8:	mov.w	r9, r9, lsr #14
    3dcc:	mov.w	r8, #0
    3dd0:	udiv	r3, r8, r9
    3dd4:	mls	r3, r9, r3, r8
    3dd8:	cbnz	r3, 3de4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x304>
      writeMsg(pr, ".");
    3dda:	cbz	r7, 3de4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x304>
    3ddc:	ldr	r1, [pc, #324]	; (3f24 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x444>)
    3dde:	mov	r0, r7
    3de0:	bl	764 <Print::write(char const*)>
    }
    if (!dev->writeSector(sector + i, secBuf)) {
    3de4:	ldr	r3, [r5, #0]
    3de6:	mov	r2, r4
    3de8:	ldr	r3, [r3, #32]
    3dea:	add.w	r1, r6, r8
    3dee:	mov	r0, r5
    3df0:	blx	r3
    3df2:	cmp	r0, #0
    3df4:	beq.n	3d24 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    3df6:	cmp.w	r8, #0
    3dfa:	bne.n	3e08 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x328>
      memset(secBuf, 0, BYTES_PER_SECTOR);
    3dfc:	mov.w	r2, #512	; 0x200
    3e00:	mov	r1, r8
    3e02:	mov	r0, r4
    3e04:	bl	90e4 <memset>
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    secBuf[i] = 0XFF;
  }
  for (uint32_t i = 0; i < ns; i++) {
    3e08:	add.w	r8, r8, #1
    3e0c:	cmp	sl, r8
    3e0e:	bne.n	3dd0 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2f0>
    }
    if (i == 0) {
      memset(secBuf, 0, BYTES_PER_SECTOR);
    }
  }
  writeMsg(pr, "\r\n");
    3e10:	cbz	r7, 3e1a <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x33a>
    3e12:	ldr	r1, [pc, #276]	; (3f28 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x448>)
    3e14:	mov	r0, r7
    3e16:	bl	764 <Print::write(char const*)>
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
    3e1a:	ldr	r3, [sp, #8]
    3e1c:	mov.w	r8, #1
    3e20:	lsl.w	r8, r8, r3
    }
  }
  writeMsg(pr, "\r\n");
  // Write cluster two, bitmap.
  sector = partitionOffset + clusterHeapOffset;
  bitmapSize = (clusterCount + 7)/8;
    3e24:	ldr	r3, [sp, #12]
    3e26:	add.w	sl, r3, #7
    3e2a:	mov.w	sl, sl, lsr #3
  ns = (bitmapSize + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3e2e:	addw	fp, sl, #511	; 0x1ff
    3e32:	mov.w	fp, fp, lsr #9
  if (ns > sectorsPerCluster) {
    3e36:	cmp	r8, fp
    3e38:	bcc.w	3d24 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3e3c:	mov.w	r2, #512	; 0x200
    3e40:	movs	r1, #0
    3e42:	mov	r0, r4
    3e44:	bl	90e4 <memset>
  // Allocate clusters for bitmap, upcase, and root.
  secBuf[0] = 0X7;
    3e48:	movs	r3, #7
    3e4a:	strb	r3, [r4, #0]
  for (uint32_t i = 0; i < ns; i++) {
    3e4c:	mov.w	r9, #0
    if (!dev->writeSector(sector + i, secBuf)) {
    3e50:	ldr	r3, [r5, #0]
    3e52:	ldr	r1, [sp, #16]
    3e54:	ldr	r3, [r3, #32]
    3e56:	mov	r2, r4
    3e58:	add	r1, r9
    3e5a:	mov	r0, r5
    3e5c:	blx	r3
    3e5e:	cmp	r0, #0
    3e60:	beq.w	3d24 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    3e64:	cmp.w	r9, #0
    3e68:	bne.n	3e6e <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x38e>
      secBuf[0] = 0;
    3e6a:	strb.w	r9, [r4]
    goto fail;
  }
  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate clusters for bitmap, upcase, and root.
  secBuf[0] = 0X7;
  for (uint32_t i = 0; i < ns; i++) {
    3e6e:	add.w	r9, r9, #1
    3e72:	cmp	fp, r9
    3e74:	bne.n	3e50 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x370>
    if (i == 0) {
      secBuf[0] = 0;
    }
  }
  // Write cluster three, upcase table.
  writeMsg(pr, "Writing upcase table\r\n");
    3e76:	cbz	r7, 3e80 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3a0>
    3e78:	ldr	r1, [pc, #176]	; (3f2c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x44c>)
    3e7a:	mov	r0, r7
    3e7c:	bl	764 <Print::write(char const*)>
  if (!writeUpcase(partitionOffset + clusterHeapOffset + sectorsPerCluster)) {
    3e80:	ldr	r3, [sp, #0]
    3e82:	ldr	r0, [sp, #4]
    3e84:	add	r3, r6
    3e86:	add.w	r9, r3, r8
    3e8a:	mov	r1, r9
    3e8c:	bl	3a4e <ExFatFormatter::writeUpcase(unsigned long)>
    3e90:	cmp	r0, #0
    3e92:	beq.w	3d24 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_upcaseSize > BYTES_PER_SECTOR*sectorsPerCluster) {
    3e96:	ldr	r3, [sp, #4]
    3e98:	ldr	r3, [r3, #8]
    3e9a:	cmp.w	r3, r8, lsl #9
    3e9e:	bhi.w	3d24 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Initialize first sector of root.
  writeMsg(pr, "Writing root\r\n");
    3ea2:	cbz	r7, 3eac <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3cc>
    3ea4:	ldr	r1, [pc, #136]	; (3f30 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x450>)
    3ea6:	mov	r0, r7
    3ea8:	bl	764 <Print::write(char const*)>
  ns = sectorsPerCluster;
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3eac:	mov.w	r2, #512	; 0x200
    3eb0:	movs	r1, #0
    3eb2:	mov	r0, r4
    3eb4:	bl	90e4 <memset>
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;

  // bitmap directory entry.
  dbm = reinterpret_cast<DirBitmap_t*>(secBuf + 32);
  dbm->type = EXFAT_TYPE_BITMAP;
    3eb8:	movs	r2, #129	; 0x81
    3eba:	strb.w	r2, [r4, #32]
    3ebe:	movs	r2, #2
    3ec0:	str	r2, [r4, #52]	; 0x34
  setLe32(dbm->firstCluster, BITMAP_CLUSTER);
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
    3ec2:	movs	r2, #130	; 0x82
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);

  // Unused Label entry.
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;
    3ec4:	movs	r3, #3
  setLe32(dbm->firstCluster, BITMAP_CLUSTER);
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
    3ec6:	strb.w	r2, [r4, #64]	; 0x40
  setLe32(dup->checksum, m_upcaseChecksum);
    3eca:	ldr	r2, [sp, #4]
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);

  // Unused Label entry.
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;
    3ecc:	strb	r3, [r4, #0]
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
  setLe32(dup->checksum, m_upcaseChecksum);
    3ece:	ldr	r2, [r2, #4]
    3ed0:	str	r3, [r4, #84]	; 0x54
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    3ed2:	ldr	r3, [sp, #4]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3ed4:	str	r2, [r4, #68]	; 0x44
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    3ed6:	ldr	r3, [r3, #8]
    3ed8:	str.w	sl, [r4, #56]	; 0x38
    3edc:	movs	r6, #0
    goto fail;
  }
  // Initialize first sector of root.
  writeMsg(pr, "Writing root\r\n");
  ns = sectorsPerCluster;
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
    3ede:	add	r9, r8
    3ee0:	str	r3, [r4, #88]	; 0x58
    3ee2:	str	r6, [r4, #92]	; 0x5c
  setLe32(dup->firstCluster, UPCASE_CLUSTER);
  setLe64(dup->size, m_upcaseSize);

  // Write root, cluster four.
  for (uint32_t i = 0; i < ns; i++) {
    if (!dev->writeSector(sector + i, secBuf)) {
    3ee4:	ldr	r3, [r5, #0]
    3ee6:	mov	r2, r4
    3ee8:	ldr	r3, [r3, #32]
    3eea:	add.w	r1, r6, r9
    3eee:	mov	r0, r5
    3ef0:	blx	r3
    3ef2:	mov	sl, r0
    3ef4:	cmp	r0, #0
    3ef6:	beq.w	3d24 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    3efa:	cbnz	r6, 3f08 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x428>
      memset(secBuf, 0, BYTES_PER_SECTOR);
    3efc:	mov.w	r2, #512	; 0x200
    3f00:	mov	r1, r6
    3f02:	mov	r0, r4
    3f04:	bl	90e4 <memset>
  setLe32(dup->checksum, m_upcaseChecksum);
  setLe32(dup->firstCluster, UPCASE_CLUSTER);
  setLe64(dup->size, m_upcaseSize);

  // Write root, cluster four.
  for (uint32_t i = 0; i < ns; i++) {
    3f08:	adds	r6, #1
    3f0a:	cmp	r8, r6
    3f0c:	bne.n	3ee4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x404>
    }
    if (i == 0) {
      memset(secBuf, 0, BYTES_PER_SECTOR);
    }
  }
  writeMsg(pr, "Format done\r\n");
    3f0e:	cbz	r7, 3f18 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x438>
    3f10:	ldr	r1, [pc, #32]	; (3f34 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x454>)
    3f12:	mov	r0, r7
    3f14:	bl	764 <Print::write(char const*)>
  return true;

 fail:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
    3f18:	mov	r0, sl
    3f1a:	add	sp, #28
    3f1c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3f20:	.word	0x00012d28
    3f24:	.word	0x00012d35
    3f28:	.word	0x00012da7
    3f2c:	.word	0x00012d37
    3f30:	.word	0x00012d4e
    3f34:	.word	0x00012d5d

00003f38 <ExFatFile::cmpName(DirName_t const*, ExName_t*)>:
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
  return hash;
}
//------------------------------------------------------------------------------
bool ExFatFile::cmpName(const DirName_t* dirName, ExName_t* fname) {
    3f38:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3f3c:	mov	r5, r2
    3f3e:	mov	r6, r1
    3f40:	add.w	r8, r1, #30
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    3f44:	ldrh	r3, [r5, #12]
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    3f46:	ldrh.w	r4, [r6, #2]!
    3f4a:	cbnz	r3, 3f5e <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x26>
    3f4c:	ldr	r2, [r5, #4]
    3f4e:	ldr	r3, [r5, #8]
    3f50:	cmp	r2, r3
    3f52:	bne.n	3f5e <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x26>
  for (uint8_t i = 0; i < 15; i++) {
    uint16_t u = getLe16(dirName->unicode + 2*i);
    if (fname->atEnd()) {
      return u == 0;
    3f54:	clz	r0, r4
    3f58:	lsrs	r0, r0, #5
    3f5a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
#if USE_UTF8_LONG_NAMES
    uint16_t cp = fname->get16();
    3f5e:	mov	r0, r5
    3f60:	bl	3980 <FsName::get16()>
    if (toUpcase(cp) != toUpcase(u)) {
    3f64:	bl	38dc <toUpcase(unsigned short)>
    3f68:	mov	r7, r0
    3f6a:	mov	r0, r4
    3f6c:	bl	38dc <toUpcase(unsigned short)>
    3f70:	cmp	r7, r0
    3f72:	bne.n	3f7e <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x46>
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
  return hash;
}
//------------------------------------------------------------------------------
bool ExFatFile::cmpName(const DirName_t* dirName, ExName_t* fname) {
  for (uint8_t i = 0; i < 15; i++) {
    3f74:	cmp	r6, r8
    3f76:	bne.n	3f44 <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0xc>
    if (u >= 0x7F || toUpper(c) != toUpper(u)) {
      return false;
    }
#endif  // USE_UTF8_LONG_NAMES
  }
  return true;
    3f78:	movs	r0, #1
    3f7a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return u == 0;
    }
#if USE_UTF8_LONG_NAMES
    uint16_t cp = fname->get16();
    if (toUpcase(cp) != toUpcase(u)) {
       return false;
    3f7e:	movs	r0, #0
    3f80:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00003f84 <ExFatFile::getName8(char*, unsigned int)>:
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName8(char* name, size_t count) {
    3f84:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  char* str = name;
  char* ptr;
  DirName_t* dn;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    3f88:	ldrb.w	r3, [r0, #49]	; 0x31
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName8(char* name, size_t count) {
    3f8c:	mov	sl, r0
    3f8e:	mov	r9, r1
  char* str = name;
  char* ptr;
  DirName_t* dn;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    3f90:	cmp	r3, #0
    3f92:	beq.n	4024 <ExFatFile::getName8(char*, unsigned int)+0xa0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    3f94:	add.w	r8, r2, #4294967295
    3f98:	mov	r5, r1
    3f9a:	movs	r7, #2
    3f9c:	movs	r4, #0
    3f9e:	add	r8, r1
  uint32_t cp;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 2; is <= m_setCount; is++) {
    3fa0:	ldrb.w	r3, [sl, #48]	; 0x30
    3fa4:	cmp	r3, r7
    3fa6:	bcc.n	4018 <ExFatFile::getName8(char*, unsigned int)+0x94>
    dn = reinterpret_cast<DirName_t*>
         (dirCache(is, FsCache::CACHE_FOR_READ));
    3fa8:	movs	r2, #0
    3faa:	mov	r1, r7
    3fac:	mov	r0, sl
    3fae:	bl	4096 <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
    3fb2:	cbz	r0, 4024 <ExFatFile::getName8(char*, unsigned int)+0xa0>
    3fb4:	ldrb	r3, [r0, #0]
    3fb6:	cmp	r3, #193	; 0xc1
    3fb8:	bne.n	4024 <ExFatFile::getName8(char*, unsigned int)+0xa0>
    3fba:	mov	r6, r0
    3fbc:	add.w	fp, r0, #30
    3fc0:	mov	r3, r4
    3fc2:	ldrh.w	r4, [r6, #2]!
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
      uint16_t c = getLe16(dn->unicode + 2*in);
      if (hs) {
    3fc6:	cbz	r3, 3fe6 <ExFatFile::getName8(char*, unsigned int)+0x62>
        if (!FsUtf::isLowSurrogate(c)) {
    3fc8:	add.w	r2, r4, #9216	; 0x2400
    3fcc:	uxth	r2, r2
    3fce:	cmp.w	r2, #1024	; 0x400
    3fd2:	bcs.n	4024 <ExFatFile::getName8(char*, unsigned int)+0xa0>
   * \param[in] hs high surrogate.
   * \param[in] ls low surrogate.
   * \return code point.
   */
  inline uint32_t u16ToCp(uint16_t hs, uint16_t ls) {
    return 0X10000 + (((hs & 0X3FF) << 10) | (ls & 0X3FF));
    3fd4:	ldr	r0, [pc, #88]	; (4030 <ExFatFile::getName8(char*, unsigned int)+0xac>)
    3fd6:	lsls	r3, r3, #10
    3fd8:	ands	r0, r3
    3fda:	ubfx	r4, r4, #0, #10
    3fde:	orrs	r4, r0
    3fe0:	add.w	r0, r4, #65536	; 0x10000
    3fe4:	b.n	4000 <ExFatFile::getName8(char*, unsigned int)+0x7c>
  /** Check for UTF-16 surrogate.
   * \param[in] c UTF-16 unit.
   * \return true if c is a surrogate else false.
   */
  inline bool isSurrogate(uint16_t c) {
    return 0XD800 <= c && c <= 0XDFFF;
    3fe6:	add.w	r3, r4, #10240	; 0x2800
    3fea:	uxth	r3, r3
          DBG_FAIL_MACRO;
          goto fail;
        }
        cp = FsUtf::u16ToCp(hs, c);
        hs = 0;
      } else if (!FsUtf::isSurrogate(c)) {
    3fec:	cmp.w	r3, #2048	; 0x800
    3ff0:	bcc.n	3ff8 <ExFatFile::getName8(char*, unsigned int)+0x74>
        if (c == 0) {
    3ff2:	cbz	r4, 4018 <ExFatFile::getName8(char*, unsigned int)+0x94>
          goto done;
        }
        cp = c;
    3ff4:	mov	r0, r4
    3ff6:	b.n	4000 <ExFatFile::getName8(char*, unsigned int)+0x7c>
      } else if (FsUtf::isHighSurrogate(c)) {
    3ff8:	cmp.w	r3, #1024	; 0x400
    3ffc:	bcc.n	400e <ExFatFile::getName8(char*, unsigned int)+0x8a>
    3ffe:	b.n	4024 <ExFatFile::getName8(char*, unsigned int)+0xa0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    4000:	mov	r2, r8
    4002:	mov	r1, r5
    4004:	bl	34ec <FsUtf::cpToMb(unsigned long, char*, char*)>
      if (!ptr) {
    4008:	cbz	r0, 4018 <ExFatFile::getName8(char*, unsigned int)+0x94>
    400a:	mov	r5, r0
    400c:	movs	r4, #0
         (dirCache(is, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
    400e:	cmp	fp, r6
    4010:	bne.n	3fc0 <ExFatFile::getName8(char*, unsigned int)+0x3c>
  uint32_t cp;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 2; is <= m_setCount; is++) {
    4012:	adds	r7, #1
    4014:	uxtb	r7, r7
    4016:	b.n	3fa0 <ExFatFile::getName8(char*, unsigned int)+0x1c>
      }
      str = ptr;
    }
  }
 done:
  *str = '\0';
    4018:	movs	r3, #0
    401a:	strb	r3, [r5, #0]
  return str - name;
    401c:	rsb	r0, r9, r5
    4020:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

 fail:
  *name = 0;
    4024:	movs	r0, #0
    4026:	strb.w	r0, [r9]
  return 0;
}
    402a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    402e:	nop
    4030:	.word	0x000ffc00

00004034 <ExFatFile::hashName(ExName_t*)>:
//------------------------------------------------------------------------------
bool ExFatFile::hashName(ExName_t* fname) {
    4034:	push	{r4, r5, r6, lr}
  }
  void reset() {
    next = begin;
    4036:	ldr	r3, [r1, #0]
    4038:	str	r3, [r1, #4]
    ls = 0;
    403a:	movs	r4, #0
    403c:	mov	r5, r1
    403e:	strh	r4, [r1, #12]
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
    4040:	str	r4, [r1, #16]
  while (!fname->atEnd()) {
    uint16_t u = fname->get16();
    if (u == 0XFFFF) {
    4042:	movw	r6, #65535	; 0xffff
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    4046:	ldrh	r3, [r5, #12]
    4048:	cbnz	r3, 4052 <ExFatFile::hashName(ExName_t*)+0x1e>
    404a:	ldr	r2, [r5, #4]
    404c:	ldr	r3, [r5, #8]
    404e:	cmp	r2, r3
    4050:	beq.n	4086 <ExFatFile::hashName(ExName_t*)+0x52>
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
  while (!fname->atEnd()) {
    uint16_t u = fname->get16();
    4052:	mov	r0, r5
    4054:	bl	3980 <FsName::get16()>
    if (u == 0XFFFF) {
    4058:	cmp	r0, r6
    405a:	beq.n	4082 <ExFatFile::hashName(ExName_t*)+0x4e>
  hash = ((hash << 15) | (hash >> 1));
  return hash;
}
//------------------------------------------------------------------------------
inline uint16_t exFatHash(uint16_t u, uint16_t hash) {
  uint16_t c = toUpcase(u);
    405c:	bl	38dc <toUpcase(unsigned short)>
    4060:	lsls	r3, r4, #15
    4062:	orr.w	r4, r3, r4, lsr #1
    4066:	uxtab	r4, r4, r0
    406a:	ubfx	r3, r4, #1, #15
    406e:	orr.w	r3, r3, r4, lsl #15
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
    4072:	asrs	r4, r0, #8
    4074:	uxtah	r4, r4, r3
    if (u == 0XFFFF) {
    DBG_FAIL_MACRO;
      goto fail;
    }
    hash = exFatHash(u, hash);
    fname->nameLength++;
    4078:	ldr	r3, [r5, #16]
    407a:	adds	r3, #1
}
//------------------------------------------------------------------------------
inline uint16_t exFatHash(uint16_t u, uint16_t hash) {
  uint16_t c = toUpcase(u);
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
    407c:	uxth	r4, r4
    if (u == 0XFFFF) {
    DBG_FAIL_MACRO;
      goto fail;
    }
    hash = exFatHash(u, hash);
    fname->nameLength++;
    407e:	str	r3, [r5, #16]
bool ExFatFile::hashName(ExName_t* fname) {
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
  while (!fname->atEnd()) {
    4080:	b.n	4046 <ExFatFile::hashName(ExName_t*)+0x12>
    goto fail;
  }
  return true;

 fail:
  return false;
    4082:	movs	r0, #0
    4084:	pop	{r4, r5, r6, pc}
    hash = exFatHash(c, hash);
  }
  fname->nameLength = fname->end - fname->begin;
#endif  // USE_UTF8_LONG_NAMES
  fname->nameHash = hash;
  if (!fname->nameLength || fname->nameLength > EXFAT_MAX_NAME_LENGTH) {
    4086:	ldr	r0, [r5, #16]
    char c = fname->getch();
    hash = exFatHash(c, hash);
  }
  fname->nameLength = fname->end - fname->begin;
#endif  // USE_UTF8_LONG_NAMES
  fname->nameHash = hash;
    4088:	strh	r4, [r5, #20]
  if (!fname->nameLength || fname->nameLength > EXFAT_MAX_NAME_LENGTH) {
    408a:	subs	r0, #1
    408c:	cmp	r0, #254	; 0xfe
    408e:	ite	hi
    4090:	movhi	r0, #0
    4092:	movls	r0, #1
  }
  return true;

 fail:
  return false;
}
    4094:	pop	{r4, r5, r6, pc}

00004096 <ExFatFile::dirCache(unsigned char, unsigned char)>:
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    4096:	push	{r4, r5, r6, r7, lr}
  DirPos_t pos = m_dirPos;
    4098:	add.w	r3, r0, #36	; 0x24
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    409c:	mov	r5, r0
    409e:	mov	r7, r1
    40a0:	mov	r6, r2
  DirPos_t pos = m_dirPos;
    40a2:	ldmia.w	r3, {r0, r1, r2}
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    40a6:	sub	sp, #20
  DirPos_t pos = m_dirPos;
    40a8:	add	r4, sp, #4
    40aa:	stmia.w	r4, {r0, r1, r2}
  if (m_vol->dirSeek(&pos, 32*set) != 1) {
    40ae:	lsls	r2, r7, #5
    40b0:	mov	r1, r4
    40b2:	ldr	r0, [r5, #32]
    40b4:	bl	4a74 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    40b8:	cmp	r0, #1
    40ba:	bne.n	40c8 <ExFatFile::dirCache(unsigned char, unsigned char)+0x32>
    return nullptr;
  }
  return m_vol->dirCache(&pos, options);
    40bc:	mov	r2, r6
    40be:	mov	r1, r4
    40c0:	ldr	r0, [r5, #32]
    40c2:	bl	49d6 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    40c6:	b.n	40ca <ExFatFile::dirCache(unsigned char, unsigned char)+0x34>
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
  DirPos_t pos = m_dirPos;
  if (m_vol->dirSeek(&pos, 32*set) != 1) {
    return nullptr;
    40c8:	movs	r0, #0
  }
  return m_vol->dirCache(&pos, options);
}
    40ca:	add	sp, #20
    40cc:	pop	{r4, r5, r6, r7, pc}

000040ce <ExFatFile::close()>:
//------------------------------------------------------------------------------
bool ExFatFile::close() {
    40ce:	push	{r4, lr}
    40d0:	mov	r4, r0
  bool rtn = sync();
    40d2:	bl	4f8c <ExFatFile::sync()>
  m_attributes = FILE_ATTR_CLOSED;
    40d6:	movs	r3, #0
    40d8:	strb.w	r3, [r4, #49]	; 0x31
  m_flags = 0;
    40dc:	strb.w	r3, [r4, #51]	; 0x33
  return rtn;
}
    40e0:	pop	{r4, pc}

000040e2 <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    40e2:	push	{r3, r4, r5, lr}
    40e4:	mov	r5, r1
    40e6:	mov	r4, r2
  DirFile_t* df = reinterpret_cast<DirFile_t*>
                 (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_READ));
    40e8:	add.w	r1, r0, #36	; 0x24
    40ec:	movs	r2, #0
    40ee:	ldr	r0, [r0, #32]
    40f0:	bl	49d6 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    40f4:	cbz	r0, 4100 <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)+0x1e>
    40f6:	ldrh	r3, [r0, #10]
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(df->createDate);
    40f8:	strh	r3, [r5, #0]
    40fa:	ldrh	r3, [r0, #8]
  *ptime = getLe16(df->createTime);
    40fc:	strh	r3, [r4, #0]
  return true;
    40fe:	movs	r0, #1

 fail:
  return false;
}
    4100:	pop	{r3, r4, r5, pc}

00004102 <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)>:
//------------------------------------------------------------------------------
bool ExFatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    4102:	push	{r3, r4, r5, lr}
    4104:	mov	r5, r1
    4106:	mov	r4, r2
  DirFile_t* df = reinterpret_cast<DirFile_t*>
                 (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_READ));
    4108:	add.w	r1, r0, #36	; 0x24
    410c:	movs	r2, #0
    410e:	ldr	r0, [r0, #32]
    4110:	bl	49d6 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    4114:	cbz	r0, 4120 <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)+0x1e>
    4116:	ldrh	r3, [r0, #14]
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(df->modifyDate);
    4118:	strh	r3, [r5, #0]
    411a:	ldrh	r3, [r0, #12]
  *ptime = getLe16(df->modifyTime);
    411c:	strh	r3, [r4, #0]
  return true;
    411e:	movs	r0, #1

 fail:
  return false;
}
    4120:	pop	{r3, r4, r5, pc}

00004122 <ExFatFile::openRoot(ExFatVolume*)>:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
    4122:	push	{r3, r4, r5, lr}
    4124:	mov	r5, r1
  if (isOpen()) {
    4126:	ldrb.w	r1, [r0, #49]	; 0x31
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
    412a:	mov	r4, r0
  if (isOpen()) {
    412c:	cbnz	r1, 4144 <ExFatFile::openRoot(ExFatVolume*)+0x22>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    412e:	movs	r2, #56	; 0x38
    4130:	bl	90e4 <memset>
  m_attributes = FILE_ATTR_ROOT;
    4134:	movs	r3, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    4136:	movs	r0, #1
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
    4138:	strb.w	r3, [r4, #49]	; 0x31
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    413c:	strb.w	r0, [r4, #51]	; 0x33
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
    4140:	str	r5, [r4, #32]
    4142:	pop	{r3, r4, r5, pc}
  m_flags = FILE_FLAG_READ;
  return true;

 fail:
  return false;
    4144:	movs	r0, #0
}
    4146:	pop	{r3, r4, r5, pc}

00004148 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>:
//------------------------------------------------------------------------------
bool ExFatFile::parsePathName(const char* path,
                            ExName_t* fname, const char** ptr) {
    4148:	push	{r4, r5, r6, r7}
  // Skip leading spaces.
  while (*path == ' ') {
    414a:	ldrb	r4, [r1, #0]
    414c:	cmp	r4, #32
    414e:	add.w	r5, r1, #1
    4152:	bne.n	4158 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x10>
    4154:	mov	r1, r5
    4156:	b.n	414a <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x2>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    4158:	ldr	r7, [pc, #100]	; (41c0 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x78>)
    path++;
  }
  fname->begin = path;
    415a:	str	r1, [r2, #0]
  fname->end = path;
    415c:	str	r1, [r2, #8]
  while (*path && !isDirSeparator(*path)) {
    415e:	mov	r5, r1
    4160:	mov	r6, r1
    4162:	ldrb.w	r4, [r5], #1
    4166:	cbz	r4, 41a0 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x58>
    4168:	cmp	r4, #47	; 0x2f
    416a:	beq.n	4194 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x4c>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    416c:	cmp	r4, #31
    416e:	bls.n	41ba <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    4170:	sub.w	r1, r4, #34	; 0x22
    4174:	uxtb	r1, r1
    4176:	cmp	r1, #29
    4178:	bhi.n	4182 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x3a>
    417a:	lsr.w	r1, r7, r1
    417e:	lsls	r1, r1, #31
    4180:	bmi.n	41ba <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    4182:	and.w	r1, r4, #191	; 0xbf
    4186:	cmp	r1, #60	; 0x3c
    4188:	beq.n	41ba <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
    418a:	cmp	r4, #92	; 0x5c
    418c:	bne.n	41aa <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    418e:	b.n	41ba <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
      // Need to trim trailing dots spaces.
      fname->end = path;
    }
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
    4190:	cmp	r4, #47	; 0x2f
    4192:	bne.n	41a0 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x58>
    4194:	mov	r6, r1
    4196:	ldrb.w	r4, [r1], #1
    419a:	cmp	r4, #32
    419c:	bne.n	4190 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x48>
    419e:	b.n	4194 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x4c>
  *ptr = path;
    41a0:	str	r6, [r3, #0]
  return hashName(fname);
    41a2:	mov	r1, r2

 fail:
  return false;
}
    41a4:	pop	{r4, r5, r6, r7}
    }
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
  *ptr = path;
  return hashName(fname);
    41a6:	b.w	4034 <ExFatFile::hashName(ExName_t*)>
    uint8_t c = *path++;
    if (!lfnLegalChar(c)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (c != '.' && c != ' ') {
    41aa:	cmp	r4, #46	; 0x2e
    41ac:	bne.n	41b2 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x6a>
    41ae:	mov	r1, r5
    41b0:	b.n	415e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x16>
    41b2:	cmp	r4, #32
    41b4:	beq.n	41ae <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x66>
      // Need to trim trailing dots spaces.
      fname->end = path;
    41b6:	str	r5, [r2, #8]
    41b8:	b.n	41ae <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x66>
  *ptr = path;
  return hashName(fname);

 fail:
  return false;
}
    41ba:	movs	r0, #0
    41bc:	pop	{r4, r5, r6, r7}
    41be:	bx	lr
    41c0:	.word	0x31000101

000041c4 <ExFatFile::read(void*, unsigned int)>:
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    41c4:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    41c8:	ldrb.w	r3, [r0, #51]	; 0x33
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    41cc:	lsls	r7, r3, #31
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    41ce:	mov	r4, r0
    41d0:	mov	r6, r1
    41d2:	mov	r5, r2
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    41d4:	bpl.n	42c6 <ExFatFile::read(void*, unsigned int)+0x102>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isContiguous() || isFile()) {
    41d6:	lsls	r0, r3, #25
    41d8:	bmi.n	41e2 <ExFatFile::read(void*, unsigned int)+0x1e>
    41da:	ldrb.w	r3, [r4, #49]	; 0x31
    41de:	lsls	r1, r3, #28
    41e0:	bpl.n	41fc <ExFatFile::read(void*, unsigned int)+0x38>
    if ((m_curPosition + count) > m_validLength) {
    41e2:	ldrd	r0, r1, [r4]
    41e6:	ldrd	r2, r3, [r4, #16]
    41ea:	adds.w	r8, r0, r5
    41ee:	adc.w	r9, r1, #0
    41f2:	cmp	r3, r9
    41f4:	it	eq
    41f6:	cmpeq	r2, r8
    41f8:	bcs.n	41fc <ExFatFile::read(void*, unsigned int)+0x38>
      count = toRead = m_validLength - m_curPosition;
    41fa:	subs	r5, r2, r0
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    41fc:	mov	r9, r5
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
      } else if (isContiguous()) {
        m_curCluster++;
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    41fe:	add.w	sl, r4, #24
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    4202:	cmp.w	r9, #0
    4206:	beq.n	4290 <ExFatFile::read(void*, unsigned int)+0xcc>
    clusterOffset = m_curPosition & m_vol->clusterMask();
    4208:	ldr	r0, [r4, #32]
    420a:	ldrd	r2, r3, [r4]
    420e:	ldr.w	r1, [r0, #1080]	; 0x438
    4212:	and.w	r8, r1, r2
    sectorOffset = clusterOffset & m_vol->sectorMask();
    4216:	ubfx	fp, r8, #0, #9
    if (clusterOffset == 0) {
    421a:	cmp.w	r8, #0
    421e:	bne.n	425e <ExFatFile::read(void*, unsigned int)+0x9a>
      if (m_curPosition == 0) {
    4220:	orrs	r3, r2
    4222:	bne.n	4234 <ExFatFile::read(void*, unsigned int)+0x70>
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
    4224:	ldrb.w	r3, [r4, #49]	; 0x31
    4228:	lsls	r2, r3, #25
    422a:	ite	mi
    422c:	ldrmi.w	r3, [r0, #1076]	; 0x434
    4230:	ldrpl	r3, [r4, #28]
    4232:	b.n	4240 <ExFatFile::read(void*, unsigned int)+0x7c>
      } else if (isContiguous()) {
    4234:	ldrb.w	r3, [r4, #51]	; 0x33
    4238:	lsls	r3, r3, #25
    423a:	bpl.n	4244 <ExFatFile::read(void*, unsigned int)+0x80>
        m_curCluster++;
    423c:	ldr	r3, [r4, #24]
    423e:	adds	r3, #1
    4240:	str	r3, [r4, #24]
    4242:	b.n	425e <ExFatFile::read(void*, unsigned int)+0x9a>
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    4244:	mov	r2, sl
    4246:	ldr	r1, [r4, #24]
    4248:	bl	4a0c <ExFatPartition::fatGet(unsigned long, unsigned long*)>
        if (fg < 0) {
    424c:	cmp	r0, #0
    424e:	blt.n	42c6 <ExFatFile::read(void*, unsigned int)+0x102>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
    4250:	bne.n	425e <ExFatFile::read(void*, unsigned int)+0x9a>
          // EOF if directory.
          if (isDir()) {
    4252:	ldrb.w	r3, [r4, #49]	; 0x31
    4256:	tst.w	r3, #80	; 0x50
    425a:	bne.n	4290 <ExFatFile::read(void*, unsigned int)+0xcc>
    425c:	b.n	42c6 <ExFatFile::read(void*, unsigned int)+0x102>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
    425e:	ldr	r7, [r4, #32]
             (clusterOffset >> m_vol->bytesPerSectorShift());
    4260:	ldr	r1, [r4, #24]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    4262:	ldrb.w	lr, [r7, #1093]	; 0x445
    4266:	ldr.w	r0, [r7, #1068]	; 0x42c
    426a:	subs	r1, #2
    426c:	lsl.w	r1, r1, lr
    4270:	mov.w	r2, r8, lsr #9
    4274:	add	r1, r0
    4276:	add.w	r8, r1, r2
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
    427a:	cmp.w	fp, #0
    427e:	bne.n	4320 <ExFatFile::read(void*, unsigned int)+0x15c>
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
    4280:	cmp.w	r9, #512	; 0x200
    4284:	bcc.n	4320 <ExFatFile::read(void*, unsigned int)+0x15c>
    4286:	ldr.w	r1, [r7, #540]	; 0x21c
                          || sector == m_vol->dataCacheSector()) {
    428a:	cmp	r8, r1
    428c:	bne.n	4298 <ExFatFile::read(void*, unsigned int)+0xd4>
    428e:	b.n	4320 <ExFatFile::read(void*, unsigned int)+0x15c>
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return count - toRead;
    4290:	rsb	r0, r9, r5
    4294:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    4298:	cmp.w	r9, #1024	; 0x400
    429c:	bcc.n	42f4 <ExFatFile::read(void*, unsigned int)+0x130>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      // Limit reads to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    429e:	movs	r3, #1
    42a0:	lsl.w	r3, r3, lr
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    42a4:	mov.w	fp, r9, lsr #9
      // Limit reads to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    42a8:	subs	r2, r3, r2
    42aa:	cmp	fp, r2
    42ac:	it	cs
    42ae:	movcs	fp, r2
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    42b0:	cmp	r8, r1
    42b2:	bhi.n	42da <ExFatFile::read(void*, unsigned int)+0x116>
    42b4:	add.w	r3, fp, r8
    42b8:	cmp	r1, r3
    42ba:	bcs.n	42da <ExFatFile::read(void*, unsigned int)+0x116>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    42bc:	add.w	r0, r7, #528	; 0x210
    42c0:	bl	3842 <FsCache::sync()>
    42c4:	cbnz	r0, 42da <ExFatFile::read(void*, unsigned int)+0x116>
    toRead -= n;
  }
  return count - toRead;

 fail:
  m_error |= READ_ERROR;
    42c6:	ldrb.w	r3, [r4, #50]	; 0x32
    42ca:	orr.w	r3, r3, #2
    42ce:	strb.w	r3, [r4, #50]	; 0x32
  return -1;
    42d2:	mov.w	r0, #4294967295
    42d6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    42da:	ldr.w	r0, [r7, #532]	; 0x214
    42de:	ldr	r3, [r0, #0]
    42e0:	mov	r2, r6
    42e2:	ldr	r7, [r3, #16]
    42e4:	mov	r1, r8
    42e6:	mov	r3, fp
    42e8:	blx	r7
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
     if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    42ea:	cmp	r0, #0
    42ec:	beq.n	42c6 <ExFatFile::read(void*, unsigned int)+0x102>
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    42ee:	mov.w	r7, fp, lsl #9
    42f2:	b.n	430a <ExFatFile::read(void*, unsigned int)+0x146>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    42f4:	ldr.w	r0, [r7, #532]	; 0x214
    42f8:	ldr	r3, [r0, #0]
    42fa:	mov	r2, r6
    42fc:	ldr	r3, [r3, #12]
    42fe:	mov	r1, r8
    4300:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    4302:	cmp	r0, #0
    4304:	beq.n	42c6 <ExFatFile::read(void*, unsigned int)+0x102>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    4306:	mov.w	r7, #512	; 0x200
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    430a:	ldrd	r2, r3, [r4]
    430e:	adds	r2, r2, r7
    4310:	adc.w	r3, r3, #0
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    4314:	add	r6, r7
    m_curPosition += n;
    4316:	strd	r2, r3, [r4]
    toRead -= n;
    431a:	rsb	r9, r7, r9
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    431e:	b.n	4202 <ExFatFile::read(void*, unsigned int)+0x3e>
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    4320:	movs	r2, #0
    4322:	mov	r1, r8
    4324:	add.w	r0, r7, #528	; 0x210
    4328:	bl	388e <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      cache = m_vol->dataCacheGet(sector, FsCache::CACHE_FOR_READ);
      if (!cache) {
    432c:	cmp	r0, #0
    432e:	beq.n	42c6 <ExFatFile::read(void*, unsigned int)+0x102>
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
      n = m_vol->bytesPerSector() - sectorOffset;
    4330:	rsb	r7, fp, #512	; 0x200
    4334:	cmp	r7, r9
    4336:	it	cs
    4338:	movcs	r7, r9
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
    433a:	add.w	r1, r0, fp
    433e:	mov	r2, r7
    4340:	mov	r0, r6
    4342:	bl	8f3c <memcpy>
    4346:	b.n	430a <ExFatFile::read(void*, unsigned int)+0x146>

00004348 <ExFatFile::peek()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int ExFatFile::peek() {
    4348:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    434a:	movs	r2, #1
    434c:	add.w	r1, sp, #7
    4350:	mov	r4, r0
  uint64_t curPosition = m_curPosition;
    4352:	ldrd	r6, r7, [r0]
  uint32_t curCluster = m_curCluster;
    4356:	ldr	r5, [r0, #24]
    4358:	bl	41c4 <ExFatFile::read(void*, unsigned int)>
    435c:	cmp	r0, #1
    435e:	it	eq
    4360:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
  m_curCluster = curCluster;
    4364:	str	r5, [r4, #24]
    4366:	it	ne
    4368:	movne.w	r0, #4294967295
//------------------------------------------------------------------------------
int ExFatFile::peek() {
  uint64_t curPosition = m_curPosition;
  uint32_t curCluster = m_curCluster;
  int c = read();
  m_curPosition = curPosition;
    436c:	strd	r6, r7, [r4]
  m_curCluster = curCluster;
  return c;
}
    4370:	add	sp, #12
    4372:	pop	{r4, r5, r6, r7, pc}

00004374 <ExFatFile::seekSet(unsigned long long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    4374:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4378:	ldrb.w	fp, [r0, #49]	; 0x31
    437c:	mov	r7, r3
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    437e:	ldr	r3, [r0, #24]
    4380:	str	r3, [sp, #4]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    4382:	mov	r4, r0
    4384:	mov	r6, r2
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    4386:	cmp.w	fp, #0
    438a:	beq.n	4434 <ExFatFile::seekSet(unsigned long long)+0xc0>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    438c:	ldrd	r8, r9, [r0]
    4390:	cmp	r9, r7
    4392:	it	eq
    4394:	cmpeq	r8, r2
    4396:	beq.n	443c <ExFatFile::seekSet(unsigned long long)+0xc8>
    return true;
  }
  if (pos == 0) {
    4398:	orrs.w	r3, r6, r7
    439c:	bne.n	43a4 <ExFatFile::seekSet(unsigned long long)+0x30>
    // set position to start of file
    m_curCluster = 0;
    439e:	movs	r3, #0
    43a0:	str	r3, [r0, #24]
    goto done;
    43a2:	b.n	442e <ExFatFile::seekSet(unsigned long long)+0xba>
  }
  if (isFile()) {
    43a4:	tst.w	fp, #8
    43a8:	beq.n	43b6 <ExFatFile::seekSet(unsigned long long)+0x42>
    if (pos > m_validLength) {
    43aa:	ldrd	r0, r1, [r0, #16]
    43ae:	cmp	r1, r7
    43b0:	it	eq
    43b2:	cmpeq	r0, r2
    43b4:	bcc.n	4434 <ExFatFile::seekSet(unsigned long long)+0xc0>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    43b6:	ldr	r3, [r4, #32]
    43b8:	str	r3, [sp, #0]
    43ba:	ldrb.w	sl, [r3, #1093]	; 0x445
    43be:	add.w	sl, sl, #9
    43c2:	adds.w	r0, r6, #4294967295
    43c6:	uxtb.w	sl, sl
    43ca:	mov	r2, sl
    43cc:	adc.w	r1, r7, #4294967295
    43d0:	bl	a558 <__aeabi_llsr>
  if (isContiguous()) {
    43d4:	ldrb.w	r2, [r4, #51]	; 0x33
    43d8:	lsls	r3, r2, #25
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    43da:	mov	r5, r0
  if (isContiguous()) {
    43dc:	bpl.n	43e6 <ExFatFile::seekSet(unsigned long long)+0x72>
    m_curCluster = m_firstCluster + nNew;
    43de:	ldr	r3, [r4, #28]
    43e0:	add	r5, r3
    43e2:	str	r5, [r4, #24]
    goto done;
    43e4:	b.n	442e <ExFatFile::seekSet(unsigned long long)+0xba>
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
    43e6:	adds.w	r0, r8, #4294967295
    43ea:	adc.w	r1, r9, #4294967295
    43ee:	mov	r2, sl
    43f0:	bl	a558 <__aeabi_llsr>
  if (nNew < nCur || m_curPosition == 0) {
    43f4:	cmp	r5, r0
    43f6:	bcc.n	43fe <ExFatFile::seekSet(unsigned long long)+0x8a>
    43f8:	orrs.w	r3, r8, r9
    43fc:	bne.n	4414 <ExFatFile::seekSet(unsigned long long)+0xa0>
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
    43fe:	tst.w	fp, #64	; 0x40
    4402:	itet	ne
    4404:	ldrne	r3, [sp, #0]
    4406:	ldreq	r3, [r4, #28]
    4408:	ldrne.w	r3, [r3, #1076]	; 0x434
    440c:	str	r3, [r4, #24]
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    440e:	add.w	r8, r4, #24
    4412:	b.n	442a <ExFatFile::seekSet(unsigned long long)+0xb6>
  if (nNew < nCur || m_curPosition == 0) {
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    4414:	subs	r5, r5, r0
    4416:	b.n	440e <ExFatFile::seekSet(unsigned long long)+0x9a>
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    4418:	mov	r2, r8
    441a:	ldr	r1, [r4, #24]
    441c:	ldr	r0, [r4, #32]
    441e:	bl	4a0c <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    4422:	cmp	r0, #0
    4424:	add.w	r5, r5, #4294967295
    4428:	ble.n	4434 <ExFatFile::seekSet(unsigned long long)+0xc0>
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    442a:	cmp	r5, #0
    442c:	bne.n	4418 <ExFatFile::seekSet(unsigned long long)+0xa4>
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    442e:	strd	r6, r7, [r4]
    4432:	b.n	443c <ExFatFile::seekSet(unsigned long long)+0xc8>
  return true;

 fail:
  m_curCluster = tmp;
    4434:	ldr	r3, [sp, #4]
    4436:	str	r3, [r4, #24]
  return false;
    4438:	movs	r0, #0
    443a:	b.n	443e <ExFatFile::seekSet(unsigned long long)+0xca>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    443c:	movs	r0, #1
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    443e:	add	sp, #12
    4440:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00004444 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openPrivate(ExFatFile* dir, ExName_t* fname, oflag_t oflag) {
    4444:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4448:	mov	sl, r3
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
  bool inSet = false;

  // error if already open, no access mode, or no directory.
  if (isOpen() || !dir->isDir()) {
    444a:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openPrivate(ExFatFile* dir, ExName_t* fname, oflag_t oflag) {
    444e:	sub	sp, #52	; 0x34
    4450:	mov	r4, r0
    4452:	mov	r6, r1
    4454:	mov	r5, r2
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
  bool inSet = false;

  // error if already open, no access mode, or no directory.
  if (isOpen() || !dir->isDir()) {
    4456:	cbnz	r3, 44b6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    4458:	ldrb.w	r3, [r1, #49]	; 0x31
    445c:	tst.w	r3, #80	; 0x50
    4460:	beq.n	44b6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    DBG_FAIL_MACRO;
    goto fail;
  }

  switch (oflag & O_ACCMODE) {
    4462:	and.w	r3, sl, #3
    4466:	cmp	r3, #1
    4468:	beq.w	4770 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x32c>
    446c:	cmp	r3, #2
    446e:	bne.w	4766 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x322>
      break;
    case O_WRONLY:
      modeFlags = FILE_FLAG_WRITE;
      break;
    case O_RDWR:
      modeFlags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    4472:	movs	r3, #3
      break;
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
    4474:	and.w	r9, sl, #8
    4478:	orr.w	r9, r9, r3

  if (fname) {
    447c:	cbz	r5, 44c2 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x7e>
    freeNeed = 2 + (fname->nameLength + 14)/15;
    447e:	ldr	r3, [r5, #16]
    4480:	mov.w	r8, #15
    4484:	adds	r3, #14
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    4486:	movs	r2, #0
    4488:	udiv	r8, r3, r8
    448c:	mov	r0, r6
    448e:	add.w	r8, r8, #2
    4492:	movs	r3, #0
    4494:	uxtb.w	r8, r8
    4498:	bl	4374 <ExFatFile::seekSet(unsigned long long)>
        }
        // Likely openNext call.
        DBG_WARN_MACRO;
        goto fail;
      }
      inSet = false;
    449c:	mov.w	fp, #0
    44a0:	mov	r7, fp
    freeNeed = 2 + (fname->nameLength + 14)/15;
    dir->rewind();
  }

  while (1) {
    n = dir->read(buf, 32);
    44a2:	movs	r2, #32
    44a4:	add	r1, sp, #16
    44a6:	mov	r0, r6
    44a8:	bl	41c4 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    44ac:	cmp	r0, #0
    44ae:	beq.w	462a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1e6>
      goto create;
    }
    if (n != 32) {
    44b2:	cmp	r0, #32
    44b4:	beq.n	44c8 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x84>
  return sync();
#endif  // READ_ONLY

 fail:
  // close file
  m_attributes = FILE_ATTR_CLOSED;
    44b6:	movs	r0, #0
    44b8:	strb.w	r0, [r4, #49]	; 0x31
  m_flags = 0;
    44bc:	strb.w	r0, [r4, #51]	; 0x33
  return false;
    44c0:	b.n	4788 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
  DirFile_t*   dirFile;
  DirStream_t* dirStream;
  DirName_t*   dirName;
  uint8_t buf[32];
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
    44c2:	mov.w	r8, #3
    44c6:	b.n	449c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x58>
    }
    if (n != 32) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(buf[0] & 0x80)) {
    44c8:	ldrb.w	r2, [sp, #16]
    44cc:	lsls	r1, r2, #24
    44ce:	bmi.n	44f4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xb0>
      // Unused entry.
      if (freeCount == 0) {
    44d0:	cbnz	r7, 44dc <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x98>
        freePos.position = dir->curPosition() - 32;
    44d2:	ldr	r3, [r6, #0]
    44d4:	subs	r3, #32
    44d6:	str	r3, [sp, #4]
    44d8:	ldr	r3, [r6, #24]
    44da:	str	r3, [sp, #0]
        freePos.cluster = dir->curCluster();
      }
      if (freeCount < freeNeed) {
    44dc:	cmp	r7, r8
        freeCount++;
    44de:	itt	cc
    44e0:	addcc	r7, #1
    44e2:	uxtbcc	r7, r7
      }
      if (!buf[0]) {
    44e4:	cbz	r2, 44ec <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa8>
      }
      if (fname->atEnd()) {
        goto found;
      }
    } else {
      inSet = false;
    44e6:	mov.w	fp, #0
    44ea:	b.n	44a2 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
      }
      if (freeCount < freeNeed) {
        freeCount++;
      }
      if (!buf[0]) {
        if (fname) {
    44ec:	cmp	r5, #0
    44ee:	bne.w	462a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1e6>
    44f2:	b.n	44b6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
        // Likely openNext call.
        DBG_WARN_MACRO;
        goto fail;
      }
      inSet = false;
    } else if (!inSet) {
    44f4:	cmp.w	fp, #0
    44f8:	bne.n	454a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x106>
      if (freeCount < freeNeed) {
        freeCount = 0;
    44fa:	cmp	r7, r8
    44fc:	it	cc
    44fe:	movcc	r7, #0
      }
      if (buf[0] != EXFAT_TYPE_FILE) {
    4500:	cmp	r2, #133	; 0x85
    4502:	bne.n	44a2 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
        continue;
      }
      inSet = true;
      memset(this, 0, sizeof(ExFatFile));
    4504:	movs	r2, #56	; 0x38
    4506:	mov	r1, fp
    4508:	mov	r0, r4
    450a:	bl	90e4 <memset>
      dirFile = reinterpret_cast<DirFile_t*>(buf);
      m_setCount = dirFile->setCount;
      m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    450e:	ldrb.w	r2, [sp, #20]
        continue;
      }
      inSet = true;
      memset(this, 0, sizeof(ExFatFile));
      dirFile = reinterpret_cast<DirFile_t*>(buf);
      m_setCount = dirFile->setCount;
    4512:	ldrb.w	r3, [sp, #17]
    4516:	strb.w	r3, [r4, #48]	; 0x30
      m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    451a:	and.w	r3, r2, #55	; 0x37
      if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
    451e:	lsls	r2, r2, #27
        m_attributes |= FILE_ATTR_FILE;
    4520:	it	pl
    4522:	orrpl.w	r3, r3, #8
    4526:	strb.w	r3, [r4, #49]	; 0x31
    452a:	ldr	r3, [r6, #32]
      }
      m_vol = dir->volume();
    452c:	str	r3, [r4, #32]
    452e:	ldr	r3, [r6, #24]
      m_dirPos.cluster = dir->curCluster();
    4530:	str	r3, [r4, #36]	; 0x24
      m_dirPos.position = dir->curPosition() - 32;
    4532:	ldr	r3, [r6, #0]
    4534:	subs	r3, #32
    4536:	str	r3, [r4, #40]	; 0x28
      m_dirPos.isContiguous = dir->isContiguous();
    4538:	ldrb.w	r3, [r6, #51]	; 0x33
    453c:	ubfx	r3, r3, #6, #1
    4540:	strb.w	r3, [r4, #44]	; 0x2c
        freeCount = 0;
      }
      if (buf[0] != EXFAT_TYPE_FILE) {
        continue;
      }
      inSet = true;
    4544:	mov.w	fp, #1
    4548:	b.n	44a2 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
      }
      m_vol = dir->volume();
      m_dirPos.cluster = dir->curCluster();
      m_dirPos.position = dir->curPosition() - 32;
      m_dirPos.isContiguous = dir->isContiguous();
    } else if (buf[0] == EXFAT_TYPE_STREAM) {
    454a:	cmp	r2, #192	; 0xc0
    454c:	bne.n	45a6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x162>
      dirStream = reinterpret_cast<DirStream_t*>(buf);
      m_flags = modeFlags;
      if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    454e:	ldrb.w	r3, [sp, #17]
      m_dirPos.cluster = dir->curCluster();
      m_dirPos.position = dir->curPosition() - 32;
      m_dirPos.isContiguous = dir->isContiguous();
    } else if (buf[0] == EXFAT_TYPE_STREAM) {
      dirStream = reinterpret_cast<DirStream_t*>(buf);
      m_flags = modeFlags;
    4552:	strb.w	r9, [r4, #51]	; 0x33
      if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    4556:	lsls	r0, r3, #30
        m_flags |= FILE_FLAG_CONTIGUOUS;
    4558:	itt	mi
    455a:	orrmi.w	r3, r9, #64	; 0x40
    455e:	strbmi.w	r3, [r4, #51]	; 0x33
      }
      m_validLength = getLe64(dirStream->validLength);
    4562:	ldrd	r2, r3, [sp, #24]
    4566:	strd	r2, r3, [r4, #16]
      m_firstCluster = getLe32(dirStream->firstCluster);
    456a:	ldr	r3, [sp, #36]	; 0x24
    456c:	str	r3, [r4, #28]
      m_dataLength = getLe64(dirStream->dataLength);
    456e:	ldrd	r2, r3, [sp, #40]	; 0x28
    4572:	strd	r2, r3, [r4, #8]
      if (!fname) {
    4576:	cbnz	r5, 4580 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x13c>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    4578:	tst.w	sl, #2048	; 0x800
    457c:	bne.n	44b6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    457e:	b.n	45ce <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x18a>
  }
  void reset() {
    next = begin;
    4580:	ldr	r3, [r5, #0]
    4582:	str	r3, [r5, #4]
    ls = 0;
    4584:	mov.w	r3, #0
    4588:	strh	r3, [r5, #12]
      m_dataLength = getLe64(dirStream->dataLength);
      if (!fname) {
        goto found;
      }
      fname->reset();
      if (fname->nameLength != dirStream->nameLength ||
    458a:	ldr	r2, [r5, #16]
    458c:	ldrb.w	r3, [sp, #19]
    4590:	cmp	r2, r3
    4592:	bne.n	44e6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa2>
    4594:	ldrh.w	r2, [sp, #20]
    4598:	ldrh	r3, [r5, #20]
    459a:	subs	r1, r2, r3
    459c:	rsbs	fp, r1, #0
    45a0:	adc.w	fp, fp, r1
    45a4:	b.n	44a2 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
          fname->nameHash != getLe16(dirStream->nameHash)) {
        inSet = false;
      }
    } else if (buf[0] == EXFAT_TYPE_NAME) {
    45a6:	cmp	r2, #193	; 0xc1
    45a8:	bne.n	44e6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa2>
      dirName = reinterpret_cast<DirName_t*>(buf);
      if (!cmpName(dirName, fname)) {
    45aa:	mov	r2, r5
    45ac:	add	r1, sp, #16
    45ae:	mov	r0, r4
    45b0:	bl	3f38 <ExFatFile::cmpName(DirName_t const*, ExName_t*)>
    45b4:	cbnz	r0, 45ba <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x176>
        inSet = false;
    45b6:	mov	fp, r0
    45b8:	b.n	44a2 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    45ba:	ldrh	r2, [r5, #12]
    45bc:	cmp	r2, #0
    45be:	bne.w	44a2 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
    45c2:	ldr	r1, [r5, #4]
    45c4:	ldr	r2, [r5, #8]
    45c6:	cmp	r1, r2
    45c8:	bne.w	44a2 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
    45cc:	b.n	4578 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x134>
  if (oflag & O_EXCL) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Write, truncate, or at end is an error for a directory or read-only file.
  if ((oflag & (O_TRUNC | O_AT_END)) || (m_flags & FILE_FLAG_WRITE)) {
    45ce:	tst.w	sl, #17408	; 0x4400
    45d2:	bne.n	45dc <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x198>
    45d4:	ldrb.w	r3, [r4, #51]	; 0x33
    45d8:	lsls	r2, r3, #30
    45da:	bpl.n	45e8 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1a4>
    if (isSubDir() || isReadOnly() || READ_ONLY) {
    45dc:	ldrb.w	r3, [r4, #49]	; 0x31
    45e0:	tst.w	r3, #17
    45e4:	bne.w	44b6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      goto fail;
    }
  }

#if !READ_ONLY
  if (oflag & O_TRUNC) {
    45e8:	tst.w	sl, #1024	; 0x400
    45ec:	beq.n	4610 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1cc>
    if (!(m_flags & FILE_FLAG_WRITE)) {
    45ee:	ldrb.w	r3, [r4, #51]	; 0x33
    45f2:	lsls	r3, r3, #30
    45f4:	bpl.w	44b6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
    45f8:	movs	r2, #0
    45fa:	movs	r3, #0
    45fc:	mov	r0, r4
    45fe:	bl	4374 <ExFatFile::seekSet(unsigned long long)>
    4602:	cmp	r0, #0
    4604:	beq.w	44b6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    4608:	mov	r0, r4
    460a:	bl	5366 <ExFatFile::truncate()>
    460e:	b.n	4622 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1de>
    }
    if (!truncate(0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    4610:	tst.w	sl, #16384	; 0x4000
    4614:	beq.w	4774 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x330>
    4618:	ldrd	r2, r3, [r4, #16]
    461c:	mov	r0, r4
    461e:	bl	4374 <ExFatFile::seekSet(unsigned long long)>
    4622:	cmp	r0, #0
    4624:	beq.w	44b6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    4628:	b.n	4774 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x330>
#if READ_ONLY
  DBG_FAIL_MACRO;
  goto fail;
#else  // READ_ONLY
  // don't create unless O_CREAT and write
  if (!(oflag & O_CREAT) || !(modeFlags & FILE_FLAG_WRITE) || !fname) {
    462a:	tst.w	sl, #512	; 0x200
    462e:	beq.w	44b6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    4632:	tst.w	r9, #2
    4636:	beq.w	44b6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    463a:	cmp	r5, #0
    463c:	beq.w	44b6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    DBG_WARN_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    4640:	cmp	r7, r8
    4642:	bcs.n	467e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x23a>
    n = dir->read(buf, 32);
    4644:	movs	r2, #32
    4646:	add	r1, sp, #16
    4648:	mov	r0, r6
    464a:	bl	41c4 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    464e:	cbnz	r0, 4666 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x222>
      curCluster = dir->m_curCluster;
      if (!dir->addDirCluster()) {
    4650:	mov	r0, r6
    goto fail;
  }
  while (freeCount < freeNeed) {
    n = dir->read(buf, 32);
    if (n == 0) {
      curCluster = dir->m_curCluster;
    4652:	ldr.w	sl, [r6, #24]
      if (!dir->addDirCluster()) {
    4656:	bl	4fca <ExFatFile::addDirCluster()>
    465a:	cmp	r0, #0
    465c:	beq.w	44b6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
        DBG_FAIL_MACRO;
        goto fail;
      }
      dir->m_curCluster = curCluster;
    4660:	str.w	sl, [r6, #24]
      continue;
    4664:	b.n	4640 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1fc>
    }
    if (n != 32) {
    4666:	cmp	r0, #32
    4668:	bne.w	44b6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (freeCount == 0) {
    466c:	cbnz	r7, 4678 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x234>
      freePos.position = dir->curPosition() - 32;
    466e:	ldr	r3, [r6, #0]
    4670:	subs	r3, #32
    4672:	str	r3, [sp, #4]
    4674:	ldr	r3, [r6, #24]
    4676:	str	r3, [sp, #0]
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
    4678:	adds	r7, #1
    467a:	uxtb	r7, r7
    467c:	b.n	4640 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1fc>
  }
  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
    467e:	movs	r2, #56	; 0x38
    4680:	movs	r1, #0
    4682:	mov	r0, r4
      freePos.position = dir->curPosition() - 32;
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }
  freePos.isContiguous = dir->isContiguous();
    4684:	ldrb.w	r7, [r6, #51]	; 0x33
  memset(this, 0, sizeof(ExFatFile));
    4688:	bl	90e4 <memset>
    468c:	ldr	r3, [r6, #32]
  m_vol = dir->volume();
    468e:	str	r3, [r4, #32]
  m_attributes = FILE_ATTR_FILE;
    4690:	movs	r3, #8
    4692:	strb.w	r3, [r4, #49]	; 0x31
  m_dirPos = freePos;
    4696:	ldr	r3, [sp, #0]
    4698:	str	r3, [r4, #36]	; 0x24
      freePos.position = dir->curPosition() - 32;
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }
  freePos.isContiguous = dir->isContiguous();
    469a:	ubfx	r7, r7, #6, #1
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
    469e:	ldr	r3, [sp, #4]
    46a0:	strb.w	r7, [r4, #44]	; 0x2c
    46a4:	str	r3, [r4, #40]	; 0x28
  }
  void reset() {
    next = begin;
    46a6:	ldr	r3, [r5, #0]
    46a8:	str	r3, [r5, #4]
    ls = 0;
    46aa:	movs	r7, #0
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    46ac:	add.w	sl, r8, #4294967295
    46b0:	strh	r7, [r5, #12]
    46b2:	uxtb.w	sl, sl
    46b6:	uxtb.w	fp, r7
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  fname->reset();
  for (uint8_t i = 0; i < freeNeed; i++) {
    46ba:	cmp	fp, r8
    46bc:	bcs.n	475e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x31a>
    cache = dirCache(i, FsCache::CACHE_FOR_WRITE);
    46be:	movs	r2, #1
    46c0:	mov	r1, fp
    46c2:	mov	r0, r4
    46c4:	bl	4096 <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache || (cache[0] & 0x80)) {
    46c8:	mov	r6, r0
    46ca:	cmp	r0, #0
    46cc:	beq.w	44b6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    46d0:	ldrsb.w	r2, [r0]
    46d4:	cmp	r2, #0
    46d6:	blt.w	44b6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memset(cache, 0 , 32);
    46da:	movs	r2, #32
    46dc:	movs	r1, #0
    46de:	bl	90e4 <memset>
    if (i == 0) {
    46e2:	cmp.w	fp, #0
    46e6:	bne.n	4726 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x2e2>
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
    46e8:	movs	r3, #133	; 0x85
    46ea:	strb	r3, [r6, #0]
      m_setCount = freeNeed - 1;
      dirFile->setCount = m_setCount;

      if (FsDateTime::callback) {
    46ec:	ldr	r3, [pc, #160]	; (4790 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x34c>)
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    46ee:	strb.w	sl, [r4, #48]	; 0x30
      dirFile->setCount = m_setCount;
    46f2:	strb.w	sl, [r6, #1]

      if (FsDateTime::callback) {
    46f6:	ldr	r3, [r3, #0]
    46f8:	cbz	r3, 471a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x2d6>
        uint16_t date, time;
        uint8_t ms10;
        FsDateTime::callback(&date, &time, &ms10);
    46fa:	add.w	r2, sp, #11
    46fe:	add.w	r1, sp, #14
    4702:	add	r0, sp, #12
    4704:	blx	r3
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    4706:	ldrh.w	r3, [sp, #12]
    470a:	strh	r3, [r6, #10]
    470c:	ldrh.w	r3, [sp, #14]
    4710:	strh	r3, [r6, #8]
        setLe16(dirFile->createDate, date);
        setLe16(dirFile->createTime, time);
        dirFile->createTimeMs = ms10;
    4712:	ldrb.w	r3, [sp, #11]
    4716:	strb	r3, [r6, #20]
    4718:	b.n	475a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
    471a:	movw	r3, #21537	; 0x5421
    471e:	strh	r3, [r6, #10]
    4720:	strh	r3, [r6, #14]
    4722:	strh	r3, [r6, #18]
    4724:	b.n	475a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
         setLe16(dirFile->createTime, FS_DEFAULT_TIME);
         setLe16(dirFile->modifyTime, FS_DEFAULT_TIME);
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
    4726:	cmp.w	fp, #1
    472a:	bne.n	4746 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x302>
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
      dirStream->flags = EXFAT_FLAG_ALWAYS1;
      m_flags = modeFlags | FILE_FLAG_DIR_DIRTY;
    472c:	orn	r3, r9, #127	; 0x7f
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
    4730:	movs	r2, #192	; 0xc0
    4732:	strb	r2, [r6, #0]
      dirStream->flags = EXFAT_FLAG_ALWAYS1;
    4734:	strb.w	fp, [r6, #1]
      m_flags = modeFlags | FILE_FLAG_DIR_DIRTY;
    4738:	strb.w	r3, [r4, #51]	; 0x33
      dirStream->nameLength = fname->nameLength;
    473c:	ldr	r3, [r5, #16]
    473e:	strb	r3, [r6, #3]
      setLe16(dirStream->nameHash, fname->nameHash);
    4740:	ldrh	r3, [r5, #20]
    4742:	strh	r3, [r6, #4]
    4744:	b.n	475a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
    } else {
      dirName = reinterpret_cast<DirName_t*>(cache);
      dirName->type = EXFAT_TYPE_NAME;
    4746:	movs	r3, #193	; 0xc1
    4748:	strb	r3, [r6, #0]
    474a:	add.w	fp, r6, #30
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    474e:	ldrh	r2, [r5, #12]
    4750:	cbnz	r2, 4778 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x334>
    4752:	ldr	r1, [r5, #4]
    4754:	ldr	r2, [r5, #8]
    4756:	cmp	r1, r2
    4758:	bne.n	4778 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x334>
    475a:	adds	r7, #1
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  fname->reset();
  for (uint8_t i = 0; i < freeNeed; i++) {
    475c:	b.n	46b6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x272>
        uint16_t u = fname->get16();
        setLe16(dirName->unicode + 2*k, u);
      }
    }
  }
  return sync();
    475e:	mov	r0, r4
    4760:	bl	4f8c <ExFatFile::sync()>
    4764:	b.n	4788 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
  if (isOpen() || !dir->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }

  switch (oflag & O_ACCMODE) {
    4766:	cmp	r3, #0
    4768:	bne.w	44b6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    case O_RDONLY:
      modeFlags = FILE_FLAG_READ;
    476c:	movs	r3, #1
    476e:	b.n	4474 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30>
      break;
    case O_WRONLY:
      modeFlags = FILE_FLAG_WRITE;
    4770:	movs	r3, #2
    4772:	b.n	4474 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30>
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    DBG_FAIL_MACRO;
    goto fail;
  }
#endif  // !READ_ONLY
  return true;
    4774:	movs	r0, #1
    4776:	b.n	4788 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
      dirName->type = EXFAT_TYPE_NAME;
      for (size_t k = 0; k < 15; k++) {
        if (fname->atEnd()) {
          break;
        }
        uint16_t u = fname->get16();
    4778:	mov	r0, r5
    477a:	bl	3980 <FsName::get16()>
    477e:	strh.w	r0, [r6, #2]!
      dirStream->nameLength = fname->nameLength;
      setLe16(dirStream->nameHash, fname->nameHash);
    } else {
      dirName = reinterpret_cast<DirName_t*>(cache);
      dirName->type = EXFAT_TYPE_NAME;
      for (size_t k = 0; k < 15; k++) {
    4782:	cmp	r6, fp
    4784:	bne.n	474e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30a>
    4786:	b.n	475a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
 fail:
  // close file
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
    4788:	add	sp, #52	; 0x34
    478a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    478e:	nop
    4790:	.word	0x2001a690

00004794 <ExFatFile::open(ExFatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
    4794:	push	{r4, r5, r6, r7, lr}
    4796:	sub	sp, #92	; 0x5c
    4798:	mov	r7, r3
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    479a:	movs	r3, #0
    479c:	strb.w	r3, [sp, #81]	; 0x51
    47a0:	strb.w	r3, [sp, #82]	; 0x52
    47a4:	strb.w	r3, [sp, #83]	; 0x53
 */
/**
 * \class FsName
 * \brief Handle UTF-8 file names.
 */
class FsName {
    47a8:	strh.w	r3, [sp, #20]
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    47ac:	ldrb.w	r3, [r0, #49]	; 0x31
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
    47b0:	str	r2, [sp, #4]
    47b2:	mov	r5, r0
    47b4:	mov	r4, r1
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    47b6:	cbz	r3, 47bc <ExFatFile::open(ExFatFile*, char const*, int)+0x28>
    close();
  }
  return openPrivate(dirFile, &fname, oflag);

 fail:
  return false;
    47b8:	movs	r0, #0
    47ba:	b.n	484a <ExFatFile::open(ExFatFile*, char const*, int)+0xb6>
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    47bc:	ldrb.w	r3, [r1, #49]	; 0x31
    47c0:	tst.w	r3, #80	; 0x50
    47c4:	beq.n	47b8 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    47c6:	ldrb	r3, [r2, #0]
    47c8:	cmp	r3, #47	; 0x2f
    47ca:	bne.n	47f2 <ExFatFile::open(ExFatFile*, char const*, int)+0x5e>
    while (isDirSeparator(*path)) {
    47cc:	ldr	r3, [sp, #4]
    47ce:	ldrb	r2, [r3, #0]
    47d0:	cmp	r2, #47	; 0x2f
    47d2:	bne.n	47da <ExFatFile::open(ExFatFile*, char const*, int)+0x46>
      path++;
    47d4:	adds	r3, #1
    47d6:	str	r3, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    47d8:	b.n	47cc <ExFatFile::open(ExFatFile*, char const*, int)+0x38>
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    47da:	ldr	r1, [r4, #32]
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
    47dc:	cbnz	r2, 47e6 <ExFatFile::open(ExFatFile*, char const*, int)+0x52>
      return openRoot(dirFile->m_vol);
    47de:	mov	r0, r5
    47e0:	bl	4122 <ExFatFile::openRoot(ExFatVolume*)>
    47e4:	b.n	484a <ExFatFile::open(ExFatFile*, char const*, int)+0xb6>
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    47e6:	add	r0, sp, #32
    47e8:	bl	4122 <ExFatFile::openRoot(ExFatVolume*)>
    47ec:	cmp	r0, #0
    47ee:	beq.n	47b8 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    47f0:	add	r4, sp, #32
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    47f2:	add	r3, sp, #4
    47f4:	add	r2, sp, #8
    47f6:	ldr	r1, [sp, #4]
    47f8:	mov	r0, r5
    47fa:	bl	4148 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    47fe:	cmp	r0, #0
    4800:	beq.n	47b8 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    4802:	ldr	r3, [sp, #4]
    4804:	ldrb	r3, [r3, #0]
    4806:	cbz	r3, 483e <ExFatFile::open(ExFatFile*, char const*, int)+0xaa>
      break;
    }
    if (!openPrivate(dirFile, &fname, O_RDONLY)) {
    4808:	movs	r3, #0
    480a:	add	r2, sp, #8
    480c:	mov	r1, r4
    480e:	mov	r0, r5
    4810:	bl	4444 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    4814:	cmp	r0, #0
    4816:	beq.n	47b8 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_WARN_MACRO;
      goto fail;
    }
    tmpDir = *this;
    4818:	add	r2, sp, #32
    481a:	mov	r3, r5
    481c:	add.w	lr, r5, #48	; 0x30
    4820:	mov	r4, r2
    4822:	ldr	r0, [r3, #0]
    4824:	ldr	r1, [r3, #4]
    4826:	mov	r6, r2
    4828:	stmia	r6!, {r0, r1}
    482a:	adds	r3, #8
    482c:	cmp	r3, lr
    482e:	mov	r2, r6
    4830:	bne.n	4822 <ExFatFile::open(ExFatFile*, char const*, int)+0x8e>
    4832:	ldr	r0, [r3, #0]
    4834:	str	r0, [r6, #0]
    dirFile = &tmpDir;
    close();
    4836:	mov	r0, r5
    4838:	bl	40ce <ExFatFile::close()>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    483c:	b.n	47f2 <ExFatFile::open(ExFatFile*, char const*, int)+0x5e>
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    close();
  }
  return openPrivate(dirFile, &fname, oflag);
    483e:	mov	r3, r7
    4840:	add	r2, sp, #8
    4842:	mov	r1, r4
    4844:	mov	r0, r5
    4846:	bl	4444 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>

 fail:
  return false;
}
    484a:	add	sp, #92	; 0x5c
    484c:	pop	{r4, r5, r6, r7, pc}

0000484e <ExFatFile::open(ExFatVolume*, char const*, int)>:
bool ExFatFile::open(const char* path, oflag_t oflag) {
  return open(ExFatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
    484e:	cbz	r1, 4858 <ExFatFile::open(ExFatVolume*, char const*, int)+0xa>
    4850:	add.w	r1, r1, #1096	; 0x448
    4854:	b.w	4794 <ExFatFile::open(ExFatFile*, char const*, int)>
}
    4858:	mov	r0, r1
    485a:	bx	lr

0000485c <ExFatFile::openNext(ExFatFile*, int)>:
    DBG_FAIL_MACRO;
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
    485c:	push	{r4, r5}
    485e:	mov	r3, r2
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    4860:	ldrb.w	r2, [r0, #49]	; 0x31
    4864:	cbnz	r2, 4884 <ExFatFile::openNext(ExFatFile*, int)+0x28>
    4866:	ldrb.w	r5, [r1, #49]	; 0x31
    486a:	tst.w	r5, #80	; 0x50
    486e:	beq.n	4884 <ExFatFile::openNext(ExFatFile*, int)+0x28>
    4870:	ldrd	r4, r5, [r1]
    4874:	movs	r5, #0
    4876:	and.w	r4, r4, #31
    487a:	orrs	r4, r5
    487c:	bne.n	4884 <ExFatFile::openNext(ExFatFile*, int)+0x28>
  }
  return openPrivate(dir, nullptr, oflag);

 fail:
  return false;
}
    487e:	pop	{r4, r5}
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return openPrivate(dir, nullptr, oflag);
    4880:	b.w	4444 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>

 fail:
  return false;
}
    4884:	movs	r0, #0
    4886:	pop	{r4, r5}
    4888:	bx	lr

0000488a <ExFatPartition::bitmapFind(unsigned long, unsigned long)>:
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"

//------------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
    488a:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    488e:	mov	r8, r0
    4890:	mov	sl, r2
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
    4892:	mov	r9, r1
    4894:	cbz	r1, 489a <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x10>
    4896:	subs	r4, r1, #2
    4898:	b.n	489e <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x14>
    489a:	ldr.w	r4, [r0, #1056]	; 0x420
  if (start >= m_clusterCount) {
    489e:	ldr.w	r3, [r8, #1072]	; 0x430
    start = 0;
    48a2:	cmp	r4, r3
    48a4:	it	cs
    48a6:	movcs	r4, #0
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
  uint16_t sectorSize = 1 << m_bytesPerSectorShift;
  size_t i = (start >> 3) & (sectorSize - 1);
  uint8_t* cache;
  uint8_t mask = 1 << (start & 7);
    48a8:	and.w	r7, r4, #7
    48ac:	movs	r3, #1
    48ae:	lsl.w	r7, r3, r7
    start = 0;
  }
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
  uint16_t sectorSize = 1 << m_bytesPerSectorShift;
  size_t i = (start >> 3) & (sectorSize - 1);
    48b2:	ubfx	fp, r4, #3, #9
  uint8_t* cache;
  uint8_t mask = 1 << (start & 7);
    48b6:	uxtb	r7, r7
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
  }
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
    48b8:	mov	r6, r4
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
  }
  uint32_t endAlloc = start;
    48ba:	mov	r5, r4
  bool bitmapModify(uint32_t cluster, uint32_t count, bool value);
  //----------------------------------------------------------------------------
  // Cache functions.
  uint8_t* bitmapCacheGet(uint32_t sector, uint8_t option) {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.get(sector, option);
    48bc:	ldr.w	r1, [r8, #1068]	; 0x42c
    48c0:	movs	r2, #0
    48c2:	add.w	r1, r1, r5, lsr #12
    48c6:	mov	r0, r8
    48c8:	bl	388e <FsCache::get(unsigned long, unsigned char)>
  uint8_t mask = 1 << (start & 7);
  while (true) {
    uint32_t sector = m_clusterHeapStartSector +
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
    48cc:	cbz	r0, 492c <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0xa2>
    48ce:	mov	r3, r7
    48d0:	mov	r1, fp
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
    48d2:	ldrb	r7, [r0, r1]
    48d4:	tst	r7, r3
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
    48d6:	add.w	r5, r5, #1
        if (!(mask & cache[i])) {
    48da:	bne.n	48f8 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x6e>
          if ((endAlloc - bgnAlloc) == count) {
    48dc:	subs	r2, r5, r6
    48de:	cmp	r2, sl
    48e0:	bne.n	48fa <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x70>
            if (cluster == 0 && count == 1) {
    48e2:	cmp.w	r9, #0
    48e6:	bne.n	48f2 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x68>
    48e8:	cmp.w	sl, #1
              // Start at found sector.  bitmapModify may increase this.
              m_bitmapStart = bgnAlloc;
    48ec:	it	eq
    48ee:	streq.w	r6, [r8, #1056]	; 0x420
            }
            return bgnAlloc + 2;
    48f2:	adds	r0, r6, #2
    48f4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
    48f8:	mov	r6, r5
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    48fa:	cmp	r4, r5
    48fc:	beq.n	492a <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0xa0>
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
    48fe:	ldr.w	r2, [r8, #1072]	; 0x430
    4902:	cmp	r5, r2
    4904:	bcs.n	4910 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x86>
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
    4906:	lsls	r3, r3, #1
    4908:	ands.w	r3, r3, #255	; 0xff
    490c:	bne.n	48d4 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x4a>
    490e:	b.n	4918 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x8e>
        }
        if (endAlloc == start) {
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
          endAlloc = bgnAlloc = 0;
    4910:	movs	r6, #0
          i = sectorSize;
    4912:	mov.w	r1, #512	; 0x200
        }
        if (endAlloc == start) {
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
          endAlloc = bgnAlloc = 0;
    4916:	mov	r5, r6
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    4918:	adds	r1, #1
    491a:	movs	r3, #1
    491c:	cmp.w	r1, #512	; 0x200
          break;
        }
      }
      mask = 1;
    }
    i = 0;
    4920:	mov.w	fp, #0
          endAlloc = bgnAlloc = 0;
          i = sectorSize;
          break;
        }
      }
      mask = 1;
    4924:	mov	r7, r3
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    4926:	bcc.n	48d2 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x48>
    4928:	b.n	48bc <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x32>
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
          return 1;
    492a:	movs	r0, #1
      mask = 1;
    }
    i = 0;
  }
  return 0;
}
    492c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00004930 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>:
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    4930:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4934:	mov	r7, r2
    4936:	mov	r6, r0
  uint32_t sector;
  uint32_t start = cluster - 2;
    4938:	subs	r2, r1, #2
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    493a:	ldr.w	r0, [r0, #1072]	; 0x430
    493e:	adds	r1, r2, r7
    4940:	cmp	r1, r0
  }
  return 0;
}
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    4942:	mov	r8, r3
  uint32_t start = cluster - 2;
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    4944:	bhi.n	49ca <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
    4946:	ldr.w	r3, [r6, #1056]	; 0x420
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    494a:	cmp.w	r8, #0
    494e:	beq.n	4964 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x34>
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
    4950:	cmp	r2, r3
    4952:	bhi.n	496c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
    4954:	cmp	r1, r3
    4956:	bls.n	496c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
      m_bitmapStart = (start + count) < m_clusterCount ? start + count : 0;
    4958:	cmp	r1, r0
    495a:	it	cs
    495c:	movcs	r1, #0
    495e:	str.w	r1, [r6, #1056]	; 0x420
    4962:	b.n	496c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
    }
  } else {
    if (start < m_bitmapStart) {
    4964:	cmp	r2, r3
      m_bitmapStart = start;
    4966:	it	cc
    4968:	strcc.w	r2, [r6, #1056]	; 0x420
    }
  }
  mask = 1 << (start & 7);
    496c:	and.w	r5, r2, #7
    4970:	movs	r3, #1
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    4972:	ldr.w	r1, [r6, #1068]	; 0x42c
  } else {
    if (start < m_bitmapStart) {
      m_bitmapStart = start;
    }
  }
  mask = 1 << (start & 7);
    4976:	lsl.w	r5, r3, r5
    497a:	uxtb	r5, r5
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    497c:	add.w	r1, r1, r2, lsr #12
  i = (start >> 3) & m_sectorMask;
    4980:	ubfx	r4, r2, #3, #9
    4984:	movs	r2, #1
    4986:	mov	r0, r6
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    4988:	add.w	r9, r1, #1
    498c:	bl	388e <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    4990:	cbz	r0, 49ca <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
    4992:	adds	r3, r0, r4
    4994:	mov	r2, r5
    4996:	add.w	r0, r0, #512	; 0x200
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
    499a:	ldrb	r1, [r3, #0]
    499c:	tst	r1, r2
    499e:	ite	ne
    49a0:	movne	r4, #1
    49a2:	moveq	r4, #0
    49a4:	cmp	r4, r8
    49a6:	beq.n	49ca <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    49a8:	eors	r1, r2
        if (--count == 0) {
    49aa:	subs	r7, #1
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    49ac:	strb	r1, [r3, #0]
        if (--count == 0) {
    49ae:	beq.n	49d0 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0xa0>
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
    49b0:	lsls	r2, r2, #1
    49b2:	ands.w	r2, r2, #255	; 0xff
    49b6:	bne.n	499a <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x6a>
    49b8:	adds	r3, #1
          return true;
        }
      }
      mask = 1;
    }
    i = 0;
    49ba:	mov	r4, r2
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    49bc:	cmp	r0, r3
    49be:	mov.w	r2, #1
  mask = 1 << (start & 7);
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
  i = (start >> 3) & m_sectorMask;
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    49c2:	mov	r1, r9
        cache[i] ^= mask;
        if (--count == 0) {
          return true;
        }
      }
      mask = 1;
    49c4:	mov	r5, r2
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    49c6:	bne.n	499a <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x6a>
    49c8:	b.n	4984 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x54>
    }
    i = 0;
  }

 fail:
  return false;
    49ca:	movs	r0, #0
    49cc:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
        if (--count == 0) {
          return true;
    49d0:	movs	r0, #1
    i = 0;
  }

 fail:
  return false;
}
    49d2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000049d6 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>:
    n++;
  } while (status);
  return n;
}
//------------------------------------------------------------------------------
uint8_t* ExFatPartition::dirCache(DirPos_t* pos, uint8_t options) {
    49d6:	push	{r3, r4, r5, lr}
    49d8:	mov	r5, r1
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    49da:	ldr.w	r1, [r0, #1080]	; 0x438
    49de:	ldr	r3, [r5, #4]
    49e0:	ands	r1, r3
    49e2:	ldr	r3, [r5, #0]
    49e4:	subs	r4, r3, #2
    49e6:	ldrb.w	r3, [r0, #1093]	; 0x445
    49ea:	lsl.w	r3, r4, r3
    49ee:	add.w	r3, r3, r1, lsr #9
    49f2:	ldr.w	r1, [r0, #1068]	; 0x42c
    49f6:	add.w	r0, r0, #528	; 0x210
    49fa:	add	r1, r3
    49fc:	bl	388e <FsCache::get(unsigned long, unsigned char)>
  uint32_t sector = clusterStartSector(pos->cluster);
  sector += (m_clusterMask & pos->position) >> m_bytesPerSectorShift;
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
    4a00:	cbz	r0, 4a0a <ExFatPartition::dirCache(DirPos_t*, unsigned char)+0x34>
    4a02:	ldr	r3, [r5, #4]
    4a04:	ubfx	r3, r3, #0, #9
    4a08:	add	r0, r3
}
    4a0a:	pop	{r3, r4, r5, pc}

00004a0c <ExFatPartition::fatGet(unsigned long, unsigned long*)>:
  }
  return 1;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    4a0c:	push	{r3, r4, r5, lr}
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    4a0e:	ldr.w	r3, [r0, #1072]	; 0x430
    4a12:	adds	r3, #1
    4a14:	cmp	r3, r1
  }
  return 1;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    4a16:	mov	r4, r1
    4a18:	mov	r5, r2
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    4a1a:	bcs.n	4a22 <ExFatPartition::fatGet(unsigned long, unsigned long*)+0x16>
    DBG_FAIL_MACRO;
    return -1;
    4a1c:	mov.w	r0, #4294967295
    4a20:	pop	{r3, r4, r5, pc}
    4a22:	ldr.w	r1, [r0, #1060]	; 0x424
    4a26:	movs	r2, #0
    4a28:	add.w	r1, r1, r4, lsr #7
    4a2c:	add.w	r0, r0, #528	; 0x210
    4a30:	bl	388e <FsCache::get(unsigned long, unsigned char)>
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));

  cache = dataCacheGet(sector, FsCache::CACHE_FOR_READ);
  if (!cache) {
    4a34:	cmp	r0, #0
    4a36:	beq.n	4a1c <ExFatPartition::fatGet(unsigned long, unsigned long*)+0x10>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    4a38:	lsls	r4, r4, #2
    4a3a:	ubfx	r4, r4, #0, #9
    4a3e:	ldr	r0, [r0, r4]
    return -1;
  }
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));
  *value = next;
    4a40:	str	r0, [r5, #0]
  return next == EXFAT_EOC ? 0 : 1;
    4a42:	adds	r0, #1
    4a44:	it	ne
    4a46:	movne	r0, #1
}
    4a48:	pop	{r3, r4, r5, pc}

00004a4a <ExFatPartition::chainSize(unsigned long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
    4a4a:	push	{r0, r1, r4, r5, r6, lr}
    4a4c:	add	r5, sp, #8
    4a4e:	mov	r6, r0
    4a50:	str.w	r1, [r5, #-4]!
  uint32_t n = 0;
    4a54:	movs	r4, #0
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    4a56:	mov	r2, r5
    4a58:	ldr	r1, [sp, #4]
    4a5a:	mov	r0, r6
    4a5c:	bl	4a0c <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    if (status < 0) return 0;
    4a60:	cmp	r0, #0
    4a62:	blt.n	4a6e <ExFatPartition::chainSize(unsigned long)+0x24>
    n++;
    4a64:	add.w	r4, r4, #1
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    4a68:	bne.n	4a56 <ExFatPartition::chainSize(unsigned long)+0xc>
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    n++;
    4a6a:	mov	r0, r4
    4a6c:	b.n	4a70 <ExFatPartition::chainSize(unsigned long)+0x26>
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    4a6e:	movs	r0, #0
    n++;
  } while (status);
  return n;
}
    4a70:	add	sp, #8
    4a72:	pop	{r4, r5, r6, pc}

00004a74 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>:
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    4a74:	push	{r4, r5, r6, lr}
    4a76:	mov	r5, r1
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    4a78:	ldr.w	r4, [r0, #1080]	; 0x438
    4a7c:	ldr	r1, [r1, #4]
    4a7e:	ands	r4, r1
    4a80:	adds	r3, r4, r2
  pos->position += offset;
    4a82:	add	r2, r1
    4a84:	str	r2, [r5, #4]
  tmp >>= bytesPerClusterShift();
    4a86:	ldrb.w	r4, [r0, #1093]	; 0x445
    4a8a:	adds	r4, #9
    4a8c:	uxtb	r4, r4
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    4a8e:	mov	r6, r0
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
    4a90:	lsr.w	r4, r3, r4
  while (tmp--) {
    4a94:	cbz	r4, 4ab4 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x40>
    if (pos->isContiguous) {
    4a96:	ldrb	r3, [r5, #8]
    4a98:	cbz	r3, 4aa4 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x30>
      pos->cluster++;
    4a9a:	ldr	r3, [r5, #0]
    4a9c:	adds	r3, #1
    4a9e:	str	r3, [r5, #0]
    4aa0:	subs	r4, #1
    4aa2:	b.n	4a94 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x20>
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    4aa4:	mov	r2, r5
    4aa6:	ldr	r1, [r5, #0]
    4aa8:	mov	r0, r6
    4aaa:	bl	4a0c <ExFatPartition::fatGet(unsigned long, unsigned long*)>
      if (status != 1) {
    4aae:	cmp	r0, #1
    4ab0:	beq.n	4aa0 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x2c>
    4ab2:	pop	{r4, r5, r6, pc}
        return status;
      }
    }
  }
  return 1;
    4ab4:	movs	r0, #1
}
    4ab6:	pop	{r4, r5, r6, pc}

00004ab8 <ExFatPartition::fatPut(unsigned long, unsigned long)>:
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    4ab8:	cmp	r1, #1
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));
  *value = next;
  return next == EXFAT_EOC ? 0 : 1;
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
    4aba:	push	{r3, r4, r5, lr}
    4abc:	mov	r4, r1
    4abe:	mov	r5, r2
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    4ac0:	bhi.n	4ac6 <ExFatPartition::fatPut(unsigned long, unsigned long)+0xe>
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;

 fail:
  return false;
    4ac2:	movs	r0, #0
    4ac4:	pop	{r3, r4, r5, pc}
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    4ac6:	ldr.w	r3, [r0, #1072]	; 0x430
    4aca:	adds	r3, #1
    4acc:	cmp	r1, r3
    4ace:	bhi.n	4ac2 <ExFatPartition::fatPut(unsigned long, unsigned long)+0xa>
    4ad0:	ldr.w	r1, [r0, #1060]	; 0x424
    4ad4:	movs	r2, #1
    4ad6:	add.w	r1, r1, r4, lsr #7
    4ada:	add.w	r0, r0, #528	; 0x210
    4ade:	bl	388e <FsCache::get(unsigned long, unsigned char)>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
  cache = dataCacheGet(sector, FsCache::CACHE_FOR_WRITE);
  if (!cache) {
    4ae2:	cmp	r0, #0
    4ae4:	beq.n	4ac2 <ExFatPartition::fatPut(unsigned long, unsigned long)+0xa>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    4ae6:	lsls	r4, r4, #2
    4ae8:	ubfx	r4, r4, #0, #9
    4aec:	str	r5, [r0, r4]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;
    4aee:	movs	r0, #1

 fail:
  return false;
}
    4af0:	pop	{r3, r4, r5, pc}

00004af2 <ExFatPartition::freeChain(unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
    4af2:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    4af6:	mov	r7, r0
    4af8:	mov	r4, r1
  uint32_t next;
  uint32_t start = cluster;
    4afa:	mov	r6, r1
  int8_t status;
  do {
    status = fatGet(cluster, &next);
    4afc:	add	r2, sp, #4
    4afe:	mov	r1, r4
    4b00:	mov	r0, r7
    4b02:	bl	4a0c <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    if (status < 0) {
    4b06:	subs.w	r8, r0, #0
    4b0a:	bge.n	4b10 <ExFatPartition::freeChain(unsigned long)+0x1e>
  } while (status);

  return true;

 fail:
  return false;
    4b0c:	movs	r5, #0
    4b0e:	b.n	4b48 <ExFatPartition::freeChain(unsigned long)+0x56>
    status = fatGet(cluster, &next);
    if (status < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!fatPut(cluster, 0)) {
    4b10:	movs	r2, #0
    4b12:	mov	r1, r4
    4b14:	mov	r0, r7
    4b16:	bl	4ab8 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4b1a:	mov	r5, r0
    4b1c:	cmp	r0, #0
    4b1e:	beq.n	4b0c <ExFatPartition::freeChain(unsigned long)+0x1a>
    4b20:	adds	r2, r4, #1
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (status == 0 || (cluster + 1) != next) {
    4b22:	cmp.w	r8, #0
    4b26:	beq.n	4b2e <ExFatPartition::freeChain(unsigned long)+0x3c>
    4b28:	ldr	r3, [sp, #4]
    4b2a:	cmp	r2, r3
    4b2c:	beq.n	4b40 <ExFatPartition::freeChain(unsigned long)+0x4e>
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    4b2e:	movs	r3, #0
    4b30:	subs	r2, r2, r6
    4b32:	mov	r1, r6
    4b34:	mov	r0, r7
    4b36:	bl	4930 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4b3a:	cmp	r0, #0
    4b3c:	beq.n	4b0c <ExFatPartition::freeChain(unsigned long)+0x1a>
        DBG_FAIL_MACRO;
        goto fail;
      }
      start = next;
    4b3e:	ldr	r6, [sp, #4]
    }
    cluster = next;
    4b40:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  uint32_t start = cluster;
  int8_t status;
  do {
    4b42:	cmp.w	r8, #0
    4b46:	bne.n	4afc <ExFatPartition::freeChain(unsigned long)+0xa>

  return true;

 fail:
  return false;
}
    4b48:	mov	r0, r5
    4b4a:	add	sp, #8
    4b4c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00004b50 <ExFatPartition::freeClusterCount()>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    4b50:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t nc = 0;
  uint32_t sector = m_clusterHeapStartSector;
    4b54:	ldr.w	r1, [r0, #1068]	; 0x42c
  uint32_t usedCount = 0;
    4b58:	movs	r4, #0

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    4b5a:	mov	r6, r0
  uint32_t nc = 0;
    4b5c:	mov	r5, r4
    4b5e:	add.w	r7, r0, #528	; 0x210
    4b62:	movs	r2, #0
    4b64:	mov	r0, r7
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
  uint8_t* cache;

  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    4b66:	add.w	r8, r1, #1
    4b6a:	bl	388e <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    4b6e:	cbz	r0, 4bb0 <ExFatPartition::freeClusterCount()+0x60>
    4b70:	add.w	lr, r0, #4294967295
    4b74:	add.w	ip, r5, #4096	; 0x1000
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
    4b78:	ldrb.w	r1, [lr, #1]!
    4b7c:	cmp	r1, #255	; 0xff
    4b7e:	bne.n	4b84 <ExFatPartition::freeClusterCount()+0x34>
        usedCount+= 8;
    4b80:	adds	r4, #8
    4b82:	b.n	4b98 <ExFatPartition::freeClusterCount()+0x48>
      } else if (cache[i]) {
    4b84:	cbz	r1, 4b98 <ExFatPartition::freeClusterCount()+0x48>
    4b86:	movs	r2, #8
    4b88:	movs	r3, #1
        for (uint8_t mask = 1; mask ; mask <<=1) {
          if ((mask & cache[i])) {
    4b8a:	tst	r1, r3
            usedCount++;
    4b8c:	it	ne
    4b8e:	addne	r4, #1
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
      } else if (cache[i]) {
        for (uint8_t mask = 1; mask ; mask <<=1) {
    4b90:	lsls	r3, r3, #1
    4b92:	subs	r2, #1
    4b94:	uxtb	r3, r3
    4b96:	bne.n	4b8a <ExFatPartition::freeClusterCount()+0x3a>
            usedCount++;
          }
        }
      }
      nc += 8;
      if (nc >= m_clusterCount) {
    4b98:	ldr.w	r0, [r6, #1072]	; 0x430
          if ((mask & cache[i])) {
            usedCount++;
          }
        }
      }
      nc += 8;
    4b9c:	adds	r5, #8
      if (nc >= m_clusterCount) {
    4b9e:	cmp	r5, r0
    4ba0:	bcc.n	4ba8 <ExFatPartition::freeClusterCount()+0x58>
        return m_clusterCount - usedCount;
    4ba2:	subs	r0, r0, r4
    4ba4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
    4ba8:	cmp	r5, ip
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
  uint8_t* cache;

  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    4baa:	mov	r1, r8
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
    4bac:	bne.n	4b78 <ExFatPartition::freeClusterCount()+0x28>
    4bae:	b.n	4b62 <ExFatPartition::freeClusterCount()+0x12>
      if (nc >= m_clusterCount) {
        return m_clusterCount - usedCount;
      }
    }
  }
}
    4bb0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00004bb4 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>:
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    4bb4:	push	{r4, r5, r6, r7, lr}
    4bb6:	mov	r4, r0
    4bb8:	sub	sp, #28
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif
  BpbExFat_t* bpb;

  m_fatType = 0;
    4bba:	movs	r5, #0
      }
    }
  }
}
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    4bbc:	mov	r0, r1
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    4bbe:	mov.w	r3, #4294967295
    4bc2:	mov	r1, r2
    4bc4:	str	r3, [r4, #12]
    4bc6:	str.w	r3, [r4, #540]	; 0x21c
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif
  BpbExFat_t* bpb;

  m_fatType = 0;
    4bca:	strb.w	r5, [r4, #1092]	; 0x444
  m_blockDev = dev;
    4bce:	str.w	r0, [r4, #1088]	; 0x440
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    4bd2:	str	r0, [r4, #4]
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4bd4:	strb	r5, [r4, #0]
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    4bd6:	str.w	r0, [r4, #532]	; 0x214
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4bda:	strb.w	r5, [r4, #528]	; 0x210
  cacheInit(m_blockDev);


  #if SUPPORT_GPT_AND_EXTENDED_PATITIONS 
  cache = cacheClear(); // get buffer to use. 
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part,cache, &firstLBA);
    4bde:	str	r5, [sp, #8]
    4be0:	str	r5, [sp, #4]
    4be2:	str	r5, [sp, #0]
    4be4:	add	r3, sp, #20
    4be6:	add.w	r2, r4, #544	; 0x220
    4bea:	bl	3604 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    4bee:	tst.w	r0, #251	; 0xfb
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    4bf2:	add.w	r7, r4, #528	; 0x210
    4bf6:	bne.n	4bfc <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x48>
  bitmapFind(0, 1);
  m_fatType = FAT_TYPE_EXFAT;
  return true;

 fail:
  return false;
    4bf8:	movs	r0, #0
    4bfa:	b.n	4c76 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xc2>
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part,cache, &firstLBA);
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    DBG_FAIL_MACRO;
    goto fail;    
  }
  volStart = firstLBA;
    4bfc:	ldr	r6, [sp, #20]
    4bfe:	mov	r2, r5
    4c00:	mov	r1, r6
    4c02:	mov	r0, r7
    4c04:	bl	388e <FsCache::get(unsigned long, unsigned char)>
  }
  volStart = getLe32(mp->relativeSectors);
  #endif

  cache = dataCacheGet(volStart, FsCache::CACHE_FOR_READ);
  if (!cache) {
    4c08:	mov	r5, r0
    4c0a:	cmp	r0, #0
    4c0c:	beq.n	4bf8 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  pbs = reinterpret_cast<pbs_t*>(cache);
  if (strncmp(pbs->oemName, "EXFAT", 5)) {
    4c0e:	ldr	r1, [pc, #108]	; (4c7c <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xc8>)
    4c10:	movs	r2, #5
    4c12:	adds	r0, #3
    4c14:	bl	c05c <strncmp>
    4c18:	mov	r1, r0
    4c1a:	cmp	r0, #0
    4c1c:	bne.n	4bf8 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  bpb = reinterpret_cast<BpbExFat_t*>(pbs->bpb);
  if (bpb->bytesPerSectorShift != m_bytesPerSectorShift) {
    4c1e:	ldrb.w	r3, [r5, #108]	; 0x6c
    4c22:	cmp	r3, #9
    4c24:	bne.n	4bf8 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_fatStartSector = volStart + getLe32(bpb->fatOffset);
    4c26:	ldr	r3, [r5, #80]	; 0x50
    4c28:	add	r3, r6
    4c2a:	str.w	r3, [r4, #1060]	; 0x424
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    4c2e:	ldr	r3, [r5, #84]	; 0x54
  m_fatLength = getLe32(bpb->fatLength);
    4c30:	str.w	r3, [r4, #1064]	; 0x428
  m_clusterHeapStartSector = volStart + getLe32(bpb->clusterHeapOffset);
    4c34:	ldr	r3, [r5, #88]	; 0x58
    4c36:	add	r6, r3
    4c38:	str.w	r6, [r4, #1068]	; 0x42c
    4c3c:	ldr	r3, [r5, #92]	; 0x5c
  m_clusterCount = getLe32(bpb->clusterCount);
    4c3e:	str.w	r3, [r4, #1072]	; 0x430
    4c42:	ldr	r3, [r5, #96]	; 0x60
  m_rootDirectoryCluster = getLe32(bpb->rootDirectoryCluster);
    4c44:	str.w	r3, [r4, #1076]	; 0x434
  m_sectorsPerClusterShift = bpb->sectorsPerClusterShift;
    4c48:	ldrb.w	r3, [r5, #109]	; 0x6d
    4c4c:	strb.w	r3, [r4, #1093]	; 0x445
  m_bytesPerCluster = 1UL << (m_bytesPerSectorShift + m_sectorsPerClusterShift);
    4c50:	movs	r5, #1
    4c52:	adds	r3, #9
    4c54:	lsl.w	r3, r5, r3
    4c58:	str.w	r3, [r4, #1084]	; 0x43c
  m_clusterMask = m_bytesPerCluster - 1;
    4c5c:	subs	r3, #1
    4c5e:	str.w	r3, [r4, #1080]	; 0x438
  // Set m_bitmapStart to first free cluster.
  m_bitmapStart = 0;
    4c62:	str.w	r0, [r4, #1056]	; 0x420
  bitmapFind(0, 1);
    4c66:	mov	r2, r5
    4c68:	mov	r0, r4
    4c6a:	bl	488a <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  m_fatType = FAT_TYPE_EXFAT;
    4c6e:	movs	r3, #64	; 0x40
    4c70:	strb.w	r3, [r4, #1092]	; 0x444
  return true;
    4c74:	mov	r0, r5

 fail:
  return false;
}
    4c76:	add	sp, #28
    4c78:	pop	{r4, r5, r6, r7, pc}
    4c7a:	nop
    4c7c:	.word	0x00012d7b

00004c80 <ExFatPartition::rootLength()>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::rootLength() {
    4c80:	push	{r4, lr}
    4c82:	mov	r4, r0
  uint32_t nc = chainSize(m_rootDirectoryCluster);
    4c84:	ldr.w	r1, [r0, #1076]	; 0x434
    4c88:	bl	4a4a <ExFatPartition::chainSize(unsigned long)>
  return nc << bytesPerClusterShift();
    4c8c:	ldrb.w	r3, [r4, #1093]	; 0x445
    4c90:	adds	r3, #9
    4c92:	uxtb	r3, r3
}
    4c94:	lsls	r0, r3
    4c96:	pop	{r4, pc}

00004c98 <ExFatVolume::chdir(char const*)>:
#define DBG_FILE "ExFatVolume.cpp"
#include "../common/DebugMacros.h"
#include "ExFatVolume.h"
ExFatVolume* ExFatVolume::m_cwv = nullptr;
//-----------------------------------------------------------------------------
bool ExFatVolume::chdir(const char* path) {
    4c98:	push	{r4, r5, r6, lr}
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend ExFatFile;
  static ExFatVolume* cwv() {return m_cwv;}
  ExFatFile* vwd() {return &m_vwd;}
    4c9a:	add.w	r4, r0, #1096	; 0x448
    4c9e:	sub	sp, #56	; 0x38
    4ca0:	movs	r3, #0
  ExFatFile dir;
  if (!dir.open(vwd(), path, O_RDONLY)) {
    4ca2:	mov	r2, r1
    4ca4:	mov	r0, sp
    4ca6:	mov	r1, r4
    4ca8:	strb.w	r3, [sp, #49]	; 0x31
    4cac:	strb.w	r3, [sp, #50]	; 0x32
    4cb0:	strb.w	r3, [sp, #51]	; 0x33
    4cb4:	bl	4794 <ExFatFile::open(ExFatFile*, char const*, int)>
    4cb8:	mov	r5, r0
    4cba:	cbz	r0, 4ce6 <ExFatVolume::chdir(char const*)+0x4e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!dir.isDir()) {
    4cbc:	ldrb.w	r3, [sp, #49]	; 0x31
    4cc0:	ands.w	r3, r3, #80	; 0x50
    4cc4:	beq.n	4ce4 <ExFatVolume::chdir(char const*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_vwd = dir;
    4cc6:	mov	r2, sp
    4cc8:	mov	r3, r4
    4cca:	add	r6, sp, #48	; 0x30
    4ccc:	mov	r4, r2
    4cce:	ldmia	r4!, {r0, r1}
    4cd0:	cmp	r4, r6
    4cd2:	str	r0, [r3, #0]
    4cd4:	str	r1, [r3, #4]
    4cd6:	mov	r2, r4
    4cd8:	add.w	r3, r3, #8
    4cdc:	bne.n	4ccc <ExFatVolume::chdir(char const*)+0x34>
    4cde:	ldr	r0, [r4, #0]
    4ce0:	str	r0, [r3, #0]
  return true;
    4ce2:	b.n	4ce6 <ExFatVolume::chdir(char const*)+0x4e>

 fail:
  return false;
    4ce4:	mov	r5, r3
}
    4ce6:	mov	r0, r5
    4ce8:	add	sp, #56	; 0x38
    4cea:	pop	{r4, r5, r6, pc}

00004cec <exFatDirChecksum(unsigned char const*, unsigned short)>:
  return false;
}
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
    4cec:	push	{r4, lr}
  bool skip = data[0] == EXFAT_TYPE_FILE;
    4cee:	ldrb	r4, [r0, #0]
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    4cf0:	movs	r3, #0
    4cf2:	lsls	r2, r1, #15
    4cf4:	orr.w	r1, r2, r1, lsr #1
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    4cf8:	ldrb	r2, [r0, r3]
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    4cfa:	cmp	r3, #1
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    4cfc:	uxtah	r1, r2, r1
    4d00:	uxth	r1, r1
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    4d02:	bne.n	4d0e <exFatDirChecksum(unsigned char const*, unsigned short)+0x22>
    4d04:	cmp	r4, #133	; 0x85
    4d06:	ite	ne
    4d08:	movne	r2, #1
    4d0a:	moveq	r2, #3
    4d0c:	b.n	4d10 <exFatDirChecksum(unsigned char const*, unsigned short)+0x24>
    4d0e:	movs	r2, #1
    4d10:	add	r3, r2
    4d12:	cmp	r3, #31
    4d14:	bls.n	4cf2 <exFatDirChecksum(unsigned char const*, unsigned short)+0x6>
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
  }
  return checksum;
}
    4d16:	mov	r0, r1
    4d18:	pop	{r4, pc}

00004d1a <ExFatPartition::cacheSync()>:
#if USE_EXFAT_BITMAP_CACHE
    m_bitmapCache.init(dev);
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
    4d1a:	push	{r4, lr}
    4d1c:	mov	r4, r0
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    4d1e:	bl	3842 <FsCache::sync()>
    4d22:	cbz	r0, 4d3c <ExFatPartition::cacheSync()+0x22>
    4d24:	add.w	r0, r4, #528	; 0x210
    4d28:	bl	3842 <FsCache::sync()>
    4d2c:	cbz	r0, 4d3c <ExFatPartition::cacheSync()+0x22>
    4d2e:	ldr.w	r0, [r4, #1088]	; 0x440
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    4d32:	ldr	r3, [r0, #0]
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
#else  // USE_EXFAT_BITMAP_CACHE
    return m_dataCache.sync() && syncDevice();
#endif  // USE_EXFAT_BITMAP_CACHE
  }
    4d34:	ldmia.w	sp!, {r4, lr}
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    4d38:	ldr	r3, [r3, #28]
    4d3a:	bx	r3
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
#else  // USE_EXFAT_BITMAP_CACHE
    return m_dataCache.sync() && syncDevice();
#endif  // USE_EXFAT_BITMAP_CACHE
  }
    4d3c:	movs	r0, #0
    4d3e:	pop	{r4, pc}

00004d40 <ExFatFile::addCluster()>:
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
    4d40:	push	{r3, r4, r5, r6, r7, lr}
    4d42:	mov	r4, r0
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    4d44:	ldr	r0, [r0, #32]
    4d46:	ldr	r1, [r4, #24]
    4d48:	cbz	r1, 4d4c <ExFatFile::addCluster()+0xc>
    4d4a:	adds	r1, #1
    4d4c:	movs	r2, #1
    4d4e:	bl	488a <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  if (find < 2) {
    4d52:	cmp	r0, #1
  }
  return checksum;
}
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    4d54:	mov	r5, r0
  if (find < 2) {
    4d56:	bhi.n	4d5c <ExFatFile::addCluster()+0x1c>
 done:
  m_curCluster = find;
  return true;

 fail:
  return false;
    4d58:	movs	r6, #0
    4d5a:	b.n	4dce <ExFatFile::addCluster()+0x8e>
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
  if (find < 2) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    4d5c:	movs	r3, #1
    4d5e:	mov	r1, r0
    4d60:	mov	r2, r3
    4d62:	ldr	r0, [r4, #32]
    4d64:	bl	4930 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4d68:	mov	r6, r0
    4d6a:	cmp	r0, #0
    4d6c:	beq.n	4d58 <ExFatFile::addCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    4d6e:	ldr	r2, [r4, #24]
    m_flags |= FILE_FLAG_CONTIGUOUS;
    4d70:	ldrb.w	r3, [r4, #51]	; 0x33
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    4d74:	cbnz	r2, 4d80 <ExFatFile::addCluster()+0x40>
    m_flags |= FILE_FLAG_CONTIGUOUS;
    4d76:	orr.w	r3, r3, #64	; 0x40
    4d7a:	strb.w	r3, [r4, #51]	; 0x33
    goto done;
    4d7e:	b.n	4dcc <ExFatFile::addCluster()+0x8c>
  }
  if (isContiguous()) {
    4d80:	lsls	r1, r3, #25
    4d82:	bpl.n	4dac <ExFatFile::addCluster()+0x6c>
    if (find == (m_curCluster + 1)) {
    4d84:	adds	r2, #1
    4d86:	cmp	r5, r2
    4d88:	beq.n	4dcc <ExFatFile::addCluster()+0x8c>
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    4d8a:	bic.w	r3, r3, #64	; 0x40

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    4d8e:	ldr	r1, [r4, #28]
  if (isContiguous()) {
    if (find == (m_curCluster + 1)) {
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    4d90:	strb.w	r3, [r4, #51]	; 0x33

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    4d94:	ldr	r3, [r4, #24]
    4d96:	cmp	r1, r3
    4d98:	bcs.n	4dac <ExFatFile::addCluster()+0x6c>
      if (!m_vol->fatPut(c, c + 1)) {
    4d9a:	adds	r7, r1, #1
    4d9c:	mov	r2, r7
    4d9e:	ldr	r0, [r4, #32]
    4da0:	bl	4ab8 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4da4:	cmp	r0, #0
    4da6:	beq.n	4d58 <ExFatFile::addCluster()+0x18>
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    4da8:	mov	r1, r7
    4daa:	b.n	4d94 <ExFatFile::addCluster()+0x54>
        goto fail;
      }
    }
  }
  // New cluster is EOC.
  if (!m_vol->fatPut(find, EXFAT_EOC)) {
    4dac:	mov.w	r2, #4294967295
    4db0:	mov	r1, r5
    4db2:	ldr	r0, [r4, #32]
    4db4:	bl	4ab8 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4db8:	cmp	r0, #0
    4dba:	beq.n	4d58 <ExFatFile::addCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Connect new cluster to existing chain.
  if (m_curCluster) {
    4dbc:	ldr	r1, [r4, #24]
    4dbe:	cbz	r1, 4dcc <ExFatFile::addCluster()+0x8c>
    if (!m_vol->fatPut(m_curCluster, find)) {
    4dc0:	mov	r2, r5
    4dc2:	ldr	r0, [r4, #32]
    4dc4:	bl	4ab8 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4dc8:	cmp	r0, #0
    4dca:	beq.n	4d58 <ExFatFile::addCluster()+0x18>
      goto fail;
    }
  }

 done:
  m_curCluster = find;
    4dcc:	str	r5, [r4, #24]
  return true;

 fail:
  return false;
}
    4dce:	mov	r0, r6
    4dd0:	pop	{r3, r4, r5, r6, r7, pc}

00004dd2 <ExFatFile::remove()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    4dd2:	push	{r4, r5, r6, lr}
    4dd4:	ldrb.w	r3, [r0, #51]	; 0x33
  uint8_t* cache;
  if (!isWritable()) {
    4dd8:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    4dda:	mov	r4, r0
  uint8_t* cache;
  if (!isWritable()) {
    4ddc:	bmi.n	4de2 <ExFatFile::remove()+0x10>

  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
    4dde:	movs	r0, #0
    4de0:	pop	{r4, r5, r6, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    4de2:	ldr	r5, [r0, #28]
    4de4:	cbnz	r5, 4dea <ExFatFile::remove()+0x18>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    4de6:	movs	r5, #0
    4de8:	b.n	4e3c <ExFatFile::remove()+0x6a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    if (isContiguous()) {
    4dea:	lsls	r3, r3, #25
    4dec:	bpl.n	4e18 <ExFatFile::remove()+0x46>
      uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    4dee:	ldr	r6, [r0, #32]
      if (!m_vol->bitmapModify(m_firstCluster, nc, 0)) {
    4df0:	ldrd	r0, r1, [r0, #8]
    4df4:	ldrb.w	r2, [r6, #1093]	; 0x445
    4df8:	adds.w	r0, r0, #4294967295
    4dfc:	add.w	r2, r2, #9
    4e00:	uxtb	r2, r2
    4e02:	adc.w	r1, r1, #4294967295
    4e06:	bl	a558 <__aeabi_llsr>
    4e0a:	movs	r3, #0
    4e0c:	adds	r2, r0, #1
    4e0e:	mov	r1, r5
    4e10:	mov	r0, r6
    4e12:	bl	4930 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4e16:	b.n	4e20 <ExFatFile::remove()+0x4e>
        DBG_FAIL_MACRO;
        goto fail;
      }
    } else {
      if (!m_vol->freeChain(m_firstCluster)) {
    4e18:	mov	r1, r5
    4e1a:	ldr	r0, [r0, #32]
    4e1c:	bl	4af2 <ExFatPartition::freeChain(unsigned long)>
    4e20:	cmp	r0, #0
    4e22:	bne.n	4de6 <ExFatFile::remove()+0x14>
    4e24:	b.n	4dde <ExFatFile::remove()+0xc>
      }
    }
  }

  for (uint8_t is = 0; is <= m_setCount; is++) {
    cache = dirCache(is, FsCache::CACHE_FOR_WRITE);
    4e26:	movs	r2, #1
    4e28:	mov	r0, r4
    4e2a:	bl	4096 <ExFatFile::dirCache(unsigned char, unsigned char)>
    4e2e:	adds	r5, #1
    if (!cache) {
    4e30:	cmp	r0, #0
    4e32:	beq.n	4dde <ExFatFile::remove()+0xc>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
    4e34:	ldrb	r3, [r0, #0]
    4e36:	and.w	r3, r3, #127	; 0x7f
    4e3a:	strb	r3, [r0, #0]
        goto fail;
      }
    }
  }

  for (uint8_t is = 0; is <= m_setCount; is++) {
    4e3c:	ldrb.w	r3, [r4, #48]	; 0x30
    4e40:	uxtb	r1, r5
    4e42:	cmp	r3, r1
    4e44:	bcs.n	4e26 <ExFatFile::remove()+0x54>
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
  }
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    4e46:	movs	r3, #0
    4e48:	strb.w	r3, [r4, #49]	; 0x31
  m_flags = 0;
    4e4c:	strb.w	r3, [r4, #51]	; 0x33

  // Write entry to device.
  return m_vol->cacheSync();
    4e50:	ldr	r0, [r4, #32]
    4e52:	bl	4d1a <ExFatPartition::cacheSync()>

 fail:
  return false;
}
    4e56:	pop	{r4, r5, r6, pc}

00004e58 <ExFatFile::rmdir()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    4e58:	push	{r4, lr}
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    4e5a:	ldrb.w	r3, [r0, #49]	; 0x31
    4e5e:	lsls	r1, r3, #27

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    4e60:	sub	sp, #32
    4e62:	mov	r4, r0
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    4e64:	bmi.n	4e6a <ExFatFile::rmdir()+0x12>
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();

 fail:
  return false;
    4e66:	movs	r0, #0
    4e68:	b.n	4ea6 <ExFatFile::rmdir()+0x4e>
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    4e6a:	movs	r2, #0
    4e6c:	movs	r3, #0
    4e6e:	bl	4374 <ExFatFile::seekSet(unsigned long long)>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    n = read(dir, 32);
    4e72:	movs	r2, #32
    4e74:	mov	r1, sp
    4e76:	mov	r0, r4
    4e78:	bl	41c4 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    4e7c:	cbz	r0, 4e8e <ExFatFile::rmdir()+0x36>
      break;
    }
    if (n != 32 || dir[0] & 0X80) {
    4e7e:	cmp	r0, #32
    4e80:	bne.n	4e66 <ExFatFile::rmdir()+0xe>
    4e82:	ldrb.w	r3, [sp]
    4e86:	lsls	r2, r3, #24
    4e88:	bmi.n	4e66 <ExFatFile::rmdir()+0xe>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (dir[0] == 0) {
    4e8a:	cmp	r3, #0
    4e8c:	bne.n	4e72 <ExFatFile::rmdir()+0x1a>
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    4e8e:	movs	r3, #8
    4e90:	strb.w	r3, [r4, #49]	; 0x31
  m_flags |= FILE_FLAG_WRITE;
    4e94:	ldrb.w	r3, [r4, #51]	; 0x33
    4e98:	orr.w	r3, r3, #2
    4e9c:	strb.w	r3, [r4, #51]	; 0x33
  return remove();
    4ea0:	mov	r0, r4
    4ea2:	bl	4dd2 <ExFatFile::remove()>

 fail:
  return false;
}
    4ea6:	add	sp, #32
    4ea8:	pop	{r4, pc}
    4eaa:	Address 0x00004eaa is out of bounds.


00004eac <ExFatFile::syncDir()>:
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    4eac:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    4eb0:	movs	r6, #0
    }
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    4eb2:	ldr.w	r8, [pc, #212]	; 4f88 <ExFatFile::syncDir()+0xdc>
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    4eb6:	mov	r5, r0
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
    4eb8:	mov	r7, r6

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    4eba:	ldrb.w	r3, [r5, #48]	; 0x30
    4ebe:	uxtb	r1, r6
    4ec0:	cmp	r3, r1
    4ec2:	bcc.n	4f5a <ExFatFile::syncDir()+0xae>
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    4ec4:	movs	r2, #0
    4ec6:	mov	r0, r5
    4ec8:	bl	4096 <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache) {
    4ecc:	mov	r4, r0
    4ece:	cmp	r0, #0
    4ed0:	beq.n	4f72 <ExFatFile::syncDir()+0xc6>
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    4ed2:	ldrb	r3, [r0, #0]
    4ed4:	cmp	r3, #192	; 0xc0
    4ed6:	beq.n	4f14 <ExFatFile::syncDir()+0x68>
    4ed8:	cmp	r3, #193	; 0xc1
    4eda:	beq.n	4f4c <ExFatFile::syncDir()+0xa0>
    4edc:	cmp	r3, #133	; 0x85
    4ede:	bne.n	4f72 <ExFatFile::syncDir()+0xc6>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    4ee0:	ldrb.w	r3, [r5, #49]	; 0x31
    4ee4:	and.w	r3, r3, #55	; 0x37
    4ee8:	strh	r3, [r0, #4]
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    4eea:	ldr.w	r3, [r8]
    4eee:	cbz	r3, 4f3e <ExFatFile::syncDir()+0x92>
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
    4ef0:	add.w	r2, sp, #3
    4ef4:	add.w	r1, sp, #6
    4ef8:	add	r0, sp, #4
    4efa:	blx	r3
          df->modifyTimeMs = ms10;
    4efc:	ldrb.w	r3, [sp, #3]
          setLe16(df->modifyTime, time);
    4f00:	ldrh.w	r2, [sp, #6]
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
          df->modifyTimeMs = ms10;
    4f04:	strb	r3, [r4, #21]
          setLe16(df->modifyTime, time);
          setLe16(df->modifyDate, date);
    4f06:	ldrh.w	r3, [sp, #4]
    4f0a:	strh	r2, [r4, #12]
    4f0c:	strh	r3, [r4, #14]
    4f0e:	strh	r2, [r4, #16]
    4f10:	strh	r3, [r4, #18]
    4f12:	b.n	4f3e <ExFatFile::syncDir()+0x92>
        m_vol->dataCacheDirty();
        break;

      case EXFAT_TYPE_STREAM:
        ds = reinterpret_cast<DirStream_t*>(cache);
        if (isContiguous()) {
    4f14:	ldrb.w	r3, [r5, #51]	; 0x33
    4f18:	tst.w	r3, #64	; 0x40
    4f1c:	ldrb	r3, [r0, #1]
          ds->flags |= EXFAT_FLAG_CONTIGUOUS;
    4f1e:	ite	ne
    4f20:	orrne.w	r3, r3, #2
        } else {
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
    4f24:	biceq.w	r3, r3, #2
    4f28:	strb	r3, [r0, #1]
        }
        setLe64(ds->validLength, m_validLength);
    4f2a:	ldrd	r2, r3, [r5, #16]

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    4f2e:	strd	r2, r3, [r0, #8]
        setLe32(ds->firstCluster, m_firstCluster);
    4f32:	ldr	r3, [r5, #28]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    4f34:	str	r3, [r0, #20]
        setLe64(ds->dataLength, m_dataLength);
    4f36:	ldrd	r2, r3, [r5, #8]
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    4f3a:	strd	r2, r3, [r0, #24]
        m_vol->dataCacheDirty();
    4f3e:	ldr	r2, [r5, #32]
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    4f40:	ldrb.w	r3, [r2, #528]	; 0x210
    4f44:	orr.w	r3, r3, #1
    4f48:	strb.w	r3, [r2, #528]	; 0x210
      default:
        DBG_FAIL_MACRO;
        goto fail;
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
    4f4c:	mov	r1, r7
    4f4e:	mov	r0, r4
    4f50:	bl	4cec <exFatDirChecksum(unsigned char const*, unsigned short)>
    4f54:	adds	r6, #1
    4f56:	mov	r7, r0
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    4f58:	b.n	4eba <ExFatFile::syncDir()+0xe>
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
  }
  df = reinterpret_cast<DirFile_t*>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
    4f5a:	movs	r2, #1
    4f5c:	add.w	r1, r5, #36	; 0x24
    4f60:	ldr	r0, [r5, #32]
    4f62:	bl	49d6 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    4f66:	cbz	r0, 4f72 <ExFatFile::syncDir()+0xc6>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    4f68:	strh	r7, [r0, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe16(df->setChecksum, checksum);
  if (!m_vol->cacheSync()) {
    4f6a:	ldr	r0, [r5, #32]
    4f6c:	bl	4d1a <ExFatPartition::cacheSync()>
    4f70:	cbnz	r0, 4f80 <ExFatFile::syncDir()+0xd4>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    4f72:	ldrb.w	r3, [r5, #50]	; 0x32
    4f76:	orr.w	r3, r3, #1
    4f7a:	strb.w	r3, [r5, #50]	; 0x32
  return false;
    4f7e:	movs	r0, #0
}
    4f80:	add	sp, #8
    4f82:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4f86:	nop
    4f88:	.word	0x2001a690

00004f8c <ExFatFile::sync()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
    4f8c:	push	{r4, lr}
  if (!isOpen()) {
    4f8e:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
    4f92:	mov	r4, r0
  if (!isOpen()) {
    4f94:	cbnz	r3, 4f9a <ExFatFile::sync()+0xe>
    return true;
    4f96:	movs	r0, #1
    4f98:	pop	{r4, pc}
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    4f9a:	ldrb.w	r3, [r0, #51]	; 0x33
    4f9e:	lsls	r2, r3, #24
    4fa0:	bpl.n	4fb2 <ExFatFile::sync()+0x26>
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    4fa2:	and.w	r3, r3, #127	; 0x7f
    4fa6:	strb.w	r3, [r0, #51]	; 0x33
  return true;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    4faa:	ldmia.w	sp!, {r4, lr}
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    return syncDir();
    4fae:	b.w	4eac <ExFatFile::syncDir()>
  }
  if (!m_vol->cacheSync()) {
    4fb2:	ldr	r0, [r0, #32]
    4fb4:	bl	4d1a <ExFatPartition::cacheSync()>
    4fb8:	cmp	r0, #0
    4fba:	bne.n	4f96 <ExFatFile::sync()+0xa>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    4fbc:	ldrb.w	r3, [r4, #50]	; 0x32
    4fc0:	orr.w	r3, r3, #1
    4fc4:	strb.w	r3, [r4, #50]	; 0x32
  return false;
}
    4fc8:	pop	{r4, pc}

00004fca <ExFatFile::addDirCluster()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    4fca:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    4fce:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    4fd2:	mov	r4, r0
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    4fd4:	lsls	r0, r3, #25
    4fd6:	bpl.n	4fe0 <ExFatFile::addDirCluster()+0x16>
    4fd8:	ldr	r0, [r4, #32]
    4fda:	bl	4c80 <ExFatPartition::rootLength()>
    4fde:	b.n	4fe2 <ExFatFile::addDirCluster()+0x18>
    4fe0:	ldr	r0, [r4, #8]
    4fe2:	ldr	r3, [r4, #32]
  uint8_t* cache;
  dl += m_vol->bytesPerCluster();
  if (dl >= 0X4000000) {
    4fe4:	ldr.w	r3, [r3, #1084]	; 0x43c
    4fe8:	add	r0, r3
    4fea:	cmp.w	r0, #67108864	; 0x4000000
    4fee:	bcs.n	50a2 <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    4ff0:	mov	r0, r4
    4ff2:	bl	4d40 <ExFatFile::addCluster()>
    4ff6:	cmp	r0, #0
    4ff8:	beq.n	50a2 <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  cache =  m_vol->cacheClear();
    4ffa:	ldr	r5, [r4, #32]
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    if (isDirty() && !sync()) {
    4ffc:	ldrb.w	r3, [r5, #528]	; 0x210
    5000:	lsls	r1, r3, #31
    5002:	bpl.n	5010 <ExFatFile::addDirCluster()+0x46>
    5004:	add.w	r0, r5, #528	; 0x210
    5008:	bl	3842 <FsCache::sync()>
    500c:	cmp	r0, #0
    500e:	beq.n	50a2 <ExFatFile::addDirCluster()+0xd8>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    5010:	mov.w	r3, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    5014:	movs	r6, #0
    m_sector = 0XFFFFFFFF;
    5016:	str.w	r3, [r5, #540]	; 0x21c
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    501a:	strb.w	r6, [r5, #528]	; 0x210
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    501e:	add.w	r5, r5, #544	; 0x220
  if (!cache) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
    5022:	mov.w	r2, #512	; 0x200
    5026:	mov	r1, r6
    5028:	mov	r0, r5
    502a:	bl	90e4 <memset>
  sector = m_vol->clusterStartSector(m_curCluster);
    502e:	ldr	r2, [r4, #32]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    5030:	ldr	r3, [r4, #24]
    5032:	ldrb.w	r1, [r2, #1093]	; 0x445
    5036:	ldr.w	r7, [r2, #1068]	; 0x42c
    503a:	subs	r3, #2
    503c:	lsls	r3, r1
    503e:	add	r7, r3
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    5040:	mov.w	r8, #1
    5044:	ldr	r3, [r4, #32]
    5046:	ldrb.w	r2, [r3, #1093]	; 0x445
    504a:	lsl.w	r2, r8, r2
    504e:	cmp	r2, r6
    5050:	bls.n	5066 <ExFatFile::addDirCluster()+0x9c>
    5052:	ldr.w	r0, [r3, #1088]	; 0x440
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    5056:	ldr	r3, [r0, #0]
    5058:	mov	r2, r5
    505a:	ldr	r3, [r3, #32]
    505c:	adds	r1, r7, r6
    505e:	blx	r3
    if (!m_vol->writeSector(sector + i, cache)) {
    5060:	cbz	r0, 50a2 <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
  sector = m_vol->clusterStartSector(m_curCluster);
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    5062:	adds	r6, #1
    5064:	b.n	5044 <ExFatFile::addDirCluster()+0x7a>
    if (!m_vol->writeSector(sector + i, cache)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  if (!isRoot()) {
    5066:	ldrb.w	r2, [r4, #49]	; 0x31
    506a:	lsls	r2, r2, #25
    506c:	bmi.n	5098 <ExFatFile::addDirCluster()+0xce>
    m_flags |= FILE_FLAG_DIR_DIRTY;
    506e:	ldrb.w	r2, [r4, #51]	; 0x33
    5072:	orn	r2, r2, #127	; 0x7f
    m_dataLength  += m_vol->bytesPerCluster();
    5076:	ldrd	r0, r1, [r4, #8]
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    507a:	strb.w	r2, [r4, #51]	; 0x33
    m_dataLength  += m_vol->bytesPerCluster();
    507e:	ldr.w	r2, [r3, #1084]	; 0x43c
    5082:	movs	r3, #0
    5084:	adds	r0, r0, r2
    5086:	adcs	r1, r3
    5088:	strd	r0, r1, [r4, #8]
    m_validLength += m_vol->bytesPerCluster();
    508c:	ldrd	r0, r1, [r4, #16]
    5090:	adds	r2, r2, r0
    5092:	adcs	r3, r1
    5094:	strd	r2, r3, [r4, #16]
  }
  return sync();
    5098:	mov	r0, r4

 fail:
  return false;
}
    509a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    m_validLength += m_vol->bytesPerCluster();
  }
  return sync();
    509e:	b.w	4f8c <ExFatFile::sync()>

 fail:
  return false;
}
    50a2:	movs	r0, #0
    50a4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000050a8 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    50a8:	push	{r4, lr}
  if (!parent->isDir()) {
    50aa:	ldrb.w	r3, [r1, #49]	; 0x31
    50ae:	tst.w	r3, #80	; 0x50

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    50b2:	mov	r4, r0
  if (!parent->isDir()) {
    50b4:	beq.n	50ec <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!openPrivate(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    50b6:	movw	r3, #2562	; 0xa02
    50ba:	bl	4444 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    50be:	cbz	r0, 50ec <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_attributes = FILE_ATTR_SUBDIR;
    50c0:	movs	r3, #16
    50c2:	strb.w	r3, [r4, #49]	; 0x31

  // allocate and zero first cluster
  if (!addDirCluster()) {
    50c6:	mov	r0, r4
    50c8:	bl	4fca <ExFatFile::addDirCluster()>
    50cc:	cbz	r0, 50ec <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    50ce:	ldr	r3, [r4, #24]
    50d0:	str	r3, [r4, #28]
    50d2:	mov	r0, r4
    50d4:	movs	r3, #0
    50d6:	movs	r2, #0
    50d8:	bl	4374 <ExFatFile::seekSet(unsigned long long)>

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    50dc:	movs	r3, #193	; 0xc1
    50de:	strb.w	r3, [r4, #51]	; 0x33
  return sync();
    50e2:	mov	r0, r4

 fail:
  return false;
}
    50e4:	ldmia.w	sp!, {r4, lr}
  m_firstCluster = m_curCluster;

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();
    50e8:	b.w	4f8c <ExFatFile::sync()>

 fail:
  return false;
}
    50ec:	movs	r0, #0
    50ee:	pop	{r4, pc}

000050f0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const char* path, bool pFlag) {
    50f0:	push	{r4, r5, r6, r7, lr}
    50f2:	sub	sp, #92	; 0x5c
    50f4:	mov	r7, r3
    50f6:	movs	r3, #0
    50f8:	strh.w	r3, [sp, #20]
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    50fc:	strb.w	r3, [sp, #81]	; 0x51
    5100:	strb.w	r3, [sp, #82]	; 0x52
    5104:	strb.w	r3, [sp, #83]	; 0x53
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    5108:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const char* path, bool pFlag) {
    510c:	str	r2, [sp, #4]
    510e:	mov	r5, r0
    5110:	mov	r4, r1
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    5112:	cmp	r3, #0
    5114:	bne.n	51a8 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    5116:	ldrb.w	r3, [r1, #49]	; 0x31
    511a:	tst.w	r3, #80	; 0x50
    511e:	beq.n	51a8 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    5120:	ldrb	r3, [r2, #0]
    5122:	cmp	r3, #47	; 0x2f
    5124:	bne.n	5142 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x52>
    while (isDirSeparator(*path)) {
    5126:	ldr	r3, [sp, #4]
    5128:	ldrb	r2, [r3, #0]
    512a:	cmp	r2, #47	; 0x2f
    512c:	bne.n	5134 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x44>
      path++;
    512e:	adds	r3, #1
    5130:	str	r3, [sp, #4]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    5132:	b.n	5126 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x36>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    5134:	ldr	r1, [r4, #32]
    5136:	add	r0, sp, #32
    5138:	bl	4122 <ExFatFile::openRoot(ExFatVolume*)>
    513c:	cmp	r0, #0
    513e:	beq.n	51a8 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    5140:	add	r4, sp, #32
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    5142:	add	r3, sp, #4
    5144:	add	r2, sp, #8
    5146:	ldr	r1, [sp, #4]
    5148:	mov	r0, r5
    514a:	bl	4148 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    514e:	cbz	r0, 51a8 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    5150:	ldr	r3, [sp, #4]
    5152:	ldrb	r3, [r3, #0]
    5154:	cbz	r3, 519c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xac>
      break;
    }
    if (!openPrivate(parent, &fname, O_RDONLY)) {
    5156:	movs	r3, #0
    5158:	add	r2, sp, #8
    515a:	mov	r1, r4
    515c:	mov	r0, r5
    515e:	bl	4444 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    5162:	cbz	r0, 518a <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x9a>
      if (!pFlag || !mkdir(parent, &fname)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    5164:	add	r2, sp, #32
    5166:	mov	r3, r5
    5168:	add.w	lr, r5, #48	; 0x30
    516c:	mov	r4, r2
    516e:	ldr	r0, [r3, #0]
    5170:	ldr	r1, [r3, #4]
    5172:	mov	r6, r2
    5174:	stmia	r6!, {r0, r1}
    5176:	adds	r3, #8
    5178:	cmp	r3, lr
    517a:	mov	r2, r6
    517c:	bne.n	516e <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x7e>
    517e:	ldr	r0, [r3, #0]
    5180:	str	r0, [r6, #0]
    parent = &tmpDir;
    close();
    5182:	mov	r0, r5
    5184:	bl	40ce <ExFatFile::close()>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    5188:	b.n	5142 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x52>
    }
    if (!*path) {
      break;
    }
    if (!openPrivate(parent, &fname, O_RDONLY)) {
      if (!pFlag || !mkdir(parent, &fname)) {
    518a:	cbz	r7, 51a8 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    518c:	add	r2, sp, #8
    518e:	mov	r1, r4
    5190:	mov	r0, r5
    5192:	bl	50a8 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    5196:	cmp	r0, #0
    5198:	bne.n	5164 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x74>
    519a:	b.n	51a8 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    519c:	add	r2, sp, #8
    519e:	mov	r1, r4
    51a0:	mov	r0, r5
    51a2:	bl	50a8 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    51a6:	b.n	51aa <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xba>

 fail:
  return false;
    51a8:	movs	r0, #0
}
    51aa:	add	sp, #92	; 0x5c
    51ac:	pop	{r4, r5, r6, r7, pc}

000051ae <ExFatFile::rename(ExFatFile*, char const*)>:
//------------------------------------------------------------------------------
bool ExFatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const char* newPath) {
    51ae:	push	{r4, r5, r6, r7, lr}
    51b0:	sub	sp, #116	; 0x74
    51b2:	movs	r3, #0
    51b4:	strb.w	r3, [sp, #49]	; 0x31
    51b8:	strb.w	r3, [sp, #50]	; 0x32
    51bc:	strb.w	r3, [sp, #51]	; 0x33
    51c0:	strb.w	r3, [sp, #105]	; 0x69
    51c4:	strb.w	r3, [sp, #106]	; 0x6a
    51c8:	strb.w	r3, [sp, #107]	; 0x6b
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    51cc:	ldrb.w	r3, [r0, #49]	; 0x31
    51d0:	tst.w	r3, #24
//------------------------------------------------------------------------------
bool ExFatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const char* newPath) {
    51d4:	mov	r4, r0
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    51d6:	bne.n	51dc <ExFatFile::rename(ExFatFile*, char const*)+0x2e>
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();

 fail:
  return false;
    51d8:	movs	r0, #0
    51da:	b.n	5250 <ExFatFile::rename(ExFatFile*, char const*)+0xa2>
  if (!(isFile() || isSubDir())) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    51dc:	ldr	r0, [r0, #32]
    51de:	ldr	r3, [r1, #32]
    51e0:	cmp	r0, r3
    51e2:	bne.n	51d8 <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    51e4:	movw	r3, #2561	; 0xa01
    51e8:	mov	r0, sp
    51ea:	bl	4794 <ExFatFile::open(ExFatFile*, char const*, int)>
    51ee:	cmp	r0, #0
    51f0:	beq.n	51d8 <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  oldFile = *this;
    51f2:	add	r2, sp, #56	; 0x38
    51f4:	mov	r3, r4
    51f6:	add.w	r7, r4, #48	; 0x30
    51fa:	mov	r6, r2
    51fc:	ldr	r0, [r3, #0]
    51fe:	ldr	r1, [r3, #4]
    5200:	mov	r5, r2
    5202:	stmia	r5!, {r0, r1}
    5204:	adds	r3, #8
    5206:	cmp	r3, r7
    5208:	mov	r2, r5
    520a:	bne.n	51fc <ExFatFile::rename(ExFatFile*, char const*)+0x4e>
    520c:	ldr	r0, [r3, #0]
    520e:	str	r0, [r5, #0]
  m_dirPos = file.m_dirPos;
    5210:	add	r2, sp, #36	; 0x24
    5212:	ldmia	r2, {r0, r1, r2}
    5214:	add.w	r3, r4, #36	; 0x24
    5218:	stmia.w	r3, {r0, r1, r2}
  m_setCount = file.m_setCount;
    521c:	ldrb.w	r3, [sp, #48]	; 0x30
    5220:	strb.w	r3, [r4, #48]	; 0x30
  m_flags |= FILE_FLAG_DIR_DIRTY;
    5224:	ldrb.w	r3, [r4, #51]	; 0x33
    5228:	orn	r3, r3, #127	; 0x7f
    522c:	strb.w	r3, [r4, #51]	; 0x33
  if (!sync()) {
    5230:	mov	r0, r4
    5232:	bl	4f8c <ExFatFile::sync()>
    5236:	cmp	r0, #0
    5238:	beq.n	51d8 <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    523a:	movs	r3, #0
    523c:	str	r3, [sp, #84]	; 0x54
  oldFile.m_flags = FILE_FLAG_WRITE;
    523e:	movs	r3, #2
    5240:	strb.w	r3, [sp, #107]	; 0x6b
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();
    5244:	mov	r0, r6
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
    5246:	movs	r3, #8
    5248:	strb.w	r3, [sp, #105]	; 0x69
  return oldFile.remove();
    524c:	bl	4dd2 <ExFatFile::remove()>

 fail:
  return false;
}
    5250:	add	sp, #116	; 0x74
    5252:	pop	{r4, r5, r6, r7, pc}

00005254 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    5254:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5258:	mov	r4, r3
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    525a:	ldrb.w	r3, [r0, #49]	; 0x31
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    525e:	ldrb.w	fp, [sp, #40]	; 0x28
    5262:	ldrb.w	sl, [sp, #44]	; 0x2c
    5266:	ldrb.w	r5, [sp, #48]	; 0x30
    526a:	ldrb.w	r9, [sp, #52]	; 0x34
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    526e:	lsls	r3, r3, #28
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    5270:	mov	r6, r0
    5272:	mov	r8, r1
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    5274:	bpl.n	52e8 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
  uint16_t date;
  uint16_t time;
  uint8_t ms10;

  if (!isFile()
      || year < 1980
    5276:	subw	r2, r2, #1980	; 0x7bc
    527a:	uxth	r7, r2
    527c:	cmp	r7, #127	; 0x7f
    527e:	bhi.n	52e8 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || year > 2107
      || month < 1
    5280:	subs	r3, r4, #1
    5282:	cmp	r3, #11
    5284:	bhi.n	52e8 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || month > 12
      || day < 1
    5286:	add.w	r3, fp, #4294967295
    528a:	cmp	r3, #30
    528c:	bhi.n	52e8 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || day > 31
      || hour > 23
    528e:	cmp.w	sl, #23
    5292:	bhi.n	52e8 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || minute > 59
    5294:	cmp	r5, #59	; 0x3b
    5296:	bhi.n	52e8 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || second > 59) {
    5298:	cmp.w	r9, #59	; 0x3b
    529c:	bhi.n	52e8 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // update directory entry
  if (!sync()) {
    529e:	bl	4f8c <ExFatFile::sync()>
    52a2:	cbz	r0, 52e8 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    52a4:	mov.w	r3, r9, asr #1
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    52a8:	orr.w	r4, fp, r4, lsl #5
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    52ac:	orr.w	r5, r3, r5, lsl #5
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    52b0:	orr.w	r4, r4, r7, lsl #9
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    52b4:	orr.w	r5, r5, sl, lsl #11
    goto fail;
  }

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;
    52b8:	tst.w	r9, #1
    52bc:	mov.w	r7, #0
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    52c0:	uxth	r4, r4
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    52c2:	uxth	r5, r5
    52c4:	ite	eq
    52c6:	moveq.w	r9, #0
    52ca:	movne.w	r9, #100	; 0x64
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
  DirFile_t* df;
  uint8_t* cache;
  uint16_t checksum = 0;
    52ce:	mov	fp, r7
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        m_vol->dataCacheDirty();
        if (flags & T_ACCESS) {
    52d0:	and.w	sl, r8, #1

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    52d4:	ldrb.w	r3, [r6, #48]	; 0x30
    52d8:	uxtb	r1, r7
    52da:	cmp	r3, r1
    52dc:	bcc.n	5348 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xf4>
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    52de:	movs	r2, #0
    52e0:	mov	r0, r6
    52e2:	bl	4096 <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache) {
    52e6:	cbnz	r0, 52ee <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x9a>
    goto fail;
  }
  return true;

 fail:
  return false;
    52e8:	movs	r0, #0
    52ea:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    52ee:	ldrb	r3, [r0, #0]
    52f0:	cmp	r3, #133	; 0x85
    52f2:	beq.n	52fe <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xaa>
    52f4:	bcc.n	52e8 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    52f6:	subs	r3, #192	; 0xc0
    52f8:	cmp	r3, #1
    52fa:	bls.n	533c <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xe8>
    52fc:	b.n	52e8 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    52fe:	ldrb.w	r3, [r6, #49]	; 0x31
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        m_vol->dataCacheDirty();
    5302:	ldr	r2, [r6, #32]
    5304:	and.w	r3, r3, #55	; 0x37
    5308:	strh	r3, [r0, #4]
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    530a:	ldrb.w	r3, [r2, #528]	; 0x210
    530e:	orr.w	r3, r3, #1
    5312:	strb.w	r3, [r2, #528]	; 0x210
        if (flags & T_ACCESS) {
    5316:	cmp.w	sl, #0
    531a:	beq.n	5320 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xcc>
    531c:	strh	r5, [r0, #16]
    531e:	strh	r4, [r0, #18]
          setLe16(df->accessTime, time);
          setLe16(df->accessDate, date);
        }
        if (flags & T_CREATE) {
    5320:	tst.w	r8, #2
          df->createTimeMs = ms10;
    5324:	ittt	ne
    5326:	strbne.w	r9, [r0, #20]
    532a:	strhne	r5, [r0, #8]
    532c:	strhne	r4, [r0, #10]
          setLe16(df->createTime, time);
          setLe16(df->createDate, date);
        }
        if (flags & T_WRITE) {
    532e:	tst.w	r8, #4
          df->modifyTimeMs = ms10;
    5332:	ittt	ne
    5334:	strbne.w	r9, [r0, #21]
    5338:	strhne	r5, [r0, #12]
    533a:	strhne	r4, [r0, #14]
      default:
        DBG_FAIL_MACRO;
        goto fail;
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
    533c:	mov	r1, fp
    533e:	bl	4cec <exFatDirChecksum(unsigned char const*, unsigned short)>
    5342:	adds	r7, #1
    5344:	mov	fp, r0

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    5346:	b.n	52d4 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x80>
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
  }
  df = reinterpret_cast<DirFile_t*>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
    5348:	movs	r2, #1
    534a:	add.w	r1, r6, #36	; 0x24
    534e:	ldr	r0, [r6, #32]
    5350:	bl	49d6 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    5354:	cmp	r0, #0
    5356:	beq.n	52e8 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    5358:	strh.w	fp, [r0, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe16(df->setChecksum, checksum);
  if (!m_vol->cacheSync()) {
    535c:	ldr	r0, [r6, #32]
    535e:	bl	4d1a <ExFatPartition::cacheSync()>
    5362:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00005366 <ExFatFile::truncate()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    5366:	push	{r0, r1, r4, r5, r6, lr}
    5368:	ldrb.w	r3, [r0, #51]	; 0x33
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    536c:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    536e:	mov	r4, r0
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    5370:	bmi.n	5376 <ExFatFile::truncate()+0x10>
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    5372:	movs	r0, #0
    5374:	b.n	5420 <ExFatFile::truncate()+0xba>
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    5376:	ldr	r5, [r0, #28]
    5378:	cmp	r5, #0
    537a:	beq.n	53fe <ExFatFile::truncate()+0x98>
      return true;
  }
  if (isContiguous()) {
    537c:	and.w	r3, r3, #64	; 0x40
    5380:	and.w	r1, r3, #255	; 0xff
    5384:	ldr	r6, [r0, #24]
    5386:	cbz	r3, 53c6 <ExFatFile::truncate()+0x60>
    5388:	ldr	r3, [r4, #32]
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    538a:	ldrd	r0, r1, [r0, #8]
    538e:	ldrb.w	r2, [r3, #1093]	; 0x445
    5392:	adds.w	r0, r0, #4294967295
    5396:	add.w	r2, r2, #9
    539a:	uxtb	r2, r2
    539c:	adc.w	r1, r1, #4294967295
    53a0:	bl	a558 <__aeabi_llsr>
    53a4:	adds	r2, r0, #1
    if (m_curCluster) {
    53a6:	cbz	r6, 53b4 <ExFatFile::truncate()+0x4e>
      toFree = m_curCluster + 1;
      nc -= 1 + m_curCluster - m_firstCluster;
    53a8:	subs	r5, #1
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    53aa:	adds	r3, r6, #1
      nc -= 1 + m_curCluster - m_firstCluster;
    53ac:	subs	r5, r5, r6
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    53ae:	str	r3, [sp, #4]
      nc -= 1 + m_curCluster - m_firstCluster;
    53b0:	add	r2, r5
    53b2:	b.n	53b8 <ExFatFile::truncate()+0x52>
    } else {
      toFree = m_firstCluster;
    53b4:	str	r5, [sp, #4]
      m_firstCluster = 0;
    53b6:	str	r6, [r4, #28]
    }
    if (nc && !m_vol->bitmapModify(toFree, nc, 0)) {
    53b8:	cbz	r2, 5402 <ExFatFile::truncate()+0x9c>
    53ba:	movs	r3, #0
    53bc:	ldr	r1, [sp, #4]
    53be:	ldr	r0, [r4, #32]
    53c0:	bl	4930 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    53c4:	b.n	53fa <ExFatFile::truncate()+0x94>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
    53c6:	cbz	r6, 53ec <ExFatFile::truncate()+0x86>
      toFree = 0;
    53c8:	add	r2, sp, #8
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    53ca:	ldr	r0, [r0, #32]
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
      toFree = 0;
    53cc:	str.w	r1, [r2, #-4]!
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    53d0:	mov	r1, r6
    53d2:	bl	4a0c <ExFatPartition::fatGet(unsigned long, unsigned long*)>
      if (fg < 0) {
    53d6:	cmp	r0, #0
    53d8:	blt.n	5372 <ExFatFile::truncate()+0xc>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (fg) {
    53da:	beq.n	53f0 <ExFatFile::truncate()+0x8a>
        // current cluster is end of chain
        if (!m_vol->fatPut(m_curCluster, EXFAT_EOC)) {
    53dc:	mov.w	r2, #4294967295
    53e0:	ldr	r1, [r4, #24]
    53e2:	ldr	r0, [r4, #32]
    53e4:	bl	4ab8 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    53e8:	cbnz	r0, 53f0 <ExFatFile::truncate()+0x8a>
    53ea:	b.n	5372 <ExFatFile::truncate()+0xc>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
    } else {
      toFree = m_firstCluster;
    53ec:	str	r5, [sp, #4]
      m_firstCluster = 0;
    53ee:	str	r6, [r0, #28]
    }
    if (toFree) {
    53f0:	ldr	r1, [sp, #4]
    53f2:	cbz	r1, 5402 <ExFatFile::truncate()+0x9c>
      if (!m_vol->freeChain(toFree)) {
    53f4:	ldr	r0, [r4, #32]
    53f6:	bl	4af2 <ExFatPartition::freeChain(unsigned long)>
    53fa:	cbnz	r0, 5402 <ExFatFile::truncate()+0x9c>
    53fc:	b.n	5372 <ExFatFile::truncate()+0xc>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    53fe:	movs	r0, #1
    5400:	b.n	5420 <ExFatFile::truncate()+0xba>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  }
  m_dataLength = m_curPosition;
    5402:	ldrd	r2, r3, [r4]
    5406:	strd	r2, r3, [r4, #8]
  m_validLength = m_curPosition;
    540a:	strd	r2, r3, [r4, #16]
  m_flags |= FILE_FLAG_DIR_DIRTY;
    540e:	ldrb.w	r3, [r4, #51]	; 0x33
    5412:	orn	r3, r3, #127	; 0x7f
    5416:	strb.w	r3, [r4, #51]	; 0x33
  return sync();
    541a:	mov	r0, r4
    541c:	bl	4f8c <ExFatFile::sync()>

 fail:
  return false;
}
    5420:	add	sp, #8
    5422:	pop	{r4, r5, r6, pc}

00005424 <ExFatFile::write(void const*, unsigned int)>:
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    5424:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5428:	ldrb.w	r3, [r0, #51]	; 0x33
    542c:	mov	r9, r1

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    542e:	lsls	r1, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    5430:	mov	r4, r0
    5432:	mov	sl, r2

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    5434:	bpl.w	55ae <ExFatFile::write(void const*, unsigned int)+0x18a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    5438:	lsls	r2, r3, #28
    543a:	bmi.n	544a <ExFatFile::write(void const*, unsigned int)+0x26>
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    543c:	add.w	r3, r4, #24

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    5440:	mov	r8, sl
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    5442:	str	r3, [sp, #0]
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    5444:	mov.w	fp, #1
    5448:	b.n	5510 <ExFatFile::write(void const*, unsigned int)+0xec>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_validLength)) {
    544a:	ldrd	r2, r3, [r0, #16]
    544e:	bl	4374 <ExFatFile::seekSet(unsigned long long)>
    5452:	cmp	r0, #0
    5454:	bne.n	543c <ExFatFile::write(void const*, unsigned int)+0x18>
    5456:	b.n	55ae <ExFatFile::write(void const*, unsigned int)+0x18a>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    clusterOffset = m_curPosition & m_vol->clusterMask();
    5458:	ldr	r0, [r4, #32]
    545a:	ldr	r6, [r4, #0]
    545c:	ldr.w	r3, [r0, #1080]	; 0x438
    5460:	ands	r6, r3
    sectorOffset = clusterOffset & m_vol->sectorMask();
    5462:	ubfx	r5, r6, #0, #9
    if (clusterOffset == 0) {
    5466:	cmp	r6, #0
    5468:	beq.n	5518 <ExFatFile::write(void const*, unsigned int)+0xf4>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    sector = m_vol->clusterStartSector(m_curCluster) +
    546a:	ldr.w	lr, [r4, #32]
             (clusterOffset >> m_vol->bytesPerSectorShift());
    546e:	ldr	r1, [r4, #24]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    5470:	ldrb.w	r2, [lr, #1093]	; 0x445
    5474:	ldr.w	r3, [lr, #1068]	; 0x42c
    5478:	subs	r1, #2
    547a:	lsls	r1, r2
    547c:	lsrs	r6, r6, #9
    547e:	add	r1, r3
    5480:	add	r1, r6

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
    5482:	cmp	r5, #0
    5484:	bne.n	5580 <ExFatFile::write(void const*, unsigned int)+0x15c>
    5486:	cmp.w	r8, #512	; 0x200
    548a:	bcs.w	55c2 <ExFatFile::write(void const*, unsigned int)+0x19e>
      // lesser of space and amount to write
      if (n > toWrite) {
        n = toWrite;
      }

      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
    548e:	ldrd	r2, r3, [r4, #16]
    5492:	ldrd	r6, r7, [r4]
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    5496:	cmp	r7, r3
    5498:	it	eq
    549a:	cmpeq	r6, r2
    549c:	ite	cc
    549e:	movcc	r2, #1
    54a0:	movcs	r2, #5
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    54a2:	add.w	r0, lr, #528	; 0x210
    54a6:	bl	388e <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      cache = m_vol->dataCacheGet(sector, cacheOption);
      if (!cache) {
    54aa:	cmp	r0, #0
    54ac:	beq.n	55ae <ExFatFile::write(void const*, unsigned int)+0x18a>
             (clusterOffset >> m_vol->bytesPerSectorShift());

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    54ae:	rsb	r6, r5, #512	; 0x200
    54b2:	cmp	r6, r8
    54b4:	it	cs
    54b6:	movcs	r6, r8
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    54b8:	add	r0, r5
    54ba:	mov	r2, r6
    54bc:	mov	r1, r9
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    54be:	add	r5, r6
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    54c0:	bl	8f3c <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    54c4:	cmp.w	r5, #512	; 0x200
    54c8:	bne.n	54d8 <ExFatFile::write(void const*, unsigned int)+0xb4>
  }
  uint32_t dataCacheSector() {return m_dataCache.sector();}
  bool dataCacheSync() {return m_dataCache.sync();}
    54ca:	ldr	r0, [r4, #32]
    54cc:	add.w	r0, r0, #528	; 0x210
    54d0:	bl	3842 <FsCache::sync()>
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeWrite(sector, src, ns)) {
    54d4:	cmp	r0, #0
    54d6:	beq.n	55ae <ExFatFile::write(void const*, unsigned int)+0x18a>
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    54d8:	ldrd	r0, r1, [r4]
    54dc:	adds	r2, r0, r6
    54de:	adc.w	r3, r1, #0
    54e2:	mov	r0, r2
    54e4:	mov	r1, r3
    54e6:	strd	r2, r3, [r4]
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    54ea:	ldrd	r2, r3, [r4, #16]
    54ee:	cmp	r3, r1
    54f0:	it	eq
    54f2:	cmpeq	r2, r0
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    src += n;
    54f4:	add	r9, r6
    toWrite -= n;
    54f6:	rsb	r8, r6, r8
    if (m_curPosition > m_validLength) {
    54fa:	bcs.n	5510 <ExFatFile::write(void const*, unsigned int)+0xec>
      m_flags |= FILE_FLAG_DIR_DIRTY;
    54fc:	ldrb.w	r3, [r4, #51]	; 0x33
    5500:	orn	r3, r3, #127	; 0x7f
    5504:	strb.w	r3, [r4, #51]	; 0x33
      m_validLength = m_curPosition;
    5508:	mov	r2, r0
    550a:	mov	r3, r1
    550c:	strd	r2, r3, [r4, #16]
    if (!seekSet(m_validLength)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    5510:	cmp.w	r8, #0
    5514:	bne.n	5458 <ExFatFile::write(void const*, unsigned int)+0x34>
    5516:	b.n	5584 <ExFatFile::write(void const*, unsigned int)+0x160>
    clusterOffset = m_curPosition & m_vol->clusterMask();
    sectorOffset = clusterOffset & m_vol->sectorMask();
    if (clusterOffset == 0) {
      // start of new cluster
      if (m_curCluster != 0) {
    5518:	ldr	r7, [r4, #24]
    551a:	cbz	r7, 556a <ExFatFile::write(void const*, unsigned int)+0x146>
        int fg;

        if (isContiguous()) {
    551c:	ldrb.w	r3, [r4, #51]	; 0x33
    5520:	lsls	r3, r3, #25
    5522:	bpl.n	555a <ExFatFile::write(void const*, unsigned int)+0x136>
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    5524:	ldrb.w	r2, [r0, #1093]	; 0x445
      // start of new cluster
      if (m_curCluster != 0) {
        int fg;

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
    5528:	ldr	r3, [r4, #28]
    552a:	str	r3, [sp, #4]
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    552c:	ldrd	r0, r1, [r4, #8]
    5530:	adds	r2, #9
    5532:	adds.w	r0, r0, #4294967295
    5536:	adc.w	r1, r1, #4294967295
    553a:	uxtb	r2, r2
    553c:	bl	a558 <__aeabi_llsr>
    5540:	ldr	r3, [sp, #4]
    5542:	add	r0, r3
    5544:	cmp	r7, r0
    5546:	bcc.n	5554 <ExFatFile::write(void const*, unsigned int)+0x130>
            goto fail;
          }
        }
        if (fg == 0) {
          // add cluster if at end of chain
          if (!addCluster()) {
    5548:	mov	r0, r4
    554a:	bl	4d40 <ExFatFile::addCluster()>
    554e:	cmp	r0, #0
    5550:	bne.n	546a <ExFatFile::write(void const*, unsigned int)+0x46>
    5552:	b.n	55ae <ExFatFile::write(void const*, unsigned int)+0x18a>

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
            m_curCluster++;
    5554:	adds	r7, #1
    5556:	str	r7, [r4, #24]
    5558:	b.n	546a <ExFatFile::write(void const*, unsigned int)+0x46>
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    555a:	ldr	r2, [sp, #0]
    555c:	mov	r1, r7
    555e:	bl	4a0c <ExFatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    5562:	cmp	r0, #0
    5564:	blt.n	55ae <ExFatFile::write(void const*, unsigned int)+0x18a>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
        if (fg == 0) {
    5566:	bne.n	546a <ExFatFile::write(void const*, unsigned int)+0x46>
    5568:	b.n	5548 <ExFatFile::write(void const*, unsigned int)+0x124>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    556a:	ldr	r3, [r4, #28]
    556c:	cbnz	r3, 557c <ExFatFile::write(void const*, unsigned int)+0x158>
          // allocate first cluster of file
          if (!addCluster()) {
    556e:	mov	r0, r4
    5570:	bl	4d40 <ExFatFile::addCluster()>
    5574:	cbz	r0, 55ae <ExFatFile::write(void const*, unsigned int)+0x18a>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    5576:	ldr	r3, [r4, #24]
    5578:	str	r3, [r4, #28]
    557a:	b.n	546a <ExFatFile::write(void const*, unsigned int)+0x46>
        } else {
          m_curCluster = m_firstCluster;
    557c:	str	r3, [r4, #24]
    557e:	b.n	546a <ExFatFile::write(void const*, unsigned int)+0x46>
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    5580:	movs	r2, #1
    5582:	b.n	54a2 <ExFatFile::write(void const*, unsigned int)+0x7e>
    if (m_curPosition > m_validLength) {
      m_flags |= FILE_FLAG_DIR_DIRTY;
      m_validLength = m_curPosition;
    }
  }
  if (m_curPosition > m_dataLength) {
    5584:	ldrd	r0, r1, [r4]
    5588:	ldrd	r2, r3, [r4, #8]
    558c:	cmp	r3, r1
    558e:	it	eq
    5590:	cmpeq	r2, r0
    5592:	bcs.n	559a <ExFatFile::write(void const*, unsigned int)+0x176>
    m_dataLength = m_curPosition;
    5594:	strd	r0, r1, [r4, #8]
    5598:	b.n	55a0 <ExFatFile::write(void const*, unsigned int)+0x17c>
    // update fileSize and insure sync will update dir entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    559a:	ldr	r3, [pc, #148]	; (5630 <ExFatFile::write(void const*, unsigned int)+0x20c>)
    559c:	ldr	r3, [r3, #0]
    559e:	cbz	r3, 55be <ExFatFile::write(void const*, unsigned int)+0x19a>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    55a0:	ldrb.w	r3, [r4, #51]	; 0x33
    55a4:	orn	r3, r3, #127	; 0x7f
    55a8:	strb.w	r3, [r4, #51]	; 0x33
    55ac:	b.n	55be <ExFatFile::write(void const*, unsigned int)+0x19a>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    55ae:	ldrb.w	r3, [r4, #50]	; 0x32
    55b2:	orr.w	r3, r3, #1
    55b6:	strb.w	r3, [r4, #50]	; 0x32
  return 0;
    55ba:	movs	r0, #0
    55bc:	b.n	562a <ExFatFile::write(void const*, unsigned int)+0x206>
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
  }
  return nbyte;
    55be:	mov	r0, sl
    55c0:	b.n	562a <ExFatFile::write(void const*, unsigned int)+0x206>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
    55c2:	cmp.w	r8, #1024	; 0x400
    55c6:	ldr.w	r7, [lr, #540]	; 0x21c
    55ca:	ldr.w	r0, [lr, #532]	; 0x214
    55ce:	bcc.n	55fa <ExFatFile::write(void const*, unsigned int)+0x1d6>
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
      // Limit writes to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    55d0:	lsl.w	r3, fp, r2
    55d4:	subs	r6, r3, r6
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
    55d6:	mov.w	ip, r8, lsr #9
    55da:	cmp	ip, r6
    55dc:	mov	r3, ip
    55de:	it	cs
    55e0:	movcs	r3, r6
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    55e2:	cmp	r1, r7
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    55e4:	mov.w	r6, r3, lsl #9
    55e8:	bhi.n	55f0 <ExFatFile::write(void const*, unsigned int)+0x1cc>
    55ea:	adds	r2, r1, r3
    55ec:	cmp	r7, r2
    55ee:	bcc.n	561c <ExFatFile::write(void const*, unsigned int)+0x1f8>
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    55f0:	ldr	r2, [r0, #0]
    55f2:	ldr	r5, [r2, #36]	; 0x24
    55f4:	mov	r2, r9
    55f6:	blx	r5
    55f8:	b.n	54d4 <ExFatFile::write(void const*, unsigned int)+0xb0>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    55fa:	cmp	r1, r7
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    55fc:	ittt	eq
    55fe:	strbeq.w	r5, [lr, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    5602:	moveq.w	r3, #4294967295
    5606:	streq.w	r3, [lr, #540]	; 0x21c
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    560a:	ldr	r3, [r0, #0]
    560c:	mov	r2, r9
    560e:	ldr	r3, [r3, #32]
    5610:	blx	r3
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    5612:	cmp	r0, #0
    5614:	beq.n	55ae <ExFatFile::write(void const*, unsigned int)+0x18a>
         DBG_FAIL_MACRO;
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
    5616:	mov.w	r6, #512	; 0x200
    561a:	b.n	54d8 <ExFatFile::write(void const*, unsigned int)+0xb4>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    561c:	mov.w	r2, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    5620:	strb.w	r5, [lr, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    5624:	str.w	r2, [lr, #540]	; 0x21c
    5628:	b.n	55f0 <ExFatFile::write(void const*, unsigned int)+0x1cc>

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
  return 0;
}
    562a:	add	sp, #12
    562c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5630:	.word	0x2001a690

00005634 <initFatDirCallback(unsigned long, void*)>:
  uint16_t count;
  uint16_t dotcount;
};
static const uint8_t * initFatDirCallback(uint32_t sector, void *context) {
  struct initFatDirState * state = (struct initFatDirState *)context;
  if (state->pr && ++state->count >= state->dotcount) {
    5634:	ldr	r0, [r1, #4]
  uint8_t * buffer;
  print_t * pr;
  uint16_t count;
  uint16_t dotcount;
};
static const uint8_t * initFatDirCallback(uint32_t sector, void *context) {
    5636:	push	{r4, lr}
    5638:	mov	r4, r1
  struct initFatDirState * state = (struct initFatDirState *)context;
  if (state->pr && ++state->count >= state->dotcount) {
    563a:	cbz	r0, 5654 <initFatDirCallback(unsigned long, void*)+0x20>
    563c:	ldrh	r3, [r1, #8]
    563e:	ldrh	r2, [r1, #10]
    5640:	adds	r3, #1
    5642:	uxth	r3, r3
    5644:	cmp	r2, r3
    5646:	strh	r3, [r1, #8]
    5648:	bhi.n	5654 <initFatDirCallback(unsigned long, void*)+0x20>
    state->pr->write(".");
    564a:	ldr	r1, [pc, #12]	; (5658 <initFatDirCallback(unsigned long, void*)+0x24>)
    564c:	bl	764 <Print::write(char const*)>
    state->count = 0;
    5650:	movs	r3, #0
    5652:	strh	r3, [r4, #8]
  }
  return state->buffer;
    5654:	ldr	r0, [r4, #0]
}
    5656:	pop	{r4, pc}
    5658:	.word	0x00012d35

0000565c <FatFormatter::initFatDir(unsigned char, unsigned long)>:
bool FatFormatter::initFatDir(uint8_t fatType, uint32_t sectorCount) {
    565c:	push	{r4, r5, r6, r7, lr}
    565e:	mov	r4, r0
    5660:	sub	sp, #28
    5662:	mov	r6, r1
    5664:	mov	r5, r2
  size_t n;
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    5666:	movs	r1, #0
    5668:	mov.w	r2, #512	; 0x200
    566c:	ldr	r0, [r0, #36]	; 0x24
    566e:	bl	90e4 <memset>
  writeMsg("Writing FAT ");
    5672:	ldr	r0, [r4, #32]
    5674:	cbz	r0, 567c <FatFormatter::initFatDir(unsigned char, unsigned long)+0x20>
    5676:	ldr	r1, [pc, #128]	; (56f8 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x9c>)
    5678:	bl	764 <Print::write(char const*)>
  struct initFatDirState state;
  state.buffer = m_secBuf;
    567c:	ldr	r3, [r4, #36]	; 0x24
    567e:	str	r3, [sp, #12]
  state.pr = m_pr;
    5680:	ldr	r3, [r4, #32]
    5682:	str	r3, [sp, #16]
  state.count = 0;
  state.dotcount = sectorCount/32;
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    5684:	ldr	r0, [r4, #28]
    5686:	ldr	r1, [r4, #12]
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
  writeMsg("Writing FAT ");
  struct initFatDirState state;
  state.buffer = m_secBuf;
  state.pr = m_pr;
  state.count = 0;
    5688:	movs	r3, #0
    568a:	strh.w	r3, [sp, #20]
  state.dotcount = sectorCount/32;
    568e:	lsrs	r3, r5, #5
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    5690:	add	r2, sp, #12
  writeMsg("Writing FAT ");
  struct initFatDirState state;
  state.buffer = m_secBuf;
  state.pr = m_pr;
  state.count = 0;
  state.dotcount = sectorCount/32;
    5692:	strh.w	r3, [sp, #22]
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    5696:	ldr	r3, [r0, #0]
    5698:	str	r2, [sp, #0]
    569a:	ldr	r7, [r3, #40]	; 0x28
    569c:	ldr	r3, [pc, #92]	; (56fc <FatFormatter::initFatDir(unsigned char, unsigned long)+0xa0>)
    569e:	subs	r2, r5, #1
    56a0:	adds	r1, #1
    56a2:	blx	r7
    56a4:	cbnz	r0, 56aa <FatFormatter::initFatDir(unsigned char, unsigned long)+0x4e>
     return false;
    56a6:	movs	r0, #0
    56a8:	b.n	56f2 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x96>
  }
  writeMsg("\r\n");
    56aa:	ldr	r0, [r4, #32]
    56ac:	cbz	r0, 56b4 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x58>
    56ae:	ldr	r1, [pc, #80]	; (5700 <FatFormatter::initFatDir(unsigned char, unsigned long)+0xa4>)
    56b0:	bl	764 <Print::write(char const*)>
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
    56b4:	ldr	r3, [r4, #36]	; 0x24
    56b6:	movs	r2, #248	; 0xf8
  n = fatType == 16 ? 4 : 12;
    56b8:	cmp	r6, #16
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
     return false;
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
    56ba:	strb	r2, [r3, #0]
  n = fatType == 16 ? 4 : 12;
  for (size_t i = 1; i < n; i++) {
    m_secBuf[i] = 0XFF;
    56bc:	mov.w	r0, #255	; 0xff
     return false;
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
  n = fatType == 16 ? 4 : 12;
    56c0:	ite	eq
    56c2:	moveq	r2, #4
    56c4:	movne	r2, #12
  for (size_t i = 1; i < n; i++) {
    56c6:	movs	r3, #1
    m_secBuf[i] = 0XFF;
    56c8:	ldr	r1, [r4, #36]	; 0x24
    56ca:	strb	r0, [r1, r3]
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
  n = fatType == 16 ? 4 : 12;
  for (size_t i = 1; i < n; i++) {
    56cc:	adds	r3, #1
    56ce:	cmp	r2, r3
    56d0:	bne.n	56c8 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x6c>
    m_secBuf[i] = 0XFF;
  }
  return m_dev->writeSector(m_fatStart, m_secBuf) &&
    56d2:	ldr	r0, [r4, #28]
    56d4:	ldr	r2, [r4, #36]	; 0x24
    56d6:	ldr	r3, [r0, #0]
    56d8:	ldr	r1, [r4, #12]
    56da:	ldr	r3, [r3, #32]
    56dc:	blx	r3
    56de:	cmp	r0, #0
    56e0:	beq.n	56a6 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x4a>
         m_dev->writeSector(m_fatStart + m_fatSize, m_secBuf);
    56e2:	ldr	r0, [r4, #28]
    56e4:	ldr	r5, [r4, #12]
    56e6:	ldr	r1, [r4, #8]
    56e8:	ldr	r3, [r0, #0]
    56ea:	ldr	r2, [r4, #36]	; 0x24
    56ec:	ldr	r3, [r3, #32]
    56ee:	add	r1, r5
    56f0:	blx	r3
}
    56f2:	add	sp, #28
    56f4:	pop	{r4, r5, r6, r7, pc}
    56f6:	nop
    56f8:	.word	0x00012d28
    56fc:	.word	0x00005635
    5700:	.word	0x00012da7

00005704 <FatFormatter::initPbs()>:
//------------------------------------------------------------------------------
void FatFormatter::initPbs() {
    5704:	push	{r3, r4, r5, lr}
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    5706:	ldr	r4, [r0, #36]	; 0x24
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    5708:	mov.w	r2, #512	; 0x200
    570c:	movs	r1, #0
  }
  return m_dev->writeSector(m_fatStart, m_secBuf) &&
         m_dev->writeSector(m_fatStart + m_fatSize, m_secBuf);
}
//------------------------------------------------------------------------------
void FatFormatter::initPbs() {
    570e:	mov	r5, r0
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    5710:	mov	r0, r4
    5712:	bl	90e4 <memset>
  pbs->jmpInstruction[0] = 0XEB;
    5716:	movs	r3, #235	; 0xeb
    5718:	strb	r3, [r4, #0]
  pbs->jmpInstruction[1] = 0X76;
    571a:	movs	r3, #118	; 0x76
    571c:	strb	r3, [r4, #1]
  pbs->jmpInstruction[2] = 0X90;
    571e:	mov	r3, r4
    5720:	movs	r2, #144	; 0x90
    5722:	strb.w	r2, [r3, #2]!
  for (uint8_t i = 0; i < sizeof(pbs->oemName); i++) {
    pbs->oemName[i] = ' ';
    5726:	movs	r1, #32
    5728:	add.w	r2, r4, #10
    572c:	strb.w	r1, [r3, #1]!
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
  pbs->jmpInstruction[0] = 0XEB;
  pbs->jmpInstruction[1] = 0X76;
  pbs->jmpInstruction[2] = 0X90;
  for (uint8_t i = 0; i < sizeof(pbs->oemName); i++) {
    5730:	cmp	r3, r2
    5732:	bne.n	572c <FatFormatter::initPbs()+0x28>
    5734:	mov.w	r3, #512	; 0x200
    5738:	strh.w	r3, [r4, #11]
    pbs->oemName[i] = ' ';
  }
  setLe16(pbs->bpb.bpb16.bytesPerSector, BYTES_PER_SECTOR);
  pbs->bpb.bpb16.sectorsPerCluster = m_sectorsPerCluster;
    573c:	ldrb.w	r3, [r5, #43]	; 0x2b
    5740:	strb	r3, [r4, #13]
  setLe16(pbs->bpb.bpb16.reservedSectorCount, m_reservedSectorCount);
    5742:	ldrh	r3, [r5, #40]	; 0x28
    5744:	strh	r3, [r4, #14]
  pbs->bpb.bpb16.fatCount = 2;
    5746:	movs	r3, #2
    5748:	strb	r3, [r4, #16]
  // skip rootDirEntryCount
  // skip totalSectors16
  pbs->bpb.bpb16.mediaType = 0XF8;
    574a:	movs	r3, #248	; 0xf8
    574c:	strb	r3, [r4, #21]
  // skip sectorsPerFat16
  // skip sectorsPerTrack
  // skip headCount
  setLe32(pbs->bpb.bpb16.hidddenSectors, m_relativeSectors);
    574e:	ldr	r3, [r5, #16]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    5750:	str	r3, [r4, #28]
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
    5752:	ldr	r3, [r5, #24]
    5754:	str	r3, [r4, #32]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    5756:	movw	r3, #43605	; 0xaa55
    575a:	strh.w	r3, [r4, #510]	; 0x1fe
    575e:	pop	{r3, r4, r5, pc}

00005760 <FatFormatter::writeMbr()>:
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
}
//------------------------------------------------------------------------------
bool FatFormatter::writeMbr() {
    5760:	push	{r4, r5, r6, lr}
    5762:	mov	r4, r0
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    5764:	mov.w	r2, #512	; 0x200
    5768:	movs	r1, #0
    576a:	ldr	r0, [r0, #36]	; 0x24
    576c:	bl	90e4 <memset>
  MbrSector_t* mbr = reinterpret_cast<MbrSector_t*>(m_secBuf);
    5770:	ldr	r5, [r4, #36]	; 0x24

#if USE_LBA_TO_CHS
  lbaToMbrChs(mbr->part->beginCHS, m_capacityMB, m_relativeSectors);
    5772:	ldr	r2, [r4, #16]
    5774:	ldr	r1, [r4, #0]
    5776:	addw	r0, r5, #447	; 0x1bf
    577a:	bl	37b4 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>
  lbaToMbrChs(mbr->part->endCHS, m_capacityMB,
              m_relativeSectors + m_totalSectors -1);
    577e:	ldr	r3, [r4, #24]
    5780:	ldr	r2, [r4, #16]
    5782:	ldr	r1, [r4, #0]
    5784:	add	r2, r3
    5786:	addw	r0, r5, #451	; 0x1c3
    578a:	subs	r2, #1
    578c:	bl	37b4 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
#endif  // USE_LBA_TO_CHS

  mbr->part->type = m_partType;
    5790:	ldrb.w	r3, [r4, #42]	; 0x2a
    5794:	strb.w	r3, [r5, #450]	; 0x1c2
  setLe32(mbr->part->relativeSectors, m_relativeSectors);
    5798:	ldr	r3, [r4, #16]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    579a:	str.w	r3, [r5, #454]	; 0x1c6
  setLe32(mbr->part->totalSectors, m_totalSectors);
    579e:	ldr	r3, [r4, #24]
  setLe16(mbr->signature, MBR_SIGNATURE);
  return m_dev->writeSector(0, m_secBuf);
    57a0:	ldr	r0, [r4, #28]
    57a2:	str.w	r3, [r5, #458]	; 0x1ca
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    57a6:	movw	r3, #43605	; 0xaa55
    57aa:	strh.w	r3, [r5, #510]	; 0x1fe
    57ae:	ldr	r3, [r0, #0]
    57b0:	ldr	r2, [r4, #36]	; 0x24
    57b2:	ldr	r3, [r3, #32]
    57b4:	movs	r1, #0
}
    57b6:	ldmia.w	sp!, {r4, r5, r6, lr}

  mbr->part->type = m_partType;
  setLe32(mbr->part->relativeSectors, m_relativeSectors);
  setLe32(mbr->part->totalSectors, m_totalSectors);
  setLe16(mbr->signature, MBR_SIGNATURE);
  return m_dev->writeSector(0, m_secBuf);
    57ba:	bx	r3

000057bc <FatFormatter::makeFat16()>:
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
  // skip rest of bpb
  setLe16(pbs->signature, PBR_SIGNATURE);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
    57bc:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    57be:	mov.w	r3, #256	; 0x100
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    57c2:	ldr	r5, [r0, #36]	; 0x24

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    57c4:	ldr.w	lr, [r0, #20]
    57c8:	ldrb.w	r2, [r0, #43]	; 0x2b
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    57cc:	str	r3, [r0, #4]
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
  // skip rest of bpb
  setLe16(pbs->signature, PBR_SIGNATURE);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
    57ce:	mov	r4, r0
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    57d0:	ldr	r3, [r4, #4]
    57d2:	rsb	r1, r3, lr
    57d6:	udiv	r1, r1, r2
    m_fatSize = (nc + 2 + (BYTES_PER_SECTOR/2) - 1)/(BYTES_PER_SECTOR/2);
    57da:	addw	r6, r1, #257	; 0x101
    57de:	lsrs	r6, r6, #8
    r = BU16 + 1 + 2*m_fatSize + FAT16_ROOT_SECTOR_COUNT;
    57e0:	lsls	r0, r6, #1
    57e2:	add.w	r7, r0, #161	; 0xa1
    if (m_dataStart >= r) {
    57e6:	cmp	r3, r7
    57e8:	bcc.n	5800 <FatFormatter::makeFat16()+0x44>
      m_relativeSectors = m_dataStart - r + BU16;
    57ea:	subs	r3, r3, r7
    57ec:	str	r6, [r4, #8]
    57ee:	add.w	r6, r3, #128	; 0x80
    57f2:	str	r6, [r4, #16]
      break;
    }
  }
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    57f4:	subw	r6, r1, #4085	; 0xff5
    57f8:	cmp.w	r6, #61440	; 0xf000
    57fc:	bcs.n	5806 <FatFormatter::makeFat16()+0x4a>
    57fe:	b.n	5814 <FatFormatter::makeFat16()+0x58>
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    5800:	adds	r3, #128	; 0x80
    5802:	str	r3, [r4, #4]
    5804:	b.n	57d0 <FatFormatter::makeFat16()+0x14>
      break;
    }
  }
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    5806:	ldr	r0, [r4, #32]
    5808:	cmp	r0, #0
    580a:	beq.n	58b4 <FatFormatter::makeFat16()+0xf8>
    580c:	ldr	r1, [pc, #168]	; (58b8 <FatFormatter::makeFat16()+0xfc>)
    580e:	bl	764 <Print::write(char const*)>
    5812:	b.n	58b4 <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  m_reservedSectorCount = 1;
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
    5814:	adds	r3, #129	; 0x81
    5816:	str	r3, [r4, #12]
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
    5818:	add.w	r3, r0, #33	; 0x21
    581c:	mla	r3, r1, r2, r3
  if (m_totalSectors < 65536) {
    5820:	cmp.w	r3, #65536	; 0x10000
    return false;
  }
  m_reservedSectorCount = 1;
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
    5824:	str	r3, [r4, #24]
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = 1;
    5826:	mov.w	r6, #1
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
  if (m_totalSectors < 65536) {
    m_partType = 0X04;
    582a:	ite	cc
    582c:	movcc	r3, #4
  } else {
    m_partType = 0X06;
    582e:	movcs	r3, #6
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = 1;
    5830:	strh	r6, [r4, #40]	; 0x28
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
  if (m_totalSectors < 65536) {
    m_partType = 0X04;
  } else {
    m_partType = 0X06;
    5832:	strb.w	r3, [r4, #42]	; 0x2a
  }
  // write MBR
  if (!writeMbr()) {
    5836:	mov	r0, r4
    5838:	bl	5760 <FatFormatter::writeMbr()>
    583c:	cmp	r0, #0
    583e:	beq.n	58b4 <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  initPbs();
    5840:	mov	r0, r4
    5842:	bl	5704 <FatFormatter::initPbs()>
    5846:	mov.w	r3, #512	; 0x200
    584a:	strh.w	r3, [r5, #17]
    584e:	ldr	r3, [r4, #8]
    5850:	strh	r3, [r5, #22]
  setLe16(pbs->bpb.bpb16.rootDirEntryCount, FAT16_ROOT_ENTRY_COUNT);
  setLe16(pbs->bpb.bpb16.sectorsPerFat16, m_fatSize);
  pbs->bpb.bpb16.physicalDriveNumber = 0X80;
    5852:	movs	r3, #128	; 0x80
    5854:	strb.w	r3, [r5, #36]	; 0x24
  pbs->bpb.bpb16.extSignature = EXTENDED_BOOT_SIGNATURE;
    5858:	movs	r3, #41	; 0x29
    585a:	strb.w	r3, [r5, #38]	; 0x26
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    585e:	ldr	r3, [pc, #92]	; (58bc <FatFormatter::makeFat16()+0x100>)
    5860:	str.w	r3, [r5, #39]	; 0x27
    5864:	add.w	r2, r5, #53	; 0x35
    5868:	add.w	r3, r5, #42	; 0x2a
  setLe32(pbs->bpb.bpb16.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb16.volumeLabel); i++) {
    pbs->bpb.bpb16.volumeLabel[i] = ' ';
    586c:	movs	r1, #32
    586e:	strb.w	r1, [r3, #1]!
  setLe16(pbs->bpb.bpb16.rootDirEntryCount, FAT16_ROOT_ENTRY_COUNT);
  setLe16(pbs->bpb.bpb16.sectorsPerFat16, m_fatSize);
  pbs->bpb.bpb16.physicalDriveNumber = 0X80;
  pbs->bpb.bpb16.extSignature = EXTENDED_BOOT_SIGNATURE;
  setLe32(pbs->bpb.bpb16.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb16.volumeLabel); i++) {
    5872:	cmp	r3, r2
    5874:	bne.n	586e <FatFormatter::makeFat16()+0xb2>
    pbs->bpb.bpb16.volumeLabel[i] = ' ';
  }
  pbs->bpb.bpb16.volumeType[0] = 'F';
    5876:	movs	r3, #70	; 0x46
    5878:	strb.w	r3, [r5, #54]	; 0x36
  pbs->bpb.bpb16.volumeType[1] = 'A';
    587c:	movs	r3, #65	; 0x41
    587e:	strb.w	r3, [r5, #55]	; 0x37
  pbs->bpb.bpb16.volumeType[2] = 'T';
    5882:	movs	r3, #84	; 0x54
    5884:	strb.w	r3, [r5, #56]	; 0x38
  pbs->bpb.bpb16.volumeType[3] = '1';
    5888:	movs	r3, #49	; 0x31
    588a:	strb.w	r3, [r5, #57]	; 0x39
  pbs->bpb.bpb16.volumeType[4] = '6';
    588e:	movs	r3, #54	; 0x36
    5890:	strb.w	r3, [r5, #58]	; 0x3a
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)) {
    5894:	ldr	r0, [r4, #28]
    5896:	ldr	r2, [r4, #36]	; 0x24
    5898:	ldr	r3, [r0, #0]
    589a:	ldr	r1, [r4, #16]
    589c:	ldr	r3, [r3, #32]
    589e:	blx	r3
    58a0:	cbz	r0, 58b4 <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
    58a2:	ldr	r2, [r4, #4]
    58a4:	ldr	r3, [r4, #12]
    58a6:	mov	r0, r4
    58a8:	subs	r2, r2, r3
    58aa:	movs	r1, #16
}
    58ac:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  pbs->bpb.bpb16.volumeType[3] = '1';
  pbs->bpb.bpb16.volumeType[4] = '6';
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)) {
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
    58b0:	b.w	565c <FatFormatter::initFatDir(unsigned char, unsigned long)>
}
    58b4:	movs	r0, #0
    58b6:	pop	{r3, r4, r5, r6, r7, pc}
    58b8:	.word	0x00012d81
    58bc:	.word	0x0012d687

000058c0 <FatFormatter::makeFat32()>:
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
    58c0:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
    58c2:	mov.w	r3, #8192	; 0x2000
    58c6:	str	r3, [r0, #16]
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    58c8:	mov.w	r3, #16384	; 0x4000
    58cc:	str	r3, [r0, #4]
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    58ce:	ldr	r5, [r0, #36]	; 0x24
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    58d0:	ldr	r3, [r0, #20]
    58d2:	ldrb.w	r1, [r0, #43]	; 0x2b
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
    58d6:	mov	r4, r0
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    58d8:	ldr	r2, [r4, #4]
    58da:	subs	r0, r3, r2
    58dc:	udiv	r0, r0, r1
    m_fatSize = (nc + 2 + (BYTES_PER_SECTOR/4) - 1)/(BYTES_PER_SECTOR/4);
    58e0:	add.w	r6, r0, #129	; 0x81
    58e4:	lsrs	r6, r6, #7
    r = m_relativeSectors + 9 + 2*m_fatSize;
    if (m_dataStart >= r) {
    58e6:	mov.w	lr, r6, lsl #1
    58ea:	add.w	r7, lr, #8192	; 0x2000
    58ee:	adds	r7, #9
    58f0:	cmp	r2, r7
    58f2:	bcs.n	58fc <FatFormatter::makeFat32()+0x3c>
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    58f4:	add.w	r2, r2, #8192	; 0x2000
    58f8:	str	r2, [r4, #4]
    58fa:	b.n	58d8 <FatFormatter::makeFat32()+0x18>
    if (m_dataStart >= r) {
      break;
    }
  }
  // error if too few clusters in FAT32 volume
  if (nc < 65525) {
    58fc:	movw	r3, #65524	; 0xfff4
    5900:	cmp	r0, r3
    5902:	str	r6, [r4, #8]
    5904:	bhi.n	5916 <FatFormatter::makeFat32()+0x56>
    writeMsg("Bad cluster count\r\n");
    5906:	ldr	r0, [r4, #32]
    5908:	cmp	r0, #0
    590a:	beq.w	5a4e <FatFormatter::makeFat32()+0x18e>
    590e:	ldr	r1, [pc, #324]	; (5a54 <FatFormatter::makeFat32()+0x194>)
    5910:	bl	764 <Print::write(char const*)>
    5914:	b.n	5a4e <FatFormatter::makeFat32()+0x18e>
    return false;
  }
  m_reservedSectorCount = m_dataStart - m_relativeSectors - 2*m_fatSize;
    5916:	sub.w	r3, r2, #8192	; 0x2000
    591a:	rsb	r3, lr, r3
    591e:	uxth	r3, r3
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster + m_dataStart - m_relativeSectors;
    5920:	mla	r2, r0, r1, r2
  // error if too few clusters in FAT32 volume
  if (nc < 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = m_dataStart - m_relativeSectors - 2*m_fatSize;
    5924:	strh	r3, [r4, #40]	; 0x28
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
    5926:	add.w	r3, r3, #8192	; 0x2000
    592a:	str	r3, [r4, #12]
  m_totalSectors = nc*m_sectorsPerCluster + m_dataStart - m_relativeSectors;
    592c:	sub.w	r3, r2, #8192	; 0x2000
    5930:	str	r3, [r4, #24]
  // type depends on address of end sector
  // max CHS has lba = 16450560 = 1024*255*63
  if ((m_relativeSectors + m_totalSectors) <= 16450560) {
    5932:	ldr	r3, [pc, #292]	; (5a58 <FatFormatter::makeFat32()+0x198>)
    5934:	cmp	r2, r3
    // FAT32 with CHS and LBA
    m_partType = 0X0B;
    5936:	ite	ls
    5938:	movls	r3, #11
  } else {
    // FAT32 with only LBA
    m_partType = 0X0C;
    593a:	movhi	r3, #12
    593c:	strb.w	r3, [r4, #42]	; 0x2a
  }
  if (!writeMbr()) {
    5940:	mov	r0, r4
    5942:	bl	5760 <FatFormatter::writeMbr()>
    5946:	cmp	r0, #0
    5948:	beq.w	5a4e <FatFormatter::makeFat32()+0x18e>
    return false;
  }
  initPbs();
    594c:	mov	r0, r4
    594e:	bl	5704 <FatFormatter::initPbs()>
  setLe32(pbs->bpb.bpb32.sectorsPerFat32, m_fatSize);
    5952:	ldr	r3, [r4, #8]
    5954:	str	r3, [r5, #36]	; 0x24
    5956:	movs	r3, #2
    5958:	str	r3, [r5, #44]	; 0x2c
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    595a:	movs	r3, #1
    595c:	strh	r3, [r5, #48]	; 0x30
    595e:	movs	r3, #6
    5960:	strh	r3, [r5, #50]	; 0x32
  setLe32(pbs->bpb.bpb32.fat32RootCluster, 2);
  setLe16(pbs->bpb.bpb32.fat32FSInfoSector, 1);
  setLe16(pbs->bpb.bpb32.fat32BackBootSector, 6);
  pbs->bpb.bpb32.physicalDriveNumber = 0X80;
    5962:	movs	r3, #128	; 0x80
    5964:	strb.w	r3, [r5, #64]	; 0x40
  pbs->bpb.bpb32.extSignature = EXTENDED_BOOT_SIGNATURE;
    5968:	movs	r3, #41	; 0x29
    596a:	strb.w	r3, [r5, #66]	; 0x42
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    596e:	ldr	r3, [pc, #236]	; (5a5c <FatFormatter::makeFat32()+0x19c>)
    5970:	str.w	r3, [r5, #67]	; 0x43
    5974:	add.w	r2, r5, #81	; 0x51
    5978:	add.w	r3, r5, #70	; 0x46
  setLe32(pbs->bpb.bpb32.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb32.volumeLabel); i++) {
    pbs->bpb.bpb32.volumeLabel[i] = ' ';
    597c:	movs	r1, #32
    597e:	strb.w	r1, [r3, #1]!
  setLe16(pbs->bpb.bpb32.fat32FSInfoSector, 1);
  setLe16(pbs->bpb.bpb32.fat32BackBootSector, 6);
  pbs->bpb.bpb32.physicalDriveNumber = 0X80;
  pbs->bpb.bpb32.extSignature = EXTENDED_BOOT_SIGNATURE;
  setLe32(pbs->bpb.bpb32.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb32.volumeLabel); i++) {
    5982:	cmp	r3, r2
    5984:	bne.n	597e <FatFormatter::makeFat32()+0xbe>
    pbs->bpb.bpb32.volumeLabel[i] = ' ';
  }
  pbs->bpb.bpb32.volumeType[0] = 'F';
    5986:	movs	r3, #70	; 0x46
    5988:	strb.w	r3, [r5, #82]	; 0x52
  pbs->bpb.bpb32.volumeType[1] = 'A';
    598c:	movs	r3, #65	; 0x41
    598e:	strb.w	r3, [r5, #83]	; 0x53
  pbs->bpb.bpb32.volumeType[2] = 'T';
    5992:	movs	r3, #84	; 0x54
    5994:	strb.w	r3, [r5, #84]	; 0x54
  pbs->bpb.bpb32.volumeType[3] = '3';
    5998:	movs	r3, #51	; 0x33
    599a:	strb.w	r3, [r5, #85]	; 0x55
  pbs->bpb.bpb32.volumeType[4] = '2';
    599e:	movs	r3, #50	; 0x32
    59a0:	strb.w	r3, [r5, #86]	; 0x56
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)  ||
    59a4:	ldr	r0, [r4, #28]
    59a6:	ldr	r2, [r4, #36]	; 0x24
    59a8:	ldr	r3, [r0, #0]
    59aa:	ldr	r1, [r4, #16]
    59ac:	ldr	r3, [r3, #32]
    59ae:	blx	r3
    59b0:	cmp	r0, #0
    59b2:	beq.n	5a4e <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 6, m_secBuf)) {
    59b4:	ldr	r0, [r4, #28]
    59b6:	ldr	r1, [r4, #16]
    59b8:	ldr	r3, [r0, #0]
    59ba:	ldr	r2, [r4, #36]	; 0x24
    59bc:	ldr	r3, [r3, #32]
    59be:	adds	r1, #6
    59c0:	blx	r3
  pbs->bpb.bpb32.volumeType[0] = 'F';
  pbs->bpb.bpb32.volumeType[1] = 'A';
  pbs->bpb.bpb32.volumeType[2] = 'T';
  pbs->bpb.bpb32.volumeType[3] = '3';
  pbs->bpb.bpb32.volumeType[4] = '2';
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)  ||
    59c2:	cmp	r0, #0
    59c4:	beq.n	5a4e <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 6, m_secBuf)) {
    return false;
  }
  // write extra boot area and backup
  memset(m_secBuf, 0 , BYTES_PER_SECTOR);
    59c6:	mov.w	r2, #512	; 0x200
    59ca:	movs	r1, #0
    59cc:	ldr	r0, [r4, #36]	; 0x24
    59ce:	bl	90e4 <memset>
    59d2:	ldr	r3, [pc, #140]	; (5a60 <FatFormatter::makeFat32()+0x1a0>)
  setLe32(fsi->trailSignature, FSINFO_TRAIL_SIGNATURE);
  if (!m_dev->writeSector(m_relativeSectors + 2, m_secBuf)  ||
    59d4:	ldr	r0, [r4, #28]
    59d6:	str.w	r3, [r5, #508]	; 0x1fc
    59da:	ldr	r1, [r4, #16]
    59dc:	ldr	r3, [r0, #0]
    59de:	ldr	r2, [r4, #36]	; 0x24
    59e0:	ldr	r3, [r3, #32]
    59e2:	adds	r1, #2
    59e4:	blx	r3
    59e6:	cmp	r0, #0
    59e8:	beq.n	5a4e <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 8, m_secBuf)) {
    59ea:	ldr	r0, [r4, #28]
    59ec:	ldr	r1, [r4, #16]
    59ee:	ldr	r3, [r0, #0]
    59f0:	ldr	r2, [r4, #36]	; 0x24
    59f2:	ldr	r3, [r3, #32]
    59f4:	adds	r1, #8
    59f6:	blx	r3
    return false;
  }
  // write extra boot area and backup
  memset(m_secBuf, 0 , BYTES_PER_SECTOR);
  setLe32(fsi->trailSignature, FSINFO_TRAIL_SIGNATURE);
  if (!m_dev->writeSector(m_relativeSectors + 2, m_secBuf)  ||
    59f8:	cbz	r0, 5a4e <FatFormatter::makeFat32()+0x18e>
    59fa:	ldr	r3, [pc, #104]	; (5a64 <FatFormatter::makeFat32()+0x1a4>)
    59fc:	str	r3, [r5, #0]
    59fe:	add.w	r3, r3, #534773760	; 0x1fe00000
    5a02:	add.w	r3, r3, #8192	; 0x2000
    5a06:	adds	r3, #32
    5a08:	str.w	r3, [r5, #484]	; 0x1e4
  // write FSINFO sector and backup
  setLe32(fsi->leadSignature, FSINFO_LEAD_SIGNATURE);
  setLe32(fsi->structSignature, FSINFO_STRUCT_SIGNATURE);
  setLe32(fsi->freeCount, 0XFFFFFFFF);
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
    5a0c:	ldr	r0, [r4, #28]
    5a0e:	ldr	r2, [r4, #36]	; 0x24
    5a10:	mov.w	r3, #4294967295
    5a14:	str.w	r3, [r5, #488]	; 0x1e8
    5a18:	str.w	r3, [r5, #492]	; 0x1ec
    5a1c:	ldr	r1, [r4, #16]
    5a1e:	ldr	r3, [r0, #0]
    5a20:	adds	r1, #1
    5a22:	ldr	r3, [r3, #32]
    5a24:	blx	r3
    5a26:	cbz	r0, 5a4e <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    5a28:	ldr	r0, [r4, #28]
    5a2a:	ldr	r1, [r4, #16]
    5a2c:	ldr	r3, [r0, #0]
    5a2e:	ldr	r2, [r4, #36]	; 0x24
    5a30:	ldr	r3, [r3, #32]
    5a32:	adds	r1, #7
    5a34:	blx	r3
  // write FSINFO sector and backup
  setLe32(fsi->leadSignature, FSINFO_LEAD_SIGNATURE);
  setLe32(fsi->structSignature, FSINFO_STRUCT_SIGNATURE);
  setLe32(fsi->freeCount, 0XFFFFFFFF);
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
    5a36:	cbz	r0, 5a4e <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
    5a38:	ldr	r2, [r4, #8]
    5a3a:	ldrb.w	r3, [r4, #43]	; 0x2b
    5a3e:	mov	r0, r4
    5a40:	add.w	r2, r3, r2, lsl #1
    5a44:	movs	r1, #32
}
    5a46:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
    5a4a:	b.w	565c <FatFormatter::initFatDir(unsigned char, unsigned long)>
}
    5a4e:	movs	r0, #0
    5a50:	pop	{r3, r4, r5, r6, r7, pc}
    5a52:	nop
    5a54:	.word	0x00012d81
    5a58:	.word	0x00fb0400
    5a5c:	.word	0x0012d687
    5a60:	.word	0xaa550000
    5a64:	.word	0x41615252

00005a68 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>:
#define writeMsg(str) if (m_pr) m_pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    5a68:	push	{r3, r4, r5, lr}
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
    5a6a:	str	r3, [r0, #32]
  m_sectorCount = m_dev->sectorCount();
    5a6c:	ldr	r3, [r1, #0]
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
  bool rtn;
  m_dev = dev;
    5a6e:	str	r1, [r0, #28]
  m_secBuf = secBuf;
    5a70:	str	r2, [r0, #36]	; 0x24
#define writeMsg(str) if (m_pr) m_pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    5a72:	mov	r4, r0
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
  m_sectorCount = m_dev->sectorCount();
    5a74:	ldr	r3, [r3, #24]
    5a76:	mov	r0, r1
    5a78:	blx	r3
  m_capacityMB = (m_sectorCount + SECTORS_PER_MB - 1)/SECTORS_PER_MB;
    5a7a:	addw	r3, r0, #2047	; 0x7ff
    5a7e:	lsrs	r3, r3, #11

  if (m_capacityMB <= 6) {
    5a80:	cmp	r3, #6
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
  m_sectorCount = m_dev->sectorCount();
    5a82:	str	r0, [r4, #20]
  m_capacityMB = (m_sectorCount + SECTORS_PER_MB - 1)/SECTORS_PER_MB;
    5a84:	str	r3, [r4, #0]

  if (m_capacityMB <= 6) {
    5a86:	bhi.n	5a96 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2e>
    writeMsg("Card is too small.\r\n");
    5a88:	ldr	r0, [r4, #32]
    5a8a:	cbz	r0, 5a92 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2a>
    5a8c:	ldr	r1, [pc, #108]	; (5afc <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x94>)
    5a8e:	bl	764 <Print::write(char const*)>
    return false;
    5a92:	movs	r0, #0
    5a94:	pop	{r3, r4, r5, pc}
  } else if (m_capacityMB <= 16) {
    5a96:	cmp	r3, #16
    5a98:	bhi.n	5a9e <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x36>
    m_sectorsPerCluster = 2;
    5a9a:	movs	r3, #2
    5a9c:	b.n	5aca <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 32) {
    5a9e:	cmp	r3, #32
    5aa0:	bhi.n	5aa6 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3e>
    m_sectorsPerCluster = 4;
    5aa2:	movs	r3, #4
    5aa4:	b.n	5aca <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 64) {
    5aa6:	cmp	r3, #64	; 0x40
    5aa8:	bhi.n	5aae <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x46>
    m_sectorsPerCluster = 8;
    5aaa:	movs	r3, #8
    5aac:	b.n	5aca <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 128) {
    5aae:	cmp	r3, #128	; 0x80
    5ab0:	bhi.n	5ab6 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x4e>
    m_sectorsPerCluster = 16;
    5ab2:	movs	r3, #16
    5ab4:	b.n	5aca <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 1024) {
    5ab6:	cmp.w	r3, #1024	; 0x400
    5aba:	bhi.n	5ac0 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x58>
    m_sectorsPerCluster = 32;
    5abc:	movs	r3, #32
    5abe:	b.n	5aca <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 32768) {
    5ac0:	cmp.w	r3, #32768	; 0x8000
    m_sectorsPerCluster = 64;
    5ac4:	ite	ls
    5ac6:	movls	r3, #64	; 0x40
  } else {
    // SDXC cards
    m_sectorsPerCluster = 128;
    5ac8:	movhi	r3, #128	; 0x80
  }
  rtn = m_sectorCount < 0X400000 ? makeFat16() : makeFat32();
    5aca:	cmp.w	r0, #4194304	; 0x400000
    m_sectorsPerCluster = 32;
  } else if (m_capacityMB <= 32768) {
    m_sectorsPerCluster = 64;
  } else {
    // SDXC cards
    m_sectorsPerCluster = 128;
    5ace:	strb.w	r3, [r4, #43]	; 0x2b
  }
  rtn = m_sectorCount < 0X400000 ? makeFat16() : makeFat32();
    5ad2:	mov	r0, r4
    5ad4:	bcs.n	5adc <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x74>
    5ad6:	bl	57bc <FatFormatter::makeFat16()>
    5ada:	b.n	5ae0 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x78>
    5adc:	bl	58c0 <FatFormatter::makeFat32()>
    5ae0:	mov	r5, r0
    5ae2:	ldr	r0, [r4, #32]
  if (rtn) {
    5ae4:	cbz	r5, 5af0 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x88>
    writeMsg("Format Done\r\n");
    5ae6:	cbz	r0, 5af8 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x90>
    5ae8:	ldr	r1, [pc, #20]	; (5b00 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x98>)
    5aea:	bl	764 <Print::write(char const*)>
    5aee:	b.n	5af8 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x90>
  } else {
    writeMsg("Format Failed\r\n");
    5af0:	cmp	r0, #0
    5af2:	beq.n	5a92 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2a>
    5af4:	ldr	r1, [pc, #12]	; (5b04 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x9c>)
    5af6:	b.n	5a8e <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x26>
    5af8:	movs	r0, #1
  }
  return rtn;
}
    5afa:	pop	{r3, r4, r5, pc}
    5afc:	.word	0x00012d95
    5b00:	.word	0x00012daa
    5b04:	.word	0x00012db8

00005b08 <FatFile::cacheDir(unsigned short)>:

  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    5b08:	push	{r4, lr}
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    5b0a:	lsls	r1, r1, #5

  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    5b0c:	mov	r4, r0
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    5b0e:	bl	6006 <FatFile::seekSet(unsigned long)>
    5b12:	cbz	r0, 5b20 <FatFile::cacheDir(unsigned short)+0x18>
    5b14:	mov	r0, r4
    5b16:	movs	r1, #0
  }
    5b18:	ldmia.w	sp!, {r4, lr}
  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    5b1c:	b.w	5fcc <FatFile::readDirCache(bool)>
  }
    5b20:	pop	{r4, pc}

00005b22 <FatFile::getLfnChar(DirLfn_t*, unsigned char)>:
#include "FatFile.h"
#include "FatVolume.h"

//------------------------------------------------------------------------------
uint16_t FatFile::getLfnChar(DirLfn_t* ldir, uint8_t i) {
  if (i < 5) {
    5b22:	cmp	r2, #4
    5b24:	bhi.n	5b30 <FatFile::getLfnChar(DirLfn_t*, unsigned char)+0xe>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    5b26:	add.w	r1, r1, r2, lsl #1
    5b2a:	ldrh.w	r0, [r1, #1]
    return getLe16(ldir->unicode1 + 2*i);
    5b2e:	bx	lr
  } else if (i < 11) {
    5b30:	cmp	r2, #10
    5b32:	bhi.n	5b3c <FatFile::getLfnChar(DirLfn_t*, unsigned char)+0x1a>
    5b34:	add.w	r1, r1, r2, lsl #1
    5b38:	ldrh	r0, [r1, #4]
    return getLe16(ldir->unicode2 + 2*i - 10);
    5b3a:	bx	lr
  } else if (i < 13) {
    5b3c:	cmp	r2, #12
    5b3e:	itte	ls
    5b40:	addls.w	r1, r1, r2, lsl #1
    5b44:	ldrhls	r0, [r1, #6]
    return getLe16(ldir->unicode3 + 2*i - 22);
  }
  DBG_HALT_IF(i >= 13);
  return 0;
    5b46:	movhi	r0, #0
}
    5b48:	bx	lr

00005b4a <FatFile::getSFN(char*, unsigned int)>:
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
    5b4a:	push	{r3, r4, r5, r6, r7, lr}
    5b4c:	mov	r6, r1
    5b4e:	ldrb	r1, [r0, #0]
    5b50:	mov	r7, r2
  char c;
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
  uint8_t* ptr;
  DirFat_t* dir;
  if (!isOpen()) {
    5b52:	cbz	r1, 5bcc <FatFile::getSFN(char*, unsigned int)+0x82>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isRoot()) {
    5b54:	ands.w	r4, r1, #96	; 0x60
    5b58:	beq.n	5b6a <FatFile::getSFN(char*, unsigned int)+0x20>
    if (size < 2) {
    5b5a:	cmp	r2, #1
    5b5c:	bls.n	5bcc <FatFile::getSFN(char*, unsigned int)+0x82>
      DBG_FAIL_MACRO;
      goto fail;
    }
    name[0] = '/';
    5b5e:	movs	r3, #47	; 0x2f
    5b60:	strb	r3, [r6, #0]
    name[1] = '\0';
    5b62:	movs	r3, #0
    5b64:	strb	r3, [r6, #1]
    return 1;
    5b66:	movs	r0, #1
    5b68:	pop	{r3, r4, r5, r6, r7, pc}
  }
  // cache entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    5b6a:	mov	r1, r4
    5b6c:	bl	5db0 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    5b70:	cbz	r0, 5bcc <FatFile::getSFN(char*, unsigned int)+0x82>
    DBG_FAIL_MACRO;
    goto fail;
  }
  ptr = dir->name;
    5b72:	mov	r5, r0
    5b74:	mov	r1, r4
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
  char c;
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
    5b76:	movs	r2, #8
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
  char c;
  uint8_t j = 0;
    5b78:	mov	r3, r4
    goto fail;
  }
  ptr = dir->name;
  // format name
  for (uint8_t i = 0; i < 12; i++) {
    if (i == 8) {
    5b7a:	cmp	r1, #8
    5b7c:	ldrb	r4, [r5, #0]
    5b7e:	bne.n	5b8a <FatFile::getSFN(char*, unsigned int)+0x40>
      if (*ptr == ' ') {
    5b80:	cmp	r4, #32
    5b82:	beq.n	5bc4 <FatFile::getSFN(char*, unsigned int)+0x7a>
        break;
      }
      lcBit = FAT_CASE_LC_EXT;
    5b84:	movs	r2, #16
      c = '.';
    5b86:	movs	r4, #46	; 0x2e
    5b88:	b.n	5bac <FatFile::getSFN(char*, unsigned int)+0x62>
    } else {
      c = *ptr++;
      if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
    5b8a:	sub.w	lr, r4, #65	; 0x41
    5b8e:	cmp.w	lr, #25
        break;
      }
      lcBit = FAT_CASE_LC_EXT;
      c = '.';
    } else {
      c = *ptr++;
    5b92:	add.w	r5, r5, #1
      if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
    5b96:	bhi.n	5ba8 <FatFile::getSFN(char*, unsigned int)+0x5e>
    5b98:	ldrb.w	lr, [r0, #12]
    5b9c:	tst.w	r2, lr
    5ba0:	beq.n	5bac <FatFile::getSFN(char*, unsigned int)+0x62>
        c += 'a' - 'A';
    5ba2:	adds	r4, #32
    5ba4:	uxtb	r4, r4
    5ba6:	b.n	5bac <FatFile::getSFN(char*, unsigned int)+0x62>
      }
      if (c == ' ') {
    5ba8:	cmp	r4, #32
    5baa:	beq.n	5bbe <FatFile::getSFN(char*, unsigned int)+0x74>
        continue;
      }
    }
    if ((j + 1u) == size) {
    5bac:	add.w	lr, r3, #1
    5bb0:	cmp	r7, lr
    5bb2:	mov	ip, r3
    5bb4:	beq.n	5bc4 <FatFile::getSFN(char*, unsigned int)+0x7a>
      break;
    }
    name[j++] = c;
    5bb6:	strb.w	r4, [r6, ip]
    5bba:	uxtb.w	r3, lr
    5bbe:	adds	r1, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  ptr = dir->name;
  // format name
  for (uint8_t i = 0; i < 12; i++) {
    5bc0:	cmp	r1, #12
    5bc2:	bne.n	5b7a <FatFile::getSFN(char*, unsigned int)+0x30>
    if ((j + 1u) == size) {
      break;
    }
    name[j++] = c;
  }
  name[j] = '\0';
    5bc4:	movs	r2, #0
    5bc6:	strb	r2, [r6, r3]
  return j;
    5bc8:	mov	r0, r3
    5bca:	pop	{r3, r4, r5, r6, r7, pc}

 fail:
  name[0] = '\0';
    5bcc:	movs	r0, #0
    5bce:	strb	r0, [r6, #0]
  return 0;
}
    5bd0:	pop	{r3, r4, r5, r6, r7, pc}
    5bd2:	Address 0x00005bd2 is out of bounds.


00005bd4 <FatFile::getName8(char*, unsigned int)>:
 fail:
  name[0] = '\0';
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getName8(char* name, size_t size) {
    5bd4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5bd8:	sub	sp, #44	; 0x2c
  char* ptr;
  FatFile dir;
  DirLfn_t* ldir;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    5bda:	ldrb	r3, [r0, #0]
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    5bdc:	movs	r4, #0
 fail:
  name[0] = '\0';
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getName8(char* name, size_t size) {
    5bde:	mov	r7, r0
    5be0:	mov	r9, r1
    5be2:	mov	r8, r2
    5be4:	strb.w	r4, [sp, #4]
    5be8:	strb.w	r4, [sp, #5]
    5bec:	strb.w	r4, [sp, #6]
  char* ptr;
  FatFile dir;
  DirLfn_t* ldir;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    5bf0:	cmp	r3, #0
    5bf2:	beq.n	5cb4 <FatFile::getName8(char*, unsigned int)+0xe0>
      DBG_FAIL_MACRO;
      goto fail;
  }
  if (!isLFN()) {
    5bf4:	ldrb	r3, [r0, #3]
    5bf6:	cbnz	r3, 5bfe <FatFile::getName8(char*, unsigned int)+0x2a>
    return getSFN(name, size);
    5bf8:	bl	5b4a <FatFile::getSFN(char*, unsigned int)>
    5bfc:	b.n	5cba <FatFile::getName8(char*, unsigned int)+0xe6>
  }
  if (!dir.openCluster(this)) {
    5bfe:	mov	r1, r0
    5c00:	add	r0, sp, #4
    5c02:	bl	5dfe <FatFile::openCluster(FatFile*)>
    5c06:	cmp	r0, #0
    5c08:	beq.n	5cb4 <FatFile::getName8(char*, unsigned int)+0xe0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    5c0a:	add.w	r8, r8, #4294967295
    5c0e:	mov	r5, r9
    5c10:	movs	r6, #1
    5c12:	add	r8, r9
  }
  if (!dir.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    5c14:	ldrb	r3, [r7, #3]
    5c16:	cmp	r3, r6
    5c18:	bcc.n	5caa <FatFile::getName8(char*, unsigned int)+0xd6>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(m_dirIndex - order));
    5c1a:	ldrh	r1, [r7, #4]
    5c1c:	subs	r1, r1, r6
    5c1e:	uxth	r1, r1
    5c20:	add	r0, sp, #4
    5c22:	bl	5b08 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    5c26:	mov	fp, r0
    5c28:	cmp	r0, #0
    5c2a:	beq.n	5cb4 <FatFile::getName8(char*, unsigned int)+0xe0>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    5c2c:	ldrb	r3, [r0, #11]
    5c2e:	cmp	r3, #15
    5c30:	bne.n	5cb4 <FatFile::getName8(char*, unsigned int)+0xe0>
    5c32:	ldrb	r3, [r0, #0]
    5c34:	and.w	r3, r3, #31
    5c38:	cmp	r6, r3
    5c3a:	bne.n	5cb4 <FatFile::getName8(char*, unsigned int)+0xe0>
    5c3c:	mov	r3, r4
    5c3e:	mov.w	sl, #0
        order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t c = getLfnChar(ldir, i);
    5c42:	uxtb.w	r2, sl
    5c46:	mov	r1, fp
    5c48:	mov	r0, r7
    5c4a:	bl	5b22 <FatFile::getLfnChar(DirLfn_t*, unsigned char)>
    5c4e:	mov	r4, r0
      if (hs) {
    5c50:	cbz	r3, 5c70 <FatFile::getName8(char*, unsigned int)+0x9c>
        if (!FsUtf::isLowSurrogate(c)) {
    5c52:	add.w	r2, r0, #9216	; 0x2400
    5c56:	uxth	r2, r2
    5c58:	cmp.w	r2, #1024	; 0x400
    5c5c:	bcs.n	5cb4 <FatFile::getName8(char*, unsigned int)+0xe0>
   * \param[in] hs high surrogate.
   * \param[in] ls low surrogate.
   * \return code point.
   */
  inline uint32_t u16ToCp(uint16_t hs, uint16_t ls) {
    return 0X10000 + (((hs & 0X3FF) << 10) | (ls & 0X3FF));
    5c5e:	ldr	r0, [pc, #96]	; (5cc0 <FatFile::getName8(char*, unsigned int)+0xec>)
    5c60:	lsls	r3, r3, #10
    5c62:	ands	r0, r3
    5c64:	ubfx	r4, r4, #0, #10
    5c68:	orrs	r4, r0
    5c6a:	add.w	r0, r4, #65536	; 0x10000
    5c6e:	b.n	5c88 <FatFile::getName8(char*, unsigned int)+0xb4>
  /** Check for UTF-16 surrogate.
   * \param[in] c UTF-16 unit.
   * \return true if c is a surrogate else false.
   */
  inline bool isSurrogate(uint16_t c) {
    return 0XD800 <= c && c <= 0XDFFF;
    5c70:	add.w	r3, r0, #10240	; 0x2800
    5c74:	uxth	r3, r3
          DBG_FAIL_MACRO;
          goto fail;
        }
        cp = FsUtf::u16ToCp(hs, c);
        hs = 0;
      } else if (!FsUtf::isSurrogate(c)) {
    5c76:	cmp.w	r3, #2048	; 0x800
    5c7a:	bcc.n	5c80 <FatFile::getName8(char*, unsigned int)+0xac>
        if (c == 0) {
    5c7c:	cbnz	r0, 5c88 <FatFile::getName8(char*, unsigned int)+0xb4>
    5c7e:	b.n	5caa <FatFile::getName8(char*, unsigned int)+0xd6>
          goto done;
        }
        cp = c;
      } else if (FsUtf::isHighSurrogate(c)) {
    5c80:	cmp.w	r3, #1024	; 0x400
    5c84:	bcc.n	5c96 <FatFile::getName8(char*, unsigned int)+0xc2>
    5c86:	b.n	5cb4 <FatFile::getName8(char*, unsigned int)+0xe0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    5c88:	mov	r2, r8
    5c8a:	mov	r1, r5
    5c8c:	bl	34ec <FsUtf::cpToMb(unsigned long, char*, char*)>
      if (!ptr) {
    5c90:	cbz	r0, 5caa <FatFile::getName8(char*, unsigned int)+0xd6>
    5c92:	mov	r5, r0
    5c94:	movs	r4, #0
    5c96:	add.w	sl, sl, #1
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
        order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t i = 0; i < 13; i++) {
    5c9a:	cmp.w	sl, #13
    5c9e:	beq.n	5ca4 <FatFile::getName8(char*, unsigned int)+0xd0>
    5ca0:	mov	r3, r4
    5ca2:	b.n	5c42 <FatFile::getName8(char*, unsigned int)+0x6e>
  }
  if (!dir.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    5ca4:	adds	r6, #1
    5ca6:	uxtb	r6, r6
    5ca8:	b.n	5c14 <FatFile::getName8(char*, unsigned int)+0x40>
      }
      str = ptr;
    }
  }
 done:
  *str = '\0';
    5caa:	movs	r3, #0
    5cac:	strb	r3, [r5, #0]
  return str - name;
    5cae:	rsb	r0, r9, r5
    5cb2:	b.n	5cba <FatFile::getName8(char*, unsigned int)+0xe6>

 fail:
  *name = 0;
    5cb4:	movs	r0, #0
    5cb6:	strb.w	r0, [r9]
  return 0;
}
    5cba:	add	sp, #44	; 0x2c
    5cbc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5cc0:	.word	0x000ffc00

00005cc4 <FatFile::getName(char*, unsigned int)>:
//------------------------------------------------------------------------------
size_t FatFile::getName(char* name, size_t size) {
#if !USE_LONG_FILE_NAMES
  return getSFN(name, size);
#elif USE_UTF8_LONG_NAMES
  return getName8(name, size);
    5cc4:	b.w	5bd4 <FatFile::getName8(char*, unsigned int)>

00005cc8 <FatPartition::cacheSync()>:
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    5cc8:	push	{r4, lr}
    5cca:	mov	r4, r0
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    5ccc:	adds	r0, #40	; 0x28
    5cce:	bl	3842 <FsCache::sync()>
    5cd2:	cbz	r0, 5cea <FatPartition::cacheSync()+0x22>
    5cd4:	add.w	r0, r4, #568	; 0x238
    5cd8:	bl	3842 <FsCache::sync()>
    5cdc:	cbz	r0, 5cea <FatPartition::cacheSync()+0x22>
    5cde:	ldr	r0, [r4, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    5ce0:	ldr	r3, [r0, #0]
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
  }
    5ce2:	ldmia.w	sp!, {r4, lr}
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    5ce6:	ldr	r3, [r3, #28]
    5ce8:	bx	r3
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
  }
    5cea:	movs	r0, #0
    5cec:	pop	{r4, pc}

00005cee <FatFile::addCluster()>:
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    5cee:	mov	r2, r0
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    5cf0:	push	{r3, r4, r5, lr}
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    5cf2:	ldr.w	r5, [r2, #16]!
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    5cf6:	mov	r4, r0
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
  if (!m_vol->allocateCluster(m_curCluster, &m_curCluster)) {
    5cf8:	mov	r1, r5
    5cfa:	ldr	r0, [r0, #8]
    5cfc:	bl	6b66 <FatPartition::allocateCluster(unsigned long, unsigned long*)>
    5d00:	cbz	r0, 5d22 <FatFile::addCluster()+0x34>
    5d02:	ldrb	r3, [r4, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (cc == 0) {
    5d04:	cbnz	r5, 5d0c <FatFile::addCluster()+0x1e>
    m_flags |= FILE_FLAG_CONTIGUOUS;
    5d06:	orr.w	r3, r3, #64	; 0x40
    5d0a:	b.n	5d18 <FatFile::addCluster()+0x2a>
  } else if (m_curCluster != (cc + 1)) {
    5d0c:	ldr	r2, [r4, #16]
    5d0e:	adds	r5, #1
    5d10:	cmp	r2, r5
    5d12:	beq.n	5d1a <FatFile::addCluster()+0x2c>
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    5d14:	bic.w	r3, r3, #64	; 0x40
    5d18:	strb	r3, [r4, #2]
  }
  m_flags |= FILE_FLAG_DIR_DIRTY;
    5d1a:	ldrb	r3, [r4, #2]
    5d1c:	orn	r3, r3, #127	; 0x7f
    5d20:	strb	r3, [r4, #2]
  return false;
#else  // USE_FAT_FILE_FLAG_CONTIGUOUS
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
    5d22:	pop	{r3, r4, r5, pc}

00005d24 <FatFile::addDirCluster()>:
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first sector of cluster in the cache.
bool FatFile::addDirCluster() {
    5d24:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    5d28:	ldrb	r3, [r0, #0]
    5d2a:	and.w	r3, r3, #32
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first sector of cluster in the cache.
bool FatFile::addDirCluster() {
    5d2e:	mov	r4, r0
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    5d30:	and.w	r5, r3, #255	; 0xff
    5d34:	cbz	r3, 5d3a <FatFile::addDirCluster()+0x16>
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
  return true;

 fail:
  return false;
    5d36:	movs	r6, #0
    5d38:	b.n	5da4 <FatFile::addDirCluster()+0x80>
  if (isRootFixed()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // max folder size
  if (m_curPosition >= 512UL*4095) {
    5d3a:	ldr	r2, [r0, #20]
    5d3c:	ldr	r3, [pc, #108]	; (5dac <FatFile::addDirCluster()+0x88>)
    5d3e:	cmp	r2, r3
    5d40:	bhi.n	5d36 <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    5d42:	bl	5cee <FatFile::addCluster()>
    5d46:	mov	r6, r0
    5d48:	cmp	r0, #0
    5d4a:	beq.n	5d36 <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_vol->clusterStartSector(m_curCluster);
    5d4c:	ldr	r0, [r4, #8]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    5d4e:	ldr	r1, [r4, #16]
    5d50:	ldrb	r3, [r0, #6]
    5d52:	ldr	r7, [r0, #20]
    5d54:	subs	r1, #2
    5d56:	lsls	r1, r3
    5d58:	add	r7, r1
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    5d5a:	movs	r2, #5
    5d5c:	mov	r1, r7
    5d5e:	adds	r0, #40	; 0x28
    5d60:	bl	388e <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_RESERVE_FOR_WRITE);
  if (!pc) {
    5d64:	mov	r8, r0
    5d66:	cmp	r0, #0
    5d68:	beq.n	5d36 <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
    5d6a:	mov	r1, r5
    5d6c:	mov.w	r2, #512	; 0x200
    5d70:	bl	90e4 <memset>
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    5d74:	movs	r5, #1
    5d76:	ldr	r3, [r4, #8]
    5d78:	ldrb	r2, [r3, #4]
    5d7a:	cmp	r2, r5
    5d7c:	bls.n	5d94 <FatFile::addDirCluster()+0x70>
    5d7e:	ldr	r0, [r3, #0]
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    5d80:	ldr	r3, [r0, #0]
    5d82:	mov	r2, r8
    5d84:	ldr	r3, [r3, #32]
    5d86:	adds	r1, r5, r7
    5d88:	blx	r3
    if (!m_vol->writeSector(sector + i, pc->data)) {
    5d8a:	cmp	r0, #0
    5d8c:	beq.n	5d36 <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    5d8e:	adds	r5, #1
    5d90:	uxtb	r5, r5
    5d92:	b.n	5d76 <FatFile::addDirCluster()+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
    5d94:	ldrb	r2, [r3, #6]
    5d96:	mov.w	r3, #512	; 0x200
    5d9a:	lsls	r3, r2
    5d9c:	ldr	r2, [r4, #20]
    5d9e:	uxtah	r3, r2, r3
    5da2:	str	r3, [r4, #20]
  return true;

 fail:
  return false;
}
    5da4:	mov	r0, r6
    5da6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5daa:	nop
    5dac:	.word	0x001ffdff

00005db0 <FatFile::cacheDirEntry(unsigned char)>:
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
DirFat_t* FatFile::cacheDirEntry(uint8_t action) {
    5db0:	push	{r4, lr}
    5db2:	mov	r4, r0
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    5db4:	ldr	r0, [r0, #8]
    5db6:	mov	r2, r1
    5db8:	adds	r0, #40	; 0x28
    5dba:	ldr	r1, [r4, #24]
    5dbc:	bl	388e <FsCache::get(unsigned long, unsigned char)>
  cache_t* pc;
  pc = m_vol->cacheFetchData(m_dirSector, action);
  if (!pc) {
    5dc0:	cbz	r0, 5dcc <FatFile::cacheDirEntry(unsigned char)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return pc->dir + (m_dirIndex & 0XF);
    5dc2:	ldrh	r3, [r4, #4]
    5dc4:	and.w	r3, r3, #15
    5dc8:	add.w	r0, r0, r3, lsl #5

 fail:
  return nullptr;
}
    5dcc:	pop	{r4, pc}

00005dce <FatFile::openRoot(FatVolume*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    5dce:	push	{r4, r5, r6, lr}
  // error if file is already open
  if (isOpen()) {
    5dd0:	ldrb	r4, [r0, #0]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    5dd2:	mov	r5, r0
    5dd4:	mov	r6, r1
  // error if file is already open
  if (isOpen()) {
    5dd6:	cbnz	r4, 5dfa <FatFile::openRoot(FatVolume*)+0x2c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(FatFile));
    5dd8:	movs	r2, #36	; 0x24
    5dda:	mov	r1, r4
    5ddc:	bl	90e4 <memset>

  m_vol = vol;
    5de0:	str	r6, [r5, #8]
  switch (vol->fatType()) {
    5de2:	ldrb	r3, [r6, #7]
    5de4:	cmp	r3, #16
    5de6:	beq.n	5df0 <FatFile::openRoot(FatVolume*)+0x22>
    5de8:	cmp	r3, #32
    5dea:	bne.n	5dfa <FatFile::openRoot(FatVolume*)+0x2c>
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    5dec:	movs	r3, #64	; 0x40
    5dee:	b.n	5df2 <FatFile::openRoot(FatVolume*)+0x24>
  switch (vol->fatType()) {
#if FAT12_SUPPORT
  case 12:
#endif  // FAT12_SUPPORT
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    5df0:	movs	r3, #32
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    5df2:	movs	r0, #1
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    5df4:	strb	r3, [r5, #0]
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    5df6:	strb	r0, [r5, #2]
    5df8:	pop	{r4, r5, r6, pc}
  return true;

 fail:
  return false;
    5dfa:	movs	r0, #0
    5dfc:	pop	{r4, r5, r6, pc}

00005dfe <FatFile::openCluster(FatFile*)>:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    5dfe:	push	{r3, r4, r5, lr}
  if (file->m_dirCluster == 0) {
    5e00:	ldr	r3, [r1, #12]
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    5e02:	mov	r4, r0
    5e04:	mov	r5, r1
  if (file->m_dirCluster == 0) {
    5e06:	cbnz	r3, 5e12 <FatFile::openCluster(FatFile*)+0x14>
    return openRoot(file->m_vol);
    5e08:	ldr	r1, [r1, #8]
  m_attributes = FILE_ATTR_SUBDIR;
  m_flags = FILE_FLAG_READ;
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
    5e0a:	ldmia.w	sp!, {r3, r4, r5, lr}
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
    5e0e:	b.w	5dce <FatFile::openRoot(FatVolume*)>
  }
  memset(this, 0, sizeof(FatFile));
    5e12:	movs	r2, #36	; 0x24
    5e14:	movs	r1, #0
    5e16:	bl	90e4 <memset>
  m_attributes = FILE_ATTR_SUBDIR;
    5e1a:	movs	r3, #16
  m_flags = FILE_FLAG_READ;
    5e1c:	movs	r0, #1
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
  m_attributes = FILE_ATTR_SUBDIR;
    5e1e:	strb	r3, [r4, #0]
  m_flags = FILE_FLAG_READ;
    5e20:	strb	r0, [r4, #2]
  m_vol = file->m_vol;
    5e22:	ldr	r3, [r5, #8]
    5e24:	str	r3, [r4, #8]
  m_firstCluster = file->m_dirCluster;
    5e26:	ldr	r3, [r5, #12]
    5e28:	str	r3, [r4, #32]
  return true;
}
    5e2a:	pop	{r3, r4, r5, pc}

00005e2c <FatFile::read(void*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    5e2c:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    5e30:	ldrb	r3, [r0, #2]
    5e32:	lsls	r5, r3, #31

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    5e34:	mov	r4, r0
    5e36:	mov	r9, r1
    5e38:	mov	r6, r2
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    5e3a:	bpl.n	5f2c <FatFile::read(void*, unsigned int)+0x100>
    5e3c:	ldrb	r3, [r0, #0]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
    5e3e:	lsls	r0, r3, #28
    5e40:	bpl.n	5e4a <FatFile::read(void*, unsigned int)+0x1e>
    uint32_t tmp32 = m_fileSize - m_curPosition;
    5e42:	ldr	r3, [r4, #28]
    5e44:	ldr	r2, [r4, #20]
    5e46:	subs	r3, r3, r2
    5e48:	b.n	5e5a <FatFile::read(void*, unsigned int)+0x2e>
    if (nbyte >= tmp32) {
      nbyte = tmp32;
    }
  } else if (isRootFixed()) {
    5e4a:	lsls	r1, r3, #26
    5e4c:	bpl.n	5e60 <FatFile::read(void*, unsigned int)+0x34>
    uint16_t tmp16 = 32*m_vol->m_rootDirEntryCount - (uint16_t)m_curPosition;
    5e4e:	ldr	r3, [r4, #8]
    if (nbyte > tmp16) {
    5e50:	ldrh	r2, [r3, #8]
    5e52:	ldr	r3, [r4, #20]
    5e54:	rsb	r3, r3, r2, lsl #5
    5e58:	uxth	r3, r3
    5e5a:	cmp	r6, r3
    5e5c:	it	cs
    5e5e:	movcs	r6, r3
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
    5e60:	mov	r7, r6
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
  int8_t fg;
  uint8_t sectorOfCluster = 0;
    5e62:	mov.w	r8, #0
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    5e66:	add.w	sl, r4, #16
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    5e6a:	cmp	r7, #0
    5e6c:	beq.n	5ef2 <FatFile::read(void*, unsigned int)+0xc6>
    5e6e:	ldrb	r3, [r4, #0]
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    5e70:	ldr	r2, [r4, #20]
    5e72:	ldr	r0, [r4, #8]
    if (isRootFixed()) {
    5e74:	tst.w	r3, #32
    }
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    5e78:	ubfx	r5, r2, #0, #9
    5e7c:	mov.w	r1, r2, lsr #9
    if (isRootFixed()) {
    5e80:	beq.n	5e88 <FatFile::read(void*, unsigned int)+0x5c>
      sector = m_vol->rootDirStart()
               + (m_curPosition >> m_vol->bytesPerSectorShift());
    5e82:	ldr	r3, [r0, #32]
    5e84:	add	r1, r3
    5e86:	b.n	5ed2 <FatFile::read(void*, unsigned int)+0xa6>
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    5e88:	ldrb.w	r8, [r0, #5]
    5e8c:	and.w	r8, r1, r8
    } else {
      sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
      if (offset == 0 && sectorOfCluster == 0) {
    5e90:	cbnz	r5, 5ec2 <FatFile::read(void*, unsigned int)+0x96>
    5e92:	cmp.w	r8, #0
    5e96:	bne.n	5ec2 <FatFile::read(void*, unsigned int)+0x96>
        // start of new cluster
        if (m_curPosition == 0) {
    5e98:	cbnz	r2, 5ea4 <FatFile::read(void*, unsigned int)+0x78>
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    5e9a:	lsls	r2, r3, #25
    5e9c:	ite	mi
    5e9e:	ldrmi	r3, [r0, #32]
    5ea0:	ldrpl	r3, [r4, #32]
    5ea2:	b.n	5f3a <FatFile::read(void*, unsigned int)+0x10e>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
    5ea4:	lsls	r3, r3, #28
    5ea6:	bpl.n	5eb4 <FatFile::read(void*, unsigned int)+0x88>
    5ea8:	ldrb	r3, [r4, #2]
    5eaa:	lsls	r1, r3, #25
    5eac:	bpl.n	5eb4 <FatFile::read(void*, unsigned int)+0x88>
          m_curCluster++;
    5eae:	ldr	r3, [r4, #16]
    5eb0:	adds	r3, #1
    5eb2:	b.n	5f3a <FatFile::read(void*, unsigned int)+0x10e>
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    5eb4:	mov	r2, sl
    5eb6:	ldr	r1, [r4, #16]
    5eb8:	bl	6aa0 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    5ebc:	cmp	r0, #0
    5ebe:	blt.n	5f2c <FatFile::read(void*, unsigned int)+0x100>
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
    5ec0:	beq.n	5eea <FatFile::read(void*, unsigned int)+0xbe>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    5ec2:	ldr	r3, [r4, #8]
    5ec4:	ldr	r1, [r4, #16]
    5ec6:	ldrb	r2, [r3, #6]
    5ec8:	ldr	r3, [r3, #20]
    5eca:	subs	r1, #2
    5ecc:	lsls	r1, r2
    5ece:	add	r1, r3
    5ed0:	add	r1, r8
    5ed2:	ldr.w	fp, [r4, #8]
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
    5ed6:	cmp	r5, #0
    5ed8:	bne.n	5f7a <FatFile::read(void*, unsigned int)+0x14e>
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
    5eda:	cmp.w	r7, #512	; 0x200
    5ede:	bcc.n	5f7a <FatFile::read(void*, unsigned int)+0x14e>
    5ee0:	ldr.w	r3, [fp, #52]	; 0x34
        || sector == m_vol->cacheSectorNumber()) {
    5ee4:	cmp	r1, r3
    5ee6:	bne.n	5ef6 <FatFile::read(void*, unsigned int)+0xca>
    5ee8:	b.n	5f7a <FatFile::read(void*, unsigned int)+0x14e>
          if (fg < 0) {
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
            if (isDir()) {
    5eea:	ldrb	r3, [r4, #0]
    5eec:	tst.w	r3, #112	; 0x70
    5ef0:	beq.n	5f2c <FatFile::read(void*, unsigned int)+0x100>
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return nbyte - toRead;
    5ef2:	subs	r0, r6, r7
    5ef4:	b.n	5f9e <FatFile::read(void*, unsigned int)+0x172>
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    5ef6:	cmp.w	r7, #1024	; 0x400
    5efa:	bcc.n	5f58 <FatFile::read(void*, unsigned int)+0x12c>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      if (!isRootFixed()) {
    5efc:	ldrb	r2, [r4, #0]
    5efe:	lsls	r2, r2, #26
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    5f00:	mov.w	r5, r7, lsr #9
      if (!isRootFixed()) {
    5f04:	bmi.n	5f14 <FatFile::read(void*, unsigned int)+0xe8>
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
    5f06:	ldrb.w	r2, [fp, #4]
    5f0a:	rsb	r2, r8, r2
    5f0e:	cmp	r5, r2
    5f10:	it	cs
    5f12:	movcs	r5, r2
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    5f14:	cmp	r1, r3
    5f16:	bhi.n	5f3e <FatFile::read(void*, unsigned int)+0x112>
    5f18:	adds	r2, r1, r5
    5f1a:	cmp	r3, r2
    5f1c:	bcs.n	5f3e <FatFile::read(void*, unsigned int)+0x112>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    5f1e:	add.w	r0, fp, #40	; 0x28
    5f22:	str	r1, [sp, #4]
    5f24:	bl	3842 <FsCache::sync()>
    5f28:	ldr	r1, [sp, #4]
    5f2a:	cbnz	r0, 5f3e <FatFile::read(void*, unsigned int)+0x112>
    toRead -= n;
  }
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
    5f2c:	ldrb	r3, [r4, #1]
    5f2e:	orr.w	r3, r3, #2
    5f32:	strb	r3, [r4, #1]
  return -1;
    5f34:	mov.w	r0, #4294967295
    5f38:	b.n	5f9e <FatFile::read(void*, unsigned int)+0x172>
        if (m_curPosition == 0) {
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
    5f3a:	str	r3, [r4, #16]
    5f3c:	b.n	5ec2 <FatFile::read(void*, unsigned int)+0x96>
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    5f3e:	ldr.w	r0, [fp, #44]	; 0x2c
    5f42:	ldr	r3, [r0, #0]
    5f44:	mov	r2, r9
    5f46:	ldr.w	fp, [r3, #16]
    5f4a:	mov	r3, r5
    5f4c:	blx	fp
        if (mb < ns) {
          ns = mb;
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    5f4e:	cmp	r0, #0
    5f50:	beq.n	5f2c <FatFile::read(void*, unsigned int)+0x100>
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
        if (mb < ns) {
          ns = mb;
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
    5f52:	mov.w	fp, r5, lsl #9
    5f56:	b.n	5f6c <FatFile::read(void*, unsigned int)+0x140>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    5f58:	ldr.w	r0, [fp, #44]	; 0x2c
    5f5c:	ldr	r3, [r0, #0]
    5f5e:	mov	r2, r9
    5f60:	ldr	r3, [r3, #12]
    5f62:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    5f64:	cmp	r0, #0
    5f66:	beq.n	5f2c <FatFile::read(void*, unsigned int)+0x100>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    5f68:	mov.w	fp, #512	; 0x200
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    5f6c:	ldr	r3, [r4, #20]
    5f6e:	add	r3, fp
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    5f70:	add	r9, fp
    m_curPosition += n;
    5f72:	str	r3, [r4, #20]
    toRead -= n;
    5f74:	rsb	r7, fp, r7
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    5f78:	b.n	5e6a <FatFile::read(void*, unsigned int)+0x3e>
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    5f7a:	movs	r2, #0
    5f7c:	add.w	r0, fp, #40	; 0x28
    5f80:	bl	388e <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
      if (!pc) {
    5f84:	cmp	r0, #0
    5f86:	beq.n	5f2c <FatFile::read(void*, unsigned int)+0x100>
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
      // amount to be read from current sector
      n = m_vol->bytesPerSector() - offset;
    5f88:	rsb	fp, r5, #512	; 0x200
    5f8c:	cmp	fp, r7
    5f8e:	it	cs
    5f90:	movcs	fp, r7
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
    5f92:	adds	r1, r0, r5
    5f94:	mov	r2, fp
    5f96:	mov	r0, r9
    5f98:	bl	8f3c <memcpy>
    5f9c:	b.n	5f6c <FatFile::read(void*, unsigned int)+0x140>
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
  return -1;
}
    5f9e:	add	sp, #12
    5fa0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00005fa4 <FatFile::peek()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::peek() {
    5fa4:	push	{r0, r1, r4, r5, r6, lr}
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    5fa6:	movs	r2, #1
    5fa8:	add.w	r1, sp, #7
    5fac:	mov	r4, r0
  uint32_t curPosition = m_curPosition;
    5fae:	ldr	r6, [r0, #20]
  uint32_t curCluster = m_curCluster;
    5fb0:	ldr	r5, [r0, #16]
    5fb2:	bl	5e2c <FatFile::read(void*, unsigned int)>
    5fb6:	cmp	r0, #1
    5fb8:	it	eq
    5fba:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
    5fbe:	str	r6, [r4, #20]
    5fc0:	it	ne
    5fc2:	movne.w	r0, #4294967295
  m_curCluster = curCluster;
    5fc6:	str	r5, [r4, #16]
  return c;
}
    5fc8:	add	sp, #8
    5fca:	pop	{r4, r5, r6, pc}

00005fcc <FatFile::readDirCache(bool)>:
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;
    5fcc:	ldr	r3, [r0, #20]
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    5fce:	push	{r0, r1, r2, r4, r5, lr}
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;
    5fd0:	ubfx	r5, r3, #5, #4
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    5fd4:	mov	r4, r0
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;

  if (i == 0 || !skipReadOk) {
    5fd6:	cbz	r5, 5fda <FatFile::readDirCache(bool)+0xe>
    5fd8:	cbnz	r1, 5ff6 <FatFile::readDirCache(bool)+0x2a>
    int8_t n = read(&n, 1);
    5fda:	movs	r2, #1
    5fdc:	add.w	r1, sp, #7
    5fe0:	mov	r0, r4
    5fe2:	bl	5e2c <FatFile::read(void*, unsigned int)>
    5fe6:	sxtb	r0, r0
    if  (n != 1) {
    5fe8:	cmp	r0, #1
    5fea:	beq.n	5ff0 <FatFile::readDirCache(bool)+0x24>
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;

 fail:
  return nullptr;
    5fec:	movs	r0, #0
    5fee:	b.n	6002 <FatFile::readDirCache(bool)+0x36>
      if (n != 0) {
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    m_curPosition += 31;
    5ff0:	ldr	r3, [r4, #20]
    5ff2:	adds	r3, #31
    5ff4:	b.n	5ff8 <FatFile::readDirCache(bool)+0x2c>
  } else {
    m_curPosition += 32;
    5ff6:	adds	r3, #32
  static const uint8_t CACHE_RESERVE_FOR_WRITE =
    CACHE_STATUS_DIRTY | CACHE_OPTION_NO_READ;
  //----------------------------------------------------------------------------
  /** \return Cache buffer address. */
  uint8_t* cacheBuffer() {
    return m_buffer;
    5ff8:	ldr	r0, [r4, #8]
    5ffa:	str	r3, [r4, #20]
    5ffc:	adds	r0, #56	; 0x38
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;
    5ffe:	add.w	r0, r0, r5, lsl #5

 fail:
  return nullptr;
}
    6002:	add	sp, #12
    6004:	pop	{r4, r5, pc}

00006006 <FatFile::seekSet(unsigned long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    6006:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    600a:	mov	r4, r0
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    600c:	ldr	r7, [r0, #16]
    600e:	ldrb	r0, [r0, #0]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    6010:	mov	r6, r1
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    6012:	cmp	r0, #0
    6014:	beq.n	60a4 <FatFile::seekSet(unsigned long)+0x9e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    6016:	ldr	r5, [r4, #20]
    6018:	cmp	r5, r1
    601a:	beq.n	60ac <FatFile::seekSet(unsigned long)+0xa6>
    return true;
  }
  if (pos == 0) {
    601c:	cbnz	r1, 6022 <FatFile::seekSet(unsigned long)+0x1c>
    // set position to start of file
    m_curCluster = 0;
    601e:	str	r1, [r4, #16]
    goto done;
    6020:	b.n	6098 <FatFile::seekSet(unsigned long)+0x92>
  }
  if (isFile()) {
    6022:	lsls	r2, r0, #28
    6024:	bpl.n	602e <FatFile::seekSet(unsigned long)+0x28>
    if (pos > m_fileSize) {
    6026:	ldr	r3, [r4, #28]
    6028:	cmp	r1, r3
    602a:	bhi.n	60a4 <FatFile::seekSet(unsigned long)+0x9e>
    602c:	b.n	603e <FatFile::seekSet(unsigned long)+0x38>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (isRootFixed()) {
    602e:	lsls	r3, r0, #26
    6030:	bpl.n	603e <FatFile::seekSet(unsigned long)+0x38>
    6032:	ldr	r3, [r4, #8]
    if (pos <= 32*m_vol->rootDirEntryCount()) {
    6034:	ldrh	r3, [r3, #8]
    6036:	cmp.w	r1, r3, lsl #5
    603a:	bhi.n	60a4 <FatFile::seekSet(unsigned long)+0x9e>
    603c:	b.n	6098 <FatFile::seekSet(unsigned long)+0x92>
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    603e:	ldr.w	lr, [r4, #8]
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    6042:	ldrb	r1, [r4, #2]
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    6044:	ldrb.w	r2, [lr, #6]
    6048:	adds	r2, #9
    604a:	uxtb	r2, r2
    604c:	subs	r3, r6, #1
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    604e:	lsls	r1, r1, #25
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    6050:	lsr.w	r3, r3, r2
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    6054:	bpl.n	605e <FatFile::seekSet(unsigned long)+0x58>
    m_curCluster = m_firstCluster + nNew;
    6056:	ldr	r2, [r4, #32]
    6058:	add	r3, r2
    605a:	str	r3, [r4, #16]
    goto done;
    605c:	b.n	6098 <FatFile::seekSet(unsigned long)+0x92>
  }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> (m_vol->bytesPerClusterShift());
    605e:	subs	r1, r5, #1
    6060:	lsr.w	r2, r1, r2

  if (nNew < nCur || m_curPosition == 0) {
    6064:	cmp	r3, r2
    6066:	bcc.n	606a <FatFile::seekSet(unsigned long)+0x64>
    6068:	cbnz	r5, 607e <FatFile::seekSet(unsigned long)+0x78>
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    606a:	lsls	r2, r0, #25
    606c:	ite	mi
    606e:	ldrmi.w	r2, [lr, #32]
    6072:	ldrpl	r2, [r4, #32]
    6074:	str	r2, [r4, #16]
    6076:	mov	r5, r3
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    6078:	add.w	r8, r4, #16
    607c:	b.n	6094 <FatFile::seekSet(unsigned long)+0x8e>
  if (nNew < nCur || m_curPosition == 0) {
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    607e:	subs	r3, r3, r2
    6080:	b.n	6076 <FatFile::seekSet(unsigned long)+0x70>
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    6082:	mov	r2, r8
    6084:	ldr	r1, [r4, #16]
    6086:	ldr	r0, [r4, #8]
    6088:	bl	6aa0 <FatPartition::fatGet(unsigned long, unsigned long*)>
    608c:	cmp	r0, #0
    608e:	add.w	r5, r5, #4294967295
    6092:	ble.n	60a4 <FatFile::seekSet(unsigned long)+0x9e>
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    6094:	cmp	r5, #0
    6096:	bne.n	6082 <FatFile::seekSet(unsigned long)+0x7c>
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    6098:	ldrb	r3, [r4, #2]
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    609a:	str	r6, [r4, #20]
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    609c:	bic.w	r3, r3, #32
    60a0:	strb	r3, [r4, #2]
    60a2:	b.n	60ac <FatFile::seekSet(unsigned long)+0xa6>
  return true;

 fail:
  m_curCluster = tmp;
    60a4:	str	r7, [r4, #16]
  return false;
    60a6:	movs	r0, #0
    60a8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    60ac:	movs	r0, #1
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    60ae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000060b2 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>:
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    60b2:	push	{r3, r4, r5, r6, r7, lr}
    60b4:	mov	r7, r1
    60b6:	mov	r6, r2
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    60b8:	movs	r1, #0
    60ba:	movs	r2, #36	; 0x24
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    60bc:	mov	r4, r0
    60be:	mov	r5, r3
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    60c0:	bl	90e4 <memset>
  // location of entry in cache
  m_vol = dirFile->m_vol;
    60c4:	ldr	r0, [r7, #8]
  m_dirIndex = dirIndex;
    60c6:	strh	r6, [r4, #4]
    60c8:	add.w	r2, r0, #56	; 0x38
  m_dirCluster = dirFile->m_firstCluster;
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;
    60cc:	and.w	r6, r6, #15
    60d0:	add.w	r2, r2, r6, lsl #5
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    60d4:	ldr	r3, [r7, #32]
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
    60d6:	str	r0, [r4, #8]
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    60d8:	str	r3, [r4, #12]
    60da:	ldrb	r1, [r2, #11]
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;

  // Must be file or subdirectory.
  if (!isFileOrSubdir(dir)) {
    60dc:	lsls	r6, r1, #28
    60de:	bmi.n	615e <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
    60e0:	and.w	r1, r1, #23
    60e4:	strb	r1, [r4, #0]
  if (isFileDir(dir)) {
    60e6:	ldrb	r3, [r2, #11]
    60e8:	tst.w	r3, #24
    m_attributes |= FILE_ATTR_FILE;
  }
  m_lfnOrd = lfnOrd;
    60ec:	ldrb.w	r3, [sp, #24]
    60f0:	strb	r3, [r4, #3]
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    m_attributes |= FILE_ATTR_FILE;
    60f2:	it	eq
    60f4:	orreq.w	r1, r1, #8
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    60f8:	and.w	r3, r5, #3
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    m_attributes |= FILE_ATTR_FILE;
    60fc:	it	eq
    60fe:	strbeq	r1, [r4, #0]
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    6100:	cmp	r3, #1
    6102:	beq.n	6116 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x64>
    6104:	cmp	r3, #2
    6106:	beq.n	6112 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x60>
    6108:	cbnz	r3, 615e <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    case O_RDONLY:
      if (oflag & O_TRUNC) {
    610a:	lsls	r3, r5, #21
    610c:	bmi.n	615e <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
        DBG_FAIL_MACRO;
        goto fail;
      }
      m_flags = FILE_FLAG_READ;
    610e:	movs	r3, #1
    6110:	b.n	6118 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
      break;

    case O_RDWR:
      m_flags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    6112:	movs	r3, #3
    6114:	b.n	6118 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
      break;

    case O_WRONLY:
      m_flags = FILE_FLAG_WRITE;
    6116:	movs	r3, #2
    6118:	strb	r3, [r4, #2]
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }

  if (m_flags & FILE_FLAG_WRITE) {
    611a:	ldrb	r3, [r4, #2]
    611c:	lsls	r7, r3, #30
    611e:	bpl.n	6128 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x76>
    if (isSubDir() || isReadOnly()) {
    6120:	ldrb	r1, [r4, #0]
    6122:	tst.w	r1, #17
    6126:	bne.n	615e <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_flags |= (oflag & O_APPEND ? FILE_FLAG_APPEND : 0);
    6128:	and.w	r1, r5, #8
    612c:	orrs	r3, r1
    612e:	strb	r3, [r4, #2]
    6130:	ldr	r3, [r0, #52]	; 0x34

  m_dirSector = m_vol->cacheSectorNumber();
    6132:	str	r3, [r4, #24]

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    6134:	ldrh	r1, [r2, #20]
    6136:	ldrh	r3, [r2, #26]

  if (oflag & O_TRUNC) {
    6138:	lsls	r6, r5, #21

  m_dirSector = m_vol->cacheSectorNumber();

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    613a:	orr.w	r1, r3, r1, lsl #16

  if (oflag & O_TRUNC) {
    613e:	bpl.n	614a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x98>
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
    6140:	cbz	r1, 6166 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xb4>
    6142:	bl	6be6 <FatPartition::freeChain(unsigned long)>
    6146:	cbnz	r0, 6166 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xb4>
    6148:	b.n	615e <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else {
    m_firstCluster = firstCluster;
    614a:	str	r1, [r4, #32]
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    614c:	ldr	r3, [r2, #28]
    m_fileSize = getLe32(dir->fileSize);
    614e:	str	r3, [r4, #28]
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    6150:	lsls	r3, r5, #17
    6152:	bpl.n	6170 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xbe>
    6154:	ldr	r1, [r4, #28]
    6156:	mov	r0, r4
    6158:	bl	6006 <FatFile::seekSet(unsigned long)>
    615c:	cbnz	r0, 6170 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xbe>
    goto fail;
  }
  return true;

 fail:
  m_attributes = FILE_ATTR_CLOSED;
    615e:	movs	r0, #0
    6160:	strb	r0, [r4, #0]
  m_flags = 0;
    6162:	strb	r0, [r4, #2]
  return false;
    6164:	pop	{r3, r4, r5, r6, r7, pc}
      DBG_FAIL_MACRO;
      goto fail;
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    6166:	ldrb	r3, [r4, #2]
    6168:	orn	r3, r3, #127	; 0x7f
    616c:	strb	r3, [r4, #2]
    616e:	b.n	6150 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x9e>
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return true;
    6170:	movs	r0, #1

 fail:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
    6172:	pop	{r3, r4, r5, r6, r7, pc}

00006174 <FatFile::openNext(FatFile*, int)>:
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    6174:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    6178:	ldrb	r3, [r0, #0]
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    617a:	mov	r6, r0
    617c:	mov	r5, r1
    617e:	mov	r9, r2
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    6180:	cbnz	r3, 61f2 <FatFile::openNext(FatFile*, int)+0x7e>
    6182:	ldrb	r3, [r1, #0]
    6184:	tst.w	r3, #112	; 0x70
    6188:	beq.n	61f2 <FatFile::openNext(FatFile*, int)+0x7e>
    618a:	ldr	r4, [r1, #20]
    618c:	ands.w	r4, r4, #31
    6190:	bne.n	61f2 <FatFile::openNext(FatFile*, int)+0x7e>
    6192:	mov	r7, r4
    goto fail;
  }
  while (1) {
    // read entry into cache
    index = dirFile->curPosition()/32;
    DirFat_t* dir = dirFile->readDirCache();
    6194:	movs	r1, #0
    6196:	mov	r0, r5
    6198:	ldr.w	r8, [r5, #20]
    619c:	bl	5fcc <FatFile::readDirCache(bool)>
    if (!dir) {
    61a0:	cbz	r0, 61f2 <FatFile::openNext(FatFile*, int)+0x7e>
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    // done if last entry
    if (dir->name[0] == FAT_NAME_FREE) {
    61a2:	ldrb	r3, [r0, #0]
    61a4:	cbz	r3, 61f2 <FatFile::openNext(FatFile*, int)+0x7e>
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
    61a6:	cmp	r3, #46	; 0x2e
    61a8:	bne.n	61ae <FatFile::openNext(FatFile*, int)+0x3a>
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
        lfnOrd = ldir->order & 0X1F;
        checksum = ldir->checksum;
      }
    } else {
      lfnOrd = 0;
    61aa:	movs	r4, #0
    61ac:	b.n	6194 <FatFile::openNext(FatFile*, int)+0x20>
    // done if last entry
    if (dir->name[0] == FAT_NAME_FREE) {
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
    61ae:	cmp	r3, #229	; 0xe5
    61b0:	beq.n	61aa <FatFile::openNext(FatFile*, int)+0x36>
    61b2:	ldrb	r2, [r0, #11]
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
    61b4:	and.w	lr, r2, #8
    61b8:	and.w	r1, lr, #255	; 0xff
    61bc:	cmp.w	lr, #0
    61c0:	bne.n	61e2 <FatFile::openNext(FatFile*, int)+0x6e>
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
    61c2:	cbz	r4, 61f6 <FatFile::openNext(FatFile*, int)+0x82>
    61c4:	subs	r2, r0, #1
    61c6:	adds	r0, #10
    61c8:	lsls	r3, r1, #7
    61ca:	orr.w	r1, r3, r1, lsr #1
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    61ce:	ldrb.w	r3, [r2, #1]!
    61d2:	uxtab	r1, r3, r1
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    61d6:	cmp	r0, r2
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    61d8:	uxtb	r1, r1
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    61da:	bne.n	61c8 <FatFile::openNext(FatFile*, int)+0x54>
    61dc:	cmp	r7, r1
    61de:	bne.n	61f2 <FatFile::openNext(FatFile*, int)+0x7e>
    61e0:	b.n	61f6 <FatFile::openNext(FatFile*, int)+0x82>
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      return true;
    } else if (isLongName(dir)) {
    61e2:	cmp	r2, #15
    61e4:	bne.n	61aa <FatFile::openNext(FatFile*, int)+0x36>
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
    61e6:	lsls	r2, r3, #25
    61e8:	bpl.n	6194 <FatFile::openNext(FatFile*, int)+0x20>
        lfnOrd = ldir->order & 0X1F;
    61ea:	and.w	r4, r3, #31
        checksum = ldir->checksum;
    61ee:	ldrb	r7, [r0, #13]
    61f0:	b.n	6194 <FatFile::openNext(FatFile*, int)+0x20>
      lfnOrd = 0;
    }
  }

 fail:
  return false;
    61f2:	movs	r0, #0
    61f4:	b.n	6206 <FatFile::openNext(FatFile*, int)+0x92>
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
    61f6:	str	r4, [sp, #0]
    61f8:	mov	r3, r9
    61fa:	ubfx	r2, r8, #5, #16
    61fe:	mov	r1, r5
    6200:	mov	r0, r6
    6202:	bl	60b2 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    }
  }

 fail:
  return false;
}
    6206:	add	sp, #12
    6208:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0000620c <FatFile::rmdir()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
    620c:	push	{r4, lr}
  // must be open subdirectory
  if (!isSubDir() || (!USE_LONG_FILE_NAMES && isLFN())) {
    620e:	ldrb	r3, [r0, #0]
    6210:	lsls	r2, r3, #27

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
    6212:	mov	r4, r0
  // must be open subdirectory
  if (!isSubDir() || (!USE_LONG_FILE_NAMES && isLFN())) {
    6214:	bpl.n	6256 <FatFile::rmdir()+0x4a>
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    6216:	movs	r1, #0
    6218:	bl	6006 <FatFile::seekSet(unsigned long)>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    DirFat_t* dir = readDirCache(true);
    621c:	movs	r1, #1
    621e:	mov	r0, r4
    6220:	bl	5fcc <FatFile::readDirCache(bool)>
    if (!dir) {
    6224:	cbnz	r0, 622c <FatFile::rmdir()+0x20>
      // EOF if no error.
      if (!getError()) {
    6226:	ldrb	r3, [r4, #1]
    6228:	cbz	r3, 6240 <FatFile::rmdir()+0x34>
    622a:	b.n	6256 <FatFile::rmdir()+0x4a>
      }
      DBG_FAIL_MACRO;
      goto fail;
    }
    // done if past last used entry
    if (dir->name[0] == FAT_NAME_FREE) {
    622c:	ldrb	r3, [r0, #0]
    622e:	cbz	r3, 6240 <FatFile::rmdir()+0x34>
      break;
    }
    // skip empty slot, '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    6230:	cmp	r3, #229	; 0xe5
    6232:	beq.n	621c <FatFile::rmdir()+0x10>
    6234:	cmp	r3, #46	; 0x2e
    6236:	beq.n	621c <FatFile::rmdir()+0x10>
      continue;
    }
    // error not empty
    if (isFileOrSubdir(dir)) {
    6238:	ldrb	r3, [r0, #11]
    623a:	lsls	r3, r3, #28
    623c:	bmi.n	621c <FatFile::rmdir()+0x10>
    623e:	b.n	6256 <FatFile::rmdir()+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    6240:	movs	r3, #8
    6242:	strb	r3, [r4, #0]
  m_flags |= FILE_FLAG_WRITE;
    6244:	ldrb	r3, [r4, #2]
    6246:	orr.w	r3, r3, #2
    624a:	strb	r3, [r4, #2]
  return remove();
    624c:	mov	r0, r4

 fail:
  return false;
}
    624e:	ldmia.w	sp!, {r4, lr}
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    6252:	b.w	7408 <FatFile::remove()>

 fail:
  return false;
}
    6256:	movs	r0, #0
    6258:	pop	{r4, pc}
    625a:	Address 0x0000625a is out of bounds.


0000625c <FatFile::sync()>:
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    625c:	push	{r0, r1, r2, r4, r5, lr}
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    625e:	ldrb	r3, [r0, #0]
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    6260:	mov	r4, r0
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    6262:	cmp	r3, #0
    6264:	beq.n	62d0 <FatFile::sync()+0x74>
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    6266:	ldrsb.w	r3, [r0, #2]
    626a:	cmp	r3, #0
    626c:	bge.n	62c4 <FatFile::sync()+0x68>
    DirFat_t* dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    626e:	movs	r1, #1
    6270:	bl	5db0 <FatFile::cacheDirEntry(unsigned char)>
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
    6274:	mov	r5, r0
    6276:	cbnz	r0, 6284 <FatFile::sync()+0x28>
    return true;
  }
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
    6278:	ldrb	r3, [r4, #1]
    627a:	orr.w	r3, r3, #1
    627e:	strb	r3, [r4, #1]
  return false;
    6280:	movs	r0, #0
    6282:	b.n	62d2 <FatFile::sync()+0x76>
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    DirFat_t* dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
    6284:	ldrb	r3, [r0, #0]
    6286:	cmp	r3, #229	; 0xe5
    6288:	beq.n	6278 <FatFile::sync()+0x1c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // do not set filesize for dir files
    if (isFile()) {
    628a:	ldrb	r3, [r4, #0]
    628c:	lsls	r3, r3, #28
      setLe32(dir->fileSize, m_fileSize);
    628e:	itt	mi
    6290:	ldrmi	r3, [r4, #28]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    6292:	strmi	r3, [r0, #28]
    }
    // update first cluster fields
    setLe16(dir->firstClusterLow, m_firstCluster & 0XFFFF);
    6294:	ldr	r3, [r4, #32]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    6296:	strh	r3, [r0, #26]
    6298:	lsrs	r3, r3, #16
    629a:	strh	r3, [r0, #20]
    setLe16(dir->firstClusterHigh, m_firstCluster >> 16);

    // set modify time if user supplied a callback date/time function
    if (FsDateTime::callback) {
    629c:	ldr	r3, [pc, #56]	; (62d8 <FatFile::sync()+0x7c>)
    629e:	ldr	r3, [r3, #0]
    62a0:	cbz	r3, 62bc <FatFile::sync()+0x60>
      FsDateTime::callback(&date, &time, &ms10);
    62a2:	add.w	r2, sp, #3
    62a6:	add.w	r1, sp, #6
    62aa:	add	r0, sp, #4
    62ac:	blx	r3
      setLe16(dir->modifyDate, date);
    62ae:	ldrh.w	r3, [sp, #4]
    62b2:	strh	r3, [r5, #24]
    62b4:	strh	r3, [r5, #18]
    62b6:	ldrh.w	r3, [sp, #6]
    62ba:	strh	r3, [r5, #22]
      setLe16(dir->accessDate, date);
      setLe16(dir->modifyTime, time);
    }
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    62bc:	ldrb	r3, [r4, #2]
    62be:	and.w	r3, r3, #127	; 0x7f
    62c2:	strb	r3, [r4, #2]
  }
  if (m_vol->cacheSync()) {
    62c4:	ldr	r0, [r4, #8]
    62c6:	bl	5cc8 <FatPartition::cacheSync()>
    62ca:	cmp	r0, #0
    62cc:	beq.n	6278 <FatFile::sync()+0x1c>
    62ce:	b.n	62d2 <FatFile::sync()+0x76>
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
    62d0:	movs	r0, #1
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    62d2:	add	sp, #12
    62d4:	pop	{r4, r5, pc}
    62d6:	nop
    62d8:	.word	0x2001a690

000062dc <FatFile::close()>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
    62dc:	push	{r4, lr}
    62de:	mov	r4, r0
  bool rtn = sync();
    62e0:	bl	625c <FatFile::sync()>
  m_attributes = FILE_ATTR_CLOSED;
    62e4:	movs	r3, #0
    62e6:	strb	r3, [r4, #0]
  m_flags = 0;
    62e8:	strb	r3, [r4, #2]
  return rtn;
}
    62ea:	pop	{r4, pc}

000062ec <FatFile::open(FatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    62ec:	push	{r4, r5, r6, r7, lr}
    62ee:	sub	sp, #84	; 0x54
    62f0:	mov	r7, r3
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    62f2:	movs	r3, #0
    62f4:	strb.w	r3, [sp, #8]
    62f8:	strb.w	r3, [sp, #9]
    62fc:	strb.w	r3, [sp, #10]
    6300:	strh.w	r3, [sp, #56]	; 0x38
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    6304:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    6306:	str	r2, [sp, #4]
    6308:	mov	r6, r0
    630a:	mov	r4, r1
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    630c:	cbz	r3, 6312 <FatFile::open(FatFile*, char const*, int)+0x26>
    close();
  }
  return open(dirFile, &fname, oflag);

 fail:
  return false;
    630e:	movs	r0, #0
    6310:	b.n	6390 <FatFile::open(FatFile*, char const*, int)+0xa4>
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    6312:	ldrb	r3, [r1, #0]
    6314:	tst.w	r3, #112	; 0x70
    6318:	beq.n	630e <FatFile::open(FatFile*, char const*, int)+0x22>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    631a:	ldrb	r3, [r2, #0]
    631c:	cmp	r3, #47	; 0x2f
    631e:	bne.n	6346 <FatFile::open(FatFile*, char const*, int)+0x5a>
    while (isDirSeparator(*path)) {
    6320:	ldr	r3, [sp, #4]
    6322:	ldrb	r2, [r3, #0]
    6324:	cmp	r2, #47	; 0x2f
    6326:	bne.n	632e <FatFile::open(FatFile*, char const*, int)+0x42>
      path++;
    6328:	adds	r3, #1
    632a:	str	r3, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    632c:	b.n	6320 <FatFile::open(FatFile*, char const*, int)+0x34>
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    632e:	ldr	r1, [r4, #8]
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
    6330:	cbnz	r2, 633a <FatFile::open(FatFile*, char const*, int)+0x4e>
      return openRoot(dirFile->m_vol);
    6332:	mov	r0, r6
    6334:	bl	5dce <FatFile::openRoot(FatVolume*)>
    6338:	b.n	6390 <FatFile::open(FatFile*, char const*, int)+0xa4>
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    633a:	add	r0, sp, #8
    633c:	bl	5dce <FatFile::openRoot(FatVolume*)>
    6340:	cmp	r0, #0
    6342:	beq.n	630e <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    6344:	add	r4, sp, #8
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    6346:	add	r3, sp, #4
    6348:	add	r2, sp, #44	; 0x2c
    634a:	ldr	r1, [sp, #4]
    634c:	mov	r0, r6
    634e:	bl	7370 <FatFile::parsePathName(char const*, FatName_t*, char const**)>
    6352:	cmp	r0, #0
    6354:	beq.n	630e <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    6356:	ldr	r3, [sp, #4]
    6358:	ldrb	r3, [r3, #0]
    635a:	cbz	r3, 6384 <FatFile::open(FatFile*, char const*, int)+0x98>
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    635c:	movs	r3, #0
    635e:	add	r2, sp, #44	; 0x2c
    6360:	mov	r1, r4
    6362:	mov	r0, r6
    6364:	bl	7120 <FatFile::open(FatFile*, FatName_t*, int)>
    6368:	cmp	r0, #0
    636a:	beq.n	630e <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_WARN_MACRO;
      goto fail;
    }
    tmpDir = *this;
    636c:	mov	r5, r6
    636e:	ldmia	r5!, {r0, r1, r2, r3}
    6370:	add	r4, sp, #8
    6372:	stmia	r4!, {r0, r1, r2, r3}
    6374:	ldmia	r5!, {r0, r1, r2, r3}
    6376:	stmia	r4!, {r0, r1, r2, r3}
    6378:	ldr	r3, [r5, #0]
    637a:	str	r3, [r4, #0]
    dirFile = &tmpDir;
    close();
    637c:	mov	r0, r6
    637e:	bl	62dc <FatFile::close()>
    6382:	b.n	6344 <FatFile::open(FatFile*, char const*, int)+0x58>
  }
  return open(dirFile, &fname, oflag);
    6384:	mov	r3, r7
    6386:	add	r2, sp, #44	; 0x2c
    6388:	mov	r1, r4
    638a:	mov	r0, r6
    638c:	bl	7120 <FatFile::open(FatFile*, FatName_t*, int)>

 fail:
  return false;
}
    6390:	add	sp, #84	; 0x54
    6392:	pop	{r4, r5, r6, r7, pc}

00006394 <FatFile::open(FatVolume*, char const*, int)>:
bool FatFile::open(const char* path, oflag_t oflag) {
  return open(FatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
    6394:	cbz	r1, 639e <FatFile::open(FatVolume*, char const*, int)+0xa>
    6396:	add.w	r1, r1, #1096	; 0x448
    639a:	b.w	62ec <FatFile::open(FatFile*, char const*, int)>
}
    639e:	mov	r0, r1
    63a0:	bx	lr

000063a2 <FatFile::dirEntry(DirFat_t*)>:
  close();
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::dirEntry(DirFat_t* dst) {
    63a2:	push	{r4, r5, r6, lr}
    63a4:	mov	r6, r0
    63a6:	mov	r4, r1
  DirFat_t* dir;
  // Make sure fields on device are correct.
  if (!sync()) {
    63a8:	bl	625c <FatFile::sync()>
    63ac:	mov	r5, r0
    63ae:	cbnz	r0, 63b4 <FatFile::dirEntry(DirFat_t*)+0x12>
  // copy to caller's struct
  memcpy(dst, dir, sizeof(DirFat_t));
  return true;

 fail:
  return false;
    63b0:	movs	r5, #0
    63b2:	b.n	63d2 <FatFile::dirEntry(DirFat_t*)+0x30>
  if (!sync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    63b4:	movs	r1, #0
    63b6:	mov	r0, r6
    63b8:	bl	5db0 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    63bc:	cmp	r0, #0
    63be:	beq.n	63b0 <FatFile::dirEntry(DirFat_t*)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy to caller's struct
  memcpy(dst, dir, sizeof(DirFat_t));
    63c0:	mov	r1, r4
    63c2:	add.w	r3, r0, #32
    63c6:	ldr.w	r2, [r0], #4
    63ca:	str.w	r2, [r1], #4
    63ce:	cmp	r0, r3
    63d0:	bne.n	63c6 <FatFile::dirEntry(DirFat_t*)+0x24>
  return true;

 fail:
  return false;
}
    63d2:	mov	r0, r5
    63d4:	pop	{r4, r5, r6, pc}

000063d6 <FatFile::getCreateDateTime(unsigned short*, unsigned short*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    63d6:	push	{r4, r5, lr}
    63d8:	sub	sp, #36	; 0x24
    63da:	mov	r5, r1
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    63dc:	mov	r1, sp

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    63de:	mov	r4, r2
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    63e0:	bl	63a2 <FatFile::dirEntry(DirFat_t*)>
    63e4:	cbz	r0, 63f2 <FatFile::getCreateDateTime(unsigned short*, unsigned short*)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(dir.createDate);
    63e6:	ldrh.w	r3, [sp, #16]
    63ea:	strh	r3, [r5, #0]
  *ptime = getLe16(dir.createTime);
    63ec:	ldrh.w	r3, [sp, #14]
    63f0:	strh	r3, [r4, #0]
  return true;

 fail:
  return false;
}
    63f2:	add	sp, #36	; 0x24
    63f4:	pop	{r4, r5, pc}

000063f6 <FatFile::getModifyDateTime(unsigned short*, unsigned short*)>:
//------------------------------------------------------------------------------
bool FatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    63f6:	push	{r4, r5, lr}
    63f8:	sub	sp, #36	; 0x24
    63fa:	mov	r5, r1
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    63fc:	mov	r1, sp

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    63fe:	mov	r4, r2
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    6400:	bl	63a2 <FatFile::dirEntry(DirFat_t*)>
    6404:	cbz	r0, 6412 <FatFile::getModifyDateTime(unsigned short*, unsigned short*)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(dir.modifyDate);
    6406:	ldrh.w	r3, [sp, #24]
    640a:	strh	r3, [r5, #0]
  *ptime = getLe16(dir.modifyTime);
    640c:	ldrh.w	r3, [sp, #22]
    6410:	strh	r3, [r4, #0]
  return true;

 fail:
  return false;
}
    6412:	add	sp, #36	; 0x24
    6414:	pop	{r4, r5, pc}

00006416 <FatFile::mkdir(FatFile*, FatName_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, FatName_t* fname) {
    6416:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    641a:	ldrb	r3, [r1, #0]
    641c:	tst.w	r3, #112	; 0x70

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, FatName_t* fname) {
    6420:	sub	sp, #32
    6422:	mov	r4, r0
    6424:	mov	r6, r1
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    6426:	beq.n	6462 <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    6428:	movw	r3, #2562	; 0xa02
    642c:	bl	7120 <FatFile::open(FatFile*, FatName_t*, int)>
    6430:	cbz	r0, 6462 <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    6432:	movs	r7, #1
  m_attributes = FILE_ATTR_SUBDIR;
    6434:	movs	r5, #16
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    6436:	strb	r7, [r4, #2]
  m_attributes = FILE_ATTR_SUBDIR;
    6438:	strb	r5, [r4, #0]

  // allocate and zero first cluster
  if (!addDirCluster()) {
    643a:	mov	r0, r4
    643c:	bl	5d24 <FatFile::addDirCluster()>
    6440:	cbz	r0, 6462 <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    6442:	ldr	r3, [r4, #16]
    6444:	str	r3, [r4, #32]
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    6446:	movs	r1, #0
    6448:	mov	r0, r4
    644a:	bl	6006 <FatFile::seekSet(unsigned long)>
  // Set to start of dir
  rewind();
  // force entry to device
  if (!sync()) {
    644e:	mov	r0, r4
    6450:	bl	625c <FatFile::sync()>
    6454:	cbz	r0, 6462 <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // cache entry - should already be in cache due to sync() call
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6456:	mov	r1, r7
    6458:	mov	r0, r4
    645a:	bl	5db0 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    645e:	mov	r3, r0
    6460:	cbnz	r0, 6466 <FatFile::mkdir(FatFile*, FatName_t*)+0x50>
  memcpy(&pc->dir[1], &dot, sizeof(dot));
  // write first sector
  return m_vol->cacheSync();

 fail:
  return false;
    6462:	movs	r0, #0
    6464:	b.n	650a <FatFile::mkdir(FatFile*, FatName_t*)+0xf4>
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // change directory entry attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;
    6466:	strb	r5, [r0, #11]

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
    6468:	mov	r2, r0
    646a:	mov	r7, sp
    646c:	add.w	ip, r0, #32
    6470:	mov	r5, sp
    6472:	ldr	r0, [r2, #0]
    6474:	ldr	r1, [r2, #4]
    6476:	mov	lr, r7
    6478:	stmia.w	lr!, {r0, r1}
    647c:	adds	r2, #8
    647e:	cmp	r2, ip
    6480:	mov	r7, lr
    6482:	bne.n	6472 <FatFile::mkdir(FatFile*, FatName_t*)+0x5c>
    6484:	ldrh	r7, [r3, #20]
    6486:	ldrh.w	r8, [r3, #26]
  dot.name[0] = '.';
    648a:	movs	r3, #46	; 0x2e
    648c:	strb.w	r3, [sp]
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    6490:	movs	r1, #32
  // change directory entry attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
    6492:	movs	r3, #0
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    6494:	adds	r2, r5, r3
    6496:	adds	r3, #1
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    6498:	cmp	r3, #10
    dot.name[i] = ' ';
    649a:	strb	r1, [r2, #1]
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    649c:	bne.n	6494 <FatFile::mkdir(FatFile*, FatName_t*)+0x7e>
    dot.name[i] = ' ';
  }

  // cache sector for '.'  and '..'
  sector = m_vol->clusterStartSector(m_firstCluster);
    649e:	ldr	r0, [r4, #8]
    64a0:	ldr	r1, [r4, #32]
    64a2:	ldrb	r3, [r0, #6]
    64a4:	subs	r1, #2
    64a6:	lsls	r1, r3
    64a8:	ldr	r3, [r0, #20]
    64aa:	movs	r2, #1
    64ac:	add	r1, r3
    64ae:	adds	r0, #40	; 0x28
    64b0:	bl	388e <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
  if (!pc) {
    64b4:	mov	r3, r0
    64b6:	cmp	r0, #0
    64b8:	beq.n	6462 <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
    64ba:	strh.w	r7, [sp, #20]
    64be:	strh.w	r8, [sp, #26]
    64c2:	mov	lr, r5
    64c4:	mov	r7, r0
    64c6:	add.w	ip, sp, #32
    64ca:	mov	r2, lr
    64cc:	ldmia	r2!, {r0, r1}
    64ce:	cmp	r2, ip
    64d0:	str	r0, [r7, #0]
    64d2:	str	r1, [r7, #4]
    64d4:	mov	lr, r2
    64d6:	add.w	r7, r7, #8
    64da:	bne.n	64ca <FatFile::mkdir(FatFile*, FatName_t*)+0xb4>
  // make entry for '..'
  dot.name[1] = '.';
    64dc:	movs	r2, #46	; 0x2e
    64de:	strb.w	r2, [sp, #1]
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
    64e2:	ldr	r2, [r6, #32]
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    64e4:	strh.w	r2, [sp, #26]
    64e8:	lsrs	r1, r2, #16
    64ea:	strh.w	r1, [sp, #20]
    64ee:	adds	r3, #32
    64f0:	add	r6, sp, #32
    64f2:	mov	r2, r5
    64f4:	ldmia	r2!, {r0, r1}
    64f6:	cmp	r2, r6
    64f8:	str	r0, [r3, #0]
    64fa:	str	r1, [r3, #4]
    64fc:	mov	r5, r2
    64fe:	add.w	r3, r3, #8
    6502:	bne.n	64f2 <FatFile::mkdir(FatFile*, FatName_t*)+0xdc>
  // write first sector
  return m_vol->cacheSync();
    6504:	ldr	r0, [r4, #8]
    6506:	bl	5cc8 <FatPartition::cacheSync()>

 fail:
  return false;
}
    650a:	add	sp, #32
    650c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00006510 <FatFile::mkdir(FatFile*, char const*, bool)>:
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    6510:	push	{r4, r5, r6, r7, lr}
    6512:	sub	sp, #84	; 0x54
    6514:	mov	r7, r3
    6516:	movs	r3, #0
    6518:	strh.w	r3, [sp, #20]
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    651c:	strb.w	r3, [sp, #44]	; 0x2c
    6520:	strb.w	r3, [sp, #45]	; 0x2d
    6524:	strb.w	r3, [sp, #46]	; 0x2e
  FatName_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    6528:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    652a:	str	r2, [sp, #4]
    652c:	mov	r6, r0
    652e:	mov	r4, r1
  FatName_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    6530:	cmp	r3, #0
    6532:	bne.n	65b4 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    6534:	ldrb	r3, [r1, #0]
    6536:	tst.w	r3, #112	; 0x70
    653a:	beq.n	65b4 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    653c:	ldrb	r3, [r2, #0]
    653e:	cmp	r3, #47	; 0x2f
    6540:	bne.n	655c <FatFile::mkdir(FatFile*, char const*, bool)+0x4c>
    while (isDirSeparator(*path)) {
    6542:	ldr	r3, [sp, #4]
    6544:	ldrb	r2, [r3, #0]
    6546:	cmp	r2, #47	; 0x2f
    6548:	bne.n	6550 <FatFile::mkdir(FatFile*, char const*, bool)+0x40>
      path++;
    654a:	adds	r3, #1
    654c:	str	r3, [sp, #4]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    654e:	b.n	6542 <FatFile::mkdir(FatFile*, char const*, bool)+0x32>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    6550:	ldr	r1, [r4, #8]
    6552:	add	r0, sp, #44	; 0x2c
    6554:	bl	5dce <FatFile::openRoot(FatVolume*)>
    6558:	cbz	r0, 65b4 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    655a:	add	r4, sp, #44	; 0x2c
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    655c:	add	r3, sp, #4
    655e:	add	r2, sp, #8
    6560:	ldr	r1, [sp, #4]
    6562:	mov	r0, r6
    6564:	bl	7370 <FatFile::parsePathName(char const*, FatName_t*, char const**)>
    6568:	cbz	r0, 65b4 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    656a:	ldr	r3, [sp, #4]
    656c:	ldrb	r3, [r3, #0]
    656e:	cbz	r3, 65a8 <FatFile::mkdir(FatFile*, char const*, bool)+0x98>
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    6570:	movs	r3, #0
    6572:	add	r2, sp, #8
    6574:	mov	r1, r4
    6576:	mov	r0, r6
    6578:	bl	7120 <FatFile::open(FatFile*, FatName_t*, int)>
    657c:	cbz	r0, 6596 <FatFile::mkdir(FatFile*, char const*, bool)+0x86>
      if (!pFlag || !mkdir(parent, &fname)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    657e:	mov	r5, r6
    6580:	ldmia	r5!, {r0, r1, r2, r3}
    6582:	add	r4, sp, #44	; 0x2c
    6584:	stmia	r4!, {r0, r1, r2, r3}
    6586:	ldmia	r5!, {r0, r1, r2, r3}
    6588:	stmia	r4!, {r0, r1, r2, r3}
    658a:	ldr	r3, [r5, #0]
    658c:	str	r3, [r4, #0]
    parent = &tmpDir;
    close();
    658e:	mov	r0, r6
    6590:	bl	62dc <FatFile::close()>
    6594:	b.n	655a <FatFile::mkdir(FatFile*, char const*, bool)+0x4a>
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
      if (!pFlag || !mkdir(parent, &fname)) {
    6596:	cbz	r7, 65b4 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    6598:	add	r2, sp, #8
    659a:	mov	r1, r4
    659c:	mov	r0, r6
    659e:	bl	6416 <FatFile::mkdir(FatFile*, FatName_t*)>
    65a2:	cmp	r0, #0
    65a4:	bne.n	657e <FatFile::mkdir(FatFile*, char const*, bool)+0x6e>
    65a6:	b.n	65b4 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    65a8:	add	r2, sp, #8
    65aa:	mov	r1, r4
    65ac:	mov	r0, r6
    65ae:	bl	6416 <FatFile::mkdir(FatFile*, FatName_t*)>
    65b2:	b.n	65b6 <FatFile::mkdir(FatFile*, char const*, bool)+0xa6>

 fail:
  return false;
    65b4:	movs	r0, #0
}
    65b6:	add	sp, #84	; 0x54
    65b8:	pop	{r4, r5, r6, r7, pc}

000065ba <FatFile::rename(FatFile*, char const*)>:
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    65ba:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    65be:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    65c0:	sub	sp, #108	; 0x6c
    65c2:	movs	r7, #0
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    65c4:	tst.w	r3, #24
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    65c8:	mov	r4, r0
    65ca:	mov	r8, r1
    65cc:	mov	r9, r2
    65ce:	strb.w	r7, [sp, #32]
    65d2:	strb.w	r7, [sp, #33]	; 0x21
    65d6:	strb.w	r7, [sp, #34]	; 0x22
    65da:	strb.w	r7, [sp, #68]	; 0x44
    65de:	strb.w	r7, [sp, #69]	; 0x45
    65e2:	strb.w	r7, [sp, #70]	; 0x46
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    65e6:	bne.n	65ec <FatFile::rename(FatFile*, char const*)+0x32>
    goto fail;
  }
  return m_vol->cacheSync();

 fail:
  return false;
    65e8:	movs	r0, #0
    65ea:	b.n	674a <FatFile::rename(FatFile*, char const*)+0x190>
  if (!USE_LONG_FILE_NAMES && isLFN()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    65ec:	ldr	r2, [r0, #8]
    65ee:	ldr	r3, [r1, #8]
    65f0:	cmp	r2, r3
    65f2:	bne.n	65e8 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // sync() and cache directory entry
  sync();
  oldFile = *this;
    65f4:	mov	r6, r4
  if (m_vol != dirFile->m_vol) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // sync() and cache directory entry
  sync();
    65f6:	bl	625c <FatFile::sync()>
  oldFile = *this;
    65fa:	ldmia	r6!, {r0, r1, r2, r3}
    65fc:	add	r5, sp, #68	; 0x44
    65fe:	stmia	r5!, {r0, r1, r2, r3}
    6600:	ldmia	r6!, {r0, r1, r2, r3}
    6602:	stmia	r5!, {r0, r1, r2, r3}
    6604:	ldr	r3, [r6, #0]
    6606:	str	r3, [r5, #0]
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    6608:	mov	r1, r7
    660a:	mov	r0, r4
    660c:	bl	5db0 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    6610:	cmp	r0, #0
    6612:	beq.n	65e8 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    6614:	mov	r3, r0
    6616:	mov	r2, sp
    6618:	add.w	r7, r0, #32
    661c:	mov	r5, sp
    661e:	ldr	r0, [r3, #0]
    6620:	ldr	r1, [r3, #4]
    6622:	mov	r6, r2
    6624:	stmia	r6!, {r0, r1}
    6626:	adds	r3, #8
    6628:	cmp	r3, r7
    662a:	mov	r2, r6
    662c:	bne.n	661e <FatFile::rename(FatFile*, char const*)+0x64>
  // make directory entry for new path
  if (isFile()) {
    662e:	ldrb	r2, [r4, #0]
    6630:	and.w	r2, r2, #8
    6634:	and.w	r3, r2, #255	; 0xff
    6638:	add	r6, sp, #32
    663a:	cbz	r2, 6652 <FatFile::rename(FatFile*, char const*)+0x98>
    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    663c:	movw	r3, #2561	; 0xa01
    6640:	mov	r2, r9
    6642:	mov	r1, r8
    6644:	mov	r0, r6
    6646:	bl	62ec <FatFile::open(FatFile*, char const*, int)>
    664a:	cmp	r0, #0
    664c:	beq.n	65e8 <FatFile::rename(FatFile*, char const*)+0x2e>
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
  DirFat_t entry;
  uint32_t dirCluster = 0;
    664e:	movs	r7, #0
    6650:	b.n	6662 <FatFile::rename(FatFile*, char const*)+0xa8>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // don't create missing path prefix components
    if (!file.mkdir(dirFile, newPath, false)) {
    6652:	mov	r2, r9
    6654:	mov	r1, r8
    6656:	mov	r0, r6
    6658:	bl	6510 <FatFile::mkdir(FatFile*, char const*, bool)>
    665c:	cmp	r0, #0
    665e:	beq.n	65e8 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
    6660:	ldr	r7, [sp, #64]	; 0x40
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
    6662:	ldr	r3, [sp, #56]	; 0x38
    6664:	str	r3, [r4, #24]
  m_dirIndex = file.m_dirIndex;
    6666:	ldrh.w	r3, [sp, #36]	; 0x24
    666a:	strh	r3, [r4, #4]
  m_lfnOrd = file.m_lfnOrd;
    666c:	ldrb.w	r3, [sp, #35]	; 0x23
    6670:	strb	r3, [r4, #3]
  m_dirCluster = file.m_dirCluster;
    6672:	ldr	r3, [sp, #44]	; 0x2c
    6674:	str	r3, [r4, #12]
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6676:	movs	r1, #1
  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    6678:	movs	r3, #0
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    667a:	mov	r0, r4
  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    667c:	strb.w	r3, [sp, #32]
  file.m_flags = 0;
    6680:	strb.w	r3, [sp, #34]	; 0x22

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6684:	bl	5db0 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    6688:	cmp	r0, #0
    668a:	beq.n	65e8 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy all but name and name flags to new directory entry
  memcpy(&dir->createTimeMs, &entry.createTimeMs,
         sizeof(entry) - sizeof(dir->name) - 2);
    668c:	add.w	r3, sp, #13
    6690:	add.w	r2, r0, #13
    6694:	add.w	r1, sp, #29
    6698:	ldr.w	lr, [r3], #4
    669c:	str.w	lr, [r2], #4
    66a0:	cmp	r3, r1
    66a2:	bne.n	6698 <FatFile::rename(FatFile*, char const*)+0xde>
    66a4:	ldrh	r1, [r3, #0]
    66a6:	strh	r1, [r2, #0]
    66a8:	ldrb	r3, [r3, #2]
    66aa:	strb	r3, [r2, #2]
  dir->attributes = entry.attributes;
    66ac:	ldrb.w	r3, [sp, #11]
    66b0:	strb	r3, [r0, #11]

  // update dot dot if directory
  if (dirCluster) {
    66b2:	cmp	r7, #0
    66b4:	beq.n	6728 <FatFile::rename(FatFile*, char const*)+0x16e>
    // get new dot dot
    uint32_t sector = m_vol->clusterStartSector(dirCluster);
    66b6:	ldr	r0, [r4, #8]
    66b8:	ldrb	r1, [r0, #6]
    66ba:	subs	r3, r7, #2
    66bc:	lsls	r3, r1
    66be:	ldr	r1, [r0, #20]
    66c0:	movs	r2, #0
    66c2:	add	r1, r3
    66c4:	adds	r0, #40	; 0x28
    66c6:	bl	388e <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    66ca:	cmp	r0, #0
    66cc:	beq.n	65e8 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&entry, &pc->dir[1], sizeof(entry));
    66ce:	add.w	r3, r0, #32
    66d2:	mov	lr, r5
    66d4:	add.w	ip, r0, #64	; 0x40
    66d8:	ldr	r0, [r3, #0]
    66da:	ldr	r1, [r3, #4]
    66dc:	mov	r2, lr
    66de:	stmia	r2!, {r0, r1}
    66e0:	adds	r3, #8
    66e2:	cmp	r3, ip
    66e4:	mov	lr, r2
    66e6:	bne.n	66d8 <FatFile::rename(FatFile*, char const*)+0x11e>

    // free unused cluster
    if (!m_vol->freeChain(dirCluster)) {
    66e8:	mov	r1, r7
    66ea:	ldr	r0, [r4, #8]
    66ec:	bl	6be6 <FatPartition::freeChain(unsigned long)>
    66f0:	cmp	r0, #0
    66f2:	beq.w	65e8 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // store new dot dot
    sector = m_vol->clusterStartSector(m_firstCluster);
    66f6:	ldr	r0, [r4, #8]
    66f8:	ldr	r1, [r4, #32]
    66fa:	ldrb	r3, [r0, #6]
    66fc:	subs	r1, #2
    66fe:	lsls	r1, r3
    6700:	ldr	r3, [r0, #20]
    6702:	movs	r2, #1
    6704:	add	r1, r3
    6706:	adds	r0, #40	; 0x28
    6708:	bl	388e <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    670c:	cmp	r0, #0
    670e:	beq.w	65e8 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&pc->dir[1], &entry, sizeof(entry));
    6712:	add.w	r3, r0, #32
    6716:	mov	r2, r5
    6718:	ldmia	r2!, {r0, r1}
    671a:	cmp	r2, r6
    671c:	str	r0, [r3, #0]
    671e:	str	r1, [r3, #4]
    6720:	mov	r5, r2
    6722:	add.w	r3, r3, #8
    6726:	bne.n	6716 <FatFile::rename(FatFile*, char const*)+0x15c>
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    6728:	movs	r3, #0
    672a:	str	r3, [sp, #100]	; 0x64
  oldFile.m_flags = FILE_FLAG_WRITE;
    672c:	movs	r3, #2
    672e:	strb.w	r3, [sp, #70]	; 0x46
  oldFile.m_attributes = FILE_ATTR_FILE;
  if (!oldFile.remove()) {
    6732:	add	r0, sp, #68	; 0x44
    memcpy(&pc->dir[1], &entry, sizeof(entry));
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
    6734:	movs	r3, #8
    6736:	strb.w	r3, [sp, #68]	; 0x44
  if (!oldFile.remove()) {
    673a:	bl	7408 <FatFile::remove()>
    673e:	cmp	r0, #0
    6740:	beq.w	65e8 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return m_vol->cacheSync();
    6744:	ldr	r0, [r4, #8]
    6746:	bl	5cc8 <FatPartition::cacheSync()>

 fail:
  return false;
}
    674a:	add	sp, #108	; 0x6c
    674c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00006750 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    6750:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6754:	mov	r4, r3
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    6756:	ldrb	r3, [r0, #0]
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    6758:	ldrb.w	fp, [sp, #40]	; 0x28
    675c:	ldrb.w	r9, [sp, #44]	; 0x2c
    6760:	ldrb.w	sl, [sp, #48]	; 0x30
    6764:	ldrb.w	r5, [sp, #52]	; 0x34
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    6768:	lsls	r3, r3, #28
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    676a:	mov	r6, r0
    676c:	mov	r7, r1
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    676e:	bmi.n	6776 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x26>
    setLe16(dir->modifyTime, dirTime);
  }
  return m_vol->cacheSync();

 fail:
  return false;
    6770:	movs	r0, #0
    6772:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint16_t dirDate;
  uint16_t dirTime;
  DirFat_t* dir;

  if (!isFile()
      || year < 1980
    6776:	subw	r2, r2, #1980	; 0x7bc
    677a:	uxth.w	r8, r2
    677e:	cmp.w	r8, #127	; 0x7f
    6782:	bhi.n	6770 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || year > 2107
      || month < 1
    6784:	subs	r3, r4, #1
    6786:	cmp	r3, #11
    6788:	bhi.n	6770 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || month > 12
      || day < 1
    678a:	add.w	r3, fp, #4294967295
    678e:	cmp	r3, #30
    6790:	bhi.n	6770 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || day > 31
      || hour > 23
    6792:	cmp.w	r9, #23
    6796:	bhi.n	6770 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || minute > 59
    6798:	cmp.w	sl, #59	; 0x3b
    679c:	bhi.n	6770 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || second > 59) {
    679e:	cmp	r5, #59	; 0x3b
    67a0:	bhi.n	6770 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // update directory entry
  if (!sync()) {
    67a2:	bl	625c <FatFile::sync()>
    67a6:	cmp	r0, #0
    67a8:	beq.n	6770 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
    DBG_FAIL_MACRO;
    goto fail;
  }
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    67aa:	movs	r1, #1
    67ac:	mov	r0, r6
    67ae:	bl	5db0 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    67b2:	cmp	r0, #0
    67b4:	beq.n	6770 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    67b6:	orr.w	r4, fp, r4, lsl #5
    67ba:	orr.w	r8, r4, r8, lsl #9
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    67be:	asrs	r3, r5, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  dirDate = FS_DATE(year, month, day);
  dirTime = FS_TIME(hour, minute, second);
  if (flags & T_ACCESS) {
    67c0:	lsls	r4, r7, #31
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    67c2:	uxth.w	r8, r8
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    67c6:	orr.w	r3, r3, sl, lsl #5
    67ca:	orr.w	r3, r3, r9, lsl #11
    67ce:	it	mi
    67d0:	strhmi.w	r8, [r0, #18]
    setLe16(dir->accessDate, dirDate);
  }
  if (flags & T_CREATE) {
    67d4:	lsls	r1, r7, #30
    67d6:	uxth	r3, r3
    67d8:	bpl.n	67ea <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x9a>
    setLe16(dir->createDate, dirDate);
    setLe16(dir->createTime, dirTime);
    // units of 10 ms
    dir->createTimeMs = second & 1 ? 100 : 0;
    67da:	ands.w	r5, r5, #1
    67de:	it	ne
    67e0:	movne	r5, #100	; 0x64
    67e2:	strh.w	r8, [r0, #16]
    67e6:	strh	r3, [r0, #14]
    67e8:	strb	r5, [r0, #13]
  }
  if (flags & T_WRITE) {
    67ea:	lsls	r2, r7, #29
    67ec:	itt	mi
    67ee:	strhmi.w	r8, [r0, #24]
    67f2:	strhmi	r3, [r0, #22]
    setLe16(dir->modifyDate, dirDate);
    setLe16(dir->modifyTime, dirTime);
  }
  return m_vol->cacheSync();
    67f4:	ldr	r0, [r6, #8]
    67f6:	bl	5cc8 <FatPartition::cacheSync()>
    67fa:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

000067fe <FatFile::truncate()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    67fe:	push	{r0, r1, r4, lr}
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    6800:	ldrb	r3, [r0, #2]
    6802:	lsls	r3, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    6804:	mov	r4, r0
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    6806:	bmi.n	680c <FatFile::truncate()+0xe>
  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    6808:	movs	r0, #0
    680a:	b.n	6862 <FatFile::truncate()+0x64>
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    680c:	ldr	r3, [r0, #32]
    680e:	cbz	r3, 6860 <FatFile::truncate()+0x62>
      return true;
  }
  if (m_curCluster) {
    6810:	ldr	r1, [r0, #16]
    6812:	cbz	r1, 6838 <FatFile::truncate()+0x3a>
    toFree = 0;
    6814:	add	r2, sp, #8
    6816:	movs	r3, #0
    6818:	str.w	r3, [r2, #-4]!
    int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    681c:	ldr	r0, [r0, #8]
    681e:	bl	6aa0 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    6822:	cmp	r0, #0
    6824:	blt.n	6808 <FatFile::truncate()+0xa>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg) {
    6826:	beq.n	683c <FatFile::truncate()+0x3e>
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    6828:	mvn.w	r2, #4026531840	; 0xf0000000
    682c:	ldr	r1, [r4, #16]
    682e:	ldr	r0, [r4, #8]
    6830:	bl	6b0a <FatPartition::fatPut(unsigned long, unsigned long)>
      // current cluster is end of chain
      if (!m_vol->fatPutEOC(m_curCluster)) {
    6834:	cbnz	r0, 683c <FatFile::truncate()+0x3e>
    6836:	b.n	6808 <FatFile::truncate()+0xa>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  } else {
    toFree = m_firstCluster;
    6838:	str	r3, [sp, #4]
    m_firstCluster = 0;
    683a:	str	r1, [r0, #32]
  }
  if (toFree) {
    683c:	ldr	r1, [sp, #4]
    683e:	cbnz	r1, 6854 <FatFile::truncate()+0x56>
    if (!m_vol->freeChain(toFree)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_fileSize = m_curPosition;
    6840:	ldr	r3, [r4, #20]
    6842:	str	r3, [r4, #28]

  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
    6844:	ldrb	r3, [r4, #2]
    6846:	orn	r3, r3, #127	; 0x7f
    684a:	strb	r3, [r4, #2]
  return sync();
    684c:	mov	r0, r4
    684e:	bl	625c <FatFile::sync()>
    6852:	b.n	6862 <FatFile::truncate()+0x64>
  } else {
    toFree = m_firstCluster;
    m_firstCluster = 0;
  }
  if (toFree) {
    if (!m_vol->freeChain(toFree)) {
    6854:	ldr	r0, [r4, #8]
    6856:	bl	6be6 <FatPartition::freeChain(unsigned long)>
    685a:	cmp	r0, #0
    685c:	bne.n	6840 <FatFile::truncate()+0x42>
    685e:	b.n	6808 <FatFile::truncate()+0xa>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    6860:	movs	r0, #1
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    6862:	add	sp, #8
    6864:	pop	{r4, pc}
    6866:	Address 0x00006866 is out of bounds.


00006868 <FatFile::write(void const*, unsigned int)>:
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    6868:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    686c:	ldrb	r3, [r0, #2]
    686e:	mov	r9, r1
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    6870:	lsls	r1, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    6872:	mov	r4, r0
    6874:	mov	r5, r2
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    6876:	bpl.w	6996 <FatFile::write(void const*, unsigned int)+0x12e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    687a:	lsls	r2, r3, #28
    687c:	bmi.n	6894 <FatFile::write(void const*, unsigned int)+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    687e:	ldr	r3, [r4, #20]
    6880:	mvns	r3, r3
    6882:	cmp	r5, r3
    6884:	bhi.w	6996 <FatFile::write(void const*, unsigned int)+0x12e>
    6888:	mov	r7, r5
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    688a:	mov.w	sl, #0
    m_sector = 0XFFFFFFFF;
    688e:	mov.w	fp, #4294967295
    6892:	b.n	6922 <FatFile::write(void const*, unsigned int)+0xba>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_fileSize)) {
    6894:	ldr	r1, [r0, #28]
    6896:	bl	6006 <FatFile::seekSet(unsigned long)>
    689a:	cmp	r0, #0
    689c:	bne.n	687e <FatFile::write(void const*, unsigned int)+0x16>
    689e:	b.n	6996 <FatFile::write(void const*, unsigned int)+0x12e>
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    68a0:	ldr	r0, [r4, #8]
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    68a2:	ldrb	r6, [r0, #5]
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    68a4:	ands.w	r6, r6, r2, lsr #9
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    68a8:	ubfx	r8, r2, #0, #9
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    68ac:	beq.n	692a <FatFile::write(void const*, unsigned int)+0xc2>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
    68ae:	ldr.w	lr, [r4, #8]
                      + sectorOfCluster;
    68b2:	ldr	r1, [r4, #16]
    68b4:	ldrb.w	r3, [lr, #6]
    68b8:	subs	r1, #2
    68ba:	lsls	r1, r3
    68bc:	ldr.w	r3, [lr, #20]
    68c0:	add	r1, r3
    68c2:	add	r1, r6

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
    68c4:	cmp.w	r8, #0
    68c8:	bne.n	695c <FatFile::write(void const*, unsigned int)+0xf4>
    68ca:	cmp.w	r7, #512	; 0x200
    68ce:	bcs.n	69aa <FatFile::write(void const*, unsigned int)+0x142>
      // lesser of space and amount to write
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (sectorOffset == 0 &&
    68d0:	ldr	r2, [r4, #20]
    68d2:	ldr	r3, [r4, #28]
    68d4:	cmp	r2, r3
    68d6:	bcs.n	6960 <FatFile::write(void const*, unsigned int)+0xf8>
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
    68d8:	ldrb	r3, [r4, #2]
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    68da:	tst.w	r3, #32
    68de:	ite	eq
    68e0:	moveq	r2, #1
    68e2:	movne	r2, #5
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    68e4:	add.w	r0, lr, #40	; 0x28
    68e8:	bl	388e <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      pc = m_vol->cacheFetchData(sector, cacheOption);
      if (!pc) {
    68ec:	cmp	r0, #0
    68ee:	beq.n	6996 <FatFile::write(void const*, unsigned int)+0x12e>
                      + sectorOfCluster;

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    68f0:	rsb	r6, r8, #512	; 0x200
    68f4:	cmp	r6, r7
    68f6:	it	cs
    68f8:	movcs	r6, r7
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    68fa:	add	r0, r8
    68fc:	mov	r2, r6
    68fe:	mov	r1, r9
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    6900:	add	r8, r6
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    6902:	bl	8f3c <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    6906:	cmp.w	r8, #512	; 0x200
    690a:	bne.n	6918 <FatFile::write(void const*, unsigned int)+0xb0>
  }
  void cacheInvalidate() {
    m_cache.invalidate();
  }
  bool cacheSyncData() {
    return m_cache.sync();
    690c:	ldr	r0, [r4, #8]
    690e:	adds	r0, #40	; 0x28
    6910:	bl	3842 <FsCache::sync()>
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
      if (nSector > maxSectors) {
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeWrite(sector, src, nSector)) {
    6914:	cmp	r0, #0
    6916:	beq.n	6996 <FatFile::write(void const*, unsigned int)+0x12e>
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    6918:	ldr	r3, [r4, #20]
    691a:	add	r3, r6
    691c:	str	r3, [r4, #20]
    src += n;
    691e:	add	r9, r6
    nToWrite -= n;
    6920:	subs	r7, r7, r6
    6922:	ldr	r2, [r4, #20]
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    6924:	cmp	r7, #0
    6926:	bne.n	68a0 <FatFile::write(void const*, unsigned int)+0x38>
    6928:	b.n	6964 <FatFile::write(void const*, unsigned int)+0xfc>
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    692a:	cmp.w	r8, #0
    692e:	bne.n	68ae <FatFile::write(void const*, unsigned int)+0x46>
      // start of new cluster
      if (m_curCluster != 0) {
    6930:	ldr	r1, [r4, #16]
    6932:	cbz	r1, 6946 <FatFile::write(void const*, unsigned int)+0xde>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
    6934:	ldrb	r3, [r4, #2]
    6936:	lsls	r3, r3, #25
    6938:	bpl.n	697e <FatFile::write(void const*, unsigned int)+0x116>
    693a:	ldr	r3, [r4, #28]
    693c:	cmp	r2, r3
    693e:	bcs.n	697e <FatFile::write(void const*, unsigned int)+0x116>
          m_curCluster++;
    6940:	adds	r1, #1
    6942:	str	r1, [r4, #16]
    6944:	b.n	68ae <FatFile::write(void const*, unsigned int)+0x46>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    6946:	ldr	r3, [r4, #32]
    6948:	cbnz	r3, 6958 <FatFile::write(void const*, unsigned int)+0xf0>
          // allocate first cluster of file
          if (!addCluster()) {
    694a:	mov	r0, r4
    694c:	bl	5cee <FatFile::addCluster()>
    6950:	cbz	r0, 6996 <FatFile::write(void const*, unsigned int)+0x12e>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    6952:	ldr	r3, [r4, #16]
    6954:	str	r3, [r4, #32]
    6956:	b.n	68ae <FatFile::write(void const*, unsigned int)+0x46>
        } else {
          m_curCluster = m_firstCluster;
    6958:	str	r3, [r4, #16]
    695a:	b.n	68ae <FatFile::write(void const*, unsigned int)+0x46>
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    695c:	movs	r2, #1
    695e:	b.n	68e4 <FatFile::write(void const*, unsigned int)+0x7c>
      }

      if (sectorOffset == 0 &&
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    6960:	movs	r2, #5
    6962:	b.n	68e4 <FatFile::write(void const*, unsigned int)+0x7c>
    }
    m_curPosition += n;
    src += n;
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    6964:	ldr	r3, [r4, #28]
    6966:	cmp	r2, r3
    6968:	bls.n	696e <FatFile::write(void const*, unsigned int)+0x106>
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    696a:	str	r2, [r4, #28]
    696c:	b.n	6974 <FatFile::write(void const*, unsigned int)+0x10c>
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    696e:	ldr	r3, [pc, #180]	; (6a24 <FatFile::write(void const*, unsigned int)+0x1bc>)
    6970:	ldr	r3, [r3, #0]
    6972:	cbz	r3, 69a4 <FatFile::write(void const*, unsigned int)+0x13c>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    6974:	ldrb	r3, [r4, #2]
    6976:	orn	r3, r3, #127	; 0x7f
    697a:	strb	r3, [r4, #2]
    697c:	b.n	69a4 <FatFile::write(void const*, unsigned int)+0x13c>
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
          m_curCluster++;
          fg = 1;
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    697e:	add.w	r2, r4, #16
    6982:	bl	6aa0 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    6986:	cmp	r0, #0
    6988:	blt.n	6996 <FatFile::write(void const*, unsigned int)+0x12e>
        if (fg < 0) {
          DBG_FAIL_MACRO;
          goto fail;
        }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        if (fg == 0) {
    698a:	bne.n	6a0c <FatFile::write(void const*, unsigned int)+0x1a4>
          // add cluster if at end of chain
          if (!addCluster()) {
    698c:	mov	r0, r4
    698e:	bl	5cee <FatFile::addCluster()>
    6992:	cmp	r0, #0
    6994:	bne.n	6a0c <FatFile::write(void const*, unsigned int)+0x1a4>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    6996:	ldrb	r3, [r4, #1]
    6998:	orr.w	r3, r3, #1
    699c:	strb	r3, [r4, #1]
  return 0;
    699e:	movs	r0, #0
    69a0:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    69a4:	mov	r0, r5
    69a6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (nToWrite >= 2*m_vol->bytesPerSector()) {
    69aa:	cmp.w	r7, #1024	; 0x400
    69ae:	ldr.w	r2, [lr, #52]	; 0x34
    69b2:	ldr.w	r0, [lr, #44]	; 0x2c
    69b6:	bcc.n	69e2 <FatFile::write(void const*, unsigned int)+0x17a>
      // use multiple sector write command
      uint32_t maxSectors = m_vol->sectorsPerCluster() - sectorOfCluster;
    69b8:	ldrb.w	r3, [lr, #4]
    69bc:	subs	r6, r3, r6
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
    69be:	lsrs	r3, r7, #9
    69c0:	cmp	r3, r6
    69c2:	it	cs
    69c4:	movcs	r3, r6
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    69c6:	cmp	r2, r1
      if (nSector > maxSectors) {
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
    69c8:	mov.w	r6, r3, lsl #9
    69cc:	bcc.n	69d6 <FatFile::write(void const*, unsigned int)+0x16e>
    69ce:	add.w	ip, r3, r1
    69d2:	cmp	r2, ip
    69d4:	bcc.n	6a02 <FatFile::write(void const*, unsigned int)+0x19a>
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    69d6:	ldr	r2, [r0, #0]
    69d8:	ldr.w	r8, [r2, #36]	; 0x24
    69dc:	mov	r2, r9
    69de:	blx	r8
    69e0:	b.n	6914 <FatFile::write(void const*, unsigned int)+0xac>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    69e2:	cmp	r2, r1
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    69e4:	it	eq
    69e6:	strbeq.w	sl, [lr, #40]	; 0x28
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    69ea:	ldr	r3, [r0, #0]
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    69ec:	it	eq
    69ee:	streq.w	fp, [lr, #52]	; 0x34
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    69f2:	ldr	r3, [r3, #32]
    69f4:	mov	r2, r9
    69f6:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    69f8:	cmp	r0, #0
    69fa:	beq.n	6996 <FatFile::write(void const*, unsigned int)+0x12e>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
    69fc:	mov.w	r6, #512	; 0x200
    6a00:	b.n	6918 <FatFile::write(void const*, unsigned int)+0xb0>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6a02:	strb.w	sl, [lr, #40]	; 0x28
    m_sector = 0XFFFFFFFF;
    6a06:	str.w	fp, [lr, #52]	; 0x34
    6a0a:	b.n	69d6 <FatFile::write(void const*, unsigned int)+0x16e>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
    6a0c:	ldr.w	lr, [r4, #8]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    6a10:	ldr	r1, [r4, #16]
    6a12:	ldrb.w	r3, [lr, #6]
    6a16:	subs	r1, #2
    6a18:	lsls	r1, r3
    6a1a:	ldr.w	r3, [lr, #20]
    6a1e:	add	r1, r3
    6a20:	b.n	68ca <FatFile::write(void const*, unsigned int)+0x62>
    6a22:	nop
    6a24:	.word	0x2001a690

00006a28 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)>:

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat16(uint32_t sector, uint8_t *buf, void *context) {
   struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint16_t *p = (uint16_t *)buf;
  unsigned int n = state->clusters_to_do;
    6a28:	ldr	r3, [r2, #0]
    6a2a:	cmp.w	r3, #256	; 0x100
  uint32_t clusters_to_do;
  uint32_t free_count;
};

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat16(uint32_t sector, uint8_t *buf, void *context) {
    6a2e:	push	{r4, r5, lr}
    6a30:	mov	r4, r3
    6a32:	it	cs
    6a34:	movcs.w	r4, #256	; 0x100
   struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint16_t *p = (uint16_t *)buf;
  unsigned int n = state->clusters_to_do;
  if (n > 256) n = 256;
  uint16_t *e = p + n;
    6a38:	add.w	r5, r1, r4, lsl #1
  while (p < e) {
    6a3c:	cmp	r1, r5
    6a3e:	bcs.n	6a50 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x28>
    if (*p++ == 0) state->free_count++;
    6a40:	ldrh.w	r0, [r1], #2
    6a44:	cmp	r0, #0
    6a46:	bne.n	6a3c <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x14>
    6a48:	ldr	r0, [r2, #4]
    6a4a:	adds	r0, #1
    6a4c:	str	r0, [r2, #4]
    6a4e:	b.n	6a3c <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x14>
  }
  state->clusters_to_do -= n;
    6a50:	subs	r3, r3, r4
    6a52:	str	r3, [r2, #0]
    6a54:	pop	{r4, r5, pc}

00006a56 <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)>:

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat32(uint32_t sector, uint8_t *buf, void *context) {
  struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint32_t *p = (uint32_t *)buf;
  unsigned int n = state->clusters_to_do;
    6a56:	ldr	r3, [r2, #0]
    6a58:	cmp	r3, #128	; 0x80
  }
  state->clusters_to_do -= n;
}

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat32(uint32_t sector, uint8_t *buf, void *context) {
    6a5a:	push	{r4, r5, lr}
    6a5c:	mov	r4, r3
    6a5e:	it	cs
    6a60:	movcs	r4, #128	; 0x80
  struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint32_t *p = (uint32_t *)buf;
  unsigned int n = state->clusters_to_do;
  if (n > 128) n = 128;
  uint32_t *e = p + n;
    6a62:	add.w	r5, r1, r4, lsl #2
  while (p < e) {
    6a66:	cmp	r1, r5
    6a68:	bcs.n	6a7a <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x24>
    if (*p++ == 0) state->free_count++;
    6a6a:	ldr.w	r0, [r1], #4
    6a6e:	cmp	r0, #0
    6a70:	bne.n	6a66 <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x10>
    6a72:	ldr	r0, [r2, #4]
    6a74:	adds	r0, #1
    6a76:	str	r0, [r2, #4]
    6a78:	b.n	6a66 <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x10>
  }
  state->clusters_to_do -= n;
    6a7a:	subs	r3, r3, r4
    6a7c:	str	r3, [r2, #0]
    6a7e:	pop	{r4, r5, pc}

00006a80 <FsCache::clear()>:
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    6a80:	push	{r4, lr}
    if (isDirty() && !sync()) {
    6a82:	ldrb	r3, [r0, #0]
    6a84:	lsls	r3, r3, #31
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    6a86:	mov	r4, r0
    if (isDirty() && !sync()) {
    6a88:	bpl.n	6a90 <FsCache::clear()+0x10>
    6a8a:	bl	3842 <FsCache::sync()>
    6a8e:	cbz	r0, 6a9e <FsCache::clear()+0x1e>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6a90:	movs	r3, #0
    6a92:	strb	r3, [r4, #0]
    m_sector = 0XFFFFFFFF;
    6a94:	mov.w	r3, #4294967295
    6a98:	str	r3, [r4, #12]
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    6a9a:	add.w	r0, r4, #16
  }
    6a9e:	pop	{r4, pc}

00006aa0 <FatPartition::fatGet(unsigned long, unsigned long*)>:
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6aa0:	cmp	r1, #1
 fail:
  return false;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry - return -1 error, 0 EOC, else 1.
int8_t FatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    6aa2:	push	{r4, r5, r6, lr}
    6aa4:	mov	r5, r0
    6aa6:	mov	r4, r1
    6aa8:	mov	r6, r2
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6aaa:	bhi.n	6ab2 <FatPartition::fatGet(unsigned long, unsigned long*)+0x12>
  }
  *value = next;
  return 1;

 fail:
  return -1;
    6aac:	mov.w	r0, #4294967295
    6ab0:	pop	{r4, r5, r6, pc}
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6ab2:	ldr	r3, [r0, #28]
    6ab4:	cmp	r1, r3
    6ab6:	bhi.n	6aac <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
    6ab8:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    6aba:	cmp	r3, #32
    6abc:	bne.n	6adc <FatPartition::fatGet(unsigned long, unsigned long*)+0x3c>
  FsCache m_cache;
#if USE_SEPARATE_FAT_CACHE
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
    6abe:	ldr	r1, [r0, #24]
    6ac0:	movs	r2, #2
    6ac2:	add.w	r1, r1, r4, lsr #7
    6ac6:	add.w	r0, r0, #568	; 0x238
    6aca:	bl	388e <FsCache::get(unsigned long, unsigned char)>
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    6ace:	cmp	r0, #0
    6ad0:	beq.n	6aac <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    6ad2:	and.w	r4, r4, #127	; 0x7f
    6ad6:	ldr.w	r3, [r0, r4, lsl #2]
    6ada:	b.n	6afc <FatPartition::fatGet(unsigned long, unsigned long*)+0x5c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe32(reinterpret_cast<uint8_t*>
                  (&pc->fat32[cluster & (m_sectorMask >> 2)]));
  } else if (fatType() == 16) {
    6adc:	cmp	r3, #16
    6ade:	bne.n	6aac <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
    6ae0:	ldr	r3, [r0, #24]
    6ae2:	ubfx	r1, r1, #8, #8
    6ae6:	movs	r2, #2
    6ae8:	add	r1, r3
    6aea:	add.w	r0, r0, #568	; 0x238
    6aee:	bl	388e <FsCache::get(unsigned long, unsigned char)>
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    6af2:	cmp	r0, #0
    6af4:	beq.n	6aac <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    6af6:	uxtb	r4, r4
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe16(reinterpret_cast<uint8_t*>
                  (&pc->fat16[cluster & (m_sectorMask >> 1)]));
    6af8:	ldrh.w	r3, [r0, r4, lsl #1]
    next = cluster & 1 ? tmp >> 4 : tmp & 0XFFF;
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    6afc:	ldr	r2, [r5, #28]
    6afe:	cmp	r3, r2
    return 0;
  }
  *value = next;
  return 1;
    6b00:	itte	ls
    6b02:	movls	r0, #1
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
  }
  *value = next;
    6b04:	strls	r3, [r6, #0]
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
    6b06:	movhi	r0, #0
  *value = next;
  return 1;

 fail:
  return -1;
}
    6b08:	pop	{r4, r5, r6, pc}

00006b0a <FatPartition::fatPut(unsigned long, unsigned long)>:
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6b0a:	cmp	r1, #1
 fail:
  return -1;
}
//------------------------------------------------------------------------------
// Store a FAT entry
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
    6b0c:	push	{r3, r4, r5, lr}
    6b0e:	mov	r4, r1
    6b10:	mov	r5, r2
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6b12:	bhi.n	6b18 <FatPartition::fatPut(unsigned long, unsigned long)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }

 fail:
  return false;
    6b14:	movs	r0, #0
    6b16:	pop	{r3, r4, r5, pc}
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6b18:	ldr	r3, [r0, #28]
    6b1a:	cmp	r1, r3
    6b1c:	bhi.n	6b14 <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
    6b1e:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    6b20:	cmp	r3, #32
    6b22:	bne.n	6b42 <FatPartition::fatPut(unsigned long, unsigned long)+0x38>
    6b24:	ldr	r1, [r0, #24]
    6b26:	movs	r2, #3
    6b28:	add.w	r1, r1, r4, lsr #7
    6b2c:	add.w	r0, r0, #568	; 0x238
    6b30:	bl	388e <FsCache::get(unsigned long, unsigned char)>
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    6b34:	cmp	r0, #0
    6b36:	beq.n	6b14 <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    6b38:	and.w	r4, r4, #127	; 0x7f
    6b3c:	str.w	r5, [r0, r4, lsl #2]
    6b40:	b.n	6b62 <FatPartition::fatPut(unsigned long, unsigned long)+0x58>
    setLe32(reinterpret_cast<uint8_t*>
           (&pc->fat32[cluster & (m_sectorMask >> 2)]), value);
    return true;
  }

  if (fatType() == 16) {
    6b42:	cmp	r3, #16
    6b44:	bne.n	6b14 <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
    6b46:	ldr	r3, [r0, #24]
    6b48:	ubfx	r1, r1, #8, #8
    6b4c:	movs	r2, #3
    6b4e:	add	r1, r3
    6b50:	add.w	r0, r0, #568	; 0x238
    6b54:	bl	388e <FsCache::get(unsigned long, unsigned char)>
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    6b58:	cmp	r0, #0
    6b5a:	beq.n	6b14 <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    6b5c:	uxtb	r4, r4
    6b5e:	strh.w	r5, [r0, r4, lsl #1]
      DBG_FAIL_MACRO;
      goto fail;
    }
    setLe16(reinterpret_cast<uint8_t*>
           (&pc->fat16[cluster & (m_sectorMask >> 1)]), value);
    return true;
    6b62:	movs	r0, #1
    goto fail;
  }

 fail:
  return false;
}
    6b64:	pop	{r3, r4, r5, pc}

00006b66 <FatPartition::allocateCluster(unsigned long, unsigned long*)>:
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"
#include "FatPartition.h"

//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    6b66:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    6b6a:	ldr	r4, [r0, #12]
    6b6c:	cmp	r4, r1
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"
#include "FatPartition.h"

//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    6b6e:	mov	r5, r0
    6b70:	mov	r6, r1
    6b72:	mov	r8, r2
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    6b74:	bcs.n	6b86 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x20>
    6b76:	mov	r4, r1
    // Try to keep file contiguous. Start just after current cluster.
    find = current;
    setStart = false;
    6b78:	movs	r7, #0
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    if (find > m_lastCluster) {
    6b7a:	ldr	r3, [r5, #28]
  } else {
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    6b7c:	adds	r4, #1
    if (find > m_lastCluster) {
    6b7e:	cmp	r4, r3
    6b80:	bls.n	6b8a <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x24>
      if (setStart) {
    6b82:	cbnz	r7, 6bb8 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
        // Can't find space, checked all clusters.
        DBG_FAIL_MACRO;
        goto fail;
      }
      find = m_allocSearchStart;
    6b84:	ldr	r4, [r5, #12]
      setStart = true;
    6b86:	movs	r7, #1
    6b88:	b.n	6b7a <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
      continue;
    }
    if (find == current) {
    6b8a:	cmp	r6, r4
    6b8c:	beq.n	6bb8 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    6b8e:	add	r2, sp, #4
    6b90:	mov	r1, r4
    6b92:	mov	r0, r5
    6b94:	bl	6aa0 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    6b98:	cmp	r0, #0
    6b9a:	blt.n	6bb8 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg && f == 0) {
    6b9c:	beq.n	6b7a <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
    6b9e:	ldr	r3, [sp, #4]
    6ba0:	cmp	r3, #0
    6ba2:	bne.n	6b7a <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
      break;
    }
  }
  if (setStart) {
    6ba4:	cbz	r7, 6ba8 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x42>
    m_allocSearchStart = find;
    6ba6:	str	r4, [r5, #12]
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    6ba8:	mvn.w	r2, #4026531840	; 0xf0000000
    6bac:	mov	r1, r4
    6bae:	mov	r0, r5
    6bb0:	bl	6b0a <FatPartition::fatPut(unsigned long, unsigned long)>
  }
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    6bb4:	mov	r7, r0
    6bb6:	cbnz	r0, 6bbc <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x56>
  updateFreeClusterCount(-1);
  *next = find;
  return true;

 fail:
  return false;
    6bb8:	movs	r7, #0
    6bba:	b.n	6bde <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
    6bbc:	cbnz	r6, 6bca <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x64>
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
  }
  void updateFreeClusterCount(int32_t change) {
    if (m_freeClusterCount >= 0) {
    6bbe:	ldr	r3, [r5, #36]	; 0x24
    6bc0:	cmp	r3, #0
    6bc2:	blt.n	6bda <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x74>
      m_freeClusterCount += change;
    6bc4:	subs	r3, #1
    6bc6:	str	r3, [r5, #36]	; 0x24
    6bc8:	b.n	6bda <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x74>
    // Link clusters.
    if (!fatPut(current, find)) {
    6bca:	mov	r2, r4
    6bcc:	mov	r1, r6
    6bce:	mov	r0, r5
    6bd0:	bl	6b0a <FatPartition::fatPut(unsigned long, unsigned long)>
    6bd4:	cmp	r0, #0
    6bd6:	bne.n	6bbe <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x58>
    6bd8:	b.n	6bb8 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  updateFreeClusterCount(-1);
  *next = find;
    6bda:	str.w	r4, [r8]
  return true;

 fail:
  return false;
}
    6bde:	mov	r0, r7
    6be0:	add	sp, #8
    6be2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00006be6 <FatPartition::freeChain(unsigned long)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
    6be6:	push	{r0, r1, r4, r5, r6, lr}
    6be8:	mov	r5, r0
    6bea:	mov	r4, r1
  uint32_t next;
  int8_t fg;
  do {
    fg = fatGet(cluster, &next);
    6bec:	add	r2, sp, #4
    6bee:	mov	r1, r4
    6bf0:	mov	r0, r5
    6bf2:	bl	6aa0 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    6bf6:	subs	r6, r0, #0
    6bf8:	bge.n	6bfe <FatPartition::freeChain(unsigned long)+0x18>
  } while (fg);

  return true;

 fail:
  return false;
    6bfa:	movs	r0, #0
    6bfc:	b.n	6c28 <FatPartition::freeChain(unsigned long)+0x42>
    if (fg < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
    6bfe:	movs	r2, #0
    6c00:	mov	r1, r4
    6c02:	mov	r0, r5
    6c04:	bl	6b0a <FatPartition::fatPut(unsigned long, unsigned long)>
    6c08:	cmp	r0, #0
    6c0a:	beq.n	6bfa <FatPartition::freeChain(unsigned long)+0x14>
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
  }
  void updateFreeClusterCount(int32_t change) {
    if (m_freeClusterCount >= 0) {
    6c0c:	ldr	r3, [r5, #36]	; 0x24
    6c0e:	cmp	r3, #0
      m_freeClusterCount += change;
    6c10:	itt	ge
    6c12:	addge	r3, #1
    6c14:	strge	r3, [r5, #36]	; 0x24
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Add one to count of free clusters.
    updateFreeClusterCount(1);
    if (cluster < m_allocSearchStart) {
    6c16:	ldr	r3, [r5, #12]
    6c18:	cmp	r4, r3
      m_allocSearchStart = cluster - 1;
    6c1a:	itt	cc
    6c1c:	addcc.w	r4, r4, #4294967295
    6c20:	strcc	r4, [r5, #12]
    }
    cluster = next;
    6c22:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  int8_t fg;
  do {
    6c24:	cmp	r6, #0
    6c26:	bne.n	6bec <FatPartition::freeChain(unsigned long)+0x6>

  return true;

 fail:
  return false;
}
    6c28:	add	sp, #8
    6c2a:	pop	{r4, r5, r6, pc}

00006c2c <FatPartition::freeClusterCount()>:
  }
  state->clusters_to_do -= n;
}

//------------------------------------------------------------------------------
int32_t FatPartition::freeClusterCount() {
    6c2c:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    6c2e:	mov	r4, r0
#if MAINTAIN_FREE_CLUSTER_COUNT
  if (m_freeClusterCount >= 0) {
    6c30:	ldr	r0, [r0, #36]	; 0x24
    6c32:	cmp	r0, #0
    6c34:	bge.n	6c7a <FatPartition::freeClusterCount()+0x4e>
    return free;
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
    6c36:	movs	r3, #0
    6c38:	str	r3, [sp, #12]
  state.clusters_to_do = m_lastCluster + 1;
    6c3a:	ldr	r3, [r4, #28]
  uint32_t num_sectors;

  //num_sectors = SD.sdfs.m_fVol->sectorsPerFat(); // edit FsVolume.h for public
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
    6c3c:	ldr	r5, [r4, #16]
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
  state.clusters_to_do = m_lastCluster + 1;
    6c3e:	adds	r3, #1
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
  //Serial.printf("  num_sectors = %u\n", num_sectors);
#if USE_SEPARATE_FAT_CACHE
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
    6c40:	add.w	r0, r4, #568	; 0x238
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
  state.clusters_to_do = m_lastCluster + 1;
    6c44:	str	r3, [sp, #8]
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
  //Serial.printf("  num_sectors = %u\n", num_sectors);
#if USE_SEPARATE_FAT_CACHE
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
    6c46:	bl	6a80 <FsCache::clear()>
#else  
  uint8_t *buf = m_cache.clear();  // will clear out anything and return buffer 
#endif  // USE_SEPARATE_FAT_CACHE
  if (buf == nullptr) return -1;
    6c4a:	mov	r2, r0
    6c4c:	cbnz	r0, 6c54 <FatPartition::freeClusterCount()+0x28>
    6c4e:	mov.w	r0, #4294967295
    6c52:	b.n	6c7a <FatPartition::freeClusterCount()+0x4e>
  if (fatType() == FAT_TYPE_FAT32) {
    6c54:	ldrb	r3, [r4, #7]
    6c56:	ldr	r0, [r4, #0]
    6c58:	cmp	r3, #32
    6c5a:	add	r3, sp, #8
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat32, &state)) return -1;
    6c5c:	ldr	r1, [r0, #0]
    6c5e:	str	r3, [sp, #4]
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
#else  
  uint8_t *buf = m_cache.clear();  // will clear out anything and return buffer 
#endif  // USE_SEPARATE_FAT_CACHE
  if (buf == nullptr) return -1;
  if (fatType() == FAT_TYPE_FAT32) {
    6c60:	bne.n	6c66 <FatPartition::freeClusterCount()+0x3a>
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat32, &state)) return -1;
    6c62:	ldr	r3, [pc, #28]	; (6c80 <FatPartition::freeClusterCount()+0x54>)
    6c64:	b.n	6c68 <FatPartition::freeClusterCount()+0x3c>
  } else {
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat16, &state)) return -1;
    6c66:	ldr	r3, [pc, #28]	; (6c84 <FatPartition::freeClusterCount()+0x58>)
    6c68:	str	r3, [sp, #0]
    6c6a:	ldr	r6, [r1, #20]
    6c6c:	ldr	r1, [r4, #24]
    6c6e:	mov	r3, r5
    6c70:	blx	r6
    6c72:	cmp	r0, #0
    6c74:	beq.n	6c4e <FatPartition::freeClusterCount()+0x22>
  }

  setFreeClusterCount(state.free_count);
    6c76:	ldr	r0, [sp, #12]
    return m_blockDev->writeSector(sector, src);
  }
#if MAINTAIN_FREE_CLUSTER_COUNT
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
    6c78:	str	r0, [r4, #36]	; 0x24
  return state.free_count;
}
    6c7a:	add	sp, #16
    6c7c:	pop	{r4, r5, r6, pc}
    6c7e:	nop
    6c80:	.word	0x00006a57
    6c84:	.word	0x00006a29

00006c88 <FatPartition::init(BlockDeviceInterface*, unsigned char)>:


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    6c88:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6c8c:	mov	r4, r0
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif

  uint8_t tmp;
  m_fatType = 0;
    6c8e:	movs	r7, #0
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    6c90:	mov.w	r3, #4294967295
  m_allocSearchStart = 1;
    6c94:	movs	r6, #1
  }
  /** Clear the cache and returns a pointer to the cache.  Not for normal apps.
   * \return A pointer to the cache buffer or zero if an error occurs.
   */
  uint8_t* cacheClear() {
    return m_cache.clear();
    6c96:	add.w	r8, r0, #40	; 0x28
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
//  Serial.printf(" FatPartition::init(%x %u)\n", (uint32_t)dev, part);
  uint32_t clusterCount;
  uint32_t totalSectors;
  uint32_t volumeStartSector = 0;
  m_blockDev = dev;
    6c9a:	str	r1, [r4, #0]
  return state.free_count;
}


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    6c9c:	sub	sp, #28
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif

  uint8_t tmp;
  m_fatType = 0;
    6c9e:	strb	r7, [r0, #7]
  m_allocSearchStart = 1;
    6ca0:	str	r6, [r0, #12]
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    6ca2:	str	r1, [r4, #44]	; 0x2c
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    6ca4:	str	r3, [r0, #52]	; 0x34
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6ca6:	strb.w	r7, [r0, #40]	; 0x28
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    6caa:	str.w	r1, [r4, #572]	; 0x23c
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    6cae:	str.w	r3, [r0, #580]	; 0x244
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6cb2:	strb.w	r7, [r0, #568]	; 0x238
    6cb6:	mov	r0, r8
  return state.free_count;
}


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    6cb8:	mov	r5, r1
    6cba:	mov	r9, r2
    6cbc:	bl	6a80 <FsCache::clear()>
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.init(dev);
#endif  // USE_SEPARATE_FAT_CACHE

  #if SUPPORT_GPT_AND_EXTENDED_PATITIONS 
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part, cacheClear(), &firstLBA);
    6cc0:	str	r7, [sp, #8]
    6cc2:	mov	r2, r0
    6cc4:	str	r7, [sp, #4]
    6cc6:	str	r7, [sp, #0]
    6cc8:	add	r3, sp, #20
    6cca:	mov	r1, r9
    6ccc:	mov	r0, r5
    6cce:	bl	3604 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    6cd2:	tst.w	r0, #251	; 0xfb
    6cd6:	beq.n	6d5c <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    DBG_FAIL_MACRO;
    goto fail;    
  }
  volumeStartSector = firstLBA;
    6cd8:	ldr	r5, [sp, #20]
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    6cda:	mov	r2, r7
    6cdc:	mov	r1, r5
    6cde:	mov	r0, r8
    6ce0:	bl	388e <FsCache::get(unsigned long, unsigned char)>
  #endif

  pbs = reinterpret_cast<pbs_t*>
        (cacheFetchData(volumeStartSector, FsCache::CACHE_FOR_READ));
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    6ce4:	cmp	r0, #0
    6ce6:	beq.n	6d5c <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    6ce8:	ldrb	r3, [r0, #16]
    6cea:	cmp	r3, #2
    6cec:	bne.n	6d5c <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    6cee:	ldrh.w	r3, [r0, #11]
    6cf2:	cmp.w	r3, #512	; 0x200
    6cf6:	bne.n	6d5c <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    6cf8:	b.n	6d60 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd8>
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    if (tmp == 0) {
    6cfa:	subs	r2, #1
    6cfc:	beq.n	6d5c <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
    6cfe:	ldrb	r6, [r4, #6]
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    6d00:	lsls	r3, r3, #1
    if (tmp == 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
    6d02:	adds	r6, #1
    6d04:	strb	r6, [r4, #6]
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    6d06:	uxtb	r3, r3
    6d08:	cmp	r3, r1
    6d0a:	bne.n	6cfa <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
    6d0c:	ldrh	r3, [r0, #22]
    6d0e:	str	r3, [r4, #16]
  if (m_sectorsPerFat == 0) {
    6d10:	cbnz	r3, 6d16 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x8e>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    6d12:	ldr	r3, [r0, #36]	; 0x24
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
    6d14:	str	r3, [r4, #16]
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    6d16:	ldrh	r1, [r0, #14]
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    6d18:	ldrh.w	r2, [r0, #17]

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    6d1c:	ldr	r6, [r4, #16]
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);
    6d1e:	strh	r2, [r4, #8]
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    6d20:	add	r1, r5

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    6d22:	add.w	r3, r1, r6, lsl #1
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    6d26:	str	r1, [r4, #24]
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    6d28:	lsls	r1, r2, #5
    6d2a:	addw	r1, r1, #511	; 0x1ff
    6d2e:	add.w	r1, r3, r1, asr #9

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    6d32:	str	r3, [r4, #32]
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
    6d34:	ldrh.w	r3, [r0, #19]

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);
    6d38:	str	r1, [r4, #20]

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
  if (totalSectors == 0) {
    6d3a:	cbnz	r3, 6d3e <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xb6>
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    6d3c:	ldr	r3, [r0, #32]
    totalSectors = getLe32(bpb->totalSectors32);
  }
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);
    6d3e:	subs	r1, r5, r1
    6d40:	add	r1, r3

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
    6d42:	ldrb	r3, [r4, #6]
    6d44:	lsrs	r1, r3
  m_lastCluster = clusterCount + 1;
    6d46:	adds	r3, r1, #1
    6d48:	str	r3, [r4, #28]
    return m_blockDev->writeSector(sector, src);
  }
#if MAINTAIN_FREE_CLUSTER_COUNT
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
    6d4a:	mov.w	r3, #4294967295
    6d4e:	str	r3, [r4, #36]	; 0x24

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    6d50:	movw	r3, #4084	; 0xff4
    6d54:	cmp	r1, r3
    6d56:	bhi.n	6d70 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xe8>
    m_fatType = 12;
    6d58:	movs	r3, #12
    6d5a:	strb	r3, [r4, #7]
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;

 fail:
  return false;
    6d5c:	movs	r0, #0
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    6d5e:	b.n	6d8a <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x102>
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
    6d60:	ldrb	r1, [r0, #13]
    6d62:	strb	r1, [r4, #4]
  m_clusterSectorMask = m_sectorsPerCluster - 1;
    6d64:	subs	r3, r1, #1
    6d66:	strb	r3, [r4, #5]
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
    6d68:	strb	r7, [r4, #6]
    6d6a:	movs	r2, #9
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    6d6c:	mov	r3, r6
    6d6e:	b.n	6d08 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x80>
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    6d70:	movw	r3, #65524	; 0xfff4
    6d74:	cmp	r1, r3
    6d76:	ittet	hi
    6d78:	ldrhi	r3, [r0, #44]	; 0x2c
    m_fatType = 16;
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    6d7a:	strhi	r3, [r4, #32]
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    m_fatType = 16;
    6d7c:	movls	r3, #16
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    m_fatType = 32;
    6d7e:	movhi	r3, #32
    6d80:	strb	r3, [r4, #7]
  }
  /** Set the offset to the second FAT for mirroring.
   * \param[in] offset Sector offset to second FAT.
   */
  void setMirrorOffset(uint32_t offset) {
    m_mirrorOffset = offset;
    6d82:	str	r6, [r4, #48]	; 0x30
    6d84:	str.w	r6, [r4, #576]	; 0x240
  }
  m_cache.setMirrorOffset(m_sectorsPerFat);
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;
    6d88:	movs	r0, #1

 fail:
  return false;
}
    6d8a:	add	sp, #28
    6d8c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00006d90 <FatVolume::chdir(char const*)>:
#define DBG_FILE "FatVolume.cpp"
#include "../common/DebugMacros.h"
#include "FatVolume.h"
FatVolume* FatVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FatVolume::chdir(const char *path) {
    6d90:	push	{r4, r5, r6, lr}
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend FatFile;
  static FatVolume* cwv() {return m_cwv;}
  FatFile* vwd() {return &m_vwd;}
    6d92:	add.w	r4, r0, #1096	; 0x448
    6d96:	sub	sp, #40	; 0x28
    6d98:	movs	r3, #0
  FatFile dir;
  if (!dir.open(vwd(), path, O_RDONLY)) {
    6d9a:	mov	r2, r1
    6d9c:	add	r0, sp, #4
    6d9e:	mov	r1, r4
    6da0:	strb.w	r3, [sp, #4]
    6da4:	strb.w	r3, [sp, #5]
    6da8:	strb.w	r3, [sp, #6]
    6dac:	bl	62ec <FatFile::open(FatFile*, char const*, int)>
    6db0:	mov	r6, r0
    6db2:	cbz	r0, 6dd0 <FatVolume::chdir(char const*)+0x40>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!dir.isDir()) {
    6db4:	ldrb.w	r3, [sp, #4]
    6db8:	ands.w	r3, r3, #112	; 0x70
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_vwd = dir;
    6dbc:	itttt	ne
    6dbe:	addne	r5, sp, #4
    6dc0:	ldmiane	r5!, {r0, r1, r2, r3}
    6dc2:	stmiane	r4!, {r0, r1, r2, r3}
    6dc4:	ldmiane	r5!, {r0, r1, r2, r3}
    6dc6:	ittte	ne
    6dc8:	stmiane	r4!, {r0, r1, r2, r3}
    6dca:	ldrne	r3, [r5, #0]
    6dcc:	strne	r3, [r4, #0]
  return true;

 fail:
  return false;
    6dce:	moveq	r6, r3
}
    6dd0:	mov	r0, r6
    6dd2:	add	sp, #40	; 0x28
    6dd4:	pop	{r4, r5, r6, pc}

00006dd6 <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>:
  }
  DirFat_t* cacheDirEntry(uint8_t action);
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    6dd6:	subs	r1, r0, #1
    6dd8:	add.w	r2, r0, #10
    uint8_t sum = 0;
    6ddc:	movs	r0, #0
    6dde:	lsls	r3, r0, #7
    6de0:	orr.w	r0, r3, r0, lsr #1
    for (uint8_t i = 0; i < 11; i++) {
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    6de4:	ldrb.w	r3, [r1, #1]!
    6de8:	uxtab	r0, r3, r0
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    6dec:	cmp	r1, r2
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    6dee:	uxtb	r0, r0
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    6df0:	bne.n	6dde <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]+0x8>
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    }
    return sum;
  }
    6df2:	bx	lr

00006df4 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)>:
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6df4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  FatFile dir = *this;
    6df8:	mov	r5, r0
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6dfa:	mov	r6, r2
    6dfc:	mov	r7, r0
    6dfe:	mov	r8, r1
    6e00:	mov	r9, r3
  FatFile dir = *this;
    6e02:	ldmia	r5!, {r0, r1, r2, r3}
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6e04:	sub	sp, #52	; 0x34
  FatFile dir = *this;
    6e06:	add	r4, sp, #12
    6e08:	stmia	r4!, {r0, r1, r2, r3}
    6e0a:	ldmia	r5!, {r0, r1, r2, r3}
    6e0c:	stmia	r4!, {r0, r1, r2, r3}
    6e0e:	ldr	r3, [r5, #0]
    6e10:	str	r3, [r4, #0]
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
  }
  void reset() {
    next = begin;
    6e12:	ldr	r3, [r6, #0]
    6e14:	str	r3, [r6, #4]
    ls = 0;
    6e16:	movs	r3, #0
    6e18:	strh	r3, [r6, #12]
  DirLfn_t* ldir;
  fname->reset();
  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6e1a:	movs	r5, #1
    6e1c:	cmp	r5, r9
    6e1e:	bhi.n	6e5a <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x66>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(index - order));
    6e20:	rsb	r1, r5, r8
    6e24:	uxth	r1, r1
    6e26:	add	r0, sp, #12
    6e28:	bl	5b08 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    6e2c:	mov	fp, r0
    6e2e:	cbnz	r0, 6e34 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x40>
    }
  }
  return true;

 fail:
  return false;
    6e30:	movs	r0, #0
    6e32:	b.n	6e8a <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
    6e34:	mov.w	sl, #0
    }
    // These should be checked in caller.
    DBG_HALT_IF(ldir->attributes != FAT_ATTRIB_LONG_NAME);
    DBG_HALT_IF(order != (ldir->order & 0X1F));
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t u = getLfnChar(ldir, i);
    6e38:	uxtb.w	r2, sl
    6e3c:	mov	r1, fp
    6e3e:	mov	r0, r7
    6e40:	bl	5b22 <FatFile::getLfnChar(DirLfn_t*, unsigned char)>
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    6e44:	ldrh	r3, [r6, #12]
    6e46:	mov	r4, r0
    6e48:	cbnz	r3, 6e5e <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x6a>
    6e4a:	ldr	r2, [r6, #4]
    6e4c:	ldr	r3, [r6, #8]
    6e4e:	cmp	r2, r3
    6e50:	bne.n	6e5e <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x6a>
      if (fname->atEnd()) {
        return u == 0;
    6e52:	clz	r0, r0
    6e56:	lsrs	r0, r0, #5
    6e58:	b.n	6e8a <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
        return false;
      }
#endif  // USE_UTF8_LONG_NAMES
    }
  }
  return true;
    6e5a:	movs	r0, #1
    6e5c:	b.n	6e8a <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
      uint16_t u = getLfnChar(ldir, i);
      if (fname->atEnd()) {
        return u == 0;
      }
#if USE_UTF8_LONG_NAMES
      uint16_t cp = fname->get16();
    6e5e:	mov	r0, r6
    6e60:	bl	3980 <FsName::get16()>
    6e64:	str	r0, [sp, #4]
      // Make sure caller checked for valid UTF-8.
      DBG_HALT_IF(cp == 0XFFFF);
      if (toUpcase(u) != toUpcase(cp)) {
    6e66:	mov	r0, r4
    6e68:	bl	38dc <toUpcase(unsigned short)>
    6e6c:	ldr	r3, [sp, #4]
    6e6e:	mov	r4, r0
    6e70:	mov	r0, r3
    6e72:	bl	38dc <toUpcase(unsigned short)>
    6e76:	cmp	r4, r0
    6e78:	bne.n	6e30 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x3c>
    6e7a:	add.w	sl, sl, #1
      goto fail;
    }
    // These should be checked in caller.
    DBG_HALT_IF(ldir->attributes != FAT_ATTRIB_LONG_NAME);
    DBG_HALT_IF(order != (ldir->order & 0X1F));
    for (uint8_t i = 0; i < 13; i++) {
    6e7e:	cmp.w	sl, #13
    6e82:	bne.n	6e38 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x44>
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
  FatFile dir = *this;
  DirLfn_t* ldir;
  fname->reset();
  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6e84:	adds	r5, #1
    6e86:	uxtb	r5, r5
    6e88:	b.n	6e1c <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x28>
  }
  return true;

 fail:
  return false;
}
    6e8a:	add	sp, #52	; 0x34
    6e8c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00006e90 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)>:
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6e90:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  FatFile dir = *this;
    6e94:	mov	r5, r0

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6e96:	mov	r6, r2
    6e98:	mov	sl, r1
    6e9a:	mov	r7, r3
  FatFile dir = *this;
    6e9c:	ldmia	r5!, {r0, r1, r2, r3}

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6e9e:	sub	sp, #52	; 0x34
  FatFile dir = *this;
    6ea0:	add	r4, sp, #12
    6ea2:	stmia	r4!, {r0, r1, r2, r3}
    6ea4:	ldmia	r5!, {r0, r1, r2, r3}
    6ea6:	stmia	r4!, {r0, r1, r2, r3}
    6ea8:	ldr	r3, [r5, #0]
    6eaa:	str	r3, [r4, #0]
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
    6eac:	add.w	r0, r6, #22
    6eb0:	bl	6dd6 <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>
  }
  void reset() {
    next = begin;
    ls = 0;
    6eb4:	movs	r5, #0
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
  }
  void reset() {
    next = begin;
    6eb6:	ldr	r3, [r6, #0]
    6eb8:	str	r3, [r6, #4]
    6eba:	mov	r9, r0
    ls = 0;
    6ebc:	strh	r5, [r6, #12]
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6ebe:	mov.w	fp, #1
      goto fail;
    }
    dir.m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    6ec2:	mov	r8, r5
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6ec4:	cmp	fp, r7
    6ec6:	bhi.n	6f16 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x86>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(index - order));
    6ec8:	rsb	r1, fp, sl
    6ecc:	uxth	r1, r1
    6ece:	add	r0, sp, #12
    6ed0:	bl	5b08 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    6ed4:	cmp	r0, #0
    6ed6:	beq.n	6f5e <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xce>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dir.m_vol->cacheDirty();
    6ed8:	ldr	r2, [sp, #20]
    invalidate();
    return m_buffer;
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    6eda:	ldrb.w	r3, [r2, #40]	; 0x28
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    6ede:	cmp	fp, r7
    6ee0:	orr.w	r3, r3, #1
    6ee4:	strb.w	r3, [r2, #40]	; 0x28
    6ee8:	ite	eq
    6eea:	orreq.w	r3, fp, #64	; 0x40
    6eee:	movne	r3, fp
    6ef0:	strb	r3, [r0, #0]
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    6ef2:	mov.w	r3, #15
    6ef6:	strb	r3, [r0, #11]
    ldir->mustBeZero1 = 0;
    6ef8:	strb.w	r8, [r0, #12]
    ldir->checksum = checksum;
    6efc:	strb.w	r9, [r0, #13]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    6f00:	strh.w	r8, [r0, #26]
    6f04:	adds	r4, r0, #4
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
    6f06:	movs	r1, #0
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    6f08:	ldrh	r3, [r6, #12]
    6f0a:	cbnz	r3, 6f1a <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x8a>
    6f0c:	ldr	r2, [r6, #4]
    6f0e:	ldr	r3, [r6, #8]
    6f10:	cmp	r2, r3
    6f12:	bne.n	6f1a <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x8a>
    6f14:	b.n	6f4c <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xbc>
        DBG_HALT_IF(cp == 0XFFFF);
      }
      putLfnChar(ldir, i, cp);
    }
  }
  return true;
    6f16:	movs	r0, #1
    6f18:	b.n	6f5e <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xce>
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t cp;
      if (fname->atEnd()) {
        cp = fc++ ? 0XFFFF : 0;
      } else {
        cp = fname->get16();
    6f1a:	mov	r0, r6
    6f1c:	str	r1, [sp, #4]
    6f1e:	bl	3980 <FsName::get16()>
    6f22:	ldr	r1, [sp, #4]
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c The 16-bit character.
 */
static void putLfnChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    6f24:	cmp	r1, #4
    6f26:	bhi.n	6f2e <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x9e>
    6f28:	strh.w	r0, [r4, #-3]
    6f2c:	b.n	6f36 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xa6>
    setLe16(ldir->unicode1 + 2*i, c);
  } else if (i < 11) {
    6f2e:	cmp	r1, #10
    6f30:	ite	ls
    6f32:	strhls	r0, [r4, #0]
    6f34:	strhhi	r0, [r4, #2]
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    ldir->checksum = checksum;
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
    6f36:	adds	r1, #1
    6f38:	uxtb	r1, r1
    6f3a:	cmp	r1, #13
    6f3c:	add.w	r4, r4, #2
    6f40:	bne.n	6f08 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x78>
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6f42:	add.w	fp, fp, #1
    6f46:	uxtb.w	fp, fp
    6f4a:	b.n	6ec4 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x34>
    ldir->checksum = checksum;
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t cp;
      if (fname->atEnd()) {
        cp = fc++ ? 0XFFFF : 0;
    6f4c:	cbz	r5, 6f58 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xc8>
    6f4e:	adds	r5, #1
    6f50:	uxtb	r5, r5
    6f52:	movw	r0, #65535	; 0xffff
    6f56:	b.n	6f24 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x94>
    6f58:	mov	r0, r5
    6f5a:	movs	r5, #1
    6f5c:	b.n	6f24 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x94>
  }
  return true;

 fail:
  return false;
}
    6f5e:	add	sp, #52	; 0x34
    6f60:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00006f64 <FatFile::makeSFN(FatName_t*)>:
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
  const char* ptr = fname->begin;
    6f64:	mov	r2, r0

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::makeSFN(FatName_t* fname) {
    6f66:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
  const char* ptr = fname->begin;
    6f6a:	ldr.w	r3, [r2], #21
  uint8_t lc = 0;
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
    6f6e:	ldr	r7, [r0, #8]
    6f70:	add.w	r1, r0, #32
  // Assume blanks removed from start and end.
  DBG_HALT_IF(*ptr == ' ' || *(end - 1) == ' ' || *(end - 1) == '.');

  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    fname->sfn[k] = ' ';
    6f74:	movs	r4, #32
    6f76:	strb.w	r4, [r2, #1]!
  DBG_HALT_IF(end == ptr);
  // Assume blanks removed from start and end.
  DBG_HALT_IF(*ptr == ' ' || *(end - 1) == ' ' || *(end - 1) == '.');

  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    6f7a:	cmp	r1, r2
    6f7c:	bne.n	6f76 <FatFile::makeSFN(FatName_t*)+0x12>
    fname->sfn[k] = ' ';
  }
  // Not 8.3 if starts with dot.
  is83 = *ptr == '.' ? false : true;
    6f7e:	ldrb	r6, [r3, #0]
    6f80:	subs	r6, #46	; 0x2e
    6f82:	it	ne
    6f84:	movne	r6, #1
    6f86:	mov	r5, r3
    6f88:	adds	r3, #1
  // Skip leading dots.
  for (; *ptr == '.'; ptr++) {}
    6f8a:	ldrb	r2, [r5, #0]
    6f8c:	cmp	r2, #46	; 0x2e
    6f8e:	beq.n	6f86 <FatFile::makeSFN(FatName_t*)+0x22>
    6f90:	subs	r3, r7, #1
  // Find last dot.
  for (dot = end - 1; dot > ptr && *dot != '.'; dot--) {}
    6f92:	cmp	r3, r5
    6f94:	mov	lr, r3
    6f96:	bhi.n	6fa8 <FatFile::makeSFN(FatName_t*)+0x44>
    6f98:	movs	r2, #0
    6f9a:	mov.w	ip, #7
    6f9e:	mov	r1, r2
    6fa0:	mov	r8, r2
    6fa2:	mov.w	r9, #8
    6fa6:	b.n	6fcc <FatFile::makeSFN(FatName_t*)+0x68>
    6fa8:	ldrb.w	r2, [lr]
    6fac:	cmp	r2, #46	; 0x2e
    6fae:	add.w	r3, r3, #4294967295
    6fb2:	bne.n	6f92 <FatFile::makeSFN(FatName_t*)+0x2e>
    6fb4:	b.n	6f98 <FatFile::makeSFN(FatName_t*)+0x34>

  for (; ptr < end; ptr++) {
    c = *ptr;
    6fb6:	ldrb	r3, [r5, #0]
//  Could skip UTF-8 units where (0XC0 & c) == 0X80

    if (c == '.' && ptr == dot) {
    6fb8:	cmp	r3, #46	; 0x2e
    6fba:	bne.n	6fd2 <FatFile::makeSFN(FatName_t*)+0x6e>
    6fbc:	cmp	lr, r5
    6fbe:	bne.n	6fda <FatFile::makeSFN(FatName_t*)+0x76>
      in = 10;  // Max index for full 8.3 name.
    6fc0:	mov.w	ip, #10
      i = 8;    // Place for extension.
    6fc4:	movs	r1, #8
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    6fc6:	mov.w	r9, #16
  // Skip leading dots.
  for (; *ptr == '.'; ptr++) {}
  // Find last dot.
  for (dot = end - 1; dot > ptr && *dot != '.'; dot--) {}

  for (; ptr < end; ptr++) {
    6fca:	adds	r5, #1
    6fcc:	cmp	r5, r7
    6fce:	bcc.n	6fb6 <FatFile::makeSFN(FatName_t*)+0x52>
    6fd0:	b.n	705c <FatFile::makeSFN(FatName_t*)+0xf8>
  /** Check for a legal 8.3 character.
   * \param[in] c Character to be checked.
   * \return true for a legal 8.3 character.
   */
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
    6fd2:	cmp	r3, #34	; 0x22
    6fd4:	beq.n	6ffe <FatFile::makeSFN(FatName_t*)+0x9a>
    6fd6:	cmp	r3, #124	; 0x7c
    6fd8:	beq.n	6ffe <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
    6fda:	sub.w	r4, r3, #42	; 0x2a
    6fde:	cmp	r4, #5
    6fe0:	bhi.n	6fe6 <FatFile::makeSFN(FatName_t*)+0x82>
    6fe2:	cmp	r3, #45	; 0x2d
    6fe4:	bne.n	6ffe <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // :;<=>?
    if (0X3A <= c && c <= 0X3F) {
    6fe6:	sub.w	r4, r3, #58	; 0x3a
    6fea:	cmp	r4, #5
    6fec:	bls.n	6ffe <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // [\]
    if (0X5B <= c && c <= 0X5D) {
    6fee:	sub.w	r4, r3, #91	; 0x5b
    6ff2:	cmp	r4, #2
    6ff4:	bls.n	6ffe <FatFile::makeSFN(FatName_t*)+0x9a>
    if (c == '.' && ptr == dot) {
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
    6ff6:	sub.w	r4, r3, #33	; 0x21
    6ffa:	cmp	r4, #93	; 0x5d
    6ffc:	bls.n	7008 <FatFile::makeSFN(FatName_t*)+0xa4>
        is83 = false;
        // Skip UTF-8 trailing characters.
        if ((c & 0XC0) == 0X80) {
    6ffe:	and.w	r3, r3, #192	; 0xc0
    7002:	cmp	r3, #128	; 0x80
    7004:	bne.n	702e <FatFile::makeSFN(FatName_t*)+0xca>
    7006:	b.n	7052 <FatFile::makeSFN(FatName_t*)+0xee>
          continue;
        }
        c = '_';
      }
      if (i > in) {
    7008:	cmp	r1, ip
    700a:	bls.n	701c <FatFile::makeSFN(FatName_t*)+0xb8>
        is83 = false;
        if (in == 10 || ptr > dot) {
    700c:	cmp.w	ip, #10
    7010:	beq.n	705a <FatFile::makeSFN(FatName_t*)+0xf6>
    7012:	cmp	lr, r5
    7014:	bcc.n	705a <FatFile::makeSFN(FatName_t*)+0xf6>
         // Done - extension longer than three characters or no extension.
          break;
        }
        // Skip to dot.
        ptr = dot - 1;
    7016:	add.w	r5, lr, #4294967295
    701a:	b.n	7052 <FatFile::makeSFN(FatName_t*)+0xee>
        continue;
      }
      if (isLower(c)) {
    701c:	sub.w	r4, r3, #97	; 0x61
    7020:	cmp	r4, #25
    7022:	bhi.n	7036 <FatFile::makeSFN(FatName_t*)+0xd2>
        c += 'A' - 'a';
    7024:	subs	r3, #32
    7026:	uxtb	r3, r3
        lc |= bit;
    7028:	orr.w	r2, r9, r2
    702c:	b.n	7042 <FatFile::makeSFN(FatName_t*)+0xde>
        if ((c & 0XC0) == 0X80) {
          continue;
        }
        c = '_';
      }
      if (i > in) {
    702e:	cmp	r1, ip
    7030:	bhi.n	700c <FatFile::makeSFN(FatName_t*)+0xa8>
        is83 = false;
        // Skip UTF-8 trailing characters.
        if ((c & 0XC0) == 0X80) {
          continue;
        }
        c = '_';
    7032:	movs	r3, #95	; 0x5f
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
        is83 = false;
    7034:	movs	r6, #0
        continue;
      }
      if (isLower(c)) {
        c += 'A' - 'a';
        lc |= bit;
      } else if (isUpper(c)) {
    7036:	sub.w	r4, r3, #65	; 0x41
    703a:	cmp	r4, #25
        uc |= bit;
    703c:	it	ls
    703e:	orrls.w	r8, r9, r8
      }
      fname->sfn[i++] = c;
    7042:	adds	r4, r1, #1
    7044:	uxtb	r4, r4
    7046:	add	r1, r0
      if (i < 7) {
    7048:	cmp	r4, #6
        c += 'A' - 'a';
        lc |= bit;
      } else if (isUpper(c)) {
        uc |= bit;
      }
      fname->sfn[i++] = c;
    704a:	strb	r3, [r1, #22]
      if (i < 7) {
    704c:	bhi.n	7056 <FatFile::makeSFN(FatName_t*)+0xf2>
        fname->seqPos = i;
    704e:	strb	r4, [r0, #20]
    7050:	b.n	7056 <FatFile::makeSFN(FatName_t*)+0xf2>
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
        is83 = false;
    7052:	movs	r6, #0
    7054:	b.n	6fca <FatFile::makeSFN(FatName_t*)+0x66>
    7056:	mov	r1, r4
    7058:	b.n	6fca <FatFile::makeSFN(FatName_t*)+0x66>
          continue;
        }
        c = '_';
      }
      if (i > in) {
        is83 = false;
    705a:	movs	r6, #0
      if (i < 7) {
        fname->seqPos = i;
      }
    }
  }
  if (fname->sfn[0] == ' ') {
    705c:	ldrb	r3, [r0, #22]
    705e:	cmp	r3, #32
    7060:	beq.n	7086 <FatFile::makeSFN(FatName_t*)+0x122>
    DBG_HALT_MACRO;
    goto fail;
  }
  if (is83) {
    7062:	cbz	r6, 7074 <FatFile::makeSFN(FatName_t*)+0x110>
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
    7064:	tst.w	r8, r2
    7068:	it	ne
    706a:	movne	r2, #2
    706c:	strb	r2, [r0, #21]
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
    706e:	movs	r0, #1
    7070:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  }
  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    7074:	ldrb	r2, [r0, #20]
    goto fail;
  }
  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    7076:	movs	r3, #1
    7078:	strb	r3, [r0, #21]
    fname->sfn[fname->seqPos] = '~';
    707a:	add	r0, r2
    707c:	movs	r2, #126	; 0x7e
    707e:	strb	r2, [r0, #22]
    fname->sfn[fname->seqPos + 1] = '1';
    7080:	movs	r2, #49	; 0x31
    7082:	strb	r2, [r0, #23]
    7084:	b.n	706e <FatFile::makeSFN(FatName_t*)+0x10a>
  }
  return true;

 fail:
  return false;
    7086:	movs	r0, #0
    7088:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0000708c <FatFile::makeUniqueSfn(FatName_t*)>:
}
//------------------------------------------------------------------------------
bool FatFile::makeUniqueSfn(FatName_t* fname) {
    708c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;
    7090:	ldrb	r5, [r1, #20]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::makeUniqueSfn(FatName_t* fname) {
    7092:	mov	r7, r0
    7094:	mov	r6, r1
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;
    7096:	movs	r4, #98	; 0x62
    for (uint8_t i = pos + 4 ; i > pos; i--) {
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
      hex >>= 4;
    }
    fname->sfn[pos] = '~';
    7098:	mov.w	r8, #126	; 0x7e
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    709c:	add.w	r9, r1, #22
  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
     DBG_WARN_IF(seq > FIRST_HASH_SEQ);
#ifdef USE_LFN_HASH
    hex = Bernstein(fname->begin, fname->end, seq);
#else
    hex = micros();
    70a0:	bl	953c <micros>
    70a4:	cmp	r5, #3
    70a6:	it	cs
    70a8:	movcs	r5, #3
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    70aa:	adds	r3, r5, #4
  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
     DBG_WARN_IF(seq > FIRST_HASH_SEQ);
#ifdef USE_LFN_HASH
    hex = Bernstein(fname->begin, fname->end, seq);
#else
    hex = micros();
    70ac:	uxth	r0, r0
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    70ae:	uxtb	r3, r3
      uint8_t h = hex & 0XF;
    70b0:	and.w	r2, r0, #15
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    70b4:	adds	r1, r6, r3
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    70b6:	subs	r3, #1
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    70b8:	cmp	r2, #9
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    70ba:	uxtb	r3, r3
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    70bc:	ite	ls
    70be:	addls	r2, #48	; 0x30
    70c0:	addhi	r2, #55	; 0x37
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    70c2:	cmp	r5, r3
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    70c4:	strb	r2, [r1, #22]
      hex >>= 4;
    70c6:	mov.w	r0, r0, lsr #4
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    70ca:	bcc.n	70b0 <FatFile::makeUniqueSfn(FatName_t*)+0x24>
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
      hex >>= 4;
    }
    fname->sfn[pos] = '~';
    70cc:	adds	r3, r6, r5
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    70ce:	movs	r1, #0
    70d0:	strb.w	r8, [r3, #22]
    70d4:	mov	r0, r7
    70d6:	bl	6006 <FatFile::seekSet(unsigned long)>
    rewind();
    while (1) {
      dir = readDirCache(true);
    70da:	movs	r1, #1
    70dc:	mov	r0, r7
    70de:	bl	5fcc <FatFile::readDirCache(bool)>
      if (!dir) {
    70e2:	mov	r1, r0
    70e4:	cbnz	r0, 70f2 <FatFile::makeUniqueSfn(FatName_t*)+0x66>
        if (!getError()) {
    70e6:	ldrb	r0, [r7, #1]
    70e8:	clz	r0, r0
    70ec:	lsrs	r0, r0, #5
    70ee:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    70f2:	ldrb	r3, [r0, #0]
    70f4:	cbz	r3, 710a <FatFile::makeUniqueSfn(FatName_t*)+0x7e>
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    70f6:	ldrb	r3, [r0, #11]
    70f8:	lsls	r3, r3, #28
    70fa:	bmi.n	70da <FatFile::makeUniqueSfn(FatName_t*)+0x4e>
    70fc:	movs	r2, #11
    70fe:	mov	r0, r9
    7100:	bl	b9a0 <memcmp>
    7104:	cmp	r0, #0
    7106:	bne.n	70da <FatFile::makeUniqueSfn(FatName_t*)+0x4e>
    7108:	b.n	7110 <FatFile::makeUniqueSfn(FatName_t*)+0x84>

 fail:
  return false;

 done:
  return true;
    710a:	movs	r0, #1
    710c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    7110:	subs	r0, r4, #1
  uint16_t hex;

  DBG_HALT_IF(!(fname->flags & FNAME_FLAG_LOST_CHARS));
  DBG_HALT_IF(fname->sfn[pos] != '~' && fname->sfn[pos + 1] != '1');

  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
    7112:	ands.w	r4, r0, #255	; 0xff
    7116:	bne.n	70a0 <FatFile::makeUniqueSfn(FatName_t*)+0x14>
  }
  // fall inti fail - too many tries.
  DBG_FAIL_MACRO;

 fail:
  return false;
    7118:	mov	r0, r4
    711a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    711e:	Address 0x0000711e is out of bounds.


00007120 <FatFile::open(FatFile*, FatName_t*, int)>:

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    7120:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7124:	sub	sp, #44	; 0x2c
    7126:	mov	r6, r1
    7128:	str	r3, [sp, #12]
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    712a:	ldrb	r3, [r1, #0]

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    712c:	str	r0, [sp, #24]
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    712e:	tst.w	r3, #112	; 0x70

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    7132:	mov	sl, r2
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    7134:	bne.n	713a <FatFile::open(FatFile*, FatName_t*, int)+0x1a>
    goto fail;
  }
  return true;

 fail:
  return false;
    7136:	movs	r0, #0
    7138:	b.n	7364 <FatFile::open(FatFile*, FatName_t*, int)+0x244>
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    713a:	ldr	r3, [sp, #24]
    713c:	ldrb	r3, [r3, #0]
    713e:	cmp	r3, #0
    7140:	bne.n	7136 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
    7142:	ldr	r3, [r2, #16]
    7144:	movs	r2, #13
    7146:	adds	r3, #12
    7148:	udiv	r3, r3, r2
    714c:	uxtb	r3, r3
    714e:	str	r3, [sp, #8]
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
    7150:	ldrb.w	r3, [sl, #21]
    7154:	lsls	r3, r3, #30
    7156:	beq.w	735e <FatFile::open(FatFile*, FatName_t*, int)+0x23e>
    715a:	ldr	r3, [sp, #8]
    715c:	add.w	fp, r3, #1
    7160:	uxtb.w	fp, fp
    7164:	movs	r1, #0
    7166:	mov	r0, r6
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
  uint8_t ms10;
  uint8_t nameOrd;
  uint16_t freeIndex = 0;
    7168:	mov.w	r9, #0
    716c:	bl	6006 <FatFile::seekSet(unsigned long)>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    7170:	add.w	r3, sl, #22
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
    7174:	str.w	r9, [sp, #16]
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
    7178:	mov	r8, r9
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
    717a:	mov	r4, r9
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
    717c:	mov	r5, r9
 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
    717e:	str.w	r9, [sp, #20]
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    7182:	str	r3, [sp, #28]
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    7184:	ldr	r7, [r6, #20]
    dir = dirFile->readDirCache();
    7186:	movs	r1, #0
    7188:	mov	r0, r6
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    718a:	ubfx	r7, r7, #5, #16
    dir = dirFile->readDirCache();
    718e:	bl	5fcc <FatFile::readDirCache(bool)>
    if (!dir) {
    7192:	cbnz	r0, 719c <FatFile::open(FatFile*, FatName_t*, int)+0x7c>
      if (dirFile->getError()) {
    7194:	ldrb	r3, [r6, #1]
    7196:	cmp	r3, #0
    7198:	beq.n	725c <FatFile::open(FatFile*, FatName_t*, int)+0x13c>
    719a:	b.n	7136 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
        goto fail;
      }
      // At EOF
      goto create;
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
    719c:	ldrb	r3, [r0, #0]
    719e:	cmp	r3, #229	; 0xe5
    71a0:	beq.n	71a4 <FatFile::open(FatFile*, FatName_t*, int)+0x84>
    71a2:	cbnz	r3, 71b6 <FatFile::open(FatFile*, FatName_t*, int)+0x96>
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    71a4:	cmp	r4, #0
    71a6:	it	eq
    71a8:	moveq	r9, r7
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
      if (freeFound == 0) {
        freeIndex = curIndex;
      }
      if (freeFound < freeNeed) {
    71aa:	cmp	r4, fp
        freeFound++;
    71ac:	itt	cc
    71ae:	addcc	r4, #1
    71b0:	uxtbcc	r4, r4
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    71b2:	cbnz	r3, 71be <FatFile::open(FatFile*, FatName_t*, int)+0x9e>
    71b4:	b.n	725c <FatFile::open(FatFile*, FatName_t*, int)+0x13c>
        goto create;
      }
    } else {
      if (freeFound < freeNeed) {
        freeFound = 0;
    71b6:	cmp	r4, fp
    71b8:	it	cc
    71ba:	movcc	r4, #0
    71bc:	b.n	71c6 <FatFile::open(FatFile*, FatName_t*, int)+0xa6>
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    71be:	cmp	r3, #229	; 0xe5
    71c0:	bne.n	71c6 <FatFile::open(FatFile*, FatName_t*, int)+0xa6>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    71c2:	movs	r5, #0
    71c4:	b.n	7184 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
      if (freeFound < freeNeed) {
        freeFound = 0;
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    71c6:	cmp	r3, #46	; 0x2e
    71c8:	beq.n	71c2 <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
    71ca:	ldrb	r2, [r0, #11]
      lfnOrd = 0;
    } else if (isLongName(dir)) {
    71cc:	cmp	r2, #15
    71ce:	bne.n	7220 <FatFile::open(FatFile*, FatName_t*, int)+0x100>
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
    71d0:	cbnz	r5, 71f0 <FatFile::open(FatFile*, FatName_t*, int)+0xd0>
        order = ldir->order & 0X1F;
        if (order != nameOrd ||
    71d2:	ldr	r2, [sp, #8]
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
      lfnOrd = 0;
    } else if (isLongName(dir)) {
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
        order = ldir->order & 0X1F;
    71d4:	and.w	r8, r3, #31
        if (order != nameOrd ||
    71d8:	cmp	r2, r8
    71da:	bne.n	7184 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
    71dc:	lsls	r1, r3, #25
    71de:	bmi.n	71e6 <FatFile::open(FatFile*, FatName_t*, int)+0xc6>
    71e0:	ldr.w	r8, [sp, #8]
    71e4:	b.n	7184 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
          (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = nameOrd;
        checksum = ldir->checksum;
    71e6:	ldrb	r3, [r0, #13]
    71e8:	str	r3, [sp, #16]
    71ea:	mov	r8, r2
    71ec:	mov	r5, r2
    71ee:	b.n	7204 <FatFile::open(FatFile*, FatName_t*, int)+0xe4>
      } else if (ldir->order != --order || checksum != ldir->checksum) {
    71f0:	add.w	r8, r8, #4294967295
    71f4:	uxtb.w	r8, r8
    71f8:	cmp	r3, r8
    71fa:	bne.n	71c2 <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
    71fc:	ldrb	r3, [r0, #13]
    71fe:	ldr	r2, [sp, #16]
    7200:	cmp	r2, r3
    7202:	bne.n	71c2 <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
        lfnOrd = 0;
        continue;
      }
      if (order == 1) {
    7204:	cmp.w	r8, #1
    7208:	bne.n	7184 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        if (!dirFile->cmpName(curIndex + 1, fname, lfnOrd)) {
    720a:	adds	r1, r7, #1
    720c:	mov	r3, r5
    720e:	mov	r2, sl
    7210:	uxth	r1, r1
    7212:	mov	r0, r6
    7214:	bl	6df4 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)>
          lfnOrd = 0;
    7218:	cmp	r0, #0
    721a:	it	eq
    721c:	moveq	r5, #0
    721e:	b.n	7184 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        }
      }
    } else if (isFileOrSubdir(dir)) {
    7220:	lsls	r3, r2, #28
    7222:	bmi.n	71c2 <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
      if (lfnOrd) {
    7224:	cbz	r5, 723a <FatFile::open(FatFile*, FatName_t*, int)+0x11a>
        if (1 == order && lfnChecksum(dir->name) == checksum) {
    7226:	cmp.w	r8, #1
    722a:	bne.n	7136 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    722c:	bl	6dd6 <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>
    7230:	ldr	r3, [sp, #16]
    7232:	cmp	r3, r0
    7234:	bne.w	7136 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    7238:	b.n	7254 <FatFile::open(FatFile*, FatName_t*, int)+0x134>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    723a:	movs	r2, #11
    723c:	ldr	r1, [sp, #28]
    723e:	bl	b9a0 <memcmp>
    7242:	cmp	r0, #0
    7244:	bne.n	7184 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        if (!(fname->flags & FNAME_FLAG_LOST_CHARS)) {
    7246:	ldrb.w	r3, [sl, #21]
    724a:	lsls	r0, r3, #31
    724c:	bpl.n	7254 <FatFile::open(FatFile*, FatName_t*, int)+0x134>
          goto found;
        }
        fnameFound = true;
    724e:	movs	r3, #1
    7250:	str	r3, [sp, #20]
    7252:	b.n	7184 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    7254:	ldr	r3, [sp, #12]
    7256:	lsls	r1, r3, #20
    7258:	bpl.n	734e <FatFile::open(FatFile*, FatName_t*, int)+0x22e>
    725a:	b.n	7136 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
  }
  goto open;

 create:
  // don't create unless O_CREAT and write mode
  if (!(oflag & O_CREAT) || !isWriteMode(oflag)) {
    725c:	ldr	r3, [sp, #12]
    725e:	lsls	r2, r3, #22
    7260:	bpl.w	7136 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    7264:	and.w	r3, r3, #3
    7268:	subs	r3, #1
    726a:	cmp	r3, #1
    726c:	bhi.w	7136 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_WARN_MACRO;
    goto fail;
  }
  // Keep found entries or start at current index if no free entries found.
  if (freeFound == 0) {
    7270:	cmp	r4, #0
    7272:	it	eq
    7274:	moveq	r9, r7
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    7276:	cmp	r4, fp
    7278:	bcc.n	7280 <FatFile::open(FatFile*, FatName_t*, int)+0x160>
      DBG_FAIL_MACRO;
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
  }
  if (fnameFound) {
    727a:	ldr	r3, [sp, #20]
    727c:	cbnz	r3, 72ae <FatFile::open(FatFile*, FatName_t*, int)+0x18e>
    727e:	b.n	72bc <FatFile::open(FatFile*, FatName_t*, int)+0x19c>
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    dir = dirFile->readDirCache();
    7280:	movs	r1, #0
    7282:	mov	r0, r6
    7284:	bl	5fcc <FatFile::readDirCache(bool)>
    if (!dir) {
    7288:	cbnz	r0, 7290 <FatFile::open(FatFile*, FatName_t*, int)+0x170>
      if (dirFile->getError()) {
    728a:	ldrb	r3, [r6, #1]
    728c:	cbz	r3, 72a2 <FatFile::open(FatFile*, FatName_t*, int)+0x182>
    728e:	b.n	7136 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
        goto fail;
      }
      // EOF if no error.
      break;
    }
    freeFound++;
    7290:	adds	r4, #1
    7292:	uxtb	r4, r4
  // Keep found entries or start at current index if no free entries found.
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    7294:	b.n	7276 <FatFile::open(FatFile*, FatName_t*, int)+0x156>
    7296:	ldr	r3, [r6, #8]
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
    7298:	ldrb	r3, [r3, #4]
    729a:	add	r4, r3
    729c:	uxtb	r4, r4
      // EOF if no error.
      break;
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
    729e:	cmp	fp, r4
    72a0:	bls.n	727a <FatFile::open(FatFile*, FatName_t*, int)+0x15a>
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
    72a2:	mov	r0, r6
    72a4:	bl	5d24 <FatFile::addDirCluster()>
    72a8:	cmp	r0, #0
    72aa:	bne.n	7296 <FatFile::open(FatFile*, FatName_t*, int)+0x176>
    72ac:	b.n	7136 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
  }
  if (fnameFound) {
    if (!dirFile->makeUniqueSfn(fname)) {
    72ae:	mov	r1, sl
    72b0:	mov	r0, r6
    72b2:	bl	708c <FatFile::makeUniqueSfn(FatName_t*)>
    72b6:	cmp	r0, #0
    72b8:	beq.w	7136 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
      goto fail;
    }
  }
  lfnOrd = freeNeed - 1;
    72bc:	add.w	r5, fp, #4294967295
    72c0:	uxtb	r5, r5
  curIndex = freeIndex + lfnOrd;
    72c2:	add.w	r7, r9, r5
    72c6:	uxth	r7, r7
  if (!dirFile->createLFN(curIndex, fname, lfnOrd)) {
    72c8:	mov	r3, r5
    72ca:	mov	r2, sl
    72cc:	mov	r1, r7
    72ce:	mov	r0, r6
    72d0:	bl	6e90 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)>
    72d4:	cmp	r0, #0
    72d6:	beq.w	7136 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    goto fail;
  }
  dir = dirFile->cacheDir(curIndex);
    72da:	mov	r1, r7
    72dc:	mov	r0, r6
    72de:	bl	5b08 <FatFile::cacheDir(unsigned short)>
  if (!dir) {
    72e2:	mov	r4, r0
    72e4:	cmp	r0, #0
    72e6:	beq.w	7136 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
    72ea:	movs	r2, #32
    72ec:	movs	r1, #0
    72ee:	bl	90e4 <memset>
  memcpy(dir->name, fname->sfn, 11);
    72f2:	mov	r3, sl
    72f4:	ldr.w	r2, [r3, #22]!
    72f8:	str	r2, [r4, #0]
    72fa:	ldr	r2, [r3, #4]
    72fc:	str	r2, [r4, #4]
    72fe:	ldrh	r2, [r3, #8]
    7300:	strh	r2, [r4, #8]
    7302:	ldrb	r3, [r3, #10]
    7304:	strb	r3, [r4, #10]

  // Set base-name and extension lower case bits.
  dir->caseFlags = (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;
    7306:	ldrb.w	r3, [sl, #21]
    730a:	and.w	r3, r3, #24
    730e:	strb	r3, [r4, #12]

  // Set timestamps.
  if (FsDateTime::callback) {
    7310:	ldr	r3, [pc, #88]	; (736c <FatFile::open(FatFile*, FatName_t*, int)+0x24c>)
    7312:	ldr	r3, [r3, #0]
    7314:	cbz	r3, 7336 <FatFile::open(FatFile*, FatName_t*, int)+0x216>
    // call user date/time function
    FsDateTime::callback(&date, &time, &ms10);
    7316:	add.w	r2, sp, #35	; 0x23
    731a:	add.w	r1, sp, #38	; 0x26
    731e:	add	r0, sp, #36	; 0x24
    7320:	blx	r3
    7322:	ldrh.w	r3, [sp, #36]	; 0x24
    7326:	strh	r3, [r4, #16]
    7328:	ldrh.w	r3, [sp, #38]	; 0x26
    732c:	strh	r3, [r4, #14]
    setLe16(dir->createDate, date);
    setLe16(dir->createTime, time);
    dir->createTimeMs = ms10;
    732e:	ldrb.w	r3, [sp, #35]	; 0x23
    7332:	strb	r3, [r4, #13]
    7334:	b.n	7340 <FatFile::open(FatFile*, FatName_t*, int)+0x220>
    7336:	movw	r3, #21537	; 0x5421
    733a:	strh	r3, [r4, #16]
    733c:	strh	r3, [r4, #24]
    733e:	strh	r3, [r4, #18]
      setLe16(dir->createTime, FS_DEFAULT_TIME);
      setLe16(dir->modifyTime, FS_DEFAULT_TIME);
    }
  }
  // Force write of entry to device.
  dirFile->m_vol->cacheDirty();
    7340:	ldr	r2, [r6, #8]
    7342:	ldrb.w	r3, [r2, #40]	; 0x28
    7346:	orr.w	r3, r3, #1
    734a:	strb.w	r3, [r2, #40]	; 0x28

 open:
  // open entry in cache.
  if (!openCachedEntry(dirFile, curIndex, oflag, lfnOrd)) {
    734e:	str	r5, [sp, #0]
    7350:	ldr	r3, [sp, #12]
    7352:	ldr	r0, [sp, #24]
    7354:	mov	r2, r7
    7356:	mov	r1, r6
    7358:	bl	60b2 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    735c:	b.n	7364 <FatFile::open(FatFile*, FatName_t*, int)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
    735e:	mov.w	fp, #1
    7362:	b.n	7164 <FatFile::open(FatFile*, FatName_t*, int)+0x44>
  }
  return true;

 fail:
  return false;
}
    7364:	add	sp, #44	; 0x2c
    7366:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    736a:	nop
    736c:	.word	0x2001a690

00007370 <FatFile::parsePathName(char const*, FatName_t*, char const**)>:
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            FatName_t* fname, const char** ptr) {
    7370:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    7372:	mov	r4, r2
    7374:	mov	r6, r3
    7376:	mov	r0, r1
    7378:	adds	r1, #1
  size_t len = 0;
  // Skip leading spaces.
  while (*path == ' ') {
    737a:	ldrb	r3, [r0, #0]
    737c:	cmp	r3, #32
    737e:	beq.n	7376 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    7380:	ldr	r7, [pc, #128]	; (7404 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x94>)
    path++;
  }
  fname->begin = path;
    7382:	str	r0, [r4, #0]
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            FatName_t* fname, const char** ptr) {
  size_t len = 0;
    7384:	movs	r5, #0
  // Skip leading spaces.
  while (*path == ' ') {
    path++;
  }
  fname->begin = path;
  while (*path && !isDirSeparator(*path)) {
    7386:	ldrb	r3, [r0, #0]
    7388:	cbz	r3, 73dc <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6c>
    738a:	cmp	r3, #47	; 0x2f
    738c:	beq.n	73dc <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6c>
#if USE_UTF8_LONG_NAMES
    uint32_t cp;
    // Allow end = path + 4 since path is zero terminated.
    path = FsUtf::mbToCp(path, path + 4, &cp);
    738e:	add	r2, sp, #4
    7390:	adds	r1, r0, #4
    7392:	bl	3580 <FsUtf::mbToCp(char const*, char const*, unsigned long*)>
    if (!path) {
    7396:	cbz	r0, 73fc <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    len += cp <= 0XFFFF ? 1 : 2;
    7398:	ldr	r2, [sp, #4]
    739a:	cmp.w	r2, #65536	; 0x10000
    739e:	ite	cs
    73a0:	movcs	r3, #2
    73a2:	movcc	r3, #1
    if (cp < 0X80 && lfnReservedChar(cp)) {
    73a4:	cmp	r2, #127	; 0x7f
    path = FsUtf::mbToCp(path, path + 4, &cp);
    if (!path) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    len += cp <= 0XFFFF ? 1 : 2;
    73a6:	add	r5, r3
    if (cp < 0X80 && lfnReservedChar(cp)) {
    73a8:	bhi.n	73d2 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x62>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    73aa:	cmp	r2, #31
    73ac:	bls.n	73fc <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    73ae:	uxtb	r3, r2
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    73b0:	sub.w	r1, r3, #34	; 0x22
    73b4:	uxtb	r1, r1
    73b6:	cmp	r1, #29
    73b8:	bhi.n	73c2 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x52>
    73ba:	lsr.w	r1, r7, r1
    73be:	lsls	r1, r1, #31
    73c0:	bmi.n	73fc <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    73c2:	and.w	r3, r3, #191	; 0xbf
    73c6:	cmp	r3, #60	; 0x3c
    73c8:	beq.n	73fc <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    73ca:	cmp	r2, #92	; 0x5c
    73cc:	beq.n	73fc <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    len++;
#endif  // USE_UTF8_LONG_NAMES
    if (cp != '.' && cp != ' ') {
    73ce:	cmp	r2, #46	; 0x2e
    73d0:	beq.n	7386 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
    73d2:	cmp	r2, #32
    73d4:	beq.n	7386 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
      // Need to trim trailing dots spaces.
      fname->len = len;
    73d6:	str	r5, [r4, #16]
      fname->end = path;
    73d8:	str	r0, [r4, #8]
  // Skip leading spaces.
  while (*path == ' ') {
    path++;
  }
  fname->begin = path;
  while (*path && !isDirSeparator(*path)) {
    73da:	b.n	7386 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
      // Need to trim trailing dots spaces.
      fname->len = len;
      fname->end = path;
    }
  }
  if (!fname->len || fname->len > FAT_MAX_LFN_LENGTH) {
    73dc:	ldr	r3, [r4, #16]
    73de:	subs	r3, #1
    73e0:	cmp	r3, #254	; 0xfe
    73e2:	bhi.n	73fc <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    73e4:	mov	r2, r0
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
    73e6:	ldrb.w	r3, [r0], #1
    73ea:	cmp	r3, #32
    73ec:	beq.n	73e4 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x74>
    73ee:	cmp	r3, #47	; 0x2f
    73f0:	beq.n	73e4 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x74>
  *ptr = path;
    73f2:	str	r2, [r6, #0]
  return makeSFN(fname);
    73f4:	mov	r0, r4
    73f6:	bl	6f64 <FatFile::makeSFN(FatName_t*)>
    73fa:	b.n	73fe <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8e>

 fail:
  return false;
    73fc:	movs	r0, #0
}
    73fe:	add	sp, #12
    7400:	pop	{r4, r5, r6, r7, pc}
    7402:	nop
    7404:	.word	0x31002101

00007408 <FatFile::remove()>:
//------------------------------------------------------------------------------
bool FatFile::remove() {
    7408:	push	{r4, r5, r6, r7, lr}
    740a:	sub	sp, #44	; 0x2c
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    740c:	movs	r3, #0
    740e:	strb.w	r3, [sp, #4]
    7412:	strb.w	r3, [sp, #5]
    7416:	strb.w	r3, [sp, #6]
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    741a:	ldrb	r3, [r0, #2]
    741c:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::remove() {
    741e:	mov	r4, r0
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    7420:	bpl.n	7452 <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
    7422:	ldr	r1, [r0, #32]
    7424:	cbz	r1, 742e <FatFile::remove()+0x26>
    7426:	ldr	r0, [r0, #8]
    7428:	bl	6be6 <FatPartition::freeChain(unsigned long)>
    742c:	cbz	r0, 7452 <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Cache directory entry.
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    742e:	movs	r1, #1
    7430:	mov	r0, r4
    7432:	bl	5db0 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    7436:	mov	r5, r0
    7438:	cbz	r0, 7452 <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  checksum = lfnChecksum(dir->name);
    743a:	bl	6dd6 <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;
    743e:	movs	r6, #229	; 0xe5
    7440:	strb	r6, [r5, #0]

  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    7442:	movs	r3, #0
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  checksum = lfnChecksum(dir->name);
    7444:	mov	r7, r0

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;

  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    7446:	strb	r3, [r4, #0]
  m_flags = 0;
    7448:	strb	r3, [r4, #2]

  // Write entry to device.
  if (!m_vol->cacheSync()) {
    744a:	ldr	r0, [r4, #8]
    744c:	bl	5cc8 <FatPartition::cacheSync()>
    7450:	cbnz	r0, 7456 <FatFile::remove()+0x4e>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  return false;
    7452:	movs	r0, #0
    7454:	b.n	74b6 <FatFile::remove()+0xae>
  // Write entry to device.
  if (!m_vol->cacheSync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    7456:	ldrb	r3, [r4, #3]
    7458:	cbz	r3, 74b6 <FatFile::remove()+0xae>
    // Done, no LFN entries.
    return true;
  }
  if (!dirFile.openCluster(this)) {
    745a:	mov	r1, r4
    745c:	add	r0, sp, #4
    745e:	bl	5dfe <FatFile::openCluster(FatFile*)>
    7462:	cmp	r0, #0
    7464:	beq.n	7452 <FatFile::remove()+0x4a>
    7466:	movs	r5, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    7468:	ldrb	r3, [r4, #3]
    746a:	cmp	r3, r5
    746c:	bcc.n	7452 <FatFile::remove()+0x4a>
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.cacheDir(m_dirIndex - order));
    746e:	ldrh	r1, [r4, #4]
    7470:	subs	r1, r1, r5
    7472:	uxth	r1, r1
    7474:	add	r0, sp, #4
    7476:	bl	5b08 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    747a:	cmp	r0, #0
    747c:	beq.n	7452 <FatFile::remove()+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    747e:	ldrb	r3, [r0, #11]
    7480:	cmp	r3, #15
    7482:	bne.n	7452 <FatFile::remove()+0x4a>
        order != (ldir->order & 0X1F) ||
    7484:	ldrb	r2, [r0, #0]
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.cacheDir(m_dirIndex - order));
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    7486:	and.w	r3, r2, #31
    748a:	cmp	r5, r3
    748c:	bne.n	7452 <FatFile::remove()+0x4a>
        order != (ldir->order & 0X1F) ||
    748e:	ldrb	r3, [r0, #13]
    7490:	cmp	r3, r7
    7492:	bne.n	7452 <FatFile::remove()+0x4a>
        checksum != ldir->checksum) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    last = ldir->order & FAT_ORDER_LAST_LONG_ENTRY;
    ldir->order = FAT_NAME_DELETED;
    7494:	strb	r6, [r0, #0]
    m_vol->cacheDirty();
    7496:	ldr	r1, [r4, #8]
    7498:	ldrb.w	r3, [r1, #40]	; 0x28
    749c:	orr.w	r3, r3, #1
    74a0:	strb.w	r3, [r1, #40]	; 0x28
    if (last) {
    74a4:	lsls	r3, r2, #25
    74a6:	bpl.n	74b0 <FatFile::remove()+0xa8>
      if (!m_vol->cacheSync()) {
    74a8:	ldr	r0, [r4, #8]
    74aa:	bl	5cc8 <FatPartition::cacheSync()>
    74ae:	b.n	74b6 <FatFile::remove()+0xae>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    74b0:	adds	r5, #1
    74b2:	uxtb	r5, r5
    74b4:	b.n	7468 <FatFile::remove()+0x60>
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  return false;
}
    74b6:	add	sp, #44	; 0x2c
    74b8:	pop	{r4, r5, r6, r7, pc}

000074ba <FsBaseFile::FsBaseFile(FsBaseFile const&)>:
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    74ba:	push	{r3, r4, r5, r6, r7, lr}
    74bc:	movs	r4, #0
    74be:	str	r4, [r0, #56]	; 0x38
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    74c0:	ldr	r7, [r1, #56]	; 0x38
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    74c2:	str	r4, [r0, #60]	; 0x3c
    74c4:	mov	r6, r0
    74c6:	mov	r5, r1
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    74c8:	cbz	r7, 74ec <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x32>
    m_fFile = new (m_fileMem) FatFile;
    74ca:	mov	r1, r0
    74cc:	movs	r0, #36	; 0x24
    74ce:	bl	7704 <operator new(unsigned int, unsigned long*)>
    74d2:	strb	r4, [r0, #0]
    74d4:	strb	r4, [r0, #1]
    74d6:	strb	r4, [r0, #2]
    74d8:	str	r0, [r6, #56]	; 0x38
    *m_fFile = *from.m_fFile;
    74da:	ldr	r5, [r5, #56]	; 0x38
    74dc:	mov	r4, r0
    74de:	ldmia	r5!, {r0, r1, r2, r3}
    74e0:	stmia	r4!, {r0, r1, r2, r3}
    74e2:	ldmia	r5!, {r0, r1, r2, r3}
    74e4:	stmia	r4!, {r0, r1, r2, r3}
    74e6:	ldr	r3, [r5, #0]
    74e8:	str	r3, [r4, #0]
    74ea:	b.n	7518 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x5e>
  } else if (from.m_xFile) {
    74ec:	ldr	r3, [r1, #60]	; 0x3c
    74ee:	cbz	r3, 7518 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x5e>
    m_xFile = new (m_fileMem) ExFatFile;
    74f0:	mov	r1, r0
    74f2:	movs	r0, #56	; 0x38
    74f4:	bl	7704 <operator new(unsigned int, unsigned long*)>
    74f8:	strb.w	r7, [r0, #49]	; 0x31
    74fc:	strb.w	r7, [r0, #50]	; 0x32
    7500:	strb.w	r7, [r0, #51]	; 0x33
    7504:	str	r0, [r6, #60]	; 0x3c
    *m_xFile = *from.m_xFile;
    7506:	ldr	r3, [r5, #60]	; 0x3c
    7508:	add.w	r2, r3, #52	; 0x34
    750c:	ldr.w	r1, [r3], #4
    7510:	str.w	r1, [r0], #4
    7514:	cmp	r3, r2
    7516:	bne.n	750c <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x52>
  }
}
    7518:	mov	r0, r6
    751a:	pop	{r3, r4, r5, r6, r7, pc}

0000751c <FsBaseFile::close()>:
    *m_xFile = *from.m_xFile;
  }
  return *this;
}
//------------------------------------------------------------------------------
bool FsBaseFile::close() {
    751c:	push	{r4, lr}
    751e:	mov	r4, r0
  if (m_fFile && m_fFile->close()) {
    7520:	ldr	r0, [r0, #56]	; 0x38
    7522:	cbz	r0, 752a <FsBaseFile::close()+0xe>
    7524:	bl	62dc <FatFile::close()>
    7528:	cbnz	r0, 753a <FsBaseFile::close()+0x1e>
    m_fFile = nullptr;
    return true;
  }
  if (m_xFile && m_xFile->close()) {
    752a:	ldr	r0, [r4, #60]	; 0x3c
    752c:	cbz	r0, 7540 <FsBaseFile::close()+0x24>
    752e:	bl	40ce <ExFatFile::close()>
    7532:	cbz	r0, 7540 <FsBaseFile::close()+0x24>
    m_xFile = nullptr;
    7534:	movs	r3, #0
    7536:	str	r3, [r4, #60]	; 0x3c
    7538:	pop	{r4, pc}
  return *this;
}
//------------------------------------------------------------------------------
bool FsBaseFile::close() {
  if (m_fFile && m_fFile->close()) {
    m_fFile = nullptr;
    753a:	movs	r3, #0
    753c:	str	r3, [r4, #56]	; 0x38
    return true;
    753e:	pop	{r4, pc}
  }
  if (m_xFile && m_xFile->close()) {
    m_xFile = nullptr;
    return true;
  }
  return false;
    7540:	movs	r0, #0
}
    7542:	pop	{r4, pc}

00007544 <FsBaseFile::open(FsVolume*, char const*, int)>:
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
    7544:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7548:	mov	r4, r0
    754a:	mov	r7, r2
    754c:	mov	r8, r3
  if (!vol) {
    754e:	mov	r5, r1
    7550:	cbnz	r1, 7558 <FsBaseFile::open(FsVolume*, char const*, int)+0x14>
    return false;
    7552:	movs	r0, #0
    7554:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  close();
    7558:	bl	751c <FsBaseFile::close()>
  if (vol->m_fVol) {
    755c:	ldr.w	r6, [r5, #1152]	; 0x480
    7560:	cbz	r6, 7588 <FsBaseFile::open(FsVolume*, char const*, int)+0x44>
    m_fFile = new (m_fileMem) FatFile;
    7562:	mov	r1, r4
    7564:	movs	r0, #36	; 0x24
    7566:	bl	7704 <operator new(unsigned int, unsigned long*)>
    756a:	movs	r2, #0
    756c:	strb	r2, [r0, #0]
    756e:	strb	r2, [r0, #1]
    7570:	strb	r2, [r0, #2]
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    7572:	mov	r3, r8
  if (!vol) {
    return false;
  }
  close();
  if (vol->m_fVol) {
    m_fFile = new (m_fileMem) FatFile;
    7574:	str	r0, [r4, #56]	; 0x38
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    7576:	mov	r2, r7
    7578:	ldr.w	r1, [r5, #1152]	; 0x480
    757c:	bl	6394 <FatFile::open(FatVolume*, char const*, int)>
    7580:	cbz	r0, 75bc <FsBaseFile::open(FsVolume*, char const*, int)+0x78>
      return true;
    7582:	movs	r0, #1
    7584:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    m_fFile = nullptr;
  } else if (vol->m_xVol) {
    7588:	ldr.w	r3, [r5, #1156]	; 0x484
    758c:	cmp	r3, #0
    758e:	beq.n	7552 <FsBaseFile::open(FsVolume*, char const*, int)+0xe>
    m_xFile = new (m_fileMem) ExFatFile;
    7590:	mov	r1, r4
    7592:	movs	r0, #56	; 0x38
    7594:	bl	7704 <operator new(unsigned int, unsigned long*)>
    7598:	strb.w	r6, [r0, #49]	; 0x31
    759c:	strb.w	r6, [r0, #50]	; 0x32
    75a0:	strb.w	r6, [r0, #51]	; 0x33
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    75a4:	mov	r3, r8
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
      return true;
    }
    m_fFile = nullptr;
  } else if (vol->m_xVol) {
    m_xFile = new (m_fileMem) ExFatFile;
    75a6:	str	r0, [r4, #60]	; 0x3c
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    75a8:	mov	r2, r7
    75aa:	ldr.w	r1, [r5, #1156]	; 0x484
    75ae:	bl	484e <ExFatFile::open(ExFatVolume*, char const*, int)>
    75b2:	cmp	r0, #0
    75b4:	bne.n	7582 <FsBaseFile::open(FsVolume*, char const*, int)+0x3e>
      return true;
    }
    m_xFile = nullptr;
    75b6:	str	r0, [r4, #60]	; 0x3c
  }
  return false;
}
    75b8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (vol->m_fVol) {
    m_fFile = new (m_fileMem) FatFile;
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
      return true;
    }
    m_fFile = nullptr;
    75bc:	str	r0, [r4, #56]	; 0x38
    75be:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000075c2 <FsBaseFile::openNext(FsBaseFile*, int)>:
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::openNext(FsBaseFile* dir, oflag_t oflag) {
    75c2:	push	{r3, r4, r5, r6, r7, lr}
    75c4:	mov	r5, r1
    75c6:	mov	r4, r0
    75c8:	mov	r7, r2
  close();
    75ca:	bl	751c <FsBaseFile::close()>
  if (dir->m_fFile) {
    75ce:	ldr	r6, [r5, #56]	; 0x38
    75d0:	cbz	r6, 75f6 <FsBaseFile::openNext(FsBaseFile*, int)+0x34>
    m_fFile = new (m_fileMem) FatFile;
    75d2:	mov	r1, r4
    75d4:	movs	r0, #36	; 0x24
    75d6:	bl	7704 <operator new(unsigned int, unsigned long*)>
    75da:	movs	r2, #0
    75dc:	strb	r2, [r0, #0]
    75de:	strb	r2, [r0, #1]
    75e0:	strb	r2, [r0, #2]
    75e2:	str	r0, [r4, #56]	; 0x38
    if (m_fFile->openNext(dir->m_fFile, oflag)) {
    75e4:	mov	r2, r7
    75e6:	ldr	r1, [r5, #56]	; 0x38
    75e8:	bl	6174 <FatFile::openNext(FatFile*, int)>
    75ec:	cbz	r0, 75f2 <FsBaseFile::openNext(FsBaseFile*, int)+0x30>
      return true;
    75ee:	movs	r0, #1
    75f0:	pop	{r3, r4, r5, r6, r7, pc}
    }
    m_fFile = nullptr;
    75f2:	str	r0, [r4, #56]	; 0x38
    75f4:	pop	{r3, r4, r5, r6, r7, pc}
  } else if (dir->m_xFile) {
    75f6:	ldr	r0, [r5, #60]	; 0x3c
    75f8:	cbz	r0, 761e <FsBaseFile::openNext(FsBaseFile*, int)+0x5c>
    m_xFile = new (m_fileMem) ExFatFile;
    75fa:	mov	r1, r4
    75fc:	movs	r0, #56	; 0x38
    75fe:	bl	7704 <operator new(unsigned int, unsigned long*)>
    7602:	strb.w	r6, [r0, #49]	; 0x31
    7606:	strb.w	r6, [r0, #50]	; 0x32
    760a:	strb.w	r6, [r0, #51]	; 0x33
    760e:	str	r0, [r4, #60]	; 0x3c
    if (m_xFile->openNext(dir->m_xFile, oflag)) {
    7610:	mov	r2, r7
    7612:	ldr	r1, [r5, #60]	; 0x3c
    7614:	bl	485c <ExFatFile::openNext(ExFatFile*, int)>
    7618:	cmp	r0, #0
    761a:	bne.n	75ee <FsBaseFile::openNext(FsBaseFile*, int)+0x2c>
      return true;
    }
    m_xFile = nullptr;
    761c:	str	r0, [r4, #60]	; 0x3c
  }
  return false;
}
    761e:	pop	{r3, r4, r5, r6, r7, pc}

00007620 <FsVolume::begin(BlockDeviceInterface*)>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    7620:	push	{r3, r4, r5, r6, r7, lr}
  m_blockDev = blockDev;
  m_fVol = nullptr;
    7622:	movs	r6, #0
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    7624:	mov	r4, r0
  m_blockDev = blockDev;
    7626:	str.w	r1, [r0, #1160]	; 0x488
  m_fVol = nullptr;
    762a:	str.w	r6, [r0, #1152]	; 0x480
  m_xVol = new (m_volMem) ExFatVolume;
    762e:	mov	r1, r0
    7630:	mov.w	r0, #1152	; 0x480
    7634:	bl	7704 <operator new(unsigned int, unsigned long*)>
 * \class ExFatPartition
 * \brief Access exFat partitions on raw file devices.
 */
class ExFatPartition {
 public:
  ExFatPartition() {}
    7638:	strb.w	r6, [r0, #1092]	; 0x444
    763c:	strb.w	r6, [r0, #1145]	; 0x479
    7640:	strb.w	r6, [r0, #1146]	; 0x47a
    7644:	strb.w	r6, [r0, #1147]	; 0x47b
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    7648:	movs	r2, #1
    764a:	str.w	r0, [r4, #1156]	; 0x484
    764e:	ldr.w	r1, [r4, #1160]	; 0x488
    7652:	ldr	r7, [pc, #124]	; (76d0 <FsVolume::begin(BlockDeviceInterface*)+0xb0>)
    7654:	mov	r5, r0
    7656:	bl	4bb4 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>
    765a:	cbz	r0, 7674 <FsVolume::begin(BlockDeviceInterface*)+0x54>
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    765c:	add.w	r6, r5, #1096	; 0x448
    7660:	mov	r0, r6
    7662:	bl	40ce <ExFatFile::close()>
    return m_vwd.openRoot(this);
    7666:	mov	r1, r5
    7668:	mov	r0, r6
    766a:	bl	4122 <ExFatFile::openRoot(ExFatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    766e:	cbz	r0, 7674 <FsVolume::begin(BlockDeviceInterface*)+0x54>
      return false;
    }
    if (setCwv || !m_cwv) {
    7670:	ldr	r3, [pc, #96]	; (76d4 <FsVolume::begin(BlockDeviceInterface*)+0xb4>)
    7672:	b.n	76ba <FsVolume::begin(BlockDeviceInterface*)+0x9a>
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    7674:	movs	r6, #0
  m_fVol = new (m_volMem) FatVolume;
    7676:	mov	r1, r4
  m_fVol = nullptr;
  m_xVol = new (m_volMem) ExFatVolume;
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    7678:	str.w	r6, [r4, #1156]	; 0x484
  m_fVol = new (m_volMem) FatVolume;
    767c:	movw	r0, #1132	; 0x46c
    7680:	bl	7704 <operator new(unsigned int, unsigned long*)>
 */
class FatPartition {
 public:
  /** Create an instance of FatPartition
   */
  FatPartition() {}
    7684:	strb	r6, [r0, #7]
    7686:	strb.w	r6, [r0, #1096]	; 0x448
    768a:	strb.w	r6, [r0, #1097]	; 0x449
    768e:	strb.w	r6, [r0, #1098]	; 0x44a
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    7692:	movs	r2, #1
    7694:	str.w	r0, [r4, #1152]	; 0x480
    7698:	ldr.w	r1, [r4, #1160]	; 0x488
    769c:	mov	r5, r0
    769e:	bl	6c88 <FatPartition::init(BlockDeviceInterface*, unsigned char)>
    76a2:	cbz	r0, 76c6 <FsVolume::begin(BlockDeviceInterface*)+0xa6>
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    76a4:	add.w	r6, r5, #1096	; 0x448
    76a8:	mov	r0, r6
    76aa:	bl	62dc <FatFile::close()>
    return m_vwd.openRoot(this);
    76ae:	mov	r1, r5
    76b0:	mov	r0, r6
    76b2:	bl	5dce <FatFile::openRoot(FatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    76b6:	cbz	r0, 76c6 <FsVolume::begin(BlockDeviceInterface*)+0xa6>
      return false;
    }
    if (setCwv || !m_cwv) {
    76b8:	ldr	r3, [pc, #28]	; (76d8 <FsVolume::begin(BlockDeviceInterface*)+0xb8>)
    76ba:	ldr	r2, [r3, #0]
    76bc:	cbnz	r2, 76c0 <FsVolume::begin(BlockDeviceInterface*)+0xa0>
      m_cwv = this;
    76be:	str	r5, [r3, #0]
  m_cwv = nullptr;
  m_fVol = nullptr;
  return false;

 done:
  m_cwv = this;
    76c0:	str	r4, [r7, #0]
  return true;
    76c2:	movs	r0, #1
    76c4:	pop	{r3, r4, r5, r6, r7, pc}
  m_xVol = nullptr;
  m_fVol = new (m_volMem) FatVolume;
  if (m_fVol && m_fVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_cwv = nullptr;
    76c6:	movs	r0, #0
    76c8:	str	r0, [r7, #0]
  m_fVol = nullptr;
    76ca:	str.w	r0, [r4, #1152]	; 0x480
  return false;

 done:
  m_cwv = this;
  return true;
}
    76ce:	pop	{r3, r4, r5, r6, r7, pc}
    76d0:	.word	0x2001a69c
    76d4:	.word	0x2001a694
    76d8:	.word	0x2001a698

000076dc <FsVolume::open(char const*, int)>:
bool FsVolume::ls(print_t* pr, const char* path, uint8_t flags) {
  FsBaseFile dir;
  return dir.open(this, path, O_RDONLY) && dir.ls(pr, flags);
}
//------------------------------------------------------------------------------
FsFile FsVolume::open(const char *path, oflag_t oflag) {
    76dc:	push	{r3, r4, r5, lr}
    76de:	mov	r4, r0
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    76e0:	movs	r0, #0
    76e2:	strb	r0, [r4, #4]
    76e4:	strb	r0, [r4, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
    76e6:	str	r0, [r4, #72]	; 0x48
    76e8:	str	r0, [r4, #76]	; 0x4c
    76ea:	mov.w	r5, #1000	; 0x3e8
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    76ee:	mov	r0, r4
    76f0:	str	r5, [r4, #8]
    76f2:	ldr	r5, [pc, #12]	; (7700 <FsVolume::open(char const*, int)+0x24>)
    76f4:	str.w	r5, [r0], #16
  FsFile tmpFile;
  tmpFile.open(this, path, oflag);
    76f8:	bl	7544 <FsBaseFile::open(FsVolume*, char const*, int)>
  return tmpFile;
}
    76fc:	mov	r0, r4
    76fe:	pop	{r3, r4, r5, pc}
    7700:	.word	0x00012554

00007704 <operator new(unsigned int, unsigned long*)>:
 */
#include "FsNew.h"
void* operator new(size_t size, newalign_t* ptr) {
  (void)size;
  return ptr;
}
    7704:	mov	r0, r1
    7706:	bx	lr

00007708 <SdSpiCard::errorCode() const>:
  /**
   * \return code for the last error. See SdCardInfo.h for a list of error codes.
   */
  uint8_t errorCode() const {
    return m_errorCode;
  }
    7708:	ldrb	r0, [r0, #15]
    770a:	bx	lr

0000770c <SdSpiCard::errorData() const>:
  /** \return error data for last error. */
  uint32_t errorData() const {
    return m_status;
  }
    770c:	ldrb	r0, [r0, #17]
    770e:	bx	lr

00007710 <SdSpiCard::readSector(unsigned long, unsigned char*)>:
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    7710:	ldr	r3, [r0, #0]
   *
   * \param[in] sector Logical sector to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
    7712:	push	{r4}
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    7714:	ldr	r4, [r3, #16]
    7716:	movs	r3, #1
    7718:	mov	ip, r4
#else  // ENABLE_DEDICATED_SPI
    return readSingle(sector, dst);
#endif  // ENABLE_DEDICATED_SPI
  }
    771a:	ldr.w	r4, [sp], #4
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    771e:	bx	ip

00007720 <SdSpiCard::type() const>:
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
  }
    7720:	ldrb	r0, [r0, #18]
    7722:	bx	lr

00007724 <SdSpiCard::~SdSpiCard()>:
/**
 * \class SdSpiCard
 * \brief Raw access to SD and SDHC flash memory cards via SPI protocol.
 */
#if HAS_SDIO_CLASS
class SdSpiCard : public SdCardInterface {
    7724:	bx	lr

00007726 <SdSpiCard::~SdSpiCard()>:
    7726:	push	{r4, lr}
    7728:	movs	r1, #20
    772a:	mov	r4, r0
    772c:	bl	a3e0 <operator delete(void*, unsigned int)>
    7730:	mov	r0, r4
    7732:	pop	{r4, pc}

00007734 <SdSpiCard::sectorCount()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
uint32_t SdSpiCard::sectorCount() {
    7734:	push	{r0, r1, r2, r3, r4, lr}
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
    7736:	ldr	r3, [r0, #0]
    7738:	mov	r1, sp
    773a:	ldr	r3, [r3, #60]	; 0x3c
    773c:	blx	r3
    773e:	cbz	r0, 77ae <SdSpiCard::sectorCount()+0x7a>
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    7740:	ldrb.w	r3, [sp]
    7744:	ands.w	r3, r3, #192	; 0xc0
    7748:	bne.n	778a <SdSpiCard::sectorCount()+0x56>
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    774a:	ldrb.w	r0, [sp, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    774e:	ldrb.w	r3, [sp, #7]
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    7752:	ldrb.w	r2, [sp, #10]
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7756:	and.w	r0, r0, #3
    775a:	lsls	r3, r3, #2
    775c:	orr.w	r3, r3, r0, lsl #10
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    7760:	ldrb.w	r0, [sp, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7764:	orr.w	r0, r3, r0, lsr #6
    7768:	adds	r3, r0, #1
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    776a:	ldrb.w	r0, [sp, #9]
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    776e:	and.w	r0, r0, #3
    7772:	lsls	r0, r0, #1
    7774:	orr.w	r0, r0, r2, lsr #7
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    7778:	ldrb.w	r2, [sp, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    777c:	and.w	r2, r2, #15
    7780:	add	r0, r2
    7782:	subs	r0, #7
    7784:	lsl.w	r0, r3, r0
    7788:	b.n	77ae <SdSpiCard::sectorCount()+0x7a>
  } else if (csd->v2.csd_ver == 1) {
    778a:	cmp	r3, #64	; 0x40
    778c:	bne.n	77ac <SdSpiCard::sectorCount()+0x78>
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    778e:	ldrb.w	r0, [sp, #9]
    7792:	adds	r3, r0, #1
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    7794:	ldrb.w	r0, [sp, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    7798:	and.w	r0, r0, #63	; 0x3f
    779c:	add.w	r0, r3, r0, lsl #16
    77a0:	ldrb.w	r3, [sp, #8]
    77a4:	add.w	r0, r0, r3, lsl #8
    77a8:	lsls	r0, r0, #10
    77aa:	b.n	77ae <SdSpiCard::sectorCount()+0x7a>
    77ac:	movs	r0, #0
}
    77ae:	add	sp, #20
    77b0:	ldr.w	pc, [sp], #4

000077b4 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>:
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spiDriverPtr->receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriverPtr->send(data);
    77b4:	ldr	r3, [r0, #0]
    77b6:	ldr	r3, [r3, #20]
    77b8:	bx	r3

000077ba <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>:
  }
  void spiDeactivate() {
    m_spiDriverPtr->deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriverPtr->receive();
    77ba:	ldr	r3, [r0, #0]
    77bc:	ldr	r3, [r3, #12]
    77be:	bx	r3

000077c0 <SysCall::curTimeMS()>:
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    77c0:	ldr	r3, [pc, #12]	; (77d0 <SysCall::curTimeMS()+0x10>)
/** Define macro for strings stored in flash. */
#define F(str) (str)
#endif  // F
//------------------------------------------------------------------------------
/** \return the time in milliseconds. */
inline SdMillis_t SysCall::curTimeMS() {
    77c2:	sub	sp, #8
    77c4:	ldr	r3, [r3, #0]
    77c6:	str	r3, [sp, #4]
	return ret;
    77c8:	ldr	r0, [sp, #4]
  return millis();
}
    77ca:	uxth	r0, r0
    77cc:	add	sp, #8
    77ce:	bx	lr
    77d0:	.word	0x2001a6fc

000077d4 <SdSpiCard::spiStart()>:
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
    77d4:	push	{r3, r4, r5, lr}
  if (!m_spiActive) {
    77d6:	ldrb	r5, [r0, #16]
uint32_t SdSpiCard::sectorCount() {
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
    77d8:	mov	r4, r0
  if (!m_spiActive) {
    77da:	cbnz	r5, 77f8 <SdSpiCard::spiStart()+0x24>
    77dc:	ldr	r0, [r0, #4]
    m_spiDriver.setSckSpeed(maxSck);
  }
  SdSpiDriver m_spiDriver;
#else  // SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriverPtr->activate();
    77de:	ldr	r3, [r0, #0]
    77e0:	ldr	r3, [r3, #0]
    77e2:	blx	r3
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    77e4:	mov	r1, r5
    77e6:	ldrb	r0, [r4, #14]
    77e8:	bl	1b3c <sdCsWrite(unsigned char, bool)>
    spiActivate();
    spiSelect();
    // Dummy byte to drive MISO busy status.
    spiSend(0XFF);    
    77ec:	movs	r1, #255	; 0xff
    77ee:	ldr	r0, [r4, #4]
    77f0:	bl	77b4 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    m_spiActive = true;
    77f4:	movs	r3, #1
    77f6:	strb	r3, [r4, #16]
    77f8:	pop	{r3, r4, r5, pc}

000077fa <SdSpiCard::spiStop()>:
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    77fa:	ldrb	r3, [r0, #16]
    spiSend(0XFF);    
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
    77fc:	push	{r4, lr}
    77fe:	mov	r4, r0
  if (m_spiActive) {
    7800:	cbz	r3, 781e <SdSpiCard::spiStop()+0x24>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    7802:	movs	r1, #1
    7804:	ldrb	r0, [r0, #14]
    7806:	bl	1b3c <sdCsWrite(unsigned char, bool)>
    spiUnselect();
    // Insure MISO goes to low Z.
    spiSend(0XFF);        
    780a:	movs	r1, #255	; 0xff
    780c:	ldr	r0, [r4, #4]
    780e:	bl	77b4 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    7812:	ldr	r0, [r4, #4]
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriverPtr->begin(spiConfig);
  }
  void spiDeactivate() {
    m_spiDriverPtr->deactivate();
    7814:	ldr	r3, [r0, #0]
    7816:	ldr	r3, [r3, #8]
    7818:	blx	r3
    spiDeactivate();
    m_spiActive = false;
    781a:	movs	r3, #0
    781c:	strb	r3, [r4, #16]
    781e:	pop	{r4, pc}

00007820 <SdSpiCard::isBusy()>:
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    7820:	push	{r4, r5, r6, lr}
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    7822:	ldrb	r3, [r0, #12]
    7824:	cmp	r3, #1
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    7826:	mov	r5, r0
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    7828:	beq.n	784a <SdSpiCard::isBusy()+0x2a>
    return false;
  }
#endif  // ENABLE_DEDICATED_SPI
  bool spiActive = m_spiActive;
    782a:	ldrb	r6, [r0, #16]
  if (!spiActive) {
    782c:	cbnz	r6, 7832 <SdSpiCard::isBusy()+0x12>
    spiStart();
    782e:	bl	77d4 <SdSpiCard::spiStart()>
  }
  bool rtn = 0XFF != spiReceive();
    7832:	ldr	r0, [r5, #4]
    7834:	bl	77ba <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7838:	subs.w	r4, r0, #255	; 0xff
    783c:	it	ne
    783e:	movne	r4, #1
  if (!spiActive) {
    7840:	cbnz	r6, 784e <SdSpiCard::isBusy()+0x2e>
    spiStop();
    7842:	mov	r0, r5
    7844:	bl	77fa <SdSpiCard::spiStop()>
    7848:	b.n	784e <SdSpiCard::isBusy()+0x2e>
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    return false;
    784a:	movs	r0, #0
    784c:	pop	{r4, r5, r6, pc}
  }
  bool rtn = 0XFF != spiReceive();
  if (!spiActive) {
    spiStop();
  }
  return rtn;
    784e:	mov	r0, r4
}
    7850:	pop	{r4, r5, r6, pc}

00007852 <SdSpiCard::readData(unsigned char*, unsigned int)>:
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst) {
  return readData(dst, 512);
}
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst, size_t count) {
    7852:	push	{r3, r4, r5, r6, r7, lr}
    7854:	mov	r4, r0
    7856:	mov	r5, r1
    7858:	mov	r6, r2
  uint16_t crc;
#endif  // USE_SD_CRC

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
    785a:	bl	77c0 <SysCall::curTimeMS()>
    785e:	mov	r7, r0
  while ((m_status = spiReceive()) == 0XFF) {
    7860:	ldr	r0, [r4, #4]
    7862:	bl	77ba <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7866:	cmp	r0, #255	; 0xff
    7868:	strb	r0, [r4, #17]
    786a:	bne.n	787c <SdSpiCard::readData(unsigned char*, unsigned int)+0x2a>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    786c:	bl	77c0 <SysCall::curTimeMS()>

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
  while ((m_status = spiReceive()) == 0XFF) {
    if (isTimedOut(t0, SD_READ_TIMEOUT)) {
    7870:	subs	r0, r0, r7
    7872:	cmp.w	r0, #300	; 0x12c
    7876:	ble.n	7860 <SdSpiCard::readData(unsigned char*, unsigned int)+0xe>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7878:	movs	r3, #29
    787a:	b.n	7896 <SdSpiCard::readData(unsigned char*, unsigned int)+0x44>
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
    }
  }
  DBG_END_TIME(DBG_WAIT_READ);
  if (m_status != DATA_START_SECTOR) {
    787c:	cmp	r0, #254	; 0xfe
    787e:	beq.n	7884 <SdSpiCard::readData(unsigned char*, unsigned int)+0x32>
    7880:	movs	r3, #24
    7882:	b.n	7896 <SdSpiCard::readData(unsigned char*, unsigned int)+0x44>
    7884:	ldr	r0, [r4, #4]
  }
  uint8_t spiReceive() {
    return m_spiDriverPtr->receive();
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spiDriverPtr->receive(buf, n);
    7886:	ldr	r3, [r0, #0]
    7888:	mov	r2, r6
    788a:	ldr	r3, [r3, #16]
    788c:	mov	r1, r5
    788e:	blx	r3
    error(SD_CARD_ERROR_READ_TOKEN);
    goto fail;
  }
  // transfer data
  if ((m_status = spiReceive(dst, count))) {
    7890:	strb	r0, [r4, #17]
    7892:	cbz	r0, 78a2 <SdSpiCard::readData(unsigned char*, unsigned int)+0x50>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7894:	movs	r3, #37	; 0x25
  spiReceive();
#endif  // USE_SD_CRC
  return true;

 fail:
  spiStop();
    7896:	mov	r0, r4
    7898:	strb	r3, [r4, #15]
    789a:	bl	77fa <SdSpiCard::spiStop()>
  return false;
    789e:	movs	r0, #0
}
    78a0:	pop	{r3, r4, r5, r6, r7, pc}
    error(SD_CARD_ERROR_READ_CRC);
    goto fail;
  }
#else  // USE_SD_CRC
  // discard crc
  spiReceive();
    78a2:	ldr	r0, [r4, #4]
    78a4:	bl	77ba <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
  spiReceive();
    78a8:	ldr	r0, [r4, #4]
    78aa:	bl	77ba <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    78ae:	movs	r0, #1
    78b0:	pop	{r3, r4, r5, r6, r7, pc}

000078b2 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    78b2:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    78b6:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    78b8:	ldrb	r3, [r0, #12]
    78ba:	cmp	r3, #2
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    78bc:	mov	r4, r0
    78be:	mov	r5, r1
    78c0:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    78c2:	bne.n	78ca <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x18>
    78c4:	ldr	r3, [r0, #8]
    78c6:	cmp	r3, r1
    78c8:	beq.n	78dc <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2a>
    if (!writeStart(sector)) {
    78ca:	ldr	r3, [r4, #0]
    78cc:	mov	r1, r5
    78ce:	ldr	r3, [r3, #80]	; 0x50
    78d0:	mov	r0, r4
    78d2:	blx	r3
    78d4:	cbz	r0, 790a <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x58>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
    78d6:	movs	r3, #2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    if (!writeStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    78d8:	str	r5, [r4, #8]
    m_curState = WRITE_STATE;
    78da:	strb	r3, [r4, #12]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    78dc:	movs	r5, #0
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    78de:	cmp	r5, r7
    78e0:	add.w	r1, r6, r5, lsl #9
    78e4:	beq.n	78f4 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x42>
    if (!writeData(src)) {
    78e6:	ldr	r3, [r4, #0]
    78e8:	mov	r0, r4
    78ea:	ldr	r3, [r3, #76]	; 0x4c
    78ec:	blx	r3
    78ee:	cbz	r0, 790a <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x58>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    78f0:	adds	r5, #1
    78f2:	b.n	78de <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2c>
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    78f4:	ldr	r3, [r4, #8]
    78f6:	add	r5, r3
  return m_sharedSpi ? syncDevice() : true;
    78f8:	ldrb	r3, [r4, #13]
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    78fa:	str	r5, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    78fc:	cbz	r3, 7916 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x64>
    78fe:	ldr	r3, [r4, #0]
    7900:	mov	r0, r4
    7902:	ldr	r3, [r3, #28]
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    7904:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7908:	bx	r3
  }
  return writeStop();
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
    790a:	mov	r0, r4
    790c:	bl	77fa <SdSpiCard::spiStop()>
  return false;
    7910:	movs	r0, #0
    7912:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7916:	movs	r0, #1
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    7918:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000791c <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)>:
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    791c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7920:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    7922:	ldrb	r3, [r0, #12]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    7924:	ldr.w	r8, [sp, #32]
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    7928:	cmp	r3, #2
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    792a:	mov	r4, r0
    792c:	mov	r5, r1
    792e:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    7930:	bne.n	7938 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x1c>
    7932:	ldr	r3, [r0, #8]
    7934:	cmp	r3, r1
    7936:	beq.n	794a <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x2e>
    if (!writeStart(sector)) {
    7938:	ldr	r3, [r4, #0]
    793a:	mov	r1, r5
    793c:	ldr	r3, [r3, #80]	; 0x50
    793e:	mov	r0, r4
    7940:	blx	r3
    7942:	cbz	r0, 7980 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x64>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
    7944:	movs	r3, #2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    if (!writeStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    7946:	str	r5, [r4, #8]
    m_curState = WRITE_STATE;
    7948:	strb	r3, [r4, #12]
    794a:	add.w	r9, r5, r6
  }
  for (size_t i = 0; i < ns; i++) {
    794e:	cmp	r5, r9
    7950:	beq.n	796a <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x4e>
    const uint8_t *src = callback(sector + i, context);
    7952:	mov	r1, r8
    7954:	mov	r0, r5
    7956:	blx	r7
    if (!writeData(src)) {
    7958:	ldr	r3, [r4, #0]
    795a:	mov	r1, r0
    795c:	ldr	r3, [r3, #76]	; 0x4c
    795e:	mov	r0, r4
    7960:	blx	r3
    7962:	adds	r5, #1
    7964:	cmp	r0, #0
    7966:	bne.n	794e <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x32>
    7968:	b.n	7980 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x64>
      goto fail;
    }
  }
  m_curSector += ns;
    796a:	ldr	r3, [r4, #8]
    796c:	add	r6, r3
  return m_sharedSpi ? syncDevice() : true;
    796e:	ldrb	r3, [r4, #13]
    const uint8_t *src = callback(sector + i, context);
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
    7970:	str	r6, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    7972:	cbz	r3, 798c <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x70>
    7974:	ldr	r3, [r4, #0]
    7976:	mov	r0, r4
    7978:	ldr	r3, [r3, #28]
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    797a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    797e:	bx	r3
  }
  return writeStop();
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
    7980:	mov	r0, r4
    7982:	bl	77fa <SdSpiCard::spiStop()>
  return false;
    7986:	movs	r0, #0
    7988:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    798c:	movs	r0, #1
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    798e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00007992 <SdSpiCard::waitNotBusy(unsigned short)>:
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
//------------------------------------------------------------------------------
// wait for card to go not busy
bool SdSpiCard::waitNotBusy(SdMillis_t timeoutMS) {
    7992:	push	{r4, r5, r6, lr}
    7994:	mov	r6, r0
    7996:	mov	r4, r1
  SdMillis_t t0 = SysCall::curTimeMS();
    7998:	bl	77c0 <SysCall::curTimeMS()>
    799c:	mov	r5, r0
    }
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    799e:	ldr	r0, [r6, #4]
    79a0:	bl	77ba <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    79a4:	cmp	r0, #255	; 0xff
    79a6:	beq.n	79b6 <SdSpiCard::waitNotBusy(unsigned short)+0x24>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    79a8:	bl	77c0 <SysCall::curTimeMS()>
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    if (isTimedOut(t0, timeoutMS)) {
    79ac:	subs	r0, r0, r5
    79ae:	cmp	r0, r4
    79b0:	ble.n	799e <SdSpiCard::waitNotBusy(unsigned short)+0xc>
      return false;
    79b2:	movs	r0, #0
    79b4:	pop	{r4, r5, r6, pc}
    }
  }
  return true;
    79b6:	movs	r0, #1
#endif  // WDT_YIELD_TIME_MILLIS
}
    79b8:	pop	{r4, r5, r6, pc}

000079ba <SdSpiCard::cardCommand(unsigned char, unsigned long)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    79ba:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    79bc:	ldrb	r3, [r0, #12]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    79be:	str	r2, [sp, #4]
    79c0:	mov	r4, r0
    79c2:	mov	r5, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    79c4:	cbz	r3, 79d2 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x18>
    79c6:	ldr	r3, [r0, #0]
    79c8:	ldr	r3, [r3, #28]
    79ca:	blx	r3
    79cc:	cbnz	r0, 79d2 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x18>
    return 0XFF;
    79ce:	movs	r0, #255	; 0xff
    79d0:	b.n	7a32 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x78>
  }
#endif  // ENABLE_DEDICATED_SPI
  // select card
  if (!m_spiActive) {
    79d2:	ldrb	r3, [r4, #16]
    79d4:	cbnz	r3, 79dc <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x22>
    spiStart();
    79d6:	mov	r0, r4
    79d8:	bl	77d4 <SdSpiCard::spiStart()>
  }
  // wait if busy unless CMD0
  if (cmd != CMD0) {
    79dc:	cbz	r5, 79e8 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x2e>
    DBG_BEGIN_TIME(DBG_CMD_BUSY);
    waitNotBusy(SD_CMD_TIMEOUT);
    79de:	mov.w	r1, #300	; 0x12c
    79e2:	mov	r0, r4
    79e4:	bl	7992 <SdSpiCard::waitNotBusy(unsigned short)>

  // send message
  spiSend(buf, 6);
#else  // USE_SD_CRC
  // send command
  spiSend(cmd | 0x40);
    79e8:	orr.w	r1, r5, #64	; 0x40
    79ec:	ldr	r0, [r4, #4]
    79ee:	bl	77b4 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    79f2:	add.w	r6, sp, #7
    79f6:	add.w	r7, sp, #3

  // send argument
  uint8_t* pa = reinterpret_cast<uint8_t*>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    spiSend(pa[i]);
    79fa:	ldrb.w	r1, [r6], #-1
    79fe:	ldr	r0, [r4, #4]
    7a00:	bl	77b4 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
  // send command
  spiSend(cmd | 0x40);

  // send argument
  uint8_t* pa = reinterpret_cast<uint8_t*>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    7a04:	cmp	r7, r6
    7a06:	bne.n	79fa <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x40>
    spiSend(pa[i]);
  }

  // send CRC - correct for CMD0 with arg zero or CMD8 with arg 0X1AA
  spiSend(cmd == CMD0 ? 0X95 : 0X87);
    7a08:	cmp	r5, #0
    7a0a:	ite	eq
    7a0c:	moveq	r1, #149	; 0x95
    7a0e:	movne	r1, #135	; 0x87
    7a10:	ldr	r0, [r4, #4]
    7a12:	bl	77b4 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
#endif  // USE_SD_CRC

  // discard first fill byte to avoid MISO pull-up problem.
  spiReceive();
    7a16:	ldr	r0, [r4, #4]
    7a18:	bl	77ba <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7a1c:	movs	r5, #11

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
    7a1e:	ldr	r0, [r4, #4]
    7a20:	bl	77ba <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7a24:	lsls	r3, r0, #24
    7a26:	strb	r0, [r4, #17]
    7a28:	bpl.n	7a32 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x78>
    7a2a:	subs	r5, #1
    7a2c:	ands.w	r5, r5, #255	; 0xff
    7a30:	bne.n	7a1e <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x64>
  }
  return m_status;
}
    7a32:	add	sp, #12
    7a34:	pop	{r4, r5, r6, r7, pc}

00007a36 <SdSpiCard::cardAcmd(unsigned char, unsigned long)>:
  /** Set CS high and deactivate the card. */
  void spiStop();

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    7a36:	push	{r4, r5, r6, lr}
    7a38:	mov	r4, r0
    7a3a:	mov	r5, r1
    7a3c:	mov	r6, r2
    cardCommand(CMD55, 0);
    7a3e:	movs	r1, #55	; 0x37
    7a40:	movs	r2, #0
    7a42:	bl	79ba <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    return cardCommand(cmd, arg);
    7a46:	mov	r2, r6
    7a48:	mov	r1, r5
    7a4a:	mov	r0, r4
  }
    7a4c:	ldmia.w	sp!, {r4, r5, r6, lr}

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    cardCommand(CMD55, 0);
    return cardCommand(cmd, arg);
    7a50:	b.w	79ba <SdSpiCard::cardCommand(unsigned char, unsigned long)>

00007a54 <SdSpiCard::begin(SdSpiConfig)>:
#endif  // CRC_CCITT
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
    7a54:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7a58:	sub	sp, #36	; 0x24
    7a5a:	add	r5, sp, #4
    7a5c:	stmia.w	r5, {r1, r2, r3}
    7a60:	mov	r4, r0
    7a62:	ldrb.w	sl, [sp, #4]
    7a66:	ldr.w	fp, [sp, #12]
    7a6a:	ldrb.w	r8, [sp, #5]
    7a6e:	ldr	r6, [sp, #8]
  SdMillis_t t0 = SysCall::curTimeMS();
    7a70:	bl	77c0 <SysCall::curTimeMS()>
  m_spiActive = false;
    7a74:	mov.w	r9, #0
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
  SdMillis_t t0 = SysCall::curTimeMS();
    7a78:	mov	r7, r0
  m_spiActive = false;
    7a7a:	strb.w	r9, [r4, #16]
  m_errorCode = SD_CARD_ERROR_NONE;
    7a7e:	strb.w	r9, [r4, #15]
  m_type = 0;
    7a82:	strb.w	r9, [r4, #18]
  m_csPin = spiConfig.csPin;
    7a86:	strb.w	sl, [r4, #14]
#if SPI_DRIVER_SELECT >= 2
  m_spiDriverPtr = spiConfig.spiPort;
    7a8a:	str.w	fp, [r4, #4]
  if (!m_spiDriverPtr) {
    7a8e:	cmp.w	fp, #0
    7a92:	bne.n	7a98 <SdSpiCard::begin(SdSpiConfig)+0x44>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7a94:	movs	r3, #42	; 0x2a
    7a96:	b.n	7bcc <SdSpiCard::begin(SdSpiConfig)+0x178>
    error(SD_CARD_ERROR_INVALID_CARD_CONFIG);
    goto fail;
  }
#endif  // SPI_DRIVER_SELECT
  sdCsInit(m_csPin);
    7a98:	mov	r0, sl
    7a9a:	bl	1b20 <sdCsInit(unsigned char)>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    7a9e:	movs	r1, #1
    7aa0:	ldrb	r0, [r4, #14]
    7aa2:	bl	1b3c <sdCsWrite(unsigned char, bool)>
    7aa6:	ldr	r0, [r4, #4]
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
  }
  void spiSetSckSpeed(uint32_t maxSck) {
    m_spiDriverPtr->setSckSpeed(maxSck);
    7aa8:	ldr	r1, [pc, #344]	; (7c04 <SdSpiCard::begin(SdSpiConfig)+0x1b0>)
    7aaa:	ldr	r3, [r0, #0]
    7aac:	ldr	r3, [r3, #28]
    7aae:	blx	r3
    7ab0:	ldmia.w	r5, {r0, r1, r2}
    7ab4:	add	r3, sp, #20
    7ab6:	ldr.w	lr, [r4, #4]
    7aba:	stmia.w	r3, {r0, r1, r2}
#else  // SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriverPtr->activate();
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriverPtr->begin(spiConfig);
    7abe:	ldr.w	r2, [lr]
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
  m_sharedSpi = spiOptionShared(spiConfig.options);
    7ac2:	and.w	r8, r8, #1
    7ac6:	mov	r0, lr
    7ac8:	ldr	r5, [r2, #4]
    7aca:	eor.w	r8, r8, #1
    7ace:	ldmia	r3, {r1, r2, r3}
    7ad0:	blx	r5
#else  // ENABLE_DEDICATED_SPI
  // m_sharedSpi is a static const bool in this case.
  static_assert(m_sharedSpi == true, "m_sharedSpi bug");
#endif  // ENABLE_DEDICATED_SPI
  spiStart();
    7ad2:	mov	r0, r4
  spiUnselect();
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
    7ad4:	strb.w	r9, [r4, #12]
  m_sharedSpi = spiOptionShared(spiConfig.options);
    7ad8:	strb.w	r8, [r4, #13]
#else  // ENABLE_DEDICATED_SPI
  // m_sharedSpi is a static const bool in this case.
  static_assert(m_sharedSpi == true, "m_sharedSpi bug");
#endif  // ENABLE_DEDICATED_SPI
  spiStart();
    7adc:	bl	77d4 <SdSpiCard::spiStart()>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    7ae0:	movs	r1, #1
    7ae2:	ldrb	r0, [r4, #14]
    7ae4:	bl	1b3c <sdCsWrite(unsigned char, bool)>
    7ae8:	movs	r5, #10

  // must supply min of 74 clock cycles with CS high.
  spiUnselect();
  for (uint8_t i = 0; i < 10; i++) {
    spiSend(0XFF);
    7aea:	movs	r1, #255	; 0xff
    7aec:	ldr	r0, [r4, #4]
    7aee:	subs	r5, #1
    7af0:	bl	77b4 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
#endif  // ENABLE_DEDICATED_SPI
  spiStart();

  // must supply min of 74 clock cycles with CS high.
  spiUnselect();
  for (uint8_t i = 0; i < 10; i++) {
    7af4:	ands.w	r5, r5, #255	; 0xff
    7af8:	bne.n	7aea <SdSpiCard::begin(SdSpiConfig)+0x96>
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    7afa:	mov	r1, r5
    7afc:	ldrb	r0, [r4, #14]
    7afe:	bl	1b3c <sdCsWrite(unsigned char, bool)>
    7b02:	movs	r5, #10
  spiSelect();
  DBG_BEGIN_TIME(DBG_CMD0_TIME);
  // command to go idle in SPI mode
  for (uint8_t i = 1;; i++) {
    DBG_EVENT_COUNT(DBG_CMD0_COUNT);
    if (cardCommand(CMD0, 0) == R1_IDLE_STATE) {
    7b04:	movs	r2, #0
    7b06:	mov	r1, r2
    7b08:	mov	r0, r4
    7b0a:	bl	79ba <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7b0e:	cmp	r0, #1
    7b10:	mov	r8, r0
    7b12:	beq.n	7b3a <SdSpiCard::begin(SdSpiConfig)+0xe6>
    7b14:	subs	r5, #1
      break;
    }
    if (i == SD_CMD0_RETRY) {
    7b16:	ands.w	r5, r5, #255	; 0xff
    7b1a:	bne.n	7b20 <SdSpiCard::begin(SdSpiConfig)+0xcc>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7b1c:	movs	r3, #1
    7b1e:	b.n	7bcc <SdSpiCard::begin(SdSpiConfig)+0x178>
      error(SD_CARD_ERROR_CMD0);
      goto fail;
    }
    // stop multi-block write
    spiSend(STOP_TRAN_TOKEN);
    7b20:	movs	r1, #253	; 0xfd
    7b22:	ldr	r0, [r4, #4]
    7b24:	bl	77b4 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    7b28:	mov.w	r8, #520	; 0x208
    // finish block transfer
    for (int i = 0; i < 520; i++) {
      spiReceive();
    7b2c:	ldr	r0, [r4, #4]
    7b2e:	bl	77ba <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
      goto fail;
    }
    // stop multi-block write
    spiSend(STOP_TRAN_TOKEN);
    // finish block transfer
    for (int i = 0; i < 520; i++) {
    7b32:	subs.w	r8, r8, #1
    7b36:	bne.n	7b2c <SdSpiCard::begin(SdSpiConfig)+0xd8>
    7b38:	b.n	7b04 <SdSpiCard::begin(SdSpiConfig)+0xb0>
    goto fail;
  }
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    7b3a:	mov.w	r2, #426	; 0x1aa
    7b3e:	movs	r1, #8
    7b40:	mov	r0, r4
    7b42:	bl	79ba <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7b46:	lsls	r3, r0, #29
    7b48:	bmi.n	7b68 <SdSpiCard::begin(SdSpiConfig)+0x114>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    7b4a:	movs	r3, #2
    7b4c:	strb	r3, [r4, #18]
    7b4e:	movs	r5, #4
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
      m_status = spiReceive();
    7b50:	ldr	r0, [r4, #4]
    7b52:	bl	77ba <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7b56:	subs	r5, #1
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    7b58:	ands.w	r5, r5, #255	; 0xff
      m_status = spiReceive();
    7b5c:	strb	r0, [r4, #17]
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    7b5e:	bne.n	7b50 <SdSpiCard::begin(SdSpiConfig)+0xfc>
      m_status = spiReceive();
    }
    if (m_status != 0XAA) {
    7b60:	cmp	r0, #170	; 0xaa
    7b62:	beq.n	7b6c <SdSpiCard::begin(SdSpiConfig)+0x118>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7b64:	movs	r3, #6
    7b66:	b.n	7bcc <SdSpiCard::begin(SdSpiConfig)+0x178>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    7b68:	strb.w	r8, [r4, #18]
    }
  } else {
    type(SD_CARD_TYPE_SD1);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
    7b6c:	ldr	r3, [r4, #0]
    7b6e:	mov	r0, r4
    7b70:	ldr	r3, [r3, #72]	; 0x48
    7b72:	blx	r3
    7b74:	cmp	r0, #2
    7b76:	ite	eq
    7b78:	moveq.w	r8, #1073741824	; 0x40000000
    7b7c:	movne.w	r8, #0
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    7b80:	mov	r2, r8
    7b82:	movs	r1, #41	; 0x29
    7b84:	mov	r0, r4
    7b86:	bl	7a36 <SdSpiCard::cardAcmd(unsigned char, unsigned long)>
    7b8a:	mov	r5, r0
    7b8c:	cbz	r0, 7b9e <SdSpiCard::begin(SdSpiConfig)+0x14a>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    7b8e:	bl	77c0 <SysCall::curTimeMS()>
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    DBG_EVENT_COUNT(DBG_ACMD41_COUNT);
    // check for timeout
    if (isTimedOut(t0, SD_INIT_TIMEOUT)) {
    7b92:	subs	r0, r0, r7
    7b94:	cmp.w	r0, #2000	; 0x7d0
    7b98:	ble.n	7b80 <SdSpiCard::begin(SdSpiConfig)+0x12c>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7b9a:	movs	r3, #23
    7b9c:	b.n	7bcc <SdSpiCard::begin(SdSpiConfig)+0x178>
    }
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    7b9e:	ldr	r3, [r4, #0]
    7ba0:	mov	r0, r4
    7ba2:	ldr	r3, [r3, #72]	; 0x48
    7ba4:	blx	r3
    7ba6:	cmp	r0, #2
    7ba8:	beq.n	7bbe <SdSpiCard::begin(SdSpiConfig)+0x16a>
    // Discard rest of ocr - contains allowed voltage range.
    for (uint8_t i = 0; i < 3; i++) {
      spiReceive();
    }
  }
  spiStop();
    7baa:	mov	r0, r4
    7bac:	bl	77fa <SdSpiCard::spiStop()>
    7bb0:	ldr	r0, [r4, #4]
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
  }
  void spiSetSckSpeed(uint32_t maxSck) {
    m_spiDriverPtr->setSckSpeed(maxSck);
    7bb2:	ldr	r3, [r0, #0]
    7bb4:	mov	r1, r6
    7bb6:	ldr	r3, [r3, #28]
    7bb8:	blx	r3
  spiSetSckSpeed(spiConfig.maxSck);
  return true;
    7bba:	movs	r0, #1
    7bbc:	b.n	7bfe <SdSpiCard::begin(SdSpiConfig)+0x1aa>
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
    7bbe:	mov	r2, r5
    7bc0:	movs	r1, #58	; 0x3a
    7bc2:	mov	r0, r4
    7bc4:	bl	79ba <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7bc8:	cbz	r0, 7bd8 <SdSpiCard::begin(SdSpiConfig)+0x184>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7bca:	movs	r3, #18
  spiStop();
  spiSetSckSpeed(spiConfig.maxSck);
  return true;

 fail:
  spiStop();
    7bcc:	mov	r0, r4
    7bce:	strb	r3, [r4, #15]
    7bd0:	bl	77fa <SdSpiCard::spiStop()>
  return false;
    7bd4:	movs	r0, #0
    7bd6:	b.n	7bfe <SdSpiCard::begin(SdSpiConfig)+0x1aa>
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
      error(SD_CARD_ERROR_CMD58);
      goto fail;
    }
    if ((spiReceive() & 0XC0) == 0XC0) {
    7bd8:	ldr	r0, [r4, #4]
    7bda:	bl	77ba <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7bde:	and.w	r0, r0, #192	; 0xc0
    7be2:	cmp	r0, #192	; 0xc0
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    7be4:	itt	eq
    7be6:	moveq	r3, #3
    7be8:	strbeq	r3, [r4, #18]
      type(SD_CARD_TYPE_SDHC);
    }
    // Discard rest of ocr - contains allowed voltage range.
    for (uint8_t i = 0; i < 3; i++) {
      spiReceive();
    7bea:	ldr	r0, [r4, #4]
    7bec:	bl	77ba <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7bf0:	ldr	r0, [r4, #4]
    7bf2:	bl	77ba <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7bf6:	ldr	r0, [r4, #4]
    7bf8:	bl	77ba <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7bfc:	b.n	7baa <SdSpiCard::begin(SdSpiConfig)+0x156>
  return true;

 fail:
  spiStop();
  return false;
}
    7bfe:	add	sp, #36	; 0x24
    7c00:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7c04:	.word	0x00061a80

00007c08 <SdSpiCard::readOCR(unsigned long*)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7c08:	push	{r4, r5, r6, lr}
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    7c0a:	movs	r2, #0
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7c0c:	mov	r6, r1
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    7c0e:	movs	r1, #58	; 0x3a
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7c10:	mov	r4, r0
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    7c12:	bl	79ba <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7c16:	cbz	r0, 7c26 <SdSpiCard::readOCR(unsigned long*)+0x1e>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7c18:	movs	r3, #18
  }
  spiStop();
  return true;

 fail:
  spiStop();
    7c1a:	mov	r0, r4
    7c1c:	strb	r3, [r4, #15]
    7c1e:	bl	77fa <SdSpiCard::spiStop()>
  return false;
    7c22:	movs	r0, #0
    7c24:	pop	{r4, r5, r6, pc}
    7c26:	adds	r5, r6, #4
  if (cardCommand(CMD58, 0)) {
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    p[3 - i] = spiReceive();
    7c28:	ldr	r0, [r4, #4]
    7c2a:	bl	77ba <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7c2e:	strb.w	r0, [r5, #-1]!
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    7c32:	cmp	r5, r6
    7c34:	bne.n	7c28 <SdSpiCard::readOCR(unsigned long*)+0x20>
    p[3 - i] = spiReceive();
  }
  spiStop();
    7c36:	mov	r0, r4
    7c38:	bl	77fa <SdSpiCard::spiStop()>
  return true;
    7c3c:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7c3e:	pop	{r4, r5, r6, pc}

00007c40 <SdSpiCard::readRegister(unsigned char, void*)>:
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    7c40:	push	{r3, r4, r5, lr}
    7c42:	mov	r5, r2
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    7c44:	movs	r2, #0
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    7c46:	mov	r4, r0
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    7c48:	bl	79ba <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7c4c:	cbz	r0, 7c54 <SdSpiCard::readRegister(unsigned char, void*)+0x14>
    7c4e:	movs	r3, #27
    7c50:	strb	r3, [r4, #15]
    7c52:	b.n	7c6a <SdSpiCard::readRegister(unsigned char, void*)+0x2a>
    error(SD_CARD_ERROR_READ_REG);
    goto fail;
  }
  if (!readData(dst, 16)) {
    7c54:	mov	r1, r5
    7c56:	movs	r2, #16
    7c58:	mov	r0, r4
    7c5a:	bl	7852 <SdSpiCard::readData(unsigned char*, unsigned int)>
    7c5e:	mov	r5, r0
    7c60:	cbz	r0, 7c6a <SdSpiCard::readRegister(unsigned char, void*)+0x2a>
    goto fail;
  }
  spiStop();
    7c62:	mov	r0, r4
    7c64:	bl	77fa <SdSpiCard::spiStop()>
  return true;
    7c68:	b.n	7c72 <SdSpiCard::readRegister(unsigned char, void*)+0x32>

 fail:
  spiStop();
    7c6a:	mov	r0, r4
    7c6c:	bl	77fa <SdSpiCard::spiStop()>
  return false;
    7c70:	movs	r5, #0
}
    7c72:	mov	r0, r5
    7c74:	pop	{r3, r4, r5, pc}

00007c76 <SdSpiCard::readCSD(csd_t*)>:
   * \param[out] csd pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCSD(csd_t* csd) {
    return readRegister(CMD9, csd);
    7c76:	mov	r2, r1
    7c78:	movs	r1, #9
    7c7a:	b.w	7c40 <SdSpiCard::readRegister(unsigned char, void*)>

00007c7e <SdSpiCard::readCID(CID*)>:
   * \param[out] cid pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCID(cid_t* cid) {
    return readRegister(CMD10, cid);
    7c7e:	mov	r2, r1
    7c80:	movs	r1, #10
    7c82:	b.w	7c40 <SdSpiCard::readRegister(unsigned char, void*)>

00007c86 <SdSpiCard::readStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    7c86:	push	{r3, r4, r5, lr}
  if (type() != SD_CARD_TYPE_SDHC) {
    7c88:	ldr	r3, [r0, #0]
    7c8a:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    7c8c:	mov	r5, r1
    7c8e:	mov	r4, r0
  if (type() != SD_CARD_TYPE_SDHC) {
    7c90:	blx	r3
    7c92:	cmp	r0, #3
    sector <<= 9;
    7c94:	it	ne
    7c96:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD18, sector)) {
    7c98:	mov	r2, r5
    7c9a:	movs	r1, #18
    7c9c:	mov	r0, r4
    7c9e:	bl	79ba <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7ca2:	cbz	r0, 7cb2 <SdSpiCard::readStart(unsigned long)+0x2c>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7ca4:	movs	r3, #12
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7ca6:	mov	r0, r4
    7ca8:	strb	r3, [r4, #15]
    7caa:	bl	77fa <SdSpiCard::spiStop()>
  return false;
    7cae:	movs	r0, #0
    7cb0:	pop	{r3, r4, r5, pc}
  }
  if (cardCommand(CMD18, sector)) {
    error(SD_CARD_ERROR_CMD18);
    goto fail;
  }
  return true;
    7cb2:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7cb4:	pop	{r3, r4, r5, pc}

00007cb6 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    7cb6:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7cba:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7cbc:	ldrb	r3, [r0, #12]
    7cbe:	cmp	r3, #1
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    7cc0:	mov	r4, r0
    7cc2:	mov	r5, r1
    7cc4:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7cc6:	bne.n	7cce <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x18>
    7cc8:	ldr	r3, [r0, #8]
    7cca:	cmp	r3, r1
    7ccc:	beq.n	7ce4 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x2e>
    if (!readStart(sector)) {
    7cce:	mov	r1, r5
    7cd0:	mov	r0, r4
    7cd2:	bl	7c86 <SdSpiCard::readStart(unsigned long)>
    7cd6:	cbnz	r0, 7cde <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x28>
    }
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
    7cd8:	movs	r0, #0
    7cda:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
    7cde:	movs	r3, #1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    7ce0:	str	r5, [r4, #8]
    m_curState = READ_STATE;
    7ce2:	strb	r3, [r4, #12]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    7ce4:	movs	r5, #0
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    7ce6:	cmp	r5, r7
    7ce8:	add.w	r1, r6, r5, lsl #9
    7cec:	beq.n	7d00 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4a>
    if (!readData(dst, 512)) {
    7cee:	mov.w	r2, #512	; 0x200
    7cf2:	mov	r0, r4
    7cf4:	bl	7852 <SdSpiCard::readData(unsigned char*, unsigned int)>
    7cf8:	cmp	r0, #0
    7cfa:	beq.n	7cd8 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x22>
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    7cfc:	adds	r5, #1
    7cfe:	b.n	7ce6 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x30>
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    7d00:	ldr	r3, [r4, #8]
    7d02:	add	r5, r3
  return m_sharedSpi ? syncDevice() : true;
    7d04:	ldrb	r3, [r4, #13]
  for (size_t i = 0; i < ns; i++, dst += 512) {
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    7d06:	str	r5, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    7d08:	cbz	r3, 7d16 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x60>
    7d0a:	ldr	r3, [r4, #0]
    7d0c:	mov	r0, r4
    7d0e:	ldr	r3, [r3, #28]
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7d10:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7d14:	bx	r3
    7d16:	movs	r0, #1
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7d18:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00007d1c <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)>:
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7d1c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7d20:	mov	r6, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7d22:	ldrb	r3, [r0, #12]
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7d24:	ldr.w	r8, [sp, #32]
    7d28:	ldr.w	r9, [sp, #36]	; 0x24
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7d2c:	cmp	r3, #1
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7d2e:	mov	r4, r0
    7d30:	mov	r5, r1
    7d32:	mov	r7, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7d34:	bne.n	7d3c <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x20>
    7d36:	ldr	r3, [r0, #8]
    7d38:	cmp	r3, r1
    7d3a:	beq.n	7d52 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x36>
    if (!readStart(sector)) {
    7d3c:	mov	r1, r5
    7d3e:	mov	r0, r4
    7d40:	bl	7c86 <SdSpiCard::readStart(unsigned long)>
    7d44:	cbnz	r0, 7d4c <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x30>
    }
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
    7d46:	movs	r0, #0
    7d48:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
    7d4c:	movs	r3, #1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    7d4e:	str	r5, [r4, #8]
    m_curState = READ_STATE;
    7d50:	strb	r3, [r4, #12]
    7d52:	add.w	sl, r5, r6
  }
  for (size_t i = 0; i < ns; i++) {
    7d56:	cmp	r5, sl
    7d58:	beq.n	7d76 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x5a>
    if (readData(dst, 512)) {
    7d5a:	mov.w	r2, #512	; 0x200
    7d5e:	mov	r1, r7
    7d60:	mov	r0, r4
    7d62:	bl	7852 <SdSpiCard::readData(unsigned char*, unsigned int)>
    7d66:	cmp	r0, #0
    7d68:	beq.n	7d46 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x2a>
      callback(sector + i, dst, context);
    7d6a:	mov	r0, r5
    7d6c:	mov	r2, r9
    7d6e:	mov	r1, r7
    7d70:	blx	r8
    7d72:	adds	r5, #1
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++) {
    7d74:	b.n	7d56 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x3a>
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    7d76:	ldr	r3, [r4, #8]
    7d78:	add	r6, r3
  return m_sharedSpi ? syncDevice() : true;
    7d7a:	ldrb	r3, [r4, #13]
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    7d7c:	str	r6, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    7d7e:	cbz	r3, 7d8c <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x70>
    7d80:	ldr	r3, [r4, #0]
    7d82:	mov	r0, r4
    7d84:	ldr	r3, [r3, #28]
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7d86:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7d8a:	bx	r3
    7d8c:	movs	r0, #1
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7d8e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00007d92 <SdSpiCard::readStop()>:
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    7d92:	push	{r4, lr}
  if (cardCommand(CMD12, 0)) {
    7d94:	movs	r2, #0
    7d96:	movs	r1, #12
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    7d98:	mov	r4, r0
  if (cardCommand(CMD12, 0)) {
    7d9a:	bl	79ba <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7d9e:	cbz	r0, 7dae <SdSpiCard::readStop()+0x1c>
    7da0:	movs	r3, #9
  }
  spiStop();
  return true;

 fail:
  spiStop();
    7da2:	mov	r0, r4
    7da4:	strb	r3, [r4, #15]
    7da6:	bl	77fa <SdSpiCard::spiStop()>
  return false;
    7daa:	movs	r0, #0
    7dac:	pop	{r4, pc}
bool SdSpiCard::readStop() {
  if (cardCommand(CMD12, 0)) {
    error(SD_CARD_ERROR_CMD12);
    goto fail;
  }
  spiStop();
    7dae:	mov	r0, r4
    7db0:	bl	77fa <SdSpiCard::spiStop()>
  return true;
    7db4:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7db6:	pop	{r4, pc}

00007db8 <SdSpiCard::syncDevice()>:
}
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
    7db8:	ldrb	r2, [r0, #12]
  m_curState = IDLE_STATE;
    7dba:	movs	r1, #0
  if (state == WRITE_STATE) {
    7dbc:	cmp	r2, #2
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
  m_curState = IDLE_STATE;
    7dbe:	strb	r1, [r0, #12]
  if (state == WRITE_STATE) {
    7dc0:	bne.n	7dc8 <SdSpiCard::syncDevice()+0x10>
    return writeStop();
    7dc2:	ldr	r3, [r0, #0]
    7dc4:	ldr	r3, [r3, #84]	; 0x54
    7dc6:	bx	r3
  }
  if (state == READ_STATE) {
    7dc8:	cmp	r2, #1
    7dca:	bne.n	7dd0 <SdSpiCard::syncDevice()+0x18>
    return readStop();
    7dcc:	b.w	7d92 <SdSpiCard::readStop()>
  }
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
    7dd0:	movs	r0, #1
    7dd2:	bx	lr

00007dd4 <SdSpiCard::writeStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    7dd4:	push	{r3, r4, r5, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7dd6:	ldr	r3, [r0, #0]
    7dd8:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    7dda:	mov	r5, r1
    7ddc:	mov	r4, r0
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7dde:	blx	r3
    7de0:	cmp	r0, #3
    sector <<= 9;
    7de2:	it	ne
    7de4:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD25, sector)) {
    7de6:	mov	r2, r5
    7de8:	movs	r1, #25
    7dea:	mov	r0, r4
    7dec:	bl	79ba <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7df0:	cbz	r0, 7e00 <SdSpiCard::writeStart(unsigned long)+0x2c>
    7df2:	movs	r3, #14
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7df4:	mov	r0, r4
    7df6:	strb	r3, [r4, #15]
    7df8:	bl	77fa <SdSpiCard::spiStop()>
  return false;
    7dfc:	movs	r0, #0
    7dfe:	pop	{r3, r4, r5, pc}
  }
  if (cardCommand(CMD25, sector)) {
    error(SD_CARD_ERROR_CMD25);
    goto fail;
  }
  return true;
    7e00:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7e02:	pop	{r3, r4, r5, pc}

00007e04 <SdSpiCard::erase(unsigned long, unsigned long)>:
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7e04:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  csd_t csd;
  if (!readCSD(&csd)) {
    7e06:	ldr	r3, [r0, #0]
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7e08:	mov	r6, r1
  csd_t csd;
  if (!readCSD(&csd)) {
    7e0a:	ldr	r3, [r3, #60]	; 0x3c
    7e0c:	mov	r1, sp
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7e0e:	mov	r4, r0
    7e10:	mov	r5, r2
  csd_t csd;
  if (!readCSD(&csd)) {
    7e12:	blx	r3
    7e14:	cbz	r0, 7e7c <SdSpiCard::erase(unsigned long, unsigned long)+0x78>
    goto fail;
  }
  // check for single sector erase
  if (!csd.v1.erase_blk_en) {
    7e16:	ldrb.w	r3, [sp, #10]
    7e1a:	lsls	r2, r3, #25
    7e1c:	bmi.n	7e38 <SdSpiCard::erase(unsigned long, unsigned long)+0x34>
    // erase size mask
    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
    7e1e:	ldrb.w	r2, [sp, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    7e22:	and.w	r3, r3, #63	; 0x3f
    7e26:	lsls	r3, r3, #1
    7e28:	orr.w	r3, r3, r2, lsr #7
    7e2c:	adds	r2, r5, #1
    7e2e:	orrs	r2, r6
    7e30:	tst	r3, r2
    7e32:	beq.n	7e38 <SdSpiCard::erase(unsigned long, unsigned long)+0x34>
    7e34:	movs	r3, #39	; 0x27
    7e36:	b.n	7e7a <SdSpiCard::erase(unsigned long, unsigned long)+0x76>
      // error card can't erase specified area
      error(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    7e38:	ldrb	r3, [r4, #18]
    7e3a:	cmp	r3, #3
    firstSector <<= 9;
    7e3c:	it	ne
    7e3e:	lslne	r6, r6, #9
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
    7e40:	mov	r2, r6
    7e42:	mov.w	r1, #32
    7e46:	mov	r0, r4
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
    7e48:	it	ne
    7e4a:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD32, firstSector)
    7e4c:	bl	79ba <SdSpiCard::cardCommand(unsigned char, unsigned long)>
      || cardCommand(CMD33, lastSector)
      || cardCommand(CMD38, 0)) {
    7e50:	cbnz	r0, 7e86 <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
      || cardCommand(CMD33, lastSector)
    7e52:	mov	r2, r5
    7e54:	movs	r1, #33	; 0x21
    7e56:	mov	r0, r4
    7e58:	bl	79ba <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7e5c:	mov	r2, r0
    7e5e:	cbnz	r0, 7e86 <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
      || cardCommand(CMD38, 0)) {
    7e60:	movs	r1, #38	; 0x26
    7e62:	mov	r0, r4
    7e64:	bl	79ba <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7e68:	cbnz	r0, 7e86 <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
    error(SD_CARD_ERROR_ERASE);
    goto fail;
  }
  DBG_BEGIN_TIME(DBG_ERASE_BUSY);
  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    7e6a:	movw	r1, #10000	; 0x2710
    7e6e:	mov	r0, r4
    7e70:	bl	7992 <SdSpiCard::waitNotBusy(unsigned short)>
    7e74:	mov	r5, r0
    7e76:	cbnz	r0, 7e8a <SdSpiCard::erase(unsigned long, unsigned long)+0x86>
    7e78:	movs	r3, #40	; 0x28
    7e7a:	strb	r3, [r4, #15]
  DBG_END_TIME(DBG_ERASE_BUSY);
  spiStop();
  return true;

 fail:
  spiStop();
    7e7c:	mov	r0, r4
    7e7e:	bl	77fa <SdSpiCard::spiStop()>
  return false;
    7e82:	movs	r5, #0
    7e84:	b.n	7e90 <SdSpiCard::erase(unsigned long, unsigned long)+0x8c>
    7e86:	movs	r3, #38	; 0x26
    7e88:	b.n	7e7a <SdSpiCard::erase(unsigned long, unsigned long)+0x76>
  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    error(SD_CARD_ERROR_ERASE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_ERASE_BUSY);
  spiStop();
    7e8a:	mov	r0, r4
    7e8c:	bl	77fa <SdSpiCard::spiStop()>
  return true;

 fail:
  spiStop();
  return false;
}
    7e90:	mov	r0, r5
    7e92:	add	sp, #16
    7e94:	pop	{r4, r5, r6, pc}

00007e96 <SdSpiCard::writeStop()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    7e96:	push	{r3, r4, r5, lr}
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7e98:	mov.w	r1, #600	; 0x258
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    7e9c:	mov	r4, r0
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7e9e:	bl	7992 <SdSpiCard::waitNotBusy(unsigned short)>
    7ea2:	mov	r5, r0
    7ea4:	cbz	r0, 7eb0 <SdSpiCard::writeStop()+0x1a>
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_STOP);
  spiSend(STOP_TRAN_TOKEN);
    7ea6:	movs	r1, #253	; 0xfd
    7ea8:	ldr	r0, [r4, #4]
    7eaa:	bl	77b4 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    7eae:	b.n	7eb4 <SdSpiCard::writeStop()+0x1e>
    7eb0:	movs	r3, #30
    7eb2:	strb	r3, [r4, #15]
  spiStop();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
    7eb4:	mov	r0, r4
    7eb6:	bl	77fa <SdSpiCard::spiStop()>
  return false;
}
    7eba:	mov	r0, r5
    7ebc:	pop	{r3, r4, r5, pc}

00007ebe <SdSpiCard::writeData(unsigned char, unsigned char const*)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one sector of data for write sector or write multiple sectors
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    7ebe:	push	{r3, r4, r5, lr}
    7ec0:	mov	r4, r0
#if USE_SD_CRC
  uint16_t crc = CRC_CCITT(src, 512);
#else  // USE_SD_CRC
  uint16_t crc = 0XFFFF;
#endif  // USE_SD_CRC
  spiSend(token);
    7ec2:	ldr	r0, [r0, #4]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one sector of data for write sector or write multiple sectors
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    7ec4:	mov	r5, r2
#if USE_SD_CRC
  uint16_t crc = CRC_CCITT(src, 512);
#else  // USE_SD_CRC
  uint16_t crc = 0XFFFF;
#endif  // USE_SD_CRC
  spiSend(token);
    7ec6:	bl	77b4 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    7eca:	ldr	r0, [r4, #4]
  }
  void spiSend(uint8_t data) {
    m_spiDriverPtr->send(data);
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
    7ecc:	ldr	r3, [r0, #0]
    7ece:	mov.w	r2, #512	; 0x200
    7ed2:	ldr	r3, [r3, #24]
    7ed4:	mov	r1, r5
    7ed6:	blx	r3
  spiSend(src, 512);
  spiSend(crc >> 8);
    7ed8:	movs	r1, #255	; 0xff
    7eda:	ldr	r0, [r4, #4]
    7edc:	bl	77b4 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
  spiSend(crc & 0XFF);
    7ee0:	movs	r1, #255	; 0xff
    7ee2:	ldr	r0, [r4, #4]
    7ee4:	bl	77b4 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>

  m_status = spiReceive();
    7ee8:	ldr	r0, [r4, #4]
    7eea:	bl	77ba <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7eee:	strb	r0, [r4, #17]
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    7ef0:	and.w	r0, r0, #31
    7ef4:	cmp	r0, #5
    7ef6:	beq.n	7f06 <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x48>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7ef8:	movs	r3, #32
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7efa:	mov	r0, r4
    7efc:	strb	r3, [r4, #15]
    7efe:	bl	77fa <SdSpiCard::spiStop()>
  return false;
    7f02:	movs	r0, #0
    7f04:	pop	{r3, r4, r5, pc}
  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    error(SD_CARD_ERROR_WRITE_DATA);
    goto fail;
  }
  return true;
    7f06:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7f08:	pop	{r3, r4, r5, pc}

00007f0a <SdSpiCard::writeData(unsigned char const*)>:
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    7f0a:	push	{r3, r4, r5, lr}
    7f0c:	mov	r5, r1
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7f0e:	mov.w	r1, #600	; 0x258
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    7f12:	mov	r4, r0
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7f14:	bl	7992 <SdSpiCard::waitNotBusy(unsigned short)>
    7f18:	cbnz	r0, 7f20 <SdSpiCard::writeData(unsigned char const*)+0x16>
    7f1a:	movs	r3, #36	; 0x24
    7f1c:	strb	r3, [r4, #15]
    7f1e:	b.n	7f2c <SdSpiCard::writeData(unsigned char const*)+0x22>
    error(SD_CARD_ERROR_WRITE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_BUSY);
  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) {
    7f20:	mov	r2, r5
    7f22:	movs	r1, #252	; 0xfc
    7f24:	mov	r0, r4
    7f26:	bl	7ebe <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    7f2a:	cbnz	r0, 7f34 <SdSpiCard::writeData(unsigned char const*)+0x2a>
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7f2c:	mov	r0, r4
    7f2e:	bl	77fa <SdSpiCard::spiStop()>
  return false;
    7f32:	movs	r0, #0
}
    7f34:	pop	{r3, r4, r5, pc}

00007f36 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7f36:	ldr	r3, [r0, #0]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    7f38:	push	{r4, r5, r6, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7f3a:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    7f3c:	mov	r5, r1
    7f3e:	mov	r4, r0
    7f40:	mov	r6, r2
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7f42:	blx	r3
    7f44:	cmp	r0, #3
    sector <<= 9;
    7f46:	it	ne
    7f48:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD24, sector)) {
    7f4a:	mov	r2, r5
    7f4c:	movs	r1, #24
    7f4e:	mov	r0, r4
    7f50:	bl	79ba <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7f54:	cbz	r0, 7f5c <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x26>
    7f56:	movs	r3, #13
    7f58:	strb	r3, [r4, #15]
    7f5a:	b.n	7f72 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x3c>
    error(SD_CARD_ERROR_CMD24);
    goto fail;
  }
  if (!writeData(DATA_START_SECTOR, src)) {
    7f5c:	mov	r2, r6
    7f5e:	movs	r1, #254	; 0xfe
    7f60:	mov	r0, r4
    7f62:	bl	7ebe <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    7f66:	mov	r5, r0
    7f68:	cbz	r0, 7f72 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x3c>
    error(SD_CARD_ERROR_CMD13);
    goto fail;
  }
#endif  // CHECK_FLASH_PROGRAMMING

  spiStop();
    7f6a:	mov	r0, r4
    7f6c:	bl	77fa <SdSpiCard::spiStop()>
  return true;
    7f70:	b.n	7f7a <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x44>

 fail:
  spiStop();
    7f72:	mov	r0, r4
    7f74:	bl	77fa <SdSpiCard::spiStop()>
  return false;
    7f78:	movs	r5, #0
}
    7f7a:	mov	r0, r5
    7f7c:	pop	{r4, r5, r6, pc}

00007f7e <SdSpiCard::writeSector(unsigned long, unsigned char const*)>:
   *
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    7f7e:	push	{r4}
    if (m_sharedSpi) {
    7f80:	ldrb	r4, [r0, #13]
    7f82:	cbz	r4, 7f8c <SdSpiCard::writeSector(unsigned long, unsigned char const*)+0xe>
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    }
  }
    7f84:	ldr.w	r4, [sp], #4
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    7f88:	b.w	7f36 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>
    } else {
      return writeSectors(sector, src, 1);
    7f8c:	ldr	r3, [r0, #0]
    7f8e:	ldr	r4, [r3, #36]	; 0x24
    7f90:	movs	r3, #1
    7f92:	mov	ip, r4
    }
  }
    7f94:	ldr.w	r4, [sp], #4
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    7f98:	bx	ip
    7f9a:	Address 0x00007f9a is out of bounds.


00007f9c <sdIrs()>:
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
  SDHC_IRQSIGEN = 0;
    7f9c:	ldr	r2, [pc, #24]	; (7fb8 <sdIrs()+0x1c>)
  m_irqstat = SDHC_IRQSTAT;
    7f9e:	ldr	r1, [pc, #28]	; (7fbc <sdIrs()+0x20>)
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
  SDHC_IRQSIGEN = 0;
    7fa0:	movs	r3, #0
    7fa2:	str	r3, [r2, #0]
  m_irqstat = SDHC_IRQSTAT;
    7fa4:	ldr.w	r0, [r2, #-8]
    7fa8:	str	r0, [r1, #0]
  SDHC_IRQSTAT = m_irqstat;
    7faa:	ldr	r1, [r1, #0]
    7fac:	str.w	r1, [r2, #-8]
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN);
#endif
  m_dmaBusy = false;
    7fb0:	ldr	r2, [pc, #12]	; (7fc0 <sdIrs()+0x24>)
    7fb2:	strb	r3, [r2, #0]
    7fb4:	bx	lr
    7fb6:	nop
    7fb8:	.word	0x400b1038
    7fbc:	.word	0x2001a6c8
    7fc0:	.word	0x2001a6dd

00007fc4 <isBusyCommandComplete()>:
static bool isBusyCMD13() {
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
}
//------------------------------------------------------------------------------
static bool isBusyCommandComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_CC | SDHC_IRQSTAT_CMD_ERROR));
    7fc4:	ldr	r3, [pc, #12]	; (7fd4 <isBusyCommandComplete()+0x10>)
    7fc6:	ldr	r0, [pc, #16]	; (7fd8 <isBusyCommandComplete()+0x14>)
    7fc8:	ldr	r3, [r3, #0]
    7fca:	ands	r0, r3
}
    7fcc:	clz	r0, r0
    7fd0:	lsrs	r0, r0, #5
    7fd2:	bx	lr
    7fd4:	.word	0x400b1030
    7fd8:	.word	0x000f0001

00007fdc <isBusyCommandInhibit()>:
//------------------------------------------------------------------------------
static bool isBusyCommandInhibit() {
  return SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB;
    7fdc:	ldr	r3, [pc, #8]	; (7fe8 <isBusyCommandInhibit()+0xc>)
    7fde:	ldr	r0, [r3, #0]
}
    7fe0:	and.w	r0, r0, #1
    7fe4:	bx	lr
    7fe6:	nop
    7fe8:	.word	0x400b1024

00007fec <isBusyDat()>:
//------------------------------------------------------------------------------
static bool isBusyDat() {
  return SDHC_PRSSTAT & (1 << 24) ? false : true;
    7fec:	ldr	r3, [pc, #12]	; (7ffc <isBusyDat()+0x10>)
    7fee:	ldr	r0, [r3, #0]
    7ff0:	eor.w	r0, r0, #16777216	; 0x1000000
}
    7ff4:	ubfx	r0, r0, #24, #1
    7ff8:	bx	lr
    7ffa:	nop
    7ffc:	.word	0x400b1024

00008000 <isBusyDMA()>:
//------------------------------------------------------------------------------
static bool isBusyDMA() {
  return m_dmaBusy;
    8000:	ldr	r3, [pc, #4]	; (8008 <isBusyDMA()+0x8>)
    8002:	ldrb	r0, [r3, #0]
}
    8004:	bx	lr
    8006:	nop
    8008:	.word	0x2001a6dd

0000800c <isBusyFifoRead()>:
//------------------------------------------------------------------------------
static bool isBusyFifoRead() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BREN);
    800c:	ldr	r3, [pc, #12]	; (801c <isBusyFifoRead()+0x10>)
    800e:	ldr	r0, [r3, #0]
    8010:	eor.w	r0, r0, #2048	; 0x800
}
    8014:	ubfx	r0, r0, #11, #1
    8018:	bx	lr
    801a:	nop
    801c:	.word	0x400b1024

00008020 <isBusyFifoWrite()>:
//------------------------------------------------------------------------------
static bool isBusyFifoWrite() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN);
    8020:	ldr	r3, [pc, #12]	; (8030 <isBusyFifoWrite()+0x10>)
    8022:	ldr	r0, [r3, #0]
    8024:	eor.w	r0, r0, #1024	; 0x400
}
    8028:	ubfx	r0, r0, #10, #1
    802c:	bx	lr
    802e:	nop
    8030:	.word	0x400b1024

00008034 <isBusyTransferComplete()>:
//------------------------------------------------------------------------------
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
    8034:	ldr	r3, [pc, #12]	; (8044 <isBusyTransferComplete()+0x10>)
    8036:	ldr	r0, [pc, #16]	; (8048 <isBusyTransferComplete()+0x14>)
    8038:	ldr	r3, [r3, #0]
    803a:	ands	r0, r3
}
    803c:	clz	r0, r0
    8040:	lsrs	r0, r0, #5
    8042:	bx	lr
    8044:	.word	0x400b1030
    8048:	.word	0x117f0002

0000804c <setSdclk(unsigned long)>:
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    804c:	mov.w	r3, #1000	; 0x3e8
  }
  d[15] = 0;
  return true;
}
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
    8050:	push	{r4, r5, lr}
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    8052:	ldr	r4, [pc, #128]	; (80d4 <setSdclk(unsigned long)+0x88>)
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    8054:	muls	r0, r3
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
    8056:	movs	r2, #1
  uint32_t maxSdclk = 1000*kHzMax;
    8058:	movs	r3, #9
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    805a:	lsls	r1, r2, #4
    805c:	udiv	r1, r4, r1
    8060:	cmp	r0, r1
    8062:	bcc.n	806c <setSdclk(unsigned long)+0x20>
    8064:	movs	r4, #1
    8066:	mov	r3, r2
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    8068:	ldr	r5, [pc, #104]	; (80d4 <setSdclk(unsigned long)+0x88>)
    806a:	b.n	8080 <setSdclk(unsigned long)+0x34>
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    806c:	subs	r3, #1
    806e:	beq.n	8064 <setSdclk(unsigned long)+0x18>
    sdclkfs <<= 1;
    8070:	lsls	r2, r2, #1
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    8072:	b.n	805a <setSdclk(unsigned long)+0xe>
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    8074:	cmp	r4, #16
    8076:	add.w	r1, r3, r2
    807a:	beq.n	8088 <setSdclk(unsigned long)+0x3c>
    dvs++;
    807c:	adds	r4, #1
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    807e:	mov	r3, r1
    8080:	udiv	r1, r5, r3
    8084:	cmp	r0, r1
    8086:	bcc.n	8074 <setSdclk(unsigned long)+0x28>
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    8088:	mov.w	r1, #1000	; 0x3e8
    808c:	muls	r3, r1
    808e:	ldr	r1, [pc, #68]	; (80d4 <setSdclk(unsigned long)+0x88>)
    8090:	udiv	r3, r1, r3
    8094:	ldr	r1, [pc, #64]	; (80d8 <setSdclk(unsigned long)+0x8c>)
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    8096:	ldr	r0, [pc, #68]	; (80dc <setSdclk(unsigned long)+0x90>)
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    8098:	str	r3, [r1, #0]
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    809a:	ldr	r3, [r0, #0]
    809c:	bic.w	r3, r3, #8
    80a0:	str	r3, [r0, #0]
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)

  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
    80a2:	ldr	r1, [r0, #0]
                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    80a4:	bic.w	r3, r1, #1044480	; 0xff000
    80a8:	lsls	r2, r2, #7
    80aa:	bic.w	r3, r3, #4080	; 0xff0
    80ae:	orr.w	r3, r3, #917504	; 0xe0000
    80b2:	and.w	r2, r2, #65280	; 0xff00
    80b6:	orrs	r2, r3
    80b8:	subs	r3, r4, #1
    80ba:	orr.w	r3, r2, r3, lsl #4

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    80be:	ldr	r2, [pc, #32]	; (80e0 <setSdclk(unsigned long)+0x94>)
  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    80c0:	str	r3, [r0, #0]

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    80c2:	ldr	r3, [r2, #0]
    80c4:	lsls	r3, r3, #28
    80c6:	bpl.n	80c2 <setSdclk(unsigned long)+0x76>
  }

#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Enable the SDHC clock.
  SDHC_SYSCTL |= SDHC_SYSCTL_SDCLKEN;
    80c8:	ldr	r3, [r0, #0]
    80ca:	orr.w	r3, r3, #8
    80ce:	str	r3, [r0, #0]
    80d0:	pop	{r4, r5, pc}
    80d2:	nop
    80d4:	.word	0x05b8d800
    80d8:	.word	0x2001a6e0
    80dc:	.word	0x400b102c
    80e0:	.word	0x400b1024

000080e4 <SdioCard::errorCode() const>:
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::errorCode() const {
  return m_errorCode;
}
    80e4:	ldr	r3, [pc, #4]	; (80ec <SdioCard::errorCode() const+0x8>)
    80e6:	ldrb	r0, [r3, #0]
    80e8:	bx	lr
    80ea:	nop
    80ec:	.word	0x1fff1338

000080f0 <SdioCard::errorData() const>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorData() const {
  return m_irqstat;
    80f0:	ldr	r3, [pc, #4]	; (80f8 <SdioCard::errorData() const+0x8>)
    80f2:	ldr	r0, [r3, #0]
}
    80f4:	bx	lr
    80f6:	nop
    80f8:	.word	0x2001a6c8

000080fc <SdioCard::readCID(CID*)>:
uint32_t SdioCard::kHzSdClk() {
  return m_sdClkKhz;
}
//------------------------------------------------------------------------------
bool SdioCard::readCID(cid_t* cid) {
  memcpy(cid, &m_cid, 16);
    80fc:	ldr	r3, [pc, #20]	; (8114 <SdioCard::readCID(CID*)+0x18>)
    80fe:	add.w	r2, r3, #16
    8102:	ldr.w	r0, [r3], #4
    8106:	str.w	r0, [r1], #4
    810a:	cmp	r3, r2
    810c:	bne.n	8102 <SdioCard::readCID(CID*)+0x6>
  return true;
}
    810e:	movs	r0, #1
    8110:	bx	lr
    8112:	nop
    8114:	.word	0x2001a6a1

00008118 <SdioCard::readCSD(csd_t*)>:
//------------------------------------------------------------------------------
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
    8118:	ldr	r3, [pc, #20]	; (8130 <SdioCard::readCSD(csd_t*)+0x18>)
    811a:	add.w	r2, r3, #16
    811e:	ldr.w	r0, [r3], #4
    8122:	str.w	r0, [r1], #4
    8126:	cmp	r3, r2
    8128:	bne.n	811e <SdioCard::readCSD(csd_t*)+0x6>
  return true;
}
    812a:	movs	r0, #1
    812c:	bx	lr
    812e:	nop
    8130:	.word	0x2001a6cd

00008134 <SdioCard::readOCR(unsigned long*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
    8134:	ldr	r3, [pc, #8]	; (8140 <SdioCard::readOCR(unsigned long*)+0xc>)
    8136:	ldr	r3, [r3, #0]
    8138:	str	r3, [r1, #0]
  return true;
}
    813a:	movs	r0, #1
    813c:	bx	lr
    813e:	nop
    8140:	.word	0x2001a6bc

00008144 <SdioCard::~SdioCard()>:
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    8144:	bx	lr
    8146:	Address 0x00008146 is out of bounds.


00008148 <waitTimeout(bool (*)())>:
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
    8148:	push	{r3, r4, r5, r6, r7, lr}
    814a:	mov	r7, r0
  uint32_t m = micros();
    814c:	bl	953c <micros>
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    8150:	ldr	r5, [pc, #20]	; (8168 <waitTimeout(bool (*)())+0x20>)
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
  uint32_t m = micros();
    8152:	mov	r6, r0
  while (fcn()) {
    8154:	blx	r7
    8156:	mov	r4, r0
    8158:	cbz	r0, 8164 <waitTimeout(bool (*)())+0x1c>
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    815a:	bl	953c <micros>
    815e:	subs	r0, r0, r6
    8160:	cmp	r0, r5
    8162:	bls.n	8154 <waitTimeout(bool (*)())+0xc>
      return true;
    }
  }
  return false;  // Caller will set errorCode.
}
    8164:	mov	r0, r4
    8166:	pop	{r3, r4, r5, r6, r7, pc}
    8168:	.word	0x000f4240

0000816c <yieldTimeout(bool (*)())>:
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    816c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  m_busyFcn = fcn;
    8170:	ldr	r4, [pc, #48]	; (81a4 <yieldTimeout(bool (*)())+0x38>)
  uint32_t m = micros();
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    8172:	ldr.w	r8, [pc, #52]	; 81a8 <yieldTimeout(bool (*)())+0x3c>
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
  m_busyFcn = fcn;
    8176:	str	r0, [r4, #0]
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    8178:	mov	r6, r0
  m_busyFcn = fcn;
  uint32_t m = micros();
    817a:	bl	953c <micros>
    817e:	mov	r7, r0
  while (fcn()) {
    8180:	blx	r6
    8182:	mov	r5, r0
    8184:	cbz	r0, 819c <yieldTimeout(bool (*)())+0x30>
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    8186:	bl	953c <micros>
    818a:	subs	r0, r0, r7
    818c:	cmp	r0, r8
    818e:	bls.n	8196 <yieldTimeout(bool (*)())+0x2a>
      m_busyFcn = 0;
    8190:	movs	r3, #0
    8192:	str	r3, [r4, #0]
      return true;
    8194:	b.n	819e <yieldTimeout(bool (*)())+0x32>
  }
}
#elif defined(ARDUINO)
inline void SysCall::yield() {
  // Use the external Arduino yield() function.
  ::yield();
    8196:	bl	9f7c <yield>
    819a:	b.n	8180 <yieldTimeout(bool (*)())+0x14>
    }
    SysCall::yield();
  }
  m_busyFcn = 0;
    819c:	str	r0, [r4, #0]
  return false;  // Caller will set errorCode.
}
    819e:	mov	r0, r5
    81a0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    81a4:	.word	0x2001a6b4
    81a8:	.word	0x000f4240

000081ac <SdioCard::~SdioCard()>:
    81ac:	push	{r4, lr}
    81ae:	movs	r1, #12
    81b0:	mov	r4, r0
    81b2:	bl	a3e0 <operator delete(void*, unsigned int)>
    81b6:	mov	r0, r4
    81b8:	pop	{r4, pc}
    81ba:	Address 0x000081ba is out of bounds.


000081bc <SdioCard::type() const>:
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
    81bc:	ldr	r3, [pc, #20]	; (81d4 <SdioCard::type() const+0x18>)
    81be:	ldrb	r3, [r3, #0]
    81c0:	cbz	r3, 81d0 <SdioCard::type() const+0x14>
    81c2:	ldr	r3, [pc, #20]	; (81d8 <SdioCard::type() const+0x1c>)
    81c4:	ldrb	r3, [r3, #0]
    81c6:	cmp	r3, #0
    81c8:	ite	ne
    81ca:	movne	r0, #3
    81cc:	moveq	r0, #2
    81ce:	bx	lr
    81d0:	movs	r0, #1
}
    81d2:	bx	lr
    81d4:	.word	0x2001a6a0
    81d8:	.word	0x2001a6b8

000081dc <cardCommand(unsigned long, unsigned long)>:
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    81dc:	push	{r3, r4, r5, lr}
    81de:	mov	r4, r0
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    81e0:	ldr	r0, [pc, #56]	; (821c <cardCommand(unsigned long, unsigned long)+0x40>)
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    81e2:	mov	r5, r1
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    81e4:	bl	8148 <waitTimeout(bool (*)())>
    81e8:	cbnz	r0, 8212 <cardCommand(unsigned long, unsigned long)+0x36>
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    81ea:	ldr	r3, [pc, #52]	; (8220 <cardCommand(unsigned long, unsigned long)+0x44>)
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
  if (waitTimeout(isBusyCommandComplete)) {
    81ec:	ldr	r0, [pc, #52]	; (8224 <cardCommand(unsigned long, unsigned long)+0x48>)
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    81ee:	str	r5, [r3, #0]
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MASK;
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
    81f0:	str	r4, [r3, #4]
  if (waitTimeout(isBusyCommandComplete)) {
    81f2:	bl	8148 <waitTimeout(bool (*)())>
    81f6:	cbnz	r0, 8212 <cardCommand(unsigned long, unsigned long)+0x36>
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
    81f8:	ldr	r2, [pc, #44]	; (8228 <cardCommand(unsigned long, unsigned long)+0x4c>)
    81fa:	ldr	r3, [pc, #48]	; (822c <cardCommand(unsigned long, unsigned long)+0x50>)
    81fc:	ldr	r1, [r2, #0]
    81fe:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    8200:	ldr	r1, [r3, #0]
    8202:	str	r1, [r2, #0]

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    8204:	ldr	r2, [r3, #0]
    8206:	lsls	r2, r2, #31
    8208:	bpl.n	8212 <cardCommand(unsigned long, unsigned long)+0x36>
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
    820a:	ldr	r3, [r3, #0]
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    820c:	tst.w	r3, #983040	; 0xf0000
    8210:	beq.n	8216 <cardCommand(unsigned long, unsigned long)+0x3a>
    8212:	movs	r0, #0
    8214:	pop	{r3, r4, r5, pc}
    8216:	movs	r0, #1
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
    8218:	pop	{r3, r4, r5, pc}
    821a:	nop
    821c:	.word	0x00007fdd
    8220:	.word	0x400b1008
    8224:	.word	0x00007fc5
    8228:	.word	0x400b1030
    822c:	.word	0x2001a6c8

00008230 <statusCMD13()>:
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
  }
}
//------------------------------------------------------------------------------
static uint32_t statusCMD13() {
    8230:	push	{r3, lr}
  return cardCommand(CMD13_XFERTYP, m_rca) ? SDHC_CMDRSP0 : 0;
    8232:	ldr	r3, [pc, #16]	; (8244 <statusCMD13()+0x14>)
    8234:	ldr	r0, [pc, #16]	; (8248 <statusCMD13()+0x18>)
    8236:	ldr	r1, [r3, #0]
    8238:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    823c:	cbz	r0, 8242 <statusCMD13()+0x12>
    823e:	ldr	r3, [pc, #12]	; (824c <statusCMD13()+0x1c>)
    8240:	ldr	r0, [r3, #0]
}
    8242:	pop	{r3, pc}
    8244:	.word	0x2001a6c0
    8248:	.word	0x0d1a0000
    824c:	.word	0x400b1010

00008250 <isBusyCMD13()>:
//------------------------------------------------------------------------------
static bool isBusyCMD13() {
    8250:	push	{r3, lr}
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
    8252:	bl	8230 <statusCMD13()>
    8256:	eor.w	r0, r0, #256	; 0x100
}
    825a:	ubfx	r0, r0, #8, #1
    825e:	pop	{r3, pc}

00008260 <SdioCard::status()>:
uint32_t SdioCard::sectorCount() {
  return sdCardCapacity(&m_csd);
}
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
    8260:	b.w	8230 <statusCMD13()>

00008264 <readReg16(unsigned long, void*)>:
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    8264:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    8266:	ldr	r3, [pc, #80]	; (82b8 <readReg16(unsigned long, void*)+0x54>)
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    8268:	mov	r5, r1
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    826a:	ldr	r1, [r3, #0]
    826c:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    8270:	cbz	r0, 82b2 <readReg16(unsigned long, void*)+0x4e>
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
    8272:	ldr	r3, [pc, #72]	; (82bc <readReg16(unsigned long, void*)+0x58>)
    8274:	ldr	r3, [r3, #0]
    8276:	str	r3, [sp, #0]
    8278:	ldr	r3, [pc, #68]	; (82c0 <readReg16(unsigned long, void*)+0x5c>)
    827a:	ldr	r3, [r3, #0]
    827c:	str	r3, [sp, #4]
    827e:	ldr	r3, [pc, #68]	; (82c4 <readReg16(unsigned long, void*)+0x60>)
    8280:	ldr	r3, [r3, #0]
    8282:	str	r3, [sp, #8]
    8284:	ldr	r3, [pc, #64]	; (82c8 <readReg16(unsigned long, void*)+0x64>)
    8286:	ldr	r3, [r3, #0]
    8288:	str	r3, [sp, #12]
    828a:	add.w	r6, r5, #15
  for (int i = 0; i < 15; i++) {
    828e:	movs	r3, #0
    d[14 - i] = sr[i/4] >> 8*(i%4);
    8290:	bic.w	r4, r3, #3
    8294:	add	r2, sp, #16
    8296:	add	r4, r2
    8298:	and.w	r2, r3, #3
    829c:	lsls	r1, r2, #3
    829e:	ldr.w	r2, [r4, #-16]
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    82a2:	adds	r3, #1
    d[14 - i] = sr[i/4] >> 8*(i%4);
    82a4:	lsrs	r2, r1
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    82a6:	cmp	r3, #15
    d[14 - i] = sr[i/4] >> 8*(i%4);
    82a8:	strb.w	r2, [r6, #-1]!
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    82ac:	bne.n	8290 <readReg16(unsigned long, void*)+0x2c>
    d[14 - i] = sr[i/4] >> 8*(i%4);
  }
  d[15] = 0;
    82ae:	movs	r3, #0
    82b0:	strb	r3, [r5, #15]
  return true;
}
    82b2:	add	sp, #16
    82b4:	pop	{r4, r5, r6, pc}
    82b6:	nop
    82b8:	.word	0x2001a6c0
    82bc:	.word	0x400b1010
    82c0:	.word	0x400b1014
    82c4:	.word	0x400b1018
    82c8:	.word	0x400b101c

000082cc <waitDmaStatus() [clone .part.4]>:
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    return false;  // Caller will set errorCode.
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    82cc:	ldr	r3, [pc, #20]	; (82e4 <waitDmaStatus() [clone .part.4]+0x18>)
    82ce:	ldr	r0, [r3, #0]
    82d0:	ands.w	r0, r0, #2
    82d4:	beq.n	82e2 <waitDmaStatus() [clone .part.4]+0x16>
    82d6:	ldr	r3, [r3, #0]
    82d8:	ldr	r0, [pc, #12]	; (82e8 <waitDmaStatus() [clone .part.4]+0x1c>)
    82da:	ands	r0, r3
    82dc:	clz	r0, r0
    82e0:	lsrs	r0, r0, #5
}
    82e2:	bx	lr
    82e4:	.word	0x2001a6c8
    82e8:	.word	0x117f0000

000082ec <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>:
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
}
//------------------------------------------------------------------------------
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
    82ec:	push	{r3, r4, r5, r6, r7, lr}
    82ee:	mov	r4, r3
  if ((3 & (uint32_t)buf) || n == 0) {
    82f0:	lsls	r3, r2, #30
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
}
//------------------------------------------------------------------------------
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
    82f2:	mov	r7, r0
    82f4:	mov	r5, r1
    82f6:	mov	r6, r2
  if ((3 & (uint32_t)buf) || n == 0) {
    82f8:	bne.n	82fc <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x10>
    82fa:	cbnz	r4, 8308 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x1c>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    82fc:	ldr	r3, [pc, #100]	; (8364 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x78>)
    82fe:	movs	r2, #37	; 0x25
    8300:	strb	r2, [r3, #0]
  m_errorLine = line;
    8302:	mov.w	r2, #506	; 0x1fa
    8306:	b.n	831a <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x2e>
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    8308:	ldr	r0, [pc, #92]	; (8368 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x7c>)
    830a:	bl	816c <yieldTimeout(bool (*)())>
    830e:	cbz	r0, 8320 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x34>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8310:	ldr	r3, [pc, #80]	; (8364 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x78>)
    8312:	movs	r2, #10
    8314:	strb	r2, [r3, #0]
  m_errorLine = line;
    8316:	movw	r2, #509	; 0x1fd
    831a:	ldr	r3, [pc, #80]	; (836c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x80>)
    831c:	str	r2, [r3, #0]
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    831e:	b.n	835e <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    8320:	ldr	r3, [pc, #76]	; (8370 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x84>)
    8322:	movs	r2, #1
    8324:	strb	r2, [r3, #0]
  m_irqstat = 0;
    8326:	ldr	r3, [pc, #76]	; (8374 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x88>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    8328:	ldr	r2, [pc, #76]	; (8378 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x8c>)
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    832a:	str	r0, [r3, #0]
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    832c:	lsls	r4, r4, #16
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    832e:	ldr	r3, [pc, #76]	; (837c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x90>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    8330:	orr.w	r4, r4, #512	; 0x200
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    8334:	str	r6, [r3, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    8336:	str	r4, [r3, #4]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    8338:	str	r2, [r3, #56]	; 0x38
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    833a:	ldr	r3, [pc, #68]	; (8380 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x94>)
    833c:	ldrb	r3, [r3, #0]
    833e:	cbnz	r3, 8344 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x58>
    8340:	lsls	r1, r5, #9
    8342:	b.n	8346 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x5a>
    8344:	mov	r1, r5
    8346:	mov	r0, r7
    8348:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    834c:	cbz	r0, 835e <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    834e:	ldr	r0, [pc, #52]	; (8384 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x98>)
    8350:	bl	816c <yieldTimeout(bool (*)())>
    8354:	cbnz	r0, 835e <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    return false;
  }
  return waitDmaStatus();
}
    8356:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    835a:	b.w	82cc <waitDmaStatus() [clone .part.4]>
    835e:	movs	r0, #0
    8360:	pop	{r3, r4, r5, r6, r7, pc}
    8362:	nop
    8364:	.word	0x1fff1338
    8368:	.word	0x00008251
    836c:	.word	0x2001a6e4
    8370:	.word	0x2001a6dd
    8374:	.word	0x2001a6c8
    8378:	.word	0x117f0002
    837c:	.word	0x400b1000
    8380:	.word	0x2001a6b8
    8384:	.word	0x00008001

00008388 <SdioCard::sectorCount()>:
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    8388:	ldr	r2, [pc, #92]	; (83e8 <SdioCard::sectorCount()+0x60>)
    838a:	ldrb	r3, [r2, #0]
    838c:	ands.w	r3, r3, #192	; 0xc0
    8390:	bne.n	83c6 <SdioCard::sectorCount()+0x3e>
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    8392:	ldrb	r0, [r2, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    8394:	ldrb	r3, [r2, #7]
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    8396:	ldrb	r1, [r2, #10]
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    8398:	and.w	r0, r0, #3
    839c:	lsls	r3, r3, #2
    839e:	orr.w	r3, r3, r0, lsl #10
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    83a2:	ldrb	r0, [r2, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    83a4:	orr.w	r0, r3, r0, lsr #6
    83a8:	adds	r3, r0, #1
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    83aa:	ldrb	r0, [r2, #9]
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    83ac:	ldrb	r2, [r2, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    83ae:	and.w	r0, r0, #3
    83b2:	lsls	r0, r0, #1
    83b4:	orr.w	r0, r0, r1, lsr #7
    83b8:	and.w	r2, r2, #15
    83bc:	add	r0, r2
    83be:	subs	r0, #7
    83c0:	lsl.w	r0, r3, r0
    83c4:	bx	lr
  } else if (csd->v2.csd_ver == 1) {
    83c6:	cmp	r3, #64	; 0x40
    83c8:	bne.n	83e2 <SdioCard::sectorCount()+0x5a>
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    83ca:	ldrb	r0, [r2, #9]
    83cc:	adds	r3, r0, #1
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    83ce:	ldrb	r0, [r2, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    83d0:	and.w	r0, r0, #63	; 0x3f
    83d4:	add.w	r0, r3, r0, lsl #16
    83d8:	ldrb	r3, [r2, #8]
    83da:	add.w	r0, r0, r3, lsl #8
    83de:	lsls	r0, r0, #10
    83e0:	bx	lr
  } else {
    return 0;
    83e2:	movs	r0, #0
  return transferStop();
}
//------------------------------------------------------------------------------
uint32_t SdioCard::sectorCount() {
  return sdCardCapacity(&m_csd);
}
    83e4:	bx	lr
    83e6:	nop
    83e8:	.word	0x2001a6cd

000083ec <SdioCard::erase(unsigned long, unsigned long)>:
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    83ec:	push	{r4, r5, r6, lr}
    83ee:	mov	r6, r2
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    83f0:	ldrb	r2, [r0, #9]
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    83f2:	mov	r5, r1
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    83f4:	cbz	r2, 8402 <SdioCard::erase(unsigned long, unsigned long)+0x16>
    83f6:	ldr	r3, [r0, #0]
    83f8:	ldr	r3, [r3, #28]
    83fa:	blx	r3
    83fc:	mov	r4, r0
    83fe:	cmp	r0, #0
    8400:	beq.n	849e <SdioCard::erase(unsigned long, unsigned long)+0xb2>
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  // check for single sector erase
  if (!m_csd.v1.erase_blk_en) {
    8402:	ldr	r1, [pc, #160]	; (84a4 <SdioCard::erase(unsigned long, unsigned long)+0xb8>)
    8404:	ldrb	r3, [r1, #10]
    8406:	and.w	r2, r3, #64	; 0x40
    840a:	and.w	r4, r2, #255	; 0xff
    840e:	cbnz	r2, 8430 <SdioCard::erase(unsigned long, unsigned long)+0x44>
    // erase size mask
    uint8_t m = (m_csd.v1.sector_size_high << 1) | m_csd.v1.sector_size_low;
    8410:	ldrb	r2, [r1, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    8412:	and.w	r3, r3, #63	; 0x3f
    8416:	lsls	r3, r3, #1
    8418:	orr.w	r3, r3, r2, lsr #7
    841c:	adds	r2, r6, #1
    841e:	orrs	r2, r5
    8420:	tst	r3, r2
    8422:	beq.n	8430 <SdioCard::erase(unsigned long, unsigned long)+0x44>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8424:	ldr	r3, [pc, #128]	; (84a8 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    8426:	movs	r2, #39	; 0x27
    8428:	strb	r2, [r3, #0]
  m_errorLine = line;
    842a:	movw	r2, #747	; 0x2eb
    842e:	b.n	8480 <SdioCard::erase(unsigned long, unsigned long)+0x94>
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
      // error card can't erase specified area
      return sdError(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
    }
  }
  if (!m_highCapacity) {
    8430:	ldr	r3, [pc, #120]	; (84ac <SdioCard::erase(unsigned long, unsigned long)+0xc0>)
    8432:	ldrb	r3, [r3, #0]
    8434:	cbnz	r3, 843a <SdioCard::erase(unsigned long, unsigned long)+0x4e>
    firstSector <<= 9;
    8436:	lsls	r5, r5, #9
    lastSector <<= 9;
    8438:	lsls	r6, r6, #9
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    843a:	mov	r1, r5
    843c:	ldr	r0, [pc, #112]	; (84b0 <SdioCard::erase(unsigned long, unsigned long)+0xc4>)
    843e:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    8442:	mov	r4, r0
    8444:	cbnz	r0, 8452 <SdioCard::erase(unsigned long, unsigned long)+0x66>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8446:	ldr	r3, [pc, #96]	; (84a8 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    8448:	movs	r2, #15
    844a:	strb	r2, [r3, #0]
  m_errorLine = line;
    844c:	movw	r2, #755	; 0x2f3
    8450:	b.n	8480 <SdioCard::erase(unsigned long, unsigned long)+0x94>
    lastSector <<= 9;
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
    8452:	mov	r1, r6
    8454:	ldr	r0, [pc, #92]	; (84b4 <SdioCard::erase(unsigned long, unsigned long)+0xc8>)
    8456:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    845a:	mov	r4, r0
    845c:	cbnz	r0, 846a <SdioCard::erase(unsigned long, unsigned long)+0x7e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    845e:	ldr	r3, [pc, #72]	; (84a8 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    8460:	movs	r2, #16
    8462:	strb	r2, [r3, #0]
  m_errorLine = line;
    8464:	movw	r2, #758	; 0x2f6
    8468:	b.n	8480 <SdioCard::erase(unsigned long, unsigned long)+0x94>
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    846a:	movs	r1, #0
    846c:	ldr	r0, [pc, #72]	; (84b8 <SdioCard::erase(unsigned long, unsigned long)+0xcc>)
    846e:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    8472:	mov	r4, r0
    8474:	cbnz	r0, 8486 <SdioCard::erase(unsigned long, unsigned long)+0x9a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8476:	ldr	r3, [pc, #48]	; (84a8 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    8478:	movs	r2, #17
    847a:	strb	r2, [r3, #0]
  m_errorLine = line;
    847c:	movw	r2, #761	; 0x2f9
    8480:	ldr	r3, [pc, #56]	; (84bc <SdioCard::erase(unsigned long, unsigned long)+0xd0>)
    8482:	str	r2, [r3, #0]
    8484:	b.n	849e <SdioCard::erase(unsigned long, unsigned long)+0xb2>
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    8486:	ldr	r0, [pc, #56]	; (84c0 <SdioCard::erase(unsigned long, unsigned long)+0xd4>)
    8488:	bl	8148 <waitTimeout(bool (*)())>
    848c:	cbz	r0, 849e <SdioCard::erase(unsigned long, unsigned long)+0xb2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    848e:	ldr	r3, [pc, #24]	; (84a8 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    8490:	movs	r2, #40	; 0x28
    8492:	strb	r2, [r3, #0]
  m_errorLine = line;
    8494:	ldr	r3, [pc, #36]	; (84bc <SdioCard::erase(unsigned long, unsigned long)+0xd0>)
    8496:	mov.w	r2, #764	; 0x2fc
    849a:	str	r2, [r3, #0]
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
    849c:	movs	r4, #0
  }
  return true;
}
    849e:	mov	r0, r4
    84a0:	pop	{r4, r5, r6, pc}
    84a2:	nop
    84a4:	.word	0x2001a6cd
    84a8:	.word	0x1fff1338
    84ac:	.word	0x2001a6b8
    84b0:	.word	0x201a0000
    84b4:	.word	0x211a0000
    84b8:	.word	0x261b0000
    84bc:	.word	0x2001a6e4
    84c0:	.word	0x00008251

000084c4 <waitTransferComplete()>:
  }
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
    84c4:	push	{r4, lr}
  if (!m_transferActive) {
    84c6:	ldr	r4, [pc, #60]	; (8504 <waitTransferComplete()+0x40>)
    84c8:	ldrb	r3, [r4, #0]
    84ca:	cbnz	r3, 84d0 <waitTransferComplete()+0xc>
    return true;
    84cc:	movs	r0, #1
    84ce:	pop	{r4, pc}
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
    84d0:	ldr	r0, [pc, #52]	; (8508 <waitTransferComplete()+0x44>)
    84d2:	bl	8148 <waitTimeout(bool (*)())>
  m_transferActive = false;
    84d6:	movs	r3, #0
  m_irqstat = SDHC_IRQSTAT;
    84d8:	ldr	r2, [pc, #48]	; (850c <waitTransferComplete()+0x48>)
static bool waitTransferComplete() {
  if (!m_transferActive) {
    return true;
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
    84da:	strb	r3, [r4, #0]
  m_irqstat = SDHC_IRQSTAT;
    84dc:	ldr	r3, [pc, #48]	; (8510 <waitTransferComplete()+0x4c>)
    84de:	ldr	r1, [r2, #0]
    84e0:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    84e2:	ldr	r1, [r3, #0]
    84e4:	str	r1, [r2, #0]
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    84e6:	cbnz	r0, 84f2 <waitTransferComplete()+0x2e>
    84e8:	ldr	r2, [r3, #0]
    84ea:	ldr	r3, [pc, #40]	; (8514 <waitTransferComplete()+0x50>)
    84ec:	ands	r3, r2
    84ee:	cmp	r3, #0
    84f0:	beq.n	84cc <waitTransferComplete()+0x8>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    84f2:	ldr	r3, [pc, #36]	; (8518 <waitTransferComplete()+0x54>)
    84f4:	movs	r2, #31
    84f6:	strb	r2, [r3, #0]
  m_errorLine = line;
    84f8:	ldr	r3, [pc, #32]	; (851c <waitTransferComplete()+0x58>)
    84fa:	movw	r2, #641	; 0x281
    84fe:	str	r2, [r3, #0]
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    return sdError(SD_CARD_ERROR_TRANSFER_COMPLETE);
    8500:	movs	r0, #0
  }
  return true;
}
    8502:	pop	{r4, pc}
    8504:	.word	0x2001a6c4
    8508:	.word	0x00008035
    850c:	.word	0x400b1030
    8510:	.word	0x2001a6c8
    8514:	.word	0x117f0000
    8518:	.word	0x1fff1338
    851c:	.word	0x2001a6e4

00008520 <SdioCard::readStop()>:
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
    8520:	push	{r4, r5, r6, lr}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8522:	ldr	r4, [pc, #100]	; (8588 <SdioCard::readStop()+0x68>)
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    8524:	ldr	r0, [pc, #100]	; (858c <SdioCard::readStop()+0x6c>)
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8526:	ldr	r3, [r4, #0]
    8528:	bic.w	r3, r3, #65536	; 0x10000
    852c:	str	r3, [r4, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    852e:	movs	r1, #0
    8530:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    8534:	mov	r5, r0
    8536:	cbnz	r0, 8548 <SdioCard::readStop()+0x28>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8538:	ldr	r3, [pc, #84]	; (8590 <SdioCard::readStop()+0x70>)
    853a:	movs	r2, #9
    853c:	strb	r2, [r3, #0]
  m_errorLine = line;
    853e:	ldr	r3, [pc, #84]	; (8594 <SdioCard::readStop()+0x74>)
    8540:	movw	r2, #578	; 0x242
    8544:	str	r2, [r3, #0]
    8546:	b.n	8582 <SdioCard::readStop()+0x62>
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    8548:	ldr	r0, [pc, #76]	; (8598 <SdioCard::readStop()+0x78>)
    854a:	bl	816c <yieldTimeout(bool (*)())>
    854e:	cbz	r0, 8562 <SdioCard::readStop()+0x42>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8550:	ldr	r3, [pc, #60]	; (8590 <SdioCard::readStop()+0x70>)
    8552:	movs	r2, #10
    8554:	strb	r2, [r3, #0]
  m_errorLine = line;
    8556:	ldr	r3, [pc, #60]	; (8594 <SdioCard::readStop()+0x74>)
    8558:	movw	r2, #582	; 0x246
    855c:	str	r2, [r3, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    return sdError(SD_CARD_ERROR_CMD13);
    855e:	movs	r5, #0
    8560:	b.n	8582 <SdioCard::readStop()+0x62>
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    8562:	ldr	r3, [pc, #56]	; (859c <SdioCard::readStop()+0x7c>)
    8564:	ldr	r3, [r3, #0]
    8566:	lsls	r3, r3, #30
    8568:	bpl.n	8582 <SdioCard::readStop()+0x62>
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    856a:	ldr	r1, [pc, #52]	; (85a0 <SdioCard::readStop()+0x80>)
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    856c:	ldr	r0, [pc, #52]	; (85a4 <SdioCard::readStop()+0x84>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    856e:	ldr	r6, [r1, #0]
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    8570:	ldr	r3, [r4, #0]
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    8572:	ldr	r2, [r0, #0]
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    8574:	bic.w	r3, r3, #65536	; 0x10000
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    8578:	orr.w	r2, r2, #67108864	; 0x4000000
    857c:	str	r2, [r0, #0]
    // Restore registers.
    SDHC_IRQSTATEN = irqsststen;
    857e:	str	r6, [r1, #0]
    SDHC_PROCTL = proctl;
    8580:	str	r3, [r4, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
}
    8582:	mov	r0, r5
    8584:	pop	{r4, r5, r6, pc}
    8586:	nop
    8588:	.word	0x400b1028
    858c:	.word	0x0cdb0000
    8590:	.word	0x1fff1338
    8594:	.word	0x2001a6e4
    8598:	.word	0x00007fed
    859c:	.word	0x400b1024
    85a0:	.word	0x400b1034
    85a4:	.word	0x400b102c

000085a8 <SdioCard::writeData(unsigned char const*)>:
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
}
//------------------------------------------------------------------------------
bool SdioCard::writeData(const uint8_t* src) {
    85a8:	push	{r4, r5, r6, lr}
    85aa:	mov	r4, r1
  DBG_IRQSTAT();
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    85ac:	bl	84c4 <waitTransferComplete()>
    85b0:	mov	r6, r0
    85b2:	cmp	r0, #0
    85b4:	beq.n	861c <SdioCard::writeData(unsigned char const*)+0x74>
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    85b6:	ldr	r5, [pc, #104]	; (8620 <SdioCard::writeData(unsigned char const*)+0x78>)
    85b8:	ldr	r3, [r5, #0]
    85ba:	tst.w	r3, #256	; 0x100
    85be:	ldr	r3, [pc, #100]	; (8624 <SdioCard::writeData(unsigned char const*)+0x7c>)
    85c0:	bne.n	85d2 <SdioCard::writeData(unsigned char const*)+0x2a>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    85c2:	ldr	r2, [r3, #0]
    85c4:	bic.w	r2, r2, #65536	; 0x10000
    85c8:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    85ca:	ldr	r2, [r3, #0]
    85cc:	orr.w	r2, r2, #131072	; 0x20000
    85d0:	str	r2, [r3, #0]
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    85d2:	ldr	r2, [r3, #0]
  if (waitTimeout(isBusyFifoWrite)) {
    85d4:	ldr	r0, [pc, #80]	; (8628 <SdioCard::writeData(unsigned char const*)+0x80>)
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    85d6:	orr.w	r2, r2, #65536	; 0x10000
    85da:	str	r2, [r3, #0]
  if (waitTimeout(isBusyFifoWrite)) {
    85dc:	bl	8148 <waitTimeout(bool (*)())>
    85e0:	cbnz	r0, 860c <SdioCard::writeData(unsigned char const*)+0x64>
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    85e2:	ldr	r1, [pc, #72]	; (862c <SdioCard::writeData(unsigned char const*)+0x84>)
    85e4:	subs	r3, r4, #4
    85e6:	add.w	r4, r4, #508	; 0x1fc
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    85ea:	ldr	r2, [r5, #0]
    85ec:	lsls	r2, r2, #21
    85ee:	bpl.n	85ea <SdioCard::writeData(unsigned char const*)+0x42>
    85f0:	add.w	r2, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    85f4:	ldr.w	r0, [r3, #4]!
    85f8:	str	r0, [r1, #0]
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    85fa:	cmp	r2, r3
    85fc:	bne.n	85f4 <SdioCard::writeData(unsigned char const*)+0x4c>
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    85fe:	cmp	r4, r2
    8600:	mov	r3, r2
    8602:	bne.n	85ea <SdioCard::writeData(unsigned char const*)+0x42>
      SDHC_DATPORT = p32[i];
    }
    p32 += FIFO_WML;
  }
#if ENABLE_TEENSY_SDIO_MOD
  m_transferActive = true;
    8604:	ldr	r3, [pc, #40]	; (8630 <SdioCard::writeData(unsigned char const*)+0x88>)
    8606:	movs	r2, #1
    8608:	strb	r2, [r3, #0]
    860a:	b.n	861c <SdioCard::writeData(unsigned char const*)+0x74>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    860c:	ldr	r3, [pc, #36]	; (8634 <SdioCard::writeData(unsigned char const*)+0x8c>)
    860e:	movs	r2, #33	; 0x21
    8610:	strb	r2, [r3, #0]
  m_errorLine = line;
    8612:	ldr	r3, [pc, #36]	; (8638 <SdioCard::writeData(unsigned char const*)+0x90>)
    8614:	movw	r2, #1015	; 0x3f7
    8618:	str	r2, [r3, #0]
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
    861a:	movs	r6, #0
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    861c:	mov	r0, r6
    861e:	pop	{r4, r5, r6, pc}
    8620:	.word	0x400b1024
    8624:	.word	0x400b1028
    8628:	.word	0x00008021
    862c:	.word	0x400b1020
    8630:	.word	0x2001a6c4
    8634:	.word	0x1fff1338
    8638:	.word	0x2001a6e4

0000863c <SdioCard::writeStart(unsigned long)>:
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    863c:	push	{r4, lr}
  if (yieldTimeout(isBusyCMD13)) {
    863e:	ldr	r0, [pc, #80]	; (8690 <SdioCard::writeStart(unsigned long)+0x54>)
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    8640:	mov	r4, r1
  if (yieldTimeout(isBusyCMD13)) {
    8642:	bl	816c <yieldTimeout(bool (*)())>
    8646:	cbz	r0, 865a <SdioCard::writeStart(unsigned long)+0x1e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8648:	ldr	r3, [pc, #72]	; (8694 <SdioCard::writeStart(unsigned long)+0x58>)
    864a:	movs	r2, #10
    864c:	strb	r2, [r3, #0]
  m_errorLine = line;
    864e:	ldr	r3, [pc, #72]	; (8698 <SdioCard::writeStart(unsigned long)+0x5c>)
    8650:	movw	r2, #1119	; 0x45f
    8654:	str	r2, [r3, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    8656:	movs	r0, #0
    8658:	pop	{r4, pc}
  }
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    865a:	ldr	r2, [pc, #64]	; (869c <SdioCard::writeStart(unsigned long)+0x60>)
    865c:	ldr	r3, [r2, #0]
    865e:	bic.w	r3, r3, #65536	; 0x10000
    8662:	str	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    8664:	ldr	r3, [pc, #56]	; (86a0 <SdioCard::writeStart(unsigned long)+0x64>)
    8666:	ldr	r2, [pc, #60]	; (86a4 <SdioCard::writeStart(unsigned long)+0x68>)
    8668:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    866a:	ldr	r3, [pc, #60]	; (86a8 <SdioCard::writeStart(unsigned long)+0x6c>)
    866c:	ldrb	r3, [r3, #0]
    866e:	cbnz	r3, 8674 <SdioCard::writeStart(unsigned long)+0x38>
    8670:	lsls	r1, r4, #9
    8672:	b.n	8676 <SdioCard::writeStart(unsigned long)+0x3a>
    8674:	mov	r1, r4
    8676:	ldr	r0, [pc, #52]	; (86ac <SdioCard::writeStart(unsigned long)+0x70>)
    8678:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    867c:	cbnz	r0, 868c <SdioCard::writeStart(unsigned long)+0x50>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    867e:	ldr	r3, [pc, #20]	; (8694 <SdioCard::writeStart(unsigned long)+0x58>)
    8680:	movs	r2, #14
    8682:	strb	r2, [r3, #0]
  m_errorLine = line;
    8684:	ldr	r3, [pc, #16]	; (8698 <SdioCard::writeStart(unsigned long)+0x5c>)
    8686:	movw	r2, #1131	; 0x46b
    868a:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
    868c:	pop	{r4, pc}
    868e:	nop
    8690:	.word	0x00008251
    8694:	.word	0x1fff1338
    8698:	.word	0x2001a6e4
    869c:	.word	0x400b1028
    86a0:	.word	0x400b1004
    86a4:	.word	0xffff0200
    86a8:	.word	0x2001a6b8
    86ac:	.word	0x193a0022

000086b0 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    86b0:	push	{r3, r4, r5, r6, r7, lr}
    86b2:	mov	r7, r0
    86b4:	mov	r4, r1
  if (m_sdioConfig.useDma()) {
    86b6:	ldrb	r6, [r7, #8]
    86b8:	lsls	r6, r6, #31
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    86ba:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    86bc:	bpl.n	86fa <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x4a>
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
    86be:	lsls	r6, r2, #30
    86c0:	beq.n	86e2 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x32>
    86c2:	adds	r6, r1, r3
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    86c4:	cmp	r4, r6
    86c6:	beq.n	8718 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
        if (!writeSector(sector, ptr)) {
    86c8:	ldr	r3, [r7, #0]
    86ca:	mov	r2, r5
    86cc:	ldr	r3, [r3, #32]
    86ce:	mov	r1, r4
    86d0:	mov	r0, r7
    86d2:	blx	r3
    86d4:	cbnz	r0, 86da <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2a>
          return false;  // writeSector will set errorCode.
    86d6:	movs	r0, #0
    86d8:	pop	{r3, r4, r5, r6, r7, pc}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    86da:	adds	r4, #1
    86dc:	add.w	r5, r5, #512	; 0x200
    86e0:	b.n	86c4 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x14>
          return false;  // writeSector will set errorCode.
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
    86e2:	ldr	r0, [pc, #56]	; (871c <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x6c>)
    86e4:	bl	82ec <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    86e8:	cbnz	r0, 8718 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    86ea:	ldr	r3, [pc, #52]	; (8720 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x70>)
    86ec:	movs	r2, #14
    86ee:	strb	r2, [r3, #0]
  m_errorLine = line;
    86f0:	ldr	r3, [pc, #48]	; (8724 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x74>)
    86f2:	movw	r2, #1105	; 0x451
    86f6:	str	r2, [r3, #0]
    86f8:	pop	{r3, r4, r5, r6, r7, pc}
    86fa:	adds	r6, r1, r3
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
      return sdError(SD_CARD_ERROR_CMD25);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    86fc:	cmp	r4, r6
    86fe:	beq.n	8718 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
      if (!writeSector(sector + i, src + i*512UL)) {
    8700:	ldr	r3, [r7, #0]
    8702:	mov	r2, r5
    8704:	mov	r1, r4
    8706:	ldr	r3, [r3, #32]
    8708:	mov	r0, r7
    870a:	blx	r3
    870c:	adds	r4, #1
    870e:	add.w	r5, r5, #512	; 0x200
    8712:	cmp	r0, #0
    8714:	bne.n	86fc <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x4c>
    8716:	b.n	86d6 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x26>
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
        if (!writeSector(sector, ptr)) {
          return false;  // writeSector will set errorCode.
        }
      }
      return true;
    8718:	movs	r0, #1
        return false;
      }
    }
  }
  return true;
}
    871a:	pop	{r3, r4, r5, r6, r7, pc}
    871c:	.word	0x193a0027
    8720:	.word	0x1fff1338
    8724:	.word	0x2001a6e4

00008728 <SdioCard::writeSector(unsigned long, unsigned char const*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    8728:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    872a:	ldrb	r3, [r0, #8]
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    872c:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    872e:	lsls	r2, r3, #31
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    8730:	sub.w	sp, sp, #512	; 0x200
    8734:	mov	r4, r0
    8736:	mov	r6, r1
  if (m_sdioConfig.useDma()) {
    8738:	bpl.n	876c <SdioCard::writeSector(unsigned long, unsigned char const*)+0x44>
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
    873a:	lsls	r3, r5, #30
    873c:	beq.n	874c <SdioCard::writeSector(unsigned long, unsigned char const*)+0x24>
      ptr = aligned;
      memcpy(aligned, src, 512);
    873e:	mov	r1, r5
    8740:	mov.w	r2, #512	; 0x200
    8744:	mov	r0, sp
    8746:	bl	8f3c <memcpy>
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
      ptr = aligned;
    874a:	mov	r5, sp
      memcpy(aligned, src, 512);
    } else {
      ptr = const_cast<uint8_t*>(src);
    }
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
    874c:	movs	r3, #1
    874e:	mov	r2, r5
    8750:	mov	r1, r6
    8752:	ldr	r0, [pc, #132]	; (87d8 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb0>)
    8754:	bl	82ec <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    8758:	cmp	r0, #0
    875a:	bne.n	87d0 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    875c:	ldr	r3, [pc, #124]	; (87dc <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb4>)
    875e:	movs	r2, #13
    8760:	strb	r2, [r3, #0]
  m_errorLine = line;
    8762:	ldr	r3, [pc, #124]	; (87e0 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb8>)
    8764:	movw	r2, #1049	; 0x419
    8768:	str	r2, [r3, #0]
    876a:	b.n	87d0 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD24);
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    876c:	bl	84c4 <waitTransferComplete()>
    8770:	cbnz	r0, 8776 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4e>
      return false;
    8772:	movs	r0, #0
    8774:	b.n	87d0 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    8776:	ldr	r3, [pc, #108]	; (87e4 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xbc>)
    8778:	ldr	r3, [r3, #0]
    877a:	lsrs	r3, r3, #16
    877c:	lsls	r3, r3, #16
    877e:	cbz	r3, 8788 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x60>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    8780:	ldrb	r3, [r4, #9]
    8782:	cmp	r3, #2
    8784:	bne.n	879c <SdioCard::writeSector(unsigned long, unsigned char const*)+0x74>
    8786:	b.n	8796 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x6e>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    8788:	ldr	r3, [r4, #0]
    878a:	mov	r0, r4
    878c:	ldr	r3, [r3, #28]
    878e:	blx	r3
    8790:	cmp	r0, #0
    8792:	bne.n	8780 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x58>
    8794:	b.n	8772 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    8796:	ldr	r3, [r4, #4]
    8798:	cmp	r6, r3
    879a:	beq.n	87bc <SdioCard::writeSector(unsigned long, unsigned char const*)+0x94>
      if (!syncDevice()) {
    879c:	ldr	r3, [r4, #0]
    879e:	mov	r0, r4
    87a0:	ldr	r3, [r3, #28]
    87a2:	blx	r3
    87a4:	cmp	r0, #0
    87a6:	beq.n	8772 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
      if (!writeStart(sector )) {
    87a8:	ldr	r3, [r4, #0]
    87aa:	mov	r1, r6
    87ac:	ldr	r3, [r3, #80]	; 0x50
    87ae:	mov	r0, r4
    87b0:	blx	r3
    87b2:	cmp	r0, #0
    87b4:	beq.n	8772 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
      m_curSector = sector;
      m_curState = WRITE_STATE;
    87b6:	movs	r3, #2
        return false;
      }
      if (!writeStart(sector )) {
        return false;
      }
      m_curSector = sector;
    87b8:	str	r6, [r4, #4]
      m_curState = WRITE_STATE;
    87ba:	strb	r3, [r4, #9]
    }
    if (!writeData(src)) {
    87bc:	ldr	r3, [r4, #0]
    87be:	mov	r1, r5
    87c0:	ldr	r3, [r3, #76]	; 0x4c
    87c2:	mov	r0, r4
    87c4:	blx	r3
    87c6:	cmp	r0, #0
    87c8:	beq.n	8772 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
      return false;
    }
    m_curSector++;
    87ca:	ldr	r3, [r4, #4]
    87cc:	adds	r3, #1
    87ce:	str	r3, [r4, #4]
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
    87d0:	add.w	sp, sp, #512	; 0x200
    87d4:	pop	{r4, r5, r6, pc}
    87d6:	nop
    87d8:	.word	0x183a0001
    87dc:	.word	0x1fff1338
    87e0:	.word	0x2001a6e4
    87e4:	.word	0x400b1004

000087e8 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    87e8:	push	{r3, r4, r5, r6, r7, lr}
    87ea:	mov	r7, r0
    87ec:	mov	r4, r1
  if (m_sdioConfig.useDma()) {
    87ee:	ldrb	r6, [r7, #8]
    87f0:	lsls	r6, r6, #31
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    87f2:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    87f4:	bpl.n	8832 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4a>
    if ((uint32_t)dst & 3) {
    87f6:	lsls	r6, r2, #30
    87f8:	beq.n	881a <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x32>
    87fa:	adds	r6, r1, r3
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    87fc:	cmp	r4, r6
    87fe:	beq.n	8850 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
        if (!readSector(sector, dst)) {
    8800:	ldr	r3, [r7, #0]
    8802:	mov	r2, r5
    8804:	ldr	r3, [r3, #12]
    8806:	mov	r1, r4
    8808:	mov	r0, r7
    880a:	blx	r3
    880c:	cbnz	r0, 8812 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x2a>
          return false;  // readSector will set errorCode.
    880e:	movs	r0, #0
    8810:	pop	{r3, r4, r5, r6, r7, pc}
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
  if (m_sdioConfig.useDma()) {
    if ((uint32_t)dst & 3) {
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    8812:	adds	r4, #1
    8814:	add.w	r5, r5, #512	; 0x200
    8818:	b.n	87fc <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x14>
          return false;  // readSector will set errorCode.
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
    881a:	ldr	r0, [pc, #56]	; (8854 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x6c>)
    881c:	bl	82ec <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    8820:	cbnz	r0, 8850 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8822:	ldr	r3, [pc, #52]	; (8858 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x70>)
    8824:	movs	r2, #12
    8826:	strb	r2, [r3, #0]
  m_errorLine = line;
    8828:	ldr	r3, [pc, #48]	; (885c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x74>)
    882a:	mov.w	r2, #912	; 0x390
    882e:	str	r2, [r3, #0]
    8830:	pop	{r3, r4, r5, r6, r7, pc}
    8832:	adds	r6, r1, r3
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
      return sdError(SD_CARD_ERROR_CMD18);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    8834:	cmp	r4, r6
    8836:	beq.n	8850 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
      if (!readSector(sector + i, dst + i*512UL)) {
    8838:	ldr	r3, [r7, #0]
    883a:	mov	r2, r5
    883c:	mov	r1, r4
    883e:	ldr	r3, [r3, #12]
    8840:	mov	r0, r7
    8842:	blx	r3
    8844:	adds	r4, #1
    8846:	add.w	r5, r5, #512	; 0x200
    884a:	cmp	r0, #0
    884c:	bne.n	8834 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4c>
    884e:	b.n	880e <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x26>
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
        if (!readSector(sector, dst)) {
          return false;  // readSector will set errorCode.
        }
      }
      return true;
    8850:	movs	r0, #1
        return false;
      }
    }
  }
  return true;
}
    8852:	pop	{r3, r4, r5, r6, r7, pc}
    8854:	.word	0x123a0037
    8858:	.word	0x1fff1338
    885c:	.word	0x2001a6e4

00008860 <cardCMD6(unsigned long, unsigned char*)>:

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    8860:	push	{r3, r4, r5, lr}
    8862:	mov	r4, r0
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    8864:	ldr	r0, [pc, #104]	; (88d0 <cardCMD6(unsigned long, unsigned char*)+0x70>)

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    8866:	mov	r5, r1
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    8868:	bl	8148 <waitTimeout(bool (*)())>
    886c:	cbz	r0, 887a <cardCMD6(unsigned long, unsigned char*)+0x1a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    886e:	ldr	r3, [pc, #100]	; (88d4 <cardCMD6(unsigned long, unsigned char*)+0x74>)
    8870:	movs	r2, #10
    8872:	strb	r2, [r3, #0]
  m_errorLine = line;
    8874:	movw	r2, #413	; 0x19d
    8878:	b.n	88bc <cardCMD6(unsigned long, unsigned char*)+0x5c>
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    887a:	ldr	r3, [pc, #92]	; (88d8 <cardCMD6(unsigned long, unsigned char*)+0x78>)
    887c:	movs	r2, #1
    887e:	strb	r2, [r3, #0]
  m_irqstat = 0;
    8880:	ldr	r3, [pc, #88]	; (88dc <cardCMD6(unsigned long, unsigned char*)+0x7c>)
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    8882:	ldr	r2, [pc, #92]	; (88e0 <cardCMD6(unsigned long, unsigned char*)+0x80>)
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    8884:	str	r0, [r3, #0]
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    8886:	ldr	r3, [pc, #92]	; (88e4 <cardCMD6(unsigned long, unsigned char*)+0x84>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    8888:	ldr	r0, [pc, #92]	; (88e8 <cardCMD6(unsigned long, unsigned char*)+0x88>)
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    888a:	str	r5, [r3, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    888c:	str	r2, [r3, #4]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    888e:	ldr	r2, [pc, #92]	; (88ec <cardCMD6(unsigned long, unsigned char*)+0x8c>)
    8890:	str	r2, [r3, #56]	; 0x38
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    8892:	mov	r1, r4
    8894:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    8898:	cbnz	r0, 88aa <cardCMD6(unsigned long, unsigned char*)+0x4a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    889a:	ldr	r3, [pc, #56]	; (88d4 <cardCMD6(unsigned long, unsigned char*)+0x74>)
    889c:	movs	r2, #4
    889e:	strb	r2, [r3, #0]
  m_errorLine = line;
    88a0:	ldr	r3, [pc, #76]	; (88f0 <cardCMD6(unsigned long, unsigned char*)+0x90>)
    88a2:	mov.w	r2, #420	; 0x1a4
    88a6:	str	r2, [r3, #0]
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
    88a8:	pop	{r3, r4, r5, pc}
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    88aa:	ldr	r0, [pc, #72]	; (88f4 <cardCMD6(unsigned long, unsigned char*)+0x94>)
    88ac:	bl	816c <yieldTimeout(bool (*)())>
    88b0:	cbz	r0, 88c4 <cardCMD6(unsigned long, unsigned char*)+0x64>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    88b2:	ldr	r3, [pc, #32]	; (88d4 <cardCMD6(unsigned long, unsigned char*)+0x74>)
    88b4:	movs	r2, #37	; 0x25
    88b6:	strb	r2, [r3, #0]
  m_errorLine = line;
    88b8:	movw	r2, #423	; 0x1a7
    88bc:	ldr	r3, [pc, #48]	; (88f0 <cardCMD6(unsigned long, unsigned char*)+0x90>)
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    return sdError(SD_CARD_ERROR_DMA);
    88be:	movs	r0, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    88c0:	str	r2, [r3, #0]
    88c2:	pop	{r3, r4, r5, pc}
    88c4:	bl	82cc <waitDmaStatus() [clone .part.4]>
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    88c8:	cmp	r0, #0
    88ca:	beq.n	88b2 <cardCMD6(unsigned long, unsigned char*)+0x52>
    return sdError(SD_CARD_ERROR_DMA);
  }
  return true;
}
    88cc:	pop	{r3, r4, r5, pc}
    88ce:	nop
    88d0:	.word	0x00008251
    88d4:	.word	0x1fff1338
    88d8:	.word	0x2001a6dd
    88dc:	.word	0x2001a6c8
    88e0:	.word	0x00010040
    88e4:	.word	0x400b1000
    88e8:	.word	0x063a0011
    88ec:	.word	0x117f0002
    88f0:	.word	0x2001a6e4
    88f4:	.word	0x00008001

000088f8 <SdioCard::begin(SdioConfig)>:
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    88f8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    88fc:	ldr	r4, [pc, #712]	; (8bc8 <SdioCard::begin(SdioConfig)+0x2d0>)
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    88fe:	ldr	r2, [pc, #716]	; (8bcc <SdioCard::begin(SdioConfig)+0x2d4>)
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
    8900:	ldr.w	ip, [pc, #828]	; 8c40 <SdioCard::begin(SdioConfig)+0x348>
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    8904:	ldr.w	lr, [pc, #828]	; 8c44 <SdioCard::begin(SdioConfig)+0x34c>
  m_version2 = false;
    8908:	ldr.w	sl, [pc, #828]	; 8c48 <SdioCard::begin(SdioConfig)+0x350>
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
    890c:	strb	r1, [r0, #8]
  m_curState = IDLE_STATE;
    890e:	movs	r3, #0
    8910:	strb	r3, [r0, #9]
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    8912:	strb	r3, [r4, #0]
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
    8914:	strb.w	r3, [ip]
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    8918:	strb.w	r3, [lr]
  m_version2 = false;
    891c:	strb.w	r3, [sl]
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    8920:	ldr	r3, [r2, #0]
  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8922:	ldr	r0, [pc, #684]	; (8bd0 <SdioCard::begin(SdioConfig)+0x2d8>)
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8924:	ldr	r5, [pc, #684]	; (8bd4 <SdioCard::begin(SdioConfig)+0x2dc>)
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8926:	ldr	r6, [pc, #688]	; (8bd8 <SdioCard::begin(SdioConfig)+0x2e0>)
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8928:	ldr	r7, [pc, #688]	; (8bdc <SdioCard::begin(SdioConfig)+0x2e4>)
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    892a:	ldr.w	r8, [pc, #800]	; 8c4c <SdioCard::begin(SdioConfig)+0x354>
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    892e:	ldr	r1, [pc, #688]	; (8be0 <SdioCard::begin(SdioConfig)+0x2e8>)
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    8930:	orr.w	r3, r3, #201326592	; 0xc000000
    8934:	str	r3, [r2, #0]
#endif  // HAS_KINETIS_MPU
  // Enable SDHC clock.
  SIM_SCGC3 |= SIM_SCGC3_SDHC;
    8936:	add.w	r2, r2, #239616	; 0x3a800
    893a:	adds	r2, #48	; 0x30
    893c:	ldr	r3, [r2, #0]
    893e:	orr.w	r3, r3, #131072	; 0x20000
    8942:	str	r3, [r2, #0]
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8944:	ldr	r2, [pc, #668]	; (8be4 <SdioCard::begin(SdioConfig)+0x2ec>)
    8946:	movw	r3, #259	; 0x103
    894a:	str	r3, [r2, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    894c:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    894e:	str	r3, [r6, #0]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8950:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8952:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8956:	str	r3, [r0, #0]
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    8958:	ldr	r3, [r1, #0]
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    895a:	sub	sp, #84	; 0x54
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    895c:	orr.w	r3, r3, #16777216	; 0x1000000
    8960:	orr.w	r3, r3, #32768	; 0x8000
    8964:	str	r3, [r1, #0]
    8966:	mov	r9, r0
    8968:	str.w	ip, [sp, #4]
    896c:	str.w	lr, [sp, #8]
    8970:	mov	fp, r1

  while (SDHC_SYSCTL & SDHC_SYSCTL_RSTA) {
    8972:	ldr.w	r1, [fp]
    8976:	ldr	r3, [pc, #616]	; (8be0 <SdioCard::begin(SdioConfig)+0x2e8>)
    8978:	lsls	r1, r1, #7
    897a:	bmi.n	8972 <SdioCard::begin(SdioConfig)+0x7a>
  }

  // Set initial SCK rate.
  setSdclk(SD_MAX_INIT_RATE_KHZ);
    897c:	mov.w	r0, #400	; 0x190
    8980:	str	r3, [sp, #0]
    8982:	str	r2, [sp, #12]
    8984:	bl	804c <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8988:	ldr	r2, [sp, #12]
    898a:	movw	r1, #1091	; 0x443
    898e:	str	r1, [r2, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8990:	mov.w	r2, #1088	; 0x440
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8994:	str	r1, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8996:	str	r2, [r6, #0]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    8998:	ldr	r2, [pc, #588]	; (8be8 <SdioCard::begin(SdioConfig)+0x2f0>)
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    899a:	str	r1, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    899c:	str.w	r1, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    89a0:	str.w	r1, [r9]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    89a4:	ldr	r1, [pc, #580]	; (8bec <SdioCard::begin(SdioConfig)+0x2f4>)
    89a6:	str	r1, [r2, #0]

  attachInterruptVector(IRQ_SDHC, sdIrs);
    89a8:	movs	r0, #81	; 0x51
    89aa:	ldr	r1, [pc, #580]	; (8bf0 <SdioCard::begin(SdioConfig)+0x2f8>)
    89ac:	bl	9458 <attachInterruptVector>
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    89b0:	ldr	r2, [pc, #576]	; (8bf4 <SdioCard::begin(SdioConfig)+0x2fc>)
    89b2:	movs	r1, #96	; 0x60
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    89b4:	mvn.w	r0, #840	; 0x348

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    89b8:	strb	r1, [r2, #0]
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    89ba:	add	r2, r0

  // Send 80 clocks to card.
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    89bc:	ldr	r3, [sp, #0]
  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    89be:	mov.w	r1, #131072	; 0x20000
    89c2:	str	r1, [r2, #0]

  // Send 80 clocks to card.
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    89c4:	ldr	r2, [r3, #0]
    89c6:	orr.w	r2, r2, #134217728	; 0x8000000
    89ca:	str	r2, [r3, #0]
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
    89cc:	ldr.w	r1, [fp]
    89d0:	ands.w	r1, r1, #134217728	; 0x8000000
    89d4:	bne.n	89cc <SdioCard::begin(SdioConfig)+0xd4>
  m_highCapacity = false;
  m_version2 = false;

  // initialize controller.
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    89d6:	mov	r0, r1
    89d8:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    89dc:	mov	fp, r0
    89de:	cbnz	r0, 89ea <SdioCard::begin(SdioConfig)+0xf2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    89e0:	movs	r3, #1
    89e2:	strb	r3, [r4, #0]
  m_errorLine = line;
    89e4:	movw	r2, #662	; 0x296
    89e8:	b.n	8a92 <SdioCard::begin(SdioConfig)+0x19a>
    89ea:	mov.w	fp, #3
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
    89ee:	mov.w	r1, #426	; 0x1aa
    89f2:	ldr	r0, [pc, #516]	; (8bf8 <SdioCard::begin(SdioConfig)+0x300>)
    89f4:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    89f8:	cbz	r0, 8a16 <SdioCard::begin(SdioConfig)+0x11e>
      if (SDHC_CMDRSP0 != 0X1AA) {
    89fa:	ldr	r3, [pc, #512]	; (8bfc <SdioCard::begin(SdioConfig)+0x304>)
    89fc:	ldr	r3, [r3, #0]
    89fe:	cmp.w	r3, #426	; 0x1aa
    8a02:	beq.n	8a0e <SdioCard::begin(SdioConfig)+0x116>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8a04:	movs	r3, #6
    8a06:	strb	r3, [r4, #0]
  m_errorLine = line;
    8a08:	mov.w	r2, #668	; 0x29c
    8a0c:	b.n	8b2e <SdioCard::begin(SdioConfig)+0x236>
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
      if (SDHC_CMDRSP0 != 0X1AA) {
        return sdError(SD_CARD_ERROR_CMD8);
      }
      m_version2 = true;
    8a0e:	movs	r3, #1
    8a10:	strb.w	r3, [sl]
      break;
    8a14:	b.n	8a1c <SdioCard::begin(SdioConfig)+0x124>
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    8a16:	subs.w	fp, fp, #1
    8a1a:	bne.n	89ee <SdioCard::begin(SdioConfig)+0xf6>
      }
      m_version2 = true;
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
    8a1c:	ldrb.w	r3, [sl]
    8a20:	cmp	r3, #0
    8a22:	ldr	r3, [pc, #476]	; (8c00 <SdioCard::begin(SdioConfig)+0x308>)
    8a24:	ite	eq
    8a26:	moveq.w	fp, #3145728	; 0x300000
    8a2a:	movne	fp, r3
  int m = micros();
    8a2c:	bl	953c <micros>
    8a30:	str	r0, [sp, #0]
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    8a32:	movs	r1, #0
    8a34:	ldr	r0, [pc, #460]	; (8c04 <SdioCard::begin(SdioConfig)+0x30c>)
    8a36:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    8a3a:	cmp	r0, #0
    8a3c:	beq.n	8b1c <SdioCard::begin(SdioConfig)+0x224>
    8a3e:	mov	r1, fp
    8a40:	ldr	r0, [pc, #452]	; (8c08 <SdioCard::begin(SdioConfig)+0x310>)
    8a42:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    8a46:	cmp	r0, #0
    8a48:	beq.n	8b1c <SdioCard::begin(SdioConfig)+0x224>
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
    8a4a:	bl	953c <micros>
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
    8a4e:	ldr	r3, [sp, #0]
    8a50:	subs	r0, r0, r3
    8a52:	ldr	r3, [pc, #440]	; (8c0c <SdioCard::begin(SdioConfig)+0x314>)
    8a54:	cmp	r0, r3
    8a56:	bhi.n	8b1c <SdioCard::begin(SdioConfig)+0x224>
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
    8a58:	ldr	r3, [pc, #416]	; (8bfc <SdioCard::begin(SdioConfig)+0x304>)
    8a5a:	ldr.w	sl, [pc, #416]	; 8bfc <SdioCard::begin(SdioConfig)+0x304>
    8a5e:	ldr	r3, [r3, #0]
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    8a60:	cmp	r3, #0
    8a62:	bge.n	8a32 <SdioCard::begin(SdioConfig)+0x13a>
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
    8a64:	ldr	r2, [pc, #424]	; (8c10 <SdioCard::begin(SdioConfig)+0x318>)
    8a66:	ldr.w	r1, [sl]
    8a6a:	str	r1, [r2, #0]
  if (SDHC_CMDRSP0 & 0x40000000) {
    8a6c:	ldr.w	r2, [sl]
    // Is high capacity.
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    8a70:	ldr	r0, [pc, #416]	; (8c14 <SdioCard::begin(SdioConfig)+0x31c>)
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    8a72:	lsls	r2, r2, #1
    // Is high capacity.
    m_highCapacity = true;
    8a74:	itt	mi
    8a76:	ldrmi	r3, [sp, #8]
    8a78:	movmi	r2, #1
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    8a7a:	mov.w	r1, #0
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    // Is high capacity.
    m_highCapacity = true;
    8a7e:	it	mi
    8a80:	strbmi	r2, [r3, #0]
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    8a82:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    8a86:	mov	fp, r0
    8a88:	cbnz	r0, 8a98 <SdioCard::begin(SdioConfig)+0x1a0>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8a8a:	movs	r3, #2
    8a8c:	strb	r3, [r4, #0]
  m_errorLine = line;
    8a8e:	mov.w	r2, #688	; 0x2b0
    8a92:	ldr	r3, [pc, #388]	; (8c18 <SdioCard::begin(SdioConfig)+0x320>)
    8a94:	str	r2, [r3, #0]
  if (SDHC_CMDRSP0 & 0x40000000) {
    // Is high capacity.
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD2);
    8a96:	b.n	8bbe <SdioCard::begin(SdioConfig)+0x2c6>
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    8a98:	movs	r1, #0
    8a9a:	ldr	r0, [pc, #384]	; (8c1c <SdioCard::begin(SdioConfig)+0x324>)
    8a9c:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    8aa0:	mov	fp, r0
    8aa2:	cbnz	r0, 8aae <SdioCard::begin(SdioConfig)+0x1b6>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8aa4:	movs	r3, #3
    8aa6:	strb	r3, [r4, #0]
  m_errorLine = line;
    8aa8:	movw	r2, #691	; 0x2b3
    8aac:	b.n	8a92 <SdioCard::begin(SdioConfig)+0x19a>
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    8aae:	ldr.w	r3, [sl]
    8ab2:	ldr.w	sl, [pc, #412]	; 8c50 <SdioCard::begin(SdioConfig)+0x358>

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    8ab6:	ldr	r1, [pc, #360]	; (8c20 <SdioCard::begin(SdioConfig)+0x328>)
    8ab8:	ldr	r0, [pc, #360]	; (8c24 <SdioCard::begin(SdioConfig)+0x32c>)
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    8aba:	lsrs	r3, r3, #16
    8abc:	lsls	r3, r3, #16
    8abe:	str.w	r3, [sl]

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    8ac2:	bl	8264 <readReg16(unsigned long, void*)>
    8ac6:	mov	fp, r0
    8ac8:	cbnz	r0, 8ad4 <SdioCard::begin(SdioConfig)+0x1dc>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8aca:	movs	r3, #7
    8acc:	strb	r3, [r4, #0]
  m_errorLine = line;
    8ace:	mov.w	r2, #696	; 0x2b8
    8ad2:	b.n	8a92 <SdioCard::begin(SdioConfig)+0x19a>
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    return sdError(SD_CARD_ERROR_CMD9);
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    8ad4:	ldr	r1, [pc, #336]	; (8c28 <SdioCard::begin(SdioConfig)+0x330>)
    8ad6:	ldr	r0, [pc, #340]	; (8c2c <SdioCard::begin(SdioConfig)+0x334>)
    8ad8:	bl	8264 <readReg16(unsigned long, void*)>
    8adc:	mov	fp, r0
    8ade:	cbnz	r0, 8aea <SdioCard::begin(SdioConfig)+0x1f2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8ae0:	movs	r3, #8
    8ae2:	strb	r3, [r4, #0]
  m_errorLine = line;
    8ae4:	movw	r2, #699	; 0x2bb
    8ae8:	b.n	8a92 <SdioCard::begin(SdioConfig)+0x19a>
    return sdError(SD_CARD_ERROR_CMD9);
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    return sdError(SD_CARD_ERROR_CMD10);
  }
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    8aea:	ldr.w	r1, [sl]
    8aee:	ldr	r0, [pc, #320]	; (8c30 <SdioCard::begin(SdioConfig)+0x338>)
    8af0:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    8af4:	mov	fp, r0
    8af6:	cbnz	r0, 8b02 <SdioCard::begin(SdioConfig)+0x20a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8af8:	movs	r3, #5
    8afa:	strb	r3, [r4, #0]
  m_errorLine = line;
    8afc:	movw	r2, #702	; 0x2be
    8b00:	b.n	8a92 <SdioCard::begin(SdioConfig)+0x19a>
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    8b02:	ldr.w	r1, [sl]
    8b06:	ldr	r0, [pc, #252]	; (8c04 <SdioCard::begin(SdioConfig)+0x30c>)
    8b08:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    8b0c:	cbz	r0, 8b26 <SdioCard::begin(SdioConfig)+0x22e>
    8b0e:	movs	r1, #2
    8b10:	ldr	r0, [pc, #288]	; (8c34 <SdioCard::begin(SdioConfig)+0x33c>)
    8b12:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    8b16:	mov	fp, r0
    8b18:	cbz	r0, 8b26 <SdioCard::begin(SdioConfig)+0x22e>
    8b1a:	b.n	8b38 <SdioCard::begin(SdioConfig)+0x240>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8b1c:	movs	r3, #23
    8b1e:	strb	r3, [r4, #0]
  m_errorLine = line;
    8b20:	movw	r2, #679	; 0x2a7
    8b24:	b.n	8b2e <SdioCard::begin(SdioConfig)+0x236>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8b26:	movs	r3, #20
    8b28:	strb	r3, [r4, #0]
  m_errorLine = line;
    8b2a:	movw	r2, #706	; 0x2c2
    8b2e:	ldr	r3, [pc, #232]	; (8c18 <SdioCard::begin(SdioConfig)+0x320>)
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
  }
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
    8b30:	mov.w	fp, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8b34:	str	r2, [r3, #0]
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
  }
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
    8b36:	b.n	8bbe <SdioCard::begin(SdioConfig)+0x2c6>
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
    8b38:	ldr	r3, [pc, #252]	; (8c38 <SdioCard::begin(SdioConfig)+0x340>)
    8b3a:	ldr	r2, [r3, #0]
    8b3c:	bic.w	r2, r2, #6
    8b40:	str	r2, [r3, #0]
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);
    8b42:	ldr	r2, [r3, #0]
    8b44:	orr.w	r2, r2, #2
    8b48:	str	r2, [r3, #0]

  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);
    8b4a:	mov.w	r2, #1048592	; 0x100010
    8b4e:	str	r2, [r3, #28]

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8b50:	add	r1, sp, #16
    8b52:	mvn.w	r0, #4278190080	; 0xff000000
    8b56:	bl	8860 <cardCMD6(unsigned long, unsigned char*)>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    8b5a:	cbz	r0, 8b64 <SdioCard::begin(SdioConfig)+0x26c>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8b5c:	ldrb.w	r3, [sp, #29]
    8b60:	lsls	r3, r3, #30
    8b62:	bmi.n	8b6a <SdioCard::begin(SdioConfig)+0x272>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    kHzSdClk = 50000;
  } else {
    kHzSdClk = 25000;
    8b64:	movw	r0, #25000	; 0x61a8
    8b68:	b.n	8b86 <SdioCard::begin(SdioConfig)+0x28e>

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    8b6a:	add	r1, sp, #16
    8b6c:	ldr	r0, [pc, #204]	; (8c3c <SdioCard::begin(SdioConfig)+0x344>)
    8b6e:	bl	8860 <cardCMD6(unsigned long, unsigned char*)>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8b72:	cmp	r0, #0
    8b74:	beq.n	8b64 <SdioCard::begin(SdioConfig)+0x26c>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    8b76:	ldrb.w	r3, [sp, #32]
    8b7a:	and.w	r3, r3, #15
    8b7e:	cmp	r3, #1
    8b80:	bne.n	8b64 <SdioCard::begin(SdioConfig)+0x26c>
    kHzSdClk = 50000;
    8b82:	movw	r0, #50000	; 0xc350
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8b86:	ldr	r4, [pc, #92]	; (8be4 <SdioCard::begin(SdioConfig)+0x2ec>)
    8b88:	movw	r3, #259	; 0x103
    8b8c:	str	r3, [r4, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8b8e:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8b90:	str	r3, [r6, #0]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8b92:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8b94:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8b98:	str.w	r3, [r9]
  }
  // Disable GPIO.
  enableGPIO(false);

  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);
    8b9c:	bl	804c <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8ba0:	movw	r3, #1091	; 0x443
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8ba4:	mov.w	r2, #1088	; 0x440
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8ba8:	str	r3, [r4, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8baa:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8bac:	str	r2, [r6, #0]
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    8bae:	ldr	r2, [sp, #4]
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8bb0:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8bb2:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8bb6:	str.w	r3, [r9]
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    8bba:	movs	r3, #1
    8bbc:	strb	r3, [r2, #0]
  return true;
}
    8bbe:	mov	r0, fp
    8bc0:	add	sp, #84	; 0x54
    8bc2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8bc6:	nop
    8bc8:	.word	0x1fff1338
    8bcc:	.word	0x4000d800
    8bd0:	.word	0x4004d014
    8bd4:	.word	0x4004d004
    8bd8:	.word	0x4004d008
    8bdc:	.word	0x4004d00c
    8be0:	.word	0x400b102c
    8be4:	.word	0x4004d000
    8be8:	.word	0x400b1034
    8bec:	.word	0x117f000b
    8bf0:	.word	0x00007f9d
    8bf4:	.word	0xe000e451
    8bf8:	.word	0x081a0000
    8bfc:	.word	0x400b1010
    8c00:	.word	0x40300000
    8c04:	.word	0x371a0000
    8c08:	.word	0x29020000
    8c0c:	.word	0x000f4240
    8c10:	.word	0x2001a6bc
    8c14:	.word	0x02090000
    8c18:	.word	0x2001a6e4
    8c1c:	.word	0x031a0000
    8c20:	.word	0x2001a6cd
    8c24:	.word	0x09090000
    8c28:	.word	0x2001a6a1
    8c2c:	.word	0x0a090000
    8c30:	.word	0x071b0000
    8c34:	.word	0x061a0000
    8c38:	.word	0x400b1028
    8c3c:	.word	0x80fffff1
    8c40:	.word	0x2001a6cc
    8c44:	.word	0x2001a6b8
    8c48:	.word	0x2001a6a0
    8c4c:	.word	0x4004d010
    8c50:	.word	0x2001a6c0

00008c54 <SdioCard::readData(unsigned char*)>:
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    8c54:	push	{r3, r4, r5, lr}
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    8c56:	ldr	r5, [pc, #152]	; (8cf0 <SdioCard::readData(unsigned char*)+0x9c>)
    8c58:	ldr	r3, [r5, #0]
    8c5a:	lsls	r3, r3, #22
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    8c5c:	mov	r4, r1
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    8c5e:	bmi.n	8c7e <SdioCard::readData(unsigned char*)+0x2a>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8c60:	ldr	r3, [pc, #144]	; (8cf4 <SdioCard::readData(unsigned char*)+0xa0>)
    8c62:	ldr	r2, [r3, #0]
    8c64:	bic.w	r2, r2, #65536	; 0x10000
    8c68:	str	r2, [r3, #0]
    noInterrupts();
    8c6a:	cpsid	i
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    8c6c:	ldr	r2, [r3, #0]
    8c6e:	orr.w	r2, r2, #131072	; 0x20000
    8c72:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    8c74:	ldr	r2, [r3, #0]
    8c76:	orr.w	r2, r2, #65536	; 0x10000
    8c7a:	str	r2, [r3, #0]
    interrupts();
    8c7c:	cpsie	i
  }
  if (waitTimeout(isBusyFifoRead)) {
    8c7e:	ldr	r0, [pc, #120]	; (8cf8 <SdioCard::readData(unsigned char*)+0xa4>)
    8c80:	bl	8148 <waitTimeout(bool (*)())>
    8c84:	cbnz	r0, 8cdc <SdioCard::readData(unsigned char*)+0x88>
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    8c86:	ldr	r1, [pc, #116]	; (8cfc <SdioCard::readData(unsigned char*)+0xa8>)
    8c88:	subs	r3, r4, #4
    8c8a:	add.w	r4, r4, #508	; 0x1fc
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    8c8e:	ldr	r2, [r5, #0]
    8c90:	lsls	r0, r2, #20
    8c92:	bpl.n	8c8e <SdioCard::readData(unsigned char*)+0x3a>
    8c94:	add.w	r2, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    8c98:	ldr	r0, [r1, #0]
    8c9a:	str.w	r0, [r3, #4]!
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    8c9e:	cmp	r2, r3
    8ca0:	bne.n	8c98 <SdioCard::readData(unsigned char*)+0x44>
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    8ca2:	cmp	r4, r2
    8ca4:	mov	r3, r2
    8ca6:	bne.n	8c8e <SdioCard::readData(unsigned char*)+0x3a>
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    }
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    8ca8:	ldr	r0, [pc, #84]	; (8d00 <SdioCard::readData(unsigned char*)+0xac>)
    8caa:	bl	8148 <waitTimeout(bool (*)())>
    8cae:	cbz	r0, 8cbc <SdioCard::readData(unsigned char*)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8cb0:	ldr	r3, [pc, #80]	; (8d04 <SdioCard::readData(unsigned char*)+0xb0>)
    8cb2:	movs	r2, #29
    8cb4:	strb	r2, [r3, #0]
  m_errorLine = line;
    8cb6:	movw	r2, #846	; 0x34e
    8cba:	b.n	8ce6 <SdioCard::readData(unsigned char*)+0x92>
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
    8cbc:	ldr	r2, [pc, #72]	; (8d08 <SdioCard::readData(unsigned char*)+0xb4>)
    8cbe:	ldr	r3, [pc, #76]	; (8d0c <SdioCard::readData(unsigned char*)+0xb8>)
    8cc0:	ldr	r1, [r2, #0]
    8cc2:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    8cc4:	ldr	r1, [r3, #0]
    8cc6:	str	r1, [r2, #0]
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    8cc8:	ldr	r2, [r3, #0]
    8cca:	lsls	r2, r2, #30
    8ccc:	bpl.n	8cec <SdioCard::readData(unsigned char*)+0x98>
    8cce:	ldr	r3, [r3, #0]
    8cd0:	ldr	r0, [pc, #60]	; (8d10 <SdioCard::readData(unsigned char*)+0xbc>)
    8cd2:	ands	r0, r3
    8cd4:	clz	r0, r0
    8cd8:	lsrs	r0, r0, #5
    8cda:	pop	{r3, r4, r5, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8cdc:	ldr	r3, [pc, #36]	; (8d04 <SdioCard::readData(unsigned char*)+0xb0>)
    8cde:	movs	r2, #26
    8ce0:	strb	r2, [r3, #0]
  m_errorLine = line;
    8ce2:	movw	r2, #835	; 0x343
    8ce6:	ldr	r3, [pc, #44]	; (8d14 <SdioCard::readData(unsigned char*)+0xc0>)
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
    8ce8:	movs	r0, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8cea:	str	r2, [r3, #0]
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
    8cec:	pop	{r3, r4, r5, pc}
    8cee:	nop
    8cf0:	.word	0x400b1024
    8cf4:	.word	0x400b1028
    8cf8:	.word	0x0000800d
    8cfc:	.word	0x400b1020
    8d00:	.word	0x00008035
    8d04:	.word	0x1fff1338
    8d08:	.word	0x400b1030
    8d0c:	.word	0x2001a6c8
    8d10:	.word	0x117f0000
    8d14:	.word	0x2001a6e4

00008d18 <SdioCard::readStart(unsigned long)>:
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    8d18:	push	{r4, lr}
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    8d1a:	ldr	r0, [pc, #80]	; (8d6c <SdioCard::readStart(unsigned long)+0x54>)
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    8d1c:	mov	r4, r1
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    8d1e:	bl	816c <yieldTimeout(bool (*)())>
    8d22:	cbz	r0, 8d36 <SdioCard::readStart(unsigned long)+0x1e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8d24:	ldr	r3, [pc, #72]	; (8d70 <SdioCard::readStart(unsigned long)+0x58>)
    8d26:	movs	r2, #10
    8d28:	strb	r2, [r3, #0]
  m_errorLine = line;
    8d2a:	ldr	r3, [pc, #72]	; (8d74 <SdioCard::readStart(unsigned long)+0x5c>)
    8d2c:	mov.w	r2, #928	; 0x3a0
    8d30:	str	r2, [r3, #0]
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    8d32:	movs	r0, #0
    8d34:	pop	{r4, pc}
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    8d36:	ldr	r2, [pc, #64]	; (8d78 <SdioCard::readStart(unsigned long)+0x60>)
    8d38:	ldr	r3, [r2, #0]
    8d3a:	orr.w	r3, r3, #65536	; 0x10000
    8d3e:	str	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    8d40:	ldr	r3, [pc, #56]	; (8d7c <SdioCard::readStart(unsigned long)+0x64>)
    8d42:	ldr	r2, [pc, #60]	; (8d80 <SdioCard::readStart(unsigned long)+0x68>)
    8d44:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    8d46:	ldr	r3, [pc, #60]	; (8d84 <SdioCard::readStart(unsigned long)+0x6c>)
    8d48:	ldrb	r3, [r3, #0]
    8d4a:	cbnz	r3, 8d50 <SdioCard::readStart(unsigned long)+0x38>
    8d4c:	lsls	r1, r4, #9
    8d4e:	b.n	8d52 <SdioCard::readStart(unsigned long)+0x3a>
    8d50:	mov	r1, r4
    8d52:	ldr	r0, [pc, #52]	; (8d88 <SdioCard::readStart(unsigned long)+0x70>)
    8d54:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    8d58:	cbnz	r0, 8d68 <SdioCard::readStart(unsigned long)+0x50>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8d5a:	ldr	r3, [pc, #20]	; (8d70 <SdioCard::readStart(unsigned long)+0x58>)
    8d5c:	movs	r2, #12
    8d5e:	strb	r2, [r3, #0]
  m_errorLine = line;
    8d60:	ldr	r3, [pc, #16]	; (8d74 <SdioCard::readStart(unsigned long)+0x5c>)
    8d62:	mov.w	r2, #940	; 0x3ac
    8d66:	str	r2, [r3, #0]

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD18);
  }
  return true;
}
    8d68:	pop	{r4, pc}
    8d6a:	nop
    8d6c:	.word	0x00008251
    8d70:	.word	0x1fff1338
    8d74:	.word	0x2001a6e4
    8d78:	.word	0x400b1028
    8d7c:	.word	0x400b1004
    8d80:	.word	0xffff0200
    8d84:	.word	0x2001a6b8
    8d88:	.word	0x123a0032

00008d8c <SdioCard::readSector(unsigned long, unsigned char*)>:
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8d8c:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    8d8e:	ldrb	r3, [r0, #8]
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8d90:	mov	r6, r2
  if (m_sdioConfig.useDma()) {
    8d92:	lsls	r2, r3, #31
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8d94:	sub.w	sp, sp, #512	; 0x200
    8d98:	mov	r4, r0
    8d9a:	mov	r5, r1
  if (m_sdioConfig.useDma()) {
    8d9c:	bpl.n	8dd6 <SdioCard::readSector(unsigned long, unsigned char*)+0x4a>
    uint8_t aligned[512];

    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;
    8d9e:	lsls	r3, r6, #30
    8da0:	ite	eq
    8da2:	moveq	r4, r6
    8da4:	movne	r4, sp

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
    8da6:	movs	r3, #1
    8da8:	mov	r2, r4
    8daa:	ldr	r0, [pc, #148]	; (8e40 <SdioCard::readSector(unsigned long, unsigned char*)+0xb4>)
    8dac:	bl	82ec <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    8db0:	mov	r5, r0
    8db2:	cbnz	r0, 8dc4 <SdioCard::readSector(unsigned long, unsigned char*)+0x38>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8db4:	ldr	r3, [pc, #140]	; (8e44 <SdioCard::readSector(unsigned long, unsigned char*)+0xb8>)
    8db6:	movs	r2, #11
    8db8:	strb	r2, [r3, #0]
  m_errorLine = line;
    8dba:	ldr	r3, [pc, #140]	; (8e48 <SdioCard::readSector(unsigned long, unsigned char*)+0xbc>)
    8dbc:	movw	r2, #865	; 0x361
    8dc0:	str	r2, [r3, #0]
    8dc2:	b.n	8e38 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD17);
    }
    if (ptr != dst) {
    8dc4:	cmp	r4, r6
    8dc6:	beq.n	8e38 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
      memcpy(dst, aligned, 512);
    8dc8:	mov.w	r2, #512	; 0x200
    8dcc:	mov	r1, sp
    8dce:	mov	r0, r6
    8dd0:	bl	8f3c <memcpy>
    8dd4:	b.n	8e38 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    8dd6:	bl	84c4 <waitTransferComplete()>
    8dda:	cbnz	r0, 8de0 <SdioCard::readSector(unsigned long, unsigned char*)+0x54>
      return false;
    8ddc:	movs	r5, #0
    8dde:	b.n	8e38 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    }
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != READ_STATE || sector != m_curSector) {
    8de0:	ldrb	r3, [r4, #9]
    8de2:	cmp	r3, #1
    8de4:	bne.n	8dec <SdioCard::readSector(unsigned long, unsigned char*)+0x60>
    8de6:	ldr	r3, [r4, #4]
    8de8:	cmp	r5, r3
    8dea:	beq.n	8e0a <SdioCard::readSector(unsigned long, unsigned char*)+0x7e>
      if (!syncDevice()) {
    8dec:	ldr	r3, [r4, #0]
    8dee:	mov	r0, r4
    8df0:	ldr	r3, [r3, #28]
    8df2:	blx	r3
    8df4:	cmp	r0, #0
    8df6:	beq.n	8ddc <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
        return false;
      }
      if (!readStart(sector)) {
    8df8:	mov	r1, r5
    8dfa:	mov	r0, r4
    8dfc:	bl	8d18 <SdioCard::readStart(unsigned long)>
    8e00:	cmp	r0, #0
    8e02:	beq.n	8ddc <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
        return false;
      }
      m_curSector = sector;
      m_curState = READ_STATE;
    8e04:	movs	r3, #1
        return false;
      }
      if (!readStart(sector)) {
        return false;
      }
      m_curSector = sector;
    8e06:	str	r5, [r4, #4]
      m_curState = READ_STATE;
    8e08:	strb	r3, [r4, #9]
    }
    if (!readData(dst)) {
    8e0a:	mov	r1, r6
    8e0c:	mov	r0, r4
    8e0e:	bl	8c54 <SdioCard::readData(unsigned char*)>
    8e12:	mov	r5, r0
    8e14:	cmp	r0, #0
    8e16:	beq.n	8ddc <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    8e18:	ldr	r3, [pc, #48]	; (8e4c <SdioCard::readSector(unsigned long, unsigned char*)+0xc0>)
    8e1a:	ldr	r3, [r3, #0]
    8e1c:	lsrs	r3, r3, #16
    8e1e:	lsls	r3, r3, #16
    8e20:	cbz	r3, 8e2a <SdioCard::readSector(unsigned long, unsigned char*)+0x9e>
      if (!syncDevice()) {
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
    8e22:	ldr	r3, [r4, #4]
    8e24:	adds	r3, #1
    8e26:	str	r3, [r4, #4]
    8e28:	b.n	8e38 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    if (!readData(dst)) {
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    8e2a:	ldr	r3, [r4, #0]
    8e2c:	mov	r0, r4
    8e2e:	ldr	r3, [r3, #28]
    8e30:	blx	r3
    8e32:	cmp	r0, #0
    8e34:	bne.n	8e22 <SdioCard::readSector(unsigned long, unsigned char*)+0x96>
    8e36:	b.n	8ddc <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
}
    8e38:	mov	r0, r5
    8e3a:	add.w	sp, sp, #512	; 0x200
    8e3e:	pop	{r4, r5, r6, pc}
    8e40:	.word	0x113a0011
    8e44:	.word	0x1fff1338
    8e48:	.word	0x2001a6e4
    8e4c:	.word	0x400b1004

00008e50 <SdioCard::stopTransmission(bool)>:
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    8e50:	push	{r4, r5, r6, lr}
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8e52:	ldr	r2, [pc, #72]	; (8e9c <SdioCard::stopTransmission(bool)+0x4c>)
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
    8e54:	movs	r5, #0
    8e56:	strb	r5, [r0, #9]
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8e58:	ldr	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    8e5a:	ldr	r0, [pc, #68]	; (8ea0 <SdioCard::stopTransmission(bool)+0x50>)
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8e5c:	bic.w	r3, r3, #65536	; 0x10000
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    8e60:	mov	r6, r1
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8e62:	str	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    8e64:	mov	r1, r5
    8e66:	bl	81dc <cardCommand(unsigned long, unsigned long)>
    8e6a:	mov	r4, r0
    8e6c:	cbnz	r0, 8e7e <SdioCard::stopTransmission(bool)+0x2e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8e6e:	ldr	r3, [pc, #52]	; (8ea4 <SdioCard::stopTransmission(bool)+0x54>)
    8e70:	movs	r2, #9
    8e72:	strb	r2, [r3, #0]
  m_errorLine = line;
    8e74:	ldr	r3, [pc, #48]	; (8ea8 <SdioCard::stopTransmission(bool)+0x58>)
    8e76:	movw	r2, #962	; 0x3c2
    8e7a:	str	r2, [r3, #0]
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
    8e7c:	b.n	8e98 <SdioCard::stopTransmission(bool)+0x48>
  }
  if (blocking) {
    8e7e:	cbz	r6, 8e98 <SdioCard::stopTransmission(bool)+0x48>
    if (yieldTimeout(isBusyDat)) {
    8e80:	ldr	r0, [pc, #40]	; (8eac <SdioCard::stopTransmission(bool)+0x5c>)
    8e82:	bl	816c <yieldTimeout(bool (*)())>
    8e86:	cbz	r0, 8e98 <SdioCard::stopTransmission(bool)+0x48>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8e88:	ldr	r3, [pc, #24]	; (8ea4 <SdioCard::stopTransmission(bool)+0x54>)
    8e8a:	movs	r2, #10
    8e8c:	strb	r2, [r3, #0]
  m_errorLine = line;
    8e8e:	ldr	r3, [pc, #24]	; (8ea8 <SdioCard::stopTransmission(bool)+0x58>)
    8e90:	movw	r2, #966	; 0x3c6
    8e94:	str	r2, [r3, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
  if (blocking) {
    if (yieldTimeout(isBusyDat)) {
      return sdError(SD_CARD_ERROR_CMD13);
    8e96:	mov	r4, r5
    }
  }
  return true;
}
    8e98:	mov	r0, r4
    8e9a:	pop	{r4, r5, r6, pc}
    8e9c:	.word	0x400b1028
    8ea0:	.word	0x0cdb0000
    8ea4:	.word	0x1fff1338
    8ea8:	.word	0x2001a6e4
    8eac:	.word	0x00007fed

00008eb0 <SdioCard::syncDevice()>:
//------------------------------------------------------------------------------
bool SdioCard::syncDevice() {
    8eb0:	push	{r4, lr}
    8eb2:	mov	r4, r0
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    8eb4:	bl	84c4 <waitTransferComplete()>
    8eb8:	cbz	r0, 8eca <SdioCard::syncDevice()+0x1a>
    return false;
  }
  if (m_curState != IDLE_STATE) {
    8eba:	ldrb	r3, [r4, #9]
    8ebc:	cbz	r3, 8eca <SdioCard::syncDevice()+0x1a>
    return stopTransmission(true);
    8ebe:	mov	r0, r4
    8ec0:	movs	r1, #1
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    8ec2:	ldmia.w	sp!, {r4, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    return false;
  }
  if (m_curState != IDLE_STATE) {
    return stopTransmission(true);
    8ec6:	b.w	8e50 <SdioCard::stopTransmission(bool)>
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    8eca:	pop	{r4, pc}

00008ecc <SdioCard::isBusy()>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorLine() const {
  return m_errorLine;
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
    8ecc:	push	{r4, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    8ece:	ldrb	r3, [r0, #8]
    8ed0:	lsls	r3, r3, #31
//------------------------------------------------------------------------------
uint32_t SdioCard::errorLine() const {
  return m_errorLine;
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
    8ed2:	mov	r2, r0
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    8ed4:	bpl.n	8ef4 <SdioCard::isBusy()+0x28>
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    8ed6:	ldr	r3, [pc, #80]	; (8f28 <SdioCard::isBusy()+0x5c>)
    8ed8:	ldr	r3, [r3, #0]
    8eda:	cbz	r3, 8ee2 <SdioCard::isBusy()+0x16>
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    8edc:	ldmia.w	sp!, {r4, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    8ee0:	bx	r3
    8ee2:	ldr	r3, [pc, #72]	; (8f2c <SdioCard::isBusy()+0x60>)
    8ee4:	ldrb	r3, [r3, #0]
    8ee6:	cbnz	r3, 8eec <SdioCard::isBusy()+0x20>
    8ee8:	movs	r0, #0
    8eea:	pop	{r4, pc}
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    8eec:	ldmia.w	sp!, {r4, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    8ef0:	b.w	8250 <isBusyCMD13()>
  } else {
    if (m_transferActive) {
    8ef4:	ldr	r1, [pc, #56]	; (8f30 <SdioCard::isBusy()+0x64>)
    8ef6:	ldrb	r4, [r1, #0]
    8ef8:	cbz	r4, 8f1a <SdioCard::isBusy()+0x4e>
      if (isBusyTransferComplete()) {
    8efa:	bl	8034 <isBusyTransferComplete()>
    8efe:	cbnz	r0, 8f26 <SdioCard::isBusy()+0x5a>
        return true;
      }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
      if ((SDHC_BLKATTR & 0XFFFF0000) != 0) {
    8f00:	ldr	r3, [pc, #48]	; (8f34 <SdioCard::isBusy()+0x68>)
    8f02:	ldr	r3, [r3, #0]
    8f04:	lsrs	r3, r3, #16
    8f06:	lsls	r3, r3, #16
    8f08:	cmp	r3, #0
    8f0a:	bne.n	8ee8 <SdioCard::isBusy()+0x1c>
        return false;
      }
      m_transferActive = false;
    8f0c:	strb	r0, [r1, #0]
      stopTransmission(false);
    8f0e:	mov	r1, r0
    8f10:	mov	r0, r2
    8f12:	bl	8e50 <SdioCard::stopTransmission(bool)>
    8f16:	mov	r0, r4
    8f18:	pop	{r4, pc}
#else  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
      return false;
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    }
    // Use DAT0 low as busy.
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
    8f1a:	ldr	r3, [pc, #28]	; (8f38 <SdioCard::isBusy()+0x6c>)
    8f1c:	ldr	r0, [r3, #0]
    8f1e:	eor.w	r0, r0, #16777216	; 0x1000000
    8f22:	ubfx	r0, r0, #24, #1
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    8f26:	pop	{r4, pc}
    8f28:	.word	0x2001a6b4
    8f2c:	.word	0x2001a6cc
    8f30:	.word	0x2001a6c4
    8f34:	.word	0x400b1004
    8f38:	.word	0x400b1024

00008f3c <memcpy>:
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
#else
	push	{r0}
    8f3c:	push	{r0}
#endif
	orr	r3, r1, r0
    8f3e:	orr.w	r3, r1, r0
	ands	r3, r3, #3
    8f42:	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    8f46:	bne.n	9028 <memcpy+0xec>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    8f48:	subs	r2, #64	; 0x40
	blo	.Lmid_block
    8f4a:	bcc.n	8fd0 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    8f4c:	ldr.w	r3, [r1], #4
    8f50:	str.w	r3, [r0], #4
    8f54:	ldr.w	r3, [r1], #4
    8f58:	str.w	r3, [r0], #4
    8f5c:	ldr.w	r3, [r1], #4
    8f60:	str.w	r3, [r0], #4
    8f64:	ldr.w	r3, [r1], #4
    8f68:	str.w	r3, [r0], #4
    8f6c:	ldr.w	r3, [r1], #4
    8f70:	str.w	r3, [r0], #4
    8f74:	ldr.w	r3, [r1], #4
    8f78:	str.w	r3, [r0], #4
    8f7c:	ldr.w	r3, [r1], #4
    8f80:	str.w	r3, [r0], #4
    8f84:	ldr.w	r3, [r1], #4
    8f88:	str.w	r3, [r0], #4
    8f8c:	ldr.w	r3, [r1], #4
    8f90:	str.w	r3, [r0], #4
    8f94:	ldr.w	r3, [r1], #4
    8f98:	str.w	r3, [r0], #4
    8f9c:	ldr.w	r3, [r1], #4
    8fa0:	str.w	r3, [r0], #4
    8fa4:	ldr.w	r3, [r1], #4
    8fa8:	str.w	r3, [r0], #4
    8fac:	ldr.w	r3, [r1], #4
    8fb0:	str.w	r3, [r0], #4
    8fb4:	ldr.w	r3, [r1], #4
    8fb8:	str.w	r3, [r0], #4
    8fbc:	ldr.w	r3, [r1], #4
    8fc0:	str.w	r3, [r0], #4
    8fc4:	ldr.w	r3, [r1], #4
    8fc8:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    8fcc:	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    8fce:	bcs.n	8f4c <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    8fd0:	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    8fd2:	bcc.n	8ff8 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    8fd4:	ldr.w	r3, [r1], #4
    8fd8:	str.w	r3, [r0], #4
    8fdc:	ldr.w	r3, [r1], #4
    8fe0:	str.w	r3, [r0], #4
    8fe4:	ldr.w	r3, [r1], #4
    8fe8:	str.w	r3, [r0], #4
    8fec:	ldr.w	r3, [r1], #4
    8ff0:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    8ff4:	subs	r2, #16
	bhs	.Lmid_block_loop
    8ff6:	bcs.n	8fd4 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    8ff8:	adds	r2, #12
	blo	.Lcopy_less_than_4
    8ffa:	bcc.n	9008 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    8ffc:	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    9000:	str.w	r3, [r0], #4
	subs	r2, #4
    9004:	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    9006:	bcs.n	8ffc <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    9008:	adds	r2, #4
	beq	.Ldone
    900a:	beq.n	9022 <memcpy+0xe6>

	lsls	r2, r2, #31
    900c:	lsls	r2, r2, #31
	itt ne
    900e:	itt	ne
	ldrbne  r3, [r1], #1
    9010:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    9014:	strbne.w	r3, [r0], #1

	bcc	.Ldone
    9018:	bcc.n	9022 <memcpy+0xe6>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
	strh	r3, [r0]
#else
	ldrb	r3, [r1]
    901a:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    901c:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    901e:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    9020:	strb	r3, [r0, #1]

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    9022:	pop	{r0}
#endif
	bx	lr
    9024:	bx	lr
    9026:	nop
	beq	.Ldst_aligned
#else
	/* if len < 12, misalignment adjustment has more overhead than
	just byte-to-byte copy.  Also, len must >=8 to guarantee code
	afterward work correctly.  */
	cmp	r2, #12
    9028:	cmp	r2, #12
	blo	.Lbyte_copy
    902a:	bcc.n	90c2 <memcpy+0x186>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    902c:	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    9030:	beq.n	9056 <memcpy+0x11a>

	rsb	r3, #4
    9032:	rsb	r3, r3, #4
	subs	r2, r3
    9036:	subs	r2, r2, r3

	lsls    r3, r3, #31
    9038:	lsls	r3, r3, #31
	itt ne
    903a:	itt	ne
	ldrbne  r3, [r1], #1
    903c:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    9040:	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    9044:	bcc.n	9056 <memcpy+0x11a>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
	strh    r3, [r0], #2
	b	.Ldst_aligned
#else
	ldrb    r3, [r1], #1
    9046:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    904a:	strb.w	r3, [r0], #1
	ldrb    r3, [r1], #1
    904e:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    9052:	strb.w	r3, [r0], #1
	/* Now that dst is aligned */
.Ldst_aligned:
	/* if r1 is aligned now, it means r0/r1 has the same misalignment,
	and they are both aligned now.  Go aligned copy.  */
	ands	r3, r1, #3
    9056:	ands.w	r3, r1, #3
	beq	.Lbig_block
    905a:	beq.w	8f48 <memcpy+0xc>

	/* dst is aligned, but src isn't.  Misaligned copy.  */

	push	{r4, r5}
    905e:	push	{r4, r5}
	subs	r2, #4
    9060:	subs	r2, #4

	/* Backward r1 by misaligned bytes, to make r1 aligned.
	Since we need to restore r1 to unaligned address after the loop,
	we need keep the offset bytes to ip and sub it from r1 afterward.  */
	subs	r1, r3
    9062:	subs	r1, r1, r3
	rsb	ip, r3, #4
    9064:	rsb	ip, r3, #4

	/* Pre-load on word */
	ldr	r4, [r1], #4
    9068:	ldr.w	r4, [r1], #4

	cmp	r3, #2
    906c:	cmp	r3, #2
	beq	.Lmisaligned_copy_2_2
    906e:	beq.n	90a4 <memcpy+0x168>
	cmp	r3, #3
    9070:	cmp	r3, #3
	beq	.Lmisaligned_copy_3_1
    9072:	beq.n	908c <memcpy+0x150>
	subs	r2, #4
	bhs	1b
	.endm

.Lmisaligned_copy_1_3:
	mis_src_copy shift=8
    9074:	lsrs	r4, r4, #8
    9076:	ldr.w	r3, [r1], #4
    907a:	lsls	r5, r3, #24
    907c:	orr.w	r4, r4, r5
    9080:	str.w	r4, [r0], #4
    9084:	mov	r4, r3
    9086:	subs	r2, #4
    9088:	bcs.n	9074 <memcpy+0x138>
	b	.Lsrc_misaligned_tail
    908a:	b.n	90ba <memcpy+0x17e>

.Lmisaligned_copy_3_1:
	mis_src_copy shift=24
    908c:	lsrs	r4, r4, #24
    908e:	ldr.w	r3, [r1], #4
    9092:	lsls	r5, r3, #8
    9094:	orr.w	r4, r4, r5
    9098:	str.w	r4, [r0], #4
    909c:	mov	r4, r3
    909e:	subs	r2, #4
    90a0:	bcs.n	908c <memcpy+0x150>
	b	.Lsrc_misaligned_tail
    90a2:	b.n	90ba <memcpy+0x17e>

.Lmisaligned_copy_2_2:
	/* For 2_2 misalignment, ldr is still faster than 2 x ldrh.  */
	mis_src_copy shift=16
    90a4:	lsrs	r4, r4, #16
    90a6:	ldr.w	r3, [r1], #4
    90aa:	lsls	r5, r3, #16
    90ac:	orr.w	r4, r4, r5
    90b0:	str.w	r4, [r0], #4
    90b4:	mov	r4, r3
    90b6:	subs	r2, #4
    90b8:	bcs.n	90a4 <memcpy+0x168>

.Lsrc_misaligned_tail:
	adds	r2, #4
    90ba:	adds	r2, #4
	subs	r1, ip
    90bc:	subs.w	r1, r1, ip
	pop	{r4, r5}
    90c0:	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    90c2:	subs	r2, #4
	blo	.Lcopy_less_than_4
    90c4:	bcc.n	9008 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    90c6:	subs	r2, #1
	ldrb    r3, [r1], #1
    90c8:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    90cc:	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    90d0:	bcs.n	90c6 <memcpy+0x18a>

	ldrb	r3, [r1]
    90d2:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    90d4:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    90d6:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    90d8:	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    90da:	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    90dc:	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    90de:	pop	{r0}
#endif
	bx	lr
    90e0:	bx	lr
    90e2:	nop

000090e4 <memset>:
	.type	memset, %function
	.thumb_func
	memset:
//FUNCTION(memset)
    // save the original pointer
    push    { r0, lr }
    90e4:	push	{r0, lr}

    // check for zero length
    cbz     r2, .L_done
    90e6:	cbz	r2, 9124 <memset+0x40>

    // short memsets aren't worth optimizing and make sure we have
    // enough headroom to try to do dwordwise move optimization
    cmp     r2, #16
    90e8:	cmp	r2, #16
    blt     .L_bytewise
    90ea:	blt.n	911c <memset+0x38>

    // see how many bytes we need to move to align to dword boundaries
    and     r3, r0, #7
    90ec:	and.w	r3, r0, #7
    cbz     r3, .L_prepare_dwordwise
    90f0:	cbz	r3, 9100 <memset+0x1c>
    rsb     r3, #8
    90f2:	rsb	r3, r3, #8
    subs    r2, r3
    90f6:	subs	r2, r2, r3

.L_bytewise_align:
    // bytewise to align memset
    subs    r3, r3, #1
    90f8:	subs	r3, #1
    strb    r1, [r0], #1
    90fa:	strb.w	r1, [r0], #1
    bgt     .L_bytewise_align
    90fe:	bgt.n	90f8 <memset+0x14>

.L_prepare_dwordwise:
    // fill a pair of 32 bit registers with the 8 bit value
    uxtb    r1, r1
    9100:	uxtb	r1, r1
    orr     r1, r1, r1, lsl #8
    9102:	orr.w	r1, r1, r1, lsl #8
    orr     r1, r1, r1, lsl #16
    9106:	orr.w	r1, r1, r1, lsl #16
    mov     r12, r1
    910a:	mov	ip, r1

    // load the number of dwords left
    lsrs    r3, r2, #3
    910c:	lsrs	r3, r2, #3

.L_dwordwise:
    // dwordwise memset
		
    subs    r3, r3, #1
    910e:	subs	r3, #1
    strd    r1, r12, [r0], #8
    9110:	strd	r1, ip, [r0], #8
    bgt     .L_dwordwise
    9114:	bgt.n	910e <memset+0x2a>

    // remaining bytes
    ands     r2, #7
    9116:	ands.w	r2, r2, #7
    beq     .L_done
    911a:	beq.n	9124 <memset+0x40>

.L_bytewise:
    // bytewise memset
    subs    r2, r2, #1
    911c:	subs	r2, #1
    strb    r1, [r0], #1
    911e:	strb.w	r1, [r0], #1
    bgt     .L_bytewise
    9122:	bgt.n	911c <memset+0x38>

.L_done:
    // restore the base pointer as return value
    pop     { r0, pc }
    9124:	pop	{r0, pc}
    9126:	nop

00009128 <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    9128:	push	{r4, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    912a:	ldr	r4, [pc, #64]	; (916c <usb_serial_getchar+0x44>)
    912c:	ldr	r3, [r4, #0]
    912e:	cbz	r3, 914c <usb_serial_getchar+0x24>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    9130:	ldr	r0, [r4, #0]
    9132:	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
    9134:	adds	r2, r3, #1
    9136:	add	r3, r0
    9138:	ldrb	r4, [r3, #8]
	if (i >= rx_packet->len) {
    913a:	ldrh	r3, [r0, #0]
    913c:	cmp	r2, r3
    913e:	bcc.n	9166 <usb_serial_getchar+0x3e>
		usb_free(rx_packet);
    9140:	bl	96ec <usb_free>
		rx_packet = NULL;
    9144:	ldr	r3, [pc, #36]	; (916c <usb_serial_getchar+0x44>)
    9146:	movs	r2, #0
    9148:	str	r2, [r3, #0]
    914a:	b.n	9168 <usb_serial_getchar+0x40>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    914c:	ldr	r3, [pc, #32]	; (9170 <usb_serial_getchar+0x48>)
    914e:	ldrb	r3, [r3, #0]
    9150:	cbnz	r3, 9158 <usb_serial_getchar+0x30>
    9152:	mov.w	r0, #4294967295
    9156:	pop	{r4, pc}
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    9158:	movs	r0, #3
    915a:	bl	9770 <usb_rx>
    915e:	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    9160:	cmp	r0, #0
    9162:	bne.n	9130 <usb_serial_getchar+0x8>
    9164:	b.n	9152 <usb_serial_getchar+0x2a>
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    9166:	strh	r2, [r0, #2]
	}
	return c;
    9168:	mov	r0, r4
}
    916a:	pop	{r4, pc}
    916c:	.word	0x2001a6f4
    9170:	.word	0x2001a7df

00009174 <usb_serial_peekchar>:

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    9174:	push	{r4, lr}
	if (!rx_packet) {
    9176:	ldr	r4, [pc, #44]	; (91a4 <usb_serial_peekchar+0x30>)
    9178:	ldr	r3, [r4, #0]
    917a:	cbz	r3, 9182 <usb_serial_peekchar+0xe>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
    917c:	ldr	r2, [r4, #0]
    917e:	cbnz	r2, 919c <usb_serial_peekchar+0x28>
    9180:	b.n	9188 <usb_serial_peekchar+0x14>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    9182:	ldr	r3, [pc, #36]	; (91a8 <usb_serial_peekchar+0x34>)
    9184:	ldrb	r3, [r3, #0]
    9186:	cbnz	r3, 918e <usb_serial_peekchar+0x1a>
    9188:	mov.w	r0, #4294967295
    918c:	pop	{r4, pc}
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    918e:	movs	r0, #3
    9190:	bl	9770 <usb_rx>
    9194:	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    9196:	cmp	r0, #0
    9198:	bne.n	917c <usb_serial_peekchar+0x8>
    919a:	b.n	9188 <usb_serial_peekchar+0x14>
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    919c:	ldrh	r3, [r2, #2]
    919e:	add	r3, r2
    91a0:	ldrb	r0, [r3, #8]
}
    91a2:	pop	{r4, pc}
    91a4:	.word	0x2001a6f4
    91a8:	.word	0x2001a7df

000091ac <usb_serial_available>:
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    91ac:	ldr	r3, [pc, #16]	; (91c0 <usb_serial_available+0x14>)

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    91ae:	ldrh	r0, [r3, #4]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    91b0:	ldr	r3, [pc, #16]	; (91c4 <usb_serial_available+0x18>)
    91b2:	ldr	r2, [r3, #0]
    91b4:	cbz	r2, 91be <usb_serial_available+0x12>
    91b6:	ldrh	r3, [r2, #0]
    91b8:	ldrh	r2, [r2, #2]
    91ba:	subs	r3, r3, r2
    91bc:	add	r0, r3
	return count;
}
    91be:	bx	lr
    91c0:	.word	0x2001a854
    91c4:	.word	0x2001a6f4

000091c8 <usb_serial_flush_input>:
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    91c8:	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
    91ca:	ldr	r3, [pc, #36]	; (91f0 <usb_serial_flush_input+0x28>)
    91cc:	ldrb	r3, [r3, #0]
    91ce:	cbz	r3, 91ec <usb_serial_flush_input+0x24>
	if (rx_packet) {
    91d0:	ldr	r4, [pc, #32]	; (91f4 <usb_serial_flush_input+0x2c>)
    91d2:	ldr	r0, [r4, #0]
    91d4:	cbz	r0, 91de <usb_serial_flush_input+0x16>
		usb_free(rx_packet);
    91d6:	bl	96ec <usb_free>
		rx_packet = NULL;
    91da:	movs	r3, #0
    91dc:	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    91de:	movs	r0, #3
    91e0:	bl	9770 <usb_rx>
		if (!rx) break;
    91e4:	cbz	r0, 91ec <usb_serial_flush_input+0x24>
		usb_free(rx);
    91e6:	bl	96ec <usb_free>
	}
    91ea:	b.n	91de <usb_serial_flush_input+0x16>
    91ec:	pop	{r4, pc}
    91ee:	nop
    91f0:	.word	0x2001a7df
    91f4:	.word	0x2001a6f4

000091f8 <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    91f8:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    91fc:	ldr	r5, [pc, #196]	; (92c4 <usb_serial_write+0xcc>)
	while (size > 0) {
		if (!tx_packet) {
    91fe:	ldr.w	r9, [pc, #212]	; 92d4 <usb_serial_write+0xdc>
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    9202:	movs	r3, #1
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    9204:	mov	sl, r0
    9206:	mov	r4, r1
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    9208:	strb	r3, [r5, #0]
	while (size > 0) {
    920a:	mov	r6, r1
    920c:	mov	r7, r9
    920e:	cmp	r6, #0
    9210:	beq.n	92ba <usb_serial_write+0xc2>
		if (!tx_packet) {
    9212:	ldr.w	r3, [r9]
    9216:	cbnz	r3, 9268 <usb_serial_write+0x70>
    9218:	ldr.w	fp, [pc, #176]	; 92cc <usb_serial_write+0xd4>
    921c:	movw	r8, #41721	; 0xa2f9
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    9220:	ldr	r3, [pc, #164]	; (92c8 <usb_serial_write+0xd0>)
    9222:	ldrb	r3, [r3, #0]
    9224:	and.w	r1, r3, #255	; 0xff
    9228:	cbnz	r3, 922e <usb_serial_write+0x36>
					tx_noautoflush = 0;
    922a:	strb	r1, [r5, #0]
    922c:	b.n	925a <usb_serial_write+0x62>
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    922e:	movs	r0, #4
    9230:	bl	97a8 <usb_tx_packet_count>
    9234:	cmp	r0, #7
    9236:	bhi.n	9248 <usb_serial_write+0x50>
					tx_noautoflush = 1;
    9238:	movs	r3, #1
    923a:	strb	r3, [r5, #0]
					tx_packet = usb_malloc();
    923c:	bl	96b0 <usb_malloc>
    9240:	str	r0, [r7, #0]
					if (tx_packet) break;
    9242:	cbnz	r0, 9268 <usb_serial_write+0x70>
					tx_noautoflush = 0;
    9244:	ldr	r3, [pc, #124]	; (92c4 <usb_serial_write+0xcc>)
    9246:	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    9248:	subs.w	r8, r8, #1
    924c:	beq.n	9254 <usb_serial_write+0x5c>
    924e:	ldrb.w	r3, [fp]
    9252:	cbz	r3, 9262 <usb_serial_write+0x6a>
					transmit_previous_timeout = 1;
    9254:	ldr	r3, [pc, #116]	; (92cc <usb_serial_write+0xd4>)
    9256:	movs	r2, #1
    9258:	strb	r2, [r3, #0]
					return -1;
    925a:	mov.w	r0, #4294967295
    925e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				}
				yield();
    9262:	bl	9f7c <yield>
			}
    9266:	b.n	9220 <usb_serial_write+0x28>
		}
		transmit_previous_timeout = 0;
    9268:	ldr	r3, [pc, #96]	; (92cc <usb_serial_write+0xd4>)
    926a:	movs	r1, #0
    926c:	strb	r1, [r3, #0]
		len = CDC_TX_SIZE - tx_packet->index;
    926e:	ldr	r1, [r7, #0]
    9270:	ldrh	r3, [r1, #2]
    9272:	rsb	r0, r3, #64	; 0x40
    9276:	cmp	r0, r6
    9278:	it	cs
    927a:	movcs	r0, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    927c:	add.w	lr, r3, r0
    9280:	add	r3, r1
    9282:	strh.w	lr, [r1, #2]
		size -= len;
    9286:	subs	r6, r6, r0
    9288:	adds	r3, #7
    928a:	add.w	r8, sl, r0
		while (len-- > 0) *dest++ = *src++;
    928e:	cmp	sl, r8
    9290:	beq.n	929c <usb_serial_write+0xa4>
    9292:	ldrb.w	r0, [sl], #1
    9296:	strb.w	r0, [r3, #1]!
    929a:	b.n	928e <usb_serial_write+0x96>
		if (tx_packet->index >= CDC_TX_SIZE) {
    929c:	ldrh	r3, [r1, #2]
    929e:	cmp	r3, #63	; 0x3f
    92a0:	bls.n	92b0 <usb_serial_write+0xb8>
			tx_packet->len = CDC_TX_SIZE;
    92a2:	movs	r3, #64	; 0x40
    92a4:	strh	r3, [r1, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    92a6:	movs	r0, #4
    92a8:	bl	9844 <usb_tx>
			tx_packet = NULL;
    92ac:	movs	r3, #0
    92ae:	str	r3, [r7, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    92b0:	ldr	r3, [pc, #28]	; (92d0 <usb_serial_write+0xd8>)
    92b2:	movs	r2, #5
    92b4:	strb	r2, [r3, #0]
    92b6:	mov	sl, r8
    92b8:	b.n	920e <usb_serial_write+0x16>
	}
	tx_noautoflush = 0;
    92ba:	strb	r6, [r5, #0]
	return ret;
    92bc:	mov	r0, r4
}
    92be:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    92c2:	nop
    92c4:	.word	0x2001a6e9
    92c8:	.word	0x2001a7df
    92cc:	.word	0x2001a6f0
    92d0:	.word	0x2001a6e8
    92d4:	.word	0x2001a6ec

000092d8 <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    92d8:	push	{r0, r1, r2, lr}
    92da:	add	r3, sp, #8
	return usb_serial_write(&c, 1);
    92dc:	movs	r1, #1
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    92de:	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    92e2:	mov	r0, r3
    92e4:	bl	91f8 <usb_serial_write>
}
    92e8:	add	sp, #12
    92ea:	ldr.w	pc, [sp], #4
    92ee:	Address 0x000092ee is out of bounds.


000092f0 <usb_serial_write_buffer_free>:
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    92f0:	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
    92f2:	ldr	r4, [pc, #56]	; (932c <usb_serial_write_buffer_free+0x3c>)
	if (!tx_packet) {
    92f4:	ldr	r5, [pc, #56]	; (9330 <usb_serial_write_buffer_free+0x40>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    92f6:	movs	r3, #1
    92f8:	strb	r3, [r4, #0]
	if (!tx_packet) {
    92fa:	ldr	r3, [r5, #0]
    92fc:	cbnz	r3, 931e <usb_serial_write_buffer_free+0x2e>
		if (!usb_configuration ||
    92fe:	ldr	r3, [pc, #52]	; (9334 <usb_serial_write_buffer_free+0x44>)
    9300:	ldrb	r3, [r3, #0]
    9302:	cbnz	r3, 930a <usb_serial_write_buffer_free+0x1a>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    9304:	movs	r0, #0
    9306:	strb	r0, [r4, #0]
			return 0;
    9308:	pop	{r3, r4, r5, pc}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    930a:	movs	r0, #4
    930c:	bl	97a8 <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    9310:	cmp	r0, #7
    9312:	bhi.n	9304 <usb_serial_write_buffer_free+0x14>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    9314:	bl	96b0 <usb_malloc>
    9318:	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    931a:	cmp	r0, #0
    931c:	beq.n	9304 <usb_serial_write_buffer_free+0x14>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    931e:	ldr	r3, [r5, #0]
    9320:	ldrh	r0, [r3, #2]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    9322:	movs	r3, #0
    9324:	strb	r3, [r4, #0]
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    9326:	rsb	r0, r0, #64	; 0x40
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    932a:	pop	{r3, r4, r5, pc}
    932c:	.word	0x2001a6e9
    9330:	.word	0x2001a6ec
    9334:	.word	0x2001a7df

00009338 <usb_serial_flush_output>:

void usb_serial_flush_output(void)
{
    9338:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!usb_configuration) return;
    933c:	ldr	r3, [pc, #68]	; (9384 <usb_serial_flush_output+0x4c>)
    933e:	ldrb	r3, [r3, #0]
    9340:	cbz	r3, 9380 <usb_serial_flush_output+0x48>
	tx_noautoflush = 1;
	if (tx_packet) {
    9342:	ldr	r7, [pc, #68]	; (9388 <usb_serial_flush_output+0x50>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    9344:	ldr	r3, [pc, #68]	; (938c <usb_serial_flush_output+0x54>)
	if (tx_packet) {
    9346:	ldr	r4, [r7, #0]
    9348:	ldr	r5, [pc, #68]	; (9390 <usb_serial_flush_output+0x58>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    934a:	movs	r6, #1
    934c:	strb	r6, [r3, #0]
    934e:	mov	r8, r3
	if (tx_packet) {
    9350:	cbz	r4, 9366 <usb_serial_flush_output+0x2e>
		usb_cdc_transmit_flush_timer = 0;
    9352:	movs	r6, #0
		tx_packet->len = tx_packet->index;
    9354:	ldrh	r3, [r4, #2]
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    9356:	strb	r6, [r5, #0]
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    9358:	mov	r1, r4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    935a:	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    935c:	movs	r0, #4
    935e:	bl	9844 <usb_tx>
		tx_packet = NULL;
    9362:	str	r6, [r7, #0]
    9364:	b.n	937a <usb_serial_flush_output+0x42>
	} else {
		usb_packet_t *tx = usb_malloc();
    9366:	bl	96b0 <usb_malloc>
		if (tx) {
    936a:	mov	r1, r0
    936c:	cbz	r0, 9378 <usb_serial_flush_output+0x40>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    936e:	movs	r0, #4
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    9370:	strb	r4, [r5, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    9372:	bl	9844 <usb_tx>
    9376:	b.n	937a <usb_serial_flush_output+0x42>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    9378:	strb	r6, [r5, #0]
		}
	}
	tx_noautoflush = 0;
    937a:	movs	r3, #0
    937c:	strb.w	r3, [r8]
    9380:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9384:	.word	0x2001a7df
    9388:	.word	0x2001a6ec
    938c:	.word	0x2001a6e9
    9390:	.word	0x2001a6e8

00009394 <usb_serial_flush_callback>:
}

void usb_serial_flush_callback(void)
{
    9394:	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
    9396:	ldr	r3, [pc, #56]	; (93d0 <usb_serial_flush_callback+0x3c>)
    9398:	ldrb	r3, [r3, #0]
    939a:	and.w	r5, r3, #255	; 0xff
    939e:	cbnz	r3, 93cc <usb_serial_flush_callback+0x38>
	if (tx_packet) {
    93a0:	ldr	r4, [pc, #48]	; (93d4 <usb_serial_flush_callback+0x40>)
    93a2:	ldr	r1, [r4, #0]
    93a4:	cbz	r1, 93b4 <usb_serial_flush_callback+0x20>
		tx_packet->len = tx_packet->index;
    93a6:	ldrh	r3, [r1, #2]
    93a8:	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    93aa:	movs	r0, #4
    93ac:	bl	9844 <usb_tx>
		tx_packet = NULL;
    93b0:	str	r5, [r4, #0]
    93b2:	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
    93b4:	bl	96b0 <usb_malloc>
		if (tx) {
    93b8:	mov	r1, r0
    93ba:	cbz	r0, 93c6 <usb_serial_flush_callback+0x32>
			usb_tx(CDC_TX_ENDPOINT, tx);
    93bc:	movs	r0, #4
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    93be:	ldmia.w	sp!, {r3, r4, r5, lr}
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
    93c2:	b.w	9844 <usb_tx>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    93c6:	ldr	r3, [pc, #16]	; (93d8 <usb_serial_flush_callback+0x44>)
    93c8:	movs	r2, #1
    93ca:	strb	r2, [r3, #0]
    93cc:	pop	{r3, r4, r5, pc}
    93ce:	nop
    93d0:	.word	0x2001a6e9
    93d4:	.word	0x2001a6ec
    93d8:	.word	0x2001a6e8

000093dc <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
    93dc:	push	{r3, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    93de:	ldr	r5, [pc, #44]	; (940c <fault_isr+0x30>)
    93e0:	mov	r4, r5
    93e2:	ldr	r3, [r5, #0]
    93e4:	lsls	r0, r3, #13
    93e6:	bpl.n	93ec <fault_isr+0x10>
    93e8:	bl	98c4 <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    93ec:	ldr	r3, [r4, #0]
    93ee:	lsls	r1, r3, #21
    93f0:	bpl.n	93f6 <fault_isr+0x1a>
    93f2:	bl	9410 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    93f6:	ldr	r3, [r4, #0]
    93f8:	lsls	r2, r3, #20
    93fa:	bpl.n	9400 <fault_isr+0x24>
    93fc:	bl	9410 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    9400:	ldr	r3, [r4, #0]
    9402:	lsls	r3, r3, #19
    9404:	bpl.n	93e2 <fault_isr+0x6>
    9406:	bl	9410 <unused_isr>
    940a:	b.n	93e2 <fault_isr+0x6>
    940c:	.word	0x40048034

00009410 <unused_isr>:
	}
}

void unused_isr(void)
{
    9410:	push	{r3, lr}
	fault_isr();
    9412:	bl	93dc <fault_isr>
    9416:	Address 0x00009416 is out of bounds.


00009418 <startup_early_hook>:
extern void rtc_set(unsigned long t);


static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    9418:	ldr	r3, [pc, #4]	; (9420 <startup_early_hook+0x8>)
    941a:	movs	r2, #16
    941c:	strh	r2, [r3, #0]
    941e:	bx	lr
    9420:	.word	0x40052000

00009424 <startup_late_hook>:
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
#endif
}
static void startup_default_late_hook(void) {}
    9424:	bx	lr
    9426:	Address 0x00009426 is out of bounds.


00009428 <_sbrk>:

void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
    9428:	ldr	r1, [pc, #36]	; (9450 <_sbrk+0x28>)

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
    942a:	push	{r3, lr}
	char *prev, *stack;

	prev = __brkval;
    942c:	ldr	r3, [r1, #0]
	if (incr != 0) {
    942e:	cbz	r0, 944c <_sbrk+0x24>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    9430:	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
    9432:	add	r0, r3
    9434:	sub.w	r2, r2, #8192	; 0x2000
    9438:	cmp	r0, r2
    943a:	bcc.n	944a <_sbrk+0x22>
			errno = ENOMEM;
    943c:	bl	b294 <__errno>
    9440:	movs	r3, #12
    9442:	str	r3, [r0, #0]
			return (void *)-1;
    9444:	mov.w	r0, #4294967295
    9448:	pop	{r3, pc}
		}
		__brkval = prev + incr;
    944a:	str	r0, [r1, #0]
	}
	return prev;
    944c:	mov	r0, r3
}
    944e:	pop	{r3, pc}
    9450:	.word	0x1fff133c

00009454 <__cxa_pure_virtual>:
	while (1);
}

__attribute__((weak)) 
void __cxa_pure_virtual()
{
    9454:	b.n	9454 <__cxa_pure_virtual>
    9456:	Address 0x00009456 is out of bounds.


00009458 <attachInterruptVector>:
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    9458:	adds	r0, #16
    945a:	ldr	r3, [pc, #8]	; (9464 <attachInterruptVector+0xc>)
    945c:	str.w	r1, [r3, r0, lsl #2]
    9460:	bx	lr
    9462:	nop
    9464:	.word	0x1fff0a00

00009468 <rtc_get>:

#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)

unsigned long rtc_get(void)
{
	return RTC_TSR;
    9468:	ldr	r3, [pc, #4]	; (9470 <rtc_get+0x8>)
    946a:	ldr	r0, [r3, #0]
}
    946c:	bx	lr
    946e:	nop
    9470:	.word	0x4003d000

00009474 <rtc_set>:

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    9474:	ldr	r3, [pc, #16]	; (9488 <rtc_set+0x14>)
	RTC_TPR = 0;
    9476:	ldr	r1, [pc, #20]	; (948c <rtc_set+0x18>)
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    9478:	movs	r2, #0
    947a:	str	r2, [r3, #0]
	RTC_TPR = 0;
    947c:	str	r2, [r1, #0]
	RTC_TSR = t;
    947e:	ldr	r2, [pc, #16]	; (9490 <rtc_set+0x1c>)
    9480:	str	r0, [r2, #0]
	RTC_SR = RTC_SR_TCE;
    9482:	movs	r2, #16
    9484:	str	r2, [r3, #0]
    9486:	bx	lr
    9488:	.word	0x4003d014
    948c:	.word	0x4003d004
    9490:	.word	0x4003d000

00009494 <startup_middle_hook>:
}
#endif

extern void usb_init(void);

static void startup_default_middle_hook(void) {}
    9494:	bx	lr
    9496:	Address 0x00009496 is out of bounds.


00009498 <digitalWrite>:

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    9498:	cmp	r0, #63	; 0x3f


// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
    949a:	push	{r4, lr}
	if (pin >= CORE_NUM_DIGITAL) return;
    949c:	bhi.n	94d0 <digitalWrite+0x38>
#ifdef KINETISK
	if (*portModeRegister(pin)) {
    949e:	ldr	r3, [pc, #52]	; (94d4 <digitalWrite+0x3c>)
    94a0:	ldr.w	r2, [r3, r0, lsl #3]
    94a4:	ldrb.w	r4, [r2, #640]	; 0x280
    94a8:	cbz	r4, 94ba <digitalWrite+0x22>
    94aa:	movs	r3, #1
		if (val) {
    94ac:	cbz	r1, 94b4 <digitalWrite+0x1c>
			*portSetRegister(pin) = 1;
    94ae:	strb.w	r3, [r2, #128]	; 0x80
    94b2:	pop	{r4, pc}
		} else {
			*portClearRegister(pin) = 1;
    94b4:	strb.w	r3, [r2, #256]	; 0x100
    94b8:	pop	{r4, pc}
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
    94ba:	add.w	r3, r3, r0, lsl #3
    94be:	ldr	r3, [r3, #4]
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    94c0:	ldr	r2, [r3, #0]
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
    94c2:	cbz	r1, 94ca <digitalWrite+0x32>
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    94c4:	orr.w	r2, r2, #3
    94c8:	b.n	94ce <digitalWrite+0x36>
			//*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else {
			// TODO use bitband for atomic read-mod-write
			*config &= ~(PORT_PCR_PE);
    94ca:	bic.w	r2, r2, #2
    94ce:	str	r2, [r3, #0]
    94d0:	pop	{r4, pc}
    94d2:	nop
    94d4:	.word	0x00012e88

000094d8 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    94d8:	cmp	r0, #63	; 0x3f
}



void pinMode(uint8_t pin, uint8_t mode)
{
    94da:	push	{r4, lr}
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    94dc:	bhi.n	9536 <pinMode+0x5e>
	config = portConfigRegister(pin);
    94de:	ldr	r2, [pc, #88]	; (9538 <pinMode+0x60>)
    94e0:	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    94e4:	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    94e6:	ldr	r3, [r3, #4]
    94e8:	mov	r4, r2

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    94ea:	beq.n	94f0 <pinMode+0x18>
    94ec:	cmp	r1, #4
    94ee:	bne.n	9510 <pinMode+0x38>
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    94f0:	ldr.w	r2, [r4, r0, lsl #3]
    94f4:	movs	r0, #1
    94f6:	strb.w	r0, [r2, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    94fa:	mov.w	r2, #324	; 0x144
    94fe:	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    9500:	ldr	r2, [r3, #0]
		*portModeRegister(pin) = 1;
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
		if (mode == OUTPUT_OPENDRAIN) {
    9502:	cmp	r1, #4
		    *config |= PORT_PCR_ODE;
    9504:	ite	eq
    9506:	orreq.w	r2, r2, #32
		} else {
		    *config &= ~PORT_PCR_ODE;
    950a:	bicne.w	r2, r2, #32
    950e:	b.n	9534 <pinMode+0x5c>
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    9510:	ldr.w	r0, [r2, r0, lsl #3]
    9514:	movs	r2, #0
    9516:	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    951a:	cbnz	r1, 9522 <pinMode+0x4a>
			*config = PORT_PCR_MUX(1);
    951c:	mov.w	r2, #256	; 0x100
    9520:	b.n	9534 <pinMode+0x5c>
		} else if (mode == INPUT_PULLUP) {
    9522:	cmp	r1, #2
    9524:	bne.n	952c <pinMode+0x54>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    9526:	movw	r2, #259	; 0x103
    952a:	b.n	9534 <pinMode+0x5c>
		} else if (mode == INPUT_PULLDOWN) {
    952c:	cmp	r1, #3
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    952e:	it	eq
    9530:	moveq.w	r2, #258	; 0x102
		} else { // INPUT_DISABLE
			*config = 0;
    9534:	str	r2, [r3, #0]
    9536:	pop	{r4, pc}
    9538:	.word	0x00012e88

0000953c <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    953c:	cpsid	i
	current = SYST_CVR;
    953e:	ldr	r3, [pc, #44]	; (956c <micros+0x30>)
	count = systick_millis_count;
    9540:	ldr	r2, [pc, #44]	; (9570 <micros+0x34>)
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    9542:	ldr	r1, [pc, #48]	; (9574 <micros+0x38>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    9544:	ldr	r3, [r3, #0]
	count = systick_millis_count;
    9546:	ldr	r2, [r2, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    9548:	ldr	r1, [r1, #0]
	__enable_irq();
    954a:	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    954c:	lsls	r1, r1, #5
    954e:	bpl.n	9556 <micros+0x1a>
    9550:	cmp	r3, #50	; 0x32
    9552:	it	hi
    9554:	addhi	r2, #1
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    9556:	rsb	r3, r3, #95744	; 0x17600
    955a:	movs	r0, #96	; 0x60
    955c:	adds	r3, #255	; 0xff
    955e:	udiv	r3, r3, r0
}
    9562:	mov.w	r0, #1000	; 0x3e8
    9566:	mla	r0, r0, r2, r3
    956a:	bx	lr
    956c:	.word	0xe000e018
    9570:	.word	0x2001a6fc
    9574:	.word	0xe000ed04

00009578 <delay>:

void delay(uint32_t ms)
{
    9578:	push	{r3, r4, r5, lr}
    957a:	mov	r4, r0
	uint32_t start = micros();
    957c:	bl	953c <micros>
    9580:	mov	r5, r0

	if (ms > 0) {
    9582:	cbnz	r4, 958e <delay+0x16>
    9584:	pop	{r3, r4, r5, pc}
		while (1) {
			while ((micros() - start) >= 1000) {
				ms--;
				if (ms == 0) return;
    9586:	subs	r4, #1
    9588:	beq.n	95a0 <delay+0x28>
				start += 1000;
    958a:	add.w	r5, r5, #1000	; 0x3e8
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    958e:	bl	953c <micros>
    9592:	subs	r0, r0, r5
    9594:	cmp.w	r0, #1000	; 0x3e8
    9598:	bcs.n	9586 <delay+0xe>
				ms--;
				if (ms == 0) return;
				start += 1000;
			}
			yield();
    959a:	bl	9f7c <yield>
		}
    959e:	b.n	958e <delay+0x16>
    95a0:	pop	{r3, r4, r5, pc}
    95a2:	Address 0x000095a2 is out of bounds.


000095a4 <_init_Teensyduino_internal_>:
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    95a4:	ldr	r3, [pc, #224]	; (9688 <_init_Teensyduino_internal_+0xe4>)
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    95a6:	ldr	r1, [pc, #228]	; (968c <_init_Teensyduino_internal_+0xe8>)
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    95a8:	mov.w	r2, #134217728	; 0x8000000
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    95ac:	push	{r4, r5, r6, lr}
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    95ae:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    95b0:	mov.w	r2, #268435456	; 0x10000000
    95b4:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    95b6:	mov.w	r2, #536870912	; 0x20000000
    95ba:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    95bc:	mov.w	r2, #1073741824	; 0x40000000
    95c0:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    95c2:	mov.w	r2, #2147483648	; 0x80000000
    95c6:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    95c8:	ldr	r3, [pc, #196]	; (9690 <_init_Teensyduino_internal_+0xec>)
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    95ca:	ldr	r5, [pc, #200]	; (9694 <_init_Teensyduino_internal_+0xf0>)
	FTM3_C1SC = 0x28;
    95cc:	ldr	r4, [pc, #200]	; (9698 <_init_Teensyduino_internal_+0xf4>)
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    95ce:	ldr	r6, [pc, #204]	; (969c <_init_Teensyduino_internal_+0xf8>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    95d0:	movs	r2, #0
	FTM0_MOD = DEFAULT_FTM_MOD;
    95d2:	movw	r0, #49151	; 0xbfff
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    95d6:	str	r2, [r3, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
    95d8:	str	r0, [r3, #4]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    95da:	movs	r3, #40	; 0x28
    95dc:	str	r3, [r1, #0]
	FTM0_C1SC = 0x28;
    95de:	str	r3, [r1, #8]
	FTM0_C2SC = 0x28;
    95e0:	str	r3, [r1, #16]
	FTM0_C3SC = 0x28;
    95e2:	str	r3, [r1, #24]
	FTM0_C4SC = 0x28;
    95e4:	str	r3, [r1, #32]
	FTM0_C5SC = 0x28;
    95e6:	str	r3, [r1, #40]	; 0x28
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    95e8:	str	r3, [r1, #48]	; 0x30
	FTM0_C7SC = 0x28;
    95ea:	str	r3, [r1, #56]	; 0x38
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
    95ec:	adds	r1, #16
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    95ee:	add.w	r1, r1, #528384	; 0x81000
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    95f2:	str	r3, [r5, #0]
	FTM3_C1SC = 0x28;
    95f4:	str	r3, [r4, #0]
	FTM3_C2SC = 0x28;
    95f6:	str	r3, [r1, #0]
	FTM3_C3SC = 0x28;
    95f8:	str	r3, [r1, #8]
	FTM3_C4SC = 0x28;
    95fa:	str	r3, [r1, #16]
	FTM3_C5SC = 0x28;
    95fc:	str	r3, [r1, #24]
	FTM3_C6SC = 0x28;
    95fe:	str	r3, [r1, #32]
	FTM3_C7SC = 0x28;
    9600:	str	r3, [r1, #40]	; 0x28
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9602:	movs	r1, #9
    9604:	str	r1, [r6, #0]
	FTM1_CNT = 0;
    9606:	add.w	r6, r6, #4096	; 0x1000
    960a:	adds	r6, #4
    960c:	str	r2, [r6, #0]
	FTM1_MOD = DEFAULT_FTM_MOD;
    960e:	str	r0, [r6, #4]
	FTM1_C0SC = 0x28;
    9610:	str	r3, [r6, #8]
	FTM1_C1SC = 0x28;
    9612:	str	r3, [r6, #16]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9614:	str.w	r1, [r6, #-4]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    9618:	add.w	r6, r6, #520192	; 0x7f000
    961c:	str	r2, [r6, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    961e:	str	r0, [r6, #4]
	FTM2_C0SC = 0x28;
    9620:	str	r3, [r6, #8]
	FTM2_C1SC = 0x28;
    9622:	str	r3, [r6, #16]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9624:	str.w	r1, [r6, #-4]
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
    9628:	add.w	r6, r6, #4096	; 0x1000
    962c:	str	r2, [r6, #0]
	FTM3_MOD = DEFAULT_FTM_MOD;
    962e:	str	r0, [r6, #4]
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9630:	ldr	r0, [pc, #108]	; (96a0 <_init_Teensyduino_internal_+0xfc>)
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
	FTM3_C0SC = 0x28;
    9632:	str	r3, [r5, #0]
	FTM3_C1SC = 0x28;
    9634:	str	r3, [r4, #0]
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9636:	str	r1, [r0, #0]
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    9638:	sub.w	r0, r0, #460800	; 0x70800
    963c:	subw	r0, r0, #2004	; 0x7d4
    9640:	ldr	r1, [r0, #0]
    9642:	orr.w	r1, r1, #512	; 0x200
    9646:	str	r1, [r0, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    9648:	ldr.w	r1, [r0, #-40]
    964c:	orr.w	r1, r1, #33554432	; 0x2000000
    9650:	str.w	r1, [r0, #-40]
	TPM1_CNT = 0;
    9654:	ldr	r1, [pc, #76]	; (96a4 <_init_Teensyduino_internal_+0x100>)
    9656:	str	r2, [r1, #0]
	TPM1_MOD = 32767;
    9658:	ldr	r2, [pc, #76]	; (96a8 <_init_Teensyduino_internal_+0x104>)
    965a:	movw	r1, #32767	; 0x7fff
    965e:	str	r1, [r2, #0]
	TPM1_C0SC = 0x28;
    9660:	str	r3, [r2, #4]
	TPM1_C1SC = 0x28;
    9662:	str	r3, [r2, #12]
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    9664:	ldr	r3, [pc, #68]	; (96ac <_init_Teensyduino_internal_+0x108>)
    9666:	movs	r2, #8
    9668:	str	r2, [r3, #0]
#endif
	analog_init();
    966a:	bl	a3e4 <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	startup_middle_hook();
    966e:	bl	9494 <startup_middle_hook>
	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    9672:	movs	r0, #20
    9674:	bl	9578 <delay>
	usb_init();
    9678:	bl	9ee8 <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    967c:	mov.w	r0, #280	; 0x118
}
    9680:	ldmia.w	sp!, {r4, r5, r6, lr}
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	startup_middle_hook();
	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    9684:	b.w	9578 <delay>
    9688:	.word	0xe000e104
    968c:	.word	0x4003800c
    9690:	.word	0x40038004
    9694:	.word	0x400b900c
    9698:	.word	0x400b9014
    969c:	.word	0x40038000
    96a0:	.word	0x400b9000
    96a4:	.word	0x400c9004
    96a8:	.word	0x400c9008
    96ac:	.word	0x400c9000

000096b0 <usb_malloc>:
// http://www.archivum.info/gnu.gcc.help/2006-08/00148/Re-GCC-Inline-Assembly.html
// http://gcc.gnu.org/ml/gcc/2012-06/msg00015.html
// __builtin_clz()

usb_packet_t * usb_malloc(void)
{
    96b0:	push	{r4, lr}
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    96b2:	cpsid	i
	avail = usb_buffer_available;
    96b4:	ldr	r0, [pc, #44]	; (96e4 <usb_malloc+0x34>)
    96b6:	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    96b8:	clz	r1, r2
	if (n >= NUM_USB_BUFFERS) {
    96bc:	cmp	r1, #11
    96be:	ble.n	96c6 <usb_malloc+0x16>
		__enable_irq();
    96c0:	cpsie	i
		return NULL;
    96c2:	movs	r0, #0
    96c4:	pop	{r4, pc}
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    96c6:	mov.w	r3, #2147483648	; 0x80000000
    96ca:	lsrs	r3, r1
    96cc:	bic.w	r2, r2, r3
    96d0:	str	r2, [r0, #0]
	__enable_irq();
    96d2:	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    96d4:	ldr	r4, [pc, #16]	; (96e8 <usb_malloc+0x38>)
    96d6:	movs	r3, #72	; 0x48
    96d8:	muls	r3, r1
    96da:	adds	r0, r4, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    96dc:	movs	r2, #0
    96de:	str	r2, [r4, r3]
	*(uint32_t *)(p + 4) = 0;
    96e0:	str	r2, [r0, #4]
	return (usb_packet_t *)p;
}
    96e2:	pop	{r4, pc}
    96e4:	.word	0x1fff1340
    96e8:	.word	0x1fff0bd0

000096ec <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    96ec:	ldr	r3, [pc, #48]	; (9720 <usb_free+0x34>)
    96ee:	movs	r2, #72	; 0x48
    96f0:	subs	r3, r0, r3
    96f2:	udiv	r3, r3, r2
	if (n >= NUM_USB_BUFFERS) return;
    96f6:	cmp	r3, #11
    96f8:	bhi.n	971e <usb_free+0x32>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    96fa:	ldr	r2, [pc, #40]	; (9724 <usb_free+0x38>)
    96fc:	ldrb	r2, [r2, #0]
    96fe:	cbz	r2, 970a <usb_free+0x1e>
    9700:	ldr	r2, [pc, #36]	; (9728 <usb_free+0x3c>)
    9702:	ldrb	r2, [r2, #0]
    9704:	cbz	r2, 970a <usb_free+0x1e>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    9706:	b.w	97cc <usb_rx_memory>
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    970a:	cpsid	i
	usb_buffer_available |= mask;
    970c:	ldr	r1, [pc, #28]	; (972c <usb_free+0x40>)
    970e:	mov.w	r2, #2147483648	; 0x80000000
    9712:	lsr.w	r3, r2, r3
    9716:	ldr	r2, [r1, #0]
    9718:	orrs	r2, r3
    971a:	str	r2, [r1, #0]
	__enable_irq();
    971c:	cpsie	i
    971e:	bx	lr
    9720:	.word	0x1fff0bd0
    9724:	.word	0x2001a7d6
    9728:	.word	0x2001a7df
    972c:	.word	0x1fff1340

00009730 <endpoint0_transmit>:
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
}


static void endpoint0_transmit(const void *data, uint32_t len)
{
    9730:	push	{r4, r5, r6, r7, lr}
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    9732:	ldr	r4, [pc, #48]	; (9764 <endpoint0_transmit+0x34>)
    9734:	ldr	r6, [pc, #48]	; (9768 <endpoint0_transmit+0x38>)
    9736:	ldrb	r3, [r4, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9738:	ldr	r5, [pc, #48]	; (976c <endpoint0_transmit+0x3c>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    973a:	orr.w	r7, r3, #2
    973e:	add.w	r2, r6, r7, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    9742:	eor.w	r3, r3, #1
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    9746:	str	r0, [r2, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9748:	ldrb	r2, [r5, #0]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    974a:	strb	r3, [r4, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    974c:	cmp	r2, #0
    974e:	ite	ne
    9750:	movne	r0, #200	; 0xc8
    9752:	moveq	r0, #136	; 0x88
	ep0_tx_data_toggle ^= 1;
    9754:	eor.w	r2, r2, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9758:	orr.w	r1, r0, r1, lsl #16
	ep0_tx_data_toggle ^= 1;
    975c:	strb	r2, [r5, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    975e:	str.w	r1, [r6, r7, lsl #3]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    9762:	pop	{r4, r5, r6, r7, pc}
    9764:	.word	0x2001a768
    9768:	.word	0x1fff0000
    976c:	.word	0x2001a7e0

00009770 <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    9770:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    9772:	cmp	r3, #3




usb_packet_t *usb_rx(uint32_t endpoint)
{
    9774:	push	{r4, lr}
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    9776:	bhi.n	979a <usb_rx+0x2a>
	__disable_irq();
    9778:	cpsid	i
	ret = rx_first[endpoint];
    977a:	ldr	r2, [pc, #36]	; (97a0 <usb_rx+0x30>)
    977c:	ldr.w	r0, [r2, r3, lsl #2]
	if (ret) {
    9780:	cbz	r0, 9796 <usb_rx+0x26>
		rx_first[endpoint] = ret->next;
    9782:	ldr	r1, [r0, #4]
    9784:	str.w	r1, [r2, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    9788:	ldr	r1, [pc, #24]	; (97a4 <usb_rx+0x34>)
    978a:	ldrh	r4, [r0, #0]
    978c:	ldrh.w	r2, [r1, r3, lsl #1]
    9790:	subs	r2, r2, r4
    9792:	strh.w	r2, [r1, r3, lsl #1]
	}
	__enable_irq();
    9796:	cpsie	i
	//serial_print("rx, epidx=");
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
    9798:	pop	{r4, pc}

usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    979a:	movs	r0, #0
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    979c:	pop	{r4, pc}
    979e:	nop
    97a0:	.word	0x2001a758
    97a4:	.word	0x2001a854

000097a8 <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    97a8:	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    97aa:	cmp	r0, #3
    97ac:	bhi.n	97c4 <usb_tx_packet_count+0x1c>
	__disable_irq();
    97ae:	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    97b0:	ldr	r3, [pc, #20]	; (97c8 <usb_tx_packet_count+0x20>)
    97b2:	ldr.w	r3, [r3, r0, lsl #2]
// https://forum.pjrc.com/threads/58663?p=223513&viewfull=1#post223513
//
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;
    97b6:	movs	r0, #0

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    97b8:	cbz	r3, 97c0 <usb_tx_packet_count+0x18>
    97ba:	adds	r0, #1
    97bc:	ldr	r3, [r3, #4]
    97be:	b.n	97b8 <usb_tx_packet_count+0x10>
	__enable_irq();
    97c0:	cpsie	i
	return count;
    97c2:	bx	lr
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
    97c4:	movs	r0, #0
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
	__enable_irq();
	return count;
}
    97c6:	bx	lr
    97c8:	.word	0x2001a7ac

000097cc <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    97cc:	push	{r4, r5, r6}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    97ce:	cpsid	i
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    97d0:	ldr	r5, [pc, #92]	; (9830 <usb_rx_memory+0x64>)
			if (table[index(i, RX, EVEN)].desc == 0) {
    97d2:	ldr	r4, [pc, #96]	; (9834 <usb_rx_memory+0x68>)
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    97d4:	movs	r3, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    97d6:	adds	r2, r3, r5
    97d8:	ldrb.w	r2, [r2, #-1]
    97dc:	lsls	r2, r2, #28
    97de:	bpl.n	981c <usb_rx_memory+0x50>
			if (table[index(i, RX, EVEN)].desc == 0) {
    97e0:	lsls	r2, r3, #2
    97e2:	ldr	r1, [pc, #80]	; (9834 <usb_rx_memory+0x68>)
    97e4:	ldr.w	r6, [r4, r2, lsl #3]
    97e8:	cbnz	r6, 97f6 <usb_rx_memory+0x2a>
				table[index(i, RX, EVEN)].addr = packet->buf;
    97ea:	add.w	r3, r1, r3, lsl #5
    97ee:	adds	r0, #8
    97f0:	str	r0, [r3, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    97f2:	ldr	r3, [pc, #68]	; (9838 <usb_rx_memory+0x6c>)
    97f4:	b.n	980a <usb_rx_memory+0x3e>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    97f6:	orr.w	r2, r2, #1
    97fa:	ldr.w	r6, [r4, r2, lsl #3]
    97fe:	cbnz	r6, 981c <usb_rx_memory+0x50>
				table[index(i, RX, ODD)].addr = packet->buf;
    9800:	add.w	r3, r1, r2, lsl #3
    9804:	adds	r0, #8
    9806:	str	r0, [r3, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    9808:	ldr	r3, [pc, #48]	; (983c <usb_rx_memory+0x70>)
    980a:	str.w	r3, [r1, r2, lsl #3]
				usb_rx_memory_needed--;
    980e:	ldr	r2, [pc, #48]	; (9840 <usb_rx_memory+0x74>)
    9810:	ldrb	r3, [r2, #0]
    9812:	subs	r3, #1
    9814:	strb	r3, [r2, #0]
				__enable_irq();
    9816:	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
    9818:	pop	{r4, r5, r6}
    981a:	bx	lr
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    981c:	adds	r3, #1
    981e:	cmp	r3, #5
    9820:	bne.n	97d6 <usb_rx_memory+0xa>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    9822:	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    9824:	ldr	r3, [pc, #24]	; (9840 <usb_rx_memory+0x74>)
    9826:	movs	r2, #0
    9828:	strb	r2, [r3, #0]
	usb_free(packet);
	return;
}
    982a:	pop	{r4, r5, r6}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
    982c:	b.w	96ec <usb_free>
    9830:	.word	0x000130b2
    9834:	.word	0x1fff0000
    9838:	.word	0x00400088
    983c:	.word	0x004000c8
    9840:	.word	0x2001a7d6

00009844 <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    9844:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    9846:	cmp	r3, #3

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    9848:	push	{r4, lr}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
    984a:	bhi.n	98b2 <usb_tx+0x6e>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    984c:	ldr	r2, [pc, #100]	; (98b4 <usb_tx+0x70>)
    984e:	lsls	r0, r0, #5
    9850:	orr.w	r0, r0, #16
    9854:	add	r0, r2
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    9856:	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    9858:	ldr	r2, [pc, #92]	; (98b8 <usb_tx+0x74>)
    985a:	ldrb	r4, [r2, r3]
    985c:	cmp	r4, #3
    985e:	bhi.n	9878 <usb_tx+0x34>
    9860:	tbb	[pc, r4]
    9864:	.word	0x07020418
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
		next = TX_STATE_EVEN_FREE;
		break;
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    9868:	movs	r4, #5
    986a:	b.n	9896 <usb_tx+0x52>
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    986c:	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    986e:	movs	r4, #2
		break;
    9870:	b.n	9896 <usb_tx+0x52>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    9872:	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    9874:	movs	r4, #4
		break;
    9876:	b.n	9896 <usb_tx+0x52>
	  default:
		if (tx_first[endpoint] == NULL) {
    9878:	ldr	r0, [pc, #64]	; (98bc <usb_tx+0x78>)
    987a:	ldr	r2, [pc, #68]	; (98c0 <usb_tx+0x7c>)
    987c:	ldr.w	r4, [r0, r3, lsl #2]
    9880:	cbnz	r4, 9888 <usb_tx+0x44>
			tx_first[endpoint] = packet;
    9882:	str.w	r1, [r0, r3, lsl #2]
    9886:	b.n	988e <usb_tx+0x4a>
		} else {
			tx_last[endpoint]->next = packet;
    9888:	ldr.w	r0, [r2, r3, lsl #2]
    988c:	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    988e:	str.w	r1, [r2, r3, lsl #2]
    9892:	b.n	98b0 <usb_tx+0x6c>
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    9894:	movs	r4, #3
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    9896:	strb	r4, [r2, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9898:	tst.w	r0, #8
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    989c:	add.w	r3, r1, #8
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    98a0:	ldrh	r2, [r1, #0]
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    98a2:	str	r3, [r0, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    98a4:	ite	ne
    98a6:	movne	r3, #200	; 0xc8
    98a8:	moveq	r3, #136	; 0x88
    98aa:	orr.w	r3, r3, r2, lsl #16
    98ae:	str	r3, [r0, #0]
	__enable_irq();
    98b0:	cpsie	i
    98b2:	pop	{r4, pc}
    98b4:	.word	0x1fff0000
    98b8:	.word	0x2001a714
    98bc:	.word	0x2001a7ac
    98c0:	.word	0x2001a7bc

000098c4 <usb_isr>:
}



void usb_isr(void)
{
    98c4:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    98c8:	ldr.w	r8, [pc, #680]	; 9b74 <usb_isr+0x2b0>
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    98cc:	ldr	r3, [pc, #676]	; (9b74 <usb_isr+0x2b0>)
    98ce:	ldrb	r4, [r3, #0]
    98d0:	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    98d2:	tst.w	r4, #4
    98d6:	mov	r5, r3
    98d8:	beq.n	9910 <usb_isr+0x4c>
		if (usb_configuration) {
    98da:	ldr	r3, [pc, #668]	; (9b78 <usb_isr+0x2b4>)
    98dc:	ldrb	r3, [r3, #0]
    98de:	cbz	r3, 990a <usb_isr+0x46>
			t = usb_reboot_timer;
    98e0:	ldr	r2, [pc, #664]	; (9b7c <usb_isr+0x2b8>)
    98e2:	ldrb	r1, [r2, #0]
			if (t) {
    98e4:	and.w	r3, r1, #255	; 0xff
    98e8:	cbz	r1, 98f4 <usb_isr+0x30>
				usb_reboot_timer = --t;
    98ea:	subs	r3, #1
    98ec:	uxtb	r3, r3
    98ee:	strb	r3, [r2, #0]
				if (!t) _reboot_Teensyduino_();
    98f0:	cbnz	r3, 98f4 <usb_isr+0x30>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    98f2:	bkpt	0x0000
			if (t) {
				usb_reboot_timer = --t;
				if (!t) _reboot_Teensyduino_();
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    98f4:	ldr	r2, [pc, #648]	; (9b80 <usb_isr+0x2bc>)
    98f6:	ldrb	r1, [r2, #0]
			if (t) {
    98f8:	and.w	r3, r1, #255	; 0xff
    98fc:	cbz	r1, 990a <usb_isr+0x46>
				usb_cdc_transmit_flush_timer = --t;
    98fe:	subs	r3, #1
    9900:	uxtb	r3, r3
    9902:	strb	r3, [r2, #0]
				if (t == 0) usb_serial_flush_callback();
    9904:	cbnz	r3, 990a <usb_isr+0x46>
    9906:	bl	9394 <usb_serial_flush_callback>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    990a:	movs	r3, #4
    990c:	strb.w	r3, [r8]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    9910:	and.w	r3, r4, #8
    9914:	and.w	r2, r3, #255	; 0xff
    9918:	cmp	r3, #0
    991a:	beq.w	9e04 <usb_isr+0x540>
		uint8_t endpoint;
		stat = USB0_STAT;
    991e:	ldr	r3, [pc, #612]	; (9b84 <usb_isr+0x2c0>)
    9920:	ldr	r4, [pc, #612]	; (9b88 <usb_isr+0x2c4>)
    9922:	ldrb	r3, [r3, #0]
    9924:	uxtb	r3, r3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    9926:	lsrs	r7, r3, #4
    9928:	mov.w	r6, r3, lsr #2
    992c:	bne.w	9d0c <usb_isr+0x448>
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
    9930:	ldr.w	r3, [r4, r6, lsl #3]
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    9934:	add.w	r2, r4, r6, lsl #3
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    9938:	ubfx	r3, r3, #2, #4
    993c:	subs	r3, #1
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    993e:	ldr	r2, [r2, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    9940:	cmp	r3, #12
    9942:	bhi.w	9d04 <usb_isr+0x440>
    9946:	tbh	[pc, r3, lsl #1]
    994a:	.short	0x019e
    994c:	.word	0x01dd019e
    9950:	.word	0x01dd01dd
    9954:	.word	0x01dd01dd
    9958:	.word	0x01bb01dd
    995c:	.word	0x01dd01dd
    9960:	.word	0x000d01dd
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    9964:	ldr	r5, [pc, #548]	; (9b8c <usb_isr+0x2c8>)
		setup.word2 = *(uint32_t *)(buf + 4);
    9966:	ldr	r3, [r2, #4]
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    9968:	ldr	r1, [r2, #0]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    996a:	ldr	r0, [pc, #548]	; (9b90 <usb_isr+0x2cc>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    996c:	str	r3, [r5, #4]

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    996e:	ldr	r3, [pc, #548]	; (9b94 <usb_isr+0x2d0>)
    9970:	str.w	r3, [r4, r6, lsl #3]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    9974:	movs	r3, #1
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    9976:	str	r1, [r5, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    9978:	ldr.w	sl, [pc, #584]	; 9bc4 <usb_isr+0x300>
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    997c:	strb	r3, [r0, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    997e:	uxth	r1, r1
    9980:	movw	r0, #1665	; 0x681
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    9984:	movs	r2, #0
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    9986:	cmp	r1, r0
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    9988:	str	r2, [r4, #16]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    998a:	str.w	r2, [sl]
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
    998e:	str	r2, [r4, #24]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    9990:	bhi.n	99c2 <usb_isr+0xfe>
    9992:	cmp.w	r1, #1664	; 0x680
    9996:	bcs.w	9bea <usb_isr+0x326>
    999a:	cmp.w	r1, #258	; 0x102
    999e:	beq.w	9b54 <usb_isr+0x290>
    99a2:	bhi.n	99b2 <usb_isr+0xee>
    99a4:	cmp	r1, #128	; 0x80
    99a6:	beq.w	9b2e <usb_isr+0x26a>
    99aa:	cmp	r1, #130	; 0x82
    99ac:	beq.w	9b36 <usb_isr+0x272>
    99b0:	b.n	9c24 <usb_isr+0x360>
    99b2:	movw	r3, #770	; 0x302
    99b6:	cmp	r1, r3
    99b8:	beq.w	9bcc <usb_isr+0x308>
    99bc:	cmp.w	r1, #1280	; 0x500
    99c0:	b.n	99fa <usb_isr+0x136>
    99c2:	movw	r0, #8225	; 0x2021
    99c6:	cmp	r1, r0
    99c8:	beq.w	9c80 <usb_isr+0x3bc>
    99cc:	bhi.n	99ea <usb_isr+0x126>
    99ce:	cmp.w	r1, #2176	; 0x880
    99d2:	beq.w	9b24 <usb_isr+0x260>
    99d6:	cmp.w	r1, #2304	; 0x900
    99da:	bne.w	9c24 <usb_isr+0x360>
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    99de:	ldr	r3, [pc, #408]	; (9b78 <usb_isr+0x2b4>)
    99e0:	ldrb	r2, [r5, #2]
    99e2:	strb	r2, [r3, #0]
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    99e4:	movs	r6, #4
			if (table[i].desc & BDT_OWN) {
    99e6:	ldr	r7, [pc, #416]	; (9b88 <usb_isr+0x2c4>)
    99e8:	b.n	9a00 <usb_isr+0x13c>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    99ea:	movw	r3, #8737	; 0x2221
    99ee:	cmp	r1, r3
    99f0:	beq.w	9c10 <usb_isr+0x34c>
    99f4:	movw	r3, #8993	; 0x2321
    99f8:	cmp	r1, r3
    99fa:	beq.w	9c2c <usb_isr+0x368>
    99fe:	b.n	9c24 <usb_isr+0x360>
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    9a00:	ldr.w	r3, [r4, r6, lsl #3]
    9a04:	lsls	r3, r3, #24
    9a06:	bpl.n	9a14 <usb_isr+0x150>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    9a08:	add.w	r3, r7, r6, lsl #3
    9a0c:	ldr	r0, [r3, #4]
    9a0e:	subs	r0, #8
    9a10:	bl	96ec <usb_free>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    9a14:	adds	r6, #1
    9a16:	cmp	r6, #20
    9a18:	bne.n	9a00 <usb_isr+0x13c>
    9a1a:	ldr	r7, [pc, #380]	; (9b98 <usb_isr+0x2d4>)
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    9a1c:	ldr.w	fp, [pc, #380]	; 9b9c <usb_isr+0x2d8>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    9a20:	movs	r6, #0
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    9a22:	ldr.w	r0, [fp, r6, lsl #2]
    9a26:	mov.w	r9, r6, lsl #2
			while (p) {
    9a2a:	cbz	r0, 9a3a <usb_isr+0x176>
				n = p->next;
    9a2c:	ldr	r2, [r0, #4]
    9a2e:	str	r2, [sp, #0]
				usb_free(p);
    9a30:	bl	96ec <usb_free>
				p = n;
    9a34:	ldr	r2, [sp, #0]
    9a36:	mov	r0, r2
    9a38:	b.n	9a2a <usb_isr+0x166>
			}
			rx_first[i] = NULL;
    9a3a:	ldr	r3, [pc, #352]	; (9b9c <usb_isr+0x2d8>)
			rx_last[i] = NULL;
			p = tx_first[i];
    9a3c:	ldr	r2, [pc, #352]	; (9ba0 <usb_isr+0x2dc>)
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
    9a3e:	str.w	r0, [r3, r9]
			rx_last[i] = NULL;
    9a42:	ldr	r3, [pc, #352]	; (9ba4 <usb_isr+0x2e0>)
    9a44:	str.w	r0, [r9, r3]
			p = tx_first[i];
    9a48:	ldr.w	r0, [r9, r2]
			while (p) {
    9a4c:	cbz	r0, 9a60 <usb_isr+0x19c>
				n = p->next;
    9a4e:	ldr	r1, [r0, #4]
    9a50:	str	r2, [sp, #4]
    9a52:	str	r1, [sp, #0]
				usb_free(p);
    9a54:	bl	96ec <usb_free>
				p = n;
    9a58:	ldr	r1, [sp, #0]
    9a5a:	ldr	r2, [sp, #4]
    9a5c:	mov	r0, r1
    9a5e:	b.n	9a4c <usb_isr+0x188>
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    9a60:	ldr	r3, [pc, #324]	; (9ba8 <usb_isr+0x2e4>)
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    9a62:	str.w	r0, [r2, r9]
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    9a66:	strh.w	r0, [r3, r6, lsl #1]
			switch (tx_state[i]) {
    9a6a:	ldrb	r3, [r7, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    9a6c:	ldr	r2, [pc, #316]	; (9bac <usb_isr+0x2e8>)
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    9a6e:	subs	r3, #2
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    9a70:	str.w	r0, [r9, r2]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    9a74:	cmp	r3, #3
    9a76:	bhi.n	9a88 <usb_isr+0x1c4>
    9a78:	tbb	[pc, r3]
    9a7c:	.word	0x04020402
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    9a80:	movs	r3, #0
    9a82:	b.n	9a86 <usb_isr+0x1c2>
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    9a84:	movs	r3, #1
    9a86:	strb	r3, [r7, #0]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    9a88:	adds	r6, #1
    9a8a:	cmp	r6, #4
    9a8c:	add.w	r7, r7, #1
    9a90:	bne.n	9a22 <usb_isr+0x15e>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    9a92:	ldr	r1, [pc, #284]	; (9bb0 <usb_isr+0x2ec>)
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
    9a94:	ldr.w	r9, [pc, #304]	; 9bc8 <usb_isr+0x304>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    9a98:	movs	r3, #0
    9a9a:	strb	r3, [r1, #0]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    9a9c:	mov.w	fp, #1
    9aa0:	mov	r7, r1
    9aa2:	ldr	r3, [pc, #272]	; (9bb4 <usb_isr+0x2f0>)
			epconf = *cfg++;
    9aa4:	add.w	r0, fp, r9
    9aa8:	add	r3, fp
    9aaa:	ldrb.w	r0, [r0, #-1]
    9aae:	lsls	r3, r3, #2
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    9ab0:	tst.w	r0, #8
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
			*reg = epconf;
    9ab4:	strb	r0, [r3, #0]
    9ab6:	mov.w	r6, fp, lsl #2
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    9aba:	beq.n	9b04 <usb_isr+0x240>
				usb_packet_t *p;
				p = usb_malloc();
    9abc:	bl	96b0 <usb_malloc>
				if (p) {
    9ac0:	cbz	r0, 9ad4 <usb_isr+0x210>
					table[index(i, RX, EVEN)].addr = p->buf;
    9ac2:	add.w	lr, r4, fp, lsl #5
    9ac6:	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    9ac8:	ldr	r3, [pc, #236]	; (9bb8 <usb_isr+0x2f4>)
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
    9aca:	str.w	r0, [lr, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    9ace:	str.w	r3, [r4, r6, lsl #3]
    9ad2:	b.n	9ade <usb_isr+0x21a>
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    9ad4:	str.w	r0, [r4, r6, lsl #3]
					usb_rx_memory_needed++;
    9ad8:	ldrb	r0, [r7, #0]
    9ada:	adds	r0, #1
    9adc:	strb	r0, [r7, #0]
				}
				p = usb_malloc();
    9ade:	bl	96b0 <usb_malloc>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    9ae2:	orr.w	lr, r6, #1
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
    9ae6:	cbz	r0, 9afa <usb_isr+0x236>
					table[index(i, RX, ODD)].addr = p->buf;
    9ae8:	add.w	ip, r4, lr, lsl #3
    9aec:	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    9aee:	ldr	r3, [pc, #164]	; (9b94 <usb_isr+0x2d0>)
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    9af0:	str.w	r0, [ip, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    9af4:	str.w	r3, [r4, lr, lsl #3]
    9af8:	b.n	9b04 <usb_isr+0x240>
				} else {
					table[index(i, RX, ODD)].desc = 0;
    9afa:	str.w	r0, [r4, lr, lsl #3]
					usb_rx_memory_needed++;
    9afe:	ldrb	r0, [r7, #0]
    9b00:	adds	r0, #1
    9b02:	strb	r0, [r7, #0]
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    9b04:	orr.w	lr, r6, #2
			table[index(i, TX, ODD)].desc = 0;
    9b08:	orr.w	r3, r6, #3
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    9b0c:	add.w	fp, fp, #1
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    9b10:	movs	r0, #0
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    9b12:	cmp.w	fp, #5
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    9b16:	str.w	r0, [r4, lr, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
    9b1a:	str.w	r0, [r4, r3, lsl #3]
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    9b1e:	bne.n	9aa2 <usb_isr+0x1de>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    9b20:	mov	r3, r0
    9b22:	b.n	9c36 <usb_isr+0x372>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    9b24:	ldr	r2, [pc, #80]	; (9b78 <usb_isr+0x2b4>)
    9b26:	ldr	r6, [pc, #148]	; (9bbc <usb_isr+0x2f8>)
    9b28:	ldrb	r2, [r2, #0]
    9b2a:	strb	r2, [r6, #0]
    9b2c:	b.n	9c38 <usb_isr+0x374>
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    9b2e:	ldr	r6, [pc, #140]	; (9bbc <usb_isr+0x2f8>)
    9b30:	strb	r2, [r6, #0]
		reply_buffer[1] = 0;
    9b32:	strb	r2, [r6, #1]
    9b34:	b.n	9c30 <usb_isr+0x36c>
    9b36:	ldrh	r1, [r5, #4]
    9b38:	and.w	r1, r1, #127	; 0x7f
		datalen = 2;
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    9b3c:	cmp	r1, #4
    9b3e:	bhi.n	9c24 <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    9b40:	ldr	r6, [pc, #120]	; (9bbc <usb_isr+0x2f8>)
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    9b42:	lsls	r1, r1, #2
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    9b44:	strb	r2, [r6, #0]
		reply_buffer[1] = 0;
    9b46:	strb	r2, [r6, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    9b48:	ldr	r2, [pc, #116]	; (9bc0 <usb_isr+0x2fc>)
    9b4a:	ldrb	r2, [r2, r1]
    9b4c:	lsls	r4, r2, #30
    9b4e:	bpl.n	9c30 <usb_isr+0x36c>
    9b50:	strb	r3, [r6, #0]
    9b52:	b.n	9c30 <usb_isr+0x36c>
    9b54:	ldrh	r2, [r5, #4]
    9b56:	and.w	r2, r2, #127	; 0x7f
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    9b5a:	cmp	r2, #4
    9b5c:	bhi.n	9c24 <usb_isr+0x360>
    9b5e:	ldrh	r3, [r5, #2]
    9b60:	cmp	r3, #0
    9b62:	bne.n	9c24 <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    9b64:	ldr	r1, [pc, #88]	; (9bc0 <usb_isr+0x2fc>)
    9b66:	lsls	r2, r2, #2
    9b68:	add	r1, r2
    9b6a:	ldrb	r2, [r1, #0]
    9b6c:	bic.w	r2, r2, #2
    9b70:	b.n	9be6 <usb_isr+0x322>
    9b72:	nop
    9b74:	.word	0x40072080
    9b78:	.word	0x2001a7df
    9b7c:	.word	0x2001a769
    9b80:	.word	0x2001a6e8
    9b84:	.word	0x40072090
    9b88:	.word	0x1fff0000
    9b8c:	.word	0x2001a7cc
    9b90:	.word	0x2001a7e0
    9b94:	.word	0x004000c8
    9b98:	.word	0x2001a714
    9b9c:	.word	0x2001a758
    9ba0:	.word	0x2001a7ac
    9ba4:	.word	0x2001a704
    9ba8:	.word	0x2001a854
    9bac:	.word	0x2001a7bc
    9bb0:	.word	0x2001a7d6
    9bb4:	.word	0x1001c830
    9bb8:	.word	0x00400088
    9bbc:	.word	0x2001a7d7
    9bc0:	.word	0x400720c0
    9bc4:	.word	0x2001a700
    9bc8:	.word	0x000130b2
    9bcc:	ldrh	r2, [r5, #4]
    9bce:	and.w	r2, r2, #127	; 0x7f
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    9bd2:	cmp	r2, #4
    9bd4:	bhi.n	9c24 <usb_isr+0x360>
    9bd6:	ldrh	r3, [r5, #2]
    9bd8:	cbnz	r3, 9c24 <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    9bda:	ldr	r1, [pc, #620]	; (9e48 <usb_isr+0x584>)
    9bdc:	lsls	r2, r2, #2
    9bde:	add	r1, r2
    9be0:	ldrb	r2, [r1, #0]
    9be2:	orr.w	r2, r2, #2
    9be6:	strb	r2, [r1, #0]
    9be8:	b.n	9c36 <usb_isr+0x372>
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    9bea:	ldrh	r2, [r5, #2]
    9bec:	ldrh	r1, [r5, #4]
    9bee:	ldr	r3, [pc, #604]	; (9e4c <usb_isr+0x588>)
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    9bf0:	ldr	r6, [r3, #4]
    9bf2:	cbz	r6, 9c24 <usb_isr+0x360>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    9bf4:	ldrh	r0, [r3, #0]
    9bf6:	cmp	r0, r2
    9bf8:	bne.n	9c0c <usb_isr+0x348>
    9bfa:	ldrh	r0, [r3, #2]
    9bfc:	cmp	r0, r1
    9bfe:	bne.n	9c0c <usb_isr+0x348>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    9c00:	lsrs	r2, r2, #8
    9c02:	cmp	r2, #3
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    9c04:	ite	eq
    9c06:	ldrbeq	r3, [r6, #0]
				} else {
					datalen = list->length;
    9c08:	ldrhne	r3, [r3, #8]
    9c0a:	b.n	9c38 <usb_isr+0x374>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    9c0c:	adds	r3, #12
    9c0e:	b.n	9bf0 <usb_isr+0x32c>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    9c10:	ldrh	r3, [r5, #4]
    9c12:	cbnz	r3, 9c34 <usb_isr+0x370>
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    9c14:	ldr	r2, [pc, #568]	; (9e50 <usb_isr+0x58c>)
    9c16:	ldr	r1, [r2, #0]
    9c18:	ldr	r2, [pc, #568]	; (9e54 <usb_isr+0x590>)
    9c1a:	str	r1, [r2, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    9c1c:	ldr	r2, [pc, #568]	; (9e58 <usb_isr+0x594>)
    9c1e:	ldrb	r1, [r5, #2]
    9c20:	strb	r1, [r2, #0]
    9c22:	b.n	9c36 <usb_isr+0x372>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9c24:	ldr	r3, [pc, #544]	; (9e48 <usb_isr+0x584>)
    9c26:	movs	r2, #15
    9c28:	strb	r2, [r3, #0]
    9c2a:	b.n	9c80 <usb_isr+0x3bc>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    9c2c:	movs	r3, #0
    9c2e:	b.n	9c36 <usb_isr+0x372>
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    9c30:	movs	r3, #2
    9c32:	b.n	9c38 <usb_isr+0x374>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    9c34:	mov	r3, r2

static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
    9c36:	mov	r6, r3
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    9c38:	ldrh	r4, [r5, #6]
    9c3a:	cmp	r4, r3
    9c3c:	it	cs
    9c3e:	movcs	r4, r3
    9c40:	cmp	r4, #64	; 0x40
    9c42:	mov	r5, r4
    9c44:	it	cs
    9c46:	movcs	r5, #64	; 0x40
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
    9c48:	mov	r0, r6
    9c4a:	mov	r1, r5
    9c4c:	bl	9730 <endpoint0_transmit>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9c50:	subs	r4, r4, r5

	if (datalen > setup.wLength) datalen = setup.wLength;
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    9c52:	add	r6, r5
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9c54:	bne.n	9c5e <usb_isr+0x39a>
    9c56:	cmp	r5, #64	; 0x40
    9c58:	bne.n	9c80 <usb_isr+0x3bc>
    9c5a:	mov	r5, r4
    9c5c:	b.n	9c66 <usb_isr+0x3a2>
    9c5e:	cmp	r4, #64	; 0x40
    9c60:	mov	r5, r4
    9c62:	it	cs
    9c64:	movcs	r5, #64	; 0x40

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
    9c66:	mov	r0, r6
    9c68:	mov	r1, r5
    9c6a:	bl	9730 <endpoint0_transmit>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9c6e:	subs	r4, r4, r5
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    9c70:	add	r6, r5
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9c72:	bne.n	9c78 <usb_isr+0x3b4>
    9c74:	cmp	r5, #64	; 0x40
    9c76:	bne.n	9c80 <usb_isr+0x3bc>

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    9c78:	ldr	r3, [pc, #480]	; (9e5c <usb_isr+0x598>)
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    9c7a:	str.w	r6, [sl]
	ep0_tx_len = datalen;
    9c7e:	strh	r4, [r3, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    9c80:	movs	r2, #1
    9c82:	ldr	r3, [pc, #476]	; (9e60 <usb_isr+0x59c>)
    9c84:	b.n	9d02 <usb_isr+0x43e>
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    9c86:	ldr	r3, [pc, #476]	; (9e64 <usb_isr+0x5a0>)
    9c88:	ldrh	r0, [r3, #0]
    9c8a:	movw	r1, #8225	; 0x2021
    9c8e:	cmp	r0, r1
    9c90:	bne.n	9cb8 <usb_isr+0x3f4>
			int i;
			uint32_t *line_coding = NULL;
			switch (setup.wIndex) {
    9c92:	ldrh	r3, [r3, #4]
    9c94:	cbnz	r3, 9cb0 <usb_isr+0x3ec>
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
					//serial_phex(*buf);
					*dst++ = *buf++;
    9c96:	ldr	r1, [pc, #464]	; (9e68 <usb_isr+0x5a4>)
    9c98:	ldrb	r0, [r2, r3]
    9c9a:	strb	r0, [r3, r1]
#endif
			}
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
    9c9c:	adds	r3, #1
    9c9e:	cmp	r3, #7
    9ca0:	bne.n	9c98 <usb_isr+0x3d4>
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    9ca2:	ldr	r3, [pc, #452]	; (9e68 <usb_isr+0x5a4>)
    9ca4:	ldr	r3, [r3, #0]
    9ca6:	cmp	r3, #134	; 0x86
    9ca8:	ittt	eq
    9caa:	ldreq	r3, [pc, #448]	; (9e6c <usb_isr+0x5a8>)
    9cac:	moveq	r2, #15
    9cae:	strbeq	r2, [r3, #0]
			}
			endpoint0_transmit(NULL, 0);
    9cb0:	movs	r1, #0
    9cb2:	mov	r0, r1
    9cb4:	bl	9730 <endpoint0_transmit>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    9cb8:	ldr	r3, [pc, #436]	; (9e70 <usb_isr+0x5ac>)
    9cba:	str.w	r3, [r4, r6, lsl #3]
    9cbe:	b.n	9d04 <usb_isr+0x440>
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    9cc0:	ldr	r7, [pc, #432]	; (9e74 <usb_isr+0x5b0>)
    9cc2:	ldr	r6, [r7, #0]
		if (data) {
    9cc4:	cbz	r6, 9cf0 <usb_isr+0x42c>
			size = ep0_tx_len;
    9cc6:	ldr.w	sl, [pc, #404]	; 9e5c <usb_isr+0x598>
    9cca:	ldrh.w	r4, [sl]
    9cce:	cmp	r4, #64	; 0x40
    9cd0:	mov	r5, r4
    9cd2:	it	cs
    9cd4:	movcs	r5, #64	; 0x40
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
    9cd6:	mov	r0, r6
    9cd8:	mov	r1, r5
    9cda:	bl	9730 <endpoint0_transmit>
			data += size;
			ep0_tx_len -= size;
    9cde:	subs	r0, r4, r5
    9ce0:	uxth	r0, r0
    9ce2:	strh.w	r0, [sl]
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    9ce6:	cbnz	r0, 9cec <usb_isr+0x428>
    9ce8:	cmp	r5, #64	; 0x40
    9cea:	bne.n	9cee <usb_isr+0x42a>
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    9cec:	adds	r0, r6, r5
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    9cee:	str	r0, [r7, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    9cf0:	ldr	r3, [pc, #368]	; (9e64 <usb_isr+0x5a0>)
    9cf2:	ldrh	r2, [r3, #0]
    9cf4:	cmp.w	r2, #1280	; 0x500
    9cf8:	bne.n	9d04 <usb_isr+0x440>
			setup.bRequest = 0;
    9cfa:	movs	r2, #0
    9cfc:	strb	r2, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    9cfe:	ldrb	r2, [r3, #2]
    9d00:	ldr	r3, [pc, #372]	; (9e78 <usb_isr+0x5b4>)
    9d02:	strb	r2, [r3, #0]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    9d04:	ldr	r3, [pc, #344]	; (9e60 <usb_isr+0x59c>)
    9d06:	movs	r2, #1
    9d08:	strb	r2, [r3, #0]
    9d0a:	b.n	9dfc <usb_isr+0x538>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    9d0c:	add.w	r5, r4, r6, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    9d10:	subs	r7, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    9d12:	ldr	r2, [r5, #4]
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    9d14:	and.w	r3, r3, #8
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    9d18:	sub.w	r0, r2, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    9d1c:	uxtb	r7, r7
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    9d1e:	and.w	lr, r3, #255	; 0xff
    9d22:	cmp	r3, #0
    9d24:	beq.n	9d94 <usb_isr+0x4d0>
				usb_free(packet);
    9d26:	bl	96ec <usb_free>
				packet = tx_first[endpoint];
    9d2a:	ldr	r0, [pc, #336]	; (9e7c <usb_isr+0x5b8>)
    9d2c:	ldr	r3, [pc, #336]	; (9e80 <usb_isr+0x5bc>)
    9d2e:	ldr.w	r1, [r0, r7, lsl #2]
				if (packet) {
    9d32:	cbz	r1, 9d70 <usb_isr+0x4ac>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    9d34:	ldr	r2, [r1, #4]
    9d36:	str.w	r2, [r0, r7, lsl #2]
					b->addr = packet->buf;
    9d3a:	add.w	r2, r1, #8
    9d3e:	str	r2, [r5, #4]
					switch (tx_state[endpoint]) {
    9d40:	ldrb	r2, [r3, r7]
    9d42:	cmp	r2, #3
    9d44:	bhi.n	9d5e <usb_isr+0x49a>
    9d46:	tbb	[pc, r2]
    9d4a:	.short	0x0402
    9d4c:	.short	0x0806
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    9d4e:	movs	r2, #3
    9d50:	b.n	9d5c <usb_isr+0x498>
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    9d52:	movs	r2, #2
    9d54:	b.n	9d5c <usb_isr+0x498>
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    9d56:	movs	r2, #5
    9d58:	b.n	9d5c <usb_isr+0x498>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    9d5a:	movs	r2, #4
    9d5c:	strb	r2, [r3, r7]
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    9d5e:	tst.w	r5, #8
    9d62:	ldrh	r2, [r1, #0]
    9d64:	ite	ne
    9d66:	movne	r3, #200	; 0xc8
    9d68:	moveq	r3, #136	; 0x88
    9d6a:	orr.w	r3, r3, r2, lsl #16
    9d6e:	b.n	9df8 <usb_isr+0x534>
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    9d70:	ldrb	r2, [r3, r7]
    9d72:	cmp	r2, #3
    9d74:	bhi.n	9d86 <usb_isr+0x4c2>
    9d76:	tbb	[pc, r2]
    9d7a:	.short	0x4141
    9d7c:	.short	0x0402
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    9d7e:	movs	r2, #0
    9d80:	b.n	9d90 <usb_isr+0x4cc>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    9d82:	movs	r2, #1
    9d84:	b.n	9d90 <usb_isr+0x4cc>
						break;
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    9d86:	tst.w	r5, #8
    9d8a:	ite	ne
    9d8c:	movne	r2, #3
    9d8e:	moveq	r2, #2
    9d90:	strb	r2, [r3, r7]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    9d92:	b.n	9dfc <usb_isr+0x538>
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    9d94:	ldr.w	r3, [r4, r6, lsl #3]
    9d98:	lsrs	r3, r3, #16
    9d9a:	uxth	r1, r3
    9d9c:	strh.w	r1, [r2, #-8]
				if (packet->len > 0) {
    9da0:	cbz	r3, 9dec <usb_isr+0x528>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    9da2:	ldr	r3, [pc, #224]	; (9e84 <usb_isr+0x5c0>)
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    9da4:	strh.w	lr, [r2, #-6]
					packet->next = NULL;
    9da8:	str.w	lr, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    9dac:	ldr.w	r2, [r3, r7, lsl #2]
    9db0:	ldr.w	lr, [pc, #252]	; 9eb0 <usb_isr+0x5ec>
    9db4:	cbnz	r2, 9dbc <usb_isr+0x4f8>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    9db6:	str.w	r0, [r3, r7, lsl #2]
    9dba:	b.n	9dc2 <usb_isr+0x4fe>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    9dbc:	ldr.w	r3, [lr, r7, lsl #2]
    9dc0:	str	r0, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    9dc2:	ldr	r2, [pc, #196]	; (9e88 <usb_isr+0x5c4>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
					}
					rx_last[endpoint] = packet;
    9dc4:	str.w	r0, [lr, r7, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    9dc8:	ldrh.w	r3, [r2, r7, lsl #1]
    9dcc:	add	r3, r1
    9dce:	strh.w	r3, [r2, r7, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    9dd2:	bl	96b0 <usb_malloc>
					if (packet) {
    9dd6:	cbz	r0, 9dde <usb_isr+0x51a>
						b->addr = packet->buf;
    9dd8:	adds	r0, #8
    9dda:	str	r0, [r5, #4]
    9ddc:	b.n	9dec <usb_isr+0x528>
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    9dde:	ldr	r2, [pc, #172]	; (9e8c <usb_isr+0x5c8>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    9de0:	str.w	r0, [r4, r6, lsl #3]
						usb_rx_memory_needed++;
    9de4:	ldrb	r3, [r2, #0]
    9de6:	adds	r3, #1
    9de8:	strb	r3, [r2, #0]
    9dea:	b.n	9dfc <usb_isr+0x538>
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9dec:	ldr	r2, [pc, #160]	; (9e90 <usb_isr+0x5cc>)
    9dee:	ldr	r3, [pc, #128]	; (9e70 <usb_isr+0x5ac>)
    9df0:	tst.w	r5, #8
    9df4:	it	eq
    9df6:	moveq	r3, r2
    9df8:	str.w	r3, [r4, r6, lsl #3]
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    9dfc:	movs	r3, #8
    9dfe:	strb.w	r3, [r8]
		goto restart;
    9e02:	b.n	98cc <usb_isr+0x8>
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    9e04:	lsls	r0, r4, #31
    9e06:	bpl.n	9eb4 <usb_isr+0x5f0>
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    9e08:	ldr	r1, [pc, #84]	; (9e60 <usb_isr+0x59c>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    9e0a:	ldr	r0, [pc, #132]	; (9e90 <usb_isr+0x5cc>)
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    9e0c:	ldr	r4, [pc, #132]	; (9e94 <usb_isr+0x5d0>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    9e0e:	movs	r3, #2
    9e10:	strb	r3, [r1, #0]
		ep0_tx_bdt_bank = 0;
    9e12:	ldr	r3, [pc, #132]	; (9e98 <usb_isr+0x5d4>)
    9e14:	strb	r2, [r3, #0]

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    9e16:	ldr	r3, [pc, #132]	; (9e9c <usb_isr+0x5d8>)
    9e18:	str	r0, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    9e1a:	str	r4, [r3, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    9e1c:	str	r0, [r3, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    9e1e:	ldr	r0, [pc, #128]	; (9ea0 <usb_isr+0x5dc>)
    9e20:	str	r0, [r3, #12]
		table[index(0, TX, EVEN)].desc = 0;
    9e22:	str	r2, [r3, #16]
		table[index(0, TX, ODD)].desc = 0;
    9e24:	str	r2, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9e26:	ldr	r3, [pc, #32]	; (9e48 <usb_isr+0x584>)
    9e28:	movs	r0, #13
    9e2a:	strb	r0, [r3, #0]

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    9e2c:	ldr	r0, [pc, #116]	; (9ea4 <usb_isr+0x5e0>)
    9e2e:	movs	r3, #255	; 0xff
    9e30:	strb	r3, [r0, #0]
		USB0_ISTAT = 0xFF;
    9e32:	strb	r3, [r5, #0]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    9e34:	strb	r2, [r0, #16]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    9e36:	ldr	r2, [pc, #112]	; (9ea8 <usb_isr+0x5e4>)
    9e38:	strb	r3, [r2, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    9e3a:	ldr	r3, [pc, #112]	; (9eac <usb_isr+0x5e8>)
    9e3c:	movs	r2, #159	; 0x9f
    9e3e:	strb	r2, [r3, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    9e40:	movs	r3, #1
    9e42:	strb	r3, [r1, #0]
		return;
    9e44:	b.n	9eda <usb_isr+0x616>
    9e46:	nop
    9e48:	.word	0x400720c0
    9e4c:	.word	0x000130b8
    9e50:	.word	0x2001a6fc
    9e54:	.word	0x2001a850
    9e58:	.word	0x2001a6f8
    9e5c:	.word	0x2001a7d4
    9e60:	.word	0x40072094
    9e64:	.word	0x2001a7cc
    9e68:	.word	0x2001a848
    9e6c:	.word	0x2001a769
    9e70:	.word	0x004000c8
    9e74:	.word	0x2001a700
    9e78:	.word	0x40072098
    9e7c:	.word	0x2001a7ac
    9e80:	.word	0x2001a714
    9e84:	.word	0x2001a758
    9e88:	.word	0x2001a854
    9e8c:	.word	0x2001a7d6
    9e90:	.word	0x00400088
    9e94:	.word	0x2001a718
    9e98:	.word	0x2001a768
    9e9c:	.word	0x1fff0000
    9ea0:	.word	0x2001a76c
    9ea4:	.word	0x40072088
    9ea8:	.word	0x4007208c
    9eac:	.word	0x40072084
    9eb0:	.word	0x2001a704
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    9eb4:	lsls	r1, r4, #24
    9eb6:	bpl.n	9ec2 <usb_isr+0x5fe>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9eb8:	ldr	r3, [pc, #36]	; (9ee0 <usb_isr+0x61c>)
    9eba:	movs	r2, #13
    9ebc:	strb	r2, [r3, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    9ebe:	movs	r3, #128	; 0x80
    9ec0:	strb	r3, [r5, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    9ec2:	lsls	r2, r4, #30
    9ec4:	bpl.n	9ed2 <usb_isr+0x60e>
		uint8_t err = USB0_ERRSTAT;
    9ec6:	ldr	r2, [pc, #28]	; (9ee4 <usb_isr+0x620>)
    9ec8:	ldrb	r3, [r2, #0]
    9eca:	uxtb	r3, r3
		USB0_ERRSTAT = err;
    9ecc:	strb	r3, [r2, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    9ece:	movs	r3, #2
    9ed0:	strb	r3, [r5, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    9ed2:	lsls	r3, r4, #27
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    9ed4:	itt	mi
    9ed6:	movmi	r3, #16
    9ed8:	strbmi	r3, [r5, #0]
	}

}
    9eda:	add	sp, #12
    9edc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9ee0:	.word	0x400720c0
    9ee4:	.word	0x40072088

00009ee8 <usb_init>:



void usb_init(void)
{
    9ee8:	push	{r4, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    9eea:	bl	a49c <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    9eee:	movs	r3, #0
		table[i].desc = 0;
    9ef0:	ldr	r0, [pc, #108]	; (9f60 <usb_init+0x78>)
    9ef2:	mov	r1, r3
    9ef4:	str.w	r1, [r0, r3, lsl #3]
		table[i].addr = 0;
    9ef8:	add.w	r4, r0, r3, lsl #3
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    9efc:	adds	r3, #1
    9efe:	cmp	r3, #20
		table[i].desc = 0;
    9f00:	ldr	r2, [pc, #92]	; (9f60 <usb_init+0x78>)
		table[i].addr = 0;
    9f02:	str	r1, [r4, #4]
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    9f04:	bne.n	9ef4 <usb_init+0xc>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    9f06:	ldr	r1, [pc, #92]	; (9f64 <usb_init+0x7c>)
    9f08:	ldr	r3, [r1, #0]
    9f0a:	orr.w	r3, r3, #262144	; 0x40000
    9f0e:	str	r3, [r1, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    9f10:	ldr	r1, [pc, #84]	; (9f68 <usb_init+0x80>)
    9f12:	ldr	r3, [r1, #0]
    9f14:	orr.w	r3, r3, #50331648	; 0x3000000
    9f18:	str	r3, [r1, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    9f1a:	ldr	r3, [pc, #80]	; (9f6c <usb_init+0x84>)
    9f1c:	ubfx	r1, r2, #8, #8
    9f20:	strb	r1, [r3, #0]
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    9f22:	ubfx	r1, r2, #16, #8
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    9f26:	lsrs	r2, r2, #24
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    9f28:	strb	r1, [r3, #20]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    9f2a:	strb	r2, [r3, #24]

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    9f2c:	ldr	r2, [pc, #64]	; (9f70 <usb_init+0x88>)
    9f2e:	movs	r3, #255	; 0xff
    9f30:	strb	r3, [r2, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    9f32:	movs	r1, #0
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    9f34:	strb	r3, [r2, #8]
	USB0_OTGISTAT = 0xFF;
    9f36:	strb.w	r3, [r2, #-112]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    9f3a:	movs	r3, #1
    9f3c:	strb	r3, [r2, #20]
	USB0_USBCTRL = 0;
    9f3e:	strb.w	r1, [r2, #128]	; 0x80

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    9f42:	strb	r3, [r2, #4]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    9f44:	ldr	r3, [pc, #44]	; (9f74 <usb_init+0x8c>)
    9f46:	movs	r2, #112	; 0x70
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    9f48:	mvn.w	r1, #816	; 0x330

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    9f4c:	strb	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    9f4e:	add	r3, r1
    9f50:	mov.w	r2, #2097152	; 0x200000
    9f54:	str	r2, [r3, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    9f56:	ldr	r3, [pc, #32]	; (9f78 <usb_init+0x90>)
    9f58:	movs	r2, #16
    9f5a:	strb	r2, [r3, #0]
    9f5c:	pop	{r4, pc}
    9f5e:	nop
    9f60:	.word	0x1fff0000
    9f64:	.word	0x40048034
    9f68:	.word	0x4000d800
    9f6c:	.word	0x4007209c
    9f70:	.word	0x40072080
    9f74:	.word	0xe000e435
    9f78:	.word	0x40072108

00009f7c <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    9f7c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    9f80:	ldr	r4, [pc, #176]	; (a034 <yield+0xb8>)
    9f82:	ldrb	r3, [r4, #0]
    9f84:	cmp	r3, #0
    9f86:	beq.n	a02e <yield+0xb2>
	if (running) return; // TODO: does this need to be atomic?
    9f88:	ldr	r5, [pc, #172]	; (a038 <yield+0xbc>)
    9f8a:	ldrb	r2, [r5, #0]
    9f8c:	cmp	r2, #0
    9f8e:	bne.n	a02e <yield+0xb2>
	running = 1;
    9f90:	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    9f92:	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    9f94:	strb	r2, [r5, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    9f96:	bpl.n	9fb0 <yield+0x34>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    9f98:	bl	91ac <usb_serial_available>
		if (Serial.available()) serialEvent();
    9f9c:	cbz	r0, 9fa2 <yield+0x26>
    9f9e:	bl	a3da <serialEvent()>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    9fa2:	ldr	r3, [pc, #152]	; (a03c <yield+0xc0>)
    9fa4:	ldrb	r3, [r3, #0]
    9fa6:	cbz	r3, 9fb0 <yield+0x34>
    9fa8:	ldrb	r3, [r4, #0]
    9faa:	bic.w	r3, r3, #1
    9fae:	strb	r3, [r4, #0]
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    9fb0:	ldrb	r3, [r4, #0]
    9fb2:	lsls	r2, r3, #30
    9fb4:	bpl.n	9fe0 <yield+0x64>
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    9fb6:	ldr.w	r8, [pc, #148]	; a04c <yield+0xd0>
			s_serials_with_serial_events[i]->doYieldCode();
    9fba:	ldr.w	r9, [pc, #148]	; a050 <yield+0xd4>
    9fbe:	movs	r6, #0
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    9fc0:	ldrb.w	r2, [r8]
    9fc4:	uxtb	r3, r6
    9fc6:	cmp	r2, r3
    9fc8:	bls.n	9fe0 <yield+0x64>
			s_serials_with_serial_events[i]->doYieldCode();
    9fca:	ldr.w	r7, [r9, r3, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*_serialEvent)();
    9fce:	ldr	r3, [r7, #0]
    9fd0:	mov	r0, r7
    9fd2:	ldr	r3, [r3, #16]
    9fd4:	blx	r3
    9fd6:	cbz	r0, 9fdc <yield+0x60>
    9fd8:	ldr	r3, [r7, #16]
    9fda:	blx	r3
    9fdc:	adds	r6, #1
    9fde:	b.n	9fc0 <yield+0x44>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    9fe0:	movs	r3, #0
    9fe2:	strb	r3, [r5, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    9fe4:	ldrb	r3, [r4, #0]
    9fe6:	lsls	r3, r3, #29
    9fe8:	bpl.n	a02e <yield+0xb2>
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
    9fea:	ldr	r1, [pc, #84]	; (a040 <yield+0xc4>)
    9fec:	ldr	r3, [r1, #0]
    9fee:	cbz	r3, a02e <yield+0xb2>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    9ff0:	mrs	r3, IPSR
		if (ipsr != 0) return;
    9ff4:	cbnz	r3, a02e <yield+0xb2>
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    9ff6:	mrs	r2, PRIMASK
		__disable_irq();
    9ffa:	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    9ffc:	ldr	r0, [r1, #0]
		if (first == nullptr) {
    9ffe:	cbz	r0, a006 <yield+0x8a>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    a000:	ldr	r4, [pc, #64]	; (a044 <yield+0xc8>)
    a002:	ldrb	r5, [r4, #0]
    a004:	cbz	r5, a00e <yield+0x92>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    a006:	cbnz	r2, a02e <yield+0xb2>
    a008:	cpsie	i
    a00a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    a00e:	movs	r3, #1
    a010:	strb	r3, [r4, #0]
		firstYield = first->_next;
    a012:	ldr	r3, [r0, #20]
    a014:	str	r3, [r1, #0]
		if (firstYield) {
    a016:	cbz	r3, a01c <yield+0xa0>
			firstYield->_prev = nullptr;
    a018:	str	r5, [r3, #24]
    a01a:	b.n	a020 <yield+0xa4>
		} else {
			lastYield = nullptr;
    a01c:	ldr	r1, [pc, #40]	; (a048 <yield+0xcc>)
    a01e:	str	r3, [r1, #0]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    a020:	cbnz	r2, a024 <yield+0xa8>
    a022:	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    a024:	movs	r5, #0
    a026:	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    a028:	ldr	r3, [r0, #8]
    a02a:	blx	r3
		runningFromYield = false;
    a02c:	strb	r5, [r4, #0]
    a02e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a032:	nop
    a034:	.word	0x1fff1344
    a038:	.word	0x2001a7e1
    a03c:	.word	0x1fff1358
    a040:	.word	0x2001a7f0
    a044:	.word	0x2001a7f4
    a048:	.word	0x2001a7ec
    a04c:	.word	0x2001a810
    a050:	.word	0x2001a7f8

0000a054 <DMAChannel::begin(bool)>:
/**                     Teensy 3.0 & 3.1                       **/
/****************************************************************/
#if defined(KINETISK)

void DMAChannel::begin(bool force_initialization)
{
    a054:	push	{r4, r5, lr}
	uint32_t ch = 0;

	__disable_irq();
    a056:	cpsid	i
    a058:	ldr	r4, [pc, #148]	; (a0f0 <DMAChannel::begin(bool)+0x9c>)
	if (!force_initialization && TCD && channel < DMA_MAX_CHANNELS
    a05a:	cbnz	r1, a080 <DMAChannel::begin(bool)+0x2c>
    a05c:	ldr	r1, [r0, #0]
    a05e:	cbz	r1, a080 <DMAChannel::begin(bool)+0x2c>
    a060:	ldrb	r3, [r0, #4]
    a062:	cmp	r3, #15
    a064:	bhi.n	a080 <DMAChannel::begin(bool)+0x2c>
	  && (dma_channel_allocated_mask & (1 << channel))
    a066:	ldrh	r2, [r4, #0]
    a068:	asrs	r2, r3
    a06a:	lsls	r2, r2, #31
    a06c:	bpl.n	a080 <DMAChannel::begin(bool)+0x2c>
	  && (uint32_t)TCD == (uint32_t)(0x40009000 + channel * 32)) {
    a06e:	add.w	r3, r3, #33554432	; 0x2000000
    a072:	add.w	r3, r3, #1152	; 0x480
    a076:	cmp.w	r1, r3, lsl #5
    a07a:	bne.n	a080 <DMAChannel::begin(bool)+0x2c>
		// DMA channel already allocated
		__enable_irq();
    a07c:	cpsie	i
		return;
    a07e:	pop	{r4, r5, pc}
	}
	while (1) {
		if (!(dma_channel_allocated_mask & (1 << ch))) {
    a080:	ldrh	r1, [r4, #0]
    a082:	movs	r3, #0
    a084:	asr.w	r2, r1, r3
    a088:	ands.w	r2, r2, #1
    a08c:	bne.n	a0e0 <DMAChannel::begin(bool)+0x8c>
			dma_channel_allocated_mask |= (1 << ch);
    a08e:	movs	r5, #1
    a090:	lsls	r5, r3
    a092:	orrs	r1, r5
    a094:	strh	r1, [r4, #0]
			__enable_irq();
    a096:	cpsie	i
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    a098:	ldr	r5, [pc, #88]	; (a0f4 <DMAChannel::begin(bool)+0xa0>)
			channel = DMA_MAX_CHANNELS;
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
    a09a:	uxtb	r1, r3
    a09c:	strb	r1, [r0, #4]
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    a09e:	ldr	r4, [r5, #0]
    a0a0:	orr.w	r4, r4, #2
    a0a4:	str	r4, [r5, #0]
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    a0a6:	ldr.w	r4, [r5, #-4]
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    a0aa:	add.w	r3, r3, #33554432	; 0x2000000
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    a0ae:	orr.w	r4, r4, #2
    a0b2:	str.w	r4, [r5, #-4]
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    a0b6:	add.w	r3, r3, #1152	; 0x480
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
    a0ba:	ldr	r4, [pc, #60]	; (a0f8 <DMAChannel::begin(bool)+0xa4>)
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    a0bc:	lsls	r3, r3, #5
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
    a0be:	movw	r5, #1154	; 0x482
    a0c2:	str	r5, [r4, #0]
#endif
	DMA_CERQ = ch;
    a0c4:	strb	r1, [r4, #26]
	DMA_CERR = ch;
    a0c6:	strb	r1, [r4, #30]
	DMA_CEEI = ch;
    a0c8:	strb	r1, [r4, #24]
	DMA_CINT = ch;
    a0ca:	strb	r1, [r4, #31]
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    a0cc:	str	r3, [r0, #0]
	uint32_t *p = (uint32_t *)TCD;
	*p++ = 0;
    a0ce:	str	r2, [r3, #0]
	*p++ = 0;
    a0d0:	str	r2, [r3, #4]
	*p++ = 0;
    a0d2:	str	r2, [r3, #8]
	*p++ = 0;
    a0d4:	str	r2, [r3, #12]
	*p++ = 0;
    a0d6:	str	r2, [r3, #16]
	*p++ = 0;
    a0d8:	str	r2, [r3, #20]
	*p++ = 0;
    a0da:	str	r2, [r3, #24]
	*p++ = 0;
    a0dc:	str	r2, [r3, #28]
    a0de:	pop	{r4, r5, pc}
		if (!(dma_channel_allocated_mask & (1 << ch))) {
			dma_channel_allocated_mask |= (1 << ch);
			__enable_irq();
			break;
		}
		if (++ch >= DMA_MAX_CHANNELS) {
    a0e0:	adds	r3, #1
    a0e2:	cmp	r3, #16
    a0e4:	bne.n	a084 <DMAChannel::begin(bool)+0x30>
			__enable_irq();
    a0e6:	cpsie	i
			TCD = (TCD_t *)0;
    a0e8:	movs	r2, #0
    a0ea:	str	r2, [r0, #0]
			channel = DMA_MAX_CHANNELS;
    a0ec:	strb	r3, [r0, #4]
    a0ee:	pop	{r4, r5, pc}
    a0f0:	.word	0x2001a7e2
    a0f4:	.word	0x40048040
    a0f8:	.word	0x40008000

0000a0fc <DMAChannel::release()>:
	*p++ = 0;
}

void DMAChannel::release(void)
{
	if (channel >= DMA_MAX_CHANNELS) return;
    a0fc:	ldrb	r3, [r0, #4]
    a0fe:	cmp	r3, #15
    a100:	bhi.n	a124 <DMAChannel::release()+0x28>
	DMA_CERQ = channel;
    a102:	ldr	r2, [pc, #36]	; (a128 <DMAChannel::release()+0x2c>)
    a104:	strb	r3, [r2, #0]
	__disable_irq();
    a106:	cpsid	i
	dma_channel_allocated_mask &= ~(1 << channel);
    a108:	ldr	r1, [pc, #32]	; (a12c <DMAChannel::release()+0x30>)
    a10a:	ldrb	r2, [r0, #4]
    a10c:	movs	r3, #1
    a10e:	lsl.w	r2, r3, r2
    a112:	ldrh	r3, [r1, #0]
    a114:	bic.w	r3, r3, r2
    a118:	strh	r3, [r1, #0]
	__enable_irq();
    a11a:	cpsie	i
	channel = DMA_MAX_CHANNELS;
    a11c:	movs	r3, #16
    a11e:	strb	r3, [r0, #4]
	TCD = (TCD_t *)0;
    a120:	movs	r3, #0
    a122:	str	r3, [r0, #0]
    a124:	bx	lr
    a126:	nop
    a128:	.word	0x4000801a
    a12c:	.word	0x2001a7e2

0000a130 <MillisTimer::disableTimerInterrupt()>:
	volatile TimerStateType _state = TimerOff;
	static MillisTimer *listWaiting; // single linked list of waiting to start timers
	static MillisTimer *listActive;  // double linked list of running timers
	static bool disableTimerInterrupt() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    a130:	mrs	r0, PRIMASK
		__disable_irq();
    a134:	cpsid	i
		return (primask == 0) ? true : false;
	}
    a136:	clz	r0, r0
    a13a:	lsrs	r0, r0, #5
    a13c:	bx	lr

0000a13e <MillisTimer::enableTimerInterrupt(bool)>:
	static void enableTimerInterrupt(bool doit) {
		if (doit) __enable_irq();
    a13e:	cbz	r0, a142 <MillisTimer::enableTimerInterrupt(bool)+0x4>
    a140:	cpsie	i
    a142:	bx	lr

0000a144 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    a144:	push	{r3, r4, r5, r6, r7, lr}
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    a146:	ldr	r6, [pc, #48]	; (a178 <EventResponder::runFromInterrupt()+0x34>)
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    a148:	ldr	r7, [pc, #48]	; (a17c <EventResponder::runFromInterrupt()+0x38>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    a14a:	movs	r5, #0
}

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
    a14c:	bl	a130 <MillisTimer::disableTimerInterrupt()>
		EventResponder *first = firstInterrupt;
    a150:	ldr	r4, [r6, #0]
}

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
    a152:	mov	r2, r0
		EventResponder *first = firstInterrupt;
		if (first) {
    a154:	cbz	r4, a172 <EventResponder::runFromInterrupt()+0x2e>
			firstInterrupt = first->_next;
    a156:	ldr	r3, [r4, #20]
    a158:	str	r3, [r6, #0]
			if (firstInterrupt) {
    a15a:	cbz	r3, a160 <EventResponder::runFromInterrupt()+0x1c>
				firstInterrupt->_prev = nullptr;
    a15c:	str	r5, [r3, #24]
    a15e:	b.n	a162 <EventResponder::runFromInterrupt()+0x1e>
			} else {
				lastInterrupt = nullptr;
    a160:	str	r3, [r7, #0]
			}
			enableInterrupts(irq);
    a162:	mov	r0, r2
    a164:	bl	a13e <MillisTimer::enableTimerInterrupt(bool)>
			first->_triggered = false;
    a168:	strb	r5, [r4, #29]
			(*(first->_function))(*first);
    a16a:	ldr	r3, [r4, #8]
    a16c:	mov	r0, r4
    a16e:	blx	r3
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
	while (1) {
    a170:	b.n	a14c <EventResponder::runFromInterrupt()+0x8>
			}
			enableInterrupts(irq);
			first->_triggered = false;
			(*(first->_function))(*first);
		} else {
			enableInterrupts(irq);
    a172:	bl	a13e <MillisTimer::enableTimerInterrupt(bool)>
    a176:	pop	{r3, r4, r5, r6, r7, pc}
    a178:	.word	0x2001a7e4
    a17c:	.word	0x2001a7e8

0000a180 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    a180:	b.w	a144 <EventResponder::runFromInterrupt()>

0000a184 <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
    a184:	ldr	r2, [pc, #8]	; (a190 <systick_isr+0xc>)
    a186:	ldr	r3, [r2, #0]
    a188:	adds	r3, #1
    a18a:	str	r3, [r2, #0]
    a18c:	bx	lr
    a18e:	nop
    a190:	.word	0x2001a6fc

0000a194 <usb_serial_class::clear()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    a194:	b.w	91c8 <usb_serial_flush_input>

0000a198 <usb_serial_class::peek()>:
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    a198:	b.w	9174 <usb_serial_peekchar>

0000a19c <usb_serial_class::read()>:
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    a19c:	b.w	9128 <usb_serial_getchar>

0000a1a0 <usb_serial_class::available()>:
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    a1a0:	b.w	91ac <usb_serial_available>

0000a1a4 <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    a1a4:	b.w	9338 <usb_serial_flush_output>

0000a1a8 <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    a1a8:	b.w	92f0 <usb_serial_write_buffer_free>

0000a1ac <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    a1ac:	mov	r0, r1
    a1ae:	mov	r1, r2
    a1b0:	b.w	91f8 <usb_serial_write>

0000a1b4 <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    a1b4:	mov	r0, r1
    a1b6:	b.w	92d8 <usb_serial_putchar>

0000a1ba <Print::write(unsigned char const*, unsigned int)>:

#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
    a1ba:	push	{r3, r4, r5, r6, r7, lr}
    a1bc:	mov	r7, r0
	if (buffer == nullptr) return 0;
    a1be:	mov	r5, r1
    a1c0:	cbz	r1, a1da <Print::write(unsigned char const*, unsigned int)+0x20>
    a1c2:	adds	r6, r1, r2
    a1c4:	movs	r4, #0
	size_t count = 0;
	while (size--) count += write(*buffer++);
    a1c6:	cmp	r5, r6
    a1c8:	beq.n	a1de <Print::write(unsigned char const*, unsigned int)+0x24>
    a1ca:	ldr	r3, [r7, #0]
    a1cc:	ldrb.w	r1, [r5], #1
    a1d0:	ldr	r3, [r3, #0]
    a1d2:	mov	r0, r7
    a1d4:	blx	r3
    a1d6:	add	r4, r0
    a1d8:	b.n	a1c6 <Print::write(unsigned char const*, unsigned int)+0xc>
#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
	if (buffer == nullptr) return 0;
    a1da:	mov	r0, r1
    a1dc:	pop	{r3, r4, r5, r6, r7, pc}
    a1de:	mov	r0, r4
	size_t count = 0;
	while (size--) count += write(*buffer++);
	return count;
}
    a1e0:	pop	{r3, r4, r5, r6, r7, pc}
    a1e2:	Address 0x0000a1e2 is out of bounds.


0000a1e4 <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    a1e4:	push	{r0, r1, r2, lr}
	uint8_t buf[2]={'\r', '\n'};
    a1e6:	ldr	r3, [pc, #24]	; (a200 <Print::println()+0x1c>)
    a1e8:	ldrh	r3, [r3, #0]
    a1ea:	strh.w	r3, [sp, #4]
	return write(buf, 2);
    a1ee:	ldr	r3, [r0, #0]
    a1f0:	movs	r2, #2
    a1f2:	ldr	r3, [r3, #4]
    a1f4:	add	r1, sp, #4
    a1f6:	blx	r3
}
    a1f8:	add	sp, #12
    a1fa:	ldr.w	pc, [sp], #4
    a1fe:	nop
    a200:	.word	0x000130b0

0000a204 <Print::printf(char const*, ...)>:
	return len;
}
}

int Print::printf(const char *format, ...)
{
    a204:	push	{r1, r2, r3}
    a206:	push	{r0, r1, lr}
    a208:	add	r2, sp, #12
    a20a:	ldr.w	r1, [r2], #4
	va_list ap;
	va_start(ap, format);
    a20e:	str	r2, [sp, #4]
#ifdef __STRICT_ANSI__
	va_end(ap);
	return 0;  // TODO: make this work with -std=c++0x
#else
	int retval = vdprintf((int)this, format, ap);
    a210:	bl	f748 <vdprintf>
	va_end(ap);
	return retval;
#endif
}
    a214:	add	sp, #8
    a216:	ldr.w	lr, [sp], #4
    a21a:	add	sp, #12
    a21c:	bx	lr

0000a21e <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
}

#else

size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
{
    a21e:	push	{r4, r5, r6, lr}
    a220:	mov	r5, r0
    a222:	sub	sp, #40	; 0x28
	uint8_t digit, i;

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
    a224:	cbnz	r2, a230 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x12>
		return write((uint8_t)n);
    a226:	ldr	r3, [r0, #0]
    a228:	uxtb	r1, r1
    a22a:	ldr	r3, [r3, #0]
    a22c:	blx	r3
    a22e:	b.n	a290 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x72>
	} else if (base == 1) {
		base = 10;
    a230:	cmp	r2, #1
    a232:	it	eq
    a234:	moveq	r2, #10
	}


	if (n == 0) {
    a236:	cbz	r1, a23c <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x1e>
    a238:	movs	r0, #33	; 0x21
    a23a:	b.n	a246 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x28>
		buf[sizeof(buf) - 1] = '0';
    a23c:	movs	r2, #48	; 0x30
    a23e:	strb.w	r2, [sp, #37]	; 0x25
		i = sizeof(buf) - 1;
    a242:	movs	r0, #33	; 0x21
    a244:	b.n	a270 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x52>
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    a246:	udiv	r6, r1, r2
    a24a:	mls	r1, r2, r6, r1
    a24e:	uxtb	r4, r1
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a250:	cmp	r1, #9
    a252:	ite	ls
    a254:	addls.w	r1, r4, #48	; 0x30
    a258:	addhi.w	r1, r4, #55	; 0x37
    a25c:	add	r4, sp, #40	; 0x28
    a25e:	add	r4, r0
    a260:	uxtb	r1, r1
    a262:	strb.w	r1, [r4, #-36]
			n /= base;
			if (n == 0) break;
    a266:	mov	r1, r6
    a268:	cbz	r6, a270 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x52>
			i--;
    a26a:	subs	r0, #1
    a26c:	uxtb	r0, r0
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
    a26e:	b.n	a246 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x28>
			n /= base;
			if (n == 0) break;
			i--;
		}
	}
	if (sign) {
    a270:	cbz	r3, a280 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x62>
		i--;
    a272:	subs	r0, #1
    a274:	uxtb	r0, r0
		buf[i] = '-';
    a276:	add	r3, sp, #40	; 0x28
    a278:	add	r3, r0
    a27a:	movs	r2, #45	; 0x2d
    a27c:	strb.w	r2, [r3, #-36]
	}
	return write(buf + i, sizeof(buf) - i);
    a280:	ldr	r3, [r5, #0]
    a282:	add	r1, sp, #4
    a284:	rsb	r2, r0, #34	; 0x22
    a288:	add	r1, r0
    a28a:	ldr	r3, [r3, #4]
    a28c:	mov	r0, r5
    a28e:	blx	r3
}
    a290:	add	sp, #40	; 0x28
    a292:	pop	{r4, r5, r6, pc}

0000a294 <Print::print(long)>:

size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
    a294:	cmp	r1, #0
		sign = '-';
		n = -n;
    a296:	itte	lt
    a298:	neglt	r1, r1
size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
		sign = '-';
    a29a:	movlt	r3, #45	; 0x2d
}


size_t Print::print(long n)
{
	uint8_t sign=0;
    a29c:	movge	r3, #0

	if (n < 0) {
		sign = '-';
		n = -n;
	}
	return printNumber(n, 10, sign);
    a29e:	movs	r2, #10
    a2a0:	b.w	a21e <Print::printNumber(unsigned long, unsigned char, unsigned char)>

0000a2a4 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>:
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
    a2a4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a2a8:	sub	sp, #72	; 0x48
    a2aa:	mov	r5, r0
    a2ac:	ldrb.w	r8, [sp, #104]	; 0x68
    a2b0:	ldrb.w	sl, [sp, #108]	; 0x6c
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    a2b4:	cmp.w	r8, #1
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
    a2b8:	mov	r6, r2
    a2ba:	mov	r7, r3
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    a2bc:	bls.n	a342 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x9e>
	if (n == 0) {
    a2be:	orrs.w	r3, r6, r7
    a2c2:	beq.n	a2d0 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x2c>
    a2c4:	movs	r4, #65	; 0x41
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    a2c6:	uxtb.w	r8, r8
    a2ca:	mov.w	r9, #0
    a2ce:	b.n	a2da <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x36>
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    a2d0:	movs	r3, #48	; 0x30
    a2d2:	strb.w	r3, [sp, #69]	; 0x45
		i = sizeof(buf) - 1;
    a2d6:	movs	r4, #65	; 0x41
    a2d8:	b.n	a31c <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x78>
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    a2da:	mov	r0, r6
    a2dc:	mov	r1, r7
    a2de:	mov	r2, r8
    a2e0:	mov	r3, r9
    a2e2:	bl	af70 <__aeabi_uldivmod>
    a2e6:	mov	r1, r3
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a2e8:	cmp	r1, #0
    a2ea:	it	eq
    a2ec:	cmpeq	r2, #10
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    a2ee:	uxtb	r3, r2
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a2f0:	add	r2, sp, #72	; 0x48
    a2f2:	ite	cc
    a2f4:	addcc	r3, #48	; 0x30
    a2f6:	addcs	r3, #55	; 0x37
    a2f8:	add	r2, r4
    a2fa:	uxtb	r3, r3
    a2fc:	strb.w	r3, [r2, #-68]
			n /= base;
    a300:	mov	r0, r6
    a302:	mov	r3, r9
    a304:	mov	r1, r7
    a306:	mov	r2, r8
    a308:	bl	af70 <__aeabi_uldivmod>
    a30c:	mov	r6, r0
    a30e:	mov	r7, r1
			if (n == 0) break;
    a310:	orrs.w	r3, r6, r7
    a314:	beq.n	a31c <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x78>
			i--;
    a316:	subs	r4, #1
    a318:	uxtb	r4, r4
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
    a31a:	b.n	a2da <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x36>
			n /= base;
			if (n == 0) break;
			i--;
		}
	}
	if (sign) {
    a31c:	cmp.w	sl, #0
    a320:	beq.n	a330 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x8c>
		i--;
    a322:	subs	r4, #1
    a324:	uxtb	r4, r4
		buf[i] = '-';
    a326:	add	r3, sp, #72	; 0x48
    a328:	add	r3, r4
    a32a:	movs	r2, #45	; 0x2d
    a32c:	strb.w	r2, [r3, #-68]
	}
	return write(buf + i, sizeof(buf) - i);
    a330:	ldr	r3, [r5, #0]
    a332:	add	r1, sp, #4
    a334:	ldr	r3, [r3, #4]
    a336:	rsb	r2, r4, #66	; 0x42
    a33a:	add	r1, r4
    a33c:	mov	r0, r5
    a33e:	blx	r3
    a340:	b.n	a344 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0xa0>
size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    a342:	movs	r0, #0
	if (sign) {
		i--;
		buf[i] = '-';
	}
	return write(buf + i, sizeof(buf) - i);
}
    a344:	add	sp, #72	; 0x48
    a346:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000a34a <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    a34a:	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    a34c:	bl	7cc <setup>
	while (1) {
		loop();
    a350:	bl	858 <loop>
		yield();
    a354:	bl	9f7c <yield>
    a358:	b.n	a350 <main+0x6>
    a35a:	Address 0x0000a35a is out of bounds.


0000a35c <Stream::timedRead()>:
#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field

// private method to read stream with timeout
int Stream::timedRead()
{
    a35c:	push	{r0, r1, r4, r5, r6, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    a35e:	ldr	r3, [pc, #48]	; (a390 <Stream::timedRead()+0x34>)
    a360:	ldr	r2, [r3, #0]
    a362:	str	r2, [sp, #0]
	return ret;
    a364:	ldr	r6, [sp, #0]
    a366:	mov	r4, r0
    a368:	mov	r5, r3
  int c;
  unsigned long startMillis = millis();
  do {
    c = read();
    a36a:	ldr	r3, [r4, #0]
    a36c:	mov	r0, r4
    a36e:	ldr	r3, [r3, #20]
    a370:	blx	r3
    if (c >= 0) return c;
    a372:	cmp	r0, #0
    a374:	bge.n	a38c <Stream::timedRead()+0x30>
    yield();
    a376:	bl	9f7c <yield>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    a37a:	ldr	r3, [r5, #0]
    a37c:	str	r3, [sp, #4]
	return ret;
    a37e:	ldr	r3, [sp, #4]
// private method to read stream with timeout
int Stream::timedRead()
{
  int c;
  unsigned long startMillis = millis();
  do {
    a380:	ldr	r2, [r4, #8]
    a382:	subs	r3, r3, r6
    a384:	cmp	r3, r2
    a386:	bcc.n	a36a <Stream::timedRead()+0xe>
    c = read();
    if (c >= 0) return c;
    yield();
  } while(millis() - startMillis < _timeout);
  return -1;     // -1 indicates timeout
    a388:	mov.w	r0, #4294967295
}
    a38c:	add	sp, #8
    a38e:	pop	{r4, r5, r6, pc}
    a390:	.word	0x2001a6fc

0000a394 <Stream::readBytesUntil(char, char*, unsigned int)>:
// as readBytes with terminator character
// terminates if length characters have been read, timeout, or if the terminator character  detected
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
    a394:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    a398:	mov	r7, r0
    a39a:	mov	r9, r1
	if (buffer == nullptr) return 0;
    a39c:	mov	r5, r2
    a39e:	cbz	r2, a3ce <Stream::readBytesUntil(char, char*, unsigned int)+0x3a>
	if (length < 1) return 0;
    a3a0:	cbz	r3, a3d2 <Stream::readBytesUntil(char, char*, unsigned int)+0x3e>
	length--;
    a3a2:	add.w	r8, r3, #4294967295
    a3a6:	mov	r6, r2
    a3a8:	subs	r4, r6, r5
	size_t index = 0;
	while (index < length) {
    a3aa:	cmp	r8, r4
    a3ac:	bls.n	a3c8 <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
		int c = timedRead();
    a3ae:	mov	r0, r7
    a3b0:	bl	a35c <Stream::timedRead()>
		if (c == terminator) break;
    a3b4:	cmp	r0, r9
    a3b6:	beq.n	a3c8 <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
		if (c < 0) {
    a3b8:	cmp	r0, #0
    a3ba:	bge.n	a3c2 <Stream::readBytesUntil(char, char*, unsigned int)+0x2e>
	String readString(size_t max = 120);
	String readStringUntil(char terminator, size_t max = 120);
	int getReadError() { return read_error; }
	void clearReadError() { setReadError(0); }
  protected:
	void setReadError(int err = 1) { read_error = err; }
    a3bc:	movs	r3, #1
    a3be:	strb	r3, [r7, #12]
    a3c0:	b.n	a3c8 <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
			setReadError();
			break;
		}
		*buffer++ = (char)c;
    a3c2:	strb.w	r0, [r6], #1
{
	if (buffer == nullptr) return 0;
	if (length < 1) return 0;
	length--;
	size_t index = 0;
	while (index < length) {
    a3c6:	b.n	a3a8 <Stream::readBytesUntil(char, char*, unsigned int)+0x14>
			break;
		}
		*buffer++ = (char)c;
		index++;
	}
	*buffer = 0;
    a3c8:	movs	r3, #0
    a3ca:	strb	r3, [r6, #0]
	return index; // return number of characters, not including null terminator
    a3cc:	b.n	a3d4 <Stream::readBytesUntil(char, char*, unsigned int)+0x40>
// terminates if length characters have been read, timeout, or if the terminator character  detected
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
	if (buffer == nullptr) return 0;
    a3ce:	mov	r4, r2
    a3d0:	b.n	a3d4 <Stream::readBytesUntil(char, char*, unsigned int)+0x40>
    a3d2:	mov	r4, r3
		*buffer++ = (char)c;
		index++;
	}
	*buffer = 0;
	return index; // return number of characters, not including null terminator
}
    a3d4:	mov	r0, r4
    a3d6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0000a3da <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    a3da:	bx	lr

0000a3dc <operator new(unsigned int)>:
    a3dc:	b.w	b340 <malloc>

0000a3e0 <operator delete(void*, unsigned int)>:
    a3e0:	b.w	b350 <free>

0000a3e4 <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    a3e4:	push	{r4, lr}
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    a3e6:	ldr	r3, [pc, #128]	; (a468 <analog_init+0x84>)
    a3e8:	ldr	r0, [pc, #128]	; (a46c <analog_init+0x88>)
    a3ea:	ldr	r1, [pc, #132]	; (a470 <analog_init+0x8c>)
    a3ec:	movs	r2, #96	; 0x60
    a3ee:	strb	r2, [r3, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    a3f0:	movs	r2, #225	; 0xe1
    a3f2:	strb	r2, [r3, #1]
	#endif

	if (analog_config_bits == 8) {
    a3f4:	ldr	r3, [pc, #124]	; (a474 <analog_init+0x90>)
    a3f6:	ldr	r2, [pc, #128]	; (a478 <analog_init+0x94>)
    a3f8:	ldrb	r4, [r3, #0]
    a3fa:	ldr	r3, [pc, #128]	; (a47c <analog_init+0x98>)
    a3fc:	cmp	r4, #8
    a3fe:	bne.n	a404 <analog_init+0x20>
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    a400:	movs	r4, #1
    a402:	b.n	a40a <analog_init+0x26>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    a404:	cmp	r4, #10
    a406:	bne.n	a410 <analog_init+0x2c>
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    a408:	movs	r4, #57	; 0x39
    a40a:	str	r4, [r0, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    a40c:	movs	r0, #19
    a40e:	b.n	a41c <analog_init+0x38>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    a410:	cmp	r4, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    a412:	ite	eq
    a414:	moveq	r4, #53	; 0x35
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    a416:	movne	r4, #61	; 0x3d
    a418:	str	r4, [r0, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    a41a:	movs	r0, #18
    a41c:	str	r0, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    a41e:	str	r4, [r2, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    a420:	str	r0, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    a422:	ldr	r3, [pc, #92]	; (a480 <analog_init+0x9c>)
    a424:	ldr	r1, [pc, #92]	; (a484 <analog_init+0xa0>)
    a426:	ldrb	r3, [r3, #0]
    a428:	ldr	r2, [pc, #92]	; (a488 <analog_init+0xa4>)
    a42a:	cbz	r3, a42e <analog_init+0x4a>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    a42c:	movs	r3, #1
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    a42e:	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    a430:	str	r3, [r2, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    a432:	ldr	r3, [pc, #88]	; (a48c <analog_init+0xa8>)
    a434:	ldr	r2, [pc, #88]	; (a490 <analog_init+0xac>)
    a436:	ldrb	r1, [r3, #0]
    a438:	ldr	r3, [pc, #88]	; (a494 <analog_init+0xb0>)
	if (num <= 1) {
    a43a:	cmp	r1, #1
    a43c:	bhi.n	a442 <analog_init+0x5e>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    a43e:	movs	r1, #128	; 0x80
    a440:	b.n	a45a <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    a442:	cmp	r1, #4
    a444:	bhi.n	a44a <analog_init+0x66>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    a446:	movs	r1, #132	; 0x84
    a448:	b.n	a45a <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    a44a:	cmp	r1, #8
    a44c:	bhi.n	a452 <analog_init+0x6e>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    a44e:	movs	r1, #133	; 0x85
    a450:	b.n	a45a <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    a452:	cmp	r1, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    a454:	ite	ls
    a456:	movls	r1, #134	; 0x86
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    a458:	movhi	r1, #135	; 0x87
    a45a:	str	r1, [r2, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    a45c:	str	r1, [r3, #0]
		#endif
	}
	calibrating = 1;
    a45e:	ldr	r3, [pc, #56]	; (a498 <analog_init+0xb4>)
    a460:	movs	r2, #1
    a462:	strb	r2, [r3, #0]
    a464:	pop	{r4, pc}
    a466:	nop
    a468:	.word	0x40074000
    a46c:	.word	0x4003b008
    a470:	.word	0x4003b00c
    a474:	.word	0x1fff1359
    a478:	.word	0x400bb008
    a47c:	.word	0x400bb00c
    a480:	.word	0x2001a812
    a484:	.word	0x4003b020
    a488:	.word	0x400bb020
    a48c:	.word	0x1fff135a
    a490:	.word	0x4003b024
    a494:	.word	0x400bb024
    a498:	.word	0x2001a811

0000a49c <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    a49c:	push	{r0, r1, r2, r3, r4, lr}
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    a49e:	cpsid	i
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    a4a0:	ldr	r3, [pc, #76]	; (a4f0 <usb_init_serialnumber+0x54>)
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    a4a2:	ldr	r1, [pc, #80]	; (a4f4 <usb_init_serialnumber+0x58>)
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    a4a4:	movs	r2, #112	; 0x70
    a4a6:	strb	r2, [r3, #0]
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    a4a8:	ldr	r2, [pc, #76]	; (a4f8 <usb_init_serialnumber+0x5c>)
    a4aa:	str	r1, [r2, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    a4ac:	movs	r2, #128	; 0x80
    a4ae:	strb	r2, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    a4b0:	ldrb	r2, [r3, #0]
    a4b2:	lsls	r2, r2, #24
    a4b4:	bpl.n	a4b0 <usb_init_serialnumber+0x14>
	num = *(uint32_t *)&FTFL_FCCOBB;
    a4b6:	ldr	r3, [pc, #68]	; (a4fc <usb_init_serialnumber+0x60>)
    a4b8:	ldr	r0, [r3, #0]
	kinetis_hsrun_enable();
#endif
	__enable_irq();
    a4ba:	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    a4bc:	ldr	r3, [pc, #64]	; (a500 <usb_init_serialnumber+0x64>)
    a4be:	cmp	r0, r3
    a4c0:	it	ls
    a4c2:	movls	r3, #10
	ultoa(num, buf, 10);
    a4c4:	add	r4, sp, #4
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    a4c6:	it	ls
    a4c8:	mulls	r0, r3
	ultoa(num, buf, 10);
    a4ca:	movs	r2, #10
    a4cc:	mov	r1, r4
    a4ce:	bl	a50c <ultoa>
    a4d2:	ldr	r2, [pc, #48]	; (a504 <usb_init_serialnumber+0x68>)
	for (i=0; i<10; i++) {
    a4d4:	movs	r3, #0
		char c = buf[i];
    a4d6:	ldrb	r1, [r4, r3]
		if (!c) break;
    a4d8:	cbz	r1, a4e4 <usb_init_serialnumber+0x48>
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    a4da:	adds	r3, #1
    a4dc:	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    a4de:	strh.w	r1, [r2], #2
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    a4e2:	bne.n	a4d6 <usb_init_serialnumber+0x3a>
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    a4e4:	ldr	r2, [pc, #32]	; (a508 <usb_init_serialnumber+0x6c>)
    a4e6:	adds	r3, #1
    a4e8:	lsls	r3, r3, #1
    a4ea:	strb	r3, [r2, #0]
}
    a4ec:	add	sp, #16
    a4ee:	pop	{r4, pc}
    a4f0:	.word	0x40020000
    a4f4:	.word	0x41070000
    a4f8:	.word	0x40020004
    a4fc:	.word	0x4002000c
    a500:	.word	0x0098967f
    a504:	.word	0x1fff13e6
    a508:	.word	0x1fff13e4

0000a50c <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    a50c:	push	{r4, r5, lr}
    a50e:	mov	r3, r0
	unsigned digit;
	int i=0, j;
    a510:	movs	r0, #0
	char t;

	while (1) {
		digit = val % radix;
    a512:	udiv	r4, r3, r2
    a516:	mls	r3, r2, r4, r3
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a51a:	cmp	r3, #9
    a51c:	ite	ls
    a51e:	addls	r3, #48	; 0x30
    a520:	addhi	r3, #55	; 0x37
    a522:	uxtb	r3, r3
    a524:	strb	r3, [r1, r0]
		val /= radix;
		if (val == 0) break;
    a526:	mov	r3, r4
    a528:	cbz	r4, a52e <ultoa+0x22>
		i++;
    a52a:	adds	r0, #1
	}
    a52c:	b.n	a512 <ultoa+0x6>
	buf[i + 1] = 0;
    a52e:	adds	r2, r1, r0
	for (j=0; j < i; j++, i--) {
    a530:	mov	r3, r4
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
    a532:	strb	r4, [r2, #1]
	for (j=0; j < i; j++, i--) {
    a534:	subs	r4, r0, r3
    a536:	cmp	r3, r4
    a538:	bge.n	a548 <ultoa+0x3c>
		t = buf[j];
    a53a:	ldrb	r4, [r1, r3]
		buf[j] = buf[i];
    a53c:	ldrb	r5, [r2, #0]
    a53e:	strb	r5, [r1, r3]
		buf[i] = t;
    a540:	strb.w	r4, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    a544:	adds	r3, #1
    a546:	b.n	a534 <ultoa+0x28>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    a548:	mov	r0, r1
    a54a:	pop	{r4, r5, pc}

0000a54c <__aeabi_atexit>:
    a54c:	mov	r3, r1
    a54e:	mov	r1, r0
    a550:	mov	r0, r3
    a552:	b.w	b288 <__cxa_atexit>
    a556:	nop

0000a558 <__aeabi_llsr>:
    a558:	lsrs	r0, r2
    a55a:	adds	r3, r1, #0
    a55c:	lsrs	r1, r2
    a55e:	mov	ip, r3
    a560:	subs	r2, #32
    a562:	lsrs	r3, r2
    a564:	orrs	r0, r3
    a566:	negs	r2, r2
    a568:	mov	r3, ip
    a56a:	lsls	r3, r2
    a56c:	orrs	r0, r3
    a56e:	bx	lr

0000a570 <__aeabi_drsub>:
    a570:	eor.w	r1, r1, #2147483648	; 0x80000000
    a574:	b.n	a57c <__adddf3>
    a576:	nop

0000a578 <__aeabi_dsub>:
    a578:	eor.w	r3, r3, #2147483648	; 0x80000000

0000a57c <__adddf3>:
    a57c:	push	{r4, r5, lr}
    a57e:	mov.w	r4, r1, lsl #1
    a582:	mov.w	r5, r3, lsl #1
    a586:	teq	r4, r5
    a58a:	it	eq
    a58c:	teqeq	r0, r2
    a590:	itttt	ne
    a592:	orrsne.w	ip, r4, r0
    a596:	orrsne.w	ip, r5, r2
    a59a:	mvnsne.w	ip, r4, asr #21
    a59e:	mvnsne.w	ip, r5, asr #21
    a5a2:	beq.w	a76a <__adddf3+0x1ee>
    a5a6:	mov.w	r4, r4, lsr #21
    a5aa:	rsbs	r5, r4, r5, lsr #21
    a5ae:	it	lt
    a5b0:	neglt	r5, r5
    a5b2:	ble.n	a5ce <__adddf3+0x52>
    a5b4:	add	r4, r5
    a5b6:	eor.w	r2, r0, r2
    a5ba:	eor.w	r3, r1, r3
    a5be:	eor.w	r0, r2, r0
    a5c2:	eor.w	r1, r3, r1
    a5c6:	eor.w	r2, r0, r2
    a5ca:	eor.w	r3, r1, r3
    a5ce:	cmp	r5, #54	; 0x36
    a5d0:	it	hi
    a5d2:	pophi	{r4, r5, pc}
    a5d4:	tst.w	r1, #2147483648	; 0x80000000
    a5d8:	mov.w	r1, r1, lsl #12
    a5dc:	mov.w	ip, #1048576	; 0x100000
    a5e0:	orr.w	r1, ip, r1, lsr #12
    a5e4:	beq.n	a5ec <__adddf3+0x70>
    a5e6:	negs	r0, r0
    a5e8:	sbc.w	r1, r1, r1, lsl #1
    a5ec:	tst.w	r3, #2147483648	; 0x80000000
    a5f0:	mov.w	r3, r3, lsl #12
    a5f4:	orr.w	r3, ip, r3, lsr #12
    a5f8:	beq.n	a600 <__adddf3+0x84>
    a5fa:	negs	r2, r2
    a5fc:	sbc.w	r3, r3, r3, lsl #1
    a600:	teq	r4, r5
    a604:	beq.w	a756 <__adddf3+0x1da>
    a608:	sub.w	r4, r4, #1
    a60c:	rsbs	lr, r5, #32
    a610:	blt.n	a62e <__adddf3+0xb2>
    a612:	lsl.w	ip, r2, lr
    a616:	lsr.w	r2, r2, r5
    a61a:	adds	r0, r0, r2
    a61c:	adc.w	r1, r1, #0
    a620:	lsl.w	r2, r3, lr
    a624:	adds	r0, r0, r2
    a626:	asr.w	r3, r3, r5
    a62a:	adcs	r1, r3
    a62c:	b.n	a64c <__adddf3+0xd0>
    a62e:	sub.w	r5, r5, #32
    a632:	add.w	lr, lr, #32
    a636:	cmp	r2, #1
    a638:	lsl.w	ip, r3, lr
    a63c:	it	cs
    a63e:	orrcs.w	ip, ip, #2
    a642:	asr.w	r3, r3, r5
    a646:	adds	r0, r0, r3
    a648:	adcs.w	r1, r1, r3, asr #31
    a64c:	and.w	r5, r1, #2147483648	; 0x80000000
    a650:	bpl.n	a662 <__adddf3+0xe6>
    a652:	mov.w	lr, #0
    a656:	rsbs	ip, ip, #0
    a65a:	sbcs.w	r0, lr, r0
    a65e:	sbc.w	r1, lr, r1
    a662:	cmp.w	r1, #1048576	; 0x100000
    a666:	bcc.n	a6a0 <__adddf3+0x124>
    a668:	cmp.w	r1, #2097152	; 0x200000
    a66c:	bcc.n	a688 <__adddf3+0x10c>
    a66e:	lsrs	r1, r1, #1
    a670:	movs.w	r0, r0, rrx
    a674:	mov.w	ip, ip, rrx
    a678:	add.w	r4, r4, #1
    a67c:	mov.w	r2, r4, lsl #21
    a680:	cmn.w	r2, #4194304	; 0x400000
    a684:	bcs.w	a7bc <__adddf3+0x240>
    a688:	cmp.w	ip, #2147483648	; 0x80000000
    a68c:	it	eq
    a68e:	movseq.w	ip, r0, lsr #1
    a692:	adcs.w	r0, r0, #0
    a696:	adc.w	r1, r1, r4, lsl #20
    a69a:	orr.w	r1, r1, r5
    a69e:	pop	{r4, r5, pc}
    a6a0:	movs.w	ip, ip, lsl #1
    a6a4:	adcs	r0, r0
    a6a6:	adc.w	r1, r1, r1
    a6aa:	tst.w	r1, #1048576	; 0x100000
    a6ae:	sub.w	r4, r4, #1
    a6b2:	bne.n	a688 <__adddf3+0x10c>
    a6b4:	teq	r1, #0
    a6b8:	itt	eq
    a6ba:	moveq	r1, r0
    a6bc:	moveq	r0, #0
    a6be:	clz	r3, r1
    a6c2:	it	eq
    a6c4:	addeq	r3, #32
    a6c6:	sub.w	r3, r3, #11
    a6ca:	subs.w	r2, r3, #32
    a6ce:	bge.n	a6ea <__adddf3+0x16e>
    a6d0:	adds	r2, #12
    a6d2:	ble.n	a6e6 <__adddf3+0x16a>
    a6d4:	add.w	ip, r2, #20
    a6d8:	rsb	r2, r2, #12
    a6dc:	lsl.w	r0, r1, ip
    a6e0:	lsr.w	r1, r1, r2
    a6e4:	b.n	a700 <__adddf3+0x184>
    a6e6:	add.w	r2, r2, #20
    a6ea:	it	le
    a6ec:	rsble	ip, r2, #32
    a6f0:	lsl.w	r1, r1, r2
    a6f4:	lsr.w	ip, r0, ip
    a6f8:	itt	le
    a6fa:	orrle.w	r1, r1, ip
    a6fe:	lslle	r0, r2
    a700:	subs	r4, r4, r3
    a702:	ittt	ge
    a704:	addge.w	r1, r1, r4, lsl #20
    a708:	orrge	r1, r5
    a70a:	popge	{r4, r5, pc}
    a70c:	mvn.w	r4, r4
    a710:	subs	r4, #31
    a712:	bge.n	a74e <__adddf3+0x1d2>
    a714:	adds	r4, #12
    a716:	bgt.n	a736 <__adddf3+0x1ba>
    a718:	add.w	r4, r4, #20
    a71c:	rsb	r2, r4, #32
    a720:	lsr.w	r0, r0, r4
    a724:	lsl.w	r3, r1, r2
    a728:	orr.w	r0, r0, r3
    a72c:	lsr.w	r3, r1, r4
    a730:	orr.w	r1, r5, r3
    a734:	pop	{r4, r5, pc}
    a736:	rsb	r4, r4, #12
    a73a:	rsb	r2, r4, #32
    a73e:	lsr.w	r0, r0, r2
    a742:	lsl.w	r3, r1, r4
    a746:	orr.w	r0, r0, r3
    a74a:	mov	r1, r5
    a74c:	pop	{r4, r5, pc}
    a74e:	lsr.w	r0, r1, r4
    a752:	mov	r1, r5
    a754:	pop	{r4, r5, pc}
    a756:	teq	r4, #0
    a75a:	eor.w	r3, r3, #1048576	; 0x100000
    a75e:	itte	eq
    a760:	eoreq.w	r1, r1, #1048576	; 0x100000
    a764:	addeq	r4, #1
    a766:	subne	r5, #1
    a768:	b.n	a608 <__adddf3+0x8c>
    a76a:	mvns.w	ip, r4, asr #21
    a76e:	it	ne
    a770:	mvnsne.w	ip, r5, asr #21
    a774:	beq.n	a7ca <__adddf3+0x24e>
    a776:	teq	r4, r5
    a77a:	it	eq
    a77c:	teqeq	r0, r2
    a780:	beq.n	a78e <__adddf3+0x212>
    a782:	orrs.w	ip, r4, r0
    a786:	itt	eq
    a788:	moveq	r1, r3
    a78a:	moveq	r0, r2
    a78c:	pop	{r4, r5, pc}
    a78e:	teq	r1, r3
    a792:	ittt	ne
    a794:	movne	r1, #0
    a796:	movne	r0, #0
    a798:	popne	{r4, r5, pc}
    a79a:	movs.w	ip, r4, lsr #21
    a79e:	bne.n	a7ac <__adddf3+0x230>
    a7a0:	lsls	r0, r0, #1
    a7a2:	adcs	r1, r1
    a7a4:	it	cs
    a7a6:	orrcs.w	r1, r1, #2147483648	; 0x80000000
    a7aa:	pop	{r4, r5, pc}
    a7ac:	adds.w	r4, r4, #4194304	; 0x400000
    a7b0:	itt	cc
    a7b2:	addcc.w	r1, r1, #1048576	; 0x100000
    a7b6:	popcc	{r4, r5, pc}
    a7b8:	and.w	r5, r1, #2147483648	; 0x80000000
    a7bc:	orr.w	r1, r5, #2130706432	; 0x7f000000
    a7c0:	orr.w	r1, r1, #15728640	; 0xf00000
    a7c4:	mov.w	r0, #0
    a7c8:	pop	{r4, r5, pc}
    a7ca:	mvns.w	ip, r4, asr #21
    a7ce:	itte	ne
    a7d0:	movne	r1, r3
    a7d2:	movne	r0, r2
    a7d4:	mvnseq.w	ip, r5, asr #21
    a7d8:	itt	ne
    a7da:	movne	r3, r1
    a7dc:	movne	r2, r0
    a7de:	orrs.w	r4, r0, r1, lsl #12
    a7e2:	itte	eq
    a7e4:	orrseq.w	r5, r2, r3, lsl #12
    a7e8:	teqeq	r1, r3
    a7ec:	orrne.w	r1, r1, #524288	; 0x80000
    a7f0:	pop	{r4, r5, pc}
    a7f2:	nop

0000a7f4 <__aeabi_ui2d>:
    a7f4:	teq	r0, #0
    a7f8:	itt	eq
    a7fa:	moveq	r1, #0
    a7fc:	bxeq	lr
    a7fe:	push	{r4, r5, lr}
    a800:	mov.w	r4, #1024	; 0x400
    a804:	add.w	r4, r4, #50	; 0x32
    a808:	mov.w	r5, #0
    a80c:	mov.w	r1, #0
    a810:	b.n	a6b4 <__adddf3+0x138>
    a812:	nop

0000a814 <__aeabi_i2d>:
    a814:	teq	r0, #0
    a818:	itt	eq
    a81a:	moveq	r1, #0
    a81c:	bxeq	lr
    a81e:	push	{r4, r5, lr}
    a820:	mov.w	r4, #1024	; 0x400
    a824:	add.w	r4, r4, #50	; 0x32
    a828:	ands.w	r5, r0, #2147483648	; 0x80000000
    a82c:	it	mi
    a82e:	negmi	r0, r0
    a830:	mov.w	r1, #0
    a834:	b.n	a6b4 <__adddf3+0x138>
    a836:	nop

0000a838 <__aeabi_f2d>:
    a838:	lsls	r2, r0, #1
    a83a:	mov.w	r1, r2, asr #3
    a83e:	mov.w	r1, r1, rrx
    a842:	mov.w	r0, r2, lsl #28
    a846:	itttt	ne
    a848:	andsne.w	r3, r2, #4278190080	; 0xff000000
    a84c:	teqne	r3, #4278190080	; 0xff000000
    a850:	eorne.w	r1, r1, #939524096	; 0x38000000
    a854:	bxne	lr
    a856:	teq	r2, #0
    a85a:	ite	ne
    a85c:	teqne	r3, #4278190080	; 0xff000000
    a860:	bxeq	lr
    a862:	push	{r4, r5, lr}
    a864:	mov.w	r4, #896	; 0x380
    a868:	and.w	r5, r1, #2147483648	; 0x80000000
    a86c:	bic.w	r1, r1, #2147483648	; 0x80000000
    a870:	b.n	a6b4 <__adddf3+0x138>
    a872:	nop

0000a874 <__aeabi_ul2d>:
    a874:	orrs.w	r2, r0, r1
    a878:	it	eq
    a87a:	bxeq	lr
    a87c:	push	{r4, r5, lr}
    a87e:	mov.w	r5, #0
    a882:	b.n	a89a <__aeabi_l2d+0x16>

0000a884 <__aeabi_l2d>:
    a884:	orrs.w	r2, r0, r1
    a888:	it	eq
    a88a:	bxeq	lr
    a88c:	push	{r4, r5, lr}
    a88e:	ands.w	r5, r1, #2147483648	; 0x80000000
    a892:	bpl.n	a89a <__aeabi_l2d+0x16>
    a894:	negs	r0, r0
    a896:	sbc.w	r1, r1, r1, lsl #1
    a89a:	mov.w	r4, #1024	; 0x400
    a89e:	add.w	r4, r4, #50	; 0x32
    a8a2:	movs.w	ip, r1, lsr #22
    a8a6:	beq.w	a662 <__adddf3+0xe6>
    a8aa:	mov.w	r2, #3
    a8ae:	movs.w	ip, ip, lsr #3
    a8b2:	it	ne
    a8b4:	addne	r2, #3
    a8b6:	movs.w	ip, ip, lsr #3
    a8ba:	it	ne
    a8bc:	addne	r2, #3
    a8be:	add.w	r2, r2, ip, lsr #3
    a8c2:	rsb	r3, r2, #32
    a8c6:	lsl.w	ip, r0, r3
    a8ca:	lsr.w	r0, r0, r2
    a8ce:	lsl.w	lr, r1, r3
    a8d2:	orr.w	r0, r0, lr
    a8d6:	lsr.w	r1, r1, r2
    a8da:	add	r4, r2
    a8dc:	b.n	a662 <__adddf3+0xe6>
    a8de:	nop

0000a8e0 <__aeabi_dmul>:
    a8e0:	push	{r4, r5, r6, lr}
    a8e2:	mov.w	ip, #255	; 0xff
    a8e6:	orr.w	ip, ip, #1792	; 0x700
    a8ea:	ands.w	r4, ip, r1, lsr #20
    a8ee:	ittte	ne
    a8f0:	andsne.w	r5, ip, r3, lsr #20
    a8f4:	teqne	r4, ip
    a8f8:	teqne	r5, ip
    a8fc:	bleq	aabc <__aeabi_dmul+0x1dc>
    a900:	add	r4, r5
    a902:	eor.w	r6, r1, r3
    a906:	bic.w	r1, r1, ip, lsl #21
    a90a:	bic.w	r3, r3, ip, lsl #21
    a90e:	orrs.w	r5, r0, r1, lsl #12
    a912:	it	ne
    a914:	orrsne.w	r5, r2, r3, lsl #12
    a918:	orr.w	r1, r1, #1048576	; 0x100000
    a91c:	orr.w	r3, r3, #1048576	; 0x100000
    a920:	beq.n	a994 <__aeabi_dmul+0xb4>
    a922:	umull	ip, lr, r0, r2
    a926:	mov.w	r5, #0
    a92a:	umlal	lr, r5, r1, r2
    a92e:	and.w	r2, r6, #2147483648	; 0x80000000
    a932:	umlal	lr, r5, r0, r3
    a936:	mov.w	r6, #0
    a93a:	umlal	r5, r6, r1, r3
    a93e:	teq	ip, #0
    a942:	it	ne
    a944:	orrne.w	lr, lr, #1
    a948:	sub.w	r4, r4, #255	; 0xff
    a94c:	cmp.w	r6, #512	; 0x200
    a950:	sbc.w	r4, r4, #768	; 0x300
    a954:	bcs.n	a960 <__aeabi_dmul+0x80>
    a956:	movs.w	lr, lr, lsl #1
    a95a:	adcs	r5, r5
    a95c:	adc.w	r6, r6, r6
    a960:	orr.w	r1, r2, r6, lsl #11
    a964:	orr.w	r1, r1, r5, lsr #21
    a968:	mov.w	r0, r5, lsl #11
    a96c:	orr.w	r0, r0, lr, lsr #21
    a970:	mov.w	lr, lr, lsl #11
    a974:	subs.w	ip, r4, #253	; 0xfd
    a978:	it	hi
    a97a:	cmphi.w	ip, #1792	; 0x700
    a97e:	bhi.n	a9be <__aeabi_dmul+0xde>
    a980:	cmp.w	lr, #2147483648	; 0x80000000
    a984:	it	eq
    a986:	movseq.w	lr, r0, lsr #1
    a98a:	adcs.w	r0, r0, #0
    a98e:	adc.w	r1, r1, r4, lsl #20
    a992:	pop	{r4, r5, r6, pc}
    a994:	and.w	r6, r6, #2147483648	; 0x80000000
    a998:	orr.w	r1, r6, r1
    a99c:	orr.w	r0, r0, r2
    a9a0:	eor.w	r1, r1, r3
    a9a4:	subs.w	r4, r4, ip, lsr #1
    a9a8:	ittt	gt
    a9aa:	rsbsgt	r5, r4, ip
    a9ae:	orrgt.w	r1, r1, r4, lsl #20
    a9b2:	popgt	{r4, r5, r6, pc}
    a9b4:	orr.w	r1, r1, #1048576	; 0x100000
    a9b8:	mov.w	lr, #0
    a9bc:	subs	r4, #1
    a9be:	bgt.w	ab18 <__aeabi_dmul+0x238>
    a9c2:	cmn.w	r4, #54	; 0x36
    a9c6:	ittt	le
    a9c8:	movle	r0, #0
    a9ca:	andle.w	r1, r1, #2147483648	; 0x80000000
    a9ce:	pople	{r4, r5, r6, pc}
    a9d0:	rsb	r4, r4, #0
    a9d4:	subs	r4, #32
    a9d6:	bge.n	aa44 <__aeabi_dmul+0x164>
    a9d8:	adds	r4, #12
    a9da:	bgt.n	aa14 <__aeabi_dmul+0x134>
    a9dc:	add.w	r4, r4, #20
    a9e0:	rsb	r5, r4, #32
    a9e4:	lsl.w	r3, r0, r5
    a9e8:	lsr.w	r0, r0, r4
    a9ec:	lsl.w	r2, r1, r5
    a9f0:	orr.w	r0, r0, r2
    a9f4:	and.w	r2, r1, #2147483648	; 0x80000000
    a9f8:	bic.w	r1, r1, #2147483648	; 0x80000000
    a9fc:	adds.w	r0, r0, r3, lsr #31
    aa00:	lsr.w	r6, r1, r4
    aa04:	adc.w	r1, r2, r6
    aa08:	orrs.w	lr, lr, r3, lsl #1
    aa0c:	it	eq
    aa0e:	biceq.w	r0, r0, r3, lsr #31
    aa12:	pop	{r4, r5, r6, pc}
    aa14:	rsb	r4, r4, #12
    aa18:	rsb	r5, r4, #32
    aa1c:	lsl.w	r3, r0, r4
    aa20:	lsr.w	r0, r0, r5
    aa24:	lsl.w	r2, r1, r4
    aa28:	orr.w	r0, r0, r2
    aa2c:	and.w	r1, r1, #2147483648	; 0x80000000
    aa30:	adds.w	r0, r0, r3, lsr #31
    aa34:	adc.w	r1, r1, #0
    aa38:	orrs.w	lr, lr, r3, lsl #1
    aa3c:	it	eq
    aa3e:	biceq.w	r0, r0, r3, lsr #31
    aa42:	pop	{r4, r5, r6, pc}
    aa44:	rsb	r5, r4, #32
    aa48:	lsl.w	r2, r0, r5
    aa4c:	orr.w	lr, lr, r2
    aa50:	lsr.w	r3, r0, r4
    aa54:	lsl.w	r2, r1, r5
    aa58:	orr.w	r3, r3, r2
    aa5c:	lsr.w	r0, r1, r4
    aa60:	and.w	r1, r1, #2147483648	; 0x80000000
    aa64:	lsr.w	r2, r1, r4
    aa68:	bic.w	r0, r0, r2
    aa6c:	add.w	r0, r0, r3, lsr #31
    aa70:	orrs.w	lr, lr, r3, lsl #1
    aa74:	it	eq
    aa76:	biceq.w	r0, r0, r3, lsr #31
    aa7a:	pop	{r4, r5, r6, pc}
    aa7c:	teq	r4, #0
    aa80:	bne.n	aaa2 <__aeabi_dmul+0x1c2>
    aa82:	and.w	r6, r1, #2147483648	; 0x80000000
    aa86:	lsls	r0, r0, #1
    aa88:	adc.w	r1, r1, r1
    aa8c:	tst.w	r1, #1048576	; 0x100000
    aa90:	it	eq
    aa92:	subeq	r4, #1
    aa94:	beq.n	aa86 <__aeabi_dmul+0x1a6>
    aa96:	orr.w	r1, r1, r6
    aa9a:	teq	r5, #0
    aa9e:	it	ne
    aaa0:	bxne	lr
    aaa2:	and.w	r6, r3, #2147483648	; 0x80000000
    aaa6:	lsls	r2, r2, #1
    aaa8:	adc.w	r3, r3, r3
    aaac:	tst.w	r3, #1048576	; 0x100000
    aab0:	it	eq
    aab2:	subeq	r5, #1
    aab4:	beq.n	aaa6 <__aeabi_dmul+0x1c6>
    aab6:	orr.w	r3, r3, r6
    aaba:	bx	lr
    aabc:	teq	r4, ip
    aac0:	and.w	r5, ip, r3, lsr #20
    aac4:	it	ne
    aac6:	teqne	r5, ip
    aaca:	beq.n	aae6 <__aeabi_dmul+0x206>
    aacc:	orrs.w	r6, r0, r1, lsl #1
    aad0:	it	ne
    aad2:	orrsne.w	r6, r2, r3, lsl #1
    aad6:	bne.n	aa7c <__aeabi_dmul+0x19c>
    aad8:	eor.w	r1, r1, r3
    aadc:	and.w	r1, r1, #2147483648	; 0x80000000
    aae0:	mov.w	r0, #0
    aae4:	pop	{r4, r5, r6, pc}
    aae6:	orrs.w	r6, r0, r1, lsl #1
    aaea:	itte	eq
    aaec:	moveq	r0, r2
    aaee:	moveq	r1, r3
    aaf0:	orrsne.w	r6, r2, r3, lsl #1
    aaf4:	beq.n	ab2a <__aeabi_dmul+0x24a>
    aaf6:	teq	r4, ip
    aafa:	bne.n	ab02 <__aeabi_dmul+0x222>
    aafc:	orrs.w	r6, r0, r1, lsl #12
    ab00:	bne.n	ab2a <__aeabi_dmul+0x24a>
    ab02:	teq	r5, ip
    ab06:	bne.n	ab14 <__aeabi_dmul+0x234>
    ab08:	orrs.w	r6, r2, r3, lsl #12
    ab0c:	itt	ne
    ab0e:	movne	r0, r2
    ab10:	movne	r1, r3
    ab12:	bne.n	ab2a <__aeabi_dmul+0x24a>
    ab14:	eor.w	r1, r1, r3
    ab18:	and.w	r1, r1, #2147483648	; 0x80000000
    ab1c:	orr.w	r1, r1, #2130706432	; 0x7f000000
    ab20:	orr.w	r1, r1, #15728640	; 0xf00000
    ab24:	mov.w	r0, #0
    ab28:	pop	{r4, r5, r6, pc}
    ab2a:	orr.w	r1, r1, #2130706432	; 0x7f000000
    ab2e:	orr.w	r1, r1, #16252928	; 0xf80000
    ab32:	pop	{r4, r5, r6, pc}

0000ab34 <__aeabi_ddiv>:
    ab34:	push	{r4, r5, r6, lr}
    ab36:	mov.w	ip, #255	; 0xff
    ab3a:	orr.w	ip, ip, #1792	; 0x700
    ab3e:	ands.w	r4, ip, r1, lsr #20
    ab42:	ittte	ne
    ab44:	andsne.w	r5, ip, r3, lsr #20
    ab48:	teqne	r4, ip
    ab4c:	teqne	r5, ip
    ab50:	bleq	aca2 <__aeabi_ddiv+0x16e>
    ab54:	sub.w	r4, r4, r5
    ab58:	eor.w	lr, r1, r3
    ab5c:	orrs.w	r5, r2, r3, lsl #12
    ab60:	mov.w	r1, r1, lsl #12
    ab64:	beq.w	ac78 <__aeabi_ddiv+0x144>
    ab68:	mov.w	r3, r3, lsl #12
    ab6c:	mov.w	r5, #268435456	; 0x10000000
    ab70:	orr.w	r3, r5, r3, lsr #4
    ab74:	orr.w	r3, r3, r2, lsr #24
    ab78:	mov.w	r2, r2, lsl #8
    ab7c:	orr.w	r5, r5, r1, lsr #4
    ab80:	orr.w	r5, r5, r0, lsr #24
    ab84:	mov.w	r6, r0, lsl #8
    ab88:	and.w	r1, lr, #2147483648	; 0x80000000
    ab8c:	cmp	r5, r3
    ab8e:	it	eq
    ab90:	cmpeq	r6, r2
    ab92:	adc.w	r4, r4, #253	; 0xfd
    ab96:	add.w	r4, r4, #768	; 0x300
    ab9a:	bcs.n	aba2 <__aeabi_ddiv+0x6e>
    ab9c:	lsrs	r3, r3, #1
    ab9e:	mov.w	r2, r2, rrx
    aba2:	subs	r6, r6, r2
    aba4:	sbc.w	r5, r5, r3
    aba8:	lsrs	r3, r3, #1
    abaa:	mov.w	r2, r2, rrx
    abae:	mov.w	r0, #1048576	; 0x100000
    abb2:	mov.w	ip, #524288	; 0x80000
    abb6:	subs.w	lr, r6, r2
    abba:	sbcs.w	lr, r5, r3
    abbe:	ittt	cs
    abc0:	subcs	r6, r6, r2
    abc2:	movcs	r5, lr
    abc4:	orrcs.w	r0, r0, ip
    abc8:	lsrs	r3, r3, #1
    abca:	mov.w	r2, r2, rrx
    abce:	subs.w	lr, r6, r2
    abd2:	sbcs.w	lr, r5, r3
    abd6:	ittt	cs
    abd8:	subcs	r6, r6, r2
    abda:	movcs	r5, lr
    abdc:	orrcs.w	r0, r0, ip, lsr #1
    abe0:	lsrs	r3, r3, #1
    abe2:	mov.w	r2, r2, rrx
    abe6:	subs.w	lr, r6, r2
    abea:	sbcs.w	lr, r5, r3
    abee:	ittt	cs
    abf0:	subcs	r6, r6, r2
    abf2:	movcs	r5, lr
    abf4:	orrcs.w	r0, r0, ip, lsr #2
    abf8:	lsrs	r3, r3, #1
    abfa:	mov.w	r2, r2, rrx
    abfe:	subs.w	lr, r6, r2
    ac02:	sbcs.w	lr, r5, r3
    ac06:	ittt	cs
    ac08:	subcs	r6, r6, r2
    ac0a:	movcs	r5, lr
    ac0c:	orrcs.w	r0, r0, ip, lsr #3
    ac10:	orrs.w	lr, r5, r6
    ac14:	beq.n	ac48 <__aeabi_ddiv+0x114>
    ac16:	mov.w	r5, r5, lsl #4
    ac1a:	orr.w	r5, r5, r6, lsr #28
    ac1e:	mov.w	r6, r6, lsl #4
    ac22:	mov.w	r3, r3, lsl #3
    ac26:	orr.w	r3, r3, r2, lsr #29
    ac2a:	mov.w	r2, r2, lsl #3
    ac2e:	movs.w	ip, ip, lsr #4
    ac32:	bne.n	abb6 <__aeabi_ddiv+0x82>
    ac34:	tst.w	r1, #1048576	; 0x100000
    ac38:	bne.n	ac52 <__aeabi_ddiv+0x11e>
    ac3a:	orr.w	r1, r1, r0
    ac3e:	mov.w	r0, #0
    ac42:	mov.w	ip, #2147483648	; 0x80000000
    ac46:	b.n	abb6 <__aeabi_ddiv+0x82>
    ac48:	tst.w	r1, #1048576	; 0x100000
    ac4c:	itt	eq
    ac4e:	orreq	r1, r0
    ac50:	moveq	r0, #0
    ac52:	subs.w	ip, r4, #253	; 0xfd
    ac56:	it	hi
    ac58:	cmphi.w	ip, #1792	; 0x700
    ac5c:	bhi.w	a9be <__aeabi_dmul+0xde>
    ac60:	subs.w	ip, r5, r3
    ac64:	itt	eq
    ac66:	subseq.w	ip, r6, r2
    ac6a:	movseq.w	ip, r0, lsr #1
    ac6e:	adcs.w	r0, r0, #0
    ac72:	adc.w	r1, r1, r4, lsl #20
    ac76:	pop	{r4, r5, r6, pc}
    ac78:	and.w	lr, lr, #2147483648	; 0x80000000
    ac7c:	orr.w	r1, lr, r1, lsr #12
    ac80:	adds.w	r4, r4, ip, lsr #1
    ac84:	ittt	gt
    ac86:	rsbsgt	r5, r4, ip
    ac8a:	orrgt.w	r1, r1, r4, lsl #20
    ac8e:	popgt	{r4, r5, r6, pc}
    ac90:	orr.w	r1, r1, #1048576	; 0x100000
    ac94:	mov.w	lr, #0
    ac98:	subs	r4, #1
    ac9a:	b.n	a9be <__aeabi_dmul+0xde>
    ac9c:	orr.w	lr, r5, r6
    aca0:	b.n	a9be <__aeabi_dmul+0xde>
    aca2:	and.w	r5, ip, r3, lsr #20
    aca6:	teq	r4, ip
    acaa:	it	eq
    acac:	teqeq	r5, ip
    acb0:	beq.w	ab2a <__aeabi_dmul+0x24a>
    acb4:	teq	r4, ip
    acb8:	bne.n	acd0 <__aeabi_ddiv+0x19c>
    acba:	orrs.w	r4, r0, r1, lsl #12
    acbe:	bne.w	ab2a <__aeabi_dmul+0x24a>
    acc2:	teq	r5, ip
    acc6:	bne.w	ab14 <__aeabi_dmul+0x234>
    acca:	mov	r0, r2
    accc:	mov	r1, r3
    acce:	b.n	ab2a <__aeabi_dmul+0x24a>
    acd0:	teq	r5, ip
    acd4:	bne.n	ace4 <__aeabi_ddiv+0x1b0>
    acd6:	orrs.w	r5, r2, r3, lsl #12
    acda:	beq.w	aad8 <__aeabi_dmul+0x1f8>
    acde:	mov	r0, r2
    ace0:	mov	r1, r3
    ace2:	b.n	ab2a <__aeabi_dmul+0x24a>
    ace4:	orrs.w	r6, r0, r1, lsl #1
    ace8:	it	ne
    acea:	orrsne.w	r6, r2, r3, lsl #1
    acee:	bne.w	aa7c <__aeabi_dmul+0x19c>
    acf2:	orrs.w	r4, r0, r1, lsl #1
    acf6:	bne.w	ab14 <__aeabi_dmul+0x234>
    acfa:	orrs.w	r5, r2, r3, lsl #1
    acfe:	bne.w	aad8 <__aeabi_dmul+0x1f8>
    ad02:	b.n	ab2a <__aeabi_dmul+0x24a>

0000ad04 <__gedf2>:
    ad04:	mov.w	ip, #4294967295
    ad08:	b.n	ad18 <__cmpdf2+0x4>
    ad0a:	nop

0000ad0c <__ledf2>:
    ad0c:	mov.w	ip, #1
    ad10:	b.n	ad18 <__cmpdf2+0x4>
    ad12:	nop

0000ad14 <__cmpdf2>:
    ad14:	mov.w	ip, #1
    ad18:	str.w	ip, [sp, #-4]!
    ad1c:	mov.w	ip, r1, lsl #1
    ad20:	mvns.w	ip, ip, asr #21
    ad24:	mov.w	ip, r3, lsl #1
    ad28:	it	ne
    ad2a:	mvnsne.w	ip, ip, asr #21
    ad2e:	beq.n	ad68 <__cmpdf2+0x54>
    ad30:	add	sp, #4
    ad32:	orrs.w	ip, r0, r1, lsl #1
    ad36:	ite	eq
    ad38:	orrseq.w	ip, r2, r3, lsl #1
    ad3c:	teqne	r1, r3
    ad40:	ittt	eq
    ad42:	teqeq	r0, r2
    ad46:	moveq	r0, #0
    ad48:	bxeq	lr
    ad4a:	cmn.w	r0, #0
    ad4e:	teq	r1, r3
    ad52:	it	pl
    ad54:	cmppl	r1, r3
    ad56:	it	eq
    ad58:	cmpeq	r0, r2
    ad5a:	ite	cs
    ad5c:	asrcs	r0, r3, #31
    ad5e:	mvncc.w	r0, r3, asr #31
    ad62:	orr.w	r0, r0, #1
    ad66:	bx	lr
    ad68:	mov.w	ip, r1, lsl #1
    ad6c:	mvns.w	ip, ip, asr #21
    ad70:	bne.n	ad78 <__cmpdf2+0x64>
    ad72:	orrs.w	ip, r0, r1, lsl #12
    ad76:	bne.n	ad88 <__cmpdf2+0x74>
    ad78:	mov.w	ip, r3, lsl #1
    ad7c:	mvns.w	ip, ip, asr #21
    ad80:	bne.n	ad30 <__cmpdf2+0x1c>
    ad82:	orrs.w	ip, r2, r3, lsl #12
    ad86:	beq.n	ad30 <__cmpdf2+0x1c>
    ad88:	ldr.w	r0, [sp], #4
    ad8c:	bx	lr
    ad8e:	nop

0000ad90 <__aeabi_cdrcmple>:
    ad90:	mov	ip, r0
    ad92:	mov	r0, r2
    ad94:	mov	r2, ip
    ad96:	mov	ip, r1
    ad98:	mov	r1, r3
    ad9a:	mov	r3, ip
    ad9c:	b.n	ada0 <__aeabi_cdcmpeq>
    ad9e:	nop

0000ada0 <__aeabi_cdcmpeq>:
    ada0:	push	{r0, lr}
    ada2:	bl	ad14 <__cmpdf2>
    ada6:	cmp	r0, #0
    ada8:	it	mi
    adaa:	cmnmi.w	r0, #0
    adae:	pop	{r0, pc}

0000adb0 <__aeabi_dcmpeq>:
    adb0:	str.w	lr, [sp, #-8]!
    adb4:	bl	ada0 <__aeabi_cdcmpeq>
    adb8:	ite	eq
    adba:	moveq	r0, #1
    adbc:	movne	r0, #0
    adbe:	ldr.w	pc, [sp], #8
    adc2:	nop

0000adc4 <__aeabi_dcmplt>:
    adc4:	str.w	lr, [sp, #-8]!
    adc8:	bl	ada0 <__aeabi_cdcmpeq>
    adcc:	ite	cc
    adce:	movcc	r0, #1
    add0:	movcs	r0, #0
    add2:	ldr.w	pc, [sp], #8
    add6:	nop

0000add8 <__aeabi_dcmple>:
    add8:	str.w	lr, [sp, #-8]!
    addc:	bl	ada0 <__aeabi_cdcmpeq>
    ade0:	ite	ls
    ade2:	movls	r0, #1
    ade4:	movhi	r0, #0
    ade6:	ldr.w	pc, [sp], #8
    adea:	nop

0000adec <__aeabi_dcmpge>:
    adec:	str.w	lr, [sp, #-8]!
    adf0:	bl	ad90 <__aeabi_cdrcmple>
    adf4:	ite	ls
    adf6:	movls	r0, #1
    adf8:	movhi	r0, #0
    adfa:	ldr.w	pc, [sp], #8
    adfe:	nop

0000ae00 <__aeabi_dcmpgt>:
    ae00:	str.w	lr, [sp, #-8]!
    ae04:	bl	ad90 <__aeabi_cdrcmple>
    ae08:	ite	cc
    ae0a:	movcc	r0, #1
    ae0c:	movcs	r0, #0
    ae0e:	ldr.w	pc, [sp], #8
    ae12:	nop

0000ae14 <__aeabi_dcmpun>:
    ae14:	mov.w	ip, r1, lsl #1
    ae18:	mvns.w	ip, ip, asr #21
    ae1c:	bne.n	ae24 <__aeabi_dcmpun+0x10>
    ae1e:	orrs.w	ip, r0, r1, lsl #12
    ae22:	bne.n	ae3a <__aeabi_dcmpun+0x26>
    ae24:	mov.w	ip, r3, lsl #1
    ae28:	mvns.w	ip, ip, asr #21
    ae2c:	bne.n	ae34 <__aeabi_dcmpun+0x20>
    ae2e:	orrs.w	ip, r2, r3, lsl #12
    ae32:	bne.n	ae3a <__aeabi_dcmpun+0x26>
    ae34:	mov.w	r0, #0
    ae38:	bx	lr
    ae3a:	mov.w	r0, #1
    ae3e:	bx	lr

0000ae40 <__aeabi_d2iz>:
    ae40:	mov.w	r2, r1, lsl #1
    ae44:	adds.w	r2, r2, #2097152	; 0x200000
    ae48:	bcs.n	ae76 <__aeabi_d2iz+0x36>
    ae4a:	bpl.n	ae70 <__aeabi_d2iz+0x30>
    ae4c:	mvn.w	r3, #992	; 0x3e0
    ae50:	subs.w	r2, r3, r2, asr #21
    ae54:	bls.n	ae7c <__aeabi_d2iz+0x3c>
    ae56:	mov.w	r3, r1, lsl #11
    ae5a:	orr.w	r3, r3, #2147483648	; 0x80000000
    ae5e:	orr.w	r3, r3, r0, lsr #21
    ae62:	tst.w	r1, #2147483648	; 0x80000000
    ae66:	lsr.w	r0, r3, r2
    ae6a:	it	ne
    ae6c:	negne	r0, r0
    ae6e:	bx	lr
    ae70:	mov.w	r0, #0
    ae74:	bx	lr
    ae76:	orrs.w	r0, r0, r1, lsl #12
    ae7a:	bne.n	ae88 <__aeabi_d2iz+0x48>
    ae7c:	ands.w	r0, r1, #2147483648	; 0x80000000
    ae80:	it	eq
    ae82:	mvneq.w	r0, #2147483648	; 0x80000000
    ae86:	bx	lr
    ae88:	mov.w	r0, #0
    ae8c:	bx	lr
    ae8e:	nop

0000ae90 <__aeabi_d2uiz>:
    ae90:	lsls	r2, r1, #1
    ae92:	bcs.n	aeb8 <__aeabi_d2uiz+0x28>
    ae94:	adds.w	r2, r2, #2097152	; 0x200000
    ae98:	bcs.n	aebe <__aeabi_d2uiz+0x2e>
    ae9a:	bpl.n	aeb8 <__aeabi_d2uiz+0x28>
    ae9c:	mvn.w	r3, #992	; 0x3e0
    aea0:	subs.w	r2, r3, r2, asr #21
    aea4:	bmi.n	aec4 <__aeabi_d2uiz+0x34>
    aea6:	mov.w	r3, r1, lsl #11
    aeaa:	orr.w	r3, r3, #2147483648	; 0x80000000
    aeae:	orr.w	r3, r3, r0, lsr #21
    aeb2:	lsr.w	r0, r3, r2
    aeb6:	bx	lr
    aeb8:	mov.w	r0, #0
    aebc:	bx	lr
    aebe:	orrs.w	r0, r0, r1, lsl #12
    aec2:	bne.n	aeca <__aeabi_d2uiz+0x3a>
    aec4:	mov.w	r0, #4294967295
    aec8:	bx	lr
    aeca:	mov.w	r0, #0
    aece:	bx	lr

0000aed0 <__aeabi_d2f>:
    aed0:	mov.w	r2, r1, lsl #1
    aed4:	subs.w	r3, r2, #1879048192	; 0x70000000
    aed8:	itt	cs
    aeda:	subscs.w	ip, r3, #2097152	; 0x200000
    aede:	rsbscs	ip, ip, #532676608	; 0x1fc00000
    aee2:	bls.n	af00 <__aeabi_d2f+0x30>
    aee4:	and.w	ip, r1, #2147483648	; 0x80000000
    aee8:	mov.w	r2, r0, lsl #3
    aeec:	orr.w	r0, ip, r0, lsr #29
    aef0:	cmp.w	r2, #2147483648	; 0x80000000
    aef4:	adc.w	r0, r0, r3, lsl #2
    aef8:	it	eq
    aefa:	biceq.w	r0, r0, #1
    aefe:	bx	lr
    af00:	tst.w	r1, #1073741824	; 0x40000000
    af04:	bne.n	af4a <__aeabi_d2f+0x7a>
    af06:	adds.w	r2, r3, #48234496	; 0x2e00000
    af0a:	itt	lt
    af0c:	andlt.w	r0, r1, #2147483648	; 0x80000000
    af10:	bxlt	lr
    af12:	orr.w	r1, r1, #1048576	; 0x100000
    af16:	mov.w	r2, r2, lsr #21
    af1a:	rsb	r2, r2, #24
    af1e:	rsb	ip, r2, #32
    af22:	lsls.w	r3, r0, ip
    af26:	lsr.w	r0, r0, r2
    af2a:	it	ne
    af2c:	orrne.w	r0, r0, #1
    af30:	mov.w	r3, r1, lsl #11
    af34:	mov.w	r3, r3, lsr #11
    af38:	lsl.w	ip, r3, ip
    af3c:	orr.w	r0, r0, ip
    af40:	lsr.w	r3, r3, r2
    af44:	mov.w	r3, r3, lsl #1
    af48:	b.n	aee4 <__aeabi_d2f+0x14>
    af4a:	mvns.w	r3, r2, asr #21
    af4e:	bne.n	af60 <__aeabi_d2f+0x90>
    af50:	orrs.w	r3, r0, r1, lsl #12
    af54:	ittt	ne
    af56:	movne.w	r0, #2130706432	; 0x7f000000
    af5a:	orrne.w	r0, r0, #12582912	; 0xc00000
    af5e:	bxne	lr
    af60:	and.w	r0, r1, #2147483648	; 0x80000000
    af64:	orr.w	r0, r0, #2130706432	; 0x7f000000
    af68:	orr.w	r0, r0, #8388608	; 0x800000
    af6c:	bx	lr
    af6e:	nop

0000af70 <__aeabi_uldivmod>:
    af70:	cbnz	r3, af88 <__aeabi_uldivmod+0x18>
    af72:	cbnz	r2, af88 <__aeabi_uldivmod+0x18>
    af74:	cmp	r1, #0
    af76:	it	eq
    af78:	cmpeq	r0, #0
    af7a:	itt	ne
    af7c:	movne.w	r1, #4294967295
    af80:	movne.w	r0, #4294967295
    af84:	b.w	b284 <__aeabi_idiv0>
    af88:	sub.w	ip, sp, #8
    af8c:	strd	ip, lr, [sp, #-16]!
    af90:	bl	afa0 <__udivmoddi4>
    af94:	ldr.w	lr, [sp, #4]
    af98:	ldrd	r2, r3, [sp, #8]
    af9c:	add	sp, #16
    af9e:	bx	lr

0000afa0 <__udivmoddi4>:
    afa0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    afa4:	mov	ip, r1
    afa6:	mov	r6, r1
    afa8:	mov	r4, r0
    afaa:	ldr	r5, [sp, #32]
    afac:	cmp	r3, #0
    afae:	bne.n	b052 <__udivmoddi4+0xb2>
    afb0:	cmp	r2, r1
    afb2:	mov	r7, r2
    afb4:	bls.n	b090 <__udivmoddi4+0xf0>
    afb6:	clz	lr, r2
    afba:	cmp.w	lr, #0
    afbe:	beq.n	afd8 <__udivmoddi4+0x38>
    afc0:	rsb	r4, lr, #32
    afc4:	lsr.w	r4, r0, r4
    afc8:	lsl.w	r6, r1, lr
    afcc:	orr.w	ip, r4, r6
    afd0:	lsl.w	r7, r2, lr
    afd4:	lsl.w	r4, r0, lr
    afd8:	mov.w	r9, r7, lsr #16
    afdc:	lsrs	r2, r4, #16
    afde:	udiv	r0, ip, r9
    afe2:	uxth.w	r8, r7
    afe6:	mls	r6, r9, r0, ip
    afea:	orr.w	r6, r2, r6, lsl #16
    afee:	mul.w	r3, r0, r8
    aff2:	cmp	r3, r6
    aff4:	bls.n	b00a <__udivmoddi4+0x6a>
    aff6:	adds	r6, r6, r7
    aff8:	add.w	r2, r0, #4294967295
    affc:	bcs.w	b244 <__udivmoddi4+0x2a4>
    b000:	cmp	r3, r6
    b002:	bls.w	b244 <__udivmoddi4+0x2a4>
    b006:	subs	r0, #2
    b008:	add	r6, r7
    b00a:	subs	r6, r6, r3
    b00c:	uxth	r2, r4
    b00e:	udiv	r3, r6, r9
    b012:	mls	r6, r9, r3, r6
    b016:	orr.w	r4, r2, r6, lsl #16
    b01a:	mul.w	r8, r3, r8
    b01e:	cmp	r8, r4
    b020:	bls.n	b036 <__udivmoddi4+0x96>
    b022:	adds	r4, r4, r7
    b024:	add.w	r2, r3, #4294967295
    b028:	bcs.w	b240 <__udivmoddi4+0x2a0>
    b02c:	cmp	r8, r4
    b02e:	bls.w	b240 <__udivmoddi4+0x2a0>
    b032:	subs	r3, #2
    b034:	add	r4, r7
    b036:	rsb	r4, r8, r4
    b03a:	orr.w	r0, r3, r0, lsl #16
    b03e:	movs	r1, #0
    b040:	cmp	r5, #0
    b042:	beq.n	b10a <__udivmoddi4+0x16a>
    b044:	lsr.w	r4, r4, lr
    b048:	movs	r3, #0
    b04a:	str	r4, [r5, #0]
    b04c:	str	r3, [r5, #4]
    b04e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b052:	cmp	r3, r1
    b054:	bls.n	b066 <__udivmoddi4+0xc6>
    b056:	cmp	r5, #0
    b058:	beq.n	b106 <__udivmoddi4+0x166>
    b05a:	movs	r1, #0
    b05c:	stmia.w	r5, {r0, r6}
    b060:	mov	r0, r1
    b062:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b066:	clz	r1, r3
    b06a:	cmp	r1, #0
    b06c:	bne.w	b190 <__udivmoddi4+0x1f0>
    b070:	cmp	r3, r6
    b072:	bcc.n	b07a <__udivmoddi4+0xda>
    b074:	cmp	r2, r0
    b076:	bhi.w	b26a <__udivmoddi4+0x2ca>
    b07a:	subs	r4, r0, r2
    b07c:	sbc.w	r6, r6, r3
    b080:	movs	r0, #1
    b082:	mov	ip, r6
    b084:	cmp	r5, #0
    b086:	beq.n	b10a <__udivmoddi4+0x16a>
    b088:	stmia.w	r5, {r4, ip}
    b08c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b090:	cbnz	r2, b098 <__udivmoddi4+0xf8>
    b092:	movs	r7, #1
    b094:	udiv	r7, r7, r2
    b098:	clz	lr, r7
    b09c:	cmp.w	lr, #0
    b0a0:	bne.n	b10e <__udivmoddi4+0x16e>
    b0a2:	subs	r3, r6, r7
    b0a4:	mov.w	r8, r7, lsr #16
    b0a8:	uxth.w	ip, r7
    b0ac:	movs	r1, #1
    b0ae:	udiv	r0, r3, r8
    b0b2:	lsrs	r2, r4, #16
    b0b4:	mls	r6, r8, r0, r3
    b0b8:	orr.w	r6, r2, r6, lsl #16
    b0bc:	mul.w	r3, ip, r0
    b0c0:	cmp	r3, r6
    b0c2:	bls.n	b0d4 <__udivmoddi4+0x134>
    b0c4:	adds	r6, r6, r7
    b0c6:	add.w	r2, r0, #4294967295
    b0ca:	bcs.n	b0d2 <__udivmoddi4+0x132>
    b0cc:	cmp	r3, r6
    b0ce:	bhi.w	b26e <__udivmoddi4+0x2ce>
    b0d2:	mov	r0, r2
    b0d4:	subs	r6, r6, r3
    b0d6:	uxth	r2, r4
    b0d8:	udiv	r3, r6, r8
    b0dc:	mls	r6, r8, r3, r6
    b0e0:	orr.w	r4, r2, r6, lsl #16
    b0e4:	mul.w	ip, ip, r3
    b0e8:	cmp	ip, r4
    b0ea:	bls.n	b0fc <__udivmoddi4+0x15c>
    b0ec:	adds	r4, r4, r7
    b0ee:	add.w	r2, r3, #4294967295
    b0f2:	bcs.n	b0fa <__udivmoddi4+0x15a>
    b0f4:	cmp	ip, r4
    b0f6:	bhi.w	b264 <__udivmoddi4+0x2c4>
    b0fa:	mov	r3, r2
    b0fc:	rsb	r4, ip, r4
    b100:	orr.w	r0, r3, r0, lsl #16
    b104:	b.n	b040 <__udivmoddi4+0xa0>
    b106:	mov	r1, r5
    b108:	mov	r0, r5
    b10a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b10e:	rsb	r1, lr, #32
    b112:	lsl.w	r3, r6, lr
    b116:	lsl.w	r7, r7, lr
    b11a:	lsr.w	r9, r0, r1
    b11e:	mov.w	r8, r7, lsr #16
    b122:	lsrs	r6, r1
    b124:	orr.w	r9, r9, r3
    b128:	udiv	sl, r6, r8
    b12c:	mov.w	r4, r9, lsr #16
    b130:	mls	r6, r8, sl, r6
    b134:	uxth.w	ip, r7
    b138:	orr.w	r3, r4, r6, lsl #16
    b13c:	mul.w	r2, sl, ip
    b140:	cmp	r2, r3
    b142:	lsl.w	r4, r0, lr
    b146:	bls.n	b15e <__udivmoddi4+0x1be>
    b148:	adds	r3, r3, r7
    b14a:	add.w	r1, sl, #4294967295
    b14e:	bcs.w	b260 <__udivmoddi4+0x2c0>
    b152:	cmp	r2, r3
    b154:	bls.w	b260 <__udivmoddi4+0x2c0>
    b158:	sub.w	sl, sl, #2
    b15c:	add	r3, r7
    b15e:	subs	r3, r3, r2
    b160:	uxth.w	r9, r9
    b164:	udiv	r1, r3, r8
    b168:	mls	r3, r8, r1, r3
    b16c:	orr.w	r3, r9, r3, lsl #16
    b170:	mul.w	r6, r1, ip
    b174:	cmp	r6, r3
    b176:	bls.n	b188 <__udivmoddi4+0x1e8>
    b178:	adds	r3, r3, r7
    b17a:	add.w	r2, r1, #4294967295
    b17e:	bcs.n	b258 <__udivmoddi4+0x2b8>
    b180:	cmp	r6, r3
    b182:	bls.n	b258 <__udivmoddi4+0x2b8>
    b184:	subs	r1, #2
    b186:	add	r3, r7
    b188:	subs	r3, r3, r6
    b18a:	orr.w	r1, r1, sl, lsl #16
    b18e:	b.n	b0ae <__udivmoddi4+0x10e>
    b190:	rsb	lr, r1, #32
    b194:	lsr.w	r4, r2, lr
    b198:	lsls	r3, r1
    b19a:	orrs	r3, r4
    b19c:	lsr.w	r7, r0, lr
    b1a0:	lsl.w	r4, r6, r1
    b1a4:	mov.w	ip, r3, lsr #16
    b1a8:	lsr.w	r6, r6, lr
    b1ac:	orrs	r4, r7
    b1ae:	udiv	r9, r6, ip
    b1b2:	lsrs	r7, r4, #16
    b1b4:	mls	r6, ip, r9, r6
    b1b8:	uxth.w	r8, r3
    b1bc:	orr.w	r6, r7, r6, lsl #16
    b1c0:	mul.w	r7, r9, r8
    b1c4:	cmp	r7, r6
    b1c6:	lsl.w	r2, r2, r1
    b1ca:	lsl.w	sl, r0, r1
    b1ce:	bls.n	b1e2 <__udivmoddi4+0x242>
    b1d0:	adds	r6, r6, r3
    b1d2:	add.w	r0, r9, #4294967295
    b1d6:	bcs.n	b25c <__udivmoddi4+0x2bc>
    b1d8:	cmp	r7, r6
    b1da:	bls.n	b25c <__udivmoddi4+0x2bc>
    b1dc:	sub.w	r9, r9, #2
    b1e0:	add	r6, r3
    b1e2:	subs	r6, r6, r7
    b1e4:	uxth	r0, r4
    b1e6:	udiv	r4, r6, ip
    b1ea:	mls	r6, ip, r4, r6
    b1ee:	orr.w	r7, r0, r6, lsl #16
    b1f2:	mul.w	r8, r4, r8
    b1f6:	cmp	r8, r7
    b1f8:	bls.n	b20a <__udivmoddi4+0x26a>
    b1fa:	adds	r7, r7, r3
    b1fc:	add.w	r0, r4, #4294967295
    b200:	bcs.n	b254 <__udivmoddi4+0x2b4>
    b202:	cmp	r8, r7
    b204:	bls.n	b254 <__udivmoddi4+0x2b4>
    b206:	subs	r4, #2
    b208:	add	r7, r3
    b20a:	orr.w	r0, r4, r9, lsl #16
    b20e:	rsb	r7, r8, r7
    b212:	umull	r8, r9, r0, r2
    b216:	cmp	r7, r9
    b218:	mov	r4, r8
    b21a:	mov	r6, r9
    b21c:	bcc.n	b248 <__udivmoddi4+0x2a8>
    b21e:	beq.n	b274 <__udivmoddi4+0x2d4>
    b220:	cbz	r5, b27c <__udivmoddi4+0x2dc>
    b222:	subs.w	r3, sl, r4
    b226:	sbc.w	r7, r7, r6
    b22a:	lsl.w	lr, r7, lr
    b22e:	lsrs	r3, r1
    b230:	lsrs	r7, r1
    b232:	orr.w	r3, lr, r3
    b236:	stmia.w	r5, {r3, r7}
    b23a:	movs	r1, #0
    b23c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b240:	mov	r3, r2
    b242:	b.n	b036 <__udivmoddi4+0x96>
    b244:	mov	r0, r2
    b246:	b.n	b00a <__udivmoddi4+0x6a>
    b248:	subs.w	r4, r8, r2
    b24c:	sbc.w	r6, r9, r3
    b250:	subs	r0, #1
    b252:	b.n	b220 <__udivmoddi4+0x280>
    b254:	mov	r4, r0
    b256:	b.n	b20a <__udivmoddi4+0x26a>
    b258:	mov	r1, r2
    b25a:	b.n	b188 <__udivmoddi4+0x1e8>
    b25c:	mov	r9, r0
    b25e:	b.n	b1e2 <__udivmoddi4+0x242>
    b260:	mov	sl, r1
    b262:	b.n	b15e <__udivmoddi4+0x1be>
    b264:	subs	r3, #2
    b266:	add	r4, r7
    b268:	b.n	b0fc <__udivmoddi4+0x15c>
    b26a:	mov	r0, r1
    b26c:	b.n	b084 <__udivmoddi4+0xe4>
    b26e:	subs	r0, #2
    b270:	add	r6, r7
    b272:	b.n	b0d4 <__udivmoddi4+0x134>
    b274:	cmp	sl, r8
    b276:	bcc.n	b248 <__udivmoddi4+0x2a8>
    b278:	mov	r6, r7
    b27a:	b.n	b220 <__udivmoddi4+0x280>
    b27c:	mov	r1, r5
    b27e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b282:	nop

0000b284 <__aeabi_idiv0>:
    b284:	bx	lr
    b286:	nop

0000b288 <__cxa_atexit>:
    b288:	mov	r3, r2
    b28a:	mov	r2, r1
    b28c:	mov	r1, r0
    b28e:	movs	r0, #2
    b290:	b.w	f7a8 <__register_exitproc>

0000b294 <__errno>:
    b294:	ldr	r3, [pc, #4]	; (b29c <__errno+0x8>)
    b296:	ldr	r0, [r3, #0]
    b298:	bx	lr
    b29a:	nop
    b29c:	.word	0x1fff1828

0000b2a0 <__libc_init_array>:
    b2a0:	push	{r4, r5, r6, lr}
    b2a2:	ldr	r6, [pc, #60]	; (b2e0 <__libc_init_array+0x40>)
    b2a4:	ldr	r5, [pc, #60]	; (b2e4 <__libc_init_array+0x44>)
    b2a6:	subs	r6, r6, r5
    b2a8:	asrs	r6, r6, #2
    b2aa:	it	ne
    b2ac:	movne	r4, #0
    b2ae:	beq.n	b2bc <__libc_init_array+0x1c>
    b2b0:	adds	r4, #1
    b2b2:	ldr.w	r3, [r5], #4
    b2b6:	blx	r3
    b2b8:	cmp	r6, r4
    b2ba:	bne.n	b2b0 <__libc_init_array+0x10>
    b2bc:	ldr	r6, [pc, #40]	; (b2e8 <__libc_init_array+0x48>)
    b2be:	ldr	r5, [pc, #44]	; (b2ec <__libc_init_array+0x4c>)
    b2c0:	subs	r6, r6, r5
    b2c2:	bl	13524 <_init>
    b2c6:	asrs	r6, r6, #2
    b2c8:	it	ne
    b2ca:	movne	r4, #0
    b2cc:	beq.n	b2dc <__libc_init_array+0x3c>
    b2ce:	adds	r4, #1
    b2d0:	ldr.w	r3, [r5], #4
    b2d4:	blx	r3
    b2d6:	cmp	r6, r4
    b2d8:	bne.n	b2ce <__libc_init_array+0x2e>
    b2da:	pop	{r4, r5, r6, pc}
    b2dc:	pop	{r4, r5, r6, pc}
    b2de:	nop
    b2e0:	.word	0x00013530
    b2e4:	.word	0x00013530
    b2e8:	.word	0x00013548
    b2ec:	.word	0x00013530

0000b2f0 <__get_current_locale>:
    b2f0:	ldr	r2, [pc, #12]	; (b300 <__get_current_locale+0x10>)
    b2f2:	ldr	r3, [pc, #16]	; (b304 <__get_current_locale+0x14>)
    b2f4:	ldr	r2, [r2, #0]
    b2f6:	ldr	r0, [r2, #52]	; 0x34
    b2f8:	cmp	r0, #0
    b2fa:	it	eq
    b2fc:	moveq	r0, r3
    b2fe:	bx	lr
    b300:	.word	0x1fff1828
    b304:	.word	0x1fff182c

0000b308 <__locale_mb_cur_max>:
    b308:	ldr	r3, [pc, #16]	; (b31c <__locale_mb_cur_max+0x14>)
    b30a:	ldr	r2, [pc, #20]	; (b320 <__locale_mb_cur_max+0x18>)
    b30c:	ldr	r3, [r3, #0]
    b30e:	ldr	r3, [r3, #52]	; 0x34
    b310:	cmp	r3, #0
    b312:	it	eq
    b314:	moveq	r3, r2
    b316:	ldrb.w	r0, [r3, #296]	; 0x128
    b31a:	bx	lr
    b31c:	.word	0x1fff1828
    b320:	.word	0x1fff182c

0000b324 <__locale_ctype_ptr_l>:
    b324:	ldr.w	r0, [r0, #236]	; 0xec
    b328:	bx	lr
    b32a:	nop

0000b32c <__locale_ctype_ptr>:
    b32c:	push	{r3, lr}
    b32e:	ldr	r3, [pc, #12]	; (b33c <__locale_ctype_ptr+0x10>)
    b330:	ldr	r0, [r3, #0]
    b332:	bl	b2f0 <__get_current_locale>
    b336:	ldr.w	r0, [r0, #236]	; 0xec
    b33a:	pop	{r3, pc}
    b33c:	.word	0x1fff1828

0000b340 <malloc>:
    b340:	ldr	r3, [pc, #8]	; (b34c <malloc+0xc>)
    b342:	mov	r1, r0
    b344:	ldr	r0, [r3, #0]
    b346:	b.w	b360 <_malloc_r>
    b34a:	nop
    b34c:	.word	0x1fff1828

0000b350 <free>:
    b350:	ldr	r3, [pc, #8]	; (b35c <free+0xc>)
    b352:	mov	r1, r0
    b354:	ldr	r0, [r3, #0]
    b356:	b.w	10890 <_free_r>
    b35a:	nop
    b35c:	.word	0x1fff1828

0000b360 <_malloc_r>:
    b360:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b364:	add.w	r5, r1, #11
    b368:	cmp	r5, #22
    b36a:	sub	sp, #12
    b36c:	mov	r6, r0
    b36e:	bls.w	b4b0 <_malloc_r+0x150>
    b372:	bics.w	r5, r5, #7
    b376:	bmi.w	b4f8 <_malloc_r+0x198>
    b37a:	cmp	r1, r5
    b37c:	bhi.w	b4f8 <_malloc_r+0x198>
    b380:	bl	bacc <__malloc_lock>
    b384:	cmp.w	r5, #504	; 0x1f8
    b388:	bcc.w	b8c4 <_malloc_r+0x564>
    b38c:	lsrs	r3, r5, #9
    b38e:	beq.w	b506 <_malloc_r+0x1a6>
    b392:	cmp	r3, #4
    b394:	bhi.w	b69e <_malloc_r+0x33e>
    b398:	lsrs	r0, r5, #6
    b39a:	add.w	lr, r0, #57	; 0x39
    b39e:	mov.w	r3, lr, lsl #1
    b3a2:	adds	r0, #56	; 0x38
    b3a4:	ldr	r7, [pc, #784]	; (b6b8 <_malloc_r+0x358>)
    b3a6:	add.w	r3, r7, r3, lsl #2
    b3aa:	sub.w	r1, r3, #8
    b3ae:	ldr	r4, [r3, #4]
    b3b0:	cmp	r1, r4
    b3b2:	bne.n	b3c4 <_malloc_r+0x64>
    b3b4:	b.n	b510 <_malloc_r+0x1b0>
    b3b6:	cmp	r2, #0
    b3b8:	bge.w	b514 <_malloc_r+0x1b4>
    b3bc:	ldr	r4, [r4, #12]
    b3be:	cmp	r1, r4
    b3c0:	beq.w	b510 <_malloc_r+0x1b0>
    b3c4:	ldr	r3, [r4, #4]
    b3c6:	bic.w	r3, r3, #3
    b3ca:	subs	r2, r3, r5
    b3cc:	cmp	r2, #15
    b3ce:	ble.n	b3b6 <_malloc_r+0x56>
    b3d0:	ldr	r1, [pc, #740]	; (b6b8 <_malloc_r+0x358>)
    b3d2:	ldr	r4, [r7, #16]
    b3d4:	add.w	lr, r1, #8
    b3d8:	cmp	r4, lr
    b3da:	beq.w	b744 <_malloc_r+0x3e4>
    b3de:	ldr	r3, [r4, #4]
    b3e0:	bic.w	r3, r3, #3
    b3e4:	subs	r2, r3, r5
    b3e6:	cmp	r2, #15
    b3e8:	bgt.w	b71e <_malloc_r+0x3be>
    b3ec:	cmp	r2, #0
    b3ee:	str.w	lr, [r1, #20]
    b3f2:	str.w	lr, [r1, #16]
    b3f6:	bge.w	b536 <_malloc_r+0x1d6>
    b3fa:	cmp.w	r3, #512	; 0x200
    b3fe:	bcs.w	b6d0 <_malloc_r+0x370>
    b402:	lsrs	r3, r3, #3
    b404:	add.w	ip, r3, #1
    b408:	movs	r2, #1
    b40a:	asrs	r3, r3, #2
    b40c:	lsl.w	r3, r2, r3
    b410:	ldr	r2, [r1, #4]
    b412:	ldr.w	r8, [r1, ip, lsl #3]
    b416:	str.w	r8, [r4, #8]
    b41a:	add.w	r9, r1, ip, lsl #3
    b41e:	orrs	r2, r3
    b420:	sub.w	r3, r9, #8
    b424:	str	r3, [r4, #12]
    b426:	str	r2, [r1, #4]
    b428:	str.w	r4, [r1, ip, lsl #3]
    b42c:	str.w	r4, [r8, #12]
    b430:	asrs	r3, r0, #2
    b432:	movs	r4, #1
    b434:	lsls	r4, r3
    b436:	cmp	r4, r2
    b438:	bhi.w	b550 <_malloc_r+0x1f0>
    b43c:	tst	r4, r2
    b43e:	bne.n	b44e <_malloc_r+0xee>
    b440:	bic.w	r0, r0, #3
    b444:	lsls	r4, r4, #1
    b446:	tst	r4, r2
    b448:	add.w	r0, r0, #4
    b44c:	beq.n	b444 <_malloc_r+0xe4>
    b44e:	add.w	r9, r7, r0, lsl #3
    b452:	mov	ip, r9
    b454:	mov	r8, r0
    b456:	ldr.w	r1, [ip, #12]
    b45a:	cmp	ip, r1
    b45c:	bne.n	b46e <_malloc_r+0x10e>
    b45e:	b.n	b748 <_malloc_r+0x3e8>
    b460:	cmp	r2, #0
    b462:	bge.w	b768 <_malloc_r+0x408>
    b466:	ldr	r1, [r1, #12]
    b468:	cmp	ip, r1
    b46a:	beq.w	b748 <_malloc_r+0x3e8>
    b46e:	ldr	r3, [r1, #4]
    b470:	bic.w	r3, r3, #3
    b474:	subs	r2, r3, r5
    b476:	cmp	r2, #15
    b478:	ble.n	b460 <_malloc_r+0x100>
    b47a:	mov	r4, r1
    b47c:	ldr.w	ip, [r1, #12]
    b480:	ldr.w	r8, [r4, #8]!
    b484:	adds	r3, r1, r5
    b486:	orr.w	r5, r5, #1
    b48a:	str	r5, [r1, #4]
    b48c:	orr.w	r1, r2, #1
    b490:	str.w	ip, [r8, #12]
    b494:	mov	r0, r6
    b496:	str.w	r8, [ip, #8]
    b49a:	str	r3, [r7, #20]
    b49c:	str	r3, [r7, #16]
    b49e:	str.w	lr, [r3, #12]
    b4a2:	str.w	lr, [r3, #8]
    b4a6:	str	r1, [r3, #4]
    b4a8:	str	r2, [r3, r2]
    b4aa:	bl	bad0 <__malloc_unlock>
    b4ae:	b.n	b4f0 <_malloc_r+0x190>
    b4b0:	cmp	r1, #16
    b4b2:	bhi.n	b4f8 <_malloc_r+0x198>
    b4b4:	bl	bacc <__malloc_lock>
    b4b8:	movs	r5, #16
    b4ba:	movs	r3, #6
    b4bc:	movs	r0, #2
    b4be:	ldr	r7, [pc, #504]	; (b6b8 <_malloc_r+0x358>)
    b4c0:	add.w	r3, r7, r3, lsl #2
    b4c4:	sub.w	r2, r3, #8
    b4c8:	ldr	r4, [r3, #4]
    b4ca:	cmp	r4, r2
    b4cc:	beq.w	b75a <_malloc_r+0x3fa>
    b4d0:	ldr	r3, [r4, #4]
    b4d2:	ldr	r1, [r4, #12]
    b4d4:	ldr	r5, [r4, #8]
    b4d6:	bic.w	r3, r3, #3
    b4da:	add	r3, r4
    b4dc:	mov	r0, r6
    b4de:	ldr	r2, [r3, #4]
    b4e0:	str	r1, [r5, #12]
    b4e2:	orr.w	r2, r2, #1
    b4e6:	str	r5, [r1, #8]
    b4e8:	str	r2, [r3, #4]
    b4ea:	bl	bad0 <__malloc_unlock>
    b4ee:	adds	r4, #8
    b4f0:	mov	r0, r4
    b4f2:	add	sp, #12
    b4f4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b4f8:	movs	r4, #0
    b4fa:	movs	r3, #12
    b4fc:	mov	r0, r4
    b4fe:	str	r3, [r6, #0]
    b500:	add	sp, #12
    b502:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b506:	movs	r3, #128	; 0x80
    b508:	mov.w	lr, #64	; 0x40
    b50c:	movs	r0, #63	; 0x3f
    b50e:	b.n	b3a4 <_malloc_r+0x44>
    b510:	mov	r0, lr
    b512:	b.n	b3d0 <_malloc_r+0x70>
    b514:	add	r3, r4
    b516:	ldr	r1, [r4, #12]
    b518:	ldr	r2, [r3, #4]
    b51a:	ldr	r5, [r4, #8]
    b51c:	orr.w	r2, r2, #1
    b520:	str	r1, [r5, #12]
    b522:	mov	r0, r6
    b524:	str	r5, [r1, #8]
    b526:	str	r2, [r3, #4]
    b528:	bl	bad0 <__malloc_unlock>
    b52c:	adds	r4, #8
    b52e:	mov	r0, r4
    b530:	add	sp, #12
    b532:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b536:	add	r3, r4
    b538:	mov	r0, r6
    b53a:	ldr	r2, [r3, #4]
    b53c:	orr.w	r2, r2, #1
    b540:	str	r2, [r3, #4]
    b542:	bl	bad0 <__malloc_unlock>
    b546:	adds	r4, #8
    b548:	mov	r0, r4
    b54a:	add	sp, #12
    b54c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b550:	ldr	r4, [r7, #8]
    b552:	ldr	r3, [r4, #4]
    b554:	bic.w	r8, r3, #3
    b558:	cmp	r8, r5
    b55a:	bcc.n	b566 <_malloc_r+0x206>
    b55c:	rsb	r3, r5, r8
    b560:	cmp	r3, #15
    b562:	bgt.w	b67e <_malloc_r+0x31e>
    b566:	ldr	r3, [pc, #340]	; (b6bc <_malloc_r+0x35c>)
    b568:	ldr.w	r9, [pc, #352]	; b6cc <_malloc_r+0x36c>
    b56c:	ldr	r2, [r3, #0]
    b56e:	ldr.w	r3, [r9]
    b572:	adds	r3, #1
    b574:	add	r2, r5
    b576:	add.w	sl, r4, r8
    b57a:	beq.w	b83e <_malloc_r+0x4de>
    b57e:	add.w	r2, r2, #4096	; 0x1000
    b582:	adds	r2, #15
    b584:	bic.w	r2, r2, #4080	; 0xff0
    b588:	bic.w	r2, r2, #15
    b58c:	mov	r1, r2
    b58e:	mov	r0, r6
    b590:	str	r2, [sp, #4]
    b592:	bl	beb4 <_sbrk_r>
    b596:	cmp.w	r0, #4294967295
    b59a:	mov	fp, r0
    b59c:	ldr	r2, [sp, #4]
    b59e:	beq.w	b852 <_malloc_r+0x4f2>
    b5a2:	cmp	sl, r0
    b5a4:	bhi.w	b7a0 <_malloc_r+0x440>
    b5a8:	ldr	r3, [pc, #276]	; (b6c0 <_malloc_r+0x360>)
    b5aa:	ldr	r1, [r3, #0]
    b5ac:	cmp	sl, fp
    b5ae:	add	r1, r2
    b5b0:	str	r1, [r3, #0]
    b5b2:	beq.w	b85c <_malloc_r+0x4fc>
    b5b6:	ldr.w	r0, [r9]
    b5ba:	ldr.w	lr, [pc, #272]	; b6cc <_malloc_r+0x36c>
    b5be:	adds	r0, #1
    b5c0:	ittet	ne
    b5c2:	rsbne	sl, sl, fp
    b5c6:	addne	r1, sl
    b5c8:	streq.w	fp, [lr]
    b5cc:	strne	r1, [r3, #0]
    b5ce:	ands.w	r1, fp, #7
    b5d2:	beq.w	b804 <_malloc_r+0x4a4>
    b5d6:	rsb	r0, r1, #8
    b5da:	rsb	r1, r1, #4096	; 0x1000
    b5de:	add	fp, r0
    b5e0:	adds	r1, #8
    b5e2:	add	r2, fp
    b5e4:	ubfx	r2, r2, #0, #12
    b5e8:	rsb	r9, r2, r1
    b5ec:	mov	r1, r9
    b5ee:	mov	r0, r6
    b5f0:	str	r3, [sp, #4]
    b5f2:	bl	beb4 <_sbrk_r>
    b5f6:	adds	r3, r0, #1
    b5f8:	ldr	r3, [sp, #4]
    b5fa:	beq.w	b87c <_malloc_r+0x51c>
    b5fe:	rsb	r2, fp, r0
    b602:	add	r2, r9
    b604:	orr.w	r2, r2, #1
    b608:	ldr	r1, [r3, #0]
    b60a:	str.w	fp, [r7, #8]
    b60e:	add	r1, r9
    b610:	cmp	r4, r7
    b612:	str.w	r2, [fp, #4]
    b616:	str	r1, [r3, #0]
    b618:	ldr.w	r9, [pc, #164]	; b6c0 <_malloc_r+0x360>
    b61c:	beq.n	b64c <_malloc_r+0x2ec>
    b61e:	cmp.w	r8, #15
    b622:	bls.w	b820 <_malloc_r+0x4c0>
    b626:	ldr	r2, [r4, #4]
    b628:	sub.w	r3, r8, #12
    b62c:	bic.w	r3, r3, #7
    b630:	adds	r0, r4, r3
    b632:	and.w	r2, r2, #1
    b636:	mov.w	lr, #5
    b63a:	orrs	r2, r3
    b63c:	cmp	r3, #15
    b63e:	str	r2, [r4, #4]
    b640:	str.w	lr, [r0, #4]
    b644:	str.w	lr, [r0, #8]
    b648:	bhi.w	b884 <_malloc_r+0x524>
    b64c:	ldr	r3, [pc, #116]	; (b6c4 <_malloc_r+0x364>)
    b64e:	ldr	r4, [r7, #8]
    b650:	ldr	r2, [r3, #0]
    b652:	cmp	r1, r2
    b654:	it	hi
    b656:	strhi	r1, [r3, #0]
    b658:	ldr	r3, [pc, #108]	; (b6c8 <_malloc_r+0x368>)
    b65a:	ldr	r2, [r3, #0]
    b65c:	cmp	r1, r2
    b65e:	ldr	r2, [r4, #4]
    b660:	it	hi
    b662:	strhi	r1, [r3, #0]
    b664:	bic.w	r2, r2, #3
    b668:	cmp	r5, r2
    b66a:	sub.w	r3, r2, r5
    b66e:	bhi.n	b674 <_malloc_r+0x314>
    b670:	cmp	r3, #15
    b672:	bgt.n	b67e <_malloc_r+0x31e>
    b674:	mov	r0, r6
    b676:	bl	bad0 <__malloc_unlock>
    b67a:	movs	r4, #0
    b67c:	b.n	b4f0 <_malloc_r+0x190>
    b67e:	adds	r2, r4, r5
    b680:	orr.w	r3, r3, #1
    b684:	orr.w	r5, r5, #1
    b688:	str	r5, [r4, #4]
    b68a:	mov	r0, r6
    b68c:	str	r2, [r7, #8]
    b68e:	str	r3, [r2, #4]
    b690:	bl	bad0 <__malloc_unlock>
    b694:	adds	r4, #8
    b696:	mov	r0, r4
    b698:	add	sp, #12
    b69a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b69e:	cmp	r3, #20
    b6a0:	bls.n	b786 <_malloc_r+0x426>
    b6a2:	cmp	r3, #84	; 0x54
    b6a4:	bhi.w	b7f0 <_malloc_r+0x490>
    b6a8:	lsrs	r0, r5, #12
    b6aa:	add.w	lr, r0, #111	; 0x6f
    b6ae:	mov.w	r3, lr, lsl #1
    b6b2:	adds	r0, #110	; 0x6e
    b6b4:	b.n	b3a4 <_malloc_r+0x44>
    b6b6:	nop
    b6b8:	.word	0x1fff1998
    b6bc:	.word	0x2001a81c
    b6c0:	.word	0x2001a820
    b6c4:	.word	0x2001a818
    b6c8:	.word	0x2001a814
    b6cc:	.word	0x1fff1da4
    b6d0:	lsrs	r2, r3, #9
    b6d2:	cmp	r2, #4
    b6d4:	bls.n	b794 <_malloc_r+0x434>
    b6d6:	cmp	r2, #20
    b6d8:	bhi.w	b842 <_malloc_r+0x4e2>
    b6dc:	add.w	r1, r2, #92	; 0x5c
    b6e0:	lsls	r1, r1, #1
    b6e2:	adds	r2, #91	; 0x5b
    b6e4:	add.w	ip, r7, r1, lsl #2
    b6e8:	ldr.w	r1, [r7, r1, lsl #2]
    b6ec:	ldr.w	r8, [pc, #476]	; b8cc <_malloc_r+0x56c>
    b6f0:	sub.w	ip, ip, #8
    b6f4:	cmp	ip, r1
    b6f6:	beq.w	b80a <_malloc_r+0x4aa>
    b6fa:	ldr	r2, [r1, #4]
    b6fc:	bic.w	r2, r2, #3
    b700:	cmp	r3, r2
    b702:	bcs.n	b70a <_malloc_r+0x3aa>
    b704:	ldr	r1, [r1, #8]
    b706:	cmp	ip, r1
    b708:	bne.n	b6fa <_malloc_r+0x39a>
    b70a:	ldr.w	ip, [r1, #12]
    b70e:	ldr	r2, [r7, #4]
    b710:	str.w	ip, [r4, #12]
    b714:	str	r1, [r4, #8]
    b716:	str.w	r4, [ip, #8]
    b71a:	str	r4, [r1, #12]
    b71c:	b.n	b430 <_malloc_r+0xd0>
    b71e:	adds	r3, r4, r5
    b720:	orr.w	r7, r2, #1
    b724:	orr.w	r5, r5, #1
    b728:	str	r5, [r4, #4]
    b72a:	mov	r0, r6
    b72c:	str	r3, [r1, #20]
    b72e:	str	r3, [r1, #16]
    b730:	str.w	lr, [r3, #12]
    b734:	str.w	lr, [r3, #8]
    b738:	str	r7, [r3, #4]
    b73a:	str	r2, [r3, r2]
    b73c:	adds	r4, #8
    b73e:	bl	bad0 <__malloc_unlock>
    b742:	b.n	b4f0 <_malloc_r+0x190>
    b744:	ldr	r2, [r1, #4]
    b746:	b.n	b430 <_malloc_r+0xd0>
    b748:	add.w	r8, r8, #1
    b74c:	tst.w	r8, #3
    b750:	add.w	ip, ip, #8
    b754:	bne.w	b456 <_malloc_r+0xf6>
    b758:	b.n	b7bc <_malloc_r+0x45c>
    b75a:	ldr	r4, [r3, #12]
    b75c:	cmp	r3, r4
    b75e:	it	eq
    b760:	addeq	r0, #2
    b762:	beq.w	b3d0 <_malloc_r+0x70>
    b766:	b.n	b4d0 <_malloc_r+0x170>
    b768:	add	r3, r1
    b76a:	mov	r4, r1
    b76c:	ldr	r2, [r3, #4]
    b76e:	ldr	r1, [r1, #12]
    b770:	ldr.w	r5, [r4, #8]!
    b774:	orr.w	r2, r2, #1
    b778:	str	r2, [r3, #4]
    b77a:	mov	r0, r6
    b77c:	str	r1, [r5, #12]
    b77e:	str	r5, [r1, #8]
    b780:	bl	bad0 <__malloc_unlock>
    b784:	b.n	b4f0 <_malloc_r+0x190>
    b786:	add.w	lr, r3, #92	; 0x5c
    b78a:	add.w	r0, r3, #91	; 0x5b
    b78e:	mov.w	r3, lr, lsl #1
    b792:	b.n	b3a4 <_malloc_r+0x44>
    b794:	lsrs	r2, r3, #6
    b796:	add.w	r1, r2, #57	; 0x39
    b79a:	lsls	r1, r1, #1
    b79c:	adds	r2, #56	; 0x38
    b79e:	b.n	b6e4 <_malloc_r+0x384>
    b7a0:	cmp	r4, r7
    b7a2:	ldr	r3, [pc, #296]	; (b8cc <_malloc_r+0x56c>)
    b7a4:	beq.w	b5a8 <_malloc_r+0x248>
    b7a8:	ldr	r4, [r3, #8]
    b7aa:	ldr	r2, [r4, #4]
    b7ac:	bic.w	r2, r2, #3
    b7b0:	b.n	b668 <_malloc_r+0x308>
    b7b2:	ldr.w	r3, [r9], #-8
    b7b6:	cmp	r9, r3
    b7b8:	bne.w	b8c0 <_malloc_r+0x560>
    b7bc:	tst.w	r0, #3
    b7c0:	add.w	r0, r0, #4294967295
    b7c4:	bne.n	b7b2 <_malloc_r+0x452>
    b7c6:	ldr	r3, [r7, #4]
    b7c8:	bic.w	r3, r3, r4
    b7cc:	str	r3, [r7, #4]
    b7ce:	lsls	r4, r4, #1
    b7d0:	cmp	r4, r3
    b7d2:	bhi.w	b550 <_malloc_r+0x1f0>
    b7d6:	cmp	r4, #0
    b7d8:	beq.w	b550 <_malloc_r+0x1f0>
    b7dc:	tst	r4, r3
    b7de:	mov	r0, r8
    b7e0:	bne.w	b44e <_malloc_r+0xee>
    b7e4:	lsls	r4, r4, #1
    b7e6:	tst	r4, r3
    b7e8:	add.w	r0, r0, #4
    b7ec:	beq.n	b7e4 <_malloc_r+0x484>
    b7ee:	b.n	b44e <_malloc_r+0xee>
    b7f0:	cmp.w	r3, #340	; 0x154
    b7f4:	bhi.n	b828 <_malloc_r+0x4c8>
    b7f6:	lsrs	r0, r5, #15
    b7f8:	add.w	lr, r0, #120	; 0x78
    b7fc:	mov.w	r3, lr, lsl #1
    b800:	adds	r0, #119	; 0x77
    b802:	b.n	b3a4 <_malloc_r+0x44>
    b804:	mov.w	r1, #4096	; 0x1000
    b808:	b.n	b5e2 <_malloc_r+0x282>
    b80a:	movs	r1, #1
    b80c:	ldr.w	r3, [r8, #4]
    b810:	asrs	r2, r2, #2
    b812:	lsl.w	r2, r1, r2
    b816:	orrs	r2, r3
    b818:	str.w	r2, [r8, #4]
    b81c:	mov	r1, ip
    b81e:	b.n	b710 <_malloc_r+0x3b0>
    b820:	movs	r3, #1
    b822:	str.w	r3, [fp, #4]
    b826:	b.n	b674 <_malloc_r+0x314>
    b828:	movw	r2, #1364	; 0x554
    b82c:	cmp	r3, r2
    b82e:	bhi.n	b872 <_malloc_r+0x512>
    b830:	lsrs	r0, r5, #18
    b832:	add.w	lr, r0, #125	; 0x7d
    b836:	mov.w	r3, lr, lsl #1
    b83a:	adds	r0, #124	; 0x7c
    b83c:	b.n	b3a4 <_malloc_r+0x44>
    b83e:	adds	r2, #16
    b840:	b.n	b58c <_malloc_r+0x22c>
    b842:	cmp	r2, #84	; 0x54
    b844:	bhi.n	b894 <_malloc_r+0x534>
    b846:	lsrs	r2, r3, #12
    b848:	add.w	r1, r2, #111	; 0x6f
    b84c:	lsls	r1, r1, #1
    b84e:	adds	r2, #110	; 0x6e
    b850:	b.n	b6e4 <_malloc_r+0x384>
    b852:	ldr	r4, [r7, #8]
    b854:	ldr	r2, [r4, #4]
    b856:	bic.w	r2, r2, #3
    b85a:	b.n	b668 <_malloc_r+0x308>
    b85c:	ubfx	r0, sl, #0, #12
    b860:	cmp	r0, #0
    b862:	bne.w	b5b6 <_malloc_r+0x256>
    b866:	add	r2, r8
    b868:	ldr	r3, [r7, #8]
    b86a:	orr.w	r2, r2, #1
    b86e:	str	r2, [r3, #4]
    b870:	b.n	b64c <_malloc_r+0x2ec>
    b872:	movs	r3, #254	; 0xfe
    b874:	mov.w	lr, #127	; 0x7f
    b878:	movs	r0, #126	; 0x7e
    b87a:	b.n	b3a4 <_malloc_r+0x44>
    b87c:	movs	r2, #1
    b87e:	mov.w	r9, #0
    b882:	b.n	b608 <_malloc_r+0x2a8>
    b884:	add.w	r1, r4, #8
    b888:	mov	r0, r6
    b88a:	bl	10890 <_free_r>
    b88e:	ldr.w	r1, [r9]
    b892:	b.n	b64c <_malloc_r+0x2ec>
    b894:	cmp.w	r2, #340	; 0x154
    b898:	bhi.n	b8a6 <_malloc_r+0x546>
    b89a:	lsrs	r2, r3, #15
    b89c:	add.w	r1, r2, #120	; 0x78
    b8a0:	lsls	r1, r1, #1
    b8a2:	adds	r2, #119	; 0x77
    b8a4:	b.n	b6e4 <_malloc_r+0x384>
    b8a6:	movw	r1, #1364	; 0x554
    b8aa:	cmp	r2, r1
    b8ac:	bhi.n	b8ba <_malloc_r+0x55a>
    b8ae:	lsrs	r2, r3, #18
    b8b0:	add.w	r1, r2, #125	; 0x7d
    b8b4:	lsls	r1, r1, #1
    b8b6:	adds	r2, #124	; 0x7c
    b8b8:	b.n	b6e4 <_malloc_r+0x384>
    b8ba:	movs	r1, #254	; 0xfe
    b8bc:	movs	r2, #126	; 0x7e
    b8be:	b.n	b6e4 <_malloc_r+0x384>
    b8c0:	ldr	r3, [r7, #4]
    b8c2:	b.n	b7ce <_malloc_r+0x46e>
    b8c4:	lsrs	r0, r5, #3
    b8c6:	adds	r3, r0, #1
    b8c8:	lsls	r3, r3, #1
    b8ca:	b.n	b4be <_malloc_r+0x15e>
    b8cc:	.word	0x1fff1998

0000b8d0 <__ascii_mbtowc>:
    b8d0:	sub	sp, #8
    b8d2:	cbz	r1, b8e8 <__ascii_mbtowc+0x18>
    b8d4:	cbz	r2, b8ee <__ascii_mbtowc+0x1e>
    b8d6:	cbz	r3, b8f4 <__ascii_mbtowc+0x24>
    b8d8:	ldrb	r3, [r2, #0]
    b8da:	str	r3, [r1, #0]
    b8dc:	ldrb	r2, [r2, #0]
    b8de:	adds	r0, r2, #0
    b8e0:	it	ne
    b8e2:	movne	r0, #1
    b8e4:	add	sp, #8
    b8e6:	bx	lr
    b8e8:	add	r1, sp, #4
    b8ea:	cmp	r2, #0
    b8ec:	bne.n	b8d6 <__ascii_mbtowc+0x6>
    b8ee:	mov	r0, r2
    b8f0:	add	sp, #8
    b8f2:	bx	lr
    b8f4:	mvn.w	r0, #1
    b8f8:	b.n	b8e4 <__ascii_mbtowc+0x14>
    b8fa:	nop
    b8fc:			; <UNDEFINED> instruction: 0xffffffff

0000b900 <memchr>:
    b900:	and.w	r1, r1, #255	; 0xff
    b904:	cmp	r2, #16
    b906:	blt.n	b960 <memchr+0x60>
    b908:	tst.w	r0, #7
    b90c:	beq.n	b920 <memchr+0x20>
    b90e:	ldrb.w	r3, [r0], #1
    b912:	subs	r2, #1
    b914:	cmp	r3, r1
    b916:	beq.n	b974 <memchr+0x74>
    b918:	tst.w	r0, #7
    b91c:	cbz	r2, b970 <memchr+0x70>
    b91e:	bne.n	b90e <memchr+0xe>
    b920:	push	{r4, r5, r6, r7}
    b922:	orr.w	r1, r1, r1, lsl #8
    b926:	orr.w	r1, r1, r1, lsl #16
    b92a:	bic.w	r4, r2, #7
    b92e:	mvns.w	r7, #0
    b932:	movs	r3, #0
    b934:	ldrd	r5, r6, [r0], #8
    b938:	subs	r4, #8
    b93a:	eor.w	r5, r5, r1
    b93e:	eor.w	r6, r6, r1
    b942:	uadd8	r5, r5, r7
    b946:	sel	r5, r3, r7
    b94a:	uadd8	r6, r6, r7
    b94e:	sel	r6, r5, r7
    b952:	cbnz	r6, b978 <memchr+0x78>
    b954:	bne.n	b934 <memchr+0x34>
    b956:	pop	{r4, r5, r6, r7}
    b958:	and.w	r1, r1, #255	; 0xff
    b95c:	and.w	r2, r2, #7
    b960:	cbz	r2, b970 <memchr+0x70>
    b962:	ldrb.w	r3, [r0], #1
    b966:	subs	r2, #1
    b968:	eor.w	r3, r3, r1
    b96c:	cbz	r3, b974 <memchr+0x74>
    b96e:	bne.n	b962 <memchr+0x62>
    b970:	movs	r0, #0
    b972:	bx	lr
    b974:	subs	r0, #1
    b976:	bx	lr
    b978:	cmp	r5, #0
    b97a:	itte	eq
    b97c:	moveq	r5, r6
    b97e:	subeq	r0, #3
    b980:	subne	r0, #7
    b982:	tst.w	r5, #1
    b986:	bne.n	b998 <memchr+0x98>
    b988:	adds	r0, #1
    b98a:	tst.w	r5, #256	; 0x100
    b98e:	ittt	eq
    b990:	addeq	r0, #1
    b992:	tsteq.w	r5, #98304	; 0x18000
    b996:	addeq	r0, #1
    b998:	pop	{r4, r5, r6, r7}
    b99a:	subs	r0, #1
    b99c:	bx	lr
    b99e:	nop

0000b9a0 <memcmp>:
    b9a0:	cmp	r2, #3
    b9a2:	push	{r4, r5, r6}
    b9a4:	bls.n	b9f4 <memcmp+0x54>
    b9a6:	orr.w	r3, r0, r1
    b9aa:	lsls	r3, r3, #30
    b9ac:	beq.n	b9d2 <memcmp+0x32>
    b9ae:	ldrb	r4, [r0, #0]
    b9b0:	ldrb	r5, [r1, #0]
    b9b2:	cmp	r4, r5
    b9b4:	bne.n	b9fc <memcmp+0x5c>
    b9b6:	add	r2, r0
    b9b8:	adds	r3, r0, #1
    b9ba:	b.n	b9c8 <memcmp+0x28>
    b9bc:	ldrb.w	r4, [r3], #1
    b9c0:	ldrb.w	r5, [r1, #1]!
    b9c4:	cmp	r4, r5
    b9c6:	bne.n	b9fc <memcmp+0x5c>
    b9c8:	cmp	r3, r2
    b9ca:	bne.n	b9bc <memcmp+0x1c>
    b9cc:	movs	r0, #0
    b9ce:	pop	{r4, r5, r6}
    b9d0:	bx	lr
    b9d2:	mov	r4, r1
    b9d4:	mov	r3, r0
    b9d6:	ldr	r6, [r3, #0]
    b9d8:	ldr	r5, [r4, #0]
    b9da:	cmp	r6, r5
    b9dc:	mov	r0, r3
    b9de:	mov	r1, r4
    b9e0:	add.w	r3, r3, #4
    b9e4:	add.w	r4, r4, #4
    b9e8:	bne.n	b9ae <memcmp+0xe>
    b9ea:	subs	r2, #4
    b9ec:	cmp	r2, #3
    b9ee:	mov	r0, r3
    b9f0:	mov	r1, r4
    b9f2:	bhi.n	b9d6 <memcmp+0x36>
    b9f4:	cmp	r2, #0
    b9f6:	bne.n	b9ae <memcmp+0xe>
    b9f8:	mov	r0, r2
    b9fa:	b.n	b9ce <memcmp+0x2e>
    b9fc:	subs	r0, r4, r5
    b9fe:	pop	{r4, r5, r6}
    ba00:	bx	lr
    ba02:	nop

0000ba04 <memmove>:
    ba04:	cmp	r0, r1
    ba06:	push	{r4, r5, r6, r7, lr}
    ba08:	bls.n	ba26 <memmove+0x22>
    ba0a:	adds	r3, r1, r2
    ba0c:	cmp	r0, r3
    ba0e:	bcs.n	ba26 <memmove+0x22>
    ba10:	adds	r1, r0, r2
    ba12:	cmp	r2, #0
    ba14:	beq.n	baba <memmove+0xb6>
    ba16:	subs	r2, r3, r2
    ba18:	ldrb.w	r4, [r3, #-1]!
    ba1c:	strb.w	r4, [r1, #-1]!
    ba20:	cmp	r3, r2
    ba22:	bne.n	ba18 <memmove+0x14>
    ba24:	pop	{r4, r5, r6, r7, pc}
    ba26:	cmp	r2, #15
    ba28:	bls.n	babc <memmove+0xb8>
    ba2a:	orr.w	r3, r1, r0
    ba2e:	lsls	r3, r3, #30
    ba30:	bne.n	bac0 <memmove+0xbc>
    ba32:	add.w	r4, r0, #16
    ba36:	add.w	r3, r1, #16
    ba3a:	mov	r5, r2
    ba3c:	ldr.w	r6, [r3, #-16]
    ba40:	str.w	r6, [r4, #-16]
    ba44:	ldr.w	r6, [r3, #-12]
    ba48:	str.w	r6, [r4, #-12]
    ba4c:	ldr.w	r6, [r3, #-8]
    ba50:	str.w	r6, [r4, #-8]
    ba54:	subs	r5, #16
    ba56:	ldr.w	r6, [r3, #-4]
    ba5a:	str.w	r6, [r4, #-4]
    ba5e:	cmp	r5, #15
    ba60:	add.w	r3, r3, #16
    ba64:	add.w	r4, r4, #16
    ba68:	bhi.n	ba3c <memmove+0x38>
    ba6a:	sub.w	r3, r2, #16
    ba6e:	bic.w	r3, r3, #15
    ba72:	and.w	lr, r2, #15
    ba76:	adds	r3, #16
    ba78:	cmp.w	lr, #3
    ba7c:	add	r1, r3
    ba7e:	add	r3, r0
    ba80:	bls.n	bac6 <memmove+0xc2>
    ba82:	subs	r6, r3, #4
    ba84:	mov	r5, r1
    ba86:	mov	r4, lr
    ba88:	subs	r4, #4
    ba8a:	ldr.w	r7, [r5], #4
    ba8e:	str.w	r7, [r6, #4]!
    ba92:	cmp	r4, #3
    ba94:	bhi.n	ba88 <memmove+0x84>
    ba96:	sub.w	r4, lr, #4
    ba9a:	bic.w	r4, r4, #3
    ba9e:	adds	r4, #4
    baa0:	add	r3, r4
    baa2:	add	r1, r4
    baa4:	and.w	r2, r2, #3
    baa8:	cbz	r2, bac4 <memmove+0xc0>
    baaa:	subs	r3, #1
    baac:	add	r2, r1
    baae:	ldrb.w	r4, [r1], #1
    bab2:	strb.w	r4, [r3, #1]!
    bab6:	cmp	r2, r1
    bab8:	bne.n	baae <memmove+0xaa>
    baba:	pop	{r4, r5, r6, r7, pc}
    babc:	mov	r3, r0
    babe:	b.n	baa8 <memmove+0xa4>
    bac0:	mov	r3, r0
    bac2:	b.n	baaa <memmove+0xa6>
    bac4:	pop	{r4, r5, r6, r7, pc}
    bac6:	mov	r2, lr
    bac8:	b.n	baa8 <memmove+0xa4>
    baca:	nop

0000bacc <__malloc_lock>:
    bacc:	bx	lr
    bace:	nop

0000bad0 <__malloc_unlock>:
    bad0:	bx	lr
    bad2:	nop

0000bad4 <_realloc_r>:
    bad4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bad8:	mov	r7, r2
    bada:	sub	sp, #12
    badc:	cmp	r1, #0
    bade:	beq.w	bc64 <_realloc_r+0x190>
    bae2:	mov	r6, r1
    bae4:	mov	r9, r0
    bae6:	add.w	r5, r7, #11
    baea:	bl	bacc <__malloc_lock>
    baee:	ldr.w	lr, [r6, #-4]
    baf2:	cmp	r5, #22
    baf4:	bic.w	r4, lr, #3
    baf8:	sub.w	r8, r6, #8
    bafc:	bhi.n	bb80 <_realloc_r+0xac>
    bafe:	movs	r2, #16
    bb00:	mov	r5, r2
    bb02:	cmp	r7, r5
    bb04:	bhi.n	bb8a <_realloc_r+0xb6>
    bb06:	cmp	r4, r2
    bb08:	bge.n	bbf6 <_realloc_r+0x122>
    bb0a:	ldr	r3, [pc, #804]	; (be30 <_realloc_r+0x35c>)
    bb0c:	ldr	r1, [r3, #8]
    bb0e:	add.w	r0, r8, r4
    bb12:	cmp	r0, r1
    bb14:	ldr	r1, [r0, #4]
    bb16:	beq.w	bccc <_realloc_r+0x1f8>
    bb1a:	bic.w	r3, r1, #1
    bb1e:	add	r3, r0
    bb20:	ldr	r3, [r3, #4]
    bb22:	lsls	r3, r3, #31
    bb24:	bpl.n	bc22 <_realloc_r+0x14e>
    bb26:	tst.w	lr, #1
    bb2a:	beq.n	bb98 <_realloc_r+0xc4>
    bb2c:	mov	r1, r7
    bb2e:	mov	r0, r9
    bb30:	bl	b360 <_malloc_r>
    bb34:	mov	r7, r0
    bb36:	cbz	r0, bb72 <_realloc_r+0x9e>
    bb38:	ldr.w	r3, [r6, #-4]
    bb3c:	bic.w	r3, r3, #1
    bb40:	add	r3, r8
    bb42:	sub.w	r2, r0, #8
    bb46:	cmp	r2, r3
    bb48:	beq.w	bdd4 <_realloc_r+0x300>
    bb4c:	subs	r2, r4, #4
    bb4e:	cmp	r2, #36	; 0x24
    bb50:	bhi.w	bdb6 <_realloc_r+0x2e2>
    bb54:	cmp	r2, #19
    bb56:	bhi.w	bd62 <_realloc_r+0x28e>
    bb5a:	mov	r3, r0
    bb5c:	mov	r2, r6
    bb5e:	ldr	r1, [r2, #0]
    bb60:	str	r1, [r3, #0]
    bb62:	ldr	r1, [r2, #4]
    bb64:	str	r1, [r3, #4]
    bb66:	ldr	r2, [r2, #8]
    bb68:	str	r2, [r3, #8]
    bb6a:	mov	r1, r6
    bb6c:	mov	r0, r9
    bb6e:	bl	10890 <_free_r>
    bb72:	mov	r0, r9
    bb74:	bl	bad0 <__malloc_unlock>
    bb78:	mov	r0, r7
    bb7a:	add	sp, #12
    bb7c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bb80:	bic.w	r5, r5, #7
    bb84:	cmp	r5, #0
    bb86:	mov	r2, r5
    bb88:	bge.n	bb02 <_realloc_r+0x2e>
    bb8a:	movs	r3, #12
    bb8c:	movs	r0, #0
    bb8e:	str.w	r3, [r9]
    bb92:	add	sp, #12
    bb94:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bb98:	ldr.w	r3, [r6, #-8]
    bb9c:	rsb	sl, r3, r8
    bba0:	ldr.w	r3, [sl, #4]
    bba4:	bic.w	ip, r3, #3
    bba8:	add.w	r3, r4, ip
    bbac:	cmp	r3, r2
    bbae:	blt.n	bb2c <_realloc_r+0x58>
    bbb0:	mov	r7, sl
    bbb2:	ldr.w	r1, [sl, #12]
    bbb6:	ldr.w	r0, [r7, #8]!
    bbba:	subs	r2, r4, #4
    bbbc:	cmp	r2, #36	; 0x24
    bbbe:	str	r1, [r0, #12]
    bbc0:	str	r0, [r1, #8]
    bbc2:	bhi.w	bdf4 <_realloc_r+0x320>
    bbc6:	cmp	r2, #19
    bbc8:	bls.w	bdf0 <_realloc_r+0x31c>
    bbcc:	ldr	r1, [r6, #0]
    bbce:	str.w	r1, [sl, #8]
    bbd2:	ldr	r1, [r6, #4]
    bbd4:	str.w	r1, [sl, #12]
    bbd8:	cmp	r2, #27
    bbda:	bhi.w	be34 <_realloc_r+0x360>
    bbde:	adds	r6, #8
    bbe0:	add.w	r2, sl, #16
    bbe4:	ldr	r1, [r6, #0]
    bbe6:	str	r1, [r2, #0]
    bbe8:	ldr	r1, [r6, #4]
    bbea:	str	r1, [r2, #4]
    bbec:	ldr	r1, [r6, #8]
    bbee:	str	r1, [r2, #8]
    bbf0:	mov	r6, r7
    bbf2:	mov	r4, r3
    bbf4:	mov	r8, sl
    bbf6:	subs	r3, r4, r5
    bbf8:	cmp	r3, #15
    bbfa:	bhi.n	bc38 <_realloc_r+0x164>
    bbfc:	ldr.w	r3, [r8, #4]
    bc00:	and.w	r3, r3, #1
    bc04:	orrs	r3, r4
    bc06:	add	r4, r8
    bc08:	str.w	r3, [r8, #4]
    bc0c:	ldr	r3, [r4, #4]
    bc0e:	orr.w	r3, r3, #1
    bc12:	str	r3, [r4, #4]
    bc14:	mov	r0, r9
    bc16:	bl	bad0 <__malloc_unlock>
    bc1a:	mov	r0, r6
    bc1c:	add	sp, #12
    bc1e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bc22:	bic.w	r1, r1, #3
    bc26:	add	r1, r4
    bc28:	cmp	r1, r2
    bc2a:	blt.n	bc70 <_realloc_r+0x19c>
    bc2c:	ldr	r3, [r0, #12]
    bc2e:	ldr	r2, [r0, #8]
    bc30:	mov	r4, r1
    bc32:	str	r3, [r2, #12]
    bc34:	str	r2, [r3, #8]
    bc36:	b.n	bbf6 <_realloc_r+0x122>
    bc38:	ldr.w	r2, [r8, #4]
    bc3c:	add.w	r1, r8, r5
    bc40:	and.w	r2, r2, #1
    bc44:	orrs	r5, r2
    bc46:	orr.w	r2, r3, #1
    bc4a:	add	r3, r1
    bc4c:	str.w	r5, [r8, #4]
    bc50:	str	r2, [r1, #4]
    bc52:	ldr	r2, [r3, #4]
    bc54:	orr.w	r2, r2, #1
    bc58:	adds	r1, #8
    bc5a:	str	r2, [r3, #4]
    bc5c:	mov	r0, r9
    bc5e:	bl	10890 <_free_r>
    bc62:	b.n	bc14 <_realloc_r+0x140>
    bc64:	mov	r1, r2
    bc66:	add	sp, #12
    bc68:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bc6c:	b.w	b360 <_malloc_r>
    bc70:	tst.w	lr, #1
    bc74:	bne.w	bb2c <_realloc_r+0x58>
    bc78:	ldr.w	r3, [r6, #-8]
    bc7c:	rsb	sl, r3, r8
    bc80:	ldr.w	r3, [sl, #4]
    bc84:	bic.w	ip, r3, #3
    bc88:	add.w	lr, r1, ip
    bc8c:	cmp	lr, r2
    bc8e:	blt.n	bba8 <_realloc_r+0xd4>
    bc90:	ldr	r3, [r0, #12]
    bc92:	ldr	r2, [r0, #8]
    bc94:	mov	r7, sl
    bc96:	str	r3, [r2, #12]
    bc98:	str	r2, [r3, #8]
    bc9a:	ldr.w	r1, [r7, #8]!
    bc9e:	ldr.w	r3, [sl, #12]
    bca2:	str	r3, [r1, #12]
    bca4:	subs	r2, r4, #4
    bca6:	cmp	r2, #36	; 0x24
    bca8:	str	r1, [r3, #8]
    bcaa:	bhi.w	bde0 <_realloc_r+0x30c>
    bcae:	cmp	r2, #19
    bcb0:	bls.n	bd78 <_realloc_r+0x2a4>
    bcb2:	ldr	r3, [r6, #0]
    bcb4:	str.w	r3, [sl, #8]
    bcb8:	ldr	r3, [r6, #4]
    bcba:	str.w	r3, [sl, #12]
    bcbe:	cmp	r2, #27
    bcc0:	bhi.w	be04 <_realloc_r+0x330>
    bcc4:	adds	r6, #8
    bcc6:	add.w	r3, sl, #16
    bcca:	b.n	bd7a <_realloc_r+0x2a6>
    bccc:	bic.w	fp, r1, #3
    bcd0:	add	fp, r4
    bcd2:	add.w	r0, r5, #16
    bcd6:	cmp	fp, r0
    bcd8:	bge.n	bd8e <_realloc_r+0x2ba>
    bcda:	tst.w	lr, #1
    bcde:	bne.w	bb2c <_realloc_r+0x58>
    bce2:	ldr.w	r1, [r6, #-8]
    bce6:	rsb	sl, r1, r8
    bcea:	ldr.w	r1, [sl, #4]
    bcee:	bic.w	ip, r1, #3
    bcf2:	add	fp, ip
    bcf4:	cmp	r0, fp
    bcf6:	bgt.w	bba8 <_realloc_r+0xd4>
    bcfa:	mov	r7, sl
    bcfc:	ldr.w	r1, [sl, #12]
    bd00:	ldr.w	r0, [r7, #8]!
    bd04:	subs	r2, r4, #4
    bd06:	cmp	r2, #36	; 0x24
    bd08:	str	r1, [r0, #12]
    bd0a:	str	r0, [r1, #8]
    bd0c:	bhi.w	be78 <_realloc_r+0x3a4>
    bd10:	cmp	r2, #19
    bd12:	bls.w	be60 <_realloc_r+0x38c>
    bd16:	ldr	r1, [r6, #0]
    bd18:	str.w	r1, [sl, #8]
    bd1c:	ldr	r1, [r6, #4]
    bd1e:	str.w	r1, [sl, #12]
    bd22:	cmp	r2, #27
    bd24:	bhi.w	be86 <_realloc_r+0x3b2>
    bd28:	adds	r6, #8
    bd2a:	add.w	r2, sl, #16
    bd2e:	ldr	r1, [r6, #0]
    bd30:	str	r1, [r2, #0]
    bd32:	ldr	r1, [r6, #4]
    bd34:	str	r1, [r2, #4]
    bd36:	ldr	r1, [r6, #8]
    bd38:	str	r1, [r2, #8]
    bd3a:	add.w	r1, sl, r5
    bd3e:	rsb	r2, r5, fp
    bd42:	orr.w	r2, r2, #1
    bd46:	str	r1, [r3, #8]
    bd48:	str	r2, [r1, #4]
    bd4a:	ldr.w	r3, [sl, #4]
    bd4e:	and.w	r3, r3, #1
    bd52:	orrs	r5, r3
    bd54:	mov	r0, r9
    bd56:	str.w	r5, [sl, #4]
    bd5a:	bl	bad0 <__malloc_unlock>
    bd5e:	mov	r0, r7
    bd60:	b.n	bc1c <_realloc_r+0x148>
    bd62:	ldr	r3, [r6, #0]
    bd64:	str	r3, [r0, #0]
    bd66:	ldr	r3, [r6, #4]
    bd68:	str	r3, [r0, #4]
    bd6a:	cmp	r2, #27
    bd6c:	bhi.n	bdbe <_realloc_r+0x2ea>
    bd6e:	add.w	r3, r0, #8
    bd72:	add.w	r2, r6, #8
    bd76:	b.n	bb5e <_realloc_r+0x8a>
    bd78:	mov	r3, r7
    bd7a:	ldr	r2, [r6, #0]
    bd7c:	str	r2, [r3, #0]
    bd7e:	ldr	r2, [r6, #4]
    bd80:	str	r2, [r3, #4]
    bd82:	ldr	r2, [r6, #8]
    bd84:	str	r2, [r3, #8]
    bd86:	mov	r6, r7
    bd88:	mov	r4, lr
    bd8a:	mov	r8, sl
    bd8c:	b.n	bbf6 <_realloc_r+0x122>
    bd8e:	add.w	r1, r8, r5
    bd92:	rsb	fp, r5, fp
    bd96:	orr.w	r2, fp, #1
    bd9a:	str	r1, [r3, #8]
    bd9c:	str	r2, [r1, #4]
    bd9e:	ldr.w	r3, [r6, #-4]
    bda2:	and.w	r3, r3, #1
    bda6:	orrs	r5, r3
    bda8:	mov	r0, r9
    bdaa:	str.w	r5, [r6, #-4]
    bdae:	bl	bad0 <__malloc_unlock>
    bdb2:	mov	r0, r6
    bdb4:	b.n	bc1c <_realloc_r+0x148>
    bdb6:	mov	r1, r6
    bdb8:	bl	ba04 <memmove>
    bdbc:	b.n	bb6a <_realloc_r+0x96>
    bdbe:	ldr	r3, [r6, #8]
    bdc0:	str	r3, [r0, #8]
    bdc2:	ldr	r3, [r6, #12]
    bdc4:	str	r3, [r0, #12]
    bdc6:	cmp	r2, #36	; 0x24
    bdc8:	beq.n	be1c <_realloc_r+0x348>
    bdca:	add.w	r3, r0, #16
    bdce:	add.w	r2, r6, #16
    bdd2:	b.n	bb5e <_realloc_r+0x8a>
    bdd4:	ldr.w	r3, [r0, #-4]
    bdd8:	bic.w	r3, r3, #3
    bddc:	add	r4, r3
    bdde:	b.n	bbf6 <_realloc_r+0x122>
    bde0:	mov	r1, r6
    bde2:	mov	r0, r7
    bde4:	mov	r4, lr
    bde6:	mov	r8, sl
    bde8:	bl	ba04 <memmove>
    bdec:	mov	r6, r7
    bdee:	b.n	bbf6 <_realloc_r+0x122>
    bdf0:	mov	r2, r7
    bdf2:	b.n	bbe4 <_realloc_r+0x110>
    bdf4:	mov	r1, r6
    bdf6:	mov	r0, r7
    bdf8:	mov	r4, r3
    bdfa:	mov	r8, sl
    bdfc:	bl	ba04 <memmove>
    be00:	mov	r6, r7
    be02:	b.n	bbf6 <_realloc_r+0x122>
    be04:	ldr	r3, [r6, #8]
    be06:	str.w	r3, [sl, #16]
    be0a:	ldr	r3, [r6, #12]
    be0c:	str.w	r3, [sl, #20]
    be10:	cmp	r2, #36	; 0x24
    be12:	beq.n	be4c <_realloc_r+0x378>
    be14:	adds	r6, #16
    be16:	add.w	r3, sl, #24
    be1a:	b.n	bd7a <_realloc_r+0x2a6>
    be1c:	ldr	r3, [r6, #16]
    be1e:	str	r3, [r0, #16]
    be20:	ldr	r3, [r6, #20]
    be22:	str	r3, [r0, #20]
    be24:	add.w	r2, r6, #24
    be28:	add.w	r3, r0, #24
    be2c:	b.n	bb5e <_realloc_r+0x8a>
    be2e:	nop
    be30:	.word	0x1fff1998
    be34:	ldr	r1, [r6, #8]
    be36:	str.w	r1, [sl, #16]
    be3a:	ldr	r1, [r6, #12]
    be3c:	str.w	r1, [sl, #20]
    be40:	cmp	r2, #36	; 0x24
    be42:	beq.n	be64 <_realloc_r+0x390>
    be44:	adds	r6, #16
    be46:	add.w	r2, sl, #24
    be4a:	b.n	bbe4 <_realloc_r+0x110>
    be4c:	ldr	r3, [r6, #16]
    be4e:	str.w	r3, [sl, #24]
    be52:	ldr	r3, [r6, #20]
    be54:	str.w	r3, [sl, #28]
    be58:	adds	r6, #24
    be5a:	add.w	r3, sl, #32
    be5e:	b.n	bd7a <_realloc_r+0x2a6>
    be60:	mov	r2, r7
    be62:	b.n	bd2e <_realloc_r+0x25a>
    be64:	ldr	r2, [r6, #16]
    be66:	str.w	r2, [sl, #24]
    be6a:	ldr	r2, [r6, #20]
    be6c:	str.w	r2, [sl, #28]
    be70:	adds	r6, #24
    be72:	add.w	r2, sl, #32
    be76:	b.n	bbe4 <_realloc_r+0x110>
    be78:	mov	r1, r6
    be7a:	mov	r0, r7
    be7c:	str	r3, [sp, #4]
    be7e:	bl	ba04 <memmove>
    be82:	ldr	r3, [sp, #4]
    be84:	b.n	bd3a <_realloc_r+0x266>
    be86:	ldr	r1, [r6, #8]
    be88:	str.w	r1, [sl, #16]
    be8c:	ldr	r1, [r6, #12]
    be8e:	str.w	r1, [sl, #20]
    be92:	cmp	r2, #36	; 0x24
    be94:	beq.n	be9e <_realloc_r+0x3ca>
    be96:	adds	r6, #16
    be98:	add.w	r2, sl, #24
    be9c:	b.n	bd2e <_realloc_r+0x25a>
    be9e:	ldr	r2, [r6, #16]
    bea0:	str.w	r2, [sl, #24]
    bea4:	ldr	r2, [r6, #20]
    bea6:	str.w	r2, [sl, #28]
    beaa:	adds	r6, #24
    beac:	add.w	r2, sl, #32
    beb0:	b.n	bd2e <_realloc_r+0x25a>
    beb2:	nop

0000beb4 <_sbrk_r>:
    beb4:	push	{r3, r4, r5, lr}
    beb6:	ldr	r4, [pc, #28]	; (bed4 <_sbrk_r+0x20>)
    beb8:	movs	r3, #0
    beba:	mov	r5, r0
    bebc:	mov	r0, r1
    bebe:	str	r3, [r4, #0]
    bec0:	bl	9428 <_sbrk>
    bec4:	adds	r3, r0, #1
    bec6:	beq.n	beca <_sbrk_r+0x16>
    bec8:	pop	{r3, r4, r5, pc}
    beca:	ldr	r3, [r4, #0]
    becc:	cmp	r3, #0
    bece:	beq.n	bec8 <_sbrk_r+0x14>
    bed0:	str	r3, [r5, #0]
    bed2:	pop	{r3, r4, r5, pc}
    bed4:	.word	0x2001a85c

0000bed8 <sprintf>:
    bed8:	push	{r1, r2, r3}
    beda:	push	{r4, r5, r6, r7, lr}
    bedc:	sub	sp, #112	; 0x70
    bede:	add	r3, sp, #132	; 0x84
    bee0:	ldr	r1, [pc, #60]	; (bf20 <sprintf+0x48>)
    bee2:	ldr.w	r2, [r3], #4
    bee6:	str	r3, [sp, #4]
    bee8:	mov	r5, r0
    beea:	mvn.w	r4, #2147483648	; 0x80000000
    beee:	ldr	r0, [r1, #0]
    bef0:	str	r5, [sp, #8]
    bef2:	mov.w	r7, #520	; 0x208
    bef6:	movw	r6, #65535	; 0xffff
    befa:	add	r1, sp, #8
    befc:	str	r5, [sp, #24]
    befe:	strh.w	r7, [sp, #20]
    bf02:	str	r4, [sp, #16]
    bf04:	str	r4, [sp, #28]
    bf06:	strh.w	r6, [sp, #22]
    bf0a:	bl	d190 <_svfprintf_r>
    bf0e:	ldr	r3, [sp, #8]
    bf10:	movs	r2, #0
    bf12:	strb	r2, [r3, #0]
    bf14:	add	sp, #112	; 0x70
    bf16:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    bf1a:	add	sp, #12
    bf1c:	bx	lr
    bf1e:	nop
    bf20:	.word	0x1fff1828

0000bf24 <sscanf>:
    bf24:	push	{r1, r2, r3}
    bf26:	push	{r4, r5, r6, r7, lr}
    bf28:	sub	sp, #112	; 0x70
    bf2a:	add	r4, sp, #132	; 0x84
    bf2c:	mov.w	r2, #516	; 0x204
    bf30:	ldr.w	r6, [r4], #4
    bf34:	strh.w	r2, [sp, #20]
    bf38:	str	r0, [sp, #8]
    bf3a:	str	r0, [sp, #24]
    bf3c:	bl	bf80 <strlen>
    bf40:	ldr	r3, [pc, #48]	; (bf74 <sscanf+0x50>)
    bf42:	str	r4, [sp, #4]
    bf44:	mov	r5, r0
    bf46:	mov	r2, r6
    bf48:	ldr	r7, [pc, #44]	; (bf78 <sscanf+0x54>)
    bf4a:	ldr	r0, [r3, #0]
    bf4c:	str	r5, [sp, #12]
    bf4e:	mov	r3, r4
    bf50:	movw	r6, #65535	; 0xffff
    bf54:	movs	r4, #0
    bf56:	add	r1, sp, #8
    bf58:	str	r5, [sp, #28]
    bf5a:	str	r7, [sp, #40]	; 0x28
    bf5c:	str	r4, [sp, #56]	; 0x38
    bf5e:	str	r4, [sp, #76]	; 0x4c
    bf60:	strh.w	r6, [sp, #22]
    bf64:	bl	e874 <__ssvfscanf_r>
    bf68:	add	sp, #112	; 0x70
    bf6a:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    bf6e:	add	sp, #12
    bf70:	bx	lr
    bf72:	nop
    bf74:	.word	0x1fff1828
    bf78:	.word	0x0000bf7d

0000bf7c <__seofread>:
    bf7c:	movs	r0, #0
    bf7e:	bx	lr

0000bf80 <strlen>:
    bf80:	pld	[r0]
    bf84:	strd	r4, r5, [sp, #-8]!
    bf88:	bic.w	r1, r0, #7
    bf8c:	mvn.w	ip, #0
    bf90:	ands.w	r4, r0, #7
    bf94:	pld	[r1, #32]
    bf98:	bne.w	c02e <strlen+0xae>
    bf9c:	mov.w	r4, #0
    bfa0:	mvn.w	r0, #7
    bfa4:	ldrd	r2, r3, [r1]
    bfa8:	pld	[r1, #64]	; 0x40
    bfac:	add.w	r0, r0, #8
    bfb0:	uadd8	r2, r2, ip
    bfb4:	sel	r2, r4, ip
    bfb8:	uadd8	r3, r3, ip
    bfbc:	sel	r3, r2, ip
    bfc0:	cbnz	r3, c016 <strlen+0x96>
    bfc2:	ldrd	r2, r3, [r1, #8]
    bfc6:	uadd8	r2, r2, ip
    bfca:	add.w	r0, r0, #8
    bfce:	sel	r2, r4, ip
    bfd2:	uadd8	r3, r3, ip
    bfd6:	sel	r3, r2, ip
    bfda:	cbnz	r3, c016 <strlen+0x96>
    bfdc:	ldrd	r2, r3, [r1, #16]
    bfe0:	uadd8	r2, r2, ip
    bfe4:	add.w	r0, r0, #8
    bfe8:	sel	r2, r4, ip
    bfec:	uadd8	r3, r3, ip
    bff0:	sel	r3, r2, ip
    bff4:	cbnz	r3, c016 <strlen+0x96>
    bff6:	ldrd	r2, r3, [r1, #24]
    bffa:	add.w	r1, r1, #32
    bffe:	uadd8	r2, r2, ip
    c002:	add.w	r0, r0, #8
    c006:	sel	r2, r4, ip
    c00a:	uadd8	r3, r3, ip
    c00e:	sel	r3, r2, ip
    c012:	cmp	r3, #0
    c014:	beq.n	bfa4 <strlen+0x24>
    c016:	cmp	r2, #0
    c018:	itt	eq
    c01a:	addeq	r0, #4
    c01c:	moveq	r2, r3
    c01e:	rev	r2, r2
    c020:	clz	r2, r2
    c024:	ldrd	r4, r5, [sp], #8
    c028:	add.w	r0, r0, r2, lsr #3
    c02c:	bx	lr
    c02e:	ldrd	r2, r3, [r1]
    c032:	and.w	r5, r4, #3
    c036:	rsb	r0, r4, #0
    c03a:	mov.w	r5, r5, lsl #3
    c03e:	tst.w	r4, #4
    c042:	pld	[r1, #64]	; 0x40
    c046:	lsl.w	r5, ip, r5
    c04a:	orn	r2, r2, r5
    c04e:	itt	ne
    c050:	ornne	r3, r3, r5
    c054:	movne	r2, ip
    c056:	mov.w	r4, #0
    c05a:	b.n	bfb0 <strlen+0x30>

0000c05c <strncmp>:
    c05c:	cmp	r2, #0
    c05e:	beq.n	c0e4 <strncmp+0x88>
    c060:	orr.w	r3, r0, r1
    c064:	ands.w	r3, r3, #3
    c068:	push	{r4, r5, r6, r7}
    c06a:	bne.n	c0b8 <strncmp+0x5c>
    c06c:	cmp	r2, #3
    c06e:	bls.n	c0b8 <strncmp+0x5c>
    c070:	ldr	r4, [r0, #0]
    c072:	ldr	r5, [r1, #0]
    c074:	cmp	r4, r5
    c076:	bne.n	c0b8 <strncmp+0x5c>
    c078:	subs	r2, #4
    c07a:	beq.n	c0e8 <strncmp+0x8c>
    c07c:	sub.w	r5, r4, #16843009	; 0x1010101
    c080:	bic.w	r4, r5, r4
    c084:	tst.w	r4, #2155905152	; 0x80808080
    c088:	bne.n	c0ee <strncmp+0x92>
    c08a:	adds	r7, r0, #4
    c08c:	adds	r5, r1, #4
    c08e:	b.n	c0ac <strncmp+0x50>
    c090:	ldr.w	r3, [r7], #4
    c094:	ldr	r6, [r1, #0]
    c096:	sub.w	r4, r3, #16843009	; 0x1010101
    c09a:	cmp	r3, r6
    c09c:	bic.w	r4, r4, r3
    c0a0:	bne.n	c0b8 <strncmp+0x5c>
    c0a2:	subs	r2, #4
    c0a4:	beq.n	c0e8 <strncmp+0x8c>
    c0a6:	tst.w	r4, #2155905152	; 0x80808080
    c0aa:	bne.n	c0f4 <strncmp+0x98>
    c0ac:	cmp	r2, #3
    c0ae:	mov	r1, r5
    c0b0:	mov	r0, r7
    c0b2:	add.w	r5, r5, #4
    c0b6:	bhi.n	c090 <strncmp+0x34>
    c0b8:	ldrb	r3, [r0, #0]
    c0ba:	ldrb	r4, [r1, #0]
    c0bc:	cmp	r4, r3
    c0be:	add.w	r2, r2, #4294967295
    c0c2:	bne.n	c0de <strncmp+0x82>
    c0c4:	cbz	r2, c0e8 <strncmp+0x8c>
    c0c6:	cbnz	r4, c0ce <strncmp+0x72>
    c0c8:	b.n	c0f8 <strncmp+0x9c>
    c0ca:	cbz	r2, c0e8 <strncmp+0x8c>
    c0cc:	cbz	r3, c0ee <strncmp+0x92>
    c0ce:	ldrb.w	r3, [r0, #1]!
    c0d2:	ldrb.w	r4, [r1, #1]!
    c0d6:	cmp	r3, r4
    c0d8:	add.w	r2, r2, #4294967295
    c0dc:	beq.n	c0ca <strncmp+0x6e>
    c0de:	subs	r0, r3, r4
    c0e0:	pop	{r4, r5, r6, r7}
    c0e2:	bx	lr
    c0e4:	mov	r0, r2
    c0e6:	bx	lr
    c0e8:	mov	r0, r2
    c0ea:	pop	{r4, r5, r6, r7}
    c0ec:	bx	lr
    c0ee:	mov	r0, r3
    c0f0:	pop	{r4, r5, r6, r7}
    c0f2:	bx	lr
    c0f4:	movs	r0, #0
    c0f6:	b.n	c0e0 <strncmp+0x84>
    c0f8:	mov	r0, r4
    c0fa:	b.n	c0e0 <strncmp+0x84>

0000c0fc <sulp>:
    c0fc:	push	{r4, r5, r6, lr}
    c0fe:	mov	r4, r0
    c100:	mov	r5, r1
    c102:	vmov	d0, r4, r5
    c106:	mov	r6, r2
    c108:	bl	11860 <__ulp>
    c10c:	vmov	r0, r1, d0
    c110:	cbz	r6, c132 <sulp+0x36>
    c112:	ubfx	r3, r5, #20, #11
    c116:	rsb	r3, r3, #107	; 0x6b
    c11a:	cmp	r3, #0
    c11c:	ble.n	c132 <sulp+0x36>
    c11e:	lsls	r3, r3, #20
    c120:	add.w	r5, r3, #1069547520	; 0x3fc00000
    c124:	movs	r4, #0
    c126:	add.w	r5, r5, #3145728	; 0x300000
    c12a:	mov	r2, r4
    c12c:	mov	r3, r5
    c12e:	bl	a8e0 <__aeabi_dmul>
    c132:	pop	{r4, r5, r6, pc}
    c134:			; <UNDEFINED> instruction: 0xffffffff

0000c138 <_strtod_l>:
    c138:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c13c:	mov	r5, r3
    c13e:	sub	sp, #132	; 0x84
    c140:	movs	r3, #0
    c142:	mov	fp, r0
    c144:	mov	r0, r5
    c146:	mov	r6, r1
    c148:	str	r2, [sp, #24]
    c14a:	str	r3, [sp, #112]	; 0x70
    c14c:	bl	111e4 <__localeconv_l>
    c150:	movs	r4, #0
    c152:	movs	r3, #0
    c154:	mov	sl, r0
    c156:	ldr	r0, [r0, #0]
    c158:	strd	r3, r4, [sp, #16]
    c15c:	bl	bf80 <strlen>
    c160:	str	r6, [sp, #108]	; 0x6c
    c162:	mov	r9, r0
    c164:	mov	r2, r6
    c166:	mov	r4, r2
    c168:	ldrb.w	r7, [r2], #1
    c16c:	cmp	r7, #45	; 0x2d
    c16e:	bhi.w	c2d0 <_strtod_l+0x198>
    c172:	tbb	[pc, r7]
    c176:	.short	0xad17
    c178:	.word	0xadadadad
    c17c:	.word	0x81adadad
    c180:	.word	0x81818181
    c184:	.word	0xadadadad
    c188:	.word	0xadadadad
    c18c:	.word	0xadadadad
    c190:	.word	0xadadadad
    c194:	.word	0xad81adad
    c198:	.word	0xadadadad
    c19c:	.word	0xadadadad
    c1a0:	.word	0x7ead2bad
    c1a4:	ldr	r3, [sp, #24]
    c1a6:	mov.w	r8, #0
    c1aa:	mov.w	r9, #0
    c1ae:	cbz	r3, c1c2 <_strtod_l+0x8a>
    c1b0:	movs	r3, #0
    c1b2:	str	r3, [sp, #28]
    c1b4:	ldr	r3, [sp, #24]
    c1b6:	str	r6, [r3, #0]
    c1b8:	ldr	r3, [sp, #28]
    c1ba:	cbz	r3, c1c2 <_strtod_l+0x8a>
    c1bc:	add.w	r3, r9, #2147483648	; 0x80000000
    c1c0:	mov	r9, r3
    c1c2:	vmov	d0, r8, r9
    c1c6:	add	sp, #132	; 0x84
    c1c8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c1cc:	movs	r3, #0
    c1ce:	str	r3, [sp, #28]
    c1d0:	adds	r2, r4, #1
    c1d2:	str	r2, [sp, #108]	; 0x6c
    c1d4:	ldrb	r7, [r4, #1]
    c1d6:	cmp	r7, #0
    c1d8:	beq.n	c1a4 <_strtod_l+0x6c>
    c1da:	cmp	r7, #48	; 0x30
    c1dc:	mov	r4, r2
    c1de:	beq.n	c2d8 <_strtod_l+0x1a0>
    c1e0:	movs	r3, #0
    c1e2:	str	r4, [sp, #32]
    c1e4:	str	r3, [sp, #40]	; 0x28
    c1e6:	sub.w	r3, r7, #48	; 0x30
    c1ea:	cmp	r3, #9
    c1ec:	bhi.w	c9fe <_strtod_l+0x8c6>
    c1f0:	mov.w	r8, #0
    c1f4:	mov	r0, r4
    c1f6:	mov	r5, r8
    c1f8:	mov	r4, r8
    c1fa:	cmp	r4, #8
    c1fc:	it	gt
    c1fe:	addgt.w	r8, r8, r8, lsl #2
    c202:	add.w	r3, r5, r5, lsl #2
    c206:	add.w	r0, r0, #1
    c20a:	add.w	r3, r7, r3, lsl #1
    c20e:	str	r0, [sp, #108]	; 0x6c
    c210:	itt	gt
    c212:	addgt.w	r7, r7, r8, lsl #1
    c216:	subgt.w	r8, r7, #48	; 0x30
    c21a:	ldrb	r7, [r0, #0]
    c21c:	it	le
    c21e:	suble.w	r5, r3, #48	; 0x30
    c222:	sub.w	r3, r7, #48	; 0x30
    c226:	cmp	r3, #9
    c228:	add.w	r4, r4, #1
    c22c:	bls.n	c1fa <_strtod_l+0xc2>
    c22e:	ldr.w	r1, [sl]
    c232:	mov	r2, r9
    c234:	bl	c05c <strncmp>
    c238:	cbz	r0, c27c <_strtod_l+0x144>
    c23a:	movs	r0, #0
    c23c:	mov	r3, r7
    c23e:	mov	r9, r0
    c240:	mov	r7, r0
    c242:	mov	sl, r4
    c244:	cmp	r3, #101	; 0x65
    c246:	beq.w	c3ae <_strtod_l+0x276>
    c24a:	cmp	r3, #69	; 0x45
    c24c:	beq.w	c3ae <_strtod_l+0x276>
    c250:	movs	r2, #0
    c252:	cmp	r4, #0
    c254:	bne.n	c2fc <_strtod_l+0x1c4>
    c256:	cbnz	r0, c260 <_strtod_l+0x128>
    c258:	ldr	r2, [sp, #40]	; 0x28
    c25a:	cmp	r2, #0
    c25c:	beq.w	c802 <_strtod_l+0x6ca>
    c260:	mov.w	r8, #0
    c264:	mov.w	r9, #0
    c268:	ldr	r3, [sp, #24]
    c26a:	cmp	r3, #0
    c26c:	beq.n	c1b8 <_strtod_l+0x80>
    c26e:	ldr	r6, [sp, #108]	; 0x6c
    c270:	b.n	c1b4 <_strtod_l+0x7c>
    c272:	movs	r3, #1
    c274:	str	r3, [sp, #28]
    c276:	b.n	c1d0 <_strtod_l+0x98>
    c278:	str	r2, [sp, #108]	; 0x6c
    c27a:	b.n	c166 <_strtod_l+0x2e>
    c27c:	ldr	r3, [sp, #108]	; 0x6c
    c27e:	add.w	r2, r3, r9
    c282:	str	r2, [sp, #108]	; 0x6c
    c284:	ldrb.w	r3, [r3, r9]
    c288:	mov	r7, r0
    c28a:	mov	sl, r4
    c28c:	sub.w	r2, r3, #48	; 0x30
    c290:	cmp	r2, #9
    c292:	bhi.w	c788 <_strtod_l+0x650>
    c296:	adds	r1, r0, #1
    c298:	mov	r3, r2
    c29a:	cmp	r2, #0
    c29c:	beq.w	cfde <_strtod_l+0xea6>
    c2a0:	cmp	r1, #1
    c2a2:	add	r7, r1
    c2a4:	it	ne
    c2a6:	addne	r0, r0, r4
    c2a8:	bne.n	c2b6 <_strtod_l+0x17e>
    c2aa:	b.w	cfd6 <_strtod_l+0xe9e>
    c2ae:	lsls	r5, r1, #1
    c2b0:	cmp	r4, r0
    c2b2:	beq.w	cc2c <_strtod_l+0xaf4>
    c2b6:	adds	r4, #1
    c2b8:	subs	r1, r4, #1
    c2ba:	cmp	r1, #8
    c2bc:	add.w	r1, r5, r5, lsl #2
    c2c0:	ble.n	c2ae <_strtod_l+0x176>
    c2c2:	cmp	r4, #16
    c2c4:	itt	le
    c2c6:	addle.w	r8, r8, r8, lsl #2
    c2ca:	movle.w	r8, r8, lsl #1
    c2ce:	b.n	c2b0 <_strtod_l+0x178>
    c2d0:	movs	r3, #0
    c2d2:	cmp	r7, #48	; 0x30
    c2d4:	str	r3, [sp, #28]
    c2d6:	bne.n	c1e0 <_strtod_l+0xa8>
    c2d8:	ldrb	r3, [r4, #1]
    c2da:	cmp	r3, #88	; 0x58
    c2dc:	beq.w	c9c6 <_strtod_l+0x88e>
    c2e0:	cmp	r3, #120	; 0x78
    c2e2:	beq.w	c9c6 <_strtod_l+0x88e>
    c2e6:	adds	r4, #1
    c2e8:	str	r4, [sp, #108]	; 0x6c
    c2ea:	ldrb	r7, [r4, #0]
    c2ec:	cmp	r7, #48	; 0x30
    c2ee:	beq.n	c2e6 <_strtod_l+0x1ae>
    c2f0:	cmp	r7, #0
    c2f2:	beq.n	c260 <_strtod_l+0x128>
    c2f4:	movs	r3, #1
    c2f6:	str	r4, [sp, #32]
    c2f8:	str	r3, [sp, #40]	; 0x28
    c2fa:	b.n	c1e6 <_strtod_l+0xae>
    c2fc:	cmp	r4, #16
    c2fe:	sub.w	r3, r2, r7
    c302:	mov	r0, r5
    c304:	mov	r9, r4
    c306:	str	r3, [sp, #44]	; 0x2c
    c308:	it	ge
    c30a:	movge.w	r9, #16
    c30e:	bl	a7f4 <__aeabi_ui2d>
    c312:	cmp.w	sl, #0
    c316:	it	eq
    c318:	moveq	sl, r4
    c31a:	cmp.w	r9, #9
    c31e:	strd	r0, r1, [sp, #16]
    c322:	ble.n	c34c <_strtod_l+0x214>
    c324:	ldr	r3, [pc, #292]	; (c44c <_strtod_l+0x314>)
    c326:	add.w	r3, r3, r9, lsl #3
    c32a:	ldrd	r2, r3, [r3, #-72]	; 0x48
    c32e:	bl	a8e0 <__aeabi_dmul>
    c332:	mov	r6, r0
    c334:	mov	r0, r8
    c336:	mov	r7, r1
    c338:	bl	a7f4 <__aeabi_ui2d>
    c33c:	mov	r2, r0
    c33e:	mov	r3, r1
    c340:	mov	r0, r6
    c342:	mov	r1, r7
    c344:	bl	a57c <__adddf3>
    c348:	strd	r0, r1, [sp, #16]
    c34c:	cmp	r4, #15
    c34e:	bgt.w	c45c <_strtod_l+0x324>
    c352:	ldr	r3, [sp, #44]	; 0x2c
    c354:	cmp	r3, #0
    c356:	beq.n	c3a8 <_strtod_l+0x270>
    c358:	ble.w	cd94 <_strtod_l+0xc5c>
    c35c:	ldr	r3, [sp, #44]	; 0x2c
    c35e:	cmp	r3, #22
    c360:	bgt.w	cc60 <_strtod_l+0xb28>
    c364:	ldr	r7, [pc, #228]	; (c44c <_strtod_l+0x314>)
    c366:	add.w	r7, r7, r3, lsl #3
    c36a:	ldrd	r0, r1, [r7]
    c36e:	ldrd	r2, r3, [sp, #16]
    c372:	bl	a8e0 <__aeabi_dmul>
    c376:	mov	r8, r0
    c378:	mov	r9, r1
    c37a:	b.n	c268 <_strtod_l+0x130>
    c37c:	add	r0, sp, #108	; 0x6c
    c37e:	ldr	r1, [pc, #208]	; (c450 <_strtod_l+0x318>)
    c380:	bl	11018 <__match>
    c384:	cmp	r0, #0
    c386:	beq.w	c1a4 <_strtod_l+0x6c>
    c38a:	ldr	r3, [sp, #108]	; 0x6c
    c38c:	ldr	r1, [pc, #196]	; (c454 <_strtod_l+0x31c>)
    c38e:	subs	r3, #1
    c390:	add	r0, sp, #108	; 0x6c
    c392:	str	r3, [sp, #108]	; 0x6c
    c394:	bl	11018 <__match>
    c398:	cbnz	r0, c3a0 <_strtod_l+0x268>
    c39a:	ldr	r3, [sp, #108]	; 0x6c
    c39c:	adds	r3, #1
    c39e:	str	r3, [sp, #108]	; 0x6c
    c3a0:	ldr	r3, [pc, #180]	; (c458 <_strtod_l+0x320>)
    c3a2:	str	r3, [sp, #20]
    c3a4:	movs	r3, #0
    c3a6:	str	r3, [sp, #16]
    c3a8:	ldrd	r8, r9, [sp, #16]
    c3ac:	b.n	c268 <_strtod_l+0x130>
    c3ae:	cmp	r4, #0
    c3b0:	beq.w	c748 <_strtod_l+0x610>
    c3b4:	ldr	r6, [sp, #108]	; 0x6c
    c3b6:	adds	r3, r6, #1
    c3b8:	str	r3, [sp, #108]	; 0x6c
    c3ba:	ldrb	r3, [r6, #1]
    c3bc:	cmp	r3, #43	; 0x2b
    c3be:	beq.w	c97c <_strtod_l+0x844>
    c3c2:	cmp	r3, #45	; 0x2d
    c3c4:	beq.w	c7f2 <_strtod_l+0x6ba>
    c3c8:	mov.w	ip, #0
    c3cc:	sub.w	r2, r3, #48	; 0x30
    c3d0:	cmp	r2, #9
    c3d2:	bhi.w	c976 <_strtod_l+0x83e>
    c3d6:	cmp	r3, #48	; 0x30
    c3d8:	bne.n	c3e6 <_strtod_l+0x2ae>
    c3da:	ldr	r2, [sp, #108]	; 0x6c
    c3dc:	adds	r2, #1
    c3de:	str	r2, [sp, #108]	; 0x6c
    c3e0:	ldrb	r3, [r2, #0]
    c3e2:	cmp	r3, #48	; 0x30
    c3e4:	beq.n	c3dc <_strtod_l+0x2a4>
    c3e6:	sub.w	r2, r3, #49	; 0x31
    c3ea:	cmp	r2, #8
    c3ec:	bhi.w	c250 <_strtod_l+0x118>
    c3f0:	ldr	r2, [sp, #108]	; 0x6c
    c3f2:	str	r2, [sp, #48]	; 0x30
    c3f4:	adds	r1, r2, #1
    c3f6:	subs	r3, #48	; 0x30
    c3f8:	str	r1, [sp, #108]	; 0x6c
    c3fa:	str	r3, [sp, #44]	; 0x2c
    c3fc:	ldrb	r3, [r2, #1]
    c3fe:	sub.w	lr, r3, #48	; 0x30
    c402:	cmp.w	lr, #9
    c406:	bhi.n	c428 <_strtod_l+0x2f0>
    c408:	ldr	r2, [sp, #44]	; 0x2c
    c40a:	adds	r1, #1
    c40c:	str	r1, [sp, #108]	; 0x6c
    c40e:	add.w	r2, r2, r2, lsl #2
    c412:	add.w	r2, r3, r2, lsl #1
    c416:	ldrb	r3, [r1, #0]
    c418:	sub.w	lr, r3, #48	; 0x30
    c41c:	cmp.w	lr, #9
    c420:	sub.w	r2, r2, #48	; 0x30
    c424:	bls.n	c40a <_strtod_l+0x2d2>
    c426:	str	r2, [sp, #44]	; 0x2c
    c428:	ldr	r2, [sp, #48]	; 0x30
    c42a:	subs	r1, r1, r2
    c42c:	cmp	r1, #8
    c42e:	bgt.w	cc4e <_strtod_l+0xb16>
    c432:	ldr	r2, [sp, #44]	; 0x2c
    c434:	movw	r1, #19999	; 0x4e1f
    c438:	cmp	r2, r1
    c43a:	it	ge
    c43c:	movge	r2, r1
    c43e:	cmp.w	ip, #0
    c442:	beq.w	c252 <_strtod_l+0x11a>
    c446:	negs	r2, r2
    c448:	b.n	c252 <_strtod_l+0x11a>
    c44a:	nop
    c44c:	.word	0x00013428
    c450:	.word	0x00013134
    c454:	.word	0x00013138
    c458:	.word	0x7ff00000
    c45c:	ldr	r3, [sp, #44]	; 0x2c
    c45e:	rsb	r9, r9, r4
    c462:	add	r9, r3
    c464:	cmp.w	r9, #0
    c468:	ble.w	cb7a <_strtod_l+0xa42>
    c46c:	ands.w	r1, r9, #15
    c470:	beq.n	c488 <_strtod_l+0x350>
    c472:	ldr	r3, [pc, #756]	; (c768 <_strtod_l+0x630>)
    c474:	add.w	r1, r3, r1, lsl #3
    c478:	ldrd	r0, r1, [r1]
    c47c:	ldrd	r2, r3, [sp, #16]
    c480:	bl	a8e0 <__aeabi_dmul>
    c484:	strd	r0, r1, [sp, #16]
    c488:	bics.w	r6, r9, #15
    c48c:	bne.w	c8b0 <_strtod_l+0x778>
    c490:	movs	r3, #0
    c492:	str	r3, [sp, #40]	; 0x28
    c494:	str	r5, [sp, #0]
    c496:	mov	r3, r4
    c498:	mov	r2, sl
    c49a:	ldr	r1, [sp, #32]
    c49c:	mov	r0, fp
    c49e:	bl	11340 <__s2b>
    c4a2:	str	r0, [sp, #72]	; 0x48
    c4a4:	cmp	r0, #0
    c4a6:	beq.w	caf6 <_strtod_l+0x9be>
    c4aa:	ldr	r2, [sp, #44]	; 0x2c
    c4ac:	movs	r7, #0
    c4ae:	cmp	r2, #0
    c4b0:	rsb	r3, r2, #0
    c4b4:	it	ge
    c4b6:	movge	r3, r7
    c4b8:	str	r3, [sp, #48]	; 0x30
    c4ba:	bic.w	r3, r2, r2, asr #31
    c4be:	str	r3, [sp, #44]	; 0x2c
    c4c0:	mov	sl, r7
    c4c2:	ldr	r4, [sp, #72]	; 0x48
    c4c4:	mov	r0, fp
    c4c6:	ldr	r1, [r4, #4]
    c4c8:	bl	11260 <_Balloc>
    c4cc:	mov	r6, r0
    c4ce:	cmp	r0, #0
    c4d0:	beq.w	c988 <_strtod_l+0x850>
    c4d4:	ldr	r2, [r4, #16]
    c4d6:	vldr	d7, [sp, #16]
    c4da:	adds	r2, #2
    c4dc:	lsls	r2, r2, #2
    c4de:	add.w	r1, r4, #12
    c4e2:	adds	r0, #12
    c4e4:	vstr	d7, [sp, #32]
    c4e8:	bl	8f3c <memcpy>
    c4ec:	vldr	d0, [sp, #32]
    c4f0:	add	r2, sp, #120	; 0x78
    c4f2:	add	r1, sp, #116	; 0x74
    c4f4:	mov	r0, fp
    c4f6:	bl	11984 <__d2b>
    c4fa:	str	r0, [sp, #112]	; 0x70
    c4fc:	cmp	r0, #0
    c4fe:	beq.w	c98a <_strtod_l+0x852>
    c502:	movs	r1, #1
    c504:	mov	r0, fp
    c506:	bl	11474 <__i2b>
    c50a:	mov	sl, r0
    c50c:	cmp	r0, #0
    c50e:	beq.w	c988 <_strtod_l+0x850>
    c512:	ldr	r2, [sp, #116]	; 0x74
    c514:	cmp	r2, #0
    c516:	blt.w	c780 <_strtod_l+0x648>
    c51a:	ldr	r3, [sp, #48]	; 0x30
    c51c:	ldr	r4, [sp, #44]	; 0x2c
    c51e:	adds	r5, r3, r2
    c520:	ldr	r0, [sp, #40]	; 0x28
    c522:	ldr	r3, [sp, #120]	; 0x78
    c524:	ldr	r1, [pc, #580]	; (c76c <_strtod_l+0x634>)
    c526:	subs	r2, r2, r0
    c528:	add	r2, r3
    c52a:	subs	r2, #1
    c52c:	cmp	r2, r1
    c52e:	rsb	r3, r3, #54	; 0x36
    c532:	bge.w	c712 <_strtod_l+0x5da>
    c536:	subs	r1, r1, r2
    c538:	cmp	r1, #31
    c53a:	sub.w	r3, r3, r1
    c53e:	bgt.w	c78e <_strtod_l+0x656>
    c542:	movs	r2, #1
    c544:	lsls	r2, r1
    c546:	str	r2, [sp, #56]	; 0x38
    c548:	movs	r2, #0
    c54a:	str	r2, [sp, #76]	; 0x4c
    c54c:	add.w	r9, r5, r3
    c550:	add	r4, r3
    c552:	ldr	r3, [sp, #40]	; 0x28
    c554:	cmp	r5, r9
    c556:	mov	r2, r5
    c558:	add	r4, r3
    c55a:	it	ge
    c55c:	movge	r2, r9
    c55e:	cmp	r2, r4
    c560:	it	ge
    c562:	movge	r2, r4
    c564:	cmp	r2, #0
    c566:	ble.n	c570 <_strtod_l+0x438>
    c568:	rsb	r9, r2, r9
    c56c:	subs	r4, r4, r2
    c56e:	subs	r5, r5, r2
    c570:	ldr	r3, [sp, #48]	; 0x30
    c572:	cbz	r3, c5a4 <_strtod_l+0x46c>
    c574:	mov	r1, sl
    c576:	mov	r2, r3
    c578:	mov	r0, fp
    c57a:	bl	115b8 <__pow5mult>
    c57e:	mov	sl, r0
    c580:	cmp	r0, #0
    c582:	beq.w	c988 <_strtod_l+0x850>
    c586:	mov	r1, r0
    c588:	ldr	r2, [sp, #112]	; 0x70
    c58a:	mov	r0, fp
    c58c:	bl	11488 <__multiply>
    c590:	cmp	r0, #0
    c592:	beq.w	c988 <_strtod_l+0x850>
    c596:	str	r0, [sp, #52]	; 0x34
    c598:	ldr	r1, [sp, #112]	; 0x70
    c59a:	mov	r0, fp
    c59c:	bl	112ac <_Bfree>
    c5a0:	ldr	r2, [sp, #52]	; 0x34
    c5a2:	str	r2, [sp, #112]	; 0x70
    c5a4:	cmp.w	r9, #0
    c5a8:	ble.n	c5bc <_strtod_l+0x484>
    c5aa:	mov	r2, r9
    c5ac:	ldr	r1, [sp, #112]	; 0x70
    c5ae:	mov	r0, fp
    c5b0:	bl	11658 <__lshift>
    c5b4:	str	r0, [sp, #112]	; 0x70
    c5b6:	cmp	r0, #0
    c5b8:	beq.w	c98a <_strtod_l+0x852>
    c5bc:	ldr	r3, [sp, #44]	; 0x2c
    c5be:	cbz	r3, c5d2 <_strtod_l+0x49a>
    c5c0:	mov	r1, r6
    c5c2:	ldr	r2, [sp, #44]	; 0x2c
    c5c4:	mov	r0, fp
    c5c6:	bl	115b8 <__pow5mult>
    c5ca:	mov	r6, r0
    c5cc:	cmp	r0, #0
    c5ce:	beq.w	c988 <_strtod_l+0x850>
    c5d2:	cmp	r4, #0
    c5d4:	ble.n	c5e8 <_strtod_l+0x4b0>
    c5d6:	mov	r1, r6
    c5d8:	mov	r2, r4
    c5da:	mov	r0, fp
    c5dc:	bl	11658 <__lshift>
    c5e0:	mov	r6, r0
    c5e2:	cmp	r0, #0
    c5e4:	beq.w	c988 <_strtod_l+0x850>
    c5e8:	cmp	r5, #0
    c5ea:	ble.n	c5fe <_strtod_l+0x4c6>
    c5ec:	mov	r1, sl
    c5ee:	mov	r2, r5
    c5f0:	mov	r0, fp
    c5f2:	bl	11658 <__lshift>
    c5f6:	mov	sl, r0
    c5f8:	cmp	r0, #0
    c5fa:	beq.w	c988 <_strtod_l+0x850>
    c5fe:	mov	r2, r6
    c600:	ldr	r1, [sp, #112]	; 0x70
    c602:	mov	r0, fp
    c604:	bl	1174c <__mdiff>
    c608:	mov	r7, r0
    c60a:	cmp	r0, #0
    c60c:	beq.w	c988 <_strtod_l+0x850>
    c610:	movs	r3, #0
    c612:	ldr	r2, [r0, #12]
    c614:	str	r3, [r0, #12]
    c616:	mov	r1, sl
    c618:	str	r2, [sp, #52]	; 0x34
    c61a:	bl	11708 <__mcmp>
    c61e:	cmp	r0, #0
    c620:	blt.w	ce3e <_strtod_l+0xd06>
    c624:	beq.w	cdb8 <_strtod_l+0xc80>
    c628:	mov	r1, sl
    c62a:	mov	r0, r7
    c62c:	bl	11a40 <__ratio>
    c630:	vmov	r4, r5, d0
    c634:	movs	r2, #0
    c636:	mov.w	r3, #1073741824	; 0x40000000
    c63a:	vmov	r0, s0
    c63e:	mov	r1, r5
    c640:	bl	add8 <__aeabi_dcmple>
    c644:	cmp	r0, #0
    c646:	beq.n	c71c <_strtod_l+0x5e4>
    c648:	ldr	r3, [sp, #52]	; 0x34
    c64a:	cmp	r3, #0
    c64c:	beq.w	c79e <_strtod_l+0x666>
    c650:	vldr	d7, [pc, #260]	; c758 <_strtod_l+0x620>
    c654:	ldr	r3, [sp, #20]
    c656:	ldr	r5, [pc, #280]	; (c770 <_strtod_l+0x638>)
    c658:	vstr	d7, [sp, #56]	; 0x38
    c65c:	movs	r4, #0
    c65e:	mov	r8, r3
    c660:	ldr.w	r9, [pc, #276]	; c778 <_strtod_l+0x640>
    c664:	ldr	r3, [pc, #268]	; (c774 <_strtod_l+0x63c>)
    c666:	and.w	r9, r8, r9
    c66a:	cmp	r9, r3
    c66c:	beq.w	ca9c <_strtod_l+0x964>
    c670:	ldr	r3, [sp, #40]	; 0x28
    c672:	cbz	r3, c6c0 <_strtod_l+0x588>
    c674:	cmp.w	r9, #111149056	; 0x6a00000
    c678:	bhi.n	c6c0 <_strtod_l+0x588>
    c67a:	add	r3, pc, #228	; (adr r3, c760 <_strtod_l+0x628>)
    c67c:	ldrd	r2, r3, [r3]
    c680:	ldrd	r0, r1, [sp, #56]	; 0x38
    c684:	bl	add8 <__aeabi_dcmple>
    c688:	cbz	r0, c6b8 <_strtod_l+0x580>
    c68a:	ldrd	r0, r1, [sp, #56]	; 0x38
    c68e:	bl	ae90 <__aeabi_d2uiz>
    c692:	cmp	r0, #0
    c694:	beq.w	cd18 <_strtod_l+0xbe0>
    c698:	bl	a7f4 <__aeabi_ui2d>
    c69c:	strd	r0, r1, [sp, #56]	; 0x38
    c6a0:	ldr	r3, [sp, #52]	; 0x34
    c6a2:	cmp	r3, #0
    c6a4:	bne.w	cd0e <_strtod_l+0xbd6>
    c6a8:	ldrd	r1, r2, [sp, #56]	; 0x38
    c6ac:	add.w	r3, r2, #2147483648	; 0x80000000
    c6b0:	str	r1, [sp, #80]	; 0x50
    c6b2:	str	r3, [sp, #84]	; 0x54
    c6b4:	ldrd	r4, r5, [sp, #80]	; 0x50
    c6b8:	add.w	r3, r5, #112197632	; 0x6b00000
    c6bc:	rsb	r5, r9, r3
    c6c0:	vldr	d0, [sp, #32]
    c6c4:	bl	11860 <__ulp>
    c6c8:	mov	r0, r4
    c6ca:	vmov	r2, r3, d0
    c6ce:	mov	r1, r5
    c6d0:	bl	a8e0 <__aeabi_dmul>
    c6d4:	ldrd	r2, r3, [sp, #32]
    c6d8:	bl	a57c <__adddf3>
    c6dc:	strd	r0, r1, [sp, #16]
    c6e0:	mov	r4, r1
    c6e2:	ldr	r3, [sp, #40]	; 0x28
    c6e4:	cbnz	r3, c6f0 <_strtod_l+0x5b8>
    c6e6:	ldr	r3, [pc, #144]	; (c778 <_strtod_l+0x640>)
    c6e8:	ands	r3, r4
    c6ea:	cmp	r9, r3
    c6ec:	beq.w	cb0c <_strtod_l+0x9d4>
    c6f0:	ldr	r1, [sp, #112]	; 0x70
    c6f2:	mov	r0, fp
    c6f4:	bl	112ac <_Bfree>
    c6f8:	mov	r1, r6
    c6fa:	mov	r0, fp
    c6fc:	bl	112ac <_Bfree>
    c700:	mov	r1, sl
    c702:	mov	r0, fp
    c704:	bl	112ac <_Bfree>
    c708:	mov	r1, r7
    c70a:	mov	r0, fp
    c70c:	bl	112ac <_Bfree>
    c710:	b.n	c4c2 <_strtod_l+0x38a>
    c712:	movs	r2, #0
    c714:	str	r2, [sp, #76]	; 0x4c
    c716:	movs	r2, #1
    c718:	str	r2, [sp, #56]	; 0x38
    c71a:	b.n	c54c <_strtod_l+0x414>
    c71c:	ldr	r3, [pc, #92]	; (c77c <_strtod_l+0x644>)
    c71e:	mov	r0, r4
    c720:	mov	r1, r5
    c722:	movs	r2, #0
    c724:	bl	a8e0 <__aeabi_dmul>
    c728:	ldr	r3, [sp, #52]	; 0x34
    c72a:	strd	r0, r1, [sp, #56]	; 0x38
    c72e:	cmp	r3, #0
    c730:	bne.n	c7e8 <_strtod_l+0x6b0>
    c732:	add.w	r3, r1, #2147483648	; 0x80000000
    c736:	str	r0, [sp, #64]	; 0x40
    c738:	str	r3, [sp, #68]	; 0x44
    c73a:	ldr	r3, [sp, #20]
    c73c:	ldrd	r4, r5, [sp, #64]	; 0x40
    c740:	mov	r8, r3
    c742:	b.n	c660 <_strtod_l+0x528>
    c744:	mov.w	r9, #1
    c748:	cmp	r0, #0
    c74a:	bne.n	c7fe <_strtod_l+0x6c6>
    c74c:	ldr	r3, [sp, #40]	; 0x28
    c74e:	cmp	r3, #0
    c750:	beq.w	c1a4 <_strtod_l+0x6c>
    c754:	mov	r4, r0
    c756:	b.n	c3b4 <_strtod_l+0x27c>
    c758:	.word	0x00000000
    c75c:	.word	0x3ff00000
    c760:	.word	0xffc00000
    c764:	.word	0x41dfffff
    c768:	.word	0x00013428
    c76c:	.word	0xfffffc02
    c770:	.word	0x3ff00000
    c774:	.word	0x7fe00000
    c778:	.word	0x7ff00000
    c77c:	.word	0x3fe00000
    c780:	ldr	r3, [sp, #44]	; 0x2c
    c782:	ldr	r5, [sp, #48]	; 0x30
    c784:	subs	r4, r3, r2
    c786:	b.n	c520 <_strtod_l+0x3e8>
    c788:	mov.w	r9, #1
    c78c:	b.n	c244 <_strtod_l+0x10c>
    c78e:	ldr	r1, [pc, #736]	; (ca70 <_strtod_l+0x938>)
    c790:	subs	r1, r1, r2
    c792:	movs	r2, #1
    c794:	lsl.w	r1, r2, r1
    c798:	str	r1, [sp, #76]	; 0x4c
    c79a:	str	r2, [sp, #56]	; 0x38
    c79c:	b.n	c54c <_strtod_l+0x414>
    c79e:	ldrd	r1, r2, [sp, #16]
    c7a2:	cmp	r1, #0
    c7a4:	bne.w	c93a <_strtod_l+0x802>
    c7a8:	ubfx	r3, r2, #0, #20
    c7ac:	mov	r8, r2
    c7ae:	cmp	r3, #0
    c7b0:	bne.w	c946 <_strtod_l+0x80e>
    c7b4:	movs	r2, #0
    c7b6:	ldr	r3, [pc, #700]	; (ca74 <_strtod_l+0x93c>)
    c7b8:	mov	r0, r4
    c7ba:	mov	r1, r5
    c7bc:	bl	adc4 <__aeabi_dcmplt>
    c7c0:	cmp	r0, #0
    c7c2:	bne.w	cec2 <_strtod_l+0xd8a>
    c7c6:	movs	r2, #0
    c7c8:	ldr	r3, [pc, #684]	; (ca78 <_strtod_l+0x940>)
    c7ca:	mov	r0, r4
    c7cc:	mov	r1, r5
    c7ce:	bl	a8e0 <__aeabi_dmul>
    c7d2:	mov	r2, r1
    c7d4:	mov	r1, r0
    c7d6:	strd	r1, r2, [sp, #56]	; 0x38
    c7da:	add.w	r3, r2, #2147483648	; 0x80000000
    c7de:	str	r0, [sp, #96]	; 0x60
    c7e0:	str	r3, [sp, #100]	; 0x64
    c7e2:	ldrd	r4, r5, [sp, #96]	; 0x60
    c7e6:	b.n	c660 <_strtod_l+0x528>
    c7e8:	vldr	d7, [sp, #56]	; 0x38
    c7ec:	vstr	d7, [sp, #64]	; 0x40
    c7f0:	b.n	c73a <_strtod_l+0x602>
    c7f2:	mov.w	ip, #1
    c7f6:	adds	r3, r6, #2
    c7f8:	str	r3, [sp, #108]	; 0x6c
    c7fa:	ldrb	r3, [r6, #2]
    c7fc:	b.n	c3cc <_strtod_l+0x294>
    c7fe:	movs	r4, #0
    c800:	b.n	c3b4 <_strtod_l+0x27c>
    c802:	cmp.w	r9, #0
    c806:	bne.w	c1a4 <_strtod_l+0x6c>
    c80a:	subs	r3, #73	; 0x49
    c80c:	cmp	r3, #37	; 0x25
    c80e:	bhi.w	c1a4 <_strtod_l+0x6c>
    c812:	add	r2, pc, #4	; (adr r2, c818 <_strtod_l+0x6e0>)
    c814:	ldr.w	pc, [r2, r3, lsl #2]
    c818:	.word	0x0000c37d
    c81c:	.word	0x0000c1a5
    c820:	.word	0x0000c1a5
    c824:	.word	0x0000c1a5
    c828:	.word	0x0000c1a5
    c82c:	.word	0x0000c955
    c830:	.word	0x0000c1a5
    c834:	.word	0x0000c1a5
    c838:	.word	0x0000c1a5
    c83c:	.word	0x0000c1a5
    c840:	.word	0x0000c1a5
    c844:	.word	0x0000c1a5
    c848:	.word	0x0000c1a5
    c84c:	.word	0x0000c1a5
    c850:	.word	0x0000c1a5
    c854:	.word	0x0000c1a5
    c858:	.word	0x0000c1a5
    c85c:	.word	0x0000c1a5
    c860:	.word	0x0000c1a5
    c864:	.word	0x0000c1a5
    c868:	.word	0x0000c1a5
    c86c:	.word	0x0000c1a5
    c870:	.word	0x0000c1a5
    c874:	.word	0x0000c1a5
    c878:	.word	0x0000c1a5
    c87c:	.word	0x0000c1a5
    c880:	.word	0x0000c1a5
    c884:	.word	0x0000c1a5
    c888:	.word	0x0000c1a5
    c88c:	.word	0x0000c1a5
    c890:	.word	0x0000c1a5
    c894:	.word	0x0000c1a5
    c898:	.word	0x0000c37d
    c89c:	.word	0x0000c1a5
    c8a0:	.word	0x0000c1a5
    c8a4:	.word	0x0000c1a5
    c8a8:	.word	0x0000c1a5
    c8ac:	.word	0x0000c955
    c8b0:	cmp.w	r6, #308	; 0x134
    c8b4:	bgt.w	caf6 <_strtod_l+0x9be>
    c8b8:	asrs	r6, r6, #4
    c8ba:	cmp	r6, #1
    c8bc:	ldr.w	r9, [pc, #472]	; ca98 <_strtod_l+0x960>
    c8c0:	ble.w	cef6 <_strtod_l+0xdbe>
    c8c4:	ldrd	r0, r1, [sp, #16]
    c8c8:	movs	r3, #0
    c8ca:	mov	r7, r9
    c8cc:	mov	r8, r3
    c8ce:	tst.w	r6, #1
    c8d2:	add.w	r8, r8, #1
    c8d6:	mov.w	r6, r6, asr #1
    c8da:	beq.n	c8e6 <_strtod_l+0x7ae>
    c8dc:	ldrd	r2, r3, [r7]
    c8e0:	bl	a8e0 <__aeabi_dmul>
    c8e4:	movs	r3, #1
    c8e6:	cmp	r6, #1
    c8e8:	add.w	r7, r7, #8
    c8ec:	bne.n	c8ce <_strtod_l+0x796>
    c8ee:	cmp	r3, #0
    c8f0:	bne.w	cfba <_strtod_l+0xe82>
    c8f4:	ldr	r3, [sp, #20]
    c8f6:	sub.w	r3, r3, #55574528	; 0x3500000
    c8fa:	str	r3, [sp, #20]
    c8fc:	add.w	r8, r9, r8, lsl #3
    c900:	ldrd	r2, r3, [sp, #16]
    c904:	ldrd	r0, r1, [r8]
    c908:	bl	a8e0 <__aeabi_dmul>
    c90c:	bic.w	r3, r1, #2147483648	; 0x80000000
    c910:	lsrs	r3, r3, #20
    c912:	ldr	r2, [pc, #360]	; (ca7c <_strtod_l+0x944>)
    c914:	lsls	r3, r3, #20
    c916:	cmp	r3, r2
    c918:	strd	r0, r1, [sp, #16]
    c91c:	bhi.w	caf6 <_strtod_l+0x9be>
    c920:	sub.w	r2, r2, #1048576	; 0x100000
    c924:	cmp	r3, r2
    c926:	bls.w	ceb8 <_strtod_l+0xd80>
    c92a:	ldr	r3, [pc, #340]	; (ca80 <_strtod_l+0x948>)
    c92c:	str	r3, [sp, #20]
    c92e:	movs	r3, #0
    c930:	str	r3, [sp, #40]	; 0x28
    c932:	mov.w	r3, #4294967295
    c936:	str	r3, [sp, #16]
    c938:	b.n	c494 <_strtod_l+0x35c>
    c93a:	ldrd	r1, r2, [sp, #16]
    c93e:	cmp	r1, #1
    c940:	beq.w	cd22 <_strtod_l+0xbea>
    c944:	mov	r8, r2
    c946:	vldr	d7, [pc, #288]	; ca68 <_strtod_l+0x930>
    c94a:	movs	r4, #0
    c94c:	ldr	r5, [pc, #308]	; (ca84 <_strtod_l+0x94c>)
    c94e:	vstr	d7, [sp, #56]	; 0x38
    c952:	b.n	c660 <_strtod_l+0x528>
    c954:	add	r0, sp, #108	; 0x6c
    c956:	ldr	r1, [pc, #304]	; (ca88 <_strtod_l+0x950>)
    c958:	bl	11018 <__match>
    c95c:	cmp	r0, #0
    c95e:	beq.w	c1a4 <_strtod_l+0x6c>
    c962:	ldr	r3, [sp, #108]	; 0x6c
    c964:	ldrb	r3, [r3, #0]
    c966:	cmp	r3, #40	; 0x28
    c968:	beq.w	cf70 <_strtod_l+0xe38>
    c96c:	ldr	r3, [pc, #284]	; (ca8c <_strtod_l+0x954>)
    c96e:	str	r3, [sp, #20]
    c970:	movs	r3, #0
    c972:	str	r3, [sp, #16]
    c974:	b.n	c3a8 <_strtod_l+0x270>
    c976:	str	r6, [sp, #108]	; 0x6c
    c978:	movs	r2, #0
    c97a:	b.n	c252 <_strtod_l+0x11a>
    c97c:	mov.w	ip, #0
    c980:	b.n	c7f6 <_strtod_l+0x6be>
    c982:	adds	r3, #1
    c984:	bne.w	cf56 <_strtod_l+0xe1e>
    c988:	ldr	r0, [sp, #112]	; 0x70
    c98a:	ldr	r3, [pc, #260]	; (ca90 <_strtod_l+0x958>)
    c98c:	str	r3, [sp, #20]
    c98e:	movs	r2, #0
    c990:	str	r2, [sp, #16]
    c992:	ldrd	r8, r9, [sp, #16]
    c996:	movs	r3, #34	; 0x22
    c998:	str.w	r3, [fp]
    c99c:	mov	r1, r0
    c99e:	mov	r0, fp
    c9a0:	bl	112ac <_Bfree>
    c9a4:	mov	r1, r6
    c9a6:	mov	r0, fp
    c9a8:	bl	112ac <_Bfree>
    c9ac:	mov	r1, sl
    c9ae:	mov	r0, fp
    c9b0:	bl	112ac <_Bfree>
    c9b4:	ldr	r1, [sp, #72]	; 0x48
    c9b6:	mov	r0, fp
    c9b8:	bl	112ac <_Bfree>
    c9bc:	mov	r1, r7
    c9be:	mov	r0, fp
    c9c0:	bl	112ac <_Bfree>
    c9c4:	b.n	c268 <_strtod_l+0x130>
    c9c6:	ldr	r2, [sp, #28]
    c9c8:	str	r5, [sp, #8]
    c9ca:	add	r3, sp, #112	; 0x70
    c9cc:	str	r2, [sp, #4]
    c9ce:	str	r3, [sp, #0]
    c9d0:	ldr	r2, [pc, #192]	; (ca94 <_strtod_l+0x95c>)
    c9d2:	add	r3, sp, #116	; 0x74
    c9d4:	add	r1, sp, #108	; 0x6c
    c9d6:	mov	r0, fp
    c9d8:	bl	10b08 <__gethex>
    c9dc:	ands.w	r6, r0, #7
    c9e0:	mov	r5, r0
    c9e2:	beq.w	c260 <_strtod_l+0x128>
    c9e6:	cmp	r6, #6
    c9e8:	bne.w	cc98 <_strtod_l+0xb60>
    c9ec:	adds	r4, #1
    c9ee:	movs	r3, #0
    c9f0:	str	r4, [sp, #108]	; 0x6c
    c9f2:	mov.w	r8, #0
    c9f6:	mov.w	r9, #0
    c9fa:	str	r3, [sp, #28]
    c9fc:	b.n	c268 <_strtod_l+0x130>
    c9fe:	ldr.w	r1, [sl]
    ca02:	mov	r0, r4
    ca04:	mov	r2, r9
    ca06:	bl	c05c <strncmp>
    ca0a:	cbz	r0, ca20 <_strtod_l+0x8e8>
    ca0c:	mov.w	sl, #0
    ca10:	mov	r3, r7
    ca12:	mov	r8, sl
    ca14:	mov	r5, sl
    ca16:	mov	r0, sl
    ca18:	mov	r7, sl
    ca1a:	mov	r4, sl
    ca1c:	mov	r9, sl
    ca1e:	b.n	c244 <_strtod_l+0x10c>
    ca20:	ldr	r3, [sp, #108]	; 0x6c
    ca22:	add.w	r2, r3, r9
    ca26:	str	r2, [sp, #108]	; 0x6c
    ca28:	ldrb.w	r3, [r3, r9]
    ca2c:	cmp	r3, #48	; 0x30
    ca2e:	bne.n	ca3e <_strtod_l+0x906>
    ca30:	adds	r2, #1
    ca32:	str	r2, [sp, #108]	; 0x6c
    ca34:	ldrb	r3, [r2, #0]
    ca36:	cmp	r3, #48	; 0x30
    ca38:	add.w	r0, r0, #1
    ca3c:	beq.n	ca30 <_strtod_l+0x8f8>
    ca3e:	sub.w	r2, r3, #49	; 0x31
    ca42:	cmp	r2, #8
    ca44:	bls.w	cd40 <_strtod_l+0xc08>
    ca48:	mov.w	sl, #0
    ca4c:	cmp	r3, #101	; 0x65
    ca4e:	mov	r8, sl
    ca50:	mov	r5, sl
    ca52:	mov	r7, sl
    ca54:	beq.w	c744 <_strtod_l+0x60c>
    ca58:	mov	r4, sl
    ca5a:	mov.w	r9, #1
    ca5e:	b.w	c24a <_strtod_l+0x112>
    ca62:	nop
    ca64:	nop.w
    ca68:	.word	0x00000000
    ca6c:	.word	0x3ff00000
    ca70:	.word	0xfffffbe2
    ca74:	.word	0x3ff00000
    ca78:	.word	0x3fe00000
    ca7c:	.word	0x7ca00000
    ca80:	.word	0x7fefffff
    ca84:	.word	0xbff00000
    ca88:	.word	0x00013140
    ca8c:	.word	0xfff80000
    ca90:	.word	0x7ff00000
    ca94:	.word	0x00013120
    ca98:	.word	0x000134f0
    ca9c:	sub.w	r3, r8, #55574528	; 0x3500000
    caa0:	str	r3, [sp, #20]
    caa2:	vldr	d7, [sp, #16]
    caa6:	vmov.f32	s0, s14
    caaa:	vmov.f32	s1, s15
    caae:	bl	11860 <__ulp>
    cab2:	mov	r0, r4
    cab4:	vmov	r2, r3, d0
    cab8:	mov	r1, r5
    caba:	bl	a8e0 <__aeabi_dmul>
    cabe:	ldrd	r2, r3, [sp, #16]
    cac2:	bl	a57c <__adddf3>
    cac6:	bic.w	r3, r1, #2147483648	; 0x80000000
    caca:	strd	r0, r1, [sp, #16]
    cace:	lsrs	r3, r3, #20
    cad0:	ldr	r2, [pc, #684]	; (cd80 <_strtod_l+0xc48>)
    cad2:	ldrd	r0, r1, [sp, #32]
    cad6:	lsls	r3, r3, #20
    cad8:	cmp	r3, r2
    cada:	strd	r0, r1, [sp, #88]	; 0x58
    cade:	bls.w	cc56 <_strtod_l+0xb1e>
    cae2:	ldr	r3, [pc, #672]	; (cd84 <_strtod_l+0xc4c>)
    cae4:	cmp	r1, r3
    cae6:	beq.w	ceae <_strtod_l+0xd76>
    caea:	ldr	r3, [pc, #664]	; (cd84 <_strtod_l+0xc4c>)
    caec:	str	r3, [sp, #20]
    caee:	mov.w	r3, #4294967295
    caf2:	str	r3, [sp, #16]
    caf4:	b.n	c6f0 <_strtod_l+0x5b8>
    caf6:	ldr	r3, [pc, #656]	; (cd88 <_strtod_l+0xc50>)
    caf8:	str	r3, [sp, #20]
    cafa:	movs	r2, #0
    cafc:	movs	r3, #34	; 0x22
    cafe:	str	r2, [sp, #16]
    cb00:	ldrd	r8, r9, [sp, #16]
    cb04:	str.w	r3, [fp]
    cb08:	b.w	c268 <_strtod_l+0x130>
    cb0c:	ldrd	r8, r9, [sp, #56]	; 0x38
    cb10:	mov	r1, r9
    cb12:	mov	r0, r8
    cb14:	bl	ae40 <__aeabi_d2iz>
    cb18:	bl	a814 <__aeabi_i2d>
    cb1c:	mov	r3, r1
    cb1e:	mov	r2, r0
    cb20:	mov	r1, r9
    cb22:	mov	r0, r8
    cb24:	bl	a578 <__aeabi_dsub>
    cb28:	ldr	r3, [sp, #52]	; 0x34
    cb2a:	mov	r8, r0
    cb2c:	mov	r9, r1
    cb2e:	cbnz	r3, cb52 <_strtod_l+0xa1a>
    cb30:	ldr	r3, [sp, #16]
    cb32:	cbnz	r3, cb52 <_strtod_l+0xa1a>
    cb34:	ubfx	r4, r4, #0, #20
    cb38:	cbnz	r4, cb52 <_strtod_l+0xa1a>
    cb3a:	add	r3, pc, #548	; (adr r3, cd60 <_strtod_l+0xc28>)
    cb3c:	ldrd	r2, r3, [r3]
    cb40:	bl	adc4 <__aeabi_dcmplt>
    cb44:	cmp	r0, #0
    cb46:	beq.w	c6f0 <_strtod_l+0x5b8>
    cb4a:	ldrd	r8, r9, [sp, #16]
    cb4e:	ldr	r0, [sp, #112]	; 0x70
    cb50:	b.n	c99c <_strtod_l+0x864>
    cb52:	add	r3, pc, #532	; (adr r3, cd68 <_strtod_l+0xc30>)
    cb54:	ldrd	r2, r3, [r3]
    cb58:	mov	r0, r8
    cb5a:	mov	r1, r9
    cb5c:	bl	adc4 <__aeabi_dcmplt>
    cb60:	cmp	r0, #0
    cb62:	bne.n	cb4a <_strtod_l+0xa12>
    cb64:	mov	r0, r8
    cb66:	mov	r1, r9
    cb68:	add	r3, pc, #516	; (adr r3, cd70 <_strtod_l+0xc38>)
    cb6a:	ldrd	r2, r3, [r3]
    cb6e:	bl	ae00 <__aeabi_dcmpgt>
    cb72:	cmp	r0, #0
    cb74:	beq.w	c6f0 <_strtod_l+0x5b8>
    cb78:	b.n	cb4a <_strtod_l+0xa12>
    cb7a:	beq.w	c490 <_strtod_l+0x358>
    cb7e:	rsb	r6, r9, #0
    cb82:	ands.w	r2, r6, #15
    cb86:	beq.n	cb9e <_strtod_l+0xa66>
    cb88:	ldr	r3, [pc, #512]	; (cd8c <_strtod_l+0xc54>)
    cb8a:	add.w	r3, r3, r2, lsl #3
    cb8e:	ldrd	r0, r1, [sp, #16]
    cb92:	ldrd	r2, r3, [r3]
    cb96:	bl	ab34 <__aeabi_ddiv>
    cb9a:	strd	r0, r1, [sp, #16]
    cb9e:	asrs	r6, r6, #4
    cba0:	beq.w	c490 <_strtod_l+0x358>
    cba4:	cmp	r6, #31
    cba6:	bgt.n	cc1a <_strtod_l+0xae2>
    cba8:	ands.w	r3, r6, #16
    cbac:	beq.w	cf20 <_strtod_l+0xde8>
    cbb0:	movs	r3, #106	; 0x6a
    cbb2:	cmp	r6, #0
    cbb4:	str	r3, [sp, #40]	; 0x28
    cbb6:	ble.n	cbe0 <_strtod_l+0xaa8>
    cbb8:	ldrd	r0, r1, [sp, #16]
    cbbc:	ldr	r7, [pc, #464]	; (cd90 <_strtod_l+0xc58>)
    cbbe:	movs	r3, #0
    cbc0:	lsls	r2, r6, #31
    cbc2:	bpl.n	cbce <_strtod_l+0xa96>
    cbc4:	ldrd	r2, r3, [r7]
    cbc8:	bl	a8e0 <__aeabi_dmul>
    cbcc:	movs	r3, #1
    cbce:	asrs	r6, r6, #1
    cbd0:	add.w	r7, r7, #8
    cbd4:	bne.n	cbc0 <_strtod_l+0xa88>
    cbd6:	cmp	r3, #0
    cbd8:	bne.w	cfc0 <_strtod_l+0xe88>
    cbdc:	ldr	r3, [sp, #40]	; 0x28
    cbde:	cbz	r3, cc08 <_strtod_l+0xad0>
    cbe0:	ldrd	r1, r2, [sp, #16]
    cbe4:	ubfx	r3, r2, #20, #11
    cbe8:	rsb	r3, r3, #107	; 0x6b
    cbec:	cmp	r3, #0
    cbee:	mov	r1, r2
    cbf0:	ble.n	cc08 <_strtod_l+0xad0>
    cbf2:	cmp	r3, #31
    cbf4:	ble.w	cfaa <_strtod_l+0xe72>
    cbf8:	movs	r2, #0
    cbfa:	cmp	r3, #52	; 0x34
    cbfc:	str	r2, [sp, #16]
    cbfe:	ble.w	cfc6 <_strtod_l+0xe8e>
    cc02:	mov.w	r3, #57671680	; 0x3700000
    cc06:	str	r3, [sp, #20]
    cc08:	movs	r2, #0
    cc0a:	movs	r3, #0
    cc0c:	ldrd	r0, r1, [sp, #16]
    cc10:	bl	adb0 <__aeabi_dcmpeq>
    cc14:	cmp	r0, #0
    cc16:	beq.w	c494 <_strtod_l+0x35c>
    cc1a:	movs	r3, #34	; 0x22
    cc1c:	str.w	r3, [fp]
    cc20:	mov.w	r8, #0
    cc24:	mov.w	r9, #0
    cc28:	b.w	c268 <_strtod_l+0x130>
    cc2c:	ldr	r1, [sp, #108]	; 0x6c
    cc2e:	adds	r4, #1
    cc30:	cmp	r0, #8
    cc32:	ble.w	cd52 <_strtod_l+0xc1a>
    cc36:	cmp	r4, #16
    cc38:	itt	le
    cc3a:	addle.w	r8, r8, r8, lsl #2
    cc3e:	addle.w	r8, r2, r8, lsl #1
    cc42:	movs	r0, #0
    cc44:	adds	r3, r1, #1
    cc46:	str	r3, [sp, #108]	; 0x6c
    cc48:	ldrb	r3, [r1, #1]
    cc4a:	b.w	c28c <_strtod_l+0x154>
    cc4e:	movw	r2, #19999	; 0x4e1f
    cc52:	b.w	c43e <_strtod_l+0x306>
    cc56:	ldr	r3, [sp, #20]
    cc58:	add.w	r4, r3, #55574528	; 0x3500000
    cc5c:	str	r4, [sp, #20]
    cc5e:	b.n	c6e2 <_strtod_l+0x5aa>
    cc60:	ldr	r6, [sp, #44]	; 0x2c
    cc62:	rsb	r3, r4, #37	; 0x25
    cc66:	cmp	r6, r3
    cc68:	bgt.w	c45c <_strtod_l+0x324>
    cc6c:	ldr	r5, [pc, #284]	; (cd8c <_strtod_l+0xc54>)
    cc6e:	rsb	r4, r4, #15
    cc72:	add.w	r1, r5, r4, lsl #3
    cc76:	subs	r4, r6, r4
    cc78:	ldrd	r2, r3, [sp, #16]
    cc7c:	ldrd	r0, r1, [r1]
    cc80:	add.w	r5, r5, r4, lsl #3
    cc84:	bl	a8e0 <__aeabi_dmul>
    cc88:	ldrd	r2, r3, [r5]
    cc8c:	bl	a8e0 <__aeabi_dmul>
    cc90:	mov	r8, r0
    cc92:	mov	r9, r1
    cc94:	b.w	c268 <_strtod_l+0x130>
    cc98:	ldr	r2, [sp, #112]	; 0x70
    cc9a:	cbz	r2, ccac <_strtod_l+0xb74>
    cc9c:	movs	r1, #53	; 0x35
    cc9e:	add	r0, sp, #120	; 0x78
    cca0:	bl	11aa0 <__copybits>
    cca4:	mov	r0, fp
    cca6:	ldr	r1, [sp, #112]	; 0x70
    cca8:	bl	112ac <_Bfree>
    ccac:	cmp	r6, #6
    ccae:	bhi.n	ccc8 <_strtod_l+0xb90>
    ccb0:	tbb	[pc, r6]
    ccb4:	.word	0x1318211d
    ccb8:	.short	0x2104
    ccba:	.byte	0x1d
    ccbb:	.byte	0x00
    ccbc:	mvn.w	r3, #2147483648	; 0x80000000
    ccc0:	str	r3, [sp, #20]
    ccc2:	mov.w	r3, #4294967295
    ccc6:	str	r3, [sp, #16]
    ccc8:	lsls	r1, r5, #28
    ccca:	bpl.w	c3a8 <_strtod_l+0x270>
    ccce:	ldr	r3, [sp, #20]
    ccd0:	orr.w	r3, r3, #2147483648	; 0x80000000
    ccd4:	str	r3, [sp, #20]
    ccd6:	b.w	c3a8 <_strtod_l+0x270>
    ccda:	ldr	r3, [pc, #172]	; (cd88 <_strtod_l+0xc50>)
    ccdc:	str	r3, [sp, #20]
    ccde:	movs	r3, #0
    cce0:	str	r3, [sp, #16]
    cce2:	b.n	ccc8 <_strtod_l+0xb90>
    cce4:	ldr	r3, [sp, #120]	; 0x78
    cce6:	str	r3, [sp, #16]
    cce8:	ldr	r3, [sp, #124]	; 0x7c
    ccea:	str	r3, [sp, #20]
    ccec:	b.n	ccc8 <_strtod_l+0xb90>
    ccee:	movs	r3, #0
    ccf0:	str	r3, [sp, #20]
    ccf2:	str	r3, [sp, #16]
    ccf4:	b.n	ccc8 <_strtod_l+0xb90>
    ccf6:	ldr	r2, [sp, #116]	; 0x74
    ccf8:	ldr	r3, [sp, #124]	; 0x7c
    ccfa:	ldr	r1, [sp, #120]	; 0x78
    ccfc:	str	r1, [sp, #16]
    ccfe:	addw	r2, r2, #1075	; 0x433
    cd02:	bic.w	r3, r3, #1048576	; 0x100000
    cd06:	orr.w	r3, r3, r2, lsl #20
    cd0a:	str	r3, [sp, #20]
    cd0c:	b.n	ccc8 <_strtod_l+0xb90>
    cd0e:	vldr	d7, [sp, #56]	; 0x38
    cd12:	vstr	d7, [sp, #80]	; 0x50
    cd16:	b.n	c6b4 <_strtod_l+0x57c>
    cd18:	vldr	d7, [pc, #92]	; cd78 <_strtod_l+0xc40>
    cd1c:	vstr	d7, [sp, #56]	; 0x38
    cd20:	b.n	c6a0 <_strtod_l+0x568>
    cd22:	ldrd	r1, r2, [sp, #16]
    cd26:	mov	r8, r2
    cd28:	cmp	r2, #0
    cd2a:	bne.w	c946 <_strtod_l+0x80e>
    cd2e:	movs	r3, #34	; 0x22
    cd30:	str.w	r3, [fp]
    cd34:	ldr	r0, [sp, #112]	; 0x70
    cd36:	mov.w	r8, #0
    cd3a:	mov.w	r9, #0
    cd3e:	b.n	c99c <_strtod_l+0x864>
    cd40:	ldr	r2, [sp, #108]	; 0x6c
    cd42:	str	r2, [sp, #32]
    cd44:	movs	r5, #0
    cd46:	subs	r3, #48	; 0x30
    cd48:	adds	r7, r0, #1
    cd4a:	mov	r1, r2
    cd4c:	mov	sl, r5
    cd4e:	mov	r8, r5
    cd50:	movs	r4, #1
    cd52:	add.w	r5, r5, r5, lsl #2
    cd56:	add.w	r5, r3, r5, lsl #1
    cd5a:	movs	r0, #0
    cd5c:	b.n	cc44 <_strtod_l+0xb0c>
    cd5e:	nop
    cd60:	.word	0x94a03595
    cd64:	.word	0x3fcfffff
    cd68:	.word	0x94a03595
    cd6c:	.word	0x3fdfffff
    cd70:	.word	0x35afe535
    cd74:	.word	0x3fe00000
    cd78:	.word	0x00000000
    cd7c:	.word	0x3ff00000
    cd80:	.word	0x7c9fffff
    cd84:	.word	0x7fefffff
    cd88:	.word	0x7ff00000
    cd8c:	.word	0x00013428
    cd90:	.word	0x00013158
    cd94:	ldr	r1, [sp, #44]	; 0x2c
    cd96:	cmn.w	r1, #22
    cd9a:	blt.w	c45c <_strtod_l+0x324>
    cd9e:	ldr	r2, [pc, #600]	; (cff8 <_strtod_l+0xec0>)
    cda0:	sub.w	r2, r2, r1, lsl #3
    cda4:	ldrd	r2, r3, [r2]
    cda8:	ldrd	r0, r1, [sp, #16]
    cdac:	bl	ab34 <__aeabi_ddiv>
    cdb0:	mov	r8, r0
    cdb2:	mov	r9, r1
    cdb4:	b.w	c268 <_strtod_l+0x130>
    cdb8:	ldr	r3, [sp, #52]	; 0x34
    cdba:	ldrd	r8, r9, [sp, #32]
    cdbe:	cmp	r3, #0
    cdc0:	beq.w	ced4 <_strtod_l+0xd9c>
    cdc4:	ldrd	r4, r5, [sp, #16]
    cdc8:	ldr	r3, [pc, #560]	; (cffc <_strtod_l+0xec4>)
    cdca:	ubfx	r1, r5, #0, #20
    cdce:	cmp	r1, r3
    cdd0:	mov	r2, r5
    cdd2:	beq.w	cf2a <_strtod_l+0xdf2>
    cdd6:	ldr	r3, [sp, #76]	; 0x4c
    cdd8:	cmp	r3, #0
    cdda:	beq.w	ceec <_strtod_l+0xdb4>
    cdde:	ldr	r2, [sp, #20]
    cde0:	tst	r3, r2
    cde2:	beq.n	ce06 <_strtod_l+0xcce>
    cde4:	ldr	r3, [sp, #52]	; 0x34
    cde6:	ldr	r2, [sp, #40]	; 0x28
    cde8:	ldrd	r0, r1, [sp, #16]
    cdec:	cmp	r3, #0
    cdee:	beq.w	cefc <_strtod_l+0xdc4>
    cdf2:	bl	c0fc <sulp>
    cdf6:	mov	r2, r0
    cdf8:	mov	r3, r1
    cdfa:	mov	r0, r8
    cdfc:	mov	r1, r9
    cdfe:	bl	a57c <__adddf3>
    ce02:	mov	r8, r0
    ce04:	mov	r9, r1
    ce06:	ldr	r3, [sp, #40]	; 0x28
    ce08:	cbz	r3, ce3a <_strtod_l+0xd02>
    ce0a:	ldr	r3, [pc, #500]	; (d000 <_strtod_l+0xec8>)
    ce0c:	str	r3, [sp, #92]	; 0x5c
    ce0e:	movs	r3, #0
    ce10:	str	r3, [sp, #88]	; 0x58
    ce12:	ldrd	r2, r3, [sp, #88]	; 0x58
    ce16:	mov	r0, r8
    ce18:	mov	r1, r9
    ce1a:	bl	a8e0 <__aeabi_dmul>
    ce1e:	mov	r3, r0
    ce20:	mov	r4, r1
    ce22:	mov	r8, r0
    ce24:	mov	r9, r1
    ce26:	strd	r3, r4, [sp, #16]
    ce2a:	cbnz	r1, ce3a <_strtod_l+0xd02>
    ce2c:	ldr	r3, [sp, #16]
    ce2e:	cbnz	r3, ce3a <_strtod_l+0xd02>
    ce30:	movs	r3, #34	; 0x22
    ce32:	ldr	r0, [sp, #112]	; 0x70
    ce34:	str.w	r3, [fp]
    ce38:	b.n	c99c <_strtod_l+0x864>
    ce3a:	ldr	r0, [sp, #112]	; 0x70
    ce3c:	b.n	c99c <_strtod_l+0x864>
    ce3e:	ldr	r3, [sp, #52]	; 0x34
    ce40:	ldrd	r8, r9, [sp, #32]
    ce44:	cmp	r3, #0
    ce46:	bne.n	ce06 <_strtod_l+0xcce>
    ce48:	ldrd	r1, r2, [sp, #16]
    ce4c:	cmp	r1, #0
    ce4e:	bne.n	ce06 <_strtod_l+0xcce>
    ce50:	ubfx	r3, r2, #0, #20
    ce54:	mov	r4, r2
    ce56:	cmp	r3, #0
    ce58:	bne.n	ce06 <_strtod_l+0xcce>
    ce5a:	bic.w	r3, r2, #2147483648	; 0x80000000
    ce5e:	lsrs	r3, r3, #20
    ce60:	lsls	r3, r3, #20
    ce62:	cmp.w	r3, #112197632	; 0x6b00000
    ce66:	bls.n	ce06 <_strtod_l+0xcce>
    ce68:	ldr	r3, [r7, #20]
    ce6a:	cbnz	r3, ce72 <_strtod_l+0xd3a>
    ce6c:	ldr	r3, [r7, #16]
    ce6e:	cmp	r3, #1
    ce70:	ble.n	ce06 <_strtod_l+0xcce>
    ce72:	mov	r1, r7
    ce74:	movs	r2, #1
    ce76:	mov	r0, fp
    ce78:	bl	11658 <__lshift>
    ce7c:	mov	r1, sl
    ce7e:	mov	r7, r0
    ce80:	bl	11708 <__mcmp>
    ce84:	cmp	r0, #0
    ce86:	ble.n	ce06 <_strtod_l+0xcce>
    ce88:	ldr	r3, [sp, #40]	; 0x28
    ce8a:	cmp	r3, #0
    ce8c:	bne.w	cf94 <_strtod_l+0xe5c>
    ce90:	ldr	r3, [pc, #368]	; (d004 <_strtod_l+0xecc>)
    ce92:	ands	r3, r4
    ce94:	sub.w	r3, r3, #1048576	; 0x100000
    ce98:	mvn.w	r3, r3, lsr #20
    ce9c:	mvn.w	r3, r3, lsl #20
    cea0:	str	r3, [sp, #20]
    cea2:	mov.w	r3, #4294967295
    cea6:	str	r3, [sp, #16]
    cea8:	ldrd	r8, r9, [sp, #16]
    ceac:	b.n	ce06 <_strtod_l+0xcce>
    ceae:	ldr	r3, [sp, #88]	; 0x58
    ceb0:	adds	r3, #1
    ceb2:	bne.w	caea <_strtod_l+0x9b2>
    ceb6:	b.n	c988 <_strtod_l+0x850>
    ceb8:	add.w	r3, r1, #55574528	; 0x3500000
    cebc:	str	r3, [sp, #20]
    cebe:	b.w	c490 <_strtod_l+0x358>
    cec2:	vldr	d7, [pc, #292]	; cfe8 <_strtod_l+0xeb0>
    cec6:	vstr	d7, [sp, #96]	; 0x60
    ceca:	vldr	d7, [pc, #292]	; cff0 <_strtod_l+0xeb8>
    cece:	vstr	d7, [sp, #56]	; 0x38
    ced2:	b.n	c7e2 <_strtod_l+0x6aa>
    ced4:	ldrd	r1, r2, [sp, #16]
    ced8:	ubfx	r3, r2, #0, #20
    cedc:	mov	r4, r2
    cede:	cmp	r3, #0
    cee0:	bne.w	cdd6 <_strtod_l+0xc9e>
    cee4:	cmp	r1, #0
    cee6:	bne.w	cdd6 <_strtod_l+0xc9e>
    ceea:	b.n	ce88 <_strtod_l+0xd50>
    ceec:	ldr	r3, [sp, #56]	; 0x38
    ceee:	ldr	r2, [sp, #16]
    cef0:	tst	r3, r2
    cef2:	beq.n	ce06 <_strtod_l+0xcce>
    cef4:	b.n	cde4 <_strtod_l+0xcac>
    cef6:	mov.w	r8, #0
    cefa:	b.n	c8f4 <_strtod_l+0x7bc>
    cefc:	bl	c0fc <sulp>
    cf00:	mov	r2, r0
    cf02:	mov	r3, r1
    cf04:	mov	r0, r8
    cf06:	mov	r1, r9
    cf08:	bl	a578 <__aeabi_dsub>
    cf0c:	movs	r2, #0
    cf0e:	movs	r3, #0
    cf10:	mov	r8, r0
    cf12:	mov	r9, r1
    cf14:	bl	adb0 <__aeabi_dcmpeq>
    cf18:	cmp	r0, #0
    cf1a:	bne.w	cd2e <_strtod_l+0xbf6>
    cf1e:	b.n	ce06 <_strtod_l+0xcce>
    cf20:	cmp	r6, #0
    cf22:	str	r3, [sp, #40]	; 0x28
    cf24:	bgt.w	cbb8 <_strtod_l+0xa80>
    cf28:	b.n	cc08 <_strtod_l+0xad0>
    cf2a:	ldr	r3, [sp, #40]	; 0x28
    cf2c:	ldr	r1, [sp, #16]
    cf2e:	cbz	r3, cf6a <_strtod_l+0xe32>
    cf30:	ldr	r3, [pc, #208]	; (d004 <_strtod_l+0xecc>)
    cf32:	ands	r3, r5
    cf34:	cmp.w	r3, #111149056	; 0x6a00000
    cf38:	bhi.n	cf6a <_strtod_l+0xe32>
    cf3a:	lsrs	r3, r3, #20
    cf3c:	rsb	r3, r3, #107	; 0x6b
    cf40:	mov.w	r0, #4294967295
    cf44:	lsl.w	r3, r0, r3
    cf48:	cmp	r3, r1
    cf4a:	bne.w	cdd6 <_strtod_l+0xc9e>
    cf4e:	ldr	r1, [pc, #184]	; (d008 <_strtod_l+0xed0>)
    cf50:	cmp	r2, r1
    cf52:	beq.w	c982 <_strtod_l+0x84a>
    cf56:	ldr	r3, [pc, #172]	; (d004 <_strtod_l+0xecc>)
    cf58:	ands	r3, r2
    cf5a:	add.w	r3, r3, #1048576	; 0x100000
    cf5e:	str	r3, [sp, #20]
    cf60:	movs	r3, #0
    cf62:	str	r3, [sp, #16]
    cf64:	ldrd	r8, r9, [sp, #16]
    cf68:	b.n	ce06 <_strtod_l+0xcce>
    cf6a:	mov.w	r3, #4294967295
    cf6e:	b.n	cf48 <_strtod_l+0xe10>
    cf70:	add	r0, sp, #108	; 0x6c
    cf72:	add	r2, sp, #120	; 0x78
    cf74:	ldr	r1, [pc, #148]	; (d00c <_strtod_l+0xed4>)
    cf76:	bl	11048 <__hexnan>
    cf7a:	cmp	r0, #5
    cf7c:	bne.w	c96c <_strtod_l+0x834>
    cf80:	ldr	r3, [sp, #124]	; 0x7c
    cf82:	orr.w	r3, r3, #2139095040	; 0x7f800000
    cf86:	orr.w	r3, r3, #7340032	; 0x700000
    cf8a:	str	r3, [sp, #20]
    cf8c:	ldr	r3, [sp, #120]	; 0x78
    cf8e:	str	r3, [sp, #16]
    cf90:	b.w	c3a8 <_strtod_l+0x270>
    cf94:	ldr	r3, [pc, #108]	; (d004 <_strtod_l+0xecc>)
    cf96:	ands	r3, r4
    cf98:	cmp.w	r3, #112197632	; 0x6b00000
    cf9c:	bgt.w	ce94 <_strtod_l+0xd5c>
    cfa0:	cmp.w	r3, #57671680	; 0x3700000
    cfa4:	bgt.w	ce0a <_strtod_l+0xcd2>
    cfa8:	b.n	cd2e <_strtod_l+0xbf6>
    cfaa:	mov.w	r2, #4294967295
    cfae:	lsl.w	r3, r2, r3
    cfb2:	ldr	r2, [sp, #16]
    cfb4:	ands	r2, r3
    cfb6:	str	r2, [sp, #16]
    cfb8:	b.n	cc08 <_strtod_l+0xad0>
    cfba:	strd	r0, r1, [sp, #16]
    cfbe:	b.n	c8f4 <_strtod_l+0x7bc>
    cfc0:	strd	r0, r1, [sp, #16]
    cfc4:	b.n	cbdc <_strtod_l+0xaa4>
    cfc6:	subs	r3, #32
    cfc8:	mov.w	r2, #4294967295
    cfcc:	lsl.w	r3, r2, r3
    cfd0:	ands	r3, r1
    cfd2:	str	r3, [sp, #20]
    cfd4:	b.n	cc08 <_strtod_l+0xad0>
    cfd6:	mov	r0, r4
    cfd8:	ldr	r1, [sp, #108]	; 0x6c
    cfda:	adds	r4, #1
    cfdc:	b.n	cc30 <_strtod_l+0xaf8>
    cfde:	mov	r0, r1
    cfe0:	ldr	r1, [sp, #108]	; 0x6c
    cfe2:	b.n	cc44 <_strtod_l+0xb0c>
    cfe4:	nop.w
    cfe8:	.word	0x00000000
    cfec:	.word	0xbfe00000
    cff0:	.word	0x00000000
    cff4:	.word	0x3fe00000
    cff8:	.word	0x00013428
    cffc:	.word	0x000fffff
    d000:	.word	0x39500000
    d004:	.word	0x7ff00000
    d008:	.word	0x7fefffff
    d00c:	.word	0x00013144

0000d010 <_strtod_r>:
    d010:	ldr	r3, [pc, #20]	; (d028 <_strtod_r+0x18>)
    d012:	ldr	r3, [r3, #0]
    d014:	push	{r4}
    d016:	ldr	r3, [r3, #52]	; 0x34
    d018:	ldr	r4, [pc, #16]	; (d02c <_strtod_r+0x1c>)
    d01a:	cmp	r3, #0
    d01c:	it	eq
    d01e:	moveq	r3, r4
    d020:	ldr.w	r4, [sp], #4
    d024:	b.w	c138 <_strtod_l>
    d028:	.word	0x1fff1828
    d02c:	.word	0x1fff182c

0000d030 <_strtol_l.isra.0>:
    d030:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d034:	ldr.w	r9, [sp, #40]	; 0x28
    d038:	mov	r7, r1
    d03a:	mov	r8, r0
    d03c:	mov	r6, r2
    d03e:	mov	r5, r3
    d040:	mov	fp, r1
    d042:	b.n	d046 <_strtol_l.isra.0+0x16>
    d044:	mov	fp, r4
    d046:	mov	r4, fp
    d048:	mov	r0, r9
    d04a:	ldrb.w	sl, [r4], #1
    d04e:	bl	b324 <__locale_ctype_ptr_l>
    d052:	add	r0, sl
    d054:	ldrb	r1, [r0, #1]
    d056:	and.w	r1, r1, #8
    d05a:	and.w	ip, r1, #255	; 0xff
    d05e:	cmp	r1, #0
    d060:	bne.n	d044 <_strtol_l.isra.0+0x14>
    d062:	mov	r2, sl
    d064:	cmp	r2, #45	; 0x2d
    d066:	beq.n	d12c <_strtol_l.isra.0+0xfc>
    d068:	cmp	r2, #43	; 0x2b
    d06a:	itt	eq
    d06c:	ldrbeq.w	r2, [fp, #1]
    d070:	addeq.w	r4, fp, #2
    d074:	cmp	r5, #0
    d076:	beq.n	d100 <_strtol_l.isra.0+0xd0>
    d078:	cmp	r5, #16
    d07a:	beq.n	d148 <_strtol_l.isra.0+0x118>
    d07c:	mov	r9, r5
    d07e:	cmp.w	ip, #0
    d082:	ite	eq
    d084:	mvneq.w	sl, #2147483648	; 0x80000000
    d088:	movne.w	sl, #2147483648	; 0x80000000
    d08c:	movs	r1, #0
    d08e:	udiv	lr, sl, r9
    d092:	mov	r0, r1
    d094:	mls	sl, r9, lr, sl
    d098:	b.n	d0a6 <_strtol_l.isra.0+0x76>
    d09a:	beq.n	d0f0 <_strtol_l.isra.0+0xc0>
    d09c:	mla	r0, r9, r0, r3
    d0a0:	movs	r1, #1
    d0a2:	ldrb.w	r2, [r4], #1
    d0a6:	sub.w	r3, r2, #48	; 0x30
    d0aa:	cmp	r3, #9
    d0ac:	bls.n	d0ba <_strtol_l.isra.0+0x8a>
    d0ae:	sub.w	r3, r2, #65	; 0x41
    d0b2:	cmp	r3, #25
    d0b4:	bhi.n	d0cc <_strtol_l.isra.0+0x9c>
    d0b6:	sub.w	r3, r2, #55	; 0x37
    d0ba:	cmp	r5, r3
    d0bc:	ble.n	d0dc <_strtol_l.isra.0+0xac>
    d0be:	adds	r2, r1, #1
    d0c0:	beq.n	d0a2 <_strtol_l.isra.0+0x72>
    d0c2:	cmp	lr, r0
    d0c4:	bcs.n	d09a <_strtol_l.isra.0+0x6a>
    d0c6:	mov.w	r1, #4294967295
    d0ca:	b.n	d0a2 <_strtol_l.isra.0+0x72>
    d0cc:	sub.w	r3, r2, #97	; 0x61
    d0d0:	cmp	r3, #25
    d0d2:	bhi.n	d0dc <_strtol_l.isra.0+0xac>
    d0d4:	sub.w	r3, r2, #87	; 0x57
    d0d8:	cmp	r5, r3
    d0da:	bgt.n	d0be <_strtol_l.isra.0+0x8e>
    d0dc:	adds	r3, r1, #1
    d0de:	beq.n	d10c <_strtol_l.isra.0+0xdc>
    d0e0:	cmp.w	ip, #0
    d0e4:	bne.n	d108 <_strtol_l.isra.0+0xd8>
    d0e6:	cbz	r6, d0fc <_strtol_l.isra.0+0xcc>
    d0e8:	cbnz	r1, d124 <_strtol_l.isra.0+0xf4>
    d0ea:	str	r7, [r6, #0]
    d0ec:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d0f0:	cmp	sl, r3
    d0f2:	bge.n	d09c <_strtol_l.isra.0+0x6c>
    d0f4:	mov	r0, lr
    d0f6:	mov.w	r1, #4294967295
    d0fa:	b.n	d0a2 <_strtol_l.isra.0+0x72>
    d0fc:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d100:	cmp	r2, #48	; 0x30
    d102:	beq.n	d13a <_strtol_l.isra.0+0x10a>
    d104:	movs	r5, #10
    d106:	b.n	d07c <_strtol_l.isra.0+0x4c>
    d108:	negs	r0, r0
    d10a:	b.n	d0e6 <_strtol_l.isra.0+0xb6>
    d10c:	cmp.w	ip, #0
    d110:	mov.w	r3, #34	; 0x22
    d114:	ite	eq
    d116:	mvneq.w	r0, #2147483648	; 0x80000000
    d11a:	movne.w	r0, #2147483648	; 0x80000000
    d11e:	str.w	r3, [r8]
    d122:	cbz	r6, d162 <_strtol_l.isra.0+0x132>
    d124:	subs	r7, r4, #1
    d126:	str	r7, [r6, #0]
    d128:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d12c:	add.w	r4, fp, #2
    d130:	ldrb.w	r2, [fp, #1]
    d134:	mov.w	ip, #1
    d138:	b.n	d074 <_strtol_l.isra.0+0x44>
    d13a:	ldrb	r3, [r4, #0]
    d13c:	and.w	r3, r3, #223	; 0xdf
    d140:	cmp	r3, #88	; 0x58
    d142:	beq.n	d156 <_strtol_l.isra.0+0x126>
    d144:	movs	r5, #8
    d146:	b.n	d07c <_strtol_l.isra.0+0x4c>
    d148:	cmp	r2, #48	; 0x30
    d14a:	bne.n	d07c <_strtol_l.isra.0+0x4c>
    d14c:	ldrb	r3, [r4, #0]
    d14e:	and.w	r3, r3, #223	; 0xdf
    d152:	cmp	r3, #88	; 0x58
    d154:	bne.n	d07c <_strtol_l.isra.0+0x4c>
    d156:	mov.w	r9, #16
    d15a:	ldrb	r2, [r4, #1]
    d15c:	mov	r5, r9
    d15e:	adds	r4, #2
    d160:	b.n	d07e <_strtol_l.isra.0+0x4e>
    d162:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d166:	nop

0000d168 <_strtol_r>:
    d168:	push	{r4, r5, lr}
    d16a:	ldr	r4, [pc, #24]	; (d184 <_strtol_r+0x1c>)
    d16c:	ldr	r5, [pc, #24]	; (d188 <_strtol_r+0x20>)
    d16e:	ldr	r4, [r4, #0]
    d170:	ldr	r4, [r4, #52]	; 0x34
    d172:	sub	sp, #12
    d174:	cmp	r4, #0
    d176:	it	eq
    d178:	moveq	r4, r5
    d17a:	str	r4, [sp, #0]
    d17c:	bl	d030 <_strtol_l.isra.0>
    d180:	add	sp, #12
    d182:	pop	{r4, r5, pc}
    d184:	.word	0x1fff1828
    d188:	.word	0x1fff182c
    d18c:	.word	0xffffffff

0000d190 <_svfprintf_r>:
    d190:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d194:	sub	sp, #260	; 0x104
    d196:	mov	r4, r1
    d198:	str	r1, [sp, #20]
    d19a:	mov	r5, r2
    d19c:	str	r3, [sp, #40]	; 0x28
    d19e:	str	r0, [sp, #24]
    d1a0:	bl	111e8 <_localeconv_r>
    d1a4:	ldr	r3, [r0, #0]
    d1a6:	str	r3, [sp, #76]	; 0x4c
    d1a8:	mov	r0, r3
    d1aa:	bl	bf80 <strlen>
    d1ae:	ldrh	r3, [r4, #12]
    d1b0:	str	r0, [sp, #72]	; 0x48
    d1b2:	lsls	r6, r3, #24
    d1b4:	bpl.n	d1be <_svfprintf_r+0x2e>
    d1b6:	ldr	r3, [r4, #16]
    d1b8:	cmp	r3, #0
    d1ba:	beq.w	e420 <_svfprintf_r+0x1290>
    d1be:	vldr	d7, [pc, #664]	; d458 <_svfprintf_r+0x2c8>
    d1c2:	movs	r3, #0
    d1c4:	vstr	d7, [sp, #64]	; 0x40
    d1c8:	str	r3, [sp, #56]	; 0x38
    d1ca:	str	r3, [sp, #148]	; 0x94
    d1cc:	str	r3, [sp, #144]	; 0x90
    d1ce:	str	r3, [sp, #84]	; 0x54
    d1d0:	str	r3, [sp, #28]
    d1d2:	ldr.w	sl, [pc, #656]	; d464 <_svfprintf_r+0x2d4>
    d1d6:	add	r3, sp, #192	; 0xc0
    d1d8:	str	r3, [sp, #140]	; 0x8c
    d1da:	mov	r9, r3
    d1dc:	mov	r8, r5
    d1de:	ldrb.w	r3, [r8]
    d1e2:	mov	r4, r8
    d1e4:	cbz	r3, d222 <_svfprintf_r+0x92>
    d1e6:	cmp	r3, #37	; 0x25
    d1e8:	bne.n	d1f0 <_svfprintf_r+0x60>
    d1ea:	b.n	d222 <_svfprintf_r+0x92>
    d1ec:	cmp	r3, #37	; 0x25
    d1ee:	beq.n	d1f8 <_svfprintf_r+0x68>
    d1f0:	ldrb.w	r3, [r4, #1]!
    d1f4:	cmp	r3, #0
    d1f6:	bne.n	d1ec <_svfprintf_r+0x5c>
    d1f8:	rsb	r5, r8, r4
    d1fc:	cbz	r5, d222 <_svfprintf_r+0x92>
    d1fe:	ldr	r3, [sp, #144]	; 0x90
    d200:	ldr	r2, [sp, #148]	; 0x94
    d202:	str.w	r8, [r9]
    d206:	adds	r3, #1
    d208:	add	r2, r5
    d20a:	cmp	r3, #7
    d20c:	str.w	r5, [r9, #4]
    d210:	str	r2, [sp, #148]	; 0x94
    d212:	str	r3, [sp, #144]	; 0x90
    d214:	bgt.w	d364 <_svfprintf_r+0x1d4>
    d218:	add.w	r9, r9, #8
    d21c:	ldr	r3, [sp, #28]
    d21e:	add	r3, r5
    d220:	str	r3, [sp, #28]
    d222:	ldrb	r3, [r4, #0]
    d224:	cmp	r3, #0
    d226:	beq.w	d376 <_svfprintf_r+0x1e6>
    d22a:	movs	r3, #0
    d22c:	mov	r2, r3
    d22e:	strb.w	r3, [sp, #111]	; 0x6f
    d232:	mov	r1, r3
    d234:	str	r3, [sp, #32]
    d236:	str	r3, [sp, #12]
    d238:	mov.w	fp, #4294967295
    d23c:	ldrb	r3, [r4, #1]
    d23e:	add.w	r8, r4, #1
    d242:	mov	r5, fp
    d244:	add.w	r8, r8, #1
    d248:	sub.w	r0, r3, #32
    d24c:	cmp	r0, #88	; 0x58
    d24e:	bhi.w	daba <_svfprintf_r+0x92a>
    d252:	tbh	[pc, r0, lsl #1]
    d256:	.short	0x03a0
    d258:	.word	0x04320432
    d25c:	.word	0x043203a8
    d260:	.word	0x04320432
    d264:	.word	0x04320432
    d268:	.word	0x03af0432
    d26c:	.word	0x043203bd
    d270:	.word	0x00e2005d
    d274:	.word	0x01090432
    d278:	.word	0x01100110
    d27c:	.word	0x01100110
    d280:	.word	0x01100110
    d284:	.word	0x01100110
    d288:	.word	0x04320110
    d28c:	.word	0x04320432
    d290:	.word	0x04320432
    d294:	.word	0x04320432
    d298:	.word	0x04320432
    d29c:	.word	0x01200432
    d2a0:	.word	0x04320286
    d2a4:	.word	0x04320286
    d2a8:	.word	0x04320432
    d2ac:	.word	0x02d40432
    d2b0:	.word	0x04320432
    d2b4:	.word	0x043202e5
    d2b8:	.word	0x04320432
    d2bc:	.word	0x04320432
    d2c0:	.word	0x0432030f
    d2c4:	.word	0x033d0432
    d2c8:	.word	0x04320432
    d2cc:	.word	0x04320432
    d2d0:	.word	0x04320432
    d2d4:	.word	0x04320432
    d2d8:	.word	0x04320432
    d2dc:	.word	0x0391037e
    d2e0:	.word	0x02860286
    d2e4:	.word	0x03990286
    d2e8:	.word	0x04320391
    d2ec:	.word	0x04070432
    d2f0:	.word	0x04120432
    d2f4:	.word	0x006400a3
    d2f8:	.word	0x043203c2
    d2fc:	.word	0x043203c9
    d300:	.word	0x043203ea
    d304:	.word	0x03f20432
    d308:	ldr	r0, [sp, #32]
    d30a:	str	r3, [sp, #40]	; 0x28
    d30c:	negs	r0, r0
    d30e:	str	r0, [sp, #32]
    d310:	ldr	r3, [sp, #12]
    d312:	orr.w	r3, r3, #4
    d316:	str	r3, [sp, #12]
    d318:	ldrb.w	r3, [r8]
    d31c:	b.n	d244 <_svfprintf_r+0xb4>
    d31e:	ldr	r0, [sp, #40]	; 0x28
    d320:	mov	fp, r5
    d322:	movs	r1, #0
    d324:	ldr	r4, [r0, #0]
    d326:	strb.w	r1, [sp, #111]	; 0x6f
    d32a:	adds	r7, r0, #4
    d32c:	ldr	r0, [sp, #12]
    d32e:	movs	r3, #48	; 0x30
    d330:	movs	r2, #120	; 0x78
    d332:	cmp	fp, r1
    d334:	strb.w	r3, [sp, #112]	; 0x70
    d338:	mov.w	r5, #0
    d33c:	strb.w	r2, [sp, #113]	; 0x71
    d340:	orr.w	r3, r0, #2
    d344:	blt.w	daf4 <_svfprintf_r+0x964>
    d348:	bic.w	r3, r0, #128	; 0x80
    d34c:	orr.w	r3, r3, #2
    d350:	str	r3, [sp, #12]
    d352:	orrs.w	r3, r4, r5
    d356:	str	r7, [sp, #40]	; 0x28
    d358:	beq.w	daa0 <_svfprintf_r+0x910>
    d35c:	mov	r7, r1
    d35e:	str	r2, [sp, #52]	; 0x34
    d360:	ldr	r0, [pc, #252]	; (d460 <_svfprintf_r+0x2d0>)
    d362:	b.n	d932 <_svfprintf_r+0x7a2>
    d364:	add	r2, sp, #140	; 0x8c
    d366:	ldr	r1, [sp, #20]
    d368:	ldr	r0, [sp, #24]
    d36a:	bl	12134 <__ssprint_r>
    d36e:	cbnz	r0, d384 <_svfprintf_r+0x1f4>
    d370:	add.w	r9, sp, #192	; 0xc0
    d374:	b.n	d21c <_svfprintf_r+0x8c>
    d376:	ldr	r3, [sp, #148]	; 0x94
    d378:	cbz	r3, d384 <_svfprintf_r+0x1f4>
    d37a:	ldr	r0, [sp, #24]
    d37c:	ldr	r1, [sp, #20]
    d37e:	add	r2, sp, #140	; 0x8c
    d380:	bl	12134 <__ssprint_r>
    d384:	ldr	r3, [sp, #20]
    d386:	ldrh	r3, [r3, #12]
    d388:	tst.w	r3, #64	; 0x40
    d38c:	ldr	r3, [sp, #28]
    d38e:	it	ne
    d390:	movne.w	r3, #4294967295
    d394:	mov	r0, r3
    d396:	add	sp, #260	; 0x104
    d398:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d39c:	str	r3, [sp, #52]	; 0x34
    d39e:	mov	fp, r5
    d3a0:	cmp	r2, #0
    d3a2:	bne.w	e80c <_svfprintf_r+0x167c>
    d3a6:	ldr	r2, [sp, #12]
    d3a8:	ands.w	r3, r2, #32
    d3ac:	beq.w	d83c <_svfprintf_r+0x6ac>
    d3b0:	ldr	r7, [sp, #40]	; 0x28
    d3b2:	adds	r7, #7
    d3b4:	bic.w	r3, r7, #7
    d3b8:	movs	r7, #0
    d3ba:	add.w	r1, r3, #8
    d3be:	cmp	fp, r7
    d3c0:	str	r1, [sp, #40]	; 0x28
    d3c2:	ldrd	r4, r5, [r3]
    d3c6:	strb.w	r7, [sp, #111]	; 0x6f
    d3ca:	blt.w	e292 <_svfprintf_r+0x1102>
    d3ce:	bic.w	r3, r2, #128	; 0x80
    d3d2:	str	r3, [sp, #12]
    d3d4:	orrs.w	r3, r4, r5
    d3d8:	beq.w	dae4 <_svfprintf_r+0x954>
    d3dc:	add	r6, sp, #192	; 0xc0
    d3de:	lsrs	r2, r4, #3
    d3e0:	orr.w	r2, r2, r5, lsl #29
    d3e4:	lsrs	r1, r5, #3
    d3e6:	and.w	r3, r4, #7
    d3ea:	mov	r5, r1
    d3ec:	mov	r4, r2
    d3ee:	adds	r3, #48	; 0x30
    d3f0:	orrs.w	r2, r4, r5
    d3f4:	strb.w	r3, [r6, #-1]!
    d3f8:	bne.n	d3de <_svfprintf_r+0x24e>
    d3fa:	ldr	r2, [sp, #12]
    d3fc:	lsls	r1, r2, #31
    d3fe:	bpl.w	d520 <_svfprintf_r+0x390>
    d402:	cmp	r3, #48	; 0x30
    d404:	beq.w	d520 <_svfprintf_r+0x390>
    d408:	movs	r2, #48	; 0x30
    d40a:	subs	r3, r6, #1
    d40c:	strb.w	r2, [r6, #-1]
    d410:	add	r2, sp, #192	; 0xc0
    d412:	subs	r2, r2, r3
    d414:	str	r2, [sp, #36]	; 0x24
    d416:	mov	r6, r3
    d418:	b.n	d526 <_svfprintf_r+0x396>
    d41a:	ldrb.w	r3, [r8]
    d41e:	cmp	r3, #42	; 0x2a
    d420:	add.w	r4, r8, #1
    d424:	beq.w	e7f0 <_svfprintf_r+0x1660>
    d428:	sub.w	r0, r3, #48	; 0x30
    d42c:	cmp	r0, #9
    d42e:	it	ls
    d430:	movls	r5, #0
    d432:	bhi.w	e742 <_svfprintf_r+0x15b2>
    d436:	ldrb.w	r3, [r4], #1
    d43a:	add.w	r5, r5, r5, lsl #2
    d43e:	add.w	r5, r0, r5, lsl #1
    d442:	sub.w	r0, r3, #48	; 0x30
    d446:	cmp	r0, #9
    d448:	bls.n	d436 <_svfprintf_r+0x2a6>
    d44a:	orr.w	r5, r5, r5, asr #31
    d44e:	mov	r8, r4
    d450:	b.n	d248 <_svfprintf_r+0xb8>
    d452:	nop
    d454:	nop.w
	...
    d460:	.word	0x000131b4
    d464:	.word	0x00013180
    d468:	ldr	r3, [sp, #12]
    d46a:	orr.w	r3, r3, #128	; 0x80
    d46e:	str	r3, [sp, #12]
    d470:	ldrb.w	r3, [r8]
    d474:	b.n	d244 <_svfprintf_r+0xb4>
    d476:	sub.w	r0, r3, #48	; 0x30
    d47a:	movs	r3, #0
    d47c:	mov	r4, r3
    d47e:	ldrb.w	r3, [r8], #1
    d482:	add.w	r4, r4, r4, lsl #2
    d486:	add.w	r4, r0, r4, lsl #1
    d48a:	sub.w	r0, r3, #48	; 0x30
    d48e:	cmp	r0, #9
    d490:	bls.n	d47e <_svfprintf_r+0x2ee>
    d492:	str	r4, [sp, #32]
    d494:	b.n	d248 <_svfprintf_r+0xb8>
    d496:	str	r3, [sp, #52]	; 0x34
    d498:	mov	fp, r5
    d49a:	cmp	r2, #0
    d49c:	bne.w	e828 <_svfprintf_r+0x1698>
    d4a0:	ldr	r3, [sp, #12]
    d4a2:	orr.w	r3, r3, #16
    d4a6:	str	r3, [sp, #12]
    d4a8:	ldr	r3, [sp, #12]
    d4aa:	lsls	r4, r3, #26
    d4ac:	bpl.w	df1e <_svfprintf_r+0xd8e>
    d4b0:	ldr	r7, [sp, #40]	; 0x28
    d4b2:	adds	r7, #7
    d4b4:	bic.w	r7, r7, #7
    d4b8:	ldrd	r2, r3, [r7]
    d4bc:	add.w	r1, r7, #8
    d4c0:	str	r1, [sp, #40]	; 0x28
    d4c2:	mov	r4, r2
    d4c4:	mov	r5, r3
    d4c6:	cmp	r2, #0
    d4c8:	sbcs.w	r3, r3, #0
    d4cc:	blt.w	df94 <_svfprintf_r+0xe04>
    d4d0:	cmp.w	fp, #0
    d4d4:	ldrb.w	r7, [sp, #111]	; 0x6f
    d4d8:	blt.w	df5a <_svfprintf_r+0xdca>
    d4dc:	ldr	r3, [sp, #12]
    d4de:	bic.w	r3, r3, #128	; 0x80
    d4e2:	str	r3, [sp, #12]
    d4e4:	orrs.w	r3, r4, r5
    d4e8:	beq.w	d8bc <_svfprintf_r+0x72c>
    d4ec:	cmp	r5, #0
    d4ee:	it	eq
    d4f0:	cmpeq	r4, #10
    d4f2:	bcc.w	d8c6 <_svfprintf_r+0x736>
    d4f6:	add	r6, sp, #192	; 0xc0
    d4f8:	mov	r0, r4
    d4fa:	mov	r1, r5
    d4fc:	movs	r2, #10
    d4fe:	movs	r3, #0
    d500:	bl	af70 <__aeabi_uldivmod>
    d504:	adds	r2, #48	; 0x30
    d506:	strb.w	r2, [r6, #-1]!
    d50a:	mov	r0, r4
    d50c:	mov	r1, r5
    d50e:	movs	r3, #0
    d510:	movs	r2, #10
    d512:	bl	af70 <__aeabi_uldivmod>
    d516:	mov	r4, r0
    d518:	mov	r5, r1
    d51a:	orrs.w	r3, r4, r5
    d51e:	bne.n	d4f8 <_svfprintf_r+0x368>
    d520:	add	r3, sp, #192	; 0xc0
    d522:	subs	r3, r3, r6
    d524:	str	r3, [sp, #36]	; 0x24
    d526:	ldr	r3, [sp, #36]	; 0x24
    d528:	cmp	r3, fp
    d52a:	it	lt
    d52c:	movlt	r3, fp
    d52e:	str	r3, [sp, #16]
    d530:	movs	r3, #0
    d532:	str	r3, [sp, #60]	; 0x3c
    d534:	cbz	r7, d53c <_svfprintf_r+0x3ac>
    d536:	ldr	r3, [sp, #16]
    d538:	adds	r3, #1
    d53a:	str	r3, [sp, #16]
    d53c:	ldr	r3, [sp, #12]
    d53e:	ands.w	r3, r3, #2
    d542:	str	r3, [sp, #44]	; 0x2c
    d544:	beq.n	d54c <_svfprintf_r+0x3bc>
    d546:	ldr	r3, [sp, #16]
    d548:	adds	r3, #2
    d54a:	str	r3, [sp, #16]
    d54c:	ldr	r3, [sp, #12]
    d54e:	ands.w	r3, r3, #132	; 0x84
    d552:	str	r3, [sp, #48]	; 0x30
    d554:	bne.w	db0e <_svfprintf_r+0x97e>
    d558:	ldr	r3, [sp, #32]
    d55a:	ldr	r2, [sp, #16]
    d55c:	subs	r5, r3, r2
    d55e:	cmp	r5, #0
    d560:	ble.w	db0e <_svfprintf_r+0x97e>
    d564:	cmp	r5, #16
    d566:	ldr	r1, [sp, #148]	; 0x94
    d568:	ldr	r2, [sp, #144]	; 0x90
    d56a:	ldr	r7, [pc, #672]	; (d80c <_svfprintf_r+0x67c>)
    d56c:	ble.n	d5be <_svfprintf_r+0x42e>
    d56e:	str	r6, [sp, #80]	; 0x50
    d570:	mov	r0, r9
    d572:	movs	r4, #16
    d574:	mov	r9, r7
    d576:	ldr	r6, [sp, #20]
    d578:	mov	r7, r5
    d57a:	ldr	r5, [sp, #24]
    d57c:	b.n	d588 <_svfprintf_r+0x3f8>
    d57e:	subs	r7, #16
    d580:	cmp	r7, #16
    d582:	add.w	r0, r0, #8
    d586:	ble.n	d5b6 <_svfprintf_r+0x426>
    d588:	adds	r2, #1
    d58a:	ldr	r3, [pc, #640]	; (d80c <_svfprintf_r+0x67c>)
    d58c:	str	r2, [sp, #144]	; 0x90
    d58e:	adds	r1, #16
    d590:	cmp	r2, #7
    d592:	str	r1, [sp, #148]	; 0x94
    d594:	stmia.w	r0, {r3, r4}
    d598:	ble.n	d57e <_svfprintf_r+0x3ee>
    d59a:	add	r2, sp, #140	; 0x8c
    d59c:	mov	r1, r6
    d59e:	mov	r0, r5
    d5a0:	bl	12134 <__ssprint_r>
    d5a4:	cmp	r0, #0
    d5a6:	bne.w	d384 <_svfprintf_r+0x1f4>
    d5aa:	subs	r7, #16
    d5ac:	cmp	r7, #16
    d5ae:	ldr	r1, [sp, #148]	; 0x94
    d5b0:	ldr	r2, [sp, #144]	; 0x90
    d5b2:	add	r0, sp, #192	; 0xc0
    d5b4:	bgt.n	d588 <_svfprintf_r+0x3f8>
    d5b6:	ldr	r6, [sp, #80]	; 0x50
    d5b8:	mov	r5, r7
    d5ba:	mov	r7, r9
    d5bc:	mov	r9, r0
    d5be:	adds	r2, #1
    d5c0:	adds	r4, r5, r1
    d5c2:	cmp	r2, #7
    d5c4:	str	r4, [sp, #148]	; 0x94
    d5c6:	str	r2, [sp, #144]	; 0x90
    d5c8:	str.w	r7, [r9]
    d5cc:	str.w	r5, [r9, #4]
    d5d0:	bgt.w	de2e <_svfprintf_r+0xc9e>
    d5d4:	ldrb.w	r7, [sp, #111]	; 0x6f
    d5d8:	add.w	r9, r9, #8
    d5dc:	cbz	r7, d5fc <_svfprintf_r+0x46c>
    d5de:	ldr	r3, [sp, #144]	; 0x90
    d5e0:	adds	r3, #1
    d5e2:	adds	r4, #1
    d5e4:	add.w	r1, sp, #111	; 0x6f
    d5e8:	movs	r2, #1
    d5ea:	cmp	r3, #7
    d5ec:	str	r4, [sp, #148]	; 0x94
    d5ee:	str	r3, [sp, #144]	; 0x90
    d5f0:	stmia.w	r9, {r1, r2}
    d5f4:	bgt.w	dd42 <_svfprintf_r+0xbb2>
    d5f8:	add.w	r9, r9, #8
    d5fc:	ldr	r3, [sp, #44]	; 0x2c
    d5fe:	cbz	r3, d61c <_svfprintf_r+0x48c>
    d600:	ldr	r3, [sp, #144]	; 0x90
    d602:	adds	r3, #1
    d604:	adds	r4, #2
    d606:	add	r1, sp, #112	; 0x70
    d608:	movs	r2, #2
    d60a:	cmp	r3, #7
    d60c:	str	r4, [sp, #148]	; 0x94
    d60e:	str	r3, [sp, #144]	; 0x90
    d610:	stmia.w	r9, {r1, r2}
    d614:	bgt.w	dd5a <_svfprintf_r+0xbca>
    d618:	add.w	r9, r9, #8
    d61c:	ldr	r3, [sp, #48]	; 0x30
    d61e:	cmp	r3, #128	; 0x80
    d620:	beq.w	dbe6 <_svfprintf_r+0xa56>
    d624:	ldr	r3, [sp, #36]	; 0x24
    d626:	rsb	r7, r3, fp
    d62a:	cmp	r7, #0
    d62c:	ble.n	d696 <_svfprintf_r+0x506>
    d62e:	ldr	r2, [pc, #480]	; (d810 <_svfprintf_r+0x680>)
    d630:	ldr	r3, [sp, #144]	; 0x90
    d632:	str	r2, [sp, #44]	; 0x2c
    d634:	cmp	r7, #16
    d636:	ble.n	d67e <_svfprintf_r+0x4ee>
    d638:	mov	r2, r4
    d63a:	mov.w	fp, #16
    d63e:	ldr	r5, [sp, #24]
    d640:	ldr	r4, [sp, #20]
    d642:	b.n	d64e <_svfprintf_r+0x4be>
    d644:	subs	r7, #16
    d646:	cmp	r7, #16
    d648:	add.w	r9, r9, #8
    d64c:	ble.n	d67c <_svfprintf_r+0x4ec>
    d64e:	adds	r3, #1
    d650:	adds	r2, #16
    d652:	cmp	r3, #7
    d654:	str	r2, [sp, #148]	; 0x94
    d656:	str	r3, [sp, #144]	; 0x90
    d658:	stmia.w	r9, {sl, fp}
    d65c:	ble.n	d644 <_svfprintf_r+0x4b4>
    d65e:	add	r2, sp, #140	; 0x8c
    d660:	mov	r1, r4
    d662:	mov	r0, r5
    d664:	bl	12134 <__ssprint_r>
    d668:	cmp	r0, #0
    d66a:	bne.w	d384 <_svfprintf_r+0x1f4>
    d66e:	subs	r7, #16
    d670:	cmp	r7, #16
    d672:	ldr	r2, [sp, #148]	; 0x94
    d674:	ldr	r3, [sp, #144]	; 0x90
    d676:	add.w	r9, sp, #192	; 0xc0
    d67a:	bgt.n	d64e <_svfprintf_r+0x4be>
    d67c:	mov	r4, r2
    d67e:	adds	r3, #1
    d680:	ldr	r2, [sp, #44]	; 0x2c
    d682:	str	r3, [sp, #144]	; 0x90
    d684:	add	r4, r7
    d686:	cmp	r3, #7
    d688:	str	r4, [sp, #148]	; 0x94
    d68a:	stmia.w	r9, {r2, r7}
    d68e:	bgt.w	dd2a <_svfprintf_r+0xb9a>
    d692:	add.w	r9, r9, #8
    d696:	ldr	r3, [sp, #12]
    d698:	lsls	r2, r3, #23
    d69a:	bmi.w	db12 <_svfprintf_r+0x982>
    d69e:	ldr	r3, [sp, #144]	; 0x90
    d6a0:	ldr	r1, [sp, #36]	; 0x24
    d6a2:	str.w	r6, [r9]
    d6a6:	adds	r3, #1
    d6a8:	add	r4, r1
    d6aa:	cmp	r3, #7
    d6ac:	str	r4, [sp, #148]	; 0x94
    d6ae:	str.w	r1, [r9, #4]
    d6b2:	str	r3, [sp, #144]	; 0x90
    d6b4:	bgt.w	dcfe <_svfprintf_r+0xb6e>
    d6b8:	add.w	r9, r9, #8
    d6bc:	ldr	r3, [sp, #12]
    d6be:	lsls	r1, r3, #29
    d6c0:	bpl.n	d742 <_svfprintf_r+0x5b2>
    d6c2:	ldr	r3, [sp, #32]
    d6c4:	ldr	r2, [sp, #16]
    d6c6:	subs	r5, r3, r2
    d6c8:	cmp	r5, #0
    d6ca:	ble.n	d742 <_svfprintf_r+0x5b2>
    d6cc:	cmp	r5, #16
    d6ce:	ldr	r3, [sp, #144]	; 0x90
    d6d0:	ldr	r7, [pc, #312]	; (d80c <_svfprintf_r+0x67c>)
    d6d2:	ble.n	d71c <_svfprintf_r+0x58c>
    d6d4:	mov	r2, r4
    d6d6:	movs	r6, #16
    d6d8:	ldr.w	fp, [sp, #24]
    d6dc:	ldr	r4, [sp, #20]
    d6de:	b.n	d6ea <_svfprintf_r+0x55a>
    d6e0:	subs	r5, #16
    d6e2:	cmp	r5, #16
    d6e4:	add.w	r9, r9, #8
    d6e8:	ble.n	d71a <_svfprintf_r+0x58a>
    d6ea:	adds	r3, #1
    d6ec:	ldr	r1, [pc, #284]	; (d80c <_svfprintf_r+0x67c>)
    d6ee:	str	r3, [sp, #144]	; 0x90
    d6f0:	adds	r2, #16
    d6f2:	cmp	r3, #7
    d6f4:	str	r2, [sp, #148]	; 0x94
    d6f6:	stmia.w	r9, {r1, r6}
    d6fa:	ble.n	d6e0 <_svfprintf_r+0x550>
    d6fc:	add	r2, sp, #140	; 0x8c
    d6fe:	mov	r1, r4
    d700:	mov	r0, fp
    d702:	bl	12134 <__ssprint_r>
    d706:	cmp	r0, #0
    d708:	bne.w	d384 <_svfprintf_r+0x1f4>
    d70c:	subs	r5, #16
    d70e:	cmp	r5, #16
    d710:	ldr	r2, [sp, #148]	; 0x94
    d712:	ldr	r3, [sp, #144]	; 0x90
    d714:	add.w	r9, sp, #192	; 0xc0
    d718:	bgt.n	d6ea <_svfprintf_r+0x55a>
    d71a:	mov	r4, r2
    d71c:	adds	r3, #1
    d71e:	add	r4, r5
    d720:	cmp	r3, #7
    d722:	str	r4, [sp, #148]	; 0x94
    d724:	str	r3, [sp, #144]	; 0x90
    d726:	str.w	r7, [r9]
    d72a:	str.w	r5, [r9, #4]
    d72e:	ble.n	d742 <_svfprintf_r+0x5b2>
    d730:	add	r2, sp, #140	; 0x8c
    d732:	ldr	r1, [sp, #20]
    d734:	ldr	r0, [sp, #24]
    d736:	bl	12134 <__ssprint_r>
    d73a:	cmp	r0, #0
    d73c:	bne.w	d384 <_svfprintf_r+0x1f4>
    d740:	ldr	r4, [sp, #148]	; 0x94
    d742:	ldr	r3, [sp, #28]
    d744:	ldr	r2, [sp, #32]
    d746:	ldr	r1, [sp, #16]
    d748:	cmp	r2, r1
    d74a:	ite	ge
    d74c:	addge	r3, r3, r2
    d74e:	addlt	r3, r3, r1
    d750:	str	r3, [sp, #28]
    d752:	cmp	r4, #0
    d754:	bne.w	dd16 <_svfprintf_r+0xb86>
    d758:	movs	r3, #0
    d75a:	str	r3, [sp, #144]	; 0x90
    d75c:	add.w	r9, sp, #192	; 0xc0
    d760:	b.n	d1de <_svfprintf_r+0x4e>
    d762:	str	r3, [sp, #52]	; 0x34
    d764:	mov	fp, r5
    d766:	cmp	r2, #0
    d768:	bne.w	e830 <_svfprintf_r+0x16a0>
    d76c:	ldr	r3, [sp, #12]
    d76e:	ldr	r7, [sp, #40]	; 0x28
    d770:	lsls	r2, r3, #28
    d772:	add.w	r7, r7, #7
    d776:	bpl.w	e262 <_svfprintf_r+0x10d2>
    d77a:	bic.w	r3, r7, #7
    d77e:	vldr	d7, [r3]
    d782:	vstr	d7, [sp, #64]	; 0x40
    d786:	add.w	r2, r3, #8
    d78a:	str	r2, [sp, #40]	; 0x28
    d78c:	ldrd	r1, r2, [sp, #64]	; 0x40
    d790:	bic.w	r3, r2, #2147483648	; 0x80000000
    d794:	str	r1, [sp, #88]	; 0x58
    d796:	str	r3, [sp, #92]	; 0x5c
    d798:	ldrd	r4, r5, [sp, #88]	; 0x58
    d79c:	mov.w	r2, #4294967295
    d7a0:	mov	r0, r4
    d7a2:	mov	r1, r5
    d7a4:	ldr	r3, [pc, #108]	; (d814 <_svfprintf_r+0x684>)
    d7a6:	bl	ae14 <__aeabi_dcmpun>
    d7aa:	cmp	r0, #0
    d7ac:	bne.w	e164 <_svfprintf_r+0xfd4>
    d7b0:	mov.w	r2, #4294967295
    d7b4:	ldr	r3, [pc, #92]	; (d814 <_svfprintf_r+0x684>)
    d7b6:	mov	r0, r4
    d7b8:	mov	r1, r5
    d7ba:	bl	add8 <__aeabi_dcmple>
    d7be:	cmp	r0, #0
    d7c0:	bne.w	e164 <_svfprintf_r+0xfd4>
    d7c4:	movs	r2, #0
    d7c6:	movs	r3, #0
    d7c8:	ldrd	r0, r1, [sp, #64]	; 0x40
    d7cc:	bl	adc4 <__aeabi_dcmplt>
    d7d0:	cmp	r0, #0
    d7d2:	bne.w	e67a <_svfprintf_r+0x14ea>
    d7d6:	ldrb.w	r7, [sp, #111]	; 0x6f
    d7da:	ldr	r6, [pc, #60]	; (d818 <_svfprintf_r+0x688>)
    d7dc:	ldr	r3, [pc, #60]	; (d81c <_svfprintf_r+0x68c>)
    d7de:	ldr	r1, [sp, #12]
    d7e0:	bic.w	r1, r1, #128	; 0x80
    d7e4:	str	r1, [sp, #12]
    d7e6:	ldr	r1, [sp, #52]	; 0x34
    d7e8:	movs	r2, #3
    d7ea:	mov.w	fp, #0
    d7ee:	str	r2, [sp, #16]
    d7f0:	cmp	r1, #71	; 0x47
    d7f2:	it	le
    d7f4:	movle	r6, r3
    d7f6:	str	r2, [sp, #36]	; 0x24
    d7f8:	str.w	fp, [sp, #60]	; 0x3c
    d7fc:	b.n	d534 <_svfprintf_r+0x3a4>
    d7fe:	ldr	r3, [sp, #12]
    d800:	orr.w	r3, r3, #8
    d804:	str	r3, [sp, #12]
    d806:	ldrb.w	r3, [r8]
    d80a:	b.n	d244 <_svfprintf_r+0xb4>
    d80c:	.word	0x000131d4
    d810:	.word	0x00013180
    d814:	.word	0x7fefffff
    d818:	.word	0x00013194
    d81c:	.word	0x00013190
    d820:	str	r3, [sp, #52]	; 0x34
    d822:	mov	fp, r5
    d824:	cmp	r2, #0
    d826:	bne.w	e848 <_svfprintf_r+0x16b8>
    d82a:	ldr	r3, [sp, #12]
    d82c:	orr.w	r3, r3, #16
    d830:	str	r3, [sp, #12]
    d832:	ldr	r2, [sp, #12]
    d834:	ands.w	r3, r2, #32
    d838:	bne.w	d3b0 <_svfprintf_r+0x220>
    d83c:	ldr	r1, [sp, #12]
    d83e:	ands.w	r2, r1, #16
    d842:	beq.w	e0fc <_svfprintf_r+0xf6c>
    d846:	ldr	r0, [sp, #40]	; 0x28
    d848:	strb.w	r3, [sp, #111]	; 0x6f
    d84c:	cmp.w	fp, #0
    d850:	ldr	r4, [r0, #0]
    d852:	add.w	r7, r0, #4
    d856:	mov.w	r5, #0
    d85a:	blt.w	e290 <_svfprintf_r+0x1100>
    d85e:	mov	r2, r1
    d860:	bic.w	r2, r2, #128	; 0x80
    d864:	str	r2, [sp, #12]
    d866:	orrs.w	r2, r4, r5
    d86a:	str	r7, [sp, #40]	; 0x28
    d86c:	beq.w	dae4 <_svfprintf_r+0x954>
    d870:	mov	r7, r3
    d872:	b.n	d3dc <_svfprintf_r+0x24c>
    d874:	str	r3, [sp, #52]	; 0x34
    d876:	mov	fp, r5
    d878:	cmp	r2, #0
    d87a:	bne.w	e840 <_svfprintf_r+0x16b0>
    d87e:	ldr	r3, [sp, #12]
    d880:	orr.w	r3, r3, #16
    d884:	str	r3, [sp, #12]
    d886:	ldr	r2, [sp, #12]
    d888:	ands.w	r3, r2, #32
    d88c:	beq.w	dee8 <_svfprintf_r+0xd58>
    d890:	ldr	r7, [sp, #40]	; 0x28
    d892:	adds	r7, #7
    d894:	bic.w	r3, r7, #7
    d898:	movs	r7, #0
    d89a:	add.w	r1, r3, #8
    d89e:	cmp	fp, r7
    d8a0:	str	r1, [sp, #40]	; 0x28
    d8a2:	ldrd	r4, r5, [r3]
    d8a6:	strb.w	r7, [sp, #111]	; 0x6f
    d8aa:	blt.w	df5a <_svfprintf_r+0xdca>
    d8ae:	bic.w	r3, r2, #128	; 0x80
    d8b2:	str	r3, [sp, #12]
    d8b4:	orrs.w	r3, r4, r5
    d8b8:	bne.w	d4ec <_svfprintf_r+0x35c>
    d8bc:	cmp.w	fp, #0
    d8c0:	beq.w	daae <_svfprintf_r+0x91e>
    d8c4:	movs	r4, #0
    d8c6:	add	r6, sp, #256	; 0x100
    d8c8:	adds	r4, #48	; 0x30
    d8ca:	strb.w	r4, [r6, #-65]!
    d8ce:	b.n	d520 <_svfprintf_r+0x390>
    d8d0:	str	r3, [sp, #52]	; 0x34
    d8d2:	mov	fp, r5
    d8d4:	cmp	r2, #0
    d8d6:	bne.w	e838 <_svfprintf_r+0x16a8>
    d8da:	ldr	r3, [sp, #12]
    d8dc:	ldr	r0, [pc, #700]	; (db9c <_svfprintf_r+0xa0c>)
    d8de:	lsls	r5, r3, #26
    d8e0:	bpl.w	da4e <_svfprintf_r+0x8be>
    d8e4:	ldr	r7, [sp, #40]	; 0x28
    d8e6:	adds	r7, #7
    d8e8:	bic.w	r3, r7, #7
    d8ec:	ldrd	r4, r5, [r3]
    d8f0:	add.w	r2, r3, #8
    d8f4:	str	r2, [sp, #40]	; 0x28
    d8f6:	ldr	r2, [sp, #12]
    d8f8:	ands.w	r7, r2, #1
    d8fc:	beq.w	dd72 <_svfprintf_r+0xbe2>
    d900:	orrs.w	r3, r4, r5
    d904:	beq.w	e30c <_svfprintf_r+0x117c>
    d908:	ldrb.w	r2, [sp, #52]	; 0x34
    d90c:	strb.w	r2, [sp, #113]	; 0x71
    d910:	movs	r7, #0
    d912:	ldr	r2, [sp, #12]
    d914:	strb.w	r7, [sp, #111]	; 0x6f
    d918:	movs	r3, #48	; 0x30
    d91a:	cmp	fp, r7
    d91c:	strb.w	r3, [sp, #112]	; 0x70
    d920:	orr.w	r3, r2, #2
    d924:	blt.w	e684 <_svfprintf_r+0x14f4>
    d928:	bic.w	r3, r2, #128	; 0x80
    d92c:	orr.w	r3, r3, #2
    d930:	str	r3, [sp, #12]
    d932:	add	r6, sp, #192	; 0xc0
    d934:	lsrs	r3, r4, #4
    d936:	and.w	r1, r4, #15
    d93a:	orr.w	r3, r3, r5, lsl #28
    d93e:	lsrs	r2, r5, #4
    d940:	mov	r4, r3
    d942:	mov	r5, r2
    d944:	ldrb	r3, [r0, r1]
    d946:	strb.w	r3, [r6, #-1]!
    d94a:	orrs.w	r3, r4, r5
    d94e:	bne.n	d934 <_svfprintf_r+0x7a4>
    d950:	b.n	d520 <_svfprintf_r+0x390>
    d952:	ldr	r1, [sp, #40]	; 0x28
    d954:	str	r3, [sp, #52]	; 0x34
    d956:	ldr	r2, [r1, #0]
    d958:	strb.w	r2, [sp, #152]	; 0x98
    d95c:	movs	r3, #0
    d95e:	mov	r2, r1
    d960:	mov	r7, r3
    d962:	strb.w	r3, [sp, #111]	; 0x6f
    d966:	adds	r2, #4
    d968:	movs	r3, #1
    d96a:	str	r3, [sp, #16]
    d96c:	mov	fp, r7
    d96e:	str	r7, [sp, #60]	; 0x3c
    d970:	str	r2, [sp, #40]	; 0x28
    d972:	str	r3, [sp, #36]	; 0x24
    d974:	add	r6, sp, #152	; 0x98
    d976:	b.n	d53c <_svfprintf_r+0x3ac>
    d978:	str	r3, [sp, #52]	; 0x34
    d97a:	mov	fp, r5
    d97c:	cmp	r2, #0
    d97e:	beq.w	d4a8 <_svfprintf_r+0x318>
    d982:	strb.w	r1, [sp, #111]	; 0x6f
    d986:	b.n	d4a8 <_svfprintf_r+0x318>
    d988:	ldr	r3, [sp, #12]
    d98a:	orr.w	r3, r3, #64	; 0x40
    d98e:	str	r3, [sp, #12]
    d990:	ldrb.w	r3, [r8]
    d994:	b.n	d244 <_svfprintf_r+0xb4>
    d996:	ldrb.w	r3, [r8]
    d99a:	cmp	r1, #0
    d99c:	bne.w	d244 <_svfprintf_r+0xb4>
    d9a0:	movs	r2, #1
    d9a2:	movs	r1, #32
    d9a4:	b.n	d244 <_svfprintf_r+0xb4>
    d9a6:	ldr	r3, [sp, #12]
    d9a8:	orr.w	r3, r3, #1
    d9ac:	str	r3, [sp, #12]
    d9ae:	ldrb.w	r3, [r8]
    d9b2:	b.n	d244 <_svfprintf_r+0xb4>
    d9b4:	ldr	r4, [sp, #40]	; 0x28
    d9b6:	ldr	r3, [r4, #0]
    d9b8:	str	r3, [sp, #32]
    d9ba:	mov	r0, r3
    d9bc:	cmp	r0, #0
    d9be:	mov	r3, r4
    d9c0:	add.w	r3, r3, #4
    d9c4:	blt.w	d308 <_svfprintf_r+0x178>
    d9c8:	str	r3, [sp, #40]	; 0x28
    d9ca:	ldrb.w	r3, [r8]
    d9ce:	b.n	d244 <_svfprintf_r+0xb4>
    d9d0:	ldrb.w	r3, [r8]
    d9d4:	movs	r2, #1
    d9d6:	movs	r1, #43	; 0x2b
    d9d8:	b.n	d244 <_svfprintf_r+0xb4>
    d9da:	ldr	r3, [sp, #12]
    d9dc:	orr.w	r3, r3, #32
    d9e0:	str	r3, [sp, #12]
    d9e2:	ldrb.w	r3, [r8]
    d9e6:	b.n	d244 <_svfprintf_r+0xb4>
    d9e8:	ldr	r2, [sp, #40]	; 0x28
    d9ea:	str	r3, [sp, #52]	; 0x34
    d9ec:	ldr	r6, [r2, #0]
    d9ee:	movs	r4, #0
    d9f0:	strb.w	r4, [sp, #111]	; 0x6f
    d9f4:	adds	r7, r2, #4
    d9f6:	cmp	r6, #0
    d9f8:	beq.w	e634 <_svfprintf_r+0x14a4>
    d9fc:	cmp	r5, #0
    d9fe:	blt.w	e4c4 <_svfprintf_r+0x1334>
    da02:	mov	r2, r5
    da04:	mov	r1, r4
    da06:	mov	r0, r6
    da08:	bl	b900 <memchr>
    da0c:	cmp	r0, #0
    da0e:	beq.w	e6d8 <_svfprintf_r+0x1548>
    da12:	subs	r3, r0, r6
    da14:	str	r3, [sp, #36]	; 0x24
    da16:	mov	fp, r4
    da18:	bic.w	r3, r3, r3, asr #31
    da1c:	str	r7, [sp, #40]	; 0x28
    da1e:	str	r3, [sp, #16]
    da20:	str.w	fp, [sp, #60]	; 0x3c
    da24:	ldrb.w	r7, [sp, #111]	; 0x6f
    da28:	b.n	d534 <_svfprintf_r+0x3a4>
    da2a:	str	r3, [sp, #52]	; 0x34
    da2c:	mov	fp, r5
    da2e:	cmp	r2, #0
    da30:	beq.w	d886 <_svfprintf_r+0x6f6>
    da34:	strb.w	r1, [sp, #111]	; 0x6f
    da38:	b.n	d886 <_svfprintf_r+0x6f6>
    da3a:	str	r3, [sp, #52]	; 0x34
    da3c:	mov	fp, r5
    da3e:	cmp	r2, #0
    da40:	bne.w	e860 <_svfprintf_r+0x16d0>
    da44:	ldr	r3, [sp, #12]
    da46:	ldr	r0, [pc, #344]	; (dba0 <_svfprintf_r+0xa10>)
    da48:	lsls	r5, r3, #26
    da4a:	bmi.w	d8e4 <_svfprintf_r+0x754>
    da4e:	ldr	r3, [sp, #12]
    da50:	lsls	r4, r3, #27
    da52:	bpl.w	e2d2 <_svfprintf_r+0x1142>
    da56:	ldr	r2, [sp, #40]	; 0x28
    da58:	mov	r3, r2
    da5a:	adds	r3, #4
    da5c:	ldr	r4, [r2, #0]
    da5e:	str	r3, [sp, #40]	; 0x28
    da60:	movs	r5, #0
    da62:	b.n	d8f6 <_svfprintf_r+0x766>
    da64:	ldrb.w	r3, [r8]
    da68:	cmp	r3, #108	; 0x6c
    da6a:	beq.w	e3f2 <_svfprintf_r+0x1262>
    da6e:	ldr	r0, [sp, #12]
    da70:	orr.w	r0, r0, #16
    da74:	str	r0, [sp, #12]
    da76:	b.w	d244 <_svfprintf_r+0xb4>
    da7a:	cmp	r2, #0
    da7c:	bne.w	e858 <_svfprintf_r+0x16c8>
    da80:	ldr	r3, [sp, #12]
    da82:	lsls	r3, r3, #26
    da84:	bpl.w	e136 <_svfprintf_r+0xfa6>
    da88:	ldr	r2, [sp, #40]	; 0x28
    da8a:	ldr	r1, [sp, #28]
    da8c:	ldr	r3, [r2, #0]
    da8e:	asrs	r5, r1, #31
    da90:	mov	r0, r1
    da92:	adds	r2, #4
    da94:	mov	r1, r5
    da96:	str	r2, [sp, #40]	; 0x28
    da98:	strd	r0, r1, [r3]
    da9c:	b.w	d1de <_svfprintf_r+0x4e>
    daa0:	ldr	r0, [pc, #252]	; (dba0 <_svfprintf_r+0xa10>)
    daa2:	str	r2, [sp, #52]	; 0x34
    daa4:	cmp.w	fp, #0
    daa8:	bne.w	dd94 <_svfprintf_r+0xc04>
    daac:	mov	r7, fp
    daae:	mov.w	fp, #0
    dab2:	str.w	fp, [sp, #36]	; 0x24
    dab6:	add	r6, sp, #192	; 0xc0
    dab8:	b.n	d526 <_svfprintf_r+0x396>
    daba:	str	r3, [sp, #52]	; 0x34
    dabc:	cmp	r2, #0
    dabe:	bne.w	e850 <_svfprintf_r+0x16c0>
    dac2:	ldr	r2, [sp, #52]	; 0x34
    dac4:	cmp	r2, #0
    dac6:	beq.w	d376 <_svfprintf_r+0x1e6>
    daca:	movs	r3, #0
    dacc:	movs	r1, #1
    dace:	mov	r7, r3
    dad0:	str	r1, [sp, #16]
    dad2:	strb.w	r2, [sp, #152]	; 0x98
    dad6:	strb.w	r3, [sp, #111]	; 0x6f
    dada:	mov	fp, r3
    dadc:	str	r3, [sp, #60]	; 0x3c
    dade:	str	r1, [sp, #36]	; 0x24
    dae0:	add	r6, sp, #152	; 0x98
    dae2:	b.n	d53c <_svfprintf_r+0x3ac>
    dae4:	cmp.w	fp, #0
    dae8:	beq.w	e708 <_svfprintf_r+0x1578>
    daec:	movs	r7, #0
    daee:	movs	r4, #0
    daf0:	movs	r5, #0
    daf2:	b.n	d3dc <_svfprintf_r+0x24c>
    daf4:	ldr	r0, [pc, #168]	; (dba0 <_svfprintf_r+0xa10>)
    daf6:	str	r3, [sp, #12]
    daf8:	str	r2, [sp, #52]	; 0x34
    dafa:	orrs.w	r3, r4, r5
    dafe:	str	r7, [sp, #40]	; 0x28
    db00:	mov.w	r7, #0
    db04:	bne.w	d932 <_svfprintf_r+0x7a2>
    db08:	movs	r4, #0
    db0a:	movs	r5, #0
    db0c:	b.n	d932 <_svfprintf_r+0x7a2>
    db0e:	ldr	r4, [sp, #148]	; 0x94
    db10:	b.n	d5dc <_svfprintf_r+0x44c>
    db12:	ldr	r3, [sp, #52]	; 0x34
    db14:	cmp	r3, #101	; 0x65
    db16:	ble.w	dc6e <_svfprintf_r+0xade>
    db1a:	movs	r2, #0
    db1c:	movs	r3, #0
    db1e:	ldrd	r0, r1, [sp, #64]	; 0x40
    db22:	bl	adb0 <__aeabi_dcmpeq>
    db26:	cmp	r0, #0
    db28:	beq.w	dd98 <_svfprintf_r+0xc08>
    db2c:	ldr	r3, [sp, #144]	; 0x90
    db2e:	ldr	r2, [pc, #116]	; (dba4 <_svfprintf_r+0xa14>)
    db30:	str.w	r2, [r9]
    db34:	adds	r3, #1
    db36:	adds	r4, #1
    db38:	movs	r2, #1
    db3a:	cmp	r3, #7
    db3c:	str	r4, [sp, #148]	; 0x94
    db3e:	str	r3, [sp, #144]	; 0x90
    db40:	str.w	r2, [r9, #4]
    db44:	bgt.w	e324 <_svfprintf_r+0x1194>
    db48:	add.w	r9, r9, #8
    db4c:	ldr	r3, [sp, #116]	; 0x74
    db4e:	ldr	r2, [sp, #56]	; 0x38
    db50:	cmp	r3, r2
    db52:	blt.n	db5c <_svfprintf_r+0x9cc>
    db54:	ldr	r3, [sp, #12]
    db56:	lsls	r3, r3, #31
    db58:	bpl.w	d6bc <_svfprintf_r+0x52c>
    db5c:	ldr	r3, [sp, #144]	; 0x90
    db5e:	ldr	r1, [sp, #72]	; 0x48
    db60:	ldr	r2, [sp, #76]	; 0x4c
    db62:	str.w	r2, [r9]
    db66:	adds	r3, #1
    db68:	add	r4, r1
    db6a:	cmp	r3, #7
    db6c:	str	r4, [sp, #148]	; 0x94
    db6e:	str.w	r1, [r9, #4]
    db72:	str	r3, [sp, #144]	; 0x90
    db74:	bgt.w	e406 <_svfprintf_r+0x1276>
    db78:	add.w	r9, r9, #8
    db7c:	ldr	r3, [sp, #56]	; 0x38
    db7e:	subs	r5, r3, #1
    db80:	cmp	r5, #0
    db82:	ble.w	d6bc <_svfprintf_r+0x52c>
    db86:	ldr	r2, [pc, #32]	; (dba8 <_svfprintf_r+0xa18>)
    db88:	ldr	r3, [sp, #144]	; 0x90
    db8a:	str	r2, [sp, #44]	; 0x2c
    db8c:	cmp	r5, #16
    db8e:	ble.w	df64 <_svfprintf_r+0xdd4>
    db92:	movs	r6, #16
    db94:	ldr	r7, [sp, #24]
    db96:	ldr.w	fp, [sp, #20]
    db9a:	b.n	dbb8 <_svfprintf_r+0xa28>
    db9c:	.word	0x000131a0
    dba0:	.word	0x000131b4
    dba4:	.word	0x000131d0
    dba8:	.word	0x00013180
    dbac:	add.w	r9, r9, #8
    dbb0:	subs	r5, #16
    dbb2:	cmp	r5, #16
    dbb4:	ble.w	df64 <_svfprintf_r+0xdd4>
    dbb8:	adds	r3, #1
    dbba:	adds	r4, #16
    dbbc:	cmp	r3, #7
    dbbe:	str	r4, [sp, #148]	; 0x94
    dbc0:	str	r3, [sp, #144]	; 0x90
    dbc2:	str.w	sl, [r9]
    dbc6:	str.w	r6, [r9, #4]
    dbca:	ble.n	dbac <_svfprintf_r+0xa1c>
    dbcc:	add	r2, sp, #140	; 0x8c
    dbce:	mov	r1, fp
    dbd0:	mov	r0, r7
    dbd2:	bl	12134 <__ssprint_r>
    dbd6:	cmp	r0, #0
    dbd8:	bne.w	d384 <_svfprintf_r+0x1f4>
    dbdc:	ldr	r4, [sp, #148]	; 0x94
    dbde:	ldr	r3, [sp, #144]	; 0x90
    dbe0:	add.w	r9, sp, #192	; 0xc0
    dbe4:	b.n	dbb0 <_svfprintf_r+0xa20>
    dbe6:	ldr	r3, [sp, #32]
    dbe8:	ldr	r2, [sp, #16]
    dbea:	subs	r7, r3, r2
    dbec:	cmp	r7, #0
    dbee:	ble.w	d624 <_svfprintf_r+0x494>
    dbf2:	ldr	r2, [pc, #752]	; (dee4 <_svfprintf_r+0xd54>)
    dbf4:	ldr	r3, [sp, #144]	; 0x90
    dbf6:	str	r2, [sp, #44]	; 0x2c
    dbf8:	cmp	r7, #16
    dbfa:	ble.n	dc54 <_svfprintf_r+0xac4>
    dbfc:	mov	r2, r9
    dbfe:	mov	r1, r4
    dc00:	mov	r9, r7
    dc02:	movs	r5, #16
    dc04:	mov	r7, r6
    dc06:	ldr	r4, [sp, #24]
    dc08:	ldr	r6, [sp, #20]
    dc0a:	b.n	dc1a <_svfprintf_r+0xa8a>
    dc0c:	sub.w	r9, r9, #16
    dc10:	cmp.w	r9, #16
    dc14:	add.w	r2, r2, #8
    dc18:	ble.n	dc4c <_svfprintf_r+0xabc>
    dc1a:	adds	r3, #1
    dc1c:	adds	r1, #16
    dc1e:	cmp	r3, #7
    dc20:	str	r1, [sp, #148]	; 0x94
    dc22:	str	r3, [sp, #144]	; 0x90
    dc24:	str.w	sl, [r2]
    dc28:	str	r5, [r2, #4]
    dc2a:	ble.n	dc0c <_svfprintf_r+0xa7c>
    dc2c:	add	r2, sp, #140	; 0x8c
    dc2e:	mov	r1, r6
    dc30:	mov	r0, r4
    dc32:	bl	12134 <__ssprint_r>
    dc36:	cmp	r0, #0
    dc38:	bne.w	d384 <_svfprintf_r+0x1f4>
    dc3c:	sub.w	r9, r9, #16
    dc40:	cmp.w	r9, #16
    dc44:	ldr	r1, [sp, #148]	; 0x94
    dc46:	ldr	r3, [sp, #144]	; 0x90
    dc48:	add	r2, sp, #192	; 0xc0
    dc4a:	bgt.n	dc1a <_svfprintf_r+0xa8a>
    dc4c:	mov	r6, r7
    dc4e:	mov	r4, r1
    dc50:	mov	r7, r9
    dc52:	mov	r9, r2
    dc54:	adds	r3, #1
    dc56:	ldr	r2, [sp, #44]	; 0x2c
    dc58:	str	r3, [sp, #144]	; 0x90
    dc5a:	add	r4, r7
    dc5c:	cmp	r3, #7
    dc5e:	str	r4, [sp, #148]	; 0x94
    dc60:	stmia.w	r9, {r2, r7}
    dc64:	bgt.w	e0e2 <_svfprintf_r+0xf52>
    dc68:	add.w	r9, r9, #8
    dc6c:	b.n	d624 <_svfprintf_r+0x494>
    dc6e:	ldr	r3, [sp, #56]	; 0x38
    dc70:	ldr	r5, [sp, #144]	; 0x90
    dc72:	cmp	r3, #1
    dc74:	ble.w	e08c <_svfprintf_r+0xefc>
    dc78:	adds	r5, #1
    dc7a:	adds	r4, #1
    dc7c:	movs	r3, #1
    dc7e:	cmp	r5, #7
    dc80:	str	r4, [sp, #148]	; 0x94
    dc82:	str	r5, [sp, #144]	; 0x90
    dc84:	str.w	r6, [r9]
    dc88:	str.w	r3, [r9, #4]
    dc8c:	bgt.w	e0ae <_svfprintf_r+0xf1e>
    dc90:	add.w	r9, r9, #8
    dc94:	ldr	r2, [sp, #72]	; 0x48
    dc96:	ldr	r3, [sp, #76]	; 0x4c
    dc98:	str.w	r3, [r9]
    dc9c:	adds	r5, #1
    dc9e:	add	r4, r2
    dca0:	cmp	r5, #7
    dca2:	str	r4, [sp, #148]	; 0x94
    dca4:	str	r5, [sp, #144]	; 0x90
    dca6:	str.w	r2, [r9, #4]
    dcaa:	bgt.w	e0c8 <_svfprintf_r+0xf38>
    dcae:	add.w	r9, r9, #8
    dcb2:	movs	r3, #0
    dcb4:	movs	r2, #0
    dcb6:	ldrd	r0, r1, [sp, #64]	; 0x40
    dcba:	bl	adb0 <__aeabi_dcmpeq>
    dcbe:	ldr	r3, [sp, #56]	; 0x38
    dcc0:	cmp	r0, #0
    dcc2:	bne.w	de4c <_svfprintf_r+0xcbc>
    dcc6:	subs	r3, #1
    dcc8:	adds	r5, #1
    dcca:	adds	r6, #1
    dccc:	add	r4, r3
    dcce:	cmp	r5, #7
    dcd0:	str	r5, [sp, #144]	; 0x90
    dcd2:	str	r4, [sp, #148]	; 0x94
    dcd4:	str.w	r6, [r9]
    dcd8:	str.w	r3, [r9, #4]
    dcdc:	bgt.w	deca <_svfprintf_r+0xd3a>
    dce0:	add.w	r9, r9, #8
    dce4:	ldr	r2, [sp, #84]	; 0x54
    dce6:	str.w	r2, [r9, #4]
    dcea:	adds	r5, #1
    dcec:	add	r4, r2
    dcee:	add	r3, sp, #124	; 0x7c
    dcf0:	cmp	r5, #7
    dcf2:	str	r4, [sp, #148]	; 0x94
    dcf4:	str	r5, [sp, #144]	; 0x90
    dcf6:	str.w	r3, [r9]
    dcfa:	ble.w	d6b8 <_svfprintf_r+0x528>
    dcfe:	add	r2, sp, #140	; 0x8c
    dd00:	ldr	r1, [sp, #20]
    dd02:	ldr	r0, [sp, #24]
    dd04:	bl	12134 <__ssprint_r>
    dd08:	cmp	r0, #0
    dd0a:	bne.w	d384 <_svfprintf_r+0x1f4>
    dd0e:	ldr	r4, [sp, #148]	; 0x94
    dd10:	add.w	r9, sp, #192	; 0xc0
    dd14:	b.n	d6bc <_svfprintf_r+0x52c>
    dd16:	add	r2, sp, #140	; 0x8c
    dd18:	ldr	r1, [sp, #20]
    dd1a:	ldr	r0, [sp, #24]
    dd1c:	bl	12134 <__ssprint_r>
    dd20:	cmp	r0, #0
    dd22:	beq.w	d758 <_svfprintf_r+0x5c8>
    dd26:	b.w	d384 <_svfprintf_r+0x1f4>
    dd2a:	add	r2, sp, #140	; 0x8c
    dd2c:	ldr	r1, [sp, #20]
    dd2e:	ldr	r0, [sp, #24]
    dd30:	bl	12134 <__ssprint_r>
    dd34:	cmp	r0, #0
    dd36:	bne.w	d384 <_svfprintf_r+0x1f4>
    dd3a:	ldr	r4, [sp, #148]	; 0x94
    dd3c:	add.w	r9, sp, #192	; 0xc0
    dd40:	b.n	d696 <_svfprintf_r+0x506>
    dd42:	add	r2, sp, #140	; 0x8c
    dd44:	ldr	r1, [sp, #20]
    dd46:	ldr	r0, [sp, #24]
    dd48:	bl	12134 <__ssprint_r>
    dd4c:	cmp	r0, #0
    dd4e:	bne.w	d384 <_svfprintf_r+0x1f4>
    dd52:	ldr	r4, [sp, #148]	; 0x94
    dd54:	add.w	r9, sp, #192	; 0xc0
    dd58:	b.n	d5fc <_svfprintf_r+0x46c>
    dd5a:	add	r2, sp, #140	; 0x8c
    dd5c:	ldr	r1, [sp, #20]
    dd5e:	ldr	r0, [sp, #24]
    dd60:	bl	12134 <__ssprint_r>
    dd64:	cmp	r0, #0
    dd66:	bne.w	d384 <_svfprintf_r+0x1f4>
    dd6a:	ldr	r4, [sp, #148]	; 0x94
    dd6c:	add.w	r9, sp, #192	; 0xc0
    dd70:	b.n	d61c <_svfprintf_r+0x48c>
    dd72:	cmp.w	fp, #0
    dd76:	strb.w	r7, [sp, #111]	; 0x6f
    dd7a:	blt.w	e33c <_svfprintf_r+0x11ac>
    dd7e:	bic.w	r3, r2, #128	; 0x80
    dd82:	str	r3, [sp, #12]
    dd84:	orrs.w	r3, r4, r5
    dd88:	bne.w	d932 <_svfprintf_r+0x7a2>
    dd8c:	cmp.w	fp, #0
    dd90:	beq.w	daac <_svfprintf_r+0x91c>
    dd94:	movs	r7, #0
    dd96:	b.n	db08 <_svfprintf_r+0x978>
    dd98:	ldr	r5, [sp, #116]	; 0x74
    dd9a:	cmp	r5, #0
    dd9c:	ble.w	e342 <_svfprintf_r+0x11b2>
    dda0:	ldr	r3, [sp, #60]	; 0x3c
    dda2:	ldr	r2, [sp, #56]	; 0x38
    dda4:	cmp	r3, r2
    dda6:	it	ge
    dda8:	movge	r3, r2
    ddaa:	cmp	r3, #0
    ddac:	mov	r5, r3
    ddae:	ble.n	ddcc <_svfprintf_r+0xc3c>
    ddb0:	ldr	r3, [sp, #144]	; 0x90
    ddb2:	str.w	r6, [r9]
    ddb6:	adds	r3, #1
    ddb8:	add	r4, r5
    ddba:	cmp	r3, #7
    ddbc:	str	r4, [sp, #148]	; 0x94
    ddbe:	str.w	r5, [r9, #4]
    ddc2:	str	r3, [sp, #144]	; 0x90
    ddc4:	bgt.w	e51a <_svfprintf_r+0x138a>
    ddc8:	add.w	r9, r9, #8
    ddcc:	ldr	r3, [sp, #60]	; 0x3c
    ddce:	cmp	r5, #0
    ddd0:	it	ge
    ddd2:	subge	r3, r3, r5
    ddd4:	cmp	r3, #0
    ddd6:	mov	r5, r3
    ddd8:	ble.w	dfcc <_svfprintf_r+0xe3c>
    dddc:	ldr	r2, [pc, #260]	; (dee4 <_svfprintf_r+0xd54>)
    ddde:	ldr	r3, [sp, #144]	; 0x90
    dde0:	str	r2, [sp, #44]	; 0x2c
    dde2:	cmp	r5, #16
    dde4:	ble.w	e2ee <_svfprintf_r+0x115e>
    dde8:	mov	r2, r4
    ddea:	movs	r7, #16
    ddec:	ldr.w	fp, [sp, #24]
    ddf0:	ldr	r4, [sp, #20]
    ddf2:	b.n	de00 <_svfprintf_r+0xc70>
    ddf4:	add.w	r9, r9, #8
    ddf8:	subs	r5, #16
    ddfa:	cmp	r5, #16
    ddfc:	ble.w	e2ec <_svfprintf_r+0x115c>
    de00:	adds	r3, #1
    de02:	adds	r2, #16
    de04:	cmp	r3, #7
    de06:	str	r2, [sp, #148]	; 0x94
    de08:	str	r3, [sp, #144]	; 0x90
    de0a:	str.w	sl, [r9]
    de0e:	str.w	r7, [r9, #4]
    de12:	ble.n	ddf4 <_svfprintf_r+0xc64>
    de14:	add	r2, sp, #140	; 0x8c
    de16:	mov	r1, r4
    de18:	mov	r0, fp
    de1a:	bl	12134 <__ssprint_r>
    de1e:	cmp	r0, #0
    de20:	bne.w	d384 <_svfprintf_r+0x1f4>
    de24:	ldr	r2, [sp, #148]	; 0x94
    de26:	ldr	r3, [sp, #144]	; 0x90
    de28:	add.w	r9, sp, #192	; 0xc0
    de2c:	b.n	ddf8 <_svfprintf_r+0xc68>
    de2e:	add	r2, sp, #140	; 0x8c
    de30:	ldr	r1, [sp, #20]
    de32:	ldr	r0, [sp, #24]
    de34:	bl	12134 <__ssprint_r>
    de38:	cmp	r0, #0
    de3a:	bne.w	d384 <_svfprintf_r+0x1f4>
    de3e:	ldrb.w	r7, [sp, #111]	; 0x6f
    de42:	ldr	r4, [sp, #148]	; 0x94
    de44:	add.w	r9, sp, #192	; 0xc0
    de48:	b.w	d5dc <_svfprintf_r+0x44c>
    de4c:	subs	r6, r3, #1
    de4e:	cmp	r6, #0
    de50:	ble.w	dce4 <_svfprintf_r+0xb54>
    de54:	ldr	r3, [pc, #140]	; (dee4 <_svfprintf_r+0xd54>)
    de56:	str	r3, [sp, #44]	; 0x2c
    de58:	cmp	r6, #16
    de5a:	ble.n	deb6 <_svfprintf_r+0xd26>
    de5c:	str.w	r8, [sp, #36]	; 0x24
    de60:	movs	r7, #16
    de62:	mov	r8, r6
    de64:	ldr.w	fp, [sp, #24]
    de68:	ldr	r6, [sp, #20]
    de6a:	b.n	de7a <_svfprintf_r+0xcea>
    de6c:	sub.w	r8, r8, #16
    de70:	cmp.w	r8, #16
    de74:	add.w	r9, r9, #8
    de78:	ble.n	deb0 <_svfprintf_r+0xd20>
    de7a:	adds	r5, #1
    de7c:	adds	r4, #16
    de7e:	cmp	r5, #7
    de80:	str	r4, [sp, #148]	; 0x94
    de82:	str	r5, [sp, #144]	; 0x90
    de84:	str.w	sl, [r9]
    de88:	str.w	r7, [r9, #4]
    de8c:	ble.n	de6c <_svfprintf_r+0xcdc>
    de8e:	add	r2, sp, #140	; 0x8c
    de90:	mov	r1, r6
    de92:	mov	r0, fp
    de94:	bl	12134 <__ssprint_r>
    de98:	cmp	r0, #0
    de9a:	bne.w	d384 <_svfprintf_r+0x1f4>
    de9e:	sub.w	r8, r8, #16
    dea2:	cmp.w	r8, #16
    dea6:	ldr	r4, [sp, #148]	; 0x94
    dea8:	ldr	r5, [sp, #144]	; 0x90
    deaa:	add.w	r9, sp, #192	; 0xc0
    deae:	bgt.n	de7a <_svfprintf_r+0xcea>
    deb0:	mov	r6, r8
    deb2:	ldr.w	r8, [sp, #36]	; 0x24
    deb6:	ldr	r3, [sp, #44]	; 0x2c
    deb8:	adds	r5, #1
    deba:	add	r4, r6
    debc:	cmp	r5, #7
    debe:	str	r4, [sp, #148]	; 0x94
    dec0:	str	r5, [sp, #144]	; 0x90
    dec2:	stmia.w	r9, {r3, r6}
    dec6:	ble.w	dce0 <_svfprintf_r+0xb50>
    deca:	add	r2, sp, #140	; 0x8c
    decc:	ldr	r1, [sp, #20]
    dece:	ldr	r0, [sp, #24]
    ded0:	bl	12134 <__ssprint_r>
    ded4:	cmp	r0, #0
    ded6:	bne.w	d384 <_svfprintf_r+0x1f4>
    deda:	ldr	r4, [sp, #148]	; 0x94
    dedc:	ldr	r5, [sp, #144]	; 0x90
    dede:	add.w	r9, sp, #192	; 0xc0
    dee2:	b.n	dce4 <_svfprintf_r+0xb54>
    dee4:	.word	0x00013180
    dee8:	ldr	r1, [sp, #12]
    deea:	ands.w	r2, r1, #16
    deee:	beq.w	e298 <_svfprintf_r+0x1108>
    def2:	ldr	r0, [sp, #40]	; 0x28
    def4:	strb.w	r3, [sp, #111]	; 0x6f
    def8:	cmp.w	fp, #0
    defc:	ldr	r4, [r0, #0]
    defe:	add.w	r7, r0, #4
    df02:	mov.w	r5, #0
    df06:	blt.n	df56 <_svfprintf_r+0xdc6>
    df08:	mov	r2, r1
    df0a:	bic.w	r2, r2, #128	; 0x80
    df0e:	str	r2, [sp, #12]
    df10:	orrs.w	r2, r4, r5
    df14:	str	r7, [sp, #40]	; 0x28
    df16:	mov	r7, r3
    df18:	bne.w	d4ec <_svfprintf_r+0x35c>
    df1c:	b.n	d8bc <_svfprintf_r+0x72c>
    df1e:	ldr	r3, [sp, #12]
    df20:	lsls	r0, r3, #27
    df22:	bmi.n	df7a <_svfprintf_r+0xdea>
    df24:	ldr	r3, [sp, #12]
    df26:	lsls	r1, r3, #25
    df28:	bpl.n	df7a <_svfprintf_r+0xdea>
    df2a:	ldr	r1, [sp, #40]	; 0x28
    df2c:	ldrsh.w	r4, [r1]
    df30:	adds	r1, #4
    df32:	asrs	r5, r4, #31
    df34:	mov	r2, r4
    df36:	mov	r3, r5
    df38:	str	r1, [sp, #40]	; 0x28
    df3a:	b.w	d4c6 <_svfprintf_r+0x336>
    df3e:	ldr	r1, [sp, #40]	; 0x28
    df40:	strb.w	r3, [sp, #111]	; 0x6f
    df44:	cmp.w	fp, #0
    df48:	ldr	r4, [r1, #0]
    df4a:	add.w	r7, r1, #4
    df4e:	mov.w	r5, #0
    df52:	bge.w	e3ee <_svfprintf_r+0x125e>
    df56:	str	r7, [sp, #40]	; 0x28
    df58:	mov	r7, r3
    df5a:	orrs.w	r3, r4, r5
    df5e:	bne.w	d4ec <_svfprintf_r+0x35c>
    df62:	b.n	d8c6 <_svfprintf_r+0x736>
    df64:	adds	r3, #1
    df66:	ldr	r2, [sp, #44]	; 0x2c
    df68:	str	r3, [sp, #144]	; 0x90
    df6a:	add	r4, r5
    df6c:	cmp	r3, #7
    df6e:	str	r4, [sp, #148]	; 0x94
    df70:	stmia.w	r9, {r2, r5}
    df74:	ble.w	d6b8 <_svfprintf_r+0x528>
    df78:	b.n	dcfe <_svfprintf_r+0xb6e>
    df7a:	ldr	r2, [sp, #40]	; 0x28
    df7c:	ldr	r4, [r2, #0]
    df7e:	mov	r3, r2
    df80:	adds	r3, #4
    df82:	asrs	r5, r4, #31
    df84:	mov	r2, r4
    df86:	str	r3, [sp, #40]	; 0x28
    df88:	cmp	r2, #0
    df8a:	mov	r3, r5
    df8c:	sbcs.w	r3, r3, #0
    df90:	bge.w	d4d0 <_svfprintf_r+0x340>
    df94:	negs	r4, r4
    df96:	mov.w	r7, #45	; 0x2d
    df9a:	sbc.w	r5, r5, r5, lsl #1
    df9e:	cmp.w	fp, #0
    dfa2:	strb.w	r7, [sp, #111]	; 0x6f
    dfa6:	blt.w	d4ec <_svfprintf_r+0x35c>
    dfaa:	ldr	r3, [sp, #12]
    dfac:	bic.w	r3, r3, #128	; 0x80
    dfb0:	str	r3, [sp, #12]
    dfb2:	b.w	d4ec <_svfprintf_r+0x35c>
    dfb6:	add	r2, sp, #140	; 0x8c
    dfb8:	ldr	r1, [sp, #20]
    dfba:	ldr	r0, [sp, #24]
    dfbc:	bl	12134 <__ssprint_r>
    dfc0:	cmp	r0, #0
    dfc2:	bne.w	d384 <_svfprintf_r+0x1f4>
    dfc6:	ldr	r4, [sp, #148]	; 0x94
    dfc8:	add.w	r9, sp, #192	; 0xc0
    dfcc:	ldr	r2, [sp, #60]	; 0x3c
    dfce:	ldr	r3, [sp, #116]	; 0x74
    dfd0:	add	r2, r6
    dfd2:	mov	r7, r2
    dfd4:	ldr	r2, [sp, #56]	; 0x38
    dfd6:	cmp	r3, r2
    dfd8:	blt.n	e06a <_svfprintf_r+0xeda>
    dfda:	ldr	r2, [sp, #12]
    dfdc:	lsls	r5, r2, #31
    dfde:	bmi.n	e06a <_svfprintf_r+0xeda>
    dfe0:	ldr	r1, [sp, #56]	; 0x38
    dfe2:	add	r6, r1
    dfe4:	subs	r5, r6, r7
    dfe6:	subs	r3, r1, r3
    dfe8:	cmp	r5, r3
    dfea:	it	ge
    dfec:	movge	r5, r3
    dfee:	cmp	r5, #0
    dff0:	mov	r6, r5
    dff2:	ble.n	e010 <_svfprintf_r+0xe80>
    dff4:	ldr	r2, [sp, #144]	; 0x90
    dff6:	str.w	r7, [r9]
    dffa:	adds	r2, #1
    dffc:	add	r4, r5
    dffe:	cmp	r2, #7
    e000:	str	r4, [sp, #148]	; 0x94
    e002:	str.w	r5, [r9, #4]
    e006:	str	r2, [sp, #144]	; 0x90
    e008:	bgt.w	e608 <_svfprintf_r+0x1478>
    e00c:	add.w	r9, r9, #8
    e010:	cmp	r6, #0
    e012:	ite	ge
    e014:	subge	r5, r3, r6
    e016:	movlt	r5, r3
    e018:	cmp	r5, #0
    e01a:	ble.w	d6bc <_svfprintf_r+0x52c>
    e01e:	ldr	r2, [pc, #744]	; (e308 <_svfprintf_r+0x1178>)
    e020:	ldr	r3, [sp, #144]	; 0x90
    e022:	str	r2, [sp, #44]	; 0x2c
    e024:	cmp	r5, #16
    e026:	ble.n	df64 <_svfprintf_r+0xdd4>
    e028:	movs	r6, #16
    e02a:	ldr	r7, [sp, #24]
    e02c:	ldr.w	fp, [sp, #20]
    e030:	b.n	e03c <_svfprintf_r+0xeac>
    e032:	add.w	r9, r9, #8
    e036:	subs	r5, #16
    e038:	cmp	r5, #16
    e03a:	ble.n	df64 <_svfprintf_r+0xdd4>
    e03c:	adds	r3, #1
    e03e:	adds	r4, #16
    e040:	cmp	r3, #7
    e042:	str	r4, [sp, #148]	; 0x94
    e044:	str	r3, [sp, #144]	; 0x90
    e046:	str.w	sl, [r9]
    e04a:	str.w	r6, [r9, #4]
    e04e:	ble.n	e032 <_svfprintf_r+0xea2>
    e050:	add	r2, sp, #140	; 0x8c
    e052:	mov	r1, fp
    e054:	mov	r0, r7
    e056:	bl	12134 <__ssprint_r>
    e05a:	cmp	r0, #0
    e05c:	bne.w	d384 <_svfprintf_r+0x1f4>
    e060:	ldr	r4, [sp, #148]	; 0x94
    e062:	ldr	r3, [sp, #144]	; 0x90
    e064:	add.w	r9, sp, #192	; 0xc0
    e068:	b.n	e036 <_svfprintf_r+0xea6>
    e06a:	ldr	r2, [sp, #144]	; 0x90
    e06c:	ldr	r0, [sp, #72]	; 0x48
    e06e:	ldr	r1, [sp, #76]	; 0x4c
    e070:	str.w	r1, [r9]
    e074:	adds	r2, #1
    e076:	add	r4, r0
    e078:	cmp	r2, #7
    e07a:	str	r4, [sp, #148]	; 0x94
    e07c:	str.w	r0, [r9, #4]
    e080:	str	r2, [sp, #144]	; 0x90
    e082:	bgt.w	e5ee <_svfprintf_r+0x145e>
    e086:	add.w	r9, r9, #8
    e08a:	b.n	dfe0 <_svfprintf_r+0xe50>
    e08c:	ldr	r3, [sp, #12]
    e08e:	lsls	r0, r3, #31
    e090:	bmi.w	dc78 <_svfprintf_r+0xae8>
    e094:	adds	r5, #1
    e096:	adds	r4, #1
    e098:	movs	r3, #1
    e09a:	cmp	r5, #7
    e09c:	str	r4, [sp, #148]	; 0x94
    e09e:	str	r5, [sp, #144]	; 0x90
    e0a0:	str.w	r6, [r9]
    e0a4:	str.w	r3, [r9, #4]
    e0a8:	ble.w	dce0 <_svfprintf_r+0xb50>
    e0ac:	b.n	deca <_svfprintf_r+0xd3a>
    e0ae:	add	r2, sp, #140	; 0x8c
    e0b0:	ldr	r1, [sp, #20]
    e0b2:	ldr	r0, [sp, #24]
    e0b4:	bl	12134 <__ssprint_r>
    e0b8:	cmp	r0, #0
    e0ba:	bne.w	d384 <_svfprintf_r+0x1f4>
    e0be:	ldr	r4, [sp, #148]	; 0x94
    e0c0:	ldr	r5, [sp, #144]	; 0x90
    e0c2:	add.w	r9, sp, #192	; 0xc0
    e0c6:	b.n	dc94 <_svfprintf_r+0xb04>
    e0c8:	add	r2, sp, #140	; 0x8c
    e0ca:	ldr	r1, [sp, #20]
    e0cc:	ldr	r0, [sp, #24]
    e0ce:	bl	12134 <__ssprint_r>
    e0d2:	cmp	r0, #0
    e0d4:	bne.w	d384 <_svfprintf_r+0x1f4>
    e0d8:	ldr	r4, [sp, #148]	; 0x94
    e0da:	ldr	r5, [sp, #144]	; 0x90
    e0dc:	add.w	r9, sp, #192	; 0xc0
    e0e0:	b.n	dcb2 <_svfprintf_r+0xb22>
    e0e2:	add	r2, sp, #140	; 0x8c
    e0e4:	ldr	r1, [sp, #20]
    e0e6:	ldr	r0, [sp, #24]
    e0e8:	bl	12134 <__ssprint_r>
    e0ec:	cmp	r0, #0
    e0ee:	bne.w	d384 <_svfprintf_r+0x1f4>
    e0f2:	ldr	r4, [sp, #148]	; 0x94
    e0f4:	add.w	r9, sp, #192	; 0xc0
    e0f8:	b.w	d624 <_svfprintf_r+0x494>
    e0fc:	ldr	r1, [sp, #12]
    e0fe:	ands.w	r3, r1, #64	; 0x40
    e102:	beq.w	e278 <_svfprintf_r+0x10e8>
    e106:	ldr	r0, [sp, #40]	; 0x28
    e108:	strb.w	r2, [sp, #111]	; 0x6f
    e10c:	mov	r3, r0
    e10e:	cmp.w	fp, #0
    e112:	add.w	r3, r3, #4
    e116:	ldrh	r4, [r0, #0]
    e118:	mov.w	r5, #0
    e11c:	blt.w	e4a0 <_svfprintf_r+0x1310>
    e120:	bic.w	r1, r1, #128	; 0x80
    e124:	str	r1, [sp, #12]
    e126:	orrs.w	r1, r4, r5
    e12a:	str	r3, [sp, #40]	; 0x28
    e12c:	beq.w	dae4 <_svfprintf_r+0x954>
    e130:	mov	r7, r2
    e132:	b.w	d3dc <_svfprintf_r+0x24c>
    e136:	ldr	r3, [sp, #12]
    e138:	lsls	r7, r3, #27
    e13a:	bmi.n	e154 <_svfprintf_r+0xfc4>
    e13c:	ldr	r3, [sp, #12]
    e13e:	lsls	r6, r3, #25
    e140:	bpl.n	e154 <_svfprintf_r+0xfc4>
    e142:	ldr	r2, [sp, #40]	; 0x28
    e144:	ldr	r3, [r2, #0]
    e146:	adds	r2, #4
    e148:	str	r2, [sp, #40]	; 0x28
    e14a:	ldrh.w	r2, [sp, #28]
    e14e:	strh	r2, [r3, #0]
    e150:	b.w	d1de <_svfprintf_r+0x4e>
    e154:	ldr	r2, [sp, #40]	; 0x28
    e156:	ldr	r3, [r2, #0]
    e158:	adds	r2, #4
    e15a:	str	r2, [sp, #40]	; 0x28
    e15c:	ldr	r2, [sp, #28]
    e15e:	str	r2, [r3, #0]
    e160:	b.w	d1de <_svfprintf_r+0x4e>
    e164:	ldrd	r0, r1, [sp, #64]	; 0x40
    e168:	mov	r2, r0
    e16a:	mov	r3, r1
    e16c:	bl	ae14 <__aeabi_dcmpun>
    e170:	cmp	r0, #0
    e172:	bne.w	e770 <_svfprintf_r+0x15e0>
    e176:	ldr	r3, [sp, #52]	; 0x34
    e178:	cmp.w	fp, #4294967295
    e17c:	bic.w	r7, r3, #32
    e180:	beq.w	e652 <_svfprintf_r+0x14c2>
    e184:	cmp	r7, #71	; 0x47
    e186:	beq.w	e48e <_svfprintf_r+0x12fe>
    e18a:	ldr	r3, [sp, #68]	; 0x44
    e18c:	ldr	r2, [sp, #12]
    e18e:	cmp	r3, #0
    e190:	orr.w	r2, r2, #256	; 0x100
    e194:	str	r2, [sp, #44]	; 0x2c
    e196:	blt.w	e68a <_svfprintf_r+0x14fa>
    e19a:	vldr	d7, [sp, #64]	; 0x40
    e19e:	vstr	d7, [sp, #96]	; 0x60
    e1a2:	movs	r3, #0
    e1a4:	str	r3, [sp, #16]
    e1a6:	ldr	r3, [sp, #52]	; 0x34
    e1a8:	cmp	r3, #102	; 0x66
    e1aa:	beq.w	e658 <_svfprintf_r+0x14c8>
    e1ae:	cmp	r3, #70	; 0x46
    e1b0:	beq.w	e43e <_svfprintf_r+0x12ae>
    e1b4:	cmp	r7, #69	; 0x45
    e1b6:	ite	eq
    e1b8:	addeq.w	r5, fp, #1
    e1bc:	movne	r5, fp
    e1be:	add	r2, sp, #132	; 0x84
    e1c0:	add	r3, sp, #120	; 0x78
    e1c2:	str	r2, [sp, #4]
    e1c4:	str	r3, [sp, #0]
    e1c6:	mov	r2, r5
    e1c8:	add	r3, sp, #116	; 0x74
    e1ca:	movs	r1, #2
    e1cc:	vldr	d0, [sp, #96]	; 0x60
    e1d0:	ldr	r0, [sp, #24]
    e1d2:	bl	f998 <_dtoa_r>
    e1d6:	ldr	r3, [sp, #52]	; 0x34
    e1d8:	cmp	r3, #103	; 0x67
    e1da:	mov	r6, r0
    e1dc:	bne.w	e6b6 <_svfprintf_r+0x1526>
    e1e0:	ldr	r3, [sp, #12]
    e1e2:	lsls	r2, r3, #31
    e1e4:	bpl.w	e75a <_svfprintf_r+0x15ca>
    e1e8:	adds	r4, r6, r5
    e1ea:	movs	r2, #0
    e1ec:	movs	r3, #0
    e1ee:	ldrd	r0, r1, [sp, #96]	; 0x60
    e1f2:	bl	adb0 <__aeabi_dcmpeq>
    e1f6:	cmp	r0, #0
    e1f8:	bne.w	e516 <_svfprintf_r+0x1386>
    e1fc:	ldr	r3, [sp, #132]	; 0x84
    e1fe:	cmp	r4, r3
    e200:	bls.n	e210 <_svfprintf_r+0x1080>
    e202:	movs	r1, #48	; 0x30
    e204:	adds	r2, r3, #1
    e206:	str	r2, [sp, #132]	; 0x84
    e208:	strb	r1, [r3, #0]
    e20a:	ldr	r3, [sp, #132]	; 0x84
    e20c:	cmp	r4, r3
    e20e:	bhi.n	e204 <_svfprintf_r+0x1074>
    e210:	subs	r3, r3, r6
    e212:	cmp	r7, #71	; 0x47
    e214:	str	r3, [sp, #56]	; 0x38
    e216:	beq.w	e508 <_svfprintf_r+0x1378>
    e21a:	ldr	r3, [sp, #52]	; 0x34
    e21c:	cmp	r3, #101	; 0x65
    e21e:	ble.w	e6d4 <_svfprintf_r+0x1544>
    e222:	ldr	r3, [sp, #52]	; 0x34
    e224:	cmp	r3, #102	; 0x66
    e226:	ldr	r3, [sp, #116]	; 0x74
    e228:	str	r3, [sp, #60]	; 0x3c
    e22a:	beq.w	e6ee <_svfprintf_r+0x155e>
    e22e:	ldr	r2, [sp, #60]	; 0x3c
    e230:	ldr	r1, [sp, #56]	; 0x38
    e232:	cmp	r2, r1
    e234:	blt.w	e69c <_svfprintf_r+0x150c>
    e238:	ldr	r3, [sp, #12]
    e23a:	lsls	r1, r3, #31
    e23c:	bmi.w	e75e <_svfprintf_r+0x15ce>
    e240:	bic.w	r3, r2, r2, asr #31
    e244:	str	r2, [sp, #36]	; 0x24
    e246:	movs	r2, #103	; 0x67
    e248:	str	r2, [sp, #52]	; 0x34
    e24a:	ldr	r2, [sp, #16]
    e24c:	cmp	r2, #0
    e24e:	bne.w	e4b0 <_svfprintf_r+0x1320>
    e252:	str	r3, [sp, #16]
    e254:	ldr	r3, [sp, #44]	; 0x2c
    e256:	str	r3, [sp, #12]
    e258:	mov	fp, r2
    e25a:	ldrb.w	r7, [sp, #111]	; 0x6f
    e25e:	b.w	d534 <_svfprintf_r+0x3a4>
    e262:	bic.w	r7, r7, #7
    e266:	vldr	d7, [r7]
    e26a:	add.w	r3, r7, #8
    e26e:	vstr	d7, [sp, #64]	; 0x40
    e272:	str	r3, [sp, #40]	; 0x28
    e274:	b.w	d78c <_svfprintf_r+0x5fc>
    e278:	ldr	r1, [sp, #40]	; 0x28
    e27a:	strb.w	r3, [sp, #111]	; 0x6f
    e27e:	cmp.w	fp, #0
    e282:	ldr	r4, [r1, #0]
    e284:	add.w	r7, r1, #4
    e288:	mov.w	r5, #0
    e28c:	bge.w	e3e8 <_svfprintf_r+0x1258>
    e290:	str	r7, [sp, #40]	; 0x28
    e292:	movs	r7, #0
    e294:	b.w	d3dc <_svfprintf_r+0x24c>
    e298:	ldr	r1, [sp, #12]
    e29a:	ands.w	r3, r1, #64	; 0x40
    e29e:	beq.w	df3e <_svfprintf_r+0xdae>
    e2a2:	ldr	r0, [sp, #40]	; 0x28
    e2a4:	strb.w	r2, [sp, #111]	; 0x6f
    e2a8:	mov	r3, r0
    e2aa:	cmp.w	fp, #0
    e2ae:	add.w	r3, r3, #4
    e2b2:	ldrh	r4, [r0, #0]
    e2b4:	mov.w	r5, #0
    e2b8:	blt.w	e49a <_svfprintf_r+0x130a>
    e2bc:	bic.w	r1, r1, #128	; 0x80
    e2c0:	str	r1, [sp, #12]
    e2c2:	orrs.w	r1, r4, r5
    e2c6:	str	r3, [sp, #40]	; 0x28
    e2c8:	mov	r7, r2
    e2ca:	bne.w	d4ec <_svfprintf_r+0x35c>
    e2ce:	b.w	d8bc <_svfprintf_r+0x72c>
    e2d2:	ldr	r3, [sp, #12]
    e2d4:	ldr	r2, [sp, #40]	; 0x28
    e2d6:	tst.w	r3, #64	; 0x40
    e2da:	mov	r3, r2
    e2dc:	beq.w	e4a4 <_svfprintf_r+0x1314>
    e2e0:	adds	r3, #4
    e2e2:	ldrh	r4, [r2, #0]
    e2e4:	str	r3, [sp, #40]	; 0x28
    e2e6:	movs	r5, #0
    e2e8:	b.w	d8f6 <_svfprintf_r+0x766>
    e2ec:	mov	r4, r2
    e2ee:	adds	r3, #1
    e2f0:	ldr	r2, [sp, #44]	; 0x2c
    e2f2:	str	r3, [sp, #144]	; 0x90
    e2f4:	add	r4, r5
    e2f6:	cmp	r3, #7
    e2f8:	str	r4, [sp, #148]	; 0x94
    e2fa:	stmia.w	r9, {r2, r5}
    e2fe:	bgt.w	dfb6 <_svfprintf_r+0xe26>
    e302:	add.w	r9, r9, #8
    e306:	b.n	dfcc <_svfprintf_r+0xe3c>
    e308:	.word	0x00013180
    e30c:	movs	r7, #0
    e30e:	cmp	fp, r7
    e310:	strb.w	r7, [sp, #111]	; 0x6f
    e314:	blt.w	db08 <_svfprintf_r+0x978>
    e318:	ldr	r3, [sp, #12]
    e31a:	bic.w	r3, r3, #128	; 0x80
    e31e:	str	r3, [sp, #12]
    e320:	b.w	daa4 <_svfprintf_r+0x914>
    e324:	add	r2, sp, #140	; 0x8c
    e326:	ldr	r1, [sp, #20]
    e328:	ldr	r0, [sp, #24]
    e32a:	bl	12134 <__ssprint_r>
    e32e:	cmp	r0, #0
    e330:	bne.w	d384 <_svfprintf_r+0x1f4>
    e334:	ldr	r4, [sp, #148]	; 0x94
    e336:	add.w	r9, sp, #192	; 0xc0
    e33a:	b.n	db4c <_svfprintf_r+0x9bc>
    e33c:	ldr	r7, [sp, #40]	; 0x28
    e33e:	b.w	dafa <_svfprintf_r+0x96a>
    e342:	ldr	r3, [sp, #144]	; 0x90
    e344:	ldr	r2, [pc, #736]	; (e628 <_svfprintf_r+0x1498>)
    e346:	str.w	r2, [r9]
    e34a:	adds	r3, #1
    e34c:	adds	r4, #1
    e34e:	movs	r2, #1
    e350:	cmp	r3, #7
    e352:	str	r4, [sp, #148]	; 0x94
    e354:	str	r3, [sp, #144]	; 0x90
    e356:	str.w	r2, [r9, #4]
    e35a:	bgt.w	e474 <_svfprintf_r+0x12e4>
    e35e:	add.w	r9, r9, #8
    e362:	cbnz	r5, e370 <_svfprintf_r+0x11e0>
    e364:	ldr	r3, [sp, #56]	; 0x38
    e366:	cbnz	r3, e370 <_svfprintf_r+0x11e0>
    e368:	ldr	r3, [sp, #12]
    e36a:	lsls	r7, r3, #31
    e36c:	bpl.w	d6bc <_svfprintf_r+0x52c>
    e370:	ldr	r3, [sp, #144]	; 0x90
    e372:	ldr	r1, [sp, #72]	; 0x48
    e374:	ldr	r2, [sp, #76]	; 0x4c
    e376:	str.w	r2, [r9]
    e37a:	adds	r3, #1
    e37c:	add	r4, r1
    e37e:	cmp	r3, #7
    e380:	str	r4, [sp, #148]	; 0x94
    e382:	str.w	r1, [r9, #4]
    e386:	str	r3, [sp, #144]	; 0x90
    e388:	bgt.w	e726 <_svfprintf_r+0x1596>
    e38c:	add.w	r9, r9, #8
    e390:	negs	r5, r5
    e392:	cmp	r5, #0
    e394:	ble.w	e4ec <_svfprintf_r+0x135c>
    e398:	ldr	r2, [pc, #656]	; (e62c <_svfprintf_r+0x149c>)
    e39a:	str	r2, [sp, #44]	; 0x2c
    e39c:	cmp	r5, #16
    e39e:	ble.w	e534 <_svfprintf_r+0x13a4>
    e3a2:	mov	r2, r4
    e3a4:	movs	r7, #16
    e3a6:	ldr.w	fp, [sp, #24]
    e3aa:	ldr	r4, [sp, #20]
    e3ac:	b.n	e3ba <_svfprintf_r+0x122a>
    e3ae:	add.w	r9, r9, #8
    e3b2:	subs	r5, #16
    e3b4:	cmp	r5, #16
    e3b6:	ble.w	e532 <_svfprintf_r+0x13a2>
    e3ba:	adds	r3, #1
    e3bc:	adds	r2, #16
    e3be:	cmp	r3, #7
    e3c0:	str	r2, [sp, #148]	; 0x94
    e3c2:	str	r3, [sp, #144]	; 0x90
    e3c4:	str.w	sl, [r9]
    e3c8:	str.w	r7, [r9, #4]
    e3cc:	ble.n	e3ae <_svfprintf_r+0x121e>
    e3ce:	add	r2, sp, #140	; 0x8c
    e3d0:	mov	r1, r4
    e3d2:	mov	r0, fp
    e3d4:	bl	12134 <__ssprint_r>
    e3d8:	cmp	r0, #0
    e3da:	bne.w	d384 <_svfprintf_r+0x1f4>
    e3de:	ldr	r2, [sp, #148]	; 0x94
    e3e0:	ldr	r3, [sp, #144]	; 0x90
    e3e2:	add.w	r9, sp, #192	; 0xc0
    e3e6:	b.n	e3b2 <_svfprintf_r+0x1222>
    e3e8:	ldr	r2, [sp, #12]
    e3ea:	b.w	d860 <_svfprintf_r+0x6d0>
    e3ee:	ldr	r2, [sp, #12]
    e3f0:	b.n	df0a <_svfprintf_r+0xd7a>
    e3f2:	ldr	r3, [sp, #12]
    e3f4:	orr.w	r3, r3, #32
    e3f8:	str	r3, [sp, #12]
    e3fa:	add.w	r8, r8, #1
    e3fe:	ldrb.w	r3, [r8]
    e402:	b.w	d244 <_svfprintf_r+0xb4>
    e406:	add	r2, sp, #140	; 0x8c
    e408:	ldr	r1, [sp, #20]
    e40a:	ldr	r0, [sp, #24]
    e40c:	bl	12134 <__ssprint_r>
    e410:	cmp	r0, #0
    e412:	bne.w	d384 <_svfprintf_r+0x1f4>
    e416:	ldr	r4, [sp, #148]	; 0x94
    e418:	add.w	r9, sp, #192	; 0xc0
    e41c:	b.w	db7c <_svfprintf_r+0x9ec>
    e420:	movs	r1, #64	; 0x40
    e422:	ldr	r0, [sp, #24]
    e424:	bl	b360 <_malloc_r>
    e428:	ldr	r2, [sp, #20]
    e42a:	str	r0, [r2, #0]
    e42c:	str	r0, [r2, #16]
    e42e:	cmp	r0, #0
    e430:	beq.w	e81a <_svfprintf_r+0x168a>
    e434:	ldr	r2, [sp, #20]
    e436:	movs	r3, #64	; 0x40
    e438:	str	r3, [r2, #20]
    e43a:	b.w	d1be <_svfprintf_r+0x2e>
    e43e:	add	r2, sp, #132	; 0x84
    e440:	add	r3, sp, #120	; 0x78
    e442:	str	r2, [sp, #4]
    e444:	str	r3, [sp, #0]
    e446:	mov	r2, fp
    e448:	add	r3, sp, #116	; 0x74
    e44a:	movs	r1, #3
    e44c:	vldr	d0, [sp, #96]	; 0x60
    e450:	ldr	r0, [sp, #24]
    e452:	bl	f998 <_dtoa_r>
    e456:	mov	r5, fp
    e458:	mov	r6, r0
    e45a:	ldr	r3, [sp, #52]	; 0x34
    e45c:	cmp	r3, #70	; 0x46
    e45e:	add.w	r4, r6, r5
    e462:	bne.w	e1ea <_svfprintf_r+0x105a>
    e466:	ldrb	r3, [r6, #0]
    e468:	cmp	r3, #48	; 0x30
    e46a:	beq.w	e77c <_svfprintf_r+0x15ec>
    e46e:	ldr	r5, [sp, #116]	; 0x74
    e470:	add	r4, r5
    e472:	b.n	e1ea <_svfprintf_r+0x105a>
    e474:	add	r2, sp, #140	; 0x8c
    e476:	ldr	r1, [sp, #20]
    e478:	ldr	r0, [sp, #24]
    e47a:	bl	12134 <__ssprint_r>
    e47e:	cmp	r0, #0
    e480:	bne.w	d384 <_svfprintf_r+0x1f4>
    e484:	ldr	r5, [sp, #116]	; 0x74
    e486:	ldr	r4, [sp, #148]	; 0x94
    e488:	add.w	r9, sp, #192	; 0xc0
    e48c:	b.n	e362 <_svfprintf_r+0x11d2>
    e48e:	cmp.w	fp, #0
    e492:	it	eq
    e494:	moveq.w	fp, #1
    e498:	b.n	e18a <_svfprintf_r+0xffa>
    e49a:	str	r3, [sp, #40]	; 0x28
    e49c:	mov	r7, r2
    e49e:	b.n	df5a <_svfprintf_r+0xdca>
    e4a0:	str	r3, [sp, #40]	; 0x28
    e4a2:	b.n	e292 <_svfprintf_r+0x1102>
    e4a4:	adds	r3, #4
    e4a6:	ldr	r4, [r2, #0]
    e4a8:	str	r3, [sp, #40]	; 0x28
    e4aa:	movs	r5, #0
    e4ac:	b.w	d8f6 <_svfprintf_r+0x766>
    e4b0:	movs	r7, #45	; 0x2d
    e4b2:	str	r3, [sp, #16]
    e4b4:	ldr	r3, [sp, #44]	; 0x2c
    e4b6:	str	r3, [sp, #12]
    e4b8:	strb.w	r7, [sp, #111]	; 0x6f
    e4bc:	mov.w	fp, #0
    e4c0:	b.w	d536 <_svfprintf_r+0x3a6>
    e4c4:	mov	r0, r6
    e4c6:	bl	bf80 <strlen>
    e4ca:	mov	fp, r4
    e4cc:	mov	r3, r0
    e4ce:	str	r0, [sp, #36]	; 0x24
    e4d0:	b.w	da18 <_svfprintf_r+0x888>
    e4d4:	add	r2, sp, #140	; 0x8c
    e4d6:	ldr	r1, [sp, #20]
    e4d8:	ldr	r0, [sp, #24]
    e4da:	bl	12134 <__ssprint_r>
    e4de:	cmp	r0, #0
    e4e0:	bne.w	d384 <_svfprintf_r+0x1f4>
    e4e4:	ldr	r4, [sp, #148]	; 0x94
    e4e6:	ldr	r3, [sp, #144]	; 0x90
    e4e8:	add.w	r9, sp, #192	; 0xc0
    e4ec:	ldr	r1, [sp, #56]	; 0x38
    e4ee:	str.w	r6, [r9]
    e4f2:	adds	r3, #1
    e4f4:	add	r4, r1
    e4f6:	cmp	r3, #7
    e4f8:	str	r4, [sp, #148]	; 0x94
    e4fa:	str	r3, [sp, #144]	; 0x90
    e4fc:	str.w	r1, [r9, #4]
    e500:	ble.w	d6b8 <_svfprintf_r+0x528>
    e504:	b.w	dcfe <_svfprintf_r+0xb6e>
    e508:	ldr	r3, [sp, #116]	; 0x74
    e50a:	adds	r5, r3, #3
    e50c:	blt.n	e54c <_svfprintf_r+0x13bc>
    e50e:	cmp	fp, r3
    e510:	blt.n	e54c <_svfprintf_r+0x13bc>
    e512:	str	r3, [sp, #60]	; 0x3c
    e514:	b.n	e22e <_svfprintf_r+0x109e>
    e516:	mov	r3, r4
    e518:	b.n	e210 <_svfprintf_r+0x1080>
    e51a:	add	r2, sp, #140	; 0x8c
    e51c:	ldr	r1, [sp, #20]
    e51e:	ldr	r0, [sp, #24]
    e520:	bl	12134 <__ssprint_r>
    e524:	cmp	r0, #0
    e526:	bne.w	d384 <_svfprintf_r+0x1f4>
    e52a:	ldr	r4, [sp, #148]	; 0x94
    e52c:	add.w	r9, sp, #192	; 0xc0
    e530:	b.n	ddcc <_svfprintf_r+0xc3c>
    e532:	mov	r4, r2
    e534:	adds	r3, #1
    e536:	ldr	r2, [sp, #44]	; 0x2c
    e538:	str	r3, [sp, #144]	; 0x90
    e53a:	add	r4, r5
    e53c:	cmp	r3, #7
    e53e:	str	r4, [sp, #148]	; 0x94
    e540:	stmia.w	r9, {r2, r5}
    e544:	bgt.n	e4d4 <_svfprintf_r+0x1344>
    e546:	add.w	r9, r9, #8
    e54a:	b.n	e4ec <_svfprintf_r+0x135c>
    e54c:	ldr	r2, [sp, #52]	; 0x34
    e54e:	subs	r2, #2
    e550:	str	r2, [sp, #52]	; 0x34
    e552:	subs	r3, #1
    e554:	cmp	r3, #0
    e556:	ldrb.w	r2, [sp, #52]	; 0x34
    e55a:	str	r3, [sp, #116]	; 0x74
    e55c:	it	lt
    e55e:	neglt	r3, r3
    e560:	strb.w	r2, [sp, #124]	; 0x7c
    e564:	ite	lt
    e566:	movlt	r2, #45	; 0x2d
    e568:	movge	r2, #43	; 0x2b
    e56a:	cmp	r3, #9
    e56c:	strb.w	r2, [sp, #125]	; 0x7d
    e570:	ble.w	e74a <_svfprintf_r+0x15ba>
    e574:	add.w	r0, sp, #139	; 0x8b
    e578:	mov	r4, r0
    e57a:	ldr	r2, [pc, #180]	; (e630 <_svfprintf_r+0x14a0>)
    e57c:	smull	r2, r1, r2, r3
    e580:	asrs	r2, r3, #31
    e582:	rsb	r2, r2, r1, asr #2
    e586:	add.w	r1, r2, r2, lsl #2
    e58a:	sub.w	r3, r3, r1, lsl #1
    e58e:	add.w	r1, r3, #48	; 0x30
    e592:	cmp	r2, #9
    e594:	mov	r3, r2
    e596:	strb.w	r1, [r4, #-1]!
    e59a:	bgt.n	e57a <_svfprintf_r+0x13ea>
    e59c:	mov	r1, r4
    e59e:	adds	r3, #48	; 0x30
    e5a0:	uxtb	r2, r3
    e5a2:	strb.w	r2, [r1, #-1]!
    e5a6:	cmp	r0, r1
    e5a8:	bls.w	e814 <_svfprintf_r+0x1684>
    e5ac:	add.w	r1, sp, #126	; 0x7e
    e5b0:	mov	r3, r4
    e5b2:	b.n	e5b8 <_svfprintf_r+0x1428>
    e5b4:	ldrb.w	r2, [r3], #1
    e5b8:	strb.w	r2, [r1], #1
    e5bc:	cmp	r0, r3
    e5be:	bne.n	e5b4 <_svfprintf_r+0x1424>
    e5c0:	adds	r3, r0, #1
    e5c2:	subs	r3, r3, r4
    e5c4:	add.w	r2, sp, #126	; 0x7e
    e5c8:	add	r3, r2
    e5ca:	add	r2, sp, #124	; 0x7c
    e5cc:	subs	r3, r3, r2
    e5ce:	ldr	r2, [sp, #56]	; 0x38
    e5d0:	str	r3, [sp, #84]	; 0x54
    e5d2:	cmp	r2, #1
    e5d4:	add	r3, r2
    e5d6:	str	r3, [sp, #36]	; 0x24
    e5d8:	ble.w	e7aa <_svfprintf_r+0x161a>
    e5dc:	ldr	r3, [sp, #36]	; 0x24
    e5de:	ldr	r2, [sp, #72]	; 0x48
    e5e0:	add	r3, r2
    e5e2:	movs	r2, #0
    e5e4:	str	r3, [sp, #36]	; 0x24
    e5e6:	str	r2, [sp, #60]	; 0x3c
    e5e8:	bic.w	r3, r3, r3, asr #31
    e5ec:	b.n	e24a <_svfprintf_r+0x10ba>
    e5ee:	add	r2, sp, #140	; 0x8c
    e5f0:	ldr	r1, [sp, #20]
    e5f2:	ldr	r0, [sp, #24]
    e5f4:	bl	12134 <__ssprint_r>
    e5f8:	cmp	r0, #0
    e5fa:	bne.w	d384 <_svfprintf_r+0x1f4>
    e5fe:	ldr	r3, [sp, #116]	; 0x74
    e600:	ldr	r4, [sp, #148]	; 0x94
    e602:	add.w	r9, sp, #192	; 0xc0
    e606:	b.n	dfe0 <_svfprintf_r+0xe50>
    e608:	add	r2, sp, #140	; 0x8c
    e60a:	ldr	r1, [sp, #20]
    e60c:	ldr	r0, [sp, #24]
    e60e:	bl	12134 <__ssprint_r>
    e612:	cmp	r0, #0
    e614:	bne.w	d384 <_svfprintf_r+0x1f4>
    e618:	ldr	r3, [sp, #116]	; 0x74
    e61a:	ldr	r2, [sp, #56]	; 0x38
    e61c:	ldr	r4, [sp, #148]	; 0x94
    e61e:	subs	r3, r2, r3
    e620:	add.w	r9, sp, #192	; 0xc0
    e624:	b.n	e010 <_svfprintf_r+0xe80>
    e626:	nop
    e628:	.word	0x000131d0
    e62c:	.word	0x00013180
    e630:	.word	0x66666667
    e634:	cmp	r5, #6
    e636:	mov	r3, r5
    e638:	it	cs
    e63a:	movcs	r3, #6
    e63c:	str	r3, [sp, #36]	; 0x24
    e63e:	bic.w	r3, r3, r3, asr #31
    e642:	mov	fp, r6
    e644:	str	r7, [sp, #40]	; 0x28
    e646:	str	r6, [sp, #60]	; 0x3c
    e648:	mov	r7, r6
    e64a:	str	r3, [sp, #16]
    e64c:	ldr	r6, [pc, #536]	; (e868 <_svfprintf_r+0x16d8>)
    e64e:	b.w	d534 <_svfprintf_r+0x3a4>
    e652:	mov.w	fp, #6
    e656:	b.n	e18a <_svfprintf_r+0xffa>
    e658:	add	r2, sp, #132	; 0x84
    e65a:	add	r3, sp, #120	; 0x78
    e65c:	str	r2, [sp, #4]
    e65e:	str	r3, [sp, #0]
    e660:	mov	r2, fp
    e662:	add	r3, sp, #116	; 0x74
    e664:	movs	r1, #3
    e666:	vldr	d0, [sp, #96]	; 0x60
    e66a:	ldr	r0, [sp, #24]
    e66c:	bl	f998 <_dtoa_r>
    e670:	mov	r5, fp
    e672:	mov	r6, r0
    e674:	add.w	r4, r0, fp
    e678:	b.n	e466 <_svfprintf_r+0x12d6>
    e67a:	movs	r7, #45	; 0x2d
    e67c:	strb.w	r7, [sp, #111]	; 0x6f
    e680:	b.w	d7da <_svfprintf_r+0x64a>
    e684:	str	r3, [sp, #12]
    e686:	b.w	d932 <_svfprintf_r+0x7a2>
    e68a:	ldrd	r1, r2, [sp, #64]	; 0x40
    e68e:	add.w	r3, r2, #2147483648	; 0x80000000
    e692:	str	r3, [sp, #100]	; 0x64
    e694:	movs	r3, #45	; 0x2d
    e696:	str	r1, [sp, #96]	; 0x60
    e698:	str	r3, [sp, #16]
    e69a:	b.n	e1a6 <_svfprintf_r+0x1016>
    e69c:	ldr	r2, [sp, #72]	; 0x48
    e69e:	ldr	r3, [sp, #56]	; 0x38
    e6a0:	add	r3, r2
    e6a2:	ldr	r2, [sp, #60]	; 0x3c
    e6a4:	str	r3, [sp, #36]	; 0x24
    e6a6:	cmp	r2, #0
    e6a8:	ble.w	e7be <_svfprintf_r+0x162e>
    e6ac:	movs	r2, #103	; 0x67
    e6ae:	bic.w	r3, r3, r3, asr #31
    e6b2:	str	r2, [sp, #52]	; 0x34
    e6b4:	b.n	e24a <_svfprintf_r+0x10ba>
    e6b6:	ldr	r3, [sp, #52]	; 0x34
    e6b8:	cmp	r3, #71	; 0x47
    e6ba:	bne.w	e1e8 <_svfprintf_r+0x1058>
    e6be:	ldr	r3, [sp, #12]
    e6c0:	lsls	r3, r3, #31
    e6c2:	bmi.w	e45a <_svfprintf_r+0x12ca>
    e6c6:	ldr	r3, [sp, #132]	; 0x84
    e6c8:	cmp	r7, #71	; 0x47
    e6ca:	sub.w	r3, r3, r6
    e6ce:	str	r3, [sp, #56]	; 0x38
    e6d0:	beq.w	e508 <_svfprintf_r+0x1378>
    e6d4:	ldr	r3, [sp, #116]	; 0x74
    e6d6:	b.n	e552 <_svfprintf_r+0x13c2>
    e6d8:	bic.w	r3, r5, r5, asr #31
    e6dc:	str	r7, [sp, #40]	; 0x28
    e6de:	str	r3, [sp, #16]
    e6e0:	str	r5, [sp, #36]	; 0x24
    e6e2:	mov	fp, r0
    e6e4:	str	r0, [sp, #60]	; 0x3c
    e6e6:	ldrb.w	r7, [sp, #111]	; 0x6f
    e6ea:	b.w	d534 <_svfprintf_r+0x3a4>
    e6ee:	cmp	r3, #0
    e6f0:	ble.n	e7ce <_svfprintf_r+0x163e>
    e6f2:	cmp.w	fp, #0
    e6f6:	bne.n	e798 <_svfprintf_r+0x1608>
    e6f8:	ldr	r2, [sp, #12]
    e6fa:	lsls	r4, r2, #31
    e6fc:	bmi.n	e798 <_svfprintf_r+0x1608>
    e6fe:	mov	r2, r3
    e700:	str	r2, [sp, #36]	; 0x24
    e702:	bic.w	r3, r3, r3, asr #31
    e706:	b.n	e24a <_svfprintf_r+0x10ba>
    e708:	ldr	r3, [sp, #12]
    e70a:	lsls	r3, r3, #31
    e70c:	mov	r7, fp
    e70e:	bpl.n	e71c <_svfprintf_r+0x158c>
    e710:	add	r6, sp, #256	; 0x100
    e712:	movs	r3, #48	; 0x30
    e714:	strb.w	r3, [r6, #-65]!
    e718:	b.w	d520 <_svfprintf_r+0x390>
    e71c:	str.w	fp, [sp, #36]	; 0x24
    e720:	add	r6, sp, #192	; 0xc0
    e722:	b.w	d526 <_svfprintf_r+0x396>
    e726:	add	r2, sp, #140	; 0x8c
    e728:	ldr	r1, [sp, #20]
    e72a:	ldr	r0, [sp, #24]
    e72c:	bl	12134 <__ssprint_r>
    e730:	cmp	r0, #0
    e732:	bne.w	d384 <_svfprintf_r+0x1f4>
    e736:	ldr	r5, [sp, #116]	; 0x74
    e738:	ldr	r4, [sp, #148]	; 0x94
    e73a:	ldr	r3, [sp, #144]	; 0x90
    e73c:	add.w	r9, sp, #192	; 0xc0
    e740:	b.n	e390 <_svfprintf_r+0x1200>
    e742:	mov	r8, r4
    e744:	movs	r5, #0
    e746:	b.w	d248 <_svfprintf_r+0xb8>
    e74a:	adds	r3, #48	; 0x30
    e74c:	movs	r2, #48	; 0x30
    e74e:	strb.w	r3, [sp, #127]	; 0x7f
    e752:	strb.w	r2, [sp, #126]	; 0x7e
    e756:	add	r3, sp, #128	; 0x80
    e758:	b.n	e5ca <_svfprintf_r+0x143a>
    e75a:	ldr	r3, [sp, #132]	; 0x84
    e75c:	b.n	e210 <_svfprintf_r+0x1080>
    e75e:	ldr	r2, [sp, #72]	; 0x48
    e760:	ldr	r3, [sp, #60]	; 0x3c
    e762:	add	r3, r2
    e764:	movs	r2, #103	; 0x67
    e766:	str	r3, [sp, #36]	; 0x24
    e768:	str	r2, [sp, #52]	; 0x34
    e76a:	bic.w	r3, r3, r3, asr #31
    e76e:	b.n	e24a <_svfprintf_r+0x10ba>
    e770:	ldr	r6, [pc, #248]	; (e86c <_svfprintf_r+0x16dc>)
    e772:	ldr	r3, [pc, #252]	; (e870 <_svfprintf_r+0x16e0>)
    e774:	ldrb.w	r7, [sp, #111]	; 0x6f
    e778:	b.w	d7de <_svfprintf_r+0x64e>
    e77c:	movs	r2, #0
    e77e:	movs	r3, #0
    e780:	ldrd	r0, r1, [sp, #96]	; 0x60
    e784:	bl	adb0 <__aeabi_dcmpeq>
    e788:	cmp	r0, #0
    e78a:	bne.w	e46e <_svfprintf_r+0x12de>
    e78e:	rsb	r5, r5, #1
    e792:	str	r5, [sp, #116]	; 0x74
    e794:	add	r4, r5
    e796:	b.n	e1ea <_svfprintf_r+0x105a>
    e798:	ldr	r3, [sp, #60]	; 0x3c
    e79a:	ldr	r2, [sp, #72]	; 0x48
    e79c:	adds	r5, r3, r2
    e79e:	add.w	r3, r5, fp
    e7a2:	str	r3, [sp, #36]	; 0x24
    e7a4:	bic.w	r3, r3, r3, asr #31
    e7a8:	b.n	e24a <_svfprintf_r+0x10ba>
    e7aa:	ldr	r3, [sp, #12]
    e7ac:	ands.w	r3, r3, #1
    e7b0:	bne.w	e5dc <_svfprintf_r+0x144c>
    e7b4:	str	r3, [sp, #60]	; 0x3c
    e7b6:	ldr	r3, [sp, #36]	; 0x24
    e7b8:	bic.w	r3, r3, r3, asr #31
    e7bc:	b.n	e24a <_svfprintf_r+0x10ba>
    e7be:	ldr	r3, [sp, #60]	; 0x3c
    e7c0:	ldr	r2, [sp, #36]	; 0x24
    e7c2:	rsb	r3, r3, #1
    e7c6:	add	r2, r3
    e7c8:	mov	r3, r2
    e7ca:	str	r2, [sp, #36]	; 0x24
    e7cc:	b.n	e6ac <_svfprintf_r+0x151c>
    e7ce:	cmp.w	fp, #0
    e7d2:	bne.n	e7da <_svfprintf_r+0x164a>
    e7d4:	ldr	r3, [sp, #12]
    e7d6:	lsls	r0, r3, #31
    e7d8:	bpl.n	e7ea <_svfprintf_r+0x165a>
    e7da:	ldr	r3, [sp, #72]	; 0x48
    e7dc:	adds	r5, r3, #1
    e7de:	add.w	r3, r5, fp
    e7e2:	str	r3, [sp, #36]	; 0x24
    e7e4:	bic.w	r3, r3, r3, asr #31
    e7e8:	b.n	e24a <_svfprintf_r+0x10ba>
    e7ea:	movs	r3, #1
    e7ec:	str	r3, [sp, #36]	; 0x24
    e7ee:	b.n	e24a <_svfprintf_r+0x10ba>
    e7f0:	ldr	r0, [sp, #40]	; 0x28
    e7f2:	ldrb.w	r3, [r8, #1]
    e7f6:	ldr	r5, [r0, #0]
    e7f8:	adds	r0, #4
    e7fa:	cmp	r5, #0
    e7fc:	str	r0, [sp, #40]	; 0x28
    e7fe:	mov	r8, r4
    e800:	bge.w	d244 <_svfprintf_r+0xb4>
    e804:	mov.w	r5, #4294967295
    e808:	b.w	d244 <_svfprintf_r+0xb4>
    e80c:	strb.w	r1, [sp, #111]	; 0x6f
    e810:	b.w	d3a6 <_svfprintf_r+0x216>
    e814:	add.w	r3, sp, #126	; 0x7e
    e818:	b.n	e5ca <_svfprintf_r+0x143a>
    e81a:	ldr	r2, [sp, #24]
    e81c:	movs	r3, #12
    e81e:	str	r3, [r2, #0]
    e820:	mov.w	r0, #4294967295
    e824:	b.w	d396 <_svfprintf_r+0x206>
    e828:	strb.w	r1, [sp, #111]	; 0x6f
    e82c:	b.w	d4a0 <_svfprintf_r+0x310>
    e830:	strb.w	r1, [sp, #111]	; 0x6f
    e834:	b.w	d76c <_svfprintf_r+0x5dc>
    e838:	strb.w	r1, [sp, #111]	; 0x6f
    e83c:	b.w	d8da <_svfprintf_r+0x74a>
    e840:	strb.w	r1, [sp, #111]	; 0x6f
    e844:	b.w	d87e <_svfprintf_r+0x6ee>
    e848:	strb.w	r1, [sp, #111]	; 0x6f
    e84c:	b.w	d82a <_svfprintf_r+0x69a>
    e850:	strb.w	r1, [sp, #111]	; 0x6f
    e854:	b.w	dac2 <_svfprintf_r+0x932>
    e858:	strb.w	r1, [sp, #111]	; 0x6f
    e85c:	b.w	da80 <_svfprintf_r+0x8f0>
    e860:	strb.w	r1, [sp, #111]	; 0x6f
    e864:	b.w	da44 <_svfprintf_r+0x8b4>
    e868:	.word	0x000131c8
    e86c:	.word	0x0001319c
    e870:	.word	0x00013198

0000e874 <__ssvfscanf_r>:
    e874:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e878:	mov	fp, r1
    e87a:	ldrsh.w	r1, [r1, #12]
    e87e:	sub.w	sp, sp, #692	; 0x2b4
    e882:	mov	sl, r0
    e884:	lsls	r0, r1, #18
    e886:	mov	r4, r2
    e888:	str	r3, [sp, #20]
    e88a:	bmi.n	e8a0 <__ssvfscanf_r+0x2c>
    e88c:	ldr.w	r3, [fp, #100]	; 0x64
    e890:	orr.w	r1, r1, #8192	; 0x2000
    e894:	bic.w	r3, r3, #8192	; 0x2000
    e898:	strh.w	r1, [fp, #12]
    e89c:	str.w	r3, [fp, #100]	; 0x64
    e8a0:	mov	r6, r4
    e8a2:	movs	r3, #0
    e8a4:	str	r3, [sp, #28]
    e8a6:	str	r3, [sp, #16]
    e8a8:	mov	r7, r3
    e8aa:	str	r3, [sp, #24]
    e8ac:	ldrb.w	r3, [r6], #1
    e8b0:	str	r3, [sp, #68]	; 0x44
    e8b2:	cbz	r3, e910 <__ssvfscanf_r+0x9c>
    e8b4:	bl	b32c <__locale_ctype_ptr>
    e8b8:	ldr	r2, [sp, #68]	; 0x44
    e8ba:	add	r0, r2
    e8bc:	ldrb	r3, [r0, #1]
    e8be:	and.w	r3, r3, #8
    e8c2:	and.w	r5, r3, #255	; 0xff
    e8c6:	cbz	r3, e91a <__ssvfscanf_r+0xa6>
    e8c8:	ldr.w	r3, [fp, #4]
    e8cc:	b.n	e8f2 <__ssvfscanf_r+0x7e>
    e8ce:	bl	b32c <__locale_ctype_ptr>
    e8d2:	ldr.w	r3, [fp]
    e8d6:	ldrb	r2, [r3, #0]
    e8d8:	add	r0, r2
    e8da:	adds	r3, #1
    e8dc:	ldrb	r2, [r0, #1]
    e8de:	lsls	r1, r2, #28
    e8e0:	bpl.n	e902 <__ssvfscanf_r+0x8e>
    e8e2:	ldr.w	r2, [fp, #4]
    e8e6:	str.w	r3, [fp]
    e8ea:	subs	r3, r2, #1
    e8ec:	adds	r7, #1
    e8ee:	str.w	r3, [fp, #4]
    e8f2:	cmp	r3, #0
    e8f4:	bgt.n	e8ce <__ssvfscanf_r+0x5a>
    e8f6:	mov	r1, fp
    e8f8:	mov	r0, sl
    e8fa:	bl	122b8 <__ssrefill_r>
    e8fe:	cmp	r0, #0
    e900:	beq.n	e8ce <__ssvfscanf_r+0x5a>
    e902:	mov	r4, r6
    e904:	mov	r6, r4
    e906:	ldrb.w	r3, [r6], #1
    e90a:	str	r3, [sp, #68]	; 0x44
    e90c:	cmp	r3, #0
    e90e:	bne.n	e8b4 <__ssvfscanf_r+0x40>
    e910:	ldr	r0, [sp, #24]
    e912:	add.w	sp, sp, #692	; 0x2b4
    e916:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e91a:	cmp	r2, #37	; 0x25
    e91c:	bne.w	ea28 <__ssvfscanf_r+0x1b4>
    e920:	ldrb.w	r8, [r4, #1]
    e924:	mov	r4, r5
    e926:	adds	r3, r6, #1
    e928:	cmp.w	r8, #120	; 0x78
    e92c:	bhi.w	edb6 <__ssvfscanf_r+0x542>
    e930:	tbh	[pc, r8, lsl #1]
    e934:	.word	0x02410092
    e938:	.word	0x02410241
    e93c:	.word	0x02410241
    e940:	.word	0x02410241
    e944:	.word	0x02410241
    e948:	.word	0x02410241
    e94c:	.word	0x02410241
    e950:	.word	0x02410241
    e954:	.word	0x02410241
    e958:	.word	0x02410241
    e95c:	.word	0x02410241
    e960:	.word	0x02410241
    e964:	.word	0x02410241
    e968:	.word	0x02410241
    e96c:	.word	0x02410241
    e970:	.word	0x02410241
    e974:	.word	0x02410241
    e978:	.word	0x02410241
    e97c:	.word	0x00790241
    e980:	.word	0x02410241
    e984:	.word	0x02410241
    e988:	.word	0x024101d8
    e98c:	.word	0x02410241
    e990:	.word	0x02410241
    e994:	.word	0x01cf01cf
    e998:	.word	0x01cf01cf
    e99c:	.word	0x01cf01cf
    e9a0:	.word	0x01cf01cf
    e9a4:	.word	0x01cf01cf
    e9a8:	.word	0x02410241
    e9ac:	.word	0x02410241
    e9b0:	.word	0x02410241
    e9b4:	.word	0x02410241
    e9b8:	.word	0x02410241
    e9bc:	.word	0x01b901c1
    e9c0:	.word	0x01b90241
    e9c4:	.word	0x02410241
    e9c8:	.word	0x02410241
    e9cc:	.word	0x024101b3
    e9d0:	.word	0x01a30241
    e9d4:	.word	0x02410241
    e9d8:	.word	0x02410241
    e9dc:	.word	0x02410241
    e9e0:	.word	0x02410241
    e9e4:	.word	0x02410193
    e9e8:	.word	0x01510241
    e9ec:	.word	0x02410241
    e9f0:	.word	0x02410241
    e9f4:	.word	0x02410241
    e9f8:	.word	0x01220241
    e9fc:	.word	0x01b90188
    ea00:	.word	0x01b901b9
    ea04:	.word	0x0098011c
    ea08:	.word	0x02410241
    ea0c:	.word	0x024100d5
    ea10:	.word	0x0101010d
    ea14:	.word	0x024100f3
    ea18:	.word	0x00eb0241
    ea1c:	.word	0x00df0241
    ea20:	.word	0x02410241
    ea24:	.short	0x0193
    ea26:	mov	r6, r3
    ea28:	ldr.w	r3, [fp, #4]
    ea2c:	cmp	r3, #0
    ea2e:	ble.w	eed8 <__ssvfscanf_r+0x664>
    ea32:	ldr.w	r3, [fp]
    ea36:	ldrb.w	r2, [r6, #-1]
    ea3a:	ldrb	r1, [r3, #0]
    ea3c:	cmp	r1, r2
    ea3e:	bne.w	e910 <__ssvfscanf_r+0x9c>
    ea42:	ldr.w	r2, [fp, #4]
    ea46:	adds	r3, #1
    ea48:	subs	r2, #1
    ea4a:	str.w	r3, [fp]
    ea4e:	adds	r7, #1
    ea50:	str.w	r2, [fp, #4]
    ea54:	mov	r4, r6
    ea56:	b.n	e904 <__ssvfscanf_r+0x90>
    ea58:	mov.w	r0, #4294967295
    ea5c:	add.w	sp, sp, #692	; 0x2b4
    ea60:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ea64:	str	r3, [sp, #12]
    ea66:	ldr.w	r3, [fp, #4]
    ea6a:	cmp	r3, #0
    ea6c:	ble.w	ef36 <__ssvfscanf_r+0x6c2>
    ea70:	ldr	r3, [pc, #736]	; (ed54 <__ssvfscanf_r+0x4e0>)
    ea72:	str	r3, [sp, #28]
    ea74:	movs	r3, #0
    ea76:	str	r3, [sp, #16]
    ea78:	movs	r6, #3
    ea7a:	b.n	ea80 <__ssvfscanf_r+0x20c>
    ea7c:	str.w	lr, [fp]
    ea80:	bl	b32c <__locale_ctype_ptr>
    ea84:	ldr.w	r2, [fp]
    ea88:	ldrb	r1, [r2, #0]
    ea8a:	add	r0, r1
    ea8c:	add.w	lr, r2, #1
    ea90:	ldrb	r3, [r0, #1]
    ea92:	and.w	r3, r3, #8
    ea96:	and.w	r8, r3, #255	; 0xff
    ea9a:	cmp	r3, #0
    ea9c:	beq.w	ef9e <__ssvfscanf_r+0x72a>
    eaa0:	ldr.w	r3, [fp, #4]
    eaa4:	subs	r3, #1
    eaa6:	cmp	r3, #0
    eaa8:	add.w	r7, r7, #1
    eaac:	str.w	r3, [fp, #4]
    eab0:	bgt.n	ea7c <__ssvfscanf_r+0x208>
    eab2:	mov	r1, fp
    eab4:	mov	r0, sl
    eab6:	bl	122b8 <__ssrefill_r>
    eaba:	cmp	r0, #0
    eabc:	beq.n	ea80 <__ssvfscanf_r+0x20c>
    eabe:	ldr	r2, [sp, #24]
    eac0:	cmp	r2, #0
    eac2:	beq.n	ea58 <__ssvfscanf_r+0x1e4>
    eac4:	ldrh.w	r3, [fp, #12]
    eac8:	tst.w	r3, #64	; 0x40
    eacc:	mov	r3, r2
    eace:	it	ne
    ead0:	movne.w	r3, #4294967295
    ead4:	mov	r0, r3
    ead6:	add.w	sp, sp, #692	; 0x2b4
    eada:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    eade:	ldrb.w	r8, [r6, #1]
    eae2:	cmp.w	r8, #108	; 0x6c
    eae6:	beq.w	eeee <__ssvfscanf_r+0x67a>
    eaea:	orr.w	r5, r5, #1
    eaee:	mov	r6, r3
    eaf0:	b.n	e926 <__ssvfscanf_r+0xb2>
    eaf2:	str	r3, [sp, #12]
    eaf4:	ldr.w	r3, [fp, #4]
    eaf8:	cmp	r3, #0
    eafa:	ble.w	ef8e <__ssvfscanf_r+0x71a>
    eafe:	ldr	r3, [pc, #600]	; (ed58 <__ssvfscanf_r+0x4e4>)
    eb00:	str	r3, [sp, #28]
    eb02:	movs	r3, #10
    eb04:	str	r3, [sp, #16]
    eb06:	movs	r6, #3
    eb08:	b.n	ea80 <__ssvfscanf_r+0x20c>
    eb0a:	str	r3, [sp, #12]
    eb0c:	ldr.w	r3, [fp, #4]
    eb10:	cmp	r3, #0
    eb12:	ble.w	ef7e <__ssvfscanf_r+0x70a>
    eb16:	movs	r6, #2
    eb18:	b.n	ea80 <__ssvfscanf_r+0x20c>
    eb1a:	str	r3, [sp, #12]
    eb1c:	ldr.w	r3, [fp, #4]
    eb20:	cmp	r3, #0
    eb22:	orr.w	r5, r5, #544	; 0x220
    eb26:	ble.w	ec6a <__ssvfscanf_r+0x3f6>
    eb2a:	ldr	r3, [pc, #556]	; (ed58 <__ssvfscanf_r+0x4e4>)
    eb2c:	str	r3, [sp, #28]
    eb2e:	movs	r3, #16
    eb30:	str	r3, [sp, #16]
    eb32:	movs	r6, #3
    eb34:	b.n	ea80 <__ssvfscanf_r+0x20c>
    eb36:	str	r3, [sp, #12]
    eb38:	ldr.w	r3, [fp, #4]
    eb3c:	cmp	r3, #0
    eb3e:	ble.w	ec8a <__ssvfscanf_r+0x416>
    eb42:	ldr	r3, [pc, #532]	; (ed58 <__ssvfscanf_r+0x4e4>)
    eb44:	str	r3, [sp, #28]
    eb46:	movs	r3, #8
    eb48:	str	r3, [sp, #16]
    eb4a:	movs	r6, #3
    eb4c:	b.n	ea80 <__ssvfscanf_r+0x20c>
    eb4e:	lsls	r2, r5, #27
    eb50:	mov	r6, r3
    eb52:	str	r3, [sp, #12]
    eb54:	bmi.w	ed3c <__ssvfscanf_r+0x4c8>
    eb58:	lsls	r3, r5, #29
    eb5a:	bpl.w	ef06 <__ssvfscanf_r+0x692>
    eb5e:	ldr	r1, [sp, #20]
    eb60:	ldr	r3, [r1, #0]
    eb62:	strh	r7, [r3, #0]
    eb64:	adds	r3, r1, #4
    eb66:	str	r3, [sp, #20]
    eb68:	mov	r4, r6
    eb6a:	b.n	e904 <__ssvfscanf_r+0x90>
    eb6c:	ldrb.w	r8, [r6, #1]
    eb70:	orr.w	r5, r5, #4
    eb74:	mov	r6, r3
    eb76:	b.n	e926 <__ssvfscanf_r+0xb2>
    eb78:	str	r3, [sp, #12]
    eb7a:	ldr.w	r3, [fp, #4]
    eb7e:	cmp	r3, #0
    eb80:	ble.w	ef5e <__ssvfscanf_r+0x6ea>
    eb84:	cmp	r4, #0
    eb86:	it	eq
    eb88:	moveq	r4, #1
    eb8a:	ands.w	r3, r5, #1
    eb8e:	bne.w	edd6 <__ssvfscanf_r+0x562>
    eb92:	lsls	r2, r5, #27
    eb94:	bpl.w	eeae <__ssvfscanf_r+0x63a>
    eb98:	mov	r5, r3
    eb9a:	b.n	ebb0 <__ssvfscanf_r+0x33c>
    eb9c:	add	r3, r2
    eb9e:	str.w	r3, [fp]
    eba2:	add	r5, r2
    eba4:	subs	r4, r4, r2
    eba6:	bl	122b8 <__ssrefill_r>
    ebaa:	cmp	r0, #0
    ebac:	bne.w	eea6 <__ssvfscanf_r+0x632>
    ebb0:	ldr.w	r2, [fp, #4]
    ebb4:	ldr.w	r3, [fp]
    ebb8:	cmp	r2, r4
    ebba:	mov	r1, fp
    ebbc:	mov	r0, sl
    ebbe:	blt.n	eb9c <__ssvfscanf_r+0x328>
    ebc0:	subs	r2, r2, r4
    ebc2:	add	r3, r4
    ebc4:	str.w	r2, [fp, #4]
    ebc8:	add	r5, r4
    ebca:	str.w	r3, [fp]
    ebce:	ldr	r6, [sp, #12]
    ebd0:	add	r7, r5
    ebd2:	mov	r4, r6
    ebd4:	b.n	e904 <__ssvfscanf_r+0x90>
    ebd6:	add.w	r9, sp, #80	; 0x50
    ebda:	mov	r1, r3
    ebdc:	mov	r0, r9
    ebde:	bl	11b48 <__sccl>
    ebe2:	ldr.w	r3, [fp, #4]
    ebe6:	cmp	r3, #0
    ebe8:	mov	r6, r0
    ebea:	ble.w	ef4e <__ssvfscanf_r+0x6da>
    ebee:	cmp	r4, #0
    ebf0:	ldr.w	r2, [fp]
    ebf4:	it	eq
    ebf6:	moveq.w	r4, #4294967295
    ebfa:	lsls	r3, r5, #27
    ebfc:	ldrb	r1, [r2, #0]
    ebfe:	bpl.w	ed42 <__ssvfscanf_r+0x4ce>
    ec02:	mov	r8, r4
    ec04:	movs	r5, #0
    ec06:	b.n	ec0a <__ssvfscanf_r+0x396>
    ec08:	ldrb	r1, [r2, #0]
    ec0a:	ldrb.w	r3, [r9, r1]
    ec0e:	adds	r2, #1
    ec10:	cmp	r3, #0
    ec12:	beq.w	ee9c <__ssvfscanf_r+0x628>
    ec16:	ldr.w	r3, [fp, #4]
    ec1a:	str.w	r2, [fp]
    ec1e:	adds	r5, #1
    ec20:	subs	r3, #1
    ec22:	cmp	r5, r4
    ec24:	str.w	r3, [fp, #4]
    ec28:	beq.w	ee96 <__ssvfscanf_r+0x622>
    ec2c:	cmp	r3, #0
    ec2e:	bgt.n	ec08 <__ssvfscanf_r+0x394>
    ec30:	mov	r1, fp
    ec32:	mov	r0, sl
    ec34:	bl	122b8 <__ssrefill_r>
    ec38:	cmp	r0, #0
    ec3a:	bne.w	ee94 <__ssvfscanf_r+0x620>
    ec3e:	ldr.w	r2, [fp]
    ec42:	b.n	ec08 <__ssvfscanf_r+0x394>
    ec44:	str	r3, [sp, #12]
    ec46:	ldr.w	r3, [fp, #4]
    ec4a:	cmp	r3, #0
    ec4c:	ble.n	ecc4 <__ssvfscanf_r+0x450>
    ec4e:	ldr	r3, [pc, #260]	; (ed54 <__ssvfscanf_r+0x4e0>)
    ec50:	str	r3, [sp, #28]
    ec52:	movs	r3, #10
    ec54:	str	r3, [sp, #16]
    ec56:	movs	r6, #3
    ec58:	b.n	ea80 <__ssvfscanf_r+0x20c>
    ec5a:	str	r3, [sp, #12]
    ec5c:	ldr.w	r3, [fp, #4]
    ec60:	cmp	r3, #0
    ec62:	orr.w	r5, r5, #512	; 0x200
    ec66:	bgt.w	eb2a <__ssvfscanf_r+0x2b6>
    ec6a:	mov	r1, fp
    ec6c:	mov	r0, sl
    ec6e:	bl	122b8 <__ssrefill_r>
    ec72:	cmp	r0, #0
    ec74:	beq.w	eb2a <__ssvfscanf_r+0x2b6>
    ec78:	b.n	eabe <__ssvfscanf_r+0x24a>
    ec7a:	str	r3, [sp, #12]
    ec7c:	ldr.w	r3, [fp, #4]
    ec80:	cmp	r3, #0
    ec82:	orr.w	r5, r5, #1
    ec86:	bgt.w	eb42 <__ssvfscanf_r+0x2ce>
    ec8a:	mov	r1, fp
    ec8c:	mov	r0, sl
    ec8e:	bl	122b8 <__ssrefill_r>
    ec92:	cmp	r0, #0
    ec94:	beq.w	eb42 <__ssvfscanf_r+0x2ce>
    ec98:	b.n	eabe <__ssvfscanf_r+0x24a>
    ec9a:	ldrb.w	r8, [r6, #1]
    ec9e:	orr.w	r5, r5, #2
    eca2:	mov	r6, r3
    eca4:	b.n	e926 <__ssvfscanf_r+0xb2>
    eca6:	str	r3, [sp, #12]
    eca8:	ldr.w	r3, [fp, #4]
    ecac:	cmp	r3, #0
    ecae:	ble.w	ef6e <__ssvfscanf_r+0x6fa>
    ecb2:	movs	r6, #4
    ecb4:	b.n	ea80 <__ssvfscanf_r+0x20c>
    ecb6:	str	r3, [sp, #12]
    ecb8:	ldr.w	r3, [fp, #4]
    ecbc:	cmp	r3, #0
    ecbe:	orr.w	r5, r5, #1
    ecc2:	bgt.n	ec4e <__ssvfscanf_r+0x3da>
    ecc4:	mov	r1, fp
    ecc6:	mov	r0, sl
    ecc8:	bl	122b8 <__ssrefill_r>
    eccc:	cmp	r0, #0
    ecce:	beq.n	ec4e <__ssvfscanf_r+0x3da>
    ecd0:	b.n	eabe <__ssvfscanf_r+0x24a>
    ecd2:	add.w	r4, r4, r4, lsl #2
    ecd6:	add.w	r4, r8, r4, lsl #1
    ecda:	subs	r4, #48	; 0x30
    ecdc:	ldrb.w	r8, [r6, #1]
    ece0:	mov	r6, r3
    ece2:	b.n	e926 <__ssvfscanf_r+0xb2>
    ece4:	ldrb.w	r8, [r6, #1]
    ece8:	orr.w	r5, r5, #16
    ecec:	mov	r6, r3
    ecee:	b.n	e926 <__ssvfscanf_r+0xb2>
    ecf0:	add	r3, sp, #72	; 0x48
    ecf2:	mov	r1, r8
    ecf4:	mov	r0, r3
    ecf6:	movs	r2, #8
    ecf8:	str	r3, [sp, #32]
    ecfa:	bl	90e4 <memset>
    ecfe:	ands.w	r9, r5, #16
    ed02:	bne.w	f5c8 <__ssvfscanf_r+0xd54>
    ed06:	ldr	r2, [sp, #20]
    ed08:	mov	r3, r2
    ed0a:	adds	r3, #4
    ed0c:	ldr.w	r8, [r2]
    ed10:	str	r3, [sp, #20]
    ed12:	movs	r6, #0
    ed14:	bl	b32c <__locale_ctype_ptr>
    ed18:	ldr.w	r3, [fp]
    ed1c:	ldrb	r3, [r3, #0]
    ed1e:	add	r0, r3
    ed20:	ldrb	r3, [r0, #1]
    ed22:	lsls	r0, r3, #28
    ed24:	bmi.n	ed2c <__ssvfscanf_r+0x4b8>
    ed26:	cmp	r4, #0
    ed28:	bne.w	f52c <__ssvfscanf_r+0xcb8>
    ed2c:	cmp.w	r9, #0
    ed30:	bne.n	ed3c <__ssvfscanf_r+0x4c8>
    ed32:	str.w	r9, [r8]
    ed36:	ldr	r3, [sp, #24]
    ed38:	adds	r3, #1
    ed3a:	str	r3, [sp, #24]
    ed3c:	ldr	r6, [sp, #12]
    ed3e:	mov	r4, r6
    ed40:	b.n	e904 <__ssvfscanf_r+0x90>
    ed42:	ldr	r0, [sp, #20]
    ed44:	ldr	r5, [r0, #0]
    ed46:	mov	r3, r0
    ed48:	adds	r3, #4
    ed4a:	add.w	r8, r5, r4
    ed4e:	str	r3, [sp, #12]
    ed50:	mov	r4, r5
    ed52:	b.n	ed62 <__ssvfscanf_r+0x4ee>
    ed54:	.word	0x0000d169
    ed58:	.word	0x00011f01
    ed5c:	ldr.w	r2, [fp]
    ed60:	ldrb	r1, [r2, #0]
    ed62:	ldrb.w	r3, [r9, r1]
    ed66:	adds	r0, r2, #1
    ed68:	cbz	r3, ed9c <__ssvfscanf_r+0x528>
    ed6a:	ldr.w	r3, [fp, #4]
    ed6e:	str.w	r0, [fp]
    ed72:	subs	r3, #1
    ed74:	str.w	r3, [fp, #4]
    ed78:	ldrb	r3, [r2, #0]
    ed7a:	strb.w	r3, [r4], #1
    ed7e:	cmp	r8, r4
    ed80:	beq.n	ed9c <__ssvfscanf_r+0x528>
    ed82:	ldr.w	r3, [fp, #4]
    ed86:	cmp	r3, #0
    ed88:	bgt.n	ed5c <__ssvfscanf_r+0x4e8>
    ed8a:	mov	r1, fp
    ed8c:	mov	r0, sl
    ed8e:	bl	122b8 <__ssrefill_r>
    ed92:	cmp	r0, #0
    ed94:	beq.n	ed5c <__ssvfscanf_r+0x4e8>
    ed96:	cmp	r5, r4
    ed98:	beq.w	eabe <__ssvfscanf_r+0x24a>
    ed9c:	subs	r5, r4, r5
    ed9e:	beq.w	e910 <__ssvfscanf_r+0x9c>
    eda2:	ldr	r2, [sp, #24]
    eda4:	adds	r2, #1
    eda6:	movs	r3, #0
    eda8:	str	r2, [sp, #24]
    edaa:	ldr	r2, [sp, #12]
    edac:	str	r2, [sp, #20]
    edae:	strb	r3, [r4, #0]
    edb0:	add	r7, r5
    edb2:	mov	r4, r6
    edb4:	b.n	e904 <__ssvfscanf_r+0x90>
    edb6:	str	r3, [sp, #12]
    edb8:	bl	b32c <__locale_ctype_ptr>
    edbc:	add	r0, r8
    edbe:	ldrb	r3, [r0, #1]
    edc0:	and.w	r3, r3, #3
    edc4:	cmp	r3, #1
    edc6:	ldr.w	r3, [fp, #4]
    edca:	beq.w	eefa <__ssvfscanf_r+0x686>
    edce:	cmp	r3, #0
    edd0:	bgt.w	ec4e <__ssvfscanf_r+0x3da>
    edd4:	b.n	ecc4 <__ssvfscanf_r+0x450>
    edd6:	add	r3, sp, #72	; 0x48
    edd8:	mov	r0, r3
    edda:	movs	r2, #8
    eddc:	movs	r1, #0
    edde:	str	r3, [sp, #32]
    ede0:	bl	90e4 <memset>
    ede4:	ands.w	r3, r5, #16
    ede8:	str	r3, [sp, #40]	; 0x28
    edea:	bne.n	eee8 <__ssvfscanf_r+0x674>
    edec:	ldr	r2, [sp, #20]
    edee:	mov	r3, r2
    edf0:	adds	r3, #4
    edf2:	ldr.w	r9, [r2]
    edf6:	str	r3, [sp, #20]
    edf8:	movs	r5, #0
    edfa:	add.w	r8, sp, #336	; 0x150
    edfe:	bl	b308 <__locale_mb_cur_max>
    ee02:	cmp	r0, r5
    ee04:	beq.w	eabe <__ssvfscanf_r+0x24a>
    ee08:	ldmia.w	fp, {r2, r3}
    ee0c:	ldrb.w	r0, [r2], #1
    ee10:	str.w	r2, [fp]
    ee14:	subs	r3, #1
    ee16:	ldr	r2, [sp, #32]
    ee18:	str	r2, [sp, #0]
    ee1a:	adds	r6, r5, #1
    ee1c:	str.w	r3, [fp, #4]
    ee20:	mov	r1, r9
    ee22:	strb.w	r0, [r8, r5]
    ee26:	mov	r3, r6
    ee28:	mov	r2, r8
    ee2a:	mov	r0, sl
    ee2c:	bl	11204 <_mbrtowc_r>
    ee30:	adds	r1, r0, #1
    ee32:	beq.w	eabe <__ssvfscanf_r+0x24a>
    ee36:	cbnz	r0, ee62 <__ssvfscanf_r+0x5ee>
    ee38:	ldr	r3, [sp, #40]	; 0x28
    ee3a:	cbnz	r3, ee82 <__ssvfscanf_r+0x60e>
    ee3c:	str.w	r3, [r9]
    ee40:	add	r7, r6
    ee42:	subs	r4, #1
    ee44:	add.w	r9, r9, #4
    ee48:	ldr.w	r3, [fp, #4]
    ee4c:	cmp	r3, #0
    ee4e:	mov.w	r5, #0
    ee52:	ble.n	ee70 <__ssvfscanf_r+0x5fc>
    ee54:	cmp	r4, #0
    ee56:	bne.n	edfe <__ssvfscanf_r+0x58a>
    ee58:	ldr	r3, [sp, #40]	; 0x28
    ee5a:	cmp	r3, #0
    ee5c:	beq.w	ed36 <__ssvfscanf_r+0x4c2>
    ee60:	b.n	ed3c <__ssvfscanf_r+0x4c8>
    ee62:	adds	r0, #2
    ee64:	bne.n	ee88 <__ssvfscanf_r+0x614>
    ee66:	ldr.w	r3, [fp, #4]
    ee6a:	cmp	r3, #0
    ee6c:	mov	r5, r6
    ee6e:	bgt.n	edfe <__ssvfscanf_r+0x58a>
    ee70:	mov	r1, fp
    ee72:	mov	r0, sl
    ee74:	bl	122b8 <__ssrefill_r>
    ee78:	cmp	r0, #0
    ee7a:	beq.n	ee54 <__ssvfscanf_r+0x5e0>
    ee7c:	cmp	r5, #0
    ee7e:	beq.n	ee58 <__ssvfscanf_r+0x5e4>
    ee80:	b.n	eabe <__ssvfscanf_r+0x24a>
    ee82:	add	r7, r6
    ee84:	subs	r4, #1
    ee86:	b.n	ee48 <__ssvfscanf_r+0x5d4>
    ee88:	ldr	r3, [sp, #40]	; 0x28
    ee8a:	add	r7, r6
    ee8c:	subs	r4, #1
    ee8e:	cmp	r3, #0
    ee90:	bne.n	ee48 <__ssvfscanf_r+0x5d4>
    ee92:	b.n	ee44 <__ssvfscanf_r+0x5d0>
    ee94:	mov	r8, r5
    ee96:	mov	r5, r8
    ee98:	add	r7, r5
    ee9a:	b.n	edb2 <__ssvfscanf_r+0x53e>
    ee9c:	cmp	r5, #0
    ee9e:	beq.w	e910 <__ssvfscanf_r+0x9c>
    eea2:	add	r7, r5
    eea4:	b.n	edb2 <__ssvfscanf_r+0x53e>
    eea6:	cmp	r5, #0
    eea8:	bne.w	ebce <__ssvfscanf_r+0x35a>
    eeac:	b.n	eabe <__ssvfscanf_r+0x24a>
    eeae:	ldr	r5, [sp, #20]
    eeb0:	mov	r3, r4
    eeb2:	ldr	r1, [r5, #0]
    eeb4:	str.w	fp, [sp]
    eeb8:	movs	r2, #1
    eeba:	mov	r0, sl
    eebc:	bl	122f4 <_sfread_r>
    eec0:	adds	r6, r5, #4
    eec2:	cmp	r0, #0
    eec4:	beq.w	eabe <__ssvfscanf_r+0x24a>
    eec8:	ldr	r3, [sp, #24]
    eeca:	str	r6, [sp, #20]
    eecc:	ldr	r6, [sp, #12]
    eece:	adds	r3, #1
    eed0:	add	r7, r0
    eed2:	str	r3, [sp, #24]
    eed4:	mov	r4, r6
    eed6:	b.n	e904 <__ssvfscanf_r+0x90>
    eed8:	mov	r1, fp
    eeda:	mov	r0, sl
    eedc:	bl	122b8 <__ssrefill_r>
    eee0:	cmp	r0, #0
    eee2:	beq.w	ea32 <__ssvfscanf_r+0x1be>
    eee6:	b.n	eabe <__ssvfscanf_r+0x24a>
    eee8:	mov.w	r9, #0
    eeec:	b.n	edf8 <__ssvfscanf_r+0x584>
    eeee:	ldrb.w	r8, [r6, #2]
    eef2:	orr.w	r5, r5, #2
    eef6:	adds	r6, #2
    eef8:	b.n	e926 <__ssvfscanf_r+0xb2>
    eefa:	cmp	r3, #0
    eefc:	orr.w	r5, r5, #1
    ef00:	bgt.w	ec4e <__ssvfscanf_r+0x3da>
    ef04:	b.n	ecc4 <__ssvfscanf_r+0x450>
    ef06:	lsls	r4, r5, #31
    ef08:	bmi.n	ef24 <__ssvfscanf_r+0x6b0>
    ef0a:	lsls	r0, r5, #30
    ef0c:	bpl.n	ef24 <__ssvfscanf_r+0x6b0>
    ef0e:	ldr	r2, [sp, #20]
    ef10:	ldr	r6, [sp, #12]
    ef12:	ldr	r3, [r2, #0]
    ef14:	mov	r0, r7
    ef16:	asrs	r1, r7, #31
    ef18:	adds	r2, #4
    ef1a:	str	r2, [sp, #20]
    ef1c:	strd	r0, r1, [r3]
    ef20:	mov	r4, r6
    ef22:	b.n	e904 <__ssvfscanf_r+0x90>
    ef24:	ldr	r2, [sp, #20]
    ef26:	ldr	r6, [sp, #12]
    ef28:	ldr	r3, [r2, #0]
    ef2a:	str	r7, [r3, #0]
    ef2c:	mov	r3, r2
    ef2e:	adds	r3, #4
    ef30:	str	r3, [sp, #20]
    ef32:	mov	r4, r6
    ef34:	b.n	e904 <__ssvfscanf_r+0x90>
    ef36:	mov	r1, fp
    ef38:	mov	r0, sl
    ef3a:	bl	122b8 <__ssrefill_r>
    ef3e:	cmp	r0, #0
    ef40:	bne.w	eabe <__ssvfscanf_r+0x24a>
    ef44:	ldr	r3, [pc, #504]	; (f140 <__ssvfscanf_r+0x8cc>)
    ef46:	str	r0, [sp, #16]
    ef48:	str	r3, [sp, #28]
    ef4a:	movs	r6, #3
    ef4c:	b.n	ea80 <__ssvfscanf_r+0x20c>
    ef4e:	mov	r1, fp
    ef50:	mov	r0, sl
    ef52:	bl	122b8 <__ssrefill_r>
    ef56:	cmp	r0, #0
    ef58:	beq.w	ebee <__ssvfscanf_r+0x37a>
    ef5c:	b.n	eabe <__ssvfscanf_r+0x24a>
    ef5e:	mov	r1, fp
    ef60:	mov	r0, sl
    ef62:	bl	122b8 <__ssrefill_r>
    ef66:	cmp	r0, #0
    ef68:	beq.w	eb84 <__ssvfscanf_r+0x310>
    ef6c:	b.n	eabe <__ssvfscanf_r+0x24a>
    ef6e:	mov	r1, fp
    ef70:	mov	r0, sl
    ef72:	bl	122b8 <__ssrefill_r>
    ef76:	cmp	r0, #0
    ef78:	beq.w	ecb2 <__ssvfscanf_r+0x43e>
    ef7c:	b.n	eabe <__ssvfscanf_r+0x24a>
    ef7e:	mov	r1, fp
    ef80:	mov	r0, sl
    ef82:	bl	122b8 <__ssrefill_r>
    ef86:	cmp	r0, #0
    ef88:	beq.w	eb16 <__ssvfscanf_r+0x2a2>
    ef8c:	b.n	eabe <__ssvfscanf_r+0x24a>
    ef8e:	mov	r1, fp
    ef90:	mov	r0, sl
    ef92:	bl	122b8 <__ssrefill_r>
    ef96:	cmp	r0, #0
    ef98:	beq.w	eafe <__ssvfscanf_r+0x28a>
    ef9c:	b.n	eabe <__ssvfscanf_r+0x24a>
    ef9e:	cmp	r6, #3
    efa0:	beq.w	f2e2 <__ssvfscanf_r+0xa6e>
    efa4:	cmp	r6, #4
    efa6:	bne.w	f424 <__ssvfscanf_r+0xbb0>
    efaa:	mov	r0, sl
    efac:	bl	111e8 <_localeconv_r>
    efb0:	subs	r3, r4, #1
    efb2:	ldr	r2, [r0, #0]
    efb4:	str	r2, [sp, #48]	; 0x30
    efb6:	cmp.w	r3, #348	; 0x15c
    efba:	bls.w	f48c <__ssvfscanf_r+0xc18>
    efbe:	mvn.w	r1, #348	; 0x15c
    efc2:	adds	r3, r4, r1
    efc4:	str	r3, [sp, #56]	; 0x38
    efc6:	movw	r4, #349	; 0x15d
    efca:	add	r3, sp, #336	; 0x150
    efcc:	mov.w	r8, #0
    efd0:	mov	r2, r3
    efd2:	str	r3, [sp, #40]	; 0x28
    efd4:	orr.w	r5, r5, #1920	; 0x780
    efd8:	mov	r3, r8
    efda:	str.w	r8, [sp, #60]	; 0x3c
    efde:	str.w	r8, [sp, #52]	; 0x34
    efe2:	mov	r6, r8
    efe4:	str.w	r8, [sp, #44]	; 0x2c
    efe8:	mov	r9, r2
    efea:	ldr.w	r0, [fp]
    efee:	ldrb	r1, [r0, #0]
    eff0:	sub.w	lr, r1, #43	; 0x2b
    eff4:	cmp.w	lr, #78	; 0x4e
    eff8:	bhi.w	f292 <__ssvfscanf_r+0xa1e>
    effc:	tbh	[pc, lr, lsl #1]
    f000:	.word	0x0149007a
    f004:	.word	0x0149007a
    f008:	.word	0x006e0149
    f00c:	.word	0x004f004f
    f010:	.word	0x004f004f
    f014:	.word	0x004f004f
    f018:	.word	0x004f004f
    f01c:	.word	0x0149004f
    f020:	.word	0x01490149
    f024:	.word	0x01490149
    f028:	.word	0x01490149
    f02c:	.word	0x01490144
    f030:	.word	0x01490149
    f034:	.word	0x0125012c
    f038:	.word	0x01490149
    f03c:	.word	0x014900a2
    f040:	.word	0x01490149
    f044:	.word	0x008b0149
    f048:	.word	0x01490149
    f04c:	.word	0x01490149
    f050:	.word	0x00850149
    f054:	.word	0x01490149
    f058:	.word	0x01490149
    f05c:	.word	0x0149007f
    f060:	.word	0x01490149
    f064:	.word	0x01490149
    f068:	.word	0x01490149
    f06c:	.word	0x01490144
    f070:	.word	0x01490149
    f074:	.word	0x0125012c
    f078:	.word	0x01490149
    f07c:	.word	0x014900a2
    f080:	.word	0x01490149
    f084:	.word	0x008b0149
    f088:	.word	0x01490149
    f08c:	.word	0x01490149
    f090:	.word	0x00850149
    f094:	.word	0x01490149
    f098:	.word	0x01490149
    f09c:	.short	0x007f
    f09e:	cmn.w	r3, r8
    f0a2:	bne.n	f0d2 <__ssvfscanf_r+0x85e>
    f0a4:	bic.w	r5, r5, #384	; 0x180
    f0a8:	strb.w	r1, [r9]
    f0ac:	add.w	r9, r9, #1
    f0b0:	ldr.w	r1, [fp, #4]
    f0b4:	subs	r1, #1
    f0b6:	cmp	r1, #0
    f0b8:	add.w	r4, r4, #4294967295
    f0bc:	add.w	r7, r7, #1
    f0c0:	str.w	r1, [fp, #4]
    f0c4:	ble.w	f2ac <__ssvfscanf_r+0xa38>
    f0c8:	adds	r0, #1
    f0ca:	str.w	r0, [fp]
    f0ce:	cmp	r4, #0
    f0d0:	bne.n	efea <__ssvfscanf_r+0x776>
    f0d2:	cmp	r6, #0
    f0d4:	beq.n	f15c <__ssvfscanf_r+0x8e8>
    f0d6:	bic.w	r5, r5, #256	; 0x100
    f0da:	b.n	f15c <__ssvfscanf_r+0x8e8>
    f0dc:	lsls	r2, r5, #23
    f0de:	bpl.n	f09e <__ssvfscanf_r+0x82a>
    f0e0:	ldr	r2, [sp, #56]	; 0x38
    f0e2:	bic.w	r5, r5, #128	; 0x80
    f0e6:	adds	r6, #1
    f0e8:	cmp	r2, #0
    f0ea:	beq.n	f0b0 <__ssvfscanf_r+0x83c>
    f0ec:	subs	r2, #1
    f0ee:	str	r2, [sp, #56]	; 0x38
    f0f0:	adds	r4, #1
    f0f2:	b.n	f0b0 <__ssvfscanf_r+0x83c>
    f0f4:	lsls	r2, r5, #24
    f0f6:	bpl.n	f0d2 <__ssvfscanf_r+0x85e>
    f0f8:	bic.w	r5, r5, #128	; 0x80
    f0fc:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f0fe:	cmp.w	r8, #7
    f102:	bne.n	f0d2 <__ssvfscanf_r+0x85e>
    f104:	mov.w	r8, #8
    f108:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f10a:	cmp.w	r8, #6
    f10e:	bne.n	f0d2 <__ssvfscanf_r+0x85e>
    f110:	mov.w	r8, #7
    f114:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f116:	cmp	r3, #0
    f118:	bne.w	f2d8 <__ssvfscanf_r+0xa64>
    f11c:	cbnz	r6, f12a <__ssvfscanf_r+0x8b6>
    f11e:	and.w	lr, r5, #1792	; 0x700
    f122:	cmp.w	lr, #1792	; 0x700
    f126:	beq.w	f5b0 <__ssvfscanf_r+0xd3c>
    f12a:	cmp.w	r8, #1
    f12e:	beq.n	f136 <__ssvfscanf_r+0x8c2>
    f130:	cmp.w	r8, #4
    f134:	bne.n	f0d2 <__ssvfscanf_r+0x85e>
    f136:	add.w	r8, r8, #1
    f13a:	uxtb.w	r8, r8
    f13e:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f140:	.word	0x0000d169
    f144:	cmp.w	r8, #0
    f148:	bne.w	f2c6 <__ssvfscanf_r+0xa52>
    f14c:	cmp	r6, #0
    f14e:	bne.n	f0d6 <__ssvfscanf_r+0x862>
    f150:	and.w	lr, r5, #1792	; 0x700
    f154:	cmp.w	lr, #1792	; 0x700
    f158:	beq.w	f5d0 <__ssvfscanf_r+0xd5c>
    f15c:	subs	r3, #1
    f15e:	cmp	r3, #1
    f160:	bls.w	f666 <__ssvfscanf_r+0xdf2>
    f164:	add.w	r3, r8, #4294967295
    f168:	cmp	r3, #6
    f16a:	bhi.n	f19a <__ssvfscanf_r+0x926>
    f16c:	cmp.w	r8, #2
    f170:	bls.w	f6b4 <__ssvfscanf_r+0xe40>
    f174:	cmp.w	r8, #3
    f178:	beq.n	f19a <__ssvfscanf_r+0x926>
    f17a:	sub.w	r4, r8, #4
    f17e:	uxtb	r4, r4
    f180:	mvn.w	r8, r4
    f184:	add	r8, r9
    f186:	ldrb.w	r1, [r9, #-1]!
    f18a:	mov	r2, fp
    f18c:	mov	r0, sl
    f18e:	bl	12234 <_sungetc_r>
    f192:	cmp	r8, r9
    f194:	bne.n	f186 <__ssvfscanf_r+0x912>
    f196:	subs	r7, #1
    f198:	subs	r7, r7, r4
    f19a:	lsls	r1, r5, #23
    f19c:	bpl.n	f1d8 <__ssvfscanf_r+0x964>
    f19e:	lsls	r2, r5, #21
    f1a0:	bmi.w	f68a <__ssvfscanf_r+0xe16>
    f1a4:	ldrb.w	r1, [r9, #-1]
    f1a8:	cmp	r1, #101	; 0x65
    f1aa:	add.w	r4, r9, #4294967295
    f1ae:	add.w	r8, r7, #4294967295
    f1b2:	beq.n	f1cc <__ssvfscanf_r+0x958>
    f1b4:	cmp	r1, #69	; 0x45
    f1b6:	beq.n	f1cc <__ssvfscanf_r+0x958>
    f1b8:	mov	r2, fp
    f1ba:	mov	r0, sl
    f1bc:	bl	12234 <_sungetc_r>
    f1c0:	ldrb.w	r1, [r9, #-2]
    f1c4:	sub.w	r8, r7, #2
    f1c8:	sub.w	r4, r9, #2
    f1cc:	mov	r2, fp
    f1ce:	mov	r0, sl
    f1d0:	bl	12234 <_sungetc_r>
    f1d4:	mov	r7, r8
    f1d6:	mov	r9, r4
    f1d8:	ands.w	r2, r5, #16
    f1dc:	bne.w	ed3c <__ssvfscanf_r+0x4c8>
    f1e0:	and.w	r3, r5, #1536	; 0x600
    f1e4:	cmp.w	r3, #1024	; 0x400
    f1e8:	strb.w	r2, [r9]
    f1ec:	beq.w	f5da <__ssvfscanf_r+0xd66>
    f1f0:	ldr	r3, [sp, #52]	; 0x34
    f1f2:	cmp	r3, #0
    f1f4:	bne.w	f5fc <__ssvfscanf_r+0xd88>
    f1f8:	ldr	r1, [sp, #40]	; 0x28
    f1fa:	movs	r2, #0
    f1fc:	mov	r0, sl
    f1fe:	bl	d010 <_strtod_r>
    f202:	lsls	r3, r5, #31
    f204:	bmi.w	f492 <__ssvfscanf_r+0xc1e>
    f208:	ands.w	r5, r5, #2
    f20c:	bne.w	f492 <__ssvfscanf_r+0xc1e>
    f210:	vmov	r2, r3, d0
    f214:	vmov	r0, r1, d0
    f218:	vstr	d0, [sp, #32]
    f21c:	bl	ae14 <__aeabi_dcmpun>
    f220:	ldr	r4, [sp, #20]
    f222:	vldr	d0, [sp, #32]
    f226:	adds	r6, r4, #4
    f228:	ldr	r4, [r4, #0]
    f22a:	cmp	r0, #0
    f22c:	bne.w	f6e8 <__ssvfscanf_r+0xe74>
    f230:	vmov	r0, r1, d0
    f234:	bl	aed0 <__aeabi_d2f>
    f238:	str	r6, [sp, #20]
    f23a:	str	r0, [r4, #0]
    f23c:	ldr	r3, [sp, #24]
    f23e:	ldr	r6, [sp, #12]
    f240:	adds	r3, #1
    f242:	str	r3, [sp, #24]
    f244:	mov	r4, r6
    f246:	b.w	e904 <__ssvfscanf_r+0x90>
    f24a:	cmp.w	r8, #2
    f24e:	bne.w	f0d2 <__ssvfscanf_r+0x85e>
    f252:	mov.w	r8, #3
    f256:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f258:	and.w	lr, r5, #1280	; 0x500
    f25c:	cmp.w	lr, #1024	; 0x400
    f260:	beq.n	f26e <__ssvfscanf_r+0x9fa>
    f262:	lsls	r2, r5, #21
    f264:	bpl.w	f0d2 <__ssvfscanf_r+0x85e>
    f268:	cmp	r6, #0
    f26a:	beq.w	f15c <__ssvfscanf_r+0x8e8>
    f26e:	lsls	r2, r5, #22
    f270:	bmi.n	f27c <__ssvfscanf_r+0xa08>
    f272:	ldr	r2, [sp, #44]	; 0x2c
    f274:	str.w	r9, [sp, #60]	; 0x3c
    f278:	subs	r2, r6, r2
    f27a:	str	r2, [sp, #52]	; 0x34
    f27c:	bic.w	r5, r5, #1920	; 0x780
    f280:	orr.w	r5, r5, #384	; 0x180
    f284:	movs	r6, #0
    f286:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f288:	cmp	r3, #1
    f28a:	bne.w	f0d2 <__ssvfscanf_r+0x85e>
    f28e:	movs	r3, #2
    f290:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f292:	ldr	r2, [sp, #48]	; 0x30
    f294:	ldrb.w	lr, [r2]
    f298:	cmp	lr, r1
    f29a:	bne.w	f0d2 <__ssvfscanf_r+0x85e>
    f29e:	lsls	r2, r5, #22
    f2a0:	bpl.w	f0d2 <__ssvfscanf_r+0x85e>
    f2a4:	bic.w	r5, r5, #640	; 0x280
    f2a8:	str	r6, [sp, #44]	; 0x2c
    f2aa:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f2ac:	mov	r1, fp
    f2ae:	mov	r0, sl
    f2b0:	str	r3, [sp, #32]
    f2b2:	bl	122b8 <__ssrefill_r>
    f2b6:	ldr	r3, [sp, #32]
    f2b8:	cmp	r0, #0
    f2ba:	bne.w	f0d2 <__ssvfscanf_r+0x85e>
    f2be:	cmp	r4, #0
    f2c0:	bne.w	efea <__ssvfscanf_r+0x776>
    f2c4:	b.n	f0d2 <__ssvfscanf_r+0x85e>
    f2c6:	cmp.w	r8, #3
    f2ca:	beq.w	f136 <__ssvfscanf_r+0x8c2>
    f2ce:	cmp.w	r8, #5
    f2d2:	beq.w	f136 <__ssvfscanf_r+0x8c2>
    f2d6:	b.n	f0d2 <__ssvfscanf_r+0x85e>
    f2d8:	cmp	r3, #2
    f2da:	bne.w	f12a <__ssvfscanf_r+0x8b6>
    f2de:	movs	r3, #3
    f2e0:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f2e2:	subs	r3, r4, #1
    f2e4:	cmp.w	r3, #348	; 0x15c
    f2e8:	itte	hi
    f2ea:	mvnhi.w	r0, #348	; 0x15c
    f2ee:	addhi.w	r9, r4, r0
    f2f2:	movls	r9, r8
    f2f4:	add	r3, sp, #336	; 0x150
    f2f6:	mov	r0, r2
    f2f8:	mov	r2, r7
    f2fa:	mov	r7, r9
    f2fc:	ldr.w	r9, [sp, #16]
    f300:	str	r3, [sp, #40]	; 0x28
    f302:	it	hi
    f304:	movwhi	r4, #349	; 0x15d
    f308:	orr.w	r5, r5, #3456	; 0xd80
    f30c:	mov	r6, r3
    f30e:	mov.w	r8, #0
    f312:	sub.w	r3, r1, #43	; 0x2b
    f316:	cmp	r3, #77	; 0x4d
    f318:	bhi.n	f3be <__ssvfscanf_r+0xb4a>
    f31a:	tbb	[pc, r3]
    f31e:	.short	0x507e
    f320:	.word	0x6f50507e
    f324:	.word	0x69696969
    f328:	.word	0x4a696969
    f32c:	.word	0x5050504a
    f330:	.word	0x50505050
    f334:	.word	0x44444444
    f338:	.word	0x50504444
    f33c:	.word	0x50505050
    f340:	.word	0x50505050
    f344:	.word	0x50505050
    f348:	.word	0x27505050
    f34c:	.word	0x50505050
    f350:	.word	0x50505050
    f354:	.word	0x44444444
    f358:	.word	0x50504444
    f35c:	.word	0x50505050
    f360:	.word	0x50505050
    f364:	.word	0x50505050
    f368:	.word	0x27505050
    f36c:	and.w	r3, r5, #1536	; 0x600
    f370:	cmp.w	r3, #512	; 0x200
    f374:	bne.n	f3be <__ssvfscanf_r+0xb4a>
    f376:	bic.w	r5, r5, #512	; 0x200
    f37a:	orr.w	r5, r5, #1280	; 0x500
    f37e:	mov.w	r9, #16
    f382:	strb	r1, [r6, #0]
    f384:	adds	r6, #1
    f386:	ldr.w	r3, [fp, #4]
    f38a:	subs	r3, #1
    f38c:	cmp	r3, #0
    f38e:	str.w	r3, [fp, #4]
    f392:	ble.n	f47a <__ssvfscanf_r+0xc06>
    f394:	adds	r0, #1
    f396:	str.w	r0, [fp]
    f39a:	subs	r4, #1
    f39c:	beq.n	f3be <__ssvfscanf_r+0xb4a>
    f39e:	ldr.w	r0, [fp]
    f3a2:	ldrb	r1, [r0, #0]
    f3a4:	b.n	f312 <__ssvfscanf_r+0xa9e>
    f3a6:	cmp.w	r9, #10
    f3aa:	ble.n	f3be <__ssvfscanf_r+0xb4a>
    f3ac:	bic.w	r5, r5, #2944	; 0xb80
    f3b0:	b.n	f382 <__ssvfscanf_r+0xb0e>
    f3b2:	ldr	r3, [pc, #756]	; (f6a8 <__ssvfscanf_r+0xe34>)
    f3b4:	ldrsh.w	r9, [r3, r9, lsl #1]
    f3b8:	cmp.w	r9, #8
    f3bc:	bgt.n	f3ac <__ssvfscanf_r+0xb38>
    f3be:	lsls	r1, r5, #23
    f3c0:	mov	r7, r2
    f3c2:	str.w	r9, [sp, #16]
    f3c6:	bpl.n	f3d8 <__ssvfscanf_r+0xb64>
    f3c8:	ldr	r3, [sp, #40]	; 0x28
    f3ca:	cmp	r6, r3
    f3cc:	bhi.w	f5b8 <__ssvfscanf_r+0xd44>
    f3d0:	ldr	r3, [sp, #40]	; 0x28
    f3d2:	cmp	r6, r3
    f3d4:	beq.w	e910 <__ssvfscanf_r+0x9c>
    f3d8:	ands.w	r4, r5, #16
    f3dc:	beq.w	f504 <__ssvfscanf_r+0xc90>
    f3e0:	ldr	r3, [sp, #40]	; 0x28
    f3e2:	subs	r6, r6, r3
    f3e4:	add	r6, r8
    f3e6:	add	r7, r6
    f3e8:	ldr	r6, [sp, #12]
    f3ea:	mov	r4, r6
    f3ec:	b.w	e904 <__ssvfscanf_r+0x90>
    f3f0:	ldr	r3, [pc, #692]	; (f6a8 <__ssvfscanf_r+0xe34>)
    f3f2:	bic.w	r5, r5, #2944	; 0xb80
    f3f6:	ldrsh.w	r9, [r3, r9, lsl #1]
    f3fa:	b.n	f382 <__ssvfscanf_r+0xb0e>
    f3fc:	lsls	r3, r5, #20
    f3fe:	bpl.n	f382 <__ssvfscanf_r+0xb0e>
    f400:	cmp.w	r9, #0
    f404:	bne.n	f40e <__ssvfscanf_r+0xb9a>
    f406:	orr.w	r5, r5, #512	; 0x200
    f40a:	mov.w	r9, #8
    f40e:	lsls	r3, r5, #21
    f410:	bpl.w	f594 <__ssvfscanf_r+0xd20>
    f414:	bic.w	r5, r5, #1408	; 0x580
    f418:	b.n	f382 <__ssvfscanf_r+0xb0e>
    f41a:	lsls	r3, r5, #24
    f41c:	bpl.n	f3be <__ssvfscanf_r+0xb4a>
    f41e:	bic.w	r5, r5, #128	; 0x80
    f422:	b.n	f382 <__ssvfscanf_r+0xb0e>
    f424:	cmp	r4, #0
    f426:	it	eq
    f428:	moveq.w	r4, #4294967295
    f42c:	ands.w	r3, r5, #1
    f430:	bne.w	ecf0 <__ssvfscanf_r+0x47c>
    f434:	lsls	r1, r5, #27
    f436:	bpl.n	f4a0 <__ssvfscanf_r+0xc2c>
    f438:	mov	r5, r3
    f43a:	bl	b32c <__locale_ctype_ptr>
    f43e:	ldr.w	r3, [fp]
    f442:	ldrb	r2, [r3, #0]
    f444:	add	r0, r2
    f446:	adds	r3, #1
    f448:	ldrb	r2, [r0, #1]
    f44a:	lsls	r2, r2, #28
    f44c:	bmi.w	ebce <__ssvfscanf_r+0x35a>
    f450:	ldr.w	r2, [fp, #4]
    f454:	str.w	r3, [fp]
    f458:	adds	r5, #1
    f45a:	subs	r3, r2, #1
    f45c:	cmp	r4, r5
    f45e:	str.w	r3, [fp, #4]
    f462:	beq.w	ebce <__ssvfscanf_r+0x35a>
    f466:	cmp	r3, #0
    f468:	bgt.n	f43a <__ssvfscanf_r+0xbc6>
    f46a:	mov	r1, fp
    f46c:	mov	r0, sl
    f46e:	bl	122b8 <__ssrefill_r>
    f472:	cmp	r0, #0
    f474:	beq.n	f43a <__ssvfscanf_r+0xbc6>
    f476:	b.w	ebce <__ssvfscanf_r+0x35a>
    f47a:	mov	r1, fp
    f47c:	mov	r0, sl
    f47e:	str	r2, [sp, #16]
    f480:	bl	122b8 <__ssrefill_r>
    f484:	ldr	r2, [sp, #16]
    f486:	cmp	r0, #0
    f488:	beq.n	f39a <__ssvfscanf_r+0xb26>
    f48a:	b.n	f3be <__ssvfscanf_r+0xb4a>
    f48c:	str.w	r8, [sp, #56]	; 0x38
    f490:	b.n	efca <__ssvfscanf_r+0x756>
    f492:	ldr	r2, [sp, #20]
    f494:	ldr	r3, [r2, #0]
    f496:	adds	r2, #4
    f498:	str	r2, [sp, #20]
    f49a:	vstr	d0, [r3]
    f49e:	b.n	f23c <__ssvfscanf_r+0x9c8>
    f4a0:	ldr	r2, [sp, #20]
    f4a2:	ldr	r5, [r2, #0]
    f4a4:	adds	r6, r2, #4
    f4a6:	add	r4, r5
    f4a8:	mov	r8, r5
    f4aa:	bl	b32c <__locale_ctype_ptr>
    f4ae:	ldr.w	r2, [fp]
    f4b2:	ldrb	r3, [r2, #0]
    f4b4:	add	r0, r3
    f4b6:	adds	r1, r2, #1
    f4b8:	ldrb	r3, [r0, #1]
    f4ba:	lsls	r3, r3, #28
    f4bc:	bmi.n	f4ea <__ssvfscanf_r+0xc76>
    f4be:	ldr.w	r3, [fp, #4]
    f4c2:	str.w	r1, [fp]
    f4c6:	subs	r3, #1
    f4c8:	str.w	r3, [fp, #4]
    f4cc:	ldrb	r3, [r2, #0]
    f4ce:	strb.w	r3, [r8], #1
    f4d2:	cmp	r4, r8
    f4d4:	beq.n	f4ec <__ssvfscanf_r+0xc78>
    f4d6:	ldr.w	r3, [fp, #4]
    f4da:	cmp	r3, #0
    f4dc:	bgt.n	f4aa <__ssvfscanf_r+0xc36>
    f4de:	mov	r1, fp
    f4e0:	mov	r0, sl
    f4e2:	bl	122b8 <__ssrefill_r>
    f4e6:	cmp	r0, #0
    f4e8:	beq.n	f4aa <__ssvfscanf_r+0xc36>
    f4ea:	mov	r4, r8
    f4ec:	ldr	r2, [sp, #24]
    f4ee:	str	r6, [sp, #20]
    f4f0:	ldr	r6, [sp, #12]
    f4f2:	subs	r5, r4, r5
    f4f4:	movs	r3, #0
    f4f6:	adds	r2, #1
    f4f8:	strb	r3, [r4, #0]
    f4fa:	add	r7, r5
    f4fc:	str	r2, [sp, #24]
    f4fe:	mov	r4, r6
    f500:	b.w	e904 <__ssvfscanf_r+0x90>
    f504:	mov	r2, r4
    f506:	strb	r4, [r6, #0]
    f508:	ldr	r3, [sp, #16]
    f50a:	ldr	r1, [sp, #40]	; 0x28
    f50c:	ldr	r4, [sp, #28]
    f50e:	mov	r0, sl
    f510:	blx	r4
    f512:	lsls	r2, r5, #26
    f514:	bmi.n	f5a4 <__ssvfscanf_r+0xd30>
    f516:	lsls	r3, r5, #29
    f518:	bpl.n	f612 <__ssvfscanf_r+0xd9e>
    f51a:	ldr	r2, [sp, #20]
    f51c:	ldr	r3, [r2, #0]
    f51e:	adds	r2, #4
    f520:	str	r2, [sp, #20]
    f522:	strh	r0, [r3, #0]
    f524:	ldr	r3, [sp, #24]
    f526:	adds	r3, #1
    f528:	str	r3, [sp, #24]
    f52a:	b.n	f3e0 <__ssvfscanf_r+0xb6c>
    f52c:	bl	b308 <__locale_mb_cur_max>
    f530:	cmp	r6, r0
    f532:	beq.w	eabe <__ssvfscanf_r+0x24a>
    f536:	ldmia.w	fp, {r2, r3}
    f53a:	ldrb.w	r0, [r2], #1
    f53e:	str.w	r2, [fp]
    f542:	ldr	r2, [sp, #32]
    f544:	str	r2, [sp, #0]
    f546:	add	r2, sp, #336	; 0x150
    f548:	adds	r5, r6, #1
    f54a:	subs	r3, #1
    f54c:	strb	r0, [r2, r6]
    f54e:	str.w	r3, [fp, #4]
    f552:	mov	r1, r8
    f554:	mov	r3, r5
    f556:	mov	r0, sl
    f558:	bl	11204 <_mbrtowc_r>
    f55c:	adds	r6, r0, #1
    f55e:	beq.w	eabe <__ssvfscanf_r+0x24a>
    f562:	cmp	r0, #0
    f564:	bne.n	f63e <__ssvfscanf_r+0xdca>
    f566:	str.w	r0, [r8]
    f56a:	bl	111c8 <iswspace>
    f56e:	cmp	r0, #0
    f570:	beq.w	f6d2 <__ssvfscanf_r+0xe5e>
    f574:	cmp	r5, #0
    f576:	beq.w	ed2c <__ssvfscanf_r+0x4b8>
    f57a:	add	r3, sp, #336	; 0x150
    f57c:	adds	r4, r3, r5
    f57e:	subs	r5, #1
    f580:	mov	r2, fp
    f582:	ldrb.w	r1, [r4, #-1]!
    f586:	mov	r0, sl
    f588:	bl	12234 <_sungetc_r>
    f58c:	cmp	r5, #0
    f58e:	bne.n	f57e <__ssvfscanf_r+0xd0a>
    f590:	b.w	ed2c <__ssvfscanf_r+0x4b8>
    f594:	bic.w	r5, r5, #896	; 0x380
    f598:	cbz	r7, f59e <__ssvfscanf_r+0xd2a>
    f59a:	subs	r7, #1
    f59c:	adds	r4, #1
    f59e:	add.w	r8, r8, #1
    f5a2:	b.n	f386 <__ssvfscanf_r+0xb12>
    f5a4:	ldr	r2, [sp, #20]
    f5a6:	ldr	r3, [r2, #0]
    f5a8:	adds	r2, #4
    f5aa:	str	r2, [sp, #20]
    f5ac:	str	r0, [r3, #0]
    f5ae:	b.n	f524 <__ssvfscanf_r+0xcb0>
    f5b0:	bic.w	r5, r5, #1920	; 0x780
    f5b4:	movs	r3, #1
    f5b6:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f5b8:	ldrb.w	r1, [r6, #-1]
    f5bc:	mov	r2, fp
    f5be:	mov	r0, sl
    f5c0:	bl	12234 <_sungetc_r>
    f5c4:	subs	r6, #1
    f5c6:	b.n	f3d0 <__ssvfscanf_r+0xb5c>
    f5c8:	add.w	r8, sp, #68	; 0x44
    f5cc:	b.w	ed12 <__ssvfscanf_r+0x49e>
    f5d0:	bic.w	r5, r5, #1920	; 0x780
    f5d4:	mov.w	r8, #1
    f5d8:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f5da:	ldr	r3, [sp, #44]	; 0x2c
    f5dc:	subs	r6, r6, r3
    f5de:	negs	r2, r6
    f5e0:	cmp	r6, #0
    f5e2:	beq.w	f1f8 <__ssvfscanf_r+0x984>
    f5e6:	addw	r3, sp, #675	; 0x2a3
    f5ea:	cmp	r9, r3
    f5ec:	it	cs
    f5ee:	addwcs	r9, sp, #674	; 0x2a2
    f5f2:	mov	r0, r9
    f5f4:	ldr	r1, [pc, #180]	; (f6ac <__ssvfscanf_r+0xe38>)
    f5f6:	bl	bed8 <sprintf>
    f5fa:	b.n	f1f8 <__ssvfscanf_r+0x984>
    f5fc:	ldr	r4, [sp, #60]	; 0x3c
    f5fe:	mov	r1, r4
    f600:	movs	r3, #10
    f602:	adds	r1, #1
    f604:	mov	r0, sl
    f606:	bl	d168 <_strtol_r>
    f60a:	ldr	r3, [sp, #52]	; 0x34
    f60c:	mov	r9, r4
    f60e:	subs	r2, r0, r3
    f610:	b.n	f5e6 <__ssvfscanf_r+0xd72>
    f612:	ands.w	r2, r5, #1
    f616:	bne.n	f5a4 <__ssvfscanf_r+0xd30>
    f618:	lsls	r4, r5, #30
    f61a:	bpl.n	f5a4 <__ssvfscanf_r+0xd30>
    f61c:	ldr	r3, [sp, #28]
    f61e:	mov	r1, r3
    f620:	ldr	r3, [pc, #140]	; (f6b0 <__ssvfscanf_r+0xe3c>)
    f622:	cmp	r1, r3
    f624:	mov	r0, sl
    f626:	ldr	r3, [sp, #16]
    f628:	ldr	r1, [sp, #40]	; 0x28
    f62a:	beq.n	f6f6 <__ssvfscanf_r+0xe82>
    f62c:	bl	11d74 <_strtoll_r>
    f630:	ldr	r2, [sp, #20]
    f632:	ldr	r3, [r2, #0]
    f634:	adds	r2, #4
    f636:	str	r2, [sp, #20]
    f638:	strd	r0, r1, [r3]
    f63c:	b.n	f524 <__ssvfscanf_r+0xcb0>
    f63e:	adds	r0, #2
    f640:	bne.n	f684 <__ssvfscanf_r+0xe10>
    f642:	mov	r6, r5
    f644:	ldr.w	r3, [fp, #4]
    f648:	cmp	r3, #0
    f64a:	bgt.w	ed14 <__ssvfscanf_r+0x4a0>
    f64e:	mov	r1, fp
    f650:	mov	r0, sl
    f652:	bl	122b8 <__ssrefill_r>
    f656:	cmp	r0, #0
    f658:	beq.w	ed14 <__ssvfscanf_r+0x4a0>
    f65c:	cmp	r6, #0
    f65e:	bne.w	eabe <__ssvfscanf_r+0x24a>
    f662:	b.w	ed2c <__ssvfscanf_r+0x4b8>
    f666:	ldr	r3, [sp, #40]	; 0x28
    f668:	cmp	r9, r3
    f66a:	bls.w	e910 <__ssvfscanf_r+0x9c>
    f66e:	ldrb.w	r1, [r9, #-1]!
    f672:	mov	r2, fp
    f674:	mov	r0, sl
    f676:	bl	12234 <_sungetc_r>
    f67a:	ldr	r3, [sp, #40]	; 0x28
    f67c:	cmp	r9, r3
    f67e:	bne.n	f66e <__ssvfscanf_r+0xdfa>
    f680:	b.w	e910 <__ssvfscanf_r+0x9c>
    f684:	ldr.w	r0, [r8]
    f688:	b.n	f56a <__ssvfscanf_r+0xcf6>
    f68a:	ldr	r3, [sp, #40]	; 0x28
    f68c:	cmp	r9, r3
    f68e:	bls.w	e910 <__ssvfscanf_r+0x9c>
    f692:	ldrb.w	r1, [r9, #-1]!
    f696:	mov	r2, fp
    f698:	mov	r0, sl
    f69a:	bl	12234 <_sungetc_r>
    f69e:	ldr	r3, [sp, #40]	; 0x28
    f6a0:	cmp	r9, r3
    f6a2:	bne.n	f692 <__ssvfscanf_r+0xe1e>
    f6a4:	b.w	e910 <__ssvfscanf_r+0x9c>
    f6a8:	.word	0x000131e4
    f6ac:	.word	0x00013208
    f6b0:	.word	0x00011f01
    f6b4:	ldr	r3, [sp, #40]	; 0x28
    f6b6:	cmp	r9, r3
    f6b8:	bls.w	e910 <__ssvfscanf_r+0x9c>
    f6bc:	ldrb.w	r1, [r9, #-1]!
    f6c0:	mov	r2, fp
    f6c2:	mov	r0, sl
    f6c4:	bl	12234 <_sungetc_r>
    f6c8:	ldr	r3, [sp, #40]	; 0x28
    f6ca:	cmp	r9, r3
    f6cc:	bne.n	f6bc <__ssvfscanf_r+0xe48>
    f6ce:	b.w	e910 <__ssvfscanf_r+0x9c>
    f6d2:	add	r7, r5
    f6d4:	subs	r4, #1
    f6d6:	cmp.w	r9, #0
    f6da:	bne.n	f6e4 <__ssvfscanf_r+0xe70>
    f6dc:	add.w	r8, r8, #4
    f6e0:	mov	r6, r9
    f6e2:	b.n	f644 <__ssvfscanf_r+0xdd0>
    f6e4:	mov	r6, r0
    f6e6:	b.n	f644 <__ssvfscanf_r+0xdd0>
    f6e8:	mov	r0, r5
    f6ea:	bl	11bbc <nanf>
    f6ee:	str	r6, [sp, #20]
    f6f0:	vstr	s0, [r4]
    f6f4:	b.n	f23c <__ssvfscanf_r+0x9c8>
    f6f6:	bl	12110 <_strtoull_r>
    f6fa:	b.n	f630 <__ssvfscanf_r+0xdbc>

0000f6fc <_vdprintf_r>:
    f6fc:	push	{r4, r5, r6, r7, lr}
    f6fe:	sub.w	sp, sp, #532	; 0x214
    f702:	add	r5, sp, #16
    f704:	str	r3, [sp, #0]
    f706:	mov	r7, r1
    f708:	mov	r3, r2
    f70a:	mov.w	r4, #512	; 0x200
    f70e:	add	r2, sp, #12
    f710:	mov	r1, r5
    f712:	str	r4, [sp, #12]
    f714:	mov	r6, r0
    f716:	bl	123f0 <_vasnprintf_r>
    f71a:	cbz	r0, f740 <_vdprintf_r+0x44>
    f71c:	mov	r4, r0
    f71e:	mov	r2, r0
    f720:	mov	r1, r7
    f722:	ldr	r3, [sp, #12]
    f724:	mov	r0, r6
    f726:	bl	f77c <_write_r>
    f72a:	cmp	r4, r5
    f72c:	str	r0, [sp, #12]
    f72e:	beq.n	f73a <_vdprintf_r+0x3e>
    f730:	mov	r0, r6
    f732:	mov	r1, r4
    f734:	bl	10890 <_free_r>
    f738:	ldr	r0, [sp, #12]
    f73a:	add.w	sp, sp, #532	; 0x214
    f73e:	pop	{r4, r5, r6, r7, pc}
    f740:	mov.w	r0, #4294967295
    f744:	b.n	f73a <_vdprintf_r+0x3e>
    f746:	nop

0000f748 <vdprintf>:
    f748:	push	{r4}
    f74a:	ldr	r4, [pc, #16]	; (f75c <vdprintf+0x14>)
    f74c:	mov	r3, r2
    f74e:	mov	r2, r1
    f750:	mov	r1, r0
    f752:	ldr	r0, [r4, #0]
    f754:	ldr.w	r4, [sp], #4
    f758:	b.w	f6fc <_vdprintf_r>
    f75c:	.word	0x1fff1828

0000f760 <__ascii_wctomb>:
    f760:	cbz	r1, f76c <__ascii_wctomb+0xc>
    f762:	cmp	r2, #255	; 0xff
    f764:	bhi.n	f770 <__ascii_wctomb+0x10>
    f766:	strb	r2, [r1, #0]
    f768:	movs	r0, #1
    f76a:	bx	lr
    f76c:	mov	r0, r1
    f76e:	bx	lr
    f770:	movs	r3, #138	; 0x8a
    f772:	str	r3, [r0, #0]
    f774:	mov.w	r0, #4294967295
    f778:	bx	lr
    f77a:	nop

0000f77c <_write_r>:
    f77c:	push	{r4, r5, r6, lr}
    f77e:	mov	r5, r1
    f780:	ldr	r4, [pc, #32]	; (f7a4 <_write_r+0x28>)
    f782:	mov	r1, r2
    f784:	mov	r6, r0
    f786:	mov	r2, r3
    f788:	mov	r0, r5
    f78a:	movs	r3, #0
    f78c:	str	r3, [r4, #0]
    f78e:	bl	2580 <_write>
    f792:	adds	r3, r0, #1
    f794:	beq.n	f798 <_write_r+0x1c>
    f796:	pop	{r4, r5, r6, pc}
    f798:	ldr	r3, [r4, #0]
    f79a:	cmp	r3, #0
    f79c:	beq.n	f796 <_write_r+0x1a>
    f79e:	str	r3, [r6, #0]
    f7a0:	pop	{r4, r5, r6, pc}
    f7a2:	nop
    f7a4:	.word	0x2001a85c

0000f7a8 <__register_exitproc>:
    f7a8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    f7ac:	ldr	r4, [pc, #148]	; (f844 <__register_exitproc+0x9c>)
    f7ae:	ldr	r5, [r4, #0]
    f7b0:	ldr.w	r4, [r5, #328]	; 0x148
    f7b4:	mov	r6, r0
    f7b6:	mov	r8, r1
    f7b8:	mov	sl, r2
    f7ba:	mov	r9, r3
    f7bc:	cbz	r4, f830 <__register_exitproc+0x88>
    f7be:	ldr	r0, [r4, #4]
    f7c0:	cmp	r0, #31
    f7c2:	bgt.n	f7f4 <__register_exitproc+0x4c>
    f7c4:	adds	r3, r0, #1
    f7c6:	cbz	r6, f7e6 <__register_exitproc+0x3e>
    f7c8:	add.w	r5, r4, r0, lsl #2
    f7cc:	movs	r2, #1
    f7ce:	str.w	sl, [r5, #136]	; 0x88
    f7d2:	ldr.w	r1, [r4, #392]	; 0x188
    f7d6:	lsls	r2, r0
    f7d8:	orrs	r1, r2
    f7da:	cmp	r6, #2
    f7dc:	str.w	r1, [r4, #392]	; 0x188
    f7e0:	str.w	r9, [r5, #264]	; 0x108
    f7e4:	beq.n	f824 <__register_exitproc+0x7c>
    f7e6:	adds	r0, #2
    f7e8:	str	r3, [r4, #4]
    f7ea:	str.w	r8, [r4, r0, lsl #2]
    f7ee:	movs	r0, #0
    f7f0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f7f4:	ldr	r3, [pc, #80]	; (f848 <__register_exitproc+0xa0>)
    f7f6:	cbz	r3, f83a <__register_exitproc+0x92>
    f7f8:	mov.w	r0, #400	; 0x190
    f7fc:	bl	b340 <malloc>
    f800:	mov	r4, r0
    f802:	cbz	r0, f83a <__register_exitproc+0x92>
    f804:	ldr.w	r3, [r5, #328]	; 0x148
    f808:	movs	r7, #0
    f80a:	stmia.w	r0, {r3, r7}
    f80e:	str.w	r4, [r5, #328]	; 0x148
    f812:	mov	r0, r7
    f814:	movs	r3, #1
    f816:	str.w	r7, [r4, #392]	; 0x188
    f81a:	str.w	r7, [r4, #396]	; 0x18c
    f81e:	cmp	r6, #0
    f820:	beq.n	f7e6 <__register_exitproc+0x3e>
    f822:	b.n	f7c8 <__register_exitproc+0x20>
    f824:	ldr.w	r1, [r4, #396]	; 0x18c
    f828:	orrs	r2, r1
    f82a:	str.w	r2, [r4, #396]	; 0x18c
    f82e:	b.n	f7e6 <__register_exitproc+0x3e>
    f830:	add.w	r4, r5, #332	; 0x14c
    f834:	str.w	r4, [r5, #328]	; 0x148
    f838:	b.n	f7be <__register_exitproc+0x16>
    f83a:	mov.w	r0, #4294967295
    f83e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f842:	nop
    f844:	.word	0x0001310c
    f848:	.word	0x0000b341

0000f84c <register_fini>:
    f84c:	ldr	r3, [pc, #8]	; (f858 <register_fini+0xc>)
    f84e:	cbz	r3, f856 <register_fini+0xa>
    f850:	ldr	r0, [pc, #8]	; (f85c <register_fini+0x10>)
    f852:	b.w	f860 <atexit>
    f856:	bx	lr
    f858:	.word	0x00000000
    f85c:	.word	0x000107cd

0000f860 <atexit>:
    f860:	movs	r3, #0
    f862:	mov	r1, r0
    f864:	mov	r2, r3
    f866:	mov	r0, r3
    f868:	b.w	f7a8 <__register_exitproc>

0000f86c <quorem>:
    f86c:	ldr	r2, [r0, #16]
    f86e:	ldr	r3, [r1, #16]
    f870:	cmp	r3, r2
    f872:	bgt.w	f990 <quorem+0x124>
    f876:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f87a:	add.w	r8, r3, #4294967295
    f87e:	add.w	r7, r1, #20
    f882:	add.w	fp, r0, #20
    f886:	ldr.w	r2, [r7, r8, lsl #2]
    f88a:	ldr.w	r3, [fp, r8, lsl #2]
    f88e:	mov.w	r4, r8, lsl #2
    f892:	sub	sp, #12
    f894:	adds	r2, #1
    f896:	udiv	r9, r3, r2
    f89a:	add.w	r3, fp, r4
    f89e:	str	r4, [sp, #0]
    f8a0:	add.w	sl, r7, r4
    f8a4:	str	r3, [sp, #4]
    f8a6:	cmp.w	r9, #0
    f8aa:	beq.n	f920 <quorem+0xb4>
    f8ac:	movs	r5, #0
    f8ae:	mov	ip, r7
    f8b0:	mov	lr, fp
    f8b2:	mov	r3, r5
    f8b4:	ldr.w	r6, [ip], #4
    f8b8:	ldr.w	r2, [lr]
    f8bc:	uxth	r4, r6
    f8be:	mla	r5, r9, r4, r5
    f8c2:	lsrs	r6, r6, #16
    f8c4:	lsrs	r4, r5, #16
    f8c6:	mla	r4, r9, r6, r4
    f8ca:	uxth	r5, r5
    f8cc:	subs	r3, r3, r5
    f8ce:	uxth	r6, r4
    f8d0:	uxtah	r3, r3, r2
    f8d4:	rsb	r6, r6, r2, lsr #16
    f8d8:	add.w	r6, r6, r3, asr #16
    f8dc:	uxth	r3, r3
    f8de:	orr.w	r3, r3, r6, lsl #16
    f8e2:	cmp	sl, ip
    f8e4:	str.w	r3, [lr], #4
    f8e8:	mov.w	r5, r4, lsr #16
    f8ec:	mov.w	r3, r6, asr #16
    f8f0:	bcs.n	f8b4 <quorem+0x48>
    f8f2:	ldr	r3, [sp, #0]
    f8f4:	ldr.w	r3, [fp, r3]
    f8f8:	cbnz	r3, f920 <quorem+0xb4>
    f8fa:	ldr	r4, [sp, #4]
    f8fc:	subs	r3, r4, #4
    f8fe:	cmp	fp, r3
    f900:	bcs.n	f91c <quorem+0xb0>
    f902:	ldr.w	r3, [r4, #-4]
    f906:	cbnz	r3, f91c <quorem+0xb0>
    f908:	sub.w	r3, r4, #8
    f90c:	b.n	f914 <quorem+0xa8>
    f90e:	ldr	r2, [r3, #0]
    f910:	subs	r3, #4
    f912:	cbnz	r2, f91c <quorem+0xb0>
    f914:	cmp	fp, r3
    f916:	add.w	r8, r8, #4294967295
    f91a:	bcc.n	f90e <quorem+0xa2>
    f91c:	str.w	r8, [r0, #16]
    f920:	mov	r4, r0
    f922:	bl	11708 <__mcmp>
    f926:	cmp	r0, #0
    f928:	blt.n	f988 <quorem+0x11c>
    f92a:	add.w	r9, r9, #1
    f92e:	mov	r5, fp
    f930:	movs	r3, #0
    f932:	ldr.w	r1, [r7], #4
    f936:	ldr	r0, [r5, #0]
    f938:	uxth	r2, r1
    f93a:	subs	r2, r3, r2
    f93c:	lsrs	r1, r1, #16
    f93e:	uxtah	r2, r2, r0
    f942:	rsb	r3, r1, r0, lsr #16
    f946:	add.w	r3, r3, r2, asr #16
    f94a:	uxth	r1, r2
    f94c:	orr.w	r1, r1, r3, lsl #16
    f950:	cmp	sl, r7
    f952:	str.w	r1, [r5], #4
    f956:	mov.w	r3, r3, asr #16
    f95a:	bcs.n	f932 <quorem+0xc6>
    f95c:	ldr.w	r2, [fp, r8, lsl #2]
    f960:	add.w	r3, fp, r8, lsl #2
    f964:	cbnz	r2, f988 <quorem+0x11c>
    f966:	subs	r2, r3, #4
    f968:	cmp	fp, r2
    f96a:	bcs.n	f984 <quorem+0x118>
    f96c:	ldr.w	r2, [r3, #-4]
    f970:	cbnz	r2, f984 <quorem+0x118>
    f972:	subs	r3, #8
    f974:	b.n	f97c <quorem+0x110>
    f976:	ldr	r2, [r3, #0]
    f978:	subs	r3, #4
    f97a:	cbnz	r2, f984 <quorem+0x118>
    f97c:	cmp	fp, r3
    f97e:	add.w	r8, r8, #4294967295
    f982:	bcc.n	f976 <quorem+0x10a>
    f984:	str.w	r8, [r4, #16]
    f988:	mov	r0, r9
    f98a:	add	sp, #12
    f98c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f990:	movs	r0, #0
    f992:	bx	lr
    f994:			; <UNDEFINED> instruction: 0xffffffff

0000f998 <_dtoa_r>:
    f998:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f99c:	vmov	r6, r7, d0
    f9a0:	sub	sp, #108	; 0x6c
    f9a2:	ldr	r4, [r0, #64]	; 0x40
    f9a4:	ldr	r5, [sp, #144]	; 0x90
    f9a6:	str	r1, [sp, #0]
    f9a8:	mov	r9, r0
    f9aa:	str	r2, [sp, #20]
    f9ac:	str	r3, [sp, #12]
    f9ae:	vmov	sl, s0
    f9b2:	mov	fp, r7
    f9b4:	cbz	r4, f9cc <_dtoa_r+0x34>
    f9b6:	ldr	r2, [r0, #68]	; 0x44
    f9b8:	str	r2, [r4, #4]
    f9ba:	movs	r3, #1
    f9bc:	lsls	r3, r2
    f9be:	str	r3, [r4, #8]
    f9c0:	mov	r1, r4
    f9c2:	bl	112ac <_Bfree>
    f9c6:	movs	r3, #0
    f9c8:	str.w	r3, [r9, #64]	; 0x40
    f9cc:	cmp.w	fp, #0
    f9d0:	mov	r4, fp
    f9d2:	blt.n	fa3e <_dtoa_r+0xa6>
    f9d4:	movs	r3, #0
    f9d6:	str	r3, [r5, #0]
    f9d8:	ldr	r3, [pc, #644]	; (fc60 <_dtoa_r+0x2c8>)
    f9da:	mov	r2, r3
    f9dc:	ands	r3, r4
    f9de:	cmp	r3, r2
    f9e0:	beq.n	fa10 <_dtoa_r+0x78>
    f9e2:	movs	r2, #0
    f9e4:	movs	r3, #0
    f9e6:	mov	r0, sl
    f9e8:	mov	r1, fp
    f9ea:	bl	adb0 <__aeabi_dcmpeq>
    f9ee:	mov	r6, sl
    f9f0:	mov	r7, fp
    f9f2:	mov	r8, r0
    f9f4:	cbz	r0, fa4a <_dtoa_r+0xb2>
    f9f6:	ldr	r2, [sp, #12]
    f9f8:	movs	r3, #1
    f9fa:	str	r3, [r2, #0]
    f9fc:	ldr	r3, [sp, #148]	; 0x94
    f9fe:	cmp	r3, #0
    fa00:	beq.w	fb80 <_dtoa_r+0x1e8>
    fa04:	ldr	r0, [pc, #604]	; (fc64 <_dtoa_r+0x2cc>)
    fa06:	str	r0, [r3, #0]
    fa08:	subs	r0, #1
    fa0a:	add	sp, #108	; 0x6c
    fa0c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fa10:	ldr	r2, [sp, #12]
    fa12:	movw	r3, #9999	; 0x270f
    fa16:	str	r3, [r2, #0]
    fa18:	cmp.w	sl, #0
    fa1c:	beq.w	fb54 <_dtoa_r+0x1bc>
    fa20:	ldr	r0, [pc, #580]	; (fc68 <_dtoa_r+0x2d0>)
    fa22:	ldr	r3, [sp, #148]	; 0x94
    fa24:	cmp	r3, #0
    fa26:	beq.n	fa0a <_dtoa_r+0x72>
    fa28:	ldrb	r3, [r0, #3]
    fa2a:	cmp	r3, #0
    fa2c:	beq.w	fb84 <_dtoa_r+0x1ec>
    fa30:	add.w	r3, r0, #8
    fa34:	ldr	r2, [sp, #148]	; 0x94
    fa36:	str	r3, [r2, #0]
    fa38:	add	sp, #108	; 0x6c
    fa3a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fa3e:	movs	r3, #1
    fa40:	bic.w	r4, fp, #2147483648	; 0x80000000
    fa44:	str	r3, [r5, #0]
    fa46:	mov	fp, r4
    fa48:	b.n	f9d8 <_dtoa_r+0x40>
    fa4a:	add	r2, sp, #96	; 0x60
    fa4c:	add	r1, sp, #100	; 0x64
    fa4e:	vmov	d0, r6, r7
    fa52:	mov	r0, r9
    fa54:	bl	11984 <__d2b>
    fa58:	lsrs	r5, r4, #20
    fa5a:	str	r0, [sp, #40]	; 0x28
    fa5c:	bne.w	fb66 <_dtoa_r+0x1ce>
    fa60:	ldr	r5, [sp, #96]	; 0x60
    fa62:	ldr	r6, [sp, #100]	; 0x64
    fa64:	add	r6, r5
    fa66:	addw	r3, r6, #1074	; 0x432
    fa6a:	cmp	r3, #32
    fa6c:	ble.w	ff80 <_dtoa_r+0x5e8>
    fa70:	rsb	r3, r3, #64	; 0x40
    fa74:	addw	r0, r6, #1042	; 0x412
    fa78:	lsls	r4, r3
    fa7a:	lsr.w	r0, sl, r0
    fa7e:	orrs	r0, r4
    fa80:	bl	a7f4 <__aeabi_ui2d>
    fa84:	movs	r3, #1
    fa86:	subs	r4, r6, #1
    fa88:	sub.w	r1, r1, #32505856	; 0x1f00000
    fa8c:	str	r3, [sp, #60]	; 0x3c
    fa8e:	movs	r2, #0
    fa90:	ldr	r3, [pc, #472]	; (fc6c <_dtoa_r+0x2d4>)
    fa92:	bl	a578 <__aeabi_dsub>
    fa96:	add	r3, pc, #432	; (adr r3, fc48 <_dtoa_r+0x2b0>)
    fa98:	ldrd	r2, r3, [r3]
    fa9c:	bl	a8e0 <__aeabi_dmul>
    faa0:	add	r3, pc, #428	; (adr r3, fc50 <_dtoa_r+0x2b8>)
    faa2:	ldrd	r2, r3, [r3]
    faa6:	bl	a57c <__adddf3>
    faaa:	mov	r6, r0
    faac:	mov	r0, r4
    faae:	mov	r7, r1
    fab0:	bl	a814 <__aeabi_i2d>
    fab4:	add	r3, pc, #416	; (adr r3, fc58 <_dtoa_r+0x2c0>)
    fab6:	ldrd	r2, r3, [r3]
    faba:	bl	a8e0 <__aeabi_dmul>
    fabe:	mov	r2, r0
    fac0:	mov	r3, r1
    fac2:	mov	r0, r6
    fac4:	mov	r1, r7
    fac6:	bl	a57c <__adddf3>
    faca:	mov	r6, r0
    facc:	mov	r7, r1
    face:	bl	ae40 <__aeabi_d2iz>
    fad2:	movs	r2, #0
    fad4:	str	r0, [sp, #16]
    fad6:	movs	r3, #0
    fad8:	mov	r0, r6
    fada:	mov	r1, r7
    fadc:	bl	adc4 <__aeabi_dcmplt>
    fae0:	cmp	r0, #0
    fae2:	bne.w	ff36 <_dtoa_r+0x59e>
    fae6:	ldr	r6, [sp, #16]
    fae8:	cmp	r6, #22
    faea:	bhi.w	ff30 <_dtoa_r+0x598>
    faee:	ldr	r3, [pc, #384]	; (fc70 <_dtoa_r+0x2d8>)
    faf0:	add.w	r3, r3, r6, lsl #3
    faf4:	ldrd	r0, r1, [r3]
    faf8:	mov	r2, sl
    fafa:	mov	r3, fp
    fafc:	bl	ae00 <__aeabi_dcmpgt>
    fb00:	cmp	r0, #0
    fb02:	beq.w	ff8a <_dtoa_r+0x5f2>
    fb06:	subs	r3, r6, #1
    fb08:	str	r3, [sp, #16]
    fb0a:	movs	r3, #0
    fb0c:	str	r3, [sp, #52]	; 0x34
    fb0e:	subs	r5, r5, r4
    fb10:	subs.w	r8, r5, #1
    fb14:	bmi.w	ff6c <_dtoa_r+0x5d4>
    fb18:	movs	r3, #0
    fb1a:	str	r3, [sp, #28]
    fb1c:	ldr	r3, [sp, #16]
    fb1e:	cmp	r3, #0
    fb20:	blt.w	ff5a <_dtoa_r+0x5c2>
    fb24:	add	r8, r3
    fb26:	str	r3, [sp, #48]	; 0x30
    fb28:	movs	r3, #0
    fb2a:	str	r3, [sp, #24]
    fb2c:	ldr	r3, [sp, #0]
    fb2e:	cmp	r3, #9
    fb30:	bhi.n	fb88 <_dtoa_r+0x1f0>
    fb32:	cmp	r3, #5
    fb34:	ble.w	107c0 <_dtoa_r+0xe28>
    fb38:	subs	r3, #4
    fb3a:	str	r3, [sp, #0]
    fb3c:	movs	r6, #0
    fb3e:	ldr	r3, [sp, #0]
    fb40:	subs	r3, #2
    fb42:	cmp	r3, #3
    fb44:	bhi.w	1078e <_dtoa_r+0xdf6>
    fb48:	tbh	[pc, r3, lsl #1]
    fb4c:	.word	0x0224032b
    fb50:	.word	0x04500336
    fb54:	ldr	r3, [pc, #272]	; (fc68 <_dtoa_r+0x2d0>)
    fb56:	ldr	r2, [pc, #284]	; (fc74 <_dtoa_r+0x2dc>)
    fb58:	ubfx	r0, r4, #0, #20
    fb5c:	cmp	r0, #0
    fb5e:	ite	ne
    fb60:	movne	r0, r3
    fb62:	moveq	r0, r2
    fb64:	b.n	fa22 <_dtoa_r+0x8a>
    fb66:	ubfx	r3, fp, #0, #20
    fb6a:	orr.w	r1, r3, #1069547520	; 0x3fc00000
    fb6e:	subw	r4, r5, #1023	; 0x3ff
    fb72:	mov	r0, sl
    fb74:	str.w	r8, [sp, #60]	; 0x3c
    fb78:	orr.w	r1, r1, #3145728	; 0x300000
    fb7c:	ldr	r5, [sp, #96]	; 0x60
    fb7e:	b.n	fa8e <_dtoa_r+0xf6>
    fb80:	ldr	r0, [pc, #244]	; (fc78 <_dtoa_r+0x2e0>)
    fb82:	b.n	fa0a <_dtoa_r+0x72>
    fb84:	adds	r3, r0, #3
    fb86:	b.n	fa34 <_dtoa_r+0x9c>
    fb88:	movs	r1, #0
    fb8a:	str.w	r1, [r9, #68]	; 0x44
    fb8e:	mov	r0, r9
    fb90:	mov	r4, r1
    fb92:	str	r1, [sp, #0]
    fb94:	bl	11260 <_Balloc>
    fb98:	mov.w	r3, #4294967295
    fb9c:	str	r3, [sp, #32]
    fb9e:	str	r3, [sp, #56]	; 0x38
    fba0:	movs	r3, #1
    fba2:	str	r0, [sp, #36]	; 0x24
    fba4:	str.w	r0, [r9, #64]	; 0x40
    fba8:	str	r4, [sp, #20]
    fbaa:	str	r3, [sp, #44]	; 0x2c
    fbac:	ldr	r3, [sp, #100]	; 0x64
    fbae:	cmp	r3, #0
    fbb0:	blt.w	fd54 <_dtoa_r+0x3bc>
    fbb4:	ldr	r2, [sp, #16]
    fbb6:	cmp	r2, #14
    fbb8:	bgt.w	fd54 <_dtoa_r+0x3bc>
    fbbc:	ldr	r3, [pc, #176]	; (fc70 <_dtoa_r+0x2d8>)
    fbbe:	add.w	r3, r3, r2, lsl #3
    fbc2:	vldr	d7, [r3]
    fbc6:	ldr	r3, [sp, #20]
    fbc8:	cmp	r3, #0
    fbca:	vstr	d7, [sp]
    fbce:	blt.w	101ce <_dtoa_r+0x836>
    fbd2:	mov	r6, sl
    fbd4:	mov	r7, fp
    fbd6:	ldrd	sl, fp, [sp]
    fbda:	mov	r0, r6
    fbdc:	mov	r2, sl
    fbde:	mov	r3, fp
    fbe0:	mov	r1, r7
    fbe2:	bl	ab34 <__aeabi_ddiv>
    fbe6:	bl	ae40 <__aeabi_d2iz>
    fbea:	mov	r4, r0
    fbec:	bl	a814 <__aeabi_i2d>
    fbf0:	mov	r2, sl
    fbf2:	mov	r3, fp
    fbf4:	bl	a8e0 <__aeabi_dmul>
    fbf8:	mov	r3, r1
    fbfa:	mov	r2, r0
    fbfc:	mov	r1, r7
    fbfe:	mov	r0, r6
    fc00:	bl	a578 <__aeabi_dsub>
    fc04:	ldr	r5, [sp, #36]	; 0x24
    fc06:	add.w	r3, r4, #48	; 0x30
    fc0a:	strb	r3, [r5, #0]
    fc0c:	ldr	r3, [sp, #32]
    fc0e:	cmp	r3, #1
    fc10:	mov	r6, r0
    fc12:	mov	r7, r1
    fc14:	add.w	r5, r5, #1
    fc18:	beq.n	fcde <_dtoa_r+0x346>
    fc1a:	movs	r2, #0
    fc1c:	ldr	r3, [pc, #92]	; (fc7c <_dtoa_r+0x2e4>)
    fc1e:	bl	a8e0 <__aeabi_dmul>
    fc22:	movs	r2, #0
    fc24:	movs	r3, #0
    fc26:	mov	r6, r0
    fc28:	mov	r7, r1
    fc2a:	bl	adb0 <__aeabi_dcmpeq>
    fc2e:	cmp	r0, #0
    fc30:	bne.n	fd2e <_dtoa_r+0x396>
    fc32:	str.w	r9, [sp, #20]
    fc36:	ldr.w	sl, [sp, #32]
    fc3a:	ldr.w	fp, [sp, #36]	; 0x24
    fc3e:	ldrd	r8, r9, [sp]
    fc42:	b.n	fc96 <_dtoa_r+0x2fe>
    fc44:	nop.w
    fc48:	.word	0x636f4361
    fc4c:	.word	0x3fd287a7
    fc50:	.word	0x8b60c8b3
    fc54:	.word	0x3fc68a28
    fc58:	.word	0x509f79fb
    fc5c:	.word	0x3fd34413
    fc60:	.word	0x7ff00000
    fc64:	.word	0x000131d1
    fc68:	.word	0x00013320
    fc6c:	.word	0x3ff80000
    fc70:	.word	0x00013428
    fc74:	.word	0x00013314
    fc78:	.word	0x000131d0
    fc7c:	.word	0x40240000
    fc80:	bl	a8e0 <__aeabi_dmul>
    fc84:	movs	r2, #0
    fc86:	movs	r3, #0
    fc88:	mov	r6, r0
    fc8a:	mov	r7, r1
    fc8c:	bl	adb0 <__aeabi_dcmpeq>
    fc90:	cmp	r0, #0
    fc92:	bne.w	103f2 <_dtoa_r+0xa5a>
    fc96:	mov	r2, r8
    fc98:	mov	r3, r9
    fc9a:	mov	r0, r6
    fc9c:	mov	r1, r7
    fc9e:	bl	ab34 <__aeabi_ddiv>
    fca2:	bl	ae40 <__aeabi_d2iz>
    fca6:	mov	r4, r0
    fca8:	bl	a814 <__aeabi_i2d>
    fcac:	mov	r2, r8
    fcae:	mov	r3, r9
    fcb0:	bl	a8e0 <__aeabi_dmul>
    fcb4:	mov	r2, r0
    fcb6:	mov	r3, r1
    fcb8:	mov	r0, r6
    fcba:	mov	r1, r7
    fcbc:	bl	a578 <__aeabi_dsub>
    fcc0:	add.w	lr, r4, #48	; 0x30
    fcc4:	strb.w	lr, [r5], #1
    fcc8:	rsb	lr, fp, r5
    fccc:	cmp	lr, sl
    fcce:	mov	r6, r0
    fcd0:	mov	r7, r1
    fcd2:	mov.w	r2, #0
    fcd6:	ldr	r3, [pc, #696]	; (ff90 <_dtoa_r+0x5f8>)
    fcd8:	bne.n	fc80 <_dtoa_r+0x2e8>
    fcda:	ldr.w	r9, [sp, #20]
    fcde:	mov	r2, r6
    fce0:	mov	r3, r7
    fce2:	mov	r0, r6
    fce4:	mov	r1, r7
    fce6:	bl	a57c <__adddf3>
    fcea:	mov	r6, r0
    fcec:	mov	r7, r1
    fcee:	mov	r2, r0
    fcf0:	mov	r3, r1
    fcf2:	ldrd	r0, r1, [sp]
    fcf6:	bl	adc4 <__aeabi_dcmplt>
    fcfa:	cbnz	r0, fd0e <_dtoa_r+0x376>
    fcfc:	mov	r2, r6
    fcfe:	mov	r3, r7
    fd00:	ldrd	r0, r1, [sp]
    fd04:	bl	adb0 <__aeabi_dcmpeq>
    fd08:	cbz	r0, fd2e <_dtoa_r+0x396>
    fd0a:	lsls	r3, r4, #31
    fd0c:	bpl.n	fd2e <_dtoa_r+0x396>
    fd0e:	ldrb.w	r4, [r5, #-1]
    fd12:	ldr	r2, [sp, #36]	; 0x24
    fd14:	subs	r3, r5, #1
    fd16:	b.n	fd22 <_dtoa_r+0x38a>
    fd18:	cmp	r2, r3
    fd1a:	beq.w	10516 <_dtoa_r+0xb7e>
    fd1e:	ldrb.w	r4, [r3, #-1]!
    fd22:	cmp	r4, #57	; 0x39
    fd24:	add.w	r5, r3, #1
    fd28:	beq.n	fd18 <_dtoa_r+0x380>
    fd2a:	adds	r4, #1
    fd2c:	strb	r4, [r3, #0]
    fd2e:	ldr	r1, [sp, #40]	; 0x28
    fd30:	mov	r0, r9
    fd32:	bl	112ac <_Bfree>
    fd36:	movs	r2, #0
    fd38:	ldr	r3, [sp, #16]
    fd3a:	strb	r2, [r5, #0]
    fd3c:	ldr	r2, [sp, #12]
    fd3e:	adds	r3, #1
    fd40:	str	r3, [r2, #0]
    fd42:	ldr	r3, [sp, #148]	; 0x94
    fd44:	cmp	r3, #0
    fd46:	beq.w	10480 <_dtoa_r+0xae8>
    fd4a:	ldr	r0, [sp, #36]	; 0x24
    fd4c:	str	r5, [r3, #0]
    fd4e:	add	sp, #108	; 0x6c
    fd50:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fd54:	ldr	r2, [sp, #44]	; 0x2c
    fd56:	cmp	r2, #0
    fd58:	beq.w	ff78 <_dtoa_r+0x5e0>
    fd5c:	ldr	r2, [sp, #0]
    fd5e:	cmp	r2, #1
    fd60:	ble.w	10212 <_dtoa_r+0x87a>
    fd64:	ldr	r3, [sp, #32]
    fd66:	ldr	r2, [sp, #24]
    fd68:	subs	r7, r3, #1
    fd6a:	cmp	r2, r7
    fd6c:	blt.w	10486 <_dtoa_r+0xaee>
    fd70:	subs	r7, r2, r7
    fd72:	ldr	r3, [sp, #32]
    fd74:	cmp	r3, #0
    fd76:	blt.w	1067a <_dtoa_r+0xce2>
    fd7a:	ldr	r5, [sp, #28]
    fd7c:	ldr	r3, [sp, #32]
    fd7e:	ldr	r2, [sp, #28]
    fd80:	movs	r1, #1
    fd82:	add	r2, r3
    fd84:	mov	r0, r9
    fd86:	str	r2, [sp, #28]
    fd88:	add	r8, r3
    fd8a:	bl	11474 <__i2b>
    fd8e:	mov	r6, r0
    fd90:	cbz	r5, fdac <_dtoa_r+0x414>
    fd92:	cmp.w	r8, #0
    fd96:	ble.n	fdac <_dtoa_r+0x414>
    fd98:	cmp	r5, r8
    fd9a:	ldr	r2, [sp, #28]
    fd9c:	mov	r3, r5
    fd9e:	it	ge
    fda0:	movge	r3, r8
    fda2:	subs	r2, r2, r3
    fda4:	str	r2, [sp, #28]
    fda6:	subs	r5, r5, r3
    fda8:	rsb	r8, r3, r8
    fdac:	ldr	r3, [sp, #24]
    fdae:	cmp	r3, #0
    fdb0:	ble.w	1039e <_dtoa_r+0xa06>
    fdb4:	ldr	r2, [sp, #44]	; 0x2c
    fdb6:	cmp	r2, #0
    fdb8:	beq.w	101c0 <_dtoa_r+0x828>
    fdbc:	cmp	r7, #0
    fdbe:	beq.w	101c0 <_dtoa_r+0x828>
    fdc2:	mov	r1, r6
    fdc4:	mov	r2, r7
    fdc6:	mov	r0, r9
    fdc8:	bl	115b8 <__pow5mult>
    fdcc:	ldr	r2, [sp, #40]	; 0x28
    fdce:	mov	r1, r0
    fdd0:	mov	r6, r0
    fdd2:	mov	r0, r9
    fdd4:	bl	11488 <__multiply>
    fdd8:	ldr	r1, [sp, #40]	; 0x28
    fdda:	mov	r4, r0
    fddc:	mov	r0, r9
    fdde:	bl	112ac <_Bfree>
    fde2:	ldr	r3, [sp, #24]
    fde4:	subs	r3, r3, r7
    fde6:	str	r3, [sp, #24]
    fde8:	bne.w	101be <_dtoa_r+0x826>
    fdec:	movs	r1, #1
    fdee:	mov	r0, r9
    fdf0:	bl	11474 <__i2b>
    fdf4:	ldr	r3, [sp, #48]	; 0x30
    fdf6:	str	r0, [sp, #24]
    fdf8:	cmp	r3, #0
    fdfa:	beq.w	10228 <_dtoa_r+0x890>
    fdfe:	mov	r1, r0
    fe00:	mov	r2, r3
    fe02:	mov	r0, r9
    fe04:	bl	115b8 <__pow5mult>
    fe08:	ldr	r3, [sp, #0]
    fe0a:	str	r0, [sp, #24]
    fe0c:	cmp	r3, #1
    fe0e:	ble.w	103f8 <_dtoa_r+0xa60>
    fe12:	movs	r7, #0
    fe14:	ldr	r2, [sp, #24]
    fe16:	ldr	r3, [r2, #16]
    fe18:	add.w	r3, r2, r3, lsl #2
    fe1c:	ldr	r0, [r3, #16]
    fe1e:	bl	113d8 <__hi0bits>
    fe22:	rsb	r0, r0, #32
    fe26:	add	r0, r8
    fe28:	ands.w	r0, r0, #31
    fe2c:	beq.w	10224 <_dtoa_r+0x88c>
    fe30:	rsb	r3, r0, #32
    fe34:	cmp	r3, #4
    fe36:	ble.w	107b4 <_dtoa_r+0xe1c>
    fe3a:	rsb	r0, r0, #28
    fe3e:	ldr	r3, [sp, #28]
    fe40:	add	r3, r0
    fe42:	str	r3, [sp, #28]
    fe44:	add	r5, r0
    fe46:	add	r8, r0
    fe48:	ldr	r3, [sp, #28]
    fe4a:	cmp	r3, #0
    fe4c:	ble.n	fe5a <_dtoa_r+0x4c2>
    fe4e:	mov	r1, r4
    fe50:	mov	r2, r3
    fe52:	mov	r0, r9
    fe54:	bl	11658 <__lshift>
    fe58:	mov	r4, r0
    fe5a:	cmp.w	r8, #0
    fe5e:	ble.n	fe6c <_dtoa_r+0x4d4>
    fe60:	mov	r2, r8
    fe62:	ldr	r1, [sp, #24]
    fe64:	mov	r0, r9
    fe66:	bl	11658 <__lshift>
    fe6a:	str	r0, [sp, #24]
    fe6c:	ldr	r3, [sp, #52]	; 0x34
    fe6e:	cmp	r3, #0
    fe70:	bne.w	10368 <_dtoa_r+0x9d0>
    fe74:	ldr	r3, [sp, #32]
    fe76:	cmp	r3, #0
    fe78:	ble.w	103a2 <_dtoa_r+0xa0a>
    fe7c:	ldr	r3, [sp, #44]	; 0x2c
    fe7e:	cmp	r3, #0
    fe80:	bne.w	1026c <_dtoa_r+0x8d4>
    fe84:	ldr.w	fp, [sp, #36]	; 0x24
    fe88:	ldr	r7, [sp, #32]
    fe8a:	ldr.w	r8, [sp, #24]
    fe8e:	mov	r5, fp
    fe90:	b.n	fe98 <_dtoa_r+0x500>
    fe92:	bl	112c0 <__multadd>
    fe96:	mov	r4, r0
    fe98:	mov	r1, r8
    fe9a:	mov	r0, r4
    fe9c:	bl	f86c <quorem>
    fea0:	add.w	sl, r0, #48	; 0x30
    fea4:	strb.w	sl, [r5], #1
    fea8:	rsb	r3, fp, r5
    feac:	cmp	r3, r7
    feae:	mov.w	r2, #10
    feb2:	mov.w	r3, #0
    feb6:	mov	r1, r4
    feb8:	mov	r0, r9
    feba:	blt.n	fe92 <_dtoa_r+0x4fa>
    febc:	ldr	r3, [sp, #36]	; 0x24
    febe:	ldr	r2, [sp, #32]
    fec0:	cmp	r2, #1
    fec2:	ite	ge
    fec4:	addge	r3, r3, r2
    fec6:	addlt	r3, #1
    fec8:	mov	r5, r3
    feca:	mov.w	fp, #0
    fece:	mov	r1, r4
    fed0:	movs	r2, #1
    fed2:	mov	r0, r9
    fed4:	bl	11658 <__lshift>
    fed8:	ldr	r1, [sp, #24]
    feda:	str	r0, [sp, #40]	; 0x28
    fedc:	bl	11708 <__mcmp>
    fee0:	cmp	r0, #0
    fee2:	ble.w	104f0 <_dtoa_r+0xb58>
    fee6:	ldrb.w	r2, [r5, #-1]
    feea:	ldr	r1, [sp, #36]	; 0x24
    feec:	subs	r3, r5, #1
    feee:	b.n	fefa <_dtoa_r+0x562>
    fef0:	cmp	r3, r1
    fef2:	beq.w	103de <_dtoa_r+0xa46>
    fef6:	ldrb.w	r2, [r3, #-1]!
    fefa:	cmp	r2, #57	; 0x39
    fefc:	add.w	r5, r3, #1
    ff00:	beq.n	fef0 <_dtoa_r+0x558>
    ff02:	adds	r2, #1
    ff04:	strb	r2, [r3, #0]
    ff06:	ldr	r1, [sp, #24]
    ff08:	mov	r0, r9
    ff0a:	bl	112ac <_Bfree>
    ff0e:	cmp	r6, #0
    ff10:	beq.w	fd2e <_dtoa_r+0x396>
    ff14:	cmp.w	fp, #0
    ff18:	beq.n	ff26 <_dtoa_r+0x58e>
    ff1a:	cmp	fp, r6
    ff1c:	beq.n	ff26 <_dtoa_r+0x58e>
    ff1e:	mov	r1, fp
    ff20:	mov	r0, r9
    ff22:	bl	112ac <_Bfree>
    ff26:	mov	r1, r6
    ff28:	mov	r0, r9
    ff2a:	bl	112ac <_Bfree>
    ff2e:	b.n	fd2e <_dtoa_r+0x396>
    ff30:	movs	r3, #1
    ff32:	str	r3, [sp, #52]	; 0x34
    ff34:	b.n	fb0e <_dtoa_r+0x176>
    ff36:	ldr.w	r8, [sp, #16]
    ff3a:	mov	r0, r8
    ff3c:	bl	a814 <__aeabi_i2d>
    ff40:	mov	r2, r0
    ff42:	mov	r3, r1
    ff44:	mov	r0, r6
    ff46:	mov	r1, r7
    ff48:	bl	adb0 <__aeabi_dcmpeq>
    ff4c:	cmp	r0, #0
    ff4e:	bne.w	fae6 <_dtoa_r+0x14e>
    ff52:	add.w	r3, r8, #4294967295
    ff56:	str	r3, [sp, #16]
    ff58:	b.n	fae6 <_dtoa_r+0x14e>
    ff5a:	ldr	r2, [sp, #28]
    ff5c:	ldr	r3, [sp, #16]
    ff5e:	subs	r2, r2, r3
    ff60:	negs	r3, r3
    ff62:	str	r3, [sp, #24]
    ff64:	movs	r3, #0
    ff66:	str	r2, [sp, #28]
    ff68:	str	r3, [sp, #48]	; 0x30
    ff6a:	b.n	fb2c <_dtoa_r+0x194>
    ff6c:	rsb	r3, r8, #0
    ff70:	str	r3, [sp, #28]
    ff72:	mov.w	r8, #0
    ff76:	b.n	fb1c <_dtoa_r+0x184>
    ff78:	ldr	r7, [sp, #24]
    ff7a:	ldr	r5, [sp, #28]
    ff7c:	ldr	r6, [sp, #44]	; 0x2c
    ff7e:	b.n	fd90 <_dtoa_r+0x3f8>
    ff80:	rsb	r4, r3, #32
    ff84:	lsl.w	r0, sl, r4
    ff88:	b.n	fa80 <_dtoa_r+0xe8>
    ff8a:	str	r0, [sp, #52]	; 0x34
    ff8c:	b.n	fb0e <_dtoa_r+0x176>
    ff8e:	nop
    ff90:	.word	0x40240000
    ff94:	movs	r3, #0
    ff96:	str	r3, [sp, #44]	; 0x2c
    ff98:	ldr	r3, [sp, #16]
    ff9a:	ldr	r2, [sp, #20]
    ff9c:	add	r3, r2
    ff9e:	str	r3, [sp, #56]	; 0x38
    ffa0:	adds	r3, #1
    ffa2:	cmp	r3, #0
    ffa4:	str	r3, [sp, #32]
    ffa6:	ble.w	104a4 <_dtoa_r+0xb0c>
    ffaa:	ldr	r4, [sp, #32]
    ffac:	mov	r5, r4
    ffae:	movs	r1, #0
    ffb0:	cmp	r5, #23
    ffb2:	str.w	r1, [r9, #68]	; 0x44
    ffb6:	bls.n	ffd0 <_dtoa_r+0x638>
    ffb8:	movs	r2, #1
    ffba:	movs	r3, #4
    ffbc:	lsls	r3, r3, #1
    ffbe:	add.w	r0, r3, #20
    ffc2:	cmp	r0, r5
    ffc4:	mov	r1, r2
    ffc6:	add.w	r2, r2, #1
    ffca:	bls.n	ffbc <_dtoa_r+0x624>
    ffcc:	str.w	r1, [r9, #68]	; 0x44
    ffd0:	mov	r0, r9
    ffd2:	bl	11260 <_Balloc>
    ffd6:	cmp	r4, #14
    ffd8:	str	r0, [sp, #36]	; 0x24
    ffda:	str.w	r0, [r9, #64]	; 0x40
    ffde:	bhi.w	fbac <_dtoa_r+0x214>
    ffe2:	cmp	r6, #0
    ffe4:	beq.w	fbac <_dtoa_r+0x214>
    ffe8:	ldr	r1, [sp, #16]
    ffea:	cmp	r1, #0
    ffec:	strd	sl, fp, [sp, #64]	; 0x40
    fff0:	ble.w	10528 <_dtoa_r+0xb90>
    fff4:	ldr	r3, [pc, #576]	; (10238 <_dtoa_r+0x8a0>)
    fff6:	and.w	r2, r1, #15
    fffa:	asrs	r6, r1, #4
    fffc:	add.w	r3, r3, r2, lsl #3
   10000:	lsls	r0, r6, #27
   10002:	ldrd	r4, r5, [r3]
   10006:	bpl.w	10496 <_dtoa_r+0xafe>
   1000a:	ldr	r3, [pc, #560]	; (1023c <_dtoa_r+0x8a4>)
   1000c:	mov	r0, sl
   1000e:	mov	r1, fp
   10010:	ldrd	r2, r3, [r3, #32]
   10014:	bl	ab34 <__aeabi_ddiv>
   10018:	strd	r0, r1, [sp, #72]	; 0x48
   1001c:	and.w	r6, r6, #15
   10020:	mov.w	sl, #3
   10024:	cbz	r6, 10048 <_dtoa_r+0x6b0>
   10026:	ldr	r7, [pc, #532]	; (1023c <_dtoa_r+0x8a4>)
   10028:	lsls	r1, r6, #31
   1002a:	bpl.n	10040 <_dtoa_r+0x6a8>
   1002c:	mov	r0, r4
   1002e:	mov	r1, r5
   10030:	ldrd	r2, r3, [r7]
   10034:	bl	a8e0 <__aeabi_dmul>
   10038:	add.w	sl, sl, #1
   1003c:	mov	r4, r0
   1003e:	mov	r5, r1
   10040:	asrs	r6, r6, #1
   10042:	add.w	r7, r7, #8
   10046:	bne.n	10028 <_dtoa_r+0x690>
   10048:	mov	r2, r4
   1004a:	mov	r3, r5
   1004c:	ldrd	r0, r1, [sp, #72]	; 0x48
   10050:	bl	ab34 <__aeabi_ddiv>
   10054:	mov	r6, r0
   10056:	mov	r7, r1
   10058:	ldr	r3, [sp, #52]	; 0x34
   1005a:	cbz	r3, 1006e <_dtoa_r+0x6d6>
   1005c:	movs	r2, #0
   1005e:	ldr	r3, [pc, #480]	; (10240 <_dtoa_r+0x8a8>)
   10060:	mov	r0, r6
   10062:	mov	r1, r7
   10064:	bl	adc4 <__aeabi_dcmplt>
   10068:	cmp	r0, #0
   1006a:	bne.w	106a2 <_dtoa_r+0xd0a>
   1006e:	mov	r0, sl
   10070:	bl	a814 <__aeabi_i2d>
   10074:	mov	r2, r6
   10076:	mov	r3, r7
   10078:	bl	a8e0 <__aeabi_dmul>
   1007c:	ldr	r3, [pc, #452]	; (10244 <_dtoa_r+0x8ac>)
   1007e:	movs	r2, #0
   10080:	bl	a57c <__adddf3>
   10084:	ldr	r3, [sp, #32]
   10086:	mov	r4, r0
   10088:	sub.w	r5, r1, #54525952	; 0x3400000
   1008c:	cmp	r3, #0
   1008e:	beq.w	10448 <_dtoa_r+0xab0>
   10092:	ldr	r3, [sp, #16]
   10094:	str	r3, [sp, #88]	; 0x58
   10096:	ldr	r3, [sp, #32]
   10098:	str	r3, [sp, #72]	; 0x48
   1009a:	ldr	r3, [sp, #44]	; 0x2c
   1009c:	cmp	r3, #0
   1009e:	beq.w	105ca <_dtoa_r+0xc32>
   100a2:	ldr	r2, [sp, #72]	; 0x48
   100a4:	ldr	r3, [pc, #400]	; (10238 <_dtoa_r+0x8a0>)
   100a6:	ldr	r1, [pc, #416]	; (10248 <_dtoa_r+0x8b0>)
   100a8:	add.w	r3, r3, r2, lsl #3
   100ac:	ldrd	r2, r3, [r3, #-8]
   100b0:	movs	r0, #0
   100b2:	bl	ab34 <__aeabi_ddiv>
   100b6:	mov	r2, r4
   100b8:	mov	r3, r5
   100ba:	bl	a578 <__aeabi_dsub>
   100be:	mov	sl, r0
   100c0:	mov	fp, r1
   100c2:	mov	r0, r6
   100c4:	mov	r1, r7
   100c6:	bl	ae40 <__aeabi_d2iz>
   100ca:	mov	r4, r0
   100cc:	bl	a814 <__aeabi_i2d>
   100d0:	mov	r2, r0
   100d2:	mov	r3, r1
   100d4:	mov	r0, r6
   100d6:	mov	r1, r7
   100d8:	bl	a578 <__aeabi_dsub>
   100dc:	adds	r4, #48	; 0x30
   100de:	ldr	r5, [sp, #36]	; 0x24
   100e0:	uxtb	r4, r4
   100e2:	mov	r6, r0
   100e4:	mov	r7, r1
   100e6:	strb	r4, [r5, #0]
   100e8:	mov	r2, r0
   100ea:	mov	r3, r1
   100ec:	mov	r0, sl
   100ee:	mov	r1, fp
   100f0:	adds	r5, #1
   100f2:	bl	ae00 <__aeabi_dcmpgt>
   100f6:	cmp	r0, #0
   100f8:	bne.n	1019c <_dtoa_r+0x804>
   100fa:	mov	r2, r6
   100fc:	mov	r3, r7
   100fe:	movs	r0, #0
   10100:	ldr	r1, [pc, #316]	; (10240 <_dtoa_r+0x8a8>)
   10102:	bl	a578 <__aeabi_dsub>
   10106:	mov	r2, r0
   10108:	mov	r3, r1
   1010a:	mov	r0, sl
   1010c:	mov	r1, fp
   1010e:	bl	ae00 <__aeabi_dcmpgt>
   10112:	cmp	r0, #0
   10114:	bne.w	10728 <_dtoa_r+0xd90>
   10118:	ldr	r2, [sp, #72]	; 0x48
   1011a:	cmp	r2, #1
   1011c:	ble.w	1050e <_dtoa_r+0xb76>
   10120:	ldr	r3, [sp, #72]	; 0x48
   10122:	ldr	r2, [sp, #36]	; 0x24
   10124:	str.w	r8, [sp, #72]	; 0x48
   10128:	add	r3, r2
   1012a:	mov	r8, r3
   1012c:	b.n	1014a <_dtoa_r+0x7b2>
   1012e:	movs	r0, #0
   10130:	ldr	r1, [pc, #268]	; (10240 <_dtoa_r+0x8a8>)
   10132:	bl	a578 <__aeabi_dsub>
   10136:	mov	r2, sl
   10138:	mov	r3, fp
   1013a:	bl	adc4 <__aeabi_dcmplt>
   1013e:	cmp	r0, #0
   10140:	bne.w	10728 <_dtoa_r+0xd90>
   10144:	cmp	r5, r8
   10146:	beq.w	1050a <_dtoa_r+0xb72>
   1014a:	mov	r0, sl
   1014c:	mov	r1, fp
   1014e:	movs	r2, #0
   10150:	ldr	r3, [pc, #248]	; (1024c <_dtoa_r+0x8b4>)
   10152:	bl	a8e0 <__aeabi_dmul>
   10156:	movs	r2, #0
   10158:	ldr	r3, [pc, #240]	; (1024c <_dtoa_r+0x8b4>)
   1015a:	mov	sl, r0
   1015c:	mov	fp, r1
   1015e:	mov	r0, r6
   10160:	mov	r1, r7
   10162:	bl	a8e0 <__aeabi_dmul>
   10166:	mov	r7, r1
   10168:	mov	r6, r0
   1016a:	bl	ae40 <__aeabi_d2iz>
   1016e:	mov	r4, r0
   10170:	bl	a814 <__aeabi_i2d>
   10174:	mov	r2, r0
   10176:	mov	r3, r1
   10178:	mov	r0, r6
   1017a:	mov	r1, r7
   1017c:	bl	a578 <__aeabi_dsub>
   10180:	adds	r4, #48	; 0x30
   10182:	uxtb	r4, r4
   10184:	mov	r2, sl
   10186:	mov	r3, fp
   10188:	strb.w	r4, [r5], #1
   1018c:	mov	r6, r0
   1018e:	mov	r7, r1
   10190:	bl	adc4 <__aeabi_dcmplt>
   10194:	mov	r2, r6
   10196:	mov	r3, r7
   10198:	cmp	r0, #0
   1019a:	beq.n	1012e <_dtoa_r+0x796>
   1019c:	ldr	r3, [sp, #88]	; 0x58
   1019e:	str	r3, [sp, #16]
   101a0:	b.n	fd2e <_dtoa_r+0x396>
   101a2:	movs	r3, #0
   101a4:	str	r3, [sp, #44]	; 0x2c
   101a6:	ldr	r3, [sp, #20]
   101a8:	cmp	r3, #0
   101aa:	ble.w	104ae <_dtoa_r+0xb16>
   101ae:	mov	r5, r3
   101b0:	mov	r4, r3
   101b2:	str	r3, [sp, #56]	; 0x38
   101b4:	str	r3, [sp, #32]
   101b6:	b.n	ffae <_dtoa_r+0x616>
   101b8:	movs	r3, #1
   101ba:	str	r3, [sp, #44]	; 0x2c
   101bc:	b.n	101a6 <_dtoa_r+0x80e>
   101be:	str	r4, [sp, #40]	; 0x28
   101c0:	ldr	r2, [sp, #24]
   101c2:	ldr	r1, [sp, #40]	; 0x28
   101c4:	mov	r0, r9
   101c6:	bl	115b8 <__pow5mult>
   101ca:	mov	r4, r0
   101cc:	b.n	fdec <_dtoa_r+0x454>
   101ce:	ldr	r3, [sp, #32]
   101d0:	cmp	r3, #0
   101d2:	bgt.w	fbd2 <_dtoa_r+0x23a>
   101d6:	bne.w	10478 <_dtoa_r+0xae0>
   101da:	movs	r2, #0
   101dc:	ldr	r3, [pc, #112]	; (10250 <_dtoa_r+0x8b8>)
   101de:	ldrd	r0, r1, [sp]
   101e2:	bl	a8e0 <__aeabi_dmul>
   101e6:	mov	r3, fp
   101e8:	mov	r2, sl
   101ea:	bl	adec <__aeabi_dcmpge>
   101ee:	ldr	r3, [sp, #32]
   101f0:	str	r3, [sp, #24]
   101f2:	mov	r6, r3
   101f4:	cmp	r0, #0
   101f6:	beq.w	103ce <_dtoa_r+0xa36>
   101fa:	ldr	r3, [sp, #20]
   101fc:	ldr	r5, [sp, #36]	; 0x24
   101fe:	mvns	r3, r3
   10200:	str	r3, [sp, #16]
   10202:	ldr	r1, [sp, #24]
   10204:	mov	r0, r9
   10206:	bl	112ac <_Bfree>
   1020a:	cmp	r6, #0
   1020c:	beq.w	fd2e <_dtoa_r+0x396>
   10210:	b.n	ff26 <_dtoa_r+0x58e>
   10212:	ldr	r2, [sp, #60]	; 0x3c
   10214:	cmp	r2, #0
   10216:	beq.w	1068a <_dtoa_r+0xcf2>
   1021a:	addw	r3, r3, #1075	; 0x433
   1021e:	ldr	r7, [sp, #24]
   10220:	ldr	r5, [sp, #28]
   10222:	b.n	fd7e <_dtoa_r+0x3e6>
   10224:	movs	r0, #28
   10226:	b.n	fe3e <_dtoa_r+0x4a6>
   10228:	ldr	r3, [sp, #0]
   1022a:	cmp	r3, #1
   1022c:	ble.w	10730 <_dtoa_r+0xd98>
   10230:	ldr	r7, [sp, #48]	; 0x30
   10232:	movs	r0, #1
   10234:	b.n	fe26 <_dtoa_r+0x48e>
   10236:	nop
   10238:	.word	0x00013428
   1023c:	.word	0x000134f0
   10240:	.word	0x3ff00000
   10244:	.word	0x401c0000
   10248:	.word	0x3fe00000
   1024c:	.word	0x40240000
   10250:	.word	0x40140000
   10254:	mov	r1, r6
   10256:	movs	r3, #0
   10258:	movs	r2, #10
   1025a:	mov	r0, r9
   1025c:	bl	112c0 <__multadd>
   10260:	ldr	r3, [sp, #56]	; 0x38
   10262:	cmp	r3, #0
   10264:	mov	r6, r0
   10266:	ble.w	10784 <_dtoa_r+0xdec>
   1026a:	str	r3, [sp, #32]
   1026c:	cmp	r5, #0
   1026e:	ble.n	1027c <_dtoa_r+0x8e4>
   10270:	mov	r1, r6
   10272:	mov	r2, r5
   10274:	mov	r0, r9
   10276:	bl	11658 <__lshift>
   1027a:	mov	r6, r0
   1027c:	cmp	r7, #0
   1027e:	bne.w	1057a <_dtoa_r+0xbe2>
   10282:	mov	r8, r6
   10284:	ldr	r3, [sp, #32]
   10286:	ldr	r2, [sp, #36]	; 0x24
   10288:	subs	r3, #1
   1028a:	adds	r3, r2, r3
   1028c:	str	r3, [sp, #32]
   1028e:	and.w	r3, sl, #1
   10292:	str	r3, [sp, #40]	; 0x28
   10294:	mov	r7, r2
   10296:	ldr.w	fp, [sp, #24]
   1029a:	mov	r0, r4
   1029c:	mov	r1, fp
   1029e:	bl	f86c <quorem>
   102a2:	mov	r1, r6
   102a4:	mov	r5, r0
   102a6:	mov	r0, r4
   102a8:	bl	11708 <__mcmp>
   102ac:	mov	r2, r8
   102ae:	mov	r1, fp
   102b0:	mov	sl, r0
   102b2:	mov	r0, r9
   102b4:	bl	1174c <__mdiff>
   102b8:	ldr	r2, [r0, #12]
   102ba:	mov	fp, r0
   102bc:	add.w	r3, r5, #48	; 0x30
   102c0:	cmp	r2, #0
   102c2:	bne.n	10358 <_dtoa_r+0x9c0>
   102c4:	mov	r1, r0
   102c6:	mov	r0, r4
   102c8:	str	r3, [sp, #28]
   102ca:	bl	11708 <__mcmp>
   102ce:	mov	r1, fp
   102d0:	str	r0, [sp, #20]
   102d2:	mov	r0, r9
   102d4:	bl	112ac <_Bfree>
   102d8:	ldr	r2, [sp, #20]
   102da:	ldr	r3, [sp, #28]
   102dc:	cbnz	r2, 102ea <_dtoa_r+0x952>
   102de:	ldr	r1, [sp, #0]
   102e0:	cbnz	r1, 102ea <_dtoa_r+0x952>
   102e2:	ldr	r1, [sp, #40]	; 0x28
   102e4:	cmp	r1, #0
   102e6:	beq.w	10754 <_dtoa_r+0xdbc>
   102ea:	cmp.w	sl, #0
   102ee:	blt.w	104b8 <_dtoa_r+0xb20>
   102f2:	bne.n	10300 <_dtoa_r+0x968>
   102f4:	ldr	r1, [sp, #0]
   102f6:	cbnz	r1, 10300 <_dtoa_r+0x968>
   102f8:	ldr	r1, [sp, #40]	; 0x28
   102fa:	cmp	r1, #0
   102fc:	beq.w	104b8 <_dtoa_r+0xb20>
   10300:	cmp	r2, #0
   10302:	bgt.w	105a2 <_dtoa_r+0xc0a>
   10306:	ldr	r2, [sp, #32]
   10308:	strb	r3, [r7, #0]
   1030a:	add.w	sl, r7, #1
   1030e:	cmp	r7, r2
   10310:	mov	r5, sl
   10312:	beq.w	105ba <_dtoa_r+0xc22>
   10316:	mov	r1, r4
   10318:	movs	r3, #0
   1031a:	movs	r2, #10
   1031c:	mov	r0, r9
   1031e:	bl	112c0 <__multadd>
   10322:	cmp	r6, r8
   10324:	mov	r4, r0
   10326:	mov	r1, r6
   10328:	mov.w	r3, #0
   1032c:	mov.w	r2, #10
   10330:	mov	r0, r9
   10332:	beq.n	1034c <_dtoa_r+0x9b4>
   10334:	bl	112c0 <__multadd>
   10338:	mov	r1, r8
   1033a:	mov	r6, r0
   1033c:	movs	r3, #0
   1033e:	movs	r2, #10
   10340:	mov	r0, r9
   10342:	bl	112c0 <__multadd>
   10346:	mov	r7, sl
   10348:	mov	r8, r0
   1034a:	b.n	10296 <_dtoa_r+0x8fe>
   1034c:	bl	112c0 <__multadd>
   10350:	mov	r7, sl
   10352:	mov	r6, r0
   10354:	mov	r8, r0
   10356:	b.n	10296 <_dtoa_r+0x8fe>
   10358:	mov	r1, r0
   1035a:	mov	r0, r9
   1035c:	str	r3, [sp, #20]
   1035e:	bl	112ac <_Bfree>
   10362:	movs	r2, #1
   10364:	ldr	r3, [sp, #20]
   10366:	b.n	102ea <_dtoa_r+0x952>
   10368:	ldr	r1, [sp, #24]
   1036a:	mov	r0, r4
   1036c:	bl	11708 <__mcmp>
   10370:	cmp	r0, #0
   10372:	bge.w	fe74 <_dtoa_r+0x4dc>
   10376:	mov	r1, r4
   10378:	ldr	r4, [sp, #16]
   1037a:	movs	r3, #0
   1037c:	subs	r4, #1
   1037e:	movs	r2, #10
   10380:	mov	r0, r9
   10382:	str	r4, [sp, #16]
   10384:	bl	112c0 <__multadd>
   10388:	ldr	r3, [sp, #44]	; 0x2c
   1038a:	mov	r4, r0
   1038c:	cmp	r3, #0
   1038e:	bne.w	10254 <_dtoa_r+0x8bc>
   10392:	ldr	r3, [sp, #56]	; 0x38
   10394:	cmp	r3, #0
   10396:	ble.w	10774 <_dtoa_r+0xddc>
   1039a:	str	r3, [sp, #32]
   1039c:	b.n	fe84 <_dtoa_r+0x4ec>
   1039e:	ldr	r4, [sp, #40]	; 0x28
   103a0:	b.n	fdec <_dtoa_r+0x454>
   103a2:	ldr	r3, [sp, #0]
   103a4:	cmp	r3, #2
   103a6:	ble.w	fe7c <_dtoa_r+0x4e4>
   103aa:	ldr	r3, [sp, #32]
   103ac:	cmp	r3, #0
   103ae:	bne.w	106ec <_dtoa_r+0xd54>
   103b2:	ldr	r1, [sp, #24]
   103b4:	movs	r2, #5
   103b6:	mov	r0, r9
   103b8:	bl	112c0 <__multadd>
   103bc:	mov	r1, r0
   103be:	str	r0, [sp, #24]
   103c0:	mov	r0, r4
   103c2:	bl	11708 <__mcmp>
   103c6:	cmp	r0, #0
   103c8:	str	r4, [sp, #40]	; 0x28
   103ca:	ble.w	101fa <_dtoa_r+0x862>
   103ce:	ldr	r2, [sp, #16]
   103d0:	ldr	r1, [sp, #36]	; 0x24
   103d2:	movs	r3, #49	; 0x31
   103d4:	adds	r2, #1
   103d6:	str	r2, [sp, #16]
   103d8:	strb	r3, [r1, #0]
   103da:	adds	r5, r1, #1
   103dc:	b.n	10202 <_dtoa_r+0x86a>
   103de:	ldr	r2, [sp, #16]
   103e0:	adds	r2, #1
   103e2:	str	r2, [sp, #16]
   103e4:	ldr	r2, [sp, #36]	; 0x24
   103e6:	movs	r3, #49	; 0x31
   103e8:	strb	r3, [r2, #0]
   103ea:	b.n	ff06 <_dtoa_r+0x56e>
   103ec:	movs	r3, #1
   103ee:	str	r3, [sp, #44]	; 0x2c
   103f0:	b.n	ff98 <_dtoa_r+0x600>
   103f2:	ldr.w	r9, [sp, #20]
   103f6:	b.n	fd2e <_dtoa_r+0x396>
   103f8:	cmp.w	sl, #0
   103fc:	bne.w	fe12 <_dtoa_r+0x47a>
   10400:	ubfx	r3, fp, #0, #20
   10404:	cmp	r3, #0
   10406:	bne.w	10686 <_dtoa_r+0xcee>
   1040a:	bic.w	r7, fp, #2147483648	; 0x80000000
   1040e:	lsrs	r7, r7, #20
   10410:	lsls	r7, r7, #20
   10412:	cbz	r7, 10420 <_dtoa_r+0xa88>
   10414:	ldr	r3, [sp, #28]
   10416:	adds	r3, #1
   10418:	str	r3, [sp, #28]
   1041a:	add.w	r8, r8, #1
   1041e:	movs	r7, #1
   10420:	ldr	r3, [sp, #48]	; 0x30
   10422:	movs	r0, #1
   10424:	cmp	r3, #0
   10426:	beq.w	fe26 <_dtoa_r+0x48e>
   1042a:	b.n	fe14 <_dtoa_r+0x47c>
   1042c:	mov	r0, sl
   1042e:	bl	a814 <__aeabi_i2d>
   10432:	mov	r2, r6
   10434:	mov	r3, r7
   10436:	bl	a8e0 <__aeabi_dmul>
   1043a:	movs	r2, #0
   1043c:	ldr	r3, [pc, #764]	; (1073c <_dtoa_r+0xda4>)
   1043e:	bl	a57c <__adddf3>
   10442:	mov	r4, r0
   10444:	sub.w	r5, r1, #54525952	; 0x3400000
   10448:	mov	r0, r6
   1044a:	mov	r1, r7
   1044c:	movs	r2, #0
   1044e:	ldr	r3, [pc, #752]	; (10740 <_dtoa_r+0xda8>)
   10450:	bl	a578 <__aeabi_dsub>
   10454:	mov	r2, r4
   10456:	mov	r3, r5
   10458:	mov	r6, r0
   1045a:	mov	r7, r1
   1045c:	bl	ae00 <__aeabi_dcmpgt>
   10460:	cmp	r0, #0
   10462:	bne.w	105c2 <_dtoa_r+0xc2a>
   10466:	mov	r2, r4
   10468:	add.w	r3, r5, #2147483648	; 0x80000000
   1046c:	mov	r0, r6
   1046e:	mov	r1, r7
   10470:	bl	adc4 <__aeabi_dcmplt>
   10474:	cmp	r0, #0
   10476:	beq.n	1050e <_dtoa_r+0xb76>
   10478:	movs	r3, #0
   1047a:	str	r3, [sp, #24]
   1047c:	mov	r6, r3
   1047e:	b.n	101fa <_dtoa_r+0x862>
   10480:	ldr	r0, [sp, #36]	; 0x24
   10482:	b.w	fa0a <_dtoa_r+0x72>
   10486:	ldr	r3, [sp, #24]
   10488:	ldr	r2, [sp, #48]	; 0x30
   1048a:	str	r7, [sp, #24]
   1048c:	subs	r3, r7, r3
   1048e:	add	r2, r3
   10490:	str	r2, [sp, #48]	; 0x30
   10492:	movs	r7, #0
   10494:	b.n	fd72 <_dtoa_r+0x3da>
   10496:	vldr	d7, [sp, #64]	; 0x40
   1049a:	mov.w	sl, #2
   1049e:	vstr	d7, [sp, #72]	; 0x48
   104a2:	b.n	10024 <_dtoa_r+0x68c>
   104a4:	mov	r4, r3
   104a6:	movs	r1, #0
   104a8:	str.w	r1, [r9, #68]	; 0x44
   104ac:	b.n	ffd0 <_dtoa_r+0x638>
   104ae:	movs	r4, #1
   104b0:	str	r4, [sp, #56]	; 0x38
   104b2:	str	r4, [sp, #32]
   104b4:	str	r4, [sp, #20]
   104b6:	b.n	104a6 <_dtoa_r+0xb0e>
   104b8:	cmp	r2, #0
   104ba:	mov	sl, r3
   104bc:	ble.n	104e2 <_dtoa_r+0xb4a>
   104be:	mov	r1, r4
   104c0:	movs	r2, #1
   104c2:	mov	r0, r9
   104c4:	bl	11658 <__lshift>
   104c8:	ldr	r1, [sp, #24]
   104ca:	mov	r4, r0
   104cc:	bl	11708 <__mcmp>
   104d0:	cmp	r0, #0
   104d2:	ble.w	10766 <_dtoa_r+0xdce>
   104d6:	cmp.w	sl, #57	; 0x39
   104da:	beq.w	106f0 <_dtoa_r+0xd58>
   104de:	add.w	sl, r5, #49	; 0x31
   104e2:	mov	fp, r6
   104e4:	strb.w	sl, [r7]
   104e8:	adds	r5, r7, #1
   104ea:	mov	r6, r8
   104ec:	str	r4, [sp, #40]	; 0x28
   104ee:	b.n	ff06 <_dtoa_r+0x56e>
   104f0:	bne.n	104fc <_dtoa_r+0xb64>
   104f2:	tst.w	sl, #1
   104f6:	beq.n	104fc <_dtoa_r+0xb64>
   104f8:	b.n	fee6 <_dtoa_r+0x54e>
   104fa:	mov	r5, r2
   104fc:	ldrb.w	r3, [r5, #-1]
   10500:	cmp	r3, #48	; 0x30
   10502:	add.w	r2, r5, #4294967295
   10506:	beq.n	104fa <_dtoa_r+0xb62>
   10508:	b.n	ff06 <_dtoa_r+0x56e>
   1050a:	ldr.w	r8, [sp, #72]	; 0x48
   1050e:	ldrd	sl, fp, [sp, #64]	; 0x40
   10512:	b.w	fbac <_dtoa_r+0x214>
   10516:	ldr	r1, [sp, #36]	; 0x24
   10518:	movs	r2, #48	; 0x30
   1051a:	strb	r2, [r1, #0]
   1051c:	ldr	r2, [sp, #16]
   1051e:	ldrb.w	r4, [r5, #-1]
   10522:	adds	r2, #1
   10524:	str	r2, [sp, #16]
   10526:	b.n	fd2a <_dtoa_r+0x392>
   10528:	ldr	r3, [sp, #16]
   1052a:	negs	r4, r3
   1052c:	cmp	r4, #0
   1052e:	beq.w	10698 <_dtoa_r+0xd00>
   10532:	ldr	r3, [pc, #528]	; (10744 <_dtoa_r+0xdac>)
   10534:	and.w	r2, r4, #15
   10538:	add.w	r3, r3, r2, lsl #3
   1053c:	ldrd	r2, r3, [r3]
   10540:	ldrd	r0, r1, [sp, #64]	; 0x40
   10544:	bl	a8e0 <__aeabi_dmul>
   10548:	asrs	r4, r4, #4
   1054a:	mov	r6, r0
   1054c:	mov	r7, r1
   1054e:	beq.w	1077e <_dtoa_r+0xde6>
   10552:	ldr	r5, [pc, #500]	; (10748 <_dtoa_r+0xdb0>)
   10554:	mov.w	sl, #2
   10558:	lsls	r2, r4, #31
   1055a:	bpl.n	10570 <_dtoa_r+0xbd8>
   1055c:	mov	r0, r6
   1055e:	mov	r1, r7
   10560:	ldrd	r2, r3, [r5]
   10564:	bl	a8e0 <__aeabi_dmul>
   10568:	add.w	sl, sl, #1
   1056c:	mov	r6, r0
   1056e:	mov	r7, r1
   10570:	asrs	r4, r4, #1
   10572:	add.w	r5, r5, #8
   10576:	bne.n	10558 <_dtoa_r+0xbc0>
   10578:	b.n	10058 <_dtoa_r+0x6c0>
   1057a:	ldr	r1, [r6, #4]
   1057c:	mov	r0, r9
   1057e:	bl	11260 <_Balloc>
   10582:	ldr	r3, [r6, #16]
   10584:	adds	r2, r3, #2
   10586:	mov	r5, r0
   10588:	lsls	r2, r2, #2
   1058a:	add.w	r1, r6, #12
   1058e:	adds	r0, #12
   10590:	bl	8f3c <memcpy>
   10594:	mov	r1, r5
   10596:	movs	r2, #1
   10598:	mov	r0, r9
   1059a:	bl	11658 <__lshift>
   1059e:	mov	r8, r0
   105a0:	b.n	10284 <_dtoa_r+0x8ec>
   105a2:	cmp	r3, #57	; 0x39
   105a4:	beq.w	106f0 <_dtoa_r+0xd58>
   105a8:	add.w	sl, r3, #1
   105ac:	mov	fp, r6
   105ae:	strb.w	sl, [r7]
   105b2:	adds	r5, r7, #1
   105b4:	mov	r6, r8
   105b6:	str	r4, [sp, #40]	; 0x28
   105b8:	b.n	ff06 <_dtoa_r+0x56e>
   105ba:	mov	fp, r6
   105bc:	mov	sl, r3
   105be:	mov	r6, r8
   105c0:	b.n	fece <_dtoa_r+0x536>
   105c2:	movs	r3, #0
   105c4:	str	r3, [sp, #24]
   105c6:	mov	r6, r3
   105c8:	b.n	103ce <_dtoa_r+0xa36>
   105ca:	ldr	r3, [sp, #72]	; 0x48
   105cc:	ldr	r1, [pc, #372]	; (10744 <_dtoa_r+0xdac>)
   105ce:	subs	r2, r3, #1
   105d0:	add.w	r1, r1, r2, lsl #3
   105d4:	mov	r3, r5
   105d6:	str	r2, [sp, #92]	; 0x5c
   105d8:	ldrd	r0, r1, [r1]
   105dc:	mov	r2, r4
   105de:	bl	a8e0 <__aeabi_dmul>
   105e2:	strd	r0, r1, [sp, #80]	; 0x50
   105e6:	mov	r1, r7
   105e8:	mov	r0, r6
   105ea:	bl	ae40 <__aeabi_d2iz>
   105ee:	mov	r4, r0
   105f0:	bl	a814 <__aeabi_i2d>
   105f4:	mov	r3, r1
   105f6:	mov	r2, r0
   105f8:	mov	r1, r7
   105fa:	mov	r0, r6
   105fc:	bl	a578 <__aeabi_dsub>
   10600:	ldr	r3, [sp, #72]	; 0x48
   10602:	mov	r7, r1
   10604:	ldr	r1, [sp, #36]	; 0x24
   10606:	adds	r4, #48	; 0x30
   10608:	cmp	r3, #1
   1060a:	mov	r6, r0
   1060c:	strb	r4, [r1, #0]
   1060e:	add.w	r5, r1, #1
   10612:	beq.n	10656 <_dtoa_r+0xcbe>
   10614:	ldr	r3, [sp, #72]	; 0x48
   10616:	ldr	r2, [sp, #36]	; 0x24
   10618:	add	r3, r2
   1061a:	mov	sl, r3
   1061c:	mov	fp, r5
   1061e:	movs	r2, #0
   10620:	ldr	r3, [pc, #296]	; (1074c <_dtoa_r+0xdb4>)
   10622:	mov	r0, r6
   10624:	mov	r1, r7
   10626:	bl	a8e0 <__aeabi_dmul>
   1062a:	mov	r7, r1
   1062c:	mov	r6, r0
   1062e:	bl	ae40 <__aeabi_d2iz>
   10632:	mov	r4, r0
   10634:	bl	a814 <__aeabi_i2d>
   10638:	adds	r4, #48	; 0x30
   1063a:	mov	r2, r0
   1063c:	mov	r3, r1
   1063e:	mov	r0, r6
   10640:	mov	r1, r7
   10642:	bl	a578 <__aeabi_dsub>
   10646:	strb.w	r4, [fp], #1
   1064a:	cmp	sl, fp
   1064c:	mov	r6, r0
   1064e:	mov	r7, r1
   10650:	bne.n	1061e <_dtoa_r+0xc86>
   10652:	ldr	r3, [sp, #92]	; 0x5c
   10654:	add	r5, r3
   10656:	movs	r2, #0
   10658:	ldr	r3, [pc, #244]	; (10750 <_dtoa_r+0xdb8>)
   1065a:	ldrd	r0, r1, [sp, #80]	; 0x50
   1065e:	bl	a57c <__adddf3>
   10662:	mov	r2, r6
   10664:	mov	r3, r7
   10666:	bl	adc4 <__aeabi_dcmplt>
   1066a:	cmp	r0, #0
   1066c:	beq.n	10700 <_dtoa_r+0xd68>
   1066e:	ldr	r3, [sp, #88]	; 0x58
   10670:	str	r3, [sp, #16]
   10672:	ldrb.w	r4, [r5, #-1]
   10676:	b.w	fd12 <_dtoa_r+0x37a>
   1067a:	ldr	r3, [sp, #28]
   1067c:	ldr	r2, [sp, #32]
   1067e:	subs	r5, r3, r2
   10680:	movs	r3, #0
   10682:	b.w	fd7e <_dtoa_r+0x3e6>
   10686:	movs	r7, #0
   10688:	b.n	10420 <_dtoa_r+0xa88>
   1068a:	ldr	r3, [sp, #96]	; 0x60
   1068c:	ldr	r7, [sp, #24]
   1068e:	ldr	r5, [sp, #28]
   10690:	rsb	r3, r3, #54	; 0x36
   10694:	b.w	fd7e <_dtoa_r+0x3e6>
   10698:	ldrd	r6, r7, [sp, #64]	; 0x40
   1069c:	mov.w	sl, #2
   106a0:	b.n	10058 <_dtoa_r+0x6c0>
   106a2:	ldr	r3, [sp, #32]
   106a4:	cmp	r3, #0
   106a6:	beq.w	1042c <_dtoa_r+0xa94>
   106aa:	ldr	r3, [sp, #56]	; 0x38
   106ac:	cmp	r3, #0
   106ae:	ble.w	1050e <_dtoa_r+0xb76>
   106b2:	movs	r2, #0
   106b4:	ldr	r3, [pc, #148]	; (1074c <_dtoa_r+0xdb4>)
   106b6:	mov	r0, r6
   106b8:	mov	r1, r7
   106ba:	bl	a8e0 <__aeabi_dmul>
   106be:	mov	r6, r0
   106c0:	mov	r7, r1
   106c2:	add.w	r0, sl, #1
   106c6:	bl	a814 <__aeabi_i2d>
   106ca:	mov	r2, r6
   106cc:	mov	r3, r7
   106ce:	bl	a8e0 <__aeabi_dmul>
   106d2:	movs	r2, #0
   106d4:	ldr	r3, [pc, #100]	; (1073c <_dtoa_r+0xda4>)
   106d6:	bl	a57c <__adddf3>
   106da:	ldr	r2, [sp, #16]
   106dc:	ldr	r3, [sp, #56]	; 0x38
   106de:	str	r3, [sp, #72]	; 0x48
   106e0:	subs	r2, #1
   106e2:	mov	r4, r0
   106e4:	sub.w	r5, r1, #54525952	; 0x3400000
   106e8:	str	r2, [sp, #88]	; 0x58
   106ea:	b.n	1009a <_dtoa_r+0x702>
   106ec:	str	r4, [sp, #40]	; 0x28
   106ee:	b.n	101fa <_dtoa_r+0x862>
   106f0:	movs	r2, #57	; 0x39
   106f2:	mov	fp, r6
   106f4:	str	r4, [sp, #40]	; 0x28
   106f6:	mov	r6, r8
   106f8:	strb	r2, [r7, #0]
   106fa:	adds	r5, r7, #1
   106fc:	b.w	feea <_dtoa_r+0x552>
   10700:	ldrd	r2, r3, [sp, #80]	; 0x50
   10704:	movs	r0, #0
   10706:	ldr	r1, [pc, #72]	; (10750 <_dtoa_r+0xdb8>)
   10708:	bl	a578 <__aeabi_dsub>
   1070c:	mov	r2, r6
   1070e:	mov	r3, r7
   10710:	bl	ae00 <__aeabi_dcmpgt>
   10714:	cbnz	r0, 1071a <_dtoa_r+0xd82>
   10716:	b.n	1050e <_dtoa_r+0xb76>
   10718:	mov	r5, r2
   1071a:	ldrb.w	r3, [r5, #-1]
   1071e:	cmp	r3, #48	; 0x30
   10720:	add.w	r2, r5, #4294967295
   10724:	beq.n	10718 <_dtoa_r+0xd80>
   10726:	b.n	1019c <_dtoa_r+0x804>
   10728:	ldr	r3, [sp, #88]	; 0x58
   1072a:	str	r3, [sp, #16]
   1072c:	b.w	fd12 <_dtoa_r+0x37a>
   10730:	cmp.w	sl, #0
   10734:	bne.w	10230 <_dtoa_r+0x898>
   10738:	b.n	10400 <_dtoa_r+0xa68>
   1073a:	nop
   1073c:	.word	0x401c0000
   10740:	.word	0x40140000
   10744:	.word	0x00013428
   10748:	.word	0x000134f0
   1074c:	.word	0x40240000
   10750:	.word	0x3fe00000
   10754:	cmp	r3, #57	; 0x39
   10756:	mov	fp, sl
   10758:	mov	sl, r3
   1075a:	beq.n	106f0 <_dtoa_r+0xd58>
   1075c:	cmp.w	fp, #0
   10760:	bgt.w	104de <_dtoa_r+0xb46>
   10764:	b.n	104e2 <_dtoa_r+0xb4a>
   10766:	bne.w	104e2 <_dtoa_r+0xb4a>
   1076a:	tst.w	sl, #1
   1076e:	beq.w	104e2 <_dtoa_r+0xb4a>
   10772:	b.n	104d6 <_dtoa_r+0xb3e>
   10774:	ldr	r3, [sp, #0]
   10776:	cmp	r3, #2
   10778:	bgt.n	107c6 <_dtoa_r+0xe2e>
   1077a:	ldr	r3, [sp, #56]	; 0x38
   1077c:	b.n	1039a <_dtoa_r+0xa02>
   1077e:	mov.w	sl, #2
   10782:	b.n	10058 <_dtoa_r+0x6c0>
   10784:	ldr	r3, [sp, #0]
   10786:	cmp	r3, #2
   10788:	bgt.n	107c6 <_dtoa_r+0xe2e>
   1078a:	ldr	r3, [sp, #56]	; 0x38
   1078c:	b.n	1026a <_dtoa_r+0x8d2>
   1078e:	movs	r4, #0
   10790:	str.w	r4, [r9, #68]	; 0x44
   10794:	mov	r1, r4
   10796:	mov	r0, r9
   10798:	bl	11260 <_Balloc>
   1079c:	mov.w	r3, #4294967295
   107a0:	str	r3, [sp, #32]
   107a2:	str	r3, [sp, #56]	; 0x38
   107a4:	movs	r3, #1
   107a6:	str	r0, [sp, #36]	; 0x24
   107a8:	str	r4, [sp, #20]
   107aa:	str.w	r0, [r9, #64]	; 0x40
   107ae:	str	r3, [sp, #44]	; 0x2c
   107b0:	b.w	fbac <_dtoa_r+0x214>
   107b4:	beq.w	fe48 <_dtoa_r+0x4b0>
   107b8:	rsb	r0, r0, #60	; 0x3c
   107bc:	b.w	fe3e <_dtoa_r+0x4a6>
   107c0:	movs	r6, #1
   107c2:	b.w	fb3e <_dtoa_r+0x1a6>
   107c6:	ldr	r3, [sp, #56]	; 0x38
   107c8:	str	r3, [sp, #32]
   107ca:	b.n	103aa <_dtoa_r+0xa12>

000107cc <__libc_fini_array>:
   107cc:	push	{r3, r4, r5, lr}
   107ce:	ldr	r5, [pc, #28]	; (107ec <__libc_fini_array+0x20>)
   107d0:	ldr	r4, [pc, #28]	; (107f0 <__libc_fini_array+0x24>)
   107d2:	subs	r4, r5, r4
   107d4:	asrs	r4, r4, #2
   107d6:	beq.n	107e4 <__libc_fini_array+0x18>
   107d8:	subs	r4, #1
   107da:	ldr.w	r3, [r5, #-4]!
   107de:	blx	r3
   107e0:	cmp	r4, #0
   107e2:	bne.n	107d8 <__libc_fini_array+0xc>
   107e4:	ldmia.w	sp!, {r3, r4, r5, lr}
   107e8:	b.w	13548 <__init_array_end>
	...

000107f4 <_malloc_trim_r>:
   107f4:	push	{r3, r4, r5, r6, r7, lr}
   107f6:	ldr	r7, [pc, #140]	; (10884 <_malloc_trim_r+0x90>)
   107f8:	mov	r4, r1
   107fa:	mov	r6, r0
   107fc:	bl	bacc <__malloc_lock>
   10800:	ldr	r3, [r7, #8]
   10802:	ldr	r5, [r3, #4]
   10804:	bic.w	r5, r5, #3
   10808:	subs	r1, r5, r4
   1080a:	addw	r1, r1, #4079	; 0xfef
   1080e:	bic.w	r1, r1, #4080	; 0xff0
   10812:	bic.w	r1, r1, #15
   10816:	sub.w	r4, r1, #4096	; 0x1000
   1081a:	cmp.w	r4, #4096	; 0x1000
   1081e:	blt.n	10830 <_malloc_trim_r+0x3c>
   10820:	movs	r1, #0
   10822:	mov	r0, r6
   10824:	bl	beb4 <_sbrk_r>
   10828:	ldr	r3, [r7, #8]
   1082a:	add	r3, r5
   1082c:	cmp	r0, r3
   1082e:	beq.n	1083a <_malloc_trim_r+0x46>
   10830:	mov	r0, r6
   10832:	bl	bad0 <__malloc_unlock>
   10836:	movs	r0, #0
   10838:	pop	{r3, r4, r5, r6, r7, pc}
   1083a:	negs	r1, r4
   1083c:	mov	r0, r6
   1083e:	bl	beb4 <_sbrk_r>
   10842:	adds	r0, #1
   10844:	beq.n	10862 <_malloc_trim_r+0x6e>
   10846:	ldr	r3, [pc, #64]	; (10888 <_malloc_trim_r+0x94>)
   10848:	ldr	r2, [r7, #8]
   1084a:	ldr	r1, [r3, #0]
   1084c:	subs	r5, r5, r4
   1084e:	orr.w	r5, r5, #1
   10852:	mov	r0, r6
   10854:	subs	r1, r1, r4
   10856:	str	r5, [r2, #4]
   10858:	str	r1, [r3, #0]
   1085a:	bl	bad0 <__malloc_unlock>
   1085e:	movs	r0, #1
   10860:	pop	{r3, r4, r5, r6, r7, pc}
   10862:	movs	r1, #0
   10864:	mov	r0, r6
   10866:	bl	beb4 <_sbrk_r>
   1086a:	ldr	r2, [r7, #8]
   1086c:	subs	r3, r0, r2
   1086e:	cmp	r3, #15
   10870:	ble.n	10830 <_malloc_trim_r+0x3c>
   10872:	ldr	r4, [pc, #24]	; (1088c <_malloc_trim_r+0x98>)
   10874:	ldr	r1, [pc, #16]	; (10888 <_malloc_trim_r+0x94>)
   10876:	ldr	r4, [r4, #0]
   10878:	orr.w	r3, r3, #1
   1087c:	subs	r0, r0, r4
   1087e:	str	r3, [r2, #4]
   10880:	str	r0, [r1, #0]
   10882:	b.n	10830 <_malloc_trim_r+0x3c>
   10884:	.word	0x1fff1998
   10888:	.word	0x2001a820
   1088c:	.word	0x1fff1da4

00010890 <_free_r>:
   10890:	cmp	r1, #0
   10892:	beq.n	10920 <_free_r+0x90>
   10894:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10898:	mov	r5, r1
   1089a:	mov	r8, r0
   1089c:	bl	bacc <__malloc_lock>
   108a0:	ldr.w	r7, [r5, #-4]
   108a4:	ldr	r1, [pc, #424]	; (10a50 <_free_r+0x1c0>)
   108a6:	bic.w	r3, r7, #1
   108aa:	sub.w	r4, r5, #8
   108ae:	adds	r2, r4, r3
   108b0:	ldr	r6, [r1, #8]
   108b2:	ldr	r0, [r2, #4]
   108b4:	cmp	r2, r6
   108b6:	bic.w	r0, r0, #3
   108ba:	beq.n	10982 <_free_r+0xf2>
   108bc:	lsls	r6, r7, #31
   108be:	str	r0, [r2, #4]
   108c0:	bmi.n	108da <_free_r+0x4a>
   108c2:	ldr.w	r7, [r5, #-8]
   108c6:	subs	r4, r4, r7
   108c8:	add.w	lr, r1, #8
   108cc:	ldr	r5, [r4, #8]
   108ce:	cmp	r5, lr
   108d0:	add	r3, r7
   108d2:	beq.n	109b4 <_free_r+0x124>
   108d4:	ldr	r7, [r4, #12]
   108d6:	str	r7, [r5, #12]
   108d8:	str	r5, [r7, #8]
   108da:	adds	r5, r2, r0
   108dc:	ldr	r5, [r5, #4]
   108de:	lsls	r5, r5, #31
   108e0:	bpl.n	10968 <_free_r+0xd8>
   108e2:	orr.w	r2, r3, #1
   108e6:	str	r2, [r4, #4]
   108e8:	str	r3, [r4, r3]
   108ea:	cmp.w	r3, #512	; 0x200
   108ee:	bcs.n	10922 <_free_r+0x92>
   108f0:	lsrs	r3, r3, #3
   108f2:	adds	r2, r3, #1
   108f4:	ldr	r5, [r1, #4]
   108f6:	ldr.w	r7, [r1, r2, lsl #3]
   108fa:	str	r7, [r4, #8]
   108fc:	movs	r0, #1
   108fe:	asrs	r3, r3, #2
   10900:	lsl.w	r3, r0, r3
   10904:	add.w	r0, r1, r2, lsl #3
   10908:	orrs	r5, r3
   1090a:	subs	r0, #8
   1090c:	str	r0, [r4, #12]
   1090e:	str	r5, [r1, #4]
   10910:	str.w	r4, [r1, r2, lsl #3]
   10914:	str	r4, [r7, #12]
   10916:	mov	r0, r8
   10918:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1091c:	b.w	bad0 <__malloc_unlock>
   10920:	bx	lr
   10922:	lsrs	r2, r3, #9
   10924:	cmp	r2, #4
   10926:	bhi.n	109d0 <_free_r+0x140>
   10928:	lsrs	r2, r3, #6
   1092a:	add.w	r7, r2, #57	; 0x39
   1092e:	lsls	r7, r7, #1
   10930:	add.w	r5, r2, #56	; 0x38
   10934:	add.w	r0, r1, r7, lsl #2
   10938:	ldr.w	r2, [r1, r7, lsl #2]
   1093c:	ldr	r1, [pc, #272]	; (10a50 <_free_r+0x1c0>)
   1093e:	subs	r0, #8
   10940:	cmp	r0, r2
   10942:	beq.n	109e0 <_free_r+0x150>
   10944:	ldr	r1, [r2, #4]
   10946:	bic.w	r1, r1, #3
   1094a:	cmp	r3, r1
   1094c:	bcs.n	10954 <_free_r+0xc4>
   1094e:	ldr	r2, [r2, #8]
   10950:	cmp	r0, r2
   10952:	bne.n	10944 <_free_r+0xb4>
   10954:	ldr	r0, [r2, #12]
   10956:	str	r0, [r4, #12]
   10958:	str	r2, [r4, #8]
   1095a:	str	r4, [r0, #8]
   1095c:	str	r4, [r2, #12]
   1095e:	mov	r0, r8
   10960:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   10964:	b.w	bad0 <__malloc_unlock>
   10968:	ldr	r5, [r2, #8]
   1096a:	ldr	r7, [pc, #232]	; (10a54 <_free_r+0x1c4>)
   1096c:	cmp	r5, r7
   1096e:	add	r3, r0
   10970:	beq.n	109f2 <_free_r+0x162>
   10972:	ldr	r0, [r2, #12]
   10974:	str	r0, [r5, #12]
   10976:	orr.w	r2, r3, #1
   1097a:	str	r5, [r0, #8]
   1097c:	str	r2, [r4, #4]
   1097e:	str	r3, [r4, r3]
   10980:	b.n	108ea <_free_r+0x5a>
   10982:	lsls	r7, r7, #31
   10984:	add	r3, r0
   10986:	bmi.n	10998 <_free_r+0x108>
   10988:	ldr.w	r2, [r5, #-8]
   1098c:	subs	r4, r4, r2
   1098e:	add	r3, r2
   10990:	ldr	r0, [r4, #8]
   10992:	ldr	r2, [r4, #12]
   10994:	str	r2, [r0, #12]
   10996:	str	r0, [r2, #8]
   10998:	ldr	r2, [pc, #188]	; (10a58 <_free_r+0x1c8>)
   1099a:	ldr	r2, [r2, #0]
   1099c:	orr.w	r0, r3, #1
   109a0:	cmp	r3, r2
   109a2:	str	r0, [r4, #4]
   109a4:	str	r4, [r1, #8]
   109a6:	bcc.n	10916 <_free_r+0x86>
   109a8:	ldr	r3, [pc, #176]	; (10a5c <_free_r+0x1cc>)
   109aa:	mov	r0, r8
   109ac:	ldr	r1, [r3, #0]
   109ae:	bl	107f4 <_malloc_trim_r>
   109b2:	b.n	10916 <_free_r+0x86>
   109b4:	adds	r1, r2, r0
   109b6:	ldr	r1, [r1, #4]
   109b8:	lsls	r1, r1, #31
   109ba:	bmi.n	10a46 <_free_r+0x1b6>
   109bc:	ldr	r1, [r2, #8]
   109be:	ldr	r2, [r2, #12]
   109c0:	str	r2, [r1, #12]
   109c2:	add	r3, r0
   109c4:	orr.w	r0, r3, #1
   109c8:	str	r1, [r2, #8]
   109ca:	str	r0, [r4, #4]
   109cc:	str	r3, [r4, r3]
   109ce:	b.n	10916 <_free_r+0x86>
   109d0:	cmp	r2, #20
   109d2:	bhi.n	10a04 <_free_r+0x174>
   109d4:	add.w	r7, r2, #92	; 0x5c
   109d8:	lsls	r7, r7, #1
   109da:	add.w	r5, r2, #91	; 0x5b
   109de:	b.n	10934 <_free_r+0xa4>
   109e0:	asrs	r2, r5, #2
   109e2:	ldr	r3, [r1, #4]
   109e4:	movs	r5, #1
   109e6:	lsl.w	r2, r5, r2
   109ea:	orrs	r3, r2
   109ec:	str	r3, [r1, #4]
   109ee:	mov	r2, r0
   109f0:	b.n	10956 <_free_r+0xc6>
   109f2:	orr.w	r2, r3, #1
   109f6:	str	r4, [r1, #20]
   109f8:	str	r4, [r1, #16]
   109fa:	str	r5, [r4, #12]
   109fc:	str	r5, [r4, #8]
   109fe:	str	r2, [r4, #4]
   10a00:	str	r3, [r4, r3]
   10a02:	b.n	10916 <_free_r+0x86>
   10a04:	cmp	r2, #84	; 0x54
   10a06:	bhi.n	10a16 <_free_r+0x186>
   10a08:	lsrs	r2, r3, #12
   10a0a:	add.w	r7, r2, #111	; 0x6f
   10a0e:	lsls	r7, r7, #1
   10a10:	add.w	r5, r2, #110	; 0x6e
   10a14:	b.n	10934 <_free_r+0xa4>
   10a16:	cmp.w	r2, #340	; 0x154
   10a1a:	bhi.n	10a2a <_free_r+0x19a>
   10a1c:	lsrs	r2, r3, #15
   10a1e:	add.w	r7, r2, #120	; 0x78
   10a22:	lsls	r7, r7, #1
   10a24:	add.w	r5, r2, #119	; 0x77
   10a28:	b.n	10934 <_free_r+0xa4>
   10a2a:	movw	r0, #1364	; 0x554
   10a2e:	cmp	r2, r0
   10a30:	bhi.n	10a40 <_free_r+0x1b0>
   10a32:	lsrs	r2, r3, #18
   10a34:	add.w	r7, r2, #125	; 0x7d
   10a38:	lsls	r7, r7, #1
   10a3a:	add.w	r5, r2, #124	; 0x7c
   10a3e:	b.n	10934 <_free_r+0xa4>
   10a40:	movs	r7, #254	; 0xfe
   10a42:	movs	r5, #126	; 0x7e
   10a44:	b.n	10934 <_free_r+0xa4>
   10a46:	orr.w	r2, r3, #1
   10a4a:	str	r2, [r4, #4]
   10a4c:	str	r3, [r4, r3]
   10a4e:	b.n	10916 <_free_r+0x86>
   10a50:	.word	0x1fff1998
   10a54:	.word	0x1fff19a0
   10a58:	.word	0x1fff1da0
   10a5c:	.word	0x2001a81c

00010a60 <rshift>:
   10a60:	ldr	r2, [r0, #16]
   10a62:	asrs	r3, r1, #5
   10a64:	cmp	r3, r2
   10a66:	bge.n	10ac6 <rshift+0x66>
   10a68:	push	{r4, r5, r6, r7, lr}
   10a6a:	ands.w	r1, r1, #31
   10a6e:	add.w	r6, r0, #20
   10a72:	add.w	r2, r6, r2, lsl #2
   10a76:	add.w	lr, r6, r3, lsl #2
   10a7a:	beq.n	10ad0 <rshift+0x70>
   10a7c:	ldr.w	r3, [r6, r3, lsl #2]
   10a80:	add.w	r5, lr, #4
   10a84:	cmp	r2, r5
   10a86:	lsr.w	r4, r3, r1
   10a8a:	rsb	ip, r1, #32
   10a8e:	bls.n	10b04 <rshift+0xa4>
   10a90:	add.w	r7, r0, #16
   10a94:	ldr	r3, [r5, #0]
   10a96:	lsl.w	r3, r3, ip
   10a9a:	orrs	r3, r4
   10a9c:	str.w	r3, [r7, #4]!
   10aa0:	ldr.w	r3, [r5], #4
   10aa4:	cmp	r2, r5
   10aa6:	lsr.w	r4, r3, r1
   10aaa:	bhi.n	10a94 <rshift+0x34>
   10aac:	rsb	r2, lr, r2
   10ab0:	subs	r2, #5
   10ab2:	bic.w	r2, r2, #3
   10ab6:	adds	r2, #4
   10ab8:	add	r2, r6
   10aba:	str	r4, [r2, #0]
   10abc:	cbz	r4, 10ac0 <rshift+0x60>
   10abe:	adds	r2, #4
   10ac0:	subs	r3, r2, r6
   10ac2:	asrs	r3, r3, #2
   10ac4:	b.n	10af4 <rshift+0x94>
   10ac6:	movs	r3, #0
   10ac8:	str	r3, [r0, #16]
   10aca:	movs	r3, #0
   10acc:	str	r3, [r0, #20]
   10ace:	bx	lr
   10ad0:	cmp	r2, lr
   10ad2:	bls.n	10afa <rshift+0x9a>
   10ad4:	add.w	r4, r0, #16
   10ad8:	mov	r1, lr
   10ada:	ldr.w	r5, [r1], #4
   10ade:	str.w	r5, [r4, #4]!
   10ae2:	cmp	r2, r1
   10ae4:	bhi.n	10ada <rshift+0x7a>
   10ae6:	mvn.w	r3, lr
   10aea:	add	r3, r2
   10aec:	bic.w	r3, r3, #3
   10af0:	adds	r3, #4
   10af2:	asrs	r3, r3, #2
   10af4:	str	r3, [r0, #16]
   10af6:	cbz	r3, 10afe <rshift+0x9e>
   10af8:	pop	{r4, r5, r6, r7, pc}
   10afa:	movs	r3, #0
   10afc:	str	r3, [r0, #16]
   10afe:	movs	r3, #0
   10b00:	str	r3, [r0, #20]
   10b02:	pop	{r4, r5, r6, r7, pc}
   10b04:	mov	r2, r6
   10b06:	b.n	10aba <rshift+0x5a>

00010b08 <__gethex>:
   10b08:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10b0c:	sub	sp, #44	; 0x2c
   10b0e:	mov	r9, r1
   10b10:	str	r0, [sp, #20]
   10b12:	ldr	r0, [sp, #88]	; 0x58
   10b14:	str	r2, [sp, #12]
   10b16:	str	r3, [sp, #32]
   10b18:	bl	111e4 <__localeconv_l>
   10b1c:	ldr	r3, [r0, #0]
   10b1e:	str	r3, [sp, #8]
   10b20:	mov	r0, r3
   10b22:	mov	r4, r3
   10b24:	bl	bf80 <strlen>
   10b28:	ldr.w	r3, [r9]
   10b2c:	str	r0, [sp, #0]
   10b2e:	ldrb	r2, [r3, #2]
   10b30:	adds	r1, r4, r0
   10b32:	cmp	r2, #48	; 0x30
   10b34:	ldrb.w	fp, [r1, #-1]
   10b38:	bne.w	10e8e <__gethex+0x386>
   10b3c:	adds	r3, #3
   10b3e:	mov.w	r8, #0
   10b42:	mov	r4, r3
   10b44:	ldrb.w	r2, [r3], #1
   10b48:	cmp	r2, #48	; 0x30
   10b4a:	add.w	r8, r8, #1
   10b4e:	beq.n	10b42 <__gethex+0x3a>
   10b50:	ldr	r6, [pc, #712]	; (10e1c <__gethex+0x314>)
   10b52:	ldrb	r3, [r6, r2]
   10b54:	cmp	r3, #0
   10b56:	beq.w	10d3a <__gethex+0x232>
   10b5a:	ldrb	r3, [r4, #0]
   10b5c:	mov.w	sl, #0
   10b60:	ldrb	r3, [r6, r3]
   10b62:	mov	r5, sl
   10b64:	mov	r7, r4
   10b66:	cbz	r3, 10b72 <__gethex+0x6a>
   10b68:	ldrb.w	r3, [r7, #1]!
   10b6c:	ldrb	r3, [r6, r3]
   10b6e:	cmp	r3, #0
   10b70:	bne.n	10b68 <__gethex+0x60>
   10b72:	ldr	r2, [sp, #0]
   10b74:	ldr	r1, [sp, #8]
   10b76:	mov	r0, r7
   10b78:	bl	c05c <strncmp>
   10b7c:	cmp	r0, #0
   10b7e:	beq.w	10ca6 <__gethex+0x19e>
   10b82:	ldrb	r3, [r7, #0]
   10b84:	cmp	r5, #0
   10b86:	beq.w	10e6c <__gethex+0x364>
   10b8a:	subs	r5, r5, r7
   10b8c:	lsls	r2, r5, #2
   10b8e:	str	r2, [sp, #4]
   10b90:	cmp	r3, #80	; 0x50
   10b92:	beq.w	10cb8 <__gethex+0x1b0>
   10b96:	cmp	r3, #112	; 0x70
   10b98:	beq.w	10cb8 <__gethex+0x1b0>
   10b9c:	mov	r5, r7
   10b9e:	str.w	r7, [r9]
   10ba2:	cmp.w	sl, #0
   10ba6:	bne.w	10d18 <__gethex+0x210>
   10baa:	subs	r3, r5, r4
   10bac:	subs	r3, #1
   10bae:	cmp	r3, #7
   10bb0:	mov	r1, sl
   10bb2:	ble.n	10bbe <__gethex+0xb6>
   10bb4:	asrs	r3, r3, #1
   10bb6:	cmp	r3, #7
   10bb8:	add.w	r1, r1, #1
   10bbc:	bgt.n	10bb4 <__gethex+0xac>
   10bbe:	ldr	r0, [sp, #20]
   10bc0:	bl	11260 <_Balloc>
   10bc4:	mov	r3, r0
   10bc6:	adds	r3, #20
   10bc8:	cmp	r5, r4
   10bca:	str	r0, [sp, #16]
   10bcc:	str	r3, [sp, #28]
   10bce:	bls.w	10f78 <__gethex+0x470>
   10bd2:	mov	r9, r3
   10bd4:	ldr	r3, [sp, #0]
   10bd6:	mov.w	r8, #0
   10bda:	rsb	r3, r3, #1
   10bde:	mov	r7, r8
   10be0:	str	r3, [sp, #24]
   10be2:	b.n	10c04 <__gethex+0xfc>
   10be4:	cmp	r7, #32
   10be6:	beq.w	10d28 <__gethex+0x220>
   10bea:	mov	r2, r7
   10bec:	adds	r7, #4
   10bee:	ldrb.w	r3, [r5, #-1]
   10bf2:	ldrb	r3, [r6, r3]
   10bf4:	mov	r5, sl
   10bf6:	and.w	r3, r3, #15
   10bfa:	lsls	r3, r2
   10bfc:	cmp	r5, r4
   10bfe:	orr.w	r8, r8, r3
   10c02:	bls.n	10c30 <__gethex+0x128>
   10c04:	ldrb.w	r3, [r5, #-1]
   10c08:	cmp	r3, fp
   10c0a:	add.w	sl, r5, #4294967295
   10c0e:	bne.n	10be4 <__gethex+0xdc>
   10c10:	ldr	r3, [sp, #24]
   10c12:	add	r3, sl
   10c14:	cmp	r3, r4
   10c16:	bcc.n	10be4 <__gethex+0xdc>
   10c18:	mov	r0, r3
   10c1a:	ldr	r2, [sp, #0]
   10c1c:	ldr	r1, [sp, #8]
   10c1e:	str	r3, [sp, #36]	; 0x24
   10c20:	bl	c05c <strncmp>
   10c24:	ldr	r3, [sp, #36]	; 0x24
   10c26:	cmp	r0, #0
   10c28:	bne.n	10be4 <__gethex+0xdc>
   10c2a:	mov	r5, r3
   10c2c:	cmp	r5, r4
   10c2e:	bhi.n	10c04 <__gethex+0xfc>
   10c30:	str.w	r8, [r9], #4
   10c34:	ldr	r3, [sp, #28]
   10c36:	ldr	r2, [sp, #16]
   10c38:	rsb	r9, r3, r9
   10c3c:	mov.w	r3, r9, asr #2
   10c40:	str	r3, [r2, #16]
   10c42:	mov	r0, r8
   10c44:	mov.w	r9, r3, lsl #5
   10c48:	bl	113d8 <__hi0bits>
   10c4c:	ldr	r3, [sp, #12]
   10c4e:	ldr	r6, [r3, #0]
   10c50:	rsb	r0, r0, r9
   10c54:	cmp	r0, r6
   10c56:	bgt.w	10e20 <__gethex+0x318>
   10c5a:	blt.w	10e70 <__gethex+0x368>
   10c5e:	movs	r7, #0
   10c60:	ldr	r3, [sp, #12]
   10c62:	ldr	r2, [sp, #4]
   10c64:	ldr	r3, [r3, #8]
   10c66:	cmp	r2, r3
   10c68:	bgt.w	10d9a <__gethex+0x292>
   10c6c:	ldr	r0, [sp, #12]
   10c6e:	ldr	r1, [sp, #4]
   10c70:	ldr	r3, [r0, #4]
   10c72:	cmp	r1, r3
   10c74:	bge.w	10de2 <__gethex+0x2da>
   10c78:	subs	r5, r3, r1
   10c7a:	cmp	r6, r5
   10c7c:	bgt.w	10e9e <__gethex+0x396>
   10c80:	ldr	r2, [r0, #12]
   10c82:	cmp	r2, #2
   10c84:	beq.w	10f86 <__gethex+0x47e>
   10c88:	cmp	r2, #3
   10c8a:	beq.w	10f46 <__gethex+0x43e>
   10c8e:	cmp	r2, #1
   10c90:	beq.w	10f8e <__gethex+0x486>
   10c94:	ldr	r0, [sp, #20]
   10c96:	ldr	r1, [sp, #16]
   10c98:	bl	112ac <_Bfree>
   10c9c:	ldr	r2, [sp, #80]	; 0x50
   10c9e:	movs	r3, #0
   10ca0:	str	r3, [r2, #0]
   10ca2:	movs	r0, #80	; 0x50
   10ca4:	b.n	10d22 <__gethex+0x21a>
   10ca6:	cmp	r5, #0
   10ca8:	beq.w	10ede <__gethex+0x3d6>
   10cac:	ldrb	r3, [r7, #0]
   10cae:	b.n	10b8a <__gethex+0x82>
   10cb0:	movs	r3, #0
   10cb2:	str	r3, [sp, #4]
   10cb4:	mov.w	sl, #1
   10cb8:	ldrb	r3, [r7, #1]
   10cba:	cmp	r3, #43	; 0x2b
   10cbc:	beq.w	10e18 <__gethex+0x310>
   10cc0:	cmp	r3, #45	; 0x2d
   10cc2:	beq.n	10db0 <__gethex+0x2a8>
   10cc4:	adds	r1, r7, #1
   10cc6:	movs	r5, #0
   10cc8:	ldrb	r3, [r6, r3]
   10cca:	ldr	r0, [pc, #336]	; (10e1c <__gethex+0x314>)
   10ccc:	subs	r2, r3, #1
   10cce:	cmp	r2, #24
   10cd0:	bhi.w	10b9c <__gethex+0x94>
   10cd4:	ldrb	r2, [r1, #1]
   10cd6:	ldrb	r2, [r0, r2]
   10cd8:	subs	r0, r2, #1
   10cda:	cmp	r0, #24
   10cdc:	sub.w	r3, r3, #16
   10ce0:	add.w	r1, r1, #1
   10ce4:	bhi.n	10cfe <__gethex+0x1f6>
   10ce6:	ldrb.w	r0, [r1, #1]!
   10cea:	add.w	r3, r3, r3, lsl #2
   10cee:	add.w	r3, r2, r3, lsl #1
   10cf2:	ldrb	r2, [r6, r0]
   10cf4:	subs	r0, r2, #1
   10cf6:	cmp	r0, #24
   10cf8:	sub.w	r3, r3, #16
   10cfc:	bls.n	10ce6 <__gethex+0x1de>
   10cfe:	cbz	r5, 10d02 <__gethex+0x1fa>
   10d00:	negs	r3, r3
   10d02:	ldr	r2, [sp, #4]
   10d04:	mov	r5, r7
   10d06:	add	r2, r3
   10d08:	mov	r7, r1
   10d0a:	str	r2, [sp, #4]
   10d0c:	str.w	r7, [r9]
   10d10:	cmp.w	sl, #0
   10d14:	beq.w	10baa <__gethex+0xa2>
   10d18:	cmp.w	r8, #0
   10d1c:	ite	eq
   10d1e:	moveq	r0, #6
   10d20:	movne	r0, #0
   10d22:	add	sp, #44	; 0x2c
   10d24:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10d28:	str.w	r8, [r9]
   10d2c:	mov.w	r8, #0
   10d30:	add.w	r9, r9, #4
   10d34:	mov	r2, r8
   10d36:	movs	r7, #4
   10d38:	b.n	10bee <__gethex+0xe6>
   10d3a:	ldr	r5, [sp, #0]
   10d3c:	ldr	r1, [sp, #8]
   10d3e:	mov	r2, r5
   10d40:	mov	r0, r4
   10d42:	bl	c05c <strncmp>
   10d46:	cmp	r0, #0
   10d48:	beq.n	10db8 <__gethex+0x2b0>
   10d4a:	ldrb	r3, [r4, #0]
   10d4c:	mov	r7, r4
   10d4e:	cmp	r3, #80	; 0x50
   10d50:	beq.n	10cb0 <__gethex+0x1a8>
   10d52:	cmp	r3, #112	; 0x70
   10d54:	beq.n	10cb0 <__gethex+0x1a8>
   10d56:	str.w	r7, [r9]
   10d5a:	b.n	10d18 <__gethex+0x210>
   10d5c:	ldr	r3, [sp, #16]
   10d5e:	ldr	r3, [r3, #8]
   10d60:	cmp	r7, r3
   10d62:	bge.w	10fce <__gethex+0x4c6>
   10d66:	mov	r3, r7
   10d68:	ldr	r0, [sp, #16]
   10d6a:	add.w	r2, r0, r3, lsl #2
   10d6e:	movs	r1, #1
   10d70:	adds	r3, #1
   10d72:	cmp	r4, #2
   10d74:	str	r3, [r0, #16]
   10d76:	str	r1, [r2, #20]
   10d78:	beq.w	10fac <__gethex+0x4a4>
   10d7c:	cmp	r7, r3
   10d7e:	bge.w	10f38 <__gethex+0x430>
   10d82:	movs	r1, #1
   10d84:	ldr	r0, [sp, #16]
   10d86:	bl	10a60 <rshift>
   10d8a:	ldr	r3, [sp, #12]
   10d8c:	ldr	r2, [sp, #4]
   10d8e:	ldr	r3, [r3, #8]
   10d90:	adds	r2, #1
   10d92:	cmp	r2, r3
   10d94:	str	r2, [sp, #4]
   10d96:	ble.w	10f3e <__gethex+0x436>
   10d9a:	ldr	r0, [sp, #20]
   10d9c:	ldr	r1, [sp, #16]
   10d9e:	bl	112ac <_Bfree>
   10da2:	ldr	r2, [sp, #80]	; 0x50
   10da4:	movs	r3, #0
   10da6:	movs	r0, #163	; 0xa3
   10da8:	str	r3, [r2, #0]
   10daa:	add	sp, #44	; 0x2c
   10dac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10db0:	movs	r5, #1
   10db2:	ldrb	r3, [r7, #2]
   10db4:	adds	r1, r7, #2
   10db6:	b.n	10cc8 <__gethex+0x1c0>
   10db8:	ldrb	r2, [r4, r5]
   10dba:	ldrb	r3, [r6, r2]
   10dbc:	adds	r7, r4, r5
   10dbe:	cmp	r3, #0
   10dc0:	beq.n	10e96 <__gethex+0x38e>
   10dc2:	cmp	r2, #48	; 0x30
   10dc4:	mov	r4, r7
   10dc6:	bne.n	10dd2 <__gethex+0x2ca>
   10dc8:	ldrb.w	r3, [r4, #1]!
   10dcc:	cmp	r3, #48	; 0x30
   10dce:	beq.n	10dc8 <__gethex+0x2c0>
   10dd0:	ldrb	r3, [r6, r3]
   10dd2:	clz	sl, r3
   10dd6:	mov	r5, r7
   10dd8:	mov.w	sl, sl, lsr #5
   10ddc:	mov.w	r8, #1
   10de0:	b.n	10b64 <__gethex+0x5c>
   10de2:	movs	r4, #1
   10de4:	cbz	r7, 10e00 <__gethex+0x2f8>
   10de6:	ldr	r3, [sp, #12]
   10de8:	ldr	r3, [r3, #12]
   10dea:	cmp	r3, #2
   10dec:	beq.w	10efa <__gethex+0x3f2>
   10df0:	cmp	r3, #3
   10df2:	beq.w	10f02 <__gethex+0x3fa>
   10df6:	cmp	r3, #1
   10df8:	beq.w	10f66 <__gethex+0x45e>
   10dfc:	orr.w	r4, r4, #16
   10e00:	ldr	r3, [sp, #80]	; 0x50
   10e02:	mov	r2, r3
   10e04:	ldr	r3, [sp, #16]
   10e06:	str	r3, [r2, #0]
   10e08:	ldr	r3, [sp, #32]
   10e0a:	mov	r2, r3
   10e0c:	ldr	r3, [sp, #4]
   10e0e:	str	r3, [r2, #0]
   10e10:	mov	r0, r4
   10e12:	add	sp, #44	; 0x2c
   10e14:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10e18:	movs	r5, #0
   10e1a:	b.n	10db2 <__gethex+0x2aa>
   10e1c:	.word	0x00013324
   10e20:	subs	r4, r0, r6
   10e22:	mov	r1, r4
   10e24:	ldr	r0, [sp, #16]
   10e26:	bl	11ae8 <__any_on>
   10e2a:	cmp	r0, #0
   10e2c:	beq.n	10e9a <__gethex+0x392>
   10e2e:	subs	r2, r4, #1
   10e30:	asrs	r1, r2, #5
   10e32:	ldr	r0, [sp, #28]
   10e34:	and.w	r3, r2, #31
   10e38:	ldr.w	r1, [r0, r1, lsl #2]
   10e3c:	movs	r7, #1
   10e3e:	lsl.w	r3, r7, r3
   10e42:	tst	r3, r1
   10e44:	beq.n	10e5c <__gethex+0x354>
   10e46:	cmp	r2, r7
   10e48:	ble.w	10f82 <__gethex+0x47a>
   10e4c:	subs	r1, r4, #2
   10e4e:	ldr	r0, [sp, #16]
   10e50:	bl	11ae8 <__any_on>
   10e54:	cmp	r0, #0
   10e56:	beq.w	10f82 <__gethex+0x47a>
   10e5a:	movs	r7, #3
   10e5c:	ldr	r3, [sp, #4]
   10e5e:	ldr	r0, [sp, #16]
   10e60:	add	r3, r4
   10e62:	mov	r1, r4
   10e64:	str	r3, [sp, #4]
   10e66:	bl	10a60 <rshift>
   10e6a:	b.n	10c60 <__gethex+0x158>
   10e6c:	str	r5, [sp, #4]
   10e6e:	b.n	10b90 <__gethex+0x88>
   10e70:	subs	r4, r6, r0
   10e72:	ldr	r1, [sp, #16]
   10e74:	ldr	r0, [sp, #20]
   10e76:	mov	r2, r4
   10e78:	bl	11658 <__lshift>
   10e7c:	ldr	r3, [sp, #4]
   10e7e:	str	r0, [sp, #16]
   10e80:	subs	r3, r3, r4
   10e82:	str	r3, [sp, #4]
   10e84:	mov	r3, r0
   10e86:	adds	r3, #20
   10e88:	str	r3, [sp, #28]
   10e8a:	movs	r7, #0
   10e8c:	b.n	10c60 <__gethex+0x158>
   10e8e:	adds	r4, r3, #2
   10e90:	mov.w	r8, #0
   10e94:	b.n	10b50 <__gethex+0x48>
   10e96:	mov	r3, r2
   10e98:	b.n	10d4e <__gethex+0x246>
   10e9a:	mov	r7, r0
   10e9c:	b.n	10e5c <__gethex+0x354>
   10e9e:	subs	r4, r5, #1
   10ea0:	cmp	r7, #0
   10ea2:	bne.n	10f42 <__gethex+0x43a>
   10ea4:	cbz	r4, 10eb0 <__gethex+0x3a8>
   10ea6:	mov	r1, r4
   10ea8:	ldr	r0, [sp, #16]
   10eaa:	bl	11ae8 <__any_on>
   10eae:	mov	r7, r0
   10eb0:	asrs	r3, r4, #5
   10eb2:	ldr	r2, [sp, #28]
   10eb4:	ldr	r0, [sp, #16]
   10eb6:	ldr.w	r2, [r2, r3, lsl #2]
   10eba:	and.w	r4, r4, #31
   10ebe:	movs	r3, #1
   10ec0:	lsl.w	r4, r3, r4
   10ec4:	tst	r4, r2
   10ec6:	mov	r1, r5
   10ec8:	it	ne
   10eca:	orrne.w	r7, r7, #2
   10ece:	bl	10a60 <rshift>
   10ed2:	ldr	r3, [sp, #12]
   10ed4:	ldr	r3, [r3, #4]
   10ed6:	str	r3, [sp, #4]
   10ed8:	subs	r6, r6, r5
   10eda:	movs	r4, #2
   10edc:	b.n	10de4 <__gethex+0x2dc>
   10ede:	ldr	r1, [sp, #0]
   10ee0:	ldrb	r3, [r7, r1]
   10ee2:	ldrb	r2, [r6, r3]
   10ee4:	adds	r5, r7, r1
   10ee6:	mov	r7, r5
   10ee8:	cmp	r2, #0
   10eea:	beq.w	10b8a <__gethex+0x82>
   10eee:	ldrb.w	r3, [r7, #1]!
   10ef2:	ldrb	r2, [r6, r3]
   10ef4:	cmp	r2, #0
   10ef6:	bne.n	10eee <__gethex+0x3e6>
   10ef8:	b.n	10b8a <__gethex+0x82>
   10efa:	ldr	r3, [sp, #84]	; 0x54
   10efc:	rsb	r3, r3, #1
   10f00:	str	r3, [sp, #84]	; 0x54
   10f02:	ldr	r3, [sp, #84]	; 0x54
   10f04:	cmp	r3, #0
   10f06:	beq.w	10dfc <__gethex+0x2f4>
   10f0a:	ldr	r3, [sp, #16]
   10f0c:	ldr	r5, [sp, #28]
   10f0e:	ldr	r7, [r3, #16]
   10f10:	mov.w	r8, r7, lsl #2
   10f14:	add.w	r0, r5, r8
   10f18:	mov	r3, r5
   10f1a:	movs	r1, #0
   10f1c:	b.n	10f28 <__gethex+0x420>
   10f1e:	str.w	r1, [r3], #4
   10f22:	cmp	r0, r3
   10f24:	bls.w	10d5c <__gethex+0x254>
   10f28:	ldr	r2, [r3, #0]
   10f2a:	cmp.w	r2, #4294967295
   10f2e:	beq.n	10f1e <__gethex+0x416>
   10f30:	adds	r2, #1
   10f32:	cmp	r4, #2
   10f34:	str	r2, [r3, #0]
   10f36:	beq.n	10fac <__gethex+0x4a4>
   10f38:	ands.w	r6, r6, #31
   10f3c:	bne.n	10fba <__gethex+0x4b2>
   10f3e:	movs	r4, #33	; 0x21
   10f40:	b.n	10e00 <__gethex+0x2f8>
   10f42:	movs	r7, #1
   10f44:	b.n	10eb0 <__gethex+0x3a8>
   10f46:	ldr	r2, [sp, #84]	; 0x54
   10f48:	cmp	r2, #0
   10f4a:	beq.w	10c94 <__gethex+0x18c>
   10f4e:	ldr	r1, [sp, #32]
   10f50:	str	r3, [r1, #0]
   10f52:	ldr	r3, [sp, #28]
   10f54:	ldr	r1, [sp, #16]
   10f56:	movs	r2, #1
   10f58:	str	r2, [r1, #16]
   10f5a:	str	r2, [r3, #0]
   10f5c:	ldr	r3, [sp, #80]	; 0x50
   10f5e:	mov	r2, r3
   10f60:	movs	r0, #98	; 0x62
   10f62:	str	r1, [r2, #0]
   10f64:	b.n	10d22 <__gethex+0x21a>
   10f66:	lsls	r2, r7, #30
   10f68:	bpl.w	10dfc <__gethex+0x2f4>
   10f6c:	ldr	r3, [sp, #28]
   10f6e:	ldr	r3, [r3, #0]
   10f70:	orrs	r3, r7
   10f72:	lsls	r3, r3, #31
   10f74:	bmi.n	10f0a <__gethex+0x402>
   10f76:	b.n	10dfc <__gethex+0x2f4>
   10f78:	ldr.w	r9, [sp, #28]
   10f7c:	mov.w	r8, #0
   10f80:	b.n	10c30 <__gethex+0x128>
   10f82:	movs	r7, #2
   10f84:	b.n	10e5c <__gethex+0x354>
   10f86:	ldr	r2, [sp, #84]	; 0x54
   10f88:	cmp	r2, #0
   10f8a:	beq.n	10f4e <__gethex+0x446>
   10f8c:	b.n	10c94 <__gethex+0x18c>
   10f8e:	cmp	r6, r5
   10f90:	bne.w	10c94 <__gethex+0x18c>
   10f94:	cmp	r6, #1
   10f96:	ble.n	10f4e <__gethex+0x446>
   10f98:	subs	r1, r6, #1
   10f9a:	ldr	r0, [sp, #16]
   10f9c:	bl	11ae8 <__any_on>
   10fa0:	cmp	r0, #0
   10fa2:	beq.w	10c94 <__gethex+0x18c>
   10fa6:	ldr	r3, [sp, #12]
   10fa8:	ldr	r3, [r3, #4]
   10faa:	b.n	10f4e <__gethex+0x446>
   10fac:	ldr	r3, [sp, #12]
   10fae:	ldr	r3, [r3, #0]
   10fb0:	subs	r3, #1
   10fb2:	cmp	r6, r3
   10fb4:	beq.n	11000 <__gethex+0x4f8>
   10fb6:	movs	r4, #34	; 0x22
   10fb8:	b.n	10e00 <__gethex+0x2f8>
   10fba:	add	r5, r8
   10fbc:	rsb	r6, r6, #32
   10fc0:	ldr.w	r0, [r5, #-4]
   10fc4:	bl	113d8 <__hi0bits>
   10fc8:	cmp	r0, r6
   10fca:	bge.n	10f3e <__gethex+0x436>
   10fcc:	b.n	10d82 <__gethex+0x27a>
   10fce:	ldr	r3, [sp, #16]
   10fd0:	ldr.w	r9, [sp, #20]
   10fd4:	ldr	r1, [r3, #4]
   10fd6:	mov	r0, r9
   10fd8:	adds	r1, #1
   10fda:	bl	11260 <_Balloc>
   10fde:	ldr	r1, [sp, #16]
   10fe0:	ldr	r3, [r1, #16]
   10fe2:	adds	r2, r3, #2
   10fe4:	mov	r5, r0
   10fe6:	lsls	r2, r2, #2
   10fe8:	adds	r1, #12
   10fea:	adds	r0, #12
   10fec:	bl	8f3c <memcpy>
   10ff0:	ldr	r1, [sp, #16]
   10ff2:	mov	r0, r9
   10ff4:	bl	112ac <_Bfree>
   10ff8:	str	r5, [sp, #16]
   10ffa:	ldr	r3, [r5, #16]
   10ffc:	adds	r5, #20
   10ffe:	b.n	10d68 <__gethex+0x260>
   11000:	asrs	r3, r6, #5
   11002:	and.w	r6, r6, #31
   11006:	ldr.w	r2, [r5, r3, lsl #2]
   1100a:	movs	r3, #1
   1100c:	lsls	r3, r6
   1100e:	tst	r3, r2
   11010:	ite	ne
   11012:	movne	r4, #33	; 0x21
   11014:	moveq	r4, #34	; 0x22
   11016:	b.n	10e00 <__gethex+0x2f8>

00011018 <__match>:
   11018:	push	{r4, r5}
   1101a:	ldr	r4, [r0, #0]
   1101c:	b.n	11030 <__match+0x18>
   1101e:	ldrb.w	r3, [r4, #1]!
   11022:	sub.w	r5, r3, #65	; 0x41
   11026:	cmp	r5, #25
   11028:	it	ls
   1102a:	addls	r3, #32
   1102c:	cmp	r3, r2
   1102e:	bne.n	11042 <__match+0x2a>
   11030:	ldrb.w	r2, [r1], #1
   11034:	cmp	r2, #0
   11036:	bne.n	1101e <__match+0x6>
   11038:	adds	r4, #1
   1103a:	str	r4, [r0, #0]
   1103c:	movs	r0, #1
   1103e:	pop	{r4, r5}
   11040:	bx	lr
   11042:	movs	r0, #0
   11044:	pop	{r4, r5}
   11046:	bx	lr

00011048 <__hexnan>:
   11048:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1104c:	ldr	r3, [r1, #0]
   1104e:	ldr.w	r9, [pc, #372]	; 111c4 <__hexnan+0x17c>
   11052:	sub	sp, #20
   11054:	asrs	r1, r3, #5
   11056:	add.w	r1, r2, r1, lsl #2
   1105a:	ands.w	r3, r3, #31
   1105e:	str	r1, [sp, #4]
   11060:	itt	ne
   11062:	addne	r1, #4
   11064:	strne	r1, [sp, #4]
   11066:	ldr	r4, [sp, #4]
   11068:	str	r0, [sp, #8]
   1106a:	str	r3, [sp, #12]
   1106c:	movs	r3, #0
   1106e:	mov	r1, r3
   11070:	str.w	r3, [r4, #-4]
   11074:	mov	sl, r3
   11076:	mov	lr, r3
   11078:	ldr	r3, [sp, #8]
   1107a:	sub.w	ip, r4, #4
   1107e:	ldr	r5, [r3, #0]
   11080:	mov	r8, ip
   11082:	mov	r0, ip
   11084:	ldrb.w	r3, [r5, #1]!
   11088:	cbz	r3, 110d4 <__hexnan+0x8c>
   1108a:	ldrb.w	r4, [r9, r3]
   1108e:	cmp	r4, #0
   11090:	bne.n	1111a <__hexnan+0xd2>
   11092:	cmp	r3, #32
   11094:	bhi.n	11152 <__hexnan+0x10a>
   11096:	cmp	lr, sl
   11098:	ble.n	11084 <__hexnan+0x3c>
   1109a:	cmp	r0, r8
   1109c:	bcs.n	110c6 <__hexnan+0x7e>
   1109e:	cmp	r1, #7
   110a0:	bgt.n	110c6 <__hexnan+0x7e>
   110a2:	rsb	r1, r1, #8
   110a6:	lsls	r1, r1, #2
   110a8:	ldr	r6, [r0, #0]
   110aa:	rsb	fp, r1, #32
   110ae:	mov	r3, r0
   110b0:	ldr	r7, [r3, #4]
   110b2:	lsl.w	r4, r7, fp
   110b6:	orrs	r4, r6
   110b8:	lsr.w	r6, r7, r1
   110bc:	str	r4, [r3, #0]
   110be:	str.w	r6, [r3, #4]!
   110c2:	cmp	r8, r3
   110c4:	bhi.n	110b0 <__hexnan+0x68>
   110c6:	cmp	r0, r2
   110c8:	bhi.n	11140 <__hexnan+0xf8>
   110ca:	ldrb.w	r3, [r5, #1]!
   110ce:	movs	r1, #8
   110d0:	cmp	r3, #0
   110d2:	bne.n	1108a <__hexnan+0x42>
   110d4:	cmp.w	lr, #0
   110d8:	beq.n	11156 <__hexnan+0x10e>
   110da:	cmp	r0, r8
   110dc:	bcs.n	110e2 <__hexnan+0x9a>
   110de:	cmp	r1, #7
   110e0:	ble.n	1119c <__hexnan+0x154>
   110e2:	cmp	r0, r2
   110e4:	bls.n	1115e <__hexnan+0x116>
   110e6:	mov	r3, r2
   110e8:	ldr.w	r1, [r0], #4
   110ec:	str.w	r1, [r3], #4
   110f0:	cmp	ip, r0
   110f2:	bcs.n	110e8 <__hexnan+0xa0>
   110f4:	movs	r1, #0
   110f6:	str.w	r1, [r3], #4
   110fa:	cmp	ip, r3
   110fc:	bcs.n	110f6 <__hexnan+0xae>
   110fe:	ldr	r3, [sp, #4]
   11100:	ldr.w	r3, [r3, #-4]
   11104:	cbnz	r3, 11112 <__hexnan+0xca>
   11106:	cmp	r2, ip
   11108:	beq.n	11180 <__hexnan+0x138>
   1110a:	ldr.w	r3, [ip, #-4]!
   1110e:	cmp	r3, #0
   11110:	beq.n	11106 <__hexnan+0xbe>
   11112:	movs	r0, #5
   11114:	add	sp, #20
   11116:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1111a:	adds	r1, #1
   1111c:	cmp	r1, #8
   1111e:	add.w	lr, lr, #1
   11122:	ble.n	11132 <__hexnan+0xea>
   11124:	cmp	r0, r2
   11126:	bls.n	11084 <__hexnan+0x3c>
   11128:	movs	r3, #0
   1112a:	str.w	r3, [r0, #-4]
   1112e:	movs	r1, #1
   11130:	subs	r0, #4
   11132:	ldr	r3, [r0, #0]
   11134:	and.w	r4, r4, #15
   11138:	orr.w	r4, r4, r3, lsl #4
   1113c:	str	r4, [r0, #0]
   1113e:	b.n	11084 <__hexnan+0x3c>
   11140:	movs	r3, #0
   11142:	sub.w	r8, r0, #4
   11146:	str.w	r3, [r0, #-4]
   1114a:	mov	sl, lr
   1114c:	mov	r0, r8
   1114e:	mov	r1, r3
   11150:	b.n	11084 <__hexnan+0x3c>
   11152:	cmp	r3, #41	; 0x29
   11154:	beq.n	1118e <__hexnan+0x146>
   11156:	movs	r0, #4
   11158:	add	sp, #20
   1115a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1115e:	ldr	r3, [sp, #12]
   11160:	cmp	r3, #0
   11162:	beq.n	110fe <__hexnan+0xb6>
   11164:	ldr	r4, [sp, #4]
   11166:	ldr	r3, [sp, #12]
   11168:	ldr.w	r1, [r4, #-4]
   1116c:	rsb	r3, r3, #32
   11170:	mov.w	r0, #4294967295
   11174:	lsr.w	r3, r0, r3
   11178:	ands	r3, r1
   1117a:	str.w	r3, [r4, #-4]
   1117e:	b.n	11104 <__hexnan+0xbc>
   11180:	movs	r3, #1
   11182:	movs	r0, #5
   11184:	str.w	r3, [ip]
   11188:	add	sp, #20
   1118a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1118e:	ldr	r3, [sp, #8]
   11190:	adds	r5, #1
   11192:	str	r5, [r3, #0]
   11194:	cmp.w	lr, #0
   11198:	bne.n	110da <__hexnan+0x92>
   1119a:	b.n	11156 <__hexnan+0x10e>
   1119c:	rsb	r3, r1, #8
   111a0:	lsls	r3, r3, #2
   111a2:	ldr	r5, [r0, #0]
   111a4:	rsb	r7, r3, #32
   111a8:	mov	r1, r0
   111aa:	ldr	r6, [r1, #4]
   111ac:	lsl.w	r4, r6, r7
   111b0:	orrs	r4, r5
   111b2:	lsr.w	r5, r6, r3
   111b6:	str	r4, [r1, #0]
   111b8:	str.w	r5, [r1, #4]!
   111bc:	cmp	r8, r1
   111be:	bhi.n	111aa <__hexnan+0x162>
   111c0:	b.n	110e2 <__hexnan+0x9a>
   111c2:	nop
   111c4:	.word	0x00013324

000111c8 <iswspace>:
   111c8:	cmp	r0, #255	; 0xff
   111ca:	bls.n	111d0 <iswspace+0x8>
   111cc:	movs	r0, #0
   111ce:	bx	lr
   111d0:	push	{r4, lr}
   111d2:	mov	r4, r0
   111d4:	bl	b32c <__locale_ctype_ptr>
   111d8:	add	r0, r4
   111da:	ldrb	r0, [r0, #1]
   111dc:	and.w	r0, r0, #8
   111e0:	uxtb	r0, r0
   111e2:	pop	{r4, pc}

000111e4 <__localeconv_l>:
   111e4:	adds	r0, #240	; 0xf0
   111e6:	bx	lr

000111e8 <_localeconv_r>:
   111e8:	ldr	r2, [pc, #16]	; (111fc <_localeconv_r+0x14>)
   111ea:	ldr	r3, [pc, #20]	; (11200 <_localeconv_r+0x18>)
   111ec:	ldr	r2, [r2, #0]
   111ee:	ldr	r0, [r2, #52]	; 0x34
   111f0:	cmp	r0, #0
   111f2:	it	eq
   111f4:	moveq	r0, r3
   111f6:	adds	r0, #240	; 0xf0
   111f8:	bx	lr
   111fa:	nop
   111fc:	.word	0x1fff1828
   11200:	.word	0x1fff182c

00011204 <_mbrtowc_r>:
   11204:	push	{r4, r5, r6, r7, lr}
   11206:	sub	sp, #12
   11208:	mov	r7, r0
   1120a:	ldr	r5, [sp, #32]
   1120c:	cbz	r2, 11234 <_mbrtowc_r+0x30>
   1120e:	ldr	r4, [pc, #68]	; (11254 <_mbrtowc_r+0x50>)
   11210:	ldr	r6, [pc, #68]	; (11258 <_mbrtowc_r+0x54>)
   11212:	ldr	r4, [r4, #0]
   11214:	ldr	r4, [r4, #52]	; 0x34
   11216:	str	r5, [sp, #0]
   11218:	cmp	r4, #0
   1121a:	it	eq
   1121c:	moveq	r4, r6
   1121e:	ldr.w	r4, [r4, #228]	; 0xe4
   11222:	blx	r4
   11224:	adds	r3, r0, #1
   11226:	bne.n	11230 <_mbrtowc_r+0x2c>
   11228:	movs	r2, #0
   1122a:	movs	r3, #138	; 0x8a
   1122c:	str	r2, [r5, #0]
   1122e:	str	r3, [r7, #0]
   11230:	add	sp, #12
   11232:	pop	{r4, r5, r6, r7, pc}
   11234:	ldr	r3, [pc, #28]	; (11254 <_mbrtowc_r+0x50>)
   11236:	ldr	r1, [pc, #32]	; (11258 <_mbrtowc_r+0x54>)
   11238:	ldr	r3, [r3, #0]
   1123a:	ldr	r3, [r3, #52]	; 0x34
   1123c:	str	r5, [sp, #0]
   1123e:	cmp	r3, #0
   11240:	it	eq
   11242:	moveq	r3, r1
   11244:	mov	r4, r2
   11246:	mov	r1, r4
   11248:	ldr	r2, [pc, #16]	; (1125c <_mbrtowc_r+0x58>)
   1124a:	ldr.w	r4, [r3, #228]	; 0xe4
   1124e:	movs	r3, #1
   11250:	blx	r4
   11252:	b.n	11224 <_mbrtowc_r+0x20>
   11254:	.word	0x1fff1828
   11258:	.word	0x1fff182c
   1125c:	.word	0x000131b0

00011260 <_Balloc>:
   11260:	ldr	r3, [r0, #76]	; 0x4c
   11262:	push	{r4, r5, r6, lr}
   11264:	mov	r5, r0
   11266:	mov	r4, r1
   11268:	cbz	r3, 1127e <_Balloc+0x1e>
   1126a:	ldr.w	r0, [r3, r4, lsl #2]
   1126e:	cbz	r0, 11292 <_Balloc+0x32>
   11270:	ldr	r2, [r0, #0]
   11272:	str.w	r2, [r3, r4, lsl #2]
   11276:	movs	r3, #0
   11278:	str	r3, [r0, #16]
   1127a:	str	r3, [r0, #12]
   1127c:	pop	{r4, r5, r6, pc}
   1127e:	movs	r2, #33	; 0x21
   11280:	movs	r1, #4
   11282:	bl	12450 <_calloc_r>
   11286:	str	r0, [r5, #76]	; 0x4c
   11288:	mov	r3, r0
   1128a:	cmp	r0, #0
   1128c:	bne.n	1126a <_Balloc+0xa>
   1128e:	movs	r0, #0
   11290:	pop	{r4, r5, r6, pc}
   11292:	movs	r1, #1
   11294:	lsl.w	r6, r1, r4
   11298:	adds	r2, r6, #5
   1129a:	mov	r0, r5
   1129c:	lsls	r2, r2, #2
   1129e:	bl	12450 <_calloc_r>
   112a2:	cmp	r0, #0
   112a4:	beq.n	1128e <_Balloc+0x2e>
   112a6:	str	r4, [r0, #4]
   112a8:	str	r6, [r0, #8]
   112aa:	b.n	11276 <_Balloc+0x16>

000112ac <_Bfree>:
   112ac:	cbz	r1, 112bc <_Bfree+0x10>
   112ae:	ldr	r3, [r0, #76]	; 0x4c
   112b0:	ldr	r2, [r1, #4]
   112b2:	ldr.w	r0, [r3, r2, lsl #2]
   112b6:	str	r0, [r1, #0]
   112b8:	str.w	r1, [r3, r2, lsl #2]
   112bc:	bx	lr
   112be:	nop

000112c0 <__multadd>:
   112c0:	push	{r4, r5, r6, r7, lr}
   112c2:	ldr	r4, [r1, #16]
   112c4:	sub	sp, #12
   112c6:	mov	r5, r1
   112c8:	mov	r6, r0
   112ca:	add.w	lr, r1, #20
   112ce:	movs	r7, #0
   112d0:	ldr.w	r0, [lr]
   112d4:	uxth	r1, r0
   112d6:	mla	r1, r2, r1, r3
   112da:	lsrs	r3, r1, #16
   112dc:	lsrs	r0, r0, #16
   112de:	mla	r3, r2, r0, r3
   112e2:	uxth	r1, r1
   112e4:	adds	r7, #1
   112e6:	add.w	r1, r1, r3, lsl #16
   112ea:	cmp	r4, r7
   112ec:	str.w	r1, [lr], #4
   112f0:	mov.w	r3, r3, lsr #16
   112f4:	bgt.n	112d0 <__multadd+0x10>
   112f6:	cbz	r3, 11308 <__multadd+0x48>
   112f8:	ldr	r2, [r5, #8]
   112fa:	cmp	r4, r2
   112fc:	bge.n	1130e <__multadd+0x4e>
   112fe:	add.w	r2, r5, r4, lsl #2
   11302:	adds	r4, #1
   11304:	str	r3, [r2, #20]
   11306:	str	r4, [r5, #16]
   11308:	mov	r0, r5
   1130a:	add	sp, #12
   1130c:	pop	{r4, r5, r6, r7, pc}
   1130e:	ldr	r1, [r5, #4]
   11310:	str	r3, [sp, #4]
   11312:	adds	r1, #1
   11314:	mov	r0, r6
   11316:	bl	11260 <_Balloc>
   1131a:	ldr	r2, [r5, #16]
   1131c:	adds	r2, #2
   1131e:	add.w	r1, r5, #12
   11322:	mov	r7, r0
   11324:	lsls	r2, r2, #2
   11326:	adds	r0, #12
   11328:	bl	8f3c <memcpy>
   1132c:	ldr	r2, [r6, #76]	; 0x4c
   1132e:	ldr	r1, [r5, #4]
   11330:	ldr	r3, [sp, #4]
   11332:	ldr.w	r0, [r2, r1, lsl #2]
   11336:	str	r0, [r5, #0]
   11338:	str.w	r5, [r2, r1, lsl #2]
   1133c:	mov	r5, r7
   1133e:	b.n	112fe <__multadd+0x3e>

00011340 <__s2b>:
   11340:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   11344:	ldr	r4, [pc, #140]	; (113d4 <__s2b+0x94>)
   11346:	ldr	r5, [sp, #32]
   11348:	mov	r7, r3
   1134a:	adds	r3, #8
   1134c:	smull	r4, lr, r4, r3
   11350:	asrs	r3, r3, #31
   11352:	rsb	lr, r3, lr, asr #1
   11356:	cmp.w	lr, #1
   1135a:	mov	r6, r0
   1135c:	mov	r4, r1
   1135e:	mov	r8, r2
   11360:	ble.n	113ce <__s2b+0x8e>
   11362:	movs	r3, #1
   11364:	movs	r1, #0
   11366:	lsls	r3, r3, #1
   11368:	cmp	lr, r3
   1136a:	add.w	r1, r1, #1
   1136e:	bgt.n	11366 <__s2b+0x26>
   11370:	mov	r0, r6
   11372:	bl	11260 <_Balloc>
   11376:	movs	r3, #1
   11378:	cmp.w	r8, #9
   1137c:	str	r5, [r0, #20]
   1137e:	str	r3, [r0, #16]
   11380:	ble.n	113c6 <__s2b+0x86>
   11382:	add.w	r9, r4, #9
   11386:	mov	r5, r9
   11388:	add	r4, r8
   1138a:	ldrb.w	r3, [r5], #1
   1138e:	mov	r1, r0
   11390:	subs	r3, #48	; 0x30
   11392:	movs	r2, #10
   11394:	mov	r0, r6
   11396:	bl	112c0 <__multadd>
   1139a:	cmp	r5, r4
   1139c:	bne.n	1138a <__s2b+0x4a>
   1139e:	add.w	r4, r9, r8
   113a2:	subs	r4, #8
   113a4:	cmp	r7, r8
   113a6:	ble.n	113c2 <__s2b+0x82>
   113a8:	rsb	r7, r8, r7
   113ac:	add	r7, r4
   113ae:	ldrb.w	r3, [r4], #1
   113b2:	mov	r1, r0
   113b4:	subs	r3, #48	; 0x30
   113b6:	movs	r2, #10
   113b8:	mov	r0, r6
   113ba:	bl	112c0 <__multadd>
   113be:	cmp	r7, r4
   113c0:	bne.n	113ae <__s2b+0x6e>
   113c2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   113c6:	adds	r4, #10
   113c8:	mov.w	r8, #9
   113cc:	b.n	113a4 <__s2b+0x64>
   113ce:	movs	r1, #0
   113d0:	b.n	11370 <__s2b+0x30>
   113d2:	nop
   113d4:	.word	0x38e38e39

000113d8 <__hi0bits>:
   113d8:	lsrs	r3, r0, #16
   113da:	lsls	r3, r3, #16
   113dc:	cbnz	r3, 1140c <__hi0bits+0x34>
   113de:	lsls	r0, r0, #16
   113e0:	movs	r3, #16
   113e2:	tst.w	r0, #4278190080	; 0xff000000
   113e6:	itt	eq
   113e8:	lsleq	r0, r0, #8
   113ea:	addeq	r3, #8
   113ec:	tst.w	r0, #4026531840	; 0xf0000000
   113f0:	itt	eq
   113f2:	lsleq	r0, r0, #4
   113f4:	addeq	r3, #4
   113f6:	tst.w	r0, #3221225472	; 0xc0000000
   113fa:	itt	eq
   113fc:	lsleq	r0, r0, #2
   113fe:	addeq	r3, #2
   11400:	cmp	r0, #0
   11402:	blt.n	11414 <__hi0bits+0x3c>
   11404:	lsls	r2, r0, #1
   11406:	bmi.n	11410 <__hi0bits+0x38>
   11408:	movs	r0, #32
   1140a:	bx	lr
   1140c:	movs	r3, #0
   1140e:	b.n	113e2 <__hi0bits+0xa>
   11410:	adds	r0, r3, #1
   11412:	bx	lr
   11414:	mov	r0, r3
   11416:	bx	lr

00011418 <__lo0bits>:
   11418:	ldr	r3, [r0, #0]
   1141a:	ands.w	r2, r3, #7
   1141e:	beq.n	11430 <__lo0bits+0x18>
   11420:	lsls	r1, r3, #31
   11422:	bmi.n	11466 <__lo0bits+0x4e>
   11424:	lsls	r2, r3, #30
   11426:	bmi.n	1146a <__lo0bits+0x52>
   11428:	lsrs	r3, r3, #2
   1142a:	str	r3, [r0, #0]
   1142c:	movs	r0, #2
   1142e:	bx	lr
   11430:	uxth	r1, r3
   11432:	cbnz	r1, 11438 <__lo0bits+0x20>
   11434:	lsrs	r3, r3, #16
   11436:	movs	r2, #16
   11438:	tst.w	r3, #255	; 0xff
   1143c:	itt	eq
   1143e:	lsreq	r3, r3, #8
   11440:	addeq	r2, #8
   11442:	lsls	r1, r3, #28
   11444:	itt	eq
   11446:	lsreq	r3, r3, #4
   11448:	addeq	r2, #4
   1144a:	lsls	r1, r3, #30
   1144c:	itt	eq
   1144e:	lsreq	r3, r3, #2
   11450:	addeq	r2, #2
   11452:	lsls	r1, r3, #31
   11454:	bmi.n	11460 <__lo0bits+0x48>
   11456:	lsrs	r3, r3, #1
   11458:	bne.n	1145e <__lo0bits+0x46>
   1145a:	movs	r0, #32
   1145c:	bx	lr
   1145e:	adds	r2, #1
   11460:	str	r3, [r0, #0]
   11462:	mov	r0, r2
   11464:	bx	lr
   11466:	movs	r0, #0
   11468:	bx	lr
   1146a:	lsrs	r3, r3, #1
   1146c:	str	r3, [r0, #0]
   1146e:	movs	r0, #1
   11470:	bx	lr
   11472:	nop

00011474 <__i2b>:
   11474:	push	{r4, lr}
   11476:	mov	r4, r1
   11478:	movs	r1, #1
   1147a:	bl	11260 <_Balloc>
   1147e:	movs	r2, #1
   11480:	str	r4, [r0, #20]
   11482:	str	r2, [r0, #16]
   11484:	pop	{r4, pc}
   11486:	nop

00011488 <__multiply>:
   11488:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1148c:	ldr	r5, [r1, #16]
   1148e:	ldr	r7, [r2, #16]
   11490:	cmp	r5, r7
   11492:	sub	sp, #12
   11494:	mov	r4, r1
   11496:	mov	r6, r2
   11498:	bge.n	114a4 <__multiply+0x1c>
   1149a:	mov	r2, r5
   1149c:	mov	r4, r6
   1149e:	mov	r5, r7
   114a0:	mov	r6, r1
   114a2:	mov	r7, r2
   114a4:	ldr	r3, [r4, #8]
   114a6:	ldr	r1, [r4, #4]
   114a8:	add.w	r8, r5, r7
   114ac:	cmp	r8, r3
   114ae:	it	gt
   114b0:	addgt	r1, #1
   114b2:	bl	11260 <_Balloc>
   114b6:	add.w	ip, r0, #20
   114ba:	add.w	r9, ip, r8, lsl #2
   114be:	cmp	ip, r9
   114c0:	str	r0, [sp, #0]
   114c2:	bcs.n	114d0 <__multiply+0x48>
   114c4:	mov	r3, ip
   114c6:	movs	r1, #0
   114c8:	str.w	r1, [r3], #4
   114cc:	cmp	r9, r3
   114ce:	bhi.n	114c8 <__multiply+0x40>
   114d0:	add.w	r2, r6, #20
   114d4:	add.w	sl, r2, r7, lsl #2
   114d8:	add.w	r3, r4, #20
   114dc:	cmp	r2, sl
   114de:	add.w	lr, r3, r5, lsl #2
   114e2:	bcs.n	1158e <__multiply+0x106>
   114e4:	str.w	r9, [sp, #4]
   114e8:	mov	r9, r3
   114ea:	ldr.w	r3, [r2], #4
   114ee:	uxth.w	fp, r3
   114f2:	cmp.w	fp, #0
   114f6:	beq.n	1153a <__multiply+0xb2>
   114f8:	movs	r0, #0
   114fa:	mov	r7, r9
   114fc:	mov	r6, ip
   114fe:	mov	r5, r0
   11500:	b.n	11504 <__multiply+0x7c>
   11502:	mov	r6, r3
   11504:	ldr.w	r4, [r7], #4
   11508:	ldr	r0, [r6, #0]
   1150a:	uxth	r1, r4
   1150c:	uxth	r3, r0
   1150e:	mla	r1, fp, r1, r3
   11512:	lsrs	r4, r4, #16
   11514:	lsrs	r0, r0, #16
   11516:	adds	r3, r1, r5
   11518:	mla	r0, fp, r4, r0
   1151c:	add.w	r0, r0, r3, lsr #16
   11520:	uxth	r1, r3
   11522:	mov	r3, r6
   11524:	orr.w	r1, r1, r0, lsl #16
   11528:	cmp	lr, r7
   1152a:	mov.w	r5, r0, lsr #16
   1152e:	str.w	r1, [r3], #4
   11532:	bhi.n	11502 <__multiply+0x7a>
   11534:	str	r5, [r6, #4]
   11536:	ldr.w	r3, [r2, #-4]
   1153a:	movs.w	fp, r3, lsr #16
   1153e:	beq.n	11582 <__multiply+0xfa>
   11540:	ldr.w	r3, [ip]
   11544:	mov	r7, ip
   11546:	mov	r0, r3
   11548:	mov	r5, r9
   1154a:	movs	r1, #0
   1154c:	b.n	11550 <__multiply+0xc8>
   1154e:	mov	r7, r6
   11550:	ldrh	r4, [r5, #0]
   11552:	lsrs	r0, r0, #16
   11554:	mla	r0, fp, r4, r0
   11558:	add	r1, r0
   1155a:	uxth	r4, r3
   1155c:	mov	r6, r7
   1155e:	orr.w	r3, r4, r1, lsl #16
   11562:	str.w	r3, [r6], #4
   11566:	ldr	r0, [r7, #4]
   11568:	ldr.w	r4, [r5], #4
   1156c:	uxth	r3, r0
   1156e:	lsrs	r4, r4, #16
   11570:	mla	r4, fp, r4, r3
   11574:	add.w	r3, r4, r1, lsr #16
   11578:	cmp	lr, r5
   1157a:	mov.w	r1, r3, lsr #16
   1157e:	bhi.n	1154e <__multiply+0xc6>
   11580:	str	r3, [r7, #4]
   11582:	cmp	sl, r2
   11584:	add.w	ip, ip, #4
   11588:	bhi.n	114ea <__multiply+0x62>
   1158a:	ldr.w	r9, [sp, #4]
   1158e:	cmp.w	r8, #0
   11592:	ble.n	115ac <__multiply+0x124>
   11594:	ldr.w	r3, [r9, #-4]
   11598:	sub.w	r9, r9, #4
   1159c:	cbz	r3, 115a6 <__multiply+0x11e>
   1159e:	b.n	115ac <__multiply+0x124>
   115a0:	ldr.w	r3, [r9, #-4]!
   115a4:	cbnz	r3, 115ac <__multiply+0x124>
   115a6:	subs.w	r8, r8, #1
   115aa:	bne.n	115a0 <__multiply+0x118>
   115ac:	ldr	r0, [sp, #0]
   115ae:	str.w	r8, [r0, #16]
   115b2:	add	sp, #12
   115b4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000115b8 <__pow5mult>:
   115b8:	ands.w	r3, r2, #3
   115bc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   115c0:	mov	r4, r2
   115c2:	mov	r7, r0
   115c4:	bne.n	11624 <__pow5mult+0x6c>
   115c6:	mov	r6, r1
   115c8:	asrs	r4, r4, #2
   115ca:	beq.n	11606 <__pow5mult+0x4e>
   115cc:	ldr	r5, [r7, #72]	; 0x48
   115ce:	cbz	r5, 11636 <__pow5mult+0x7e>
   115d0:	lsls	r3, r4, #31
   115d2:	mov.w	r8, #0
   115d6:	bmi.n	115e6 <__pow5mult+0x2e>
   115d8:	asrs	r4, r4, #1
   115da:	beq.n	11606 <__pow5mult+0x4e>
   115dc:	ldr	r0, [r5, #0]
   115de:	cbz	r0, 1160c <__pow5mult+0x54>
   115e0:	mov	r5, r0
   115e2:	lsls	r3, r4, #31
   115e4:	bpl.n	115d8 <__pow5mult+0x20>
   115e6:	mov	r2, r5
   115e8:	mov	r1, r6
   115ea:	mov	r0, r7
   115ec:	bl	11488 <__multiply>
   115f0:	cbz	r6, 11620 <__pow5mult+0x68>
   115f2:	ldr	r2, [r6, #4]
   115f4:	ldr	r3, [r7, #76]	; 0x4c
   115f6:	asrs	r4, r4, #1
   115f8:	ldr.w	r1, [r3, r2, lsl #2]
   115fc:	str	r1, [r6, #0]
   115fe:	str.w	r6, [r3, r2, lsl #2]
   11602:	mov	r6, r0
   11604:	bne.n	115dc <__pow5mult+0x24>
   11606:	mov	r0, r6
   11608:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1160c:	mov	r2, r5
   1160e:	mov	r1, r5
   11610:	mov	r0, r7
   11612:	bl	11488 <__multiply>
   11616:	str	r0, [r5, #0]
   11618:	str.w	r8, [r0]
   1161c:	mov	r5, r0
   1161e:	b.n	115e2 <__pow5mult+0x2a>
   11620:	mov	r6, r0
   11622:	b.n	115d8 <__pow5mult+0x20>
   11624:	subs	r2, r3, #1
   11626:	ldr	r5, [pc, #44]	; (11654 <__pow5mult+0x9c>)
   11628:	movs	r3, #0
   1162a:	ldr.w	r2, [r5, r2, lsl #2]
   1162e:	bl	112c0 <__multadd>
   11632:	mov	r6, r0
   11634:	b.n	115c8 <__pow5mult+0x10>
   11636:	movs	r1, #1
   11638:	mov	r0, r7
   1163a:	bl	11260 <_Balloc>
   1163e:	movw	r1, #625	; 0x271
   11642:	movs	r2, #1
   11644:	movs	r3, #0
   11646:	str	r1, [r0, #20]
   11648:	str	r2, [r0, #16]
   1164a:	mov	r5, r0
   1164c:	str	r0, [r7, #72]	; 0x48
   1164e:	str	r3, [r0, #0]
   11650:	b.n	115d0 <__pow5mult+0x18>
   11652:	nop
   11654:	.word	0x00013518

00011658 <__lshift>:
   11658:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1165c:	mov	r9, r2
   1165e:	ldr	r2, [r1, #16]
   11660:	ldr	r3, [r1, #8]
   11662:	mov.w	r4, r9, asr #5
   11666:	add.w	r8, r4, r2
   1166a:	add.w	r5, r8, #1
   1166e:	cmp	r5, r3
   11670:	mov	r6, r1
   11672:	mov	sl, r0
   11674:	ldr	r1, [r1, #4]
   11676:	ble.n	11682 <__lshift+0x2a>
   11678:	lsls	r3, r3, #1
   1167a:	cmp	r5, r3
   1167c:	add.w	r1, r1, #1
   11680:	bgt.n	11678 <__lshift+0x20>
   11682:	mov	r0, sl
   11684:	bl	11260 <_Balloc>
   11688:	cmp	r4, #0
   1168a:	add.w	r2, r0, #20
   1168e:	ble.n	11702 <__lshift+0xaa>
   11690:	add.w	r3, r2, r4, lsl #2
   11694:	movs	r1, #0
   11696:	str.w	r1, [r2], #4
   1169a:	cmp	r3, r2
   1169c:	bne.n	11696 <__lshift+0x3e>
   1169e:	ldr	r4, [r6, #16]
   116a0:	add.w	r1, r6, #20
   116a4:	ands.w	r9, r9, #31
   116a8:	add.w	lr, r1, r4, lsl #2
   116ac:	beq.n	116f2 <__lshift+0x9a>
   116ae:	rsb	r2, r9, #32
   116b2:	movs	r4, #0
   116b4:	ldr	r7, [r1, #0]
   116b6:	lsl.w	ip, r7, r9
   116ba:	orr.w	r4, ip, r4
   116be:	mov	ip, r3
   116c0:	str.w	r4, [r3], #4
   116c4:	ldr.w	r4, [r1], #4
   116c8:	cmp	lr, r1
   116ca:	lsr.w	r4, r4, r2
   116ce:	bhi.n	116b4 <__lshift+0x5c>
   116d0:	str.w	r4, [ip, #4]
   116d4:	cbz	r4, 116da <__lshift+0x82>
   116d6:	add.w	r5, r8, #2
   116da:	ldr.w	r3, [sl, #76]	; 0x4c
   116de:	ldr	r2, [r6, #4]
   116e0:	subs	r5, #1
   116e2:	ldr.w	r1, [r3, r2, lsl #2]
   116e6:	str	r5, [r0, #16]
   116e8:	str	r1, [r6, #0]
   116ea:	str.w	r6, [r3, r2, lsl #2]
   116ee:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   116f2:	subs	r3, #4
   116f4:	ldr.w	r2, [r1], #4
   116f8:	str.w	r2, [r3, #4]!
   116fc:	cmp	lr, r1
   116fe:	bhi.n	116f4 <__lshift+0x9c>
   11700:	b.n	116da <__lshift+0x82>
   11702:	mov	r3, r2
   11704:	b.n	1169e <__lshift+0x46>
   11706:	nop

00011708 <__mcmp>:
   11708:	ldr	r2, [r0, #16]
   1170a:	ldr	r3, [r1, #16]
   1170c:	subs	r2, r2, r3
   1170e:	bne.n	11738 <__mcmp+0x30>
   11710:	lsls	r3, r3, #2
   11712:	adds	r0, #20
   11714:	adds	r1, #20
   11716:	add	r1, r3
   11718:	push	{r4}
   1171a:	add	r3, r0
   1171c:	b.n	11722 <__mcmp+0x1a>
   1171e:	cmp	r0, r3
   11720:	bcs.n	1173c <__mcmp+0x34>
   11722:	ldr.w	r4, [r3, #-4]!
   11726:	ldr.w	r2, [r1, #-4]!
   1172a:	cmp	r4, r2
   1172c:	beq.n	1171e <__mcmp+0x16>
   1172e:	bcc.n	11744 <__mcmp+0x3c>
   11730:	movs	r0, #1
   11732:	ldr.w	r4, [sp], #4
   11736:	bx	lr
   11738:	mov	r0, r2
   1173a:	bx	lr
   1173c:	movs	r0, #0
   1173e:	ldr.w	r4, [sp], #4
   11742:	bx	lr
   11744:	mov.w	r0, #4294967295
   11748:	b.n	11732 <__mcmp+0x2a>
   1174a:	nop

0001174c <__mdiff>:
   1174c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   11750:	ldr	r3, [r1, #16]
   11752:	mov	r7, r1
   11754:	ldr	r1, [r2, #16]
   11756:	subs	r3, r3, r1
   11758:	cmp	r3, #0
   1175a:	mov	r8, r2
   1175c:	bne.n	1178e <__mdiff+0x42>
   1175e:	lsls	r1, r1, #2
   11760:	add.w	r2, r7, #20
   11764:	add.w	r5, r8, #20
   11768:	adds	r3, r2, r1
   1176a:	add	r1, r5
   1176c:	b.n	11772 <__mdiff+0x26>
   1176e:	cmp	r2, r3
   11770:	bcs.n	11830 <__mdiff+0xe4>
   11772:	ldr.w	r6, [r3, #-4]!
   11776:	ldr.w	r4, [r1, #-4]!
   1177a:	cmp	r6, r4
   1177c:	beq.n	1176e <__mdiff+0x22>
   1177e:	bcs.n	11842 <__mdiff+0xf6>
   11780:	mov	r3, r7
   11782:	mov	r4, r2
   11784:	mov	r7, r8
   11786:	mov.w	r9, #1
   1178a:	mov	r8, r3
   1178c:	b.n	1179c <__mdiff+0x50>
   1178e:	blt.n	1184c <__mdiff+0x100>
   11790:	add.w	r5, r7, #20
   11794:	add.w	r4, r2, #20
   11798:	mov.w	r9, #0
   1179c:	ldr	r1, [r7, #4]
   1179e:	bl	11260 <_Balloc>
   117a2:	ldr.w	r3, [r8, #16]
   117a6:	ldr	r6, [r7, #16]
   117a8:	str.w	r9, [r0, #12]
   117ac:	add.w	ip, r4, r3, lsl #2
   117b0:	mov	lr, r4
   117b2:	add.w	r7, r5, r6, lsl #2
   117b6:	add.w	r4, r0, #20
   117ba:	movs	r3, #0
   117bc:	ldr.w	r1, [lr], #4
   117c0:	ldr.w	r8, [r5], #4
   117c4:	uxth	r2, r1
   117c6:	uxtah	r3, r3, r8
   117ca:	lsrs	r1, r1, #16
   117cc:	subs	r2, r3, r2
   117ce:	rsb	r3, r1, r8, lsr #16
   117d2:	add.w	r3, r3, r2, asr #16
   117d6:	uxth	r2, r2
   117d8:	orr.w	r2, r2, r3, lsl #16
   117dc:	cmp	ip, lr
   117de:	str.w	r2, [r4], #4
   117e2:	mov.w	r3, r3, asr #16
   117e6:	bhi.n	117bc <__mdiff+0x70>
   117e8:	cmp	r7, r5
   117ea:	bls.n	1181c <__mdiff+0xd0>
   117ec:	mov	ip, r4
   117ee:	mov	r1, r5
   117f0:	ldr.w	lr, [r1], #4
   117f4:	uxtah	r2, r3, lr
   117f8:	asrs	r3, r2, #16
   117fa:	add.w	r3, r3, lr, lsr #16
   117fe:	uxth	r2, r2
   11800:	orr.w	r2, r2, r3, lsl #16
   11804:	cmp	r7, r1
   11806:	str.w	r2, [ip], #4
   1180a:	mov.w	r3, r3, asr #16
   1180e:	bhi.n	117f0 <__mdiff+0xa4>
   11810:	mvns	r5, r5
   11812:	add	r5, r7
   11814:	bic.w	r5, r5, #3
   11818:	adds	r5, #4
   1181a:	add	r4, r5
   1181c:	subs	r4, #4
   1181e:	cbnz	r2, 1182a <__mdiff+0xde>
   11820:	ldr.w	r3, [r4, #-4]!
   11824:	subs	r6, #1
   11826:	cmp	r3, #0
   11828:	beq.n	11820 <__mdiff+0xd4>
   1182a:	str	r6, [r0, #16]
   1182c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   11830:	movs	r1, #0
   11832:	bl	11260 <_Balloc>
   11836:	movs	r2, #1
   11838:	movs	r3, #0
   1183a:	str	r2, [r0, #16]
   1183c:	str	r3, [r0, #20]
   1183e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   11842:	mov	r4, r5
   11844:	mov.w	r9, #0
   11848:	mov	r5, r2
   1184a:	b.n	1179c <__mdiff+0x50>
   1184c:	mov	r3, r7
   1184e:	add.w	r4, r7, #20
   11852:	add.w	r5, r8, #20
   11856:	mov	r7, r8
   11858:	mov.w	r9, #1
   1185c:	mov	r8, r3
   1185e:	b.n	1179c <__mdiff+0x50>

00011860 <__ulp>:
   11860:	ldr	r3, [pc, #76]	; (118b0 <__ulp+0x50>)
   11862:	vmov	r2, s1
   11866:	ands	r2, r3
   11868:	sub.w	r3, r2, #54525952	; 0x3400000
   1186c:	cmp	r3, #0
   1186e:	ble.n	1187a <__ulp+0x1a>
   11870:	movs	r0, #0
   11872:	mov	r1, r3
   11874:	vmov	d0, r0, r1
   11878:	bx	lr
   1187a:	negs	r3, r3
   1187c:	asrs	r3, r3, #20
   1187e:	cmp	r3, #19
   11880:	ble.n	1189e <__ulp+0x3e>
   11882:	subs	r3, #20
   11884:	cmp	r3, #30
   11886:	ittte	le
   11888:	rsble	r3, r3, #31
   1188c:	movle	r2, #1
   1188e:	lslle.w	r3, r2, r3
   11892:	movgt	r3, #1
   11894:	movs	r1, #0
   11896:	mov	r0, r3
   11898:	vmov	d0, r0, r1
   1189c:	bx	lr
   1189e:	mov.w	r2, #524288	; 0x80000
   118a2:	movs	r0, #0
   118a4:	asr.w	r1, r2, r3
   118a8:	vmov	d0, r0, r1
   118ac:	bx	lr
   118ae:	nop
   118b0:	.word	0x7ff00000

000118b4 <__b2d>:
   118b4:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   118b8:	ldr	r6, [r0, #16]
   118ba:	add.w	r8, r0, #20
   118be:	add.w	r6, r8, r6, lsl #2
   118c2:	ldr.w	r7, [r6, #-4]
   118c6:	mov	r0, r7
   118c8:	bl	113d8 <__hi0bits>
   118cc:	rsb	r3, r0, #32
   118d0:	cmp	r0, #10
   118d2:	str	r3, [r1, #0]
   118d4:	sub.w	r3, r6, #4
   118d8:	bgt.n	1190c <__b2d+0x58>
   118da:	cmp	r8, r3
   118dc:	rsb	r2, r0, #11
   118e0:	it	cc
   118e2:	ldrcc.w	r3, [r6, #-8]
   118e6:	lsr.w	r1, r7, r2
   118ea:	add.w	r0, r0, #21
   118ee:	orr.w	r5, r1, #1069547520	; 0x3fc00000
   118f2:	ite	cc
   118f4:	lsrcc	r3, r2
   118f6:	movcs	r3, #0
   118f8:	lsl.w	r0, r7, r0
   118fc:	orr.w	r5, r5, #3145728	; 0x300000
   11900:	orr.w	r4, r0, r3
   11904:	vmov	d0, r4, r5
   11908:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1190c:	cmp	r8, r3
   1190e:	bcs.n	11952 <__b2d+0x9e>
   11910:	subs.w	r3, r0, #11
   11914:	ldr.w	r2, [r6, #-8]
   11918:	beq.n	11958 <__b2d+0xa4>
   1191a:	lsl.w	r0, r7, r3
   1191e:	orr.w	r7, r0, #1069547520	; 0x3fc00000
   11922:	rsb	lr, r3, #32
   11926:	sub.w	r1, r6, #8
   1192a:	orr.w	r7, r7, #3145728	; 0x300000
   1192e:	lsr.w	r0, r2, lr
   11932:	cmp	r8, r1
   11934:	orr.w	r5, r7, r0
   11938:	bcs.n	1197c <__b2d+0xc8>
   1193a:	ldr.w	r1, [r6, #-12]
   1193e:	lsl.w	r0, r2, r3
   11942:	lsr.w	r3, r1, lr
   11946:	orrs	r0, r3
   11948:	mov	r4, r0
   1194a:	vmov	d0, r4, r5
   1194e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11952:	subs	r0, #11
   11954:	bne.n	1196a <__b2d+0xb6>
   11956:	mov	r2, r0
   11958:	orr.w	r5, r7, #1069547520	; 0x3fc00000
   1195c:	orr.w	r5, r5, #3145728	; 0x300000
   11960:	mov	r4, r2
   11962:	vmov	d0, r4, r5
   11966:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1196a:	lsl.w	r0, r7, r0
   1196e:	orr.w	r5, r0, #1069547520	; 0x3fc00000
   11972:	movs	r0, #0
   11974:	orr.w	r5, r5, #3145728	; 0x300000
   11978:	mov	r4, r0
   1197a:	b.n	1194a <__b2d+0x96>
   1197c:	lsl.w	r0, r2, r3
   11980:	mov	r4, r0
   11982:	b.n	1194a <__b2d+0x96>

00011984 <__d2b>:
   11984:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11988:	vmov	r6, r7, d0
   1198c:	sub	sp, #12
   1198e:	mov	r8, r1
   11990:	movs	r1, #1
   11992:	mov	r4, r7
   11994:	ubfx	r5, r7, #20, #11
   11998:	mov	r7, r2
   1199a:	bl	11260 <_Balloc>
   1199e:	ubfx	r4, r4, #0, #20
   119a2:	mov	r9, r0
   119a4:	cbz	r5, 119aa <__d2b+0x26>
   119a6:	orr.w	r4, r4, #1048576	; 0x100000
   119aa:	str	r4, [sp, #4]
   119ac:	cbz	r6, 119f6 <__d2b+0x72>
   119ae:	add	r0, sp, #8
   119b0:	str.w	r6, [r0, #-8]!
   119b4:	bl	11418 <__lo0bits>
   119b8:	cmp	r0, #0
   119ba:	bne.n	11a26 <__d2b+0xa2>
   119bc:	ldmia.w	sp, {r2, r3}
   119c0:	str.w	r2, [r9, #20]
   119c4:	cmp	r3, #0
   119c6:	ite	eq
   119c8:	moveq	r1, #1
   119ca:	movne	r1, #2
   119cc:	str.w	r3, [r9, #24]
   119d0:	str.w	r1, [r9, #16]
   119d4:	cbnz	r5, 11a0e <__d2b+0x8a>
   119d6:	add.w	r3, r9, r1, lsl #2
   119da:	subw	r0, r0, #1074	; 0x432
   119de:	str.w	r0, [r8]
   119e2:	ldr	r0, [r3, #16]
   119e4:	bl	113d8 <__hi0bits>
   119e8:	rsb	r0, r0, r1, lsl #5
   119ec:	str	r0, [r7, #0]
   119ee:	mov	r0, r9
   119f0:	add	sp, #12
   119f2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   119f6:	add	r0, sp, #4
   119f8:	bl	11418 <__lo0bits>
   119fc:	ldr	r3, [sp, #4]
   119fe:	str.w	r3, [r9, #20]
   11a02:	movs	r1, #1
   11a04:	adds	r0, #32
   11a06:	str.w	r1, [r9, #16]
   11a0a:	cmp	r5, #0
   11a0c:	beq.n	119d6 <__d2b+0x52>
   11a0e:	subw	r5, r5, #1075	; 0x433
   11a12:	add	r5, r0
   11a14:	rsb	r0, r0, #53	; 0x35
   11a18:	str.w	r5, [r8]
   11a1c:	str	r0, [r7, #0]
   11a1e:	mov	r0, r9
   11a20:	add	sp, #12
   11a22:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   11a26:	ldmia.w	sp, {r2, r3}
   11a2a:	rsb	r1, r0, #32
   11a2e:	lsl.w	r1, r3, r1
   11a32:	orrs	r2, r1
   11a34:	lsrs	r3, r0
   11a36:	str	r3, [sp, #4]
   11a38:	str.w	r2, [r9, #20]
   11a3c:	b.n	119c4 <__d2b+0x40>
   11a3e:	nop

00011a40 <__ratio>:
   11a40:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11a44:	sub	sp, #12
   11a46:	mov	r8, r1
   11a48:	mov	r1, sp
   11a4a:	mov	r9, r0
   11a4c:	bl	118b4 <__b2d>
   11a50:	mov	r0, r8
   11a52:	add	r1, sp, #4
   11a54:	vmov	r4, r5, d0
   11a58:	bl	118b4 <__b2d>
   11a5c:	ldmia.w	sp, {r1, r3}
   11a60:	ldr.w	r2, [r9, #16]
   11a64:	ldr.w	r0, [r8, #16]
   11a68:	subs	r1, r1, r3
   11a6a:	subs	r0, r2, r0
   11a6c:	add.w	r3, r1, r0, lsl #5
   11a70:	cmp	r3, #0
   11a72:	vmov	r6, r7, d0
   11a76:	ble.n	11a94 <__ratio+0x54>
   11a78:	add.w	r1, r5, r3, lsl #20
   11a7c:	mov	r5, r1
   11a7e:	mov	r2, r6
   11a80:	mov	r3, r7
   11a82:	mov	r0, r4
   11a84:	mov	r1, r5
   11a86:	bl	ab34 <__aeabi_ddiv>
   11a8a:	vmov	d0, r0, r1
   11a8e:	add	sp, #12
   11a90:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   11a94:	sub.w	r9, r7, r3, lsl #20
   11a98:	vmov	r6, s0
   11a9c:	mov	r7, r9
   11a9e:	b.n	11a7e <__ratio+0x3e>

00011aa0 <__copybits>:
   11aa0:	push	{r4, r5, r6}
   11aa2:	ldr	r4, [r2, #16]
   11aa4:	add.w	r3, r2, #20
   11aa8:	subs	r1, #1
   11aaa:	asrs	r6, r1, #5
   11aac:	add.w	r4, r3, r4, lsl #2
   11ab0:	adds	r6, #1
   11ab2:	cmp	r3, r4
   11ab4:	add.w	r6, r0, r6, lsl #2
   11ab8:	bcs.n	11ad4 <__copybits+0x34>
   11aba:	subs	r1, r0, #4
   11abc:	ldr.w	r5, [r3], #4
   11ac0:	str.w	r5, [r1, #4]!
   11ac4:	cmp	r4, r3
   11ac6:	bhi.n	11abc <__copybits+0x1c>
   11ac8:	subs	r3, r4, r2
   11aca:	subs	r3, #21
   11acc:	bic.w	r3, r3, #3
   11ad0:	adds	r3, #4
   11ad2:	add	r0, r3
   11ad4:	cmp	r6, r0
   11ad6:	bls.n	11ae2 <__copybits+0x42>
   11ad8:	movs	r3, #0
   11ada:	str.w	r3, [r0], #4
   11ade:	cmp	r6, r0
   11ae0:	bhi.n	11ada <__copybits+0x3a>
   11ae2:	pop	{r4, r5, r6}
   11ae4:	bx	lr
   11ae6:	nop

00011ae8 <__any_on>:
   11ae8:	ldr	r3, [r0, #16]
   11aea:	asrs	r2, r1, #5
   11aec:	cmp	r3, r2
   11aee:	push	{r4}
   11af0:	add.w	r4, r0, #20
   11af4:	bge.n	11b18 <__any_on+0x30>
   11af6:	add.w	r3, r4, r3, lsl #2
   11afa:	cmp	r4, r3
   11afc:	bcs.n	11b42 <__any_on+0x5a>
   11afe:	ldr.w	r0, [r3, #-4]
   11b02:	subs	r3, #4
   11b04:	cbz	r0, 11b0e <__any_on+0x26>
   11b06:	b.n	11b34 <__any_on+0x4c>
   11b08:	ldr.w	r2, [r3, #-4]!
   11b0c:	cbnz	r2, 11b34 <__any_on+0x4c>
   11b0e:	cmp	r4, r3
   11b10:	bcc.n	11b08 <__any_on+0x20>
   11b12:	ldr.w	r4, [sp], #4
   11b16:	bx	lr
   11b18:	ble.n	11b3c <__any_on+0x54>
   11b1a:	ands.w	r1, r1, #31
   11b1e:	beq.n	11b3c <__any_on+0x54>
   11b20:	ldr.w	r0, [r4, r2, lsl #2]
   11b24:	lsr.w	r3, r0, r1
   11b28:	lsl.w	r1, r3, r1
   11b2c:	cmp	r0, r1
   11b2e:	add.w	r3, r4, r2, lsl #2
   11b32:	beq.n	11afa <__any_on+0x12>
   11b34:	movs	r0, #1
   11b36:	ldr.w	r4, [sp], #4
   11b3a:	bx	lr
   11b3c:	add.w	r3, r4, r2, lsl #2
   11b40:	b.n	11afa <__any_on+0x12>
   11b42:	movs	r0, #0
   11b44:	b.n	11b12 <__any_on+0x2a>
   11b46:	nop

00011b48 <__sccl>:
   11b48:	push	{r4, r5, r6}
   11b4a:	ldrb	r5, [r1, #0]
   11b4c:	cmp	r5, #94	; 0x5e
   11b4e:	beq.n	11bb0 <__sccl+0x68>
   11b50:	movs	r2, #0
   11b52:	adds	r1, #1
   11b54:	mov	r6, r2
   11b56:	subs	r3, r0, #1
   11b58:	add.w	r4, r0, #255	; 0xff
   11b5c:	strb.w	r2, [r3, #1]!
   11b60:	cmp	r3, r4
   11b62:	bne.n	11b5c <__sccl+0x14>
   11b64:	cbz	r5, 11b88 <__sccl+0x40>
   11b66:	eor.w	r2, r6, #1
   11b6a:	strb	r2, [r0, r5]
   11b6c:	adds	r4, r1, #1
   11b6e:	ldrb.w	r3, [r4, #-1]
   11b72:	cmp	r3, #45	; 0x2d
   11b74:	beq.n	11b94 <__sccl+0x4c>
   11b76:	cmp	r3, #93	; 0x5d
   11b78:	beq.n	11b8e <__sccl+0x46>
   11b7a:	cbz	r3, 11b82 <__sccl+0x3a>
   11b7c:	mov	r5, r3
   11b7e:	mov	r1, r4
   11b80:	b.n	11b6a <__sccl+0x22>
   11b82:	mov	r0, r1
   11b84:	pop	{r4, r5, r6}
   11b86:	bx	lr
   11b88:	subs	r0, r1, #1
   11b8a:	pop	{r4, r5, r6}
   11b8c:	bx	lr
   11b8e:	mov	r0, r4
   11b90:	pop	{r4, r5, r6}
   11b92:	bx	lr
   11b94:	ldrb	r6, [r1, #1]
   11b96:	cmp	r6, #93	; 0x5d
   11b98:	beq.n	11b7c <__sccl+0x34>
   11b9a:	cmp	r5, r6
   11b9c:	bgt.n	11b7c <__sccl+0x34>
   11b9e:	adds	r1, #2
   11ba0:	adds	r3, r0, r5
   11ba2:	adds	r5, #1
   11ba4:	cmp	r6, r5
   11ba6:	strb.w	r2, [r3, #1]!
   11baa:	bgt.n	11ba2 <__sccl+0x5a>
   11bac:	adds	r4, #2
   11bae:	b.n	11b6e <__sccl+0x26>
   11bb0:	movs	r2, #1
   11bb2:	ldrb	r5, [r1, #1]
   11bb4:	mov	r6, r2
   11bb6:	adds	r1, #2
   11bb8:	b.n	11b56 <__sccl+0xe>
   11bba:	nop

00011bbc <nanf>:
   11bbc:	vldr	s0, [pc, #4]	; 11bc4 <nanf+0x8>
   11bc0:	bx	lr
   11bc2:	nop
   11bc4:	.word	0x7fc00000

00011bc8 <_strtoll_l.isra.0>:
   11bc8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11bcc:	sub	sp, #20
   11bce:	mov	sl, r3
   11bd0:	str	r1, [sp, #8]
   11bd2:	str	r0, [sp, #12]
   11bd4:	str	r2, [sp, #4]
   11bd6:	mov	r7, r1
   11bd8:	ldr	r6, [sp, #56]	; 0x38
   11bda:	b.n	11bde <_strtoll_l.isra.0+0x16>
   11bdc:	mov	r7, r5
   11bde:	mov	r5, r7
   11be0:	mov	r0, r6
   11be2:	ldrb.w	r4, [r5], #1
   11be6:	bl	b324 <__locale_ctype_ptr_l>
   11bea:	add	r0, r4
   11bec:	ldrb	r3, [r0, #1]
   11bee:	and.w	r3, r3, #8
   11bf2:	and.w	r2, r3, #255	; 0xff
   11bf6:	cmp	r3, #0
   11bf8:	bne.n	11bdc <_strtoll_l.isra.0+0x14>
   11bfa:	cmp	r4, #45	; 0x2d
   11bfc:	beq.w	11d06 <_strtoll_l.isra.0+0x13e>
   11c00:	cmp	r4, #43	; 0x2b
   11c02:	it	eq
   11c04:	ldrbeq	r4, [r7, #1]
   11c06:	str	r2, [sp, #0]
   11c08:	it	eq
   11c0a:	addeq	r5, r7, #2
   11c0c:	cmp.w	sl, #0
   11c10:	beq.n	11c2c <_strtoll_l.isra.0+0x64>
   11c12:	cmp.w	sl, #16
   11c16:	beq.w	11d44 <_strtoll_l.isra.0+0x17c>
   11c1a:	ldr	r3, [sp, #0]
   11c1c:	mov	r6, sl
   11c1e:	asrs	r7, r6, #31
   11c20:	cbnz	r3, 11c3e <_strtoll_l.isra.0+0x76>
   11c22:	mov.w	r8, #4294967295
   11c26:	mvn.w	r9, #2147483648	; 0x80000000
   11c2a:	b.n	11c46 <_strtoll_l.isra.0+0x7e>
   11c2c:	cmp	r4, #48	; 0x30
   11c2e:	beq.n	11d30 <_strtoll_l.isra.0+0x168>
   11c30:	movs	r6, #10
   11c32:	movs	r7, #0
   11c34:	mov.w	sl, #10
   11c38:	ldr	r3, [sp, #0]
   11c3a:	cmp	r3, #0
   11c3c:	beq.n	11c22 <_strtoll_l.isra.0+0x5a>
   11c3e:	mov.w	r8, #0
   11c42:	mov.w	r9, #2147483648	; 0x80000000
   11c46:	mov	r2, r6
   11c48:	mov	r3, r7
   11c4a:	mov	r0, r8
   11c4c:	mov	r1, r9
   11c4e:	bl	af70 <__aeabi_uldivmod>
   11c52:	mov	r3, r7
   11c54:	mov	fp, r2
   11c56:	mov	r0, r8
   11c58:	mov	r2, r6
   11c5a:	mov	r1, r9
   11c5c:	bl	af70 <__aeabi_uldivmod>
   11c60:	mov.w	lr, #0
   11c64:	movs	r2, #0
   11c66:	movs	r3, #0
   11c68:	b.n	11c8a <_strtoll_l.isra.0+0xc2>
   11c6a:	beq.n	11cf8 <_strtoll_l.isra.0+0x130>
   11c6c:	mul.w	r4, r2, r7
   11c70:	mla	r4, r6, r3, r4
   11c74:	umull	r2, r3, r2, r6
   11c78:	add	r3, r4
   11c7a:	adds.w	r2, r2, ip
   11c7e:	adc.w	r3, r3, ip, asr #31
   11c82:	mov.w	lr, #1
   11c86:	ldrb.w	r4, [r5], #1
   11c8a:	sub.w	ip, r4, #48	; 0x30
   11c8e:	cmp.w	ip, #9
   11c92:	bls.n	11ca2 <_strtoll_l.isra.0+0xda>
   11c94:	sub.w	ip, r4, #65	; 0x41
   11c98:	cmp.w	ip, #25
   11c9c:	bhi.n	11cba <_strtoll_l.isra.0+0xf2>
   11c9e:	sub.w	ip, r4, #55	; 0x37
   11ca2:	cmp	sl, ip
   11ca4:	ble.n	11ccc <_strtoll_l.isra.0+0x104>
   11ca6:	cmp.w	lr, #4294967295
   11caa:	beq.n	11c86 <_strtoll_l.isra.0+0xbe>
   11cac:	cmp	r1, r3
   11cae:	it	eq
   11cb0:	cmpeq	r0, r2
   11cb2:	bcs.n	11c6a <_strtoll_l.isra.0+0xa2>
   11cb4:	mov.w	lr, #4294967295
   11cb8:	b.n	11c86 <_strtoll_l.isra.0+0xbe>
   11cba:	sub.w	ip, r4, #97	; 0x61
   11cbe:	cmp.w	ip, #25
   11cc2:	bhi.n	11ccc <_strtoll_l.isra.0+0x104>
   11cc4:	sub.w	ip, r4, #87	; 0x57
   11cc8:	cmp	sl, ip
   11cca:	bgt.n	11ca6 <_strtoll_l.isra.0+0xde>
   11ccc:	cmp.w	lr, #4294967295
   11cd0:	beq.n	11d10 <_strtoll_l.isra.0+0x148>
   11cd2:	ldr	r1, [sp, #0]
   11cd4:	cbz	r1, 11cdc <_strtoll_l.isra.0+0x114>
   11cd6:	negs	r2, r2
   11cd8:	sbc.w	r3, r3, r3, lsl #1
   11cdc:	ldr	r1, [sp, #4]
   11cde:	cmp	r1, #0
   11ce0:	beq.n	11d68 <_strtoll_l.isra.0+0x1a0>
   11ce2:	cmp.w	lr, #0
   11ce6:	bne.n	11d28 <_strtoll_l.isra.0+0x160>
   11ce8:	ldr	r5, [sp, #8]
   11cea:	mov	r0, r2
   11cec:	mov	r1, r3
   11cee:	ldr	r3, [sp, #4]
   11cf0:	str	r5, [r3, #0]
   11cf2:	add	sp, #20
   11cf4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11cf8:	cmp	fp, ip
   11cfa:	bge.n	11c6c <_strtoll_l.isra.0+0xa4>
   11cfc:	mov	r2, r0
   11cfe:	mov	r3, r1
   11d00:	mov.w	lr, #4294967295
   11d04:	b.n	11c86 <_strtoll_l.isra.0+0xbe>
   11d06:	movs	r3, #1
   11d08:	adds	r5, r7, #2
   11d0a:	ldrb	r4, [r7, #1]
   11d0c:	str	r3, [sp, #0]
   11d0e:	b.n	11c0c <_strtoll_l.isra.0+0x44>
   11d10:	ldr	r3, [sp, #0]
   11d12:	cbnz	r3, 11d60 <_strtoll_l.isra.0+0x198>
   11d14:	mov.w	r0, #4294967295
   11d18:	mvn.w	r1, #2147483648	; 0x80000000
   11d1c:	ldr	r2, [sp, #12]
   11d1e:	movs	r3, #34	; 0x22
   11d20:	str	r3, [r2, #0]
   11d22:	ldr	r3, [sp, #4]
   11d24:	cbnz	r3, 11d2c <_strtoll_l.isra.0+0x164>
   11d26:	b.n	11cf2 <_strtoll_l.isra.0+0x12a>
   11d28:	mov	r0, r2
   11d2a:	mov	r1, r3
   11d2c:	subs	r5, #1
   11d2e:	b.n	11cee <_strtoll_l.isra.0+0x126>
   11d30:	ldrb	r3, [r5, #0]
   11d32:	and.w	r3, r3, #223	; 0xdf
   11d36:	cmp	r3, #88	; 0x58
   11d38:	beq.n	11d52 <_strtoll_l.isra.0+0x18a>
   11d3a:	movs	r6, #8
   11d3c:	movs	r7, #0
   11d3e:	mov.w	sl, #8
   11d42:	b.n	11c38 <_strtoll_l.isra.0+0x70>
   11d44:	cmp	r4, #48	; 0x30
   11d46:	bne.n	11d6e <_strtoll_l.isra.0+0x1a6>
   11d48:	ldrb	r3, [r5, #0]
   11d4a:	and.w	r3, r3, #223	; 0xdf
   11d4e:	cmp	r3, #88	; 0x58
   11d50:	bne.n	11d6e <_strtoll_l.isra.0+0x1a6>
   11d52:	ldrb	r4, [r5, #1]
   11d54:	movs	r6, #16
   11d56:	movs	r7, #0
   11d58:	adds	r5, #2
   11d5a:	mov.w	sl, #16
   11d5e:	b.n	11c38 <_strtoll_l.isra.0+0x70>
   11d60:	movs	r0, #0
   11d62:	mov.w	r1, #2147483648	; 0x80000000
   11d66:	b.n	11d1c <_strtoll_l.isra.0+0x154>
   11d68:	mov	r0, r2
   11d6a:	mov	r1, r3
   11d6c:	b.n	11cf2 <_strtoll_l.isra.0+0x12a>
   11d6e:	movs	r6, #16
   11d70:	movs	r7, #0
   11d72:	b.n	11c38 <_strtoll_l.isra.0+0x70>

00011d74 <_strtoll_r>:
   11d74:	push	{r4, r5, lr}
   11d76:	ldr	r4, [pc, #24]	; (11d90 <_strtoll_r+0x1c>)
   11d78:	ldr	r5, [pc, #24]	; (11d94 <_strtoll_r+0x20>)
   11d7a:	ldr	r4, [r4, #0]
   11d7c:	ldr	r4, [r4, #52]	; 0x34
   11d7e:	sub	sp, #12
   11d80:	cmp	r4, #0
   11d82:	it	eq
   11d84:	moveq	r4, r5
   11d86:	str	r4, [sp, #0]
   11d88:	bl	11bc8 <_strtoll_l.isra.0>
   11d8c:	add	sp, #12
   11d8e:	pop	{r4, r5, pc}
   11d90:	.word	0x1fff1828
   11d94:	.word	0x1fff182c

00011d98 <_strtoul_l.isra.0>:
   11d98:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11d9c:	ldr.w	r9, [sp, #40]	; 0x28
   11da0:	mov	r6, r1
   11da2:	mov	r7, r0
   11da4:	mov	r5, r2
   11da6:	mov	r8, r3
   11da8:	mov	fp, r1
   11daa:	b.n	11dae <_strtoul_l.isra.0+0x16>
   11dac:	mov	fp, r4
   11dae:	mov	r4, fp
   11db0:	mov	r0, r9
   11db2:	ldrb.w	sl, [r4], #1
   11db6:	bl	b324 <__locale_ctype_ptr_l>
   11dba:	add	r0, sl
   11dbc:	ldrb	r0, [r0, #1]
   11dbe:	and.w	r0, r0, #8
   11dc2:	and.w	ip, r0, #255	; 0xff
   11dc6:	cmp	r0, #0
   11dc8:	bne.n	11dac <_strtoul_l.isra.0+0x14>
   11dca:	mov	r1, sl
   11dcc:	cmp	r1, #45	; 0x2d
   11dce:	beq.n	11e94 <_strtoul_l.isra.0+0xfc>
   11dd0:	cmp	r1, #43	; 0x2b
   11dd2:	itt	eq
   11dd4:	ldrbeq.w	r1, [fp, #1]
   11dd8:	addeq.w	r4, fp, #2
   11ddc:	cmp.w	r8, #0
   11de0:	beq.n	11dfc <_strtoul_l.isra.0+0x64>
   11de2:	cmp.w	r8, #16
   11de6:	beq.n	11ea2 <_strtoul_l.isra.0+0x10a>
   11de8:	mov.w	r3, #4294967295
   11dec:	udiv	r3, r3, r8
   11df0:	mul.w	sl, r8, r3
   11df4:	mvn.w	sl, sl
   11df8:	mov	r9, r8
   11dfa:	b.n	11e0c <_strtoul_l.isra.0+0x74>
   11dfc:	cmp	r1, #48	; 0x30
   11dfe:	beq.n	11ec4 <_strtoul_l.isra.0+0x12c>
   11e00:	mov.w	r8, #10
   11e04:	ldr	r3, [pc, #244]	; (11efc <_strtoul_l.isra.0+0x164>)
   11e06:	mov	r9, r8
   11e08:	mov.w	sl, #5
   11e0c:	mov.w	lr, #0
   11e10:	mov	r0, lr
   11e12:	b.n	11e22 <_strtoul_l.isra.0+0x8a>
   11e14:	beq.n	11e76 <_strtoul_l.isra.0+0xde>
   11e16:	mla	r0, r9, r0, r2
   11e1a:	mov.w	lr, #1
   11e1e:	ldrb.w	r1, [r4], #1
   11e22:	sub.w	r2, r1, #48	; 0x30
   11e26:	cmp	r2, #9
   11e28:	bls.n	11e36 <_strtoul_l.isra.0+0x9e>
   11e2a:	sub.w	r2, r1, #65	; 0x41
   11e2e:	cmp	r2, #25
   11e30:	bhi.n	11e4a <_strtoul_l.isra.0+0xb2>
   11e32:	sub.w	r2, r1, #55	; 0x37
   11e36:	cmp	r8, r2
   11e38:	ble.n	11e5a <_strtoul_l.isra.0+0xc2>
   11e3a:	cmp.w	lr, #4294967295
   11e3e:	beq.n	11e1e <_strtoul_l.isra.0+0x86>
   11e40:	cmp	r0, r3
   11e42:	bls.n	11e14 <_strtoul_l.isra.0+0x7c>
   11e44:	mov.w	lr, #4294967295
   11e48:	b.n	11e1e <_strtoul_l.isra.0+0x86>
   11e4a:	sub.w	r2, r1, #97	; 0x61
   11e4e:	cmp	r2, #25
   11e50:	bhi.n	11e5a <_strtoul_l.isra.0+0xc2>
   11e52:	sub.w	r2, r1, #87	; 0x57
   11e56:	cmp	r8, r2
   11e58:	bgt.n	11e3a <_strtoul_l.isra.0+0xa2>
   11e5a:	cmp.w	lr, #4294967295
   11e5e:	beq.n	11e84 <_strtoul_l.isra.0+0xec>
   11e60:	cmp.w	ip, #0
   11e64:	beq.n	11e68 <_strtoul_l.isra.0+0xd0>
   11e66:	negs	r0, r0
   11e68:	cbz	r5, 11e80 <_strtoul_l.isra.0+0xe8>
   11e6a:	cmp.w	lr, #0
   11e6e:	bne.n	11e8c <_strtoul_l.isra.0+0xf4>
   11e70:	str	r6, [r5, #0]
   11e72:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11e76:	cmp	r2, sl
   11e78:	ble.n	11e16 <_strtoul_l.isra.0+0x7e>
   11e7a:	mov.w	lr, #4294967295
   11e7e:	b.n	11e1e <_strtoul_l.isra.0+0x86>
   11e80:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11e84:	movs	r3, #34	; 0x22
   11e86:	str	r3, [r7, #0]
   11e88:	mov	r0, lr
   11e8a:	cbz	r5, 11ede <_strtoul_l.isra.0+0x146>
   11e8c:	subs	r6, r4, #1
   11e8e:	str	r6, [r5, #0]
   11e90:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11e94:	add.w	r4, fp, #2
   11e98:	ldrb.w	r1, [fp, #1]
   11e9c:	mov.w	ip, #1
   11ea0:	b.n	11ddc <_strtoul_l.isra.0+0x44>
   11ea2:	cmp	r1, #48	; 0x30
   11ea4:	bne.n	11ee2 <_strtoul_l.isra.0+0x14a>
   11ea6:	ldrb	r3, [r4, #0]
   11ea8:	and.w	r3, r3, #223	; 0xdf
   11eac:	cmp	r3, #88	; 0x58
   11eae:	bne.n	11eee <_strtoul_l.isra.0+0x156>
   11eb0:	mov.w	r9, #16
   11eb4:	ldrb	r1, [r4, #1]
   11eb6:	mov	r8, r9
   11eb8:	mov.w	sl, #15
   11ebc:	adds	r4, #2
   11ebe:	mvn.w	r3, #4026531840	; 0xf0000000
   11ec2:	b.n	11e0c <_strtoul_l.isra.0+0x74>
   11ec4:	ldrb	r3, [r4, #0]
   11ec6:	and.w	r3, r3, #223	; 0xdf
   11eca:	cmp	r3, #88	; 0x58
   11ecc:	beq.n	11eb0 <_strtoul_l.isra.0+0x118>
   11ece:	mov.w	r8, #8
   11ed2:	mov	r9, r8
   11ed4:	mov.w	sl, #7
   11ed8:	mvn.w	r3, #3758096384	; 0xe0000000
   11edc:	b.n	11e0c <_strtoul_l.isra.0+0x74>
   11ede:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11ee2:	mov.w	sl, #15
   11ee6:	mvn.w	r3, #4026531840	; 0xf0000000
   11eea:	mov	r9, r8
   11eec:	b.n	11e0c <_strtoul_l.isra.0+0x74>
   11eee:	mov	r9, r8
   11ef0:	mov.w	sl, #15
   11ef4:	mvn.w	r3, #4026531840	; 0xf0000000
   11ef8:	b.n	11e0c <_strtoul_l.isra.0+0x74>
   11efa:	nop
   11efc:	.word	0x19999999

00011f00 <_strtoul_r>:
   11f00:	push	{r4, r5, lr}
   11f02:	ldr	r4, [pc, #24]	; (11f1c <_strtoul_r+0x1c>)
   11f04:	ldr	r5, [pc, #24]	; (11f20 <_strtoul_r+0x20>)
   11f06:	ldr	r4, [r4, #0]
   11f08:	ldr	r4, [r4, #52]	; 0x34
   11f0a:	sub	sp, #12
   11f0c:	cmp	r4, #0
   11f0e:	it	eq
   11f10:	moveq	r4, r5
   11f12:	str	r4, [sp, #0]
   11f14:	bl	11d98 <_strtoul_l.isra.0>
   11f18:	add	sp, #12
   11f1a:	pop	{r4, r5, pc}
   11f1c:	.word	0x1fff1828
   11f20:	.word	0x1fff182c

00011f24 <_strtoull_l.isra.0>:
   11f24:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11f28:	sub	sp, #20
   11f2a:	mov	fp, r1
   11f2c:	str	r0, [sp, #8]
   11f2e:	mov	r7, r2
   11f30:	mov	r6, r3
   11f32:	mov	r8, r1
   11f34:	ldr	r4, [sp, #56]	; 0x38
   11f36:	b.n	11f3a <_strtoull_l.isra.0+0x16>
   11f38:	mov	r8, r5
   11f3a:	mov	r5, r8
   11f3c:	mov	r0, r4
   11f3e:	ldrb.w	r9, [r5], #1
   11f42:	bl	b324 <__locale_ctype_ptr_l>
   11f46:	add	r0, r9
   11f48:	ldrb	r3, [r0, #1]
   11f4a:	and.w	r3, r3, #8
   11f4e:	and.w	r2, r3, #255	; 0xff
   11f52:	cmp	r3, #0
   11f54:	bne.n	11f38 <_strtoull_l.isra.0+0x14>
   11f56:	mov	r4, r9
   11f58:	cmp	r4, #45	; 0x2d
   11f5a:	beq.w	12076 <_strtoull_l.isra.0+0x152>
   11f5e:	cmp	r4, #43	; 0x2b
   11f60:	it	eq
   11f62:	ldrbeq.w	r4, [r8, #1]
   11f66:	str	r2, [sp, #4]
   11f68:	it	eq
   11f6a:	addeq.w	r5, r8, #2
   11f6e:	cbz	r6, 11fa8 <_strtoull_l.isra.0+0x84>
   11f70:	cmp	r6, #16
   11f72:	beq.w	12084 <_strtoull_l.isra.0+0x160>
   11f76:	mov.w	r9, r6, asr #31
   11f7a:	mov	r2, r6
   11f7c:	mov	r3, r9
   11f7e:	mov.w	r0, #4294967295
   11f82:	mov.w	r1, #4294967295
   11f86:	bl	af70 <__aeabi_uldivmod>
   11f8a:	mov	r2, r6
   11f8c:	str	r0, [sp, #12]
   11f8e:	mov	sl, r1
   11f90:	mov	r3, r9
   11f92:	mov.w	r0, #4294967295
   11f96:	mov.w	r1, #4294967295
   11f9a:	bl	af70 <__aeabi_uldivmod>
   11f9e:	mov	r8, r6
   11fa0:	mov	lr, r2
   11fa2:	ldr	r2, [sp, #12]
   11fa4:	mov	r3, sl
   11fa6:	b.n	11fc2 <_strtoull_l.isra.0+0x9e>
   11fa8:	cmp	r4, #48	; 0x30
   11faa:	beq.w	120b0 <_strtoull_l.isra.0+0x18c>
   11fae:	ldr	r3, [pc, #348]	; (1210c <_strtoull_l.isra.0+0x1e8>)
   11fb0:	mov.w	lr, #5
   11fb4:	mov.w	r2, #2576980377	; 0x99999999
   11fb8:	mov.w	r8, #10
   11fbc:	mov.w	r9, #0
   11fc0:	movs	r6, #10
   11fc2:	mov.w	ip, #0
   11fc6:	movs	r0, #0
   11fc8:	movs	r1, #0
   11fca:	b.n	11ff2 <_strtoull_l.isra.0+0xce>
   11fcc:	cmp	r1, r3
   11fce:	it	eq
   11fd0:	cmpeq	r0, r2
   11fd2:	beq.n	12056 <_strtoull_l.isra.0+0x132>
   11fd4:	mul.w	r4, r0, r9
   11fd8:	mla	r4, r8, r1, r4
   11fdc:	umull	r0, r1, r0, r8
   11fe0:	add	r1, r4
   11fe2:	adds.w	r0, r0, sl
   11fe6:	adc.w	r1, r1, sl, asr #31
   11fea:	mov.w	ip, #1
   11fee:	ldrb.w	r4, [r5], #1
   11ff2:	sub.w	sl, r4, #48	; 0x30
   11ff6:	cmp.w	sl, #9
   11ffa:	bls.n	1200a <_strtoull_l.isra.0+0xe6>
   11ffc:	sub.w	sl, r4, #65	; 0x41
   12000:	cmp.w	sl, #25
   12004:	bhi.n	12022 <_strtoull_l.isra.0+0xfe>
   12006:	sub.w	sl, r4, #55	; 0x37
   1200a:	cmp	r6, sl
   1200c:	ble.n	12034 <_strtoull_l.isra.0+0x110>
   1200e:	cmp.w	ip, #4294967295
   12012:	beq.n	11fee <_strtoull_l.isra.0+0xca>
   12014:	cmp	r3, r1
   12016:	it	eq
   12018:	cmpeq	r2, r0
   1201a:	bcs.n	11fcc <_strtoull_l.isra.0+0xa8>
   1201c:	mov.w	ip, #4294967295
   12020:	b.n	11fee <_strtoull_l.isra.0+0xca>
   12022:	sub.w	sl, r4, #97	; 0x61
   12026:	cmp.w	sl, #25
   1202a:	bhi.n	12034 <_strtoull_l.isra.0+0x110>
   1202c:	sub.w	sl, r4, #87	; 0x57
   12030:	cmp	r6, sl
   12032:	bgt.n	1200e <_strtoull_l.isra.0+0xea>
   12034:	cmp.w	ip, #4294967295
   12038:	beq.n	12060 <_strtoull_l.isra.0+0x13c>
   1203a:	ldr	r3, [sp, #4]
   1203c:	cbz	r3, 12044 <_strtoull_l.isra.0+0x120>
   1203e:	negs	r0, r0
   12040:	sbc.w	r1, r1, r1, lsl #1
   12044:	cbz	r7, 12050 <_strtoull_l.isra.0+0x12c>
   12046:	cmp.w	ip, #0
   1204a:	bne.n	12072 <_strtoull_l.isra.0+0x14e>
   1204c:	mov	r5, fp
   1204e:	str	r5, [r7, #0]
   12050:	add	sp, #20
   12052:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12056:	cmp	sl, lr
   12058:	ble.n	11fd4 <_strtoull_l.isra.0+0xb0>
   1205a:	mov.w	ip, #4294967295
   1205e:	b.n	11fee <_strtoull_l.isra.0+0xca>
   12060:	ldr	r2, [sp, #8]
   12062:	movs	r3, #34	; 0x22
   12064:	str	r3, [r2, #0]
   12066:	mov.w	r0, #4294967295
   1206a:	mov.w	r1, #4294967295
   1206e:	cmp	r7, #0
   12070:	beq.n	12050 <_strtoull_l.isra.0+0x12c>
   12072:	subs	r5, #1
   12074:	b.n	1204e <_strtoull_l.isra.0+0x12a>
   12076:	movs	r3, #1
   12078:	add.w	r5, r8, #2
   1207c:	ldrb.w	r4, [r8, #1]
   12080:	str	r3, [sp, #4]
   12082:	b.n	11f6e <_strtoull_l.isra.0+0x4a>
   12084:	cmp	r4, #48	; 0x30
   12086:	bne.n	120d2 <_strtoull_l.isra.0+0x1ae>
   12088:	ldrb	r3, [r5, #0]
   1208a:	and.w	r3, r3, #223	; 0xdf
   1208e:	cmp	r3, #88	; 0x58
   12090:	bne.n	120e8 <_strtoull_l.isra.0+0x1c4>
   12092:	mov.w	r3, #4294967295
   12096:	ldrb	r4, [r5, #1]
   12098:	str	r3, [sp, #12]
   1209a:	mov.w	lr, #15
   1209e:	adds	r5, #2
   120a0:	mvn.w	sl, #4026531840	; 0xf0000000
   120a4:	mov.w	r8, #16
   120a8:	mov.w	r9, #0
   120ac:	movs	r6, #16
   120ae:	b.n	11fa2 <_strtoull_l.isra.0+0x7e>
   120b0:	ldrb	r3, [r5, #0]
   120b2:	and.w	r3, r3, #223	; 0xdf
   120b6:	cmp	r3, #88	; 0x58
   120b8:	beq.n	12092 <_strtoull_l.isra.0+0x16e>
   120ba:	mov.w	lr, #7
   120be:	mov.w	r2, #4294967295
   120c2:	mvn.w	r3, #3758096384	; 0xe0000000
   120c6:	mov.w	r8, #8
   120ca:	mov.w	r9, #0
   120ce:	movs	r6, #8
   120d0:	b.n	11fc2 <_strtoull_l.isra.0+0x9e>
   120d2:	mov.w	lr, #15
   120d6:	mov.w	r2, #4294967295
   120da:	mvn.w	r3, #4026531840	; 0xf0000000
   120de:	mov.w	r8, #16
   120e2:	mov.w	r9, #0
   120e6:	b.n	11fc2 <_strtoull_l.isra.0+0x9e>
   120e8:	mov.w	r8, #16
   120ec:	mov.w	r9, #0
   120f0:	mov	r2, r8
   120f2:	mov	r3, r9
   120f4:	mov.w	r0, #4294967295
   120f8:	mov.w	r1, #4294967295
   120fc:	bl	af70 <__aeabi_uldivmod>
   12100:	mvn.w	r3, #4026531840	; 0xf0000000
   12104:	mov	lr, r2
   12106:	mov.w	r2, #4294967295
   1210a:	b.n	11fc2 <_strtoull_l.isra.0+0x9e>
   1210c:	.word	0x19999999

00012110 <_strtoull_r>:
   12110:	push	{r4, r5, lr}
   12112:	ldr	r4, [pc, #24]	; (1212c <_strtoull_r+0x1c>)
   12114:	ldr	r5, [pc, #24]	; (12130 <_strtoull_r+0x20>)
   12116:	ldr	r4, [r4, #0]
   12118:	ldr	r4, [r4, #52]	; 0x34
   1211a:	sub	sp, #12
   1211c:	cmp	r4, #0
   1211e:	it	eq
   12120:	moveq	r4, r5
   12122:	str	r4, [sp, #0]
   12124:	bl	11f24 <_strtoull_l.isra.0>
   12128:	add	sp, #12
   1212a:	pop	{r4, r5, pc}
   1212c:	.word	0x1fff1828
   12130:	.word	0x1fff182c

00012134 <__ssprint_r>:
   12134:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12138:	ldr	r3, [r2, #8]
   1213a:	sub	sp, #12
   1213c:	mov	r8, r2
   1213e:	cmp	r3, #0
   12140:	beq.n	12228 <__ssprint_r+0xf4>
   12142:	mov	fp, r0
   12144:	mov.w	r9, #0
   12148:	ldr	r6, [r2, #0]
   1214a:	ldr	r0, [r1, #0]
   1214c:	ldr	r3, [r1, #8]
   1214e:	mov	r5, r1
   12150:	mov	r4, r9
   12152:	cmp	r4, #0
   12154:	beq.n	121e2 <__ssprint_r+0xae>
   12156:	cmp	r4, r3
   12158:	mov	r7, r3
   1215a:	mov	sl, r3
   1215c:	bcc.n	121ec <__ssprint_r+0xb8>
   1215e:	ldrh	r3, [r5, #12]
   12160:	tst.w	r3, #1152	; 0x480
   12164:	beq.n	121c2 <__ssprint_r+0x8e>
   12166:	ldr	r7, [r5, #20]
   12168:	ldr	r1, [r5, #16]
   1216a:	add.w	r7, r7, r7, lsl #1
   1216e:	rsb	sl, r1, r0
   12172:	add.w	r7, r7, r7, lsr #31
   12176:	adds	r0, r4, #1
   12178:	asrs	r7, r7, #1
   1217a:	add	r0, sl
   1217c:	cmp	r0, r7
   1217e:	mov	r2, r7
   12180:	itt	hi
   12182:	movhi	r7, r0
   12184:	movhi	r2, r7
   12186:	lsls	r3, r3, #21
   12188:	bpl.n	121f2 <__ssprint_r+0xbe>
   1218a:	mov	r1, r2
   1218c:	mov	r0, fp
   1218e:	bl	b360 <_malloc_r>
   12192:	cmp	r0, #0
   12194:	beq.n	12206 <__ssprint_r+0xd2>
   12196:	mov	r2, sl
   12198:	ldr	r1, [r5, #16]
   1219a:	str	r0, [sp, #4]
   1219c:	bl	8f3c <memcpy>
   121a0:	ldrh	r2, [r5, #12]
   121a2:	ldr	r3, [sp, #4]
   121a4:	bic.w	r2, r2, #1152	; 0x480
   121a8:	orr.w	r2, r2, #128	; 0x80
   121ac:	strh	r2, [r5, #12]
   121ae:	rsb	r2, sl, r7
   121b2:	add.w	r0, r3, sl
   121b6:	str	r7, [r5, #20]
   121b8:	str	r3, [r5, #16]
   121ba:	str	r0, [r5, #0]
   121bc:	str	r2, [r5, #8]
   121be:	mov	r7, r4
   121c0:	mov	sl, r4
   121c2:	mov	r2, sl
   121c4:	mov	r1, r9
   121c6:	bl	ba04 <memmove>
   121ca:	ldr.w	r2, [r8, #8]
   121ce:	ldr	r3, [r5, #8]
   121d0:	ldr	r0, [r5, #0]
   121d2:	subs	r3, r3, r7
   121d4:	add	r0, sl
   121d6:	subs	r4, r2, r4
   121d8:	str	r3, [r5, #8]
   121da:	str	r0, [r5, #0]
   121dc:	str.w	r4, [r8, #8]
   121e0:	cbz	r4, 12228 <__ssprint_r+0xf4>
   121e2:	ldr.w	r9, [r6]
   121e6:	ldr	r4, [r6, #4]
   121e8:	adds	r6, #8
   121ea:	b.n	12152 <__ssprint_r+0x1e>
   121ec:	mov	r7, r4
   121ee:	mov	sl, r4
   121f0:	b.n	121c2 <__ssprint_r+0x8e>
   121f2:	mov	r0, fp
   121f4:	bl	bad4 <_realloc_r>
   121f8:	mov	r3, r0
   121fa:	cmp	r0, #0
   121fc:	bne.n	121ae <__ssprint_r+0x7a>
   121fe:	ldr	r1, [r5, #16]
   12200:	mov	r0, fp
   12202:	bl	10890 <_free_r>
   12206:	movs	r3, #12
   12208:	str.w	r3, [fp]
   1220c:	ldrh	r3, [r5, #12]
   1220e:	movs	r2, #0
   12210:	orr.w	r3, r3, #64	; 0x40
   12214:	mov.w	r0, #4294967295
   12218:	strh	r3, [r5, #12]
   1221a:	str.w	r2, [r8, #8]
   1221e:	str.w	r2, [r8, #4]
   12222:	add	sp, #12
   12224:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12228:	movs	r0, #0
   1222a:	str.w	r0, [r8, #4]
   1222e:	add	sp, #12
   12230:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00012234 <_sungetc_r>:
   12234:	adds	r3, r1, #1
   12236:	push	{r4, r5, r6, lr}
   12238:	beq.n	12272 <_sungetc_r+0x3e>
   1223a:	ldrh	r3, [r2, #12]
   1223c:	ldr	r4, [r2, #48]	; 0x30
   1223e:	bic.w	r3, r3, #32
   12242:	strh	r3, [r2, #12]
   12244:	uxtb	r5, r1
   12246:	cbz	r4, 12278 <_sungetc_r+0x44>
   12248:	mov	r4, r2
   1224a:	ldr	r2, [r2, #4]
   1224c:	ldr	r3, [r4, #52]	; 0x34
   1224e:	cmp	r2, r3
   12250:	mov	r6, r1
   12252:	bge.n	12268 <_sungetc_r+0x34>
   12254:	ldr	r3, [r4, #0]
   12256:	subs	r2, r3, #1
   12258:	str	r2, [r4, #0]
   1225a:	strb.w	r6, [r3, #-1]
   1225e:	ldr	r3, [r4, #4]
   12260:	adds	r3, #1
   12262:	str	r3, [r4, #4]
   12264:	mov	r0, r5
   12266:	pop	{r4, r5, r6, pc}
   12268:	mov	r1, r4
   1226a:	bl	12378 <__submore>
   1226e:	cmp	r0, #0
   12270:	beq.n	12254 <_sungetc_r+0x20>
   12272:	mov.w	r5, #4294967295
   12276:	b.n	12264 <_sungetc_r+0x30>
   12278:	ldr	r0, [r2, #16]
   1227a:	ldr	r3, [r2, #0]
   1227c:	cbz	r0, 1228a <_sungetc_r+0x56>
   1227e:	cmp	r0, r3
   12280:	bcs.n	1228a <_sungetc_r+0x56>
   12282:	ldrb.w	r0, [r3, #-1]
   12286:	cmp	r5, r0
   12288:	beq.n	122aa <_sungetc_r+0x76>
   1228a:	str	r3, [r2, #56]	; 0x38
   1228c:	mov	r3, r2
   1228e:	ldr	r6, [r2, #4]
   12290:	str	r6, [r2, #60]	; 0x3c
   12292:	add.w	r4, r2, #64	; 0x40
   12296:	movs	r0, #3
   12298:	str	r0, [r2, #52]	; 0x34
   1229a:	str	r4, [r2, #48]	; 0x30
   1229c:	strb.w	r1, [r3, #66]!
   122a0:	movs	r1, #1
   122a2:	str	r3, [r2, #0]
   122a4:	str	r1, [r2, #4]
   122a6:	mov	r0, r5
   122a8:	pop	{r4, r5, r6, pc}
   122aa:	ldr	r1, [r2, #4]
   122ac:	subs	r3, #1
   122ae:	adds	r1, #1
   122b0:	str	r3, [r2, #0]
   122b2:	str	r1, [r2, #4]
   122b4:	b.n	12264 <_sungetc_r+0x30>
   122b6:	nop

000122b8 <__ssrefill_r>:
   122b8:	push	{r4, lr}
   122ba:	mov	r4, r1
   122bc:	ldr	r1, [r1, #48]	; 0x30
   122be:	cbz	r1, 122dc <__ssrefill_r+0x24>
   122c0:	add.w	r3, r4, #64	; 0x40
   122c4:	cmp	r1, r3
   122c6:	beq.n	122cc <__ssrefill_r+0x14>
   122c8:	bl	10890 <_free_r>
   122cc:	ldr	r3, [r4, #60]	; 0x3c
   122ce:	str	r3, [r4, #4]
   122d0:	movs	r0, #0
   122d2:	str	r0, [r4, #48]	; 0x30
   122d4:	cbz	r3, 122dc <__ssrefill_r+0x24>
   122d6:	ldr	r3, [r4, #56]	; 0x38
   122d8:	str	r3, [r4, #0]
   122da:	pop	{r4, pc}
   122dc:	ldrh	r3, [r4, #12]
   122de:	ldr	r2, [r4, #16]
   122e0:	str	r2, [r4, #0]
   122e2:	orr.w	r3, r3, #32
   122e6:	movs	r2, #0
   122e8:	strh	r3, [r4, #12]
   122ea:	str	r2, [r4, #4]
   122ec:	mov.w	r0, #4294967295
   122f0:	pop	{r4, pc}
   122f2:	nop

000122f4 <_sfread_r>:
   122f4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   122f8:	sub	sp, #12
   122fa:	mul.w	r9, r2, r3
   122fe:	str	r2, [sp, #4]
   12300:	mov	sl, r3
   12302:	ldr	r4, [sp, #48]	; 0x30
   12304:	cmp.w	r9, #0
   12308:	beq.n	1235e <_sfread_r+0x6a>
   1230a:	mov	r7, r0
   1230c:	mov	r6, r1
   1230e:	mov	r5, r9
   12310:	mov.w	r8, #0
   12314:	b.n	12336 <_sfread_r+0x42>
   12316:	ldr	r1, [r4, #0]
   12318:	bl	8f3c <memcpy>
   1231c:	ldr	r2, [r4, #0]
   1231e:	str.w	r8, [r4, #4]
   12322:	add	r2, fp
   12324:	str	r2, [r4, #0]
   12326:	mov	r1, r4
   12328:	mov	r0, r7
   1232a:	add	r6, fp
   1232c:	rsb	r5, fp, r5
   12330:	bl	122b8 <__ssrefill_r>
   12334:	cbnz	r0, 12366 <_sfread_r+0x72>
   12336:	ldr.w	fp, [r4, #4]
   1233a:	cmp	r5, fp
   1233c:	mov	r0, r6
   1233e:	mov	r2, fp
   12340:	bhi.n	12316 <_sfread_r+0x22>
   12342:	mov	r2, r5
   12344:	ldr	r1, [r4, #0]
   12346:	bl	8f3c <memcpy>
   1234a:	ldr	r2, [r4, #4]
   1234c:	ldr	r3, [r4, #0]
   1234e:	subs	r2, r2, r5
   12350:	add	r3, r5
   12352:	mov	r0, sl
   12354:	str	r2, [r4, #4]
   12356:	str	r3, [r4, #0]
   12358:	add	sp, #12
   1235a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1235e:	mov	r0, r9
   12360:	add	sp, #12
   12362:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12366:	ldr	r3, [sp, #4]
   12368:	rsb	r9, r5, r9
   1236c:	udiv	r0, r9, r3
   12370:	add	sp, #12
   12372:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12376:	nop

00012378 <__submore>:
   12378:	add.w	r3, r1, #64	; 0x40
   1237c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12380:	mov	r4, r1
   12382:	ldr	r1, [r1, #48]	; 0x30
   12384:	cmp	r1, r3
   12386:	beq.n	123b2 <__submore+0x3a>
   12388:	ldr	r6, [r4, #52]	; 0x34
   1238a:	lsls	r7, r6, #1
   1238c:	mov	r2, r7
   1238e:	bl	bad4 <_realloc_r>
   12392:	mov	r5, r0
   12394:	cbz	r0, 123e8 <__submore+0x70>
   12396:	add.w	r8, r0, r6
   1239a:	mov	r2, r6
   1239c:	mov	r0, r8
   1239e:	mov	r1, r5
   123a0:	bl	8f3c <memcpy>
   123a4:	str.w	r8, [r4]
   123a8:	str	r5, [r4, #48]	; 0x30
   123aa:	str	r7, [r4, #52]	; 0x34
   123ac:	movs	r0, #0
   123ae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   123b2:	mov.w	r1, #1024	; 0x400
   123b6:	bl	b360 <_malloc_r>
   123ba:	cbz	r0, 123e8 <__submore+0x70>
   123bc:	ldrb.w	r3, [r4, #66]	; 0x42
   123c0:	str	r0, [r4, #48]	; 0x30
   123c2:	mov.w	r2, #1024	; 0x400
   123c6:	str	r2, [r4, #52]	; 0x34
   123c8:	strb.w	r3, [r0, #1023]	; 0x3ff
   123cc:	ldrb.w	r3, [r4, #65]	; 0x41
   123d0:	strb.w	r3, [r0, #1022]	; 0x3fe
   123d4:	ldrb.w	r3, [r4, #64]	; 0x40
   123d8:	strb.w	r3, [r0, #1021]	; 0x3fd
   123dc:	addw	r0, r0, #1021	; 0x3fd
   123e0:	str	r0, [r4, #0]
   123e2:	movs	r0, #0
   123e4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   123e8:	mov.w	r0, #4294967295
   123ec:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000123f0 <_vasnprintf_r>:
   123f0:	push	{r4, r5, r6, lr}
   123f2:	mov	r5, r2
   123f4:	sub	sp, #104	; 0x68
   123f6:	ldr	r4, [r2, #0]
   123f8:	cbz	r1, 123fe <_vasnprintf_r+0xe>
   123fa:	cmp	r4, #0
   123fc:	bne.n	12434 <_vasnprintf_r+0x44>
   123fe:	movs	r4, #0
   12400:	mov.w	r2, #648	; 0x288
   12404:	strh.w	r2, [sp, #12]
   12408:	str	r4, [sp, #0]
   1240a:	str	r4, [sp, #16]
   1240c:	mov	r2, r3
   1240e:	movw	r6, #65535	; 0xffff
   12412:	ldr	r3, [sp, #120]	; 0x78
   12414:	str	r4, [sp, #8]
   12416:	mov	r1, sp
   12418:	str	r4, [sp, #20]
   1241a:	strh.w	r6, [sp, #14]
   1241e:	bl	d190 <_svfprintf_r>
   12422:	cmp	r0, #0
   12424:	blt.n	1244a <_vasnprintf_r+0x5a>
   12426:	ldr	r3, [sp, #0]
   12428:	str	r0, [r5, #0]
   1242a:	movs	r2, #0
   1242c:	strb	r2, [r3, #0]
   1242e:	ldr	r0, [sp, #16]
   12430:	add	sp, #104	; 0x68
   12432:	pop	{r4, r5, r6, pc}
   12434:	mov.w	r2, #1544	; 0x608
   12438:	str	r1, [sp, #0]
   1243a:	str	r1, [sp, #16]
   1243c:	strh.w	r2, [sp, #12]
   12440:	bge.n	1240c <_vasnprintf_r+0x1c>
   12442:	movs	r3, #139	; 0x8b
   12444:	str	r3, [r0, #0]
   12446:	movs	r0, #0
   12448:	b.n	12430 <_vasnprintf_r+0x40>
   1244a:	movs	r0, #0
   1244c:	b.n	12430 <_vasnprintf_r+0x40>
   1244e:	nop

00012450 <_calloc_r>:
   12450:	push	{r4, lr}
   12452:	mul.w	r1, r2, r1
   12456:	bl	b360 <_malloc_r>
   1245a:	mov	r4, r0
   1245c:	cbz	r0, 12496 <_calloc_r+0x46>
   1245e:	ldr.w	r2, [r0, #-4]
   12462:	bic.w	r2, r2, #3
   12466:	subs	r2, #4
   12468:	cmp	r2, #36	; 0x24
   1246a:	bhi.n	1249e <_calloc_r+0x4e>
   1246c:	cmp	r2, #19
   1246e:	bls.n	1249a <_calloc_r+0x4a>
   12470:	movs	r3, #0
   12472:	cmp	r2, #27
   12474:	str	r3, [r0, #0]
   12476:	str	r3, [r0, #4]
   12478:	bls.n	124a8 <_calloc_r+0x58>
   1247a:	cmp	r2, #36	; 0x24
   1247c:	str	r3, [r0, #8]
   1247e:	str	r3, [r0, #12]
   12480:	iteee	ne
   12482:	addne.w	r2, r0, #16
   12486:	streq	r3, [r0, #16]
   12488:	streq	r3, [r0, #20]
   1248a:	addeq.w	r2, r0, #24
   1248e:	movs	r3, #0
   12490:	str	r3, [r2, #0]
   12492:	str	r3, [r2, #4]
   12494:	str	r3, [r2, #8]
   12496:	mov	r0, r4
   12498:	pop	{r4, pc}
   1249a:	mov	r2, r0
   1249c:	b.n	1248e <_calloc_r+0x3e>
   1249e:	movs	r1, #0
   124a0:	bl	90e4 <memset>
   124a4:	mov	r0, r4
   124a6:	pop	{r4, pc}
   124a8:	add.w	r2, r0, #8
   124ac:	b.n	1248e <_calloc_r+0x3e>
   124ae:	nop
   124b0:	.word	0x25206425
   124b4:	.short	0x0a64
   124b6:	.byte	0x00
   124b7:	.byte	0x62
   124b8:	.word	0x63697361
   124bc:	.word	0x756f5320
   124c0:	.word	0x5220646e
   124c4:	.word	0x726f6365
   124c8:	.word	0x20726564
   124cc:	.word	0x73726556
   124d0:	.word	0x3a6e6f69
   124d4:	.word	0x62654620
   124d8:	.word	0x20372020
   124dc:	.word	0x32323032
   124e0:	.word	0x3a393020
   124e4:	.word	0x323a3632
   124e8:	.word	0x6e450035
   124ec:	.word	0x666f2064
   124f0:	.word	0x74655320
   124f4:	.word	0x0a007075
   124f8:	.word	0x706f6f4c
   124fc:	.word	0x2000203a
   12500:	.word	0xff00203a

00012504 <vtable for Stream>:
	...
   1250c:	U...............
   1251c:	U...U...U...

00012528 <vtable for StreamFile<FsBaseFile, unsigned long long>>:
	...
   12530:	............9...
   12540:	U...{...O...

0001254c <vtable for FsFile>:
	...
   12554:	............9...
   12564:	U...{...O...

00012570 <vtable for File>:
	...
   12578:	................
   12588:	................
   12598:	....

0001259c <vtable for SDFile>:
	...
   125a4:	............3...
   125b4:	_...Y...C...A...
   125c4:	................
   125d4:	-...............
   125e4:	....5...........
   125f4:	..../Config.txt.
   12604:	%10d.... Menu. '
   12614:	:h'  : print hel
   12624:	p. ':s'  : start
   12634:	 acquisition. ':
   12644:	e'  : stop acqui
   12654:	sition. ':w'  : 
   12664:	write parameters
   12674:	 to microSD card
   12684:	. ':l'  : list d
   12694:	isks. ':r'  : re
   126a4:	set MTP. ':b'  :
   126b4:	 reboot CPU. '?p
   126c4:	'  : show all pa
   126d4:	rameters. '?d'  
   126e4:	: get date. '?t'
   126f4:	  : get time. '?
   12704:	a'  : get file d
   12714:	uration (s). '!d
   12724:	 yyyy/mm/dd<cr>'
   12734:	  : set date. '!
   12744:	t hh:mm:ss<cr>' 
   12754:	   : set time. '
   12764:	!a val<cr>'  : s
   12774:	et file duration
   12784:	 (s).CVAS_V3 Ver
   12794:	sion: Feb  7 202
   127a4:	2 09:26:25.Teens
   127b4:	y: %d: %06x..Dat
   127c4:	e d = %04d/%02d/
   127d4:	%02d..Time t = %
   127e4:	02d:%02d:%02d..T
   127f4:	_acq a = %d..%d%
   12804:	c%d%c%d.start.st
   12814:	op.rebooting CPU
	...

00012825 <monthDays>:
   12825:	...............

00012834 <vtable for MySpiClass>:
	...
   1283c:	........-.......
   1284c:	....).......y...
   1285c:	No spi storage.S
   1286c:	torage %d %d %s 
   1287c:	.%d %d.D./%s%06x
   1288c:	_%04d%02d%02d/%0
   1289c:	2d/./%s%06x_%04d
   128ac:	%02d%02d/%02d_%0
   128bc:	2d/.F.%s_%02d%02
   128cc:	d%02d.bin.Failin
   128dc:	g open file.WMXZ
   128ec:	.%s%04d%02d%02d_
   128fc:	%02d%02d%02d.sd1
   1290c:	.No I2C address 
   1291c:	found...

00012924 <TwoWire::i2c0_hardware>:
   12924:	4..@@.....".0...
   12934:	....!./.........

00012944 <TwoWire::i2c1_hardware>:
   12944:	4..@....&:......
   12954:	..%;............

00012964 <TwoWire::i2c2_hardware>:
   12964:	(..@@...........
   12974:	............J...

00012984 <vtable for TwoWire>:
	...
   1298c:	.%..%&.......%..
   1299c:	.%...%...%..

000129a8 <SPISettings::ctar_div_table>:
   129a8:	................
   129b8:	...... .(.8.@.`.
   129c8:	................

000129d8 <SPIClass::spi0_hardware>:
   129d8:	<..@............
   129e8:	.....0....'.....
   129f8:	................
   12a08:	................
   12a18:	................
   12a28:	..........-.....
   12a38:	................
   12a48:	................
   12a58:	................
   12a68:	.. .

00012a6c <SPISettings::ctar_clock_table>:
   12a6c:	................
   12a7c:	................
   12a8c:	. ....... ...0..
   12a9c:	. ... ...@...@..
   12aac:	.P...P...`...`..
   12abc:	.p...`...p..

00012ac8 <vtable for SDClass>:
	...
   12ad0:	.....1...1..K2..
   12ae0:	.1..S1...2...2..
   12af0:	.3..34..

00012af8 <FsGetPartitionInfo::mbdpGuid>:
   12af8:	......3D..h..&..
   12b08:	EFI PART..

00012b12 <lookupTable>:
   12b12:	..x...C.........
   12b22:	..............=.
   12b32:	.. .............
   12b42:	................
   12b52:	................
   12b62:	....:.e,<.;.>.f,
   12b72:	B.A.S...T...V...
   12b82:	W...Y...[...`...
   12b92:	c...h...i...k.b,
   12ba2:	o...r...u...}.d,
   12bb2:	..............D.
   12bc2:	..........E.....
   12bd2:	{...|...}.......
   12be2:	................
   12bf2:	................
   12c02:	}.c,Q.Y.S.[.U.].
   12c12:	W._.x...y.......
   12c22:	............N!2!
   12c32:	.!.!a,`,v,u,

00012c3e <mapTable>:
   12c3e:	a..............0
   12c4e:	2...9...J...y...
   12c5e:	................
   12c6e:	.......("...F...
   12c7e:	................
   12c8e:	0.. P...`.."...6
   12c9e:	.......Da..&....
   12cae:	...Z........ ...
   12cbe:	0...@...`...p.J.
   12cce:	r.V.v.d.z.p.|.~.
   12cde:	................
   12cee:	........p!...$..
   12cfe:	0,./g,...,.d.-.&
   12d0e:	A...Device is to
   12d1e:	o small...Writin
   12d2e:	g FAT ...Writing
   12d3e:	 upcase table...
   12d4e:	Writing root...F
   12d5e:	ormat done...For
   12d6e:	mat failed...EXF
   12d7e:	AT.Bad cluster c
   12d8e:	ount...Card is t
   12d9e:	oo small....Form
   12dae:	at Done...Format
   12dbe:	 Failed...

00012dc8 <vtable for SdSpiCard>:
	...
   12dd0:	%w..'w..!x...w..
   12de0:	.|...}..5w...}..
   12df0:	.....x...y...~..
   12e00:	.w...w...|..w|..
   12e10:	.|......!w......
   12e20:	.}...~..

00012e28 <vtable for SdioCard>:
	...
   12e30:	E...............
   12e40:	................
   12e50:	).......S.......
   12e60:	................
   12e70:	5...a...........
   12e80:	=...!...

00012e88 <digital_pin_to_info_PGM>:
   12e88:	@..C@..@D..CD..@
   12e98:	...C...@0..C0..@
   12ea8:	4..C4..@...C...@
   12eb8:	...C...@...C...@
   12ec8:	...C...@...C...@
   12ed8:	...C...@...C...@
   12ee8:	...C...@...C...@
   12ef8:	...C...@...C...@
   12f08:	...C...@...C...@
   12f18:	...C...@...C...@
   12f28:	...C...@...C...@
   12f38:	...C...@...C...@
   12f48:	h .Ch..@...C...@
   12f58:	8..C8..@<..C<..@
   12f68:	@..C@..@H..CH..@
   12f78:	L..CL..@(..C(..@
   12f88:	,..C,..@` .C`..@
   12f98:	d .Cd..@ ..C ..@
   12fa8:	$..C$..@(..C(..@
   12fb8:	,..C,..@D..CD..@
   12fc8:	p..Cp..@t..Ct..@
   12fd8:	h..Ch..@P..CP..@
   12fe8:	X..CX..@\..C\..@
   12ff8:	T..CT..@ ..C ..@
   13008:	$..C$..@...C...@
   13018:	...C...@8..C8..@
   13028:	4..C4..@0..C0..@
   13038:	<..C<..@,..C,..@
   13048:	( .C(..@, .C,..@
   13058:	. .C...@. .C...@
   13068:	. .C...@. .C...@
   13078:	. .C...@. .C...@

00013088 <vtable for usb_serial_class>:
	...
   13090:	................
   130a0:	................
   130b0:	..

000130b2 <usb_endpoint_config_table>:
   130b2:	......

000130b8 <usb_descriptor_list>:
   130b8:	....[...........
   130c8:	....C...........
   130d8:	........n.......
   130e8:	................
   130f8:	................
   13108:	....

0001310c <_global_impure_ptr>:
   1310c:	....C...POSIX...
   1311c:	....

00013120 <fpi.6173>:
   13120:	5...............
   13130:	....nf..inity...
   13140:	an..

00013144 <fpinan.6209>:
   13144:	4...............
   13154:	....

00013158 <tinytens>:
   13158:	.......<3...#.I9
   13168:	=..D...2......[%
   13178:	Co.d(.h.

00013180 <zeroes.7258>:
   13180:	0000000000000000
   13190:	INF.inf.NAN.nan.
   131a0:	0123456789ABCDEF
   131b0:	....0123456789ab
   131c0:	cdef....(null)..
   131d0:	0...

000131d4 <blanks.7257>:
   131d4:	                

000131e4 <basefix.7328>:
   131e4:	................
   131f4:	................
   13204:	....e%ld....

00013210 <_ctype_>:
   13210:	.         ((((( 
   13220:	                
   13230:	 ...............
   13240:	................
   13250:	..AAAAAA........
   13260:	................
   13270:	..BBBBBB........
   13280:	................
   13290:	 ...............
	...
   13310:	....Infinity....
   13320:	NaN.

00013324 <__hexdig>:
	...
   13354:	................
   13364:	................
	...
   13384:	................
	...
   13424:	....

00013428 <__mprec_tens>:
   13428:	.......?......$@
   13438:	......Y@.....@.@
   13448:	.......@.....j.@
   13458:	.......A......cA
   13468:	.......A....e..A
   13478:	... _..B....vH7B
   13488:	......mB..@..0.B
   13498:	.......B..4&.k.C
   134a8:	...7y.AC....W4vC
   134b8:	..Ngm..C.=.`.X.C
   134c8:	@..x...DP.....KD
   134d8:	..M....D.J...-.D
   134e8:	...yCx.D

000134f0 <__mprec_bigtens>:
   134f0:	...7y.AC.n.....F
   13500:	..?..O8M2.0.Hw.Z
   13510:	<.s..O.u

00013518 <p05.6087>:
   13518:	........}...

00013524 <_init>:
   13524:	push	{r3, r4, r5, r6, r7, lr}
   13526:	nop
   13528:	pop	{r3, r4, r5, r6, r7}
   1352a:	pop	{r3}
   1352c:	mov	lr, r3
   1352e:	bx	lr

00013530 <__init_array_start>:
   13530:	.word	0x0000f84d

00013534 <__frame_dummy_init_array_entry>:
   13534:	5...=....!..9%..
   13544:	.4..

Disassembly of section .fini:

00013548 <_fini>:
   13548:	push	{r3, r4, r5, r6, r7, lr}
   1354a:	nop
