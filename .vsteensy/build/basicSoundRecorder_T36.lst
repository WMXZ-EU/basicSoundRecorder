
.vsteensy/build/basicSoundRecorder_T36.elf:     file format elf32-littlearm

SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
00012d5c l    d  .fini	00000000 .fini
00012d60 l    d  .ARM.exidx	00000000 .ARM.exidx
1fff0000 l    d  .usbdescriptortable	00000000 .usbdescriptortable
1fff0200 l    d  .dmabuffers	00000000 .dmabuffers
1fff0bd0 l    d  .usbbuffers	00000000 .usbbuffers
1fff0f30 l    d  .data	00000000 .data
1fff1dc0 l    d  .bss	00000000 .bss
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 mk20dx128.c
00008cc8 l     F .text	0000000c startup_default_early_hook
00008cd4 l     F .text	00000002 startup_default_late_hook
00000000 l    df *ABS*	00000000 crtstuff.c
00000410 l     F .text	00000000 __do_global_dtors_aux
1fff1dc0 l       .bss	00000000 completed.8605
00000434 l     F .text	00000000 frame_dummy
1fff1dc4 l       .bss	00000000 object.8610
00012d0c l     O .text	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 acq.cpp
00000668 l     F .text	00000050 acq_isr()
1fff0200 l     O .dmabuffers	00000800 tdm_rx_buffer
1fff1de4 l     O .bss	00000400 acq_rx_buffer
00000000 l    df *ABS*	00000000 main.cpp
1fff21e8 l     O .bss	00000004 checkToCloseFile(short, unsigned long)::to
1fff0f34 l     O .data	00000002 loop::status
00000000 l    df *ABS*	00000000 menu.cpp
000009d0 l     F .text	00000024 File::dec_refcount() [clone .isra.15]
00000000 l    df *ABS*	00000000 mTime.cpp
00011fcd l     O .text	0000000c monthDays
00000000 l    df *ABS*	00000000 filing.cpp
000016b4 l     F .text	00000002 __tcf_0
00001778 l     F .text	00000024 File::dec_refcount() [clone .isra.23]
000020f0 l     F .text	000000d0 _GLOBAL__sub_I_data_buffer
1fff0f3c l     O .data	00000004 checkDiskSpace()::isd_
1fff2268 l     O .bss	00000200 saveData(short)::header
00012004 l     O .text	0000001c cs
1fff0f40 l     O .data	00000004 isd
1fff45e0 l     O .bss	00000050 saveData(short)::fileName
1fff4630 l     O .bss	00000004 saveData(short)::dirFlag
1fff4658 l     O .bss	00000050 saveData(short)::dirName
1fff46a8 l     O .bss	00000800 dummy_buffer
00000000 l    df *ABS*	00000000 adc.cpp
00000000 l    df *ABS*	00000000 utils.cpp
00000000 l    df *ABS*	00000000 SPI.cpp
00002200 l     F .text	00000022 DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]
00000000 l    df *ABS*	00000000 output_pwm.cpp
0000255c l     F .text	00000018 _GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE
00000000 l    df *ABS*	00000000 input_i2s.cpp
00002574 l     F .text	00000018 _GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE
00000000 l    df *ABS*	00000000 output_pt8211.cpp
0000258c l     F .text	00000018 _GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE
00000000 l    df *ABS*	00000000 output_adat.cpp
000025a4 l     F .text	00000018 _GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE
00000000 l    df *ABS*	00000000 input_adc.cpp
000025bc l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE
00000000 l    df *ABS*	00000000 output_dac.cpp
000025d4 l     F .text	00000018 _GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE
00000000 l    df *ABS*	00000000 input_adcs.cpp
000025ec l     F .text	00000030 _GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE
00000000 l    df *ABS*	00000000 input_i2s_quad.cpp
0000261c l     F .text	00000018 _GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E
00000000 l    df *ABS*	00000000 output_dacs.cpp
00002634 l     F .text	00000018 _GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE
00000000 l    df *ABS*	00000000 output_i2s_quad.cpp
0000264c l     F .text	00000018 _GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE
00000000 l    df *ABS*	00000000 input_i2s_oct.cpp
00002664 l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E
00000000 l    df *ABS*	00000000 output_tdm.cpp
0000267c l     F .text	00000018 _GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE
00000000 l    df *ABS*	00000000 input_tdm.cpp
00002694 l     F .text	00000018 _GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE
00000000 l    df *ABS*	00000000 input_i2s_hex.cpp
000026ac l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E
00000000 l    df *ABS*	00000000 input_pdm.cpp
000026c4 l     F .text	00000018 _GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE
00000000 l    df *ABS*	00000000 output_i2s.cpp
000026dc l     F .text	00000018 _GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE
00000000 l    df *ABS*	00000000 output_spdif.cpp
000026f4 l     F .text	00000018 _GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE
00000000 l    df *ABS*	00000000 WireKinetis.cpp
1fff7f4c l     O .bss	00000001 TwoWire::isr()::receiving
00000000 l    df *ABS*	00000000 SD.cpp
00002c80 l     F .text	00000064 _GLOBAL__sub_I_SD
00000000 l    df *ABS*	00000000 FsUtf.cpp
00000000 l    df *ABS*	00000000 FsGetPartitionInfo.cpp
000122d0 l     O .text	00000010 FsGetPartitionInfo::mbdpGuid
00000000 l    df *ABS*	00000000 FsStructs.cpp
00000000 l    df *ABS*	00000000 FsCache.cpp
00000000 l    df *ABS*	00000000 upcase.cpp
000122ea l     O .text	0000012c lookupTable
00012416 l     O .text	000000d4 mapTable
00000000 l    df *ABS*	00000000 FsName.cpp
00000000 l    df *ABS*	00000000 ExFatFormatter.cpp
00000000 l    df *ABS*	00000000 ExFatName.cpp
00000000 l    df *ABS*	00000000 ExFatFile.cpp
00000000 l    df *ABS*	00000000 ExFatPartition.cpp
00000000 l    df *ABS*	00000000 ExFatVolume.cpp
00000000 l    df *ABS*	00000000 ExFatFileWrite.cpp
000044e4 l     F .text	0000002e exFatDirChecksum(unsigned char const*, unsigned short)
00000000 l    df *ABS*	00000000 FatFormatter.cpp
00004e2c l     F .text	00000028 initFatDirCallback(unsigned long, void*)
00000000 l    df *ABS*	00000000 FatName.cpp
00000000 l    df *ABS*	00000000 FatFile.cpp
00000000 l    df *ABS*	00000000 FatPartition.cpp
00000000 l    df *ABS*	00000000 FatVolume.cpp
00000000 l    df *ABS*	00000000 FatFileLFN.cpp
000065ce l     F .text	0000001e FatFile::lfnChecksum(unsigned char*) [clone .isra.14]
00000000 l    df *ABS*	00000000 FsFile.cpp
00000000 l    df *ABS*	00000000 FsVolume.cpp
00000000 l    df *ABS*	00000000 FsNew.cpp
00000000 l    df *ABS*	00000000 SdSpiCard.cpp
00006fac l     F .text	00000006 SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]
00006fb2 l     F .text	00000006 SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]
00000000 l    df *ABS*	00000000 SdioTeensy.cpp
00007794 l     F .text	00000028 sdIrs()
000077bc l     F .text	00000018 isBusyCommandComplete()
000077d4 l     F .text	00000010 isBusyCommandInhibit()
000077e4 l     F .text	00000014 isBusyDat()
000077f8 l     F .text	0000000c isBusyDMA()
00007804 l     F .text	00000014 isBusyFifoRead()
00007818 l     F .text	00000014 isBusyFifoWrite()
0000782c l     F .text	00000018 isBusyTransferComplete()
00007844 l     F .text	00000098 setSdclk(unsigned long)
00007940 l     F .text	00000024 waitTimeout(bool (*)())
00007964 l     F .text	00000040 yieldTimeout(bool (*)())
000079d4 l     F .text	00000054 cardCommand(unsigned long, unsigned long)
00007a28 l     F .text	00000020 statusCMD13()
00007a48 l     F .text	00000010 isBusyCMD13()
00007a5c l     F .text	00000068 readReg16(unsigned long, void*)
00007ac4 l     F .text	00000020 waitDmaStatus() [clone .part.4]
00007ae4 l     F .text	0000009c rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)
00007cbc l     F .text	0000005c waitTransferComplete()
00008058 l     F .text	00000098 cardCMD6(unsigned long, unsigned char*)
1fff8428 l     O .bss	00000001 m_version2
1fff8429 l     O .bss	00000010 m_cid
1fff843c l     O .bss	00000004 m_busyFcn
1fff8440 l     O .bss	00000001 m_highCapacity
1fff8444 l     O .bss	00000004 m_ocr
1fff8448 l     O .bss	00000004 m_rca
1fff844c l     O .bss	00000001 m_transferActive
1fff8450 l     O .bss	00000004 m_irqstat
1fff1358 l     O .data	00000001 m_errorCode
1fff8454 l     O .bss	00000001 m_initDone
1fff8455 l     O .bss	00000010 m_csd
1fff8465 l     O .bss	00000001 m_dmaBusy
1fff8468 l     O .bss	00000004 m_sdClkKhz
1fff846c l     O .bss	00000004 m_errorLine
00000000 l    df *ABS*	00000000 memcpy-armv7m.o
00000000 l    df *ABS*	00000000 memset.o
00000000 l    df *ABS*	00000000 usb_serial.c
1fff8471 l     O .bss	00000001 tx_noautoflush
1fff8474 l     O .bss	00000004 tx_packet
1fff8478 l     O .bss	00000001 transmit_previous_timeout
1fff847c l     O .bss	00000004 rx_packet
00000000 l    df *ABS*	00000000 analog.c
1fff8481 l     O .bss	00000001 calibrating
1fff1359 l     O .data	00000001 analog_config_bits
1fff8482 l     O .bss	00000001 analog_reference_internal
1fff135a l     O .data	00000001 analog_num_average
00000000 l    df *ABS*	00000000 pins_teensy.c
00008d44 l     F .text	00000002 startup_default_middle_hook
00000000 l    df *ABS*	00000000 usb_mem.c
1fff1360 l     O .data	00000004 usb_buffer_available
00000000 l    df *ABS*	00000000 usb_dev.c
00008fa0 l     F .text	00000040 endpoint0_transmit
1fff8488 l     O .bss	00000004 ep0_tx_ptr
1fff848c l     O .bss	00000010 rx_last
1fff849c l     O .bss	00000004 tx_state
1fff84a0 l     O .bss	00000040 ep0_rx0_buf
1fff84e0 l     O .bss	00000010 rx_first
1fff84f0 l     O .bss	00000001 ep0_tx_bdt_bank
1fff84f4 l     O .bss	00000040 ep0_rx1_buf
1fff8534 l     O .bss	00000010 tx_first
1fff0000 l     O .usbdescriptortable	000000a0 table
1fff8544 l     O .bss	00000010 tx_last
1fff8554 l     O .bss	00000008 setup
1fff855c l     O .bss	00000002 ep0_tx_len
1fff855f l     O .bss	00000008 reply_buffer
1fff8568 l     O .bss	00000001 ep0_tx_data_toggle
00000000 l    df *ABS*	00000000 yield.cpp
1fff8569 l     O .bss	00000001 yield::running
00000000 l    df *ABS*	00000000 DMAChannel.cpp
00000000 l    df *ABS*	00000000 EventResponder.cpp
00000000 l    df *ABS*	00000000 usb_inst.cpp
00000000 l    df *ABS*	00000000 Print.cpp
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 AudioStream.cpp
00000000 l    df *ABS*	00000000 Stream.cpp
00000000 l    df *ABS*	00000000 serialEvent.cpp
00000000 l    df *ABS*	00000000 new.cpp
00000000 l    df *ABS*	00000000 usb_desc.c
1fff1379 l     O .data	00000012 device_descriptor
1fff13a4 l     O .data	00000043 config_descriptor
00000000 l    df *ABS*	00000000 nonstd.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 atexit_arm.cc
00000000 l    df *ABS*	00000000 _lshrdi3.o
00000000 l    df *ABS*	00000000 _arm_addsubdf3.o
00000000 l    df *ABS*	00000000 _arm_muldivdf3.o
00000000 l    df *ABS*	00000000 _arm_cmpdf2.o
00000000 l    df *ABS*	00000000 _arm_unorddf2.o
00000000 l    df *ABS*	00000000 _arm_fixdfsi.o
00000000 l    df *ABS*	00000000 _arm_fixunsdfsi.o
00000000 l    df *ABS*	00000000 _arm_truncdfsf2.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 cxa_atexit.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 locale.c
0000aa80 l     F .text	00000018 __get_current_locale
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 lib_a-memchr.o
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 sscanf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 lib_a-strlen.o
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strtod.c
0000b8bc l     F .text	00000038 sulp
000128f8 l     O .text	00000014 fpi.6173
0001291c l     O .text	00000014 fpinan.6209
00012930 l     O .text	00000028 tinytens
00000000 l    df *ABS*	00000000 strtol.c
0000c7f0 l     F .text	00000136 _strtol_l.isra.0
00000000 l    df *ABS*	00000000 vfprintf.c
00012958 l     O .text	00000010 zeroes.7258
000129ac l     O .text	00000010 blanks.7257
00000000 l    df *ABS*	00000000 vfscanf.c
000129bc l     O .text	00000022 basefix.7328
00000000 l    df *ABS*	00000000 vdprintf.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0000f00c l     F .text	00000014 register_fini
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 dtoa.c
0000f02c l     F .text	00000128 quorem
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
00010220 l     F .text	000000a8 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 localeconv.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mprec.c
00012cf0 l     O .text	0000000c p05.6087
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 strtoll.c
0001137c l     F .text	000001ac _strtoll_l.isra.0
00000000 l    df *ABS*	00000000 strtoul.c
0001154c l     F .text	00000168 _strtoul_l.isra.0
00000000 l    df *ABS*	00000000 strtoull.c
000116d8 l     F .text	000001ec _strtoull_l.isra.0
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 vfscanf.c
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vasnprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 impure.c
1fff1418 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 ctype_.c
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.19/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crti.o
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.19/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crtn.o
00000000 l    df *ABS*	00000000 FsDateTime.cpp
00000000 l    df *ABS*	00000000 HardwareSerial.cpp
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 
1fff1dc0 l       .bss	00000000 __bss_start__
1fff85f0 l       .bss	00000000 __bss_end__
00000000 l       *UND*	00000000 software_init_hook
00000000 l       *UND*	00000000 hardware_init_hook
00000000 l       *UND*	00000000 __stack
000054c0  w    F .text	00000026 FatPartition::cacheSync()
00008cc0  w    F .text	00000006 adc0_isr
000008ee  w    F .text	00000066 SDFile::getModifyTime(DateTimeFields&)
000030d4 g     F .text	000000a4 toUpcase(unsigned short)
000018e8 g     F .text	00000034 pushData(unsigned long*)
0000a5a4 g     F .text	0000002c .hidden __aeabi_dcmpun
000089a4 g     F .text	0000001c usb_serial_available
00001190 g     F .text	000001b4 menu()
000112a8 g     F .text	0000005e __any_on
0000a568 g     F .text	00000012 .hidden __aeabi_dcmple
00006220 g     F .text	0000002e FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)
0000a4a4 g     F .text	0000007a .hidden __cmpdf2
00007fe0 g     F .text	00000078 SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)
000097ec  w    F .text	000000d8 yield
1fff1de0 g     O .bss	00000004 acq_miss
00006060 g     F .text	000001c0 FatFile::write(void const*, unsigned int)
0000a4a4 g     F .text	0000007a .hidden __eqdf2
00006f1c  w    F .text	00000002 SdSpiCard::~SdSpiCard()
00009a6c g     F .text	000000a6 Print::printNumber64(unsigned long long, unsigned char, unsigned char)
1fff138c g     O .data	00000018 usb_string_manufacturer_name_default
00005ff6 g     F .text	00000068 FatFile::truncate()
1fff121c g     O .data	0000013c Wire1
000032d8 g     F .text	00000458 ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)
1fff463c g     O .bss	0000001c clusterSize
0000a014 g     F .text	0000005a .hidden __floatdidf
00001344 g     F .text	00000024 newHour()
00008c8c  w    F .text	00000034 hard_fault_isr
00008cc0  w    F .text	00000006 dma_ch6_isr
0000179c  w    F .text	00000054 MySpiClass::deactivate()
1fff8418 g     O .bss	00000004 FsDateTime::callback
00002468  w    F .text	000000d8 SPIClass::dma_rxisr()
00002b76  w    F .text	00000050 SdBase<FsVolume>::restart()
00004efc g     F .text	0000005c FatFormatter::initPbs()
000099ac g     F .text	00000020 Print::println()
000027ac g     F .text	00000114 TwoWire::isr()
00008cc0  w    F .text	00000006 uart0_lon_isr
00003b6c g     F .text	000000d0 ExFatFile::seekSet(unsigned long long)
0000903c g     F .text	00000078 usb_rx_memory
00006f00  w    F .text	00000004 SdSpiCard::errorCode() const
0000083a  w    F .text	0000000c File::flush()
00000888  w    F .text	00000066 SDFile::getCreateTime(DateTimeFields&)
00008cc0  w    F .text	00000006 dma_ch8_isr
0000b260 g     F .text	00000002 __malloc_unlock
00006fcc g     F .text	00000026 SdSpiCard::spiStart()
00000e04  w    F .text	00000088 SDFile::openNextFile(unsigned char)
1fff8424 g     O .bss	00000004 FsVolume::m_cwv
00005ae4 g     F .text	000000a8 FatFile::open(FatFile*, char const*, int)
1fff7eb8 g     O .bss	00000004 SerNum
00008bd4 g     F .text	000000b8 analog_init
00001764  w    F .text	00000014 MySpiClass::begin(SdSpiConfig)
000090b4 g     F .text	00000080 usb_tx
0000c7d0 g     F .text	00000020 _strtod_r
00008cc0  w    F .text	00000006 portcd_isr
000018b8  w    F .text	00000016 MySpiClass::setSckSpeed(unsigned long)
0000eebc g     F .text	0000004a _vdprintf_r
00005bce g     F .text	00000020 FatFile::getCreateDateTime(unsigned short*, unsigned short*)
00001cd8 g     F .text	00000418 saveData(short)
00009ce8 g     F .text	00000018 .hidden __aeabi_llsr
00011d44  w    O .text	0000005c vtable for SDFile
00011aa8 g     F .text	00000082 _sfread_r
0000b194 g     F .text	000000c6 memmove
1fff7f04 g     O .bss	00000008 AudioOutputAnalogStereo::dma
0000aabc g     F .text	00000014 __locale_ctype_ptr
00008648 g     F .text	00000060 SdioCard::stopTransmission(bool)
00010a20 g     F .text	0000004c _Balloc
00008cc0  w    F .text	00000006 can1_rx_warn_isr
00012d68 g       .ARM.exidx	00000000 __exidx_end
00008cc0  w    F .text	00000006 dma_error_isr
00002b3c  w    F .text	0000003a SdBase<FsVolume>::cardBegin(SdSpiConfig)
000063de g     F .text	00000046 FatPartition::freeChain(unsigned long)
1fff857c g     O .bss	00000001 EventResponder::runningFromYield
000071b2 g     F .text	0000007c SdSpiCard::cardCommand(unsigned char, unsigned long)
000028c0 g     F .text	0000000c i2c0_isr
000015fc  w    F .text	0000009c MySpiClass::activate()
00009982 g     F .text	00000028 Print::write(unsigned char const*, unsigned int)
0000a494 g     F .text	0000008a .hidden __gtdf2
0000aa24 g     F .text	0000000c __errno
00000af8  w    F .text	0000000a SDFile::isDirectory()
00004a4c g     F .text	00000112 ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
00000812  w    F .text	0000000c File::write(unsigned char const*, unsigned int)
00008cc0  w    F .text	00000006 portd_isr
00000f94 g     F .text	0000001c saveParameters()
00008cc0  w    F .text	00000006 enet_error_isr
0000722e  w    F .text	0000001e SdSpiCard::cardAcmd(unsigned char, unsigned long)
0001225c g     O .text	00000020 TwoWire::i2c2_hardware
000009f4  w    F .text	0000001c File::~File()
1fff856c g     O .bss	00000004 EventResponder::firstInterrupt
000109a4 g     F .text	00000004 __localeconv_l
00006f1e  w    F .text	0000000e SdSpiCard::~SdSpiCard()
0000322a g     F .text	0000001c ExFatFormatter::writeUpcaseUnicode(unsigned short)
00000494 g     F .text	00000028 acq_startClocks()
00006cb2 g     F .text	00000062 FsBaseFile::FsBaseFile(FsBaseFile const&)
00008cc0  w    F .text	00000006 tpm1_isr
00004478 g     F .text	00000018 ExFatPartition::rootLength()
00000d36  w    F .text	00000036 SDFile::setCreateTime(DateTimeFields const&)
00006f04  w    F .text	00000004 SdSpiCard::errorData() const
00009974  w    F .text	00000008 usb_serial_class::write(unsigned char const*, unsigned int)
00012660 g     O .text	00000200 digital_pin_to_info_PGM
0000046c g     F .text	00000028 acq_stopClocks()
1fff85ec g     O .bss	00000004 errno
00007400 g     F .text	00000038 SdSpiCard::readOCR(unsigned long*)
00004204 g     F .text	0000003e ExFatPartition::fatGet(unsigned long, unsigned long*)
0000b70c g     F .text	00000004 __seofread
00012d68 g       .ARM.exidx	00000000 _etext
00002540 g     F .text	00000010 _spi_dma_rxISR0()
00001c58 g     F .text	00000078 listDisks()
1fff1dc0 g       .bss	00000000 _sbss
00004f58 g     F .text	0000005c FatFormatter::writeMbr()
00001960 g     F .text	0000001c sdCsInit(unsigned char)
00002c2a g     F .text	00000054 SDClass::mediaPresent()
0000a530 g     F .text	00000010 .hidden __aeabi_cdcmple
000078e8 g     F .text	0000000c SdioCard::errorData() const
00000ba6  w    F .text	00000018 FsBaseFile::peek()
00007f20 g     F .text	000000c0 SdioCard::writeSector(unsigned long, unsigned char const*)
00008cc0  w    F .text	00000006 porte_isr
00000770 g     F .text	0000009c loop
00008cc0  w    F .text	00000006 portb_isr
00008cc0  w    F .text	00000006 spi1_isr
00008cc0  w    F .text	00000006 uart3_status_isr
00003940 g     F .text	0000007c ExFatFile::parsePathName(char const*, ExName_t*, char const**)
00008cc0  w    F .text	00000006 mcm_isr
0000844c g     F .text	000000c4 SdioCard::readData(unsigned char*)
0000704a g     F .text	00000060 SdSpiCard::readData(unsigned char*, unsigned int)
1fff8570 g     O .bss	00000004 EventResponder::lastInterrupt
00008cc0  w    F .text	00000006 uart1_status_isr
00006d14 g     F .text	00000028 FsBaseFile::close()
00008734 g     F .text	000001a6 memcpy
00008cc0  w    F .text	00000006 randnum_isr
00010808 g     F .text	00000180 __hexnan
0000a520 g     F .text	00000020 .hidden __aeabi_cdrcmple
0000081e  w    F .text	0000000c File::available()
00001820  w    F .text	00000014 Print::println(unsigned long)
00002ce4 g     F .text	00000094 FsUtf::cpToMb(unsigned long, char*, char*)
00000f04 g     F .text	00000090 storeConfig(unsigned short*, int)
000042ea g     F .text	0000005e ExFatPartition::freeChain(unsigned long)
0000579c g     F .text	00000028 FatFile::peek()
0000c950 g     F .text	000016e4 _svfprintf_r
00009fa4 g     F .text	00000022 .hidden __floatsidf
1fff21f0  w    O .bss	00000001 SDFile::name()::zeroterm
1fff8484 g     O .bss	00000004 systick_millis_count
0000a49c g     F .text	00000082 .hidden __ltdf2
000049a6 g     F .text	000000a6 ExFatFile::rename(ExFatFile*, char const*)
00008c8c  w    F .text	00000034 bus_fault_isr
00000994  w    F .text	0000003c SDFile::truncate(unsigned long long)
00008cc0  w    F .text	00000006 watchdog_isr
0000a700 g     F .text	00000000 .hidden __aeabi_uldivmod
000028cc g     F .text	0000000c i2c1_isr
1fff8567 g     O .bss	00000001 usb_configuration
00008cc0  w    F .text	00000006 dma_ch11_isr
000015f6  w    F .text	00000006 SdCardInterface::status()
000086a8 g     F .text	0000001c SdioCard::syncDevice()
00007da0 g     F .text	00000094 SdioCard::writeData(unsigned char const*)
00000000  w      *UND*	00000000 __fini_array_end
00000ac4  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::available()
1fff21f2 g     O .bss	00000020 store
000057c4 g     F .text	0000003a FatFile::readDirCache(bool)
00011200 g     F .text	00000060 __ratio
000028d8 g     F .text	0000000c i2c2_isr
1fff7ee4 g     O .bss	00000008 AudioOutputAnalog::dma
1fff138c  w    O .data	00000018 usb_string_manufacturer_name
1fff85e4 g     O .bss	00000008 usb_rx_byte_count_data
00008cc0  w    F .text	00000006 pit1_isr
0000aad0 g     F .text	00000010 malloc
00008cc0  w    F .text	00000006 dma_ch4_isr
0001223c g     O .text	00000020 TwoWire::i2c1_hardware
00009b24 g     F .text	00000074 software_isr
00006fb8  w    F .text	00000014 SysCall::curTimeMS()
00002bc6 g     F .text	00000064 SDClass::format(int, char, Print&)
00011cf4  w    O .text	00000024 vtable for FsFile
00010988 g     F .text	0000001c iswspace
00008cc0  w    F .text	00000006 dma_ch7_isr
00002718  w    F .text	0000001e TwoWire::read()
00012c00 g     O .text	000000c8 __mprec_tens
00009758 g     F .text	00000094 usb_init
00006f18  w    F .text	00000004 SdSpiCard::type() const
0000a620 g     F .text	00000040 .hidden __fixunsdfsi
00008cc0  w    F .text	00000006 lptmr_isr
00000c3c  w    F .text	00000058 SDFile::seek(unsigned long long, int)
1fff85ac g     O .bss	00000004 __malloc_top_pad
00008d24 g     F .text	00000020 rtc_set
00011a6c g     F .text	0000003a __ssrefill_r
000070aa g     F .text	0000006a SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
00004b5e g     F .text	000000be ExFatFile::truncate()
1fff0f30 g     O .data	00000000 .hidden __dso_handle
00009f84 g     F .text	0000001e .hidden __aeabi_ui2d
000109a8 g     F .text	0000001c _localeconv_r
1fff0f44 g     O .data	0000001c sd_str
000118c4 g     F .text	00000024 _strtoull_r
00008d08 g     F .text	00000010 attachInterruptVector
00010c34 g     F .text	00000012 __i2b
1fff0f30 g       .data	00000000 _sdata
0001221c g     O .text	00000020 TwoWire::i2c0_hardware
000050b8 g     F .text	000001a8 FatFormatter::makeFat32()
0000a730 g     F .text	000002e2 .hidden __udivmoddi4
00009d00 g     F .text	00000000 .hidden __aeabi_drsub
000054e6 g     F .text	00000036 FatFile::addCluster()
0000b644 g     F .text	00000024 _sbrk_r
00007438 g     F .text	00000036 SdSpiCard::readRegister(unsigned char, void*)
000079b4 g     F .text	00000020 SdioCard::type() const
000001d0 g     F .text	000001f0 ResetHandler
00008920 g     F .text	0000004c usb_serial_getchar
00008cc0  w    F .text	00000006 can1_bus_off_isr
00008cc0  w    F .text	00000006 ftm2_isr
00000954  w    F .text	00000040 SDFile::name()
1fff85d8 g     O .bss	00000008 usb_cdc_line_coding
1fff8574 g     O .bss	00000004 EventResponder::lastYield
00008cc0  w    F .text	00000006 uart5_status_isr
00008cc0  w    F .text	00000006 lpuart0_status_isr
0000391a g     F .text	00000026 ExFatFile::openRoot(ExFatVolume*)
0001288a g     O .text	00000004 usb_endpoint_config_table
00008cc0  w    F .text	00000006 dma_ch9_isr
00000a54  w    F .text	0000001c Print::write(char const*)
00000bea  w    F .text	00000020 StreamFile<FsBaseFile, unsigned long long>::read()
00008cc0  w    F .text	00000006 pit2_isr
000031c0 g     F .text	00000028 ExFatFormatter::syncUpcase()
00000d00  w    F .text	00000036 SDFile::setModifyTime(DateTimeFields const&)
0000a554 g     F .text	00000012 .hidden __aeabi_dcmplt
000121c0 g     O .text	0000005c SPISettings::ctar_clock_table
1fff85a8 g     O .bss	00000004 __malloc_max_sbrked_mem
00000a24  w    F .text	00000018 SDFile::position()
00008d48 g     F .text	00000064 pinMode
0000768e g     F .text	00000028 SdSpiCard::writeStop()
00008f5c g     F .text	00000044 usb_free
00008cc0  w    F .text	00000006 i2c3_isr
00009fc8 g     F .text	0000003a .hidden __extendsfdf2
0000e034 g     F .text	00000e88 __ssvfscanf_r
0000a2c4 g     F .text	000001d0 .hidden __aeabi_ddiv
00000bd2  w    F .text	00000018 FsBaseFile::read(void*, unsigned int)
00009d0c g     F .text	00000276 .hidden __adddf3
1fff0fa4 g     O .data	0000013c Wire2
000006dc g     F .text	00000030 checkToCloseFile(short, unsigned long)
00007702 g     F .text	0000002c SdSpiCard::writeData(unsigned char const*)
0000082a  w    F .text	00000010 File::peek()
00006424 g     F .text	0000005c FatPartition::freeClusterCount()
00000e8c  w    F .text	00000078 SDClass::open(char const*, unsigned char)
00011074 g     F .text	000000d0 __b2d
000021c0 g     F .text	00000002 adc_init()
00012d60 g       .ARM.exidx	00000000 __exidx_start
0000a070 g     F .text	00000254 .hidden __aeabi_dmul
00002550  w    F .text	0000000c DMAChannel::~DMAChannel()
000075cc g     F .text	00000030 SdSpiCard::writeStart(unsigned long)
00008cc0  w    F .text	00000006 pit0_isr
1fff8578 g     O .bss	00000004 EventResponder::firstYield
000128e4 g     O .text	00000004 _global_impure_ptr
00001818  w    F .text	00000008 Print::print(unsigned long)
00008cc0  w    F .text	00000006 can1_error_isr
00002d78 g     F .text	00000084 FsUtf::mbToCp(char const*, char const*, unsigned long*)
00000d8a  w    F .text	00000018 StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)
00000dc8  w    F .text	0000003c SDFile::SDFile(FsFile const&)
0000b264 g     F .text	000003de _realloc_r
00000c0a  w    F .text	0000000a SDFile::read(void*, unsigned int)
0000aa30 g     F .text	00000050 __libc_init_array
1fff85f0 g       .bss	00000000 __bss_end
00000b02  w    F .text	00000028 SDFile::rewindDirectory()
0000270c  w    F .text	0000000c TwoWire::available()
00008cc0  w    F .text	00000006 can0_wakeup_isr
00004046 g     F .text	0000000e ExFatFile::open(ExFatVolume*, char const*, int)
000078f4 g     F .text	0000001c SdioCard::readCID(CID*)
00012afc g     O .text	00000100 __hexdig
000047c2 g     F .text	000000de ExFatFile::addDirCluster()
00008cc0  w    F .text	00000006 flash_cmd_isr
00007514 g     F .text	00000076 SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)
000076b6 g     F .text	0000004c SdSpiCard::writeData(unsigned char, unsigned char const*)
00012cc8 g     O .text	00000028 __mprec_bigtens
00010b00 g     F .text	00000098 __s2b
0000995c  w    F .text	00000004 usb_serial_class::clear()
00009f84 g     F .text	0000001e .hidden __floatunsidf
00008cc0  w    F .text	00000006 uart2_status_isr
00008cd8 g     F .text	0000002c _sbrk
00001698  w    F .text	0000001c MySpiClass::send(unsigned char)
00010ec8 g     F .text	00000042 __mcmp
000122a0 g     O .text	00000030 vtable for SDClass
1fff7f1c g     O .bss	00000008 AudioOutputTDM::dma
1fff135c g     O .data	00000004 __brkval
1fff8480 g     O .bss	00000001 usb_cdc_line_rtsdtr
00008b8c g     F .text	00000048 usb_serial_flush_callback
00012cfc g     F .text	00000000 _init
000055a8 g     F .text	0000001e FatFile::cacheDirEntry(unsigned char)
00008cc0  w    F .text	00000006 svcall_isr
0000297e  w    F .text	00000056 SDClass::remove(char const*)
00000b3c  w    F .text	00000026 SDFile::close()
00008cc0  w    F .text	00000006 dma_ch15_isr
00000b64  w    F .text	00000024 SDFile::~SDFile()
0000a660 g     F .text	0000009e .hidden __aeabi_d2f
0001227c g     O .text	00000024 vtable for TwoWire
00008cc0  w    F .text	00000006 uart1_error_isr
0000ff8c g     F .text	00000028 __libc_fini_array
0000b8f8 g     F .text	00000ed8 _strtod_l
000107d8 g     F .text	00000030 __match
00008cc0  w    F .text	00000006 usbhs_phy_isr
1fff7eec g     O .bss	00000008 AudioInputAnalogStereo::dma0
1fff85f0 g       .bss	00000000 _ebss
00007ea8 g     F .text	00000078 SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
1fff2214 g     O .bss	00000004 hour_
1fff7ed4 g     O .bss	00000008 AudioOutputADAT::dma
00000ca8  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::flush()
000015c2  w    F .text	00000034 BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)
00010b98 g     F .text	00000040 __hi0bits
0000388e g     F .text	00000038 ExFatFile::dirCache(unsigned char, unsigned char)
0000a5d0 g     F .text	0000004e .hidden __fixdfsi
000048a0 g     F .text	00000048 ExFatFile::mkdir(ExFatFile*, ExName_t*)
00008cc0 g     F .text	00000006 unused_isr
00000dc8  w    F .text	0000003c SDFile::SDFile(FsFile const&)
00008cc0  w    F .text	00000006 spi0_isr
00008cc0  w    F .text	00000006 dma_ch3_isr
000028e4  w    F .text	00000002 SDClass::~SDClass()
00004490 g     F .text	00000054 ExFatVolume::chdir(char const*)
00002550  w    F .text	0000000c DMAChannel::~DMAChannel()
1fff76b8 g     O .bss	00000800 diskBuffer
1fff2468 g     O .bss	00002178 sdx
00006884 g     F .text	00000092 FatFile::makeUniqueSfn(FatName_t*)
000009f4  w    F .text	0000001c File::~File()
00001998 g     F .text	000002c0 storage_configure()
00005260 g     F .text	000000a0 FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)
0000531a g     F .text	00000028 FatFile::getLfnChar(DirLfn_t*, unsigned char)
00009c1c g     F .text	00000004 operator delete(void*, unsigned int)
00008cc0  w    F .text	00000006 flash_error_isr
00009ce8 g     F .text	00000018 .hidden __lshrdi3
00009d0c g     F .text	00000276 .hidden __aeabi_dadd
1fff2254 g     O .bss	00000014 file
0000a49c g     F .text	00000082 .hidden __ledf2
00008cc0  w    F .text	00000006 uart5_error_isr
00008cc0  w    F .text	00000006 rtc_seconds_isr
0001212c g     O .text	00000094 SPIClass::spi0_hardware
00008cc0  w    F .text	00000006 pdb_isr
00010d78 g     F .text	000000a0 __pow5mult
00005a04 g     F .text	0000004e FatFile::rmdir()
0000a004 g     F .text	0000006a .hidden __aeabi_ul2d
00008c8c  w    F .text	00000034 usage_fault_isr
00008cc0  w    F .text	00000006 dac1_isr
00000000 g     O .text	000001d0 _VectorsFlash
0000635e g     F .text	00000080 FatPartition::allocateCluster(unsigned long, unsigned long*)
00008cc0  w    F .text	00000006 dma_ch14_isr
00009906  w    F .text	00000006 MillisTimer::enableTimerInterrupt(bool)
000028e6  w    F .text	00000044 SDClass::exists(char const*)
00000000  w      *UND*	00000000 __deregister_frame_info
1fff85e0 g     O .bss	00000004 usb_cdc_line_rtsdtr_millis
000006b8  w    F .text	00000024 Print::println(char const*)
0000994c g     F .text	00000010 systick_isr
00000634 g     F .text	00000034 extract(void*, void*)
00001144 g     F .text	0000004c menuGet3Int(int*, int*, int*)
00008cc0  w    F .text	00000006 rtc_alarm_isr
1fff4ea8 g     O .bss	0000000c mySpi
000074ae g     F .text	00000066 SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)
1fff8580 g     O .bss	00000004 AudioStream::first_update
00008cc0  w    F .text	00000006 dma_ch2_isr
1fff1368 g     O .data	00000010 Serial
00008cc0  w    F .text	00000006 ftm1_isr
0000997c  w    F .text	00000006 usb_serial_class::write(unsigned char)
00006dba g     F .text	0000005e FsBaseFile::openNext(FsBaseFile*, int)
00008cc8  w    F .text	0000000c startup_early_hook
0000772e g     F .text	00000048 SdSpiCard::writeSingle(unsigned long, unsigned char const*)
00008cc0  w    F .text	00000006 dma_ch13_isr
00004538 g     F .text	00000092 ExFatFile::addCluster()
00011d18  w    O .text	0000002c vtable for File
00008cc0  w    F .text	00000006 uart2_error_isr
00002ad0  w    F .text	00000036 SDClass::usedSize()
0000896c g     F .text	00000038 usb_serial_peekchar
0000a590 g     F .text	00000012 .hidden __aeabi_dcmpgt
00000fb0 g     F .text	000000d4 printMenu()
0000b090 g     F .text	00000000 memchr
00006302 g     F .text	0000005c FatPartition::fatPut(unsigned long, unsigned long)
1fff1402 g     O .data	00000016 usb_string_serial_number_default
00008c8c g     F .text	00000034 fault_isr
00010050 g     F .text	000001d0 _free_r
00007d18 g     F .text	00000088 SdioCard::readStop()
00003086 g     F .text	0000004e FsCache::get(unsigned long, unsigned char)
0000aa98 g     F .text	0000001c __locale_mb_cur_max
0000a57c g     F .text	00000012 .hidden __aeabi_dcmpge
00008cc0  w    F .text	00000006 usb_charge_isr
0000675c g     F .text	00000128 FatFile::makeSFN(FatName_t*)
0000996c  w    F .text	00000004 usb_serial_class::flush()
00003246 g     F .text	00000090 ExFatFormatter::writeUpcase(unsigned long)
000119e8 g     F .text	00000082 _sungetc_r
00008cc0  w    F .text	00000006 cmt_isr
00009d08 g     F .text	0000027a .hidden __aeabi_dsub
00006480 g     F .text	00000108 FatPartition::init(BlockDeviceInterface*, unsigned char)
00008cc0  w    F .text	00000006 usbhs_isr
1fff1dbc g     O .data	00000004 __malloc_sbrk_base
00009964  w    F .text	00000004 usb_serial_class::read()
00008cc0  w    F .text	00000006 ftm3_isr
00011528 g     F .text	00000024 _strtoll_r
00008cc0  w    F .text	00000006 tsi0_isr
00006c00 g     F .text	000000b2 FatFile::remove()
0000a004 g     F .text	0000006a .hidden __floatundidf
1fff2218 g     O .bss	00000004 msd
00008d04  w    F .text	00000002 __cxa_pure_virtual
000021c2 g     F .text	00000002 adcStatus()
00010e18 g     F .text	000000ae __lshift
00005d08 g     F .text	000000aa FatFile::mkdir(FatFile*, char const*, bool)
000004d4 g     F .text	00000014 acq_stop()
00008cc0  w    F .text	00000006 spi2_isr
1fff7ef4 g     O .bss	00000008 AudioInputAnalogStereo::dma1
000118e8 g     F .text	00000100 __ssprint_r
00011ba4 g     F .text	0000005e _vasnprintf_r
00009c16  w    F .text	00000002 serialEvent()
1fff84f1 g     O .bss	00000001 usb_reboot_timer
1fff7ebc g     O .bss	00000008 AudioOutputPWM::dma
0000ef68 g     F .text	000000a4 __register_exitproc
00003f8c g     F .text	000000ba ExFatFile::open(ExFatFile*, char const*, int)
0000b81c g     F .text	000000a0 strncmp
00000cbc  w    F .text	00000044 FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
000048e8 g     F .text	000000be ExFatFile::mkdir(ExFatFile*, char const*, bool)
00004fb4 g     F .text	00000104 FatFormatter::makeFat16()
000089c0 g     F .text	00000030 usb_serial_flush_input
00004348 g     F .text	00000064 ExFatPartition::freeClusterCount()
00010c48 g     F .text	00000130 __multiply
1fff1ddc g     O .bss	00000004 acq_count
00008ad0 g     F .text	00000016 usb_serial_putchar
00000022 g       *ABS*	00000000 _teensy_model_identifier
1fff85b0 g     O .bss	00000028 __malloc_current_mallinfo
00011144 g     F .text	000000ba __d2b
1fff8588 g     O .bss	00000018 HardwareSerial::s_serials_with_serial_events
00008cc0  w    F .text	00000006 can0_bus_off_isr
000079a4  w    F .text	0000000e SdioCard::~SdioCard()
000018ac  w    F .text	0000000c SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)
1fff855e g     O .bss	00000001 usb_rx_memory_needed
00007e34 g     F .text	00000074 SdioCard::writeStart(unsigned long)
000116b4 g     F .text	00000024 _strtoul_r
00009134 g     F .text	00000624 usb_isr
0000aa18 g     F .text	0000000c __cxa_atexit
000039bc g     F .text	00000184 ExFatFile::read(void*, unsigned int)
00009fa4 g     F .text	00000022 .hidden __aeabi_i2d
00000bc8  w    F .text	0000000a SDFile::peek()
0000303a g     F .text	0000004c FsCache::sync()
1fff0f64 g     O .data	00000040 SPI
0000b130 g     F .text	00000062 memcmp
00012860  w    O .text	00000028 vtable for usb_serial_class
00006688 g     F .text	000000d4 FatFile::createLFN(unsigned short, FatName_t*, unsigned char)
00008cc0  w    F .text	00000006 uart3_error_isr
0000197c g     F .text	0000001c sdCsWrite(unsigned char, bool)
0000b6b4 g     F .text	00000058 sscanf
0000aa14  w    F .text	00000002 .hidden __aeabi_ldiv0
00004650 g     F .text	00000052 ExFatFile::rmdir()
00001108 g     F .text	0000003c menuGetInt(int*)
1fff7f2c g     O .bss	00000008 AudioInputI2SHex::dma
00008cc0  w    F .text	00000006 porta_isr
00002a8a  w    F .text	00000020 FsVolume::bytesPerCluster() const
0000a2c4 g     F .text	000001d0 .hidden __divdf3
00011260 g     F .text	00000046 __copybits
1fff0bd0 g     O .usbbuffers	00000360 usb_buffer_memory
00006f2c g     F .text	00000080 SdSpiCard::sectorCount()
00008cc0  w    F .text	00000006 low_voltage_isr
1fff19b0 g     O .data	00000408 __malloc_av_
00008cc0  w    F .text	00000006 can0_error_isr
1fff21e4 g     O .bss	00000004 max_write
00008e14 g     F .text	0000010c _init_Teensyduino_internal_
00000cb2  w    F .text	0000000a SDFile::flush()
0000a070 g     F .text	00000254 .hidden __muldf3
00008b30 g     F .text	0000005c usb_serial_flush_output
00008cc0  w    F .text	00000006 dma_ch12_isr
1fff7ec4 g     O .bss	00000008 AudioInputI2S::dma
0000b25c g     F .text	00000002 __malloc_lock
0000377c g     F .text	000000b0 ExFatFile::getName8(char*, unsigned int)
00000000  w      *UND*	00000000 __fini_array_start
00008cc0  w    F .text	00000006 can1_wakeup_isr
1fff0a00 g     O .dmabuffers	000001d0 _VectorsRam
00004e54 g     F .text	000000a8 FatFormatter::initFatDir(unsigned char, unsigned long)
00011c04 g     F .text	0000005e _calloc_r
00008cc0  w    F .text	00000006 pit3_isr
00002224 g     F .text	00000078 SPIClass::begin()
1fff0f38 g     O .data	00000004 t_acq
1fff1364 g     O .data	00000001 yield_active_check_flags
00008cc0  w    F .text	00000006 enet_rx_isr
00004784 g     F .text	0000003e ExFatFile::sync()
00005db2 g     F .text	00000196 FatFile::rename(FatFile*, char const*)
000086c4 g     F .text	00000070 SdioCard::isBusy()
00008cc0  w    F .text	00000006 portc_isr
0000758a g     F .text	00000026 SdSpiCard::readStop()
1fff7efc g     O .bss	00000008 AudioInputI2SQuad::dma
000088dc g     F .text	00000000 memset
000018d0 g     F .text	00000018 getCount()
00009b12 g     F .text	00000010 main
1fff7f3c g     O .bss	00000008 AudioOutputI2S::dma
1fff21ec g     O .bss	00000004 max_count
1fff4634 g     O .bss	00000008 rawData
1fff85a4 g     O .bss	00000004 __malloc_max_total_mem
00004082 g     F .text	000000a6 ExFatPartition::bitmapFind(unsigned long, unsigned long)
00001cd0 g     F .text	00000006 checkReboot()
00004c1c g     F .text	00000210 ExFatFile::write(void const*, unsigned int)
00008c8c  w    F .text	00000034 memmanage_fault_isr
00002fac g     F .text	0000008e lbaToMbrChs(unsigned char*, unsigned long, unsigned long)
00005b9a g     F .text	00000034 FatFile::dirEntry(DirFat_t*)
00000ace  w    F .text	0000000a SDFile::available()
00000dac  w    F .text	0000001c File::close()
00009c20 g     F .text	00000070 usb_init_serialnumber
00001554 g     F .text	00000036 setRTCTime(int, int, int, int, int, int)
0000c928 g     F .text	00000024 _strtol_r
0000a660 g     F .text	0000009e .hidden __truncdfsf2
00012d5c g       .text	00000000 __init_array_end
0000f158 g     F .text	00000e34 _dtoa_r
0000aaf0 g     F .text	00000570 _malloc_r
1fff85a0 g     O .bss	00000001 HardwareSerial::s_count_serials_with_serial_events
00008cc0  w    F .text	00000006 debugmonitor_isr
0000ef20 g     F .text	0000001a __ascii_wctomb
00000b9c  w    F .text	0000000a SDFile::isOpen()
00006cb2 g     F .text	00000062 FsBaseFile::FsBaseFile(FsBaseFile const&)
0000a014 g     F .text	0000005a .hidden __aeabi_l2d
1fff8420 g     O .bss	00000004 FatVolume::m_cwv
1fff7f14 g     O .bss	00000008 AudioInputI2SOct::dma
00001810  w    F .text	00000008 Print::print(char const*)
00011b2c g     F .text	00000078 __submore
00009bd0 g     F .text	00000046 Stream::readBytesUntil(char, char*, unsigned int)
0000229c g     F .text	000001cc SPIClass::transfer(void const*, void*, unsigned int)
61f995c6 g       *ABS*	00000000 __rtc_localtime
00008dac g     F .text	0000003c micros
00000000  w      *UND*	00000000 __libc_fini
00008cc0  w    F .text	00000006 cmp1_isr
00008cc0  w    F .text	00000006 ftm0_isr
000046a4 g     F .text	000000e0 ExFatFile::syncDir()
0000ffb4 g     F .text	0000009c _malloc_trim_r
1fff13fe g     O .data	00000004 string0
000089f0 g     F .text	000000e0 usb_serial_write
00008cd4  w    F .text	00000002 startup_late_hook
00000a70  w    F .text	00000054 FsBaseFile::available() const
00009968  w    F .text	00000004 usb_serial_class::available()
1fff1378 g     O .data	00000001 _serialEvent_default
00005a54 g     F .text	00000080 FatFile::sync()
000004e8 g     F .text	0000014c acq_init(int)
000065ec g     F .text	0000009c FatFile::cmpName(unsigned short, FatName_t*, unsigned char)
000029d4  w    F .text	0000004e SDClass::mkdir(char const*)
00004512  w    F .text	00000026 ExFatPartition::cacheSync()
1fff13e8  w    O .data	00000016 usb_string_product_name
00008de8 g     F .text	0000002a delay
0000a4a4 g     F .text	0000007a .hidden __nedf2
00008cc0  w    F .text	00000006 tpm0_isr
1fff856a g     O .bss	00000002 dma_channel_allocated_mask
000038fa g     F .text	00000020 ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)
00000c14  w    F .text	00000028 FsBaseFile::seekSet(unsigned long long)
00012d5c g     F .fini	00000000 _fini
00000c94  w    F .text	00000014 FsBaseFile::sync()
0000274e g     F .text	00000026 TwoWire::write(unsigned char)
1fff7ecc g     O .bss	00000008 AudioOutputPT8211::dma
000120fe g     O .text	0000002e SPISettings::ctar_div_table
0000747e g     F .text	00000030 SdSpiCard::readStart(unsigned long)
00004054 g     F .text	0000002e ExFatFile::openNext(ExFatFile*, int)
00007114 g     F .text	00000076 SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)
0000b668 g     F .text	0000004c sprintf
000099cc g     F .text	0000001a Print::printf(char const*, ...)
00008cc0  w    F .text	00000006 i2s0_rx_isr
00008cc0  w    F .text	00000006 uart4_error_isr
00009a5c g     F .text	00000010 Print::print(long)
00005ad4 g     F .text	00000010 FatFile::close()
00000b88  w    F .text	00000014 SDFile::~SDFile()
0000f020 g     F .text	0000000c atexit
0000793c  w    F .text	00000002 SdioCard::~SdioCard()
00000bbe  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::peek()
0000086c  w    F .text	0000001c File::write(unsigned char)
0000ef3c g     F .text	0000002c _write_r
1fff7f50 g     O .bss	000004c8 SD
00001368 g     F .text	0000012c breakTime(unsigned long, tmElements_t&)
00007be4 g     F .text	000000d8 SdioCard::erase(unsigned long, unsigned long)
00006278  w    F .text	00000020 FsCache::clear()
00008cc0  w    F .text	00000006 can0_message_isr
00009cd0 g     F .text	0000000c nanf
1fff1840 g     O .data	00000004 _impure_ptr
00011cac  w    O .text	00000024 vtable for Stream
00008cc0  w    F .text	00000006 can1_message_isr
00003b40 g     F .text	0000002c ExFatFile::peek()
00011cd0  w    O .text	00000024 vtable for StreamFile<FsBaseFile, unsigned long long>
1fff7f44 g     O .bss	00000008 AudioOutputSPDIF::dma
000109c4 g     F .text	0000005c _mbrtowc_r
00008cc0  w    F .text	00000006 nmi_isr
1fff10e0 g     O .data	0000013c Wire
0000184c  w    F .text	00000060 SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)
00000da2  w    F .text	0000000a SDFile::write(void const*, unsigned int)
00006ed4 g     F .text	00000028 FsVolume::open(char const*, int)
000078dc g     F .text	0000000c SdioCard::errorCode() const
00005b8c g     F .text	0000000e FatFile::open(FatVolume*, char const*, int)
00000d80  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)
1fff2238 g     O .bss	0000001c diskSize
00012d08 g       .text	00000000 __preinit_array_end
000016b6 g     F .text	00000076 dateTime(unsigned short*, unsigned short*, unsigned char*)
00006f1c  w    F .text	00000002 SdSpiCard::~SdSpiCard()
1fff7f24 g     O .bss	00000008 AudioInputTDM::dma
00008cc0  w    F .text	00000006 sdhc_isr
000043ac g     F .text	000000cc ExFatPartition::init(BlockDeviceInterface*, unsigned char)
000041ce g     F .text	00000036 ExFatPartition::dirCache(DirPos_t*, unsigned char)
000075fc g     F .text	00000092 SdSpiCard::erase(unsigned long, unsigned long)
0000b060 g     F .text	0000002a __ascii_mbtowc
00007018 g     F .text	00000032 SdSpiCard::isBusy()
00011020 g     F .text	00000054 __ulp
000125a0 g     O .text	00000060 vtable for SdSpiCard
00007476  w    F .text	00000008 SdSpiCard::readCID(CID*)
00002736  w    F .text	00000016 TwoWire::peek()
0000274c  w    F .text	00000002 TwoWire::flush()
0000070c g     F .text	00000064 setup
00012890 g     O .text	00000054 usb_descriptor_list
00008fe0 g     F .text	00000038 usb_rx
00007a58 g     F .text	00000004 SdioCard::status()
00008cc0  w    F .text	00000006 dma_ch10_isr
0000172c  w    F .text	00000014 MySpiClass::send(unsigned char const*, unsigned int)
00005bee g     F .text	00000020 FatFile::getModifyDateTime(unsigned short*, unsigned short*)
00000810  w    F .text	00000002 Print::flush()
00000b2a  w    F .text	00000012 FsBaseFile::isOpen() const
0000a620 g     F .text	00000040 .hidden __aeabi_d2uiz
00008cc0  w    F .text	00000006 uart0_error_isr
00000ad8  w    F .text	00000020 FsBaseFile::isDir() const
0000292a  w    F .text	00000054 SDClass::rmdir(char const*)
00011fdc  w    O .text	00000028 vtable for MySpiClass
00008f20 g     F .text	0000003c usb_malloc
00005624 g     F .text	00000178 FatFile::read(void*, unsigned int)
00008cc0  w    F .text	00000006 i2s0_isr
000055c6 g     F .text	00000030 FatFile::openRoot(FatVolume*)
1fff841c g     O .bss	00000004 ExFatVolume::m_cwv
00001834  w    F .text	00000018 FsVolume::freeClusterCount() const
20030000 g       .bss	00000000 _estack
00006efc g     F .text	00000004 operator new(unsigned int, unsigned long*)
0000746e  w    F .text	00000008 SdSpiCard::readCSD(csd_t*)
000098c4 g     F .text	00000034 DMAChannel::release()
00000846  w    F .text	00000026 File::read()
00008ae8 g     F .text	00000048 usb_serial_write_buffer_free
0000718a g     F .text	00000028 SdSpiCard::waitNotBusy(unsigned short)
00006ff2 g     F .text	00000026 SdSpiCard::spiStop()
00008cc0  w    F .text	00000006 enet_timer_isr
00006918 g     F .text	00000250 FatFile::open(FatFile*, FatName_t*, int)
0000a540 g     F .text	00000012 .hidden __aeabi_dcmpeq
00001494 g     F .text	000000c0 makeTime(tmElements_t const&)
1fff7f34 g     O .bss	00000008 AudioInputPDM::dma
00002774 g     F .text	00000038 TwoWire::write(unsigned char const*, unsigned int)
00000a10  w    F .text	00000014 File::~File()
000021c4 g     F .text	0000003c _write
1fff1dc0 g       .data	00000000 _edata
000042b0 g     F .text	0000003a ExFatPartition::fatPut(unsigned long, unsigned long)
0000793c  w    F .text	00000002 SdioCard::~SdioCard()
00008cc0  w    F .text	00000006 i2s0_tx_isr
00008cc0  w    F .text	00000006 adc1_isr
00003178 g     F .text	00000048 FsName::get16()
000075b0 g     F .text	0000001c SdSpiCard::syncDevice()
0000382c g     F .text	00000062 ExFatFile::hashName(ExName_t*)
0000551c g     F .text	0000008c FatFile::addDirCluster()
00005c0e g     F .text	000000fa FatFile::mkdir(FatFile*, FatName_t*)
00009970  w    F .text	00000004 usb_serial_class::availableForWrite()
00008cc0  w    F .text	00000006 cmp0_isr
000017f0  w    F .text	00000020 MySpiClass::receive()
0000624e g     F .text	0000002a FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)
00009c90 g     F .text	00000040 ultoa
000028e4  w    F .text	00000002 SDClass::~SDClass()
0000724c g     F .text	000001b4 SdSpiCard::begin(SdSpiConfig)
00006d3c g     F .text	0000007e FsBaseFile::open(FsVolume*, char const*, int)
000098f8  w    F .text	0000000e MillisTimer::disableTimerInterrupt()
00009c18 g     F .text	00000004 operator new(unsigned int)
0000990c g     F .text	0000003c EventResponder::runFromInterrupt()
00001084 g     F .text	00000084 printMenuEntries()
1fff1db8 g     O .data	00000004 __malloc_trim_threshold
00009960  w    F .text	00000004 usb_serial_class::peek()
00010f0c g     F .text	00000114 __mdiff
0000792c g     F .text	00000010 SdioCard::readOCR(unsigned long*)
0000a5d0 g     F .text	0000004e .hidden __aeabi_d2iz
0000426c g     F .text	00000044 ExFatPartition::dirSeek(DirPos_t*, unsigned long)
1fff8470 g     O .bss	00000001 usb_cdc_transmit_flush_timer
000053cc g     F .text	000000f0 FatFile::getName8(char*, unsigned int)
00003c3c g     F .text	00000350 ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)
1fff8586 g     O .bss	00000002 AudioStream::cpu_cycles_total
00008cc0  w    F .text	00000006 pit_isr
00007d18 g     F .text	00000088 SdioCard::writeStop()
00007776  w    F .text	0000001c SdSpiCard::writeSector(unsigned long, unsigned char const*)
00011308 g     F .text	00000072 __sccl
000038c6 g     F .text	00000014 ExFatFile::close()
000129e8 g     O .text	00000101 _ctype_
00008cc0  w    F .text	00000006 dac0_isr
00006f08  w    F .text	00000010 SdSpiCard::readSector(unsigned long, unsigned char*)
00012d08 g       .text	00000000 __init_array_start
0000aa14  w    F .text	00000002 .hidden __aeabi_idiv0
00008cc0  w    F .text	00000006 can1_tx_warn_isr
0000a5a4 g     F .text	0000002c .hidden __unorddf2
1fff76b4 g     O .bss	00000004 disk_count
000031e8 g     F .text	00000042 ExFatFormatter::writeUpcaseByte(unsigned char)
00002dfc g     F .text	000001b0 FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)
00002a22  w    F .text	00000068 SDClass::rename(char const*, char const*)
00008cc0  w    F .text	00000006 uart0_status_isr
00006588 g     F .text	00000046 FatVolume::chdir(char const*)
000004bc g     F .text	00000018 acq_start()
00008cc0  w    F .text	00000006 mcg_isr
00009b98 g     F .text	00000038 Stream::timedRead()
00000400 g     O .text	00000010 flashconfigbytes
0000b740 g     F .text	000000dc strlen
000055f6 g     F .text	0000002e FatFile::openCluster(FatFile*)
0000aab4 g     F .text	00000006 __locale_ctype_ptr_l
00002b06  w    F .text	00000036 SdBase<FsVolume>::begin(SdioConfig)
0000a530 g     F .text	00000010 .hidden __aeabi_cdcmpeq
0000a494 g     F .text	0000008a .hidden __gedf2
000057fe g     F .text	000000ac FatFile::seekSet(unsigned long)
00006b68 g     F .text	00000098 FatFile::parsePathName(char const*, FatName_t*, char const**)
000102c8 g     F .text	00000510 __gethex
1fff13e8 g     O .data	00000016 usb_string_product_name_default
1fff7f0c g     O .bss	00000008 AudioOutputI2SQuad::dma
0000ef08 g     F .text	00000018 vdprintf
00008cc0  w    F .text	00000006 dma_ch1_isr
00007b80 g     F .text	00000064 SdioCard::sectorCount()
00006e18 g     F .text	000000bc FsVolume::begin(BlockDeviceInterface*)
00001740  w    F .text	00000024 MySpiClass::receive(unsigned char*, unsigned int)
00009018 g     F .text	00000024 usb_tx_packet_count
0000596c g     F .text	00000098 FatFile::openNext(FatFile*, int)
1fff221c g     O .bss	0000001c diskSpace
00008d44  w    F .text	00000002 startup_middle_hook
00012600 g     O .text	00000060 vtable for SdioCard
00009fc8 g     F .text	0000003a .hidden __aeabi_f2d
00008cc0  w    F .text	00000006 dma_ch5_isr
000054bc g     F .text	00000004 FatFile::getName(char*, unsigned int)
00008cc0  w    F .text	00000006 can0_rx_warn_isr
000018ac  w    F .text	0000000c SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)
00008cc0  w    F .text	00000006 can0_tx_warn_isr
00008cc0  w    F .text	00000006 uart4_status_isr
00008510 g     F .text	00000074 SdioCard::readStart(unsigned long)
00000000  w      *UND*	00000000 _Jv_RegisterClasses
1fff7edc g     O .bss	00000008 AudioInputAnalog::dma
1fff8584 g     O .bss	00000002 AudioStream::cpu_cycles_total_max
00005300  w    F .text	0000001a FatFile::cacheDir(unsigned short)
00009d08 g     F .text	0000027a .hidden __subdf3
0000191c g     F .text	00000044 pullData(unsigned long*, unsigned long)
00012d08 g       .text	00000000 __preinit_array_start
00004128 g     F .text	000000a6 ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)
00000d6c  w    F .text	00000014 FsBaseFile::write(void const*, unsigned int)
1fff4eb4 g     O .bss	00002800 data_buffer
00010bd8 g     F .text	0000005a __lo0bits
00004242 g     F .text	0000002a ExFatPartition::chainSize(unsigned long)
000058aa g     F .text	000000c2 FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)
00005f48 g     F .text	000000ae FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
1fff0f60 g     O .data	00000004 stdPrint
0000158a  w    F .text	00000038 BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)
00009cdc g     F .text	0000000a __aeabi_atexit
00000000  w      *UND*	00000000 __register_frame_info
00008d18 g     F .text	0000000c rtc_get
000045ca g     F .text	00000086 ExFatFile::remove()
00008cc0  w    F .text	00000006 cmp2_isr
00009948 g     F .text	00000004 pendablesrvreq_isr
00002aaa  w    F .text	00000026 SDClass::totalSize()
0000080c  w    F .text	00000004 Print::availableForWrite()
1fff1844 g     O .data	0000016c __global_locale
00008cc0  w    F .text	00000006 wakeup_isr
000080f0 g     F .text	0000035c SdioCard::begin(SdioConfig)
000038da g     F .text	00000020 ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)
00008cc0  w    F .text	00000006 cmp3_isr
000099e6 g     F .text	00000076 Print::printNumber(unsigned long, unsigned char, unsigned char)
00006298 g     F .text	0000006a FatPartition::fatGet(unsigned long, unsigned long*)
0000aae0 g     F .text	00000010 free
00008cc0  w    F .text	00000006 tpm2_isr
00003730 g     F .text	0000004c ExFatFile::cmpName(DirName_t const*, ExName_t*)
00010a80 g     F .text	00000080 __multadd
00010a6c g     F .text	00000012 _Bfree
00000a3c  w    F .text	00000018 SDFile::size()
00005342 g     F .text	00000088 FatFile::getSFN(char*, unsigned int)
00008cc0  w    F .text	00000006 dma_ch0_isr
00000b64  w    F .text	00000024 SDFile::~SDFile()
1fff1402  w    O .data	00000016 usb_string_serial_number
00008cc0  w    F .text	00000006 enet_tx_isr
00008584 g     F .text	000000c4 SdioCard::readSector(unsigned long, unsigned char*)
00007910 g     F .text	0000001c SdioCard::readCSD(csd_t*)



Disassembly of section .text:

00000000 <_VectorsFlash>:
  return fsFmtTime(str, time);
}
//------------------------------------------------------------------------------
char* fsFmtTimeZone(char* str, int8_t tz) {
  char sign;
  if (tz & 0X80) {
       0:	... ............
    if (tz & 0X40) {
      sign = '-';
      10:	................
    } else {
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      str = fsFmtField(str, 15*(tz%4), 0);
      20:	................
      30:	........I...M...
      str = fsFmtField(str, tz/4, ':');
      40:	................
      *--str = sign;
      50:	................
    }
    *--str = 'C';
    *--str = 'T';
    *--str = 'U';
      60:	................
      70:	................
      80:	................
      90:	................
      a0:	.(...(..........
      b0:	................
      c0:	................
      d0:	................
      e0:	................
      f0:	................
     100:	................
     110:	....5...........
     120:	................
     130:	................
     140:	%...............
     150:	................
     160:	.........(......
     170:	................
     180:	................
     190:	................
     1a0:	................
     1b0:	................
     1c0:	................

000001d0 <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d0:	ldr	r3, [pc, #356]	; (338 <ResetHandler+0x168>)
     1d2:	movw	r2, #50464	; 0xc520
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
     1d6:	push	{r4, lr}
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d8:	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
     1da:	movw	r2, #55592	; 0xd928
     1de:	strh	r2, [r3, #0]
	__asm__ volatile ("nop");
     1e0:	nop
	__asm__ volatile ("nop");
     1e2:	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
     1e4:	bl	8cc8 <startup_early_hook>
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1e8:	ldr	r3, [pc, #336]	; (33c <ResetHandler+0x16c>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     1ea:	ldr	r1, [pc, #340]	; (340 <ResetHandler+0x170>)
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1ec:	mov.w	r2, #184549376	; 0xb000000
     1f0:	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
     1f2:	ldr	r2, [pc, #336]	; (344 <ResetHandler+0x174>)
     1f4:	str	r2, [r3, #8]
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
     1f6:	ldr	r2, [pc, #336]	; (348 <ResetHandler+0x178>)
     1f8:	str	r2, [r3, #12]
	SIM_SCGC4 = SIM_SCGC4_USBOTG | 0xF0000030;
	SIM_SCGC5 = 0x00003F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_ADC0 | SIM_SCGC6_TPM0 | SIM_SCGC6_TPM1 | SIM_SCGC6_TPM2 | SIM_SCGC6_FTFL;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SCB_CPACR = 0x00F00000;
     1fa:	ldr	r3, [pc, #336]	; (34c <ResetHandler+0x17c>)
     1fc:	mov.w	r2, #15728640	; 0xf00000
     200:	str	r2, [r3, #0]
#endif
#if defined(__MK66FX1M0__)
	LMEM_PCCCR = 0x85000003;
     202:	ldr	r3, [pc, #332]	; (350 <ResetHandler+0x180>)
     204:	ldr	r2, [pc, #332]	; (354 <ResetHandler+0x184>)
     206:	str	r2, [r3, #0]
		RTC_SR = 0;
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     208:	ldr	r3, [pc, #332]	; (358 <ResetHandler+0x188>)
     20a:	ldrb	r2, [r3, #0]
     20c:	lsls	r0, r2, #28
     20e:	ittt	mi
     210:	ldrbmi	r2, [r3, #0]
     212:	orrmi.w	r2, r2, #8
     216:	strbmi	r2, [r3, #0]

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     218:	ldr	r3, [pc, #320]	; (35c <ResetHandler+0x18c>)
     21a:	movs	r2, #170	; 0xaa
     21c:	strb	r2, [r3, #0]
     21e:	ldr	r2, [pc, #320]	; (360 <ResetHandler+0x190>)
     220:	ldr	r3, [pc, #320]	; (364 <ResetHandler+0x194>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     222:	cmp	r3, r1
     224:	bcs.n	230 <ResetHandler+0x60>
     226:	ldr.w	r0, [r2, #4]!
     22a:	str.w	r0, [r3], #4
     22e:	b.n	222 <ResetHandler+0x52>
     230:	ldr	r3, [pc, #308]	; (368 <ResetHandler+0x198>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     232:	ldr	r2, [pc, #312]	; (36c <ResetHandler+0x19c>)
     234:	movs	r1, #0
     236:	cmp	r3, r2
     238:	bcs.n	240 <ResetHandler+0x70>
     23a:	str.w	r1, [r3], #4
     23e:	b.n	236 <ResetHandler+0x66>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     240:	ldr	r2, [pc, #300]	; (370 <ResetHandler+0x1a0>)
     242:	ldr	r0, [pc, #304]	; (374 <ResetHandler+0x1a4>)
     244:	movs	r3, #0
     246:	ldr.w	r1, [r0, r3, lsl #2]
     24a:	str.w	r1, [r2, r3, lsl #2]
     24e:	adds	r3, #1
     250:	cmp	r3, #116	; 0x74
     252:	bne.n	246 <ResetHandler+0x76>
     254:	ldr	r3, [pc, #288]	; (378 <ResetHandler+0x1a8>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     256:	ldr	r2, [pc, #292]	; (37c <ResetHandler+0x1ac>)
     258:	movs	r1, #128	; 0x80
     25a:	strb.w	r1, [r3], #1
     25e:	cmp	r3, r2
     260:	bne.n	25a <ResetHandler+0x8a>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     262:	ldr	r3, [pc, #284]	; (380 <ResetHandler+0x1b0>)
     264:	ldr	r2, [pc, #264]	; (370 <ResetHandler+0x1a0>)
     266:	str	r2, [r3, #0]
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     268:	ldr	r3, [pc, #280]	; (384 <ResetHandler+0x1b4>)
     26a:	movs	r2, #138	; 0x8a
     26c:	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     26e:	sub.w	r3, r3, #4096	; 0x1000
     272:	movs	r2, #36	; 0x24
     274:	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     276:	movs	r2, #160	; 0xa0
     278:	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     27a:	ldrb	r2, [r3, #6]
     27c:	lsls	r1, r2, #30
     27e:	bpl.n	27a <ResetHandler+0xaa>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     280:	ldrb	r2, [r3, #6]
     282:	lsls	r2, r2, #27
     284:	bmi.n	280 <ResetHandler+0xb0>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     286:	ldr	r2, [pc, #256]	; (388 <ResetHandler+0x1b8>)
     288:	ldrb	r3, [r2, #6]
     28a:	and.w	r3, r3, #12
     28e:	cmp	r3, #8
     290:	ldr	r3, [pc, #244]	; (388 <ResetHandler+0x1b8>)
     292:	bne.n	288 <ResetHandler+0xb8>
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(2);
    #elif F_CPU == 120000000
	MCG_C5 = MCG_C5_PRDIV0(1);
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(14);
    #elif F_CPU == 96000000 || F_CPU == 48000000 || F_CPU == 24000000
	MCG_C5 = MCG_C5_PRDIV0(1);
     294:	movs	r2, #1
     296:	strb	r2, [r3, #4]
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(8);
     298:	movs	r2, #72	; 0x48
     29a:	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     29c:	ldrb	r2, [r3, #6]
     29e:	lsls	r4, r2, #26
     2a0:	bpl.n	29c <ResetHandler+0xcc>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     2a2:	ldr	r1, [pc, #228]	; (388 <ResetHandler+0x1b8>)
     2a4:	ldrb	r2, [r1, #6]
     2a6:	ldr	r3, [pc, #224]	; (388 <ResetHandler+0x1b8>)
     2a8:	lsls	r0, r2, #25
     2aa:	bpl.n	2a4 <ResetHandler+0xd4>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC;
#elif F_CPU == 96000000
	// config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash, USB = 96 / 2
	#if F_BUS == 48000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(3);
     2ac:	ldr	r2, [pc, #220]	; (38c <ResetHandler+0x1bc>)
     2ae:	ldr	r1, [pc, #224]	; (390 <ResetHandler+0x1c0>)
     2b0:	str	r1, [r2, #0]
	#elif F_BUS == 96000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(0) | SIM_CLKDIV1_OUTDIV4(3);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1);
     2b2:	movs	r1, #2
     2b4:	str	r1, [r2, #4]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     2b6:	movs	r2, #32
     2b8:	strb	r2, [r3, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     2ba:	ldrb	r2, [r3, #6]
     2bc:	and.w	r2, r2, #12
     2c0:	cmp	r2, #12
     2c2:	bne.n	2ba <ResetHandler+0xea>
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#else
	// USB uses PLL clock
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     2c4:	ldr	r3, [pc, #204]	; (394 <ResetHandler+0x1c4>)
     2c6:	ldr	r2, [pc, #208]	; (398 <ResetHandler+0x1c8>)
     2c8:	str	r2, [r3, #0]
#endif

#if defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started.  For Teensy 3.6
	// we don't do this early.  See comment above about slow rising power.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     2ca:	ldr	r2, [pc, #208]	; (39c <ResetHandler+0x1cc>)
     2cc:	ldr	r4, [pc, #208]	; (3a0 <ResetHandler+0x1d0>)
     2ce:	ldr	r3, [r2, #0]
     2d0:	ands.w	r3, r3, #256	; 0x100
		RTC_SR = 0;
     2d4:	ittt	eq
     2d6:	streq	r3, [r4, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     2d8:	moveq.w	r3, #5376	; 0x1500
     2dc:	streq	r3, [r2, #0]
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2de:	ldr	r3, [pc, #196]	; (3a4 <ResetHandler+0x1d4>)
     2e0:	ldr	r2, [pc, #196]	; (3a8 <ResetHandler+0x1d8>)
     2e2:	str	r2, [r3, #0]
	SYST_CVR = 0;
     2e4:	movs	r2, #0
     2e6:	str	r2, [r3, #4]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2e8:	movs	r2, #7
     2ea:	str.w	r2, [r3, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2ee:	ldr	r2, [pc, #188]	; (3ac <ResetHandler+0x1dc>)
     2f0:	str.w	r2, [r3, #3340]	; 0xd0c

	//init_pins();
	__enable_irq();
     2f4:	cpsie	i

	_init_Teensyduino_internal_();
     2f6:	bl	8e14 <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     2fa:	ldr	r3, [r4, #0]
     2fc:	lsls	r2, r3, #31
     2fe:	bpl.n	30c <ResetHandler+0x13c>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     300:	ldr	r0, [pc, #172]	; (3b0 <ResetHandler+0x1e0>)
     302:	bl	8d24 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     306:	ldr	r3, [pc, #172]	; (3b4 <ResetHandler+0x1e4>)
     308:	ldr	r2, [pc, #172]	; (3b8 <ResetHandler+0x1e8>)
     30a:	str	r2, [r3, #0]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     30c:	ldr	r3, [pc, #172]	; (3bc <ResetHandler+0x1ec>)
     30e:	ldrb	r3, [r3, #0]
     310:	lsls	r3, r3, #25
     312:	bpl.n	328 <ResetHandler+0x158>
     314:	ldr	r4, [pc, #156]	; (3b4 <ResetHandler+0x1e4>)
     316:	ldr	r3, [pc, #160]	; (3b8 <ResetHandler+0x1e8>)
     318:	ldr	r2, [r4, #0]
     31a:	cmp	r2, r3
     31c:	bne.n	328 <ResetHandler+0x158>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     31e:	ldr	r0, [pc, #144]	; (3b0 <ResetHandler+0x1e0>)
     320:	bl	8d24 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     324:	movs	r3, #0
     326:	str	r3, [r4, #0]
	}
#endif

	startup_late_hook();
     328:	bl	8cd4 <startup_late_hook>
	__libc_init_array();
     32c:	bl	aa30 <__libc_init_array>

	main();
     330:	bl	9b12 <main>
     334:	b.n	334 <ResetHandler+0x164>
     336:	nop
     338:	.word	0x4005200e
     33c:	.word	0x40048030
     340:	.word	0x1fff1dc0
     344:	.word	0x00043f82
     348:	.word	0x2b000001
     34c:	.word	0xe000ed88
     350:	.word	0xe0082000
     354:	.word	0x85000003
     358:	.word	0x4007d002
     35c:	.word	0x4007e000
     360:	.word	0x00012d64
     364:	.word	0x1fff0f30
     368:	.word	0x1fff1dc0
     36c:	.word	0x1fff85f0
     370:	.word	0x1fff0a00
     374:	.word	0x00000000
     378:	.word	0xe000e400
     37c:	.word	0xe000e464
     380:	.word	0xe000ed08
     384:	.word	0x40065000
     388:	.word	0x40064000
     38c:	.word	0x40048044
     390:	.word	0x01030000
     394:	.word	0x40048004
     398:	.word	0x000510c0
     39c:	.word	0x4003d010
     3a0:	.word	0x4003d014
     3a4:	.word	0xe000e014
     3a8:	.word	0x000176ff
     3ac:	.word	0x20200000
     3b0:	.word	0x61f995c6
     3b4:	.word	0x4003e01c
     3b8:	.word	0x5a94c3a5
     3bc:	.word	0x4007f000
     3c0:	.word	0xffffffff
     3c4:	.word	0xffffffff
     3c8:	.word	0xffffffff
     3cc:	.word	0xffffffff
     3d0:	.word	0xffffffff
     3d4:	.word	0xffffffff
     3d8:	.word	0xffffffff
     3dc:	.word	0xffffffff
     3e0:	.word	0xffffffff
     3e4:	.word	0xffffffff
     3e8:	.word	0xffffffff
     3ec:	.word	0xffffffff
     3f0:	.word	0xffffffff
     3f4:	.word	0xffffffff
     3f8:	.word	0xffffffff
     3fc:	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	................

00000410 <__do_global_dtors_aux>:
     410:	push	{r4, lr}
     412:	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
     414:	ldrb	r3, [r4, #0]
     416:	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
     41a:	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
     41e:	nop.w
     422:	movs	r3, #1
     424:	strb	r3, [r4, #0]
     426:	pop	{r4, pc}
     428:	.word	0x1fff1dc0
     42c:	.word	0x00000000
     430:	.word	0x00012d60

00000434 <frame_dummy>:
     434:	ldr	r3, [pc, #32]	; (458 <frame_dummy+0x24>)
     436:	push	{r4, lr}
     438:	cbz	r3, 442 <frame_dummy+0xe>
     43a:	ldr	r1, [pc, #32]	; (45c <frame_dummy+0x28>)
     43c:	ldr	r0, [pc, #32]	; (460 <frame_dummy+0x2c>)
     43e:	nop.w
     442:	ldr	r0, [pc, #32]	; (464 <frame_dummy+0x30>)
     444:	ldr	r3, [r0, #0]
     446:	cbnz	r3, 44a <frame_dummy+0x16>
     448:	pop	{r4, pc}
     44a:	ldr	r3, [pc, #28]	; (468 <frame_dummy+0x34>)
     44c:	cmp	r3, #0
     44e:	beq.n	448 <frame_dummy+0x14>
     450:	ldmia.w	sp!, {r4, lr}
     454:	bx	r3
     456:	nop
     458:	.word	0x00000000
     45c:	.word	0x1fff1dc4
     460:	.word	0x00012d60
     464:	.word	0x1fff1dc0
     468:	.word	0x00000000

0000046c <acq_stopClocks()>:
    const int32_t fsamp0=(((F_PLL*MCLK_MULT)/MCLK_DIV)/512);

    
    void acq_stopClocks(void)
    {
        SIM_SCGC6 &= ~SIM_SCGC6_DMAMUX;
     46c:	ldr	r3, [pc, #28]	; (48c <acq_stopClocks()+0x20>)
        SIM_SCGC7 &= ~SIM_SCGC7_DMA;
     46e:	ldr	r1, [pc, #32]	; (490 <acq_stopClocks()+0x24>)
    const int32_t fsamp0=(((F_PLL*MCLK_MULT)/MCLK_DIV)/512);

    
    void acq_stopClocks(void)
    {
        SIM_SCGC6 &= ~SIM_SCGC6_DMAMUX;
     470:	ldr	r2, [r3, #0]
     472:	bic.w	r2, r2, #2
     476:	str	r2, [r3, #0]
        SIM_SCGC7 &= ~SIM_SCGC7_DMA;
     478:	ldr	r2, [r1, #0]
     47a:	bic.w	r2, r2, #2
     47e:	str	r2, [r1, #0]
        SIM_SCGC6 &= ~SIM_SCGC6_I2S;
     480:	ldr	r2, [r3, #0]
     482:	bic.w	r2, r2, #32768	; 0x8000
     486:	str	r2, [r3, #0]
     488:	bx	lr
     48a:	nop
     48c:	.word	0x4004803c
     490:	.word	0x40048040

00000494 <acq_startClocks()>:
    }

    void acq_startClocks(void)
    {
    SIM_SCGC6 |= SIM_SCGC6_I2S;
     494:	ldr	r3, [pc, #28]	; (4b4 <acq_startClocks()+0x20>)
    SIM_SCGC7 |= SIM_SCGC7_DMA;
     496:	ldr	r1, [pc, #32]	; (4b8 <acq_startClocks()+0x24>)
        SIM_SCGC6 &= ~SIM_SCGC6_I2S;
    }

    void acq_startClocks(void)
    {
    SIM_SCGC6 |= SIM_SCGC6_I2S;
     498:	ldr	r2, [r3, #0]
     49a:	orr.w	r2, r2, #32768	; 0x8000
     49e:	str	r2, [r3, #0]
    SIM_SCGC7 |= SIM_SCGC7_DMA;
     4a0:	ldr	r2, [r1, #0]
     4a2:	orr.w	r2, r2, #2
     4a6:	str	r2, [r1, #0]
    SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
     4a8:	ldr	r2, [r3, #0]
     4aa:	orr.w	r2, r2, #2
     4ae:	str	r2, [r3, #0]
     4b0:	bx	lr
     4b2:	nop
     4b4:	.word	0x4004803c
     4b8:	.word	0x40048040

000004bc <acq_start()>:
    }

    void acq_start(void)
    {
     4bc:	push	{r3, lr}
        acq_startClocks();
     4be:	bl	494 <acq_startClocks()>
        //DMA_SERQ = dma.channel;
        I2S0_RCSR |= (I2S_RCSR_RE | I2S_RCSR_BCE);
     4c2:	ldr	r2, [pc, #12]	; (4d0 <acq_start()+0x14>)
     4c4:	ldr	r3, [r2, #0]
     4c6:	orr.w	r3, r3, #2415919104	; 0x90000000
     4ca:	str	r3, [r2, #0]
     4cc:	pop	{r3, pc}
     4ce:	nop
     4d0:	.word	0x4002f080

000004d4 <acq_stop()>:
    }

    void acq_stop(void)
    {
        I2S0_RCSR &= ~(I2S_RCSR_RE | I2S_RCSR_BCE);
     4d4:	ldr	r2, [pc, #12]	; (4e4 <acq_stop()+0x10>)
     4d6:	ldr	r3, [r2, #0]
     4d8:	bic.w	r3, r3, #2415919104	; 0x90000000
     4dc:	str	r3, [r2, #0]
        acq_stopClocks();
     4de:	b.w	46c <acq_stopClocks()>
     4e2:	nop
     4e4:	.word	0x4002f080

000004e8 <acq_init(int)>:
    }


    void acq_init(int fsamp)
    {
        Serial.printf("%d %d\n",fsamp,fsamp0);
     4e8:	mov	r2, r0
     4ea:	ldr	r3, [pc, #244]	; (5e0 <acq_init(int)+0xf8>)
     4ec:	ldr	r1, [pc, #244]	; (5e4 <acq_init(int)+0xfc>)
     4ee:	ldr	r0, [pc, #248]	; (5e8 <acq_init(int)+0x100>)
        acq_stopClocks();
    }


    void acq_init(int fsamp)
    {
     4f0:	push	{r4, lr}
        Serial.printf("%d %d\n",fsamp,fsamp0);
     4f2:	bl	99cc <Print::printf(char const*, ...)>
//        SIM_SCGC6 |= SIM_SCGC6_I2S;
        acq_startClocks();
     4f6:	bl	494 <acq_startClocks()>

        #if I2S_CONFIG==0
            CORE_PIN39_CONFIG = PORT_PCR_MUX(6);  //pin39, PTA17, I2S0_MCLK
     4fa:	ldr	r3, [pc, #240]	; (5ec <acq_init(int)+0x104>)
     4fc:	mov.w	r2, #1536	; 0x600
     500:	str	r2, [r3, #0]
            CORE_PIN11_CONFIG = PORT_PCR_MUX(4);  //pin11, PTC6,  I2S0_RX_BCLK
     502:	ldr	r2, [pc, #236]	; (5f0 <acq_init(int)+0x108>)
     504:	mov.w	r3, #1024	; 0x400
     508:	str	r3, [r2, #0]
            CORE_PIN12_CONFIG = PORT_PCR_MUX(4);  //pin12, PTC7,  I2S0_RX_FS
     50a:	str	r3, [r2, #4]
            CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  //pin13, PTC5,  I2S0_RXD0
     50c:	str.w	r3, [r2, #-4]
            CORE_PIN36_CONFIG = PORT_PCR_MUX(4);  //pin36, PTC9,   I2S0_RX_BCLK
            CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
            CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
        #endif

        I2S0_RCSR=0;
     510:	sub.w	r2, r2, #114176	; 0x1be00
     514:	sub.w	r2, r2, #408	; 0x198
     518:	movs	r3, #0
     51a:	str	r3, [r2, #0]

        // enable MCLK output
        I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
     51c:	ldr	r3, [pc, #212]	; (5f4 <acq_init(int)+0x10c>)
     51e:	movs	r1, #1
     520:	str	r1, [r3, #0]
        while(I2S0_MCR & I2S_MCR_DUF);
     522:	ldr	r1, [pc, #212]	; (5f8 <acq_init(int)+0x110>)
     524:	ldr	r3, [r1, #0]
     526:	cmp	r3, #0
     528:	blt.n	524 <acq_init(int)+0x3c>
        I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
     52a:	ldr	r3, [pc, #204]	; (5f8 <acq_init(int)+0x110>)
        DMA_TCD0_SLAST = 0;
        
        DMA_TCD0_ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
        DMA_TCD0_NBYTES_MLNO = 4;
            
        DMA_TCD0_DADDR = tdm_rx_buffer;
     52c:	ldr	r4, [pc, #204]	; (5fc <acq_init(int)+0x114>)
        I2S0_RCSR=0;

        // enable MCLK output
        I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
        while(I2S0_MCR & I2S_MCR_DUF);
        I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
     52e:	mov.w	r1, #1124073472	; 0x43000000
     532:	str	r1, [r3, #0]
        
        I2S0_RMR=0; // enable receiver mask
     534:	ldr	r1, [pc, #200]	; (600 <acq_init(int)+0x118>)
     536:	movs	r3, #0
        I2S0_RCR1 = I2S_RCR1_RFW(3); 
     538:	movs	r0, #3
        // enable MCLK output
        I2S0_MDR = I2S_MDR_FRACT((MCLK_MULT-1)) | I2S_MDR_DIVIDE((MCLK_DIV-1));
        while(I2S0_MCR & I2S_MCR_DUF);
        I2S0_MCR = I2S_MCR_MICS(MCLK_SRC) | I2S_MCR_MOE;
        
        I2S0_RMR=0; // enable receiver mask
     53a:	str	r3, [r1, #0]
        I2S0_RCR1 = I2S_RCR1_RFW(3); 
     53c:	str.w	r0, [r1, #-92]

        I2S0_RCR2 = I2S_RCR2_SYNC(0) 
                    | I2S_RCR2_BCP ;
     540:	mov.w	r0, #33554432	; 0x2000000
     544:	str.w	r0, [r1, #-88]
                    
        I2S0_RCR3 = I2S_RCR3_RCE; // single rx channel
     548:	mov.w	r0, #65536	; 0x10000
     54c:	str.w	r0, [r1, #-84]

        I2S0_RCR4 = I2S_RCR4_FRSZ((NCHAN_I2S-1)) // 8 words (TDM - mode)
                    | I2S_RCR4_FSE  // frame sync early
                    | I2S_RCR4_MF;
     550:	adds	r0, #24
     552:	str.w	r0, [r1, #-80]
        #if ADC_STEREO
            I2S0_RCR4 |=  I2S_RCR4_SYWD(31);
     556:	ldr.w	r0, [r1, #-80]
     55a:	orr.w	r0, r0, #7936	; 0x1f00
     55e:	str.w	r0, [r1, #-80]
        #endif
        
        I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
     562:	ldr	r0, [pc, #160]	; (604 <acq_init(int)+0x11c>)
     564:	str.w	r0, [r1, #-76]
        // DMA 
//        SIM_SCGC7 |= SIM_SCGC7_DMA;
//        SIM_SCGC6 |= SIM_SCGC6_DMAMUX;

        DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG;
     568:	ldr	r1, [pc, #156]	; (608 <acq_init(int)+0x120>)
     56a:	movs	r0, #130	; 0x82
     56c:	str	r0, [r1, #0]
        DMA_CR |= DMA_CR_GRP1PRI;
     56e:	ldr	r0, [r1, #0]
     570:	orr.w	r0, r0, #1024	; 0x400
     574:	str	r0, [r1, #0]
        
        DMA_TCD0_SADDR = &I2S0_RDR0;
     576:	add.w	r1, r1, #4096	; 0x1000
     57a:	ldr	r0, [pc, #144]	; (60c <acq_init(int)+0x124>)
     57c:	str	r0, [r1, #0]
        DMA_TCD0_SOFF  = 0;
        DMA_TCD0_SLAST = 0;
        
        DMA_TCD0_ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
     57e:	movw	r0, #514	; 0x202

        DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG;
        DMA_CR |= DMA_CR_GRP1PRI;
        
        DMA_TCD0_SADDR = &I2S0_RDR0;
        DMA_TCD0_SOFF  = 0;
     582:	strh	r3, [r1, #4]
        DMA_TCD0_SLAST = 0;
     584:	str	r3, [r1, #12]
        
        DMA_TCD0_ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
     586:	strh	r0, [r1, #6]
        DMA_TCD0_NBYTES_MLNO = 4;
     588:	ldr	r0, [pc, #132]	; (610 <acq_init(int)+0x128>)
     58a:	movs	r1, #4
     58c:	str	r1, [r0, #0]
            
        DMA_TCD0_DADDR = tdm_rx_buffer;
     58e:	str	r4, [r0, #8]
        DMA_TCD0_DOFF = 4;
     590:	strh	r1, [r0, #12]
        DMA_TCD0_DLASTSGA = -sizeof(tdm_rx_buffer); // Bytes
     592:	ldr	r1, [pc, #128]	; (614 <acq_init(int)+0x12c>)
     594:	ldr	r0, [pc, #128]	; (618 <acq_init(int)+0x130>)
     596:	str	r0, [r1, #0]
            
        DMA_TCD0_CITER_ELINKNO = DMA_TCD0_BITER_ELINKNO = sizeof(tdm_rx_buffer)/4;
     598:	ldr	r0, [pc, #128]	; (61c <acq_init(int)+0x134>)
     59a:	mov.w	r1, #512	; 0x200
     59e:	strh	r1, [r0, #0]
     5a0:	strh.w	r1, [r0, #-8]
            
        DMA_TCD0_CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
     5a4:	ldr	r1, [pc, #120]	; (620 <acq_init(int)+0x138>)
     5a6:	movs	r0, #6
     5a8:	strh	r0, [r1, #0]
            
        DMAMUX0_CHCFG0 = DMAMUX_DISABLE;
     5aa:	add.w	r1, r1, #97792	; 0x17e00
     5ae:	add.w	r1, r1, #484	; 0x1e4
        DMAMUX0_CHCFG0 = DMAMUX_SOURCE_I2S0_RX | DMAMUX_ENABLE;
     5b2:	movs	r0, #140	; 0x8c
            
        DMA_TCD0_CITER_ELINKNO = DMA_TCD0_BITER_ELINKNO = sizeof(tdm_rx_buffer)/4;
            
        DMA_TCD0_CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
            
        DMAMUX0_CHCFG0 = DMAMUX_DISABLE;
     5b4:	strb	r3, [r1, #0]
        DMAMUX0_CHCFG0 = DMAMUX_SOURCE_I2S0_RX | DMAMUX_ENABLE;
     5b6:	strb	r0, [r1, #0]

        // partial start I2S
        I2S0_RCSR |= I2S_RCSR_FR | I2S_RCSR_FRDE;
     5b8:	ldr	r1, [r2, #0]
     5ba:	orr.w	r1, r1, #33554432	; 0x2000000
     5be:	orr.w	r1, r1, #1
     5c2:	str	r1, [r2, #0]

        //start DMA
        _VectorsRam[IRQ_DMA_CH0 + 16] = acq_isr;
     5c4:	ldr	r2, [pc, #92]	; (624 <acq_init(int)+0x13c>)
     5c6:	ldr	r1, [pc, #96]	; (628 <acq_init(int)+0x140>)
     5c8:	str	r1, [r2, #64]	; 0x40
        NVIC_SET_PRIORITY(IRQ_DMA_CH0, I2S_DMA_PRIO);
     5ca:	ldr	r2, [pc, #96]	; (62c <acq_init(int)+0x144>)
     5cc:	movs	r1, #80	; 0x50
     5ce:	strb	r1, [r2, #0]
        NVIC_ENABLE_IRQ(IRQ_DMA_CH0); 
     5d0:	sub.w	r2, r2, #768	; 0x300
     5d4:	movs	r1, #1
     5d6:	str	r1, [r2, #0]
        DMA_SERQ = 0;
     5d8:	ldr	r2, [pc, #84]	; (630 <acq_init(int)+0x148>)
     5da:	strb	r3, [r2, #0]
     5dc:	pop	{r4, pc}
     5de:	nop
     5e0:	.word	0x00016e36
     5e4:	.word	0x00011c64
     5e8:	.word	0x1fff1368
     5ec:	.word	0x40049044
     5f0:	.word	0x4004b018
     5f4:	.word	0x4002f104
     5f8:	.word	0x4002f100
     5fc:	.word	0x1fff0200
     600:	.word	0x4002f0e0
     604:	.word	0x1f1f1f00
     608:	.word	0x40008000
     60c:	.word	0x4002f0a0
     610:	.word	0x40009008
     614:	.word	0x40009018
     618:	.word	0xfffff800
     61c:	.word	0x4000901e
     620:	.word	0x4000901c
     624:	.word	0x1fff0a00
     628:	.word	0x00000669
     62c:	.word	0xe000e400
     630:	.word	0x4000801b

00000634 <extract(void*, void*)>:
                dout[1+ii*NCHAN_ACQ] = din[1+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
            }
        }
    #else // have TMA 8 channels
        void extract(void *out, void *inp)
        {   int32_t *dout = (int32_t *) out;
     634:	add.w	r2, r1, #1024	; 0x400
            int32_t *din  = (int32_t *) inp;
            for(int ii=0; ii < NSAMP; ii++)
            {   dout[0+ii*NCHAN_ACQ] = din[0+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     638:	ldr	r3, [r1, #0]
     63a:	asrs	r3, r3, #8
     63c:	str	r3, [r0, #0]
                dout[1+ii*NCHAN_ACQ] = din[2+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     63e:	ldr	r3, [r1, #8]
     640:	asrs	r3, r3, #8
     642:	str	r3, [r0, #4]
                dout[2+ii*NCHAN_ACQ] = din[4+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     644:	ldr	r3, [r1, #16]
     646:	asrs	r3, r3, #8
     648:	str	r3, [r0, #8]
                dout[3+ii*NCHAN_ACQ] = din[1+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     64a:	ldr	r3, [r1, #4]
     64c:	asrs	r3, r3, #8
     64e:	str	r3, [r0, #12]
                dout[4+ii*NCHAN_ACQ] = din[3+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     650:	ldr	r3, [r1, #12]
     652:	asrs	r3, r3, #8
     654:	str	r3, [r0, #16]
                dout[5+ii*NCHAN_ACQ] = din[5+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     656:	ldr	r3, [r1, #20]
     658:	adds	r1, #8
     65a:	asrs	r3, r3, #8
        }
    #else // have TMA 8 channels
        void extract(void *out, void *inp)
        {   int32_t *dout = (int32_t *) out;
            int32_t *din  = (int32_t *) inp;
            for(int ii=0; ii < NSAMP; ii++)
     65c:	cmp	r1, r2
            {   dout[0+ii*NCHAN_ACQ] = din[0+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
                dout[1+ii*NCHAN_ACQ] = din[2+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
                dout[2+ii*NCHAN_ACQ] = din[4+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
                dout[3+ii*NCHAN_ACQ] = din[1+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
                dout[4+ii*NCHAN_ACQ] = din[3+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
                dout[5+ii*NCHAN_ACQ] = din[5+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     65e:	str	r3, [r0, #20]
     660:	add.w	r0, r0, #8
        }
    #else // have TMA 8 channels
        void extract(void *out, void *inp)
        {   int32_t *dout = (int32_t *) out;
            int32_t *din  = (int32_t *) inp;
            for(int ii=0; ii < NSAMP; ii++)
     664:	bne.n	638 <extract(void*, void*)+0x4>
                dout[2+ii*NCHAN_ACQ] = din[4+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
                dout[3+ii*NCHAN_ACQ] = din[1+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
                dout[4+ii*NCHAN_ACQ] = din[3+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
                dout[5+ii*NCHAN_ACQ] = din[5+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
            }
        }
     666:	bx	lr

00000668 <acq_isr()>:
    #endif

    void acq_isr(void)
    {
     668:	push	{r3, lr}
        uint32_t daddr;
        uint32_t *src;

        //dma.clearInterrupt();
        #if defined(__MK66FX1M0__)
            DMA_CINT = 0;
     66a:	ldr	r3, [pc, #56]	; (6a4 <acq_isr()+0x3c>)

        #if IMXRT_CACHE_ENABLED >=1
            arm_dcache_delete((void*)src, sizeof(tdm_rx_buffer) / 2);
        #endif

        extract((void *) acq_rx_buffer, (void *) src);
     66c:	ldr	r0, [pc, #56]	; (6a8 <acq_isr()+0x40>)
        uint32_t daddr;
        uint32_t *src;

        //dma.clearInterrupt();
        #if defined(__MK66FX1M0__)
            DMA_CINT = 0;
     66e:	movs	r2, #0
     670:	strb	r2, [r3, #0]
            daddr = (uint32_t) DMA_TCD0_DADDR;
     672:	ldr.w	r1, [r3, #4081]	; 0xff1
            daddr = (uint32_t) dma.destinationAddress();
            asm volatile("dsb");
        #endif


        if (daddr < ((uint32_t)tdm_rx_buffer + sizeof(tdm_rx_buffer) / 2)) {
     676:	ldr	r3, [pc, #52]	; (6ac <acq_isr()+0x44>)
            // need to remove data from the second half
            src = &tdm_rx_buffer[NBUF_I2S];
        } else {
            // DMA is receiving to the second half of the buffer
            // need to remove data from the first half
            src = &tdm_rx_buffer[0];
     678:	sub.w	r2, r3, #1024	; 0x400

        #if IMXRT_CACHE_ENABLED >=1
            arm_dcache_delete((void*)src, sizeof(tdm_rx_buffer) / 2);
        #endif

        extract((void *) acq_rx_buffer, (void *) src);
     67c:	cmp	r1, r3
     67e:	ite	cc
     680:	movcc	r1, r3
     682:	movcs	r1, r2
     684:	bl	634 <extract(void*, void*)>

        if(!pushData(acq_rx_buffer)) acq_miss++;
     688:	ldr	r0, [pc, #28]	; (6a8 <acq_isr()+0x40>)
     68a:	bl	18e8 <pushData(unsigned long*)>
     68e:	cbnz	r0, 698 <acq_isr()+0x30>
     690:	ldr	r2, [pc, #28]	; (6b0 <acq_isr()+0x48>)
     692:	ldr	r3, [r2, #0]
     694:	adds	r3, #1
     696:	str	r3, [r2, #0]
        acq_count++;
     698:	ldr	r2, [pc, #24]	; (6b4 <acq_isr()+0x4c>)
     69a:	ldr	r3, [r2, #0]
     69c:	adds	r3, #1
     69e:	str	r3, [r2, #0]
     6a0:	pop	{r3, pc}
     6a2:	nop
     6a4:	.word	0x4000801f
     6a8:	.word	0x1fff1de4
     6ac:	.word	0x1fff0600
     6b0:	.word	0x1fff1de0
     6b4:	.word	0x1fff1ddc

000006b8 <Print::println(char const*)>:
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     6b8:	push	{r3, r4, r5, lr}
     6ba:	mov	r4, r0
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     6bc:	mov	r0, r1
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     6be:	mov	r5, r1
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     6c0:	bl	b740 <strlen>
     6c4:	ldr	r3, [r4, #0]
     6c6:	mov	r2, r0
     6c8:	mov	r1, r5
     6ca:	ldr	r3, [r3, #4]
     6cc:	mov	r0, r4
     6ce:	blx	r3
     6d0:	mov	r5, r0
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     6d2:	mov	r0, r4
     6d4:	bl	99ac <Print::println()>
     6d8:	add	r0, r5
     6da:	pop	{r3, r4, r5, pc}

000006dc <checkToCloseFile(short, unsigned long)>:

uint32_t t_start;

/* check if we should close file */
int16_t checkToCloseFile(int16_t status, uint32_t t_acq)
{ if((status == OPENED) || (status == RUNNING))
     6dc:	push	{r3, r4, r5, lr}
     6de:	subs	r3, r0, #1
     6e0:	uxth	r3, r3
     6e2:	cmp	r3, #1
     6e4:	mov	r5, r0
     6e6:	mov	r4, r1
     6e8:	bhi.n	702 <checkToCloseFile(short, unsigned long)+0x26>
  {
    //
    static uint32_t to =0;
    uint32_t tx=rtc_get();
     6ea:	bl	8d18 <rtc_get>
    tx %= t_acq;
    if(tx<to) status = DOCLOSE; // time wrapped, file must be closed
     6ee:	ldr	r3, [pc, #24]	; (708 <checkToCloseFile(short, unsigned long)+0x2c>)
{ if((status == OPENED) || (status == RUNNING))
  {
    //
    static uint32_t to =0;
    uint32_t tx=rtc_get();
    tx %= t_acq;
     6f0:	udiv	r1, r0, r4
    if(tx<to) status = DOCLOSE; // time wrapped, file must be closed
     6f4:	ldr	r2, [r3, #0]
{ if((status == OPENED) || (status == RUNNING))
  {
    //
    static uint32_t to =0;
    uint32_t tx=rtc_get();
    tx %= t_acq;
     6f6:	mls	r0, r1, r4, r0
    if(tx<to) status = DOCLOSE; // time wrapped, file must be closed
     6fa:	cmp	r0, r2
     6fc:	it	cc
     6fe:	movcc	r5, #3
    to=tx;
     700:	str	r0, [r3, #0]
  } 
  return status;
}
     702:	mov	r0, r5
     704:	pop	{r3, r4, r5, pc}
     706:	nop
     708:	.word	0x1fff21e8

0000070c <setup>:

void setup()
{
     70c:	push	{r3, r4, r5, lr}
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     70e:	ldr	r0, [pc, #68]	; (754 <setup+0x48>)
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     710:	ldr	r4, [pc, #68]	; (758 <setup+0x4c>)
     712:	ldr	r5, [pc, #72]	; (75c <setup+0x50>)
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     714:	ldr	r1, [pc, #72]	; (760 <setup+0x54>)
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     716:	ldrb	r3, [r4, #0]
     718:	cmp	r3, #0
     71a:	beq.n	716 <setup+0xa>
     71c:	ldrb	r3, [r5, #0]
     71e:	lsls	r3, r3, #31
     720:	bpl.n	716 <setup+0xa>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     722:	ldr	r3, [r0, #0]
     724:	ldr	r2, [r1, #0]
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     726:	subs	r3, r3, r2
     728:	cmp	r3, #14
     72a:	bls.n	716 <setup+0xa>
  while(!Serial) continue;

  Serial.println("basic Sound Recorder Version: " __DATE__  " " __TIME__ );
     72c:	ldr	r1, [pc, #52]	; (764 <setup+0x58>)
     72e:	ldr	r0, [pc, #56]	; (768 <setup+0x5c>)
     730:	bl	6b8 <Print::println(char const*)>

  storage_configure();
     734:	bl	1998 <storage_configure()>
  
  adc_init();
     738:	bl	21c0 <adc_init()>
  acq_init(FSAMP);
     73c:	movw	r0, #48000	; 0xbb80
     740:	bl	4e8 <acq_init(int)>

  acq_start(); 
     744:	bl	4bc <acq_start()>

  Serial.println("End of Setup");
     748:	ldr	r1, [pc, #32]	; (76c <setup+0x60>)
     74a:	ldr	r0, [pc, #28]	; (768 <setup+0x5c>)
     74c:	bl	6b8 <Print::println(char const*)>
     750:	pop	{r3, r4, r5, pc}
     752:	nop
     754:	.word	0x1fff8484
     758:	.word	0x1fff8567
     75c:	.word	0x1fff8480
     760:	.word	0x1fff85e0
     764:	.word	0x00011c6b
     768:	.word	0x1fff1368
     76c:	.word	0x00011c9e

00000770 <loop>:
}

void loop()
{ static int16_t status=START_MODE; 
     770:	push	{r0, r1, r4, r5, r6, lr}

  if(status==MUST_REBOOT) status=checkReboot(); // hapens only if microSD card write fails: reboot if space on disk
     772:	ldr	r4, [pc, #132]	; (7f8 <loop+0x88>)
     774:	ldrsh.w	r3, [r4]
     778:	adds	r3, #2
     77a:	bne.n	782 <loop+0x12>
     77c:	bl	1cd0 <checkReboot()>
     780:	strh	r0, [r4, #0]

  // normal operation
  int16_t ch=menu();  // check if we have serial line command (0: no input; 1: start; -1: stop)
     782:	bl	1190 <menu()>

  if(ch>0 && status==STOPPED)  // was stopped, should run now 
     786:	cmp	r0, #0
     788:	ble.n	79c <loop+0x2c>
     78a:	ldrsh.w	r3, [r4]
     78e:	adds	r3, #1
     790:	bne.n	7b0 <loop+0x40>
  { 
    acq_start(); adcStatus();
     792:	bl	4bc <acq_start()>
     796:	bl	21c2 <adcStatus()>
     79a:	b.n	7b0 <loop+0x40>
  }  
  
  if(ch<0 && status>=CLOSED)  // was running, should stop now
     79c:	beq.n	7b0 <loop+0x40>
     79e:	ldrsh.w	r3, [r4]
     7a2:	cmp	r3, #0
     7a4:	blt.n	7f2 <loop+0x82>
  { status=MUSTSTOP;  acq_stop();  
     7a6:	ldr	r3, [pc, #80]	; (7f8 <loop+0x88>)
     7a8:	movs	r2, #4
     7aa:	strh	r2, [r3, #0]
     7ac:	bl	4d4 <acq_stop()>
  } 

  if(status >= CLOSED) // CLOSED or HIGHER
     7b0:	ldrsh.w	r0, [r4]
     7b4:	ldr	r5, [pc, #64]	; (7f8 <loop+0x88>)
     7b6:	cmp	r0, #0
     7b8:	blt.n	7f2 <loop+0x82>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     7ba:	ldr	r4, [pc, #64]	; (7fc <loop+0x8c>)
     7bc:	ldr	r3, [r4, #0]
     7be:	str	r3, [sp, #0]
  {
    uint32_t to=millis();
    status = checkToCloseFile(status, (uint32_t) t_acq); // check if we reached file size or aquisition time
     7c0:	ldr	r3, [pc, #60]	; (800 <loop+0x90>)
	return ret;
     7c2:	ldr	r6, [sp, #0]
     7c4:	ldr	r1, [r3, #0]
     7c6:	bl	6dc <checkToCloseFile(short, unsigned long)>
     7ca:	strh	r0, [r5, #0]
    //
    status = saveData(status);  
     7cc:	bl	1cd8 <saveData(short)>
     7d0:	strh	r0, [r5, #0]
    //
    uint32_t mc = getCount();
     7d2:	bl	18d0 <getCount()>
    if(mc>max_count) max_count=mc;
     7d6:	ldr	r2, [pc, #44]	; (804 <loop+0x94>)
     7d8:	ldr	r3, [r2, #0]
     7da:	cmp	r0, r3
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     7dc:	ldr	r3, [r4, #0]
     7de:	it	hi
     7e0:	strhi	r0, [r2, #0]
     7e2:	str	r3, [sp, #4]
    //
    uint32_t dt=millis()-to;
    if(max_write<dt) max_write=dt;
     7e4:	ldr	r2, [pc, #32]	; (808 <loop+0x98>)
	return ret;
     7e6:	ldr	r3, [sp, #4]
     7e8:	ldr	r1, [r2, #0]
    status = saveData(status);  
    //
    uint32_t mc = getCount();
    if(mc>max_count) max_count=mc;
    //
    uint32_t dt=millis()-to;
     7ea:	subs	r3, r3, r6
    if(max_write<dt) max_write=dt;
     7ec:	cmp	r3, r1
     7ee:	it	hi
     7f0:	strhi	r3, [r2, #0]
  }
     7f2:	add	sp, #8
     7f4:	pop	{r4, r5, r6, pc}
     7f6:	nop
     7f8:	.word	0x1fff0f34
     7fc:	.word	0x1fff8484
     800:	.word	0x1fff0f38
     804:	.word	0x1fff21ec
     808:	.word	0x1fff21e4

0000080c <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
     80c:	movs	r0, #0
     80e:	bx	lr

00000810 <Print::flush()>:
	virtual void flush()				{ }
     810:	bx	lr

00000812 <File::write(unsigned char const*, unsigned int)>:
		return (f) ? f->read(buf, nbyte) : 0;
	}
	
	// override print version
	virtual size_t write(const uint8_t *buf, size_t size) {
		return (f) ? f->write((void*)buf, size) : 0;
     812:	ldr	r0, [r0, #16]
     814:	cbz	r0, 81c <File::write(unsigned char const*, unsigned int)+0xa>
     816:	ldr	r3, [r0, #0]
     818:	ldr	r3, [r3, #12]
     81a:	bx	r3
	}
     81c:	bx	lr

0000081e <File::available()>:

	size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
	}
	int available() {
		return (f) ? f->available() : 0;
     81e:	ldr	r0, [r0, #16]
     820:	cbz	r0, 828 <File::available()+0xa>
     822:	ldr	r3, [r0, #0]
     824:	ldr	r3, [r3, #16]
     826:	bx	r3
	}
     828:	bx	lr

0000082a <File::peek()>:
	int peek() {
		return (f) ? f->peek() : -1;
     82a:	ldr	r0, [r0, #16]
     82c:	cbz	r0, 834 <File::peek()+0xa>
     82e:	ldr	r3, [r0, #0]
     830:	ldr	r3, [r3, #20]
     832:	bx	r3
	}
     834:	mov.w	r0, #4294967295
     838:	bx	lr

0000083a <File::flush()>:
	void flush() {
		if (f) f->flush();
     83a:	ldr	r0, [r0, #16]
     83c:	cbz	r0, 844 <File::flush()+0xa>
     83e:	ldr	r3, [r0, #0]
     840:	ldr	r3, [r3, #24]
     842:	bx	r3
     844:	bx	lr

00000846 <File::read()>:
		return (f) ? f->setModifyTime(tm) : false;
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
     846:	push	{r0, r1, r2, lr}
		if (!f) return -1;
     848:	ldr	r0, [r0, #16]
     84a:	cbnz	r0, 852 <File::read()+0xc>
     84c:	mov.w	r0, #4294967295
     850:	b.n	866 <File::read()+0x20>
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
     852:	ldr	r3, [r0, #0]
     854:	movs	r2, #1
     856:	ldr	r3, [r3, #8]
     858:	add.w	r1, sp, #7
     85c:	blx	r3
     85e:	cmp	r0, #0
     860:	beq.n	84c <File::read()+0x6>
		return b;
     862:	ldrb.w	r0, [sp, #7]
	}
     866:	add	sp, #12
     868:	ldr.w	pc, [sp], #4

0000086c <File::write(unsigned char)>:
	size_t write(uint8_t b) {
     86c:	push	{r0, r1, r2, lr}
		return (f) ? f->write(&b, 1) : 0;
     86e:	ldr	r0, [r0, #16]
		if (!f) return -1;
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
		return b;
	}
	size_t write(uint8_t b) {
     870:	strb.w	r1, [sp, #7]
		return (f) ? f->write(&b, 1) : 0;
     874:	cbz	r0, 882 <File::write(unsigned char)+0x16>
     876:	ldr	r3, [r0, #0]
     878:	movs	r2, #1
     87a:	ldr	r3, [r3, #12]
     87c:	add.w	r1, sp, #7
     880:	blx	r3
	}
     882:	add	sp, #12
     884:	ldr.w	pc, [sp], #4

00000888 <SDFile::getCreateTime(DateTimeFields&)>:
		return File();
	}
	virtual void rewindDirectory(void) {
		sdfatfile.rewindDirectory();
	}
	virtual bool getCreateTime(DateTimeFields &tm) {
     888:	push	{r0, r1, r4, lr}
     88a:	mov	r3, r0
   * \param[out] ptime Packed time for directory entry.
   *
   * \return true for success or false for failure.
   */
  bool getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    return m_fFile ? m_fFile->getCreateDateTime(pdate, ptime) :
     88c:	ldr	r0, [r0, #80]	; 0x50
     88e:	mov	r4, r1
           m_xFile ? m_xFile->getCreateDateTime(pdate, ptime) : false;
     890:	cbz	r0, 89e <SDFile::getCreateTime(DateTimeFields&)+0x16>
     892:	add.w	r2, sp, #6
     896:	add	r1, sp, #4
     898:	bl	5bce <FatFile::getCreateDateTime(unsigned short*, unsigned short*)>
     89c:	b.n	8b0 <SDFile::getCreateTime(DateTimeFields&)+0x28>
     89e:	ldr	r0, [r3, #84]	; 0x54
     8a0:	cbnz	r0, 8a6 <SDFile::getCreateTime(DateTimeFields&)+0x1e>
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getCreateDateTime(&fat_date, &fat_time)) return false;
     8a2:	movs	r0, #0
     8a4:	b.n	8ea <SDFile::getCreateTime(DateTimeFields&)+0x62>
     8a6:	add.w	r2, sp, #6
     8aa:	add	r1, sp, #4
     8ac:	bl	38da <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)>
     8b0:	cmp	r0, #0
     8b2:	beq.n	8a2 <SDFile::getCreateTime(DateTimeFields&)+0x1a>
		if ((fat_date == 0) && (fat_time == 0)) return false;
     8b4:	ldrh.w	r3, [sp, #4]
     8b8:	ldrh.w	r2, [sp, #6]
     8bc:	cbnz	r3, 8c2 <SDFile::getCreateTime(DateTimeFields&)+0x3a>
     8be:	cmp	r2, #0
     8c0:	beq.n	8a2 <SDFile::getCreateTime(DateTimeFields&)+0x1a>
		tm.sec = FS_SECOND(fat_time);
     8c2:	and.w	r1, r2, #31
     8c6:	lsls	r1, r1, #1
     8c8:	strb	r1, [r4, #0]
		tm.min = FS_MINUTE(fat_time);
     8ca:	ubfx	r1, r2, #5, #6
		tm.hour = FS_HOUR(fat_time);
     8ce:	asrs	r2, r2, #11
     8d0:	strb	r2, [r4, #2]
		tm.mday = FS_DAY(fat_date);
     8d2:	and.w	r2, r3, #31
     8d6:	strb	r2, [r4, #4]
		tm.mon = FS_MONTH(fat_date) - 1;
     8d8:	ubfx	r2, r3, #5, #4
		tm.year = FS_YEAR(fat_date) - 1900;
     8dc:	asrs	r3, r3, #9
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     8de:	subs	r2, #1
		tm.year = FS_YEAR(fat_date) - 1900;
     8e0:	add.w	r3, r3, #1872	; 0x750
	virtual bool getCreateTime(DateTimeFields &tm) {
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getCreateDateTime(&fat_date, &fat_time)) return false;
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
     8e4:	strb	r1, [r4, #1]
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     8e6:	strb	r2, [r4, #5]
		tm.year = FS_YEAR(fat_date) - 1900;
     8e8:	strb	r3, [r4, #6]
		return true;
	}
     8ea:	add	sp, #8
     8ec:	pop	{r4, pc}

000008ee <SDFile::getModifyTime(DateTimeFields&)>:
	virtual bool getModifyTime(DateTimeFields &tm) {
     8ee:	push	{r0, r1, r4, lr}
     8f0:	mov	r3, r0
   * \param[out] ptime Packed time for directory entry.
   *
   * \return true for success or false for failure.
   */
  bool getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    return m_fFile ? m_fFile->getModifyDateTime(pdate, ptime) :
     8f2:	ldr	r0, [r0, #80]	; 0x50
     8f4:	mov	r4, r1
           m_xFile ? m_xFile->getModifyDateTime(pdate, ptime) : false;
     8f6:	cbz	r0, 904 <SDFile::getModifyTime(DateTimeFields&)+0x16>
     8f8:	add.w	r2, sp, #6
     8fc:	add	r1, sp, #4
     8fe:	bl	5bee <FatFile::getModifyDateTime(unsigned short*, unsigned short*)>
     902:	b.n	916 <SDFile::getModifyTime(DateTimeFields&)+0x28>
     904:	ldr	r0, [r3, #84]	; 0x54
     906:	cbnz	r0, 90c <SDFile::getModifyTime(DateTimeFields&)+0x1e>
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getModifyDateTime(&fat_date, &fat_time)) return false;
     908:	movs	r0, #0
     90a:	b.n	950 <SDFile::getModifyTime(DateTimeFields&)+0x62>
     90c:	add.w	r2, sp, #6
     910:	add	r1, sp, #4
     912:	bl	38fa <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)>
     916:	cmp	r0, #0
     918:	beq.n	908 <SDFile::getModifyTime(DateTimeFields&)+0x1a>
		if ((fat_date == 0) && (fat_time == 0)) return false;
     91a:	ldrh.w	r3, [sp, #4]
     91e:	ldrh.w	r2, [sp, #6]
     922:	cbnz	r3, 928 <SDFile::getModifyTime(DateTimeFields&)+0x3a>
     924:	cmp	r2, #0
     926:	beq.n	908 <SDFile::getModifyTime(DateTimeFields&)+0x1a>
		tm.sec = FS_SECOND(fat_time);
     928:	and.w	r1, r2, #31
     92c:	lsls	r1, r1, #1
     92e:	strb	r1, [r4, #0]
		tm.min = FS_MINUTE(fat_time);
     930:	ubfx	r1, r2, #5, #6
		tm.hour = FS_HOUR(fat_time);
     934:	asrs	r2, r2, #11
     936:	strb	r2, [r4, #2]
		tm.mday = FS_DAY(fat_date);
     938:	and.w	r2, r3, #31
     93c:	strb	r2, [r4, #4]
		tm.mon = FS_MONTH(fat_date) - 1;
     93e:	ubfx	r2, r3, #5, #4
		tm.year = FS_YEAR(fat_date) - 1900;
     942:	asrs	r3, r3, #9
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     944:	subs	r2, #1
		tm.year = FS_YEAR(fat_date) - 1900;
     946:	add.w	r3, r3, #1872	; 0x750
	virtual bool getModifyTime(DateTimeFields &tm) {
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getModifyDateTime(&fat_date, &fat_time)) return false;
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
     94a:	strb	r1, [r4, #1]
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     94c:	strb	r2, [r4, #5]
		tm.year = FS_YEAR(fat_date) - 1900;
     94e:	strb	r3, [r4, #6]
		return true;
	}
     950:	add	sp, #8
     952:	pop	{r4, pc}

00000954 <SDFile::name()>:
		}
	}
	virtual bool isOpen() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
     954:	push	{r3, r4, r5, lr}
		if (!filename) {
     956:	ldr	r5, [r0, #88]	; 0x58
		}
	}
	virtual bool isOpen() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
     958:	mov	r4, r0
		if (!filename) {
     95a:	cbnz	r5, 98c <SDFile::name()+0x38>
			filename = (char *)malloc(MAX_FILENAME_LEN);
     95c:	mov.w	r0, #256	; 0x100
     960:	bl	aad0 <malloc>
     964:	mov	r1, r0
     966:	str	r0, [r4, #88]	; 0x58
			if (filename) {
     968:	cbz	r0, 988 <SDFile::name()+0x34>
   *             must be at least 13 bytes long.  The file's name will be
   *             truncated if the file's name is too long.
   * \return The length of the returned string.
   */
  size_t getName(char* name, size_t len) {
    *name = 0;
     96a:	strb	r5, [r0, #0]
    return m_fFile ? m_fFile->getName(name, len) :
     96c:	ldr	r0, [r4, #80]	; 0x50
           m_xFile ? m_xFile->getName(name, len) : 0;
     96e:	cbz	r0, 97a <SDFile::name()+0x26>
     970:	mov.w	r2, #256	; 0x100
     974:	bl	54bc <FatFile::getName(char*, unsigned int)>
     978:	b.n	98c <SDFile::name()+0x38>
     97a:	ldr	r0, [r4, #84]	; 0x54
     97c:	cbz	r0, 98c <SDFile::name()+0x38>
   * \param[in] size The size of the array in characters.
   * \return the name length.
   */
  size_t getName(char* name, size_t size) {
#if USE_UTF8_LONG_NAMES
    return getName8(name, size);
     97e:	mov.w	r2, #256	; 0x100
     982:	bl	377c <ExFatFile::getName8(char*, unsigned int)>
     986:	b.n	98c <SDFile::name()+0x38>
				sdfatfile.getName(filename, MAX_FILENAME_LEN);
			} else {
				static char zeroterm = 0;
				filename = &zeroterm;
     988:	ldr	r3, [pc, #4]	; (990 <SDFile::name()+0x3c>)
     98a:	str	r3, [r4, #88]	; 0x58
			}
		}
		return filename;
	}
     98c:	ldr	r0, [r4, #88]	; 0x58
     98e:	pop	{r3, r4, r5, pc}
     990:	.word	0x1fff21f0

00000994 <SDFile::truncate(unsigned long long)>:
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
		return sdfatfile.read(buf, nbyte);
	}
	virtual bool truncate(uint64_t size=0) {
     994:	push	{r4, r6, r7, lr}
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     996:	ldr	r4, [r0, #80]	; 0x50
           m_xFile ? m_xFile->truncate(length) : false;
     998:	cbz	r4, 9b6 <SDFile::truncate(unsigned long long)+0x22>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     99a:	cmp	r3, #1
     99c:	it	eq
     99e:	cmpeq	r2, #0
     9a0:	bcs.n	9cc <SDFile::truncate(unsigned long long)+0x38>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint32_t length) {
    return seekSet(length) && truncate();
     9a2:	mov	r1, r2
     9a4:	mov	r0, r4
     9a6:	bl	57fe <FatFile::seekSet(unsigned long)>
     9aa:	cbz	r0, 9cc <SDFile::truncate(unsigned long long)+0x38>
     9ac:	mov	r0, r4
     9ae:	bl	5ff6 <FatFile::truncate()>
     9b2:	cbz	r0, 9cc <SDFile::truncate(unsigned long long)+0x38>
     9b4:	pop	{r4, r6, r7, pc}
           m_xFile ? m_xFile->truncate(length) : false;
     9b6:	ldr	r4, [r0, #84]	; 0x54
     9b8:	cbz	r4, 9cc <SDFile::truncate(unsigned long long)+0x38>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
     9ba:	mov	r0, r4
     9bc:	bl	3b6c <ExFatFile::seekSet(unsigned long long)>
     9c0:	cbz	r0, 9cc <SDFile::truncate(unsigned long long)+0x38>
     9c2:	mov	r0, r4
		return sdfatfile.truncate(size);
	}
     9c4:	ldmia.w	sp!, {r4, r6, r7, lr}
     9c8:	b.w	4b5e <ExFatFile::truncate()>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     9cc:	movs	r0, #0
     9ce:	pop	{r4, r6, r7, pc}

000009d0 <File::dec_refcount() [clone .isra.15]>:
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	using Print::write;
private:
	void dec_refcount() {
     9d0:	push	{r4, lr}
     9d2:	mov	r4, r0
		if (--(f->refcount) == 0) {
     9d4:	ldr	r0, [r0, #0]
     9d6:	ldr	r3, [r0, #4]
     9d8:	subs	r3, #1
     9da:	str	r3, [r0, #4]
     9dc:	cbnz	r3, 9ee <File::dec_refcount() [clone .isra.15]+0x1e>
			f->close();
     9de:	ldr	r3, [r0, #0]
     9e0:	ldr	r3, [r3, #44]	; 0x2c
     9e2:	blx	r3
			delete f;
     9e4:	ldr	r0, [r4, #0]
     9e6:	cbz	r0, 9ee <File::dec_refcount() [clone .isra.15]+0x1e>
     9e8:	ldr	r3, [r0, #0]
     9ea:	ldr	r3, [r3, #4]
     9ec:	blx	r3
		}
		f = nullptr;
     9ee:	movs	r3, #0
     9f0:	str	r3, [r4, #0]
     9f2:	pop	{r4, pc}

000009f4 <File::~File()>:
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
     9f4:	ldr	r3, [pc, #20]	; (a0c <File::~File()+0x18>)
     9f6:	push	{r4, lr}
     9f8:	str	r3, [r0, #0]
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
     9fa:	ldr	r3, [r0, #16]
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
     9fc:	mov	r4, r0
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
     9fe:	cbz	r3, a06 <File::~File()+0x12>
     a00:	adds	r0, #16
     a02:	bl	9d0 <File::dec_refcount() [clone .isra.15]>
	}
     a06:	mov	r0, r4
     a08:	pop	{r4, pc}
     a0a:	nop
     a0c:	.word	0x00011d20

00000a10 <File::~File()>:
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
     a10:	push	{r4, lr}
     a12:	mov	r4, r0
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
	}
     a14:	bl	9f4 <File::~File()>
     a18:	mov	r0, r4
     a1a:	movs	r1, #20
     a1c:	bl	9c1c <operator delete(void*, unsigned int)>
     a20:	mov	r0, r4
     a22:	pop	{r4, pc}

00000a24 <SDFile::position()>:
    return m_fFile ? m_fFile->contiguousRange(bgnSector, endSector) :
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
     a24:	ldr	r3, [r0, #80]	; 0x50
           m_xFile ? m_xFile->curPosition() : 0;
     a26:	cbz	r3, a2e <SDFile::position()+0xa>
     a28:	ldr	r0, [r3, #20]
     a2a:	movs	r1, #0
     a2c:	bx	lr
     a2e:	ldr	r3, [r0, #84]	; 0x54
     a30:	cbz	r3, a38 <SDFile::position()+0x14>
   *
   * \return true for success or false for failure.
   */
  bool contiguousRange(uint32_t* bgnSector, uint32_t* endSector);
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {return m_curPosition;}
     a32:	ldmia.w	r3, {r0, r1}
     a36:	bx	lr
     a38:	mov	r0, r3
     a3a:	b.n	a2a <SDFile::position()+0x6>

00000a3c <SDFile::size()>:
    return m_fFile ? m_fFile->fgets(str, num, delim) :
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
     a3c:	ldr	r3, [r0, #80]	; 0x50
           m_xFile ? m_xFile->fileSize() : 0;
     a3e:	cbz	r3, a46 <SDFile::size()+0xa>
     a40:	ldr	r0, [r3, #28]
     a42:	movs	r1, #0
     a44:	bx	lr
     a46:	ldr	r3, [r0, #84]	; 0x54
     a48:	cbz	r3, a50 <SDFile::size()+0x14>
   * If no data is read, fgets() returns zero for EOF or -1 if an error
   * occurred.
   */
  int fgets(char* str, int num, char* delim = nullptr);
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {return m_validLength;}
     a4a:	ldr	r0, [r3, #16]
     a4c:	ldr	r1, [r3, #20]
     a4e:	bx	lr
     a50:	mov	r0, r3
     a52:	b.n	a42 <SDFile::size()+0x6>

00000a54 <Print::write(char const*)>:
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     a54:	push	{r4, r5, r6, lr}
     a56:	mov	r4, r0
     a58:	mov	r0, r1
     a5a:	mov	r5, r1
     a5c:	bl	b740 <strlen>
     a60:	ldr	r3, [r4, #0]
     a62:	mov	r2, r0
     a64:	mov	r1, r5
     a66:	mov	r0, r4
     a68:	ldr	r3, [r3, #4]
     a6a:	ldmia.w	sp!, {r4, r5, r6, lr}
     a6e:	bx	r3

00000a70 <FsBaseFile::available() const>:
  operator bool() const {return isOpen();}
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
    return m_fFile ? m_fFile->available() :
     a70:	ldr	r2, [r0, #56]	; 0x38
    */
  operator bool() const {return isOpen();}
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
     a72:	push	{r4, r5, lr}
    return m_fFile ? m_fFile->available() :
           m_xFile ? m_xFile->available() : 0;
     a74:	cbz	r2, a90 <FsBaseFile::available() const+0x20>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available32() const {
    return isFile() ? fileSize() - curPosition() : 0;
     a76:	ldrb	r3, [r2, #0]
     a78:	and.w	r3, r3, #8
     a7c:	and.w	r0, r3, #255	; 0xff
     a80:	cbz	r3, ac2 <FsBaseFile::available() const+0x52>
     a82:	ldr	r3, [r2, #28]
     a84:	ldr	r0, [r2, #20]
   * Zero is returned for directory files.
   *
   */
  int available() const {
    uint32_t n = available32();
    return n > INT_MAX ? INT_MAX : n;
     a86:	subs	r0, r3, r0
     a88:	bpl.n	ac2 <FsBaseFile::available() const+0x52>
     a8a:	mvn.w	r0, #2147483648	; 0x80000000
     a8e:	b.n	ac2 <FsBaseFile::available() const+0x52>
     a90:	ldr	r0, [r0, #60]	; 0x3c
     a92:	cbz	r0, ac2 <FsBaseFile::available() const+0x52>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint64_t available64() {
    return isFile() ? fileSize() - curPosition() : 0;
     a94:	ldrb.w	r3, [r0, #49]	; 0x31
     a98:	lsls	r3, r3, #28
     a9a:	bpl.n	aac <FsBaseFile::available() const+0x3c>
     a9c:	ldrd	r4, r5, [r0, #16]
     aa0:	ldrd	r2, r3, [r0]
     aa4:	subs	r0, r4, r2
     aa6:	sbc.w	r1, r5, r3
     aaa:	b.n	ab0 <FsBaseFile::available() const+0x40>
     aac:	movs	r0, #0
     aae:	movs	r1, #0
   * Zero is returned for directory files.
   *
   */
  int available() {
    uint64_t n = available64();
    return n > INT_MAX ? INT_MAX : n;
     ab0:	movs	r3, #0
     ab2:	mvn.w	r2, #2147483648	; 0x80000000
     ab6:	cmp	r3, r1
     ab8:	it	eq
     aba:	cmpeq	r2, r0
     abc:	bcs.n	ac2 <FsBaseFile::available() const+0x52>
     abe:	mov	r0, r2
     ac0:	pop	{r4, r5, pc}
  }
     ac2:	pop	{r4, r5, pc}

00000ac4 <StreamFile<FsBaseFile, unsigned long long>::available()>:
  StreamFile() {}

  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
     ac4:	push	{r3, lr}
    return BaseFile::available();
     ac6:	adds	r0, #16
     ac8:	bl	a70 <FsBaseFile::available() const>
  }
     acc:	pop	{r3, pc}

00000ace <SDFile::available()>:
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
		return sdfatfile.peek();
	}
	virtual int available() {
     ace:	push	{r3, lr}

  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
    return BaseFile::available();
     ad0:	adds	r0, #24
     ad2:	bl	a70 <FsBaseFile::available() const>
		return sdfatfile.available();
	}
     ad6:	pop	{r3, pc}

00000ad8 <FsBaseFile::isDir() const>:
    return m_xFile ? m_xFile->isContiguous() : false;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  }
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_fFile ? m_fFile->isDir() :
     ad8:	ldr	r3, [r0, #56]	; 0x38
           m_xFile ? m_xFile->isDir() : false;
     ada:	cbz	r3, ae4 <FsBaseFile::isDir() const+0xc>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
    /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  /** \return True if this is a directory. */
  bool isDir() const {return m_attributes & FILE_ATTR_DIR;}
     adc:	ldrb	r3, [r3, #0]
     ade:	tst.w	r3, #112	; 0x70
     ae2:	b.n	af0 <FsBaseFile::isDir() const+0x18>
     ae4:	ldr	r0, [r0, #60]	; 0x3c
     ae6:	cbz	r0, af6 <FsBaseFile::isDir() const+0x1e>
   */
  bool isBusy();
  /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
  /** \return True if this is a directory. */
  bool isDir() const  {return m_attributes & FILE_ATTR_DIR;}
     ae8:	ldrb.w	r3, [r0, #49]	; 0x31
     aec:	tst.w	r3, #80	; 0x50
     af0:	ite	ne
     af2:	movne	r0, #1
     af4:	moveq	r0, #0
  }
     af6:	bx	lr

00000af8 <SDFile::isDirectory()>:
				filename = &zeroterm;
			}
		}
		return filename;
	}
	virtual boolean isDirectory(void) {
     af8:	push	{r3, lr}
  }
  /** This function reports if the current file is a directory or not.
  * \return true if the file is a directory.
  */
  bool isDirectory() {
    return BaseFile::isDir();
     afa:	adds	r0, #24
     afc:	bl	ad8 <FsBaseFile::isDir() const>
		return sdfatfile.isDirectory();
	}
     b00:	pop	{r3, pc}

00000b02 <SDFile::rewindDirectory()>:
	virtual File openNextFile(uint8_t mode=0) {
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
		return File();
	}
	virtual void rewindDirectory(void) {
     b02:	push	{r4, lr}
     b04:	mov	r4, r0
  int read() {
    return BaseFile::read();
  }
  /** Rewind a file if it is a directory */
  void rewindDirectory() {
    if (BaseFile::isDir()) {
     b06:	adds	r0, #24
     b08:	bl	ad8 <FsBaseFile::isDir() const>
     b0c:	cbz	r0, b28 <SDFile::rewindDirectory()+0x26>
    return m_fFile ? m_fFile->rename(dirFile->m_fFile, newPath) :
           m_xFile ? m_xFile->rename(dirFile->m_xFile, newPath) : false;
  }
  /** Set the file's current position to zero. */
  void rewind() {
    if (m_fFile) m_fFile->rewind();
     b0e:	ldr	r0, [r4, #80]	; 0x50
     b10:	cbz	r0, b18 <SDFile::rewindDirectory()+0x16>
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
     b12:	movs	r1, #0
     b14:	bl	57fe <FatFile::seekSet(unsigned long)>
    if (m_xFile) m_xFile->rewind();
     b18:	ldr	r0, [r4, #84]	; 0x54
     b1a:	cbz	r0, b28 <SDFile::rewindDirectory()+0x26>
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
     b1c:	movs	r2, #0
     b1e:	movs	r3, #0
		sdfatfile.rewindDirectory();
	}
     b20:	ldmia.w	sp!, {r4, lr}
     b24:	b.w	3b6c <ExFatFile::seekSet(unsigned long long)>
     b28:	pop	{r4, pc}

00000b2a <FsBaseFile::isOpen() const>:
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     b2a:	ldr	r3, [r0, #56]	; 0x38
     b2c:	cbnz	r3, b38 <FsBaseFile::isOpen() const+0xe>
     b2e:	ldr	r0, [r0, #60]	; 0x3c
     b30:	adds	r0, #0
     b32:	it	ne
     b34:	movne	r0, #1
     b36:	bx	lr
     b38:	movs	r0, #1
     b3a:	bx	lr

00000b3c <SDFile::close()>:
		return sdfatfile.curPosition();
	}
	virtual uint64_t size() {
		return sdfatfile.size();
	}
	virtual void close() {
     b3c:	push	{r4, lr}
     b3e:	mov	r4, r0
		if (filename) {
     b40:	ldr	r0, [r0, #88]	; 0x58
     b42:	cbz	r0, b4c <SDFile::close()+0x10>
			free(filename);
     b44:	bl	aae0 <free>
			filename = nullptr;
     b48:	movs	r3, #0
     b4a:	str	r3, [r4, #88]	; 0x58
		}
		if (sdfatfile.isOpen()) {
     b4c:	adds	r4, #24
     b4e:	mov	r0, r4
     b50:	bl	b2a <FsBaseFile::isOpen() const>
     b54:	cbz	r0, b60 <SDFile::close()+0x24>
			sdfatfile.close();
     b56:	mov	r0, r4
		}
	}
     b58:	ldmia.w	sp!, {r4, lr}
		if (filename) {
			free(filename);
			filename = nullptr;
		}
		if (sdfatfile.isOpen()) {
			sdfatfile.close();
     b5c:	b.w	6d14 <FsBaseFile::close()>
     b60:	pop	{r4, pc}
     b62:	Address 0x00000b62 is out of bounds.


00000b64 <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     b64:	push	{r4, lr}
     b66:	ldr	r3, [pc, #24]	; (b80 <SDFile::~SDFile()+0x1c>)
     b68:	str	r3, [r0, #0]
     b6a:	mov	r4, r0
		close();
     b6c:	bl	b3c <SDFile::close()>
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     b70:	ldr	r3, [pc, #16]	; (b84 <SDFile::~SDFile()+0x20>)
     b72:	str	r3, [r4, #8]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     b74:	add.w	r0, r4, #24
     b78:	bl	6d14 <FsBaseFile::close()>
	}
     b7c:	mov	r0, r4
     b7e:	pop	{r4, pc}
     b80:	.word	0x00011d4c
     b84:	.word	0x00011cd8

00000b88 <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     b88:	push	{r4, lr}
     b8a:	mov	r4, r0
		close();
	}
     b8c:	bl	b64 <SDFile::~SDFile()>
     b90:	mov	r0, r4
     b92:	movs	r1, #92	; 0x5c
     b94:	bl	9c1c <operator delete(void*, unsigned int)>
     b98:	mov	r0, r4
     b9a:	pop	{r4, pc}

00000b9c <SDFile::isOpen()>:
		}
		if (sdfatfile.isOpen()) {
			sdfatfile.close();
		}
	}
	virtual bool isOpen() {
     b9c:	push	{r3, lr}
		return sdfatfile.isOpen();
     b9e:	adds	r0, #24
     ba0:	bl	b2a <FsBaseFile::isOpen() const>
	}
     ba4:	pop	{r3, pc}

00000ba6 <FsBaseFile::peek()>:
  uint64_t position() const {return curPosition();}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
     ba6:	mov	r3, r0
    return m_fFile ? m_fFile->peek() :
     ba8:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->peek() : -1;
     baa:	cbz	r0, bb0 <FsBaseFile::peek()+0xa>
     bac:	b.w	579c <FatFile::peek()>
     bb0:	ldr	r0, [r3, #60]	; 0x3c
     bb2:	cbz	r0, bb8 <FsBaseFile::peek()+0x12>
     bb4:	b.w	3b40 <ExFatFile::peek()>
  }
     bb8:	mov.w	r0, #4294967295
     bbc:	bx	lr

00000bbe <StreamFile<FsBaseFile, unsigned long long>::peek()>:
  const char* name() const {return "use getName()";}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
     bbe:	push	{r3, lr}
    return BaseFile::peek();
     bc0:	adds	r0, #16
     bc2:	bl	ba6 <FsBaseFile::peek()>
  }
     bc6:	pop	{r3, pc}

00000bc8 <SDFile::peek()>:
		close();
	}
	virtual size_t write(const void *buf, size_t size) {
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
     bc8:	push	{r3, lr}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    return BaseFile::peek();
     bca:	adds	r0, #24
     bcc:	bl	ba6 <FsBaseFile::peek()>
		return sdfatfile.peek();
	}
     bd0:	pop	{r3, pc}

00000bd2 <FsBaseFile::read(void*, unsigned int)>:
   * if end of file is reached.
   * If an error occurs, read() returns -1.  Possible errors include
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
     bd2:	mov	r3, r0
    return m_fFile ? m_fFile->read(buf, count) :
     bd4:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->read(buf, count) : -1;
     bd6:	cbz	r0, bdc <FsBaseFile::read(void*, unsigned int)+0xa>
     bd8:	b.w	5624 <FatFile::read(void*, unsigned int)>
     bdc:	ldr	r0, [r3, #60]	; 0x3c
     bde:	cbz	r0, be4 <FsBaseFile::read(void*, unsigned int)+0x12>
     be0:	b.w	39bc <ExFatFile::read(void*, unsigned int)>
  }
     be4:	mov.w	r0, #4294967295
     be8:	bx	lr

00000bea <StreamFile<FsBaseFile, unsigned long long>::read()>:
  /** Read the next byte from a file.
   *
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
     bea:	push	{r0, r1, r2, lr}
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
     bec:	movs	r2, #1
     bee:	add.w	r1, sp, #7
     bf2:	adds	r0, #16
     bf4:	bl	bd2 <FsBaseFile::read(void*, unsigned int)>
     bf8:	cmp	r0, #1
     bfa:	ite	eq
     bfc:	ldrbeq.w	r0, [sp, #7]
     c00:	movne.w	r0, #4294967295
    return BaseFile::read();
  }
     c04:	add	sp, #12
     c06:	ldr.w	pc, [sp], #4

00000c0a <SDFile::read(void*, unsigned int)>:
		return sdfatfile.available();
	}
	virtual void flush() {
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
     c0a:	push	{r3, lr}
		return sdfatfile.read(buf, nbyte);
     c0c:	adds	r0, #24
     c0e:	bl	bd2 <FsBaseFile::read(void*, unsigned int)>
	}
     c12:	pop	{r3, pc}

00000c14 <FsBaseFile::seekSet(unsigned long long)>:
   *
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
     c14:	push	{r4, r6, r7}
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     c16:	ldr	r4, [r0, #56]	; 0x38
           m_xFile ? m_xFile->seekSet(pos) : false;
     c18:	cbz	r4, c2c <FsBaseFile::seekSet(unsigned long long)+0x18>
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     c1a:	cmp	r3, #1
     c1c:	it	eq
     c1e:	cmpeq	r2, #0
     c20:	bcs.n	c36 <FsBaseFile::seekSet(unsigned long long)+0x22>
     c22:	mov	r0, r4
     c24:	mov	r1, r2
           m_xFile ? m_xFile->seekSet(pos) : false;
  }
     c26:	pop	{r4, r6, r7}
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     c28:	b.w	57fe <FatFile::seekSet(unsigned long)>
           m_xFile ? m_xFile->seekSet(pos) : false;
     c2c:	ldr	r0, [r0, #60]	; 0x3c
     c2e:	cbz	r0, c36 <FsBaseFile::seekSet(unsigned long long)+0x22>
  }
     c30:	pop	{r4, r6, r7}
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     c32:	b.w	3b6c <ExFatFile::seekSet(unsigned long long)>
  }
     c36:	movs	r0, #0
     c38:	pop	{r4, r6, r7}
     c3a:	bx	lr

00000c3c <SDFile::seek(unsigned long long, int)>:
	virtual bool truncate(uint64_t size=0) {
		return sdfatfile.truncate(size);
	}
	virtual bool seek(uint64_t pos, int mode = SeekSet) {
     c3c:	push	{r3, r4, r5, lr}
     c3e:	mov	r1, r0
     c40:	ldr	r0, [sp, #16]
     c42:	mov	r4, r2
     c44:	mov	r5, r3
		if (mode == SeekSet) return sdfatfile.seekSet(pos);
     c46:	cbnz	r0, c4e <SDFile::seek(unsigned long long, int)+0x12>
     c48:	add.w	r0, r1, #24
     c4c:	b.n	c8a <SDFile::seek(unsigned long long, int)+0x4e>
		if (mode == SeekCur) return sdfatfile.seekCur(pos);
     c4e:	cmp	r0, #1
     c50:	bne.n	c68 <SDFile::seek(unsigned long long, int)+0x2c>
    return m_fFile ? m_fFile->contiguousRange(bgnSector, endSector) :
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
     c52:	ldr	r3, [r1, #80]	; 0x50
     c54:	add.w	r0, r1, #24
           m_xFile ? m_xFile->curPosition() : 0;
     c58:	cbz	r3, c5e <SDFile::seek(unsigned long long, int)+0x22>
     c5a:	ldr	r2, [r3, #20]
     c5c:	b.n	c84 <SDFile::seek(unsigned long long, int)+0x48>
     c5e:	ldr	r3, [r1, #84]	; 0x54
     c60:	cbz	r3, c82 <SDFile::seek(unsigned long long, int)+0x46>
   *
   * \return true for success or false for failure.
   */
  bool contiguousRange(uint32_t* bgnSector, uint32_t* endSector);
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {return m_curPosition;}
     c62:	ldrd	r2, r3, [r3]
     c66:	b.n	c86 <SDFile::seek(unsigned long long, int)+0x4a>
		if (mode == SeekEnd) return sdfatfile.seekEnd(pos);
     c68:	cmp	r0, #2
     c6a:	bne.n	c90 <SDFile::seek(unsigned long long, int)+0x54>
    return m_fFile ? m_fFile->fgets(str, num, delim) :
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
     c6c:	ldr	r3, [r1, #80]	; 0x50
     c6e:	add.w	r0, r1, #24
           m_xFile ? m_xFile->fileSize() : 0;
     c72:	cbz	r3, c78 <SDFile::seek(unsigned long long, int)+0x3c>
     c74:	ldr	r2, [r3, #28]
     c76:	b.n	c84 <SDFile::seek(unsigned long long, int)+0x48>
     c78:	ldr	r3, [r1, #84]	; 0x54
     c7a:	cbz	r3, c82 <SDFile::seek(unsigned long long, int)+0x46>
   * If no data is read, fgets() returns zero for EOF or -1 if an error
   * occurred.
   */
  int fgets(char* str, int num, char* delim = nullptr);
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {return m_validLength;}
     c7c:	ldrd	r2, r3, [r3, #16]
     c80:	b.n	c86 <SDFile::seek(unsigned long long, int)+0x4a>
     c82:	movs	r2, #0
     c84:	movs	r3, #0
   * Can't be used for directory files since file size is not defined.
   * \param[in] offset The new position in bytes from end-of-file.
   * \return true for success or false for failure.
   */
  bool seekEnd(int64_t offset = 0) {
    return seekSet(fileSize() + offset);
     c86:	adds	r2, r2, r4
     c88:	adcs	r3, r5
     c8a:	bl	c14 <FsBaseFile::seekSet(unsigned long long)>
     c8e:	pop	{r3, r4, r5, pc}
		return false;
     c90:	movs	r0, #0
	}
     c92:	pop	{r3, r4, r5, pc}

00000c94 <FsBaseFile::sync()>:
  /** The sync() call causes all modified data and directory fields
   * to be written to the storage device.
   *
   * \return true for success or false for failure.
   */
  bool sync() {
     c94:	mov	r3, r0
    return m_fFile ? m_fFile->sync() :
     c96:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->sync() : false;
     c98:	cbz	r0, c9e <FsBaseFile::sync()+0xa>
     c9a:	b.w	5a54 <FatFile::sync()>
     c9e:	ldr	r0, [r3, #60]	; 0x3c
     ca0:	cbz	r0, ca6 <FsBaseFile::sync()+0x12>
     ca2:	b.w	4784 <ExFatFile::sync()>
  }
     ca6:	bx	lr

00000ca8 <StreamFile<FsBaseFile, unsigned long long>::flush()>:
   */
  int available() {
    return BaseFile::available();
  }
  /** Ensure that any bytes written to the file are saved to the SD card. */
  void flush() {
     ca8:	push	{r3, lr}
    BaseFile::sync();
     caa:	adds	r0, #16
     cac:	bl	c94 <FsBaseFile::sync()>
     cb0:	pop	{r3, pc}

00000cb2 <SDFile::flush()>:
		return sdfatfile.peek();
	}
	virtual int available() {
		return sdfatfile.available();
	}
	virtual void flush() {
     cb2:	push	{r3, lr}
     cb4:	adds	r0, #24
     cb6:	bl	c94 <FsBaseFile::sync()>
     cba:	pop	{r3, pc}

00000cbc <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
   * Modify and access timestamps may be overwritten if a date time callback
   * function has been set by dateTimeCallback().
   *
   * \return true for success or false for failure.
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
     cbc:	push	{r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
     cbe:	ldr.w	lr, [r0, #56]	; 0x38
   * Modify and access timestamps may be overwritten if a date time callback
   * function has been set by dateTimeCallback().
   *
   * \return true for success or false for failure.
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
     cc2:	ldrb.w	r4, [sp, #20]
     cc6:	ldrb.w	r5, [sp, #24]
     cca:	ldrb.w	r6, [sp, #28]
     cce:	ldrb.w	r7, [sp, #32]
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     cd2:	cmp.w	lr, #0
     cd6:	beq.n	cea <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x2e>
     cd8:	str	r7, [sp, #32]
     cda:	str	r6, [sp, #28]
     cdc:	str	r5, [sp, #24]
     cde:	str	r4, [sp, #20]
     ce0:	mov	r0, lr
  }
     ce2:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     ce6:	b.w	5f48 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
     cea:	ldr	r0, [r0, #60]	; 0x3c
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     cec:	cbz	r0, cfe <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x42>
     cee:	str	r7, [sp, #32]
     cf0:	str	r6, [sp, #28]
     cf2:	str	r5, [sp, #24]
     cf4:	str	r4, [sp, #20]
  }
     cf6:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     cfa:	b.w	4a4c <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
  }
     cfe:	pop	{r4, r5, r6, r7, pc}

00000d00 <SDFile::setModifyTime(DateTimeFields const&)>:
	virtual bool setCreateTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
	virtual bool setModifyTime(const DateTimeFields &tm) {
     d00:	push	{r0, r1, r2, r3, r4, lr}
		if (tm.year < 80 || tm.year > 207) return false;
     d02:	ldrb	r2, [r1, #6]
     d04:	sub.w	r3, r2, #80	; 0x50
     d08:	lsls	r3, r3, #24
     d0a:	bmi.n	d30 <SDFile::setModifyTime(DateTimeFields const&)+0x30>
		return sdfatfile.timestamp(T_WRITE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
     d0c:	ldrb	r4, [r1, #0]
     d0e:	ldrb	r3, [r1, #5]
     d10:	str	r4, [sp, #12]
     d12:	ldrb	r4, [r1, #1]
     d14:	str	r4, [sp, #8]
     d16:	ldrb	r4, [r1, #2]
     d18:	str	r4, [sp, #4]
     d1a:	ldrb	r1, [r1, #4]
     d1c:	str	r1, [sp, #0]
     d1e:	adds	r3, #1
     d20:	uxtb	r3, r3
     d22:	addw	r2, r2, #1900	; 0x76c
     d26:	movs	r1, #4
     d28:	adds	r0, #24
     d2a:	bl	cbc <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
     d2e:	b.n	d32 <SDFile::setModifyTime(DateTimeFields const&)+0x32>
		if (tm.year < 80 || tm.year > 207) return false;
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
	virtual bool setModifyTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
     d30:	movs	r0, #0
		return sdfatfile.timestamp(T_WRITE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
     d32:	add	sp, #16
     d34:	pop	{r4, pc}

00000d36 <SDFile::setCreateTime(DateTimeFields const&)>:
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
		tm.year = FS_YEAR(fat_date) - 1900;
		return true;
	}
	virtual bool setCreateTime(const DateTimeFields &tm) {
     d36:	push	{r0, r1, r2, r3, r4, lr}
		if (tm.year < 80 || tm.year > 207) return false;
     d38:	ldrb	r2, [r1, #6]
     d3a:	sub.w	r3, r2, #80	; 0x50
     d3e:	lsls	r3, r3, #24
     d40:	bmi.n	d66 <SDFile::setCreateTime(DateTimeFields const&)+0x30>
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
     d42:	ldrb	r4, [r1, #0]
     d44:	ldrb	r3, [r1, #5]
     d46:	str	r4, [sp, #12]
     d48:	ldrb	r4, [r1, #1]
     d4a:	str	r4, [sp, #8]
     d4c:	ldrb	r4, [r1, #2]
     d4e:	str	r4, [sp, #4]
     d50:	ldrb	r1, [r1, #4]
     d52:	str	r1, [sp, #0]
     d54:	adds	r3, #1
     d56:	uxtb	r3, r3
     d58:	addw	r2, r2, #1900	; 0x76c
     d5c:	movs	r1, #2
     d5e:	adds	r0, #24
     d60:	bl	cbc <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
     d64:	b.n	d68 <SDFile::setCreateTime(DateTimeFields const&)+0x32>
		tm.mon = FS_MONTH(fat_date) - 1;
		tm.year = FS_YEAR(fat_date) - 1900;
		return true;
	}
	virtual bool setCreateTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
     d66:	movs	r0, #0
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
     d68:	add	sp, #16
     d6a:	pop	{r4, pc}

00000d6c <FsBaseFile::write(void const*, unsigned int)>:
   * \param[in] count Number of bytes to write.
   *
   * \return For success write() returns the number of bytes written, always
   * \a nbyte.  If an error occurs, write() returns zero and writeError is set.
   */
  size_t write(const void* buf, size_t count) {
     d6c:	mov	r3, r0
    return m_fFile ? m_fFile->write(buf, count) :
     d6e:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->write(buf, count) : 0;
     d70:	cbz	r0, d76 <FsBaseFile::write(void const*, unsigned int)+0xa>
     d72:	b.w	6060 <FatFile::write(void const*, unsigned int)>
     d76:	ldr	r0, [r3, #60]	; 0x3c
     d78:	cbz	r0, d7e <FsBaseFile::write(void const*, unsigned int)+0x12>
     d7a:	b.w	4c1c <ExFatFile::write(void const*, unsigned int)>
  }
     d7e:	bx	lr

00000d80 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)>:
   * \param[in] size Number of bytes to write.
   *
   * \return For success write() returns the number of bytes written, always
   * \a size.
   */
  size_t write(const uint8_t* buffer, size_t size) {
     d80:	push	{r3, lr}
    return BaseFile::write(buffer, size);
     d82:	adds	r0, #16
     d84:	bl	d6c <FsBaseFile::write(void const*, unsigned int)>
  }
     d88:	pop	{r3, pc}

00000d8a <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)>:
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {
     d8a:	push	{r0, r1, r2, lr}
     d8c:	add	r3, sp, #8
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {return write(&b, 1);}
     d8e:	movs	r2, #1
     d90:	strb.w	r1, [r3, #-1]!
     d94:	adds	r0, #16
     d96:	mov	r1, r3
     d98:	bl	d6c <FsBaseFile::write(void const*, unsigned int)>
    return BaseFile::write(b);
  }
     d9c:	add	sp, #12
     d9e:	ldr.w	pc, [sp], #4

00000da2 <SDFile::write(void const*, unsigned int)>:
	friend class SDClass;
public:
	virtual ~SDFile(void) {
		close();
	}
	virtual size_t write(const void *buf, size_t size) {
     da2:	push	{r3, lr}
		return sdfatfile.write(buf, size);
     da4:	adds	r0, #24
     da6:	bl	d6c <FsBaseFile::write(void const*, unsigned int)>
	}
     daa:	pop	{r3, pc}

00000dac <File::close()>:
		return (f) ? f->position() : 0;
	}
	uint64_t size() {
		return (f) ? f->size() : 0;
	}
	void close() {
     dac:	push	{r4, lr}
     dae:	mov	r4, r0
		if (f) {
     db0:	ldr	r0, [r0, #16]
     db2:	cbz	r0, dc6 <File::close()+0x1a>
			f->close();
     db4:	ldr	r3, [r0, #0]
     db6:	ldr	r3, [r3, #44]	; 0x2c
     db8:	blx	r3
			dec_refcount();
     dba:	add.w	r0, r4, #16
		}
	}
     dbe:	ldmia.w	sp!, {r4, lr}
		return (f) ? f->size() : 0;
	}
	void close() {
		if (f) {
			f->close();
			dec_refcount();
     dc2:	b.w	9d0 <File::dec_refcount() [clone .isra.15]>
     dc6:	pop	{r4, pc}

00000dc8 <SDFile::SDFile(FsFile const&)>:
	// Classes derived from File are never meant to be constructed
	// anywhere other than open() in the parent FS class and
	// openNextFile() while traversing a directory.
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
     dc8:	push	{r3, r4, r5, lr}
// FileImpl instances are automatically deleted when the last referencing
// File is closed or goes out of scope.  The refcount variable is meant to
// be maintained by File class instances, never access by FileImpl functions.
// The FileImpl functions are meant to be called only by use of File instances.
//
class FileImpl {
     dca:	movs	r5, #0
     dcc:	ldr	r3, [pc, #40]	; (df8 <SDFile::SDFile(FsFile const&)+0x30>)
     dce:	str	r5, [r0, #4]
     dd0:	str	r3, [r0, #0]
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
     dd2:	ldrb	r3, [r1, #4]
     dd4:	strb	r3, [r0, #12]
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
     dd6:	ldr	r3, [pc, #36]	; (dfc <SDFile::SDFile(FsFile const&)+0x34>)
     dd8:	str	r3, [r0, #8]
     dda:	ldr	r3, [r1, #8]
     ddc:	str	r3, [r0, #16]
     dde:	ldrb	r3, [r1, #12]
     de0:	strb	r3, [r0, #20]
     de2:	mov	r4, r0
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     de4:	adds	r1, #16
     de6:	adds	r0, #24
     de8:	bl	6cb2 <FsBaseFile::FsBaseFile(FsBaseFile const&)>
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     dec:	ldr	r3, [pc, #16]	; (e00 <SDFile::SDFile(FsFile const&)+0x38>)
     dee:	str	r3, [r4, #8]
     df0:	str	r5, [r4, #88]	; 0x58
     df2:	mov	r0, r4
     df4:	pop	{r3, r4, r5, pc}
     df6:	nop
     df8:	.word	0x00011d4c
     dfc:	.word	0x00011cb4
     e00:	.word	0x00011cfc

00000e04 <SDFile::openNextFile(unsigned char)>:
		return filename;
	}
	virtual boolean isDirectory(void) {
		return sdfatfile.isDirectory();
	}
	virtual File openNextFile(uint8_t mode=0) {
     e04:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     e08:	sub	sp, #84	; 0x54
{
  public:
	constexpr Print() : write_error(0) {}
     e0a:	movs	r5, #0
     e0c:	add.w	r8, sp, #80	; 0x50
     e10:	ldr	r3, [pc, #108]	; (e80 <SDFile::openNextFile(unsigned char)+0x7c>)
     e12:	str.w	r3, [r8, #-80]!
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
     e16:	mov	r2, r5
     e18:	adds	r1, #24
     e1a:	mov	r4, r0
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     e1c:	mov.w	r6, #1000	; 0x3e8
     e20:	add	r0, sp, #16
     e22:	strb.w	r5, [sp, #4]
     e26:	str	r6, [sp, #8]
     e28:	strb.w	r5, [sp, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
     e2c:	str	r5, [sp, #72]	; 0x48
     e2e:	str	r5, [sp, #76]	; 0x4c
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
     e30:	bl	6dba <FsBaseFile::openNext(FsBaseFile*, int)>
  FsBaseFile& operator=(const FsBaseFile& from);
  /** The parenthesis operator.
    *
    * \return true if a file is open.
    */
  operator bool() const {return isOpen();}
     e34:	add	r0, sp, #16
     e36:	bl	b2a <FsBaseFile::isOpen() const>
     e3a:	ldr.w	r9, [pc, #76]	; e88 <SDFile::openNextFile(unsigned char)+0x84>
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
     e3e:	cbz	r0, e62 <SDFile::openNextFile(unsigned char)+0x5e>
     e40:	movs	r0, #92	; 0x5c
     e42:	bl	9c18 <operator new(unsigned int)>
     e46:	mov	r7, r0
     e48:	mov	r1, r8
     e4a:	bl	dc8 <SDFile::SDFile(FsFile const&)>
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
		if (f) f->refcount++;
     e4e:	ldr	r3, [r7, #4]
     e50:	strb	r5, [r4, #4]
     e52:	adds	r3, #1
     e54:	str	r6, [r4, #8]
     e56:	strb	r5, [r4, #12]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
     e58:	str.w	r9, [r4]
		f = file;
     e5c:	str	r7, [r4, #16]
		if (f) f->refcount++;
     e5e:	str	r3, [r7, #4]
     e60:	b.n	e6e <SDFile::openNextFile(unsigned char)+0x6a>
     e62:	strb	r0, [r4, #4]
     e64:	str	r6, [r4, #8]
     e66:	strb	r0, [r4, #12]
//
class File final : public Stream {
public:
	// Empty constructor, used when a program creates a File variable
	// but does not immediately assign or initialize it.
	constexpr File() : f(nullptr) { }
     e68:	str.w	r9, [r4]
     e6c:	str	r0, [r4, #16]
     e6e:	ldr	r3, [pc, #20]	; (e84 <SDFile::openNextFile(unsigned char)+0x80>)
     e70:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     e72:	add	r0, sp, #16
     e74:	bl	6d14 <FsBaseFile::close()>
		return File();
	}
     e78:	mov	r0, r4
     e7a:	add	sp, #84	; 0x54
     e7c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     e80:	.word	0x00011cfc
     e84:	.word	0x00011cd8
     e88:	.word	0x00011d20

00000e8c <SDClass::open(char const*, unsigned char)>:
class SDClass : public FS
{
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
     e8c:	push	{r4, r5, r6, lr}
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     e8e:	cmp	r3, #1
class SDClass : public FS
{
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
     e90:	sub	sp, #80	; 0x50
     e92:	mov	r4, r0
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     e94:	beq.n	ea2 <SDClass::open(char const*, unsigned char)+0x16>
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
     e96:	cmp	r3, #2
     e98:	movw	r3, #514	; 0x202
     e9c:	it	ne
     e9e:	movne	r3, #0
     ea0:	b.n	ea6 <SDClass::open(char const*, unsigned char)+0x1a>
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     ea2:	movw	r3, #16898	; 0x4202
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
     ea6:	adds	r1, #4
     ea8:	mov	r0, sp
     eaa:	bl	6ed4 <FsVolume::open(char const*, int)>
  FsBaseFile& operator=(const FsBaseFile& from);
  /** The parenthesis operator.
    *
    * \return true if a file is open.
    */
  operator bool() const {return isOpen();}
     eae:	add	r0, sp, #16
     eb0:	bl	b2a <FsBaseFile::isOpen() const>
     eb4:	ldr	r6, [pc, #68]	; (efc <SDClass::open(char const*, unsigned char)+0x70>)
		if (file) return File(new SDFile(file));
     eb6:	cbz	r0, ede <SDClass::open(char const*, unsigned char)+0x52>
     eb8:	movs	r0, #92	; 0x5c
     eba:	bl	9c18 <operator new(unsigned int)>
     ebe:	mov	r1, sp
     ec0:	mov	r5, r0
     ec2:	bl	dc8 <SDFile::SDFile(FsFile const&)>
     ec6:	movs	r3, #0
     ec8:	strb	r3, [r4, #4]
     eca:	strb	r3, [r4, #12]
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
		if (f) f->refcount++;
     ecc:	ldr	r3, [r5, #4]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
     ece:	str	r6, [r4, #0]
     ed0:	mov.w	r2, #1000	; 0x3e8
		f = file;
		if (f) f->refcount++;
     ed4:	adds	r3, #1
     ed6:	str	r2, [r4, #8]
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
     ed8:	str	r5, [r4, #16]
		if (f) f->refcount++;
     eda:	str	r3, [r5, #4]
     edc:	b.n	eec <SDClass::open(char const*, unsigned char)+0x60>
     ede:	mov.w	r3, #1000	; 0x3e8
     ee2:	strb	r0, [r4, #4]
     ee4:	str	r3, [r4, #8]
     ee6:	strb	r0, [r4, #12]
//
class File final : public Stream {
public:
	// Empty constructor, used when a program creates a File variable
	// but does not immediately assign or initialize it.
	constexpr File() : f(nullptr) { }
     ee8:	str	r6, [r4, #0]
     eea:	str	r0, [r4, #16]
     eec:	ldr	r3, [pc, #16]	; (f00 <SDClass::open(char const*, unsigned char)+0x74>)
     eee:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     ef0:	add	r0, sp, #16
     ef2:	bl	6d14 <FsBaseFile::close()>
		return File();
	}
     ef6:	mov	r0, r4
     ef8:	add	sp, #80	; 0x50
     efa:	pop	{r4, r5, r6, pc}
     efc:	.word	0x00011d20
     f00:	.word	0x00011cd8

00000f04 <storeConfig(unsigned short*, int)>:
uint16_t store[16];

extern  int t_acq;

void storeConfig(uint16_t *store, int ns)
{ 
     f04:	push	{r4, r5, r6, lr}
     f06:	sub	sp, #56	; 0x38
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
     f08:	ldr	r3, [pc, #120]	; (f84 <storeConfig(unsigned short*, int)+0x80>)
     f0a:	str	r3, [sp, #4]
     f0c:	mov.w	r2, #1000	; 0x3e8
     f10:	movs	r3, #0
     f12:	strb.w	r3, [sp, #8]
     f16:	str	r2, [sp, #12]
     f18:	strb.w	r3, [sp, #16]
     f1c:	str	r3, [sp, #20]
uint16_t store[16];

extern  int t_acq;

void storeConfig(uint16_t *store, int ns)
{ 
     f1e:	mov	r5, r0
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    char text[32];
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
     f20:	movs	r3, #2
uint16_t store[16];

extern  int t_acq;

void storeConfig(uint16_t *store, int ns)
{ 
     f22:	mov	r6, r1
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    char text[32];
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
     f24:	ldr	r2, [pc, #96]	; (f88 <storeConfig(unsigned short*, int)+0x84>)
     f26:	ldr	r1, [pc, #100]	; (f8c <storeConfig(unsigned short*, int)+0x88>)
     f28:	add	r0, sp, #24
     f2a:	bl	e8c <SDClass::open(char const*, unsigned char)>
	}
#ifdef FILE_USE_MOVE
	// Move assignment.
	File& operator = (const File&& file) {
		//Serial.println("File move assignment");
		if (file.f) file.f->refcount++;
     f2e:	ldr	r3, [sp, #40]	; 0x28
     f30:	cbz	r3, f38 <storeConfig(unsigned short*, int)+0x34>
     f32:	ldr	r2, [r3, #4]
     f34:	adds	r2, #1
     f36:	str	r2, [r3, #4]
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
     f38:	ldr	r3, [sp, #20]
     f3a:	cbz	r3, f42 <storeConfig(unsigned short*, int)+0x3e>
     f3c:	add	r0, sp, #20
     f3e:	bl	9d0 <File::dec_refcount() [clone .isra.15]>
		f = file.f;
     f42:	ldr	r3, [sp, #40]	; 0x28
     f44:	str	r3, [sp, #20]
     f46:	add	r0, sp, #24
     f48:	bl	9f4 <File::~File()>
      for(int ii=0; ii<ns; ii++)
     f4c:	movs	r4, #0
     f4e:	cmp	r4, r6
     f50:	bge.n	f72 <storeConfig(unsigned short*, int)+0x6e>
      { sprintf(text,"%10d\r\n",(int) store[ii]); configFile.write((uint8_t*)text,strlen(text)); }
     f52:	ldrh.w	r2, [r5, r4, lsl #1]
     f56:	ldr	r1, [pc, #56]	; (f90 <storeConfig(unsigned short*, int)+0x8c>)
     f58:	add	r0, sp, #24
     f5a:	bl	b668 <sprintf>
     f5e:	add	r0, sp, #24
     f60:	bl	b740 <strlen>
     f64:	add	r1, sp, #24
     f66:	mov	r2, r0
     f68:	add	r0, sp, #4
     f6a:	bl	812 <File::write(unsigned char const*, unsigned int)>
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    char text[32];
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
      for(int ii=0; ii<ns; ii++)
     f6e:	adds	r4, #1
     f70:	b.n	f4e <storeConfig(unsigned short*, int)+0x4a>
      { sprintf(text,"%10d\r\n",(int) store[ii]); configFile.write((uint8_t*)text,strlen(text)); }
    configFile.close();
     f72:	add	r0, sp, #4
     f74:	bl	dac <File::close()>

void storeConfig(uint16_t *store, int ns)
{ 
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
     f78:	add	r0, sp, #4
     f7a:	bl	9f4 <File::~File()>
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
      for(int ii=0; ii<ns; ii++)
      { sprintf(text,"%10d\r\n",(int) store[ii]); configFile.write((uint8_t*)text,strlen(text)); }
    configFile.close();
  
}
     f7e:	add	sp, #56	; 0x38
     f80:	pop	{r4, r5, r6, pc}
     f82:	nop
     f84:	.word	0x00011d20
     f88:	.word	0x00011da0
     f8c:	.word	0x1fff2468
     f90:	.word	0x00011dac

00000f94 <saveParameters()>:
    configFile.close();
}

void saveParameters(void)
{
  store[0]= 1;
     f94:	ldr	r0, [pc, #16]	; (fa8 <saveParameters()+0x14>)
     f96:	movs	r3, #1
     f98:	strh	r3, [r0, #0]
  store[2]= t_acq;
     f9a:	ldr	r3, [pc, #16]	; (fac <saveParameters()+0x18>)

  storeConfig(store, 16);
     f9c:	movs	r1, #16
}

void saveParameters(void)
{
  store[0]= 1;
  store[2]= t_acq;
     f9e:	ldr	r3, [r3, #0]
     fa0:	strh	r3, [r0, #4]

  storeConfig(store, 16);
     fa2:	b.w	f04 <storeConfig(unsigned short*, int)>
     fa6:	nop
     fa8:	.word	0x1fff21f2
     fac:	.word	0x1fff0f38

00000fb0 <printMenu()>:
  }
}


void printMenu(void)
{
     fb0:	push	{r4, lr}
  Serial.println("\n Menu");
     fb2:	ldr	r4, [pc, #144]	; (1044 <printMenu()+0x94>)
     fb4:	ldr	r1, [pc, #144]	; (1048 <printMenu()+0x98>)
     fb6:	mov	r0, r4
     fb8:	bl	6b8 <Print::println(char const*)>
  Serial.println(" ':h'  : print help");
     fbc:	ldr	r1, [pc, #140]	; (104c <printMenu()+0x9c>)
     fbe:	mov	r0, r4
     fc0:	bl	6b8 <Print::println(char const*)>
  Serial.println(" ':s'  : start acquisition");
     fc4:	ldr	r1, [pc, #136]	; (1050 <printMenu()+0xa0>)
     fc6:	mov	r0, r4
     fc8:	bl	6b8 <Print::println(char const*)>
  Serial.println(" ':e'  : stop acquisition");
     fcc:	ldr	r1, [pc, #132]	; (1054 <printMenu()+0xa4>)
     fce:	mov	r0, r4
     fd0:	bl	6b8 <Print::println(char const*)>
  Serial.println(" ':w'  : write parameters to microSD card");
     fd4:	ldr	r1, [pc, #128]	; (1058 <printMenu()+0xa8>)
     fd6:	mov	r0, r4
     fd8:	bl	6b8 <Print::println(char const*)>
  Serial.println(" ':l'  : list disks");
     fdc:	ldr	r1, [pc, #124]	; (105c <printMenu()+0xac>)
     fde:	mov	r0, r4
     fe0:	bl	6b8 <Print::println(char const*)>
  Serial.println(" ':r'  : reset MTP");
     fe4:	ldr	r1, [pc, #120]	; (1060 <printMenu()+0xb0>)
     fe6:	mov	r0, r4
     fe8:	bl	6b8 <Print::println(char const*)>
  Serial.println(" ':b'  : reboot CPU");
     fec:	ldr	r1, [pc, #116]	; (1064 <printMenu()+0xb4>)
     fee:	mov	r0, r4
     ff0:	bl	6b8 <Print::println(char const*)>
//  Serial.println(" ':d'  : dump Index List (testing)");
  Serial.println();
     ff4:	mov	r0, r4
     ff6:	bl	99ac <Print::println()>
  Serial.println(" '?p'  : show all parameters");
     ffa:	ldr	r1, [pc, #108]	; (1068 <printMenu()+0xb8>)
     ffc:	mov	r0, r4
     ffe:	bl	6b8 <Print::println(char const*)>
  Serial.println(" '?d'  : get date");
    1002:	ldr	r1, [pc, #104]	; (106c <printMenu()+0xbc>)
    1004:	mov	r0, r4
    1006:	bl	6b8 <Print::println(char const*)>
  Serial.println(" '?t'  : get time");
    100a:	ldr	r1, [pc, #100]	; (1070 <printMenu()+0xc0>)
    100c:	mov	r0, r4
    100e:	bl	6b8 <Print::println(char const*)>
  Serial.println(" '?a'  : get file duration (s)");
    1012:	ldr	r1, [pc, #96]	; (1074 <printMenu()+0xc4>)
    1014:	mov	r0, r4
    1016:	bl	6b8 <Print::println(char const*)>
  Serial.println();
    101a:	mov	r0, r4
    101c:	bl	99ac <Print::println()>
  Serial.println(" '!d yyyy/mm/dd<cr>'  : set date");
    1020:	ldr	r1, [pc, #84]	; (1078 <printMenu()+0xc8>)
    1022:	mov	r0, r4
    1024:	bl	6b8 <Print::println(char const*)>
  Serial.println(" '!t hh:mm:ss<cr>'    : set time");
    1028:	ldr	r1, [pc, #80]	; (107c <printMenu()+0xcc>)
    102a:	mov	r0, r4
    102c:	bl	6b8 <Print::println(char const*)>
  Serial.println(" '!a val<cr>'  : set file duration (s)");
    1030:	mov	r0, r4
    1032:	ldr	r1, [pc, #76]	; (1080 <printMenu()+0xd0>)
    1034:	bl	6b8 <Print::println(char const*)>
  Serial.println();
    1038:	mov	r0, r4
}
    103a:	ldmia.w	sp!, {r4, lr}
  Serial.println(" '?a'  : get file duration (s)");
  Serial.println();
  Serial.println(" '!d yyyy/mm/dd<cr>'  : set date");
  Serial.println(" '!t hh:mm:ss<cr>'    : set time");
  Serial.println(" '!a val<cr>'  : set file duration (s)");
  Serial.println();
    103e:	b.w	99ac <Print::println()>
    1042:	nop
    1044:	.word	0x1fff1368
    1048:	.word	0x00011db3
    104c:	.word	0x00011dba
    1050:	.word	0x00011dce
    1054:	.word	0x00011de9
    1058:	.word	0x00011e03
    105c:	.word	0x00011e2d
    1060:	.word	0x00011e41
    1064:	.word	0x00011e54
    1068:	.word	0x00011e68
    106c:	.word	0x00011e85
    1070:	.word	0x00011e97
    1074:	.word	0x00011ea9
    1078:	.word	0x00011ec8
    107c:	.word	0x00011ee9
    1080:	.word	0x00011f0a

00001084 <printMenuEntries()>:
}

void printMenuEntries(void)
{
    1084:	push	{r0, r1, r2, r3, r4, lr}
    tmElements_t tm;
    breakTime(rtc_get(), tm);

  Serial.println("CVAS_V3 Version: " __DATE__  " " __TIME__ );
    1086:	ldr	r4, [pc, #96]	; (10e8 <printMenuEntries()+0x64>)
}

void printMenuEntries(void)
{
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    1088:	bl	8d18 <rtc_get>
    108c:	add	r1, sp, #8
    108e:	bl	1368 <breakTime(unsigned long, tmElements_t&)>

  Serial.println("CVAS_V3 Version: " __DATE__  " " __TIME__ );
    1092:	ldr	r1, [pc, #88]	; (10ec <printMenuEntries()+0x68>)
    1094:	mov	r0, r4
    1096:	bl	6b8 <Print::println(char const*)>
  Serial.printf("Teensy: %d: %06x\n",teensy,SerNum);
    109a:	ldr	r3, [pc, #84]	; (10f0 <printMenuEntries()+0x6c>)
    109c:	ldr	r1, [pc, #84]	; (10f4 <printMenuEntries()+0x70>)
    109e:	ldr	r3, [r3, #0]
    10a0:	movs	r2, #36	; 0x24
    10a2:	mov	r0, r4
    10a4:	bl	99cc <Print::printf(char const*, ...)>
  Serial.printf("Date d = %04d/%02d/%02d\n",tmYearToCalendar(tm.Year), tm.Month, tm.Day); 
    10a8:	ldrb.w	r2, [sp, #14]
    10ac:	ldrb.w	r1, [sp, #12]
    10b0:	ldrb.w	r3, [sp, #13]
    10b4:	str	r1, [sp, #0]
    10b6:	addw	r2, r2, #1970	; 0x7b2
    10ba:	ldr	r1, [pc, #60]	; (10f8 <printMenuEntries()+0x74>)
    10bc:	mov	r0, r4
    10be:	bl	99cc <Print::printf(char const*, ...)>
  Serial.printf("Time t = %02d:%02d:%02d\n",tm.Hour, tm.Minute, tm.Second); 
    10c2:	ldrb.w	r1, [sp, #8]
    10c6:	ldrb.w	r3, [sp, #9]
    10ca:	ldrb.w	r2, [sp, #10]
    10ce:	str	r1, [sp, #0]
    10d0:	mov	r0, r4
    10d2:	ldr	r1, [pc, #40]	; (10fc <printMenuEntries()+0x78>)
    10d4:	bl	99cc <Print::printf(char const*, ...)>
  Serial.printf("T_acq a = %d\n",t_acq); 
    10d8:	ldr	r3, [pc, #36]	; (1100 <printMenuEntries()+0x7c>)
    10da:	ldr	r1, [pc, #40]	; (1104 <printMenuEntries()+0x80>)
    10dc:	ldr	r2, [r3, #0]
    10de:	mov	r0, r4
    10e0:	bl	99cc <Print::printf(char const*, ...)>
}
    10e4:	add	sp, #16
    10e6:	pop	{r4, pc}
    10e8:	.word	0x1fff1368
    10ec:	.word	0x00011f31
    10f0:	.word	0x1fff7eb8
    10f4:	.word	0x00011f57
    10f8:	.word	0x00011f69
    10fc:	.word	0x00011f82
    1100:	.word	0x1fff0f38
    1104:	.word	0x00011f9b

00001108 <menuGetInt(int*)>:

int menuGetInt(int *val)
{ char buffer[40];
    1108:	push	{r4, lr}
    110a:	mov	r4, r0
    110c:	sub	sp, #40	; 0x28
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    110e:	bl	89a4 <usb_serial_available>
  while(!Serial.available());
    1112:	cmp	r0, #0
    1114:	beq.n	110e <menuGetInt(int*)+0x6>
  int count = Serial.readBytesUntil('\r',buffer,40);
    1116:	mov	r2, sp
    1118:	movs	r3, #40	; 0x28
    111a:	movs	r1, #13
    111c:	ldr	r0, [pc, #28]	; (113c <menuGetInt(int*)+0x34>)
    111e:	bl	9bd0 <Stream::readBytesUntil(char, char*, unsigned int)>
  buffer[count]=0;
    1122:	add	r3, sp, #40	; 0x28
    1124:	add	r0, r3
    1126:	movs	r3, #0
    1128:	strb.w	r3, [r0, #-40]
//  Serial.println(buffer);
  return sscanf(buffer,"%d",val);
    112c:	mov	r2, r4
    112e:	ldr	r1, [pc, #16]	; (1140 <menuGetInt(int*)+0x38>)
    1130:	mov	r0, sp
    1132:	bl	b6b4 <sscanf>
}
    1136:	add	sp, #40	; 0x28
    1138:	pop	{r4, pc}
    113a:	nop
    113c:	.word	0x1fff1368
    1140:	.word	0x00012054

00001144 <menuGet3Int(int*, int*, int*)>:

int menuGet3Int(int *val1, int *val2, int *val3)
{ char buffer[40];
    1144:	push	{r4, r5, r6, lr}
    1146:	mov	r4, r0
    1148:	sub	sp, #64	; 0x40
    114a:	mov	r5, r1
    114c:	mov	r6, r2
    114e:	bl	89a4 <usb_serial_available>
  while(!Serial.available());
    1152:	cmp	r0, #0
    1154:	beq.n	114e <menuGet3Int(int*, int*, int*)+0xa>
  int count = Serial.readBytesUntil('\r',buffer,40);
    1156:	add	r2, sp, #24
    1158:	movs	r3, #40	; 0x28
    115a:	movs	r1, #13
    115c:	ldr	r0, [pc, #40]	; (1188 <menuGet3Int(int*, int*, int*)+0x44>)
    115e:	bl	9bd0 <Stream::readBytesUntil(char, char*, unsigned int)>
  buffer[count]=0;
    1162:	add	r3, sp, #64	; 0x40
    1164:	add	r0, r3
    1166:	movs	r3, #0
    1168:	strb.w	r3, [r0, #-40]
//  Serial.println(buffer);
  char c1,c2;
  return sscanf(buffer,"%d%c%d%c%d",val1,&c1,val2,&c2,val3);
    116c:	add.w	r3, sp, #23
    1170:	str	r3, [sp, #4]
    1172:	str	r6, [sp, #8]
    1174:	str	r5, [sp, #0]
    1176:	add.w	r3, sp, #22
    117a:	mov	r2, r4
    117c:	ldr	r1, [pc, #12]	; (118c <menuGet3Int(int*, int*, int*)+0x48>)
    117e:	add	r0, sp, #24
    1180:	bl	b6b4 <sscanf>
}
    1184:	add	sp, #64	; 0x40
    1186:	pop	{r4, r5, r6, pc}
    1188:	.word	0x1fff1368
    118c:	.word	0x00011fa9

00001190 <menu()>:
#if defined (KINETISK) 
#define CPU_RESTART 
#endif

int16_t menu(void)
{
    1190:	push	{r4, lr}
    1192:	sub	sp, #32
    1194:	bl	89a4 <usb_serial_available>
  if(!Serial.available()) return 0;
    1198:	cmp	r0, #0
    119a:	beq.w	1318 <menu()+0x188>
        virtual int read() { return usb_serial_getchar(); }
    119e:	bl	8920 <usb_serial_getchar>

  char ch=Serial.read();
    11a2:	uxtb	r0, r0
  if(ch==':')
    11a4:	cmp	r0, #58	; 0x3a
    11a6:	bne.n	1228 <menu()+0x98>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    11a8:	bl	89a4 <usb_serial_available>
  { while(!Serial.available()) ; ch=Serial.read();
    11ac:	cmp	r0, #0
    11ae:	beq.n	11a8 <menu()+0x18>
        virtual int read() { return usb_serial_getchar(); }
    11b0:	bl	8920 <usb_serial_getchar>
    11b4:	uxtb	r0, r0

    if(ch=='s') { Serial.print("\n"); Serial.print("start"); return  +1;} // start acq
    11b6:	cmp	r0, #115	; 0x73
    11b8:	bne.n	11ce <menu()+0x3e>
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
    11ba:	ldr	r1, [pc, #356]	; (1320 <menu()+0x190>)
    11bc:	ldr	r0, [pc, #356]	; (1324 <menu()+0x194>)
    11be:	bl	a54 <Print::write(char const*)>
    11c2:	ldr	r1, [pc, #356]	; (1328 <menu()+0x198>)
    11c4:	ldr	r0, [pc, #348]	; (1324 <menu()+0x194>)
    11c6:	bl	a54 <Print::write(char const*)>
    11ca:	movs	r0, #1
    11cc:	b.n	131a <menu()+0x18a>
    else if(ch=='e') { Serial.print("\n"); Serial.print("stop");  return  -1;} // end acq
    11ce:	cmp	r0, #101	; 0x65
    11d0:	bne.n	11e8 <menu()+0x58>
    11d2:	ldr	r1, [pc, #332]	; (1320 <menu()+0x190>)
    11d4:	ldr	r0, [pc, #332]	; (1324 <menu()+0x194>)
    11d6:	bl	a54 <Print::write(char const*)>
    11da:	ldr	r1, [pc, #336]	; (132c <menu()+0x19c>)
    11dc:	ldr	r0, [pc, #324]	; (1324 <menu()+0x194>)
    11de:	bl	a54 <Print::write(char const*)>
    11e2:	mov.w	r0, #4294967295
    11e6:	b.n	131a <menu()+0x18a>
    else if(ch=='h') { printMenu(); return 0;} 
    11e8:	cmp	r0, #104	; 0x68
    11ea:	bne.n	11f2 <menu()+0x62>
    11ec:	bl	fb0 <printMenu()>
    11f0:	b.n	1318 <menu()+0x188>
    else if(ch=='w') { saveParameters(); return 0;} 
    11f2:	cmp	r0, #119	; 0x77
    11f4:	bne.n	11fc <menu()+0x6c>
    11f6:	bl	f94 <saveParameters()>
    11fa:	b.n	1318 <menu()+0x188>
    else if(ch=='l') { listDisks(); return 0;} 
    11fc:	cmp	r0, #108	; 0x6c
    11fe:	bne.n	1206 <menu()+0x76>
    1200:	bl	1c58 <listDisks()>
    1204:	b.n	1318 <menu()+0x188>
    else if(ch=='b') { Serial.print("\n"); Serial.print("rebooting CPU"); Serial.flush(); delay(100); CPU_RESTART; return 0;} 
    1206:	cmp	r0, #98	; 0x62
    1208:	bne.w	1318 <menu()+0x188>
    120c:	ldr	r1, [pc, #272]	; (1320 <menu()+0x190>)
    120e:	ldr	r0, [pc, #276]	; (1324 <menu()+0x194>)
    1210:	bl	a54 <Print::write(char const*)>
    1214:	ldr	r1, [pc, #280]	; (1330 <menu()+0x1a0>)
    1216:	ldr	r0, [pc, #268]	; (1324 <menu()+0x194>)
    1218:	bl	a54 <Print::write(char const*)>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    121c:	bl	8b30 <usb_serial_flush_output>
    1220:	movs	r0, #100	; 0x64
    1222:	bl	8de8 <delay>
    1226:	b.n	1318 <menu()+0x188>
  }
  else if(ch=='?') // get info
    1228:	cmp	r0, #63	; 0x3f
    122a:	bne.n	1296 <menu()+0x106>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    122c:	bl	89a4 <usb_serial_available>
  {
    while(!Serial.available()) ; ch=Serial.read();
    1230:	cmp	r0, #0
    1232:	beq.n	122c <menu()+0x9c>
        virtual int read() { return usb_serial_getchar(); }
    1234:	bl	8920 <usb_serial_getchar>
    1238:	uxtb	r4, r0

    tmElements_t tm;
    breakTime(rtc_get(), tm);
    123a:	bl	8d18 <rtc_get>
    123e:	add	r1, sp, #24
    1240:	bl	1368 <breakTime(unsigned long, tmElements_t&)>

    if(ch=='p') { printMenuEntries(); return 0;} 
    1244:	cmp	r4, #112	; 0x70
    1246:	bne.n	124e <menu()+0xbe>
    1248:	bl	1084 <printMenuEntries()>
    124c:	b.n	1318 <menu()+0x188>
    else if(ch=='d') { Serial.printf("%04d/%02d/%02d\n",tmYearToCalendar(tm.Year), tm.Month, tm.Day); return  0;} // display date
    124e:	cmp	r4, #100	; 0x64
    1250:	bne.n	1268 <menu()+0xd8>
    1252:	ldrb.w	r2, [sp, #30]
    1256:	ldrb.w	r1, [sp, #28]
    125a:	str	r1, [sp, #0]
    125c:	ldrb.w	r3, [sp, #29]
    1260:	ldr	r1, [pc, #208]	; (1334 <menu()+0x1a4>)
    1262:	addw	r2, r2, #1970	; 0x7b2
    1266:	b.n	127c <menu()+0xec>
    else if(ch=='t') { Serial.printf("%02d:%02d:%02d\n",tm.Hour, tm.Minute, tm.Second); return  0;} // display time
    1268:	cmp	r4, #116	; 0x74
    126a:	bne.n	1284 <menu()+0xf4>
    126c:	ldrb.w	r1, [sp, #24]
    1270:	str	r1, [sp, #0]
    1272:	ldrb.w	r3, [sp, #25]
    1276:	ldrb.w	r2, [sp, #26]
    127a:	ldr	r1, [pc, #188]	; (1338 <menu()+0x1a8>)
    127c:	ldr	r0, [pc, #164]	; (1324 <menu()+0x194>)
    127e:	bl	99cc <Print::printf(char const*, ...)>
    1282:	b.n	1318 <menu()+0x188>
    else if(ch=='a') { Serial.printf("%d\n",t_acq); return  0;} // file size
    1284:	cmp	r4, #97	; 0x61
    1286:	bne.n	1318 <menu()+0x188>
    1288:	ldr	r3, [pc, #176]	; (133c <menu()+0x1ac>)
    128a:	ldr	r1, [pc, #180]	; (1340 <menu()+0x1b0>)
    128c:	ldr	r2, [r3, #0]
    128e:	ldr	r0, [pc, #148]	; (1324 <menu()+0x194>)
    1290:	bl	99cc <Print::printf(char const*, ...)>
    1294:	b.n	1318 <menu()+0x188>
  }
  else if(ch=='!') // set 
    1296:	cmp	r0, #33	; 0x21
    1298:	bne.n	1318 <menu()+0x188>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    129a:	bl	89a4 <usb_serial_available>
  { 
    while(!Serial.available()) ;
    129e:	cmp	r0, #0
    12a0:	beq.n	129a <menu()+0x10a>
        virtual int read() { return usb_serial_getchar(); }
    12a2:	bl	8920 <usb_serial_getchar>
    ch=Serial.read();
    12a6:	uxtb	r0, r0
    if(ch=='d') // set date
    12a8:	cmp	r0, #100	; 0x64
    12aa:	bne.n	12d8 <menu()+0x148>
    { int year,month,day;
      menuGet3Int(&year,&month,&day);
    12ac:	add	r2, sp, #20
    12ae:	add	r1, sp, #16
    12b0:	add	r0, sp, #12
    12b2:	bl	1144 <menuGet3Int(int*, int*, int*)>
      tmElements_t tm;
      breakTime(rtc_get(), tm);
    12b6:	bl	8d18 <rtc_get>
    12ba:	add	r1, sp, #24
    12bc:	bl	1368 <breakTime(unsigned long, tmElements_t&)>

      setRTCTime(tm.Hour, tm.Minute, tm.Second, day, month, year);
    12c0:	ldr	r3, [sp, #12]
    12c2:	str	r3, [sp, #4]
    12c4:	ldr	r3, [sp, #16]
    12c6:	str	r3, [sp, #0]
    12c8:	ldrb.w	r2, [sp, #24]
    12cc:	ldrb.w	r1, [sp, #25]
    12d0:	ldrb.w	r0, [sp, #26]
    12d4:	ldr	r3, [sp, #20]
    12d6:	b.n	1308 <menu()+0x178>
      return  0;
    } 
    else if(ch=='t') // set time
    12d8:	cmp	r0, #116	; 0x74
    12da:	bne.n	130e <menu()+0x17e>
    { int hour,minutes,seconds;
      menuGet3Int(&hour,&minutes,&seconds);
    12dc:	add	r2, sp, #20
    12de:	add	r1, sp, #16
    12e0:	add	r0, sp, #12
    12e2:	bl	1144 <menuGet3Int(int*, int*, int*)>

      tmElements_t tm;
      breakTime(rtc_get(), tm);
    12e6:	bl	8d18 <rtc_get>
    12ea:	add	r1, sp, #24
    12ec:	bl	1368 <breakTime(unsigned long, tmElements_t&)>
      setRTCTime(hour, minutes, seconds, tm.Day, tm.Month, tmYearToCalendar(tm.Year));
    12f0:	ldrb.w	r2, [sp, #30]
    12f4:	ldrb.w	r3, [sp, #28]
    12f8:	addw	r2, r2, #1970	; 0x7b2
    12fc:	str	r2, [sp, #4]
    12fe:	ldrb.w	r2, [sp, #29]
    1302:	str	r2, [sp, #0]
    1304:	add	r0, sp, #12
    1306:	ldmia	r0, {r0, r1, r2}
    1308:	bl	1554 <setRTCTime(int, int, int, int, int, int)>
    130c:	b.n	1318 <menu()+0x188>
      return  0;
    } 
    else if(ch=='a') { menuGetInt(&t_acq); return  0;} // file size
    130e:	cmp	r0, #97	; 0x61
    1310:	bne.n	1318 <menu()+0x188>
    1312:	ldr	r0, [pc, #40]	; (133c <menu()+0x1ac>)
    1314:	bl	1108 <menuGetInt(int*)>
    1318:	movs	r0, #0
  }
  return 0;
}
    131a:	add	sp, #32
    131c:	pop	{r4, pc}
    131e:	nop
    1320:	.word	0x00012580
    1324:	.word	0x1fff1368
    1328:	.word	0x00011fb4
    132c:	.word	0x00011fba
    1330:	.word	0x00011fbf
    1334:	.word	0x00011f72
    1338:	.word	0x00011f8b
    133c:	.word	0x1fff0f38
    1340:	.word	0x00011fa5

00001344 <newHour()>:
    return 1;
}

int32_t hour_ = 0;
int16_t newHour(void)
{   uint32_t tx=rtc_get();
    1344:	push	{r3, lr}
    1346:	bl	8d18 <rtc_get>
    int32_t h_ = (int32_t) tx/SECS_PER_HOUR;  // use hours since 1970 as measures
    134a:	mov.w	r3, #3600	; 0xe10
    134e:	udiv	r0, r0, r3
    if(hour_== h_) return 0;
    1352:	ldr	r3, [pc, #16]	; (1364 <newHour()+0x20>)
    1354:	ldr	r2, [r3, #0]
    1356:	cmp	r0, r2
    hour_ = h_;
    1358:	itte	ne
    135a:	strne	r0, [r3, #0]
    return 1;
    135c:	movne	r0, #1

int32_t hour_ = 0;
int16_t newHour(void)
{   uint32_t tx=rtc_get();
    int32_t h_ = (int32_t) tx/SECS_PER_HOUR;  // use hours since 1970 as measures
    if(hour_== h_) return 0;
    135e:	moveq	r0, #0
    hour_ = h_;
    return 1;
}
    1360:	pop	{r3, pc}
    1362:	nop
    1364:	.word	0x1fff2214

00001368 <breakTime(unsigned long, tmElements_t&)>:
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    1368:	movs	r3, #60	; 0x3c
/* functions to convert to and from system time */
/* These are for interfacing with time services and are not normally needed in a sketch */

static  const uint8_t monthDays[]={31,28,31,30,31,30,31,31,30,31,30,31}; // API starts months from 1, this array starts from 0
 
void breakTime(uint32_t timeInput, tmElements_t &tm){
    136a:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    136e:	udiv	r4, r0, r3
    1372:	mls	r2, r3, r4, r0
    1376:	strb	r2, [r1, #0]
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    1378:	udiv	r2, r4, r3
    137c:	mls	r3, r3, r2, r4
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    1380:	movs	r4, #24
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    1382:	strb	r3, [r1, #1]
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    1384:	mov.w	r3, #3600	; 0xe10
    1388:	udiv	r3, r0, r3
    138c:	udiv	r2, r3, r4
    1390:	mls	r3, r4, r2, r3
    1394:	strb	r3, [r1, #2]
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    1396:	movs	r2, #7
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
    1398:	ldr	r3, [pc, #240]	; (148c <breakTime(unsigned long, tmElements_t&)+0x124>)
    139a:	udiv	r0, r0, r3
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    139e:	adds	r3, r0, #4
    13a0:	udiv	r2, r3, r2
    13a4:	rsb	r2, r2, r2, lsl #3
    13a8:	subs	r3, r3, r2
    13aa:	adds	r3, #1
    13ac:	movs	r4, #0
    13ae:	strb	r3, [r1, #3]
  
  year = 0;  
  days = 0;
    13b0:	mov	r2, r4
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    13b2:	movw	r8, #365	; 0x16d
    13b6:	mov.w	lr, #100	; 0x64
    13ba:	mov.w	ip, #400	; 0x190
    13be:	uxtb	r6, r4
    13c0:	addw	r3, r6, #1970	; 0x7b2
    13c4:	ands.w	r7, r3, #3
    13c8:	bne.n	13e8 <breakTime(unsigned long, tmElements_t&)+0x80>
    13ca:	sdiv	r5, r3, lr
    13ce:	mls	r5, lr, r5, r3
    13d2:	cbnz	r5, 13ee <breakTime(unsigned long, tmElements_t&)+0x86>
    13d4:	sdiv	r5, r3, ip
    13d8:	mls	r5, ip, r5, r3
    13dc:	cmp	r5, #0
    13de:	ite	ne
    13e0:	movne	r5, r8
    13e2:	moveq.w	r5, #366	; 0x16e
    13e6:	b.n	13f2 <breakTime(unsigned long, tmElements_t&)+0x8a>
    13e8:	movw	r5, #365	; 0x16d
    13ec:	b.n	13f2 <breakTime(unsigned long, tmElements_t&)+0x8a>
    13ee:	mov.w	r5, #366	; 0x16e
    13f2:	add	r2, r5
    13f4:	cmp	r0, r2
    13f6:	add.w	r4, r4, #1
    13fa:	bcs.n	13be <breakTime(unsigned long, tmElements_t&)+0x56>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
    13fc:	strb	r6, [r1, #6]
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    13fe:	cbnz	r7, 1426 <breakTime(unsigned long, tmElements_t&)+0xbe>
    1400:	movs	r5, #100	; 0x64
    1402:	sdiv	r4, r3, r5
    1406:	mls	r4, r5, r4, r3
    140a:	cbnz	r4, 142c <breakTime(unsigned long, tmElements_t&)+0xc4>
    140c:	mov.w	r5, #400	; 0x190
    1410:	sdiv	r4, r3, r5
    1414:	mls	r4, r5, r4, r3
    1418:	cmp	r4, #0
    141a:	movw	r4, #365	; 0x16d
    141e:	it	eq
    1420:	moveq.w	r4, #366	; 0x16e
    1424:	b.n	1430 <breakTime(unsigned long, tmElements_t&)+0xc8>
    1426:	movw	r4, #365	; 0x16d
    142a:	b.n	1430 <breakTime(unsigned long, tmElements_t&)+0xc8>
    142c:	mov.w	r4, #366	; 0x16e
  time  -= days; // now it is days in this year, starting at 0
    1430:	subs	r2, r2, r4
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    1432:	movs	r6, #100	; 0x64
    1434:	mov.w	r4, #400	; 0x190
        monthLength=29;
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    1438:	ldr.w	lr, [pc, #84]	; 1490 <breakTime(unsigned long, tmElements_t&)+0x128>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
  time  -= days; // now it is days in this year, starting at 0
    143c:	subs	r0, r0, r2
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    143e:	sdiv	r2, r3, r6
    1442:	mls	r6, r6, r2, r3
    1446:	sdiv	r2, r3, r4
    144a:	mls	r3, r4, r2, r3
    144e:	movs	r2, #0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
    1450:	cmp	r2, #1
    1452:	uxtb	r5, r2
    1454:	bne.n	1464 <breakTime(unsigned long, tmElements_t&)+0xfc>
      if (LEAP_YEAR(year)) {
    1456:	cbnz	r7, 146a <breakTime(unsigned long, tmElements_t&)+0x102>
    1458:	cbnz	r6, 146e <breakTime(unsigned long, tmElements_t&)+0x106>
        monthLength=29;
    145a:	cmp	r3, #0
    145c:	ite	ne
    145e:	movne	r4, #28
    1460:	moveq	r4, #29
    1462:	b.n	1470 <breakTime(unsigned long, tmElements_t&)+0x108>
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    1464:	ldrb.w	r4, [r2, lr]
    1468:	b.n	1470 <breakTime(unsigned long, tmElements_t&)+0x108>
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
        monthLength=29;
      } else {
        monthLength=28;
    146a:	movs	r4, #28
    146c:	b.n	1470 <breakTime(unsigned long, tmElements_t&)+0x108>
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
        monthLength=29;
    146e:	movs	r4, #29
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    1470:	cmp	r4, r0
    1472:	bhi.n	1480 <breakTime(unsigned long, tmElements_t&)+0x118>
    1474:	adds	r2, #1
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    1476:	cmp	r2, #12
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
      time -= monthLength;
    1478:	sub.w	r0, r0, r4
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    147c:	bne.n	1450 <breakTime(unsigned long, tmElements_t&)+0xe8>
    147e:	mov	r5, r2
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    1480:	adds	r5, #1
  tm.Day = time + 1;     // day of month
    1482:	adds	r0, #1
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    1484:	strb	r5, [r1, #5]
  tm.Day = time + 1;     // day of month
    1486:	strb	r0, [r1, #4]
    1488:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    148c:	.word	0x00015180
    1490:	.word	0x00011fcd

00001494 <makeTime(tmElements_t const&)>:
}

uint32_t makeTime(const tmElements_t &tm){   
    1494:	push	{r4, r5, r6, r7, lr}
  
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
    1496:	ldr	r3, [pc, #176]	; (1548 <makeTime(tmElements_t const&)+0xb4>)
    1498:	ldrb	r2, [r0, #6]
    149a:	movw	r1, #1970	; 0x7b2
    149e:	muls	r3, r2
  for (i = 0; i < tm.Year; i++) {
    if (LEAP_YEAR(i)) {
    14a0:	movs	r5, #100	; 0x64
    14a2:	mov.w	r6, #400	; 0x190
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
  for (i = 0; i < tm.Year; i++) {
    14a6:	subw	r4, r1, #1970	; 0x7b2
    14aa:	cmp	r2, r4
    14ac:	ble.n	14d2 <makeTime(tmElements_t const&)+0x3e>
    if (LEAP_YEAR(i)) {
    14ae:	lsls	r4, r1, #30
    14b0:	bne.n	14ce <makeTime(tmElements_t const&)+0x3a>
    14b2:	sdiv	r4, r1, r5
    14b6:	mls	r4, r5, r4, r1
    14ba:	cbnz	r4, 14c6 <makeTime(tmElements_t const&)+0x32>
    14bc:	sdiv	r4, r1, r6
    14c0:	mls	r4, r6, r4, r1
    14c4:	cbnz	r4, 14ce <makeTime(tmElements_t const&)+0x3a>
      seconds += SECS_PER_DAY;   // add extra days for leap years
    14c6:	add.w	r3, r3, #86016	; 0x15000
    14ca:	add.w	r3, r3, #384	; 0x180
    14ce:	adds	r1, #1
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
  for (i = 0; i < tm.Year; i++) {
    14d0:	b.n	14a6 <makeTime(tmElements_t const&)+0x12>
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    14d2:	addw	r2, r2, #1970	; 0x7b2
    14d6:	movs	r4, #100	; 0x64
    14d8:	mov.w	r5, #400	; 0x190
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    14dc:	ldrb	r6, [r0, #5]
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
      seconds += SECS_PER_DAY * 29;
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    14de:	ldr	r7, [pc, #108]	; (154c <makeTime(tmElements_t const&)+0xb8>)
    14e0:	ldr.w	lr, [pc, #108]	; 1550 <makeTime(tmElements_t const&)+0xbc>
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    14e4:	sdiv	r1, r2, r4
    14e8:	mls	r4, r4, r1, r2
    14ec:	sdiv	r1, r2, r5
    14f0:	mls	r5, r5, r1, r2
    14f4:	movs	r1, #1
    14f6:	and.w	r2, r2, #3
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    14fa:	cmp	r6, r1
    14fc:	ble.n	1522 <makeTime(tmElements_t const&)+0x8e>
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    14fe:	cmp	r1, #2
    1500:	bne.n	1512 <makeTime(tmElements_t const&)+0x7e>
    1502:	cbnz	r2, 1512 <makeTime(tmElements_t const&)+0x7e>
    1504:	cbnz	r4, 1508 <makeTime(tmElements_t const&)+0x74>
    1506:	cbnz	r5, 1512 <makeTime(tmElements_t const&)+0x7e>
      seconds += SECS_PER_DAY * 29;
    1508:	add.w	r3, r3, #2490368	; 0x260000
    150c:	add.w	r3, r3, #15232	; 0x3b80
    1510:	b.n	151e <makeTime(tmElements_t const&)+0x8a>
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    1512:	add.w	ip, r7, r1
    1516:	ldrb.w	ip, [ip, #-1]
    151a:	mla	r3, lr, ip, r3
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    151e:	adds	r1, #1
    1520:	b.n	14fa <makeTime(tmElements_t const&)+0x66>
  }
  seconds+= (tm.Day-1) * SECS_PER_DAY;
  seconds+= tm.Hour * SECS_PER_HOUR;
  seconds+= tm.Minute * SECS_PER_MIN;
  seconds+= tm.Second;
  return seconds; 
    1522:	ldrb	r2, [r0, #1]
    1524:	ldrb	r1, [r0, #2]
    1526:	rsb	r2, r2, r2, lsl #4
    152a:	mov.w	r4, #3600	; 0xe10
    152e:	lsls	r2, r2, #2
    1530:	mla	r2, r4, r1, r2
    1534:	ldrb	r1, [r0, #0]
    1536:	add	r2, r1
    1538:	ldrb	r1, [r0, #4]
    153a:	ldr	r0, [pc, #20]	; (1550 <makeTime(tmElements_t const&)+0xbc>)
    153c:	subs	r1, #1
    153e:	mla	r0, r0, r1, r2
}
    1542:	add	r0, r3
    1544:	pop	{r4, r5, r6, r7, pc}
    1546:	nop
    1548:	.word	0x01e13380
    154c:	.word	0x00011fcd
    1550:	.word	0x00015180

00001554 <setRTCTime(int, int, int, int, int, int)>:

extern "C" void rtc_set(uint32_t tt);

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
    1554:	push	{r0, r1, r4, lr}
    1556:	ldr	r4, [sp, #20]
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
    1558:	strb.w	r0, [sp, #2]
extern "C" void rtc_set(uint32_t tt);

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
 // year can be given as full four digit year or two digts (2010 or 10 for 2010);  
 // it is converted to years since 1970
  if( yr > 99)
    155c:	cmp	r4, #99	; 0x63
  tm.Year = yr;
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;
    155e:	add	r0, sp, #8

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
 // year can be given as full four digit year or two digts (2010 or 10 for 2010);  
 // it is converted to years since 1970
  if( yr > 99)
      yr = yr - 1970;
    1560:	ite	gt
    1562:	subwgt	r4, r4, #1970	; 0x7b2
  else
      yr += 30;  
    1566:	addle	r4, #30
  
  tmElements_t tm;
  tm.Year = yr;
    1568:	strb.w	r4, [sp, #6]
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;
    156c:	strb.w	r2, [r0, #-8]!
  else
      yr += 30;  
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
    1570:	ldr	r4, [sp, #16]
  tm.Day = dy;
    1572:	strb.w	r3, [sp, #4]
  tm.Hour = hr;
  tm.Minute = min;
    1576:	strb.w	r1, [sp, #1]
  else
      yr += 30;  
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
    157a:	strb.w	r4, [sp, #5]
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;

  uint32_t tt = makeTime(tm);
    157e:	bl	1494 <makeTime(tmElements_t const&)>
  rtc_set(tt); // for RTC
    1582:	bl	8d24 <rtc_set>
}
    1586:	add	sp, #8
    1588:	pop	{r4, pc}

0000158a <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)>:
   * \param[out] dst Pointer to the location that will receive the data.
   * \param[in] callback Function to be called with each sector's data
   * \param[in] context Pointer to be passed to the callback function
   * \return true for success or false for failure.
   */
  virtual bool readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
    158a:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    158e:	ldr	r5, [sp, #32]
    1590:	mov	r7, r0
    1592:	mov	r6, r2
    1594:	add.w	r9, r3, r1
    1598:	mov	r4, r1
   void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
    159a:	cmp	r4, r9
    159c:	beq.n	15bc <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x32>
       if (!readSector(sector + i, dst)) return false;
    159e:	ldr	r3, [r7, #0]
    15a0:	mov	r2, r6
    15a2:	ldr	r3, [r3, #12]
    15a4:	mov	r1, r4
    15a6:	mov	r0, r7
    15a8:	blx	r3
    15aa:	add.w	r8, r4, #1
    15ae:	cbz	r0, 15be <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x34>
       callback(sector + i, dst, context);
    15b0:	mov	r0, r4
    15b2:	ldr	r2, [sp, #36]	; 0x24
    15b4:	mov	r1, r6
    15b6:	blx	r5
   * \param[in] context Pointer to be passed to the callback function
   * \return true for success or false for failure.
   */
  virtual bool readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
   void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
    15b8:	mov	r4, r8
    15ba:	b.n	159a <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x10>
       if (!readSector(sector + i, dst)) return false;
       callback(sector + i, dst, context);
     }
     return true;
    15bc:	movs	r0, #1
  }
    15be:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000015c2 <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)>:
   * \param[in] ns Number of sectors to be written.
   * \param[in] callback Function to be called for each sector's data
   * \param[in] context Context to pass to callback function
   * \return true for success or false for failure.
   */
  virtual bool writeSectorsCallback(uint32_t sector, size_t ns,
    15c2:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    15c6:	mov	r5, r0
    15c8:	mov	r7, r3
    15ca:	add.w	r8, r2, r1
    15ce:	mov	r4, r1
   const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
    15d0:	cmp	r4, r8
    15d2:	beq.n	15f0 <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x2e>
       if (!writeSector(sector + i, callback(sector + i, context))) return false;
    15d4:	ldr	r3, [r5, #0]
    15d6:	ldr	r1, [sp, #24]
    15d8:	ldr	r6, [r3, #32]
    15da:	mov	r0, r4
    15dc:	blx	r7
    15de:	mov	r1, r4
    15e0:	mov	r2, r0
    15e2:	mov	r0, r5
    15e4:	blx	r6
    15e6:	adds	r4, #1
    15e8:	cmp	r0, #0
    15ea:	bne.n	15d0 <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0xe>
    15ec:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     }
    return true;
    15f0:	movs	r0, #1
  }
    15f2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000015f6 <SdCardInterface::status()>:
   * \return The number of 512 byte data sectors in the card
   *         or zero if an error occurs.
   */
  virtual uint32_t sectorCount() = 0;
  /** \return card status. */
  virtual uint32_t status() {return 0XFFFFFFFF;}
    15f6:	mov.w	r0, #4294967295
    15fa:	bx	lr

000015fc <MySpiClass::activate()>:
    public:
        // Initialize the SPI bus.
        void begin(SdSpiConfig config) {  (void) config; SPI.begin(); }

        // Activate SPI hardware with correct speed and mode.
        void activate() { if(doTransactions) SPI.beginTransaction(m_spiSettings); }
    15fc:	ldrb	r3, [r0, #8]
    15fe:	push	{r4, r5, lr}
    1600:	cmp	r3, #0
    1602:	beq.n	1678 <MySpiClass::activate()+0x7c>

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    1604:	ldr	r3, [pc, #116]	; (167c <MySpiClass::activate()+0x80>)
    1606:	ldr	r2, [r0, #4]
    1608:	ldrb	r1, [r3, #11]
    160a:	cmp	r1, #0
    160c:	beq.n	1660 <MySpiClass::activate()+0x64>
			__disable_irq();
    160e:	cpsid	i
			if (interruptMasksUsed & 0x01) {
    1610:	ldrb	r1, [r3, #11]
    1612:	lsls	r1, r1, #31
    1614:	bpl.n	1622 <MySpiClass::activate()+0x26>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    1616:	ldr	r0, [pc, #104]	; (1680 <MySpiClass::activate()+0x84>)
    1618:	ldr	r1, [r3, #12]
    161a:	ldr	r4, [r0, #0]
    161c:	ands	r1, r4
    161e:	str	r1, [r3, #28]
				NVIC_ICER0 = interruptSave[0];
    1620:	str	r1, [r0, #0]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    1622:	ldrb	r1, [r3, #11]
    1624:	ldr	r4, [pc, #84]	; (167c <MySpiClass::activate()+0x80>)
    1626:	lsls	r5, r1, #30
    1628:	bpl.n	1636 <MySpiClass::activate()+0x3a>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    162a:	ldr	r0, [pc, #88]	; (1684 <MySpiClass::activate()+0x88>)
    162c:	ldr	r1, [r4, #16]
    162e:	ldr	r5, [r0, #0]
    1630:	ands	r1, r5
    1632:	str	r1, [r4, #32]
				NVIC_ICER1 = interruptSave[1];
    1634:	str	r1, [r0, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    1636:	ldrb	r1, [r3, #11]
    1638:	ldr	r4, [pc, #64]	; (167c <MySpiClass::activate()+0x80>)
    163a:	lsls	r0, r1, #29
    163c:	bpl.n	164a <MySpiClass::activate()+0x4e>
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    163e:	ldr	r0, [pc, #72]	; (1688 <MySpiClass::activate()+0x8c>)
    1640:	ldr	r1, [r4, #20]
    1642:	ldr	r5, [r0, #0]
    1644:	ands	r1, r5
    1646:	str	r1, [r4, #36]	; 0x24
				NVIC_ICER2 = interruptSave[2];
    1648:	str	r1, [r0, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    164a:	ldrb	r1, [r3, #11]
    164c:	ldr	r4, [pc, #44]	; (167c <MySpiClass::activate()+0x80>)
    164e:	lsls	r1, r1, #28
    1650:	bpl.n	165e <MySpiClass::activate()+0x62>
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
    1652:	ldr	r0, [pc, #56]	; (168c <MySpiClass::activate()+0x90>)
    1654:	ldr	r1, [r4, #24]
    1656:	ldr	r5, [r0, #0]
    1658:	ands	r1, r5
    165a:	str	r1, [r4, #40]	; 0x28
				NVIC_ICER3 = interruptSave[3];
    165c:	str	r1, [r0, #0]
			}
			#endif
			__enable_irq();
    165e:	cpsie	i
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    1660:	ldr	r3, [r3, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
    1662:	ldr	r1, [r3, #12]
    1664:	cmp	r1, r2
    1666:	beq.n	1678 <MySpiClass::activate()+0x7c>
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
    1668:	ldr	r1, [pc, #36]	; (1690 <MySpiClass::activate()+0x94>)
    166a:	str	r1, [r3, #0]
			port().CTAR0 = settings.ctar;
    166c:	str	r2, [r3, #12]
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
    166e:	orr.w	r2, r2, #1073741824	; 0x40000000
    1672:	str	r2, [r3, #16]
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    1674:	ldr	r2, [pc, #28]	; (1694 <MySpiClass::activate()+0x98>)
    1676:	str	r2, [r3, #0]
    1678:	pop	{r4, r5, pc}
    167a:	nop
    167c:	.word	0x1fff0f64
    1680:	.word	0xe000e180
    1684:	.word	0xe000e184
    1688:	.word	0xe000e188
    168c:	.word	0xe000e18c
    1690:	.word	0x003f4001
    1694:	.word	0x803f0000

00001698 <MySpiClass::send(unsigned char)>:

        // Receive a byte.
        uint8_t receive() { return SPI.transfer(0XFF); }

        // Send a byte.
        void send(uint8_t data) { SPI.transfer(data); }
    1698:	ldr	r3, [pc, #20]	; (16b0 <MySpiClass::send(unsigned char)+0x18>)
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    169a:	ldr	r3, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    169c:	mov.w	r2, #2147483648	; 0x80000000
    16a0:	str	r2, [r3, #44]	; 0x2c
		port().PUSHR = data;
    16a2:	str	r1, [r3, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    16a4:	ldr	r2, [r3, #44]	; 0x2c
    16a6:	cmp	r2, #0
    16a8:	bge.n	16a4 <MySpiClass::send(unsigned char)+0xc>
		return port().POPR;
    16aa:	ldr	r3, [r3, #56]	; 0x38
    16ac:	bx	lr
    16ae:	nop
    16b0:	.word	0x1fff0f64

000016b4 <__tcf_0>:
    const char *sd_str[]={"sdio",   "sd1","sd2","sd3","sd4","sd5","sd6"};
    const int cs[] = {BUILTIN_SDCARD,  34,   33,   35,   36,   37,  38 };

    const int nsd = sizeof(cs)/sizeof(int);

    SDClass sdx[nsd];
    16b4:	bx	lr

000016b6 <dateTime(unsigned short*, unsigned short*, unsigned char*)>:
    uint32_t diskSpace[nsd];
    uint32_t clusterSize[nsd];

// Call back for file timestamps.  Only called for file create and sync(). needed by SDFat-beta
void dateTime(uint16_t* date, uint16_t* time, uint8_t* ms10) 
{       
    16b6:	push	{r0, r1, r4, r5, r6, lr}
    16b8:	mov	r5, r2
    16ba:	mov	r4, r1
    16bc:	mov	r6, r0
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    16be:	bl	8d18 <rtc_get>
    16c2:	mov	r1, sp
    16c4:	bl	1368 <breakTime(unsigned long, tmElements_t&)>
 * \param[in] day [1,31]
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
    16c8:	ldrb.w	r3, [sp, #6]

    *date = FS_DATE(tmYearToCalendar(tm.Year),tm.Month, tm.Day);
    16cc:	ldrb.w	r2, [sp, #5]
    16d0:	ldrb.w	r1, [sp, #4]
    16d4:	subs	r3, #10
    16d6:	uxth	r3, r3
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    16d8:	cmp	r3, #127	; 0x7f
    16da:	bhi.n	16f0 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3a>
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
    16dc:	cmp	r2, #12
    16de:	bhi.n	16f0 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3a>
    16e0:	cmp	r1, #31
    16e2:	bhi.n	16f0 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3a>
         year << 9 | month << 5 | day;
    16e4:	orr.w	r1, r1, r2, lsl #5
    16e8:	orr.w	r3, r1, r3, lsl #9
    16ec:	uxth	r3, r3
    16ee:	b.n	16f2 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3c>
    16f0:	movs	r3, #0
    16f2:	strh	r3, [r6, #0]
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    16f4:	ldrb.w	r3, [sp, #2]
    16f8:	ldrb.w	r1, [sp, #1]
    16fc:	ldrb.w	r2, [sp]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    1700:	cmp	r3, #23
    1702:	bhi.n	171a <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
 * \param[in] second [0,59]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
    1704:	cmp	r1, #59	; 0x3b
    1706:	bhi.n	171a <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
    1708:	cmp	r2, #59	; 0x3b
    170a:	bhi.n	171a <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
         hour << 11 | minute << 5 | second >> 1;
    170c:	lsls	r1, r1, #5
    170e:	orr.w	r3, r1, r3, lsl #11
    1712:	orr.w	r3, r3, r2, lsr #1
    1716:	uxth	r3, r3
    1718:	b.n	171c <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x66>
    171a:	movs	r3, #0
    *ms10 = tm.Second & 1 ? 100 : 0;
    171c:	ands.w	r2, r2, #1
    1720:	it	ne
    1722:	movne	r2, #100	; 0x64
{       
    tmElements_t tm;
    breakTime(rtc_get(), tm);

    *date = FS_DATE(tmYearToCalendar(tm.Year),tm.Month, tm.Day);
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    1724:	strh	r3, [r4, #0]
    *ms10 = tm.Second & 1 ? 100 : 0;
    1726:	strb	r2, [r5, #0]
}
    1728:	add	sp, #8
    172a:	pop	{r4, r5, r6, pc}

0000172c <MySpiClass::send(unsigned char const*, unsigned int)>:
        { memset(buf, 0XFF, count); SPI.transfer(buf, count); return 0; }

        // Send multiple bytes.
        // Replace this function if your board has multiple byte send.
        void send(const uint8_t* buf, size_t count) 
        {  SPI.transfer((void *)buf, (void *) dummy_buffer, count); }
    172c:	mov	r3, r2
    172e:	ldr	r0, [pc, #8]	; (1738 <MySpiClass::send(unsigned char const*, unsigned int)+0xc>)
    1730:	ldr	r2, [pc, #8]	; (173c <MySpiClass::send(unsigned char const*, unsigned int)+0x10>)
    1732:	b.w	229c <SPIClass::transfer(void const*, void*, unsigned int)>
    1736:	nop
    1738:	.word	0x1fff0f64
    173c:	.word	0x1fff46a8

00001740 <MySpiClass::receive(unsigned char*, unsigned int)>:
        // Send a byte.
        void send(uint8_t data) { SPI.transfer(data); }

        // Receive multiple bytes.  
        // Replace this function if your board has multiple byte receive.
        uint8_t receive(uint8_t* buf, size_t count) 
    1740:	push	{r3, r4, r5, lr}
    1742:	mov	r4, r1
    1744:	mov	r5, r2
        { memset(buf, 0XFF, count); SPI.transfer(buf, count); return 0; }
    1746:	movs	r1, #255	; 0xff
    1748:	mov	r0, r4
    174a:	bl	88dc <memset>
		port().PUSHR = data | SPI_PUSHR_CTAS(1);
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
	}

	void inline transfer(void *buf, size_t count) {transfer(buf, buf, count);}
    174e:	mov	r3, r5
    1750:	mov	r2, r4
    1752:	mov	r1, r4
    1754:	ldr	r0, [pc, #8]	; (1760 <MySpiClass::receive(unsigned char*, unsigned int)+0x20>)
    1756:	bl	229c <SPIClass::transfer(void const*, void*, unsigned int)>
    175a:	movs	r0, #0
    175c:	pop	{r3, r4, r5, pc}
    175e:	nop
    1760:	.word	0x1fff0f64

00001764 <MySpiClass::begin(SdSpiConfig)>:
     * 
     */

    public:
        // Initialize the SPI bus.
        void begin(SdSpiConfig config) {  (void) config; SPI.begin(); }
    1764:	sub	sp, #16
    1766:	add	r0, sp, #16
    1768:	stmdb	r0, {r1, r2, r3}
    176c:	ldr	r0, [pc, #4]	; (1774 <MySpiClass::begin(SdSpiConfig)+0x10>)
    176e:	add	sp, #16
    1770:	b.w	2224 <SPIClass::begin()>
    1774:	.word	0x1fff0f64

00001778 <File::dec_refcount() [clone .isra.23]>:
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	using Print::write;
private:
	void dec_refcount() {
    1778:	push	{r4, lr}
    177a:	mov	r4, r0
		if (--(f->refcount) == 0) {
    177c:	ldr	r0, [r0, #0]
    177e:	ldr	r3, [r0, #4]
    1780:	subs	r3, #1
    1782:	str	r3, [r0, #4]
    1784:	cbnz	r3, 1796 <File::dec_refcount() [clone .isra.23]+0x1e>
			f->close();
    1786:	ldr	r3, [r0, #0]
    1788:	ldr	r3, [r3, #44]	; 0x2c
    178a:	blx	r3
			delete f;
    178c:	ldr	r0, [r4, #0]
    178e:	cbz	r0, 1796 <File::dec_refcount() [clone .isra.23]+0x1e>
    1790:	ldr	r3, [r0, #0]
    1792:	ldr	r3, [r3, #4]
    1794:	blx	r3
		}
		f = nullptr;
    1796:	movs	r3, #0
    1798:	str	r3, [r4, #0]
    179a:	pop	{r4, pc}

0000179c <MySpiClass::deactivate()>:

        // Activate SPI hardware with correct speed and mode.
        void activate() { if(doTransactions) SPI.beginTransaction(m_spiSettings); }
        // Deactivate SPI hardware.
        void deactivate() { if(doTransactions) SPI.endTransaction(); }
    179c:	ldrb	r3, [r0, #8]
    179e:	cbz	r3, 17da <MySpiClass::deactivate()+0x3e>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    17a0:	ldr	r3, [pc, #56]	; (17dc <MySpiClass::deactivate()+0x40>)
    17a2:	ldrb	r2, [r3, #11]
    17a4:	cbz	r2, 17da <MySpiClass::deactivate()+0x3e>
			if (interruptMasksUsed & 0x01) {
    17a6:	lsls	r0, r2, #31
				NVIC_ISER0 = interruptSave[0];
    17a8:	ittt	mi
    17aa:	ldrmi	r2, [pc, #52]	; (17e0 <MySpiClass::deactivate()+0x44>)
    17ac:	ldrmi	r1, [r3, #28]
    17ae:	strmi	r1, [r2, #0]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    17b0:	ldrb	r2, [r3, #11]
    17b2:	lsls	r1, r2, #30
				NVIC_ISER1 = interruptSave[1];
    17b4:	itttt	mi
    17b6:	ldrmi	r2, [pc, #36]	; (17dc <MySpiClass::deactivate()+0x40>)
    17b8:	ldrmi	r1, [r2, #32]
    17ba:	ldrmi	r2, [pc, #40]	; (17e4 <MySpiClass::deactivate()+0x48>)
    17bc:	strmi	r1, [r2, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    17be:	ldrb	r2, [r3, #11]
    17c0:	lsls	r2, r2, #29
				NVIC_ISER2 = interruptSave[2];
    17c2:	itttt	mi
    17c4:	ldrmi	r2, [pc, #20]	; (17dc <MySpiClass::deactivate()+0x40>)
    17c6:	ldrmi	r1, [r2, #36]	; 0x24
    17c8:	ldrmi	r2, [pc, #28]	; (17e8 <MySpiClass::deactivate()+0x4c>)
    17ca:	strmi	r1, [r2, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    17cc:	ldrb	r3, [r3, #11]
    17ce:	lsls	r3, r3, #28
				NVIC_ISER3 = interruptSave[3];
    17d0:	itttt	mi
    17d2:	ldrmi	r3, [pc, #8]	; (17dc <MySpiClass::deactivate()+0x40>)
    17d4:	ldrmi	r2, [r3, #40]	; 0x28
    17d6:	ldrmi	r3, [pc, #20]	; (17ec <MySpiClass::deactivate()+0x50>)
    17d8:	strmi	r2, [r3, #0]
    17da:	bx	lr
    17dc:	.word	0x1fff0f64
    17e0:	.word	0xe000e100
    17e4:	.word	0xe000e104
    17e8:	.word	0xe000e108
    17ec:	.word	0xe000e10c

000017f0 <MySpiClass::receive()>:

        // Receive a byte.
        uint8_t receive() { return SPI.transfer(0XFF); }
    17f0:	ldr	r3, [pc, #24]	; (180c <MySpiClass::receive()+0x1c>)
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    17f2:	ldr	r3, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    17f4:	mov.w	r2, #2147483648	; 0x80000000
    17f8:	str	r2, [r3, #44]	; 0x2c
		port().PUSHR = data;
    17fa:	movs	r2, #255	; 0xff
    17fc:	str	r2, [r3, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    17fe:	ldr	r2, [r3, #44]	; 0x2c
    1800:	cmp	r2, #0
    1802:	bge.n	17fe <MySpiClass::receive()+0xe>
		return port().POPR;
    1804:	ldr	r0, [r3, #56]	; 0x38
    1806:	uxtb	r0, r0
    1808:	bx	lr
    180a:	nop
    180c:	.word	0x1fff0f64

00001810 <Print::print(char const*)>:
    1810:	push	{r3, lr}
    1812:	bl	a54 <Print::write(char const*)>
    1816:	pop	{r3, pc}

00001818 <Print::print(unsigned long)>:

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
    1818:	movs	r3, #0
    181a:	movs	r2, #10
    181c:	b.w	99e6 <Print::printNumber(unsigned long, unsigned char, unsigned char)>

00001820 <Print::println(unsigned long)>:

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
    1820:	push	{r3, r4, r5, lr}
    1822:	mov	r5, r0
    1824:	bl	1818 <Print::print(unsigned long)>
    1828:	mov	r4, r0
    182a:	mov	r0, r5
    182c:	bl	99ac <Print::println()>
    1830:	add	r0, r4
    1832:	pop	{r3, r4, r5, pc}

00001834 <FsVolume::freeClusterCount() const>:
  uint8_t fatType() const {
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    1834:	mov	r3, r0
    return m_fVol ? m_fVol->freeClusterCount() :
    1836:	ldr.w	r0, [r0, #1152]	; 0x480
           m_xVol ? m_xVol->freeClusterCount() : 0;
    183a:	cbz	r0, 1840 <FsVolume::freeClusterCount() const+0xc>
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
    183c:	b.w	6424 <FatPartition::freeClusterCount()>
           m_xVol ? m_xVol->freeClusterCount() : 0;
    1840:	ldr.w	r0, [r3, #1156]	; 0x484
    1844:	cbz	r0, 184a <FsVolume::freeClusterCount() const+0x16>
    1846:	b.w	4348 <ExFatPartition::freeClusterCount()>
  }
    184a:	bx	lr

0000184c <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)>:
	}
	SPISettings() {
		init_AlwaysInline(4000000, MSBFIRST, SPI_MODE0);
	}
private:
	void init_MightInline(uint32_t clock, uint8_t bitOrder, uint8_t dataMode) {
    184c:	push	{r4, r5, r6, r7, lr}
		init_AlwaysInline(clock, bitOrder, dataMode);
	}
	void init_AlwaysInline(uint32_t clock, uint8_t bitOrder, uint8_t dataMode)
	  __attribute__((__always_inline__)) {
		uint32_t t, c = SPI_CTAR_FMSZ(7);
		if (bitOrder == LSBFIRST) c |= SPI_CTAR_LSBFE;
    184e:	cmp	r2, #0
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    1850:	ldr	r6, [pc, #76]	; (18a0 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x54>)
    1852:	ldr	r7, [pc, #80]	; (18a4 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x58>)
		init_AlwaysInline(clock, bitOrder, dataMode);
	}
	void init_AlwaysInline(uint32_t clock, uint8_t bitOrder, uint8_t dataMode)
	  __attribute__((__always_inline__)) {
		uint32_t t, c = SPI_CTAR_FMSZ(7);
		if (bitOrder == LSBFIRST) c |= SPI_CTAR_LSBFE;
    1854:	ite	ne
    1856:	movne.w	r4, #939524096	; 0x38000000
    185a:	moveq.w	r4, #956301312	; 0x39000000
				t = SPI_CTAR_PBR(2) | SPI_CTAR_BR(7) | SPI_CTAR_CSSCK(6);
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
    185e:	movs	r2, #0
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    1860:	ldrh.w	r5, [r6, r2, lsl #1]
    1864:	sdiv	r5, r7, r5
    1868:	cmp	r1, r5
    186a:	bcc.n	1876 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x2a>
			}
		}
		if (dataMode & 0x08) {
    186c:	lsls	r1, r3, #28
    186e:	bpl.n	1880 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x34>
			c |= SPI_CTAR_CPOL;
    1870:	orr.w	r4, r4, #67108864	; 0x4000000
    1874:	b.n	1880 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x34>
				t = SPI_CTAR_PBR(2) | SPI_CTAR_BR(7) | SPI_CTAR_CSSCK(6);
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
    1876:	adds	r5, r2, #1
    1878:	cmp	r5, #23
    187a:	beq.n	186c <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x20>
    187c:	mov	r2, r5
    187e:	b.n	1860 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x14>
				t = ctar_clock_table[i];
    1880:	ldr	r1, [pc, #36]	; (18a8 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x5c>)
			}
		}
		if (dataMode & 0x08) {
			c |= SPI_CTAR_CPOL;
		}
		if (dataMode & 0x04) {
    1882:	lsls	r3, r3, #29
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
				t = ctar_clock_table[i];
    1884:	ldr.w	r2, [r1, r2, lsl #2]
			}
		}
		if (dataMode & 0x08) {
			c |= SPI_CTAR_CPOL;
		}
		if (dataMode & 0x04) {
    1888:	bpl.n	189a <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x4e>
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
    188a:	bic.w	r3, r2, #61440	; 0xf000
    188e:	lsrs	r2, r2, #4
    1890:	and.w	r2, r2, #3840	; 0xf00
		}
		if (dataMode & 0x08) {
			c |= SPI_CTAR_CPOL;
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
    1894:	orr.w	r4, r4, #33554432	; 0x2000000
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
    1898:	orrs	r2, r3
		}
		ctar = c | t;
    189a:	orrs	r2, r4
    189c:	str	r2, [r0, #0]
    189e:	pop	{r4, r5, r6, r7, pc}
    18a0:	.word	0x000120fe
    18a4:	.word	0x02dc6c00
    18a8:	.word	0x000121c0

000018ac <SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)>:
#define SPI_HAS_NOTUSINGINTERRUPT 1
#define SPI_ATOMIC_VERSION 1

class SPISettings {
public:
	SPISettings(uint32_t clock, uint8_t bitOrder, uint8_t dataMode) {
    18ac:	push	{r4, lr}
    18ae:	mov	r4, r0
		if (__builtin_constant_p(clock)) {
			init_AlwaysInline(clock, bitOrder, dataMode);
		} else {
			init_MightInline(clock, bitOrder, dataMode);
    18b0:	bl	184c <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)>
		}
	}
    18b4:	mov	r0, r4
    18b6:	pop	{r4, pc}

000018b8 <MySpiClass::setSckSpeed(unsigned long)>:
        // Replace this function if your board has multiple byte send.
        void send(const uint8_t* buf, size_t count) 
        {  SPI.transfer((void *)buf, (void *) dummy_buffer, count); }

        // Save SPISettings for new max SCK frequency
        void setSckSpeed(uint32_t maxSck) {  m_spiSettings = SPISettings(maxSck, MSBFIRST, SPI_MODE0); }
    18b8:	push	{r0, r1, r4, lr}
    18ba:	movs	r3, #0
    18bc:	mov	r4, r0
    18be:	movs	r2, #1
    18c0:	add	r0, sp, #4
    18c2:	bl	18ac <SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)>
    18c6:	ldr	r3, [sp, #4]
    18c8:	str	r3, [r4, #4]
    18ca:	add	sp, #8
    18cc:	pop	{r4, pc}
    18ce:	Address 0x000018ce is out of bounds.


000018d0 <getCount()>:

    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    18d0:	ldr	r2, [pc, #16]	; (18e4 <getCount()+0x14>)
    18d2:	ldrh	r3, [r2, #0]
    18d4:	ldrh	r0, [r2, #2]
            {  
                /**
                 * @brief get number of data blocks in storage
                 * 
                 */
                if(front_ >= rear_) return front_ - rear_; return front_+ MAXBUF -rear_; 
    18d6:	cmp	r3, r0
    18d8:	it	cc
    18da:	addcc	r3, #10
    18dc:	subs	r0, r3, r0
    18de:	uxth	r0, r0

    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    18e0:	bx	lr
    18e2:	nop
    18e4:	.word	0x1fff4634

000018e8 <pushData(unsigned long*)>:
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    18e8:	push	{r3, r4, r5, lr}
            { 
                /** 
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
    18ea:	ldr	r5, [pc, #44]	; (1918 <pushData(unsigned long*)+0x30>)
    18ec:	ldrh	r4, [r5, #0]
                if(f >= MAXBUF) f=0;
                if(f == rear_) return 0;
    18ee:	ldrh	r3, [r5, #2]
            { 
                /** 
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
    18f0:	adds	r4, #1
    18f2:	uxth	r4, r4
                if(f >= MAXBUF) f=0;
    18f4:	cmp	r4, #10
    18f6:	it	cs
    18f8:	movcs	r4, #0
                if(f == rear_) return 0;
    18fa:	cmp	r3, r4
    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    18fc:	mov	r1, r0
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
                if(f >= MAXBUF) f=0;
                if(f == rear_) return 0;
    18fe:	beq.n	1914 <pushData(unsigned long*)+0x2c>

                uint32_t *ptr= data_buffer+f*NBUF_ACQ;
                memcpy(ptr,src,NBUF_ACQ*4);
    1900:	ldr	r0, [r5, #4]
    1902:	mov.w	r2, #1024	; 0x400
    1906:	add.w	r0, r0, r4, lsl #10
    190a:	bl	8734 <memcpy>
                front_ = f;
    190e:	strh	r4, [r5, #0]
                return 1;
    1910:	movs	r0, #1
    1912:	pop	{r3, r4, r5, pc}
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
                if(f >= MAXBUF) f=0;
                if(f == rear_) return 0;
    1914:	movs	r0, #0
    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    1916:	pop	{r3, r4, r5, pc}
    1918:	.word	0x1fff4634

0000191c <pullData(unsigned long*, unsigned long)>:
    uint16_t pullData(uint32_t * dst, uint32_t ndbl) {return rawData.pull(dst,ndbl);}
    191c:	push	{r4, r5, r6, lr}
                /** 
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
    191e:	ldr	r6, [pc, #60]	; (195c <pullData(unsigned long*, unsigned long)+0x40>)
    1920:	ldrh	r4, [r6, #2]
                if(r == (front_/ndbl)) return 0;
    1922:	ldrh	r3, [r6, #0]
                /** 
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
    1924:	udiv	r4, r4, r1
                if(r == (front_/ndbl)) return 0;
    1928:	udiv	r3, r3, r1
    192c:	cmp	r4, r3

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    uint16_t pullData(uint32_t * dst, uint32_t ndbl) {return rawData.pull(dst,ndbl);}
    192e:	mov	r5, r1
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
                if(r == (front_/ndbl)) return 0;
    1930:	beq.n	1958 <pullData(unsigned long*, unsigned long)+0x3c>
    1932:	lsls	r2, r1, #10

                uint32_t *ptr= data_buffer + r*ndbl*NBUF_ACQ;
                memcpy(dst,ptr,ndbl*NBUF_ACQ*4);
    1934:	ldr	r1, [r6, #4]
    1936:	mla	r1, r2, r4, r1
    193a:	bl	8734 <memcpy>
                if(++r >= (MAXBUF/ndbl)) r=0;
    193e:	adds	r1, r4, #1
    1940:	uxth	r1, r1
    1942:	movs	r3, #10
    1944:	udiv	r3, r3, r5
    1948:	cmp	r1, r3
    194a:	it	cs
    194c:	movcs	r1, #0
                rear_ = r*ndbl;
    194e:	smulbb	r1, r5, r1
    1952:	strh	r1, [r6, #2]
                return 1;
    1954:	movs	r0, #1
    1956:	pop	{r4, r5, r6, pc}
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
                if(r == (front_/ndbl)) return 0;
    1958:	movs	r0, #0

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    uint16_t pullData(uint32_t * dst, uint32_t ndbl) {return rawData.pull(dst,ndbl);}
    195a:	pop	{r4, r5, r6, pc}
    195c:	.word	0x1fff4634

00001960 <sdCsInit(unsigned char)>:
};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}

void sdCsInit(SdCsPin_t pin) { pinMode(pin, OUTPUT); digitalWriteFast(pin, HIGH);}
    1960:	push	{r4, lr}
    1962:	movs	r1, #1
    1964:	mov	r4, r0
    1966:	bl	8d48 <pinMode>
			}
			#endif
		}
	} else {
		if (val) {
			*portSetRegister(pin) = digitalPinToBitMask(pin);
    196a:	ldr	r3, [pc, #12]	; (1978 <sdCsInit(unsigned char)+0x18>)
    196c:	ldr.w	r3, [r3, r4, lsl #3]
    1970:	movs	r2, #1
    1972:	strb.w	r2, [r3, #128]	; 0x80
    1976:	pop	{r4, pc}
    1978:	.word	0x00012660

0000197c <sdCsWrite(unsigned char, bool)>:
void sdCsWrite(SdCsPin_t pin, bool level) { digitalWriteFast(pin, level); }
    197c:	ldr	r2, [pc, #20]	; (1994 <sdCsWrite(unsigned char, bool)+0x18>)
    197e:	movs	r3, #1
    1980:	ldr.w	r2, [r2, r0, lsl #3]
				CORE_PIN63_PORTCLEAR = CORE_PIN63_BITMASK;
			}
			#endif
		}
	} else {
		if (val) {
    1984:	cbz	r1, 198c <sdCsWrite(unsigned char, bool)+0x10>
			*portSetRegister(pin) = digitalPinToBitMask(pin);
    1986:	strb.w	r3, [r2, #128]	; 0x80
    198a:	bx	lr
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
    198c:	strb.w	r3, [r2, #256]	; 0x100
    1990:	bx	lr
    1992:	nop
    1994:	.word	0x00012660

00001998 <storage_configure()>:
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    *ms10 = tm.Second & 1 ? 100 : 0;
}

void storage_configure()
{
    1998:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      SPI.setMISO(SD_MISO);
      SPI.setSCK(SD_SCK);
    #endif

    // Set Time callback
    FsDateTime::callback = dateTime;
    199c:	ldr	r3, [pc, #636]	; (1c1c <storage_configure()+0x284>)
    199e:	ldr	r2, [pc, #640]	; (1c20 <storage_configure()+0x288>)
    19a0:	ldr	r4, [pc, #640]	; (1c24 <storage_configure()+0x28c>)
    19a2:	str	r2, [r3, #0]
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    *ms10 = tm.Second & 1 ? 100 : 0;
}

void storage_configure()
{
    19a4:	sub	sp, #60	; 0x3c
    #endif

    // Set Time callback
    FsDateTime::callback = dateTime;

    for(int ii=0; ii<nsd; ii++)
    19a6:	movs	r6, #0
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    19a8:	mov	r1, r6
    19aa:	ldr	r0, [pc, #636]	; (1c28 <storage_configure()+0x290>)
    19ac:	bl	9a5c <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    19b0:	ldr	r0, [pc, #628]	; (1c28 <storage_configure()+0x290>)
    19b2:	bl	99ac <Print::println()>
    { Serial.println(ii);

      uint16_t status=0;
      if(cs[ii] == BUILTIN_SDCARD)
    19b6:	ldr	r3, [pc, #628]	; (1c2c <storage_configure()+0x294>)
    19b8:	ldr.w	r7, [r3, r6, lsl #2]
    19bc:	cmp	r7, #254	; 0xfe
    19be:	mov.w	r5, r6, lsl #2
    19c2:	bne.n	19fc <storage_configure()+0x64>
    19c4:	mov.w	r8, #0
    19c8:	add.w	sl, r4, #4
    19cc:	addw	fp, r4, #1172	; 0x494
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    19d0:	movs	r3, #255	; 0xff
    sdioConfigBackup = sdioConfig;
    19d2:	movs	r1, #0
   * \param[in] config SDIO configuration.
   * \return generic card pointer or nullptr if SDIO is not supported.
   */
  SdCard* newCard(SdioConfig config) {
#if HAS_SDIO_CLASS
    m_sdioCard.begin(config);
    19d4:	mov	r0, fp
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    19d6:	strb.w	r3, [r4, #1204]	; 0x4b4
    sdioConfigBackup = sdioConfig;
    19da:	strb.w	r1, [r4, #1216]	; 0x4c0
    19de:	uxth.w	r9, r8
    19e2:	bl	80f0 <SdioCard::begin(SdioConfig)>
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdioConfig sdioConfig) {
    m_card = m_cardFactory.newCard(sdioConfig);
    19e6:	str.w	fp, [r4, #1168]	; 0x490
    return m_card && !m_card->errorCode();
    19ea:	cmp.w	fp, #0
    19ee:	beq.n	1aec <storage_configure()+0x154>
    19f0:	mov	r0, fp
    19f2:	bl	78dc <SdioCard::errorCode() const>
    19f6:	cmp	r0, #0
    19f8:	bne.n	1aec <storage_configure()+0x154>
    19fa:	b.n	1ad6 <storage_configure()+0x13e>
            else
            {
                Serial.println("No sdio storage"); 
            }
      }
      else if(cs[ii]<BUILTIN_SDCARD)
    19fc:	cmp	r7, #253	; 0xfd
    19fe:	bgt.w	1c08 <storage_configure()+0x270>
      { 
            sdCsInit(cs[ii]);
    1a02:	uxtb.w	r8, r7
    1a06:	mov	r0, r8
    1a08:	bl	1960 <sdCsInit(unsigned char)>
            delay(100);
    1a0c:	movs	r0, #100	; 0x64
    1a0e:	bl	8de8 <delay>
    1a12:	mov.w	fp, #0
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    1a16:	ldr	r2, [pc, #536]	; (1c30 <storage_configure()+0x298>)
    1a18:	str.w	r2, [r4, #1208]	; 0x4b8
    spiConfigBackupPort = spiConfig.spiPort;
    1a1c:	ldr	r2, [pc, #532]	; (1c34 <storage_configure()+0x29c>)
    1a1e:	str.w	r2, [r4, #1212]	; 0x4bc
    1a22:	adds	r3, r4, #4
    1a24:	ldr	r2, [pc, #520]	; (1c30 <storage_configure()+0x298>)
    1a26:	str	r2, [sp, #24]
    1a28:	str	r3, [sp, #8]
    1a2a:	ldr	r2, [pc, #520]	; (1c34 <storage_configure()+0x29c>)
    1a2c:	str	r2, [sp, #28]
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    1a2e:	movs	r3, #0
    1a30:	strb.w	r3, [sp, #21]
    1a34:	strb.w	r8, [sp, #20]
    1a38:	add	r2, sp, #20
    1a3a:	ldmia	r2, {r0, r1, r2}
    1a3c:	add.w	lr, sp, #32
    1a40:	stmia.w	lr, {r0, r1, r2}
    1a44:	strb.w	r3, [r4, #1205]	; 0x4b5
    1a48:	strb.w	r3, [sp, #33]	; 0x21
    1a4c:	ldr	r3, [pc, #480]	; (1c30 <storage_configure()+0x298>)
    1a4e:	str	r3, [sp, #36]	; 0x24
    1a50:	ldr	r3, [pc, #480]	; (1c34 <storage_configure()+0x29c>)
    1a52:	str	r3, [sp, #40]	; 0x28
    1a54:	strb.w	r8, [sp, #32]
    1a58:	ldmia.w	lr, {r0, r1, r2}
    1a5c:	add	r3, sp, #44	; 0x2c
    1a5e:	stmia.w	r3, {r0, r1, r2}
    1a62:	add.w	r9, r4, #1184	; 0x4a0
   *
   * \param[in] config SPI configuration.
   * \return generic card pointer.
   */
  SdCard* newCard(SdSpiConfig config) {
    m_spiCard.begin(config);
    1a66:	ldmia	r3, {r1, r2, r3}
    1a68:	mov	r0, r9
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    1a6a:	strb.w	r8, [r4, #1204]	; 0x4b4
    1a6e:	uxth.w	sl, fp
    1a72:	bl	724c <SdSpiCard::begin(SdSpiConfig)>
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    m_card = m_cardFactory.newCard(spiConfig);
    1a76:	str.w	r9, [r4, #1168]	; 0x490
    return m_card && !m_card->errorCode();
    1a7a:	cmp.w	r9, #0
    1a7e:	bne.n	1a8c <storage_configure()+0xf4>
            uint16_t tries=0;
            while(!sdx[ii].sdfs.begin(SdSpiConfig(cs[ii], SHARED_SPI, SPI_SPEED, &mySpi)) && tries<10)
    1a80:	cmp.w	sl, #9
    1a84:	ite	hi
    1a86:	movhi	r3, #0
    1a88:	movls	r3, #1
    1a8a:	b.n	1aa4 <storage_configure()+0x10c>
    1a8c:	ldrb.w	r3, [r4, #1199]	; 0x4af
    1a90:	cmp	r3, #0
    1a92:	bne.n	1a80 <storage_configure()+0xe8>
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    1a94:	mov	r1, r9
    1a96:	adds	r0, r4, #4
    1a98:	str	r3, [sp, #8]
    1a9a:	bl	6e18 <FsVolume::begin(BlockDeviceInterface*)>
    1a9e:	ldr	r3, [sp, #8]
    1aa0:	cmp	r0, #0
    1aa2:	beq.n	1a80 <storage_configure()+0xe8>
    1aa4:	add.w	r9, fp, #1
    1aa8:	cbz	r3, 1ac6 <storage_configure()+0x12e>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    1aaa:	mov	r1, sl
    1aac:	ldr	r0, [pc, #376]	; (1c28 <storage_configure()+0x290>)
    1aae:	bl	9a5c <Print::print(long)>
            { Serial.print(tries); Serial.print(" "); tries++; delay(1000); } 
    1ab2:	ldr	r1, [pc, #388]	; (1c38 <storage_configure()+0x2a0>)
    1ab4:	ldr	r0, [pc, #368]	; (1c28 <storage_configure()+0x290>)
    1ab6:	bl	1810 <Print::print(char const*)>
    1aba:	mov.w	r0, #1000	; 0x3e8
    1abe:	bl	8de8 <delay>
      else if(cs[ii]<BUILTIN_SDCARD)
      { 
            sdCsInit(cs[ii]);
            delay(100);
            uint16_t tries=0;
            while(!sdx[ii].sdfs.begin(SdSpiConfig(cs[ii], SHARED_SPI, SPI_SPEED, &mySpi)) && tries<10)
    1ac2:	mov	fp, r9
    1ac4:	b.n	1a16 <storage_configure()+0x7e>
            { Serial.print(tries); Serial.print(" "); tries++; delay(1000); } 

            if(tries<10) 
    1ac6:	cmp.w	sl, #9
    1aca:	bls.n	1b10 <storage_configure()+0x178>
            {
                status=1;
            }
            else
            {
                Serial.println("No spi storage");
    1acc:	ldr	r1, [pc, #364]	; (1c3c <storage_configure()+0x2a4>)
    1ace:	ldr	r0, [pc, #344]	; (1c28 <storage_configure()+0x290>)
    1ad0:	bl	6b8 <Print::println(char const*)>
    1ad4:	b.n	1c08 <storage_configure()+0x270>
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
    1ad6:	ldr.w	r1, [r4, #1168]	; 0x490
    1ada:	mov	r0, sl
    1adc:	bl	6e18 <FsVolume::begin(BlockDeviceInterface*)>
    1ae0:	cbz	r0, 1aec <storage_configure()+0x154>
      {
            uint16_t tries=0;
            while(!sdx[ii].sdfs.begin(SdioConfig(FIFO_SDIO)) && tries<10)
            { Serial.print(tries); Serial.print(" "); tries++; delay(1000); } 

            if(tries<10) 
    1ae2:	cmp.w	r9, #10
    1ae6:	bne.n	1b10 <storage_configure()+0x178>
            {
                status=1;
            }
            else
            {
                Serial.println("No sdio storage"); 
    1ae8:	ldr	r1, [pc, #340]	; (1c40 <storage_configure()+0x2a8>)
    1aea:	b.n	1ace <storage_configure()+0x136>

      uint16_t status=0;
      if(cs[ii] == BUILTIN_SDCARD)
      {
            uint16_t tries=0;
            while(!sdx[ii].sdfs.begin(SdioConfig(FIFO_SDIO)) && tries<10)
    1aec:	cmp.w	r8, #10
    1af0:	beq.n	1ae2 <storage_configure()+0x14a>
    1af2:	mov	r1, r8
    1af4:	ldr	r0, [pc, #304]	; (1c28 <storage_configure()+0x290>)
    1af6:	bl	9a5c <Print::print(long)>
            { Serial.print(tries); Serial.print(" "); tries++; delay(1000); } 
    1afa:	ldr	r1, [pc, #316]	; (1c38 <storage_configure()+0x2a0>)
    1afc:	ldr	r0, [pc, #296]	; (1c28 <storage_configure()+0x290>)
    1afe:	bl	1810 <Print::print(char const*)>
    1b02:	mov.w	r0, #1000	; 0x3e8
    1b06:	bl	8de8 <delay>
    1b0a:	add.w	r8, r8, #1

      uint16_t status=0;
      if(cs[ii] == BUILTIN_SDCARD)
      {
            uint16_t tries=0;
            while(!sdx[ii].sdfs.begin(SdioConfig(FIFO_SDIO)) && tries<10)
    1b0e:	b.n	19cc <storage_configure()+0x34>
                Serial.println("No spi storage");
            }
      }
      if (status)
      {
            uint64_t totalSize = sdx[ii].totalSize();
    1b10:	ldr	r3, [r4, #0]
    1b12:	mov	r0, r4
    1b14:	ldr	r3, [r3, #28]
    1b16:	blx	r3
            uint64_t usedSize  = sdx[ii].usedSize();
    1b18:	ldr	r3, [r4, #0]
                Serial.println("No spi storage");
            }
      }
      if (status)
      {
            uint64_t totalSize = sdx[ii].totalSize();
    1b1a:	mov	r8, r0
            uint64_t usedSize  = sdx[ii].usedSize();
    1b1c:	ldr	r3, [r3, #24]
    1b1e:	mov	r0, r4
                Serial.println("No spi storage");
            }
      }
      if (status)
      {
            uint64_t totalSize = sdx[ii].totalSize();
    1b20:	mov	r9, r1
            uint64_t usedSize  = sdx[ii].usedSize();
    1b22:	blx	r3

            Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]); 
    1b24:	ldr	r3, [pc, #284]	; (1c44 <storage_configure()+0x2ac>)
    1b26:	ldr	r3, [r5, r3]
    1b28:	str	r3, [sp, #0]
            }
      }
      if (status)
      {
            uint64_t totalSize = sdx[ii].totalSize();
            uint64_t usedSize  = sdx[ii].usedSize();
    1b2a:	strd	r0, r1, [sp, #8]

            Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]); 
    1b2e:	mov	r3, r7
    1b30:	ldr	r1, [pc, #276]	; (1c48 <storage_configure()+0x2b0>)
    1b32:	ldr	r0, [pc, #244]	; (1c28 <storage_configure()+0x290>)
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
	size_t print(int64_t n);
	size_t print(uint64_t n)			{ return printNumber64(n, 10, 0); }
    1b34:	movs	r7, #10
    1b36:	mov	r2, r6
    1b38:	mov.w	sl, #0
    1b3c:	bl	99cc <Print::printf(char const*, ...)>
    1b40:	mov	r2, r8
    1b42:	mov	r3, r9
    1b44:	stmia.w	sp, {r7, sl}
    1b48:	ldr	r0, [pc, #220]	; (1c28 <storage_configure()+0x290>)
    1b4a:	bl	9a6c <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
            Serial.print(totalSize); Serial.print(" "); Serial.println(usedSize);
    1b4e:	ldr	r1, [pc, #232]	; (1c38 <storage_configure()+0x2a0>)
    1b50:	ldr	r0, [pc, #212]	; (1c28 <storage_configure()+0x290>)
    1b52:	bl	1810 <Print::print(char const*)>
    1b56:	ldrd	r2, r3, [sp, #8]
    1b5a:	stmia.w	sp, {r7, sl}
    1b5e:	ldr	r0, [pc, #200]	; (1c28 <storage_configure()+0x290>)
    1b60:	bl	9a6c <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
	size_t println(int64_t n)			{ return print(n) + println(); }
	size_t println(uint64_t n)			{ return print(n) + println(); }
    1b64:	ldr	r0, [pc, #192]	; (1c28 <storage_configure()+0x290>)
    1b66:	bl	99ac <Print::println()>
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    1b6a:	ldr.w	r3, [r4, #1156]	; 0x484
    1b6e:	adds	r7, r4, #4
           m_xVol ? m_xVol->clusterCount() : 0;
    1b70:	cbz	r3, 1b78 <storage_configure()+0x1e0>
  uint8_t* cacheClear() {
    return m_cache.clear();
  }
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_lastCluster - 1;
    1b72:	ldr	r1, [r3, #28]
    1b74:	subs	r1, #1
    1b76:	b.n	1b82 <storage_configure()+0x1ea>
    1b78:	ldr.w	r1, [r4, #1160]	; 0x488
    1b7c:	cbz	r1, 1b82 <storage_configure()+0x1ea>
    1b7e:	ldr.w	r1, [r1, #1072]	; 0x430

            Serial.print(sdx[ii].sdfs.clusterCount()); Serial.print(" "); 
    1b82:	ldr	r0, [pc, #164]	; (1c28 <storage_configure()+0x290>)
    1b84:	bl	1818 <Print::print(unsigned long)>
    1b88:	ldr	r1, [pc, #172]	; (1c38 <storage_configure()+0x2a0>)
    1b8a:	ldr	r0, [pc, #156]	; (1c28 <storage_configure()+0x290>)
    1b8c:	bl	1810 <Print::print(char const*)>
            Serial.print(sdx[ii].sdfs.freeClusterCount()); Serial.print(" ");
    1b90:	mov	r0, r7
    1b92:	bl	1834 <FsVolume::freeClusterCount() const>
    1b96:	mov	r1, r0
    1b98:	ldr	r0, [pc, #140]	; (1c28 <storage_configure()+0x290>)
    1b9a:	bl	1818 <Print::print(unsigned long)>
    1b9e:	ldr	r1, [pc, #152]	; (1c38 <storage_configure()+0x2a0>)
    1ba0:	ldr	r0, [pc, #132]	; (1c28 <storage_configure()+0x290>)
    1ba2:	bl	1810 <Print::print(char const*)>
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  uint32_t __attribute__((error("use sectorsPerCluster()"))) blocksPerCluster();
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
    1ba6:	ldr.w	r3, [r4, #1156]	; 0x484
           m_xVol ? m_xVol->bytesPerCluster() : 0;
    1baa:	cbz	r3, 1bba <storage_configure()+0x222>
    1bac:	ldrb	r1, [r3, #6]
    1bae:	mov.w	r3, #512	; 0x200
    1bb2:	lsl.w	r1, r3, r1
    1bb6:	uxth	r1, r1
    1bb8:	b.n	1bc4 <storage_configure()+0x22c>
    1bba:	ldr.w	r1, [r4, #1160]	; 0x488
    1bbe:	cbz	r1, 1bc4 <storage_configure()+0x22c>
    1bc0:	ldr.w	r1, [r1, #1084]	; 0x43c

            clusterSize[ii] = sdx[ii].sdfs.bytesPerCluster()/512; // count sectors
    1bc4:	ldr	r3, [pc, #132]	; (1c4c <storage_configure()+0x2b4>)
            Serial.println(clusterSize[ii]) ;Serial.print(" ");
    1bc6:	ldr	r0, [pc, #96]	; (1c28 <storage_configure()+0x290>)
            Serial.print(totalSize); Serial.print(" "); Serial.println(usedSize);

            Serial.print(sdx[ii].sdfs.clusterCount()); Serial.print(" "); 
            Serial.print(sdx[ii].sdfs.freeClusterCount()); Serial.print(" ");

            clusterSize[ii] = sdx[ii].sdfs.bytesPerCluster()/512; // count sectors
    1bc8:	lsrs	r1, r1, #9
    1bca:	str	r1, [r5, r3]
            Serial.println(clusterSize[ii]) ;Serial.print(" ");
    1bcc:	bl	1820 <Print::println(unsigned long)>
    1bd0:	ldr	r1, [pc, #100]	; (1c38 <storage_configure()+0x2a0>)
    1bd2:	ldr	r0, [pc, #84]	; (1c28 <storage_configure()+0x290>)
    1bd4:	bl	1810 <Print::print(char const*)>

            diskSpace[ii]=diskSize[ii]=sdx[ii].sdfs.freeClusterCount();
    1bd8:	mov	r0, r7
    1bda:	bl	1834 <FsVolume::freeClusterCount() const>
    1bde:	ldr	r3, [pc, #112]	; (1c50 <storage_configure()+0x2b8>)
    1be0:	str	r0, [r5, r3]
    1be2:	ldr	r3, [pc, #112]	; (1c54 <storage_configure()+0x2bc>)
    1be4:	mov	r1, r0
    1be6:	str	r0, [r5, r3]
            Serial.println(diskSize[ii]) ;Serial.print(" ");
    1be8:	ldr	r0, [pc, #60]	; (1c28 <storage_configure()+0x290>)
    1bea:	bl	1820 <Print::println(unsigned long)>
    1bee:	ldr	r1, [pc, #72]	; (1c38 <storage_configure()+0x2a0>)
    1bf0:	ldr	r0, [pc, #52]	; (1c28 <storage_configure()+0x290>)
    1bf2:	bl	1810 <Print::print(char const*)>
    #endif

    // Set Time callback
    FsDateTime::callback = dateTime;

    for(int ii=0; ii<nsd; ii++)
    1bf6:	adds	r6, #1
    1bf8:	cmp	r6, #7
    1bfa:	add.w	r4, r4, #1224	; 0x4c8
    1bfe:	bne.w	19a8 <storage_configure()+0x10>
            diskSize[ii]=0;
            diskSpace[ii]=0;
            clusterSize[ii]=1;
      }
    }
}
    1c02:	add	sp, #60	; 0x3c
    1c04:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            diskSpace[ii]=diskSize[ii]=sdx[ii].sdfs.freeClusterCount();
            Serial.println(diskSize[ii]) ;Serial.print(" ");
      }
      else
      {
            diskSize[ii]=0;
    1c08:	ldr	r2, [pc, #68]	; (1c50 <storage_configure()+0x2b8>)
    1c0a:	movs	r3, #0
    1c0c:	str	r3, [r5, r2]
            diskSpace[ii]=0;
    1c0e:	ldr	r2, [pc, #68]	; (1c54 <storage_configure()+0x2bc>)
    1c10:	str	r3, [r5, r2]
            clusterSize[ii]=1;
    1c12:	ldr	r3, [pc, #56]	; (1c4c <storage_configure()+0x2b4>)
    1c14:	movs	r2, #1
    1c16:	str	r2, [r5, r3]
    1c18:	b.n	1bf6 <storage_configure()+0x25e>
    1c1a:	nop
    1c1c:	.word	0x1fff8418
    1c20:	.word	0x000016b7
    1c24:	.word	0x1fff2468
    1c28:	.word	0x1fff1368
    1c2c:	.word	0x00012004
    1c30:	.word	0x01f78a40
    1c34:	.word	0x1fff4ea8
    1c38:	.word	0x00012058
    1c3c:	.word	0x00012030
    1c40:	.word	0x00012020
    1c44:	.word	0x1fff0f44
    1c48:	.word	0x0001203f
    1c4c:	.word	0x1fff463c
    1c50:	.word	0x1fff2238
    1c54:	.word	0x1fff221c

00001c58 <listDisks()>:
      }
    }
}

void listDisks(void)
{
    1c58:	push	{r0, r1, r2, r4, r5, lr}
    for(int ii=0;ii<nsd;ii++)
    {
        Serial.print("\n"); 
        Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]);
    1c5a:	ldr	r5, [pc, #84]	; (1cb0 <listDisks()+0x58>)
    }
}

void listDisks(void)
{
    for(int ii=0;ii<nsd;ii++)
    1c5c:	movs	r4, #0
    {
        Serial.print("\n"); 
    1c5e:	ldr	r1, [pc, #84]	; (1cb4 <listDisks()+0x5c>)
    1c60:	ldr	r0, [pc, #84]	; (1cb8 <listDisks()+0x60>)
    1c62:	bl	1810 <Print::print(char const*)>
        Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]);
    1c66:	ldr	r3, [pc, #84]	; (1cbc <listDisks()+0x64>)
    1c68:	ldr	r1, [pc, #84]	; (1cc0 <listDisks()+0x68>)
    1c6a:	ldr.w	r3, [r3, r4, lsl #2]
    1c6e:	str	r3, [sp, #0]
    1c70:	mov	r2, r4
    1c72:	ldr.w	r3, [r5, r4, lsl #2]
    1c76:	ldr	r0, [pc, #64]	; (1cb8 <listDisks()+0x60>)
    1c78:	bl	99cc <Print::printf(char const*, ...)>
        Serial.printf("%d %d",sdx[ii].sdfs.freeClusterCount(),diskSize[ii]);
    1c7c:	ldr	r0, [pc, #68]	; (1cc4 <listDisks()+0x6c>)
    1c7e:	mov.w	r3, #1224	; 0x4c8
    1c82:	mla	r0, r3, r4, r0
    1c86:	adds	r0, #4
    1c88:	bl	1834 <FsVolume::freeClusterCount() const>
    1c8c:	ldr	r3, [pc, #56]	; (1cc8 <listDisks()+0x70>)
    1c8e:	ldr	r1, [pc, #60]	; (1ccc <listDisks()+0x74>)
    1c90:	ldr.w	r3, [r3, r4, lsl #2]
    1c94:	mov	r2, r0
    }
}

void listDisks(void)
{
    for(int ii=0;ii<nsd;ii++)
    1c96:	adds	r4, #1
    {
        Serial.print("\n"); 
        Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]);
        Serial.printf("%d %d",sdx[ii].sdfs.freeClusterCount(),diskSize[ii]);
    1c98:	ldr	r0, [pc, #28]	; (1cb8 <listDisks()+0x60>)
    1c9a:	bl	99cc <Print::printf(char const*, ...)>
    }
}

void listDisks(void)
{
    for(int ii=0;ii<nsd;ii++)
    1c9e:	cmp	r4, #7
    1ca0:	bne.n	1c5e <listDisks()+0x6>
    {
        Serial.print("\n"); 
        Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]);
        Serial.printf("%d %d",sdx[ii].sdfs.freeClusterCount(),diskSize[ii]);
    }
    Serial.print("\n"); 
    1ca2:	ldr	r1, [pc, #16]	; (1cb4 <listDisks()+0x5c>)
    1ca4:	ldr	r0, [pc, #16]	; (1cb8 <listDisks()+0x60>)
    1ca6:	bl	1810 <Print::print(char const*)>
}
    1caa:	add	sp, #12
    1cac:	pop	{r4, r5, pc}
    1cae:	nop
    1cb0:	.word	0x00012004
    1cb4:	.word	0x00012580
    1cb8:	.word	0x1fff1368
    1cbc:	.word	0x1fff0f44
    1cc0:	.word	0x0001203f
    1cc4:	.word	0x1fff2468
    1cc8:	.word	0x1fff2238
    1ccc:	.word	0x00012051

00001cd0 <checkReboot()>:
{
    int ii=0;
    while((ii<nsd) && (diskSpace[ii]<MIN_SPACE)) ii++;
    if(ii<nsd) CPU_RESTART;
    return -1;
}
    1cd0:	mov.w	r0, #4294967295
    1cd4:	bx	lr
    1cd6:	Address 0x00001cd6 is out of bounds.


00001cd8 <saveData(short)>:
    return 1;
}

/* main data filing routine */
int16_t saveData(int16_t status)
{   static char dirName[80];
    1cd8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    static char fileName[80];
    static char header[512];
    static int dirFlag=0;

    if(status<CLOSED) return status; // we are stopped: don't do anything
    1cdc:	subs	r4, r0, #0
    return 1;
}

/* main data filing routine */
int16_t saveData(int16_t status)
{   static char dirName[80];
    1cde:	sub	sp, #84	; 0x54
    static char fileName[80];
    static char header[512];
    static int dirFlag=0;

    if(status<CLOSED) return status; // we are stopped: don't do anything
    1ce0:	blt.w	1e9e <saveData(short)+0x1c6>

    //fetch data from circular buffer
    if(pullData(diskBuffer,NDBL))
    1ce4:	movs	r1, #2
    1ce6:	ldr	r0, [pc, #672]	; (1f88 <saveData(short)+0x2b0>)
    1ce8:	bl	191c <pullData(unsigned long*, unsigned long)>
    1cec:	cmp	r0, #0
    1cee:	beq.n	1de8 <saveData(short)+0x110>
    {   disk_count++;
    1cf0:	ldr	r2, [pc, #664]	; (1f8c <saveData(short)+0x2b4>)
    1cf2:	ldr	r3, [r2, #0]
    1cf4:	adds	r3, #1
    1cf6:	str	r3, [r2, #0]
        if(status==CLOSED) // file closed: should open
    1cf8:	cbnz	r4, 1d3c <saveData(short)+0x64>
        bool doTransactions=true;

};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}
    1cfa:	ldr	r3, [pc, #660]	; (1f90 <saveData(short)+0x2b8>)

static SDClass *checkDiskSpace(void)
{   static int isd_ = nsd;

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
    1cfc:	ldr	r7, [pc, #660]	; (1f94 <saveData(short)+0x2bc>)
    1cfe:	ldr.w	r9, [pc, #744]	; 1fe8 <saveData(short)+0x310>
        bool doTransactions=true;

};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}
    1d02:	movs	r2, #1
    1d04:	strb	r2, [r3, #8]
    1d06:	mov	r8, r3
    1d08:	mov	r5, r7

static SDClass *checkDiskSpace(void)
{   static int isd_ = nsd;

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
    1d0a:	ldr	r4, [r7, #0]
    1d0c:	ldr	r6, [pc, #644]	; (1f94 <saveData(short)+0x2bc>)
    1d0e:	cmp	r4, #6
    1d10:	bgt.n	1e10 <saveData(short)+0x138>
    1d12:	ldr.w	r3, [r9, r4, lsl #2]
    1d16:	cmp	r3, #0
    1d18:	beq.w	1ea2 <saveData(short)+0x1ca>
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    1d1c:	ldr	r0, [pc, #632]	; (1f98 <saveData(short)+0x2c0>)
    1d1e:	mov.w	r3, #1224	; 0x4c8
    1d22:	mla	r0, r3, r4, r0
    1d26:	adds	r0, #4
    1d28:	bl	1834 <FsVolume::freeClusterCount() const>
    1d2c:	ldr	r3, [pc, #620]	; (1f9c <saveData(short)+0x2c4>)
    1d2e:	cmp.w	r0, #153600	; 0x25800
    1d32:	str.w	r0, [r3, r4, lsl #2]
    1d36:	bcc.w	1ea2 <saveData(short)+0x1ca>
    1d3a:	b.n	1e10 <saveData(short)+0x138>
            {
               return MUST_REBOOT; // if file open fails: don't do anything
            }
        }
        //
        if(status==OPENED) // file is open: write first record (header)
    1d3c:	cmp	r4, #1
    1d3e:	bne.n	1dce <saveData(short)+0xf6>
     * @param header is pointer to header
     * 
     */
    #define MAGIC "WMXZ"
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    1d40:	bl	8d18 <rtc_get>
    1d44:	add	r1, sp, #24
    1d46:	bl	1368 <breakTime(unsigned long, tmElements_t&)>

    int nd=sprintf(header,"%s%04d%02d%02d_%02d%02d%02d",
            MAGIC,tmYearToCalendar(tm.Year),tm.Month,tm.Day,tm.Hour,tm.Minute,tm.Second);
    1d4a:	ldrb.w	r2, [sp, #24]
    1d4e:	str	r2, [sp, #16]
    1d50:	ldrb.w	r2, [sp, #25]
    1d54:	str	r2, [sp, #12]
    1d56:	ldrb.w	r2, [sp, #26]
    1d5a:	ldr	r5, [pc, #580]	; (1fa0 <saveData(short)+0x2c8>)
    1d5c:	ldrb.w	r3, [sp, #30]
    1d60:	str	r2, [sp, #8]
    1d62:	ldrb.w	r2, [sp, #28]
    1d66:	str	r2, [sp, #4]
    1d68:	ldrb.w	r2, [sp, #29]
    1d6c:	str	r2, [sp, #0]
    1d6e:	addw	r3, r3, #1970	; 0x7b2
    1d72:	ldr	r2, [pc, #560]	; (1fa4 <saveData(short)+0x2cc>)
    1d74:	ldr	r1, [pc, #560]	; (1fa8 <saveData(short)+0x2d0>)
    1d76:	mov	r0, r5
    1d78:	bl	b668 <sprintf>
    char *ptr = header+(nd+1);
    1d7c:	adds	r0, #1

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    1d7e:	movs	r2, #4
    1d80:	str	r2, [r5, r0]
    iptr[1] = (int32_t)SerNum;      // serial number
    1d82:	ldr	r2, [pc, #552]	; (1fac <saveData(short)+0x2d4>)
    tmElements_t tm;
    breakTime(rtc_get(), tm);

    int nd=sprintf(header,"%s%04d%02d%02d_%02d%02d%02d",
            MAGIC,tmYearToCalendar(tm.Year),tm.Month,tm.Day,tm.Hour,tm.Minute,tm.Second);
    char *ptr = header+(nd+1);
    1d84:	adds	r3, r5, r0

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    iptr[1] = (int32_t)SerNum;      // serial number
    1d86:	ldr	r2, [r2, #0]
    1d88:	str	r2, [r3, #4]
    iptr[2] = FSAMP;
    1d8a:	movw	r2, #48000	; 0xbb80
    1d8e:	str	r2, [r3, #8]
    iptr[3] = NCHAN_ACQ;
    iptr[4] = t_acq;
    1d90:	ldr	r2, [pc, #540]	; (1fb0 <saveData(short)+0x2d8>)
    1d92:	ldr	r2, [r2, #0]
    1d94:	str	r2, [r3, #16]

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    iptr[1] = (int32_t)SerNum;      // serial number
    iptr[2] = FSAMP;
    iptr[3] = NCHAN_ACQ;
    1d96:	movs	r4, #2
    iptr[4] = t_acq;
    iptr[5] = 0;
    1d98:	movs	r2, #0

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    iptr[1] = (int32_t)SerNum;      // serial number
    iptr[2] = FSAMP;
    iptr[3] = NCHAN_ACQ;
    1d9a:	str	r4, [r3, #12]
    iptr[4] = t_acq;
    iptr[5] = 0;
    1d9c:	str	r2, [r3, #20]

    uint32_t *uptr = (uint32_t*) header;
    uptr[127] = 0x55555555;
    1d9e:	movs	r3, #85	; 0x55
    1da0:	strb.w	r3, [r5, #508]	; 0x1fc
    1da4:	strb.w	r3, [r5, #509]	; 0x1fd
    1da8:	strb.w	r3, [r5, #510]	; 0x1fe
    1dac:	strb.w	r3, [r5, #511]	; 0x1ff
    1db0:	ldr	r3, [pc, #512]	; (1fb4 <saveData(short)+0x2dc>)
    1db2:	ldr	r0, [r3, #16]
	virtual size_t write(const uint8_t *buf, size_t size) {
		return (f) ? f->write((void*)buf, size) : 0;
	}

	size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    1db4:	cbnz	r0, 1dbc <saveData(short)+0xe4>
                file = msd->open(fileName, FILE_WRITE_BEGIN); 
                if(file) 
                    status = OPENED; 
                else 
                {   Serial.println("Failing open file");
                    return MUST_REBOOT; 
    1db6:	mvn.w	r0, #1
    1dba:	b.n	20c6 <saveData(short)+0x3ee>
    1dbc:	ldr	r3, [r0, #0]
    1dbe:	mov.w	r2, #512	; 0x200
    1dc2:	ldr	r3, [r3, #12]
    1dc4:	mov	r1, r5
    1dc6:	blx	r3
            }
        }
        //
        if(status==OPENED) // file is open: write first record (header)
        {   makeHeader(header);
            if(file.write((const void*)header,512) < 512) return MUST_REBOOT; else status=2;
    1dc8:	cmp.w	r0, #512	; 0x200
    1dcc:	bcc.n	1db6 <saveData(short)+0xde>
    1dce:	ldr	r3, [pc, #484]	; (1fb4 <saveData(short)+0x2dc>)
    1dd0:	ldr	r0, [r3, #16]
    1dd2:	cmp	r0, #0
    1dd4:	beq.n	1db6 <saveData(short)+0xde>
    1dd6:	ldr	r3, [r0, #0]
    1dd8:	ldr	r1, [pc, #428]	; (1f88 <saveData(short)+0x2b0>)
    1dda:	ldr	r3, [r3, #12]
    1ddc:	mov.w	r2, #2048	; 0x800
    1de0:	blx	r3
        }
        //
        if(status>=RUNNING) // file is open, header written: store data records
        {   
            if(file.write((const void *)diskBuffer,4*MAX_DISK_BUFFER) < 4*MAX_DISK_BUFFER) return MUST_REBOOT;
    1de2:	cmp.w	r0, #2048	; 0x800
    1de6:	bcc.n	1db6 <saveData(short)+0xde>
        }
    }
    // following is done independent of data availability
    if(status==DOCLOSE) // should close file
    1de8:	cmp	r4, #3
    1dea:	bne.n	1dfa <saveData(short)+0x122>
    {
        // writes are done, so enable again transaction activations
        file.flush();
    1dec:	ldr	r0, [pc, #452]	; (1fb4 <saveData(short)+0x2dc>)
    1dee:	bl	83a <File::flush()>
        file.close();
    1df2:	ldr	r0, [pc, #448]	; (1fb4 <saveData(short)+0x2dc>)
    1df4:	bl	dac <File::close()>
    1df8:	b.n	1e9a <saveData(short)+0x1c2>
        status = CLOSED;
    }
    if(status==MUSTSTOP) // should close file and stop
    1dfa:	cmp	r4, #4
    1dfc:	bne.n	1e9e <saveData(short)+0x1c6>
    {   
        file.flush();
    1dfe:	ldr	r0, [pc, #436]	; (1fb4 <saveData(short)+0x2dc>)
    1e00:	bl	83a <File::flush()>
        file.close();
    1e04:	ldr	r0, [pc, #428]	; (1fb4 <saveData(short)+0x2dc>)
    1e06:	bl	dac <File::close()>
        status = STOPPED;
    1e0a:	mov.w	r0, #4294967295
    1e0e:	b.n	20c6 <saveData(short)+0x3ee>
        bool doTransactions=true;

};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}
    1e10:	movs	r3, #0
    1e12:	strb.w	r3, [r8, #8]

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    doTransactions(false);
    if(isd<nsd) 
    1e16:	ldr	r3, [r6, #0]
    1e18:	ldr	r4, [pc, #376]	; (1f94 <saveData(short)+0x2bc>)
    1e1a:	cmp	r3, #6
    1e1c:	bgt.n	1e58 <saveData(short)+0x180>
    {   sdx[isd].sdfs.chvol();
    1e1e:	ldr	r5, [pc, #376]	; (1f98 <saveData(short)+0x2c0>)
    bool chdir(const char* path) {
    return m_fVol ? m_fVol->chdir(path) :
           m_xVol ? m_xVol->chdir(path) : false;
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
    1e20:	ldr	r2, [pc, #404]	; (1fb8 <saveData(short)+0x2e0>)
        Serial.println(); Serial.print(isd);
    1e22:	ldr	r0, [pc, #408]	; (1fbc <saveData(short)+0x2e4>)
    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    doTransactions(false);
    if(isd<nsd) 
    {   sdx[isd].sdfs.chvol();
    1e24:	mov.w	r7, #1224	; 0x4c8
    1e28:	mla	r3, r7, r3, r5
    1e2c:	adds	r3, #4
    1e2e:	str	r3, [r2, #0]
        Serial.println(); Serial.print(isd);
    1e30:	bl	99ac <Print::println()>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    1e34:	ldr	r1, [r4, #0]
    1e36:	ldr	r0, [pc, #388]	; (1fbc <saveData(short)+0x2e4>)
    1e38:	bl	9a5c <Print::print(long)>
        Serial.print(": "); Serial.print(sdx[isd].sdfs.freeClusterCount());
    1e3c:	ldr	r1, [pc, #384]	; (1fc0 <saveData(short)+0x2e8>)
    1e3e:	ldr	r0, [pc, #380]	; (1fbc <saveData(short)+0x2e4>)
    1e40:	bl	1810 <Print::print(char const*)>
    1e44:	ldr	r0, [r4, #0]
    1e46:	mla	r0, r7, r0, r5
    1e4a:	adds	r0, #4
    1e4c:	bl	1834 <FsVolume::freeClusterCount() const>
    1e50:	mov	r1, r0
    1e52:	ldr	r0, [pc, #360]	; (1fbc <saveData(short)+0x2e4>)
    1e54:	bl	1818 <Print::print(unsigned long)>
    }
    //
    if(isd != isd_) hour_=0; // set hour_ to zero to trigger creation of directories in new disk
    1e58:	ldr	r2, [pc, #360]	; (1fc4 <saveData(short)+0x2ec>)
    1e5a:	ldr	r3, [r6, #0]
    1e5c:	ldr	r1, [r2, #0]
    isd_=isd;
    1e5e:	str	r3, [r2, #0]
    {   sdx[isd].sdfs.chvol();
        Serial.println(); Serial.print(isd);
        Serial.print(": "); Serial.print(sdx[isd].sdfs.freeClusterCount());
    }
    //
    if(isd != isd_) hour_=0; // set hour_ to zero to trigger creation of directories in new disk
    1e60:	cmp	r3, r1
    1e62:	it	ne
    1e64:	ldrne	r1, [pc, #352]	; (1fc8 <saveData(short)+0x2f0>)
    //fetch data from circular buffer
    if(pullData(diskBuffer,NDBL))
    {   disk_count++;
        if(status==CLOSED) // file closed: should open
        {   //doTransactions(true);
            if(!(msd=checkDiskSpace())) return MUST_REBOOT;
    1e66:	ldr	r5, [pc, #356]	; (1fcc <saveData(short)+0x2f4>)
    {   sdx[isd].sdfs.chvol();
        Serial.println(); Serial.print(isd);
        Serial.print(": "); Serial.print(sdx[isd].sdfs.freeClusterCount());
    }
    //
    if(isd != isd_) hour_=0; // set hour_ to zero to trigger creation of directories in new disk
    1e68:	itt	ne
    1e6a:	movne	r0, #0
    1e6c:	strne	r0, [r1, #0]
    isd_=isd;
    if(isd==nsd) return (SDClass *) 0; else return &sdx[isd];
    1e6e:	cmp	r3, #7
    1e70:	ittte	ne
    1e72:	ldrne	r2, [pc, #292]	; (1f98 <saveData(short)+0x2c0>)
    1e74:	movne.w	r1, #1224	; 0x4c8
    1e78:	mlane	r3, r1, r3, r2
    1e7c:	moveq	r3, #0
    //fetch data from circular buffer
    if(pullData(diskBuffer,NDBL))
    {   disk_count++;
        if(status==CLOSED) // file closed: should open
        {   //doTransactions(true);
            if(!(msd=checkDiskSpace())) return MUST_REBOOT;
    1e7e:	str	r3, [r5, #0]
    1e80:	cmp	r3, #0
    1e82:	beq.n	1db6 <saveData(short)+0xde>
            //
            if(newDirectory(dirName,dirFlag)) 
    1e84:	ldr	r4, [pc, #328]	; (1fd0 <saveData(short)+0x2f8>)
    1e86:	ldr	r7, [r4, #0]
    isd_=isd;
    if(isd==nsd) return (SDClass *) 0; else return &sdx[isd];
}

static int16_t newDirectory(char *dirName, int dirFlag)
{ if(newHour())
    1e88:	bl	1344 <newHour()>
    1e8c:	cbnz	r0, 1eaa <saveData(short)+0x1d2>
            if(newDirectory(dirName,dirFlag)) 
            {   if(!msd->sdfs.exists(dirName) && !msd->sdfs.mkdir(dirName)) dirFlag++;          
                if(!msd->sdfs.chdir(dirName)) dirFlag++; else dirFlag=0;
            }
            //
            if(dirFlag>5) return MUST_REBOOT;   // too many directory errors
    1e8e:	ldr	r3, [r4, #0]
    1e90:	cmp	r3, #5
    1e92:	bgt.n	1db6 <saveData(short)+0xde>
            if(dirFlag>0) return CLOSED;        // create new directory with different name
    1e94:	cmp	r3, #0
    1e96:	ble.w	2036 <saveData(short)+0x35e>
    1e9a:	movs	r0, #0
    1e9c:	b.n	20c6 <saveData(short)+0x3ee>
    1e9e:	mov	r0, r4
    1ea0:	b.n	20c6 <saveData(short)+0x3ee>
static SDClass *checkDiskSpace(void)
{   static int isd_ = nsd;

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    1ea2:	ldr	r3, [r5, #0]
    1ea4:	adds	r3, #1
    1ea6:	str	r3, [r5, #0]
    1ea8:	b.n	1d0a <saveData(short)+0x32>

static int16_t newDirectory(char *dirName, int dirFlag)
{ if(newHour())
    {   
        tmElements_t tm;
        breakTime(rtc_get(), tm);
    1eaa:	bl	8d18 <rtc_get>
    1eae:	add	r1, sp, #24
    1eb0:	bl	1368 <breakTime(unsigned long, tmElements_t&)>
    1eb4:	ldr	r2, [pc, #244]	; (1fac <saveData(short)+0x2d4>)
    1eb6:	ldrb.w	lr, [sp, #26]
    1eba:	ldrb.w	r0, [sp, #28]
    1ebe:	ldrb.w	r1, [sp, #29]
    1ec2:	ldrb.w	r3, [sp, #30]
        if(!dirFlag)
    1ec6:	cbnz	r7, 1ee4 <saveData(short)+0x20c>
        {
            sprintf(dirName, "/%s%06x_%04d%02d%02d/%02d/", 
                          DirPrefix,(unsigned int)SerNum,
                                  tmYearToCalendar(tm.Year),tm.Month, tm.Day, tm.Hour);
    1ec8:	addw	r3, r3, #1970	; 0x7b2
    1ecc:	str	r0, [sp, #8]
    1ece:	str	r1, [sp, #4]
    1ed0:	str.w	lr, [sp, #12]
    1ed4:	str	r3, [sp, #0]
    1ed6:	ldr	r3, [r2, #0]
    1ed8:	ldr	r1, [pc, #248]	; (1fd4 <saveData(short)+0x2fc>)
    1eda:	ldr	r2, [pc, #252]	; (1fd8 <saveData(short)+0x300>)
    1edc:	ldr	r0, [pc, #252]	; (1fdc <saveData(short)+0x304>)
    1ede:	bl	b668 <sprintf>
    1ee2:	b.n	1f00 <saveData(short)+0x228>
        }
        else
        {
            sprintf(dirName, "/%s%06x_%04d%02d%02d/%02d_%02d/", 
                          DirPrefix,(unsigned int)SerNum,
                                  tmYearToCalendar(tm.Year),tm.Month, tm.Day, tm.Hour,dirFlag);
    1ee4:	addw	r3, r3, #1970	; 0x7b2
    1ee8:	str	r0, [sp, #8]
    1eea:	str	r1, [sp, #4]
    1eec:	str	r7, [sp, #16]
    1eee:	str.w	lr, [sp, #12]
    1ef2:	str	r3, [sp, #0]
    1ef4:	ldr	r3, [r2, #0]
    1ef6:	ldr	r1, [pc, #232]	; (1fe0 <saveData(short)+0x308>)
    1ef8:	ldr	r2, [pc, #220]	; (1fd8 <saveData(short)+0x300>)
    1efa:	ldr	r0, [pc, #224]	; (1fdc <saveData(short)+0x304>)
    1efc:	bl	b668 <sprintf>
        }

        //
        Serial.print("\n"); Serial.print(dirName);
    1f00:	ldr	r1, [pc, #224]	; (1fe4 <saveData(short)+0x30c>)
    1f02:	ldr	r0, [pc, #184]	; (1fbc <saveData(short)+0x2e4>)
    1f04:	bl	1810 <Print::print(char const*)>
    1f08:	ldr	r1, [pc, #208]	; (1fdc <saveData(short)+0x304>)
    1f0a:	ldr	r0, [pc, #176]	; (1fbc <saveData(short)+0x2e4>)
    1f0c:	bl	1810 <Print::print(char const*)>
        if(status==CLOSED) // file closed: should open
        {   //doTransactions(true);
            if(!(msd=checkDiskSpace())) return MUST_REBOOT;
            //
            if(newDirectory(dirName,dirFlag)) 
            {   if(!msd->sdfs.exists(dirName) && !msd->sdfs.mkdir(dirName)) dirFlag++;          
    1f10:	ldr	r3, [r5, #0]
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
    1f12:	ldr.w	r1, [r3, #1156]	; 0x484
           m_xVol ? m_xVol->exists(path) : false;
    1f16:	cbz	r1, 1f30 <saveData(short)+0x258>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    1f18:	movs	r3, #0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    1f1a:	ldr	r2, [pc, #192]	; (1fdc <saveData(short)+0x304>)
    1f1c:	strb.w	r3, [sp, #24]
    1f20:	add	r0, sp, #24
    1f22:	strb.w	r3, [sp, #25]
    1f26:	strb.w	r3, [sp, #26]
    1f2a:	bl	5b8c <FatFile::open(FatVolume*, char const*, int)>
    1f2e:	b.n	1f74 <saveData(short)+0x29c>
    1f30:	ldr.w	r0, [r3, #1160]	; 0x488
    1f34:	cbnz	r0, 1f5c <saveData(short)+0x284>
    1f36:	ldr	r3, [r5, #0]
   * \param[in] pFlag Create missing parent directories if true.
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
    1f38:	ldr.w	r1, [r3, #1156]	; 0x484
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
    1f3c:	cbz	r1, 1f7a <saveData(short)+0x2a2>
    1f3e:	movs	r3, #0
    1f40:	strb.w	r3, [sp, #24]
    1f44:	strb.w	r3, [sp, #25]
    1f48:	strb.w	r3, [sp, #26]
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    1f4c:	ldr	r2, [pc, #140]	; (1fdc <saveData(short)+0x304>)
    1f4e:	movs	r3, #1
    1f50:	add.w	r1, r1, #1096	; 0x448
    1f54:	add	r0, sp, #24
    1f56:	bl	5d08 <FatFile::mkdir(FatFile*, char const*, bool)>
    1f5a:	b.n	2006 <saveData(short)+0x32e>
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    1f5c:	strb.w	r1, [sp, #73]	; 0x49
    1f60:	strb.w	r1, [sp, #74]	; 0x4a
    1f64:	strb.w	r1, [sp, #75]	; 0x4b
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    1f68:	mov	r3, r1
    1f6a:	ldr	r2, [pc, #112]	; (1fdc <saveData(short)+0x304>)
    1f6c:	mov	r1, r0
    1f6e:	add	r0, sp, #24
    1f70:	bl	4046 <ExFatFile::open(ExFatVolume*, char const*, int)>
    1f74:	cmp	r0, #0
    1f76:	bne.n	200a <saveData(short)+0x332>
    1f78:	b.n	1f36 <saveData(short)+0x25e>
    1f7a:	ldr.w	r0, [r3, #1160]	; 0x488
    1f7e:	cbnz	r0, 1fec <saveData(short)+0x314>
    1f80:	ldr	r3, [r4, #0]
    1f82:	adds	r3, #1
    1f84:	str	r3, [r4, #0]
    1f86:	b.n	200a <saveData(short)+0x332>
    1f88:	.word	0x1fff76b8
    1f8c:	.word	0x1fff76b4
    1f90:	.word	0x1fff4ea8
    1f94:	.word	0x1fff0f40
    1f98:	.word	0x1fff2468
    1f9c:	.word	0x1fff221c
    1fa0:	.word	0x1fff2268
    1fa4:	.word	0x000120bf
    1fa8:	.word	0x000120c4
    1fac:	.word	0x1fff7eb8
    1fb0:	.word	0x1fff0f38
    1fb4:	.word	0x1fff2254
    1fb8:	.word	0x1fff8424
    1fbc:	.word	0x1fff1368
    1fc0:	.word	0x00012057
    1fc4:	.word	0x1fff0f3c
    1fc8:	.word	0x1fff2214
    1fcc:	.word	0x1fff2218
    1fd0:	.word	0x1fff4630
    1fd4:	.word	0x0001205c
    1fd8:	.word	0x0001205a
    1fdc:	.word	0x1fff4658
    1fe0:	.word	0x00012077
    1fe4:	.word	0x00012580
    1fe8:	.word	0x1fff2238
    1fec:	strb.w	r1, [sp, #73]	; 0x49
    1ff0:	strb.w	r1, [sp, #74]	; 0x4a
    1ff4:	strb.w	r1, [sp, #75]	; 0x4b
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    1ff8:	movs	r3, #1
    1ffa:	add.w	r1, r0, #1096	; 0x448
    1ffe:	ldr	r2, [pc, #204]	; (20cc <saveData(short)+0x3f4>)
    2000:	add	r0, sp, #24
    2002:	bl	48e8 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
    2006:	cmp	r0, #0
    2008:	beq.n	1f80 <saveData(short)+0x2a8>
                if(!msd->sdfs.chdir(dirName)) dirFlag++; else dirFlag=0;
    200a:	ldr	r3, [r5, #0]
   * Set volume working directory.
   * \param[in] path Path for volume working directory.
   * \return true for success or false for failure.
   */
    bool chdir(const char* path) {
    return m_fVol ? m_fVol->chdir(path) :
    200c:	ldr.w	r0, [r3, #1156]	; 0x484
           m_xVol ? m_xVol->chdir(path) : false;
    2010:	cbz	r0, 201a <saveData(short)+0x342>
    2012:	ldr	r1, [pc, #184]	; (20cc <saveData(short)+0x3f4>)
    2014:	bl	6588 <FatVolume::chdir(char const*)>
    2018:	b.n	202c <saveData(short)+0x354>
    201a:	ldr.w	r0, [r3, #1160]	; 0x488
    201e:	cbnz	r0, 2026 <saveData(short)+0x34e>
    2020:	ldr	r3, [r4, #0]
    2022:	adds	r3, #1
    2024:	b.n	2032 <saveData(short)+0x35a>
    2026:	ldr	r1, [pc, #164]	; (20cc <saveData(short)+0x3f4>)
    2028:	bl	4490 <ExFatVolume::chdir(char const*)>
    202c:	cmp	r0, #0
    202e:	beq.n	2020 <saveData(short)+0x348>
    2030:	movs	r3, #0
    2032:	str	r3, [r4, #0]
    2034:	b.n	1e8e <saveData(short)+0x1b6>

}
static int16_t newFileName(char *fileName)
{
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    2036:	bl	8d18 <rtc_get>
    203a:	add	r1, sp, #24
    203c:	bl	1368 <breakTime(unsigned long, tmElements_t&)>
	sprintf(fileName, "%s_%02d%02d%02d.bin", FilePrefix, tm.Hour, tm.Minute, tm.Second);
    2040:	ldrb.w	r2, [sp, #24]
    2044:	str	r2, [sp, #4]
    2046:	ldrb.w	r2, [sp, #25]
    204a:	ldrb.w	r3, [sp, #26]
    204e:	str	r2, [sp, #0]
    2050:	ldr	r1, [pc, #124]	; (20d0 <saveData(short)+0x3f8>)
    2052:	ldr	r2, [pc, #128]	; (20d4 <saveData(short)+0x3fc>)
    2054:	ldr	r0, [pc, #128]	; (20d8 <saveData(short)+0x400>)
    2056:	bl	b668 <sprintf>
    //
    Serial.print("\n"); Serial.print(isd); Serial.print(": ");Serial.print(fileName);
    205a:	ldr	r1, [pc, #128]	; (20dc <saveData(short)+0x404>)
    205c:	ldr	r0, [pc, #128]	; (20e0 <saveData(short)+0x408>)
    205e:	bl	1810 <Print::print(char const*)>
    2062:	ldr	r1, [r6, #0]
    2064:	ldr	r0, [pc, #120]	; (20e0 <saveData(short)+0x408>)
    2066:	bl	9a5c <Print::print(long)>
    206a:	ldr	r1, [pc, #120]	; (20e4 <saveData(short)+0x40c>)
    206c:	ldr	r0, [pc, #112]	; (20e0 <saveData(short)+0x408>)
    206e:	bl	1810 <Print::print(char const*)>
    2072:	ldr	r1, [pc, #100]	; (20d8 <saveData(short)+0x400>)
    2074:	ldr	r0, [pc, #104]	; (20e0 <saveData(short)+0x408>)
    2076:	bl	1810 <Print::print(char const*)>
            if(dirFlag>5) return MUST_REBOOT;   // too many directory errors
            if(dirFlag>0) return CLOSED;        // create new directory with different name

            if(newFileName(fileName))
            {   
                file = msd->open(fileName, FILE_WRITE_BEGIN); 
    207a:	ldr	r1, [r5, #0]
    207c:	ldr	r2, [pc, #88]	; (20d8 <saveData(short)+0x400>)
    207e:	ldr	r3, [r1, #0]
    2080:	add	r0, sp, #24
    2082:	ldr	r4, [r3, #0]
    2084:	movs	r3, #2
    2086:	blx	r4
	}
#ifdef FILE_USE_MOVE
	// Move assignment.
	File& operator = (const File&& file) {
		//Serial.println("File move assignment");
		if (file.f) file.f->refcount++;
    2088:	ldr	r3, [sp, #40]	; 0x28
    208a:	cbz	r3, 2092 <saveData(short)+0x3ba>
    208c:	ldr	r2, [r3, #4]
    208e:	adds	r2, #1
    2090:	str	r2, [r3, #4]
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
    2092:	ldr	r4, [pc, #84]	; (20e8 <saveData(short)+0x410>)
    2094:	ldr	r3, [r4, #16]
    2096:	cbz	r3, 20a0 <saveData(short)+0x3c8>
    2098:	add.w	r0, r4, #16
    209c:	bl	1778 <File::dec_refcount() [clone .isra.23]>
		f = file.f;
    20a0:	ldr	r3, [sp, #40]	; 0x28
    20a2:	str	r3, [r4, #16]
    20a4:	add	r0, sp, #24
    20a6:	bl	9f4 <File::~File()>
    20aa:	ldr	r0, [r4, #16]
			f->close();
			dec_refcount();
		}
	}
	operator bool() {
		return (f) ? f->isOpen() : false;
    20ac:	cbnz	r0, 20b8 <saveData(short)+0x3e0>
                if(file) 
                    status = OPENED; 
                else 
                {   Serial.println("Failing open file");
    20ae:	ldr	r1, [pc, #60]	; (20ec <saveData(short)+0x414>)
    20b0:	ldr	r0, [pc, #44]	; (20e0 <saveData(short)+0x408>)
    20b2:	bl	6b8 <Print::println(char const*)>
    20b6:	b.n	1db6 <saveData(short)+0xde>
    20b8:	ldr	r3, [r0, #0]
    20ba:	ldr	r3, [r3, #48]	; 0x30
    20bc:	blx	r3
            if(dirFlag>0) return CLOSED;        // create new directory with different name

            if(newFileName(fileName))
            {   
                file = msd->open(fileName, FILE_WRITE_BEGIN); 
                if(file) 
    20be:	cmp	r0, #0
    20c0:	bne.w	1d40 <saveData(short)+0x68>
    20c4:	b.n	20ae <saveData(short)+0x3d6>
        file.flush();
        file.close();
        status = STOPPED;
    }
    return status;
}
    20c6:	add	sp, #84	; 0x54
    20c8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    20cc:	.word	0x1fff4658
    20d0:	.word	0x00012099
    20d4:	.word	0x00012097
    20d8:	.word	0x1fff45e0
    20dc:	.word	0x00012580
    20e0:	.word	0x1fff1368
    20e4:	.word	0x00012057
    20e8:	.word	0x1fff2254
    20ec:	.word	0x000120ad

000020f0 <_GLOBAL__sub_I_data_buffer>:
    20f0:	push	{r3, r4, r5, r6, r7, lr}
            { /**
             * @brief Constructor
             * @param buffer is pointer to data store
             * 
             */
                data_buffer=buffer; front_=rear_=0;
    20f2:	ldr	r3, [pc, #144]	; (2184 <_GLOBAL__sub_I_data_buffer+0x94>)
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    20f4:	ldr	r0, [pc, #144]	; (2188 <_GLOBAL__sub_I_data_buffer+0x98>)
    20f6:	ldr	r2, [pc, #148]	; (218c <_GLOBAL__sub_I_data_buffer+0x9c>)
    20f8:	str	r2, [r3, #4]
    20fa:	movs	r4, #0
    20fc:	strh	r4, [r3, #2]
    20fe:	strh	r4, [r3, #0]
    2100:	mov.w	r3, #1000	; 0x3e8
    2104:	strb	r4, [r0, #4]
    2106:	str	r3, [r0, #8]
    2108:	strb	r4, [r0, #12]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
    210a:	ldr	r3, [pc, #132]	; (2190 <_GLOBAL__sub_I_data_buffer+0xa0>)

/****************************** Filing Utility *******************************************/

extern int t_acq;

File file=NULL; // is used by saveData and saveNAD
    210c:	ldr	r2, [pc, #132]	; (2194 <_GLOBAL__sub_I_data_buffer+0xa4>)
    210e:	ldr	r1, [pc, #136]	; (2198 <_GLOBAL__sub_I_data_buffer+0xa8>)
    2110:	str	r3, [r0, #0]
		f = file;
    2112:	str	r4, [r0, #16]
    2114:	bl	9cdc <__aeabi_atexit>
// This is a simple driver based on the the standard SPI.h library.
// You can write a driver entirely independent of SPI.h.
// It can be optimized for your board or a different SPI port can be used.
// The driver must be derived from SdSpiBaseClass.
// See: SdFat/src/SpiDriver/SdSpiBaseClass.h
class MySpiClass : public SdSpiBaseClass {
    2118:	ldr	r3, [pc, #128]	; (219c <_GLOBAL__sub_I_data_buffer+0xac>)
    211a:	ldr	r2, [pc, #132]	; (21a0 <_GLOBAL__sub_I_data_buffer+0xb0>)
    211c:	str	r2, [r3, #0]
    211e:	movs	r1, #1
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
		}
		ctar = c | t;
    2120:	ldr	r2, [pc, #128]	; (21a4 <_GLOBAL__sub_I_data_buffer+0xb4>)
    2122:	str	r2, [r3, #4]
    2124:	strb	r1, [r3, #8]


class SDClass : public FS
{
public:
	SDClass() { }
    2126:	ldr.w	lr, [pc, #148]	; 21bc <_GLOBAL__sub_I_data_buffer+0xcc>
    const char *sd_str[]={"sdio",   "sd1","sd2","sd3","sd4","sd5","sd6"};
    const int cs[] = {BUILTIN_SDCARD,  34,   33,   35,   36,   37,  38 };

    const int nsd = sizeof(cs)/sizeof(int);

    SDClass sdx[nsd];
    212a:	ldr	r3, [pc, #124]	; (21a8 <_GLOBAL__sub_I_data_buffer+0xb8>)
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    212c:	ldr	r7, [pc, #124]	; (21ac <_GLOBAL__sub_I_data_buffer+0xbc>)
#else  // HAS_SDIO_CLASS
class SdSpiCard {
#endif  // HAS_SDIO_CLASS
 public:
  /** Construct an instance of SdSpiCard. */
  SdSpiCard() {}
    212e:	ldr	r6, [pc, #128]	; (21b0 <_GLOBAL__sub_I_data_buffer+0xc0>)
    2130:	ldr	r0, [pc, #128]	; (21b4 <_GLOBAL__sub_I_data_buffer+0xc4>)
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() {}
    2132:	mov	r2, r4
    2134:	movs	r5, #41	; 0x29
    2136:	movs	r4, #255	; 0xff
    2138:	str.w	r2, [r3, #1156]	; 0x484
    213c:	str.w	r2, [r3, #1160]	; 0x488
    2140:	str.w	r7, [r3, #1172]	; 0x494
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    2144:	strb.w	r2, [r3, #1180]	; 0x49c
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    2148:	strb.w	r2, [r3, #1181]	; 0x49d
    214c:	str.w	r6, [r3, #1184]	; 0x4a0
    2150:	strb.w	r1, [r3, #1197]	; 0x4ad
    2154:	strb.w	r5, [r3, #1199]	; 0x4af
    2158:	strb.w	r2, [r3, #1202]	; 0x4b2
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    215c:	strb.w	r2, [r3, #1216]	; 0x4c0
    2160:	strb.w	r2, [r3, #1220]	; 0x4c4
    2164:	strb.w	r4, [r3, #1221]	; 0x4c5
    2168:	str.w	lr, [r3]
    216c:	add.w	r3, r3, #1224	; 0x4c8
    2170:	cmp	r3, r0
    2172:	bne.n	2138 <_GLOBAL__sub_I_data_buffer+0x48>
    2174:	ldr	r2, [pc, #28]	; (2194 <_GLOBAL__sub_I_data_buffer+0xa4>)
    2176:	ldr	r1, [pc, #64]	; (21b8 <_GLOBAL__sub_I_data_buffer+0xc8>)
    2178:	movs	r0, #0
        file.flush();
        file.close();
        status = STOPPED;
    }
    return status;
}
    217a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    const char *sd_str[]={"sdio",   "sd1","sd2","sd3","sd4","sd5","sd6"};
    const int cs[] = {BUILTIN_SDCARD,  34,   33,   35,   36,   37,  38 };

    const int nsd = sizeof(cs)/sizeof(int);

    SDClass sdx[nsd];
    217e:	b.w	9cdc <__aeabi_atexit>
    2182:	nop
    2184:	.word	0x1fff4634
    2188:	.word	0x1fff2254
    218c:	.word	0x1fff4eb4
    2190:	.word	0x00011d20
    2194:	.word	0x1fff0f30
    2198:	.word	0x000009f5
    219c:	.word	0x1fff4ea8
    21a0:	.word	0x00011fe4
    21a4:	.word	0x38011001
    21a8:	.word	0x1fff2468
    21ac:	.word	0x00012608
    21b0:	.word	0x000125a8
    21b4:	.word	0x1fff45e0
    21b8:	.word	0x000016b5
    21bc:	.word	0x000122a8

000021c0 <adc_init()>:
    21c0:	bx	lr

000021c2 <adcStatus()>:
int gain=0;

#if ADC_MODEL == CS5381
    void adc_init(void) { }
    void setAGain(int8_t again) {  }
    void adcStatus(void) {  }
    21c2:	bx	lr

000021c4 <_write>:
  int _write(int file, const void *buf, size_t len) {
    // https://forum.pjrc.com/threads/28473-Quick-Guide-Using-printf()-on-Teensy-ARM
    Print *out;
  
    // Send both stdout and stderr to stdPrint
    if (file == stdout->_file || file == stderr->_file) {
    21c4:	ldr	r3, [pc, #48]	; (21f8 <_write+0x34>)
    21c6:	ldr	r3, [r3, #0]
#include "usb_serial.h"
Print *stdPrint = &Serial;

extern "C"
{
  int _write(int file, const void *buf, size_t len) {
    21c8:	push	{r4}
    // https://forum.pjrc.com/threads/28473-Quick-Guide-Using-printf()-on-Teensy-ARM
    Print *out;
  
    // Send both stdout and stderr to stdPrint
    if (file == stdout->_file || file == stderr->_file) {
    21ca:	ldr	r4, [r3, #8]
    21cc:	ldrsh.w	r4, [r4, #14]
    21d0:	cmp	r4, r0
    21d2:	beq.n	21de <_write+0x1a>
    21d4:	ldr	r3, [r3, #12]
    21d6:	ldrsh.w	r3, [r3, #14]
    21da:	cmp	r0, r3
    21dc:	bne.n	21e2 <_write+0x1e>
      out = stdPrint;
    21de:	ldr	r3, [pc, #28]	; (21fc <_write+0x38>)
    21e0:	ldr	r0, [r3, #0]
    } else {
      out = (Print *)file;
    }
  
    if (out == nullptr) {
    21e2:	cbz	r0, 21ee <_write+0x2a>
      return len;
    }
  
    // Don't check for len == 0 for returning early, in case there's side effects
    return out->write((const uint8_t *)buf, len);
    21e4:	ldr	r3, [r0, #0]
  }
    21e6:	ldr.w	r4, [sp], #4
    if (out == nullptr) {
      return len;
    }
  
    // Don't check for len == 0 for returning early, in case there's side effects
    return out->write((const uint8_t *)buf, len);
    21ea:	ldr	r3, [r3, #4]
    21ec:	bx	r3
  }
    21ee:	mov	r0, r2
    21f0:	ldr.w	r4, [sp], #4
    21f4:	bx	lr
    21f6:	nop
    21f8:	.word	0x1fff1840
    21fc:	.word	0x1fff0f60

00002200 <DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]>:

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    2200:	ldrh	r3, [r0, #30]
    2202:	lsls	r3, r3, #16
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    2204:	itttt	mi
    2206:	ldrhmi	r3, [r0, #30]
    2208:	ubfxmi	r1, r1, #0, #9
    220c:	andmi.w	r3, r3, #65024	; 0xfe00
    2210:	orrmi	r1, r3
#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
    2212:	it	pl
    2214:	ubfxpl	r1, r1, #0, #15
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    2218:	strh	r1, [r0, #30]
	}
	tcd->CITER = tcd->BITER; 
    221a:	ldrh	r3, [r0, #30]
    221c:	uxth	r3, r3
    221e:	strh	r3, [r0, #22]
    2220:	bx	lr
    2222:	Address 0x00002222 is out of bounds.


00002224 <SPIClass::begin()>:
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
	const SPI_Hardware_t & hardware() { return *(const SPI_Hardware_t *)hardware_addr; }
    2224:	ldr	r3, [r0, #4]

void SPIClass::begin()
{
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    2226:	ldr	r1, [r3, #0]
    2228:	ldr	r2, [r3, #4]
SPIClass SPI2((uintptr_t)&KINETISK_SPI2, (uintptr_t)&SPIClass::spi2_hardware);
#endif


void SPIClass::begin()
{
    222a:	push	{r4, lr}
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    222c:	ldr	r4, [r1, #0]
    222e:	orrs	r2, r4
    2230:	str	r2, [r1, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    2232:	ldr	r2, [r0, #0]
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
    2234:	ldr	r1, [pc, #84]	; (228c <SPIClass::begin()+0x68>)
    2236:	str	r1, [r2, #0]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    2238:	ldr	r1, [pc, #84]	; (2290 <SPIClass::begin()+0x6c>)
    223a:	str	r1, [r2, #12]
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    223c:	add.w	r1, r1, #1073741824	; 0x40000000
    2240:	str	r1, [r2, #16]
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
    2242:	ldr	r1, [pc, #80]	; (2294 <SPIClass::begin()+0x70>)
    2244:	str	r1, [r2, #0]
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2246:	ldrb	r1, [r0, #9]
    2248:	ldr	r2, [pc, #76]	; (2298 <SPIClass::begin()+0x74>)
    224a:	adds	r4, r3, r1
	*reg = hardware().mosi_mux[mosi_pin_index];
    224c:	adds	r1, #12
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    224e:	ldrb.w	r4, [r4, #44]	; 0x2c
	*reg = hardware().mosi_mux[mosi_pin_index];
    2252:	ldr.w	r1, [r3, r1, lsl #2]
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2256:	add.w	r4, r2, r4, lsl #3
    225a:	ldr	r4, [r4, #4]
	*reg = hardware().mosi_mux[mosi_pin_index];
    225c:	str	r1, [r4, #0]
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    225e:	ldrb	r1, [r0, #8]
    2260:	adds	r4, r3, r1
	*reg= hardware().miso_mux[miso_pin_index];
    2262:	add.w	r1, r3, r1, lsl #2
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2266:	ldrb	r4, [r4, #24]
	*reg= hardware().miso_mux[miso_pin_index];
    2268:	ldr	r1, [r1, #28]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    226a:	add.w	r4, r2, r4, lsl #3
    226e:	ldr	r4, [r4, #4]
	*reg= hardware().miso_mux[miso_pin_index];
    2270:	str	r1, [r4, #0]
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2272:	ldrb	r1, [r0, #10]
    2274:	adds	r0, r3, r1
	*reg = hardware().sck_mux[sck_pin_index];
    2276:	add.w	r3, r3, r1, lsl #2
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    227a:	ldrb.w	r0, [r0, #64]	; 0x40
	*reg = hardware().sck_mux[sck_pin_index];
    227e:	ldr	r3, [r3, #68]	; 0x44
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2280:	add.w	r2, r2, r0, lsl #3
    2284:	ldr	r2, [r2, #4]
	*reg = hardware().sck_mux[sck_pin_index];
    2286:	str	r3, [r2, #0]
    2288:	pop	{r4, pc}
    228a:	nop
    228c:	.word	0x001f4001
    2290:	.word	0x38001001
    2294:	.word	0x801f0000
    2298:	.word	0x00012660

0000229c <SPIClass::transfer(void const*, void*, unsigned int)>:
		}
	}
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{
    229c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	if (count == 0) return;
    22a0:	cmp	r3, #0
    22a2:	beq.w	245e <SPIClass::transfer(void const*, void*, unsigned int)+0x1c2>
    22a6:	ldr	r4, [r0, #0]
    22a8:	ldr	r6, [pc, #440]	; (2464 <SPIClass::transfer(void const*, void*, unsigned int)+0x1c8>)
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    22aa:	ldr	r5, [r4, #12]
		const uint8_t *p_write = (const uint8_t *)buf;
		uint8_t *p_read = (uint8_t *)retbuf;
		size_t count_read = count;

		// Lets clear the reader queue
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);
    22ac:	str	r6, [r4, #0]

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    22ae:	tst.w	r5, #16777216	; 0x1000000
    22b2:	and.w	r5, r3, #1
    22b6:	bne.n	2394 <SPIClass::transfer(void const*, void*, unsigned int)+0xf8>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    22b8:	cbz	r5, 22e0 <SPIClass::transfer(void const*, void*, unsigned int)+0x44>
		    if (p_write) {
    22ba:	cbz	r1, 22ce <SPIClass::transfer(void const*, void*, unsigned int)+0x32>
    22bc:	adds	r5, r1, #1
    22be:	ldrb	r1, [r1, #0]
				if (count > 1)
    22c0:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    22c2:	it	ne
    22c4:	orrne.w	r1, r1, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    22c8:	str	r1, [r4, #52]	; 0x34
    22ca:	mov	r1, r5
    22cc:	b.n	22dc <SPIClass::transfer(void const*, void*, unsigned int)+0x40>
    22ce:	ldrb.w	r5, [r0, #44]	; 0x2c
			} else {
				if (count > 1)
    22d2:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    22d4:	it	ne
    22d6:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    22da:	str	r5, [r4, #52]	; 0x34
			}
			count--;
    22dc:	subs	r6, r3, #1
    22de:	b.n	22e2 <SPIClass::transfer(void const*, void*, unsigned int)+0x46>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    22e0:	mov	r6, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    22e2:	ldrb.w	r4, [r0, #44]	; 0x2c
    22e6:	orr.w	r4, r4, r4, lsl #8

		while (count > 0) {
    22ea:	cmp	r6, #0
    22ec:	beq.n	236c <SPIClass::transfer(void const*, void*, unsigned int)+0xd0>
			// Push out the next byte; 
		    if (p_write) {
    22ee:	cbz	r1, 22fe <SPIClass::transfer(void const*, void*, unsigned int)+0x62>
		    	w = (*p_write++) << 8;
    22f0:	mov	r5, r1
				w |= *p_write++;
    22f2:	ldrb	r1, [r1, #1]
	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;

		while (count > 0) {
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
    22f4:	ldrb.w	r4, [r5], #2
				w |= *p_write++;
    22f8:	orr.w	r4, r1, r4, lsl #8
    22fc:	mov	r1, r5
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    22fe:	ldr	r5, [r0, #4]
    2300:	ldr	r7, [r0, #0]
    2302:	ldrb	r5, [r5, #8]
			if (count == 2)
    2304:	cmp	r6, #2
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2306:	add.w	r5, r5, #4294967295
    230a:	mov.w	r5, r5, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    230e:	ite	eq
    2310:	orreq.w	lr, r4, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2314:	orrne.w	lr, r4, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2318:	uxth	r5, r5
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    231a:	str.w	lr, [r7, #52]	; 0x34
			count -= 2; // how many bytes to output.
    231e:	subs	r6, #2
    2320:	ldr.w	lr, [r0]
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    2324:	ldr.w	r7, [lr, #44]	; 0x2c
				if (sr & 0xF0)  {
    2328:	tst.w	r7, #240	; 0xf0
    232c:	beq.n	2358 <SPIClass::transfer(void const*, void*, unsigned int)+0xbc>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    232e:	tst.w	r3, #1
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    2332:	ldr.w	ip, [lr, #56]	; 0x38
					if (count_read & 1) {
    2336:	beq.n	2344 <SPIClass::transfer(void const*, void*, unsigned int)+0xa8>
						if (p_read) {
    2338:	cbz	r2, 2340 <SPIClass::transfer(void const*, void*, unsigned int)+0xa4>
							*p_read++ = w;  // Read any pending RX bytes in
    233a:	strb.w	ip, [r2]
    233e:	adds	r2, #1
						} 
						count_read--;
    2340:	subs	r3, #1
    2342:	b.n	2358 <SPIClass::transfer(void const*, void*, unsigned int)+0xbc>
					} else {
						if (p_read) {
    2344:	cbz	r2, 2356 <SPIClass::transfer(void const*, void*, unsigned int)+0xba>
							*p_read++ = w >> 8;
    2346:	mov	lr, r2
    2348:	mov.w	r8, ip, asr #8
    234c:	strb.w	r8, [lr], #2
							*p_read++ = (w & 0xff);
    2350:	strb.w	ip, [r2, #1]
    2354:	mov	r2, lr
						}
						count_read -= 2;
    2356:	subs	r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    2358:	and.w	r7, r7, #61440	; 0xf000
    235c:	cmp	r7, r5
    235e:	bhi.n	2320 <SPIClass::transfer(void const*, void*, unsigned int)+0x84>
    2360:	b.n	22ea <SPIClass::transfer(void const*, void*, unsigned int)+0x4e>
    2362:	ldr	r1, [r0, #0]

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
    2364:	ldr	r4, [r1, #44]	; 0x2c
			if (sr & 0xF0)  {
    2366:	tst.w	r4, #240	; 0xf0
    236a:	bne.n	2372 <SPIClass::transfer(void const*, void*, unsigned int)+0xd6>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    236c:	cmp	r3, #0
    236e:	bne.n	2362 <SPIClass::transfer(void const*, void*, unsigned int)+0xc6>
    2370:	b.n	245e <SPIClass::transfer(void const*, void*, unsigned int)+0x1c2>
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    2372:	ldr	r4, [r1, #56]	; 0x38
				if (count_read & 1) {
    2374:	lsls	r1, r3, #31
    2376:	bpl.n	2382 <SPIClass::transfer(void const*, void*, unsigned int)+0xe6>
					if (p_read)
    2378:	cbz	r2, 237e <SPIClass::transfer(void const*, void*, unsigned int)+0xe2>
						*p_read++ = w;  // Read any pending RX bytes in
    237a:	strb	r4, [r2, #0]
    237c:	adds	r2, #1
					count_read--;
    237e:	subs	r3, #1
    2380:	b.n	236c <SPIClass::transfer(void const*, void*, unsigned int)+0xd0>
				} else {
					if (p_read) {
    2382:	cbz	r2, 2390 <SPIClass::transfer(void const*, void*, unsigned int)+0xf4>
						*p_read++ = w >> 8;
    2384:	mov	r1, r2
    2386:	asrs	r5, r4, #8
    2388:	strb.w	r5, [r1], #2
						*p_read++ = (w & 0xff);
    238c:	strb	r4, [r2, #1]
    238e:	mov	r2, r1
					}
					count_read -= 2;
    2390:	subs	r3, #2
    2392:	b.n	236c <SPIClass::transfer(void const*, void*, unsigned int)+0xd0>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2394:	cbz	r5, 23bc <SPIClass::transfer(void const*, void*, unsigned int)+0x120>
		    if (p_write) {
    2396:	cbz	r1, 23aa <SPIClass::transfer(void const*, void*, unsigned int)+0x10e>
    2398:	adds	r5, r1, #1
    239a:	ldrb	r1, [r1, #0]
				if (count > 1)
    239c:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    239e:	it	ne
    23a0:	orrne.w	r1, r1, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    23a4:	str	r1, [r4, #52]	; 0x34
    23a6:	mov	r1, r5
    23a8:	b.n	23b8 <SPIClass::transfer(void const*, void*, unsigned int)+0x11c>
    23aa:	ldrb.w	r5, [r0, #44]	; 0x2c
			} else {
				if (count > 1)
    23ae:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    23b0:	it	ne
    23b2:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    23b6:	str	r5, [r4, #52]	; 0x34
			}
			count--;
    23b8:	subs	r6, r3, #1
    23ba:	b.n	23be <SPIClass::transfer(void const*, void*, unsigned int)+0x122>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    23bc:	mov	r6, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w = _transferWriteFill;
    23be:	ldrb.w	r7, [r0, #44]	; 0x2c

		while (count > 0) {
    23c2:	cmp	r6, #0
    23c4:	beq.n	2436 <SPIClass::transfer(void const*, void*, unsigned int)+0x19a>
			// Push out the next byte; 
		    if (p_write) {
    23c6:	cbz	r1, 23d2 <SPIClass::transfer(void const*, void*, unsigned int)+0x136>
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
    23c8:	ldrb	r7, [r1, #1]
    23ca:	ldrb	r4, [r1, #0]
    23cc:	adds	r1, #2
    23ce:	orr.w	r7, r4, r7, lsl #8
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    23d2:	ldr	r4, [r0, #4]
    23d4:	ldr	r5, [r0, #0]
    23d6:	ldrb	r4, [r4, #8]
			if (count == 2)
    23d8:	cmp	r6, #2
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    23da:	add.w	r4, r4, #4294967295
    23de:	mov.w	r4, r4, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    23e2:	ite	eq
    23e4:	orreq.w	lr, r7, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    23e8:	orrne.w	lr, r7, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    23ec:	uxth	r4, r4
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    23ee:	str.w	lr, [r5, #52]	; 0x34
			count -= 2; // how many bytes to output.
    23f2:	subs	r6, #2
    23f4:	ldr	r5, [r0, #0]
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    23f6:	ldr.w	lr, [r5, #44]	; 0x2c
				if (sr & 0xF0)  {
    23fa:	tst.w	lr, #240	; 0xf0
    23fe:	beq.n	2422 <SPIClass::transfer(void const*, void*, unsigned int)+0x186>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    2400:	tst.w	r3, #1
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    2404:	ldr	r5, [r5, #56]	; 0x38
					if (count_read & 1) {
    2406:	beq.n	2412 <SPIClass::transfer(void const*, void*, unsigned int)+0x176>
						if (p_read) {
    2408:	cbz	r2, 240e <SPIClass::transfer(void const*, void*, unsigned int)+0x172>
							*p_read++ = w;  // Read any pending RX bytes in
    240a:	strb	r5, [r2, #0]
    240c:	adds	r2, #1
						} 
						count_read--;
    240e:	subs	r3, #1
    2410:	b.n	2422 <SPIClass::transfer(void const*, void*, unsigned int)+0x186>
					} else {
						if (p_read) {
    2412:	cbz	r2, 2420 <SPIClass::transfer(void const*, void*, unsigned int)+0x184>
							*p_read++ = (w & 0xff);
    2414:	mov	ip, r2
    2416:	strb.w	r5, [ip], #2
							*p_read++ = w >> 8;
    241a:	asrs	r5, r5, #8
    241c:	strb	r5, [r2, #1]
    241e:	mov	r2, ip
						}
						count_read -= 2;
    2420:	subs	r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    2422:	and.w	lr, lr, #61440	; 0xf000
    2426:	cmp	lr, r4
    2428:	bhi.n	23f4 <SPIClass::transfer(void const*, void*, unsigned int)+0x158>
    242a:	b.n	23c2 <SPIClass::transfer(void const*, void*, unsigned int)+0x126>
    242c:	ldr	r1, [r0, #0]

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
    242e:	ldr	r4, [r1, #44]	; 0x2c
			if (sr & 0xF0)  {
    2430:	tst.w	r4, #240	; 0xf0
    2434:	bne.n	243c <SPIClass::transfer(void const*, void*, unsigned int)+0x1a0>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    2436:	cmp	r3, #0
    2438:	bne.n	242c <SPIClass::transfer(void const*, void*, unsigned int)+0x190>
    243a:	b.n	245e <SPIClass::transfer(void const*, void*, unsigned int)+0x1c2>
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
				if (count_read & 1) {
    243c:	lsls	r4, r3, #31

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    243e:	ldr	r1, [r1, #56]	; 0x38
				if (count_read & 1) {
    2440:	bpl.n	244c <SPIClass::transfer(void const*, void*, unsigned int)+0x1b0>
					if (p_read)
    2442:	cbz	r2, 2448 <SPIClass::transfer(void const*, void*, unsigned int)+0x1ac>
						*p_read++ = w;  // Read any pending RX bytes in
    2444:	strb	r1, [r2, #0]
    2446:	adds	r2, #1
					count_read--;
    2448:	subs	r3, #1
    244a:	b.n	2436 <SPIClass::transfer(void const*, void*, unsigned int)+0x19a>
				} else {
					if (p_read) {
    244c:	cbz	r2, 245a <SPIClass::transfer(void const*, void*, unsigned int)+0x1be>
						*p_read++ = (w & 0xff);
    244e:	mov	r4, r2
    2450:	strb.w	r1, [r4], #2
						*p_read++ = w >> 8;
    2454:	asrs	r1, r1, #8
    2456:	strb	r1, [r2, #1]
    2458:	mov	r2, r4
					}
					count_read -= 2;
    245a:	subs	r3, #2
    245c:	b.n	2436 <SPIClass::transfer(void const*, void*, unsigned int)+0x19a>
    245e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2462:	nop
    2464:	.word	0x801f0400

00002468 <SPIClass::dma_rxisr()>:


//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
    2468:	push	{r4, r5, r6, lr}
    246a:	ldr	r3, [r0, #56]	; 0x38
    246c:	ldrb	r2, [r3, #4]
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    246e:	ldr	r3, [pc, #192]	; (2530 <SPIClass::dma_rxisr()+0xc8>)
    2470:	strb	r2, [r3, #0]
    2472:	ldr	r3, [r0, #52]	; 0x34
    2474:	ldrb	r2, [r3, #4]
	bool complete(void) {
		if (TCD->CSR & DMA_TCD_CSR_DONE) return true;
		return false;
	}
	void clearComplete(void) {
		DMA_CDNE = channel;
    2476:	ldr	r3, [pc, #188]	; (2534 <SPIClass::dma_rxisr()+0xcc>)
    2478:	strb	r2, [r3, #0]
    247a:	ldr	r2, [r0, #56]	; 0x38
    247c:	ldrb	r2, [r2, #4]
    247e:	strb	r2, [r3, #0]
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
    2480:	ldr	r2, [r0, #48]	; 0x30


//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
    2482:	mov	r4, r0
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
    2484:	cmp	r2, #0
    2486:	beq.n	2508 <SPIClass::dma_rxisr()+0xa0>
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
    2488:	ldr	r3, [r0, #4]
    248a:	ldr	r1, [r3, #12]
    248c:	cmp	r2, r1
    248e:	bls.n	2498 <SPIClass::dma_rxisr()+0x30>
			_dma_count_remaining -= hardware().max_dma_count;
    2490:	subs	r2, r2, r1
    2492:	str	r2, [r0, #48]	; 0x30
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    2494:	movs	r1, #1
    2496:	b.n	24ba <SPIClass::dma_rxisr()+0x52>
    2498:	ldr	r3, [r0, #52]	; 0x34
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
			_dma_count_remaining -= hardware().max_dma_count;
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
    249a:	subs	r1, r2, #1
    249c:	ldr	r0, [r3, #0]
    249e:	bl	2200 <DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]>
    24a2:	ldr	r3, [r4, #56]	; 0x38
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
    24a4:	ldr	r1, [r4, #48]	; 0x30
    24a6:	ldr	r0, [r3, #0]
    24a8:	bl	2200 <DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]>
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    24ac:	ldr	r1, [r4, #48]	; 0x30
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    24ae:	movs	r3, #0
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    24b0:	adds.w	r1, r1, #4294967295
    24b4:	it	ne
    24b6:	movne	r1, #1
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    24b8:	str	r3, [r4, #48]	; 0x30
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
    24ba:	ldr	r3, [r4, #52]	; 0x34
    24bc:	ldr	r3, [r3, #0]
    24be:	ldr	r0, [r3, #0]
    24c0:	add.w	r2, r4, #44	; 0x2c
    24c4:	cmp	r0, r2
    24c6:	ldr	r2, [r4, #0]
    24c8:	bne.n	24d6 <SPIClass::dma_rxisr()+0x6e>
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    24ca:	ldr	r3, [r2, #12]
    24cc:	ldrb.w	r3, [r4, #44]	; 0x2c
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    24d0:	orr.w	r3, r3, #2147483648	; 0x80000000
    24d4:	b.n	24f4 <SPIClass::dma_rxisr()+0x8c>
			} else  {
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    24d6:	ldr	r0, [r2, #12]
    24d8:	tst.w	r0, #1073741824	; 0x40000000
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    24dc:	ldr	r0, [r3, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    24de:	itete	ne
    24e0:	ldrne	r5, [r3, #0]
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    24e2:	ldreq	r5, [r3, #0]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    24e4:	ldrhne	r0, [r0, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
    24e6:	ldrbeq	r0, [r0, #0]
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    24e8:	ite	ne
    24ea:	addne	r5, #2
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    24ec:	addeq	r5, #1
    24ee:	str	r5, [r3, #0]
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    24f0:	orr.w	r3, r0, #2147483648	; 0x80000000
    24f4:	str	r3, [r2, #52]	; 0x34
    24f6:	ldr	r3, [r4, #56]	; 0x38
    24f8:	ldrb	r2, [r3, #4]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    24fa:	ldr	r3, [pc, #60]	; (2538 <SPIClass::dma_rxisr()+0xd0>)
    24fc:	strb	r2, [r3, #0]
			}
		}
		_dmaRX->enable();
		if (should_reenable_tx)
    24fe:	cbz	r1, 252c <SPIClass::dma_rxisr()+0xc4>
    2500:	ldr	r2, [r4, #52]	; 0x34
    2502:	ldrb	r2, [r2, #4]
    2504:	strb	r2, [r3, #0]
    2506:	pop	{r4, r5, r6, pc}
    2508:	ldr	r3, [r0, #0]
			_dmaTX->enable();
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    250a:	ldr	r1, [pc, #48]	; (253c <SPIClass::dma_rxisr()+0xd4>)
		_dmaRX->enable();
		if (should_reenable_tx)
			_dmaTX->enable();
	} else {

		port().RSER = 0;
    250c:	str	r2, [r3, #48]	; 0x30
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    250e:	str	r1, [r3, #44]	; 0x2c
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    2510:	ldr	r1, [r3, #12]
    2512:	bic.w	r1, r1, #1073741824	; 0x40000000
    2516:	str	r1, [r3, #12]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    2518:	movs	r3, #3
    251a:	strb.w	r3, [r0, #45]	; 0x2d
		_dma_event_responder->triggerEvent();
    251e:	ldr	r0, [r0, #60]	; 0x3c
    2520:	ldr	r3, [r0, #0]
    2522:	mov	r1, r2
    2524:	ldr	r3, [r3, #0]

	}
}
    2526:	ldmia.w	sp!, {r4, r5, r6, lr}
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    252a:	bx	r3
    252c:	pop	{r4, r5, r6, pc}
    252e:	nop
    2530:	.word	0x4000801f
    2534:	.word	0x4000801c
    2538:	.word	0x4000801b
    253c:	.word	0xff0f0000

00002540 <_spi_dma_rxISR0()>:
};
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    2540:	push	{r3, lr}
    2542:	ldr	r0, [pc, #8]	; (254c <_spi_dma_rxISR0()+0xc>)
    2544:	bl	2468 <SPIClass::dma_rxisr()>
    2548:	pop	{r3, pc}
    254a:	nop
    254c:	.word	0x1fff0f64

00002550 <DMAChannel::~DMAChannel()>:
	}
	DMAChannel & operator = (const DMASetting &rhs) {
		copy_tcd(TCD, rhs.TCD);
		return *this;
	}
	~DMAChannel() {
    2550:	push	{r4, lr}
    2552:	mov	r4, r0
		release();
    2554:	bl	98c4 <DMAChannel::release()>
	}
    2558:	mov	r0, r4
    255a:	pop	{r4, pc}

0000255c <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE>:
audio_block_t * AudioOutputPWM::block_2nd = NULL;
uint32_t  AudioOutputPWM::block_offset = 0;
uint8_t AudioOutputPWM::interrupt_count = 0;

DMAMEM uint32_t pwm_dma_buffer[AUDIO_BLOCK_SAMPLES*2];
DMAChannel AudioOutputPWM::dma(false);
    255c:	ldr	r2, [pc, #8]	; (2568 <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE+0xc>)
    255e:	ldr	r1, [pc, #12]	; (256c <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE+0x10>)
    2560:	ldr	r0, [pc, #12]	; (2570 <_GLOBAL__sub_I__ZN14AudioOutputPWM21update_responsibilityE+0x14>)
    2562:	b.w	9cdc <__aeabi_atexit>
    2566:	nop
    2568:	.word	0x1fff0f30
    256c:	.word	0x00002551
    2570:	.word	0x1fff7ebc

00002574 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE>:
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_rx_buffer[AUDIO_BLOCK_SAMPLES];
audio_block_t * AudioInputI2S::block_left = NULL;
audio_block_t * AudioInputI2S::block_right = NULL;
uint16_t AudioInputI2S::block_offset = 0;
bool AudioInputI2S::update_responsibility = false;
DMAChannel AudioInputI2S::dma(false);
    2574:	ldr	r2, [pc, #8]	; (2580 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0xc>)
    2576:	ldr	r1, [pc, #12]	; (2584 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0x10>)
    2578:	ldr	r0, [pc, #12]	; (2588 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE+0x14>)
    257a:	b.w	9cdc <__aeabi_atexit>
    257e:	nop
    2580:	.word	0x1fff0f30
    2584:	.word	0x00002551
    2588:	.word	0x1fff7ec4

0000258c <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE>:
#if defined(AUDIO_PT8211_OVERSAMPLING)
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*4];
#else
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES];
#endif
DMAChannel AudioOutputPT8211::dma(false);
    258c:	ldr	r2, [pc, #8]	; (2598 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0xc>)
    258e:	ldr	r1, [pc, #12]	; (259c <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0x10>)
    2590:	ldr	r0, [pc, #12]	; (25a0 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE+0x14>)
    2592:	b.w	9cdc <__aeabi_atexit>
    2596:	nop
    2598:	.word	0x1fff0f30
    259c:	.word	0x00002551
    25a0:	.word	0x1fff7ecc

000025a4 <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE>:
bool AudioOutputADAT::update_responsibility = false;
//uint32_t  AudioOutputADAT::vucp = VUCP_VALID;

DMAMEM __attribute__((aligned(32))) static uint32_t ADAT_tx_buffer[AUDIO_BLOCK_SAMPLES * 8]; //4 KB, AUDIO_BLOCK_SAMPLES is usually 128

DMAChannel AudioOutputADAT::dma(false);
    25a4:	ldr	r2, [pc, #8]	; (25b0 <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE+0xc>)
    25a6:	ldr	r1, [pc, #12]	; (25b4 <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE+0x10>)
    25a8:	ldr	r0, [pc, #12]	; (25b8 <_GLOBAL__sub_I__ZN15AudioOutputADAT13block_ch1_1stE+0x14>)
    25aa:	b.w	9cdc <__aeabi_atexit>
    25ae:	nop
    25b0:	.word	0x1fff0f30
    25b4:	.word	0x00002551
    25b8:	.word	0x1fff7ed4

000025bc <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE>:
uint16_t AudioInputAnalog::block_offset = 0;
int32_t AudioInputAnalog::hpf_y1 = 0;
int32_t AudioInputAnalog::hpf_x1 = 0;

bool AudioInputAnalog::update_responsibility = false;
DMAChannel AudioInputAnalog::dma(false);
    25bc:	ldr	r2, [pc, #8]	; (25c8 <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE+0xc>)
    25be:	ldr	r1, [pc, #12]	; (25cc <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE+0x10>)
    25c0:	ldr	r0, [pc, #12]	; (25d0 <_GLOBAL__sub_I__ZN16AudioInputAnalog10block_leftE+0x14>)
    25c2:	b.w	9cdc <__aeabi_atexit>
    25c6:	nop
    25c8:	.word	0x1fff0f30
    25cc:	.word	0x00002551
    25d0:	.word	0x1fff7edc

000025d4 <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE>:

DMAMEM __attribute__((aligned(32))) static uint16_t dac_buffer[AUDIO_BLOCK_SAMPLES*2];
audio_block_t * AudioOutputAnalog::block_left_1st = NULL;
audio_block_t * AudioOutputAnalog::block_left_2nd = NULL;
bool AudioOutputAnalog::update_responsibility = false;
DMAChannel AudioOutputAnalog::dma(false);
    25d4:	ldr	r2, [pc, #8]	; (25e0 <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE+0xc>)
    25d6:	ldr	r1, [pc, #12]	; (25e4 <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE+0x10>)
    25d8:	ldr	r0, [pc, #12]	; (25e8 <_GLOBAL__sub_I__ZN17AudioOutputAnalog14block_left_1stE+0x14>)
    25da:	b.w	9cdc <__aeabi_atexit>
    25de:	nop
    25e0:	.word	0x1fff0f30
    25e4:	.word	0x00002551
    25e8:	.word	0x1fff7ee4

000025ec <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE>:
        while (1) {
                if ((ADC1_SC1A & ADC_SC1_COCO)) {
                        return ADC1_RA;
                }
        }
}
    25ec:	push	{r3, r4, r5, lr}
uint16_t AudioInputAnalogStereo::offset_left = 0;
uint16_t AudioInputAnalogStereo::offset_right = 0;
int32_t AudioInputAnalogStereo::hpf_y1[2] = { 0, 0 };
int32_t AudioInputAnalogStereo::hpf_x1[2] = { 0, 0 };
bool AudioInputAnalogStereo::update_responsibility = false;
DMAChannel AudioInputAnalogStereo::dma0(false);
    25ee:	ldr	r5, [pc, #28]	; (260c <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x20>)
    25f0:	ldr	r4, [pc, #28]	; (2610 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x24>)
    25f2:	ldr	r0, [pc, #32]	; (2614 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x28>)
    25f4:	mov	r2, r5
    25f6:	mov	r1, r4
    25f8:	bl	9cdc <__aeabi_atexit>
DMAChannel AudioInputAnalogStereo::dma1(false);
    25fc:	mov	r2, r5
    25fe:	mov	r1, r4
    2600:	ldr	r0, [pc, #20]	; (2618 <_GLOBAL__sub_I__ZN22AudioInputAnalogStereo10block_leftE+0x2c>)
        while (1) {
                if ((ADC1_SC1A & ADC_SC1_COCO)) {
                        return ADC1_RA;
                }
        }
}
    2602:	ldmia.w	sp!, {r3, r4, r5, lr}
uint16_t AudioInputAnalogStereo::offset_right = 0;
int32_t AudioInputAnalogStereo::hpf_y1[2] = { 0, 0 };
int32_t AudioInputAnalogStereo::hpf_x1[2] = { 0, 0 };
bool AudioInputAnalogStereo::update_responsibility = false;
DMAChannel AudioInputAnalogStereo::dma0(false);
DMAChannel AudioInputAnalogStereo::dma1(false);
    2606:	b.w	9cdc <__aeabi_atexit>
    260a:	nop
    260c:	.word	0x1fff0f30
    2610:	.word	0x00002551
    2614:	.word	0x1fff7eec
    2618:	.word	0x1fff7ef4

0000261c <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E>:
audio_block_t * AudioInputI2SQuad::block_ch2 = NULL;
audio_block_t * AudioInputI2SQuad::block_ch3 = NULL;
audio_block_t * AudioInputI2SQuad::block_ch4 = NULL;
uint16_t AudioInputI2SQuad::block_offset = 0;
bool AudioInputI2SQuad::update_responsibility = false;
DMAChannel AudioInputI2SQuad::dma(false);
    261c:	ldr	r2, [pc, #8]	; (2628 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0xc>)
    261e:	ldr	r1, [pc, #12]	; (262c <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0x10>)
    2620:	ldr	r0, [pc, #12]	; (2630 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E+0x14>)
    2622:	b.w	9cdc <__aeabi_atexit>
    2626:	nop
    2628:	.word	0x1fff0f30
    262c:	.word	0x00002551
    2630:	.word	0x1fff7efc

00002634 <_GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE>:
audio_block_t * AudioOutputAnalogStereo::block_left_2nd = NULL;
audio_block_t * AudioOutputAnalogStereo::block_right_1st = NULL;
audio_block_t * AudioOutputAnalogStereo::block_right_2nd = NULL;
audio_block_t AudioOutputAnalogStereo::block_silent;
bool AudioOutputAnalogStereo::update_responsibility = false;
DMAChannel AudioOutputAnalogStereo::dma(false);
    2634:	ldr	r2, [pc, #8]	; (2640 <_GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE+0xc>)
    2636:	ldr	r1, [pc, #12]	; (2644 <_GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE+0x10>)
    2638:	ldr	r0, [pc, #12]	; (2648 <_GLOBAL__sub_I__ZN23AudioOutputAnalogStereo14block_left_1stE+0x14>)
    263a:	b.w	9cdc <__aeabi_atexit>
    263e:	nop
    2640:	.word	0x1fff0f30
    2644:	.word	0x00002551
    2648:	.word	0x1fff7f04

0000264c <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE>:
uint16_t  AudioOutputI2SQuad::ch2_offset = 0;
uint16_t  AudioOutputI2SQuad::ch3_offset = 0;
uint16_t  AudioOutputI2SQuad::ch4_offset = 0;
bool AudioOutputI2SQuad::update_responsibility = false;
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*2];
DMAChannel AudioOutputI2SQuad::dma(false);
    264c:	ldr	r2, [pc, #8]	; (2658 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0xc>)
    264e:	ldr	r1, [pc, #12]	; (265c <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0x10>)
    2650:	ldr	r0, [pc, #12]	; (2660 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE+0x14>)
    2652:	b.w	9cdc <__aeabi_atexit>
    2656:	nop
    2658:	.word	0x1fff0f30
    265c:	.word	0x00002551
    2660:	.word	0x1fff7f0c

00002664 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E>:
audio_block_t * AudioInputI2SOct::block_ch6 = NULL;
audio_block_t * AudioInputI2SOct::block_ch7 = NULL;
audio_block_t * AudioInputI2SOct::block_ch8 = NULL;
uint16_t AudioInputI2SOct::block_offset = 0;
bool AudioInputI2SOct::update_responsibility = false;
DMAChannel AudioInputI2SOct::dma(false);
    2664:	ldr	r2, [pc, #8]	; (2670 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E+0xc>)
    2666:	ldr	r1, [pc, #12]	; (2674 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E+0x10>)
    2668:	ldr	r0, [pc, #12]	; (2678 <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E+0x14>)
    266a:	b.w	9cdc <__aeabi_atexit>
    266e:	nop
    2670:	.word	0x1fff0f30
    2674:	.word	0x00002551
    2678:	.word	0x1fff7f14

0000267c <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE>:
audio_block_t * AudioOutputTDM::block_input[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioOutputTDM::update_responsibility = false;
DMAChannel AudioOutputTDM::dma(false);
    267c:	ldr	r2, [pc, #8]	; (2688 <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0xc>)
    267e:	ldr	r1, [pc, #12]	; (268c <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0x10>)
    2680:	ldr	r0, [pc, #12]	; (2690 <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE+0x14>)
    2682:	b.w	9cdc <__aeabi_atexit>
    2686:	nop
    2688:	.word	0x1fff0f30
    268c:	.word	0x00002551
    2690:	.word	0x1fff7f1c

00002694 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE>:
audio_block_t * AudioInputTDM::block_incoming[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioInputTDM::update_responsibility = false;
DMAChannel AudioInputTDM::dma(false);
    2694:	ldr	r2, [pc, #8]	; (26a0 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0xc>)
    2696:	ldr	r1, [pc, #12]	; (26a4 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0x10>)
    2698:	ldr	r0, [pc, #12]	; (26a8 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE+0x14>)
    269a:	b.w	9cdc <__aeabi_atexit>
    269e:	nop
    26a0:	.word	0x1fff0f30
    26a4:	.word	0x00002551
    26a8:	.word	0x1fff7f24

000026ac <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E>:
audio_block_t * AudioInputI2SHex::block_ch4 = NULL;
audio_block_t * AudioInputI2SHex::block_ch5 = NULL;
audio_block_t * AudioInputI2SHex::block_ch6 = NULL;
uint16_t AudioInputI2SHex::block_offset = 0;
bool AudioInputI2SHex::update_responsibility = false;
DMAChannel AudioInputI2SHex::dma(false);
    26ac:	ldr	r2, [pc, #8]	; (26b8 <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E+0xc>)
    26ae:	ldr	r1, [pc, #12]	; (26bc <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E+0x10>)
    26b0:	ldr	r0, [pc, #12]	; (26c0 <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E+0x14>)
    26b2:	b.w	9cdc <__aeabi_atexit>
    26b6:	nop
    26b8:	.word	0x1fff0f30
    26bc:	.word	0x00002551
    26c0:	.word	0x1fff7f2c

000026c4 <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE>:
#if defined(__IMXRT1062__) || defined(KINETISK)
DMAMEM __attribute__((aligned(32))) static uint32_t pdm_buffer[AUDIO_BLOCK_SAMPLES*4];
static uint32_t leftover[14];
audio_block_t * AudioInputPDM::block_left = NULL;
bool AudioInputPDM::update_responsibility = false;
DMAChannel AudioInputPDM::dma(false);
    26c4:	ldr	r2, [pc, #8]	; (26d0 <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE+0xc>)
    26c6:	ldr	r1, [pc, #12]	; (26d4 <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE+0x10>)
    26c8:	ldr	r0, [pc, #12]	; (26d8 <_GLOBAL__sub_I__ZN13AudioInputPDM10block_leftE+0x14>)
    26ca:	b.w	9cdc <__aeabi_atexit>
    26ce:	nop
    26d0:	.word	0x1fff0f30
    26d4:	.word	0x00002551
    26d8:	.word	0x1fff7f34

000026dc <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE>:
audio_block_t * AudioOutputI2S::block_left_2nd = NULL;
audio_block_t * AudioOutputI2S::block_right_2nd = NULL;
uint16_t  AudioOutputI2S::block_left_offset = 0;
uint16_t  AudioOutputI2S::block_right_offset = 0;
bool AudioOutputI2S::update_responsibility = false;
DMAChannel AudioOutputI2S::dma(false);
    26dc:	ldr	r2, [pc, #8]	; (26e8 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0xc>)
    26de:	ldr	r1, [pc, #12]	; (26ec <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0x10>)
    26e0:	ldr	r0, [pc, #12]	; (26f0 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE+0x14>)
    26e2:	b.w	9cdc <__aeabi_atexit>
    26e6:	nop
    26e8:	.word	0x1fff0f30
    26ec:	.word	0x00002551
    26f0:	.word	0x1fff7f3c

000026f4 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE>:
audio_block_t * AudioOutputSPDIF::block_left_2nd = NULL;
audio_block_t * AudioOutputSPDIF::block_right_2nd = NULL;
uint16_t  AudioOutputSPDIF::block_left_offset = 0;
uint16_t  AudioOutputSPDIF::block_right_offset = 0;
bool AudioOutputSPDIF::update_responsibility = false;
DMAChannel AudioOutputSPDIF::dma(false);
    26f4:	ldr	r2, [pc, #8]	; (2700 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0xc>)
    26f6:	ldr	r1, [pc, #12]	; (2704 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0x10>)
    26f8:	ldr	r0, [pc, #12]	; (2708 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE+0x14>)
    26fa:	b.w	9cdc <__aeabi_atexit>
    26fe:	nop
    2700:	.word	0x1fff0f30
    2704:	.word	0x00002551
    2708:	.word	0x1fff7f44

0000270c <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    270c:	ldrb.w	r2, [r0, #161]	; 0xa1
    2710:	ldrb.w	r0, [r0, #160]	; 0xa0
	}
    2714:	subs	r0, r2, r0
    2716:	bx	lr

00002718 <TwoWire::read()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2718:	ldrb.w	r3, [r0, #160]	; 0xa0
    271c:	ldrb.w	r2, [r0, #161]	; 0xa1
    2720:	cmp	r2, r3
		return rxBuffer[rxBufferIndex++];
    2722:	itttt	hi
    2724:	addhi	r2, r3, #1
    2726:	addhi	r3, r3, r0
    2728:	strbhi.w	r2, [r0, #160]	; 0xa0
    272c:	ldrbhi	r0, [r3, #24]
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    272e:	it	ls
    2730:	movls.w	r0, #4294967295
		return rxBuffer[rxBufferIndex++];
	}
    2734:	bx	lr

00002736 <TwoWire::peek()>:
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2736:	ldrb.w	r3, [r0, #160]	; 0xa0
    273a:	ldrb.w	r2, [r0, #161]	; 0xa1
    273e:	cmp	r2, r3
		return rxBuffer[rxBufferIndex];
    2740:	itte	hi
    2742:	addhi	r3, r3, r0
    2744:	ldrbhi	r0, [r3, #24]
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2746:	movls.w	r0, #4294967295
		return rxBuffer[rxBufferIndex];
	}
    274a:	bx	lr

0000274c <TwoWire::flush()>:
	virtual void flush(void) {
    274c:	bx	lr

0000274e <TwoWire::write(unsigned char)>:
//  I2C0_C2      // I2C Control Register 2
//  I2C0_FLT     // I2C Programmable Input Glitch Filter register

size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
    274e:	ldrh.w	r3, [r0, #302]	; 0x12e
    2752:	cbz	r3, 2760 <TwoWire::write(unsigned char)+0x12>
		if (txBufferLength >= BUFFER_LENGTH+1) {
    2754:	ldrb.w	r3, [r0, #301]	; 0x12d
    2758:	cmp	r3, #136	; 0x88
    275a:	bls.n	2764 <TwoWire::write(unsigned char)+0x16>
	// format warnings are too pedantic - disable until newer toolchain offers better...
	// https://forum.pjrc.com/threads/62473?p=256873&viewfull=1#post256873
	int printf(const char *format, ...) /*__attribute__ ((format (printf, 2, 3)))*/;
	int printf(const __FlashStringHelper *format, ...);
  protected:
	void setWriteError(int err = 1) { write_error = err; }
    275c:	movs	r3, #1
    275e:	strb	r3, [r0, #4]
			setWriteError();
			return 0;
    2760:	movs	r0, #0
    2762:	bx	lr
		}
		txBuffer[txBufferLength++] = data;
    2764:	adds	r2, r3, #1
    2766:	add	r3, r0
    2768:	strb.w	r2, [r0, #301]	; 0x12d
    276c:	strb.w	r1, [r3, #163]	; 0xa3
		return 1;
    2770:	movs	r0, #1
    2772:	bx	lr

00002774 <TwoWire::write(unsigned char const*, unsigned int)>:
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    2774:	push	{r3, r4, r5, lr}
    2776:	mov	r4, r0
	if (transmitting || slave_mode) {
    2778:	ldrh.w	r0, [r0, #302]	; 0x12e
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    277c:	mov	r5, r2
	if (transmitting || slave_mode) {
    277e:	cbz	r0, 27aa <TwoWire::write(unsigned char const*, unsigned int)+0x36>
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
    2780:	ldrb.w	r3, [r4, #301]	; 0x12d
    2784:	rsb	r2, r3, #137	; 0x89
		if (quantity > avail) {
    2788:	cmp	r5, r2
    278a:	ittt	hi
    278c:	movhi	r0, #1
    278e:	movhi	r5, r2
    2790:	strbhi	r0, [r4, #4]
			quantity = avail;
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
    2792:	add.w	r0, r4, #163	; 0xa3
    2796:	add	r0, r3
    2798:	mov	r2, r5
    279a:	bl	8734 <memcpy>
		txBufferLength += quantity;
    279e:	ldrb.w	r3, [r4, #301]	; 0x12d
    27a2:	add	r3, r5
    27a4:	strb.w	r3, [r4, #301]	; 0x12d
    27a8:	mov	r0, r5
		return quantity;
	}
	return 0;
}
    27aa:	pop	{r3, r4, r5, pc}

000027ac <TwoWire::isr()>:
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    27ac:	push	{r3, r4, r5, lr}
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    27ae:	ldr	r2, [r0, #16]
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
    27b0:	ldrb	r5, [r2, #3]
    27b2:	uxtb	r5, r5
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    27b4:	tst.w	r5, #16
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    27b8:	mov	r4, r0
    27ba:	and.w	r3, r5, #64	; 0x40
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    27be:	bne.n	27c8 <TwoWire::isr()+0x1c>


		}
		if (!(status & I2C_S_IAAS)) return;
	}
	if (status & I2C_S_IAAS) {
    27c0:	and.w	r1, r3, #255	; 0xff
    27c4:	cbnz	r3, 27d2 <TwoWire::isr()+0x26>
    27c6:	b.n	2820 <TwoWire::isr()+0x74>

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
		// Arbitration Lost
		port().S = I2C_S_ARBL;
    27c8:	movs	r1, #16
    27ca:	strb	r1, [r2, #3]
		if (receiving && rxBufferLength > 0) {
			// TODO: does this detect the STOP condition in slave receive mode?


		}
		if (!(status & I2C_S_IAAS)) return;
    27cc:	cmp	r3, #0
    27ce:	bne.n	27c0 <TwoWire::isr()+0x14>
    27d0:	pop	{r3, r4, r5, pc}
	}
	if (status & I2C_S_IAAS) {
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
    27d2:	and.w	r5, r5, #4
    27d6:	and.w	r2, r5, #255	; 0xff
    27da:	ldr	r3, [pc, #224]	; (28bc <TwoWire::isr()+0x110>)
    27dc:	cbz	r5, 2814 <TwoWire::isr()+0x68>
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    27de:	movs	r2, #0
    27e0:	strb	r2, [r3, #0]
			txBufferLength = 0;
			if (user_onRequest != NULL) {
    27e2:	ldr.w	r3, [r4, #308]	; 0x134
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
			txBufferLength = 0;
    27e6:	strb.w	r2, [r4, #301]	; 0x12d
			if (user_onRequest != NULL) {
    27ea:	cbz	r3, 27ee <TwoWire::isr()+0x42>
				user_onRequest();
    27ec:	blx	r3
			}
			if (txBufferLength == 0) {
    27ee:	ldrb.w	r3, [r4, #301]	; 0x12d
    27f2:	cbnz	r3, 27fe <TwoWire::isr()+0x52>
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    27f4:	movs	r2, #1
    27f6:	strb.w	r2, [r4, #301]	; 0x12d
				txBuffer[0] = 0;
    27fa:	strb.w	r3, [r4, #163]	; 0xa3
    27fe:	ldr	r3, [r4, #16]
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    2800:	movs	r2, #208	; 0xd0
    2802:	strb	r2, [r3, #2]
    2804:	ldr	r3, [r4, #16]
			port().D = txBuffer[0];
    2806:	ldrb.w	r2, [r4, #163]	; 0xa3
    280a:	strb	r2, [r3, #4]
			txBufferIndex = 1;
    280c:	movs	r3, #1
    280e:	strb.w	r3, [r4, #300]	; 0x12c
    2812:	b.n	28b2 <TwoWire::isr()+0x106>
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    2814:	movs	r1, #1
    2816:	strb	r1, [r3, #0]
			rxBufferLength = 0;
    2818:	strb.w	r2, [r4, #161]	; 0xa1
    281c:	ldr	r3, [r4, #16]
    281e:	b.n	287e <TwoWire::isr()+0xd2>
    2820:	ldr	r2, [r4, #16]
		}
		port().S = I2C_S_IICIF;
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
    2822:	ldrb	r3, [r2, #6]
    2824:	uxtb	r3, r3
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
    2826:	and.w	r0, r3, #96	; 0x60
    282a:	cmp	r0, #96	; 0x60
    282c:	bne.n	2844 <TwoWire::isr()+0x98>
		port().FLT = c1 & ~I2C_FLT_STOPIE;
    282e:	and.w	r3, r3, #223	; 0xdf
    2832:	strb	r3, [r2, #6]
		if (user_onReceive != NULL) {
    2834:	ldr.w	r3, [r4, #312]	; 0x138
    2838:	cbz	r3, 2844 <TwoWire::isr()+0x98>
			rxBufferIndex = 0;
    283a:	strb.w	r1, [r4, #160]	; 0xa0
			user_onReceive(rxBufferLength);
    283e:	ldrb.w	r0, [r4, #161]	; 0xa1
    2842:	blx	r3
    2844:	ldr	r3, [r4, #16]
		}
	}
	#endif
	c1 = port().C1;
    2846:	ldrb	r2, [r3, #2]
	if (c1 & I2C_C1_TX) {
    2848:	and.w	r2, r2, #16
    284c:	and.w	r1, r2, #255	; 0xff
    2850:	cbz	r2, 2888 <TwoWire::isr()+0xdc>
		// Continue Slave Transmit
		//serial_print("t");
		if ((status & I2C_S_RXAK) == 0) {
    2852:	ands.w	r5, r5, #1
    2856:	bne.n	287e <TwoWire::isr()+0xd2>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
    2858:	ldrb.w	r2, [r4, #300]	; 0x12c
    285c:	ldrb.w	r1, [r4, #301]	; 0x12d
    2860:	cmp	r1, r2
				port().D = txBuffer[txBufferIndex++];
    2862:	itttt	hi
    2864:	addhi	r1, r2, #1
    2866:	addhi	r2, r2, r4
    2868:	strbhi.w	r1, [r4, #300]	; 0x12c
    286c:	ldrbhi.w	r2, [r2, #163]	; 0xa3
    2870:	ite	hi
    2872:	strbhi	r2, [r3, #4]
			} else {
				port().D = 0;
    2874:	strbls	r5, [r3, #4]
    2876:	ldr	r3, [r4, #16]
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    2878:	movs	r2, #208	; 0xd0
    287a:	strb	r2, [r3, #2]
    287c:	b.n	28b2 <TwoWire::isr()+0x106>
		} else {
			//serial_print("*");
			// Master did not ACK previous byte
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    287e:	movs	r2, #192	; 0xc0
    2880:	strb	r2, [r3, #2]
    2882:	ldr	r3, [r4, #16]
			data = port().D;
    2884:	ldrb	r3, [r3, #4]
    2886:	b.n	28b2 <TwoWire::isr()+0x106>
		}
	} else {
		// Continue Slave Receive
		irqcount = 0;
    2888:	strb.w	r1, [r4, #304]	; 0x130
		#ifdef WIRE_HAS_STOP_INTERRUPT
		port().FLT |= I2C_FLT_STOPIE;
    288c:	ldrb	r2, [r3, #6]
    288e:	orr.w	r2, r2, #32
    2892:	strb	r2, [r3, #6]
    2894:	ldr	r3, [r4, #16]
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    2896:	ldrb	r2, [r3, #4]
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    2898:	ldrb.w	r3, [r4, #161]	; 0xa1
    289c:	cmp	r3, #135	; 0x87
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    289e:	uxtb	r2, r2
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    28a0:	bhi.n	28b2 <TwoWire::isr()+0x106>
    28a2:	ldr	r1, [pc, #24]	; (28bc <TwoWire::isr()+0x110>)
    28a4:	ldrb	r1, [r1, #0]
    28a6:	cbz	r1, 28b2 <TwoWire::isr()+0x106>
			rxBuffer[rxBufferLength++] = data;
    28a8:	adds	r1, r3, #1
    28aa:	add	r3, r4
    28ac:	strb.w	r1, [r4, #161]	; 0xa1
    28b0:	strb	r2, [r3, #24]
    28b2:	ldr	r3, [r4, #16]
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    28b4:	movs	r2, #2
    28b6:	strb	r2, [r3, #3]
    28b8:	pop	{r3, r4, r5, pc}
    28ba:	nop
    28bc:	.word	0x1fff7f4c

000028c0 <i2c0_isr>:
#define MAKE_CONST(x) (__builtin_constant_p(x) ? (x) : (x))

#ifdef WIRE_IMPLEMENT_WIRE
constexpr uintptr_t i2c0_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C0));
TwoWire Wire(i2c0_addr, TwoWire::i2c0_hardware);
void i2c0_isr(void) { Wire.isr(); }
    28c0:	ldr	r0, [pc, #4]	; (28c8 <i2c0_isr+0x8>)
    28c2:	b.w	27ac <TwoWire::isr()>
    28c6:	nop
    28c8:	.word	0x1fff10e0

000028cc <i2c1_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE1
constexpr uintptr_t i2c1_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C1));
TwoWire Wire1(i2c1_addr, TwoWire::i2c1_hardware);
void i2c1_isr(void) { Wire1.isr(); }
    28cc:	ldr	r0, [pc, #4]	; (28d4 <i2c1_isr+0x8>)
    28ce:	b.w	27ac <TwoWire::isr()>
    28d2:	nop
    28d4:	.word	0x1fff121c

000028d8 <i2c2_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE2
constexpr uintptr_t i2c2_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C2));
TwoWire Wire2(i2c2_addr, TwoWire::i2c2_hardware);
void i2c2_isr(void) { Wire2.isr(); }
    28d8:	ldr	r0, [pc, #4]	; (28e0 <i2c2_isr+0x8>)
    28da:	b.w	27ac <TwoWire::isr()>
    28de:	nop
    28e0:	.word	0x1fff0fa4

000028e4 <SDClass::~SDClass()>:
	char *filename;
};



class SDClass : public FS
    28e4:	bx	lr

000028e6 <SDClass::exists(char const*)>:
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
		if (file) return File(new SDFile(file));
		return File();
	}
	bool exists(const char *filepath) {
    28e6:	push	{lr}
    28e8:	mov	r2, r1
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
    28ea:	ldr.w	r1, [r0, #1156]	; 0x484
    28ee:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->exists(path) : false;
    28f0:	cbz	r1, 2908 <SDClass::exists(char const*)+0x22>
    28f2:	movs	r3, #0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    28f4:	mov	r0, sp
    28f6:	strb.w	r3, [sp]
    28fa:	strb.w	r3, [sp, #1]
    28fe:	strb.w	r3, [sp, #2]
    2902:	bl	5b8c <FatFile::open(FatVolume*, char const*, int)>
    2906:	b.n	2924 <SDClass::exists(char const*)+0x3e>
    2908:	ldr.w	r0, [r0, #1160]	; 0x488
    290c:	cbz	r0, 2924 <SDClass::exists(char const*)+0x3e>
    290e:	strb.w	r1, [sp, #49]	; 0x31
    2912:	strb.w	r1, [sp, #50]	; 0x32
    2916:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    291a:	mov	r3, r1
    291c:	mov	r1, r0
    291e:	mov	r0, sp
    2920:	bl	4046 <ExFatFile::open(ExFatVolume*, char const*, int)>
		return sdfs.exists(filepath);
	}
    2924:	add	sp, #60	; 0x3c
    2926:	ldr.w	pc, [sp], #4

0000292a <SDClass::rmdir(char const*)>:
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
    292a:	push	{lr}
    292c:	mov	r2, r1
   * The subdirectory file will be removed only if it is empty.
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char *path) {
    return m_fVol ? m_fVol->rmdir(path) :
    292e:	ldr.w	r1, [r0, #1156]	; 0x484
    2932:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->rmdir(path) : false;
    2934:	cbz	r1, 2954 <SDClass::rmdir(char const*)+0x2a>
    2936:	movs	r3, #0
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char* path) {
    FatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
    2938:	mov	r0, sp
    293a:	strb.w	r3, [sp]
    293e:	strb.w	r3, [sp, #1]
    2942:	strb.w	r3, [sp, #2]
    2946:	bl	5b8c <FatFile::open(FatVolume*, char const*, int)>
    294a:	cbz	r0, 2978 <SDClass::rmdir(char const*)+0x4e>
    294c:	mov	r0, sp
    294e:	bl	5a04 <FatFile::rmdir()>
    2952:	b.n	2978 <SDClass::rmdir(char const*)+0x4e>
    2954:	ldr.w	r0, [r0, #1160]	; 0x488
    2958:	cbz	r0, 2978 <SDClass::rmdir(char const*)+0x4e>
    295a:	strb.w	r1, [sp, #49]	; 0x31
    295e:	strb.w	r1, [sp, #50]	; 0x32
    2962:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char* path) {
    ExFatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
    2966:	mov	r3, r1
    2968:	mov	r1, r0
    296a:	mov	r0, sp
    296c:	bl	4046 <ExFatFile::open(ExFatVolume*, char const*, int)>
    2970:	cbz	r0, 2978 <SDClass::rmdir(char const*)+0x4e>
    2972:	mov	r0, sp
    2974:	bl	4650 <ExFatFile::rmdir()>
		return sdfs.rmdir(filepath);
	}
    2978:	add	sp, #60	; 0x3c
    297a:	ldr.w	pc, [sp], #4

0000297e <SDClass::remove(char const*)>:
		return sdfs.mkdir(filepath);
	}
	bool rename(const char *oldfilepath, const char *newfilepath) {
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
    297e:	push	{lr}
    2980:	mov	r2, r1
  * \param[in] path A path with a valid 8.3 DOS name for the file.
  *
   * \return true for success or false for failure.
  */
  bool remove(const char *path) {
    return m_fVol ? m_fVol->remove(path) :
    2982:	ldr.w	r1, [r0, #1156]	; 0x484
    2986:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->remove(path) : false;
    2988:	cbz	r1, 29aa <SDClass::remove(char const*)+0x2c>
    298a:	movs	r3, #0
    298c:	strb.w	r3, [sp]
    2990:	strb.w	r3, [sp, #1]
    2994:	strb.w	r3, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    2998:	mov	r0, sp
    299a:	movs	r3, #1
    299c:	bl	5b8c <FatFile::open(FatVolume*, char const*, int)>
    29a0:	cbz	r0, 29ce <SDClass::remove(char const*)+0x50>
    29a2:	mov	r0, sp
    29a4:	bl	6c00 <FatFile::remove()>
    29a8:	b.n	29ce <SDClass::remove(char const*)+0x50>
    29aa:	ldr.w	r0, [r0, #1160]	; 0x488
    29ae:	cbz	r0, 29ce <SDClass::remove(char const*)+0x50>
    29b0:	strb.w	r1, [sp, #49]	; 0x31
    29b4:	strb.w	r1, [sp, #50]	; 0x32
    29b8:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    29bc:	movs	r3, #1
    29be:	mov	r1, r0
    29c0:	mov	r0, sp
    29c2:	bl	4046 <ExFatFile::open(ExFatVolume*, char const*, int)>
    29c6:	cbz	r0, 29ce <SDClass::remove(char const*)+0x50>
    29c8:	mov	r0, sp
    29ca:	bl	45ca <ExFatFile::remove()>
		return sdfs.remove(filepath);
	}
    29ce:	add	sp, #60	; 0x3c
    29d0:	ldr.w	pc, [sp], #4

000029d4 <SDClass::mkdir(char const*)>:
		return File();
	}
	bool exists(const char *filepath) {
		return sdfs.exists(filepath);
	}
	bool mkdir(const char *filepath) {
    29d4:	push	{r4, lr}
   * \param[in] pFlag Create missing parent directories if true.
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
    29d6:	ldr.w	r4, [r0, #1156]	; 0x484
    29da:	sub	sp, #56	; 0x38
    29dc:	mov	r2, r1
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
    29de:	cbz	r4, 29fc <SDClass::mkdir(char const*)+0x28>
    29e0:	movs	r3, #0
    29e2:	strb.w	r3, [sp]
    29e6:	strb.w	r3, [sp, #1]
    29ea:	strb.w	r3, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    29ee:	add.w	r1, r4, #1096	; 0x448
    29f2:	movs	r3, #1
    29f4:	mov	r0, sp
    29f6:	bl	5d08 <FatFile::mkdir(FatFile*, char const*, bool)>
    29fa:	b.n	2a1e <SDClass::mkdir(char const*)+0x4a>
    29fc:	ldr.w	r1, [r0, #1160]	; 0x488
    2a00:	cbz	r1, 2a1c <SDClass::mkdir(char const*)+0x48>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    2a02:	movs	r3, #1
    2a04:	add.w	r1, r1, #1096	; 0x448
    2a08:	mov	r0, sp
    2a0a:	strb.w	r4, [sp, #49]	; 0x31
    2a0e:	strb.w	r4, [sp, #50]	; 0x32
    2a12:	strb.w	r4, [sp, #51]	; 0x33
    2a16:	bl	48e8 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
    2a1a:	b.n	2a1e <SDClass::mkdir(char const*)+0x4a>
    2a1c:	mov	r0, r1
		return sdfs.mkdir(filepath);
	}
    2a1e:	add	sp, #56	; 0x38
    2a20:	pop	{r4, pc}

00002a22 <SDClass::rename(char const*, char const*)>:
	bool rename(const char *oldfilepath, const char *newfilepath) {
    2a22:	push	{r4, r5, lr}
   * a file object that was opened before the rename() call.
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    return m_fVol ? m_fVol->rename(oldPath, newPath) :
    2a24:	ldr.w	r3, [r0, #1156]	; 0x484
    2a28:	sub	sp, #60	; 0x3c
    2a2a:	mov	r5, r2
           m_xVol ? m_xVol->rename(oldPath, newPath) : false;
    2a2c:	cbz	r3, 2a5a <SDClass::rename(char const*, char const*)+0x38>
    2a2e:	movs	r2, #0
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend FatFile;
  static FatVolume* cwv() {return m_cwv;}
  FatFile* vwd() {return &m_vwd;}
    2a30:	add.w	r4, r3, #1096	; 0x448
    2a34:	strb.w	r2, [sp]
    2a38:	strb.w	r2, [sp, #1]
    2a3c:	strb.w	r2, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    FatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    2a40:	mov	r3, r2
    2a42:	mov	r0, sp
    2a44:	mov	r2, r1
    2a46:	mov	r1, r4
    2a48:	bl	5ae4 <FatFile::open(FatFile*, char const*, int)>
    2a4c:	cbz	r0, 2a86 <SDClass::rename(char const*, char const*)+0x64>
    2a4e:	mov	r2, r5
    2a50:	mov	r1, r4
    2a52:	mov	r0, sp
    2a54:	bl	5db2 <FatFile::rename(FatFile*, char const*)>
    2a58:	b.n	2a86 <SDClass::rename(char const*, char const*)+0x64>
    2a5a:	ldr.w	r0, [r0, #1160]	; 0x488
    2a5e:	cbz	r0, 2a86 <SDClass::rename(char const*, char const*)+0x64>
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend ExFatFile;
  static ExFatVolume* cwv() {return m_cwv;}
  ExFatFile* vwd() {return &m_vwd;}
    2a60:	add.w	r4, r0, #1096	; 0x448
   *
   * \return true for success or false for failure.
   */
  bool rename(const char* oldPath, const char* newPath) {
    ExFatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    2a64:	mov	r2, r1
    2a66:	mov	r0, sp
    2a68:	mov	r1, r4
    2a6a:	strb.w	r3, [sp, #49]	; 0x31
    2a6e:	strb.w	r3, [sp, #50]	; 0x32
    2a72:	strb.w	r3, [sp, #51]	; 0x33
    2a76:	bl	3f8c <ExFatFile::open(ExFatFile*, char const*, int)>
    2a7a:	cbz	r0, 2a86 <SDClass::rename(char const*, char const*)+0x64>
    2a7c:	mov	r2, r5
    2a7e:	mov	r1, r4
    2a80:	mov	r0, sp
    2a82:	bl	49a6 <ExFatFile::rename(ExFatFile*, char const*)>
		return sdfs.rename(oldfilepath, newfilepath);
	}
    2a86:	add	sp, #60	; 0x3c
    2a88:	pop	{r4, r5, pc}

00002a8a <FsVolume::bytesPerCluster() const>:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  uint32_t __attribute__((error("use sectorsPerCluster()"))) blocksPerCluster();
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
    2a8a:	ldr.w	r3, [r0, #1152]	; 0x480
           m_xVol ? m_xVol->bytesPerCluster() : 0;
    2a8e:	cbz	r3, 2a9e <FsVolume::bytesPerCluster() const+0x14>
    2a90:	ldrb	r0, [r3, #6]
    2a92:	mov.w	r3, #512	; 0x200
    2a96:	lsl.w	r0, r3, r0
    2a9a:	uxth	r0, r0
    2a9c:	bx	lr
    2a9e:	ldr.w	r0, [r0, #1156]	; 0x484
    2aa2:	cbz	r0, 2aa8 <FsVolume::bytesPerCluster() const+0x1e>
    2aa4:	ldr.w	r0, [r0, #1084]	; 0x43c
  }
    2aa8:	bx	lr

00002aaa <SDClass::totalSize()>:
	}
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
		  * (uint64_t)sdfs.bytesPerCluster();
	}
	uint64_t totalSize() {
    2aaa:	mov	r3, r0
    2aac:	push	{r4, lr}
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    2aae:	ldr.w	r2, [r3, #1156]	; 0x484
		return (uint64_t)sdfs.clusterCount() * (uint64_t)sdfs.bytesPerCluster();
    2ab2:	adds	r0, #4
           m_xVol ? m_xVol->clusterCount() : 0;
    2ab4:	cbz	r2, 2abc <SDClass::totalSize()+0x12>
    2ab6:	ldr	r4, [r2, #28]
    2ab8:	subs	r4, #1
    2aba:	b.n	2ac6 <SDClass::totalSize()+0x1c>
    2abc:	ldr.w	r4, [r3, #1160]	; 0x488
    2ac0:	cbz	r4, 2ac6 <SDClass::totalSize()+0x1c>
    2ac2:	ldr.w	r4, [r4, #1072]	; 0x430
    2ac6:	bl	2a8a <FsVolume::bytesPerCluster() const>
	}
    2aca:	umull	r0, r1, r4, r0
    2ace:	pop	{r4, pc}

00002ad0 <SDClass::usedSize()>:
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
		return sdfs.rmdir(filepath);
	}
	uint64_t usedSize() {
    2ad0:	push	{r3, r4, r5, lr}
    2ad2:	mov	r3, r0
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
    2ad4:	adds	r5, r0, #4
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    2ad6:	ldr.w	r0, [r0, #1156]	; 0x484
           m_xVol ? m_xVol->clusterCount() : 0;
    2ada:	cbz	r0, 2ae6 <SDClass::usedSize()+0x16>
    2adc:	ldr	r4, [r0, #28]
    2ade:	subs	r4, #1
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
    2ae0:	bl	6424 <FatPartition::freeClusterCount()>
    2ae4:	b.n	2af8 <SDClass::usedSize()+0x28>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    2ae6:	ldr.w	r0, [r3, #1160]	; 0x488
    2aea:	cbz	r0, 2af6 <SDClass::usedSize()+0x26>
    2aec:	ldr.w	r4, [r0, #1072]	; 0x430
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
           m_xVol ? m_xVol->freeClusterCount() : 0;
    2af0:	bl	4348 <ExFatPartition::freeClusterCount()>
    2af4:	b.n	2af8 <SDClass::usedSize()+0x28>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    2af6:	mov	r4, r0
    2af8:	subs	r4, r4, r0
		  * (uint64_t)sdfs.bytesPerCluster();
    2afa:	mov	r0, r5
    2afc:	bl	2a8a <FsVolume::bytesPerCluster() const>
	}
    2b00:	umull	r0, r1, r4, r0
    2b04:	pop	{r3, r4, r5, pc}

00002b06 <SdBase<FsVolume>::begin(SdioConfig)>:
  /** Initialize SD card and file system for SDIO mode.
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    2b06:	push	{r3, r4, r5, lr}
   * \param[in] config SDIO configuration.
   * \return generic card pointer or nullptr if SDIO is not supported.
   */
  SdCard* newCard(SdioConfig config) {
#if HAS_SDIO_CLASS
    m_sdioCard.begin(config);
    2b08:	add.w	r5, r0, #1168	; 0x490
    2b0c:	mov	r4, r0
    spiConfigBackupPin = 255;
    2b0e:	movs	r3, #255	; 0xff
    2b10:	strb.w	r3, [r0, #1200]	; 0x4b0
    sdioConfigBackup = sdioConfig;
    2b14:	strb.w	r1, [r0, #1212]	; 0x4bc
    2b18:	mov	r0, r5
    2b1a:	bl	80f0 <SdioCard::begin(SdioConfig)>
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdioConfig sdioConfig) {
    m_card = m_cardFactory.newCard(sdioConfig);
    2b1e:	str.w	r5, [r4, #1164]	; 0x48c
    return m_card && !m_card->errorCode();
    2b22:	mov	r0, r5
    2b24:	bl	78dc <SdioCard::errorCode() const>
    2b28:	cbnz	r0, 2b38 <SdBase<FsVolume>::begin(SdioConfig)+0x32>
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
    2b2a:	ldr.w	r1, [r4, #1164]	; 0x48c
    2b2e:	mov	r0, r4
  }
    2b30:	ldmia.w	sp!, {r3, r4, r5, lr}
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
    2b34:	b.w	6e18 <FsVolume::begin(BlockDeviceInterface*)>
  }
    2b38:	movs	r0, #0
    2b3a:	pop	{r3, r4, r5, pc}

00002b3c <SdBase<FsVolume>::cardBegin(SdSpiConfig)>:
  /** Initialize SD card in SPI mode.
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    2b3c:	push	{r4, r5, r6, lr}
    2b3e:	sub	sp, #32
    2b40:	mov	r6, r0
    2b42:	add	r0, sp, #4
    2b44:	stmia.w	r0, {r1, r2, r3}
    2b48:	ldmia	r0, {r0, r1, r2}
    2b4a:	add	r5, sp, #20
    2b4c:	stmia.w	r5, {r0, r1, r3}
   *
   * \param[in] config SPI configuration.
   * \return generic card pointer.
   */
  SdCard* newCard(SdSpiConfig config) {
    m_spiCard.begin(config);
    2b50:	addw	r4, r6, #1180	; 0x49c
    2b54:	ldmia.w	r5, {r1, r2, r3}
    2b58:	mov	r0, r4
    2b5a:	bl	724c <SdSpiCard::begin(SdSpiConfig)>
    m_card = m_cardFactory.newCard(spiConfig);
    2b5e:	str.w	r4, [r6, #1164]	; 0x48c
    return m_card && !m_card->errorCode();
    2b62:	cbz	r4, 2b70 <SdBase<FsVolume>::cardBegin(SdSpiConfig)+0x34>
    2b64:	ldrb.w	r0, [r6, #1195]	; 0x4ab
    2b68:	clz	r0, r0
    2b6c:	lsrs	r0, r0, #5
    2b6e:	b.n	2b72 <SdBase<FsVolume>::cardBegin(SdSpiConfig)+0x36>
    2b70:	mov	r0, r4
  }
    2b72:	add	sp, #32
    2b74:	pop	{r4, r5, r6, pc}

00002b76 <SdBase<FsVolume>::restart()>:
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
  }
  //----------------------------------------------------------------------------
  /** Restart library with same config, used after media removed and replaced */
  bool restart() {
    2b76:	push	{r4, r5, lr}
    if (spiConfigBackupPin == 255) {
    2b78:	ldrb.w	r3, [r0, #1200]	; 0x4b0
    2b7c:	cmp	r3, #255	; 0xff
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
  }
  //----------------------------------------------------------------------------
  /** Restart library with same config, used after media removed and replaced */
  bool restart() {
    2b7e:	sub	sp, #20
    2b80:	mov	r4, r0
    if (spiConfigBackupPin == 255) {
    2b82:	bne.n	2b8e <SdBase<FsVolume>::restart()+0x18>
      return begin(sdioConfigBackup);
    2b84:	ldrb.w	r1, [r0, #1212]	; 0x4bc
    2b88:	bl	2b06 <SdBase<FsVolume>::begin(SdioConfig)>
    2b8c:	b.n	2bc2 <SdBase<FsVolume>::restart()+0x4c>
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
    2b8e:	ldr.w	r1, [r0, #1204]	; 0x4b4
    2b92:	ldr.w	r2, [r0, #1208]	; 0x4b8
    2b96:	ldrb.w	r5, [r0, #1201]	; 0x4b1
    2b9a:	strb.w	r3, [sp, #4]
    2b9e:	strb.w	r5, [sp, #5]
    2ba2:	str	r1, [sp, #8]
    2ba4:	str	r2, [sp, #12]
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    2ba6:	add	r3, sp, #16
    2ba8:	ldmdb	r3, {r1, r2, r3}
    2bac:	bl	2b3c <SdBase<FsVolume>::cardBegin(SdSpiConfig)>
    2bb0:	cbz	r0, 2bc2 <SdBase<FsVolume>::restart()+0x4c>
    2bb2:	ldr.w	r1, [r4, #1164]	; 0x48c
    2bb6:	mov	r0, r4
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
      return begin(spiConfig);
    }
  }
    2bb8:	add	sp, #20
    2bba:	ldmia.w	sp!, {r4, r5, lr}
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    2bbe:	b.w	6e18 <FsVolume::begin(BlockDeviceInterface*)>
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
      return begin(spiConfig);
    }
  }
    2bc2:	add	sp, #20
    2bc4:	pop	{r4, r5, pc}

00002bc6 <SDClass::format(int, char, Print&)>:
	}
}
#endif

bool SDClass::format(int type, char progressChar, Print& pr)
{
    2bc6:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2bca:	ldr.w	r4, [r0, #1168]	; 0x490
    2bce:	sub	sp, #48	; 0x30
    2bd0:	mov	r6, r0
    2bd2:	mov	r7, r3
	SdCard *card = sdfs.card();
	if (!card) return false; // no SD card
    2bd4:	cbnz	r4, 2bda <SDClass::format(int, char, Print&)+0x14>
    2bd6:	movs	r0, #0
    2bd8:	b.n	2c24 <SDClass::format(int, char, Print&)+0x5e>
	uint32_t sectors = card->sectorCount();
    2bda:	ldr	r3, [r4, #0]
    2bdc:	mov	r0, r4
    2bde:	ldr	r3, [r3, #24]
    2be0:	blx	r3
	if (sectors <= 12288) return false; // card too small
    2be2:	cmp.w	r0, #12288	; 0x3000

bool SDClass::format(int type, char progressChar, Print& pr)
{
	SdCard *card = sdfs.card();
	if (!card) return false; // no SD card
	uint32_t sectors = card->sectorCount();
    2be6:	mov	r8, r0
	if (sectors <= 12288) return false; // card too small
    2be8:	bls.n	2bd6 <SDClass::format(int, char, Print&)+0x10>
	uint8_t *buf = (uint8_t *)malloc(512);
    2bea:	mov.w	r0, #512	; 0x200
    2bee:	bl	aad0 <malloc>
	if (!buf) return false; // unable to allocate memory
    2bf2:	mov	r5, r0
    2bf4:	cmp	r0, #0
    2bf6:	beq.n	2bd6 <SDClass::format(int, char, Print&)+0x10>
	bool ret;
	if (sectors > 67108864) {
    2bf8:	cmp.w	r8, #67108864	; 0x4000000
#ifdef __arm__
		ExFatFormatter exFatFormatter;
		ret = exFatFormatter.format(card, buf, &pr);
    2bfc:	mov	r2, r0
    2bfe:	mov	r3, r7
    2c00:	mov	r1, r4
    2c02:	add	r0, sp, #4
	uint32_t sectors = card->sectorCount();
	if (sectors <= 12288) return false; // card too small
	uint8_t *buf = (uint8_t *)malloc(512);
	if (!buf) return false; // unable to allocate memory
	bool ret;
	if (sectors > 67108864) {
    2c04:	bls.n	2c0c <SDClass::format(int, char, Print&)+0x46>
#ifdef __arm__
		ExFatFormatter exFatFormatter;
		ret = exFatFormatter.format(card, buf, &pr);
    2c06:	bl	32d8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>
    2c0a:	b.n	2c10 <SDClass::format(int, char, Print&)+0x4a>
#else
		ret = false;
#endif
	} else {
		FatFormatter fatFormatter;
		ret = fatFormatter.format(card, buf, &pr);
    2c0c:	bl	5260 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>
    2c10:	mov	r4, r0
	}
	free(buf);
    2c12:	mov	r0, r5
    2c14:	bl	aae0 <free>
	if (ret) {
    2c18:	cmp	r4, #0
    2c1a:	beq.n	2bd6 <SDClass::format(int, char, Print&)+0x10>
		// TODO: Is begin() really necessary?  Is a quicker way possible?
		sdfs.restart(); // TODO: is sdfs.volumeBegin() enough??
    2c1c:	adds	r0, r6, #4
    2c1e:	bl	2b76 <SdBase<FsVolume>::restart()>
    2c22:	movs	r0, #1
	}
	return ret;
}
    2c24:	add	sp, #48	; 0x30
    2c26:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00002c2a <SDClass::mediaPresent()>:
	}
	return false;
}

bool SDClass::mediaPresent()
{
    2c2a:	push	{r4, r5, lr}
    2c2c:	ldr.w	r4, [r0, #1168]	; 0x490
    2c30:	sub	sp, #20
    2c32:	mov	r5, r0
	//Serial.print("mediaPresent: ");
	bool ret;
	SdCard *card = sdfs.card();
	if (card) {
    2c34:	cbz	r4, 2c74 <SDClass::mediaPresent()+0x4a>
		if (cardPreviouslyPresent) {
    2c36:	ldrb.w	r3, [r0, #1220]	; 0x4c4
    2c3a:	cbz	r3, 2c6c <SDClass::mediaPresent()+0x42>
			#ifdef BUILTIN_SDCARD
			uint32_t s;
			if (csPin_ == BUILTIN_SDCARD) {
    2c3c:	ldrb.w	r3, [r0, #1221]	; 0x4c5
    2c40:	cmp	r3, #254	; 0xfe
    2c42:	beq.n	2c50 <SDClass::mediaPresent()+0x26>
			const uint32_t s = 0xFFFFFFFF;
			#endif
			if (s == 0xFFFFFFFF) {
				// SPI doesn't have 32 bit status, read CID register
				cid_t cid;
				ret = card->readCID(&cid);
    2c44:	ldr	r3, [r4, #0]
    2c46:	mov	r1, sp
    2c48:	ldr	r3, [r3, #56]	; 0x38
    2c4a:	mov	r0, r4
    2c4c:	blx	r3
    2c4e:	b.n	2c76 <SDClass::mediaPresent()+0x4c>
		if (cardPreviouslyPresent) {
			#ifdef BUILTIN_SDCARD
			uint32_t s;
			if (csPin_ == BUILTIN_SDCARD) {
				#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
				card->syncDevice();
    2c50:	ldr	r3, [r4, #0]
    2c52:	mov	r0, r4
    2c54:	ldr	r3, [r3, #28]
    2c56:	blx	r3
				#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
				s = card->status();
    2c58:	ldr	r3, [r4, #0]
    2c5a:	mov	r0, r4
    2c5c:	ldr	r3, [r3, #68]	; 0x44
    2c5e:	blx	r3
			} else s = 0xFFFFFFFF;
			#else
			const uint32_t s = 0xFFFFFFFF;
			#endif
			if (s == 0xFFFFFFFF) {
    2c60:	adds	r3, r0, #1
    2c62:	beq.n	2c44 <SDClass::mediaPresent()+0x1a>
				// SPI doesn't have 32 bit status, read CID register
				cid_t cid;
				ret = card->readCID(&cid);
				//Serial.print(ret ? "CID=ok" : "CID=unreadable");
			} else if (s == 0) {
    2c64:	adds	r0, #0
    2c66:	it	ne
    2c68:	movne	r0, #1
    2c6a:	b.n	2c76 <SDClass::mediaPresent()+0x4c>
			if ((csPin_ == BUILTIN_SDCARD) && !digitalReadFast(_SD_DAT3))
				ret = false;
			else
			#endif
			{
				ret = sdfs.restart();
    2c6c:	adds	r0, #4
    2c6e:	bl	2b76 <SdBase<FsVolume>::restart()>
    2c72:	b.n	2c76 <SDClass::mediaPresent()+0x4c>
			}
			//Serial.print(ret ? "begin ok" : "begin nope");
		}
	} else {
		//Serial.print("no card");
		ret = false;
    2c74:	mov	r0, r4
	}
	//Serial.println();
	cardPreviouslyPresent = ret;
    2c76:	strb.w	r0, [r5, #1220]	; 0x4c4
	return ret;
}
    2c7a:	add	sp, #20
    2c7c:	pop	{r4, r5, pc}
    2c7e:	Address 0x00002c7e is out of bounds.


00002c80 <_GLOBAL__sub_I_SD>:


class SDClass : public FS
{
public:
	SDClass() { }
    2c80:	ldr	r0, [pc, #72]	; (2ccc <_GLOBAL__sub_I_SD+0x4c>)
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    2c82:	ldr	r2, [pc, #76]	; (2cd0 <_GLOBAL__sub_I_SD+0x50>)
    2c84:	str.w	r2, [r0, #1172]	; 0x494
    2c88:	ldr	r2, [pc, #72]	; (2cd4 <_GLOBAL__sub_I_SD+0x54>)
    2c8a:	ldr	r3, [pc, #76]	; (2cd8 <_GLOBAL__sub_I_SD+0x58>)
    2c8c:	str.w	r2, [r0, #1184]	; 0x4a0
    2c90:	movs	r2, #1
    2c92:	str	r3, [r0, #0]
    2c94:	strb.w	r2, [r0, #1197]	; 0x4ad
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() {}
    2c98:	movs	r3, #0
    2c9a:	movs	r2, #41	; 0x29
    2c9c:	str.w	r3, [r0, #1156]	; 0x484
    2ca0:	str.w	r3, [r0, #1160]	; 0x488
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    2ca4:	strb.w	r3, [r0, #1180]	; 0x49c
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    2ca8:	strb.w	r3, [r0, #1181]	; 0x49d
    2cac:	strb.w	r2, [r0, #1199]	; 0x4af
    2cb0:	strb.w	r3, [r0, #1202]	; 0x4b2
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    2cb4:	strb.w	r3, [r0, #1216]	; 0x4c0
    2cb8:	strb.w	r3, [r0, #1220]	; 0x4c4
 */

#include <Arduino.h>
#include <SD.h>

SDClass SD;
    2cbc:	ldr	r2, [pc, #28]	; (2cdc <_GLOBAL__sub_I_SD+0x5c>)
    2cbe:	ldr	r1, [pc, #32]	; (2ce0 <_GLOBAL__sub_I_SD+0x60>)
    2cc0:	movs	r3, #255	; 0xff
    2cc2:	strb.w	r3, [r0, #1221]	; 0x4c5
    2cc6:	b.w	9cdc <__aeabi_atexit>
    2cca:	nop
    2ccc:	.word	0x1fff7f50
    2cd0:	.word	0x00012608
    2cd4:	.word	0x000125a8
    2cd8:	.word	0x000122a8
    2cdc:	.word	0x1fff0f30
    2ce0:	.word	0x000028e5

00002ce4 <FsUtf::cpToMb(unsigned long, char*, char*)>:
#include "FsUtf.h"
namespace FsUtf {
  //----------------------------------------------------------------------------
  char* cpToMb(uint32_t cp, char* str, char* end) {
    size_t n = end - str;
    if (cp < 0X80) {
    2ce4:	cmp	r0, #127	; 0x7f
 */
#include "FsUtf.h"
namespace FsUtf {
  //----------------------------------------------------------------------------
  char* cpToMb(uint32_t cp, char* str, char* end) {
    size_t n = end - str;
    2ce6:	sub.w	r2, r2, r1
    if (cp < 0X80) {
    2cea:	bhi.n	2cf6 <FsUtf::cpToMb(unsigned long, char*, char*)+0x12>
      if (n < 1) goto fail;
    2cec:	cmp	r2, #0
    2cee:	beq.n	2d70 <FsUtf::cpToMb(unsigned long, char*, char*)+0x8c>
      *(str++) = static_cast<uint8_t>(cp);
    2cf0:	strb	r0, [r1, #0]
    2cf2:	adds	r0, r1, #1
    2cf4:	bx	lr
    } else if (cp < 0X800) {
    2cf6:	cmp.w	r0, #2048	; 0x800
    2cfa:	bcs.n	2d18 <FsUtf::cpToMb(unsigned long, char*, char*)+0x34>
      if (n < 2) goto fail;
    2cfc:	cmp	r2, #1
    2cfe:	bls.n	2d74 <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    2d00:	lsrs	r3, r0, #6
    2d02:	mov	r2, r1
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    2d04:	and.w	r0, r0, #63	; 0x3f
    if (cp < 0X80) {
      if (n < 1) goto fail;
      *(str++) = static_cast<uint8_t>(cp);
    } else if (cp < 0X800) {
      if (n < 2) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    2d08:	orn	r3, r3, #63	; 0x3f
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    2d0c:	orn	r0, r0, #127	; 0x7f
    if (cp < 0X80) {
      if (n < 1) goto fail;
      *(str++) = static_cast<uint8_t>(cp);
    } else if (cp < 0X800) {
      if (n < 2) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    2d10:	strb.w	r3, [r2], #2
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    2d14:	strb	r0, [r1, #1]
    2d16:	b.n	2d70 <FsUtf::cpToMb(unsigned long, char*, char*)+0x8c>
    } else if (cp < 0X10000) {
    2d18:	cmp.w	r0, #65536	; 0x10000
    2d1c:	bcs.n	2d42 <FsUtf::cpToMb(unsigned long, char*, char*)+0x5e>
      if (n < 3) goto fail;
    2d1e:	cmp	r2, #2
    2d20:	bls.n	2d74 <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 12)         | 0XE0);
    2d22:	lsrs	r3, r0, #12
    2d24:	orn	r3, r3, #31
    2d28:	strb	r3, [r1, #0]
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    2d2a:	ubfx	r3, r0, #6, #6
    2d2e:	orn	r3, r3, #127	; 0x7f
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    2d32:	and.w	r0, r0, #63	; 0x3f
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    } else if (cp < 0X10000) {
      if (n < 3) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 12)         | 0XE0);
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    2d36:	strb	r3, [r1, #1]
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    2d38:	orn	r3, r0, #127	; 0x7f
    2d3c:	strb	r3, [r1, #2]
    2d3e:	adds	r0, r1, #3
    2d40:	bx	lr
    } else {
       if (n < 4) goto fail;
    2d42:	cmp	r2, #3
    2d44:	bls.n	2d74 <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 18)         | 0XF0);
    2d46:	lsrs	r3, r0, #18
    2d48:	orn	r3, r3, #15
    2d4c:	strb	r3, [r1, #0]
      *(str++) = static_cast<uint8_t>(((cp >> 12) & 0X3F)| 0X80);
    2d4e:	ubfx	r3, r0, #12, #6
    2d52:	orn	r3, r3, #127	; 0x7f
    2d56:	strb	r3, [r1, #1]
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    2d58:	ubfx	r3, r0, #6, #6
    2d5c:	orn	r3, r3, #127	; 0x7f
    2d60:	strb	r3, [r1, #2]
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    2d62:	and.w	r3, r0, #63	; 0x3f
    2d66:	orn	r3, r3, #127	; 0x7f
    2d6a:	strb	r3, [r1, #3]
    2d6c:	adds	r0, r1, #4
    2d6e:	bx	lr
    }
    return str;

   fail:
    return nullptr;
    2d70:	mov	r0, r2
    2d72:	bx	lr
    2d74:	movs	r0, #0
  }
    2d76:	bx	lr

00002d78 <FsUtf::mbToCp(char const*, char const*, unsigned long*)>:
  //----------------------------------------------------------------------------
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    size_t n;
    uint32_t cp;
    if (str >= end) {
    2d78:	cmp	r0, r1
   fail:
    return nullptr;
  }
  //----------------------------------------------------------------------------
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    2d7a:	push	{r4, r5, lr}
    size_t n;
    uint32_t cp;
    if (str >= end) {
    2d7c:	bcs.n	2dec <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
      return nullptr;
    }
    uint8_t ch = str[0];
    2d7e:	ldrb	r3, [r0, #0]
    if ((ch & 0X80) == 0) {
    2d80:	lsls	r4, r3, #24
    2d82:	bmi.n	2d8a <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x12>
      *rtn = ch;
    2d84:	str	r3, [r2, #0]
      return str + 1;
    2d86:	adds	r4, r0, #1
    2d88:	b.n	2df2 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x7a>
    }
    if ((ch & 0XE0) == 0XC0) {
    2d8a:	and.w	r4, r3, #224	; 0xe0
    2d8e:	cmp	r4, #192	; 0xc0
    2d90:	bne.n	2d9a <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x22>
      cp = ch & 0X1F;
    2d92:	and.w	r3, r3, #31
      n = 2;
    2d96:	movs	r4, #2
    2d98:	b.n	2db8 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x40>
    } else if ((ch & 0XF0) == 0XE0) {
    2d9a:	and.w	r4, r3, #240	; 0xf0
    2d9e:	cmp	r4, #224	; 0xe0
    2da0:	bne.n	2daa <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x32>
      cp = ch & 0X0F;
    2da2:	and.w	r3, r3, #15
      n = 3;
    2da6:	movs	r4, #3
    2da8:	b.n	2db8 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x40>
    } else if ((ch & 0XF8) == 0XF0) {
    2daa:	and.w	r4, r3, #248	; 0xf8
    2dae:	cmp	r4, #240	; 0xf0
    2db0:	bne.n	2dec <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
      cp = ch & 0X07;
    2db2:	and.w	r3, r3, #7
      n = 4;
    2db6:	movs	r4, #4
    } else {
      return nullptr;
    }
    if ((str + n) > end) {
    2db8:	add	r4, r0
    2dba:	cmp	r1, r4
    2dbc:	bcc.n	2dec <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
    2dbe:	adds	r0, #1
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
      ch = str[i];
    2dc0:	ldrb.w	r1, [r0], #1
      if ((ch & 0XC0) != 0X80) {
    2dc4:	and.w	r5, r1, #192	; 0xc0
    2dc8:	cmp	r5, #128	; 0x80
    2dca:	bne.n	2dec <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
        return nullptr;
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    2dcc:	and.w	r1, r1, #63	; 0x3f
      return nullptr;
    }
    if ((str + n) > end) {
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
    2dd0:	cmp	r0, r4
      ch = str[i];
      if ((ch & 0XC0) != 0X80) {
        return nullptr;
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    2dd2:	orr.w	r3, r1, r3, lsl #6
      return nullptr;
    }
    if ((str + n) > end) {
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
    2dd6:	bne.n	2dc0 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x48>
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    }
    // Don't allow over long as ASCII.
    if (cp < 0X80 || !isValidCp(cp)) {
    2dd8:	ldr	r1, [pc, #28]	; (2df8 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x80>)
    2dda:	sub.w	r0, r3, #128	; 0x80
    2dde:	cmp	r0, r1
    2de0:	bhi.n	2dec <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
  /** Check for a valid code point.
   * \param[in] cp code point.
   * \return true if valid else false.
   */
  inline bool isValidCp(uint32_t cp) {
    return cp <= 0x10FFFF && (cp < 0XD800 || cp > 0XDFFF);
    2de2:	sub.w	r1, r3, #55296	; 0xd800
    2de6:	cmp.w	r1, #2048	; 0x800
    2dea:	bcs.n	2df0 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x78>
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    size_t n;
    uint32_t cp;
    if (str >= end) {
      return nullptr;
    2dec:	movs	r4, #0
    2dee:	b.n	2df2 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x7a>
    }
    // Don't allow over long as ASCII.
    if (cp < 0X80 || !isValidCp(cp)) {
      return nullptr;
    }
    *rtn = cp;
    2df0:	str	r3, [r2, #0]
    return str + n;
  }
    2df2:	mov	r0, r4
    2df4:	pop	{r4, r5, pc}
    2df6:	nop
    2df8:	.word	0x0010ff7f

00002dfc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>:
#include "FsGetPartitionInfo.h"
namespace FsGetPartitionInfo {
  static const uint8_t mbdpGuid[16] PROGMEM = {0xA2, 0xA0, 0xD0, 0xEB, 0xE5, 0xB9, 0x33, 0x44, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7};

  voltype_t getPartitionInfo(BlockDeviceInterface *blockDev, uint8_t part, uint8_t *secBuf,
      uint32_t *pfirstLBA, uint32_t *psectorCount, uint32_t *pmbrLBA, uint8_t *pmbrPart) {
    2dfc:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2e00:	add	r6, sp, #48	; 0x30
    2e02:	mov	r5, r0
    2e04:	mov	r4, r2
    2e06:	mov	sl, r3
    2e08:	ldmia.w	r6, {r6, r7, r8}
    uint32_t firstLBA;
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    2e0c:	str	r1, [sp, #4]
    2e0e:	cbnz	r1, 2e14 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x18>
    2e10:	movs	r0, #0
    2e12:	b.n	2f9c <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    2e14:	cmp.w	sl, #0
    2e18:	beq.n	2e10 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    part--; // zero base it.

    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    2e1a:	ldr	r3, [r0, #0]
    2e1c:	movs	r1, #0
    2e1e:	ldr	r3, [r3, #12]
    2e20:	blx	r3
    2e22:	cmp	r0, #0
    2e24:	beq.n	2e10 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    part--; // zero base it.
    2e26:	ldr	r3, [sp, #4]
    2e28:	add.w	r9, r3, #4294967295
    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    mbr = reinterpret_cast<MbrSector_t*>(secBuf);

    // First check for GPT vs MBR
    mp = &mbr->part[0];
    if (mp->type == 0xee) {
    2e2c:	ldrb.w	r3, [r4, #450]	; 0x1c2
    2e30:	cmp	r3, #238	; 0xee
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    part--; // zero base it.
    2e32:	uxtb.w	r9, r9
    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    mbr = reinterpret_cast<MbrSector_t*>(secBuf);

    // First check for GPT vs MBR
    mp = &mbr->part[0];
    if (mp->type == 0xee) {
    2e36:	bne.n	2eb8 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xbc>
      // This is a GPT initialized Disk assume validation done earlier.
      if (!blockDev->readSector(1, secBuf)) return INVALID_VOL; 
    2e38:	ldr	r3, [r5, #0]
    2e3a:	mov	r2, r4
    2e3c:	ldr	r3, [r3, #12]
    2e3e:	movs	r1, #1
    2e40:	mov	r0, r5
    2e42:	blx	r3
    2e44:	cmp	r0, #0
    2e46:	beq.n	2e10 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      GPTPartitionHeader_t* gptph = reinterpret_cast<GPTPartitionHeader_t*>(secBuf);
      // Lets do a little validation of this data.
      if (!gptph || (memcmp(gptph->signature, F("EFI PART"), 8) != 0))  return INVALID_VOL;
    2e48:	movs	r2, #8
    2e4a:	ldr	r1, [pc, #344]	; (2fa4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a8>)
    2e4c:	mov	r0, r4
    2e4e:	bl	b130 <memcmp>
    2e52:	cmp	r0, #0
    2e54:	bne.n	2e10 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      uint32_t numberPartitions = getLe32(gptph->numberPartitions);
      if (part > numberPartitions)  return INVALID_VOL;
    2e56:	ldr	r3, [r4, #80]	; 0x50
    2e58:	cmp	r9, r3
    2e5a:	bhi.n	2e10 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>

      // We will overload the mbr part to give clue where GPT data is stored for this volume
      uint32_t mbrLBA = 2 + (part >> 2);
    2e5c:	mov.w	r1, r9, asr #2
    2e60:	adds	r1, #2
      uint8_t mbrPart = part & 0x3;
    2e62:	and.w	r9, r9, #3
      if (pmbrLBA) *pmbrLBA = mbrLBA;
    2e66:	cbz	r7, 2e6a <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x6e>
    2e68:	str	r1, [r7, #0]
      if (pmbrPart) *pmbrPart =mbrPart;
    2e6a:	cmp.w	r8, #0
    2e6e:	beq.n	2e74 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x78>
    2e70:	strb.w	r9, [r8]
      if (!blockDev->readSector(mbrLBA, secBuf)) return INVALID_VOL; 
    2e74:	ldr	r3, [r5, #0]
    2e76:	mov	r2, r4
    2e78:	ldr	r3, [r3, #12]
    2e7a:	mov	r0, r5
    2e7c:	blx	r3
    2e7e:	cmp	r0, #0
    2e80:	beq.n	2e10 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      GPTPartitionEntrySector_t *gptes = reinterpret_cast<GPTPartitionEntrySector_t*>(secBuf);
      GPTPartitionEntryItem_t *gptei = &gptes->items[mbrPart];

      // Mow extract the data...
      firstLBA = getLe64(gptei->firstLBA);
    2e82:	mov.w	r0, r9, lsl #7
    2e86:	add.w	r3, r0, #32
    2e8a:	ldr	r2, [r4, r3]
      sectorCount = 1 + getLe64(gptei->lastLBA) - getLe64(gptei->firstLBA);
    2e8c:	add.w	r3, r0, #40	; 0x28
    2e90:	ldr	r3, [r4, r3]
    2e92:	adds	r3, #1
    2e94:	subs	r3, r3, r2
      if ((firstLBA == 0) && (sectorCount == 1)) return INVALID_VOL;
    2e96:	cbnz	r2, 2e9c <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xa0>
    2e98:	cmp	r3, #1
    2e9a:	beq.n	2e10 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      
      *pfirstLBA = firstLBA;
    2e9c:	str.w	r2, [sl]
      if (psectorCount) *psectorCount = sectorCount;
    2ea0:	cbz	r6, 2ea4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xa8>
    2ea2:	str	r3, [r6, #0]

      if (memcmp((uint8_t *)gptei->partitionTypeGUID, mbdpGuid, 16) != 0) return OTHER_VOL;
    2ea4:	movs	r2, #16
    2ea6:	ldr	r1, [pc, #256]	; (2fa8 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1ac>)
    2ea8:	add	r0, r4
    2eaa:	bl	b130 <memcmp>
    2eae:	cmp	r0, #0
    2eb0:	ite	eq
    2eb2:	moveq	r0, #3
    2eb4:	movne	r0, #4
    2eb6:	b.n	2f9c <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    }
    // So we are now looking a MBR type setups. 
    // Extended support we need to walk through the partitions to see if there is an extended partition
    // that we need to walk into. 
    // short cut:
    if (part < 4) {
    2eb8:	cmp.w	r9, #3
    2ebc:	bhi.n	2efe <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
      // try quick way through
      mp = &mbr->part[part];
      if (((mp->boot == 0) || (mp->boot == 0X80)) && (mp->type != 0) && (mp->type != 0xf)) {
    2ebe:	add.w	r3, r4, r9, lsl #4
    2ec2:	ldrb.w	r2, [r3, #446]	; 0x1be
    2ec6:	lsls	r2, r2, #25
    2ec8:	bne.n	2efe <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
    2eca:	ldrb.w	r3, [r3, #450]	; 0x1c2
    2ece:	cbz	r3, 2efe <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
    2ed0:	cmp	r3, #15
    2ed2:	beq.n	2efe <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
        *pfirstLBA = getLe32(mp->relativeSectors);
    2ed4:	add.w	r3, r9, #28
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    2ed8:	add.w	r4, r4, r3, lsl #4
    2edc:	ldr.w	r3, [r4, #6]
    2ee0:	str.w	r3, [sl]
        if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
    2ee4:	cbz	r6, 2eec <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xf0>
    2ee6:	ldr.w	r3, [r4, #10]
    2eea:	str	r3, [r6, #0]
        if (pmbrLBA) *pmbrLBA = 0;
    2eec:	cbz	r7, 2ef2 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xf6>
    2eee:	movs	r3, #0
    2ef0:	str	r3, [r7, #0]
        if (pmbrPart) *pmbrPart = part; // zero based. 
    2ef2:	cmp.w	r8, #0
    2ef6:	beq.n	2f2c <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x130>
    2ef8:	strb.w	r9, [r8]
    2efc:	b.n	2f2c <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x130>
    2efe:	mov	r1, r4
#include "FsGetPartitionInfo.h"
namespace FsGetPartitionInfo {
  static const uint8_t mbdpGuid[16] PROGMEM = {0xA2, 0xA0, 0xD0, 0xEB, 0xE5, 0xB9, 0x33, 0x44, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7};

  voltype_t getPartitionInfo(BlockDeviceInterface *blockDev, uint8_t part, uint8_t *secBuf,
      uint32_t *pfirstLBA, uint32_t *psectorCount, uint32_t *pmbrLBA, uint8_t *pmbrPart) {
    2f00:	movs	r3, #0

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
      mp = &mbr->part[index_part];
      if ((mp->boot != 0 && mp->boot != 0X80) || mp->type == 0 || index_part > part) return INVALID_VOL;
    2f02:	ldrb.w	r0, [r1, #446]	; 0x1be
    2f06:	lsls	r0, r0, #25
    2f08:	uxtb	r2, r3
    2f0a:	bne.n	2e10 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    2f0c:	ldrb.w	r0, [r1, #450]	; 0x1c2
    2f10:	cmp	r0, #0
    2f12:	beq.w	2e10 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    2f16:	cmp	r9, r2
    2f18:	bcc.w	2e10 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      if (mp->type == 0xf) break;
    2f1c:	cmp	r0, #15
    2f1e:	beq.n	2f30 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x134>
    2f20:	adds	r3, #1
      }
    }  

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
    2f22:	cmp	r3, #4
    2f24:	add.w	r1, r1, #16
    2f28:	bne.n	2f02 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x106>
    2f2a:	b.n	2e10 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      if (((mp->boot == 0) || (mp->boot == 0X80)) && (mp->type != 0) && (mp->type != 0xf)) {
        *pfirstLBA = getLe32(mp->relativeSectors);
        if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
        if (pmbrLBA) *pmbrLBA = 0;
        if (pmbrPart) *pmbrPart = part; // zero based. 
        return MBR_VOL;
    2f2c:	movs	r0, #1
    2f2e:	b.n	2f9c <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    }  

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
      mp = &mbr->part[index_part];
    2f30:	add.w	r3, r4, r3, lsl #4
    2f34:	adds	r2, #1
    2f36:	ldr.w	r9, [r3, #454]	; 0x1c6
    2f3a:	uxtb.w	fp, r2
    if (index_part == 4) return INVALID_VOL; // no extended partition found. 

    // Our partition if it exists is in extended partition. 
    uint32_t next_mbr = getLe32(mp->relativeSectors);
    for(;;) {
      if (!blockDev->readSector(next_mbr, secBuf)) return INVALID_VOL;
    2f3e:	ldr	r3, [r5, #0]
    2f40:	mov	r2, r4
    2f42:	ldr	r3, [r3, #12]
    2f44:	mov	r1, r9
    2f46:	mov	r0, r5
    2f48:	blx	r3
    2f4a:	cmp	r0, #0
    2f4c:	beq.w	2e10 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      mbr = reinterpret_cast<MbrSector_t*>(secBuf);

      if (index_part == part) break; // should be at that entry
    2f50:	ldr	r3, [sp, #4]
    2f52:	cmp	r3, fp
    2f54:	beq.n	2f76 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x17a>
      // else we need to see if it points to others...
      mp = &mbr->part[1];
      uint32_t  relSec = getLe32(mp->relativeSectors);
      //Serial.printf("    Check for next: type: %u start:%u\n ", mp->type, volumeStartSector);
      if ((mp->type == 5) && relSec) {
    2f56:	ldrb.w	r2, [r4, #466]	; 0x1d2
    2f5a:	ldr.w	r3, [r4, #470]	; 0x1d6
    2f5e:	cmp	r2, #5
    2f60:	bne.w	2e10 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    2f64:	add.w	r2, fp, #1
    2f68:	uxtb.w	fp, r2
    2f6c:	cmp	r3, #0
    2f6e:	beq.w	2e10 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
        next_mbr = next_mbr + relSec;
    2f72:	add	r9, r3

    if (index_part == 4) return INVALID_VOL; // no extended partition found. 

    // Our partition if it exists is in extended partition. 
    uint32_t next_mbr = getLe32(mp->relativeSectors);
    for(;;) {
    2f74:	b.n	2f3e <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x142>
      } else return INVALID_VOL;
    }
   
    // If we are here than we should hopefully be at start of segment...
    mp = &mbr->part[0];
    *pfirstLBA = getLe32(mp->relativeSectors) + next_mbr;
    2f76:	ldr.w	r3, [r4, #454]	; 0x1c6
    2f7a:	add	r3, r9
    2f7c:	str.w	r3, [sl]
    if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
    2f80:	cbz	r6, 2f88 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x18c>
    2f82:	ldr.w	r3, [r4, #458]	; 0x1ca
    2f86:	str	r3, [r6, #0]
    if (pmbrLBA) *pmbrLBA = next_mbr;
    2f88:	cbz	r7, 2f8e <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x192>
    2f8a:	str.w	r9, [r7]
    if (pmbrPart) *pmbrPart = 0; // zero based. 
    2f8e:	cmp.w	r8, #0
    2f92:	beq.n	2f9a <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x19e>
    2f94:	movs	r3, #0
    2f96:	strb.w	r3, [r8]
    return EXT_VOL;
    2f9a:	movs	r0, #2
  }
    2f9c:	add	sp, #12
    2f9e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2fa2:	nop
    2fa4:	.word	0x000122e0
    2fa8:	.word	0x000122d0

00002fac <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>:
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    2fac:	cmp.w	r1, #256	; 0x100
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsStructs.h"
// bgnLba = relSector;
// endLba = relSector + partSize - 1;
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba) {
    2fb0:	push	{r4, r5, lr}
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    2fb2:	bhi.n	2fc2 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x16>
  if (capacityMB <= 16) {
    2fb4:	cmp	r1, #16
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    2fb6:	mov.w	r4, #32
  if (capacityMB <= 16) {
    2fba:	bls.n	2fe6 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x3a>
    numberOfHeads = 2;
  } else if (capacityMB <= 32) {
    2fbc:	cmp	r1, #32
    2fbe:	bls.n	2fea <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x3e>
    2fc0:	b.n	2fc4 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x18>
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    2fc2:	movs	r4, #63	; 0x3f
  if (capacityMB <= 16) {
    numberOfHeads = 2;
  } else if (capacityMB <= 32) {
    numberOfHeads = 4;
  } else if (capacityMB <= 128) {
    2fc4:	cmp	r1, #128	; 0x80
    2fc6:	bls.n	2fee <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x42>
    numberOfHeads = 8;
  } else if (capacityMB <= 504) {
    2fc8:	cmp.w	r1, #504	; 0x1f8
    2fcc:	bls.n	2ff2 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x46>
    numberOfHeads = 16;
  } else if (capacityMB <= 1008) {
    2fce:	cmp.w	r1, #1008	; 0x3f0
    2fd2:	bls.n	2ff6 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x4a>
    numberOfHeads = 32;
  } else if (capacityMB <= 2016) {
    2fd4:	cmp.w	r1, #2016	; 0x7e0
    2fd8:	bls.n	2ffa <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x4e>
    numberOfHeads = 64;
  } else if (capacityMB <= 4032) {
    2fda:	cmp.w	r1, #4032	; 0xfc0
    numberOfHeads = 128;
  } else {
    numberOfHeads = 255;
    2fde:	ite	ls
    2fe0:	movls	r3, #128	; 0x80
    2fe2:	movhi	r3, #255	; 0xff
    2fe4:	b.n	2ffc <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
  if (capacityMB <= 16) {
    numberOfHeads = 2;
    2fe6:	movs	r3, #2
    2fe8:	b.n	2ffc <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 32) {
    numberOfHeads = 4;
    2fea:	movs	r3, #4
    2fec:	b.n	2ffc <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 128) {
    numberOfHeads = 8;
    2fee:	movs	r3, #8
    2ff0:	b.n	2ffc <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 504) {
    numberOfHeads = 16;
    2ff2:	movs	r3, #16
    2ff4:	b.n	2ffc <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 1008) {
    numberOfHeads = 32;
    2ff6:	movs	r3, #32
    2ff8:	b.n	2ffc <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 2016) {
    numberOfHeads = 64;
    2ffa:	movs	r3, #64	; 0x40
  } else if (capacityMB <= 4032) {
    numberOfHeads = 128;
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
    2ffc:	smulbb	r3, r3, r4
    3000:	udiv	r5, r2, r3
  if (c <= 1023) {
    3004:	cmp.w	r5, #1024	; 0x400
    3008:	bcs.n	3022 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x76>
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
    300a:	udiv	r1, r2, r4
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    300e:	mls	r3, r3, r5, r2
    s = (lba % sectorsPerTrack) + 1;
    3012:	mls	r2, r4, r1, r2
    3016:	adds	r2, #1
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    3018:	udiv	r3, r3, r4
    s = (lba % sectorsPerTrack) + 1;
    301c:	uxtb	r2, r2
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    301e:	uxtb	r3, r3
    3020:	b.n	302a <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x7e>
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    h = 254;
    s = 63;
    3022:	movs	r2, #63	; 0x3f
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    h = 254;
    3024:	movs	r3, #254	; 0xfe
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    3026:	movw	r5, #1023	; 0x3ff
    h = 254;
    s = 63;
  }
  chs[0] = h;
    302a:	strb	r3, [r0, #0]
  chs[1] = ((c >> 2) & 0XC0) | s;
    302c:	lsrs	r3, r5, #2
    302e:	bic.w	r3, r3, #63	; 0x3f
    3032:	orrs	r2, r3
    3034:	strb	r2, [r0, #1]
  chs[2] = c;
    3036:	strb	r5, [r0, #2]
    3038:	pop	{r4, r5, pc}

0000303a <FsCache::sync()>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    303a:	push	{r3, r4, r5, r6, r7, lr}
  if (m_status & CACHE_STATUS_DIRTY) {
    303c:	ldrb	r3, [r0, #0]
    303e:	lsls	r2, r3, #31

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    3040:	mov	r4, r0
  if (m_status & CACHE_STATUS_DIRTY) {
    3042:	bpl.n	3080 <FsCache::sync()+0x46>
    if (!m_blockDev->writeSector(m_sector, m_buffer)) {
    3044:	ldr	r0, [r0, #4]
    3046:	ldr	r1, [r4, #12]
    3048:	ldr	r3, [r0, #0]
    304a:	add.w	r6, r4, #16
    304e:	ldr	r3, [r3, #32]
    3050:	mov	r2, r6
    3052:	blx	r3
    3054:	mov	r5, r0
    3056:	cbnz	r0, 305c <FsCache::sync()+0x22>
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;

 fail:
  return false;
    3058:	movs	r5, #0
    305a:	b.n	3082 <FsCache::sync()+0x48>
    if (!m_blockDev->writeSector(m_sector, m_buffer)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
    305c:	ldrb	r3, [r4, #0]
    305e:	lsls	r3, r3, #30
    3060:	bmi.n	306c <FsCache::sync()+0x32>
      if (!m_blockDev->writeSector(sector, m_buffer)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
    3062:	ldrb	r3, [r4, #0]
    3064:	bic.w	r3, r3, #1
    3068:	strb	r3, [r4, #0]
    306a:	b.n	3082 <FsCache::sync()+0x48>
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
      uint32_t sector = m_sector + m_mirrorOffset;
      if (!m_blockDev->writeSector(sector, m_buffer)) {
    306c:	adds	r0, r4, #4
    306e:	ldmia	r0, {r0, r1, r7}
    3070:	ldr	r3, [r0, #0]
    3072:	mov	r2, r6
    3074:	ldr	r3, [r3, #32]
    3076:	add	r1, r7
    3078:	blx	r3
    307a:	cmp	r0, #0
    307c:	bne.n	3062 <FsCache::sync()+0x28>
    307e:	b.n	3058 <FsCache::sync()+0x1e>
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;
    3080:	movs	r5, #1

 fail:
  return false;
}
    3082:	mov	r0, r5
    3084:	pop	{r3, r4, r5, r6, r7, pc}

00003086 <FsCache::get(unsigned long, unsigned char)>:
#define DBG_FILE "FsCache.cpp"
#include "DebugMacros.h"
#include "FsCache.h"
//------------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
  if (!m_blockDev) {
    3086:	ldr	r3, [r0, #4]
 */
#define DBG_FILE "FsCache.cpp"
#include "DebugMacros.h"
#include "FsCache.h"
//------------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
    3088:	push	{r4, r5, r6, lr}
    308a:	mov	r4, r0
    308c:	mov	r6, r1
    308e:	mov	r5, r2
  if (!m_blockDev) {
    3090:	cbnz	r3, 3096 <FsCache::get(unsigned long, unsigned char)+0x10>
  }
  m_status |= option & CACHE_STATUS_MASK;
  return m_buffer;

 fail:
  return nullptr;
    3092:	movs	r0, #0
    3094:	pop	{r4, r5, r6, pc}
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
  if (!m_blockDev) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_sector != sector) {
    3096:	ldr	r3, [r0, #12]
    3098:	cmp	r3, r1
    309a:	beq.n	30c4 <FsCache::get(unsigned long, unsigned char)+0x3e>
    if (!sync()) {
    309c:	bl	303a <FsCache::sync()>
    30a0:	cmp	r0, #0
    30a2:	beq.n	3092 <FsCache::get(unsigned long, unsigned char)+0xc>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
    30a4:	lsls	r3, r5, #29
    30a6:	bpl.n	30b0 <FsCache::get(unsigned long, unsigned char)+0x2a>
      if (!m_blockDev->readSector(sector, m_buffer)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status = 0;
    30a8:	movs	r3, #0
    30aa:	strb	r3, [r4, #0]
    m_sector = sector;
    30ac:	str	r6, [r4, #12]
    30ae:	b.n	30c4 <FsCache::get(unsigned long, unsigned char)+0x3e>
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
      if (!m_blockDev->readSector(sector, m_buffer)) {
    30b0:	ldr	r0, [r4, #4]
    30b2:	ldr	r3, [r0, #0]
    30b4:	add.w	r2, r4, #16
    30b8:	ldr	r3, [r3, #12]
    30ba:	mov	r1, r6
    30bc:	blx	r3
    30be:	cmp	r0, #0
    30c0:	bne.n	30a8 <FsCache::get(unsigned long, unsigned char)+0x22>
    30c2:	b.n	3092 <FsCache::get(unsigned long, unsigned char)+0xc>
      }
    }
    m_status = 0;
    m_sector = sector;
  }
  m_status |= option & CACHE_STATUS_MASK;
    30c4:	ldrb	r3, [r4, #0]
    30c6:	mov	r0, r4
    30c8:	and.w	r5, r5, #3
    30cc:	orrs	r5, r3
    30ce:	strb.w	r5, [r0], #16
  return m_buffer;

 fail:
  return nullptr;
}
    30d2:	pop	{r4, r5, r6, pc}

000030d4 <toUpcase(unsigned short)>:
}
//------------------------------------------------------------------------------
uint16_t toUpcase(uint16_t chr) {
  uint16_t i, first;
  // Optimize for simple ASCII.
  if (chr < 127) {
    30d4:	cmp	r0, #126	; 0x7e
    }
  }
  return left;
}
//------------------------------------------------------------------------------
uint16_t toUpcase(uint16_t chr) {
    30d6:	push	{r4, r5, lr}
  uint16_t i, first;
  // Optimize for simple ASCII.
  if (chr < 127) {
    30d8:	bhi.n	30e8 <toUpcase(unsigned short)+0x14>
    return chr - ('a' <= chr && chr <= 'z' ? 'a' - 'A' : 0);
    30da:	sub.w	r3, r0, #97	; 0x61
    30de:	cmp	r3, #25
    30e0:	ite	hi
    30e2:	movhi	r3, #0
    30e4:	movls	r3, #32
    30e6:	b.n	312a <toUpcase(unsigned short)+0x56>
    30e8:	ldr	r5, [pc, #132]	; (3170 <toUpcase(unsigned short)+0x9c>)
    30ea:	movs	r4, #53	; 0x35
    30ec:	movs	r3, #0
//------------------------------------------------------------------------------
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    30ee:	subs	r2, r4, r3
    30f0:	cmp	r2, #1
    30f2:	ldr	r1, [pc, #124]	; (3170 <toUpcase(unsigned short)+0x9c>)
    30f4:	bls.n	3108 <toUpcase(unsigned short)+0x34>
    mid = left + (right - left)/2;
    30f6:	add.w	r2, r3, r2, lsr #1
    if (readTable16(table[mid].key) <= key) {
    30fa:	ldrh.w	r1, [r5, r2, lsl #2]
    30fe:	cmp	r1, r0
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    mid = left + (right - left)/2;
    3100:	ite	hi
    3102:	movhi	r4, r2
    3104:	movls	r3, r2
    3106:	b.n	30ee <toUpcase(unsigned short)+0x1a>
  // Optimize for simple ASCII.
  if (chr < 127) {
    return chr - ('a' <= chr && chr <= 'z' ? 'a' - 'A' : 0);
  }
  i = searchPair16(reinterpret_cast<const pair16_t*>(mapTable), MAP_DIM, chr);
  first = readTable16(mapTable[i].base);
    3108:	uxth	r2, r3
    310a:	ldrh.w	r3, [r1, r2, lsl #2]
  if (first <= chr && (chr - first)  < readTable8(mapTable[i].count)) {
    310e:	cmp	r0, r3
    3110:	bcc.n	313e <toUpcase(unsigned short)+0x6a>
    3112:	add.w	r2, r1, r2, lsl #2
    3116:	subs	r3, r0, r3
    3118:	ldrb	r1, [r2, #3]
    311a:	cmp	r3, r1
    311c:	bge.n	313e <toUpcase(unsigned short)+0x6a>
    int8_t off = readTable8(mapTable[i].off);
    311e:	ldrsb.w	r2, [r2, #2]
    if (off == 1) {
    3122:	cmp	r2, #1
    3124:	bne.n	312e <toUpcase(unsigned short)+0x5a>
      return chr - ((chr - first) & 1);
    3126:	and.w	r3, r3, #1
    312a:	subs	r0, r0, r3
    312c:	b.n	313a <toUpcase(unsigned short)+0x66>
    }
    return chr + (off ? off : -0x1C60);
    312e:	cbz	r2, 3134 <toUpcase(unsigned short)+0x60>
    3130:	uxth	r2, r2
    3132:	b.n	3138 <toUpcase(unsigned short)+0x64>
    3134:	movw	r2, #58272	; 0xe3a0
    3138:	add	r0, r2
    313a:	uxth	r0, r0
    313c:	pop	{r4, r5, pc}
    313e:	ldr	r5, [pc, #52]	; (3174 <toUpcase(unsigned short)+0xa0>)
    3140:	movs	r4, #75	; 0x4b
    3142:	movs	r3, #0
//------------------------------------------------------------------------------
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    3144:	subs	r2, r4, r3
    3146:	cmp	r2, #1
    3148:	ldr	r1, [pc, #40]	; (3174 <toUpcase(unsigned short)+0xa0>)
    314a:	bls.n	315e <toUpcase(unsigned short)+0x8a>
    mid = left + (right - left)/2;
    314c:	add.w	r2, r3, r2, lsr #1
    if (readTable16(table[mid].key) <= key) {
    3150:	ldrh.w	r1, [r5, r2, lsl #2]
    3154:	cmp	r1, r0
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    mid = left + (right - left)/2;
    3156:	ite	hi
    3158:	movhi	r4, r2
    315a:	movls	r3, r2
    315c:	b.n	3144 <toUpcase(unsigned short)+0x70>
      return chr - ((chr - first) & 1);
    }
    return chr + (off ? off : -0x1C60);
  }
  i = searchPair16(lookupTable, LOOKUP_DIM, chr);
  if (readTable16(lookupTable[i].key) == chr) {
    315e:	uxth	r3, r3
    3160:	ldrh.w	r2, [r1, r3, lsl #2]
    3164:	cmp	r2, r0
    return readTable16(lookupTable[i].val);
    3166:	itt	eq
    3168:	addeq.w	r3, r1, r3, lsl #2
    316c:	ldrheq	r0, [r3, #2]
  }
  return chr;
}
    316e:	pop	{r4, r5, pc}
    3170:	.word	0x00012416
    3174:	.word	0x000122ea

00003178 <FsName::get16()>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsName.h"
#include "FsUtf.h"
#if USE_UTF8_LONG_NAMES
uint16_t FsName::get16() {
    3178:	push	{r0, r1, r4, lr}
    317a:	mov	r4, r0
  uint16_t rtn;
  if (ls) {
    317c:	ldrh	r0, [r0, #12]
    317e:	cbz	r0, 3186 <FsName::get16()+0xe>
    rtn = ls;
    ls = 0;
    3180:	movs	r3, #0
    3182:	strh	r3, [r4, #12]
    3184:	b.n	31bc <FsName::get16()+0x44>
  } else if (next >= end) {
    3186:	ldr	r3, [r4, #4]
    3188:	ldr	r1, [r4, #8]
    318a:	cmp	r3, r1
    318c:	bcs.n	31bc <FsName::get16()+0x44>
    rtn = 0;
  } else {
    uint32_t cp;
    const char* ptr = FsUtf::mbToCp(next, end, &cp);
    318e:	add	r2, sp, #4
    3190:	mov	r0, r3
    3192:	bl	2d78 <FsUtf::mbToCp(char const*, char const*, unsigned long*)>
    if (!ptr) {
    3196:	cbz	r0, 31b8 <FsName::get16()+0x40>
      goto fail;
    }
    next = ptr;
    3198:	str	r0, [r4, #4]
    if (cp <= 0XFFFF) {
    319a:	ldr	r0, [sp, #4]
    319c:	cmp.w	r0, #65536	; 0x10000
      rtn = cp;
    } else {
      ls = FsUtf::lowSurrogate(cp);
    31a0:	itttt	cs
    31a2:	ubfxcs	r3, r0, #0, #10
  /** High surrogate for a code point.
   * \param{in} cp code point.
   * \return high surrogate.
   */
  inline uint16_t highSurrogate(uint32_t cp) {
    return (cp >> 10) + (0XD800 - (0X10000 >> 10));
    31a6:	lsrcs	r0, r0, #10
    31a8:	subcs.w	r3, r3, #9216	; 0x2400
    31ac:	subcs.w	r0, r0, #10304	; 0x2840
    31b0:	it	cs
    31b2:	strhcs	r3, [r4, #12]
    31b4:	uxth	r0, r0
    31b6:	b.n	31bc <FsName::get16()+0x44>
    }
  }
  return rtn;

 fail:
  return 0XFFFF;
    31b8:	movw	r0, #65535	; 0xffff
}
    31bc:	add	sp, #8
    31be:	pop	{r4, pc}

000031c0 <ExFatFormatter::syncUpcase()>:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::syncUpcase() {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    31c0:	ldr	r3, [r0, #8]
    31c2:	ubfx	r3, r3, #0, #9
 fail:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::syncUpcase() {
    31c6:	mov	r1, r0
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  if (!index) {
    31c8:	cbz	r3, 31e4 <ExFatFormatter::syncUpcase()+0x24>
    return true;
  }
  for (size_t i = index; i < BYTES_PER_SECTOR; i++) {
    m_secBuf[i] = 0;
    31ca:	movs	r0, #0
    31cc:	ldr	r2, [r1, #16]
    31ce:	strb	r0, [r2, r3]
bool ExFatFormatter::syncUpcase() {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  if (!index) {
    return true;
  }
  for (size_t i = index; i < BYTES_PER_SECTOR; i++) {
    31d0:	adds	r3, #1
    31d2:	cmp.w	r3, #512	; 0x200
    31d6:	bne.n	31cc <ExFatFormatter::syncUpcase()+0xc>
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
    31d8:	ldr	r0, [r1, #12]
    31da:	ldr	r2, [r1, #16]
    31dc:	ldr	r3, [r0, #0]
    31de:	ldr	r1, [r1, #0]
    31e0:	ldr	r3, [r3, #32]
    31e2:	bx	r3
}
    31e4:	movs	r0, #1
    31e6:	bx	lr

000031e8 <ExFatFormatter::writeUpcaseByte(unsigned char)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    31e8:	ldr	r2, [r0, #8]
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
    31ea:	mov	r3, r0
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    31ec:	ubfx	r2, r2, #0, #9
  m_secBuf[index] = b;
    31f0:	ldr	r0, [r0, #16]
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
    31f2:	push	{r4}
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  m_secBuf[index] = b;
    31f4:	strb	r1, [r0, r2]
  m_upcaseChecksum = exFatChecksum(m_upcaseChecksum, b);
    31f6:	ldr	r0, [r3, #4]
    31f8:	add.w	r1, r1, r0, ror #1
    31fc:	str	r1, [r3, #4]
  m_upcaseSize++;
    31fe:	ldr	r1, [r3, #8]
    3200:	adds	r1, #1
    3202:	str	r1, [r3, #8]
  if (index == SECTOR_MASK) {
    3204:	movw	r1, #511	; 0x1ff
    3208:	cmp	r2, r1
    320a:	bne.n	3222 <ExFatFormatter::writeUpcaseByte(unsigned char)+0x3a>
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
    320c:	ldr	r0, [r3, #12]
    320e:	ldr	r1, [r3, #0]
    3210:	ldr	r2, [r0, #0]
    3212:	ldr	r4, [r2, #32]
    3214:	adds	r2, r1, #1
    3216:	str	r2, [r3, #0]
    3218:	ldr	r2, [r3, #16]
    321a:	mov	r3, r4
  }
  return true;
}
    321c:	ldr.w	r4, [sp], #4
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  m_secBuf[index] = b;
  m_upcaseChecksum = exFatChecksum(m_upcaseChecksum, b);
  m_upcaseSize++;
  if (index == SECTOR_MASK) {
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
    3220:	bx	r3
  }
  return true;
}
    3222:	movs	r0, #1
    3224:	ldr.w	r4, [sp], #4
    3228:	bx	lr

0000322a <ExFatFormatter::writeUpcaseUnicode(unsigned short)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
    322a:	push	{r3, r4, r5, lr}
    322c:	mov	r4, r1
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    322e:	uxtb	r1, r1
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
  }
  return true;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
    3230:	mov	r5, r0
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    3232:	bl	31e8 <ExFatFormatter::writeUpcaseByte(unsigned char)>
    3236:	cbz	r0, 3244 <ExFatFormatter::writeUpcaseUnicode(unsigned short)+0x1a>
    3238:	lsrs	r1, r4, #8
    323a:	mov	r0, r5
}
    323c:	ldmia.w	sp!, {r3, r4, r5, lr}
  }
  return true;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    3240:	b.w	31e8 <ExFatFormatter::writeUpcaseByte(unsigned char)>
}
    3244:	pop	{r3, r4, r5, pc}

00003246 <ExFatFormatter::writeUpcase(unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcase(uint32_t sector) {
    3246:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t n;
  uint32_t ns;
  uint32_t ch = 0;
  uint16_t uc;

  m_upcaseSize = 0;
    3248:	movs	r4, #0
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;
    324a:	stmia.w	r0, {r1, r4}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcase(uint32_t sector) {
    324e:	mov	r7, r0
  uint32_t n;
  uint32_t ns;
  uint32_t ch = 0;
  uint16_t uc;

  m_upcaseSize = 0;
    3250:	str	r4, [r0, #8]
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    uc = toUpcase(ch);
    3252:	uxth	r0, r4
    3254:	bl	30d4 <toUpcase(unsigned short)>
    if (uc != ch) {
    3258:	cmp	r0, r4
  m_upcaseSize = 0;
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    uc = toUpcase(ch);
    325a:	mov	r6, r0
    if (uc != ch) {
    325c:	beq.n	3274 <ExFatFormatter::writeUpcase(unsigned long)+0x2e>
      if (!writeUpcaseUnicode(uc)) {
    325e:	mov	r1, r0
    3260:	mov	r0, r7
    3262:	bl	322a <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    3266:	cbz	r0, 32d2 <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    3268:	adds	r5, r4, #1

  m_upcaseSize = 0;
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    326a:	cmp.w	r5, #65536	; 0x10000
    326e:	bcs.n	3288 <ExFatFormatter::writeUpcase(unsigned long)+0x42>
    3270:	mov	r4, r5
    3272:	b.n	3252 <ExFatFormatter::writeUpcase(unsigned long)+0xc>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
    3274:	adds	r5, r4, #1
    3276:	cmp.w	r5, #65536	; 0x10000
    327a:	bcs.n	3292 <ExFatFormatter::writeUpcase(unsigned long)+0x4c>
    327c:	uxth	r0, r5
    327e:	bl	30d4 <toUpcase(unsigned short)>
    3282:	cmp	r5, r0
    3284:	bne.n	3292 <ExFatFormatter::writeUpcase(unsigned long)+0x4c>
    3286:	b.n	32ce <ExFatFormatter::writeUpcase(unsigned long)+0x88>
          }
        }
      }
    }
  }
  if (!syncUpcase()) {
    3288:	mov	r0, r7
  }
  return true;

 fail:
  return false;
}
    328a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
          }
        }
      }
    }
  }
  if (!syncUpcase()) {
    328e:	b.w	31c0 <ExFatFormatter::syncUpcase()>
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
      ns = n - ch;
    3292:	subs	r4, r5, r4
      if (ns >= MINIMUM_UPCASE_SKIP) {
    3294:	cmp.w	r4, #512	; 0x200
    3298:	bcc.n	32b4 <ExFatFormatter::writeUpcase(unsigned long)+0x6e>
        if (!writeUpcaseUnicode(0XFFFF) || !writeUpcaseUnicode(ns)) {
    329a:	movw	r1, #65535	; 0xffff
    329e:	mov	r0, r7
    32a0:	bl	322a <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    32a4:	cbz	r0, 32d2 <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
    32a6:	uxth	r1, r4
    32a8:	mov	r0, r7
    32aa:	bl	322a <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    32ae:	cmp	r0, #0
    32b0:	bne.n	326a <ExFatFormatter::writeUpcase(unsigned long)+0x24>
    32b2:	b.n	32d2 <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
      ns = n - ch;
      if (ns >= MINIMUM_UPCASE_SKIP) {
    32b4:	mov	r4, r6
          DBG_FAIL_MACRO;
          goto fail;
        }
        ch = n;
      } else {
        while (ch < n) {
    32b6:	cmp	r5, r4
    32b8:	bhi.n	32be <ExFatFormatter::writeUpcase(unsigned long)+0x78>
    32ba:	mov	r5, r4
    32bc:	b.n	326a <ExFatFormatter::writeUpcase(unsigned long)+0x24>
          if (!writeUpcaseUnicode(ch++)) {
    32be:	uxth	r1, r4
    32c0:	mov	r0, r7
    32c2:	bl	322a <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    32c6:	adds	r4, #1
    32c8:	cmp	r0, #0
    32ca:	bne.n	32b6 <ExFatFormatter::writeUpcase(unsigned long)+0x70>
    32cc:	b.n	32d2 <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
    32ce:	adds	r5, #1
    32d0:	b.n	3276 <ExFatFormatter::writeUpcase(unsigned long)+0x30>
  }
  return true;

 fail:
  return false;
}
    32d2:	movs	r0, #0
    32d4:	pop	{r3, r4, r5, r6, r7, pc}
    32d6:	Address 0x000032d6 is out of bounds.


000032d8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>:
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    32d8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    32dc:	mov	r7, r3
  uint32_t volumeLength;
  uint32_t sectorCount;
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
    32de:	mov	r3, r0
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    32e0:	sub	sp, #28
  uint32_t volumeLength;
  uint32_t sectorCount;
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
    32e2:	str	r1, [r3, #12]
  m_secBuf = secBuf;
    32e4:	str	r2, [r3, #16]
  sectorCount = dev->sectorCount();
    32e6:	ldr	r3, [r1, #0]
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    32e8:	str	r0, [sp, #4]
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    32ea:	ldr	r3, [r3, #24]
    32ec:	mov	r0, r1
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    32ee:	mov	r5, r1
    32f0:	mov	r4, r2
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    32f2:	blx	r3
  // Min size is 512 MB
  if (sectorCount < 0X100000) {
    32f4:	cmp.w	r0, #1048576	; 0x100000
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    32f8:	mov	r9, r0
  // Min size is 512 MB
  if (sectorCount < 0X100000) {
    32fa:	bcs.n	330c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x34>
    writeMsg(pr, "Device is too small\r\n");
    32fc:	cmp	r7, #0
    32fe:	beq.w	3526 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x24e>
    3302:	ldr	r1, [pc, #584]	; (354c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x274>)
    3304:	mov	r0, r7
    3306:	bl	a54 <Print::write(char const*)>
    330a:	b.n	351e <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x246>
    330c:	movs	r6, #0
    330e:	movs	r3, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
    3310:	adds	r6, #1
    3312:	uxtb	r6, r6
    3314:	cmp	r6, #32
    3316:	mov.w	r3, r3, lsl #1
    331a:	beq.n	3328 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x50>
    331c:	cmp	r9, r3
    331e:	bhi.n	3310 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x38>
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
    3320:	cmp	r6, #28
    3322:	bhi.n	3328 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x50>
    3324:	movs	r3, #8
    3326:	b.n	3330 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x58>
    3328:	sub.w	r8, r6, #11
    332c:	ubfx	r3, r8, #1, #8
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
    3330:	cmp	r6, #26
    3332:	it	hi
    3334:	addhi	r6, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
    3336:	str	r3, [sp, #8]
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
    3338:	ittte	hi
    333a:	asrhi	r6, r6, #1
    333c:	movhi	r3, #1
    333e:	lslhi	r3, r6
    3340:	movls.w	r3, #8192	; 0x2000
    3344:	str	r3, [sp, #0]
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
    3346:	ldr	r3, [sp, #0]
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    3348:	ldr	r2, [sp, #8]
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
    334a:	lsls	r6, r3, #1
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
    334c:	lsls	r3, r3, #2
    334e:	rsb	sl, r3, r9
    3352:	str	r3, [sp, #16]
    3354:	ldr	r3, [sp, #8]
    3356:	lsr.w	r3, sl, r3
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    335a:	lsl.w	sl, r3, r2

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    335e:	movs	r1, #0
    3360:	mov.w	r2, #512	; 0x200
    3364:	mov	r0, r4
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
    3366:	str	r3, [sp, #12]
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3368:	bl	88dc <memset>
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
  mbr->part->type = 7;
    336c:	movs	r3, #7
    336e:	strb.w	r3, [r4, #450]	; 0x1c2
  mbr->part->endCHS[0] = 0XFE;
    3372:	movs	r3, #254	; 0xfe
    3374:	strb.w	r3, [r4, #451]	; 0x1c3
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
    3378:	mov.w	fp, #1
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
  mbr->part->type = 7;
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
    337c:	movs	r3, #255	; 0xff
  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
    337e:	mov.w	r8, #0
  mbr->part->type = 7;
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
    3382:	strb.w	r3, [r4, #452]	; 0x1c4
  mbr->part->endCHS[2] = 0XFF;
    3386:	strb.w	r3, [r4, #453]	; 0x1c5
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
    338a:	strb.w	fp, [r4, #447]	; 0x1bf
  mbr->part->beginCHS[1] = 1;
    338e:	strb.w	fp, [r4, #448]	; 0x1c0
  mbr->part->beginCHS[2] = 0;
    3392:	strb.w	r8, [r4, #449]	; 0x1c1
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3396:	movw	r3, #43605	; 0xaa55
    339a:	strh.w	r3, [r4, #510]	; 0x1fe
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
  setLe32(mbr->part->relativeSectors, partitionOffset);
  setLe32(mbr->part->totalSectors, volumeLength);
  setLe16(mbr->signature, MBR_SIGNATURE);
  if (!dev->writeSector(0, secBuf)) {
    339e:	ldr	r3, [r5, #0]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    33a0:	str.w	r6, [r4, #454]	; 0x1c6
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    33a4:	add	sl, r6
    33a6:	str.w	sl, [r4, #458]	; 0x1ca
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
  setLe32(mbr->part->relativeSectors, partitionOffset);
  setLe32(mbr->part->totalSectors, volumeLength);
  setLe16(mbr->signature, MBR_SIGNATURE);
  if (!dev->writeSector(0, secBuf)) {
    33aa:	ldr	r3, [r3, #32]
    33ac:	mov	r2, r4
    33ae:	mov	r1, r8
    33b0:	mov	r0, r5
    33b2:	blx	r3
    33b4:	cmp	r0, #0
    33b6:	beq.w	351c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Partition Boot sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    33ba:	mov.w	r2, #512	; 0x200
    33be:	mov	r1, r8
    33c0:	mov	r0, r4
    33c2:	bl	88dc <memset>
  pbs = reinterpret_cast<ExFatPbs_t*>(secBuf);
  pbs->jmpInstruction[0] = 0XEB;
    33c6:	movs	r3, #235	; 0xeb
    33c8:	strb	r3, [r4, #0]
  pbs->jmpInstruction[1] = 0X76;
    33ca:	movs	r3, #118	; 0x76
    33cc:	strb	r3, [r4, #1]
  pbs->jmpInstruction[2] = 0X90;
    33ce:	movs	r3, #144	; 0x90
    33d0:	strb	r3, [r4, #2]
  pbs->oemName[0] = 'E';
    33d2:	movs	r3, #69	; 0x45
    33d4:	strb	r3, [r4, #3]
  pbs->oemName[1] = 'X';
    33d6:	movs	r3, #88	; 0x58
    33d8:	strb	r3, [r4, #4]
  pbs->oemName[2] = 'F';
    33da:	movs	r3, #70	; 0x46
    33dc:	strb	r3, [r4, #5]
  pbs->oemName[3] = 'A';
    33de:	movs	r3, #65	; 0x41
    33e0:	strb	r3, [r4, #6]
  pbs->oemName[4] = 'T';
    33e2:	movs	r3, #84	; 0x54
    33e4:	strb	r3, [r4, #7]
  pbs->oemName[5] = ' ';
    33e6:	movs	r3, #32
    33e8:	strb	r3, [r4, #8]
  pbs->oemName[6] = ' ';
    33ea:	strb	r3, [r4, #9]
  pbs->oemName[7] = ' ';
    33ec:	strb	r3, [r4, #10]
    33ee:	ldr	r3, [sp, #0]
    33f0:	str	r3, [r4, #80]	; 0x50
    33f2:	str	r3, [r4, #84]	; 0x54
    33f4:	ldr	r3, [sp, #12]
    33f6:	str	r3, [r4, #92]	; 0x5c
    33f8:	movs	r3, #4
    33fa:	str	r3, [r4, #96]	; 0x60
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    33fc:	mov.w	r3, #256	; 0x100
    3400:	strh.w	r3, [r4, #104]	; 0x68
  setLe32(pbs->bpb.clusterCount, clusterCount);
  setLe32(pbs->bpb.rootDirectoryCluster, ROOT_CLUSTER);
  setLe32(pbs->bpb.volumeSerialNumber, sectorCount);
  setLe16(pbs->bpb.fileSystemRevision, 0X100);
  setLe16(pbs->bpb.volumeFlags, 0);
  pbs->bpb.bytesPerSectorShift = BYTES_PER_SECTOR_SHIFT;
    3404:	movs	r3, #9
    3406:	strb.w	r3, [r4, #108]	; 0x6c
  pbs->bpb.sectorsPerClusterShift = sectorsPerClusterShift;
    340a:	ldrb.w	r3, [sp, #8]
    340e:	strb.w	r3, [r4, #109]	; 0x6d
  pbs->bpb.numberOfFats = 1;
  pbs->bpb.driveSelect = 0X80;
    3412:	movs	r3, #128	; 0x80
    3414:	strb.w	r3, [r4, #111]	; 0x6f

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    3418:	str	r6, [r4, #64]	; 0x40
    341a:	str.w	r8, [r4, #68]	; 0x44
    341e:	str.w	sl, [r4, #72]	; 0x48
    3422:	str.w	r8, [r4, #76]	; 0x4c
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3426:	str	r6, [r4, #88]	; 0x58
    3428:	str.w	r9, [r4, #100]	; 0x64
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    342c:	strh.w	r8, [r4, #106]	; 0x6a
  setLe32(pbs->bpb.volumeSerialNumber, sectorCount);
  setLe16(pbs->bpb.fileSystemRevision, 0X100);
  setLe16(pbs->bpb.volumeFlags, 0);
  pbs->bpb.bytesPerSectorShift = BYTES_PER_SECTOR_SHIFT;
  pbs->bpb.sectorsPerClusterShift = sectorsPerClusterShift;
  pbs->bpb.numberOfFats = 1;
    3430:	strb.w	fp, [r4, #110]	; 0x6e
  pbs->bpb.driveSelect = 0X80;
  pbs->bpb.percentInUse = 0;
    3434:	strb.w	r8, [r4, #112]	; 0x70
    3438:	add.w	r3, r4, #119	; 0x77
    343c:	addw	r2, r4, #509	; 0x1fd

  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
    3440:	movs	r1, #244	; 0xf4
    3442:	strb.w	r1, [r3, #1]!
  pbs->bpb.numberOfFats = 1;
  pbs->bpb.driveSelect = 0X80;
  pbs->bpb.percentInUse = 0;

  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    3446:	cmp	r3, r2
    3448:	bne.n	3442 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x16a>
    344a:	movw	r3, #43605	; 0xaa55
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    344e:	mov.w	r9, #0
    3452:	strh.w	r3, [r4, #510]	; 0x1fe
  ExFatPbs_t* pbs;
  DirUpcase_t* dup;
  DirBitmap_t* dbm;
  DirLabel_t* label;
  uint32_t bitmapSize;
  uint32_t checksum = 0;
    3456:	mov	r8, r9
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    if (i == offsetof(ExFatPbs_t, bpb.volumeFlags[0]) ||
    3458:	sub.w	r3, r9, #106	; 0x6a
    345c:	cmp	r3, #1
    345e:	bls.n	346e <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x196>
        i == offsetof(ExFatPbs_t, bpb.volumeFlags[1]) ||
    3460:	cmp.w	r9, #112	; 0x70
  uint8_t  mustBeZero2[2];
  uint8_t  unicode3[4];
} DirLfn_t;
//=============================================================================
inline uint32_t exFatChecksum(uint32_t sum, uint8_t data) {
  return (sum << 31) + (sum >> 1) + data;
    3464:	itt	ne
    3466:	ldrbne.w	r3, [r4, r9]
    346a:	addne.w	r8, r3, r8, ror #1
  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    346e:	add.w	r9, r9, #1
    3472:	cmp.w	r9, #512	; 0x200
    3476:	bne.n	3458 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x180>
      continue;
    }
    checksum = exFatChecksum(checksum, secBuf[i]);
  }
  sector = partitionOffset;
  if (!dev->writeSector(sector, secBuf)  ||
    3478:	ldr	r3, [r5, #0]
    347a:	mov	r2, r4
    347c:	ldr	r3, [r3, #32]
    347e:	mov	r1, r6
    3480:	mov	r0, r5
    3482:	blx	r3
    3484:	cmp	r0, #0
    3486:	beq.n	351c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3488:	ldr	r3, [r5, #0]
    348a:	mov	r2, r4
    348c:	ldr	r3, [r3, #32]
    348e:	add.w	r1, r6, #12
    3492:	mov	r0, r5
    3494:	blx	r3
      continue;
    }
    checksum = exFatChecksum(checksum, secBuf[i]);
  }
  sector = partitionOffset;
  if (!dev->writeSector(sector, secBuf)  ||
    3496:	cmp	r0, #0
    3498:	beq.n	351c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    349a:	mov	r2, r9
    349c:	movs	r1, #0
    349e:	mov	r0, r4
    34a0:	bl	88dc <memset>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    34a4:	movw	r3, #43605	; 0xaa55
    34a8:	strh.w	r3, [r4, #510]	; 0x1fe
    34ac:	subs	r3, r4, #1
  if (!dev->writeSector(sector, secBuf)  ||
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector++;
    34ae:	add.w	sl, r6, #1
    34b2:	add.w	r9, r6, #9
    34b6:	str	r3, [sp, #20]
    34b8:	addw	fp, r4, #511	; 0x1ff
  ExFatPbs_t* pbs;
  DirUpcase_t* dup;
  DirBitmap_t* dbm;
  DirLabel_t* label;
  uint32_t bitmapSize;
  uint32_t checksum = 0;
    34bc:	ldr	r3, [sp, #20]
  uint8_t  mustBeZero2[2];
  uint8_t  unicode3[4];
} DirLfn_t;
//=============================================================================
inline uint32_t exFatChecksum(uint32_t sum, uint8_t data) {
  return (sum << 31) + (sum >> 1) + data;
    34be:	ldrb.w	r2, [r3, #1]!
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    34c2:	cmp	fp, r3
    34c4:	add.w	r8, r2, r8, ror #1
    34c8:	bne.n	34be <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x1e6>
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    34ca:	ldr	r3, [r5, #0]
    34cc:	mov	r2, r4
    34ce:	ldr	r3, [r3, #32]
    34d0:	mov	r1, sl
    34d2:	mov	r0, r5
    34d4:	blx	r3
    34d6:	cbz	r0, 351c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    34d8:	ldr	r3, [r5, #0]
    34da:	mov	r2, r4
    34dc:	ldr	r3, [r3, #32]
    34de:	add.w	r1, sl, #12
    34e2:	mov	r0, r5
    34e4:	blx	r3
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    34e6:	cbz	r0, 351c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    sector++;
    34e8:	add.w	sl, sl, #1
  }
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    34ec:	cmp	sl, r9
    34ee:	bne.n	34bc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x1e4>
      goto fail;
    }
    sector++;
  }
  // Write OEM Parameter Sector and reserved sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    34f0:	mov.w	r2, #512	; 0x200
    34f4:	movs	r1, #0
    34f6:	mov	r0, r4
    34f8:	bl	88dc <memset>
    34fc:	add.w	sl, r6, #11
    3500:	ldr	r3, [sp, #20]
    3502:	ldrb.w	r2, [r3, #1]!
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    3506:	cmp	fp, r3
    3508:	add.w	r8, r2, r8, ror #1
    350c:	bne.n	3502 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x22a>
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    350e:	ldr	r3, [r5, #0]
    3510:	mov	r2, r4
    3512:	ldr	r3, [r3, #32]
    3514:	mov	r1, r9
    3516:	mov	r0, r5
    3518:	blx	r3
    351a:	cbnz	r0, 352c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x254>
  }
  writeMsg(pr, "Format done\r\n");
  return true;

 fail:
  writeMsg(pr, "Format failed\r\n");
    351c:	cbz	r7, 3526 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x24e>
    351e:	ldr	r1, [pc, #48]	; (3550 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x278>)
    3520:	mov	r0, r7
    3522:	bl	a54 <Print::write(char const*)>
  return false;
    3526:	mov.w	sl, #0
    352a:	b.n	3710 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x438>
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    352c:	ldr	r3, [r5, #0]
    352e:	mov	r2, r4
    3530:	ldr	r3, [r3, #32]
    3532:	add.w	r1, r9, #12
    3536:	mov	r0, r5
    3538:	blx	r3
  memset(secBuf, 0, BYTES_PER_SECTOR);
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    353a:	cmp	r0, #0
    353c:	beq.n	351c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    sector++;
    353e:	add.w	r3, r9, #1
    }
    sector++;
  }
  // Write OEM Parameter Sector and reserved sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  for (int j = 0; j < 2; j++) {
    3542:	cmp	r3, sl
    3544:	beq.n	3554 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x27c>
    3546:	mov	r9, r3
    3548:	b.n	3500 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x228>
    354a:	nop
    354c:	.word	0x000124ea
    3550:	.word	0x00012543
    3554:	subs	r3, r4, #4
    3556:	add.w	r2, r4, #508	; 0x1fc
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    355a:	str.w	r8, [r3, #4]!
      goto fail;
    }
    sector++;
  }
  // Write Boot CheckSum Sector.
  for (size_t i = 0; i < BYTES_PER_SECTOR; i += 4) {
    355e:	cmp	r2, r3
    3560:	bne.n	355a <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x282>
    setLe32(secBuf + i, checksum);
  }
  if (!dev->writeSector(sector, secBuf)  ||
    3562:	ldr	r3, [r5, #0]
    3564:	mov	r2, r4
    3566:	ldr	r3, [r3, #32]
    3568:	mov	r1, sl
    356a:	mov	r0, r5
    356c:	blx	r3
    356e:	cmp	r0, #0
    3570:	beq.n	351c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3572:	ldr	r3, [r5, #0]
    3574:	mov	r2, r4
    3576:	ldr	r3, [r3, #32]
    3578:	add.w	r1, r9, #13
    357c:	mov	r0, r5
    357e:	blx	r3
  }
  // Write Boot CheckSum Sector.
  for (size_t i = 0; i < BYTES_PER_SECTOR; i += 4) {
    setLe32(secBuf + i, checksum);
  }
  if (!dev->writeSector(sector, secBuf)  ||
    3580:	cmp	r0, #0
    3582:	beq.n	351c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
    3584:	cbz	r7, 358e <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2b6>
    3586:	ldr	r1, [pc, #400]	; (3718 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x440>)
    3588:	mov	r0, r7
    358a:	bl	a54 <Print::write(char const*)>
  sector = partitionOffset + fatOffset;
    358e:	ldr	r3, [sp, #0]
    3590:	add	r6, r3
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3592:	ldr	r3, [sp, #12]

  memset(secBuf, 0, BYTES_PER_SECTOR);
    3594:	mov.w	r2, #512	; 0x200
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3598:	mov.w	r9, r3, lsl #2

  memset(secBuf, 0, BYTES_PER_SECTOR);
    359c:	movs	r1, #0
    359e:	mov	r0, r4
    35a0:	bl	88dc <memset>
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    35a4:	addw	r9, r9, #519	; 0x207

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
    35a8:	movs	r3, #248	; 0xf8
    35aa:	strb	r3, [r4, #0]
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    35ac:	mov.w	sl, r9, lsr #9
    35b0:	mov	r3, r4
    35b2:	add.w	r2, r4, #19

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    secBuf[i] = 0XFF;
    35b6:	movs	r1, #255	; 0xff
    35b8:	strb.w	r1, [r3, #1]!
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    35bc:	cmp	r2, r3
    35be:	bne.n	35b8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2e0>
    secBuf[i] = 0XFF;
  }
  for (uint32_t i = 0; i < ns; i++) {
    if (i%(ns/32) == 0) {
    35c0:	mov.w	r9, r9, lsr #14
    35c4:	mov.w	r8, #0
    35c8:	udiv	r3, r8, r9
    35cc:	mls	r3, r9, r3, r8
    35d0:	cbnz	r3, 35dc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x304>
      writeMsg(pr, ".");
    35d2:	cbz	r7, 35dc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x304>
    35d4:	ldr	r1, [pc, #324]	; (371c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x444>)
    35d6:	mov	r0, r7
    35d8:	bl	a54 <Print::write(char const*)>
    }
    if (!dev->writeSector(sector + i, secBuf)) {
    35dc:	ldr	r3, [r5, #0]
    35de:	mov	r2, r4
    35e0:	ldr	r3, [r3, #32]
    35e2:	add.w	r1, r6, r8
    35e6:	mov	r0, r5
    35e8:	blx	r3
    35ea:	cmp	r0, #0
    35ec:	beq.n	351c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    35ee:	cmp.w	r8, #0
    35f2:	bne.n	3600 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x328>
      memset(secBuf, 0, BYTES_PER_SECTOR);
    35f4:	mov.w	r2, #512	; 0x200
    35f8:	mov	r1, r8
    35fa:	mov	r0, r4
    35fc:	bl	88dc <memset>
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    secBuf[i] = 0XFF;
  }
  for (uint32_t i = 0; i < ns; i++) {
    3600:	add.w	r8, r8, #1
    3604:	cmp	sl, r8
    3606:	bne.n	35c8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2f0>
    }
    if (i == 0) {
      memset(secBuf, 0, BYTES_PER_SECTOR);
    }
  }
  writeMsg(pr, "\r\n");
    3608:	cbz	r7, 3612 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x33a>
    360a:	ldr	r1, [pc, #276]	; (3720 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x448>)
    360c:	mov	r0, r7
    360e:	bl	a54 <Print::write(char const*)>
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
    3612:	ldr	r3, [sp, #8]
    3614:	mov.w	r8, #1
    3618:	lsl.w	r8, r8, r3
    }
  }
  writeMsg(pr, "\r\n");
  // Write cluster two, bitmap.
  sector = partitionOffset + clusterHeapOffset;
  bitmapSize = (clusterCount + 7)/8;
    361c:	ldr	r3, [sp, #12]
    361e:	add.w	sl, r3, #7
    3622:	mov.w	sl, sl, lsr #3
  ns = (bitmapSize + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3626:	addw	fp, sl, #511	; 0x1ff
    362a:	mov.w	fp, fp, lsr #9
  if (ns > sectorsPerCluster) {
    362e:	cmp	r8, fp
    3630:	bcc.w	351c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3634:	mov.w	r2, #512	; 0x200
    3638:	movs	r1, #0
    363a:	mov	r0, r4
    363c:	bl	88dc <memset>
  // Allocate clusters for bitmap, upcase, and root.
  secBuf[0] = 0X7;
    3640:	movs	r3, #7
    3642:	strb	r3, [r4, #0]
  for (uint32_t i = 0; i < ns; i++) {
    3644:	mov.w	r9, #0
    if (!dev->writeSector(sector + i, secBuf)) {
    3648:	ldr	r3, [r5, #0]
    364a:	ldr	r1, [sp, #16]
    364c:	ldr	r3, [r3, #32]
    364e:	mov	r2, r4
    3650:	add	r1, r9
    3652:	mov	r0, r5
    3654:	blx	r3
    3656:	cmp	r0, #0
    3658:	beq.w	351c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    365c:	cmp.w	r9, #0
    3660:	bne.n	3666 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x38e>
      secBuf[0] = 0;
    3662:	strb.w	r9, [r4]
    goto fail;
  }
  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate clusters for bitmap, upcase, and root.
  secBuf[0] = 0X7;
  for (uint32_t i = 0; i < ns; i++) {
    3666:	add.w	r9, r9, #1
    366a:	cmp	fp, r9
    366c:	bne.n	3648 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x370>
    if (i == 0) {
      secBuf[0] = 0;
    }
  }
  // Write cluster three, upcase table.
  writeMsg(pr, "Writing upcase table\r\n");
    366e:	cbz	r7, 3678 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3a0>
    3670:	ldr	r1, [pc, #176]	; (3724 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x44c>)
    3672:	mov	r0, r7
    3674:	bl	a54 <Print::write(char const*)>
  if (!writeUpcase(partitionOffset + clusterHeapOffset + sectorsPerCluster)) {
    3678:	ldr	r3, [sp, #0]
    367a:	ldr	r0, [sp, #4]
    367c:	add	r3, r6
    367e:	add.w	r9, r3, r8
    3682:	mov	r1, r9
    3684:	bl	3246 <ExFatFormatter::writeUpcase(unsigned long)>
    3688:	cmp	r0, #0
    368a:	beq.w	351c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_upcaseSize > BYTES_PER_SECTOR*sectorsPerCluster) {
    368e:	ldr	r3, [sp, #4]
    3690:	ldr	r3, [r3, #8]
    3692:	cmp.w	r3, r8, lsl #9
    3696:	bhi.w	351c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Initialize first sector of root.
  writeMsg(pr, "Writing root\r\n");
    369a:	cbz	r7, 36a4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3cc>
    369c:	ldr	r1, [pc, #136]	; (3728 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x450>)
    369e:	mov	r0, r7
    36a0:	bl	a54 <Print::write(char const*)>
  ns = sectorsPerCluster;
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);
    36a4:	mov.w	r2, #512	; 0x200
    36a8:	movs	r1, #0
    36aa:	mov	r0, r4
    36ac:	bl	88dc <memset>
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;

  // bitmap directory entry.
  dbm = reinterpret_cast<DirBitmap_t*>(secBuf + 32);
  dbm->type = EXFAT_TYPE_BITMAP;
    36b0:	movs	r2, #129	; 0x81
    36b2:	strb.w	r2, [r4, #32]
    36b6:	movs	r2, #2
    36b8:	str	r2, [r4, #52]	; 0x34
  setLe32(dbm->firstCluster, BITMAP_CLUSTER);
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
    36ba:	movs	r2, #130	; 0x82
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);

  // Unused Label entry.
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;
    36bc:	movs	r3, #3
  setLe32(dbm->firstCluster, BITMAP_CLUSTER);
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
    36be:	strb.w	r2, [r4, #64]	; 0x40
  setLe32(dup->checksum, m_upcaseChecksum);
    36c2:	ldr	r2, [sp, #4]
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);

  // Unused Label entry.
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;
    36c4:	strb	r3, [r4, #0]
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
  setLe32(dup->checksum, m_upcaseChecksum);
    36c6:	ldr	r2, [r2, #4]
    36c8:	str	r3, [r4, #84]	; 0x54
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    36ca:	ldr	r3, [sp, #4]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    36cc:	str	r2, [r4, #68]	; 0x44
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    36ce:	ldr	r3, [r3, #8]
    36d0:	str.w	sl, [r4, #56]	; 0x38
    36d4:	movs	r6, #0
    goto fail;
  }
  // Initialize first sector of root.
  writeMsg(pr, "Writing root\r\n");
  ns = sectorsPerCluster;
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
    36d6:	add	r9, r8
    36d8:	str	r3, [r4, #88]	; 0x58
    36da:	str	r6, [r4, #92]	; 0x5c
  setLe32(dup->firstCluster, UPCASE_CLUSTER);
  setLe64(dup->size, m_upcaseSize);

  // Write root, cluster four.
  for (uint32_t i = 0; i < ns; i++) {
    if (!dev->writeSector(sector + i, secBuf)) {
    36dc:	ldr	r3, [r5, #0]
    36de:	mov	r2, r4
    36e0:	ldr	r3, [r3, #32]
    36e2:	add.w	r1, r6, r9
    36e6:	mov	r0, r5
    36e8:	blx	r3
    36ea:	mov	sl, r0
    36ec:	cmp	r0, #0
    36ee:	beq.w	351c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    36f2:	cbnz	r6, 3700 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x428>
      memset(secBuf, 0, BYTES_PER_SECTOR);
    36f4:	mov.w	r2, #512	; 0x200
    36f8:	mov	r1, r6
    36fa:	mov	r0, r4
    36fc:	bl	88dc <memset>
  setLe32(dup->checksum, m_upcaseChecksum);
  setLe32(dup->firstCluster, UPCASE_CLUSTER);
  setLe64(dup->size, m_upcaseSize);

  // Write root, cluster four.
  for (uint32_t i = 0; i < ns; i++) {
    3700:	adds	r6, #1
    3702:	cmp	r8, r6
    3704:	bne.n	36dc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x404>
    }
    if (i == 0) {
      memset(secBuf, 0, BYTES_PER_SECTOR);
    }
  }
  writeMsg(pr, "Format done\r\n");
    3706:	cbz	r7, 3710 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x438>
    3708:	ldr	r1, [pc, #32]	; (372c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x454>)
    370a:	mov	r0, r7
    370c:	bl	a54 <Print::write(char const*)>
  return true;

 fail:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
    3710:	mov	r0, sl
    3712:	add	sp, #28
    3714:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3718:	.word	0x00012500
    371c:	.word	0x0001250d
    3720:	.word	0x0001257f
    3724:	.word	0x0001250f
    3728:	.word	0x00012526
    372c:	.word	0x00012535

00003730 <ExFatFile::cmpName(DirName_t const*, ExName_t*)>:
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
  return hash;
}
//------------------------------------------------------------------------------
bool ExFatFile::cmpName(const DirName_t* dirName, ExName_t* fname) {
    3730:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3734:	mov	r5, r2
    3736:	mov	r6, r1
    3738:	add.w	r8, r1, #30
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    373c:	ldrh	r3, [r5, #12]
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    373e:	ldrh.w	r4, [r6, #2]!
    3742:	cbnz	r3, 3756 <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x26>
    3744:	ldr	r2, [r5, #4]
    3746:	ldr	r3, [r5, #8]
    3748:	cmp	r2, r3
    374a:	bne.n	3756 <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x26>
  for (uint8_t i = 0; i < 15; i++) {
    uint16_t u = getLe16(dirName->unicode + 2*i);
    if (fname->atEnd()) {
      return u == 0;
    374c:	clz	r0, r4
    3750:	lsrs	r0, r0, #5
    3752:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
#if USE_UTF8_LONG_NAMES
    uint16_t cp = fname->get16();
    3756:	mov	r0, r5
    3758:	bl	3178 <FsName::get16()>
    if (toUpcase(cp) != toUpcase(u)) {
    375c:	bl	30d4 <toUpcase(unsigned short)>
    3760:	mov	r7, r0
    3762:	mov	r0, r4
    3764:	bl	30d4 <toUpcase(unsigned short)>
    3768:	cmp	r7, r0
    376a:	bne.n	3776 <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x46>
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
  return hash;
}
//------------------------------------------------------------------------------
bool ExFatFile::cmpName(const DirName_t* dirName, ExName_t* fname) {
  for (uint8_t i = 0; i < 15; i++) {
    376c:	cmp	r6, r8
    376e:	bne.n	373c <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0xc>
    if (u >= 0x7F || toUpper(c) != toUpper(u)) {
      return false;
    }
#endif  // USE_UTF8_LONG_NAMES
  }
  return true;
    3770:	movs	r0, #1
    3772:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return u == 0;
    }
#if USE_UTF8_LONG_NAMES
    uint16_t cp = fname->get16();
    if (toUpcase(cp) != toUpcase(u)) {
       return false;
    3776:	movs	r0, #0
    3778:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000377c <ExFatFile::getName8(char*, unsigned int)>:
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName8(char* name, size_t count) {
    377c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  char* str = name;
  char* ptr;
  DirName_t* dn;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    3780:	ldrb.w	r3, [r0, #49]	; 0x31
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName8(char* name, size_t count) {
    3784:	mov	sl, r0
    3786:	mov	r9, r1
  char* str = name;
  char* ptr;
  DirName_t* dn;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    3788:	cmp	r3, #0
    378a:	beq.n	381c <ExFatFile::getName8(char*, unsigned int)+0xa0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    378c:	add.w	r8, r2, #4294967295
    3790:	mov	r5, r1
    3792:	movs	r7, #2
    3794:	movs	r4, #0
    3796:	add	r8, r1
  uint32_t cp;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 2; is <= m_setCount; is++) {
    3798:	ldrb.w	r3, [sl, #48]	; 0x30
    379c:	cmp	r3, r7
    379e:	bcc.n	3810 <ExFatFile::getName8(char*, unsigned int)+0x94>
    dn = reinterpret_cast<DirName_t*>
         (dirCache(is, FsCache::CACHE_FOR_READ));
    37a0:	movs	r2, #0
    37a2:	mov	r1, r7
    37a4:	mov	r0, sl
    37a6:	bl	388e <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
    37aa:	cbz	r0, 381c <ExFatFile::getName8(char*, unsigned int)+0xa0>
    37ac:	ldrb	r3, [r0, #0]
    37ae:	cmp	r3, #193	; 0xc1
    37b0:	bne.n	381c <ExFatFile::getName8(char*, unsigned int)+0xa0>
    37b2:	mov	r6, r0
    37b4:	add.w	fp, r0, #30
    37b8:	mov	r3, r4
    37ba:	ldrh.w	r4, [r6, #2]!
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
      uint16_t c = getLe16(dn->unicode + 2*in);
      if (hs) {
    37be:	cbz	r3, 37de <ExFatFile::getName8(char*, unsigned int)+0x62>
        if (!FsUtf::isLowSurrogate(c)) {
    37c0:	add.w	r2, r4, #9216	; 0x2400
    37c4:	uxth	r2, r2
    37c6:	cmp.w	r2, #1024	; 0x400
    37ca:	bcs.n	381c <ExFatFile::getName8(char*, unsigned int)+0xa0>
   * \param[in] hs high surrogate.
   * \param[in] ls low surrogate.
   * \return code point.
   */
  inline uint32_t u16ToCp(uint16_t hs, uint16_t ls) {
    return 0X10000 + (((hs & 0X3FF) << 10) | (ls & 0X3FF));
    37cc:	ldr	r0, [pc, #88]	; (3828 <ExFatFile::getName8(char*, unsigned int)+0xac>)
    37ce:	lsls	r3, r3, #10
    37d0:	ands	r0, r3
    37d2:	ubfx	r4, r4, #0, #10
    37d6:	orrs	r4, r0
    37d8:	add.w	r0, r4, #65536	; 0x10000
    37dc:	b.n	37f8 <ExFatFile::getName8(char*, unsigned int)+0x7c>
  /** Check for UTF-16 surrogate.
   * \param[in] c UTF-16 unit.
   * \return true if c is a surrogate else false.
   */
  inline bool isSurrogate(uint16_t c) {
    return 0XD800 <= c && c <= 0XDFFF;
    37de:	add.w	r3, r4, #10240	; 0x2800
    37e2:	uxth	r3, r3
          DBG_FAIL_MACRO;
          goto fail;
        }
        cp = FsUtf::u16ToCp(hs, c);
        hs = 0;
      } else if (!FsUtf::isSurrogate(c)) {
    37e4:	cmp.w	r3, #2048	; 0x800
    37e8:	bcc.n	37f0 <ExFatFile::getName8(char*, unsigned int)+0x74>
        if (c == 0) {
    37ea:	cbz	r4, 3810 <ExFatFile::getName8(char*, unsigned int)+0x94>
          goto done;
        }
        cp = c;
    37ec:	mov	r0, r4
    37ee:	b.n	37f8 <ExFatFile::getName8(char*, unsigned int)+0x7c>
      } else if (FsUtf::isHighSurrogate(c)) {
    37f0:	cmp.w	r3, #1024	; 0x400
    37f4:	bcc.n	3806 <ExFatFile::getName8(char*, unsigned int)+0x8a>
    37f6:	b.n	381c <ExFatFile::getName8(char*, unsigned int)+0xa0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    37f8:	mov	r2, r8
    37fa:	mov	r1, r5
    37fc:	bl	2ce4 <FsUtf::cpToMb(unsigned long, char*, char*)>
      if (!ptr) {
    3800:	cbz	r0, 3810 <ExFatFile::getName8(char*, unsigned int)+0x94>
    3802:	mov	r5, r0
    3804:	movs	r4, #0
         (dirCache(is, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
    3806:	cmp	fp, r6
    3808:	bne.n	37b8 <ExFatFile::getName8(char*, unsigned int)+0x3c>
  uint32_t cp;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 2; is <= m_setCount; is++) {
    380a:	adds	r7, #1
    380c:	uxtb	r7, r7
    380e:	b.n	3798 <ExFatFile::getName8(char*, unsigned int)+0x1c>
      }
      str = ptr;
    }
  }
 done:
  *str = '\0';
    3810:	movs	r3, #0
    3812:	strb	r3, [r5, #0]
  return str - name;
    3814:	rsb	r0, r9, r5
    3818:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

 fail:
  *name = 0;
    381c:	movs	r0, #0
    381e:	strb.w	r0, [r9]
  return 0;
}
    3822:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3826:	nop
    3828:	.word	0x000ffc00

0000382c <ExFatFile::hashName(ExName_t*)>:
//------------------------------------------------------------------------------
bool ExFatFile::hashName(ExName_t* fname) {
    382c:	push	{r4, r5, r6, lr}
  }
  void reset() {
    next = begin;
    382e:	ldr	r3, [r1, #0]
    3830:	str	r3, [r1, #4]
    ls = 0;
    3832:	movs	r4, #0
    3834:	mov	r5, r1
    3836:	strh	r4, [r1, #12]
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
    3838:	str	r4, [r1, #16]
  while (!fname->atEnd()) {
    uint16_t u = fname->get16();
    if (u == 0XFFFF) {
    383a:	movw	r6, #65535	; 0xffff
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    383e:	ldrh	r3, [r5, #12]
    3840:	cbnz	r3, 384a <ExFatFile::hashName(ExName_t*)+0x1e>
    3842:	ldr	r2, [r5, #4]
    3844:	ldr	r3, [r5, #8]
    3846:	cmp	r2, r3
    3848:	beq.n	387e <ExFatFile::hashName(ExName_t*)+0x52>
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
  while (!fname->atEnd()) {
    uint16_t u = fname->get16();
    384a:	mov	r0, r5
    384c:	bl	3178 <FsName::get16()>
    if (u == 0XFFFF) {
    3850:	cmp	r0, r6
    3852:	beq.n	387a <ExFatFile::hashName(ExName_t*)+0x4e>
  hash = ((hash << 15) | (hash >> 1));
  return hash;
}
//------------------------------------------------------------------------------
inline uint16_t exFatHash(uint16_t u, uint16_t hash) {
  uint16_t c = toUpcase(u);
    3854:	bl	30d4 <toUpcase(unsigned short)>
    3858:	lsls	r3, r4, #15
    385a:	orr.w	r4, r3, r4, lsr #1
    385e:	uxtab	r4, r4, r0
    3862:	ubfx	r3, r4, #1, #15
    3866:	orr.w	r3, r3, r4, lsl #15
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
    386a:	asrs	r4, r0, #8
    386c:	uxtah	r4, r4, r3
    if (u == 0XFFFF) {
    DBG_FAIL_MACRO;
      goto fail;
    }
    hash = exFatHash(u, hash);
    fname->nameLength++;
    3870:	ldr	r3, [r5, #16]
    3872:	adds	r3, #1
}
//------------------------------------------------------------------------------
inline uint16_t exFatHash(uint16_t u, uint16_t hash) {
  uint16_t c = toUpcase(u);
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
    3874:	uxth	r4, r4
    if (u == 0XFFFF) {
    DBG_FAIL_MACRO;
      goto fail;
    }
    hash = exFatHash(u, hash);
    fname->nameLength++;
    3876:	str	r3, [r5, #16]
bool ExFatFile::hashName(ExName_t* fname) {
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
  while (!fname->atEnd()) {
    3878:	b.n	383e <ExFatFile::hashName(ExName_t*)+0x12>
    goto fail;
  }
  return true;

 fail:
  return false;
    387a:	movs	r0, #0
    387c:	pop	{r4, r5, r6, pc}
    hash = exFatHash(c, hash);
  }
  fname->nameLength = fname->end - fname->begin;
#endif  // USE_UTF8_LONG_NAMES
  fname->nameHash = hash;
  if (!fname->nameLength || fname->nameLength > EXFAT_MAX_NAME_LENGTH) {
    387e:	ldr	r0, [r5, #16]
    char c = fname->getch();
    hash = exFatHash(c, hash);
  }
  fname->nameLength = fname->end - fname->begin;
#endif  // USE_UTF8_LONG_NAMES
  fname->nameHash = hash;
    3880:	strh	r4, [r5, #20]
  if (!fname->nameLength || fname->nameLength > EXFAT_MAX_NAME_LENGTH) {
    3882:	subs	r0, #1
    3884:	cmp	r0, #254	; 0xfe
    3886:	ite	hi
    3888:	movhi	r0, #0
    388a:	movls	r0, #1
  }
  return true;

 fail:
  return false;
}
    388c:	pop	{r4, r5, r6, pc}

0000388e <ExFatFile::dirCache(unsigned char, unsigned char)>:
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    388e:	push	{r4, r5, r6, r7, lr}
  DirPos_t pos = m_dirPos;
    3890:	add.w	r3, r0, #36	; 0x24
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    3894:	mov	r5, r0
    3896:	mov	r7, r1
    3898:	mov	r6, r2
  DirPos_t pos = m_dirPos;
    389a:	ldmia.w	r3, {r0, r1, r2}
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    389e:	sub	sp, #20
  DirPos_t pos = m_dirPos;
    38a0:	add	r4, sp, #4
    38a2:	stmia.w	r4, {r0, r1, r2}
  if (m_vol->dirSeek(&pos, 32*set) != 1) {
    38a6:	lsls	r2, r7, #5
    38a8:	mov	r1, r4
    38aa:	ldr	r0, [r5, #32]
    38ac:	bl	426c <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    38b0:	cmp	r0, #1
    38b2:	bne.n	38c0 <ExFatFile::dirCache(unsigned char, unsigned char)+0x32>
    return nullptr;
  }
  return m_vol->dirCache(&pos, options);
    38b4:	mov	r2, r6
    38b6:	mov	r1, r4
    38b8:	ldr	r0, [r5, #32]
    38ba:	bl	41ce <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    38be:	b.n	38c2 <ExFatFile::dirCache(unsigned char, unsigned char)+0x34>
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
  DirPos_t pos = m_dirPos;
  if (m_vol->dirSeek(&pos, 32*set) != 1) {
    return nullptr;
    38c0:	movs	r0, #0
  }
  return m_vol->dirCache(&pos, options);
}
    38c2:	add	sp, #20
    38c4:	pop	{r4, r5, r6, r7, pc}

000038c6 <ExFatFile::close()>:
//------------------------------------------------------------------------------
bool ExFatFile::close() {
    38c6:	push	{r4, lr}
    38c8:	mov	r4, r0
  bool rtn = sync();
    38ca:	bl	4784 <ExFatFile::sync()>
  m_attributes = FILE_ATTR_CLOSED;
    38ce:	movs	r3, #0
    38d0:	strb.w	r3, [r4, #49]	; 0x31
  m_flags = 0;
    38d4:	strb.w	r3, [r4, #51]	; 0x33
  return rtn;
}
    38d8:	pop	{r4, pc}

000038da <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    38da:	push	{r3, r4, r5, lr}
    38dc:	mov	r5, r1
    38de:	mov	r4, r2
  DirFile_t* df = reinterpret_cast<DirFile_t*>
                 (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_READ));
    38e0:	add.w	r1, r0, #36	; 0x24
    38e4:	movs	r2, #0
    38e6:	ldr	r0, [r0, #32]
    38e8:	bl	41ce <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    38ec:	cbz	r0, 38f8 <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)+0x1e>
    38ee:	ldrh	r3, [r0, #10]
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(df->createDate);
    38f0:	strh	r3, [r5, #0]
    38f2:	ldrh	r3, [r0, #8]
  *ptime = getLe16(df->createTime);
    38f4:	strh	r3, [r4, #0]
  return true;
    38f6:	movs	r0, #1

 fail:
  return false;
}
    38f8:	pop	{r3, r4, r5, pc}

000038fa <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)>:
//------------------------------------------------------------------------------
bool ExFatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    38fa:	push	{r3, r4, r5, lr}
    38fc:	mov	r5, r1
    38fe:	mov	r4, r2
  DirFile_t* df = reinterpret_cast<DirFile_t*>
                 (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_READ));
    3900:	add.w	r1, r0, #36	; 0x24
    3904:	movs	r2, #0
    3906:	ldr	r0, [r0, #32]
    3908:	bl	41ce <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    390c:	cbz	r0, 3918 <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)+0x1e>
    390e:	ldrh	r3, [r0, #14]
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(df->modifyDate);
    3910:	strh	r3, [r5, #0]
    3912:	ldrh	r3, [r0, #12]
  *ptime = getLe16(df->modifyTime);
    3914:	strh	r3, [r4, #0]
  return true;
    3916:	movs	r0, #1

 fail:
  return false;
}
    3918:	pop	{r3, r4, r5, pc}

0000391a <ExFatFile::openRoot(ExFatVolume*)>:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
    391a:	push	{r3, r4, r5, lr}
    391c:	mov	r5, r1
  if (isOpen()) {
    391e:	ldrb.w	r1, [r0, #49]	; 0x31
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
    3922:	mov	r4, r0
  if (isOpen()) {
    3924:	cbnz	r1, 393c <ExFatFile::openRoot(ExFatVolume*)+0x22>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    3926:	movs	r2, #56	; 0x38
    3928:	bl	88dc <memset>
  m_attributes = FILE_ATTR_ROOT;
    392c:	movs	r3, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    392e:	movs	r0, #1
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
    3930:	strb.w	r3, [r4, #49]	; 0x31
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    3934:	strb.w	r0, [r4, #51]	; 0x33
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
    3938:	str	r5, [r4, #32]
    393a:	pop	{r3, r4, r5, pc}
  m_flags = FILE_FLAG_READ;
  return true;

 fail:
  return false;
    393c:	movs	r0, #0
}
    393e:	pop	{r3, r4, r5, pc}

00003940 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>:
//------------------------------------------------------------------------------
bool ExFatFile::parsePathName(const char* path,
                            ExName_t* fname, const char** ptr) {
    3940:	push	{r4, r5, r6, r7}
  // Skip leading spaces.
  while (*path == ' ') {
    3942:	ldrb	r4, [r1, #0]
    3944:	cmp	r4, #32
    3946:	add.w	r5, r1, #1
    394a:	bne.n	3950 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x10>
    394c:	mov	r1, r5
    394e:	b.n	3942 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x2>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    3950:	ldr	r7, [pc, #100]	; (39b8 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x78>)
    path++;
  }
  fname->begin = path;
    3952:	str	r1, [r2, #0]
  fname->end = path;
    3954:	str	r1, [r2, #8]
  while (*path && !isDirSeparator(*path)) {
    3956:	mov	r5, r1
    3958:	mov	r6, r1
    395a:	ldrb.w	r4, [r5], #1
    395e:	cbz	r4, 3998 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x58>
    3960:	cmp	r4, #47	; 0x2f
    3962:	beq.n	398c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x4c>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    3964:	cmp	r4, #31
    3966:	bls.n	39b2 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    3968:	sub.w	r1, r4, #34	; 0x22
    396c:	uxtb	r1, r1
    396e:	cmp	r1, #29
    3970:	bhi.n	397a <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x3a>
    3972:	lsr.w	r1, r7, r1
    3976:	lsls	r1, r1, #31
    3978:	bmi.n	39b2 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    397a:	and.w	r1, r4, #191	; 0xbf
    397e:	cmp	r1, #60	; 0x3c
    3980:	beq.n	39b2 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
    3982:	cmp	r4, #92	; 0x5c
    3984:	bne.n	39a2 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    3986:	b.n	39b2 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
      // Need to trim trailing dots spaces.
      fname->end = path;
    }
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
    3988:	cmp	r4, #47	; 0x2f
    398a:	bne.n	3998 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x58>
    398c:	mov	r6, r1
    398e:	ldrb.w	r4, [r1], #1
    3992:	cmp	r4, #32
    3994:	bne.n	3988 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x48>
    3996:	b.n	398c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x4c>
  *ptr = path;
    3998:	str	r6, [r3, #0]
  return hashName(fname);
    399a:	mov	r1, r2

 fail:
  return false;
}
    399c:	pop	{r4, r5, r6, r7}
    }
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
  *ptr = path;
  return hashName(fname);
    399e:	b.w	382c <ExFatFile::hashName(ExName_t*)>
    uint8_t c = *path++;
    if (!lfnLegalChar(c)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (c != '.' && c != ' ') {
    39a2:	cmp	r4, #46	; 0x2e
    39a4:	bne.n	39aa <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x6a>
    39a6:	mov	r1, r5
    39a8:	b.n	3956 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x16>
    39aa:	cmp	r4, #32
    39ac:	beq.n	39a6 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x66>
      // Need to trim trailing dots spaces.
      fname->end = path;
    39ae:	str	r5, [r2, #8]
    39b0:	b.n	39a6 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x66>
  *ptr = path;
  return hashName(fname);

 fail:
  return false;
}
    39b2:	movs	r0, #0
    39b4:	pop	{r4, r5, r6, r7}
    39b6:	bx	lr
    39b8:	.word	0x31000101

000039bc <ExFatFile::read(void*, unsigned int)>:
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    39bc:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    39c0:	ldrb.w	r3, [r0, #51]	; 0x33
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    39c4:	lsls	r7, r3, #31
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    39c6:	mov	r4, r0
    39c8:	mov	r6, r1
    39ca:	mov	r5, r2
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    39cc:	bpl.n	3abe <ExFatFile::read(void*, unsigned int)+0x102>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isContiguous() || isFile()) {
    39ce:	lsls	r0, r3, #25
    39d0:	bmi.n	39da <ExFatFile::read(void*, unsigned int)+0x1e>
    39d2:	ldrb.w	r3, [r4, #49]	; 0x31
    39d6:	lsls	r1, r3, #28
    39d8:	bpl.n	39f4 <ExFatFile::read(void*, unsigned int)+0x38>
    if ((m_curPosition + count) > m_validLength) {
    39da:	ldrd	r0, r1, [r4]
    39de:	ldrd	r2, r3, [r4, #16]
    39e2:	adds.w	r8, r0, r5
    39e6:	adc.w	r9, r1, #0
    39ea:	cmp	r3, r9
    39ec:	it	eq
    39ee:	cmpeq	r2, r8
    39f0:	bcs.n	39f4 <ExFatFile::read(void*, unsigned int)+0x38>
      count = toRead = m_validLength - m_curPosition;
    39f2:	subs	r5, r2, r0
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    39f4:	mov	r9, r5
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
      } else if (isContiguous()) {
        m_curCluster++;
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    39f6:	add.w	sl, r4, #24
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    39fa:	cmp.w	r9, #0
    39fe:	beq.n	3a88 <ExFatFile::read(void*, unsigned int)+0xcc>
    clusterOffset = m_curPosition & m_vol->clusterMask();
    3a00:	ldr	r0, [r4, #32]
    3a02:	ldrd	r2, r3, [r4]
    3a06:	ldr.w	r1, [r0, #1080]	; 0x438
    3a0a:	and.w	r8, r1, r2
    sectorOffset = clusterOffset & m_vol->sectorMask();
    3a0e:	ubfx	fp, r8, #0, #9
    if (clusterOffset == 0) {
    3a12:	cmp.w	r8, #0
    3a16:	bne.n	3a56 <ExFatFile::read(void*, unsigned int)+0x9a>
      if (m_curPosition == 0) {
    3a18:	orrs	r3, r2
    3a1a:	bne.n	3a2c <ExFatFile::read(void*, unsigned int)+0x70>
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
    3a1c:	ldrb.w	r3, [r4, #49]	; 0x31
    3a20:	lsls	r2, r3, #25
    3a22:	ite	mi
    3a24:	ldrmi.w	r3, [r0, #1076]	; 0x434
    3a28:	ldrpl	r3, [r4, #28]
    3a2a:	b.n	3a38 <ExFatFile::read(void*, unsigned int)+0x7c>
      } else if (isContiguous()) {
    3a2c:	ldrb.w	r3, [r4, #51]	; 0x33
    3a30:	lsls	r3, r3, #25
    3a32:	bpl.n	3a3c <ExFatFile::read(void*, unsigned int)+0x80>
        m_curCluster++;
    3a34:	ldr	r3, [r4, #24]
    3a36:	adds	r3, #1
    3a38:	str	r3, [r4, #24]
    3a3a:	b.n	3a56 <ExFatFile::read(void*, unsigned int)+0x9a>
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    3a3c:	mov	r2, sl
    3a3e:	ldr	r1, [r4, #24]
    3a40:	bl	4204 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
        if (fg < 0) {
    3a44:	cmp	r0, #0
    3a46:	blt.n	3abe <ExFatFile::read(void*, unsigned int)+0x102>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
    3a48:	bne.n	3a56 <ExFatFile::read(void*, unsigned int)+0x9a>
          // EOF if directory.
          if (isDir()) {
    3a4a:	ldrb.w	r3, [r4, #49]	; 0x31
    3a4e:	tst.w	r3, #80	; 0x50
    3a52:	bne.n	3a88 <ExFatFile::read(void*, unsigned int)+0xcc>
    3a54:	b.n	3abe <ExFatFile::read(void*, unsigned int)+0x102>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
    3a56:	ldr	r7, [r4, #32]
             (clusterOffset >> m_vol->bytesPerSectorShift());
    3a58:	ldr	r1, [r4, #24]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    3a5a:	ldrb.w	lr, [r7, #1093]	; 0x445
    3a5e:	ldr.w	r0, [r7, #1068]	; 0x42c
    3a62:	subs	r1, #2
    3a64:	lsl.w	r1, r1, lr
    3a68:	mov.w	r2, r8, lsr #9
    3a6c:	add	r1, r0
    3a6e:	add.w	r8, r1, r2
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
    3a72:	cmp.w	fp, #0
    3a76:	bne.n	3b18 <ExFatFile::read(void*, unsigned int)+0x15c>
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
    3a78:	cmp.w	r9, #512	; 0x200
    3a7c:	bcc.n	3b18 <ExFatFile::read(void*, unsigned int)+0x15c>
    3a7e:	ldr.w	r1, [r7, #540]	; 0x21c
                          || sector == m_vol->dataCacheSector()) {
    3a82:	cmp	r8, r1
    3a84:	bne.n	3a90 <ExFatFile::read(void*, unsigned int)+0xd4>
    3a86:	b.n	3b18 <ExFatFile::read(void*, unsigned int)+0x15c>
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return count - toRead;
    3a88:	rsb	r0, r9, r5
    3a8c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    3a90:	cmp.w	r9, #1024	; 0x400
    3a94:	bcc.n	3aec <ExFatFile::read(void*, unsigned int)+0x130>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      // Limit reads to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    3a96:	movs	r3, #1
    3a98:	lsl.w	r3, r3, lr
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    3a9c:	mov.w	fp, r9, lsr #9
      // Limit reads to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    3aa0:	subs	r2, r3, r2
    3aa2:	cmp	fp, r2
    3aa4:	it	cs
    3aa6:	movcs	fp, r2
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    3aa8:	cmp	r8, r1
    3aaa:	bhi.n	3ad2 <ExFatFile::read(void*, unsigned int)+0x116>
    3aac:	add.w	r3, fp, r8
    3ab0:	cmp	r1, r3
    3ab2:	bcs.n	3ad2 <ExFatFile::read(void*, unsigned int)+0x116>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    3ab4:	add.w	r0, r7, #528	; 0x210
    3ab8:	bl	303a <FsCache::sync()>
    3abc:	cbnz	r0, 3ad2 <ExFatFile::read(void*, unsigned int)+0x116>
    toRead -= n;
  }
  return count - toRead;

 fail:
  m_error |= READ_ERROR;
    3abe:	ldrb.w	r3, [r4, #50]	; 0x32
    3ac2:	orr.w	r3, r3, #2
    3ac6:	strb.w	r3, [r4, #50]	; 0x32
  return -1;
    3aca:	mov.w	r0, #4294967295
    3ace:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    3ad2:	ldr.w	r0, [r7, #532]	; 0x214
    3ad6:	ldr	r3, [r0, #0]
    3ad8:	mov	r2, r6
    3ada:	ldr	r7, [r3, #16]
    3adc:	mov	r1, r8
    3ade:	mov	r3, fp
    3ae0:	blx	r7
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
     if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    3ae2:	cmp	r0, #0
    3ae4:	beq.n	3abe <ExFatFile::read(void*, unsigned int)+0x102>
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    3ae6:	mov.w	r7, fp, lsl #9
    3aea:	b.n	3b02 <ExFatFile::read(void*, unsigned int)+0x146>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    3aec:	ldr.w	r0, [r7, #532]	; 0x214
    3af0:	ldr	r3, [r0, #0]
    3af2:	mov	r2, r6
    3af4:	ldr	r3, [r3, #12]
    3af6:	mov	r1, r8
    3af8:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    3afa:	cmp	r0, #0
    3afc:	beq.n	3abe <ExFatFile::read(void*, unsigned int)+0x102>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    3afe:	mov.w	r7, #512	; 0x200
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    3b02:	ldrd	r2, r3, [r4]
    3b06:	adds	r2, r2, r7
    3b08:	adc.w	r3, r3, #0
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    3b0c:	add	r6, r7
    m_curPosition += n;
    3b0e:	strd	r2, r3, [r4]
    toRead -= n;
    3b12:	rsb	r9, r7, r9
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    3b16:	b.n	39fa <ExFatFile::read(void*, unsigned int)+0x3e>
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    3b18:	movs	r2, #0
    3b1a:	mov	r1, r8
    3b1c:	add.w	r0, r7, #528	; 0x210
    3b20:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      cache = m_vol->dataCacheGet(sector, FsCache::CACHE_FOR_READ);
      if (!cache) {
    3b24:	cmp	r0, #0
    3b26:	beq.n	3abe <ExFatFile::read(void*, unsigned int)+0x102>
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
      n = m_vol->bytesPerSector() - sectorOffset;
    3b28:	rsb	r7, fp, #512	; 0x200
    3b2c:	cmp	r7, r9
    3b2e:	it	cs
    3b30:	movcs	r7, r9
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
    3b32:	add.w	r1, r0, fp
    3b36:	mov	r2, r7
    3b38:	mov	r0, r6
    3b3a:	bl	8734 <memcpy>
    3b3e:	b.n	3b02 <ExFatFile::read(void*, unsigned int)+0x146>

00003b40 <ExFatFile::peek()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int ExFatFile::peek() {
    3b40:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    3b42:	movs	r2, #1
    3b44:	add.w	r1, sp, #7
    3b48:	mov	r4, r0
  uint64_t curPosition = m_curPosition;
    3b4a:	ldrd	r6, r7, [r0]
  uint32_t curCluster = m_curCluster;
    3b4e:	ldr	r5, [r0, #24]
    3b50:	bl	39bc <ExFatFile::read(void*, unsigned int)>
    3b54:	cmp	r0, #1
    3b56:	it	eq
    3b58:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
  m_curCluster = curCluster;
    3b5c:	str	r5, [r4, #24]
    3b5e:	it	ne
    3b60:	movne.w	r0, #4294967295
//------------------------------------------------------------------------------
int ExFatFile::peek() {
  uint64_t curPosition = m_curPosition;
  uint32_t curCluster = m_curCluster;
  int c = read();
  m_curPosition = curPosition;
    3b64:	strd	r6, r7, [r4]
  m_curCluster = curCluster;
  return c;
}
    3b68:	add	sp, #12
    3b6a:	pop	{r4, r5, r6, r7, pc}

00003b6c <ExFatFile::seekSet(unsigned long long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    3b6c:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3b70:	ldrb.w	fp, [r0, #49]	; 0x31
    3b74:	mov	r7, r3
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    3b76:	ldr	r3, [r0, #24]
    3b78:	str	r3, [sp, #4]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    3b7a:	mov	r4, r0
    3b7c:	mov	r6, r2
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    3b7e:	cmp.w	fp, #0
    3b82:	beq.n	3c2c <ExFatFile::seekSet(unsigned long long)+0xc0>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    3b84:	ldrd	r8, r9, [r0]
    3b88:	cmp	r9, r7
    3b8a:	it	eq
    3b8c:	cmpeq	r8, r2
    3b8e:	beq.n	3c34 <ExFatFile::seekSet(unsigned long long)+0xc8>
    return true;
  }
  if (pos == 0) {
    3b90:	orrs.w	r3, r6, r7
    3b94:	bne.n	3b9c <ExFatFile::seekSet(unsigned long long)+0x30>
    // set position to start of file
    m_curCluster = 0;
    3b96:	movs	r3, #0
    3b98:	str	r3, [r0, #24]
    goto done;
    3b9a:	b.n	3c26 <ExFatFile::seekSet(unsigned long long)+0xba>
  }
  if (isFile()) {
    3b9c:	tst.w	fp, #8
    3ba0:	beq.n	3bae <ExFatFile::seekSet(unsigned long long)+0x42>
    if (pos > m_validLength) {
    3ba2:	ldrd	r0, r1, [r0, #16]
    3ba6:	cmp	r1, r7
    3ba8:	it	eq
    3baa:	cmpeq	r0, r2
    3bac:	bcc.n	3c2c <ExFatFile::seekSet(unsigned long long)+0xc0>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    3bae:	ldr	r3, [r4, #32]
    3bb0:	str	r3, [sp, #0]
    3bb2:	ldrb.w	sl, [r3, #1093]	; 0x445
    3bb6:	add.w	sl, sl, #9
    3bba:	adds.w	r0, r6, #4294967295
    3bbe:	uxtb.w	sl, sl
    3bc2:	mov	r2, sl
    3bc4:	adc.w	r1, r7, #4294967295
    3bc8:	bl	9ce8 <__aeabi_llsr>
  if (isContiguous()) {
    3bcc:	ldrb.w	r2, [r4, #51]	; 0x33
    3bd0:	lsls	r3, r2, #25
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    3bd2:	mov	r5, r0
  if (isContiguous()) {
    3bd4:	bpl.n	3bde <ExFatFile::seekSet(unsigned long long)+0x72>
    m_curCluster = m_firstCluster + nNew;
    3bd6:	ldr	r3, [r4, #28]
    3bd8:	add	r5, r3
    3bda:	str	r5, [r4, #24]
    goto done;
    3bdc:	b.n	3c26 <ExFatFile::seekSet(unsigned long long)+0xba>
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
    3bde:	adds.w	r0, r8, #4294967295
    3be2:	adc.w	r1, r9, #4294967295
    3be6:	mov	r2, sl
    3be8:	bl	9ce8 <__aeabi_llsr>
  if (nNew < nCur || m_curPosition == 0) {
    3bec:	cmp	r5, r0
    3bee:	bcc.n	3bf6 <ExFatFile::seekSet(unsigned long long)+0x8a>
    3bf0:	orrs.w	r3, r8, r9
    3bf4:	bne.n	3c0c <ExFatFile::seekSet(unsigned long long)+0xa0>
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
    3bf6:	tst.w	fp, #64	; 0x40
    3bfa:	itet	ne
    3bfc:	ldrne	r3, [sp, #0]
    3bfe:	ldreq	r3, [r4, #28]
    3c00:	ldrne.w	r3, [r3, #1076]	; 0x434
    3c04:	str	r3, [r4, #24]
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    3c06:	add.w	r8, r4, #24
    3c0a:	b.n	3c22 <ExFatFile::seekSet(unsigned long long)+0xb6>
  if (nNew < nCur || m_curPosition == 0) {
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    3c0c:	subs	r5, r5, r0
    3c0e:	b.n	3c06 <ExFatFile::seekSet(unsigned long long)+0x9a>
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    3c10:	mov	r2, r8
    3c12:	ldr	r1, [r4, #24]
    3c14:	ldr	r0, [r4, #32]
    3c16:	bl	4204 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    3c1a:	cmp	r0, #0
    3c1c:	add.w	r5, r5, #4294967295
    3c20:	ble.n	3c2c <ExFatFile::seekSet(unsigned long long)+0xc0>
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    3c22:	cmp	r5, #0
    3c24:	bne.n	3c10 <ExFatFile::seekSet(unsigned long long)+0xa4>
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    3c26:	strd	r6, r7, [r4]
    3c2a:	b.n	3c34 <ExFatFile::seekSet(unsigned long long)+0xc8>
  return true;

 fail:
  m_curCluster = tmp;
    3c2c:	ldr	r3, [sp, #4]
    3c2e:	str	r3, [r4, #24]
  return false;
    3c30:	movs	r0, #0
    3c32:	b.n	3c36 <ExFatFile::seekSet(unsigned long long)+0xca>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    3c34:	movs	r0, #1
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    3c36:	add	sp, #12
    3c38:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00003c3c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openPrivate(ExFatFile* dir, ExName_t* fname, oflag_t oflag) {
    3c3c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3c40:	mov	sl, r3
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
  bool inSet = false;

  // error if already open, no access mode, or no directory.
  if (isOpen() || !dir->isDir()) {
    3c42:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openPrivate(ExFatFile* dir, ExName_t* fname, oflag_t oflag) {
    3c46:	sub	sp, #52	; 0x34
    3c48:	mov	r4, r0
    3c4a:	mov	r6, r1
    3c4c:	mov	r5, r2
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
  bool inSet = false;

  // error if already open, no access mode, or no directory.
  if (isOpen() || !dir->isDir()) {
    3c4e:	cbnz	r3, 3cae <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    3c50:	ldrb.w	r3, [r1, #49]	; 0x31
    3c54:	tst.w	r3, #80	; 0x50
    3c58:	beq.n	3cae <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    DBG_FAIL_MACRO;
    goto fail;
  }

  switch (oflag & O_ACCMODE) {
    3c5a:	and.w	r3, sl, #3
    3c5e:	cmp	r3, #1
    3c60:	beq.w	3f68 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x32c>
    3c64:	cmp	r3, #2
    3c66:	bne.w	3f5e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x322>
      break;
    case O_WRONLY:
      modeFlags = FILE_FLAG_WRITE;
      break;
    case O_RDWR:
      modeFlags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    3c6a:	movs	r3, #3
      break;
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
    3c6c:	and.w	r9, sl, #8
    3c70:	orr.w	r9, r9, r3

  if (fname) {
    3c74:	cbz	r5, 3cba <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x7e>
    freeNeed = 2 + (fname->nameLength + 14)/15;
    3c76:	ldr	r3, [r5, #16]
    3c78:	mov.w	r8, #15
    3c7c:	adds	r3, #14
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    3c7e:	movs	r2, #0
    3c80:	udiv	r8, r3, r8
    3c84:	mov	r0, r6
    3c86:	add.w	r8, r8, #2
    3c8a:	movs	r3, #0
    3c8c:	uxtb.w	r8, r8
    3c90:	bl	3b6c <ExFatFile::seekSet(unsigned long long)>
        }
        // Likely openNext call.
        DBG_WARN_MACRO;
        goto fail;
      }
      inSet = false;
    3c94:	mov.w	fp, #0
    3c98:	mov	r7, fp
    freeNeed = 2 + (fname->nameLength + 14)/15;
    dir->rewind();
  }

  while (1) {
    n = dir->read(buf, 32);
    3c9a:	movs	r2, #32
    3c9c:	add	r1, sp, #16
    3c9e:	mov	r0, r6
    3ca0:	bl	39bc <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    3ca4:	cmp	r0, #0
    3ca6:	beq.w	3e22 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1e6>
      goto create;
    }
    if (n != 32) {
    3caa:	cmp	r0, #32
    3cac:	beq.n	3cc0 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x84>
  return sync();
#endif  // READ_ONLY

 fail:
  // close file
  m_attributes = FILE_ATTR_CLOSED;
    3cae:	movs	r0, #0
    3cb0:	strb.w	r0, [r4, #49]	; 0x31
  m_flags = 0;
    3cb4:	strb.w	r0, [r4, #51]	; 0x33
  return false;
    3cb8:	b.n	3f80 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
  DirFile_t*   dirFile;
  DirStream_t* dirStream;
  DirName_t*   dirName;
  uint8_t buf[32];
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
    3cba:	mov.w	r8, #3
    3cbe:	b.n	3c94 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x58>
    }
    if (n != 32) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(buf[0] & 0x80)) {
    3cc0:	ldrb.w	r2, [sp, #16]
    3cc4:	lsls	r1, r2, #24
    3cc6:	bmi.n	3cec <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xb0>
      // Unused entry.
      if (freeCount == 0) {
    3cc8:	cbnz	r7, 3cd4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x98>
        freePos.position = dir->curPosition() - 32;
    3cca:	ldr	r3, [r6, #0]
    3ccc:	subs	r3, #32
    3cce:	str	r3, [sp, #4]
    3cd0:	ldr	r3, [r6, #24]
    3cd2:	str	r3, [sp, #0]
        freePos.cluster = dir->curCluster();
      }
      if (freeCount < freeNeed) {
    3cd4:	cmp	r7, r8
        freeCount++;
    3cd6:	itt	cc
    3cd8:	addcc	r7, #1
    3cda:	uxtbcc	r7, r7
      }
      if (!buf[0]) {
    3cdc:	cbz	r2, 3ce4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa8>
      }
      if (fname->atEnd()) {
        goto found;
      }
    } else {
      inSet = false;
    3cde:	mov.w	fp, #0
    3ce2:	b.n	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
      }
      if (freeCount < freeNeed) {
        freeCount++;
      }
      if (!buf[0]) {
        if (fname) {
    3ce4:	cmp	r5, #0
    3ce6:	bne.w	3e22 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1e6>
    3cea:	b.n	3cae <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
        // Likely openNext call.
        DBG_WARN_MACRO;
        goto fail;
      }
      inSet = false;
    } else if (!inSet) {
    3cec:	cmp.w	fp, #0
    3cf0:	bne.n	3d42 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x106>
      if (freeCount < freeNeed) {
        freeCount = 0;
    3cf2:	cmp	r7, r8
    3cf4:	it	cc
    3cf6:	movcc	r7, #0
      }
      if (buf[0] != EXFAT_TYPE_FILE) {
    3cf8:	cmp	r2, #133	; 0x85
    3cfa:	bne.n	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
        continue;
      }
      inSet = true;
      memset(this, 0, sizeof(ExFatFile));
    3cfc:	movs	r2, #56	; 0x38
    3cfe:	mov	r1, fp
    3d00:	mov	r0, r4
    3d02:	bl	88dc <memset>
      dirFile = reinterpret_cast<DirFile_t*>(buf);
      m_setCount = dirFile->setCount;
      m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    3d06:	ldrb.w	r2, [sp, #20]
        continue;
      }
      inSet = true;
      memset(this, 0, sizeof(ExFatFile));
      dirFile = reinterpret_cast<DirFile_t*>(buf);
      m_setCount = dirFile->setCount;
    3d0a:	ldrb.w	r3, [sp, #17]
    3d0e:	strb.w	r3, [r4, #48]	; 0x30
      m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    3d12:	and.w	r3, r2, #55	; 0x37
      if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
    3d16:	lsls	r2, r2, #27
        m_attributes |= FILE_ATTR_FILE;
    3d18:	it	pl
    3d1a:	orrpl.w	r3, r3, #8
    3d1e:	strb.w	r3, [r4, #49]	; 0x31
    3d22:	ldr	r3, [r6, #32]
      }
      m_vol = dir->volume();
    3d24:	str	r3, [r4, #32]
    3d26:	ldr	r3, [r6, #24]
      m_dirPos.cluster = dir->curCluster();
    3d28:	str	r3, [r4, #36]	; 0x24
      m_dirPos.position = dir->curPosition() - 32;
    3d2a:	ldr	r3, [r6, #0]
    3d2c:	subs	r3, #32
    3d2e:	str	r3, [r4, #40]	; 0x28
      m_dirPos.isContiguous = dir->isContiguous();
    3d30:	ldrb.w	r3, [r6, #51]	; 0x33
    3d34:	ubfx	r3, r3, #6, #1
    3d38:	strb.w	r3, [r4, #44]	; 0x2c
        freeCount = 0;
      }
      if (buf[0] != EXFAT_TYPE_FILE) {
        continue;
      }
      inSet = true;
    3d3c:	mov.w	fp, #1
    3d40:	b.n	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
      }
      m_vol = dir->volume();
      m_dirPos.cluster = dir->curCluster();
      m_dirPos.position = dir->curPosition() - 32;
      m_dirPos.isContiguous = dir->isContiguous();
    } else if (buf[0] == EXFAT_TYPE_STREAM) {
    3d42:	cmp	r2, #192	; 0xc0
    3d44:	bne.n	3d9e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x162>
      dirStream = reinterpret_cast<DirStream_t*>(buf);
      m_flags = modeFlags;
      if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    3d46:	ldrb.w	r3, [sp, #17]
      m_dirPos.cluster = dir->curCluster();
      m_dirPos.position = dir->curPosition() - 32;
      m_dirPos.isContiguous = dir->isContiguous();
    } else if (buf[0] == EXFAT_TYPE_STREAM) {
      dirStream = reinterpret_cast<DirStream_t*>(buf);
      m_flags = modeFlags;
    3d4a:	strb.w	r9, [r4, #51]	; 0x33
      if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    3d4e:	lsls	r0, r3, #30
        m_flags |= FILE_FLAG_CONTIGUOUS;
    3d50:	itt	mi
    3d52:	orrmi.w	r3, r9, #64	; 0x40
    3d56:	strbmi.w	r3, [r4, #51]	; 0x33
      }
      m_validLength = getLe64(dirStream->validLength);
    3d5a:	ldrd	r2, r3, [sp, #24]
    3d5e:	strd	r2, r3, [r4, #16]
      m_firstCluster = getLe32(dirStream->firstCluster);
    3d62:	ldr	r3, [sp, #36]	; 0x24
    3d64:	str	r3, [r4, #28]
      m_dataLength = getLe64(dirStream->dataLength);
    3d66:	ldrd	r2, r3, [sp, #40]	; 0x28
    3d6a:	strd	r2, r3, [r4, #8]
      if (!fname) {
    3d6e:	cbnz	r5, 3d78 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x13c>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    3d70:	tst.w	sl, #2048	; 0x800
    3d74:	bne.n	3cae <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    3d76:	b.n	3dc6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x18a>
  }
  void reset() {
    next = begin;
    3d78:	ldr	r3, [r5, #0]
    3d7a:	str	r3, [r5, #4]
    ls = 0;
    3d7c:	mov.w	r3, #0
    3d80:	strh	r3, [r5, #12]
      m_dataLength = getLe64(dirStream->dataLength);
      if (!fname) {
        goto found;
      }
      fname->reset();
      if (fname->nameLength != dirStream->nameLength ||
    3d82:	ldr	r2, [r5, #16]
    3d84:	ldrb.w	r3, [sp, #19]
    3d88:	cmp	r2, r3
    3d8a:	bne.n	3cde <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa2>
    3d8c:	ldrh.w	r2, [sp, #20]
    3d90:	ldrh	r3, [r5, #20]
    3d92:	subs	r1, r2, r3
    3d94:	rsbs	fp, r1, #0
    3d98:	adc.w	fp, fp, r1
    3d9c:	b.n	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
          fname->nameHash != getLe16(dirStream->nameHash)) {
        inSet = false;
      }
    } else if (buf[0] == EXFAT_TYPE_NAME) {
    3d9e:	cmp	r2, #193	; 0xc1
    3da0:	bne.n	3cde <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa2>
      dirName = reinterpret_cast<DirName_t*>(buf);
      if (!cmpName(dirName, fname)) {
    3da2:	mov	r2, r5
    3da4:	add	r1, sp, #16
    3da6:	mov	r0, r4
    3da8:	bl	3730 <ExFatFile::cmpName(DirName_t const*, ExName_t*)>
    3dac:	cbnz	r0, 3db2 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x176>
        inSet = false;
    3dae:	mov	fp, r0
    3db0:	b.n	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    3db2:	ldrh	r2, [r5, #12]
    3db4:	cmp	r2, #0
    3db6:	bne.w	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
    3dba:	ldr	r1, [r5, #4]
    3dbc:	ldr	r2, [r5, #8]
    3dbe:	cmp	r1, r2
    3dc0:	bne.w	3c9a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
    3dc4:	b.n	3d70 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x134>
  if (oflag & O_EXCL) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Write, truncate, or at end is an error for a directory or read-only file.
  if ((oflag & (O_TRUNC | O_AT_END)) || (m_flags & FILE_FLAG_WRITE)) {
    3dc6:	tst.w	sl, #17408	; 0x4400
    3dca:	bne.n	3dd4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x198>
    3dcc:	ldrb.w	r3, [r4, #51]	; 0x33
    3dd0:	lsls	r2, r3, #30
    3dd2:	bpl.n	3de0 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1a4>
    if (isSubDir() || isReadOnly() || READ_ONLY) {
    3dd4:	ldrb.w	r3, [r4, #49]	; 0x31
    3dd8:	tst.w	r3, #17
    3ddc:	bne.w	3cae <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      goto fail;
    }
  }

#if !READ_ONLY
  if (oflag & O_TRUNC) {
    3de0:	tst.w	sl, #1024	; 0x400
    3de4:	beq.n	3e08 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1cc>
    if (!(m_flags & FILE_FLAG_WRITE)) {
    3de6:	ldrb.w	r3, [r4, #51]	; 0x33
    3dea:	lsls	r3, r3, #30
    3dec:	bpl.w	3cae <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
    3df0:	movs	r2, #0
    3df2:	movs	r3, #0
    3df4:	mov	r0, r4
    3df6:	bl	3b6c <ExFatFile::seekSet(unsigned long long)>
    3dfa:	cmp	r0, #0
    3dfc:	beq.w	3cae <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    3e00:	mov	r0, r4
    3e02:	bl	4b5e <ExFatFile::truncate()>
    3e06:	b.n	3e1a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1de>
    }
    if (!truncate(0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    3e08:	tst.w	sl, #16384	; 0x4000
    3e0c:	beq.w	3f6c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x330>
    3e10:	ldrd	r2, r3, [r4, #16]
    3e14:	mov	r0, r4
    3e16:	bl	3b6c <ExFatFile::seekSet(unsigned long long)>
    3e1a:	cmp	r0, #0
    3e1c:	beq.w	3cae <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    3e20:	b.n	3f6c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x330>
#if READ_ONLY
  DBG_FAIL_MACRO;
  goto fail;
#else  // READ_ONLY
  // don't create unless O_CREAT and write
  if (!(oflag & O_CREAT) || !(modeFlags & FILE_FLAG_WRITE) || !fname) {
    3e22:	tst.w	sl, #512	; 0x200
    3e26:	beq.w	3cae <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    3e2a:	tst.w	r9, #2
    3e2e:	beq.w	3cae <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    3e32:	cmp	r5, #0
    3e34:	beq.w	3cae <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    DBG_WARN_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    3e38:	cmp	r7, r8
    3e3a:	bcs.n	3e76 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x23a>
    n = dir->read(buf, 32);
    3e3c:	movs	r2, #32
    3e3e:	add	r1, sp, #16
    3e40:	mov	r0, r6
    3e42:	bl	39bc <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    3e46:	cbnz	r0, 3e5e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x222>
      curCluster = dir->m_curCluster;
      if (!dir->addDirCluster()) {
    3e48:	mov	r0, r6
    goto fail;
  }
  while (freeCount < freeNeed) {
    n = dir->read(buf, 32);
    if (n == 0) {
      curCluster = dir->m_curCluster;
    3e4a:	ldr.w	sl, [r6, #24]
      if (!dir->addDirCluster()) {
    3e4e:	bl	47c2 <ExFatFile::addDirCluster()>
    3e52:	cmp	r0, #0
    3e54:	beq.w	3cae <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
        DBG_FAIL_MACRO;
        goto fail;
      }
      dir->m_curCluster = curCluster;
    3e58:	str.w	sl, [r6, #24]
      continue;
    3e5c:	b.n	3e38 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1fc>
    }
    if (n != 32) {
    3e5e:	cmp	r0, #32
    3e60:	bne.w	3cae <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (freeCount == 0) {
    3e64:	cbnz	r7, 3e70 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x234>
      freePos.position = dir->curPosition() - 32;
    3e66:	ldr	r3, [r6, #0]
    3e68:	subs	r3, #32
    3e6a:	str	r3, [sp, #4]
    3e6c:	ldr	r3, [r6, #24]
    3e6e:	str	r3, [sp, #0]
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
    3e70:	adds	r7, #1
    3e72:	uxtb	r7, r7
    3e74:	b.n	3e38 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1fc>
  }
  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
    3e76:	movs	r2, #56	; 0x38
    3e78:	movs	r1, #0
    3e7a:	mov	r0, r4
      freePos.position = dir->curPosition() - 32;
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }
  freePos.isContiguous = dir->isContiguous();
    3e7c:	ldrb.w	r7, [r6, #51]	; 0x33
  memset(this, 0, sizeof(ExFatFile));
    3e80:	bl	88dc <memset>
    3e84:	ldr	r3, [r6, #32]
  m_vol = dir->volume();
    3e86:	str	r3, [r4, #32]
  m_attributes = FILE_ATTR_FILE;
    3e88:	movs	r3, #8
    3e8a:	strb.w	r3, [r4, #49]	; 0x31
  m_dirPos = freePos;
    3e8e:	ldr	r3, [sp, #0]
    3e90:	str	r3, [r4, #36]	; 0x24
      freePos.position = dir->curPosition() - 32;
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }
  freePos.isContiguous = dir->isContiguous();
    3e92:	ubfx	r7, r7, #6, #1
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
    3e96:	ldr	r3, [sp, #4]
    3e98:	strb.w	r7, [r4, #44]	; 0x2c
    3e9c:	str	r3, [r4, #40]	; 0x28
  }
  void reset() {
    next = begin;
    3e9e:	ldr	r3, [r5, #0]
    3ea0:	str	r3, [r5, #4]
    ls = 0;
    3ea2:	movs	r7, #0
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    3ea4:	add.w	sl, r8, #4294967295
    3ea8:	strh	r7, [r5, #12]
    3eaa:	uxtb.w	sl, sl
    3eae:	uxtb.w	fp, r7
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  fname->reset();
  for (uint8_t i = 0; i < freeNeed; i++) {
    3eb2:	cmp	fp, r8
    3eb4:	bcs.n	3f56 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x31a>
    cache = dirCache(i, FsCache::CACHE_FOR_WRITE);
    3eb6:	movs	r2, #1
    3eb8:	mov	r1, fp
    3eba:	mov	r0, r4
    3ebc:	bl	388e <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache || (cache[0] & 0x80)) {
    3ec0:	mov	r6, r0
    3ec2:	cmp	r0, #0
    3ec4:	beq.w	3cae <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    3ec8:	ldrsb.w	r2, [r0]
    3ecc:	cmp	r2, #0
    3ece:	blt.w	3cae <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memset(cache, 0 , 32);
    3ed2:	movs	r2, #32
    3ed4:	movs	r1, #0
    3ed6:	bl	88dc <memset>
    if (i == 0) {
    3eda:	cmp.w	fp, #0
    3ede:	bne.n	3f1e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x2e2>
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
    3ee0:	movs	r3, #133	; 0x85
    3ee2:	strb	r3, [r6, #0]
      m_setCount = freeNeed - 1;
      dirFile->setCount = m_setCount;

      if (FsDateTime::callback) {
    3ee4:	ldr	r3, [pc, #160]	; (3f88 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x34c>)
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    3ee6:	strb.w	sl, [r4, #48]	; 0x30
      dirFile->setCount = m_setCount;
    3eea:	strb.w	sl, [r6, #1]

      if (FsDateTime::callback) {
    3eee:	ldr	r3, [r3, #0]
    3ef0:	cbz	r3, 3f12 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x2d6>
        uint16_t date, time;
        uint8_t ms10;
        FsDateTime::callback(&date, &time, &ms10);
    3ef2:	add.w	r2, sp, #11
    3ef6:	add.w	r1, sp, #14
    3efa:	add	r0, sp, #12
    3efc:	blx	r3
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3efe:	ldrh.w	r3, [sp, #12]
    3f02:	strh	r3, [r6, #10]
    3f04:	ldrh.w	r3, [sp, #14]
    3f08:	strh	r3, [r6, #8]
        setLe16(dirFile->createDate, date);
        setLe16(dirFile->createTime, time);
        dirFile->createTimeMs = ms10;
    3f0a:	ldrb.w	r3, [sp, #11]
    3f0e:	strb	r3, [r6, #20]
    3f10:	b.n	3f52 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
    3f12:	movw	r3, #21537	; 0x5421
    3f16:	strh	r3, [r6, #10]
    3f18:	strh	r3, [r6, #14]
    3f1a:	strh	r3, [r6, #18]
    3f1c:	b.n	3f52 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
         setLe16(dirFile->createTime, FS_DEFAULT_TIME);
         setLe16(dirFile->modifyTime, FS_DEFAULT_TIME);
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
    3f1e:	cmp.w	fp, #1
    3f22:	bne.n	3f3e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x302>
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
      dirStream->flags = EXFAT_FLAG_ALWAYS1;
      m_flags = modeFlags | FILE_FLAG_DIR_DIRTY;
    3f24:	orn	r3, r9, #127	; 0x7f
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
    3f28:	movs	r2, #192	; 0xc0
    3f2a:	strb	r2, [r6, #0]
      dirStream->flags = EXFAT_FLAG_ALWAYS1;
    3f2c:	strb.w	fp, [r6, #1]
      m_flags = modeFlags | FILE_FLAG_DIR_DIRTY;
    3f30:	strb.w	r3, [r4, #51]	; 0x33
      dirStream->nameLength = fname->nameLength;
    3f34:	ldr	r3, [r5, #16]
    3f36:	strb	r3, [r6, #3]
      setLe16(dirStream->nameHash, fname->nameHash);
    3f38:	ldrh	r3, [r5, #20]
    3f3a:	strh	r3, [r6, #4]
    3f3c:	b.n	3f52 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
    } else {
      dirName = reinterpret_cast<DirName_t*>(cache);
      dirName->type = EXFAT_TYPE_NAME;
    3f3e:	movs	r3, #193	; 0xc1
    3f40:	strb	r3, [r6, #0]
    3f42:	add.w	fp, r6, #30
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    3f46:	ldrh	r2, [r5, #12]
    3f48:	cbnz	r2, 3f70 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x334>
    3f4a:	ldr	r1, [r5, #4]
    3f4c:	ldr	r2, [r5, #8]
    3f4e:	cmp	r1, r2
    3f50:	bne.n	3f70 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x334>
    3f52:	adds	r7, #1
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  fname->reset();
  for (uint8_t i = 0; i < freeNeed; i++) {
    3f54:	b.n	3eae <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x272>
        uint16_t u = fname->get16();
        setLe16(dirName->unicode + 2*k, u);
      }
    }
  }
  return sync();
    3f56:	mov	r0, r4
    3f58:	bl	4784 <ExFatFile::sync()>
    3f5c:	b.n	3f80 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
  if (isOpen() || !dir->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }

  switch (oflag & O_ACCMODE) {
    3f5e:	cmp	r3, #0
    3f60:	bne.w	3cae <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    case O_RDONLY:
      modeFlags = FILE_FLAG_READ;
    3f64:	movs	r3, #1
    3f66:	b.n	3c6c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30>
      break;
    case O_WRONLY:
      modeFlags = FILE_FLAG_WRITE;
    3f68:	movs	r3, #2
    3f6a:	b.n	3c6c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30>
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    DBG_FAIL_MACRO;
    goto fail;
  }
#endif  // !READ_ONLY
  return true;
    3f6c:	movs	r0, #1
    3f6e:	b.n	3f80 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
      dirName->type = EXFAT_TYPE_NAME;
      for (size_t k = 0; k < 15; k++) {
        if (fname->atEnd()) {
          break;
        }
        uint16_t u = fname->get16();
    3f70:	mov	r0, r5
    3f72:	bl	3178 <FsName::get16()>
    3f76:	strh.w	r0, [r6, #2]!
      dirStream->nameLength = fname->nameLength;
      setLe16(dirStream->nameHash, fname->nameHash);
    } else {
      dirName = reinterpret_cast<DirName_t*>(cache);
      dirName->type = EXFAT_TYPE_NAME;
      for (size_t k = 0; k < 15; k++) {
    3f7a:	cmp	r6, fp
    3f7c:	bne.n	3f46 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30a>
    3f7e:	b.n	3f52 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
 fail:
  // close file
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
    3f80:	add	sp, #52	; 0x34
    3f82:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3f86:	nop
    3f88:	.word	0x1fff8418

00003f8c <ExFatFile::open(ExFatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
    3f8c:	push	{r4, r5, r6, r7, lr}
    3f8e:	sub	sp, #92	; 0x5c
    3f90:	mov	r7, r3
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    3f92:	movs	r3, #0
    3f94:	strb.w	r3, [sp, #81]	; 0x51
    3f98:	strb.w	r3, [sp, #82]	; 0x52
    3f9c:	strb.w	r3, [sp, #83]	; 0x53
 */
/**
 * \class FsName
 * \brief Handle UTF-8 file names.
 */
class FsName {
    3fa0:	strh.w	r3, [sp, #20]
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    3fa4:	ldrb.w	r3, [r0, #49]	; 0x31
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
    3fa8:	str	r2, [sp, #4]
    3faa:	mov	r5, r0
    3fac:	mov	r4, r1
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    3fae:	cbz	r3, 3fb4 <ExFatFile::open(ExFatFile*, char const*, int)+0x28>
    close();
  }
  return openPrivate(dirFile, &fname, oflag);

 fail:
  return false;
    3fb0:	movs	r0, #0
    3fb2:	b.n	4042 <ExFatFile::open(ExFatFile*, char const*, int)+0xb6>
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    3fb4:	ldrb.w	r3, [r1, #49]	; 0x31
    3fb8:	tst.w	r3, #80	; 0x50
    3fbc:	beq.n	3fb0 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    3fbe:	ldrb	r3, [r2, #0]
    3fc0:	cmp	r3, #47	; 0x2f
    3fc2:	bne.n	3fea <ExFatFile::open(ExFatFile*, char const*, int)+0x5e>
    while (isDirSeparator(*path)) {
    3fc4:	ldr	r3, [sp, #4]
    3fc6:	ldrb	r2, [r3, #0]
    3fc8:	cmp	r2, #47	; 0x2f
    3fca:	bne.n	3fd2 <ExFatFile::open(ExFatFile*, char const*, int)+0x46>
      path++;
    3fcc:	adds	r3, #1
    3fce:	str	r3, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    3fd0:	b.n	3fc4 <ExFatFile::open(ExFatFile*, char const*, int)+0x38>
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    3fd2:	ldr	r1, [r4, #32]
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
    3fd4:	cbnz	r2, 3fde <ExFatFile::open(ExFatFile*, char const*, int)+0x52>
      return openRoot(dirFile->m_vol);
    3fd6:	mov	r0, r5
    3fd8:	bl	391a <ExFatFile::openRoot(ExFatVolume*)>
    3fdc:	b.n	4042 <ExFatFile::open(ExFatFile*, char const*, int)+0xb6>
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    3fde:	add	r0, sp, #32
    3fe0:	bl	391a <ExFatFile::openRoot(ExFatVolume*)>
    3fe4:	cmp	r0, #0
    3fe6:	beq.n	3fb0 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    3fe8:	add	r4, sp, #32
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    3fea:	add	r3, sp, #4
    3fec:	add	r2, sp, #8
    3fee:	ldr	r1, [sp, #4]
    3ff0:	mov	r0, r5
    3ff2:	bl	3940 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    3ff6:	cmp	r0, #0
    3ff8:	beq.n	3fb0 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    3ffa:	ldr	r3, [sp, #4]
    3ffc:	ldrb	r3, [r3, #0]
    3ffe:	cbz	r3, 4036 <ExFatFile::open(ExFatFile*, char const*, int)+0xaa>
      break;
    }
    if (!openPrivate(dirFile, &fname, O_RDONLY)) {
    4000:	movs	r3, #0
    4002:	add	r2, sp, #8
    4004:	mov	r1, r4
    4006:	mov	r0, r5
    4008:	bl	3c3c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    400c:	cmp	r0, #0
    400e:	beq.n	3fb0 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_WARN_MACRO;
      goto fail;
    }
    tmpDir = *this;
    4010:	add	r2, sp, #32
    4012:	mov	r3, r5
    4014:	add.w	lr, r5, #48	; 0x30
    4018:	mov	r4, r2
    401a:	ldr	r0, [r3, #0]
    401c:	ldr	r1, [r3, #4]
    401e:	mov	r6, r2
    4020:	stmia	r6!, {r0, r1}
    4022:	adds	r3, #8
    4024:	cmp	r3, lr
    4026:	mov	r2, r6
    4028:	bne.n	401a <ExFatFile::open(ExFatFile*, char const*, int)+0x8e>
    402a:	ldr	r0, [r3, #0]
    402c:	str	r0, [r6, #0]
    dirFile = &tmpDir;
    close();
    402e:	mov	r0, r5
    4030:	bl	38c6 <ExFatFile::close()>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    4034:	b.n	3fea <ExFatFile::open(ExFatFile*, char const*, int)+0x5e>
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    close();
  }
  return openPrivate(dirFile, &fname, oflag);
    4036:	mov	r3, r7
    4038:	add	r2, sp, #8
    403a:	mov	r1, r4
    403c:	mov	r0, r5
    403e:	bl	3c3c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>

 fail:
  return false;
}
    4042:	add	sp, #92	; 0x5c
    4044:	pop	{r4, r5, r6, r7, pc}

00004046 <ExFatFile::open(ExFatVolume*, char const*, int)>:
bool ExFatFile::open(const char* path, oflag_t oflag) {
  return open(ExFatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
    4046:	cbz	r1, 4050 <ExFatFile::open(ExFatVolume*, char const*, int)+0xa>
    4048:	add.w	r1, r1, #1096	; 0x448
    404c:	b.w	3f8c <ExFatFile::open(ExFatFile*, char const*, int)>
}
    4050:	mov	r0, r1
    4052:	bx	lr

00004054 <ExFatFile::openNext(ExFatFile*, int)>:
    DBG_FAIL_MACRO;
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
    4054:	push	{r4, r5}
    4056:	mov	r3, r2
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    4058:	ldrb.w	r2, [r0, #49]	; 0x31
    405c:	cbnz	r2, 407c <ExFatFile::openNext(ExFatFile*, int)+0x28>
    405e:	ldrb.w	r5, [r1, #49]	; 0x31
    4062:	tst.w	r5, #80	; 0x50
    4066:	beq.n	407c <ExFatFile::openNext(ExFatFile*, int)+0x28>
    4068:	ldrd	r4, r5, [r1]
    406c:	movs	r5, #0
    406e:	and.w	r4, r4, #31
    4072:	orrs	r4, r5
    4074:	bne.n	407c <ExFatFile::openNext(ExFatFile*, int)+0x28>
  }
  return openPrivate(dir, nullptr, oflag);

 fail:
  return false;
}
    4076:	pop	{r4, r5}
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return openPrivate(dir, nullptr, oflag);
    4078:	b.w	3c3c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>

 fail:
  return false;
}
    407c:	movs	r0, #0
    407e:	pop	{r4, r5}
    4080:	bx	lr

00004082 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>:
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"

//------------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
    4082:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4086:	mov	r8, r0
    4088:	mov	sl, r2
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
    408a:	mov	r9, r1
    408c:	cbz	r1, 4092 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x10>
    408e:	subs	r4, r1, #2
    4090:	b.n	4096 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x14>
    4092:	ldr.w	r4, [r0, #1056]	; 0x420
  if (start >= m_clusterCount) {
    4096:	ldr.w	r3, [r8, #1072]	; 0x430
    start = 0;
    409a:	cmp	r4, r3
    409c:	it	cs
    409e:	movcs	r4, #0
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
  uint16_t sectorSize = 1 << m_bytesPerSectorShift;
  size_t i = (start >> 3) & (sectorSize - 1);
  uint8_t* cache;
  uint8_t mask = 1 << (start & 7);
    40a0:	and.w	r7, r4, #7
    40a4:	movs	r3, #1
    40a6:	lsl.w	r7, r3, r7
    start = 0;
  }
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
  uint16_t sectorSize = 1 << m_bytesPerSectorShift;
  size_t i = (start >> 3) & (sectorSize - 1);
    40aa:	ubfx	fp, r4, #3, #9
  uint8_t* cache;
  uint8_t mask = 1 << (start & 7);
    40ae:	uxtb	r7, r7
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
  }
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
    40b0:	mov	r6, r4
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
  }
  uint32_t endAlloc = start;
    40b2:	mov	r5, r4
  bool bitmapModify(uint32_t cluster, uint32_t count, bool value);
  //----------------------------------------------------------------------------
  // Cache functions.
  uint8_t* bitmapCacheGet(uint32_t sector, uint8_t option) {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.get(sector, option);
    40b4:	ldr.w	r1, [r8, #1068]	; 0x42c
    40b8:	movs	r2, #0
    40ba:	add.w	r1, r1, r5, lsr #12
    40be:	mov	r0, r8
    40c0:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
  uint8_t mask = 1 << (start & 7);
  while (true) {
    uint32_t sector = m_clusterHeapStartSector +
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
    40c4:	cbz	r0, 4124 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0xa2>
    40c6:	mov	r3, r7
    40c8:	mov	r1, fp
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
    40ca:	ldrb	r7, [r0, r1]
    40cc:	tst	r7, r3
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
    40ce:	add.w	r5, r5, #1
        if (!(mask & cache[i])) {
    40d2:	bne.n	40f0 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x6e>
          if ((endAlloc - bgnAlloc) == count) {
    40d4:	subs	r2, r5, r6
    40d6:	cmp	r2, sl
    40d8:	bne.n	40f2 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x70>
            if (cluster == 0 && count == 1) {
    40da:	cmp.w	r9, #0
    40de:	bne.n	40ea <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x68>
    40e0:	cmp.w	sl, #1
              // Start at found sector.  bitmapModify may increase this.
              m_bitmapStart = bgnAlloc;
    40e4:	it	eq
    40e6:	streq.w	r6, [r8, #1056]	; 0x420
            }
            return bgnAlloc + 2;
    40ea:	adds	r0, r6, #2
    40ec:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
    40f0:	mov	r6, r5
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    40f2:	cmp	r4, r5
    40f4:	beq.n	4122 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0xa0>
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
    40f6:	ldr.w	r2, [r8, #1072]	; 0x430
    40fa:	cmp	r5, r2
    40fc:	bcs.n	4108 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x86>
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
    40fe:	lsls	r3, r3, #1
    4100:	ands.w	r3, r3, #255	; 0xff
    4104:	bne.n	40cc <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x4a>
    4106:	b.n	4110 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x8e>
        }
        if (endAlloc == start) {
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
          endAlloc = bgnAlloc = 0;
    4108:	movs	r6, #0
          i = sectorSize;
    410a:	mov.w	r1, #512	; 0x200
        }
        if (endAlloc == start) {
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
          endAlloc = bgnAlloc = 0;
    410e:	mov	r5, r6
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    4110:	adds	r1, #1
    4112:	movs	r3, #1
    4114:	cmp.w	r1, #512	; 0x200
          break;
        }
      }
      mask = 1;
    }
    i = 0;
    4118:	mov.w	fp, #0
          endAlloc = bgnAlloc = 0;
          i = sectorSize;
          break;
        }
      }
      mask = 1;
    411c:	mov	r7, r3
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    411e:	bcc.n	40ca <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x48>
    4120:	b.n	40b4 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x32>
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
          return 1;
    4122:	movs	r0, #1
      mask = 1;
    }
    i = 0;
  }
  return 0;
}
    4124:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00004128 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>:
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    4128:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    412c:	mov	r7, r2
    412e:	mov	r6, r0
  uint32_t sector;
  uint32_t start = cluster - 2;
    4130:	subs	r2, r1, #2
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    4132:	ldr.w	r0, [r0, #1072]	; 0x430
    4136:	adds	r1, r2, r7
    4138:	cmp	r1, r0
  }
  return 0;
}
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    413a:	mov	r8, r3
  uint32_t start = cluster - 2;
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    413c:	bhi.n	41c2 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
    413e:	ldr.w	r3, [r6, #1056]	; 0x420
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    4142:	cmp.w	r8, #0
    4146:	beq.n	415c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x34>
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
    4148:	cmp	r2, r3
    414a:	bhi.n	4164 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
    414c:	cmp	r1, r3
    414e:	bls.n	4164 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
      m_bitmapStart = (start + count) < m_clusterCount ? start + count : 0;
    4150:	cmp	r1, r0
    4152:	it	cs
    4154:	movcs	r1, #0
    4156:	str.w	r1, [r6, #1056]	; 0x420
    415a:	b.n	4164 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
    }
  } else {
    if (start < m_bitmapStart) {
    415c:	cmp	r2, r3
      m_bitmapStart = start;
    415e:	it	cc
    4160:	strcc.w	r2, [r6, #1056]	; 0x420
    }
  }
  mask = 1 << (start & 7);
    4164:	and.w	r5, r2, #7
    4168:	movs	r3, #1
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    416a:	ldr.w	r1, [r6, #1068]	; 0x42c
  } else {
    if (start < m_bitmapStart) {
      m_bitmapStart = start;
    }
  }
  mask = 1 << (start & 7);
    416e:	lsl.w	r5, r3, r5
    4172:	uxtb	r5, r5
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    4174:	add.w	r1, r1, r2, lsr #12
  i = (start >> 3) & m_sectorMask;
    4178:	ubfx	r4, r2, #3, #9
    417c:	movs	r2, #1
    417e:	mov	r0, r6
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    4180:	add.w	r9, r1, #1
    4184:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    4188:	cbz	r0, 41c2 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
    418a:	adds	r3, r0, r4
    418c:	mov	r2, r5
    418e:	add.w	r0, r0, #512	; 0x200
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
    4192:	ldrb	r1, [r3, #0]
    4194:	tst	r1, r2
    4196:	ite	ne
    4198:	movne	r4, #1
    419a:	moveq	r4, #0
    419c:	cmp	r4, r8
    419e:	beq.n	41c2 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    41a0:	eors	r1, r2
        if (--count == 0) {
    41a2:	subs	r7, #1
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    41a4:	strb	r1, [r3, #0]
        if (--count == 0) {
    41a6:	beq.n	41c8 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0xa0>
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
    41a8:	lsls	r2, r2, #1
    41aa:	ands.w	r2, r2, #255	; 0xff
    41ae:	bne.n	4192 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x6a>
    41b0:	adds	r3, #1
          return true;
        }
      }
      mask = 1;
    }
    i = 0;
    41b2:	mov	r4, r2
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    41b4:	cmp	r0, r3
    41b6:	mov.w	r2, #1
  mask = 1 << (start & 7);
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
  i = (start >> 3) & m_sectorMask;
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    41ba:	mov	r1, r9
        cache[i] ^= mask;
        if (--count == 0) {
          return true;
        }
      }
      mask = 1;
    41bc:	mov	r5, r2
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    41be:	bne.n	4192 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x6a>
    41c0:	b.n	417c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x54>
    }
    i = 0;
  }

 fail:
  return false;
    41c2:	movs	r0, #0
    41c4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
        if (--count == 0) {
          return true;
    41c8:	movs	r0, #1
    i = 0;
  }

 fail:
  return false;
}
    41ca:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000041ce <ExFatPartition::dirCache(DirPos_t*, unsigned char)>:
    n++;
  } while (status);
  return n;
}
//------------------------------------------------------------------------------
uint8_t* ExFatPartition::dirCache(DirPos_t* pos, uint8_t options) {
    41ce:	push	{r3, r4, r5, lr}
    41d0:	mov	r5, r1
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    41d2:	ldr.w	r1, [r0, #1080]	; 0x438
    41d6:	ldr	r3, [r5, #4]
    41d8:	ands	r1, r3
    41da:	ldr	r3, [r5, #0]
    41dc:	subs	r4, r3, #2
    41de:	ldrb.w	r3, [r0, #1093]	; 0x445
    41e2:	lsl.w	r3, r4, r3
    41e6:	add.w	r3, r3, r1, lsr #9
    41ea:	ldr.w	r1, [r0, #1068]	; 0x42c
    41ee:	add.w	r0, r0, #528	; 0x210
    41f2:	add	r1, r3
    41f4:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
  uint32_t sector = clusterStartSector(pos->cluster);
  sector += (m_clusterMask & pos->position) >> m_bytesPerSectorShift;
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
    41f8:	cbz	r0, 4202 <ExFatPartition::dirCache(DirPos_t*, unsigned char)+0x34>
    41fa:	ldr	r3, [r5, #4]
    41fc:	ubfx	r3, r3, #0, #9
    4200:	add	r0, r3
}
    4202:	pop	{r3, r4, r5, pc}

00004204 <ExFatPartition::fatGet(unsigned long, unsigned long*)>:
  }
  return 1;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    4204:	push	{r3, r4, r5, lr}
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    4206:	ldr.w	r3, [r0, #1072]	; 0x430
    420a:	adds	r3, #1
    420c:	cmp	r3, r1
  }
  return 1;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    420e:	mov	r4, r1
    4210:	mov	r5, r2
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    4212:	bcs.n	421a <ExFatPartition::fatGet(unsigned long, unsigned long*)+0x16>
    DBG_FAIL_MACRO;
    return -1;
    4214:	mov.w	r0, #4294967295
    4218:	pop	{r3, r4, r5, pc}
    421a:	ldr.w	r1, [r0, #1060]	; 0x424
    421e:	movs	r2, #0
    4220:	add.w	r1, r1, r4, lsr #7
    4224:	add.w	r0, r0, #528	; 0x210
    4228:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));

  cache = dataCacheGet(sector, FsCache::CACHE_FOR_READ);
  if (!cache) {
    422c:	cmp	r0, #0
    422e:	beq.n	4214 <ExFatPartition::fatGet(unsigned long, unsigned long*)+0x10>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    4230:	lsls	r4, r4, #2
    4232:	ubfx	r4, r4, #0, #9
    4236:	ldr	r0, [r0, r4]
    return -1;
  }
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));
  *value = next;
    4238:	str	r0, [r5, #0]
  return next == EXFAT_EOC ? 0 : 1;
    423a:	adds	r0, #1
    423c:	it	ne
    423e:	movne	r0, #1
}
    4240:	pop	{r3, r4, r5, pc}

00004242 <ExFatPartition::chainSize(unsigned long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
    4242:	push	{r0, r1, r4, r5, r6, lr}
    4244:	add	r5, sp, #8
    4246:	mov	r6, r0
    4248:	str.w	r1, [r5, #-4]!
  uint32_t n = 0;
    424c:	movs	r4, #0
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    424e:	mov	r2, r5
    4250:	ldr	r1, [sp, #4]
    4252:	mov	r0, r6
    4254:	bl	4204 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    if (status < 0) return 0;
    4258:	cmp	r0, #0
    425a:	blt.n	4266 <ExFatPartition::chainSize(unsigned long)+0x24>
    n++;
    425c:	add.w	r4, r4, #1
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    4260:	bne.n	424e <ExFatPartition::chainSize(unsigned long)+0xc>
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    n++;
    4262:	mov	r0, r4
    4264:	b.n	4268 <ExFatPartition::chainSize(unsigned long)+0x26>
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    4266:	movs	r0, #0
    n++;
  } while (status);
  return n;
}
    4268:	add	sp, #8
    426a:	pop	{r4, r5, r6, pc}

0000426c <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>:
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    426c:	push	{r4, r5, r6, lr}
    426e:	mov	r5, r1
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    4270:	ldr.w	r4, [r0, #1080]	; 0x438
    4274:	ldr	r1, [r1, #4]
    4276:	ands	r4, r1
    4278:	adds	r3, r4, r2
  pos->position += offset;
    427a:	add	r2, r1
    427c:	str	r2, [r5, #4]
  tmp >>= bytesPerClusterShift();
    427e:	ldrb.w	r4, [r0, #1093]	; 0x445
    4282:	adds	r4, #9
    4284:	uxtb	r4, r4
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    4286:	mov	r6, r0
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
    4288:	lsr.w	r4, r3, r4
  while (tmp--) {
    428c:	cbz	r4, 42ac <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x40>
    if (pos->isContiguous) {
    428e:	ldrb	r3, [r5, #8]
    4290:	cbz	r3, 429c <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x30>
      pos->cluster++;
    4292:	ldr	r3, [r5, #0]
    4294:	adds	r3, #1
    4296:	str	r3, [r5, #0]
    4298:	subs	r4, #1
    429a:	b.n	428c <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x20>
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    429c:	mov	r2, r5
    429e:	ldr	r1, [r5, #0]
    42a0:	mov	r0, r6
    42a2:	bl	4204 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
      if (status != 1) {
    42a6:	cmp	r0, #1
    42a8:	beq.n	4298 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x2c>
    42aa:	pop	{r4, r5, r6, pc}
        return status;
      }
    }
  }
  return 1;
    42ac:	movs	r0, #1
}
    42ae:	pop	{r4, r5, r6, pc}

000042b0 <ExFatPartition::fatPut(unsigned long, unsigned long)>:
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    42b0:	cmp	r1, #1
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));
  *value = next;
  return next == EXFAT_EOC ? 0 : 1;
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
    42b2:	push	{r3, r4, r5, lr}
    42b4:	mov	r4, r1
    42b6:	mov	r5, r2
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    42b8:	bhi.n	42be <ExFatPartition::fatPut(unsigned long, unsigned long)+0xe>
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;

 fail:
  return false;
    42ba:	movs	r0, #0
    42bc:	pop	{r3, r4, r5, pc}
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    42be:	ldr.w	r3, [r0, #1072]	; 0x430
    42c2:	adds	r3, #1
    42c4:	cmp	r1, r3
    42c6:	bhi.n	42ba <ExFatPartition::fatPut(unsigned long, unsigned long)+0xa>
    42c8:	ldr.w	r1, [r0, #1060]	; 0x424
    42cc:	movs	r2, #1
    42ce:	add.w	r1, r1, r4, lsr #7
    42d2:	add.w	r0, r0, #528	; 0x210
    42d6:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
  cache = dataCacheGet(sector, FsCache::CACHE_FOR_WRITE);
  if (!cache) {
    42da:	cmp	r0, #0
    42dc:	beq.n	42ba <ExFatPartition::fatPut(unsigned long, unsigned long)+0xa>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    42de:	lsls	r4, r4, #2
    42e0:	ubfx	r4, r4, #0, #9
    42e4:	str	r5, [r0, r4]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;
    42e6:	movs	r0, #1

 fail:
  return false;
}
    42e8:	pop	{r3, r4, r5, pc}

000042ea <ExFatPartition::freeChain(unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
    42ea:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    42ee:	mov	r7, r0
    42f0:	mov	r4, r1
  uint32_t next;
  uint32_t start = cluster;
    42f2:	mov	r6, r1
  int8_t status;
  do {
    status = fatGet(cluster, &next);
    42f4:	add	r2, sp, #4
    42f6:	mov	r1, r4
    42f8:	mov	r0, r7
    42fa:	bl	4204 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    if (status < 0) {
    42fe:	subs.w	r8, r0, #0
    4302:	bge.n	4308 <ExFatPartition::freeChain(unsigned long)+0x1e>
  } while (status);

  return true;

 fail:
  return false;
    4304:	movs	r5, #0
    4306:	b.n	4340 <ExFatPartition::freeChain(unsigned long)+0x56>
    status = fatGet(cluster, &next);
    if (status < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!fatPut(cluster, 0)) {
    4308:	movs	r2, #0
    430a:	mov	r1, r4
    430c:	mov	r0, r7
    430e:	bl	42b0 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4312:	mov	r5, r0
    4314:	cmp	r0, #0
    4316:	beq.n	4304 <ExFatPartition::freeChain(unsigned long)+0x1a>
    4318:	adds	r2, r4, #1
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (status == 0 || (cluster + 1) != next) {
    431a:	cmp.w	r8, #0
    431e:	beq.n	4326 <ExFatPartition::freeChain(unsigned long)+0x3c>
    4320:	ldr	r3, [sp, #4]
    4322:	cmp	r2, r3
    4324:	beq.n	4338 <ExFatPartition::freeChain(unsigned long)+0x4e>
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    4326:	movs	r3, #0
    4328:	subs	r2, r2, r6
    432a:	mov	r1, r6
    432c:	mov	r0, r7
    432e:	bl	4128 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4332:	cmp	r0, #0
    4334:	beq.n	4304 <ExFatPartition::freeChain(unsigned long)+0x1a>
        DBG_FAIL_MACRO;
        goto fail;
      }
      start = next;
    4336:	ldr	r6, [sp, #4]
    }
    cluster = next;
    4338:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  uint32_t start = cluster;
  int8_t status;
  do {
    433a:	cmp.w	r8, #0
    433e:	bne.n	42f4 <ExFatPartition::freeChain(unsigned long)+0xa>

  return true;

 fail:
  return false;
}
    4340:	mov	r0, r5
    4342:	add	sp, #8
    4344:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00004348 <ExFatPartition::freeClusterCount()>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    4348:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t nc = 0;
  uint32_t sector = m_clusterHeapStartSector;
    434c:	ldr.w	r1, [r0, #1068]	; 0x42c
  uint32_t usedCount = 0;
    4350:	movs	r4, #0

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    4352:	mov	r6, r0
  uint32_t nc = 0;
    4354:	mov	r5, r4
    4356:	add.w	r7, r0, #528	; 0x210
    435a:	movs	r2, #0
    435c:	mov	r0, r7
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
  uint8_t* cache;

  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    435e:	add.w	r8, r1, #1
    4362:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    4366:	cbz	r0, 43a8 <ExFatPartition::freeClusterCount()+0x60>
    4368:	add.w	lr, r0, #4294967295
    436c:	add.w	ip, r5, #4096	; 0x1000
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
    4370:	ldrb.w	r1, [lr, #1]!
    4374:	cmp	r1, #255	; 0xff
    4376:	bne.n	437c <ExFatPartition::freeClusterCount()+0x34>
        usedCount+= 8;
    4378:	adds	r4, #8
    437a:	b.n	4390 <ExFatPartition::freeClusterCount()+0x48>
      } else if (cache[i]) {
    437c:	cbz	r1, 4390 <ExFatPartition::freeClusterCount()+0x48>
    437e:	movs	r2, #8
    4380:	movs	r3, #1
        for (uint8_t mask = 1; mask ; mask <<=1) {
          if ((mask & cache[i])) {
    4382:	tst	r1, r3
            usedCount++;
    4384:	it	ne
    4386:	addne	r4, #1
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
      } else if (cache[i]) {
        for (uint8_t mask = 1; mask ; mask <<=1) {
    4388:	lsls	r3, r3, #1
    438a:	subs	r2, #1
    438c:	uxtb	r3, r3
    438e:	bne.n	4382 <ExFatPartition::freeClusterCount()+0x3a>
            usedCount++;
          }
        }
      }
      nc += 8;
      if (nc >= m_clusterCount) {
    4390:	ldr.w	r0, [r6, #1072]	; 0x430
          if ((mask & cache[i])) {
            usedCount++;
          }
        }
      }
      nc += 8;
    4394:	adds	r5, #8
      if (nc >= m_clusterCount) {
    4396:	cmp	r5, r0
    4398:	bcc.n	43a0 <ExFatPartition::freeClusterCount()+0x58>
        return m_clusterCount - usedCount;
    439a:	subs	r0, r0, r4
    439c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
    43a0:	cmp	r5, ip
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
  uint8_t* cache;

  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    43a2:	mov	r1, r8
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
    43a4:	bne.n	4370 <ExFatPartition::freeClusterCount()+0x28>
    43a6:	b.n	435a <ExFatPartition::freeClusterCount()+0x12>
      if (nc >= m_clusterCount) {
        return m_clusterCount - usedCount;
      }
    }
  }
}
    43a8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000043ac <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>:
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    43ac:	push	{r4, r5, r6, r7, lr}
    43ae:	mov	r4, r0
    43b0:	sub	sp, #28
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif
  BpbExFat_t* bpb;

  m_fatType = 0;
    43b2:	movs	r5, #0
      }
    }
  }
}
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    43b4:	mov	r0, r1
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    43b6:	mov.w	r3, #4294967295
    43ba:	mov	r1, r2
    43bc:	str	r3, [r4, #12]
    43be:	str.w	r3, [r4, #540]	; 0x21c
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif
  BpbExFat_t* bpb;

  m_fatType = 0;
    43c2:	strb.w	r5, [r4, #1092]	; 0x444
  m_blockDev = dev;
    43c6:	str.w	r0, [r4, #1088]	; 0x440
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    43ca:	str	r0, [r4, #4]
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    43cc:	strb	r5, [r4, #0]
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    43ce:	str.w	r0, [r4, #532]	; 0x214
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    43d2:	strb.w	r5, [r4, #528]	; 0x210
  cacheInit(m_blockDev);


  #if SUPPORT_GPT_AND_EXTENDED_PATITIONS 
  cache = cacheClear(); // get buffer to use. 
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part,cache, &firstLBA);
    43d6:	str	r5, [sp, #8]
    43d8:	str	r5, [sp, #4]
    43da:	str	r5, [sp, #0]
    43dc:	add	r3, sp, #20
    43de:	add.w	r2, r4, #544	; 0x220
    43e2:	bl	2dfc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    43e6:	tst.w	r0, #251	; 0xfb
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    43ea:	add.w	r7, r4, #528	; 0x210
    43ee:	bne.n	43f4 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x48>
  bitmapFind(0, 1);
  m_fatType = FAT_TYPE_EXFAT;
  return true;

 fail:
  return false;
    43f0:	movs	r0, #0
    43f2:	b.n	446e <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xc2>
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part,cache, &firstLBA);
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    DBG_FAIL_MACRO;
    goto fail;    
  }
  volStart = firstLBA;
    43f4:	ldr	r6, [sp, #20]
    43f6:	mov	r2, r5
    43f8:	mov	r1, r6
    43fa:	mov	r0, r7
    43fc:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
  }
  volStart = getLe32(mp->relativeSectors);
  #endif

  cache = dataCacheGet(volStart, FsCache::CACHE_FOR_READ);
  if (!cache) {
    4400:	mov	r5, r0
    4402:	cmp	r0, #0
    4404:	beq.n	43f0 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  pbs = reinterpret_cast<pbs_t*>(cache);
  if (strncmp(pbs->oemName, "EXFAT", 5)) {
    4406:	ldr	r1, [pc, #108]	; (4474 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xc8>)
    4408:	movs	r2, #5
    440a:	adds	r0, #3
    440c:	bl	b81c <strncmp>
    4410:	mov	r1, r0
    4412:	cmp	r0, #0
    4414:	bne.n	43f0 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  bpb = reinterpret_cast<BpbExFat_t*>(pbs->bpb);
  if (bpb->bytesPerSectorShift != m_bytesPerSectorShift) {
    4416:	ldrb.w	r3, [r5, #108]	; 0x6c
    441a:	cmp	r3, #9
    441c:	bne.n	43f0 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_fatStartSector = volStart + getLe32(bpb->fatOffset);
    441e:	ldr	r3, [r5, #80]	; 0x50
    4420:	add	r3, r6
    4422:	str.w	r3, [r4, #1060]	; 0x424
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    4426:	ldr	r3, [r5, #84]	; 0x54
  m_fatLength = getLe32(bpb->fatLength);
    4428:	str.w	r3, [r4, #1064]	; 0x428
  m_clusterHeapStartSector = volStart + getLe32(bpb->clusterHeapOffset);
    442c:	ldr	r3, [r5, #88]	; 0x58
    442e:	add	r6, r3
    4430:	str.w	r6, [r4, #1068]	; 0x42c
    4434:	ldr	r3, [r5, #92]	; 0x5c
  m_clusterCount = getLe32(bpb->clusterCount);
    4436:	str.w	r3, [r4, #1072]	; 0x430
    443a:	ldr	r3, [r5, #96]	; 0x60
  m_rootDirectoryCluster = getLe32(bpb->rootDirectoryCluster);
    443c:	str.w	r3, [r4, #1076]	; 0x434
  m_sectorsPerClusterShift = bpb->sectorsPerClusterShift;
    4440:	ldrb.w	r3, [r5, #109]	; 0x6d
    4444:	strb.w	r3, [r4, #1093]	; 0x445
  m_bytesPerCluster = 1UL << (m_bytesPerSectorShift + m_sectorsPerClusterShift);
    4448:	movs	r5, #1
    444a:	adds	r3, #9
    444c:	lsl.w	r3, r5, r3
    4450:	str.w	r3, [r4, #1084]	; 0x43c
  m_clusterMask = m_bytesPerCluster - 1;
    4454:	subs	r3, #1
    4456:	str.w	r3, [r4, #1080]	; 0x438
  // Set m_bitmapStart to first free cluster.
  m_bitmapStart = 0;
    445a:	str.w	r0, [r4, #1056]	; 0x420
  bitmapFind(0, 1);
    445e:	mov	r2, r5
    4460:	mov	r0, r4
    4462:	bl	4082 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  m_fatType = FAT_TYPE_EXFAT;
    4466:	movs	r3, #64	; 0x40
    4468:	strb.w	r3, [r4, #1092]	; 0x444
  return true;
    446c:	mov	r0, r5

 fail:
  return false;
}
    446e:	add	sp, #28
    4470:	pop	{r4, r5, r6, r7, pc}
    4472:	nop
    4474:	.word	0x00012553

00004478 <ExFatPartition::rootLength()>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::rootLength() {
    4478:	push	{r4, lr}
    447a:	mov	r4, r0
  uint32_t nc = chainSize(m_rootDirectoryCluster);
    447c:	ldr.w	r1, [r0, #1076]	; 0x434
    4480:	bl	4242 <ExFatPartition::chainSize(unsigned long)>
  return nc << bytesPerClusterShift();
    4484:	ldrb.w	r3, [r4, #1093]	; 0x445
    4488:	adds	r3, #9
    448a:	uxtb	r3, r3
}
    448c:	lsls	r0, r3
    448e:	pop	{r4, pc}

00004490 <ExFatVolume::chdir(char const*)>:
#define DBG_FILE "ExFatVolume.cpp"
#include "../common/DebugMacros.h"
#include "ExFatVolume.h"
ExFatVolume* ExFatVolume::m_cwv = nullptr;
//-----------------------------------------------------------------------------
bool ExFatVolume::chdir(const char* path) {
    4490:	push	{r4, r5, r6, lr}
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend ExFatFile;
  static ExFatVolume* cwv() {return m_cwv;}
  ExFatFile* vwd() {return &m_vwd;}
    4492:	add.w	r4, r0, #1096	; 0x448
    4496:	sub	sp, #56	; 0x38
    4498:	movs	r3, #0
  ExFatFile dir;
  if (!dir.open(vwd(), path, O_RDONLY)) {
    449a:	mov	r2, r1
    449c:	mov	r0, sp
    449e:	mov	r1, r4
    44a0:	strb.w	r3, [sp, #49]	; 0x31
    44a4:	strb.w	r3, [sp, #50]	; 0x32
    44a8:	strb.w	r3, [sp, #51]	; 0x33
    44ac:	bl	3f8c <ExFatFile::open(ExFatFile*, char const*, int)>
    44b0:	mov	r5, r0
    44b2:	cbz	r0, 44de <ExFatVolume::chdir(char const*)+0x4e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!dir.isDir()) {
    44b4:	ldrb.w	r3, [sp, #49]	; 0x31
    44b8:	ands.w	r3, r3, #80	; 0x50
    44bc:	beq.n	44dc <ExFatVolume::chdir(char const*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_vwd = dir;
    44be:	mov	r2, sp
    44c0:	mov	r3, r4
    44c2:	add	r6, sp, #48	; 0x30
    44c4:	mov	r4, r2
    44c6:	ldmia	r4!, {r0, r1}
    44c8:	cmp	r4, r6
    44ca:	str	r0, [r3, #0]
    44cc:	str	r1, [r3, #4]
    44ce:	mov	r2, r4
    44d0:	add.w	r3, r3, #8
    44d4:	bne.n	44c4 <ExFatVolume::chdir(char const*)+0x34>
    44d6:	ldr	r0, [r4, #0]
    44d8:	str	r0, [r3, #0]
  return true;
    44da:	b.n	44de <ExFatVolume::chdir(char const*)+0x4e>

 fail:
  return false;
    44dc:	mov	r5, r3
}
    44de:	mov	r0, r5
    44e0:	add	sp, #56	; 0x38
    44e2:	pop	{r4, r5, r6, pc}

000044e4 <exFatDirChecksum(unsigned char const*, unsigned short)>:
  return false;
}
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
    44e4:	push	{r4, lr}
  bool skip = data[0] == EXFAT_TYPE_FILE;
    44e6:	ldrb	r4, [r0, #0]
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    44e8:	movs	r3, #0
    44ea:	lsls	r2, r1, #15
    44ec:	orr.w	r1, r2, r1, lsr #1
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    44f0:	ldrb	r2, [r0, r3]
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    44f2:	cmp	r3, #1
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    44f4:	uxtah	r1, r2, r1
    44f8:	uxth	r1, r1
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    44fa:	bne.n	4506 <exFatDirChecksum(unsigned char const*, unsigned short)+0x22>
    44fc:	cmp	r4, #133	; 0x85
    44fe:	ite	ne
    4500:	movne	r2, #1
    4502:	moveq	r2, #3
    4504:	b.n	4508 <exFatDirChecksum(unsigned char const*, unsigned short)+0x24>
    4506:	movs	r2, #1
    4508:	add	r3, r2
    450a:	cmp	r3, #31
    450c:	bls.n	44ea <exFatDirChecksum(unsigned char const*, unsigned short)+0x6>
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
  }
  return checksum;
}
    450e:	mov	r0, r1
    4510:	pop	{r4, pc}

00004512 <ExFatPartition::cacheSync()>:
#if USE_EXFAT_BITMAP_CACHE
    m_bitmapCache.init(dev);
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
    4512:	push	{r4, lr}
    4514:	mov	r4, r0
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    4516:	bl	303a <FsCache::sync()>
    451a:	cbz	r0, 4534 <ExFatPartition::cacheSync()+0x22>
    451c:	add.w	r0, r4, #528	; 0x210
    4520:	bl	303a <FsCache::sync()>
    4524:	cbz	r0, 4534 <ExFatPartition::cacheSync()+0x22>
    4526:	ldr.w	r0, [r4, #1088]	; 0x440
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    452a:	ldr	r3, [r0, #0]
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
#else  // USE_EXFAT_BITMAP_CACHE
    return m_dataCache.sync() && syncDevice();
#endif  // USE_EXFAT_BITMAP_CACHE
  }
    452c:	ldmia.w	sp!, {r4, lr}
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    4530:	ldr	r3, [r3, #28]
    4532:	bx	r3
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
#else  // USE_EXFAT_BITMAP_CACHE
    return m_dataCache.sync() && syncDevice();
#endif  // USE_EXFAT_BITMAP_CACHE
  }
    4534:	movs	r0, #0
    4536:	pop	{r4, pc}

00004538 <ExFatFile::addCluster()>:
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
    4538:	push	{r3, r4, r5, r6, r7, lr}
    453a:	mov	r4, r0
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    453c:	ldr	r0, [r0, #32]
    453e:	ldr	r1, [r4, #24]
    4540:	cbz	r1, 4544 <ExFatFile::addCluster()+0xc>
    4542:	adds	r1, #1
    4544:	movs	r2, #1
    4546:	bl	4082 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  if (find < 2) {
    454a:	cmp	r0, #1
  }
  return checksum;
}
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    454c:	mov	r5, r0
  if (find < 2) {
    454e:	bhi.n	4554 <ExFatFile::addCluster()+0x1c>
 done:
  m_curCluster = find;
  return true;

 fail:
  return false;
    4550:	movs	r6, #0
    4552:	b.n	45c6 <ExFatFile::addCluster()+0x8e>
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
  if (find < 2) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    4554:	movs	r3, #1
    4556:	mov	r1, r0
    4558:	mov	r2, r3
    455a:	ldr	r0, [r4, #32]
    455c:	bl	4128 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4560:	mov	r6, r0
    4562:	cmp	r0, #0
    4564:	beq.n	4550 <ExFatFile::addCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    4566:	ldr	r2, [r4, #24]
    m_flags |= FILE_FLAG_CONTIGUOUS;
    4568:	ldrb.w	r3, [r4, #51]	; 0x33
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    456c:	cbnz	r2, 4578 <ExFatFile::addCluster()+0x40>
    m_flags |= FILE_FLAG_CONTIGUOUS;
    456e:	orr.w	r3, r3, #64	; 0x40
    4572:	strb.w	r3, [r4, #51]	; 0x33
    goto done;
    4576:	b.n	45c4 <ExFatFile::addCluster()+0x8c>
  }
  if (isContiguous()) {
    4578:	lsls	r1, r3, #25
    457a:	bpl.n	45a4 <ExFatFile::addCluster()+0x6c>
    if (find == (m_curCluster + 1)) {
    457c:	adds	r2, #1
    457e:	cmp	r5, r2
    4580:	beq.n	45c4 <ExFatFile::addCluster()+0x8c>
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    4582:	bic.w	r3, r3, #64	; 0x40

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    4586:	ldr	r1, [r4, #28]
  if (isContiguous()) {
    if (find == (m_curCluster + 1)) {
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    4588:	strb.w	r3, [r4, #51]	; 0x33

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    458c:	ldr	r3, [r4, #24]
    458e:	cmp	r1, r3
    4590:	bcs.n	45a4 <ExFatFile::addCluster()+0x6c>
      if (!m_vol->fatPut(c, c + 1)) {
    4592:	adds	r7, r1, #1
    4594:	mov	r2, r7
    4596:	ldr	r0, [r4, #32]
    4598:	bl	42b0 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    459c:	cmp	r0, #0
    459e:	beq.n	4550 <ExFatFile::addCluster()+0x18>
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    45a0:	mov	r1, r7
    45a2:	b.n	458c <ExFatFile::addCluster()+0x54>
        goto fail;
      }
    }
  }
  // New cluster is EOC.
  if (!m_vol->fatPut(find, EXFAT_EOC)) {
    45a4:	mov.w	r2, #4294967295
    45a8:	mov	r1, r5
    45aa:	ldr	r0, [r4, #32]
    45ac:	bl	42b0 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    45b0:	cmp	r0, #0
    45b2:	beq.n	4550 <ExFatFile::addCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Connect new cluster to existing chain.
  if (m_curCluster) {
    45b4:	ldr	r1, [r4, #24]
    45b6:	cbz	r1, 45c4 <ExFatFile::addCluster()+0x8c>
    if (!m_vol->fatPut(m_curCluster, find)) {
    45b8:	mov	r2, r5
    45ba:	ldr	r0, [r4, #32]
    45bc:	bl	42b0 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    45c0:	cmp	r0, #0
    45c2:	beq.n	4550 <ExFatFile::addCluster()+0x18>
      goto fail;
    }
  }

 done:
  m_curCluster = find;
    45c4:	str	r5, [r4, #24]
  return true;

 fail:
  return false;
}
    45c6:	mov	r0, r6
    45c8:	pop	{r3, r4, r5, r6, r7, pc}

000045ca <ExFatFile::remove()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    45ca:	push	{r4, r5, r6, lr}
    45cc:	ldrb.w	r3, [r0, #51]	; 0x33
  uint8_t* cache;
  if (!isWritable()) {
    45d0:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    45d2:	mov	r4, r0
  uint8_t* cache;
  if (!isWritable()) {
    45d4:	bmi.n	45da <ExFatFile::remove()+0x10>

  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
    45d6:	movs	r0, #0
    45d8:	pop	{r4, r5, r6, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    45da:	ldr	r5, [r0, #28]
    45dc:	cbnz	r5, 45e2 <ExFatFile::remove()+0x18>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    45de:	movs	r5, #0
    45e0:	b.n	4634 <ExFatFile::remove()+0x6a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    if (isContiguous()) {
    45e2:	lsls	r3, r3, #25
    45e4:	bpl.n	4610 <ExFatFile::remove()+0x46>
      uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    45e6:	ldr	r6, [r0, #32]
      if (!m_vol->bitmapModify(m_firstCluster, nc, 0)) {
    45e8:	ldrd	r0, r1, [r0, #8]
    45ec:	ldrb.w	r2, [r6, #1093]	; 0x445
    45f0:	adds.w	r0, r0, #4294967295
    45f4:	add.w	r2, r2, #9
    45f8:	uxtb	r2, r2
    45fa:	adc.w	r1, r1, #4294967295
    45fe:	bl	9ce8 <__aeabi_llsr>
    4602:	movs	r3, #0
    4604:	adds	r2, r0, #1
    4606:	mov	r1, r5
    4608:	mov	r0, r6
    460a:	bl	4128 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    460e:	b.n	4618 <ExFatFile::remove()+0x4e>
        DBG_FAIL_MACRO;
        goto fail;
      }
    } else {
      if (!m_vol->freeChain(m_firstCluster)) {
    4610:	mov	r1, r5
    4612:	ldr	r0, [r0, #32]
    4614:	bl	42ea <ExFatPartition::freeChain(unsigned long)>
    4618:	cmp	r0, #0
    461a:	bne.n	45de <ExFatFile::remove()+0x14>
    461c:	b.n	45d6 <ExFatFile::remove()+0xc>
      }
    }
  }

  for (uint8_t is = 0; is <= m_setCount; is++) {
    cache = dirCache(is, FsCache::CACHE_FOR_WRITE);
    461e:	movs	r2, #1
    4620:	mov	r0, r4
    4622:	bl	388e <ExFatFile::dirCache(unsigned char, unsigned char)>
    4626:	adds	r5, #1
    if (!cache) {
    4628:	cmp	r0, #0
    462a:	beq.n	45d6 <ExFatFile::remove()+0xc>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
    462c:	ldrb	r3, [r0, #0]
    462e:	and.w	r3, r3, #127	; 0x7f
    4632:	strb	r3, [r0, #0]
        goto fail;
      }
    }
  }

  for (uint8_t is = 0; is <= m_setCount; is++) {
    4634:	ldrb.w	r3, [r4, #48]	; 0x30
    4638:	uxtb	r1, r5
    463a:	cmp	r3, r1
    463c:	bcs.n	461e <ExFatFile::remove()+0x54>
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
  }
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    463e:	movs	r3, #0
    4640:	strb.w	r3, [r4, #49]	; 0x31
  m_flags = 0;
    4644:	strb.w	r3, [r4, #51]	; 0x33

  // Write entry to device.
  return m_vol->cacheSync();
    4648:	ldr	r0, [r4, #32]
    464a:	bl	4512 <ExFatPartition::cacheSync()>

 fail:
  return false;
}
    464e:	pop	{r4, r5, r6, pc}

00004650 <ExFatFile::rmdir()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    4650:	push	{r4, lr}
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    4652:	ldrb.w	r3, [r0, #49]	; 0x31
    4656:	lsls	r1, r3, #27

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    4658:	sub	sp, #32
    465a:	mov	r4, r0
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    465c:	bmi.n	4662 <ExFatFile::rmdir()+0x12>
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();

 fail:
  return false;
    465e:	movs	r0, #0
    4660:	b.n	469e <ExFatFile::rmdir()+0x4e>
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    4662:	movs	r2, #0
    4664:	movs	r3, #0
    4666:	bl	3b6c <ExFatFile::seekSet(unsigned long long)>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    n = read(dir, 32);
    466a:	movs	r2, #32
    466c:	mov	r1, sp
    466e:	mov	r0, r4
    4670:	bl	39bc <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    4674:	cbz	r0, 4686 <ExFatFile::rmdir()+0x36>
      break;
    }
    if (n != 32 || dir[0] & 0X80) {
    4676:	cmp	r0, #32
    4678:	bne.n	465e <ExFatFile::rmdir()+0xe>
    467a:	ldrb.w	r3, [sp]
    467e:	lsls	r2, r3, #24
    4680:	bmi.n	465e <ExFatFile::rmdir()+0xe>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (dir[0] == 0) {
    4682:	cmp	r3, #0
    4684:	bne.n	466a <ExFatFile::rmdir()+0x1a>
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    4686:	movs	r3, #8
    4688:	strb.w	r3, [r4, #49]	; 0x31
  m_flags |= FILE_FLAG_WRITE;
    468c:	ldrb.w	r3, [r4, #51]	; 0x33
    4690:	orr.w	r3, r3, #2
    4694:	strb.w	r3, [r4, #51]	; 0x33
  return remove();
    4698:	mov	r0, r4
    469a:	bl	45ca <ExFatFile::remove()>

 fail:
  return false;
}
    469e:	add	sp, #32
    46a0:	pop	{r4, pc}
    46a2:	Address 0x000046a2 is out of bounds.


000046a4 <ExFatFile::syncDir()>:
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    46a4:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    46a8:	movs	r6, #0
    }
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    46aa:	ldr.w	r8, [pc, #212]	; 4780 <ExFatFile::syncDir()+0xdc>
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    46ae:	mov	r5, r0
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
    46b0:	mov	r7, r6

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    46b2:	ldrb.w	r3, [r5, #48]	; 0x30
    46b6:	uxtb	r1, r6
    46b8:	cmp	r3, r1
    46ba:	bcc.n	4752 <ExFatFile::syncDir()+0xae>
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    46bc:	movs	r2, #0
    46be:	mov	r0, r5
    46c0:	bl	388e <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache) {
    46c4:	mov	r4, r0
    46c6:	cmp	r0, #0
    46c8:	beq.n	476a <ExFatFile::syncDir()+0xc6>
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    46ca:	ldrb	r3, [r0, #0]
    46cc:	cmp	r3, #192	; 0xc0
    46ce:	beq.n	470c <ExFatFile::syncDir()+0x68>
    46d0:	cmp	r3, #193	; 0xc1
    46d2:	beq.n	4744 <ExFatFile::syncDir()+0xa0>
    46d4:	cmp	r3, #133	; 0x85
    46d6:	bne.n	476a <ExFatFile::syncDir()+0xc6>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    46d8:	ldrb.w	r3, [r5, #49]	; 0x31
    46dc:	and.w	r3, r3, #55	; 0x37
    46e0:	strh	r3, [r0, #4]
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    46e2:	ldr.w	r3, [r8]
    46e6:	cbz	r3, 4736 <ExFatFile::syncDir()+0x92>
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
    46e8:	add.w	r2, sp, #3
    46ec:	add.w	r1, sp, #6
    46f0:	add	r0, sp, #4
    46f2:	blx	r3
          df->modifyTimeMs = ms10;
    46f4:	ldrb.w	r3, [sp, #3]
          setLe16(df->modifyTime, time);
    46f8:	ldrh.w	r2, [sp, #6]
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
          df->modifyTimeMs = ms10;
    46fc:	strb	r3, [r4, #21]
          setLe16(df->modifyTime, time);
          setLe16(df->modifyDate, date);
    46fe:	ldrh.w	r3, [sp, #4]
    4702:	strh	r2, [r4, #12]
    4704:	strh	r3, [r4, #14]
    4706:	strh	r2, [r4, #16]
    4708:	strh	r3, [r4, #18]
    470a:	b.n	4736 <ExFatFile::syncDir()+0x92>
        m_vol->dataCacheDirty();
        break;

      case EXFAT_TYPE_STREAM:
        ds = reinterpret_cast<DirStream_t*>(cache);
        if (isContiguous()) {
    470c:	ldrb.w	r3, [r5, #51]	; 0x33
    4710:	tst.w	r3, #64	; 0x40
    4714:	ldrb	r3, [r0, #1]
          ds->flags |= EXFAT_FLAG_CONTIGUOUS;
    4716:	ite	ne
    4718:	orrne.w	r3, r3, #2
        } else {
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
    471c:	biceq.w	r3, r3, #2
    4720:	strb	r3, [r0, #1]
        }
        setLe64(ds->validLength, m_validLength);
    4722:	ldrd	r2, r3, [r5, #16]

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    4726:	strd	r2, r3, [r0, #8]
        setLe32(ds->firstCluster, m_firstCluster);
    472a:	ldr	r3, [r5, #28]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    472c:	str	r3, [r0, #20]
        setLe64(ds->dataLength, m_dataLength);
    472e:	ldrd	r2, r3, [r5, #8]
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    4732:	strd	r2, r3, [r0, #24]
        m_vol->dataCacheDirty();
    4736:	ldr	r2, [r5, #32]
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    4738:	ldrb.w	r3, [r2, #528]	; 0x210
    473c:	orr.w	r3, r3, #1
    4740:	strb.w	r3, [r2, #528]	; 0x210
      default:
        DBG_FAIL_MACRO;
        goto fail;
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
    4744:	mov	r1, r7
    4746:	mov	r0, r4
    4748:	bl	44e4 <exFatDirChecksum(unsigned char const*, unsigned short)>
    474c:	adds	r6, #1
    474e:	mov	r7, r0
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    4750:	b.n	46b2 <ExFatFile::syncDir()+0xe>
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
  }
  df = reinterpret_cast<DirFile_t*>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
    4752:	movs	r2, #1
    4754:	add.w	r1, r5, #36	; 0x24
    4758:	ldr	r0, [r5, #32]
    475a:	bl	41ce <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    475e:	cbz	r0, 476a <ExFatFile::syncDir()+0xc6>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    4760:	strh	r7, [r0, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe16(df->setChecksum, checksum);
  if (!m_vol->cacheSync()) {
    4762:	ldr	r0, [r5, #32]
    4764:	bl	4512 <ExFatPartition::cacheSync()>
    4768:	cbnz	r0, 4778 <ExFatFile::syncDir()+0xd4>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    476a:	ldrb.w	r3, [r5, #50]	; 0x32
    476e:	orr.w	r3, r3, #1
    4772:	strb.w	r3, [r5, #50]	; 0x32
  return false;
    4776:	movs	r0, #0
}
    4778:	add	sp, #8
    477a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    477e:	nop
    4780:	.word	0x1fff8418

00004784 <ExFatFile::sync()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
    4784:	push	{r4, lr}
  if (!isOpen()) {
    4786:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
    478a:	mov	r4, r0
  if (!isOpen()) {
    478c:	cbnz	r3, 4792 <ExFatFile::sync()+0xe>
    return true;
    478e:	movs	r0, #1
    4790:	pop	{r4, pc}
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    4792:	ldrb.w	r3, [r0, #51]	; 0x33
    4796:	lsls	r2, r3, #24
    4798:	bpl.n	47aa <ExFatFile::sync()+0x26>
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    479a:	and.w	r3, r3, #127	; 0x7f
    479e:	strb.w	r3, [r0, #51]	; 0x33
  return true;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    47a2:	ldmia.w	sp!, {r4, lr}
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    return syncDir();
    47a6:	b.w	46a4 <ExFatFile::syncDir()>
  }
  if (!m_vol->cacheSync()) {
    47aa:	ldr	r0, [r0, #32]
    47ac:	bl	4512 <ExFatPartition::cacheSync()>
    47b0:	cmp	r0, #0
    47b2:	bne.n	478e <ExFatFile::sync()+0xa>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    47b4:	ldrb.w	r3, [r4, #50]	; 0x32
    47b8:	orr.w	r3, r3, #1
    47bc:	strb.w	r3, [r4, #50]	; 0x32
  return false;
}
    47c0:	pop	{r4, pc}

000047c2 <ExFatFile::addDirCluster()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    47c2:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    47c6:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    47ca:	mov	r4, r0
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    47cc:	lsls	r0, r3, #25
    47ce:	bpl.n	47d8 <ExFatFile::addDirCluster()+0x16>
    47d0:	ldr	r0, [r4, #32]
    47d2:	bl	4478 <ExFatPartition::rootLength()>
    47d6:	b.n	47da <ExFatFile::addDirCluster()+0x18>
    47d8:	ldr	r0, [r4, #8]
    47da:	ldr	r3, [r4, #32]
  uint8_t* cache;
  dl += m_vol->bytesPerCluster();
  if (dl >= 0X4000000) {
    47dc:	ldr.w	r3, [r3, #1084]	; 0x43c
    47e0:	add	r0, r3
    47e2:	cmp.w	r0, #67108864	; 0x4000000
    47e6:	bcs.n	489a <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    47e8:	mov	r0, r4
    47ea:	bl	4538 <ExFatFile::addCluster()>
    47ee:	cmp	r0, #0
    47f0:	beq.n	489a <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  cache =  m_vol->cacheClear();
    47f2:	ldr	r5, [r4, #32]
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    if (isDirty() && !sync()) {
    47f4:	ldrb.w	r3, [r5, #528]	; 0x210
    47f8:	lsls	r1, r3, #31
    47fa:	bpl.n	4808 <ExFatFile::addDirCluster()+0x46>
    47fc:	add.w	r0, r5, #528	; 0x210
    4800:	bl	303a <FsCache::sync()>
    4804:	cmp	r0, #0
    4806:	beq.n	489a <ExFatFile::addDirCluster()+0xd8>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    4808:	mov.w	r3, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    480c:	movs	r6, #0
    m_sector = 0XFFFFFFFF;
    480e:	str.w	r3, [r5, #540]	; 0x21c
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4812:	strb.w	r6, [r5, #528]	; 0x210
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    4816:	add.w	r5, r5, #544	; 0x220
  if (!cache) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
    481a:	mov.w	r2, #512	; 0x200
    481e:	mov	r1, r6
    4820:	mov	r0, r5
    4822:	bl	88dc <memset>
  sector = m_vol->clusterStartSector(m_curCluster);
    4826:	ldr	r2, [r4, #32]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    4828:	ldr	r3, [r4, #24]
    482a:	ldrb.w	r1, [r2, #1093]	; 0x445
    482e:	ldr.w	r7, [r2, #1068]	; 0x42c
    4832:	subs	r3, #2
    4834:	lsls	r3, r1
    4836:	add	r7, r3
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    4838:	mov.w	r8, #1
    483c:	ldr	r3, [r4, #32]
    483e:	ldrb.w	r2, [r3, #1093]	; 0x445
    4842:	lsl.w	r2, r8, r2
    4846:	cmp	r2, r6
    4848:	bls.n	485e <ExFatFile::addDirCluster()+0x9c>
    484a:	ldr.w	r0, [r3, #1088]	; 0x440
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    484e:	ldr	r3, [r0, #0]
    4850:	mov	r2, r5
    4852:	ldr	r3, [r3, #32]
    4854:	adds	r1, r7, r6
    4856:	blx	r3
    if (!m_vol->writeSector(sector + i, cache)) {
    4858:	cbz	r0, 489a <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
  sector = m_vol->clusterStartSector(m_curCluster);
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    485a:	adds	r6, #1
    485c:	b.n	483c <ExFatFile::addDirCluster()+0x7a>
    if (!m_vol->writeSector(sector + i, cache)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  if (!isRoot()) {
    485e:	ldrb.w	r2, [r4, #49]	; 0x31
    4862:	lsls	r2, r2, #25
    4864:	bmi.n	4890 <ExFatFile::addDirCluster()+0xce>
    m_flags |= FILE_FLAG_DIR_DIRTY;
    4866:	ldrb.w	r2, [r4, #51]	; 0x33
    486a:	orn	r2, r2, #127	; 0x7f
    m_dataLength  += m_vol->bytesPerCluster();
    486e:	ldrd	r0, r1, [r4, #8]
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    4872:	strb.w	r2, [r4, #51]	; 0x33
    m_dataLength  += m_vol->bytesPerCluster();
    4876:	ldr.w	r2, [r3, #1084]	; 0x43c
    487a:	movs	r3, #0
    487c:	adds	r0, r0, r2
    487e:	adcs	r1, r3
    4880:	strd	r0, r1, [r4, #8]
    m_validLength += m_vol->bytesPerCluster();
    4884:	ldrd	r0, r1, [r4, #16]
    4888:	adds	r2, r2, r0
    488a:	adcs	r3, r1
    488c:	strd	r2, r3, [r4, #16]
  }
  return sync();
    4890:	mov	r0, r4

 fail:
  return false;
}
    4892:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    m_validLength += m_vol->bytesPerCluster();
  }
  return sync();
    4896:	b.w	4784 <ExFatFile::sync()>

 fail:
  return false;
}
    489a:	movs	r0, #0
    489c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000048a0 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    48a0:	push	{r4, lr}
  if (!parent->isDir()) {
    48a2:	ldrb.w	r3, [r1, #49]	; 0x31
    48a6:	tst.w	r3, #80	; 0x50

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    48aa:	mov	r4, r0
  if (!parent->isDir()) {
    48ac:	beq.n	48e4 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!openPrivate(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    48ae:	movw	r3, #2562	; 0xa02
    48b2:	bl	3c3c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    48b6:	cbz	r0, 48e4 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_attributes = FILE_ATTR_SUBDIR;
    48b8:	movs	r3, #16
    48ba:	strb.w	r3, [r4, #49]	; 0x31

  // allocate and zero first cluster
  if (!addDirCluster()) {
    48be:	mov	r0, r4
    48c0:	bl	47c2 <ExFatFile::addDirCluster()>
    48c4:	cbz	r0, 48e4 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    48c6:	ldr	r3, [r4, #24]
    48c8:	str	r3, [r4, #28]
    48ca:	mov	r0, r4
    48cc:	movs	r3, #0
    48ce:	movs	r2, #0
    48d0:	bl	3b6c <ExFatFile::seekSet(unsigned long long)>

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    48d4:	movs	r3, #193	; 0xc1
    48d6:	strb.w	r3, [r4, #51]	; 0x33
  return sync();
    48da:	mov	r0, r4

 fail:
  return false;
}
    48dc:	ldmia.w	sp!, {r4, lr}
  m_firstCluster = m_curCluster;

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();
    48e0:	b.w	4784 <ExFatFile::sync()>

 fail:
  return false;
}
    48e4:	movs	r0, #0
    48e6:	pop	{r4, pc}

000048e8 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const char* path, bool pFlag) {
    48e8:	push	{r4, r5, r6, r7, lr}
    48ea:	sub	sp, #92	; 0x5c
    48ec:	mov	r7, r3
    48ee:	movs	r3, #0
    48f0:	strh.w	r3, [sp, #20]
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    48f4:	strb.w	r3, [sp, #81]	; 0x51
    48f8:	strb.w	r3, [sp, #82]	; 0x52
    48fc:	strb.w	r3, [sp, #83]	; 0x53
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    4900:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const char* path, bool pFlag) {
    4904:	str	r2, [sp, #4]
    4906:	mov	r5, r0
    4908:	mov	r4, r1
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    490a:	cmp	r3, #0
    490c:	bne.n	49a0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    490e:	ldrb.w	r3, [r1, #49]	; 0x31
    4912:	tst.w	r3, #80	; 0x50
    4916:	beq.n	49a0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    4918:	ldrb	r3, [r2, #0]
    491a:	cmp	r3, #47	; 0x2f
    491c:	bne.n	493a <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x52>
    while (isDirSeparator(*path)) {
    491e:	ldr	r3, [sp, #4]
    4920:	ldrb	r2, [r3, #0]
    4922:	cmp	r2, #47	; 0x2f
    4924:	bne.n	492c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x44>
      path++;
    4926:	adds	r3, #1
    4928:	str	r3, [sp, #4]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    492a:	b.n	491e <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x36>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    492c:	ldr	r1, [r4, #32]
    492e:	add	r0, sp, #32
    4930:	bl	391a <ExFatFile::openRoot(ExFatVolume*)>
    4934:	cmp	r0, #0
    4936:	beq.n	49a0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    4938:	add	r4, sp, #32
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    493a:	add	r3, sp, #4
    493c:	add	r2, sp, #8
    493e:	ldr	r1, [sp, #4]
    4940:	mov	r0, r5
    4942:	bl	3940 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    4946:	cbz	r0, 49a0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    4948:	ldr	r3, [sp, #4]
    494a:	ldrb	r3, [r3, #0]
    494c:	cbz	r3, 4994 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xac>
      break;
    }
    if (!openPrivate(parent, &fname, O_RDONLY)) {
    494e:	movs	r3, #0
    4950:	add	r2, sp, #8
    4952:	mov	r1, r4
    4954:	mov	r0, r5
    4956:	bl	3c3c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    495a:	cbz	r0, 4982 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x9a>
      if (!pFlag || !mkdir(parent, &fname)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    495c:	add	r2, sp, #32
    495e:	mov	r3, r5
    4960:	add.w	lr, r5, #48	; 0x30
    4964:	mov	r4, r2
    4966:	ldr	r0, [r3, #0]
    4968:	ldr	r1, [r3, #4]
    496a:	mov	r6, r2
    496c:	stmia	r6!, {r0, r1}
    496e:	adds	r3, #8
    4970:	cmp	r3, lr
    4972:	mov	r2, r6
    4974:	bne.n	4966 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x7e>
    4976:	ldr	r0, [r3, #0]
    4978:	str	r0, [r6, #0]
    parent = &tmpDir;
    close();
    497a:	mov	r0, r5
    497c:	bl	38c6 <ExFatFile::close()>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    4980:	b.n	493a <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x52>
    }
    if (!*path) {
      break;
    }
    if (!openPrivate(parent, &fname, O_RDONLY)) {
      if (!pFlag || !mkdir(parent, &fname)) {
    4982:	cbz	r7, 49a0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    4984:	add	r2, sp, #8
    4986:	mov	r1, r4
    4988:	mov	r0, r5
    498a:	bl	48a0 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    498e:	cmp	r0, #0
    4990:	bne.n	495c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x74>
    4992:	b.n	49a0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    4994:	add	r2, sp, #8
    4996:	mov	r1, r4
    4998:	mov	r0, r5
    499a:	bl	48a0 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    499e:	b.n	49a2 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xba>

 fail:
  return false;
    49a0:	movs	r0, #0
}
    49a2:	add	sp, #92	; 0x5c
    49a4:	pop	{r4, r5, r6, r7, pc}

000049a6 <ExFatFile::rename(ExFatFile*, char const*)>:
//------------------------------------------------------------------------------
bool ExFatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const char* newPath) {
    49a6:	push	{r4, r5, r6, r7, lr}
    49a8:	sub	sp, #116	; 0x74
    49aa:	movs	r3, #0
    49ac:	strb.w	r3, [sp, #49]	; 0x31
    49b0:	strb.w	r3, [sp, #50]	; 0x32
    49b4:	strb.w	r3, [sp, #51]	; 0x33
    49b8:	strb.w	r3, [sp, #105]	; 0x69
    49bc:	strb.w	r3, [sp, #106]	; 0x6a
    49c0:	strb.w	r3, [sp, #107]	; 0x6b
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    49c4:	ldrb.w	r3, [r0, #49]	; 0x31
    49c8:	tst.w	r3, #24
//------------------------------------------------------------------------------
bool ExFatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const char* newPath) {
    49cc:	mov	r4, r0
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    49ce:	bne.n	49d4 <ExFatFile::rename(ExFatFile*, char const*)+0x2e>
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();

 fail:
  return false;
    49d0:	movs	r0, #0
    49d2:	b.n	4a48 <ExFatFile::rename(ExFatFile*, char const*)+0xa2>
  if (!(isFile() || isSubDir())) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    49d4:	ldr	r0, [r0, #32]
    49d6:	ldr	r3, [r1, #32]
    49d8:	cmp	r0, r3
    49da:	bne.n	49d0 <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    49dc:	movw	r3, #2561	; 0xa01
    49e0:	mov	r0, sp
    49e2:	bl	3f8c <ExFatFile::open(ExFatFile*, char const*, int)>
    49e6:	cmp	r0, #0
    49e8:	beq.n	49d0 <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  oldFile = *this;
    49ea:	add	r2, sp, #56	; 0x38
    49ec:	mov	r3, r4
    49ee:	add.w	r7, r4, #48	; 0x30
    49f2:	mov	r6, r2
    49f4:	ldr	r0, [r3, #0]
    49f6:	ldr	r1, [r3, #4]
    49f8:	mov	r5, r2
    49fa:	stmia	r5!, {r0, r1}
    49fc:	adds	r3, #8
    49fe:	cmp	r3, r7
    4a00:	mov	r2, r5
    4a02:	bne.n	49f4 <ExFatFile::rename(ExFatFile*, char const*)+0x4e>
    4a04:	ldr	r0, [r3, #0]
    4a06:	str	r0, [r5, #0]
  m_dirPos = file.m_dirPos;
    4a08:	add	r2, sp, #36	; 0x24
    4a0a:	ldmia	r2, {r0, r1, r2}
    4a0c:	add.w	r3, r4, #36	; 0x24
    4a10:	stmia.w	r3, {r0, r1, r2}
  m_setCount = file.m_setCount;
    4a14:	ldrb.w	r3, [sp, #48]	; 0x30
    4a18:	strb.w	r3, [r4, #48]	; 0x30
  m_flags |= FILE_FLAG_DIR_DIRTY;
    4a1c:	ldrb.w	r3, [r4, #51]	; 0x33
    4a20:	orn	r3, r3, #127	; 0x7f
    4a24:	strb.w	r3, [r4, #51]	; 0x33
  if (!sync()) {
    4a28:	mov	r0, r4
    4a2a:	bl	4784 <ExFatFile::sync()>
    4a2e:	cmp	r0, #0
    4a30:	beq.n	49d0 <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    4a32:	movs	r3, #0
    4a34:	str	r3, [sp, #84]	; 0x54
  oldFile.m_flags = FILE_FLAG_WRITE;
    4a36:	movs	r3, #2
    4a38:	strb.w	r3, [sp, #107]	; 0x6b
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();
    4a3c:	mov	r0, r6
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
    4a3e:	movs	r3, #8
    4a40:	strb.w	r3, [sp, #105]	; 0x69
  return oldFile.remove();
    4a44:	bl	45ca <ExFatFile::remove()>

 fail:
  return false;
}
    4a48:	add	sp, #116	; 0x74
    4a4a:	pop	{r4, r5, r6, r7, pc}

00004a4c <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    4a4c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4a50:	mov	r4, r3
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    4a52:	ldrb.w	r3, [r0, #49]	; 0x31
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    4a56:	ldrb.w	fp, [sp, #40]	; 0x28
    4a5a:	ldrb.w	sl, [sp, #44]	; 0x2c
    4a5e:	ldrb.w	r5, [sp, #48]	; 0x30
    4a62:	ldrb.w	r9, [sp, #52]	; 0x34
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    4a66:	lsls	r3, r3, #28
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    4a68:	mov	r6, r0
    4a6a:	mov	r8, r1
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    4a6c:	bpl.n	4ae0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
  uint16_t date;
  uint16_t time;
  uint8_t ms10;

  if (!isFile()
      || year < 1980
    4a6e:	subw	r2, r2, #1980	; 0x7bc
    4a72:	uxth	r7, r2
    4a74:	cmp	r7, #127	; 0x7f
    4a76:	bhi.n	4ae0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || year > 2107
      || month < 1
    4a78:	subs	r3, r4, #1
    4a7a:	cmp	r3, #11
    4a7c:	bhi.n	4ae0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || month > 12
      || day < 1
    4a7e:	add.w	r3, fp, #4294967295
    4a82:	cmp	r3, #30
    4a84:	bhi.n	4ae0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || day > 31
      || hour > 23
    4a86:	cmp.w	sl, #23
    4a8a:	bhi.n	4ae0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || minute > 59
    4a8c:	cmp	r5, #59	; 0x3b
    4a8e:	bhi.n	4ae0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || second > 59) {
    4a90:	cmp.w	r9, #59	; 0x3b
    4a94:	bhi.n	4ae0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // update directory entry
  if (!sync()) {
    4a96:	bl	4784 <ExFatFile::sync()>
    4a9a:	cbz	r0, 4ae0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    4a9c:	mov.w	r3, r9, asr #1
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    4aa0:	orr.w	r4, fp, r4, lsl #5
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    4aa4:	orr.w	r5, r3, r5, lsl #5
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    4aa8:	orr.w	r4, r4, r7, lsl #9
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    4aac:	orr.w	r5, r5, sl, lsl #11
    goto fail;
  }

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;
    4ab0:	tst.w	r9, #1
    4ab4:	mov.w	r7, #0
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    4ab8:	uxth	r4, r4
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    4aba:	uxth	r5, r5
    4abc:	ite	eq
    4abe:	moveq.w	r9, #0
    4ac2:	movne.w	r9, #100	; 0x64
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
  DirFile_t* df;
  uint8_t* cache;
  uint16_t checksum = 0;
    4ac6:	mov	fp, r7
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        m_vol->dataCacheDirty();
        if (flags & T_ACCESS) {
    4ac8:	and.w	sl, r8, #1

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    4acc:	ldrb.w	r3, [r6, #48]	; 0x30
    4ad0:	uxtb	r1, r7
    4ad2:	cmp	r3, r1
    4ad4:	bcc.n	4b40 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xf4>
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    4ad6:	movs	r2, #0
    4ad8:	mov	r0, r6
    4ada:	bl	388e <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache) {
    4ade:	cbnz	r0, 4ae6 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x9a>
    goto fail;
  }
  return true;

 fail:
  return false;
    4ae0:	movs	r0, #0
    4ae2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    4ae6:	ldrb	r3, [r0, #0]
    4ae8:	cmp	r3, #133	; 0x85
    4aea:	beq.n	4af6 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xaa>
    4aec:	bcc.n	4ae0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    4aee:	subs	r3, #192	; 0xc0
    4af0:	cmp	r3, #1
    4af2:	bls.n	4b34 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xe8>
    4af4:	b.n	4ae0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    4af6:	ldrb.w	r3, [r6, #49]	; 0x31
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        m_vol->dataCacheDirty();
    4afa:	ldr	r2, [r6, #32]
    4afc:	and.w	r3, r3, #55	; 0x37
    4b00:	strh	r3, [r0, #4]
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    4b02:	ldrb.w	r3, [r2, #528]	; 0x210
    4b06:	orr.w	r3, r3, #1
    4b0a:	strb.w	r3, [r2, #528]	; 0x210
        if (flags & T_ACCESS) {
    4b0e:	cmp.w	sl, #0
    4b12:	beq.n	4b18 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xcc>
    4b14:	strh	r5, [r0, #16]
    4b16:	strh	r4, [r0, #18]
          setLe16(df->accessTime, time);
          setLe16(df->accessDate, date);
        }
        if (flags & T_CREATE) {
    4b18:	tst.w	r8, #2
          df->createTimeMs = ms10;
    4b1c:	ittt	ne
    4b1e:	strbne.w	r9, [r0, #20]
    4b22:	strhne	r5, [r0, #8]
    4b24:	strhne	r4, [r0, #10]
          setLe16(df->createTime, time);
          setLe16(df->createDate, date);
        }
        if (flags & T_WRITE) {
    4b26:	tst.w	r8, #4
          df->modifyTimeMs = ms10;
    4b2a:	ittt	ne
    4b2c:	strbne.w	r9, [r0, #21]
    4b30:	strhne	r5, [r0, #12]
    4b32:	strhne	r4, [r0, #14]
      default:
        DBG_FAIL_MACRO;
        goto fail;
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
    4b34:	mov	r1, fp
    4b36:	bl	44e4 <exFatDirChecksum(unsigned char const*, unsigned short)>
    4b3a:	adds	r7, #1
    4b3c:	mov	fp, r0

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    4b3e:	b.n	4acc <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x80>
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
  }
  df = reinterpret_cast<DirFile_t*>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
    4b40:	movs	r2, #1
    4b42:	add.w	r1, r6, #36	; 0x24
    4b46:	ldr	r0, [r6, #32]
    4b48:	bl	41ce <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    4b4c:	cmp	r0, #0
    4b4e:	beq.n	4ae0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    4b50:	strh.w	fp, [r0, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe16(df->setChecksum, checksum);
  if (!m_vol->cacheSync()) {
    4b54:	ldr	r0, [r6, #32]
    4b56:	bl	4512 <ExFatPartition::cacheSync()>
    4b5a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00004b5e <ExFatFile::truncate()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    4b5e:	push	{r0, r1, r4, r5, r6, lr}
    4b60:	ldrb.w	r3, [r0, #51]	; 0x33
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    4b64:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    4b66:	mov	r4, r0
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    4b68:	bmi.n	4b6e <ExFatFile::truncate()+0x10>
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    4b6a:	movs	r0, #0
    4b6c:	b.n	4c18 <ExFatFile::truncate()+0xba>
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    4b6e:	ldr	r5, [r0, #28]
    4b70:	cmp	r5, #0
    4b72:	beq.n	4bf6 <ExFatFile::truncate()+0x98>
      return true;
  }
  if (isContiguous()) {
    4b74:	and.w	r3, r3, #64	; 0x40
    4b78:	and.w	r1, r3, #255	; 0xff
    4b7c:	ldr	r6, [r0, #24]
    4b7e:	cbz	r3, 4bbe <ExFatFile::truncate()+0x60>
    4b80:	ldr	r3, [r4, #32]
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    4b82:	ldrd	r0, r1, [r0, #8]
    4b86:	ldrb.w	r2, [r3, #1093]	; 0x445
    4b8a:	adds.w	r0, r0, #4294967295
    4b8e:	add.w	r2, r2, #9
    4b92:	uxtb	r2, r2
    4b94:	adc.w	r1, r1, #4294967295
    4b98:	bl	9ce8 <__aeabi_llsr>
    4b9c:	adds	r2, r0, #1
    if (m_curCluster) {
    4b9e:	cbz	r6, 4bac <ExFatFile::truncate()+0x4e>
      toFree = m_curCluster + 1;
      nc -= 1 + m_curCluster - m_firstCluster;
    4ba0:	subs	r5, #1
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    4ba2:	adds	r3, r6, #1
      nc -= 1 + m_curCluster - m_firstCluster;
    4ba4:	subs	r5, r5, r6
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    4ba6:	str	r3, [sp, #4]
      nc -= 1 + m_curCluster - m_firstCluster;
    4ba8:	add	r2, r5
    4baa:	b.n	4bb0 <ExFatFile::truncate()+0x52>
    } else {
      toFree = m_firstCluster;
    4bac:	str	r5, [sp, #4]
      m_firstCluster = 0;
    4bae:	str	r6, [r4, #28]
    }
    if (nc && !m_vol->bitmapModify(toFree, nc, 0)) {
    4bb0:	cbz	r2, 4bfa <ExFatFile::truncate()+0x9c>
    4bb2:	movs	r3, #0
    4bb4:	ldr	r1, [sp, #4]
    4bb6:	ldr	r0, [r4, #32]
    4bb8:	bl	4128 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4bbc:	b.n	4bf2 <ExFatFile::truncate()+0x94>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
    4bbe:	cbz	r6, 4be4 <ExFatFile::truncate()+0x86>
      toFree = 0;
    4bc0:	add	r2, sp, #8
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    4bc2:	ldr	r0, [r0, #32]
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
      toFree = 0;
    4bc4:	str.w	r1, [r2, #-4]!
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    4bc8:	mov	r1, r6
    4bca:	bl	4204 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
      if (fg < 0) {
    4bce:	cmp	r0, #0
    4bd0:	blt.n	4b6a <ExFatFile::truncate()+0xc>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (fg) {
    4bd2:	beq.n	4be8 <ExFatFile::truncate()+0x8a>
        // current cluster is end of chain
        if (!m_vol->fatPut(m_curCluster, EXFAT_EOC)) {
    4bd4:	mov.w	r2, #4294967295
    4bd8:	ldr	r1, [r4, #24]
    4bda:	ldr	r0, [r4, #32]
    4bdc:	bl	42b0 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4be0:	cbnz	r0, 4be8 <ExFatFile::truncate()+0x8a>
    4be2:	b.n	4b6a <ExFatFile::truncate()+0xc>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
    } else {
      toFree = m_firstCluster;
    4be4:	str	r5, [sp, #4]
      m_firstCluster = 0;
    4be6:	str	r6, [r0, #28]
    }
    if (toFree) {
    4be8:	ldr	r1, [sp, #4]
    4bea:	cbz	r1, 4bfa <ExFatFile::truncate()+0x9c>
      if (!m_vol->freeChain(toFree)) {
    4bec:	ldr	r0, [r4, #32]
    4bee:	bl	42ea <ExFatPartition::freeChain(unsigned long)>
    4bf2:	cbnz	r0, 4bfa <ExFatFile::truncate()+0x9c>
    4bf4:	b.n	4b6a <ExFatFile::truncate()+0xc>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    4bf6:	movs	r0, #1
    4bf8:	b.n	4c18 <ExFatFile::truncate()+0xba>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  }
  m_dataLength = m_curPosition;
    4bfa:	ldrd	r2, r3, [r4]
    4bfe:	strd	r2, r3, [r4, #8]
  m_validLength = m_curPosition;
    4c02:	strd	r2, r3, [r4, #16]
  m_flags |= FILE_FLAG_DIR_DIRTY;
    4c06:	ldrb.w	r3, [r4, #51]	; 0x33
    4c0a:	orn	r3, r3, #127	; 0x7f
    4c0e:	strb.w	r3, [r4, #51]	; 0x33
  return sync();
    4c12:	mov	r0, r4
    4c14:	bl	4784 <ExFatFile::sync()>

 fail:
  return false;
}
    4c18:	add	sp, #8
    4c1a:	pop	{r4, r5, r6, pc}

00004c1c <ExFatFile::write(void const*, unsigned int)>:
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    4c1c:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4c20:	ldrb.w	r3, [r0, #51]	; 0x33
    4c24:	mov	r9, r1

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    4c26:	lsls	r1, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    4c28:	mov	r4, r0
    4c2a:	mov	sl, r2

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    4c2c:	bpl.w	4da6 <ExFatFile::write(void const*, unsigned int)+0x18a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    4c30:	lsls	r2, r3, #28
    4c32:	bmi.n	4c42 <ExFatFile::write(void const*, unsigned int)+0x26>
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    4c34:	add.w	r3, r4, #24

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    4c38:	mov	r8, sl
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    4c3a:	str	r3, [sp, #0]
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    4c3c:	mov.w	fp, #1
    4c40:	b.n	4d08 <ExFatFile::write(void const*, unsigned int)+0xec>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_validLength)) {
    4c42:	ldrd	r2, r3, [r0, #16]
    4c46:	bl	3b6c <ExFatFile::seekSet(unsigned long long)>
    4c4a:	cmp	r0, #0
    4c4c:	bne.n	4c34 <ExFatFile::write(void const*, unsigned int)+0x18>
    4c4e:	b.n	4da6 <ExFatFile::write(void const*, unsigned int)+0x18a>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    clusterOffset = m_curPosition & m_vol->clusterMask();
    4c50:	ldr	r0, [r4, #32]
    4c52:	ldr	r6, [r4, #0]
    4c54:	ldr.w	r3, [r0, #1080]	; 0x438
    4c58:	ands	r6, r3
    sectorOffset = clusterOffset & m_vol->sectorMask();
    4c5a:	ubfx	r5, r6, #0, #9
    if (clusterOffset == 0) {
    4c5e:	cmp	r6, #0
    4c60:	beq.n	4d10 <ExFatFile::write(void const*, unsigned int)+0xf4>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    sector = m_vol->clusterStartSector(m_curCluster) +
    4c62:	ldr.w	lr, [r4, #32]
             (clusterOffset >> m_vol->bytesPerSectorShift());
    4c66:	ldr	r1, [r4, #24]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    4c68:	ldrb.w	r2, [lr, #1093]	; 0x445
    4c6c:	ldr.w	r3, [lr, #1068]	; 0x42c
    4c70:	subs	r1, #2
    4c72:	lsls	r1, r2
    4c74:	lsrs	r6, r6, #9
    4c76:	add	r1, r3
    4c78:	add	r1, r6

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
    4c7a:	cmp	r5, #0
    4c7c:	bne.n	4d78 <ExFatFile::write(void const*, unsigned int)+0x15c>
    4c7e:	cmp.w	r8, #512	; 0x200
    4c82:	bcs.w	4dba <ExFatFile::write(void const*, unsigned int)+0x19e>
      // lesser of space and amount to write
      if (n > toWrite) {
        n = toWrite;
      }

      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
    4c86:	ldrd	r2, r3, [r4, #16]
    4c8a:	ldrd	r6, r7, [r4]
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    4c8e:	cmp	r7, r3
    4c90:	it	eq
    4c92:	cmpeq	r6, r2
    4c94:	ite	cc
    4c96:	movcc	r2, #1
    4c98:	movcs	r2, #5
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    4c9a:	add.w	r0, lr, #528	; 0x210
    4c9e:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      cache = m_vol->dataCacheGet(sector, cacheOption);
      if (!cache) {
    4ca2:	cmp	r0, #0
    4ca4:	beq.n	4da6 <ExFatFile::write(void const*, unsigned int)+0x18a>
             (clusterOffset >> m_vol->bytesPerSectorShift());

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    4ca6:	rsb	r6, r5, #512	; 0x200
    4caa:	cmp	r6, r8
    4cac:	it	cs
    4cae:	movcs	r6, r8
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    4cb0:	add	r0, r5
    4cb2:	mov	r2, r6
    4cb4:	mov	r1, r9
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    4cb6:	add	r5, r6
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    4cb8:	bl	8734 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    4cbc:	cmp.w	r5, #512	; 0x200
    4cc0:	bne.n	4cd0 <ExFatFile::write(void const*, unsigned int)+0xb4>
  }
  uint32_t dataCacheSector() {return m_dataCache.sector();}
  bool dataCacheSync() {return m_dataCache.sync();}
    4cc2:	ldr	r0, [r4, #32]
    4cc4:	add.w	r0, r0, #528	; 0x210
    4cc8:	bl	303a <FsCache::sync()>
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeWrite(sector, src, ns)) {
    4ccc:	cmp	r0, #0
    4cce:	beq.n	4da6 <ExFatFile::write(void const*, unsigned int)+0x18a>
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    4cd0:	ldrd	r0, r1, [r4]
    4cd4:	adds	r2, r0, r6
    4cd6:	adc.w	r3, r1, #0
    4cda:	mov	r0, r2
    4cdc:	mov	r1, r3
    4cde:	strd	r2, r3, [r4]
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    4ce2:	ldrd	r2, r3, [r4, #16]
    4ce6:	cmp	r3, r1
    4ce8:	it	eq
    4cea:	cmpeq	r2, r0
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    src += n;
    4cec:	add	r9, r6
    toWrite -= n;
    4cee:	rsb	r8, r6, r8
    if (m_curPosition > m_validLength) {
    4cf2:	bcs.n	4d08 <ExFatFile::write(void const*, unsigned int)+0xec>
      m_flags |= FILE_FLAG_DIR_DIRTY;
    4cf4:	ldrb.w	r3, [r4, #51]	; 0x33
    4cf8:	orn	r3, r3, #127	; 0x7f
    4cfc:	strb.w	r3, [r4, #51]	; 0x33
      m_validLength = m_curPosition;
    4d00:	mov	r2, r0
    4d02:	mov	r3, r1
    4d04:	strd	r2, r3, [r4, #16]
    if (!seekSet(m_validLength)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    4d08:	cmp.w	r8, #0
    4d0c:	bne.n	4c50 <ExFatFile::write(void const*, unsigned int)+0x34>
    4d0e:	b.n	4d7c <ExFatFile::write(void const*, unsigned int)+0x160>
    clusterOffset = m_curPosition & m_vol->clusterMask();
    sectorOffset = clusterOffset & m_vol->sectorMask();
    if (clusterOffset == 0) {
      // start of new cluster
      if (m_curCluster != 0) {
    4d10:	ldr	r7, [r4, #24]
    4d12:	cbz	r7, 4d62 <ExFatFile::write(void const*, unsigned int)+0x146>
        int fg;

        if (isContiguous()) {
    4d14:	ldrb.w	r3, [r4, #51]	; 0x33
    4d18:	lsls	r3, r3, #25
    4d1a:	bpl.n	4d52 <ExFatFile::write(void const*, unsigned int)+0x136>
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    4d1c:	ldrb.w	r2, [r0, #1093]	; 0x445
      // start of new cluster
      if (m_curCluster != 0) {
        int fg;

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
    4d20:	ldr	r3, [r4, #28]
    4d22:	str	r3, [sp, #4]
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    4d24:	ldrd	r0, r1, [r4, #8]
    4d28:	adds	r2, #9
    4d2a:	adds.w	r0, r0, #4294967295
    4d2e:	adc.w	r1, r1, #4294967295
    4d32:	uxtb	r2, r2
    4d34:	bl	9ce8 <__aeabi_llsr>
    4d38:	ldr	r3, [sp, #4]
    4d3a:	add	r0, r3
    4d3c:	cmp	r7, r0
    4d3e:	bcc.n	4d4c <ExFatFile::write(void const*, unsigned int)+0x130>
            goto fail;
          }
        }
        if (fg == 0) {
          // add cluster if at end of chain
          if (!addCluster()) {
    4d40:	mov	r0, r4
    4d42:	bl	4538 <ExFatFile::addCluster()>
    4d46:	cmp	r0, #0
    4d48:	bne.n	4c62 <ExFatFile::write(void const*, unsigned int)+0x46>
    4d4a:	b.n	4da6 <ExFatFile::write(void const*, unsigned int)+0x18a>

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
            m_curCluster++;
    4d4c:	adds	r7, #1
    4d4e:	str	r7, [r4, #24]
    4d50:	b.n	4c62 <ExFatFile::write(void const*, unsigned int)+0x46>
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    4d52:	ldr	r2, [sp, #0]
    4d54:	mov	r1, r7
    4d56:	bl	4204 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    4d5a:	cmp	r0, #0
    4d5c:	blt.n	4da6 <ExFatFile::write(void const*, unsigned int)+0x18a>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
        if (fg == 0) {
    4d5e:	bne.n	4c62 <ExFatFile::write(void const*, unsigned int)+0x46>
    4d60:	b.n	4d40 <ExFatFile::write(void const*, unsigned int)+0x124>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    4d62:	ldr	r3, [r4, #28]
    4d64:	cbnz	r3, 4d74 <ExFatFile::write(void const*, unsigned int)+0x158>
          // allocate first cluster of file
          if (!addCluster()) {
    4d66:	mov	r0, r4
    4d68:	bl	4538 <ExFatFile::addCluster()>
    4d6c:	cbz	r0, 4da6 <ExFatFile::write(void const*, unsigned int)+0x18a>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    4d6e:	ldr	r3, [r4, #24]
    4d70:	str	r3, [r4, #28]
    4d72:	b.n	4c62 <ExFatFile::write(void const*, unsigned int)+0x46>
        } else {
          m_curCluster = m_firstCluster;
    4d74:	str	r3, [r4, #24]
    4d76:	b.n	4c62 <ExFatFile::write(void const*, unsigned int)+0x46>
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    4d78:	movs	r2, #1
    4d7a:	b.n	4c9a <ExFatFile::write(void const*, unsigned int)+0x7e>
    if (m_curPosition > m_validLength) {
      m_flags |= FILE_FLAG_DIR_DIRTY;
      m_validLength = m_curPosition;
    }
  }
  if (m_curPosition > m_dataLength) {
    4d7c:	ldrd	r0, r1, [r4]
    4d80:	ldrd	r2, r3, [r4, #8]
    4d84:	cmp	r3, r1
    4d86:	it	eq
    4d88:	cmpeq	r2, r0
    4d8a:	bcs.n	4d92 <ExFatFile::write(void const*, unsigned int)+0x176>
    m_dataLength = m_curPosition;
    4d8c:	strd	r0, r1, [r4, #8]
    4d90:	b.n	4d98 <ExFatFile::write(void const*, unsigned int)+0x17c>
    // update fileSize and insure sync will update dir entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    4d92:	ldr	r3, [pc, #148]	; (4e28 <ExFatFile::write(void const*, unsigned int)+0x20c>)
    4d94:	ldr	r3, [r3, #0]
    4d96:	cbz	r3, 4db6 <ExFatFile::write(void const*, unsigned int)+0x19a>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    4d98:	ldrb.w	r3, [r4, #51]	; 0x33
    4d9c:	orn	r3, r3, #127	; 0x7f
    4da0:	strb.w	r3, [r4, #51]	; 0x33
    4da4:	b.n	4db6 <ExFatFile::write(void const*, unsigned int)+0x19a>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    4da6:	ldrb.w	r3, [r4, #50]	; 0x32
    4daa:	orr.w	r3, r3, #1
    4dae:	strb.w	r3, [r4, #50]	; 0x32
  return 0;
    4db2:	movs	r0, #0
    4db4:	b.n	4e22 <ExFatFile::write(void const*, unsigned int)+0x206>
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
  }
  return nbyte;
    4db6:	mov	r0, sl
    4db8:	b.n	4e22 <ExFatFile::write(void const*, unsigned int)+0x206>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
    4dba:	cmp.w	r8, #1024	; 0x400
    4dbe:	ldr.w	r7, [lr, #540]	; 0x21c
    4dc2:	ldr.w	r0, [lr, #532]	; 0x214
    4dc6:	bcc.n	4df2 <ExFatFile::write(void const*, unsigned int)+0x1d6>
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
      // Limit writes to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    4dc8:	lsl.w	r3, fp, r2
    4dcc:	subs	r6, r3, r6
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
    4dce:	mov.w	ip, r8, lsr #9
    4dd2:	cmp	ip, r6
    4dd4:	mov	r3, ip
    4dd6:	it	cs
    4dd8:	movcs	r3, r6
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    4dda:	cmp	r1, r7
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    4ddc:	mov.w	r6, r3, lsl #9
    4de0:	bhi.n	4de8 <ExFatFile::write(void const*, unsigned int)+0x1cc>
    4de2:	adds	r2, r1, r3
    4de4:	cmp	r7, r2
    4de6:	bcc.n	4e14 <ExFatFile::write(void const*, unsigned int)+0x1f8>
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    4de8:	ldr	r2, [r0, #0]
    4dea:	ldr	r5, [r2, #36]	; 0x24
    4dec:	mov	r2, r9
    4dee:	blx	r5
    4df0:	b.n	4ccc <ExFatFile::write(void const*, unsigned int)+0xb0>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    4df2:	cmp	r1, r7
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4df4:	ittt	eq
    4df6:	strbeq.w	r5, [lr, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    4dfa:	moveq.w	r3, #4294967295
    4dfe:	streq.w	r3, [lr, #540]	; 0x21c
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    4e02:	ldr	r3, [r0, #0]
    4e04:	mov	r2, r9
    4e06:	ldr	r3, [r3, #32]
    4e08:	blx	r3
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    4e0a:	cmp	r0, #0
    4e0c:	beq.n	4da6 <ExFatFile::write(void const*, unsigned int)+0x18a>
         DBG_FAIL_MACRO;
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
    4e0e:	mov.w	r6, #512	; 0x200
    4e12:	b.n	4cd0 <ExFatFile::write(void const*, unsigned int)+0xb4>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    4e14:	mov.w	r2, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4e18:	strb.w	r5, [lr, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    4e1c:	str.w	r2, [lr, #540]	; 0x21c
    4e20:	b.n	4de8 <ExFatFile::write(void const*, unsigned int)+0x1cc>

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
  return 0;
}
    4e22:	add	sp, #12
    4e24:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4e28:	.word	0x1fff8418

00004e2c <initFatDirCallback(unsigned long, void*)>:
  uint16_t count;
  uint16_t dotcount;
};
static const uint8_t * initFatDirCallback(uint32_t sector, void *context) {
  struct initFatDirState * state = (struct initFatDirState *)context;
  if (state->pr && ++state->count >= state->dotcount) {
    4e2c:	ldr	r0, [r1, #4]
  uint8_t * buffer;
  print_t * pr;
  uint16_t count;
  uint16_t dotcount;
};
static const uint8_t * initFatDirCallback(uint32_t sector, void *context) {
    4e2e:	push	{r4, lr}
    4e30:	mov	r4, r1
  struct initFatDirState * state = (struct initFatDirState *)context;
  if (state->pr && ++state->count >= state->dotcount) {
    4e32:	cbz	r0, 4e4c <initFatDirCallback(unsigned long, void*)+0x20>
    4e34:	ldrh	r3, [r1, #8]
    4e36:	ldrh	r2, [r1, #10]
    4e38:	adds	r3, #1
    4e3a:	uxth	r3, r3
    4e3c:	cmp	r2, r3
    4e3e:	strh	r3, [r1, #8]
    4e40:	bhi.n	4e4c <initFatDirCallback(unsigned long, void*)+0x20>
    state->pr->write(".");
    4e42:	ldr	r1, [pc, #12]	; (4e50 <initFatDirCallback(unsigned long, void*)+0x24>)
    4e44:	bl	a54 <Print::write(char const*)>
    state->count = 0;
    4e48:	movs	r3, #0
    4e4a:	strh	r3, [r4, #8]
  }
  return state->buffer;
    4e4c:	ldr	r0, [r4, #0]
}
    4e4e:	pop	{r4, pc}
    4e50:	.word	0x0001250d

00004e54 <FatFormatter::initFatDir(unsigned char, unsigned long)>:
bool FatFormatter::initFatDir(uint8_t fatType, uint32_t sectorCount) {
    4e54:	push	{r4, r5, r6, r7, lr}
    4e56:	mov	r4, r0
    4e58:	sub	sp, #28
    4e5a:	mov	r6, r1
    4e5c:	mov	r5, r2
  size_t n;
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    4e5e:	movs	r1, #0
    4e60:	mov.w	r2, #512	; 0x200
    4e64:	ldr	r0, [r0, #36]	; 0x24
    4e66:	bl	88dc <memset>
  writeMsg("Writing FAT ");
    4e6a:	ldr	r0, [r4, #32]
    4e6c:	cbz	r0, 4e74 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x20>
    4e6e:	ldr	r1, [pc, #128]	; (4ef0 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x9c>)
    4e70:	bl	a54 <Print::write(char const*)>
  struct initFatDirState state;
  state.buffer = m_secBuf;
    4e74:	ldr	r3, [r4, #36]	; 0x24
    4e76:	str	r3, [sp, #12]
  state.pr = m_pr;
    4e78:	ldr	r3, [r4, #32]
    4e7a:	str	r3, [sp, #16]
  state.count = 0;
  state.dotcount = sectorCount/32;
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    4e7c:	ldr	r0, [r4, #28]
    4e7e:	ldr	r1, [r4, #12]
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
  writeMsg("Writing FAT ");
  struct initFatDirState state;
  state.buffer = m_secBuf;
  state.pr = m_pr;
  state.count = 0;
    4e80:	movs	r3, #0
    4e82:	strh.w	r3, [sp, #20]
  state.dotcount = sectorCount/32;
    4e86:	lsrs	r3, r5, #5
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    4e88:	add	r2, sp, #12
  writeMsg("Writing FAT ");
  struct initFatDirState state;
  state.buffer = m_secBuf;
  state.pr = m_pr;
  state.count = 0;
  state.dotcount = sectorCount/32;
    4e8a:	strh.w	r3, [sp, #22]
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    4e8e:	ldr	r3, [r0, #0]
    4e90:	str	r2, [sp, #0]
    4e92:	ldr	r7, [r3, #40]	; 0x28
    4e94:	ldr	r3, [pc, #92]	; (4ef4 <FatFormatter::initFatDir(unsigned char, unsigned long)+0xa0>)
    4e96:	subs	r2, r5, #1
    4e98:	adds	r1, #1
    4e9a:	blx	r7
    4e9c:	cbnz	r0, 4ea2 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x4e>
     return false;
    4e9e:	movs	r0, #0
    4ea0:	b.n	4eea <FatFormatter::initFatDir(unsigned char, unsigned long)+0x96>
  }
  writeMsg("\r\n");
    4ea2:	ldr	r0, [r4, #32]
    4ea4:	cbz	r0, 4eac <FatFormatter::initFatDir(unsigned char, unsigned long)+0x58>
    4ea6:	ldr	r1, [pc, #80]	; (4ef8 <FatFormatter::initFatDir(unsigned char, unsigned long)+0xa4>)
    4ea8:	bl	a54 <Print::write(char const*)>
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
    4eac:	ldr	r3, [r4, #36]	; 0x24
    4eae:	movs	r2, #248	; 0xf8
  n = fatType == 16 ? 4 : 12;
    4eb0:	cmp	r6, #16
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
     return false;
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
    4eb2:	strb	r2, [r3, #0]
  n = fatType == 16 ? 4 : 12;
  for (size_t i = 1; i < n; i++) {
    m_secBuf[i] = 0XFF;
    4eb4:	mov.w	r0, #255	; 0xff
     return false;
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
  n = fatType == 16 ? 4 : 12;
    4eb8:	ite	eq
    4eba:	moveq	r2, #4
    4ebc:	movne	r2, #12
  for (size_t i = 1; i < n; i++) {
    4ebe:	movs	r3, #1
    m_secBuf[i] = 0XFF;
    4ec0:	ldr	r1, [r4, #36]	; 0x24
    4ec2:	strb	r0, [r1, r3]
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
  n = fatType == 16 ? 4 : 12;
  for (size_t i = 1; i < n; i++) {
    4ec4:	adds	r3, #1
    4ec6:	cmp	r2, r3
    4ec8:	bne.n	4ec0 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x6c>
    m_secBuf[i] = 0XFF;
  }
  return m_dev->writeSector(m_fatStart, m_secBuf) &&
    4eca:	ldr	r0, [r4, #28]
    4ecc:	ldr	r2, [r4, #36]	; 0x24
    4ece:	ldr	r3, [r0, #0]
    4ed0:	ldr	r1, [r4, #12]
    4ed2:	ldr	r3, [r3, #32]
    4ed4:	blx	r3
    4ed6:	cmp	r0, #0
    4ed8:	beq.n	4e9e <FatFormatter::initFatDir(unsigned char, unsigned long)+0x4a>
         m_dev->writeSector(m_fatStart + m_fatSize, m_secBuf);
    4eda:	ldr	r0, [r4, #28]
    4edc:	ldr	r5, [r4, #12]
    4ede:	ldr	r1, [r4, #8]
    4ee0:	ldr	r3, [r0, #0]
    4ee2:	ldr	r2, [r4, #36]	; 0x24
    4ee4:	ldr	r3, [r3, #32]
    4ee6:	add	r1, r5
    4ee8:	blx	r3
}
    4eea:	add	sp, #28
    4eec:	pop	{r4, r5, r6, r7, pc}
    4eee:	nop
    4ef0:	.word	0x00012500
    4ef4:	.word	0x00004e2d
    4ef8:	.word	0x0001257f

00004efc <FatFormatter::initPbs()>:
//------------------------------------------------------------------------------
void FatFormatter::initPbs() {
    4efc:	push	{r3, r4, r5, lr}
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    4efe:	ldr	r4, [r0, #36]	; 0x24
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    4f00:	mov.w	r2, #512	; 0x200
    4f04:	movs	r1, #0
  }
  return m_dev->writeSector(m_fatStart, m_secBuf) &&
         m_dev->writeSector(m_fatStart + m_fatSize, m_secBuf);
}
//------------------------------------------------------------------------------
void FatFormatter::initPbs() {
    4f06:	mov	r5, r0
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    4f08:	mov	r0, r4
    4f0a:	bl	88dc <memset>
  pbs->jmpInstruction[0] = 0XEB;
    4f0e:	movs	r3, #235	; 0xeb
    4f10:	strb	r3, [r4, #0]
  pbs->jmpInstruction[1] = 0X76;
    4f12:	movs	r3, #118	; 0x76
    4f14:	strb	r3, [r4, #1]
  pbs->jmpInstruction[2] = 0X90;
    4f16:	mov	r3, r4
    4f18:	movs	r2, #144	; 0x90
    4f1a:	strb.w	r2, [r3, #2]!
  for (uint8_t i = 0; i < sizeof(pbs->oemName); i++) {
    pbs->oemName[i] = ' ';
    4f1e:	movs	r1, #32
    4f20:	add.w	r2, r4, #10
    4f24:	strb.w	r1, [r3, #1]!
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
  pbs->jmpInstruction[0] = 0XEB;
  pbs->jmpInstruction[1] = 0X76;
  pbs->jmpInstruction[2] = 0X90;
  for (uint8_t i = 0; i < sizeof(pbs->oemName); i++) {
    4f28:	cmp	r3, r2
    4f2a:	bne.n	4f24 <FatFormatter::initPbs()+0x28>
    4f2c:	mov.w	r3, #512	; 0x200
    4f30:	strh.w	r3, [r4, #11]
    pbs->oemName[i] = ' ';
  }
  setLe16(pbs->bpb.bpb16.bytesPerSector, BYTES_PER_SECTOR);
  pbs->bpb.bpb16.sectorsPerCluster = m_sectorsPerCluster;
    4f34:	ldrb.w	r3, [r5, #43]	; 0x2b
    4f38:	strb	r3, [r4, #13]
  setLe16(pbs->bpb.bpb16.reservedSectorCount, m_reservedSectorCount);
    4f3a:	ldrh	r3, [r5, #40]	; 0x28
    4f3c:	strh	r3, [r4, #14]
  pbs->bpb.bpb16.fatCount = 2;
    4f3e:	movs	r3, #2
    4f40:	strb	r3, [r4, #16]
  // skip rootDirEntryCount
  // skip totalSectors16
  pbs->bpb.bpb16.mediaType = 0XF8;
    4f42:	movs	r3, #248	; 0xf8
    4f44:	strb	r3, [r4, #21]
  // skip sectorsPerFat16
  // skip sectorsPerTrack
  // skip headCount
  setLe32(pbs->bpb.bpb16.hidddenSectors, m_relativeSectors);
    4f46:	ldr	r3, [r5, #16]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    4f48:	str	r3, [r4, #28]
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
    4f4a:	ldr	r3, [r5, #24]
    4f4c:	str	r3, [r4, #32]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    4f4e:	movw	r3, #43605	; 0xaa55
    4f52:	strh.w	r3, [r4, #510]	; 0x1fe
    4f56:	pop	{r3, r4, r5, pc}

00004f58 <FatFormatter::writeMbr()>:
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
}
//------------------------------------------------------------------------------
bool FatFormatter::writeMbr() {
    4f58:	push	{r4, r5, r6, lr}
    4f5a:	mov	r4, r0
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    4f5c:	mov.w	r2, #512	; 0x200
    4f60:	movs	r1, #0
    4f62:	ldr	r0, [r0, #36]	; 0x24
    4f64:	bl	88dc <memset>
  MbrSector_t* mbr = reinterpret_cast<MbrSector_t*>(m_secBuf);
    4f68:	ldr	r5, [r4, #36]	; 0x24

#if USE_LBA_TO_CHS
  lbaToMbrChs(mbr->part->beginCHS, m_capacityMB, m_relativeSectors);
    4f6a:	ldr	r2, [r4, #16]
    4f6c:	ldr	r1, [r4, #0]
    4f6e:	addw	r0, r5, #447	; 0x1bf
    4f72:	bl	2fac <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>
  lbaToMbrChs(mbr->part->endCHS, m_capacityMB,
              m_relativeSectors + m_totalSectors -1);
    4f76:	ldr	r3, [r4, #24]
    4f78:	ldr	r2, [r4, #16]
    4f7a:	ldr	r1, [r4, #0]
    4f7c:	add	r2, r3
    4f7e:	addw	r0, r5, #451	; 0x1c3
    4f82:	subs	r2, #1
    4f84:	bl	2fac <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
#endif  // USE_LBA_TO_CHS

  mbr->part->type = m_partType;
    4f88:	ldrb.w	r3, [r4, #42]	; 0x2a
    4f8c:	strb.w	r3, [r5, #450]	; 0x1c2
  setLe32(mbr->part->relativeSectors, m_relativeSectors);
    4f90:	ldr	r3, [r4, #16]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    4f92:	str.w	r3, [r5, #454]	; 0x1c6
  setLe32(mbr->part->totalSectors, m_totalSectors);
    4f96:	ldr	r3, [r4, #24]
  setLe16(mbr->signature, MBR_SIGNATURE);
  return m_dev->writeSector(0, m_secBuf);
    4f98:	ldr	r0, [r4, #28]
    4f9a:	str.w	r3, [r5, #458]	; 0x1ca
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    4f9e:	movw	r3, #43605	; 0xaa55
    4fa2:	strh.w	r3, [r5, #510]	; 0x1fe
    4fa6:	ldr	r3, [r0, #0]
    4fa8:	ldr	r2, [r4, #36]	; 0x24
    4faa:	ldr	r3, [r3, #32]
    4fac:	movs	r1, #0
}
    4fae:	ldmia.w	sp!, {r4, r5, r6, lr}

  mbr->part->type = m_partType;
  setLe32(mbr->part->relativeSectors, m_relativeSectors);
  setLe32(mbr->part->totalSectors, m_totalSectors);
  setLe16(mbr->signature, MBR_SIGNATURE);
  return m_dev->writeSector(0, m_secBuf);
    4fb2:	bx	r3

00004fb4 <FatFormatter::makeFat16()>:
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
  // skip rest of bpb
  setLe16(pbs->signature, PBR_SIGNATURE);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
    4fb4:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    4fb6:	mov.w	r3, #256	; 0x100
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    4fba:	ldr	r5, [r0, #36]	; 0x24

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    4fbc:	ldr.w	lr, [r0, #20]
    4fc0:	ldrb.w	r2, [r0, #43]	; 0x2b
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    4fc4:	str	r3, [r0, #4]
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
  // skip rest of bpb
  setLe16(pbs->signature, PBR_SIGNATURE);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
    4fc6:	mov	r4, r0
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    4fc8:	ldr	r3, [r4, #4]
    4fca:	rsb	r1, r3, lr
    4fce:	udiv	r1, r1, r2
    m_fatSize = (nc + 2 + (BYTES_PER_SECTOR/2) - 1)/(BYTES_PER_SECTOR/2);
    4fd2:	addw	r6, r1, #257	; 0x101
    4fd6:	lsrs	r6, r6, #8
    r = BU16 + 1 + 2*m_fatSize + FAT16_ROOT_SECTOR_COUNT;
    4fd8:	lsls	r0, r6, #1
    4fda:	add.w	r7, r0, #161	; 0xa1
    if (m_dataStart >= r) {
    4fde:	cmp	r3, r7
    4fe0:	bcc.n	4ff8 <FatFormatter::makeFat16()+0x44>
      m_relativeSectors = m_dataStart - r + BU16;
    4fe2:	subs	r3, r3, r7
    4fe4:	str	r6, [r4, #8]
    4fe6:	add.w	r6, r3, #128	; 0x80
    4fea:	str	r6, [r4, #16]
      break;
    }
  }
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    4fec:	subw	r6, r1, #4085	; 0xff5
    4ff0:	cmp.w	r6, #61440	; 0xf000
    4ff4:	bcs.n	4ffe <FatFormatter::makeFat16()+0x4a>
    4ff6:	b.n	500c <FatFormatter::makeFat16()+0x58>
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    4ff8:	adds	r3, #128	; 0x80
    4ffa:	str	r3, [r4, #4]
    4ffc:	b.n	4fc8 <FatFormatter::makeFat16()+0x14>
      break;
    }
  }
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    4ffe:	ldr	r0, [r4, #32]
    5000:	cmp	r0, #0
    5002:	beq.n	50ac <FatFormatter::makeFat16()+0xf8>
    5004:	ldr	r1, [pc, #168]	; (50b0 <FatFormatter::makeFat16()+0xfc>)
    5006:	bl	a54 <Print::write(char const*)>
    500a:	b.n	50ac <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  m_reservedSectorCount = 1;
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
    500c:	adds	r3, #129	; 0x81
    500e:	str	r3, [r4, #12]
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
    5010:	add.w	r3, r0, #33	; 0x21
    5014:	mla	r3, r1, r2, r3
  if (m_totalSectors < 65536) {
    5018:	cmp.w	r3, #65536	; 0x10000
    return false;
  }
  m_reservedSectorCount = 1;
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
    501c:	str	r3, [r4, #24]
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = 1;
    501e:	mov.w	r6, #1
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
  if (m_totalSectors < 65536) {
    m_partType = 0X04;
    5022:	ite	cc
    5024:	movcc	r3, #4
  } else {
    m_partType = 0X06;
    5026:	movcs	r3, #6
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = 1;
    5028:	strh	r6, [r4, #40]	; 0x28
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
  if (m_totalSectors < 65536) {
    m_partType = 0X04;
  } else {
    m_partType = 0X06;
    502a:	strb.w	r3, [r4, #42]	; 0x2a
  }
  // write MBR
  if (!writeMbr()) {
    502e:	mov	r0, r4
    5030:	bl	4f58 <FatFormatter::writeMbr()>
    5034:	cmp	r0, #0
    5036:	beq.n	50ac <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  initPbs();
    5038:	mov	r0, r4
    503a:	bl	4efc <FatFormatter::initPbs()>
    503e:	mov.w	r3, #512	; 0x200
    5042:	strh.w	r3, [r5, #17]
    5046:	ldr	r3, [r4, #8]
    5048:	strh	r3, [r5, #22]
  setLe16(pbs->bpb.bpb16.rootDirEntryCount, FAT16_ROOT_ENTRY_COUNT);
  setLe16(pbs->bpb.bpb16.sectorsPerFat16, m_fatSize);
  pbs->bpb.bpb16.physicalDriveNumber = 0X80;
    504a:	movs	r3, #128	; 0x80
    504c:	strb.w	r3, [r5, #36]	; 0x24
  pbs->bpb.bpb16.extSignature = EXTENDED_BOOT_SIGNATURE;
    5050:	movs	r3, #41	; 0x29
    5052:	strb.w	r3, [r5, #38]	; 0x26
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    5056:	ldr	r3, [pc, #92]	; (50b4 <FatFormatter::makeFat16()+0x100>)
    5058:	str.w	r3, [r5, #39]	; 0x27
    505c:	add.w	r2, r5, #53	; 0x35
    5060:	add.w	r3, r5, #42	; 0x2a
  setLe32(pbs->bpb.bpb16.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb16.volumeLabel); i++) {
    pbs->bpb.bpb16.volumeLabel[i] = ' ';
    5064:	movs	r1, #32
    5066:	strb.w	r1, [r3, #1]!
  setLe16(pbs->bpb.bpb16.rootDirEntryCount, FAT16_ROOT_ENTRY_COUNT);
  setLe16(pbs->bpb.bpb16.sectorsPerFat16, m_fatSize);
  pbs->bpb.bpb16.physicalDriveNumber = 0X80;
  pbs->bpb.bpb16.extSignature = EXTENDED_BOOT_SIGNATURE;
  setLe32(pbs->bpb.bpb16.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb16.volumeLabel); i++) {
    506a:	cmp	r3, r2
    506c:	bne.n	5066 <FatFormatter::makeFat16()+0xb2>
    pbs->bpb.bpb16.volumeLabel[i] = ' ';
  }
  pbs->bpb.bpb16.volumeType[0] = 'F';
    506e:	movs	r3, #70	; 0x46
    5070:	strb.w	r3, [r5, #54]	; 0x36
  pbs->bpb.bpb16.volumeType[1] = 'A';
    5074:	movs	r3, #65	; 0x41
    5076:	strb.w	r3, [r5, #55]	; 0x37
  pbs->bpb.bpb16.volumeType[2] = 'T';
    507a:	movs	r3, #84	; 0x54
    507c:	strb.w	r3, [r5, #56]	; 0x38
  pbs->bpb.bpb16.volumeType[3] = '1';
    5080:	movs	r3, #49	; 0x31
    5082:	strb.w	r3, [r5, #57]	; 0x39
  pbs->bpb.bpb16.volumeType[4] = '6';
    5086:	movs	r3, #54	; 0x36
    5088:	strb.w	r3, [r5, #58]	; 0x3a
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)) {
    508c:	ldr	r0, [r4, #28]
    508e:	ldr	r2, [r4, #36]	; 0x24
    5090:	ldr	r3, [r0, #0]
    5092:	ldr	r1, [r4, #16]
    5094:	ldr	r3, [r3, #32]
    5096:	blx	r3
    5098:	cbz	r0, 50ac <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
    509a:	ldr	r2, [r4, #4]
    509c:	ldr	r3, [r4, #12]
    509e:	mov	r0, r4
    50a0:	subs	r2, r2, r3
    50a2:	movs	r1, #16
}
    50a4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  pbs->bpb.bpb16.volumeType[3] = '1';
  pbs->bpb.bpb16.volumeType[4] = '6';
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)) {
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
    50a8:	b.w	4e54 <FatFormatter::initFatDir(unsigned char, unsigned long)>
}
    50ac:	movs	r0, #0
    50ae:	pop	{r3, r4, r5, r6, r7, pc}
    50b0:	.word	0x00012559
    50b4:	.word	0x0012d687

000050b8 <FatFormatter::makeFat32()>:
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
    50b8:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
    50ba:	mov.w	r3, #8192	; 0x2000
    50be:	str	r3, [r0, #16]
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    50c0:	mov.w	r3, #16384	; 0x4000
    50c4:	str	r3, [r0, #4]
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    50c6:	ldr	r5, [r0, #36]	; 0x24
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    50c8:	ldr	r3, [r0, #20]
    50ca:	ldrb.w	r1, [r0, #43]	; 0x2b
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
    50ce:	mov	r4, r0
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    50d0:	ldr	r2, [r4, #4]
    50d2:	subs	r0, r3, r2
    50d4:	udiv	r0, r0, r1
    m_fatSize = (nc + 2 + (BYTES_PER_SECTOR/4) - 1)/(BYTES_PER_SECTOR/4);
    50d8:	add.w	r6, r0, #129	; 0x81
    50dc:	lsrs	r6, r6, #7
    r = m_relativeSectors + 9 + 2*m_fatSize;
    if (m_dataStart >= r) {
    50de:	mov.w	lr, r6, lsl #1
    50e2:	add.w	r7, lr, #8192	; 0x2000
    50e6:	adds	r7, #9
    50e8:	cmp	r2, r7
    50ea:	bcs.n	50f4 <FatFormatter::makeFat32()+0x3c>
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    50ec:	add.w	r2, r2, #8192	; 0x2000
    50f0:	str	r2, [r4, #4]
    50f2:	b.n	50d0 <FatFormatter::makeFat32()+0x18>
    if (m_dataStart >= r) {
      break;
    }
  }
  // error if too few clusters in FAT32 volume
  if (nc < 65525) {
    50f4:	movw	r3, #65524	; 0xfff4
    50f8:	cmp	r0, r3
    50fa:	str	r6, [r4, #8]
    50fc:	bhi.n	510e <FatFormatter::makeFat32()+0x56>
    writeMsg("Bad cluster count\r\n");
    50fe:	ldr	r0, [r4, #32]
    5100:	cmp	r0, #0
    5102:	beq.w	5246 <FatFormatter::makeFat32()+0x18e>
    5106:	ldr	r1, [pc, #324]	; (524c <FatFormatter::makeFat32()+0x194>)
    5108:	bl	a54 <Print::write(char const*)>
    510c:	b.n	5246 <FatFormatter::makeFat32()+0x18e>
    return false;
  }
  m_reservedSectorCount = m_dataStart - m_relativeSectors - 2*m_fatSize;
    510e:	sub.w	r3, r2, #8192	; 0x2000
    5112:	rsb	r3, lr, r3
    5116:	uxth	r3, r3
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster + m_dataStart - m_relativeSectors;
    5118:	mla	r2, r0, r1, r2
  // error if too few clusters in FAT32 volume
  if (nc < 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = m_dataStart - m_relativeSectors - 2*m_fatSize;
    511c:	strh	r3, [r4, #40]	; 0x28
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
    511e:	add.w	r3, r3, #8192	; 0x2000
    5122:	str	r3, [r4, #12]
  m_totalSectors = nc*m_sectorsPerCluster + m_dataStart - m_relativeSectors;
    5124:	sub.w	r3, r2, #8192	; 0x2000
    5128:	str	r3, [r4, #24]
  // type depends on address of end sector
  // max CHS has lba = 16450560 = 1024*255*63
  if ((m_relativeSectors + m_totalSectors) <= 16450560) {
    512a:	ldr	r3, [pc, #292]	; (5250 <FatFormatter::makeFat32()+0x198>)
    512c:	cmp	r2, r3
    // FAT32 with CHS and LBA
    m_partType = 0X0B;
    512e:	ite	ls
    5130:	movls	r3, #11
  } else {
    // FAT32 with only LBA
    m_partType = 0X0C;
    5132:	movhi	r3, #12
    5134:	strb.w	r3, [r4, #42]	; 0x2a
  }
  if (!writeMbr()) {
    5138:	mov	r0, r4
    513a:	bl	4f58 <FatFormatter::writeMbr()>
    513e:	cmp	r0, #0
    5140:	beq.w	5246 <FatFormatter::makeFat32()+0x18e>
    return false;
  }
  initPbs();
    5144:	mov	r0, r4
    5146:	bl	4efc <FatFormatter::initPbs()>
  setLe32(pbs->bpb.bpb32.sectorsPerFat32, m_fatSize);
    514a:	ldr	r3, [r4, #8]
    514c:	str	r3, [r5, #36]	; 0x24
    514e:	movs	r3, #2
    5150:	str	r3, [r5, #44]	; 0x2c
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    5152:	movs	r3, #1
    5154:	strh	r3, [r5, #48]	; 0x30
    5156:	movs	r3, #6
    5158:	strh	r3, [r5, #50]	; 0x32
  setLe32(pbs->bpb.bpb32.fat32RootCluster, 2);
  setLe16(pbs->bpb.bpb32.fat32FSInfoSector, 1);
  setLe16(pbs->bpb.bpb32.fat32BackBootSector, 6);
  pbs->bpb.bpb32.physicalDriveNumber = 0X80;
    515a:	movs	r3, #128	; 0x80
    515c:	strb.w	r3, [r5, #64]	; 0x40
  pbs->bpb.bpb32.extSignature = EXTENDED_BOOT_SIGNATURE;
    5160:	movs	r3, #41	; 0x29
    5162:	strb.w	r3, [r5, #66]	; 0x42
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    5166:	ldr	r3, [pc, #236]	; (5254 <FatFormatter::makeFat32()+0x19c>)
    5168:	str.w	r3, [r5, #67]	; 0x43
    516c:	add.w	r2, r5, #81	; 0x51
    5170:	add.w	r3, r5, #70	; 0x46
  setLe32(pbs->bpb.bpb32.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb32.volumeLabel); i++) {
    pbs->bpb.bpb32.volumeLabel[i] = ' ';
    5174:	movs	r1, #32
    5176:	strb.w	r1, [r3, #1]!
  setLe16(pbs->bpb.bpb32.fat32FSInfoSector, 1);
  setLe16(pbs->bpb.bpb32.fat32BackBootSector, 6);
  pbs->bpb.bpb32.physicalDriveNumber = 0X80;
  pbs->bpb.bpb32.extSignature = EXTENDED_BOOT_SIGNATURE;
  setLe32(pbs->bpb.bpb32.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb32.volumeLabel); i++) {
    517a:	cmp	r3, r2
    517c:	bne.n	5176 <FatFormatter::makeFat32()+0xbe>
    pbs->bpb.bpb32.volumeLabel[i] = ' ';
  }
  pbs->bpb.bpb32.volumeType[0] = 'F';
    517e:	movs	r3, #70	; 0x46
    5180:	strb.w	r3, [r5, #82]	; 0x52
  pbs->bpb.bpb32.volumeType[1] = 'A';
    5184:	movs	r3, #65	; 0x41
    5186:	strb.w	r3, [r5, #83]	; 0x53
  pbs->bpb.bpb32.volumeType[2] = 'T';
    518a:	movs	r3, #84	; 0x54
    518c:	strb.w	r3, [r5, #84]	; 0x54
  pbs->bpb.bpb32.volumeType[3] = '3';
    5190:	movs	r3, #51	; 0x33
    5192:	strb.w	r3, [r5, #85]	; 0x55
  pbs->bpb.bpb32.volumeType[4] = '2';
    5196:	movs	r3, #50	; 0x32
    5198:	strb.w	r3, [r5, #86]	; 0x56
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)  ||
    519c:	ldr	r0, [r4, #28]
    519e:	ldr	r2, [r4, #36]	; 0x24
    51a0:	ldr	r3, [r0, #0]
    51a2:	ldr	r1, [r4, #16]
    51a4:	ldr	r3, [r3, #32]
    51a6:	blx	r3
    51a8:	cmp	r0, #0
    51aa:	beq.n	5246 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 6, m_secBuf)) {
    51ac:	ldr	r0, [r4, #28]
    51ae:	ldr	r1, [r4, #16]
    51b0:	ldr	r3, [r0, #0]
    51b2:	ldr	r2, [r4, #36]	; 0x24
    51b4:	ldr	r3, [r3, #32]
    51b6:	adds	r1, #6
    51b8:	blx	r3
  pbs->bpb.bpb32.volumeType[0] = 'F';
  pbs->bpb.bpb32.volumeType[1] = 'A';
  pbs->bpb.bpb32.volumeType[2] = 'T';
  pbs->bpb.bpb32.volumeType[3] = '3';
  pbs->bpb.bpb32.volumeType[4] = '2';
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)  ||
    51ba:	cmp	r0, #0
    51bc:	beq.n	5246 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 6, m_secBuf)) {
    return false;
  }
  // write extra boot area and backup
  memset(m_secBuf, 0 , BYTES_PER_SECTOR);
    51be:	mov.w	r2, #512	; 0x200
    51c2:	movs	r1, #0
    51c4:	ldr	r0, [r4, #36]	; 0x24
    51c6:	bl	88dc <memset>
    51ca:	ldr	r3, [pc, #140]	; (5258 <FatFormatter::makeFat32()+0x1a0>)
  setLe32(fsi->trailSignature, FSINFO_TRAIL_SIGNATURE);
  if (!m_dev->writeSector(m_relativeSectors + 2, m_secBuf)  ||
    51cc:	ldr	r0, [r4, #28]
    51ce:	str.w	r3, [r5, #508]	; 0x1fc
    51d2:	ldr	r1, [r4, #16]
    51d4:	ldr	r3, [r0, #0]
    51d6:	ldr	r2, [r4, #36]	; 0x24
    51d8:	ldr	r3, [r3, #32]
    51da:	adds	r1, #2
    51dc:	blx	r3
    51de:	cmp	r0, #0
    51e0:	beq.n	5246 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 8, m_secBuf)) {
    51e2:	ldr	r0, [r4, #28]
    51e4:	ldr	r1, [r4, #16]
    51e6:	ldr	r3, [r0, #0]
    51e8:	ldr	r2, [r4, #36]	; 0x24
    51ea:	ldr	r3, [r3, #32]
    51ec:	adds	r1, #8
    51ee:	blx	r3
    return false;
  }
  // write extra boot area and backup
  memset(m_secBuf, 0 , BYTES_PER_SECTOR);
  setLe32(fsi->trailSignature, FSINFO_TRAIL_SIGNATURE);
  if (!m_dev->writeSector(m_relativeSectors + 2, m_secBuf)  ||
    51f0:	cbz	r0, 5246 <FatFormatter::makeFat32()+0x18e>
    51f2:	ldr	r3, [pc, #104]	; (525c <FatFormatter::makeFat32()+0x1a4>)
    51f4:	str	r3, [r5, #0]
    51f6:	add.w	r3, r3, #534773760	; 0x1fe00000
    51fa:	add.w	r3, r3, #8192	; 0x2000
    51fe:	adds	r3, #32
    5200:	str.w	r3, [r5, #484]	; 0x1e4
  // write FSINFO sector and backup
  setLe32(fsi->leadSignature, FSINFO_LEAD_SIGNATURE);
  setLe32(fsi->structSignature, FSINFO_STRUCT_SIGNATURE);
  setLe32(fsi->freeCount, 0XFFFFFFFF);
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
    5204:	ldr	r0, [r4, #28]
    5206:	ldr	r2, [r4, #36]	; 0x24
    5208:	mov.w	r3, #4294967295
    520c:	str.w	r3, [r5, #488]	; 0x1e8
    5210:	str.w	r3, [r5, #492]	; 0x1ec
    5214:	ldr	r1, [r4, #16]
    5216:	ldr	r3, [r0, #0]
    5218:	adds	r1, #1
    521a:	ldr	r3, [r3, #32]
    521c:	blx	r3
    521e:	cbz	r0, 5246 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    5220:	ldr	r0, [r4, #28]
    5222:	ldr	r1, [r4, #16]
    5224:	ldr	r3, [r0, #0]
    5226:	ldr	r2, [r4, #36]	; 0x24
    5228:	ldr	r3, [r3, #32]
    522a:	adds	r1, #7
    522c:	blx	r3
  // write FSINFO sector and backup
  setLe32(fsi->leadSignature, FSINFO_LEAD_SIGNATURE);
  setLe32(fsi->structSignature, FSINFO_STRUCT_SIGNATURE);
  setLe32(fsi->freeCount, 0XFFFFFFFF);
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
    522e:	cbz	r0, 5246 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
    5230:	ldr	r2, [r4, #8]
    5232:	ldrb.w	r3, [r4, #43]	; 0x2b
    5236:	mov	r0, r4
    5238:	add.w	r2, r3, r2, lsl #1
    523c:	movs	r1, #32
}
    523e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
    5242:	b.w	4e54 <FatFormatter::initFatDir(unsigned char, unsigned long)>
}
    5246:	movs	r0, #0
    5248:	pop	{r3, r4, r5, r6, r7, pc}
    524a:	nop
    524c:	.word	0x00012559
    5250:	.word	0x00fb0400
    5254:	.word	0x0012d687
    5258:	.word	0xaa550000
    525c:	.word	0x41615252

00005260 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>:
#define writeMsg(str) if (m_pr) m_pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    5260:	push	{r3, r4, r5, lr}
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
    5262:	str	r3, [r0, #32]
  m_sectorCount = m_dev->sectorCount();
    5264:	ldr	r3, [r1, #0]
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
  bool rtn;
  m_dev = dev;
    5266:	str	r1, [r0, #28]
  m_secBuf = secBuf;
    5268:	str	r2, [r0, #36]	; 0x24
#define writeMsg(str) if (m_pr) m_pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    526a:	mov	r4, r0
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
  m_sectorCount = m_dev->sectorCount();
    526c:	ldr	r3, [r3, #24]
    526e:	mov	r0, r1
    5270:	blx	r3
  m_capacityMB = (m_sectorCount + SECTORS_PER_MB - 1)/SECTORS_PER_MB;
    5272:	addw	r3, r0, #2047	; 0x7ff
    5276:	lsrs	r3, r3, #11

  if (m_capacityMB <= 6) {
    5278:	cmp	r3, #6
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
  m_sectorCount = m_dev->sectorCount();
    527a:	str	r0, [r4, #20]
  m_capacityMB = (m_sectorCount + SECTORS_PER_MB - 1)/SECTORS_PER_MB;
    527c:	str	r3, [r4, #0]

  if (m_capacityMB <= 6) {
    527e:	bhi.n	528e <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2e>
    writeMsg("Card is too small.\r\n");
    5280:	ldr	r0, [r4, #32]
    5282:	cbz	r0, 528a <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2a>
    5284:	ldr	r1, [pc, #108]	; (52f4 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x94>)
    5286:	bl	a54 <Print::write(char const*)>
    return false;
    528a:	movs	r0, #0
    528c:	pop	{r3, r4, r5, pc}
  } else if (m_capacityMB <= 16) {
    528e:	cmp	r3, #16
    5290:	bhi.n	5296 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x36>
    m_sectorsPerCluster = 2;
    5292:	movs	r3, #2
    5294:	b.n	52c2 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 32) {
    5296:	cmp	r3, #32
    5298:	bhi.n	529e <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3e>
    m_sectorsPerCluster = 4;
    529a:	movs	r3, #4
    529c:	b.n	52c2 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 64) {
    529e:	cmp	r3, #64	; 0x40
    52a0:	bhi.n	52a6 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x46>
    m_sectorsPerCluster = 8;
    52a2:	movs	r3, #8
    52a4:	b.n	52c2 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 128) {
    52a6:	cmp	r3, #128	; 0x80
    52a8:	bhi.n	52ae <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x4e>
    m_sectorsPerCluster = 16;
    52aa:	movs	r3, #16
    52ac:	b.n	52c2 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 1024) {
    52ae:	cmp.w	r3, #1024	; 0x400
    52b2:	bhi.n	52b8 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x58>
    m_sectorsPerCluster = 32;
    52b4:	movs	r3, #32
    52b6:	b.n	52c2 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 32768) {
    52b8:	cmp.w	r3, #32768	; 0x8000
    m_sectorsPerCluster = 64;
    52bc:	ite	ls
    52be:	movls	r3, #64	; 0x40
  } else {
    // SDXC cards
    m_sectorsPerCluster = 128;
    52c0:	movhi	r3, #128	; 0x80
  }
  rtn = m_sectorCount < 0X400000 ? makeFat16() : makeFat32();
    52c2:	cmp.w	r0, #4194304	; 0x400000
    m_sectorsPerCluster = 32;
  } else if (m_capacityMB <= 32768) {
    m_sectorsPerCluster = 64;
  } else {
    // SDXC cards
    m_sectorsPerCluster = 128;
    52c6:	strb.w	r3, [r4, #43]	; 0x2b
  }
  rtn = m_sectorCount < 0X400000 ? makeFat16() : makeFat32();
    52ca:	mov	r0, r4
    52cc:	bcs.n	52d4 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x74>
    52ce:	bl	4fb4 <FatFormatter::makeFat16()>
    52d2:	b.n	52d8 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x78>
    52d4:	bl	50b8 <FatFormatter::makeFat32()>
    52d8:	mov	r5, r0
    52da:	ldr	r0, [r4, #32]
  if (rtn) {
    52dc:	cbz	r5, 52e8 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x88>
    writeMsg("Format Done\r\n");
    52de:	cbz	r0, 52f0 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x90>
    52e0:	ldr	r1, [pc, #20]	; (52f8 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x98>)
    52e2:	bl	a54 <Print::write(char const*)>
    52e6:	b.n	52f0 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x90>
  } else {
    writeMsg("Format Failed\r\n");
    52e8:	cmp	r0, #0
    52ea:	beq.n	528a <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2a>
    52ec:	ldr	r1, [pc, #12]	; (52fc <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x9c>)
    52ee:	b.n	5286 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x26>
    52f0:	movs	r0, #1
  }
  return rtn;
}
    52f2:	pop	{r3, r4, r5, pc}
    52f4:	.word	0x0001256d
    52f8:	.word	0x00012582
    52fc:	.word	0x00012590

00005300 <FatFile::cacheDir(unsigned short)>:

  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    5300:	push	{r4, lr}
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    5302:	lsls	r1, r1, #5

  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    5304:	mov	r4, r0
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    5306:	bl	57fe <FatFile::seekSet(unsigned long)>
    530a:	cbz	r0, 5318 <FatFile::cacheDir(unsigned short)+0x18>
    530c:	mov	r0, r4
    530e:	movs	r1, #0
  }
    5310:	ldmia.w	sp!, {r4, lr}
  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    5314:	b.w	57c4 <FatFile::readDirCache(bool)>
  }
    5318:	pop	{r4, pc}

0000531a <FatFile::getLfnChar(DirLfn_t*, unsigned char)>:
#include "FatFile.h"
#include "FatVolume.h"

//------------------------------------------------------------------------------
uint16_t FatFile::getLfnChar(DirLfn_t* ldir, uint8_t i) {
  if (i < 5) {
    531a:	cmp	r2, #4
    531c:	bhi.n	5328 <FatFile::getLfnChar(DirLfn_t*, unsigned char)+0xe>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    531e:	add.w	r1, r1, r2, lsl #1
    5322:	ldrh.w	r0, [r1, #1]
    return getLe16(ldir->unicode1 + 2*i);
    5326:	bx	lr
  } else if (i < 11) {
    5328:	cmp	r2, #10
    532a:	bhi.n	5334 <FatFile::getLfnChar(DirLfn_t*, unsigned char)+0x1a>
    532c:	add.w	r1, r1, r2, lsl #1
    5330:	ldrh	r0, [r1, #4]
    return getLe16(ldir->unicode2 + 2*i - 10);
    5332:	bx	lr
  } else if (i < 13) {
    5334:	cmp	r2, #12
    5336:	itte	ls
    5338:	addls.w	r1, r1, r2, lsl #1
    533c:	ldrhls	r0, [r1, #6]
    return getLe16(ldir->unicode3 + 2*i - 22);
  }
  DBG_HALT_IF(i >= 13);
  return 0;
    533e:	movhi	r0, #0
}
    5340:	bx	lr

00005342 <FatFile::getSFN(char*, unsigned int)>:
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
    5342:	push	{r3, r4, r5, r6, r7, lr}
    5344:	mov	r6, r1
    5346:	ldrb	r1, [r0, #0]
    5348:	mov	r7, r2
  char c;
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
  uint8_t* ptr;
  DirFat_t* dir;
  if (!isOpen()) {
    534a:	cbz	r1, 53c4 <FatFile::getSFN(char*, unsigned int)+0x82>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isRoot()) {
    534c:	ands.w	r4, r1, #96	; 0x60
    5350:	beq.n	5362 <FatFile::getSFN(char*, unsigned int)+0x20>
    if (size < 2) {
    5352:	cmp	r2, #1
    5354:	bls.n	53c4 <FatFile::getSFN(char*, unsigned int)+0x82>
      DBG_FAIL_MACRO;
      goto fail;
    }
    name[0] = '/';
    5356:	movs	r3, #47	; 0x2f
    5358:	strb	r3, [r6, #0]
    name[1] = '\0';
    535a:	movs	r3, #0
    535c:	strb	r3, [r6, #1]
    return 1;
    535e:	movs	r0, #1
    5360:	pop	{r3, r4, r5, r6, r7, pc}
  }
  // cache entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    5362:	mov	r1, r4
    5364:	bl	55a8 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    5368:	cbz	r0, 53c4 <FatFile::getSFN(char*, unsigned int)+0x82>
    DBG_FAIL_MACRO;
    goto fail;
  }
  ptr = dir->name;
    536a:	mov	r5, r0
    536c:	mov	r1, r4
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
  char c;
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
    536e:	movs	r2, #8
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
  char c;
  uint8_t j = 0;
    5370:	mov	r3, r4
    goto fail;
  }
  ptr = dir->name;
  // format name
  for (uint8_t i = 0; i < 12; i++) {
    if (i == 8) {
    5372:	cmp	r1, #8
    5374:	ldrb	r4, [r5, #0]
    5376:	bne.n	5382 <FatFile::getSFN(char*, unsigned int)+0x40>
      if (*ptr == ' ') {
    5378:	cmp	r4, #32
    537a:	beq.n	53bc <FatFile::getSFN(char*, unsigned int)+0x7a>
        break;
      }
      lcBit = FAT_CASE_LC_EXT;
    537c:	movs	r2, #16
      c = '.';
    537e:	movs	r4, #46	; 0x2e
    5380:	b.n	53a4 <FatFile::getSFN(char*, unsigned int)+0x62>
    } else {
      c = *ptr++;
      if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
    5382:	sub.w	lr, r4, #65	; 0x41
    5386:	cmp.w	lr, #25
        break;
      }
      lcBit = FAT_CASE_LC_EXT;
      c = '.';
    } else {
      c = *ptr++;
    538a:	add.w	r5, r5, #1
      if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
    538e:	bhi.n	53a0 <FatFile::getSFN(char*, unsigned int)+0x5e>
    5390:	ldrb.w	lr, [r0, #12]
    5394:	tst.w	r2, lr
    5398:	beq.n	53a4 <FatFile::getSFN(char*, unsigned int)+0x62>
        c += 'a' - 'A';
    539a:	adds	r4, #32
    539c:	uxtb	r4, r4
    539e:	b.n	53a4 <FatFile::getSFN(char*, unsigned int)+0x62>
      }
      if (c == ' ') {
    53a0:	cmp	r4, #32
    53a2:	beq.n	53b6 <FatFile::getSFN(char*, unsigned int)+0x74>
        continue;
      }
    }
    if ((j + 1u) == size) {
    53a4:	add.w	lr, r3, #1
    53a8:	cmp	r7, lr
    53aa:	mov	ip, r3
    53ac:	beq.n	53bc <FatFile::getSFN(char*, unsigned int)+0x7a>
      break;
    }
    name[j++] = c;
    53ae:	strb.w	r4, [r6, ip]
    53b2:	uxtb.w	r3, lr
    53b6:	adds	r1, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  ptr = dir->name;
  // format name
  for (uint8_t i = 0; i < 12; i++) {
    53b8:	cmp	r1, #12
    53ba:	bne.n	5372 <FatFile::getSFN(char*, unsigned int)+0x30>
    if ((j + 1u) == size) {
      break;
    }
    name[j++] = c;
  }
  name[j] = '\0';
    53bc:	movs	r2, #0
    53be:	strb	r2, [r6, r3]
  return j;
    53c0:	mov	r0, r3
    53c2:	pop	{r3, r4, r5, r6, r7, pc}

 fail:
  name[0] = '\0';
    53c4:	movs	r0, #0
    53c6:	strb	r0, [r6, #0]
  return 0;
}
    53c8:	pop	{r3, r4, r5, r6, r7, pc}
    53ca:	Address 0x000053ca is out of bounds.


000053cc <FatFile::getName8(char*, unsigned int)>:
 fail:
  name[0] = '\0';
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getName8(char* name, size_t size) {
    53cc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    53d0:	sub	sp, #44	; 0x2c
  char* ptr;
  FatFile dir;
  DirLfn_t* ldir;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    53d2:	ldrb	r3, [r0, #0]
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    53d4:	movs	r4, #0
 fail:
  name[0] = '\0';
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getName8(char* name, size_t size) {
    53d6:	mov	r7, r0
    53d8:	mov	r9, r1
    53da:	mov	r8, r2
    53dc:	strb.w	r4, [sp, #4]
    53e0:	strb.w	r4, [sp, #5]
    53e4:	strb.w	r4, [sp, #6]
  char* ptr;
  FatFile dir;
  DirLfn_t* ldir;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    53e8:	cmp	r3, #0
    53ea:	beq.n	54ac <FatFile::getName8(char*, unsigned int)+0xe0>
      DBG_FAIL_MACRO;
      goto fail;
  }
  if (!isLFN()) {
    53ec:	ldrb	r3, [r0, #3]
    53ee:	cbnz	r3, 53f6 <FatFile::getName8(char*, unsigned int)+0x2a>
    return getSFN(name, size);
    53f0:	bl	5342 <FatFile::getSFN(char*, unsigned int)>
    53f4:	b.n	54b2 <FatFile::getName8(char*, unsigned int)+0xe6>
  }
  if (!dir.openCluster(this)) {
    53f6:	mov	r1, r0
    53f8:	add	r0, sp, #4
    53fa:	bl	55f6 <FatFile::openCluster(FatFile*)>
    53fe:	cmp	r0, #0
    5400:	beq.n	54ac <FatFile::getName8(char*, unsigned int)+0xe0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    5402:	add.w	r8, r8, #4294967295
    5406:	mov	r5, r9
    5408:	movs	r6, #1
    540a:	add	r8, r9
  }
  if (!dir.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    540c:	ldrb	r3, [r7, #3]
    540e:	cmp	r3, r6
    5410:	bcc.n	54a2 <FatFile::getName8(char*, unsigned int)+0xd6>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(m_dirIndex - order));
    5412:	ldrh	r1, [r7, #4]
    5414:	subs	r1, r1, r6
    5416:	uxth	r1, r1
    5418:	add	r0, sp, #4
    541a:	bl	5300 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    541e:	mov	fp, r0
    5420:	cmp	r0, #0
    5422:	beq.n	54ac <FatFile::getName8(char*, unsigned int)+0xe0>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    5424:	ldrb	r3, [r0, #11]
    5426:	cmp	r3, #15
    5428:	bne.n	54ac <FatFile::getName8(char*, unsigned int)+0xe0>
    542a:	ldrb	r3, [r0, #0]
    542c:	and.w	r3, r3, #31
    5430:	cmp	r6, r3
    5432:	bne.n	54ac <FatFile::getName8(char*, unsigned int)+0xe0>
    5434:	mov	r3, r4
    5436:	mov.w	sl, #0
        order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t c = getLfnChar(ldir, i);
    543a:	uxtb.w	r2, sl
    543e:	mov	r1, fp
    5440:	mov	r0, r7
    5442:	bl	531a <FatFile::getLfnChar(DirLfn_t*, unsigned char)>
    5446:	mov	r4, r0
      if (hs) {
    5448:	cbz	r3, 5468 <FatFile::getName8(char*, unsigned int)+0x9c>
        if (!FsUtf::isLowSurrogate(c)) {
    544a:	add.w	r2, r0, #9216	; 0x2400
    544e:	uxth	r2, r2
    5450:	cmp.w	r2, #1024	; 0x400
    5454:	bcs.n	54ac <FatFile::getName8(char*, unsigned int)+0xe0>
   * \param[in] hs high surrogate.
   * \param[in] ls low surrogate.
   * \return code point.
   */
  inline uint32_t u16ToCp(uint16_t hs, uint16_t ls) {
    return 0X10000 + (((hs & 0X3FF) << 10) | (ls & 0X3FF));
    5456:	ldr	r0, [pc, #96]	; (54b8 <FatFile::getName8(char*, unsigned int)+0xec>)
    5458:	lsls	r3, r3, #10
    545a:	ands	r0, r3
    545c:	ubfx	r4, r4, #0, #10
    5460:	orrs	r4, r0
    5462:	add.w	r0, r4, #65536	; 0x10000
    5466:	b.n	5480 <FatFile::getName8(char*, unsigned int)+0xb4>
  /** Check for UTF-16 surrogate.
   * \param[in] c UTF-16 unit.
   * \return true if c is a surrogate else false.
   */
  inline bool isSurrogate(uint16_t c) {
    return 0XD800 <= c && c <= 0XDFFF;
    5468:	add.w	r3, r0, #10240	; 0x2800
    546c:	uxth	r3, r3
          DBG_FAIL_MACRO;
          goto fail;
        }
        cp = FsUtf::u16ToCp(hs, c);
        hs = 0;
      } else if (!FsUtf::isSurrogate(c)) {
    546e:	cmp.w	r3, #2048	; 0x800
    5472:	bcc.n	5478 <FatFile::getName8(char*, unsigned int)+0xac>
        if (c == 0) {
    5474:	cbnz	r0, 5480 <FatFile::getName8(char*, unsigned int)+0xb4>
    5476:	b.n	54a2 <FatFile::getName8(char*, unsigned int)+0xd6>
          goto done;
        }
        cp = c;
      } else if (FsUtf::isHighSurrogate(c)) {
    5478:	cmp.w	r3, #1024	; 0x400
    547c:	bcc.n	548e <FatFile::getName8(char*, unsigned int)+0xc2>
    547e:	b.n	54ac <FatFile::getName8(char*, unsigned int)+0xe0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    5480:	mov	r2, r8
    5482:	mov	r1, r5
    5484:	bl	2ce4 <FsUtf::cpToMb(unsigned long, char*, char*)>
      if (!ptr) {
    5488:	cbz	r0, 54a2 <FatFile::getName8(char*, unsigned int)+0xd6>
    548a:	mov	r5, r0
    548c:	movs	r4, #0
    548e:	add.w	sl, sl, #1
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
        order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t i = 0; i < 13; i++) {
    5492:	cmp.w	sl, #13
    5496:	beq.n	549c <FatFile::getName8(char*, unsigned int)+0xd0>
    5498:	mov	r3, r4
    549a:	b.n	543a <FatFile::getName8(char*, unsigned int)+0x6e>
  }
  if (!dir.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    549c:	adds	r6, #1
    549e:	uxtb	r6, r6
    54a0:	b.n	540c <FatFile::getName8(char*, unsigned int)+0x40>
      }
      str = ptr;
    }
  }
 done:
  *str = '\0';
    54a2:	movs	r3, #0
    54a4:	strb	r3, [r5, #0]
  return str - name;
    54a6:	rsb	r0, r9, r5
    54aa:	b.n	54b2 <FatFile::getName8(char*, unsigned int)+0xe6>

 fail:
  *name = 0;
    54ac:	movs	r0, #0
    54ae:	strb.w	r0, [r9]
  return 0;
}
    54b2:	add	sp, #44	; 0x2c
    54b4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    54b8:	.word	0x000ffc00

000054bc <FatFile::getName(char*, unsigned int)>:
//------------------------------------------------------------------------------
size_t FatFile::getName(char* name, size_t size) {
#if !USE_LONG_FILE_NAMES
  return getSFN(name, size);
#elif USE_UTF8_LONG_NAMES
  return getName8(name, size);
    54bc:	b.w	53cc <FatFile::getName8(char*, unsigned int)>

000054c0 <FatPartition::cacheSync()>:
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    54c0:	push	{r4, lr}
    54c2:	mov	r4, r0
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    54c4:	adds	r0, #40	; 0x28
    54c6:	bl	303a <FsCache::sync()>
    54ca:	cbz	r0, 54e2 <FatPartition::cacheSync()+0x22>
    54cc:	add.w	r0, r4, #568	; 0x238
    54d0:	bl	303a <FsCache::sync()>
    54d4:	cbz	r0, 54e2 <FatPartition::cacheSync()+0x22>
    54d6:	ldr	r0, [r4, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    54d8:	ldr	r3, [r0, #0]
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
  }
    54da:	ldmia.w	sp!, {r4, lr}
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    54de:	ldr	r3, [r3, #28]
    54e0:	bx	r3
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
  }
    54e2:	movs	r0, #0
    54e4:	pop	{r4, pc}

000054e6 <FatFile::addCluster()>:
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    54e6:	mov	r2, r0
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    54e8:	push	{r3, r4, r5, lr}
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    54ea:	ldr.w	r5, [r2, #16]!
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    54ee:	mov	r4, r0
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
  if (!m_vol->allocateCluster(m_curCluster, &m_curCluster)) {
    54f0:	mov	r1, r5
    54f2:	ldr	r0, [r0, #8]
    54f4:	bl	635e <FatPartition::allocateCluster(unsigned long, unsigned long*)>
    54f8:	cbz	r0, 551a <FatFile::addCluster()+0x34>
    54fa:	ldrb	r3, [r4, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (cc == 0) {
    54fc:	cbnz	r5, 5504 <FatFile::addCluster()+0x1e>
    m_flags |= FILE_FLAG_CONTIGUOUS;
    54fe:	orr.w	r3, r3, #64	; 0x40
    5502:	b.n	5510 <FatFile::addCluster()+0x2a>
  } else if (m_curCluster != (cc + 1)) {
    5504:	ldr	r2, [r4, #16]
    5506:	adds	r5, #1
    5508:	cmp	r2, r5
    550a:	beq.n	5512 <FatFile::addCluster()+0x2c>
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    550c:	bic.w	r3, r3, #64	; 0x40
    5510:	strb	r3, [r4, #2]
  }
  m_flags |= FILE_FLAG_DIR_DIRTY;
    5512:	ldrb	r3, [r4, #2]
    5514:	orn	r3, r3, #127	; 0x7f
    5518:	strb	r3, [r4, #2]
  return false;
#else  // USE_FAT_FILE_FLAG_CONTIGUOUS
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
    551a:	pop	{r3, r4, r5, pc}

0000551c <FatFile::addDirCluster()>:
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first sector of cluster in the cache.
bool FatFile::addDirCluster() {
    551c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    5520:	ldrb	r3, [r0, #0]
    5522:	and.w	r3, r3, #32
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first sector of cluster in the cache.
bool FatFile::addDirCluster() {
    5526:	mov	r4, r0
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    5528:	and.w	r5, r3, #255	; 0xff
    552c:	cbz	r3, 5532 <FatFile::addDirCluster()+0x16>
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
  return true;

 fail:
  return false;
    552e:	movs	r6, #0
    5530:	b.n	559c <FatFile::addDirCluster()+0x80>
  if (isRootFixed()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // max folder size
  if (m_curPosition >= 512UL*4095) {
    5532:	ldr	r2, [r0, #20]
    5534:	ldr	r3, [pc, #108]	; (55a4 <FatFile::addDirCluster()+0x88>)
    5536:	cmp	r2, r3
    5538:	bhi.n	552e <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    553a:	bl	54e6 <FatFile::addCluster()>
    553e:	mov	r6, r0
    5540:	cmp	r0, #0
    5542:	beq.n	552e <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_vol->clusterStartSector(m_curCluster);
    5544:	ldr	r0, [r4, #8]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    5546:	ldr	r1, [r4, #16]
    5548:	ldrb	r3, [r0, #6]
    554a:	ldr	r7, [r0, #20]
    554c:	subs	r1, #2
    554e:	lsls	r1, r3
    5550:	add	r7, r1
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    5552:	movs	r2, #5
    5554:	mov	r1, r7
    5556:	adds	r0, #40	; 0x28
    5558:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_RESERVE_FOR_WRITE);
  if (!pc) {
    555c:	mov	r8, r0
    555e:	cmp	r0, #0
    5560:	beq.n	552e <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
    5562:	mov	r1, r5
    5564:	mov.w	r2, #512	; 0x200
    5568:	bl	88dc <memset>
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    556c:	movs	r5, #1
    556e:	ldr	r3, [r4, #8]
    5570:	ldrb	r2, [r3, #4]
    5572:	cmp	r2, r5
    5574:	bls.n	558c <FatFile::addDirCluster()+0x70>
    5576:	ldr	r0, [r3, #0]
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    5578:	ldr	r3, [r0, #0]
    557a:	mov	r2, r8
    557c:	ldr	r3, [r3, #32]
    557e:	adds	r1, r5, r7
    5580:	blx	r3
    if (!m_vol->writeSector(sector + i, pc->data)) {
    5582:	cmp	r0, #0
    5584:	beq.n	552e <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    5586:	adds	r5, #1
    5588:	uxtb	r5, r5
    558a:	b.n	556e <FatFile::addDirCluster()+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
    558c:	ldrb	r2, [r3, #6]
    558e:	mov.w	r3, #512	; 0x200
    5592:	lsls	r3, r2
    5594:	ldr	r2, [r4, #20]
    5596:	uxtah	r3, r2, r3
    559a:	str	r3, [r4, #20]
  return true;

 fail:
  return false;
}
    559c:	mov	r0, r6
    559e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    55a2:	nop
    55a4:	.word	0x001ffdff

000055a8 <FatFile::cacheDirEntry(unsigned char)>:
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
DirFat_t* FatFile::cacheDirEntry(uint8_t action) {
    55a8:	push	{r4, lr}
    55aa:	mov	r4, r0
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    55ac:	ldr	r0, [r0, #8]
    55ae:	mov	r2, r1
    55b0:	adds	r0, #40	; 0x28
    55b2:	ldr	r1, [r4, #24]
    55b4:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
  cache_t* pc;
  pc = m_vol->cacheFetchData(m_dirSector, action);
  if (!pc) {
    55b8:	cbz	r0, 55c4 <FatFile::cacheDirEntry(unsigned char)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return pc->dir + (m_dirIndex & 0XF);
    55ba:	ldrh	r3, [r4, #4]
    55bc:	and.w	r3, r3, #15
    55c0:	add.w	r0, r0, r3, lsl #5

 fail:
  return nullptr;
}
    55c4:	pop	{r4, pc}

000055c6 <FatFile::openRoot(FatVolume*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    55c6:	push	{r4, r5, r6, lr}
  // error if file is already open
  if (isOpen()) {
    55c8:	ldrb	r4, [r0, #0]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    55ca:	mov	r5, r0
    55cc:	mov	r6, r1
  // error if file is already open
  if (isOpen()) {
    55ce:	cbnz	r4, 55f2 <FatFile::openRoot(FatVolume*)+0x2c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(FatFile));
    55d0:	movs	r2, #36	; 0x24
    55d2:	mov	r1, r4
    55d4:	bl	88dc <memset>

  m_vol = vol;
    55d8:	str	r6, [r5, #8]
  switch (vol->fatType()) {
    55da:	ldrb	r3, [r6, #7]
    55dc:	cmp	r3, #16
    55de:	beq.n	55e8 <FatFile::openRoot(FatVolume*)+0x22>
    55e0:	cmp	r3, #32
    55e2:	bne.n	55f2 <FatFile::openRoot(FatVolume*)+0x2c>
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    55e4:	movs	r3, #64	; 0x40
    55e6:	b.n	55ea <FatFile::openRoot(FatVolume*)+0x24>
  switch (vol->fatType()) {
#if FAT12_SUPPORT
  case 12:
#endif  // FAT12_SUPPORT
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    55e8:	movs	r3, #32
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    55ea:	movs	r0, #1
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    55ec:	strb	r3, [r5, #0]
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    55ee:	strb	r0, [r5, #2]
    55f0:	pop	{r4, r5, r6, pc}
  return true;

 fail:
  return false;
    55f2:	movs	r0, #0
    55f4:	pop	{r4, r5, r6, pc}

000055f6 <FatFile::openCluster(FatFile*)>:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    55f6:	push	{r3, r4, r5, lr}
  if (file->m_dirCluster == 0) {
    55f8:	ldr	r3, [r1, #12]
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    55fa:	mov	r4, r0
    55fc:	mov	r5, r1
  if (file->m_dirCluster == 0) {
    55fe:	cbnz	r3, 560a <FatFile::openCluster(FatFile*)+0x14>
    return openRoot(file->m_vol);
    5600:	ldr	r1, [r1, #8]
  m_attributes = FILE_ATTR_SUBDIR;
  m_flags = FILE_FLAG_READ;
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
    5602:	ldmia.w	sp!, {r3, r4, r5, lr}
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
    5606:	b.w	55c6 <FatFile::openRoot(FatVolume*)>
  }
  memset(this, 0, sizeof(FatFile));
    560a:	movs	r2, #36	; 0x24
    560c:	movs	r1, #0
    560e:	bl	88dc <memset>
  m_attributes = FILE_ATTR_SUBDIR;
    5612:	movs	r3, #16
  m_flags = FILE_FLAG_READ;
    5614:	movs	r0, #1
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
  m_attributes = FILE_ATTR_SUBDIR;
    5616:	strb	r3, [r4, #0]
  m_flags = FILE_FLAG_READ;
    5618:	strb	r0, [r4, #2]
  m_vol = file->m_vol;
    561a:	ldr	r3, [r5, #8]
    561c:	str	r3, [r4, #8]
  m_firstCluster = file->m_dirCluster;
    561e:	ldr	r3, [r5, #12]
    5620:	str	r3, [r4, #32]
  return true;
}
    5622:	pop	{r3, r4, r5, pc}

00005624 <FatFile::read(void*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    5624:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    5628:	ldrb	r3, [r0, #2]
    562a:	lsls	r5, r3, #31

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    562c:	mov	r4, r0
    562e:	mov	r9, r1
    5630:	mov	r6, r2
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    5632:	bpl.n	5724 <FatFile::read(void*, unsigned int)+0x100>
    5634:	ldrb	r3, [r0, #0]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
    5636:	lsls	r0, r3, #28
    5638:	bpl.n	5642 <FatFile::read(void*, unsigned int)+0x1e>
    uint32_t tmp32 = m_fileSize - m_curPosition;
    563a:	ldr	r3, [r4, #28]
    563c:	ldr	r2, [r4, #20]
    563e:	subs	r3, r3, r2
    5640:	b.n	5652 <FatFile::read(void*, unsigned int)+0x2e>
    if (nbyte >= tmp32) {
      nbyte = tmp32;
    }
  } else if (isRootFixed()) {
    5642:	lsls	r1, r3, #26
    5644:	bpl.n	5658 <FatFile::read(void*, unsigned int)+0x34>
    uint16_t tmp16 = 32*m_vol->m_rootDirEntryCount - (uint16_t)m_curPosition;
    5646:	ldr	r3, [r4, #8]
    if (nbyte > tmp16) {
    5648:	ldrh	r2, [r3, #8]
    564a:	ldr	r3, [r4, #20]
    564c:	rsb	r3, r3, r2, lsl #5
    5650:	uxth	r3, r3
    5652:	cmp	r6, r3
    5654:	it	cs
    5656:	movcs	r6, r3
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
    5658:	mov	r7, r6
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
  int8_t fg;
  uint8_t sectorOfCluster = 0;
    565a:	mov.w	r8, #0
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    565e:	add.w	sl, r4, #16
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    5662:	cmp	r7, #0
    5664:	beq.n	56ea <FatFile::read(void*, unsigned int)+0xc6>
    5666:	ldrb	r3, [r4, #0]
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    5668:	ldr	r2, [r4, #20]
    566a:	ldr	r0, [r4, #8]
    if (isRootFixed()) {
    566c:	tst.w	r3, #32
    }
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    5670:	ubfx	r5, r2, #0, #9
    5674:	mov.w	r1, r2, lsr #9
    if (isRootFixed()) {
    5678:	beq.n	5680 <FatFile::read(void*, unsigned int)+0x5c>
      sector = m_vol->rootDirStart()
               + (m_curPosition >> m_vol->bytesPerSectorShift());
    567a:	ldr	r3, [r0, #32]
    567c:	add	r1, r3
    567e:	b.n	56ca <FatFile::read(void*, unsigned int)+0xa6>
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    5680:	ldrb.w	r8, [r0, #5]
    5684:	and.w	r8, r1, r8
    } else {
      sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
      if (offset == 0 && sectorOfCluster == 0) {
    5688:	cbnz	r5, 56ba <FatFile::read(void*, unsigned int)+0x96>
    568a:	cmp.w	r8, #0
    568e:	bne.n	56ba <FatFile::read(void*, unsigned int)+0x96>
        // start of new cluster
        if (m_curPosition == 0) {
    5690:	cbnz	r2, 569c <FatFile::read(void*, unsigned int)+0x78>
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    5692:	lsls	r2, r3, #25
    5694:	ite	mi
    5696:	ldrmi	r3, [r0, #32]
    5698:	ldrpl	r3, [r4, #32]
    569a:	b.n	5732 <FatFile::read(void*, unsigned int)+0x10e>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
    569c:	lsls	r3, r3, #28
    569e:	bpl.n	56ac <FatFile::read(void*, unsigned int)+0x88>
    56a0:	ldrb	r3, [r4, #2]
    56a2:	lsls	r1, r3, #25
    56a4:	bpl.n	56ac <FatFile::read(void*, unsigned int)+0x88>
          m_curCluster++;
    56a6:	ldr	r3, [r4, #16]
    56a8:	adds	r3, #1
    56aa:	b.n	5732 <FatFile::read(void*, unsigned int)+0x10e>
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    56ac:	mov	r2, sl
    56ae:	ldr	r1, [r4, #16]
    56b0:	bl	6298 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    56b4:	cmp	r0, #0
    56b6:	blt.n	5724 <FatFile::read(void*, unsigned int)+0x100>
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
    56b8:	beq.n	56e2 <FatFile::read(void*, unsigned int)+0xbe>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    56ba:	ldr	r3, [r4, #8]
    56bc:	ldr	r1, [r4, #16]
    56be:	ldrb	r2, [r3, #6]
    56c0:	ldr	r3, [r3, #20]
    56c2:	subs	r1, #2
    56c4:	lsls	r1, r2
    56c6:	add	r1, r3
    56c8:	add	r1, r8
    56ca:	ldr.w	fp, [r4, #8]
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
    56ce:	cmp	r5, #0
    56d0:	bne.n	5772 <FatFile::read(void*, unsigned int)+0x14e>
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
    56d2:	cmp.w	r7, #512	; 0x200
    56d6:	bcc.n	5772 <FatFile::read(void*, unsigned int)+0x14e>
    56d8:	ldr.w	r3, [fp, #52]	; 0x34
        || sector == m_vol->cacheSectorNumber()) {
    56dc:	cmp	r1, r3
    56de:	bne.n	56ee <FatFile::read(void*, unsigned int)+0xca>
    56e0:	b.n	5772 <FatFile::read(void*, unsigned int)+0x14e>
          if (fg < 0) {
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
            if (isDir()) {
    56e2:	ldrb	r3, [r4, #0]
    56e4:	tst.w	r3, #112	; 0x70
    56e8:	beq.n	5724 <FatFile::read(void*, unsigned int)+0x100>
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return nbyte - toRead;
    56ea:	subs	r0, r6, r7
    56ec:	b.n	5796 <FatFile::read(void*, unsigned int)+0x172>
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    56ee:	cmp.w	r7, #1024	; 0x400
    56f2:	bcc.n	5750 <FatFile::read(void*, unsigned int)+0x12c>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      if (!isRootFixed()) {
    56f4:	ldrb	r2, [r4, #0]
    56f6:	lsls	r2, r2, #26
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    56f8:	mov.w	r5, r7, lsr #9
      if (!isRootFixed()) {
    56fc:	bmi.n	570c <FatFile::read(void*, unsigned int)+0xe8>
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
    56fe:	ldrb.w	r2, [fp, #4]
    5702:	rsb	r2, r8, r2
    5706:	cmp	r5, r2
    5708:	it	cs
    570a:	movcs	r5, r2
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    570c:	cmp	r1, r3
    570e:	bhi.n	5736 <FatFile::read(void*, unsigned int)+0x112>
    5710:	adds	r2, r1, r5
    5712:	cmp	r3, r2
    5714:	bcs.n	5736 <FatFile::read(void*, unsigned int)+0x112>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    5716:	add.w	r0, fp, #40	; 0x28
    571a:	str	r1, [sp, #4]
    571c:	bl	303a <FsCache::sync()>
    5720:	ldr	r1, [sp, #4]
    5722:	cbnz	r0, 5736 <FatFile::read(void*, unsigned int)+0x112>
    toRead -= n;
  }
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
    5724:	ldrb	r3, [r4, #1]
    5726:	orr.w	r3, r3, #2
    572a:	strb	r3, [r4, #1]
  return -1;
    572c:	mov.w	r0, #4294967295
    5730:	b.n	5796 <FatFile::read(void*, unsigned int)+0x172>
        if (m_curPosition == 0) {
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
    5732:	str	r3, [r4, #16]
    5734:	b.n	56ba <FatFile::read(void*, unsigned int)+0x96>
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    5736:	ldr.w	r0, [fp, #44]	; 0x2c
    573a:	ldr	r3, [r0, #0]
    573c:	mov	r2, r9
    573e:	ldr.w	fp, [r3, #16]
    5742:	mov	r3, r5
    5744:	blx	fp
        if (mb < ns) {
          ns = mb;
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    5746:	cmp	r0, #0
    5748:	beq.n	5724 <FatFile::read(void*, unsigned int)+0x100>
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
        if (mb < ns) {
          ns = mb;
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
    574a:	mov.w	fp, r5, lsl #9
    574e:	b.n	5764 <FatFile::read(void*, unsigned int)+0x140>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    5750:	ldr.w	r0, [fp, #44]	; 0x2c
    5754:	ldr	r3, [r0, #0]
    5756:	mov	r2, r9
    5758:	ldr	r3, [r3, #12]
    575a:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    575c:	cmp	r0, #0
    575e:	beq.n	5724 <FatFile::read(void*, unsigned int)+0x100>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    5760:	mov.w	fp, #512	; 0x200
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    5764:	ldr	r3, [r4, #20]
    5766:	add	r3, fp
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    5768:	add	r9, fp
    m_curPosition += n;
    576a:	str	r3, [r4, #20]
    toRead -= n;
    576c:	rsb	r7, fp, r7
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    5770:	b.n	5662 <FatFile::read(void*, unsigned int)+0x3e>
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    5772:	movs	r2, #0
    5774:	add.w	r0, fp, #40	; 0x28
    5778:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
      if (!pc) {
    577c:	cmp	r0, #0
    577e:	beq.n	5724 <FatFile::read(void*, unsigned int)+0x100>
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
      // amount to be read from current sector
      n = m_vol->bytesPerSector() - offset;
    5780:	rsb	fp, r5, #512	; 0x200
    5784:	cmp	fp, r7
    5786:	it	cs
    5788:	movcs	fp, r7
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
    578a:	adds	r1, r0, r5
    578c:	mov	r2, fp
    578e:	mov	r0, r9
    5790:	bl	8734 <memcpy>
    5794:	b.n	5764 <FatFile::read(void*, unsigned int)+0x140>
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
  return -1;
}
    5796:	add	sp, #12
    5798:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000579c <FatFile::peek()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::peek() {
    579c:	push	{r0, r1, r4, r5, r6, lr}
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    579e:	movs	r2, #1
    57a0:	add.w	r1, sp, #7
    57a4:	mov	r4, r0
  uint32_t curPosition = m_curPosition;
    57a6:	ldr	r6, [r0, #20]
  uint32_t curCluster = m_curCluster;
    57a8:	ldr	r5, [r0, #16]
    57aa:	bl	5624 <FatFile::read(void*, unsigned int)>
    57ae:	cmp	r0, #1
    57b0:	it	eq
    57b2:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
    57b6:	str	r6, [r4, #20]
    57b8:	it	ne
    57ba:	movne.w	r0, #4294967295
  m_curCluster = curCluster;
    57be:	str	r5, [r4, #16]
  return c;
}
    57c0:	add	sp, #8
    57c2:	pop	{r4, r5, r6, pc}

000057c4 <FatFile::readDirCache(bool)>:
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;
    57c4:	ldr	r3, [r0, #20]
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    57c6:	push	{r0, r1, r2, r4, r5, lr}
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;
    57c8:	ubfx	r5, r3, #5, #4
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    57cc:	mov	r4, r0
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;

  if (i == 0 || !skipReadOk) {
    57ce:	cbz	r5, 57d2 <FatFile::readDirCache(bool)+0xe>
    57d0:	cbnz	r1, 57ee <FatFile::readDirCache(bool)+0x2a>
    int8_t n = read(&n, 1);
    57d2:	movs	r2, #1
    57d4:	add.w	r1, sp, #7
    57d8:	mov	r0, r4
    57da:	bl	5624 <FatFile::read(void*, unsigned int)>
    57de:	sxtb	r0, r0
    if  (n != 1) {
    57e0:	cmp	r0, #1
    57e2:	beq.n	57e8 <FatFile::readDirCache(bool)+0x24>
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;

 fail:
  return nullptr;
    57e4:	movs	r0, #0
    57e6:	b.n	57fa <FatFile::readDirCache(bool)+0x36>
      if (n != 0) {
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    m_curPosition += 31;
    57e8:	ldr	r3, [r4, #20]
    57ea:	adds	r3, #31
    57ec:	b.n	57f0 <FatFile::readDirCache(bool)+0x2c>
  } else {
    m_curPosition += 32;
    57ee:	adds	r3, #32
  static const uint8_t CACHE_RESERVE_FOR_WRITE =
    CACHE_STATUS_DIRTY | CACHE_OPTION_NO_READ;
  //----------------------------------------------------------------------------
  /** \return Cache buffer address. */
  uint8_t* cacheBuffer() {
    return m_buffer;
    57f0:	ldr	r0, [r4, #8]
    57f2:	str	r3, [r4, #20]
    57f4:	adds	r0, #56	; 0x38
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;
    57f6:	add.w	r0, r0, r5, lsl #5

 fail:
  return nullptr;
}
    57fa:	add	sp, #12
    57fc:	pop	{r4, r5, pc}

000057fe <FatFile::seekSet(unsigned long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    57fe:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5802:	mov	r4, r0
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    5804:	ldr	r7, [r0, #16]
    5806:	ldrb	r0, [r0, #0]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    5808:	mov	r6, r1
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    580a:	cmp	r0, #0
    580c:	beq.n	589c <FatFile::seekSet(unsigned long)+0x9e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    580e:	ldr	r5, [r4, #20]
    5810:	cmp	r5, r1
    5812:	beq.n	58a4 <FatFile::seekSet(unsigned long)+0xa6>
    return true;
  }
  if (pos == 0) {
    5814:	cbnz	r1, 581a <FatFile::seekSet(unsigned long)+0x1c>
    // set position to start of file
    m_curCluster = 0;
    5816:	str	r1, [r4, #16]
    goto done;
    5818:	b.n	5890 <FatFile::seekSet(unsigned long)+0x92>
  }
  if (isFile()) {
    581a:	lsls	r2, r0, #28
    581c:	bpl.n	5826 <FatFile::seekSet(unsigned long)+0x28>
    if (pos > m_fileSize) {
    581e:	ldr	r3, [r4, #28]
    5820:	cmp	r1, r3
    5822:	bhi.n	589c <FatFile::seekSet(unsigned long)+0x9e>
    5824:	b.n	5836 <FatFile::seekSet(unsigned long)+0x38>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (isRootFixed()) {
    5826:	lsls	r3, r0, #26
    5828:	bpl.n	5836 <FatFile::seekSet(unsigned long)+0x38>
    582a:	ldr	r3, [r4, #8]
    if (pos <= 32*m_vol->rootDirEntryCount()) {
    582c:	ldrh	r3, [r3, #8]
    582e:	cmp.w	r1, r3, lsl #5
    5832:	bhi.n	589c <FatFile::seekSet(unsigned long)+0x9e>
    5834:	b.n	5890 <FatFile::seekSet(unsigned long)+0x92>
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    5836:	ldr.w	lr, [r4, #8]
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    583a:	ldrb	r1, [r4, #2]
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    583c:	ldrb.w	r2, [lr, #6]
    5840:	adds	r2, #9
    5842:	uxtb	r2, r2
    5844:	subs	r3, r6, #1
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    5846:	lsls	r1, r1, #25
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    5848:	lsr.w	r3, r3, r2
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    584c:	bpl.n	5856 <FatFile::seekSet(unsigned long)+0x58>
    m_curCluster = m_firstCluster + nNew;
    584e:	ldr	r2, [r4, #32]
    5850:	add	r3, r2
    5852:	str	r3, [r4, #16]
    goto done;
    5854:	b.n	5890 <FatFile::seekSet(unsigned long)+0x92>
  }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> (m_vol->bytesPerClusterShift());
    5856:	subs	r1, r5, #1
    5858:	lsr.w	r2, r1, r2

  if (nNew < nCur || m_curPosition == 0) {
    585c:	cmp	r3, r2
    585e:	bcc.n	5862 <FatFile::seekSet(unsigned long)+0x64>
    5860:	cbnz	r5, 5876 <FatFile::seekSet(unsigned long)+0x78>
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    5862:	lsls	r2, r0, #25
    5864:	ite	mi
    5866:	ldrmi.w	r2, [lr, #32]
    586a:	ldrpl	r2, [r4, #32]
    586c:	str	r2, [r4, #16]
    586e:	mov	r5, r3
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    5870:	add.w	r8, r4, #16
    5874:	b.n	588c <FatFile::seekSet(unsigned long)+0x8e>
  if (nNew < nCur || m_curPosition == 0) {
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    5876:	subs	r3, r3, r2
    5878:	b.n	586e <FatFile::seekSet(unsigned long)+0x70>
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    587a:	mov	r2, r8
    587c:	ldr	r1, [r4, #16]
    587e:	ldr	r0, [r4, #8]
    5880:	bl	6298 <FatPartition::fatGet(unsigned long, unsigned long*)>
    5884:	cmp	r0, #0
    5886:	add.w	r5, r5, #4294967295
    588a:	ble.n	589c <FatFile::seekSet(unsigned long)+0x9e>
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    588c:	cmp	r5, #0
    588e:	bne.n	587a <FatFile::seekSet(unsigned long)+0x7c>
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    5890:	ldrb	r3, [r4, #2]
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    5892:	str	r6, [r4, #20]
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    5894:	bic.w	r3, r3, #32
    5898:	strb	r3, [r4, #2]
    589a:	b.n	58a4 <FatFile::seekSet(unsigned long)+0xa6>
  return true;

 fail:
  m_curCluster = tmp;
    589c:	str	r7, [r4, #16]
  return false;
    589e:	movs	r0, #0
    58a0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    58a4:	movs	r0, #1
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    58a6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000058aa <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>:
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    58aa:	push	{r3, r4, r5, r6, r7, lr}
    58ac:	mov	r7, r1
    58ae:	mov	r6, r2
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    58b0:	movs	r1, #0
    58b2:	movs	r2, #36	; 0x24
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    58b4:	mov	r4, r0
    58b6:	mov	r5, r3
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    58b8:	bl	88dc <memset>
  // location of entry in cache
  m_vol = dirFile->m_vol;
    58bc:	ldr	r0, [r7, #8]
  m_dirIndex = dirIndex;
    58be:	strh	r6, [r4, #4]
    58c0:	add.w	r2, r0, #56	; 0x38
  m_dirCluster = dirFile->m_firstCluster;
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;
    58c4:	and.w	r6, r6, #15
    58c8:	add.w	r2, r2, r6, lsl #5
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    58cc:	ldr	r3, [r7, #32]
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
    58ce:	str	r0, [r4, #8]
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    58d0:	str	r3, [r4, #12]
    58d2:	ldrb	r1, [r2, #11]
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;

  // Must be file or subdirectory.
  if (!isFileOrSubdir(dir)) {
    58d4:	lsls	r6, r1, #28
    58d6:	bmi.n	5956 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
    58d8:	and.w	r1, r1, #23
    58dc:	strb	r1, [r4, #0]
  if (isFileDir(dir)) {
    58de:	ldrb	r3, [r2, #11]
    58e0:	tst.w	r3, #24
    m_attributes |= FILE_ATTR_FILE;
  }
  m_lfnOrd = lfnOrd;
    58e4:	ldrb.w	r3, [sp, #24]
    58e8:	strb	r3, [r4, #3]
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    m_attributes |= FILE_ATTR_FILE;
    58ea:	it	eq
    58ec:	orreq.w	r1, r1, #8
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    58f0:	and.w	r3, r5, #3
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    m_attributes |= FILE_ATTR_FILE;
    58f4:	it	eq
    58f6:	strbeq	r1, [r4, #0]
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    58f8:	cmp	r3, #1
    58fa:	beq.n	590e <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x64>
    58fc:	cmp	r3, #2
    58fe:	beq.n	590a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x60>
    5900:	cbnz	r3, 5956 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    case O_RDONLY:
      if (oflag & O_TRUNC) {
    5902:	lsls	r3, r5, #21
    5904:	bmi.n	5956 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
        DBG_FAIL_MACRO;
        goto fail;
      }
      m_flags = FILE_FLAG_READ;
    5906:	movs	r3, #1
    5908:	b.n	5910 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
      break;

    case O_RDWR:
      m_flags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    590a:	movs	r3, #3
    590c:	b.n	5910 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
      break;

    case O_WRONLY:
      m_flags = FILE_FLAG_WRITE;
    590e:	movs	r3, #2
    5910:	strb	r3, [r4, #2]
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }

  if (m_flags & FILE_FLAG_WRITE) {
    5912:	ldrb	r3, [r4, #2]
    5914:	lsls	r7, r3, #30
    5916:	bpl.n	5920 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x76>
    if (isSubDir() || isReadOnly()) {
    5918:	ldrb	r1, [r4, #0]
    591a:	tst.w	r1, #17
    591e:	bne.n	5956 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_flags |= (oflag & O_APPEND ? FILE_FLAG_APPEND : 0);
    5920:	and.w	r1, r5, #8
    5924:	orrs	r3, r1
    5926:	strb	r3, [r4, #2]
    5928:	ldr	r3, [r0, #52]	; 0x34

  m_dirSector = m_vol->cacheSectorNumber();
    592a:	str	r3, [r4, #24]

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    592c:	ldrh	r1, [r2, #20]
    592e:	ldrh	r3, [r2, #26]

  if (oflag & O_TRUNC) {
    5930:	lsls	r6, r5, #21

  m_dirSector = m_vol->cacheSectorNumber();

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    5932:	orr.w	r1, r3, r1, lsl #16

  if (oflag & O_TRUNC) {
    5936:	bpl.n	5942 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x98>
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
    5938:	cbz	r1, 595e <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xb4>
    593a:	bl	63de <FatPartition::freeChain(unsigned long)>
    593e:	cbnz	r0, 595e <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xb4>
    5940:	b.n	5956 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else {
    m_firstCluster = firstCluster;
    5942:	str	r1, [r4, #32]
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    5944:	ldr	r3, [r2, #28]
    m_fileSize = getLe32(dir->fileSize);
    5946:	str	r3, [r4, #28]
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    5948:	lsls	r3, r5, #17
    594a:	bpl.n	5968 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xbe>
    594c:	ldr	r1, [r4, #28]
    594e:	mov	r0, r4
    5950:	bl	57fe <FatFile::seekSet(unsigned long)>
    5954:	cbnz	r0, 5968 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xbe>
    goto fail;
  }
  return true;

 fail:
  m_attributes = FILE_ATTR_CLOSED;
    5956:	movs	r0, #0
    5958:	strb	r0, [r4, #0]
  m_flags = 0;
    595a:	strb	r0, [r4, #2]
  return false;
    595c:	pop	{r3, r4, r5, r6, r7, pc}
      DBG_FAIL_MACRO;
      goto fail;
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    595e:	ldrb	r3, [r4, #2]
    5960:	orn	r3, r3, #127	; 0x7f
    5964:	strb	r3, [r4, #2]
    5966:	b.n	5948 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x9e>
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return true;
    5968:	movs	r0, #1

 fail:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
    596a:	pop	{r3, r4, r5, r6, r7, pc}

0000596c <FatFile::openNext(FatFile*, int)>:
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    596c:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    5970:	ldrb	r3, [r0, #0]
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    5972:	mov	r6, r0
    5974:	mov	r5, r1
    5976:	mov	r9, r2
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    5978:	cbnz	r3, 59ea <FatFile::openNext(FatFile*, int)+0x7e>
    597a:	ldrb	r3, [r1, #0]
    597c:	tst.w	r3, #112	; 0x70
    5980:	beq.n	59ea <FatFile::openNext(FatFile*, int)+0x7e>
    5982:	ldr	r4, [r1, #20]
    5984:	ands.w	r4, r4, #31
    5988:	bne.n	59ea <FatFile::openNext(FatFile*, int)+0x7e>
    598a:	mov	r7, r4
    goto fail;
  }
  while (1) {
    // read entry into cache
    index = dirFile->curPosition()/32;
    DirFat_t* dir = dirFile->readDirCache();
    598c:	movs	r1, #0
    598e:	mov	r0, r5
    5990:	ldr.w	r8, [r5, #20]
    5994:	bl	57c4 <FatFile::readDirCache(bool)>
    if (!dir) {
    5998:	cbz	r0, 59ea <FatFile::openNext(FatFile*, int)+0x7e>
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    // done if last entry
    if (dir->name[0] == FAT_NAME_FREE) {
    599a:	ldrb	r3, [r0, #0]
    599c:	cbz	r3, 59ea <FatFile::openNext(FatFile*, int)+0x7e>
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
    599e:	cmp	r3, #46	; 0x2e
    59a0:	bne.n	59a6 <FatFile::openNext(FatFile*, int)+0x3a>
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
        lfnOrd = ldir->order & 0X1F;
        checksum = ldir->checksum;
      }
    } else {
      lfnOrd = 0;
    59a2:	movs	r4, #0
    59a4:	b.n	598c <FatFile::openNext(FatFile*, int)+0x20>
    // done if last entry
    if (dir->name[0] == FAT_NAME_FREE) {
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
    59a6:	cmp	r3, #229	; 0xe5
    59a8:	beq.n	59a2 <FatFile::openNext(FatFile*, int)+0x36>
    59aa:	ldrb	r2, [r0, #11]
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
    59ac:	and.w	lr, r2, #8
    59b0:	and.w	r1, lr, #255	; 0xff
    59b4:	cmp.w	lr, #0
    59b8:	bne.n	59da <FatFile::openNext(FatFile*, int)+0x6e>
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
    59ba:	cbz	r4, 59ee <FatFile::openNext(FatFile*, int)+0x82>
    59bc:	subs	r2, r0, #1
    59be:	adds	r0, #10
    59c0:	lsls	r3, r1, #7
    59c2:	orr.w	r1, r3, r1, lsr #1
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    59c6:	ldrb.w	r3, [r2, #1]!
    59ca:	uxtab	r1, r3, r1
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    59ce:	cmp	r0, r2
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    59d0:	uxtb	r1, r1
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    59d2:	bne.n	59c0 <FatFile::openNext(FatFile*, int)+0x54>
    59d4:	cmp	r7, r1
    59d6:	bne.n	59ea <FatFile::openNext(FatFile*, int)+0x7e>
    59d8:	b.n	59ee <FatFile::openNext(FatFile*, int)+0x82>
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      return true;
    } else if (isLongName(dir)) {
    59da:	cmp	r2, #15
    59dc:	bne.n	59a2 <FatFile::openNext(FatFile*, int)+0x36>
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
    59de:	lsls	r2, r3, #25
    59e0:	bpl.n	598c <FatFile::openNext(FatFile*, int)+0x20>
        lfnOrd = ldir->order & 0X1F;
    59e2:	and.w	r4, r3, #31
        checksum = ldir->checksum;
    59e6:	ldrb	r7, [r0, #13]
    59e8:	b.n	598c <FatFile::openNext(FatFile*, int)+0x20>
      lfnOrd = 0;
    }
  }

 fail:
  return false;
    59ea:	movs	r0, #0
    59ec:	b.n	59fe <FatFile::openNext(FatFile*, int)+0x92>
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
    59ee:	str	r4, [sp, #0]
    59f0:	mov	r3, r9
    59f2:	ubfx	r2, r8, #5, #16
    59f6:	mov	r1, r5
    59f8:	mov	r0, r6
    59fa:	bl	58aa <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    }
  }

 fail:
  return false;
}
    59fe:	add	sp, #12
    5a00:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00005a04 <FatFile::rmdir()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
    5a04:	push	{r4, lr}
  // must be open subdirectory
  if (!isSubDir() || (!USE_LONG_FILE_NAMES && isLFN())) {
    5a06:	ldrb	r3, [r0, #0]
    5a08:	lsls	r2, r3, #27

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
    5a0a:	mov	r4, r0
  // must be open subdirectory
  if (!isSubDir() || (!USE_LONG_FILE_NAMES && isLFN())) {
    5a0c:	bpl.n	5a4e <FatFile::rmdir()+0x4a>
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    5a0e:	movs	r1, #0
    5a10:	bl	57fe <FatFile::seekSet(unsigned long)>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    DirFat_t* dir = readDirCache(true);
    5a14:	movs	r1, #1
    5a16:	mov	r0, r4
    5a18:	bl	57c4 <FatFile::readDirCache(bool)>
    if (!dir) {
    5a1c:	cbnz	r0, 5a24 <FatFile::rmdir()+0x20>
      // EOF if no error.
      if (!getError()) {
    5a1e:	ldrb	r3, [r4, #1]
    5a20:	cbz	r3, 5a38 <FatFile::rmdir()+0x34>
    5a22:	b.n	5a4e <FatFile::rmdir()+0x4a>
      }
      DBG_FAIL_MACRO;
      goto fail;
    }
    // done if past last used entry
    if (dir->name[0] == FAT_NAME_FREE) {
    5a24:	ldrb	r3, [r0, #0]
    5a26:	cbz	r3, 5a38 <FatFile::rmdir()+0x34>
      break;
    }
    // skip empty slot, '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    5a28:	cmp	r3, #229	; 0xe5
    5a2a:	beq.n	5a14 <FatFile::rmdir()+0x10>
    5a2c:	cmp	r3, #46	; 0x2e
    5a2e:	beq.n	5a14 <FatFile::rmdir()+0x10>
      continue;
    }
    // error not empty
    if (isFileOrSubdir(dir)) {
    5a30:	ldrb	r3, [r0, #11]
    5a32:	lsls	r3, r3, #28
    5a34:	bmi.n	5a14 <FatFile::rmdir()+0x10>
    5a36:	b.n	5a4e <FatFile::rmdir()+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    5a38:	movs	r3, #8
    5a3a:	strb	r3, [r4, #0]
  m_flags |= FILE_FLAG_WRITE;
    5a3c:	ldrb	r3, [r4, #2]
    5a3e:	orr.w	r3, r3, #2
    5a42:	strb	r3, [r4, #2]
  return remove();
    5a44:	mov	r0, r4

 fail:
  return false;
}
    5a46:	ldmia.w	sp!, {r4, lr}
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    5a4a:	b.w	6c00 <FatFile::remove()>

 fail:
  return false;
}
    5a4e:	movs	r0, #0
    5a50:	pop	{r4, pc}
    5a52:	Address 0x00005a52 is out of bounds.


00005a54 <FatFile::sync()>:
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    5a54:	push	{r0, r1, r2, r4, r5, lr}
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    5a56:	ldrb	r3, [r0, #0]
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    5a58:	mov	r4, r0
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    5a5a:	cmp	r3, #0
    5a5c:	beq.n	5ac8 <FatFile::sync()+0x74>
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    5a5e:	ldrsb.w	r3, [r0, #2]
    5a62:	cmp	r3, #0
    5a64:	bge.n	5abc <FatFile::sync()+0x68>
    DirFat_t* dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    5a66:	movs	r1, #1
    5a68:	bl	55a8 <FatFile::cacheDirEntry(unsigned char)>
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
    5a6c:	mov	r5, r0
    5a6e:	cbnz	r0, 5a7c <FatFile::sync()+0x28>
    return true;
  }
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
    5a70:	ldrb	r3, [r4, #1]
    5a72:	orr.w	r3, r3, #1
    5a76:	strb	r3, [r4, #1]
  return false;
    5a78:	movs	r0, #0
    5a7a:	b.n	5aca <FatFile::sync()+0x76>
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    DirFat_t* dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
    5a7c:	ldrb	r3, [r0, #0]
    5a7e:	cmp	r3, #229	; 0xe5
    5a80:	beq.n	5a70 <FatFile::sync()+0x1c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // do not set filesize for dir files
    if (isFile()) {
    5a82:	ldrb	r3, [r4, #0]
    5a84:	lsls	r3, r3, #28
      setLe32(dir->fileSize, m_fileSize);
    5a86:	itt	mi
    5a88:	ldrmi	r3, [r4, #28]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    5a8a:	strmi	r3, [r0, #28]
    }
    // update first cluster fields
    setLe16(dir->firstClusterLow, m_firstCluster & 0XFFFF);
    5a8c:	ldr	r3, [r4, #32]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    5a8e:	strh	r3, [r0, #26]
    5a90:	lsrs	r3, r3, #16
    5a92:	strh	r3, [r0, #20]
    setLe16(dir->firstClusterHigh, m_firstCluster >> 16);

    // set modify time if user supplied a callback date/time function
    if (FsDateTime::callback) {
    5a94:	ldr	r3, [pc, #56]	; (5ad0 <FatFile::sync()+0x7c>)
    5a96:	ldr	r3, [r3, #0]
    5a98:	cbz	r3, 5ab4 <FatFile::sync()+0x60>
      FsDateTime::callback(&date, &time, &ms10);
    5a9a:	add.w	r2, sp, #3
    5a9e:	add.w	r1, sp, #6
    5aa2:	add	r0, sp, #4
    5aa4:	blx	r3
      setLe16(dir->modifyDate, date);
    5aa6:	ldrh.w	r3, [sp, #4]
    5aaa:	strh	r3, [r5, #24]
    5aac:	strh	r3, [r5, #18]
    5aae:	ldrh.w	r3, [sp, #6]
    5ab2:	strh	r3, [r5, #22]
      setLe16(dir->accessDate, date);
      setLe16(dir->modifyTime, time);
    }
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    5ab4:	ldrb	r3, [r4, #2]
    5ab6:	and.w	r3, r3, #127	; 0x7f
    5aba:	strb	r3, [r4, #2]
  }
  if (m_vol->cacheSync()) {
    5abc:	ldr	r0, [r4, #8]
    5abe:	bl	54c0 <FatPartition::cacheSync()>
    5ac2:	cmp	r0, #0
    5ac4:	beq.n	5a70 <FatFile::sync()+0x1c>
    5ac6:	b.n	5aca <FatFile::sync()+0x76>
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
    5ac8:	movs	r0, #1
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    5aca:	add	sp, #12
    5acc:	pop	{r4, r5, pc}
    5ace:	nop
    5ad0:	.word	0x1fff8418

00005ad4 <FatFile::close()>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
    5ad4:	push	{r4, lr}
    5ad6:	mov	r4, r0
  bool rtn = sync();
    5ad8:	bl	5a54 <FatFile::sync()>
  m_attributes = FILE_ATTR_CLOSED;
    5adc:	movs	r3, #0
    5ade:	strb	r3, [r4, #0]
  m_flags = 0;
    5ae0:	strb	r3, [r4, #2]
  return rtn;
}
    5ae2:	pop	{r4, pc}

00005ae4 <FatFile::open(FatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    5ae4:	push	{r4, r5, r6, r7, lr}
    5ae6:	sub	sp, #84	; 0x54
    5ae8:	mov	r7, r3
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    5aea:	movs	r3, #0
    5aec:	strb.w	r3, [sp, #8]
    5af0:	strb.w	r3, [sp, #9]
    5af4:	strb.w	r3, [sp, #10]
    5af8:	strh.w	r3, [sp, #56]	; 0x38
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    5afc:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    5afe:	str	r2, [sp, #4]
    5b00:	mov	r6, r0
    5b02:	mov	r4, r1
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    5b04:	cbz	r3, 5b0a <FatFile::open(FatFile*, char const*, int)+0x26>
    close();
  }
  return open(dirFile, &fname, oflag);

 fail:
  return false;
    5b06:	movs	r0, #0
    5b08:	b.n	5b88 <FatFile::open(FatFile*, char const*, int)+0xa4>
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    5b0a:	ldrb	r3, [r1, #0]
    5b0c:	tst.w	r3, #112	; 0x70
    5b10:	beq.n	5b06 <FatFile::open(FatFile*, char const*, int)+0x22>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    5b12:	ldrb	r3, [r2, #0]
    5b14:	cmp	r3, #47	; 0x2f
    5b16:	bne.n	5b3e <FatFile::open(FatFile*, char const*, int)+0x5a>
    while (isDirSeparator(*path)) {
    5b18:	ldr	r3, [sp, #4]
    5b1a:	ldrb	r2, [r3, #0]
    5b1c:	cmp	r2, #47	; 0x2f
    5b1e:	bne.n	5b26 <FatFile::open(FatFile*, char const*, int)+0x42>
      path++;
    5b20:	adds	r3, #1
    5b22:	str	r3, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    5b24:	b.n	5b18 <FatFile::open(FatFile*, char const*, int)+0x34>
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    5b26:	ldr	r1, [r4, #8]
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
    5b28:	cbnz	r2, 5b32 <FatFile::open(FatFile*, char const*, int)+0x4e>
      return openRoot(dirFile->m_vol);
    5b2a:	mov	r0, r6
    5b2c:	bl	55c6 <FatFile::openRoot(FatVolume*)>
    5b30:	b.n	5b88 <FatFile::open(FatFile*, char const*, int)+0xa4>
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    5b32:	add	r0, sp, #8
    5b34:	bl	55c6 <FatFile::openRoot(FatVolume*)>
    5b38:	cmp	r0, #0
    5b3a:	beq.n	5b06 <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    5b3c:	add	r4, sp, #8
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    5b3e:	add	r3, sp, #4
    5b40:	add	r2, sp, #44	; 0x2c
    5b42:	ldr	r1, [sp, #4]
    5b44:	mov	r0, r6
    5b46:	bl	6b68 <FatFile::parsePathName(char const*, FatName_t*, char const**)>
    5b4a:	cmp	r0, #0
    5b4c:	beq.n	5b06 <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    5b4e:	ldr	r3, [sp, #4]
    5b50:	ldrb	r3, [r3, #0]
    5b52:	cbz	r3, 5b7c <FatFile::open(FatFile*, char const*, int)+0x98>
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    5b54:	movs	r3, #0
    5b56:	add	r2, sp, #44	; 0x2c
    5b58:	mov	r1, r4
    5b5a:	mov	r0, r6
    5b5c:	bl	6918 <FatFile::open(FatFile*, FatName_t*, int)>
    5b60:	cmp	r0, #0
    5b62:	beq.n	5b06 <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_WARN_MACRO;
      goto fail;
    }
    tmpDir = *this;
    5b64:	mov	r5, r6
    5b66:	ldmia	r5!, {r0, r1, r2, r3}
    5b68:	add	r4, sp, #8
    5b6a:	stmia	r4!, {r0, r1, r2, r3}
    5b6c:	ldmia	r5!, {r0, r1, r2, r3}
    5b6e:	stmia	r4!, {r0, r1, r2, r3}
    5b70:	ldr	r3, [r5, #0]
    5b72:	str	r3, [r4, #0]
    dirFile = &tmpDir;
    close();
    5b74:	mov	r0, r6
    5b76:	bl	5ad4 <FatFile::close()>
    5b7a:	b.n	5b3c <FatFile::open(FatFile*, char const*, int)+0x58>
  }
  return open(dirFile, &fname, oflag);
    5b7c:	mov	r3, r7
    5b7e:	add	r2, sp, #44	; 0x2c
    5b80:	mov	r1, r4
    5b82:	mov	r0, r6
    5b84:	bl	6918 <FatFile::open(FatFile*, FatName_t*, int)>

 fail:
  return false;
}
    5b88:	add	sp, #84	; 0x54
    5b8a:	pop	{r4, r5, r6, r7, pc}

00005b8c <FatFile::open(FatVolume*, char const*, int)>:
bool FatFile::open(const char* path, oflag_t oflag) {
  return open(FatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
    5b8c:	cbz	r1, 5b96 <FatFile::open(FatVolume*, char const*, int)+0xa>
    5b8e:	add.w	r1, r1, #1096	; 0x448
    5b92:	b.w	5ae4 <FatFile::open(FatFile*, char const*, int)>
}
    5b96:	mov	r0, r1
    5b98:	bx	lr

00005b9a <FatFile::dirEntry(DirFat_t*)>:
  close();
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::dirEntry(DirFat_t* dst) {
    5b9a:	push	{r4, r5, r6, lr}
    5b9c:	mov	r6, r0
    5b9e:	mov	r4, r1
  DirFat_t* dir;
  // Make sure fields on device are correct.
  if (!sync()) {
    5ba0:	bl	5a54 <FatFile::sync()>
    5ba4:	mov	r5, r0
    5ba6:	cbnz	r0, 5bac <FatFile::dirEntry(DirFat_t*)+0x12>
  // copy to caller's struct
  memcpy(dst, dir, sizeof(DirFat_t));
  return true;

 fail:
  return false;
    5ba8:	movs	r5, #0
    5baa:	b.n	5bca <FatFile::dirEntry(DirFat_t*)+0x30>
  if (!sync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    5bac:	movs	r1, #0
    5bae:	mov	r0, r6
    5bb0:	bl	55a8 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    5bb4:	cmp	r0, #0
    5bb6:	beq.n	5ba8 <FatFile::dirEntry(DirFat_t*)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy to caller's struct
  memcpy(dst, dir, sizeof(DirFat_t));
    5bb8:	mov	r1, r4
    5bba:	add.w	r3, r0, #32
    5bbe:	ldr.w	r2, [r0], #4
    5bc2:	str.w	r2, [r1], #4
    5bc6:	cmp	r0, r3
    5bc8:	bne.n	5bbe <FatFile::dirEntry(DirFat_t*)+0x24>
  return true;

 fail:
  return false;
}
    5bca:	mov	r0, r5
    5bcc:	pop	{r4, r5, r6, pc}

00005bce <FatFile::getCreateDateTime(unsigned short*, unsigned short*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    5bce:	push	{r4, r5, lr}
    5bd0:	sub	sp, #36	; 0x24
    5bd2:	mov	r5, r1
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    5bd4:	mov	r1, sp

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    5bd6:	mov	r4, r2
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    5bd8:	bl	5b9a <FatFile::dirEntry(DirFat_t*)>
    5bdc:	cbz	r0, 5bea <FatFile::getCreateDateTime(unsigned short*, unsigned short*)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(dir.createDate);
    5bde:	ldrh.w	r3, [sp, #16]
    5be2:	strh	r3, [r5, #0]
  *ptime = getLe16(dir.createTime);
    5be4:	ldrh.w	r3, [sp, #14]
    5be8:	strh	r3, [r4, #0]
  return true;

 fail:
  return false;
}
    5bea:	add	sp, #36	; 0x24
    5bec:	pop	{r4, r5, pc}

00005bee <FatFile::getModifyDateTime(unsigned short*, unsigned short*)>:
//------------------------------------------------------------------------------
bool FatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    5bee:	push	{r4, r5, lr}
    5bf0:	sub	sp, #36	; 0x24
    5bf2:	mov	r5, r1
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    5bf4:	mov	r1, sp

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    5bf6:	mov	r4, r2
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    5bf8:	bl	5b9a <FatFile::dirEntry(DirFat_t*)>
    5bfc:	cbz	r0, 5c0a <FatFile::getModifyDateTime(unsigned short*, unsigned short*)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(dir.modifyDate);
    5bfe:	ldrh.w	r3, [sp, #24]
    5c02:	strh	r3, [r5, #0]
  *ptime = getLe16(dir.modifyTime);
    5c04:	ldrh.w	r3, [sp, #22]
    5c08:	strh	r3, [r4, #0]
  return true;

 fail:
  return false;
}
    5c0a:	add	sp, #36	; 0x24
    5c0c:	pop	{r4, r5, pc}

00005c0e <FatFile::mkdir(FatFile*, FatName_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, FatName_t* fname) {
    5c0e:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    5c12:	ldrb	r3, [r1, #0]
    5c14:	tst.w	r3, #112	; 0x70

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, FatName_t* fname) {
    5c18:	sub	sp, #32
    5c1a:	mov	r4, r0
    5c1c:	mov	r6, r1
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    5c1e:	beq.n	5c5a <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    5c20:	movw	r3, #2562	; 0xa02
    5c24:	bl	6918 <FatFile::open(FatFile*, FatName_t*, int)>
    5c28:	cbz	r0, 5c5a <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    5c2a:	movs	r7, #1
  m_attributes = FILE_ATTR_SUBDIR;
    5c2c:	movs	r5, #16
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    5c2e:	strb	r7, [r4, #2]
  m_attributes = FILE_ATTR_SUBDIR;
    5c30:	strb	r5, [r4, #0]

  // allocate and zero first cluster
  if (!addDirCluster()) {
    5c32:	mov	r0, r4
    5c34:	bl	551c <FatFile::addDirCluster()>
    5c38:	cbz	r0, 5c5a <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    5c3a:	ldr	r3, [r4, #16]
    5c3c:	str	r3, [r4, #32]
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    5c3e:	movs	r1, #0
    5c40:	mov	r0, r4
    5c42:	bl	57fe <FatFile::seekSet(unsigned long)>
  // Set to start of dir
  rewind();
  // force entry to device
  if (!sync()) {
    5c46:	mov	r0, r4
    5c48:	bl	5a54 <FatFile::sync()>
    5c4c:	cbz	r0, 5c5a <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // cache entry - should already be in cache due to sync() call
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    5c4e:	mov	r1, r7
    5c50:	mov	r0, r4
    5c52:	bl	55a8 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    5c56:	mov	r3, r0
    5c58:	cbnz	r0, 5c5e <FatFile::mkdir(FatFile*, FatName_t*)+0x50>
  memcpy(&pc->dir[1], &dot, sizeof(dot));
  // write first sector
  return m_vol->cacheSync();

 fail:
  return false;
    5c5a:	movs	r0, #0
    5c5c:	b.n	5d02 <FatFile::mkdir(FatFile*, FatName_t*)+0xf4>
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // change directory entry attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;
    5c5e:	strb	r5, [r0, #11]

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
    5c60:	mov	r2, r0
    5c62:	mov	r7, sp
    5c64:	add.w	ip, r0, #32
    5c68:	mov	r5, sp
    5c6a:	ldr	r0, [r2, #0]
    5c6c:	ldr	r1, [r2, #4]
    5c6e:	mov	lr, r7
    5c70:	stmia.w	lr!, {r0, r1}
    5c74:	adds	r2, #8
    5c76:	cmp	r2, ip
    5c78:	mov	r7, lr
    5c7a:	bne.n	5c6a <FatFile::mkdir(FatFile*, FatName_t*)+0x5c>
    5c7c:	ldrh	r7, [r3, #20]
    5c7e:	ldrh.w	r8, [r3, #26]
  dot.name[0] = '.';
    5c82:	movs	r3, #46	; 0x2e
    5c84:	strb.w	r3, [sp]
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    5c88:	movs	r1, #32
  // change directory entry attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
    5c8a:	movs	r3, #0
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    5c8c:	adds	r2, r5, r3
    5c8e:	adds	r3, #1
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    5c90:	cmp	r3, #10
    dot.name[i] = ' ';
    5c92:	strb	r1, [r2, #1]
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    5c94:	bne.n	5c8c <FatFile::mkdir(FatFile*, FatName_t*)+0x7e>
    dot.name[i] = ' ';
  }

  // cache sector for '.'  and '..'
  sector = m_vol->clusterStartSector(m_firstCluster);
    5c96:	ldr	r0, [r4, #8]
    5c98:	ldr	r1, [r4, #32]
    5c9a:	ldrb	r3, [r0, #6]
    5c9c:	subs	r1, #2
    5c9e:	lsls	r1, r3
    5ca0:	ldr	r3, [r0, #20]
    5ca2:	movs	r2, #1
    5ca4:	add	r1, r3
    5ca6:	adds	r0, #40	; 0x28
    5ca8:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
  if (!pc) {
    5cac:	mov	r3, r0
    5cae:	cmp	r0, #0
    5cb0:	beq.n	5c5a <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
    5cb2:	strh.w	r7, [sp, #20]
    5cb6:	strh.w	r8, [sp, #26]
    5cba:	mov	lr, r5
    5cbc:	mov	r7, r0
    5cbe:	add.w	ip, sp, #32
    5cc2:	mov	r2, lr
    5cc4:	ldmia	r2!, {r0, r1}
    5cc6:	cmp	r2, ip
    5cc8:	str	r0, [r7, #0]
    5cca:	str	r1, [r7, #4]
    5ccc:	mov	lr, r2
    5cce:	add.w	r7, r7, #8
    5cd2:	bne.n	5cc2 <FatFile::mkdir(FatFile*, FatName_t*)+0xb4>
  // make entry for '..'
  dot.name[1] = '.';
    5cd4:	movs	r2, #46	; 0x2e
    5cd6:	strb.w	r2, [sp, #1]
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
    5cda:	ldr	r2, [r6, #32]
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    5cdc:	strh.w	r2, [sp, #26]
    5ce0:	lsrs	r1, r2, #16
    5ce2:	strh.w	r1, [sp, #20]
    5ce6:	adds	r3, #32
    5ce8:	add	r6, sp, #32
    5cea:	mov	r2, r5
    5cec:	ldmia	r2!, {r0, r1}
    5cee:	cmp	r2, r6
    5cf0:	str	r0, [r3, #0]
    5cf2:	str	r1, [r3, #4]
    5cf4:	mov	r5, r2
    5cf6:	add.w	r3, r3, #8
    5cfa:	bne.n	5cea <FatFile::mkdir(FatFile*, FatName_t*)+0xdc>
  // write first sector
  return m_vol->cacheSync();
    5cfc:	ldr	r0, [r4, #8]
    5cfe:	bl	54c0 <FatPartition::cacheSync()>

 fail:
  return false;
}
    5d02:	add	sp, #32
    5d04:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00005d08 <FatFile::mkdir(FatFile*, char const*, bool)>:
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    5d08:	push	{r4, r5, r6, r7, lr}
    5d0a:	sub	sp, #84	; 0x54
    5d0c:	mov	r7, r3
    5d0e:	movs	r3, #0
    5d10:	strh.w	r3, [sp, #20]
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    5d14:	strb.w	r3, [sp, #44]	; 0x2c
    5d18:	strb.w	r3, [sp, #45]	; 0x2d
    5d1c:	strb.w	r3, [sp, #46]	; 0x2e
  FatName_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    5d20:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    5d22:	str	r2, [sp, #4]
    5d24:	mov	r6, r0
    5d26:	mov	r4, r1
  FatName_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    5d28:	cmp	r3, #0
    5d2a:	bne.n	5dac <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    5d2c:	ldrb	r3, [r1, #0]
    5d2e:	tst.w	r3, #112	; 0x70
    5d32:	beq.n	5dac <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    5d34:	ldrb	r3, [r2, #0]
    5d36:	cmp	r3, #47	; 0x2f
    5d38:	bne.n	5d54 <FatFile::mkdir(FatFile*, char const*, bool)+0x4c>
    while (isDirSeparator(*path)) {
    5d3a:	ldr	r3, [sp, #4]
    5d3c:	ldrb	r2, [r3, #0]
    5d3e:	cmp	r2, #47	; 0x2f
    5d40:	bne.n	5d48 <FatFile::mkdir(FatFile*, char const*, bool)+0x40>
      path++;
    5d42:	adds	r3, #1
    5d44:	str	r3, [sp, #4]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    5d46:	b.n	5d3a <FatFile::mkdir(FatFile*, char const*, bool)+0x32>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    5d48:	ldr	r1, [r4, #8]
    5d4a:	add	r0, sp, #44	; 0x2c
    5d4c:	bl	55c6 <FatFile::openRoot(FatVolume*)>
    5d50:	cbz	r0, 5dac <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    5d52:	add	r4, sp, #44	; 0x2c
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    5d54:	add	r3, sp, #4
    5d56:	add	r2, sp, #8
    5d58:	ldr	r1, [sp, #4]
    5d5a:	mov	r0, r6
    5d5c:	bl	6b68 <FatFile::parsePathName(char const*, FatName_t*, char const**)>
    5d60:	cbz	r0, 5dac <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    5d62:	ldr	r3, [sp, #4]
    5d64:	ldrb	r3, [r3, #0]
    5d66:	cbz	r3, 5da0 <FatFile::mkdir(FatFile*, char const*, bool)+0x98>
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    5d68:	movs	r3, #0
    5d6a:	add	r2, sp, #8
    5d6c:	mov	r1, r4
    5d6e:	mov	r0, r6
    5d70:	bl	6918 <FatFile::open(FatFile*, FatName_t*, int)>
    5d74:	cbz	r0, 5d8e <FatFile::mkdir(FatFile*, char const*, bool)+0x86>
      if (!pFlag || !mkdir(parent, &fname)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    5d76:	mov	r5, r6
    5d78:	ldmia	r5!, {r0, r1, r2, r3}
    5d7a:	add	r4, sp, #44	; 0x2c
    5d7c:	stmia	r4!, {r0, r1, r2, r3}
    5d7e:	ldmia	r5!, {r0, r1, r2, r3}
    5d80:	stmia	r4!, {r0, r1, r2, r3}
    5d82:	ldr	r3, [r5, #0]
    5d84:	str	r3, [r4, #0]
    parent = &tmpDir;
    close();
    5d86:	mov	r0, r6
    5d88:	bl	5ad4 <FatFile::close()>
    5d8c:	b.n	5d52 <FatFile::mkdir(FatFile*, char const*, bool)+0x4a>
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
      if (!pFlag || !mkdir(parent, &fname)) {
    5d8e:	cbz	r7, 5dac <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    5d90:	add	r2, sp, #8
    5d92:	mov	r1, r4
    5d94:	mov	r0, r6
    5d96:	bl	5c0e <FatFile::mkdir(FatFile*, FatName_t*)>
    5d9a:	cmp	r0, #0
    5d9c:	bne.n	5d76 <FatFile::mkdir(FatFile*, char const*, bool)+0x6e>
    5d9e:	b.n	5dac <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    5da0:	add	r2, sp, #8
    5da2:	mov	r1, r4
    5da4:	mov	r0, r6
    5da6:	bl	5c0e <FatFile::mkdir(FatFile*, FatName_t*)>
    5daa:	b.n	5dae <FatFile::mkdir(FatFile*, char const*, bool)+0xa6>

 fail:
  return false;
    5dac:	movs	r0, #0
}
    5dae:	add	sp, #84	; 0x54
    5db0:	pop	{r4, r5, r6, r7, pc}

00005db2 <FatFile::rename(FatFile*, char const*)>:
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    5db2:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    5db6:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    5db8:	sub	sp, #108	; 0x6c
    5dba:	movs	r7, #0
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    5dbc:	tst.w	r3, #24
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    5dc0:	mov	r4, r0
    5dc2:	mov	r8, r1
    5dc4:	mov	r9, r2
    5dc6:	strb.w	r7, [sp, #32]
    5dca:	strb.w	r7, [sp, #33]	; 0x21
    5dce:	strb.w	r7, [sp, #34]	; 0x22
    5dd2:	strb.w	r7, [sp, #68]	; 0x44
    5dd6:	strb.w	r7, [sp, #69]	; 0x45
    5dda:	strb.w	r7, [sp, #70]	; 0x46
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    5dde:	bne.n	5de4 <FatFile::rename(FatFile*, char const*)+0x32>
    goto fail;
  }
  return m_vol->cacheSync();

 fail:
  return false;
    5de0:	movs	r0, #0
    5de2:	b.n	5f42 <FatFile::rename(FatFile*, char const*)+0x190>
  if (!USE_LONG_FILE_NAMES && isLFN()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    5de4:	ldr	r2, [r0, #8]
    5de6:	ldr	r3, [r1, #8]
    5de8:	cmp	r2, r3
    5dea:	bne.n	5de0 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // sync() and cache directory entry
  sync();
  oldFile = *this;
    5dec:	mov	r6, r4
  if (m_vol != dirFile->m_vol) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // sync() and cache directory entry
  sync();
    5dee:	bl	5a54 <FatFile::sync()>
  oldFile = *this;
    5df2:	ldmia	r6!, {r0, r1, r2, r3}
    5df4:	add	r5, sp, #68	; 0x44
    5df6:	stmia	r5!, {r0, r1, r2, r3}
    5df8:	ldmia	r6!, {r0, r1, r2, r3}
    5dfa:	stmia	r5!, {r0, r1, r2, r3}
    5dfc:	ldr	r3, [r6, #0]
    5dfe:	str	r3, [r5, #0]
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    5e00:	mov	r1, r7
    5e02:	mov	r0, r4
    5e04:	bl	55a8 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    5e08:	cmp	r0, #0
    5e0a:	beq.n	5de0 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    5e0c:	mov	r3, r0
    5e0e:	mov	r2, sp
    5e10:	add.w	r7, r0, #32
    5e14:	mov	r5, sp
    5e16:	ldr	r0, [r3, #0]
    5e18:	ldr	r1, [r3, #4]
    5e1a:	mov	r6, r2
    5e1c:	stmia	r6!, {r0, r1}
    5e1e:	adds	r3, #8
    5e20:	cmp	r3, r7
    5e22:	mov	r2, r6
    5e24:	bne.n	5e16 <FatFile::rename(FatFile*, char const*)+0x64>
  // make directory entry for new path
  if (isFile()) {
    5e26:	ldrb	r2, [r4, #0]
    5e28:	and.w	r2, r2, #8
    5e2c:	and.w	r3, r2, #255	; 0xff
    5e30:	add	r6, sp, #32
    5e32:	cbz	r2, 5e4a <FatFile::rename(FatFile*, char const*)+0x98>
    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    5e34:	movw	r3, #2561	; 0xa01
    5e38:	mov	r2, r9
    5e3a:	mov	r1, r8
    5e3c:	mov	r0, r6
    5e3e:	bl	5ae4 <FatFile::open(FatFile*, char const*, int)>
    5e42:	cmp	r0, #0
    5e44:	beq.n	5de0 <FatFile::rename(FatFile*, char const*)+0x2e>
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
  DirFat_t entry;
  uint32_t dirCluster = 0;
    5e46:	movs	r7, #0
    5e48:	b.n	5e5a <FatFile::rename(FatFile*, char const*)+0xa8>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // don't create missing path prefix components
    if (!file.mkdir(dirFile, newPath, false)) {
    5e4a:	mov	r2, r9
    5e4c:	mov	r1, r8
    5e4e:	mov	r0, r6
    5e50:	bl	5d08 <FatFile::mkdir(FatFile*, char const*, bool)>
    5e54:	cmp	r0, #0
    5e56:	beq.n	5de0 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
    5e58:	ldr	r7, [sp, #64]	; 0x40
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
    5e5a:	ldr	r3, [sp, #56]	; 0x38
    5e5c:	str	r3, [r4, #24]
  m_dirIndex = file.m_dirIndex;
    5e5e:	ldrh.w	r3, [sp, #36]	; 0x24
    5e62:	strh	r3, [r4, #4]
  m_lfnOrd = file.m_lfnOrd;
    5e64:	ldrb.w	r3, [sp, #35]	; 0x23
    5e68:	strb	r3, [r4, #3]
  m_dirCluster = file.m_dirCluster;
    5e6a:	ldr	r3, [sp, #44]	; 0x2c
    5e6c:	str	r3, [r4, #12]
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    5e6e:	movs	r1, #1
  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    5e70:	movs	r3, #0
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    5e72:	mov	r0, r4
  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    5e74:	strb.w	r3, [sp, #32]
  file.m_flags = 0;
    5e78:	strb.w	r3, [sp, #34]	; 0x22

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    5e7c:	bl	55a8 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    5e80:	cmp	r0, #0
    5e82:	beq.n	5de0 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy all but name and name flags to new directory entry
  memcpy(&dir->createTimeMs, &entry.createTimeMs,
         sizeof(entry) - sizeof(dir->name) - 2);
    5e84:	add.w	r3, sp, #13
    5e88:	add.w	r2, r0, #13
    5e8c:	add.w	r1, sp, #29
    5e90:	ldr.w	lr, [r3], #4
    5e94:	str.w	lr, [r2], #4
    5e98:	cmp	r3, r1
    5e9a:	bne.n	5e90 <FatFile::rename(FatFile*, char const*)+0xde>
    5e9c:	ldrh	r1, [r3, #0]
    5e9e:	strh	r1, [r2, #0]
    5ea0:	ldrb	r3, [r3, #2]
    5ea2:	strb	r3, [r2, #2]
  dir->attributes = entry.attributes;
    5ea4:	ldrb.w	r3, [sp, #11]
    5ea8:	strb	r3, [r0, #11]

  // update dot dot if directory
  if (dirCluster) {
    5eaa:	cmp	r7, #0
    5eac:	beq.n	5f20 <FatFile::rename(FatFile*, char const*)+0x16e>
    // get new dot dot
    uint32_t sector = m_vol->clusterStartSector(dirCluster);
    5eae:	ldr	r0, [r4, #8]
    5eb0:	ldrb	r1, [r0, #6]
    5eb2:	subs	r3, r7, #2
    5eb4:	lsls	r3, r1
    5eb6:	ldr	r1, [r0, #20]
    5eb8:	movs	r2, #0
    5eba:	add	r1, r3
    5ebc:	adds	r0, #40	; 0x28
    5ebe:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    5ec2:	cmp	r0, #0
    5ec4:	beq.n	5de0 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&entry, &pc->dir[1], sizeof(entry));
    5ec6:	add.w	r3, r0, #32
    5eca:	mov	lr, r5
    5ecc:	add.w	ip, r0, #64	; 0x40
    5ed0:	ldr	r0, [r3, #0]
    5ed2:	ldr	r1, [r3, #4]
    5ed4:	mov	r2, lr
    5ed6:	stmia	r2!, {r0, r1}
    5ed8:	adds	r3, #8
    5eda:	cmp	r3, ip
    5edc:	mov	lr, r2
    5ede:	bne.n	5ed0 <FatFile::rename(FatFile*, char const*)+0x11e>

    // free unused cluster
    if (!m_vol->freeChain(dirCluster)) {
    5ee0:	mov	r1, r7
    5ee2:	ldr	r0, [r4, #8]
    5ee4:	bl	63de <FatPartition::freeChain(unsigned long)>
    5ee8:	cmp	r0, #0
    5eea:	beq.w	5de0 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // store new dot dot
    sector = m_vol->clusterStartSector(m_firstCluster);
    5eee:	ldr	r0, [r4, #8]
    5ef0:	ldr	r1, [r4, #32]
    5ef2:	ldrb	r3, [r0, #6]
    5ef4:	subs	r1, #2
    5ef6:	lsls	r1, r3
    5ef8:	ldr	r3, [r0, #20]
    5efa:	movs	r2, #1
    5efc:	add	r1, r3
    5efe:	adds	r0, #40	; 0x28
    5f00:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    5f04:	cmp	r0, #0
    5f06:	beq.w	5de0 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&pc->dir[1], &entry, sizeof(entry));
    5f0a:	add.w	r3, r0, #32
    5f0e:	mov	r2, r5
    5f10:	ldmia	r2!, {r0, r1}
    5f12:	cmp	r2, r6
    5f14:	str	r0, [r3, #0]
    5f16:	str	r1, [r3, #4]
    5f18:	mov	r5, r2
    5f1a:	add.w	r3, r3, #8
    5f1e:	bne.n	5f0e <FatFile::rename(FatFile*, char const*)+0x15c>
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    5f20:	movs	r3, #0
    5f22:	str	r3, [sp, #100]	; 0x64
  oldFile.m_flags = FILE_FLAG_WRITE;
    5f24:	movs	r3, #2
    5f26:	strb.w	r3, [sp, #70]	; 0x46
  oldFile.m_attributes = FILE_ATTR_FILE;
  if (!oldFile.remove()) {
    5f2a:	add	r0, sp, #68	; 0x44
    memcpy(&pc->dir[1], &entry, sizeof(entry));
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
    5f2c:	movs	r3, #8
    5f2e:	strb.w	r3, [sp, #68]	; 0x44
  if (!oldFile.remove()) {
    5f32:	bl	6c00 <FatFile::remove()>
    5f36:	cmp	r0, #0
    5f38:	beq.w	5de0 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return m_vol->cacheSync();
    5f3c:	ldr	r0, [r4, #8]
    5f3e:	bl	54c0 <FatPartition::cacheSync()>

 fail:
  return false;
}
    5f42:	add	sp, #108	; 0x6c
    5f44:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00005f48 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    5f48:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5f4c:	mov	r4, r3
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    5f4e:	ldrb	r3, [r0, #0]
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    5f50:	ldrb.w	fp, [sp, #40]	; 0x28
    5f54:	ldrb.w	r9, [sp, #44]	; 0x2c
    5f58:	ldrb.w	sl, [sp, #48]	; 0x30
    5f5c:	ldrb.w	r5, [sp, #52]	; 0x34
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    5f60:	lsls	r3, r3, #28
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    5f62:	mov	r6, r0
    5f64:	mov	r7, r1
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    5f66:	bmi.n	5f6e <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x26>
    setLe16(dir->modifyTime, dirTime);
  }
  return m_vol->cacheSync();

 fail:
  return false;
    5f68:	movs	r0, #0
    5f6a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint16_t dirDate;
  uint16_t dirTime;
  DirFat_t* dir;

  if (!isFile()
      || year < 1980
    5f6e:	subw	r2, r2, #1980	; 0x7bc
    5f72:	uxth.w	r8, r2
    5f76:	cmp.w	r8, #127	; 0x7f
    5f7a:	bhi.n	5f68 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || year > 2107
      || month < 1
    5f7c:	subs	r3, r4, #1
    5f7e:	cmp	r3, #11
    5f80:	bhi.n	5f68 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || month > 12
      || day < 1
    5f82:	add.w	r3, fp, #4294967295
    5f86:	cmp	r3, #30
    5f88:	bhi.n	5f68 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || day > 31
      || hour > 23
    5f8a:	cmp.w	r9, #23
    5f8e:	bhi.n	5f68 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || minute > 59
    5f90:	cmp.w	sl, #59	; 0x3b
    5f94:	bhi.n	5f68 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || second > 59) {
    5f96:	cmp	r5, #59	; 0x3b
    5f98:	bhi.n	5f68 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // update directory entry
  if (!sync()) {
    5f9a:	bl	5a54 <FatFile::sync()>
    5f9e:	cmp	r0, #0
    5fa0:	beq.n	5f68 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
    DBG_FAIL_MACRO;
    goto fail;
  }
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    5fa2:	movs	r1, #1
    5fa4:	mov	r0, r6
    5fa6:	bl	55a8 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    5faa:	cmp	r0, #0
    5fac:	beq.n	5f68 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    5fae:	orr.w	r4, fp, r4, lsl #5
    5fb2:	orr.w	r8, r4, r8, lsl #9
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    5fb6:	asrs	r3, r5, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  dirDate = FS_DATE(year, month, day);
  dirTime = FS_TIME(hour, minute, second);
  if (flags & T_ACCESS) {
    5fb8:	lsls	r4, r7, #31
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    5fba:	uxth.w	r8, r8
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    5fbe:	orr.w	r3, r3, sl, lsl #5
    5fc2:	orr.w	r3, r3, r9, lsl #11
    5fc6:	it	mi
    5fc8:	strhmi.w	r8, [r0, #18]
    setLe16(dir->accessDate, dirDate);
  }
  if (flags & T_CREATE) {
    5fcc:	lsls	r1, r7, #30
    5fce:	uxth	r3, r3
    5fd0:	bpl.n	5fe2 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x9a>
    setLe16(dir->createDate, dirDate);
    setLe16(dir->createTime, dirTime);
    // units of 10 ms
    dir->createTimeMs = second & 1 ? 100 : 0;
    5fd2:	ands.w	r5, r5, #1
    5fd6:	it	ne
    5fd8:	movne	r5, #100	; 0x64
    5fda:	strh.w	r8, [r0, #16]
    5fde:	strh	r3, [r0, #14]
    5fe0:	strb	r5, [r0, #13]
  }
  if (flags & T_WRITE) {
    5fe2:	lsls	r2, r7, #29
    5fe4:	itt	mi
    5fe6:	strhmi.w	r8, [r0, #24]
    5fea:	strhmi	r3, [r0, #22]
    setLe16(dir->modifyDate, dirDate);
    setLe16(dir->modifyTime, dirTime);
  }
  return m_vol->cacheSync();
    5fec:	ldr	r0, [r6, #8]
    5fee:	bl	54c0 <FatPartition::cacheSync()>
    5ff2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00005ff6 <FatFile::truncate()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    5ff6:	push	{r0, r1, r4, lr}
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    5ff8:	ldrb	r3, [r0, #2]
    5ffa:	lsls	r3, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    5ffc:	mov	r4, r0
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    5ffe:	bmi.n	6004 <FatFile::truncate()+0xe>
  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    6000:	movs	r0, #0
    6002:	b.n	605a <FatFile::truncate()+0x64>
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    6004:	ldr	r3, [r0, #32]
    6006:	cbz	r3, 6058 <FatFile::truncate()+0x62>
      return true;
  }
  if (m_curCluster) {
    6008:	ldr	r1, [r0, #16]
    600a:	cbz	r1, 6030 <FatFile::truncate()+0x3a>
    toFree = 0;
    600c:	add	r2, sp, #8
    600e:	movs	r3, #0
    6010:	str.w	r3, [r2, #-4]!
    int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    6014:	ldr	r0, [r0, #8]
    6016:	bl	6298 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    601a:	cmp	r0, #0
    601c:	blt.n	6000 <FatFile::truncate()+0xa>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg) {
    601e:	beq.n	6034 <FatFile::truncate()+0x3e>
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    6020:	mvn.w	r2, #4026531840	; 0xf0000000
    6024:	ldr	r1, [r4, #16]
    6026:	ldr	r0, [r4, #8]
    6028:	bl	6302 <FatPartition::fatPut(unsigned long, unsigned long)>
      // current cluster is end of chain
      if (!m_vol->fatPutEOC(m_curCluster)) {
    602c:	cbnz	r0, 6034 <FatFile::truncate()+0x3e>
    602e:	b.n	6000 <FatFile::truncate()+0xa>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  } else {
    toFree = m_firstCluster;
    6030:	str	r3, [sp, #4]
    m_firstCluster = 0;
    6032:	str	r1, [r0, #32]
  }
  if (toFree) {
    6034:	ldr	r1, [sp, #4]
    6036:	cbnz	r1, 604c <FatFile::truncate()+0x56>
    if (!m_vol->freeChain(toFree)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_fileSize = m_curPosition;
    6038:	ldr	r3, [r4, #20]
    603a:	str	r3, [r4, #28]

  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
    603c:	ldrb	r3, [r4, #2]
    603e:	orn	r3, r3, #127	; 0x7f
    6042:	strb	r3, [r4, #2]
  return sync();
    6044:	mov	r0, r4
    6046:	bl	5a54 <FatFile::sync()>
    604a:	b.n	605a <FatFile::truncate()+0x64>
  } else {
    toFree = m_firstCluster;
    m_firstCluster = 0;
  }
  if (toFree) {
    if (!m_vol->freeChain(toFree)) {
    604c:	ldr	r0, [r4, #8]
    604e:	bl	63de <FatPartition::freeChain(unsigned long)>
    6052:	cmp	r0, #0
    6054:	bne.n	6038 <FatFile::truncate()+0x42>
    6056:	b.n	6000 <FatFile::truncate()+0xa>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    6058:	movs	r0, #1
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    605a:	add	sp, #8
    605c:	pop	{r4, pc}
    605e:	Address 0x0000605e is out of bounds.


00006060 <FatFile::write(void const*, unsigned int)>:
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    6060:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6064:	ldrb	r3, [r0, #2]
    6066:	mov	r9, r1
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    6068:	lsls	r1, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    606a:	mov	r4, r0
    606c:	mov	r5, r2
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    606e:	bpl.w	618e <FatFile::write(void const*, unsigned int)+0x12e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    6072:	lsls	r2, r3, #28
    6074:	bmi.n	608c <FatFile::write(void const*, unsigned int)+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    6076:	ldr	r3, [r4, #20]
    6078:	mvns	r3, r3
    607a:	cmp	r5, r3
    607c:	bhi.w	618e <FatFile::write(void const*, unsigned int)+0x12e>
    6080:	mov	r7, r5
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6082:	mov.w	sl, #0
    m_sector = 0XFFFFFFFF;
    6086:	mov.w	fp, #4294967295
    608a:	b.n	611a <FatFile::write(void const*, unsigned int)+0xba>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_fileSize)) {
    608c:	ldr	r1, [r0, #28]
    608e:	bl	57fe <FatFile::seekSet(unsigned long)>
    6092:	cmp	r0, #0
    6094:	bne.n	6076 <FatFile::write(void const*, unsigned int)+0x16>
    6096:	b.n	618e <FatFile::write(void const*, unsigned int)+0x12e>
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    6098:	ldr	r0, [r4, #8]
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    609a:	ldrb	r6, [r0, #5]
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    609c:	ands.w	r6, r6, r2, lsr #9
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    60a0:	ubfx	r8, r2, #0, #9
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    60a4:	beq.n	6122 <FatFile::write(void const*, unsigned int)+0xc2>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
    60a6:	ldr.w	lr, [r4, #8]
                      + sectorOfCluster;
    60aa:	ldr	r1, [r4, #16]
    60ac:	ldrb.w	r3, [lr, #6]
    60b0:	subs	r1, #2
    60b2:	lsls	r1, r3
    60b4:	ldr.w	r3, [lr, #20]
    60b8:	add	r1, r3
    60ba:	add	r1, r6

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
    60bc:	cmp.w	r8, #0
    60c0:	bne.n	6154 <FatFile::write(void const*, unsigned int)+0xf4>
    60c2:	cmp.w	r7, #512	; 0x200
    60c6:	bcs.n	61a2 <FatFile::write(void const*, unsigned int)+0x142>
      // lesser of space and amount to write
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (sectorOffset == 0 &&
    60c8:	ldr	r2, [r4, #20]
    60ca:	ldr	r3, [r4, #28]
    60cc:	cmp	r2, r3
    60ce:	bcs.n	6158 <FatFile::write(void const*, unsigned int)+0xf8>
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
    60d0:	ldrb	r3, [r4, #2]
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    60d2:	tst.w	r3, #32
    60d6:	ite	eq
    60d8:	moveq	r2, #1
    60da:	movne	r2, #5
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    60dc:	add.w	r0, lr, #40	; 0x28
    60e0:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      pc = m_vol->cacheFetchData(sector, cacheOption);
      if (!pc) {
    60e4:	cmp	r0, #0
    60e6:	beq.n	618e <FatFile::write(void const*, unsigned int)+0x12e>
                      + sectorOfCluster;

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    60e8:	rsb	r6, r8, #512	; 0x200
    60ec:	cmp	r6, r7
    60ee:	it	cs
    60f0:	movcs	r6, r7
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    60f2:	add	r0, r8
    60f4:	mov	r2, r6
    60f6:	mov	r1, r9
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    60f8:	add	r8, r6
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    60fa:	bl	8734 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    60fe:	cmp.w	r8, #512	; 0x200
    6102:	bne.n	6110 <FatFile::write(void const*, unsigned int)+0xb0>
  }
  void cacheInvalidate() {
    m_cache.invalidate();
  }
  bool cacheSyncData() {
    return m_cache.sync();
    6104:	ldr	r0, [r4, #8]
    6106:	adds	r0, #40	; 0x28
    6108:	bl	303a <FsCache::sync()>
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
      if (nSector > maxSectors) {
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeWrite(sector, src, nSector)) {
    610c:	cmp	r0, #0
    610e:	beq.n	618e <FatFile::write(void const*, unsigned int)+0x12e>
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    6110:	ldr	r3, [r4, #20]
    6112:	add	r3, r6
    6114:	str	r3, [r4, #20]
    src += n;
    6116:	add	r9, r6
    nToWrite -= n;
    6118:	subs	r7, r7, r6
    611a:	ldr	r2, [r4, #20]
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    611c:	cmp	r7, #0
    611e:	bne.n	6098 <FatFile::write(void const*, unsigned int)+0x38>
    6120:	b.n	615c <FatFile::write(void const*, unsigned int)+0xfc>
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    6122:	cmp.w	r8, #0
    6126:	bne.n	60a6 <FatFile::write(void const*, unsigned int)+0x46>
      // start of new cluster
      if (m_curCluster != 0) {
    6128:	ldr	r1, [r4, #16]
    612a:	cbz	r1, 613e <FatFile::write(void const*, unsigned int)+0xde>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
    612c:	ldrb	r3, [r4, #2]
    612e:	lsls	r3, r3, #25
    6130:	bpl.n	6176 <FatFile::write(void const*, unsigned int)+0x116>
    6132:	ldr	r3, [r4, #28]
    6134:	cmp	r2, r3
    6136:	bcs.n	6176 <FatFile::write(void const*, unsigned int)+0x116>
          m_curCluster++;
    6138:	adds	r1, #1
    613a:	str	r1, [r4, #16]
    613c:	b.n	60a6 <FatFile::write(void const*, unsigned int)+0x46>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    613e:	ldr	r3, [r4, #32]
    6140:	cbnz	r3, 6150 <FatFile::write(void const*, unsigned int)+0xf0>
          // allocate first cluster of file
          if (!addCluster()) {
    6142:	mov	r0, r4
    6144:	bl	54e6 <FatFile::addCluster()>
    6148:	cbz	r0, 618e <FatFile::write(void const*, unsigned int)+0x12e>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    614a:	ldr	r3, [r4, #16]
    614c:	str	r3, [r4, #32]
    614e:	b.n	60a6 <FatFile::write(void const*, unsigned int)+0x46>
        } else {
          m_curCluster = m_firstCluster;
    6150:	str	r3, [r4, #16]
    6152:	b.n	60a6 <FatFile::write(void const*, unsigned int)+0x46>
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    6154:	movs	r2, #1
    6156:	b.n	60dc <FatFile::write(void const*, unsigned int)+0x7c>
      }

      if (sectorOffset == 0 &&
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    6158:	movs	r2, #5
    615a:	b.n	60dc <FatFile::write(void const*, unsigned int)+0x7c>
    }
    m_curPosition += n;
    src += n;
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    615c:	ldr	r3, [r4, #28]
    615e:	cmp	r2, r3
    6160:	bls.n	6166 <FatFile::write(void const*, unsigned int)+0x106>
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    6162:	str	r2, [r4, #28]
    6164:	b.n	616c <FatFile::write(void const*, unsigned int)+0x10c>
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    6166:	ldr	r3, [pc, #180]	; (621c <FatFile::write(void const*, unsigned int)+0x1bc>)
    6168:	ldr	r3, [r3, #0]
    616a:	cbz	r3, 619c <FatFile::write(void const*, unsigned int)+0x13c>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    616c:	ldrb	r3, [r4, #2]
    616e:	orn	r3, r3, #127	; 0x7f
    6172:	strb	r3, [r4, #2]
    6174:	b.n	619c <FatFile::write(void const*, unsigned int)+0x13c>
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
          m_curCluster++;
          fg = 1;
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    6176:	add.w	r2, r4, #16
    617a:	bl	6298 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    617e:	cmp	r0, #0
    6180:	blt.n	618e <FatFile::write(void const*, unsigned int)+0x12e>
        if (fg < 0) {
          DBG_FAIL_MACRO;
          goto fail;
        }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        if (fg == 0) {
    6182:	bne.n	6204 <FatFile::write(void const*, unsigned int)+0x1a4>
          // add cluster if at end of chain
          if (!addCluster()) {
    6184:	mov	r0, r4
    6186:	bl	54e6 <FatFile::addCluster()>
    618a:	cmp	r0, #0
    618c:	bne.n	6204 <FatFile::write(void const*, unsigned int)+0x1a4>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    618e:	ldrb	r3, [r4, #1]
    6190:	orr.w	r3, r3, #1
    6194:	strb	r3, [r4, #1]
  return 0;
    6196:	movs	r0, #0
    6198:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    619c:	mov	r0, r5
    619e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (nToWrite >= 2*m_vol->bytesPerSector()) {
    61a2:	cmp.w	r7, #1024	; 0x400
    61a6:	ldr.w	r2, [lr, #52]	; 0x34
    61aa:	ldr.w	r0, [lr, #44]	; 0x2c
    61ae:	bcc.n	61da <FatFile::write(void const*, unsigned int)+0x17a>
      // use multiple sector write command
      uint32_t maxSectors = m_vol->sectorsPerCluster() - sectorOfCluster;
    61b0:	ldrb.w	r3, [lr, #4]
    61b4:	subs	r6, r3, r6
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
    61b6:	lsrs	r3, r7, #9
    61b8:	cmp	r3, r6
    61ba:	it	cs
    61bc:	movcs	r3, r6
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    61be:	cmp	r2, r1
      if (nSector > maxSectors) {
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
    61c0:	mov.w	r6, r3, lsl #9
    61c4:	bcc.n	61ce <FatFile::write(void const*, unsigned int)+0x16e>
    61c6:	add.w	ip, r3, r1
    61ca:	cmp	r2, ip
    61cc:	bcc.n	61fa <FatFile::write(void const*, unsigned int)+0x19a>
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    61ce:	ldr	r2, [r0, #0]
    61d0:	ldr.w	r8, [r2, #36]	; 0x24
    61d4:	mov	r2, r9
    61d6:	blx	r8
    61d8:	b.n	610c <FatFile::write(void const*, unsigned int)+0xac>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    61da:	cmp	r2, r1
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    61dc:	it	eq
    61de:	strbeq.w	sl, [lr, #40]	; 0x28
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    61e2:	ldr	r3, [r0, #0]
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    61e4:	it	eq
    61e6:	streq.w	fp, [lr, #52]	; 0x34
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    61ea:	ldr	r3, [r3, #32]
    61ec:	mov	r2, r9
    61ee:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    61f0:	cmp	r0, #0
    61f2:	beq.n	618e <FatFile::write(void const*, unsigned int)+0x12e>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
    61f4:	mov.w	r6, #512	; 0x200
    61f8:	b.n	6110 <FatFile::write(void const*, unsigned int)+0xb0>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    61fa:	strb.w	sl, [lr, #40]	; 0x28
    m_sector = 0XFFFFFFFF;
    61fe:	str.w	fp, [lr, #52]	; 0x34
    6202:	b.n	61ce <FatFile::write(void const*, unsigned int)+0x16e>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
    6204:	ldr.w	lr, [r4, #8]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    6208:	ldr	r1, [r4, #16]
    620a:	ldrb.w	r3, [lr, #6]
    620e:	subs	r1, #2
    6210:	lsls	r1, r3
    6212:	ldr.w	r3, [lr, #20]
    6216:	add	r1, r3
    6218:	b.n	60c2 <FatFile::write(void const*, unsigned int)+0x62>
    621a:	nop
    621c:	.word	0x1fff8418

00006220 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)>:

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat16(uint32_t sector, uint8_t *buf, void *context) {
   struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint16_t *p = (uint16_t *)buf;
  unsigned int n = state->clusters_to_do;
    6220:	ldr	r3, [r2, #0]
    6222:	cmp.w	r3, #256	; 0x100
  uint32_t clusters_to_do;
  uint32_t free_count;
};

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat16(uint32_t sector, uint8_t *buf, void *context) {
    6226:	push	{r4, r5, lr}
    6228:	mov	r4, r3
    622a:	it	cs
    622c:	movcs.w	r4, #256	; 0x100
   struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint16_t *p = (uint16_t *)buf;
  unsigned int n = state->clusters_to_do;
  if (n > 256) n = 256;
  uint16_t *e = p + n;
    6230:	add.w	r5, r1, r4, lsl #1
  while (p < e) {
    6234:	cmp	r1, r5
    6236:	bcs.n	6248 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x28>
    if (*p++ == 0) state->free_count++;
    6238:	ldrh.w	r0, [r1], #2
    623c:	cmp	r0, #0
    623e:	bne.n	6234 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x14>
    6240:	ldr	r0, [r2, #4]
    6242:	adds	r0, #1
    6244:	str	r0, [r2, #4]
    6246:	b.n	6234 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x14>
  }
  state->clusters_to_do -= n;
    6248:	subs	r3, r3, r4
    624a:	str	r3, [r2, #0]
    624c:	pop	{r4, r5, pc}

0000624e <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)>:

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat32(uint32_t sector, uint8_t *buf, void *context) {
  struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint32_t *p = (uint32_t *)buf;
  unsigned int n = state->clusters_to_do;
    624e:	ldr	r3, [r2, #0]
    6250:	cmp	r3, #128	; 0x80
  }
  state->clusters_to_do -= n;
}

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat32(uint32_t sector, uint8_t *buf, void *context) {
    6252:	push	{r4, r5, lr}
    6254:	mov	r4, r3
    6256:	it	cs
    6258:	movcs	r4, #128	; 0x80
  struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint32_t *p = (uint32_t *)buf;
  unsigned int n = state->clusters_to_do;
  if (n > 128) n = 128;
  uint32_t *e = p + n;
    625a:	add.w	r5, r1, r4, lsl #2
  while (p < e) {
    625e:	cmp	r1, r5
    6260:	bcs.n	6272 <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x24>
    if (*p++ == 0) state->free_count++;
    6262:	ldr.w	r0, [r1], #4
    6266:	cmp	r0, #0
    6268:	bne.n	625e <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x10>
    626a:	ldr	r0, [r2, #4]
    626c:	adds	r0, #1
    626e:	str	r0, [r2, #4]
    6270:	b.n	625e <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x10>
  }
  state->clusters_to_do -= n;
    6272:	subs	r3, r3, r4
    6274:	str	r3, [r2, #0]
    6276:	pop	{r4, r5, pc}

00006278 <FsCache::clear()>:
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    6278:	push	{r4, lr}
    if (isDirty() && !sync()) {
    627a:	ldrb	r3, [r0, #0]
    627c:	lsls	r3, r3, #31
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    627e:	mov	r4, r0
    if (isDirty() && !sync()) {
    6280:	bpl.n	6288 <FsCache::clear()+0x10>
    6282:	bl	303a <FsCache::sync()>
    6286:	cbz	r0, 6296 <FsCache::clear()+0x1e>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6288:	movs	r3, #0
    628a:	strb	r3, [r4, #0]
    m_sector = 0XFFFFFFFF;
    628c:	mov.w	r3, #4294967295
    6290:	str	r3, [r4, #12]
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    6292:	add.w	r0, r4, #16
  }
    6296:	pop	{r4, pc}

00006298 <FatPartition::fatGet(unsigned long, unsigned long*)>:
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6298:	cmp	r1, #1
 fail:
  return false;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry - return -1 error, 0 EOC, else 1.
int8_t FatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    629a:	push	{r4, r5, r6, lr}
    629c:	mov	r5, r0
    629e:	mov	r4, r1
    62a0:	mov	r6, r2
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    62a2:	bhi.n	62aa <FatPartition::fatGet(unsigned long, unsigned long*)+0x12>
  }
  *value = next;
  return 1;

 fail:
  return -1;
    62a4:	mov.w	r0, #4294967295
    62a8:	pop	{r4, r5, r6, pc}
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    62aa:	ldr	r3, [r0, #28]
    62ac:	cmp	r1, r3
    62ae:	bhi.n	62a4 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
    62b0:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    62b2:	cmp	r3, #32
    62b4:	bne.n	62d4 <FatPartition::fatGet(unsigned long, unsigned long*)+0x3c>
  FsCache m_cache;
#if USE_SEPARATE_FAT_CACHE
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
    62b6:	ldr	r1, [r0, #24]
    62b8:	movs	r2, #2
    62ba:	add.w	r1, r1, r4, lsr #7
    62be:	add.w	r0, r0, #568	; 0x238
    62c2:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    62c6:	cmp	r0, #0
    62c8:	beq.n	62a4 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    62ca:	and.w	r4, r4, #127	; 0x7f
    62ce:	ldr.w	r3, [r0, r4, lsl #2]
    62d2:	b.n	62f4 <FatPartition::fatGet(unsigned long, unsigned long*)+0x5c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe32(reinterpret_cast<uint8_t*>
                  (&pc->fat32[cluster & (m_sectorMask >> 2)]));
  } else if (fatType() == 16) {
    62d4:	cmp	r3, #16
    62d6:	bne.n	62a4 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
    62d8:	ldr	r3, [r0, #24]
    62da:	ubfx	r1, r1, #8, #8
    62de:	movs	r2, #2
    62e0:	add	r1, r3
    62e2:	add.w	r0, r0, #568	; 0x238
    62e6:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    62ea:	cmp	r0, #0
    62ec:	beq.n	62a4 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    62ee:	uxtb	r4, r4
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe16(reinterpret_cast<uint8_t*>
                  (&pc->fat16[cluster & (m_sectorMask >> 1)]));
    62f0:	ldrh.w	r3, [r0, r4, lsl #1]
    next = cluster & 1 ? tmp >> 4 : tmp & 0XFFF;
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    62f4:	ldr	r2, [r5, #28]
    62f6:	cmp	r3, r2
    return 0;
  }
  *value = next;
  return 1;
    62f8:	itte	ls
    62fa:	movls	r0, #1
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
  }
  *value = next;
    62fc:	strls	r3, [r6, #0]
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
    62fe:	movhi	r0, #0
  *value = next;
  return 1;

 fail:
  return -1;
}
    6300:	pop	{r4, r5, r6, pc}

00006302 <FatPartition::fatPut(unsigned long, unsigned long)>:
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6302:	cmp	r1, #1
 fail:
  return -1;
}
//------------------------------------------------------------------------------
// Store a FAT entry
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
    6304:	push	{r3, r4, r5, lr}
    6306:	mov	r4, r1
    6308:	mov	r5, r2
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    630a:	bhi.n	6310 <FatPartition::fatPut(unsigned long, unsigned long)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }

 fail:
  return false;
    630c:	movs	r0, #0
    630e:	pop	{r3, r4, r5, pc}
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6310:	ldr	r3, [r0, #28]
    6312:	cmp	r1, r3
    6314:	bhi.n	630c <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
    6316:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    6318:	cmp	r3, #32
    631a:	bne.n	633a <FatPartition::fatPut(unsigned long, unsigned long)+0x38>
    631c:	ldr	r1, [r0, #24]
    631e:	movs	r2, #3
    6320:	add.w	r1, r1, r4, lsr #7
    6324:	add.w	r0, r0, #568	; 0x238
    6328:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    632c:	cmp	r0, #0
    632e:	beq.n	630c <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    6330:	and.w	r4, r4, #127	; 0x7f
    6334:	str.w	r5, [r0, r4, lsl #2]
    6338:	b.n	635a <FatPartition::fatPut(unsigned long, unsigned long)+0x58>
    setLe32(reinterpret_cast<uint8_t*>
           (&pc->fat32[cluster & (m_sectorMask >> 2)]), value);
    return true;
  }

  if (fatType() == 16) {
    633a:	cmp	r3, #16
    633c:	bne.n	630c <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
    633e:	ldr	r3, [r0, #24]
    6340:	ubfx	r1, r1, #8, #8
    6344:	movs	r2, #3
    6346:	add	r1, r3
    6348:	add.w	r0, r0, #568	; 0x238
    634c:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    6350:	cmp	r0, #0
    6352:	beq.n	630c <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    6354:	uxtb	r4, r4
    6356:	strh.w	r5, [r0, r4, lsl #1]
      DBG_FAIL_MACRO;
      goto fail;
    }
    setLe16(reinterpret_cast<uint8_t*>
           (&pc->fat16[cluster & (m_sectorMask >> 1)]), value);
    return true;
    635a:	movs	r0, #1
    goto fail;
  }

 fail:
  return false;
}
    635c:	pop	{r3, r4, r5, pc}

0000635e <FatPartition::allocateCluster(unsigned long, unsigned long*)>:
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"
#include "FatPartition.h"

//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    635e:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    6362:	ldr	r4, [r0, #12]
    6364:	cmp	r4, r1
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"
#include "FatPartition.h"

//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    6366:	mov	r5, r0
    6368:	mov	r6, r1
    636a:	mov	r8, r2
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    636c:	bcs.n	637e <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x20>
    636e:	mov	r4, r1
    // Try to keep file contiguous. Start just after current cluster.
    find = current;
    setStart = false;
    6370:	movs	r7, #0
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    if (find > m_lastCluster) {
    6372:	ldr	r3, [r5, #28]
  } else {
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    6374:	adds	r4, #1
    if (find > m_lastCluster) {
    6376:	cmp	r4, r3
    6378:	bls.n	6382 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x24>
      if (setStart) {
    637a:	cbnz	r7, 63b0 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
        // Can't find space, checked all clusters.
        DBG_FAIL_MACRO;
        goto fail;
      }
      find = m_allocSearchStart;
    637c:	ldr	r4, [r5, #12]
      setStart = true;
    637e:	movs	r7, #1
    6380:	b.n	6372 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
      continue;
    }
    if (find == current) {
    6382:	cmp	r6, r4
    6384:	beq.n	63b0 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    6386:	add	r2, sp, #4
    6388:	mov	r1, r4
    638a:	mov	r0, r5
    638c:	bl	6298 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    6390:	cmp	r0, #0
    6392:	blt.n	63b0 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg && f == 0) {
    6394:	beq.n	6372 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
    6396:	ldr	r3, [sp, #4]
    6398:	cmp	r3, #0
    639a:	bne.n	6372 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
      break;
    }
  }
  if (setStart) {
    639c:	cbz	r7, 63a0 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x42>
    m_allocSearchStart = find;
    639e:	str	r4, [r5, #12]
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    63a0:	mvn.w	r2, #4026531840	; 0xf0000000
    63a4:	mov	r1, r4
    63a6:	mov	r0, r5
    63a8:	bl	6302 <FatPartition::fatPut(unsigned long, unsigned long)>
  }
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    63ac:	mov	r7, r0
    63ae:	cbnz	r0, 63b4 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x56>
  updateFreeClusterCount(-1);
  *next = find;
  return true;

 fail:
  return false;
    63b0:	movs	r7, #0
    63b2:	b.n	63d6 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
    63b4:	cbnz	r6, 63c2 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x64>
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
  }
  void updateFreeClusterCount(int32_t change) {
    if (m_freeClusterCount >= 0) {
    63b6:	ldr	r3, [r5, #36]	; 0x24
    63b8:	cmp	r3, #0
    63ba:	blt.n	63d2 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x74>
      m_freeClusterCount += change;
    63bc:	subs	r3, #1
    63be:	str	r3, [r5, #36]	; 0x24
    63c0:	b.n	63d2 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x74>
    // Link clusters.
    if (!fatPut(current, find)) {
    63c2:	mov	r2, r4
    63c4:	mov	r1, r6
    63c6:	mov	r0, r5
    63c8:	bl	6302 <FatPartition::fatPut(unsigned long, unsigned long)>
    63cc:	cmp	r0, #0
    63ce:	bne.n	63b6 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x58>
    63d0:	b.n	63b0 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  updateFreeClusterCount(-1);
  *next = find;
    63d2:	str.w	r4, [r8]
  return true;

 fail:
  return false;
}
    63d6:	mov	r0, r7
    63d8:	add	sp, #8
    63da:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000063de <FatPartition::freeChain(unsigned long)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
    63de:	push	{r0, r1, r4, r5, r6, lr}
    63e0:	mov	r5, r0
    63e2:	mov	r4, r1
  uint32_t next;
  int8_t fg;
  do {
    fg = fatGet(cluster, &next);
    63e4:	add	r2, sp, #4
    63e6:	mov	r1, r4
    63e8:	mov	r0, r5
    63ea:	bl	6298 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    63ee:	subs	r6, r0, #0
    63f0:	bge.n	63f6 <FatPartition::freeChain(unsigned long)+0x18>
  } while (fg);

  return true;

 fail:
  return false;
    63f2:	movs	r0, #0
    63f4:	b.n	6420 <FatPartition::freeChain(unsigned long)+0x42>
    if (fg < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
    63f6:	movs	r2, #0
    63f8:	mov	r1, r4
    63fa:	mov	r0, r5
    63fc:	bl	6302 <FatPartition::fatPut(unsigned long, unsigned long)>
    6400:	cmp	r0, #0
    6402:	beq.n	63f2 <FatPartition::freeChain(unsigned long)+0x14>
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
  }
  void updateFreeClusterCount(int32_t change) {
    if (m_freeClusterCount >= 0) {
    6404:	ldr	r3, [r5, #36]	; 0x24
    6406:	cmp	r3, #0
      m_freeClusterCount += change;
    6408:	itt	ge
    640a:	addge	r3, #1
    640c:	strge	r3, [r5, #36]	; 0x24
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Add one to count of free clusters.
    updateFreeClusterCount(1);
    if (cluster < m_allocSearchStart) {
    640e:	ldr	r3, [r5, #12]
    6410:	cmp	r4, r3
      m_allocSearchStart = cluster - 1;
    6412:	itt	cc
    6414:	addcc.w	r4, r4, #4294967295
    6418:	strcc	r4, [r5, #12]
    }
    cluster = next;
    641a:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  int8_t fg;
  do {
    641c:	cmp	r6, #0
    641e:	bne.n	63e4 <FatPartition::freeChain(unsigned long)+0x6>

  return true;

 fail:
  return false;
}
    6420:	add	sp, #8
    6422:	pop	{r4, r5, r6, pc}

00006424 <FatPartition::freeClusterCount()>:
  }
  state->clusters_to_do -= n;
}

//------------------------------------------------------------------------------
int32_t FatPartition::freeClusterCount() {
    6424:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    6426:	mov	r4, r0
#if MAINTAIN_FREE_CLUSTER_COUNT
  if (m_freeClusterCount >= 0) {
    6428:	ldr	r0, [r0, #36]	; 0x24
    642a:	cmp	r0, #0
    642c:	bge.n	6472 <FatPartition::freeClusterCount()+0x4e>
    return free;
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
    642e:	movs	r3, #0
    6430:	str	r3, [sp, #12]
  state.clusters_to_do = m_lastCluster + 1;
    6432:	ldr	r3, [r4, #28]
  uint32_t num_sectors;

  //num_sectors = SD.sdfs.m_fVol->sectorsPerFat(); // edit FsVolume.h for public
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
    6434:	ldr	r5, [r4, #16]
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
  state.clusters_to_do = m_lastCluster + 1;
    6436:	adds	r3, #1
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
  //Serial.printf("  num_sectors = %u\n", num_sectors);
#if USE_SEPARATE_FAT_CACHE
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
    6438:	add.w	r0, r4, #568	; 0x238
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
  state.clusters_to_do = m_lastCluster + 1;
    643c:	str	r3, [sp, #8]
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
  //Serial.printf("  num_sectors = %u\n", num_sectors);
#if USE_SEPARATE_FAT_CACHE
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
    643e:	bl	6278 <FsCache::clear()>
#else  
  uint8_t *buf = m_cache.clear();  // will clear out anything and return buffer 
#endif  // USE_SEPARATE_FAT_CACHE
  if (buf == nullptr) return -1;
    6442:	mov	r2, r0
    6444:	cbnz	r0, 644c <FatPartition::freeClusterCount()+0x28>
    6446:	mov.w	r0, #4294967295
    644a:	b.n	6472 <FatPartition::freeClusterCount()+0x4e>
  if (fatType() == FAT_TYPE_FAT32) {
    644c:	ldrb	r3, [r4, #7]
    644e:	ldr	r0, [r4, #0]
    6450:	cmp	r3, #32
    6452:	add	r3, sp, #8
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat32, &state)) return -1;
    6454:	ldr	r1, [r0, #0]
    6456:	str	r3, [sp, #4]
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
#else  
  uint8_t *buf = m_cache.clear();  // will clear out anything and return buffer 
#endif  // USE_SEPARATE_FAT_CACHE
  if (buf == nullptr) return -1;
  if (fatType() == FAT_TYPE_FAT32) {
    6458:	bne.n	645e <FatPartition::freeClusterCount()+0x3a>
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat32, &state)) return -1;
    645a:	ldr	r3, [pc, #28]	; (6478 <FatPartition::freeClusterCount()+0x54>)
    645c:	b.n	6460 <FatPartition::freeClusterCount()+0x3c>
  } else {
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat16, &state)) return -1;
    645e:	ldr	r3, [pc, #28]	; (647c <FatPartition::freeClusterCount()+0x58>)
    6460:	str	r3, [sp, #0]
    6462:	ldr	r6, [r1, #20]
    6464:	ldr	r1, [r4, #24]
    6466:	mov	r3, r5
    6468:	blx	r6
    646a:	cmp	r0, #0
    646c:	beq.n	6446 <FatPartition::freeClusterCount()+0x22>
  }

  setFreeClusterCount(state.free_count);
    646e:	ldr	r0, [sp, #12]
    return m_blockDev->writeSector(sector, src);
  }
#if MAINTAIN_FREE_CLUSTER_COUNT
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
    6470:	str	r0, [r4, #36]	; 0x24
  return state.free_count;
}
    6472:	add	sp, #16
    6474:	pop	{r4, r5, r6, pc}
    6476:	nop
    6478:	.word	0x0000624f
    647c:	.word	0x00006221

00006480 <FatPartition::init(BlockDeviceInterface*, unsigned char)>:


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    6480:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6484:	mov	r4, r0
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif

  uint8_t tmp;
  m_fatType = 0;
    6486:	movs	r7, #0
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    6488:	mov.w	r3, #4294967295
  m_allocSearchStart = 1;
    648c:	movs	r6, #1
  }
  /** Clear the cache and returns a pointer to the cache.  Not for normal apps.
   * \return A pointer to the cache buffer or zero if an error occurs.
   */
  uint8_t* cacheClear() {
    return m_cache.clear();
    648e:	add.w	r8, r0, #40	; 0x28
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
//  Serial.printf(" FatPartition::init(%x %u)\n", (uint32_t)dev, part);
  uint32_t clusterCount;
  uint32_t totalSectors;
  uint32_t volumeStartSector = 0;
  m_blockDev = dev;
    6492:	str	r1, [r4, #0]
  return state.free_count;
}


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    6494:	sub	sp, #28
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif

  uint8_t tmp;
  m_fatType = 0;
    6496:	strb	r7, [r0, #7]
  m_allocSearchStart = 1;
    6498:	str	r6, [r0, #12]
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    649a:	str	r1, [r4, #44]	; 0x2c
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    649c:	str	r3, [r0, #52]	; 0x34
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    649e:	strb.w	r7, [r0, #40]	; 0x28
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    64a2:	str.w	r1, [r4, #572]	; 0x23c
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    64a6:	str.w	r3, [r0, #580]	; 0x244
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    64aa:	strb.w	r7, [r0, #568]	; 0x238
    64ae:	mov	r0, r8
  return state.free_count;
}


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    64b0:	mov	r5, r1
    64b2:	mov	r9, r2
    64b4:	bl	6278 <FsCache::clear()>
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.init(dev);
#endif  // USE_SEPARATE_FAT_CACHE

  #if SUPPORT_GPT_AND_EXTENDED_PATITIONS 
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part, cacheClear(), &firstLBA);
    64b8:	str	r7, [sp, #8]
    64ba:	mov	r2, r0
    64bc:	str	r7, [sp, #4]
    64be:	str	r7, [sp, #0]
    64c0:	add	r3, sp, #20
    64c2:	mov	r1, r9
    64c4:	mov	r0, r5
    64c6:	bl	2dfc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    64ca:	tst.w	r0, #251	; 0xfb
    64ce:	beq.n	6554 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    DBG_FAIL_MACRO;
    goto fail;    
  }
  volumeStartSector = firstLBA;
    64d0:	ldr	r5, [sp, #20]
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    64d2:	mov	r2, r7
    64d4:	mov	r1, r5
    64d6:	mov	r0, r8
    64d8:	bl	3086 <FsCache::get(unsigned long, unsigned char)>
  #endif

  pbs = reinterpret_cast<pbs_t*>
        (cacheFetchData(volumeStartSector, FsCache::CACHE_FOR_READ));
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    64dc:	cmp	r0, #0
    64de:	beq.n	6554 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    64e0:	ldrb	r3, [r0, #16]
    64e2:	cmp	r3, #2
    64e4:	bne.n	6554 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    64e6:	ldrh.w	r3, [r0, #11]
    64ea:	cmp.w	r3, #512	; 0x200
    64ee:	bne.n	6554 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    64f0:	b.n	6558 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd8>
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    if (tmp == 0) {
    64f2:	subs	r2, #1
    64f4:	beq.n	6554 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
    64f6:	ldrb	r6, [r4, #6]
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    64f8:	lsls	r3, r3, #1
    if (tmp == 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
    64fa:	adds	r6, #1
    64fc:	strb	r6, [r4, #6]
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    64fe:	uxtb	r3, r3
    6500:	cmp	r3, r1
    6502:	bne.n	64f2 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
    6504:	ldrh	r3, [r0, #22]
    6506:	str	r3, [r4, #16]
  if (m_sectorsPerFat == 0) {
    6508:	cbnz	r3, 650e <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x8e>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    650a:	ldr	r3, [r0, #36]	; 0x24
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
    650c:	str	r3, [r4, #16]
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    650e:	ldrh	r1, [r0, #14]
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    6510:	ldrh.w	r2, [r0, #17]

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    6514:	ldr	r6, [r4, #16]
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);
    6516:	strh	r2, [r4, #8]
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    6518:	add	r1, r5

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    651a:	add.w	r3, r1, r6, lsl #1
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    651e:	str	r1, [r4, #24]
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    6520:	lsls	r1, r2, #5
    6522:	addw	r1, r1, #511	; 0x1ff
    6526:	add.w	r1, r3, r1, asr #9

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    652a:	str	r3, [r4, #32]
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
    652c:	ldrh.w	r3, [r0, #19]

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);
    6530:	str	r1, [r4, #20]

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
  if (totalSectors == 0) {
    6532:	cbnz	r3, 6536 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xb6>
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    6534:	ldr	r3, [r0, #32]
    totalSectors = getLe32(bpb->totalSectors32);
  }
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);
    6536:	subs	r1, r5, r1
    6538:	add	r1, r3

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
    653a:	ldrb	r3, [r4, #6]
    653c:	lsrs	r1, r3
  m_lastCluster = clusterCount + 1;
    653e:	adds	r3, r1, #1
    6540:	str	r3, [r4, #28]
    return m_blockDev->writeSector(sector, src);
  }
#if MAINTAIN_FREE_CLUSTER_COUNT
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
    6542:	mov.w	r3, #4294967295
    6546:	str	r3, [r4, #36]	; 0x24

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    6548:	movw	r3, #4084	; 0xff4
    654c:	cmp	r1, r3
    654e:	bhi.n	6568 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xe8>
    m_fatType = 12;
    6550:	movs	r3, #12
    6552:	strb	r3, [r4, #7]
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;

 fail:
  return false;
    6554:	movs	r0, #0
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    6556:	b.n	6582 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x102>
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
    6558:	ldrb	r1, [r0, #13]
    655a:	strb	r1, [r4, #4]
  m_clusterSectorMask = m_sectorsPerCluster - 1;
    655c:	subs	r3, r1, #1
    655e:	strb	r3, [r4, #5]
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
    6560:	strb	r7, [r4, #6]
    6562:	movs	r2, #9
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    6564:	mov	r3, r6
    6566:	b.n	6500 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x80>
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    6568:	movw	r3, #65524	; 0xfff4
    656c:	cmp	r1, r3
    656e:	ittet	hi
    6570:	ldrhi	r3, [r0, #44]	; 0x2c
    m_fatType = 16;
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    6572:	strhi	r3, [r4, #32]
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    m_fatType = 16;
    6574:	movls	r3, #16
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    m_fatType = 32;
    6576:	movhi	r3, #32
    6578:	strb	r3, [r4, #7]
  }
  /** Set the offset to the second FAT for mirroring.
   * \param[in] offset Sector offset to second FAT.
   */
  void setMirrorOffset(uint32_t offset) {
    m_mirrorOffset = offset;
    657a:	str	r6, [r4, #48]	; 0x30
    657c:	str.w	r6, [r4, #576]	; 0x240
  }
  m_cache.setMirrorOffset(m_sectorsPerFat);
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;
    6580:	movs	r0, #1

 fail:
  return false;
}
    6582:	add	sp, #28
    6584:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00006588 <FatVolume::chdir(char const*)>:
#define DBG_FILE "FatVolume.cpp"
#include "../common/DebugMacros.h"
#include "FatVolume.h"
FatVolume* FatVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FatVolume::chdir(const char *path) {
    6588:	push	{r4, r5, r6, lr}
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend FatFile;
  static FatVolume* cwv() {return m_cwv;}
  FatFile* vwd() {return &m_vwd;}
    658a:	add.w	r4, r0, #1096	; 0x448
    658e:	sub	sp, #40	; 0x28
    6590:	movs	r3, #0
  FatFile dir;
  if (!dir.open(vwd(), path, O_RDONLY)) {
    6592:	mov	r2, r1
    6594:	add	r0, sp, #4
    6596:	mov	r1, r4
    6598:	strb.w	r3, [sp, #4]
    659c:	strb.w	r3, [sp, #5]
    65a0:	strb.w	r3, [sp, #6]
    65a4:	bl	5ae4 <FatFile::open(FatFile*, char const*, int)>
    65a8:	mov	r6, r0
    65aa:	cbz	r0, 65c8 <FatVolume::chdir(char const*)+0x40>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!dir.isDir()) {
    65ac:	ldrb.w	r3, [sp, #4]
    65b0:	ands.w	r3, r3, #112	; 0x70
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_vwd = dir;
    65b4:	itttt	ne
    65b6:	addne	r5, sp, #4
    65b8:	ldmiane	r5!, {r0, r1, r2, r3}
    65ba:	stmiane	r4!, {r0, r1, r2, r3}
    65bc:	ldmiane	r5!, {r0, r1, r2, r3}
    65be:	ittte	ne
    65c0:	stmiane	r4!, {r0, r1, r2, r3}
    65c2:	ldrne	r3, [r5, #0]
    65c4:	strne	r3, [r4, #0]
  return true;

 fail:
  return false;
    65c6:	moveq	r6, r3
}
    65c8:	mov	r0, r6
    65ca:	add	sp, #40	; 0x28
    65cc:	pop	{r4, r5, r6, pc}

000065ce <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>:
  }
  DirFat_t* cacheDirEntry(uint8_t action);
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    65ce:	subs	r1, r0, #1
    65d0:	add.w	r2, r0, #10
    uint8_t sum = 0;
    65d4:	movs	r0, #0
    65d6:	lsls	r3, r0, #7
    65d8:	orr.w	r0, r3, r0, lsr #1
    for (uint8_t i = 0; i < 11; i++) {
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    65dc:	ldrb.w	r3, [r1, #1]!
    65e0:	uxtab	r0, r3, r0
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    65e4:	cmp	r1, r2
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    65e6:	uxtb	r0, r0
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    65e8:	bne.n	65d6 <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]+0x8>
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    }
    return sum;
  }
    65ea:	bx	lr

000065ec <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)>:
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    65ec:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  FatFile dir = *this;
    65f0:	mov	r5, r0
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    65f2:	mov	r6, r2
    65f4:	mov	r7, r0
    65f6:	mov	r8, r1
    65f8:	mov	r9, r3
  FatFile dir = *this;
    65fa:	ldmia	r5!, {r0, r1, r2, r3}
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    65fc:	sub	sp, #52	; 0x34
  FatFile dir = *this;
    65fe:	add	r4, sp, #12
    6600:	stmia	r4!, {r0, r1, r2, r3}
    6602:	ldmia	r5!, {r0, r1, r2, r3}
    6604:	stmia	r4!, {r0, r1, r2, r3}
    6606:	ldr	r3, [r5, #0]
    6608:	str	r3, [r4, #0]
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
  }
  void reset() {
    next = begin;
    660a:	ldr	r3, [r6, #0]
    660c:	str	r3, [r6, #4]
    ls = 0;
    660e:	movs	r3, #0
    6610:	strh	r3, [r6, #12]
  DirLfn_t* ldir;
  fname->reset();
  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6612:	movs	r5, #1
    6614:	cmp	r5, r9
    6616:	bhi.n	6652 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x66>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(index - order));
    6618:	rsb	r1, r5, r8
    661c:	uxth	r1, r1
    661e:	add	r0, sp, #12
    6620:	bl	5300 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    6624:	mov	fp, r0
    6626:	cbnz	r0, 662c <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x40>
    }
  }
  return true;

 fail:
  return false;
    6628:	movs	r0, #0
    662a:	b.n	6682 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
    662c:	mov.w	sl, #0
    }
    // These should be checked in caller.
    DBG_HALT_IF(ldir->attributes != FAT_ATTRIB_LONG_NAME);
    DBG_HALT_IF(order != (ldir->order & 0X1F));
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t u = getLfnChar(ldir, i);
    6630:	uxtb.w	r2, sl
    6634:	mov	r1, fp
    6636:	mov	r0, r7
    6638:	bl	531a <FatFile::getLfnChar(DirLfn_t*, unsigned char)>
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    663c:	ldrh	r3, [r6, #12]
    663e:	mov	r4, r0
    6640:	cbnz	r3, 6656 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x6a>
    6642:	ldr	r2, [r6, #4]
    6644:	ldr	r3, [r6, #8]
    6646:	cmp	r2, r3
    6648:	bne.n	6656 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x6a>
      if (fname->atEnd()) {
        return u == 0;
    664a:	clz	r0, r0
    664e:	lsrs	r0, r0, #5
    6650:	b.n	6682 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
        return false;
      }
#endif  // USE_UTF8_LONG_NAMES
    }
  }
  return true;
    6652:	movs	r0, #1
    6654:	b.n	6682 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
      uint16_t u = getLfnChar(ldir, i);
      if (fname->atEnd()) {
        return u == 0;
      }
#if USE_UTF8_LONG_NAMES
      uint16_t cp = fname->get16();
    6656:	mov	r0, r6
    6658:	bl	3178 <FsName::get16()>
    665c:	str	r0, [sp, #4]
      // Make sure caller checked for valid UTF-8.
      DBG_HALT_IF(cp == 0XFFFF);
      if (toUpcase(u) != toUpcase(cp)) {
    665e:	mov	r0, r4
    6660:	bl	30d4 <toUpcase(unsigned short)>
    6664:	ldr	r3, [sp, #4]
    6666:	mov	r4, r0
    6668:	mov	r0, r3
    666a:	bl	30d4 <toUpcase(unsigned short)>
    666e:	cmp	r4, r0
    6670:	bne.n	6628 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x3c>
    6672:	add.w	sl, sl, #1
      goto fail;
    }
    // These should be checked in caller.
    DBG_HALT_IF(ldir->attributes != FAT_ATTRIB_LONG_NAME);
    DBG_HALT_IF(order != (ldir->order & 0X1F));
    for (uint8_t i = 0; i < 13; i++) {
    6676:	cmp.w	sl, #13
    667a:	bne.n	6630 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x44>
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
  FatFile dir = *this;
  DirLfn_t* ldir;
  fname->reset();
  for (uint8_t order = 1; order <= lfnOrd; order++) {
    667c:	adds	r5, #1
    667e:	uxtb	r5, r5
    6680:	b.n	6614 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x28>
  }
  return true;

 fail:
  return false;
}
    6682:	add	sp, #52	; 0x34
    6684:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00006688 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)>:
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6688:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  FatFile dir = *this;
    668c:	mov	r5, r0

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    668e:	mov	r6, r2
    6690:	mov	sl, r1
    6692:	mov	r7, r3
  FatFile dir = *this;
    6694:	ldmia	r5!, {r0, r1, r2, r3}

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6696:	sub	sp, #52	; 0x34
  FatFile dir = *this;
    6698:	add	r4, sp, #12
    669a:	stmia	r4!, {r0, r1, r2, r3}
    669c:	ldmia	r5!, {r0, r1, r2, r3}
    669e:	stmia	r4!, {r0, r1, r2, r3}
    66a0:	ldr	r3, [r5, #0]
    66a2:	str	r3, [r4, #0]
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
    66a4:	add.w	r0, r6, #22
    66a8:	bl	65ce <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>
  }
  void reset() {
    next = begin;
    ls = 0;
    66ac:	movs	r5, #0
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
  }
  void reset() {
    next = begin;
    66ae:	ldr	r3, [r6, #0]
    66b0:	str	r3, [r6, #4]
    66b2:	mov	r9, r0
    ls = 0;
    66b4:	strh	r5, [r6, #12]
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    66b6:	mov.w	fp, #1
      goto fail;
    }
    dir.m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    66ba:	mov	r8, r5
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    66bc:	cmp	fp, r7
    66be:	bhi.n	670e <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x86>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(index - order));
    66c0:	rsb	r1, fp, sl
    66c4:	uxth	r1, r1
    66c6:	add	r0, sp, #12
    66c8:	bl	5300 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    66cc:	cmp	r0, #0
    66ce:	beq.n	6756 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xce>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dir.m_vol->cacheDirty();
    66d0:	ldr	r2, [sp, #20]
    invalidate();
    return m_buffer;
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    66d2:	ldrb.w	r3, [r2, #40]	; 0x28
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    66d6:	cmp	fp, r7
    66d8:	orr.w	r3, r3, #1
    66dc:	strb.w	r3, [r2, #40]	; 0x28
    66e0:	ite	eq
    66e2:	orreq.w	r3, fp, #64	; 0x40
    66e6:	movne	r3, fp
    66e8:	strb	r3, [r0, #0]
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    66ea:	mov.w	r3, #15
    66ee:	strb	r3, [r0, #11]
    ldir->mustBeZero1 = 0;
    66f0:	strb.w	r8, [r0, #12]
    ldir->checksum = checksum;
    66f4:	strb.w	r9, [r0, #13]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    66f8:	strh.w	r8, [r0, #26]
    66fc:	adds	r4, r0, #4
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
    66fe:	movs	r1, #0
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    6700:	ldrh	r3, [r6, #12]
    6702:	cbnz	r3, 6712 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x8a>
    6704:	ldr	r2, [r6, #4]
    6706:	ldr	r3, [r6, #8]
    6708:	cmp	r2, r3
    670a:	bne.n	6712 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x8a>
    670c:	b.n	6744 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xbc>
        DBG_HALT_IF(cp == 0XFFFF);
      }
      putLfnChar(ldir, i, cp);
    }
  }
  return true;
    670e:	movs	r0, #1
    6710:	b.n	6756 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xce>
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t cp;
      if (fname->atEnd()) {
        cp = fc++ ? 0XFFFF : 0;
      } else {
        cp = fname->get16();
    6712:	mov	r0, r6
    6714:	str	r1, [sp, #4]
    6716:	bl	3178 <FsName::get16()>
    671a:	ldr	r1, [sp, #4]
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c The 16-bit character.
 */
static void putLfnChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    671c:	cmp	r1, #4
    671e:	bhi.n	6726 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x9e>
    6720:	strh.w	r0, [r4, #-3]
    6724:	b.n	672e <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xa6>
    setLe16(ldir->unicode1 + 2*i, c);
  } else if (i < 11) {
    6726:	cmp	r1, #10
    6728:	ite	ls
    672a:	strhls	r0, [r4, #0]
    672c:	strhhi	r0, [r4, #2]
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    ldir->checksum = checksum;
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
    672e:	adds	r1, #1
    6730:	uxtb	r1, r1
    6732:	cmp	r1, #13
    6734:	add.w	r4, r4, #2
    6738:	bne.n	6700 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x78>
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    673a:	add.w	fp, fp, #1
    673e:	uxtb.w	fp, fp
    6742:	b.n	66bc <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x34>
    ldir->checksum = checksum;
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t cp;
      if (fname->atEnd()) {
        cp = fc++ ? 0XFFFF : 0;
    6744:	cbz	r5, 6750 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xc8>
    6746:	adds	r5, #1
    6748:	uxtb	r5, r5
    674a:	movw	r0, #65535	; 0xffff
    674e:	b.n	671c <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x94>
    6750:	mov	r0, r5
    6752:	movs	r5, #1
    6754:	b.n	671c <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x94>
  }
  return true;

 fail:
  return false;
}
    6756:	add	sp, #52	; 0x34
    6758:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000675c <FatFile::makeSFN(FatName_t*)>:
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
  const char* ptr = fname->begin;
    675c:	mov	r2, r0

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::makeSFN(FatName_t* fname) {
    675e:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
  const char* ptr = fname->begin;
    6762:	ldr.w	r3, [r2], #21
  uint8_t lc = 0;
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
    6766:	ldr	r7, [r0, #8]
    6768:	add.w	r1, r0, #32
  // Assume blanks removed from start and end.
  DBG_HALT_IF(*ptr == ' ' || *(end - 1) == ' ' || *(end - 1) == '.');

  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    fname->sfn[k] = ' ';
    676c:	movs	r4, #32
    676e:	strb.w	r4, [r2, #1]!
  DBG_HALT_IF(end == ptr);
  // Assume blanks removed from start and end.
  DBG_HALT_IF(*ptr == ' ' || *(end - 1) == ' ' || *(end - 1) == '.');

  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    6772:	cmp	r1, r2
    6774:	bne.n	676e <FatFile::makeSFN(FatName_t*)+0x12>
    fname->sfn[k] = ' ';
  }
  // Not 8.3 if starts with dot.
  is83 = *ptr == '.' ? false : true;
    6776:	ldrb	r6, [r3, #0]
    6778:	subs	r6, #46	; 0x2e
    677a:	it	ne
    677c:	movne	r6, #1
    677e:	mov	r5, r3
    6780:	adds	r3, #1
  // Skip leading dots.
  for (; *ptr == '.'; ptr++) {}
    6782:	ldrb	r2, [r5, #0]
    6784:	cmp	r2, #46	; 0x2e
    6786:	beq.n	677e <FatFile::makeSFN(FatName_t*)+0x22>
    6788:	subs	r3, r7, #1
  // Find last dot.
  for (dot = end - 1; dot > ptr && *dot != '.'; dot--) {}
    678a:	cmp	r3, r5
    678c:	mov	lr, r3
    678e:	bhi.n	67a0 <FatFile::makeSFN(FatName_t*)+0x44>
    6790:	movs	r2, #0
    6792:	mov.w	ip, #7
    6796:	mov	r1, r2
    6798:	mov	r8, r2
    679a:	mov.w	r9, #8
    679e:	b.n	67c4 <FatFile::makeSFN(FatName_t*)+0x68>
    67a0:	ldrb.w	r2, [lr]
    67a4:	cmp	r2, #46	; 0x2e
    67a6:	add.w	r3, r3, #4294967295
    67aa:	bne.n	678a <FatFile::makeSFN(FatName_t*)+0x2e>
    67ac:	b.n	6790 <FatFile::makeSFN(FatName_t*)+0x34>

  for (; ptr < end; ptr++) {
    c = *ptr;
    67ae:	ldrb	r3, [r5, #0]
//  Could skip UTF-8 units where (0XC0 & c) == 0X80

    if (c == '.' && ptr == dot) {
    67b0:	cmp	r3, #46	; 0x2e
    67b2:	bne.n	67ca <FatFile::makeSFN(FatName_t*)+0x6e>
    67b4:	cmp	lr, r5
    67b6:	bne.n	67d2 <FatFile::makeSFN(FatName_t*)+0x76>
      in = 10;  // Max index for full 8.3 name.
    67b8:	mov.w	ip, #10
      i = 8;    // Place for extension.
    67bc:	movs	r1, #8
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    67be:	mov.w	r9, #16
  // Skip leading dots.
  for (; *ptr == '.'; ptr++) {}
  // Find last dot.
  for (dot = end - 1; dot > ptr && *dot != '.'; dot--) {}

  for (; ptr < end; ptr++) {
    67c2:	adds	r5, #1
    67c4:	cmp	r5, r7
    67c6:	bcc.n	67ae <FatFile::makeSFN(FatName_t*)+0x52>
    67c8:	b.n	6854 <FatFile::makeSFN(FatName_t*)+0xf8>
  /** Check for a legal 8.3 character.
   * \param[in] c Character to be checked.
   * \return true for a legal 8.3 character.
   */
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
    67ca:	cmp	r3, #34	; 0x22
    67cc:	beq.n	67f6 <FatFile::makeSFN(FatName_t*)+0x9a>
    67ce:	cmp	r3, #124	; 0x7c
    67d0:	beq.n	67f6 <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
    67d2:	sub.w	r4, r3, #42	; 0x2a
    67d6:	cmp	r4, #5
    67d8:	bhi.n	67de <FatFile::makeSFN(FatName_t*)+0x82>
    67da:	cmp	r3, #45	; 0x2d
    67dc:	bne.n	67f6 <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // :;<=>?
    if (0X3A <= c && c <= 0X3F) {
    67de:	sub.w	r4, r3, #58	; 0x3a
    67e2:	cmp	r4, #5
    67e4:	bls.n	67f6 <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // [\]
    if (0X5B <= c && c <= 0X5D) {
    67e6:	sub.w	r4, r3, #91	; 0x5b
    67ea:	cmp	r4, #2
    67ec:	bls.n	67f6 <FatFile::makeSFN(FatName_t*)+0x9a>
    if (c == '.' && ptr == dot) {
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
    67ee:	sub.w	r4, r3, #33	; 0x21
    67f2:	cmp	r4, #93	; 0x5d
    67f4:	bls.n	6800 <FatFile::makeSFN(FatName_t*)+0xa4>
        is83 = false;
        // Skip UTF-8 trailing characters.
        if ((c & 0XC0) == 0X80) {
    67f6:	and.w	r3, r3, #192	; 0xc0
    67fa:	cmp	r3, #128	; 0x80
    67fc:	bne.n	6826 <FatFile::makeSFN(FatName_t*)+0xca>
    67fe:	b.n	684a <FatFile::makeSFN(FatName_t*)+0xee>
          continue;
        }
        c = '_';
      }
      if (i > in) {
    6800:	cmp	r1, ip
    6802:	bls.n	6814 <FatFile::makeSFN(FatName_t*)+0xb8>
        is83 = false;
        if (in == 10 || ptr > dot) {
    6804:	cmp.w	ip, #10
    6808:	beq.n	6852 <FatFile::makeSFN(FatName_t*)+0xf6>
    680a:	cmp	lr, r5
    680c:	bcc.n	6852 <FatFile::makeSFN(FatName_t*)+0xf6>
         // Done - extension longer than three characters or no extension.
          break;
        }
        // Skip to dot.
        ptr = dot - 1;
    680e:	add.w	r5, lr, #4294967295
    6812:	b.n	684a <FatFile::makeSFN(FatName_t*)+0xee>
        continue;
      }
      if (isLower(c)) {
    6814:	sub.w	r4, r3, #97	; 0x61
    6818:	cmp	r4, #25
    681a:	bhi.n	682e <FatFile::makeSFN(FatName_t*)+0xd2>
        c += 'A' - 'a';
    681c:	subs	r3, #32
    681e:	uxtb	r3, r3
        lc |= bit;
    6820:	orr.w	r2, r9, r2
    6824:	b.n	683a <FatFile::makeSFN(FatName_t*)+0xde>
        if ((c & 0XC0) == 0X80) {
          continue;
        }
        c = '_';
      }
      if (i > in) {
    6826:	cmp	r1, ip
    6828:	bhi.n	6804 <FatFile::makeSFN(FatName_t*)+0xa8>
        is83 = false;
        // Skip UTF-8 trailing characters.
        if ((c & 0XC0) == 0X80) {
          continue;
        }
        c = '_';
    682a:	movs	r3, #95	; 0x5f
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
        is83 = false;
    682c:	movs	r6, #0
        continue;
      }
      if (isLower(c)) {
        c += 'A' - 'a';
        lc |= bit;
      } else if (isUpper(c)) {
    682e:	sub.w	r4, r3, #65	; 0x41
    6832:	cmp	r4, #25
        uc |= bit;
    6834:	it	ls
    6836:	orrls.w	r8, r9, r8
      }
      fname->sfn[i++] = c;
    683a:	adds	r4, r1, #1
    683c:	uxtb	r4, r4
    683e:	add	r1, r0
      if (i < 7) {
    6840:	cmp	r4, #6
        c += 'A' - 'a';
        lc |= bit;
      } else if (isUpper(c)) {
        uc |= bit;
      }
      fname->sfn[i++] = c;
    6842:	strb	r3, [r1, #22]
      if (i < 7) {
    6844:	bhi.n	684e <FatFile::makeSFN(FatName_t*)+0xf2>
        fname->seqPos = i;
    6846:	strb	r4, [r0, #20]
    6848:	b.n	684e <FatFile::makeSFN(FatName_t*)+0xf2>
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
        is83 = false;
    684a:	movs	r6, #0
    684c:	b.n	67c2 <FatFile::makeSFN(FatName_t*)+0x66>
    684e:	mov	r1, r4
    6850:	b.n	67c2 <FatFile::makeSFN(FatName_t*)+0x66>
          continue;
        }
        c = '_';
      }
      if (i > in) {
        is83 = false;
    6852:	movs	r6, #0
      if (i < 7) {
        fname->seqPos = i;
      }
    }
  }
  if (fname->sfn[0] == ' ') {
    6854:	ldrb	r3, [r0, #22]
    6856:	cmp	r3, #32
    6858:	beq.n	687e <FatFile::makeSFN(FatName_t*)+0x122>
    DBG_HALT_MACRO;
    goto fail;
  }
  if (is83) {
    685a:	cbz	r6, 686c <FatFile::makeSFN(FatName_t*)+0x110>
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
    685c:	tst.w	r8, r2
    6860:	it	ne
    6862:	movne	r2, #2
    6864:	strb	r2, [r0, #21]
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
    6866:	movs	r0, #1
    6868:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  }
  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    686c:	ldrb	r2, [r0, #20]
    goto fail;
  }
  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    686e:	movs	r3, #1
    6870:	strb	r3, [r0, #21]
    fname->sfn[fname->seqPos] = '~';
    6872:	add	r0, r2
    6874:	movs	r2, #126	; 0x7e
    6876:	strb	r2, [r0, #22]
    fname->sfn[fname->seqPos + 1] = '1';
    6878:	movs	r2, #49	; 0x31
    687a:	strb	r2, [r0, #23]
    687c:	b.n	6866 <FatFile::makeSFN(FatName_t*)+0x10a>
  }
  return true;

 fail:
  return false;
    687e:	movs	r0, #0
    6880:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00006884 <FatFile::makeUniqueSfn(FatName_t*)>:
}
//------------------------------------------------------------------------------
bool FatFile::makeUniqueSfn(FatName_t* fname) {
    6884:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;
    6888:	ldrb	r5, [r1, #20]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::makeUniqueSfn(FatName_t* fname) {
    688a:	mov	r7, r0
    688c:	mov	r6, r1
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;
    688e:	movs	r4, #98	; 0x62
    for (uint8_t i = pos + 4 ; i > pos; i--) {
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
      hex >>= 4;
    }
    fname->sfn[pos] = '~';
    6890:	mov.w	r8, #126	; 0x7e
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    6894:	add.w	r9, r1, #22
  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
     DBG_WARN_IF(seq > FIRST_HASH_SEQ);
#ifdef USE_LFN_HASH
    hex = Bernstein(fname->begin, fname->end, seq);
#else
    hex = micros();
    6898:	bl	8dac <micros>
    689c:	cmp	r5, #3
    689e:	it	cs
    68a0:	movcs	r5, #3
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    68a2:	adds	r3, r5, #4
  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
     DBG_WARN_IF(seq > FIRST_HASH_SEQ);
#ifdef USE_LFN_HASH
    hex = Bernstein(fname->begin, fname->end, seq);
#else
    hex = micros();
    68a4:	uxth	r0, r0
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    68a6:	uxtb	r3, r3
      uint8_t h = hex & 0XF;
    68a8:	and.w	r2, r0, #15
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    68ac:	adds	r1, r6, r3
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    68ae:	subs	r3, #1
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    68b0:	cmp	r2, #9
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    68b2:	uxtb	r3, r3
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    68b4:	ite	ls
    68b6:	addls	r2, #48	; 0x30
    68b8:	addhi	r2, #55	; 0x37
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    68ba:	cmp	r5, r3
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    68bc:	strb	r2, [r1, #22]
      hex >>= 4;
    68be:	mov.w	r0, r0, lsr #4
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    68c2:	bcc.n	68a8 <FatFile::makeUniqueSfn(FatName_t*)+0x24>
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
      hex >>= 4;
    }
    fname->sfn[pos] = '~';
    68c4:	adds	r3, r6, r5
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    68c6:	movs	r1, #0
    68c8:	strb.w	r8, [r3, #22]
    68cc:	mov	r0, r7
    68ce:	bl	57fe <FatFile::seekSet(unsigned long)>
    rewind();
    while (1) {
      dir = readDirCache(true);
    68d2:	movs	r1, #1
    68d4:	mov	r0, r7
    68d6:	bl	57c4 <FatFile::readDirCache(bool)>
      if (!dir) {
    68da:	mov	r1, r0
    68dc:	cbnz	r0, 68ea <FatFile::makeUniqueSfn(FatName_t*)+0x66>
        if (!getError()) {
    68de:	ldrb	r0, [r7, #1]
    68e0:	clz	r0, r0
    68e4:	lsrs	r0, r0, #5
    68e6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    68ea:	ldrb	r3, [r0, #0]
    68ec:	cbz	r3, 6902 <FatFile::makeUniqueSfn(FatName_t*)+0x7e>
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    68ee:	ldrb	r3, [r0, #11]
    68f0:	lsls	r3, r3, #28
    68f2:	bmi.n	68d2 <FatFile::makeUniqueSfn(FatName_t*)+0x4e>
    68f4:	movs	r2, #11
    68f6:	mov	r0, r9
    68f8:	bl	b130 <memcmp>
    68fc:	cmp	r0, #0
    68fe:	bne.n	68d2 <FatFile::makeUniqueSfn(FatName_t*)+0x4e>
    6900:	b.n	6908 <FatFile::makeUniqueSfn(FatName_t*)+0x84>

 fail:
  return false;

 done:
  return true;
    6902:	movs	r0, #1
    6904:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6908:	subs	r0, r4, #1
  uint16_t hex;

  DBG_HALT_IF(!(fname->flags & FNAME_FLAG_LOST_CHARS));
  DBG_HALT_IF(fname->sfn[pos] != '~' && fname->sfn[pos + 1] != '1');

  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
    690a:	ands.w	r4, r0, #255	; 0xff
    690e:	bne.n	6898 <FatFile::makeUniqueSfn(FatName_t*)+0x14>
  }
  // fall inti fail - too many tries.
  DBG_FAIL_MACRO;

 fail:
  return false;
    6910:	mov	r0, r4
    6912:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6916:	Address 0x00006916 is out of bounds.


00006918 <FatFile::open(FatFile*, FatName_t*, int)>:

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    6918:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    691c:	sub	sp, #44	; 0x2c
    691e:	mov	r6, r1
    6920:	str	r3, [sp, #12]
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    6922:	ldrb	r3, [r1, #0]

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    6924:	str	r0, [sp, #24]
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    6926:	tst.w	r3, #112	; 0x70

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    692a:	mov	sl, r2
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    692c:	bne.n	6932 <FatFile::open(FatFile*, FatName_t*, int)+0x1a>
    goto fail;
  }
  return true;

 fail:
  return false;
    692e:	movs	r0, #0
    6930:	b.n	6b5c <FatFile::open(FatFile*, FatName_t*, int)+0x244>
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    6932:	ldr	r3, [sp, #24]
    6934:	ldrb	r3, [r3, #0]
    6936:	cmp	r3, #0
    6938:	bne.n	692e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
    693a:	ldr	r3, [r2, #16]
    693c:	movs	r2, #13
    693e:	adds	r3, #12
    6940:	udiv	r3, r3, r2
    6944:	uxtb	r3, r3
    6946:	str	r3, [sp, #8]
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
    6948:	ldrb.w	r3, [sl, #21]
    694c:	lsls	r3, r3, #30
    694e:	beq.w	6b56 <FatFile::open(FatFile*, FatName_t*, int)+0x23e>
    6952:	ldr	r3, [sp, #8]
    6954:	add.w	fp, r3, #1
    6958:	uxtb.w	fp, fp
    695c:	movs	r1, #0
    695e:	mov	r0, r6
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
  uint8_t ms10;
  uint8_t nameOrd;
  uint16_t freeIndex = 0;
    6960:	mov.w	r9, #0
    6964:	bl	57fe <FatFile::seekSet(unsigned long)>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    6968:	add.w	r3, sl, #22
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
    696c:	str.w	r9, [sp, #16]
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
    6970:	mov	r8, r9
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
    6972:	mov	r4, r9
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
    6974:	mov	r5, r9
 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
    6976:	str.w	r9, [sp, #20]
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    697a:	str	r3, [sp, #28]
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    697c:	ldr	r7, [r6, #20]
    dir = dirFile->readDirCache();
    697e:	movs	r1, #0
    6980:	mov	r0, r6
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    6982:	ubfx	r7, r7, #5, #16
    dir = dirFile->readDirCache();
    6986:	bl	57c4 <FatFile::readDirCache(bool)>
    if (!dir) {
    698a:	cbnz	r0, 6994 <FatFile::open(FatFile*, FatName_t*, int)+0x7c>
      if (dirFile->getError()) {
    698c:	ldrb	r3, [r6, #1]
    698e:	cmp	r3, #0
    6990:	beq.n	6a54 <FatFile::open(FatFile*, FatName_t*, int)+0x13c>
    6992:	b.n	692e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
        goto fail;
      }
      // At EOF
      goto create;
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
    6994:	ldrb	r3, [r0, #0]
    6996:	cmp	r3, #229	; 0xe5
    6998:	beq.n	699c <FatFile::open(FatFile*, FatName_t*, int)+0x84>
    699a:	cbnz	r3, 69ae <FatFile::open(FatFile*, FatName_t*, int)+0x96>
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    699c:	cmp	r4, #0
    699e:	it	eq
    69a0:	moveq	r9, r7
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
      if (freeFound == 0) {
        freeIndex = curIndex;
      }
      if (freeFound < freeNeed) {
    69a2:	cmp	r4, fp
        freeFound++;
    69a4:	itt	cc
    69a6:	addcc	r4, #1
    69a8:	uxtbcc	r4, r4
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    69aa:	cbnz	r3, 69b6 <FatFile::open(FatFile*, FatName_t*, int)+0x9e>
    69ac:	b.n	6a54 <FatFile::open(FatFile*, FatName_t*, int)+0x13c>
        goto create;
      }
    } else {
      if (freeFound < freeNeed) {
        freeFound = 0;
    69ae:	cmp	r4, fp
    69b0:	it	cc
    69b2:	movcc	r4, #0
    69b4:	b.n	69be <FatFile::open(FatFile*, FatName_t*, int)+0xa6>
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    69b6:	cmp	r3, #229	; 0xe5
    69b8:	bne.n	69be <FatFile::open(FatFile*, FatName_t*, int)+0xa6>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    69ba:	movs	r5, #0
    69bc:	b.n	697c <FatFile::open(FatFile*, FatName_t*, int)+0x64>
      if (freeFound < freeNeed) {
        freeFound = 0;
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    69be:	cmp	r3, #46	; 0x2e
    69c0:	beq.n	69ba <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
    69c2:	ldrb	r2, [r0, #11]
      lfnOrd = 0;
    } else if (isLongName(dir)) {
    69c4:	cmp	r2, #15
    69c6:	bne.n	6a18 <FatFile::open(FatFile*, FatName_t*, int)+0x100>
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
    69c8:	cbnz	r5, 69e8 <FatFile::open(FatFile*, FatName_t*, int)+0xd0>
        order = ldir->order & 0X1F;
        if (order != nameOrd ||
    69ca:	ldr	r2, [sp, #8]
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
      lfnOrd = 0;
    } else if (isLongName(dir)) {
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
        order = ldir->order & 0X1F;
    69cc:	and.w	r8, r3, #31
        if (order != nameOrd ||
    69d0:	cmp	r2, r8
    69d2:	bne.n	697c <FatFile::open(FatFile*, FatName_t*, int)+0x64>
    69d4:	lsls	r1, r3, #25
    69d6:	bmi.n	69de <FatFile::open(FatFile*, FatName_t*, int)+0xc6>
    69d8:	ldr.w	r8, [sp, #8]
    69dc:	b.n	697c <FatFile::open(FatFile*, FatName_t*, int)+0x64>
          (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = nameOrd;
        checksum = ldir->checksum;
    69de:	ldrb	r3, [r0, #13]
    69e0:	str	r3, [sp, #16]
    69e2:	mov	r8, r2
    69e4:	mov	r5, r2
    69e6:	b.n	69fc <FatFile::open(FatFile*, FatName_t*, int)+0xe4>
      } else if (ldir->order != --order || checksum != ldir->checksum) {
    69e8:	add.w	r8, r8, #4294967295
    69ec:	uxtb.w	r8, r8
    69f0:	cmp	r3, r8
    69f2:	bne.n	69ba <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
    69f4:	ldrb	r3, [r0, #13]
    69f6:	ldr	r2, [sp, #16]
    69f8:	cmp	r2, r3
    69fa:	bne.n	69ba <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
        lfnOrd = 0;
        continue;
      }
      if (order == 1) {
    69fc:	cmp.w	r8, #1
    6a00:	bne.n	697c <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        if (!dirFile->cmpName(curIndex + 1, fname, lfnOrd)) {
    6a02:	adds	r1, r7, #1
    6a04:	mov	r3, r5
    6a06:	mov	r2, sl
    6a08:	uxth	r1, r1
    6a0a:	mov	r0, r6
    6a0c:	bl	65ec <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)>
          lfnOrd = 0;
    6a10:	cmp	r0, #0
    6a12:	it	eq
    6a14:	moveq	r5, #0
    6a16:	b.n	697c <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        }
      }
    } else if (isFileOrSubdir(dir)) {
    6a18:	lsls	r3, r2, #28
    6a1a:	bmi.n	69ba <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
      if (lfnOrd) {
    6a1c:	cbz	r5, 6a32 <FatFile::open(FatFile*, FatName_t*, int)+0x11a>
        if (1 == order && lfnChecksum(dir->name) == checksum) {
    6a1e:	cmp.w	r8, #1
    6a22:	bne.n	692e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    6a24:	bl	65ce <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>
    6a28:	ldr	r3, [sp, #16]
    6a2a:	cmp	r3, r0
    6a2c:	bne.w	692e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    6a30:	b.n	6a4c <FatFile::open(FatFile*, FatName_t*, int)+0x134>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    6a32:	movs	r2, #11
    6a34:	ldr	r1, [sp, #28]
    6a36:	bl	b130 <memcmp>
    6a3a:	cmp	r0, #0
    6a3c:	bne.n	697c <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        if (!(fname->flags & FNAME_FLAG_LOST_CHARS)) {
    6a3e:	ldrb.w	r3, [sl, #21]
    6a42:	lsls	r0, r3, #31
    6a44:	bpl.n	6a4c <FatFile::open(FatFile*, FatName_t*, int)+0x134>
          goto found;
        }
        fnameFound = true;
    6a46:	movs	r3, #1
    6a48:	str	r3, [sp, #20]
    6a4a:	b.n	697c <FatFile::open(FatFile*, FatName_t*, int)+0x64>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    6a4c:	ldr	r3, [sp, #12]
    6a4e:	lsls	r1, r3, #20
    6a50:	bpl.n	6b46 <FatFile::open(FatFile*, FatName_t*, int)+0x22e>
    6a52:	b.n	692e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
  }
  goto open;

 create:
  // don't create unless O_CREAT and write mode
  if (!(oflag & O_CREAT) || !isWriteMode(oflag)) {
    6a54:	ldr	r3, [sp, #12]
    6a56:	lsls	r2, r3, #22
    6a58:	bpl.w	692e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    6a5c:	and.w	r3, r3, #3
    6a60:	subs	r3, #1
    6a62:	cmp	r3, #1
    6a64:	bhi.w	692e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_WARN_MACRO;
    goto fail;
  }
  // Keep found entries or start at current index if no free entries found.
  if (freeFound == 0) {
    6a68:	cmp	r4, #0
    6a6a:	it	eq
    6a6c:	moveq	r9, r7
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    6a6e:	cmp	r4, fp
    6a70:	bcc.n	6a78 <FatFile::open(FatFile*, FatName_t*, int)+0x160>
      DBG_FAIL_MACRO;
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
  }
  if (fnameFound) {
    6a72:	ldr	r3, [sp, #20]
    6a74:	cbnz	r3, 6aa6 <FatFile::open(FatFile*, FatName_t*, int)+0x18e>
    6a76:	b.n	6ab4 <FatFile::open(FatFile*, FatName_t*, int)+0x19c>
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    dir = dirFile->readDirCache();
    6a78:	movs	r1, #0
    6a7a:	mov	r0, r6
    6a7c:	bl	57c4 <FatFile::readDirCache(bool)>
    if (!dir) {
    6a80:	cbnz	r0, 6a88 <FatFile::open(FatFile*, FatName_t*, int)+0x170>
      if (dirFile->getError()) {
    6a82:	ldrb	r3, [r6, #1]
    6a84:	cbz	r3, 6a9a <FatFile::open(FatFile*, FatName_t*, int)+0x182>
    6a86:	b.n	692e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
        goto fail;
      }
      // EOF if no error.
      break;
    }
    freeFound++;
    6a88:	adds	r4, #1
    6a8a:	uxtb	r4, r4
  // Keep found entries or start at current index if no free entries found.
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    6a8c:	b.n	6a6e <FatFile::open(FatFile*, FatName_t*, int)+0x156>
    6a8e:	ldr	r3, [r6, #8]
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
    6a90:	ldrb	r3, [r3, #4]
    6a92:	add	r4, r3
    6a94:	uxtb	r4, r4
      // EOF if no error.
      break;
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
    6a96:	cmp	fp, r4
    6a98:	bls.n	6a72 <FatFile::open(FatFile*, FatName_t*, int)+0x15a>
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
    6a9a:	mov	r0, r6
    6a9c:	bl	551c <FatFile::addDirCluster()>
    6aa0:	cmp	r0, #0
    6aa2:	bne.n	6a8e <FatFile::open(FatFile*, FatName_t*, int)+0x176>
    6aa4:	b.n	692e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
  }
  if (fnameFound) {
    if (!dirFile->makeUniqueSfn(fname)) {
    6aa6:	mov	r1, sl
    6aa8:	mov	r0, r6
    6aaa:	bl	6884 <FatFile::makeUniqueSfn(FatName_t*)>
    6aae:	cmp	r0, #0
    6ab0:	beq.w	692e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
      goto fail;
    }
  }
  lfnOrd = freeNeed - 1;
    6ab4:	add.w	r5, fp, #4294967295
    6ab8:	uxtb	r5, r5
  curIndex = freeIndex + lfnOrd;
    6aba:	add.w	r7, r9, r5
    6abe:	uxth	r7, r7
  if (!dirFile->createLFN(curIndex, fname, lfnOrd)) {
    6ac0:	mov	r3, r5
    6ac2:	mov	r2, sl
    6ac4:	mov	r1, r7
    6ac6:	mov	r0, r6
    6ac8:	bl	6688 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)>
    6acc:	cmp	r0, #0
    6ace:	beq.w	692e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    goto fail;
  }
  dir = dirFile->cacheDir(curIndex);
    6ad2:	mov	r1, r7
    6ad4:	mov	r0, r6
    6ad6:	bl	5300 <FatFile::cacheDir(unsigned short)>
  if (!dir) {
    6ada:	mov	r4, r0
    6adc:	cmp	r0, #0
    6ade:	beq.w	692e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
    6ae2:	movs	r2, #32
    6ae4:	movs	r1, #0
    6ae6:	bl	88dc <memset>
  memcpy(dir->name, fname->sfn, 11);
    6aea:	mov	r3, sl
    6aec:	ldr.w	r2, [r3, #22]!
    6af0:	str	r2, [r4, #0]
    6af2:	ldr	r2, [r3, #4]
    6af4:	str	r2, [r4, #4]
    6af6:	ldrh	r2, [r3, #8]
    6af8:	strh	r2, [r4, #8]
    6afa:	ldrb	r3, [r3, #10]
    6afc:	strb	r3, [r4, #10]

  // Set base-name and extension lower case bits.
  dir->caseFlags = (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;
    6afe:	ldrb.w	r3, [sl, #21]
    6b02:	and.w	r3, r3, #24
    6b06:	strb	r3, [r4, #12]

  // Set timestamps.
  if (FsDateTime::callback) {
    6b08:	ldr	r3, [pc, #88]	; (6b64 <FatFile::open(FatFile*, FatName_t*, int)+0x24c>)
    6b0a:	ldr	r3, [r3, #0]
    6b0c:	cbz	r3, 6b2e <FatFile::open(FatFile*, FatName_t*, int)+0x216>
    // call user date/time function
    FsDateTime::callback(&date, &time, &ms10);
    6b0e:	add.w	r2, sp, #35	; 0x23
    6b12:	add.w	r1, sp, #38	; 0x26
    6b16:	add	r0, sp, #36	; 0x24
    6b18:	blx	r3
    6b1a:	ldrh.w	r3, [sp, #36]	; 0x24
    6b1e:	strh	r3, [r4, #16]
    6b20:	ldrh.w	r3, [sp, #38]	; 0x26
    6b24:	strh	r3, [r4, #14]
    setLe16(dir->createDate, date);
    setLe16(dir->createTime, time);
    dir->createTimeMs = ms10;
    6b26:	ldrb.w	r3, [sp, #35]	; 0x23
    6b2a:	strb	r3, [r4, #13]
    6b2c:	b.n	6b38 <FatFile::open(FatFile*, FatName_t*, int)+0x220>
    6b2e:	movw	r3, #21537	; 0x5421
    6b32:	strh	r3, [r4, #16]
    6b34:	strh	r3, [r4, #24]
    6b36:	strh	r3, [r4, #18]
      setLe16(dir->createTime, FS_DEFAULT_TIME);
      setLe16(dir->modifyTime, FS_DEFAULT_TIME);
    }
  }
  // Force write of entry to device.
  dirFile->m_vol->cacheDirty();
    6b38:	ldr	r2, [r6, #8]
    6b3a:	ldrb.w	r3, [r2, #40]	; 0x28
    6b3e:	orr.w	r3, r3, #1
    6b42:	strb.w	r3, [r2, #40]	; 0x28

 open:
  // open entry in cache.
  if (!openCachedEntry(dirFile, curIndex, oflag, lfnOrd)) {
    6b46:	str	r5, [sp, #0]
    6b48:	ldr	r3, [sp, #12]
    6b4a:	ldr	r0, [sp, #24]
    6b4c:	mov	r2, r7
    6b4e:	mov	r1, r6
    6b50:	bl	58aa <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    6b54:	b.n	6b5c <FatFile::open(FatFile*, FatName_t*, int)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
    6b56:	mov.w	fp, #1
    6b5a:	b.n	695c <FatFile::open(FatFile*, FatName_t*, int)+0x44>
  }
  return true;

 fail:
  return false;
}
    6b5c:	add	sp, #44	; 0x2c
    6b5e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6b62:	nop
    6b64:	.word	0x1fff8418

00006b68 <FatFile::parsePathName(char const*, FatName_t*, char const**)>:
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            FatName_t* fname, const char** ptr) {
    6b68:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    6b6a:	mov	r4, r2
    6b6c:	mov	r6, r3
    6b6e:	mov	r0, r1
    6b70:	adds	r1, #1
  size_t len = 0;
  // Skip leading spaces.
  while (*path == ' ') {
    6b72:	ldrb	r3, [r0, #0]
    6b74:	cmp	r3, #32
    6b76:	beq.n	6b6e <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    6b78:	ldr	r7, [pc, #128]	; (6bfc <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x94>)
    path++;
  }
  fname->begin = path;
    6b7a:	str	r0, [r4, #0]
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            FatName_t* fname, const char** ptr) {
  size_t len = 0;
    6b7c:	movs	r5, #0
  // Skip leading spaces.
  while (*path == ' ') {
    path++;
  }
  fname->begin = path;
  while (*path && !isDirSeparator(*path)) {
    6b7e:	ldrb	r3, [r0, #0]
    6b80:	cbz	r3, 6bd4 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6c>
    6b82:	cmp	r3, #47	; 0x2f
    6b84:	beq.n	6bd4 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6c>
#if USE_UTF8_LONG_NAMES
    uint32_t cp;
    // Allow end = path + 4 since path is zero terminated.
    path = FsUtf::mbToCp(path, path + 4, &cp);
    6b86:	add	r2, sp, #4
    6b88:	adds	r1, r0, #4
    6b8a:	bl	2d78 <FsUtf::mbToCp(char const*, char const*, unsigned long*)>
    if (!path) {
    6b8e:	cbz	r0, 6bf4 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    len += cp <= 0XFFFF ? 1 : 2;
    6b90:	ldr	r2, [sp, #4]
    6b92:	cmp.w	r2, #65536	; 0x10000
    6b96:	ite	cs
    6b98:	movcs	r3, #2
    6b9a:	movcc	r3, #1
    if (cp < 0X80 && lfnReservedChar(cp)) {
    6b9c:	cmp	r2, #127	; 0x7f
    path = FsUtf::mbToCp(path, path + 4, &cp);
    if (!path) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    len += cp <= 0XFFFF ? 1 : 2;
    6b9e:	add	r5, r3
    if (cp < 0X80 && lfnReservedChar(cp)) {
    6ba0:	bhi.n	6bca <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x62>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    6ba2:	cmp	r2, #31
    6ba4:	bls.n	6bf4 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    6ba6:	uxtb	r3, r2
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    6ba8:	sub.w	r1, r3, #34	; 0x22
    6bac:	uxtb	r1, r1
    6bae:	cmp	r1, #29
    6bb0:	bhi.n	6bba <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x52>
    6bb2:	lsr.w	r1, r7, r1
    6bb6:	lsls	r1, r1, #31
    6bb8:	bmi.n	6bf4 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    6bba:	and.w	r3, r3, #191	; 0xbf
    6bbe:	cmp	r3, #60	; 0x3c
    6bc0:	beq.n	6bf4 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    6bc2:	cmp	r2, #92	; 0x5c
    6bc4:	beq.n	6bf4 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    len++;
#endif  // USE_UTF8_LONG_NAMES
    if (cp != '.' && cp != ' ') {
    6bc6:	cmp	r2, #46	; 0x2e
    6bc8:	beq.n	6b7e <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
    6bca:	cmp	r2, #32
    6bcc:	beq.n	6b7e <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
      // Need to trim trailing dots spaces.
      fname->len = len;
    6bce:	str	r5, [r4, #16]
      fname->end = path;
    6bd0:	str	r0, [r4, #8]
  // Skip leading spaces.
  while (*path == ' ') {
    path++;
  }
  fname->begin = path;
  while (*path && !isDirSeparator(*path)) {
    6bd2:	b.n	6b7e <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
      // Need to trim trailing dots spaces.
      fname->len = len;
      fname->end = path;
    }
  }
  if (!fname->len || fname->len > FAT_MAX_LFN_LENGTH) {
    6bd4:	ldr	r3, [r4, #16]
    6bd6:	subs	r3, #1
    6bd8:	cmp	r3, #254	; 0xfe
    6bda:	bhi.n	6bf4 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    6bdc:	mov	r2, r0
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
    6bde:	ldrb.w	r3, [r0], #1
    6be2:	cmp	r3, #32
    6be4:	beq.n	6bdc <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x74>
    6be6:	cmp	r3, #47	; 0x2f
    6be8:	beq.n	6bdc <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x74>
  *ptr = path;
    6bea:	str	r2, [r6, #0]
  return makeSFN(fname);
    6bec:	mov	r0, r4
    6bee:	bl	675c <FatFile::makeSFN(FatName_t*)>
    6bf2:	b.n	6bf6 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8e>

 fail:
  return false;
    6bf4:	movs	r0, #0
}
    6bf6:	add	sp, #12
    6bf8:	pop	{r4, r5, r6, r7, pc}
    6bfa:	nop
    6bfc:	.word	0x31002101

00006c00 <FatFile::remove()>:
//------------------------------------------------------------------------------
bool FatFile::remove() {
    6c00:	push	{r4, r5, r6, r7, lr}
    6c02:	sub	sp, #44	; 0x2c
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    6c04:	movs	r3, #0
    6c06:	strb.w	r3, [sp, #4]
    6c0a:	strb.w	r3, [sp, #5]
    6c0e:	strb.w	r3, [sp, #6]
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    6c12:	ldrb	r3, [r0, #2]
    6c14:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::remove() {
    6c16:	mov	r4, r0
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    6c18:	bpl.n	6c4a <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
    6c1a:	ldr	r1, [r0, #32]
    6c1c:	cbz	r1, 6c26 <FatFile::remove()+0x26>
    6c1e:	ldr	r0, [r0, #8]
    6c20:	bl	63de <FatPartition::freeChain(unsigned long)>
    6c24:	cbz	r0, 6c4a <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Cache directory entry.
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6c26:	movs	r1, #1
    6c28:	mov	r0, r4
    6c2a:	bl	55a8 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    6c2e:	mov	r5, r0
    6c30:	cbz	r0, 6c4a <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  checksum = lfnChecksum(dir->name);
    6c32:	bl	65ce <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;
    6c36:	movs	r6, #229	; 0xe5
    6c38:	strb	r6, [r5, #0]

  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    6c3a:	movs	r3, #0
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  checksum = lfnChecksum(dir->name);
    6c3c:	mov	r7, r0

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;

  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    6c3e:	strb	r3, [r4, #0]
  m_flags = 0;
    6c40:	strb	r3, [r4, #2]

  // Write entry to device.
  if (!m_vol->cacheSync()) {
    6c42:	ldr	r0, [r4, #8]
    6c44:	bl	54c0 <FatPartition::cacheSync()>
    6c48:	cbnz	r0, 6c4e <FatFile::remove()+0x4e>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  return false;
    6c4a:	movs	r0, #0
    6c4c:	b.n	6cae <FatFile::remove()+0xae>
  // Write entry to device.
  if (!m_vol->cacheSync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    6c4e:	ldrb	r3, [r4, #3]
    6c50:	cbz	r3, 6cae <FatFile::remove()+0xae>
    // Done, no LFN entries.
    return true;
  }
  if (!dirFile.openCluster(this)) {
    6c52:	mov	r1, r4
    6c54:	add	r0, sp, #4
    6c56:	bl	55f6 <FatFile::openCluster(FatFile*)>
    6c5a:	cmp	r0, #0
    6c5c:	beq.n	6c4a <FatFile::remove()+0x4a>
    6c5e:	movs	r5, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    6c60:	ldrb	r3, [r4, #3]
    6c62:	cmp	r3, r5
    6c64:	bcc.n	6c4a <FatFile::remove()+0x4a>
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.cacheDir(m_dirIndex - order));
    6c66:	ldrh	r1, [r4, #4]
    6c68:	subs	r1, r1, r5
    6c6a:	uxth	r1, r1
    6c6c:	add	r0, sp, #4
    6c6e:	bl	5300 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    6c72:	cmp	r0, #0
    6c74:	beq.n	6c4a <FatFile::remove()+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    6c76:	ldrb	r3, [r0, #11]
    6c78:	cmp	r3, #15
    6c7a:	bne.n	6c4a <FatFile::remove()+0x4a>
        order != (ldir->order & 0X1F) ||
    6c7c:	ldrb	r2, [r0, #0]
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.cacheDir(m_dirIndex - order));
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    6c7e:	and.w	r3, r2, #31
    6c82:	cmp	r5, r3
    6c84:	bne.n	6c4a <FatFile::remove()+0x4a>
        order != (ldir->order & 0X1F) ||
    6c86:	ldrb	r3, [r0, #13]
    6c88:	cmp	r3, r7
    6c8a:	bne.n	6c4a <FatFile::remove()+0x4a>
        checksum != ldir->checksum) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    last = ldir->order & FAT_ORDER_LAST_LONG_ENTRY;
    ldir->order = FAT_NAME_DELETED;
    6c8c:	strb	r6, [r0, #0]
    m_vol->cacheDirty();
    6c8e:	ldr	r1, [r4, #8]
    6c90:	ldrb.w	r3, [r1, #40]	; 0x28
    6c94:	orr.w	r3, r3, #1
    6c98:	strb.w	r3, [r1, #40]	; 0x28
    if (last) {
    6c9c:	lsls	r3, r2, #25
    6c9e:	bpl.n	6ca8 <FatFile::remove()+0xa8>
      if (!m_vol->cacheSync()) {
    6ca0:	ldr	r0, [r4, #8]
    6ca2:	bl	54c0 <FatPartition::cacheSync()>
    6ca6:	b.n	6cae <FatFile::remove()+0xae>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    6ca8:	adds	r5, #1
    6caa:	uxtb	r5, r5
    6cac:	b.n	6c60 <FatFile::remove()+0x60>
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  return false;
}
    6cae:	add	sp, #44	; 0x2c
    6cb0:	pop	{r4, r5, r6, r7, pc}

00006cb2 <FsBaseFile::FsBaseFile(FsBaseFile const&)>:
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    6cb2:	push	{r3, r4, r5, r6, r7, lr}
    6cb4:	movs	r4, #0
    6cb6:	str	r4, [r0, #56]	; 0x38
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    6cb8:	ldr	r7, [r1, #56]	; 0x38
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    6cba:	str	r4, [r0, #60]	; 0x3c
    6cbc:	mov	r6, r0
    6cbe:	mov	r5, r1
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    6cc0:	cbz	r7, 6ce4 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x32>
    m_fFile = new (m_fileMem) FatFile;
    6cc2:	mov	r1, r0
    6cc4:	movs	r0, #36	; 0x24
    6cc6:	bl	6efc <operator new(unsigned int, unsigned long*)>
    6cca:	strb	r4, [r0, #0]
    6ccc:	strb	r4, [r0, #1]
    6cce:	strb	r4, [r0, #2]
    6cd0:	str	r0, [r6, #56]	; 0x38
    *m_fFile = *from.m_fFile;
    6cd2:	ldr	r5, [r5, #56]	; 0x38
    6cd4:	mov	r4, r0
    6cd6:	ldmia	r5!, {r0, r1, r2, r3}
    6cd8:	stmia	r4!, {r0, r1, r2, r3}
    6cda:	ldmia	r5!, {r0, r1, r2, r3}
    6cdc:	stmia	r4!, {r0, r1, r2, r3}
    6cde:	ldr	r3, [r5, #0]
    6ce0:	str	r3, [r4, #0]
    6ce2:	b.n	6d10 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x5e>
  } else if (from.m_xFile) {
    6ce4:	ldr	r3, [r1, #60]	; 0x3c
    6ce6:	cbz	r3, 6d10 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x5e>
    m_xFile = new (m_fileMem) ExFatFile;
    6ce8:	mov	r1, r0
    6cea:	movs	r0, #56	; 0x38
    6cec:	bl	6efc <operator new(unsigned int, unsigned long*)>
    6cf0:	strb.w	r7, [r0, #49]	; 0x31
    6cf4:	strb.w	r7, [r0, #50]	; 0x32
    6cf8:	strb.w	r7, [r0, #51]	; 0x33
    6cfc:	str	r0, [r6, #60]	; 0x3c
    *m_xFile = *from.m_xFile;
    6cfe:	ldr	r3, [r5, #60]	; 0x3c
    6d00:	add.w	r2, r3, #52	; 0x34
    6d04:	ldr.w	r1, [r3], #4
    6d08:	str.w	r1, [r0], #4
    6d0c:	cmp	r3, r2
    6d0e:	bne.n	6d04 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x52>
  }
}
    6d10:	mov	r0, r6
    6d12:	pop	{r3, r4, r5, r6, r7, pc}

00006d14 <FsBaseFile::close()>:
    *m_xFile = *from.m_xFile;
  }
  return *this;
}
//------------------------------------------------------------------------------
bool FsBaseFile::close() {
    6d14:	push	{r4, lr}
    6d16:	mov	r4, r0
  if (m_fFile && m_fFile->close()) {
    6d18:	ldr	r0, [r0, #56]	; 0x38
    6d1a:	cbz	r0, 6d22 <FsBaseFile::close()+0xe>
    6d1c:	bl	5ad4 <FatFile::close()>
    6d20:	cbnz	r0, 6d32 <FsBaseFile::close()+0x1e>
    m_fFile = nullptr;
    return true;
  }
  if (m_xFile && m_xFile->close()) {
    6d22:	ldr	r0, [r4, #60]	; 0x3c
    6d24:	cbz	r0, 6d38 <FsBaseFile::close()+0x24>
    6d26:	bl	38c6 <ExFatFile::close()>
    6d2a:	cbz	r0, 6d38 <FsBaseFile::close()+0x24>
    m_xFile = nullptr;
    6d2c:	movs	r3, #0
    6d2e:	str	r3, [r4, #60]	; 0x3c
    6d30:	pop	{r4, pc}
  return *this;
}
//------------------------------------------------------------------------------
bool FsBaseFile::close() {
  if (m_fFile && m_fFile->close()) {
    m_fFile = nullptr;
    6d32:	movs	r3, #0
    6d34:	str	r3, [r4, #56]	; 0x38
    return true;
    6d36:	pop	{r4, pc}
  }
  if (m_xFile && m_xFile->close()) {
    m_xFile = nullptr;
    return true;
  }
  return false;
    6d38:	movs	r0, #0
}
    6d3a:	pop	{r4, pc}

00006d3c <FsBaseFile::open(FsVolume*, char const*, int)>:
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
    6d3c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6d40:	mov	r4, r0
    6d42:	mov	r7, r2
    6d44:	mov	r8, r3
  if (!vol) {
    6d46:	mov	r5, r1
    6d48:	cbnz	r1, 6d50 <FsBaseFile::open(FsVolume*, char const*, int)+0x14>
    return false;
    6d4a:	movs	r0, #0
    6d4c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  close();
    6d50:	bl	6d14 <FsBaseFile::close()>
  if (vol->m_fVol) {
    6d54:	ldr.w	r6, [r5, #1152]	; 0x480
    6d58:	cbz	r6, 6d80 <FsBaseFile::open(FsVolume*, char const*, int)+0x44>
    m_fFile = new (m_fileMem) FatFile;
    6d5a:	mov	r1, r4
    6d5c:	movs	r0, #36	; 0x24
    6d5e:	bl	6efc <operator new(unsigned int, unsigned long*)>
    6d62:	movs	r2, #0
    6d64:	strb	r2, [r0, #0]
    6d66:	strb	r2, [r0, #1]
    6d68:	strb	r2, [r0, #2]
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    6d6a:	mov	r3, r8
  if (!vol) {
    return false;
  }
  close();
  if (vol->m_fVol) {
    m_fFile = new (m_fileMem) FatFile;
    6d6c:	str	r0, [r4, #56]	; 0x38
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    6d6e:	mov	r2, r7
    6d70:	ldr.w	r1, [r5, #1152]	; 0x480
    6d74:	bl	5b8c <FatFile::open(FatVolume*, char const*, int)>
    6d78:	cbz	r0, 6db4 <FsBaseFile::open(FsVolume*, char const*, int)+0x78>
      return true;
    6d7a:	movs	r0, #1
    6d7c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    m_fFile = nullptr;
  } else if (vol->m_xVol) {
    6d80:	ldr.w	r3, [r5, #1156]	; 0x484
    6d84:	cmp	r3, #0
    6d86:	beq.n	6d4a <FsBaseFile::open(FsVolume*, char const*, int)+0xe>
    m_xFile = new (m_fileMem) ExFatFile;
    6d88:	mov	r1, r4
    6d8a:	movs	r0, #56	; 0x38
    6d8c:	bl	6efc <operator new(unsigned int, unsigned long*)>
    6d90:	strb.w	r6, [r0, #49]	; 0x31
    6d94:	strb.w	r6, [r0, #50]	; 0x32
    6d98:	strb.w	r6, [r0, #51]	; 0x33
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    6d9c:	mov	r3, r8
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
      return true;
    }
    m_fFile = nullptr;
  } else if (vol->m_xVol) {
    m_xFile = new (m_fileMem) ExFatFile;
    6d9e:	str	r0, [r4, #60]	; 0x3c
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    6da0:	mov	r2, r7
    6da2:	ldr.w	r1, [r5, #1156]	; 0x484
    6da6:	bl	4046 <ExFatFile::open(ExFatVolume*, char const*, int)>
    6daa:	cmp	r0, #0
    6dac:	bne.n	6d7a <FsBaseFile::open(FsVolume*, char const*, int)+0x3e>
      return true;
    }
    m_xFile = nullptr;
    6dae:	str	r0, [r4, #60]	; 0x3c
  }
  return false;
}
    6db0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (vol->m_fVol) {
    m_fFile = new (m_fileMem) FatFile;
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
      return true;
    }
    m_fFile = nullptr;
    6db4:	str	r0, [r4, #56]	; 0x38
    6db6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00006dba <FsBaseFile::openNext(FsBaseFile*, int)>:
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::openNext(FsBaseFile* dir, oflag_t oflag) {
    6dba:	push	{r3, r4, r5, r6, r7, lr}
    6dbc:	mov	r5, r1
    6dbe:	mov	r4, r0
    6dc0:	mov	r7, r2
  close();
    6dc2:	bl	6d14 <FsBaseFile::close()>
  if (dir->m_fFile) {
    6dc6:	ldr	r6, [r5, #56]	; 0x38
    6dc8:	cbz	r6, 6dee <FsBaseFile::openNext(FsBaseFile*, int)+0x34>
    m_fFile = new (m_fileMem) FatFile;
    6dca:	mov	r1, r4
    6dcc:	movs	r0, #36	; 0x24
    6dce:	bl	6efc <operator new(unsigned int, unsigned long*)>
    6dd2:	movs	r2, #0
    6dd4:	strb	r2, [r0, #0]
    6dd6:	strb	r2, [r0, #1]
    6dd8:	strb	r2, [r0, #2]
    6dda:	str	r0, [r4, #56]	; 0x38
    if (m_fFile->openNext(dir->m_fFile, oflag)) {
    6ddc:	mov	r2, r7
    6dde:	ldr	r1, [r5, #56]	; 0x38
    6de0:	bl	596c <FatFile::openNext(FatFile*, int)>
    6de4:	cbz	r0, 6dea <FsBaseFile::openNext(FsBaseFile*, int)+0x30>
      return true;
    6de6:	movs	r0, #1
    6de8:	pop	{r3, r4, r5, r6, r7, pc}
    }
    m_fFile = nullptr;
    6dea:	str	r0, [r4, #56]	; 0x38
    6dec:	pop	{r3, r4, r5, r6, r7, pc}
  } else if (dir->m_xFile) {
    6dee:	ldr	r0, [r5, #60]	; 0x3c
    6df0:	cbz	r0, 6e16 <FsBaseFile::openNext(FsBaseFile*, int)+0x5c>
    m_xFile = new (m_fileMem) ExFatFile;
    6df2:	mov	r1, r4
    6df4:	movs	r0, #56	; 0x38
    6df6:	bl	6efc <operator new(unsigned int, unsigned long*)>
    6dfa:	strb.w	r6, [r0, #49]	; 0x31
    6dfe:	strb.w	r6, [r0, #50]	; 0x32
    6e02:	strb.w	r6, [r0, #51]	; 0x33
    6e06:	str	r0, [r4, #60]	; 0x3c
    if (m_xFile->openNext(dir->m_xFile, oflag)) {
    6e08:	mov	r2, r7
    6e0a:	ldr	r1, [r5, #60]	; 0x3c
    6e0c:	bl	4054 <ExFatFile::openNext(ExFatFile*, int)>
    6e10:	cmp	r0, #0
    6e12:	bne.n	6de6 <FsBaseFile::openNext(FsBaseFile*, int)+0x2c>
      return true;
    }
    m_xFile = nullptr;
    6e14:	str	r0, [r4, #60]	; 0x3c
  }
  return false;
}
    6e16:	pop	{r3, r4, r5, r6, r7, pc}

00006e18 <FsVolume::begin(BlockDeviceInterface*)>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    6e18:	push	{r3, r4, r5, r6, r7, lr}
  m_blockDev = blockDev;
  m_fVol = nullptr;
    6e1a:	movs	r6, #0
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    6e1c:	mov	r4, r0
  m_blockDev = blockDev;
    6e1e:	str.w	r1, [r0, #1160]	; 0x488
  m_fVol = nullptr;
    6e22:	str.w	r6, [r0, #1152]	; 0x480
  m_xVol = new (m_volMem) ExFatVolume;
    6e26:	mov	r1, r0
    6e28:	mov.w	r0, #1152	; 0x480
    6e2c:	bl	6efc <operator new(unsigned int, unsigned long*)>
 * \class ExFatPartition
 * \brief Access exFat partitions on raw file devices.
 */
class ExFatPartition {
 public:
  ExFatPartition() {}
    6e30:	strb.w	r6, [r0, #1092]	; 0x444
    6e34:	strb.w	r6, [r0, #1145]	; 0x479
    6e38:	strb.w	r6, [r0, #1146]	; 0x47a
    6e3c:	strb.w	r6, [r0, #1147]	; 0x47b
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    6e40:	movs	r2, #1
    6e42:	str.w	r0, [r4, #1156]	; 0x484
    6e46:	ldr.w	r1, [r4, #1160]	; 0x488
    6e4a:	ldr	r7, [pc, #124]	; (6ec8 <FsVolume::begin(BlockDeviceInterface*)+0xb0>)
    6e4c:	mov	r5, r0
    6e4e:	bl	43ac <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>
    6e52:	cbz	r0, 6e6c <FsVolume::begin(BlockDeviceInterface*)+0x54>
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    6e54:	add.w	r6, r5, #1096	; 0x448
    6e58:	mov	r0, r6
    6e5a:	bl	38c6 <ExFatFile::close()>
    return m_vwd.openRoot(this);
    6e5e:	mov	r1, r5
    6e60:	mov	r0, r6
    6e62:	bl	391a <ExFatFile::openRoot(ExFatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    6e66:	cbz	r0, 6e6c <FsVolume::begin(BlockDeviceInterface*)+0x54>
      return false;
    }
    if (setCwv || !m_cwv) {
    6e68:	ldr	r3, [pc, #96]	; (6ecc <FsVolume::begin(BlockDeviceInterface*)+0xb4>)
    6e6a:	b.n	6eb2 <FsVolume::begin(BlockDeviceInterface*)+0x9a>
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    6e6c:	movs	r6, #0
  m_fVol = new (m_volMem) FatVolume;
    6e6e:	mov	r1, r4
  m_fVol = nullptr;
  m_xVol = new (m_volMem) ExFatVolume;
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    6e70:	str.w	r6, [r4, #1156]	; 0x484
  m_fVol = new (m_volMem) FatVolume;
    6e74:	movw	r0, #1132	; 0x46c
    6e78:	bl	6efc <operator new(unsigned int, unsigned long*)>
 */
class FatPartition {
 public:
  /** Create an instance of FatPartition
   */
  FatPartition() {}
    6e7c:	strb	r6, [r0, #7]
    6e7e:	strb.w	r6, [r0, #1096]	; 0x448
    6e82:	strb.w	r6, [r0, #1097]	; 0x449
    6e86:	strb.w	r6, [r0, #1098]	; 0x44a
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    6e8a:	movs	r2, #1
    6e8c:	str.w	r0, [r4, #1152]	; 0x480
    6e90:	ldr.w	r1, [r4, #1160]	; 0x488
    6e94:	mov	r5, r0
    6e96:	bl	6480 <FatPartition::init(BlockDeviceInterface*, unsigned char)>
    6e9a:	cbz	r0, 6ebe <FsVolume::begin(BlockDeviceInterface*)+0xa6>
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    6e9c:	add.w	r6, r5, #1096	; 0x448
    6ea0:	mov	r0, r6
    6ea2:	bl	5ad4 <FatFile::close()>
    return m_vwd.openRoot(this);
    6ea6:	mov	r1, r5
    6ea8:	mov	r0, r6
    6eaa:	bl	55c6 <FatFile::openRoot(FatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    6eae:	cbz	r0, 6ebe <FsVolume::begin(BlockDeviceInterface*)+0xa6>
      return false;
    }
    if (setCwv || !m_cwv) {
    6eb0:	ldr	r3, [pc, #28]	; (6ed0 <FsVolume::begin(BlockDeviceInterface*)+0xb8>)
    6eb2:	ldr	r2, [r3, #0]
    6eb4:	cbnz	r2, 6eb8 <FsVolume::begin(BlockDeviceInterface*)+0xa0>
      m_cwv = this;
    6eb6:	str	r5, [r3, #0]
  m_cwv = nullptr;
  m_fVol = nullptr;
  return false;

 done:
  m_cwv = this;
    6eb8:	str	r4, [r7, #0]
  return true;
    6eba:	movs	r0, #1
    6ebc:	pop	{r3, r4, r5, r6, r7, pc}
  m_xVol = nullptr;
  m_fVol = new (m_volMem) FatVolume;
  if (m_fVol && m_fVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_cwv = nullptr;
    6ebe:	movs	r0, #0
    6ec0:	str	r0, [r7, #0]
  m_fVol = nullptr;
    6ec2:	str.w	r0, [r4, #1152]	; 0x480
  return false;

 done:
  m_cwv = this;
  return true;
}
    6ec6:	pop	{r3, r4, r5, r6, r7, pc}
    6ec8:	.word	0x1fff8424
    6ecc:	.word	0x1fff841c
    6ed0:	.word	0x1fff8420

00006ed4 <FsVolume::open(char const*, int)>:
bool FsVolume::ls(print_t* pr, const char* path, uint8_t flags) {
  FsBaseFile dir;
  return dir.open(this, path, O_RDONLY) && dir.ls(pr, flags);
}
//------------------------------------------------------------------------------
FsFile FsVolume::open(const char *path, oflag_t oflag) {
    6ed4:	push	{r3, r4, r5, lr}
    6ed6:	mov	r4, r0
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    6ed8:	movs	r0, #0
    6eda:	strb	r0, [r4, #4]
    6edc:	strb	r0, [r4, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
    6ede:	str	r0, [r4, #72]	; 0x48
    6ee0:	str	r0, [r4, #76]	; 0x4c
    6ee2:	mov.w	r5, #1000	; 0x3e8
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    6ee6:	mov	r0, r4
    6ee8:	str	r5, [r4, #8]
    6eea:	ldr	r5, [pc, #12]	; (6ef8 <FsVolume::open(char const*, int)+0x24>)
    6eec:	str.w	r5, [r0], #16
  FsFile tmpFile;
  tmpFile.open(this, path, oflag);
    6ef0:	bl	6d3c <FsBaseFile::open(FsVolume*, char const*, int)>
  return tmpFile;
}
    6ef4:	mov	r0, r4
    6ef6:	pop	{r3, r4, r5, pc}
    6ef8:	.word	0x00011cfc

00006efc <operator new(unsigned int, unsigned long*)>:
 */
#include "FsNew.h"
void* operator new(size_t size, newalign_t* ptr) {
  (void)size;
  return ptr;
}
    6efc:	mov	r0, r1
    6efe:	bx	lr

00006f00 <SdSpiCard::errorCode() const>:
  /**
   * \return code for the last error. See SdCardInfo.h for a list of error codes.
   */
  uint8_t errorCode() const {
    return m_errorCode;
  }
    6f00:	ldrb	r0, [r0, #15]
    6f02:	bx	lr

00006f04 <SdSpiCard::errorData() const>:
  /** \return error data for last error. */
  uint32_t errorData() const {
    return m_status;
  }
    6f04:	ldrb	r0, [r0, #17]
    6f06:	bx	lr

00006f08 <SdSpiCard::readSector(unsigned long, unsigned char*)>:
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    6f08:	ldr	r3, [r0, #0]
   *
   * \param[in] sector Logical sector to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
    6f0a:	push	{r4}
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    6f0c:	ldr	r4, [r3, #16]
    6f0e:	movs	r3, #1
    6f10:	mov	ip, r4
#else  // ENABLE_DEDICATED_SPI
    return readSingle(sector, dst);
#endif  // ENABLE_DEDICATED_SPI
  }
    6f12:	ldr.w	r4, [sp], #4
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    6f16:	bx	ip

00006f18 <SdSpiCard::type() const>:
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
  }
    6f18:	ldrb	r0, [r0, #18]
    6f1a:	bx	lr

00006f1c <SdSpiCard::~SdSpiCard()>:
/**
 * \class SdSpiCard
 * \brief Raw access to SD and SDHC flash memory cards via SPI protocol.
 */
#if HAS_SDIO_CLASS
class SdSpiCard : public SdCardInterface {
    6f1c:	bx	lr

00006f1e <SdSpiCard::~SdSpiCard()>:
    6f1e:	push	{r4, lr}
    6f20:	movs	r1, #20
    6f22:	mov	r4, r0
    6f24:	bl	9c1c <operator delete(void*, unsigned int)>
    6f28:	mov	r0, r4
    6f2a:	pop	{r4, pc}

00006f2c <SdSpiCard::sectorCount()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
uint32_t SdSpiCard::sectorCount() {
    6f2c:	push	{r0, r1, r2, r3, r4, lr}
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
    6f2e:	ldr	r3, [r0, #0]
    6f30:	mov	r1, sp
    6f32:	ldr	r3, [r3, #60]	; 0x3c
    6f34:	blx	r3
    6f36:	cbz	r0, 6fa6 <SdSpiCard::sectorCount()+0x7a>
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    6f38:	ldrb.w	r3, [sp]
    6f3c:	ands.w	r3, r3, #192	; 0xc0
    6f40:	bne.n	6f82 <SdSpiCard::sectorCount()+0x56>
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    6f42:	ldrb.w	r0, [sp, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    6f46:	ldrb.w	r3, [sp, #7]
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    6f4a:	ldrb.w	r2, [sp, #10]
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    6f4e:	and.w	r0, r0, #3
    6f52:	lsls	r3, r3, #2
    6f54:	orr.w	r3, r3, r0, lsl #10
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    6f58:	ldrb.w	r0, [sp, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    6f5c:	orr.w	r0, r3, r0, lsr #6
    6f60:	adds	r3, r0, #1
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    6f62:	ldrb.w	r0, [sp, #9]
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    6f66:	and.w	r0, r0, #3
    6f6a:	lsls	r0, r0, #1
    6f6c:	orr.w	r0, r0, r2, lsr #7
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    6f70:	ldrb.w	r2, [sp, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    6f74:	and.w	r2, r2, #15
    6f78:	add	r0, r2
    6f7a:	subs	r0, #7
    6f7c:	lsl.w	r0, r3, r0
    6f80:	b.n	6fa6 <SdSpiCard::sectorCount()+0x7a>
  } else if (csd->v2.csd_ver == 1) {
    6f82:	cmp	r3, #64	; 0x40
    6f84:	bne.n	6fa4 <SdSpiCard::sectorCount()+0x78>
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    6f86:	ldrb.w	r0, [sp, #9]
    6f8a:	adds	r3, r0, #1
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    6f8c:	ldrb.w	r0, [sp, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    6f90:	and.w	r0, r0, #63	; 0x3f
    6f94:	add.w	r0, r3, r0, lsl #16
    6f98:	ldrb.w	r3, [sp, #8]
    6f9c:	add.w	r0, r0, r3, lsl #8
    6fa0:	lsls	r0, r0, #10
    6fa2:	b.n	6fa6 <SdSpiCard::sectorCount()+0x7a>
    6fa4:	movs	r0, #0
}
    6fa6:	add	sp, #20
    6fa8:	ldr.w	pc, [sp], #4

00006fac <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>:
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spiDriverPtr->receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriverPtr->send(data);
    6fac:	ldr	r3, [r0, #0]
    6fae:	ldr	r3, [r3, #20]
    6fb0:	bx	r3

00006fb2 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>:
  }
  void spiDeactivate() {
    m_spiDriverPtr->deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriverPtr->receive();
    6fb2:	ldr	r3, [r0, #0]
    6fb4:	ldr	r3, [r3, #12]
    6fb6:	bx	r3

00006fb8 <SysCall::curTimeMS()>:
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    6fb8:	ldr	r3, [pc, #12]	; (6fc8 <SysCall::curTimeMS()+0x10>)
/** Define macro for strings stored in flash. */
#define F(str) (str)
#endif  // F
//------------------------------------------------------------------------------
/** \return the time in milliseconds. */
inline SdMillis_t SysCall::curTimeMS() {
    6fba:	sub	sp, #8
    6fbc:	ldr	r3, [r3, #0]
    6fbe:	str	r3, [sp, #4]
	return ret;
    6fc0:	ldr	r0, [sp, #4]
  return millis();
}
    6fc2:	uxth	r0, r0
    6fc4:	add	sp, #8
    6fc6:	bx	lr
    6fc8:	.word	0x1fff8484

00006fcc <SdSpiCard::spiStart()>:
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
    6fcc:	push	{r3, r4, r5, lr}
  if (!m_spiActive) {
    6fce:	ldrb	r5, [r0, #16]
uint32_t SdSpiCard::sectorCount() {
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
    6fd0:	mov	r4, r0
  if (!m_spiActive) {
    6fd2:	cbnz	r5, 6ff0 <SdSpiCard::spiStart()+0x24>
    6fd4:	ldr	r0, [r0, #4]
    m_spiDriver.setSckSpeed(maxSck);
  }
  SdSpiDriver m_spiDriver;
#else  // SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriverPtr->activate();
    6fd6:	ldr	r3, [r0, #0]
    6fd8:	ldr	r3, [r3, #0]
    6fda:	blx	r3
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    6fdc:	mov	r1, r5
    6fde:	ldrb	r0, [r4, #14]
    6fe0:	bl	197c <sdCsWrite(unsigned char, bool)>
    spiActivate();
    spiSelect();
    // Dummy byte to drive MISO busy status.
    spiSend(0XFF);    
    6fe4:	movs	r1, #255	; 0xff
    6fe6:	ldr	r0, [r4, #4]
    6fe8:	bl	6fac <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    m_spiActive = true;
    6fec:	movs	r3, #1
    6fee:	strb	r3, [r4, #16]
    6ff0:	pop	{r3, r4, r5, pc}

00006ff2 <SdSpiCard::spiStop()>:
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    6ff2:	ldrb	r3, [r0, #16]
    spiSend(0XFF);    
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
    6ff4:	push	{r4, lr}
    6ff6:	mov	r4, r0
  if (m_spiActive) {
    6ff8:	cbz	r3, 7016 <SdSpiCard::spiStop()+0x24>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    6ffa:	movs	r1, #1
    6ffc:	ldrb	r0, [r0, #14]
    6ffe:	bl	197c <sdCsWrite(unsigned char, bool)>
    spiUnselect();
    // Insure MISO goes to low Z.
    spiSend(0XFF);        
    7002:	movs	r1, #255	; 0xff
    7004:	ldr	r0, [r4, #4]
    7006:	bl	6fac <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    700a:	ldr	r0, [r4, #4]
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriverPtr->begin(spiConfig);
  }
  void spiDeactivate() {
    m_spiDriverPtr->deactivate();
    700c:	ldr	r3, [r0, #0]
    700e:	ldr	r3, [r3, #8]
    7010:	blx	r3
    spiDeactivate();
    m_spiActive = false;
    7012:	movs	r3, #0
    7014:	strb	r3, [r4, #16]
    7016:	pop	{r4, pc}

00007018 <SdSpiCard::isBusy()>:
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    7018:	push	{r4, r5, r6, lr}
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    701a:	ldrb	r3, [r0, #12]
    701c:	cmp	r3, #1
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    701e:	mov	r5, r0
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    7020:	beq.n	7042 <SdSpiCard::isBusy()+0x2a>
    return false;
  }
#endif  // ENABLE_DEDICATED_SPI
  bool spiActive = m_spiActive;
    7022:	ldrb	r6, [r0, #16]
  if (!spiActive) {
    7024:	cbnz	r6, 702a <SdSpiCard::isBusy()+0x12>
    spiStart();
    7026:	bl	6fcc <SdSpiCard::spiStart()>
  }
  bool rtn = 0XFF != spiReceive();
    702a:	ldr	r0, [r5, #4]
    702c:	bl	6fb2 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7030:	subs.w	r4, r0, #255	; 0xff
    7034:	it	ne
    7036:	movne	r4, #1
  if (!spiActive) {
    7038:	cbnz	r6, 7046 <SdSpiCard::isBusy()+0x2e>
    spiStop();
    703a:	mov	r0, r5
    703c:	bl	6ff2 <SdSpiCard::spiStop()>
    7040:	b.n	7046 <SdSpiCard::isBusy()+0x2e>
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    return false;
    7042:	movs	r0, #0
    7044:	pop	{r4, r5, r6, pc}
  }
  bool rtn = 0XFF != spiReceive();
  if (!spiActive) {
    spiStop();
  }
  return rtn;
    7046:	mov	r0, r4
}
    7048:	pop	{r4, r5, r6, pc}

0000704a <SdSpiCard::readData(unsigned char*, unsigned int)>:
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst) {
  return readData(dst, 512);
}
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst, size_t count) {
    704a:	push	{r3, r4, r5, r6, r7, lr}
    704c:	mov	r4, r0
    704e:	mov	r5, r1
    7050:	mov	r6, r2
  uint16_t crc;
#endif  // USE_SD_CRC

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
    7052:	bl	6fb8 <SysCall::curTimeMS()>
    7056:	mov	r7, r0
  while ((m_status = spiReceive()) == 0XFF) {
    7058:	ldr	r0, [r4, #4]
    705a:	bl	6fb2 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    705e:	cmp	r0, #255	; 0xff
    7060:	strb	r0, [r4, #17]
    7062:	bne.n	7074 <SdSpiCard::readData(unsigned char*, unsigned int)+0x2a>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    7064:	bl	6fb8 <SysCall::curTimeMS()>

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
  while ((m_status = spiReceive()) == 0XFF) {
    if (isTimedOut(t0, SD_READ_TIMEOUT)) {
    7068:	subs	r0, r0, r7
    706a:	cmp.w	r0, #300	; 0x12c
    706e:	ble.n	7058 <SdSpiCard::readData(unsigned char*, unsigned int)+0xe>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7070:	movs	r3, #29
    7072:	b.n	708e <SdSpiCard::readData(unsigned char*, unsigned int)+0x44>
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
    }
  }
  DBG_END_TIME(DBG_WAIT_READ);
  if (m_status != DATA_START_SECTOR) {
    7074:	cmp	r0, #254	; 0xfe
    7076:	beq.n	707c <SdSpiCard::readData(unsigned char*, unsigned int)+0x32>
    7078:	movs	r3, #24
    707a:	b.n	708e <SdSpiCard::readData(unsigned char*, unsigned int)+0x44>
    707c:	ldr	r0, [r4, #4]
  }
  uint8_t spiReceive() {
    return m_spiDriverPtr->receive();
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spiDriverPtr->receive(buf, n);
    707e:	ldr	r3, [r0, #0]
    7080:	mov	r2, r6
    7082:	ldr	r3, [r3, #16]
    7084:	mov	r1, r5
    7086:	blx	r3
    error(SD_CARD_ERROR_READ_TOKEN);
    goto fail;
  }
  // transfer data
  if ((m_status = spiReceive(dst, count))) {
    7088:	strb	r0, [r4, #17]
    708a:	cbz	r0, 709a <SdSpiCard::readData(unsigned char*, unsigned int)+0x50>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    708c:	movs	r3, #37	; 0x25
  spiReceive();
#endif  // USE_SD_CRC
  return true;

 fail:
  spiStop();
    708e:	mov	r0, r4
    7090:	strb	r3, [r4, #15]
    7092:	bl	6ff2 <SdSpiCard::spiStop()>
  return false;
    7096:	movs	r0, #0
}
    7098:	pop	{r3, r4, r5, r6, r7, pc}
    error(SD_CARD_ERROR_READ_CRC);
    goto fail;
  }
#else  // USE_SD_CRC
  // discard crc
  spiReceive();
    709a:	ldr	r0, [r4, #4]
    709c:	bl	6fb2 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
  spiReceive();
    70a0:	ldr	r0, [r4, #4]
    70a2:	bl	6fb2 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    70a6:	movs	r0, #1
    70a8:	pop	{r3, r4, r5, r6, r7, pc}

000070aa <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    70aa:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    70ae:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    70b0:	ldrb	r3, [r0, #12]
    70b2:	cmp	r3, #2
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    70b4:	mov	r4, r0
    70b6:	mov	r5, r1
    70b8:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    70ba:	bne.n	70c2 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x18>
    70bc:	ldr	r3, [r0, #8]
    70be:	cmp	r3, r1
    70c0:	beq.n	70d4 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2a>
    if (!writeStart(sector)) {
    70c2:	ldr	r3, [r4, #0]
    70c4:	mov	r1, r5
    70c6:	ldr	r3, [r3, #80]	; 0x50
    70c8:	mov	r0, r4
    70ca:	blx	r3
    70cc:	cbz	r0, 7102 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x58>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
    70ce:	movs	r3, #2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    if (!writeStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    70d0:	str	r5, [r4, #8]
    m_curState = WRITE_STATE;
    70d2:	strb	r3, [r4, #12]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    70d4:	movs	r5, #0
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    70d6:	cmp	r5, r7
    70d8:	add.w	r1, r6, r5, lsl #9
    70dc:	beq.n	70ec <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x42>
    if (!writeData(src)) {
    70de:	ldr	r3, [r4, #0]
    70e0:	mov	r0, r4
    70e2:	ldr	r3, [r3, #76]	; 0x4c
    70e4:	blx	r3
    70e6:	cbz	r0, 7102 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x58>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    70e8:	adds	r5, #1
    70ea:	b.n	70d6 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2c>
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    70ec:	ldr	r3, [r4, #8]
    70ee:	add	r5, r3
  return m_sharedSpi ? syncDevice() : true;
    70f0:	ldrb	r3, [r4, #13]
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    70f2:	str	r5, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    70f4:	cbz	r3, 710e <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x64>
    70f6:	ldr	r3, [r4, #0]
    70f8:	mov	r0, r4
    70fa:	ldr	r3, [r3, #28]
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    70fc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7100:	bx	r3
  }
  return writeStop();
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
    7102:	mov	r0, r4
    7104:	bl	6ff2 <SdSpiCard::spiStop()>
  return false;
    7108:	movs	r0, #0
    710a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    710e:	movs	r0, #1
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    7110:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00007114 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)>:
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    7114:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7118:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    711a:	ldrb	r3, [r0, #12]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    711c:	ldr.w	r8, [sp, #32]
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    7120:	cmp	r3, #2
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    7122:	mov	r4, r0
    7124:	mov	r5, r1
    7126:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    7128:	bne.n	7130 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x1c>
    712a:	ldr	r3, [r0, #8]
    712c:	cmp	r3, r1
    712e:	beq.n	7142 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x2e>
    if (!writeStart(sector)) {
    7130:	ldr	r3, [r4, #0]
    7132:	mov	r1, r5
    7134:	ldr	r3, [r3, #80]	; 0x50
    7136:	mov	r0, r4
    7138:	blx	r3
    713a:	cbz	r0, 7178 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x64>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
    713c:	movs	r3, #2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    if (!writeStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    713e:	str	r5, [r4, #8]
    m_curState = WRITE_STATE;
    7140:	strb	r3, [r4, #12]
    7142:	add.w	r9, r5, r6
  }
  for (size_t i = 0; i < ns; i++) {
    7146:	cmp	r5, r9
    7148:	beq.n	7162 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x4e>
    const uint8_t *src = callback(sector + i, context);
    714a:	mov	r1, r8
    714c:	mov	r0, r5
    714e:	blx	r7
    if (!writeData(src)) {
    7150:	ldr	r3, [r4, #0]
    7152:	mov	r1, r0
    7154:	ldr	r3, [r3, #76]	; 0x4c
    7156:	mov	r0, r4
    7158:	blx	r3
    715a:	adds	r5, #1
    715c:	cmp	r0, #0
    715e:	bne.n	7146 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x32>
    7160:	b.n	7178 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x64>
      goto fail;
    }
  }
  m_curSector += ns;
    7162:	ldr	r3, [r4, #8]
    7164:	add	r6, r3
  return m_sharedSpi ? syncDevice() : true;
    7166:	ldrb	r3, [r4, #13]
    const uint8_t *src = callback(sector + i, context);
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
    7168:	str	r6, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    716a:	cbz	r3, 7184 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x70>
    716c:	ldr	r3, [r4, #0]
    716e:	mov	r0, r4
    7170:	ldr	r3, [r3, #28]
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    7172:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7176:	bx	r3
  }
  return writeStop();
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
    7178:	mov	r0, r4
    717a:	bl	6ff2 <SdSpiCard::spiStop()>
  return false;
    717e:	movs	r0, #0
    7180:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7184:	movs	r0, #1
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    7186:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000718a <SdSpiCard::waitNotBusy(unsigned short)>:
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
//------------------------------------------------------------------------------
// wait for card to go not busy
bool SdSpiCard::waitNotBusy(SdMillis_t timeoutMS) {
    718a:	push	{r4, r5, r6, lr}
    718c:	mov	r6, r0
    718e:	mov	r4, r1
  SdMillis_t t0 = SysCall::curTimeMS();
    7190:	bl	6fb8 <SysCall::curTimeMS()>
    7194:	mov	r5, r0
    }
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    7196:	ldr	r0, [r6, #4]
    7198:	bl	6fb2 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    719c:	cmp	r0, #255	; 0xff
    719e:	beq.n	71ae <SdSpiCard::waitNotBusy(unsigned short)+0x24>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    71a0:	bl	6fb8 <SysCall::curTimeMS()>
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    if (isTimedOut(t0, timeoutMS)) {
    71a4:	subs	r0, r0, r5
    71a6:	cmp	r0, r4
    71a8:	ble.n	7196 <SdSpiCard::waitNotBusy(unsigned short)+0xc>
      return false;
    71aa:	movs	r0, #0
    71ac:	pop	{r4, r5, r6, pc}
    }
  }
  return true;
    71ae:	movs	r0, #1
#endif  // WDT_YIELD_TIME_MILLIS
}
    71b0:	pop	{r4, r5, r6, pc}

000071b2 <SdSpiCard::cardCommand(unsigned char, unsigned long)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    71b2:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    71b4:	ldrb	r3, [r0, #12]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    71b6:	str	r2, [sp, #4]
    71b8:	mov	r4, r0
    71ba:	mov	r5, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    71bc:	cbz	r3, 71ca <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x18>
    71be:	ldr	r3, [r0, #0]
    71c0:	ldr	r3, [r3, #28]
    71c2:	blx	r3
    71c4:	cbnz	r0, 71ca <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x18>
    return 0XFF;
    71c6:	movs	r0, #255	; 0xff
    71c8:	b.n	722a <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x78>
  }
#endif  // ENABLE_DEDICATED_SPI
  // select card
  if (!m_spiActive) {
    71ca:	ldrb	r3, [r4, #16]
    71cc:	cbnz	r3, 71d4 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x22>
    spiStart();
    71ce:	mov	r0, r4
    71d0:	bl	6fcc <SdSpiCard::spiStart()>
  }
  // wait if busy unless CMD0
  if (cmd != CMD0) {
    71d4:	cbz	r5, 71e0 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x2e>
    DBG_BEGIN_TIME(DBG_CMD_BUSY);
    waitNotBusy(SD_CMD_TIMEOUT);
    71d6:	mov.w	r1, #300	; 0x12c
    71da:	mov	r0, r4
    71dc:	bl	718a <SdSpiCard::waitNotBusy(unsigned short)>

  // send message
  spiSend(buf, 6);
#else  // USE_SD_CRC
  // send command
  spiSend(cmd | 0x40);
    71e0:	orr.w	r1, r5, #64	; 0x40
    71e4:	ldr	r0, [r4, #4]
    71e6:	bl	6fac <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    71ea:	add.w	r6, sp, #7
    71ee:	add.w	r7, sp, #3

  // send argument
  uint8_t* pa = reinterpret_cast<uint8_t*>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    spiSend(pa[i]);
    71f2:	ldrb.w	r1, [r6], #-1
    71f6:	ldr	r0, [r4, #4]
    71f8:	bl	6fac <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
  // send command
  spiSend(cmd | 0x40);

  // send argument
  uint8_t* pa = reinterpret_cast<uint8_t*>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    71fc:	cmp	r7, r6
    71fe:	bne.n	71f2 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x40>
    spiSend(pa[i]);
  }

  // send CRC - correct for CMD0 with arg zero or CMD8 with arg 0X1AA
  spiSend(cmd == CMD0 ? 0X95 : 0X87);
    7200:	cmp	r5, #0
    7202:	ite	eq
    7204:	moveq	r1, #149	; 0x95
    7206:	movne	r1, #135	; 0x87
    7208:	ldr	r0, [r4, #4]
    720a:	bl	6fac <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
#endif  // USE_SD_CRC

  // discard first fill byte to avoid MISO pull-up problem.
  spiReceive();
    720e:	ldr	r0, [r4, #4]
    7210:	bl	6fb2 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7214:	movs	r5, #11

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
    7216:	ldr	r0, [r4, #4]
    7218:	bl	6fb2 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    721c:	lsls	r3, r0, #24
    721e:	strb	r0, [r4, #17]
    7220:	bpl.n	722a <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x78>
    7222:	subs	r5, #1
    7224:	ands.w	r5, r5, #255	; 0xff
    7228:	bne.n	7216 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x64>
  }
  return m_status;
}
    722a:	add	sp, #12
    722c:	pop	{r4, r5, r6, r7, pc}

0000722e <SdSpiCard::cardAcmd(unsigned char, unsigned long)>:
  /** Set CS high and deactivate the card. */
  void spiStop();

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    722e:	push	{r4, r5, r6, lr}
    7230:	mov	r4, r0
    7232:	mov	r5, r1
    7234:	mov	r6, r2
    cardCommand(CMD55, 0);
    7236:	movs	r1, #55	; 0x37
    7238:	movs	r2, #0
    723a:	bl	71b2 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    return cardCommand(cmd, arg);
    723e:	mov	r2, r6
    7240:	mov	r1, r5
    7242:	mov	r0, r4
  }
    7244:	ldmia.w	sp!, {r4, r5, r6, lr}

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    cardCommand(CMD55, 0);
    return cardCommand(cmd, arg);
    7248:	b.w	71b2 <SdSpiCard::cardCommand(unsigned char, unsigned long)>

0000724c <SdSpiCard::begin(SdSpiConfig)>:
#endif  // CRC_CCITT
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
    724c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7250:	sub	sp, #36	; 0x24
    7252:	add	r5, sp, #4
    7254:	stmia.w	r5, {r1, r2, r3}
    7258:	mov	r4, r0
    725a:	ldrb.w	sl, [sp, #4]
    725e:	ldr.w	fp, [sp, #12]
    7262:	ldrb.w	r8, [sp, #5]
    7266:	ldr	r6, [sp, #8]
  SdMillis_t t0 = SysCall::curTimeMS();
    7268:	bl	6fb8 <SysCall::curTimeMS()>
  m_spiActive = false;
    726c:	mov.w	r9, #0
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
  SdMillis_t t0 = SysCall::curTimeMS();
    7270:	mov	r7, r0
  m_spiActive = false;
    7272:	strb.w	r9, [r4, #16]
  m_errorCode = SD_CARD_ERROR_NONE;
    7276:	strb.w	r9, [r4, #15]
  m_type = 0;
    727a:	strb.w	r9, [r4, #18]
  m_csPin = spiConfig.csPin;
    727e:	strb.w	sl, [r4, #14]
#if SPI_DRIVER_SELECT >= 2
  m_spiDriverPtr = spiConfig.spiPort;
    7282:	str.w	fp, [r4, #4]
  if (!m_spiDriverPtr) {
    7286:	cmp.w	fp, #0
    728a:	bne.n	7290 <SdSpiCard::begin(SdSpiConfig)+0x44>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    728c:	movs	r3, #42	; 0x2a
    728e:	b.n	73c4 <SdSpiCard::begin(SdSpiConfig)+0x178>
    error(SD_CARD_ERROR_INVALID_CARD_CONFIG);
    goto fail;
  }
#endif  // SPI_DRIVER_SELECT
  sdCsInit(m_csPin);
    7290:	mov	r0, sl
    7292:	bl	1960 <sdCsInit(unsigned char)>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    7296:	movs	r1, #1
    7298:	ldrb	r0, [r4, #14]
    729a:	bl	197c <sdCsWrite(unsigned char, bool)>
    729e:	ldr	r0, [r4, #4]
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
  }
  void spiSetSckSpeed(uint32_t maxSck) {
    m_spiDriverPtr->setSckSpeed(maxSck);
    72a0:	ldr	r1, [pc, #344]	; (73fc <SdSpiCard::begin(SdSpiConfig)+0x1b0>)
    72a2:	ldr	r3, [r0, #0]
    72a4:	ldr	r3, [r3, #28]
    72a6:	blx	r3
    72a8:	ldmia.w	r5, {r0, r1, r2}
    72ac:	add	r3, sp, #20
    72ae:	ldr.w	lr, [r4, #4]
    72b2:	stmia.w	r3, {r0, r1, r2}
#else  // SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriverPtr->activate();
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriverPtr->begin(spiConfig);
    72b6:	ldr.w	r2, [lr]
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
  m_sharedSpi = spiOptionShared(spiConfig.options);
    72ba:	and.w	r8, r8, #1
    72be:	mov	r0, lr
    72c0:	ldr	r5, [r2, #4]
    72c2:	eor.w	r8, r8, #1
    72c6:	ldmia	r3, {r1, r2, r3}
    72c8:	blx	r5
#else  // ENABLE_DEDICATED_SPI
  // m_sharedSpi is a static const bool in this case.
  static_assert(m_sharedSpi == true, "m_sharedSpi bug");
#endif  // ENABLE_DEDICATED_SPI
  spiStart();
    72ca:	mov	r0, r4
  spiUnselect();
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
    72cc:	strb.w	r9, [r4, #12]
  m_sharedSpi = spiOptionShared(spiConfig.options);
    72d0:	strb.w	r8, [r4, #13]
#else  // ENABLE_DEDICATED_SPI
  // m_sharedSpi is a static const bool in this case.
  static_assert(m_sharedSpi == true, "m_sharedSpi bug");
#endif  // ENABLE_DEDICATED_SPI
  spiStart();
    72d4:	bl	6fcc <SdSpiCard::spiStart()>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    72d8:	movs	r1, #1
    72da:	ldrb	r0, [r4, #14]
    72dc:	bl	197c <sdCsWrite(unsigned char, bool)>
    72e0:	movs	r5, #10

  // must supply min of 74 clock cycles with CS high.
  spiUnselect();
  for (uint8_t i = 0; i < 10; i++) {
    spiSend(0XFF);
    72e2:	movs	r1, #255	; 0xff
    72e4:	ldr	r0, [r4, #4]
    72e6:	subs	r5, #1
    72e8:	bl	6fac <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
#endif  // ENABLE_DEDICATED_SPI
  spiStart();

  // must supply min of 74 clock cycles with CS high.
  spiUnselect();
  for (uint8_t i = 0; i < 10; i++) {
    72ec:	ands.w	r5, r5, #255	; 0xff
    72f0:	bne.n	72e2 <SdSpiCard::begin(SdSpiConfig)+0x96>
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    72f2:	mov	r1, r5
    72f4:	ldrb	r0, [r4, #14]
    72f6:	bl	197c <sdCsWrite(unsigned char, bool)>
    72fa:	movs	r5, #10
  spiSelect();
  DBG_BEGIN_TIME(DBG_CMD0_TIME);
  // command to go idle in SPI mode
  for (uint8_t i = 1;; i++) {
    DBG_EVENT_COUNT(DBG_CMD0_COUNT);
    if (cardCommand(CMD0, 0) == R1_IDLE_STATE) {
    72fc:	movs	r2, #0
    72fe:	mov	r1, r2
    7300:	mov	r0, r4
    7302:	bl	71b2 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7306:	cmp	r0, #1
    7308:	mov	r8, r0
    730a:	beq.n	7332 <SdSpiCard::begin(SdSpiConfig)+0xe6>
    730c:	subs	r5, #1
      break;
    }
    if (i == SD_CMD0_RETRY) {
    730e:	ands.w	r5, r5, #255	; 0xff
    7312:	bne.n	7318 <SdSpiCard::begin(SdSpiConfig)+0xcc>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7314:	movs	r3, #1
    7316:	b.n	73c4 <SdSpiCard::begin(SdSpiConfig)+0x178>
      error(SD_CARD_ERROR_CMD0);
      goto fail;
    }
    // stop multi-block write
    spiSend(STOP_TRAN_TOKEN);
    7318:	movs	r1, #253	; 0xfd
    731a:	ldr	r0, [r4, #4]
    731c:	bl	6fac <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    7320:	mov.w	r8, #520	; 0x208
    // finish block transfer
    for (int i = 0; i < 520; i++) {
      spiReceive();
    7324:	ldr	r0, [r4, #4]
    7326:	bl	6fb2 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
      goto fail;
    }
    // stop multi-block write
    spiSend(STOP_TRAN_TOKEN);
    // finish block transfer
    for (int i = 0; i < 520; i++) {
    732a:	subs.w	r8, r8, #1
    732e:	bne.n	7324 <SdSpiCard::begin(SdSpiConfig)+0xd8>
    7330:	b.n	72fc <SdSpiCard::begin(SdSpiConfig)+0xb0>
    goto fail;
  }
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    7332:	mov.w	r2, #426	; 0x1aa
    7336:	movs	r1, #8
    7338:	mov	r0, r4
    733a:	bl	71b2 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    733e:	lsls	r3, r0, #29
    7340:	bmi.n	7360 <SdSpiCard::begin(SdSpiConfig)+0x114>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    7342:	movs	r3, #2
    7344:	strb	r3, [r4, #18]
    7346:	movs	r5, #4
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
      m_status = spiReceive();
    7348:	ldr	r0, [r4, #4]
    734a:	bl	6fb2 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    734e:	subs	r5, #1
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    7350:	ands.w	r5, r5, #255	; 0xff
      m_status = spiReceive();
    7354:	strb	r0, [r4, #17]
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    7356:	bne.n	7348 <SdSpiCard::begin(SdSpiConfig)+0xfc>
      m_status = spiReceive();
    }
    if (m_status != 0XAA) {
    7358:	cmp	r0, #170	; 0xaa
    735a:	beq.n	7364 <SdSpiCard::begin(SdSpiConfig)+0x118>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    735c:	movs	r3, #6
    735e:	b.n	73c4 <SdSpiCard::begin(SdSpiConfig)+0x178>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    7360:	strb.w	r8, [r4, #18]
    }
  } else {
    type(SD_CARD_TYPE_SD1);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
    7364:	ldr	r3, [r4, #0]
    7366:	mov	r0, r4
    7368:	ldr	r3, [r3, #72]	; 0x48
    736a:	blx	r3
    736c:	cmp	r0, #2
    736e:	ite	eq
    7370:	moveq.w	r8, #1073741824	; 0x40000000
    7374:	movne.w	r8, #0
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    7378:	mov	r2, r8
    737a:	movs	r1, #41	; 0x29
    737c:	mov	r0, r4
    737e:	bl	722e <SdSpiCard::cardAcmd(unsigned char, unsigned long)>
    7382:	mov	r5, r0
    7384:	cbz	r0, 7396 <SdSpiCard::begin(SdSpiConfig)+0x14a>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    7386:	bl	6fb8 <SysCall::curTimeMS()>
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    DBG_EVENT_COUNT(DBG_ACMD41_COUNT);
    // check for timeout
    if (isTimedOut(t0, SD_INIT_TIMEOUT)) {
    738a:	subs	r0, r0, r7
    738c:	cmp.w	r0, #2000	; 0x7d0
    7390:	ble.n	7378 <SdSpiCard::begin(SdSpiConfig)+0x12c>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7392:	movs	r3, #23
    7394:	b.n	73c4 <SdSpiCard::begin(SdSpiConfig)+0x178>
    }
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    7396:	ldr	r3, [r4, #0]
    7398:	mov	r0, r4
    739a:	ldr	r3, [r3, #72]	; 0x48
    739c:	blx	r3
    739e:	cmp	r0, #2
    73a0:	beq.n	73b6 <SdSpiCard::begin(SdSpiConfig)+0x16a>
    // Discard rest of ocr - contains allowed voltage range.
    for (uint8_t i = 0; i < 3; i++) {
      spiReceive();
    }
  }
  spiStop();
    73a2:	mov	r0, r4
    73a4:	bl	6ff2 <SdSpiCard::spiStop()>
    73a8:	ldr	r0, [r4, #4]
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
  }
  void spiSetSckSpeed(uint32_t maxSck) {
    m_spiDriverPtr->setSckSpeed(maxSck);
    73aa:	ldr	r3, [r0, #0]
    73ac:	mov	r1, r6
    73ae:	ldr	r3, [r3, #28]
    73b0:	blx	r3
  spiSetSckSpeed(spiConfig.maxSck);
  return true;
    73b2:	movs	r0, #1
    73b4:	b.n	73f6 <SdSpiCard::begin(SdSpiConfig)+0x1aa>
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
    73b6:	mov	r2, r5
    73b8:	movs	r1, #58	; 0x3a
    73ba:	mov	r0, r4
    73bc:	bl	71b2 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    73c0:	cbz	r0, 73d0 <SdSpiCard::begin(SdSpiConfig)+0x184>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    73c2:	movs	r3, #18
  spiStop();
  spiSetSckSpeed(spiConfig.maxSck);
  return true;

 fail:
  spiStop();
    73c4:	mov	r0, r4
    73c6:	strb	r3, [r4, #15]
    73c8:	bl	6ff2 <SdSpiCard::spiStop()>
  return false;
    73cc:	movs	r0, #0
    73ce:	b.n	73f6 <SdSpiCard::begin(SdSpiConfig)+0x1aa>
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
      error(SD_CARD_ERROR_CMD58);
      goto fail;
    }
    if ((spiReceive() & 0XC0) == 0XC0) {
    73d0:	ldr	r0, [r4, #4]
    73d2:	bl	6fb2 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    73d6:	and.w	r0, r0, #192	; 0xc0
    73da:	cmp	r0, #192	; 0xc0
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    73dc:	itt	eq
    73de:	moveq	r3, #3
    73e0:	strbeq	r3, [r4, #18]
      type(SD_CARD_TYPE_SDHC);
    }
    // Discard rest of ocr - contains allowed voltage range.
    for (uint8_t i = 0; i < 3; i++) {
      spiReceive();
    73e2:	ldr	r0, [r4, #4]
    73e4:	bl	6fb2 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    73e8:	ldr	r0, [r4, #4]
    73ea:	bl	6fb2 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    73ee:	ldr	r0, [r4, #4]
    73f0:	bl	6fb2 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    73f4:	b.n	73a2 <SdSpiCard::begin(SdSpiConfig)+0x156>
  return true;

 fail:
  spiStop();
  return false;
}
    73f6:	add	sp, #36	; 0x24
    73f8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    73fc:	.word	0x00061a80

00007400 <SdSpiCard::readOCR(unsigned long*)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7400:	push	{r4, r5, r6, lr}
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    7402:	movs	r2, #0
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7404:	mov	r6, r1
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    7406:	movs	r1, #58	; 0x3a
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7408:	mov	r4, r0
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    740a:	bl	71b2 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    740e:	cbz	r0, 741e <SdSpiCard::readOCR(unsigned long*)+0x1e>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7410:	movs	r3, #18
  }
  spiStop();
  return true;

 fail:
  spiStop();
    7412:	mov	r0, r4
    7414:	strb	r3, [r4, #15]
    7416:	bl	6ff2 <SdSpiCard::spiStop()>
  return false;
    741a:	movs	r0, #0
    741c:	pop	{r4, r5, r6, pc}
    741e:	adds	r5, r6, #4
  if (cardCommand(CMD58, 0)) {
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    p[3 - i] = spiReceive();
    7420:	ldr	r0, [r4, #4]
    7422:	bl	6fb2 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7426:	strb.w	r0, [r5, #-1]!
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    742a:	cmp	r5, r6
    742c:	bne.n	7420 <SdSpiCard::readOCR(unsigned long*)+0x20>
    p[3 - i] = spiReceive();
  }
  spiStop();
    742e:	mov	r0, r4
    7430:	bl	6ff2 <SdSpiCard::spiStop()>
  return true;
    7434:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7436:	pop	{r4, r5, r6, pc}

00007438 <SdSpiCard::readRegister(unsigned char, void*)>:
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    7438:	push	{r3, r4, r5, lr}
    743a:	mov	r5, r2
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    743c:	movs	r2, #0
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    743e:	mov	r4, r0
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    7440:	bl	71b2 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7444:	cbz	r0, 744c <SdSpiCard::readRegister(unsigned char, void*)+0x14>
    7446:	movs	r3, #27
    7448:	strb	r3, [r4, #15]
    744a:	b.n	7462 <SdSpiCard::readRegister(unsigned char, void*)+0x2a>
    error(SD_CARD_ERROR_READ_REG);
    goto fail;
  }
  if (!readData(dst, 16)) {
    744c:	mov	r1, r5
    744e:	movs	r2, #16
    7450:	mov	r0, r4
    7452:	bl	704a <SdSpiCard::readData(unsigned char*, unsigned int)>
    7456:	mov	r5, r0
    7458:	cbz	r0, 7462 <SdSpiCard::readRegister(unsigned char, void*)+0x2a>
    goto fail;
  }
  spiStop();
    745a:	mov	r0, r4
    745c:	bl	6ff2 <SdSpiCard::spiStop()>
  return true;
    7460:	b.n	746a <SdSpiCard::readRegister(unsigned char, void*)+0x32>

 fail:
  spiStop();
    7462:	mov	r0, r4
    7464:	bl	6ff2 <SdSpiCard::spiStop()>
  return false;
    7468:	movs	r5, #0
}
    746a:	mov	r0, r5
    746c:	pop	{r3, r4, r5, pc}

0000746e <SdSpiCard::readCSD(csd_t*)>:
   * \param[out] csd pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCSD(csd_t* csd) {
    return readRegister(CMD9, csd);
    746e:	mov	r2, r1
    7470:	movs	r1, #9
    7472:	b.w	7438 <SdSpiCard::readRegister(unsigned char, void*)>

00007476 <SdSpiCard::readCID(CID*)>:
   * \param[out] cid pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCID(cid_t* cid) {
    return readRegister(CMD10, cid);
    7476:	mov	r2, r1
    7478:	movs	r1, #10
    747a:	b.w	7438 <SdSpiCard::readRegister(unsigned char, void*)>

0000747e <SdSpiCard::readStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    747e:	push	{r3, r4, r5, lr}
  if (type() != SD_CARD_TYPE_SDHC) {
    7480:	ldr	r3, [r0, #0]
    7482:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    7484:	mov	r5, r1
    7486:	mov	r4, r0
  if (type() != SD_CARD_TYPE_SDHC) {
    7488:	blx	r3
    748a:	cmp	r0, #3
    sector <<= 9;
    748c:	it	ne
    748e:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD18, sector)) {
    7490:	mov	r2, r5
    7492:	movs	r1, #18
    7494:	mov	r0, r4
    7496:	bl	71b2 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    749a:	cbz	r0, 74aa <SdSpiCard::readStart(unsigned long)+0x2c>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    749c:	movs	r3, #12
    goto fail;
  }
  return true;

 fail:
  spiStop();
    749e:	mov	r0, r4
    74a0:	strb	r3, [r4, #15]
    74a2:	bl	6ff2 <SdSpiCard::spiStop()>
  return false;
    74a6:	movs	r0, #0
    74a8:	pop	{r3, r4, r5, pc}
  }
  if (cardCommand(CMD18, sector)) {
    error(SD_CARD_ERROR_CMD18);
    goto fail;
  }
  return true;
    74aa:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    74ac:	pop	{r3, r4, r5, pc}

000074ae <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    74ae:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    74b2:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    74b4:	ldrb	r3, [r0, #12]
    74b6:	cmp	r3, #1
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    74b8:	mov	r4, r0
    74ba:	mov	r5, r1
    74bc:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    74be:	bne.n	74c6 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x18>
    74c0:	ldr	r3, [r0, #8]
    74c2:	cmp	r3, r1
    74c4:	beq.n	74dc <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x2e>
    if (!readStart(sector)) {
    74c6:	mov	r1, r5
    74c8:	mov	r0, r4
    74ca:	bl	747e <SdSpiCard::readStart(unsigned long)>
    74ce:	cbnz	r0, 74d6 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x28>
    }
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
    74d0:	movs	r0, #0
    74d2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
    74d6:	movs	r3, #1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    74d8:	str	r5, [r4, #8]
    m_curState = READ_STATE;
    74da:	strb	r3, [r4, #12]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    74dc:	movs	r5, #0
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    74de:	cmp	r5, r7
    74e0:	add.w	r1, r6, r5, lsl #9
    74e4:	beq.n	74f8 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4a>
    if (!readData(dst, 512)) {
    74e6:	mov.w	r2, #512	; 0x200
    74ea:	mov	r0, r4
    74ec:	bl	704a <SdSpiCard::readData(unsigned char*, unsigned int)>
    74f0:	cmp	r0, #0
    74f2:	beq.n	74d0 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x22>
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    74f4:	adds	r5, #1
    74f6:	b.n	74de <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x30>
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    74f8:	ldr	r3, [r4, #8]
    74fa:	add	r5, r3
  return m_sharedSpi ? syncDevice() : true;
    74fc:	ldrb	r3, [r4, #13]
  for (size_t i = 0; i < ns; i++, dst += 512) {
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    74fe:	str	r5, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    7500:	cbz	r3, 750e <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x60>
    7502:	ldr	r3, [r4, #0]
    7504:	mov	r0, r4
    7506:	ldr	r3, [r3, #28]
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7508:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    750c:	bx	r3
    750e:	movs	r0, #1
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7510:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00007514 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)>:
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7514:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7518:	mov	r6, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    751a:	ldrb	r3, [r0, #12]
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    751c:	ldr.w	r8, [sp, #32]
    7520:	ldr.w	r9, [sp, #36]	; 0x24
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7524:	cmp	r3, #1
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7526:	mov	r4, r0
    7528:	mov	r5, r1
    752a:	mov	r7, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    752c:	bne.n	7534 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x20>
    752e:	ldr	r3, [r0, #8]
    7530:	cmp	r3, r1
    7532:	beq.n	754a <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x36>
    if (!readStart(sector)) {
    7534:	mov	r1, r5
    7536:	mov	r0, r4
    7538:	bl	747e <SdSpiCard::readStart(unsigned long)>
    753c:	cbnz	r0, 7544 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x30>
    }
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
    753e:	movs	r0, #0
    7540:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
    7544:	movs	r3, #1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    7546:	str	r5, [r4, #8]
    m_curState = READ_STATE;
    7548:	strb	r3, [r4, #12]
    754a:	add.w	sl, r5, r6
  }
  for (size_t i = 0; i < ns; i++) {
    754e:	cmp	r5, sl
    7550:	beq.n	756e <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x5a>
    if (readData(dst, 512)) {
    7552:	mov.w	r2, #512	; 0x200
    7556:	mov	r1, r7
    7558:	mov	r0, r4
    755a:	bl	704a <SdSpiCard::readData(unsigned char*, unsigned int)>
    755e:	cmp	r0, #0
    7560:	beq.n	753e <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x2a>
      callback(sector + i, dst, context);
    7562:	mov	r0, r5
    7564:	mov	r2, r9
    7566:	mov	r1, r7
    7568:	blx	r8
    756a:	adds	r5, #1
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++) {
    756c:	b.n	754e <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x3a>
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    756e:	ldr	r3, [r4, #8]
    7570:	add	r6, r3
  return m_sharedSpi ? syncDevice() : true;
    7572:	ldrb	r3, [r4, #13]
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    7574:	str	r6, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    7576:	cbz	r3, 7584 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x70>
    7578:	ldr	r3, [r4, #0]
    757a:	mov	r0, r4
    757c:	ldr	r3, [r3, #28]
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    757e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7582:	bx	r3
    7584:	movs	r0, #1
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7586:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000758a <SdSpiCard::readStop()>:
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    758a:	push	{r4, lr}
  if (cardCommand(CMD12, 0)) {
    758c:	movs	r2, #0
    758e:	movs	r1, #12
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    7590:	mov	r4, r0
  if (cardCommand(CMD12, 0)) {
    7592:	bl	71b2 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7596:	cbz	r0, 75a6 <SdSpiCard::readStop()+0x1c>
    7598:	movs	r3, #9
  }
  spiStop();
  return true;

 fail:
  spiStop();
    759a:	mov	r0, r4
    759c:	strb	r3, [r4, #15]
    759e:	bl	6ff2 <SdSpiCard::spiStop()>
  return false;
    75a2:	movs	r0, #0
    75a4:	pop	{r4, pc}
bool SdSpiCard::readStop() {
  if (cardCommand(CMD12, 0)) {
    error(SD_CARD_ERROR_CMD12);
    goto fail;
  }
  spiStop();
    75a6:	mov	r0, r4
    75a8:	bl	6ff2 <SdSpiCard::spiStop()>
  return true;
    75ac:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    75ae:	pop	{r4, pc}

000075b0 <SdSpiCard::syncDevice()>:
}
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
    75b0:	ldrb	r2, [r0, #12]
  m_curState = IDLE_STATE;
    75b2:	movs	r1, #0
  if (state == WRITE_STATE) {
    75b4:	cmp	r2, #2
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
  m_curState = IDLE_STATE;
    75b6:	strb	r1, [r0, #12]
  if (state == WRITE_STATE) {
    75b8:	bne.n	75c0 <SdSpiCard::syncDevice()+0x10>
    return writeStop();
    75ba:	ldr	r3, [r0, #0]
    75bc:	ldr	r3, [r3, #84]	; 0x54
    75be:	bx	r3
  }
  if (state == READ_STATE) {
    75c0:	cmp	r2, #1
    75c2:	bne.n	75c8 <SdSpiCard::syncDevice()+0x18>
    return readStop();
    75c4:	b.w	758a <SdSpiCard::readStop()>
  }
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
    75c8:	movs	r0, #1
    75ca:	bx	lr

000075cc <SdSpiCard::writeStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    75cc:	push	{r3, r4, r5, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    75ce:	ldr	r3, [r0, #0]
    75d0:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    75d2:	mov	r5, r1
    75d4:	mov	r4, r0
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    75d6:	blx	r3
    75d8:	cmp	r0, #3
    sector <<= 9;
    75da:	it	ne
    75dc:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD25, sector)) {
    75de:	mov	r2, r5
    75e0:	movs	r1, #25
    75e2:	mov	r0, r4
    75e4:	bl	71b2 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    75e8:	cbz	r0, 75f8 <SdSpiCard::writeStart(unsigned long)+0x2c>
    75ea:	movs	r3, #14
    goto fail;
  }
  return true;

 fail:
  spiStop();
    75ec:	mov	r0, r4
    75ee:	strb	r3, [r4, #15]
    75f0:	bl	6ff2 <SdSpiCard::spiStop()>
  return false;
    75f4:	movs	r0, #0
    75f6:	pop	{r3, r4, r5, pc}
  }
  if (cardCommand(CMD25, sector)) {
    error(SD_CARD_ERROR_CMD25);
    goto fail;
  }
  return true;
    75f8:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    75fa:	pop	{r3, r4, r5, pc}

000075fc <SdSpiCard::erase(unsigned long, unsigned long)>:
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    75fc:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  csd_t csd;
  if (!readCSD(&csd)) {
    75fe:	ldr	r3, [r0, #0]
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7600:	mov	r6, r1
  csd_t csd;
  if (!readCSD(&csd)) {
    7602:	ldr	r3, [r3, #60]	; 0x3c
    7604:	mov	r1, sp
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7606:	mov	r4, r0
    7608:	mov	r5, r2
  csd_t csd;
  if (!readCSD(&csd)) {
    760a:	blx	r3
    760c:	cbz	r0, 7674 <SdSpiCard::erase(unsigned long, unsigned long)+0x78>
    goto fail;
  }
  // check for single sector erase
  if (!csd.v1.erase_blk_en) {
    760e:	ldrb.w	r3, [sp, #10]
    7612:	lsls	r2, r3, #25
    7614:	bmi.n	7630 <SdSpiCard::erase(unsigned long, unsigned long)+0x34>
    // erase size mask
    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
    7616:	ldrb.w	r2, [sp, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    761a:	and.w	r3, r3, #63	; 0x3f
    761e:	lsls	r3, r3, #1
    7620:	orr.w	r3, r3, r2, lsr #7
    7624:	adds	r2, r5, #1
    7626:	orrs	r2, r6
    7628:	tst	r3, r2
    762a:	beq.n	7630 <SdSpiCard::erase(unsigned long, unsigned long)+0x34>
    762c:	movs	r3, #39	; 0x27
    762e:	b.n	7672 <SdSpiCard::erase(unsigned long, unsigned long)+0x76>
      // error card can't erase specified area
      error(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    7630:	ldrb	r3, [r4, #18]
    7632:	cmp	r3, #3
    firstSector <<= 9;
    7634:	it	ne
    7636:	lslne	r6, r6, #9
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
    7638:	mov	r2, r6
    763a:	mov.w	r1, #32
    763e:	mov	r0, r4
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
    7640:	it	ne
    7642:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD32, firstSector)
    7644:	bl	71b2 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
      || cardCommand(CMD33, lastSector)
      || cardCommand(CMD38, 0)) {
    7648:	cbnz	r0, 767e <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
      || cardCommand(CMD33, lastSector)
    764a:	mov	r2, r5
    764c:	movs	r1, #33	; 0x21
    764e:	mov	r0, r4
    7650:	bl	71b2 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7654:	mov	r2, r0
    7656:	cbnz	r0, 767e <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
      || cardCommand(CMD38, 0)) {
    7658:	movs	r1, #38	; 0x26
    765a:	mov	r0, r4
    765c:	bl	71b2 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7660:	cbnz	r0, 767e <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
    error(SD_CARD_ERROR_ERASE);
    goto fail;
  }
  DBG_BEGIN_TIME(DBG_ERASE_BUSY);
  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    7662:	movw	r1, #10000	; 0x2710
    7666:	mov	r0, r4
    7668:	bl	718a <SdSpiCard::waitNotBusy(unsigned short)>
    766c:	mov	r5, r0
    766e:	cbnz	r0, 7682 <SdSpiCard::erase(unsigned long, unsigned long)+0x86>
    7670:	movs	r3, #40	; 0x28
    7672:	strb	r3, [r4, #15]
  DBG_END_TIME(DBG_ERASE_BUSY);
  spiStop();
  return true;

 fail:
  spiStop();
    7674:	mov	r0, r4
    7676:	bl	6ff2 <SdSpiCard::spiStop()>
  return false;
    767a:	movs	r5, #0
    767c:	b.n	7688 <SdSpiCard::erase(unsigned long, unsigned long)+0x8c>
    767e:	movs	r3, #38	; 0x26
    7680:	b.n	7672 <SdSpiCard::erase(unsigned long, unsigned long)+0x76>
  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    error(SD_CARD_ERROR_ERASE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_ERASE_BUSY);
  spiStop();
    7682:	mov	r0, r4
    7684:	bl	6ff2 <SdSpiCard::spiStop()>
  return true;

 fail:
  spiStop();
  return false;
}
    7688:	mov	r0, r5
    768a:	add	sp, #16
    768c:	pop	{r4, r5, r6, pc}

0000768e <SdSpiCard::writeStop()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    768e:	push	{r3, r4, r5, lr}
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7690:	mov.w	r1, #600	; 0x258
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    7694:	mov	r4, r0
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7696:	bl	718a <SdSpiCard::waitNotBusy(unsigned short)>
    769a:	mov	r5, r0
    769c:	cbz	r0, 76a8 <SdSpiCard::writeStop()+0x1a>
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_STOP);
  spiSend(STOP_TRAN_TOKEN);
    769e:	movs	r1, #253	; 0xfd
    76a0:	ldr	r0, [r4, #4]
    76a2:	bl	6fac <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    76a6:	b.n	76ac <SdSpiCard::writeStop()+0x1e>
    76a8:	movs	r3, #30
    76aa:	strb	r3, [r4, #15]
  spiStop();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
    76ac:	mov	r0, r4
    76ae:	bl	6ff2 <SdSpiCard::spiStop()>
  return false;
}
    76b2:	mov	r0, r5
    76b4:	pop	{r3, r4, r5, pc}

000076b6 <SdSpiCard::writeData(unsigned char, unsigned char const*)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one sector of data for write sector or write multiple sectors
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    76b6:	push	{r3, r4, r5, lr}
    76b8:	mov	r4, r0
#if USE_SD_CRC
  uint16_t crc = CRC_CCITT(src, 512);
#else  // USE_SD_CRC
  uint16_t crc = 0XFFFF;
#endif  // USE_SD_CRC
  spiSend(token);
    76ba:	ldr	r0, [r0, #4]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one sector of data for write sector or write multiple sectors
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    76bc:	mov	r5, r2
#if USE_SD_CRC
  uint16_t crc = CRC_CCITT(src, 512);
#else  // USE_SD_CRC
  uint16_t crc = 0XFFFF;
#endif  // USE_SD_CRC
  spiSend(token);
    76be:	bl	6fac <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    76c2:	ldr	r0, [r4, #4]
  }
  void spiSend(uint8_t data) {
    m_spiDriverPtr->send(data);
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
    76c4:	ldr	r3, [r0, #0]
    76c6:	mov.w	r2, #512	; 0x200
    76ca:	ldr	r3, [r3, #24]
    76cc:	mov	r1, r5
    76ce:	blx	r3
  spiSend(src, 512);
  spiSend(crc >> 8);
    76d0:	movs	r1, #255	; 0xff
    76d2:	ldr	r0, [r4, #4]
    76d4:	bl	6fac <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
  spiSend(crc & 0XFF);
    76d8:	movs	r1, #255	; 0xff
    76da:	ldr	r0, [r4, #4]
    76dc:	bl	6fac <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>

  m_status = spiReceive();
    76e0:	ldr	r0, [r4, #4]
    76e2:	bl	6fb2 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    76e6:	strb	r0, [r4, #17]
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    76e8:	and.w	r0, r0, #31
    76ec:	cmp	r0, #5
    76ee:	beq.n	76fe <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x48>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    76f0:	movs	r3, #32
    goto fail;
  }
  return true;

 fail:
  spiStop();
    76f2:	mov	r0, r4
    76f4:	strb	r3, [r4, #15]
    76f6:	bl	6ff2 <SdSpiCard::spiStop()>
  return false;
    76fa:	movs	r0, #0
    76fc:	pop	{r3, r4, r5, pc}
  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    error(SD_CARD_ERROR_WRITE_DATA);
    goto fail;
  }
  return true;
    76fe:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7700:	pop	{r3, r4, r5, pc}

00007702 <SdSpiCard::writeData(unsigned char const*)>:
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    7702:	push	{r3, r4, r5, lr}
    7704:	mov	r5, r1
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7706:	mov.w	r1, #600	; 0x258
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    770a:	mov	r4, r0
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    770c:	bl	718a <SdSpiCard::waitNotBusy(unsigned short)>
    7710:	cbnz	r0, 7718 <SdSpiCard::writeData(unsigned char const*)+0x16>
    7712:	movs	r3, #36	; 0x24
    7714:	strb	r3, [r4, #15]
    7716:	b.n	7724 <SdSpiCard::writeData(unsigned char const*)+0x22>
    error(SD_CARD_ERROR_WRITE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_BUSY);
  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) {
    7718:	mov	r2, r5
    771a:	movs	r1, #252	; 0xfc
    771c:	mov	r0, r4
    771e:	bl	76b6 <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    7722:	cbnz	r0, 772c <SdSpiCard::writeData(unsigned char const*)+0x2a>
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7724:	mov	r0, r4
    7726:	bl	6ff2 <SdSpiCard::spiStop()>
  return false;
    772a:	movs	r0, #0
}
    772c:	pop	{r3, r4, r5, pc}

0000772e <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    772e:	ldr	r3, [r0, #0]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    7730:	push	{r4, r5, r6, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7732:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    7734:	mov	r5, r1
    7736:	mov	r4, r0
    7738:	mov	r6, r2
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    773a:	blx	r3
    773c:	cmp	r0, #3
    sector <<= 9;
    773e:	it	ne
    7740:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD24, sector)) {
    7742:	mov	r2, r5
    7744:	movs	r1, #24
    7746:	mov	r0, r4
    7748:	bl	71b2 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    774c:	cbz	r0, 7754 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x26>
    774e:	movs	r3, #13
    7750:	strb	r3, [r4, #15]
    7752:	b.n	776a <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x3c>
    error(SD_CARD_ERROR_CMD24);
    goto fail;
  }
  if (!writeData(DATA_START_SECTOR, src)) {
    7754:	mov	r2, r6
    7756:	movs	r1, #254	; 0xfe
    7758:	mov	r0, r4
    775a:	bl	76b6 <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    775e:	mov	r5, r0
    7760:	cbz	r0, 776a <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x3c>
    error(SD_CARD_ERROR_CMD13);
    goto fail;
  }
#endif  // CHECK_FLASH_PROGRAMMING

  spiStop();
    7762:	mov	r0, r4
    7764:	bl	6ff2 <SdSpiCard::spiStop()>
  return true;
    7768:	b.n	7772 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x44>

 fail:
  spiStop();
    776a:	mov	r0, r4
    776c:	bl	6ff2 <SdSpiCard::spiStop()>
  return false;
    7770:	movs	r5, #0
}
    7772:	mov	r0, r5
    7774:	pop	{r4, r5, r6, pc}

00007776 <SdSpiCard::writeSector(unsigned long, unsigned char const*)>:
   *
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    7776:	push	{r4}
    if (m_sharedSpi) {
    7778:	ldrb	r4, [r0, #13]
    777a:	cbz	r4, 7784 <SdSpiCard::writeSector(unsigned long, unsigned char const*)+0xe>
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    }
  }
    777c:	ldr.w	r4, [sp], #4
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    7780:	b.w	772e <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>
    } else {
      return writeSectors(sector, src, 1);
    7784:	ldr	r3, [r0, #0]
    7786:	ldr	r4, [r3, #36]	; 0x24
    7788:	movs	r3, #1
    778a:	mov	ip, r4
    }
  }
    778c:	ldr.w	r4, [sp], #4
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    7790:	bx	ip
    7792:	Address 0x00007792 is out of bounds.


00007794 <sdIrs()>:
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
  SDHC_IRQSIGEN = 0;
    7794:	ldr	r2, [pc, #24]	; (77b0 <sdIrs()+0x1c>)
  m_irqstat = SDHC_IRQSTAT;
    7796:	ldr	r1, [pc, #28]	; (77b4 <sdIrs()+0x20>)
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
  SDHC_IRQSIGEN = 0;
    7798:	movs	r3, #0
    779a:	str	r3, [r2, #0]
  m_irqstat = SDHC_IRQSTAT;
    779c:	ldr.w	r0, [r2, #-8]
    77a0:	str	r0, [r1, #0]
  SDHC_IRQSTAT = m_irqstat;
    77a2:	ldr	r1, [r1, #0]
    77a4:	str.w	r1, [r2, #-8]
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN);
#endif
  m_dmaBusy = false;
    77a8:	ldr	r2, [pc, #12]	; (77b8 <sdIrs()+0x24>)
    77aa:	strb	r3, [r2, #0]
    77ac:	bx	lr
    77ae:	nop
    77b0:	.word	0x400b1038
    77b4:	.word	0x1fff8450
    77b8:	.word	0x1fff8465

000077bc <isBusyCommandComplete()>:
static bool isBusyCMD13() {
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
}
//------------------------------------------------------------------------------
static bool isBusyCommandComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_CC | SDHC_IRQSTAT_CMD_ERROR));
    77bc:	ldr	r3, [pc, #12]	; (77cc <isBusyCommandComplete()+0x10>)
    77be:	ldr	r0, [pc, #16]	; (77d0 <isBusyCommandComplete()+0x14>)
    77c0:	ldr	r3, [r3, #0]
    77c2:	ands	r0, r3
}
    77c4:	clz	r0, r0
    77c8:	lsrs	r0, r0, #5
    77ca:	bx	lr
    77cc:	.word	0x400b1030
    77d0:	.word	0x000f0001

000077d4 <isBusyCommandInhibit()>:
//------------------------------------------------------------------------------
static bool isBusyCommandInhibit() {
  return SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB;
    77d4:	ldr	r3, [pc, #8]	; (77e0 <isBusyCommandInhibit()+0xc>)
    77d6:	ldr	r0, [r3, #0]
}
    77d8:	and.w	r0, r0, #1
    77dc:	bx	lr
    77de:	nop
    77e0:	.word	0x400b1024

000077e4 <isBusyDat()>:
//------------------------------------------------------------------------------
static bool isBusyDat() {
  return SDHC_PRSSTAT & (1 << 24) ? false : true;
    77e4:	ldr	r3, [pc, #12]	; (77f4 <isBusyDat()+0x10>)
    77e6:	ldr	r0, [r3, #0]
    77e8:	eor.w	r0, r0, #16777216	; 0x1000000
}
    77ec:	ubfx	r0, r0, #24, #1
    77f0:	bx	lr
    77f2:	nop
    77f4:	.word	0x400b1024

000077f8 <isBusyDMA()>:
//------------------------------------------------------------------------------
static bool isBusyDMA() {
  return m_dmaBusy;
    77f8:	ldr	r3, [pc, #4]	; (7800 <isBusyDMA()+0x8>)
    77fa:	ldrb	r0, [r3, #0]
}
    77fc:	bx	lr
    77fe:	nop
    7800:	.word	0x1fff8465

00007804 <isBusyFifoRead()>:
//------------------------------------------------------------------------------
static bool isBusyFifoRead() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BREN);
    7804:	ldr	r3, [pc, #12]	; (7814 <isBusyFifoRead()+0x10>)
    7806:	ldr	r0, [r3, #0]
    7808:	eor.w	r0, r0, #2048	; 0x800
}
    780c:	ubfx	r0, r0, #11, #1
    7810:	bx	lr
    7812:	nop
    7814:	.word	0x400b1024

00007818 <isBusyFifoWrite()>:
//------------------------------------------------------------------------------
static bool isBusyFifoWrite() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN);
    7818:	ldr	r3, [pc, #12]	; (7828 <isBusyFifoWrite()+0x10>)
    781a:	ldr	r0, [r3, #0]
    781c:	eor.w	r0, r0, #1024	; 0x400
}
    7820:	ubfx	r0, r0, #10, #1
    7824:	bx	lr
    7826:	nop
    7828:	.word	0x400b1024

0000782c <isBusyTransferComplete()>:
//------------------------------------------------------------------------------
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
    782c:	ldr	r3, [pc, #12]	; (783c <isBusyTransferComplete()+0x10>)
    782e:	ldr	r0, [pc, #16]	; (7840 <isBusyTransferComplete()+0x14>)
    7830:	ldr	r3, [r3, #0]
    7832:	ands	r0, r3
}
    7834:	clz	r0, r0
    7838:	lsrs	r0, r0, #5
    783a:	bx	lr
    783c:	.word	0x400b1030
    7840:	.word	0x117f0002

00007844 <setSdclk(unsigned long)>:
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    7844:	mov.w	r3, #1000	; 0x3e8
  }
  d[15] = 0;
  return true;
}
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
    7848:	push	{r4, r5, lr}
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    784a:	ldr	r4, [pc, #128]	; (78cc <setSdclk(unsigned long)+0x88>)
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    784c:	muls	r0, r3
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
    784e:	movs	r2, #1
  uint32_t maxSdclk = 1000*kHzMax;
    7850:	movs	r3, #9
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    7852:	lsls	r1, r2, #4
    7854:	udiv	r1, r4, r1
    7858:	cmp	r0, r1
    785a:	bcc.n	7864 <setSdclk(unsigned long)+0x20>
    785c:	movs	r4, #1
    785e:	mov	r3, r2
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    7860:	ldr	r5, [pc, #104]	; (78cc <setSdclk(unsigned long)+0x88>)
    7862:	b.n	7878 <setSdclk(unsigned long)+0x34>
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    7864:	subs	r3, #1
    7866:	beq.n	785c <setSdclk(unsigned long)+0x18>
    sdclkfs <<= 1;
    7868:	lsls	r2, r2, #1
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    786a:	b.n	7852 <setSdclk(unsigned long)+0xe>
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    786c:	cmp	r4, #16
    786e:	add.w	r1, r3, r2
    7872:	beq.n	7880 <setSdclk(unsigned long)+0x3c>
    dvs++;
    7874:	adds	r4, #1
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    7876:	mov	r3, r1
    7878:	udiv	r1, r5, r3
    787c:	cmp	r0, r1
    787e:	bcc.n	786c <setSdclk(unsigned long)+0x28>
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    7880:	mov.w	r1, #1000	; 0x3e8
    7884:	muls	r3, r1
    7886:	ldr	r1, [pc, #68]	; (78cc <setSdclk(unsigned long)+0x88>)
    7888:	udiv	r3, r1, r3
    788c:	ldr	r1, [pc, #64]	; (78d0 <setSdclk(unsigned long)+0x8c>)
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    788e:	ldr	r0, [pc, #68]	; (78d4 <setSdclk(unsigned long)+0x90>)
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    7890:	str	r3, [r1, #0]
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    7892:	ldr	r3, [r0, #0]
    7894:	bic.w	r3, r3, #8
    7898:	str	r3, [r0, #0]
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)

  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
    789a:	ldr	r1, [r0, #0]
                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    789c:	bic.w	r3, r1, #1044480	; 0xff000
    78a0:	lsls	r2, r2, #7
    78a2:	bic.w	r3, r3, #4080	; 0xff0
    78a6:	orr.w	r3, r3, #917504	; 0xe0000
    78aa:	and.w	r2, r2, #65280	; 0xff00
    78ae:	orrs	r2, r3
    78b0:	subs	r3, r4, #1
    78b2:	orr.w	r3, r2, r3, lsl #4

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    78b6:	ldr	r2, [pc, #32]	; (78d8 <setSdclk(unsigned long)+0x94>)
  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    78b8:	str	r3, [r0, #0]

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    78ba:	ldr	r3, [r2, #0]
    78bc:	lsls	r3, r3, #28
    78be:	bpl.n	78ba <setSdclk(unsigned long)+0x76>
  }

#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Enable the SDHC clock.
  SDHC_SYSCTL |= SDHC_SYSCTL_SDCLKEN;
    78c0:	ldr	r3, [r0, #0]
    78c2:	orr.w	r3, r3, #8
    78c6:	str	r3, [r0, #0]
    78c8:	pop	{r4, r5, pc}
    78ca:	nop
    78cc:	.word	0x05b8d800
    78d0:	.word	0x1fff8468
    78d4:	.word	0x400b102c
    78d8:	.word	0x400b1024

000078dc <SdioCard::errorCode() const>:
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::errorCode() const {
  return m_errorCode;
}
    78dc:	ldr	r3, [pc, #4]	; (78e4 <SdioCard::errorCode() const+0x8>)
    78de:	ldrb	r0, [r3, #0]
    78e0:	bx	lr
    78e2:	nop
    78e4:	.word	0x1fff1358

000078e8 <SdioCard::errorData() const>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorData() const {
  return m_irqstat;
    78e8:	ldr	r3, [pc, #4]	; (78f0 <SdioCard::errorData() const+0x8>)
    78ea:	ldr	r0, [r3, #0]
}
    78ec:	bx	lr
    78ee:	nop
    78f0:	.word	0x1fff8450

000078f4 <SdioCard::readCID(CID*)>:
uint32_t SdioCard::kHzSdClk() {
  return m_sdClkKhz;
}
//------------------------------------------------------------------------------
bool SdioCard::readCID(cid_t* cid) {
  memcpy(cid, &m_cid, 16);
    78f4:	ldr	r3, [pc, #20]	; (790c <SdioCard::readCID(CID*)+0x18>)
    78f6:	add.w	r2, r3, #16
    78fa:	ldr.w	r0, [r3], #4
    78fe:	str.w	r0, [r1], #4
    7902:	cmp	r3, r2
    7904:	bne.n	78fa <SdioCard::readCID(CID*)+0x6>
  return true;
}
    7906:	movs	r0, #1
    7908:	bx	lr
    790a:	nop
    790c:	.word	0x1fff8429

00007910 <SdioCard::readCSD(csd_t*)>:
//------------------------------------------------------------------------------
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
    7910:	ldr	r3, [pc, #20]	; (7928 <SdioCard::readCSD(csd_t*)+0x18>)
    7912:	add.w	r2, r3, #16
    7916:	ldr.w	r0, [r3], #4
    791a:	str.w	r0, [r1], #4
    791e:	cmp	r3, r2
    7920:	bne.n	7916 <SdioCard::readCSD(csd_t*)+0x6>
  return true;
}
    7922:	movs	r0, #1
    7924:	bx	lr
    7926:	nop
    7928:	.word	0x1fff8455

0000792c <SdioCard::readOCR(unsigned long*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
    792c:	ldr	r3, [pc, #8]	; (7938 <SdioCard::readOCR(unsigned long*)+0xc>)
    792e:	ldr	r3, [r3, #0]
    7930:	str	r3, [r1, #0]
  return true;
}
    7932:	movs	r0, #1
    7934:	bx	lr
    7936:	nop
    7938:	.word	0x1fff8444

0000793c <SdioCard::~SdioCard()>:
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    793c:	bx	lr
    793e:	Address 0x0000793e is out of bounds.


00007940 <waitTimeout(bool (*)())>:
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
    7940:	push	{r3, r4, r5, r6, r7, lr}
    7942:	mov	r7, r0
  uint32_t m = micros();
    7944:	bl	8dac <micros>
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    7948:	ldr	r5, [pc, #20]	; (7960 <waitTimeout(bool (*)())+0x20>)
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
  uint32_t m = micros();
    794a:	mov	r6, r0
  while (fcn()) {
    794c:	blx	r7
    794e:	mov	r4, r0
    7950:	cbz	r0, 795c <waitTimeout(bool (*)())+0x1c>
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    7952:	bl	8dac <micros>
    7956:	subs	r0, r0, r6
    7958:	cmp	r0, r5
    795a:	bls.n	794c <waitTimeout(bool (*)())+0xc>
      return true;
    }
  }
  return false;  // Caller will set errorCode.
}
    795c:	mov	r0, r4
    795e:	pop	{r3, r4, r5, r6, r7, pc}
    7960:	.word	0x000f4240

00007964 <yieldTimeout(bool (*)())>:
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    7964:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  m_busyFcn = fcn;
    7968:	ldr	r4, [pc, #48]	; (799c <yieldTimeout(bool (*)())+0x38>)
  uint32_t m = micros();
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    796a:	ldr.w	r8, [pc, #52]	; 79a0 <yieldTimeout(bool (*)())+0x3c>
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
  m_busyFcn = fcn;
    796e:	str	r0, [r4, #0]
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    7970:	mov	r6, r0
  m_busyFcn = fcn;
  uint32_t m = micros();
    7972:	bl	8dac <micros>
    7976:	mov	r7, r0
  while (fcn()) {
    7978:	blx	r6
    797a:	mov	r5, r0
    797c:	cbz	r0, 7994 <yieldTimeout(bool (*)())+0x30>
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    797e:	bl	8dac <micros>
    7982:	subs	r0, r0, r7
    7984:	cmp	r0, r8
    7986:	bls.n	798e <yieldTimeout(bool (*)())+0x2a>
      m_busyFcn = 0;
    7988:	movs	r3, #0
    798a:	str	r3, [r4, #0]
      return true;
    798c:	b.n	7996 <yieldTimeout(bool (*)())+0x32>
  }
}
#elif defined(ARDUINO)
inline void SysCall::yield() {
  // Use the external Arduino yield() function.
  ::yield();
    798e:	bl	97ec <yield>
    7992:	b.n	7978 <yieldTimeout(bool (*)())+0x14>
    }
    SysCall::yield();
  }
  m_busyFcn = 0;
    7994:	str	r0, [r4, #0]
  return false;  // Caller will set errorCode.
}
    7996:	mov	r0, r5
    7998:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    799c:	.word	0x1fff843c
    79a0:	.word	0x000f4240

000079a4 <SdioCard::~SdioCard()>:
    79a4:	push	{r4, lr}
    79a6:	movs	r1, #12
    79a8:	mov	r4, r0
    79aa:	bl	9c1c <operator delete(void*, unsigned int)>
    79ae:	mov	r0, r4
    79b0:	pop	{r4, pc}
    79b2:	Address 0x000079b2 is out of bounds.


000079b4 <SdioCard::type() const>:
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
    79b4:	ldr	r3, [pc, #20]	; (79cc <SdioCard::type() const+0x18>)
    79b6:	ldrb	r3, [r3, #0]
    79b8:	cbz	r3, 79c8 <SdioCard::type() const+0x14>
    79ba:	ldr	r3, [pc, #20]	; (79d0 <SdioCard::type() const+0x1c>)
    79bc:	ldrb	r3, [r3, #0]
    79be:	cmp	r3, #0
    79c0:	ite	ne
    79c2:	movne	r0, #3
    79c4:	moveq	r0, #2
    79c6:	bx	lr
    79c8:	movs	r0, #1
}
    79ca:	bx	lr
    79cc:	.word	0x1fff8428
    79d0:	.word	0x1fff8440

000079d4 <cardCommand(unsigned long, unsigned long)>:
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    79d4:	push	{r3, r4, r5, lr}
    79d6:	mov	r4, r0
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    79d8:	ldr	r0, [pc, #56]	; (7a14 <cardCommand(unsigned long, unsigned long)+0x40>)
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    79da:	mov	r5, r1
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    79dc:	bl	7940 <waitTimeout(bool (*)())>
    79e0:	cbnz	r0, 7a0a <cardCommand(unsigned long, unsigned long)+0x36>
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    79e2:	ldr	r3, [pc, #52]	; (7a18 <cardCommand(unsigned long, unsigned long)+0x44>)
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
  if (waitTimeout(isBusyCommandComplete)) {
    79e4:	ldr	r0, [pc, #52]	; (7a1c <cardCommand(unsigned long, unsigned long)+0x48>)
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    79e6:	str	r5, [r3, #0]
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MASK;
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
    79e8:	str	r4, [r3, #4]
  if (waitTimeout(isBusyCommandComplete)) {
    79ea:	bl	7940 <waitTimeout(bool (*)())>
    79ee:	cbnz	r0, 7a0a <cardCommand(unsigned long, unsigned long)+0x36>
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
    79f0:	ldr	r2, [pc, #44]	; (7a20 <cardCommand(unsigned long, unsigned long)+0x4c>)
    79f2:	ldr	r3, [pc, #48]	; (7a24 <cardCommand(unsigned long, unsigned long)+0x50>)
    79f4:	ldr	r1, [r2, #0]
    79f6:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    79f8:	ldr	r1, [r3, #0]
    79fa:	str	r1, [r2, #0]

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    79fc:	ldr	r2, [r3, #0]
    79fe:	lsls	r2, r2, #31
    7a00:	bpl.n	7a0a <cardCommand(unsigned long, unsigned long)+0x36>
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
    7a02:	ldr	r3, [r3, #0]
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    7a04:	tst.w	r3, #983040	; 0xf0000
    7a08:	beq.n	7a0e <cardCommand(unsigned long, unsigned long)+0x3a>
    7a0a:	movs	r0, #0
    7a0c:	pop	{r3, r4, r5, pc}
    7a0e:	movs	r0, #1
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
    7a10:	pop	{r3, r4, r5, pc}
    7a12:	nop
    7a14:	.word	0x000077d5
    7a18:	.word	0x400b1008
    7a1c:	.word	0x000077bd
    7a20:	.word	0x400b1030
    7a24:	.word	0x1fff8450

00007a28 <statusCMD13()>:
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
  }
}
//------------------------------------------------------------------------------
static uint32_t statusCMD13() {
    7a28:	push	{r3, lr}
  return cardCommand(CMD13_XFERTYP, m_rca) ? SDHC_CMDRSP0 : 0;
    7a2a:	ldr	r3, [pc, #16]	; (7a3c <statusCMD13()+0x14>)
    7a2c:	ldr	r0, [pc, #16]	; (7a40 <statusCMD13()+0x18>)
    7a2e:	ldr	r1, [r3, #0]
    7a30:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    7a34:	cbz	r0, 7a3a <statusCMD13()+0x12>
    7a36:	ldr	r3, [pc, #12]	; (7a44 <statusCMD13()+0x1c>)
    7a38:	ldr	r0, [r3, #0]
}
    7a3a:	pop	{r3, pc}
    7a3c:	.word	0x1fff8448
    7a40:	.word	0x0d1a0000
    7a44:	.word	0x400b1010

00007a48 <isBusyCMD13()>:
//------------------------------------------------------------------------------
static bool isBusyCMD13() {
    7a48:	push	{r3, lr}
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
    7a4a:	bl	7a28 <statusCMD13()>
    7a4e:	eor.w	r0, r0, #256	; 0x100
}
    7a52:	ubfx	r0, r0, #8, #1
    7a56:	pop	{r3, pc}

00007a58 <SdioCard::status()>:
uint32_t SdioCard::sectorCount() {
  return sdCardCapacity(&m_csd);
}
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
    7a58:	b.w	7a28 <statusCMD13()>

00007a5c <readReg16(unsigned long, void*)>:
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    7a5c:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    7a5e:	ldr	r3, [pc, #80]	; (7ab0 <readReg16(unsigned long, void*)+0x54>)
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    7a60:	mov	r5, r1
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    7a62:	ldr	r1, [r3, #0]
    7a64:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    7a68:	cbz	r0, 7aaa <readReg16(unsigned long, void*)+0x4e>
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
    7a6a:	ldr	r3, [pc, #72]	; (7ab4 <readReg16(unsigned long, void*)+0x58>)
    7a6c:	ldr	r3, [r3, #0]
    7a6e:	str	r3, [sp, #0]
    7a70:	ldr	r3, [pc, #68]	; (7ab8 <readReg16(unsigned long, void*)+0x5c>)
    7a72:	ldr	r3, [r3, #0]
    7a74:	str	r3, [sp, #4]
    7a76:	ldr	r3, [pc, #68]	; (7abc <readReg16(unsigned long, void*)+0x60>)
    7a78:	ldr	r3, [r3, #0]
    7a7a:	str	r3, [sp, #8]
    7a7c:	ldr	r3, [pc, #64]	; (7ac0 <readReg16(unsigned long, void*)+0x64>)
    7a7e:	ldr	r3, [r3, #0]
    7a80:	str	r3, [sp, #12]
    7a82:	add.w	r6, r5, #15
  for (int i = 0; i < 15; i++) {
    7a86:	movs	r3, #0
    d[14 - i] = sr[i/4] >> 8*(i%4);
    7a88:	bic.w	r4, r3, #3
    7a8c:	add	r2, sp, #16
    7a8e:	add	r4, r2
    7a90:	and.w	r2, r3, #3
    7a94:	lsls	r1, r2, #3
    7a96:	ldr.w	r2, [r4, #-16]
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    7a9a:	adds	r3, #1
    d[14 - i] = sr[i/4] >> 8*(i%4);
    7a9c:	lsrs	r2, r1
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    7a9e:	cmp	r3, #15
    d[14 - i] = sr[i/4] >> 8*(i%4);
    7aa0:	strb.w	r2, [r6, #-1]!
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    7aa4:	bne.n	7a88 <readReg16(unsigned long, void*)+0x2c>
    d[14 - i] = sr[i/4] >> 8*(i%4);
  }
  d[15] = 0;
    7aa6:	movs	r3, #0
    7aa8:	strb	r3, [r5, #15]
  return true;
}
    7aaa:	add	sp, #16
    7aac:	pop	{r4, r5, r6, pc}
    7aae:	nop
    7ab0:	.word	0x1fff8448
    7ab4:	.word	0x400b1010
    7ab8:	.word	0x400b1014
    7abc:	.word	0x400b1018
    7ac0:	.word	0x400b101c

00007ac4 <waitDmaStatus() [clone .part.4]>:
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    return false;  // Caller will set errorCode.
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    7ac4:	ldr	r3, [pc, #20]	; (7adc <waitDmaStatus() [clone .part.4]+0x18>)
    7ac6:	ldr	r0, [r3, #0]
    7ac8:	ands.w	r0, r0, #2
    7acc:	beq.n	7ada <waitDmaStatus() [clone .part.4]+0x16>
    7ace:	ldr	r3, [r3, #0]
    7ad0:	ldr	r0, [pc, #12]	; (7ae0 <waitDmaStatus() [clone .part.4]+0x1c>)
    7ad2:	ands	r0, r3
    7ad4:	clz	r0, r0
    7ad8:	lsrs	r0, r0, #5
}
    7ada:	bx	lr
    7adc:	.word	0x1fff8450
    7ae0:	.word	0x117f0000

00007ae4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>:
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
}
//------------------------------------------------------------------------------
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
    7ae4:	push	{r3, r4, r5, r6, r7, lr}
    7ae6:	mov	r4, r3
  if ((3 & (uint32_t)buf) || n == 0) {
    7ae8:	lsls	r3, r2, #30
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
}
//------------------------------------------------------------------------------
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
    7aea:	mov	r7, r0
    7aec:	mov	r5, r1
    7aee:	mov	r6, r2
  if ((3 & (uint32_t)buf) || n == 0) {
    7af0:	bne.n	7af4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x10>
    7af2:	cbnz	r4, 7b00 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x1c>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7af4:	ldr	r3, [pc, #100]	; (7b5c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x78>)
    7af6:	movs	r2, #37	; 0x25
    7af8:	strb	r2, [r3, #0]
  m_errorLine = line;
    7afa:	mov.w	r2, #506	; 0x1fa
    7afe:	b.n	7b12 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x2e>
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    7b00:	ldr	r0, [pc, #92]	; (7b60 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x7c>)
    7b02:	bl	7964 <yieldTimeout(bool (*)())>
    7b06:	cbz	r0, 7b18 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x34>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7b08:	ldr	r3, [pc, #80]	; (7b5c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x78>)
    7b0a:	movs	r2, #10
    7b0c:	strb	r2, [r3, #0]
  m_errorLine = line;
    7b0e:	movw	r2, #509	; 0x1fd
    7b12:	ldr	r3, [pc, #80]	; (7b64 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x80>)
    7b14:	str	r2, [r3, #0]
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    7b16:	b.n	7b56 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    7b18:	ldr	r3, [pc, #76]	; (7b68 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x84>)
    7b1a:	movs	r2, #1
    7b1c:	strb	r2, [r3, #0]
  m_irqstat = 0;
    7b1e:	ldr	r3, [pc, #76]	; (7b6c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x88>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    7b20:	ldr	r2, [pc, #76]	; (7b70 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x8c>)
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    7b22:	str	r0, [r3, #0]
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    7b24:	lsls	r4, r4, #16
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    7b26:	ldr	r3, [pc, #76]	; (7b74 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x90>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    7b28:	orr.w	r4, r4, #512	; 0x200
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    7b2c:	str	r6, [r3, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    7b2e:	str	r4, [r3, #4]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    7b30:	str	r2, [r3, #56]	; 0x38
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    7b32:	ldr	r3, [pc, #68]	; (7b78 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x94>)
    7b34:	ldrb	r3, [r3, #0]
    7b36:	cbnz	r3, 7b3c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x58>
    7b38:	lsls	r1, r5, #9
    7b3a:	b.n	7b3e <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x5a>
    7b3c:	mov	r1, r5
    7b3e:	mov	r0, r7
    7b40:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    7b44:	cbz	r0, 7b56 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    7b46:	ldr	r0, [pc, #52]	; (7b7c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x98>)
    7b48:	bl	7964 <yieldTimeout(bool (*)())>
    7b4c:	cbnz	r0, 7b56 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    return false;
  }
  return waitDmaStatus();
}
    7b4e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    7b52:	b.w	7ac4 <waitDmaStatus() [clone .part.4]>
    7b56:	movs	r0, #0
    7b58:	pop	{r3, r4, r5, r6, r7, pc}
    7b5a:	nop
    7b5c:	.word	0x1fff1358
    7b60:	.word	0x00007a49
    7b64:	.word	0x1fff846c
    7b68:	.word	0x1fff8465
    7b6c:	.word	0x1fff8450
    7b70:	.word	0x117f0002
    7b74:	.word	0x400b1000
    7b78:	.word	0x1fff8440
    7b7c:	.word	0x000077f9

00007b80 <SdioCard::sectorCount()>:
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    7b80:	ldr	r2, [pc, #92]	; (7be0 <SdioCard::sectorCount()+0x60>)
    7b82:	ldrb	r3, [r2, #0]
    7b84:	ands.w	r3, r3, #192	; 0xc0
    7b88:	bne.n	7bbe <SdioCard::sectorCount()+0x3e>
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    7b8a:	ldrb	r0, [r2, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7b8c:	ldrb	r3, [r2, #7]
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    7b8e:	ldrb	r1, [r2, #10]
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7b90:	and.w	r0, r0, #3
    7b94:	lsls	r3, r3, #2
    7b96:	orr.w	r3, r3, r0, lsl #10
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    7b9a:	ldrb	r0, [r2, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7b9c:	orr.w	r0, r3, r0, lsr #6
    7ba0:	adds	r3, r0, #1
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    7ba2:	ldrb	r0, [r2, #9]
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    7ba4:	ldrb	r2, [r2, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7ba6:	and.w	r0, r0, #3
    7baa:	lsls	r0, r0, #1
    7bac:	orr.w	r0, r0, r1, lsr #7
    7bb0:	and.w	r2, r2, #15
    7bb4:	add	r0, r2
    7bb6:	subs	r0, #7
    7bb8:	lsl.w	r0, r3, r0
    7bbc:	bx	lr
  } else if (csd->v2.csd_ver == 1) {
    7bbe:	cmp	r3, #64	; 0x40
    7bc0:	bne.n	7bda <SdioCard::sectorCount()+0x5a>
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    7bc2:	ldrb	r0, [r2, #9]
    7bc4:	adds	r3, r0, #1
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    7bc6:	ldrb	r0, [r2, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    7bc8:	and.w	r0, r0, #63	; 0x3f
    7bcc:	add.w	r0, r3, r0, lsl #16
    7bd0:	ldrb	r3, [r2, #8]
    7bd2:	add.w	r0, r0, r3, lsl #8
    7bd6:	lsls	r0, r0, #10
    7bd8:	bx	lr
  } else {
    return 0;
    7bda:	movs	r0, #0
  return transferStop();
}
//------------------------------------------------------------------------------
uint32_t SdioCard::sectorCount() {
  return sdCardCapacity(&m_csd);
}
    7bdc:	bx	lr
    7bde:	nop
    7be0:	.word	0x1fff8455

00007be4 <SdioCard::erase(unsigned long, unsigned long)>:
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7be4:	push	{r4, r5, r6, lr}
    7be6:	mov	r6, r2
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    7be8:	ldrb	r2, [r0, #9]
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7bea:	mov	r5, r1
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    7bec:	cbz	r2, 7bfa <SdioCard::erase(unsigned long, unsigned long)+0x16>
    7bee:	ldr	r3, [r0, #0]
    7bf0:	ldr	r3, [r3, #28]
    7bf2:	blx	r3
    7bf4:	mov	r4, r0
    7bf6:	cmp	r0, #0
    7bf8:	beq.n	7c96 <SdioCard::erase(unsigned long, unsigned long)+0xb2>
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  // check for single sector erase
  if (!m_csd.v1.erase_blk_en) {
    7bfa:	ldr	r1, [pc, #160]	; (7c9c <SdioCard::erase(unsigned long, unsigned long)+0xb8>)
    7bfc:	ldrb	r3, [r1, #10]
    7bfe:	and.w	r2, r3, #64	; 0x40
    7c02:	and.w	r4, r2, #255	; 0xff
    7c06:	cbnz	r2, 7c28 <SdioCard::erase(unsigned long, unsigned long)+0x44>
    // erase size mask
    uint8_t m = (m_csd.v1.sector_size_high << 1) | m_csd.v1.sector_size_low;
    7c08:	ldrb	r2, [r1, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    7c0a:	and.w	r3, r3, #63	; 0x3f
    7c0e:	lsls	r3, r3, #1
    7c10:	orr.w	r3, r3, r2, lsr #7
    7c14:	adds	r2, r6, #1
    7c16:	orrs	r2, r5
    7c18:	tst	r3, r2
    7c1a:	beq.n	7c28 <SdioCard::erase(unsigned long, unsigned long)+0x44>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7c1c:	ldr	r3, [pc, #128]	; (7ca0 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    7c1e:	movs	r2, #39	; 0x27
    7c20:	strb	r2, [r3, #0]
  m_errorLine = line;
    7c22:	movw	r2, #747	; 0x2eb
    7c26:	b.n	7c78 <SdioCard::erase(unsigned long, unsigned long)+0x94>
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
      // error card can't erase specified area
      return sdError(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
    }
  }
  if (!m_highCapacity) {
    7c28:	ldr	r3, [pc, #120]	; (7ca4 <SdioCard::erase(unsigned long, unsigned long)+0xc0>)
    7c2a:	ldrb	r3, [r3, #0]
    7c2c:	cbnz	r3, 7c32 <SdioCard::erase(unsigned long, unsigned long)+0x4e>
    firstSector <<= 9;
    7c2e:	lsls	r5, r5, #9
    lastSector <<= 9;
    7c30:	lsls	r6, r6, #9
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    7c32:	mov	r1, r5
    7c34:	ldr	r0, [pc, #112]	; (7ca8 <SdioCard::erase(unsigned long, unsigned long)+0xc4>)
    7c36:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    7c3a:	mov	r4, r0
    7c3c:	cbnz	r0, 7c4a <SdioCard::erase(unsigned long, unsigned long)+0x66>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7c3e:	ldr	r3, [pc, #96]	; (7ca0 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    7c40:	movs	r2, #15
    7c42:	strb	r2, [r3, #0]
  m_errorLine = line;
    7c44:	movw	r2, #755	; 0x2f3
    7c48:	b.n	7c78 <SdioCard::erase(unsigned long, unsigned long)+0x94>
    lastSector <<= 9;
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
    7c4a:	mov	r1, r6
    7c4c:	ldr	r0, [pc, #92]	; (7cac <SdioCard::erase(unsigned long, unsigned long)+0xc8>)
    7c4e:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    7c52:	mov	r4, r0
    7c54:	cbnz	r0, 7c62 <SdioCard::erase(unsigned long, unsigned long)+0x7e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7c56:	ldr	r3, [pc, #72]	; (7ca0 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    7c58:	movs	r2, #16
    7c5a:	strb	r2, [r3, #0]
  m_errorLine = line;
    7c5c:	movw	r2, #758	; 0x2f6
    7c60:	b.n	7c78 <SdioCard::erase(unsigned long, unsigned long)+0x94>
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    7c62:	movs	r1, #0
    7c64:	ldr	r0, [pc, #72]	; (7cb0 <SdioCard::erase(unsigned long, unsigned long)+0xcc>)
    7c66:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    7c6a:	mov	r4, r0
    7c6c:	cbnz	r0, 7c7e <SdioCard::erase(unsigned long, unsigned long)+0x9a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7c6e:	ldr	r3, [pc, #48]	; (7ca0 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    7c70:	movs	r2, #17
    7c72:	strb	r2, [r3, #0]
  m_errorLine = line;
    7c74:	movw	r2, #761	; 0x2f9
    7c78:	ldr	r3, [pc, #56]	; (7cb4 <SdioCard::erase(unsigned long, unsigned long)+0xd0>)
    7c7a:	str	r2, [r3, #0]
    7c7c:	b.n	7c96 <SdioCard::erase(unsigned long, unsigned long)+0xb2>
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    7c7e:	ldr	r0, [pc, #56]	; (7cb8 <SdioCard::erase(unsigned long, unsigned long)+0xd4>)
    7c80:	bl	7940 <waitTimeout(bool (*)())>
    7c84:	cbz	r0, 7c96 <SdioCard::erase(unsigned long, unsigned long)+0xb2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7c86:	ldr	r3, [pc, #24]	; (7ca0 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    7c88:	movs	r2, #40	; 0x28
    7c8a:	strb	r2, [r3, #0]
  m_errorLine = line;
    7c8c:	ldr	r3, [pc, #36]	; (7cb4 <SdioCard::erase(unsigned long, unsigned long)+0xd0>)
    7c8e:	mov.w	r2, #764	; 0x2fc
    7c92:	str	r2, [r3, #0]
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
    7c94:	movs	r4, #0
  }
  return true;
}
    7c96:	mov	r0, r4
    7c98:	pop	{r4, r5, r6, pc}
    7c9a:	nop
    7c9c:	.word	0x1fff8455
    7ca0:	.word	0x1fff1358
    7ca4:	.word	0x1fff8440
    7ca8:	.word	0x201a0000
    7cac:	.word	0x211a0000
    7cb0:	.word	0x261b0000
    7cb4:	.word	0x1fff846c
    7cb8:	.word	0x00007a49

00007cbc <waitTransferComplete()>:
  }
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
    7cbc:	push	{r4, lr}
  if (!m_transferActive) {
    7cbe:	ldr	r4, [pc, #60]	; (7cfc <waitTransferComplete()+0x40>)
    7cc0:	ldrb	r3, [r4, #0]
    7cc2:	cbnz	r3, 7cc8 <waitTransferComplete()+0xc>
    return true;
    7cc4:	movs	r0, #1
    7cc6:	pop	{r4, pc}
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
    7cc8:	ldr	r0, [pc, #52]	; (7d00 <waitTransferComplete()+0x44>)
    7cca:	bl	7940 <waitTimeout(bool (*)())>
  m_transferActive = false;
    7cce:	movs	r3, #0
  m_irqstat = SDHC_IRQSTAT;
    7cd0:	ldr	r2, [pc, #48]	; (7d04 <waitTransferComplete()+0x48>)
static bool waitTransferComplete() {
  if (!m_transferActive) {
    return true;
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
    7cd2:	strb	r3, [r4, #0]
  m_irqstat = SDHC_IRQSTAT;
    7cd4:	ldr	r3, [pc, #48]	; (7d08 <waitTransferComplete()+0x4c>)
    7cd6:	ldr	r1, [r2, #0]
    7cd8:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    7cda:	ldr	r1, [r3, #0]
    7cdc:	str	r1, [r2, #0]
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    7cde:	cbnz	r0, 7cea <waitTransferComplete()+0x2e>
    7ce0:	ldr	r2, [r3, #0]
    7ce2:	ldr	r3, [pc, #40]	; (7d0c <waitTransferComplete()+0x50>)
    7ce4:	ands	r3, r2
    7ce6:	cmp	r3, #0
    7ce8:	beq.n	7cc4 <waitTransferComplete()+0x8>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7cea:	ldr	r3, [pc, #36]	; (7d10 <waitTransferComplete()+0x54>)
    7cec:	movs	r2, #31
    7cee:	strb	r2, [r3, #0]
  m_errorLine = line;
    7cf0:	ldr	r3, [pc, #32]	; (7d14 <waitTransferComplete()+0x58>)
    7cf2:	movw	r2, #641	; 0x281
    7cf6:	str	r2, [r3, #0]
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    return sdError(SD_CARD_ERROR_TRANSFER_COMPLETE);
    7cf8:	movs	r0, #0
  }
  return true;
}
    7cfa:	pop	{r4, pc}
    7cfc:	.word	0x1fff844c
    7d00:	.word	0x0000782d
    7d04:	.word	0x400b1030
    7d08:	.word	0x1fff8450
    7d0c:	.word	0x117f0000
    7d10:	.word	0x1fff1358
    7d14:	.word	0x1fff846c

00007d18 <SdioCard::readStop()>:
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
    7d18:	push	{r4, r5, r6, lr}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    7d1a:	ldr	r4, [pc, #100]	; (7d80 <SdioCard::readStop()+0x68>)
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    7d1c:	ldr	r0, [pc, #100]	; (7d84 <SdioCard::readStop()+0x6c>)
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    7d1e:	ldr	r3, [r4, #0]
    7d20:	bic.w	r3, r3, #65536	; 0x10000
    7d24:	str	r3, [r4, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    7d26:	movs	r1, #0
    7d28:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    7d2c:	mov	r5, r0
    7d2e:	cbnz	r0, 7d40 <SdioCard::readStop()+0x28>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7d30:	ldr	r3, [pc, #84]	; (7d88 <SdioCard::readStop()+0x70>)
    7d32:	movs	r2, #9
    7d34:	strb	r2, [r3, #0]
  m_errorLine = line;
    7d36:	ldr	r3, [pc, #84]	; (7d8c <SdioCard::readStop()+0x74>)
    7d38:	movw	r2, #578	; 0x242
    7d3c:	str	r2, [r3, #0]
    7d3e:	b.n	7d7a <SdioCard::readStop()+0x62>
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    7d40:	ldr	r0, [pc, #76]	; (7d90 <SdioCard::readStop()+0x78>)
    7d42:	bl	7964 <yieldTimeout(bool (*)())>
    7d46:	cbz	r0, 7d5a <SdioCard::readStop()+0x42>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7d48:	ldr	r3, [pc, #60]	; (7d88 <SdioCard::readStop()+0x70>)
    7d4a:	movs	r2, #10
    7d4c:	strb	r2, [r3, #0]
  m_errorLine = line;
    7d4e:	ldr	r3, [pc, #60]	; (7d8c <SdioCard::readStop()+0x74>)
    7d50:	movw	r2, #582	; 0x246
    7d54:	str	r2, [r3, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    return sdError(SD_CARD_ERROR_CMD13);
    7d56:	movs	r5, #0
    7d58:	b.n	7d7a <SdioCard::readStop()+0x62>
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    7d5a:	ldr	r3, [pc, #56]	; (7d94 <SdioCard::readStop()+0x7c>)
    7d5c:	ldr	r3, [r3, #0]
    7d5e:	lsls	r3, r3, #30
    7d60:	bpl.n	7d7a <SdioCard::readStop()+0x62>
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    7d62:	ldr	r1, [pc, #52]	; (7d98 <SdioCard::readStop()+0x80>)
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    7d64:	ldr	r0, [pc, #52]	; (7d9c <SdioCard::readStop()+0x84>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    7d66:	ldr	r6, [r1, #0]
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    7d68:	ldr	r3, [r4, #0]
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    7d6a:	ldr	r2, [r0, #0]
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    7d6c:	bic.w	r3, r3, #65536	; 0x10000
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    7d70:	orr.w	r2, r2, #67108864	; 0x4000000
    7d74:	str	r2, [r0, #0]
    // Restore registers.
    SDHC_IRQSTATEN = irqsststen;
    7d76:	str	r6, [r1, #0]
    SDHC_PROCTL = proctl;
    7d78:	str	r3, [r4, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
}
    7d7a:	mov	r0, r5
    7d7c:	pop	{r4, r5, r6, pc}
    7d7e:	nop
    7d80:	.word	0x400b1028
    7d84:	.word	0x0cdb0000
    7d88:	.word	0x1fff1358
    7d8c:	.word	0x1fff846c
    7d90:	.word	0x000077e5
    7d94:	.word	0x400b1024
    7d98:	.word	0x400b1034
    7d9c:	.word	0x400b102c

00007da0 <SdioCard::writeData(unsigned char const*)>:
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
}
//------------------------------------------------------------------------------
bool SdioCard::writeData(const uint8_t* src) {
    7da0:	push	{r4, r5, r6, lr}
    7da2:	mov	r4, r1
  DBG_IRQSTAT();
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    7da4:	bl	7cbc <waitTransferComplete()>
    7da8:	mov	r6, r0
    7daa:	cmp	r0, #0
    7dac:	beq.n	7e14 <SdioCard::writeData(unsigned char const*)+0x74>
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    7dae:	ldr	r5, [pc, #104]	; (7e18 <SdioCard::writeData(unsigned char const*)+0x78>)
    7db0:	ldr	r3, [r5, #0]
    7db2:	tst.w	r3, #256	; 0x100
    7db6:	ldr	r3, [pc, #100]	; (7e1c <SdioCard::writeData(unsigned char const*)+0x7c>)
    7db8:	bne.n	7dca <SdioCard::writeData(unsigned char const*)+0x2a>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    7dba:	ldr	r2, [r3, #0]
    7dbc:	bic.w	r2, r2, #65536	; 0x10000
    7dc0:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    7dc2:	ldr	r2, [r3, #0]
    7dc4:	orr.w	r2, r2, #131072	; 0x20000
    7dc8:	str	r2, [r3, #0]
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    7dca:	ldr	r2, [r3, #0]
  if (waitTimeout(isBusyFifoWrite)) {
    7dcc:	ldr	r0, [pc, #80]	; (7e20 <SdioCard::writeData(unsigned char const*)+0x80>)
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    7dce:	orr.w	r2, r2, #65536	; 0x10000
    7dd2:	str	r2, [r3, #0]
  if (waitTimeout(isBusyFifoWrite)) {
    7dd4:	bl	7940 <waitTimeout(bool (*)())>
    7dd8:	cbnz	r0, 7e04 <SdioCard::writeData(unsigned char const*)+0x64>
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    7dda:	ldr	r1, [pc, #72]	; (7e24 <SdioCard::writeData(unsigned char const*)+0x84>)
    7ddc:	subs	r3, r4, #4
    7dde:	add.w	r4, r4, #508	; 0x1fc
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    7de2:	ldr	r2, [r5, #0]
    7de4:	lsls	r2, r2, #21
    7de6:	bpl.n	7de2 <SdioCard::writeData(unsigned char const*)+0x42>
    7de8:	add.w	r2, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    7dec:	ldr.w	r0, [r3, #4]!
    7df0:	str	r0, [r1, #0]
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    7df2:	cmp	r2, r3
    7df4:	bne.n	7dec <SdioCard::writeData(unsigned char const*)+0x4c>
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    7df6:	cmp	r4, r2
    7df8:	mov	r3, r2
    7dfa:	bne.n	7de2 <SdioCard::writeData(unsigned char const*)+0x42>
      SDHC_DATPORT = p32[i];
    }
    p32 += FIFO_WML;
  }
#if ENABLE_TEENSY_SDIO_MOD
  m_transferActive = true;
    7dfc:	ldr	r3, [pc, #40]	; (7e28 <SdioCard::writeData(unsigned char const*)+0x88>)
    7dfe:	movs	r2, #1
    7e00:	strb	r2, [r3, #0]
    7e02:	b.n	7e14 <SdioCard::writeData(unsigned char const*)+0x74>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7e04:	ldr	r3, [pc, #36]	; (7e2c <SdioCard::writeData(unsigned char const*)+0x8c>)
    7e06:	movs	r2, #33	; 0x21
    7e08:	strb	r2, [r3, #0]
  m_errorLine = line;
    7e0a:	ldr	r3, [pc, #36]	; (7e30 <SdioCard::writeData(unsigned char const*)+0x90>)
    7e0c:	movw	r2, #1015	; 0x3f7
    7e10:	str	r2, [r3, #0]
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
    7e12:	movs	r6, #0
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    7e14:	mov	r0, r6
    7e16:	pop	{r4, r5, r6, pc}
    7e18:	.word	0x400b1024
    7e1c:	.word	0x400b1028
    7e20:	.word	0x00007819
    7e24:	.word	0x400b1020
    7e28:	.word	0x1fff844c
    7e2c:	.word	0x1fff1358
    7e30:	.word	0x1fff846c

00007e34 <SdioCard::writeStart(unsigned long)>:
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    7e34:	push	{r4, lr}
  if (yieldTimeout(isBusyCMD13)) {
    7e36:	ldr	r0, [pc, #80]	; (7e88 <SdioCard::writeStart(unsigned long)+0x54>)
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    7e38:	mov	r4, r1
  if (yieldTimeout(isBusyCMD13)) {
    7e3a:	bl	7964 <yieldTimeout(bool (*)())>
    7e3e:	cbz	r0, 7e52 <SdioCard::writeStart(unsigned long)+0x1e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7e40:	ldr	r3, [pc, #72]	; (7e8c <SdioCard::writeStart(unsigned long)+0x58>)
    7e42:	movs	r2, #10
    7e44:	strb	r2, [r3, #0]
  m_errorLine = line;
    7e46:	ldr	r3, [pc, #72]	; (7e90 <SdioCard::writeStart(unsigned long)+0x5c>)
    7e48:	movw	r2, #1119	; 0x45f
    7e4c:	str	r2, [r3, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    7e4e:	movs	r0, #0
    7e50:	pop	{r4, pc}
  }
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    7e52:	ldr	r2, [pc, #64]	; (7e94 <SdioCard::writeStart(unsigned long)+0x60>)
    7e54:	ldr	r3, [r2, #0]
    7e56:	bic.w	r3, r3, #65536	; 0x10000
    7e5a:	str	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    7e5c:	ldr	r3, [pc, #56]	; (7e98 <SdioCard::writeStart(unsigned long)+0x64>)
    7e5e:	ldr	r2, [pc, #60]	; (7e9c <SdioCard::writeStart(unsigned long)+0x68>)
    7e60:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    7e62:	ldr	r3, [pc, #60]	; (7ea0 <SdioCard::writeStart(unsigned long)+0x6c>)
    7e64:	ldrb	r3, [r3, #0]
    7e66:	cbnz	r3, 7e6c <SdioCard::writeStart(unsigned long)+0x38>
    7e68:	lsls	r1, r4, #9
    7e6a:	b.n	7e6e <SdioCard::writeStart(unsigned long)+0x3a>
    7e6c:	mov	r1, r4
    7e6e:	ldr	r0, [pc, #52]	; (7ea4 <SdioCard::writeStart(unsigned long)+0x70>)
    7e70:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    7e74:	cbnz	r0, 7e84 <SdioCard::writeStart(unsigned long)+0x50>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7e76:	ldr	r3, [pc, #20]	; (7e8c <SdioCard::writeStart(unsigned long)+0x58>)
    7e78:	movs	r2, #14
    7e7a:	strb	r2, [r3, #0]
  m_errorLine = line;
    7e7c:	ldr	r3, [pc, #16]	; (7e90 <SdioCard::writeStart(unsigned long)+0x5c>)
    7e7e:	movw	r2, #1131	; 0x46b
    7e82:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
    7e84:	pop	{r4, pc}
    7e86:	nop
    7e88:	.word	0x00007a49
    7e8c:	.word	0x1fff1358
    7e90:	.word	0x1fff846c
    7e94:	.word	0x400b1028
    7e98:	.word	0x400b1004
    7e9c:	.word	0xffff0200
    7ea0:	.word	0x1fff8440
    7ea4:	.word	0x193a0022

00007ea8 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    7ea8:	push	{r3, r4, r5, r6, r7, lr}
    7eaa:	mov	r7, r0
    7eac:	mov	r4, r1
  if (m_sdioConfig.useDma()) {
    7eae:	ldrb	r6, [r7, #8]
    7eb0:	lsls	r6, r6, #31
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    7eb2:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    7eb4:	bpl.n	7ef2 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x4a>
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
    7eb6:	lsls	r6, r2, #30
    7eb8:	beq.n	7eda <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x32>
    7eba:	adds	r6, r1, r3
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    7ebc:	cmp	r4, r6
    7ebe:	beq.n	7f10 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
        if (!writeSector(sector, ptr)) {
    7ec0:	ldr	r3, [r7, #0]
    7ec2:	mov	r2, r5
    7ec4:	ldr	r3, [r3, #32]
    7ec6:	mov	r1, r4
    7ec8:	mov	r0, r7
    7eca:	blx	r3
    7ecc:	cbnz	r0, 7ed2 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2a>
          return false;  // writeSector will set errorCode.
    7ece:	movs	r0, #0
    7ed0:	pop	{r3, r4, r5, r6, r7, pc}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    7ed2:	adds	r4, #1
    7ed4:	add.w	r5, r5, #512	; 0x200
    7ed8:	b.n	7ebc <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x14>
          return false;  // writeSector will set errorCode.
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
    7eda:	ldr	r0, [pc, #56]	; (7f14 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x6c>)
    7edc:	bl	7ae4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    7ee0:	cbnz	r0, 7f10 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7ee2:	ldr	r3, [pc, #52]	; (7f18 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x70>)
    7ee4:	movs	r2, #14
    7ee6:	strb	r2, [r3, #0]
  m_errorLine = line;
    7ee8:	ldr	r3, [pc, #48]	; (7f1c <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x74>)
    7eea:	movw	r2, #1105	; 0x451
    7eee:	str	r2, [r3, #0]
    7ef0:	pop	{r3, r4, r5, r6, r7, pc}
    7ef2:	adds	r6, r1, r3
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
      return sdError(SD_CARD_ERROR_CMD25);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    7ef4:	cmp	r4, r6
    7ef6:	beq.n	7f10 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
      if (!writeSector(sector + i, src + i*512UL)) {
    7ef8:	ldr	r3, [r7, #0]
    7efa:	mov	r2, r5
    7efc:	mov	r1, r4
    7efe:	ldr	r3, [r3, #32]
    7f00:	mov	r0, r7
    7f02:	blx	r3
    7f04:	adds	r4, #1
    7f06:	add.w	r5, r5, #512	; 0x200
    7f0a:	cmp	r0, #0
    7f0c:	bne.n	7ef4 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x4c>
    7f0e:	b.n	7ece <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x26>
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
        if (!writeSector(sector, ptr)) {
          return false;  // writeSector will set errorCode.
        }
      }
      return true;
    7f10:	movs	r0, #1
        return false;
      }
    }
  }
  return true;
}
    7f12:	pop	{r3, r4, r5, r6, r7, pc}
    7f14:	.word	0x193a0027
    7f18:	.word	0x1fff1358
    7f1c:	.word	0x1fff846c

00007f20 <SdioCard::writeSector(unsigned long, unsigned char const*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    7f20:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    7f22:	ldrb	r3, [r0, #8]
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    7f24:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    7f26:	lsls	r2, r3, #31
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    7f28:	sub.w	sp, sp, #512	; 0x200
    7f2c:	mov	r4, r0
    7f2e:	mov	r6, r1
  if (m_sdioConfig.useDma()) {
    7f30:	bpl.n	7f64 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x44>
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
    7f32:	lsls	r3, r5, #30
    7f34:	beq.n	7f44 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x24>
      ptr = aligned;
      memcpy(aligned, src, 512);
    7f36:	mov	r1, r5
    7f38:	mov.w	r2, #512	; 0x200
    7f3c:	mov	r0, sp
    7f3e:	bl	8734 <memcpy>
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
      ptr = aligned;
    7f42:	mov	r5, sp
      memcpy(aligned, src, 512);
    } else {
      ptr = const_cast<uint8_t*>(src);
    }
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
    7f44:	movs	r3, #1
    7f46:	mov	r2, r5
    7f48:	mov	r1, r6
    7f4a:	ldr	r0, [pc, #132]	; (7fd0 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb0>)
    7f4c:	bl	7ae4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    7f50:	cmp	r0, #0
    7f52:	bne.n	7fc8 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    7f54:	ldr	r3, [pc, #124]	; (7fd4 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb4>)
    7f56:	movs	r2, #13
    7f58:	strb	r2, [r3, #0]
  m_errorLine = line;
    7f5a:	ldr	r3, [pc, #124]	; (7fd8 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb8>)
    7f5c:	movw	r2, #1049	; 0x419
    7f60:	str	r2, [r3, #0]
    7f62:	b.n	7fc8 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD24);
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    7f64:	bl	7cbc <waitTransferComplete()>
    7f68:	cbnz	r0, 7f6e <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4e>
      return false;
    7f6a:	movs	r0, #0
    7f6c:	b.n	7fc8 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    7f6e:	ldr	r3, [pc, #108]	; (7fdc <SdioCard::writeSector(unsigned long, unsigned char const*)+0xbc>)
    7f70:	ldr	r3, [r3, #0]
    7f72:	lsrs	r3, r3, #16
    7f74:	lsls	r3, r3, #16
    7f76:	cbz	r3, 7f80 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x60>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    7f78:	ldrb	r3, [r4, #9]
    7f7a:	cmp	r3, #2
    7f7c:	bne.n	7f94 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x74>
    7f7e:	b.n	7f8e <SdioCard::writeSector(unsigned long, unsigned char const*)+0x6e>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    7f80:	ldr	r3, [r4, #0]
    7f82:	mov	r0, r4
    7f84:	ldr	r3, [r3, #28]
    7f86:	blx	r3
    7f88:	cmp	r0, #0
    7f8a:	bne.n	7f78 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x58>
    7f8c:	b.n	7f6a <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    7f8e:	ldr	r3, [r4, #4]
    7f90:	cmp	r6, r3
    7f92:	beq.n	7fb4 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x94>
      if (!syncDevice()) {
    7f94:	ldr	r3, [r4, #0]
    7f96:	mov	r0, r4
    7f98:	ldr	r3, [r3, #28]
    7f9a:	blx	r3
    7f9c:	cmp	r0, #0
    7f9e:	beq.n	7f6a <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
      if (!writeStart(sector )) {
    7fa0:	ldr	r3, [r4, #0]
    7fa2:	mov	r1, r6
    7fa4:	ldr	r3, [r3, #80]	; 0x50
    7fa6:	mov	r0, r4
    7fa8:	blx	r3
    7faa:	cmp	r0, #0
    7fac:	beq.n	7f6a <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
      m_curSector = sector;
      m_curState = WRITE_STATE;
    7fae:	movs	r3, #2
        return false;
      }
      if (!writeStart(sector )) {
        return false;
      }
      m_curSector = sector;
    7fb0:	str	r6, [r4, #4]
      m_curState = WRITE_STATE;
    7fb2:	strb	r3, [r4, #9]
    }
    if (!writeData(src)) {
    7fb4:	ldr	r3, [r4, #0]
    7fb6:	mov	r1, r5
    7fb8:	ldr	r3, [r3, #76]	; 0x4c
    7fba:	mov	r0, r4
    7fbc:	blx	r3
    7fbe:	cmp	r0, #0
    7fc0:	beq.n	7f6a <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
      return false;
    }
    m_curSector++;
    7fc2:	ldr	r3, [r4, #4]
    7fc4:	adds	r3, #1
    7fc6:	str	r3, [r4, #4]
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
    7fc8:	add.w	sp, sp, #512	; 0x200
    7fcc:	pop	{r4, r5, r6, pc}
    7fce:	nop
    7fd0:	.word	0x183a0001
    7fd4:	.word	0x1fff1358
    7fd8:	.word	0x1fff846c
    7fdc:	.word	0x400b1004

00007fe0 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    7fe0:	push	{r3, r4, r5, r6, r7, lr}
    7fe2:	mov	r7, r0
    7fe4:	mov	r4, r1
  if (m_sdioConfig.useDma()) {
    7fe6:	ldrb	r6, [r7, #8]
    7fe8:	lsls	r6, r6, #31
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    7fea:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    7fec:	bpl.n	802a <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4a>
    if ((uint32_t)dst & 3) {
    7fee:	lsls	r6, r2, #30
    7ff0:	beq.n	8012 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x32>
    7ff2:	adds	r6, r1, r3
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    7ff4:	cmp	r4, r6
    7ff6:	beq.n	8048 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
        if (!readSector(sector, dst)) {
    7ff8:	ldr	r3, [r7, #0]
    7ffa:	mov	r2, r5
    7ffc:	ldr	r3, [r3, #12]
    7ffe:	mov	r1, r4
    8000:	mov	r0, r7
    8002:	blx	r3
    8004:	cbnz	r0, 800a <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x2a>
          return false;  // readSector will set errorCode.
    8006:	movs	r0, #0
    8008:	pop	{r3, r4, r5, r6, r7, pc}
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
  if (m_sdioConfig.useDma()) {
    if ((uint32_t)dst & 3) {
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    800a:	adds	r4, #1
    800c:	add.w	r5, r5, #512	; 0x200
    8010:	b.n	7ff4 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x14>
          return false;  // readSector will set errorCode.
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
    8012:	ldr	r0, [pc, #56]	; (804c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x6c>)
    8014:	bl	7ae4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    8018:	cbnz	r0, 8048 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    801a:	ldr	r3, [pc, #52]	; (8050 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x70>)
    801c:	movs	r2, #12
    801e:	strb	r2, [r3, #0]
  m_errorLine = line;
    8020:	ldr	r3, [pc, #48]	; (8054 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x74>)
    8022:	mov.w	r2, #912	; 0x390
    8026:	str	r2, [r3, #0]
    8028:	pop	{r3, r4, r5, r6, r7, pc}
    802a:	adds	r6, r1, r3
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
      return sdError(SD_CARD_ERROR_CMD18);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    802c:	cmp	r4, r6
    802e:	beq.n	8048 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
      if (!readSector(sector + i, dst + i*512UL)) {
    8030:	ldr	r3, [r7, #0]
    8032:	mov	r2, r5
    8034:	mov	r1, r4
    8036:	ldr	r3, [r3, #12]
    8038:	mov	r0, r7
    803a:	blx	r3
    803c:	adds	r4, #1
    803e:	add.w	r5, r5, #512	; 0x200
    8042:	cmp	r0, #0
    8044:	bne.n	802c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4c>
    8046:	b.n	8006 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x26>
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
        if (!readSector(sector, dst)) {
          return false;  // readSector will set errorCode.
        }
      }
      return true;
    8048:	movs	r0, #1
        return false;
      }
    }
  }
  return true;
}
    804a:	pop	{r3, r4, r5, r6, r7, pc}
    804c:	.word	0x123a0037
    8050:	.word	0x1fff1358
    8054:	.word	0x1fff846c

00008058 <cardCMD6(unsigned long, unsigned char*)>:

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    8058:	push	{r3, r4, r5, lr}
    805a:	mov	r4, r0
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    805c:	ldr	r0, [pc, #104]	; (80c8 <cardCMD6(unsigned long, unsigned char*)+0x70>)

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    805e:	mov	r5, r1
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    8060:	bl	7940 <waitTimeout(bool (*)())>
    8064:	cbz	r0, 8072 <cardCMD6(unsigned long, unsigned char*)+0x1a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8066:	ldr	r3, [pc, #100]	; (80cc <cardCMD6(unsigned long, unsigned char*)+0x74>)
    8068:	movs	r2, #10
    806a:	strb	r2, [r3, #0]
  m_errorLine = line;
    806c:	movw	r2, #413	; 0x19d
    8070:	b.n	80b4 <cardCMD6(unsigned long, unsigned char*)+0x5c>
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    8072:	ldr	r3, [pc, #92]	; (80d0 <cardCMD6(unsigned long, unsigned char*)+0x78>)
    8074:	movs	r2, #1
    8076:	strb	r2, [r3, #0]
  m_irqstat = 0;
    8078:	ldr	r3, [pc, #88]	; (80d4 <cardCMD6(unsigned long, unsigned char*)+0x7c>)
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    807a:	ldr	r2, [pc, #92]	; (80d8 <cardCMD6(unsigned long, unsigned char*)+0x80>)
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    807c:	str	r0, [r3, #0]
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    807e:	ldr	r3, [pc, #92]	; (80dc <cardCMD6(unsigned long, unsigned char*)+0x84>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    8080:	ldr	r0, [pc, #92]	; (80e0 <cardCMD6(unsigned long, unsigned char*)+0x88>)
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    8082:	str	r5, [r3, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    8084:	str	r2, [r3, #4]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    8086:	ldr	r2, [pc, #92]	; (80e4 <cardCMD6(unsigned long, unsigned char*)+0x8c>)
    8088:	str	r2, [r3, #56]	; 0x38
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    808a:	mov	r1, r4
    808c:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    8090:	cbnz	r0, 80a2 <cardCMD6(unsigned long, unsigned char*)+0x4a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8092:	ldr	r3, [pc, #56]	; (80cc <cardCMD6(unsigned long, unsigned char*)+0x74>)
    8094:	movs	r2, #4
    8096:	strb	r2, [r3, #0]
  m_errorLine = line;
    8098:	ldr	r3, [pc, #76]	; (80e8 <cardCMD6(unsigned long, unsigned char*)+0x90>)
    809a:	mov.w	r2, #420	; 0x1a4
    809e:	str	r2, [r3, #0]
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
    80a0:	pop	{r3, r4, r5, pc}
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    80a2:	ldr	r0, [pc, #72]	; (80ec <cardCMD6(unsigned long, unsigned char*)+0x94>)
    80a4:	bl	7964 <yieldTimeout(bool (*)())>
    80a8:	cbz	r0, 80bc <cardCMD6(unsigned long, unsigned char*)+0x64>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    80aa:	ldr	r3, [pc, #32]	; (80cc <cardCMD6(unsigned long, unsigned char*)+0x74>)
    80ac:	movs	r2, #37	; 0x25
    80ae:	strb	r2, [r3, #0]
  m_errorLine = line;
    80b0:	movw	r2, #423	; 0x1a7
    80b4:	ldr	r3, [pc, #48]	; (80e8 <cardCMD6(unsigned long, unsigned char*)+0x90>)
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    return sdError(SD_CARD_ERROR_DMA);
    80b6:	movs	r0, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    80b8:	str	r2, [r3, #0]
    80ba:	pop	{r3, r4, r5, pc}
    80bc:	bl	7ac4 <waitDmaStatus() [clone .part.4]>
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    80c0:	cmp	r0, #0
    80c2:	beq.n	80aa <cardCMD6(unsigned long, unsigned char*)+0x52>
    return sdError(SD_CARD_ERROR_DMA);
  }
  return true;
}
    80c4:	pop	{r3, r4, r5, pc}
    80c6:	nop
    80c8:	.word	0x00007a49
    80cc:	.word	0x1fff1358
    80d0:	.word	0x1fff8465
    80d4:	.word	0x1fff8450
    80d8:	.word	0x00010040
    80dc:	.word	0x400b1000
    80e0:	.word	0x063a0011
    80e4:	.word	0x117f0002
    80e8:	.word	0x1fff846c
    80ec:	.word	0x000077f9

000080f0 <SdioCard::begin(SdioConfig)>:
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    80f0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    80f4:	ldr	r4, [pc, #712]	; (83c0 <SdioCard::begin(SdioConfig)+0x2d0>)
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    80f6:	ldr	r2, [pc, #716]	; (83c4 <SdioCard::begin(SdioConfig)+0x2d4>)
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
    80f8:	ldr.w	ip, [pc, #828]	; 8438 <SdioCard::begin(SdioConfig)+0x348>
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    80fc:	ldr.w	lr, [pc, #828]	; 843c <SdioCard::begin(SdioConfig)+0x34c>
  m_version2 = false;
    8100:	ldr.w	sl, [pc, #828]	; 8440 <SdioCard::begin(SdioConfig)+0x350>
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
    8104:	strb	r1, [r0, #8]
  m_curState = IDLE_STATE;
    8106:	movs	r3, #0
    8108:	strb	r3, [r0, #9]
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    810a:	strb	r3, [r4, #0]
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
    810c:	strb.w	r3, [ip]
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    8110:	strb.w	r3, [lr]
  m_version2 = false;
    8114:	strb.w	r3, [sl]
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    8118:	ldr	r3, [r2, #0]
  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    811a:	ldr	r0, [pc, #684]	; (83c8 <SdioCard::begin(SdioConfig)+0x2d8>)
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    811c:	ldr	r5, [pc, #684]	; (83cc <SdioCard::begin(SdioConfig)+0x2dc>)
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    811e:	ldr	r6, [pc, #688]	; (83d0 <SdioCard::begin(SdioConfig)+0x2e0>)
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8120:	ldr	r7, [pc, #688]	; (83d4 <SdioCard::begin(SdioConfig)+0x2e4>)
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8122:	ldr.w	r8, [pc, #800]	; 8444 <SdioCard::begin(SdioConfig)+0x354>
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    8126:	ldr	r1, [pc, #688]	; (83d8 <SdioCard::begin(SdioConfig)+0x2e8>)
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    8128:	orr.w	r3, r3, #201326592	; 0xc000000
    812c:	str	r3, [r2, #0]
#endif  // HAS_KINETIS_MPU
  // Enable SDHC clock.
  SIM_SCGC3 |= SIM_SCGC3_SDHC;
    812e:	add.w	r2, r2, #239616	; 0x3a800
    8132:	adds	r2, #48	; 0x30
    8134:	ldr	r3, [r2, #0]
    8136:	orr.w	r3, r3, #131072	; 0x20000
    813a:	str	r3, [r2, #0]
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    813c:	ldr	r2, [pc, #668]	; (83dc <SdioCard::begin(SdioConfig)+0x2ec>)
    813e:	movw	r3, #259	; 0x103
    8142:	str	r3, [r2, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8144:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8146:	str	r3, [r6, #0]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8148:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    814a:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    814e:	str	r3, [r0, #0]
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    8150:	ldr	r3, [r1, #0]
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    8152:	sub	sp, #84	; 0x54
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    8154:	orr.w	r3, r3, #16777216	; 0x1000000
    8158:	orr.w	r3, r3, #32768	; 0x8000
    815c:	str	r3, [r1, #0]
    815e:	mov	r9, r0
    8160:	str.w	ip, [sp, #4]
    8164:	str.w	lr, [sp, #8]
    8168:	mov	fp, r1

  while (SDHC_SYSCTL & SDHC_SYSCTL_RSTA) {
    816a:	ldr.w	r1, [fp]
    816e:	ldr	r3, [pc, #616]	; (83d8 <SdioCard::begin(SdioConfig)+0x2e8>)
    8170:	lsls	r1, r1, #7
    8172:	bmi.n	816a <SdioCard::begin(SdioConfig)+0x7a>
  }

  // Set initial SCK rate.
  setSdclk(SD_MAX_INIT_RATE_KHZ);
    8174:	mov.w	r0, #400	; 0x190
    8178:	str	r3, [sp, #0]
    817a:	str	r2, [sp, #12]
    817c:	bl	7844 <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8180:	ldr	r2, [sp, #12]
    8182:	movw	r1, #1091	; 0x443
    8186:	str	r1, [r2, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8188:	mov.w	r2, #1088	; 0x440
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    818c:	str	r1, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    818e:	str	r2, [r6, #0]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    8190:	ldr	r2, [pc, #588]	; (83e0 <SdioCard::begin(SdioConfig)+0x2f0>)
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8192:	str	r1, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8194:	str.w	r1, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8198:	str.w	r1, [r9]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    819c:	ldr	r1, [pc, #580]	; (83e4 <SdioCard::begin(SdioConfig)+0x2f4>)
    819e:	str	r1, [r2, #0]

  attachInterruptVector(IRQ_SDHC, sdIrs);
    81a0:	movs	r0, #81	; 0x51
    81a2:	ldr	r1, [pc, #580]	; (83e8 <SdioCard::begin(SdioConfig)+0x2f8>)
    81a4:	bl	8d08 <attachInterruptVector>
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    81a8:	ldr	r2, [pc, #576]	; (83ec <SdioCard::begin(SdioConfig)+0x2fc>)
    81aa:	movs	r1, #96	; 0x60
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    81ac:	mvn.w	r0, #840	; 0x348

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    81b0:	strb	r1, [r2, #0]
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    81b2:	add	r2, r0

  // Send 80 clocks to card.
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    81b4:	ldr	r3, [sp, #0]
  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    81b6:	mov.w	r1, #131072	; 0x20000
    81ba:	str	r1, [r2, #0]

  // Send 80 clocks to card.
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    81bc:	ldr	r2, [r3, #0]
    81be:	orr.w	r2, r2, #134217728	; 0x8000000
    81c2:	str	r2, [r3, #0]
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
    81c4:	ldr.w	r1, [fp]
    81c8:	ands.w	r1, r1, #134217728	; 0x8000000
    81cc:	bne.n	81c4 <SdioCard::begin(SdioConfig)+0xd4>
  m_highCapacity = false;
  m_version2 = false;

  // initialize controller.
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    81ce:	mov	r0, r1
    81d0:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    81d4:	mov	fp, r0
    81d6:	cbnz	r0, 81e2 <SdioCard::begin(SdioConfig)+0xf2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    81d8:	movs	r3, #1
    81da:	strb	r3, [r4, #0]
  m_errorLine = line;
    81dc:	movw	r2, #662	; 0x296
    81e0:	b.n	828a <SdioCard::begin(SdioConfig)+0x19a>
    81e2:	mov.w	fp, #3
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
    81e6:	mov.w	r1, #426	; 0x1aa
    81ea:	ldr	r0, [pc, #516]	; (83f0 <SdioCard::begin(SdioConfig)+0x300>)
    81ec:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    81f0:	cbz	r0, 820e <SdioCard::begin(SdioConfig)+0x11e>
      if (SDHC_CMDRSP0 != 0X1AA) {
    81f2:	ldr	r3, [pc, #512]	; (83f4 <SdioCard::begin(SdioConfig)+0x304>)
    81f4:	ldr	r3, [r3, #0]
    81f6:	cmp.w	r3, #426	; 0x1aa
    81fa:	beq.n	8206 <SdioCard::begin(SdioConfig)+0x116>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    81fc:	movs	r3, #6
    81fe:	strb	r3, [r4, #0]
  m_errorLine = line;
    8200:	mov.w	r2, #668	; 0x29c
    8204:	b.n	8326 <SdioCard::begin(SdioConfig)+0x236>
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
      if (SDHC_CMDRSP0 != 0X1AA) {
        return sdError(SD_CARD_ERROR_CMD8);
      }
      m_version2 = true;
    8206:	movs	r3, #1
    8208:	strb.w	r3, [sl]
      break;
    820c:	b.n	8214 <SdioCard::begin(SdioConfig)+0x124>
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    820e:	subs.w	fp, fp, #1
    8212:	bne.n	81e6 <SdioCard::begin(SdioConfig)+0xf6>
      }
      m_version2 = true;
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
    8214:	ldrb.w	r3, [sl]
    8218:	cmp	r3, #0
    821a:	ldr	r3, [pc, #476]	; (83f8 <SdioCard::begin(SdioConfig)+0x308>)
    821c:	ite	eq
    821e:	moveq.w	fp, #3145728	; 0x300000
    8222:	movne	fp, r3
  int m = micros();
    8224:	bl	8dac <micros>
    8228:	str	r0, [sp, #0]
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    822a:	movs	r1, #0
    822c:	ldr	r0, [pc, #460]	; (83fc <SdioCard::begin(SdioConfig)+0x30c>)
    822e:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    8232:	cmp	r0, #0
    8234:	beq.n	8314 <SdioCard::begin(SdioConfig)+0x224>
    8236:	mov	r1, fp
    8238:	ldr	r0, [pc, #452]	; (8400 <SdioCard::begin(SdioConfig)+0x310>)
    823a:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    823e:	cmp	r0, #0
    8240:	beq.n	8314 <SdioCard::begin(SdioConfig)+0x224>
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
    8242:	bl	8dac <micros>
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
    8246:	ldr	r3, [sp, #0]
    8248:	subs	r0, r0, r3
    824a:	ldr	r3, [pc, #440]	; (8404 <SdioCard::begin(SdioConfig)+0x314>)
    824c:	cmp	r0, r3
    824e:	bhi.n	8314 <SdioCard::begin(SdioConfig)+0x224>
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
    8250:	ldr	r3, [pc, #416]	; (83f4 <SdioCard::begin(SdioConfig)+0x304>)
    8252:	ldr.w	sl, [pc, #416]	; 83f4 <SdioCard::begin(SdioConfig)+0x304>
    8256:	ldr	r3, [r3, #0]
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    8258:	cmp	r3, #0
    825a:	bge.n	822a <SdioCard::begin(SdioConfig)+0x13a>
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
    825c:	ldr	r2, [pc, #424]	; (8408 <SdioCard::begin(SdioConfig)+0x318>)
    825e:	ldr.w	r1, [sl]
    8262:	str	r1, [r2, #0]
  if (SDHC_CMDRSP0 & 0x40000000) {
    8264:	ldr.w	r2, [sl]
    // Is high capacity.
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    8268:	ldr	r0, [pc, #416]	; (840c <SdioCard::begin(SdioConfig)+0x31c>)
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    826a:	lsls	r2, r2, #1
    // Is high capacity.
    m_highCapacity = true;
    826c:	itt	mi
    826e:	ldrmi	r3, [sp, #8]
    8270:	movmi	r2, #1
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    8272:	mov.w	r1, #0
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    // Is high capacity.
    m_highCapacity = true;
    8276:	it	mi
    8278:	strbmi	r2, [r3, #0]
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    827a:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    827e:	mov	fp, r0
    8280:	cbnz	r0, 8290 <SdioCard::begin(SdioConfig)+0x1a0>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8282:	movs	r3, #2
    8284:	strb	r3, [r4, #0]
  m_errorLine = line;
    8286:	mov.w	r2, #688	; 0x2b0
    828a:	ldr	r3, [pc, #388]	; (8410 <SdioCard::begin(SdioConfig)+0x320>)
    828c:	str	r2, [r3, #0]
  if (SDHC_CMDRSP0 & 0x40000000) {
    // Is high capacity.
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD2);
    828e:	b.n	83b6 <SdioCard::begin(SdioConfig)+0x2c6>
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    8290:	movs	r1, #0
    8292:	ldr	r0, [pc, #384]	; (8414 <SdioCard::begin(SdioConfig)+0x324>)
    8294:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    8298:	mov	fp, r0
    829a:	cbnz	r0, 82a6 <SdioCard::begin(SdioConfig)+0x1b6>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    829c:	movs	r3, #3
    829e:	strb	r3, [r4, #0]
  m_errorLine = line;
    82a0:	movw	r2, #691	; 0x2b3
    82a4:	b.n	828a <SdioCard::begin(SdioConfig)+0x19a>
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    82a6:	ldr.w	r3, [sl]
    82aa:	ldr.w	sl, [pc, #412]	; 8448 <SdioCard::begin(SdioConfig)+0x358>

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    82ae:	ldr	r1, [pc, #360]	; (8418 <SdioCard::begin(SdioConfig)+0x328>)
    82b0:	ldr	r0, [pc, #360]	; (841c <SdioCard::begin(SdioConfig)+0x32c>)
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    82b2:	lsrs	r3, r3, #16
    82b4:	lsls	r3, r3, #16
    82b6:	str.w	r3, [sl]

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    82ba:	bl	7a5c <readReg16(unsigned long, void*)>
    82be:	mov	fp, r0
    82c0:	cbnz	r0, 82cc <SdioCard::begin(SdioConfig)+0x1dc>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    82c2:	movs	r3, #7
    82c4:	strb	r3, [r4, #0]
  m_errorLine = line;
    82c6:	mov.w	r2, #696	; 0x2b8
    82ca:	b.n	828a <SdioCard::begin(SdioConfig)+0x19a>
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    return sdError(SD_CARD_ERROR_CMD9);
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    82cc:	ldr	r1, [pc, #336]	; (8420 <SdioCard::begin(SdioConfig)+0x330>)
    82ce:	ldr	r0, [pc, #340]	; (8424 <SdioCard::begin(SdioConfig)+0x334>)
    82d0:	bl	7a5c <readReg16(unsigned long, void*)>
    82d4:	mov	fp, r0
    82d6:	cbnz	r0, 82e2 <SdioCard::begin(SdioConfig)+0x1f2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    82d8:	movs	r3, #8
    82da:	strb	r3, [r4, #0]
  m_errorLine = line;
    82dc:	movw	r2, #699	; 0x2bb
    82e0:	b.n	828a <SdioCard::begin(SdioConfig)+0x19a>
    return sdError(SD_CARD_ERROR_CMD9);
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    return sdError(SD_CARD_ERROR_CMD10);
  }
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    82e2:	ldr.w	r1, [sl]
    82e6:	ldr	r0, [pc, #320]	; (8428 <SdioCard::begin(SdioConfig)+0x338>)
    82e8:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    82ec:	mov	fp, r0
    82ee:	cbnz	r0, 82fa <SdioCard::begin(SdioConfig)+0x20a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    82f0:	movs	r3, #5
    82f2:	strb	r3, [r4, #0]
  m_errorLine = line;
    82f4:	movw	r2, #702	; 0x2be
    82f8:	b.n	828a <SdioCard::begin(SdioConfig)+0x19a>
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    82fa:	ldr.w	r1, [sl]
    82fe:	ldr	r0, [pc, #252]	; (83fc <SdioCard::begin(SdioConfig)+0x30c>)
    8300:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    8304:	cbz	r0, 831e <SdioCard::begin(SdioConfig)+0x22e>
    8306:	movs	r1, #2
    8308:	ldr	r0, [pc, #288]	; (842c <SdioCard::begin(SdioConfig)+0x33c>)
    830a:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    830e:	mov	fp, r0
    8310:	cbz	r0, 831e <SdioCard::begin(SdioConfig)+0x22e>
    8312:	b.n	8330 <SdioCard::begin(SdioConfig)+0x240>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8314:	movs	r3, #23
    8316:	strb	r3, [r4, #0]
  m_errorLine = line;
    8318:	movw	r2, #679	; 0x2a7
    831c:	b.n	8326 <SdioCard::begin(SdioConfig)+0x236>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    831e:	movs	r3, #20
    8320:	strb	r3, [r4, #0]
  m_errorLine = line;
    8322:	movw	r2, #706	; 0x2c2
    8326:	ldr	r3, [pc, #232]	; (8410 <SdioCard::begin(SdioConfig)+0x320>)
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
  }
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
    8328:	mov.w	fp, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    832c:	str	r2, [r3, #0]
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
  }
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
    832e:	b.n	83b6 <SdioCard::begin(SdioConfig)+0x2c6>
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
    8330:	ldr	r3, [pc, #252]	; (8430 <SdioCard::begin(SdioConfig)+0x340>)
    8332:	ldr	r2, [r3, #0]
    8334:	bic.w	r2, r2, #6
    8338:	str	r2, [r3, #0]
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);
    833a:	ldr	r2, [r3, #0]
    833c:	orr.w	r2, r2, #2
    8340:	str	r2, [r3, #0]

  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);
    8342:	mov.w	r2, #1048592	; 0x100010
    8346:	str	r2, [r3, #28]

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8348:	add	r1, sp, #16
    834a:	mvn.w	r0, #4278190080	; 0xff000000
    834e:	bl	8058 <cardCMD6(unsigned long, unsigned char*)>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    8352:	cbz	r0, 835c <SdioCard::begin(SdioConfig)+0x26c>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8354:	ldrb.w	r3, [sp, #29]
    8358:	lsls	r3, r3, #30
    835a:	bmi.n	8362 <SdioCard::begin(SdioConfig)+0x272>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    kHzSdClk = 50000;
  } else {
    kHzSdClk = 25000;
    835c:	movw	r0, #25000	; 0x61a8
    8360:	b.n	837e <SdioCard::begin(SdioConfig)+0x28e>

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    8362:	add	r1, sp, #16
    8364:	ldr	r0, [pc, #204]	; (8434 <SdioCard::begin(SdioConfig)+0x344>)
    8366:	bl	8058 <cardCMD6(unsigned long, unsigned char*)>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    836a:	cmp	r0, #0
    836c:	beq.n	835c <SdioCard::begin(SdioConfig)+0x26c>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    836e:	ldrb.w	r3, [sp, #32]
    8372:	and.w	r3, r3, #15
    8376:	cmp	r3, #1
    8378:	bne.n	835c <SdioCard::begin(SdioConfig)+0x26c>
    kHzSdClk = 50000;
    837a:	movw	r0, #50000	; 0xc350
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    837e:	ldr	r4, [pc, #92]	; (83dc <SdioCard::begin(SdioConfig)+0x2ec>)
    8380:	movw	r3, #259	; 0x103
    8384:	str	r3, [r4, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8386:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8388:	str	r3, [r6, #0]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    838a:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    838c:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8390:	str.w	r3, [r9]
  }
  // Disable GPIO.
  enableGPIO(false);

  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);
    8394:	bl	7844 <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8398:	movw	r3, #1091	; 0x443
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    839c:	mov.w	r2, #1088	; 0x440
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    83a0:	str	r3, [r4, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    83a2:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    83a4:	str	r2, [r6, #0]
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    83a6:	ldr	r2, [sp, #4]
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    83a8:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    83aa:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    83ae:	str.w	r3, [r9]
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    83b2:	movs	r3, #1
    83b4:	strb	r3, [r2, #0]
  return true;
}
    83b6:	mov	r0, fp
    83b8:	add	sp, #84	; 0x54
    83ba:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    83be:	nop
    83c0:	.word	0x1fff1358
    83c4:	.word	0x4000d800
    83c8:	.word	0x4004d014
    83cc:	.word	0x4004d004
    83d0:	.word	0x4004d008
    83d4:	.word	0x4004d00c
    83d8:	.word	0x400b102c
    83dc:	.word	0x4004d000
    83e0:	.word	0x400b1034
    83e4:	.word	0x117f000b
    83e8:	.word	0x00007795
    83ec:	.word	0xe000e451
    83f0:	.word	0x081a0000
    83f4:	.word	0x400b1010
    83f8:	.word	0x40300000
    83fc:	.word	0x371a0000
    8400:	.word	0x29020000
    8404:	.word	0x000f4240
    8408:	.word	0x1fff8444
    840c:	.word	0x02090000
    8410:	.word	0x1fff846c
    8414:	.word	0x031a0000
    8418:	.word	0x1fff8455
    841c:	.word	0x09090000
    8420:	.word	0x1fff8429
    8424:	.word	0x0a090000
    8428:	.word	0x071b0000
    842c:	.word	0x061a0000
    8430:	.word	0x400b1028
    8434:	.word	0x80fffff1
    8438:	.word	0x1fff8454
    843c:	.word	0x1fff8440
    8440:	.word	0x1fff8428
    8444:	.word	0x4004d010
    8448:	.word	0x1fff8448

0000844c <SdioCard::readData(unsigned char*)>:
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    844c:	push	{r3, r4, r5, lr}
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    844e:	ldr	r5, [pc, #152]	; (84e8 <SdioCard::readData(unsigned char*)+0x9c>)
    8450:	ldr	r3, [r5, #0]
    8452:	lsls	r3, r3, #22
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    8454:	mov	r4, r1
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    8456:	bmi.n	8476 <SdioCard::readData(unsigned char*)+0x2a>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8458:	ldr	r3, [pc, #144]	; (84ec <SdioCard::readData(unsigned char*)+0xa0>)
    845a:	ldr	r2, [r3, #0]
    845c:	bic.w	r2, r2, #65536	; 0x10000
    8460:	str	r2, [r3, #0]
    noInterrupts();
    8462:	cpsid	i
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    8464:	ldr	r2, [r3, #0]
    8466:	orr.w	r2, r2, #131072	; 0x20000
    846a:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    846c:	ldr	r2, [r3, #0]
    846e:	orr.w	r2, r2, #65536	; 0x10000
    8472:	str	r2, [r3, #0]
    interrupts();
    8474:	cpsie	i
  }
  if (waitTimeout(isBusyFifoRead)) {
    8476:	ldr	r0, [pc, #120]	; (84f0 <SdioCard::readData(unsigned char*)+0xa4>)
    8478:	bl	7940 <waitTimeout(bool (*)())>
    847c:	cbnz	r0, 84d4 <SdioCard::readData(unsigned char*)+0x88>
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    847e:	ldr	r1, [pc, #116]	; (84f4 <SdioCard::readData(unsigned char*)+0xa8>)
    8480:	subs	r3, r4, #4
    8482:	add.w	r4, r4, #508	; 0x1fc
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    8486:	ldr	r2, [r5, #0]
    8488:	lsls	r0, r2, #20
    848a:	bpl.n	8486 <SdioCard::readData(unsigned char*)+0x3a>
    848c:	add.w	r2, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    8490:	ldr	r0, [r1, #0]
    8492:	str.w	r0, [r3, #4]!
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    8496:	cmp	r2, r3
    8498:	bne.n	8490 <SdioCard::readData(unsigned char*)+0x44>
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    849a:	cmp	r4, r2
    849c:	mov	r3, r2
    849e:	bne.n	8486 <SdioCard::readData(unsigned char*)+0x3a>
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    }
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    84a0:	ldr	r0, [pc, #84]	; (84f8 <SdioCard::readData(unsigned char*)+0xac>)
    84a2:	bl	7940 <waitTimeout(bool (*)())>
    84a6:	cbz	r0, 84b4 <SdioCard::readData(unsigned char*)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    84a8:	ldr	r3, [pc, #80]	; (84fc <SdioCard::readData(unsigned char*)+0xb0>)
    84aa:	movs	r2, #29
    84ac:	strb	r2, [r3, #0]
  m_errorLine = line;
    84ae:	movw	r2, #846	; 0x34e
    84b2:	b.n	84de <SdioCard::readData(unsigned char*)+0x92>
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
    84b4:	ldr	r2, [pc, #72]	; (8500 <SdioCard::readData(unsigned char*)+0xb4>)
    84b6:	ldr	r3, [pc, #76]	; (8504 <SdioCard::readData(unsigned char*)+0xb8>)
    84b8:	ldr	r1, [r2, #0]
    84ba:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    84bc:	ldr	r1, [r3, #0]
    84be:	str	r1, [r2, #0]
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    84c0:	ldr	r2, [r3, #0]
    84c2:	lsls	r2, r2, #30
    84c4:	bpl.n	84e4 <SdioCard::readData(unsigned char*)+0x98>
    84c6:	ldr	r3, [r3, #0]
    84c8:	ldr	r0, [pc, #60]	; (8508 <SdioCard::readData(unsigned char*)+0xbc>)
    84ca:	ands	r0, r3
    84cc:	clz	r0, r0
    84d0:	lsrs	r0, r0, #5
    84d2:	pop	{r3, r4, r5, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    84d4:	ldr	r3, [pc, #36]	; (84fc <SdioCard::readData(unsigned char*)+0xb0>)
    84d6:	movs	r2, #26
    84d8:	strb	r2, [r3, #0]
  m_errorLine = line;
    84da:	movw	r2, #835	; 0x343
    84de:	ldr	r3, [pc, #44]	; (850c <SdioCard::readData(unsigned char*)+0xc0>)
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
    84e0:	movs	r0, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    84e2:	str	r2, [r3, #0]
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
    84e4:	pop	{r3, r4, r5, pc}
    84e6:	nop
    84e8:	.word	0x400b1024
    84ec:	.word	0x400b1028
    84f0:	.word	0x00007805
    84f4:	.word	0x400b1020
    84f8:	.word	0x0000782d
    84fc:	.word	0x1fff1358
    8500:	.word	0x400b1030
    8504:	.word	0x1fff8450
    8508:	.word	0x117f0000
    850c:	.word	0x1fff846c

00008510 <SdioCard::readStart(unsigned long)>:
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    8510:	push	{r4, lr}
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    8512:	ldr	r0, [pc, #80]	; (8564 <SdioCard::readStart(unsigned long)+0x54>)
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    8514:	mov	r4, r1
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    8516:	bl	7964 <yieldTimeout(bool (*)())>
    851a:	cbz	r0, 852e <SdioCard::readStart(unsigned long)+0x1e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    851c:	ldr	r3, [pc, #72]	; (8568 <SdioCard::readStart(unsigned long)+0x58>)
    851e:	movs	r2, #10
    8520:	strb	r2, [r3, #0]
  m_errorLine = line;
    8522:	ldr	r3, [pc, #72]	; (856c <SdioCard::readStart(unsigned long)+0x5c>)
    8524:	mov.w	r2, #928	; 0x3a0
    8528:	str	r2, [r3, #0]
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    852a:	movs	r0, #0
    852c:	pop	{r4, pc}
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    852e:	ldr	r2, [pc, #64]	; (8570 <SdioCard::readStart(unsigned long)+0x60>)
    8530:	ldr	r3, [r2, #0]
    8532:	orr.w	r3, r3, #65536	; 0x10000
    8536:	str	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    8538:	ldr	r3, [pc, #56]	; (8574 <SdioCard::readStart(unsigned long)+0x64>)
    853a:	ldr	r2, [pc, #60]	; (8578 <SdioCard::readStart(unsigned long)+0x68>)
    853c:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    853e:	ldr	r3, [pc, #60]	; (857c <SdioCard::readStart(unsigned long)+0x6c>)
    8540:	ldrb	r3, [r3, #0]
    8542:	cbnz	r3, 8548 <SdioCard::readStart(unsigned long)+0x38>
    8544:	lsls	r1, r4, #9
    8546:	b.n	854a <SdioCard::readStart(unsigned long)+0x3a>
    8548:	mov	r1, r4
    854a:	ldr	r0, [pc, #52]	; (8580 <SdioCard::readStart(unsigned long)+0x70>)
    854c:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    8550:	cbnz	r0, 8560 <SdioCard::readStart(unsigned long)+0x50>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8552:	ldr	r3, [pc, #20]	; (8568 <SdioCard::readStart(unsigned long)+0x58>)
    8554:	movs	r2, #12
    8556:	strb	r2, [r3, #0]
  m_errorLine = line;
    8558:	ldr	r3, [pc, #16]	; (856c <SdioCard::readStart(unsigned long)+0x5c>)
    855a:	mov.w	r2, #940	; 0x3ac
    855e:	str	r2, [r3, #0]

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD18);
  }
  return true;
}
    8560:	pop	{r4, pc}
    8562:	nop
    8564:	.word	0x00007a49
    8568:	.word	0x1fff1358
    856c:	.word	0x1fff846c
    8570:	.word	0x400b1028
    8574:	.word	0x400b1004
    8578:	.word	0xffff0200
    857c:	.word	0x1fff8440
    8580:	.word	0x123a0032

00008584 <SdioCard::readSector(unsigned long, unsigned char*)>:
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8584:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    8586:	ldrb	r3, [r0, #8]
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8588:	mov	r6, r2
  if (m_sdioConfig.useDma()) {
    858a:	lsls	r2, r3, #31
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    858c:	sub.w	sp, sp, #512	; 0x200
    8590:	mov	r4, r0
    8592:	mov	r5, r1
  if (m_sdioConfig.useDma()) {
    8594:	bpl.n	85ce <SdioCard::readSector(unsigned long, unsigned char*)+0x4a>
    uint8_t aligned[512];

    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;
    8596:	lsls	r3, r6, #30
    8598:	ite	eq
    859a:	moveq	r4, r6
    859c:	movne	r4, sp

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
    859e:	movs	r3, #1
    85a0:	mov	r2, r4
    85a2:	ldr	r0, [pc, #148]	; (8638 <SdioCard::readSector(unsigned long, unsigned char*)+0xb4>)
    85a4:	bl	7ae4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    85a8:	mov	r5, r0
    85aa:	cbnz	r0, 85bc <SdioCard::readSector(unsigned long, unsigned char*)+0x38>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    85ac:	ldr	r3, [pc, #140]	; (863c <SdioCard::readSector(unsigned long, unsigned char*)+0xb8>)
    85ae:	movs	r2, #11
    85b0:	strb	r2, [r3, #0]
  m_errorLine = line;
    85b2:	ldr	r3, [pc, #140]	; (8640 <SdioCard::readSector(unsigned long, unsigned char*)+0xbc>)
    85b4:	movw	r2, #865	; 0x361
    85b8:	str	r2, [r3, #0]
    85ba:	b.n	8630 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD17);
    }
    if (ptr != dst) {
    85bc:	cmp	r4, r6
    85be:	beq.n	8630 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
      memcpy(dst, aligned, 512);
    85c0:	mov.w	r2, #512	; 0x200
    85c4:	mov	r1, sp
    85c6:	mov	r0, r6
    85c8:	bl	8734 <memcpy>
    85cc:	b.n	8630 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    85ce:	bl	7cbc <waitTransferComplete()>
    85d2:	cbnz	r0, 85d8 <SdioCard::readSector(unsigned long, unsigned char*)+0x54>
      return false;
    85d4:	movs	r5, #0
    85d6:	b.n	8630 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    }
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != READ_STATE || sector != m_curSector) {
    85d8:	ldrb	r3, [r4, #9]
    85da:	cmp	r3, #1
    85dc:	bne.n	85e4 <SdioCard::readSector(unsigned long, unsigned char*)+0x60>
    85de:	ldr	r3, [r4, #4]
    85e0:	cmp	r5, r3
    85e2:	beq.n	8602 <SdioCard::readSector(unsigned long, unsigned char*)+0x7e>
      if (!syncDevice()) {
    85e4:	ldr	r3, [r4, #0]
    85e6:	mov	r0, r4
    85e8:	ldr	r3, [r3, #28]
    85ea:	blx	r3
    85ec:	cmp	r0, #0
    85ee:	beq.n	85d4 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
        return false;
      }
      if (!readStart(sector)) {
    85f0:	mov	r1, r5
    85f2:	mov	r0, r4
    85f4:	bl	8510 <SdioCard::readStart(unsigned long)>
    85f8:	cmp	r0, #0
    85fa:	beq.n	85d4 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
        return false;
      }
      m_curSector = sector;
      m_curState = READ_STATE;
    85fc:	movs	r3, #1
        return false;
      }
      if (!readStart(sector)) {
        return false;
      }
      m_curSector = sector;
    85fe:	str	r5, [r4, #4]
      m_curState = READ_STATE;
    8600:	strb	r3, [r4, #9]
    }
    if (!readData(dst)) {
    8602:	mov	r1, r6
    8604:	mov	r0, r4
    8606:	bl	844c <SdioCard::readData(unsigned char*)>
    860a:	mov	r5, r0
    860c:	cmp	r0, #0
    860e:	beq.n	85d4 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    8610:	ldr	r3, [pc, #48]	; (8644 <SdioCard::readSector(unsigned long, unsigned char*)+0xc0>)
    8612:	ldr	r3, [r3, #0]
    8614:	lsrs	r3, r3, #16
    8616:	lsls	r3, r3, #16
    8618:	cbz	r3, 8622 <SdioCard::readSector(unsigned long, unsigned char*)+0x9e>
      if (!syncDevice()) {
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
    861a:	ldr	r3, [r4, #4]
    861c:	adds	r3, #1
    861e:	str	r3, [r4, #4]
    8620:	b.n	8630 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    if (!readData(dst)) {
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    8622:	ldr	r3, [r4, #0]
    8624:	mov	r0, r4
    8626:	ldr	r3, [r3, #28]
    8628:	blx	r3
    862a:	cmp	r0, #0
    862c:	bne.n	861a <SdioCard::readSector(unsigned long, unsigned char*)+0x96>
    862e:	b.n	85d4 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
}
    8630:	mov	r0, r5
    8632:	add.w	sp, sp, #512	; 0x200
    8636:	pop	{r4, r5, r6, pc}
    8638:	.word	0x113a0011
    863c:	.word	0x1fff1358
    8640:	.word	0x1fff846c
    8644:	.word	0x400b1004

00008648 <SdioCard::stopTransmission(bool)>:
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    8648:	push	{r4, r5, r6, lr}
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    864a:	ldr	r2, [pc, #72]	; (8694 <SdioCard::stopTransmission(bool)+0x4c>)
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
    864c:	movs	r5, #0
    864e:	strb	r5, [r0, #9]
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8650:	ldr	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    8652:	ldr	r0, [pc, #68]	; (8698 <SdioCard::stopTransmission(bool)+0x50>)
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8654:	bic.w	r3, r3, #65536	; 0x10000
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    8658:	mov	r6, r1
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    865a:	str	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    865c:	mov	r1, r5
    865e:	bl	79d4 <cardCommand(unsigned long, unsigned long)>
    8662:	mov	r4, r0
    8664:	cbnz	r0, 8676 <SdioCard::stopTransmission(bool)+0x2e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8666:	ldr	r3, [pc, #52]	; (869c <SdioCard::stopTransmission(bool)+0x54>)
    8668:	movs	r2, #9
    866a:	strb	r2, [r3, #0]
  m_errorLine = line;
    866c:	ldr	r3, [pc, #48]	; (86a0 <SdioCard::stopTransmission(bool)+0x58>)
    866e:	movw	r2, #962	; 0x3c2
    8672:	str	r2, [r3, #0]
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
    8674:	b.n	8690 <SdioCard::stopTransmission(bool)+0x48>
  }
  if (blocking) {
    8676:	cbz	r6, 8690 <SdioCard::stopTransmission(bool)+0x48>
    if (yieldTimeout(isBusyDat)) {
    8678:	ldr	r0, [pc, #40]	; (86a4 <SdioCard::stopTransmission(bool)+0x5c>)
    867a:	bl	7964 <yieldTimeout(bool (*)())>
    867e:	cbz	r0, 8690 <SdioCard::stopTransmission(bool)+0x48>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8680:	ldr	r3, [pc, #24]	; (869c <SdioCard::stopTransmission(bool)+0x54>)
    8682:	movs	r2, #10
    8684:	strb	r2, [r3, #0]
  m_errorLine = line;
    8686:	ldr	r3, [pc, #24]	; (86a0 <SdioCard::stopTransmission(bool)+0x58>)
    8688:	movw	r2, #966	; 0x3c6
    868c:	str	r2, [r3, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
  if (blocking) {
    if (yieldTimeout(isBusyDat)) {
      return sdError(SD_CARD_ERROR_CMD13);
    868e:	mov	r4, r5
    }
  }
  return true;
}
    8690:	mov	r0, r4
    8692:	pop	{r4, r5, r6, pc}
    8694:	.word	0x400b1028
    8698:	.word	0x0cdb0000
    869c:	.word	0x1fff1358
    86a0:	.word	0x1fff846c
    86a4:	.word	0x000077e5

000086a8 <SdioCard::syncDevice()>:
//------------------------------------------------------------------------------
bool SdioCard::syncDevice() {
    86a8:	push	{r4, lr}
    86aa:	mov	r4, r0
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    86ac:	bl	7cbc <waitTransferComplete()>
    86b0:	cbz	r0, 86c2 <SdioCard::syncDevice()+0x1a>
    return false;
  }
  if (m_curState != IDLE_STATE) {
    86b2:	ldrb	r3, [r4, #9]
    86b4:	cbz	r3, 86c2 <SdioCard::syncDevice()+0x1a>
    return stopTransmission(true);
    86b6:	mov	r0, r4
    86b8:	movs	r1, #1
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    86ba:	ldmia.w	sp!, {r4, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    return false;
  }
  if (m_curState != IDLE_STATE) {
    return stopTransmission(true);
    86be:	b.w	8648 <SdioCard::stopTransmission(bool)>
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    86c2:	pop	{r4, pc}

000086c4 <SdioCard::isBusy()>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorLine() const {
  return m_errorLine;
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
    86c4:	push	{r4, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    86c6:	ldrb	r3, [r0, #8]
    86c8:	lsls	r3, r3, #31
//------------------------------------------------------------------------------
uint32_t SdioCard::errorLine() const {
  return m_errorLine;
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
    86ca:	mov	r2, r0
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    86cc:	bpl.n	86ec <SdioCard::isBusy()+0x28>
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    86ce:	ldr	r3, [pc, #80]	; (8720 <SdioCard::isBusy()+0x5c>)
    86d0:	ldr	r3, [r3, #0]
    86d2:	cbz	r3, 86da <SdioCard::isBusy()+0x16>
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    86d4:	ldmia.w	sp!, {r4, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    86d8:	bx	r3
    86da:	ldr	r3, [pc, #72]	; (8724 <SdioCard::isBusy()+0x60>)
    86dc:	ldrb	r3, [r3, #0]
    86de:	cbnz	r3, 86e4 <SdioCard::isBusy()+0x20>
    86e0:	movs	r0, #0
    86e2:	pop	{r4, pc}
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    86e4:	ldmia.w	sp!, {r4, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    86e8:	b.w	7a48 <isBusyCMD13()>
  } else {
    if (m_transferActive) {
    86ec:	ldr	r1, [pc, #56]	; (8728 <SdioCard::isBusy()+0x64>)
    86ee:	ldrb	r4, [r1, #0]
    86f0:	cbz	r4, 8712 <SdioCard::isBusy()+0x4e>
      if (isBusyTransferComplete()) {
    86f2:	bl	782c <isBusyTransferComplete()>
    86f6:	cbnz	r0, 871e <SdioCard::isBusy()+0x5a>
        return true;
      }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
      if ((SDHC_BLKATTR & 0XFFFF0000) != 0) {
    86f8:	ldr	r3, [pc, #48]	; (872c <SdioCard::isBusy()+0x68>)
    86fa:	ldr	r3, [r3, #0]
    86fc:	lsrs	r3, r3, #16
    86fe:	lsls	r3, r3, #16
    8700:	cmp	r3, #0
    8702:	bne.n	86e0 <SdioCard::isBusy()+0x1c>
        return false;
      }
      m_transferActive = false;
    8704:	strb	r0, [r1, #0]
      stopTransmission(false);
    8706:	mov	r1, r0
    8708:	mov	r0, r2
    870a:	bl	8648 <SdioCard::stopTransmission(bool)>
    870e:	mov	r0, r4
    8710:	pop	{r4, pc}
#else  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
      return false;
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    }
    // Use DAT0 low as busy.
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
    8712:	ldr	r3, [pc, #28]	; (8730 <SdioCard::isBusy()+0x6c>)
    8714:	ldr	r0, [r3, #0]
    8716:	eor.w	r0, r0, #16777216	; 0x1000000
    871a:	ubfx	r0, r0, #24, #1
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    871e:	pop	{r4, pc}
    8720:	.word	0x1fff843c
    8724:	.word	0x1fff8454
    8728:	.word	0x1fff844c
    872c:	.word	0x400b1004
    8730:	.word	0x400b1024

00008734 <memcpy>:
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
#else
	push	{r0}
    8734:	push	{r0}
#endif
	orr	r3, r1, r0
    8736:	orr.w	r3, r1, r0
	ands	r3, r3, #3
    873a:	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    873e:	bne.n	8820 <memcpy+0xec>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    8740:	subs	r2, #64	; 0x40
	blo	.Lmid_block
    8742:	bcc.n	87c8 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    8744:	ldr.w	r3, [r1], #4
    8748:	str.w	r3, [r0], #4
    874c:	ldr.w	r3, [r1], #4
    8750:	str.w	r3, [r0], #4
    8754:	ldr.w	r3, [r1], #4
    8758:	str.w	r3, [r0], #4
    875c:	ldr.w	r3, [r1], #4
    8760:	str.w	r3, [r0], #4
    8764:	ldr.w	r3, [r1], #4
    8768:	str.w	r3, [r0], #4
    876c:	ldr.w	r3, [r1], #4
    8770:	str.w	r3, [r0], #4
    8774:	ldr.w	r3, [r1], #4
    8778:	str.w	r3, [r0], #4
    877c:	ldr.w	r3, [r1], #4
    8780:	str.w	r3, [r0], #4
    8784:	ldr.w	r3, [r1], #4
    8788:	str.w	r3, [r0], #4
    878c:	ldr.w	r3, [r1], #4
    8790:	str.w	r3, [r0], #4
    8794:	ldr.w	r3, [r1], #4
    8798:	str.w	r3, [r0], #4
    879c:	ldr.w	r3, [r1], #4
    87a0:	str.w	r3, [r0], #4
    87a4:	ldr.w	r3, [r1], #4
    87a8:	str.w	r3, [r0], #4
    87ac:	ldr.w	r3, [r1], #4
    87b0:	str.w	r3, [r0], #4
    87b4:	ldr.w	r3, [r1], #4
    87b8:	str.w	r3, [r0], #4
    87bc:	ldr.w	r3, [r1], #4
    87c0:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    87c4:	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    87c6:	bcs.n	8744 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    87c8:	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    87ca:	bcc.n	87f0 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    87cc:	ldr.w	r3, [r1], #4
    87d0:	str.w	r3, [r0], #4
    87d4:	ldr.w	r3, [r1], #4
    87d8:	str.w	r3, [r0], #4
    87dc:	ldr.w	r3, [r1], #4
    87e0:	str.w	r3, [r0], #4
    87e4:	ldr.w	r3, [r1], #4
    87e8:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    87ec:	subs	r2, #16
	bhs	.Lmid_block_loop
    87ee:	bcs.n	87cc <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    87f0:	adds	r2, #12
	blo	.Lcopy_less_than_4
    87f2:	bcc.n	8800 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    87f4:	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    87f8:	str.w	r3, [r0], #4
	subs	r2, #4
    87fc:	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    87fe:	bcs.n	87f4 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    8800:	adds	r2, #4
	beq	.Ldone
    8802:	beq.n	881a <memcpy+0xe6>

	lsls	r2, r2, #31
    8804:	lsls	r2, r2, #31
	itt ne
    8806:	itt	ne
	ldrbne  r3, [r1], #1
    8808:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    880c:	strbne.w	r3, [r0], #1

	bcc	.Ldone
    8810:	bcc.n	881a <memcpy+0xe6>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
	strh	r3, [r0]
#else
	ldrb	r3, [r1]
    8812:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    8814:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    8816:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    8818:	strb	r3, [r0, #1]

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    881a:	pop	{r0}
#endif
	bx	lr
    881c:	bx	lr
    881e:	nop
	beq	.Ldst_aligned
#else
	/* if len < 12, misalignment adjustment has more overhead than
	just byte-to-byte copy.  Also, len must >=8 to guarantee code
	afterward work correctly.  */
	cmp	r2, #12
    8820:	cmp	r2, #12
	blo	.Lbyte_copy
    8822:	bcc.n	88ba <memcpy+0x186>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    8824:	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    8828:	beq.n	884e <memcpy+0x11a>

	rsb	r3, #4
    882a:	rsb	r3, r3, #4
	subs	r2, r3
    882e:	subs	r2, r2, r3

	lsls    r3, r3, #31
    8830:	lsls	r3, r3, #31
	itt ne
    8832:	itt	ne
	ldrbne  r3, [r1], #1
    8834:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    8838:	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    883c:	bcc.n	884e <memcpy+0x11a>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
	strh    r3, [r0], #2
	b	.Ldst_aligned
#else
	ldrb    r3, [r1], #1
    883e:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    8842:	strb.w	r3, [r0], #1
	ldrb    r3, [r1], #1
    8846:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    884a:	strb.w	r3, [r0], #1
	/* Now that dst is aligned */
.Ldst_aligned:
	/* if r1 is aligned now, it means r0/r1 has the same misalignment,
	and they are both aligned now.  Go aligned copy.  */
	ands	r3, r1, #3
    884e:	ands.w	r3, r1, #3
	beq	.Lbig_block
    8852:	beq.w	8740 <memcpy+0xc>

	/* dst is aligned, but src isn't.  Misaligned copy.  */

	push	{r4, r5}
    8856:	push	{r4, r5}
	subs	r2, #4
    8858:	subs	r2, #4

	/* Backward r1 by misaligned bytes, to make r1 aligned.
	Since we need to restore r1 to unaligned address after the loop,
	we need keep the offset bytes to ip and sub it from r1 afterward.  */
	subs	r1, r3
    885a:	subs	r1, r1, r3
	rsb	ip, r3, #4
    885c:	rsb	ip, r3, #4

	/* Pre-load on word */
	ldr	r4, [r1], #4
    8860:	ldr.w	r4, [r1], #4

	cmp	r3, #2
    8864:	cmp	r3, #2
	beq	.Lmisaligned_copy_2_2
    8866:	beq.n	889c <memcpy+0x168>
	cmp	r3, #3
    8868:	cmp	r3, #3
	beq	.Lmisaligned_copy_3_1
    886a:	beq.n	8884 <memcpy+0x150>
	subs	r2, #4
	bhs	1b
	.endm

.Lmisaligned_copy_1_3:
	mis_src_copy shift=8
    886c:	lsrs	r4, r4, #8
    886e:	ldr.w	r3, [r1], #4
    8872:	lsls	r5, r3, #24
    8874:	orr.w	r4, r4, r5
    8878:	str.w	r4, [r0], #4
    887c:	mov	r4, r3
    887e:	subs	r2, #4
    8880:	bcs.n	886c <memcpy+0x138>
	b	.Lsrc_misaligned_tail
    8882:	b.n	88b2 <memcpy+0x17e>

.Lmisaligned_copy_3_1:
	mis_src_copy shift=24
    8884:	lsrs	r4, r4, #24
    8886:	ldr.w	r3, [r1], #4
    888a:	lsls	r5, r3, #8
    888c:	orr.w	r4, r4, r5
    8890:	str.w	r4, [r0], #4
    8894:	mov	r4, r3
    8896:	subs	r2, #4
    8898:	bcs.n	8884 <memcpy+0x150>
	b	.Lsrc_misaligned_tail
    889a:	b.n	88b2 <memcpy+0x17e>

.Lmisaligned_copy_2_2:
	/* For 2_2 misalignment, ldr is still faster than 2 x ldrh.  */
	mis_src_copy shift=16
    889c:	lsrs	r4, r4, #16
    889e:	ldr.w	r3, [r1], #4
    88a2:	lsls	r5, r3, #16
    88a4:	orr.w	r4, r4, r5
    88a8:	str.w	r4, [r0], #4
    88ac:	mov	r4, r3
    88ae:	subs	r2, #4
    88b0:	bcs.n	889c <memcpy+0x168>

.Lsrc_misaligned_tail:
	adds	r2, #4
    88b2:	adds	r2, #4
	subs	r1, ip
    88b4:	subs.w	r1, r1, ip
	pop	{r4, r5}
    88b8:	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    88ba:	subs	r2, #4
	blo	.Lcopy_less_than_4
    88bc:	bcc.n	8800 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    88be:	subs	r2, #1
	ldrb    r3, [r1], #1
    88c0:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    88c4:	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    88c8:	bcs.n	88be <memcpy+0x18a>

	ldrb	r3, [r1]
    88ca:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    88cc:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    88ce:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    88d0:	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    88d2:	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    88d4:	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    88d6:	pop	{r0}
#endif
	bx	lr
    88d8:	bx	lr
    88da:	nop

000088dc <memset>:
	.type	memset, %function
	.thumb_func
	memset:
//FUNCTION(memset)
    // save the original pointer
    push    { r0, lr }
    88dc:	push	{r0, lr}

    // check for zero length
    cbz     r2, .L_done
    88de:	cbz	r2, 891c <memset+0x40>

    // short memsets aren't worth optimizing and make sure we have
    // enough headroom to try to do dwordwise move optimization
    cmp     r2, #16
    88e0:	cmp	r2, #16
    blt     .L_bytewise
    88e2:	blt.n	8914 <memset+0x38>

    // see how many bytes we need to move to align to dword boundaries
    and     r3, r0, #7
    88e4:	and.w	r3, r0, #7
    cbz     r3, .L_prepare_dwordwise
    88e8:	cbz	r3, 88f8 <memset+0x1c>
    rsb     r3, #8
    88ea:	rsb	r3, r3, #8
    subs    r2, r3
    88ee:	subs	r2, r2, r3

.L_bytewise_align:
    // bytewise to align memset
    subs    r3, r3, #1
    88f0:	subs	r3, #1
    strb    r1, [r0], #1
    88f2:	strb.w	r1, [r0], #1
    bgt     .L_bytewise_align
    88f6:	bgt.n	88f0 <memset+0x14>

.L_prepare_dwordwise:
    // fill a pair of 32 bit registers with the 8 bit value
    uxtb    r1, r1
    88f8:	uxtb	r1, r1
    orr     r1, r1, r1, lsl #8
    88fa:	orr.w	r1, r1, r1, lsl #8
    orr     r1, r1, r1, lsl #16
    88fe:	orr.w	r1, r1, r1, lsl #16
    mov     r12, r1
    8902:	mov	ip, r1

    // load the number of dwords left
    lsrs    r3, r2, #3
    8904:	lsrs	r3, r2, #3

.L_dwordwise:
    // dwordwise memset
		
    subs    r3, r3, #1
    8906:	subs	r3, #1
    strd    r1, r12, [r0], #8
    8908:	strd	r1, ip, [r0], #8
    bgt     .L_dwordwise
    890c:	bgt.n	8906 <memset+0x2a>

    // remaining bytes
    ands     r2, #7
    890e:	ands.w	r2, r2, #7
    beq     .L_done
    8912:	beq.n	891c <memset+0x40>

.L_bytewise:
    // bytewise memset
    subs    r2, r2, #1
    8914:	subs	r2, #1
    strb    r1, [r0], #1
    8916:	strb.w	r1, [r0], #1
    bgt     .L_bytewise
    891a:	bgt.n	8914 <memset+0x38>

.L_done:
    // restore the base pointer as return value
    pop     { r0, pc }
    891c:	pop	{r0, pc}
    891e:	nop

00008920 <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    8920:	push	{r4, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    8922:	ldr	r4, [pc, #64]	; (8964 <usb_serial_getchar+0x44>)
    8924:	ldr	r3, [r4, #0]
    8926:	cbz	r3, 8944 <usb_serial_getchar+0x24>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    8928:	ldr	r0, [r4, #0]
    892a:	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
    892c:	adds	r2, r3, #1
    892e:	add	r3, r0
    8930:	ldrb	r4, [r3, #8]
	if (i >= rx_packet->len) {
    8932:	ldrh	r3, [r0, #0]
    8934:	cmp	r2, r3
    8936:	bcc.n	895e <usb_serial_getchar+0x3e>
		usb_free(rx_packet);
    8938:	bl	8f5c <usb_free>
		rx_packet = NULL;
    893c:	ldr	r3, [pc, #36]	; (8964 <usb_serial_getchar+0x44>)
    893e:	movs	r2, #0
    8940:	str	r2, [r3, #0]
    8942:	b.n	8960 <usb_serial_getchar+0x40>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    8944:	ldr	r3, [pc, #32]	; (8968 <usb_serial_getchar+0x48>)
    8946:	ldrb	r3, [r3, #0]
    8948:	cbnz	r3, 8950 <usb_serial_getchar+0x30>
    894a:	mov.w	r0, #4294967295
    894e:	pop	{r4, pc}
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    8950:	movs	r0, #3
    8952:	bl	8fe0 <usb_rx>
    8956:	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    8958:	cmp	r0, #0
    895a:	bne.n	8928 <usb_serial_getchar+0x8>
    895c:	b.n	894a <usb_serial_getchar+0x2a>
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    895e:	strh	r2, [r0, #2]
	}
	return c;
    8960:	mov	r0, r4
}
    8962:	pop	{r4, pc}
    8964:	.word	0x1fff847c
    8968:	.word	0x1fff8567

0000896c <usb_serial_peekchar>:

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    896c:	push	{r4, lr}
	if (!rx_packet) {
    896e:	ldr	r4, [pc, #44]	; (899c <usb_serial_peekchar+0x30>)
    8970:	ldr	r3, [r4, #0]
    8972:	cbz	r3, 897a <usb_serial_peekchar+0xe>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
    8974:	ldr	r2, [r4, #0]
    8976:	cbnz	r2, 8994 <usb_serial_peekchar+0x28>
    8978:	b.n	8980 <usb_serial_peekchar+0x14>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    897a:	ldr	r3, [pc, #36]	; (89a0 <usb_serial_peekchar+0x34>)
    897c:	ldrb	r3, [r3, #0]
    897e:	cbnz	r3, 8986 <usb_serial_peekchar+0x1a>
    8980:	mov.w	r0, #4294967295
    8984:	pop	{r4, pc}
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    8986:	movs	r0, #3
    8988:	bl	8fe0 <usb_rx>
    898c:	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    898e:	cmp	r0, #0
    8990:	bne.n	8974 <usb_serial_peekchar+0x8>
    8992:	b.n	8980 <usb_serial_peekchar+0x14>
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    8994:	ldrh	r3, [r2, #2]
    8996:	add	r3, r2
    8998:	ldrb	r0, [r3, #8]
}
    899a:	pop	{r4, pc}
    899c:	.word	0x1fff847c
    89a0:	.word	0x1fff8567

000089a4 <usb_serial_available>:
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    89a4:	ldr	r3, [pc, #16]	; (89b8 <usb_serial_available+0x14>)

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    89a6:	ldrh	r0, [r3, #4]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    89a8:	ldr	r3, [pc, #16]	; (89bc <usb_serial_available+0x18>)
    89aa:	ldr	r2, [r3, #0]
    89ac:	cbz	r2, 89b6 <usb_serial_available+0x12>
    89ae:	ldrh	r3, [r2, #0]
    89b0:	ldrh	r2, [r2, #2]
    89b2:	subs	r3, r3, r2
    89b4:	add	r0, r3
	return count;
}
    89b6:	bx	lr
    89b8:	.word	0x1fff85e4
    89bc:	.word	0x1fff847c

000089c0 <usb_serial_flush_input>:
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    89c0:	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
    89c2:	ldr	r3, [pc, #36]	; (89e8 <usb_serial_flush_input+0x28>)
    89c4:	ldrb	r3, [r3, #0]
    89c6:	cbz	r3, 89e4 <usb_serial_flush_input+0x24>
	if (rx_packet) {
    89c8:	ldr	r4, [pc, #32]	; (89ec <usb_serial_flush_input+0x2c>)
    89ca:	ldr	r0, [r4, #0]
    89cc:	cbz	r0, 89d6 <usb_serial_flush_input+0x16>
		usb_free(rx_packet);
    89ce:	bl	8f5c <usb_free>
		rx_packet = NULL;
    89d2:	movs	r3, #0
    89d4:	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    89d6:	movs	r0, #3
    89d8:	bl	8fe0 <usb_rx>
		if (!rx) break;
    89dc:	cbz	r0, 89e4 <usb_serial_flush_input+0x24>
		usb_free(rx);
    89de:	bl	8f5c <usb_free>
	}
    89e2:	b.n	89d6 <usb_serial_flush_input+0x16>
    89e4:	pop	{r4, pc}
    89e6:	nop
    89e8:	.word	0x1fff8567
    89ec:	.word	0x1fff847c

000089f0 <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    89f0:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    89f4:	ldr	r5, [pc, #196]	; (8abc <usb_serial_write+0xcc>)
	while (size > 0) {
		if (!tx_packet) {
    89f6:	ldr.w	r9, [pc, #212]	; 8acc <usb_serial_write+0xdc>
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    89fa:	movs	r3, #1
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    89fc:	mov	sl, r0
    89fe:	mov	r4, r1
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    8a00:	strb	r3, [r5, #0]
	while (size > 0) {
    8a02:	mov	r6, r1
    8a04:	mov	r7, r9
    8a06:	cmp	r6, #0
    8a08:	beq.n	8ab2 <usb_serial_write+0xc2>
		if (!tx_packet) {
    8a0a:	ldr.w	r3, [r9]
    8a0e:	cbnz	r3, 8a60 <usb_serial_write+0x70>
    8a10:	ldr.w	fp, [pc, #176]	; 8ac4 <usb_serial_write+0xd4>
    8a14:	movw	r8, #41721	; 0xa2f9
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    8a18:	ldr	r3, [pc, #164]	; (8ac0 <usb_serial_write+0xd0>)
    8a1a:	ldrb	r3, [r3, #0]
    8a1c:	and.w	r1, r3, #255	; 0xff
    8a20:	cbnz	r3, 8a26 <usb_serial_write+0x36>
					tx_noautoflush = 0;
    8a22:	strb	r1, [r5, #0]
    8a24:	b.n	8a52 <usb_serial_write+0x62>
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    8a26:	movs	r0, #4
    8a28:	bl	9018 <usb_tx_packet_count>
    8a2c:	cmp	r0, #7
    8a2e:	bhi.n	8a40 <usb_serial_write+0x50>
					tx_noautoflush = 1;
    8a30:	movs	r3, #1
    8a32:	strb	r3, [r5, #0]
					tx_packet = usb_malloc();
    8a34:	bl	8f20 <usb_malloc>
    8a38:	str	r0, [r7, #0]
					if (tx_packet) break;
    8a3a:	cbnz	r0, 8a60 <usb_serial_write+0x70>
					tx_noautoflush = 0;
    8a3c:	ldr	r3, [pc, #124]	; (8abc <usb_serial_write+0xcc>)
    8a3e:	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    8a40:	subs.w	r8, r8, #1
    8a44:	beq.n	8a4c <usb_serial_write+0x5c>
    8a46:	ldrb.w	r3, [fp]
    8a4a:	cbz	r3, 8a5a <usb_serial_write+0x6a>
					transmit_previous_timeout = 1;
    8a4c:	ldr	r3, [pc, #116]	; (8ac4 <usb_serial_write+0xd4>)
    8a4e:	movs	r2, #1
    8a50:	strb	r2, [r3, #0]
					return -1;
    8a52:	mov.w	r0, #4294967295
    8a56:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				}
				yield();
    8a5a:	bl	97ec <yield>
			}
    8a5e:	b.n	8a18 <usb_serial_write+0x28>
		}
		transmit_previous_timeout = 0;
    8a60:	ldr	r3, [pc, #96]	; (8ac4 <usb_serial_write+0xd4>)
    8a62:	movs	r1, #0
    8a64:	strb	r1, [r3, #0]
		len = CDC_TX_SIZE - tx_packet->index;
    8a66:	ldr	r1, [r7, #0]
    8a68:	ldrh	r3, [r1, #2]
    8a6a:	rsb	r0, r3, #64	; 0x40
    8a6e:	cmp	r0, r6
    8a70:	it	cs
    8a72:	movcs	r0, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    8a74:	add.w	lr, r3, r0
    8a78:	add	r3, r1
    8a7a:	strh.w	lr, [r1, #2]
		size -= len;
    8a7e:	subs	r6, r6, r0
    8a80:	adds	r3, #7
    8a82:	add.w	r8, sl, r0
		while (len-- > 0) *dest++ = *src++;
    8a86:	cmp	sl, r8
    8a88:	beq.n	8a94 <usb_serial_write+0xa4>
    8a8a:	ldrb.w	r0, [sl], #1
    8a8e:	strb.w	r0, [r3, #1]!
    8a92:	b.n	8a86 <usb_serial_write+0x96>
		if (tx_packet->index >= CDC_TX_SIZE) {
    8a94:	ldrh	r3, [r1, #2]
    8a96:	cmp	r3, #63	; 0x3f
    8a98:	bls.n	8aa8 <usb_serial_write+0xb8>
			tx_packet->len = CDC_TX_SIZE;
    8a9a:	movs	r3, #64	; 0x40
    8a9c:	strh	r3, [r1, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    8a9e:	movs	r0, #4
    8aa0:	bl	90b4 <usb_tx>
			tx_packet = NULL;
    8aa4:	movs	r3, #0
    8aa6:	str	r3, [r7, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    8aa8:	ldr	r3, [pc, #28]	; (8ac8 <usb_serial_write+0xd8>)
    8aaa:	movs	r2, #5
    8aac:	strb	r2, [r3, #0]
    8aae:	mov	sl, r8
    8ab0:	b.n	8a06 <usb_serial_write+0x16>
	}
	tx_noautoflush = 0;
    8ab2:	strb	r6, [r5, #0]
	return ret;
    8ab4:	mov	r0, r4
}
    8ab6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8aba:	nop
    8abc:	.word	0x1fff8471
    8ac0:	.word	0x1fff8567
    8ac4:	.word	0x1fff8478
    8ac8:	.word	0x1fff8470
    8acc:	.word	0x1fff8474

00008ad0 <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    8ad0:	push	{r0, r1, r2, lr}
    8ad2:	add	r3, sp, #8
	return usb_serial_write(&c, 1);
    8ad4:	movs	r1, #1
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    8ad6:	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    8ada:	mov	r0, r3
    8adc:	bl	89f0 <usb_serial_write>
}
    8ae0:	add	sp, #12
    8ae2:	ldr.w	pc, [sp], #4
    8ae6:	Address 0x00008ae6 is out of bounds.


00008ae8 <usb_serial_write_buffer_free>:
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    8ae8:	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
    8aea:	ldr	r4, [pc, #56]	; (8b24 <usb_serial_write_buffer_free+0x3c>)
	if (!tx_packet) {
    8aec:	ldr	r5, [pc, #56]	; (8b28 <usb_serial_write_buffer_free+0x40>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    8aee:	movs	r3, #1
    8af0:	strb	r3, [r4, #0]
	if (!tx_packet) {
    8af2:	ldr	r3, [r5, #0]
    8af4:	cbnz	r3, 8b16 <usb_serial_write_buffer_free+0x2e>
		if (!usb_configuration ||
    8af6:	ldr	r3, [pc, #52]	; (8b2c <usb_serial_write_buffer_free+0x44>)
    8af8:	ldrb	r3, [r3, #0]
    8afa:	cbnz	r3, 8b02 <usb_serial_write_buffer_free+0x1a>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    8afc:	movs	r0, #0
    8afe:	strb	r0, [r4, #0]
			return 0;
    8b00:	pop	{r3, r4, r5, pc}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    8b02:	movs	r0, #4
    8b04:	bl	9018 <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    8b08:	cmp	r0, #7
    8b0a:	bhi.n	8afc <usb_serial_write_buffer_free+0x14>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    8b0c:	bl	8f20 <usb_malloc>
    8b10:	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    8b12:	cmp	r0, #0
    8b14:	beq.n	8afc <usb_serial_write_buffer_free+0x14>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    8b16:	ldr	r3, [r5, #0]
    8b18:	ldrh	r0, [r3, #2]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    8b1a:	movs	r3, #0
    8b1c:	strb	r3, [r4, #0]
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    8b1e:	rsb	r0, r0, #64	; 0x40
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    8b22:	pop	{r3, r4, r5, pc}
    8b24:	.word	0x1fff8471
    8b28:	.word	0x1fff8474
    8b2c:	.word	0x1fff8567

00008b30 <usb_serial_flush_output>:

void usb_serial_flush_output(void)
{
    8b30:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!usb_configuration) return;
    8b34:	ldr	r3, [pc, #68]	; (8b7c <usb_serial_flush_output+0x4c>)
    8b36:	ldrb	r3, [r3, #0]
    8b38:	cbz	r3, 8b78 <usb_serial_flush_output+0x48>
	tx_noautoflush = 1;
	if (tx_packet) {
    8b3a:	ldr	r7, [pc, #68]	; (8b80 <usb_serial_flush_output+0x50>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    8b3c:	ldr	r3, [pc, #68]	; (8b84 <usb_serial_flush_output+0x54>)
	if (tx_packet) {
    8b3e:	ldr	r4, [r7, #0]
    8b40:	ldr	r5, [pc, #68]	; (8b88 <usb_serial_flush_output+0x58>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    8b42:	movs	r6, #1
    8b44:	strb	r6, [r3, #0]
    8b46:	mov	r8, r3
	if (tx_packet) {
    8b48:	cbz	r4, 8b5e <usb_serial_flush_output+0x2e>
		usb_cdc_transmit_flush_timer = 0;
    8b4a:	movs	r6, #0
		tx_packet->len = tx_packet->index;
    8b4c:	ldrh	r3, [r4, #2]
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    8b4e:	strb	r6, [r5, #0]
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    8b50:	mov	r1, r4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    8b52:	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    8b54:	movs	r0, #4
    8b56:	bl	90b4 <usb_tx>
		tx_packet = NULL;
    8b5a:	str	r6, [r7, #0]
    8b5c:	b.n	8b72 <usb_serial_flush_output+0x42>
	} else {
		usb_packet_t *tx = usb_malloc();
    8b5e:	bl	8f20 <usb_malloc>
		if (tx) {
    8b62:	mov	r1, r0
    8b64:	cbz	r0, 8b70 <usb_serial_flush_output+0x40>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    8b66:	movs	r0, #4
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    8b68:	strb	r4, [r5, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    8b6a:	bl	90b4 <usb_tx>
    8b6e:	b.n	8b72 <usb_serial_flush_output+0x42>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    8b70:	strb	r6, [r5, #0]
		}
	}
	tx_noautoflush = 0;
    8b72:	movs	r3, #0
    8b74:	strb.w	r3, [r8]
    8b78:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8b7c:	.word	0x1fff8567
    8b80:	.word	0x1fff8474
    8b84:	.word	0x1fff8471
    8b88:	.word	0x1fff8470

00008b8c <usb_serial_flush_callback>:
}

void usb_serial_flush_callback(void)
{
    8b8c:	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
    8b8e:	ldr	r3, [pc, #56]	; (8bc8 <usb_serial_flush_callback+0x3c>)
    8b90:	ldrb	r3, [r3, #0]
    8b92:	and.w	r5, r3, #255	; 0xff
    8b96:	cbnz	r3, 8bc4 <usb_serial_flush_callback+0x38>
	if (tx_packet) {
    8b98:	ldr	r4, [pc, #48]	; (8bcc <usb_serial_flush_callback+0x40>)
    8b9a:	ldr	r1, [r4, #0]
    8b9c:	cbz	r1, 8bac <usb_serial_flush_callback+0x20>
		tx_packet->len = tx_packet->index;
    8b9e:	ldrh	r3, [r1, #2]
    8ba0:	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    8ba2:	movs	r0, #4
    8ba4:	bl	90b4 <usb_tx>
		tx_packet = NULL;
    8ba8:	str	r5, [r4, #0]
    8baa:	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
    8bac:	bl	8f20 <usb_malloc>
		if (tx) {
    8bb0:	mov	r1, r0
    8bb2:	cbz	r0, 8bbe <usb_serial_flush_callback+0x32>
			usb_tx(CDC_TX_ENDPOINT, tx);
    8bb4:	movs	r0, #4
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    8bb6:	ldmia.w	sp!, {r3, r4, r5, lr}
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
    8bba:	b.w	90b4 <usb_tx>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    8bbe:	ldr	r3, [pc, #16]	; (8bd0 <usb_serial_flush_callback+0x44>)
    8bc0:	movs	r2, #1
    8bc2:	strb	r2, [r3, #0]
    8bc4:	pop	{r3, r4, r5, pc}
    8bc6:	nop
    8bc8:	.word	0x1fff8471
    8bcc:	.word	0x1fff8474
    8bd0:	.word	0x1fff8470

00008bd4 <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    8bd4:	push	{r4, lr}
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    8bd6:	ldr	r3, [pc, #128]	; (8c58 <analog_init+0x84>)
    8bd8:	ldr	r0, [pc, #128]	; (8c5c <analog_init+0x88>)
    8bda:	ldr	r1, [pc, #132]	; (8c60 <analog_init+0x8c>)
    8bdc:	movs	r2, #96	; 0x60
    8bde:	strb	r2, [r3, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    8be0:	movs	r2, #225	; 0xe1
    8be2:	strb	r2, [r3, #1]
	#endif

	if (analog_config_bits == 8) {
    8be4:	ldr	r3, [pc, #124]	; (8c64 <analog_init+0x90>)
    8be6:	ldr	r2, [pc, #128]	; (8c68 <analog_init+0x94>)
    8be8:	ldrb	r4, [r3, #0]
    8bea:	ldr	r3, [pc, #128]	; (8c6c <analog_init+0x98>)
    8bec:	cmp	r4, #8
    8bee:	bne.n	8bf4 <analog_init+0x20>
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    8bf0:	movs	r4, #1
    8bf2:	b.n	8bfa <analog_init+0x26>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    8bf4:	cmp	r4, #10
    8bf6:	bne.n	8c00 <analog_init+0x2c>
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    8bf8:	movs	r4, #57	; 0x39
    8bfa:	str	r4, [r0, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    8bfc:	movs	r0, #19
    8bfe:	b.n	8c0c <analog_init+0x38>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    8c00:	cmp	r4, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    8c02:	ite	eq
    8c04:	moveq	r4, #53	; 0x35
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    8c06:	movne	r4, #61	; 0x3d
    8c08:	str	r4, [r0, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    8c0a:	movs	r0, #18
    8c0c:	str	r0, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    8c0e:	str	r4, [r2, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    8c10:	str	r0, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    8c12:	ldr	r3, [pc, #92]	; (8c70 <analog_init+0x9c>)
    8c14:	ldr	r1, [pc, #92]	; (8c74 <analog_init+0xa0>)
    8c16:	ldrb	r3, [r3, #0]
    8c18:	ldr	r2, [pc, #92]	; (8c78 <analog_init+0xa4>)
    8c1a:	cbz	r3, 8c1e <analog_init+0x4a>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    8c1c:	movs	r3, #1
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    8c1e:	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    8c20:	str	r3, [r2, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    8c22:	ldr	r3, [pc, #88]	; (8c7c <analog_init+0xa8>)
    8c24:	ldr	r2, [pc, #88]	; (8c80 <analog_init+0xac>)
    8c26:	ldrb	r1, [r3, #0]
    8c28:	ldr	r3, [pc, #88]	; (8c84 <analog_init+0xb0>)
	if (num <= 1) {
    8c2a:	cmp	r1, #1
    8c2c:	bhi.n	8c32 <analog_init+0x5e>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    8c2e:	movs	r1, #128	; 0x80
    8c30:	b.n	8c4a <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    8c32:	cmp	r1, #4
    8c34:	bhi.n	8c3a <analog_init+0x66>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    8c36:	movs	r1, #132	; 0x84
    8c38:	b.n	8c4a <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    8c3a:	cmp	r1, #8
    8c3c:	bhi.n	8c42 <analog_init+0x6e>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    8c3e:	movs	r1, #133	; 0x85
    8c40:	b.n	8c4a <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    8c42:	cmp	r1, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    8c44:	ite	ls
    8c46:	movls	r1, #134	; 0x86
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    8c48:	movhi	r1, #135	; 0x87
    8c4a:	str	r1, [r2, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    8c4c:	str	r1, [r3, #0]
		#endif
	}
	calibrating = 1;
    8c4e:	ldr	r3, [pc, #56]	; (8c88 <analog_init+0xb4>)
    8c50:	movs	r2, #1
    8c52:	strb	r2, [r3, #0]
    8c54:	pop	{r4, pc}
    8c56:	nop
    8c58:	.word	0x40074000
    8c5c:	.word	0x4003b008
    8c60:	.word	0x4003b00c
    8c64:	.word	0x1fff1359
    8c68:	.word	0x400bb008
    8c6c:	.word	0x400bb00c
    8c70:	.word	0x1fff8482
    8c74:	.word	0x4003b020
    8c78:	.word	0x400bb020
    8c7c:	.word	0x1fff135a
    8c80:	.word	0x4003b024
    8c84:	.word	0x400bb024
    8c88:	.word	0x1fff8481

00008c8c <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
    8c8c:	push	{r3, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    8c8e:	ldr	r5, [pc, #44]	; (8cbc <fault_isr+0x30>)
    8c90:	mov	r4, r5
    8c92:	ldr	r3, [r5, #0]
    8c94:	lsls	r0, r3, #13
    8c96:	bpl.n	8c9c <fault_isr+0x10>
    8c98:	bl	9134 <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    8c9c:	ldr	r3, [r4, #0]
    8c9e:	lsls	r1, r3, #21
    8ca0:	bpl.n	8ca6 <fault_isr+0x1a>
    8ca2:	bl	8cc0 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    8ca6:	ldr	r3, [r4, #0]
    8ca8:	lsls	r2, r3, #20
    8caa:	bpl.n	8cb0 <fault_isr+0x24>
    8cac:	bl	8cc0 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    8cb0:	ldr	r3, [r4, #0]
    8cb2:	lsls	r3, r3, #19
    8cb4:	bpl.n	8c92 <fault_isr+0x6>
    8cb6:	bl	8cc0 <unused_isr>
    8cba:	b.n	8c92 <fault_isr+0x6>
    8cbc:	.word	0x40048034

00008cc0 <unused_isr>:
	}
}

void unused_isr(void)
{
    8cc0:	push	{r3, lr}
	fault_isr();
    8cc2:	bl	8c8c <fault_isr>
    8cc6:	Address 0x00008cc6 is out of bounds.


00008cc8 <startup_early_hook>:
extern void rtc_set(unsigned long t);


static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    8cc8:	ldr	r3, [pc, #4]	; (8cd0 <startup_early_hook+0x8>)
    8cca:	movs	r2, #16
    8ccc:	strh	r2, [r3, #0]
    8cce:	bx	lr
    8cd0:	.word	0x40052000

00008cd4 <startup_late_hook>:
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
#endif
}
static void startup_default_late_hook(void) {}
    8cd4:	bx	lr
    8cd6:	Address 0x00008cd6 is out of bounds.


00008cd8 <_sbrk>:

void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
    8cd8:	ldr	r1, [pc, #36]	; (8d00 <_sbrk+0x28>)

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
    8cda:	push	{r3, lr}
	char *prev, *stack;

	prev = __brkval;
    8cdc:	ldr	r3, [r1, #0]
	if (incr != 0) {
    8cde:	cbz	r0, 8cfc <_sbrk+0x24>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    8ce0:	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
    8ce2:	add	r0, r3
    8ce4:	sub.w	r2, r2, #8192	; 0x2000
    8ce8:	cmp	r0, r2
    8cea:	bcc.n	8cfa <_sbrk+0x22>
			errno = ENOMEM;
    8cec:	bl	aa24 <__errno>
    8cf0:	movs	r3, #12
    8cf2:	str	r3, [r0, #0]
			return (void *)-1;
    8cf4:	mov.w	r0, #4294967295
    8cf8:	pop	{r3, pc}
		}
		__brkval = prev + incr;
    8cfa:	str	r0, [r1, #0]
	}
	return prev;
    8cfc:	mov	r0, r3
}
    8cfe:	pop	{r3, pc}
    8d00:	.word	0x1fff135c

00008d04 <__cxa_pure_virtual>:
	while (1);
}

__attribute__((weak)) 
void __cxa_pure_virtual()
{
    8d04:	b.n	8d04 <__cxa_pure_virtual>
    8d06:	Address 0x00008d06 is out of bounds.


00008d08 <attachInterruptVector>:
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    8d08:	adds	r0, #16
    8d0a:	ldr	r3, [pc, #8]	; (8d14 <attachInterruptVector+0xc>)
    8d0c:	str.w	r1, [r3, r0, lsl #2]
    8d10:	bx	lr
    8d12:	nop
    8d14:	.word	0x1fff0a00

00008d18 <rtc_get>:

#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)

unsigned long rtc_get(void)
{
	return RTC_TSR;
    8d18:	ldr	r3, [pc, #4]	; (8d20 <rtc_get+0x8>)
    8d1a:	ldr	r0, [r3, #0]
}
    8d1c:	bx	lr
    8d1e:	nop
    8d20:	.word	0x4003d000

00008d24 <rtc_set>:

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    8d24:	ldr	r3, [pc, #16]	; (8d38 <rtc_set+0x14>)
	RTC_TPR = 0;
    8d26:	ldr	r1, [pc, #20]	; (8d3c <rtc_set+0x18>)
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    8d28:	movs	r2, #0
    8d2a:	str	r2, [r3, #0]
	RTC_TPR = 0;
    8d2c:	str	r2, [r1, #0]
	RTC_TSR = t;
    8d2e:	ldr	r2, [pc, #16]	; (8d40 <rtc_set+0x1c>)
    8d30:	str	r0, [r2, #0]
	RTC_SR = RTC_SR_TCE;
    8d32:	movs	r2, #16
    8d34:	str	r2, [r3, #0]
    8d36:	bx	lr
    8d38:	.word	0x4003d014
    8d3c:	.word	0x4003d004
    8d40:	.word	0x4003d000

00008d44 <startup_middle_hook>:
}
#endif

extern void usb_init(void);

static void startup_default_middle_hook(void) {}
    8d44:	bx	lr
    8d46:	Address 0x00008d46 is out of bounds.


00008d48 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    8d48:	cmp	r0, #63	; 0x3f
}



void pinMode(uint8_t pin, uint8_t mode)
{
    8d4a:	push	{r4, lr}
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    8d4c:	bhi.n	8da6 <pinMode+0x5e>
	config = portConfigRegister(pin);
    8d4e:	ldr	r2, [pc, #88]	; (8da8 <pinMode+0x60>)
    8d50:	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    8d54:	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    8d56:	ldr	r3, [r3, #4]
    8d58:	mov	r4, r2

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    8d5a:	beq.n	8d60 <pinMode+0x18>
    8d5c:	cmp	r1, #4
    8d5e:	bne.n	8d80 <pinMode+0x38>
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    8d60:	ldr.w	r2, [r4, r0, lsl #3]
    8d64:	movs	r0, #1
    8d66:	strb.w	r0, [r2, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    8d6a:	mov.w	r2, #324	; 0x144
    8d6e:	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    8d70:	ldr	r2, [r3, #0]
		*portModeRegister(pin) = 1;
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
		if (mode == OUTPUT_OPENDRAIN) {
    8d72:	cmp	r1, #4
		    *config |= PORT_PCR_ODE;
    8d74:	ite	eq
    8d76:	orreq.w	r2, r2, #32
		} else {
		    *config &= ~PORT_PCR_ODE;
    8d7a:	bicne.w	r2, r2, #32
    8d7e:	b.n	8da4 <pinMode+0x5c>
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    8d80:	ldr.w	r0, [r2, r0, lsl #3]
    8d84:	movs	r2, #0
    8d86:	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    8d8a:	cbnz	r1, 8d92 <pinMode+0x4a>
			*config = PORT_PCR_MUX(1);
    8d8c:	mov.w	r2, #256	; 0x100
    8d90:	b.n	8da4 <pinMode+0x5c>
		} else if (mode == INPUT_PULLUP) {
    8d92:	cmp	r1, #2
    8d94:	bne.n	8d9c <pinMode+0x54>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    8d96:	movw	r2, #259	; 0x103
    8d9a:	b.n	8da4 <pinMode+0x5c>
		} else if (mode == INPUT_PULLDOWN) {
    8d9c:	cmp	r1, #3
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    8d9e:	it	eq
    8da0:	moveq.w	r2, #258	; 0x102
		} else { // INPUT_DISABLE
			*config = 0;
    8da4:	str	r2, [r3, #0]
    8da6:	pop	{r4, pc}
    8da8:	.word	0x00012660

00008dac <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    8dac:	cpsid	i
	current = SYST_CVR;
    8dae:	ldr	r3, [pc, #44]	; (8ddc <micros+0x30>)
	count = systick_millis_count;
    8db0:	ldr	r2, [pc, #44]	; (8de0 <micros+0x34>)
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    8db2:	ldr	r1, [pc, #48]	; (8de4 <micros+0x38>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    8db4:	ldr	r3, [r3, #0]
	count = systick_millis_count;
    8db6:	ldr	r2, [r2, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    8db8:	ldr	r1, [r1, #0]
	__enable_irq();
    8dba:	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    8dbc:	lsls	r1, r1, #5
    8dbe:	bpl.n	8dc6 <micros+0x1a>
    8dc0:	cmp	r3, #50	; 0x32
    8dc2:	it	hi
    8dc4:	addhi	r2, #1
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    8dc6:	rsb	r3, r3, #95744	; 0x17600
    8dca:	movs	r0, #96	; 0x60
    8dcc:	adds	r3, #255	; 0xff
    8dce:	udiv	r3, r3, r0
}
    8dd2:	mov.w	r0, #1000	; 0x3e8
    8dd6:	mla	r0, r0, r2, r3
    8dda:	bx	lr
    8ddc:	.word	0xe000e018
    8de0:	.word	0x1fff8484
    8de4:	.word	0xe000ed04

00008de8 <delay>:

void delay(uint32_t ms)
{
    8de8:	push	{r3, r4, r5, lr}
    8dea:	mov	r4, r0
	uint32_t start = micros();
    8dec:	bl	8dac <micros>
    8df0:	mov	r5, r0

	if (ms > 0) {
    8df2:	cbnz	r4, 8dfe <delay+0x16>
    8df4:	pop	{r3, r4, r5, pc}
		while (1) {
			while ((micros() - start) >= 1000) {
				ms--;
				if (ms == 0) return;
    8df6:	subs	r4, #1
    8df8:	beq.n	8e10 <delay+0x28>
				start += 1000;
    8dfa:	add.w	r5, r5, #1000	; 0x3e8
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    8dfe:	bl	8dac <micros>
    8e02:	subs	r0, r0, r5
    8e04:	cmp.w	r0, #1000	; 0x3e8
    8e08:	bcs.n	8df6 <delay+0xe>
				ms--;
				if (ms == 0) return;
				start += 1000;
			}
			yield();
    8e0a:	bl	97ec <yield>
		}
    8e0e:	b.n	8dfe <delay+0x16>
    8e10:	pop	{r3, r4, r5, pc}
    8e12:	Address 0x00008e12 is out of bounds.


00008e14 <_init_Teensyduino_internal_>:
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    8e14:	ldr	r3, [pc, #224]	; (8ef8 <_init_Teensyduino_internal_+0xe4>)
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    8e16:	ldr	r1, [pc, #228]	; (8efc <_init_Teensyduino_internal_+0xe8>)
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    8e18:	mov.w	r2, #134217728	; 0x8000000
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    8e1c:	push	{r4, r5, r6, lr}
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    8e1e:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    8e20:	mov.w	r2, #268435456	; 0x10000000
    8e24:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    8e26:	mov.w	r2, #536870912	; 0x20000000
    8e2a:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    8e2c:	mov.w	r2, #1073741824	; 0x40000000
    8e30:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    8e32:	mov.w	r2, #2147483648	; 0x80000000
    8e36:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    8e38:	ldr	r3, [pc, #196]	; (8f00 <_init_Teensyduino_internal_+0xec>)
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    8e3a:	ldr	r5, [pc, #200]	; (8f04 <_init_Teensyduino_internal_+0xf0>)
	FTM3_C1SC = 0x28;
    8e3c:	ldr	r4, [pc, #200]	; (8f08 <_init_Teensyduino_internal_+0xf4>)
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    8e3e:	ldr	r6, [pc, #204]	; (8f0c <_init_Teensyduino_internal_+0xf8>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    8e40:	movs	r2, #0
	FTM0_MOD = DEFAULT_FTM_MOD;
    8e42:	movw	r0, #49151	; 0xbfff
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    8e46:	str	r2, [r3, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
    8e48:	str	r0, [r3, #4]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    8e4a:	movs	r3, #40	; 0x28
    8e4c:	str	r3, [r1, #0]
	FTM0_C1SC = 0x28;
    8e4e:	str	r3, [r1, #8]
	FTM0_C2SC = 0x28;
    8e50:	str	r3, [r1, #16]
	FTM0_C3SC = 0x28;
    8e52:	str	r3, [r1, #24]
	FTM0_C4SC = 0x28;
    8e54:	str	r3, [r1, #32]
	FTM0_C5SC = 0x28;
    8e56:	str	r3, [r1, #40]	; 0x28
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    8e58:	str	r3, [r1, #48]	; 0x30
	FTM0_C7SC = 0x28;
    8e5a:	str	r3, [r1, #56]	; 0x38
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
    8e5c:	adds	r1, #16
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    8e5e:	add.w	r1, r1, #528384	; 0x81000
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    8e62:	str	r3, [r5, #0]
	FTM3_C1SC = 0x28;
    8e64:	str	r3, [r4, #0]
	FTM3_C2SC = 0x28;
    8e66:	str	r3, [r1, #0]
	FTM3_C3SC = 0x28;
    8e68:	str	r3, [r1, #8]
	FTM3_C4SC = 0x28;
    8e6a:	str	r3, [r1, #16]
	FTM3_C5SC = 0x28;
    8e6c:	str	r3, [r1, #24]
	FTM3_C6SC = 0x28;
    8e6e:	str	r3, [r1, #32]
	FTM3_C7SC = 0x28;
    8e70:	str	r3, [r1, #40]	; 0x28
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    8e72:	movs	r1, #9
    8e74:	str	r1, [r6, #0]
	FTM1_CNT = 0;
    8e76:	add.w	r6, r6, #4096	; 0x1000
    8e7a:	adds	r6, #4
    8e7c:	str	r2, [r6, #0]
	FTM1_MOD = DEFAULT_FTM_MOD;
    8e7e:	str	r0, [r6, #4]
	FTM1_C0SC = 0x28;
    8e80:	str	r3, [r6, #8]
	FTM1_C1SC = 0x28;
    8e82:	str	r3, [r6, #16]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    8e84:	str.w	r1, [r6, #-4]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    8e88:	add.w	r6, r6, #520192	; 0x7f000
    8e8c:	str	r2, [r6, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    8e8e:	str	r0, [r6, #4]
	FTM2_C0SC = 0x28;
    8e90:	str	r3, [r6, #8]
	FTM2_C1SC = 0x28;
    8e92:	str	r3, [r6, #16]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    8e94:	str.w	r1, [r6, #-4]
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
    8e98:	add.w	r6, r6, #4096	; 0x1000
    8e9c:	str	r2, [r6, #0]
	FTM3_MOD = DEFAULT_FTM_MOD;
    8e9e:	str	r0, [r6, #4]
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    8ea0:	ldr	r0, [pc, #108]	; (8f10 <_init_Teensyduino_internal_+0xfc>)
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
	FTM3_C0SC = 0x28;
    8ea2:	str	r3, [r5, #0]
	FTM3_C1SC = 0x28;
    8ea4:	str	r3, [r4, #0]
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    8ea6:	str	r1, [r0, #0]
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    8ea8:	sub.w	r0, r0, #460800	; 0x70800
    8eac:	subw	r0, r0, #2004	; 0x7d4
    8eb0:	ldr	r1, [r0, #0]
    8eb2:	orr.w	r1, r1, #512	; 0x200
    8eb6:	str	r1, [r0, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    8eb8:	ldr.w	r1, [r0, #-40]
    8ebc:	orr.w	r1, r1, #33554432	; 0x2000000
    8ec0:	str.w	r1, [r0, #-40]
	TPM1_CNT = 0;
    8ec4:	ldr	r1, [pc, #76]	; (8f14 <_init_Teensyduino_internal_+0x100>)
    8ec6:	str	r2, [r1, #0]
	TPM1_MOD = 32767;
    8ec8:	ldr	r2, [pc, #76]	; (8f18 <_init_Teensyduino_internal_+0x104>)
    8eca:	movw	r1, #32767	; 0x7fff
    8ece:	str	r1, [r2, #0]
	TPM1_C0SC = 0x28;
    8ed0:	str	r3, [r2, #4]
	TPM1_C1SC = 0x28;
    8ed2:	str	r3, [r2, #12]
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    8ed4:	ldr	r3, [pc, #68]	; (8f1c <_init_Teensyduino_internal_+0x108>)
    8ed6:	movs	r2, #8
    8ed8:	str	r2, [r3, #0]
#endif
	analog_init();
    8eda:	bl	8bd4 <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	startup_middle_hook();
    8ede:	bl	8d44 <startup_middle_hook>
	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    8ee2:	movs	r0, #20
    8ee4:	bl	8de8 <delay>
	usb_init();
    8ee8:	bl	9758 <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    8eec:	mov.w	r0, #280	; 0x118
}
    8ef0:	ldmia.w	sp!, {r4, r5, r6, lr}
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	startup_middle_hook();
	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    8ef4:	b.w	8de8 <delay>
    8ef8:	.word	0xe000e104
    8efc:	.word	0x4003800c
    8f00:	.word	0x40038004
    8f04:	.word	0x400b900c
    8f08:	.word	0x400b9014
    8f0c:	.word	0x40038000
    8f10:	.word	0x400b9000
    8f14:	.word	0x400c9004
    8f18:	.word	0x400c9008
    8f1c:	.word	0x400c9000

00008f20 <usb_malloc>:
// http://www.archivum.info/gnu.gcc.help/2006-08/00148/Re-GCC-Inline-Assembly.html
// http://gcc.gnu.org/ml/gcc/2012-06/msg00015.html
// __builtin_clz()

usb_packet_t * usb_malloc(void)
{
    8f20:	push	{r4, lr}
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    8f22:	cpsid	i
	avail = usb_buffer_available;
    8f24:	ldr	r0, [pc, #44]	; (8f54 <usb_malloc+0x34>)
    8f26:	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    8f28:	clz	r1, r2
	if (n >= NUM_USB_BUFFERS) {
    8f2c:	cmp	r1, #11
    8f2e:	ble.n	8f36 <usb_malloc+0x16>
		__enable_irq();
    8f30:	cpsie	i
		return NULL;
    8f32:	movs	r0, #0
    8f34:	pop	{r4, pc}
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    8f36:	mov.w	r3, #2147483648	; 0x80000000
    8f3a:	lsrs	r3, r1
    8f3c:	bic.w	r2, r2, r3
    8f40:	str	r2, [r0, #0]
	__enable_irq();
    8f42:	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    8f44:	ldr	r4, [pc, #16]	; (8f58 <usb_malloc+0x38>)
    8f46:	movs	r3, #72	; 0x48
    8f48:	muls	r3, r1
    8f4a:	adds	r0, r4, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    8f4c:	movs	r2, #0
    8f4e:	str	r2, [r4, r3]
	*(uint32_t *)(p + 4) = 0;
    8f50:	str	r2, [r0, #4]
	return (usb_packet_t *)p;
}
    8f52:	pop	{r4, pc}
    8f54:	.word	0x1fff1360
    8f58:	.word	0x1fff0bd0

00008f5c <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    8f5c:	ldr	r3, [pc, #48]	; (8f90 <usb_free+0x34>)
    8f5e:	movs	r2, #72	; 0x48
    8f60:	subs	r3, r0, r3
    8f62:	udiv	r3, r3, r2
	if (n >= NUM_USB_BUFFERS) return;
    8f66:	cmp	r3, #11
    8f68:	bhi.n	8f8e <usb_free+0x32>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    8f6a:	ldr	r2, [pc, #40]	; (8f94 <usb_free+0x38>)
    8f6c:	ldrb	r2, [r2, #0]
    8f6e:	cbz	r2, 8f7a <usb_free+0x1e>
    8f70:	ldr	r2, [pc, #36]	; (8f98 <usb_free+0x3c>)
    8f72:	ldrb	r2, [r2, #0]
    8f74:	cbz	r2, 8f7a <usb_free+0x1e>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    8f76:	b.w	903c <usb_rx_memory>
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    8f7a:	cpsid	i
	usb_buffer_available |= mask;
    8f7c:	ldr	r1, [pc, #28]	; (8f9c <usb_free+0x40>)
    8f7e:	mov.w	r2, #2147483648	; 0x80000000
    8f82:	lsr.w	r3, r2, r3
    8f86:	ldr	r2, [r1, #0]
    8f88:	orrs	r2, r3
    8f8a:	str	r2, [r1, #0]
	__enable_irq();
    8f8c:	cpsie	i
    8f8e:	bx	lr
    8f90:	.word	0x1fff0bd0
    8f94:	.word	0x1fff855e
    8f98:	.word	0x1fff8567
    8f9c:	.word	0x1fff1360

00008fa0 <endpoint0_transmit>:
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
}


static void endpoint0_transmit(const void *data, uint32_t len)
{
    8fa0:	push	{r4, r5, r6, r7, lr}
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    8fa2:	ldr	r4, [pc, #48]	; (8fd4 <endpoint0_transmit+0x34>)
    8fa4:	ldr	r6, [pc, #48]	; (8fd8 <endpoint0_transmit+0x38>)
    8fa6:	ldrb	r3, [r4, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    8fa8:	ldr	r5, [pc, #48]	; (8fdc <endpoint0_transmit+0x3c>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    8faa:	orr.w	r7, r3, #2
    8fae:	add.w	r2, r6, r7, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    8fb2:	eor.w	r3, r3, #1
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    8fb6:	str	r0, [r2, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    8fb8:	ldrb	r2, [r5, #0]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    8fba:	strb	r3, [r4, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    8fbc:	cmp	r2, #0
    8fbe:	ite	ne
    8fc0:	movne	r0, #200	; 0xc8
    8fc2:	moveq	r0, #136	; 0x88
	ep0_tx_data_toggle ^= 1;
    8fc4:	eor.w	r2, r2, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    8fc8:	orr.w	r1, r0, r1, lsl #16
	ep0_tx_data_toggle ^= 1;
    8fcc:	strb	r2, [r5, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    8fce:	str.w	r1, [r6, r7, lsl #3]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    8fd2:	pop	{r4, r5, r6, r7, pc}
    8fd4:	.word	0x1fff84f0
    8fd8:	.word	0x1fff0000
    8fdc:	.word	0x1fff8568

00008fe0 <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    8fe0:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    8fe2:	cmp	r3, #3




usb_packet_t *usb_rx(uint32_t endpoint)
{
    8fe4:	push	{r4, lr}
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    8fe6:	bhi.n	900a <usb_rx+0x2a>
	__disable_irq();
    8fe8:	cpsid	i
	ret = rx_first[endpoint];
    8fea:	ldr	r2, [pc, #36]	; (9010 <usb_rx+0x30>)
    8fec:	ldr.w	r0, [r2, r3, lsl #2]
	if (ret) {
    8ff0:	cbz	r0, 9006 <usb_rx+0x26>
		rx_first[endpoint] = ret->next;
    8ff2:	ldr	r1, [r0, #4]
    8ff4:	str.w	r1, [r2, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    8ff8:	ldr	r1, [pc, #24]	; (9014 <usb_rx+0x34>)
    8ffa:	ldrh	r4, [r0, #0]
    8ffc:	ldrh.w	r2, [r1, r3, lsl #1]
    9000:	subs	r2, r2, r4
    9002:	strh.w	r2, [r1, r3, lsl #1]
	}
	__enable_irq();
    9006:	cpsie	i
	//serial_print("rx, epidx=");
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
    9008:	pop	{r4, pc}

usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    900a:	movs	r0, #0
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    900c:	pop	{r4, pc}
    900e:	nop
    9010:	.word	0x1fff84e0
    9014:	.word	0x1fff85e4

00009018 <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    9018:	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    901a:	cmp	r0, #3
    901c:	bhi.n	9034 <usb_tx_packet_count+0x1c>
	__disable_irq();
    901e:	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    9020:	ldr	r3, [pc, #20]	; (9038 <usb_tx_packet_count+0x20>)
    9022:	ldr.w	r3, [r3, r0, lsl #2]
// https://forum.pjrc.com/threads/58663?p=223513&viewfull=1#post223513
//
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;
    9026:	movs	r0, #0

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    9028:	cbz	r3, 9030 <usb_tx_packet_count+0x18>
    902a:	adds	r0, #1
    902c:	ldr	r3, [r3, #4]
    902e:	b.n	9028 <usb_tx_packet_count+0x10>
	__enable_irq();
    9030:	cpsie	i
	return count;
    9032:	bx	lr
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
    9034:	movs	r0, #0
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
	__enable_irq();
	return count;
}
    9036:	bx	lr
    9038:	.word	0x1fff8534

0000903c <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    903c:	push	{r4, r5, r6}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    903e:	cpsid	i
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    9040:	ldr	r5, [pc, #92]	; (90a0 <usb_rx_memory+0x64>)
			if (table[index(i, RX, EVEN)].desc == 0) {
    9042:	ldr	r4, [pc, #96]	; (90a4 <usb_rx_memory+0x68>)
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    9044:	movs	r3, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    9046:	adds	r2, r3, r5
    9048:	ldrb.w	r2, [r2, #-1]
    904c:	lsls	r2, r2, #28
    904e:	bpl.n	908c <usb_rx_memory+0x50>
			if (table[index(i, RX, EVEN)].desc == 0) {
    9050:	lsls	r2, r3, #2
    9052:	ldr	r1, [pc, #80]	; (90a4 <usb_rx_memory+0x68>)
    9054:	ldr.w	r6, [r4, r2, lsl #3]
    9058:	cbnz	r6, 9066 <usb_rx_memory+0x2a>
				table[index(i, RX, EVEN)].addr = packet->buf;
    905a:	add.w	r3, r1, r3, lsl #5
    905e:	adds	r0, #8
    9060:	str	r0, [r3, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    9062:	ldr	r3, [pc, #68]	; (90a8 <usb_rx_memory+0x6c>)
    9064:	b.n	907a <usb_rx_memory+0x3e>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    9066:	orr.w	r2, r2, #1
    906a:	ldr.w	r6, [r4, r2, lsl #3]
    906e:	cbnz	r6, 908c <usb_rx_memory+0x50>
				table[index(i, RX, ODD)].addr = packet->buf;
    9070:	add.w	r3, r1, r2, lsl #3
    9074:	adds	r0, #8
    9076:	str	r0, [r3, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    9078:	ldr	r3, [pc, #48]	; (90ac <usb_rx_memory+0x70>)
    907a:	str.w	r3, [r1, r2, lsl #3]
				usb_rx_memory_needed--;
    907e:	ldr	r2, [pc, #48]	; (90b0 <usb_rx_memory+0x74>)
    9080:	ldrb	r3, [r2, #0]
    9082:	subs	r3, #1
    9084:	strb	r3, [r2, #0]
				__enable_irq();
    9086:	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
    9088:	pop	{r4, r5, r6}
    908a:	bx	lr
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    908c:	adds	r3, #1
    908e:	cmp	r3, #5
    9090:	bne.n	9046 <usb_rx_memory+0xa>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    9092:	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    9094:	ldr	r3, [pc, #24]	; (90b0 <usb_rx_memory+0x74>)
    9096:	movs	r2, #0
    9098:	strb	r2, [r3, #0]
	usb_free(packet);
	return;
}
    909a:	pop	{r4, r5, r6}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
    909c:	b.w	8f5c <usb_free>
    90a0:	.word	0x0001288a
    90a4:	.word	0x1fff0000
    90a8:	.word	0x00400088
    90ac:	.word	0x004000c8
    90b0:	.word	0x1fff855e

000090b4 <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    90b4:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    90b6:	cmp	r3, #3

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    90b8:	push	{r4, lr}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
    90ba:	bhi.n	9122 <usb_tx+0x6e>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    90bc:	ldr	r2, [pc, #100]	; (9124 <usb_tx+0x70>)
    90be:	lsls	r0, r0, #5
    90c0:	orr.w	r0, r0, #16
    90c4:	add	r0, r2
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    90c6:	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    90c8:	ldr	r2, [pc, #92]	; (9128 <usb_tx+0x74>)
    90ca:	ldrb	r4, [r2, r3]
    90cc:	cmp	r4, #3
    90ce:	bhi.n	90e8 <usb_tx+0x34>
    90d0:	tbb	[pc, r4]
    90d4:	.word	0x07020418
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
		next = TX_STATE_EVEN_FREE;
		break;
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    90d8:	movs	r4, #5
    90da:	b.n	9106 <usb_tx+0x52>
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    90dc:	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    90de:	movs	r4, #2
		break;
    90e0:	b.n	9106 <usb_tx+0x52>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    90e2:	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    90e4:	movs	r4, #4
		break;
    90e6:	b.n	9106 <usb_tx+0x52>
	  default:
		if (tx_first[endpoint] == NULL) {
    90e8:	ldr	r0, [pc, #64]	; (912c <usb_tx+0x78>)
    90ea:	ldr	r2, [pc, #68]	; (9130 <usb_tx+0x7c>)
    90ec:	ldr.w	r4, [r0, r3, lsl #2]
    90f0:	cbnz	r4, 90f8 <usb_tx+0x44>
			tx_first[endpoint] = packet;
    90f2:	str.w	r1, [r0, r3, lsl #2]
    90f6:	b.n	90fe <usb_tx+0x4a>
		} else {
			tx_last[endpoint]->next = packet;
    90f8:	ldr.w	r0, [r2, r3, lsl #2]
    90fc:	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    90fe:	str.w	r1, [r2, r3, lsl #2]
    9102:	b.n	9120 <usb_tx+0x6c>
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    9104:	movs	r4, #3
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    9106:	strb	r4, [r2, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9108:	tst.w	r0, #8
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    910c:	add.w	r3, r1, #8
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9110:	ldrh	r2, [r1, #0]
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    9112:	str	r3, [r0, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9114:	ite	ne
    9116:	movne	r3, #200	; 0xc8
    9118:	moveq	r3, #136	; 0x88
    911a:	orr.w	r3, r3, r2, lsl #16
    911e:	str	r3, [r0, #0]
	__enable_irq();
    9120:	cpsie	i
    9122:	pop	{r4, pc}
    9124:	.word	0x1fff0000
    9128:	.word	0x1fff849c
    912c:	.word	0x1fff8534
    9130:	.word	0x1fff8544

00009134 <usb_isr>:
}



void usb_isr(void)
{
    9134:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9138:	ldr.w	r8, [pc, #680]	; 93e4 <usb_isr+0x2b0>
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    913c:	ldr	r3, [pc, #676]	; (93e4 <usb_isr+0x2b0>)
    913e:	ldrb	r4, [r3, #0]
    9140:	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    9142:	tst.w	r4, #4
    9146:	mov	r5, r3
    9148:	beq.n	9180 <usb_isr+0x4c>
		if (usb_configuration) {
    914a:	ldr	r3, [pc, #668]	; (93e8 <usb_isr+0x2b4>)
    914c:	ldrb	r3, [r3, #0]
    914e:	cbz	r3, 917a <usb_isr+0x46>
			t = usb_reboot_timer;
    9150:	ldr	r2, [pc, #664]	; (93ec <usb_isr+0x2b8>)
    9152:	ldrb	r1, [r2, #0]
			if (t) {
    9154:	and.w	r3, r1, #255	; 0xff
    9158:	cbz	r1, 9164 <usb_isr+0x30>
				usb_reboot_timer = --t;
    915a:	subs	r3, #1
    915c:	uxtb	r3, r3
    915e:	strb	r3, [r2, #0]
				if (!t) _reboot_Teensyduino_();
    9160:	cbnz	r3, 9164 <usb_isr+0x30>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    9162:	bkpt	0x0000
			if (t) {
				usb_reboot_timer = --t;
				if (!t) _reboot_Teensyduino_();
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    9164:	ldr	r2, [pc, #648]	; (93f0 <usb_isr+0x2bc>)
    9166:	ldrb	r1, [r2, #0]
			if (t) {
    9168:	and.w	r3, r1, #255	; 0xff
    916c:	cbz	r1, 917a <usb_isr+0x46>
				usb_cdc_transmit_flush_timer = --t;
    916e:	subs	r3, #1
    9170:	uxtb	r3, r3
    9172:	strb	r3, [r2, #0]
				if (t == 0) usb_serial_flush_callback();
    9174:	cbnz	r3, 917a <usb_isr+0x46>
    9176:	bl	8b8c <usb_serial_flush_callback>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    917a:	movs	r3, #4
    917c:	strb.w	r3, [r8]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    9180:	and.w	r3, r4, #8
    9184:	and.w	r2, r3, #255	; 0xff
    9188:	cmp	r3, #0
    918a:	beq.w	9674 <usb_isr+0x540>
		uint8_t endpoint;
		stat = USB0_STAT;
    918e:	ldr	r3, [pc, #612]	; (93f4 <usb_isr+0x2c0>)
    9190:	ldr	r4, [pc, #612]	; (93f8 <usb_isr+0x2c4>)
    9192:	ldrb	r3, [r3, #0]
    9194:	uxtb	r3, r3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    9196:	lsrs	r7, r3, #4
    9198:	mov.w	r6, r3, lsr #2
    919c:	bne.w	957c <usb_isr+0x448>
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
    91a0:	ldr.w	r3, [r4, r6, lsl #3]
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    91a4:	add.w	r2, r4, r6, lsl #3
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    91a8:	ubfx	r3, r3, #2, #4
    91ac:	subs	r3, #1
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    91ae:	ldr	r2, [r2, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    91b0:	cmp	r3, #12
    91b2:	bhi.w	9574 <usb_isr+0x440>
    91b6:	tbh	[pc, r3, lsl #1]
    91ba:	.short	0x019e
    91bc:	.word	0x01dd019e
    91c0:	.word	0x01dd01dd
    91c4:	.word	0x01dd01dd
    91c8:	.word	0x01bb01dd
    91cc:	.word	0x01dd01dd
    91d0:	.word	0x000d01dd
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    91d4:	ldr	r5, [pc, #548]	; (93fc <usb_isr+0x2c8>)
		setup.word2 = *(uint32_t *)(buf + 4);
    91d6:	ldr	r3, [r2, #4]
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    91d8:	ldr	r1, [r2, #0]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    91da:	ldr	r0, [pc, #548]	; (9400 <usb_isr+0x2cc>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    91dc:	str	r3, [r5, #4]

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    91de:	ldr	r3, [pc, #548]	; (9404 <usb_isr+0x2d0>)
    91e0:	str.w	r3, [r4, r6, lsl #3]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    91e4:	movs	r3, #1
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    91e6:	str	r1, [r5, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    91e8:	ldr.w	sl, [pc, #584]	; 9434 <usb_isr+0x300>
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    91ec:	strb	r3, [r0, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    91ee:	uxth	r1, r1
    91f0:	movw	r0, #1665	; 0x681
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    91f4:	movs	r2, #0
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    91f6:	cmp	r1, r0
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    91f8:	str	r2, [r4, #16]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    91fa:	str.w	r2, [sl]
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
    91fe:	str	r2, [r4, #24]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    9200:	bhi.n	9232 <usb_isr+0xfe>
    9202:	cmp.w	r1, #1664	; 0x680
    9206:	bcs.w	945a <usb_isr+0x326>
    920a:	cmp.w	r1, #258	; 0x102
    920e:	beq.w	93c4 <usb_isr+0x290>
    9212:	bhi.n	9222 <usb_isr+0xee>
    9214:	cmp	r1, #128	; 0x80
    9216:	beq.w	939e <usb_isr+0x26a>
    921a:	cmp	r1, #130	; 0x82
    921c:	beq.w	93a6 <usb_isr+0x272>
    9220:	b.n	9494 <usb_isr+0x360>
    9222:	movw	r3, #770	; 0x302
    9226:	cmp	r1, r3
    9228:	beq.w	943c <usb_isr+0x308>
    922c:	cmp.w	r1, #1280	; 0x500
    9230:	b.n	926a <usb_isr+0x136>
    9232:	movw	r0, #8225	; 0x2021
    9236:	cmp	r1, r0
    9238:	beq.w	94f0 <usb_isr+0x3bc>
    923c:	bhi.n	925a <usb_isr+0x126>
    923e:	cmp.w	r1, #2176	; 0x880
    9242:	beq.w	9394 <usb_isr+0x260>
    9246:	cmp.w	r1, #2304	; 0x900
    924a:	bne.w	9494 <usb_isr+0x360>
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    924e:	ldr	r3, [pc, #408]	; (93e8 <usb_isr+0x2b4>)
    9250:	ldrb	r2, [r5, #2]
    9252:	strb	r2, [r3, #0]
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    9254:	movs	r6, #4
			if (table[i].desc & BDT_OWN) {
    9256:	ldr	r7, [pc, #416]	; (93f8 <usb_isr+0x2c4>)
    9258:	b.n	9270 <usb_isr+0x13c>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    925a:	movw	r3, #8737	; 0x2221
    925e:	cmp	r1, r3
    9260:	beq.w	9480 <usb_isr+0x34c>
    9264:	movw	r3, #8993	; 0x2321
    9268:	cmp	r1, r3
    926a:	beq.w	949c <usb_isr+0x368>
    926e:	b.n	9494 <usb_isr+0x360>
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    9270:	ldr.w	r3, [r4, r6, lsl #3]
    9274:	lsls	r3, r3, #24
    9276:	bpl.n	9284 <usb_isr+0x150>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    9278:	add.w	r3, r7, r6, lsl #3
    927c:	ldr	r0, [r3, #4]
    927e:	subs	r0, #8
    9280:	bl	8f5c <usb_free>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    9284:	adds	r6, #1
    9286:	cmp	r6, #20
    9288:	bne.n	9270 <usb_isr+0x13c>
    928a:	ldr	r7, [pc, #380]	; (9408 <usb_isr+0x2d4>)
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    928c:	ldr.w	fp, [pc, #380]	; 940c <usb_isr+0x2d8>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    9290:	movs	r6, #0
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    9292:	ldr.w	r0, [fp, r6, lsl #2]
    9296:	mov.w	r9, r6, lsl #2
			while (p) {
    929a:	cbz	r0, 92aa <usb_isr+0x176>
				n = p->next;
    929c:	ldr	r2, [r0, #4]
    929e:	str	r2, [sp, #0]
				usb_free(p);
    92a0:	bl	8f5c <usb_free>
				p = n;
    92a4:	ldr	r2, [sp, #0]
    92a6:	mov	r0, r2
    92a8:	b.n	929a <usb_isr+0x166>
			}
			rx_first[i] = NULL;
    92aa:	ldr	r3, [pc, #352]	; (940c <usb_isr+0x2d8>)
			rx_last[i] = NULL;
			p = tx_first[i];
    92ac:	ldr	r2, [pc, #352]	; (9410 <usb_isr+0x2dc>)
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
    92ae:	str.w	r0, [r3, r9]
			rx_last[i] = NULL;
    92b2:	ldr	r3, [pc, #352]	; (9414 <usb_isr+0x2e0>)
    92b4:	str.w	r0, [r9, r3]
			p = tx_first[i];
    92b8:	ldr.w	r0, [r9, r2]
			while (p) {
    92bc:	cbz	r0, 92d0 <usb_isr+0x19c>
				n = p->next;
    92be:	ldr	r1, [r0, #4]
    92c0:	str	r2, [sp, #4]
    92c2:	str	r1, [sp, #0]
				usb_free(p);
    92c4:	bl	8f5c <usb_free>
				p = n;
    92c8:	ldr	r1, [sp, #0]
    92ca:	ldr	r2, [sp, #4]
    92cc:	mov	r0, r1
    92ce:	b.n	92bc <usb_isr+0x188>
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    92d0:	ldr	r3, [pc, #324]	; (9418 <usb_isr+0x2e4>)
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    92d2:	str.w	r0, [r2, r9]
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    92d6:	strh.w	r0, [r3, r6, lsl #1]
			switch (tx_state[i]) {
    92da:	ldrb	r3, [r7, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    92dc:	ldr	r2, [pc, #316]	; (941c <usb_isr+0x2e8>)
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    92de:	subs	r3, #2
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    92e0:	str.w	r0, [r9, r2]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    92e4:	cmp	r3, #3
    92e6:	bhi.n	92f8 <usb_isr+0x1c4>
    92e8:	tbb	[pc, r3]
    92ec:	.word	0x04020402
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    92f0:	movs	r3, #0
    92f2:	b.n	92f6 <usb_isr+0x1c2>
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    92f4:	movs	r3, #1
    92f6:	strb	r3, [r7, #0]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    92f8:	adds	r6, #1
    92fa:	cmp	r6, #4
    92fc:	add.w	r7, r7, #1
    9300:	bne.n	9292 <usb_isr+0x15e>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    9302:	ldr	r1, [pc, #284]	; (9420 <usb_isr+0x2ec>)
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
    9304:	ldr.w	r9, [pc, #304]	; 9438 <usb_isr+0x304>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    9308:	movs	r3, #0
    930a:	strb	r3, [r1, #0]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    930c:	mov.w	fp, #1
    9310:	mov	r7, r1
    9312:	ldr	r3, [pc, #272]	; (9424 <usb_isr+0x2f0>)
			epconf = *cfg++;
    9314:	add.w	r0, fp, r9
    9318:	add	r3, fp
    931a:	ldrb.w	r0, [r0, #-1]
    931e:	lsls	r3, r3, #2
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    9320:	tst.w	r0, #8
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
			*reg = epconf;
    9324:	strb	r0, [r3, #0]
    9326:	mov.w	r6, fp, lsl #2
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    932a:	beq.n	9374 <usb_isr+0x240>
				usb_packet_t *p;
				p = usb_malloc();
    932c:	bl	8f20 <usb_malloc>
				if (p) {
    9330:	cbz	r0, 9344 <usb_isr+0x210>
					table[index(i, RX, EVEN)].addr = p->buf;
    9332:	add.w	lr, r4, fp, lsl #5
    9336:	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    9338:	ldr	r3, [pc, #236]	; (9428 <usb_isr+0x2f4>)
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
    933a:	str.w	r0, [lr, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    933e:	str.w	r3, [r4, r6, lsl #3]
    9342:	b.n	934e <usb_isr+0x21a>
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    9344:	str.w	r0, [r4, r6, lsl #3]
					usb_rx_memory_needed++;
    9348:	ldrb	r0, [r7, #0]
    934a:	adds	r0, #1
    934c:	strb	r0, [r7, #0]
				}
				p = usb_malloc();
    934e:	bl	8f20 <usb_malloc>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    9352:	orr.w	lr, r6, #1
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
    9356:	cbz	r0, 936a <usb_isr+0x236>
					table[index(i, RX, ODD)].addr = p->buf;
    9358:	add.w	ip, r4, lr, lsl #3
    935c:	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    935e:	ldr	r3, [pc, #164]	; (9404 <usb_isr+0x2d0>)
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    9360:	str.w	r0, [ip, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    9364:	str.w	r3, [r4, lr, lsl #3]
    9368:	b.n	9374 <usb_isr+0x240>
				} else {
					table[index(i, RX, ODD)].desc = 0;
    936a:	str.w	r0, [r4, lr, lsl #3]
					usb_rx_memory_needed++;
    936e:	ldrb	r0, [r7, #0]
    9370:	adds	r0, #1
    9372:	strb	r0, [r7, #0]
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    9374:	orr.w	lr, r6, #2
			table[index(i, TX, ODD)].desc = 0;
    9378:	orr.w	r3, r6, #3
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    937c:	add.w	fp, fp, #1
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    9380:	movs	r0, #0
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    9382:	cmp.w	fp, #5
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    9386:	str.w	r0, [r4, lr, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
    938a:	str.w	r0, [r4, r3, lsl #3]
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    938e:	bne.n	9312 <usb_isr+0x1de>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    9390:	mov	r3, r0
    9392:	b.n	94a6 <usb_isr+0x372>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    9394:	ldr	r2, [pc, #80]	; (93e8 <usb_isr+0x2b4>)
    9396:	ldr	r6, [pc, #148]	; (942c <usb_isr+0x2f8>)
    9398:	ldrb	r2, [r2, #0]
    939a:	strb	r2, [r6, #0]
    939c:	b.n	94a8 <usb_isr+0x374>
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    939e:	ldr	r6, [pc, #140]	; (942c <usb_isr+0x2f8>)
    93a0:	strb	r2, [r6, #0]
		reply_buffer[1] = 0;
    93a2:	strb	r2, [r6, #1]
    93a4:	b.n	94a0 <usb_isr+0x36c>
    93a6:	ldrh	r1, [r5, #4]
    93a8:	and.w	r1, r1, #127	; 0x7f
		datalen = 2;
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    93ac:	cmp	r1, #4
    93ae:	bhi.n	9494 <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    93b0:	ldr	r6, [pc, #120]	; (942c <usb_isr+0x2f8>)
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    93b2:	lsls	r1, r1, #2
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    93b4:	strb	r2, [r6, #0]
		reply_buffer[1] = 0;
    93b6:	strb	r2, [r6, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    93b8:	ldr	r2, [pc, #116]	; (9430 <usb_isr+0x2fc>)
    93ba:	ldrb	r2, [r2, r1]
    93bc:	lsls	r4, r2, #30
    93be:	bpl.n	94a0 <usb_isr+0x36c>
    93c0:	strb	r3, [r6, #0]
    93c2:	b.n	94a0 <usb_isr+0x36c>
    93c4:	ldrh	r2, [r5, #4]
    93c6:	and.w	r2, r2, #127	; 0x7f
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    93ca:	cmp	r2, #4
    93cc:	bhi.n	9494 <usb_isr+0x360>
    93ce:	ldrh	r3, [r5, #2]
    93d0:	cmp	r3, #0
    93d2:	bne.n	9494 <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    93d4:	ldr	r1, [pc, #88]	; (9430 <usb_isr+0x2fc>)
    93d6:	lsls	r2, r2, #2
    93d8:	add	r1, r2
    93da:	ldrb	r2, [r1, #0]
    93dc:	bic.w	r2, r2, #2
    93e0:	b.n	9456 <usb_isr+0x322>
    93e2:	nop
    93e4:	.word	0x40072080
    93e8:	.word	0x1fff8567
    93ec:	.word	0x1fff84f1
    93f0:	.word	0x1fff8470
    93f4:	.word	0x40072090
    93f8:	.word	0x1fff0000
    93fc:	.word	0x1fff8554
    9400:	.word	0x1fff8568
    9404:	.word	0x004000c8
    9408:	.word	0x1fff849c
    940c:	.word	0x1fff84e0
    9410:	.word	0x1fff8534
    9414:	.word	0x1fff848c
    9418:	.word	0x1fff85e4
    941c:	.word	0x1fff8544
    9420:	.word	0x1fff855e
    9424:	.word	0x1001c830
    9428:	.word	0x00400088
    942c:	.word	0x1fff855f
    9430:	.word	0x400720c0
    9434:	.word	0x1fff8488
    9438:	.word	0x0001288a
    943c:	ldrh	r2, [r5, #4]
    943e:	and.w	r2, r2, #127	; 0x7f
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    9442:	cmp	r2, #4
    9444:	bhi.n	9494 <usb_isr+0x360>
    9446:	ldrh	r3, [r5, #2]
    9448:	cbnz	r3, 9494 <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    944a:	ldr	r1, [pc, #620]	; (96b8 <usb_isr+0x584>)
    944c:	lsls	r2, r2, #2
    944e:	add	r1, r2
    9450:	ldrb	r2, [r1, #0]
    9452:	orr.w	r2, r2, #2
    9456:	strb	r2, [r1, #0]
    9458:	b.n	94a6 <usb_isr+0x372>
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    945a:	ldrh	r2, [r5, #2]
    945c:	ldrh	r1, [r5, #4]
    945e:	ldr	r3, [pc, #604]	; (96bc <usb_isr+0x588>)
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    9460:	ldr	r6, [r3, #4]
    9462:	cbz	r6, 9494 <usb_isr+0x360>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    9464:	ldrh	r0, [r3, #0]
    9466:	cmp	r0, r2
    9468:	bne.n	947c <usb_isr+0x348>
    946a:	ldrh	r0, [r3, #2]
    946c:	cmp	r0, r1
    946e:	bne.n	947c <usb_isr+0x348>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    9470:	lsrs	r2, r2, #8
    9472:	cmp	r2, #3
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    9474:	ite	eq
    9476:	ldrbeq	r3, [r6, #0]
				} else {
					datalen = list->length;
    9478:	ldrhne	r3, [r3, #8]
    947a:	b.n	94a8 <usb_isr+0x374>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    947c:	adds	r3, #12
    947e:	b.n	9460 <usb_isr+0x32c>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    9480:	ldrh	r3, [r5, #4]
    9482:	cbnz	r3, 94a4 <usb_isr+0x370>
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    9484:	ldr	r2, [pc, #568]	; (96c0 <usb_isr+0x58c>)
    9486:	ldr	r1, [r2, #0]
    9488:	ldr	r2, [pc, #568]	; (96c4 <usb_isr+0x590>)
    948a:	str	r1, [r2, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    948c:	ldr	r2, [pc, #568]	; (96c8 <usb_isr+0x594>)
    948e:	ldrb	r1, [r5, #2]
    9490:	strb	r1, [r2, #0]
    9492:	b.n	94a6 <usb_isr+0x372>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9494:	ldr	r3, [pc, #544]	; (96b8 <usb_isr+0x584>)
    9496:	movs	r2, #15
    9498:	strb	r2, [r3, #0]
    949a:	b.n	94f0 <usb_isr+0x3bc>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    949c:	movs	r3, #0
    949e:	b.n	94a6 <usb_isr+0x372>
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    94a0:	movs	r3, #2
    94a2:	b.n	94a8 <usb_isr+0x374>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    94a4:	mov	r3, r2

static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
    94a6:	mov	r6, r3
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    94a8:	ldrh	r4, [r5, #6]
    94aa:	cmp	r4, r3
    94ac:	it	cs
    94ae:	movcs	r4, r3
    94b0:	cmp	r4, #64	; 0x40
    94b2:	mov	r5, r4
    94b4:	it	cs
    94b6:	movcs	r5, #64	; 0x40
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
    94b8:	mov	r0, r6
    94ba:	mov	r1, r5
    94bc:	bl	8fa0 <endpoint0_transmit>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    94c0:	subs	r4, r4, r5

	if (datalen > setup.wLength) datalen = setup.wLength;
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    94c2:	add	r6, r5
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    94c4:	bne.n	94ce <usb_isr+0x39a>
    94c6:	cmp	r5, #64	; 0x40
    94c8:	bne.n	94f0 <usb_isr+0x3bc>
    94ca:	mov	r5, r4
    94cc:	b.n	94d6 <usb_isr+0x3a2>
    94ce:	cmp	r4, #64	; 0x40
    94d0:	mov	r5, r4
    94d2:	it	cs
    94d4:	movcs	r5, #64	; 0x40

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
    94d6:	mov	r0, r6
    94d8:	mov	r1, r5
    94da:	bl	8fa0 <endpoint0_transmit>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    94de:	subs	r4, r4, r5
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    94e0:	add	r6, r5
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    94e2:	bne.n	94e8 <usb_isr+0x3b4>
    94e4:	cmp	r5, #64	; 0x40
    94e6:	bne.n	94f0 <usb_isr+0x3bc>

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    94e8:	ldr	r3, [pc, #480]	; (96cc <usb_isr+0x598>)
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    94ea:	str.w	r6, [sl]
	ep0_tx_len = datalen;
    94ee:	strh	r4, [r3, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    94f0:	movs	r2, #1
    94f2:	ldr	r3, [pc, #476]	; (96d0 <usb_isr+0x59c>)
    94f4:	b.n	9572 <usb_isr+0x43e>
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    94f6:	ldr	r3, [pc, #476]	; (96d4 <usb_isr+0x5a0>)
    94f8:	ldrh	r0, [r3, #0]
    94fa:	movw	r1, #8225	; 0x2021
    94fe:	cmp	r0, r1
    9500:	bne.n	9528 <usb_isr+0x3f4>
			int i;
			uint32_t *line_coding = NULL;
			switch (setup.wIndex) {
    9502:	ldrh	r3, [r3, #4]
    9504:	cbnz	r3, 9520 <usb_isr+0x3ec>
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
					//serial_phex(*buf);
					*dst++ = *buf++;
    9506:	ldr	r1, [pc, #464]	; (96d8 <usb_isr+0x5a4>)
    9508:	ldrb	r0, [r2, r3]
    950a:	strb	r0, [r3, r1]
#endif
			}
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
    950c:	adds	r3, #1
    950e:	cmp	r3, #7
    9510:	bne.n	9508 <usb_isr+0x3d4>
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    9512:	ldr	r3, [pc, #452]	; (96d8 <usb_isr+0x5a4>)
    9514:	ldr	r3, [r3, #0]
    9516:	cmp	r3, #134	; 0x86
    9518:	ittt	eq
    951a:	ldreq	r3, [pc, #448]	; (96dc <usb_isr+0x5a8>)
    951c:	moveq	r2, #15
    951e:	strbeq	r2, [r3, #0]
			}
			endpoint0_transmit(NULL, 0);
    9520:	movs	r1, #0
    9522:	mov	r0, r1
    9524:	bl	8fa0 <endpoint0_transmit>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    9528:	ldr	r3, [pc, #436]	; (96e0 <usb_isr+0x5ac>)
    952a:	str.w	r3, [r4, r6, lsl #3]
    952e:	b.n	9574 <usb_isr+0x440>
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    9530:	ldr	r7, [pc, #432]	; (96e4 <usb_isr+0x5b0>)
    9532:	ldr	r6, [r7, #0]
		if (data) {
    9534:	cbz	r6, 9560 <usb_isr+0x42c>
			size = ep0_tx_len;
    9536:	ldr.w	sl, [pc, #404]	; 96cc <usb_isr+0x598>
    953a:	ldrh.w	r4, [sl]
    953e:	cmp	r4, #64	; 0x40
    9540:	mov	r5, r4
    9542:	it	cs
    9544:	movcs	r5, #64	; 0x40
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
    9546:	mov	r0, r6
    9548:	mov	r1, r5
    954a:	bl	8fa0 <endpoint0_transmit>
			data += size;
			ep0_tx_len -= size;
    954e:	subs	r0, r4, r5
    9550:	uxth	r0, r0
    9552:	strh.w	r0, [sl]
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    9556:	cbnz	r0, 955c <usb_isr+0x428>
    9558:	cmp	r5, #64	; 0x40
    955a:	bne.n	955e <usb_isr+0x42a>
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    955c:	adds	r0, r6, r5
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    955e:	str	r0, [r7, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    9560:	ldr	r3, [pc, #368]	; (96d4 <usb_isr+0x5a0>)
    9562:	ldrh	r2, [r3, #0]
    9564:	cmp.w	r2, #1280	; 0x500
    9568:	bne.n	9574 <usb_isr+0x440>
			setup.bRequest = 0;
    956a:	movs	r2, #0
    956c:	strb	r2, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    956e:	ldrb	r2, [r3, #2]
    9570:	ldr	r3, [pc, #372]	; (96e8 <usb_isr+0x5b4>)
    9572:	strb	r2, [r3, #0]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    9574:	ldr	r3, [pc, #344]	; (96d0 <usb_isr+0x59c>)
    9576:	movs	r2, #1
    9578:	strb	r2, [r3, #0]
    957a:	b.n	966c <usb_isr+0x538>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    957c:	add.w	r5, r4, r6, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    9580:	subs	r7, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    9582:	ldr	r2, [r5, #4]
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    9584:	and.w	r3, r3, #8
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    9588:	sub.w	r0, r2, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    958c:	uxtb	r7, r7
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    958e:	and.w	lr, r3, #255	; 0xff
    9592:	cmp	r3, #0
    9594:	beq.n	9604 <usb_isr+0x4d0>
				usb_free(packet);
    9596:	bl	8f5c <usb_free>
				packet = tx_first[endpoint];
    959a:	ldr	r0, [pc, #336]	; (96ec <usb_isr+0x5b8>)
    959c:	ldr	r3, [pc, #336]	; (96f0 <usb_isr+0x5bc>)
    959e:	ldr.w	r1, [r0, r7, lsl #2]
				if (packet) {
    95a2:	cbz	r1, 95e0 <usb_isr+0x4ac>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    95a4:	ldr	r2, [r1, #4]
    95a6:	str.w	r2, [r0, r7, lsl #2]
					b->addr = packet->buf;
    95aa:	add.w	r2, r1, #8
    95ae:	str	r2, [r5, #4]
					switch (tx_state[endpoint]) {
    95b0:	ldrb	r2, [r3, r7]
    95b2:	cmp	r2, #3
    95b4:	bhi.n	95ce <usb_isr+0x49a>
    95b6:	tbb	[pc, r2]
    95ba:	.short	0x0402
    95bc:	.short	0x0806
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    95be:	movs	r2, #3
    95c0:	b.n	95cc <usb_isr+0x498>
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    95c2:	movs	r2, #2
    95c4:	b.n	95cc <usb_isr+0x498>
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    95c6:	movs	r2, #5
    95c8:	b.n	95cc <usb_isr+0x498>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    95ca:	movs	r2, #4
    95cc:	strb	r2, [r3, r7]
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    95ce:	tst.w	r5, #8
    95d2:	ldrh	r2, [r1, #0]
    95d4:	ite	ne
    95d6:	movne	r3, #200	; 0xc8
    95d8:	moveq	r3, #136	; 0x88
    95da:	orr.w	r3, r3, r2, lsl #16
    95de:	b.n	9668 <usb_isr+0x534>
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    95e0:	ldrb	r2, [r3, r7]
    95e2:	cmp	r2, #3
    95e4:	bhi.n	95f6 <usb_isr+0x4c2>
    95e6:	tbb	[pc, r2]
    95ea:	.short	0x4141
    95ec:	.short	0x0402
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    95ee:	movs	r2, #0
    95f0:	b.n	9600 <usb_isr+0x4cc>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    95f2:	movs	r2, #1
    95f4:	b.n	9600 <usb_isr+0x4cc>
						break;
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    95f6:	tst.w	r5, #8
    95fa:	ite	ne
    95fc:	movne	r2, #3
    95fe:	moveq	r2, #2
    9600:	strb	r2, [r3, r7]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    9602:	b.n	966c <usb_isr+0x538>
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    9604:	ldr.w	r3, [r4, r6, lsl #3]
    9608:	lsrs	r3, r3, #16
    960a:	uxth	r1, r3
    960c:	strh.w	r1, [r2, #-8]
				if (packet->len > 0) {
    9610:	cbz	r3, 965c <usb_isr+0x528>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    9612:	ldr	r3, [pc, #224]	; (96f4 <usb_isr+0x5c0>)
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    9614:	strh.w	lr, [r2, #-6]
					packet->next = NULL;
    9618:	str.w	lr, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    961c:	ldr.w	r2, [r3, r7, lsl #2]
    9620:	ldr.w	lr, [pc, #252]	; 9720 <usb_isr+0x5ec>
    9624:	cbnz	r2, 962c <usb_isr+0x4f8>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    9626:	str.w	r0, [r3, r7, lsl #2]
    962a:	b.n	9632 <usb_isr+0x4fe>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    962c:	ldr.w	r3, [lr, r7, lsl #2]
    9630:	str	r0, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    9632:	ldr	r2, [pc, #196]	; (96f8 <usb_isr+0x5c4>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
					}
					rx_last[endpoint] = packet;
    9634:	str.w	r0, [lr, r7, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    9638:	ldrh.w	r3, [r2, r7, lsl #1]
    963c:	add	r3, r1
    963e:	strh.w	r3, [r2, r7, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    9642:	bl	8f20 <usb_malloc>
					if (packet) {
    9646:	cbz	r0, 964e <usb_isr+0x51a>
						b->addr = packet->buf;
    9648:	adds	r0, #8
    964a:	str	r0, [r5, #4]
    964c:	b.n	965c <usb_isr+0x528>
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    964e:	ldr	r2, [pc, #172]	; (96fc <usb_isr+0x5c8>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    9650:	str.w	r0, [r4, r6, lsl #3]
						usb_rx_memory_needed++;
    9654:	ldrb	r3, [r2, #0]
    9656:	adds	r3, #1
    9658:	strb	r3, [r2, #0]
    965a:	b.n	966c <usb_isr+0x538>
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    965c:	ldr	r2, [pc, #160]	; (9700 <usb_isr+0x5cc>)
    965e:	ldr	r3, [pc, #128]	; (96e0 <usb_isr+0x5ac>)
    9660:	tst.w	r5, #8
    9664:	it	eq
    9666:	moveq	r3, r2
    9668:	str.w	r3, [r4, r6, lsl #3]
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    966c:	movs	r3, #8
    966e:	strb.w	r3, [r8]
		goto restart;
    9672:	b.n	913c <usb_isr+0x8>
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    9674:	lsls	r0, r4, #31
    9676:	bpl.n	9724 <usb_isr+0x5f0>
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    9678:	ldr	r1, [pc, #84]	; (96d0 <usb_isr+0x59c>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    967a:	ldr	r0, [pc, #132]	; (9700 <usb_isr+0x5cc>)
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    967c:	ldr	r4, [pc, #132]	; (9704 <usb_isr+0x5d0>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    967e:	movs	r3, #2
    9680:	strb	r3, [r1, #0]
		ep0_tx_bdt_bank = 0;
    9682:	ldr	r3, [pc, #132]	; (9708 <usb_isr+0x5d4>)
    9684:	strb	r2, [r3, #0]

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    9686:	ldr	r3, [pc, #132]	; (970c <usb_isr+0x5d8>)
    9688:	str	r0, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    968a:	str	r4, [r3, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    968c:	str	r0, [r3, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    968e:	ldr	r0, [pc, #128]	; (9710 <usb_isr+0x5dc>)
    9690:	str	r0, [r3, #12]
		table[index(0, TX, EVEN)].desc = 0;
    9692:	str	r2, [r3, #16]
		table[index(0, TX, ODD)].desc = 0;
    9694:	str	r2, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9696:	ldr	r3, [pc, #32]	; (96b8 <usb_isr+0x584>)
    9698:	movs	r0, #13
    969a:	strb	r0, [r3, #0]

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    969c:	ldr	r0, [pc, #116]	; (9714 <usb_isr+0x5e0>)
    969e:	movs	r3, #255	; 0xff
    96a0:	strb	r3, [r0, #0]
		USB0_ISTAT = 0xFF;
    96a2:	strb	r3, [r5, #0]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    96a4:	strb	r2, [r0, #16]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    96a6:	ldr	r2, [pc, #112]	; (9718 <usb_isr+0x5e4>)
    96a8:	strb	r3, [r2, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    96aa:	ldr	r3, [pc, #112]	; (971c <usb_isr+0x5e8>)
    96ac:	movs	r2, #159	; 0x9f
    96ae:	strb	r2, [r3, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    96b0:	movs	r3, #1
    96b2:	strb	r3, [r1, #0]
		return;
    96b4:	b.n	974a <usb_isr+0x616>
    96b6:	nop
    96b8:	.word	0x400720c0
    96bc:	.word	0x00012890
    96c0:	.word	0x1fff8484
    96c4:	.word	0x1fff85e0
    96c8:	.word	0x1fff8480
    96cc:	.word	0x1fff855c
    96d0:	.word	0x40072094
    96d4:	.word	0x1fff8554
    96d8:	.word	0x1fff85d8
    96dc:	.word	0x1fff84f1
    96e0:	.word	0x004000c8
    96e4:	.word	0x1fff8488
    96e8:	.word	0x40072098
    96ec:	.word	0x1fff8534
    96f0:	.word	0x1fff849c
    96f4:	.word	0x1fff84e0
    96f8:	.word	0x1fff85e4
    96fc:	.word	0x1fff855e
    9700:	.word	0x00400088
    9704:	.word	0x1fff84a0
    9708:	.word	0x1fff84f0
    970c:	.word	0x1fff0000
    9710:	.word	0x1fff84f4
    9714:	.word	0x40072088
    9718:	.word	0x4007208c
    971c:	.word	0x40072084
    9720:	.word	0x1fff848c
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    9724:	lsls	r1, r4, #24
    9726:	bpl.n	9732 <usb_isr+0x5fe>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9728:	ldr	r3, [pc, #36]	; (9750 <usb_isr+0x61c>)
    972a:	movs	r2, #13
    972c:	strb	r2, [r3, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    972e:	movs	r3, #128	; 0x80
    9730:	strb	r3, [r5, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    9732:	lsls	r2, r4, #30
    9734:	bpl.n	9742 <usb_isr+0x60e>
		uint8_t err = USB0_ERRSTAT;
    9736:	ldr	r2, [pc, #28]	; (9754 <usb_isr+0x620>)
    9738:	ldrb	r3, [r2, #0]
    973a:	uxtb	r3, r3
		USB0_ERRSTAT = err;
    973c:	strb	r3, [r2, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    973e:	movs	r3, #2
    9740:	strb	r3, [r5, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    9742:	lsls	r3, r4, #27
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    9744:	itt	mi
    9746:	movmi	r3, #16
    9748:	strbmi	r3, [r5, #0]
	}

}
    974a:	add	sp, #12
    974c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9750:	.word	0x400720c0
    9754:	.word	0x40072088

00009758 <usb_init>:



void usb_init(void)
{
    9758:	push	{r4, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    975a:	bl	9c20 <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    975e:	movs	r3, #0
		table[i].desc = 0;
    9760:	ldr	r0, [pc, #108]	; (97d0 <usb_init+0x78>)
    9762:	mov	r1, r3
    9764:	str.w	r1, [r0, r3, lsl #3]
		table[i].addr = 0;
    9768:	add.w	r4, r0, r3, lsl #3
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    976c:	adds	r3, #1
    976e:	cmp	r3, #20
		table[i].desc = 0;
    9770:	ldr	r2, [pc, #92]	; (97d0 <usb_init+0x78>)
		table[i].addr = 0;
    9772:	str	r1, [r4, #4]
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    9774:	bne.n	9764 <usb_init+0xc>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    9776:	ldr	r1, [pc, #92]	; (97d4 <usb_init+0x7c>)
    9778:	ldr	r3, [r1, #0]
    977a:	orr.w	r3, r3, #262144	; 0x40000
    977e:	str	r3, [r1, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    9780:	ldr	r1, [pc, #84]	; (97d8 <usb_init+0x80>)
    9782:	ldr	r3, [r1, #0]
    9784:	orr.w	r3, r3, #50331648	; 0x3000000
    9788:	str	r3, [r1, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    978a:	ldr	r3, [pc, #80]	; (97dc <usb_init+0x84>)
    978c:	ubfx	r1, r2, #8, #8
    9790:	strb	r1, [r3, #0]
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    9792:	ubfx	r1, r2, #16, #8
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    9796:	lsrs	r2, r2, #24
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    9798:	strb	r1, [r3, #20]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    979a:	strb	r2, [r3, #24]

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    979c:	ldr	r2, [pc, #64]	; (97e0 <usb_init+0x88>)
    979e:	movs	r3, #255	; 0xff
    97a0:	strb	r3, [r2, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    97a2:	movs	r1, #0
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    97a4:	strb	r3, [r2, #8]
	USB0_OTGISTAT = 0xFF;
    97a6:	strb.w	r3, [r2, #-112]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    97aa:	movs	r3, #1
    97ac:	strb	r3, [r2, #20]
	USB0_USBCTRL = 0;
    97ae:	strb.w	r1, [r2, #128]	; 0x80

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    97b2:	strb	r3, [r2, #4]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    97b4:	ldr	r3, [pc, #44]	; (97e4 <usb_init+0x8c>)
    97b6:	movs	r2, #112	; 0x70
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    97b8:	mvn.w	r1, #816	; 0x330

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    97bc:	strb	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    97be:	add	r3, r1
    97c0:	mov.w	r2, #2097152	; 0x200000
    97c4:	str	r2, [r3, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    97c6:	ldr	r3, [pc, #32]	; (97e8 <usb_init+0x90>)
    97c8:	movs	r2, #16
    97ca:	strb	r2, [r3, #0]
    97cc:	pop	{r4, pc}
    97ce:	nop
    97d0:	.word	0x1fff0000
    97d4:	.word	0x40048034
    97d8:	.word	0x4000d800
    97dc:	.word	0x4007209c
    97e0:	.word	0x40072080
    97e4:	.word	0xe000e435
    97e8:	.word	0x40072108

000097ec <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    97ec:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    97f0:	ldr	r4, [pc, #176]	; (98a4 <yield+0xb8>)
    97f2:	ldrb	r3, [r4, #0]
    97f4:	cmp	r3, #0
    97f6:	beq.n	989e <yield+0xb2>
	if (running) return; // TODO: does this need to be atomic?
    97f8:	ldr	r5, [pc, #172]	; (98a8 <yield+0xbc>)
    97fa:	ldrb	r2, [r5, #0]
    97fc:	cmp	r2, #0
    97fe:	bne.n	989e <yield+0xb2>
	running = 1;
    9800:	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    9802:	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    9804:	strb	r2, [r5, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    9806:	bpl.n	9820 <yield+0x34>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    9808:	bl	89a4 <usb_serial_available>
		if (Serial.available()) serialEvent();
    980c:	cbz	r0, 9812 <yield+0x26>
    980e:	bl	9c16 <serialEvent()>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    9812:	ldr	r3, [pc, #152]	; (98ac <yield+0xc0>)
    9814:	ldrb	r3, [r3, #0]
    9816:	cbz	r3, 9820 <yield+0x34>
    9818:	ldrb	r3, [r4, #0]
    981a:	bic.w	r3, r3, #1
    981e:	strb	r3, [r4, #0]
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    9820:	ldrb	r3, [r4, #0]
    9822:	lsls	r2, r3, #30
    9824:	bpl.n	9850 <yield+0x64>
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    9826:	ldr.w	r8, [pc, #148]	; 98bc <yield+0xd0>
			s_serials_with_serial_events[i]->doYieldCode();
    982a:	ldr.w	r9, [pc, #148]	; 98c0 <yield+0xd4>
    982e:	movs	r6, #0
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    9830:	ldrb.w	r2, [r8]
    9834:	uxtb	r3, r6
    9836:	cmp	r2, r3
    9838:	bls.n	9850 <yield+0x64>
			s_serials_with_serial_events[i]->doYieldCode();
    983a:	ldr.w	r7, [r9, r3, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*_serialEvent)();
    983e:	ldr	r3, [r7, #0]
    9840:	mov	r0, r7
    9842:	ldr	r3, [r3, #16]
    9844:	blx	r3
    9846:	cbz	r0, 984c <yield+0x60>
    9848:	ldr	r3, [r7, #16]
    984a:	blx	r3
    984c:	adds	r6, #1
    984e:	b.n	9830 <yield+0x44>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    9850:	movs	r3, #0
    9852:	strb	r3, [r5, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    9854:	ldrb	r3, [r4, #0]
    9856:	lsls	r3, r3, #29
    9858:	bpl.n	989e <yield+0xb2>
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
    985a:	ldr	r1, [pc, #84]	; (98b0 <yield+0xc4>)
    985c:	ldr	r3, [r1, #0]
    985e:	cbz	r3, 989e <yield+0xb2>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    9860:	mrs	r3, IPSR
		if (ipsr != 0) return;
    9864:	cbnz	r3, 989e <yield+0xb2>
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    9866:	mrs	r2, PRIMASK
		__disable_irq();
    986a:	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    986c:	ldr	r0, [r1, #0]
		if (first == nullptr) {
    986e:	cbz	r0, 9876 <yield+0x8a>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    9870:	ldr	r4, [pc, #64]	; (98b4 <yield+0xc8>)
    9872:	ldrb	r5, [r4, #0]
    9874:	cbz	r5, 987e <yield+0x92>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    9876:	cbnz	r2, 989e <yield+0xb2>
    9878:	cpsie	i
    987a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    987e:	movs	r3, #1
    9880:	strb	r3, [r4, #0]
		firstYield = first->_next;
    9882:	ldr	r3, [r0, #20]
    9884:	str	r3, [r1, #0]
		if (firstYield) {
    9886:	cbz	r3, 988c <yield+0xa0>
			firstYield->_prev = nullptr;
    9888:	str	r5, [r3, #24]
    988a:	b.n	9890 <yield+0xa4>
		} else {
			lastYield = nullptr;
    988c:	ldr	r1, [pc, #40]	; (98b8 <yield+0xcc>)
    988e:	str	r3, [r1, #0]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    9890:	cbnz	r2, 9894 <yield+0xa8>
    9892:	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    9894:	movs	r5, #0
    9896:	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    9898:	ldr	r3, [r0, #8]
    989a:	blx	r3
		runningFromYield = false;
    989c:	strb	r5, [r4, #0]
    989e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    98a2:	nop
    98a4:	.word	0x1fff1364
    98a8:	.word	0x1fff8569
    98ac:	.word	0x1fff1378
    98b0:	.word	0x1fff8578
    98b4:	.word	0x1fff857c
    98b8:	.word	0x1fff8574
    98bc:	.word	0x1fff85a0
    98c0:	.word	0x1fff8588

000098c4 <DMAChannel::release()>:
	*p++ = 0;
}

void DMAChannel::release(void)
{
	if (channel >= DMA_MAX_CHANNELS) return;
    98c4:	ldrb	r3, [r0, #4]
    98c6:	cmp	r3, #15
    98c8:	bhi.n	98ec <DMAChannel::release()+0x28>
	DMA_CERQ = channel;
    98ca:	ldr	r2, [pc, #36]	; (98f0 <DMAChannel::release()+0x2c>)
    98cc:	strb	r3, [r2, #0]
	__disable_irq();
    98ce:	cpsid	i
	dma_channel_allocated_mask &= ~(1 << channel);
    98d0:	ldr	r1, [pc, #32]	; (98f4 <DMAChannel::release()+0x30>)
    98d2:	ldrb	r2, [r0, #4]
    98d4:	movs	r3, #1
    98d6:	lsl.w	r2, r3, r2
    98da:	ldrh	r3, [r1, #0]
    98dc:	bic.w	r3, r3, r2
    98e0:	strh	r3, [r1, #0]
	__enable_irq();
    98e2:	cpsie	i
	channel = DMA_MAX_CHANNELS;
    98e4:	movs	r3, #16
    98e6:	strb	r3, [r0, #4]
	TCD = (TCD_t *)0;
    98e8:	movs	r3, #0
    98ea:	str	r3, [r0, #0]
    98ec:	bx	lr
    98ee:	nop
    98f0:	.word	0x4000801a
    98f4:	.word	0x1fff856a

000098f8 <MillisTimer::disableTimerInterrupt()>:
	volatile TimerStateType _state = TimerOff;
	static MillisTimer *listWaiting; // single linked list of waiting to start timers
	static MillisTimer *listActive;  // double linked list of running timers
	static bool disableTimerInterrupt() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    98f8:	mrs	r0, PRIMASK
		__disable_irq();
    98fc:	cpsid	i
		return (primask == 0) ? true : false;
	}
    98fe:	clz	r0, r0
    9902:	lsrs	r0, r0, #5
    9904:	bx	lr

00009906 <MillisTimer::enableTimerInterrupt(bool)>:
	static void enableTimerInterrupt(bool doit) {
		if (doit) __enable_irq();
    9906:	cbz	r0, 990a <MillisTimer::enableTimerInterrupt(bool)+0x4>
    9908:	cpsie	i
    990a:	bx	lr

0000990c <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    990c:	push	{r3, r4, r5, r6, r7, lr}
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    990e:	ldr	r6, [pc, #48]	; (9940 <EventResponder::runFromInterrupt()+0x34>)
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    9910:	ldr	r7, [pc, #48]	; (9944 <EventResponder::runFromInterrupt()+0x38>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    9912:	movs	r5, #0
}

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
    9914:	bl	98f8 <MillisTimer::disableTimerInterrupt()>
		EventResponder *first = firstInterrupt;
    9918:	ldr	r4, [r6, #0]
}

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
    991a:	mov	r2, r0
		EventResponder *first = firstInterrupt;
		if (first) {
    991c:	cbz	r4, 993a <EventResponder::runFromInterrupt()+0x2e>
			firstInterrupt = first->_next;
    991e:	ldr	r3, [r4, #20]
    9920:	str	r3, [r6, #0]
			if (firstInterrupt) {
    9922:	cbz	r3, 9928 <EventResponder::runFromInterrupt()+0x1c>
				firstInterrupt->_prev = nullptr;
    9924:	str	r5, [r3, #24]
    9926:	b.n	992a <EventResponder::runFromInterrupt()+0x1e>
			} else {
				lastInterrupt = nullptr;
    9928:	str	r3, [r7, #0]
			}
			enableInterrupts(irq);
    992a:	mov	r0, r2
    992c:	bl	9906 <MillisTimer::enableTimerInterrupt(bool)>
			first->_triggered = false;
    9930:	strb	r5, [r4, #29]
			(*(first->_function))(*first);
    9932:	ldr	r3, [r4, #8]
    9934:	mov	r0, r4
    9936:	blx	r3
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
	while (1) {
    9938:	b.n	9914 <EventResponder::runFromInterrupt()+0x8>
			}
			enableInterrupts(irq);
			first->_triggered = false;
			(*(first->_function))(*first);
		} else {
			enableInterrupts(irq);
    993a:	bl	9906 <MillisTimer::enableTimerInterrupt(bool)>
    993e:	pop	{r3, r4, r5, r6, r7, pc}
    9940:	.word	0x1fff856c
    9944:	.word	0x1fff8570

00009948 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    9948:	b.w	990c <EventResponder::runFromInterrupt()>

0000994c <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
    994c:	ldr	r2, [pc, #8]	; (9958 <systick_isr+0xc>)
    994e:	ldr	r3, [r2, #0]
    9950:	adds	r3, #1
    9952:	str	r3, [r2, #0]
    9954:	bx	lr
    9956:	nop
    9958:	.word	0x1fff8484

0000995c <usb_serial_class::clear()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    995c:	b.w	89c0 <usb_serial_flush_input>

00009960 <usb_serial_class::peek()>:
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    9960:	b.w	896c <usb_serial_peekchar>

00009964 <usb_serial_class::read()>:
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    9964:	b.w	8920 <usb_serial_getchar>

00009968 <usb_serial_class::available()>:
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    9968:	b.w	89a4 <usb_serial_available>

0000996c <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    996c:	b.w	8b30 <usb_serial_flush_output>

00009970 <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    9970:	b.w	8ae8 <usb_serial_write_buffer_free>

00009974 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    9974:	mov	r0, r1
    9976:	mov	r1, r2
    9978:	b.w	89f0 <usb_serial_write>

0000997c <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    997c:	mov	r0, r1
    997e:	b.w	8ad0 <usb_serial_putchar>

00009982 <Print::write(unsigned char const*, unsigned int)>:

#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
    9982:	push	{r3, r4, r5, r6, r7, lr}
    9984:	mov	r7, r0
	if (buffer == nullptr) return 0;
    9986:	mov	r5, r1
    9988:	cbz	r1, 99a2 <Print::write(unsigned char const*, unsigned int)+0x20>
    998a:	adds	r6, r1, r2
    998c:	movs	r4, #0
	size_t count = 0;
	while (size--) count += write(*buffer++);
    998e:	cmp	r5, r6
    9990:	beq.n	99a6 <Print::write(unsigned char const*, unsigned int)+0x24>
    9992:	ldr	r3, [r7, #0]
    9994:	ldrb.w	r1, [r5], #1
    9998:	ldr	r3, [r3, #0]
    999a:	mov	r0, r7
    999c:	blx	r3
    999e:	add	r4, r0
    99a0:	b.n	998e <Print::write(unsigned char const*, unsigned int)+0xc>
#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
	if (buffer == nullptr) return 0;
    99a2:	mov	r0, r1
    99a4:	pop	{r3, r4, r5, r6, r7, pc}
    99a6:	mov	r0, r4
	size_t count = 0;
	while (size--) count += write(*buffer++);
	return count;
}
    99a8:	pop	{r3, r4, r5, r6, r7, pc}
    99aa:	Address 0x000099aa is out of bounds.


000099ac <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    99ac:	push	{r0, r1, r2, lr}
	uint8_t buf[2]={'\r', '\n'};
    99ae:	ldr	r3, [pc, #24]	; (99c8 <Print::println()+0x1c>)
    99b0:	ldrh	r3, [r3, #0]
    99b2:	strh.w	r3, [sp, #4]
	return write(buf, 2);
    99b6:	ldr	r3, [r0, #0]
    99b8:	movs	r2, #2
    99ba:	ldr	r3, [r3, #4]
    99bc:	add	r1, sp, #4
    99be:	blx	r3
}
    99c0:	add	sp, #12
    99c2:	ldr.w	pc, [sp], #4
    99c6:	nop
    99c8:	.word	0x00012888

000099cc <Print::printf(char const*, ...)>:
	return len;
}
}

int Print::printf(const char *format, ...)
{
    99cc:	push	{r1, r2, r3}
    99ce:	push	{r0, r1, lr}
    99d0:	add	r2, sp, #12
    99d2:	ldr.w	r1, [r2], #4
	va_list ap;
	va_start(ap, format);
    99d6:	str	r2, [sp, #4]
#ifdef __STRICT_ANSI__
	va_end(ap);
	return 0;  // TODO: make this work with -std=c++0x
#else
	int retval = vdprintf((int)this, format, ap);
    99d8:	bl	ef08 <vdprintf>
	va_end(ap);
	return retval;
#endif
}
    99dc:	add	sp, #8
    99de:	ldr.w	lr, [sp], #4
    99e2:	add	sp, #12
    99e4:	bx	lr

000099e6 <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
}

#else

size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
{
    99e6:	push	{r4, r5, r6, lr}
    99e8:	mov	r5, r0
    99ea:	sub	sp, #40	; 0x28
	uint8_t digit, i;

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
    99ec:	cbnz	r2, 99f8 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x12>
		return write((uint8_t)n);
    99ee:	ldr	r3, [r0, #0]
    99f0:	uxtb	r1, r1
    99f2:	ldr	r3, [r3, #0]
    99f4:	blx	r3
    99f6:	b.n	9a58 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x72>
	} else if (base == 1) {
		base = 10;
    99f8:	cmp	r2, #1
    99fa:	it	eq
    99fc:	moveq	r2, #10
	}


	if (n == 0) {
    99fe:	cbz	r1, 9a04 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x1e>
    9a00:	movs	r0, #33	; 0x21
    9a02:	b.n	9a0e <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x28>
		buf[sizeof(buf) - 1] = '0';
    9a04:	movs	r2, #48	; 0x30
    9a06:	strb.w	r2, [sp, #37]	; 0x25
		i = sizeof(buf) - 1;
    9a0a:	movs	r0, #33	; 0x21
    9a0c:	b.n	9a38 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x52>
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    9a0e:	udiv	r6, r1, r2
    9a12:	mls	r1, r2, r6, r1
    9a16:	uxtb	r4, r1
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    9a18:	cmp	r1, #9
    9a1a:	ite	ls
    9a1c:	addls.w	r1, r4, #48	; 0x30
    9a20:	addhi.w	r1, r4, #55	; 0x37
    9a24:	add	r4, sp, #40	; 0x28
    9a26:	add	r4, r0
    9a28:	uxtb	r1, r1
    9a2a:	strb.w	r1, [r4, #-36]
			n /= base;
			if (n == 0) break;
    9a2e:	mov	r1, r6
    9a30:	cbz	r6, 9a38 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x52>
			i--;
    9a32:	subs	r0, #1
    9a34:	uxtb	r0, r0
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
    9a36:	b.n	9a0e <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x28>
			n /= base;
			if (n == 0) break;
			i--;
		}
	}
	if (sign) {
    9a38:	cbz	r3, 9a48 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x62>
		i--;
    9a3a:	subs	r0, #1
    9a3c:	uxtb	r0, r0
		buf[i] = '-';
    9a3e:	add	r3, sp, #40	; 0x28
    9a40:	add	r3, r0
    9a42:	movs	r2, #45	; 0x2d
    9a44:	strb.w	r2, [r3, #-36]
	}
	return write(buf + i, sizeof(buf) - i);
    9a48:	ldr	r3, [r5, #0]
    9a4a:	add	r1, sp, #4
    9a4c:	rsb	r2, r0, #34	; 0x22
    9a50:	add	r1, r0
    9a52:	ldr	r3, [r3, #4]
    9a54:	mov	r0, r5
    9a56:	blx	r3
}
    9a58:	add	sp, #40	; 0x28
    9a5a:	pop	{r4, r5, r6, pc}

00009a5c <Print::print(long)>:

size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
    9a5c:	cmp	r1, #0
		sign = '-';
		n = -n;
    9a5e:	itte	lt
    9a60:	neglt	r1, r1
size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
		sign = '-';
    9a62:	movlt	r3, #45	; 0x2d
}


size_t Print::print(long n)
{
	uint8_t sign=0;
    9a64:	movge	r3, #0

	if (n < 0) {
		sign = '-';
		n = -n;
	}
	return printNumber(n, 10, sign);
    9a66:	movs	r2, #10
    9a68:	b.w	99e6 <Print::printNumber(unsigned long, unsigned char, unsigned char)>

00009a6c <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>:
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
    9a6c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    9a70:	sub	sp, #72	; 0x48
    9a72:	mov	r5, r0
    9a74:	ldrb.w	r8, [sp, #104]	; 0x68
    9a78:	ldrb.w	sl, [sp, #108]	; 0x6c
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    9a7c:	cmp.w	r8, #1
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
    9a80:	mov	r6, r2
    9a82:	mov	r7, r3
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    9a84:	bls.n	9b0a <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x9e>
	if (n == 0) {
    9a86:	orrs.w	r3, r6, r7
    9a8a:	beq.n	9a98 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x2c>
    9a8c:	movs	r4, #65	; 0x41
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    9a8e:	uxtb.w	r8, r8
    9a92:	mov.w	r9, #0
    9a96:	b.n	9aa2 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x36>
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    9a98:	movs	r3, #48	; 0x30
    9a9a:	strb.w	r3, [sp, #69]	; 0x45
		i = sizeof(buf) - 1;
    9a9e:	movs	r4, #65	; 0x41
    9aa0:	b.n	9ae4 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x78>
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    9aa2:	mov	r0, r6
    9aa4:	mov	r1, r7
    9aa6:	mov	r2, r8
    9aa8:	mov	r3, r9
    9aaa:	bl	a700 <__aeabi_uldivmod>
    9aae:	mov	r1, r3
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    9ab0:	cmp	r1, #0
    9ab2:	it	eq
    9ab4:	cmpeq	r2, #10
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    9ab6:	uxtb	r3, r2
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    9ab8:	add	r2, sp, #72	; 0x48
    9aba:	ite	cc
    9abc:	addcc	r3, #48	; 0x30
    9abe:	addcs	r3, #55	; 0x37
    9ac0:	add	r2, r4
    9ac2:	uxtb	r3, r3
    9ac4:	strb.w	r3, [r2, #-68]
			n /= base;
    9ac8:	mov	r0, r6
    9aca:	mov	r3, r9
    9acc:	mov	r1, r7
    9ace:	mov	r2, r8
    9ad0:	bl	a700 <__aeabi_uldivmod>
    9ad4:	mov	r6, r0
    9ad6:	mov	r7, r1
			if (n == 0) break;
    9ad8:	orrs.w	r3, r6, r7
    9adc:	beq.n	9ae4 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x78>
			i--;
    9ade:	subs	r4, #1
    9ae0:	uxtb	r4, r4
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
    9ae2:	b.n	9aa2 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x36>
			n /= base;
			if (n == 0) break;
			i--;
		}
	}
	if (sign) {
    9ae4:	cmp.w	sl, #0
    9ae8:	beq.n	9af8 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x8c>
		i--;
    9aea:	subs	r4, #1
    9aec:	uxtb	r4, r4
		buf[i] = '-';
    9aee:	add	r3, sp, #72	; 0x48
    9af0:	add	r3, r4
    9af2:	movs	r2, #45	; 0x2d
    9af4:	strb.w	r2, [r3, #-68]
	}
	return write(buf + i, sizeof(buf) - i);
    9af8:	ldr	r3, [r5, #0]
    9afa:	add	r1, sp, #4
    9afc:	ldr	r3, [r3, #4]
    9afe:	rsb	r2, r4, #66	; 0x42
    9b02:	add	r1, r4
    9b04:	mov	r0, r5
    9b06:	blx	r3
    9b08:	b.n	9b0c <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0xa0>
size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    9b0a:	movs	r0, #0
	if (sign) {
		i--;
		buf[i] = '-';
	}
	return write(buf + i, sizeof(buf) - i);
}
    9b0c:	add	sp, #72	; 0x48
    9b0e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00009b12 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    9b12:	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    9b14:	bl	70c <setup>
	while (1) {
		loop();
    9b18:	bl	770 <loop>
		yield();
    9b1c:	bl	97ec <yield>
    9b20:	b.n	9b18 <main+0x6>
    9b22:	Address 0x00009b22 is out of bounds.


00009b24 <software_isr>:
void software_isr(void) // AudioStream::update_all()
{
	AudioStream *p;

#if defined(KINETISK)
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    9b24:	ldr	r2, [pc, #88]	; (9b80 <software_isr+0x5c>)
}

AudioStream * AudioStream::first_update = NULL;

void software_isr(void) // AudioStream::update_all()
{
    9b26:	push	{r3, r4, r5, r6, r7, lr}
	AudioStream *p;

#if defined(KINETISK)
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    9b28:	ldr	r3, [r2, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
	uint32_t totalcycles = ARM_DWT_CYCCNT;
    9b2a:	ldr	r5, [pc, #88]	; (9b84 <software_isr+0x60>)
void software_isr(void) // AudioStream::update_all()
{
	AudioStream *p;

#if defined(KINETISK)
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    9b2c:	orr.w	r3, r3, #16777216	; 0x1000000
    9b30:	str	r3, [r2, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
    9b32:	ldr	r2, [pc, #84]	; (9b88 <software_isr+0x64>)
    9b34:	ldr	r3, [r2, #0]
    9b36:	orr.w	r3, r3, #1
    9b3a:	str	r3, [r2, #0]
	uint32_t totalcycles = ARM_DWT_CYCCNT;
#elif defined(KINETISL)
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    9b3c:	ldr	r3, [pc, #76]	; (9b8c <software_isr+0x68>)
	AudioStream *p;

#if defined(KINETISK)
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA;
	uint32_t totalcycles = ARM_DWT_CYCCNT;
    9b3e:	ldr	r6, [r5, #0]
#elif defined(KINETISL)
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    9b40:	ldr	r4, [r3, #0]
    9b42:	cbz	r4, 9b68 <software_isr+0x44>
		if (p->active) {
    9b44:	ldrb	r3, [r4, #8]
    9b46:	cbz	r3, 9b64 <software_isr+0x40>
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
    9b48:	ldr	r3, [r4, #0]
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
		if (p->active) {
			uint32_t cycles = ARM_DWT_CYCCNT;
    9b4a:	ldr	r7, [r5, #0]
			p->update();
    9b4c:	ldr	r3, [r3, #0]
    9b4e:	mov	r0, r4
    9b50:	blx	r3
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 4;
    9b52:	ldr	r2, [r5, #0]
			p->cpu_cycles = cycles;
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
    9b54:	ldrh	r3, [r4, #6]
		if (p->active) {
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 4;
    9b56:	subs	r2, r2, r7
    9b58:	lsrs	r2, r2, #4
			p->cpu_cycles = cycles;
    9b5a:	uxth	r1, r2
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
    9b5c:	cmp	r2, r3
			uint32_t cycles = ARM_DWT_CYCCNT;
			p->update();
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 4;
			p->cpu_cycles = cycles;
    9b5e:	strh	r1, [r4, #4]
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
    9b60:	it	hi
    9b62:	strhhi	r1, [r4, #6]
	uint32_t totalcycles = ARM_DWT_CYCCNT;
#elif defined(KINETISL)
	uint32_t totalcycles = micros();
#endif
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    9b64:	ldr	r4, [r4, #20]
    9b66:	b.n	9b42 <software_isr+0x1e>
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
#if defined(KINETISK)
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;
    9b68:	ldr	r3, [r5, #0]
#elif defined(KINETISL)
	totalcycles = micros() - totalcycles;
#endif
	AudioStream::cpu_cycles_total = totalcycles;
    9b6a:	ldr	r2, [pc, #36]	; (9b90 <software_isr+0x6c>)
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
#if defined(KINETISK)
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 4;
    9b6c:	subs	r3, r3, r6
    9b6e:	lsrs	r3, r3, #4
#elif defined(KINETISL)
	totalcycles = micros() - totalcycles;
#endif
	AudioStream::cpu_cycles_total = totalcycles;
    9b70:	uxth	r1, r3
    9b72:	strh	r1, [r2, #0]
	if (totalcycles > AudioStream::cpu_cycles_total_max)
    9b74:	ldr	r2, [pc, #28]	; (9b94 <software_isr+0x70>)
    9b76:	ldrh	r0, [r2, #0]
    9b78:	cmp	r3, r0
		AudioStream::cpu_cycles_total_max = totalcycles;
    9b7a:	it	hi
    9b7c:	strhhi	r1, [r2, #0]
    9b7e:	pop	{r3, r4, r5, r6, r7, pc}
    9b80:	.word	0xe000edfc
    9b84:	.word	0xe0001004
    9b88:	.word	0xe0001000
    9b8c:	.word	0x1fff8580
    9b90:	.word	0x1fff8586
    9b94:	.word	0x1fff8584

00009b98 <Stream::timedRead()>:
#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field

// private method to read stream with timeout
int Stream::timedRead()
{
    9b98:	push	{r0, r1, r4, r5, r6, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    9b9a:	ldr	r3, [pc, #48]	; (9bcc <Stream::timedRead()+0x34>)
    9b9c:	ldr	r2, [r3, #0]
    9b9e:	str	r2, [sp, #0]
	return ret;
    9ba0:	ldr	r6, [sp, #0]
    9ba2:	mov	r4, r0
    9ba4:	mov	r5, r3
  int c;
  unsigned long startMillis = millis();
  do {
    c = read();
    9ba6:	ldr	r3, [r4, #0]
    9ba8:	mov	r0, r4
    9baa:	ldr	r3, [r3, #20]
    9bac:	blx	r3
    if (c >= 0) return c;
    9bae:	cmp	r0, #0
    9bb0:	bge.n	9bc8 <Stream::timedRead()+0x30>
    yield();
    9bb2:	bl	97ec <yield>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    9bb6:	ldr	r3, [r5, #0]
    9bb8:	str	r3, [sp, #4]
	return ret;
    9bba:	ldr	r3, [sp, #4]
// private method to read stream with timeout
int Stream::timedRead()
{
  int c;
  unsigned long startMillis = millis();
  do {
    9bbc:	ldr	r2, [r4, #8]
    9bbe:	subs	r3, r3, r6
    9bc0:	cmp	r3, r2
    9bc2:	bcc.n	9ba6 <Stream::timedRead()+0xe>
    c = read();
    if (c >= 0) return c;
    yield();
  } while(millis() - startMillis < _timeout);
  return -1;     // -1 indicates timeout
    9bc4:	mov.w	r0, #4294967295
}
    9bc8:	add	sp, #8
    9bca:	pop	{r4, r5, r6, pc}
    9bcc:	.word	0x1fff8484

00009bd0 <Stream::readBytesUntil(char, char*, unsigned int)>:
// as readBytes with terminator character
// terminates if length characters have been read, timeout, or if the terminator character  detected
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
    9bd0:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    9bd4:	mov	r7, r0
    9bd6:	mov	r9, r1
	if (buffer == nullptr) return 0;
    9bd8:	mov	r5, r2
    9bda:	cbz	r2, 9c0a <Stream::readBytesUntil(char, char*, unsigned int)+0x3a>
	if (length < 1) return 0;
    9bdc:	cbz	r3, 9c0e <Stream::readBytesUntil(char, char*, unsigned int)+0x3e>
	length--;
    9bde:	add.w	r8, r3, #4294967295
    9be2:	mov	r6, r2
    9be4:	subs	r4, r6, r5
	size_t index = 0;
	while (index < length) {
    9be6:	cmp	r8, r4
    9be8:	bls.n	9c04 <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
		int c = timedRead();
    9bea:	mov	r0, r7
    9bec:	bl	9b98 <Stream::timedRead()>
		if (c == terminator) break;
    9bf0:	cmp	r0, r9
    9bf2:	beq.n	9c04 <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
		if (c < 0) {
    9bf4:	cmp	r0, #0
    9bf6:	bge.n	9bfe <Stream::readBytesUntil(char, char*, unsigned int)+0x2e>
	String readString(size_t max = 120);
	String readStringUntil(char terminator, size_t max = 120);
	int getReadError() { return read_error; }
	void clearReadError() { setReadError(0); }
  protected:
	void setReadError(int err = 1) { read_error = err; }
    9bf8:	movs	r3, #1
    9bfa:	strb	r3, [r7, #12]
    9bfc:	b.n	9c04 <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
			setReadError();
			break;
		}
		*buffer++ = (char)c;
    9bfe:	strb.w	r0, [r6], #1
{
	if (buffer == nullptr) return 0;
	if (length < 1) return 0;
	length--;
	size_t index = 0;
	while (index < length) {
    9c02:	b.n	9be4 <Stream::readBytesUntil(char, char*, unsigned int)+0x14>
			break;
		}
		*buffer++ = (char)c;
		index++;
	}
	*buffer = 0;
    9c04:	movs	r3, #0
    9c06:	strb	r3, [r6, #0]
	return index; // return number of characters, not including null terminator
    9c08:	b.n	9c10 <Stream::readBytesUntil(char, char*, unsigned int)+0x40>
// terminates if length characters have been read, timeout, or if the terminator character  detected
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
	if (buffer == nullptr) return 0;
    9c0a:	mov	r4, r2
    9c0c:	b.n	9c10 <Stream::readBytesUntil(char, char*, unsigned int)+0x40>
    9c0e:	mov	r4, r3
		*buffer++ = (char)c;
		index++;
	}
	*buffer = 0;
	return index; // return number of characters, not including null terminator
}
    9c10:	mov	r0, r4
    9c12:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00009c16 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    9c16:	bx	lr

00009c18 <operator new(unsigned int)>:
    9c18:	b.w	aad0 <malloc>

00009c1c <operator delete(void*, unsigned int)>:
    9c1c:	b.w	aae0 <free>

00009c20 <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    9c20:	push	{r0, r1, r2, r3, r4, lr}
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    9c22:	cpsid	i
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    9c24:	ldr	r3, [pc, #76]	; (9c74 <usb_init_serialnumber+0x54>)
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    9c26:	ldr	r1, [pc, #80]	; (9c78 <usb_init_serialnumber+0x58>)
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    9c28:	movs	r2, #112	; 0x70
    9c2a:	strb	r2, [r3, #0]
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    9c2c:	ldr	r2, [pc, #76]	; (9c7c <usb_init_serialnumber+0x5c>)
    9c2e:	str	r1, [r2, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    9c30:	movs	r2, #128	; 0x80
    9c32:	strb	r2, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    9c34:	ldrb	r2, [r3, #0]
    9c36:	lsls	r2, r2, #24
    9c38:	bpl.n	9c34 <usb_init_serialnumber+0x14>
	num = *(uint32_t *)&FTFL_FCCOBB;
    9c3a:	ldr	r3, [pc, #68]	; (9c80 <usb_init_serialnumber+0x60>)
    9c3c:	ldr	r0, [r3, #0]
	kinetis_hsrun_enable();
#endif
	__enable_irq();
    9c3e:	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    9c40:	ldr	r3, [pc, #64]	; (9c84 <usb_init_serialnumber+0x64>)
    9c42:	cmp	r0, r3
    9c44:	it	ls
    9c46:	movls	r3, #10
	ultoa(num, buf, 10);
    9c48:	add	r4, sp, #4
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    9c4a:	it	ls
    9c4c:	mulls	r0, r3
	ultoa(num, buf, 10);
    9c4e:	movs	r2, #10
    9c50:	mov	r1, r4
    9c52:	bl	9c90 <ultoa>
    9c56:	ldr	r2, [pc, #48]	; (9c88 <usb_init_serialnumber+0x68>)
	for (i=0; i<10; i++) {
    9c58:	movs	r3, #0
		char c = buf[i];
    9c5a:	ldrb	r1, [r4, r3]
		if (!c) break;
    9c5c:	cbz	r1, 9c68 <usb_init_serialnumber+0x48>
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    9c5e:	adds	r3, #1
    9c60:	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    9c62:	strh.w	r1, [r2], #2
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    9c66:	bne.n	9c5a <usb_init_serialnumber+0x3a>
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    9c68:	ldr	r2, [pc, #32]	; (9c8c <usb_init_serialnumber+0x6c>)
    9c6a:	adds	r3, #1
    9c6c:	lsls	r3, r3, #1
    9c6e:	strb	r3, [r2, #0]
}
    9c70:	add	sp, #16
    9c72:	pop	{r4, pc}
    9c74:	.word	0x40020000
    9c78:	.word	0x41070000
    9c7c:	.word	0x40020004
    9c80:	.word	0x4002000c
    9c84:	.word	0x0098967f
    9c88:	.word	0x1fff1404
    9c8c:	.word	0x1fff1402

00009c90 <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    9c90:	push	{r4, r5, lr}
    9c92:	mov	r3, r0
	unsigned digit;
	int i=0, j;
    9c94:	movs	r0, #0
	char t;

	while (1) {
		digit = val % radix;
    9c96:	udiv	r4, r3, r2
    9c9a:	mls	r3, r2, r4, r3
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    9c9e:	cmp	r3, #9
    9ca0:	ite	ls
    9ca2:	addls	r3, #48	; 0x30
    9ca4:	addhi	r3, #55	; 0x37
    9ca6:	uxtb	r3, r3
    9ca8:	strb	r3, [r1, r0]
		val /= radix;
		if (val == 0) break;
    9caa:	mov	r3, r4
    9cac:	cbz	r4, 9cb2 <ultoa+0x22>
		i++;
    9cae:	adds	r0, #1
	}
    9cb0:	b.n	9c96 <ultoa+0x6>
	buf[i + 1] = 0;
    9cb2:	adds	r2, r1, r0
	for (j=0; j < i; j++, i--) {
    9cb4:	mov	r3, r4
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
    9cb6:	strb	r4, [r2, #1]
	for (j=0; j < i; j++, i--) {
    9cb8:	subs	r4, r0, r3
    9cba:	cmp	r3, r4
    9cbc:	bge.n	9ccc <ultoa+0x3c>
		t = buf[j];
    9cbe:	ldrb	r4, [r1, r3]
		buf[j] = buf[i];
    9cc0:	ldrb	r5, [r2, #0]
    9cc2:	strb	r5, [r1, r3]
		buf[i] = t;
    9cc4:	strb.w	r4, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    9cc8:	adds	r3, #1
    9cca:	b.n	9cb8 <ultoa+0x28>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    9ccc:	mov	r0, r1
    9cce:	pop	{r4, r5, pc}

00009cd0 <nanf>:
    9cd0:	vldr	s0, [pc, #4]	; 9cd8 <nanf+0x8>
    9cd4:	bx	lr
    9cd6:	nop
    9cd8:	.word	0x7fc00000

00009cdc <__aeabi_atexit>:
    9cdc:	mov	r3, r1
    9cde:	mov	r1, r0
    9ce0:	mov	r0, r3
    9ce2:	b.w	aa18 <__cxa_atexit>
    9ce6:	nop

00009ce8 <__aeabi_llsr>:
    9ce8:	lsrs	r0, r2
    9cea:	adds	r3, r1, #0
    9cec:	lsrs	r1, r2
    9cee:	mov	ip, r3
    9cf0:	subs	r2, #32
    9cf2:	lsrs	r3, r2
    9cf4:	orrs	r0, r3
    9cf6:	negs	r2, r2
    9cf8:	mov	r3, ip
    9cfa:	lsls	r3, r2
    9cfc:	orrs	r0, r3
    9cfe:	bx	lr

00009d00 <__aeabi_drsub>:
    9d00:	eor.w	r1, r1, #2147483648	; 0x80000000
    9d04:	b.n	9d0c <__adddf3>
    9d06:	nop

00009d08 <__aeabi_dsub>:
    9d08:	eor.w	r3, r3, #2147483648	; 0x80000000

00009d0c <__adddf3>:
    9d0c:	push	{r4, r5, lr}
    9d0e:	mov.w	r4, r1, lsl #1
    9d12:	mov.w	r5, r3, lsl #1
    9d16:	teq	r4, r5
    9d1a:	it	eq
    9d1c:	teqeq	r0, r2
    9d20:	itttt	ne
    9d22:	orrsne.w	ip, r4, r0
    9d26:	orrsne.w	ip, r5, r2
    9d2a:	mvnsne.w	ip, r4, asr #21
    9d2e:	mvnsne.w	ip, r5, asr #21
    9d32:	beq.w	9efa <__adddf3+0x1ee>
    9d36:	mov.w	r4, r4, lsr #21
    9d3a:	rsbs	r5, r4, r5, lsr #21
    9d3e:	it	lt
    9d40:	neglt	r5, r5
    9d42:	ble.n	9d5e <__adddf3+0x52>
    9d44:	add	r4, r5
    9d46:	eor.w	r2, r0, r2
    9d4a:	eor.w	r3, r1, r3
    9d4e:	eor.w	r0, r2, r0
    9d52:	eor.w	r1, r3, r1
    9d56:	eor.w	r2, r0, r2
    9d5a:	eor.w	r3, r1, r3
    9d5e:	cmp	r5, #54	; 0x36
    9d60:	it	hi
    9d62:	pophi	{r4, r5, pc}
    9d64:	tst.w	r1, #2147483648	; 0x80000000
    9d68:	mov.w	r1, r1, lsl #12
    9d6c:	mov.w	ip, #1048576	; 0x100000
    9d70:	orr.w	r1, ip, r1, lsr #12
    9d74:	beq.n	9d7c <__adddf3+0x70>
    9d76:	negs	r0, r0
    9d78:	sbc.w	r1, r1, r1, lsl #1
    9d7c:	tst.w	r3, #2147483648	; 0x80000000
    9d80:	mov.w	r3, r3, lsl #12
    9d84:	orr.w	r3, ip, r3, lsr #12
    9d88:	beq.n	9d90 <__adddf3+0x84>
    9d8a:	negs	r2, r2
    9d8c:	sbc.w	r3, r3, r3, lsl #1
    9d90:	teq	r4, r5
    9d94:	beq.w	9ee6 <__adddf3+0x1da>
    9d98:	sub.w	r4, r4, #1
    9d9c:	rsbs	lr, r5, #32
    9da0:	blt.n	9dbe <__adddf3+0xb2>
    9da2:	lsl.w	ip, r2, lr
    9da6:	lsr.w	r2, r2, r5
    9daa:	adds	r0, r0, r2
    9dac:	adc.w	r1, r1, #0
    9db0:	lsl.w	r2, r3, lr
    9db4:	adds	r0, r0, r2
    9db6:	asr.w	r3, r3, r5
    9dba:	adcs	r1, r3
    9dbc:	b.n	9ddc <__adddf3+0xd0>
    9dbe:	sub.w	r5, r5, #32
    9dc2:	add.w	lr, lr, #32
    9dc6:	cmp	r2, #1
    9dc8:	lsl.w	ip, r3, lr
    9dcc:	it	cs
    9dce:	orrcs.w	ip, ip, #2
    9dd2:	asr.w	r3, r3, r5
    9dd6:	adds	r0, r0, r3
    9dd8:	adcs.w	r1, r1, r3, asr #31
    9ddc:	and.w	r5, r1, #2147483648	; 0x80000000
    9de0:	bpl.n	9df2 <__adddf3+0xe6>
    9de2:	mov.w	lr, #0
    9de6:	rsbs	ip, ip, #0
    9dea:	sbcs.w	r0, lr, r0
    9dee:	sbc.w	r1, lr, r1
    9df2:	cmp.w	r1, #1048576	; 0x100000
    9df6:	bcc.n	9e30 <__adddf3+0x124>
    9df8:	cmp.w	r1, #2097152	; 0x200000
    9dfc:	bcc.n	9e18 <__adddf3+0x10c>
    9dfe:	lsrs	r1, r1, #1
    9e00:	movs.w	r0, r0, rrx
    9e04:	mov.w	ip, ip, rrx
    9e08:	add.w	r4, r4, #1
    9e0c:	mov.w	r2, r4, lsl #21
    9e10:	cmn.w	r2, #4194304	; 0x400000
    9e14:	bcs.w	9f4c <__adddf3+0x240>
    9e18:	cmp.w	ip, #2147483648	; 0x80000000
    9e1c:	it	eq
    9e1e:	movseq.w	ip, r0, lsr #1
    9e22:	adcs.w	r0, r0, #0
    9e26:	adc.w	r1, r1, r4, lsl #20
    9e2a:	orr.w	r1, r1, r5
    9e2e:	pop	{r4, r5, pc}
    9e30:	movs.w	ip, ip, lsl #1
    9e34:	adcs	r0, r0
    9e36:	adc.w	r1, r1, r1
    9e3a:	tst.w	r1, #1048576	; 0x100000
    9e3e:	sub.w	r4, r4, #1
    9e42:	bne.n	9e18 <__adddf3+0x10c>
    9e44:	teq	r1, #0
    9e48:	itt	eq
    9e4a:	moveq	r1, r0
    9e4c:	moveq	r0, #0
    9e4e:	clz	r3, r1
    9e52:	it	eq
    9e54:	addeq	r3, #32
    9e56:	sub.w	r3, r3, #11
    9e5a:	subs.w	r2, r3, #32
    9e5e:	bge.n	9e7a <__adddf3+0x16e>
    9e60:	adds	r2, #12
    9e62:	ble.n	9e76 <__adddf3+0x16a>
    9e64:	add.w	ip, r2, #20
    9e68:	rsb	r2, r2, #12
    9e6c:	lsl.w	r0, r1, ip
    9e70:	lsr.w	r1, r1, r2
    9e74:	b.n	9e90 <__adddf3+0x184>
    9e76:	add.w	r2, r2, #20
    9e7a:	it	le
    9e7c:	rsble	ip, r2, #32
    9e80:	lsl.w	r1, r1, r2
    9e84:	lsr.w	ip, r0, ip
    9e88:	itt	le
    9e8a:	orrle.w	r1, r1, ip
    9e8e:	lslle	r0, r2
    9e90:	subs	r4, r4, r3
    9e92:	ittt	ge
    9e94:	addge.w	r1, r1, r4, lsl #20
    9e98:	orrge	r1, r5
    9e9a:	popge	{r4, r5, pc}
    9e9c:	mvn.w	r4, r4
    9ea0:	subs	r4, #31
    9ea2:	bge.n	9ede <__adddf3+0x1d2>
    9ea4:	adds	r4, #12
    9ea6:	bgt.n	9ec6 <__adddf3+0x1ba>
    9ea8:	add.w	r4, r4, #20
    9eac:	rsb	r2, r4, #32
    9eb0:	lsr.w	r0, r0, r4
    9eb4:	lsl.w	r3, r1, r2
    9eb8:	orr.w	r0, r0, r3
    9ebc:	lsr.w	r3, r1, r4
    9ec0:	orr.w	r1, r5, r3
    9ec4:	pop	{r4, r5, pc}
    9ec6:	rsb	r4, r4, #12
    9eca:	rsb	r2, r4, #32
    9ece:	lsr.w	r0, r0, r2
    9ed2:	lsl.w	r3, r1, r4
    9ed6:	orr.w	r0, r0, r3
    9eda:	mov	r1, r5
    9edc:	pop	{r4, r5, pc}
    9ede:	lsr.w	r0, r1, r4
    9ee2:	mov	r1, r5
    9ee4:	pop	{r4, r5, pc}
    9ee6:	teq	r4, #0
    9eea:	eor.w	r3, r3, #1048576	; 0x100000
    9eee:	itte	eq
    9ef0:	eoreq.w	r1, r1, #1048576	; 0x100000
    9ef4:	addeq	r4, #1
    9ef6:	subne	r5, #1
    9ef8:	b.n	9d98 <__adddf3+0x8c>
    9efa:	mvns.w	ip, r4, asr #21
    9efe:	it	ne
    9f00:	mvnsne.w	ip, r5, asr #21
    9f04:	beq.n	9f5a <__adddf3+0x24e>
    9f06:	teq	r4, r5
    9f0a:	it	eq
    9f0c:	teqeq	r0, r2
    9f10:	beq.n	9f1e <__adddf3+0x212>
    9f12:	orrs.w	ip, r4, r0
    9f16:	itt	eq
    9f18:	moveq	r1, r3
    9f1a:	moveq	r0, r2
    9f1c:	pop	{r4, r5, pc}
    9f1e:	teq	r1, r3
    9f22:	ittt	ne
    9f24:	movne	r1, #0
    9f26:	movne	r0, #0
    9f28:	popne	{r4, r5, pc}
    9f2a:	movs.w	ip, r4, lsr #21
    9f2e:	bne.n	9f3c <__adddf3+0x230>
    9f30:	lsls	r0, r0, #1
    9f32:	adcs	r1, r1
    9f34:	it	cs
    9f36:	orrcs.w	r1, r1, #2147483648	; 0x80000000
    9f3a:	pop	{r4, r5, pc}
    9f3c:	adds.w	r4, r4, #4194304	; 0x400000
    9f40:	itt	cc
    9f42:	addcc.w	r1, r1, #1048576	; 0x100000
    9f46:	popcc	{r4, r5, pc}
    9f48:	and.w	r5, r1, #2147483648	; 0x80000000
    9f4c:	orr.w	r1, r5, #2130706432	; 0x7f000000
    9f50:	orr.w	r1, r1, #15728640	; 0xf00000
    9f54:	mov.w	r0, #0
    9f58:	pop	{r4, r5, pc}
    9f5a:	mvns.w	ip, r4, asr #21
    9f5e:	itte	ne
    9f60:	movne	r1, r3
    9f62:	movne	r0, r2
    9f64:	mvnseq.w	ip, r5, asr #21
    9f68:	itt	ne
    9f6a:	movne	r3, r1
    9f6c:	movne	r2, r0
    9f6e:	orrs.w	r4, r0, r1, lsl #12
    9f72:	itte	eq
    9f74:	orrseq.w	r5, r2, r3, lsl #12
    9f78:	teqeq	r1, r3
    9f7c:	orrne.w	r1, r1, #524288	; 0x80000
    9f80:	pop	{r4, r5, pc}
    9f82:	nop

00009f84 <__aeabi_ui2d>:
    9f84:	teq	r0, #0
    9f88:	itt	eq
    9f8a:	moveq	r1, #0
    9f8c:	bxeq	lr
    9f8e:	push	{r4, r5, lr}
    9f90:	mov.w	r4, #1024	; 0x400
    9f94:	add.w	r4, r4, #50	; 0x32
    9f98:	mov.w	r5, #0
    9f9c:	mov.w	r1, #0
    9fa0:	b.n	9e44 <__adddf3+0x138>
    9fa2:	nop

00009fa4 <__aeabi_i2d>:
    9fa4:	teq	r0, #0
    9fa8:	itt	eq
    9faa:	moveq	r1, #0
    9fac:	bxeq	lr
    9fae:	push	{r4, r5, lr}
    9fb0:	mov.w	r4, #1024	; 0x400
    9fb4:	add.w	r4, r4, #50	; 0x32
    9fb8:	ands.w	r5, r0, #2147483648	; 0x80000000
    9fbc:	it	mi
    9fbe:	negmi	r0, r0
    9fc0:	mov.w	r1, #0
    9fc4:	b.n	9e44 <__adddf3+0x138>
    9fc6:	nop

00009fc8 <__aeabi_f2d>:
    9fc8:	lsls	r2, r0, #1
    9fca:	mov.w	r1, r2, asr #3
    9fce:	mov.w	r1, r1, rrx
    9fd2:	mov.w	r0, r2, lsl #28
    9fd6:	itttt	ne
    9fd8:	andsne.w	r3, r2, #4278190080	; 0xff000000
    9fdc:	teqne	r3, #4278190080	; 0xff000000
    9fe0:	eorne.w	r1, r1, #939524096	; 0x38000000
    9fe4:	bxne	lr
    9fe6:	teq	r2, #0
    9fea:	ite	ne
    9fec:	teqne	r3, #4278190080	; 0xff000000
    9ff0:	bxeq	lr
    9ff2:	push	{r4, r5, lr}
    9ff4:	mov.w	r4, #896	; 0x380
    9ff8:	and.w	r5, r1, #2147483648	; 0x80000000
    9ffc:	bic.w	r1, r1, #2147483648	; 0x80000000
    a000:	b.n	9e44 <__adddf3+0x138>
    a002:	nop

0000a004 <__aeabi_ul2d>:
    a004:	orrs.w	r2, r0, r1
    a008:	it	eq
    a00a:	bxeq	lr
    a00c:	push	{r4, r5, lr}
    a00e:	mov.w	r5, #0
    a012:	b.n	a02a <__aeabi_l2d+0x16>

0000a014 <__aeabi_l2d>:
    a014:	orrs.w	r2, r0, r1
    a018:	it	eq
    a01a:	bxeq	lr
    a01c:	push	{r4, r5, lr}
    a01e:	ands.w	r5, r1, #2147483648	; 0x80000000
    a022:	bpl.n	a02a <__aeabi_l2d+0x16>
    a024:	negs	r0, r0
    a026:	sbc.w	r1, r1, r1, lsl #1
    a02a:	mov.w	r4, #1024	; 0x400
    a02e:	add.w	r4, r4, #50	; 0x32
    a032:	movs.w	ip, r1, lsr #22
    a036:	beq.w	9df2 <__adddf3+0xe6>
    a03a:	mov.w	r2, #3
    a03e:	movs.w	ip, ip, lsr #3
    a042:	it	ne
    a044:	addne	r2, #3
    a046:	movs.w	ip, ip, lsr #3
    a04a:	it	ne
    a04c:	addne	r2, #3
    a04e:	add.w	r2, r2, ip, lsr #3
    a052:	rsb	r3, r2, #32
    a056:	lsl.w	ip, r0, r3
    a05a:	lsr.w	r0, r0, r2
    a05e:	lsl.w	lr, r1, r3
    a062:	orr.w	r0, r0, lr
    a066:	lsr.w	r1, r1, r2
    a06a:	add	r4, r2
    a06c:	b.n	9df2 <__adddf3+0xe6>
    a06e:	nop

0000a070 <__aeabi_dmul>:
    a070:	push	{r4, r5, r6, lr}
    a072:	mov.w	ip, #255	; 0xff
    a076:	orr.w	ip, ip, #1792	; 0x700
    a07a:	ands.w	r4, ip, r1, lsr #20
    a07e:	ittte	ne
    a080:	andsne.w	r5, ip, r3, lsr #20
    a084:	teqne	r4, ip
    a088:	teqne	r5, ip
    a08c:	bleq	a24c <__aeabi_dmul+0x1dc>
    a090:	add	r4, r5
    a092:	eor.w	r6, r1, r3
    a096:	bic.w	r1, r1, ip, lsl #21
    a09a:	bic.w	r3, r3, ip, lsl #21
    a09e:	orrs.w	r5, r0, r1, lsl #12
    a0a2:	it	ne
    a0a4:	orrsne.w	r5, r2, r3, lsl #12
    a0a8:	orr.w	r1, r1, #1048576	; 0x100000
    a0ac:	orr.w	r3, r3, #1048576	; 0x100000
    a0b0:	beq.n	a124 <__aeabi_dmul+0xb4>
    a0b2:	umull	ip, lr, r0, r2
    a0b6:	mov.w	r5, #0
    a0ba:	umlal	lr, r5, r1, r2
    a0be:	and.w	r2, r6, #2147483648	; 0x80000000
    a0c2:	umlal	lr, r5, r0, r3
    a0c6:	mov.w	r6, #0
    a0ca:	umlal	r5, r6, r1, r3
    a0ce:	teq	ip, #0
    a0d2:	it	ne
    a0d4:	orrne.w	lr, lr, #1
    a0d8:	sub.w	r4, r4, #255	; 0xff
    a0dc:	cmp.w	r6, #512	; 0x200
    a0e0:	sbc.w	r4, r4, #768	; 0x300
    a0e4:	bcs.n	a0f0 <__aeabi_dmul+0x80>
    a0e6:	movs.w	lr, lr, lsl #1
    a0ea:	adcs	r5, r5
    a0ec:	adc.w	r6, r6, r6
    a0f0:	orr.w	r1, r2, r6, lsl #11
    a0f4:	orr.w	r1, r1, r5, lsr #21
    a0f8:	mov.w	r0, r5, lsl #11
    a0fc:	orr.w	r0, r0, lr, lsr #21
    a100:	mov.w	lr, lr, lsl #11
    a104:	subs.w	ip, r4, #253	; 0xfd
    a108:	it	hi
    a10a:	cmphi.w	ip, #1792	; 0x700
    a10e:	bhi.n	a14e <__aeabi_dmul+0xde>
    a110:	cmp.w	lr, #2147483648	; 0x80000000
    a114:	it	eq
    a116:	movseq.w	lr, r0, lsr #1
    a11a:	adcs.w	r0, r0, #0
    a11e:	adc.w	r1, r1, r4, lsl #20
    a122:	pop	{r4, r5, r6, pc}
    a124:	and.w	r6, r6, #2147483648	; 0x80000000
    a128:	orr.w	r1, r6, r1
    a12c:	orr.w	r0, r0, r2
    a130:	eor.w	r1, r1, r3
    a134:	subs.w	r4, r4, ip, lsr #1
    a138:	ittt	gt
    a13a:	rsbsgt	r5, r4, ip
    a13e:	orrgt.w	r1, r1, r4, lsl #20
    a142:	popgt	{r4, r5, r6, pc}
    a144:	orr.w	r1, r1, #1048576	; 0x100000
    a148:	mov.w	lr, #0
    a14c:	subs	r4, #1
    a14e:	bgt.w	a2a8 <__aeabi_dmul+0x238>
    a152:	cmn.w	r4, #54	; 0x36
    a156:	ittt	le
    a158:	movle	r0, #0
    a15a:	andle.w	r1, r1, #2147483648	; 0x80000000
    a15e:	pople	{r4, r5, r6, pc}
    a160:	rsb	r4, r4, #0
    a164:	subs	r4, #32
    a166:	bge.n	a1d4 <__aeabi_dmul+0x164>
    a168:	adds	r4, #12
    a16a:	bgt.n	a1a4 <__aeabi_dmul+0x134>
    a16c:	add.w	r4, r4, #20
    a170:	rsb	r5, r4, #32
    a174:	lsl.w	r3, r0, r5
    a178:	lsr.w	r0, r0, r4
    a17c:	lsl.w	r2, r1, r5
    a180:	orr.w	r0, r0, r2
    a184:	and.w	r2, r1, #2147483648	; 0x80000000
    a188:	bic.w	r1, r1, #2147483648	; 0x80000000
    a18c:	adds.w	r0, r0, r3, lsr #31
    a190:	lsr.w	r6, r1, r4
    a194:	adc.w	r1, r2, r6
    a198:	orrs.w	lr, lr, r3, lsl #1
    a19c:	it	eq
    a19e:	biceq.w	r0, r0, r3, lsr #31
    a1a2:	pop	{r4, r5, r6, pc}
    a1a4:	rsb	r4, r4, #12
    a1a8:	rsb	r5, r4, #32
    a1ac:	lsl.w	r3, r0, r4
    a1b0:	lsr.w	r0, r0, r5
    a1b4:	lsl.w	r2, r1, r4
    a1b8:	orr.w	r0, r0, r2
    a1bc:	and.w	r1, r1, #2147483648	; 0x80000000
    a1c0:	adds.w	r0, r0, r3, lsr #31
    a1c4:	adc.w	r1, r1, #0
    a1c8:	orrs.w	lr, lr, r3, lsl #1
    a1cc:	it	eq
    a1ce:	biceq.w	r0, r0, r3, lsr #31
    a1d2:	pop	{r4, r5, r6, pc}
    a1d4:	rsb	r5, r4, #32
    a1d8:	lsl.w	r2, r0, r5
    a1dc:	orr.w	lr, lr, r2
    a1e0:	lsr.w	r3, r0, r4
    a1e4:	lsl.w	r2, r1, r5
    a1e8:	orr.w	r3, r3, r2
    a1ec:	lsr.w	r0, r1, r4
    a1f0:	and.w	r1, r1, #2147483648	; 0x80000000
    a1f4:	lsr.w	r2, r1, r4
    a1f8:	bic.w	r0, r0, r2
    a1fc:	add.w	r0, r0, r3, lsr #31
    a200:	orrs.w	lr, lr, r3, lsl #1
    a204:	it	eq
    a206:	biceq.w	r0, r0, r3, lsr #31
    a20a:	pop	{r4, r5, r6, pc}
    a20c:	teq	r4, #0
    a210:	bne.n	a232 <__aeabi_dmul+0x1c2>
    a212:	and.w	r6, r1, #2147483648	; 0x80000000
    a216:	lsls	r0, r0, #1
    a218:	adc.w	r1, r1, r1
    a21c:	tst.w	r1, #1048576	; 0x100000
    a220:	it	eq
    a222:	subeq	r4, #1
    a224:	beq.n	a216 <__aeabi_dmul+0x1a6>
    a226:	orr.w	r1, r1, r6
    a22a:	teq	r5, #0
    a22e:	it	ne
    a230:	bxne	lr
    a232:	and.w	r6, r3, #2147483648	; 0x80000000
    a236:	lsls	r2, r2, #1
    a238:	adc.w	r3, r3, r3
    a23c:	tst.w	r3, #1048576	; 0x100000
    a240:	it	eq
    a242:	subeq	r5, #1
    a244:	beq.n	a236 <__aeabi_dmul+0x1c6>
    a246:	orr.w	r3, r3, r6
    a24a:	bx	lr
    a24c:	teq	r4, ip
    a250:	and.w	r5, ip, r3, lsr #20
    a254:	it	ne
    a256:	teqne	r5, ip
    a25a:	beq.n	a276 <__aeabi_dmul+0x206>
    a25c:	orrs.w	r6, r0, r1, lsl #1
    a260:	it	ne
    a262:	orrsne.w	r6, r2, r3, lsl #1
    a266:	bne.n	a20c <__aeabi_dmul+0x19c>
    a268:	eor.w	r1, r1, r3
    a26c:	and.w	r1, r1, #2147483648	; 0x80000000
    a270:	mov.w	r0, #0
    a274:	pop	{r4, r5, r6, pc}
    a276:	orrs.w	r6, r0, r1, lsl #1
    a27a:	itte	eq
    a27c:	moveq	r0, r2
    a27e:	moveq	r1, r3
    a280:	orrsne.w	r6, r2, r3, lsl #1
    a284:	beq.n	a2ba <__aeabi_dmul+0x24a>
    a286:	teq	r4, ip
    a28a:	bne.n	a292 <__aeabi_dmul+0x222>
    a28c:	orrs.w	r6, r0, r1, lsl #12
    a290:	bne.n	a2ba <__aeabi_dmul+0x24a>
    a292:	teq	r5, ip
    a296:	bne.n	a2a4 <__aeabi_dmul+0x234>
    a298:	orrs.w	r6, r2, r3, lsl #12
    a29c:	itt	ne
    a29e:	movne	r0, r2
    a2a0:	movne	r1, r3
    a2a2:	bne.n	a2ba <__aeabi_dmul+0x24a>
    a2a4:	eor.w	r1, r1, r3
    a2a8:	and.w	r1, r1, #2147483648	; 0x80000000
    a2ac:	orr.w	r1, r1, #2130706432	; 0x7f000000
    a2b0:	orr.w	r1, r1, #15728640	; 0xf00000
    a2b4:	mov.w	r0, #0
    a2b8:	pop	{r4, r5, r6, pc}
    a2ba:	orr.w	r1, r1, #2130706432	; 0x7f000000
    a2be:	orr.w	r1, r1, #16252928	; 0xf80000
    a2c2:	pop	{r4, r5, r6, pc}

0000a2c4 <__aeabi_ddiv>:
    a2c4:	push	{r4, r5, r6, lr}
    a2c6:	mov.w	ip, #255	; 0xff
    a2ca:	orr.w	ip, ip, #1792	; 0x700
    a2ce:	ands.w	r4, ip, r1, lsr #20
    a2d2:	ittte	ne
    a2d4:	andsne.w	r5, ip, r3, lsr #20
    a2d8:	teqne	r4, ip
    a2dc:	teqne	r5, ip
    a2e0:	bleq	a432 <__aeabi_ddiv+0x16e>
    a2e4:	sub.w	r4, r4, r5
    a2e8:	eor.w	lr, r1, r3
    a2ec:	orrs.w	r5, r2, r3, lsl #12
    a2f0:	mov.w	r1, r1, lsl #12
    a2f4:	beq.w	a408 <__aeabi_ddiv+0x144>
    a2f8:	mov.w	r3, r3, lsl #12
    a2fc:	mov.w	r5, #268435456	; 0x10000000
    a300:	orr.w	r3, r5, r3, lsr #4
    a304:	orr.w	r3, r3, r2, lsr #24
    a308:	mov.w	r2, r2, lsl #8
    a30c:	orr.w	r5, r5, r1, lsr #4
    a310:	orr.w	r5, r5, r0, lsr #24
    a314:	mov.w	r6, r0, lsl #8
    a318:	and.w	r1, lr, #2147483648	; 0x80000000
    a31c:	cmp	r5, r3
    a31e:	it	eq
    a320:	cmpeq	r6, r2
    a322:	adc.w	r4, r4, #253	; 0xfd
    a326:	add.w	r4, r4, #768	; 0x300
    a32a:	bcs.n	a332 <__aeabi_ddiv+0x6e>
    a32c:	lsrs	r3, r3, #1
    a32e:	mov.w	r2, r2, rrx
    a332:	subs	r6, r6, r2
    a334:	sbc.w	r5, r5, r3
    a338:	lsrs	r3, r3, #1
    a33a:	mov.w	r2, r2, rrx
    a33e:	mov.w	r0, #1048576	; 0x100000
    a342:	mov.w	ip, #524288	; 0x80000
    a346:	subs.w	lr, r6, r2
    a34a:	sbcs.w	lr, r5, r3
    a34e:	ittt	cs
    a350:	subcs	r6, r6, r2
    a352:	movcs	r5, lr
    a354:	orrcs.w	r0, r0, ip
    a358:	lsrs	r3, r3, #1
    a35a:	mov.w	r2, r2, rrx
    a35e:	subs.w	lr, r6, r2
    a362:	sbcs.w	lr, r5, r3
    a366:	ittt	cs
    a368:	subcs	r6, r6, r2
    a36a:	movcs	r5, lr
    a36c:	orrcs.w	r0, r0, ip, lsr #1
    a370:	lsrs	r3, r3, #1
    a372:	mov.w	r2, r2, rrx
    a376:	subs.w	lr, r6, r2
    a37a:	sbcs.w	lr, r5, r3
    a37e:	ittt	cs
    a380:	subcs	r6, r6, r2
    a382:	movcs	r5, lr
    a384:	orrcs.w	r0, r0, ip, lsr #2
    a388:	lsrs	r3, r3, #1
    a38a:	mov.w	r2, r2, rrx
    a38e:	subs.w	lr, r6, r2
    a392:	sbcs.w	lr, r5, r3
    a396:	ittt	cs
    a398:	subcs	r6, r6, r2
    a39a:	movcs	r5, lr
    a39c:	orrcs.w	r0, r0, ip, lsr #3
    a3a0:	orrs.w	lr, r5, r6
    a3a4:	beq.n	a3d8 <__aeabi_ddiv+0x114>
    a3a6:	mov.w	r5, r5, lsl #4
    a3aa:	orr.w	r5, r5, r6, lsr #28
    a3ae:	mov.w	r6, r6, lsl #4
    a3b2:	mov.w	r3, r3, lsl #3
    a3b6:	orr.w	r3, r3, r2, lsr #29
    a3ba:	mov.w	r2, r2, lsl #3
    a3be:	movs.w	ip, ip, lsr #4
    a3c2:	bne.n	a346 <__aeabi_ddiv+0x82>
    a3c4:	tst.w	r1, #1048576	; 0x100000
    a3c8:	bne.n	a3e2 <__aeabi_ddiv+0x11e>
    a3ca:	orr.w	r1, r1, r0
    a3ce:	mov.w	r0, #0
    a3d2:	mov.w	ip, #2147483648	; 0x80000000
    a3d6:	b.n	a346 <__aeabi_ddiv+0x82>
    a3d8:	tst.w	r1, #1048576	; 0x100000
    a3dc:	itt	eq
    a3de:	orreq	r1, r0
    a3e0:	moveq	r0, #0
    a3e2:	subs.w	ip, r4, #253	; 0xfd
    a3e6:	it	hi
    a3e8:	cmphi.w	ip, #1792	; 0x700
    a3ec:	bhi.w	a14e <__aeabi_dmul+0xde>
    a3f0:	subs.w	ip, r5, r3
    a3f4:	itt	eq
    a3f6:	subseq.w	ip, r6, r2
    a3fa:	movseq.w	ip, r0, lsr #1
    a3fe:	adcs.w	r0, r0, #0
    a402:	adc.w	r1, r1, r4, lsl #20
    a406:	pop	{r4, r5, r6, pc}
    a408:	and.w	lr, lr, #2147483648	; 0x80000000
    a40c:	orr.w	r1, lr, r1, lsr #12
    a410:	adds.w	r4, r4, ip, lsr #1
    a414:	ittt	gt
    a416:	rsbsgt	r5, r4, ip
    a41a:	orrgt.w	r1, r1, r4, lsl #20
    a41e:	popgt	{r4, r5, r6, pc}
    a420:	orr.w	r1, r1, #1048576	; 0x100000
    a424:	mov.w	lr, #0
    a428:	subs	r4, #1
    a42a:	b.n	a14e <__aeabi_dmul+0xde>
    a42c:	orr.w	lr, r5, r6
    a430:	b.n	a14e <__aeabi_dmul+0xde>
    a432:	and.w	r5, ip, r3, lsr #20
    a436:	teq	r4, ip
    a43a:	it	eq
    a43c:	teqeq	r5, ip
    a440:	beq.w	a2ba <__aeabi_dmul+0x24a>
    a444:	teq	r4, ip
    a448:	bne.n	a460 <__aeabi_ddiv+0x19c>
    a44a:	orrs.w	r4, r0, r1, lsl #12
    a44e:	bne.w	a2ba <__aeabi_dmul+0x24a>
    a452:	teq	r5, ip
    a456:	bne.w	a2a4 <__aeabi_dmul+0x234>
    a45a:	mov	r0, r2
    a45c:	mov	r1, r3
    a45e:	b.n	a2ba <__aeabi_dmul+0x24a>
    a460:	teq	r5, ip
    a464:	bne.n	a474 <__aeabi_ddiv+0x1b0>
    a466:	orrs.w	r5, r2, r3, lsl #12
    a46a:	beq.w	a268 <__aeabi_dmul+0x1f8>
    a46e:	mov	r0, r2
    a470:	mov	r1, r3
    a472:	b.n	a2ba <__aeabi_dmul+0x24a>
    a474:	orrs.w	r6, r0, r1, lsl #1
    a478:	it	ne
    a47a:	orrsne.w	r6, r2, r3, lsl #1
    a47e:	bne.w	a20c <__aeabi_dmul+0x19c>
    a482:	orrs.w	r4, r0, r1, lsl #1
    a486:	bne.w	a2a4 <__aeabi_dmul+0x234>
    a48a:	orrs.w	r5, r2, r3, lsl #1
    a48e:	bne.w	a268 <__aeabi_dmul+0x1f8>
    a492:	b.n	a2ba <__aeabi_dmul+0x24a>

0000a494 <__gedf2>:
    a494:	mov.w	ip, #4294967295
    a498:	b.n	a4a8 <__cmpdf2+0x4>
    a49a:	nop

0000a49c <__ledf2>:
    a49c:	mov.w	ip, #1
    a4a0:	b.n	a4a8 <__cmpdf2+0x4>
    a4a2:	nop

0000a4a4 <__cmpdf2>:
    a4a4:	mov.w	ip, #1
    a4a8:	str.w	ip, [sp, #-4]!
    a4ac:	mov.w	ip, r1, lsl #1
    a4b0:	mvns.w	ip, ip, asr #21
    a4b4:	mov.w	ip, r3, lsl #1
    a4b8:	it	ne
    a4ba:	mvnsne.w	ip, ip, asr #21
    a4be:	beq.n	a4f8 <__cmpdf2+0x54>
    a4c0:	add	sp, #4
    a4c2:	orrs.w	ip, r0, r1, lsl #1
    a4c6:	ite	eq
    a4c8:	orrseq.w	ip, r2, r3, lsl #1
    a4cc:	teqne	r1, r3
    a4d0:	ittt	eq
    a4d2:	teqeq	r0, r2
    a4d6:	moveq	r0, #0
    a4d8:	bxeq	lr
    a4da:	cmn.w	r0, #0
    a4de:	teq	r1, r3
    a4e2:	it	pl
    a4e4:	cmppl	r1, r3
    a4e6:	it	eq
    a4e8:	cmpeq	r0, r2
    a4ea:	ite	cs
    a4ec:	asrcs	r0, r3, #31
    a4ee:	mvncc.w	r0, r3, asr #31
    a4f2:	orr.w	r0, r0, #1
    a4f6:	bx	lr
    a4f8:	mov.w	ip, r1, lsl #1
    a4fc:	mvns.w	ip, ip, asr #21
    a500:	bne.n	a508 <__cmpdf2+0x64>
    a502:	orrs.w	ip, r0, r1, lsl #12
    a506:	bne.n	a518 <__cmpdf2+0x74>
    a508:	mov.w	ip, r3, lsl #1
    a50c:	mvns.w	ip, ip, asr #21
    a510:	bne.n	a4c0 <__cmpdf2+0x1c>
    a512:	orrs.w	ip, r2, r3, lsl #12
    a516:	beq.n	a4c0 <__cmpdf2+0x1c>
    a518:	ldr.w	r0, [sp], #4
    a51c:	bx	lr
    a51e:	nop

0000a520 <__aeabi_cdrcmple>:
    a520:	mov	ip, r0
    a522:	mov	r0, r2
    a524:	mov	r2, ip
    a526:	mov	ip, r1
    a528:	mov	r1, r3
    a52a:	mov	r3, ip
    a52c:	b.n	a530 <__aeabi_cdcmpeq>
    a52e:	nop

0000a530 <__aeabi_cdcmpeq>:
    a530:	push	{r0, lr}
    a532:	bl	a4a4 <__cmpdf2>
    a536:	cmp	r0, #0
    a538:	it	mi
    a53a:	cmnmi.w	r0, #0
    a53e:	pop	{r0, pc}

0000a540 <__aeabi_dcmpeq>:
    a540:	str.w	lr, [sp, #-8]!
    a544:	bl	a530 <__aeabi_cdcmpeq>
    a548:	ite	eq
    a54a:	moveq	r0, #1
    a54c:	movne	r0, #0
    a54e:	ldr.w	pc, [sp], #8
    a552:	nop

0000a554 <__aeabi_dcmplt>:
    a554:	str.w	lr, [sp, #-8]!
    a558:	bl	a530 <__aeabi_cdcmpeq>
    a55c:	ite	cc
    a55e:	movcc	r0, #1
    a560:	movcs	r0, #0
    a562:	ldr.w	pc, [sp], #8
    a566:	nop

0000a568 <__aeabi_dcmple>:
    a568:	str.w	lr, [sp, #-8]!
    a56c:	bl	a530 <__aeabi_cdcmpeq>
    a570:	ite	ls
    a572:	movls	r0, #1
    a574:	movhi	r0, #0
    a576:	ldr.w	pc, [sp], #8
    a57a:	nop

0000a57c <__aeabi_dcmpge>:
    a57c:	str.w	lr, [sp, #-8]!
    a580:	bl	a520 <__aeabi_cdrcmple>
    a584:	ite	ls
    a586:	movls	r0, #1
    a588:	movhi	r0, #0
    a58a:	ldr.w	pc, [sp], #8
    a58e:	nop

0000a590 <__aeabi_dcmpgt>:
    a590:	str.w	lr, [sp, #-8]!
    a594:	bl	a520 <__aeabi_cdrcmple>
    a598:	ite	cc
    a59a:	movcc	r0, #1
    a59c:	movcs	r0, #0
    a59e:	ldr.w	pc, [sp], #8
    a5a2:	nop

0000a5a4 <__aeabi_dcmpun>:
    a5a4:	mov.w	ip, r1, lsl #1
    a5a8:	mvns.w	ip, ip, asr #21
    a5ac:	bne.n	a5b4 <__aeabi_dcmpun+0x10>
    a5ae:	orrs.w	ip, r0, r1, lsl #12
    a5b2:	bne.n	a5ca <__aeabi_dcmpun+0x26>
    a5b4:	mov.w	ip, r3, lsl #1
    a5b8:	mvns.w	ip, ip, asr #21
    a5bc:	bne.n	a5c4 <__aeabi_dcmpun+0x20>
    a5be:	orrs.w	ip, r2, r3, lsl #12
    a5c2:	bne.n	a5ca <__aeabi_dcmpun+0x26>
    a5c4:	mov.w	r0, #0
    a5c8:	bx	lr
    a5ca:	mov.w	r0, #1
    a5ce:	bx	lr

0000a5d0 <__aeabi_d2iz>:
    a5d0:	mov.w	r2, r1, lsl #1
    a5d4:	adds.w	r2, r2, #2097152	; 0x200000
    a5d8:	bcs.n	a606 <__aeabi_d2iz+0x36>
    a5da:	bpl.n	a600 <__aeabi_d2iz+0x30>
    a5dc:	mvn.w	r3, #992	; 0x3e0
    a5e0:	subs.w	r2, r3, r2, asr #21
    a5e4:	bls.n	a60c <__aeabi_d2iz+0x3c>
    a5e6:	mov.w	r3, r1, lsl #11
    a5ea:	orr.w	r3, r3, #2147483648	; 0x80000000
    a5ee:	orr.w	r3, r3, r0, lsr #21
    a5f2:	tst.w	r1, #2147483648	; 0x80000000
    a5f6:	lsr.w	r0, r3, r2
    a5fa:	it	ne
    a5fc:	negne	r0, r0
    a5fe:	bx	lr
    a600:	mov.w	r0, #0
    a604:	bx	lr
    a606:	orrs.w	r0, r0, r1, lsl #12
    a60a:	bne.n	a618 <__aeabi_d2iz+0x48>
    a60c:	ands.w	r0, r1, #2147483648	; 0x80000000
    a610:	it	eq
    a612:	mvneq.w	r0, #2147483648	; 0x80000000
    a616:	bx	lr
    a618:	mov.w	r0, #0
    a61c:	bx	lr
    a61e:	nop

0000a620 <__aeabi_d2uiz>:
    a620:	lsls	r2, r1, #1
    a622:	bcs.n	a648 <__aeabi_d2uiz+0x28>
    a624:	adds.w	r2, r2, #2097152	; 0x200000
    a628:	bcs.n	a64e <__aeabi_d2uiz+0x2e>
    a62a:	bpl.n	a648 <__aeabi_d2uiz+0x28>
    a62c:	mvn.w	r3, #992	; 0x3e0
    a630:	subs.w	r2, r3, r2, asr #21
    a634:	bmi.n	a654 <__aeabi_d2uiz+0x34>
    a636:	mov.w	r3, r1, lsl #11
    a63a:	orr.w	r3, r3, #2147483648	; 0x80000000
    a63e:	orr.w	r3, r3, r0, lsr #21
    a642:	lsr.w	r0, r3, r2
    a646:	bx	lr
    a648:	mov.w	r0, #0
    a64c:	bx	lr
    a64e:	orrs.w	r0, r0, r1, lsl #12
    a652:	bne.n	a65a <__aeabi_d2uiz+0x3a>
    a654:	mov.w	r0, #4294967295
    a658:	bx	lr
    a65a:	mov.w	r0, #0
    a65e:	bx	lr

0000a660 <__aeabi_d2f>:
    a660:	mov.w	r2, r1, lsl #1
    a664:	subs.w	r3, r2, #1879048192	; 0x70000000
    a668:	itt	cs
    a66a:	subscs.w	ip, r3, #2097152	; 0x200000
    a66e:	rsbscs	ip, ip, #532676608	; 0x1fc00000
    a672:	bls.n	a690 <__aeabi_d2f+0x30>
    a674:	and.w	ip, r1, #2147483648	; 0x80000000
    a678:	mov.w	r2, r0, lsl #3
    a67c:	orr.w	r0, ip, r0, lsr #29
    a680:	cmp.w	r2, #2147483648	; 0x80000000
    a684:	adc.w	r0, r0, r3, lsl #2
    a688:	it	eq
    a68a:	biceq.w	r0, r0, #1
    a68e:	bx	lr
    a690:	tst.w	r1, #1073741824	; 0x40000000
    a694:	bne.n	a6da <__aeabi_d2f+0x7a>
    a696:	adds.w	r2, r3, #48234496	; 0x2e00000
    a69a:	itt	lt
    a69c:	andlt.w	r0, r1, #2147483648	; 0x80000000
    a6a0:	bxlt	lr
    a6a2:	orr.w	r1, r1, #1048576	; 0x100000
    a6a6:	mov.w	r2, r2, lsr #21
    a6aa:	rsb	r2, r2, #24
    a6ae:	rsb	ip, r2, #32
    a6b2:	lsls.w	r3, r0, ip
    a6b6:	lsr.w	r0, r0, r2
    a6ba:	it	ne
    a6bc:	orrne.w	r0, r0, #1
    a6c0:	mov.w	r3, r1, lsl #11
    a6c4:	mov.w	r3, r3, lsr #11
    a6c8:	lsl.w	ip, r3, ip
    a6cc:	orr.w	r0, r0, ip
    a6d0:	lsr.w	r3, r3, r2
    a6d4:	mov.w	r3, r3, lsl #1
    a6d8:	b.n	a674 <__aeabi_d2f+0x14>
    a6da:	mvns.w	r3, r2, asr #21
    a6de:	bne.n	a6f0 <__aeabi_d2f+0x90>
    a6e0:	orrs.w	r3, r0, r1, lsl #12
    a6e4:	ittt	ne
    a6e6:	movne.w	r0, #2130706432	; 0x7f000000
    a6ea:	orrne.w	r0, r0, #12582912	; 0xc00000
    a6ee:	bxne	lr
    a6f0:	and.w	r0, r1, #2147483648	; 0x80000000
    a6f4:	orr.w	r0, r0, #2130706432	; 0x7f000000
    a6f8:	orr.w	r0, r0, #8388608	; 0x800000
    a6fc:	bx	lr
    a6fe:	nop

0000a700 <__aeabi_uldivmod>:
    a700:	cbnz	r3, a718 <__aeabi_uldivmod+0x18>
    a702:	cbnz	r2, a718 <__aeabi_uldivmod+0x18>
    a704:	cmp	r1, #0
    a706:	it	eq
    a708:	cmpeq	r0, #0
    a70a:	itt	ne
    a70c:	movne.w	r1, #4294967295
    a710:	movne.w	r0, #4294967295
    a714:	b.w	aa14 <__aeabi_idiv0>
    a718:	sub.w	ip, sp, #8
    a71c:	strd	ip, lr, [sp, #-16]!
    a720:	bl	a730 <__udivmoddi4>
    a724:	ldr.w	lr, [sp, #4]
    a728:	ldrd	r2, r3, [sp, #8]
    a72c:	add	sp, #16
    a72e:	bx	lr

0000a730 <__udivmoddi4>:
    a730:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a734:	mov	ip, r1
    a736:	mov	r6, r1
    a738:	mov	r4, r0
    a73a:	ldr	r5, [sp, #32]
    a73c:	cmp	r3, #0
    a73e:	bne.n	a7e2 <__udivmoddi4+0xb2>
    a740:	cmp	r2, r1
    a742:	mov	r7, r2
    a744:	bls.n	a820 <__udivmoddi4+0xf0>
    a746:	clz	lr, r2
    a74a:	cmp.w	lr, #0
    a74e:	beq.n	a768 <__udivmoddi4+0x38>
    a750:	rsb	r4, lr, #32
    a754:	lsr.w	r4, r0, r4
    a758:	lsl.w	r6, r1, lr
    a75c:	orr.w	ip, r4, r6
    a760:	lsl.w	r7, r2, lr
    a764:	lsl.w	r4, r0, lr
    a768:	mov.w	r9, r7, lsr #16
    a76c:	lsrs	r2, r4, #16
    a76e:	udiv	r0, ip, r9
    a772:	uxth.w	r8, r7
    a776:	mls	r6, r9, r0, ip
    a77a:	orr.w	r6, r2, r6, lsl #16
    a77e:	mul.w	r3, r0, r8
    a782:	cmp	r3, r6
    a784:	bls.n	a79a <__udivmoddi4+0x6a>
    a786:	adds	r6, r6, r7
    a788:	add.w	r2, r0, #4294967295
    a78c:	bcs.w	a9d4 <__udivmoddi4+0x2a4>
    a790:	cmp	r3, r6
    a792:	bls.w	a9d4 <__udivmoddi4+0x2a4>
    a796:	subs	r0, #2
    a798:	add	r6, r7
    a79a:	subs	r6, r6, r3
    a79c:	uxth	r2, r4
    a79e:	udiv	r3, r6, r9
    a7a2:	mls	r6, r9, r3, r6
    a7a6:	orr.w	r4, r2, r6, lsl #16
    a7aa:	mul.w	r8, r3, r8
    a7ae:	cmp	r8, r4
    a7b0:	bls.n	a7c6 <__udivmoddi4+0x96>
    a7b2:	adds	r4, r4, r7
    a7b4:	add.w	r2, r3, #4294967295
    a7b8:	bcs.w	a9d0 <__udivmoddi4+0x2a0>
    a7bc:	cmp	r8, r4
    a7be:	bls.w	a9d0 <__udivmoddi4+0x2a0>
    a7c2:	subs	r3, #2
    a7c4:	add	r4, r7
    a7c6:	rsb	r4, r8, r4
    a7ca:	orr.w	r0, r3, r0, lsl #16
    a7ce:	movs	r1, #0
    a7d0:	cmp	r5, #0
    a7d2:	beq.n	a89a <__udivmoddi4+0x16a>
    a7d4:	lsr.w	r4, r4, lr
    a7d8:	movs	r3, #0
    a7da:	str	r4, [r5, #0]
    a7dc:	str	r3, [r5, #4]
    a7de:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a7e2:	cmp	r3, r1
    a7e4:	bls.n	a7f6 <__udivmoddi4+0xc6>
    a7e6:	cmp	r5, #0
    a7e8:	beq.n	a896 <__udivmoddi4+0x166>
    a7ea:	movs	r1, #0
    a7ec:	stmia.w	r5, {r0, r6}
    a7f0:	mov	r0, r1
    a7f2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a7f6:	clz	r1, r3
    a7fa:	cmp	r1, #0
    a7fc:	bne.w	a920 <__udivmoddi4+0x1f0>
    a800:	cmp	r3, r6
    a802:	bcc.n	a80a <__udivmoddi4+0xda>
    a804:	cmp	r2, r0
    a806:	bhi.w	a9fa <__udivmoddi4+0x2ca>
    a80a:	subs	r4, r0, r2
    a80c:	sbc.w	r6, r6, r3
    a810:	movs	r0, #1
    a812:	mov	ip, r6
    a814:	cmp	r5, #0
    a816:	beq.n	a89a <__udivmoddi4+0x16a>
    a818:	stmia.w	r5, {r4, ip}
    a81c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a820:	cbnz	r2, a828 <__udivmoddi4+0xf8>
    a822:	movs	r7, #1
    a824:	udiv	r7, r7, r2
    a828:	clz	lr, r7
    a82c:	cmp.w	lr, #0
    a830:	bne.n	a89e <__udivmoddi4+0x16e>
    a832:	subs	r3, r6, r7
    a834:	mov.w	r8, r7, lsr #16
    a838:	uxth.w	ip, r7
    a83c:	movs	r1, #1
    a83e:	udiv	r0, r3, r8
    a842:	lsrs	r2, r4, #16
    a844:	mls	r6, r8, r0, r3
    a848:	orr.w	r6, r2, r6, lsl #16
    a84c:	mul.w	r3, ip, r0
    a850:	cmp	r3, r6
    a852:	bls.n	a864 <__udivmoddi4+0x134>
    a854:	adds	r6, r6, r7
    a856:	add.w	r2, r0, #4294967295
    a85a:	bcs.n	a862 <__udivmoddi4+0x132>
    a85c:	cmp	r3, r6
    a85e:	bhi.w	a9fe <__udivmoddi4+0x2ce>
    a862:	mov	r0, r2
    a864:	subs	r6, r6, r3
    a866:	uxth	r2, r4
    a868:	udiv	r3, r6, r8
    a86c:	mls	r6, r8, r3, r6
    a870:	orr.w	r4, r2, r6, lsl #16
    a874:	mul.w	ip, ip, r3
    a878:	cmp	ip, r4
    a87a:	bls.n	a88c <__udivmoddi4+0x15c>
    a87c:	adds	r4, r4, r7
    a87e:	add.w	r2, r3, #4294967295
    a882:	bcs.n	a88a <__udivmoddi4+0x15a>
    a884:	cmp	ip, r4
    a886:	bhi.w	a9f4 <__udivmoddi4+0x2c4>
    a88a:	mov	r3, r2
    a88c:	rsb	r4, ip, r4
    a890:	orr.w	r0, r3, r0, lsl #16
    a894:	b.n	a7d0 <__udivmoddi4+0xa0>
    a896:	mov	r1, r5
    a898:	mov	r0, r5
    a89a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a89e:	rsb	r1, lr, #32
    a8a2:	lsl.w	r3, r6, lr
    a8a6:	lsl.w	r7, r7, lr
    a8aa:	lsr.w	r9, r0, r1
    a8ae:	mov.w	r8, r7, lsr #16
    a8b2:	lsrs	r6, r1
    a8b4:	orr.w	r9, r9, r3
    a8b8:	udiv	sl, r6, r8
    a8bc:	mov.w	r4, r9, lsr #16
    a8c0:	mls	r6, r8, sl, r6
    a8c4:	uxth.w	ip, r7
    a8c8:	orr.w	r3, r4, r6, lsl #16
    a8cc:	mul.w	r2, sl, ip
    a8d0:	cmp	r2, r3
    a8d2:	lsl.w	r4, r0, lr
    a8d6:	bls.n	a8ee <__udivmoddi4+0x1be>
    a8d8:	adds	r3, r3, r7
    a8da:	add.w	r1, sl, #4294967295
    a8de:	bcs.w	a9f0 <__udivmoddi4+0x2c0>
    a8e2:	cmp	r2, r3
    a8e4:	bls.w	a9f0 <__udivmoddi4+0x2c0>
    a8e8:	sub.w	sl, sl, #2
    a8ec:	add	r3, r7
    a8ee:	subs	r3, r3, r2
    a8f0:	uxth.w	r9, r9
    a8f4:	udiv	r1, r3, r8
    a8f8:	mls	r3, r8, r1, r3
    a8fc:	orr.w	r3, r9, r3, lsl #16
    a900:	mul.w	r6, r1, ip
    a904:	cmp	r6, r3
    a906:	bls.n	a918 <__udivmoddi4+0x1e8>
    a908:	adds	r3, r3, r7
    a90a:	add.w	r2, r1, #4294967295
    a90e:	bcs.n	a9e8 <__udivmoddi4+0x2b8>
    a910:	cmp	r6, r3
    a912:	bls.n	a9e8 <__udivmoddi4+0x2b8>
    a914:	subs	r1, #2
    a916:	add	r3, r7
    a918:	subs	r3, r3, r6
    a91a:	orr.w	r1, r1, sl, lsl #16
    a91e:	b.n	a83e <__udivmoddi4+0x10e>
    a920:	rsb	lr, r1, #32
    a924:	lsr.w	r4, r2, lr
    a928:	lsls	r3, r1
    a92a:	orrs	r3, r4
    a92c:	lsr.w	r7, r0, lr
    a930:	lsl.w	r4, r6, r1
    a934:	mov.w	ip, r3, lsr #16
    a938:	lsr.w	r6, r6, lr
    a93c:	orrs	r4, r7
    a93e:	udiv	r9, r6, ip
    a942:	lsrs	r7, r4, #16
    a944:	mls	r6, ip, r9, r6
    a948:	uxth.w	r8, r3
    a94c:	orr.w	r6, r7, r6, lsl #16
    a950:	mul.w	r7, r9, r8
    a954:	cmp	r7, r6
    a956:	lsl.w	r2, r2, r1
    a95a:	lsl.w	sl, r0, r1
    a95e:	bls.n	a972 <__udivmoddi4+0x242>
    a960:	adds	r6, r6, r3
    a962:	add.w	r0, r9, #4294967295
    a966:	bcs.n	a9ec <__udivmoddi4+0x2bc>
    a968:	cmp	r7, r6
    a96a:	bls.n	a9ec <__udivmoddi4+0x2bc>
    a96c:	sub.w	r9, r9, #2
    a970:	add	r6, r3
    a972:	subs	r6, r6, r7
    a974:	uxth	r0, r4
    a976:	udiv	r4, r6, ip
    a97a:	mls	r6, ip, r4, r6
    a97e:	orr.w	r7, r0, r6, lsl #16
    a982:	mul.w	r8, r4, r8
    a986:	cmp	r8, r7
    a988:	bls.n	a99a <__udivmoddi4+0x26a>
    a98a:	adds	r7, r7, r3
    a98c:	add.w	r0, r4, #4294967295
    a990:	bcs.n	a9e4 <__udivmoddi4+0x2b4>
    a992:	cmp	r8, r7
    a994:	bls.n	a9e4 <__udivmoddi4+0x2b4>
    a996:	subs	r4, #2
    a998:	add	r7, r3
    a99a:	orr.w	r0, r4, r9, lsl #16
    a99e:	rsb	r7, r8, r7
    a9a2:	umull	r8, r9, r0, r2
    a9a6:	cmp	r7, r9
    a9a8:	mov	r4, r8
    a9aa:	mov	r6, r9
    a9ac:	bcc.n	a9d8 <__udivmoddi4+0x2a8>
    a9ae:	beq.n	aa04 <__udivmoddi4+0x2d4>
    a9b0:	cbz	r5, aa0c <__udivmoddi4+0x2dc>
    a9b2:	subs.w	r3, sl, r4
    a9b6:	sbc.w	r7, r7, r6
    a9ba:	lsl.w	lr, r7, lr
    a9be:	lsrs	r3, r1
    a9c0:	lsrs	r7, r1
    a9c2:	orr.w	r3, lr, r3
    a9c6:	stmia.w	r5, {r3, r7}
    a9ca:	movs	r1, #0
    a9cc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    a9d0:	mov	r3, r2
    a9d2:	b.n	a7c6 <__udivmoddi4+0x96>
    a9d4:	mov	r0, r2
    a9d6:	b.n	a79a <__udivmoddi4+0x6a>
    a9d8:	subs.w	r4, r8, r2
    a9dc:	sbc.w	r6, r9, r3
    a9e0:	subs	r0, #1
    a9e2:	b.n	a9b0 <__udivmoddi4+0x280>
    a9e4:	mov	r4, r0
    a9e6:	b.n	a99a <__udivmoddi4+0x26a>
    a9e8:	mov	r1, r2
    a9ea:	b.n	a918 <__udivmoddi4+0x1e8>
    a9ec:	mov	r9, r0
    a9ee:	b.n	a972 <__udivmoddi4+0x242>
    a9f0:	mov	sl, r1
    a9f2:	b.n	a8ee <__udivmoddi4+0x1be>
    a9f4:	subs	r3, #2
    a9f6:	add	r4, r7
    a9f8:	b.n	a88c <__udivmoddi4+0x15c>
    a9fa:	mov	r0, r1
    a9fc:	b.n	a814 <__udivmoddi4+0xe4>
    a9fe:	subs	r0, #2
    aa00:	add	r6, r7
    aa02:	b.n	a864 <__udivmoddi4+0x134>
    aa04:	cmp	sl, r8
    aa06:	bcc.n	a9d8 <__udivmoddi4+0x2a8>
    aa08:	mov	r6, r7
    aa0a:	b.n	a9b0 <__udivmoddi4+0x280>
    aa0c:	mov	r1, r5
    aa0e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    aa12:	nop

0000aa14 <__aeabi_idiv0>:
    aa14:	bx	lr
    aa16:	nop

0000aa18 <__cxa_atexit>:
    aa18:	mov	r3, r2
    aa1a:	mov	r2, r1
    aa1c:	mov	r1, r0
    aa1e:	movs	r0, #2
    aa20:	b.w	ef68 <__register_exitproc>

0000aa24 <__errno>:
    aa24:	ldr	r3, [pc, #4]	; (aa2c <__errno+0x8>)
    aa26:	ldr	r0, [r3, #0]
    aa28:	bx	lr
    aa2a:	nop
    aa2c:	.word	0x1fff1840

0000aa30 <__libc_init_array>:
    aa30:	push	{r4, r5, r6, lr}
    aa32:	ldr	r6, [pc, #60]	; (aa70 <__libc_init_array+0x40>)
    aa34:	ldr	r5, [pc, #60]	; (aa74 <__libc_init_array+0x44>)
    aa36:	subs	r6, r6, r5
    aa38:	asrs	r6, r6, #2
    aa3a:	it	ne
    aa3c:	movne	r4, #0
    aa3e:	beq.n	aa4c <__libc_init_array+0x1c>
    aa40:	adds	r4, #1
    aa42:	ldr.w	r3, [r5], #4
    aa46:	blx	r3
    aa48:	cmp	r6, r4
    aa4a:	bne.n	aa40 <__libc_init_array+0x10>
    aa4c:	ldr	r6, [pc, #40]	; (aa78 <__libc_init_array+0x48>)
    aa4e:	ldr	r5, [pc, #44]	; (aa7c <__libc_init_array+0x4c>)
    aa50:	subs	r6, r6, r5
    aa52:	bl	12cfc <_init>
    aa56:	asrs	r6, r6, #2
    aa58:	it	ne
    aa5a:	movne	r4, #0
    aa5c:	beq.n	aa6c <__libc_init_array+0x3c>
    aa5e:	adds	r4, #1
    aa60:	ldr.w	r3, [r5], #4
    aa64:	blx	r3
    aa66:	cmp	r6, r4
    aa68:	bne.n	aa5e <__libc_init_array+0x2e>
    aa6a:	pop	{r4, r5, r6, pc}
    aa6c:	pop	{r4, r5, r6, pc}
    aa6e:	nop
    aa70:	.word	0x00012d08
    aa74:	.word	0x00012d08
    aa78:	.word	0x00012d5c
    aa7c:	.word	0x00012d08

0000aa80 <__get_current_locale>:
    aa80:	ldr	r2, [pc, #12]	; (aa90 <__get_current_locale+0x10>)
    aa82:	ldr	r3, [pc, #16]	; (aa94 <__get_current_locale+0x14>)
    aa84:	ldr	r2, [r2, #0]
    aa86:	ldr	r0, [r2, #52]	; 0x34
    aa88:	cmp	r0, #0
    aa8a:	it	eq
    aa8c:	moveq	r0, r3
    aa8e:	bx	lr
    aa90:	.word	0x1fff1840
    aa94:	.word	0x1fff1844

0000aa98 <__locale_mb_cur_max>:
    aa98:	ldr	r3, [pc, #16]	; (aaac <__locale_mb_cur_max+0x14>)
    aa9a:	ldr	r2, [pc, #20]	; (aab0 <__locale_mb_cur_max+0x18>)
    aa9c:	ldr	r3, [r3, #0]
    aa9e:	ldr	r3, [r3, #52]	; 0x34
    aaa0:	cmp	r3, #0
    aaa2:	it	eq
    aaa4:	moveq	r3, r2
    aaa6:	ldrb.w	r0, [r3, #296]	; 0x128
    aaaa:	bx	lr
    aaac:	.word	0x1fff1840
    aab0:	.word	0x1fff1844

0000aab4 <__locale_ctype_ptr_l>:
    aab4:	ldr.w	r0, [r0, #236]	; 0xec
    aab8:	bx	lr
    aaba:	nop

0000aabc <__locale_ctype_ptr>:
    aabc:	push	{r3, lr}
    aabe:	ldr	r3, [pc, #12]	; (aacc <__locale_ctype_ptr+0x10>)
    aac0:	ldr	r0, [r3, #0]
    aac2:	bl	aa80 <__get_current_locale>
    aac6:	ldr.w	r0, [r0, #236]	; 0xec
    aaca:	pop	{r3, pc}
    aacc:	.word	0x1fff1840

0000aad0 <malloc>:
    aad0:	ldr	r3, [pc, #8]	; (aadc <malloc+0xc>)
    aad2:	mov	r1, r0
    aad4:	ldr	r0, [r3, #0]
    aad6:	b.w	aaf0 <_malloc_r>
    aada:	nop
    aadc:	.word	0x1fff1840

0000aae0 <free>:
    aae0:	ldr	r3, [pc, #8]	; (aaec <free+0xc>)
    aae2:	mov	r1, r0
    aae4:	ldr	r0, [r3, #0]
    aae6:	b.w	10050 <_free_r>
    aaea:	nop
    aaec:	.word	0x1fff1840

0000aaf0 <_malloc_r>:
    aaf0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    aaf4:	add.w	r5, r1, #11
    aaf8:	cmp	r5, #22
    aafa:	sub	sp, #12
    aafc:	mov	r6, r0
    aafe:	bls.w	ac40 <_malloc_r+0x150>
    ab02:	bics.w	r5, r5, #7
    ab06:	bmi.w	ac88 <_malloc_r+0x198>
    ab0a:	cmp	r1, r5
    ab0c:	bhi.w	ac88 <_malloc_r+0x198>
    ab10:	bl	b25c <__malloc_lock>
    ab14:	cmp.w	r5, #504	; 0x1f8
    ab18:	bcc.w	b054 <_malloc_r+0x564>
    ab1c:	lsrs	r3, r5, #9
    ab1e:	beq.w	ac96 <_malloc_r+0x1a6>
    ab22:	cmp	r3, #4
    ab24:	bhi.w	ae2e <_malloc_r+0x33e>
    ab28:	lsrs	r0, r5, #6
    ab2a:	add.w	lr, r0, #57	; 0x39
    ab2e:	mov.w	r3, lr, lsl #1
    ab32:	adds	r0, #56	; 0x38
    ab34:	ldr	r7, [pc, #784]	; (ae48 <_malloc_r+0x358>)
    ab36:	add.w	r3, r7, r3, lsl #2
    ab3a:	sub.w	r1, r3, #8
    ab3e:	ldr	r4, [r3, #4]
    ab40:	cmp	r1, r4
    ab42:	bne.n	ab54 <_malloc_r+0x64>
    ab44:	b.n	aca0 <_malloc_r+0x1b0>
    ab46:	cmp	r2, #0
    ab48:	bge.w	aca4 <_malloc_r+0x1b4>
    ab4c:	ldr	r4, [r4, #12]
    ab4e:	cmp	r1, r4
    ab50:	beq.w	aca0 <_malloc_r+0x1b0>
    ab54:	ldr	r3, [r4, #4]
    ab56:	bic.w	r3, r3, #3
    ab5a:	subs	r2, r3, r5
    ab5c:	cmp	r2, #15
    ab5e:	ble.n	ab46 <_malloc_r+0x56>
    ab60:	ldr	r1, [pc, #740]	; (ae48 <_malloc_r+0x358>)
    ab62:	ldr	r4, [r7, #16]
    ab64:	add.w	lr, r1, #8
    ab68:	cmp	r4, lr
    ab6a:	beq.w	aed4 <_malloc_r+0x3e4>
    ab6e:	ldr	r3, [r4, #4]
    ab70:	bic.w	r3, r3, #3
    ab74:	subs	r2, r3, r5
    ab76:	cmp	r2, #15
    ab78:	bgt.w	aeae <_malloc_r+0x3be>
    ab7c:	cmp	r2, #0
    ab7e:	str.w	lr, [r1, #20]
    ab82:	str.w	lr, [r1, #16]
    ab86:	bge.w	acc6 <_malloc_r+0x1d6>
    ab8a:	cmp.w	r3, #512	; 0x200
    ab8e:	bcs.w	ae60 <_malloc_r+0x370>
    ab92:	lsrs	r3, r3, #3
    ab94:	add.w	ip, r3, #1
    ab98:	movs	r2, #1
    ab9a:	asrs	r3, r3, #2
    ab9c:	lsl.w	r3, r2, r3
    aba0:	ldr	r2, [r1, #4]
    aba2:	ldr.w	r8, [r1, ip, lsl #3]
    aba6:	str.w	r8, [r4, #8]
    abaa:	add.w	r9, r1, ip, lsl #3
    abae:	orrs	r2, r3
    abb0:	sub.w	r3, r9, #8
    abb4:	str	r3, [r4, #12]
    abb6:	str	r2, [r1, #4]
    abb8:	str.w	r4, [r1, ip, lsl #3]
    abbc:	str.w	r4, [r8, #12]
    abc0:	asrs	r3, r0, #2
    abc2:	movs	r4, #1
    abc4:	lsls	r4, r3
    abc6:	cmp	r4, r2
    abc8:	bhi.w	ace0 <_malloc_r+0x1f0>
    abcc:	tst	r4, r2
    abce:	bne.n	abde <_malloc_r+0xee>
    abd0:	bic.w	r0, r0, #3
    abd4:	lsls	r4, r4, #1
    abd6:	tst	r4, r2
    abd8:	add.w	r0, r0, #4
    abdc:	beq.n	abd4 <_malloc_r+0xe4>
    abde:	add.w	r9, r7, r0, lsl #3
    abe2:	mov	ip, r9
    abe4:	mov	r8, r0
    abe6:	ldr.w	r1, [ip, #12]
    abea:	cmp	ip, r1
    abec:	bne.n	abfe <_malloc_r+0x10e>
    abee:	b.n	aed8 <_malloc_r+0x3e8>
    abf0:	cmp	r2, #0
    abf2:	bge.w	aef8 <_malloc_r+0x408>
    abf6:	ldr	r1, [r1, #12]
    abf8:	cmp	ip, r1
    abfa:	beq.w	aed8 <_malloc_r+0x3e8>
    abfe:	ldr	r3, [r1, #4]
    ac00:	bic.w	r3, r3, #3
    ac04:	subs	r2, r3, r5
    ac06:	cmp	r2, #15
    ac08:	ble.n	abf0 <_malloc_r+0x100>
    ac0a:	mov	r4, r1
    ac0c:	ldr.w	ip, [r1, #12]
    ac10:	ldr.w	r8, [r4, #8]!
    ac14:	adds	r3, r1, r5
    ac16:	orr.w	r5, r5, #1
    ac1a:	str	r5, [r1, #4]
    ac1c:	orr.w	r1, r2, #1
    ac20:	str.w	ip, [r8, #12]
    ac24:	mov	r0, r6
    ac26:	str.w	r8, [ip, #8]
    ac2a:	str	r3, [r7, #20]
    ac2c:	str	r3, [r7, #16]
    ac2e:	str.w	lr, [r3, #12]
    ac32:	str.w	lr, [r3, #8]
    ac36:	str	r1, [r3, #4]
    ac38:	str	r2, [r3, r2]
    ac3a:	bl	b260 <__malloc_unlock>
    ac3e:	b.n	ac80 <_malloc_r+0x190>
    ac40:	cmp	r1, #16
    ac42:	bhi.n	ac88 <_malloc_r+0x198>
    ac44:	bl	b25c <__malloc_lock>
    ac48:	movs	r5, #16
    ac4a:	movs	r3, #6
    ac4c:	movs	r0, #2
    ac4e:	ldr	r7, [pc, #504]	; (ae48 <_malloc_r+0x358>)
    ac50:	add.w	r3, r7, r3, lsl #2
    ac54:	sub.w	r2, r3, #8
    ac58:	ldr	r4, [r3, #4]
    ac5a:	cmp	r4, r2
    ac5c:	beq.w	aeea <_malloc_r+0x3fa>
    ac60:	ldr	r3, [r4, #4]
    ac62:	ldr	r1, [r4, #12]
    ac64:	ldr	r5, [r4, #8]
    ac66:	bic.w	r3, r3, #3
    ac6a:	add	r3, r4
    ac6c:	mov	r0, r6
    ac6e:	ldr	r2, [r3, #4]
    ac70:	str	r1, [r5, #12]
    ac72:	orr.w	r2, r2, #1
    ac76:	str	r5, [r1, #8]
    ac78:	str	r2, [r3, #4]
    ac7a:	bl	b260 <__malloc_unlock>
    ac7e:	adds	r4, #8
    ac80:	mov	r0, r4
    ac82:	add	sp, #12
    ac84:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ac88:	movs	r4, #0
    ac8a:	movs	r3, #12
    ac8c:	mov	r0, r4
    ac8e:	str	r3, [r6, #0]
    ac90:	add	sp, #12
    ac92:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ac96:	movs	r3, #128	; 0x80
    ac98:	mov.w	lr, #64	; 0x40
    ac9c:	movs	r0, #63	; 0x3f
    ac9e:	b.n	ab34 <_malloc_r+0x44>
    aca0:	mov	r0, lr
    aca2:	b.n	ab60 <_malloc_r+0x70>
    aca4:	add	r3, r4
    aca6:	ldr	r1, [r4, #12]
    aca8:	ldr	r2, [r3, #4]
    acaa:	ldr	r5, [r4, #8]
    acac:	orr.w	r2, r2, #1
    acb0:	str	r1, [r5, #12]
    acb2:	mov	r0, r6
    acb4:	str	r5, [r1, #8]
    acb6:	str	r2, [r3, #4]
    acb8:	bl	b260 <__malloc_unlock>
    acbc:	adds	r4, #8
    acbe:	mov	r0, r4
    acc0:	add	sp, #12
    acc2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    acc6:	add	r3, r4
    acc8:	mov	r0, r6
    acca:	ldr	r2, [r3, #4]
    accc:	orr.w	r2, r2, #1
    acd0:	str	r2, [r3, #4]
    acd2:	bl	b260 <__malloc_unlock>
    acd6:	adds	r4, #8
    acd8:	mov	r0, r4
    acda:	add	sp, #12
    acdc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ace0:	ldr	r4, [r7, #8]
    ace2:	ldr	r3, [r4, #4]
    ace4:	bic.w	r8, r3, #3
    ace8:	cmp	r8, r5
    acea:	bcc.n	acf6 <_malloc_r+0x206>
    acec:	rsb	r3, r5, r8
    acf0:	cmp	r3, #15
    acf2:	bgt.w	ae0e <_malloc_r+0x31e>
    acf6:	ldr	r3, [pc, #340]	; (ae4c <_malloc_r+0x35c>)
    acf8:	ldr.w	r9, [pc, #352]	; ae5c <_malloc_r+0x36c>
    acfc:	ldr	r2, [r3, #0]
    acfe:	ldr.w	r3, [r9]
    ad02:	adds	r3, #1
    ad04:	add	r2, r5
    ad06:	add.w	sl, r4, r8
    ad0a:	beq.w	afce <_malloc_r+0x4de>
    ad0e:	add.w	r2, r2, #4096	; 0x1000
    ad12:	adds	r2, #15
    ad14:	bic.w	r2, r2, #4080	; 0xff0
    ad18:	bic.w	r2, r2, #15
    ad1c:	mov	r1, r2
    ad1e:	mov	r0, r6
    ad20:	str	r2, [sp, #4]
    ad22:	bl	b644 <_sbrk_r>
    ad26:	cmp.w	r0, #4294967295
    ad2a:	mov	fp, r0
    ad2c:	ldr	r2, [sp, #4]
    ad2e:	beq.w	afe2 <_malloc_r+0x4f2>
    ad32:	cmp	sl, r0
    ad34:	bhi.w	af30 <_malloc_r+0x440>
    ad38:	ldr	r3, [pc, #276]	; (ae50 <_malloc_r+0x360>)
    ad3a:	ldr	r1, [r3, #0]
    ad3c:	cmp	sl, fp
    ad3e:	add	r1, r2
    ad40:	str	r1, [r3, #0]
    ad42:	beq.w	afec <_malloc_r+0x4fc>
    ad46:	ldr.w	r0, [r9]
    ad4a:	ldr.w	lr, [pc, #272]	; ae5c <_malloc_r+0x36c>
    ad4e:	adds	r0, #1
    ad50:	ittet	ne
    ad52:	rsbne	sl, sl, fp
    ad56:	addne	r1, sl
    ad58:	streq.w	fp, [lr]
    ad5c:	strne	r1, [r3, #0]
    ad5e:	ands.w	r1, fp, #7
    ad62:	beq.w	af94 <_malloc_r+0x4a4>
    ad66:	rsb	r0, r1, #8
    ad6a:	rsb	r1, r1, #4096	; 0x1000
    ad6e:	add	fp, r0
    ad70:	adds	r1, #8
    ad72:	add	r2, fp
    ad74:	ubfx	r2, r2, #0, #12
    ad78:	rsb	r9, r2, r1
    ad7c:	mov	r1, r9
    ad7e:	mov	r0, r6
    ad80:	str	r3, [sp, #4]
    ad82:	bl	b644 <_sbrk_r>
    ad86:	adds	r3, r0, #1
    ad88:	ldr	r3, [sp, #4]
    ad8a:	beq.w	b00c <_malloc_r+0x51c>
    ad8e:	rsb	r2, fp, r0
    ad92:	add	r2, r9
    ad94:	orr.w	r2, r2, #1
    ad98:	ldr	r1, [r3, #0]
    ad9a:	str.w	fp, [r7, #8]
    ad9e:	add	r1, r9
    ada0:	cmp	r4, r7
    ada2:	str.w	r2, [fp, #4]
    ada6:	str	r1, [r3, #0]
    ada8:	ldr.w	r9, [pc, #164]	; ae50 <_malloc_r+0x360>
    adac:	beq.n	addc <_malloc_r+0x2ec>
    adae:	cmp.w	r8, #15
    adb2:	bls.w	afb0 <_malloc_r+0x4c0>
    adb6:	ldr	r2, [r4, #4]
    adb8:	sub.w	r3, r8, #12
    adbc:	bic.w	r3, r3, #7
    adc0:	adds	r0, r4, r3
    adc2:	and.w	r2, r2, #1
    adc6:	mov.w	lr, #5
    adca:	orrs	r2, r3
    adcc:	cmp	r3, #15
    adce:	str	r2, [r4, #4]
    add0:	str.w	lr, [r0, #4]
    add4:	str.w	lr, [r0, #8]
    add8:	bhi.w	b014 <_malloc_r+0x524>
    addc:	ldr	r3, [pc, #116]	; (ae54 <_malloc_r+0x364>)
    adde:	ldr	r4, [r7, #8]
    ade0:	ldr	r2, [r3, #0]
    ade2:	cmp	r1, r2
    ade4:	it	hi
    ade6:	strhi	r1, [r3, #0]
    ade8:	ldr	r3, [pc, #108]	; (ae58 <_malloc_r+0x368>)
    adea:	ldr	r2, [r3, #0]
    adec:	cmp	r1, r2
    adee:	ldr	r2, [r4, #4]
    adf0:	it	hi
    adf2:	strhi	r1, [r3, #0]
    adf4:	bic.w	r2, r2, #3
    adf8:	cmp	r5, r2
    adfa:	sub.w	r3, r2, r5
    adfe:	bhi.n	ae04 <_malloc_r+0x314>
    ae00:	cmp	r3, #15
    ae02:	bgt.n	ae0e <_malloc_r+0x31e>
    ae04:	mov	r0, r6
    ae06:	bl	b260 <__malloc_unlock>
    ae0a:	movs	r4, #0
    ae0c:	b.n	ac80 <_malloc_r+0x190>
    ae0e:	adds	r2, r4, r5
    ae10:	orr.w	r3, r3, #1
    ae14:	orr.w	r5, r5, #1
    ae18:	str	r5, [r4, #4]
    ae1a:	mov	r0, r6
    ae1c:	str	r2, [r7, #8]
    ae1e:	str	r3, [r2, #4]
    ae20:	bl	b260 <__malloc_unlock>
    ae24:	adds	r4, #8
    ae26:	mov	r0, r4
    ae28:	add	sp, #12
    ae2a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ae2e:	cmp	r3, #20
    ae30:	bls.n	af16 <_malloc_r+0x426>
    ae32:	cmp	r3, #84	; 0x54
    ae34:	bhi.w	af80 <_malloc_r+0x490>
    ae38:	lsrs	r0, r5, #12
    ae3a:	add.w	lr, r0, #111	; 0x6f
    ae3e:	mov.w	r3, lr, lsl #1
    ae42:	adds	r0, #110	; 0x6e
    ae44:	b.n	ab34 <_malloc_r+0x44>
    ae46:	nop
    ae48:	.word	0x1fff19b0
    ae4c:	.word	0x1fff85ac
    ae50:	.word	0x1fff85b0
    ae54:	.word	0x1fff85a8
    ae58:	.word	0x1fff85a4
    ae5c:	.word	0x1fff1dbc
    ae60:	lsrs	r2, r3, #9
    ae62:	cmp	r2, #4
    ae64:	bls.n	af24 <_malloc_r+0x434>
    ae66:	cmp	r2, #20
    ae68:	bhi.w	afd2 <_malloc_r+0x4e2>
    ae6c:	add.w	r1, r2, #92	; 0x5c
    ae70:	lsls	r1, r1, #1
    ae72:	adds	r2, #91	; 0x5b
    ae74:	add.w	ip, r7, r1, lsl #2
    ae78:	ldr.w	r1, [r7, r1, lsl #2]
    ae7c:	ldr.w	r8, [pc, #476]	; b05c <_malloc_r+0x56c>
    ae80:	sub.w	ip, ip, #8
    ae84:	cmp	ip, r1
    ae86:	beq.w	af9a <_malloc_r+0x4aa>
    ae8a:	ldr	r2, [r1, #4]
    ae8c:	bic.w	r2, r2, #3
    ae90:	cmp	r3, r2
    ae92:	bcs.n	ae9a <_malloc_r+0x3aa>
    ae94:	ldr	r1, [r1, #8]
    ae96:	cmp	ip, r1
    ae98:	bne.n	ae8a <_malloc_r+0x39a>
    ae9a:	ldr.w	ip, [r1, #12]
    ae9e:	ldr	r2, [r7, #4]
    aea0:	str.w	ip, [r4, #12]
    aea4:	str	r1, [r4, #8]
    aea6:	str.w	r4, [ip, #8]
    aeaa:	str	r4, [r1, #12]
    aeac:	b.n	abc0 <_malloc_r+0xd0>
    aeae:	adds	r3, r4, r5
    aeb0:	orr.w	r7, r2, #1
    aeb4:	orr.w	r5, r5, #1
    aeb8:	str	r5, [r4, #4]
    aeba:	mov	r0, r6
    aebc:	str	r3, [r1, #20]
    aebe:	str	r3, [r1, #16]
    aec0:	str.w	lr, [r3, #12]
    aec4:	str.w	lr, [r3, #8]
    aec8:	str	r7, [r3, #4]
    aeca:	str	r2, [r3, r2]
    aecc:	adds	r4, #8
    aece:	bl	b260 <__malloc_unlock>
    aed2:	b.n	ac80 <_malloc_r+0x190>
    aed4:	ldr	r2, [r1, #4]
    aed6:	b.n	abc0 <_malloc_r+0xd0>
    aed8:	add.w	r8, r8, #1
    aedc:	tst.w	r8, #3
    aee0:	add.w	ip, ip, #8
    aee4:	bne.w	abe6 <_malloc_r+0xf6>
    aee8:	b.n	af4c <_malloc_r+0x45c>
    aeea:	ldr	r4, [r3, #12]
    aeec:	cmp	r3, r4
    aeee:	it	eq
    aef0:	addeq	r0, #2
    aef2:	beq.w	ab60 <_malloc_r+0x70>
    aef6:	b.n	ac60 <_malloc_r+0x170>
    aef8:	add	r3, r1
    aefa:	mov	r4, r1
    aefc:	ldr	r2, [r3, #4]
    aefe:	ldr	r1, [r1, #12]
    af00:	ldr.w	r5, [r4, #8]!
    af04:	orr.w	r2, r2, #1
    af08:	str	r2, [r3, #4]
    af0a:	mov	r0, r6
    af0c:	str	r1, [r5, #12]
    af0e:	str	r5, [r1, #8]
    af10:	bl	b260 <__malloc_unlock>
    af14:	b.n	ac80 <_malloc_r+0x190>
    af16:	add.w	lr, r3, #92	; 0x5c
    af1a:	add.w	r0, r3, #91	; 0x5b
    af1e:	mov.w	r3, lr, lsl #1
    af22:	b.n	ab34 <_malloc_r+0x44>
    af24:	lsrs	r2, r3, #6
    af26:	add.w	r1, r2, #57	; 0x39
    af2a:	lsls	r1, r1, #1
    af2c:	adds	r2, #56	; 0x38
    af2e:	b.n	ae74 <_malloc_r+0x384>
    af30:	cmp	r4, r7
    af32:	ldr	r3, [pc, #296]	; (b05c <_malloc_r+0x56c>)
    af34:	beq.w	ad38 <_malloc_r+0x248>
    af38:	ldr	r4, [r3, #8]
    af3a:	ldr	r2, [r4, #4]
    af3c:	bic.w	r2, r2, #3
    af40:	b.n	adf8 <_malloc_r+0x308>
    af42:	ldr.w	r3, [r9], #-8
    af46:	cmp	r9, r3
    af48:	bne.w	b050 <_malloc_r+0x560>
    af4c:	tst.w	r0, #3
    af50:	add.w	r0, r0, #4294967295
    af54:	bne.n	af42 <_malloc_r+0x452>
    af56:	ldr	r3, [r7, #4]
    af58:	bic.w	r3, r3, r4
    af5c:	str	r3, [r7, #4]
    af5e:	lsls	r4, r4, #1
    af60:	cmp	r4, r3
    af62:	bhi.w	ace0 <_malloc_r+0x1f0>
    af66:	cmp	r4, #0
    af68:	beq.w	ace0 <_malloc_r+0x1f0>
    af6c:	tst	r4, r3
    af6e:	mov	r0, r8
    af70:	bne.w	abde <_malloc_r+0xee>
    af74:	lsls	r4, r4, #1
    af76:	tst	r4, r3
    af78:	add.w	r0, r0, #4
    af7c:	beq.n	af74 <_malloc_r+0x484>
    af7e:	b.n	abde <_malloc_r+0xee>
    af80:	cmp.w	r3, #340	; 0x154
    af84:	bhi.n	afb8 <_malloc_r+0x4c8>
    af86:	lsrs	r0, r5, #15
    af88:	add.w	lr, r0, #120	; 0x78
    af8c:	mov.w	r3, lr, lsl #1
    af90:	adds	r0, #119	; 0x77
    af92:	b.n	ab34 <_malloc_r+0x44>
    af94:	mov.w	r1, #4096	; 0x1000
    af98:	b.n	ad72 <_malloc_r+0x282>
    af9a:	movs	r1, #1
    af9c:	ldr.w	r3, [r8, #4]
    afa0:	asrs	r2, r2, #2
    afa2:	lsl.w	r2, r1, r2
    afa6:	orrs	r2, r3
    afa8:	str.w	r2, [r8, #4]
    afac:	mov	r1, ip
    afae:	b.n	aea0 <_malloc_r+0x3b0>
    afb0:	movs	r3, #1
    afb2:	str.w	r3, [fp, #4]
    afb6:	b.n	ae04 <_malloc_r+0x314>
    afb8:	movw	r2, #1364	; 0x554
    afbc:	cmp	r3, r2
    afbe:	bhi.n	b002 <_malloc_r+0x512>
    afc0:	lsrs	r0, r5, #18
    afc2:	add.w	lr, r0, #125	; 0x7d
    afc6:	mov.w	r3, lr, lsl #1
    afca:	adds	r0, #124	; 0x7c
    afcc:	b.n	ab34 <_malloc_r+0x44>
    afce:	adds	r2, #16
    afd0:	b.n	ad1c <_malloc_r+0x22c>
    afd2:	cmp	r2, #84	; 0x54
    afd4:	bhi.n	b024 <_malloc_r+0x534>
    afd6:	lsrs	r2, r3, #12
    afd8:	add.w	r1, r2, #111	; 0x6f
    afdc:	lsls	r1, r1, #1
    afde:	adds	r2, #110	; 0x6e
    afe0:	b.n	ae74 <_malloc_r+0x384>
    afe2:	ldr	r4, [r7, #8]
    afe4:	ldr	r2, [r4, #4]
    afe6:	bic.w	r2, r2, #3
    afea:	b.n	adf8 <_malloc_r+0x308>
    afec:	ubfx	r0, sl, #0, #12
    aff0:	cmp	r0, #0
    aff2:	bne.w	ad46 <_malloc_r+0x256>
    aff6:	add	r2, r8
    aff8:	ldr	r3, [r7, #8]
    affa:	orr.w	r2, r2, #1
    affe:	str	r2, [r3, #4]
    b000:	b.n	addc <_malloc_r+0x2ec>
    b002:	movs	r3, #254	; 0xfe
    b004:	mov.w	lr, #127	; 0x7f
    b008:	movs	r0, #126	; 0x7e
    b00a:	b.n	ab34 <_malloc_r+0x44>
    b00c:	movs	r2, #1
    b00e:	mov.w	r9, #0
    b012:	b.n	ad98 <_malloc_r+0x2a8>
    b014:	add.w	r1, r4, #8
    b018:	mov	r0, r6
    b01a:	bl	10050 <_free_r>
    b01e:	ldr.w	r1, [r9]
    b022:	b.n	addc <_malloc_r+0x2ec>
    b024:	cmp.w	r2, #340	; 0x154
    b028:	bhi.n	b036 <_malloc_r+0x546>
    b02a:	lsrs	r2, r3, #15
    b02c:	add.w	r1, r2, #120	; 0x78
    b030:	lsls	r1, r1, #1
    b032:	adds	r2, #119	; 0x77
    b034:	b.n	ae74 <_malloc_r+0x384>
    b036:	movw	r1, #1364	; 0x554
    b03a:	cmp	r2, r1
    b03c:	bhi.n	b04a <_malloc_r+0x55a>
    b03e:	lsrs	r2, r3, #18
    b040:	add.w	r1, r2, #125	; 0x7d
    b044:	lsls	r1, r1, #1
    b046:	adds	r2, #124	; 0x7c
    b048:	b.n	ae74 <_malloc_r+0x384>
    b04a:	movs	r1, #254	; 0xfe
    b04c:	movs	r2, #126	; 0x7e
    b04e:	b.n	ae74 <_malloc_r+0x384>
    b050:	ldr	r3, [r7, #4]
    b052:	b.n	af5e <_malloc_r+0x46e>
    b054:	lsrs	r0, r5, #3
    b056:	adds	r3, r0, #1
    b058:	lsls	r3, r3, #1
    b05a:	b.n	ac4e <_malloc_r+0x15e>
    b05c:	.word	0x1fff19b0

0000b060 <__ascii_mbtowc>:
    b060:	sub	sp, #8
    b062:	cbz	r1, b078 <__ascii_mbtowc+0x18>
    b064:	cbz	r2, b07e <__ascii_mbtowc+0x1e>
    b066:	cbz	r3, b084 <__ascii_mbtowc+0x24>
    b068:	ldrb	r3, [r2, #0]
    b06a:	str	r3, [r1, #0]
    b06c:	ldrb	r2, [r2, #0]
    b06e:	adds	r0, r2, #0
    b070:	it	ne
    b072:	movne	r0, #1
    b074:	add	sp, #8
    b076:	bx	lr
    b078:	add	r1, sp, #4
    b07a:	cmp	r2, #0
    b07c:	bne.n	b066 <__ascii_mbtowc+0x6>
    b07e:	mov	r0, r2
    b080:	add	sp, #8
    b082:	bx	lr
    b084:	mvn.w	r0, #1
    b088:	b.n	b074 <__ascii_mbtowc+0x14>
    b08a:	nop
    b08c:			; <UNDEFINED> instruction: 0xffffffff

0000b090 <memchr>:
    b090:	and.w	r1, r1, #255	; 0xff
    b094:	cmp	r2, #16
    b096:	blt.n	b0f0 <memchr+0x60>
    b098:	tst.w	r0, #7
    b09c:	beq.n	b0b0 <memchr+0x20>
    b09e:	ldrb.w	r3, [r0], #1
    b0a2:	subs	r2, #1
    b0a4:	cmp	r3, r1
    b0a6:	beq.n	b104 <memchr+0x74>
    b0a8:	tst.w	r0, #7
    b0ac:	cbz	r2, b100 <memchr+0x70>
    b0ae:	bne.n	b09e <memchr+0xe>
    b0b0:	push	{r4, r5, r6, r7}
    b0b2:	orr.w	r1, r1, r1, lsl #8
    b0b6:	orr.w	r1, r1, r1, lsl #16
    b0ba:	bic.w	r4, r2, #7
    b0be:	mvns.w	r7, #0
    b0c2:	movs	r3, #0
    b0c4:	ldrd	r5, r6, [r0], #8
    b0c8:	subs	r4, #8
    b0ca:	eor.w	r5, r5, r1
    b0ce:	eor.w	r6, r6, r1
    b0d2:	uadd8	r5, r5, r7
    b0d6:	sel	r5, r3, r7
    b0da:	uadd8	r6, r6, r7
    b0de:	sel	r6, r5, r7
    b0e2:	cbnz	r6, b108 <memchr+0x78>
    b0e4:	bne.n	b0c4 <memchr+0x34>
    b0e6:	pop	{r4, r5, r6, r7}
    b0e8:	and.w	r1, r1, #255	; 0xff
    b0ec:	and.w	r2, r2, #7
    b0f0:	cbz	r2, b100 <memchr+0x70>
    b0f2:	ldrb.w	r3, [r0], #1
    b0f6:	subs	r2, #1
    b0f8:	eor.w	r3, r3, r1
    b0fc:	cbz	r3, b104 <memchr+0x74>
    b0fe:	bne.n	b0f2 <memchr+0x62>
    b100:	movs	r0, #0
    b102:	bx	lr
    b104:	subs	r0, #1
    b106:	bx	lr
    b108:	cmp	r5, #0
    b10a:	itte	eq
    b10c:	moveq	r5, r6
    b10e:	subeq	r0, #3
    b110:	subne	r0, #7
    b112:	tst.w	r5, #1
    b116:	bne.n	b128 <memchr+0x98>
    b118:	adds	r0, #1
    b11a:	tst.w	r5, #256	; 0x100
    b11e:	ittt	eq
    b120:	addeq	r0, #1
    b122:	tsteq.w	r5, #98304	; 0x18000
    b126:	addeq	r0, #1
    b128:	pop	{r4, r5, r6, r7}
    b12a:	subs	r0, #1
    b12c:	bx	lr
    b12e:	nop

0000b130 <memcmp>:
    b130:	cmp	r2, #3
    b132:	push	{r4, r5, r6}
    b134:	bls.n	b184 <memcmp+0x54>
    b136:	orr.w	r3, r0, r1
    b13a:	lsls	r3, r3, #30
    b13c:	beq.n	b162 <memcmp+0x32>
    b13e:	ldrb	r4, [r0, #0]
    b140:	ldrb	r5, [r1, #0]
    b142:	cmp	r4, r5
    b144:	bne.n	b18c <memcmp+0x5c>
    b146:	add	r2, r0
    b148:	adds	r3, r0, #1
    b14a:	b.n	b158 <memcmp+0x28>
    b14c:	ldrb.w	r4, [r3], #1
    b150:	ldrb.w	r5, [r1, #1]!
    b154:	cmp	r4, r5
    b156:	bne.n	b18c <memcmp+0x5c>
    b158:	cmp	r3, r2
    b15a:	bne.n	b14c <memcmp+0x1c>
    b15c:	movs	r0, #0
    b15e:	pop	{r4, r5, r6}
    b160:	bx	lr
    b162:	mov	r4, r1
    b164:	mov	r3, r0
    b166:	ldr	r6, [r3, #0]
    b168:	ldr	r5, [r4, #0]
    b16a:	cmp	r6, r5
    b16c:	mov	r0, r3
    b16e:	mov	r1, r4
    b170:	add.w	r3, r3, #4
    b174:	add.w	r4, r4, #4
    b178:	bne.n	b13e <memcmp+0xe>
    b17a:	subs	r2, #4
    b17c:	cmp	r2, #3
    b17e:	mov	r0, r3
    b180:	mov	r1, r4
    b182:	bhi.n	b166 <memcmp+0x36>
    b184:	cmp	r2, #0
    b186:	bne.n	b13e <memcmp+0xe>
    b188:	mov	r0, r2
    b18a:	b.n	b15e <memcmp+0x2e>
    b18c:	subs	r0, r4, r5
    b18e:	pop	{r4, r5, r6}
    b190:	bx	lr
    b192:	nop

0000b194 <memmove>:
    b194:	cmp	r0, r1
    b196:	push	{r4, r5, r6, r7, lr}
    b198:	bls.n	b1b6 <memmove+0x22>
    b19a:	adds	r3, r1, r2
    b19c:	cmp	r0, r3
    b19e:	bcs.n	b1b6 <memmove+0x22>
    b1a0:	adds	r1, r0, r2
    b1a2:	cmp	r2, #0
    b1a4:	beq.n	b24a <memmove+0xb6>
    b1a6:	subs	r2, r3, r2
    b1a8:	ldrb.w	r4, [r3, #-1]!
    b1ac:	strb.w	r4, [r1, #-1]!
    b1b0:	cmp	r3, r2
    b1b2:	bne.n	b1a8 <memmove+0x14>
    b1b4:	pop	{r4, r5, r6, r7, pc}
    b1b6:	cmp	r2, #15
    b1b8:	bls.n	b24c <memmove+0xb8>
    b1ba:	orr.w	r3, r1, r0
    b1be:	lsls	r3, r3, #30
    b1c0:	bne.n	b250 <memmove+0xbc>
    b1c2:	add.w	r4, r0, #16
    b1c6:	add.w	r3, r1, #16
    b1ca:	mov	r5, r2
    b1cc:	ldr.w	r6, [r3, #-16]
    b1d0:	str.w	r6, [r4, #-16]
    b1d4:	ldr.w	r6, [r3, #-12]
    b1d8:	str.w	r6, [r4, #-12]
    b1dc:	ldr.w	r6, [r3, #-8]
    b1e0:	str.w	r6, [r4, #-8]
    b1e4:	subs	r5, #16
    b1e6:	ldr.w	r6, [r3, #-4]
    b1ea:	str.w	r6, [r4, #-4]
    b1ee:	cmp	r5, #15
    b1f0:	add.w	r3, r3, #16
    b1f4:	add.w	r4, r4, #16
    b1f8:	bhi.n	b1cc <memmove+0x38>
    b1fa:	sub.w	r3, r2, #16
    b1fe:	bic.w	r3, r3, #15
    b202:	and.w	lr, r2, #15
    b206:	adds	r3, #16
    b208:	cmp.w	lr, #3
    b20c:	add	r1, r3
    b20e:	add	r3, r0
    b210:	bls.n	b256 <memmove+0xc2>
    b212:	subs	r6, r3, #4
    b214:	mov	r5, r1
    b216:	mov	r4, lr
    b218:	subs	r4, #4
    b21a:	ldr.w	r7, [r5], #4
    b21e:	str.w	r7, [r6, #4]!
    b222:	cmp	r4, #3
    b224:	bhi.n	b218 <memmove+0x84>
    b226:	sub.w	r4, lr, #4
    b22a:	bic.w	r4, r4, #3
    b22e:	adds	r4, #4
    b230:	add	r3, r4
    b232:	add	r1, r4
    b234:	and.w	r2, r2, #3
    b238:	cbz	r2, b254 <memmove+0xc0>
    b23a:	subs	r3, #1
    b23c:	add	r2, r1
    b23e:	ldrb.w	r4, [r1], #1
    b242:	strb.w	r4, [r3, #1]!
    b246:	cmp	r2, r1
    b248:	bne.n	b23e <memmove+0xaa>
    b24a:	pop	{r4, r5, r6, r7, pc}
    b24c:	mov	r3, r0
    b24e:	b.n	b238 <memmove+0xa4>
    b250:	mov	r3, r0
    b252:	b.n	b23a <memmove+0xa6>
    b254:	pop	{r4, r5, r6, r7, pc}
    b256:	mov	r2, lr
    b258:	b.n	b238 <memmove+0xa4>
    b25a:	nop

0000b25c <__malloc_lock>:
    b25c:	bx	lr
    b25e:	nop

0000b260 <__malloc_unlock>:
    b260:	bx	lr
    b262:	nop

0000b264 <_realloc_r>:
    b264:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b268:	mov	r7, r2
    b26a:	sub	sp, #12
    b26c:	cmp	r1, #0
    b26e:	beq.w	b3f4 <_realloc_r+0x190>
    b272:	mov	r6, r1
    b274:	mov	r9, r0
    b276:	add.w	r5, r7, #11
    b27a:	bl	b25c <__malloc_lock>
    b27e:	ldr.w	lr, [r6, #-4]
    b282:	cmp	r5, #22
    b284:	bic.w	r4, lr, #3
    b288:	sub.w	r8, r6, #8
    b28c:	bhi.n	b310 <_realloc_r+0xac>
    b28e:	movs	r2, #16
    b290:	mov	r5, r2
    b292:	cmp	r7, r5
    b294:	bhi.n	b31a <_realloc_r+0xb6>
    b296:	cmp	r4, r2
    b298:	bge.n	b386 <_realloc_r+0x122>
    b29a:	ldr	r3, [pc, #804]	; (b5c0 <_realloc_r+0x35c>)
    b29c:	ldr	r1, [r3, #8]
    b29e:	add.w	r0, r8, r4
    b2a2:	cmp	r0, r1
    b2a4:	ldr	r1, [r0, #4]
    b2a6:	beq.w	b45c <_realloc_r+0x1f8>
    b2aa:	bic.w	r3, r1, #1
    b2ae:	add	r3, r0
    b2b0:	ldr	r3, [r3, #4]
    b2b2:	lsls	r3, r3, #31
    b2b4:	bpl.n	b3b2 <_realloc_r+0x14e>
    b2b6:	tst.w	lr, #1
    b2ba:	beq.n	b328 <_realloc_r+0xc4>
    b2bc:	mov	r1, r7
    b2be:	mov	r0, r9
    b2c0:	bl	aaf0 <_malloc_r>
    b2c4:	mov	r7, r0
    b2c6:	cbz	r0, b302 <_realloc_r+0x9e>
    b2c8:	ldr.w	r3, [r6, #-4]
    b2cc:	bic.w	r3, r3, #1
    b2d0:	add	r3, r8
    b2d2:	sub.w	r2, r0, #8
    b2d6:	cmp	r2, r3
    b2d8:	beq.w	b564 <_realloc_r+0x300>
    b2dc:	subs	r2, r4, #4
    b2de:	cmp	r2, #36	; 0x24
    b2e0:	bhi.w	b546 <_realloc_r+0x2e2>
    b2e4:	cmp	r2, #19
    b2e6:	bhi.w	b4f2 <_realloc_r+0x28e>
    b2ea:	mov	r3, r0
    b2ec:	mov	r2, r6
    b2ee:	ldr	r1, [r2, #0]
    b2f0:	str	r1, [r3, #0]
    b2f2:	ldr	r1, [r2, #4]
    b2f4:	str	r1, [r3, #4]
    b2f6:	ldr	r2, [r2, #8]
    b2f8:	str	r2, [r3, #8]
    b2fa:	mov	r1, r6
    b2fc:	mov	r0, r9
    b2fe:	bl	10050 <_free_r>
    b302:	mov	r0, r9
    b304:	bl	b260 <__malloc_unlock>
    b308:	mov	r0, r7
    b30a:	add	sp, #12
    b30c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b310:	bic.w	r5, r5, #7
    b314:	cmp	r5, #0
    b316:	mov	r2, r5
    b318:	bge.n	b292 <_realloc_r+0x2e>
    b31a:	movs	r3, #12
    b31c:	movs	r0, #0
    b31e:	str.w	r3, [r9]
    b322:	add	sp, #12
    b324:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b328:	ldr.w	r3, [r6, #-8]
    b32c:	rsb	sl, r3, r8
    b330:	ldr.w	r3, [sl, #4]
    b334:	bic.w	ip, r3, #3
    b338:	add.w	r3, r4, ip
    b33c:	cmp	r3, r2
    b33e:	blt.n	b2bc <_realloc_r+0x58>
    b340:	mov	r7, sl
    b342:	ldr.w	r1, [sl, #12]
    b346:	ldr.w	r0, [r7, #8]!
    b34a:	subs	r2, r4, #4
    b34c:	cmp	r2, #36	; 0x24
    b34e:	str	r1, [r0, #12]
    b350:	str	r0, [r1, #8]
    b352:	bhi.w	b584 <_realloc_r+0x320>
    b356:	cmp	r2, #19
    b358:	bls.w	b580 <_realloc_r+0x31c>
    b35c:	ldr	r1, [r6, #0]
    b35e:	str.w	r1, [sl, #8]
    b362:	ldr	r1, [r6, #4]
    b364:	str.w	r1, [sl, #12]
    b368:	cmp	r2, #27
    b36a:	bhi.w	b5c4 <_realloc_r+0x360>
    b36e:	adds	r6, #8
    b370:	add.w	r2, sl, #16
    b374:	ldr	r1, [r6, #0]
    b376:	str	r1, [r2, #0]
    b378:	ldr	r1, [r6, #4]
    b37a:	str	r1, [r2, #4]
    b37c:	ldr	r1, [r6, #8]
    b37e:	str	r1, [r2, #8]
    b380:	mov	r6, r7
    b382:	mov	r4, r3
    b384:	mov	r8, sl
    b386:	subs	r3, r4, r5
    b388:	cmp	r3, #15
    b38a:	bhi.n	b3c8 <_realloc_r+0x164>
    b38c:	ldr.w	r3, [r8, #4]
    b390:	and.w	r3, r3, #1
    b394:	orrs	r3, r4
    b396:	add	r4, r8
    b398:	str.w	r3, [r8, #4]
    b39c:	ldr	r3, [r4, #4]
    b39e:	orr.w	r3, r3, #1
    b3a2:	str	r3, [r4, #4]
    b3a4:	mov	r0, r9
    b3a6:	bl	b260 <__malloc_unlock>
    b3aa:	mov	r0, r6
    b3ac:	add	sp, #12
    b3ae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b3b2:	bic.w	r1, r1, #3
    b3b6:	add	r1, r4
    b3b8:	cmp	r1, r2
    b3ba:	blt.n	b400 <_realloc_r+0x19c>
    b3bc:	ldr	r3, [r0, #12]
    b3be:	ldr	r2, [r0, #8]
    b3c0:	mov	r4, r1
    b3c2:	str	r3, [r2, #12]
    b3c4:	str	r2, [r3, #8]
    b3c6:	b.n	b386 <_realloc_r+0x122>
    b3c8:	ldr.w	r2, [r8, #4]
    b3cc:	add.w	r1, r8, r5
    b3d0:	and.w	r2, r2, #1
    b3d4:	orrs	r5, r2
    b3d6:	orr.w	r2, r3, #1
    b3da:	add	r3, r1
    b3dc:	str.w	r5, [r8, #4]
    b3e0:	str	r2, [r1, #4]
    b3e2:	ldr	r2, [r3, #4]
    b3e4:	orr.w	r2, r2, #1
    b3e8:	adds	r1, #8
    b3ea:	str	r2, [r3, #4]
    b3ec:	mov	r0, r9
    b3ee:	bl	10050 <_free_r>
    b3f2:	b.n	b3a4 <_realloc_r+0x140>
    b3f4:	mov	r1, r2
    b3f6:	add	sp, #12
    b3f8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b3fc:	b.w	aaf0 <_malloc_r>
    b400:	tst.w	lr, #1
    b404:	bne.w	b2bc <_realloc_r+0x58>
    b408:	ldr.w	r3, [r6, #-8]
    b40c:	rsb	sl, r3, r8
    b410:	ldr.w	r3, [sl, #4]
    b414:	bic.w	ip, r3, #3
    b418:	add.w	lr, r1, ip
    b41c:	cmp	lr, r2
    b41e:	blt.n	b338 <_realloc_r+0xd4>
    b420:	ldr	r3, [r0, #12]
    b422:	ldr	r2, [r0, #8]
    b424:	mov	r7, sl
    b426:	str	r3, [r2, #12]
    b428:	str	r2, [r3, #8]
    b42a:	ldr.w	r1, [r7, #8]!
    b42e:	ldr.w	r3, [sl, #12]
    b432:	str	r3, [r1, #12]
    b434:	subs	r2, r4, #4
    b436:	cmp	r2, #36	; 0x24
    b438:	str	r1, [r3, #8]
    b43a:	bhi.w	b570 <_realloc_r+0x30c>
    b43e:	cmp	r2, #19
    b440:	bls.n	b508 <_realloc_r+0x2a4>
    b442:	ldr	r3, [r6, #0]
    b444:	str.w	r3, [sl, #8]
    b448:	ldr	r3, [r6, #4]
    b44a:	str.w	r3, [sl, #12]
    b44e:	cmp	r2, #27
    b450:	bhi.w	b594 <_realloc_r+0x330>
    b454:	adds	r6, #8
    b456:	add.w	r3, sl, #16
    b45a:	b.n	b50a <_realloc_r+0x2a6>
    b45c:	bic.w	fp, r1, #3
    b460:	add	fp, r4
    b462:	add.w	r0, r5, #16
    b466:	cmp	fp, r0
    b468:	bge.n	b51e <_realloc_r+0x2ba>
    b46a:	tst.w	lr, #1
    b46e:	bne.w	b2bc <_realloc_r+0x58>
    b472:	ldr.w	r1, [r6, #-8]
    b476:	rsb	sl, r1, r8
    b47a:	ldr.w	r1, [sl, #4]
    b47e:	bic.w	ip, r1, #3
    b482:	add	fp, ip
    b484:	cmp	r0, fp
    b486:	bgt.w	b338 <_realloc_r+0xd4>
    b48a:	mov	r7, sl
    b48c:	ldr.w	r1, [sl, #12]
    b490:	ldr.w	r0, [r7, #8]!
    b494:	subs	r2, r4, #4
    b496:	cmp	r2, #36	; 0x24
    b498:	str	r1, [r0, #12]
    b49a:	str	r0, [r1, #8]
    b49c:	bhi.w	b608 <_realloc_r+0x3a4>
    b4a0:	cmp	r2, #19
    b4a2:	bls.w	b5f0 <_realloc_r+0x38c>
    b4a6:	ldr	r1, [r6, #0]
    b4a8:	str.w	r1, [sl, #8]
    b4ac:	ldr	r1, [r6, #4]
    b4ae:	str.w	r1, [sl, #12]
    b4b2:	cmp	r2, #27
    b4b4:	bhi.w	b616 <_realloc_r+0x3b2>
    b4b8:	adds	r6, #8
    b4ba:	add.w	r2, sl, #16
    b4be:	ldr	r1, [r6, #0]
    b4c0:	str	r1, [r2, #0]
    b4c2:	ldr	r1, [r6, #4]
    b4c4:	str	r1, [r2, #4]
    b4c6:	ldr	r1, [r6, #8]
    b4c8:	str	r1, [r2, #8]
    b4ca:	add.w	r1, sl, r5
    b4ce:	rsb	r2, r5, fp
    b4d2:	orr.w	r2, r2, #1
    b4d6:	str	r1, [r3, #8]
    b4d8:	str	r2, [r1, #4]
    b4da:	ldr.w	r3, [sl, #4]
    b4de:	and.w	r3, r3, #1
    b4e2:	orrs	r5, r3
    b4e4:	mov	r0, r9
    b4e6:	str.w	r5, [sl, #4]
    b4ea:	bl	b260 <__malloc_unlock>
    b4ee:	mov	r0, r7
    b4f0:	b.n	b3ac <_realloc_r+0x148>
    b4f2:	ldr	r3, [r6, #0]
    b4f4:	str	r3, [r0, #0]
    b4f6:	ldr	r3, [r6, #4]
    b4f8:	str	r3, [r0, #4]
    b4fa:	cmp	r2, #27
    b4fc:	bhi.n	b54e <_realloc_r+0x2ea>
    b4fe:	add.w	r3, r0, #8
    b502:	add.w	r2, r6, #8
    b506:	b.n	b2ee <_realloc_r+0x8a>
    b508:	mov	r3, r7
    b50a:	ldr	r2, [r6, #0]
    b50c:	str	r2, [r3, #0]
    b50e:	ldr	r2, [r6, #4]
    b510:	str	r2, [r3, #4]
    b512:	ldr	r2, [r6, #8]
    b514:	str	r2, [r3, #8]
    b516:	mov	r6, r7
    b518:	mov	r4, lr
    b51a:	mov	r8, sl
    b51c:	b.n	b386 <_realloc_r+0x122>
    b51e:	add.w	r1, r8, r5
    b522:	rsb	fp, r5, fp
    b526:	orr.w	r2, fp, #1
    b52a:	str	r1, [r3, #8]
    b52c:	str	r2, [r1, #4]
    b52e:	ldr.w	r3, [r6, #-4]
    b532:	and.w	r3, r3, #1
    b536:	orrs	r5, r3
    b538:	mov	r0, r9
    b53a:	str.w	r5, [r6, #-4]
    b53e:	bl	b260 <__malloc_unlock>
    b542:	mov	r0, r6
    b544:	b.n	b3ac <_realloc_r+0x148>
    b546:	mov	r1, r6
    b548:	bl	b194 <memmove>
    b54c:	b.n	b2fa <_realloc_r+0x96>
    b54e:	ldr	r3, [r6, #8]
    b550:	str	r3, [r0, #8]
    b552:	ldr	r3, [r6, #12]
    b554:	str	r3, [r0, #12]
    b556:	cmp	r2, #36	; 0x24
    b558:	beq.n	b5ac <_realloc_r+0x348>
    b55a:	add.w	r3, r0, #16
    b55e:	add.w	r2, r6, #16
    b562:	b.n	b2ee <_realloc_r+0x8a>
    b564:	ldr.w	r3, [r0, #-4]
    b568:	bic.w	r3, r3, #3
    b56c:	add	r4, r3
    b56e:	b.n	b386 <_realloc_r+0x122>
    b570:	mov	r1, r6
    b572:	mov	r0, r7
    b574:	mov	r4, lr
    b576:	mov	r8, sl
    b578:	bl	b194 <memmove>
    b57c:	mov	r6, r7
    b57e:	b.n	b386 <_realloc_r+0x122>
    b580:	mov	r2, r7
    b582:	b.n	b374 <_realloc_r+0x110>
    b584:	mov	r1, r6
    b586:	mov	r0, r7
    b588:	mov	r4, r3
    b58a:	mov	r8, sl
    b58c:	bl	b194 <memmove>
    b590:	mov	r6, r7
    b592:	b.n	b386 <_realloc_r+0x122>
    b594:	ldr	r3, [r6, #8]
    b596:	str.w	r3, [sl, #16]
    b59a:	ldr	r3, [r6, #12]
    b59c:	str.w	r3, [sl, #20]
    b5a0:	cmp	r2, #36	; 0x24
    b5a2:	beq.n	b5dc <_realloc_r+0x378>
    b5a4:	adds	r6, #16
    b5a6:	add.w	r3, sl, #24
    b5aa:	b.n	b50a <_realloc_r+0x2a6>
    b5ac:	ldr	r3, [r6, #16]
    b5ae:	str	r3, [r0, #16]
    b5b0:	ldr	r3, [r6, #20]
    b5b2:	str	r3, [r0, #20]
    b5b4:	add.w	r2, r6, #24
    b5b8:	add.w	r3, r0, #24
    b5bc:	b.n	b2ee <_realloc_r+0x8a>
    b5be:	nop
    b5c0:	.word	0x1fff19b0
    b5c4:	ldr	r1, [r6, #8]
    b5c6:	str.w	r1, [sl, #16]
    b5ca:	ldr	r1, [r6, #12]
    b5cc:	str.w	r1, [sl, #20]
    b5d0:	cmp	r2, #36	; 0x24
    b5d2:	beq.n	b5f4 <_realloc_r+0x390>
    b5d4:	adds	r6, #16
    b5d6:	add.w	r2, sl, #24
    b5da:	b.n	b374 <_realloc_r+0x110>
    b5dc:	ldr	r3, [r6, #16]
    b5de:	str.w	r3, [sl, #24]
    b5e2:	ldr	r3, [r6, #20]
    b5e4:	str.w	r3, [sl, #28]
    b5e8:	adds	r6, #24
    b5ea:	add.w	r3, sl, #32
    b5ee:	b.n	b50a <_realloc_r+0x2a6>
    b5f0:	mov	r2, r7
    b5f2:	b.n	b4be <_realloc_r+0x25a>
    b5f4:	ldr	r2, [r6, #16]
    b5f6:	str.w	r2, [sl, #24]
    b5fa:	ldr	r2, [r6, #20]
    b5fc:	str.w	r2, [sl, #28]
    b600:	adds	r6, #24
    b602:	add.w	r2, sl, #32
    b606:	b.n	b374 <_realloc_r+0x110>
    b608:	mov	r1, r6
    b60a:	mov	r0, r7
    b60c:	str	r3, [sp, #4]
    b60e:	bl	b194 <memmove>
    b612:	ldr	r3, [sp, #4]
    b614:	b.n	b4ca <_realloc_r+0x266>
    b616:	ldr	r1, [r6, #8]
    b618:	str.w	r1, [sl, #16]
    b61c:	ldr	r1, [r6, #12]
    b61e:	str.w	r1, [sl, #20]
    b622:	cmp	r2, #36	; 0x24
    b624:	beq.n	b62e <_realloc_r+0x3ca>
    b626:	adds	r6, #16
    b628:	add.w	r2, sl, #24
    b62c:	b.n	b4be <_realloc_r+0x25a>
    b62e:	ldr	r2, [r6, #16]
    b630:	str.w	r2, [sl, #24]
    b634:	ldr	r2, [r6, #20]
    b636:	str.w	r2, [sl, #28]
    b63a:	adds	r6, #24
    b63c:	add.w	r2, sl, #32
    b640:	b.n	b4be <_realloc_r+0x25a>
    b642:	nop

0000b644 <_sbrk_r>:
    b644:	push	{r3, r4, r5, lr}
    b646:	ldr	r4, [pc, #28]	; (b664 <_sbrk_r+0x20>)
    b648:	movs	r3, #0
    b64a:	mov	r5, r0
    b64c:	mov	r0, r1
    b64e:	str	r3, [r4, #0]
    b650:	bl	8cd8 <_sbrk>
    b654:	adds	r3, r0, #1
    b656:	beq.n	b65a <_sbrk_r+0x16>
    b658:	pop	{r3, r4, r5, pc}
    b65a:	ldr	r3, [r4, #0]
    b65c:	cmp	r3, #0
    b65e:	beq.n	b658 <_sbrk_r+0x14>
    b660:	str	r3, [r5, #0]
    b662:	pop	{r3, r4, r5, pc}
    b664:	.word	0x1fff85ec

0000b668 <sprintf>:
    b668:	push	{r1, r2, r3}
    b66a:	push	{r4, r5, r6, r7, lr}
    b66c:	sub	sp, #112	; 0x70
    b66e:	add	r3, sp, #132	; 0x84
    b670:	ldr	r1, [pc, #60]	; (b6b0 <sprintf+0x48>)
    b672:	ldr.w	r2, [r3], #4
    b676:	str	r3, [sp, #4]
    b678:	mov	r5, r0
    b67a:	mvn.w	r4, #2147483648	; 0x80000000
    b67e:	ldr	r0, [r1, #0]
    b680:	str	r5, [sp, #8]
    b682:	mov.w	r7, #520	; 0x208
    b686:	movw	r6, #65535	; 0xffff
    b68a:	add	r1, sp, #8
    b68c:	str	r5, [sp, #24]
    b68e:	strh.w	r7, [sp, #20]
    b692:	str	r4, [sp, #16]
    b694:	str	r4, [sp, #28]
    b696:	strh.w	r6, [sp, #22]
    b69a:	bl	c950 <_svfprintf_r>
    b69e:	ldr	r3, [sp, #8]
    b6a0:	movs	r2, #0
    b6a2:	strb	r2, [r3, #0]
    b6a4:	add	sp, #112	; 0x70
    b6a6:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    b6aa:	add	sp, #12
    b6ac:	bx	lr
    b6ae:	nop
    b6b0:	.word	0x1fff1840

0000b6b4 <sscanf>:
    b6b4:	push	{r1, r2, r3}
    b6b6:	push	{r4, r5, r6, r7, lr}
    b6b8:	sub	sp, #112	; 0x70
    b6ba:	add	r4, sp, #132	; 0x84
    b6bc:	mov.w	r2, #516	; 0x204
    b6c0:	ldr.w	r6, [r4], #4
    b6c4:	strh.w	r2, [sp, #20]
    b6c8:	str	r0, [sp, #8]
    b6ca:	str	r0, [sp, #24]
    b6cc:	bl	b740 <strlen>
    b6d0:	ldr	r3, [pc, #48]	; (b704 <sscanf+0x50>)
    b6d2:	str	r4, [sp, #4]
    b6d4:	mov	r5, r0
    b6d6:	mov	r2, r6
    b6d8:	ldr	r7, [pc, #44]	; (b708 <sscanf+0x54>)
    b6da:	ldr	r0, [r3, #0]
    b6dc:	str	r5, [sp, #12]
    b6de:	mov	r3, r4
    b6e0:	movw	r6, #65535	; 0xffff
    b6e4:	movs	r4, #0
    b6e6:	add	r1, sp, #8
    b6e8:	str	r5, [sp, #28]
    b6ea:	str	r7, [sp, #40]	; 0x28
    b6ec:	str	r4, [sp, #56]	; 0x38
    b6ee:	str	r4, [sp, #76]	; 0x4c
    b6f0:	strh.w	r6, [sp, #22]
    b6f4:	bl	e034 <__ssvfscanf_r>
    b6f8:	add	sp, #112	; 0x70
    b6fa:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    b6fe:	add	sp, #12
    b700:	bx	lr
    b702:	nop
    b704:	.word	0x1fff1840
    b708:	.word	0x0000b70d

0000b70c <__seofread>:
    b70c:	movs	r0, #0
    b70e:	bx	lr
    b710:			; <UNDEFINED> instruction: 0xffffffff
    b714:			; <UNDEFINED> instruction: 0xffffffff
    b718:			; <UNDEFINED> instruction: 0xffffffff
    b71c:			; <UNDEFINED> instruction: 0xffffffff
    b720:			; <UNDEFINED> instruction: 0xffffffff
    b724:			; <UNDEFINED> instruction: 0xffffffff
    b728:			; <UNDEFINED> instruction: 0xffffffff
    b72c:			; <UNDEFINED> instruction: 0xffffffff
    b730:			; <UNDEFINED> instruction: 0xffffffff
    b734:			; <UNDEFINED> instruction: 0xffffffff
    b738:			; <UNDEFINED> instruction: 0xffffffff
    b73c:			; <UNDEFINED> instruction: 0xffffffff

0000b740 <strlen>:
    b740:	pld	[r0]
    b744:	strd	r4, r5, [sp, #-8]!
    b748:	bic.w	r1, r0, #7
    b74c:	mvn.w	ip, #0
    b750:	ands.w	r4, r0, #7
    b754:	pld	[r1, #32]
    b758:	bne.w	b7ee <strlen+0xae>
    b75c:	mov.w	r4, #0
    b760:	mvn.w	r0, #7
    b764:	ldrd	r2, r3, [r1]
    b768:	pld	[r1, #64]	; 0x40
    b76c:	add.w	r0, r0, #8
    b770:	uadd8	r2, r2, ip
    b774:	sel	r2, r4, ip
    b778:	uadd8	r3, r3, ip
    b77c:	sel	r3, r2, ip
    b780:	cbnz	r3, b7d6 <strlen+0x96>
    b782:	ldrd	r2, r3, [r1, #8]
    b786:	uadd8	r2, r2, ip
    b78a:	add.w	r0, r0, #8
    b78e:	sel	r2, r4, ip
    b792:	uadd8	r3, r3, ip
    b796:	sel	r3, r2, ip
    b79a:	cbnz	r3, b7d6 <strlen+0x96>
    b79c:	ldrd	r2, r3, [r1, #16]
    b7a0:	uadd8	r2, r2, ip
    b7a4:	add.w	r0, r0, #8
    b7a8:	sel	r2, r4, ip
    b7ac:	uadd8	r3, r3, ip
    b7b0:	sel	r3, r2, ip
    b7b4:	cbnz	r3, b7d6 <strlen+0x96>
    b7b6:	ldrd	r2, r3, [r1, #24]
    b7ba:	add.w	r1, r1, #32
    b7be:	uadd8	r2, r2, ip
    b7c2:	add.w	r0, r0, #8
    b7c6:	sel	r2, r4, ip
    b7ca:	uadd8	r3, r3, ip
    b7ce:	sel	r3, r2, ip
    b7d2:	cmp	r3, #0
    b7d4:	beq.n	b764 <strlen+0x24>
    b7d6:	cmp	r2, #0
    b7d8:	itt	eq
    b7da:	addeq	r0, #4
    b7dc:	moveq	r2, r3
    b7de:	rev	r2, r2
    b7e0:	clz	r2, r2
    b7e4:	ldrd	r4, r5, [sp], #8
    b7e8:	add.w	r0, r0, r2, lsr #3
    b7ec:	bx	lr
    b7ee:	ldrd	r2, r3, [r1]
    b7f2:	and.w	r5, r4, #3
    b7f6:	rsb	r0, r4, #0
    b7fa:	mov.w	r5, r5, lsl #3
    b7fe:	tst.w	r4, #4
    b802:	pld	[r1, #64]	; 0x40
    b806:	lsl.w	r5, ip, r5
    b80a:	orn	r2, r2, r5
    b80e:	itt	ne
    b810:	ornne	r3, r3, r5
    b814:	movne	r2, ip
    b816:	mov.w	r4, #0
    b81a:	b.n	b770 <strlen+0x30>

0000b81c <strncmp>:
    b81c:	cmp	r2, #0
    b81e:	beq.n	b8a4 <strncmp+0x88>
    b820:	orr.w	r3, r0, r1
    b824:	ands.w	r3, r3, #3
    b828:	push	{r4, r5, r6, r7}
    b82a:	bne.n	b878 <strncmp+0x5c>
    b82c:	cmp	r2, #3
    b82e:	bls.n	b878 <strncmp+0x5c>
    b830:	ldr	r4, [r0, #0]
    b832:	ldr	r5, [r1, #0]
    b834:	cmp	r4, r5
    b836:	bne.n	b878 <strncmp+0x5c>
    b838:	subs	r2, #4
    b83a:	beq.n	b8a8 <strncmp+0x8c>
    b83c:	sub.w	r5, r4, #16843009	; 0x1010101
    b840:	bic.w	r4, r5, r4
    b844:	tst.w	r4, #2155905152	; 0x80808080
    b848:	bne.n	b8ae <strncmp+0x92>
    b84a:	adds	r7, r0, #4
    b84c:	adds	r5, r1, #4
    b84e:	b.n	b86c <strncmp+0x50>
    b850:	ldr.w	r3, [r7], #4
    b854:	ldr	r6, [r1, #0]
    b856:	sub.w	r4, r3, #16843009	; 0x1010101
    b85a:	cmp	r3, r6
    b85c:	bic.w	r4, r4, r3
    b860:	bne.n	b878 <strncmp+0x5c>
    b862:	subs	r2, #4
    b864:	beq.n	b8a8 <strncmp+0x8c>
    b866:	tst.w	r4, #2155905152	; 0x80808080
    b86a:	bne.n	b8b4 <strncmp+0x98>
    b86c:	cmp	r2, #3
    b86e:	mov	r1, r5
    b870:	mov	r0, r7
    b872:	add.w	r5, r5, #4
    b876:	bhi.n	b850 <strncmp+0x34>
    b878:	ldrb	r3, [r0, #0]
    b87a:	ldrb	r4, [r1, #0]
    b87c:	cmp	r4, r3
    b87e:	add.w	r2, r2, #4294967295
    b882:	bne.n	b89e <strncmp+0x82>
    b884:	cbz	r2, b8a8 <strncmp+0x8c>
    b886:	cbnz	r4, b88e <strncmp+0x72>
    b888:	b.n	b8b8 <strncmp+0x9c>
    b88a:	cbz	r2, b8a8 <strncmp+0x8c>
    b88c:	cbz	r3, b8ae <strncmp+0x92>
    b88e:	ldrb.w	r3, [r0, #1]!
    b892:	ldrb.w	r4, [r1, #1]!
    b896:	cmp	r3, r4
    b898:	add.w	r2, r2, #4294967295
    b89c:	beq.n	b88a <strncmp+0x6e>
    b89e:	subs	r0, r3, r4
    b8a0:	pop	{r4, r5, r6, r7}
    b8a2:	bx	lr
    b8a4:	mov	r0, r2
    b8a6:	bx	lr
    b8a8:	mov	r0, r2
    b8aa:	pop	{r4, r5, r6, r7}
    b8ac:	bx	lr
    b8ae:	mov	r0, r3
    b8b0:	pop	{r4, r5, r6, r7}
    b8b2:	bx	lr
    b8b4:	movs	r0, #0
    b8b6:	b.n	b8a0 <strncmp+0x84>
    b8b8:	mov	r0, r4
    b8ba:	b.n	b8a0 <strncmp+0x84>

0000b8bc <sulp>:
    b8bc:	push	{r4, r5, r6, lr}
    b8be:	mov	r4, r0
    b8c0:	mov	r5, r1
    b8c2:	vmov	d0, r4, r5
    b8c6:	mov	r6, r2
    b8c8:	bl	11020 <__ulp>
    b8cc:	vmov	r0, r1, d0
    b8d0:	cbz	r6, b8f2 <sulp+0x36>
    b8d2:	ubfx	r3, r5, #20, #11
    b8d6:	rsb	r3, r3, #107	; 0x6b
    b8da:	cmp	r3, #0
    b8dc:	ble.n	b8f2 <sulp+0x36>
    b8de:	lsls	r3, r3, #20
    b8e0:	add.w	r5, r3, #1069547520	; 0x3fc00000
    b8e4:	movs	r4, #0
    b8e6:	add.w	r5, r5, #3145728	; 0x300000
    b8ea:	mov	r2, r4
    b8ec:	mov	r3, r5
    b8ee:	bl	a070 <__aeabi_dmul>
    b8f2:	pop	{r4, r5, r6, pc}
    b8f4:			; <UNDEFINED> instruction: 0xffffffff

0000b8f8 <_strtod_l>:
    b8f8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b8fc:	mov	r5, r3
    b8fe:	sub	sp, #132	; 0x84
    b900:	movs	r3, #0
    b902:	mov	fp, r0
    b904:	mov	r0, r5
    b906:	mov	r6, r1
    b908:	str	r2, [sp, #24]
    b90a:	str	r3, [sp, #112]	; 0x70
    b90c:	bl	109a4 <__localeconv_l>
    b910:	movs	r4, #0
    b912:	movs	r3, #0
    b914:	mov	sl, r0
    b916:	ldr	r0, [r0, #0]
    b918:	strd	r3, r4, [sp, #16]
    b91c:	bl	b740 <strlen>
    b920:	str	r6, [sp, #108]	; 0x6c
    b922:	mov	r9, r0
    b924:	mov	r2, r6
    b926:	mov	r4, r2
    b928:	ldrb.w	r7, [r2], #1
    b92c:	cmp	r7, #45	; 0x2d
    b92e:	bhi.w	ba90 <_strtod_l+0x198>
    b932:	tbb	[pc, r7]
    b936:	.short	0xad17
    b938:	.word	0xadadadad
    b93c:	.word	0x81adadad
    b940:	.word	0x81818181
    b944:	.word	0xadadadad
    b948:	.word	0xadadadad
    b94c:	.word	0xadadadad
    b950:	.word	0xadadadad
    b954:	.word	0xad81adad
    b958:	.word	0xadadadad
    b95c:	.word	0xadadadad
    b960:	.word	0x7ead2bad
    b964:	ldr	r3, [sp, #24]
    b966:	mov.w	r8, #0
    b96a:	mov.w	r9, #0
    b96e:	cbz	r3, b982 <_strtod_l+0x8a>
    b970:	movs	r3, #0
    b972:	str	r3, [sp, #28]
    b974:	ldr	r3, [sp, #24]
    b976:	str	r6, [r3, #0]
    b978:	ldr	r3, [sp, #28]
    b97a:	cbz	r3, b982 <_strtod_l+0x8a>
    b97c:	add.w	r3, r9, #2147483648	; 0x80000000
    b980:	mov	r9, r3
    b982:	vmov	d0, r8, r9
    b986:	add	sp, #132	; 0x84
    b988:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b98c:	movs	r3, #0
    b98e:	str	r3, [sp, #28]
    b990:	adds	r2, r4, #1
    b992:	str	r2, [sp, #108]	; 0x6c
    b994:	ldrb	r7, [r4, #1]
    b996:	cmp	r7, #0
    b998:	beq.n	b964 <_strtod_l+0x6c>
    b99a:	cmp	r7, #48	; 0x30
    b99c:	mov	r4, r2
    b99e:	beq.n	ba98 <_strtod_l+0x1a0>
    b9a0:	movs	r3, #0
    b9a2:	str	r4, [sp, #32]
    b9a4:	str	r3, [sp, #40]	; 0x28
    b9a6:	sub.w	r3, r7, #48	; 0x30
    b9aa:	cmp	r3, #9
    b9ac:	bhi.w	c1be <_strtod_l+0x8c6>
    b9b0:	mov.w	r8, #0
    b9b4:	mov	r0, r4
    b9b6:	mov	r5, r8
    b9b8:	mov	r4, r8
    b9ba:	cmp	r4, #8
    b9bc:	it	gt
    b9be:	addgt.w	r8, r8, r8, lsl #2
    b9c2:	add.w	r3, r5, r5, lsl #2
    b9c6:	add.w	r0, r0, #1
    b9ca:	add.w	r3, r7, r3, lsl #1
    b9ce:	str	r0, [sp, #108]	; 0x6c
    b9d0:	itt	gt
    b9d2:	addgt.w	r7, r7, r8, lsl #1
    b9d6:	subgt.w	r8, r7, #48	; 0x30
    b9da:	ldrb	r7, [r0, #0]
    b9dc:	it	le
    b9de:	suble.w	r5, r3, #48	; 0x30
    b9e2:	sub.w	r3, r7, #48	; 0x30
    b9e6:	cmp	r3, #9
    b9e8:	add.w	r4, r4, #1
    b9ec:	bls.n	b9ba <_strtod_l+0xc2>
    b9ee:	ldr.w	r1, [sl]
    b9f2:	mov	r2, r9
    b9f4:	bl	b81c <strncmp>
    b9f8:	cbz	r0, ba3c <_strtod_l+0x144>
    b9fa:	movs	r0, #0
    b9fc:	mov	r3, r7
    b9fe:	mov	r9, r0
    ba00:	mov	r7, r0
    ba02:	mov	sl, r4
    ba04:	cmp	r3, #101	; 0x65
    ba06:	beq.w	bb6e <_strtod_l+0x276>
    ba0a:	cmp	r3, #69	; 0x45
    ba0c:	beq.w	bb6e <_strtod_l+0x276>
    ba10:	movs	r2, #0
    ba12:	cmp	r4, #0
    ba14:	bne.n	babc <_strtod_l+0x1c4>
    ba16:	cbnz	r0, ba20 <_strtod_l+0x128>
    ba18:	ldr	r2, [sp, #40]	; 0x28
    ba1a:	cmp	r2, #0
    ba1c:	beq.w	bfc2 <_strtod_l+0x6ca>
    ba20:	mov.w	r8, #0
    ba24:	mov.w	r9, #0
    ba28:	ldr	r3, [sp, #24]
    ba2a:	cmp	r3, #0
    ba2c:	beq.n	b978 <_strtod_l+0x80>
    ba2e:	ldr	r6, [sp, #108]	; 0x6c
    ba30:	b.n	b974 <_strtod_l+0x7c>
    ba32:	movs	r3, #1
    ba34:	str	r3, [sp, #28]
    ba36:	b.n	b990 <_strtod_l+0x98>
    ba38:	str	r2, [sp, #108]	; 0x6c
    ba3a:	b.n	b926 <_strtod_l+0x2e>
    ba3c:	ldr	r3, [sp, #108]	; 0x6c
    ba3e:	add.w	r2, r3, r9
    ba42:	str	r2, [sp, #108]	; 0x6c
    ba44:	ldrb.w	r3, [r3, r9]
    ba48:	mov	r7, r0
    ba4a:	mov	sl, r4
    ba4c:	sub.w	r2, r3, #48	; 0x30
    ba50:	cmp	r2, #9
    ba52:	bhi.w	bf48 <_strtod_l+0x650>
    ba56:	adds	r1, r0, #1
    ba58:	mov	r3, r2
    ba5a:	cmp	r2, #0
    ba5c:	beq.w	c79e <_strtod_l+0xea6>
    ba60:	cmp	r1, #1
    ba62:	add	r7, r1
    ba64:	it	ne
    ba66:	addne	r0, r0, r4
    ba68:	bne.n	ba76 <_strtod_l+0x17e>
    ba6a:	b.w	c796 <_strtod_l+0xe9e>
    ba6e:	lsls	r5, r1, #1
    ba70:	cmp	r4, r0
    ba72:	beq.w	c3ec <_strtod_l+0xaf4>
    ba76:	adds	r4, #1
    ba78:	subs	r1, r4, #1
    ba7a:	cmp	r1, #8
    ba7c:	add.w	r1, r5, r5, lsl #2
    ba80:	ble.n	ba6e <_strtod_l+0x176>
    ba82:	cmp	r4, #16
    ba84:	itt	le
    ba86:	addle.w	r8, r8, r8, lsl #2
    ba8a:	movle.w	r8, r8, lsl #1
    ba8e:	b.n	ba70 <_strtod_l+0x178>
    ba90:	movs	r3, #0
    ba92:	cmp	r7, #48	; 0x30
    ba94:	str	r3, [sp, #28]
    ba96:	bne.n	b9a0 <_strtod_l+0xa8>
    ba98:	ldrb	r3, [r4, #1]
    ba9a:	cmp	r3, #88	; 0x58
    ba9c:	beq.w	c186 <_strtod_l+0x88e>
    baa0:	cmp	r3, #120	; 0x78
    baa2:	beq.w	c186 <_strtod_l+0x88e>
    baa6:	adds	r4, #1
    baa8:	str	r4, [sp, #108]	; 0x6c
    baaa:	ldrb	r7, [r4, #0]
    baac:	cmp	r7, #48	; 0x30
    baae:	beq.n	baa6 <_strtod_l+0x1ae>
    bab0:	cmp	r7, #0
    bab2:	beq.n	ba20 <_strtod_l+0x128>
    bab4:	movs	r3, #1
    bab6:	str	r4, [sp, #32]
    bab8:	str	r3, [sp, #40]	; 0x28
    baba:	b.n	b9a6 <_strtod_l+0xae>
    babc:	cmp	r4, #16
    babe:	sub.w	r3, r2, r7
    bac2:	mov	r0, r5
    bac4:	mov	r9, r4
    bac6:	str	r3, [sp, #44]	; 0x2c
    bac8:	it	ge
    baca:	movge.w	r9, #16
    bace:	bl	9f84 <__aeabi_ui2d>
    bad2:	cmp.w	sl, #0
    bad6:	it	eq
    bad8:	moveq	sl, r4
    bada:	cmp.w	r9, #9
    bade:	strd	r0, r1, [sp, #16]
    bae2:	ble.n	bb0c <_strtod_l+0x214>
    bae4:	ldr	r3, [pc, #292]	; (bc0c <_strtod_l+0x314>)
    bae6:	add.w	r3, r3, r9, lsl #3
    baea:	ldrd	r2, r3, [r3, #-72]	; 0x48
    baee:	bl	a070 <__aeabi_dmul>
    baf2:	mov	r6, r0
    baf4:	mov	r0, r8
    baf6:	mov	r7, r1
    baf8:	bl	9f84 <__aeabi_ui2d>
    bafc:	mov	r2, r0
    bafe:	mov	r3, r1
    bb00:	mov	r0, r6
    bb02:	mov	r1, r7
    bb04:	bl	9d0c <__adddf3>
    bb08:	strd	r0, r1, [sp, #16]
    bb0c:	cmp	r4, #15
    bb0e:	bgt.w	bc1c <_strtod_l+0x324>
    bb12:	ldr	r3, [sp, #44]	; 0x2c
    bb14:	cmp	r3, #0
    bb16:	beq.n	bb68 <_strtod_l+0x270>
    bb18:	ble.w	c554 <_strtod_l+0xc5c>
    bb1c:	ldr	r3, [sp, #44]	; 0x2c
    bb1e:	cmp	r3, #22
    bb20:	bgt.w	c420 <_strtod_l+0xb28>
    bb24:	ldr	r7, [pc, #228]	; (bc0c <_strtod_l+0x314>)
    bb26:	add.w	r7, r7, r3, lsl #3
    bb2a:	ldrd	r0, r1, [r7]
    bb2e:	ldrd	r2, r3, [sp, #16]
    bb32:	bl	a070 <__aeabi_dmul>
    bb36:	mov	r8, r0
    bb38:	mov	r9, r1
    bb3a:	b.n	ba28 <_strtod_l+0x130>
    bb3c:	add	r0, sp, #108	; 0x6c
    bb3e:	ldr	r1, [pc, #208]	; (bc10 <_strtod_l+0x318>)
    bb40:	bl	107d8 <__match>
    bb44:	cmp	r0, #0
    bb46:	beq.w	b964 <_strtod_l+0x6c>
    bb4a:	ldr	r3, [sp, #108]	; 0x6c
    bb4c:	ldr	r1, [pc, #196]	; (bc14 <_strtod_l+0x31c>)
    bb4e:	subs	r3, #1
    bb50:	add	r0, sp, #108	; 0x6c
    bb52:	str	r3, [sp, #108]	; 0x6c
    bb54:	bl	107d8 <__match>
    bb58:	cbnz	r0, bb60 <_strtod_l+0x268>
    bb5a:	ldr	r3, [sp, #108]	; 0x6c
    bb5c:	adds	r3, #1
    bb5e:	str	r3, [sp, #108]	; 0x6c
    bb60:	ldr	r3, [pc, #180]	; (bc18 <_strtod_l+0x320>)
    bb62:	str	r3, [sp, #20]
    bb64:	movs	r3, #0
    bb66:	str	r3, [sp, #16]
    bb68:	ldrd	r8, r9, [sp, #16]
    bb6c:	b.n	ba28 <_strtod_l+0x130>
    bb6e:	cmp	r4, #0
    bb70:	beq.w	bf08 <_strtod_l+0x610>
    bb74:	ldr	r6, [sp, #108]	; 0x6c
    bb76:	adds	r3, r6, #1
    bb78:	str	r3, [sp, #108]	; 0x6c
    bb7a:	ldrb	r3, [r6, #1]
    bb7c:	cmp	r3, #43	; 0x2b
    bb7e:	beq.w	c13c <_strtod_l+0x844>
    bb82:	cmp	r3, #45	; 0x2d
    bb84:	beq.w	bfb2 <_strtod_l+0x6ba>
    bb88:	mov.w	ip, #0
    bb8c:	sub.w	r2, r3, #48	; 0x30
    bb90:	cmp	r2, #9
    bb92:	bhi.w	c136 <_strtod_l+0x83e>
    bb96:	cmp	r3, #48	; 0x30
    bb98:	bne.n	bba6 <_strtod_l+0x2ae>
    bb9a:	ldr	r2, [sp, #108]	; 0x6c
    bb9c:	adds	r2, #1
    bb9e:	str	r2, [sp, #108]	; 0x6c
    bba0:	ldrb	r3, [r2, #0]
    bba2:	cmp	r3, #48	; 0x30
    bba4:	beq.n	bb9c <_strtod_l+0x2a4>
    bba6:	sub.w	r2, r3, #49	; 0x31
    bbaa:	cmp	r2, #8
    bbac:	bhi.w	ba10 <_strtod_l+0x118>
    bbb0:	ldr	r2, [sp, #108]	; 0x6c
    bbb2:	str	r2, [sp, #48]	; 0x30
    bbb4:	adds	r1, r2, #1
    bbb6:	subs	r3, #48	; 0x30
    bbb8:	str	r1, [sp, #108]	; 0x6c
    bbba:	str	r3, [sp, #44]	; 0x2c
    bbbc:	ldrb	r3, [r2, #1]
    bbbe:	sub.w	lr, r3, #48	; 0x30
    bbc2:	cmp.w	lr, #9
    bbc6:	bhi.n	bbe8 <_strtod_l+0x2f0>
    bbc8:	ldr	r2, [sp, #44]	; 0x2c
    bbca:	adds	r1, #1
    bbcc:	str	r1, [sp, #108]	; 0x6c
    bbce:	add.w	r2, r2, r2, lsl #2
    bbd2:	add.w	r2, r3, r2, lsl #1
    bbd6:	ldrb	r3, [r1, #0]
    bbd8:	sub.w	lr, r3, #48	; 0x30
    bbdc:	cmp.w	lr, #9
    bbe0:	sub.w	r2, r2, #48	; 0x30
    bbe4:	bls.n	bbca <_strtod_l+0x2d2>
    bbe6:	str	r2, [sp, #44]	; 0x2c
    bbe8:	ldr	r2, [sp, #48]	; 0x30
    bbea:	subs	r1, r1, r2
    bbec:	cmp	r1, #8
    bbee:	bgt.w	c40e <_strtod_l+0xb16>
    bbf2:	ldr	r2, [sp, #44]	; 0x2c
    bbf4:	movw	r1, #19999	; 0x4e1f
    bbf8:	cmp	r2, r1
    bbfa:	it	ge
    bbfc:	movge	r2, r1
    bbfe:	cmp.w	ip, #0
    bc02:	beq.w	ba12 <_strtod_l+0x11a>
    bc06:	negs	r2, r2
    bc08:	b.n	ba12 <_strtod_l+0x11a>
    bc0a:	nop
    bc0c:	.word	0x00012c00
    bc10:	.word	0x0001290c
    bc14:	.word	0x00012910
    bc18:	.word	0x7ff00000
    bc1c:	ldr	r3, [sp, #44]	; 0x2c
    bc1e:	rsb	r9, r9, r4
    bc22:	add	r9, r3
    bc24:	cmp.w	r9, #0
    bc28:	ble.w	c33a <_strtod_l+0xa42>
    bc2c:	ands.w	r1, r9, #15
    bc30:	beq.n	bc48 <_strtod_l+0x350>
    bc32:	ldr	r3, [pc, #756]	; (bf28 <_strtod_l+0x630>)
    bc34:	add.w	r1, r3, r1, lsl #3
    bc38:	ldrd	r0, r1, [r1]
    bc3c:	ldrd	r2, r3, [sp, #16]
    bc40:	bl	a070 <__aeabi_dmul>
    bc44:	strd	r0, r1, [sp, #16]
    bc48:	bics.w	r6, r9, #15
    bc4c:	bne.w	c070 <_strtod_l+0x778>
    bc50:	movs	r3, #0
    bc52:	str	r3, [sp, #40]	; 0x28
    bc54:	str	r5, [sp, #0]
    bc56:	mov	r3, r4
    bc58:	mov	r2, sl
    bc5a:	ldr	r1, [sp, #32]
    bc5c:	mov	r0, fp
    bc5e:	bl	10b00 <__s2b>
    bc62:	str	r0, [sp, #72]	; 0x48
    bc64:	cmp	r0, #0
    bc66:	beq.w	c2b6 <_strtod_l+0x9be>
    bc6a:	ldr	r2, [sp, #44]	; 0x2c
    bc6c:	movs	r7, #0
    bc6e:	cmp	r2, #0
    bc70:	rsb	r3, r2, #0
    bc74:	it	ge
    bc76:	movge	r3, r7
    bc78:	str	r3, [sp, #48]	; 0x30
    bc7a:	bic.w	r3, r2, r2, asr #31
    bc7e:	str	r3, [sp, #44]	; 0x2c
    bc80:	mov	sl, r7
    bc82:	ldr	r4, [sp, #72]	; 0x48
    bc84:	mov	r0, fp
    bc86:	ldr	r1, [r4, #4]
    bc88:	bl	10a20 <_Balloc>
    bc8c:	mov	r6, r0
    bc8e:	cmp	r0, #0
    bc90:	beq.w	c148 <_strtod_l+0x850>
    bc94:	ldr	r2, [r4, #16]
    bc96:	vldr	d7, [sp, #16]
    bc9a:	adds	r2, #2
    bc9c:	lsls	r2, r2, #2
    bc9e:	add.w	r1, r4, #12
    bca2:	adds	r0, #12
    bca4:	vstr	d7, [sp, #32]
    bca8:	bl	8734 <memcpy>
    bcac:	vldr	d0, [sp, #32]
    bcb0:	add	r2, sp, #120	; 0x78
    bcb2:	add	r1, sp, #116	; 0x74
    bcb4:	mov	r0, fp
    bcb6:	bl	11144 <__d2b>
    bcba:	str	r0, [sp, #112]	; 0x70
    bcbc:	cmp	r0, #0
    bcbe:	beq.w	c14a <_strtod_l+0x852>
    bcc2:	movs	r1, #1
    bcc4:	mov	r0, fp
    bcc6:	bl	10c34 <__i2b>
    bcca:	mov	sl, r0
    bccc:	cmp	r0, #0
    bcce:	beq.w	c148 <_strtod_l+0x850>
    bcd2:	ldr	r2, [sp, #116]	; 0x74
    bcd4:	cmp	r2, #0
    bcd6:	blt.w	bf40 <_strtod_l+0x648>
    bcda:	ldr	r3, [sp, #48]	; 0x30
    bcdc:	ldr	r4, [sp, #44]	; 0x2c
    bcde:	adds	r5, r3, r2
    bce0:	ldr	r0, [sp, #40]	; 0x28
    bce2:	ldr	r3, [sp, #120]	; 0x78
    bce4:	ldr	r1, [pc, #580]	; (bf2c <_strtod_l+0x634>)
    bce6:	subs	r2, r2, r0
    bce8:	add	r2, r3
    bcea:	subs	r2, #1
    bcec:	cmp	r2, r1
    bcee:	rsb	r3, r3, #54	; 0x36
    bcf2:	bge.w	bed2 <_strtod_l+0x5da>
    bcf6:	subs	r1, r1, r2
    bcf8:	cmp	r1, #31
    bcfa:	sub.w	r3, r3, r1
    bcfe:	bgt.w	bf4e <_strtod_l+0x656>
    bd02:	movs	r2, #1
    bd04:	lsls	r2, r1
    bd06:	str	r2, [sp, #56]	; 0x38
    bd08:	movs	r2, #0
    bd0a:	str	r2, [sp, #76]	; 0x4c
    bd0c:	add.w	r9, r5, r3
    bd10:	add	r4, r3
    bd12:	ldr	r3, [sp, #40]	; 0x28
    bd14:	cmp	r5, r9
    bd16:	mov	r2, r5
    bd18:	add	r4, r3
    bd1a:	it	ge
    bd1c:	movge	r2, r9
    bd1e:	cmp	r2, r4
    bd20:	it	ge
    bd22:	movge	r2, r4
    bd24:	cmp	r2, #0
    bd26:	ble.n	bd30 <_strtod_l+0x438>
    bd28:	rsb	r9, r2, r9
    bd2c:	subs	r4, r4, r2
    bd2e:	subs	r5, r5, r2
    bd30:	ldr	r3, [sp, #48]	; 0x30
    bd32:	cbz	r3, bd64 <_strtod_l+0x46c>
    bd34:	mov	r1, sl
    bd36:	mov	r2, r3
    bd38:	mov	r0, fp
    bd3a:	bl	10d78 <__pow5mult>
    bd3e:	mov	sl, r0
    bd40:	cmp	r0, #0
    bd42:	beq.w	c148 <_strtod_l+0x850>
    bd46:	mov	r1, r0
    bd48:	ldr	r2, [sp, #112]	; 0x70
    bd4a:	mov	r0, fp
    bd4c:	bl	10c48 <__multiply>
    bd50:	cmp	r0, #0
    bd52:	beq.w	c148 <_strtod_l+0x850>
    bd56:	str	r0, [sp, #52]	; 0x34
    bd58:	ldr	r1, [sp, #112]	; 0x70
    bd5a:	mov	r0, fp
    bd5c:	bl	10a6c <_Bfree>
    bd60:	ldr	r2, [sp, #52]	; 0x34
    bd62:	str	r2, [sp, #112]	; 0x70
    bd64:	cmp.w	r9, #0
    bd68:	ble.n	bd7c <_strtod_l+0x484>
    bd6a:	mov	r2, r9
    bd6c:	ldr	r1, [sp, #112]	; 0x70
    bd6e:	mov	r0, fp
    bd70:	bl	10e18 <__lshift>
    bd74:	str	r0, [sp, #112]	; 0x70
    bd76:	cmp	r0, #0
    bd78:	beq.w	c14a <_strtod_l+0x852>
    bd7c:	ldr	r3, [sp, #44]	; 0x2c
    bd7e:	cbz	r3, bd92 <_strtod_l+0x49a>
    bd80:	mov	r1, r6
    bd82:	ldr	r2, [sp, #44]	; 0x2c
    bd84:	mov	r0, fp
    bd86:	bl	10d78 <__pow5mult>
    bd8a:	mov	r6, r0
    bd8c:	cmp	r0, #0
    bd8e:	beq.w	c148 <_strtod_l+0x850>
    bd92:	cmp	r4, #0
    bd94:	ble.n	bda8 <_strtod_l+0x4b0>
    bd96:	mov	r1, r6
    bd98:	mov	r2, r4
    bd9a:	mov	r0, fp
    bd9c:	bl	10e18 <__lshift>
    bda0:	mov	r6, r0
    bda2:	cmp	r0, #0
    bda4:	beq.w	c148 <_strtod_l+0x850>
    bda8:	cmp	r5, #0
    bdaa:	ble.n	bdbe <_strtod_l+0x4c6>
    bdac:	mov	r1, sl
    bdae:	mov	r2, r5
    bdb0:	mov	r0, fp
    bdb2:	bl	10e18 <__lshift>
    bdb6:	mov	sl, r0
    bdb8:	cmp	r0, #0
    bdba:	beq.w	c148 <_strtod_l+0x850>
    bdbe:	mov	r2, r6
    bdc0:	ldr	r1, [sp, #112]	; 0x70
    bdc2:	mov	r0, fp
    bdc4:	bl	10f0c <__mdiff>
    bdc8:	mov	r7, r0
    bdca:	cmp	r0, #0
    bdcc:	beq.w	c148 <_strtod_l+0x850>
    bdd0:	movs	r3, #0
    bdd2:	ldr	r2, [r0, #12]
    bdd4:	str	r3, [r0, #12]
    bdd6:	mov	r1, sl
    bdd8:	str	r2, [sp, #52]	; 0x34
    bdda:	bl	10ec8 <__mcmp>
    bdde:	cmp	r0, #0
    bde0:	blt.w	c5fe <_strtod_l+0xd06>
    bde4:	beq.w	c578 <_strtod_l+0xc80>
    bde8:	mov	r1, sl
    bdea:	mov	r0, r7
    bdec:	bl	11200 <__ratio>
    bdf0:	vmov	r4, r5, d0
    bdf4:	movs	r2, #0
    bdf6:	mov.w	r3, #1073741824	; 0x40000000
    bdfa:	vmov	r0, s0
    bdfe:	mov	r1, r5
    be00:	bl	a568 <__aeabi_dcmple>
    be04:	cmp	r0, #0
    be06:	beq.n	bedc <_strtod_l+0x5e4>
    be08:	ldr	r3, [sp, #52]	; 0x34
    be0a:	cmp	r3, #0
    be0c:	beq.w	bf5e <_strtod_l+0x666>
    be10:	vldr	d7, [pc, #260]	; bf18 <_strtod_l+0x620>
    be14:	ldr	r3, [sp, #20]
    be16:	ldr	r5, [pc, #280]	; (bf30 <_strtod_l+0x638>)
    be18:	vstr	d7, [sp, #56]	; 0x38
    be1c:	movs	r4, #0
    be1e:	mov	r8, r3
    be20:	ldr.w	r9, [pc, #276]	; bf38 <_strtod_l+0x640>
    be24:	ldr	r3, [pc, #268]	; (bf34 <_strtod_l+0x63c>)
    be26:	and.w	r9, r8, r9
    be2a:	cmp	r9, r3
    be2c:	beq.w	c25c <_strtod_l+0x964>
    be30:	ldr	r3, [sp, #40]	; 0x28
    be32:	cbz	r3, be80 <_strtod_l+0x588>
    be34:	cmp.w	r9, #111149056	; 0x6a00000
    be38:	bhi.n	be80 <_strtod_l+0x588>
    be3a:	add	r3, pc, #228	; (adr r3, bf20 <_strtod_l+0x628>)
    be3c:	ldrd	r2, r3, [r3]
    be40:	ldrd	r0, r1, [sp, #56]	; 0x38
    be44:	bl	a568 <__aeabi_dcmple>
    be48:	cbz	r0, be78 <_strtod_l+0x580>
    be4a:	ldrd	r0, r1, [sp, #56]	; 0x38
    be4e:	bl	a620 <__aeabi_d2uiz>
    be52:	cmp	r0, #0
    be54:	beq.w	c4d8 <_strtod_l+0xbe0>
    be58:	bl	9f84 <__aeabi_ui2d>
    be5c:	strd	r0, r1, [sp, #56]	; 0x38
    be60:	ldr	r3, [sp, #52]	; 0x34
    be62:	cmp	r3, #0
    be64:	bne.w	c4ce <_strtod_l+0xbd6>
    be68:	ldrd	r1, r2, [sp, #56]	; 0x38
    be6c:	add.w	r3, r2, #2147483648	; 0x80000000
    be70:	str	r1, [sp, #80]	; 0x50
    be72:	str	r3, [sp, #84]	; 0x54
    be74:	ldrd	r4, r5, [sp, #80]	; 0x50
    be78:	add.w	r3, r5, #112197632	; 0x6b00000
    be7c:	rsb	r5, r9, r3
    be80:	vldr	d0, [sp, #32]
    be84:	bl	11020 <__ulp>
    be88:	mov	r0, r4
    be8a:	vmov	r2, r3, d0
    be8e:	mov	r1, r5
    be90:	bl	a070 <__aeabi_dmul>
    be94:	ldrd	r2, r3, [sp, #32]
    be98:	bl	9d0c <__adddf3>
    be9c:	strd	r0, r1, [sp, #16]
    bea0:	mov	r4, r1
    bea2:	ldr	r3, [sp, #40]	; 0x28
    bea4:	cbnz	r3, beb0 <_strtod_l+0x5b8>
    bea6:	ldr	r3, [pc, #144]	; (bf38 <_strtod_l+0x640>)
    bea8:	ands	r3, r4
    beaa:	cmp	r9, r3
    beac:	beq.w	c2cc <_strtod_l+0x9d4>
    beb0:	ldr	r1, [sp, #112]	; 0x70
    beb2:	mov	r0, fp
    beb4:	bl	10a6c <_Bfree>
    beb8:	mov	r1, r6
    beba:	mov	r0, fp
    bebc:	bl	10a6c <_Bfree>
    bec0:	mov	r1, sl
    bec2:	mov	r0, fp
    bec4:	bl	10a6c <_Bfree>
    bec8:	mov	r1, r7
    beca:	mov	r0, fp
    becc:	bl	10a6c <_Bfree>
    bed0:	b.n	bc82 <_strtod_l+0x38a>
    bed2:	movs	r2, #0
    bed4:	str	r2, [sp, #76]	; 0x4c
    bed6:	movs	r2, #1
    bed8:	str	r2, [sp, #56]	; 0x38
    beda:	b.n	bd0c <_strtod_l+0x414>
    bedc:	ldr	r3, [pc, #92]	; (bf3c <_strtod_l+0x644>)
    bede:	mov	r0, r4
    bee0:	mov	r1, r5
    bee2:	movs	r2, #0
    bee4:	bl	a070 <__aeabi_dmul>
    bee8:	ldr	r3, [sp, #52]	; 0x34
    beea:	strd	r0, r1, [sp, #56]	; 0x38
    beee:	cmp	r3, #0
    bef0:	bne.n	bfa8 <_strtod_l+0x6b0>
    bef2:	add.w	r3, r1, #2147483648	; 0x80000000
    bef6:	str	r0, [sp, #64]	; 0x40
    bef8:	str	r3, [sp, #68]	; 0x44
    befa:	ldr	r3, [sp, #20]
    befc:	ldrd	r4, r5, [sp, #64]	; 0x40
    bf00:	mov	r8, r3
    bf02:	b.n	be20 <_strtod_l+0x528>
    bf04:	mov.w	r9, #1
    bf08:	cmp	r0, #0
    bf0a:	bne.n	bfbe <_strtod_l+0x6c6>
    bf0c:	ldr	r3, [sp, #40]	; 0x28
    bf0e:	cmp	r3, #0
    bf10:	beq.w	b964 <_strtod_l+0x6c>
    bf14:	mov	r4, r0
    bf16:	b.n	bb74 <_strtod_l+0x27c>
    bf18:	.word	0x00000000
    bf1c:	.word	0x3ff00000
    bf20:	.word	0xffc00000
    bf24:	.word	0x41dfffff
    bf28:	.word	0x00012c00
    bf2c:	.word	0xfffffc02
    bf30:	.word	0x3ff00000
    bf34:	.word	0x7fe00000
    bf38:	.word	0x7ff00000
    bf3c:	.word	0x3fe00000
    bf40:	ldr	r3, [sp, #44]	; 0x2c
    bf42:	ldr	r5, [sp, #48]	; 0x30
    bf44:	subs	r4, r3, r2
    bf46:	b.n	bce0 <_strtod_l+0x3e8>
    bf48:	mov.w	r9, #1
    bf4c:	b.n	ba04 <_strtod_l+0x10c>
    bf4e:	ldr	r1, [pc, #736]	; (c230 <_strtod_l+0x938>)
    bf50:	subs	r1, r1, r2
    bf52:	movs	r2, #1
    bf54:	lsl.w	r1, r2, r1
    bf58:	str	r1, [sp, #76]	; 0x4c
    bf5a:	str	r2, [sp, #56]	; 0x38
    bf5c:	b.n	bd0c <_strtod_l+0x414>
    bf5e:	ldrd	r1, r2, [sp, #16]
    bf62:	cmp	r1, #0
    bf64:	bne.w	c0fa <_strtod_l+0x802>
    bf68:	ubfx	r3, r2, #0, #20
    bf6c:	mov	r8, r2
    bf6e:	cmp	r3, #0
    bf70:	bne.w	c106 <_strtod_l+0x80e>
    bf74:	movs	r2, #0
    bf76:	ldr	r3, [pc, #700]	; (c234 <_strtod_l+0x93c>)
    bf78:	mov	r0, r4
    bf7a:	mov	r1, r5
    bf7c:	bl	a554 <__aeabi_dcmplt>
    bf80:	cmp	r0, #0
    bf82:	bne.w	c682 <_strtod_l+0xd8a>
    bf86:	movs	r2, #0
    bf88:	ldr	r3, [pc, #684]	; (c238 <_strtod_l+0x940>)
    bf8a:	mov	r0, r4
    bf8c:	mov	r1, r5
    bf8e:	bl	a070 <__aeabi_dmul>
    bf92:	mov	r2, r1
    bf94:	mov	r1, r0
    bf96:	strd	r1, r2, [sp, #56]	; 0x38
    bf9a:	add.w	r3, r2, #2147483648	; 0x80000000
    bf9e:	str	r0, [sp, #96]	; 0x60
    bfa0:	str	r3, [sp, #100]	; 0x64
    bfa2:	ldrd	r4, r5, [sp, #96]	; 0x60
    bfa6:	b.n	be20 <_strtod_l+0x528>
    bfa8:	vldr	d7, [sp, #56]	; 0x38
    bfac:	vstr	d7, [sp, #64]	; 0x40
    bfb0:	b.n	befa <_strtod_l+0x602>
    bfb2:	mov.w	ip, #1
    bfb6:	adds	r3, r6, #2
    bfb8:	str	r3, [sp, #108]	; 0x6c
    bfba:	ldrb	r3, [r6, #2]
    bfbc:	b.n	bb8c <_strtod_l+0x294>
    bfbe:	movs	r4, #0
    bfc0:	b.n	bb74 <_strtod_l+0x27c>
    bfc2:	cmp.w	r9, #0
    bfc6:	bne.w	b964 <_strtod_l+0x6c>
    bfca:	subs	r3, #73	; 0x49
    bfcc:	cmp	r3, #37	; 0x25
    bfce:	bhi.w	b964 <_strtod_l+0x6c>
    bfd2:	add	r2, pc, #4	; (adr r2, bfd8 <_strtod_l+0x6e0>)
    bfd4:	ldr.w	pc, [r2, r3, lsl #2]
    bfd8:	.word	0x0000bb3d
    bfdc:	.word	0x0000b965
    bfe0:	.word	0x0000b965
    bfe4:	.word	0x0000b965
    bfe8:	.word	0x0000b965
    bfec:	.word	0x0000c115
    bff0:	.word	0x0000b965
    bff4:	.word	0x0000b965
    bff8:	.word	0x0000b965
    bffc:	.word	0x0000b965
    c000:	.word	0x0000b965
    c004:	.word	0x0000b965
    c008:	.word	0x0000b965
    c00c:	.word	0x0000b965
    c010:	.word	0x0000b965
    c014:	.word	0x0000b965
    c018:	.word	0x0000b965
    c01c:	.word	0x0000b965
    c020:	.word	0x0000b965
    c024:	.word	0x0000b965
    c028:	.word	0x0000b965
    c02c:	.word	0x0000b965
    c030:	.word	0x0000b965
    c034:	.word	0x0000b965
    c038:	.word	0x0000b965
    c03c:	.word	0x0000b965
    c040:	.word	0x0000b965
    c044:	.word	0x0000b965
    c048:	.word	0x0000b965
    c04c:	.word	0x0000b965
    c050:	.word	0x0000b965
    c054:	.word	0x0000b965
    c058:	.word	0x0000bb3d
    c05c:	.word	0x0000b965
    c060:	.word	0x0000b965
    c064:	.word	0x0000b965
    c068:	.word	0x0000b965
    c06c:	.word	0x0000c115
    c070:	cmp.w	r6, #308	; 0x134
    c074:	bgt.w	c2b6 <_strtod_l+0x9be>
    c078:	asrs	r6, r6, #4
    c07a:	cmp	r6, #1
    c07c:	ldr.w	r9, [pc, #472]	; c258 <_strtod_l+0x960>
    c080:	ble.w	c6b6 <_strtod_l+0xdbe>
    c084:	ldrd	r0, r1, [sp, #16]
    c088:	movs	r3, #0
    c08a:	mov	r7, r9
    c08c:	mov	r8, r3
    c08e:	tst.w	r6, #1
    c092:	add.w	r8, r8, #1
    c096:	mov.w	r6, r6, asr #1
    c09a:	beq.n	c0a6 <_strtod_l+0x7ae>
    c09c:	ldrd	r2, r3, [r7]
    c0a0:	bl	a070 <__aeabi_dmul>
    c0a4:	movs	r3, #1
    c0a6:	cmp	r6, #1
    c0a8:	add.w	r7, r7, #8
    c0ac:	bne.n	c08e <_strtod_l+0x796>
    c0ae:	cmp	r3, #0
    c0b0:	bne.w	c77a <_strtod_l+0xe82>
    c0b4:	ldr	r3, [sp, #20]
    c0b6:	sub.w	r3, r3, #55574528	; 0x3500000
    c0ba:	str	r3, [sp, #20]
    c0bc:	add.w	r8, r9, r8, lsl #3
    c0c0:	ldrd	r2, r3, [sp, #16]
    c0c4:	ldrd	r0, r1, [r8]
    c0c8:	bl	a070 <__aeabi_dmul>
    c0cc:	bic.w	r3, r1, #2147483648	; 0x80000000
    c0d0:	lsrs	r3, r3, #20
    c0d2:	ldr	r2, [pc, #360]	; (c23c <_strtod_l+0x944>)
    c0d4:	lsls	r3, r3, #20
    c0d6:	cmp	r3, r2
    c0d8:	strd	r0, r1, [sp, #16]
    c0dc:	bhi.w	c2b6 <_strtod_l+0x9be>
    c0e0:	sub.w	r2, r2, #1048576	; 0x100000
    c0e4:	cmp	r3, r2
    c0e6:	bls.w	c678 <_strtod_l+0xd80>
    c0ea:	ldr	r3, [pc, #340]	; (c240 <_strtod_l+0x948>)
    c0ec:	str	r3, [sp, #20]
    c0ee:	movs	r3, #0
    c0f0:	str	r3, [sp, #40]	; 0x28
    c0f2:	mov.w	r3, #4294967295
    c0f6:	str	r3, [sp, #16]
    c0f8:	b.n	bc54 <_strtod_l+0x35c>
    c0fa:	ldrd	r1, r2, [sp, #16]
    c0fe:	cmp	r1, #1
    c100:	beq.w	c4e2 <_strtod_l+0xbea>
    c104:	mov	r8, r2
    c106:	vldr	d7, [pc, #288]	; c228 <_strtod_l+0x930>
    c10a:	movs	r4, #0
    c10c:	ldr	r5, [pc, #308]	; (c244 <_strtod_l+0x94c>)
    c10e:	vstr	d7, [sp, #56]	; 0x38
    c112:	b.n	be20 <_strtod_l+0x528>
    c114:	add	r0, sp, #108	; 0x6c
    c116:	ldr	r1, [pc, #304]	; (c248 <_strtod_l+0x950>)
    c118:	bl	107d8 <__match>
    c11c:	cmp	r0, #0
    c11e:	beq.w	b964 <_strtod_l+0x6c>
    c122:	ldr	r3, [sp, #108]	; 0x6c
    c124:	ldrb	r3, [r3, #0]
    c126:	cmp	r3, #40	; 0x28
    c128:	beq.w	c730 <_strtod_l+0xe38>
    c12c:	ldr	r3, [pc, #284]	; (c24c <_strtod_l+0x954>)
    c12e:	str	r3, [sp, #20]
    c130:	movs	r3, #0
    c132:	str	r3, [sp, #16]
    c134:	b.n	bb68 <_strtod_l+0x270>
    c136:	str	r6, [sp, #108]	; 0x6c
    c138:	movs	r2, #0
    c13a:	b.n	ba12 <_strtod_l+0x11a>
    c13c:	mov.w	ip, #0
    c140:	b.n	bfb6 <_strtod_l+0x6be>
    c142:	adds	r3, #1
    c144:	bne.w	c716 <_strtod_l+0xe1e>
    c148:	ldr	r0, [sp, #112]	; 0x70
    c14a:	ldr	r3, [pc, #260]	; (c250 <_strtod_l+0x958>)
    c14c:	str	r3, [sp, #20]
    c14e:	movs	r2, #0
    c150:	str	r2, [sp, #16]
    c152:	ldrd	r8, r9, [sp, #16]
    c156:	movs	r3, #34	; 0x22
    c158:	str.w	r3, [fp]
    c15c:	mov	r1, r0
    c15e:	mov	r0, fp
    c160:	bl	10a6c <_Bfree>
    c164:	mov	r1, r6
    c166:	mov	r0, fp
    c168:	bl	10a6c <_Bfree>
    c16c:	mov	r1, sl
    c16e:	mov	r0, fp
    c170:	bl	10a6c <_Bfree>
    c174:	ldr	r1, [sp, #72]	; 0x48
    c176:	mov	r0, fp
    c178:	bl	10a6c <_Bfree>
    c17c:	mov	r1, r7
    c17e:	mov	r0, fp
    c180:	bl	10a6c <_Bfree>
    c184:	b.n	ba28 <_strtod_l+0x130>
    c186:	ldr	r2, [sp, #28]
    c188:	str	r5, [sp, #8]
    c18a:	add	r3, sp, #112	; 0x70
    c18c:	str	r2, [sp, #4]
    c18e:	str	r3, [sp, #0]
    c190:	ldr	r2, [pc, #192]	; (c254 <_strtod_l+0x95c>)
    c192:	add	r3, sp, #116	; 0x74
    c194:	add	r1, sp, #108	; 0x6c
    c196:	mov	r0, fp
    c198:	bl	102c8 <__gethex>
    c19c:	ands.w	r6, r0, #7
    c1a0:	mov	r5, r0
    c1a2:	beq.w	ba20 <_strtod_l+0x128>
    c1a6:	cmp	r6, #6
    c1a8:	bne.w	c458 <_strtod_l+0xb60>
    c1ac:	adds	r4, #1
    c1ae:	movs	r3, #0
    c1b0:	str	r4, [sp, #108]	; 0x6c
    c1b2:	mov.w	r8, #0
    c1b6:	mov.w	r9, #0
    c1ba:	str	r3, [sp, #28]
    c1bc:	b.n	ba28 <_strtod_l+0x130>
    c1be:	ldr.w	r1, [sl]
    c1c2:	mov	r0, r4
    c1c4:	mov	r2, r9
    c1c6:	bl	b81c <strncmp>
    c1ca:	cbz	r0, c1e0 <_strtod_l+0x8e8>
    c1cc:	mov.w	sl, #0
    c1d0:	mov	r3, r7
    c1d2:	mov	r8, sl
    c1d4:	mov	r5, sl
    c1d6:	mov	r0, sl
    c1d8:	mov	r7, sl
    c1da:	mov	r4, sl
    c1dc:	mov	r9, sl
    c1de:	b.n	ba04 <_strtod_l+0x10c>
    c1e0:	ldr	r3, [sp, #108]	; 0x6c
    c1e2:	add.w	r2, r3, r9
    c1e6:	str	r2, [sp, #108]	; 0x6c
    c1e8:	ldrb.w	r3, [r3, r9]
    c1ec:	cmp	r3, #48	; 0x30
    c1ee:	bne.n	c1fe <_strtod_l+0x906>
    c1f0:	adds	r2, #1
    c1f2:	str	r2, [sp, #108]	; 0x6c
    c1f4:	ldrb	r3, [r2, #0]
    c1f6:	cmp	r3, #48	; 0x30
    c1f8:	add.w	r0, r0, #1
    c1fc:	beq.n	c1f0 <_strtod_l+0x8f8>
    c1fe:	sub.w	r2, r3, #49	; 0x31
    c202:	cmp	r2, #8
    c204:	bls.w	c500 <_strtod_l+0xc08>
    c208:	mov.w	sl, #0
    c20c:	cmp	r3, #101	; 0x65
    c20e:	mov	r8, sl
    c210:	mov	r5, sl
    c212:	mov	r7, sl
    c214:	beq.w	bf04 <_strtod_l+0x60c>
    c218:	mov	r4, sl
    c21a:	mov.w	r9, #1
    c21e:	b.w	ba0a <_strtod_l+0x112>
    c222:	nop
    c224:	nop.w
    c228:	.word	0x00000000
    c22c:	.word	0x3ff00000
    c230:	.word	0xfffffbe2
    c234:	.word	0x3ff00000
    c238:	.word	0x3fe00000
    c23c:	.word	0x7ca00000
    c240:	.word	0x7fefffff
    c244:	.word	0xbff00000
    c248:	.word	0x00012918
    c24c:	.word	0xfff80000
    c250:	.word	0x7ff00000
    c254:	.word	0x000128f8
    c258:	.word	0x00012cc8
    c25c:	sub.w	r3, r8, #55574528	; 0x3500000
    c260:	str	r3, [sp, #20]
    c262:	vldr	d7, [sp, #16]
    c266:	vmov.f32	s0, s14
    c26a:	vmov.f32	s1, s15
    c26e:	bl	11020 <__ulp>
    c272:	mov	r0, r4
    c274:	vmov	r2, r3, d0
    c278:	mov	r1, r5
    c27a:	bl	a070 <__aeabi_dmul>
    c27e:	ldrd	r2, r3, [sp, #16]
    c282:	bl	9d0c <__adddf3>
    c286:	bic.w	r3, r1, #2147483648	; 0x80000000
    c28a:	strd	r0, r1, [sp, #16]
    c28e:	lsrs	r3, r3, #20
    c290:	ldr	r2, [pc, #684]	; (c540 <_strtod_l+0xc48>)
    c292:	ldrd	r0, r1, [sp, #32]
    c296:	lsls	r3, r3, #20
    c298:	cmp	r3, r2
    c29a:	strd	r0, r1, [sp, #88]	; 0x58
    c29e:	bls.w	c416 <_strtod_l+0xb1e>
    c2a2:	ldr	r3, [pc, #672]	; (c544 <_strtod_l+0xc4c>)
    c2a4:	cmp	r1, r3
    c2a6:	beq.w	c66e <_strtod_l+0xd76>
    c2aa:	ldr	r3, [pc, #664]	; (c544 <_strtod_l+0xc4c>)
    c2ac:	str	r3, [sp, #20]
    c2ae:	mov.w	r3, #4294967295
    c2b2:	str	r3, [sp, #16]
    c2b4:	b.n	beb0 <_strtod_l+0x5b8>
    c2b6:	ldr	r3, [pc, #656]	; (c548 <_strtod_l+0xc50>)
    c2b8:	str	r3, [sp, #20]
    c2ba:	movs	r2, #0
    c2bc:	movs	r3, #34	; 0x22
    c2be:	str	r2, [sp, #16]
    c2c0:	ldrd	r8, r9, [sp, #16]
    c2c4:	str.w	r3, [fp]
    c2c8:	b.w	ba28 <_strtod_l+0x130>
    c2cc:	ldrd	r8, r9, [sp, #56]	; 0x38
    c2d0:	mov	r1, r9
    c2d2:	mov	r0, r8
    c2d4:	bl	a5d0 <__aeabi_d2iz>
    c2d8:	bl	9fa4 <__aeabi_i2d>
    c2dc:	mov	r3, r1
    c2de:	mov	r2, r0
    c2e0:	mov	r1, r9
    c2e2:	mov	r0, r8
    c2e4:	bl	9d08 <__aeabi_dsub>
    c2e8:	ldr	r3, [sp, #52]	; 0x34
    c2ea:	mov	r8, r0
    c2ec:	mov	r9, r1
    c2ee:	cbnz	r3, c312 <_strtod_l+0xa1a>
    c2f0:	ldr	r3, [sp, #16]
    c2f2:	cbnz	r3, c312 <_strtod_l+0xa1a>
    c2f4:	ubfx	r4, r4, #0, #20
    c2f8:	cbnz	r4, c312 <_strtod_l+0xa1a>
    c2fa:	add	r3, pc, #548	; (adr r3, c520 <_strtod_l+0xc28>)
    c2fc:	ldrd	r2, r3, [r3]
    c300:	bl	a554 <__aeabi_dcmplt>
    c304:	cmp	r0, #0
    c306:	beq.w	beb0 <_strtod_l+0x5b8>
    c30a:	ldrd	r8, r9, [sp, #16]
    c30e:	ldr	r0, [sp, #112]	; 0x70
    c310:	b.n	c15c <_strtod_l+0x864>
    c312:	add	r3, pc, #532	; (adr r3, c528 <_strtod_l+0xc30>)
    c314:	ldrd	r2, r3, [r3]
    c318:	mov	r0, r8
    c31a:	mov	r1, r9
    c31c:	bl	a554 <__aeabi_dcmplt>
    c320:	cmp	r0, #0
    c322:	bne.n	c30a <_strtod_l+0xa12>
    c324:	mov	r0, r8
    c326:	mov	r1, r9
    c328:	add	r3, pc, #516	; (adr r3, c530 <_strtod_l+0xc38>)
    c32a:	ldrd	r2, r3, [r3]
    c32e:	bl	a590 <__aeabi_dcmpgt>
    c332:	cmp	r0, #0
    c334:	beq.w	beb0 <_strtod_l+0x5b8>
    c338:	b.n	c30a <_strtod_l+0xa12>
    c33a:	beq.w	bc50 <_strtod_l+0x358>
    c33e:	rsb	r6, r9, #0
    c342:	ands.w	r2, r6, #15
    c346:	beq.n	c35e <_strtod_l+0xa66>
    c348:	ldr	r3, [pc, #512]	; (c54c <_strtod_l+0xc54>)
    c34a:	add.w	r3, r3, r2, lsl #3
    c34e:	ldrd	r0, r1, [sp, #16]
    c352:	ldrd	r2, r3, [r3]
    c356:	bl	a2c4 <__aeabi_ddiv>
    c35a:	strd	r0, r1, [sp, #16]
    c35e:	asrs	r6, r6, #4
    c360:	beq.w	bc50 <_strtod_l+0x358>
    c364:	cmp	r6, #31
    c366:	bgt.n	c3da <_strtod_l+0xae2>
    c368:	ands.w	r3, r6, #16
    c36c:	beq.w	c6e0 <_strtod_l+0xde8>
    c370:	movs	r3, #106	; 0x6a
    c372:	cmp	r6, #0
    c374:	str	r3, [sp, #40]	; 0x28
    c376:	ble.n	c3a0 <_strtod_l+0xaa8>
    c378:	ldrd	r0, r1, [sp, #16]
    c37c:	ldr	r7, [pc, #464]	; (c550 <_strtod_l+0xc58>)
    c37e:	movs	r3, #0
    c380:	lsls	r2, r6, #31
    c382:	bpl.n	c38e <_strtod_l+0xa96>
    c384:	ldrd	r2, r3, [r7]
    c388:	bl	a070 <__aeabi_dmul>
    c38c:	movs	r3, #1
    c38e:	asrs	r6, r6, #1
    c390:	add.w	r7, r7, #8
    c394:	bne.n	c380 <_strtod_l+0xa88>
    c396:	cmp	r3, #0
    c398:	bne.w	c780 <_strtod_l+0xe88>
    c39c:	ldr	r3, [sp, #40]	; 0x28
    c39e:	cbz	r3, c3c8 <_strtod_l+0xad0>
    c3a0:	ldrd	r1, r2, [sp, #16]
    c3a4:	ubfx	r3, r2, #20, #11
    c3a8:	rsb	r3, r3, #107	; 0x6b
    c3ac:	cmp	r3, #0
    c3ae:	mov	r1, r2
    c3b0:	ble.n	c3c8 <_strtod_l+0xad0>
    c3b2:	cmp	r3, #31
    c3b4:	ble.w	c76a <_strtod_l+0xe72>
    c3b8:	movs	r2, #0
    c3ba:	cmp	r3, #52	; 0x34
    c3bc:	str	r2, [sp, #16]
    c3be:	ble.w	c786 <_strtod_l+0xe8e>
    c3c2:	mov.w	r3, #57671680	; 0x3700000
    c3c6:	str	r3, [sp, #20]
    c3c8:	movs	r2, #0
    c3ca:	movs	r3, #0
    c3cc:	ldrd	r0, r1, [sp, #16]
    c3d0:	bl	a540 <__aeabi_dcmpeq>
    c3d4:	cmp	r0, #0
    c3d6:	beq.w	bc54 <_strtod_l+0x35c>
    c3da:	movs	r3, #34	; 0x22
    c3dc:	str.w	r3, [fp]
    c3e0:	mov.w	r8, #0
    c3e4:	mov.w	r9, #0
    c3e8:	b.w	ba28 <_strtod_l+0x130>
    c3ec:	ldr	r1, [sp, #108]	; 0x6c
    c3ee:	adds	r4, #1
    c3f0:	cmp	r0, #8
    c3f2:	ble.w	c512 <_strtod_l+0xc1a>
    c3f6:	cmp	r4, #16
    c3f8:	itt	le
    c3fa:	addle.w	r8, r8, r8, lsl #2
    c3fe:	addle.w	r8, r2, r8, lsl #1
    c402:	movs	r0, #0
    c404:	adds	r3, r1, #1
    c406:	str	r3, [sp, #108]	; 0x6c
    c408:	ldrb	r3, [r1, #1]
    c40a:	b.w	ba4c <_strtod_l+0x154>
    c40e:	movw	r2, #19999	; 0x4e1f
    c412:	b.w	bbfe <_strtod_l+0x306>
    c416:	ldr	r3, [sp, #20]
    c418:	add.w	r4, r3, #55574528	; 0x3500000
    c41c:	str	r4, [sp, #20]
    c41e:	b.n	bea2 <_strtod_l+0x5aa>
    c420:	ldr	r6, [sp, #44]	; 0x2c
    c422:	rsb	r3, r4, #37	; 0x25
    c426:	cmp	r6, r3
    c428:	bgt.w	bc1c <_strtod_l+0x324>
    c42c:	ldr	r5, [pc, #284]	; (c54c <_strtod_l+0xc54>)
    c42e:	rsb	r4, r4, #15
    c432:	add.w	r1, r5, r4, lsl #3
    c436:	subs	r4, r6, r4
    c438:	ldrd	r2, r3, [sp, #16]
    c43c:	ldrd	r0, r1, [r1]
    c440:	add.w	r5, r5, r4, lsl #3
    c444:	bl	a070 <__aeabi_dmul>
    c448:	ldrd	r2, r3, [r5]
    c44c:	bl	a070 <__aeabi_dmul>
    c450:	mov	r8, r0
    c452:	mov	r9, r1
    c454:	b.w	ba28 <_strtod_l+0x130>
    c458:	ldr	r2, [sp, #112]	; 0x70
    c45a:	cbz	r2, c46c <_strtod_l+0xb74>
    c45c:	movs	r1, #53	; 0x35
    c45e:	add	r0, sp, #120	; 0x78
    c460:	bl	11260 <__copybits>
    c464:	mov	r0, fp
    c466:	ldr	r1, [sp, #112]	; 0x70
    c468:	bl	10a6c <_Bfree>
    c46c:	cmp	r6, #6
    c46e:	bhi.n	c488 <_strtod_l+0xb90>
    c470:	tbb	[pc, r6]
    c474:	.word	0x1318211d
    c478:	.short	0x2104
    c47a:	.byte	0x1d
    c47b:	.byte	0x00
    c47c:	mvn.w	r3, #2147483648	; 0x80000000
    c480:	str	r3, [sp, #20]
    c482:	mov.w	r3, #4294967295
    c486:	str	r3, [sp, #16]
    c488:	lsls	r1, r5, #28
    c48a:	bpl.w	bb68 <_strtod_l+0x270>
    c48e:	ldr	r3, [sp, #20]
    c490:	orr.w	r3, r3, #2147483648	; 0x80000000
    c494:	str	r3, [sp, #20]
    c496:	b.w	bb68 <_strtod_l+0x270>
    c49a:	ldr	r3, [pc, #172]	; (c548 <_strtod_l+0xc50>)
    c49c:	str	r3, [sp, #20]
    c49e:	movs	r3, #0
    c4a0:	str	r3, [sp, #16]
    c4a2:	b.n	c488 <_strtod_l+0xb90>
    c4a4:	ldr	r3, [sp, #120]	; 0x78
    c4a6:	str	r3, [sp, #16]
    c4a8:	ldr	r3, [sp, #124]	; 0x7c
    c4aa:	str	r3, [sp, #20]
    c4ac:	b.n	c488 <_strtod_l+0xb90>
    c4ae:	movs	r3, #0
    c4b0:	str	r3, [sp, #20]
    c4b2:	str	r3, [sp, #16]
    c4b4:	b.n	c488 <_strtod_l+0xb90>
    c4b6:	ldr	r2, [sp, #116]	; 0x74
    c4b8:	ldr	r3, [sp, #124]	; 0x7c
    c4ba:	ldr	r1, [sp, #120]	; 0x78
    c4bc:	str	r1, [sp, #16]
    c4be:	addw	r2, r2, #1075	; 0x433
    c4c2:	bic.w	r3, r3, #1048576	; 0x100000
    c4c6:	orr.w	r3, r3, r2, lsl #20
    c4ca:	str	r3, [sp, #20]
    c4cc:	b.n	c488 <_strtod_l+0xb90>
    c4ce:	vldr	d7, [sp, #56]	; 0x38
    c4d2:	vstr	d7, [sp, #80]	; 0x50
    c4d6:	b.n	be74 <_strtod_l+0x57c>
    c4d8:	vldr	d7, [pc, #92]	; c538 <_strtod_l+0xc40>
    c4dc:	vstr	d7, [sp, #56]	; 0x38
    c4e0:	b.n	be60 <_strtod_l+0x568>
    c4e2:	ldrd	r1, r2, [sp, #16]
    c4e6:	mov	r8, r2
    c4e8:	cmp	r2, #0
    c4ea:	bne.w	c106 <_strtod_l+0x80e>
    c4ee:	movs	r3, #34	; 0x22
    c4f0:	str.w	r3, [fp]
    c4f4:	ldr	r0, [sp, #112]	; 0x70
    c4f6:	mov.w	r8, #0
    c4fa:	mov.w	r9, #0
    c4fe:	b.n	c15c <_strtod_l+0x864>
    c500:	ldr	r2, [sp, #108]	; 0x6c
    c502:	str	r2, [sp, #32]
    c504:	movs	r5, #0
    c506:	subs	r3, #48	; 0x30
    c508:	adds	r7, r0, #1
    c50a:	mov	r1, r2
    c50c:	mov	sl, r5
    c50e:	mov	r8, r5
    c510:	movs	r4, #1
    c512:	add.w	r5, r5, r5, lsl #2
    c516:	add.w	r5, r3, r5, lsl #1
    c51a:	movs	r0, #0
    c51c:	b.n	c404 <_strtod_l+0xb0c>
    c51e:	nop
    c520:	.word	0x94a03595
    c524:	.word	0x3fcfffff
    c528:	.word	0x94a03595
    c52c:	.word	0x3fdfffff
    c530:	.word	0x35afe535
    c534:	.word	0x3fe00000
    c538:	.word	0x00000000
    c53c:	.word	0x3ff00000
    c540:	.word	0x7c9fffff
    c544:	.word	0x7fefffff
    c548:	.word	0x7ff00000
    c54c:	.word	0x00012c00
    c550:	.word	0x00012930
    c554:	ldr	r1, [sp, #44]	; 0x2c
    c556:	cmn.w	r1, #22
    c55a:	blt.w	bc1c <_strtod_l+0x324>
    c55e:	ldr	r2, [pc, #600]	; (c7b8 <_strtod_l+0xec0>)
    c560:	sub.w	r2, r2, r1, lsl #3
    c564:	ldrd	r2, r3, [r2]
    c568:	ldrd	r0, r1, [sp, #16]
    c56c:	bl	a2c4 <__aeabi_ddiv>
    c570:	mov	r8, r0
    c572:	mov	r9, r1
    c574:	b.w	ba28 <_strtod_l+0x130>
    c578:	ldr	r3, [sp, #52]	; 0x34
    c57a:	ldrd	r8, r9, [sp, #32]
    c57e:	cmp	r3, #0
    c580:	beq.w	c694 <_strtod_l+0xd9c>
    c584:	ldrd	r4, r5, [sp, #16]
    c588:	ldr	r3, [pc, #560]	; (c7bc <_strtod_l+0xec4>)
    c58a:	ubfx	r1, r5, #0, #20
    c58e:	cmp	r1, r3
    c590:	mov	r2, r5
    c592:	beq.w	c6ea <_strtod_l+0xdf2>
    c596:	ldr	r3, [sp, #76]	; 0x4c
    c598:	cmp	r3, #0
    c59a:	beq.w	c6ac <_strtod_l+0xdb4>
    c59e:	ldr	r2, [sp, #20]
    c5a0:	tst	r3, r2
    c5a2:	beq.n	c5c6 <_strtod_l+0xcce>
    c5a4:	ldr	r3, [sp, #52]	; 0x34
    c5a6:	ldr	r2, [sp, #40]	; 0x28
    c5a8:	ldrd	r0, r1, [sp, #16]
    c5ac:	cmp	r3, #0
    c5ae:	beq.w	c6bc <_strtod_l+0xdc4>
    c5b2:	bl	b8bc <sulp>
    c5b6:	mov	r2, r0
    c5b8:	mov	r3, r1
    c5ba:	mov	r0, r8
    c5bc:	mov	r1, r9
    c5be:	bl	9d0c <__adddf3>
    c5c2:	mov	r8, r0
    c5c4:	mov	r9, r1
    c5c6:	ldr	r3, [sp, #40]	; 0x28
    c5c8:	cbz	r3, c5fa <_strtod_l+0xd02>
    c5ca:	ldr	r3, [pc, #500]	; (c7c0 <_strtod_l+0xec8>)
    c5cc:	str	r3, [sp, #92]	; 0x5c
    c5ce:	movs	r3, #0
    c5d0:	str	r3, [sp, #88]	; 0x58
    c5d2:	ldrd	r2, r3, [sp, #88]	; 0x58
    c5d6:	mov	r0, r8
    c5d8:	mov	r1, r9
    c5da:	bl	a070 <__aeabi_dmul>
    c5de:	mov	r3, r0
    c5e0:	mov	r4, r1
    c5e2:	mov	r8, r0
    c5e4:	mov	r9, r1
    c5e6:	strd	r3, r4, [sp, #16]
    c5ea:	cbnz	r1, c5fa <_strtod_l+0xd02>
    c5ec:	ldr	r3, [sp, #16]
    c5ee:	cbnz	r3, c5fa <_strtod_l+0xd02>
    c5f0:	movs	r3, #34	; 0x22
    c5f2:	ldr	r0, [sp, #112]	; 0x70
    c5f4:	str.w	r3, [fp]
    c5f8:	b.n	c15c <_strtod_l+0x864>
    c5fa:	ldr	r0, [sp, #112]	; 0x70
    c5fc:	b.n	c15c <_strtod_l+0x864>
    c5fe:	ldr	r3, [sp, #52]	; 0x34
    c600:	ldrd	r8, r9, [sp, #32]
    c604:	cmp	r3, #0
    c606:	bne.n	c5c6 <_strtod_l+0xcce>
    c608:	ldrd	r1, r2, [sp, #16]
    c60c:	cmp	r1, #0
    c60e:	bne.n	c5c6 <_strtod_l+0xcce>
    c610:	ubfx	r3, r2, #0, #20
    c614:	mov	r4, r2
    c616:	cmp	r3, #0
    c618:	bne.n	c5c6 <_strtod_l+0xcce>
    c61a:	bic.w	r3, r2, #2147483648	; 0x80000000
    c61e:	lsrs	r3, r3, #20
    c620:	lsls	r3, r3, #20
    c622:	cmp.w	r3, #112197632	; 0x6b00000
    c626:	bls.n	c5c6 <_strtod_l+0xcce>
    c628:	ldr	r3, [r7, #20]
    c62a:	cbnz	r3, c632 <_strtod_l+0xd3a>
    c62c:	ldr	r3, [r7, #16]
    c62e:	cmp	r3, #1
    c630:	ble.n	c5c6 <_strtod_l+0xcce>
    c632:	mov	r1, r7
    c634:	movs	r2, #1
    c636:	mov	r0, fp
    c638:	bl	10e18 <__lshift>
    c63c:	mov	r1, sl
    c63e:	mov	r7, r0
    c640:	bl	10ec8 <__mcmp>
    c644:	cmp	r0, #0
    c646:	ble.n	c5c6 <_strtod_l+0xcce>
    c648:	ldr	r3, [sp, #40]	; 0x28
    c64a:	cmp	r3, #0
    c64c:	bne.w	c754 <_strtod_l+0xe5c>
    c650:	ldr	r3, [pc, #368]	; (c7c4 <_strtod_l+0xecc>)
    c652:	ands	r3, r4
    c654:	sub.w	r3, r3, #1048576	; 0x100000
    c658:	mvn.w	r3, r3, lsr #20
    c65c:	mvn.w	r3, r3, lsl #20
    c660:	str	r3, [sp, #20]
    c662:	mov.w	r3, #4294967295
    c666:	str	r3, [sp, #16]
    c668:	ldrd	r8, r9, [sp, #16]
    c66c:	b.n	c5c6 <_strtod_l+0xcce>
    c66e:	ldr	r3, [sp, #88]	; 0x58
    c670:	adds	r3, #1
    c672:	bne.w	c2aa <_strtod_l+0x9b2>
    c676:	b.n	c148 <_strtod_l+0x850>
    c678:	add.w	r3, r1, #55574528	; 0x3500000
    c67c:	str	r3, [sp, #20]
    c67e:	b.w	bc50 <_strtod_l+0x358>
    c682:	vldr	d7, [pc, #292]	; c7a8 <_strtod_l+0xeb0>
    c686:	vstr	d7, [sp, #96]	; 0x60
    c68a:	vldr	d7, [pc, #292]	; c7b0 <_strtod_l+0xeb8>
    c68e:	vstr	d7, [sp, #56]	; 0x38
    c692:	b.n	bfa2 <_strtod_l+0x6aa>
    c694:	ldrd	r1, r2, [sp, #16]
    c698:	ubfx	r3, r2, #0, #20
    c69c:	mov	r4, r2
    c69e:	cmp	r3, #0
    c6a0:	bne.w	c596 <_strtod_l+0xc9e>
    c6a4:	cmp	r1, #0
    c6a6:	bne.w	c596 <_strtod_l+0xc9e>
    c6aa:	b.n	c648 <_strtod_l+0xd50>
    c6ac:	ldr	r3, [sp, #56]	; 0x38
    c6ae:	ldr	r2, [sp, #16]
    c6b0:	tst	r3, r2
    c6b2:	beq.n	c5c6 <_strtod_l+0xcce>
    c6b4:	b.n	c5a4 <_strtod_l+0xcac>
    c6b6:	mov.w	r8, #0
    c6ba:	b.n	c0b4 <_strtod_l+0x7bc>
    c6bc:	bl	b8bc <sulp>
    c6c0:	mov	r2, r0
    c6c2:	mov	r3, r1
    c6c4:	mov	r0, r8
    c6c6:	mov	r1, r9
    c6c8:	bl	9d08 <__aeabi_dsub>
    c6cc:	movs	r2, #0
    c6ce:	movs	r3, #0
    c6d0:	mov	r8, r0
    c6d2:	mov	r9, r1
    c6d4:	bl	a540 <__aeabi_dcmpeq>
    c6d8:	cmp	r0, #0
    c6da:	bne.w	c4ee <_strtod_l+0xbf6>
    c6de:	b.n	c5c6 <_strtod_l+0xcce>
    c6e0:	cmp	r6, #0
    c6e2:	str	r3, [sp, #40]	; 0x28
    c6e4:	bgt.w	c378 <_strtod_l+0xa80>
    c6e8:	b.n	c3c8 <_strtod_l+0xad0>
    c6ea:	ldr	r3, [sp, #40]	; 0x28
    c6ec:	ldr	r1, [sp, #16]
    c6ee:	cbz	r3, c72a <_strtod_l+0xe32>
    c6f0:	ldr	r3, [pc, #208]	; (c7c4 <_strtod_l+0xecc>)
    c6f2:	ands	r3, r5
    c6f4:	cmp.w	r3, #111149056	; 0x6a00000
    c6f8:	bhi.n	c72a <_strtod_l+0xe32>
    c6fa:	lsrs	r3, r3, #20
    c6fc:	rsb	r3, r3, #107	; 0x6b
    c700:	mov.w	r0, #4294967295
    c704:	lsl.w	r3, r0, r3
    c708:	cmp	r3, r1
    c70a:	bne.w	c596 <_strtod_l+0xc9e>
    c70e:	ldr	r1, [pc, #184]	; (c7c8 <_strtod_l+0xed0>)
    c710:	cmp	r2, r1
    c712:	beq.w	c142 <_strtod_l+0x84a>
    c716:	ldr	r3, [pc, #172]	; (c7c4 <_strtod_l+0xecc>)
    c718:	ands	r3, r2
    c71a:	add.w	r3, r3, #1048576	; 0x100000
    c71e:	str	r3, [sp, #20]
    c720:	movs	r3, #0
    c722:	str	r3, [sp, #16]
    c724:	ldrd	r8, r9, [sp, #16]
    c728:	b.n	c5c6 <_strtod_l+0xcce>
    c72a:	mov.w	r3, #4294967295
    c72e:	b.n	c708 <_strtod_l+0xe10>
    c730:	add	r0, sp, #108	; 0x6c
    c732:	add	r2, sp, #120	; 0x78
    c734:	ldr	r1, [pc, #148]	; (c7cc <_strtod_l+0xed4>)
    c736:	bl	10808 <__hexnan>
    c73a:	cmp	r0, #5
    c73c:	bne.w	c12c <_strtod_l+0x834>
    c740:	ldr	r3, [sp, #124]	; 0x7c
    c742:	orr.w	r3, r3, #2139095040	; 0x7f800000
    c746:	orr.w	r3, r3, #7340032	; 0x700000
    c74a:	str	r3, [sp, #20]
    c74c:	ldr	r3, [sp, #120]	; 0x78
    c74e:	str	r3, [sp, #16]
    c750:	b.w	bb68 <_strtod_l+0x270>
    c754:	ldr	r3, [pc, #108]	; (c7c4 <_strtod_l+0xecc>)
    c756:	ands	r3, r4
    c758:	cmp.w	r3, #112197632	; 0x6b00000
    c75c:	bgt.w	c654 <_strtod_l+0xd5c>
    c760:	cmp.w	r3, #57671680	; 0x3700000
    c764:	bgt.w	c5ca <_strtod_l+0xcd2>
    c768:	b.n	c4ee <_strtod_l+0xbf6>
    c76a:	mov.w	r2, #4294967295
    c76e:	lsl.w	r3, r2, r3
    c772:	ldr	r2, [sp, #16]
    c774:	ands	r2, r3
    c776:	str	r2, [sp, #16]
    c778:	b.n	c3c8 <_strtod_l+0xad0>
    c77a:	strd	r0, r1, [sp, #16]
    c77e:	b.n	c0b4 <_strtod_l+0x7bc>
    c780:	strd	r0, r1, [sp, #16]
    c784:	b.n	c39c <_strtod_l+0xaa4>
    c786:	subs	r3, #32
    c788:	mov.w	r2, #4294967295
    c78c:	lsl.w	r3, r2, r3
    c790:	ands	r3, r1
    c792:	str	r3, [sp, #20]
    c794:	b.n	c3c8 <_strtod_l+0xad0>
    c796:	mov	r0, r4
    c798:	ldr	r1, [sp, #108]	; 0x6c
    c79a:	adds	r4, #1
    c79c:	b.n	c3f0 <_strtod_l+0xaf8>
    c79e:	mov	r0, r1
    c7a0:	ldr	r1, [sp, #108]	; 0x6c
    c7a2:	b.n	c404 <_strtod_l+0xb0c>
    c7a4:	nop.w
    c7a8:	.word	0x00000000
    c7ac:	.word	0xbfe00000
    c7b0:	.word	0x00000000
    c7b4:	.word	0x3fe00000
    c7b8:	.word	0x00012c00
    c7bc:	.word	0x000fffff
    c7c0:	.word	0x39500000
    c7c4:	.word	0x7ff00000
    c7c8:	.word	0x7fefffff
    c7cc:	.word	0x0001291c

0000c7d0 <_strtod_r>:
    c7d0:	ldr	r3, [pc, #20]	; (c7e8 <_strtod_r+0x18>)
    c7d2:	ldr	r3, [r3, #0]
    c7d4:	push	{r4}
    c7d6:	ldr	r3, [r3, #52]	; 0x34
    c7d8:	ldr	r4, [pc, #16]	; (c7ec <_strtod_r+0x1c>)
    c7da:	cmp	r3, #0
    c7dc:	it	eq
    c7de:	moveq	r3, r4
    c7e0:	ldr.w	r4, [sp], #4
    c7e4:	b.w	b8f8 <_strtod_l>
    c7e8:	.word	0x1fff1840
    c7ec:	.word	0x1fff1844

0000c7f0 <_strtol_l.isra.0>:
    c7f0:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c7f4:	ldr.w	r9, [sp, #40]	; 0x28
    c7f8:	mov	r7, r1
    c7fa:	mov	r8, r0
    c7fc:	mov	r6, r2
    c7fe:	mov	r5, r3
    c800:	mov	fp, r1
    c802:	b.n	c806 <_strtol_l.isra.0+0x16>
    c804:	mov	fp, r4
    c806:	mov	r4, fp
    c808:	mov	r0, r9
    c80a:	ldrb.w	sl, [r4], #1
    c80e:	bl	aab4 <__locale_ctype_ptr_l>
    c812:	add	r0, sl
    c814:	ldrb	r1, [r0, #1]
    c816:	and.w	r1, r1, #8
    c81a:	and.w	ip, r1, #255	; 0xff
    c81e:	cmp	r1, #0
    c820:	bne.n	c804 <_strtol_l.isra.0+0x14>
    c822:	mov	r2, sl
    c824:	cmp	r2, #45	; 0x2d
    c826:	beq.n	c8ec <_strtol_l.isra.0+0xfc>
    c828:	cmp	r2, #43	; 0x2b
    c82a:	itt	eq
    c82c:	ldrbeq.w	r2, [fp, #1]
    c830:	addeq.w	r4, fp, #2
    c834:	cmp	r5, #0
    c836:	beq.n	c8c0 <_strtol_l.isra.0+0xd0>
    c838:	cmp	r5, #16
    c83a:	beq.n	c908 <_strtol_l.isra.0+0x118>
    c83c:	mov	r9, r5
    c83e:	cmp.w	ip, #0
    c842:	ite	eq
    c844:	mvneq.w	sl, #2147483648	; 0x80000000
    c848:	movne.w	sl, #2147483648	; 0x80000000
    c84c:	movs	r1, #0
    c84e:	udiv	lr, sl, r9
    c852:	mov	r0, r1
    c854:	mls	sl, r9, lr, sl
    c858:	b.n	c866 <_strtol_l.isra.0+0x76>
    c85a:	beq.n	c8b0 <_strtol_l.isra.0+0xc0>
    c85c:	mla	r0, r9, r0, r3
    c860:	movs	r1, #1
    c862:	ldrb.w	r2, [r4], #1
    c866:	sub.w	r3, r2, #48	; 0x30
    c86a:	cmp	r3, #9
    c86c:	bls.n	c87a <_strtol_l.isra.0+0x8a>
    c86e:	sub.w	r3, r2, #65	; 0x41
    c872:	cmp	r3, #25
    c874:	bhi.n	c88c <_strtol_l.isra.0+0x9c>
    c876:	sub.w	r3, r2, #55	; 0x37
    c87a:	cmp	r5, r3
    c87c:	ble.n	c89c <_strtol_l.isra.0+0xac>
    c87e:	adds	r2, r1, #1
    c880:	beq.n	c862 <_strtol_l.isra.0+0x72>
    c882:	cmp	lr, r0
    c884:	bcs.n	c85a <_strtol_l.isra.0+0x6a>
    c886:	mov.w	r1, #4294967295
    c88a:	b.n	c862 <_strtol_l.isra.0+0x72>
    c88c:	sub.w	r3, r2, #97	; 0x61
    c890:	cmp	r3, #25
    c892:	bhi.n	c89c <_strtol_l.isra.0+0xac>
    c894:	sub.w	r3, r2, #87	; 0x57
    c898:	cmp	r5, r3
    c89a:	bgt.n	c87e <_strtol_l.isra.0+0x8e>
    c89c:	adds	r3, r1, #1
    c89e:	beq.n	c8cc <_strtol_l.isra.0+0xdc>
    c8a0:	cmp.w	ip, #0
    c8a4:	bne.n	c8c8 <_strtol_l.isra.0+0xd8>
    c8a6:	cbz	r6, c8bc <_strtol_l.isra.0+0xcc>
    c8a8:	cbnz	r1, c8e4 <_strtol_l.isra.0+0xf4>
    c8aa:	str	r7, [r6, #0]
    c8ac:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c8b0:	cmp	sl, r3
    c8b2:	bge.n	c85c <_strtol_l.isra.0+0x6c>
    c8b4:	mov	r0, lr
    c8b6:	mov.w	r1, #4294967295
    c8ba:	b.n	c862 <_strtol_l.isra.0+0x72>
    c8bc:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c8c0:	cmp	r2, #48	; 0x30
    c8c2:	beq.n	c8fa <_strtol_l.isra.0+0x10a>
    c8c4:	movs	r5, #10
    c8c6:	b.n	c83c <_strtol_l.isra.0+0x4c>
    c8c8:	negs	r0, r0
    c8ca:	b.n	c8a6 <_strtol_l.isra.0+0xb6>
    c8cc:	cmp.w	ip, #0
    c8d0:	mov.w	r3, #34	; 0x22
    c8d4:	ite	eq
    c8d6:	mvneq.w	r0, #2147483648	; 0x80000000
    c8da:	movne.w	r0, #2147483648	; 0x80000000
    c8de:	str.w	r3, [r8]
    c8e2:	cbz	r6, c922 <_strtol_l.isra.0+0x132>
    c8e4:	subs	r7, r4, #1
    c8e6:	str	r7, [r6, #0]
    c8e8:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c8ec:	add.w	r4, fp, #2
    c8f0:	ldrb.w	r2, [fp, #1]
    c8f4:	mov.w	ip, #1
    c8f8:	b.n	c834 <_strtol_l.isra.0+0x44>
    c8fa:	ldrb	r3, [r4, #0]
    c8fc:	and.w	r3, r3, #223	; 0xdf
    c900:	cmp	r3, #88	; 0x58
    c902:	beq.n	c916 <_strtol_l.isra.0+0x126>
    c904:	movs	r5, #8
    c906:	b.n	c83c <_strtol_l.isra.0+0x4c>
    c908:	cmp	r2, #48	; 0x30
    c90a:	bne.n	c83c <_strtol_l.isra.0+0x4c>
    c90c:	ldrb	r3, [r4, #0]
    c90e:	and.w	r3, r3, #223	; 0xdf
    c912:	cmp	r3, #88	; 0x58
    c914:	bne.n	c83c <_strtol_l.isra.0+0x4c>
    c916:	mov.w	r9, #16
    c91a:	ldrb	r2, [r4, #1]
    c91c:	mov	r5, r9
    c91e:	adds	r4, #2
    c920:	b.n	c83e <_strtol_l.isra.0+0x4e>
    c922:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c926:	nop

0000c928 <_strtol_r>:
    c928:	push	{r4, r5, lr}
    c92a:	ldr	r4, [pc, #24]	; (c944 <_strtol_r+0x1c>)
    c92c:	ldr	r5, [pc, #24]	; (c948 <_strtol_r+0x20>)
    c92e:	ldr	r4, [r4, #0]
    c930:	ldr	r4, [r4, #52]	; 0x34
    c932:	sub	sp, #12
    c934:	cmp	r4, #0
    c936:	it	eq
    c938:	moveq	r4, r5
    c93a:	str	r4, [sp, #0]
    c93c:	bl	c7f0 <_strtol_l.isra.0>
    c940:	add	sp, #12
    c942:	pop	{r4, r5, pc}
    c944:	.word	0x1fff1840
    c948:	.word	0x1fff1844
    c94c:	.word	0xffffffff

0000c950 <_svfprintf_r>:
    c950:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c954:	sub	sp, #260	; 0x104
    c956:	mov	r4, r1
    c958:	str	r1, [sp, #20]
    c95a:	mov	r5, r2
    c95c:	str	r3, [sp, #40]	; 0x28
    c95e:	str	r0, [sp, #24]
    c960:	bl	109a8 <_localeconv_r>
    c964:	ldr	r3, [r0, #0]
    c966:	str	r3, [sp, #76]	; 0x4c
    c968:	mov	r0, r3
    c96a:	bl	b740 <strlen>
    c96e:	ldrh	r3, [r4, #12]
    c970:	str	r0, [sp, #72]	; 0x48
    c972:	lsls	r6, r3, #24
    c974:	bpl.n	c97e <_svfprintf_r+0x2e>
    c976:	ldr	r3, [r4, #16]
    c978:	cmp	r3, #0
    c97a:	beq.w	dbe0 <_svfprintf_r+0x1290>
    c97e:	vldr	d7, [pc, #664]	; cc18 <_svfprintf_r+0x2c8>
    c982:	movs	r3, #0
    c984:	vstr	d7, [sp, #64]	; 0x40
    c988:	str	r3, [sp, #56]	; 0x38
    c98a:	str	r3, [sp, #148]	; 0x94
    c98c:	str	r3, [sp, #144]	; 0x90
    c98e:	str	r3, [sp, #84]	; 0x54
    c990:	str	r3, [sp, #28]
    c992:	ldr.w	sl, [pc, #656]	; cc24 <_svfprintf_r+0x2d4>
    c996:	add	r3, sp, #192	; 0xc0
    c998:	str	r3, [sp, #140]	; 0x8c
    c99a:	mov	r9, r3
    c99c:	mov	r8, r5
    c99e:	ldrb.w	r3, [r8]
    c9a2:	mov	r4, r8
    c9a4:	cbz	r3, c9e2 <_svfprintf_r+0x92>
    c9a6:	cmp	r3, #37	; 0x25
    c9a8:	bne.n	c9b0 <_svfprintf_r+0x60>
    c9aa:	b.n	c9e2 <_svfprintf_r+0x92>
    c9ac:	cmp	r3, #37	; 0x25
    c9ae:	beq.n	c9b8 <_svfprintf_r+0x68>
    c9b0:	ldrb.w	r3, [r4, #1]!
    c9b4:	cmp	r3, #0
    c9b6:	bne.n	c9ac <_svfprintf_r+0x5c>
    c9b8:	rsb	r5, r8, r4
    c9bc:	cbz	r5, c9e2 <_svfprintf_r+0x92>
    c9be:	ldr	r3, [sp, #144]	; 0x90
    c9c0:	ldr	r2, [sp, #148]	; 0x94
    c9c2:	str.w	r8, [r9]
    c9c6:	adds	r3, #1
    c9c8:	add	r2, r5
    c9ca:	cmp	r3, #7
    c9cc:	str.w	r5, [r9, #4]
    c9d0:	str	r2, [sp, #148]	; 0x94
    c9d2:	str	r3, [sp, #144]	; 0x90
    c9d4:	bgt.w	cb24 <_svfprintf_r+0x1d4>
    c9d8:	add.w	r9, r9, #8
    c9dc:	ldr	r3, [sp, #28]
    c9de:	add	r3, r5
    c9e0:	str	r3, [sp, #28]
    c9e2:	ldrb	r3, [r4, #0]
    c9e4:	cmp	r3, #0
    c9e6:	beq.w	cb36 <_svfprintf_r+0x1e6>
    c9ea:	movs	r3, #0
    c9ec:	mov	r2, r3
    c9ee:	strb.w	r3, [sp, #111]	; 0x6f
    c9f2:	mov	r1, r3
    c9f4:	str	r3, [sp, #32]
    c9f6:	str	r3, [sp, #12]
    c9f8:	mov.w	fp, #4294967295
    c9fc:	ldrb	r3, [r4, #1]
    c9fe:	add.w	r8, r4, #1
    ca02:	mov	r5, fp
    ca04:	add.w	r8, r8, #1
    ca08:	sub.w	r0, r3, #32
    ca0c:	cmp	r0, #88	; 0x58
    ca0e:	bhi.w	d27a <_svfprintf_r+0x92a>
    ca12:	tbh	[pc, r0, lsl #1]
    ca16:	.short	0x03a0
    ca18:	.word	0x04320432
    ca1c:	.word	0x043203a8
    ca20:	.word	0x04320432
    ca24:	.word	0x04320432
    ca28:	.word	0x03af0432
    ca2c:	.word	0x043203bd
    ca30:	.word	0x00e2005d
    ca34:	.word	0x01090432
    ca38:	.word	0x01100110
    ca3c:	.word	0x01100110
    ca40:	.word	0x01100110
    ca44:	.word	0x01100110
    ca48:	.word	0x04320110
    ca4c:	.word	0x04320432
    ca50:	.word	0x04320432
    ca54:	.word	0x04320432
    ca58:	.word	0x04320432
    ca5c:	.word	0x01200432
    ca60:	.word	0x04320286
    ca64:	.word	0x04320286
    ca68:	.word	0x04320432
    ca6c:	.word	0x02d40432
    ca70:	.word	0x04320432
    ca74:	.word	0x043202e5
    ca78:	.word	0x04320432
    ca7c:	.word	0x04320432
    ca80:	.word	0x0432030f
    ca84:	.word	0x033d0432
    ca88:	.word	0x04320432
    ca8c:	.word	0x04320432
    ca90:	.word	0x04320432
    ca94:	.word	0x04320432
    ca98:	.word	0x04320432
    ca9c:	.word	0x0391037e
    caa0:	.word	0x02860286
    caa4:	.word	0x03990286
    caa8:	.word	0x04320391
    caac:	.word	0x04070432
    cab0:	.word	0x04120432
    cab4:	.word	0x006400a3
    cab8:	.word	0x043203c2
    cabc:	.word	0x043203c9
    cac0:	.word	0x043203ea
    cac4:	.word	0x03f20432
    cac8:	ldr	r0, [sp, #32]
    caca:	str	r3, [sp, #40]	; 0x28
    cacc:	negs	r0, r0
    cace:	str	r0, [sp, #32]
    cad0:	ldr	r3, [sp, #12]
    cad2:	orr.w	r3, r3, #4
    cad6:	str	r3, [sp, #12]
    cad8:	ldrb.w	r3, [r8]
    cadc:	b.n	ca04 <_svfprintf_r+0xb4>
    cade:	ldr	r0, [sp, #40]	; 0x28
    cae0:	mov	fp, r5
    cae2:	movs	r1, #0
    cae4:	ldr	r4, [r0, #0]
    cae6:	strb.w	r1, [sp, #111]	; 0x6f
    caea:	adds	r7, r0, #4
    caec:	ldr	r0, [sp, #12]
    caee:	movs	r3, #48	; 0x30
    caf0:	movs	r2, #120	; 0x78
    caf2:	cmp	fp, r1
    caf4:	strb.w	r3, [sp, #112]	; 0x70
    caf8:	mov.w	r5, #0
    cafc:	strb.w	r2, [sp, #113]	; 0x71
    cb00:	orr.w	r3, r0, #2
    cb04:	blt.w	d2b4 <_svfprintf_r+0x964>
    cb08:	bic.w	r3, r0, #128	; 0x80
    cb0c:	orr.w	r3, r3, #2
    cb10:	str	r3, [sp, #12]
    cb12:	orrs.w	r3, r4, r5
    cb16:	str	r7, [sp, #40]	; 0x28
    cb18:	beq.w	d260 <_svfprintf_r+0x910>
    cb1c:	mov	r7, r1
    cb1e:	str	r2, [sp, #52]	; 0x34
    cb20:	ldr	r0, [pc, #252]	; (cc20 <_svfprintf_r+0x2d0>)
    cb22:	b.n	d0f2 <_svfprintf_r+0x7a2>
    cb24:	add	r2, sp, #140	; 0x8c
    cb26:	ldr	r1, [sp, #20]
    cb28:	ldr	r0, [sp, #24]
    cb2a:	bl	118e8 <__ssprint_r>
    cb2e:	cbnz	r0, cb44 <_svfprintf_r+0x1f4>
    cb30:	add.w	r9, sp, #192	; 0xc0
    cb34:	b.n	c9dc <_svfprintf_r+0x8c>
    cb36:	ldr	r3, [sp, #148]	; 0x94
    cb38:	cbz	r3, cb44 <_svfprintf_r+0x1f4>
    cb3a:	ldr	r0, [sp, #24]
    cb3c:	ldr	r1, [sp, #20]
    cb3e:	add	r2, sp, #140	; 0x8c
    cb40:	bl	118e8 <__ssprint_r>
    cb44:	ldr	r3, [sp, #20]
    cb46:	ldrh	r3, [r3, #12]
    cb48:	tst.w	r3, #64	; 0x40
    cb4c:	ldr	r3, [sp, #28]
    cb4e:	it	ne
    cb50:	movne.w	r3, #4294967295
    cb54:	mov	r0, r3
    cb56:	add	sp, #260	; 0x104
    cb58:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cb5c:	str	r3, [sp, #52]	; 0x34
    cb5e:	mov	fp, r5
    cb60:	cmp	r2, #0
    cb62:	bne.w	dfcc <_svfprintf_r+0x167c>
    cb66:	ldr	r2, [sp, #12]
    cb68:	ands.w	r3, r2, #32
    cb6c:	beq.w	cffc <_svfprintf_r+0x6ac>
    cb70:	ldr	r7, [sp, #40]	; 0x28
    cb72:	adds	r7, #7
    cb74:	bic.w	r3, r7, #7
    cb78:	movs	r7, #0
    cb7a:	add.w	r1, r3, #8
    cb7e:	cmp	fp, r7
    cb80:	str	r1, [sp, #40]	; 0x28
    cb82:	ldrd	r4, r5, [r3]
    cb86:	strb.w	r7, [sp, #111]	; 0x6f
    cb8a:	blt.w	da52 <_svfprintf_r+0x1102>
    cb8e:	bic.w	r3, r2, #128	; 0x80
    cb92:	str	r3, [sp, #12]
    cb94:	orrs.w	r3, r4, r5
    cb98:	beq.w	d2a4 <_svfprintf_r+0x954>
    cb9c:	add	r6, sp, #192	; 0xc0
    cb9e:	lsrs	r2, r4, #3
    cba0:	orr.w	r2, r2, r5, lsl #29
    cba4:	lsrs	r1, r5, #3
    cba6:	and.w	r3, r4, #7
    cbaa:	mov	r5, r1
    cbac:	mov	r4, r2
    cbae:	adds	r3, #48	; 0x30
    cbb0:	orrs.w	r2, r4, r5
    cbb4:	strb.w	r3, [r6, #-1]!
    cbb8:	bne.n	cb9e <_svfprintf_r+0x24e>
    cbba:	ldr	r2, [sp, #12]
    cbbc:	lsls	r1, r2, #31
    cbbe:	bpl.w	cce0 <_svfprintf_r+0x390>
    cbc2:	cmp	r3, #48	; 0x30
    cbc4:	beq.w	cce0 <_svfprintf_r+0x390>
    cbc8:	movs	r2, #48	; 0x30
    cbca:	subs	r3, r6, #1
    cbcc:	strb.w	r2, [r6, #-1]
    cbd0:	add	r2, sp, #192	; 0xc0
    cbd2:	subs	r2, r2, r3
    cbd4:	str	r2, [sp, #36]	; 0x24
    cbd6:	mov	r6, r3
    cbd8:	b.n	cce6 <_svfprintf_r+0x396>
    cbda:	ldrb.w	r3, [r8]
    cbde:	cmp	r3, #42	; 0x2a
    cbe0:	add.w	r4, r8, #1
    cbe4:	beq.w	dfb0 <_svfprintf_r+0x1660>
    cbe8:	sub.w	r0, r3, #48	; 0x30
    cbec:	cmp	r0, #9
    cbee:	it	ls
    cbf0:	movls	r5, #0
    cbf2:	bhi.w	df02 <_svfprintf_r+0x15b2>
    cbf6:	ldrb.w	r3, [r4], #1
    cbfa:	add.w	r5, r5, r5, lsl #2
    cbfe:	add.w	r5, r0, r5, lsl #1
    cc02:	sub.w	r0, r3, #48	; 0x30
    cc06:	cmp	r0, #9
    cc08:	bls.n	cbf6 <_svfprintf_r+0x2a6>
    cc0a:	orr.w	r5, r5, r5, asr #31
    cc0e:	mov	r8, r4
    cc10:	b.n	ca08 <_svfprintf_r+0xb8>
    cc12:	nop
    cc14:	nop.w
	...
    cc20:	.word	0x0001298c
    cc24:	.word	0x00012958
    cc28:	ldr	r3, [sp, #12]
    cc2a:	orr.w	r3, r3, #128	; 0x80
    cc2e:	str	r3, [sp, #12]
    cc30:	ldrb.w	r3, [r8]
    cc34:	b.n	ca04 <_svfprintf_r+0xb4>
    cc36:	sub.w	r0, r3, #48	; 0x30
    cc3a:	movs	r3, #0
    cc3c:	mov	r4, r3
    cc3e:	ldrb.w	r3, [r8], #1
    cc42:	add.w	r4, r4, r4, lsl #2
    cc46:	add.w	r4, r0, r4, lsl #1
    cc4a:	sub.w	r0, r3, #48	; 0x30
    cc4e:	cmp	r0, #9
    cc50:	bls.n	cc3e <_svfprintf_r+0x2ee>
    cc52:	str	r4, [sp, #32]
    cc54:	b.n	ca08 <_svfprintf_r+0xb8>
    cc56:	str	r3, [sp, #52]	; 0x34
    cc58:	mov	fp, r5
    cc5a:	cmp	r2, #0
    cc5c:	bne.w	dfe8 <_svfprintf_r+0x1698>
    cc60:	ldr	r3, [sp, #12]
    cc62:	orr.w	r3, r3, #16
    cc66:	str	r3, [sp, #12]
    cc68:	ldr	r3, [sp, #12]
    cc6a:	lsls	r4, r3, #26
    cc6c:	bpl.w	d6de <_svfprintf_r+0xd8e>
    cc70:	ldr	r7, [sp, #40]	; 0x28
    cc72:	adds	r7, #7
    cc74:	bic.w	r7, r7, #7
    cc78:	ldrd	r2, r3, [r7]
    cc7c:	add.w	r1, r7, #8
    cc80:	str	r1, [sp, #40]	; 0x28
    cc82:	mov	r4, r2
    cc84:	mov	r5, r3
    cc86:	cmp	r2, #0
    cc88:	sbcs.w	r3, r3, #0
    cc8c:	blt.w	d754 <_svfprintf_r+0xe04>
    cc90:	cmp.w	fp, #0
    cc94:	ldrb.w	r7, [sp, #111]	; 0x6f
    cc98:	blt.w	d71a <_svfprintf_r+0xdca>
    cc9c:	ldr	r3, [sp, #12]
    cc9e:	bic.w	r3, r3, #128	; 0x80
    cca2:	str	r3, [sp, #12]
    cca4:	orrs.w	r3, r4, r5
    cca8:	beq.w	d07c <_svfprintf_r+0x72c>
    ccac:	cmp	r5, #0
    ccae:	it	eq
    ccb0:	cmpeq	r4, #10
    ccb2:	bcc.w	d086 <_svfprintf_r+0x736>
    ccb6:	add	r6, sp, #192	; 0xc0
    ccb8:	mov	r0, r4
    ccba:	mov	r1, r5
    ccbc:	movs	r2, #10
    ccbe:	movs	r3, #0
    ccc0:	bl	a700 <__aeabi_uldivmod>
    ccc4:	adds	r2, #48	; 0x30
    ccc6:	strb.w	r2, [r6, #-1]!
    ccca:	mov	r0, r4
    cccc:	mov	r1, r5
    ccce:	movs	r3, #0
    ccd0:	movs	r2, #10
    ccd2:	bl	a700 <__aeabi_uldivmod>
    ccd6:	mov	r4, r0
    ccd8:	mov	r5, r1
    ccda:	orrs.w	r3, r4, r5
    ccde:	bne.n	ccb8 <_svfprintf_r+0x368>
    cce0:	add	r3, sp, #192	; 0xc0
    cce2:	subs	r3, r3, r6
    cce4:	str	r3, [sp, #36]	; 0x24
    cce6:	ldr	r3, [sp, #36]	; 0x24
    cce8:	cmp	r3, fp
    ccea:	it	lt
    ccec:	movlt	r3, fp
    ccee:	str	r3, [sp, #16]
    ccf0:	movs	r3, #0
    ccf2:	str	r3, [sp, #60]	; 0x3c
    ccf4:	cbz	r7, ccfc <_svfprintf_r+0x3ac>
    ccf6:	ldr	r3, [sp, #16]
    ccf8:	adds	r3, #1
    ccfa:	str	r3, [sp, #16]
    ccfc:	ldr	r3, [sp, #12]
    ccfe:	ands.w	r3, r3, #2
    cd02:	str	r3, [sp, #44]	; 0x2c
    cd04:	beq.n	cd0c <_svfprintf_r+0x3bc>
    cd06:	ldr	r3, [sp, #16]
    cd08:	adds	r3, #2
    cd0a:	str	r3, [sp, #16]
    cd0c:	ldr	r3, [sp, #12]
    cd0e:	ands.w	r3, r3, #132	; 0x84
    cd12:	str	r3, [sp, #48]	; 0x30
    cd14:	bne.w	d2ce <_svfprintf_r+0x97e>
    cd18:	ldr	r3, [sp, #32]
    cd1a:	ldr	r2, [sp, #16]
    cd1c:	subs	r5, r3, r2
    cd1e:	cmp	r5, #0
    cd20:	ble.w	d2ce <_svfprintf_r+0x97e>
    cd24:	cmp	r5, #16
    cd26:	ldr	r1, [sp, #148]	; 0x94
    cd28:	ldr	r2, [sp, #144]	; 0x90
    cd2a:	ldr	r7, [pc, #672]	; (cfcc <_svfprintf_r+0x67c>)
    cd2c:	ble.n	cd7e <_svfprintf_r+0x42e>
    cd2e:	str	r6, [sp, #80]	; 0x50
    cd30:	mov	r0, r9
    cd32:	movs	r4, #16
    cd34:	mov	r9, r7
    cd36:	ldr	r6, [sp, #20]
    cd38:	mov	r7, r5
    cd3a:	ldr	r5, [sp, #24]
    cd3c:	b.n	cd48 <_svfprintf_r+0x3f8>
    cd3e:	subs	r7, #16
    cd40:	cmp	r7, #16
    cd42:	add.w	r0, r0, #8
    cd46:	ble.n	cd76 <_svfprintf_r+0x426>
    cd48:	adds	r2, #1
    cd4a:	ldr	r3, [pc, #640]	; (cfcc <_svfprintf_r+0x67c>)
    cd4c:	str	r2, [sp, #144]	; 0x90
    cd4e:	adds	r1, #16
    cd50:	cmp	r2, #7
    cd52:	str	r1, [sp, #148]	; 0x94
    cd54:	stmia.w	r0, {r3, r4}
    cd58:	ble.n	cd3e <_svfprintf_r+0x3ee>
    cd5a:	add	r2, sp, #140	; 0x8c
    cd5c:	mov	r1, r6
    cd5e:	mov	r0, r5
    cd60:	bl	118e8 <__ssprint_r>
    cd64:	cmp	r0, #0
    cd66:	bne.w	cb44 <_svfprintf_r+0x1f4>
    cd6a:	subs	r7, #16
    cd6c:	cmp	r7, #16
    cd6e:	ldr	r1, [sp, #148]	; 0x94
    cd70:	ldr	r2, [sp, #144]	; 0x90
    cd72:	add	r0, sp, #192	; 0xc0
    cd74:	bgt.n	cd48 <_svfprintf_r+0x3f8>
    cd76:	ldr	r6, [sp, #80]	; 0x50
    cd78:	mov	r5, r7
    cd7a:	mov	r7, r9
    cd7c:	mov	r9, r0
    cd7e:	adds	r2, #1
    cd80:	adds	r4, r5, r1
    cd82:	cmp	r2, #7
    cd84:	str	r4, [sp, #148]	; 0x94
    cd86:	str	r2, [sp, #144]	; 0x90
    cd88:	str.w	r7, [r9]
    cd8c:	str.w	r5, [r9, #4]
    cd90:	bgt.w	d5ee <_svfprintf_r+0xc9e>
    cd94:	ldrb.w	r7, [sp, #111]	; 0x6f
    cd98:	add.w	r9, r9, #8
    cd9c:	cbz	r7, cdbc <_svfprintf_r+0x46c>
    cd9e:	ldr	r3, [sp, #144]	; 0x90
    cda0:	adds	r3, #1
    cda2:	adds	r4, #1
    cda4:	add.w	r1, sp, #111	; 0x6f
    cda8:	movs	r2, #1
    cdaa:	cmp	r3, #7
    cdac:	str	r4, [sp, #148]	; 0x94
    cdae:	str	r3, [sp, #144]	; 0x90
    cdb0:	stmia.w	r9, {r1, r2}
    cdb4:	bgt.w	d502 <_svfprintf_r+0xbb2>
    cdb8:	add.w	r9, r9, #8
    cdbc:	ldr	r3, [sp, #44]	; 0x2c
    cdbe:	cbz	r3, cddc <_svfprintf_r+0x48c>
    cdc0:	ldr	r3, [sp, #144]	; 0x90
    cdc2:	adds	r3, #1
    cdc4:	adds	r4, #2
    cdc6:	add	r1, sp, #112	; 0x70
    cdc8:	movs	r2, #2
    cdca:	cmp	r3, #7
    cdcc:	str	r4, [sp, #148]	; 0x94
    cdce:	str	r3, [sp, #144]	; 0x90
    cdd0:	stmia.w	r9, {r1, r2}
    cdd4:	bgt.w	d51a <_svfprintf_r+0xbca>
    cdd8:	add.w	r9, r9, #8
    cddc:	ldr	r3, [sp, #48]	; 0x30
    cdde:	cmp	r3, #128	; 0x80
    cde0:	beq.w	d3a6 <_svfprintf_r+0xa56>
    cde4:	ldr	r3, [sp, #36]	; 0x24
    cde6:	rsb	r7, r3, fp
    cdea:	cmp	r7, #0
    cdec:	ble.n	ce56 <_svfprintf_r+0x506>
    cdee:	ldr	r2, [pc, #480]	; (cfd0 <_svfprintf_r+0x680>)
    cdf0:	ldr	r3, [sp, #144]	; 0x90
    cdf2:	str	r2, [sp, #44]	; 0x2c
    cdf4:	cmp	r7, #16
    cdf6:	ble.n	ce3e <_svfprintf_r+0x4ee>
    cdf8:	mov	r2, r4
    cdfa:	mov.w	fp, #16
    cdfe:	ldr	r5, [sp, #24]
    ce00:	ldr	r4, [sp, #20]
    ce02:	b.n	ce0e <_svfprintf_r+0x4be>
    ce04:	subs	r7, #16
    ce06:	cmp	r7, #16
    ce08:	add.w	r9, r9, #8
    ce0c:	ble.n	ce3c <_svfprintf_r+0x4ec>
    ce0e:	adds	r3, #1
    ce10:	adds	r2, #16
    ce12:	cmp	r3, #7
    ce14:	str	r2, [sp, #148]	; 0x94
    ce16:	str	r3, [sp, #144]	; 0x90
    ce18:	stmia.w	r9, {sl, fp}
    ce1c:	ble.n	ce04 <_svfprintf_r+0x4b4>
    ce1e:	add	r2, sp, #140	; 0x8c
    ce20:	mov	r1, r4
    ce22:	mov	r0, r5
    ce24:	bl	118e8 <__ssprint_r>
    ce28:	cmp	r0, #0
    ce2a:	bne.w	cb44 <_svfprintf_r+0x1f4>
    ce2e:	subs	r7, #16
    ce30:	cmp	r7, #16
    ce32:	ldr	r2, [sp, #148]	; 0x94
    ce34:	ldr	r3, [sp, #144]	; 0x90
    ce36:	add.w	r9, sp, #192	; 0xc0
    ce3a:	bgt.n	ce0e <_svfprintf_r+0x4be>
    ce3c:	mov	r4, r2
    ce3e:	adds	r3, #1
    ce40:	ldr	r2, [sp, #44]	; 0x2c
    ce42:	str	r3, [sp, #144]	; 0x90
    ce44:	add	r4, r7
    ce46:	cmp	r3, #7
    ce48:	str	r4, [sp, #148]	; 0x94
    ce4a:	stmia.w	r9, {r2, r7}
    ce4e:	bgt.w	d4ea <_svfprintf_r+0xb9a>
    ce52:	add.w	r9, r9, #8
    ce56:	ldr	r3, [sp, #12]
    ce58:	lsls	r2, r3, #23
    ce5a:	bmi.w	d2d2 <_svfprintf_r+0x982>
    ce5e:	ldr	r3, [sp, #144]	; 0x90
    ce60:	ldr	r1, [sp, #36]	; 0x24
    ce62:	str.w	r6, [r9]
    ce66:	adds	r3, #1
    ce68:	add	r4, r1
    ce6a:	cmp	r3, #7
    ce6c:	str	r4, [sp, #148]	; 0x94
    ce6e:	str.w	r1, [r9, #4]
    ce72:	str	r3, [sp, #144]	; 0x90
    ce74:	bgt.w	d4be <_svfprintf_r+0xb6e>
    ce78:	add.w	r9, r9, #8
    ce7c:	ldr	r3, [sp, #12]
    ce7e:	lsls	r1, r3, #29
    ce80:	bpl.n	cf02 <_svfprintf_r+0x5b2>
    ce82:	ldr	r3, [sp, #32]
    ce84:	ldr	r2, [sp, #16]
    ce86:	subs	r5, r3, r2
    ce88:	cmp	r5, #0
    ce8a:	ble.n	cf02 <_svfprintf_r+0x5b2>
    ce8c:	cmp	r5, #16
    ce8e:	ldr	r3, [sp, #144]	; 0x90
    ce90:	ldr	r7, [pc, #312]	; (cfcc <_svfprintf_r+0x67c>)
    ce92:	ble.n	cedc <_svfprintf_r+0x58c>
    ce94:	mov	r2, r4
    ce96:	movs	r6, #16
    ce98:	ldr.w	fp, [sp, #24]
    ce9c:	ldr	r4, [sp, #20]
    ce9e:	b.n	ceaa <_svfprintf_r+0x55a>
    cea0:	subs	r5, #16
    cea2:	cmp	r5, #16
    cea4:	add.w	r9, r9, #8
    cea8:	ble.n	ceda <_svfprintf_r+0x58a>
    ceaa:	adds	r3, #1
    ceac:	ldr	r1, [pc, #284]	; (cfcc <_svfprintf_r+0x67c>)
    ceae:	str	r3, [sp, #144]	; 0x90
    ceb0:	adds	r2, #16
    ceb2:	cmp	r3, #7
    ceb4:	str	r2, [sp, #148]	; 0x94
    ceb6:	stmia.w	r9, {r1, r6}
    ceba:	ble.n	cea0 <_svfprintf_r+0x550>
    cebc:	add	r2, sp, #140	; 0x8c
    cebe:	mov	r1, r4
    cec0:	mov	r0, fp
    cec2:	bl	118e8 <__ssprint_r>
    cec6:	cmp	r0, #0
    cec8:	bne.w	cb44 <_svfprintf_r+0x1f4>
    cecc:	subs	r5, #16
    cece:	cmp	r5, #16
    ced0:	ldr	r2, [sp, #148]	; 0x94
    ced2:	ldr	r3, [sp, #144]	; 0x90
    ced4:	add.w	r9, sp, #192	; 0xc0
    ced8:	bgt.n	ceaa <_svfprintf_r+0x55a>
    ceda:	mov	r4, r2
    cedc:	adds	r3, #1
    cede:	add	r4, r5
    cee0:	cmp	r3, #7
    cee2:	str	r4, [sp, #148]	; 0x94
    cee4:	str	r3, [sp, #144]	; 0x90
    cee6:	str.w	r7, [r9]
    ceea:	str.w	r5, [r9, #4]
    ceee:	ble.n	cf02 <_svfprintf_r+0x5b2>
    cef0:	add	r2, sp, #140	; 0x8c
    cef2:	ldr	r1, [sp, #20]
    cef4:	ldr	r0, [sp, #24]
    cef6:	bl	118e8 <__ssprint_r>
    cefa:	cmp	r0, #0
    cefc:	bne.w	cb44 <_svfprintf_r+0x1f4>
    cf00:	ldr	r4, [sp, #148]	; 0x94
    cf02:	ldr	r3, [sp, #28]
    cf04:	ldr	r2, [sp, #32]
    cf06:	ldr	r1, [sp, #16]
    cf08:	cmp	r2, r1
    cf0a:	ite	ge
    cf0c:	addge	r3, r3, r2
    cf0e:	addlt	r3, r3, r1
    cf10:	str	r3, [sp, #28]
    cf12:	cmp	r4, #0
    cf14:	bne.w	d4d6 <_svfprintf_r+0xb86>
    cf18:	movs	r3, #0
    cf1a:	str	r3, [sp, #144]	; 0x90
    cf1c:	add.w	r9, sp, #192	; 0xc0
    cf20:	b.n	c99e <_svfprintf_r+0x4e>
    cf22:	str	r3, [sp, #52]	; 0x34
    cf24:	mov	fp, r5
    cf26:	cmp	r2, #0
    cf28:	bne.w	dff0 <_svfprintf_r+0x16a0>
    cf2c:	ldr	r3, [sp, #12]
    cf2e:	ldr	r7, [sp, #40]	; 0x28
    cf30:	lsls	r2, r3, #28
    cf32:	add.w	r7, r7, #7
    cf36:	bpl.w	da22 <_svfprintf_r+0x10d2>
    cf3a:	bic.w	r3, r7, #7
    cf3e:	vldr	d7, [r3]
    cf42:	vstr	d7, [sp, #64]	; 0x40
    cf46:	add.w	r2, r3, #8
    cf4a:	str	r2, [sp, #40]	; 0x28
    cf4c:	ldrd	r1, r2, [sp, #64]	; 0x40
    cf50:	bic.w	r3, r2, #2147483648	; 0x80000000
    cf54:	str	r1, [sp, #88]	; 0x58
    cf56:	str	r3, [sp, #92]	; 0x5c
    cf58:	ldrd	r4, r5, [sp, #88]	; 0x58
    cf5c:	mov.w	r2, #4294967295
    cf60:	mov	r0, r4
    cf62:	mov	r1, r5
    cf64:	ldr	r3, [pc, #108]	; (cfd4 <_svfprintf_r+0x684>)
    cf66:	bl	a5a4 <__aeabi_dcmpun>
    cf6a:	cmp	r0, #0
    cf6c:	bne.w	d924 <_svfprintf_r+0xfd4>
    cf70:	mov.w	r2, #4294967295
    cf74:	ldr	r3, [pc, #92]	; (cfd4 <_svfprintf_r+0x684>)
    cf76:	mov	r0, r4
    cf78:	mov	r1, r5
    cf7a:	bl	a568 <__aeabi_dcmple>
    cf7e:	cmp	r0, #0
    cf80:	bne.w	d924 <_svfprintf_r+0xfd4>
    cf84:	movs	r2, #0
    cf86:	movs	r3, #0
    cf88:	ldrd	r0, r1, [sp, #64]	; 0x40
    cf8c:	bl	a554 <__aeabi_dcmplt>
    cf90:	cmp	r0, #0
    cf92:	bne.w	de3a <_svfprintf_r+0x14ea>
    cf96:	ldrb.w	r7, [sp, #111]	; 0x6f
    cf9a:	ldr	r6, [pc, #60]	; (cfd8 <_svfprintf_r+0x688>)
    cf9c:	ldr	r3, [pc, #60]	; (cfdc <_svfprintf_r+0x68c>)
    cf9e:	ldr	r1, [sp, #12]
    cfa0:	bic.w	r1, r1, #128	; 0x80
    cfa4:	str	r1, [sp, #12]
    cfa6:	ldr	r1, [sp, #52]	; 0x34
    cfa8:	movs	r2, #3
    cfaa:	mov.w	fp, #0
    cfae:	str	r2, [sp, #16]
    cfb0:	cmp	r1, #71	; 0x47
    cfb2:	it	le
    cfb4:	movle	r6, r3
    cfb6:	str	r2, [sp, #36]	; 0x24
    cfb8:	str.w	fp, [sp, #60]	; 0x3c
    cfbc:	b.n	ccf4 <_svfprintf_r+0x3a4>
    cfbe:	ldr	r3, [sp, #12]
    cfc0:	orr.w	r3, r3, #8
    cfc4:	str	r3, [sp, #12]
    cfc6:	ldrb.w	r3, [r8]
    cfca:	b.n	ca04 <_svfprintf_r+0xb4>
    cfcc:	.word	0x000129ac
    cfd0:	.word	0x00012958
    cfd4:	.word	0x7fefffff
    cfd8:	.word	0x0001296c
    cfdc:	.word	0x00012968
    cfe0:	str	r3, [sp, #52]	; 0x34
    cfe2:	mov	fp, r5
    cfe4:	cmp	r2, #0
    cfe6:	bne.w	e008 <_svfprintf_r+0x16b8>
    cfea:	ldr	r3, [sp, #12]
    cfec:	orr.w	r3, r3, #16
    cff0:	str	r3, [sp, #12]
    cff2:	ldr	r2, [sp, #12]
    cff4:	ands.w	r3, r2, #32
    cff8:	bne.w	cb70 <_svfprintf_r+0x220>
    cffc:	ldr	r1, [sp, #12]
    cffe:	ands.w	r2, r1, #16
    d002:	beq.w	d8bc <_svfprintf_r+0xf6c>
    d006:	ldr	r0, [sp, #40]	; 0x28
    d008:	strb.w	r3, [sp, #111]	; 0x6f
    d00c:	cmp.w	fp, #0
    d010:	ldr	r4, [r0, #0]
    d012:	add.w	r7, r0, #4
    d016:	mov.w	r5, #0
    d01a:	blt.w	da50 <_svfprintf_r+0x1100>
    d01e:	mov	r2, r1
    d020:	bic.w	r2, r2, #128	; 0x80
    d024:	str	r2, [sp, #12]
    d026:	orrs.w	r2, r4, r5
    d02a:	str	r7, [sp, #40]	; 0x28
    d02c:	beq.w	d2a4 <_svfprintf_r+0x954>
    d030:	mov	r7, r3
    d032:	b.n	cb9c <_svfprintf_r+0x24c>
    d034:	str	r3, [sp, #52]	; 0x34
    d036:	mov	fp, r5
    d038:	cmp	r2, #0
    d03a:	bne.w	e000 <_svfprintf_r+0x16b0>
    d03e:	ldr	r3, [sp, #12]
    d040:	orr.w	r3, r3, #16
    d044:	str	r3, [sp, #12]
    d046:	ldr	r2, [sp, #12]
    d048:	ands.w	r3, r2, #32
    d04c:	beq.w	d6a8 <_svfprintf_r+0xd58>
    d050:	ldr	r7, [sp, #40]	; 0x28
    d052:	adds	r7, #7
    d054:	bic.w	r3, r7, #7
    d058:	movs	r7, #0
    d05a:	add.w	r1, r3, #8
    d05e:	cmp	fp, r7
    d060:	str	r1, [sp, #40]	; 0x28
    d062:	ldrd	r4, r5, [r3]
    d066:	strb.w	r7, [sp, #111]	; 0x6f
    d06a:	blt.w	d71a <_svfprintf_r+0xdca>
    d06e:	bic.w	r3, r2, #128	; 0x80
    d072:	str	r3, [sp, #12]
    d074:	orrs.w	r3, r4, r5
    d078:	bne.w	ccac <_svfprintf_r+0x35c>
    d07c:	cmp.w	fp, #0
    d080:	beq.w	d26e <_svfprintf_r+0x91e>
    d084:	movs	r4, #0
    d086:	add	r6, sp, #256	; 0x100
    d088:	adds	r4, #48	; 0x30
    d08a:	strb.w	r4, [r6, #-65]!
    d08e:	b.n	cce0 <_svfprintf_r+0x390>
    d090:	str	r3, [sp, #52]	; 0x34
    d092:	mov	fp, r5
    d094:	cmp	r2, #0
    d096:	bne.w	dff8 <_svfprintf_r+0x16a8>
    d09a:	ldr	r3, [sp, #12]
    d09c:	ldr	r0, [pc, #700]	; (d35c <_svfprintf_r+0xa0c>)
    d09e:	lsls	r5, r3, #26
    d0a0:	bpl.w	d20e <_svfprintf_r+0x8be>
    d0a4:	ldr	r7, [sp, #40]	; 0x28
    d0a6:	adds	r7, #7
    d0a8:	bic.w	r3, r7, #7
    d0ac:	ldrd	r4, r5, [r3]
    d0b0:	add.w	r2, r3, #8
    d0b4:	str	r2, [sp, #40]	; 0x28
    d0b6:	ldr	r2, [sp, #12]
    d0b8:	ands.w	r7, r2, #1
    d0bc:	beq.w	d532 <_svfprintf_r+0xbe2>
    d0c0:	orrs.w	r3, r4, r5
    d0c4:	beq.w	dacc <_svfprintf_r+0x117c>
    d0c8:	ldrb.w	r2, [sp, #52]	; 0x34
    d0cc:	strb.w	r2, [sp, #113]	; 0x71
    d0d0:	movs	r7, #0
    d0d2:	ldr	r2, [sp, #12]
    d0d4:	strb.w	r7, [sp, #111]	; 0x6f
    d0d8:	movs	r3, #48	; 0x30
    d0da:	cmp	fp, r7
    d0dc:	strb.w	r3, [sp, #112]	; 0x70
    d0e0:	orr.w	r3, r2, #2
    d0e4:	blt.w	de44 <_svfprintf_r+0x14f4>
    d0e8:	bic.w	r3, r2, #128	; 0x80
    d0ec:	orr.w	r3, r3, #2
    d0f0:	str	r3, [sp, #12]
    d0f2:	add	r6, sp, #192	; 0xc0
    d0f4:	lsrs	r3, r4, #4
    d0f6:	and.w	r1, r4, #15
    d0fa:	orr.w	r3, r3, r5, lsl #28
    d0fe:	lsrs	r2, r5, #4
    d100:	mov	r4, r3
    d102:	mov	r5, r2
    d104:	ldrb	r3, [r0, r1]
    d106:	strb.w	r3, [r6, #-1]!
    d10a:	orrs.w	r3, r4, r5
    d10e:	bne.n	d0f4 <_svfprintf_r+0x7a4>
    d110:	b.n	cce0 <_svfprintf_r+0x390>
    d112:	ldr	r1, [sp, #40]	; 0x28
    d114:	str	r3, [sp, #52]	; 0x34
    d116:	ldr	r2, [r1, #0]
    d118:	strb.w	r2, [sp, #152]	; 0x98
    d11c:	movs	r3, #0
    d11e:	mov	r2, r1
    d120:	mov	r7, r3
    d122:	strb.w	r3, [sp, #111]	; 0x6f
    d126:	adds	r2, #4
    d128:	movs	r3, #1
    d12a:	str	r3, [sp, #16]
    d12c:	mov	fp, r7
    d12e:	str	r7, [sp, #60]	; 0x3c
    d130:	str	r2, [sp, #40]	; 0x28
    d132:	str	r3, [sp, #36]	; 0x24
    d134:	add	r6, sp, #152	; 0x98
    d136:	b.n	ccfc <_svfprintf_r+0x3ac>
    d138:	str	r3, [sp, #52]	; 0x34
    d13a:	mov	fp, r5
    d13c:	cmp	r2, #0
    d13e:	beq.w	cc68 <_svfprintf_r+0x318>
    d142:	strb.w	r1, [sp, #111]	; 0x6f
    d146:	b.n	cc68 <_svfprintf_r+0x318>
    d148:	ldr	r3, [sp, #12]
    d14a:	orr.w	r3, r3, #64	; 0x40
    d14e:	str	r3, [sp, #12]
    d150:	ldrb.w	r3, [r8]
    d154:	b.n	ca04 <_svfprintf_r+0xb4>
    d156:	ldrb.w	r3, [r8]
    d15a:	cmp	r1, #0
    d15c:	bne.w	ca04 <_svfprintf_r+0xb4>
    d160:	movs	r2, #1
    d162:	movs	r1, #32
    d164:	b.n	ca04 <_svfprintf_r+0xb4>
    d166:	ldr	r3, [sp, #12]
    d168:	orr.w	r3, r3, #1
    d16c:	str	r3, [sp, #12]
    d16e:	ldrb.w	r3, [r8]
    d172:	b.n	ca04 <_svfprintf_r+0xb4>
    d174:	ldr	r4, [sp, #40]	; 0x28
    d176:	ldr	r3, [r4, #0]
    d178:	str	r3, [sp, #32]
    d17a:	mov	r0, r3
    d17c:	cmp	r0, #0
    d17e:	mov	r3, r4
    d180:	add.w	r3, r3, #4
    d184:	blt.w	cac8 <_svfprintf_r+0x178>
    d188:	str	r3, [sp, #40]	; 0x28
    d18a:	ldrb.w	r3, [r8]
    d18e:	b.n	ca04 <_svfprintf_r+0xb4>
    d190:	ldrb.w	r3, [r8]
    d194:	movs	r2, #1
    d196:	movs	r1, #43	; 0x2b
    d198:	b.n	ca04 <_svfprintf_r+0xb4>
    d19a:	ldr	r3, [sp, #12]
    d19c:	orr.w	r3, r3, #32
    d1a0:	str	r3, [sp, #12]
    d1a2:	ldrb.w	r3, [r8]
    d1a6:	b.n	ca04 <_svfprintf_r+0xb4>
    d1a8:	ldr	r2, [sp, #40]	; 0x28
    d1aa:	str	r3, [sp, #52]	; 0x34
    d1ac:	ldr	r6, [r2, #0]
    d1ae:	movs	r4, #0
    d1b0:	strb.w	r4, [sp, #111]	; 0x6f
    d1b4:	adds	r7, r2, #4
    d1b6:	cmp	r6, #0
    d1b8:	beq.w	ddf4 <_svfprintf_r+0x14a4>
    d1bc:	cmp	r5, #0
    d1be:	blt.w	dc84 <_svfprintf_r+0x1334>
    d1c2:	mov	r2, r5
    d1c4:	mov	r1, r4
    d1c6:	mov	r0, r6
    d1c8:	bl	b090 <memchr>
    d1cc:	cmp	r0, #0
    d1ce:	beq.w	de98 <_svfprintf_r+0x1548>
    d1d2:	subs	r3, r0, r6
    d1d4:	str	r3, [sp, #36]	; 0x24
    d1d6:	mov	fp, r4
    d1d8:	bic.w	r3, r3, r3, asr #31
    d1dc:	str	r7, [sp, #40]	; 0x28
    d1de:	str	r3, [sp, #16]
    d1e0:	str.w	fp, [sp, #60]	; 0x3c
    d1e4:	ldrb.w	r7, [sp, #111]	; 0x6f
    d1e8:	b.n	ccf4 <_svfprintf_r+0x3a4>
    d1ea:	str	r3, [sp, #52]	; 0x34
    d1ec:	mov	fp, r5
    d1ee:	cmp	r2, #0
    d1f0:	beq.w	d046 <_svfprintf_r+0x6f6>
    d1f4:	strb.w	r1, [sp, #111]	; 0x6f
    d1f8:	b.n	d046 <_svfprintf_r+0x6f6>
    d1fa:	str	r3, [sp, #52]	; 0x34
    d1fc:	mov	fp, r5
    d1fe:	cmp	r2, #0
    d200:	bne.w	e020 <_svfprintf_r+0x16d0>
    d204:	ldr	r3, [sp, #12]
    d206:	ldr	r0, [pc, #344]	; (d360 <_svfprintf_r+0xa10>)
    d208:	lsls	r5, r3, #26
    d20a:	bmi.w	d0a4 <_svfprintf_r+0x754>
    d20e:	ldr	r3, [sp, #12]
    d210:	lsls	r4, r3, #27
    d212:	bpl.w	da92 <_svfprintf_r+0x1142>
    d216:	ldr	r2, [sp, #40]	; 0x28
    d218:	mov	r3, r2
    d21a:	adds	r3, #4
    d21c:	ldr	r4, [r2, #0]
    d21e:	str	r3, [sp, #40]	; 0x28
    d220:	movs	r5, #0
    d222:	b.n	d0b6 <_svfprintf_r+0x766>
    d224:	ldrb.w	r3, [r8]
    d228:	cmp	r3, #108	; 0x6c
    d22a:	beq.w	dbb2 <_svfprintf_r+0x1262>
    d22e:	ldr	r0, [sp, #12]
    d230:	orr.w	r0, r0, #16
    d234:	str	r0, [sp, #12]
    d236:	b.w	ca04 <_svfprintf_r+0xb4>
    d23a:	cmp	r2, #0
    d23c:	bne.w	e018 <_svfprintf_r+0x16c8>
    d240:	ldr	r3, [sp, #12]
    d242:	lsls	r3, r3, #26
    d244:	bpl.w	d8f6 <_svfprintf_r+0xfa6>
    d248:	ldr	r2, [sp, #40]	; 0x28
    d24a:	ldr	r1, [sp, #28]
    d24c:	ldr	r3, [r2, #0]
    d24e:	asrs	r5, r1, #31
    d250:	mov	r0, r1
    d252:	adds	r2, #4
    d254:	mov	r1, r5
    d256:	str	r2, [sp, #40]	; 0x28
    d258:	strd	r0, r1, [r3]
    d25c:	b.w	c99e <_svfprintf_r+0x4e>
    d260:	ldr	r0, [pc, #252]	; (d360 <_svfprintf_r+0xa10>)
    d262:	str	r2, [sp, #52]	; 0x34
    d264:	cmp.w	fp, #0
    d268:	bne.w	d554 <_svfprintf_r+0xc04>
    d26c:	mov	r7, fp
    d26e:	mov.w	fp, #0
    d272:	str.w	fp, [sp, #36]	; 0x24
    d276:	add	r6, sp, #192	; 0xc0
    d278:	b.n	cce6 <_svfprintf_r+0x396>
    d27a:	str	r3, [sp, #52]	; 0x34
    d27c:	cmp	r2, #0
    d27e:	bne.w	e010 <_svfprintf_r+0x16c0>
    d282:	ldr	r2, [sp, #52]	; 0x34
    d284:	cmp	r2, #0
    d286:	beq.w	cb36 <_svfprintf_r+0x1e6>
    d28a:	movs	r3, #0
    d28c:	movs	r1, #1
    d28e:	mov	r7, r3
    d290:	str	r1, [sp, #16]
    d292:	strb.w	r2, [sp, #152]	; 0x98
    d296:	strb.w	r3, [sp, #111]	; 0x6f
    d29a:	mov	fp, r3
    d29c:	str	r3, [sp, #60]	; 0x3c
    d29e:	str	r1, [sp, #36]	; 0x24
    d2a0:	add	r6, sp, #152	; 0x98
    d2a2:	b.n	ccfc <_svfprintf_r+0x3ac>
    d2a4:	cmp.w	fp, #0
    d2a8:	beq.w	dec8 <_svfprintf_r+0x1578>
    d2ac:	movs	r7, #0
    d2ae:	movs	r4, #0
    d2b0:	movs	r5, #0
    d2b2:	b.n	cb9c <_svfprintf_r+0x24c>
    d2b4:	ldr	r0, [pc, #168]	; (d360 <_svfprintf_r+0xa10>)
    d2b6:	str	r3, [sp, #12]
    d2b8:	str	r2, [sp, #52]	; 0x34
    d2ba:	orrs.w	r3, r4, r5
    d2be:	str	r7, [sp, #40]	; 0x28
    d2c0:	mov.w	r7, #0
    d2c4:	bne.w	d0f2 <_svfprintf_r+0x7a2>
    d2c8:	movs	r4, #0
    d2ca:	movs	r5, #0
    d2cc:	b.n	d0f2 <_svfprintf_r+0x7a2>
    d2ce:	ldr	r4, [sp, #148]	; 0x94
    d2d0:	b.n	cd9c <_svfprintf_r+0x44c>
    d2d2:	ldr	r3, [sp, #52]	; 0x34
    d2d4:	cmp	r3, #101	; 0x65
    d2d6:	ble.w	d42e <_svfprintf_r+0xade>
    d2da:	movs	r2, #0
    d2dc:	movs	r3, #0
    d2de:	ldrd	r0, r1, [sp, #64]	; 0x40
    d2e2:	bl	a540 <__aeabi_dcmpeq>
    d2e6:	cmp	r0, #0
    d2e8:	beq.w	d558 <_svfprintf_r+0xc08>
    d2ec:	ldr	r3, [sp, #144]	; 0x90
    d2ee:	ldr	r2, [pc, #116]	; (d364 <_svfprintf_r+0xa14>)
    d2f0:	str.w	r2, [r9]
    d2f4:	adds	r3, #1
    d2f6:	adds	r4, #1
    d2f8:	movs	r2, #1
    d2fa:	cmp	r3, #7
    d2fc:	str	r4, [sp, #148]	; 0x94
    d2fe:	str	r3, [sp, #144]	; 0x90
    d300:	str.w	r2, [r9, #4]
    d304:	bgt.w	dae4 <_svfprintf_r+0x1194>
    d308:	add.w	r9, r9, #8
    d30c:	ldr	r3, [sp, #116]	; 0x74
    d30e:	ldr	r2, [sp, #56]	; 0x38
    d310:	cmp	r3, r2
    d312:	blt.n	d31c <_svfprintf_r+0x9cc>
    d314:	ldr	r3, [sp, #12]
    d316:	lsls	r3, r3, #31
    d318:	bpl.w	ce7c <_svfprintf_r+0x52c>
    d31c:	ldr	r3, [sp, #144]	; 0x90
    d31e:	ldr	r1, [sp, #72]	; 0x48
    d320:	ldr	r2, [sp, #76]	; 0x4c
    d322:	str.w	r2, [r9]
    d326:	adds	r3, #1
    d328:	add	r4, r1
    d32a:	cmp	r3, #7
    d32c:	str	r4, [sp, #148]	; 0x94
    d32e:	str.w	r1, [r9, #4]
    d332:	str	r3, [sp, #144]	; 0x90
    d334:	bgt.w	dbc6 <_svfprintf_r+0x1276>
    d338:	add.w	r9, r9, #8
    d33c:	ldr	r3, [sp, #56]	; 0x38
    d33e:	subs	r5, r3, #1
    d340:	cmp	r5, #0
    d342:	ble.w	ce7c <_svfprintf_r+0x52c>
    d346:	ldr	r2, [pc, #32]	; (d368 <_svfprintf_r+0xa18>)
    d348:	ldr	r3, [sp, #144]	; 0x90
    d34a:	str	r2, [sp, #44]	; 0x2c
    d34c:	cmp	r5, #16
    d34e:	ble.w	d724 <_svfprintf_r+0xdd4>
    d352:	movs	r6, #16
    d354:	ldr	r7, [sp, #24]
    d356:	ldr.w	fp, [sp, #20]
    d35a:	b.n	d378 <_svfprintf_r+0xa28>
    d35c:	.word	0x00012978
    d360:	.word	0x0001298c
    d364:	.word	0x000129a8
    d368:	.word	0x00012958
    d36c:	add.w	r9, r9, #8
    d370:	subs	r5, #16
    d372:	cmp	r5, #16
    d374:	ble.w	d724 <_svfprintf_r+0xdd4>
    d378:	adds	r3, #1
    d37a:	adds	r4, #16
    d37c:	cmp	r3, #7
    d37e:	str	r4, [sp, #148]	; 0x94
    d380:	str	r3, [sp, #144]	; 0x90
    d382:	str.w	sl, [r9]
    d386:	str.w	r6, [r9, #4]
    d38a:	ble.n	d36c <_svfprintf_r+0xa1c>
    d38c:	add	r2, sp, #140	; 0x8c
    d38e:	mov	r1, fp
    d390:	mov	r0, r7
    d392:	bl	118e8 <__ssprint_r>
    d396:	cmp	r0, #0
    d398:	bne.w	cb44 <_svfprintf_r+0x1f4>
    d39c:	ldr	r4, [sp, #148]	; 0x94
    d39e:	ldr	r3, [sp, #144]	; 0x90
    d3a0:	add.w	r9, sp, #192	; 0xc0
    d3a4:	b.n	d370 <_svfprintf_r+0xa20>
    d3a6:	ldr	r3, [sp, #32]
    d3a8:	ldr	r2, [sp, #16]
    d3aa:	subs	r7, r3, r2
    d3ac:	cmp	r7, #0
    d3ae:	ble.w	cde4 <_svfprintf_r+0x494>
    d3b2:	ldr	r2, [pc, #752]	; (d6a4 <_svfprintf_r+0xd54>)
    d3b4:	ldr	r3, [sp, #144]	; 0x90
    d3b6:	str	r2, [sp, #44]	; 0x2c
    d3b8:	cmp	r7, #16
    d3ba:	ble.n	d414 <_svfprintf_r+0xac4>
    d3bc:	mov	r2, r9
    d3be:	mov	r1, r4
    d3c0:	mov	r9, r7
    d3c2:	movs	r5, #16
    d3c4:	mov	r7, r6
    d3c6:	ldr	r4, [sp, #24]
    d3c8:	ldr	r6, [sp, #20]
    d3ca:	b.n	d3da <_svfprintf_r+0xa8a>
    d3cc:	sub.w	r9, r9, #16
    d3d0:	cmp.w	r9, #16
    d3d4:	add.w	r2, r2, #8
    d3d8:	ble.n	d40c <_svfprintf_r+0xabc>
    d3da:	adds	r3, #1
    d3dc:	adds	r1, #16
    d3de:	cmp	r3, #7
    d3e0:	str	r1, [sp, #148]	; 0x94
    d3e2:	str	r3, [sp, #144]	; 0x90
    d3e4:	str.w	sl, [r2]
    d3e8:	str	r5, [r2, #4]
    d3ea:	ble.n	d3cc <_svfprintf_r+0xa7c>
    d3ec:	add	r2, sp, #140	; 0x8c
    d3ee:	mov	r1, r6
    d3f0:	mov	r0, r4
    d3f2:	bl	118e8 <__ssprint_r>
    d3f6:	cmp	r0, #0
    d3f8:	bne.w	cb44 <_svfprintf_r+0x1f4>
    d3fc:	sub.w	r9, r9, #16
    d400:	cmp.w	r9, #16
    d404:	ldr	r1, [sp, #148]	; 0x94
    d406:	ldr	r3, [sp, #144]	; 0x90
    d408:	add	r2, sp, #192	; 0xc0
    d40a:	bgt.n	d3da <_svfprintf_r+0xa8a>
    d40c:	mov	r6, r7
    d40e:	mov	r4, r1
    d410:	mov	r7, r9
    d412:	mov	r9, r2
    d414:	adds	r3, #1
    d416:	ldr	r2, [sp, #44]	; 0x2c
    d418:	str	r3, [sp, #144]	; 0x90
    d41a:	add	r4, r7
    d41c:	cmp	r3, #7
    d41e:	str	r4, [sp, #148]	; 0x94
    d420:	stmia.w	r9, {r2, r7}
    d424:	bgt.w	d8a2 <_svfprintf_r+0xf52>
    d428:	add.w	r9, r9, #8
    d42c:	b.n	cde4 <_svfprintf_r+0x494>
    d42e:	ldr	r3, [sp, #56]	; 0x38
    d430:	ldr	r5, [sp, #144]	; 0x90
    d432:	cmp	r3, #1
    d434:	ble.w	d84c <_svfprintf_r+0xefc>
    d438:	adds	r5, #1
    d43a:	adds	r4, #1
    d43c:	movs	r3, #1
    d43e:	cmp	r5, #7
    d440:	str	r4, [sp, #148]	; 0x94
    d442:	str	r5, [sp, #144]	; 0x90
    d444:	str.w	r6, [r9]
    d448:	str.w	r3, [r9, #4]
    d44c:	bgt.w	d86e <_svfprintf_r+0xf1e>
    d450:	add.w	r9, r9, #8
    d454:	ldr	r2, [sp, #72]	; 0x48
    d456:	ldr	r3, [sp, #76]	; 0x4c
    d458:	str.w	r3, [r9]
    d45c:	adds	r5, #1
    d45e:	add	r4, r2
    d460:	cmp	r5, #7
    d462:	str	r4, [sp, #148]	; 0x94
    d464:	str	r5, [sp, #144]	; 0x90
    d466:	str.w	r2, [r9, #4]
    d46a:	bgt.w	d888 <_svfprintf_r+0xf38>
    d46e:	add.w	r9, r9, #8
    d472:	movs	r3, #0
    d474:	movs	r2, #0
    d476:	ldrd	r0, r1, [sp, #64]	; 0x40
    d47a:	bl	a540 <__aeabi_dcmpeq>
    d47e:	ldr	r3, [sp, #56]	; 0x38
    d480:	cmp	r0, #0
    d482:	bne.w	d60c <_svfprintf_r+0xcbc>
    d486:	subs	r3, #1
    d488:	adds	r5, #1
    d48a:	adds	r6, #1
    d48c:	add	r4, r3
    d48e:	cmp	r5, #7
    d490:	str	r5, [sp, #144]	; 0x90
    d492:	str	r4, [sp, #148]	; 0x94
    d494:	str.w	r6, [r9]
    d498:	str.w	r3, [r9, #4]
    d49c:	bgt.w	d68a <_svfprintf_r+0xd3a>
    d4a0:	add.w	r9, r9, #8
    d4a4:	ldr	r2, [sp, #84]	; 0x54
    d4a6:	str.w	r2, [r9, #4]
    d4aa:	adds	r5, #1
    d4ac:	add	r4, r2
    d4ae:	add	r3, sp, #124	; 0x7c
    d4b0:	cmp	r5, #7
    d4b2:	str	r4, [sp, #148]	; 0x94
    d4b4:	str	r5, [sp, #144]	; 0x90
    d4b6:	str.w	r3, [r9]
    d4ba:	ble.w	ce78 <_svfprintf_r+0x528>
    d4be:	add	r2, sp, #140	; 0x8c
    d4c0:	ldr	r1, [sp, #20]
    d4c2:	ldr	r0, [sp, #24]
    d4c4:	bl	118e8 <__ssprint_r>
    d4c8:	cmp	r0, #0
    d4ca:	bne.w	cb44 <_svfprintf_r+0x1f4>
    d4ce:	ldr	r4, [sp, #148]	; 0x94
    d4d0:	add.w	r9, sp, #192	; 0xc0
    d4d4:	b.n	ce7c <_svfprintf_r+0x52c>
    d4d6:	add	r2, sp, #140	; 0x8c
    d4d8:	ldr	r1, [sp, #20]
    d4da:	ldr	r0, [sp, #24]
    d4dc:	bl	118e8 <__ssprint_r>
    d4e0:	cmp	r0, #0
    d4e2:	beq.w	cf18 <_svfprintf_r+0x5c8>
    d4e6:	b.w	cb44 <_svfprintf_r+0x1f4>
    d4ea:	add	r2, sp, #140	; 0x8c
    d4ec:	ldr	r1, [sp, #20]
    d4ee:	ldr	r0, [sp, #24]
    d4f0:	bl	118e8 <__ssprint_r>
    d4f4:	cmp	r0, #0
    d4f6:	bne.w	cb44 <_svfprintf_r+0x1f4>
    d4fa:	ldr	r4, [sp, #148]	; 0x94
    d4fc:	add.w	r9, sp, #192	; 0xc0
    d500:	b.n	ce56 <_svfprintf_r+0x506>
    d502:	add	r2, sp, #140	; 0x8c
    d504:	ldr	r1, [sp, #20]
    d506:	ldr	r0, [sp, #24]
    d508:	bl	118e8 <__ssprint_r>
    d50c:	cmp	r0, #0
    d50e:	bne.w	cb44 <_svfprintf_r+0x1f4>
    d512:	ldr	r4, [sp, #148]	; 0x94
    d514:	add.w	r9, sp, #192	; 0xc0
    d518:	b.n	cdbc <_svfprintf_r+0x46c>
    d51a:	add	r2, sp, #140	; 0x8c
    d51c:	ldr	r1, [sp, #20]
    d51e:	ldr	r0, [sp, #24]
    d520:	bl	118e8 <__ssprint_r>
    d524:	cmp	r0, #0
    d526:	bne.w	cb44 <_svfprintf_r+0x1f4>
    d52a:	ldr	r4, [sp, #148]	; 0x94
    d52c:	add.w	r9, sp, #192	; 0xc0
    d530:	b.n	cddc <_svfprintf_r+0x48c>
    d532:	cmp.w	fp, #0
    d536:	strb.w	r7, [sp, #111]	; 0x6f
    d53a:	blt.w	dafc <_svfprintf_r+0x11ac>
    d53e:	bic.w	r3, r2, #128	; 0x80
    d542:	str	r3, [sp, #12]
    d544:	orrs.w	r3, r4, r5
    d548:	bne.w	d0f2 <_svfprintf_r+0x7a2>
    d54c:	cmp.w	fp, #0
    d550:	beq.w	d26c <_svfprintf_r+0x91c>
    d554:	movs	r7, #0
    d556:	b.n	d2c8 <_svfprintf_r+0x978>
    d558:	ldr	r5, [sp, #116]	; 0x74
    d55a:	cmp	r5, #0
    d55c:	ble.w	db02 <_svfprintf_r+0x11b2>
    d560:	ldr	r3, [sp, #60]	; 0x3c
    d562:	ldr	r2, [sp, #56]	; 0x38
    d564:	cmp	r3, r2
    d566:	it	ge
    d568:	movge	r3, r2
    d56a:	cmp	r3, #0
    d56c:	mov	r5, r3
    d56e:	ble.n	d58c <_svfprintf_r+0xc3c>
    d570:	ldr	r3, [sp, #144]	; 0x90
    d572:	str.w	r6, [r9]
    d576:	adds	r3, #1
    d578:	add	r4, r5
    d57a:	cmp	r3, #7
    d57c:	str	r4, [sp, #148]	; 0x94
    d57e:	str.w	r5, [r9, #4]
    d582:	str	r3, [sp, #144]	; 0x90
    d584:	bgt.w	dcda <_svfprintf_r+0x138a>
    d588:	add.w	r9, r9, #8
    d58c:	ldr	r3, [sp, #60]	; 0x3c
    d58e:	cmp	r5, #0
    d590:	it	ge
    d592:	subge	r3, r3, r5
    d594:	cmp	r3, #0
    d596:	mov	r5, r3
    d598:	ble.w	d78c <_svfprintf_r+0xe3c>
    d59c:	ldr	r2, [pc, #260]	; (d6a4 <_svfprintf_r+0xd54>)
    d59e:	ldr	r3, [sp, #144]	; 0x90
    d5a0:	str	r2, [sp, #44]	; 0x2c
    d5a2:	cmp	r5, #16
    d5a4:	ble.w	daae <_svfprintf_r+0x115e>
    d5a8:	mov	r2, r4
    d5aa:	movs	r7, #16
    d5ac:	ldr.w	fp, [sp, #24]
    d5b0:	ldr	r4, [sp, #20]
    d5b2:	b.n	d5c0 <_svfprintf_r+0xc70>
    d5b4:	add.w	r9, r9, #8
    d5b8:	subs	r5, #16
    d5ba:	cmp	r5, #16
    d5bc:	ble.w	daac <_svfprintf_r+0x115c>
    d5c0:	adds	r3, #1
    d5c2:	adds	r2, #16
    d5c4:	cmp	r3, #7
    d5c6:	str	r2, [sp, #148]	; 0x94
    d5c8:	str	r3, [sp, #144]	; 0x90
    d5ca:	str.w	sl, [r9]
    d5ce:	str.w	r7, [r9, #4]
    d5d2:	ble.n	d5b4 <_svfprintf_r+0xc64>
    d5d4:	add	r2, sp, #140	; 0x8c
    d5d6:	mov	r1, r4
    d5d8:	mov	r0, fp
    d5da:	bl	118e8 <__ssprint_r>
    d5de:	cmp	r0, #0
    d5e0:	bne.w	cb44 <_svfprintf_r+0x1f4>
    d5e4:	ldr	r2, [sp, #148]	; 0x94
    d5e6:	ldr	r3, [sp, #144]	; 0x90
    d5e8:	add.w	r9, sp, #192	; 0xc0
    d5ec:	b.n	d5b8 <_svfprintf_r+0xc68>
    d5ee:	add	r2, sp, #140	; 0x8c
    d5f0:	ldr	r1, [sp, #20]
    d5f2:	ldr	r0, [sp, #24]
    d5f4:	bl	118e8 <__ssprint_r>
    d5f8:	cmp	r0, #0
    d5fa:	bne.w	cb44 <_svfprintf_r+0x1f4>
    d5fe:	ldrb.w	r7, [sp, #111]	; 0x6f
    d602:	ldr	r4, [sp, #148]	; 0x94
    d604:	add.w	r9, sp, #192	; 0xc0
    d608:	b.w	cd9c <_svfprintf_r+0x44c>
    d60c:	subs	r6, r3, #1
    d60e:	cmp	r6, #0
    d610:	ble.w	d4a4 <_svfprintf_r+0xb54>
    d614:	ldr	r3, [pc, #140]	; (d6a4 <_svfprintf_r+0xd54>)
    d616:	str	r3, [sp, #44]	; 0x2c
    d618:	cmp	r6, #16
    d61a:	ble.n	d676 <_svfprintf_r+0xd26>
    d61c:	str.w	r8, [sp, #36]	; 0x24
    d620:	movs	r7, #16
    d622:	mov	r8, r6
    d624:	ldr.w	fp, [sp, #24]
    d628:	ldr	r6, [sp, #20]
    d62a:	b.n	d63a <_svfprintf_r+0xcea>
    d62c:	sub.w	r8, r8, #16
    d630:	cmp.w	r8, #16
    d634:	add.w	r9, r9, #8
    d638:	ble.n	d670 <_svfprintf_r+0xd20>
    d63a:	adds	r5, #1
    d63c:	adds	r4, #16
    d63e:	cmp	r5, #7
    d640:	str	r4, [sp, #148]	; 0x94
    d642:	str	r5, [sp, #144]	; 0x90
    d644:	str.w	sl, [r9]
    d648:	str.w	r7, [r9, #4]
    d64c:	ble.n	d62c <_svfprintf_r+0xcdc>
    d64e:	add	r2, sp, #140	; 0x8c
    d650:	mov	r1, r6
    d652:	mov	r0, fp
    d654:	bl	118e8 <__ssprint_r>
    d658:	cmp	r0, #0
    d65a:	bne.w	cb44 <_svfprintf_r+0x1f4>
    d65e:	sub.w	r8, r8, #16
    d662:	cmp.w	r8, #16
    d666:	ldr	r4, [sp, #148]	; 0x94
    d668:	ldr	r5, [sp, #144]	; 0x90
    d66a:	add.w	r9, sp, #192	; 0xc0
    d66e:	bgt.n	d63a <_svfprintf_r+0xcea>
    d670:	mov	r6, r8
    d672:	ldr.w	r8, [sp, #36]	; 0x24
    d676:	ldr	r3, [sp, #44]	; 0x2c
    d678:	adds	r5, #1
    d67a:	add	r4, r6
    d67c:	cmp	r5, #7
    d67e:	str	r4, [sp, #148]	; 0x94
    d680:	str	r5, [sp, #144]	; 0x90
    d682:	stmia.w	r9, {r3, r6}
    d686:	ble.w	d4a0 <_svfprintf_r+0xb50>
    d68a:	add	r2, sp, #140	; 0x8c
    d68c:	ldr	r1, [sp, #20]
    d68e:	ldr	r0, [sp, #24]
    d690:	bl	118e8 <__ssprint_r>
    d694:	cmp	r0, #0
    d696:	bne.w	cb44 <_svfprintf_r+0x1f4>
    d69a:	ldr	r4, [sp, #148]	; 0x94
    d69c:	ldr	r5, [sp, #144]	; 0x90
    d69e:	add.w	r9, sp, #192	; 0xc0
    d6a2:	b.n	d4a4 <_svfprintf_r+0xb54>
    d6a4:	.word	0x00012958
    d6a8:	ldr	r1, [sp, #12]
    d6aa:	ands.w	r2, r1, #16
    d6ae:	beq.w	da58 <_svfprintf_r+0x1108>
    d6b2:	ldr	r0, [sp, #40]	; 0x28
    d6b4:	strb.w	r3, [sp, #111]	; 0x6f
    d6b8:	cmp.w	fp, #0
    d6bc:	ldr	r4, [r0, #0]
    d6be:	add.w	r7, r0, #4
    d6c2:	mov.w	r5, #0
    d6c6:	blt.n	d716 <_svfprintf_r+0xdc6>
    d6c8:	mov	r2, r1
    d6ca:	bic.w	r2, r2, #128	; 0x80
    d6ce:	str	r2, [sp, #12]
    d6d0:	orrs.w	r2, r4, r5
    d6d4:	str	r7, [sp, #40]	; 0x28
    d6d6:	mov	r7, r3
    d6d8:	bne.w	ccac <_svfprintf_r+0x35c>
    d6dc:	b.n	d07c <_svfprintf_r+0x72c>
    d6de:	ldr	r3, [sp, #12]
    d6e0:	lsls	r0, r3, #27
    d6e2:	bmi.n	d73a <_svfprintf_r+0xdea>
    d6e4:	ldr	r3, [sp, #12]
    d6e6:	lsls	r1, r3, #25
    d6e8:	bpl.n	d73a <_svfprintf_r+0xdea>
    d6ea:	ldr	r1, [sp, #40]	; 0x28
    d6ec:	ldrsh.w	r4, [r1]
    d6f0:	adds	r1, #4
    d6f2:	asrs	r5, r4, #31
    d6f4:	mov	r2, r4
    d6f6:	mov	r3, r5
    d6f8:	str	r1, [sp, #40]	; 0x28
    d6fa:	b.w	cc86 <_svfprintf_r+0x336>
    d6fe:	ldr	r1, [sp, #40]	; 0x28
    d700:	strb.w	r3, [sp, #111]	; 0x6f
    d704:	cmp.w	fp, #0
    d708:	ldr	r4, [r1, #0]
    d70a:	add.w	r7, r1, #4
    d70e:	mov.w	r5, #0
    d712:	bge.w	dbae <_svfprintf_r+0x125e>
    d716:	str	r7, [sp, #40]	; 0x28
    d718:	mov	r7, r3
    d71a:	orrs.w	r3, r4, r5
    d71e:	bne.w	ccac <_svfprintf_r+0x35c>
    d722:	b.n	d086 <_svfprintf_r+0x736>
    d724:	adds	r3, #1
    d726:	ldr	r2, [sp, #44]	; 0x2c
    d728:	str	r3, [sp, #144]	; 0x90
    d72a:	add	r4, r5
    d72c:	cmp	r3, #7
    d72e:	str	r4, [sp, #148]	; 0x94
    d730:	stmia.w	r9, {r2, r5}
    d734:	ble.w	ce78 <_svfprintf_r+0x528>
    d738:	b.n	d4be <_svfprintf_r+0xb6e>
    d73a:	ldr	r2, [sp, #40]	; 0x28
    d73c:	ldr	r4, [r2, #0]
    d73e:	mov	r3, r2
    d740:	adds	r3, #4
    d742:	asrs	r5, r4, #31
    d744:	mov	r2, r4
    d746:	str	r3, [sp, #40]	; 0x28
    d748:	cmp	r2, #0
    d74a:	mov	r3, r5
    d74c:	sbcs.w	r3, r3, #0
    d750:	bge.w	cc90 <_svfprintf_r+0x340>
    d754:	negs	r4, r4
    d756:	mov.w	r7, #45	; 0x2d
    d75a:	sbc.w	r5, r5, r5, lsl #1
    d75e:	cmp.w	fp, #0
    d762:	strb.w	r7, [sp, #111]	; 0x6f
    d766:	blt.w	ccac <_svfprintf_r+0x35c>
    d76a:	ldr	r3, [sp, #12]
    d76c:	bic.w	r3, r3, #128	; 0x80
    d770:	str	r3, [sp, #12]
    d772:	b.w	ccac <_svfprintf_r+0x35c>
    d776:	add	r2, sp, #140	; 0x8c
    d778:	ldr	r1, [sp, #20]
    d77a:	ldr	r0, [sp, #24]
    d77c:	bl	118e8 <__ssprint_r>
    d780:	cmp	r0, #0
    d782:	bne.w	cb44 <_svfprintf_r+0x1f4>
    d786:	ldr	r4, [sp, #148]	; 0x94
    d788:	add.w	r9, sp, #192	; 0xc0
    d78c:	ldr	r2, [sp, #60]	; 0x3c
    d78e:	ldr	r3, [sp, #116]	; 0x74
    d790:	add	r2, r6
    d792:	mov	r7, r2
    d794:	ldr	r2, [sp, #56]	; 0x38
    d796:	cmp	r3, r2
    d798:	blt.n	d82a <_svfprintf_r+0xeda>
    d79a:	ldr	r2, [sp, #12]
    d79c:	lsls	r5, r2, #31
    d79e:	bmi.n	d82a <_svfprintf_r+0xeda>
    d7a0:	ldr	r1, [sp, #56]	; 0x38
    d7a2:	add	r6, r1
    d7a4:	subs	r5, r6, r7
    d7a6:	subs	r3, r1, r3
    d7a8:	cmp	r5, r3
    d7aa:	it	ge
    d7ac:	movge	r5, r3
    d7ae:	cmp	r5, #0
    d7b0:	mov	r6, r5
    d7b2:	ble.n	d7d0 <_svfprintf_r+0xe80>
    d7b4:	ldr	r2, [sp, #144]	; 0x90
    d7b6:	str.w	r7, [r9]
    d7ba:	adds	r2, #1
    d7bc:	add	r4, r5
    d7be:	cmp	r2, #7
    d7c0:	str	r4, [sp, #148]	; 0x94
    d7c2:	str.w	r5, [r9, #4]
    d7c6:	str	r2, [sp, #144]	; 0x90
    d7c8:	bgt.w	ddc8 <_svfprintf_r+0x1478>
    d7cc:	add.w	r9, r9, #8
    d7d0:	cmp	r6, #0
    d7d2:	ite	ge
    d7d4:	subge	r5, r3, r6
    d7d6:	movlt	r5, r3
    d7d8:	cmp	r5, #0
    d7da:	ble.w	ce7c <_svfprintf_r+0x52c>
    d7de:	ldr	r2, [pc, #744]	; (dac8 <_svfprintf_r+0x1178>)
    d7e0:	ldr	r3, [sp, #144]	; 0x90
    d7e2:	str	r2, [sp, #44]	; 0x2c
    d7e4:	cmp	r5, #16
    d7e6:	ble.n	d724 <_svfprintf_r+0xdd4>
    d7e8:	movs	r6, #16
    d7ea:	ldr	r7, [sp, #24]
    d7ec:	ldr.w	fp, [sp, #20]
    d7f0:	b.n	d7fc <_svfprintf_r+0xeac>
    d7f2:	add.w	r9, r9, #8
    d7f6:	subs	r5, #16
    d7f8:	cmp	r5, #16
    d7fa:	ble.n	d724 <_svfprintf_r+0xdd4>
    d7fc:	adds	r3, #1
    d7fe:	adds	r4, #16
    d800:	cmp	r3, #7
    d802:	str	r4, [sp, #148]	; 0x94
    d804:	str	r3, [sp, #144]	; 0x90
    d806:	str.w	sl, [r9]
    d80a:	str.w	r6, [r9, #4]
    d80e:	ble.n	d7f2 <_svfprintf_r+0xea2>
    d810:	add	r2, sp, #140	; 0x8c
    d812:	mov	r1, fp
    d814:	mov	r0, r7
    d816:	bl	118e8 <__ssprint_r>
    d81a:	cmp	r0, #0
    d81c:	bne.w	cb44 <_svfprintf_r+0x1f4>
    d820:	ldr	r4, [sp, #148]	; 0x94
    d822:	ldr	r3, [sp, #144]	; 0x90
    d824:	add.w	r9, sp, #192	; 0xc0
    d828:	b.n	d7f6 <_svfprintf_r+0xea6>
    d82a:	ldr	r2, [sp, #144]	; 0x90
    d82c:	ldr	r0, [sp, #72]	; 0x48
    d82e:	ldr	r1, [sp, #76]	; 0x4c
    d830:	str.w	r1, [r9]
    d834:	adds	r2, #1
    d836:	add	r4, r0
    d838:	cmp	r2, #7
    d83a:	str	r4, [sp, #148]	; 0x94
    d83c:	str.w	r0, [r9, #4]
    d840:	str	r2, [sp, #144]	; 0x90
    d842:	bgt.w	ddae <_svfprintf_r+0x145e>
    d846:	add.w	r9, r9, #8
    d84a:	b.n	d7a0 <_svfprintf_r+0xe50>
    d84c:	ldr	r3, [sp, #12]
    d84e:	lsls	r0, r3, #31
    d850:	bmi.w	d438 <_svfprintf_r+0xae8>
    d854:	adds	r5, #1
    d856:	adds	r4, #1
    d858:	movs	r3, #1
    d85a:	cmp	r5, #7
    d85c:	str	r4, [sp, #148]	; 0x94
    d85e:	str	r5, [sp, #144]	; 0x90
    d860:	str.w	r6, [r9]
    d864:	str.w	r3, [r9, #4]
    d868:	ble.w	d4a0 <_svfprintf_r+0xb50>
    d86c:	b.n	d68a <_svfprintf_r+0xd3a>
    d86e:	add	r2, sp, #140	; 0x8c
    d870:	ldr	r1, [sp, #20]
    d872:	ldr	r0, [sp, #24]
    d874:	bl	118e8 <__ssprint_r>
    d878:	cmp	r0, #0
    d87a:	bne.w	cb44 <_svfprintf_r+0x1f4>
    d87e:	ldr	r4, [sp, #148]	; 0x94
    d880:	ldr	r5, [sp, #144]	; 0x90
    d882:	add.w	r9, sp, #192	; 0xc0
    d886:	b.n	d454 <_svfprintf_r+0xb04>
    d888:	add	r2, sp, #140	; 0x8c
    d88a:	ldr	r1, [sp, #20]
    d88c:	ldr	r0, [sp, #24]
    d88e:	bl	118e8 <__ssprint_r>
    d892:	cmp	r0, #0
    d894:	bne.w	cb44 <_svfprintf_r+0x1f4>
    d898:	ldr	r4, [sp, #148]	; 0x94
    d89a:	ldr	r5, [sp, #144]	; 0x90
    d89c:	add.w	r9, sp, #192	; 0xc0
    d8a0:	b.n	d472 <_svfprintf_r+0xb22>
    d8a2:	add	r2, sp, #140	; 0x8c
    d8a4:	ldr	r1, [sp, #20]
    d8a6:	ldr	r0, [sp, #24]
    d8a8:	bl	118e8 <__ssprint_r>
    d8ac:	cmp	r0, #0
    d8ae:	bne.w	cb44 <_svfprintf_r+0x1f4>
    d8b2:	ldr	r4, [sp, #148]	; 0x94
    d8b4:	add.w	r9, sp, #192	; 0xc0
    d8b8:	b.w	cde4 <_svfprintf_r+0x494>
    d8bc:	ldr	r1, [sp, #12]
    d8be:	ands.w	r3, r1, #64	; 0x40
    d8c2:	beq.w	da38 <_svfprintf_r+0x10e8>
    d8c6:	ldr	r0, [sp, #40]	; 0x28
    d8c8:	strb.w	r2, [sp, #111]	; 0x6f
    d8cc:	mov	r3, r0
    d8ce:	cmp.w	fp, #0
    d8d2:	add.w	r3, r3, #4
    d8d6:	ldrh	r4, [r0, #0]
    d8d8:	mov.w	r5, #0
    d8dc:	blt.w	dc60 <_svfprintf_r+0x1310>
    d8e0:	bic.w	r1, r1, #128	; 0x80
    d8e4:	str	r1, [sp, #12]
    d8e6:	orrs.w	r1, r4, r5
    d8ea:	str	r3, [sp, #40]	; 0x28
    d8ec:	beq.w	d2a4 <_svfprintf_r+0x954>
    d8f0:	mov	r7, r2
    d8f2:	b.w	cb9c <_svfprintf_r+0x24c>
    d8f6:	ldr	r3, [sp, #12]
    d8f8:	lsls	r7, r3, #27
    d8fa:	bmi.n	d914 <_svfprintf_r+0xfc4>
    d8fc:	ldr	r3, [sp, #12]
    d8fe:	lsls	r6, r3, #25
    d900:	bpl.n	d914 <_svfprintf_r+0xfc4>
    d902:	ldr	r2, [sp, #40]	; 0x28
    d904:	ldr	r3, [r2, #0]
    d906:	adds	r2, #4
    d908:	str	r2, [sp, #40]	; 0x28
    d90a:	ldrh.w	r2, [sp, #28]
    d90e:	strh	r2, [r3, #0]
    d910:	b.w	c99e <_svfprintf_r+0x4e>
    d914:	ldr	r2, [sp, #40]	; 0x28
    d916:	ldr	r3, [r2, #0]
    d918:	adds	r2, #4
    d91a:	str	r2, [sp, #40]	; 0x28
    d91c:	ldr	r2, [sp, #28]
    d91e:	str	r2, [r3, #0]
    d920:	b.w	c99e <_svfprintf_r+0x4e>
    d924:	ldrd	r0, r1, [sp, #64]	; 0x40
    d928:	mov	r2, r0
    d92a:	mov	r3, r1
    d92c:	bl	a5a4 <__aeabi_dcmpun>
    d930:	cmp	r0, #0
    d932:	bne.w	df30 <_svfprintf_r+0x15e0>
    d936:	ldr	r3, [sp, #52]	; 0x34
    d938:	cmp.w	fp, #4294967295
    d93c:	bic.w	r7, r3, #32
    d940:	beq.w	de12 <_svfprintf_r+0x14c2>
    d944:	cmp	r7, #71	; 0x47
    d946:	beq.w	dc4e <_svfprintf_r+0x12fe>
    d94a:	ldr	r3, [sp, #68]	; 0x44
    d94c:	ldr	r2, [sp, #12]
    d94e:	cmp	r3, #0
    d950:	orr.w	r2, r2, #256	; 0x100
    d954:	str	r2, [sp, #44]	; 0x2c
    d956:	blt.w	de4a <_svfprintf_r+0x14fa>
    d95a:	vldr	d7, [sp, #64]	; 0x40
    d95e:	vstr	d7, [sp, #96]	; 0x60
    d962:	movs	r3, #0
    d964:	str	r3, [sp, #16]
    d966:	ldr	r3, [sp, #52]	; 0x34
    d968:	cmp	r3, #102	; 0x66
    d96a:	beq.w	de18 <_svfprintf_r+0x14c8>
    d96e:	cmp	r3, #70	; 0x46
    d970:	beq.w	dbfe <_svfprintf_r+0x12ae>
    d974:	cmp	r7, #69	; 0x45
    d976:	ite	eq
    d978:	addeq.w	r5, fp, #1
    d97c:	movne	r5, fp
    d97e:	add	r2, sp, #132	; 0x84
    d980:	add	r3, sp, #120	; 0x78
    d982:	str	r2, [sp, #4]
    d984:	str	r3, [sp, #0]
    d986:	mov	r2, r5
    d988:	add	r3, sp, #116	; 0x74
    d98a:	movs	r1, #2
    d98c:	vldr	d0, [sp, #96]	; 0x60
    d990:	ldr	r0, [sp, #24]
    d992:	bl	f158 <_dtoa_r>
    d996:	ldr	r3, [sp, #52]	; 0x34
    d998:	cmp	r3, #103	; 0x67
    d99a:	mov	r6, r0
    d99c:	bne.w	de76 <_svfprintf_r+0x1526>
    d9a0:	ldr	r3, [sp, #12]
    d9a2:	lsls	r2, r3, #31
    d9a4:	bpl.w	df1a <_svfprintf_r+0x15ca>
    d9a8:	adds	r4, r6, r5
    d9aa:	movs	r2, #0
    d9ac:	movs	r3, #0
    d9ae:	ldrd	r0, r1, [sp, #96]	; 0x60
    d9b2:	bl	a540 <__aeabi_dcmpeq>
    d9b6:	cmp	r0, #0
    d9b8:	bne.w	dcd6 <_svfprintf_r+0x1386>
    d9bc:	ldr	r3, [sp, #132]	; 0x84
    d9be:	cmp	r4, r3
    d9c0:	bls.n	d9d0 <_svfprintf_r+0x1080>
    d9c2:	movs	r1, #48	; 0x30
    d9c4:	adds	r2, r3, #1
    d9c6:	str	r2, [sp, #132]	; 0x84
    d9c8:	strb	r1, [r3, #0]
    d9ca:	ldr	r3, [sp, #132]	; 0x84
    d9cc:	cmp	r4, r3
    d9ce:	bhi.n	d9c4 <_svfprintf_r+0x1074>
    d9d0:	subs	r3, r3, r6
    d9d2:	cmp	r7, #71	; 0x47
    d9d4:	str	r3, [sp, #56]	; 0x38
    d9d6:	beq.w	dcc8 <_svfprintf_r+0x1378>
    d9da:	ldr	r3, [sp, #52]	; 0x34
    d9dc:	cmp	r3, #101	; 0x65
    d9de:	ble.w	de94 <_svfprintf_r+0x1544>
    d9e2:	ldr	r3, [sp, #52]	; 0x34
    d9e4:	cmp	r3, #102	; 0x66
    d9e6:	ldr	r3, [sp, #116]	; 0x74
    d9e8:	str	r3, [sp, #60]	; 0x3c
    d9ea:	beq.w	deae <_svfprintf_r+0x155e>
    d9ee:	ldr	r2, [sp, #60]	; 0x3c
    d9f0:	ldr	r1, [sp, #56]	; 0x38
    d9f2:	cmp	r2, r1
    d9f4:	blt.w	de5c <_svfprintf_r+0x150c>
    d9f8:	ldr	r3, [sp, #12]
    d9fa:	lsls	r1, r3, #31
    d9fc:	bmi.w	df1e <_svfprintf_r+0x15ce>
    da00:	bic.w	r3, r2, r2, asr #31
    da04:	str	r2, [sp, #36]	; 0x24
    da06:	movs	r2, #103	; 0x67
    da08:	str	r2, [sp, #52]	; 0x34
    da0a:	ldr	r2, [sp, #16]
    da0c:	cmp	r2, #0
    da0e:	bne.w	dc70 <_svfprintf_r+0x1320>
    da12:	str	r3, [sp, #16]
    da14:	ldr	r3, [sp, #44]	; 0x2c
    da16:	str	r3, [sp, #12]
    da18:	mov	fp, r2
    da1a:	ldrb.w	r7, [sp, #111]	; 0x6f
    da1e:	b.w	ccf4 <_svfprintf_r+0x3a4>
    da22:	bic.w	r7, r7, #7
    da26:	vldr	d7, [r7]
    da2a:	add.w	r3, r7, #8
    da2e:	vstr	d7, [sp, #64]	; 0x40
    da32:	str	r3, [sp, #40]	; 0x28
    da34:	b.w	cf4c <_svfprintf_r+0x5fc>
    da38:	ldr	r1, [sp, #40]	; 0x28
    da3a:	strb.w	r3, [sp, #111]	; 0x6f
    da3e:	cmp.w	fp, #0
    da42:	ldr	r4, [r1, #0]
    da44:	add.w	r7, r1, #4
    da48:	mov.w	r5, #0
    da4c:	bge.w	dba8 <_svfprintf_r+0x1258>
    da50:	str	r7, [sp, #40]	; 0x28
    da52:	movs	r7, #0
    da54:	b.w	cb9c <_svfprintf_r+0x24c>
    da58:	ldr	r1, [sp, #12]
    da5a:	ands.w	r3, r1, #64	; 0x40
    da5e:	beq.w	d6fe <_svfprintf_r+0xdae>
    da62:	ldr	r0, [sp, #40]	; 0x28
    da64:	strb.w	r2, [sp, #111]	; 0x6f
    da68:	mov	r3, r0
    da6a:	cmp.w	fp, #0
    da6e:	add.w	r3, r3, #4
    da72:	ldrh	r4, [r0, #0]
    da74:	mov.w	r5, #0
    da78:	blt.w	dc5a <_svfprintf_r+0x130a>
    da7c:	bic.w	r1, r1, #128	; 0x80
    da80:	str	r1, [sp, #12]
    da82:	orrs.w	r1, r4, r5
    da86:	str	r3, [sp, #40]	; 0x28
    da88:	mov	r7, r2
    da8a:	bne.w	ccac <_svfprintf_r+0x35c>
    da8e:	b.w	d07c <_svfprintf_r+0x72c>
    da92:	ldr	r3, [sp, #12]
    da94:	ldr	r2, [sp, #40]	; 0x28
    da96:	tst.w	r3, #64	; 0x40
    da9a:	mov	r3, r2
    da9c:	beq.w	dc64 <_svfprintf_r+0x1314>
    daa0:	adds	r3, #4
    daa2:	ldrh	r4, [r2, #0]
    daa4:	str	r3, [sp, #40]	; 0x28
    daa6:	movs	r5, #0
    daa8:	b.w	d0b6 <_svfprintf_r+0x766>
    daac:	mov	r4, r2
    daae:	adds	r3, #1
    dab0:	ldr	r2, [sp, #44]	; 0x2c
    dab2:	str	r3, [sp, #144]	; 0x90
    dab4:	add	r4, r5
    dab6:	cmp	r3, #7
    dab8:	str	r4, [sp, #148]	; 0x94
    daba:	stmia.w	r9, {r2, r5}
    dabe:	bgt.w	d776 <_svfprintf_r+0xe26>
    dac2:	add.w	r9, r9, #8
    dac6:	b.n	d78c <_svfprintf_r+0xe3c>
    dac8:	.word	0x00012958
    dacc:	movs	r7, #0
    dace:	cmp	fp, r7
    dad0:	strb.w	r7, [sp, #111]	; 0x6f
    dad4:	blt.w	d2c8 <_svfprintf_r+0x978>
    dad8:	ldr	r3, [sp, #12]
    dada:	bic.w	r3, r3, #128	; 0x80
    dade:	str	r3, [sp, #12]
    dae0:	b.w	d264 <_svfprintf_r+0x914>
    dae4:	add	r2, sp, #140	; 0x8c
    dae6:	ldr	r1, [sp, #20]
    dae8:	ldr	r0, [sp, #24]
    daea:	bl	118e8 <__ssprint_r>
    daee:	cmp	r0, #0
    daf0:	bne.w	cb44 <_svfprintf_r+0x1f4>
    daf4:	ldr	r4, [sp, #148]	; 0x94
    daf6:	add.w	r9, sp, #192	; 0xc0
    dafa:	b.n	d30c <_svfprintf_r+0x9bc>
    dafc:	ldr	r7, [sp, #40]	; 0x28
    dafe:	b.w	d2ba <_svfprintf_r+0x96a>
    db02:	ldr	r3, [sp, #144]	; 0x90
    db04:	ldr	r2, [pc, #736]	; (dde8 <_svfprintf_r+0x1498>)
    db06:	str.w	r2, [r9]
    db0a:	adds	r3, #1
    db0c:	adds	r4, #1
    db0e:	movs	r2, #1
    db10:	cmp	r3, #7
    db12:	str	r4, [sp, #148]	; 0x94
    db14:	str	r3, [sp, #144]	; 0x90
    db16:	str.w	r2, [r9, #4]
    db1a:	bgt.w	dc34 <_svfprintf_r+0x12e4>
    db1e:	add.w	r9, r9, #8
    db22:	cbnz	r5, db30 <_svfprintf_r+0x11e0>
    db24:	ldr	r3, [sp, #56]	; 0x38
    db26:	cbnz	r3, db30 <_svfprintf_r+0x11e0>
    db28:	ldr	r3, [sp, #12]
    db2a:	lsls	r7, r3, #31
    db2c:	bpl.w	ce7c <_svfprintf_r+0x52c>
    db30:	ldr	r3, [sp, #144]	; 0x90
    db32:	ldr	r1, [sp, #72]	; 0x48
    db34:	ldr	r2, [sp, #76]	; 0x4c
    db36:	str.w	r2, [r9]
    db3a:	adds	r3, #1
    db3c:	add	r4, r1
    db3e:	cmp	r3, #7
    db40:	str	r4, [sp, #148]	; 0x94
    db42:	str.w	r1, [r9, #4]
    db46:	str	r3, [sp, #144]	; 0x90
    db48:	bgt.w	dee6 <_svfprintf_r+0x1596>
    db4c:	add.w	r9, r9, #8
    db50:	negs	r5, r5
    db52:	cmp	r5, #0
    db54:	ble.w	dcac <_svfprintf_r+0x135c>
    db58:	ldr	r2, [pc, #656]	; (ddec <_svfprintf_r+0x149c>)
    db5a:	str	r2, [sp, #44]	; 0x2c
    db5c:	cmp	r5, #16
    db5e:	ble.w	dcf4 <_svfprintf_r+0x13a4>
    db62:	mov	r2, r4
    db64:	movs	r7, #16
    db66:	ldr.w	fp, [sp, #24]
    db6a:	ldr	r4, [sp, #20]
    db6c:	b.n	db7a <_svfprintf_r+0x122a>
    db6e:	add.w	r9, r9, #8
    db72:	subs	r5, #16
    db74:	cmp	r5, #16
    db76:	ble.w	dcf2 <_svfprintf_r+0x13a2>
    db7a:	adds	r3, #1
    db7c:	adds	r2, #16
    db7e:	cmp	r3, #7
    db80:	str	r2, [sp, #148]	; 0x94
    db82:	str	r3, [sp, #144]	; 0x90
    db84:	str.w	sl, [r9]
    db88:	str.w	r7, [r9, #4]
    db8c:	ble.n	db6e <_svfprintf_r+0x121e>
    db8e:	add	r2, sp, #140	; 0x8c
    db90:	mov	r1, r4
    db92:	mov	r0, fp
    db94:	bl	118e8 <__ssprint_r>
    db98:	cmp	r0, #0
    db9a:	bne.w	cb44 <_svfprintf_r+0x1f4>
    db9e:	ldr	r2, [sp, #148]	; 0x94
    dba0:	ldr	r3, [sp, #144]	; 0x90
    dba2:	add.w	r9, sp, #192	; 0xc0
    dba6:	b.n	db72 <_svfprintf_r+0x1222>
    dba8:	ldr	r2, [sp, #12]
    dbaa:	b.w	d020 <_svfprintf_r+0x6d0>
    dbae:	ldr	r2, [sp, #12]
    dbb0:	b.n	d6ca <_svfprintf_r+0xd7a>
    dbb2:	ldr	r3, [sp, #12]
    dbb4:	orr.w	r3, r3, #32
    dbb8:	str	r3, [sp, #12]
    dbba:	add.w	r8, r8, #1
    dbbe:	ldrb.w	r3, [r8]
    dbc2:	b.w	ca04 <_svfprintf_r+0xb4>
    dbc6:	add	r2, sp, #140	; 0x8c
    dbc8:	ldr	r1, [sp, #20]
    dbca:	ldr	r0, [sp, #24]
    dbcc:	bl	118e8 <__ssprint_r>
    dbd0:	cmp	r0, #0
    dbd2:	bne.w	cb44 <_svfprintf_r+0x1f4>
    dbd6:	ldr	r4, [sp, #148]	; 0x94
    dbd8:	add.w	r9, sp, #192	; 0xc0
    dbdc:	b.w	d33c <_svfprintf_r+0x9ec>
    dbe0:	movs	r1, #64	; 0x40
    dbe2:	ldr	r0, [sp, #24]
    dbe4:	bl	aaf0 <_malloc_r>
    dbe8:	ldr	r2, [sp, #20]
    dbea:	str	r0, [r2, #0]
    dbec:	str	r0, [r2, #16]
    dbee:	cmp	r0, #0
    dbf0:	beq.w	dfda <_svfprintf_r+0x168a>
    dbf4:	ldr	r2, [sp, #20]
    dbf6:	movs	r3, #64	; 0x40
    dbf8:	str	r3, [r2, #20]
    dbfa:	b.w	c97e <_svfprintf_r+0x2e>
    dbfe:	add	r2, sp, #132	; 0x84
    dc00:	add	r3, sp, #120	; 0x78
    dc02:	str	r2, [sp, #4]
    dc04:	str	r3, [sp, #0]
    dc06:	mov	r2, fp
    dc08:	add	r3, sp, #116	; 0x74
    dc0a:	movs	r1, #3
    dc0c:	vldr	d0, [sp, #96]	; 0x60
    dc10:	ldr	r0, [sp, #24]
    dc12:	bl	f158 <_dtoa_r>
    dc16:	mov	r5, fp
    dc18:	mov	r6, r0
    dc1a:	ldr	r3, [sp, #52]	; 0x34
    dc1c:	cmp	r3, #70	; 0x46
    dc1e:	add.w	r4, r6, r5
    dc22:	bne.w	d9aa <_svfprintf_r+0x105a>
    dc26:	ldrb	r3, [r6, #0]
    dc28:	cmp	r3, #48	; 0x30
    dc2a:	beq.w	df3c <_svfprintf_r+0x15ec>
    dc2e:	ldr	r5, [sp, #116]	; 0x74
    dc30:	add	r4, r5
    dc32:	b.n	d9aa <_svfprintf_r+0x105a>
    dc34:	add	r2, sp, #140	; 0x8c
    dc36:	ldr	r1, [sp, #20]
    dc38:	ldr	r0, [sp, #24]
    dc3a:	bl	118e8 <__ssprint_r>
    dc3e:	cmp	r0, #0
    dc40:	bne.w	cb44 <_svfprintf_r+0x1f4>
    dc44:	ldr	r5, [sp, #116]	; 0x74
    dc46:	ldr	r4, [sp, #148]	; 0x94
    dc48:	add.w	r9, sp, #192	; 0xc0
    dc4c:	b.n	db22 <_svfprintf_r+0x11d2>
    dc4e:	cmp.w	fp, #0
    dc52:	it	eq
    dc54:	moveq.w	fp, #1
    dc58:	b.n	d94a <_svfprintf_r+0xffa>
    dc5a:	str	r3, [sp, #40]	; 0x28
    dc5c:	mov	r7, r2
    dc5e:	b.n	d71a <_svfprintf_r+0xdca>
    dc60:	str	r3, [sp, #40]	; 0x28
    dc62:	b.n	da52 <_svfprintf_r+0x1102>
    dc64:	adds	r3, #4
    dc66:	ldr	r4, [r2, #0]
    dc68:	str	r3, [sp, #40]	; 0x28
    dc6a:	movs	r5, #0
    dc6c:	b.w	d0b6 <_svfprintf_r+0x766>
    dc70:	movs	r7, #45	; 0x2d
    dc72:	str	r3, [sp, #16]
    dc74:	ldr	r3, [sp, #44]	; 0x2c
    dc76:	str	r3, [sp, #12]
    dc78:	strb.w	r7, [sp, #111]	; 0x6f
    dc7c:	mov.w	fp, #0
    dc80:	b.w	ccf6 <_svfprintf_r+0x3a6>
    dc84:	mov	r0, r6
    dc86:	bl	b740 <strlen>
    dc8a:	mov	fp, r4
    dc8c:	mov	r3, r0
    dc8e:	str	r0, [sp, #36]	; 0x24
    dc90:	b.w	d1d8 <_svfprintf_r+0x888>
    dc94:	add	r2, sp, #140	; 0x8c
    dc96:	ldr	r1, [sp, #20]
    dc98:	ldr	r0, [sp, #24]
    dc9a:	bl	118e8 <__ssprint_r>
    dc9e:	cmp	r0, #0
    dca0:	bne.w	cb44 <_svfprintf_r+0x1f4>
    dca4:	ldr	r4, [sp, #148]	; 0x94
    dca6:	ldr	r3, [sp, #144]	; 0x90
    dca8:	add.w	r9, sp, #192	; 0xc0
    dcac:	ldr	r1, [sp, #56]	; 0x38
    dcae:	str.w	r6, [r9]
    dcb2:	adds	r3, #1
    dcb4:	add	r4, r1
    dcb6:	cmp	r3, #7
    dcb8:	str	r4, [sp, #148]	; 0x94
    dcba:	str	r3, [sp, #144]	; 0x90
    dcbc:	str.w	r1, [r9, #4]
    dcc0:	ble.w	ce78 <_svfprintf_r+0x528>
    dcc4:	b.w	d4be <_svfprintf_r+0xb6e>
    dcc8:	ldr	r3, [sp, #116]	; 0x74
    dcca:	adds	r5, r3, #3
    dccc:	blt.n	dd0c <_svfprintf_r+0x13bc>
    dcce:	cmp	fp, r3
    dcd0:	blt.n	dd0c <_svfprintf_r+0x13bc>
    dcd2:	str	r3, [sp, #60]	; 0x3c
    dcd4:	b.n	d9ee <_svfprintf_r+0x109e>
    dcd6:	mov	r3, r4
    dcd8:	b.n	d9d0 <_svfprintf_r+0x1080>
    dcda:	add	r2, sp, #140	; 0x8c
    dcdc:	ldr	r1, [sp, #20]
    dcde:	ldr	r0, [sp, #24]
    dce0:	bl	118e8 <__ssprint_r>
    dce4:	cmp	r0, #0
    dce6:	bne.w	cb44 <_svfprintf_r+0x1f4>
    dcea:	ldr	r4, [sp, #148]	; 0x94
    dcec:	add.w	r9, sp, #192	; 0xc0
    dcf0:	b.n	d58c <_svfprintf_r+0xc3c>
    dcf2:	mov	r4, r2
    dcf4:	adds	r3, #1
    dcf6:	ldr	r2, [sp, #44]	; 0x2c
    dcf8:	str	r3, [sp, #144]	; 0x90
    dcfa:	add	r4, r5
    dcfc:	cmp	r3, #7
    dcfe:	str	r4, [sp, #148]	; 0x94
    dd00:	stmia.w	r9, {r2, r5}
    dd04:	bgt.n	dc94 <_svfprintf_r+0x1344>
    dd06:	add.w	r9, r9, #8
    dd0a:	b.n	dcac <_svfprintf_r+0x135c>
    dd0c:	ldr	r2, [sp, #52]	; 0x34
    dd0e:	subs	r2, #2
    dd10:	str	r2, [sp, #52]	; 0x34
    dd12:	subs	r3, #1
    dd14:	cmp	r3, #0
    dd16:	ldrb.w	r2, [sp, #52]	; 0x34
    dd1a:	str	r3, [sp, #116]	; 0x74
    dd1c:	it	lt
    dd1e:	neglt	r3, r3
    dd20:	strb.w	r2, [sp, #124]	; 0x7c
    dd24:	ite	lt
    dd26:	movlt	r2, #45	; 0x2d
    dd28:	movge	r2, #43	; 0x2b
    dd2a:	cmp	r3, #9
    dd2c:	strb.w	r2, [sp, #125]	; 0x7d
    dd30:	ble.w	df0a <_svfprintf_r+0x15ba>
    dd34:	add.w	r0, sp, #139	; 0x8b
    dd38:	mov	r4, r0
    dd3a:	ldr	r2, [pc, #180]	; (ddf0 <_svfprintf_r+0x14a0>)
    dd3c:	smull	r2, r1, r2, r3
    dd40:	asrs	r2, r3, #31
    dd42:	rsb	r2, r2, r1, asr #2
    dd46:	add.w	r1, r2, r2, lsl #2
    dd4a:	sub.w	r3, r3, r1, lsl #1
    dd4e:	add.w	r1, r3, #48	; 0x30
    dd52:	cmp	r2, #9
    dd54:	mov	r3, r2
    dd56:	strb.w	r1, [r4, #-1]!
    dd5a:	bgt.n	dd3a <_svfprintf_r+0x13ea>
    dd5c:	mov	r1, r4
    dd5e:	adds	r3, #48	; 0x30
    dd60:	uxtb	r2, r3
    dd62:	strb.w	r2, [r1, #-1]!
    dd66:	cmp	r0, r1
    dd68:	bls.w	dfd4 <_svfprintf_r+0x1684>
    dd6c:	add.w	r1, sp, #126	; 0x7e
    dd70:	mov	r3, r4
    dd72:	b.n	dd78 <_svfprintf_r+0x1428>
    dd74:	ldrb.w	r2, [r3], #1
    dd78:	strb.w	r2, [r1], #1
    dd7c:	cmp	r0, r3
    dd7e:	bne.n	dd74 <_svfprintf_r+0x1424>
    dd80:	adds	r3, r0, #1
    dd82:	subs	r3, r3, r4
    dd84:	add.w	r2, sp, #126	; 0x7e
    dd88:	add	r3, r2
    dd8a:	add	r2, sp, #124	; 0x7c
    dd8c:	subs	r3, r3, r2
    dd8e:	ldr	r2, [sp, #56]	; 0x38
    dd90:	str	r3, [sp, #84]	; 0x54
    dd92:	cmp	r2, #1
    dd94:	add	r3, r2
    dd96:	str	r3, [sp, #36]	; 0x24
    dd98:	ble.w	df6a <_svfprintf_r+0x161a>
    dd9c:	ldr	r3, [sp, #36]	; 0x24
    dd9e:	ldr	r2, [sp, #72]	; 0x48
    dda0:	add	r3, r2
    dda2:	movs	r2, #0
    dda4:	str	r3, [sp, #36]	; 0x24
    dda6:	str	r2, [sp, #60]	; 0x3c
    dda8:	bic.w	r3, r3, r3, asr #31
    ddac:	b.n	da0a <_svfprintf_r+0x10ba>
    ddae:	add	r2, sp, #140	; 0x8c
    ddb0:	ldr	r1, [sp, #20]
    ddb2:	ldr	r0, [sp, #24]
    ddb4:	bl	118e8 <__ssprint_r>
    ddb8:	cmp	r0, #0
    ddba:	bne.w	cb44 <_svfprintf_r+0x1f4>
    ddbe:	ldr	r3, [sp, #116]	; 0x74
    ddc0:	ldr	r4, [sp, #148]	; 0x94
    ddc2:	add.w	r9, sp, #192	; 0xc0
    ddc6:	b.n	d7a0 <_svfprintf_r+0xe50>
    ddc8:	add	r2, sp, #140	; 0x8c
    ddca:	ldr	r1, [sp, #20]
    ddcc:	ldr	r0, [sp, #24]
    ddce:	bl	118e8 <__ssprint_r>
    ddd2:	cmp	r0, #0
    ddd4:	bne.w	cb44 <_svfprintf_r+0x1f4>
    ddd8:	ldr	r3, [sp, #116]	; 0x74
    ddda:	ldr	r2, [sp, #56]	; 0x38
    dddc:	ldr	r4, [sp, #148]	; 0x94
    ddde:	subs	r3, r2, r3
    dde0:	add.w	r9, sp, #192	; 0xc0
    dde4:	b.n	d7d0 <_svfprintf_r+0xe80>
    dde6:	nop
    dde8:	.word	0x000129a8
    ddec:	.word	0x00012958
    ddf0:	.word	0x66666667
    ddf4:	cmp	r5, #6
    ddf6:	mov	r3, r5
    ddf8:	it	cs
    ddfa:	movcs	r3, #6
    ddfc:	str	r3, [sp, #36]	; 0x24
    ddfe:	bic.w	r3, r3, r3, asr #31
    de02:	mov	fp, r6
    de04:	str	r7, [sp, #40]	; 0x28
    de06:	str	r6, [sp, #60]	; 0x3c
    de08:	mov	r7, r6
    de0a:	str	r3, [sp, #16]
    de0c:	ldr	r6, [pc, #536]	; (e028 <_svfprintf_r+0x16d8>)
    de0e:	b.w	ccf4 <_svfprintf_r+0x3a4>
    de12:	mov.w	fp, #6
    de16:	b.n	d94a <_svfprintf_r+0xffa>
    de18:	add	r2, sp, #132	; 0x84
    de1a:	add	r3, sp, #120	; 0x78
    de1c:	str	r2, [sp, #4]
    de1e:	str	r3, [sp, #0]
    de20:	mov	r2, fp
    de22:	add	r3, sp, #116	; 0x74
    de24:	movs	r1, #3
    de26:	vldr	d0, [sp, #96]	; 0x60
    de2a:	ldr	r0, [sp, #24]
    de2c:	bl	f158 <_dtoa_r>
    de30:	mov	r5, fp
    de32:	mov	r6, r0
    de34:	add.w	r4, r0, fp
    de38:	b.n	dc26 <_svfprintf_r+0x12d6>
    de3a:	movs	r7, #45	; 0x2d
    de3c:	strb.w	r7, [sp, #111]	; 0x6f
    de40:	b.w	cf9a <_svfprintf_r+0x64a>
    de44:	str	r3, [sp, #12]
    de46:	b.w	d0f2 <_svfprintf_r+0x7a2>
    de4a:	ldrd	r1, r2, [sp, #64]	; 0x40
    de4e:	add.w	r3, r2, #2147483648	; 0x80000000
    de52:	str	r3, [sp, #100]	; 0x64
    de54:	movs	r3, #45	; 0x2d
    de56:	str	r1, [sp, #96]	; 0x60
    de58:	str	r3, [sp, #16]
    de5a:	b.n	d966 <_svfprintf_r+0x1016>
    de5c:	ldr	r2, [sp, #72]	; 0x48
    de5e:	ldr	r3, [sp, #56]	; 0x38
    de60:	add	r3, r2
    de62:	ldr	r2, [sp, #60]	; 0x3c
    de64:	str	r3, [sp, #36]	; 0x24
    de66:	cmp	r2, #0
    de68:	ble.w	df7e <_svfprintf_r+0x162e>
    de6c:	movs	r2, #103	; 0x67
    de6e:	bic.w	r3, r3, r3, asr #31
    de72:	str	r2, [sp, #52]	; 0x34
    de74:	b.n	da0a <_svfprintf_r+0x10ba>
    de76:	ldr	r3, [sp, #52]	; 0x34
    de78:	cmp	r3, #71	; 0x47
    de7a:	bne.w	d9a8 <_svfprintf_r+0x1058>
    de7e:	ldr	r3, [sp, #12]
    de80:	lsls	r3, r3, #31
    de82:	bmi.w	dc1a <_svfprintf_r+0x12ca>
    de86:	ldr	r3, [sp, #132]	; 0x84
    de88:	cmp	r7, #71	; 0x47
    de8a:	sub.w	r3, r3, r6
    de8e:	str	r3, [sp, #56]	; 0x38
    de90:	beq.w	dcc8 <_svfprintf_r+0x1378>
    de94:	ldr	r3, [sp, #116]	; 0x74
    de96:	b.n	dd12 <_svfprintf_r+0x13c2>
    de98:	bic.w	r3, r5, r5, asr #31
    de9c:	str	r7, [sp, #40]	; 0x28
    de9e:	str	r3, [sp, #16]
    dea0:	str	r5, [sp, #36]	; 0x24
    dea2:	mov	fp, r0
    dea4:	str	r0, [sp, #60]	; 0x3c
    dea6:	ldrb.w	r7, [sp, #111]	; 0x6f
    deaa:	b.w	ccf4 <_svfprintf_r+0x3a4>
    deae:	cmp	r3, #0
    deb0:	ble.n	df8e <_svfprintf_r+0x163e>
    deb2:	cmp.w	fp, #0
    deb6:	bne.n	df58 <_svfprintf_r+0x1608>
    deb8:	ldr	r2, [sp, #12]
    deba:	lsls	r4, r2, #31
    debc:	bmi.n	df58 <_svfprintf_r+0x1608>
    debe:	mov	r2, r3
    dec0:	str	r2, [sp, #36]	; 0x24
    dec2:	bic.w	r3, r3, r3, asr #31
    dec6:	b.n	da0a <_svfprintf_r+0x10ba>
    dec8:	ldr	r3, [sp, #12]
    deca:	lsls	r3, r3, #31
    decc:	mov	r7, fp
    dece:	bpl.n	dedc <_svfprintf_r+0x158c>
    ded0:	add	r6, sp, #256	; 0x100
    ded2:	movs	r3, #48	; 0x30
    ded4:	strb.w	r3, [r6, #-65]!
    ded8:	b.w	cce0 <_svfprintf_r+0x390>
    dedc:	str.w	fp, [sp, #36]	; 0x24
    dee0:	add	r6, sp, #192	; 0xc0
    dee2:	b.w	cce6 <_svfprintf_r+0x396>
    dee6:	add	r2, sp, #140	; 0x8c
    dee8:	ldr	r1, [sp, #20]
    deea:	ldr	r0, [sp, #24]
    deec:	bl	118e8 <__ssprint_r>
    def0:	cmp	r0, #0
    def2:	bne.w	cb44 <_svfprintf_r+0x1f4>
    def6:	ldr	r5, [sp, #116]	; 0x74
    def8:	ldr	r4, [sp, #148]	; 0x94
    defa:	ldr	r3, [sp, #144]	; 0x90
    defc:	add.w	r9, sp, #192	; 0xc0
    df00:	b.n	db50 <_svfprintf_r+0x1200>
    df02:	mov	r8, r4
    df04:	movs	r5, #0
    df06:	b.w	ca08 <_svfprintf_r+0xb8>
    df0a:	adds	r3, #48	; 0x30
    df0c:	movs	r2, #48	; 0x30
    df0e:	strb.w	r3, [sp, #127]	; 0x7f
    df12:	strb.w	r2, [sp, #126]	; 0x7e
    df16:	add	r3, sp, #128	; 0x80
    df18:	b.n	dd8a <_svfprintf_r+0x143a>
    df1a:	ldr	r3, [sp, #132]	; 0x84
    df1c:	b.n	d9d0 <_svfprintf_r+0x1080>
    df1e:	ldr	r2, [sp, #72]	; 0x48
    df20:	ldr	r3, [sp, #60]	; 0x3c
    df22:	add	r3, r2
    df24:	movs	r2, #103	; 0x67
    df26:	str	r3, [sp, #36]	; 0x24
    df28:	str	r2, [sp, #52]	; 0x34
    df2a:	bic.w	r3, r3, r3, asr #31
    df2e:	b.n	da0a <_svfprintf_r+0x10ba>
    df30:	ldr	r6, [pc, #248]	; (e02c <_svfprintf_r+0x16dc>)
    df32:	ldr	r3, [pc, #252]	; (e030 <_svfprintf_r+0x16e0>)
    df34:	ldrb.w	r7, [sp, #111]	; 0x6f
    df38:	b.w	cf9e <_svfprintf_r+0x64e>
    df3c:	movs	r2, #0
    df3e:	movs	r3, #0
    df40:	ldrd	r0, r1, [sp, #96]	; 0x60
    df44:	bl	a540 <__aeabi_dcmpeq>
    df48:	cmp	r0, #0
    df4a:	bne.w	dc2e <_svfprintf_r+0x12de>
    df4e:	rsb	r5, r5, #1
    df52:	str	r5, [sp, #116]	; 0x74
    df54:	add	r4, r5
    df56:	b.n	d9aa <_svfprintf_r+0x105a>
    df58:	ldr	r3, [sp, #60]	; 0x3c
    df5a:	ldr	r2, [sp, #72]	; 0x48
    df5c:	adds	r5, r3, r2
    df5e:	add.w	r3, r5, fp
    df62:	str	r3, [sp, #36]	; 0x24
    df64:	bic.w	r3, r3, r3, asr #31
    df68:	b.n	da0a <_svfprintf_r+0x10ba>
    df6a:	ldr	r3, [sp, #12]
    df6c:	ands.w	r3, r3, #1
    df70:	bne.w	dd9c <_svfprintf_r+0x144c>
    df74:	str	r3, [sp, #60]	; 0x3c
    df76:	ldr	r3, [sp, #36]	; 0x24
    df78:	bic.w	r3, r3, r3, asr #31
    df7c:	b.n	da0a <_svfprintf_r+0x10ba>
    df7e:	ldr	r3, [sp, #60]	; 0x3c
    df80:	ldr	r2, [sp, #36]	; 0x24
    df82:	rsb	r3, r3, #1
    df86:	add	r2, r3
    df88:	mov	r3, r2
    df8a:	str	r2, [sp, #36]	; 0x24
    df8c:	b.n	de6c <_svfprintf_r+0x151c>
    df8e:	cmp.w	fp, #0
    df92:	bne.n	df9a <_svfprintf_r+0x164a>
    df94:	ldr	r3, [sp, #12]
    df96:	lsls	r0, r3, #31
    df98:	bpl.n	dfaa <_svfprintf_r+0x165a>
    df9a:	ldr	r3, [sp, #72]	; 0x48
    df9c:	adds	r5, r3, #1
    df9e:	add.w	r3, r5, fp
    dfa2:	str	r3, [sp, #36]	; 0x24
    dfa4:	bic.w	r3, r3, r3, asr #31
    dfa8:	b.n	da0a <_svfprintf_r+0x10ba>
    dfaa:	movs	r3, #1
    dfac:	str	r3, [sp, #36]	; 0x24
    dfae:	b.n	da0a <_svfprintf_r+0x10ba>
    dfb0:	ldr	r0, [sp, #40]	; 0x28
    dfb2:	ldrb.w	r3, [r8, #1]
    dfb6:	ldr	r5, [r0, #0]
    dfb8:	adds	r0, #4
    dfba:	cmp	r5, #0
    dfbc:	str	r0, [sp, #40]	; 0x28
    dfbe:	mov	r8, r4
    dfc0:	bge.w	ca04 <_svfprintf_r+0xb4>
    dfc4:	mov.w	r5, #4294967295
    dfc8:	b.w	ca04 <_svfprintf_r+0xb4>
    dfcc:	strb.w	r1, [sp, #111]	; 0x6f
    dfd0:	b.w	cb66 <_svfprintf_r+0x216>
    dfd4:	add.w	r3, sp, #126	; 0x7e
    dfd8:	b.n	dd8a <_svfprintf_r+0x143a>
    dfda:	ldr	r2, [sp, #24]
    dfdc:	movs	r3, #12
    dfde:	str	r3, [r2, #0]
    dfe0:	mov.w	r0, #4294967295
    dfe4:	b.w	cb56 <_svfprintf_r+0x206>
    dfe8:	strb.w	r1, [sp, #111]	; 0x6f
    dfec:	b.w	cc60 <_svfprintf_r+0x310>
    dff0:	strb.w	r1, [sp, #111]	; 0x6f
    dff4:	b.w	cf2c <_svfprintf_r+0x5dc>
    dff8:	strb.w	r1, [sp, #111]	; 0x6f
    dffc:	b.w	d09a <_svfprintf_r+0x74a>
    e000:	strb.w	r1, [sp, #111]	; 0x6f
    e004:	b.w	d03e <_svfprintf_r+0x6ee>
    e008:	strb.w	r1, [sp, #111]	; 0x6f
    e00c:	b.w	cfea <_svfprintf_r+0x69a>
    e010:	strb.w	r1, [sp, #111]	; 0x6f
    e014:	b.w	d282 <_svfprintf_r+0x932>
    e018:	strb.w	r1, [sp, #111]	; 0x6f
    e01c:	b.w	d240 <_svfprintf_r+0x8f0>
    e020:	strb.w	r1, [sp, #111]	; 0x6f
    e024:	b.w	d204 <_svfprintf_r+0x8b4>
    e028:	.word	0x000129a0
    e02c:	.word	0x00012974
    e030:	.word	0x00012970

0000e034 <__ssvfscanf_r>:
    e034:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e038:	mov	fp, r1
    e03a:	ldrsh.w	r1, [r1, #12]
    e03e:	sub.w	sp, sp, #692	; 0x2b4
    e042:	mov	sl, r0
    e044:	lsls	r0, r1, #18
    e046:	mov	r4, r2
    e048:	str	r3, [sp, #20]
    e04a:	bmi.n	e060 <__ssvfscanf_r+0x2c>
    e04c:	ldr.w	r3, [fp, #100]	; 0x64
    e050:	orr.w	r1, r1, #8192	; 0x2000
    e054:	bic.w	r3, r3, #8192	; 0x2000
    e058:	strh.w	r1, [fp, #12]
    e05c:	str.w	r3, [fp, #100]	; 0x64
    e060:	mov	r6, r4
    e062:	movs	r3, #0
    e064:	str	r3, [sp, #28]
    e066:	str	r3, [sp, #16]
    e068:	mov	r7, r3
    e06a:	str	r3, [sp, #24]
    e06c:	ldrb.w	r3, [r6], #1
    e070:	str	r3, [sp, #68]	; 0x44
    e072:	cbz	r3, e0d0 <__ssvfscanf_r+0x9c>
    e074:	bl	aabc <__locale_ctype_ptr>
    e078:	ldr	r2, [sp, #68]	; 0x44
    e07a:	add	r0, r2
    e07c:	ldrb	r3, [r0, #1]
    e07e:	and.w	r3, r3, #8
    e082:	and.w	r5, r3, #255	; 0xff
    e086:	cbz	r3, e0da <__ssvfscanf_r+0xa6>
    e088:	ldr.w	r3, [fp, #4]
    e08c:	b.n	e0b2 <__ssvfscanf_r+0x7e>
    e08e:	bl	aabc <__locale_ctype_ptr>
    e092:	ldr.w	r3, [fp]
    e096:	ldrb	r2, [r3, #0]
    e098:	add	r0, r2
    e09a:	adds	r3, #1
    e09c:	ldrb	r2, [r0, #1]
    e09e:	lsls	r1, r2, #28
    e0a0:	bpl.n	e0c2 <__ssvfscanf_r+0x8e>
    e0a2:	ldr.w	r2, [fp, #4]
    e0a6:	str.w	r3, [fp]
    e0aa:	subs	r3, r2, #1
    e0ac:	adds	r7, #1
    e0ae:	str.w	r3, [fp, #4]
    e0b2:	cmp	r3, #0
    e0b4:	bgt.n	e08e <__ssvfscanf_r+0x5a>
    e0b6:	mov	r1, fp
    e0b8:	mov	r0, sl
    e0ba:	bl	11a6c <__ssrefill_r>
    e0be:	cmp	r0, #0
    e0c0:	beq.n	e08e <__ssvfscanf_r+0x5a>
    e0c2:	mov	r4, r6
    e0c4:	mov	r6, r4
    e0c6:	ldrb.w	r3, [r6], #1
    e0ca:	str	r3, [sp, #68]	; 0x44
    e0cc:	cmp	r3, #0
    e0ce:	bne.n	e074 <__ssvfscanf_r+0x40>
    e0d0:	ldr	r0, [sp, #24]
    e0d2:	add.w	sp, sp, #692	; 0x2b4
    e0d6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e0da:	cmp	r2, #37	; 0x25
    e0dc:	bne.w	e1e8 <__ssvfscanf_r+0x1b4>
    e0e0:	ldrb.w	r8, [r4, #1]
    e0e4:	mov	r4, r5
    e0e6:	adds	r3, r6, #1
    e0e8:	cmp.w	r8, #120	; 0x78
    e0ec:	bhi.w	e576 <__ssvfscanf_r+0x542>
    e0f0:	tbh	[pc, r8, lsl #1]
    e0f4:	.word	0x02410092
    e0f8:	.word	0x02410241
    e0fc:	.word	0x02410241
    e100:	.word	0x02410241
    e104:	.word	0x02410241
    e108:	.word	0x02410241
    e10c:	.word	0x02410241
    e110:	.word	0x02410241
    e114:	.word	0x02410241
    e118:	.word	0x02410241
    e11c:	.word	0x02410241
    e120:	.word	0x02410241
    e124:	.word	0x02410241
    e128:	.word	0x02410241
    e12c:	.word	0x02410241
    e130:	.word	0x02410241
    e134:	.word	0x02410241
    e138:	.word	0x02410241
    e13c:	.word	0x00790241
    e140:	.word	0x02410241
    e144:	.word	0x02410241
    e148:	.word	0x024101d8
    e14c:	.word	0x02410241
    e150:	.word	0x02410241
    e154:	.word	0x01cf01cf
    e158:	.word	0x01cf01cf
    e15c:	.word	0x01cf01cf
    e160:	.word	0x01cf01cf
    e164:	.word	0x01cf01cf
    e168:	.word	0x02410241
    e16c:	.word	0x02410241
    e170:	.word	0x02410241
    e174:	.word	0x02410241
    e178:	.word	0x02410241
    e17c:	.word	0x01b901c1
    e180:	.word	0x01b90241
    e184:	.word	0x02410241
    e188:	.word	0x02410241
    e18c:	.word	0x024101b3
    e190:	.word	0x01a30241
    e194:	.word	0x02410241
    e198:	.word	0x02410241
    e19c:	.word	0x02410241
    e1a0:	.word	0x02410241
    e1a4:	.word	0x02410193
    e1a8:	.word	0x01510241
    e1ac:	.word	0x02410241
    e1b0:	.word	0x02410241
    e1b4:	.word	0x02410241
    e1b8:	.word	0x01220241
    e1bc:	.word	0x01b90188
    e1c0:	.word	0x01b901b9
    e1c4:	.word	0x0098011c
    e1c8:	.word	0x02410241
    e1cc:	.word	0x024100d5
    e1d0:	.word	0x0101010d
    e1d4:	.word	0x024100f3
    e1d8:	.word	0x00eb0241
    e1dc:	.word	0x00df0241
    e1e0:	.word	0x02410241
    e1e4:	.short	0x0193
    e1e6:	mov	r6, r3
    e1e8:	ldr.w	r3, [fp, #4]
    e1ec:	cmp	r3, #0
    e1ee:	ble.w	e698 <__ssvfscanf_r+0x664>
    e1f2:	ldr.w	r3, [fp]
    e1f6:	ldrb.w	r2, [r6, #-1]
    e1fa:	ldrb	r1, [r3, #0]
    e1fc:	cmp	r1, r2
    e1fe:	bne.w	e0d0 <__ssvfscanf_r+0x9c>
    e202:	ldr.w	r2, [fp, #4]
    e206:	adds	r3, #1
    e208:	subs	r2, #1
    e20a:	str.w	r3, [fp]
    e20e:	adds	r7, #1
    e210:	str.w	r2, [fp, #4]
    e214:	mov	r4, r6
    e216:	b.n	e0c4 <__ssvfscanf_r+0x90>
    e218:	mov.w	r0, #4294967295
    e21c:	add.w	sp, sp, #692	; 0x2b4
    e220:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e224:	str	r3, [sp, #12]
    e226:	ldr.w	r3, [fp, #4]
    e22a:	cmp	r3, #0
    e22c:	ble.w	e6f6 <__ssvfscanf_r+0x6c2>
    e230:	ldr	r3, [pc, #736]	; (e514 <__ssvfscanf_r+0x4e0>)
    e232:	str	r3, [sp, #28]
    e234:	movs	r3, #0
    e236:	str	r3, [sp, #16]
    e238:	movs	r6, #3
    e23a:	b.n	e240 <__ssvfscanf_r+0x20c>
    e23c:	str.w	lr, [fp]
    e240:	bl	aabc <__locale_ctype_ptr>
    e244:	ldr.w	r2, [fp]
    e248:	ldrb	r1, [r2, #0]
    e24a:	add	r0, r1
    e24c:	add.w	lr, r2, #1
    e250:	ldrb	r3, [r0, #1]
    e252:	and.w	r3, r3, #8
    e256:	and.w	r8, r3, #255	; 0xff
    e25a:	cmp	r3, #0
    e25c:	beq.w	e75e <__ssvfscanf_r+0x72a>
    e260:	ldr.w	r3, [fp, #4]
    e264:	subs	r3, #1
    e266:	cmp	r3, #0
    e268:	add.w	r7, r7, #1
    e26c:	str.w	r3, [fp, #4]
    e270:	bgt.n	e23c <__ssvfscanf_r+0x208>
    e272:	mov	r1, fp
    e274:	mov	r0, sl
    e276:	bl	11a6c <__ssrefill_r>
    e27a:	cmp	r0, #0
    e27c:	beq.n	e240 <__ssvfscanf_r+0x20c>
    e27e:	ldr	r2, [sp, #24]
    e280:	cmp	r2, #0
    e282:	beq.n	e218 <__ssvfscanf_r+0x1e4>
    e284:	ldrh.w	r3, [fp, #12]
    e288:	tst.w	r3, #64	; 0x40
    e28c:	mov	r3, r2
    e28e:	it	ne
    e290:	movne.w	r3, #4294967295
    e294:	mov	r0, r3
    e296:	add.w	sp, sp, #692	; 0x2b4
    e29a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e29e:	ldrb.w	r8, [r6, #1]
    e2a2:	cmp.w	r8, #108	; 0x6c
    e2a6:	beq.w	e6ae <__ssvfscanf_r+0x67a>
    e2aa:	orr.w	r5, r5, #1
    e2ae:	mov	r6, r3
    e2b0:	b.n	e0e6 <__ssvfscanf_r+0xb2>
    e2b2:	str	r3, [sp, #12]
    e2b4:	ldr.w	r3, [fp, #4]
    e2b8:	cmp	r3, #0
    e2ba:	ble.w	e74e <__ssvfscanf_r+0x71a>
    e2be:	ldr	r3, [pc, #600]	; (e518 <__ssvfscanf_r+0x4e4>)
    e2c0:	str	r3, [sp, #28]
    e2c2:	movs	r3, #10
    e2c4:	str	r3, [sp, #16]
    e2c6:	movs	r6, #3
    e2c8:	b.n	e240 <__ssvfscanf_r+0x20c>
    e2ca:	str	r3, [sp, #12]
    e2cc:	ldr.w	r3, [fp, #4]
    e2d0:	cmp	r3, #0
    e2d2:	ble.w	e73e <__ssvfscanf_r+0x70a>
    e2d6:	movs	r6, #2
    e2d8:	b.n	e240 <__ssvfscanf_r+0x20c>
    e2da:	str	r3, [sp, #12]
    e2dc:	ldr.w	r3, [fp, #4]
    e2e0:	cmp	r3, #0
    e2e2:	orr.w	r5, r5, #544	; 0x220
    e2e6:	ble.w	e42a <__ssvfscanf_r+0x3f6>
    e2ea:	ldr	r3, [pc, #556]	; (e518 <__ssvfscanf_r+0x4e4>)
    e2ec:	str	r3, [sp, #28]
    e2ee:	movs	r3, #16
    e2f0:	str	r3, [sp, #16]
    e2f2:	movs	r6, #3
    e2f4:	b.n	e240 <__ssvfscanf_r+0x20c>
    e2f6:	str	r3, [sp, #12]
    e2f8:	ldr.w	r3, [fp, #4]
    e2fc:	cmp	r3, #0
    e2fe:	ble.w	e44a <__ssvfscanf_r+0x416>
    e302:	ldr	r3, [pc, #532]	; (e518 <__ssvfscanf_r+0x4e4>)
    e304:	str	r3, [sp, #28]
    e306:	movs	r3, #8
    e308:	str	r3, [sp, #16]
    e30a:	movs	r6, #3
    e30c:	b.n	e240 <__ssvfscanf_r+0x20c>
    e30e:	lsls	r2, r5, #27
    e310:	mov	r6, r3
    e312:	str	r3, [sp, #12]
    e314:	bmi.w	e4fc <__ssvfscanf_r+0x4c8>
    e318:	lsls	r3, r5, #29
    e31a:	bpl.w	e6c6 <__ssvfscanf_r+0x692>
    e31e:	ldr	r1, [sp, #20]
    e320:	ldr	r3, [r1, #0]
    e322:	strh	r7, [r3, #0]
    e324:	adds	r3, r1, #4
    e326:	str	r3, [sp, #20]
    e328:	mov	r4, r6
    e32a:	b.n	e0c4 <__ssvfscanf_r+0x90>
    e32c:	ldrb.w	r8, [r6, #1]
    e330:	orr.w	r5, r5, #4
    e334:	mov	r6, r3
    e336:	b.n	e0e6 <__ssvfscanf_r+0xb2>
    e338:	str	r3, [sp, #12]
    e33a:	ldr.w	r3, [fp, #4]
    e33e:	cmp	r3, #0
    e340:	ble.w	e71e <__ssvfscanf_r+0x6ea>
    e344:	cmp	r4, #0
    e346:	it	eq
    e348:	moveq	r4, #1
    e34a:	ands.w	r3, r5, #1
    e34e:	bne.w	e596 <__ssvfscanf_r+0x562>
    e352:	lsls	r2, r5, #27
    e354:	bpl.w	e66e <__ssvfscanf_r+0x63a>
    e358:	mov	r5, r3
    e35a:	b.n	e370 <__ssvfscanf_r+0x33c>
    e35c:	add	r3, r2
    e35e:	str.w	r3, [fp]
    e362:	add	r5, r2
    e364:	subs	r4, r4, r2
    e366:	bl	11a6c <__ssrefill_r>
    e36a:	cmp	r0, #0
    e36c:	bne.w	e666 <__ssvfscanf_r+0x632>
    e370:	ldr.w	r2, [fp, #4]
    e374:	ldr.w	r3, [fp]
    e378:	cmp	r2, r4
    e37a:	mov	r1, fp
    e37c:	mov	r0, sl
    e37e:	blt.n	e35c <__ssvfscanf_r+0x328>
    e380:	subs	r2, r2, r4
    e382:	add	r3, r4
    e384:	str.w	r2, [fp, #4]
    e388:	add	r5, r4
    e38a:	str.w	r3, [fp]
    e38e:	ldr	r6, [sp, #12]
    e390:	add	r7, r5
    e392:	mov	r4, r6
    e394:	b.n	e0c4 <__ssvfscanf_r+0x90>
    e396:	add.w	r9, sp, #80	; 0x50
    e39a:	mov	r1, r3
    e39c:	mov	r0, r9
    e39e:	bl	11308 <__sccl>
    e3a2:	ldr.w	r3, [fp, #4]
    e3a6:	cmp	r3, #0
    e3a8:	mov	r6, r0
    e3aa:	ble.w	e70e <__ssvfscanf_r+0x6da>
    e3ae:	cmp	r4, #0
    e3b0:	ldr.w	r2, [fp]
    e3b4:	it	eq
    e3b6:	moveq.w	r4, #4294967295
    e3ba:	lsls	r3, r5, #27
    e3bc:	ldrb	r1, [r2, #0]
    e3be:	bpl.w	e502 <__ssvfscanf_r+0x4ce>
    e3c2:	mov	r8, r4
    e3c4:	movs	r5, #0
    e3c6:	b.n	e3ca <__ssvfscanf_r+0x396>
    e3c8:	ldrb	r1, [r2, #0]
    e3ca:	ldrb.w	r3, [r9, r1]
    e3ce:	adds	r2, #1
    e3d0:	cmp	r3, #0
    e3d2:	beq.w	e65c <__ssvfscanf_r+0x628>
    e3d6:	ldr.w	r3, [fp, #4]
    e3da:	str.w	r2, [fp]
    e3de:	adds	r5, #1
    e3e0:	subs	r3, #1
    e3e2:	cmp	r5, r4
    e3e4:	str.w	r3, [fp, #4]
    e3e8:	beq.w	e656 <__ssvfscanf_r+0x622>
    e3ec:	cmp	r3, #0
    e3ee:	bgt.n	e3c8 <__ssvfscanf_r+0x394>
    e3f0:	mov	r1, fp
    e3f2:	mov	r0, sl
    e3f4:	bl	11a6c <__ssrefill_r>
    e3f8:	cmp	r0, #0
    e3fa:	bne.w	e654 <__ssvfscanf_r+0x620>
    e3fe:	ldr.w	r2, [fp]
    e402:	b.n	e3c8 <__ssvfscanf_r+0x394>
    e404:	str	r3, [sp, #12]
    e406:	ldr.w	r3, [fp, #4]
    e40a:	cmp	r3, #0
    e40c:	ble.n	e484 <__ssvfscanf_r+0x450>
    e40e:	ldr	r3, [pc, #260]	; (e514 <__ssvfscanf_r+0x4e0>)
    e410:	str	r3, [sp, #28]
    e412:	movs	r3, #10
    e414:	str	r3, [sp, #16]
    e416:	movs	r6, #3
    e418:	b.n	e240 <__ssvfscanf_r+0x20c>
    e41a:	str	r3, [sp, #12]
    e41c:	ldr.w	r3, [fp, #4]
    e420:	cmp	r3, #0
    e422:	orr.w	r5, r5, #512	; 0x200
    e426:	bgt.w	e2ea <__ssvfscanf_r+0x2b6>
    e42a:	mov	r1, fp
    e42c:	mov	r0, sl
    e42e:	bl	11a6c <__ssrefill_r>
    e432:	cmp	r0, #0
    e434:	beq.w	e2ea <__ssvfscanf_r+0x2b6>
    e438:	b.n	e27e <__ssvfscanf_r+0x24a>
    e43a:	str	r3, [sp, #12]
    e43c:	ldr.w	r3, [fp, #4]
    e440:	cmp	r3, #0
    e442:	orr.w	r5, r5, #1
    e446:	bgt.w	e302 <__ssvfscanf_r+0x2ce>
    e44a:	mov	r1, fp
    e44c:	mov	r0, sl
    e44e:	bl	11a6c <__ssrefill_r>
    e452:	cmp	r0, #0
    e454:	beq.w	e302 <__ssvfscanf_r+0x2ce>
    e458:	b.n	e27e <__ssvfscanf_r+0x24a>
    e45a:	ldrb.w	r8, [r6, #1]
    e45e:	orr.w	r5, r5, #2
    e462:	mov	r6, r3
    e464:	b.n	e0e6 <__ssvfscanf_r+0xb2>
    e466:	str	r3, [sp, #12]
    e468:	ldr.w	r3, [fp, #4]
    e46c:	cmp	r3, #0
    e46e:	ble.w	e72e <__ssvfscanf_r+0x6fa>
    e472:	movs	r6, #4
    e474:	b.n	e240 <__ssvfscanf_r+0x20c>
    e476:	str	r3, [sp, #12]
    e478:	ldr.w	r3, [fp, #4]
    e47c:	cmp	r3, #0
    e47e:	orr.w	r5, r5, #1
    e482:	bgt.n	e40e <__ssvfscanf_r+0x3da>
    e484:	mov	r1, fp
    e486:	mov	r0, sl
    e488:	bl	11a6c <__ssrefill_r>
    e48c:	cmp	r0, #0
    e48e:	beq.n	e40e <__ssvfscanf_r+0x3da>
    e490:	b.n	e27e <__ssvfscanf_r+0x24a>
    e492:	add.w	r4, r4, r4, lsl #2
    e496:	add.w	r4, r8, r4, lsl #1
    e49a:	subs	r4, #48	; 0x30
    e49c:	ldrb.w	r8, [r6, #1]
    e4a0:	mov	r6, r3
    e4a2:	b.n	e0e6 <__ssvfscanf_r+0xb2>
    e4a4:	ldrb.w	r8, [r6, #1]
    e4a8:	orr.w	r5, r5, #16
    e4ac:	mov	r6, r3
    e4ae:	b.n	e0e6 <__ssvfscanf_r+0xb2>
    e4b0:	add	r3, sp, #72	; 0x48
    e4b2:	mov	r1, r8
    e4b4:	mov	r0, r3
    e4b6:	movs	r2, #8
    e4b8:	str	r3, [sp, #32]
    e4ba:	bl	88dc <memset>
    e4be:	ands.w	r9, r5, #16
    e4c2:	bne.w	ed88 <__ssvfscanf_r+0xd54>
    e4c6:	ldr	r2, [sp, #20]
    e4c8:	mov	r3, r2
    e4ca:	adds	r3, #4
    e4cc:	ldr.w	r8, [r2]
    e4d0:	str	r3, [sp, #20]
    e4d2:	movs	r6, #0
    e4d4:	bl	aabc <__locale_ctype_ptr>
    e4d8:	ldr.w	r3, [fp]
    e4dc:	ldrb	r3, [r3, #0]
    e4de:	add	r0, r3
    e4e0:	ldrb	r3, [r0, #1]
    e4e2:	lsls	r0, r3, #28
    e4e4:	bmi.n	e4ec <__ssvfscanf_r+0x4b8>
    e4e6:	cmp	r4, #0
    e4e8:	bne.w	ecec <__ssvfscanf_r+0xcb8>
    e4ec:	cmp.w	r9, #0
    e4f0:	bne.n	e4fc <__ssvfscanf_r+0x4c8>
    e4f2:	str.w	r9, [r8]
    e4f6:	ldr	r3, [sp, #24]
    e4f8:	adds	r3, #1
    e4fa:	str	r3, [sp, #24]
    e4fc:	ldr	r6, [sp, #12]
    e4fe:	mov	r4, r6
    e500:	b.n	e0c4 <__ssvfscanf_r+0x90>
    e502:	ldr	r0, [sp, #20]
    e504:	ldr	r5, [r0, #0]
    e506:	mov	r3, r0
    e508:	adds	r3, #4
    e50a:	add.w	r8, r5, r4
    e50e:	str	r3, [sp, #12]
    e510:	mov	r4, r5
    e512:	b.n	e522 <__ssvfscanf_r+0x4ee>
    e514:	.word	0x0000c929
    e518:	.word	0x000116b5
    e51c:	ldr.w	r2, [fp]
    e520:	ldrb	r1, [r2, #0]
    e522:	ldrb.w	r3, [r9, r1]
    e526:	adds	r0, r2, #1
    e528:	cbz	r3, e55c <__ssvfscanf_r+0x528>
    e52a:	ldr.w	r3, [fp, #4]
    e52e:	str.w	r0, [fp]
    e532:	subs	r3, #1
    e534:	str.w	r3, [fp, #4]
    e538:	ldrb	r3, [r2, #0]
    e53a:	strb.w	r3, [r4], #1
    e53e:	cmp	r8, r4
    e540:	beq.n	e55c <__ssvfscanf_r+0x528>
    e542:	ldr.w	r3, [fp, #4]
    e546:	cmp	r3, #0
    e548:	bgt.n	e51c <__ssvfscanf_r+0x4e8>
    e54a:	mov	r1, fp
    e54c:	mov	r0, sl
    e54e:	bl	11a6c <__ssrefill_r>
    e552:	cmp	r0, #0
    e554:	beq.n	e51c <__ssvfscanf_r+0x4e8>
    e556:	cmp	r5, r4
    e558:	beq.w	e27e <__ssvfscanf_r+0x24a>
    e55c:	subs	r5, r4, r5
    e55e:	beq.w	e0d0 <__ssvfscanf_r+0x9c>
    e562:	ldr	r2, [sp, #24]
    e564:	adds	r2, #1
    e566:	movs	r3, #0
    e568:	str	r2, [sp, #24]
    e56a:	ldr	r2, [sp, #12]
    e56c:	str	r2, [sp, #20]
    e56e:	strb	r3, [r4, #0]
    e570:	add	r7, r5
    e572:	mov	r4, r6
    e574:	b.n	e0c4 <__ssvfscanf_r+0x90>
    e576:	str	r3, [sp, #12]
    e578:	bl	aabc <__locale_ctype_ptr>
    e57c:	add	r0, r8
    e57e:	ldrb	r3, [r0, #1]
    e580:	and.w	r3, r3, #3
    e584:	cmp	r3, #1
    e586:	ldr.w	r3, [fp, #4]
    e58a:	beq.w	e6ba <__ssvfscanf_r+0x686>
    e58e:	cmp	r3, #0
    e590:	bgt.w	e40e <__ssvfscanf_r+0x3da>
    e594:	b.n	e484 <__ssvfscanf_r+0x450>
    e596:	add	r3, sp, #72	; 0x48
    e598:	mov	r0, r3
    e59a:	movs	r2, #8
    e59c:	movs	r1, #0
    e59e:	str	r3, [sp, #32]
    e5a0:	bl	88dc <memset>
    e5a4:	ands.w	r3, r5, #16
    e5a8:	str	r3, [sp, #40]	; 0x28
    e5aa:	bne.n	e6a8 <__ssvfscanf_r+0x674>
    e5ac:	ldr	r2, [sp, #20]
    e5ae:	mov	r3, r2
    e5b0:	adds	r3, #4
    e5b2:	ldr.w	r9, [r2]
    e5b6:	str	r3, [sp, #20]
    e5b8:	movs	r5, #0
    e5ba:	add.w	r8, sp, #336	; 0x150
    e5be:	bl	aa98 <__locale_mb_cur_max>
    e5c2:	cmp	r0, r5
    e5c4:	beq.w	e27e <__ssvfscanf_r+0x24a>
    e5c8:	ldmia.w	fp, {r2, r3}
    e5cc:	ldrb.w	r0, [r2], #1
    e5d0:	str.w	r2, [fp]
    e5d4:	subs	r3, #1
    e5d6:	ldr	r2, [sp, #32]
    e5d8:	str	r2, [sp, #0]
    e5da:	adds	r6, r5, #1
    e5dc:	str.w	r3, [fp, #4]
    e5e0:	mov	r1, r9
    e5e2:	strb.w	r0, [r8, r5]
    e5e6:	mov	r3, r6
    e5e8:	mov	r2, r8
    e5ea:	mov	r0, sl
    e5ec:	bl	109c4 <_mbrtowc_r>
    e5f0:	adds	r1, r0, #1
    e5f2:	beq.w	e27e <__ssvfscanf_r+0x24a>
    e5f6:	cbnz	r0, e622 <__ssvfscanf_r+0x5ee>
    e5f8:	ldr	r3, [sp, #40]	; 0x28
    e5fa:	cbnz	r3, e642 <__ssvfscanf_r+0x60e>
    e5fc:	str.w	r3, [r9]
    e600:	add	r7, r6
    e602:	subs	r4, #1
    e604:	add.w	r9, r9, #4
    e608:	ldr.w	r3, [fp, #4]
    e60c:	cmp	r3, #0
    e60e:	mov.w	r5, #0
    e612:	ble.n	e630 <__ssvfscanf_r+0x5fc>
    e614:	cmp	r4, #0
    e616:	bne.n	e5be <__ssvfscanf_r+0x58a>
    e618:	ldr	r3, [sp, #40]	; 0x28
    e61a:	cmp	r3, #0
    e61c:	beq.w	e4f6 <__ssvfscanf_r+0x4c2>
    e620:	b.n	e4fc <__ssvfscanf_r+0x4c8>
    e622:	adds	r0, #2
    e624:	bne.n	e648 <__ssvfscanf_r+0x614>
    e626:	ldr.w	r3, [fp, #4]
    e62a:	cmp	r3, #0
    e62c:	mov	r5, r6
    e62e:	bgt.n	e5be <__ssvfscanf_r+0x58a>
    e630:	mov	r1, fp
    e632:	mov	r0, sl
    e634:	bl	11a6c <__ssrefill_r>
    e638:	cmp	r0, #0
    e63a:	beq.n	e614 <__ssvfscanf_r+0x5e0>
    e63c:	cmp	r5, #0
    e63e:	beq.n	e618 <__ssvfscanf_r+0x5e4>
    e640:	b.n	e27e <__ssvfscanf_r+0x24a>
    e642:	add	r7, r6
    e644:	subs	r4, #1
    e646:	b.n	e608 <__ssvfscanf_r+0x5d4>
    e648:	ldr	r3, [sp, #40]	; 0x28
    e64a:	add	r7, r6
    e64c:	subs	r4, #1
    e64e:	cmp	r3, #0
    e650:	bne.n	e608 <__ssvfscanf_r+0x5d4>
    e652:	b.n	e604 <__ssvfscanf_r+0x5d0>
    e654:	mov	r8, r5
    e656:	mov	r5, r8
    e658:	add	r7, r5
    e65a:	b.n	e572 <__ssvfscanf_r+0x53e>
    e65c:	cmp	r5, #0
    e65e:	beq.w	e0d0 <__ssvfscanf_r+0x9c>
    e662:	add	r7, r5
    e664:	b.n	e572 <__ssvfscanf_r+0x53e>
    e666:	cmp	r5, #0
    e668:	bne.w	e38e <__ssvfscanf_r+0x35a>
    e66c:	b.n	e27e <__ssvfscanf_r+0x24a>
    e66e:	ldr	r5, [sp, #20]
    e670:	mov	r3, r4
    e672:	ldr	r1, [r5, #0]
    e674:	str.w	fp, [sp]
    e678:	movs	r2, #1
    e67a:	mov	r0, sl
    e67c:	bl	11aa8 <_sfread_r>
    e680:	adds	r6, r5, #4
    e682:	cmp	r0, #0
    e684:	beq.w	e27e <__ssvfscanf_r+0x24a>
    e688:	ldr	r3, [sp, #24]
    e68a:	str	r6, [sp, #20]
    e68c:	ldr	r6, [sp, #12]
    e68e:	adds	r3, #1
    e690:	add	r7, r0
    e692:	str	r3, [sp, #24]
    e694:	mov	r4, r6
    e696:	b.n	e0c4 <__ssvfscanf_r+0x90>
    e698:	mov	r1, fp
    e69a:	mov	r0, sl
    e69c:	bl	11a6c <__ssrefill_r>
    e6a0:	cmp	r0, #0
    e6a2:	beq.w	e1f2 <__ssvfscanf_r+0x1be>
    e6a6:	b.n	e27e <__ssvfscanf_r+0x24a>
    e6a8:	mov.w	r9, #0
    e6ac:	b.n	e5b8 <__ssvfscanf_r+0x584>
    e6ae:	ldrb.w	r8, [r6, #2]
    e6b2:	orr.w	r5, r5, #2
    e6b6:	adds	r6, #2
    e6b8:	b.n	e0e6 <__ssvfscanf_r+0xb2>
    e6ba:	cmp	r3, #0
    e6bc:	orr.w	r5, r5, #1
    e6c0:	bgt.w	e40e <__ssvfscanf_r+0x3da>
    e6c4:	b.n	e484 <__ssvfscanf_r+0x450>
    e6c6:	lsls	r4, r5, #31
    e6c8:	bmi.n	e6e4 <__ssvfscanf_r+0x6b0>
    e6ca:	lsls	r0, r5, #30
    e6cc:	bpl.n	e6e4 <__ssvfscanf_r+0x6b0>
    e6ce:	ldr	r2, [sp, #20]
    e6d0:	ldr	r6, [sp, #12]
    e6d2:	ldr	r3, [r2, #0]
    e6d4:	mov	r0, r7
    e6d6:	asrs	r1, r7, #31
    e6d8:	adds	r2, #4
    e6da:	str	r2, [sp, #20]
    e6dc:	strd	r0, r1, [r3]
    e6e0:	mov	r4, r6
    e6e2:	b.n	e0c4 <__ssvfscanf_r+0x90>
    e6e4:	ldr	r2, [sp, #20]
    e6e6:	ldr	r6, [sp, #12]
    e6e8:	ldr	r3, [r2, #0]
    e6ea:	str	r7, [r3, #0]
    e6ec:	mov	r3, r2
    e6ee:	adds	r3, #4
    e6f0:	str	r3, [sp, #20]
    e6f2:	mov	r4, r6
    e6f4:	b.n	e0c4 <__ssvfscanf_r+0x90>
    e6f6:	mov	r1, fp
    e6f8:	mov	r0, sl
    e6fa:	bl	11a6c <__ssrefill_r>
    e6fe:	cmp	r0, #0
    e700:	bne.w	e27e <__ssvfscanf_r+0x24a>
    e704:	ldr	r3, [pc, #504]	; (e900 <__ssvfscanf_r+0x8cc>)
    e706:	str	r0, [sp, #16]
    e708:	str	r3, [sp, #28]
    e70a:	movs	r6, #3
    e70c:	b.n	e240 <__ssvfscanf_r+0x20c>
    e70e:	mov	r1, fp
    e710:	mov	r0, sl
    e712:	bl	11a6c <__ssrefill_r>
    e716:	cmp	r0, #0
    e718:	beq.w	e3ae <__ssvfscanf_r+0x37a>
    e71c:	b.n	e27e <__ssvfscanf_r+0x24a>
    e71e:	mov	r1, fp
    e720:	mov	r0, sl
    e722:	bl	11a6c <__ssrefill_r>
    e726:	cmp	r0, #0
    e728:	beq.w	e344 <__ssvfscanf_r+0x310>
    e72c:	b.n	e27e <__ssvfscanf_r+0x24a>
    e72e:	mov	r1, fp
    e730:	mov	r0, sl
    e732:	bl	11a6c <__ssrefill_r>
    e736:	cmp	r0, #0
    e738:	beq.w	e472 <__ssvfscanf_r+0x43e>
    e73c:	b.n	e27e <__ssvfscanf_r+0x24a>
    e73e:	mov	r1, fp
    e740:	mov	r0, sl
    e742:	bl	11a6c <__ssrefill_r>
    e746:	cmp	r0, #0
    e748:	beq.w	e2d6 <__ssvfscanf_r+0x2a2>
    e74c:	b.n	e27e <__ssvfscanf_r+0x24a>
    e74e:	mov	r1, fp
    e750:	mov	r0, sl
    e752:	bl	11a6c <__ssrefill_r>
    e756:	cmp	r0, #0
    e758:	beq.w	e2be <__ssvfscanf_r+0x28a>
    e75c:	b.n	e27e <__ssvfscanf_r+0x24a>
    e75e:	cmp	r6, #3
    e760:	beq.w	eaa2 <__ssvfscanf_r+0xa6e>
    e764:	cmp	r6, #4
    e766:	bne.w	ebe4 <__ssvfscanf_r+0xbb0>
    e76a:	mov	r0, sl
    e76c:	bl	109a8 <_localeconv_r>
    e770:	subs	r3, r4, #1
    e772:	ldr	r2, [r0, #0]
    e774:	str	r2, [sp, #48]	; 0x30
    e776:	cmp.w	r3, #348	; 0x15c
    e77a:	bls.w	ec4c <__ssvfscanf_r+0xc18>
    e77e:	mvn.w	r1, #348	; 0x15c
    e782:	adds	r3, r4, r1
    e784:	str	r3, [sp, #56]	; 0x38
    e786:	movw	r4, #349	; 0x15d
    e78a:	add	r3, sp, #336	; 0x150
    e78c:	mov.w	r8, #0
    e790:	mov	r2, r3
    e792:	str	r3, [sp, #40]	; 0x28
    e794:	orr.w	r5, r5, #1920	; 0x780
    e798:	mov	r3, r8
    e79a:	str.w	r8, [sp, #60]	; 0x3c
    e79e:	str.w	r8, [sp, #52]	; 0x34
    e7a2:	mov	r6, r8
    e7a4:	str.w	r8, [sp, #44]	; 0x2c
    e7a8:	mov	r9, r2
    e7aa:	ldr.w	r0, [fp]
    e7ae:	ldrb	r1, [r0, #0]
    e7b0:	sub.w	lr, r1, #43	; 0x2b
    e7b4:	cmp.w	lr, #78	; 0x4e
    e7b8:	bhi.w	ea52 <__ssvfscanf_r+0xa1e>
    e7bc:	tbh	[pc, lr, lsl #1]
    e7c0:	.word	0x0149007a
    e7c4:	.word	0x0149007a
    e7c8:	.word	0x006e0149
    e7cc:	.word	0x004f004f
    e7d0:	.word	0x004f004f
    e7d4:	.word	0x004f004f
    e7d8:	.word	0x004f004f
    e7dc:	.word	0x0149004f
    e7e0:	.word	0x01490149
    e7e4:	.word	0x01490149
    e7e8:	.word	0x01490149
    e7ec:	.word	0x01490144
    e7f0:	.word	0x01490149
    e7f4:	.word	0x0125012c
    e7f8:	.word	0x01490149
    e7fc:	.word	0x014900a2
    e800:	.word	0x01490149
    e804:	.word	0x008b0149
    e808:	.word	0x01490149
    e80c:	.word	0x01490149
    e810:	.word	0x00850149
    e814:	.word	0x01490149
    e818:	.word	0x01490149
    e81c:	.word	0x0149007f
    e820:	.word	0x01490149
    e824:	.word	0x01490149
    e828:	.word	0x01490149
    e82c:	.word	0x01490144
    e830:	.word	0x01490149
    e834:	.word	0x0125012c
    e838:	.word	0x01490149
    e83c:	.word	0x014900a2
    e840:	.word	0x01490149
    e844:	.word	0x008b0149
    e848:	.word	0x01490149
    e84c:	.word	0x01490149
    e850:	.word	0x00850149
    e854:	.word	0x01490149
    e858:	.word	0x01490149
    e85c:	.short	0x007f
    e85e:	cmn.w	r3, r8
    e862:	bne.n	e892 <__ssvfscanf_r+0x85e>
    e864:	bic.w	r5, r5, #384	; 0x180
    e868:	strb.w	r1, [r9]
    e86c:	add.w	r9, r9, #1
    e870:	ldr.w	r1, [fp, #4]
    e874:	subs	r1, #1
    e876:	cmp	r1, #0
    e878:	add.w	r4, r4, #4294967295
    e87c:	add.w	r7, r7, #1
    e880:	str.w	r1, [fp, #4]
    e884:	ble.w	ea6c <__ssvfscanf_r+0xa38>
    e888:	adds	r0, #1
    e88a:	str.w	r0, [fp]
    e88e:	cmp	r4, #0
    e890:	bne.n	e7aa <__ssvfscanf_r+0x776>
    e892:	cmp	r6, #0
    e894:	beq.n	e91c <__ssvfscanf_r+0x8e8>
    e896:	bic.w	r5, r5, #256	; 0x100
    e89a:	b.n	e91c <__ssvfscanf_r+0x8e8>
    e89c:	lsls	r2, r5, #23
    e89e:	bpl.n	e85e <__ssvfscanf_r+0x82a>
    e8a0:	ldr	r2, [sp, #56]	; 0x38
    e8a2:	bic.w	r5, r5, #128	; 0x80
    e8a6:	adds	r6, #1
    e8a8:	cmp	r2, #0
    e8aa:	beq.n	e870 <__ssvfscanf_r+0x83c>
    e8ac:	subs	r2, #1
    e8ae:	str	r2, [sp, #56]	; 0x38
    e8b0:	adds	r4, #1
    e8b2:	b.n	e870 <__ssvfscanf_r+0x83c>
    e8b4:	lsls	r2, r5, #24
    e8b6:	bpl.n	e892 <__ssvfscanf_r+0x85e>
    e8b8:	bic.w	r5, r5, #128	; 0x80
    e8bc:	b.n	e868 <__ssvfscanf_r+0x834>
    e8be:	cmp.w	r8, #7
    e8c2:	bne.n	e892 <__ssvfscanf_r+0x85e>
    e8c4:	mov.w	r8, #8
    e8c8:	b.n	e868 <__ssvfscanf_r+0x834>
    e8ca:	cmp.w	r8, #6
    e8ce:	bne.n	e892 <__ssvfscanf_r+0x85e>
    e8d0:	mov.w	r8, #7
    e8d4:	b.n	e868 <__ssvfscanf_r+0x834>
    e8d6:	cmp	r3, #0
    e8d8:	bne.w	ea98 <__ssvfscanf_r+0xa64>
    e8dc:	cbnz	r6, e8ea <__ssvfscanf_r+0x8b6>
    e8de:	and.w	lr, r5, #1792	; 0x700
    e8e2:	cmp.w	lr, #1792	; 0x700
    e8e6:	beq.w	ed70 <__ssvfscanf_r+0xd3c>
    e8ea:	cmp.w	r8, #1
    e8ee:	beq.n	e8f6 <__ssvfscanf_r+0x8c2>
    e8f0:	cmp.w	r8, #4
    e8f4:	bne.n	e892 <__ssvfscanf_r+0x85e>
    e8f6:	add.w	r8, r8, #1
    e8fa:	uxtb.w	r8, r8
    e8fe:	b.n	e868 <__ssvfscanf_r+0x834>
    e900:	.word	0x0000c929
    e904:	cmp.w	r8, #0
    e908:	bne.w	ea86 <__ssvfscanf_r+0xa52>
    e90c:	cmp	r6, #0
    e90e:	bne.n	e896 <__ssvfscanf_r+0x862>
    e910:	and.w	lr, r5, #1792	; 0x700
    e914:	cmp.w	lr, #1792	; 0x700
    e918:	beq.w	ed90 <__ssvfscanf_r+0xd5c>
    e91c:	subs	r3, #1
    e91e:	cmp	r3, #1
    e920:	bls.w	ee26 <__ssvfscanf_r+0xdf2>
    e924:	add.w	r3, r8, #4294967295
    e928:	cmp	r3, #6
    e92a:	bhi.n	e95a <__ssvfscanf_r+0x926>
    e92c:	cmp.w	r8, #2
    e930:	bls.w	ee74 <__ssvfscanf_r+0xe40>
    e934:	cmp.w	r8, #3
    e938:	beq.n	e95a <__ssvfscanf_r+0x926>
    e93a:	sub.w	r4, r8, #4
    e93e:	uxtb	r4, r4
    e940:	mvn.w	r8, r4
    e944:	add	r8, r9
    e946:	ldrb.w	r1, [r9, #-1]!
    e94a:	mov	r2, fp
    e94c:	mov	r0, sl
    e94e:	bl	119e8 <_sungetc_r>
    e952:	cmp	r8, r9
    e954:	bne.n	e946 <__ssvfscanf_r+0x912>
    e956:	subs	r7, #1
    e958:	subs	r7, r7, r4
    e95a:	lsls	r1, r5, #23
    e95c:	bpl.n	e998 <__ssvfscanf_r+0x964>
    e95e:	lsls	r2, r5, #21
    e960:	bmi.w	ee4a <__ssvfscanf_r+0xe16>
    e964:	ldrb.w	r1, [r9, #-1]
    e968:	cmp	r1, #101	; 0x65
    e96a:	add.w	r4, r9, #4294967295
    e96e:	add.w	r8, r7, #4294967295
    e972:	beq.n	e98c <__ssvfscanf_r+0x958>
    e974:	cmp	r1, #69	; 0x45
    e976:	beq.n	e98c <__ssvfscanf_r+0x958>
    e978:	mov	r2, fp
    e97a:	mov	r0, sl
    e97c:	bl	119e8 <_sungetc_r>
    e980:	ldrb.w	r1, [r9, #-2]
    e984:	sub.w	r8, r7, #2
    e988:	sub.w	r4, r9, #2
    e98c:	mov	r2, fp
    e98e:	mov	r0, sl
    e990:	bl	119e8 <_sungetc_r>
    e994:	mov	r7, r8
    e996:	mov	r9, r4
    e998:	ands.w	r2, r5, #16
    e99c:	bne.w	e4fc <__ssvfscanf_r+0x4c8>
    e9a0:	and.w	r3, r5, #1536	; 0x600
    e9a4:	cmp.w	r3, #1024	; 0x400
    e9a8:	strb.w	r2, [r9]
    e9ac:	beq.w	ed9a <__ssvfscanf_r+0xd66>
    e9b0:	ldr	r3, [sp, #52]	; 0x34
    e9b2:	cmp	r3, #0
    e9b4:	bne.w	edbc <__ssvfscanf_r+0xd88>
    e9b8:	ldr	r1, [sp, #40]	; 0x28
    e9ba:	movs	r2, #0
    e9bc:	mov	r0, sl
    e9be:	bl	c7d0 <_strtod_r>
    e9c2:	lsls	r3, r5, #31
    e9c4:	bmi.w	ec52 <__ssvfscanf_r+0xc1e>
    e9c8:	ands.w	r5, r5, #2
    e9cc:	bne.w	ec52 <__ssvfscanf_r+0xc1e>
    e9d0:	vmov	r2, r3, d0
    e9d4:	vmov	r0, r1, d0
    e9d8:	vstr	d0, [sp, #32]
    e9dc:	bl	a5a4 <__aeabi_dcmpun>
    e9e0:	ldr	r4, [sp, #20]
    e9e2:	vldr	d0, [sp, #32]
    e9e6:	adds	r6, r4, #4
    e9e8:	ldr	r4, [r4, #0]
    e9ea:	cmp	r0, #0
    e9ec:	bne.w	eea8 <__ssvfscanf_r+0xe74>
    e9f0:	vmov	r0, r1, d0
    e9f4:	bl	a660 <__aeabi_d2f>
    e9f8:	str	r6, [sp, #20]
    e9fa:	str	r0, [r4, #0]
    e9fc:	ldr	r3, [sp, #24]
    e9fe:	ldr	r6, [sp, #12]
    ea00:	adds	r3, #1
    ea02:	str	r3, [sp, #24]
    ea04:	mov	r4, r6
    ea06:	b.w	e0c4 <__ssvfscanf_r+0x90>
    ea0a:	cmp.w	r8, #2
    ea0e:	bne.w	e892 <__ssvfscanf_r+0x85e>
    ea12:	mov.w	r8, #3
    ea16:	b.n	e868 <__ssvfscanf_r+0x834>
    ea18:	and.w	lr, r5, #1280	; 0x500
    ea1c:	cmp.w	lr, #1024	; 0x400
    ea20:	beq.n	ea2e <__ssvfscanf_r+0x9fa>
    ea22:	lsls	r2, r5, #21
    ea24:	bpl.w	e892 <__ssvfscanf_r+0x85e>
    ea28:	cmp	r6, #0
    ea2a:	beq.w	e91c <__ssvfscanf_r+0x8e8>
    ea2e:	lsls	r2, r5, #22
    ea30:	bmi.n	ea3c <__ssvfscanf_r+0xa08>
    ea32:	ldr	r2, [sp, #44]	; 0x2c
    ea34:	str.w	r9, [sp, #60]	; 0x3c
    ea38:	subs	r2, r6, r2
    ea3a:	str	r2, [sp, #52]	; 0x34
    ea3c:	bic.w	r5, r5, #1920	; 0x780
    ea40:	orr.w	r5, r5, #384	; 0x180
    ea44:	movs	r6, #0
    ea46:	b.n	e868 <__ssvfscanf_r+0x834>
    ea48:	cmp	r3, #1
    ea4a:	bne.w	e892 <__ssvfscanf_r+0x85e>
    ea4e:	movs	r3, #2
    ea50:	b.n	e868 <__ssvfscanf_r+0x834>
    ea52:	ldr	r2, [sp, #48]	; 0x30
    ea54:	ldrb.w	lr, [r2]
    ea58:	cmp	lr, r1
    ea5a:	bne.w	e892 <__ssvfscanf_r+0x85e>
    ea5e:	lsls	r2, r5, #22
    ea60:	bpl.w	e892 <__ssvfscanf_r+0x85e>
    ea64:	bic.w	r5, r5, #640	; 0x280
    ea68:	str	r6, [sp, #44]	; 0x2c
    ea6a:	b.n	e868 <__ssvfscanf_r+0x834>
    ea6c:	mov	r1, fp
    ea6e:	mov	r0, sl
    ea70:	str	r3, [sp, #32]
    ea72:	bl	11a6c <__ssrefill_r>
    ea76:	ldr	r3, [sp, #32]
    ea78:	cmp	r0, #0
    ea7a:	bne.w	e892 <__ssvfscanf_r+0x85e>
    ea7e:	cmp	r4, #0
    ea80:	bne.w	e7aa <__ssvfscanf_r+0x776>
    ea84:	b.n	e892 <__ssvfscanf_r+0x85e>
    ea86:	cmp.w	r8, #3
    ea8a:	beq.w	e8f6 <__ssvfscanf_r+0x8c2>
    ea8e:	cmp.w	r8, #5
    ea92:	beq.w	e8f6 <__ssvfscanf_r+0x8c2>
    ea96:	b.n	e892 <__ssvfscanf_r+0x85e>
    ea98:	cmp	r3, #2
    ea9a:	bne.w	e8ea <__ssvfscanf_r+0x8b6>
    ea9e:	movs	r3, #3
    eaa0:	b.n	e868 <__ssvfscanf_r+0x834>
    eaa2:	subs	r3, r4, #1
    eaa4:	cmp.w	r3, #348	; 0x15c
    eaa8:	itte	hi
    eaaa:	mvnhi.w	r0, #348	; 0x15c
    eaae:	addhi.w	r9, r4, r0
    eab2:	movls	r9, r8
    eab4:	add	r3, sp, #336	; 0x150
    eab6:	mov	r0, r2
    eab8:	mov	r2, r7
    eaba:	mov	r7, r9
    eabc:	ldr.w	r9, [sp, #16]
    eac0:	str	r3, [sp, #40]	; 0x28
    eac2:	it	hi
    eac4:	movwhi	r4, #349	; 0x15d
    eac8:	orr.w	r5, r5, #3456	; 0xd80
    eacc:	mov	r6, r3
    eace:	mov.w	r8, #0
    ead2:	sub.w	r3, r1, #43	; 0x2b
    ead6:	cmp	r3, #77	; 0x4d
    ead8:	bhi.n	eb7e <__ssvfscanf_r+0xb4a>
    eada:	tbb	[pc, r3]
    eade:	.short	0x507e
    eae0:	.word	0x6f50507e
    eae4:	.word	0x69696969
    eae8:	.word	0x4a696969
    eaec:	.word	0x5050504a
    eaf0:	.word	0x50505050
    eaf4:	.word	0x44444444
    eaf8:	.word	0x50504444
    eafc:	.word	0x50505050
    eb00:	.word	0x50505050
    eb04:	.word	0x50505050
    eb08:	.word	0x27505050
    eb0c:	.word	0x50505050
    eb10:	.word	0x50505050
    eb14:	.word	0x44444444
    eb18:	.word	0x50504444
    eb1c:	.word	0x50505050
    eb20:	.word	0x50505050
    eb24:	.word	0x50505050
    eb28:	.word	0x27505050
    eb2c:	and.w	r3, r5, #1536	; 0x600
    eb30:	cmp.w	r3, #512	; 0x200
    eb34:	bne.n	eb7e <__ssvfscanf_r+0xb4a>
    eb36:	bic.w	r5, r5, #512	; 0x200
    eb3a:	orr.w	r5, r5, #1280	; 0x500
    eb3e:	mov.w	r9, #16
    eb42:	strb	r1, [r6, #0]
    eb44:	adds	r6, #1
    eb46:	ldr.w	r3, [fp, #4]
    eb4a:	subs	r3, #1
    eb4c:	cmp	r3, #0
    eb4e:	str.w	r3, [fp, #4]
    eb52:	ble.n	ec3a <__ssvfscanf_r+0xc06>
    eb54:	adds	r0, #1
    eb56:	str.w	r0, [fp]
    eb5a:	subs	r4, #1
    eb5c:	beq.n	eb7e <__ssvfscanf_r+0xb4a>
    eb5e:	ldr.w	r0, [fp]
    eb62:	ldrb	r1, [r0, #0]
    eb64:	b.n	ead2 <__ssvfscanf_r+0xa9e>
    eb66:	cmp.w	r9, #10
    eb6a:	ble.n	eb7e <__ssvfscanf_r+0xb4a>
    eb6c:	bic.w	r5, r5, #2944	; 0xb80
    eb70:	b.n	eb42 <__ssvfscanf_r+0xb0e>
    eb72:	ldr	r3, [pc, #756]	; (ee68 <__ssvfscanf_r+0xe34>)
    eb74:	ldrsh.w	r9, [r3, r9, lsl #1]
    eb78:	cmp.w	r9, #8
    eb7c:	bgt.n	eb6c <__ssvfscanf_r+0xb38>
    eb7e:	lsls	r1, r5, #23
    eb80:	mov	r7, r2
    eb82:	str.w	r9, [sp, #16]
    eb86:	bpl.n	eb98 <__ssvfscanf_r+0xb64>
    eb88:	ldr	r3, [sp, #40]	; 0x28
    eb8a:	cmp	r6, r3
    eb8c:	bhi.w	ed78 <__ssvfscanf_r+0xd44>
    eb90:	ldr	r3, [sp, #40]	; 0x28
    eb92:	cmp	r6, r3
    eb94:	beq.w	e0d0 <__ssvfscanf_r+0x9c>
    eb98:	ands.w	r4, r5, #16
    eb9c:	beq.w	ecc4 <__ssvfscanf_r+0xc90>
    eba0:	ldr	r3, [sp, #40]	; 0x28
    eba2:	subs	r6, r6, r3
    eba4:	add	r6, r8
    eba6:	add	r7, r6
    eba8:	ldr	r6, [sp, #12]
    ebaa:	mov	r4, r6
    ebac:	b.w	e0c4 <__ssvfscanf_r+0x90>
    ebb0:	ldr	r3, [pc, #692]	; (ee68 <__ssvfscanf_r+0xe34>)
    ebb2:	bic.w	r5, r5, #2944	; 0xb80
    ebb6:	ldrsh.w	r9, [r3, r9, lsl #1]
    ebba:	b.n	eb42 <__ssvfscanf_r+0xb0e>
    ebbc:	lsls	r3, r5, #20
    ebbe:	bpl.n	eb42 <__ssvfscanf_r+0xb0e>
    ebc0:	cmp.w	r9, #0
    ebc4:	bne.n	ebce <__ssvfscanf_r+0xb9a>
    ebc6:	orr.w	r5, r5, #512	; 0x200
    ebca:	mov.w	r9, #8
    ebce:	lsls	r3, r5, #21
    ebd0:	bpl.w	ed54 <__ssvfscanf_r+0xd20>
    ebd4:	bic.w	r5, r5, #1408	; 0x580
    ebd8:	b.n	eb42 <__ssvfscanf_r+0xb0e>
    ebda:	lsls	r3, r5, #24
    ebdc:	bpl.n	eb7e <__ssvfscanf_r+0xb4a>
    ebde:	bic.w	r5, r5, #128	; 0x80
    ebe2:	b.n	eb42 <__ssvfscanf_r+0xb0e>
    ebe4:	cmp	r4, #0
    ebe6:	it	eq
    ebe8:	moveq.w	r4, #4294967295
    ebec:	ands.w	r3, r5, #1
    ebf0:	bne.w	e4b0 <__ssvfscanf_r+0x47c>
    ebf4:	lsls	r1, r5, #27
    ebf6:	bpl.n	ec60 <__ssvfscanf_r+0xc2c>
    ebf8:	mov	r5, r3
    ebfa:	bl	aabc <__locale_ctype_ptr>
    ebfe:	ldr.w	r3, [fp]
    ec02:	ldrb	r2, [r3, #0]
    ec04:	add	r0, r2
    ec06:	adds	r3, #1
    ec08:	ldrb	r2, [r0, #1]
    ec0a:	lsls	r2, r2, #28
    ec0c:	bmi.w	e38e <__ssvfscanf_r+0x35a>
    ec10:	ldr.w	r2, [fp, #4]
    ec14:	str.w	r3, [fp]
    ec18:	adds	r5, #1
    ec1a:	subs	r3, r2, #1
    ec1c:	cmp	r4, r5
    ec1e:	str.w	r3, [fp, #4]
    ec22:	beq.w	e38e <__ssvfscanf_r+0x35a>
    ec26:	cmp	r3, #0
    ec28:	bgt.n	ebfa <__ssvfscanf_r+0xbc6>
    ec2a:	mov	r1, fp
    ec2c:	mov	r0, sl
    ec2e:	bl	11a6c <__ssrefill_r>
    ec32:	cmp	r0, #0
    ec34:	beq.n	ebfa <__ssvfscanf_r+0xbc6>
    ec36:	b.w	e38e <__ssvfscanf_r+0x35a>
    ec3a:	mov	r1, fp
    ec3c:	mov	r0, sl
    ec3e:	str	r2, [sp, #16]
    ec40:	bl	11a6c <__ssrefill_r>
    ec44:	ldr	r2, [sp, #16]
    ec46:	cmp	r0, #0
    ec48:	beq.n	eb5a <__ssvfscanf_r+0xb26>
    ec4a:	b.n	eb7e <__ssvfscanf_r+0xb4a>
    ec4c:	str.w	r8, [sp, #56]	; 0x38
    ec50:	b.n	e78a <__ssvfscanf_r+0x756>
    ec52:	ldr	r2, [sp, #20]
    ec54:	ldr	r3, [r2, #0]
    ec56:	adds	r2, #4
    ec58:	str	r2, [sp, #20]
    ec5a:	vstr	d0, [r3]
    ec5e:	b.n	e9fc <__ssvfscanf_r+0x9c8>
    ec60:	ldr	r2, [sp, #20]
    ec62:	ldr	r5, [r2, #0]
    ec64:	adds	r6, r2, #4
    ec66:	add	r4, r5
    ec68:	mov	r8, r5
    ec6a:	bl	aabc <__locale_ctype_ptr>
    ec6e:	ldr.w	r2, [fp]
    ec72:	ldrb	r3, [r2, #0]
    ec74:	add	r0, r3
    ec76:	adds	r1, r2, #1
    ec78:	ldrb	r3, [r0, #1]
    ec7a:	lsls	r3, r3, #28
    ec7c:	bmi.n	ecaa <__ssvfscanf_r+0xc76>
    ec7e:	ldr.w	r3, [fp, #4]
    ec82:	str.w	r1, [fp]
    ec86:	subs	r3, #1
    ec88:	str.w	r3, [fp, #4]
    ec8c:	ldrb	r3, [r2, #0]
    ec8e:	strb.w	r3, [r8], #1
    ec92:	cmp	r4, r8
    ec94:	beq.n	ecac <__ssvfscanf_r+0xc78>
    ec96:	ldr.w	r3, [fp, #4]
    ec9a:	cmp	r3, #0
    ec9c:	bgt.n	ec6a <__ssvfscanf_r+0xc36>
    ec9e:	mov	r1, fp
    eca0:	mov	r0, sl
    eca2:	bl	11a6c <__ssrefill_r>
    eca6:	cmp	r0, #0
    eca8:	beq.n	ec6a <__ssvfscanf_r+0xc36>
    ecaa:	mov	r4, r8
    ecac:	ldr	r2, [sp, #24]
    ecae:	str	r6, [sp, #20]
    ecb0:	ldr	r6, [sp, #12]
    ecb2:	subs	r5, r4, r5
    ecb4:	movs	r3, #0
    ecb6:	adds	r2, #1
    ecb8:	strb	r3, [r4, #0]
    ecba:	add	r7, r5
    ecbc:	str	r2, [sp, #24]
    ecbe:	mov	r4, r6
    ecc0:	b.w	e0c4 <__ssvfscanf_r+0x90>
    ecc4:	mov	r2, r4
    ecc6:	strb	r4, [r6, #0]
    ecc8:	ldr	r3, [sp, #16]
    ecca:	ldr	r1, [sp, #40]	; 0x28
    eccc:	ldr	r4, [sp, #28]
    ecce:	mov	r0, sl
    ecd0:	blx	r4
    ecd2:	lsls	r2, r5, #26
    ecd4:	bmi.n	ed64 <__ssvfscanf_r+0xd30>
    ecd6:	lsls	r3, r5, #29
    ecd8:	bpl.n	edd2 <__ssvfscanf_r+0xd9e>
    ecda:	ldr	r2, [sp, #20]
    ecdc:	ldr	r3, [r2, #0]
    ecde:	adds	r2, #4
    ece0:	str	r2, [sp, #20]
    ece2:	strh	r0, [r3, #0]
    ece4:	ldr	r3, [sp, #24]
    ece6:	adds	r3, #1
    ece8:	str	r3, [sp, #24]
    ecea:	b.n	eba0 <__ssvfscanf_r+0xb6c>
    ecec:	bl	aa98 <__locale_mb_cur_max>
    ecf0:	cmp	r6, r0
    ecf2:	beq.w	e27e <__ssvfscanf_r+0x24a>
    ecf6:	ldmia.w	fp, {r2, r3}
    ecfa:	ldrb.w	r0, [r2], #1
    ecfe:	str.w	r2, [fp]
    ed02:	ldr	r2, [sp, #32]
    ed04:	str	r2, [sp, #0]
    ed06:	add	r2, sp, #336	; 0x150
    ed08:	adds	r5, r6, #1
    ed0a:	subs	r3, #1
    ed0c:	strb	r0, [r2, r6]
    ed0e:	str.w	r3, [fp, #4]
    ed12:	mov	r1, r8
    ed14:	mov	r3, r5
    ed16:	mov	r0, sl
    ed18:	bl	109c4 <_mbrtowc_r>
    ed1c:	adds	r6, r0, #1
    ed1e:	beq.w	e27e <__ssvfscanf_r+0x24a>
    ed22:	cmp	r0, #0
    ed24:	bne.n	edfe <__ssvfscanf_r+0xdca>
    ed26:	str.w	r0, [r8]
    ed2a:	bl	10988 <iswspace>
    ed2e:	cmp	r0, #0
    ed30:	beq.w	ee92 <__ssvfscanf_r+0xe5e>
    ed34:	cmp	r5, #0
    ed36:	beq.w	e4ec <__ssvfscanf_r+0x4b8>
    ed3a:	add	r3, sp, #336	; 0x150
    ed3c:	adds	r4, r3, r5
    ed3e:	subs	r5, #1
    ed40:	mov	r2, fp
    ed42:	ldrb.w	r1, [r4, #-1]!
    ed46:	mov	r0, sl
    ed48:	bl	119e8 <_sungetc_r>
    ed4c:	cmp	r5, #0
    ed4e:	bne.n	ed3e <__ssvfscanf_r+0xd0a>
    ed50:	b.w	e4ec <__ssvfscanf_r+0x4b8>
    ed54:	bic.w	r5, r5, #896	; 0x380
    ed58:	cbz	r7, ed5e <__ssvfscanf_r+0xd2a>
    ed5a:	subs	r7, #1
    ed5c:	adds	r4, #1
    ed5e:	add.w	r8, r8, #1
    ed62:	b.n	eb46 <__ssvfscanf_r+0xb12>
    ed64:	ldr	r2, [sp, #20]
    ed66:	ldr	r3, [r2, #0]
    ed68:	adds	r2, #4
    ed6a:	str	r2, [sp, #20]
    ed6c:	str	r0, [r3, #0]
    ed6e:	b.n	ece4 <__ssvfscanf_r+0xcb0>
    ed70:	bic.w	r5, r5, #1920	; 0x780
    ed74:	movs	r3, #1
    ed76:	b.n	e868 <__ssvfscanf_r+0x834>
    ed78:	ldrb.w	r1, [r6, #-1]
    ed7c:	mov	r2, fp
    ed7e:	mov	r0, sl
    ed80:	bl	119e8 <_sungetc_r>
    ed84:	subs	r6, #1
    ed86:	b.n	eb90 <__ssvfscanf_r+0xb5c>
    ed88:	add.w	r8, sp, #68	; 0x44
    ed8c:	b.w	e4d2 <__ssvfscanf_r+0x49e>
    ed90:	bic.w	r5, r5, #1920	; 0x780
    ed94:	mov.w	r8, #1
    ed98:	b.n	e868 <__ssvfscanf_r+0x834>
    ed9a:	ldr	r3, [sp, #44]	; 0x2c
    ed9c:	subs	r6, r6, r3
    ed9e:	negs	r2, r6
    eda0:	cmp	r6, #0
    eda2:	beq.w	e9b8 <__ssvfscanf_r+0x984>
    eda6:	addw	r3, sp, #675	; 0x2a3
    edaa:	cmp	r9, r3
    edac:	it	cs
    edae:	addwcs	r9, sp, #674	; 0x2a2
    edb2:	mov	r0, r9
    edb4:	ldr	r1, [pc, #180]	; (ee6c <__ssvfscanf_r+0xe38>)
    edb6:	bl	b668 <sprintf>
    edba:	b.n	e9b8 <__ssvfscanf_r+0x984>
    edbc:	ldr	r4, [sp, #60]	; 0x3c
    edbe:	mov	r1, r4
    edc0:	movs	r3, #10
    edc2:	adds	r1, #1
    edc4:	mov	r0, sl
    edc6:	bl	c928 <_strtol_r>
    edca:	ldr	r3, [sp, #52]	; 0x34
    edcc:	mov	r9, r4
    edce:	subs	r2, r0, r3
    edd0:	b.n	eda6 <__ssvfscanf_r+0xd72>
    edd2:	ands.w	r2, r5, #1
    edd6:	bne.n	ed64 <__ssvfscanf_r+0xd30>
    edd8:	lsls	r4, r5, #30
    edda:	bpl.n	ed64 <__ssvfscanf_r+0xd30>
    eddc:	ldr	r3, [sp, #28]
    edde:	mov	r1, r3
    ede0:	ldr	r3, [pc, #140]	; (ee70 <__ssvfscanf_r+0xe3c>)
    ede2:	cmp	r1, r3
    ede4:	mov	r0, sl
    ede6:	ldr	r3, [sp, #16]
    ede8:	ldr	r1, [sp, #40]	; 0x28
    edea:	beq.n	eeb6 <__ssvfscanf_r+0xe82>
    edec:	bl	11528 <_strtoll_r>
    edf0:	ldr	r2, [sp, #20]
    edf2:	ldr	r3, [r2, #0]
    edf4:	adds	r2, #4
    edf6:	str	r2, [sp, #20]
    edf8:	strd	r0, r1, [r3]
    edfc:	b.n	ece4 <__ssvfscanf_r+0xcb0>
    edfe:	adds	r0, #2
    ee00:	bne.n	ee44 <__ssvfscanf_r+0xe10>
    ee02:	mov	r6, r5
    ee04:	ldr.w	r3, [fp, #4]
    ee08:	cmp	r3, #0
    ee0a:	bgt.w	e4d4 <__ssvfscanf_r+0x4a0>
    ee0e:	mov	r1, fp
    ee10:	mov	r0, sl
    ee12:	bl	11a6c <__ssrefill_r>
    ee16:	cmp	r0, #0
    ee18:	beq.w	e4d4 <__ssvfscanf_r+0x4a0>
    ee1c:	cmp	r6, #0
    ee1e:	bne.w	e27e <__ssvfscanf_r+0x24a>
    ee22:	b.w	e4ec <__ssvfscanf_r+0x4b8>
    ee26:	ldr	r3, [sp, #40]	; 0x28
    ee28:	cmp	r9, r3
    ee2a:	bls.w	e0d0 <__ssvfscanf_r+0x9c>
    ee2e:	ldrb.w	r1, [r9, #-1]!
    ee32:	mov	r2, fp
    ee34:	mov	r0, sl
    ee36:	bl	119e8 <_sungetc_r>
    ee3a:	ldr	r3, [sp, #40]	; 0x28
    ee3c:	cmp	r9, r3
    ee3e:	bne.n	ee2e <__ssvfscanf_r+0xdfa>
    ee40:	b.w	e0d0 <__ssvfscanf_r+0x9c>
    ee44:	ldr.w	r0, [r8]
    ee48:	b.n	ed2a <__ssvfscanf_r+0xcf6>
    ee4a:	ldr	r3, [sp, #40]	; 0x28
    ee4c:	cmp	r9, r3
    ee4e:	bls.w	e0d0 <__ssvfscanf_r+0x9c>
    ee52:	ldrb.w	r1, [r9, #-1]!
    ee56:	mov	r2, fp
    ee58:	mov	r0, sl
    ee5a:	bl	119e8 <_sungetc_r>
    ee5e:	ldr	r3, [sp, #40]	; 0x28
    ee60:	cmp	r9, r3
    ee62:	bne.n	ee52 <__ssvfscanf_r+0xe1e>
    ee64:	b.w	e0d0 <__ssvfscanf_r+0x9c>
    ee68:	.word	0x000129bc
    ee6c:	.word	0x000129e0
    ee70:	.word	0x000116b5
    ee74:	ldr	r3, [sp, #40]	; 0x28
    ee76:	cmp	r9, r3
    ee78:	bls.w	e0d0 <__ssvfscanf_r+0x9c>
    ee7c:	ldrb.w	r1, [r9, #-1]!
    ee80:	mov	r2, fp
    ee82:	mov	r0, sl
    ee84:	bl	119e8 <_sungetc_r>
    ee88:	ldr	r3, [sp, #40]	; 0x28
    ee8a:	cmp	r9, r3
    ee8c:	bne.n	ee7c <__ssvfscanf_r+0xe48>
    ee8e:	b.w	e0d0 <__ssvfscanf_r+0x9c>
    ee92:	add	r7, r5
    ee94:	subs	r4, #1
    ee96:	cmp.w	r9, #0
    ee9a:	bne.n	eea4 <__ssvfscanf_r+0xe70>
    ee9c:	add.w	r8, r8, #4
    eea0:	mov	r6, r9
    eea2:	b.n	ee04 <__ssvfscanf_r+0xdd0>
    eea4:	mov	r6, r0
    eea6:	b.n	ee04 <__ssvfscanf_r+0xdd0>
    eea8:	mov	r0, r5
    eeaa:	bl	9cd0 <nanf>
    eeae:	str	r6, [sp, #20]
    eeb0:	vstr	s0, [r4]
    eeb4:	b.n	e9fc <__ssvfscanf_r+0x9c8>
    eeb6:	bl	118c4 <_strtoull_r>
    eeba:	b.n	edf0 <__ssvfscanf_r+0xdbc>

0000eebc <_vdprintf_r>:
    eebc:	push	{r4, r5, r6, r7, lr}
    eebe:	sub.w	sp, sp, #532	; 0x214
    eec2:	add	r5, sp, #16
    eec4:	str	r3, [sp, #0]
    eec6:	mov	r7, r1
    eec8:	mov	r3, r2
    eeca:	mov.w	r4, #512	; 0x200
    eece:	add	r2, sp, #12
    eed0:	mov	r1, r5
    eed2:	str	r4, [sp, #12]
    eed4:	mov	r6, r0
    eed6:	bl	11ba4 <_vasnprintf_r>
    eeda:	cbz	r0, ef00 <_vdprintf_r+0x44>
    eedc:	mov	r4, r0
    eede:	mov	r2, r0
    eee0:	mov	r1, r7
    eee2:	ldr	r3, [sp, #12]
    eee4:	mov	r0, r6
    eee6:	bl	ef3c <_write_r>
    eeea:	cmp	r4, r5
    eeec:	str	r0, [sp, #12]
    eeee:	beq.n	eefa <_vdprintf_r+0x3e>
    eef0:	mov	r0, r6
    eef2:	mov	r1, r4
    eef4:	bl	10050 <_free_r>
    eef8:	ldr	r0, [sp, #12]
    eefa:	add.w	sp, sp, #532	; 0x214
    eefe:	pop	{r4, r5, r6, r7, pc}
    ef00:	mov.w	r0, #4294967295
    ef04:	b.n	eefa <_vdprintf_r+0x3e>
    ef06:	nop

0000ef08 <vdprintf>:
    ef08:	push	{r4}
    ef0a:	ldr	r4, [pc, #16]	; (ef1c <vdprintf+0x14>)
    ef0c:	mov	r3, r2
    ef0e:	mov	r2, r1
    ef10:	mov	r1, r0
    ef12:	ldr	r0, [r4, #0]
    ef14:	ldr.w	r4, [sp], #4
    ef18:	b.w	eebc <_vdprintf_r>
    ef1c:	.word	0x1fff1840

0000ef20 <__ascii_wctomb>:
    ef20:	cbz	r1, ef2c <__ascii_wctomb+0xc>
    ef22:	cmp	r2, #255	; 0xff
    ef24:	bhi.n	ef30 <__ascii_wctomb+0x10>
    ef26:	strb	r2, [r1, #0]
    ef28:	movs	r0, #1
    ef2a:	bx	lr
    ef2c:	mov	r0, r1
    ef2e:	bx	lr
    ef30:	movs	r3, #138	; 0x8a
    ef32:	str	r3, [r0, #0]
    ef34:	mov.w	r0, #4294967295
    ef38:	bx	lr
    ef3a:	nop

0000ef3c <_write_r>:
    ef3c:	push	{r4, r5, r6, lr}
    ef3e:	mov	r5, r1
    ef40:	ldr	r4, [pc, #32]	; (ef64 <_write_r+0x28>)
    ef42:	mov	r1, r2
    ef44:	mov	r6, r0
    ef46:	mov	r2, r3
    ef48:	mov	r0, r5
    ef4a:	movs	r3, #0
    ef4c:	str	r3, [r4, #0]
    ef4e:	bl	21c4 <_write>
    ef52:	adds	r3, r0, #1
    ef54:	beq.n	ef58 <_write_r+0x1c>
    ef56:	pop	{r4, r5, r6, pc}
    ef58:	ldr	r3, [r4, #0]
    ef5a:	cmp	r3, #0
    ef5c:	beq.n	ef56 <_write_r+0x1a>
    ef5e:	str	r3, [r6, #0]
    ef60:	pop	{r4, r5, r6, pc}
    ef62:	nop
    ef64:	.word	0x1fff85ec

0000ef68 <__register_exitproc>:
    ef68:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ef6c:	ldr	r4, [pc, #148]	; (f004 <__register_exitproc+0x9c>)
    ef6e:	ldr	r5, [r4, #0]
    ef70:	ldr.w	r4, [r5, #328]	; 0x148
    ef74:	mov	r6, r0
    ef76:	mov	r8, r1
    ef78:	mov	sl, r2
    ef7a:	mov	r9, r3
    ef7c:	cbz	r4, eff0 <__register_exitproc+0x88>
    ef7e:	ldr	r0, [r4, #4]
    ef80:	cmp	r0, #31
    ef82:	bgt.n	efb4 <__register_exitproc+0x4c>
    ef84:	adds	r3, r0, #1
    ef86:	cbz	r6, efa6 <__register_exitproc+0x3e>
    ef88:	add.w	r5, r4, r0, lsl #2
    ef8c:	movs	r2, #1
    ef8e:	str.w	sl, [r5, #136]	; 0x88
    ef92:	ldr.w	r1, [r4, #392]	; 0x188
    ef96:	lsls	r2, r0
    ef98:	orrs	r1, r2
    ef9a:	cmp	r6, #2
    ef9c:	str.w	r1, [r4, #392]	; 0x188
    efa0:	str.w	r9, [r5, #264]	; 0x108
    efa4:	beq.n	efe4 <__register_exitproc+0x7c>
    efa6:	adds	r0, #2
    efa8:	str	r3, [r4, #4]
    efaa:	str.w	r8, [r4, r0, lsl #2]
    efae:	movs	r0, #0
    efb0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    efb4:	ldr	r3, [pc, #80]	; (f008 <__register_exitproc+0xa0>)
    efb6:	cbz	r3, effa <__register_exitproc+0x92>
    efb8:	mov.w	r0, #400	; 0x190
    efbc:	bl	aad0 <malloc>
    efc0:	mov	r4, r0
    efc2:	cbz	r0, effa <__register_exitproc+0x92>
    efc4:	ldr.w	r3, [r5, #328]	; 0x148
    efc8:	movs	r7, #0
    efca:	stmia.w	r0, {r3, r7}
    efce:	str.w	r4, [r5, #328]	; 0x148
    efd2:	mov	r0, r7
    efd4:	movs	r3, #1
    efd6:	str.w	r7, [r4, #392]	; 0x188
    efda:	str.w	r7, [r4, #396]	; 0x18c
    efde:	cmp	r6, #0
    efe0:	beq.n	efa6 <__register_exitproc+0x3e>
    efe2:	b.n	ef88 <__register_exitproc+0x20>
    efe4:	ldr.w	r1, [r4, #396]	; 0x18c
    efe8:	orrs	r2, r1
    efea:	str.w	r2, [r4, #396]	; 0x18c
    efee:	b.n	efa6 <__register_exitproc+0x3e>
    eff0:	add.w	r4, r5, #332	; 0x14c
    eff4:	str.w	r4, [r5, #328]	; 0x148
    eff8:	b.n	ef7e <__register_exitproc+0x16>
    effa:	mov.w	r0, #4294967295
    effe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f002:	nop
    f004:	.word	0x000128e4
    f008:	.word	0x0000aad1

0000f00c <register_fini>:
    f00c:	ldr	r3, [pc, #8]	; (f018 <register_fini+0xc>)
    f00e:	cbz	r3, f016 <register_fini+0xa>
    f010:	ldr	r0, [pc, #8]	; (f01c <register_fini+0x10>)
    f012:	b.w	f020 <atexit>
    f016:	bx	lr
    f018:	.word	0x00000000
    f01c:	.word	0x0000ff8d

0000f020 <atexit>:
    f020:	movs	r3, #0
    f022:	mov	r1, r0
    f024:	mov	r2, r3
    f026:	mov	r0, r3
    f028:	b.w	ef68 <__register_exitproc>

0000f02c <quorem>:
    f02c:	ldr	r2, [r0, #16]
    f02e:	ldr	r3, [r1, #16]
    f030:	cmp	r3, r2
    f032:	bgt.w	f150 <quorem+0x124>
    f036:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f03a:	add.w	r8, r3, #4294967295
    f03e:	add.w	r7, r1, #20
    f042:	add.w	fp, r0, #20
    f046:	ldr.w	r2, [r7, r8, lsl #2]
    f04a:	ldr.w	r3, [fp, r8, lsl #2]
    f04e:	mov.w	r4, r8, lsl #2
    f052:	sub	sp, #12
    f054:	adds	r2, #1
    f056:	udiv	r9, r3, r2
    f05a:	add.w	r3, fp, r4
    f05e:	str	r4, [sp, #0]
    f060:	add.w	sl, r7, r4
    f064:	str	r3, [sp, #4]
    f066:	cmp.w	r9, #0
    f06a:	beq.n	f0e0 <quorem+0xb4>
    f06c:	movs	r5, #0
    f06e:	mov	ip, r7
    f070:	mov	lr, fp
    f072:	mov	r3, r5
    f074:	ldr.w	r6, [ip], #4
    f078:	ldr.w	r2, [lr]
    f07c:	uxth	r4, r6
    f07e:	mla	r5, r9, r4, r5
    f082:	lsrs	r6, r6, #16
    f084:	lsrs	r4, r5, #16
    f086:	mla	r4, r9, r6, r4
    f08a:	uxth	r5, r5
    f08c:	subs	r3, r3, r5
    f08e:	uxth	r6, r4
    f090:	uxtah	r3, r3, r2
    f094:	rsb	r6, r6, r2, lsr #16
    f098:	add.w	r6, r6, r3, asr #16
    f09c:	uxth	r3, r3
    f09e:	orr.w	r3, r3, r6, lsl #16
    f0a2:	cmp	sl, ip
    f0a4:	str.w	r3, [lr], #4
    f0a8:	mov.w	r5, r4, lsr #16
    f0ac:	mov.w	r3, r6, asr #16
    f0b0:	bcs.n	f074 <quorem+0x48>
    f0b2:	ldr	r3, [sp, #0]
    f0b4:	ldr.w	r3, [fp, r3]
    f0b8:	cbnz	r3, f0e0 <quorem+0xb4>
    f0ba:	ldr	r4, [sp, #4]
    f0bc:	subs	r3, r4, #4
    f0be:	cmp	fp, r3
    f0c0:	bcs.n	f0dc <quorem+0xb0>
    f0c2:	ldr.w	r3, [r4, #-4]
    f0c6:	cbnz	r3, f0dc <quorem+0xb0>
    f0c8:	sub.w	r3, r4, #8
    f0cc:	b.n	f0d4 <quorem+0xa8>
    f0ce:	ldr	r2, [r3, #0]
    f0d0:	subs	r3, #4
    f0d2:	cbnz	r2, f0dc <quorem+0xb0>
    f0d4:	cmp	fp, r3
    f0d6:	add.w	r8, r8, #4294967295
    f0da:	bcc.n	f0ce <quorem+0xa2>
    f0dc:	str.w	r8, [r0, #16]
    f0e0:	mov	r4, r0
    f0e2:	bl	10ec8 <__mcmp>
    f0e6:	cmp	r0, #0
    f0e8:	blt.n	f148 <quorem+0x11c>
    f0ea:	add.w	r9, r9, #1
    f0ee:	mov	r5, fp
    f0f0:	movs	r3, #0
    f0f2:	ldr.w	r1, [r7], #4
    f0f6:	ldr	r0, [r5, #0]
    f0f8:	uxth	r2, r1
    f0fa:	subs	r2, r3, r2
    f0fc:	lsrs	r1, r1, #16
    f0fe:	uxtah	r2, r2, r0
    f102:	rsb	r3, r1, r0, lsr #16
    f106:	add.w	r3, r3, r2, asr #16
    f10a:	uxth	r1, r2
    f10c:	orr.w	r1, r1, r3, lsl #16
    f110:	cmp	sl, r7
    f112:	str.w	r1, [r5], #4
    f116:	mov.w	r3, r3, asr #16
    f11a:	bcs.n	f0f2 <quorem+0xc6>
    f11c:	ldr.w	r2, [fp, r8, lsl #2]
    f120:	add.w	r3, fp, r8, lsl #2
    f124:	cbnz	r2, f148 <quorem+0x11c>
    f126:	subs	r2, r3, #4
    f128:	cmp	fp, r2
    f12a:	bcs.n	f144 <quorem+0x118>
    f12c:	ldr.w	r2, [r3, #-4]
    f130:	cbnz	r2, f144 <quorem+0x118>
    f132:	subs	r3, #8
    f134:	b.n	f13c <quorem+0x110>
    f136:	ldr	r2, [r3, #0]
    f138:	subs	r3, #4
    f13a:	cbnz	r2, f144 <quorem+0x118>
    f13c:	cmp	fp, r3
    f13e:	add.w	r8, r8, #4294967295
    f142:	bcc.n	f136 <quorem+0x10a>
    f144:	str.w	r8, [r4, #16]
    f148:	mov	r0, r9
    f14a:	add	sp, #12
    f14c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f150:	movs	r0, #0
    f152:	bx	lr
    f154:			; <UNDEFINED> instruction: 0xffffffff

0000f158 <_dtoa_r>:
    f158:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f15c:	vmov	r6, r7, d0
    f160:	sub	sp, #108	; 0x6c
    f162:	ldr	r4, [r0, #64]	; 0x40
    f164:	ldr	r5, [sp, #144]	; 0x90
    f166:	str	r1, [sp, #0]
    f168:	mov	r9, r0
    f16a:	str	r2, [sp, #20]
    f16c:	str	r3, [sp, #12]
    f16e:	vmov	sl, s0
    f172:	mov	fp, r7
    f174:	cbz	r4, f18c <_dtoa_r+0x34>
    f176:	ldr	r2, [r0, #68]	; 0x44
    f178:	str	r2, [r4, #4]
    f17a:	movs	r3, #1
    f17c:	lsls	r3, r2
    f17e:	str	r3, [r4, #8]
    f180:	mov	r1, r4
    f182:	bl	10a6c <_Bfree>
    f186:	movs	r3, #0
    f188:	str.w	r3, [r9, #64]	; 0x40
    f18c:	cmp.w	fp, #0
    f190:	mov	r4, fp
    f192:	blt.n	f1fe <_dtoa_r+0xa6>
    f194:	movs	r3, #0
    f196:	str	r3, [r5, #0]
    f198:	ldr	r3, [pc, #644]	; (f420 <_dtoa_r+0x2c8>)
    f19a:	mov	r2, r3
    f19c:	ands	r3, r4
    f19e:	cmp	r3, r2
    f1a0:	beq.n	f1d0 <_dtoa_r+0x78>
    f1a2:	movs	r2, #0
    f1a4:	movs	r3, #0
    f1a6:	mov	r0, sl
    f1a8:	mov	r1, fp
    f1aa:	bl	a540 <__aeabi_dcmpeq>
    f1ae:	mov	r6, sl
    f1b0:	mov	r7, fp
    f1b2:	mov	r8, r0
    f1b4:	cbz	r0, f20a <_dtoa_r+0xb2>
    f1b6:	ldr	r2, [sp, #12]
    f1b8:	movs	r3, #1
    f1ba:	str	r3, [r2, #0]
    f1bc:	ldr	r3, [sp, #148]	; 0x94
    f1be:	cmp	r3, #0
    f1c0:	beq.w	f340 <_dtoa_r+0x1e8>
    f1c4:	ldr	r0, [pc, #604]	; (f424 <_dtoa_r+0x2cc>)
    f1c6:	str	r0, [r3, #0]
    f1c8:	subs	r0, #1
    f1ca:	add	sp, #108	; 0x6c
    f1cc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f1d0:	ldr	r2, [sp, #12]
    f1d2:	movw	r3, #9999	; 0x270f
    f1d6:	str	r3, [r2, #0]
    f1d8:	cmp.w	sl, #0
    f1dc:	beq.w	f314 <_dtoa_r+0x1bc>
    f1e0:	ldr	r0, [pc, #580]	; (f428 <_dtoa_r+0x2d0>)
    f1e2:	ldr	r3, [sp, #148]	; 0x94
    f1e4:	cmp	r3, #0
    f1e6:	beq.n	f1ca <_dtoa_r+0x72>
    f1e8:	ldrb	r3, [r0, #3]
    f1ea:	cmp	r3, #0
    f1ec:	beq.w	f344 <_dtoa_r+0x1ec>
    f1f0:	add.w	r3, r0, #8
    f1f4:	ldr	r2, [sp, #148]	; 0x94
    f1f6:	str	r3, [r2, #0]
    f1f8:	add	sp, #108	; 0x6c
    f1fa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f1fe:	movs	r3, #1
    f200:	bic.w	r4, fp, #2147483648	; 0x80000000
    f204:	str	r3, [r5, #0]
    f206:	mov	fp, r4
    f208:	b.n	f198 <_dtoa_r+0x40>
    f20a:	add	r2, sp, #96	; 0x60
    f20c:	add	r1, sp, #100	; 0x64
    f20e:	vmov	d0, r6, r7
    f212:	mov	r0, r9
    f214:	bl	11144 <__d2b>
    f218:	lsrs	r5, r4, #20
    f21a:	str	r0, [sp, #40]	; 0x28
    f21c:	bne.w	f326 <_dtoa_r+0x1ce>
    f220:	ldr	r5, [sp, #96]	; 0x60
    f222:	ldr	r6, [sp, #100]	; 0x64
    f224:	add	r6, r5
    f226:	addw	r3, r6, #1074	; 0x432
    f22a:	cmp	r3, #32
    f22c:	ble.w	f740 <_dtoa_r+0x5e8>
    f230:	rsb	r3, r3, #64	; 0x40
    f234:	addw	r0, r6, #1042	; 0x412
    f238:	lsls	r4, r3
    f23a:	lsr.w	r0, sl, r0
    f23e:	orrs	r0, r4
    f240:	bl	9f84 <__aeabi_ui2d>
    f244:	movs	r3, #1
    f246:	subs	r4, r6, #1
    f248:	sub.w	r1, r1, #32505856	; 0x1f00000
    f24c:	str	r3, [sp, #60]	; 0x3c
    f24e:	movs	r2, #0
    f250:	ldr	r3, [pc, #472]	; (f42c <_dtoa_r+0x2d4>)
    f252:	bl	9d08 <__aeabi_dsub>
    f256:	add	r3, pc, #432	; (adr r3, f408 <_dtoa_r+0x2b0>)
    f258:	ldrd	r2, r3, [r3]
    f25c:	bl	a070 <__aeabi_dmul>
    f260:	add	r3, pc, #428	; (adr r3, f410 <_dtoa_r+0x2b8>)
    f262:	ldrd	r2, r3, [r3]
    f266:	bl	9d0c <__adddf3>
    f26a:	mov	r6, r0
    f26c:	mov	r0, r4
    f26e:	mov	r7, r1
    f270:	bl	9fa4 <__aeabi_i2d>
    f274:	add	r3, pc, #416	; (adr r3, f418 <_dtoa_r+0x2c0>)
    f276:	ldrd	r2, r3, [r3]
    f27a:	bl	a070 <__aeabi_dmul>
    f27e:	mov	r2, r0
    f280:	mov	r3, r1
    f282:	mov	r0, r6
    f284:	mov	r1, r7
    f286:	bl	9d0c <__adddf3>
    f28a:	mov	r6, r0
    f28c:	mov	r7, r1
    f28e:	bl	a5d0 <__aeabi_d2iz>
    f292:	movs	r2, #0
    f294:	str	r0, [sp, #16]
    f296:	movs	r3, #0
    f298:	mov	r0, r6
    f29a:	mov	r1, r7
    f29c:	bl	a554 <__aeabi_dcmplt>
    f2a0:	cmp	r0, #0
    f2a2:	bne.w	f6f6 <_dtoa_r+0x59e>
    f2a6:	ldr	r6, [sp, #16]
    f2a8:	cmp	r6, #22
    f2aa:	bhi.w	f6f0 <_dtoa_r+0x598>
    f2ae:	ldr	r3, [pc, #384]	; (f430 <_dtoa_r+0x2d8>)
    f2b0:	add.w	r3, r3, r6, lsl #3
    f2b4:	ldrd	r0, r1, [r3]
    f2b8:	mov	r2, sl
    f2ba:	mov	r3, fp
    f2bc:	bl	a590 <__aeabi_dcmpgt>
    f2c0:	cmp	r0, #0
    f2c2:	beq.w	f74a <_dtoa_r+0x5f2>
    f2c6:	subs	r3, r6, #1
    f2c8:	str	r3, [sp, #16]
    f2ca:	movs	r3, #0
    f2cc:	str	r3, [sp, #52]	; 0x34
    f2ce:	subs	r5, r5, r4
    f2d0:	subs.w	r8, r5, #1
    f2d4:	bmi.w	f72c <_dtoa_r+0x5d4>
    f2d8:	movs	r3, #0
    f2da:	str	r3, [sp, #28]
    f2dc:	ldr	r3, [sp, #16]
    f2de:	cmp	r3, #0
    f2e0:	blt.w	f71a <_dtoa_r+0x5c2>
    f2e4:	add	r8, r3
    f2e6:	str	r3, [sp, #48]	; 0x30
    f2e8:	movs	r3, #0
    f2ea:	str	r3, [sp, #24]
    f2ec:	ldr	r3, [sp, #0]
    f2ee:	cmp	r3, #9
    f2f0:	bhi.n	f348 <_dtoa_r+0x1f0>
    f2f2:	cmp	r3, #5
    f2f4:	ble.w	ff80 <_dtoa_r+0xe28>
    f2f8:	subs	r3, #4
    f2fa:	str	r3, [sp, #0]
    f2fc:	movs	r6, #0
    f2fe:	ldr	r3, [sp, #0]
    f300:	subs	r3, #2
    f302:	cmp	r3, #3
    f304:	bhi.w	ff4e <_dtoa_r+0xdf6>
    f308:	tbh	[pc, r3, lsl #1]
    f30c:	.word	0x0224032b
    f310:	.word	0x04500336
    f314:	ldr	r3, [pc, #272]	; (f428 <_dtoa_r+0x2d0>)
    f316:	ldr	r2, [pc, #284]	; (f434 <_dtoa_r+0x2dc>)
    f318:	ubfx	r0, r4, #0, #20
    f31c:	cmp	r0, #0
    f31e:	ite	ne
    f320:	movne	r0, r3
    f322:	moveq	r0, r2
    f324:	b.n	f1e2 <_dtoa_r+0x8a>
    f326:	ubfx	r3, fp, #0, #20
    f32a:	orr.w	r1, r3, #1069547520	; 0x3fc00000
    f32e:	subw	r4, r5, #1023	; 0x3ff
    f332:	mov	r0, sl
    f334:	str.w	r8, [sp, #60]	; 0x3c
    f338:	orr.w	r1, r1, #3145728	; 0x300000
    f33c:	ldr	r5, [sp, #96]	; 0x60
    f33e:	b.n	f24e <_dtoa_r+0xf6>
    f340:	ldr	r0, [pc, #244]	; (f438 <_dtoa_r+0x2e0>)
    f342:	b.n	f1ca <_dtoa_r+0x72>
    f344:	adds	r3, r0, #3
    f346:	b.n	f1f4 <_dtoa_r+0x9c>
    f348:	movs	r1, #0
    f34a:	str.w	r1, [r9, #68]	; 0x44
    f34e:	mov	r0, r9
    f350:	mov	r4, r1
    f352:	str	r1, [sp, #0]
    f354:	bl	10a20 <_Balloc>
    f358:	mov.w	r3, #4294967295
    f35c:	str	r3, [sp, #32]
    f35e:	str	r3, [sp, #56]	; 0x38
    f360:	movs	r3, #1
    f362:	str	r0, [sp, #36]	; 0x24
    f364:	str.w	r0, [r9, #64]	; 0x40
    f368:	str	r4, [sp, #20]
    f36a:	str	r3, [sp, #44]	; 0x2c
    f36c:	ldr	r3, [sp, #100]	; 0x64
    f36e:	cmp	r3, #0
    f370:	blt.w	f514 <_dtoa_r+0x3bc>
    f374:	ldr	r2, [sp, #16]
    f376:	cmp	r2, #14
    f378:	bgt.w	f514 <_dtoa_r+0x3bc>
    f37c:	ldr	r3, [pc, #176]	; (f430 <_dtoa_r+0x2d8>)
    f37e:	add.w	r3, r3, r2, lsl #3
    f382:	vldr	d7, [r3]
    f386:	ldr	r3, [sp, #20]
    f388:	cmp	r3, #0
    f38a:	vstr	d7, [sp]
    f38e:	blt.w	f98e <_dtoa_r+0x836>
    f392:	mov	r6, sl
    f394:	mov	r7, fp
    f396:	ldrd	sl, fp, [sp]
    f39a:	mov	r0, r6
    f39c:	mov	r2, sl
    f39e:	mov	r3, fp
    f3a0:	mov	r1, r7
    f3a2:	bl	a2c4 <__aeabi_ddiv>
    f3a6:	bl	a5d0 <__aeabi_d2iz>
    f3aa:	mov	r4, r0
    f3ac:	bl	9fa4 <__aeabi_i2d>
    f3b0:	mov	r2, sl
    f3b2:	mov	r3, fp
    f3b4:	bl	a070 <__aeabi_dmul>
    f3b8:	mov	r3, r1
    f3ba:	mov	r2, r0
    f3bc:	mov	r1, r7
    f3be:	mov	r0, r6
    f3c0:	bl	9d08 <__aeabi_dsub>
    f3c4:	ldr	r5, [sp, #36]	; 0x24
    f3c6:	add.w	r3, r4, #48	; 0x30
    f3ca:	strb	r3, [r5, #0]
    f3cc:	ldr	r3, [sp, #32]
    f3ce:	cmp	r3, #1
    f3d0:	mov	r6, r0
    f3d2:	mov	r7, r1
    f3d4:	add.w	r5, r5, #1
    f3d8:	beq.n	f49e <_dtoa_r+0x346>
    f3da:	movs	r2, #0
    f3dc:	ldr	r3, [pc, #92]	; (f43c <_dtoa_r+0x2e4>)
    f3de:	bl	a070 <__aeabi_dmul>
    f3e2:	movs	r2, #0
    f3e4:	movs	r3, #0
    f3e6:	mov	r6, r0
    f3e8:	mov	r7, r1
    f3ea:	bl	a540 <__aeabi_dcmpeq>
    f3ee:	cmp	r0, #0
    f3f0:	bne.n	f4ee <_dtoa_r+0x396>
    f3f2:	str.w	r9, [sp, #20]
    f3f6:	ldr.w	sl, [sp, #32]
    f3fa:	ldr.w	fp, [sp, #36]	; 0x24
    f3fe:	ldrd	r8, r9, [sp]
    f402:	b.n	f456 <_dtoa_r+0x2fe>
    f404:	nop.w
    f408:	.word	0x636f4361
    f40c:	.word	0x3fd287a7
    f410:	.word	0x8b60c8b3
    f414:	.word	0x3fc68a28
    f418:	.word	0x509f79fb
    f41c:	.word	0x3fd34413
    f420:	.word	0x7ff00000
    f424:	.word	0x000129a9
    f428:	.word	0x00012af8
    f42c:	.word	0x3ff80000
    f430:	.word	0x00012c00
    f434:	.word	0x00012aec
    f438:	.word	0x000129a8
    f43c:	.word	0x40240000
    f440:	bl	a070 <__aeabi_dmul>
    f444:	movs	r2, #0
    f446:	movs	r3, #0
    f448:	mov	r6, r0
    f44a:	mov	r7, r1
    f44c:	bl	a540 <__aeabi_dcmpeq>
    f450:	cmp	r0, #0
    f452:	bne.w	fbb2 <_dtoa_r+0xa5a>
    f456:	mov	r2, r8
    f458:	mov	r3, r9
    f45a:	mov	r0, r6
    f45c:	mov	r1, r7
    f45e:	bl	a2c4 <__aeabi_ddiv>
    f462:	bl	a5d0 <__aeabi_d2iz>
    f466:	mov	r4, r0
    f468:	bl	9fa4 <__aeabi_i2d>
    f46c:	mov	r2, r8
    f46e:	mov	r3, r9
    f470:	bl	a070 <__aeabi_dmul>
    f474:	mov	r2, r0
    f476:	mov	r3, r1
    f478:	mov	r0, r6
    f47a:	mov	r1, r7
    f47c:	bl	9d08 <__aeabi_dsub>
    f480:	add.w	lr, r4, #48	; 0x30
    f484:	strb.w	lr, [r5], #1
    f488:	rsb	lr, fp, r5
    f48c:	cmp	lr, sl
    f48e:	mov	r6, r0
    f490:	mov	r7, r1
    f492:	mov.w	r2, #0
    f496:	ldr	r3, [pc, #696]	; (f750 <_dtoa_r+0x5f8>)
    f498:	bne.n	f440 <_dtoa_r+0x2e8>
    f49a:	ldr.w	r9, [sp, #20]
    f49e:	mov	r2, r6
    f4a0:	mov	r3, r7
    f4a2:	mov	r0, r6
    f4a4:	mov	r1, r7
    f4a6:	bl	9d0c <__adddf3>
    f4aa:	mov	r6, r0
    f4ac:	mov	r7, r1
    f4ae:	mov	r2, r0
    f4b0:	mov	r3, r1
    f4b2:	ldrd	r0, r1, [sp]
    f4b6:	bl	a554 <__aeabi_dcmplt>
    f4ba:	cbnz	r0, f4ce <_dtoa_r+0x376>
    f4bc:	mov	r2, r6
    f4be:	mov	r3, r7
    f4c0:	ldrd	r0, r1, [sp]
    f4c4:	bl	a540 <__aeabi_dcmpeq>
    f4c8:	cbz	r0, f4ee <_dtoa_r+0x396>
    f4ca:	lsls	r3, r4, #31
    f4cc:	bpl.n	f4ee <_dtoa_r+0x396>
    f4ce:	ldrb.w	r4, [r5, #-1]
    f4d2:	ldr	r2, [sp, #36]	; 0x24
    f4d4:	subs	r3, r5, #1
    f4d6:	b.n	f4e2 <_dtoa_r+0x38a>
    f4d8:	cmp	r2, r3
    f4da:	beq.w	fcd6 <_dtoa_r+0xb7e>
    f4de:	ldrb.w	r4, [r3, #-1]!
    f4e2:	cmp	r4, #57	; 0x39
    f4e4:	add.w	r5, r3, #1
    f4e8:	beq.n	f4d8 <_dtoa_r+0x380>
    f4ea:	adds	r4, #1
    f4ec:	strb	r4, [r3, #0]
    f4ee:	ldr	r1, [sp, #40]	; 0x28
    f4f0:	mov	r0, r9
    f4f2:	bl	10a6c <_Bfree>
    f4f6:	movs	r2, #0
    f4f8:	ldr	r3, [sp, #16]
    f4fa:	strb	r2, [r5, #0]
    f4fc:	ldr	r2, [sp, #12]
    f4fe:	adds	r3, #1
    f500:	str	r3, [r2, #0]
    f502:	ldr	r3, [sp, #148]	; 0x94
    f504:	cmp	r3, #0
    f506:	beq.w	fc40 <_dtoa_r+0xae8>
    f50a:	ldr	r0, [sp, #36]	; 0x24
    f50c:	str	r5, [r3, #0]
    f50e:	add	sp, #108	; 0x6c
    f510:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f514:	ldr	r2, [sp, #44]	; 0x2c
    f516:	cmp	r2, #0
    f518:	beq.w	f738 <_dtoa_r+0x5e0>
    f51c:	ldr	r2, [sp, #0]
    f51e:	cmp	r2, #1
    f520:	ble.w	f9d2 <_dtoa_r+0x87a>
    f524:	ldr	r3, [sp, #32]
    f526:	ldr	r2, [sp, #24]
    f528:	subs	r7, r3, #1
    f52a:	cmp	r2, r7
    f52c:	blt.w	fc46 <_dtoa_r+0xaee>
    f530:	subs	r7, r2, r7
    f532:	ldr	r3, [sp, #32]
    f534:	cmp	r3, #0
    f536:	blt.w	fe3a <_dtoa_r+0xce2>
    f53a:	ldr	r5, [sp, #28]
    f53c:	ldr	r3, [sp, #32]
    f53e:	ldr	r2, [sp, #28]
    f540:	movs	r1, #1
    f542:	add	r2, r3
    f544:	mov	r0, r9
    f546:	str	r2, [sp, #28]
    f548:	add	r8, r3
    f54a:	bl	10c34 <__i2b>
    f54e:	mov	r6, r0
    f550:	cbz	r5, f56c <_dtoa_r+0x414>
    f552:	cmp.w	r8, #0
    f556:	ble.n	f56c <_dtoa_r+0x414>
    f558:	cmp	r5, r8
    f55a:	ldr	r2, [sp, #28]
    f55c:	mov	r3, r5
    f55e:	it	ge
    f560:	movge	r3, r8
    f562:	subs	r2, r2, r3
    f564:	str	r2, [sp, #28]
    f566:	subs	r5, r5, r3
    f568:	rsb	r8, r3, r8
    f56c:	ldr	r3, [sp, #24]
    f56e:	cmp	r3, #0
    f570:	ble.w	fb5e <_dtoa_r+0xa06>
    f574:	ldr	r2, [sp, #44]	; 0x2c
    f576:	cmp	r2, #0
    f578:	beq.w	f980 <_dtoa_r+0x828>
    f57c:	cmp	r7, #0
    f57e:	beq.w	f980 <_dtoa_r+0x828>
    f582:	mov	r1, r6
    f584:	mov	r2, r7
    f586:	mov	r0, r9
    f588:	bl	10d78 <__pow5mult>
    f58c:	ldr	r2, [sp, #40]	; 0x28
    f58e:	mov	r1, r0
    f590:	mov	r6, r0
    f592:	mov	r0, r9
    f594:	bl	10c48 <__multiply>
    f598:	ldr	r1, [sp, #40]	; 0x28
    f59a:	mov	r4, r0
    f59c:	mov	r0, r9
    f59e:	bl	10a6c <_Bfree>
    f5a2:	ldr	r3, [sp, #24]
    f5a4:	subs	r3, r3, r7
    f5a6:	str	r3, [sp, #24]
    f5a8:	bne.w	f97e <_dtoa_r+0x826>
    f5ac:	movs	r1, #1
    f5ae:	mov	r0, r9
    f5b0:	bl	10c34 <__i2b>
    f5b4:	ldr	r3, [sp, #48]	; 0x30
    f5b6:	str	r0, [sp, #24]
    f5b8:	cmp	r3, #0
    f5ba:	beq.w	f9e8 <_dtoa_r+0x890>
    f5be:	mov	r1, r0
    f5c0:	mov	r2, r3
    f5c2:	mov	r0, r9
    f5c4:	bl	10d78 <__pow5mult>
    f5c8:	ldr	r3, [sp, #0]
    f5ca:	str	r0, [sp, #24]
    f5cc:	cmp	r3, #1
    f5ce:	ble.w	fbb8 <_dtoa_r+0xa60>
    f5d2:	movs	r7, #0
    f5d4:	ldr	r2, [sp, #24]
    f5d6:	ldr	r3, [r2, #16]
    f5d8:	add.w	r3, r2, r3, lsl #2
    f5dc:	ldr	r0, [r3, #16]
    f5de:	bl	10b98 <__hi0bits>
    f5e2:	rsb	r0, r0, #32
    f5e6:	add	r0, r8
    f5e8:	ands.w	r0, r0, #31
    f5ec:	beq.w	f9e4 <_dtoa_r+0x88c>
    f5f0:	rsb	r3, r0, #32
    f5f4:	cmp	r3, #4
    f5f6:	ble.w	ff74 <_dtoa_r+0xe1c>
    f5fa:	rsb	r0, r0, #28
    f5fe:	ldr	r3, [sp, #28]
    f600:	add	r3, r0
    f602:	str	r3, [sp, #28]
    f604:	add	r5, r0
    f606:	add	r8, r0
    f608:	ldr	r3, [sp, #28]
    f60a:	cmp	r3, #0
    f60c:	ble.n	f61a <_dtoa_r+0x4c2>
    f60e:	mov	r1, r4
    f610:	mov	r2, r3
    f612:	mov	r0, r9
    f614:	bl	10e18 <__lshift>
    f618:	mov	r4, r0
    f61a:	cmp.w	r8, #0
    f61e:	ble.n	f62c <_dtoa_r+0x4d4>
    f620:	mov	r2, r8
    f622:	ldr	r1, [sp, #24]
    f624:	mov	r0, r9
    f626:	bl	10e18 <__lshift>
    f62a:	str	r0, [sp, #24]
    f62c:	ldr	r3, [sp, #52]	; 0x34
    f62e:	cmp	r3, #0
    f630:	bne.w	fb28 <_dtoa_r+0x9d0>
    f634:	ldr	r3, [sp, #32]
    f636:	cmp	r3, #0
    f638:	ble.w	fb62 <_dtoa_r+0xa0a>
    f63c:	ldr	r3, [sp, #44]	; 0x2c
    f63e:	cmp	r3, #0
    f640:	bne.w	fa2c <_dtoa_r+0x8d4>
    f644:	ldr.w	fp, [sp, #36]	; 0x24
    f648:	ldr	r7, [sp, #32]
    f64a:	ldr.w	r8, [sp, #24]
    f64e:	mov	r5, fp
    f650:	b.n	f658 <_dtoa_r+0x500>
    f652:	bl	10a80 <__multadd>
    f656:	mov	r4, r0
    f658:	mov	r1, r8
    f65a:	mov	r0, r4
    f65c:	bl	f02c <quorem>
    f660:	add.w	sl, r0, #48	; 0x30
    f664:	strb.w	sl, [r5], #1
    f668:	rsb	r3, fp, r5
    f66c:	cmp	r3, r7
    f66e:	mov.w	r2, #10
    f672:	mov.w	r3, #0
    f676:	mov	r1, r4
    f678:	mov	r0, r9
    f67a:	blt.n	f652 <_dtoa_r+0x4fa>
    f67c:	ldr	r3, [sp, #36]	; 0x24
    f67e:	ldr	r2, [sp, #32]
    f680:	cmp	r2, #1
    f682:	ite	ge
    f684:	addge	r3, r3, r2
    f686:	addlt	r3, #1
    f688:	mov	r5, r3
    f68a:	mov.w	fp, #0
    f68e:	mov	r1, r4
    f690:	movs	r2, #1
    f692:	mov	r0, r9
    f694:	bl	10e18 <__lshift>
    f698:	ldr	r1, [sp, #24]
    f69a:	str	r0, [sp, #40]	; 0x28
    f69c:	bl	10ec8 <__mcmp>
    f6a0:	cmp	r0, #0
    f6a2:	ble.w	fcb0 <_dtoa_r+0xb58>
    f6a6:	ldrb.w	r2, [r5, #-1]
    f6aa:	ldr	r1, [sp, #36]	; 0x24
    f6ac:	subs	r3, r5, #1
    f6ae:	b.n	f6ba <_dtoa_r+0x562>
    f6b0:	cmp	r3, r1
    f6b2:	beq.w	fb9e <_dtoa_r+0xa46>
    f6b6:	ldrb.w	r2, [r3, #-1]!
    f6ba:	cmp	r2, #57	; 0x39
    f6bc:	add.w	r5, r3, #1
    f6c0:	beq.n	f6b0 <_dtoa_r+0x558>
    f6c2:	adds	r2, #1
    f6c4:	strb	r2, [r3, #0]
    f6c6:	ldr	r1, [sp, #24]
    f6c8:	mov	r0, r9
    f6ca:	bl	10a6c <_Bfree>
    f6ce:	cmp	r6, #0
    f6d0:	beq.w	f4ee <_dtoa_r+0x396>
    f6d4:	cmp.w	fp, #0
    f6d8:	beq.n	f6e6 <_dtoa_r+0x58e>
    f6da:	cmp	fp, r6
    f6dc:	beq.n	f6e6 <_dtoa_r+0x58e>
    f6de:	mov	r1, fp
    f6e0:	mov	r0, r9
    f6e2:	bl	10a6c <_Bfree>
    f6e6:	mov	r1, r6
    f6e8:	mov	r0, r9
    f6ea:	bl	10a6c <_Bfree>
    f6ee:	b.n	f4ee <_dtoa_r+0x396>
    f6f0:	movs	r3, #1
    f6f2:	str	r3, [sp, #52]	; 0x34
    f6f4:	b.n	f2ce <_dtoa_r+0x176>
    f6f6:	ldr.w	r8, [sp, #16]
    f6fa:	mov	r0, r8
    f6fc:	bl	9fa4 <__aeabi_i2d>
    f700:	mov	r2, r0
    f702:	mov	r3, r1
    f704:	mov	r0, r6
    f706:	mov	r1, r7
    f708:	bl	a540 <__aeabi_dcmpeq>
    f70c:	cmp	r0, #0
    f70e:	bne.w	f2a6 <_dtoa_r+0x14e>
    f712:	add.w	r3, r8, #4294967295
    f716:	str	r3, [sp, #16]
    f718:	b.n	f2a6 <_dtoa_r+0x14e>
    f71a:	ldr	r2, [sp, #28]
    f71c:	ldr	r3, [sp, #16]
    f71e:	subs	r2, r2, r3
    f720:	negs	r3, r3
    f722:	str	r3, [sp, #24]
    f724:	movs	r3, #0
    f726:	str	r2, [sp, #28]
    f728:	str	r3, [sp, #48]	; 0x30
    f72a:	b.n	f2ec <_dtoa_r+0x194>
    f72c:	rsb	r3, r8, #0
    f730:	str	r3, [sp, #28]
    f732:	mov.w	r8, #0
    f736:	b.n	f2dc <_dtoa_r+0x184>
    f738:	ldr	r7, [sp, #24]
    f73a:	ldr	r5, [sp, #28]
    f73c:	ldr	r6, [sp, #44]	; 0x2c
    f73e:	b.n	f550 <_dtoa_r+0x3f8>
    f740:	rsb	r4, r3, #32
    f744:	lsl.w	r0, sl, r4
    f748:	b.n	f240 <_dtoa_r+0xe8>
    f74a:	str	r0, [sp, #52]	; 0x34
    f74c:	b.n	f2ce <_dtoa_r+0x176>
    f74e:	nop
    f750:	.word	0x40240000
    f754:	movs	r3, #0
    f756:	str	r3, [sp, #44]	; 0x2c
    f758:	ldr	r3, [sp, #16]
    f75a:	ldr	r2, [sp, #20]
    f75c:	add	r3, r2
    f75e:	str	r3, [sp, #56]	; 0x38
    f760:	adds	r3, #1
    f762:	cmp	r3, #0
    f764:	str	r3, [sp, #32]
    f766:	ble.w	fc64 <_dtoa_r+0xb0c>
    f76a:	ldr	r4, [sp, #32]
    f76c:	mov	r5, r4
    f76e:	movs	r1, #0
    f770:	cmp	r5, #23
    f772:	str.w	r1, [r9, #68]	; 0x44
    f776:	bls.n	f790 <_dtoa_r+0x638>
    f778:	movs	r2, #1
    f77a:	movs	r3, #4
    f77c:	lsls	r3, r3, #1
    f77e:	add.w	r0, r3, #20
    f782:	cmp	r0, r5
    f784:	mov	r1, r2
    f786:	add.w	r2, r2, #1
    f78a:	bls.n	f77c <_dtoa_r+0x624>
    f78c:	str.w	r1, [r9, #68]	; 0x44
    f790:	mov	r0, r9
    f792:	bl	10a20 <_Balloc>
    f796:	cmp	r4, #14
    f798:	str	r0, [sp, #36]	; 0x24
    f79a:	str.w	r0, [r9, #64]	; 0x40
    f79e:	bhi.w	f36c <_dtoa_r+0x214>
    f7a2:	cmp	r6, #0
    f7a4:	beq.w	f36c <_dtoa_r+0x214>
    f7a8:	ldr	r1, [sp, #16]
    f7aa:	cmp	r1, #0
    f7ac:	strd	sl, fp, [sp, #64]	; 0x40
    f7b0:	ble.w	fce8 <_dtoa_r+0xb90>
    f7b4:	ldr	r3, [pc, #576]	; (f9f8 <_dtoa_r+0x8a0>)
    f7b6:	and.w	r2, r1, #15
    f7ba:	asrs	r6, r1, #4
    f7bc:	add.w	r3, r3, r2, lsl #3
    f7c0:	lsls	r0, r6, #27
    f7c2:	ldrd	r4, r5, [r3]
    f7c6:	bpl.w	fc56 <_dtoa_r+0xafe>
    f7ca:	ldr	r3, [pc, #560]	; (f9fc <_dtoa_r+0x8a4>)
    f7cc:	mov	r0, sl
    f7ce:	mov	r1, fp
    f7d0:	ldrd	r2, r3, [r3, #32]
    f7d4:	bl	a2c4 <__aeabi_ddiv>
    f7d8:	strd	r0, r1, [sp, #72]	; 0x48
    f7dc:	and.w	r6, r6, #15
    f7e0:	mov.w	sl, #3
    f7e4:	cbz	r6, f808 <_dtoa_r+0x6b0>
    f7e6:	ldr	r7, [pc, #532]	; (f9fc <_dtoa_r+0x8a4>)
    f7e8:	lsls	r1, r6, #31
    f7ea:	bpl.n	f800 <_dtoa_r+0x6a8>
    f7ec:	mov	r0, r4
    f7ee:	mov	r1, r5
    f7f0:	ldrd	r2, r3, [r7]
    f7f4:	bl	a070 <__aeabi_dmul>
    f7f8:	add.w	sl, sl, #1
    f7fc:	mov	r4, r0
    f7fe:	mov	r5, r1
    f800:	asrs	r6, r6, #1
    f802:	add.w	r7, r7, #8
    f806:	bne.n	f7e8 <_dtoa_r+0x690>
    f808:	mov	r2, r4
    f80a:	mov	r3, r5
    f80c:	ldrd	r0, r1, [sp, #72]	; 0x48
    f810:	bl	a2c4 <__aeabi_ddiv>
    f814:	mov	r6, r0
    f816:	mov	r7, r1
    f818:	ldr	r3, [sp, #52]	; 0x34
    f81a:	cbz	r3, f82e <_dtoa_r+0x6d6>
    f81c:	movs	r2, #0
    f81e:	ldr	r3, [pc, #480]	; (fa00 <_dtoa_r+0x8a8>)
    f820:	mov	r0, r6
    f822:	mov	r1, r7
    f824:	bl	a554 <__aeabi_dcmplt>
    f828:	cmp	r0, #0
    f82a:	bne.w	fe62 <_dtoa_r+0xd0a>
    f82e:	mov	r0, sl
    f830:	bl	9fa4 <__aeabi_i2d>
    f834:	mov	r2, r6
    f836:	mov	r3, r7
    f838:	bl	a070 <__aeabi_dmul>
    f83c:	ldr	r3, [pc, #452]	; (fa04 <_dtoa_r+0x8ac>)
    f83e:	movs	r2, #0
    f840:	bl	9d0c <__adddf3>
    f844:	ldr	r3, [sp, #32]
    f846:	mov	r4, r0
    f848:	sub.w	r5, r1, #54525952	; 0x3400000
    f84c:	cmp	r3, #0
    f84e:	beq.w	fc08 <_dtoa_r+0xab0>
    f852:	ldr	r3, [sp, #16]
    f854:	str	r3, [sp, #88]	; 0x58
    f856:	ldr	r3, [sp, #32]
    f858:	str	r3, [sp, #72]	; 0x48
    f85a:	ldr	r3, [sp, #44]	; 0x2c
    f85c:	cmp	r3, #0
    f85e:	beq.w	fd8a <_dtoa_r+0xc32>
    f862:	ldr	r2, [sp, #72]	; 0x48
    f864:	ldr	r3, [pc, #400]	; (f9f8 <_dtoa_r+0x8a0>)
    f866:	ldr	r1, [pc, #416]	; (fa08 <_dtoa_r+0x8b0>)
    f868:	add.w	r3, r3, r2, lsl #3
    f86c:	ldrd	r2, r3, [r3, #-8]
    f870:	movs	r0, #0
    f872:	bl	a2c4 <__aeabi_ddiv>
    f876:	mov	r2, r4
    f878:	mov	r3, r5
    f87a:	bl	9d08 <__aeabi_dsub>
    f87e:	mov	sl, r0
    f880:	mov	fp, r1
    f882:	mov	r0, r6
    f884:	mov	r1, r7
    f886:	bl	a5d0 <__aeabi_d2iz>
    f88a:	mov	r4, r0
    f88c:	bl	9fa4 <__aeabi_i2d>
    f890:	mov	r2, r0
    f892:	mov	r3, r1
    f894:	mov	r0, r6
    f896:	mov	r1, r7
    f898:	bl	9d08 <__aeabi_dsub>
    f89c:	adds	r4, #48	; 0x30
    f89e:	ldr	r5, [sp, #36]	; 0x24
    f8a0:	uxtb	r4, r4
    f8a2:	mov	r6, r0
    f8a4:	mov	r7, r1
    f8a6:	strb	r4, [r5, #0]
    f8a8:	mov	r2, r0
    f8aa:	mov	r3, r1
    f8ac:	mov	r0, sl
    f8ae:	mov	r1, fp
    f8b0:	adds	r5, #1
    f8b2:	bl	a590 <__aeabi_dcmpgt>
    f8b6:	cmp	r0, #0
    f8b8:	bne.n	f95c <_dtoa_r+0x804>
    f8ba:	mov	r2, r6
    f8bc:	mov	r3, r7
    f8be:	movs	r0, #0
    f8c0:	ldr	r1, [pc, #316]	; (fa00 <_dtoa_r+0x8a8>)
    f8c2:	bl	9d08 <__aeabi_dsub>
    f8c6:	mov	r2, r0
    f8c8:	mov	r3, r1
    f8ca:	mov	r0, sl
    f8cc:	mov	r1, fp
    f8ce:	bl	a590 <__aeabi_dcmpgt>
    f8d2:	cmp	r0, #0
    f8d4:	bne.w	fee8 <_dtoa_r+0xd90>
    f8d8:	ldr	r2, [sp, #72]	; 0x48
    f8da:	cmp	r2, #1
    f8dc:	ble.w	fcce <_dtoa_r+0xb76>
    f8e0:	ldr	r3, [sp, #72]	; 0x48
    f8e2:	ldr	r2, [sp, #36]	; 0x24
    f8e4:	str.w	r8, [sp, #72]	; 0x48
    f8e8:	add	r3, r2
    f8ea:	mov	r8, r3
    f8ec:	b.n	f90a <_dtoa_r+0x7b2>
    f8ee:	movs	r0, #0
    f8f0:	ldr	r1, [pc, #268]	; (fa00 <_dtoa_r+0x8a8>)
    f8f2:	bl	9d08 <__aeabi_dsub>
    f8f6:	mov	r2, sl
    f8f8:	mov	r3, fp
    f8fa:	bl	a554 <__aeabi_dcmplt>
    f8fe:	cmp	r0, #0
    f900:	bne.w	fee8 <_dtoa_r+0xd90>
    f904:	cmp	r5, r8
    f906:	beq.w	fcca <_dtoa_r+0xb72>
    f90a:	mov	r0, sl
    f90c:	mov	r1, fp
    f90e:	movs	r2, #0
    f910:	ldr	r3, [pc, #248]	; (fa0c <_dtoa_r+0x8b4>)
    f912:	bl	a070 <__aeabi_dmul>
    f916:	movs	r2, #0
    f918:	ldr	r3, [pc, #240]	; (fa0c <_dtoa_r+0x8b4>)
    f91a:	mov	sl, r0
    f91c:	mov	fp, r1
    f91e:	mov	r0, r6
    f920:	mov	r1, r7
    f922:	bl	a070 <__aeabi_dmul>
    f926:	mov	r7, r1
    f928:	mov	r6, r0
    f92a:	bl	a5d0 <__aeabi_d2iz>
    f92e:	mov	r4, r0
    f930:	bl	9fa4 <__aeabi_i2d>
    f934:	mov	r2, r0
    f936:	mov	r3, r1
    f938:	mov	r0, r6
    f93a:	mov	r1, r7
    f93c:	bl	9d08 <__aeabi_dsub>
    f940:	adds	r4, #48	; 0x30
    f942:	uxtb	r4, r4
    f944:	mov	r2, sl
    f946:	mov	r3, fp
    f948:	strb.w	r4, [r5], #1
    f94c:	mov	r6, r0
    f94e:	mov	r7, r1
    f950:	bl	a554 <__aeabi_dcmplt>
    f954:	mov	r2, r6
    f956:	mov	r3, r7
    f958:	cmp	r0, #0
    f95a:	beq.n	f8ee <_dtoa_r+0x796>
    f95c:	ldr	r3, [sp, #88]	; 0x58
    f95e:	str	r3, [sp, #16]
    f960:	b.n	f4ee <_dtoa_r+0x396>
    f962:	movs	r3, #0
    f964:	str	r3, [sp, #44]	; 0x2c
    f966:	ldr	r3, [sp, #20]
    f968:	cmp	r3, #0
    f96a:	ble.w	fc6e <_dtoa_r+0xb16>
    f96e:	mov	r5, r3
    f970:	mov	r4, r3
    f972:	str	r3, [sp, #56]	; 0x38
    f974:	str	r3, [sp, #32]
    f976:	b.n	f76e <_dtoa_r+0x616>
    f978:	movs	r3, #1
    f97a:	str	r3, [sp, #44]	; 0x2c
    f97c:	b.n	f966 <_dtoa_r+0x80e>
    f97e:	str	r4, [sp, #40]	; 0x28
    f980:	ldr	r2, [sp, #24]
    f982:	ldr	r1, [sp, #40]	; 0x28
    f984:	mov	r0, r9
    f986:	bl	10d78 <__pow5mult>
    f98a:	mov	r4, r0
    f98c:	b.n	f5ac <_dtoa_r+0x454>
    f98e:	ldr	r3, [sp, #32]
    f990:	cmp	r3, #0
    f992:	bgt.w	f392 <_dtoa_r+0x23a>
    f996:	bne.w	fc38 <_dtoa_r+0xae0>
    f99a:	movs	r2, #0
    f99c:	ldr	r3, [pc, #112]	; (fa10 <_dtoa_r+0x8b8>)
    f99e:	ldrd	r0, r1, [sp]
    f9a2:	bl	a070 <__aeabi_dmul>
    f9a6:	mov	r3, fp
    f9a8:	mov	r2, sl
    f9aa:	bl	a57c <__aeabi_dcmpge>
    f9ae:	ldr	r3, [sp, #32]
    f9b0:	str	r3, [sp, #24]
    f9b2:	mov	r6, r3
    f9b4:	cmp	r0, #0
    f9b6:	beq.w	fb8e <_dtoa_r+0xa36>
    f9ba:	ldr	r3, [sp, #20]
    f9bc:	ldr	r5, [sp, #36]	; 0x24
    f9be:	mvns	r3, r3
    f9c0:	str	r3, [sp, #16]
    f9c2:	ldr	r1, [sp, #24]
    f9c4:	mov	r0, r9
    f9c6:	bl	10a6c <_Bfree>
    f9ca:	cmp	r6, #0
    f9cc:	beq.w	f4ee <_dtoa_r+0x396>
    f9d0:	b.n	f6e6 <_dtoa_r+0x58e>
    f9d2:	ldr	r2, [sp, #60]	; 0x3c
    f9d4:	cmp	r2, #0
    f9d6:	beq.w	fe4a <_dtoa_r+0xcf2>
    f9da:	addw	r3, r3, #1075	; 0x433
    f9de:	ldr	r7, [sp, #24]
    f9e0:	ldr	r5, [sp, #28]
    f9e2:	b.n	f53e <_dtoa_r+0x3e6>
    f9e4:	movs	r0, #28
    f9e6:	b.n	f5fe <_dtoa_r+0x4a6>
    f9e8:	ldr	r3, [sp, #0]
    f9ea:	cmp	r3, #1
    f9ec:	ble.w	fef0 <_dtoa_r+0xd98>
    f9f0:	ldr	r7, [sp, #48]	; 0x30
    f9f2:	movs	r0, #1
    f9f4:	b.n	f5e6 <_dtoa_r+0x48e>
    f9f6:	nop
    f9f8:	.word	0x00012c00
    f9fc:	.word	0x00012cc8
    fa00:	.word	0x3ff00000
    fa04:	.word	0x401c0000
    fa08:	.word	0x3fe00000
    fa0c:	.word	0x40240000
    fa10:	.word	0x40140000
    fa14:	mov	r1, r6
    fa16:	movs	r3, #0
    fa18:	movs	r2, #10
    fa1a:	mov	r0, r9
    fa1c:	bl	10a80 <__multadd>
    fa20:	ldr	r3, [sp, #56]	; 0x38
    fa22:	cmp	r3, #0
    fa24:	mov	r6, r0
    fa26:	ble.w	ff44 <_dtoa_r+0xdec>
    fa2a:	str	r3, [sp, #32]
    fa2c:	cmp	r5, #0
    fa2e:	ble.n	fa3c <_dtoa_r+0x8e4>
    fa30:	mov	r1, r6
    fa32:	mov	r2, r5
    fa34:	mov	r0, r9
    fa36:	bl	10e18 <__lshift>
    fa3a:	mov	r6, r0
    fa3c:	cmp	r7, #0
    fa3e:	bne.w	fd3a <_dtoa_r+0xbe2>
    fa42:	mov	r8, r6
    fa44:	ldr	r3, [sp, #32]
    fa46:	ldr	r2, [sp, #36]	; 0x24
    fa48:	subs	r3, #1
    fa4a:	adds	r3, r2, r3
    fa4c:	str	r3, [sp, #32]
    fa4e:	and.w	r3, sl, #1
    fa52:	str	r3, [sp, #40]	; 0x28
    fa54:	mov	r7, r2
    fa56:	ldr.w	fp, [sp, #24]
    fa5a:	mov	r0, r4
    fa5c:	mov	r1, fp
    fa5e:	bl	f02c <quorem>
    fa62:	mov	r1, r6
    fa64:	mov	r5, r0
    fa66:	mov	r0, r4
    fa68:	bl	10ec8 <__mcmp>
    fa6c:	mov	r2, r8
    fa6e:	mov	r1, fp
    fa70:	mov	sl, r0
    fa72:	mov	r0, r9
    fa74:	bl	10f0c <__mdiff>
    fa78:	ldr	r2, [r0, #12]
    fa7a:	mov	fp, r0
    fa7c:	add.w	r3, r5, #48	; 0x30
    fa80:	cmp	r2, #0
    fa82:	bne.n	fb18 <_dtoa_r+0x9c0>
    fa84:	mov	r1, r0
    fa86:	mov	r0, r4
    fa88:	str	r3, [sp, #28]
    fa8a:	bl	10ec8 <__mcmp>
    fa8e:	mov	r1, fp
    fa90:	str	r0, [sp, #20]
    fa92:	mov	r0, r9
    fa94:	bl	10a6c <_Bfree>
    fa98:	ldr	r2, [sp, #20]
    fa9a:	ldr	r3, [sp, #28]
    fa9c:	cbnz	r2, faaa <_dtoa_r+0x952>
    fa9e:	ldr	r1, [sp, #0]
    faa0:	cbnz	r1, faaa <_dtoa_r+0x952>
    faa2:	ldr	r1, [sp, #40]	; 0x28
    faa4:	cmp	r1, #0
    faa6:	beq.w	ff14 <_dtoa_r+0xdbc>
    faaa:	cmp.w	sl, #0
    faae:	blt.w	fc78 <_dtoa_r+0xb20>
    fab2:	bne.n	fac0 <_dtoa_r+0x968>
    fab4:	ldr	r1, [sp, #0]
    fab6:	cbnz	r1, fac0 <_dtoa_r+0x968>
    fab8:	ldr	r1, [sp, #40]	; 0x28
    faba:	cmp	r1, #0
    fabc:	beq.w	fc78 <_dtoa_r+0xb20>
    fac0:	cmp	r2, #0
    fac2:	bgt.w	fd62 <_dtoa_r+0xc0a>
    fac6:	ldr	r2, [sp, #32]
    fac8:	strb	r3, [r7, #0]
    faca:	add.w	sl, r7, #1
    face:	cmp	r7, r2
    fad0:	mov	r5, sl
    fad2:	beq.w	fd7a <_dtoa_r+0xc22>
    fad6:	mov	r1, r4
    fad8:	movs	r3, #0
    fada:	movs	r2, #10
    fadc:	mov	r0, r9
    fade:	bl	10a80 <__multadd>
    fae2:	cmp	r6, r8
    fae4:	mov	r4, r0
    fae6:	mov	r1, r6
    fae8:	mov.w	r3, #0
    faec:	mov.w	r2, #10
    faf0:	mov	r0, r9
    faf2:	beq.n	fb0c <_dtoa_r+0x9b4>
    faf4:	bl	10a80 <__multadd>
    faf8:	mov	r1, r8
    fafa:	mov	r6, r0
    fafc:	movs	r3, #0
    fafe:	movs	r2, #10
    fb00:	mov	r0, r9
    fb02:	bl	10a80 <__multadd>
    fb06:	mov	r7, sl
    fb08:	mov	r8, r0
    fb0a:	b.n	fa56 <_dtoa_r+0x8fe>
    fb0c:	bl	10a80 <__multadd>
    fb10:	mov	r7, sl
    fb12:	mov	r6, r0
    fb14:	mov	r8, r0
    fb16:	b.n	fa56 <_dtoa_r+0x8fe>
    fb18:	mov	r1, r0
    fb1a:	mov	r0, r9
    fb1c:	str	r3, [sp, #20]
    fb1e:	bl	10a6c <_Bfree>
    fb22:	movs	r2, #1
    fb24:	ldr	r3, [sp, #20]
    fb26:	b.n	faaa <_dtoa_r+0x952>
    fb28:	ldr	r1, [sp, #24]
    fb2a:	mov	r0, r4
    fb2c:	bl	10ec8 <__mcmp>
    fb30:	cmp	r0, #0
    fb32:	bge.w	f634 <_dtoa_r+0x4dc>
    fb36:	mov	r1, r4
    fb38:	ldr	r4, [sp, #16]
    fb3a:	movs	r3, #0
    fb3c:	subs	r4, #1
    fb3e:	movs	r2, #10
    fb40:	mov	r0, r9
    fb42:	str	r4, [sp, #16]
    fb44:	bl	10a80 <__multadd>
    fb48:	ldr	r3, [sp, #44]	; 0x2c
    fb4a:	mov	r4, r0
    fb4c:	cmp	r3, #0
    fb4e:	bne.w	fa14 <_dtoa_r+0x8bc>
    fb52:	ldr	r3, [sp, #56]	; 0x38
    fb54:	cmp	r3, #0
    fb56:	ble.w	ff34 <_dtoa_r+0xddc>
    fb5a:	str	r3, [sp, #32]
    fb5c:	b.n	f644 <_dtoa_r+0x4ec>
    fb5e:	ldr	r4, [sp, #40]	; 0x28
    fb60:	b.n	f5ac <_dtoa_r+0x454>
    fb62:	ldr	r3, [sp, #0]
    fb64:	cmp	r3, #2
    fb66:	ble.w	f63c <_dtoa_r+0x4e4>
    fb6a:	ldr	r3, [sp, #32]
    fb6c:	cmp	r3, #0
    fb6e:	bne.w	feac <_dtoa_r+0xd54>
    fb72:	ldr	r1, [sp, #24]
    fb74:	movs	r2, #5
    fb76:	mov	r0, r9
    fb78:	bl	10a80 <__multadd>
    fb7c:	mov	r1, r0
    fb7e:	str	r0, [sp, #24]
    fb80:	mov	r0, r4
    fb82:	bl	10ec8 <__mcmp>
    fb86:	cmp	r0, #0
    fb88:	str	r4, [sp, #40]	; 0x28
    fb8a:	ble.w	f9ba <_dtoa_r+0x862>
    fb8e:	ldr	r2, [sp, #16]
    fb90:	ldr	r1, [sp, #36]	; 0x24
    fb92:	movs	r3, #49	; 0x31
    fb94:	adds	r2, #1
    fb96:	str	r2, [sp, #16]
    fb98:	strb	r3, [r1, #0]
    fb9a:	adds	r5, r1, #1
    fb9c:	b.n	f9c2 <_dtoa_r+0x86a>
    fb9e:	ldr	r2, [sp, #16]
    fba0:	adds	r2, #1
    fba2:	str	r2, [sp, #16]
    fba4:	ldr	r2, [sp, #36]	; 0x24
    fba6:	movs	r3, #49	; 0x31
    fba8:	strb	r3, [r2, #0]
    fbaa:	b.n	f6c6 <_dtoa_r+0x56e>
    fbac:	movs	r3, #1
    fbae:	str	r3, [sp, #44]	; 0x2c
    fbb0:	b.n	f758 <_dtoa_r+0x600>
    fbb2:	ldr.w	r9, [sp, #20]
    fbb6:	b.n	f4ee <_dtoa_r+0x396>
    fbb8:	cmp.w	sl, #0
    fbbc:	bne.w	f5d2 <_dtoa_r+0x47a>
    fbc0:	ubfx	r3, fp, #0, #20
    fbc4:	cmp	r3, #0
    fbc6:	bne.w	fe46 <_dtoa_r+0xcee>
    fbca:	bic.w	r7, fp, #2147483648	; 0x80000000
    fbce:	lsrs	r7, r7, #20
    fbd0:	lsls	r7, r7, #20
    fbd2:	cbz	r7, fbe0 <_dtoa_r+0xa88>
    fbd4:	ldr	r3, [sp, #28]
    fbd6:	adds	r3, #1
    fbd8:	str	r3, [sp, #28]
    fbda:	add.w	r8, r8, #1
    fbde:	movs	r7, #1
    fbe0:	ldr	r3, [sp, #48]	; 0x30
    fbe2:	movs	r0, #1
    fbe4:	cmp	r3, #0
    fbe6:	beq.w	f5e6 <_dtoa_r+0x48e>
    fbea:	b.n	f5d4 <_dtoa_r+0x47c>
    fbec:	mov	r0, sl
    fbee:	bl	9fa4 <__aeabi_i2d>
    fbf2:	mov	r2, r6
    fbf4:	mov	r3, r7
    fbf6:	bl	a070 <__aeabi_dmul>
    fbfa:	movs	r2, #0
    fbfc:	ldr	r3, [pc, #764]	; (fefc <_dtoa_r+0xda4>)
    fbfe:	bl	9d0c <__adddf3>
    fc02:	mov	r4, r0
    fc04:	sub.w	r5, r1, #54525952	; 0x3400000
    fc08:	mov	r0, r6
    fc0a:	mov	r1, r7
    fc0c:	movs	r2, #0
    fc0e:	ldr	r3, [pc, #752]	; (ff00 <_dtoa_r+0xda8>)
    fc10:	bl	9d08 <__aeabi_dsub>
    fc14:	mov	r2, r4
    fc16:	mov	r3, r5
    fc18:	mov	r6, r0
    fc1a:	mov	r7, r1
    fc1c:	bl	a590 <__aeabi_dcmpgt>
    fc20:	cmp	r0, #0
    fc22:	bne.w	fd82 <_dtoa_r+0xc2a>
    fc26:	mov	r2, r4
    fc28:	add.w	r3, r5, #2147483648	; 0x80000000
    fc2c:	mov	r0, r6
    fc2e:	mov	r1, r7
    fc30:	bl	a554 <__aeabi_dcmplt>
    fc34:	cmp	r0, #0
    fc36:	beq.n	fcce <_dtoa_r+0xb76>
    fc38:	movs	r3, #0
    fc3a:	str	r3, [sp, #24]
    fc3c:	mov	r6, r3
    fc3e:	b.n	f9ba <_dtoa_r+0x862>
    fc40:	ldr	r0, [sp, #36]	; 0x24
    fc42:	b.w	f1ca <_dtoa_r+0x72>
    fc46:	ldr	r3, [sp, #24]
    fc48:	ldr	r2, [sp, #48]	; 0x30
    fc4a:	str	r7, [sp, #24]
    fc4c:	subs	r3, r7, r3
    fc4e:	add	r2, r3
    fc50:	str	r2, [sp, #48]	; 0x30
    fc52:	movs	r7, #0
    fc54:	b.n	f532 <_dtoa_r+0x3da>
    fc56:	vldr	d7, [sp, #64]	; 0x40
    fc5a:	mov.w	sl, #2
    fc5e:	vstr	d7, [sp, #72]	; 0x48
    fc62:	b.n	f7e4 <_dtoa_r+0x68c>
    fc64:	mov	r4, r3
    fc66:	movs	r1, #0
    fc68:	str.w	r1, [r9, #68]	; 0x44
    fc6c:	b.n	f790 <_dtoa_r+0x638>
    fc6e:	movs	r4, #1
    fc70:	str	r4, [sp, #56]	; 0x38
    fc72:	str	r4, [sp, #32]
    fc74:	str	r4, [sp, #20]
    fc76:	b.n	fc66 <_dtoa_r+0xb0e>
    fc78:	cmp	r2, #0
    fc7a:	mov	sl, r3
    fc7c:	ble.n	fca2 <_dtoa_r+0xb4a>
    fc7e:	mov	r1, r4
    fc80:	movs	r2, #1
    fc82:	mov	r0, r9
    fc84:	bl	10e18 <__lshift>
    fc88:	ldr	r1, [sp, #24]
    fc8a:	mov	r4, r0
    fc8c:	bl	10ec8 <__mcmp>
    fc90:	cmp	r0, #0
    fc92:	ble.w	ff26 <_dtoa_r+0xdce>
    fc96:	cmp.w	sl, #57	; 0x39
    fc9a:	beq.w	feb0 <_dtoa_r+0xd58>
    fc9e:	add.w	sl, r5, #49	; 0x31
    fca2:	mov	fp, r6
    fca4:	strb.w	sl, [r7]
    fca8:	adds	r5, r7, #1
    fcaa:	mov	r6, r8
    fcac:	str	r4, [sp, #40]	; 0x28
    fcae:	b.n	f6c6 <_dtoa_r+0x56e>
    fcb0:	bne.n	fcbc <_dtoa_r+0xb64>
    fcb2:	tst.w	sl, #1
    fcb6:	beq.n	fcbc <_dtoa_r+0xb64>
    fcb8:	b.n	f6a6 <_dtoa_r+0x54e>
    fcba:	mov	r5, r2
    fcbc:	ldrb.w	r3, [r5, #-1]
    fcc0:	cmp	r3, #48	; 0x30
    fcc2:	add.w	r2, r5, #4294967295
    fcc6:	beq.n	fcba <_dtoa_r+0xb62>
    fcc8:	b.n	f6c6 <_dtoa_r+0x56e>
    fcca:	ldr.w	r8, [sp, #72]	; 0x48
    fcce:	ldrd	sl, fp, [sp, #64]	; 0x40
    fcd2:	b.w	f36c <_dtoa_r+0x214>
    fcd6:	ldr	r1, [sp, #36]	; 0x24
    fcd8:	movs	r2, #48	; 0x30
    fcda:	strb	r2, [r1, #0]
    fcdc:	ldr	r2, [sp, #16]
    fcde:	ldrb.w	r4, [r5, #-1]
    fce2:	adds	r2, #1
    fce4:	str	r2, [sp, #16]
    fce6:	b.n	f4ea <_dtoa_r+0x392>
    fce8:	ldr	r3, [sp, #16]
    fcea:	negs	r4, r3
    fcec:	cmp	r4, #0
    fcee:	beq.w	fe58 <_dtoa_r+0xd00>
    fcf2:	ldr	r3, [pc, #528]	; (ff04 <_dtoa_r+0xdac>)
    fcf4:	and.w	r2, r4, #15
    fcf8:	add.w	r3, r3, r2, lsl #3
    fcfc:	ldrd	r2, r3, [r3]
    fd00:	ldrd	r0, r1, [sp, #64]	; 0x40
    fd04:	bl	a070 <__aeabi_dmul>
    fd08:	asrs	r4, r4, #4
    fd0a:	mov	r6, r0
    fd0c:	mov	r7, r1
    fd0e:	beq.w	ff3e <_dtoa_r+0xde6>
    fd12:	ldr	r5, [pc, #500]	; (ff08 <_dtoa_r+0xdb0>)
    fd14:	mov.w	sl, #2
    fd18:	lsls	r2, r4, #31
    fd1a:	bpl.n	fd30 <_dtoa_r+0xbd8>
    fd1c:	mov	r0, r6
    fd1e:	mov	r1, r7
    fd20:	ldrd	r2, r3, [r5]
    fd24:	bl	a070 <__aeabi_dmul>
    fd28:	add.w	sl, sl, #1
    fd2c:	mov	r6, r0
    fd2e:	mov	r7, r1
    fd30:	asrs	r4, r4, #1
    fd32:	add.w	r5, r5, #8
    fd36:	bne.n	fd18 <_dtoa_r+0xbc0>
    fd38:	b.n	f818 <_dtoa_r+0x6c0>
    fd3a:	ldr	r1, [r6, #4]
    fd3c:	mov	r0, r9
    fd3e:	bl	10a20 <_Balloc>
    fd42:	ldr	r3, [r6, #16]
    fd44:	adds	r2, r3, #2
    fd46:	mov	r5, r0
    fd48:	lsls	r2, r2, #2
    fd4a:	add.w	r1, r6, #12
    fd4e:	adds	r0, #12
    fd50:	bl	8734 <memcpy>
    fd54:	mov	r1, r5
    fd56:	movs	r2, #1
    fd58:	mov	r0, r9
    fd5a:	bl	10e18 <__lshift>
    fd5e:	mov	r8, r0
    fd60:	b.n	fa44 <_dtoa_r+0x8ec>
    fd62:	cmp	r3, #57	; 0x39
    fd64:	beq.w	feb0 <_dtoa_r+0xd58>
    fd68:	add.w	sl, r3, #1
    fd6c:	mov	fp, r6
    fd6e:	strb.w	sl, [r7]
    fd72:	adds	r5, r7, #1
    fd74:	mov	r6, r8
    fd76:	str	r4, [sp, #40]	; 0x28
    fd78:	b.n	f6c6 <_dtoa_r+0x56e>
    fd7a:	mov	fp, r6
    fd7c:	mov	sl, r3
    fd7e:	mov	r6, r8
    fd80:	b.n	f68e <_dtoa_r+0x536>
    fd82:	movs	r3, #0
    fd84:	str	r3, [sp, #24]
    fd86:	mov	r6, r3
    fd88:	b.n	fb8e <_dtoa_r+0xa36>
    fd8a:	ldr	r3, [sp, #72]	; 0x48
    fd8c:	ldr	r1, [pc, #372]	; (ff04 <_dtoa_r+0xdac>)
    fd8e:	subs	r2, r3, #1
    fd90:	add.w	r1, r1, r2, lsl #3
    fd94:	mov	r3, r5
    fd96:	str	r2, [sp, #92]	; 0x5c
    fd98:	ldrd	r0, r1, [r1]
    fd9c:	mov	r2, r4
    fd9e:	bl	a070 <__aeabi_dmul>
    fda2:	strd	r0, r1, [sp, #80]	; 0x50
    fda6:	mov	r1, r7
    fda8:	mov	r0, r6
    fdaa:	bl	a5d0 <__aeabi_d2iz>
    fdae:	mov	r4, r0
    fdb0:	bl	9fa4 <__aeabi_i2d>
    fdb4:	mov	r3, r1
    fdb6:	mov	r2, r0
    fdb8:	mov	r1, r7
    fdba:	mov	r0, r6
    fdbc:	bl	9d08 <__aeabi_dsub>
    fdc0:	ldr	r3, [sp, #72]	; 0x48
    fdc2:	mov	r7, r1
    fdc4:	ldr	r1, [sp, #36]	; 0x24
    fdc6:	adds	r4, #48	; 0x30
    fdc8:	cmp	r3, #1
    fdca:	mov	r6, r0
    fdcc:	strb	r4, [r1, #0]
    fdce:	add.w	r5, r1, #1
    fdd2:	beq.n	fe16 <_dtoa_r+0xcbe>
    fdd4:	ldr	r3, [sp, #72]	; 0x48
    fdd6:	ldr	r2, [sp, #36]	; 0x24
    fdd8:	add	r3, r2
    fdda:	mov	sl, r3
    fddc:	mov	fp, r5
    fdde:	movs	r2, #0
    fde0:	ldr	r3, [pc, #296]	; (ff0c <_dtoa_r+0xdb4>)
    fde2:	mov	r0, r6
    fde4:	mov	r1, r7
    fde6:	bl	a070 <__aeabi_dmul>
    fdea:	mov	r7, r1
    fdec:	mov	r6, r0
    fdee:	bl	a5d0 <__aeabi_d2iz>
    fdf2:	mov	r4, r0
    fdf4:	bl	9fa4 <__aeabi_i2d>
    fdf8:	adds	r4, #48	; 0x30
    fdfa:	mov	r2, r0
    fdfc:	mov	r3, r1
    fdfe:	mov	r0, r6
    fe00:	mov	r1, r7
    fe02:	bl	9d08 <__aeabi_dsub>
    fe06:	strb.w	r4, [fp], #1
    fe0a:	cmp	sl, fp
    fe0c:	mov	r6, r0
    fe0e:	mov	r7, r1
    fe10:	bne.n	fdde <_dtoa_r+0xc86>
    fe12:	ldr	r3, [sp, #92]	; 0x5c
    fe14:	add	r5, r3
    fe16:	movs	r2, #0
    fe18:	ldr	r3, [pc, #244]	; (ff10 <_dtoa_r+0xdb8>)
    fe1a:	ldrd	r0, r1, [sp, #80]	; 0x50
    fe1e:	bl	9d0c <__adddf3>
    fe22:	mov	r2, r6
    fe24:	mov	r3, r7
    fe26:	bl	a554 <__aeabi_dcmplt>
    fe2a:	cmp	r0, #0
    fe2c:	beq.n	fec0 <_dtoa_r+0xd68>
    fe2e:	ldr	r3, [sp, #88]	; 0x58
    fe30:	str	r3, [sp, #16]
    fe32:	ldrb.w	r4, [r5, #-1]
    fe36:	b.w	f4d2 <_dtoa_r+0x37a>
    fe3a:	ldr	r3, [sp, #28]
    fe3c:	ldr	r2, [sp, #32]
    fe3e:	subs	r5, r3, r2
    fe40:	movs	r3, #0
    fe42:	b.w	f53e <_dtoa_r+0x3e6>
    fe46:	movs	r7, #0
    fe48:	b.n	fbe0 <_dtoa_r+0xa88>
    fe4a:	ldr	r3, [sp, #96]	; 0x60
    fe4c:	ldr	r7, [sp, #24]
    fe4e:	ldr	r5, [sp, #28]
    fe50:	rsb	r3, r3, #54	; 0x36
    fe54:	b.w	f53e <_dtoa_r+0x3e6>
    fe58:	ldrd	r6, r7, [sp, #64]	; 0x40
    fe5c:	mov.w	sl, #2
    fe60:	b.n	f818 <_dtoa_r+0x6c0>
    fe62:	ldr	r3, [sp, #32]
    fe64:	cmp	r3, #0
    fe66:	beq.w	fbec <_dtoa_r+0xa94>
    fe6a:	ldr	r3, [sp, #56]	; 0x38
    fe6c:	cmp	r3, #0
    fe6e:	ble.w	fcce <_dtoa_r+0xb76>
    fe72:	movs	r2, #0
    fe74:	ldr	r3, [pc, #148]	; (ff0c <_dtoa_r+0xdb4>)
    fe76:	mov	r0, r6
    fe78:	mov	r1, r7
    fe7a:	bl	a070 <__aeabi_dmul>
    fe7e:	mov	r6, r0
    fe80:	mov	r7, r1
    fe82:	add.w	r0, sl, #1
    fe86:	bl	9fa4 <__aeabi_i2d>
    fe8a:	mov	r2, r6
    fe8c:	mov	r3, r7
    fe8e:	bl	a070 <__aeabi_dmul>
    fe92:	movs	r2, #0
    fe94:	ldr	r3, [pc, #100]	; (fefc <_dtoa_r+0xda4>)
    fe96:	bl	9d0c <__adddf3>
    fe9a:	ldr	r2, [sp, #16]
    fe9c:	ldr	r3, [sp, #56]	; 0x38
    fe9e:	str	r3, [sp, #72]	; 0x48
    fea0:	subs	r2, #1
    fea2:	mov	r4, r0
    fea4:	sub.w	r5, r1, #54525952	; 0x3400000
    fea8:	str	r2, [sp, #88]	; 0x58
    feaa:	b.n	f85a <_dtoa_r+0x702>
    feac:	str	r4, [sp, #40]	; 0x28
    feae:	b.n	f9ba <_dtoa_r+0x862>
    feb0:	movs	r2, #57	; 0x39
    feb2:	mov	fp, r6
    feb4:	str	r4, [sp, #40]	; 0x28
    feb6:	mov	r6, r8
    feb8:	strb	r2, [r7, #0]
    feba:	adds	r5, r7, #1
    febc:	b.w	f6aa <_dtoa_r+0x552>
    fec0:	ldrd	r2, r3, [sp, #80]	; 0x50
    fec4:	movs	r0, #0
    fec6:	ldr	r1, [pc, #72]	; (ff10 <_dtoa_r+0xdb8>)
    fec8:	bl	9d08 <__aeabi_dsub>
    fecc:	mov	r2, r6
    fece:	mov	r3, r7
    fed0:	bl	a590 <__aeabi_dcmpgt>
    fed4:	cbnz	r0, feda <_dtoa_r+0xd82>
    fed6:	b.n	fcce <_dtoa_r+0xb76>
    fed8:	mov	r5, r2
    feda:	ldrb.w	r3, [r5, #-1]
    fede:	cmp	r3, #48	; 0x30
    fee0:	add.w	r2, r5, #4294967295
    fee4:	beq.n	fed8 <_dtoa_r+0xd80>
    fee6:	b.n	f95c <_dtoa_r+0x804>
    fee8:	ldr	r3, [sp, #88]	; 0x58
    feea:	str	r3, [sp, #16]
    feec:	b.w	f4d2 <_dtoa_r+0x37a>
    fef0:	cmp.w	sl, #0
    fef4:	bne.w	f9f0 <_dtoa_r+0x898>
    fef8:	b.n	fbc0 <_dtoa_r+0xa68>
    fefa:	nop
    fefc:	.word	0x401c0000
    ff00:	.word	0x40140000
    ff04:	.word	0x00012c00
    ff08:	.word	0x00012cc8
    ff0c:	.word	0x40240000
    ff10:	.word	0x3fe00000
    ff14:	cmp	r3, #57	; 0x39
    ff16:	mov	fp, sl
    ff18:	mov	sl, r3
    ff1a:	beq.n	feb0 <_dtoa_r+0xd58>
    ff1c:	cmp.w	fp, #0
    ff20:	bgt.w	fc9e <_dtoa_r+0xb46>
    ff24:	b.n	fca2 <_dtoa_r+0xb4a>
    ff26:	bne.w	fca2 <_dtoa_r+0xb4a>
    ff2a:	tst.w	sl, #1
    ff2e:	beq.w	fca2 <_dtoa_r+0xb4a>
    ff32:	b.n	fc96 <_dtoa_r+0xb3e>
    ff34:	ldr	r3, [sp, #0]
    ff36:	cmp	r3, #2
    ff38:	bgt.n	ff86 <_dtoa_r+0xe2e>
    ff3a:	ldr	r3, [sp, #56]	; 0x38
    ff3c:	b.n	fb5a <_dtoa_r+0xa02>
    ff3e:	mov.w	sl, #2
    ff42:	b.n	f818 <_dtoa_r+0x6c0>
    ff44:	ldr	r3, [sp, #0]
    ff46:	cmp	r3, #2
    ff48:	bgt.n	ff86 <_dtoa_r+0xe2e>
    ff4a:	ldr	r3, [sp, #56]	; 0x38
    ff4c:	b.n	fa2a <_dtoa_r+0x8d2>
    ff4e:	movs	r4, #0
    ff50:	str.w	r4, [r9, #68]	; 0x44
    ff54:	mov	r1, r4
    ff56:	mov	r0, r9
    ff58:	bl	10a20 <_Balloc>
    ff5c:	mov.w	r3, #4294967295
    ff60:	str	r3, [sp, #32]
    ff62:	str	r3, [sp, #56]	; 0x38
    ff64:	movs	r3, #1
    ff66:	str	r0, [sp, #36]	; 0x24
    ff68:	str	r4, [sp, #20]
    ff6a:	str.w	r0, [r9, #64]	; 0x40
    ff6e:	str	r3, [sp, #44]	; 0x2c
    ff70:	b.w	f36c <_dtoa_r+0x214>
    ff74:	beq.w	f608 <_dtoa_r+0x4b0>
    ff78:	rsb	r0, r0, #60	; 0x3c
    ff7c:	b.w	f5fe <_dtoa_r+0x4a6>
    ff80:	movs	r6, #1
    ff82:	b.w	f2fe <_dtoa_r+0x1a6>
    ff86:	ldr	r3, [sp, #56]	; 0x38
    ff88:	str	r3, [sp, #32]
    ff8a:	b.n	fb6a <_dtoa_r+0xa12>

0000ff8c <__libc_fini_array>:
    ff8c:	push	{r3, r4, r5, lr}
    ff8e:	ldr	r5, [pc, #28]	; (ffac <__libc_fini_array+0x20>)
    ff90:	ldr	r4, [pc, #28]	; (ffb0 <__libc_fini_array+0x24>)
    ff92:	subs	r4, r5, r4
    ff94:	asrs	r4, r4, #2
    ff96:	beq.n	ffa4 <__libc_fini_array+0x18>
    ff98:	subs	r4, #1
    ff9a:	ldr.w	r3, [r5, #-4]!
    ff9e:	blx	r3
    ffa0:	cmp	r4, #0
    ffa2:	bne.n	ff98 <__libc_fini_array+0xc>
    ffa4:	ldmia.w	sp!, {r3, r4, r5, lr}
    ffa8:	b.w	12d5c <__init_array_end>
	...

0000ffb4 <_malloc_trim_r>:
    ffb4:	push	{r3, r4, r5, r6, r7, lr}
    ffb6:	ldr	r7, [pc, #140]	; (10044 <_malloc_trim_r+0x90>)
    ffb8:	mov	r4, r1
    ffba:	mov	r6, r0
    ffbc:	bl	b25c <__malloc_lock>
    ffc0:	ldr	r3, [r7, #8]
    ffc2:	ldr	r5, [r3, #4]
    ffc4:	bic.w	r5, r5, #3
    ffc8:	subs	r1, r5, r4
    ffca:	addw	r1, r1, #4079	; 0xfef
    ffce:	bic.w	r1, r1, #4080	; 0xff0
    ffd2:	bic.w	r1, r1, #15
    ffd6:	sub.w	r4, r1, #4096	; 0x1000
    ffda:	cmp.w	r4, #4096	; 0x1000
    ffde:	blt.n	fff0 <_malloc_trim_r+0x3c>
    ffe0:	movs	r1, #0
    ffe2:	mov	r0, r6
    ffe4:	bl	b644 <_sbrk_r>
    ffe8:	ldr	r3, [r7, #8]
    ffea:	add	r3, r5
    ffec:	cmp	r0, r3
    ffee:	beq.n	fffa <_malloc_trim_r+0x46>
    fff0:	mov	r0, r6
    fff2:	bl	b260 <__malloc_unlock>
    fff6:	movs	r0, #0
    fff8:	pop	{r3, r4, r5, r6, r7, pc}
    fffa:	negs	r1, r4
    fffc:	mov	r0, r6
    fffe:	bl	b644 <_sbrk_r>
   10002:	adds	r0, #1
   10004:	beq.n	10022 <_malloc_trim_r+0x6e>
   10006:	ldr	r3, [pc, #64]	; (10048 <_malloc_trim_r+0x94>)
   10008:	ldr	r2, [r7, #8]
   1000a:	ldr	r1, [r3, #0]
   1000c:	subs	r5, r5, r4
   1000e:	orr.w	r5, r5, #1
   10012:	mov	r0, r6
   10014:	subs	r1, r1, r4
   10016:	str	r5, [r2, #4]
   10018:	str	r1, [r3, #0]
   1001a:	bl	b260 <__malloc_unlock>
   1001e:	movs	r0, #1
   10020:	pop	{r3, r4, r5, r6, r7, pc}
   10022:	movs	r1, #0
   10024:	mov	r0, r6
   10026:	bl	b644 <_sbrk_r>
   1002a:	ldr	r2, [r7, #8]
   1002c:	subs	r3, r0, r2
   1002e:	cmp	r3, #15
   10030:	ble.n	fff0 <_malloc_trim_r+0x3c>
   10032:	ldr	r4, [pc, #24]	; (1004c <_malloc_trim_r+0x98>)
   10034:	ldr	r1, [pc, #16]	; (10048 <_malloc_trim_r+0x94>)
   10036:	ldr	r4, [r4, #0]
   10038:	orr.w	r3, r3, #1
   1003c:	subs	r0, r0, r4
   1003e:	str	r3, [r2, #4]
   10040:	str	r0, [r1, #0]
   10042:	b.n	fff0 <_malloc_trim_r+0x3c>
   10044:	.word	0x1fff19b0
   10048:	.word	0x1fff85b0
   1004c:	.word	0x1fff1dbc

00010050 <_free_r>:
   10050:	cmp	r1, #0
   10052:	beq.n	100e0 <_free_r+0x90>
   10054:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10058:	mov	r5, r1
   1005a:	mov	r8, r0
   1005c:	bl	b25c <__malloc_lock>
   10060:	ldr.w	r7, [r5, #-4]
   10064:	ldr	r1, [pc, #424]	; (10210 <_free_r+0x1c0>)
   10066:	bic.w	r3, r7, #1
   1006a:	sub.w	r4, r5, #8
   1006e:	adds	r2, r4, r3
   10070:	ldr	r6, [r1, #8]
   10072:	ldr	r0, [r2, #4]
   10074:	cmp	r2, r6
   10076:	bic.w	r0, r0, #3
   1007a:	beq.n	10142 <_free_r+0xf2>
   1007c:	lsls	r6, r7, #31
   1007e:	str	r0, [r2, #4]
   10080:	bmi.n	1009a <_free_r+0x4a>
   10082:	ldr.w	r7, [r5, #-8]
   10086:	subs	r4, r4, r7
   10088:	add.w	lr, r1, #8
   1008c:	ldr	r5, [r4, #8]
   1008e:	cmp	r5, lr
   10090:	add	r3, r7
   10092:	beq.n	10174 <_free_r+0x124>
   10094:	ldr	r7, [r4, #12]
   10096:	str	r7, [r5, #12]
   10098:	str	r5, [r7, #8]
   1009a:	adds	r5, r2, r0
   1009c:	ldr	r5, [r5, #4]
   1009e:	lsls	r5, r5, #31
   100a0:	bpl.n	10128 <_free_r+0xd8>
   100a2:	orr.w	r2, r3, #1
   100a6:	str	r2, [r4, #4]
   100a8:	str	r3, [r4, r3]
   100aa:	cmp.w	r3, #512	; 0x200
   100ae:	bcs.n	100e2 <_free_r+0x92>
   100b0:	lsrs	r3, r3, #3
   100b2:	adds	r2, r3, #1
   100b4:	ldr	r5, [r1, #4]
   100b6:	ldr.w	r7, [r1, r2, lsl #3]
   100ba:	str	r7, [r4, #8]
   100bc:	movs	r0, #1
   100be:	asrs	r3, r3, #2
   100c0:	lsl.w	r3, r0, r3
   100c4:	add.w	r0, r1, r2, lsl #3
   100c8:	orrs	r5, r3
   100ca:	subs	r0, #8
   100cc:	str	r0, [r4, #12]
   100ce:	str	r5, [r1, #4]
   100d0:	str.w	r4, [r1, r2, lsl #3]
   100d4:	str	r4, [r7, #12]
   100d6:	mov	r0, r8
   100d8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   100dc:	b.w	b260 <__malloc_unlock>
   100e0:	bx	lr
   100e2:	lsrs	r2, r3, #9
   100e4:	cmp	r2, #4
   100e6:	bhi.n	10190 <_free_r+0x140>
   100e8:	lsrs	r2, r3, #6
   100ea:	add.w	r7, r2, #57	; 0x39
   100ee:	lsls	r7, r7, #1
   100f0:	add.w	r5, r2, #56	; 0x38
   100f4:	add.w	r0, r1, r7, lsl #2
   100f8:	ldr.w	r2, [r1, r7, lsl #2]
   100fc:	ldr	r1, [pc, #272]	; (10210 <_free_r+0x1c0>)
   100fe:	subs	r0, #8
   10100:	cmp	r0, r2
   10102:	beq.n	101a0 <_free_r+0x150>
   10104:	ldr	r1, [r2, #4]
   10106:	bic.w	r1, r1, #3
   1010a:	cmp	r3, r1
   1010c:	bcs.n	10114 <_free_r+0xc4>
   1010e:	ldr	r2, [r2, #8]
   10110:	cmp	r0, r2
   10112:	bne.n	10104 <_free_r+0xb4>
   10114:	ldr	r0, [r2, #12]
   10116:	str	r0, [r4, #12]
   10118:	str	r2, [r4, #8]
   1011a:	str	r4, [r0, #8]
   1011c:	str	r4, [r2, #12]
   1011e:	mov	r0, r8
   10120:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   10124:	b.w	b260 <__malloc_unlock>
   10128:	ldr	r5, [r2, #8]
   1012a:	ldr	r7, [pc, #232]	; (10214 <_free_r+0x1c4>)
   1012c:	cmp	r5, r7
   1012e:	add	r3, r0
   10130:	beq.n	101b2 <_free_r+0x162>
   10132:	ldr	r0, [r2, #12]
   10134:	str	r0, [r5, #12]
   10136:	orr.w	r2, r3, #1
   1013a:	str	r5, [r0, #8]
   1013c:	str	r2, [r4, #4]
   1013e:	str	r3, [r4, r3]
   10140:	b.n	100aa <_free_r+0x5a>
   10142:	lsls	r7, r7, #31
   10144:	add	r3, r0
   10146:	bmi.n	10158 <_free_r+0x108>
   10148:	ldr.w	r2, [r5, #-8]
   1014c:	subs	r4, r4, r2
   1014e:	add	r3, r2
   10150:	ldr	r0, [r4, #8]
   10152:	ldr	r2, [r4, #12]
   10154:	str	r2, [r0, #12]
   10156:	str	r0, [r2, #8]
   10158:	ldr	r2, [pc, #188]	; (10218 <_free_r+0x1c8>)
   1015a:	ldr	r2, [r2, #0]
   1015c:	orr.w	r0, r3, #1
   10160:	cmp	r3, r2
   10162:	str	r0, [r4, #4]
   10164:	str	r4, [r1, #8]
   10166:	bcc.n	100d6 <_free_r+0x86>
   10168:	ldr	r3, [pc, #176]	; (1021c <_free_r+0x1cc>)
   1016a:	mov	r0, r8
   1016c:	ldr	r1, [r3, #0]
   1016e:	bl	ffb4 <_malloc_trim_r>
   10172:	b.n	100d6 <_free_r+0x86>
   10174:	adds	r1, r2, r0
   10176:	ldr	r1, [r1, #4]
   10178:	lsls	r1, r1, #31
   1017a:	bmi.n	10206 <_free_r+0x1b6>
   1017c:	ldr	r1, [r2, #8]
   1017e:	ldr	r2, [r2, #12]
   10180:	str	r2, [r1, #12]
   10182:	add	r3, r0
   10184:	orr.w	r0, r3, #1
   10188:	str	r1, [r2, #8]
   1018a:	str	r0, [r4, #4]
   1018c:	str	r3, [r4, r3]
   1018e:	b.n	100d6 <_free_r+0x86>
   10190:	cmp	r2, #20
   10192:	bhi.n	101c4 <_free_r+0x174>
   10194:	add.w	r7, r2, #92	; 0x5c
   10198:	lsls	r7, r7, #1
   1019a:	add.w	r5, r2, #91	; 0x5b
   1019e:	b.n	100f4 <_free_r+0xa4>
   101a0:	asrs	r2, r5, #2
   101a2:	ldr	r3, [r1, #4]
   101a4:	movs	r5, #1
   101a6:	lsl.w	r2, r5, r2
   101aa:	orrs	r3, r2
   101ac:	str	r3, [r1, #4]
   101ae:	mov	r2, r0
   101b0:	b.n	10116 <_free_r+0xc6>
   101b2:	orr.w	r2, r3, #1
   101b6:	str	r4, [r1, #20]
   101b8:	str	r4, [r1, #16]
   101ba:	str	r5, [r4, #12]
   101bc:	str	r5, [r4, #8]
   101be:	str	r2, [r4, #4]
   101c0:	str	r3, [r4, r3]
   101c2:	b.n	100d6 <_free_r+0x86>
   101c4:	cmp	r2, #84	; 0x54
   101c6:	bhi.n	101d6 <_free_r+0x186>
   101c8:	lsrs	r2, r3, #12
   101ca:	add.w	r7, r2, #111	; 0x6f
   101ce:	lsls	r7, r7, #1
   101d0:	add.w	r5, r2, #110	; 0x6e
   101d4:	b.n	100f4 <_free_r+0xa4>
   101d6:	cmp.w	r2, #340	; 0x154
   101da:	bhi.n	101ea <_free_r+0x19a>
   101dc:	lsrs	r2, r3, #15
   101de:	add.w	r7, r2, #120	; 0x78
   101e2:	lsls	r7, r7, #1
   101e4:	add.w	r5, r2, #119	; 0x77
   101e8:	b.n	100f4 <_free_r+0xa4>
   101ea:	movw	r0, #1364	; 0x554
   101ee:	cmp	r2, r0
   101f0:	bhi.n	10200 <_free_r+0x1b0>
   101f2:	lsrs	r2, r3, #18
   101f4:	add.w	r7, r2, #125	; 0x7d
   101f8:	lsls	r7, r7, #1
   101fa:	add.w	r5, r2, #124	; 0x7c
   101fe:	b.n	100f4 <_free_r+0xa4>
   10200:	movs	r7, #254	; 0xfe
   10202:	movs	r5, #126	; 0x7e
   10204:	b.n	100f4 <_free_r+0xa4>
   10206:	orr.w	r2, r3, #1
   1020a:	str	r2, [r4, #4]
   1020c:	str	r3, [r4, r3]
   1020e:	b.n	100d6 <_free_r+0x86>
   10210:	.word	0x1fff19b0
   10214:	.word	0x1fff19b8
   10218:	.word	0x1fff1db8
   1021c:	.word	0x1fff85ac

00010220 <rshift>:
   10220:	ldr	r2, [r0, #16]
   10222:	asrs	r3, r1, #5
   10224:	cmp	r3, r2
   10226:	bge.n	10286 <rshift+0x66>
   10228:	push	{r4, r5, r6, r7, lr}
   1022a:	ands.w	r1, r1, #31
   1022e:	add.w	r6, r0, #20
   10232:	add.w	r2, r6, r2, lsl #2
   10236:	add.w	lr, r6, r3, lsl #2
   1023a:	beq.n	10290 <rshift+0x70>
   1023c:	ldr.w	r3, [r6, r3, lsl #2]
   10240:	add.w	r5, lr, #4
   10244:	cmp	r2, r5
   10246:	lsr.w	r4, r3, r1
   1024a:	rsb	ip, r1, #32
   1024e:	bls.n	102c4 <rshift+0xa4>
   10250:	add.w	r7, r0, #16
   10254:	ldr	r3, [r5, #0]
   10256:	lsl.w	r3, r3, ip
   1025a:	orrs	r3, r4
   1025c:	str.w	r3, [r7, #4]!
   10260:	ldr.w	r3, [r5], #4
   10264:	cmp	r2, r5
   10266:	lsr.w	r4, r3, r1
   1026a:	bhi.n	10254 <rshift+0x34>
   1026c:	rsb	r2, lr, r2
   10270:	subs	r2, #5
   10272:	bic.w	r2, r2, #3
   10276:	adds	r2, #4
   10278:	add	r2, r6
   1027a:	str	r4, [r2, #0]
   1027c:	cbz	r4, 10280 <rshift+0x60>
   1027e:	adds	r2, #4
   10280:	subs	r3, r2, r6
   10282:	asrs	r3, r3, #2
   10284:	b.n	102b4 <rshift+0x94>
   10286:	movs	r3, #0
   10288:	str	r3, [r0, #16]
   1028a:	movs	r3, #0
   1028c:	str	r3, [r0, #20]
   1028e:	bx	lr
   10290:	cmp	r2, lr
   10292:	bls.n	102ba <rshift+0x9a>
   10294:	add.w	r4, r0, #16
   10298:	mov	r1, lr
   1029a:	ldr.w	r5, [r1], #4
   1029e:	str.w	r5, [r4, #4]!
   102a2:	cmp	r2, r1
   102a4:	bhi.n	1029a <rshift+0x7a>
   102a6:	mvn.w	r3, lr
   102aa:	add	r3, r2
   102ac:	bic.w	r3, r3, #3
   102b0:	adds	r3, #4
   102b2:	asrs	r3, r3, #2
   102b4:	str	r3, [r0, #16]
   102b6:	cbz	r3, 102be <rshift+0x9e>
   102b8:	pop	{r4, r5, r6, r7, pc}
   102ba:	movs	r3, #0
   102bc:	str	r3, [r0, #16]
   102be:	movs	r3, #0
   102c0:	str	r3, [r0, #20]
   102c2:	pop	{r4, r5, r6, r7, pc}
   102c4:	mov	r2, r6
   102c6:	b.n	1027a <rshift+0x5a>

000102c8 <__gethex>:
   102c8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   102cc:	sub	sp, #44	; 0x2c
   102ce:	mov	r9, r1
   102d0:	str	r0, [sp, #20]
   102d2:	ldr	r0, [sp, #88]	; 0x58
   102d4:	str	r2, [sp, #12]
   102d6:	str	r3, [sp, #32]
   102d8:	bl	109a4 <__localeconv_l>
   102dc:	ldr	r3, [r0, #0]
   102de:	str	r3, [sp, #8]
   102e0:	mov	r0, r3
   102e2:	mov	r4, r3
   102e4:	bl	b740 <strlen>
   102e8:	ldr.w	r3, [r9]
   102ec:	str	r0, [sp, #0]
   102ee:	ldrb	r2, [r3, #2]
   102f0:	adds	r1, r4, r0
   102f2:	cmp	r2, #48	; 0x30
   102f4:	ldrb.w	fp, [r1, #-1]
   102f8:	bne.w	1064e <__gethex+0x386>
   102fc:	adds	r3, #3
   102fe:	mov.w	r8, #0
   10302:	mov	r4, r3
   10304:	ldrb.w	r2, [r3], #1
   10308:	cmp	r2, #48	; 0x30
   1030a:	add.w	r8, r8, #1
   1030e:	beq.n	10302 <__gethex+0x3a>
   10310:	ldr	r6, [pc, #712]	; (105dc <__gethex+0x314>)
   10312:	ldrb	r3, [r6, r2]
   10314:	cmp	r3, #0
   10316:	beq.w	104fa <__gethex+0x232>
   1031a:	ldrb	r3, [r4, #0]
   1031c:	mov.w	sl, #0
   10320:	ldrb	r3, [r6, r3]
   10322:	mov	r5, sl
   10324:	mov	r7, r4
   10326:	cbz	r3, 10332 <__gethex+0x6a>
   10328:	ldrb.w	r3, [r7, #1]!
   1032c:	ldrb	r3, [r6, r3]
   1032e:	cmp	r3, #0
   10330:	bne.n	10328 <__gethex+0x60>
   10332:	ldr	r2, [sp, #0]
   10334:	ldr	r1, [sp, #8]
   10336:	mov	r0, r7
   10338:	bl	b81c <strncmp>
   1033c:	cmp	r0, #0
   1033e:	beq.w	10466 <__gethex+0x19e>
   10342:	ldrb	r3, [r7, #0]
   10344:	cmp	r5, #0
   10346:	beq.w	1062c <__gethex+0x364>
   1034a:	subs	r5, r5, r7
   1034c:	lsls	r2, r5, #2
   1034e:	str	r2, [sp, #4]
   10350:	cmp	r3, #80	; 0x50
   10352:	beq.w	10478 <__gethex+0x1b0>
   10356:	cmp	r3, #112	; 0x70
   10358:	beq.w	10478 <__gethex+0x1b0>
   1035c:	mov	r5, r7
   1035e:	str.w	r7, [r9]
   10362:	cmp.w	sl, #0
   10366:	bne.w	104d8 <__gethex+0x210>
   1036a:	subs	r3, r5, r4
   1036c:	subs	r3, #1
   1036e:	cmp	r3, #7
   10370:	mov	r1, sl
   10372:	ble.n	1037e <__gethex+0xb6>
   10374:	asrs	r3, r3, #1
   10376:	cmp	r3, #7
   10378:	add.w	r1, r1, #1
   1037c:	bgt.n	10374 <__gethex+0xac>
   1037e:	ldr	r0, [sp, #20]
   10380:	bl	10a20 <_Balloc>
   10384:	mov	r3, r0
   10386:	adds	r3, #20
   10388:	cmp	r5, r4
   1038a:	str	r0, [sp, #16]
   1038c:	str	r3, [sp, #28]
   1038e:	bls.w	10738 <__gethex+0x470>
   10392:	mov	r9, r3
   10394:	ldr	r3, [sp, #0]
   10396:	mov.w	r8, #0
   1039a:	rsb	r3, r3, #1
   1039e:	mov	r7, r8
   103a0:	str	r3, [sp, #24]
   103a2:	b.n	103c4 <__gethex+0xfc>
   103a4:	cmp	r7, #32
   103a6:	beq.w	104e8 <__gethex+0x220>
   103aa:	mov	r2, r7
   103ac:	adds	r7, #4
   103ae:	ldrb.w	r3, [r5, #-1]
   103b2:	ldrb	r3, [r6, r3]
   103b4:	mov	r5, sl
   103b6:	and.w	r3, r3, #15
   103ba:	lsls	r3, r2
   103bc:	cmp	r5, r4
   103be:	orr.w	r8, r8, r3
   103c2:	bls.n	103f0 <__gethex+0x128>
   103c4:	ldrb.w	r3, [r5, #-1]
   103c8:	cmp	r3, fp
   103ca:	add.w	sl, r5, #4294967295
   103ce:	bne.n	103a4 <__gethex+0xdc>
   103d0:	ldr	r3, [sp, #24]
   103d2:	add	r3, sl
   103d4:	cmp	r3, r4
   103d6:	bcc.n	103a4 <__gethex+0xdc>
   103d8:	mov	r0, r3
   103da:	ldr	r2, [sp, #0]
   103dc:	ldr	r1, [sp, #8]
   103de:	str	r3, [sp, #36]	; 0x24
   103e0:	bl	b81c <strncmp>
   103e4:	ldr	r3, [sp, #36]	; 0x24
   103e6:	cmp	r0, #0
   103e8:	bne.n	103a4 <__gethex+0xdc>
   103ea:	mov	r5, r3
   103ec:	cmp	r5, r4
   103ee:	bhi.n	103c4 <__gethex+0xfc>
   103f0:	str.w	r8, [r9], #4
   103f4:	ldr	r3, [sp, #28]
   103f6:	ldr	r2, [sp, #16]
   103f8:	rsb	r9, r3, r9
   103fc:	mov.w	r3, r9, asr #2
   10400:	str	r3, [r2, #16]
   10402:	mov	r0, r8
   10404:	mov.w	r9, r3, lsl #5
   10408:	bl	10b98 <__hi0bits>
   1040c:	ldr	r3, [sp, #12]
   1040e:	ldr	r6, [r3, #0]
   10410:	rsb	r0, r0, r9
   10414:	cmp	r0, r6
   10416:	bgt.w	105e0 <__gethex+0x318>
   1041a:	blt.w	10630 <__gethex+0x368>
   1041e:	movs	r7, #0
   10420:	ldr	r3, [sp, #12]
   10422:	ldr	r2, [sp, #4]
   10424:	ldr	r3, [r3, #8]
   10426:	cmp	r2, r3
   10428:	bgt.w	1055a <__gethex+0x292>
   1042c:	ldr	r0, [sp, #12]
   1042e:	ldr	r1, [sp, #4]
   10430:	ldr	r3, [r0, #4]
   10432:	cmp	r1, r3
   10434:	bge.w	105a2 <__gethex+0x2da>
   10438:	subs	r5, r3, r1
   1043a:	cmp	r6, r5
   1043c:	bgt.w	1065e <__gethex+0x396>
   10440:	ldr	r2, [r0, #12]
   10442:	cmp	r2, #2
   10444:	beq.w	10746 <__gethex+0x47e>
   10448:	cmp	r2, #3
   1044a:	beq.w	10706 <__gethex+0x43e>
   1044e:	cmp	r2, #1
   10450:	beq.w	1074e <__gethex+0x486>
   10454:	ldr	r0, [sp, #20]
   10456:	ldr	r1, [sp, #16]
   10458:	bl	10a6c <_Bfree>
   1045c:	ldr	r2, [sp, #80]	; 0x50
   1045e:	movs	r3, #0
   10460:	str	r3, [r2, #0]
   10462:	movs	r0, #80	; 0x50
   10464:	b.n	104e2 <__gethex+0x21a>
   10466:	cmp	r5, #0
   10468:	beq.w	1069e <__gethex+0x3d6>
   1046c:	ldrb	r3, [r7, #0]
   1046e:	b.n	1034a <__gethex+0x82>
   10470:	movs	r3, #0
   10472:	str	r3, [sp, #4]
   10474:	mov.w	sl, #1
   10478:	ldrb	r3, [r7, #1]
   1047a:	cmp	r3, #43	; 0x2b
   1047c:	beq.w	105d8 <__gethex+0x310>
   10480:	cmp	r3, #45	; 0x2d
   10482:	beq.n	10570 <__gethex+0x2a8>
   10484:	adds	r1, r7, #1
   10486:	movs	r5, #0
   10488:	ldrb	r3, [r6, r3]
   1048a:	ldr	r0, [pc, #336]	; (105dc <__gethex+0x314>)
   1048c:	subs	r2, r3, #1
   1048e:	cmp	r2, #24
   10490:	bhi.w	1035c <__gethex+0x94>
   10494:	ldrb	r2, [r1, #1]
   10496:	ldrb	r2, [r0, r2]
   10498:	subs	r0, r2, #1
   1049a:	cmp	r0, #24
   1049c:	sub.w	r3, r3, #16
   104a0:	add.w	r1, r1, #1
   104a4:	bhi.n	104be <__gethex+0x1f6>
   104a6:	ldrb.w	r0, [r1, #1]!
   104aa:	add.w	r3, r3, r3, lsl #2
   104ae:	add.w	r3, r2, r3, lsl #1
   104b2:	ldrb	r2, [r6, r0]
   104b4:	subs	r0, r2, #1
   104b6:	cmp	r0, #24
   104b8:	sub.w	r3, r3, #16
   104bc:	bls.n	104a6 <__gethex+0x1de>
   104be:	cbz	r5, 104c2 <__gethex+0x1fa>
   104c0:	negs	r3, r3
   104c2:	ldr	r2, [sp, #4]
   104c4:	mov	r5, r7
   104c6:	add	r2, r3
   104c8:	mov	r7, r1
   104ca:	str	r2, [sp, #4]
   104cc:	str.w	r7, [r9]
   104d0:	cmp.w	sl, #0
   104d4:	beq.w	1036a <__gethex+0xa2>
   104d8:	cmp.w	r8, #0
   104dc:	ite	eq
   104de:	moveq	r0, #6
   104e0:	movne	r0, #0
   104e2:	add	sp, #44	; 0x2c
   104e4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   104e8:	str.w	r8, [r9]
   104ec:	mov.w	r8, #0
   104f0:	add.w	r9, r9, #4
   104f4:	mov	r2, r8
   104f6:	movs	r7, #4
   104f8:	b.n	103ae <__gethex+0xe6>
   104fa:	ldr	r5, [sp, #0]
   104fc:	ldr	r1, [sp, #8]
   104fe:	mov	r2, r5
   10500:	mov	r0, r4
   10502:	bl	b81c <strncmp>
   10506:	cmp	r0, #0
   10508:	beq.n	10578 <__gethex+0x2b0>
   1050a:	ldrb	r3, [r4, #0]
   1050c:	mov	r7, r4
   1050e:	cmp	r3, #80	; 0x50
   10510:	beq.n	10470 <__gethex+0x1a8>
   10512:	cmp	r3, #112	; 0x70
   10514:	beq.n	10470 <__gethex+0x1a8>
   10516:	str.w	r7, [r9]
   1051a:	b.n	104d8 <__gethex+0x210>
   1051c:	ldr	r3, [sp, #16]
   1051e:	ldr	r3, [r3, #8]
   10520:	cmp	r7, r3
   10522:	bge.w	1078e <__gethex+0x4c6>
   10526:	mov	r3, r7
   10528:	ldr	r0, [sp, #16]
   1052a:	add.w	r2, r0, r3, lsl #2
   1052e:	movs	r1, #1
   10530:	adds	r3, #1
   10532:	cmp	r4, #2
   10534:	str	r3, [r0, #16]
   10536:	str	r1, [r2, #20]
   10538:	beq.w	1076c <__gethex+0x4a4>
   1053c:	cmp	r7, r3
   1053e:	bge.w	106f8 <__gethex+0x430>
   10542:	movs	r1, #1
   10544:	ldr	r0, [sp, #16]
   10546:	bl	10220 <rshift>
   1054a:	ldr	r3, [sp, #12]
   1054c:	ldr	r2, [sp, #4]
   1054e:	ldr	r3, [r3, #8]
   10550:	adds	r2, #1
   10552:	cmp	r2, r3
   10554:	str	r2, [sp, #4]
   10556:	ble.w	106fe <__gethex+0x436>
   1055a:	ldr	r0, [sp, #20]
   1055c:	ldr	r1, [sp, #16]
   1055e:	bl	10a6c <_Bfree>
   10562:	ldr	r2, [sp, #80]	; 0x50
   10564:	movs	r3, #0
   10566:	movs	r0, #163	; 0xa3
   10568:	str	r3, [r2, #0]
   1056a:	add	sp, #44	; 0x2c
   1056c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10570:	movs	r5, #1
   10572:	ldrb	r3, [r7, #2]
   10574:	adds	r1, r7, #2
   10576:	b.n	10488 <__gethex+0x1c0>
   10578:	ldrb	r2, [r4, r5]
   1057a:	ldrb	r3, [r6, r2]
   1057c:	adds	r7, r4, r5
   1057e:	cmp	r3, #0
   10580:	beq.n	10656 <__gethex+0x38e>
   10582:	cmp	r2, #48	; 0x30
   10584:	mov	r4, r7
   10586:	bne.n	10592 <__gethex+0x2ca>
   10588:	ldrb.w	r3, [r4, #1]!
   1058c:	cmp	r3, #48	; 0x30
   1058e:	beq.n	10588 <__gethex+0x2c0>
   10590:	ldrb	r3, [r6, r3]
   10592:	clz	sl, r3
   10596:	mov	r5, r7
   10598:	mov.w	sl, sl, lsr #5
   1059c:	mov.w	r8, #1
   105a0:	b.n	10324 <__gethex+0x5c>
   105a2:	movs	r4, #1
   105a4:	cbz	r7, 105c0 <__gethex+0x2f8>
   105a6:	ldr	r3, [sp, #12]
   105a8:	ldr	r3, [r3, #12]
   105aa:	cmp	r3, #2
   105ac:	beq.w	106ba <__gethex+0x3f2>
   105b0:	cmp	r3, #3
   105b2:	beq.w	106c2 <__gethex+0x3fa>
   105b6:	cmp	r3, #1
   105b8:	beq.w	10726 <__gethex+0x45e>
   105bc:	orr.w	r4, r4, #16
   105c0:	ldr	r3, [sp, #80]	; 0x50
   105c2:	mov	r2, r3
   105c4:	ldr	r3, [sp, #16]
   105c6:	str	r3, [r2, #0]
   105c8:	ldr	r3, [sp, #32]
   105ca:	mov	r2, r3
   105cc:	ldr	r3, [sp, #4]
   105ce:	str	r3, [r2, #0]
   105d0:	mov	r0, r4
   105d2:	add	sp, #44	; 0x2c
   105d4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   105d8:	movs	r5, #0
   105da:	b.n	10572 <__gethex+0x2aa>
   105dc:	.word	0x00012afc
   105e0:	subs	r4, r0, r6
   105e2:	mov	r1, r4
   105e4:	ldr	r0, [sp, #16]
   105e6:	bl	112a8 <__any_on>
   105ea:	cmp	r0, #0
   105ec:	beq.n	1065a <__gethex+0x392>
   105ee:	subs	r2, r4, #1
   105f0:	asrs	r1, r2, #5
   105f2:	ldr	r0, [sp, #28]
   105f4:	and.w	r3, r2, #31
   105f8:	ldr.w	r1, [r0, r1, lsl #2]
   105fc:	movs	r7, #1
   105fe:	lsl.w	r3, r7, r3
   10602:	tst	r3, r1
   10604:	beq.n	1061c <__gethex+0x354>
   10606:	cmp	r2, r7
   10608:	ble.w	10742 <__gethex+0x47a>
   1060c:	subs	r1, r4, #2
   1060e:	ldr	r0, [sp, #16]
   10610:	bl	112a8 <__any_on>
   10614:	cmp	r0, #0
   10616:	beq.w	10742 <__gethex+0x47a>
   1061a:	movs	r7, #3
   1061c:	ldr	r3, [sp, #4]
   1061e:	ldr	r0, [sp, #16]
   10620:	add	r3, r4
   10622:	mov	r1, r4
   10624:	str	r3, [sp, #4]
   10626:	bl	10220 <rshift>
   1062a:	b.n	10420 <__gethex+0x158>
   1062c:	str	r5, [sp, #4]
   1062e:	b.n	10350 <__gethex+0x88>
   10630:	subs	r4, r6, r0
   10632:	ldr	r1, [sp, #16]
   10634:	ldr	r0, [sp, #20]
   10636:	mov	r2, r4
   10638:	bl	10e18 <__lshift>
   1063c:	ldr	r3, [sp, #4]
   1063e:	str	r0, [sp, #16]
   10640:	subs	r3, r3, r4
   10642:	str	r3, [sp, #4]
   10644:	mov	r3, r0
   10646:	adds	r3, #20
   10648:	str	r3, [sp, #28]
   1064a:	movs	r7, #0
   1064c:	b.n	10420 <__gethex+0x158>
   1064e:	adds	r4, r3, #2
   10650:	mov.w	r8, #0
   10654:	b.n	10310 <__gethex+0x48>
   10656:	mov	r3, r2
   10658:	b.n	1050e <__gethex+0x246>
   1065a:	mov	r7, r0
   1065c:	b.n	1061c <__gethex+0x354>
   1065e:	subs	r4, r5, #1
   10660:	cmp	r7, #0
   10662:	bne.n	10702 <__gethex+0x43a>
   10664:	cbz	r4, 10670 <__gethex+0x3a8>
   10666:	mov	r1, r4
   10668:	ldr	r0, [sp, #16]
   1066a:	bl	112a8 <__any_on>
   1066e:	mov	r7, r0
   10670:	asrs	r3, r4, #5
   10672:	ldr	r2, [sp, #28]
   10674:	ldr	r0, [sp, #16]
   10676:	ldr.w	r2, [r2, r3, lsl #2]
   1067a:	and.w	r4, r4, #31
   1067e:	movs	r3, #1
   10680:	lsl.w	r4, r3, r4
   10684:	tst	r4, r2
   10686:	mov	r1, r5
   10688:	it	ne
   1068a:	orrne.w	r7, r7, #2
   1068e:	bl	10220 <rshift>
   10692:	ldr	r3, [sp, #12]
   10694:	ldr	r3, [r3, #4]
   10696:	str	r3, [sp, #4]
   10698:	subs	r6, r6, r5
   1069a:	movs	r4, #2
   1069c:	b.n	105a4 <__gethex+0x2dc>
   1069e:	ldr	r1, [sp, #0]
   106a0:	ldrb	r3, [r7, r1]
   106a2:	ldrb	r2, [r6, r3]
   106a4:	adds	r5, r7, r1
   106a6:	mov	r7, r5
   106a8:	cmp	r2, #0
   106aa:	beq.w	1034a <__gethex+0x82>
   106ae:	ldrb.w	r3, [r7, #1]!
   106b2:	ldrb	r2, [r6, r3]
   106b4:	cmp	r2, #0
   106b6:	bne.n	106ae <__gethex+0x3e6>
   106b8:	b.n	1034a <__gethex+0x82>
   106ba:	ldr	r3, [sp, #84]	; 0x54
   106bc:	rsb	r3, r3, #1
   106c0:	str	r3, [sp, #84]	; 0x54
   106c2:	ldr	r3, [sp, #84]	; 0x54
   106c4:	cmp	r3, #0
   106c6:	beq.w	105bc <__gethex+0x2f4>
   106ca:	ldr	r3, [sp, #16]
   106cc:	ldr	r5, [sp, #28]
   106ce:	ldr	r7, [r3, #16]
   106d0:	mov.w	r8, r7, lsl #2
   106d4:	add.w	r0, r5, r8
   106d8:	mov	r3, r5
   106da:	movs	r1, #0
   106dc:	b.n	106e8 <__gethex+0x420>
   106de:	str.w	r1, [r3], #4
   106e2:	cmp	r0, r3
   106e4:	bls.w	1051c <__gethex+0x254>
   106e8:	ldr	r2, [r3, #0]
   106ea:	cmp.w	r2, #4294967295
   106ee:	beq.n	106de <__gethex+0x416>
   106f0:	adds	r2, #1
   106f2:	cmp	r4, #2
   106f4:	str	r2, [r3, #0]
   106f6:	beq.n	1076c <__gethex+0x4a4>
   106f8:	ands.w	r6, r6, #31
   106fc:	bne.n	1077a <__gethex+0x4b2>
   106fe:	movs	r4, #33	; 0x21
   10700:	b.n	105c0 <__gethex+0x2f8>
   10702:	movs	r7, #1
   10704:	b.n	10670 <__gethex+0x3a8>
   10706:	ldr	r2, [sp, #84]	; 0x54
   10708:	cmp	r2, #0
   1070a:	beq.w	10454 <__gethex+0x18c>
   1070e:	ldr	r1, [sp, #32]
   10710:	str	r3, [r1, #0]
   10712:	ldr	r3, [sp, #28]
   10714:	ldr	r1, [sp, #16]
   10716:	movs	r2, #1
   10718:	str	r2, [r1, #16]
   1071a:	str	r2, [r3, #0]
   1071c:	ldr	r3, [sp, #80]	; 0x50
   1071e:	mov	r2, r3
   10720:	movs	r0, #98	; 0x62
   10722:	str	r1, [r2, #0]
   10724:	b.n	104e2 <__gethex+0x21a>
   10726:	lsls	r2, r7, #30
   10728:	bpl.w	105bc <__gethex+0x2f4>
   1072c:	ldr	r3, [sp, #28]
   1072e:	ldr	r3, [r3, #0]
   10730:	orrs	r3, r7
   10732:	lsls	r3, r3, #31
   10734:	bmi.n	106ca <__gethex+0x402>
   10736:	b.n	105bc <__gethex+0x2f4>
   10738:	ldr.w	r9, [sp, #28]
   1073c:	mov.w	r8, #0
   10740:	b.n	103f0 <__gethex+0x128>
   10742:	movs	r7, #2
   10744:	b.n	1061c <__gethex+0x354>
   10746:	ldr	r2, [sp, #84]	; 0x54
   10748:	cmp	r2, #0
   1074a:	beq.n	1070e <__gethex+0x446>
   1074c:	b.n	10454 <__gethex+0x18c>
   1074e:	cmp	r6, r5
   10750:	bne.w	10454 <__gethex+0x18c>
   10754:	cmp	r6, #1
   10756:	ble.n	1070e <__gethex+0x446>
   10758:	subs	r1, r6, #1
   1075a:	ldr	r0, [sp, #16]
   1075c:	bl	112a8 <__any_on>
   10760:	cmp	r0, #0
   10762:	beq.w	10454 <__gethex+0x18c>
   10766:	ldr	r3, [sp, #12]
   10768:	ldr	r3, [r3, #4]
   1076a:	b.n	1070e <__gethex+0x446>
   1076c:	ldr	r3, [sp, #12]
   1076e:	ldr	r3, [r3, #0]
   10770:	subs	r3, #1
   10772:	cmp	r6, r3
   10774:	beq.n	107c0 <__gethex+0x4f8>
   10776:	movs	r4, #34	; 0x22
   10778:	b.n	105c0 <__gethex+0x2f8>
   1077a:	add	r5, r8
   1077c:	rsb	r6, r6, #32
   10780:	ldr.w	r0, [r5, #-4]
   10784:	bl	10b98 <__hi0bits>
   10788:	cmp	r0, r6
   1078a:	bge.n	106fe <__gethex+0x436>
   1078c:	b.n	10542 <__gethex+0x27a>
   1078e:	ldr	r3, [sp, #16]
   10790:	ldr.w	r9, [sp, #20]
   10794:	ldr	r1, [r3, #4]
   10796:	mov	r0, r9
   10798:	adds	r1, #1
   1079a:	bl	10a20 <_Balloc>
   1079e:	ldr	r1, [sp, #16]
   107a0:	ldr	r3, [r1, #16]
   107a2:	adds	r2, r3, #2
   107a4:	mov	r5, r0
   107a6:	lsls	r2, r2, #2
   107a8:	adds	r1, #12
   107aa:	adds	r0, #12
   107ac:	bl	8734 <memcpy>
   107b0:	ldr	r1, [sp, #16]
   107b2:	mov	r0, r9
   107b4:	bl	10a6c <_Bfree>
   107b8:	str	r5, [sp, #16]
   107ba:	ldr	r3, [r5, #16]
   107bc:	adds	r5, #20
   107be:	b.n	10528 <__gethex+0x260>
   107c0:	asrs	r3, r6, #5
   107c2:	and.w	r6, r6, #31
   107c6:	ldr.w	r2, [r5, r3, lsl #2]
   107ca:	movs	r3, #1
   107cc:	lsls	r3, r6
   107ce:	tst	r3, r2
   107d0:	ite	ne
   107d2:	movne	r4, #33	; 0x21
   107d4:	moveq	r4, #34	; 0x22
   107d6:	b.n	105c0 <__gethex+0x2f8>

000107d8 <__match>:
   107d8:	push	{r4, r5}
   107da:	ldr	r4, [r0, #0]
   107dc:	b.n	107f0 <__match+0x18>
   107de:	ldrb.w	r3, [r4, #1]!
   107e2:	sub.w	r5, r3, #65	; 0x41
   107e6:	cmp	r5, #25
   107e8:	it	ls
   107ea:	addls	r3, #32
   107ec:	cmp	r3, r2
   107ee:	bne.n	10802 <__match+0x2a>
   107f0:	ldrb.w	r2, [r1], #1
   107f4:	cmp	r2, #0
   107f6:	bne.n	107de <__match+0x6>
   107f8:	adds	r4, #1
   107fa:	str	r4, [r0, #0]
   107fc:	movs	r0, #1
   107fe:	pop	{r4, r5}
   10800:	bx	lr
   10802:	movs	r0, #0
   10804:	pop	{r4, r5}
   10806:	bx	lr

00010808 <__hexnan>:
   10808:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1080c:	ldr	r3, [r1, #0]
   1080e:	ldr.w	r9, [pc, #372]	; 10984 <__hexnan+0x17c>
   10812:	sub	sp, #20
   10814:	asrs	r1, r3, #5
   10816:	add.w	r1, r2, r1, lsl #2
   1081a:	ands.w	r3, r3, #31
   1081e:	str	r1, [sp, #4]
   10820:	itt	ne
   10822:	addne	r1, #4
   10824:	strne	r1, [sp, #4]
   10826:	ldr	r4, [sp, #4]
   10828:	str	r0, [sp, #8]
   1082a:	str	r3, [sp, #12]
   1082c:	movs	r3, #0
   1082e:	mov	r1, r3
   10830:	str.w	r3, [r4, #-4]
   10834:	mov	sl, r3
   10836:	mov	lr, r3
   10838:	ldr	r3, [sp, #8]
   1083a:	sub.w	ip, r4, #4
   1083e:	ldr	r5, [r3, #0]
   10840:	mov	r8, ip
   10842:	mov	r0, ip
   10844:	ldrb.w	r3, [r5, #1]!
   10848:	cbz	r3, 10894 <__hexnan+0x8c>
   1084a:	ldrb.w	r4, [r9, r3]
   1084e:	cmp	r4, #0
   10850:	bne.n	108da <__hexnan+0xd2>
   10852:	cmp	r3, #32
   10854:	bhi.n	10912 <__hexnan+0x10a>
   10856:	cmp	lr, sl
   10858:	ble.n	10844 <__hexnan+0x3c>
   1085a:	cmp	r0, r8
   1085c:	bcs.n	10886 <__hexnan+0x7e>
   1085e:	cmp	r1, #7
   10860:	bgt.n	10886 <__hexnan+0x7e>
   10862:	rsb	r1, r1, #8
   10866:	lsls	r1, r1, #2
   10868:	ldr	r6, [r0, #0]
   1086a:	rsb	fp, r1, #32
   1086e:	mov	r3, r0
   10870:	ldr	r7, [r3, #4]
   10872:	lsl.w	r4, r7, fp
   10876:	orrs	r4, r6
   10878:	lsr.w	r6, r7, r1
   1087c:	str	r4, [r3, #0]
   1087e:	str.w	r6, [r3, #4]!
   10882:	cmp	r8, r3
   10884:	bhi.n	10870 <__hexnan+0x68>
   10886:	cmp	r0, r2
   10888:	bhi.n	10900 <__hexnan+0xf8>
   1088a:	ldrb.w	r3, [r5, #1]!
   1088e:	movs	r1, #8
   10890:	cmp	r3, #0
   10892:	bne.n	1084a <__hexnan+0x42>
   10894:	cmp.w	lr, #0
   10898:	beq.n	10916 <__hexnan+0x10e>
   1089a:	cmp	r0, r8
   1089c:	bcs.n	108a2 <__hexnan+0x9a>
   1089e:	cmp	r1, #7
   108a0:	ble.n	1095c <__hexnan+0x154>
   108a2:	cmp	r0, r2
   108a4:	bls.n	1091e <__hexnan+0x116>
   108a6:	mov	r3, r2
   108a8:	ldr.w	r1, [r0], #4
   108ac:	str.w	r1, [r3], #4
   108b0:	cmp	ip, r0
   108b2:	bcs.n	108a8 <__hexnan+0xa0>
   108b4:	movs	r1, #0
   108b6:	str.w	r1, [r3], #4
   108ba:	cmp	ip, r3
   108bc:	bcs.n	108b6 <__hexnan+0xae>
   108be:	ldr	r3, [sp, #4]
   108c0:	ldr.w	r3, [r3, #-4]
   108c4:	cbnz	r3, 108d2 <__hexnan+0xca>
   108c6:	cmp	r2, ip
   108c8:	beq.n	10940 <__hexnan+0x138>
   108ca:	ldr.w	r3, [ip, #-4]!
   108ce:	cmp	r3, #0
   108d0:	beq.n	108c6 <__hexnan+0xbe>
   108d2:	movs	r0, #5
   108d4:	add	sp, #20
   108d6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   108da:	adds	r1, #1
   108dc:	cmp	r1, #8
   108de:	add.w	lr, lr, #1
   108e2:	ble.n	108f2 <__hexnan+0xea>
   108e4:	cmp	r0, r2
   108e6:	bls.n	10844 <__hexnan+0x3c>
   108e8:	movs	r3, #0
   108ea:	str.w	r3, [r0, #-4]
   108ee:	movs	r1, #1
   108f0:	subs	r0, #4
   108f2:	ldr	r3, [r0, #0]
   108f4:	and.w	r4, r4, #15
   108f8:	orr.w	r4, r4, r3, lsl #4
   108fc:	str	r4, [r0, #0]
   108fe:	b.n	10844 <__hexnan+0x3c>
   10900:	movs	r3, #0
   10902:	sub.w	r8, r0, #4
   10906:	str.w	r3, [r0, #-4]
   1090a:	mov	sl, lr
   1090c:	mov	r0, r8
   1090e:	mov	r1, r3
   10910:	b.n	10844 <__hexnan+0x3c>
   10912:	cmp	r3, #41	; 0x29
   10914:	beq.n	1094e <__hexnan+0x146>
   10916:	movs	r0, #4
   10918:	add	sp, #20
   1091a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1091e:	ldr	r3, [sp, #12]
   10920:	cmp	r3, #0
   10922:	beq.n	108be <__hexnan+0xb6>
   10924:	ldr	r4, [sp, #4]
   10926:	ldr	r3, [sp, #12]
   10928:	ldr.w	r1, [r4, #-4]
   1092c:	rsb	r3, r3, #32
   10930:	mov.w	r0, #4294967295
   10934:	lsr.w	r3, r0, r3
   10938:	ands	r3, r1
   1093a:	str.w	r3, [r4, #-4]
   1093e:	b.n	108c4 <__hexnan+0xbc>
   10940:	movs	r3, #1
   10942:	movs	r0, #5
   10944:	str.w	r3, [ip]
   10948:	add	sp, #20
   1094a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1094e:	ldr	r3, [sp, #8]
   10950:	adds	r5, #1
   10952:	str	r5, [r3, #0]
   10954:	cmp.w	lr, #0
   10958:	bne.n	1089a <__hexnan+0x92>
   1095a:	b.n	10916 <__hexnan+0x10e>
   1095c:	rsb	r3, r1, #8
   10960:	lsls	r3, r3, #2
   10962:	ldr	r5, [r0, #0]
   10964:	rsb	r7, r3, #32
   10968:	mov	r1, r0
   1096a:	ldr	r6, [r1, #4]
   1096c:	lsl.w	r4, r6, r7
   10970:	orrs	r4, r5
   10972:	lsr.w	r5, r6, r3
   10976:	str	r4, [r1, #0]
   10978:	str.w	r5, [r1, #4]!
   1097c:	cmp	r8, r1
   1097e:	bhi.n	1096a <__hexnan+0x162>
   10980:	b.n	108a2 <__hexnan+0x9a>
   10982:	nop
   10984:	.word	0x00012afc

00010988 <iswspace>:
   10988:	cmp	r0, #255	; 0xff
   1098a:	bls.n	10990 <iswspace+0x8>
   1098c:	movs	r0, #0
   1098e:	bx	lr
   10990:	push	{r4, lr}
   10992:	mov	r4, r0
   10994:	bl	aabc <__locale_ctype_ptr>
   10998:	add	r0, r4
   1099a:	ldrb	r0, [r0, #1]
   1099c:	and.w	r0, r0, #8
   109a0:	uxtb	r0, r0
   109a2:	pop	{r4, pc}

000109a4 <__localeconv_l>:
   109a4:	adds	r0, #240	; 0xf0
   109a6:	bx	lr

000109a8 <_localeconv_r>:
   109a8:	ldr	r2, [pc, #16]	; (109bc <_localeconv_r+0x14>)
   109aa:	ldr	r3, [pc, #20]	; (109c0 <_localeconv_r+0x18>)
   109ac:	ldr	r2, [r2, #0]
   109ae:	ldr	r0, [r2, #52]	; 0x34
   109b0:	cmp	r0, #0
   109b2:	it	eq
   109b4:	moveq	r0, r3
   109b6:	adds	r0, #240	; 0xf0
   109b8:	bx	lr
   109ba:	nop
   109bc:	.word	0x1fff1840
   109c0:	.word	0x1fff1844

000109c4 <_mbrtowc_r>:
   109c4:	push	{r4, r5, r6, r7, lr}
   109c6:	sub	sp, #12
   109c8:	mov	r7, r0
   109ca:	ldr	r5, [sp, #32]
   109cc:	cbz	r2, 109f4 <_mbrtowc_r+0x30>
   109ce:	ldr	r4, [pc, #68]	; (10a14 <_mbrtowc_r+0x50>)
   109d0:	ldr	r6, [pc, #68]	; (10a18 <_mbrtowc_r+0x54>)
   109d2:	ldr	r4, [r4, #0]
   109d4:	ldr	r4, [r4, #52]	; 0x34
   109d6:	str	r5, [sp, #0]
   109d8:	cmp	r4, #0
   109da:	it	eq
   109dc:	moveq	r4, r6
   109de:	ldr.w	r4, [r4, #228]	; 0xe4
   109e2:	blx	r4
   109e4:	adds	r3, r0, #1
   109e6:	bne.n	109f0 <_mbrtowc_r+0x2c>
   109e8:	movs	r2, #0
   109ea:	movs	r3, #138	; 0x8a
   109ec:	str	r2, [r5, #0]
   109ee:	str	r3, [r7, #0]
   109f0:	add	sp, #12
   109f2:	pop	{r4, r5, r6, r7, pc}
   109f4:	ldr	r3, [pc, #28]	; (10a14 <_mbrtowc_r+0x50>)
   109f6:	ldr	r1, [pc, #32]	; (10a18 <_mbrtowc_r+0x54>)
   109f8:	ldr	r3, [r3, #0]
   109fa:	ldr	r3, [r3, #52]	; 0x34
   109fc:	str	r5, [sp, #0]
   109fe:	cmp	r3, #0
   10a00:	it	eq
   10a02:	moveq	r3, r1
   10a04:	mov	r4, r2
   10a06:	mov	r1, r4
   10a08:	ldr	r2, [pc, #16]	; (10a1c <_mbrtowc_r+0x58>)
   10a0a:	ldr.w	r4, [r3, #228]	; 0xe4
   10a0e:	movs	r3, #1
   10a10:	blx	r4
   10a12:	b.n	109e4 <_mbrtowc_r+0x20>
   10a14:	.word	0x1fff1840
   10a18:	.word	0x1fff1844
   10a1c:	.word	0x00012988

00010a20 <_Balloc>:
   10a20:	ldr	r3, [r0, #76]	; 0x4c
   10a22:	push	{r4, r5, r6, lr}
   10a24:	mov	r5, r0
   10a26:	mov	r4, r1
   10a28:	cbz	r3, 10a3e <_Balloc+0x1e>
   10a2a:	ldr.w	r0, [r3, r4, lsl #2]
   10a2e:	cbz	r0, 10a52 <_Balloc+0x32>
   10a30:	ldr	r2, [r0, #0]
   10a32:	str.w	r2, [r3, r4, lsl #2]
   10a36:	movs	r3, #0
   10a38:	str	r3, [r0, #16]
   10a3a:	str	r3, [r0, #12]
   10a3c:	pop	{r4, r5, r6, pc}
   10a3e:	movs	r2, #33	; 0x21
   10a40:	movs	r1, #4
   10a42:	bl	11c04 <_calloc_r>
   10a46:	str	r0, [r5, #76]	; 0x4c
   10a48:	mov	r3, r0
   10a4a:	cmp	r0, #0
   10a4c:	bne.n	10a2a <_Balloc+0xa>
   10a4e:	movs	r0, #0
   10a50:	pop	{r4, r5, r6, pc}
   10a52:	movs	r1, #1
   10a54:	lsl.w	r6, r1, r4
   10a58:	adds	r2, r6, #5
   10a5a:	mov	r0, r5
   10a5c:	lsls	r2, r2, #2
   10a5e:	bl	11c04 <_calloc_r>
   10a62:	cmp	r0, #0
   10a64:	beq.n	10a4e <_Balloc+0x2e>
   10a66:	str	r4, [r0, #4]
   10a68:	str	r6, [r0, #8]
   10a6a:	b.n	10a36 <_Balloc+0x16>

00010a6c <_Bfree>:
   10a6c:	cbz	r1, 10a7c <_Bfree+0x10>
   10a6e:	ldr	r3, [r0, #76]	; 0x4c
   10a70:	ldr	r2, [r1, #4]
   10a72:	ldr.w	r0, [r3, r2, lsl #2]
   10a76:	str	r0, [r1, #0]
   10a78:	str.w	r1, [r3, r2, lsl #2]
   10a7c:	bx	lr
   10a7e:	nop

00010a80 <__multadd>:
   10a80:	push	{r4, r5, r6, r7, lr}
   10a82:	ldr	r4, [r1, #16]
   10a84:	sub	sp, #12
   10a86:	mov	r5, r1
   10a88:	mov	r6, r0
   10a8a:	add.w	lr, r1, #20
   10a8e:	movs	r7, #0
   10a90:	ldr.w	r0, [lr]
   10a94:	uxth	r1, r0
   10a96:	mla	r1, r2, r1, r3
   10a9a:	lsrs	r3, r1, #16
   10a9c:	lsrs	r0, r0, #16
   10a9e:	mla	r3, r2, r0, r3
   10aa2:	uxth	r1, r1
   10aa4:	adds	r7, #1
   10aa6:	add.w	r1, r1, r3, lsl #16
   10aaa:	cmp	r4, r7
   10aac:	str.w	r1, [lr], #4
   10ab0:	mov.w	r3, r3, lsr #16
   10ab4:	bgt.n	10a90 <__multadd+0x10>
   10ab6:	cbz	r3, 10ac8 <__multadd+0x48>
   10ab8:	ldr	r2, [r5, #8]
   10aba:	cmp	r4, r2
   10abc:	bge.n	10ace <__multadd+0x4e>
   10abe:	add.w	r2, r5, r4, lsl #2
   10ac2:	adds	r4, #1
   10ac4:	str	r3, [r2, #20]
   10ac6:	str	r4, [r5, #16]
   10ac8:	mov	r0, r5
   10aca:	add	sp, #12
   10acc:	pop	{r4, r5, r6, r7, pc}
   10ace:	ldr	r1, [r5, #4]
   10ad0:	str	r3, [sp, #4]
   10ad2:	adds	r1, #1
   10ad4:	mov	r0, r6
   10ad6:	bl	10a20 <_Balloc>
   10ada:	ldr	r2, [r5, #16]
   10adc:	adds	r2, #2
   10ade:	add.w	r1, r5, #12
   10ae2:	mov	r7, r0
   10ae4:	lsls	r2, r2, #2
   10ae6:	adds	r0, #12
   10ae8:	bl	8734 <memcpy>
   10aec:	ldr	r2, [r6, #76]	; 0x4c
   10aee:	ldr	r1, [r5, #4]
   10af0:	ldr	r3, [sp, #4]
   10af2:	ldr.w	r0, [r2, r1, lsl #2]
   10af6:	str	r0, [r5, #0]
   10af8:	str.w	r5, [r2, r1, lsl #2]
   10afc:	mov	r5, r7
   10afe:	b.n	10abe <__multadd+0x3e>

00010b00 <__s2b>:
   10b00:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   10b04:	ldr	r4, [pc, #140]	; (10b94 <__s2b+0x94>)
   10b06:	ldr	r5, [sp, #32]
   10b08:	mov	r7, r3
   10b0a:	adds	r3, #8
   10b0c:	smull	r4, lr, r4, r3
   10b10:	asrs	r3, r3, #31
   10b12:	rsb	lr, r3, lr, asr #1
   10b16:	cmp.w	lr, #1
   10b1a:	mov	r6, r0
   10b1c:	mov	r4, r1
   10b1e:	mov	r8, r2
   10b20:	ble.n	10b8e <__s2b+0x8e>
   10b22:	movs	r3, #1
   10b24:	movs	r1, #0
   10b26:	lsls	r3, r3, #1
   10b28:	cmp	lr, r3
   10b2a:	add.w	r1, r1, #1
   10b2e:	bgt.n	10b26 <__s2b+0x26>
   10b30:	mov	r0, r6
   10b32:	bl	10a20 <_Balloc>
   10b36:	movs	r3, #1
   10b38:	cmp.w	r8, #9
   10b3c:	str	r5, [r0, #20]
   10b3e:	str	r3, [r0, #16]
   10b40:	ble.n	10b86 <__s2b+0x86>
   10b42:	add.w	r9, r4, #9
   10b46:	mov	r5, r9
   10b48:	add	r4, r8
   10b4a:	ldrb.w	r3, [r5], #1
   10b4e:	mov	r1, r0
   10b50:	subs	r3, #48	; 0x30
   10b52:	movs	r2, #10
   10b54:	mov	r0, r6
   10b56:	bl	10a80 <__multadd>
   10b5a:	cmp	r5, r4
   10b5c:	bne.n	10b4a <__s2b+0x4a>
   10b5e:	add.w	r4, r9, r8
   10b62:	subs	r4, #8
   10b64:	cmp	r7, r8
   10b66:	ble.n	10b82 <__s2b+0x82>
   10b68:	rsb	r7, r8, r7
   10b6c:	add	r7, r4
   10b6e:	ldrb.w	r3, [r4], #1
   10b72:	mov	r1, r0
   10b74:	subs	r3, #48	; 0x30
   10b76:	movs	r2, #10
   10b78:	mov	r0, r6
   10b7a:	bl	10a80 <__multadd>
   10b7e:	cmp	r7, r4
   10b80:	bne.n	10b6e <__s2b+0x6e>
   10b82:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   10b86:	adds	r4, #10
   10b88:	mov.w	r8, #9
   10b8c:	b.n	10b64 <__s2b+0x64>
   10b8e:	movs	r1, #0
   10b90:	b.n	10b30 <__s2b+0x30>
   10b92:	nop
   10b94:	.word	0x38e38e39

00010b98 <__hi0bits>:
   10b98:	lsrs	r3, r0, #16
   10b9a:	lsls	r3, r3, #16
   10b9c:	cbnz	r3, 10bcc <__hi0bits+0x34>
   10b9e:	lsls	r0, r0, #16
   10ba0:	movs	r3, #16
   10ba2:	tst.w	r0, #4278190080	; 0xff000000
   10ba6:	itt	eq
   10ba8:	lsleq	r0, r0, #8
   10baa:	addeq	r3, #8
   10bac:	tst.w	r0, #4026531840	; 0xf0000000
   10bb0:	itt	eq
   10bb2:	lsleq	r0, r0, #4
   10bb4:	addeq	r3, #4
   10bb6:	tst.w	r0, #3221225472	; 0xc0000000
   10bba:	itt	eq
   10bbc:	lsleq	r0, r0, #2
   10bbe:	addeq	r3, #2
   10bc0:	cmp	r0, #0
   10bc2:	blt.n	10bd4 <__hi0bits+0x3c>
   10bc4:	lsls	r2, r0, #1
   10bc6:	bmi.n	10bd0 <__hi0bits+0x38>
   10bc8:	movs	r0, #32
   10bca:	bx	lr
   10bcc:	movs	r3, #0
   10bce:	b.n	10ba2 <__hi0bits+0xa>
   10bd0:	adds	r0, r3, #1
   10bd2:	bx	lr
   10bd4:	mov	r0, r3
   10bd6:	bx	lr

00010bd8 <__lo0bits>:
   10bd8:	ldr	r3, [r0, #0]
   10bda:	ands.w	r2, r3, #7
   10bde:	beq.n	10bf0 <__lo0bits+0x18>
   10be0:	lsls	r1, r3, #31
   10be2:	bmi.n	10c26 <__lo0bits+0x4e>
   10be4:	lsls	r2, r3, #30
   10be6:	bmi.n	10c2a <__lo0bits+0x52>
   10be8:	lsrs	r3, r3, #2
   10bea:	str	r3, [r0, #0]
   10bec:	movs	r0, #2
   10bee:	bx	lr
   10bf0:	uxth	r1, r3
   10bf2:	cbnz	r1, 10bf8 <__lo0bits+0x20>
   10bf4:	lsrs	r3, r3, #16
   10bf6:	movs	r2, #16
   10bf8:	tst.w	r3, #255	; 0xff
   10bfc:	itt	eq
   10bfe:	lsreq	r3, r3, #8
   10c00:	addeq	r2, #8
   10c02:	lsls	r1, r3, #28
   10c04:	itt	eq
   10c06:	lsreq	r3, r3, #4
   10c08:	addeq	r2, #4
   10c0a:	lsls	r1, r3, #30
   10c0c:	itt	eq
   10c0e:	lsreq	r3, r3, #2
   10c10:	addeq	r2, #2
   10c12:	lsls	r1, r3, #31
   10c14:	bmi.n	10c20 <__lo0bits+0x48>
   10c16:	lsrs	r3, r3, #1
   10c18:	bne.n	10c1e <__lo0bits+0x46>
   10c1a:	movs	r0, #32
   10c1c:	bx	lr
   10c1e:	adds	r2, #1
   10c20:	str	r3, [r0, #0]
   10c22:	mov	r0, r2
   10c24:	bx	lr
   10c26:	movs	r0, #0
   10c28:	bx	lr
   10c2a:	lsrs	r3, r3, #1
   10c2c:	str	r3, [r0, #0]
   10c2e:	movs	r0, #1
   10c30:	bx	lr
   10c32:	nop

00010c34 <__i2b>:
   10c34:	push	{r4, lr}
   10c36:	mov	r4, r1
   10c38:	movs	r1, #1
   10c3a:	bl	10a20 <_Balloc>
   10c3e:	movs	r2, #1
   10c40:	str	r4, [r0, #20]
   10c42:	str	r2, [r0, #16]
   10c44:	pop	{r4, pc}
   10c46:	nop

00010c48 <__multiply>:
   10c48:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10c4c:	ldr	r5, [r1, #16]
   10c4e:	ldr	r7, [r2, #16]
   10c50:	cmp	r5, r7
   10c52:	sub	sp, #12
   10c54:	mov	r4, r1
   10c56:	mov	r6, r2
   10c58:	bge.n	10c64 <__multiply+0x1c>
   10c5a:	mov	r2, r5
   10c5c:	mov	r4, r6
   10c5e:	mov	r5, r7
   10c60:	mov	r6, r1
   10c62:	mov	r7, r2
   10c64:	ldr	r3, [r4, #8]
   10c66:	ldr	r1, [r4, #4]
   10c68:	add.w	r8, r5, r7
   10c6c:	cmp	r8, r3
   10c6e:	it	gt
   10c70:	addgt	r1, #1
   10c72:	bl	10a20 <_Balloc>
   10c76:	add.w	ip, r0, #20
   10c7a:	add.w	r9, ip, r8, lsl #2
   10c7e:	cmp	ip, r9
   10c80:	str	r0, [sp, #0]
   10c82:	bcs.n	10c90 <__multiply+0x48>
   10c84:	mov	r3, ip
   10c86:	movs	r1, #0
   10c88:	str.w	r1, [r3], #4
   10c8c:	cmp	r9, r3
   10c8e:	bhi.n	10c88 <__multiply+0x40>
   10c90:	add.w	r2, r6, #20
   10c94:	add.w	sl, r2, r7, lsl #2
   10c98:	add.w	r3, r4, #20
   10c9c:	cmp	r2, sl
   10c9e:	add.w	lr, r3, r5, lsl #2
   10ca2:	bcs.n	10d4e <__multiply+0x106>
   10ca4:	str.w	r9, [sp, #4]
   10ca8:	mov	r9, r3
   10caa:	ldr.w	r3, [r2], #4
   10cae:	uxth.w	fp, r3
   10cb2:	cmp.w	fp, #0
   10cb6:	beq.n	10cfa <__multiply+0xb2>
   10cb8:	movs	r0, #0
   10cba:	mov	r7, r9
   10cbc:	mov	r6, ip
   10cbe:	mov	r5, r0
   10cc0:	b.n	10cc4 <__multiply+0x7c>
   10cc2:	mov	r6, r3
   10cc4:	ldr.w	r4, [r7], #4
   10cc8:	ldr	r0, [r6, #0]
   10cca:	uxth	r1, r4
   10ccc:	uxth	r3, r0
   10cce:	mla	r1, fp, r1, r3
   10cd2:	lsrs	r4, r4, #16
   10cd4:	lsrs	r0, r0, #16
   10cd6:	adds	r3, r1, r5
   10cd8:	mla	r0, fp, r4, r0
   10cdc:	add.w	r0, r0, r3, lsr #16
   10ce0:	uxth	r1, r3
   10ce2:	mov	r3, r6
   10ce4:	orr.w	r1, r1, r0, lsl #16
   10ce8:	cmp	lr, r7
   10cea:	mov.w	r5, r0, lsr #16
   10cee:	str.w	r1, [r3], #4
   10cf2:	bhi.n	10cc2 <__multiply+0x7a>
   10cf4:	str	r5, [r6, #4]
   10cf6:	ldr.w	r3, [r2, #-4]
   10cfa:	movs.w	fp, r3, lsr #16
   10cfe:	beq.n	10d42 <__multiply+0xfa>
   10d00:	ldr.w	r3, [ip]
   10d04:	mov	r7, ip
   10d06:	mov	r0, r3
   10d08:	mov	r5, r9
   10d0a:	movs	r1, #0
   10d0c:	b.n	10d10 <__multiply+0xc8>
   10d0e:	mov	r7, r6
   10d10:	ldrh	r4, [r5, #0]
   10d12:	lsrs	r0, r0, #16
   10d14:	mla	r0, fp, r4, r0
   10d18:	add	r1, r0
   10d1a:	uxth	r4, r3
   10d1c:	mov	r6, r7
   10d1e:	orr.w	r3, r4, r1, lsl #16
   10d22:	str.w	r3, [r6], #4
   10d26:	ldr	r0, [r7, #4]
   10d28:	ldr.w	r4, [r5], #4
   10d2c:	uxth	r3, r0
   10d2e:	lsrs	r4, r4, #16
   10d30:	mla	r4, fp, r4, r3
   10d34:	add.w	r3, r4, r1, lsr #16
   10d38:	cmp	lr, r5
   10d3a:	mov.w	r1, r3, lsr #16
   10d3e:	bhi.n	10d0e <__multiply+0xc6>
   10d40:	str	r3, [r7, #4]
   10d42:	cmp	sl, r2
   10d44:	add.w	ip, ip, #4
   10d48:	bhi.n	10caa <__multiply+0x62>
   10d4a:	ldr.w	r9, [sp, #4]
   10d4e:	cmp.w	r8, #0
   10d52:	ble.n	10d6c <__multiply+0x124>
   10d54:	ldr.w	r3, [r9, #-4]
   10d58:	sub.w	r9, r9, #4
   10d5c:	cbz	r3, 10d66 <__multiply+0x11e>
   10d5e:	b.n	10d6c <__multiply+0x124>
   10d60:	ldr.w	r3, [r9, #-4]!
   10d64:	cbnz	r3, 10d6c <__multiply+0x124>
   10d66:	subs.w	r8, r8, #1
   10d6a:	bne.n	10d60 <__multiply+0x118>
   10d6c:	ldr	r0, [sp, #0]
   10d6e:	str.w	r8, [r0, #16]
   10d72:	add	sp, #12
   10d74:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00010d78 <__pow5mult>:
   10d78:	ands.w	r3, r2, #3
   10d7c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10d80:	mov	r4, r2
   10d82:	mov	r7, r0
   10d84:	bne.n	10de4 <__pow5mult+0x6c>
   10d86:	mov	r6, r1
   10d88:	asrs	r4, r4, #2
   10d8a:	beq.n	10dc6 <__pow5mult+0x4e>
   10d8c:	ldr	r5, [r7, #72]	; 0x48
   10d8e:	cbz	r5, 10df6 <__pow5mult+0x7e>
   10d90:	lsls	r3, r4, #31
   10d92:	mov.w	r8, #0
   10d96:	bmi.n	10da6 <__pow5mult+0x2e>
   10d98:	asrs	r4, r4, #1
   10d9a:	beq.n	10dc6 <__pow5mult+0x4e>
   10d9c:	ldr	r0, [r5, #0]
   10d9e:	cbz	r0, 10dcc <__pow5mult+0x54>
   10da0:	mov	r5, r0
   10da2:	lsls	r3, r4, #31
   10da4:	bpl.n	10d98 <__pow5mult+0x20>
   10da6:	mov	r2, r5
   10da8:	mov	r1, r6
   10daa:	mov	r0, r7
   10dac:	bl	10c48 <__multiply>
   10db0:	cbz	r6, 10de0 <__pow5mult+0x68>
   10db2:	ldr	r2, [r6, #4]
   10db4:	ldr	r3, [r7, #76]	; 0x4c
   10db6:	asrs	r4, r4, #1
   10db8:	ldr.w	r1, [r3, r2, lsl #2]
   10dbc:	str	r1, [r6, #0]
   10dbe:	str.w	r6, [r3, r2, lsl #2]
   10dc2:	mov	r6, r0
   10dc4:	bne.n	10d9c <__pow5mult+0x24>
   10dc6:	mov	r0, r6
   10dc8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   10dcc:	mov	r2, r5
   10dce:	mov	r1, r5
   10dd0:	mov	r0, r7
   10dd2:	bl	10c48 <__multiply>
   10dd6:	str	r0, [r5, #0]
   10dd8:	str.w	r8, [r0]
   10ddc:	mov	r5, r0
   10dde:	b.n	10da2 <__pow5mult+0x2a>
   10de0:	mov	r6, r0
   10de2:	b.n	10d98 <__pow5mult+0x20>
   10de4:	subs	r2, r3, #1
   10de6:	ldr	r5, [pc, #44]	; (10e14 <__pow5mult+0x9c>)
   10de8:	movs	r3, #0
   10dea:	ldr.w	r2, [r5, r2, lsl #2]
   10dee:	bl	10a80 <__multadd>
   10df2:	mov	r6, r0
   10df4:	b.n	10d88 <__pow5mult+0x10>
   10df6:	movs	r1, #1
   10df8:	mov	r0, r7
   10dfa:	bl	10a20 <_Balloc>
   10dfe:	movw	r1, #625	; 0x271
   10e02:	movs	r2, #1
   10e04:	movs	r3, #0
   10e06:	str	r1, [r0, #20]
   10e08:	str	r2, [r0, #16]
   10e0a:	mov	r5, r0
   10e0c:	str	r0, [r7, #72]	; 0x48
   10e0e:	str	r3, [r0, #0]
   10e10:	b.n	10d90 <__pow5mult+0x18>
   10e12:	nop
   10e14:	.word	0x00012cf0

00010e18 <__lshift>:
   10e18:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   10e1c:	mov	r9, r2
   10e1e:	ldr	r2, [r1, #16]
   10e20:	ldr	r3, [r1, #8]
   10e22:	mov.w	r4, r9, asr #5
   10e26:	add.w	r8, r4, r2
   10e2a:	add.w	r5, r8, #1
   10e2e:	cmp	r5, r3
   10e30:	mov	r6, r1
   10e32:	mov	sl, r0
   10e34:	ldr	r1, [r1, #4]
   10e36:	ble.n	10e42 <__lshift+0x2a>
   10e38:	lsls	r3, r3, #1
   10e3a:	cmp	r5, r3
   10e3c:	add.w	r1, r1, #1
   10e40:	bgt.n	10e38 <__lshift+0x20>
   10e42:	mov	r0, sl
   10e44:	bl	10a20 <_Balloc>
   10e48:	cmp	r4, #0
   10e4a:	add.w	r2, r0, #20
   10e4e:	ble.n	10ec2 <__lshift+0xaa>
   10e50:	add.w	r3, r2, r4, lsl #2
   10e54:	movs	r1, #0
   10e56:	str.w	r1, [r2], #4
   10e5a:	cmp	r3, r2
   10e5c:	bne.n	10e56 <__lshift+0x3e>
   10e5e:	ldr	r4, [r6, #16]
   10e60:	add.w	r1, r6, #20
   10e64:	ands.w	r9, r9, #31
   10e68:	add.w	lr, r1, r4, lsl #2
   10e6c:	beq.n	10eb2 <__lshift+0x9a>
   10e6e:	rsb	r2, r9, #32
   10e72:	movs	r4, #0
   10e74:	ldr	r7, [r1, #0]
   10e76:	lsl.w	ip, r7, r9
   10e7a:	orr.w	r4, ip, r4
   10e7e:	mov	ip, r3
   10e80:	str.w	r4, [r3], #4
   10e84:	ldr.w	r4, [r1], #4
   10e88:	cmp	lr, r1
   10e8a:	lsr.w	r4, r4, r2
   10e8e:	bhi.n	10e74 <__lshift+0x5c>
   10e90:	str.w	r4, [ip, #4]
   10e94:	cbz	r4, 10e9a <__lshift+0x82>
   10e96:	add.w	r5, r8, #2
   10e9a:	ldr.w	r3, [sl, #76]	; 0x4c
   10e9e:	ldr	r2, [r6, #4]
   10ea0:	subs	r5, #1
   10ea2:	ldr.w	r1, [r3, r2, lsl #2]
   10ea6:	str	r5, [r0, #16]
   10ea8:	str	r1, [r6, #0]
   10eaa:	str.w	r6, [r3, r2, lsl #2]
   10eae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   10eb2:	subs	r3, #4
   10eb4:	ldr.w	r2, [r1], #4
   10eb8:	str.w	r2, [r3, #4]!
   10ebc:	cmp	lr, r1
   10ebe:	bhi.n	10eb4 <__lshift+0x9c>
   10ec0:	b.n	10e9a <__lshift+0x82>
   10ec2:	mov	r3, r2
   10ec4:	b.n	10e5e <__lshift+0x46>
   10ec6:	nop

00010ec8 <__mcmp>:
   10ec8:	ldr	r2, [r0, #16]
   10eca:	ldr	r3, [r1, #16]
   10ecc:	subs	r2, r2, r3
   10ece:	bne.n	10ef8 <__mcmp+0x30>
   10ed0:	lsls	r3, r3, #2
   10ed2:	adds	r0, #20
   10ed4:	adds	r1, #20
   10ed6:	add	r1, r3
   10ed8:	push	{r4}
   10eda:	add	r3, r0
   10edc:	b.n	10ee2 <__mcmp+0x1a>
   10ede:	cmp	r0, r3
   10ee0:	bcs.n	10efc <__mcmp+0x34>
   10ee2:	ldr.w	r4, [r3, #-4]!
   10ee6:	ldr.w	r2, [r1, #-4]!
   10eea:	cmp	r4, r2
   10eec:	beq.n	10ede <__mcmp+0x16>
   10eee:	bcc.n	10f04 <__mcmp+0x3c>
   10ef0:	movs	r0, #1
   10ef2:	ldr.w	r4, [sp], #4
   10ef6:	bx	lr
   10ef8:	mov	r0, r2
   10efa:	bx	lr
   10efc:	movs	r0, #0
   10efe:	ldr.w	r4, [sp], #4
   10f02:	bx	lr
   10f04:	mov.w	r0, #4294967295
   10f08:	b.n	10ef2 <__mcmp+0x2a>
   10f0a:	nop

00010f0c <__mdiff>:
   10f0c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   10f10:	ldr	r3, [r1, #16]
   10f12:	mov	r7, r1
   10f14:	ldr	r1, [r2, #16]
   10f16:	subs	r3, r3, r1
   10f18:	cmp	r3, #0
   10f1a:	mov	r8, r2
   10f1c:	bne.n	10f4e <__mdiff+0x42>
   10f1e:	lsls	r1, r1, #2
   10f20:	add.w	r2, r7, #20
   10f24:	add.w	r5, r8, #20
   10f28:	adds	r3, r2, r1
   10f2a:	add	r1, r5
   10f2c:	b.n	10f32 <__mdiff+0x26>
   10f2e:	cmp	r2, r3
   10f30:	bcs.n	10ff0 <__mdiff+0xe4>
   10f32:	ldr.w	r6, [r3, #-4]!
   10f36:	ldr.w	r4, [r1, #-4]!
   10f3a:	cmp	r6, r4
   10f3c:	beq.n	10f2e <__mdiff+0x22>
   10f3e:	bcs.n	11002 <__mdiff+0xf6>
   10f40:	mov	r3, r7
   10f42:	mov	r4, r2
   10f44:	mov	r7, r8
   10f46:	mov.w	r9, #1
   10f4a:	mov	r8, r3
   10f4c:	b.n	10f5c <__mdiff+0x50>
   10f4e:	blt.n	1100c <__mdiff+0x100>
   10f50:	add.w	r5, r7, #20
   10f54:	add.w	r4, r2, #20
   10f58:	mov.w	r9, #0
   10f5c:	ldr	r1, [r7, #4]
   10f5e:	bl	10a20 <_Balloc>
   10f62:	ldr.w	r3, [r8, #16]
   10f66:	ldr	r6, [r7, #16]
   10f68:	str.w	r9, [r0, #12]
   10f6c:	add.w	ip, r4, r3, lsl #2
   10f70:	mov	lr, r4
   10f72:	add.w	r7, r5, r6, lsl #2
   10f76:	add.w	r4, r0, #20
   10f7a:	movs	r3, #0
   10f7c:	ldr.w	r1, [lr], #4
   10f80:	ldr.w	r8, [r5], #4
   10f84:	uxth	r2, r1
   10f86:	uxtah	r3, r3, r8
   10f8a:	lsrs	r1, r1, #16
   10f8c:	subs	r2, r3, r2
   10f8e:	rsb	r3, r1, r8, lsr #16
   10f92:	add.w	r3, r3, r2, asr #16
   10f96:	uxth	r2, r2
   10f98:	orr.w	r2, r2, r3, lsl #16
   10f9c:	cmp	ip, lr
   10f9e:	str.w	r2, [r4], #4
   10fa2:	mov.w	r3, r3, asr #16
   10fa6:	bhi.n	10f7c <__mdiff+0x70>
   10fa8:	cmp	r7, r5
   10faa:	bls.n	10fdc <__mdiff+0xd0>
   10fac:	mov	ip, r4
   10fae:	mov	r1, r5
   10fb0:	ldr.w	lr, [r1], #4
   10fb4:	uxtah	r2, r3, lr
   10fb8:	asrs	r3, r2, #16
   10fba:	add.w	r3, r3, lr, lsr #16
   10fbe:	uxth	r2, r2
   10fc0:	orr.w	r2, r2, r3, lsl #16
   10fc4:	cmp	r7, r1
   10fc6:	str.w	r2, [ip], #4
   10fca:	mov.w	r3, r3, asr #16
   10fce:	bhi.n	10fb0 <__mdiff+0xa4>
   10fd0:	mvns	r5, r5
   10fd2:	add	r5, r7
   10fd4:	bic.w	r5, r5, #3
   10fd8:	adds	r5, #4
   10fda:	add	r4, r5
   10fdc:	subs	r4, #4
   10fde:	cbnz	r2, 10fea <__mdiff+0xde>
   10fe0:	ldr.w	r3, [r4, #-4]!
   10fe4:	subs	r6, #1
   10fe6:	cmp	r3, #0
   10fe8:	beq.n	10fe0 <__mdiff+0xd4>
   10fea:	str	r6, [r0, #16]
   10fec:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   10ff0:	movs	r1, #0
   10ff2:	bl	10a20 <_Balloc>
   10ff6:	movs	r2, #1
   10ff8:	movs	r3, #0
   10ffa:	str	r2, [r0, #16]
   10ffc:	str	r3, [r0, #20]
   10ffe:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   11002:	mov	r4, r5
   11004:	mov.w	r9, #0
   11008:	mov	r5, r2
   1100a:	b.n	10f5c <__mdiff+0x50>
   1100c:	mov	r3, r7
   1100e:	add.w	r4, r7, #20
   11012:	add.w	r5, r8, #20
   11016:	mov	r7, r8
   11018:	mov.w	r9, #1
   1101c:	mov	r8, r3
   1101e:	b.n	10f5c <__mdiff+0x50>

00011020 <__ulp>:
   11020:	ldr	r3, [pc, #76]	; (11070 <__ulp+0x50>)
   11022:	vmov	r2, s1
   11026:	ands	r2, r3
   11028:	sub.w	r3, r2, #54525952	; 0x3400000
   1102c:	cmp	r3, #0
   1102e:	ble.n	1103a <__ulp+0x1a>
   11030:	movs	r0, #0
   11032:	mov	r1, r3
   11034:	vmov	d0, r0, r1
   11038:	bx	lr
   1103a:	negs	r3, r3
   1103c:	asrs	r3, r3, #20
   1103e:	cmp	r3, #19
   11040:	ble.n	1105e <__ulp+0x3e>
   11042:	subs	r3, #20
   11044:	cmp	r3, #30
   11046:	ittte	le
   11048:	rsble	r3, r3, #31
   1104c:	movle	r2, #1
   1104e:	lslle.w	r3, r2, r3
   11052:	movgt	r3, #1
   11054:	movs	r1, #0
   11056:	mov	r0, r3
   11058:	vmov	d0, r0, r1
   1105c:	bx	lr
   1105e:	mov.w	r2, #524288	; 0x80000
   11062:	movs	r0, #0
   11064:	asr.w	r1, r2, r3
   11068:	vmov	d0, r0, r1
   1106c:	bx	lr
   1106e:	nop
   11070:	.word	0x7ff00000

00011074 <__b2d>:
   11074:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11078:	ldr	r6, [r0, #16]
   1107a:	add.w	r8, r0, #20
   1107e:	add.w	r6, r8, r6, lsl #2
   11082:	ldr.w	r7, [r6, #-4]
   11086:	mov	r0, r7
   11088:	bl	10b98 <__hi0bits>
   1108c:	rsb	r3, r0, #32
   11090:	cmp	r0, #10
   11092:	str	r3, [r1, #0]
   11094:	sub.w	r3, r6, #4
   11098:	bgt.n	110cc <__b2d+0x58>
   1109a:	cmp	r8, r3
   1109c:	rsb	r2, r0, #11
   110a0:	it	cc
   110a2:	ldrcc.w	r3, [r6, #-8]
   110a6:	lsr.w	r1, r7, r2
   110aa:	add.w	r0, r0, #21
   110ae:	orr.w	r5, r1, #1069547520	; 0x3fc00000
   110b2:	ite	cc
   110b4:	lsrcc	r3, r2
   110b6:	movcs	r3, #0
   110b8:	lsl.w	r0, r7, r0
   110bc:	orr.w	r5, r5, #3145728	; 0x300000
   110c0:	orr.w	r4, r0, r3
   110c4:	vmov	d0, r4, r5
   110c8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   110cc:	cmp	r8, r3
   110ce:	bcs.n	11112 <__b2d+0x9e>
   110d0:	subs.w	r3, r0, #11
   110d4:	ldr.w	r2, [r6, #-8]
   110d8:	beq.n	11118 <__b2d+0xa4>
   110da:	lsl.w	r0, r7, r3
   110de:	orr.w	r7, r0, #1069547520	; 0x3fc00000
   110e2:	rsb	lr, r3, #32
   110e6:	sub.w	r1, r6, #8
   110ea:	orr.w	r7, r7, #3145728	; 0x300000
   110ee:	lsr.w	r0, r2, lr
   110f2:	cmp	r8, r1
   110f4:	orr.w	r5, r7, r0
   110f8:	bcs.n	1113c <__b2d+0xc8>
   110fa:	ldr.w	r1, [r6, #-12]
   110fe:	lsl.w	r0, r2, r3
   11102:	lsr.w	r3, r1, lr
   11106:	orrs	r0, r3
   11108:	mov	r4, r0
   1110a:	vmov	d0, r4, r5
   1110e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11112:	subs	r0, #11
   11114:	bne.n	1112a <__b2d+0xb6>
   11116:	mov	r2, r0
   11118:	orr.w	r5, r7, #1069547520	; 0x3fc00000
   1111c:	orr.w	r5, r5, #3145728	; 0x300000
   11120:	mov	r4, r2
   11122:	vmov	d0, r4, r5
   11126:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1112a:	lsl.w	r0, r7, r0
   1112e:	orr.w	r5, r0, #1069547520	; 0x3fc00000
   11132:	movs	r0, #0
   11134:	orr.w	r5, r5, #3145728	; 0x300000
   11138:	mov	r4, r0
   1113a:	b.n	1110a <__b2d+0x96>
   1113c:	lsl.w	r0, r2, r3
   11140:	mov	r4, r0
   11142:	b.n	1110a <__b2d+0x96>

00011144 <__d2b>:
   11144:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11148:	vmov	r6, r7, d0
   1114c:	sub	sp, #12
   1114e:	mov	r8, r1
   11150:	movs	r1, #1
   11152:	mov	r4, r7
   11154:	ubfx	r5, r7, #20, #11
   11158:	mov	r7, r2
   1115a:	bl	10a20 <_Balloc>
   1115e:	ubfx	r4, r4, #0, #20
   11162:	mov	r9, r0
   11164:	cbz	r5, 1116a <__d2b+0x26>
   11166:	orr.w	r4, r4, #1048576	; 0x100000
   1116a:	str	r4, [sp, #4]
   1116c:	cbz	r6, 111b6 <__d2b+0x72>
   1116e:	add	r0, sp, #8
   11170:	str.w	r6, [r0, #-8]!
   11174:	bl	10bd8 <__lo0bits>
   11178:	cmp	r0, #0
   1117a:	bne.n	111e6 <__d2b+0xa2>
   1117c:	ldmia.w	sp, {r2, r3}
   11180:	str.w	r2, [r9, #20]
   11184:	cmp	r3, #0
   11186:	ite	eq
   11188:	moveq	r1, #1
   1118a:	movne	r1, #2
   1118c:	str.w	r3, [r9, #24]
   11190:	str.w	r1, [r9, #16]
   11194:	cbnz	r5, 111ce <__d2b+0x8a>
   11196:	add.w	r3, r9, r1, lsl #2
   1119a:	subw	r0, r0, #1074	; 0x432
   1119e:	str.w	r0, [r8]
   111a2:	ldr	r0, [r3, #16]
   111a4:	bl	10b98 <__hi0bits>
   111a8:	rsb	r0, r0, r1, lsl #5
   111ac:	str	r0, [r7, #0]
   111ae:	mov	r0, r9
   111b0:	add	sp, #12
   111b2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   111b6:	add	r0, sp, #4
   111b8:	bl	10bd8 <__lo0bits>
   111bc:	ldr	r3, [sp, #4]
   111be:	str.w	r3, [r9, #20]
   111c2:	movs	r1, #1
   111c4:	adds	r0, #32
   111c6:	str.w	r1, [r9, #16]
   111ca:	cmp	r5, #0
   111cc:	beq.n	11196 <__d2b+0x52>
   111ce:	subw	r5, r5, #1075	; 0x433
   111d2:	add	r5, r0
   111d4:	rsb	r0, r0, #53	; 0x35
   111d8:	str.w	r5, [r8]
   111dc:	str	r0, [r7, #0]
   111de:	mov	r0, r9
   111e0:	add	sp, #12
   111e2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   111e6:	ldmia.w	sp, {r2, r3}
   111ea:	rsb	r1, r0, #32
   111ee:	lsl.w	r1, r3, r1
   111f2:	orrs	r2, r1
   111f4:	lsrs	r3, r0
   111f6:	str	r3, [sp, #4]
   111f8:	str.w	r2, [r9, #20]
   111fc:	b.n	11184 <__d2b+0x40>
   111fe:	nop

00011200 <__ratio>:
   11200:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11204:	sub	sp, #12
   11206:	mov	r8, r1
   11208:	mov	r1, sp
   1120a:	mov	r9, r0
   1120c:	bl	11074 <__b2d>
   11210:	mov	r0, r8
   11212:	add	r1, sp, #4
   11214:	vmov	r4, r5, d0
   11218:	bl	11074 <__b2d>
   1121c:	ldmia.w	sp, {r1, r3}
   11220:	ldr.w	r2, [r9, #16]
   11224:	ldr.w	r0, [r8, #16]
   11228:	subs	r1, r1, r3
   1122a:	subs	r0, r2, r0
   1122c:	add.w	r3, r1, r0, lsl #5
   11230:	cmp	r3, #0
   11232:	vmov	r6, r7, d0
   11236:	ble.n	11254 <__ratio+0x54>
   11238:	add.w	r1, r5, r3, lsl #20
   1123c:	mov	r5, r1
   1123e:	mov	r2, r6
   11240:	mov	r3, r7
   11242:	mov	r0, r4
   11244:	mov	r1, r5
   11246:	bl	a2c4 <__aeabi_ddiv>
   1124a:	vmov	d0, r0, r1
   1124e:	add	sp, #12
   11250:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   11254:	sub.w	r9, r7, r3, lsl #20
   11258:	vmov	r6, s0
   1125c:	mov	r7, r9
   1125e:	b.n	1123e <__ratio+0x3e>

00011260 <__copybits>:
   11260:	push	{r4, r5, r6}
   11262:	ldr	r4, [r2, #16]
   11264:	add.w	r3, r2, #20
   11268:	subs	r1, #1
   1126a:	asrs	r6, r1, #5
   1126c:	add.w	r4, r3, r4, lsl #2
   11270:	adds	r6, #1
   11272:	cmp	r3, r4
   11274:	add.w	r6, r0, r6, lsl #2
   11278:	bcs.n	11294 <__copybits+0x34>
   1127a:	subs	r1, r0, #4
   1127c:	ldr.w	r5, [r3], #4
   11280:	str.w	r5, [r1, #4]!
   11284:	cmp	r4, r3
   11286:	bhi.n	1127c <__copybits+0x1c>
   11288:	subs	r3, r4, r2
   1128a:	subs	r3, #21
   1128c:	bic.w	r3, r3, #3
   11290:	adds	r3, #4
   11292:	add	r0, r3
   11294:	cmp	r6, r0
   11296:	bls.n	112a2 <__copybits+0x42>
   11298:	movs	r3, #0
   1129a:	str.w	r3, [r0], #4
   1129e:	cmp	r6, r0
   112a0:	bhi.n	1129a <__copybits+0x3a>
   112a2:	pop	{r4, r5, r6}
   112a4:	bx	lr
   112a6:	nop

000112a8 <__any_on>:
   112a8:	ldr	r3, [r0, #16]
   112aa:	asrs	r2, r1, #5
   112ac:	cmp	r3, r2
   112ae:	push	{r4}
   112b0:	add.w	r4, r0, #20
   112b4:	bge.n	112d8 <__any_on+0x30>
   112b6:	add.w	r3, r4, r3, lsl #2
   112ba:	cmp	r4, r3
   112bc:	bcs.n	11302 <__any_on+0x5a>
   112be:	ldr.w	r0, [r3, #-4]
   112c2:	subs	r3, #4
   112c4:	cbz	r0, 112ce <__any_on+0x26>
   112c6:	b.n	112f4 <__any_on+0x4c>
   112c8:	ldr.w	r2, [r3, #-4]!
   112cc:	cbnz	r2, 112f4 <__any_on+0x4c>
   112ce:	cmp	r4, r3
   112d0:	bcc.n	112c8 <__any_on+0x20>
   112d2:	ldr.w	r4, [sp], #4
   112d6:	bx	lr
   112d8:	ble.n	112fc <__any_on+0x54>
   112da:	ands.w	r1, r1, #31
   112de:	beq.n	112fc <__any_on+0x54>
   112e0:	ldr.w	r0, [r4, r2, lsl #2]
   112e4:	lsr.w	r3, r0, r1
   112e8:	lsl.w	r1, r3, r1
   112ec:	cmp	r0, r1
   112ee:	add.w	r3, r4, r2, lsl #2
   112f2:	beq.n	112ba <__any_on+0x12>
   112f4:	movs	r0, #1
   112f6:	ldr.w	r4, [sp], #4
   112fa:	bx	lr
   112fc:	add.w	r3, r4, r2, lsl #2
   11300:	b.n	112ba <__any_on+0x12>
   11302:	movs	r0, #0
   11304:	b.n	112d2 <__any_on+0x2a>
   11306:	nop

00011308 <__sccl>:
   11308:	push	{r4, r5, r6}
   1130a:	ldrb	r5, [r1, #0]
   1130c:	cmp	r5, #94	; 0x5e
   1130e:	beq.n	11370 <__sccl+0x68>
   11310:	movs	r2, #0
   11312:	adds	r1, #1
   11314:	mov	r6, r2
   11316:	subs	r3, r0, #1
   11318:	add.w	r4, r0, #255	; 0xff
   1131c:	strb.w	r2, [r3, #1]!
   11320:	cmp	r3, r4
   11322:	bne.n	1131c <__sccl+0x14>
   11324:	cbz	r5, 11348 <__sccl+0x40>
   11326:	eor.w	r2, r6, #1
   1132a:	strb	r2, [r0, r5]
   1132c:	adds	r4, r1, #1
   1132e:	ldrb.w	r3, [r4, #-1]
   11332:	cmp	r3, #45	; 0x2d
   11334:	beq.n	11354 <__sccl+0x4c>
   11336:	cmp	r3, #93	; 0x5d
   11338:	beq.n	1134e <__sccl+0x46>
   1133a:	cbz	r3, 11342 <__sccl+0x3a>
   1133c:	mov	r5, r3
   1133e:	mov	r1, r4
   11340:	b.n	1132a <__sccl+0x22>
   11342:	mov	r0, r1
   11344:	pop	{r4, r5, r6}
   11346:	bx	lr
   11348:	subs	r0, r1, #1
   1134a:	pop	{r4, r5, r6}
   1134c:	bx	lr
   1134e:	mov	r0, r4
   11350:	pop	{r4, r5, r6}
   11352:	bx	lr
   11354:	ldrb	r6, [r1, #1]
   11356:	cmp	r6, #93	; 0x5d
   11358:	beq.n	1133c <__sccl+0x34>
   1135a:	cmp	r5, r6
   1135c:	bgt.n	1133c <__sccl+0x34>
   1135e:	adds	r1, #2
   11360:	adds	r3, r0, r5
   11362:	adds	r5, #1
   11364:	cmp	r6, r5
   11366:	strb.w	r2, [r3, #1]!
   1136a:	bgt.n	11362 <__sccl+0x5a>
   1136c:	adds	r4, #2
   1136e:	b.n	1132e <__sccl+0x26>
   11370:	movs	r2, #1
   11372:	ldrb	r5, [r1, #1]
   11374:	mov	r6, r2
   11376:	adds	r1, #2
   11378:	b.n	11316 <__sccl+0xe>
   1137a:	nop

0001137c <_strtoll_l.isra.0>:
   1137c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11380:	sub	sp, #20
   11382:	mov	sl, r3
   11384:	str	r1, [sp, #8]
   11386:	str	r0, [sp, #12]
   11388:	str	r2, [sp, #4]
   1138a:	mov	r7, r1
   1138c:	ldr	r6, [sp, #56]	; 0x38
   1138e:	b.n	11392 <_strtoll_l.isra.0+0x16>
   11390:	mov	r7, r5
   11392:	mov	r5, r7
   11394:	mov	r0, r6
   11396:	ldrb.w	r4, [r5], #1
   1139a:	bl	aab4 <__locale_ctype_ptr_l>
   1139e:	add	r0, r4
   113a0:	ldrb	r3, [r0, #1]
   113a2:	and.w	r3, r3, #8
   113a6:	and.w	r2, r3, #255	; 0xff
   113aa:	cmp	r3, #0
   113ac:	bne.n	11390 <_strtoll_l.isra.0+0x14>
   113ae:	cmp	r4, #45	; 0x2d
   113b0:	beq.w	114ba <_strtoll_l.isra.0+0x13e>
   113b4:	cmp	r4, #43	; 0x2b
   113b6:	it	eq
   113b8:	ldrbeq	r4, [r7, #1]
   113ba:	str	r2, [sp, #0]
   113bc:	it	eq
   113be:	addeq	r5, r7, #2
   113c0:	cmp.w	sl, #0
   113c4:	beq.n	113e0 <_strtoll_l.isra.0+0x64>
   113c6:	cmp.w	sl, #16
   113ca:	beq.w	114f8 <_strtoll_l.isra.0+0x17c>
   113ce:	ldr	r3, [sp, #0]
   113d0:	mov	r6, sl
   113d2:	asrs	r7, r6, #31
   113d4:	cbnz	r3, 113f2 <_strtoll_l.isra.0+0x76>
   113d6:	mov.w	r8, #4294967295
   113da:	mvn.w	r9, #2147483648	; 0x80000000
   113de:	b.n	113fa <_strtoll_l.isra.0+0x7e>
   113e0:	cmp	r4, #48	; 0x30
   113e2:	beq.n	114e4 <_strtoll_l.isra.0+0x168>
   113e4:	movs	r6, #10
   113e6:	movs	r7, #0
   113e8:	mov.w	sl, #10
   113ec:	ldr	r3, [sp, #0]
   113ee:	cmp	r3, #0
   113f0:	beq.n	113d6 <_strtoll_l.isra.0+0x5a>
   113f2:	mov.w	r8, #0
   113f6:	mov.w	r9, #2147483648	; 0x80000000
   113fa:	mov	r2, r6
   113fc:	mov	r3, r7
   113fe:	mov	r0, r8
   11400:	mov	r1, r9
   11402:	bl	a700 <__aeabi_uldivmod>
   11406:	mov	r3, r7
   11408:	mov	fp, r2
   1140a:	mov	r0, r8
   1140c:	mov	r2, r6
   1140e:	mov	r1, r9
   11410:	bl	a700 <__aeabi_uldivmod>
   11414:	mov.w	lr, #0
   11418:	movs	r2, #0
   1141a:	movs	r3, #0
   1141c:	b.n	1143e <_strtoll_l.isra.0+0xc2>
   1141e:	beq.n	114ac <_strtoll_l.isra.0+0x130>
   11420:	mul.w	r4, r2, r7
   11424:	mla	r4, r6, r3, r4
   11428:	umull	r2, r3, r2, r6
   1142c:	add	r3, r4
   1142e:	adds.w	r2, r2, ip
   11432:	adc.w	r3, r3, ip, asr #31
   11436:	mov.w	lr, #1
   1143a:	ldrb.w	r4, [r5], #1
   1143e:	sub.w	ip, r4, #48	; 0x30
   11442:	cmp.w	ip, #9
   11446:	bls.n	11456 <_strtoll_l.isra.0+0xda>
   11448:	sub.w	ip, r4, #65	; 0x41
   1144c:	cmp.w	ip, #25
   11450:	bhi.n	1146e <_strtoll_l.isra.0+0xf2>
   11452:	sub.w	ip, r4, #55	; 0x37
   11456:	cmp	sl, ip
   11458:	ble.n	11480 <_strtoll_l.isra.0+0x104>
   1145a:	cmp.w	lr, #4294967295
   1145e:	beq.n	1143a <_strtoll_l.isra.0+0xbe>
   11460:	cmp	r1, r3
   11462:	it	eq
   11464:	cmpeq	r0, r2
   11466:	bcs.n	1141e <_strtoll_l.isra.0+0xa2>
   11468:	mov.w	lr, #4294967295
   1146c:	b.n	1143a <_strtoll_l.isra.0+0xbe>
   1146e:	sub.w	ip, r4, #97	; 0x61
   11472:	cmp.w	ip, #25
   11476:	bhi.n	11480 <_strtoll_l.isra.0+0x104>
   11478:	sub.w	ip, r4, #87	; 0x57
   1147c:	cmp	sl, ip
   1147e:	bgt.n	1145a <_strtoll_l.isra.0+0xde>
   11480:	cmp.w	lr, #4294967295
   11484:	beq.n	114c4 <_strtoll_l.isra.0+0x148>
   11486:	ldr	r1, [sp, #0]
   11488:	cbz	r1, 11490 <_strtoll_l.isra.0+0x114>
   1148a:	negs	r2, r2
   1148c:	sbc.w	r3, r3, r3, lsl #1
   11490:	ldr	r1, [sp, #4]
   11492:	cmp	r1, #0
   11494:	beq.n	1151c <_strtoll_l.isra.0+0x1a0>
   11496:	cmp.w	lr, #0
   1149a:	bne.n	114dc <_strtoll_l.isra.0+0x160>
   1149c:	ldr	r5, [sp, #8]
   1149e:	mov	r0, r2
   114a0:	mov	r1, r3
   114a2:	ldr	r3, [sp, #4]
   114a4:	str	r5, [r3, #0]
   114a6:	add	sp, #20
   114a8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   114ac:	cmp	fp, ip
   114ae:	bge.n	11420 <_strtoll_l.isra.0+0xa4>
   114b0:	mov	r2, r0
   114b2:	mov	r3, r1
   114b4:	mov.w	lr, #4294967295
   114b8:	b.n	1143a <_strtoll_l.isra.0+0xbe>
   114ba:	movs	r3, #1
   114bc:	adds	r5, r7, #2
   114be:	ldrb	r4, [r7, #1]
   114c0:	str	r3, [sp, #0]
   114c2:	b.n	113c0 <_strtoll_l.isra.0+0x44>
   114c4:	ldr	r3, [sp, #0]
   114c6:	cbnz	r3, 11514 <_strtoll_l.isra.0+0x198>
   114c8:	mov.w	r0, #4294967295
   114cc:	mvn.w	r1, #2147483648	; 0x80000000
   114d0:	ldr	r2, [sp, #12]
   114d2:	movs	r3, #34	; 0x22
   114d4:	str	r3, [r2, #0]
   114d6:	ldr	r3, [sp, #4]
   114d8:	cbnz	r3, 114e0 <_strtoll_l.isra.0+0x164>
   114da:	b.n	114a6 <_strtoll_l.isra.0+0x12a>
   114dc:	mov	r0, r2
   114de:	mov	r1, r3
   114e0:	subs	r5, #1
   114e2:	b.n	114a2 <_strtoll_l.isra.0+0x126>
   114e4:	ldrb	r3, [r5, #0]
   114e6:	and.w	r3, r3, #223	; 0xdf
   114ea:	cmp	r3, #88	; 0x58
   114ec:	beq.n	11506 <_strtoll_l.isra.0+0x18a>
   114ee:	movs	r6, #8
   114f0:	movs	r7, #0
   114f2:	mov.w	sl, #8
   114f6:	b.n	113ec <_strtoll_l.isra.0+0x70>
   114f8:	cmp	r4, #48	; 0x30
   114fa:	bne.n	11522 <_strtoll_l.isra.0+0x1a6>
   114fc:	ldrb	r3, [r5, #0]
   114fe:	and.w	r3, r3, #223	; 0xdf
   11502:	cmp	r3, #88	; 0x58
   11504:	bne.n	11522 <_strtoll_l.isra.0+0x1a6>
   11506:	ldrb	r4, [r5, #1]
   11508:	movs	r6, #16
   1150a:	movs	r7, #0
   1150c:	adds	r5, #2
   1150e:	mov.w	sl, #16
   11512:	b.n	113ec <_strtoll_l.isra.0+0x70>
   11514:	movs	r0, #0
   11516:	mov.w	r1, #2147483648	; 0x80000000
   1151a:	b.n	114d0 <_strtoll_l.isra.0+0x154>
   1151c:	mov	r0, r2
   1151e:	mov	r1, r3
   11520:	b.n	114a6 <_strtoll_l.isra.0+0x12a>
   11522:	movs	r6, #16
   11524:	movs	r7, #0
   11526:	b.n	113ec <_strtoll_l.isra.0+0x70>

00011528 <_strtoll_r>:
   11528:	push	{r4, r5, lr}
   1152a:	ldr	r4, [pc, #24]	; (11544 <_strtoll_r+0x1c>)
   1152c:	ldr	r5, [pc, #24]	; (11548 <_strtoll_r+0x20>)
   1152e:	ldr	r4, [r4, #0]
   11530:	ldr	r4, [r4, #52]	; 0x34
   11532:	sub	sp, #12
   11534:	cmp	r4, #0
   11536:	it	eq
   11538:	moveq	r4, r5
   1153a:	str	r4, [sp, #0]
   1153c:	bl	1137c <_strtoll_l.isra.0>
   11540:	add	sp, #12
   11542:	pop	{r4, r5, pc}
   11544:	.word	0x1fff1840
   11548:	.word	0x1fff1844

0001154c <_strtoul_l.isra.0>:
   1154c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11550:	ldr.w	r9, [sp, #40]	; 0x28
   11554:	mov	r6, r1
   11556:	mov	r7, r0
   11558:	mov	r5, r2
   1155a:	mov	r8, r3
   1155c:	mov	fp, r1
   1155e:	b.n	11562 <_strtoul_l.isra.0+0x16>
   11560:	mov	fp, r4
   11562:	mov	r4, fp
   11564:	mov	r0, r9
   11566:	ldrb.w	sl, [r4], #1
   1156a:	bl	aab4 <__locale_ctype_ptr_l>
   1156e:	add	r0, sl
   11570:	ldrb	r0, [r0, #1]
   11572:	and.w	r0, r0, #8
   11576:	and.w	ip, r0, #255	; 0xff
   1157a:	cmp	r0, #0
   1157c:	bne.n	11560 <_strtoul_l.isra.0+0x14>
   1157e:	mov	r1, sl
   11580:	cmp	r1, #45	; 0x2d
   11582:	beq.n	11648 <_strtoul_l.isra.0+0xfc>
   11584:	cmp	r1, #43	; 0x2b
   11586:	itt	eq
   11588:	ldrbeq.w	r1, [fp, #1]
   1158c:	addeq.w	r4, fp, #2
   11590:	cmp.w	r8, #0
   11594:	beq.n	115b0 <_strtoul_l.isra.0+0x64>
   11596:	cmp.w	r8, #16
   1159a:	beq.n	11656 <_strtoul_l.isra.0+0x10a>
   1159c:	mov.w	r3, #4294967295
   115a0:	udiv	r3, r3, r8
   115a4:	mul.w	sl, r8, r3
   115a8:	mvn.w	sl, sl
   115ac:	mov	r9, r8
   115ae:	b.n	115c0 <_strtoul_l.isra.0+0x74>
   115b0:	cmp	r1, #48	; 0x30
   115b2:	beq.n	11678 <_strtoul_l.isra.0+0x12c>
   115b4:	mov.w	r8, #10
   115b8:	ldr	r3, [pc, #244]	; (116b0 <_strtoul_l.isra.0+0x164>)
   115ba:	mov	r9, r8
   115bc:	mov.w	sl, #5
   115c0:	mov.w	lr, #0
   115c4:	mov	r0, lr
   115c6:	b.n	115d6 <_strtoul_l.isra.0+0x8a>
   115c8:	beq.n	1162a <_strtoul_l.isra.0+0xde>
   115ca:	mla	r0, r9, r0, r2
   115ce:	mov.w	lr, #1
   115d2:	ldrb.w	r1, [r4], #1
   115d6:	sub.w	r2, r1, #48	; 0x30
   115da:	cmp	r2, #9
   115dc:	bls.n	115ea <_strtoul_l.isra.0+0x9e>
   115de:	sub.w	r2, r1, #65	; 0x41
   115e2:	cmp	r2, #25
   115e4:	bhi.n	115fe <_strtoul_l.isra.0+0xb2>
   115e6:	sub.w	r2, r1, #55	; 0x37
   115ea:	cmp	r8, r2
   115ec:	ble.n	1160e <_strtoul_l.isra.0+0xc2>
   115ee:	cmp.w	lr, #4294967295
   115f2:	beq.n	115d2 <_strtoul_l.isra.0+0x86>
   115f4:	cmp	r0, r3
   115f6:	bls.n	115c8 <_strtoul_l.isra.0+0x7c>
   115f8:	mov.w	lr, #4294967295
   115fc:	b.n	115d2 <_strtoul_l.isra.0+0x86>
   115fe:	sub.w	r2, r1, #97	; 0x61
   11602:	cmp	r2, #25
   11604:	bhi.n	1160e <_strtoul_l.isra.0+0xc2>
   11606:	sub.w	r2, r1, #87	; 0x57
   1160a:	cmp	r8, r2
   1160c:	bgt.n	115ee <_strtoul_l.isra.0+0xa2>
   1160e:	cmp.w	lr, #4294967295
   11612:	beq.n	11638 <_strtoul_l.isra.0+0xec>
   11614:	cmp.w	ip, #0
   11618:	beq.n	1161c <_strtoul_l.isra.0+0xd0>
   1161a:	negs	r0, r0
   1161c:	cbz	r5, 11634 <_strtoul_l.isra.0+0xe8>
   1161e:	cmp.w	lr, #0
   11622:	bne.n	11640 <_strtoul_l.isra.0+0xf4>
   11624:	str	r6, [r5, #0]
   11626:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1162a:	cmp	r2, sl
   1162c:	ble.n	115ca <_strtoul_l.isra.0+0x7e>
   1162e:	mov.w	lr, #4294967295
   11632:	b.n	115d2 <_strtoul_l.isra.0+0x86>
   11634:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11638:	movs	r3, #34	; 0x22
   1163a:	str	r3, [r7, #0]
   1163c:	mov	r0, lr
   1163e:	cbz	r5, 11692 <_strtoul_l.isra.0+0x146>
   11640:	subs	r6, r4, #1
   11642:	str	r6, [r5, #0]
   11644:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11648:	add.w	r4, fp, #2
   1164c:	ldrb.w	r1, [fp, #1]
   11650:	mov.w	ip, #1
   11654:	b.n	11590 <_strtoul_l.isra.0+0x44>
   11656:	cmp	r1, #48	; 0x30
   11658:	bne.n	11696 <_strtoul_l.isra.0+0x14a>
   1165a:	ldrb	r3, [r4, #0]
   1165c:	and.w	r3, r3, #223	; 0xdf
   11660:	cmp	r3, #88	; 0x58
   11662:	bne.n	116a2 <_strtoul_l.isra.0+0x156>
   11664:	mov.w	r9, #16
   11668:	ldrb	r1, [r4, #1]
   1166a:	mov	r8, r9
   1166c:	mov.w	sl, #15
   11670:	adds	r4, #2
   11672:	mvn.w	r3, #4026531840	; 0xf0000000
   11676:	b.n	115c0 <_strtoul_l.isra.0+0x74>
   11678:	ldrb	r3, [r4, #0]
   1167a:	and.w	r3, r3, #223	; 0xdf
   1167e:	cmp	r3, #88	; 0x58
   11680:	beq.n	11664 <_strtoul_l.isra.0+0x118>
   11682:	mov.w	r8, #8
   11686:	mov	r9, r8
   11688:	mov.w	sl, #7
   1168c:	mvn.w	r3, #3758096384	; 0xe0000000
   11690:	b.n	115c0 <_strtoul_l.isra.0+0x74>
   11692:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11696:	mov.w	sl, #15
   1169a:	mvn.w	r3, #4026531840	; 0xf0000000
   1169e:	mov	r9, r8
   116a0:	b.n	115c0 <_strtoul_l.isra.0+0x74>
   116a2:	mov	r9, r8
   116a4:	mov.w	sl, #15
   116a8:	mvn.w	r3, #4026531840	; 0xf0000000
   116ac:	b.n	115c0 <_strtoul_l.isra.0+0x74>
   116ae:	nop
   116b0:	.word	0x19999999

000116b4 <_strtoul_r>:
   116b4:	push	{r4, r5, lr}
   116b6:	ldr	r4, [pc, #24]	; (116d0 <_strtoul_r+0x1c>)
   116b8:	ldr	r5, [pc, #24]	; (116d4 <_strtoul_r+0x20>)
   116ba:	ldr	r4, [r4, #0]
   116bc:	ldr	r4, [r4, #52]	; 0x34
   116be:	sub	sp, #12
   116c0:	cmp	r4, #0
   116c2:	it	eq
   116c4:	moveq	r4, r5
   116c6:	str	r4, [sp, #0]
   116c8:	bl	1154c <_strtoul_l.isra.0>
   116cc:	add	sp, #12
   116ce:	pop	{r4, r5, pc}
   116d0:	.word	0x1fff1840
   116d4:	.word	0x1fff1844

000116d8 <_strtoull_l.isra.0>:
   116d8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   116dc:	sub	sp, #20
   116de:	mov	fp, r1
   116e0:	str	r0, [sp, #8]
   116e2:	mov	r7, r2
   116e4:	mov	r6, r3
   116e6:	mov	r8, r1
   116e8:	ldr	r4, [sp, #56]	; 0x38
   116ea:	b.n	116ee <_strtoull_l.isra.0+0x16>
   116ec:	mov	r8, r5
   116ee:	mov	r5, r8
   116f0:	mov	r0, r4
   116f2:	ldrb.w	r9, [r5], #1
   116f6:	bl	aab4 <__locale_ctype_ptr_l>
   116fa:	add	r0, r9
   116fc:	ldrb	r3, [r0, #1]
   116fe:	and.w	r3, r3, #8
   11702:	and.w	r2, r3, #255	; 0xff
   11706:	cmp	r3, #0
   11708:	bne.n	116ec <_strtoull_l.isra.0+0x14>
   1170a:	mov	r4, r9
   1170c:	cmp	r4, #45	; 0x2d
   1170e:	beq.w	1182a <_strtoull_l.isra.0+0x152>
   11712:	cmp	r4, #43	; 0x2b
   11714:	it	eq
   11716:	ldrbeq.w	r4, [r8, #1]
   1171a:	str	r2, [sp, #4]
   1171c:	it	eq
   1171e:	addeq.w	r5, r8, #2
   11722:	cbz	r6, 1175c <_strtoull_l.isra.0+0x84>
   11724:	cmp	r6, #16
   11726:	beq.w	11838 <_strtoull_l.isra.0+0x160>
   1172a:	mov.w	r9, r6, asr #31
   1172e:	mov	r2, r6
   11730:	mov	r3, r9
   11732:	mov.w	r0, #4294967295
   11736:	mov.w	r1, #4294967295
   1173a:	bl	a700 <__aeabi_uldivmod>
   1173e:	mov	r2, r6
   11740:	str	r0, [sp, #12]
   11742:	mov	sl, r1
   11744:	mov	r3, r9
   11746:	mov.w	r0, #4294967295
   1174a:	mov.w	r1, #4294967295
   1174e:	bl	a700 <__aeabi_uldivmod>
   11752:	mov	r8, r6
   11754:	mov	lr, r2
   11756:	ldr	r2, [sp, #12]
   11758:	mov	r3, sl
   1175a:	b.n	11776 <_strtoull_l.isra.0+0x9e>
   1175c:	cmp	r4, #48	; 0x30
   1175e:	beq.w	11864 <_strtoull_l.isra.0+0x18c>
   11762:	ldr	r3, [pc, #348]	; (118c0 <_strtoull_l.isra.0+0x1e8>)
   11764:	mov.w	lr, #5
   11768:	mov.w	r2, #2576980377	; 0x99999999
   1176c:	mov.w	r8, #10
   11770:	mov.w	r9, #0
   11774:	movs	r6, #10
   11776:	mov.w	ip, #0
   1177a:	movs	r0, #0
   1177c:	movs	r1, #0
   1177e:	b.n	117a6 <_strtoull_l.isra.0+0xce>
   11780:	cmp	r1, r3
   11782:	it	eq
   11784:	cmpeq	r0, r2
   11786:	beq.n	1180a <_strtoull_l.isra.0+0x132>
   11788:	mul.w	r4, r0, r9
   1178c:	mla	r4, r8, r1, r4
   11790:	umull	r0, r1, r0, r8
   11794:	add	r1, r4
   11796:	adds.w	r0, r0, sl
   1179a:	adc.w	r1, r1, sl, asr #31
   1179e:	mov.w	ip, #1
   117a2:	ldrb.w	r4, [r5], #1
   117a6:	sub.w	sl, r4, #48	; 0x30
   117aa:	cmp.w	sl, #9
   117ae:	bls.n	117be <_strtoull_l.isra.0+0xe6>
   117b0:	sub.w	sl, r4, #65	; 0x41
   117b4:	cmp.w	sl, #25
   117b8:	bhi.n	117d6 <_strtoull_l.isra.0+0xfe>
   117ba:	sub.w	sl, r4, #55	; 0x37
   117be:	cmp	r6, sl
   117c0:	ble.n	117e8 <_strtoull_l.isra.0+0x110>
   117c2:	cmp.w	ip, #4294967295
   117c6:	beq.n	117a2 <_strtoull_l.isra.0+0xca>
   117c8:	cmp	r3, r1
   117ca:	it	eq
   117cc:	cmpeq	r2, r0
   117ce:	bcs.n	11780 <_strtoull_l.isra.0+0xa8>
   117d0:	mov.w	ip, #4294967295
   117d4:	b.n	117a2 <_strtoull_l.isra.0+0xca>
   117d6:	sub.w	sl, r4, #97	; 0x61
   117da:	cmp.w	sl, #25
   117de:	bhi.n	117e8 <_strtoull_l.isra.0+0x110>
   117e0:	sub.w	sl, r4, #87	; 0x57
   117e4:	cmp	r6, sl
   117e6:	bgt.n	117c2 <_strtoull_l.isra.0+0xea>
   117e8:	cmp.w	ip, #4294967295
   117ec:	beq.n	11814 <_strtoull_l.isra.0+0x13c>
   117ee:	ldr	r3, [sp, #4]
   117f0:	cbz	r3, 117f8 <_strtoull_l.isra.0+0x120>
   117f2:	negs	r0, r0
   117f4:	sbc.w	r1, r1, r1, lsl #1
   117f8:	cbz	r7, 11804 <_strtoull_l.isra.0+0x12c>
   117fa:	cmp.w	ip, #0
   117fe:	bne.n	11826 <_strtoull_l.isra.0+0x14e>
   11800:	mov	r5, fp
   11802:	str	r5, [r7, #0]
   11804:	add	sp, #20
   11806:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1180a:	cmp	sl, lr
   1180c:	ble.n	11788 <_strtoull_l.isra.0+0xb0>
   1180e:	mov.w	ip, #4294967295
   11812:	b.n	117a2 <_strtoull_l.isra.0+0xca>
   11814:	ldr	r2, [sp, #8]
   11816:	movs	r3, #34	; 0x22
   11818:	str	r3, [r2, #0]
   1181a:	mov.w	r0, #4294967295
   1181e:	mov.w	r1, #4294967295
   11822:	cmp	r7, #0
   11824:	beq.n	11804 <_strtoull_l.isra.0+0x12c>
   11826:	subs	r5, #1
   11828:	b.n	11802 <_strtoull_l.isra.0+0x12a>
   1182a:	movs	r3, #1
   1182c:	add.w	r5, r8, #2
   11830:	ldrb.w	r4, [r8, #1]
   11834:	str	r3, [sp, #4]
   11836:	b.n	11722 <_strtoull_l.isra.0+0x4a>
   11838:	cmp	r4, #48	; 0x30
   1183a:	bne.n	11886 <_strtoull_l.isra.0+0x1ae>
   1183c:	ldrb	r3, [r5, #0]
   1183e:	and.w	r3, r3, #223	; 0xdf
   11842:	cmp	r3, #88	; 0x58
   11844:	bne.n	1189c <_strtoull_l.isra.0+0x1c4>
   11846:	mov.w	r3, #4294967295
   1184a:	ldrb	r4, [r5, #1]
   1184c:	str	r3, [sp, #12]
   1184e:	mov.w	lr, #15
   11852:	adds	r5, #2
   11854:	mvn.w	sl, #4026531840	; 0xf0000000
   11858:	mov.w	r8, #16
   1185c:	mov.w	r9, #0
   11860:	movs	r6, #16
   11862:	b.n	11756 <_strtoull_l.isra.0+0x7e>
   11864:	ldrb	r3, [r5, #0]
   11866:	and.w	r3, r3, #223	; 0xdf
   1186a:	cmp	r3, #88	; 0x58
   1186c:	beq.n	11846 <_strtoull_l.isra.0+0x16e>
   1186e:	mov.w	lr, #7
   11872:	mov.w	r2, #4294967295
   11876:	mvn.w	r3, #3758096384	; 0xe0000000
   1187a:	mov.w	r8, #8
   1187e:	mov.w	r9, #0
   11882:	movs	r6, #8
   11884:	b.n	11776 <_strtoull_l.isra.0+0x9e>
   11886:	mov.w	lr, #15
   1188a:	mov.w	r2, #4294967295
   1188e:	mvn.w	r3, #4026531840	; 0xf0000000
   11892:	mov.w	r8, #16
   11896:	mov.w	r9, #0
   1189a:	b.n	11776 <_strtoull_l.isra.0+0x9e>
   1189c:	mov.w	r8, #16
   118a0:	mov.w	r9, #0
   118a4:	mov	r2, r8
   118a6:	mov	r3, r9
   118a8:	mov.w	r0, #4294967295
   118ac:	mov.w	r1, #4294967295
   118b0:	bl	a700 <__aeabi_uldivmod>
   118b4:	mvn.w	r3, #4026531840	; 0xf0000000
   118b8:	mov	lr, r2
   118ba:	mov.w	r2, #4294967295
   118be:	b.n	11776 <_strtoull_l.isra.0+0x9e>
   118c0:	.word	0x19999999

000118c4 <_strtoull_r>:
   118c4:	push	{r4, r5, lr}
   118c6:	ldr	r4, [pc, #24]	; (118e0 <_strtoull_r+0x1c>)
   118c8:	ldr	r5, [pc, #24]	; (118e4 <_strtoull_r+0x20>)
   118ca:	ldr	r4, [r4, #0]
   118cc:	ldr	r4, [r4, #52]	; 0x34
   118ce:	sub	sp, #12
   118d0:	cmp	r4, #0
   118d2:	it	eq
   118d4:	moveq	r4, r5
   118d6:	str	r4, [sp, #0]
   118d8:	bl	116d8 <_strtoull_l.isra.0>
   118dc:	add	sp, #12
   118de:	pop	{r4, r5, pc}
   118e0:	.word	0x1fff1840
   118e4:	.word	0x1fff1844

000118e8 <__ssprint_r>:
   118e8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   118ec:	ldr	r3, [r2, #8]
   118ee:	sub	sp, #12
   118f0:	mov	r8, r2
   118f2:	cmp	r3, #0
   118f4:	beq.n	119dc <__ssprint_r+0xf4>
   118f6:	mov	fp, r0
   118f8:	mov.w	r9, #0
   118fc:	ldr	r6, [r2, #0]
   118fe:	ldr	r0, [r1, #0]
   11900:	ldr	r3, [r1, #8]
   11902:	mov	r5, r1
   11904:	mov	r4, r9
   11906:	cmp	r4, #0
   11908:	beq.n	11996 <__ssprint_r+0xae>
   1190a:	cmp	r4, r3
   1190c:	mov	r7, r3
   1190e:	mov	sl, r3
   11910:	bcc.n	119a0 <__ssprint_r+0xb8>
   11912:	ldrh	r3, [r5, #12]
   11914:	tst.w	r3, #1152	; 0x480
   11918:	beq.n	11976 <__ssprint_r+0x8e>
   1191a:	ldr	r7, [r5, #20]
   1191c:	ldr	r1, [r5, #16]
   1191e:	add.w	r7, r7, r7, lsl #1
   11922:	rsb	sl, r1, r0
   11926:	add.w	r7, r7, r7, lsr #31
   1192a:	adds	r0, r4, #1
   1192c:	asrs	r7, r7, #1
   1192e:	add	r0, sl
   11930:	cmp	r0, r7
   11932:	mov	r2, r7
   11934:	itt	hi
   11936:	movhi	r7, r0
   11938:	movhi	r2, r7
   1193a:	lsls	r3, r3, #21
   1193c:	bpl.n	119a6 <__ssprint_r+0xbe>
   1193e:	mov	r1, r2
   11940:	mov	r0, fp
   11942:	bl	aaf0 <_malloc_r>
   11946:	cmp	r0, #0
   11948:	beq.n	119ba <__ssprint_r+0xd2>
   1194a:	mov	r2, sl
   1194c:	ldr	r1, [r5, #16]
   1194e:	str	r0, [sp, #4]
   11950:	bl	8734 <memcpy>
   11954:	ldrh	r2, [r5, #12]
   11956:	ldr	r3, [sp, #4]
   11958:	bic.w	r2, r2, #1152	; 0x480
   1195c:	orr.w	r2, r2, #128	; 0x80
   11960:	strh	r2, [r5, #12]
   11962:	rsb	r2, sl, r7
   11966:	add.w	r0, r3, sl
   1196a:	str	r7, [r5, #20]
   1196c:	str	r3, [r5, #16]
   1196e:	str	r0, [r5, #0]
   11970:	str	r2, [r5, #8]
   11972:	mov	r7, r4
   11974:	mov	sl, r4
   11976:	mov	r2, sl
   11978:	mov	r1, r9
   1197a:	bl	b194 <memmove>
   1197e:	ldr.w	r2, [r8, #8]
   11982:	ldr	r3, [r5, #8]
   11984:	ldr	r0, [r5, #0]
   11986:	subs	r3, r3, r7
   11988:	add	r0, sl
   1198a:	subs	r4, r2, r4
   1198c:	str	r3, [r5, #8]
   1198e:	str	r0, [r5, #0]
   11990:	str.w	r4, [r8, #8]
   11994:	cbz	r4, 119dc <__ssprint_r+0xf4>
   11996:	ldr.w	r9, [r6]
   1199a:	ldr	r4, [r6, #4]
   1199c:	adds	r6, #8
   1199e:	b.n	11906 <__ssprint_r+0x1e>
   119a0:	mov	r7, r4
   119a2:	mov	sl, r4
   119a4:	b.n	11976 <__ssprint_r+0x8e>
   119a6:	mov	r0, fp
   119a8:	bl	b264 <_realloc_r>
   119ac:	mov	r3, r0
   119ae:	cmp	r0, #0
   119b0:	bne.n	11962 <__ssprint_r+0x7a>
   119b2:	ldr	r1, [r5, #16]
   119b4:	mov	r0, fp
   119b6:	bl	10050 <_free_r>
   119ba:	movs	r3, #12
   119bc:	str.w	r3, [fp]
   119c0:	ldrh	r3, [r5, #12]
   119c2:	movs	r2, #0
   119c4:	orr.w	r3, r3, #64	; 0x40
   119c8:	mov.w	r0, #4294967295
   119cc:	strh	r3, [r5, #12]
   119ce:	str.w	r2, [r8, #8]
   119d2:	str.w	r2, [r8, #4]
   119d6:	add	sp, #12
   119d8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   119dc:	movs	r0, #0
   119de:	str.w	r0, [r8, #4]
   119e2:	add	sp, #12
   119e4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000119e8 <_sungetc_r>:
   119e8:	adds	r3, r1, #1
   119ea:	push	{r4, r5, r6, lr}
   119ec:	beq.n	11a26 <_sungetc_r+0x3e>
   119ee:	ldrh	r3, [r2, #12]
   119f0:	ldr	r4, [r2, #48]	; 0x30
   119f2:	bic.w	r3, r3, #32
   119f6:	strh	r3, [r2, #12]
   119f8:	uxtb	r5, r1
   119fa:	cbz	r4, 11a2c <_sungetc_r+0x44>
   119fc:	mov	r4, r2
   119fe:	ldr	r2, [r2, #4]
   11a00:	ldr	r3, [r4, #52]	; 0x34
   11a02:	cmp	r2, r3
   11a04:	mov	r6, r1
   11a06:	bge.n	11a1c <_sungetc_r+0x34>
   11a08:	ldr	r3, [r4, #0]
   11a0a:	subs	r2, r3, #1
   11a0c:	str	r2, [r4, #0]
   11a0e:	strb.w	r6, [r3, #-1]
   11a12:	ldr	r3, [r4, #4]
   11a14:	adds	r3, #1
   11a16:	str	r3, [r4, #4]
   11a18:	mov	r0, r5
   11a1a:	pop	{r4, r5, r6, pc}
   11a1c:	mov	r1, r4
   11a1e:	bl	11b2c <__submore>
   11a22:	cmp	r0, #0
   11a24:	beq.n	11a08 <_sungetc_r+0x20>
   11a26:	mov.w	r5, #4294967295
   11a2a:	b.n	11a18 <_sungetc_r+0x30>
   11a2c:	ldr	r0, [r2, #16]
   11a2e:	ldr	r3, [r2, #0]
   11a30:	cbz	r0, 11a3e <_sungetc_r+0x56>
   11a32:	cmp	r0, r3
   11a34:	bcs.n	11a3e <_sungetc_r+0x56>
   11a36:	ldrb.w	r0, [r3, #-1]
   11a3a:	cmp	r5, r0
   11a3c:	beq.n	11a5e <_sungetc_r+0x76>
   11a3e:	str	r3, [r2, #56]	; 0x38
   11a40:	mov	r3, r2
   11a42:	ldr	r6, [r2, #4]
   11a44:	str	r6, [r2, #60]	; 0x3c
   11a46:	add.w	r4, r2, #64	; 0x40
   11a4a:	movs	r0, #3
   11a4c:	str	r0, [r2, #52]	; 0x34
   11a4e:	str	r4, [r2, #48]	; 0x30
   11a50:	strb.w	r1, [r3, #66]!
   11a54:	movs	r1, #1
   11a56:	str	r3, [r2, #0]
   11a58:	str	r1, [r2, #4]
   11a5a:	mov	r0, r5
   11a5c:	pop	{r4, r5, r6, pc}
   11a5e:	ldr	r1, [r2, #4]
   11a60:	subs	r3, #1
   11a62:	adds	r1, #1
   11a64:	str	r3, [r2, #0]
   11a66:	str	r1, [r2, #4]
   11a68:	b.n	11a18 <_sungetc_r+0x30>
   11a6a:	nop

00011a6c <__ssrefill_r>:
   11a6c:	push	{r4, lr}
   11a6e:	mov	r4, r1
   11a70:	ldr	r1, [r1, #48]	; 0x30
   11a72:	cbz	r1, 11a90 <__ssrefill_r+0x24>
   11a74:	add.w	r3, r4, #64	; 0x40
   11a78:	cmp	r1, r3
   11a7a:	beq.n	11a80 <__ssrefill_r+0x14>
   11a7c:	bl	10050 <_free_r>
   11a80:	ldr	r3, [r4, #60]	; 0x3c
   11a82:	str	r3, [r4, #4]
   11a84:	movs	r0, #0
   11a86:	str	r0, [r4, #48]	; 0x30
   11a88:	cbz	r3, 11a90 <__ssrefill_r+0x24>
   11a8a:	ldr	r3, [r4, #56]	; 0x38
   11a8c:	str	r3, [r4, #0]
   11a8e:	pop	{r4, pc}
   11a90:	ldrh	r3, [r4, #12]
   11a92:	ldr	r2, [r4, #16]
   11a94:	str	r2, [r4, #0]
   11a96:	orr.w	r3, r3, #32
   11a9a:	movs	r2, #0
   11a9c:	strh	r3, [r4, #12]
   11a9e:	str	r2, [r4, #4]
   11aa0:	mov.w	r0, #4294967295
   11aa4:	pop	{r4, pc}
   11aa6:	nop

00011aa8 <_sfread_r>:
   11aa8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11aac:	sub	sp, #12
   11aae:	mul.w	r9, r2, r3
   11ab2:	str	r2, [sp, #4]
   11ab4:	mov	sl, r3
   11ab6:	ldr	r4, [sp, #48]	; 0x30
   11ab8:	cmp.w	r9, #0
   11abc:	beq.n	11b12 <_sfread_r+0x6a>
   11abe:	mov	r7, r0
   11ac0:	mov	r6, r1
   11ac2:	mov	r5, r9
   11ac4:	mov.w	r8, #0
   11ac8:	b.n	11aea <_sfread_r+0x42>
   11aca:	ldr	r1, [r4, #0]
   11acc:	bl	8734 <memcpy>
   11ad0:	ldr	r2, [r4, #0]
   11ad2:	str.w	r8, [r4, #4]
   11ad6:	add	r2, fp
   11ad8:	str	r2, [r4, #0]
   11ada:	mov	r1, r4
   11adc:	mov	r0, r7
   11ade:	add	r6, fp
   11ae0:	rsb	r5, fp, r5
   11ae4:	bl	11a6c <__ssrefill_r>
   11ae8:	cbnz	r0, 11b1a <_sfread_r+0x72>
   11aea:	ldr.w	fp, [r4, #4]
   11aee:	cmp	r5, fp
   11af0:	mov	r0, r6
   11af2:	mov	r2, fp
   11af4:	bhi.n	11aca <_sfread_r+0x22>
   11af6:	mov	r2, r5
   11af8:	ldr	r1, [r4, #0]
   11afa:	bl	8734 <memcpy>
   11afe:	ldr	r2, [r4, #4]
   11b00:	ldr	r3, [r4, #0]
   11b02:	subs	r2, r2, r5
   11b04:	add	r3, r5
   11b06:	mov	r0, sl
   11b08:	str	r2, [r4, #4]
   11b0a:	str	r3, [r4, #0]
   11b0c:	add	sp, #12
   11b0e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11b12:	mov	r0, r9
   11b14:	add	sp, #12
   11b16:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11b1a:	ldr	r3, [sp, #4]
   11b1c:	rsb	r9, r5, r9
   11b20:	udiv	r0, r9, r3
   11b24:	add	sp, #12
   11b26:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11b2a:	nop

00011b2c <__submore>:
   11b2c:	add.w	r3, r1, #64	; 0x40
   11b30:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11b34:	mov	r4, r1
   11b36:	ldr	r1, [r1, #48]	; 0x30
   11b38:	cmp	r1, r3
   11b3a:	beq.n	11b66 <__submore+0x3a>
   11b3c:	ldr	r6, [r4, #52]	; 0x34
   11b3e:	lsls	r7, r6, #1
   11b40:	mov	r2, r7
   11b42:	bl	b264 <_realloc_r>
   11b46:	mov	r5, r0
   11b48:	cbz	r0, 11b9c <__submore+0x70>
   11b4a:	add.w	r8, r0, r6
   11b4e:	mov	r2, r6
   11b50:	mov	r0, r8
   11b52:	mov	r1, r5
   11b54:	bl	8734 <memcpy>
   11b58:	str.w	r8, [r4]
   11b5c:	str	r5, [r4, #48]	; 0x30
   11b5e:	str	r7, [r4, #52]	; 0x34
   11b60:	movs	r0, #0
   11b62:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11b66:	mov.w	r1, #1024	; 0x400
   11b6a:	bl	aaf0 <_malloc_r>
   11b6e:	cbz	r0, 11b9c <__submore+0x70>
   11b70:	ldrb.w	r3, [r4, #66]	; 0x42
   11b74:	str	r0, [r4, #48]	; 0x30
   11b76:	mov.w	r2, #1024	; 0x400
   11b7a:	str	r2, [r4, #52]	; 0x34
   11b7c:	strb.w	r3, [r0, #1023]	; 0x3ff
   11b80:	ldrb.w	r3, [r4, #65]	; 0x41
   11b84:	strb.w	r3, [r0, #1022]	; 0x3fe
   11b88:	ldrb.w	r3, [r4, #64]	; 0x40
   11b8c:	strb.w	r3, [r0, #1021]	; 0x3fd
   11b90:	addw	r0, r0, #1021	; 0x3fd
   11b94:	str	r0, [r4, #0]
   11b96:	movs	r0, #0
   11b98:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11b9c:	mov.w	r0, #4294967295
   11ba0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00011ba4 <_vasnprintf_r>:
   11ba4:	push	{r4, r5, r6, lr}
   11ba6:	mov	r5, r2
   11ba8:	sub	sp, #104	; 0x68
   11baa:	ldr	r4, [r2, #0]
   11bac:	cbz	r1, 11bb2 <_vasnprintf_r+0xe>
   11bae:	cmp	r4, #0
   11bb0:	bne.n	11be8 <_vasnprintf_r+0x44>
   11bb2:	movs	r4, #0
   11bb4:	mov.w	r2, #648	; 0x288
   11bb8:	strh.w	r2, [sp, #12]
   11bbc:	str	r4, [sp, #0]
   11bbe:	str	r4, [sp, #16]
   11bc0:	mov	r2, r3
   11bc2:	movw	r6, #65535	; 0xffff
   11bc6:	ldr	r3, [sp, #120]	; 0x78
   11bc8:	str	r4, [sp, #8]
   11bca:	mov	r1, sp
   11bcc:	str	r4, [sp, #20]
   11bce:	strh.w	r6, [sp, #14]
   11bd2:	bl	c950 <_svfprintf_r>
   11bd6:	cmp	r0, #0
   11bd8:	blt.n	11bfe <_vasnprintf_r+0x5a>
   11bda:	ldr	r3, [sp, #0]
   11bdc:	str	r0, [r5, #0]
   11bde:	movs	r2, #0
   11be0:	strb	r2, [r3, #0]
   11be2:	ldr	r0, [sp, #16]
   11be4:	add	sp, #104	; 0x68
   11be6:	pop	{r4, r5, r6, pc}
   11be8:	mov.w	r2, #1544	; 0x608
   11bec:	str	r1, [sp, #0]
   11bee:	str	r1, [sp, #16]
   11bf0:	strh.w	r2, [sp, #12]
   11bf4:	bge.n	11bc0 <_vasnprintf_r+0x1c>
   11bf6:	movs	r3, #139	; 0x8b
   11bf8:	str	r3, [r0, #0]
   11bfa:	movs	r0, #0
   11bfc:	b.n	11be4 <_vasnprintf_r+0x40>
   11bfe:	movs	r0, #0
   11c00:	b.n	11be4 <_vasnprintf_r+0x40>
   11c02:	nop

00011c04 <_calloc_r>:
   11c04:	push	{r4, lr}
   11c06:	mul.w	r1, r2, r1
   11c0a:	bl	aaf0 <_malloc_r>
   11c0e:	mov	r4, r0
   11c10:	cbz	r0, 11c4a <_calloc_r+0x46>
   11c12:	ldr.w	r2, [r0, #-4]
   11c16:	bic.w	r2, r2, #3
   11c1a:	subs	r2, #4
   11c1c:	cmp	r2, #36	; 0x24
   11c1e:	bhi.n	11c52 <_calloc_r+0x4e>
   11c20:	cmp	r2, #19
   11c22:	bls.n	11c4e <_calloc_r+0x4a>
   11c24:	movs	r3, #0
   11c26:	cmp	r2, #27
   11c28:	str	r3, [r0, #0]
   11c2a:	str	r3, [r0, #4]
   11c2c:	bls.n	11c5c <_calloc_r+0x58>
   11c2e:	cmp	r2, #36	; 0x24
   11c30:	str	r3, [r0, #8]
   11c32:	str	r3, [r0, #12]
   11c34:	iteee	ne
   11c36:	addne.w	r2, r0, #16
   11c3a:	streq	r3, [r0, #16]
   11c3c:	streq	r3, [r0, #20]
   11c3e:	addeq.w	r2, r0, #24
   11c42:	movs	r3, #0
   11c44:	str	r3, [r2, #0]
   11c46:	str	r3, [r2, #4]
   11c48:	str	r3, [r2, #8]
   11c4a:	mov	r0, r4
   11c4c:	pop	{r4, pc}
   11c4e:	mov	r2, r0
   11c50:	b.n	11c42 <_calloc_r+0x3e>
   11c52:	movs	r1, #0
   11c54:	bl	88dc <memset>
   11c58:	mov	r0, r4
   11c5a:	pop	{r4, pc}
   11c5c:	add.w	r2, r0, #8
   11c60:	b.n	11c42 <_calloc_r+0x3e>
   11c62:	nop
   11c64:	.word	0x25206425
   11c68:	.short	0x0a64
   11c6a:	.byte	0x00
   11c6b:	.byte	0x62
   11c6c:	.word	0x63697361
   11c70:	.word	0x756f5320
   11c74:	.word	0x5220646e
   11c78:	.word	0x726f6365
   11c7c:	.word	0x20726564
   11c80:	.word	0x73726556
   11c84:	.word	0x3a6e6f69
   11c88:	.word	0x62654620
   11c8c:	.word	0x20312020
   11c90:	.word	0x32323032
   11c94:	.word	0x3a303220
   11c98:	.word	0x323a3931
   11c9c:	.word	0x6e450030
   11ca0:	.word	0x666f2064
   11ca4:	.word	0x74655320
   11ca8:	.word	0xff007075

00011cac <vtable for Stream>:
	...
   11cb4:	................
   11cc4:	............

00011cd0 <vtable for StreamFile<FsBaseFile, unsigned long long>>:
	...
   11cd8:	................
   11ce8:	............

00011cf4 <vtable for FsFile>:
	...
   11cfc:	................
   11d0c:	............

00011d18 <vtable for File>:
	...
   11d20:	m...........;...
   11d30:	....G...+.......
   11d40:	....

00011d44 <vtable for SDFile>:
	...
   11d4c:	e...............
   11d5c:	................
   11d6c:	=...%...=...=...
   11d7c:	....U...........
   11d8c:	............7...
   11d9c:	..../Config.txt.
   11dac:	%10d.... Menu. '
   11dbc:	:h'  : print hel
   11dcc:	p. ':s'  : start
   11ddc:	 acquisition. ':
   11dec:	e'  : stop acqui
   11dfc:	sition. ':w'  : 
   11e0c:	write parameters
   11e1c:	 to microSD card
   11e2c:	. ':l'  : list d
   11e3c:	isks. ':r'  : re
   11e4c:	set MTP. ':b'  :
   11e5c:	 reboot CPU. '?p
   11e6c:	'  : show all pa
   11e7c:	rameters. '?d'  
   11e8c:	: get date. '?t'
   11e9c:	  : get time. '?
   11eac:	a'  : get file d
   11ebc:	uration (s). '!d
   11ecc:	 yyyy/mm/dd<cr>'
   11edc:	  : set date. '!
   11eec:	t hh:mm:ss<cr>' 
   11efc:	   : set time. '
   11f0c:	!a val<cr>'  : s
   11f1c:	et file duration
   11f2c:	 (s).CVAS_V3 Ver
   11f3c:	sion: Feb  1 202
   11f4c:	2 20:05:56.Teens
   11f5c:	y: %d: %06x..Dat
   11f6c:	e d = %04d/%02d/
   11f7c:	%02d..Time t = %
   11f8c:	02d:%02d:%02d..T
   11f9c:	_acq a = %d..%d%
   11fac:	c%d%c%d.start.st
   11fbc:	op.rebooting CPU
	...

00011fcd <monthDays>:
   11fcd:	...............

00011fdc <vtable for MySpiClass>:
	...
   11fe4:	....e...........
   11ff4:	A.......-.......

00012004 <cs>:
   12004:	...."...!...#...
   12014:	$...%...&...No s
   12024:	dio storage.No s
   12034:	pi storage.Stora
   12044:	ge %d %d %s .%d 
   12054:	%d.: .D./%s%06x_
   12064:	%04d%02d%02d/%02
   12074:	d/./%s%06x_%04d%
   12084:	02d%02d/%02d_%02
   12094:	d/.F.%s_%02d%02d
   120a4:	%02d.bin.Failing
   120b4:	 open file.WMXZ.
   120c4:	%s%04d%02d%02d_%
   120d4:	02d%02d%02d.sdio
   120e4:	.sd1.sd2.sd3.sd4
   120f4:	.sd5.sd6..

000120fe <SPISettings::ctar_div_table>:
   120fe:	................
   1210e:	...... .(.8.@.`.
   1211e:	..............

0001212c <SPIClass::spi0_hardware>:
   1212c:	<..@............
   1213c:	....A%....'.....
   1214c:	................
   1215c:	................
   1216c:	................
   1217c:	..........-.....
   1218c:	................
   1219c:	................
   121ac:	................
   121bc:	.. .

000121c0 <SPISettings::ctar_clock_table>:
   121c0:	................
   121d0:	................
   121e0:	. ....... ...0..
   121f0:	. ... ...@...@..
   12200:	.P...P...`...`..
   12210:	.p...`...p..

0001221c <TwoWire::i2c0_hardware>:
   1221c:	4..@@.....".0...
   1222c:	....!./.........

0001223c <TwoWire::i2c1_hardware>:
   1223c:	4..@....&:......
   1224c:	..%;............

0001225c <TwoWire::i2c2_hardware>:
   1225c:	(..@@...........
   1226c:	............J...

0001227c <vtable for TwoWire>:
	...
   12284:	O'..u'......M'..
   12294:	.'...'..7'..

000122a0 <vtable for SDClass>:
	...
   122a8:	.....(...)..#*..
   122b8:	.)..+)...*...*..
   122c8:	.+..+,..

000122d0 <FsGetPartitionInfo::mbdpGuid>:
   122d0:	......3D..h..&..
   122e0:	EFI PART..

000122ea <lookupTable>:
   122ea:	..x...C.........
   122fa:	..............=.
   1230a:	.. .............
   1231a:	................
   1232a:	................
   1233a:	....:.e,<.;.>.f,
   1234a:	B.A.S...T...V...
   1235a:	W...Y...[...`...
   1236a:	c...h...i...k.b,
   1237a:	o...r...u...}.d,
   1238a:	..............D.
   1239a:	..........E.....
   123aa:	{...|...}.......
   123ba:	................
   123ca:	................
   123da:	}.c,Q.Y.S.[.U.].
   123ea:	W._.x...y.......
   123fa:	............N!2!
   1240a:	.!.!a,`,v,u,

00012416 <mapTable>:
   12416:	a..............0
   12426:	2...9...J...y...
   12436:	................
   12446:	.......("...F...
   12456:	................
   12466:	0.. P...`.."...6
   12476:	.......Da..&....
   12486:	...Z........ ...
   12496:	0...@...`...p.J.
   124a6:	r.V.v.d.z.p.|.~.
   124b6:	................
   124c6:	........p!...$..
   124d6:	0,./g,...,.d.-.&
   124e6:	A...Device is to
   124f6:	o small...Writin
   12506:	g FAT ...Writing
   12516:	 upcase table...
   12526:	Writing root...F
   12536:	ormat done...For
   12546:	mat failed...EXF
   12556:	AT.Bad cluster c
   12566:	ount...Card is t
   12576:	oo small....Form
   12586:	at Done...Format
   12596:	 Failed...

000125a0 <vtable for SdSpiCard>:
	...
   125a8:	.o...o...p...o..
   125b8:	.t...u..-o...u..
   125c8:	ww...p...q...u..
   125d8:	.o...o..wt..ot..
   125e8:	.t.......o...w..
   125f8:	.u...v..

00012600 <vtable for SdioCard>:
	...
   12608:	=y...y..........
   12618:	.........{......
   12628:	!....~.......{..
   12638:	.x...x...x...y..
   12648:	-y..Yz...y...}..
   12658:	5~...}..

00012660 <digital_pin_to_info_PGM>:
   12660:	@..C@..@D..CD..@
   12670:	...C...@0..C0..@
   12680:	4..C4..@...C...@
   12690:	...C...@...C...@
   126a0:	...C...@...C...@
   126b0:	...C...@...C...@
   126c0:	...C...@...C...@
   126d0:	...C...@...C...@
   126e0:	...C...@...C...@
   126f0:	...C...@...C...@
   12700:	...C...@...C...@
   12710:	...C...@...C...@
   12720:	h .Ch..@...C...@
   12730:	8..C8..@<..C<..@
   12740:	@..C@..@H..CH..@
   12750:	L..CL..@(..C(..@
   12760:	,..C,..@` .C`..@
   12770:	d .Cd..@ ..C ..@
   12780:	$..C$..@(..C(..@
   12790:	,..C,..@D..CD..@
   127a0:	p..Cp..@t..Ct..@
   127b0:	h..Ch..@P..CP..@
   127c0:	X..CX..@\..C\..@
   127d0:	T..CT..@ ..C ..@
   127e0:	$..C$..@...C...@
   127f0:	...C...@8..C8..@
   12800:	4..C4..@0..C0..@
   12810:	<..C<..@,..C,..@
   12820:	( .C(..@, .C,..@
   12830:	. .C...@. .C...@
   12840:	. .C...@. .C...@
   12850:	. .C...@. .C...@

00012860 <vtable for usb_serial_class>:
	...
   12868:	}...u...q...m...
   12878:	i...e...a...]...
   12888:	..

0001288a <usb_endpoint_config_table>:
   1288a:	......

00012890 <usb_descriptor_list>:
   12890:	....y...........
   128a0:	....C...........
   128b0:	................
   128c0:	................
   128d0:	................
   128e0:	....

000128e4 <_global_impure_ptr>:
   128e4:	....C...POSIX...
   128f4:	....

000128f8 <fpi.6173>:
   128f8:	5...............
   12908:	....nf..inity...
   12918:	an..

0001291c <fpinan.6209>:
   1291c:	4...............
   1292c:	....

00012930 <tinytens>:
   12930:	.......<3...#.I9
   12940:	=..D...2......[%
   12950:	Co.d(.h.

00012958 <zeroes.7258>:
   12958:	0000000000000000
   12968:	INF.inf.NAN.nan.
   12978:	0123456789ABCDEF
   12988:	....0123456789ab
   12998:	cdef....(null)..
   129a8:	0...

000129ac <blanks.7257>:
   129ac:	                

000129bc <basefix.7328>:
   129bc:	................
   129cc:	................
   129dc:	....e%ld....

000129e8 <_ctype_>:
   129e8:	.         ((((( 
   129f8:	                
   12a08:	 ...............
   12a18:	................
   12a28:	..AAAAAA........
   12a38:	................
   12a48:	..BBBBBB........
   12a58:	................
   12a68:	 ...............
	...
   12ae8:	....Infinity....
   12af8:	NaN.

00012afc <__hexdig>:
	...
   12b2c:	................
   12b3c:	................
	...
   12b5c:	................
	...
   12bfc:	....

00012c00 <__mprec_tens>:
   12c00:	.......?......$@
   12c10:	......Y@.....@.@
   12c20:	.......@.....j.@
   12c30:	.......A......cA
   12c40:	.......A....e..A
   12c50:	... _..B....vH7B
   12c60:	......mB..@..0.B
   12c70:	.......B..4&.k.C
   12c80:	...7y.AC....W4vC
   12c90:	..Ngm..C.=.`.X.C
   12ca0:	@..x...DP.....KD
   12cb0:	..M....D.J...-.D
   12cc0:	...yCx.D

00012cc8 <__mprec_bigtens>:
   12cc8:	...7y.AC.n.....F
   12cd8:	..?..O8M2.0.Hw.Z
   12ce8:	<.s..O.u

00012cf0 <p05.6087>:
   12cf0:	........}...

00012cfc <_init>:
   12cfc:	push	{r3, r4, r5, r6, r7, lr}
   12cfe:	nop
   12d00:	pop	{r3, r4, r5, r6, r7}
   12d02:	pop	{r3}
   12d04:	mov	lr, r3
   12d06:	bx	lr

00012d08 <__init_array_start>:
   12d08:	.word	0x0000f00d

00012d0c <__frame_dummy_init_array_entry>:
   12d0c:	5.... ..]%..u%..
   12d1c:	.%...%...%...%..
   12d2c:	.%...&..5&..M&..
   12d3c:	e&..}&...&...&..
   12d4c:	.&...&...&...,..

Disassembly of section .fini:

00012d5c <_fini>:
   12d5c:	push	{r3, r4, r5, r6, r7, lr}
   12d5e:	nop
