
.vsteensy/build/basicSoundRecorder_T36.elf:     file format elf32-littlearm

SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
00013548 l    d  .fini	00000000 .fini
0001354c l    d  .ARM.exidx	00000000 .ARM.exidx
1fff0000 l    d  .usbdescriptortable	00000000 .usbdescriptortable
1fff0200 l    d  .dmabuffers	00000000 .dmabuffers
1fff0bd0 l    d  .usbbuffers	00000000 .usbbuffers
1fff0f30 l    d  .data	00000000 .data
1fff1da8 l    d  .bss	00000000 .bss
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 mk20dx128.c
000093f0 l     F .text	0000000c startup_default_early_hook
000093fc l     F .text	00000002 startup_default_late_hook
00000000 l    df *ABS*	00000000 crtstuff.c
00000410 l     F .text	00000000 __do_global_dtors_aux
1fff1da8 l       .bss	00000000 completed.8605
00000434 l     F .text	00000000 frame_dummy
1fff1dac l       .bss	00000000 object.8610
00013534 l     O .text	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 acq.cpp
000006b4 l     F .text	00000058 acq_isr()
0000070c l     F .text	00000028 _GLOBAL__sub_I_acq_count
1fff0200 l     O .dmabuffers	00000800 tdm_rx_buffer
1fff1dcc l     O .bss	00000400 acq_rx_buffer
1fff21cc l     O .bss	00000008 dma
00000000 l    df *ABS*	00000000 main.cpp
1fff21d8 l     O .bss	00000004 checkToCloseFile(short, unsigned long)::to
1fff21dc l     O .bss	00000004 loop::t0
1fff21e0 l     O .bss	00000002 loop::status
00000000 l    df *ABS*	00000000 menu.cpp
00000b50 l     F .text	00000024 File::dec_refcount() [clone .isra.15]
00000000 l    df *ABS*	00000000 utils.cpp
00000000 l    df *ABS*	00000000 mTime.cpp
00012825 l     O .text	0000000c monthDays
00000000 l    df *ABS*	00000000 filing.cpp
00001888 l     F .text	00000002 __tcf_0
0000194c l     F .text	00000024 File::dec_refcount() [clone .isra.23]
0000222c l     F .text	000000bc _GLOBAL__sub_I_data_buffer
1fff222c l     O .bss	00000004 isd
1fff0f3c l     O .data	00000004 checkDiskSpace()::isd_
20017a34 l     O .bss	00000200 saveData(short)::header
20018100 l     O .bss	00000050 saveData(short)::fileName
20018150 l     O .bss	00000004 saveData(short)::dirFlag
20018160 l     O .bss	00000050 saveData(short)::dirName
200181b0 l     O .bss	00001000 dummy_buffer
00000000 l    df *ABS*	00000000 adc.cpp
00002580 l     F .text	00000014 _GLOBAL__sub_I_gain
00000000 l    df *ABS*	00000000 WireKinetis.cpp
0000286a l       .text	00000000 L_1161_delayMicroseconds
00002878 l       .text	00000000 L_1175_delayMicroseconds
000028c0 l       .text	00000000 L_1220_delayMicroseconds
00002b50 l       .text	00000000 L_2399_delayMicroseconds
2001a1c4 l     O .bss	00000001 TwoWire::isr()::receiving
00000000 l    df *ABS*	00000000 SPI.cpp
00002bc0 l     F .text	00000022 DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]
00000000 l    df *ABS*	00000000 SD.cpp
00003460 l     F .text	00000064 _GLOBAL__sub_I_SD
00000000 l    df *ABS*	00000000 FsUtf.cpp
00000000 l    df *ABS*	00000000 FsGetPartitionInfo.cpp
00012af8 l     O .text	00000010 FsGetPartitionInfo::mbdpGuid
00000000 l    df *ABS*	00000000 FsStructs.cpp
00000000 l    df *ABS*	00000000 FsCache.cpp
00000000 l    df *ABS*	00000000 upcase.cpp
00012b12 l     O .text	0000012c lookupTable
00012c3e l     O .text	000000d4 mapTable
00000000 l    df *ABS*	00000000 FsName.cpp
00000000 l    df *ABS*	00000000 ExFatFormatter.cpp
00000000 l    df *ABS*	00000000 ExFatName.cpp
00000000 l    df *ABS*	00000000 ExFatFile.cpp
00000000 l    df *ABS*	00000000 ExFatPartition.cpp
00000000 l    df *ABS*	00000000 ExFatVolume.cpp
00000000 l    df *ABS*	00000000 ExFatFileWrite.cpp
00004cc4 l     F .text	0000002e exFatDirChecksum(unsigned char const*, unsigned short)
00000000 l    df *ABS*	00000000 FatFormatter.cpp
0000560c l     F .text	00000028 initFatDirCallback(unsigned long, void*)
00000000 l    df *ABS*	00000000 FatName.cpp
00000000 l    df *ABS*	00000000 FatFile.cpp
00000000 l    df *ABS*	00000000 FatPartition.cpp
00000000 l    df *ABS*	00000000 FatVolume.cpp
00000000 l    df *ABS*	00000000 FatFileLFN.cpp
00006dae l     F .text	0000001e FatFile::lfnChecksum(unsigned char*) [clone .isra.14]
00000000 l    df *ABS*	00000000 FsFile.cpp
00000000 l    df *ABS*	00000000 FsVolume.cpp
00000000 l    df *ABS*	00000000 FsNew.cpp
00000000 l    df *ABS*	00000000 SdSpiCard.cpp
0000778c l     F .text	00000006 SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]
00007792 l     F .text	00000006 SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]
00000000 l    df *ABS*	00000000 SdioTeensy.cpp
00007f74 l     F .text	00000028 sdIrs()
00007f9c l     F .text	00000018 isBusyCommandComplete()
00007fb4 l     F .text	00000010 isBusyCommandInhibit()
00007fc4 l     F .text	00000014 isBusyDat()
00007fd8 l     F .text	0000000c isBusyDMA()
00007fe4 l     F .text	00000014 isBusyFifoRead()
00007ff8 l     F .text	00000014 isBusyFifoWrite()
0000800c l     F .text	00000018 isBusyTransferComplete()
00008024 l     F .text	00000098 setSdclk(unsigned long)
00008120 l     F .text	00000024 waitTimeout(bool (*)())
00008144 l     F .text	00000040 yieldTimeout(bool (*)())
000081b4 l     F .text	00000054 cardCommand(unsigned long, unsigned long)
00008208 l     F .text	00000020 statusCMD13()
00008228 l     F .text	00000010 isBusyCMD13()
0000823c l     F .text	00000068 readReg16(unsigned long, void*)
000082a4 l     F .text	00000020 waitDmaStatus() [clone .part.4]
000082c4 l     F .text	0000009c rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)
0000849c l     F .text	0000005c waitTransferComplete()
00008838 l     F .text	00000098 cardCMD6(unsigned long, unsigned char*)
2001a6a0 l     O .bss	00000001 m_version2
2001a6a1 l     O .bss	00000010 m_cid
2001a6b4 l     O .bss	00000004 m_busyFcn
2001a6b8 l     O .bss	00000001 m_highCapacity
2001a6bc l     O .bss	00000004 m_ocr
2001a6c0 l     O .bss	00000004 m_rca
2001a6c4 l     O .bss	00000001 m_transferActive
2001a6c8 l     O .bss	00000004 m_irqstat
1fff1338 l     O .data	00000001 m_errorCode
2001a6cc l     O .bss	00000001 m_initDone
2001a6cd l     O .bss	00000010 m_csd
2001a6dd l     O .bss	00000001 m_dmaBusy
2001a6e0 l     O .bss	00000004 m_sdClkKhz
2001a6e4 l     O .bss	00000004 m_errorLine
00000000 l    df *ABS*	00000000 memcpy-armv7m.o
00000000 l    df *ABS*	00000000 memset.o
00000000 l    df *ABS*	00000000 usb_serial.c
2001a6e9 l     O .bss	00000001 tx_noautoflush
2001a6ec l     O .bss	00000004 tx_packet
2001a6f0 l     O .bss	00000001 transmit_previous_timeout
2001a6f4 l     O .bss	00000004 rx_packet
00000000 l    df *ABS*	00000000 pins_teensy.c
0000946c l     F .text	00000002 startup_default_middle_hook
00000000 l    df *ABS*	00000000 usb_mem.c
1fff1340 l     O .data	00000004 usb_buffer_available
00000000 l    df *ABS*	00000000 usb_dev.c
00009708 l     F .text	00000040 endpoint0_transmit
2001a700 l     O .bss	00000004 ep0_tx_ptr
2001a704 l     O .bss	00000010 rx_last
2001a714 l     O .bss	00000004 tx_state
2001a718 l     O .bss	00000040 ep0_rx0_buf
2001a758 l     O .bss	00000010 rx_first
2001a768 l     O .bss	00000001 ep0_tx_bdt_bank
2001a76c l     O .bss	00000040 ep0_rx1_buf
2001a7ac l     O .bss	00000010 tx_first
1fff0000 l     O .usbdescriptortable	000000a0 table
2001a7bc l     O .bss	00000010 tx_last
2001a7cc l     O .bss	00000008 setup
2001a7d4 l     O .bss	00000002 ep0_tx_len
2001a7d7 l     O .bss	00000008 reply_buffer
2001a7e0 l     O .bss	00000001 ep0_tx_data_toggle
00000000 l    df *ABS*	00000000 yield.cpp
2001a7e1 l     O .bss	00000001 yield::running
00000000 l    df *ABS*	00000000 DMAChannel.cpp
00000000 l    df *ABS*	00000000 EventResponder.cpp
00000000 l    df *ABS*	00000000 usb_inst.cpp
00000000 l    df *ABS*	00000000 Print.cpp
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 Stream.cpp
00000000 l    df *ABS*	00000000 serialEvent.cpp
00000000 l    df *ABS*	00000000 new.cpp
00000000 l    df *ABS*	00000000 analog.c
2001a811 l     O .bss	00000001 calibrating
1fff1359 l     O .data	00000001 analog_config_bits
2001a812 l     O .bss	00000001 analog_reference_internal
1fff135a l     O .data	00000001 analog_num_average
00000000 l    df *ABS*	00000000 usb_desc.c
1fff135b l     O .data	00000012 device_descriptor
1fff1386 l     O .data	00000043 config_descriptor
00000000 l    df *ABS*	00000000 nonstd.c
00000000 l    df *ABS*	00000000 atexit_arm.cc
00000000 l    df *ABS*	00000000 _lshrdi3.o
00000000 l    df *ABS*	00000000 _arm_addsubdf3.o
00000000 l    df *ABS*	00000000 _arm_muldivdf3.o
00000000 l    df *ABS*	00000000 _arm_cmpdf2.o
00000000 l    df *ABS*	00000000 _arm_unorddf2.o
00000000 l    df *ABS*	00000000 _arm_fixdfsi.o
00000000 l    df *ABS*	00000000 _arm_fixunsdfsi.o
00000000 l    df *ABS*	00000000 _arm_truncdfsf2.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 cxa_atexit.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 locale.c
0000b2c8 l     F .text	00000018 __get_current_locale
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 lib_a-memchr.o
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 sscanf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 lib_a-strlen.o
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strtod.c
0000c0fc l     F .text	00000038 sulp
00013120 l     O .text	00000014 fpi.6173
00013144 l     O .text	00000014 fpinan.6209
00013158 l     O .text	00000028 tinytens
00000000 l    df *ABS*	00000000 strtol.c
0000d030 l     F .text	00000136 _strtol_l.isra.0
00000000 l    df *ABS*	00000000 vfprintf.c
00013180 l     O .text	00000010 zeroes.7258
000131d4 l     O .text	00000010 blanks.7257
00000000 l    df *ABS*	00000000 vfscanf.c
000131e4 l     O .text	00000022 basefix.7328
00000000 l    df *ABS*	00000000 vdprintf.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0000f84c l     F .text	00000014 register_fini
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 dtoa.c
0000f86c l     F .text	00000128 quorem
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
00010a60 l     F .text	000000a8 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 localeconv.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mprec.c
00013518 l     O .text	0000000c p05.6087
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strtoll.c
00011bc8 l     F .text	000001ac _strtoll_l.isra.0
00000000 l    df *ABS*	00000000 strtoul.c
00011d98 l     F .text	00000168 _strtoul_l.isra.0
00000000 l    df *ABS*	00000000 strtoull.c
00011f24 l     F .text	000001ec _strtoull_l.isra.0
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 vfscanf.c
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vasnprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 impure.c
1fff1400 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 ctype_.c
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.19/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crti.o
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.19/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crtn.o
00000000 l    df *ABS*	00000000 FsDateTime.cpp
00000000 l    df *ABS*	00000000 avr_emulation.cpp
00000000 l    df *ABS*	00000000 HardwareSerial.cpp
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 
1fff1da8 l       .bss	00000000 __bss_start__
2001a860 l       .bss	00000000 __bss_end__
00000000 l       *UND*	00000000 software_init_hook
00000000 l       *UND*	00000000 hardware_init_hook
00000000 l       *UND*	00000000 __stack
00005ca0  w    F .text	00000026 FatPartition::cacheSync()
000093e8  w    F .text	00000006 adc0_isr
00000a6e  w    F .text	00000066 SDFile::getModifyTime(DateTimeFields&)
000038b4 g     F .text	000000a4 toUpcase(unsigned short)
00001aec g     F .text	00000034 pushData(unsigned long*)
0000adec g     F .text	0000002c .hidden __aeabi_dcmpun
00009184 g     F .text	0000001c usb_serial_available
000012f4 g     F .text	000001b4 menu()
00011ae8 g     F .text	0000005e __any_on
0000adb0 g     F .text	00000012 .hidden __aeabi_dcmple
000022f0  w    F .text	0000004a i2c_class::write16(unsigned char, unsigned short, unsigned short)
00006a00 g     F .text	0000002e FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)
0000acec g     F .text	0000007a .hidden __cmpdf2
000087c0 g     F .text	00000078 SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)
00009f54  w    F .text	000000d8 yield
1fff1dc8 g     O .bss	00000004 acq_miss
00006840 g     F .text	000001c0 FatFile::write(void const*, unsigned int)
0000acec g     F .text	0000007a .hidden __eqdf2
000076fc  w    F .text	00000002 SdSpiCard::~SdSpiCard()
0000a27c g     F .text	000000a6 Print::printNumber64(unsigned long long, unsigned char, unsigned char)
1fff136e g     O .data	00000018 usb_string_manufacturer_name_default
000067d6 g     F .text	00000068 FatFile::truncate()
1fff11bc g     O .data	0000013c Wire1
00003ab8 g     F .text	00000458 ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)
2001815c g     O .bss	00000004 clusterSize
0000a85c g     F .text	0000005a .hidden __floatdidf
00001518 g     F .text	00000024 newHour()
000093b4  w    F .text	00000034 hard_fault_isr
000093e8  w    F .text	00000006 dma_ch6_isr
00001970  w    F .text	00000054 MySpiClass::deactivate()
2001a690 g     O .bss	00000004 FsDateTime::callback
00002ffc  w    F .text	000000d8 SPIClass::dma_rxisr()
00003356  w    F .text	00000050 SdBase<FsVolume>::restart()
000056dc g     F .text	0000005c FatFormatter::initPbs()
0000a1bc g     F .text	00000020 Print::println()
000026f4 g     F .text	00000114 TwoWire::isr()
000093e8  w    F .text	00000006 uart0_lon_isr
0000434c g     F .text	000000d0 ExFatFile::seekSet(unsigned long long)
000097a4 g     F .text	00000078 usb_rx_memory
000076e0  w    F .text	00000004 SdSpiCard::errorCode() const
000009ba  w    F .text	0000000c File::flush()
00000a08  w    F .text	00000066 SDFile::getCreateTime(DateTimeFields&)
000093e8  w    F .text	00000006 dma_ch8_isr
0000bab0 g     F .text	00000002 __malloc_unlock
000077ac g     F .text	00000026 SdSpiCard::spiStart()
00000f68  w    F .text	00000088 SDFile::openNextFile(unsigned char)
2001a69c g     O .bss	00000004 FsVolume::m_cwv
000062c4 g     F .text	000000a8 FatFile::open(FatFile*, char const*, int)
1fff220c g     O .bss	00000004 SerNum
0000a3bc g     F .text	000000b8 analog_init
00001938  w    F .text	00000014 MySpiClass::begin(SdSpiConfig)
0000981c g     F .text	00000080 usb_tx
0000d010 g     F .text	00000020 _strtod_r
000093e8  w    F .text	00000006 portcd_isr
00001abc  w    F .text	00000016 MySpiClass::setSckSpeed(unsigned long)
0000f6fc g     F .text	0000004a _vdprintf_r
000063ae g     F .text	00000020 FatFile::getCreateDateTime(unsigned short*, unsigned short*)
00002d8c g     F .text	000000a4 SPIClass::setSCK(unsigned char)
00001e10 g     F .text	0000041c saveData(short)
0000a530 g     F .text	00000018 .hidden __aeabi_llsr
0001259c  w    O .text	0000005c vtable for SDFile
000122f4 g     F .text	00000082 _sfread_r
0000b9e4 g     F .text	000000c6 memmove
0000b304 g     F .text	00000014 __locale_ctype_ptr
00008e28 g     F .text	00000060 SdioCard::stopTransmission(bool)
00011260 g     F .text	0000004c _Balloc
000093e8  w    F .text	00000006 can1_rx_warn_isr
00013554 g       .ARM.exidx	00000000 __exidx_end
000093e8  w    F .text	00000006 dma_error_isr
0000331c  w    F .text	0000003a SdBase<FsVolume>::cardBegin(SdSpiConfig)
00006bbe g     F .text	00000046 FatPartition::freeChain(unsigned long)
2001a7f4 g     O .bss	00000001 EventResponder::runningFromYield
00007992 g     F .text	0000007c SdSpiCard::cardCommand(unsigned char, unsigned long)
00002b9c g     F .text	0000000c i2c0_isr
000017d0  w    F .text	0000009c MySpiClass::activate()
0000a192 g     F .text	00000028 Print::write(unsigned char const*, unsigned int)
0000acdc g     F .text	0000008a .hidden __gtdf2
0000b26c g     F .text	0000000c __errno
00000c5c  w    F .text	0000000a SDFile::isDirectory()
0000522c g     F .text	00000112 ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
00000992  w    F .text	0000000c File::write(unsigned char const*, unsigned int)
000093e8  w    F .text	00000006 portd_isr
000010f8 g     F .text	0000001c saveParameters()
000093e8  w    F .text	00000006 enet_error_isr
00007a0e  w    F .text	0000001e SdSpiCard::cardAcmd(unsigned char, unsigned long)
00012964 g     O .text	00000020 TwoWire::i2c2_hardware
00000b74  w    F .text	0000001c File::~File()
2001a7e4 g     O .bss	00000004 EventResponder::firstInterrupt
000111e4 g     F .text	00000004 __localeconv_l
000076fe  w    F .text	0000000e SdSpiCard::~SdSpiCard()
00003a0a g     F .text	0000001c ExFatFormatter::writeUpcaseUnicode(unsigned short)
000004a0 g     F .text	00000028 acq_startClocks()
00007492 g     F .text	00000062 FsBaseFile::FsBaseFile(FsBaseFile const&)
000093e8  w    F .text	00000006 tpm1_isr
00004c58 g     F .text	00000018 ExFatPartition::rootLength()
00000e9a  w    F .text	00000036 SDFile::setCreateTime(DateTimeFields const&)
000076e4  w    F .text	00000004 SdSpiCard::errorData() const
0000a184  w    F .text	00000008 usb_serial_class::write(unsigned char const*, unsigned int)
00012e88 g     O .text	00000200 digital_pin_to_info_PGM
00000478 g     F .text	00000028 acq_stopClocks()
2001a85c g     O .bss	00000004 errno
00007be0 g     F .text	00000038 SdSpiCard::readOCR(unsigned long*)
000049e4 g     F .text	0000003e ExFatPartition::fatGet(unsigned long, unsigned long*)
0000bf5c g     F .text	00000004 __seofread
00013554 g       .ARM.exidx	00000000 _etext
000030d4 g     F .text	00000010 _spi_dma_rxISR0()
00001dac g     F .text	0000005c listDisks()
1fff1da8 g       .bss	00000000 _sbss
00005738 g     F .text	0000005c FatFormatter::writeMbr()
00001b64 g     F .text	0000001c sdCsInit(unsigned char)
0000340a g     F .text	00000054 SDClass::mediaPresent()
0000ad78 g     F .text	00000010 .hidden __aeabi_cdcmple
000080c8 g     F .text	0000000c SdioCard::errorData() const
00000d0a  w    F .text	00000018 FsBaseFile::peek()
00008700 g     F .text	000000c0 SdioCard::writeSector(unsigned long, unsigned char const*)
000093e8  w    F .text	00000006 porte_isr
0000082c g     F .text	00000160 loop
000093e8  w    F .text	00000006 portb_isr
000093e8  w    F .text	00000006 spi1_isr
000093e8  w    F .text	00000006 uart3_status_isr
00004120 g     F .text	0000007c ExFatFile::parsePathName(char const*, ExName_t*, char const**)
000093e8  w    F .text	00000006 mcm_isr
00008c2c g     F .text	000000c4 SdioCard::readData(unsigned char*)
0000782a g     F .text	00000060 SdSpiCard::readData(unsigned char*, unsigned int)
000028e8 g     F .text	000000f8 TwoWire::endTransmission(unsigned char)
2001a7e8 g     O .bss	00000004 EventResponder::lastInterrupt
000093e8  w    F .text	00000006 uart1_status_isr
000074f4 g     F .text	00000028 FsBaseFile::close()
00008f14 g     F .text	000001a6 memcpy
000093e8  w    F .text	00000006 randnum_isr
00011048 g     F .text	00000180 __hexnan
0000ad68 g     F .text	00000020 .hidden __aeabi_cdrcmple
0000099e  w    F .text	0000000c File::available()
000019ec  w    F .text	00000014 Print::println(unsigned long)
000034c4 g     F .text	00000094 FsUtf::cpToMb(unsigned long, char*, char*)
00001068 g     F .text	00000090 storeConfig(unsigned short*, int)
00004aca g     F .text	0000005e ExFatPartition::freeChain(unsigned long)
00005f7c g     F .text	00000028 FatFile::peek()
0000d190 g     F .text	000016e4 _svfprintf_r
0000a7ec g     F .text	00000022 .hidden __floatsidf
1fff21e8  w    O .bss	00000001 SDFile::name()::zeroterm
2001a6fc g     O .bss	00000004 systick_millis_count
0000ace4 g     F .text	00000082 .hidden __ltdf2
00005186 g     F .text	000000a6 ExFatFile::rename(ExFatFile*, char const*)
000093b4  w    F .text	00000034 bus_fault_isr
00000b14  w    F .text	0000003c SDFile::truncate(unsigned long long)
00002808 g     F .text	000000e0 TwoWire::wait_idle()
000093e8  w    F .text	00000006 watchdog_isr
0000af48 g     F .text	00000000 .hidden __aeabi_uldivmod
00002ba8 g     F .text	0000000c i2c1_isr
2001a7df g     O .bss	00000001 usb_configuration
000093e8  w    F .text	00000006 dma_ch11_isr
000017ca  w    F .text	00000006 SdCardInterface::status()
00008e88 g     F .text	0000001c SdioCard::syncDevice()
00008580 g     F .text	00000094 SdioCard::writeData(unsigned char const*)
00000000  w      *UND*	00000000 __fini_array_end
2001a7f5 g     O .bss	00000001 SPCRemulation::pinout
00000c28  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::available()
1fff21ea g     O .bss	00000020 store
00005fa4 g     F .text	0000003a FatFile::readDirCache(bool)
00011a40 g     F .text	00000060 __ratio
00002bb4 g     F .text	0000000c i2c2_isr
1fff136e  w    O .data	00000018 usb_string_manufacturer_name
2001a854 g     O .bss	00000008 usb_rx_byte_count_data
000093e8  w    F .text	00000006 pit1_isr
0000b318 g     F .text	00000010 malloc
000093e8  w    F .text	00000006 dma_ch4_isr
00012944 g     O .text	00000020 TwoWire::i2c1_hardware
000093e8  w    F .text	00000006 software_isr
00007798  w    F .text	00000014 SysCall::curTimeMS()
000033a6 g     F .text	00000064 SDClass::format(int, char, Print&)
0001254c  w    O .text	00000024 vtable for FsFile
000111c8 g     F .text	0000001c iswspace
000093e8  w    F .text	00000006 dma_ch7_isr
000025a0  w    F .text	0000001e TwoWire::read()
00013428 g     O .text	000000c8 __mprec_tens
00009ec0 g     F .text	00000094 usb_init
000076f8  w    F .text	00000004 SdSpiCard::type() const
0000ae68 g     F .text	00000040 .hidden __fixunsdfsi
000093e8  w    F .text	00000006 lptmr_isr
00000da0  w    F .text	00000058 SDFile::seek(unsigned long long, int)
2001a81c g     O .bss	00000004 __malloc_top_pad
0000944c g     F .text	00000020 rtc_set
000122b8 g     F .text	0000003a __ssrefill_r
0000788a g     F .text	0000006a SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
0000533e g     F .text	000000be ExFatFile::truncate()
1fff0f30 g     O .data	00000000 .hidden __dso_handle
0000a7cc g     F .text	0000001e .hidden __aeabi_ui2d
000111e8 g     F .text	0000001c _localeconv_r
1fff0f40 g     O .data	00000004 sd_str
00012110 g     F .text	00000024 _strtoull_r
00009430 g     F .text	00000010 attachInterruptVector
00011474 g     F .text	00000012 __i2b
1fff0f30 g       .data	00000000 _sdata
00012924 g     O .text	00000020 TwoWire::i2c0_hardware
00005898 g     F .text	000001a8 FatFormatter::makeFat32()
0000af78 g     F .text	000002e2 .hidden __udivmoddi4
0000a548 g     F .text	00000000 .hidden __aeabi_drsub
00005cc6 g     F .text	00000036 FatFile::addCluster()
0000be94 g     F .text	00000024 _sbrk_r
00007c18 g     F .text	00000036 SdSpiCard::readRegister(unsigned char, void*)
00008194 g     F .text	00000020 SdioCard::type() const
000001d0 g     F .text	000001f0 ResetHandler
00009100 g     F .text	0000004c usb_serial_getchar
000093e8  w    F .text	00000006 can1_bus_off_isr
00001a20  w    F .text	00000018 FsVolume::clusterCount() const
000093e8  w    F .text	00000006 ftm2_isr
00000ad4  w    F .text	00000040 SDFile::name()
2001a848 g     O .bss	00000008 usb_cdc_line_coding
00009470 g     F .text	00000040 digitalWrite
2001a7ec g     O .bss	00000004 EventResponder::lastYield
000093e8  w    F .text	00000006 uart5_status_isr
000093e8  w    F .text	00000006 lpuart0_status_isr
000040fa g     F .text	00000026 ExFatFile::openRoot(ExFatVolume*)
000130b2 g     O .text	00000004 usb_endpoint_config_table
000093e8  w    F .text	00000006 dma_ch9_isr
00000734  w    F .text	0000001c Print::write(char const*)
00000d4e  w    F .text	00000020 StreamFile<FsBaseFile, unsigned long long>::read()
000093e8  w    F .text	00000006 pit2_isr
000039a0 g     F .text	00000028 ExFatFormatter::syncUpcase()
00000e64  w    F .text	00000036 SDFile::setModifyTime(DateTimeFields const&)
0000ad9c g     F .text	00000012 .hidden __aeabi_dcmplt
00012a6c g     O .text	0000005c SPISettings::ctar_clock_table
2001a818 g     O .bss	00000004 __malloc_max_sbrked_mem
00000ba4  w    F .text	00000018 SDFile::position()
000094b0 g     F .text	00000064 pinMode
000014a8 g     F .text	00000034 getTeensySerial()
00007e6e g     F .text	00000028 SdSpiCard::writeStop()
000096c4 g     F .text	00000044 usb_free
000093e8  w    F .text	00000006 i2c3_isr
0000a810 g     F .text	0000003a .hidden __extendsfdf2
0000e874 g     F .text	00000e88 __ssvfscanf_r
0000ab0c g     F .text	000001d0 .hidden __aeabi_ddiv
00000d36  w    F .text	00000018 FsBaseFile::read(void*, unsigned int)
0000a554 g     F .text	00000276 .hidden __adddf3
1fff0f44 g     O .data	0000013c Wire2
0000076c g     F .text	00000030 checkToCloseFile(short, unsigned long)
00007ee2 g     F .text	0000002c SdSpiCard::writeData(unsigned char const*)
000009aa  w    F .text	00000010 File::peek()
00006c04 g     F .text	0000005c FatPartition::freeClusterCount()
00000ff0  w    F .text	00000078 SDClass::open(char const*, unsigned char)
000118b4 g     F .text	000000d0 __b2d
0000233a g     F .text	00000002 adc_init()
0001354c g       .ARM.exidx	00000000 __exidx_start
0000a8b8 g     F .text	00000254 .hidden __aeabi_dmul
0000046c  w    F .text	0000000c DMAChannel::~DMAChannel()
00007dac g     F .text	00000030 SdSpiCard::writeStart(unsigned long)
000093e8  w    F .text	00000006 pit0_isr
2001a7f0 g     O .bss	00000004 EventResponder::firstYield
0001310c g     O .text	00000004 _global_impure_ptr
00000750  w    F .text	00000008 Print::print(unsigned long)
000093e8  w    F .text	00000006 can1_error_isr
00003558 g     F .text	00000084 FsUtf::mbToCp(char const*, char const*, unsigned long*)
00000eee  w    F .text	00000018 StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)
00000f2c  w    F .text	0000003c SDFile::SDFile(FsFile const&)
0000bab4 g     F .text	000003de _realloc_r
00000d6e  w    F .text	0000000a SDFile::read(void*, unsigned int)
0000b278 g     F .text	00000050 __libc_init_array
2001a860 g       .bss	00000000 __bss_end
00000c66  w    F .text	00000028 SDFile::rewindDirectory()
00002594  w    F .text	0000000c TwoWire::available()
000093e8  w    F .text	00000006 can0_wakeup_isr
00004826 g     F .text	0000000e ExFatFile::open(ExFatVolume*, char const*, int)
000080d4 g     F .text	0000001c SdioCard::readCID(CID*)
00013324 g     O .text	00000100 __hexdig
00004fa2 g     F .text	000000de ExFatFile::addDirCluster()
000093e8  w    F .text	00000006 flash_cmd_isr
00007cf4 g     F .text	00000076 SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)
00007e96 g     F .text	0000004c SdSpiCard::writeData(unsigned char, unsigned char const*)
000134f0 g     O .text	00000028 __mprec_bigtens
00011340 g     F .text	00000098 __s2b
000029e0 g     F .text	000001bc TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)
0000a16c  w    F .text	00000004 usb_serial_class::clear()
0000a7cc g     F .text	0000001e .hidden __floatunsidf
000093e8  w    F .text	00000006 uart2_status_isr
00009400 g     F .text	0000002c _sbrk
0000186c  w    F .text	0000001c MySpiClass::send(unsigned char)
00011708 g     F .text	00000042 __mcmp
00012ac8 g     O .text	00000030 vtable for SDClass
1fff133c g     O .data	00000004 __brkval
2001a6f8 g     O .bss	00000001 usb_cdc_line_rtsdtr
0000936c g     F .text	00000048 usb_serial_flush_callback
00013524 g     F .text	00000000 _init
00005d88 g     F .text	0000001e FatFile::cacheDirEntry(unsigned char)
000093e8  w    F .text	00000006 svcall_isr
0000317e  w    F .text	00000056 SDClass::remove(char const*)
00000ca0  w    F .text	00000026 SDFile::close()
000093e8  w    F .text	00000006 dma_ch15_isr
00000cc8  w    F .text	00000024 SDFile::~SDFile()
0000aea8 g     F .text	0000009e .hidden __aeabi_d2f
00012984 g     O .text	00000024 vtable for TwoWire
000093e8  w    F .text	00000006 uart1_error_isr
000107cc g     F .text	00000028 __libc_fini_array
0000c138 g     F .text	00000ed8 _strtod_l
00011018 g     F .text	00000030 __match
000093e8  w    F .text	00000006 usbhs_phy_isr
2001a860 g       .bss	00000000 _ebss
00008688 g     F .text	00000078 SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
1fff2210 g     O .bss	00000004 hour_
00000e0c  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::flush()
000022e8  w    F .text	00000008 TwoWire::write(int)
00001796  w    F .text	00000034 BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)
000113d8 g     F .text	00000040 __hi0bits
0000406e g     F .text	00000038 ExFatFile::dirCache(unsigned char, unsigned char)
0000ae18 g     F .text	0000004e .hidden __fixdfsi
00005080 g     F .text	00000048 ExFatFile::mkdir(ExFatFile*, ExName_t*)
000093e8 g     F .text	00000006 unused_isr
00000f2c  w    F .text	0000003c SDFile::SDFile(FsFile const&)
000093e8  w    F .text	00000006 spi0_isr
000093e8  w    F .text	00000006 dma_ch3_isr
000030e4  w    F .text	00000002 SDClass::~SDClass()
00004c70 g     F .text	00000054 ExFatVolume::chdir(char const*)
0000046c  w    F .text	0000000c DMAChannel::~DMAChannel()
200191c0 g     O .bss	00001000 diskBuffer
20017c38 g     O .bss	000004c8 sdx
00007064 g     F .text	00000092 FatFile::makeUniqueSfn(FatName_t*)
00000b74  w    F .text	0000001c File::~File()
00001b9c g     F .text	00000210 storage_configure()
00005a40 g     F .text	000000a0 FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)
00005afa g     F .text	00000028 FatFile::getLfnChar(DirLfn_t*, unsigned char)
0000a3b8 g     F .text	00000004 operator delete(void*, unsigned int)
000093e8  w    F .text	00000006 flash_error_isr
0000a530 g     F .text	00000018 .hidden __lshrdi3
0000a554 g     F .text	00000276 .hidden __aeabi_dadd
1fff2214 g     O .bss	00000014 file
0000ace4 g     F .text	00000082 .hidden __ledf2
000093e8  w    F .text	00000006 uart5_error_isr
000093e8  w    F .text	00000006 rtc_seconds_isr
000129d8 g     O .text	00000094 SPIClass::spi0_hardware
000093e8  w    F .text	00000006 pdb_isr
000115b8 g     F .text	000000a0 __pow5mult
000061e4 g     F .text	0000004e FatFile::rmdir()
0000a84c g     F .text	0000006a .hidden __aeabi_ul2d
000093b4  w    F .text	00000034 usage_fault_isr
000093e8  w    F .text	00000006 dac1_isr
00000000 g     O .text	000001d0 _VectorsFlash
00006b3e g     F .text	00000080 FatPartition::allocateCluster(unsigned long, unsigned long*)
000093e8  w    F .text	00000006 dma_ch14_isr
0000a116  w    F .text	00000006 MillisTimer::enableTimerInterrupt(bool)
000030e6  w    F .text	00000044 SDClass::exists(char const*)
00000000  w      *UND*	00000000 __deregister_frame_info
2001a850 g     O .bss	00000004 usb_cdc_line_rtsdtr_millis
00000758  w    F .text	00000014 Print::println(char const*)
0000a15c g     F .text	00000010 systick_isr
00000694 g     F .text	0000001e extract(void*, void*)
000012a8 g     F .text	0000004c menuGet3Int(int*, int*, int*)
000093e8  w    F .text	00000006 rtc_alarm_isr
200191b0 g     O .bss	0000000c mySpi
00007c8e g     F .text	00000066 SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)
000093e8  w    F .text	00000006 dma_ch2_isr
1fff1348 g     O .data	00000010 Serial
000093e8  w    F .text	00000006 ftm1_isr
0000a18c  w    F .text	00000006 usb_serial_class::write(unsigned char)
0000759a g     F .text	0000005e FsBaseFile::openNext(FsBaseFile*, int)
000093f0  w    F .text	0000000c startup_early_hook
00007f0e g     F .text	00000048 SdSpiCard::writeSingle(unsigned long, unsigned char const*)
000093e8  w    F .text	00000006 dma_ch13_isr
00004d18 g     F .text	00000092 ExFatFile::addCluster()
00012570  w    O .text	0000002c vtable for File
000093e8  w    F .text	00000006 uart2_error_isr
000032b0  w    F .text	00000036 SDClass::usedSize()
0000914c g     F .text	00000038 usb_serial_peekchar
0000add8 g     F .text	00000012 .hidden __aeabi_dcmpgt
00001114 g     F .text	000000d4 printMenu()
0000b8e0 g     F .text	00000000 memchr
00006ae2 g     F .text	0000005c FatPartition::fatPut(unsigned long, unsigned long)
1fff13e4 g     O .data	00000016 usb_string_serial_number_default
000093b4 g     F .text	00000034 fault_isr
00010890 g     F .text	000001d0 _free_r
000084f8 g     F .text	00000088 SdioCard::readStop()
00003866 g     F .text	0000004e FsCache::get(unsigned long, unsigned char)
0000b2e0 g     F .text	0000001c __locale_mb_cur_max
0000adc4 g     F .text	00000012 .hidden __aeabi_dcmpge
000093e8  w    F .text	00000006 usb_charge_isr
00006f3c g     F .text	00000128 FatFile::makeSFN(FatName_t*)
0000a17c  w    F .text	00000004 usb_serial_class::flush()
00003a26 g     F .text	00000090 ExFatFormatter::writeUpcase(unsigned long)
00012234 g     F .text	00000082 _sungetc_r
000093e8  w    F .text	00000006 cmt_isr
0000a550 g     F .text	0000027a .hidden __aeabi_dsub
00006c60 g     F .text	00000108 FatPartition::init(BlockDeviceInterface*, unsigned char)
000093e8  w    F .text	00000006 usbhs_isr
1fff1da4 g     O .data	00000004 __malloc_sbrk_base
0000a174  w    F .text	00000004 usb_serial_class::read()
000093e8  w    F .text	00000006 ftm3_isr
00011d74 g     F .text	00000024 _strtoll_r
000093e8  w    F .text	00000006 tsi0_isr
000073e0 g     F .text	000000b2 FatFile::remove()
0000a84c g     F .text	0000006a .hidden __floatundidf
20017c34 g     O .bss	00000004 msd
0000942c  w    F .text	00000002 __cxa_pure_virtual
0000233c g     F .text	00000002 adcStatus()
00011658 g     F .text	000000ae __lshift
000064e8 g     F .text	000000aa FatFile::mkdir(FatFile*, char const*, bool)
000004e0 g     F .text	00000014 acq_stop()
000093e8  w    F .text	00000006 spi2_isr
00012134 g     F .text	00000100 __ssprint_r
000123f0 g     F .text	0000005e _vasnprintf_r
0000a3b2  w    F .text	00000002 serialEvent()
2001a769 g     O .bss	00000001 usb_reboot_timer
0000f7a8 g     F .text	000000a4 __register_exitproc
0000476c g     F .text	000000ba ExFatFile::open(ExFatFile*, char const*, int)
0000c05c g     F .text	000000a0 strncmp
00000e20  w    F .text	00000044 FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
000050c8 g     F .text	000000be ExFatFile::mkdir(ExFatFile*, char const*, bool)
00005794 g     F .text	00000104 FatFormatter::makeFat16()
000091a0 g     F .text	00000030 usb_serial_flush_input
00004b28 g     F .text	00000064 ExFatPartition::freeClusterCount()
00011488 g     F .text	00000130 __multiply
1fff1dc4 g     O .bss	00000004 acq_count
000092b0 g     F .text	00000016 usb_serial_putchar
00000022 g       *ABS*	00000000 _teensy_model_identifier
2001a820 g     O .bss	00000028 __malloc_current_mallinfo
00011984 g     F .text	000000ba __d2b
2001a7f8 g     O .bss	00000018 HardwareSerial::s_serials_with_serial_events
000093e8  w    F .text	00000006 can0_bus_off_isr
00008184  w    F .text	0000000e SdioCard::~SdioCard()
00001ab0  w    F .text	0000000c SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)
2001a7d6 g     O .bss	00000001 usb_rx_memory_needed
00008614 g     F .text	00000074 SdioCard::writeStart(unsigned long)
00011f00 g     F .text	00000024 _strtoul_r
0000989c g     F .text	00000624 usb_isr
0000b260 g     F .text	0000000c __cxa_atexit
0000419c g     F .text	00000184 ExFatFile::read(void*, unsigned int)
2001a1c0 g     O .bss	00000004 i2c
0000a7ec g     F .text	00000022 .hidden __aeabi_i2d
00000d2c  w    F .text	0000000a SDFile::peek()
0000381a g     F .text	0000004c FsCache::sync()
1fff12f8 g     O .data	00000040 SPI
0000b980 g     F .text	00000062 memcmp
00013088  w    O .text	00000028 vtable for usb_serial_class
00006e68 g     F .text	000000d4 FatFile::createLFN(unsigned short, FatName_t*, unsigned char)
000093e8  w    F .text	00000006 uart3_error_isr
00001b80 g     F .text	0000001c sdCsWrite(unsigned char, bool)
0000bf04 g     F .text	00000058 sscanf
0000b25c  w    F .text	00000002 .hidden __aeabi_ldiv0
00004e30 g     F .text	00000052 ExFatFile::rmdir()
0000126c g     F .text	0000003c menuGetInt(int*)
000093e8  w    F .text	00000006 porta_isr
00001a00  w    F .text	00000020 FsVolume::bytesPerCluster() const
0000ab0c g     F .text	000001d0 .hidden __divdf3
00011aa0 g     F .text	00000046 __copybits
1fff0bd0 g     O .usbbuffers	00000360 usb_buffer_memory
0000770c g     F .text	00000080 SdSpiCard::sectorCount()
000093e8  w    F .text	00000006 low_voltage_isr
1fff1998 g     O .data	00000408 __malloc_av_
000093e8  w    F .text	00000006 can0_error_isr
1fff21d4 g     O .bss	00000004 max_write
0000957c g     F .text	0000010c _init_Teensyduino_internal_
00000e16  w    F .text	0000000a SDFile::flush()
0000a8b8 g     F .text	00000254 .hidden __muldf3
00009310 g     F .text	0000005c usb_serial_flush_output
000093e8  w    F .text	00000006 dma_ch12_isr
0000baac g     F .text	00000002 __malloc_lock
00003f5c g     F .text	000000b0 ExFatFile::getName8(char*, unsigned int)
00000000  w      *UND*	00000000 __fini_array_start
000093e8  w    F .text	00000006 can1_wakeup_isr
1fff0a00 g     O .dmabuffers	000001d0 _VectorsRam
00005634 g     F .text	000000a8 FatFormatter::initFatDir(unsigned char, unsigned long)
00012450 g     F .text	0000005e _calloc_r
000093e8  w    F .text	00000006 pit3_isr
00002be4 g     F .text	00000078 SPIClass::begin()
1fff0f34 g     O .data	00000004 t_acq
1fff1344 g     O .data	00000001 yield_active_check_flags
000093e8  w    F .text	00000006 enet_rx_isr
00004f64 g     F .text	0000003e ExFatFile::sync()
00006592 g     F .text	00000196 FatFile::rename(FatFile*, char const*)
00008ea4 g     F .text	00000070 SdioCard::isBusy()
000093e8  w    F .text	00000006 portc_isr
00007d6a g     F .text	00000026 SdSpiCard::readStop()
000090bc g     F .text	00000000 memset
00001ad4 g     F .text	00000018 getCount()
0000a322 g     F .text	00000010 main
1fff21e4 g     O .bss	00000004 max_count
20018154 g     O .bss	00000008 rawData
2001a814 g     O .bss	00000004 __malloc_max_total_mem
00004862 g     F .text	000000a6 ExFatPartition::bitmapFind(unsigned long, unsigned long)
00001e08 g     F .text	00000006 checkReboot()
000053fc g     F .text	00000210 ExFatFile::write(void const*, unsigned int)
000093b4  w    F .text	00000034 memmanage_fault_isr
0000378c g     F .text	0000008e lbaToMbrChs(unsigned char*, unsigned long, unsigned long)
0000637a g     F .text	00000034 FatFile::dirEntry(DirFat_t*)
00000c32  w    F .text	0000000a SDFile::available()
00000f10  w    F .text	0000001c File::close()
0000a474 g     F .text	00000070 usb_init_serialnumber
00001728 g     F .text	00000036 setRTCTime(int, int, int, int, int, int)
0000d168 g     F .text	00000024 _strtol_r
0000aea8 g     F .text	0000009e .hidden __truncdfsf2
00013548 g       .text	00000000 __init_array_end
0000f998 g     F .text	00000e34 _dtoa_r
0000b338 g     F .text	00000570 _malloc_r
2001a810 g     O .bss	00000001 HardwareSerial::s_count_serials_with_serial_events
000093e8  w    F .text	00000006 debugmonitor_isr
0000f760 g     F .text	0000001a __ascii_wctomb
00000d00  w    F .text	0000000a SDFile::isOpen()
00007492 g     F .text	00000062 FsBaseFile::FsBaseFile(FsBaseFile const&)
0000a85c g     F .text	0000005a .hidden __aeabi_l2d
2001a698 g     O .bss	00000004 FatVolume::m_cwv
000019e4  w    F .text	00000008 Print::print(char const*)
00012378 g     F .text	00000078 __submore
0000a36c g     F .text	00000046 Stream::readBytesUntil(char, char*, unsigned int)
00002e30 g     F .text	000001cc SPIClass::transfer(void const*, void*, unsigned int)
620117ca g       *ABS*	00000000 __rtc_localtime
00009514 g     F .text	0000003c micros
00000000  w      *UND*	00000000 __libc_fini
000093e8  w    F .text	00000006 cmp1_isr
000093e8  w    F .text	00000006 ftm0_isr
00004e84 g     F .text	000000e0 ExFatFile::syncDir()
00002634 g     F .text	00000034 TwoWire::setClock(unsigned long)
000107f4 g     F .text	0000009c _malloc_trim_r
1fff13e0 g     O .data	00000004 string0
000091d0 g     F .text	000000e0 usb_serial_write
000093fc  w    F .text	00000002 startup_late_hook
00000bd4  w    F .text	00000054 FsBaseFile::available() const
0000a178  w    F .text	00000004 usb_serial_class::available()
1fff1358 g     O .data	00000001 _serialEvent_default
00006234 g     F .text	00000080 FatFile::sync()
00000538 g     F .text	0000015c acq_init(int)
00006dcc g     F .text	0000009c FatFile::cmpName(unsigned short, FatName_t*, unsigned char)
000031d4  w    F .text	0000004e SDClass::mkdir(char const*)
00004cf2  w    F .text	00000026 ExFatPartition::cacheSync()
1fff13ca  w    O .data	00000016 usb_string_product_name
00009550 g     F .text	0000002a delay
0000acec g     F .text	0000007a .hidden __nedf2
000093e8  w    F .text	00000006 tpm0_isr
2001a7e2 g     O .bss	00000002 dma_channel_allocated_mask
000040da g     F .text	00000020 ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)
00000d78  w    F .text	00000028 FsBaseFile::seekSet(unsigned long long)
00013548 g     F .fini	00000000 _fini
00000df8  w    F .text	00000014 FsBaseFile::sync()
000025d6 g     F .text	00000026 TwoWire::write(unsigned char)
000129a8 g     O .text	0000002e SPISettings::ctar_div_table
00007c5e g     F .text	00000030 SdSpiCard::readStart(unsigned long)
00004834 g     F .text	0000002e ExFatFile::openNext(ExFatFile*, int)
000078f4 g     F .text	00000076 SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)
0000beb8 g     F .text	0000004c sprintf
0000a1dc g     F .text	0000001a Print::printf(char const*, ...)
000093e8  w    F .text	00000006 i2s0_rx_isr
000093e8  w    F .text	00000006 uart4_error_isr
0000a26c g     F .text	00000010 Print::print(long)
000062b4 g     F .text	00000010 FatFile::close()
00000cec  w    F .text	00000014 SDFile::~SDFile()
0000f860 g     F .text	0000000c atexit
0000811c  w    F .text	00000002 SdioCard::~SdioCard()
00000d22  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::peek()
000009ec  w    F .text	0000001c File::write(unsigned char)
0000f77c g     F .text	0000002c _write_r
2001a1c8 g     O .bss	000004c8 SD
0000153c g     F .text	0000012c breakTime(unsigned long, tmElements_t&)
000083c4 g     F .text	000000d8 SdioCard::erase(unsigned long, unsigned long)
00006a58  w    F .text	00000020 FsCache::clear()
000093e8  w    F .text	00000006 can0_message_isr
00002c5c g     F .text	0000009c SPIClass::setMOSI(unsigned char)
00011bbc g     F .text	0000000c nanf
1fff1828 g     O .data	00000004 _impure_ptr
00012504  w    O .text	00000024 vtable for Stream
000093e8  w    F .text	00000006 can1_message_isr
00004320 g     F .text	0000002c ExFatFile::peek()
00012528  w    O .text	00000024 vtable for StreamFile<FsBaseFile, unsigned long long>
00011204 g     F .text	0000005c _mbrtowc_r
000093e8  w    F .text	00000006 nmi_isr
1fff1080 g     O .data	0000013c Wire
00001a50  w    F .text	00000060 SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)
00000f06  w    F .text	0000000a SDFile::write(void const*, unsigned int)
000076b4 g     F .text	00000028 FsVolume::open(char const*, int)
000080bc g     F .text	0000000c SdioCard::errorCode() const
0000636c g     F .text	0000000e FatFile::open(FatVolume*, char const*, int)
00000ee4  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)
1fff2230 g     O .bss	00000004 diskSize
00013530 g       .text	00000000 __preinit_array_end
0000188a g     F .text	00000076 dateTime(unsigned short*, unsigned short*, unsigned char*)
000076fc  w    F .text	00000002 SdSpiCard::~SdSpiCard()
000093e8  w    F .text	00000006 sdhc_isr
00004b8c g     F .text	000000cc ExFatPartition::init(BlockDeviceInterface*, unsigned char)
000049ae g     F .text	00000036 ExFatPartition::dirCache(DirPos_t*, unsigned char)
00007ddc g     F .text	00000092 SdSpiCard::erase(unsigned long, unsigned long)
0000b8a8 g     F .text	0000002a __ascii_mbtowc
000077f8 g     F .text	00000032 SdSpiCard::isBusy()
00011860 g     F .text	00000054 __ulp
00012dc8 g     O .text	00000060 vtable for SdSpiCard
00007c56  w    F .text	00000008 SdSpiCard::readCID(CID*)
000025be  w    F .text	00000016 TwoWire::peek()
000025d4  w    F .text	00000002 TwoWire::flush()
0000079c g     F .text	00000090 setup
000130b8 g     O .text	00000054 usb_descriptor_list
00009748 g     F .text	00000038 usb_rx
00008238 g     F .text	00000004 SdioCard::status()
000093e8  w    F .text	00000006 dma_ch10_isr
00001900  w    F .text	00000014 MySpiClass::send(unsigned char const*, unsigned int)
000063ce g     F .text	00000020 FatFile::getModifyDateTime(unsigned short*, unsigned short*)
00000990  w    F .text	00000002 Print::flush()
00000c8e  w    F .text	00000012 FsBaseFile::isOpen() const
0000ae68 g     F .text	00000040 .hidden __aeabi_d2uiz
000093e8  w    F .text	00000006 uart0_error_isr
00000c3c  w    F .text	00000020 FsBaseFile::isDir() const
0000312a  w    F .text	00000054 SDClass::rmdir(char const*)
00012834  w    O .text	00000028 vtable for MySpiClass
00009688 g     F .text	0000003c usb_malloc
00005e04 g     F .text	00000178 FatFile::read(void*, unsigned int)
000093e8  w    F .text	00000006 i2s0_isr
00005da6 g     F .text	00000030 FatFile::openRoot(FatVolume*)
2001a694 g     O .bss	00000004 ExFatVolume::m_cwv
00001a38  w    F .text	00000018 FsVolume::freeClusterCount() const
20030000 g       .bss	00000000 _estack
000076dc g     F .text	00000004 operator new(unsigned int, unsigned long*)
00007c4e  w    F .text	00000008 SdSpiCard::readCSD(csd_t*)
0000a0d4 g     F .text	00000034 DMAChannel::release()
000009c6  w    F .text	00000026 File::read()
000092c8 g     F .text	00000048 usb_serial_write_buffer_free
0000796a g     F .text	00000028 SdSpiCard::waitNotBusy(unsigned short)
000077d2 g     F .text	00000026 SdSpiCard::spiStop()
000093e8  w    F .text	00000006 enet_timer_isr
000070f8 g     F .text	00000250 FatFile::open(FatFile*, FatName_t*, int)
0000ad88 g     F .text	00000012 .hidden __aeabi_dcmpeq
00001668 g     F .text	000000c0 makeTime(tmElements_t const&)
000025fc g     F .text	00000038 TwoWire::write(unsigned char const*, unsigned int)
00000b90  w    F .text	00000014 File::~File()
000014dc g     F .text	0000003c _write
1fff1da8 g       .data	00000000 _edata
00004a90 g     F .text	0000003a ExFatPartition::fatPut(unsigned long, unsigned long)
0000811c  w    F .text	00000002 SdioCard::~SdioCard()
000093e8  w    F .text	00000006 i2s0_tx_isr
000093e8  w    F .text	00000006 adc1_isr
00003958 g     F .text	00000048 FsName::get16()
00007d90 g     F .text	0000001c SdSpiCard::syncDevice()
0000400c g     F .text	00000062 ExFatFile::hashName(ExName_t*)
00005cfc g     F .text	0000008c FatFile::addDirCluster()
000063ee g     F .text	000000fa FatFile::mkdir(FatFile*, FatName_t*)
0000a180  w    F .text	00000004 usb_serial_class::availableForWrite()
000093e8  w    F .text	00000006 cmp0_isr
000019c4  w    F .text	00000020 MySpiClass::receive()
00006a2e g     F .text	0000002a FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)
0000a4e4 g     F .text	00000040 ultoa
000030e4  w    F .text	00000002 SDClass::~SDClass()
00007a2c g     F .text	000001b4 SdSpiCard::begin(SdSpiConfig)
00002668 g     F .text	0000008c TwoWire::begin()
0000751c g     F .text	0000007e FsBaseFile::open(FsVolume*, char const*, int)
0000a108  w    F .text	0000000e MillisTimer::disableTimerInterrupt()
0000a3b4 g     F .text	00000004 operator new(unsigned int)
0000a11c g     F .text	0000003c EventResponder::runFromInterrupt()
000011e8 g     F .text	00000084 printMenuEntries()
1fff1da0 g     O .data	00000004 __malloc_trim_threshold
0000a170  w    F .text	00000004 usb_serial_class::peek()
0001174c g     F .text	00000114 __mdiff
0000810c g     F .text	00000010 SdioCard::readOCR(unsigned long*)
0000ae18 g     F .text	0000004e .hidden __aeabi_d2iz
00004a4c g     F .text	00000044 ExFatPartition::dirSeek(DirPos_t*, unsigned long)
2001a6e8 g     O .bss	00000001 usb_cdc_transmit_flush_timer
00005bac g     F .text	000000f0 FatFile::getName8(char*, unsigned int)
0000441c g     F .text	00000350 ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)
000093e8  w    F .text	00000006 pit_isr
000084f8 g     F .text	00000088 SdioCard::writeStop()
00007f56  w    F .text	0000001c SdSpiCard::writeSector(unsigned long, unsigned char const*)
00011b48 g     F .text	00000072 __sccl
000040a6 g     F .text	00000014 ExFatFile::close()
00013210 g     O .text	00000101 _ctype_
000093e8  w    F .text	00000006 dac0_isr
000076e8  w    F .text	00000010 SdSpiCard::readSector(unsigned long, unsigned char*)
00002340 g     F .text	00000240 adc_enable(unsigned int, unsigned long)
00013530 g       .text	00000000 __init_array_start
0000b25c  w    F .text	00000002 .hidden __aeabi_idiv0
000093e8  w    F .text	00000006 can1_tx_warn_isr
0000adec g     F .text	0000002c .hidden __unorddf2
200191bc g     O .bss	00000004 disk_count
000039c8 g     F .text	00000042 ExFatFormatter::writeUpcaseByte(unsigned char)
000035dc g     F .text	000001b0 FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)
00003222  w    F .text	00000068 SDClass::rename(char const*, char const*)
000093e8  w    F .text	00000006 uart0_status_isr
00006d68 g     F .text	00000046 FatVolume::chdir(char const*)
000004c8 g     F .text	00000018 acq_start()
000093e8  w    F .text	00000006 mcg_isr
0000a334 g     F .text	00000038 Stream::timedRead()
00000400 g     O .text	00000010 flashconfigbytes
0000a02c g     F .text	000000a8 DMAChannel::begin(bool)
0000bf80 g     F .text	000000dc strlen
00005dd6 g     F .text	0000002e FatFile::openCluster(FatFile*)
0000b2fc g     F .text	00000006 __locale_ctype_ptr_l
000032e6  w    F .text	00000036 SdBase<FsVolume>::begin(SdioConfig)
0000ad78 g     F .text	00000010 .hidden __aeabi_cdcmpeq
0000acdc g     F .text	0000008a .hidden __gedf2
00005fde g     F .text	000000ac FatFile::seekSet(unsigned long)
00007348 g     F .text	00000098 FatFile::parsePathName(char const*, FatName_t*, char const**)
00010b08 g     F .text	00000510 __gethex
1fff13ca g     O .data	00000016 usb_string_product_name_default
0000f748 g     F .text	00000018 vdprintf
000093e8  w    F .text	00000006 dma_ch1_isr
00008360 g     F .text	00000064 SdioCard::sectorCount()
000075f8 g     F .text	000000bc FsVolume::begin(BlockDeviceInterface*)
00001914  w    F .text	00000024 MySpiClass::receive(unsigned char*, unsigned int)
00009780 g     F .text	00000024 usb_tx_packet_count
0000614c g     F .text	00000098 FatFile::openNext(FatFile*, int)
1fff2228 g     O .bss	00000004 diskSpace
000004f4 g     F .text	00000044 mckl_init(int, int, int)
0000946c  w    F .text	00000002 startup_middle_hook
00012e28 g     O .text	00000060 vtable for SdioCard
0000a810 g     F .text	0000003a .hidden __aeabi_f2d
000093e8  w    F .text	00000006 dma_ch5_isr
00005c9c g     F .text	00000004 FatFile::getName(char*, unsigned int)
000093e8  w    F .text	00000006 can0_rx_warn_isr
00001ab0  w    F .text	0000000c SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)
000093e8  w    F .text	00000006 can0_tx_warn_isr
000093e8  w    F .text	00000006 uart4_status_isr
00008cf0 g     F .text	00000074 SdioCard::readStart(unsigned long)
00000000  w      *UND*	00000000 _Jv_RegisterClasses
00005ae0  w    F .text	0000001a FatFile::cacheDir(unsigned short)
0000a550 g     F .text	0000027a .hidden __subdf3
00001b20 g     F .text	00000044 pullData(unsigned long*, unsigned long)
00013530 g       .text	00000000 __preinit_array_start
00004908 g     F .text	000000a6 ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)
00000ed0  w    F .text	00000014 FsBaseFile::write(void const*, unsigned int)
1fff2234 g     O .bss	00025800 data_buffer
00011418 g     F .text	0000005a __lo0bits
00004a22 g     F .text	0000002a ExFatPartition::chainSize(unsigned long)
0000608a g     F .text	000000c2 FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)
00006728 g     F .text	000000ae FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
1fff0f38 g     O .data	00000004 stdPrint
0000175e  w    F .text	00000038 BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)
0000a524 g     F .text	0000000a __aeabi_atexit
00000000  w      *UND*	00000000 __register_frame_info
00009440 g     F .text	0000000c rtc_get
00004daa g     F .text	00000086 ExFatFile::remove()
000093e8  w    F .text	00000006 cmp2_isr
0000a158 g     F .text	00000004 pendablesrvreq_isr
0000328a  w    F .text	00000026 SDClass::totalSize()
0000098c  w    F .text	00000004 Print::availableForWrite()
1fff182c g     O .data	0000016c __global_locale
000093e8  w    F .text	00000006 wakeup_isr
00002cf8 g     F .text	00000094 SPIClass::setMISO(unsigned char)
000088d0 g     F .text	0000035c SdioCard::begin(SdioConfig)
000040ba g     F .text	00000020 ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)
000093e8  w    F .text	00000006 cmp3_isr
0000a1f6 g     F .text	00000076 Print::printNumber(unsigned long, unsigned char, unsigned char)
00006a78 g     F .text	0000006a FatPartition::fatGet(unsigned long, unsigned long*)
0000b328 g     F .text	00000010 free
000093e8  w    F .text	00000006 tpm2_isr
00003f10 g     F .text	0000004c ExFatFile::cmpName(DirName_t const*, ExName_t*)
000112c0 g     F .text	00000080 __multadd
000112ac g     F .text	00000012 _Bfree
00000bbc  w    F .text	00000018 SDFile::size()
00005b22 g     F .text	00000088 FatFile::getSFN(char*, unsigned int)
000093e8  w    F .text	00000006 dma_ch0_isr
00000cc8  w    F .text	00000024 SDFile::~SDFile()
1fff13e4  w    O .data	00000016 usb_string_serial_number
000093e8  w    F .text	00000006 enet_tx_isr
00008d64 g     F .text	000000c4 SdioCard::readSector(unsigned long, unsigned char*)
000080f0 g     F .text	0000001c SdioCard::readCSD(csd_t*)



Disassembly of section .text:

00000000 <_VectorsFlash>:
  return fsFmtTime(str, time);
}
//------------------------------------------------------------------------------
char* fsFmtTimeZone(char* str, int8_t tz) {
  char sign;
  if (tz & 0X80) {
       0:	... ............
    if (tz & 0X40) {
      sign = '-';
      10:	................
    } else {
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      str = fsFmtField(str, 15*(tz%4), 0);
      20:	................
      30:	........Y...]...
      str = fsFmtField(str, tz/4, ':');
      40:	................
      *--str = sign;
      50:	................
    }
    *--str = 'C';
    *--str = 'T';
    *--str = 'U';
      60:	................
      70:	................
      80:	................
      90:	................
      a0:	.+...+..........
      b0:	................
      c0:	................
      d0:	................
      e0:	................
      f0:	................
     100:	................
     110:	................
     120:	................
     130:	................
     140:	................
     150:	................
     160:	.........+......
     170:	................
     180:	................
     190:	................
     1a0:	................
     1b0:	................
     1c0:	................

000001d0 <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d0:	ldr	r3, [pc, #356]	; (338 <ResetHandler+0x168>)
     1d2:	movw	r2, #50464	; 0xc520
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
     1d6:	push	{r4, lr}
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d8:	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
     1da:	movw	r2, #55592	; 0xd928
     1de:	strh	r2, [r3, #0]
	__asm__ volatile ("nop");
     1e0:	nop
	__asm__ volatile ("nop");
     1e2:	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
     1e4:	bl	93f0 <startup_early_hook>
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1e8:	ldr	r3, [pc, #336]	; (33c <ResetHandler+0x16c>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     1ea:	ldr	r1, [pc, #340]	; (340 <ResetHandler+0x170>)
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1ec:	mov.w	r2, #184549376	; 0xb000000
     1f0:	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
     1f2:	ldr	r2, [pc, #336]	; (344 <ResetHandler+0x174>)
     1f4:	str	r2, [r3, #8]
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
     1f6:	ldr	r2, [pc, #336]	; (348 <ResetHandler+0x178>)
     1f8:	str	r2, [r3, #12]
	SIM_SCGC4 = SIM_SCGC4_USBOTG | 0xF0000030;
	SIM_SCGC5 = 0x00003F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_ADC0 | SIM_SCGC6_TPM0 | SIM_SCGC6_TPM1 | SIM_SCGC6_TPM2 | SIM_SCGC6_FTFL;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SCB_CPACR = 0x00F00000;
     1fa:	ldr	r3, [pc, #336]	; (34c <ResetHandler+0x17c>)
     1fc:	mov.w	r2, #15728640	; 0xf00000
     200:	str	r2, [r3, #0]
#endif
#if defined(__MK66FX1M0__)
	LMEM_PCCCR = 0x85000003;
     202:	ldr	r3, [pc, #332]	; (350 <ResetHandler+0x180>)
     204:	ldr	r2, [pc, #332]	; (354 <ResetHandler+0x184>)
     206:	str	r2, [r3, #0]
		RTC_SR = 0;
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     208:	ldr	r3, [pc, #332]	; (358 <ResetHandler+0x188>)
     20a:	ldrb	r2, [r3, #0]
     20c:	lsls	r0, r2, #28
     20e:	ittt	mi
     210:	ldrbmi	r2, [r3, #0]
     212:	orrmi.w	r2, r2, #8
     216:	strbmi	r2, [r3, #0]

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     218:	ldr	r3, [pc, #320]	; (35c <ResetHandler+0x18c>)
     21a:	movs	r2, #170	; 0xaa
     21c:	strb	r2, [r3, #0]
     21e:	ldr	r2, [pc, #320]	; (360 <ResetHandler+0x190>)
     220:	ldr	r3, [pc, #320]	; (364 <ResetHandler+0x194>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     222:	cmp	r3, r1
     224:	bcs.n	230 <ResetHandler+0x60>
     226:	ldr.w	r0, [r2, #4]!
     22a:	str.w	r0, [r3], #4
     22e:	b.n	222 <ResetHandler+0x52>
     230:	ldr	r3, [pc, #308]	; (368 <ResetHandler+0x198>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     232:	ldr	r2, [pc, #312]	; (36c <ResetHandler+0x19c>)
     234:	movs	r1, #0
     236:	cmp	r3, r2
     238:	bcs.n	240 <ResetHandler+0x70>
     23a:	str.w	r1, [r3], #4
     23e:	b.n	236 <ResetHandler+0x66>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     240:	ldr	r2, [pc, #300]	; (370 <ResetHandler+0x1a0>)
     242:	ldr	r0, [pc, #304]	; (374 <ResetHandler+0x1a4>)
     244:	movs	r3, #0
     246:	ldr.w	r1, [r0, r3, lsl #2]
     24a:	str.w	r1, [r2, r3, lsl #2]
     24e:	adds	r3, #1
     250:	cmp	r3, #116	; 0x74
     252:	bne.n	246 <ResetHandler+0x76>
     254:	ldr	r3, [pc, #288]	; (378 <ResetHandler+0x1a8>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     256:	ldr	r2, [pc, #292]	; (37c <ResetHandler+0x1ac>)
     258:	movs	r1, #128	; 0x80
     25a:	strb.w	r1, [r3], #1
     25e:	cmp	r3, r2
     260:	bne.n	25a <ResetHandler+0x8a>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     262:	ldr	r3, [pc, #284]	; (380 <ResetHandler+0x1b0>)
     264:	ldr	r2, [pc, #264]	; (370 <ResetHandler+0x1a0>)
     266:	str	r2, [r3, #0]
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     268:	ldr	r3, [pc, #280]	; (384 <ResetHandler+0x1b4>)
     26a:	movs	r2, #138	; 0x8a
     26c:	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     26e:	sub.w	r3, r3, #4096	; 0x1000
     272:	movs	r2, #36	; 0x24
     274:	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     276:	movs	r2, #160	; 0xa0
     278:	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     27a:	ldrb	r2, [r3, #6]
     27c:	lsls	r1, r2, #30
     27e:	bpl.n	27a <ResetHandler+0xaa>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     280:	ldrb	r2, [r3, #6]
     282:	lsls	r2, r2, #27
     284:	bmi.n	280 <ResetHandler+0xb0>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     286:	ldr	r2, [pc, #256]	; (388 <ResetHandler+0x1b8>)
     288:	ldrb	r3, [r2, #6]
     28a:	and.w	r3, r3, #12
     28e:	cmp	r3, #8
     290:	ldr	r3, [pc, #244]	; (388 <ResetHandler+0x1b8>)
     292:	bne.n	288 <ResetHandler+0xb8>
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(2);
    #elif F_CPU == 120000000
	MCG_C5 = MCG_C5_PRDIV0(1);
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(14);
    #elif F_CPU == 96000000 || F_CPU == 48000000 || F_CPU == 24000000
	MCG_C5 = MCG_C5_PRDIV0(1);
     294:	movs	r2, #1
     296:	strb	r2, [r3, #4]
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(8);
     298:	movs	r2, #72	; 0x48
     29a:	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     29c:	ldrb	r2, [r3, #6]
     29e:	lsls	r4, r2, #26
     2a0:	bpl.n	29c <ResetHandler+0xcc>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     2a2:	ldr	r1, [pc, #228]	; (388 <ResetHandler+0x1b8>)
     2a4:	ldrb	r2, [r1, #6]
     2a6:	ldr	r3, [pc, #224]	; (388 <ResetHandler+0x1b8>)
     2a8:	lsls	r0, r2, #25
     2aa:	bpl.n	2a4 <ResetHandler+0xd4>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC;
#elif F_CPU == 96000000
	// config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash, USB = 96 / 2
	#if F_BUS == 48000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(3);
     2ac:	ldr	r2, [pc, #220]	; (38c <ResetHandler+0x1bc>)
     2ae:	ldr	r1, [pc, #224]	; (390 <ResetHandler+0x1c0>)
     2b0:	str	r1, [r2, #0]
	#elif F_BUS == 96000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(0) | SIM_CLKDIV1_OUTDIV4(3);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1);
     2b2:	movs	r1, #2
     2b4:	str	r1, [r2, #4]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     2b6:	movs	r2, #32
     2b8:	strb	r2, [r3, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     2ba:	ldrb	r2, [r3, #6]
     2bc:	and.w	r2, r2, #12
     2c0:	cmp	r2, #12
     2c2:	bne.n	2ba <ResetHandler+0xea>
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#else
	// USB uses PLL clock
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     2c4:	ldr	r3, [pc, #204]	; (394 <ResetHandler+0x1c4>)
     2c6:	ldr	r2, [pc, #208]	; (398 <ResetHandler+0x1c8>)
     2c8:	str	r2, [r3, #0]
#endif

#if defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started.  For Teensy 3.6
	// we don't do this early.  See comment above about slow rising power.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     2ca:	ldr	r2, [pc, #208]	; (39c <ResetHandler+0x1cc>)
     2cc:	ldr	r4, [pc, #208]	; (3a0 <ResetHandler+0x1d0>)
     2ce:	ldr	r3, [r2, #0]
     2d0:	ands.w	r3, r3, #256	; 0x100
		RTC_SR = 0;
     2d4:	ittt	eq
     2d6:	streq	r3, [r4, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     2d8:	moveq.w	r3, #5376	; 0x1500
     2dc:	streq	r3, [r2, #0]
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2de:	ldr	r3, [pc, #196]	; (3a4 <ResetHandler+0x1d4>)
     2e0:	ldr	r2, [pc, #196]	; (3a8 <ResetHandler+0x1d8>)
     2e2:	str	r2, [r3, #0]
	SYST_CVR = 0;
     2e4:	movs	r2, #0
     2e6:	str	r2, [r3, #4]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2e8:	movs	r2, #7
     2ea:	str.w	r2, [r3, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2ee:	ldr	r2, [pc, #188]	; (3ac <ResetHandler+0x1dc>)
     2f0:	str.w	r2, [r3, #3340]	; 0xd0c

	//init_pins();
	__enable_irq();
     2f4:	cpsie	i

	_init_Teensyduino_internal_();
     2f6:	bl	957c <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     2fa:	ldr	r3, [r4, #0]
     2fc:	lsls	r2, r3, #31
     2fe:	bpl.n	30c <ResetHandler+0x13c>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     300:	ldr	r0, [pc, #172]	; (3b0 <ResetHandler+0x1e0>)
     302:	bl	944c <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     306:	ldr	r3, [pc, #172]	; (3b4 <ResetHandler+0x1e4>)
     308:	ldr	r2, [pc, #172]	; (3b8 <ResetHandler+0x1e8>)
     30a:	str	r2, [r3, #0]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     30c:	ldr	r3, [pc, #172]	; (3bc <ResetHandler+0x1ec>)
     30e:	ldrb	r3, [r3, #0]
     310:	lsls	r3, r3, #25
     312:	bpl.n	328 <ResetHandler+0x158>
     314:	ldr	r4, [pc, #156]	; (3b4 <ResetHandler+0x1e4>)
     316:	ldr	r3, [pc, #160]	; (3b8 <ResetHandler+0x1e8>)
     318:	ldr	r2, [r4, #0]
     31a:	cmp	r2, r3
     31c:	bne.n	328 <ResetHandler+0x158>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     31e:	ldr	r0, [pc, #144]	; (3b0 <ResetHandler+0x1e0>)
     320:	bl	944c <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     324:	movs	r3, #0
     326:	str	r3, [r4, #0]
	}
#endif

	startup_late_hook();
     328:	bl	93fc <startup_late_hook>
	__libc_init_array();
     32c:	bl	b278 <__libc_init_array>

	main();
     330:	bl	a322 <main>
     334:	b.n	334 <ResetHandler+0x164>
     336:	nop
     338:	.word	0x4005200e
     33c:	.word	0x40048030
     340:	.word	0x1fff1da8
     344:	.word	0x00043f82
     348:	.word	0x2b000001
     34c:	.word	0xe000ed88
     350:	.word	0xe0082000
     354:	.word	0x85000003
     358:	.word	0x4007d002
     35c:	.word	0x4007e000
     360:	.word	0x00013550
     364:	.word	0x1fff0f30
     368:	.word	0x1fff1da8
     36c:	.word	0x2001a860
     370:	.word	0x1fff0a00
     374:	.word	0x00000000
     378:	.word	0xe000e400
     37c:	.word	0xe000e464
     380:	.word	0xe000ed08
     384:	.word	0x40065000
     388:	.word	0x40064000
     38c:	.word	0x40048044
     390:	.word	0x01030000
     394:	.word	0x40048004
     398:	.word	0x000510c0
     39c:	.word	0x4003d010
     3a0:	.word	0x4003d014
     3a4:	.word	0xe000e014
     3a8:	.word	0x000176ff
     3ac:	.word	0x20200000
     3b0:	.word	0x620117ca
     3b4:	.word	0x4003e01c
     3b8:	.word	0x5a94c3a5
     3bc:	.word	0x4007f000
     3c0:	.word	0xffffffff
     3c4:	.word	0xffffffff
     3c8:	.word	0xffffffff
     3cc:	.word	0xffffffff
     3d0:	.word	0xffffffff
     3d4:	.word	0xffffffff
     3d8:	.word	0xffffffff
     3dc:	.word	0xffffffff
     3e0:	.word	0xffffffff
     3e4:	.word	0xffffffff
     3e8:	.word	0xffffffff
     3ec:	.word	0xffffffff
     3f0:	.word	0xffffffff
     3f4:	.word	0xffffffff
     3f8:	.word	0xffffffff
     3fc:	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	................

00000410 <__do_global_dtors_aux>:
     410:	push	{r4, lr}
     412:	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
     414:	ldrb	r3, [r4, #0]
     416:	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
     41a:	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
     41e:	nop.w
     422:	movs	r3, #1
     424:	strb	r3, [r4, #0]
     426:	pop	{r4, pc}
     428:	.word	0x1fff1da8
     42c:	.word	0x00000000
     430:	.word	0x0001354c

00000434 <frame_dummy>:
     434:	ldr	r3, [pc, #32]	; (458 <frame_dummy+0x24>)
     436:	push	{r4, lr}
     438:	cbz	r3, 442 <frame_dummy+0xe>
     43a:	ldr	r1, [pc, #32]	; (45c <frame_dummy+0x28>)
     43c:	ldr	r0, [pc, #32]	; (460 <frame_dummy+0x2c>)
     43e:	nop.w
     442:	ldr	r0, [pc, #32]	; (464 <frame_dummy+0x30>)
     444:	ldr	r3, [r0, #0]
     446:	cbnz	r3, 44a <frame_dummy+0x16>
     448:	pop	{r4, pc}
     44a:	ldr	r3, [pc, #28]	; (468 <frame_dummy+0x34>)
     44c:	cmp	r3, #0
     44e:	beq.n	448 <frame_dummy+0x14>
     450:	ldmia.w	sp!, {r4, lr}
     454:	bx	r3
     456:	nop
     458:	.word	0x00000000
     45c:	.word	0x1fff1dac
     460:	.word	0x0001354c
     464:	.word	0x1fff1da8
     468:	.word	0x00000000

0000046c <DMAChannel::~DMAChannel()>:
	}
	DMAChannel & operator = (const DMASetting &rhs) {
		copy_tcd(TCD, rhs.TCD);
		return *this;
	}
	~DMAChannel() {
     46c:	push	{r4, lr}
     46e:	mov	r4, r0
		release();
     470:	bl	a0d4 <DMAChannel::release()>
	}
     474:	mov	r0, r4
     476:	pop	{r4, pc}

00000478 <acq_stopClocks()>:

    const int32_t fsamp0=(((F_PLL*MCLK_MULT)/MCLK_DIV)/512);
    
    void acq_stopClocks(void)
    {
        SIM_SCGC6 &= ~SIM_SCGC6_DMAMUX;
     478:	ldr	r3, [pc, #28]	; (498 <acq_stopClocks()+0x20>)
        SIM_SCGC7 &= ~SIM_SCGC7_DMA;
     47a:	ldr	r1, [pc, #32]	; (49c <acq_stopClocks()+0x24>)

    const int32_t fsamp0=(((F_PLL*MCLK_MULT)/MCLK_DIV)/512);
    
    void acq_stopClocks(void)
    {
        SIM_SCGC6 &= ~SIM_SCGC6_DMAMUX;
     47c:	ldr	r2, [r3, #0]
     47e:	bic.w	r2, r2, #2
     482:	str	r2, [r3, #0]
        SIM_SCGC7 &= ~SIM_SCGC7_DMA;
     484:	ldr	r2, [r1, #0]
     486:	bic.w	r2, r2, #2
     48a:	str	r2, [r1, #0]
        SIM_SCGC6 &= ~SIM_SCGC6_I2S;
     48c:	ldr	r2, [r3, #0]
     48e:	bic.w	r2, r2, #32768	; 0x8000
     492:	str	r2, [r3, #0]
     494:	bx	lr
     496:	nop
     498:	.word	0x4004803c
     49c:	.word	0x40048040

000004a0 <acq_startClocks()>:
    }

    void acq_startClocks(void)
    {
    SIM_SCGC6 |= SIM_SCGC6_I2S;
     4a0:	ldr	r3, [pc, #28]	; (4c0 <acq_startClocks()+0x20>)
    SIM_SCGC7 |= SIM_SCGC7_DMA;
     4a2:	ldr	r1, [pc, #32]	; (4c4 <acq_startClocks()+0x24>)
        SIM_SCGC6 &= ~SIM_SCGC6_I2S;
    }

    void acq_startClocks(void)
    {
    SIM_SCGC6 |= SIM_SCGC6_I2S;
     4a4:	ldr	r2, [r3, #0]
     4a6:	orr.w	r2, r2, #32768	; 0x8000
     4aa:	str	r2, [r3, #0]
    SIM_SCGC7 |= SIM_SCGC7_DMA;
     4ac:	ldr	r2, [r1, #0]
     4ae:	orr.w	r2, r2, #2
     4b2:	str	r2, [r1, #0]
    SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
     4b4:	ldr	r2, [r3, #0]
     4b6:	orr.w	r2, r2, #2
     4ba:	str	r2, [r3, #0]
     4bc:	bx	lr
     4be:	nop
     4c0:	.word	0x4004803c
     4c4:	.word	0x40048040

000004c8 <acq_start()>:
    }

    void acq_start(void)
    {
     4c8:	push	{r3, lr}
        acq_startClocks();
     4ca:	bl	4a0 <acq_startClocks()>
        I2S0_RCSR |= (I2S_RCSR_RE | I2S_RCSR_BCE);
     4ce:	ldr	r2, [pc, #12]	; (4dc <acq_start()+0x14>)
     4d0:	ldr	r3, [r2, #0]
     4d2:	orr.w	r3, r3, #2415919104	; 0x90000000
     4d6:	str	r3, [r2, #0]
     4d8:	pop	{r3, pc}
     4da:	nop
     4dc:	.word	0x4002f080

000004e0 <acq_stop()>:
    }

    void acq_stop(void)
    {
        I2S0_RCSR &= ~(I2S_RCSR_RE | I2S_RCSR_BCE);
     4e0:	ldr	r2, [pc, #12]	; (4f0 <acq_stop()+0x10>)
     4e2:	ldr	r3, [r2, #0]
     4e4:	bic.w	r3, r3, #2415919104	; 0x90000000
     4e8:	str	r3, [r2, #0]
        acq_stopClocks();
     4ea:	b.w	478 <acq_stopClocks()>
     4ee:	nop
     4f0:	.word	0x4002f080

000004f4 <mckl_init(int, int, int)>:
    }

    void mckl_init(int src, int mult, int div)
    {
     4f4:	push	{r4, lr}
        SIM_SCGC6 |= SIM_SCGC6_I2S;
     4f6:	ldr	r4, [pc, #52]	; (52c <mckl_init(int, int, int)+0x38>)
     4f8:	ldr	r3, [r4, #0]
        // enable MCLK output
        I2S0_MDR = I2S_MDR_FRACT((mult-1)) | I2S_MDR_DIVIDE((div-1));
     4fa:	subs	r1, #1
        acq_stopClocks();
    }

    void mckl_init(int src, int mult, int div)
    {
        SIM_SCGC6 |= SIM_SCGC6_I2S;
     4fc:	orr.w	r3, r3, #32768	; 0x8000
        // enable MCLK output
        I2S0_MDR = I2S_MDR_FRACT((mult-1)) | I2S_MDR_DIVIDE((div-1));
     500:	lsls	r1, r1, #12
     502:	subs	r2, #1
        acq_stopClocks();
    }

    void mckl_init(int src, int mult, int div)
    {
        SIM_SCGC6 |= SIM_SCGC6_I2S;
     504:	str	r3, [r4, #0]
        // enable MCLK output
        I2S0_MDR = I2S_MDR_FRACT((mult-1)) | I2S_MDR_DIVIDE((div-1));
     506:	and.w	r1, r1, #1044480	; 0xff000
     50a:	ubfx	r2, r2, #0, #12
     50e:	ldr	r3, [pc, #32]	; (530 <mckl_init(int, int, int)+0x3c>)
     510:	orrs	r2, r1
     512:	str	r2, [r3, #0]
        while(I2S0_MCR & I2S_MCR_DUF);
     514:	ldr	r2, [pc, #28]	; (534 <mckl_init(int, int, int)+0x40>)
     516:	ldr	r3, [r2, #0]
     518:	cmp	r3, #0
     51a:	blt.n	516 <mckl_init(int, int, int)+0x22>
        I2S0_MCR = I2S_MCR_MICS(src) | I2S_MCR_MOE;
     51c:	lsls	r0, r0, #24
     51e:	and.w	r0, r0, #50331648	; 0x3000000
     522:	ldr	r3, [pc, #16]	; (534 <mckl_init(int, int, int)+0x40>)
     524:	orr.w	r0, r0, #1073741824	; 0x40000000
     528:	str	r0, [r3, #0]
     52a:	pop	{r4, pc}
     52c:	.word	0x4004803c
     530:	.word	0x4002f104
     534:	.word	0x4002f100

00000538 <acq_init(int)>:

    }

    void acq_init(int fsamp)
    {
     538:	push	{r3, r4, r5, r6, r7, lr}
        Serial.printf("%d %d\n",fsamp,fsamp0);
     53a:	mov	r2, r0
     53c:	ldr	r3, [pc, #244]	; (634 <acq_init(int)+0xfc>)
     53e:	ldr	r1, [pc, #248]	; (638 <acq_init(int)+0x100>)
     540:	ldr	r0, [pc, #248]	; (63c <acq_init(int)+0x104>)
            CORE_PIN35_CONFIG = PORT_PCR_MUX(4) | PORT_PCR_SRE | PORT_PCR_DSE;  //pin35, PTC8,   I2S0_MCLK (SLEW rate (SRE)?)
            CORE_PIN36_CONFIG = PORT_PCR_MUX(4);  //pin36, PTC9,   I2S0_RX_BCLK
            CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
            CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
        #endif
        I2S0_RCSR=0;
     542:	ldr	r5, [pc, #252]	; (640 <acq_init(int)+0x108>)
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV(BCLK_DIV);
	I2S0_TCR3 = I2S_TCR3_TCE;
	I2S0_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(31) | I2S_TCR4_MF
		| I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD;
	I2S0_TCR5 = I2S_TCR5_WNW(31) | I2S_TCR5_W0W(31) | I2S_TCR5_FBT(31);
     544:	ldr	r6, [pc, #252]	; (644 <acq_init(int)+0x10c>)

	// configure receiver (sync'd to transmitter clocks)
	I2S0_RMR = 0;
	I2S0_RCR1 = I2S_RCR1_RFW(1);
	I2S0_RCR2 = I2S_RCR2_SYNC(1) | I2S_TCR2_BCP | I2S_RCR2_MSEL(1)
		| I2S_RCR2_BCD | I2S_RCR2_DIV(BCLK_DIV);
     546:	ldr	r7, [pc, #256]	; (648 <acq_init(int)+0x110>)

    }

    void acq_init(int fsamp)
    {
        Serial.printf("%d %d\n",fsamp,fsamp0);
     548:	bl	a1dc <Print::printf(char const*, ...)>

        acq_startClocks();
     54c:	bl	4a0 <acq_startClocks()>

        #if I2S_CONFIG==0
            CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
     550:	ldr	r2, [pc, #248]	; (64c <acq_init(int)+0x114>)
     552:	mov.w	r3, #1536	; 0x600
     556:	str	r3, [r2, #0]
        	CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK
     558:	str.w	r3, [r2, #-12]
            CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
     55c:	str.w	r3, [r2, #-16]
            CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  //pin 13, PTC5,  I2S0_RXD0
     560:	ldr	r3, [pc, #236]	; (650 <acq_init(int)+0x118>)
            CORE_PIN35_CONFIG = PORT_PCR_MUX(4) | PORT_PCR_SRE | PORT_PCR_DSE;  //pin35, PTC8,   I2S0_MCLK (SLEW rate (SRE)?)
            CORE_PIN36_CONFIG = PORT_PCR_MUX(4);  //pin36, PTC9,   I2S0_RX_BCLK
            CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
            CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
        #endif
        I2S0_RCSR=0;
     562:	movs	r4, #0

        #if I2S_CONFIG==0
            CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
        	CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK
            CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
            CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  //pin 13, PTC5,  I2S0_RXD0
     564:	mov.w	r2, #1024	; 0x400
     568:	str	r2, [r3, #0]
            CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
            CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
        #endif
        I2S0_RCSR=0;

        mckl_init(MCLK_SRC, MCLK_MULT, MCLK_DIV);
     56a:	movs	r1, #1
            CORE_PIN35_CONFIG = PORT_PCR_MUX(4) | PORT_PCR_SRE | PORT_PCR_DSE;  //pin35, PTC8,   I2S0_MCLK (SLEW rate (SRE)?)
            CORE_PIN36_CONFIG = PORT_PCR_MUX(4);  //pin36, PTC9,   I2S0_RX_BCLK
            CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
            CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
        #endif
        I2S0_RCSR=0;
     56c:	str	r4, [r5, #0]

        mckl_init(MCLK_SRC, MCLK_MULT, MCLK_DIV);
     56e:	movs	r2, #2
     570:	movs	r0, #3
     572:	bl	4f4 <mckl_init(int, int, int)>
        #endif
        
        I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
#else
	// configure transmitter
	I2S0_TMR = 0;
     576:	ldr	r3, [pc, #220]	; (654 <acq_init(int)+0x11c>)
	I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV(BCLK_DIV);
     578:	ldr	r2, [pc, #220]	; (658 <acq_init(int)+0x120>)
        #endif
        
        I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
#else
	// configure transmitter
	I2S0_TMR = 0;
     57a:	str	r4, [r3, #0]
	I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
     57c:	movs	r1, #1
     57e:	str.w	r1, [r3, #-92]
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV(BCLK_DIV);
	I2S0_TCR3 = I2S_TCR3_TCE;
     582:	mov.w	r0, #65536	; 0x10000
#else
	// configure transmitter
	I2S0_TMR = 0;
	I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV(BCLK_DIV);
     586:	str.w	r2, [r3, #-88]
	I2S0_TCR3 = I2S_TCR3_TCE;
	I2S0_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(31) | I2S_TCR4_MF
		| I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD;
     58a:	ldr	r2, [pc, #208]	; (65c <acq_init(int)+0x124>)
	// configure transmitter
	I2S0_TMR = 0;
	I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV(BCLK_DIV);
	I2S0_TCR3 = I2S_TCR3_TCE;
     58c:	str.w	r0, [r3, #-84]
	I2S0_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(31) | I2S_TCR4_MF
		| I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD;
     590:	str.w	r2, [r3, #-80]
	I2S0_TCR5 = I2S_TCR5_WNW(31) | I2S_TCR5_W0W(31) | I2S_TCR5_FBT(31);
     594:	ldr	r3, [pc, #200]	; (660 <acq_init(int)+0x128>)
     596:	str	r3, [r6, #0]

	// configure receiver (sync'd to transmitter clocks)
	I2S0_RMR = 0;
     598:	str.w	r4, [r6, #204]	; 0xcc
	I2S0_RCR1 = I2S_RCR1_RFW(1);
     59c:	str	r1, [r6, #112]	; 0x70
	I2S0_RCR2 = I2S_RCR2_SYNC(1) | I2S_TCR2_BCP | I2S_RCR2_MSEL(1)
		| I2S_RCR2_BCD | I2S_RCR2_DIV(BCLK_DIV);
     59e:	str	r7, [r6, #116]	; 0x74
	I2S0_RCR3 = I2S_RCR3_RCE;
     5a0:	str	r0, [r6, #120]	; 0x78
	I2S0_RCR4 = I2S_RCR4_FRSZ(1) | I2S_RCR4_SYWD(31) | I2S_RCR4_MF
		| I2S_RCR4_FSE | I2S_RCR4_FSP | I2S_RCR4_FSD;
     5a2:	ldr	r0, [pc, #192]	; (664 <acq_init(int)+0x12c>)
        dma.TCD->SADDR = &I2S0_RDR0;
        dma.TCD->SOFF = 0;
        dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
	    dma.TCD->NBYTES_MLOFFNO = 4;
        dma.TCD->SLAST = 0;
        dma.TCD->DADDR = tdm_rx_buffer;
     5a4:	ldr	r6, [pc, #192]	; (668 <acq_init(int)+0x130>)
	I2S0_RCR1 = I2S_RCR1_RFW(1);
	I2S0_RCR2 = I2S_RCR2_SYNC(1) | I2S_TCR2_BCP | I2S_RCR2_MSEL(1)
		| I2S_RCR2_BCD | I2S_RCR2_DIV(BCLK_DIV);
	I2S0_RCR3 = I2S_RCR3_RCE;
	I2S0_RCR4 = I2S_RCR4_FRSZ(1) | I2S_RCR4_SYWD(31) | I2S_RCR4_MF
		| I2S_RCR4_FSE | I2S_RCR4_FSP | I2S_RCR4_FSD;
     5a6:	str	r2, [r0, #0]
	I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
     5a8:	ldr	r2, [pc, #192]	; (66c <acq_init(int)+0x134>)
     5aa:	str	r3, [r2, #0]

	I2S0_TCSR = I2S_TCSR_SR;
     5ac:	ldr	r3, [pc, #192]	; (670 <acq_init(int)+0x138>)
     5ae:	mov.w	r2, #16777216	; 0x1000000
     5b2:	str	r2, [r3, #0]
	I2S0_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;
     5b4:	ldr	r2, [pc, #188]	; (674 <acq_init(int)+0x13c>)
     5b6:	str	r2, [r3, #0]

#endif
// configuration of DMA
        dma.TCD->SADDR = &I2S0_RDR0;
     5b8:	ldr	r2, [pc, #188]	; (678 <acq_init(int)+0x140>)
     5ba:	ldr	r3, [r2, #0]
     5bc:	adds	r0, #16
     5be:	str	r0, [r3, #0]
        dma.TCD->SOFF = 0;
        dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
     5c0:	movw	r0, #514	; 0x202
     5c4:	strh	r0, [r3, #6]
	    dma.TCD->NBYTES_MLOFFNO = 4;
     5c6:	movs	r0, #4
     5c8:	str	r0, [r3, #8]
        dma.TCD->SLAST = 0;
        dma.TCD->DADDR = tdm_rx_buffer;
        dma.TCD->DOFF = 4;
     5ca:	strh	r0, [r3, #20]
        dma.TCD->CITER_ELINKNO = 2*NBUF_I2S;
     5cc:	mov.w	r0, #512	; 0x200
        dma.TCD->SADDR = &I2S0_RDR0;
        dma.TCD->SOFF = 0;
        dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
	    dma.TCD->NBYTES_MLOFFNO = 4;
        dma.TCD->SLAST = 0;
        dma.TCD->DADDR = tdm_rx_buffer;
     5d0:	str	r6, [r3, #16]
	I2S0_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;

#endif
// configuration of DMA
        dma.TCD->SADDR = &I2S0_RDR0;
        dma.TCD->SOFF = 0;
     5d2:	strh	r4, [r3, #4]
        dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
	    dma.TCD->NBYTES_MLOFFNO = 4;
        dma.TCD->SLAST = 0;
        dma.TCD->DADDR = tdm_rx_buffer;
        dma.TCD->DOFF = 4;
        dma.TCD->CITER_ELINKNO = 2*NBUF_I2S;
     5d4:	strh	r0, [r3, #22]
        dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
     5d6:	ldr	r6, [pc, #164]	; (67c <acq_init(int)+0x144>)
        dma.TCD->BITER_ELINKNO = 2*NBUF_I2S;
     5d8:	strh	r0, [r3, #30]
        dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
     5da:	movs	r0, #6
     5dc:	strh	r0, [r3, #28]
// configuration of DMA
        dma.TCD->SADDR = &I2S0_RDR0;
        dma.TCD->SOFF = 0;
        dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
	    dma.TCD->NBYTES_MLOFFNO = 4;
        dma.TCD->SLAST = 0;
     5de:	str	r4, [r3, #12]
        dma.TCD->DADDR = tdm_rx_buffer;
        dma.TCD->DOFF = 4;
        dma.TCD->CITER_ELINKNO = 2*NBUF_I2S;
        dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
     5e0:	str	r6, [r3, #24]
	// 32 bits.  If a channel is configured for 200 transfers

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
     5e2:	ldrb	r3, [r2, #4]
     5e4:	add.w	r3, r3, #1073741824	; 0x40000000
     5e8:	add.w	r3, r3, #135168	; 0x21000
		*mux = 0;
		*mux = (source & 63) | DMAMUX_ENABLE;
     5ec:	movs	r0, #140	; 0x8c

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
		*mux = 0;
     5ee:	strb	r4, [r3, #0]
		*mux = (source & 63) | DMAMUX_ENABLE;
     5f0:	strb	r0, [r3, #0]
        dma.TCD->BITER_ELINKNO = 2*NBUF_I2S;
        dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
        //
        dma.triggerAtHardwareEvent(DMAMUX_SOURCE_I2S0_RX);
        NVIC_SET_PRIORITY(DMAMUX_SOURCE_I2S0_RX,I2S_SAI_PRIO);
     5f2:	ldr	r3, [pc, #140]	; (680 <acq_init(int)+0x148>)
     5f4:	movs	r0, #64	; 0x40
     5f6:	strb	r0, [r3, #0]
        //
        I2S0_RCSR =  I2S_RCSR_FRDE | I2S_RCSR_FR;
     5f8:	ldr	r3, [pc, #136]	; (684 <acq_init(int)+0x14c>)
     5fa:	str	r3, [r5, #0]
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void attachInterrupt(void (*isr)(void), uint8_t prio) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
     5fc:	ldrb	r0, [r2, #4]
     5fe:	ldr	r3, [pc, #136]	; (688 <acq_init(int)+0x150>)
     600:	ldr	r5, [pc, #136]	; (68c <acq_init(int)+0x154>)
     602:	add.w	r4, r0, #16
     606:	str.w	r5, [r3, r4, lsl #2]
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
     60a:	asrs	r3, r0, #5
     60c:	lsls	r3, r3, #2
     60e:	add.w	r3, r3, #3758096384	; 0xe0000000
     612:	add.w	r3, r3, #57600	; 0xe100
     616:	and.w	r0, r0, #31
     61a:	lsls	r1, r0
     61c:	str	r1, [r3, #0]
		NVIC_SET_PRIORITY(IRQ_DMA_CH0 + channel, prio);
     61e:	ldrb	r3, [r2, #4]
     620:	add.w	r3, r3, #3758096384	; 0xe0000000
     624:	add.w	r3, r3, #58368	; 0xe400
     628:	movs	r1, #80	; 0x50
     62a:	strb	r1, [r3, #0]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
     62c:	ldr	r3, [pc, #96]	; (690 <acq_init(int)+0x158>)
     62e:	ldrb	r2, [r2, #4]
     630:	strb	r2, [r3, #0]
     632:	pop	{r3, r4, r5, r6, r7, pc}
     634:	.word	0x00016e36
     638:	.word	0x000124b0
     63c:	.word	0x1fff1348
     640:	.word	0x4002f080
     644:	.word	0x4002f014
     648:	.word	0x47000003
     64c:	.word	0x4004b018
     650:	.word	0x4004b014
     654:	.word	0x4002f060
     658:	.word	0x07000003
     65c:	.word	0x00011f1b
     660:	.word	0x1f1f1f00
     664:	.word	0x4002f090
     668:	.word	0x1fff0200
     66c:	.word	0x4002f094
     670:	.word	0x4002f000
     674:	.word	0x90000001
     678:	.word	0x1fff21cc
     67c:	.word	0xfffff800
     680:	.word	0xe000e40c
     684:	.word	0x02000001
     688:	.word	0x1fff0a00
     68c:	.word	0x000006b5
     690:	.word	0x4000801b

00000694 <extract(void*, void*)>:


const int adc_shift=8;
#if ADC_STEREO // have stereo I2S
    void extract(void *out, void *inp)
    {   
     694:	push	{r4, lr}
     696:	movs	r3, #0
        int32_t *dout = (int32_t *) out;
        int32_t *din  = (int32_t *) inp;
        for(int ii=0; ii < NSAMP; ii++)
        {   dout[0+ii*NCHAN_ACQ] = din[0+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     698:	ldr	r2, [r1, r3]
     69a:	asrs	r2, r2, #8
     69c:	str	r2, [r0, r3]
            dout[1+ii*NCHAN_ACQ] = din[1+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     69e:	adds	r2, r1, r3
     6a0:	adds	r4, r0, r3
     6a2:	ldr	r2, [r2, #4]
     6a4:	adds	r3, #8
     6a6:	asrs	r2, r2, #8
#if ADC_STEREO // have stereo I2S
    void extract(void *out, void *inp)
    {   
        int32_t *dout = (int32_t *) out;
        int32_t *din  = (int32_t *) inp;
        for(int ii=0; ii < NSAMP; ii++)
     6a8:	cmp.w	r3, #1024	; 0x400
        {   dout[0+ii*NCHAN_ACQ] = din[0+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
            dout[1+ii*NCHAN_ACQ] = din[1+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     6ac:	str	r2, [r4, #4]
#if ADC_STEREO // have stereo I2S
    void extract(void *out, void *inp)
    {   
        int32_t *dout = (int32_t *) out;
        int32_t *din  = (int32_t *) inp;
        for(int ii=0; ii < NSAMP; ii++)
     6ae:	bne.n	698 <extract(void*, void*)+0x4>
        {   dout[0+ii*NCHAN_ACQ] = din[0+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
            dout[1+ii*NCHAN_ACQ] = din[1+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
        }
    }
     6b0:	pop	{r4, pc}
     6b2:	Address 0x000006b2 is out of bounds.


000006b4 <acq_isr()>:
        }
    }
#endif

    void acq_isr(void)
    {
     6b4:	push	{r3, lr}
     6b6:	ldr	r3, [pc, #60]	; (6f4 <acq_isr()+0x40>)
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
     6b8:	ldr	r2, [pc, #60]	; (6f8 <acq_isr()+0x44>)
     6ba:	ldrb	r1, [r3, #4]
     6bc:	strb	r1, [r2, #0]
        uint32_t daddr;
        uint32_t *src;

        dma.clearInterrupt();
        asm volatile("dsb");
     6be:	dsb	sy
     6c2:	ldr	r3, [r3, #0]

        #if IMXRT_CACHE_ENABLED >=1
            arm_dcache_delete((void*)src, sizeof(tdm_rx_buffer) / 2);
        #endif

        extract((void *) acq_rx_buffer, (void *) src);
     6c4:	ldr	r0, [pc, #52]	; (6fc <acq_isr()+0x48>)
	}
	void * sourceAddress(void) {
		return (void *)(TCD->SADDR);
	}
	void * destinationAddress(void) {
		return (void *)(TCD->DADDR);
     6c6:	ldr	r1, [r3, #16]

        dma.clearInterrupt();
        asm volatile("dsb");
        daddr = (uint32_t) dma.destinationAddress();

        if (daddr < (uint32_t) &tdm_rx_buffer[NBUF_I2S]) {
     6c8:	ldr	r3, [pc, #52]	; (700 <acq_isr()+0x4c>)
            // need to remove data from the second half
            src = &tdm_rx_buffer[NBUF_I2S];
        } else {
            // DMA is receiving to the second half of the buffer
            // need to remove data from the first half
            src = &tdm_rx_buffer[0];
     6ca:	sub.w	r2, r3, #1024	; 0x400

        #if IMXRT_CACHE_ENABLED >=1
            arm_dcache_delete((void*)src, sizeof(tdm_rx_buffer) / 2);
        #endif

        extract((void *) acq_rx_buffer, (void *) src);
     6ce:	cmp	r1, r3
     6d0:	ite	cc
     6d2:	movcc	r1, r3
     6d4:	movcs	r1, r2
     6d6:	bl	694 <extract(void*, void*)>
        if(!pushData(acq_rx_buffer)) acq_miss++;
     6da:	ldr	r0, [pc, #32]	; (6fc <acq_isr()+0x48>)
     6dc:	bl	1aec <pushData(unsigned long*)>
     6e0:	cbnz	r0, 6ea <acq_isr()+0x36>
     6e2:	ldr	r2, [pc, #32]	; (704 <acq_isr()+0x50>)
     6e4:	ldr	r3, [r2, #0]
     6e6:	adds	r3, #1
     6e8:	str	r3, [r2, #0]
        acq_count++;
     6ea:	ldr	r2, [pc, #28]	; (708 <acq_isr()+0x54>)
     6ec:	ldr	r3, [r2, #0]
     6ee:	adds	r3, #1
     6f0:	str	r3, [r2, #0]
     6f2:	pop	{r3, pc}
     6f4:	.word	0x1fff21cc
     6f8:	.word	0x4000801f
     6fc:	.word	0x1fff1dcc
     700:	.word	0x1fff0600
     704:	.word	0x1fff1dc8
     708:	.word	0x1fff1dc4

0000070c <_GLOBAL__sub_I_acq_count>:
    }
     70c:	push	{r4, lr}
	/*************************************************/
	/**    Channel Allocation                       **/
	/*************************************************/

	DMAChannel() {
		begin();
     70e:	ldr	r4, [pc, #24]	; (728 <_GLOBAL__sub_I_acq_count+0x1c>)
     710:	movs	r1, #0
     712:	mov	r0, r4
     714:	bl	a02c <DMAChannel::begin(bool)>
#include "acq.h"
#include "adc.h"

/********************************************************************************/
#include "DMAChannel.h"
static DMAChannel dma;
     718:	mov	r0, r4
     71a:	ldr	r2, [pc, #16]	; (72c <_GLOBAL__sub_I_acq_count+0x20>)
     71c:	ldr	r1, [pc, #16]	; (730 <_GLOBAL__sub_I_acq_count+0x24>)
        #endif

        extract((void *) acq_rx_buffer, (void *) src);
        if(!pushData(acq_rx_buffer)) acq_miss++;
        acq_count++;
    }
     71e:	ldmia.w	sp!, {r4, lr}
#include "acq.h"
#include "adc.h"

/********************************************************************************/
#include "DMAChannel.h"
static DMAChannel dma;
     722:	b.w	a524 <__aeabi_atexit>
     726:	nop
     728:	.word	0x1fff21cc
     72c:	.word	0x1fff0f30
     730:	.word	0x0000046d

00000734 <Print::write(char const*)>:
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     734:	push	{r4, r5, r6, lr}
     736:	mov	r4, r0
     738:	mov	r0, r1
     73a:	mov	r5, r1
     73c:	bl	bf80 <strlen>
     740:	ldr	r3, [r4, #0]
     742:	mov	r2, r0
     744:	mov	r1, r5
     746:	mov	r0, r4
     748:	ldr	r3, [r3, #4]
     74a:	ldmia.w	sp!, {r4, r5, r6, lr}
     74e:	bx	r3

00000750 <Print::print(unsigned long)>:

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
     750:	movs	r3, #0
     752:	movs	r2, #10
     754:	b.w	a1f6 <Print::printNumber(unsigned long, unsigned char, unsigned char)>

00000758 <Print::println(char const*)>:
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     758:	push	{r3, r4, r5, lr}
     75a:	mov	r5, r0
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
     75c:	bl	734 <Print::write(char const*)>
     760:	mov	r4, r0
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     762:	mov	r0, r5
     764:	bl	a1bc <Print::println()>
     768:	add	r0, r4
     76a:	pop	{r3, r4, r5, pc}

0000076c <checkToCloseFile(short, unsigned long)>:

uint32_t t_start;

/* check if we should close file */
int16_t checkToCloseFile(int16_t status, uint32_t t_acq)
{ if((status == OPENED) || (status == RUNNING))
     76c:	push	{r3, r4, r5, lr}
     76e:	subs	r3, r0, #1
     770:	uxth	r3, r3
     772:	cmp	r3, #1
     774:	mov	r5, r0
     776:	mov	r4, r1
     778:	bhi.n	792 <checkToCloseFile(short, unsigned long)+0x26>
  { //
    static uint32_t to =0;
    uint32_t tx=rtc_get();
     77a:	bl	9440 <rtc_get>
    tx %= t_acq;
    if(tx<to) status = DOCLOSE; // time wrapped, file must be closed
     77e:	ldr	r3, [pc, #24]	; (798 <checkToCloseFile(short, unsigned long)+0x2c>)
int16_t checkToCloseFile(int16_t status, uint32_t t_acq)
{ if((status == OPENED) || (status == RUNNING))
  { //
    static uint32_t to =0;
    uint32_t tx=rtc_get();
    tx %= t_acq;
     780:	udiv	r1, r0, r4
    if(tx<to) status = DOCLOSE; // time wrapped, file must be closed
     784:	ldr	r2, [r3, #0]
int16_t checkToCloseFile(int16_t status, uint32_t t_acq)
{ if((status == OPENED) || (status == RUNNING))
  { //
    static uint32_t to =0;
    uint32_t tx=rtc_get();
    tx %= t_acq;
     786:	mls	r0, r1, r4, r0
    if(tx<to) status = DOCLOSE; // time wrapped, file must be closed
     78a:	cmp	r0, r2
     78c:	it	cc
     78e:	movcc	r5, #3
    to=tx;
     790:	str	r0, [r3, #0]
  } 
  return status;
}
     792:	mov	r0, r5
     794:	pop	{r3, r4, r5, pc}
     796:	nop
     798:	.word	0x1fff21d8

0000079c <setup>:

void setup()
{
     79c:	push	{r3, r4, r5, lr}
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     79e:	ldr	r0, [pc, #100]	; (804 <setup+0x68>)
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     7a0:	ldr	r4, [pc, #100]	; (808 <setup+0x6c>)
     7a2:	ldr	r5, [pc, #104]	; (80c <setup+0x70>)
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     7a4:	ldr	r1, [pc, #104]	; (810 <setup+0x74>)
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     7a6:	ldrb	r3, [r4, #0]
     7a8:	cmp	r3, #0
     7aa:	beq.n	7a6 <setup+0xa>
     7ac:	ldrb	r3, [r5, #0]
     7ae:	lsls	r3, r3, #31
     7b0:	bpl.n	7a6 <setup+0xa>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     7b2:	ldr	r3, [r0, #0]
     7b4:	ldr	r2, [r1, #0]
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     7b6:	subs	r3, r3, r2
     7b8:	cmp	r3, #14
     7ba:	bls.n	7a6 <setup+0xa>
  while(!Serial) continue;
  Serial.println("basic Sound Recorder Version: " __DATE__  " " __TIME__ );
     7bc:	ldr	r1, [pc, #84]	; (814 <setup+0x78>)
     7be:	ldr	r0, [pc, #88]	; (818 <setup+0x7c>)
     7c0:	bl	758 <Print::println(char const*)>
  SerNum = getTeensySerial();
     7c4:	bl	14a8 <getTeensySerial()>
     7c8:	ldr	r3, [pc, #80]	; (81c <setup+0x80>)
	size_t print(uint64_t n)			{ return printNumber64(n, 10, 0); }

	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
     7ca:	movs	r2, #16
     7cc:	mov	r1, r0
     7ce:	str	r0, [r3, #0]
     7d0:	movs	r3, #0
     7d2:	ldr	r0, [pc, #68]	; (818 <setup+0x7c>)
     7d4:	bl	a1f6 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	size_t println(uint64_t n)			{ return print(n) + println(); }

	size_t println(unsigned char n, int base)	{ return print(n, base) + println(); }
	size_t println(int n, int base)			{ return print(n, base) + println(); }
	size_t println(unsigned int n, int base)	{ return print(n, base) + println(); }
	size_t println(long n, int base)		{ return print(n, base) + println(); }
     7d8:	ldr	r0, [pc, #60]	; (818 <setup+0x7c>)
     7da:	bl	a1bc <Print::println()>
  Serial.println((int32_t)SerNum,HEX);

  storage_configure();
     7de:	bl	1b9c <storage_configure()>

  adc_init();
     7e2:	bl	233a <adc_init()>
  acq_init(FSAMP);
     7e6:	ldr	r0, [pc, #56]	; (820 <setup+0x84>)
     7e8:	bl	538 <acq_init(int)>
  adc_enable(0);
     7ec:	ldr	r1, [pc, #52]	; (824 <setup+0x88>)
     7ee:	movs	r0, #0
     7f0:	bl	2340 <adc_enable(unsigned int, unsigned long)>

  #if START_MODE==CLOSED
    acq_start(); 
     7f4:	bl	4c8 <acq_start()>
  #endif

  Serial.println("End of Setup");
     7f8:	ldr	r1, [pc, #44]	; (828 <setup+0x8c>)
     7fa:	ldr	r0, [pc, #28]	; (818 <setup+0x7c>)
     7fc:	bl	758 <Print::println(char const*)>
     800:	pop	{r3, r4, r5, pc}
     802:	nop
     804:	.word	0x2001a6fc
     808:	.word	0x2001a7df
     80c:	.word	0x2001a6f8
     810:	.word	0x2001a850
     814:	.word	0x000124b7
     818:	.word	0x1fff1348
     81c:	.word	0x1fff220c
     820:	.word	0x00017700
     824:	.word	0x0ac44000
     828:	.word	0x000124ea

0000082c <loop>:
}

void loop()
{ static int16_t status=START_MODE; 
     82c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

  if(status==MUST_REBOOT) status=checkReboot(); // hapens only if microSD card write fails: reboot if space on disk
     830:	ldr	r4, [pc, #296]	; (95c <loop+0x130>)
     832:	ldrsh.w	r3, [r4]
     836:	adds	r3, #2

  Serial.println("End of Setup");
}

void loop()
{ static int16_t status=START_MODE; 
     838:	sub	sp, #20

  if(status==MUST_REBOOT) status=checkReboot(); // hapens only if microSD card write fails: reboot if space on disk
     83a:	bne.n	842 <loop+0x16>
     83c:	bl	1e08 <checkReboot()>
     840:	strh	r0, [r4, #0]

  // normal operation
  int16_t ch=menu();  // check if we have serial line command (0: no input; 1: start; -1: stop)
     842:	bl	12f4 <menu()>

  if(ch>0 && status==STOPPED)  // was stopped, should run now 
     846:	cmp	r0, #0
     848:	ble.n	862 <loop+0x36>
     84a:	ldrsh.w	r3, [r4]
     84e:	adds	r3, #1
     850:	bne.n	876 <loop+0x4a>
  { 
    status=CLOSED; acq_start(); adcStatus();
     852:	ldr	r3, [pc, #264]	; (95c <loop+0x130>)
     854:	movs	r2, #0
     856:	strh	r2, [r3, #0]
     858:	bl	4c8 <acq_start()>
     85c:	bl	233c <adcStatus()>
     860:	b.n	876 <loop+0x4a>
  }  
  
  if(ch<0 && status>=CLOSED)  // was running, should stop now
     862:	beq.n	876 <loop+0x4a>
     864:	ldrsh.w	r3, [r4]
     868:	cmp	r3, #0
     86a:	blt.n	876 <loop+0x4a>
  { 
    status=MUSTSTOP;  acq_stop();  
     86c:	ldr	r3, [pc, #236]	; (95c <loop+0x130>)
     86e:	movs	r2, #4
     870:	strh	r2, [r3, #0]
     872:	bl	4e0 <acq_stop()>
  } 

  if(status > CLOSED) // RUNNING
     876:	ldrsh.w	r0, [r4]
     87a:	cmp	r0, #0
     87c:	ble.n	88a <loop+0x5e>
  {
    status = checkToCloseFile(status, (uint32_t) t_acq); // check if we reached file size or aquisition time
     87e:	ldr	r3, [pc, #224]	; (960 <loop+0x134>)
     880:	ldr	r1, [r3, #0]
     882:	bl	76c <checkToCloseFile(short, unsigned long)>
     886:	ldr	r3, [pc, #212]	; (95c <loop+0x130>)
     888:	strh	r0, [r3, #0]
  }

  if(status >= CLOSED) // NOT STOPPED
     88a:	ldrsh.w	r3, [r4]
     88e:	ldr	r5, [pc, #212]	; (964 <loop+0x138>)
     890:	cmp	r3, #0
     892:	blt.n	8c4 <loop+0x98>
  {
    uint32_t mc = getCount();
     894:	bl	1ad4 <getCount()>
    if(mc>max_count) max_count=mc;
     898:	ldr	r3, [pc, #204]	; (968 <loop+0x13c>)
     89a:	ldr	r2, [r3, #0]
     89c:	cmp	r0, r2
     89e:	it	hi
     8a0:	strhi	r0, [r3, #0]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     8a2:	ldr	r3, [r5, #0]
     8a4:	str	r3, [sp, #4]
    //
    uint32_t to=millis();
    status = saveData(status);  
     8a6:	ldrsh.w	r0, [r4]
	return ret;
     8aa:	ldr	r6, [sp, #4]
     8ac:	bl	1e10 <saveData(short)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     8b0:	ldr	r3, [r5, #0]
    uint32_t dt=millis()-to;
    if(max_write<dt) max_write=dt;
     8b2:	ldr	r2, [pc, #184]	; (96c <loop+0x140>)
     8b4:	str	r3, [sp, #0]
	return ret;
     8b6:	ldr	r3, [sp, #0]
     8b8:	ldr	r1, [r2, #0]
  {
    uint32_t mc = getCount();
    if(mc>max_count) max_count=mc;
    //
    uint32_t to=millis();
    status = saveData(status);  
     8ba:	strh	r0, [r4, #0]
    uint32_t dt=millis()-to;
     8bc:	subs	r3, r3, r6
    if(max_write<dt) max_write=dt;
     8be:	cmp	r3, r1
     8c0:	it	hi
     8c2:	strhi	r3, [r2, #0]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     8c4:	ldr	r3, [r5, #0]
  }

  static uint32_t t0;
  if(millis()-t0>1000)
     8c6:	ldr	r2, [pc, #168]	; (970 <loop+0x144>)
     8c8:	str	r3, [sp, #8]
	return ret;
     8ca:	ldr	r3, [sp, #8]
     8cc:	ldr	r1, [r2, #0]
     8ce:	subs	r3, r3, r1
     8d0:	cmp.w	r3, #1000	; 0x3e8
     8d4:	mov	r9, r2
     8d6:	bls.n	956 <loop+0x12a>
  {
    if(status>=CLOSED)
     8d8:	ldrsh.w	r3, [r4]
     8dc:	ldr	r6, [pc, #136]	; (968 <loop+0x13c>)
     8de:	ldr	r4, [pc, #140]	; (96c <loop+0x140>)
     8e0:	ldr.w	r8, [pc, #164]	; 988 <loop+0x15c>
     8e4:	ldr	r7, [pc, #140]	; (974 <loop+0x148>)
     8e6:	cmp	r3, #0
     8e8:	blt.n	940 <loop+0x114>
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
     8ea:	ldr	r1, [pc, #140]	; (978 <loop+0x14c>)
     8ec:	ldr	r0, [pc, #140]	; (97c <loop+0x150>)
     8ee:	bl	734 <Print::write(char const*)>
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
     8f2:	ldr	r3, [pc, #104]	; (95c <loop+0x130>)
     8f4:	ldr	r0, [pc, #132]	; (97c <loop+0x150>)
     8f6:	ldrsh.w	r1, [r3]
     8fa:	bl	a26c <Print::print(long)>
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
     8fe:	ldr	r1, [pc, #128]	; (980 <loop+0x154>)
     900:	ldr	r0, [pc, #120]	; (97c <loop+0x150>)
     902:	bl	734 <Print::write(char const*)>
    {
      Serial.print("\nLoop: ");
        Serial.print(status); Serial.print(" : "); 
        Serial.print(acq_count); Serial.print(" ");
     906:	ldr.w	r1, [r8]
     90a:	ldr	r0, [pc, #112]	; (97c <loop+0x150>)
     90c:	bl	750 <Print::print(unsigned long)>
     910:	ldr	r1, [pc, #112]	; (984 <loop+0x158>)
     912:	ldr	r0, [pc, #104]	; (97c <loop+0x150>)
     914:	bl	734 <Print::write(char const*)>
        Serial.print(acq_miss); Serial.print(" ");
     918:	ldr	r1, [r7, #0]
     91a:	ldr	r0, [pc, #96]	; (97c <loop+0x150>)
     91c:	bl	750 <Print::print(unsigned long)>
     920:	ldr	r1, [pc, #96]	; (984 <loop+0x158>)
     922:	ldr	r0, [pc, #88]	; (97c <loop+0x150>)
     924:	bl	734 <Print::write(char const*)>
        Serial.print(max_count); Serial.print(" ");
     928:	ldr	r1, [r6, #0]
     92a:	ldr	r0, [pc, #80]	; (97c <loop+0x150>)
     92c:	bl	750 <Print::print(unsigned long)>
     930:	ldr	r1, [pc, #80]	; (984 <loop+0x158>)
     932:	ldr	r0, [pc, #72]	; (97c <loop+0x150>)
     934:	bl	734 <Print::write(char const*)>
        Serial.print(max_write);
     938:	ldr	r1, [r4, #0]
     93a:	ldr	r0, [pc, #64]	; (97c <loop+0x150>)
     93c:	bl	750 <Print::print(unsigned long)>
    }
    acq_count=0;
     940:	movs	r3, #0
     942:	str.w	r3, [r8]
    acq_miss=0;
     946:	str	r3, [r7, #0]
    max_count=0;
     948:	str	r3, [r6, #0]
    max_write=0;
     94a:	str	r3, [r4, #0]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     94c:	ldr	r3, [r5, #0]
     94e:	str	r3, [sp, #12]
	return ret;
     950:	ldr	r3, [sp, #12]
    t0=millis();
     952:	str.w	r3, [r9]
  }
     956:	add	sp, #20
     958:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     95c:	.word	0x1fff21e0
     960:	.word	0x1fff0f34
     964:	.word	0x2001a6fc
     968:	.word	0x1fff21e4
     96c:	.word	0x1fff21d4
     970:	.word	0x1fff21dc
     974:	.word	0x1fff1dc8
     978:	.word	0x000124f7
     97c:	.word	0x1fff1348
     980:	.word	0x000124ff
     984:	.word	0x00012501
     988:	.word	0x1fff1dc4

0000098c <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
     98c:	movs	r0, #0
     98e:	bx	lr

00000990 <Print::flush()>:
	virtual void flush()				{ }
     990:	bx	lr

00000992 <File::write(unsigned char const*, unsigned int)>:
		return (f) ? f->read(buf, nbyte) : 0;
	}
	
	// override print version
	virtual size_t write(const uint8_t *buf, size_t size) {
		return (f) ? f->write((void*)buf, size) : 0;
     992:	ldr	r0, [r0, #16]
     994:	cbz	r0, 99c <File::write(unsigned char const*, unsigned int)+0xa>
     996:	ldr	r3, [r0, #0]
     998:	ldr	r3, [r3, #12]
     99a:	bx	r3
	}
     99c:	bx	lr

0000099e <File::available()>:

	size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
	}
	int available() {
		return (f) ? f->available() : 0;
     99e:	ldr	r0, [r0, #16]
     9a0:	cbz	r0, 9a8 <File::available()+0xa>
     9a2:	ldr	r3, [r0, #0]
     9a4:	ldr	r3, [r3, #16]
     9a6:	bx	r3
	}
     9a8:	bx	lr

000009aa <File::peek()>:
	int peek() {
		return (f) ? f->peek() : -1;
     9aa:	ldr	r0, [r0, #16]
     9ac:	cbz	r0, 9b4 <File::peek()+0xa>
     9ae:	ldr	r3, [r0, #0]
     9b0:	ldr	r3, [r3, #20]
     9b2:	bx	r3
	}
     9b4:	mov.w	r0, #4294967295
     9b8:	bx	lr

000009ba <File::flush()>:
	void flush() {
		if (f) f->flush();
     9ba:	ldr	r0, [r0, #16]
     9bc:	cbz	r0, 9c4 <File::flush()+0xa>
     9be:	ldr	r3, [r0, #0]
     9c0:	ldr	r3, [r3, #24]
     9c2:	bx	r3
     9c4:	bx	lr

000009c6 <File::read()>:
		return (f) ? f->setModifyTime(tm) : false;
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
     9c6:	push	{r0, r1, r2, lr}
		if (!f) return -1;
     9c8:	ldr	r0, [r0, #16]
     9ca:	cbnz	r0, 9d2 <File::read()+0xc>
     9cc:	mov.w	r0, #4294967295
     9d0:	b.n	9e6 <File::read()+0x20>
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
     9d2:	ldr	r3, [r0, #0]
     9d4:	movs	r2, #1
     9d6:	ldr	r3, [r3, #8]
     9d8:	add.w	r1, sp, #7
     9dc:	blx	r3
     9de:	cmp	r0, #0
     9e0:	beq.n	9cc <File::read()+0x6>
		return b;
     9e2:	ldrb.w	r0, [sp, #7]
	}
     9e6:	add	sp, #12
     9e8:	ldr.w	pc, [sp], #4

000009ec <File::write(unsigned char)>:
	size_t write(uint8_t b) {
     9ec:	push	{r0, r1, r2, lr}
		return (f) ? f->write(&b, 1) : 0;
     9ee:	ldr	r0, [r0, #16]
		if (!f) return -1;
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
		return b;
	}
	size_t write(uint8_t b) {
     9f0:	strb.w	r1, [sp, #7]
		return (f) ? f->write(&b, 1) : 0;
     9f4:	cbz	r0, a02 <File::write(unsigned char)+0x16>
     9f6:	ldr	r3, [r0, #0]
     9f8:	movs	r2, #1
     9fa:	ldr	r3, [r3, #12]
     9fc:	add.w	r1, sp, #7
     a00:	blx	r3
	}
     a02:	add	sp, #12
     a04:	ldr.w	pc, [sp], #4

00000a08 <SDFile::getCreateTime(DateTimeFields&)>:
		return File();
	}
	virtual void rewindDirectory(void) {
		sdfatfile.rewindDirectory();
	}
	virtual bool getCreateTime(DateTimeFields &tm) {
     a08:	push	{r0, r1, r4, lr}
     a0a:	mov	r3, r0
   * \param[out] ptime Packed time for directory entry.
   *
   * \return true for success or false for failure.
   */
  bool getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    return m_fFile ? m_fFile->getCreateDateTime(pdate, ptime) :
     a0c:	ldr	r0, [r0, #80]	; 0x50
     a0e:	mov	r4, r1
           m_xFile ? m_xFile->getCreateDateTime(pdate, ptime) : false;
     a10:	cbz	r0, a1e <SDFile::getCreateTime(DateTimeFields&)+0x16>
     a12:	add.w	r2, sp, #6
     a16:	add	r1, sp, #4
     a18:	bl	63ae <FatFile::getCreateDateTime(unsigned short*, unsigned short*)>
     a1c:	b.n	a30 <SDFile::getCreateTime(DateTimeFields&)+0x28>
     a1e:	ldr	r0, [r3, #84]	; 0x54
     a20:	cbnz	r0, a26 <SDFile::getCreateTime(DateTimeFields&)+0x1e>
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getCreateDateTime(&fat_date, &fat_time)) return false;
     a22:	movs	r0, #0
     a24:	b.n	a6a <SDFile::getCreateTime(DateTimeFields&)+0x62>
     a26:	add.w	r2, sp, #6
     a2a:	add	r1, sp, #4
     a2c:	bl	40ba <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)>
     a30:	cmp	r0, #0
     a32:	beq.n	a22 <SDFile::getCreateTime(DateTimeFields&)+0x1a>
		if ((fat_date == 0) && (fat_time == 0)) return false;
     a34:	ldrh.w	r3, [sp, #4]
     a38:	ldrh.w	r2, [sp, #6]
     a3c:	cbnz	r3, a42 <SDFile::getCreateTime(DateTimeFields&)+0x3a>
     a3e:	cmp	r2, #0
     a40:	beq.n	a22 <SDFile::getCreateTime(DateTimeFields&)+0x1a>
		tm.sec = FS_SECOND(fat_time);
     a42:	and.w	r1, r2, #31
     a46:	lsls	r1, r1, #1
     a48:	strb	r1, [r4, #0]
		tm.min = FS_MINUTE(fat_time);
     a4a:	ubfx	r1, r2, #5, #6
		tm.hour = FS_HOUR(fat_time);
     a4e:	asrs	r2, r2, #11
     a50:	strb	r2, [r4, #2]
		tm.mday = FS_DAY(fat_date);
     a52:	and.w	r2, r3, #31
     a56:	strb	r2, [r4, #4]
		tm.mon = FS_MONTH(fat_date) - 1;
     a58:	ubfx	r2, r3, #5, #4
		tm.year = FS_YEAR(fat_date) - 1900;
     a5c:	asrs	r3, r3, #9
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     a5e:	subs	r2, #1
		tm.year = FS_YEAR(fat_date) - 1900;
     a60:	add.w	r3, r3, #1872	; 0x750
	virtual bool getCreateTime(DateTimeFields &tm) {
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getCreateDateTime(&fat_date, &fat_time)) return false;
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
     a64:	strb	r1, [r4, #1]
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     a66:	strb	r2, [r4, #5]
		tm.year = FS_YEAR(fat_date) - 1900;
     a68:	strb	r3, [r4, #6]
		return true;
	}
     a6a:	add	sp, #8
     a6c:	pop	{r4, pc}

00000a6e <SDFile::getModifyTime(DateTimeFields&)>:
	virtual bool getModifyTime(DateTimeFields &tm) {
     a6e:	push	{r0, r1, r4, lr}
     a70:	mov	r3, r0
   * \param[out] ptime Packed time for directory entry.
   *
   * \return true for success or false for failure.
   */
  bool getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    return m_fFile ? m_fFile->getModifyDateTime(pdate, ptime) :
     a72:	ldr	r0, [r0, #80]	; 0x50
     a74:	mov	r4, r1
           m_xFile ? m_xFile->getModifyDateTime(pdate, ptime) : false;
     a76:	cbz	r0, a84 <SDFile::getModifyTime(DateTimeFields&)+0x16>
     a78:	add.w	r2, sp, #6
     a7c:	add	r1, sp, #4
     a7e:	bl	63ce <FatFile::getModifyDateTime(unsigned short*, unsigned short*)>
     a82:	b.n	a96 <SDFile::getModifyTime(DateTimeFields&)+0x28>
     a84:	ldr	r0, [r3, #84]	; 0x54
     a86:	cbnz	r0, a8c <SDFile::getModifyTime(DateTimeFields&)+0x1e>
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getModifyDateTime(&fat_date, &fat_time)) return false;
     a88:	movs	r0, #0
     a8a:	b.n	ad0 <SDFile::getModifyTime(DateTimeFields&)+0x62>
     a8c:	add.w	r2, sp, #6
     a90:	add	r1, sp, #4
     a92:	bl	40da <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)>
     a96:	cmp	r0, #0
     a98:	beq.n	a88 <SDFile::getModifyTime(DateTimeFields&)+0x1a>
		if ((fat_date == 0) && (fat_time == 0)) return false;
     a9a:	ldrh.w	r3, [sp, #4]
     a9e:	ldrh.w	r2, [sp, #6]
     aa2:	cbnz	r3, aa8 <SDFile::getModifyTime(DateTimeFields&)+0x3a>
     aa4:	cmp	r2, #0
     aa6:	beq.n	a88 <SDFile::getModifyTime(DateTimeFields&)+0x1a>
		tm.sec = FS_SECOND(fat_time);
     aa8:	and.w	r1, r2, #31
     aac:	lsls	r1, r1, #1
     aae:	strb	r1, [r4, #0]
		tm.min = FS_MINUTE(fat_time);
     ab0:	ubfx	r1, r2, #5, #6
		tm.hour = FS_HOUR(fat_time);
     ab4:	asrs	r2, r2, #11
     ab6:	strb	r2, [r4, #2]
		tm.mday = FS_DAY(fat_date);
     ab8:	and.w	r2, r3, #31
     abc:	strb	r2, [r4, #4]
		tm.mon = FS_MONTH(fat_date) - 1;
     abe:	ubfx	r2, r3, #5, #4
		tm.year = FS_YEAR(fat_date) - 1900;
     ac2:	asrs	r3, r3, #9
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     ac4:	subs	r2, #1
		tm.year = FS_YEAR(fat_date) - 1900;
     ac6:	add.w	r3, r3, #1872	; 0x750
	virtual bool getModifyTime(DateTimeFields &tm) {
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getModifyDateTime(&fat_date, &fat_time)) return false;
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
     aca:	strb	r1, [r4, #1]
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     acc:	strb	r2, [r4, #5]
		tm.year = FS_YEAR(fat_date) - 1900;
     ace:	strb	r3, [r4, #6]
		return true;
	}
     ad0:	add	sp, #8
     ad2:	pop	{r4, pc}

00000ad4 <SDFile::name()>:
		}
	}
	virtual bool isOpen() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
     ad4:	push	{r3, r4, r5, lr}
		if (!filename) {
     ad6:	ldr	r5, [r0, #88]	; 0x58
		}
	}
	virtual bool isOpen() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
     ad8:	mov	r4, r0
		if (!filename) {
     ada:	cbnz	r5, b0c <SDFile::name()+0x38>
			filename = (char *)malloc(MAX_FILENAME_LEN);
     adc:	mov.w	r0, #256	; 0x100
     ae0:	bl	b318 <malloc>
     ae4:	mov	r1, r0
     ae6:	str	r0, [r4, #88]	; 0x58
			if (filename) {
     ae8:	cbz	r0, b08 <SDFile::name()+0x34>
   *             must be at least 13 bytes long.  The file's name will be
   *             truncated if the file's name is too long.
   * \return The length of the returned string.
   */
  size_t getName(char* name, size_t len) {
    *name = 0;
     aea:	strb	r5, [r0, #0]
    return m_fFile ? m_fFile->getName(name, len) :
     aec:	ldr	r0, [r4, #80]	; 0x50
           m_xFile ? m_xFile->getName(name, len) : 0;
     aee:	cbz	r0, afa <SDFile::name()+0x26>
     af0:	mov.w	r2, #256	; 0x100
     af4:	bl	5c9c <FatFile::getName(char*, unsigned int)>
     af8:	b.n	b0c <SDFile::name()+0x38>
     afa:	ldr	r0, [r4, #84]	; 0x54
     afc:	cbz	r0, b0c <SDFile::name()+0x38>
   * \param[in] size The size of the array in characters.
   * \return the name length.
   */
  size_t getName(char* name, size_t size) {
#if USE_UTF8_LONG_NAMES
    return getName8(name, size);
     afe:	mov.w	r2, #256	; 0x100
     b02:	bl	3f5c <ExFatFile::getName8(char*, unsigned int)>
     b06:	b.n	b0c <SDFile::name()+0x38>
				sdfatfile.getName(filename, MAX_FILENAME_LEN);
			} else {
				static char zeroterm = 0;
				filename = &zeroterm;
     b08:	ldr	r3, [pc, #4]	; (b10 <SDFile::name()+0x3c>)
     b0a:	str	r3, [r4, #88]	; 0x58
			}
		}
		return filename;
	}
     b0c:	ldr	r0, [r4, #88]	; 0x58
     b0e:	pop	{r3, r4, r5, pc}
     b10:	.word	0x1fff21e8

00000b14 <SDFile::truncate(unsigned long long)>:
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
		return sdfatfile.read(buf, nbyte);
	}
	virtual bool truncate(uint64_t size=0) {
     b14:	push	{r4, r6, r7, lr}
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     b16:	ldr	r4, [r0, #80]	; 0x50
           m_xFile ? m_xFile->truncate(length) : false;
     b18:	cbz	r4, b36 <SDFile::truncate(unsigned long long)+0x22>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     b1a:	cmp	r3, #1
     b1c:	it	eq
     b1e:	cmpeq	r2, #0
     b20:	bcs.n	b4c <SDFile::truncate(unsigned long long)+0x38>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint32_t length) {
    return seekSet(length) && truncate();
     b22:	mov	r1, r2
     b24:	mov	r0, r4
     b26:	bl	5fde <FatFile::seekSet(unsigned long)>
     b2a:	cbz	r0, b4c <SDFile::truncate(unsigned long long)+0x38>
     b2c:	mov	r0, r4
     b2e:	bl	67d6 <FatFile::truncate()>
     b32:	cbz	r0, b4c <SDFile::truncate(unsigned long long)+0x38>
     b34:	pop	{r4, r6, r7, pc}
           m_xFile ? m_xFile->truncate(length) : false;
     b36:	ldr	r4, [r0, #84]	; 0x54
     b38:	cbz	r4, b4c <SDFile::truncate(unsigned long long)+0x38>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
     b3a:	mov	r0, r4
     b3c:	bl	434c <ExFatFile::seekSet(unsigned long long)>
     b40:	cbz	r0, b4c <SDFile::truncate(unsigned long long)+0x38>
     b42:	mov	r0, r4
		return sdfatfile.truncate(size);
	}
     b44:	ldmia.w	sp!, {r4, r6, r7, lr}
     b48:	b.w	533e <ExFatFile::truncate()>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     b4c:	movs	r0, #0
     b4e:	pop	{r4, r6, r7, pc}

00000b50 <File::dec_refcount() [clone .isra.15]>:
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	using Print::write;
private:
	void dec_refcount() {
     b50:	push	{r4, lr}
     b52:	mov	r4, r0
		if (--(f->refcount) == 0) {
     b54:	ldr	r0, [r0, #0]
     b56:	ldr	r3, [r0, #4]
     b58:	subs	r3, #1
     b5a:	str	r3, [r0, #4]
     b5c:	cbnz	r3, b6e <File::dec_refcount() [clone .isra.15]+0x1e>
			f->close();
     b5e:	ldr	r3, [r0, #0]
     b60:	ldr	r3, [r3, #44]	; 0x2c
     b62:	blx	r3
			delete f;
     b64:	ldr	r0, [r4, #0]
     b66:	cbz	r0, b6e <File::dec_refcount() [clone .isra.15]+0x1e>
     b68:	ldr	r3, [r0, #0]
     b6a:	ldr	r3, [r3, #4]
     b6c:	blx	r3
		}
		f = nullptr;
     b6e:	movs	r3, #0
     b70:	str	r3, [r4, #0]
     b72:	pop	{r4, pc}

00000b74 <File::~File()>:
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
     b74:	ldr	r3, [pc, #20]	; (b8c <File::~File()+0x18>)
     b76:	push	{r4, lr}
     b78:	str	r3, [r0, #0]
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
     b7a:	ldr	r3, [r0, #16]
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
     b7c:	mov	r4, r0
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
     b7e:	cbz	r3, b86 <File::~File()+0x12>
     b80:	adds	r0, #16
     b82:	bl	b50 <File::dec_refcount() [clone .isra.15]>
	}
     b86:	mov	r0, r4
     b88:	pop	{r4, pc}
     b8a:	nop
     b8c:	.word	0x00012578

00000b90 <File::~File()>:
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
     b90:	push	{r4, lr}
     b92:	mov	r4, r0
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
	}
     b94:	bl	b74 <File::~File()>
     b98:	mov	r0, r4
     b9a:	movs	r1, #20
     b9c:	bl	a3b8 <operator delete(void*, unsigned int)>
     ba0:	mov	r0, r4
     ba2:	pop	{r4, pc}

00000ba4 <SDFile::position()>:
    return m_fFile ? m_fFile->contiguousRange(bgnSector, endSector) :
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
     ba4:	ldr	r3, [r0, #80]	; 0x50
           m_xFile ? m_xFile->curPosition() : 0;
     ba6:	cbz	r3, bae <SDFile::position()+0xa>
     ba8:	ldr	r0, [r3, #20]
     baa:	movs	r1, #0
     bac:	bx	lr
     bae:	ldr	r3, [r0, #84]	; 0x54
     bb0:	cbz	r3, bb8 <SDFile::position()+0x14>
   *
   * \return true for success or false for failure.
   */
  bool contiguousRange(uint32_t* bgnSector, uint32_t* endSector);
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {return m_curPosition;}
     bb2:	ldmia.w	r3, {r0, r1}
     bb6:	bx	lr
     bb8:	mov	r0, r3
     bba:	b.n	baa <SDFile::position()+0x6>

00000bbc <SDFile::size()>:
    return m_fFile ? m_fFile->fgets(str, num, delim) :
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
     bbc:	ldr	r3, [r0, #80]	; 0x50
           m_xFile ? m_xFile->fileSize() : 0;
     bbe:	cbz	r3, bc6 <SDFile::size()+0xa>
     bc0:	ldr	r0, [r3, #28]
     bc2:	movs	r1, #0
     bc4:	bx	lr
     bc6:	ldr	r3, [r0, #84]	; 0x54
     bc8:	cbz	r3, bd0 <SDFile::size()+0x14>
   * If no data is read, fgets() returns zero for EOF or -1 if an error
   * occurred.
   */
  int fgets(char* str, int num, char* delim = nullptr);
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {return m_validLength;}
     bca:	ldr	r0, [r3, #16]
     bcc:	ldr	r1, [r3, #20]
     bce:	bx	lr
     bd0:	mov	r0, r3
     bd2:	b.n	bc2 <SDFile::size()+0x6>

00000bd4 <FsBaseFile::available() const>:
  operator bool() const {return isOpen();}
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
    return m_fFile ? m_fFile->available() :
     bd4:	ldr	r2, [r0, #56]	; 0x38
    */
  operator bool() const {return isOpen();}
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
     bd6:	push	{r4, r5, lr}
    return m_fFile ? m_fFile->available() :
           m_xFile ? m_xFile->available() : 0;
     bd8:	cbz	r2, bf4 <FsBaseFile::available() const+0x20>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available32() const {
    return isFile() ? fileSize() - curPosition() : 0;
     bda:	ldrb	r3, [r2, #0]
     bdc:	and.w	r3, r3, #8
     be0:	and.w	r0, r3, #255	; 0xff
     be4:	cbz	r3, c26 <FsBaseFile::available() const+0x52>
     be6:	ldr	r3, [r2, #28]
     be8:	ldr	r0, [r2, #20]
   * Zero is returned for directory files.
   *
   */
  int available() const {
    uint32_t n = available32();
    return n > INT_MAX ? INT_MAX : n;
     bea:	subs	r0, r3, r0
     bec:	bpl.n	c26 <FsBaseFile::available() const+0x52>
     bee:	mvn.w	r0, #2147483648	; 0x80000000
     bf2:	b.n	c26 <FsBaseFile::available() const+0x52>
     bf4:	ldr	r0, [r0, #60]	; 0x3c
     bf6:	cbz	r0, c26 <FsBaseFile::available() const+0x52>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint64_t available64() {
    return isFile() ? fileSize() - curPosition() : 0;
     bf8:	ldrb.w	r3, [r0, #49]	; 0x31
     bfc:	lsls	r3, r3, #28
     bfe:	bpl.n	c10 <FsBaseFile::available() const+0x3c>
     c00:	ldrd	r4, r5, [r0, #16]
     c04:	ldrd	r2, r3, [r0]
     c08:	subs	r0, r4, r2
     c0a:	sbc.w	r1, r5, r3
     c0e:	b.n	c14 <FsBaseFile::available() const+0x40>
     c10:	movs	r0, #0
     c12:	movs	r1, #0
   * Zero is returned for directory files.
   *
   */
  int available() {
    uint64_t n = available64();
    return n > INT_MAX ? INT_MAX : n;
     c14:	movs	r3, #0
     c16:	mvn.w	r2, #2147483648	; 0x80000000
     c1a:	cmp	r3, r1
     c1c:	it	eq
     c1e:	cmpeq	r2, r0
     c20:	bcs.n	c26 <FsBaseFile::available() const+0x52>
     c22:	mov	r0, r2
     c24:	pop	{r4, r5, pc}
  }
     c26:	pop	{r4, r5, pc}

00000c28 <StreamFile<FsBaseFile, unsigned long long>::available()>:
  StreamFile() {}

  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
     c28:	push	{r3, lr}
    return BaseFile::available();
     c2a:	adds	r0, #16
     c2c:	bl	bd4 <FsBaseFile::available() const>
  }
     c30:	pop	{r3, pc}

00000c32 <SDFile::available()>:
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
		return sdfatfile.peek();
	}
	virtual int available() {
     c32:	push	{r3, lr}

  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
    return BaseFile::available();
     c34:	adds	r0, #24
     c36:	bl	bd4 <FsBaseFile::available() const>
		return sdfatfile.available();
	}
     c3a:	pop	{r3, pc}

00000c3c <FsBaseFile::isDir() const>:
    return m_xFile ? m_xFile->isContiguous() : false;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  }
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_fFile ? m_fFile->isDir() :
     c3c:	ldr	r3, [r0, #56]	; 0x38
           m_xFile ? m_xFile->isDir() : false;
     c3e:	cbz	r3, c48 <FsBaseFile::isDir() const+0xc>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
    /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  /** \return True if this is a directory. */
  bool isDir() const {return m_attributes & FILE_ATTR_DIR;}
     c40:	ldrb	r3, [r3, #0]
     c42:	tst.w	r3, #112	; 0x70
     c46:	b.n	c54 <FsBaseFile::isDir() const+0x18>
     c48:	ldr	r0, [r0, #60]	; 0x3c
     c4a:	cbz	r0, c5a <FsBaseFile::isDir() const+0x1e>
   */
  bool isBusy();
  /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
  /** \return True if this is a directory. */
  bool isDir() const  {return m_attributes & FILE_ATTR_DIR;}
     c4c:	ldrb.w	r3, [r0, #49]	; 0x31
     c50:	tst.w	r3, #80	; 0x50
     c54:	ite	ne
     c56:	movne	r0, #1
     c58:	moveq	r0, #0
  }
     c5a:	bx	lr

00000c5c <SDFile::isDirectory()>:
				filename = &zeroterm;
			}
		}
		return filename;
	}
	virtual boolean isDirectory(void) {
     c5c:	push	{r3, lr}
  }
  /** This function reports if the current file is a directory or not.
  * \return true if the file is a directory.
  */
  bool isDirectory() {
    return BaseFile::isDir();
     c5e:	adds	r0, #24
     c60:	bl	c3c <FsBaseFile::isDir() const>
		return sdfatfile.isDirectory();
	}
     c64:	pop	{r3, pc}

00000c66 <SDFile::rewindDirectory()>:
	virtual File openNextFile(uint8_t mode=0) {
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
		return File();
	}
	virtual void rewindDirectory(void) {
     c66:	push	{r4, lr}
     c68:	mov	r4, r0
  int read() {
    return BaseFile::read();
  }
  /** Rewind a file if it is a directory */
  void rewindDirectory() {
    if (BaseFile::isDir()) {
     c6a:	adds	r0, #24
     c6c:	bl	c3c <FsBaseFile::isDir() const>
     c70:	cbz	r0, c8c <SDFile::rewindDirectory()+0x26>
    return m_fFile ? m_fFile->rename(dirFile->m_fFile, newPath) :
           m_xFile ? m_xFile->rename(dirFile->m_xFile, newPath) : false;
  }
  /** Set the file's current position to zero. */
  void rewind() {
    if (m_fFile) m_fFile->rewind();
     c72:	ldr	r0, [r4, #80]	; 0x50
     c74:	cbz	r0, c7c <SDFile::rewindDirectory()+0x16>
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
     c76:	movs	r1, #0
     c78:	bl	5fde <FatFile::seekSet(unsigned long)>
    if (m_xFile) m_xFile->rewind();
     c7c:	ldr	r0, [r4, #84]	; 0x54
     c7e:	cbz	r0, c8c <SDFile::rewindDirectory()+0x26>
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
     c80:	movs	r2, #0
     c82:	movs	r3, #0
		sdfatfile.rewindDirectory();
	}
     c84:	ldmia.w	sp!, {r4, lr}
     c88:	b.w	434c <ExFatFile::seekSet(unsigned long long)>
     c8c:	pop	{r4, pc}

00000c8e <FsBaseFile::isOpen() const>:
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     c8e:	ldr	r3, [r0, #56]	; 0x38
     c90:	cbnz	r3, c9c <FsBaseFile::isOpen() const+0xe>
     c92:	ldr	r0, [r0, #60]	; 0x3c
     c94:	adds	r0, #0
     c96:	it	ne
     c98:	movne	r0, #1
     c9a:	bx	lr
     c9c:	movs	r0, #1
     c9e:	bx	lr

00000ca0 <SDFile::close()>:
		return sdfatfile.curPosition();
	}
	virtual uint64_t size() {
		return sdfatfile.size();
	}
	virtual void close() {
     ca0:	push	{r4, lr}
     ca2:	mov	r4, r0
		if (filename) {
     ca4:	ldr	r0, [r0, #88]	; 0x58
     ca6:	cbz	r0, cb0 <SDFile::close()+0x10>
			free(filename);
     ca8:	bl	b328 <free>
			filename = nullptr;
     cac:	movs	r3, #0
     cae:	str	r3, [r4, #88]	; 0x58
		}
		if (sdfatfile.isOpen()) {
     cb0:	adds	r4, #24
     cb2:	mov	r0, r4
     cb4:	bl	c8e <FsBaseFile::isOpen() const>
     cb8:	cbz	r0, cc4 <SDFile::close()+0x24>
			sdfatfile.close();
     cba:	mov	r0, r4
		}
	}
     cbc:	ldmia.w	sp!, {r4, lr}
		if (filename) {
			free(filename);
			filename = nullptr;
		}
		if (sdfatfile.isOpen()) {
			sdfatfile.close();
     cc0:	b.w	74f4 <FsBaseFile::close()>
     cc4:	pop	{r4, pc}
     cc6:	Address 0x00000cc6 is out of bounds.


00000cc8 <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     cc8:	push	{r4, lr}
     cca:	ldr	r3, [pc, #24]	; (ce4 <SDFile::~SDFile()+0x1c>)
     ccc:	str	r3, [r0, #0]
     cce:	mov	r4, r0
		close();
     cd0:	bl	ca0 <SDFile::close()>
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     cd4:	ldr	r3, [pc, #16]	; (ce8 <SDFile::~SDFile()+0x20>)
     cd6:	str	r3, [r4, #8]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     cd8:	add.w	r0, r4, #24
     cdc:	bl	74f4 <FsBaseFile::close()>
	}
     ce0:	mov	r0, r4
     ce2:	pop	{r4, pc}
     ce4:	.word	0x000125a4
     ce8:	.word	0x00012530

00000cec <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     cec:	push	{r4, lr}
     cee:	mov	r4, r0
		close();
	}
     cf0:	bl	cc8 <SDFile::~SDFile()>
     cf4:	mov	r0, r4
     cf6:	movs	r1, #92	; 0x5c
     cf8:	bl	a3b8 <operator delete(void*, unsigned int)>
     cfc:	mov	r0, r4
     cfe:	pop	{r4, pc}

00000d00 <SDFile::isOpen()>:
		}
		if (sdfatfile.isOpen()) {
			sdfatfile.close();
		}
	}
	virtual bool isOpen() {
     d00:	push	{r3, lr}
		return sdfatfile.isOpen();
     d02:	adds	r0, #24
     d04:	bl	c8e <FsBaseFile::isOpen() const>
	}
     d08:	pop	{r3, pc}

00000d0a <FsBaseFile::peek()>:
  uint64_t position() const {return curPosition();}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
     d0a:	mov	r3, r0
    return m_fFile ? m_fFile->peek() :
     d0c:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->peek() : -1;
     d0e:	cbz	r0, d14 <FsBaseFile::peek()+0xa>
     d10:	b.w	5f7c <FatFile::peek()>
     d14:	ldr	r0, [r3, #60]	; 0x3c
     d16:	cbz	r0, d1c <FsBaseFile::peek()+0x12>
     d18:	b.w	4320 <ExFatFile::peek()>
  }
     d1c:	mov.w	r0, #4294967295
     d20:	bx	lr

00000d22 <StreamFile<FsBaseFile, unsigned long long>::peek()>:
  const char* name() const {return "use getName()";}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
     d22:	push	{r3, lr}
    return BaseFile::peek();
     d24:	adds	r0, #16
     d26:	bl	d0a <FsBaseFile::peek()>
  }
     d2a:	pop	{r3, pc}

00000d2c <SDFile::peek()>:
		close();
	}
	virtual size_t write(const void *buf, size_t size) {
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
     d2c:	push	{r3, lr}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    return BaseFile::peek();
     d2e:	adds	r0, #24
     d30:	bl	d0a <FsBaseFile::peek()>
		return sdfatfile.peek();
	}
     d34:	pop	{r3, pc}

00000d36 <FsBaseFile::read(void*, unsigned int)>:
   * if end of file is reached.
   * If an error occurs, read() returns -1.  Possible errors include
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
     d36:	mov	r3, r0
    return m_fFile ? m_fFile->read(buf, count) :
     d38:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->read(buf, count) : -1;
     d3a:	cbz	r0, d40 <FsBaseFile::read(void*, unsigned int)+0xa>
     d3c:	b.w	5e04 <FatFile::read(void*, unsigned int)>
     d40:	ldr	r0, [r3, #60]	; 0x3c
     d42:	cbz	r0, d48 <FsBaseFile::read(void*, unsigned int)+0x12>
     d44:	b.w	419c <ExFatFile::read(void*, unsigned int)>
  }
     d48:	mov.w	r0, #4294967295
     d4c:	bx	lr

00000d4e <StreamFile<FsBaseFile, unsigned long long>::read()>:
  /** Read the next byte from a file.
   *
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
     d4e:	push	{r0, r1, r2, lr}
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
     d50:	movs	r2, #1
     d52:	add.w	r1, sp, #7
     d56:	adds	r0, #16
     d58:	bl	d36 <FsBaseFile::read(void*, unsigned int)>
     d5c:	cmp	r0, #1
     d5e:	ite	eq
     d60:	ldrbeq.w	r0, [sp, #7]
     d64:	movne.w	r0, #4294967295
    return BaseFile::read();
  }
     d68:	add	sp, #12
     d6a:	ldr.w	pc, [sp], #4

00000d6e <SDFile::read(void*, unsigned int)>:
		return sdfatfile.available();
	}
	virtual void flush() {
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
     d6e:	push	{r3, lr}
		return sdfatfile.read(buf, nbyte);
     d70:	adds	r0, #24
     d72:	bl	d36 <FsBaseFile::read(void*, unsigned int)>
	}
     d76:	pop	{r3, pc}

00000d78 <FsBaseFile::seekSet(unsigned long long)>:
   *
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
     d78:	push	{r4, r6, r7}
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     d7a:	ldr	r4, [r0, #56]	; 0x38
           m_xFile ? m_xFile->seekSet(pos) : false;
     d7c:	cbz	r4, d90 <FsBaseFile::seekSet(unsigned long long)+0x18>
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     d7e:	cmp	r3, #1
     d80:	it	eq
     d82:	cmpeq	r2, #0
     d84:	bcs.n	d9a <FsBaseFile::seekSet(unsigned long long)+0x22>
     d86:	mov	r0, r4
     d88:	mov	r1, r2
           m_xFile ? m_xFile->seekSet(pos) : false;
  }
     d8a:	pop	{r4, r6, r7}
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     d8c:	b.w	5fde <FatFile::seekSet(unsigned long)>
           m_xFile ? m_xFile->seekSet(pos) : false;
     d90:	ldr	r0, [r0, #60]	; 0x3c
     d92:	cbz	r0, d9a <FsBaseFile::seekSet(unsigned long long)+0x22>
  }
     d94:	pop	{r4, r6, r7}
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     d96:	b.w	434c <ExFatFile::seekSet(unsigned long long)>
  }
     d9a:	movs	r0, #0
     d9c:	pop	{r4, r6, r7}
     d9e:	bx	lr

00000da0 <SDFile::seek(unsigned long long, int)>:
	virtual bool truncate(uint64_t size=0) {
		return sdfatfile.truncate(size);
	}
	virtual bool seek(uint64_t pos, int mode = SeekSet) {
     da0:	push	{r3, r4, r5, lr}
     da2:	mov	r1, r0
     da4:	ldr	r0, [sp, #16]
     da6:	mov	r4, r2
     da8:	mov	r5, r3
		if (mode == SeekSet) return sdfatfile.seekSet(pos);
     daa:	cbnz	r0, db2 <SDFile::seek(unsigned long long, int)+0x12>
     dac:	add.w	r0, r1, #24
     db0:	b.n	dee <SDFile::seek(unsigned long long, int)+0x4e>
		if (mode == SeekCur) return sdfatfile.seekCur(pos);
     db2:	cmp	r0, #1
     db4:	bne.n	dcc <SDFile::seek(unsigned long long, int)+0x2c>
    return m_fFile ? m_fFile->contiguousRange(bgnSector, endSector) :
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
     db6:	ldr	r3, [r1, #80]	; 0x50
     db8:	add.w	r0, r1, #24
           m_xFile ? m_xFile->curPosition() : 0;
     dbc:	cbz	r3, dc2 <SDFile::seek(unsigned long long, int)+0x22>
     dbe:	ldr	r2, [r3, #20]
     dc0:	b.n	de8 <SDFile::seek(unsigned long long, int)+0x48>
     dc2:	ldr	r3, [r1, #84]	; 0x54
     dc4:	cbz	r3, de6 <SDFile::seek(unsigned long long, int)+0x46>
   *
   * \return true for success or false for failure.
   */
  bool contiguousRange(uint32_t* bgnSector, uint32_t* endSector);
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {return m_curPosition;}
     dc6:	ldrd	r2, r3, [r3]
     dca:	b.n	dea <SDFile::seek(unsigned long long, int)+0x4a>
		if (mode == SeekEnd) return sdfatfile.seekEnd(pos);
     dcc:	cmp	r0, #2
     dce:	bne.n	df4 <SDFile::seek(unsigned long long, int)+0x54>
    return m_fFile ? m_fFile->fgets(str, num, delim) :
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
     dd0:	ldr	r3, [r1, #80]	; 0x50
     dd2:	add.w	r0, r1, #24
           m_xFile ? m_xFile->fileSize() : 0;
     dd6:	cbz	r3, ddc <SDFile::seek(unsigned long long, int)+0x3c>
     dd8:	ldr	r2, [r3, #28]
     dda:	b.n	de8 <SDFile::seek(unsigned long long, int)+0x48>
     ddc:	ldr	r3, [r1, #84]	; 0x54
     dde:	cbz	r3, de6 <SDFile::seek(unsigned long long, int)+0x46>
   * If no data is read, fgets() returns zero for EOF or -1 if an error
   * occurred.
   */
  int fgets(char* str, int num, char* delim = nullptr);
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {return m_validLength;}
     de0:	ldrd	r2, r3, [r3, #16]
     de4:	b.n	dea <SDFile::seek(unsigned long long, int)+0x4a>
     de6:	movs	r2, #0
     de8:	movs	r3, #0
   * Can't be used for directory files since file size is not defined.
   * \param[in] offset The new position in bytes from end-of-file.
   * \return true for success or false for failure.
   */
  bool seekEnd(int64_t offset = 0) {
    return seekSet(fileSize() + offset);
     dea:	adds	r2, r2, r4
     dec:	adcs	r3, r5
     dee:	bl	d78 <FsBaseFile::seekSet(unsigned long long)>
     df2:	pop	{r3, r4, r5, pc}
		return false;
     df4:	movs	r0, #0
	}
     df6:	pop	{r3, r4, r5, pc}

00000df8 <FsBaseFile::sync()>:
  /** The sync() call causes all modified data and directory fields
   * to be written to the storage device.
   *
   * \return true for success or false for failure.
   */
  bool sync() {
     df8:	mov	r3, r0
    return m_fFile ? m_fFile->sync() :
     dfa:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->sync() : false;
     dfc:	cbz	r0, e02 <FsBaseFile::sync()+0xa>
     dfe:	b.w	6234 <FatFile::sync()>
     e02:	ldr	r0, [r3, #60]	; 0x3c
     e04:	cbz	r0, e0a <FsBaseFile::sync()+0x12>
     e06:	b.w	4f64 <ExFatFile::sync()>
  }
     e0a:	bx	lr

00000e0c <StreamFile<FsBaseFile, unsigned long long>::flush()>:
   */
  int available() {
    return BaseFile::available();
  }
  /** Ensure that any bytes written to the file are saved to the SD card. */
  void flush() {
     e0c:	push	{r3, lr}
    BaseFile::sync();
     e0e:	adds	r0, #16
     e10:	bl	df8 <FsBaseFile::sync()>
     e14:	pop	{r3, pc}

00000e16 <SDFile::flush()>:
		return sdfatfile.peek();
	}
	virtual int available() {
		return sdfatfile.available();
	}
	virtual void flush() {
     e16:	push	{r3, lr}
     e18:	adds	r0, #24
     e1a:	bl	df8 <FsBaseFile::sync()>
     e1e:	pop	{r3, pc}

00000e20 <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
   * Modify and access timestamps may be overwritten if a date time callback
   * function has been set by dateTimeCallback().
   *
   * \return true for success or false for failure.
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
     e20:	push	{r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
     e22:	ldr.w	lr, [r0, #56]	; 0x38
   * Modify and access timestamps may be overwritten if a date time callback
   * function has been set by dateTimeCallback().
   *
   * \return true for success or false for failure.
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
     e26:	ldrb.w	r4, [sp, #20]
     e2a:	ldrb.w	r5, [sp, #24]
     e2e:	ldrb.w	r6, [sp, #28]
     e32:	ldrb.w	r7, [sp, #32]
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     e36:	cmp.w	lr, #0
     e3a:	beq.n	e4e <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x2e>
     e3c:	str	r7, [sp, #32]
     e3e:	str	r6, [sp, #28]
     e40:	str	r5, [sp, #24]
     e42:	str	r4, [sp, #20]
     e44:	mov	r0, lr
  }
     e46:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     e4a:	b.w	6728 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
     e4e:	ldr	r0, [r0, #60]	; 0x3c
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     e50:	cbz	r0, e62 <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x42>
     e52:	str	r7, [sp, #32]
     e54:	str	r6, [sp, #28]
     e56:	str	r5, [sp, #24]
     e58:	str	r4, [sp, #20]
  }
     e5a:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     e5e:	b.w	522c <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
  }
     e62:	pop	{r4, r5, r6, r7, pc}

00000e64 <SDFile::setModifyTime(DateTimeFields const&)>:
	virtual bool setCreateTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
	virtual bool setModifyTime(const DateTimeFields &tm) {
     e64:	push	{r0, r1, r2, r3, r4, lr}
		if (tm.year < 80 || tm.year > 207) return false;
     e66:	ldrb	r2, [r1, #6]
     e68:	sub.w	r3, r2, #80	; 0x50
     e6c:	lsls	r3, r3, #24
     e6e:	bmi.n	e94 <SDFile::setModifyTime(DateTimeFields const&)+0x30>
		return sdfatfile.timestamp(T_WRITE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
     e70:	ldrb	r4, [r1, #0]
     e72:	ldrb	r3, [r1, #5]
     e74:	str	r4, [sp, #12]
     e76:	ldrb	r4, [r1, #1]
     e78:	str	r4, [sp, #8]
     e7a:	ldrb	r4, [r1, #2]
     e7c:	str	r4, [sp, #4]
     e7e:	ldrb	r1, [r1, #4]
     e80:	str	r1, [sp, #0]
     e82:	adds	r3, #1
     e84:	uxtb	r3, r3
     e86:	addw	r2, r2, #1900	; 0x76c
     e8a:	movs	r1, #4
     e8c:	adds	r0, #24
     e8e:	bl	e20 <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
     e92:	b.n	e96 <SDFile::setModifyTime(DateTimeFields const&)+0x32>
		if (tm.year < 80 || tm.year > 207) return false;
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
	virtual bool setModifyTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
     e94:	movs	r0, #0
		return sdfatfile.timestamp(T_WRITE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
     e96:	add	sp, #16
     e98:	pop	{r4, pc}

00000e9a <SDFile::setCreateTime(DateTimeFields const&)>:
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
		tm.year = FS_YEAR(fat_date) - 1900;
		return true;
	}
	virtual bool setCreateTime(const DateTimeFields &tm) {
     e9a:	push	{r0, r1, r2, r3, r4, lr}
		if (tm.year < 80 || tm.year > 207) return false;
     e9c:	ldrb	r2, [r1, #6]
     e9e:	sub.w	r3, r2, #80	; 0x50
     ea2:	lsls	r3, r3, #24
     ea4:	bmi.n	eca <SDFile::setCreateTime(DateTimeFields const&)+0x30>
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
     ea6:	ldrb	r4, [r1, #0]
     ea8:	ldrb	r3, [r1, #5]
     eaa:	str	r4, [sp, #12]
     eac:	ldrb	r4, [r1, #1]
     eae:	str	r4, [sp, #8]
     eb0:	ldrb	r4, [r1, #2]
     eb2:	str	r4, [sp, #4]
     eb4:	ldrb	r1, [r1, #4]
     eb6:	str	r1, [sp, #0]
     eb8:	adds	r3, #1
     eba:	uxtb	r3, r3
     ebc:	addw	r2, r2, #1900	; 0x76c
     ec0:	movs	r1, #2
     ec2:	adds	r0, #24
     ec4:	bl	e20 <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
     ec8:	b.n	ecc <SDFile::setCreateTime(DateTimeFields const&)+0x32>
		tm.mon = FS_MONTH(fat_date) - 1;
		tm.year = FS_YEAR(fat_date) - 1900;
		return true;
	}
	virtual bool setCreateTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
     eca:	movs	r0, #0
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
     ecc:	add	sp, #16
     ece:	pop	{r4, pc}

00000ed0 <FsBaseFile::write(void const*, unsigned int)>:
   * \param[in] count Number of bytes to write.
   *
   * \return For success write() returns the number of bytes written, always
   * \a nbyte.  If an error occurs, write() returns zero and writeError is set.
   */
  size_t write(const void* buf, size_t count) {
     ed0:	mov	r3, r0
    return m_fFile ? m_fFile->write(buf, count) :
     ed2:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->write(buf, count) : 0;
     ed4:	cbz	r0, eda <FsBaseFile::write(void const*, unsigned int)+0xa>
     ed6:	b.w	6840 <FatFile::write(void const*, unsigned int)>
     eda:	ldr	r0, [r3, #60]	; 0x3c
     edc:	cbz	r0, ee2 <FsBaseFile::write(void const*, unsigned int)+0x12>
     ede:	b.w	53fc <ExFatFile::write(void const*, unsigned int)>
  }
     ee2:	bx	lr

00000ee4 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)>:
   * \param[in] size Number of bytes to write.
   *
   * \return For success write() returns the number of bytes written, always
   * \a size.
   */
  size_t write(const uint8_t* buffer, size_t size) {
     ee4:	push	{r3, lr}
    return BaseFile::write(buffer, size);
     ee6:	adds	r0, #16
     ee8:	bl	ed0 <FsBaseFile::write(void const*, unsigned int)>
  }
     eec:	pop	{r3, pc}

00000eee <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)>:
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {
     eee:	push	{r0, r1, r2, lr}
     ef0:	add	r3, sp, #8
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {return write(&b, 1);}
     ef2:	movs	r2, #1
     ef4:	strb.w	r1, [r3, #-1]!
     ef8:	adds	r0, #16
     efa:	mov	r1, r3
     efc:	bl	ed0 <FsBaseFile::write(void const*, unsigned int)>
    return BaseFile::write(b);
  }
     f00:	add	sp, #12
     f02:	ldr.w	pc, [sp], #4

00000f06 <SDFile::write(void const*, unsigned int)>:
	friend class SDClass;
public:
	virtual ~SDFile(void) {
		close();
	}
	virtual size_t write(const void *buf, size_t size) {
     f06:	push	{r3, lr}
		return sdfatfile.write(buf, size);
     f08:	adds	r0, #24
     f0a:	bl	ed0 <FsBaseFile::write(void const*, unsigned int)>
	}
     f0e:	pop	{r3, pc}

00000f10 <File::close()>:
		return (f) ? f->position() : 0;
	}
	uint64_t size() {
		return (f) ? f->size() : 0;
	}
	void close() {
     f10:	push	{r4, lr}
     f12:	mov	r4, r0
		if (f) {
     f14:	ldr	r0, [r0, #16]
     f16:	cbz	r0, f2a <File::close()+0x1a>
			f->close();
     f18:	ldr	r3, [r0, #0]
     f1a:	ldr	r3, [r3, #44]	; 0x2c
     f1c:	blx	r3
			dec_refcount();
     f1e:	add.w	r0, r4, #16
		}
	}
     f22:	ldmia.w	sp!, {r4, lr}
		return (f) ? f->size() : 0;
	}
	void close() {
		if (f) {
			f->close();
			dec_refcount();
     f26:	b.w	b50 <File::dec_refcount() [clone .isra.15]>
     f2a:	pop	{r4, pc}

00000f2c <SDFile::SDFile(FsFile const&)>:
	// Classes derived from File are never meant to be constructed
	// anywhere other than open() in the parent FS class and
	// openNextFile() while traversing a directory.
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
     f2c:	push	{r3, r4, r5, lr}
// FileImpl instances are automatically deleted when the last referencing
// File is closed or goes out of scope.  The refcount variable is meant to
// be maintained by File class instances, never access by FileImpl functions.
// The FileImpl functions are meant to be called only by use of File instances.
//
class FileImpl {
     f2e:	movs	r5, #0
     f30:	ldr	r3, [pc, #40]	; (f5c <SDFile::SDFile(FsFile const&)+0x30>)
     f32:	str	r5, [r0, #4]
     f34:	str	r3, [r0, #0]
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
     f36:	ldrb	r3, [r1, #4]
     f38:	strb	r3, [r0, #12]
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
     f3a:	ldr	r3, [pc, #36]	; (f60 <SDFile::SDFile(FsFile const&)+0x34>)
     f3c:	str	r3, [r0, #8]
     f3e:	ldr	r3, [r1, #8]
     f40:	str	r3, [r0, #16]
     f42:	ldrb	r3, [r1, #12]
     f44:	strb	r3, [r0, #20]
     f46:	mov	r4, r0
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     f48:	adds	r1, #16
     f4a:	adds	r0, #24
     f4c:	bl	7492 <FsBaseFile::FsBaseFile(FsBaseFile const&)>
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     f50:	ldr	r3, [pc, #16]	; (f64 <SDFile::SDFile(FsFile const&)+0x38>)
     f52:	str	r3, [r4, #8]
     f54:	str	r5, [r4, #88]	; 0x58
     f56:	mov	r0, r4
     f58:	pop	{r3, r4, r5, pc}
     f5a:	nop
     f5c:	.word	0x000125a4
     f60:	.word	0x0001250c
     f64:	.word	0x00012554

00000f68 <SDFile::openNextFile(unsigned char)>:
		return filename;
	}
	virtual boolean isDirectory(void) {
		return sdfatfile.isDirectory();
	}
	virtual File openNextFile(uint8_t mode=0) {
     f68:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     f6c:	sub	sp, #84	; 0x54
{
  public:
	constexpr Print() : write_error(0) {}
     f6e:	movs	r5, #0
     f70:	add.w	r8, sp, #80	; 0x50
     f74:	ldr	r3, [pc, #108]	; (fe4 <SDFile::openNextFile(unsigned char)+0x7c>)
     f76:	str.w	r3, [r8, #-80]!
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
     f7a:	mov	r2, r5
     f7c:	adds	r1, #24
     f7e:	mov	r4, r0
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     f80:	mov.w	r6, #1000	; 0x3e8
     f84:	add	r0, sp, #16
     f86:	strb.w	r5, [sp, #4]
     f8a:	str	r6, [sp, #8]
     f8c:	strb.w	r5, [sp, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
     f90:	str	r5, [sp, #72]	; 0x48
     f92:	str	r5, [sp, #76]	; 0x4c
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
     f94:	bl	759a <FsBaseFile::openNext(FsBaseFile*, int)>
  FsBaseFile& operator=(const FsBaseFile& from);
  /** The parenthesis operator.
    *
    * \return true if a file is open.
    */
  operator bool() const {return isOpen();}
     f98:	add	r0, sp, #16
     f9a:	bl	c8e <FsBaseFile::isOpen() const>
     f9e:	ldr.w	r9, [pc, #76]	; fec <SDFile::openNextFile(unsigned char)+0x84>
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
     fa2:	cbz	r0, fc6 <SDFile::openNextFile(unsigned char)+0x5e>
     fa4:	movs	r0, #92	; 0x5c
     fa6:	bl	a3b4 <operator new(unsigned int)>
     faa:	mov	r7, r0
     fac:	mov	r1, r8
     fae:	bl	f2c <SDFile::SDFile(FsFile const&)>
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
		if (f) f->refcount++;
     fb2:	ldr	r3, [r7, #4]
     fb4:	strb	r5, [r4, #4]
     fb6:	adds	r3, #1
     fb8:	str	r6, [r4, #8]
     fba:	strb	r5, [r4, #12]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
     fbc:	str.w	r9, [r4]
		f = file;
     fc0:	str	r7, [r4, #16]
		if (f) f->refcount++;
     fc2:	str	r3, [r7, #4]
     fc4:	b.n	fd2 <SDFile::openNextFile(unsigned char)+0x6a>
     fc6:	strb	r0, [r4, #4]
     fc8:	str	r6, [r4, #8]
     fca:	strb	r0, [r4, #12]
//
class File final : public Stream {
public:
	// Empty constructor, used when a program creates a File variable
	// but does not immediately assign or initialize it.
	constexpr File() : f(nullptr) { }
     fcc:	str.w	r9, [r4]
     fd0:	str	r0, [r4, #16]
     fd2:	ldr	r3, [pc, #20]	; (fe8 <SDFile::openNextFile(unsigned char)+0x80>)
     fd4:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     fd6:	add	r0, sp, #16
     fd8:	bl	74f4 <FsBaseFile::close()>
		return File();
	}
     fdc:	mov	r0, r4
     fde:	add	sp, #84	; 0x54
     fe0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     fe4:	.word	0x00012554
     fe8:	.word	0x00012530
     fec:	.word	0x00012578

00000ff0 <SDClass::open(char const*, unsigned char)>:
class SDClass : public FS
{
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
     ff0:	push	{r4, r5, r6, lr}
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     ff2:	cmp	r3, #1
class SDClass : public FS
{
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
     ff4:	sub	sp, #80	; 0x50
     ff6:	mov	r4, r0
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     ff8:	beq.n	1006 <SDClass::open(char const*, unsigned char)+0x16>
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
     ffa:	cmp	r3, #2
     ffc:	movw	r3, #514	; 0x202
    1000:	it	ne
    1002:	movne	r3, #0
    1004:	b.n	100a <SDClass::open(char const*, unsigned char)+0x1a>
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
    1006:	movw	r3, #16898	; 0x4202
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
    100a:	adds	r1, #4
    100c:	mov	r0, sp
    100e:	bl	76b4 <FsVolume::open(char const*, int)>
  FsBaseFile& operator=(const FsBaseFile& from);
  /** The parenthesis operator.
    *
    * \return true if a file is open.
    */
  operator bool() const {return isOpen();}
    1012:	add	r0, sp, #16
    1014:	bl	c8e <FsBaseFile::isOpen() const>
    1018:	ldr	r6, [pc, #68]	; (1060 <SDClass::open(char const*, unsigned char)+0x70>)
		if (file) return File(new SDFile(file));
    101a:	cbz	r0, 1042 <SDClass::open(char const*, unsigned char)+0x52>
    101c:	movs	r0, #92	; 0x5c
    101e:	bl	a3b4 <operator new(unsigned int)>
    1022:	mov	r1, sp
    1024:	mov	r5, r0
    1026:	bl	f2c <SDFile::SDFile(FsFile const&)>
    102a:	movs	r3, #0
    102c:	strb	r3, [r4, #4]
    102e:	strb	r3, [r4, #12]
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
		if (f) f->refcount++;
    1030:	ldr	r3, [r5, #4]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
    1032:	str	r6, [r4, #0]
    1034:	mov.w	r2, #1000	; 0x3e8
		f = file;
		if (f) f->refcount++;
    1038:	adds	r3, #1
    103a:	str	r2, [r4, #8]
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
    103c:	str	r5, [r4, #16]
		if (f) f->refcount++;
    103e:	str	r3, [r5, #4]
    1040:	b.n	1050 <SDClass::open(char const*, unsigned char)+0x60>
    1042:	mov.w	r3, #1000	; 0x3e8
    1046:	strb	r0, [r4, #4]
    1048:	str	r3, [r4, #8]
    104a:	strb	r0, [r4, #12]
//
class File final : public Stream {
public:
	// Empty constructor, used when a program creates a File variable
	// but does not immediately assign or initialize it.
	constexpr File() : f(nullptr) { }
    104c:	str	r6, [r4, #0]
    104e:	str	r0, [r4, #16]
    1050:	ldr	r3, [pc, #16]	; (1064 <SDClass::open(char const*, unsigned char)+0x74>)
    1052:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
    1054:	add	r0, sp, #16
    1056:	bl	74f4 <FsBaseFile::close()>
		return File();
	}
    105a:	mov	r0, r4
    105c:	add	sp, #80	; 0x50
    105e:	pop	{r4, r5, r6, pc}
    1060:	.word	0x00012578
    1064:	.word	0x00012530

00001068 <storeConfig(unsigned short*, int)>:
uint16_t store[16];

extern  int t_acq;

void storeConfig(uint16_t *store, int ns)
{ 
    1068:	push	{r4, r5, r6, lr}
    106a:	sub	sp, #56	; 0x38
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    106c:	ldr	r3, [pc, #120]	; (10e8 <storeConfig(unsigned short*, int)+0x80>)
    106e:	str	r3, [sp, #4]
    1070:	mov.w	r2, #1000	; 0x3e8
    1074:	movs	r3, #0
    1076:	strb.w	r3, [sp, #8]
    107a:	str	r2, [sp, #12]
    107c:	strb.w	r3, [sp, #16]
    1080:	str	r3, [sp, #20]
uint16_t store[16];

extern  int t_acq;

void storeConfig(uint16_t *store, int ns)
{ 
    1082:	mov	r5, r0
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    char text[32];
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
    1084:	movs	r3, #2
uint16_t store[16];

extern  int t_acq;

void storeConfig(uint16_t *store, int ns)
{ 
    1086:	mov	r6, r1
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    char text[32];
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
    1088:	ldr	r2, [pc, #96]	; (10ec <storeConfig(unsigned short*, int)+0x84>)
    108a:	ldr	r1, [pc, #100]	; (10f0 <storeConfig(unsigned short*, int)+0x88>)
    108c:	add	r0, sp, #24
    108e:	bl	ff0 <SDClass::open(char const*, unsigned char)>
	}
#ifdef FILE_USE_MOVE
	// Move assignment.
	File& operator = (const File&& file) {
		//Serial.println("File move assignment");
		if (file.f) file.f->refcount++;
    1092:	ldr	r3, [sp, #40]	; 0x28
    1094:	cbz	r3, 109c <storeConfig(unsigned short*, int)+0x34>
    1096:	ldr	r2, [r3, #4]
    1098:	adds	r2, #1
    109a:	str	r2, [r3, #4]
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
    109c:	ldr	r3, [sp, #20]
    109e:	cbz	r3, 10a6 <storeConfig(unsigned short*, int)+0x3e>
    10a0:	add	r0, sp, #20
    10a2:	bl	b50 <File::dec_refcount() [clone .isra.15]>
		f = file.f;
    10a6:	ldr	r3, [sp, #40]	; 0x28
    10a8:	str	r3, [sp, #20]
    10aa:	add	r0, sp, #24
    10ac:	bl	b74 <File::~File()>
      for(int ii=0; ii<ns; ii++)
    10b0:	movs	r4, #0
    10b2:	cmp	r4, r6
    10b4:	bge.n	10d6 <storeConfig(unsigned short*, int)+0x6e>
      { sprintf(text,"%10d\r\n",(int) store[ii]); configFile.write((uint8_t*)text,strlen(text)); }
    10b6:	ldrh.w	r2, [r5, r4, lsl #1]
    10ba:	ldr	r1, [pc, #56]	; (10f4 <storeConfig(unsigned short*, int)+0x8c>)
    10bc:	add	r0, sp, #24
    10be:	bl	beb8 <sprintf>
    10c2:	add	r0, sp, #24
    10c4:	bl	bf80 <strlen>
    10c8:	add	r1, sp, #24
    10ca:	mov	r2, r0
    10cc:	add	r0, sp, #4
    10ce:	bl	992 <File::write(unsigned char const*, unsigned int)>
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    char text[32];
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
      for(int ii=0; ii<ns; ii++)
    10d2:	adds	r4, #1
    10d4:	b.n	10b2 <storeConfig(unsigned short*, int)+0x4a>
      { sprintf(text,"%10d\r\n",(int) store[ii]); configFile.write((uint8_t*)text,strlen(text)); }
    configFile.close();
    10d6:	add	r0, sp, #4
    10d8:	bl	f10 <File::close()>

void storeConfig(uint16_t *store, int ns)
{ 
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    10dc:	add	r0, sp, #4
    10de:	bl	b74 <File::~File()>
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
      for(int ii=0; ii<ns; ii++)
      { sprintf(text,"%10d\r\n",(int) store[ii]); configFile.write((uint8_t*)text,strlen(text)); }
    configFile.close();
  
}
    10e2:	add	sp, #56	; 0x38
    10e4:	pop	{r4, r5, r6, pc}
    10e6:	nop
    10e8:	.word	0x00012578
    10ec:	.word	0x000125f8
    10f0:	.word	0x20017c38
    10f4:	.word	0x00012604

000010f8 <saveParameters()>:
    configFile.close();
}

void saveParameters(void)
{
  store[0]= 1;
    10f8:	ldr	r0, [pc, #16]	; (110c <saveParameters()+0x14>)
    10fa:	movs	r3, #1
    10fc:	strh	r3, [r0, #0]
  store[2]= t_acq;
    10fe:	ldr	r3, [pc, #16]	; (1110 <saveParameters()+0x18>)

  storeConfig(store, 16);
    1100:	movs	r1, #16
}

void saveParameters(void)
{
  store[0]= 1;
  store[2]= t_acq;
    1102:	ldr	r3, [r3, #0]
    1104:	strh	r3, [r0, #4]

  storeConfig(store, 16);
    1106:	b.w	1068 <storeConfig(unsigned short*, int)>
    110a:	nop
    110c:	.word	0x1fff21ea
    1110:	.word	0x1fff0f34

00001114 <printMenu()>:
  }
}


void printMenu(void)
{
    1114:	push	{r4, lr}
  Serial.println("\n Menu");
    1116:	ldr	r4, [pc, #144]	; (11a8 <printMenu()+0x94>)
    1118:	ldr	r1, [pc, #144]	; (11ac <printMenu()+0x98>)
    111a:	mov	r0, r4
    111c:	bl	758 <Print::println(char const*)>
  Serial.println(" ':h'  : print help");
    1120:	ldr	r1, [pc, #140]	; (11b0 <printMenu()+0x9c>)
    1122:	mov	r0, r4
    1124:	bl	758 <Print::println(char const*)>
  Serial.println(" ':s'  : start acquisition");
    1128:	ldr	r1, [pc, #136]	; (11b4 <printMenu()+0xa0>)
    112a:	mov	r0, r4
    112c:	bl	758 <Print::println(char const*)>
  Serial.println(" ':e'  : stop acquisition");
    1130:	ldr	r1, [pc, #132]	; (11b8 <printMenu()+0xa4>)
    1132:	mov	r0, r4
    1134:	bl	758 <Print::println(char const*)>
  Serial.println(" ':w'  : write parameters to microSD card");
    1138:	ldr	r1, [pc, #128]	; (11bc <printMenu()+0xa8>)
    113a:	mov	r0, r4
    113c:	bl	758 <Print::println(char const*)>
  Serial.println(" ':l'  : list disks");
    1140:	ldr	r1, [pc, #124]	; (11c0 <printMenu()+0xac>)
    1142:	mov	r0, r4
    1144:	bl	758 <Print::println(char const*)>
  Serial.println(" ':r'  : reset MTP");
    1148:	ldr	r1, [pc, #120]	; (11c4 <printMenu()+0xb0>)
    114a:	mov	r0, r4
    114c:	bl	758 <Print::println(char const*)>
  Serial.println(" ':b'  : reboot CPU");
    1150:	ldr	r1, [pc, #116]	; (11c8 <printMenu()+0xb4>)
    1152:	mov	r0, r4
    1154:	bl	758 <Print::println(char const*)>
//  Serial.println(" ':d'  : dump Index List (testing)");
  Serial.println();
    1158:	mov	r0, r4
    115a:	bl	a1bc <Print::println()>
  Serial.println(" '?p'  : show all parameters");
    115e:	ldr	r1, [pc, #108]	; (11cc <printMenu()+0xb8>)
    1160:	mov	r0, r4
    1162:	bl	758 <Print::println(char const*)>
  Serial.println(" '?d'  : get date");
    1166:	ldr	r1, [pc, #104]	; (11d0 <printMenu()+0xbc>)
    1168:	mov	r0, r4
    116a:	bl	758 <Print::println(char const*)>
  Serial.println(" '?t'  : get time");
    116e:	ldr	r1, [pc, #100]	; (11d4 <printMenu()+0xc0>)
    1170:	mov	r0, r4
    1172:	bl	758 <Print::println(char const*)>
  Serial.println(" '?a'  : get file duration (s)");
    1176:	ldr	r1, [pc, #96]	; (11d8 <printMenu()+0xc4>)
    1178:	mov	r0, r4
    117a:	bl	758 <Print::println(char const*)>
  Serial.println();
    117e:	mov	r0, r4
    1180:	bl	a1bc <Print::println()>
  Serial.println(" '!d yyyy/mm/dd<cr>'  : set date");
    1184:	ldr	r1, [pc, #84]	; (11dc <printMenu()+0xc8>)
    1186:	mov	r0, r4
    1188:	bl	758 <Print::println(char const*)>
  Serial.println(" '!t hh:mm:ss<cr>'    : set time");
    118c:	ldr	r1, [pc, #80]	; (11e0 <printMenu()+0xcc>)
    118e:	mov	r0, r4
    1190:	bl	758 <Print::println(char const*)>
  Serial.println(" '!a val<cr>'  : set file duration (s)");
    1194:	mov	r0, r4
    1196:	ldr	r1, [pc, #76]	; (11e4 <printMenu()+0xd0>)
    1198:	bl	758 <Print::println(char const*)>
  Serial.println();
    119c:	mov	r0, r4
}
    119e:	ldmia.w	sp!, {r4, lr}
  Serial.println(" '?a'  : get file duration (s)");
  Serial.println();
  Serial.println(" '!d yyyy/mm/dd<cr>'  : set date");
  Serial.println(" '!t hh:mm:ss<cr>'    : set time");
  Serial.println(" '!a val<cr>'  : set file duration (s)");
  Serial.println();
    11a2:	b.w	a1bc <Print::println()>
    11a6:	nop
    11a8:	.word	0x1fff1348
    11ac:	.word	0x0001260b
    11b0:	.word	0x00012612
    11b4:	.word	0x00012626
    11b8:	.word	0x00012641
    11bc:	.word	0x0001265b
    11c0:	.word	0x00012685
    11c4:	.word	0x00012699
    11c8:	.word	0x000126ac
    11cc:	.word	0x000126c0
    11d0:	.word	0x000126dd
    11d4:	.word	0x000126ef
    11d8:	.word	0x00012701
    11dc:	.word	0x00012720
    11e0:	.word	0x00012741
    11e4:	.word	0x00012762

000011e8 <printMenuEntries()>:
}

void printMenuEntries(void)
{
    11e8:	push	{r0, r1, r2, r3, r4, lr}
    tmElements_t tm;
    breakTime(rtc_get(), tm);

  Serial.println("CVAS_V3 Version: " __DATE__  " " __TIME__ );
    11ea:	ldr	r4, [pc, #96]	; (124c <printMenuEntries()+0x64>)
}

void printMenuEntries(void)
{
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    11ec:	bl	9440 <rtc_get>
    11f0:	add	r1, sp, #8
    11f2:	bl	153c <breakTime(unsigned long, tmElements_t&)>

  Serial.println("CVAS_V3 Version: " __DATE__  " " __TIME__ );
    11f6:	ldr	r1, [pc, #88]	; (1250 <printMenuEntries()+0x68>)
    11f8:	mov	r0, r4
    11fa:	bl	758 <Print::println(char const*)>
  Serial.printf("Teensy: %d: %06x\n",teensy,SerNum);
    11fe:	ldr	r3, [pc, #84]	; (1254 <printMenuEntries()+0x6c>)
    1200:	ldr	r1, [pc, #84]	; (1258 <printMenuEntries()+0x70>)
    1202:	ldr	r3, [r3, #0]
    1204:	movs	r2, #36	; 0x24
    1206:	mov	r0, r4
    1208:	bl	a1dc <Print::printf(char const*, ...)>
  Serial.printf("Date d = %04d/%02d/%02d\n",tmYearToCalendar(tm.Year), tm.Month, tm.Day); 
    120c:	ldrb.w	r2, [sp, #14]
    1210:	ldrb.w	r1, [sp, #12]
    1214:	ldrb.w	r3, [sp, #13]
    1218:	str	r1, [sp, #0]
    121a:	addw	r2, r2, #1970	; 0x7b2
    121e:	ldr	r1, [pc, #60]	; (125c <printMenuEntries()+0x74>)
    1220:	mov	r0, r4
    1222:	bl	a1dc <Print::printf(char const*, ...)>
  Serial.printf("Time t = %02d:%02d:%02d\n",tm.Hour, tm.Minute, tm.Second); 
    1226:	ldrb.w	r1, [sp, #8]
    122a:	ldrb.w	r3, [sp, #9]
    122e:	ldrb.w	r2, [sp, #10]
    1232:	str	r1, [sp, #0]
    1234:	mov	r0, r4
    1236:	ldr	r1, [pc, #40]	; (1260 <printMenuEntries()+0x78>)
    1238:	bl	a1dc <Print::printf(char const*, ...)>
  Serial.printf("T_acq a = %d\n",t_acq); 
    123c:	ldr	r3, [pc, #36]	; (1264 <printMenuEntries()+0x7c>)
    123e:	ldr	r1, [pc, #40]	; (1268 <printMenuEntries()+0x80>)
    1240:	ldr	r2, [r3, #0]
    1242:	mov	r0, r4
    1244:	bl	a1dc <Print::printf(char const*, ...)>
}
    1248:	add	sp, #16
    124a:	pop	{r4, pc}
    124c:	.word	0x1fff1348
    1250:	.word	0x00012789
    1254:	.word	0x1fff220c
    1258:	.word	0x000127af
    125c:	.word	0x000127c1
    1260:	.word	0x000127da
    1264:	.word	0x1fff0f34
    1268:	.word	0x000127f3

0000126c <menuGetInt(int*)>:

int menuGetInt(int *val)
{ char buffer[40];
    126c:	push	{r4, lr}
    126e:	mov	r4, r0
    1270:	sub	sp, #40	; 0x28
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    1272:	bl	9184 <usb_serial_available>
  while(!Serial.available());
    1276:	cmp	r0, #0
    1278:	beq.n	1272 <menuGetInt(int*)+0x6>
  int count = Serial.readBytesUntil('\r',buffer,40);
    127a:	mov	r2, sp
    127c:	movs	r3, #40	; 0x28
    127e:	movs	r1, #13
    1280:	ldr	r0, [pc, #28]	; (12a0 <menuGetInt(int*)+0x34>)
    1282:	bl	a36c <Stream::readBytesUntil(char, char*, unsigned int)>
  buffer[count]=0;
    1286:	add	r3, sp, #40	; 0x28
    1288:	add	r0, r3
    128a:	movs	r3, #0
    128c:	strb.w	r3, [r0, #-40]
//  Serial.println(buffer);
  return sscanf(buffer,"%d",val);
    1290:	mov	r2, r4
    1292:	ldr	r1, [pc, #16]	; (12a4 <menuGetInt(int*)+0x38>)
    1294:	mov	r0, sp
    1296:	bl	bf04 <sscanf>
}
    129a:	add	sp, #40	; 0x28
    129c:	pop	{r4, pc}
    129e:	nop
    12a0:	.word	0x1fff1348
    12a4:	.word	0x00012880

000012a8 <menuGet3Int(int*, int*, int*)>:

int menuGet3Int(int *val1, int *val2, int *val3)
{ char buffer[40];
    12a8:	push	{r4, r5, r6, lr}
    12aa:	mov	r4, r0
    12ac:	sub	sp, #64	; 0x40
    12ae:	mov	r5, r1
    12b0:	mov	r6, r2
    12b2:	bl	9184 <usb_serial_available>
  while(!Serial.available());
    12b6:	cmp	r0, #0
    12b8:	beq.n	12b2 <menuGet3Int(int*, int*, int*)+0xa>
  int count = Serial.readBytesUntil('\r',buffer,40);
    12ba:	add	r2, sp, #24
    12bc:	movs	r3, #40	; 0x28
    12be:	movs	r1, #13
    12c0:	ldr	r0, [pc, #40]	; (12ec <menuGet3Int(int*, int*, int*)+0x44>)
    12c2:	bl	a36c <Stream::readBytesUntil(char, char*, unsigned int)>
  buffer[count]=0;
    12c6:	add	r3, sp, #64	; 0x40
    12c8:	add	r0, r3
    12ca:	movs	r3, #0
    12cc:	strb.w	r3, [r0, #-40]
//  Serial.println(buffer);
  char c1,c2;
  return sscanf(buffer,"%d%c%d%c%d",val1,&c1,val2,&c2,val3);
    12d0:	add.w	r3, sp, #23
    12d4:	str	r3, [sp, #4]
    12d6:	str	r6, [sp, #8]
    12d8:	str	r5, [sp, #0]
    12da:	add.w	r3, sp, #22
    12de:	mov	r2, r4
    12e0:	ldr	r1, [pc, #12]	; (12f0 <menuGet3Int(int*, int*, int*)+0x48>)
    12e2:	add	r0, sp, #24
    12e4:	bl	bf04 <sscanf>
}
    12e8:	add	sp, #64	; 0x40
    12ea:	pop	{r4, r5, r6, pc}
    12ec:	.word	0x1fff1348
    12f0:	.word	0x00012801

000012f4 <menu()>:
#if defined (KINETISK) 
#define CPU_RESTART 
#endif

int16_t menu(void)
{
    12f4:	push	{r4, lr}
    12f6:	sub	sp, #32
    12f8:	bl	9184 <usb_serial_available>
  if(!Serial.available()) return 0;
    12fc:	cmp	r0, #0
    12fe:	beq.w	147c <menu()+0x188>
        virtual int read() { return usb_serial_getchar(); }
    1302:	bl	9100 <usb_serial_getchar>

  char ch=Serial.read();
    1306:	uxtb	r0, r0
  if(ch==':')
    1308:	cmp	r0, #58	; 0x3a
    130a:	bne.n	138c <menu()+0x98>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    130c:	bl	9184 <usb_serial_available>
  { while(!Serial.available()) ; ch=Serial.read();
    1310:	cmp	r0, #0
    1312:	beq.n	130c <menu()+0x18>
        virtual int read() { return usb_serial_getchar(); }
    1314:	bl	9100 <usb_serial_getchar>
    1318:	uxtb	r0, r0

    if(ch=='s') { Serial.print("\n"); Serial.print("start"); return  +1;} // start acq
    131a:	cmp	r0, #115	; 0x73
    131c:	bne.n	1332 <menu()+0x3e>
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
    131e:	ldr	r1, [pc, #356]	; (1484 <menu()+0x190>)
    1320:	ldr	r0, [pc, #356]	; (1488 <menu()+0x194>)
    1322:	bl	734 <Print::write(char const*)>
    1326:	ldr	r1, [pc, #356]	; (148c <menu()+0x198>)
    1328:	ldr	r0, [pc, #348]	; (1488 <menu()+0x194>)
    132a:	bl	734 <Print::write(char const*)>
    132e:	movs	r0, #1
    1330:	b.n	147e <menu()+0x18a>
    else if(ch=='e') { Serial.print("\n"); Serial.print("stop");  return  -1;} // end acq
    1332:	cmp	r0, #101	; 0x65
    1334:	bne.n	134c <menu()+0x58>
    1336:	ldr	r1, [pc, #332]	; (1484 <menu()+0x190>)
    1338:	ldr	r0, [pc, #332]	; (1488 <menu()+0x194>)
    133a:	bl	734 <Print::write(char const*)>
    133e:	ldr	r1, [pc, #336]	; (1490 <menu()+0x19c>)
    1340:	ldr	r0, [pc, #324]	; (1488 <menu()+0x194>)
    1342:	bl	734 <Print::write(char const*)>
    1346:	mov.w	r0, #4294967295
    134a:	b.n	147e <menu()+0x18a>
    else if(ch=='h') { printMenu(); return 0;} 
    134c:	cmp	r0, #104	; 0x68
    134e:	bne.n	1356 <menu()+0x62>
    1350:	bl	1114 <printMenu()>
    1354:	b.n	147c <menu()+0x188>
    else if(ch=='w') { saveParameters(); return 0;} 
    1356:	cmp	r0, #119	; 0x77
    1358:	bne.n	1360 <menu()+0x6c>
    135a:	bl	10f8 <saveParameters()>
    135e:	b.n	147c <menu()+0x188>
    else if(ch=='l') { listDisks(); return 0;} 
    1360:	cmp	r0, #108	; 0x6c
    1362:	bne.n	136a <menu()+0x76>
    1364:	bl	1dac <listDisks()>
    1368:	b.n	147c <menu()+0x188>
    else if(ch=='b') { Serial.print("\n"); Serial.print("rebooting CPU"); Serial.flush(); delay(100); CPU_RESTART; return 0;} 
    136a:	cmp	r0, #98	; 0x62
    136c:	bne.w	147c <menu()+0x188>
    1370:	ldr	r1, [pc, #272]	; (1484 <menu()+0x190>)
    1372:	ldr	r0, [pc, #276]	; (1488 <menu()+0x194>)
    1374:	bl	734 <Print::write(char const*)>
    1378:	ldr	r1, [pc, #280]	; (1494 <menu()+0x1a0>)
    137a:	ldr	r0, [pc, #268]	; (1488 <menu()+0x194>)
    137c:	bl	734 <Print::write(char const*)>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    1380:	bl	9310 <usb_serial_flush_output>
    1384:	movs	r0, #100	; 0x64
    1386:	bl	9550 <delay>
    138a:	b.n	147c <menu()+0x188>
  }
  else if(ch=='?') // get info
    138c:	cmp	r0, #63	; 0x3f
    138e:	bne.n	13fa <menu()+0x106>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    1390:	bl	9184 <usb_serial_available>
  {
    while(!Serial.available()) ; ch=Serial.read();
    1394:	cmp	r0, #0
    1396:	beq.n	1390 <menu()+0x9c>
        virtual int read() { return usb_serial_getchar(); }
    1398:	bl	9100 <usb_serial_getchar>
    139c:	uxtb	r4, r0

    tmElements_t tm;
    breakTime(rtc_get(), tm);
    139e:	bl	9440 <rtc_get>
    13a2:	add	r1, sp, #24
    13a4:	bl	153c <breakTime(unsigned long, tmElements_t&)>

    if(ch=='p') { printMenuEntries(); return 0;} 
    13a8:	cmp	r4, #112	; 0x70
    13aa:	bne.n	13b2 <menu()+0xbe>
    13ac:	bl	11e8 <printMenuEntries()>
    13b0:	b.n	147c <menu()+0x188>
    else if(ch=='d') { Serial.printf("%04d/%02d/%02d\n",tmYearToCalendar(tm.Year), tm.Month, tm.Day); return  0;} // display date
    13b2:	cmp	r4, #100	; 0x64
    13b4:	bne.n	13cc <menu()+0xd8>
    13b6:	ldrb.w	r2, [sp, #30]
    13ba:	ldrb.w	r1, [sp, #28]
    13be:	str	r1, [sp, #0]
    13c0:	ldrb.w	r3, [sp, #29]
    13c4:	ldr	r1, [pc, #208]	; (1498 <menu()+0x1a4>)
    13c6:	addw	r2, r2, #1970	; 0x7b2
    13ca:	b.n	13e0 <menu()+0xec>
    else if(ch=='t') { Serial.printf("%02d:%02d:%02d\n",tm.Hour, tm.Minute, tm.Second); return  0;} // display time
    13cc:	cmp	r4, #116	; 0x74
    13ce:	bne.n	13e8 <menu()+0xf4>
    13d0:	ldrb.w	r1, [sp, #24]
    13d4:	str	r1, [sp, #0]
    13d6:	ldrb.w	r3, [sp, #25]
    13da:	ldrb.w	r2, [sp, #26]
    13de:	ldr	r1, [pc, #188]	; (149c <menu()+0x1a8>)
    13e0:	ldr	r0, [pc, #164]	; (1488 <menu()+0x194>)
    13e2:	bl	a1dc <Print::printf(char const*, ...)>
    13e6:	b.n	147c <menu()+0x188>
    else if(ch=='a') { Serial.printf("%d\n",t_acq); return  0;} // file size
    13e8:	cmp	r4, #97	; 0x61
    13ea:	bne.n	147c <menu()+0x188>
    13ec:	ldr	r3, [pc, #176]	; (14a0 <menu()+0x1ac>)
    13ee:	ldr	r1, [pc, #180]	; (14a4 <menu()+0x1b0>)
    13f0:	ldr	r2, [r3, #0]
    13f2:	ldr	r0, [pc, #148]	; (1488 <menu()+0x194>)
    13f4:	bl	a1dc <Print::printf(char const*, ...)>
    13f8:	b.n	147c <menu()+0x188>
  }
  else if(ch=='!') // set 
    13fa:	cmp	r0, #33	; 0x21
    13fc:	bne.n	147c <menu()+0x188>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    13fe:	bl	9184 <usb_serial_available>
  { 
    while(!Serial.available()) ;
    1402:	cmp	r0, #0
    1404:	beq.n	13fe <menu()+0x10a>
        virtual int read() { return usb_serial_getchar(); }
    1406:	bl	9100 <usb_serial_getchar>
    ch=Serial.read();
    140a:	uxtb	r0, r0
    if(ch=='d') // set date
    140c:	cmp	r0, #100	; 0x64
    140e:	bne.n	143c <menu()+0x148>
    { int year,month,day;
      menuGet3Int(&year,&month,&day);
    1410:	add	r2, sp, #20
    1412:	add	r1, sp, #16
    1414:	add	r0, sp, #12
    1416:	bl	12a8 <menuGet3Int(int*, int*, int*)>
      tmElements_t tm;
      breakTime(rtc_get(), tm);
    141a:	bl	9440 <rtc_get>
    141e:	add	r1, sp, #24
    1420:	bl	153c <breakTime(unsigned long, tmElements_t&)>

      setRTCTime(tm.Hour, tm.Minute, tm.Second, day, month, year);
    1424:	ldr	r3, [sp, #12]
    1426:	str	r3, [sp, #4]
    1428:	ldr	r3, [sp, #16]
    142a:	str	r3, [sp, #0]
    142c:	ldrb.w	r2, [sp, #24]
    1430:	ldrb.w	r1, [sp, #25]
    1434:	ldrb.w	r0, [sp, #26]
    1438:	ldr	r3, [sp, #20]
    143a:	b.n	146c <menu()+0x178>
      return  0;
    } 
    else if(ch=='t') // set time
    143c:	cmp	r0, #116	; 0x74
    143e:	bne.n	1472 <menu()+0x17e>
    { int hour,minutes,seconds;
      menuGet3Int(&hour,&minutes,&seconds);
    1440:	add	r2, sp, #20
    1442:	add	r1, sp, #16
    1444:	add	r0, sp, #12
    1446:	bl	12a8 <menuGet3Int(int*, int*, int*)>

      tmElements_t tm;
      breakTime(rtc_get(), tm);
    144a:	bl	9440 <rtc_get>
    144e:	add	r1, sp, #24
    1450:	bl	153c <breakTime(unsigned long, tmElements_t&)>
      setRTCTime(hour, minutes, seconds, tm.Day, tm.Month, tmYearToCalendar(tm.Year));
    1454:	ldrb.w	r2, [sp, #30]
    1458:	ldrb.w	r3, [sp, #28]
    145c:	addw	r2, r2, #1970	; 0x7b2
    1460:	str	r2, [sp, #4]
    1462:	ldrb.w	r2, [sp, #29]
    1466:	str	r2, [sp, #0]
    1468:	add	r0, sp, #12
    146a:	ldmia	r0, {r0, r1, r2}
    146c:	bl	1728 <setRTCTime(int, int, int, int, int, int)>
    1470:	b.n	147c <menu()+0x188>
      return  0;
    } 
    else if(ch=='a') { menuGetInt(&t_acq); return  0;} // file size
    1472:	cmp	r0, #97	; 0x61
    1474:	bne.n	147c <menu()+0x188>
    1476:	ldr	r0, [pc, #40]	; (14a0 <menu()+0x1ac>)
    1478:	bl	126c <menuGetInt(int*)>
    147c:	movs	r0, #0
  }
  return 0;
}
    147e:	add	sp, #32
    1480:	pop	{r4, pc}
    1482:	nop
    1484:	.word	0x00012da8
    1488:	.word	0x1fff1348
    148c:	.word	0x0001280c
    1490:	.word	0x00012812
    1494:	.word	0x00012817
    1498:	.word	0x000127ca
    149c:	.word	0x000127e3
    14a0:	.word	0x1fff0f34
    14a4:	.word	0x000127fd

000014a8 <getTeensySerial()>:

#else
  uint32_t getTeensySerial(void) 
  {
    uint32_t num = 0;
    __disable_irq();
    14a8:	cpsid	i
      FTFL_FSTAT = FTFL_FSTAT_CCIF;
      while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
      num = *(uint32_t *)&FTFL_FCCOB7;
    #elif defined(HAS_KINETIS_FLASH_FTFE)
      kinetis_hsrun_disable();
      FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    14aa:	ldr	r3, [pc, #32]	; (14cc <getTeensySerial()+0x24>)
      *(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    14ac:	ldr	r1, [pc, #32]	; (14d0 <getTeensySerial()+0x28>)
      FTFL_FSTAT = FTFL_FSTAT_CCIF;
      while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
      num = *(uint32_t *)&FTFL_FCCOB7;
    #elif defined(HAS_KINETIS_FLASH_FTFE)
      kinetis_hsrun_disable();
      FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    14ae:	movs	r2, #112	; 0x70
    14b0:	strb	r2, [r3, #0]
      *(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    14b2:	ldr	r2, [pc, #32]	; (14d4 <getTeensySerial()+0x2c>)
    14b4:	str	r1, [r2, #0]
      FTFL_FSTAT = FTFL_FSTAT_CCIF;
    14b6:	movs	r2, #128	; 0x80
    14b8:	strb	r2, [r3, #0]
      while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    14ba:	ldrb	r2, [r3, #0]
    14bc:	lsls	r2, r2, #24
    14be:	bpl.n	14ba <getTeensySerial()+0x12>
      num = *(uint32_t *)&FTFL_FCCOBB;
    14c0:	ldr	r3, [pc, #20]	; (14d8 <getTeensySerial()+0x30>)
    14c2:	ldr	r0, [r3, #0]
      kinetis_hsrun_enable();
    #endif
    __enable_irq();
    14c4:	cpsie	i
    return num & 0xFFFFFF;
  }
    14c6:	bic.w	r0, r0, #4278190080	; 0xff000000
    14ca:	bx	lr
    14cc:	.word	0x40020000
    14d0:	.word	0x41070000
    14d4:	.word	0x40020004
    14d8:	.word	0x4002000c

000014dc <_write>:
  int _write(int file, const void *buf, size_t len) {
    // https://forum.pjrc.com/threads/28473-Quick-Guide-Using-printf()-on-Teensy-ARM
    Print *out;
  
    // Send both stdout and stderr to stdPrint
    if (file == stdout->_file || file == stderr->_file) {
    14dc:	ldr	r3, [pc, #48]	; (1510 <_write+0x34>)
    14de:	ldr	r3, [r3, #0]
#include "usb_serial.h"
Print *stdPrint = &Serial;

extern "C"
{
  int _write(int file, const void *buf, size_t len) {
    14e0:	push	{r4}
    // https://forum.pjrc.com/threads/28473-Quick-Guide-Using-printf()-on-Teensy-ARM
    Print *out;
  
    // Send both stdout and stderr to stdPrint
    if (file == stdout->_file || file == stderr->_file) {
    14e2:	ldr	r4, [r3, #8]
    14e4:	ldrsh.w	r4, [r4, #14]
    14e8:	cmp	r4, r0
    14ea:	beq.n	14f6 <_write+0x1a>
    14ec:	ldr	r3, [r3, #12]
    14ee:	ldrsh.w	r3, [r3, #14]
    14f2:	cmp	r0, r3
    14f4:	bne.n	14fa <_write+0x1e>
      out = stdPrint;
    14f6:	ldr	r3, [pc, #28]	; (1514 <_write+0x38>)
    14f8:	ldr	r0, [r3, #0]
    } else {
      out = (Print *)file;
    }
  
    if (out == nullptr) {
    14fa:	cbz	r0, 1506 <_write+0x2a>
      return len;
    }
  
    // Don't check for len == 0 for returning early, in case there's side effects
    return out->write((const uint8_t *)buf, len);
    14fc:	ldr	r3, [r0, #0]
  }
    14fe:	ldr.w	r4, [sp], #4
    if (out == nullptr) {
      return len;
    }
  
    // Don't check for len == 0 for returning early, in case there's side effects
    return out->write((const uint8_t *)buf, len);
    1502:	ldr	r3, [r3, #4]
    1504:	bx	r3
  }
    1506:	mov	r0, r2
    1508:	ldr.w	r4, [sp], #4
    150c:	bx	lr
    150e:	nop
    1510:	.word	0x1fff1828
    1514:	.word	0x1fff0f38

00001518 <newHour()>:
    return 1;
}

int32_t hour_ = 0;
int16_t newHour(void)
{   uint32_t tx=rtc_get();
    1518:	push	{r3, lr}
    151a:	bl	9440 <rtc_get>
    int32_t h_ = (int32_t) tx/SECS_PER_HOUR;  // use hours since 1970 as measures
    151e:	mov.w	r3, #3600	; 0xe10
    1522:	udiv	r0, r0, r3
    if(hour_== h_) return 0;
    1526:	ldr	r3, [pc, #16]	; (1538 <newHour()+0x20>)
    1528:	ldr	r2, [r3, #0]
    152a:	cmp	r0, r2
    hour_ = h_;
    152c:	itte	ne
    152e:	strne	r0, [r3, #0]
    return 1;
    1530:	movne	r0, #1

int32_t hour_ = 0;
int16_t newHour(void)
{   uint32_t tx=rtc_get();
    int32_t h_ = (int32_t) tx/SECS_PER_HOUR;  // use hours since 1970 as measures
    if(hour_== h_) return 0;
    1532:	moveq	r0, #0
    hour_ = h_;
    return 1;
}
    1534:	pop	{r3, pc}
    1536:	nop
    1538:	.word	0x1fff2210

0000153c <breakTime(unsigned long, tmElements_t&)>:
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    153c:	movs	r3, #60	; 0x3c
/* functions to convert to and from system time */
/* These are for interfacing with time services and are not normally needed in a sketch */

static  const uint8_t monthDays[]={31,28,31,30,31,30,31,31,30,31,30,31}; // API starts months from 1, this array starts from 0
 
void breakTime(uint32_t timeInput, tmElements_t &tm){
    153e:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    1542:	udiv	r4, r0, r3
    1546:	mls	r2, r3, r4, r0
    154a:	strb	r2, [r1, #0]
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    154c:	udiv	r2, r4, r3
    1550:	mls	r3, r3, r2, r4
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    1554:	movs	r4, #24
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    1556:	strb	r3, [r1, #1]
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    1558:	mov.w	r3, #3600	; 0xe10
    155c:	udiv	r3, r0, r3
    1560:	udiv	r2, r3, r4
    1564:	mls	r3, r4, r2, r3
    1568:	strb	r3, [r1, #2]
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    156a:	movs	r2, #7
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
    156c:	ldr	r3, [pc, #240]	; (1660 <breakTime(unsigned long, tmElements_t&)+0x124>)
    156e:	udiv	r0, r0, r3
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    1572:	adds	r3, r0, #4
    1574:	udiv	r2, r3, r2
    1578:	rsb	r2, r2, r2, lsl #3
    157c:	subs	r3, r3, r2
    157e:	adds	r3, #1
    1580:	movs	r4, #0
    1582:	strb	r3, [r1, #3]
  
  year = 0;  
  days = 0;
    1584:	mov	r2, r4
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    1586:	movw	r8, #365	; 0x16d
    158a:	mov.w	lr, #100	; 0x64
    158e:	mov.w	ip, #400	; 0x190
    1592:	uxtb	r6, r4
    1594:	addw	r3, r6, #1970	; 0x7b2
    1598:	ands.w	r7, r3, #3
    159c:	bne.n	15bc <breakTime(unsigned long, tmElements_t&)+0x80>
    159e:	sdiv	r5, r3, lr
    15a2:	mls	r5, lr, r5, r3
    15a6:	cbnz	r5, 15c2 <breakTime(unsigned long, tmElements_t&)+0x86>
    15a8:	sdiv	r5, r3, ip
    15ac:	mls	r5, ip, r5, r3
    15b0:	cmp	r5, #0
    15b2:	ite	ne
    15b4:	movne	r5, r8
    15b6:	moveq.w	r5, #366	; 0x16e
    15ba:	b.n	15c6 <breakTime(unsigned long, tmElements_t&)+0x8a>
    15bc:	movw	r5, #365	; 0x16d
    15c0:	b.n	15c6 <breakTime(unsigned long, tmElements_t&)+0x8a>
    15c2:	mov.w	r5, #366	; 0x16e
    15c6:	add	r2, r5
    15c8:	cmp	r0, r2
    15ca:	add.w	r4, r4, #1
    15ce:	bcs.n	1592 <breakTime(unsigned long, tmElements_t&)+0x56>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
    15d0:	strb	r6, [r1, #6]
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    15d2:	cbnz	r7, 15fa <breakTime(unsigned long, tmElements_t&)+0xbe>
    15d4:	movs	r5, #100	; 0x64
    15d6:	sdiv	r4, r3, r5
    15da:	mls	r4, r5, r4, r3
    15de:	cbnz	r4, 1600 <breakTime(unsigned long, tmElements_t&)+0xc4>
    15e0:	mov.w	r5, #400	; 0x190
    15e4:	sdiv	r4, r3, r5
    15e8:	mls	r4, r5, r4, r3
    15ec:	cmp	r4, #0
    15ee:	movw	r4, #365	; 0x16d
    15f2:	it	eq
    15f4:	moveq.w	r4, #366	; 0x16e
    15f8:	b.n	1604 <breakTime(unsigned long, tmElements_t&)+0xc8>
    15fa:	movw	r4, #365	; 0x16d
    15fe:	b.n	1604 <breakTime(unsigned long, tmElements_t&)+0xc8>
    1600:	mov.w	r4, #366	; 0x16e
  time  -= days; // now it is days in this year, starting at 0
    1604:	subs	r2, r2, r4
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    1606:	movs	r6, #100	; 0x64
    1608:	mov.w	r4, #400	; 0x190
        monthLength=29;
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    160c:	ldr.w	lr, [pc, #84]	; 1664 <breakTime(unsigned long, tmElements_t&)+0x128>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
  time  -= days; // now it is days in this year, starting at 0
    1610:	subs	r0, r0, r2
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    1612:	sdiv	r2, r3, r6
    1616:	mls	r6, r6, r2, r3
    161a:	sdiv	r2, r3, r4
    161e:	mls	r3, r4, r2, r3
    1622:	movs	r2, #0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
    1624:	cmp	r2, #1
    1626:	uxtb	r5, r2
    1628:	bne.n	1638 <breakTime(unsigned long, tmElements_t&)+0xfc>
      if (LEAP_YEAR(year)) {
    162a:	cbnz	r7, 163e <breakTime(unsigned long, tmElements_t&)+0x102>
    162c:	cbnz	r6, 1642 <breakTime(unsigned long, tmElements_t&)+0x106>
        monthLength=29;
    162e:	cmp	r3, #0
    1630:	ite	ne
    1632:	movne	r4, #28
    1634:	moveq	r4, #29
    1636:	b.n	1644 <breakTime(unsigned long, tmElements_t&)+0x108>
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    1638:	ldrb.w	r4, [r2, lr]
    163c:	b.n	1644 <breakTime(unsigned long, tmElements_t&)+0x108>
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
        monthLength=29;
      } else {
        monthLength=28;
    163e:	movs	r4, #28
    1640:	b.n	1644 <breakTime(unsigned long, tmElements_t&)+0x108>
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
        monthLength=29;
    1642:	movs	r4, #29
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    1644:	cmp	r4, r0
    1646:	bhi.n	1654 <breakTime(unsigned long, tmElements_t&)+0x118>
    1648:	adds	r2, #1
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    164a:	cmp	r2, #12
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
      time -= monthLength;
    164c:	sub.w	r0, r0, r4
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    1650:	bne.n	1624 <breakTime(unsigned long, tmElements_t&)+0xe8>
    1652:	mov	r5, r2
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    1654:	adds	r5, #1
  tm.Day = time + 1;     // day of month
    1656:	adds	r0, #1
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    1658:	strb	r5, [r1, #5]
  tm.Day = time + 1;     // day of month
    165a:	strb	r0, [r1, #4]
    165c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1660:	.word	0x00015180
    1664:	.word	0x00012825

00001668 <makeTime(tmElements_t const&)>:
}

uint32_t makeTime(const tmElements_t &tm){   
    1668:	push	{r4, r5, r6, r7, lr}
  
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
    166a:	ldr	r3, [pc, #176]	; (171c <makeTime(tmElements_t const&)+0xb4>)
    166c:	ldrb	r2, [r0, #6]
    166e:	movw	r1, #1970	; 0x7b2
    1672:	muls	r3, r2
  for (i = 0; i < tm.Year; i++) {
    if (LEAP_YEAR(i)) {
    1674:	movs	r5, #100	; 0x64
    1676:	mov.w	r6, #400	; 0x190
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
  for (i = 0; i < tm.Year; i++) {
    167a:	subw	r4, r1, #1970	; 0x7b2
    167e:	cmp	r2, r4
    1680:	ble.n	16a6 <makeTime(tmElements_t const&)+0x3e>
    if (LEAP_YEAR(i)) {
    1682:	lsls	r4, r1, #30
    1684:	bne.n	16a2 <makeTime(tmElements_t const&)+0x3a>
    1686:	sdiv	r4, r1, r5
    168a:	mls	r4, r5, r4, r1
    168e:	cbnz	r4, 169a <makeTime(tmElements_t const&)+0x32>
    1690:	sdiv	r4, r1, r6
    1694:	mls	r4, r6, r4, r1
    1698:	cbnz	r4, 16a2 <makeTime(tmElements_t const&)+0x3a>
      seconds += SECS_PER_DAY;   // add extra days for leap years
    169a:	add.w	r3, r3, #86016	; 0x15000
    169e:	add.w	r3, r3, #384	; 0x180
    16a2:	adds	r1, #1
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
  for (i = 0; i < tm.Year; i++) {
    16a4:	b.n	167a <makeTime(tmElements_t const&)+0x12>
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    16a6:	addw	r2, r2, #1970	; 0x7b2
    16aa:	movs	r4, #100	; 0x64
    16ac:	mov.w	r5, #400	; 0x190
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    16b0:	ldrb	r6, [r0, #5]
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
      seconds += SECS_PER_DAY * 29;
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    16b2:	ldr	r7, [pc, #108]	; (1720 <makeTime(tmElements_t const&)+0xb8>)
    16b4:	ldr.w	lr, [pc, #108]	; 1724 <makeTime(tmElements_t const&)+0xbc>
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    16b8:	sdiv	r1, r2, r4
    16bc:	mls	r4, r4, r1, r2
    16c0:	sdiv	r1, r2, r5
    16c4:	mls	r5, r5, r1, r2
    16c8:	movs	r1, #1
    16ca:	and.w	r2, r2, #3
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    16ce:	cmp	r6, r1
    16d0:	ble.n	16f6 <makeTime(tmElements_t const&)+0x8e>
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    16d2:	cmp	r1, #2
    16d4:	bne.n	16e6 <makeTime(tmElements_t const&)+0x7e>
    16d6:	cbnz	r2, 16e6 <makeTime(tmElements_t const&)+0x7e>
    16d8:	cbnz	r4, 16dc <makeTime(tmElements_t const&)+0x74>
    16da:	cbnz	r5, 16e6 <makeTime(tmElements_t const&)+0x7e>
      seconds += SECS_PER_DAY * 29;
    16dc:	add.w	r3, r3, #2490368	; 0x260000
    16e0:	add.w	r3, r3, #15232	; 0x3b80
    16e4:	b.n	16f2 <makeTime(tmElements_t const&)+0x8a>
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    16e6:	add.w	ip, r7, r1
    16ea:	ldrb.w	ip, [ip, #-1]
    16ee:	mla	r3, lr, ip, r3
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    16f2:	adds	r1, #1
    16f4:	b.n	16ce <makeTime(tmElements_t const&)+0x66>
  }
  seconds+= (tm.Day-1) * SECS_PER_DAY;
  seconds+= tm.Hour * SECS_PER_HOUR;
  seconds+= tm.Minute * SECS_PER_MIN;
  seconds+= tm.Second;
  return seconds; 
    16f6:	ldrb	r2, [r0, #1]
    16f8:	ldrb	r1, [r0, #2]
    16fa:	rsb	r2, r2, r2, lsl #4
    16fe:	mov.w	r4, #3600	; 0xe10
    1702:	lsls	r2, r2, #2
    1704:	mla	r2, r4, r1, r2
    1708:	ldrb	r1, [r0, #0]
    170a:	add	r2, r1
    170c:	ldrb	r1, [r0, #4]
    170e:	ldr	r0, [pc, #20]	; (1724 <makeTime(tmElements_t const&)+0xbc>)
    1710:	subs	r1, #1
    1712:	mla	r0, r0, r1, r2
}
    1716:	add	r0, r3
    1718:	pop	{r4, r5, r6, r7, pc}
    171a:	nop
    171c:	.word	0x01e13380
    1720:	.word	0x00012825
    1724:	.word	0x00015180

00001728 <setRTCTime(int, int, int, int, int, int)>:

extern "C" void rtc_set(uint32_t tt);

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
    1728:	push	{r0, r1, r4, lr}
    172a:	ldr	r4, [sp, #20]
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
    172c:	strb.w	r0, [sp, #2]
extern "C" void rtc_set(uint32_t tt);

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
 // year can be given as full four digit year or two digts (2010 or 10 for 2010);  
 // it is converted to years since 1970
  if( yr > 99)
    1730:	cmp	r4, #99	; 0x63
  tm.Year = yr;
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;
    1732:	add	r0, sp, #8

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
 // year can be given as full four digit year or two digts (2010 or 10 for 2010);  
 // it is converted to years since 1970
  if( yr > 99)
      yr = yr - 1970;
    1734:	ite	gt
    1736:	subwgt	r4, r4, #1970	; 0x7b2
  else
      yr += 30;  
    173a:	addle	r4, #30
  
  tmElements_t tm;
  tm.Year = yr;
    173c:	strb.w	r4, [sp, #6]
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;
    1740:	strb.w	r2, [r0, #-8]!
  else
      yr += 30;  
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
    1744:	ldr	r4, [sp, #16]
  tm.Day = dy;
    1746:	strb.w	r3, [sp, #4]
  tm.Hour = hr;
  tm.Minute = min;
    174a:	strb.w	r1, [sp, #1]
  else
      yr += 30;  
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
    174e:	strb.w	r4, [sp, #5]
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;

  uint32_t tt = makeTime(tm);
    1752:	bl	1668 <makeTime(tmElements_t const&)>
  rtc_set(tt); // for RTC
    1756:	bl	944c <rtc_set>
}
    175a:	add	sp, #8
    175c:	pop	{r4, pc}

0000175e <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)>:
   * \param[out] dst Pointer to the location that will receive the data.
   * \param[in] callback Function to be called with each sector's data
   * \param[in] context Pointer to be passed to the callback function
   * \return true for success or false for failure.
   */
  virtual bool readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
    175e:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    1762:	ldr	r5, [sp, #32]
    1764:	mov	r7, r0
    1766:	mov	r6, r2
    1768:	add.w	r9, r3, r1
    176c:	mov	r4, r1
   void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
    176e:	cmp	r4, r9
    1770:	beq.n	1790 <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x32>
       if (!readSector(sector + i, dst)) return false;
    1772:	ldr	r3, [r7, #0]
    1774:	mov	r2, r6
    1776:	ldr	r3, [r3, #12]
    1778:	mov	r1, r4
    177a:	mov	r0, r7
    177c:	blx	r3
    177e:	add.w	r8, r4, #1
    1782:	cbz	r0, 1792 <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x34>
       callback(sector + i, dst, context);
    1784:	mov	r0, r4
    1786:	ldr	r2, [sp, #36]	; 0x24
    1788:	mov	r1, r6
    178a:	blx	r5
   * \param[in] context Pointer to be passed to the callback function
   * \return true for success or false for failure.
   */
  virtual bool readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
   void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
    178c:	mov	r4, r8
    178e:	b.n	176e <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x10>
       if (!readSector(sector + i, dst)) return false;
       callback(sector + i, dst, context);
     }
     return true;
    1790:	movs	r0, #1
  }
    1792:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00001796 <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)>:
   * \param[in] ns Number of sectors to be written.
   * \param[in] callback Function to be called for each sector's data
   * \param[in] context Context to pass to callback function
   * \return true for success or false for failure.
   */
  virtual bool writeSectorsCallback(uint32_t sector, size_t ns,
    1796:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    179a:	mov	r5, r0
    179c:	mov	r7, r3
    179e:	add.w	r8, r2, r1
    17a2:	mov	r4, r1
   const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
    17a4:	cmp	r4, r8
    17a6:	beq.n	17c4 <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x2e>
       if (!writeSector(sector + i, callback(sector + i, context))) return false;
    17a8:	ldr	r3, [r5, #0]
    17aa:	ldr	r1, [sp, #24]
    17ac:	ldr	r6, [r3, #32]
    17ae:	mov	r0, r4
    17b0:	blx	r7
    17b2:	mov	r1, r4
    17b4:	mov	r2, r0
    17b6:	mov	r0, r5
    17b8:	blx	r6
    17ba:	adds	r4, #1
    17bc:	cmp	r0, #0
    17be:	bne.n	17a4 <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0xe>
    17c0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     }
    return true;
    17c4:	movs	r0, #1
  }
    17c6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000017ca <SdCardInterface::status()>:
   * \return The number of 512 byte data sectors in the card
   *         or zero if an error occurs.
   */
  virtual uint32_t sectorCount() = 0;
  /** \return card status. */
  virtual uint32_t status() {return 0XFFFFFFFF;}
    17ca:	mov.w	r0, #4294967295
    17ce:	bx	lr

000017d0 <MySpiClass::activate()>:
    public:
        // Initialize the SPI bus.
        void begin(SdSpiConfig config) {  (void) config; SPI.begin(); }

        // Activate SPI hardware with correct speed and mode.
        void activate() { if(doTransactions) SPI.beginTransaction(m_spiSettings); }
    17d0:	ldrb	r3, [r0, #8]
    17d2:	push	{r4, r5, lr}
    17d4:	cmp	r3, #0
    17d6:	beq.n	184c <MySpiClass::activate()+0x7c>

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    17d8:	ldr	r3, [pc, #116]	; (1850 <MySpiClass::activate()+0x80>)
    17da:	ldr	r2, [r0, #4]
    17dc:	ldrb	r1, [r3, #11]
    17de:	cmp	r1, #0
    17e0:	beq.n	1834 <MySpiClass::activate()+0x64>
			__disable_irq();
    17e2:	cpsid	i
			if (interruptMasksUsed & 0x01) {
    17e4:	ldrb	r1, [r3, #11]
    17e6:	lsls	r1, r1, #31
    17e8:	bpl.n	17f6 <MySpiClass::activate()+0x26>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    17ea:	ldr	r0, [pc, #104]	; (1854 <MySpiClass::activate()+0x84>)
    17ec:	ldr	r1, [r3, #12]
    17ee:	ldr	r4, [r0, #0]
    17f0:	ands	r1, r4
    17f2:	str	r1, [r3, #28]
				NVIC_ICER0 = interruptSave[0];
    17f4:	str	r1, [r0, #0]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    17f6:	ldrb	r1, [r3, #11]
    17f8:	ldr	r4, [pc, #84]	; (1850 <MySpiClass::activate()+0x80>)
    17fa:	lsls	r5, r1, #30
    17fc:	bpl.n	180a <MySpiClass::activate()+0x3a>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    17fe:	ldr	r0, [pc, #88]	; (1858 <MySpiClass::activate()+0x88>)
    1800:	ldr	r1, [r4, #16]
    1802:	ldr	r5, [r0, #0]
    1804:	ands	r1, r5
    1806:	str	r1, [r4, #32]
				NVIC_ICER1 = interruptSave[1];
    1808:	str	r1, [r0, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    180a:	ldrb	r1, [r3, #11]
    180c:	ldr	r4, [pc, #64]	; (1850 <MySpiClass::activate()+0x80>)
    180e:	lsls	r0, r1, #29
    1810:	bpl.n	181e <MySpiClass::activate()+0x4e>
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    1812:	ldr	r0, [pc, #72]	; (185c <MySpiClass::activate()+0x8c>)
    1814:	ldr	r1, [r4, #20]
    1816:	ldr	r5, [r0, #0]
    1818:	ands	r1, r5
    181a:	str	r1, [r4, #36]	; 0x24
				NVIC_ICER2 = interruptSave[2];
    181c:	str	r1, [r0, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    181e:	ldrb	r1, [r3, #11]
    1820:	ldr	r4, [pc, #44]	; (1850 <MySpiClass::activate()+0x80>)
    1822:	lsls	r1, r1, #28
    1824:	bpl.n	1832 <MySpiClass::activate()+0x62>
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
    1826:	ldr	r0, [pc, #56]	; (1860 <MySpiClass::activate()+0x90>)
    1828:	ldr	r1, [r4, #24]
    182a:	ldr	r5, [r0, #0]
    182c:	ands	r1, r5
    182e:	str	r1, [r4, #40]	; 0x28
				NVIC_ICER3 = interruptSave[3];
    1830:	str	r1, [r0, #0]
			}
			#endif
			__enable_irq();
    1832:	cpsie	i
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    1834:	ldr	r3, [r3, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
    1836:	ldr	r1, [r3, #12]
    1838:	cmp	r1, r2
    183a:	beq.n	184c <MySpiClass::activate()+0x7c>
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
    183c:	ldr	r1, [pc, #36]	; (1864 <MySpiClass::activate()+0x94>)
    183e:	str	r1, [r3, #0]
			port().CTAR0 = settings.ctar;
    1840:	str	r2, [r3, #12]
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
    1842:	orr.w	r2, r2, #1073741824	; 0x40000000
    1846:	str	r2, [r3, #16]
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    1848:	ldr	r2, [pc, #28]	; (1868 <MySpiClass::activate()+0x98>)
    184a:	str	r2, [r3, #0]
    184c:	pop	{r4, r5, pc}
    184e:	nop
    1850:	.word	0x1fff12f8
    1854:	.word	0xe000e180
    1858:	.word	0xe000e184
    185c:	.word	0xe000e188
    1860:	.word	0xe000e18c
    1864:	.word	0x003f4001
    1868:	.word	0x803f0000

0000186c <MySpiClass::send(unsigned char)>:

        // Receive a byte.
        uint8_t receive() { return SPI.transfer(0XFF); }

        // Send a byte.
        void send(uint8_t data) { SPI.transfer(data); }
    186c:	ldr	r3, [pc, #20]	; (1884 <MySpiClass::send(unsigned char)+0x18>)
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    186e:	ldr	r3, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    1870:	mov.w	r2, #2147483648	; 0x80000000
    1874:	str	r2, [r3, #44]	; 0x2c
		port().PUSHR = data;
    1876:	str	r1, [r3, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    1878:	ldr	r2, [r3, #44]	; 0x2c
    187a:	cmp	r2, #0
    187c:	bge.n	1878 <MySpiClass::send(unsigned char)+0xc>
		return port().POPR;
    187e:	ldr	r3, [r3, #56]	; 0x38
    1880:	bx	lr
    1882:	nop
    1884:	.word	0x1fff12f8

00001888 <__tcf_0>:
    const char *sd_str[]={"sd1"};
    const int cs[] = {10 };

    const int nsd = sizeof(cs)/sizeof(int);

    SDClass sdx[nsd];
    1888:	bx	lr

0000188a <dateTime(unsigned short*, unsigned short*, unsigned char*)>:
    uint32_t diskSpace[nsd];
    uint32_t clusterSize[nsd];

// Call back for file timestamps.  Only called for file create and sync(). needed by SDFat-beta
void dateTime(uint16_t* date, uint16_t* time, uint8_t* ms10) 
{       
    188a:	push	{r0, r1, r4, r5, r6, lr}
    188c:	mov	r5, r2
    188e:	mov	r4, r1
    1890:	mov	r6, r0
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    1892:	bl	9440 <rtc_get>
    1896:	mov	r1, sp
    1898:	bl	153c <breakTime(unsigned long, tmElements_t&)>
 * \param[in] day [1,31]
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
    189c:	ldrb.w	r3, [sp, #6]

    *date = FS_DATE(tmYearToCalendar(tm.Year),tm.Month, tm.Day);
    18a0:	ldrb.w	r2, [sp, #5]
    18a4:	ldrb.w	r1, [sp, #4]
    18a8:	subs	r3, #10
    18aa:	uxth	r3, r3
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    18ac:	cmp	r3, #127	; 0x7f
    18ae:	bhi.n	18c4 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3a>
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
    18b0:	cmp	r2, #12
    18b2:	bhi.n	18c4 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3a>
    18b4:	cmp	r1, #31
    18b6:	bhi.n	18c4 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3a>
         year << 9 | month << 5 | day;
    18b8:	orr.w	r1, r1, r2, lsl #5
    18bc:	orr.w	r3, r1, r3, lsl #9
    18c0:	uxth	r3, r3
    18c2:	b.n	18c6 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3c>
    18c4:	movs	r3, #0
    18c6:	strh	r3, [r6, #0]
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    18c8:	ldrb.w	r3, [sp, #2]
    18cc:	ldrb.w	r1, [sp, #1]
    18d0:	ldrb.w	r2, [sp]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    18d4:	cmp	r3, #23
    18d6:	bhi.n	18ee <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
 * \param[in] second [0,59]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
    18d8:	cmp	r1, #59	; 0x3b
    18da:	bhi.n	18ee <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
    18dc:	cmp	r2, #59	; 0x3b
    18de:	bhi.n	18ee <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
         hour << 11 | minute << 5 | second >> 1;
    18e0:	lsls	r1, r1, #5
    18e2:	orr.w	r3, r1, r3, lsl #11
    18e6:	orr.w	r3, r3, r2, lsr #1
    18ea:	uxth	r3, r3
    18ec:	b.n	18f0 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x66>
    18ee:	movs	r3, #0
    *ms10 = tm.Second & 1 ? 100 : 0;
    18f0:	ands.w	r2, r2, #1
    18f4:	it	ne
    18f6:	movne	r2, #100	; 0x64
{       
    tmElements_t tm;
    breakTime(rtc_get(), tm);

    *date = FS_DATE(tmYearToCalendar(tm.Year),tm.Month, tm.Day);
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    18f8:	strh	r3, [r4, #0]
    *ms10 = tm.Second & 1 ? 100 : 0;
    18fa:	strb	r2, [r5, #0]
}
    18fc:	add	sp, #8
    18fe:	pop	{r4, r5, r6, pc}

00001900 <MySpiClass::send(unsigned char const*, unsigned int)>:
        { memset(buf, 0XFF, count); SPI.transfer(buf, count); return 0; }

        // Send multiple bytes.
        // Replace this function if your board has multiple byte send.
        void send(const uint8_t* buf, size_t count) 
        {  SPI.transfer((void *)buf, (void *) dummy_buffer, count); }
    1900:	mov	r3, r2
    1902:	ldr	r0, [pc, #8]	; (190c <MySpiClass::send(unsigned char const*, unsigned int)+0xc>)
    1904:	ldr	r2, [pc, #8]	; (1910 <MySpiClass::send(unsigned char const*, unsigned int)+0x10>)
    1906:	b.w	2e30 <SPIClass::transfer(void const*, void*, unsigned int)>
    190a:	nop
    190c:	.word	0x1fff12f8
    1910:	.word	0x200181b0

00001914 <MySpiClass::receive(unsigned char*, unsigned int)>:
        // Send a byte.
        void send(uint8_t data) { SPI.transfer(data); }

        // Receive multiple bytes.  
        // Replace this function if your board has multiple byte receive.
        uint8_t receive(uint8_t* buf, size_t count) 
    1914:	push	{r3, r4, r5, lr}
    1916:	mov	r4, r1
    1918:	mov	r5, r2
        { memset(buf, 0XFF, count); SPI.transfer(buf, count); return 0; }
    191a:	movs	r1, #255	; 0xff
    191c:	mov	r0, r4
    191e:	bl	90bc <memset>
		port().PUSHR = data | SPI_PUSHR_CTAS(1);
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
	}

	void inline transfer(void *buf, size_t count) {transfer(buf, buf, count);}
    1922:	mov	r3, r5
    1924:	mov	r2, r4
    1926:	mov	r1, r4
    1928:	ldr	r0, [pc, #8]	; (1934 <MySpiClass::receive(unsigned char*, unsigned int)+0x20>)
    192a:	bl	2e30 <SPIClass::transfer(void const*, void*, unsigned int)>
    192e:	movs	r0, #0
    1930:	pop	{r3, r4, r5, pc}
    1932:	nop
    1934:	.word	0x1fff12f8

00001938 <MySpiClass::begin(SdSpiConfig)>:
     * 
     */

    public:
        // Initialize the SPI bus.
        void begin(SdSpiConfig config) {  (void) config; SPI.begin(); }
    1938:	sub	sp, #16
    193a:	add	r0, sp, #16
    193c:	stmdb	r0, {r1, r2, r3}
    1940:	ldr	r0, [pc, #4]	; (1948 <MySpiClass::begin(SdSpiConfig)+0x10>)
    1942:	add	sp, #16
    1944:	b.w	2be4 <SPIClass::begin()>
    1948:	.word	0x1fff12f8

0000194c <File::dec_refcount() [clone .isra.23]>:
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	using Print::write;
private:
	void dec_refcount() {
    194c:	push	{r4, lr}
    194e:	mov	r4, r0
		if (--(f->refcount) == 0) {
    1950:	ldr	r0, [r0, #0]
    1952:	ldr	r3, [r0, #4]
    1954:	subs	r3, #1
    1956:	str	r3, [r0, #4]
    1958:	cbnz	r3, 196a <File::dec_refcount() [clone .isra.23]+0x1e>
			f->close();
    195a:	ldr	r3, [r0, #0]
    195c:	ldr	r3, [r3, #44]	; 0x2c
    195e:	blx	r3
			delete f;
    1960:	ldr	r0, [r4, #0]
    1962:	cbz	r0, 196a <File::dec_refcount() [clone .isra.23]+0x1e>
    1964:	ldr	r3, [r0, #0]
    1966:	ldr	r3, [r3, #4]
    1968:	blx	r3
		}
		f = nullptr;
    196a:	movs	r3, #0
    196c:	str	r3, [r4, #0]
    196e:	pop	{r4, pc}

00001970 <MySpiClass::deactivate()>:

        // Activate SPI hardware with correct speed and mode.
        void activate() { if(doTransactions) SPI.beginTransaction(m_spiSettings); }
        // Deactivate SPI hardware.
        void deactivate() { if(doTransactions) SPI.endTransaction(); }
    1970:	ldrb	r3, [r0, #8]
    1972:	cbz	r3, 19ae <MySpiClass::deactivate()+0x3e>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    1974:	ldr	r3, [pc, #56]	; (19b0 <MySpiClass::deactivate()+0x40>)
    1976:	ldrb	r2, [r3, #11]
    1978:	cbz	r2, 19ae <MySpiClass::deactivate()+0x3e>
			if (interruptMasksUsed & 0x01) {
    197a:	lsls	r0, r2, #31
				NVIC_ISER0 = interruptSave[0];
    197c:	ittt	mi
    197e:	ldrmi	r2, [pc, #52]	; (19b4 <MySpiClass::deactivate()+0x44>)
    1980:	ldrmi	r1, [r3, #28]
    1982:	strmi	r1, [r2, #0]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    1984:	ldrb	r2, [r3, #11]
    1986:	lsls	r1, r2, #30
				NVIC_ISER1 = interruptSave[1];
    1988:	itttt	mi
    198a:	ldrmi	r2, [pc, #36]	; (19b0 <MySpiClass::deactivate()+0x40>)
    198c:	ldrmi	r1, [r2, #32]
    198e:	ldrmi	r2, [pc, #40]	; (19b8 <MySpiClass::deactivate()+0x48>)
    1990:	strmi	r1, [r2, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    1992:	ldrb	r2, [r3, #11]
    1994:	lsls	r2, r2, #29
				NVIC_ISER2 = interruptSave[2];
    1996:	itttt	mi
    1998:	ldrmi	r2, [pc, #20]	; (19b0 <MySpiClass::deactivate()+0x40>)
    199a:	ldrmi	r1, [r2, #36]	; 0x24
    199c:	ldrmi	r2, [pc, #28]	; (19bc <MySpiClass::deactivate()+0x4c>)
    199e:	strmi	r1, [r2, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    19a0:	ldrb	r3, [r3, #11]
    19a2:	lsls	r3, r3, #28
				NVIC_ISER3 = interruptSave[3];
    19a4:	itttt	mi
    19a6:	ldrmi	r3, [pc, #8]	; (19b0 <MySpiClass::deactivate()+0x40>)
    19a8:	ldrmi	r2, [r3, #40]	; 0x28
    19aa:	ldrmi	r3, [pc, #20]	; (19c0 <MySpiClass::deactivate()+0x50>)
    19ac:	strmi	r2, [r3, #0]
    19ae:	bx	lr
    19b0:	.word	0x1fff12f8
    19b4:	.word	0xe000e100
    19b8:	.word	0xe000e104
    19bc:	.word	0xe000e108
    19c0:	.word	0xe000e10c

000019c4 <MySpiClass::receive()>:

        // Receive a byte.
        uint8_t receive() { return SPI.transfer(0XFF); }
    19c4:	ldr	r3, [pc, #24]	; (19e0 <MySpiClass::receive()+0x1c>)
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    19c6:	ldr	r3, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    19c8:	mov.w	r2, #2147483648	; 0x80000000
    19cc:	str	r2, [r3, #44]	; 0x2c
		port().PUSHR = data;
    19ce:	movs	r2, #255	; 0xff
    19d0:	str	r2, [r3, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    19d2:	ldr	r2, [r3, #44]	; 0x2c
    19d4:	cmp	r2, #0
    19d6:	bge.n	19d2 <MySpiClass::receive()+0xe>
		return port().POPR;
    19d8:	ldr	r0, [r3, #56]	; 0x38
    19da:	uxtb	r0, r0
    19dc:	bx	lr
    19de:	nop
    19e0:	.word	0x1fff12f8

000019e4 <Print::print(char const*)>:
    19e4:	push	{r3, lr}
    19e6:	bl	734 <Print::write(char const*)>
    19ea:	pop	{r3, pc}

000019ec <Print::println(unsigned long)>:

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
    19ec:	push	{r3, r4, r5, lr}
    19ee:	mov	r5, r0
    19f0:	bl	750 <Print::print(unsigned long)>
    19f4:	mov	r4, r0
    19f6:	mov	r0, r5
    19f8:	bl	a1bc <Print::println()>
    19fc:	add	r0, r4
    19fe:	pop	{r3, r4, r5, pc}

00001a00 <FsVolume::bytesPerCluster() const>:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  uint32_t __attribute__((error("use sectorsPerCluster()"))) blocksPerCluster();
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
    1a00:	ldr.w	r3, [r0, #1152]	; 0x480
           m_xVol ? m_xVol->bytesPerCluster() : 0;
    1a04:	cbz	r3, 1a14 <FsVolume::bytesPerCluster() const+0x14>
    1a06:	ldrb	r0, [r3, #6]
    1a08:	mov.w	r3, #512	; 0x200
    1a0c:	lsl.w	r0, r3, r0
    1a10:	uxth	r0, r0
    1a12:	bx	lr
    1a14:	ldr.w	r0, [r0, #1156]	; 0x484
    1a18:	cbz	r0, 1a1e <FsVolume::bytesPerCluster() const+0x1e>
    1a1a:	ldr.w	r0, [r0, #1084]	; 0x43c
  }
    1a1e:	bx	lr

00001a20 <FsVolume::clusterCount() const>:
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    1a20:	ldr.w	r3, [r0, #1152]	; 0x480
           m_xVol ? m_xVol->clusterCount() : 0;
    1a24:	cbz	r3, 1a2c <FsVolume::clusterCount() const+0xc>
  uint8_t* cacheClear() {
    return m_cache.clear();
  }
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_lastCluster - 1;
    1a26:	ldr	r0, [r3, #28]
    1a28:	subs	r0, #1
    1a2a:	bx	lr
    1a2c:	ldr.w	r0, [r0, #1156]	; 0x484
    1a30:	cbz	r0, 1a36 <FsVolume::clusterCount() const+0x16>
    1a32:	ldr.w	r0, [r0, #1072]	; 0x430
  }
    1a36:	bx	lr

00001a38 <FsVolume::freeClusterCount() const>:
  uint8_t fatType() const {
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    1a38:	mov	r3, r0
    return m_fVol ? m_fVol->freeClusterCount() :
    1a3a:	ldr.w	r0, [r0, #1152]	; 0x480
           m_xVol ? m_xVol->freeClusterCount() : 0;
    1a3e:	cbz	r0, 1a44 <FsVolume::freeClusterCount() const+0xc>
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
    1a40:	b.w	6c04 <FatPartition::freeClusterCount()>
           m_xVol ? m_xVol->freeClusterCount() : 0;
    1a44:	ldr.w	r0, [r3, #1156]	; 0x484
    1a48:	cbz	r0, 1a4e <FsVolume::freeClusterCount() const+0x16>
    1a4a:	b.w	4b28 <ExFatPartition::freeClusterCount()>
  }
    1a4e:	bx	lr

00001a50 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)>:
	}
	SPISettings() {
		init_AlwaysInline(4000000, MSBFIRST, SPI_MODE0);
	}
private:
	void init_MightInline(uint32_t clock, uint8_t bitOrder, uint8_t dataMode) {
    1a50:	push	{r4, r5, r6, r7, lr}
		init_AlwaysInline(clock, bitOrder, dataMode);
	}
	void init_AlwaysInline(uint32_t clock, uint8_t bitOrder, uint8_t dataMode)
	  __attribute__((__always_inline__)) {
		uint32_t t, c = SPI_CTAR_FMSZ(7);
		if (bitOrder == LSBFIRST) c |= SPI_CTAR_LSBFE;
    1a52:	cmp	r2, #0
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    1a54:	ldr	r6, [pc, #76]	; (1aa4 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x54>)
    1a56:	ldr	r7, [pc, #80]	; (1aa8 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x58>)
		init_AlwaysInline(clock, bitOrder, dataMode);
	}
	void init_AlwaysInline(uint32_t clock, uint8_t bitOrder, uint8_t dataMode)
	  __attribute__((__always_inline__)) {
		uint32_t t, c = SPI_CTAR_FMSZ(7);
		if (bitOrder == LSBFIRST) c |= SPI_CTAR_LSBFE;
    1a58:	ite	ne
    1a5a:	movne.w	r4, #939524096	; 0x38000000
    1a5e:	moveq.w	r4, #956301312	; 0x39000000
				t = SPI_CTAR_PBR(2) | SPI_CTAR_BR(7) | SPI_CTAR_CSSCK(6);
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
    1a62:	movs	r2, #0
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    1a64:	ldrh.w	r5, [r6, r2, lsl #1]
    1a68:	sdiv	r5, r7, r5
    1a6c:	cmp	r1, r5
    1a6e:	bcc.n	1a7a <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x2a>
			}
		}
		if (dataMode & 0x08) {
    1a70:	lsls	r1, r3, #28
    1a72:	bpl.n	1a84 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x34>
			c |= SPI_CTAR_CPOL;
    1a74:	orr.w	r4, r4, #67108864	; 0x4000000
    1a78:	b.n	1a84 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x34>
				t = SPI_CTAR_PBR(2) | SPI_CTAR_BR(7) | SPI_CTAR_CSSCK(6);
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
    1a7a:	adds	r5, r2, #1
    1a7c:	cmp	r5, #23
    1a7e:	beq.n	1a70 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x20>
    1a80:	mov	r2, r5
    1a82:	b.n	1a64 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x14>
				t = ctar_clock_table[i];
    1a84:	ldr	r1, [pc, #36]	; (1aac <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x5c>)
			}
		}
		if (dataMode & 0x08) {
			c |= SPI_CTAR_CPOL;
		}
		if (dataMode & 0x04) {
    1a86:	lsls	r3, r3, #29
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
				t = ctar_clock_table[i];
    1a88:	ldr.w	r2, [r1, r2, lsl #2]
			}
		}
		if (dataMode & 0x08) {
			c |= SPI_CTAR_CPOL;
		}
		if (dataMode & 0x04) {
    1a8c:	bpl.n	1a9e <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x4e>
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
    1a8e:	bic.w	r3, r2, #61440	; 0xf000
    1a92:	lsrs	r2, r2, #4
    1a94:	and.w	r2, r2, #3840	; 0xf00
		}
		if (dataMode & 0x08) {
			c |= SPI_CTAR_CPOL;
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
    1a98:	orr.w	r4, r4, #33554432	; 0x2000000
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
    1a9c:	orrs	r2, r3
		}
		ctar = c | t;
    1a9e:	orrs	r2, r4
    1aa0:	str	r2, [r0, #0]
    1aa2:	pop	{r4, r5, r6, r7, pc}
    1aa4:	.word	0x000129a8
    1aa8:	.word	0x02dc6c00
    1aac:	.word	0x00012a6c

00001ab0 <SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)>:
#define SPI_HAS_NOTUSINGINTERRUPT 1
#define SPI_ATOMIC_VERSION 1

class SPISettings {
public:
	SPISettings(uint32_t clock, uint8_t bitOrder, uint8_t dataMode) {
    1ab0:	push	{r4, lr}
    1ab2:	mov	r4, r0
		if (__builtin_constant_p(clock)) {
			init_AlwaysInline(clock, bitOrder, dataMode);
		} else {
			init_MightInline(clock, bitOrder, dataMode);
    1ab4:	bl	1a50 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)>
		}
	}
    1ab8:	mov	r0, r4
    1aba:	pop	{r4, pc}

00001abc <MySpiClass::setSckSpeed(unsigned long)>:
        // Replace this function if your board has multiple byte send.
        void send(const uint8_t* buf, size_t count) 
        {  SPI.transfer((void *)buf, (void *) dummy_buffer, count); }

        // Save SPISettings for new max SCK frequency
        void setSckSpeed(uint32_t maxSck) {  m_spiSettings = SPISettings(maxSck, MSBFIRST, SPI_MODE0); }
    1abc:	push	{r0, r1, r4, lr}
    1abe:	movs	r3, #0
    1ac0:	mov	r4, r0
    1ac2:	movs	r2, #1
    1ac4:	add	r0, sp, #4
    1ac6:	bl	1ab0 <SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)>
    1aca:	ldr	r3, [sp, #4]
    1acc:	str	r3, [r4, #4]
    1ace:	add	sp, #8
    1ad0:	pop	{r4, pc}
    1ad2:	Address 0x00001ad2 is out of bounds.


00001ad4 <getCount()>:

    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    1ad4:	ldr	r2, [pc, #16]	; (1ae8 <getCount()+0x14>)
    1ad6:	ldrh	r3, [r2, #0]
    1ad8:	ldrh	r0, [r2, #2]
            {  
                /**
                 * @brief get number of data blocks in storage
                 * 
                 */
                if(front_ >= rear_) return front_ - rear_; return front_+ MAXBUF -rear_; 
    1ada:	cmp	r3, r0
    1adc:	it	cc
    1ade:	addcc	r3, #150	; 0x96
    1ae0:	subs	r0, r3, r0
    1ae2:	uxth	r0, r0

    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    1ae4:	bx	lr
    1ae6:	nop
    1ae8:	.word	0x20018154

00001aec <pushData(unsigned long*)>:
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    1aec:	push	{r3, r4, r5, lr}
            { 
                /** 
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
    1aee:	ldr	r5, [pc, #44]	; (1b1c <pushData(unsigned long*)+0x30>)
    1af0:	ldrh	r4, [r5, #0]
                if(f >= MAXBUF) f=0;
                if(f == rear_) return 0;
    1af2:	ldrh	r3, [r5, #2]
            { 
                /** 
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
    1af4:	adds	r4, #1
    1af6:	uxth	r4, r4
                if(f >= MAXBUF) f=0;
    1af8:	cmp	r4, #150	; 0x96
    1afa:	it	cs
    1afc:	movcs	r4, #0
                if(f == rear_) return 0;
    1afe:	cmp	r3, r4
    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    1b00:	mov	r1, r0
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
                if(f >= MAXBUF) f=0;
                if(f == rear_) return 0;
    1b02:	beq.n	1b18 <pushData(unsigned long*)+0x2c>

                uint32_t *ptr= data_buffer+f*NBUF_ACQ;
                memcpy(ptr,src,NBUF_ACQ*4);
    1b04:	ldr	r0, [r5, #4]
    1b06:	mov.w	r2, #1024	; 0x400
    1b0a:	add.w	r0, r0, r4, lsl #10
    1b0e:	bl	8f14 <memcpy>
                front_ = f;
    1b12:	strh	r4, [r5, #0]
                return 1;
    1b14:	movs	r0, #1
    1b16:	pop	{r3, r4, r5, pc}
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
                if(f >= MAXBUF) f=0;
                if(f == rear_) return 0;
    1b18:	movs	r0, #0
    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    1b1a:	pop	{r3, r4, r5, pc}
    1b1c:	.word	0x20018154

00001b20 <pullData(unsigned long*, unsigned long)>:
    uint16_t pullData(uint32_t * dst, uint32_t ndbl) {return rawData.pull(dst,ndbl);}
    1b20:	push	{r4, r5, r6, lr}
                /** 
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
    1b22:	ldr	r6, [pc, #60]	; (1b60 <pullData(unsigned long*, unsigned long)+0x40>)
    1b24:	ldrh	r4, [r6, #2]
                if(r == (front_/ndbl)) return 0;
    1b26:	ldrh	r3, [r6, #0]
                /** 
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
    1b28:	udiv	r4, r4, r1
                if(r == (front_/ndbl)) return 0;
    1b2c:	udiv	r3, r3, r1
    1b30:	cmp	r4, r3

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    uint16_t pullData(uint32_t * dst, uint32_t ndbl) {return rawData.pull(dst,ndbl);}
    1b32:	mov	r5, r1
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
                if(r == (front_/ndbl)) return 0;
    1b34:	beq.n	1b5c <pullData(unsigned long*, unsigned long)+0x3c>
    1b36:	lsls	r2, r1, #10

                uint32_t *ptr= data_buffer + r*ndbl*NBUF_ACQ;
                memcpy(dst,ptr,ndbl*NBUF_ACQ*4);
    1b38:	ldr	r1, [r6, #4]
    1b3a:	mla	r1, r2, r4, r1
    1b3e:	bl	8f14 <memcpy>
                if(++r >= (MAXBUF/ndbl)) r=0;
    1b42:	adds	r1, r4, #1
    1b44:	uxth	r1, r1
    1b46:	movs	r3, #150	; 0x96
    1b48:	udiv	r3, r3, r5
    1b4c:	cmp	r1, r3
    1b4e:	it	cs
    1b50:	movcs	r1, #0
                rear_ = r*ndbl;
    1b52:	smulbb	r1, r5, r1
    1b56:	strh	r1, [r6, #2]
                return 1;
    1b58:	movs	r0, #1
    1b5a:	pop	{r4, r5, r6, pc}
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
                if(r == (front_/ndbl)) return 0;
    1b5c:	movs	r0, #0

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    uint16_t pullData(uint32_t * dst, uint32_t ndbl) {return rawData.pull(dst,ndbl);}
    1b5e:	pop	{r4, r5, r6, pc}
    1b60:	.word	0x20018154

00001b64 <sdCsInit(unsigned char)>:
};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}

void sdCsInit(SdCsPin_t pin) { pinMode(pin, OUTPUT); digitalWriteFast(pin, HIGH);}
    1b64:	push	{r4, lr}
    1b66:	movs	r1, #1
    1b68:	mov	r4, r0
    1b6a:	bl	94b0 <pinMode>
			}
			#endif
		}
	} else {
		if (val) {
			*portSetRegister(pin) = digitalPinToBitMask(pin);
    1b6e:	ldr	r3, [pc, #12]	; (1b7c <sdCsInit(unsigned char)+0x18>)
    1b70:	ldr.w	r3, [r3, r4, lsl #3]
    1b74:	movs	r2, #1
    1b76:	strb.w	r2, [r3, #128]	; 0x80
    1b7a:	pop	{r4, pc}
    1b7c:	.word	0x00012e88

00001b80 <sdCsWrite(unsigned char, bool)>:
void sdCsWrite(SdCsPin_t pin, bool level) { digitalWriteFast(pin, level); }
    1b80:	ldr	r2, [pc, #20]	; (1b98 <sdCsWrite(unsigned char, bool)+0x18>)
    1b82:	movs	r3, #1
    1b84:	ldr.w	r2, [r2, r0, lsl #3]
				CORE_PIN63_PORTCLEAR = CORE_PIN63_BITMASK;
			}
			#endif
		}
	} else {
		if (val) {
    1b88:	cbz	r1, 1b90 <sdCsWrite(unsigned char, bool)+0x10>
			*portSetRegister(pin) = digitalPinToBitMask(pin);
    1b8a:	strb.w	r3, [r2, #128]	; 0x80
    1b8e:	bx	lr
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
    1b90:	strb.w	r3, [r2, #256]	; 0x100
    1b94:	bx	lr
    1b96:	nop
    1b98:	.word	0x00012e88

00001b9c <storage_configure()>:
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    *ms10 = tm.Second & 1 ? 100 : 0;
}

void storage_configure()
{
    1b9c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    #if defined SD_SCK
      SPI.setMOSI(SD_MOSI);
    1ba0:	movs	r1, #7
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    *ms10 = tm.Second & 1 ? 100 : 0;
}

void storage_configure()
{
    1ba2:	sub	sp, #56	; 0x38
    #if defined SD_SCK
      SPI.setMOSI(SD_MOSI);
    1ba4:	ldr	r0, [pc, #452]	; (1d6c <storage_configure()+0x1d0>)
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    1ba6:	ldr	r5, [pc, #456]	; (1d70 <storage_configure()+0x1d4>)
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    1ba8:	ldr.w	r8, [pc, #508]	; 1da8 <storage_configure()+0x20c>
    1bac:	bl	2c5c <SPIClass::setMOSI(unsigned char)>
      SPI.setMISO(SD_MISO);
    1bb0:	movs	r1, #12
    1bb2:	ldr	r0, [pc, #440]	; (1d6c <storage_configure()+0x1d0>)
    1bb4:	bl	2cf8 <SPIClass::setMISO(unsigned char)>
      SPI.setSCK(SD_SCK);
    1bb8:	movs	r1, #14
    1bba:	ldr	r0, [pc, #432]	; (1d6c <storage_configure()+0x1d0>)
    1bbc:	bl	2d8c <SPIClass::setSCK(unsigned char)>
    #endif

    // Set Time callback
    FsDateTime::callback = dateTime;
    1bc0:	ldr	r3, [pc, #432]	; (1d74 <storage_configure()+0x1d8>)
    1bc2:	ldr	r2, [pc, #436]	; (1d78 <storage_configure()+0x1dc>)
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    1bc4:	ldr	r0, [pc, #436]	; (1d7c <storage_configure()+0x1e0>)
    1bc6:	str	r2, [r3, #0]
    1bc8:	movs	r1, #0
    1bca:	bl	a26c <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    1bce:	ldr	r0, [pc, #428]	; (1d7c <storage_configure()+0x1e0>)
    1bd0:	bl	a1bc <Print::println()>
                Serial.println("No sdio storage"); 
            }
      }
      else if(cs[ii]<BUILTIN_SDCARD)
      { 
            sdCsInit(cs[ii]);
    1bd4:	movs	r0, #10
    1bd6:	bl	1b64 <sdCsInit(unsigned char)>
            delay(100);
    1bda:	movs	r0, #100	; 0x64
    1bdc:	bl	9550 <delay>
    1be0:	movs	r6, #0
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    1be2:	mov.w	ip, #10
    spiConfigBackupOptions = spiConfig.options;
    1be6:	mov.w	lr, #0
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    1bea:	ldr	r3, [pc, #404]	; (1d80 <storage_configure()+0x1e4>)
    1bec:	str	r3, [sp, #28]
    1bee:	strb.w	ip, [sp, #20]
    1bf2:	strb.w	lr, [sp, #21]
    1bf6:	str.w	r8, [sp, #24]
    1bfa:	add	r2, sp, #20
    1bfc:	ldmia	r2, {r0, r1, r2}
    1bfe:	add	r4, sp, #32
    1c00:	stmia.w	r4, {r0, r1, r2}
    1c04:	str	r3, [sp, #40]	; 0x28
    1c06:	strb.w	ip, [sp, #32]
    1c0a:	strb.w	lr, [sp, #33]	; 0x21
    1c0e:	str.w	r8, [sp, #36]	; 0x24
    1c12:	ldmia.w	r4, {r0, r1, r2}
    1c16:	str.w	r3, [r5, #1212]	; 0x4bc
    1c1a:	add	r3, sp, #44	; 0x2c
    1c1c:	stmia.w	r3, {r0, r1, r2}
   *
   * \param[in] config SPI configuration.
   * \return generic card pointer.
   */
  SdCard* newCard(SdSpiConfig config) {
    m_spiCard.begin(config);
    1c20:	ldr	r4, [pc, #352]	; (1d84 <storage_configure()+0x1e8>)
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    1c22:	strb.w	ip, [r5, #1204]	; 0x4b4
    spiConfigBackupOptions = spiConfig.options;
    1c26:	strb.w	lr, [r5, #1205]	; 0x4b5
    spiConfigBackupClock = spiConfig.maxSck;
    1c2a:	str.w	r8, [r5, #1208]	; 0x4b8
    1c2e:	ldmia	r3, {r1, r2, r3}
    1c30:	mov	r0, r4
    1c32:	bl	7a2c <SdSpiCard::begin(SdSpiConfig)>
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    m_card = m_cardFactory.newCard(spiConfig);
    return m_card && !m_card->errorCode();
    1c36:	ldrb.w	r9, [r5, #1199]	; 0x4af
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    m_card = m_cardFactory.newCard(spiConfig);
    1c3a:	str.w	r4, [r5, #1168]	; 0x490
    1c3e:	uxth	r7, r6
    return m_card && !m_card->errorCode();
    1c40:	cmp.w	r9, #0
    1c44:	beq.n	1c50 <storage_configure()+0xb4>
            uint16_t tries=0;
            while(!sdx[ii].sdfs.begin(SdSpiConfig(cs[ii], SHARED_SPI, SPI_SPEED, &mySpi)) && tries<10)
    1c46:	cmp	r7, #9
    1c48:	ite	hi
    1c4a:	movhi	r4, #0
    1c4c:	movls	r4, #1
    1c4e:	b.n	1c60 <storage_configure()+0xc4>
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    1c50:	mov	r1, r4
    1c52:	subw	r0, r4, #1180	; 0x49c
    1c56:	bl	75f8 <FsVolume::begin(BlockDeviceInterface*)>
    1c5a:	cmp	r0, #0
    1c5c:	beq.n	1c46 <storage_configure()+0xaa>
    1c5e:	mov	r4, r9
    1c60:	adds	r6, #1
    1c62:	cbz	r4, 1c7e <storage_configure()+0xe2>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    1c64:	mov	r1, r7
    1c66:	ldr	r0, [pc, #276]	; (1d7c <storage_configure()+0x1e0>)
    1c68:	bl	a26c <Print::print(long)>
            { Serial.print(tries); Serial.print(" "); tries++; delay(1000); } 
    1c6c:	ldr	r1, [pc, #280]	; (1d88 <storage_configure()+0x1ec>)
    1c6e:	ldr	r0, [pc, #268]	; (1d7c <storage_configure()+0x1e0>)
    1c70:	bl	19e4 <Print::print(char const*)>
    1c74:	mov.w	r0, #1000	; 0x3e8
    1c78:	bl	9550 <delay>
      else if(cs[ii]<BUILTIN_SDCARD)
      { 
            sdCsInit(cs[ii]);
            delay(100);
            uint16_t tries=0;
            while(!sdx[ii].sdfs.begin(SdSpiConfig(cs[ii], SHARED_SPI, SPI_SPEED, &mySpi)) && tries<10)
    1c7c:	b.n	1be2 <storage_configure()+0x46>
            { Serial.print(tries); Serial.print(" "); tries++; delay(1000); } 

            if(tries<10) 
    1c7e:	cmp	r7, #9
    1c80:	ldr	r6, [pc, #264]	; (1d8c <storage_configure()+0x1f0>)
    1c82:	ldr	r5, [pc, #268]	; (1d90 <storage_configure()+0x1f4>)
    1c84:	ldr	r7, [pc, #268]	; (1d94 <storage_configure()+0x1f8>)
    1c86:	bls.n	1c9a <storage_configure()+0xfe>
            {
                status=1;
            }
            else
            {
                Serial.println("No spi storage");
    1c88:	ldr	r1, [pc, #268]	; (1d98 <storage_configure()+0x1fc>)
    1c8a:	ldr	r0, [pc, #240]	; (1d7c <storage_configure()+0x1e0>)
    1c8c:	bl	758 <Print::println(char const*)>
      }
      else
      {
            diskSize[ii]=0;
            diskSpace[ii]=0;
            clusterSize[ii]=1;
    1c90:	movs	r3, #1
            diskSpace[ii]=diskSize[ii]=sdx[ii].sdfs.freeClusterCount();
            Serial.println(diskSize[ii]) ;Serial.print(" ");
      }
      else
      {
            diskSize[ii]=0;
    1c92:	str	r4, [r6, #0]
            diskSpace[ii]=0;
    1c94:	str	r4, [r5, #0]
            clusterSize[ii]=1;
    1c96:	str	r3, [r7, #0]
      }
    }
}
    1c98:	b.n	1d66 <storage_configure()+0x1ca>
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
		  * (uint64_t)sdfs.bytesPerCluster();
	}
	uint64_t totalSize() {
		return (uint64_t)sdfs.clusterCount() * (uint64_t)sdfs.bytesPerCluster();
    1c9a:	ldr	r0, [pc, #256]	; (1d9c <storage_configure()+0x200>)
    1c9c:	bl	1a20 <FsVolume::clusterCount() const>
    1ca0:	mov	sl, r0
    1ca2:	ldr	r0, [pc, #248]	; (1d9c <storage_configure()+0x200>)
    1ca4:	bl	1a00 <FsVolume::bytesPerCluster() const>
    1ca8:	umull	r8, r9, sl, r0
	}
	bool rmdir(const char *filepath) {
		return sdfs.rmdir(filepath);
	}
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
    1cac:	ldr	r0, [pc, #236]	; (1d9c <storage_configure()+0x200>)
    1cae:	bl	1a38 <FsVolume::freeClusterCount() const>
    1cb2:	rsb	sl, r0, sl
		  * (uint64_t)sdfs.bytesPerCluster();
    1cb6:	ldr	r0, [pc, #228]	; (1d9c <storage_configure()+0x200>)
    1cb8:	bl	1a00 <FsVolume::bytesPerCluster() const>
    1cbc:	umull	r2, r3, sl, r0
    1cc0:	strd	r2, r3, [sp, #8]
      if (status)
      {
            uint64_t totalSize = sdx[ii].totalSize();
            uint64_t usedSize  = sdx[ii].usedSize();

            Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]); 
    1cc4:	ldr	r3, [pc, #216]	; (1da0 <storage_configure()+0x204>)
    1cc6:	ldr	r1, [pc, #220]	; (1da4 <storage_configure()+0x208>)
    1cc8:	ldr	r3, [r3, #0]
    1cca:	str	r3, [sp, #0]
    1ccc:	mov	r2, r4
    1cce:	movs	r3, #10
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
	size_t print(int64_t n);
	size_t print(uint64_t n)			{ return printNumber64(n, 10, 0); }
    1cd0:	mov.w	sl, #10
    1cd4:	ldr	r0, [pc, #164]	; (1d7c <storage_configure()+0x1e0>)
    1cd6:	bl	a1dc <Print::printf(char const*, ...)>
    1cda:	mov	r2, r8
    1cdc:	mov	r3, r9
    1cde:	str	r4, [sp, #4]
    1ce0:	str.w	sl, [sp]
    1ce4:	ldr	r0, [pc, #148]	; (1d7c <storage_configure()+0x1e0>)
    1ce6:	bl	a27c <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
            Serial.print(totalSize); Serial.print(" "); Serial.println(usedSize);
    1cea:	ldr	r1, [pc, #156]	; (1d88 <storage_configure()+0x1ec>)
    1cec:	ldr	r0, [pc, #140]	; (1d7c <storage_configure()+0x1e0>)
    1cee:	bl	19e4 <Print::print(char const*)>
    1cf2:	ldrd	r2, r3, [sp, #8]
    1cf6:	str	r4, [sp, #4]
    1cf8:	str.w	sl, [sp]
    1cfc:	ldr	r0, [pc, #124]	; (1d7c <storage_configure()+0x1e0>)
    1cfe:	bl	a27c <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
	size_t println(int64_t n)			{ return print(n) + println(); }
	size_t println(uint64_t n)			{ return print(n) + println(); }
    1d02:	ldr	r0, [pc, #120]	; (1d7c <storage_configure()+0x1e0>)
    1d04:	bl	a1bc <Print::println()>

            Serial.print(sdx[ii].sdfs.clusterCount()); Serial.print(" "); 
    1d08:	ldr	r0, [pc, #144]	; (1d9c <storage_configure()+0x200>)
    1d0a:	bl	1a20 <FsVolume::clusterCount() const>
    1d0e:	mov	r1, r0
    1d10:	ldr	r0, [pc, #104]	; (1d7c <storage_configure()+0x1e0>)
    1d12:	bl	750 <Print::print(unsigned long)>
    1d16:	ldr	r1, [pc, #112]	; (1d88 <storage_configure()+0x1ec>)
    1d18:	ldr	r0, [pc, #96]	; (1d7c <storage_configure()+0x1e0>)
    1d1a:	bl	19e4 <Print::print(char const*)>
            Serial.print(sdx[ii].sdfs.freeClusterCount()); Serial.print(" ");
    1d1e:	ldr	r0, [pc, #124]	; (1d9c <storage_configure()+0x200>)
    1d20:	bl	1a38 <FsVolume::freeClusterCount() const>
    1d24:	mov	r1, r0
    1d26:	ldr	r0, [pc, #84]	; (1d7c <storage_configure()+0x1e0>)
    1d28:	bl	750 <Print::print(unsigned long)>
    1d2c:	ldr	r1, [pc, #88]	; (1d88 <storage_configure()+0x1ec>)
    1d2e:	ldr	r0, [pc, #76]	; (1d7c <storage_configure()+0x1e0>)
    1d30:	bl	19e4 <Print::print(char const*)>

            clusterSize[ii] = sdx[ii].sdfs.bytesPerCluster()/512; // count sectors
    1d34:	ldr	r0, [pc, #100]	; (1d9c <storage_configure()+0x200>)
    1d36:	bl	1a00 <FsVolume::bytesPerCluster() const>
    1d3a:	lsrs	r1, r0, #9
            Serial.println(clusterSize[ii]) ;Serial.print(" ");
    1d3c:	ldr	r0, [pc, #60]	; (1d7c <storage_configure()+0x1e0>)
            Serial.print(totalSize); Serial.print(" "); Serial.println(usedSize);

            Serial.print(sdx[ii].sdfs.clusterCount()); Serial.print(" "); 
            Serial.print(sdx[ii].sdfs.freeClusterCount()); Serial.print(" ");

            clusterSize[ii] = sdx[ii].sdfs.bytesPerCluster()/512; // count sectors
    1d3e:	str	r1, [r7, #0]
            Serial.println(clusterSize[ii]) ;Serial.print(" ");
    1d40:	bl	19ec <Print::println(unsigned long)>
    1d44:	ldr	r1, [pc, #64]	; (1d88 <storage_configure()+0x1ec>)
    1d46:	ldr	r0, [pc, #52]	; (1d7c <storage_configure()+0x1e0>)
    1d48:	bl	19e4 <Print::print(char const*)>

            diskSpace[ii]=diskSize[ii]=sdx[ii].sdfs.freeClusterCount();
    1d4c:	ldr	r0, [pc, #76]	; (1d9c <storage_configure()+0x200>)
    1d4e:	bl	1a38 <FsVolume::freeClusterCount() const>
    1d52:	mov	r1, r0
    1d54:	str	r0, [r6, #0]
    1d56:	str	r0, [r5, #0]
            Serial.println(diskSize[ii]) ;Serial.print(" ");
    1d58:	ldr	r0, [pc, #32]	; (1d7c <storage_configure()+0x1e0>)
    1d5a:	bl	19ec <Print::println(unsigned long)>
    1d5e:	ldr	r1, [pc, #40]	; (1d88 <storage_configure()+0x1ec>)
    1d60:	ldr	r0, [pc, #24]	; (1d7c <storage_configure()+0x1e0>)
    1d62:	bl	19e4 <Print::print(char const*)>
            diskSize[ii]=0;
            diskSpace[ii]=0;
            clusterSize[ii]=1;
      }
    }
}
    1d66:	add	sp, #56	; 0x38
    1d68:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1d6c:	.word	0x1fff12f8
    1d70:	.word	0x20017c38
    1d74:	.word	0x2001a690
    1d78:	.word	0x0000188b
    1d7c:	.word	0x1fff1348
    1d80:	.word	0x200191b0
    1d84:	.word	0x200180d8
    1d88:	.word	0x00012501
    1d8c:	.word	0x1fff2230
    1d90:	.word	0x1fff2228
    1d94:	.word	0x2001815c
    1d98:	.word	0x0001285c
    1d9c:	.word	0x20017c3c
    1da0:	.word	0x1fff0f40
    1da4:	.word	0x0001286b
    1da8:	.word	0x01f78a40

00001dac <listDisks()>:

void listDisks(void)
{
    1dac:	push	{r0, r1, r2, r4, r5, lr}
    for(int ii=0;ii<nsd;ii++)
    {
        Serial.print("\n"); 
    1dae:	ldr	r4, [pc, #60]	; (1dec <listDisks()+0x40>)
    1db0:	ldr	r5, [pc, #60]	; (1df0 <listDisks()+0x44>)
    1db2:	mov	r0, r4
    1db4:	mov	r1, r5
    1db6:	bl	19e4 <Print::print(char const*)>
        Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]);
    1dba:	ldr	r3, [pc, #56]	; (1df4 <listDisks()+0x48>)
    1dbc:	ldr	r1, [pc, #56]	; (1df8 <listDisks()+0x4c>)
    1dbe:	ldr	r3, [r3, #0]
    1dc0:	str	r3, [sp, #0]
    1dc2:	movs	r2, #0
    1dc4:	movs	r3, #10
    1dc6:	mov	r0, r4
    1dc8:	bl	a1dc <Print::printf(char const*, ...)>
        Serial.printf("%d %d",sdx[ii].sdfs.freeClusterCount(),diskSize[ii]);
    1dcc:	ldr	r0, [pc, #44]	; (1dfc <listDisks()+0x50>)
    1dce:	bl	1a38 <FsVolume::freeClusterCount() const>
    1dd2:	ldr	r3, [pc, #44]	; (1e00 <listDisks()+0x54>)
    1dd4:	ldr	r1, [pc, #44]	; (1e04 <listDisks()+0x58>)
    1dd6:	ldr	r3, [r3, #0]
    1dd8:	mov	r2, r0
    1dda:	mov	r0, r4
    1ddc:	bl	a1dc <Print::printf(char const*, ...)>
    }
    Serial.print("\n"); 
    1de0:	mov	r1, r5
    1de2:	mov	r0, r4
    1de4:	bl	19e4 <Print::print(char const*)>
}
    1de8:	add	sp, #12
    1dea:	pop	{r4, r5, pc}
    1dec:	.word	0x1fff1348
    1df0:	.word	0x00012da8
    1df4:	.word	0x1fff0f40
    1df8:	.word	0x0001286b
    1dfc:	.word	0x20017c3c
    1e00:	.word	0x1fff2230
    1e04:	.word	0x0001287d

00001e08 <checkReboot()>:
{
    int ii=0;
    while((ii<nsd) && (diskSpace[ii]<MIN_SPACE)) ii++;
    if(ii<nsd) CPU_RESTART;
    return -1;
}
    1e08:	mov.w	r0, #4294967295
    1e0c:	bx	lr
    1e0e:	Address 0x00001e0e is out of bounds.


00001e10 <saveData(short)>:
    return 1;
}

/* main data filing routine */
int16_t saveData(int16_t status)
{   static char dirName[80];
    1e10:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    static char fileName[80];
    static char header[512];
    static int dirFlag=0;

    if(status<CLOSED) return status; // we are stopped: don't do anything
    1e14:	subs	r4, r0, #0
    return 1;
}

/* main data filing routine */
int16_t saveData(int16_t status)
{   static char dirName[80];
    1e16:	sub	sp, #84	; 0x54
    static char fileName[80];
    static char header[512];
    static int dirFlag=0;

    if(status<CLOSED) return status; // we are stopped: don't do anything
    1e18:	blt.w	1fd4 <saveData(short)+0x1c4>

    //fetch data from circular buffer
    if(pullData(diskBuffer,NDBL))
    1e1c:	movs	r1, #4
    1e1e:	ldr	r0, [pc, #672]	; (20c0 <saveData(short)+0x2b0>)
    1e20:	bl	1b20 <pullData(unsigned long*, unsigned long)>
    1e24:	cmp	r0, #0
    1e26:	beq.n	1f1e <saveData(short)+0x10e>
    {   disk_count++;
    1e28:	ldr	r2, [pc, #664]	; (20c4 <saveData(short)+0x2b4>)
    1e2a:	ldr	r3, [r2, #0]
    1e2c:	adds	r3, #1
    1e2e:	str	r3, [r2, #0]
        if(status==CLOSED) // file closed: should open
    1e30:	cbnz	r4, 1e74 <saveData(short)+0x64>
        bool doTransactions=true;

};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}
    1e32:	ldr	r3, [pc, #660]	; (20c8 <saveData(short)+0x2b8>)

static SDClass *checkDiskSpace(void)
{   static int isd_ = nsd;

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
    1e34:	ldr	r7, [pc, #660]	; (20cc <saveData(short)+0x2bc>)
    1e36:	ldr.w	r9, [pc, #748]	; 2124 <saveData(short)+0x314>
        bool doTransactions=true;

};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}
    1e3a:	movs	r2, #1
    1e3c:	strb	r2, [r3, #8]
    1e3e:	mov	r8, r3
    1e40:	mov	r5, r7

static SDClass *checkDiskSpace(void)
{   static int isd_ = nsd;

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
    1e42:	ldr	r4, [r7, #0]
    1e44:	ldr	r6, [pc, #644]	; (20cc <saveData(short)+0x2bc>)
    1e46:	cmp	r4, #0
    1e48:	bgt.n	1f46 <saveData(short)+0x136>
    1e4a:	ldr.w	r3, [r9, r4, lsl #2]
    1e4e:	cmp	r3, #0
    1e50:	beq.w	1fd8 <saveData(short)+0x1c8>
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    1e54:	ldr	r0, [pc, #632]	; (20d0 <saveData(short)+0x2c0>)
    1e56:	mov.w	r3, #1224	; 0x4c8
    1e5a:	mla	r0, r3, r4, r0
    1e5e:	adds	r0, #4
    1e60:	bl	1a38 <FsVolume::freeClusterCount() const>
    1e64:	ldr	r3, [pc, #620]	; (20d4 <saveData(short)+0x2c4>)
    1e66:	cmp.w	r0, #307200	; 0x4b000
    1e6a:	str.w	r0, [r3, r4, lsl #2]
    1e6e:	bcc.w	1fd8 <saveData(short)+0x1c8>
    1e72:	b.n	1f46 <saveData(short)+0x136>
            {
               return MUST_REBOOT; // if file open fails: don't do anything
            }
        }
        //
        if(status==OPENED) // file is open: write first record (header)
    1e74:	cmp	r4, #1
    1e76:	bne.n	1f04 <saveData(short)+0xf4>
     * @param header is pointer to header
     * 
     */
    #define MAGIC "WMXZ"
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    1e78:	bl	9440 <rtc_get>
    1e7c:	add	r1, sp, #24
    1e7e:	bl	153c <breakTime(unsigned long, tmElements_t&)>

    int nd=sprintf(header,"%s%04d%02d%02d_%02d%02d%02d",
            MAGIC,tmYearToCalendar(tm.Year),tm.Month,tm.Day,tm.Hour,tm.Minute,tm.Second);
    1e82:	ldrb.w	r2, [sp, #24]
    1e86:	str	r2, [sp, #16]
    1e88:	ldrb.w	r2, [sp, #25]
    1e8c:	str	r2, [sp, #12]
    1e8e:	ldrb.w	r2, [sp, #26]
    1e92:	ldr	r5, [pc, #580]	; (20d8 <saveData(short)+0x2c8>)
    1e94:	ldrb.w	r3, [sp, #30]
    1e98:	str	r2, [sp, #8]
    1e9a:	ldrb.w	r2, [sp, #28]
    1e9e:	str	r2, [sp, #4]
    1ea0:	ldrb.w	r2, [sp, #29]
    1ea4:	str	r2, [sp, #0]
    1ea6:	addw	r3, r3, #1970	; 0x7b2
    1eaa:	ldr	r2, [pc, #560]	; (20dc <saveData(short)+0x2cc>)
    1eac:	ldr	r1, [pc, #560]	; (20e0 <saveData(short)+0x2d0>)
    1eae:	mov	r0, r5
    1eb0:	bl	beb8 <sprintf>
    char *ptr = header+(nd+1);
    1eb4:	adds	r0, #1

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    1eb6:	movs	r2, #4
    1eb8:	str	r2, [r5, r0]
    iptr[1] = (int32_t)SerNum;      // serial number
    1eba:	ldr	r2, [pc, #552]	; (20e4 <saveData(short)+0x2d4>)
    tmElements_t tm;
    breakTime(rtc_get(), tm);

    int nd=sprintf(header,"%s%04d%02d%02d_%02d%02d%02d",
            MAGIC,tmYearToCalendar(tm.Year),tm.Month,tm.Day,tm.Hour,tm.Minute,tm.Second);
    char *ptr = header+(nd+1);
    1ebc:	adds	r3, r5, r0

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    iptr[1] = (int32_t)SerNum;      // serial number
    1ebe:	ldr	r2, [r2, #0]
    1ec0:	str	r2, [r3, #4]
    iptr[2] = FSAMP;
    1ec2:	ldr	r2, [pc, #548]	; (20e8 <saveData(short)+0x2d8>)
    1ec4:	str	r2, [r3, #8]
    iptr[3] = NCHAN_ACQ;
    iptr[4] = t_acq;
    1ec6:	ldr	r2, [pc, #548]	; (20ec <saveData(short)+0x2dc>)
    1ec8:	ldr	r2, [r2, #0]
    1eca:	str	r2, [r3, #16]

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    iptr[1] = (int32_t)SerNum;      // serial number
    iptr[2] = FSAMP;
    iptr[3] = NCHAN_ACQ;
    1ecc:	movs	r4, #2
    iptr[4] = t_acq;
    iptr[5] = 0;
    1ece:	movs	r2, #0

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    iptr[1] = (int32_t)SerNum;      // serial number
    iptr[2] = FSAMP;
    iptr[3] = NCHAN_ACQ;
    1ed0:	str	r4, [r3, #12]
    iptr[4] = t_acq;
    iptr[5] = 0;
    1ed2:	str	r2, [r3, #20]

    uint32_t *uptr = (uint32_t*) header;
    uptr[127] = 0x55555555;
    1ed4:	movs	r3, #85	; 0x55
    1ed6:	strb.w	r3, [r5, #508]	; 0x1fc
    1eda:	strb.w	r3, [r5, #509]	; 0x1fd
    1ede:	strb.w	r3, [r5, #510]	; 0x1fe
    1ee2:	strb.w	r3, [r5, #511]	; 0x1ff
    1ee6:	ldr	r3, [pc, #520]	; (20f0 <saveData(short)+0x2e0>)
    1ee8:	ldr	r0, [r3, #16]
	virtual size_t write(const uint8_t *buf, size_t size) {
		return (f) ? f->write((void*)buf, size) : 0;
	}

	size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    1eea:	cbnz	r0, 1ef2 <saveData(short)+0xe2>
                file = msd->open(fileName, FILE_WRITE_BEGIN); 
                if(file) 
                    status = OPENED; 
                else 
                {   Serial.println("Failing open file");
                    return MUST_REBOOT; 
    1eec:	mvn.w	r0, #1
    1ef0:	b.n	2202 <saveData(short)+0x3f2>
    1ef2:	ldr	r3, [r0, #0]
    1ef4:	mov.w	r2, #512	; 0x200
    1ef8:	ldr	r3, [r3, #12]
    1efa:	mov	r1, r5
    1efc:	blx	r3
            }
        }
        //
        if(status==OPENED) // file is open: write first record (header)
        {   makeHeader(header);
            if(file.write((const void*)header,512) < 512) return MUST_REBOOT; else status=2;
    1efe:	cmp.w	r0, #512	; 0x200
    1f02:	bcc.n	1eec <saveData(short)+0xdc>
    1f04:	ldr	r3, [pc, #488]	; (20f0 <saveData(short)+0x2e0>)
    1f06:	ldr	r0, [r3, #16]
    1f08:	cmp	r0, #0
    1f0a:	beq.n	1eec <saveData(short)+0xdc>
    1f0c:	ldr	r3, [r0, #0]
    1f0e:	ldr	r1, [pc, #432]	; (20c0 <saveData(short)+0x2b0>)
    1f10:	ldr	r3, [r3, #12]
    1f12:	mov.w	r2, #4096	; 0x1000
    1f16:	blx	r3
        }
        //
        if(status>=RUNNING) // file is open, header written: store data records
        {   
            if(file.write((const void *)diskBuffer,4*MAX_DISK_BUFFER) < 4*MAX_DISK_BUFFER) return MUST_REBOOT;
    1f18:	cmp.w	r0, #4096	; 0x1000
    1f1c:	bcc.n	1eec <saveData(short)+0xdc>
        }
    }
    // following is done independent of data availability
    if(status==DOCLOSE) // should close file
    1f1e:	cmp	r4, #3
    1f20:	bne.n	1f30 <saveData(short)+0x120>
    {
        // writes are done, so enable again transaction activations
        file.flush();
    1f22:	ldr	r0, [pc, #460]	; (20f0 <saveData(short)+0x2e0>)
    1f24:	bl	9ba <File::flush()>
        file.close();
    1f28:	ldr	r0, [pc, #452]	; (20f0 <saveData(short)+0x2e0>)
    1f2a:	bl	f10 <File::close()>
    1f2e:	b.n	1fd0 <saveData(short)+0x1c0>
        status = CLOSED;
    }
    if(status==MUSTSTOP) // should close file and stop
    1f30:	cmp	r4, #4
    1f32:	bne.n	1fd4 <saveData(short)+0x1c4>
    {   
        file.flush();
    1f34:	ldr	r0, [pc, #440]	; (20f0 <saveData(short)+0x2e0>)
    1f36:	bl	9ba <File::flush()>
        file.close();
    1f3a:	ldr	r0, [pc, #436]	; (20f0 <saveData(short)+0x2e0>)
    1f3c:	bl	f10 <File::close()>
        status = STOPPED;
    1f40:	mov.w	r0, #4294967295
    1f44:	b.n	2202 <saveData(short)+0x3f2>
        bool doTransactions=true;

};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}
    1f46:	movs	r3, #0
    1f48:	strb.w	r3, [r8, #8]

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    doTransactions(false);
    if(isd<nsd) 
    1f4c:	ldr	r3, [r6, #0]
    1f4e:	ldr	r4, [pc, #380]	; (20cc <saveData(short)+0x2bc>)
    1f50:	cmp	r3, #0
    1f52:	bgt.n	1f8e <saveData(short)+0x17e>
    {   sdx[isd].sdfs.chvol();
    1f54:	ldr	r5, [pc, #376]	; (20d0 <saveData(short)+0x2c0>)
    bool chdir(const char* path) {
    return m_fVol ? m_fVol->chdir(path) :
           m_xVol ? m_xVol->chdir(path) : false;
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
    1f56:	ldr	r2, [pc, #412]	; (20f4 <saveData(short)+0x2e4>)
        Serial.println(); Serial.print(isd);
    1f58:	ldr	r0, [pc, #412]	; (20f8 <saveData(short)+0x2e8>)
    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    doTransactions(false);
    if(isd<nsd) 
    {   sdx[isd].sdfs.chvol();
    1f5a:	mov.w	r7, #1224	; 0x4c8
    1f5e:	mla	r3, r7, r3, r5
    1f62:	adds	r3, #4
    1f64:	str	r3, [r2, #0]
        Serial.println(); Serial.print(isd);
    1f66:	bl	a1bc <Print::println()>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    1f6a:	ldr	r1, [r4, #0]
    1f6c:	ldr	r0, [pc, #392]	; (20f8 <saveData(short)+0x2e8>)
    1f6e:	bl	a26c <Print::print(long)>
        Serial.print(": "); Serial.print(sdx[isd].sdfs.freeClusterCount());
    1f72:	ldr	r1, [pc, #392]	; (20fc <saveData(short)+0x2ec>)
    1f74:	ldr	r0, [pc, #384]	; (20f8 <saveData(short)+0x2e8>)
    1f76:	bl	19e4 <Print::print(char const*)>
    1f7a:	ldr	r0, [r4, #0]
    1f7c:	mla	r0, r7, r0, r5
    1f80:	adds	r0, #4
    1f82:	bl	1a38 <FsVolume::freeClusterCount() const>
    1f86:	mov	r1, r0
    1f88:	ldr	r0, [pc, #364]	; (20f8 <saveData(short)+0x2e8>)
    1f8a:	bl	750 <Print::print(unsigned long)>
    }
    //
    if(isd != isd_) hour_=0; // set hour_ to zero to trigger creation of directories in new disk
    1f8e:	ldr	r2, [pc, #368]	; (2100 <saveData(short)+0x2f0>)
    1f90:	ldr	r3, [r6, #0]
    1f92:	ldr	r1, [r2, #0]
    isd_=isd;
    1f94:	str	r3, [r2, #0]
    {   sdx[isd].sdfs.chvol();
        Serial.println(); Serial.print(isd);
        Serial.print(": "); Serial.print(sdx[isd].sdfs.freeClusterCount());
    }
    //
    if(isd != isd_) hour_=0; // set hour_ to zero to trigger creation of directories in new disk
    1f96:	cmp	r3, r1
    1f98:	it	ne
    1f9a:	ldrne	r1, [pc, #360]	; (2104 <saveData(short)+0x2f4>)
    //fetch data from circular buffer
    if(pullData(diskBuffer,NDBL))
    {   disk_count++;
        if(status==CLOSED) // file closed: should open
        {   //doTransactions(true);
            if(!(msd=checkDiskSpace())) return MUST_REBOOT;
    1f9c:	ldr	r5, [pc, #360]	; (2108 <saveData(short)+0x2f8>)
    {   sdx[isd].sdfs.chvol();
        Serial.println(); Serial.print(isd);
        Serial.print(": "); Serial.print(sdx[isd].sdfs.freeClusterCount());
    }
    //
    if(isd != isd_) hour_=0; // set hour_ to zero to trigger creation of directories in new disk
    1f9e:	itt	ne
    1fa0:	movne	r0, #0
    1fa2:	strne	r0, [r1, #0]
    isd_=isd;
    if(isd==nsd) return (SDClass *) 0; else return &sdx[isd];
    1fa4:	cmp	r3, #1
    1fa6:	ittte	ne
    1fa8:	ldrne	r2, [pc, #292]	; (20d0 <saveData(short)+0x2c0>)
    1faa:	movne.w	r1, #1224	; 0x4c8
    1fae:	mlane	r3, r1, r3, r2
    1fb2:	moveq	r3, #0
    //fetch data from circular buffer
    if(pullData(diskBuffer,NDBL))
    {   disk_count++;
        if(status==CLOSED) // file closed: should open
        {   //doTransactions(true);
            if(!(msd=checkDiskSpace())) return MUST_REBOOT;
    1fb4:	str	r3, [r5, #0]
    1fb6:	cmp	r3, #0
    1fb8:	beq.n	1eec <saveData(short)+0xdc>
            //
            if(newDirectory(dirName,dirFlag)) 
    1fba:	ldr	r4, [pc, #336]	; (210c <saveData(short)+0x2fc>)
    1fbc:	ldr	r7, [r4, #0]
    isd_=isd;
    if(isd==nsd) return (SDClass *) 0; else return &sdx[isd];
}

static int16_t newDirectory(char *dirName, int dirFlag)
{ if(newHour())
    1fbe:	bl	1518 <newHour()>
    1fc2:	cbnz	r0, 1fe0 <saveData(short)+0x1d0>
            if(newDirectory(dirName,dirFlag)) 
            {   if(!msd->sdfs.exists(dirName) && !msd->sdfs.mkdir(dirName)) dirFlag++;          
                if(!msd->sdfs.chdir(dirName)) dirFlag++; else dirFlag=0;
            }
            //
            if(dirFlag>5) return MUST_REBOOT;   // too many directory errors
    1fc4:	ldr	r3, [r4, #0]
    1fc6:	cmp	r3, #5
    1fc8:	bgt.n	1eec <saveData(short)+0xdc>
            if(dirFlag>0) return CLOSED;        // create new directory with different name
    1fca:	cmp	r3, #0
    1fcc:	ble.w	2172 <saveData(short)+0x362>
    1fd0:	movs	r0, #0
    1fd2:	b.n	2202 <saveData(short)+0x3f2>
    1fd4:	mov	r0, r4
    1fd6:	b.n	2202 <saveData(short)+0x3f2>
static SDClass *checkDiskSpace(void)
{   static int isd_ = nsd;

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    1fd8:	ldr	r3, [r5, #0]
    1fda:	adds	r3, #1
    1fdc:	str	r3, [r5, #0]
    1fde:	b.n	1e42 <saveData(short)+0x32>

static int16_t newDirectory(char *dirName, int dirFlag)
{ if(newHour())
    {   
        tmElements_t tm;
        breakTime(rtc_get(), tm);
    1fe0:	bl	9440 <rtc_get>
    1fe4:	add	r1, sp, #24
    1fe6:	bl	153c <breakTime(unsigned long, tmElements_t&)>
    1fea:	ldr	r2, [pc, #248]	; (20e4 <saveData(short)+0x2d4>)
    1fec:	ldrb.w	lr, [sp, #26]
    1ff0:	ldrb.w	r0, [sp, #28]
    1ff4:	ldrb.w	r1, [sp, #29]
    1ff8:	ldrb.w	r3, [sp, #30]
        if(!dirFlag)
    1ffc:	cbnz	r7, 201a <saveData(short)+0x20a>
        {
            sprintf(dirName, "/%s%06x_%04d%02d%02d/%02d/", 
                          DirPrefix,(unsigned int)SerNum,
                                  tmYearToCalendar(tm.Year),tm.Month, tm.Day, tm.Hour);
    1ffe:	addw	r3, r3, #1970	; 0x7b2
    2002:	str	r0, [sp, #8]
    2004:	str	r1, [sp, #4]
    2006:	str.w	lr, [sp, #12]
    200a:	str	r3, [sp, #0]
    200c:	ldr	r3, [r2, #0]
    200e:	ldr	r1, [pc, #256]	; (2110 <saveData(short)+0x300>)
    2010:	ldr	r2, [pc, #256]	; (2114 <saveData(short)+0x304>)
    2012:	ldr	r0, [pc, #260]	; (2118 <saveData(short)+0x308>)
    2014:	bl	beb8 <sprintf>
    2018:	b.n	2036 <saveData(short)+0x226>
        }
        else
        {
            sprintf(dirName, "/%s%06x_%04d%02d%02d/%02d_%02d/", 
                          DirPrefix,(unsigned int)SerNum,
                                  tmYearToCalendar(tm.Year),tm.Month, tm.Day, tm.Hour,dirFlag);
    201a:	addw	r3, r3, #1970	; 0x7b2
    201e:	str	r0, [sp, #8]
    2020:	str	r1, [sp, #4]
    2022:	str	r7, [sp, #16]
    2024:	str.w	lr, [sp, #12]
    2028:	str	r3, [sp, #0]
    202a:	ldr	r3, [r2, #0]
    202c:	ldr	r1, [pc, #236]	; (211c <saveData(short)+0x30c>)
    202e:	ldr	r2, [pc, #228]	; (2114 <saveData(short)+0x304>)
    2030:	ldr	r0, [pc, #228]	; (2118 <saveData(short)+0x308>)
    2032:	bl	beb8 <sprintf>
        }

        //
        Serial.print("\n"); Serial.print(dirName);
    2036:	ldr	r1, [pc, #232]	; (2120 <saveData(short)+0x310>)
    2038:	ldr	r0, [pc, #188]	; (20f8 <saveData(short)+0x2e8>)
    203a:	bl	19e4 <Print::print(char const*)>
    203e:	ldr	r1, [pc, #216]	; (2118 <saveData(short)+0x308>)
    2040:	ldr	r0, [pc, #180]	; (20f8 <saveData(short)+0x2e8>)
    2042:	bl	19e4 <Print::print(char const*)>
        if(status==CLOSED) // file closed: should open
        {   //doTransactions(true);
            if(!(msd=checkDiskSpace())) return MUST_REBOOT;
            //
            if(newDirectory(dirName,dirFlag)) 
            {   if(!msd->sdfs.exists(dirName) && !msd->sdfs.mkdir(dirName)) dirFlag++;          
    2046:	ldr	r3, [r5, #0]
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
    2048:	ldr.w	r1, [r3, #1156]	; 0x484
           m_xVol ? m_xVol->exists(path) : false;
    204c:	cbz	r1, 2066 <saveData(short)+0x256>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    204e:	movs	r3, #0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    2050:	ldr	r2, [pc, #196]	; (2118 <saveData(short)+0x308>)
    2052:	strb.w	r3, [sp, #24]
    2056:	add	r0, sp, #24
    2058:	strb.w	r3, [sp, #25]
    205c:	strb.w	r3, [sp, #26]
    2060:	bl	636c <FatFile::open(FatVolume*, char const*, int)>
    2064:	b.n	20aa <saveData(short)+0x29a>
    2066:	ldr.w	r0, [r3, #1160]	; 0x488
    206a:	cbnz	r0, 2092 <saveData(short)+0x282>
    206c:	ldr	r3, [r5, #0]
   * \param[in] pFlag Create missing parent directories if true.
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
    206e:	ldr.w	r1, [r3, #1156]	; 0x484
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
    2072:	cbz	r1, 20b0 <saveData(short)+0x2a0>
    2074:	movs	r3, #0
    2076:	strb.w	r3, [sp, #24]
    207a:	strb.w	r3, [sp, #25]
    207e:	strb.w	r3, [sp, #26]
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    2082:	ldr	r2, [pc, #148]	; (2118 <saveData(short)+0x308>)
    2084:	movs	r3, #1
    2086:	add.w	r1, r1, #1096	; 0x448
    208a:	add	r0, sp, #24
    208c:	bl	64e8 <FatFile::mkdir(FatFile*, char const*, bool)>
    2090:	b.n	2142 <saveData(short)+0x332>
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    2092:	strb.w	r1, [sp, #73]	; 0x49
    2096:	strb.w	r1, [sp, #74]	; 0x4a
    209a:	strb.w	r1, [sp, #75]	; 0x4b
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    209e:	mov	r3, r1
    20a0:	ldr	r2, [pc, #116]	; (2118 <saveData(short)+0x308>)
    20a2:	mov	r1, r0
    20a4:	add	r0, sp, #24
    20a6:	bl	4826 <ExFatFile::open(ExFatVolume*, char const*, int)>
    20aa:	cmp	r0, #0
    20ac:	bne.n	2146 <saveData(short)+0x336>
    20ae:	b.n	206c <saveData(short)+0x25c>
    20b0:	ldr.w	r0, [r3, #1160]	; 0x488
    20b4:	cbnz	r0, 2128 <saveData(short)+0x318>
    20b6:	ldr	r3, [r4, #0]
    20b8:	adds	r3, #1
    20ba:	str	r3, [r4, #0]
    20bc:	b.n	2146 <saveData(short)+0x336>
    20be:	nop
    20c0:	.word	0x200191c0
    20c4:	.word	0x200191bc
    20c8:	.word	0x200191b0
    20cc:	.word	0x1fff222c
    20d0:	.word	0x20017c38
    20d4:	.word	0x1fff2228
    20d8:	.word	0x20017a34
    20dc:	.word	0x000128e8
    20e0:	.word	0x000128ed
    20e4:	.word	0x1fff220c
    20e8:	.word	0x00017700
    20ec:	.word	0x1fff0f34
    20f0:	.word	0x1fff2214
    20f4:	.word	0x2001a69c
    20f8:	.word	0x1fff1348
    20fc:	.word	0x00012500
    2100:	.word	0x1fff0f3c
    2104:	.word	0x1fff2210
    2108:	.word	0x20017c34
    210c:	.word	0x20018150
    2110:	.word	0x00012885
    2114:	.word	0x00012883
    2118:	.word	0x20018160
    211c:	.word	0x000128a0
    2120:	.word	0x00012da8
    2124:	.word	0x1fff2230
    2128:	strb.w	r1, [sp, #73]	; 0x49
    212c:	strb.w	r1, [sp, #74]	; 0x4a
    2130:	strb.w	r1, [sp, #75]	; 0x4b
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    2134:	movs	r3, #1
    2136:	add.w	r1, r0, #1096	; 0x448
    213a:	ldr	r2, [pc, #204]	; (2208 <saveData(short)+0x3f8>)
    213c:	add	r0, sp, #24
    213e:	bl	50c8 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
    2142:	cmp	r0, #0
    2144:	beq.n	20b6 <saveData(short)+0x2a6>
                if(!msd->sdfs.chdir(dirName)) dirFlag++; else dirFlag=0;
    2146:	ldr	r3, [r5, #0]
   * Set volume working directory.
   * \param[in] path Path for volume working directory.
   * \return true for success or false for failure.
   */
    bool chdir(const char* path) {
    return m_fVol ? m_fVol->chdir(path) :
    2148:	ldr.w	r0, [r3, #1156]	; 0x484
           m_xVol ? m_xVol->chdir(path) : false;
    214c:	cbz	r0, 2156 <saveData(short)+0x346>
    214e:	ldr	r1, [pc, #184]	; (2208 <saveData(short)+0x3f8>)
    2150:	bl	6d68 <FatVolume::chdir(char const*)>
    2154:	b.n	2168 <saveData(short)+0x358>
    2156:	ldr.w	r0, [r3, #1160]	; 0x488
    215a:	cbnz	r0, 2162 <saveData(short)+0x352>
    215c:	ldr	r3, [r4, #0]
    215e:	adds	r3, #1
    2160:	b.n	216e <saveData(short)+0x35e>
    2162:	ldr	r1, [pc, #164]	; (2208 <saveData(short)+0x3f8>)
    2164:	bl	4c70 <ExFatVolume::chdir(char const*)>
    2168:	cmp	r0, #0
    216a:	beq.n	215c <saveData(short)+0x34c>
    216c:	movs	r3, #0
    216e:	str	r3, [r4, #0]
    2170:	b.n	1fc4 <saveData(short)+0x1b4>

}
static int16_t newFileName(char *fileName)
{
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    2172:	bl	9440 <rtc_get>
    2176:	add	r1, sp, #24
    2178:	bl	153c <breakTime(unsigned long, tmElements_t&)>
	sprintf(fileName, "%s_%02d%02d%02d.bin", FilePrefix, tm.Hour, tm.Minute, tm.Second);
    217c:	ldrb.w	r2, [sp, #24]
    2180:	str	r2, [sp, #4]
    2182:	ldrb.w	r2, [sp, #25]
    2186:	ldrb.w	r3, [sp, #26]
    218a:	str	r2, [sp, #0]
    218c:	ldr	r1, [pc, #124]	; (220c <saveData(short)+0x3fc>)
    218e:	ldr	r2, [pc, #128]	; (2210 <saveData(short)+0x400>)
    2190:	ldr	r0, [pc, #128]	; (2214 <saveData(short)+0x404>)
    2192:	bl	beb8 <sprintf>
    //
    Serial.print("\n"); Serial.print(isd); Serial.print(": ");Serial.print(fileName);
    2196:	ldr	r1, [pc, #128]	; (2218 <saveData(short)+0x408>)
    2198:	ldr	r0, [pc, #128]	; (221c <saveData(short)+0x40c>)
    219a:	bl	19e4 <Print::print(char const*)>
    219e:	ldr	r1, [r6, #0]
    21a0:	ldr	r0, [pc, #120]	; (221c <saveData(short)+0x40c>)
    21a2:	bl	a26c <Print::print(long)>
    21a6:	ldr	r1, [pc, #120]	; (2220 <saveData(short)+0x410>)
    21a8:	ldr	r0, [pc, #112]	; (221c <saveData(short)+0x40c>)
    21aa:	bl	19e4 <Print::print(char const*)>
    21ae:	ldr	r1, [pc, #100]	; (2214 <saveData(short)+0x404>)
    21b0:	ldr	r0, [pc, #104]	; (221c <saveData(short)+0x40c>)
    21b2:	bl	19e4 <Print::print(char const*)>
            if(dirFlag>5) return MUST_REBOOT;   // too many directory errors
            if(dirFlag>0) return CLOSED;        // create new directory with different name

            if(newFileName(fileName))
            {   
                file = msd->open(fileName, FILE_WRITE_BEGIN); 
    21b6:	ldr	r1, [r5, #0]
    21b8:	ldr	r2, [pc, #88]	; (2214 <saveData(short)+0x404>)
    21ba:	ldr	r3, [r1, #0]
    21bc:	add	r0, sp, #24
    21be:	ldr	r4, [r3, #0]
    21c0:	movs	r3, #2
    21c2:	blx	r4
	}
#ifdef FILE_USE_MOVE
	// Move assignment.
	File& operator = (const File&& file) {
		//Serial.println("File move assignment");
		if (file.f) file.f->refcount++;
    21c4:	ldr	r3, [sp, #40]	; 0x28
    21c6:	cbz	r3, 21ce <saveData(short)+0x3be>
    21c8:	ldr	r2, [r3, #4]
    21ca:	adds	r2, #1
    21cc:	str	r2, [r3, #4]
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
    21ce:	ldr	r4, [pc, #84]	; (2224 <saveData(short)+0x414>)
    21d0:	ldr	r3, [r4, #16]
    21d2:	cbz	r3, 21dc <saveData(short)+0x3cc>
    21d4:	add.w	r0, r4, #16
    21d8:	bl	194c <File::dec_refcount() [clone .isra.23]>
		f = file.f;
    21dc:	ldr	r3, [sp, #40]	; 0x28
    21de:	str	r3, [r4, #16]
    21e0:	add	r0, sp, #24
    21e2:	bl	b74 <File::~File()>
    21e6:	ldr	r0, [r4, #16]
			f->close();
			dec_refcount();
		}
	}
	operator bool() {
		return (f) ? f->isOpen() : false;
    21e8:	cbnz	r0, 21f4 <saveData(short)+0x3e4>
                if(file) 
                    status = OPENED; 
                else 
                {   Serial.println("Failing open file");
    21ea:	ldr	r1, [pc, #60]	; (2228 <saveData(short)+0x418>)
    21ec:	ldr	r0, [pc, #44]	; (221c <saveData(short)+0x40c>)
    21ee:	bl	758 <Print::println(char const*)>
    21f2:	b.n	1eec <saveData(short)+0xdc>
    21f4:	ldr	r3, [r0, #0]
    21f6:	ldr	r3, [r3, #48]	; 0x30
    21f8:	blx	r3
            if(dirFlag>0) return CLOSED;        // create new directory with different name

            if(newFileName(fileName))
            {   
                file = msd->open(fileName, FILE_WRITE_BEGIN); 
                if(file) 
    21fa:	cmp	r0, #0
    21fc:	bne.w	1e78 <saveData(short)+0x68>
    2200:	b.n	21ea <saveData(short)+0x3da>
        file.flush();
        file.close();
        status = STOPPED;
    }
    return status;
}
    2202:	add	sp, #84	; 0x54
    2204:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    2208:	.word	0x20018160
    220c:	.word	0x000128c2
    2210:	.word	0x000128c0
    2214:	.word	0x20018100
    2218:	.word	0x00012da8
    221c:	.word	0x1fff1348
    2220:	.word	0x00012500
    2224:	.word	0x1fff2214
    2228:	.word	0x000128d6

0000222c <_GLOBAL__sub_I_data_buffer>:
    222c:	push	{r3, r4, r5, lr}
            { /**
             * @brief Constructor
             * @param buffer is pointer to data store
             * 
             */
                data_buffer=buffer; front_=rear_=0;
    222e:	ldr	r3, [pc, #128]	; (22b0 <_GLOBAL__sub_I_data_buffer+0x84>)
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    2230:	ldr	r0, [pc, #128]	; (22b4 <_GLOBAL__sub_I_data_buffer+0x88>)

/****************************** Filing Utility *******************************************/

extern int t_acq;

File file=NULL; // is used by saveData and saveNAD
    2232:	ldr	r5, [pc, #132]	; (22b8 <_GLOBAL__sub_I_data_buffer+0x8c>)
            { /**
             * @brief Constructor
             * @param buffer is pointer to data store
             * 
             */
                data_buffer=buffer; front_=rear_=0;
    2234:	ldr	r2, [pc, #132]	; (22bc <_GLOBAL__sub_I_data_buffer+0x90>)
    2236:	str	r2, [r3, #4]
    2238:	movs	r4, #0
    223a:	strh	r4, [r3, #2]
    223c:	strh	r4, [r3, #0]
    223e:	mov.w	r3, #1000	; 0x3e8

/****************************** Filing Utility *******************************************/

extern int t_acq;

File file=NULL; // is used by saveData and saveNAD
    2242:	mov	r2, r5
    2244:	strb	r4, [r0, #4]
    2246:	str	r3, [r0, #8]
    2248:	strb	r4, [r0, #12]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
    224a:	ldr	r3, [pc, #116]	; (22c0 <_GLOBAL__sub_I_data_buffer+0x94>)
    224c:	ldr	r1, [pc, #116]	; (22c4 <_GLOBAL__sub_I_data_buffer+0x98>)
    224e:	str	r3, [r0, #0]
		f = file;
    2250:	str	r4, [r0, #16]
    2252:	bl	a524 <__aeabi_atexit>
// This is a simple driver based on the the standard SPI.h library.
// You can write a driver entirely independent of SPI.h.
// It can be optimized for your board or a different SPI port can be used.
// The driver must be derived from SdSpiBaseClass.
// See: SdFat/src/SpiDriver/SdSpiBaseClass.h
class MySpiClass : public SdSpiBaseClass {
    2256:	ldr	r3, [pc, #112]	; (22c8 <_GLOBAL__sub_I_data_buffer+0x9c>)
    2258:	ldr	r2, [pc, #112]	; (22cc <_GLOBAL__sub_I_data_buffer+0xa0>)
    225a:	str	r2, [r3, #0]
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
		}
		ctar = c | t;
    225c:	ldr	r2, [pc, #112]	; (22d0 <_GLOBAL__sub_I_data_buffer+0xa4>)
    225e:	str	r2, [r3, #4]
    2260:	movs	r2, #1
    2262:	strb	r2, [r3, #8]


class SDClass : public FS
{
public:
	SDClass() { }
    2264:	ldr	r3, [pc, #108]	; (22d4 <_GLOBAL__sub_I_data_buffer+0xa8>)
    2266:	ldr	r1, [pc, #112]	; (22d8 <_GLOBAL__sub_I_data_buffer+0xac>)
#else  // HAS_SDIO_CLASS
class SdSpiCard {
#endif  // HAS_SDIO_CLASS
 public:
  /** Construct an instance of SdSpiCard. */
  SdSpiCard() {}
    2268:	strb.w	r2, [r3, #1197]	; 0x4ad
    226c:	movs	r2, #41	; 0x29
    226e:	str	r1, [r3, #0]
    2270:	strb.w	r2, [r3, #1199]	; 0x4af
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    2274:	ldr	r1, [pc, #100]	; (22dc <_GLOBAL__sub_I_data_buffer+0xb0>)
    2276:	str.w	r1, [r3, #1172]	; 0x494
    227a:	movs	r2, #255	; 0xff
    227c:	ldr	r1, [pc, #96]	; (22e0 <_GLOBAL__sub_I_data_buffer+0xb4>)
    227e:	strb.w	r2, [r3, #1221]	; 0x4c5
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    2282:	strb.w	r4, [r3, #1180]	; 0x49c
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    2286:	strb.w	r4, [r3, #1181]	; 0x49d
    228a:	strb.w	r4, [r3, #1202]	; 0x4b2
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    228e:	strb.w	r4, [r3, #1216]	; 0x4c0
    2292:	str.w	r1, [r3, #1184]	; 0x4a0
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() {}
    2296:	str.w	r4, [r3, #1156]	; 0x484
    229a:	str.w	r4, [r3, #1160]	; 0x488
    229e:	strb.w	r4, [r3, #1220]	; 0x4c4
    const char *sd_str[]={"sd1"};
    const int cs[] = {10 };

    const int nsd = sizeof(cs)/sizeof(int);

    SDClass sdx[nsd];
    22a2:	mov	r2, r5
    22a4:	mov	r0, r4
    22a6:	ldr	r1, [pc, #60]	; (22e4 <_GLOBAL__sub_I_data_buffer+0xb8>)
        file.flush();
        file.close();
        status = STOPPED;
    }
    return status;
}
    22a8:	ldmia.w	sp!, {r3, r4, r5, lr}
    const char *sd_str[]={"sd1"};
    const int cs[] = {10 };

    const int nsd = sizeof(cs)/sizeof(int);

    SDClass sdx[nsd];
    22ac:	b.w	a524 <__aeabi_atexit>
    22b0:	.word	0x20018154
    22b4:	.word	0x1fff2214
    22b8:	.word	0x1fff0f30
    22bc:	.word	0x1fff2234
    22c0:	.word	0x00012578
    22c4:	.word	0x00000b75
    22c8:	.word	0x200191b0
    22cc:	.word	0x0001283c
    22d0:	.word	0x38011001
    22d4:	.word	0x20017c38
    22d8:	.word	0x00012ad0
    22dc:	.word	0x00012e30
    22e0:	.word	0x00012dd0
    22e4:	.word	0x00001889

000022e8 <TwoWire::write(int)>:
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
	}
	size_t write(int n) {
		return write((uint8_t)n);
    22e8:	ldr	r3, [r0, #0]
    22ea:	uxtb	r1, r1
    22ec:	ldr	r3, [r3, #0]
    22ee:	bx	r3

000022f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>:
        val = wire->read()<<8;
        val |= wire->read();
        return val;
    }
    
    uint8_t write16(uint8_t addr, uint16_t reg, uint16_t val) 
    22f0:	push	{r3, r4, r5, r6, r7, lr}
    22f2:	mov	r6, r3
    { 
        wire->beginTransmission(addr);
    22f4:	ldr	r3, [r0, #0]
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
		transmitting = 1;
    22f6:	movs	r5, #1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    22f8:	lsls	r1, r1, #1
    22fa:	strb.w	r1, [r3, #163]	; 0xa3
		transmitting = 1;
    22fe:	strb.w	r5, [r3, #302]	; 0x12e
		txBufferLength = 1;
    2302:	strb.w	r5, [r3, #301]	; 0x12d
        val = wire->read()<<8;
        val |= wire->read();
        return val;
    }
    
    uint8_t write16(uint8_t addr, uint16_t reg, uint16_t val) 
    2306:	mov	r4, r0
    2308:	mov	r7, r2
    { 
        wire->beginTransmission(addr);
        wire->write(reg >> 8);
    230a:	lsrs	r1, r2, #8
    230c:	ldr	r0, [r0, #0]
    230e:	bl	22e8 <TwoWire::write(int)>
        wire->write(reg);
    2312:	mov	r1, r7
    2314:	ldr	r0, [r4, #0]
    2316:	bl	22e8 <TwoWire::write(int)>
        wire->write(val >> 8);
    231a:	lsrs	r1, r6, #8
    231c:	ldr	r0, [r4, #0]
    231e:	bl	22e8 <TwoWire::write(int)>
        wire->write(val);
    2322:	mov	r1, r6
    2324:	ldr	r0, [r4, #0]
    2326:	bl	22e8 <TwoWire::write(int)>
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    232a:	mov	r1, r5
    232c:	ldr	r0, [r4, #0]
    232e:	bl	28e8 <TwoWire::endTransmission(unsigned char)>
        return (wire->endTransmission() == 0) ;
    }
    2332:	clz	r0, r0
    2336:	lsrs	r0, r0, #5
    2338:	pop	{r3, r4, r5, r6, r7, pc}

0000233a <adc_init()>:
    233a:	bx	lr

0000233c <adcStatus()>:
    static uint8_t addr = SGTL5000_I2C_ADDR_CS_LOW;
    i2c_class i2c(&Wire);
    
    void adc_init(void) {  }
    void setAGain(int8_t again) {  }
    void adcStatus(void) {  }
    233c:	bx	lr
    233e:	Address 0x0000233e is out of bounds.


00002340 <adc_enable(unsigned int, unsigned long)>:

    bool adc_enable(const unsigned extMCLK, const uint32_t pllFreq) 
    {
    2340:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        wire->setSDA(sda);
    }

    uint8_t exist(uint8_t addr)
    {
        wire->beginTransmission(addr);
    2344:	ldr	r6, [pc, #548]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    2346:	mov	r5, r0
    2348:	ldr	r0, [r6, #0]
    234a:	mov	r7, r1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    234c:	movs	r4, #20
		transmitting = 1;
    234e:	movs	r1, #1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2350:	strb.w	r4, [r0, #163]	; 0xa3
		transmitting = 1;
    2354:	strb.w	r1, [r0, #302]	; 0x12e
		txBufferLength = 1;
    2358:	strb.w	r1, [r0, #301]	; 0x12d
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    235c:	bl	28e8 <TwoWire::endTransmission(unsigned char)>
        if(!i2c.exist(addr)) Serial.println("No I2C address found");
    2360:	cbz	r0, 2370 <adc_enable(unsigned int, unsigned long)+0x30>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    2362:	mov	r1, r4
    2364:	ldr	r0, [pc, #520]	; (2570 <adc_enable(unsigned int, unsigned long)+0x230>)
    2366:	bl	91d0 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    236a:	ldr	r0, [pc, #520]	; (2574 <adc_enable(unsigned int, unsigned long)+0x234>)
    236c:	bl	a1bc <Print::println()>
    }

    uint16_t read16(uint8_t addr, uint16_t reg) 
    { 
        unsigned int val;
        wire->beginTransmission(addr);
    2370:	ldr	r0, [r6, #0]
    2372:	ldr.w	r8, [pc, #504]	; 256c <adc_enable(unsigned int, unsigned long)+0x22c>
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2376:	movs	r3, #20
		transmitting = 1;
    2378:	movs	r4, #1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    237a:	strb.w	r3, [r0, #163]	; 0xa3
        wire->write(reg >> 8);
    237e:	movs	r1, #0
		transmitting = 1;
    2380:	strb.w	r4, [r0, #302]	; 0x12e
		txBufferLength = 1;
    2384:	strb.w	r4, [r0, #301]	; 0x12d
    2388:	bl	22e8 <TwoWire::write(int)>
        wire->write(reg);
    238c:	movs	r1, #6
    238e:	ldr	r0, [r6, #0]
    2390:	bl	22e8 <TwoWire::write(int)>
        if (wire->endTransmission(false) != 0) return 0;
    2394:	movs	r1, #0
    2396:	ldr	r0, [r6, #0]
    2398:	bl	28e8 <TwoWire::endTransmission(unsigned char)>
    239c:	cbnz	r0, 23d4 <adc_enable(unsigned int, unsigned long)+0x94>
	uint8_t requestFrom(int address, int quantity, int sendStop) {
		return requestFrom((uint8_t)address, (uint8_t)quantity,
			(uint8_t)(sendStop ? 1 : 0));
	}
	uint8_t requestFrom(int address, int quantity) {
		return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)1);
    239e:	mov	r3, r4
    23a0:	mov	r2, r4
    23a2:	movs	r1, #10
    23a4:	ldr.w	r0, [r8]
    23a8:	bl	29e0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
        if (wire->requestFrom((int)addr, 1) < 1) return 0;
    23ac:	cbz	r0, 23d4 <adc_enable(unsigned int, unsigned long)+0x94>
        val = wire->read()<<8;
    23ae:	ldr.w	r0, [r8]
    23b2:	ldr	r3, [r0, #0]
    23b4:	ldr	r3, [r3, #20]
    23b6:	blx	r3
    23b8:	lsls	r6, r0, #8
        val |= wire->read();
    23ba:	ldr.w	r0, [r8]
    23be:	ldr	r3, [r0, #0]
    23c0:	ldr	r3, [r3, #20]
    23c2:	blx	r3
        return val;
    23c4:	orrs	r0, r6
    23c6:	uxth	r0, r0
 
        //Check if we are in Master Mode and if the Teensy had a reset:
        unsigned int n = i2c.read16(addr,CHIP_I2S_CTRL);
        if ( (extMCLK > 0) && (n == (0x0030 | (1<<7))) ) {
    23c8:	cbz	r5, 23d4 <adc_enable(unsigned int, unsigned long)+0x94>
    23ca:	cmp	r0, #176	; 0xb0
    23cc:	bne.n	23d4 <adc_enable(unsigned int, unsigned long)+0x94>
            //Yes. Do not initialize.
            return true;
    23ce:	mov	r0, r4
    23d0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        }

        int r = i2c.write16(addr,CHIP_ANA_POWER, 0x4060);  // VDDD is externally driven with 1.8V
    23d4:	movw	r3, #16480	; 0x4060
    23d8:	movs	r2, #48	; 0x30
    23da:	movs	r1, #10
    23dc:	ldr	r0, [pc, #396]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    23de:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        if (!r) return false;
    23e2:	cbnz	r0, 23ea <adc_enable(unsigned int, unsigned long)+0xaa>
    23e4:	movs	r0, #0
    23e6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        i2c.write16(addr,CHIP_LINREG_CTRL, 0x006C);  // VDDA & VDDIO both over 3.1V
    23ea:	movs	r3, #108	; 0x6c
    23ec:	movs	r2, #38	; 0x26
    23ee:	movs	r1, #10
    23f0:	ldr	r0, [pc, #376]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    23f2:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_REF_CTRL, 0x01F2); // VAG=1.575, normal ramp, +12.5% bias current
    23f6:	mov.w	r3, #498	; 0x1f2
    23fa:	movs	r2, #40	; 0x28
    23fc:	movs	r1, #10
    23fe:	ldr	r0, [pc, #364]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    2400:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_LINE_OUT_CTRL, 0x0F22); // LO_VAGCNTRL=1.65V, OUT_CURRENT=0.54mA
    2404:	movw	r3, #3874	; 0xf22
    2408:	movs	r2, #44	; 0x2c
    240a:	movs	r1, #10
    240c:	ldr	r0, [pc, #348]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    240e:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_SHORT_CTRL, 0x4446);  // allow up to 125mA
    2412:	movw	r3, #17478	; 0x4446
    2416:	movs	r2, #60	; 0x3c
    2418:	movs	r1, #10
    241a:	ldr	r0, [pc, #336]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    241c:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_ANA_CTRL, 0x0137);  // enable zero cross detectors
    2420:	movw	r3, #311	; 0x137
    2424:	movs	r2, #36	; 0x24
    2426:	movs	r1, #10
    2428:	ldr	r0, [pc, #320]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    242a:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
            
        if (extMCLK > 0) {
    242e:	cbz	r5, 2494 <adc_enable(unsigned int, unsigned long)+0x154>
            //SGTL is I2S Master
            //Datasheet Pg. 14: Using the PLL - Asynchronous SYS_MCLK input
            if (extMCLK > 17000000) {
    2430:	ldr	r3, [pc, #324]	; (2578 <adc_enable(unsigned int, unsigned long)+0x238>)
                i2c.write16(addr,CHIP_CLK_TOP_CTRL, 1);
            } else {
                i2c.write16(addr,CHIP_CLK_TOP_CTRL, 0);
    2432:	ldr	r0, [pc, #312]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
        i2c.write16(addr,CHIP_ANA_CTRL, 0x0137);  // enable zero cross detectors
            
        if (extMCLK > 0) {
            //SGTL is I2S Master
            //Datasheet Pg. 14: Using the PLL - Asynchronous SYS_MCLK input
            if (extMCLK > 17000000) {
    2434:	cmp	r5, r3
                i2c.write16(addr,CHIP_CLK_TOP_CTRL, 1);
    2436:	ite	hi
    2438:	movhi	r3, #1
            } else {
                i2c.write16(addr,CHIP_CLK_TOP_CTRL, 0);
    243a:	movls	r3, #0
    243c:	movs	r2, #52	; 0x34
    243e:	movs	r1, #10
    2440:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
            }

            uint32_t int_divisor = (pllFreq / extMCLK) & 0x1f;
    2444:	udiv	r3, r7, r5
            uint32_t frac_divisor = (uint32_t)((((float)pllFreq / extMCLK) - int_divisor) * 2048.0f) & 0x7ff;
            
            i2c.write16(addr,CHIP_PLL_CTRL, (int_divisor << 11) | frac_divisor);		
    2448:	vmov	s15, r7
    244c:	vcvt.f32.u32	s14, s15
    2450:	vmov	s15, r5
    2454:	vcvt.f32.u32	s13, s15
                i2c.write16(addr,CHIP_CLK_TOP_CTRL, 1);
            } else {
                i2c.write16(addr,CHIP_CLK_TOP_CTRL, 0);
            }

            uint32_t int_divisor = (pllFreq / extMCLK) & 0x1f;
    2458:	and.w	r3, r3, #31
            uint32_t frac_divisor = (uint32_t)((((float)pllFreq / extMCLK) - int_divisor) * 2048.0f) & 0x7ff;
            
            i2c.write16(addr,CHIP_PLL_CTRL, (int_divisor << 11) | frac_divisor);		
    245c:	vdiv.f32	s15, s14, s13
    2460:	movs	r1, #10
    2462:	ldr	r0, [pc, #264]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    2464:	vmov	s14, r3
    2468:	vcvt.f32.s32	s14, s14
    246c:	vsub.f32	s15, s15, s14
    2470:	vldr	s14, [pc, #264]	; 257c <adc_enable(unsigned int, unsigned long)+0x23c>
    2474:	vmul.f32	s15, s15, s14
    2478:	vcvt.u32.f32	s15, s15
    247c:	vmov	r2, s15
    2480:	ubfx	r2, r2, #0, #11
    2484:	orr.w	r3, r2, r3, lsl #11
    2488:	movs	r2, #50	; 0x32
    248a:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
            i2c.write16(addr,CHIP_ANA_POWER, 0x40FF | (1<<10) | (1<<8) ); // power up: lineout, hp, adc, dac, PLL_POWERUP, VCOAMP_POWERUP
    248e:	movw	r3, #17919	; 0x45ff
    2492:	b.n	2498 <adc_enable(unsigned int, unsigned long)+0x158>
        } else {
            //SGTL is I2S Slave
            i2c.write16(addr,CHIP_ANA_POWER, 0x40FF); // power up: lineout, hp, adc, dac
    2494:	movw	r3, #16639	; 0x40ff
    2498:	movs	r2, #48	; 0x30
    249a:	movs	r1, #10
    249c:	ldr	r0, [pc, #204]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    249e:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        }

        i2c.write16(addr,CHIP_DIG_POWER, 0x0073); // power up all digital stuff
    24a2:	movs	r3, #115	; 0x73
    24a4:	movs	r2, #2
    24a6:	movs	r1, #10
    24a8:	ldr	r0, [pc, #192]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    24aa:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        delay(400);
    24ae:	mov.w	r0, #400	; 0x190
    24b2:	bl	9550 <delay>
        i2c.write16(addr,CHIP_LINE_OUT_VOL, 0x1D1D); // default approx 1.3 volts peak-to-peak
    24b6:	movw	r3, #7453	; 0x1d1d
    24ba:	movs	r2, #46	; 0x2e
    24bc:	movs	r1, #10
    24be:	ldr	r0, [pc, #172]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    24c0:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        
        if (extMCLK > 0) { 
    24c4:	cbz	r5, 24d6 <adc_enable(unsigned int, unsigned long)+0x196>
            //SGTL is I2S Master
            i2c.write16(addr,CHIP_CLK_CTRL, 0x0004 | 0x03);  // 44.1 kHz, 256*Fs, use PLL
    24c6:	movs	r3, #7
    24c8:	movs	r2, #4
    24ca:	movs	r1, #10
    24cc:	ldr	r0, [pc, #156]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    24ce:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
            i2c.write16(addr,CHIP_I2S_CTRL, 0x0030 | (1<<7)); // SCLK=64*Fs, 16bit, I2S format
    24d2:	movs	r3, #176	; 0xb0
    24d4:	b.n	24e4 <adc_enable(unsigned int, unsigned long)+0x1a4>
        } else {
            //SGTL is I2S Slave
            i2c.write16(addr,CHIP_CLK_CTRL, 0x0004);  // 44.1 kHz, 256*Fs
    24d6:	movs	r3, #4
    24d8:	mov	r2, r3
    24da:	movs	r1, #10
    24dc:	ldr	r0, [pc, #140]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    24de:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
            i2c.write16(addr,CHIP_I2S_CTRL, 0x0030); // SCLK=64*Fs, 16bit, I2S format
    24e2:	movs	r3, #48	; 0x30
    24e4:	movs	r2, #6
    24e6:	movs	r1, #10
    24e8:	ldr	r0, [pc, #128]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    24ea:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        }

        // default signal routing is ok?
        i2c.write16(addr,CHIP_SSS_CTRL, 0x0010); // ADC->I2S, I2S->DAC
    24ee:	movs	r2, #10
    24f0:	mov	r1, r2
    24f2:	movs	r3, #16
    24f4:	ldr	r0, [pc, #116]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    24f6:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_ADCDAC_CTRL, 0x0000); // disable dac mute
    24fa:	movs	r3, #0
    24fc:	movs	r2, #14
    24fe:	movs	r1, #10
    2500:	ldr	r0, [pc, #104]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    2502:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_DAC_VOL, 0x3C3C); // digital gain, 0dB
    2506:	movw	r3, #15420	; 0x3c3c
    250a:	movs	r2, #16
    250c:	movs	r1, #10
    250e:	ldr	r0, [pc, #92]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    2510:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_ANA_HP_CTRL, 0x7F7F); // set volume (lowest level)
    2514:	movw	r3, #32639	; 0x7f7f
    2518:	movs	r2, #34	; 0x22
    251a:	movs	r1, #10
    251c:	ldr	r0, [pc, #76]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    251e:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_ANA_CTRL, 0x0036);  // enable zero cross detectors
    2522:	movs	r3, #54	; 0x36
    2524:	movs	r2, #36	; 0x24
    2526:	movs	r1, #10
    2528:	ldr	r0, [pc, #64]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    252a:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        uint16_t ana_ctrl=0x0036;

        return i2c.write16(addr,0x002A, 0x0173) // mic preamp gain = +40dB
    252e:	movw	r3, #371	; 0x173
    2532:	movs	r2, #42	; 0x2a
    2534:	movs	r1, #10
    2536:	ldr	r0, [pc, #52]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    2538:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
                && i2c.write16(addr,0x0020, 0x088)     // input gain +12dB (is this enough?)
                && i2c.write16(addr,0x0024, ana_ctrl & ~(1<<2)); // enable mic
    253c:	cmp	r0, #0
    253e:	beq.w	23e4 <adc_enable(unsigned int, unsigned long)+0xa4>
        i2c.write16(addr,CHIP_ANA_HP_CTRL, 0x7F7F); // set volume (lowest level)
        i2c.write16(addr,CHIP_ANA_CTRL, 0x0036);  // enable zero cross detectors
        uint16_t ana_ctrl=0x0036;

        return i2c.write16(addr,0x002A, 0x0173) // mic preamp gain = +40dB
                && i2c.write16(addr,0x0020, 0x088)     // input gain +12dB (is this enough?)
    2542:	movs	r3, #136	; 0x88
    2544:	movs	r2, #32
    2546:	movs	r1, #10
    2548:	ldr	r0, [pc, #32]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    254a:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
    254e:	cmp	r0, #0
    2550:	beq.w	23e4 <adc_enable(unsigned int, unsigned long)+0xa4>
                && i2c.write16(addr,0x0024, ana_ctrl & ~(1<<2)); // enable mic
    2554:	movs	r3, #50	; 0x32
    2556:	movs	r2, #36	; 0x24
    2558:	movs	r1, #10
    255a:	ldr	r0, [pc, #16]	; (256c <adc_enable(unsigned int, unsigned long)+0x22c>)
    255c:	bl	22f0 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
    2560:	adds	r0, #0
    2562:	it	ne
    2564:	movne	r0, #1
    2566:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    256a:	nop
    256c:	.word	0x2001a1c0
    2570:	.word	0x0001290d
    2574:	.word	0x1fff1348
    2578:	.word	0x01036640
    257c:	.word	0x45000000

00002580 <_GLOBAL__sub_I_gain>:
class i2c_class
{ TwoWire *wire;
    public:

    i2c_class(TwoWire *wire) 
    {   this->wire = wire;
    2580:	ldr	r3, [pc, #8]	; (258c <_GLOBAL__sub_I_gain+0xc>)
    2582:	ldr	r0, [pc, #12]	; (2590 <_GLOBAL__sub_I_gain+0x10>)
    2584:	str	r0, [r3, #0]
        wire->begin();
    2586:	b.w	2668 <TwoWire::begin()>
    258a:	nop
    258c:	.word	0x2001a1c0
    2590:	.word	0x1fff1080

00002594 <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    2594:	ldrb.w	r2, [r0, #161]	; 0xa1
    2598:	ldrb.w	r0, [r0, #160]	; 0xa0
	}
    259c:	subs	r0, r2, r0
    259e:	bx	lr

000025a0 <TwoWire::read()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    25a0:	ldrb.w	r3, [r0, #160]	; 0xa0
    25a4:	ldrb.w	r2, [r0, #161]	; 0xa1
    25a8:	cmp	r2, r3
		return rxBuffer[rxBufferIndex++];
    25aa:	itttt	hi
    25ac:	addhi	r2, r3, #1
    25ae:	addhi	r3, r3, r0
    25b0:	strbhi.w	r2, [r0, #160]	; 0xa0
    25b4:	ldrbhi	r0, [r3, #24]
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    25b6:	it	ls
    25b8:	movls.w	r0, #4294967295
		return rxBuffer[rxBufferIndex++];
	}
    25bc:	bx	lr

000025be <TwoWire::peek()>:
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    25be:	ldrb.w	r3, [r0, #160]	; 0xa0
    25c2:	ldrb.w	r2, [r0, #161]	; 0xa1
    25c6:	cmp	r2, r3
		return rxBuffer[rxBufferIndex];
    25c8:	itte	hi
    25ca:	addhi	r3, r3, r0
    25cc:	ldrbhi	r0, [r3, #24]
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    25ce:	movls.w	r0, #4294967295
		return rxBuffer[rxBufferIndex];
	}
    25d2:	bx	lr

000025d4 <TwoWire::flush()>:
	virtual void flush(void) {
    25d4:	bx	lr

000025d6 <TwoWire::write(unsigned char)>:
//  I2C0_C2      // I2C Control Register 2
//  I2C0_FLT     // I2C Programmable Input Glitch Filter register

size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
    25d6:	ldrh.w	r3, [r0, #302]	; 0x12e
    25da:	cbz	r3, 25e8 <TwoWire::write(unsigned char)+0x12>
		if (txBufferLength >= BUFFER_LENGTH+1) {
    25dc:	ldrb.w	r3, [r0, #301]	; 0x12d
    25e0:	cmp	r3, #136	; 0x88
    25e2:	bls.n	25ec <TwoWire::write(unsigned char)+0x16>
	// format warnings are too pedantic - disable until newer toolchain offers better...
	// https://forum.pjrc.com/threads/62473?p=256873&viewfull=1#post256873
	int printf(const char *format, ...) /*__attribute__ ((format (printf, 2, 3)))*/;
	int printf(const __FlashStringHelper *format, ...);
  protected:
	void setWriteError(int err = 1) { write_error = err; }
    25e4:	movs	r3, #1
    25e6:	strb	r3, [r0, #4]
			setWriteError();
			return 0;
    25e8:	movs	r0, #0
    25ea:	bx	lr
		}
		txBuffer[txBufferLength++] = data;
    25ec:	adds	r2, r3, #1
    25ee:	add	r3, r0
    25f0:	strb.w	r2, [r0, #301]	; 0x12d
    25f4:	strb.w	r1, [r3, #163]	; 0xa3
		return 1;
    25f8:	movs	r0, #1
    25fa:	bx	lr

000025fc <TwoWire::write(unsigned char const*, unsigned int)>:
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    25fc:	push	{r3, r4, r5, lr}
    25fe:	mov	r4, r0
	if (transmitting || slave_mode) {
    2600:	ldrh.w	r0, [r0, #302]	; 0x12e
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    2604:	mov	r5, r2
	if (transmitting || slave_mode) {
    2606:	cbz	r0, 2632 <TwoWire::write(unsigned char const*, unsigned int)+0x36>
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
    2608:	ldrb.w	r3, [r4, #301]	; 0x12d
    260c:	rsb	r2, r3, #137	; 0x89
		if (quantity > avail) {
    2610:	cmp	r5, r2
    2612:	ittt	hi
    2614:	movhi	r0, #1
    2616:	movhi	r5, r2
    2618:	strbhi	r0, [r4, #4]
			quantity = avail;
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
    261a:	add.w	r0, r4, #163	; 0xa3
    261e:	add	r0, r3
    2620:	mov	r2, r5
    2622:	bl	8f14 <memcpy>
		txBufferLength += quantity;
    2626:	ldrb.w	r3, [r4, #301]	; 0x12d
    262a:	add	r3, r5
    262c:	strb.w	r3, [r4, #301]	; 0x12d
    2630:	mov	r0, r5
		return quantity;
	}
	return 0;
}
    2632:	pop	{r3, r4, r5, pc}

00002634 <TwoWire::setClock(unsigned long)>:
	//pinMode(4, OUTPUT);
}

void TwoWire::setClock(uint32_t frequency)
{
	if (!(hardware.clock_gate_register & hardware.clock_gate_mask)) return;
    2634:	ldr	r3, [r0, #20]
    2636:	ldr	r2, [r3, #0]
    2638:	ldr	r3, [r3, #4]
    263a:	ldr	r2, [r2, #0]
    263c:	tst	r2, r3
    263e:	beq.n	265e <TwoWire::setClock(unsigned long)+0x2a>
	} else {
		port().F = I2C_F_DIV56; // 0.96 MHz
	}
	port().FLT = 4;
#elif F_BUS == 48000000
	if (frequency < 400000) {
    2640:	ldr	r3, [pc, #28]	; (2660 <TwoWire::setClock(unsigned long)+0x2c>)
    2642:	cmp	r1, r3
    2644:	ldr	r3, [r0, #16]
    2646:	bhi.n	264c <TwoWire::setClock(unsigned long)+0x18>
		port().F = 0x27;	// 100 kHz
    2648:	movs	r2, #39	; 0x27
    264a:	b.n	2656 <TwoWire::setClock(unsigned long)+0x22>
	} else if (frequency < 1000000) {
    264c:	ldr	r2, [pc, #20]	; (2664 <TwoWire::setClock(unsigned long)+0x30>)
    264e:	cmp	r1, r2
		port().F = 0x1A; // 400 kHz
    2650:	ite	ls
    2652:	movls	r2, #26
	} else {
		port().F = 0x0D; // 1 MHz
    2654:	movhi	r2, #13
    2656:	strb	r2, [r3, #1]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    2658:	ldr	r3, [r0, #16]
	}
	port().FLT = 4;
    265a:	movs	r2, #4
    265c:	strb	r2, [r3, #6]
    265e:	bx	lr
    2660:	.word	0x00061a7f
    2664:	.word	0x000f423f

00002668 <TwoWire::begin()>:

void sda_rising_isr0(void);
void sda_rising_isr1(void);

void TwoWire::begin(void)
{
    2668:	push	{r4, r5, r6, lr}
	//serial_begin(BAUD2DIV(115200));
	//serial_print("\nWire Begin\n");

	rxBufferIndex = 0;
    266a:	movs	r3, #0
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    266c:	ldr	r5, [r0, #20]
void TwoWire::begin(void)
{
	//serial_begin(BAUD2DIV(115200));
	//serial_print("\nWire Begin\n");

	rxBufferIndex = 0;
    266e:	strb.w	r3, [r0, #160]	; 0xa0
	rxBufferLength = 0;
    2672:	strb.w	r3, [r0, #161]	; 0xa1
	txBufferIndex = 0;
    2676:	strb.w	r3, [r0, #300]	; 0x12c
	txBufferLength = 0;
    267a:	strb.w	r3, [r0, #301]	; 0x12d
	transmitting = 0;
    267e:	strb.w	r3, [r0, #302]	; 0x12e
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
    2682:	strb.w	r3, [r0, #303]	; 0x12f
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    2686:	ldr	r1, [r5, #0]
    2688:	ldr	r2, [r5, #4]
    268a:	ldr	r6, [r1, #0]
	rxBufferIndex = 0;
	rxBufferLength = 0;
	txBufferIndex = 0;
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
    268c:	str.w	r3, [r0, #308]	; 0x134
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    2690:	orrs	r2, r6
	rxBufferLength = 0;
	txBufferIndex = 0;
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
    2692:	str.w	r3, [r0, #312]	; 0x138
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    2696:	str	r2, [r1, #0]
    2698:	ldr	r2, [r0, #16]
	port().C1 = 0;
    269a:	strb	r3, [r2, #2]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    269c:	ldr	r6, [r0, #20]
    269e:	ldrb.w	r1, [r0, #305]	; 0x131
    26a2:	ldr	r2, [pc, #72]	; (26ec <TwoWire::begin()+0x84>)
    26a4:	add	r1, r6
    26a6:	ldrb	r5, [r1, #8]
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    26a8:	ldrb	r3, [r1, #13]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    26aa:	add.w	r5, r2, r5, lsl #3
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    26ae:	lsls	r3, r3, #8
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    26b0:	ldr	r5, [r5, #4]
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    26b2:	and.w	r3, r3, #1792	; 0x700
    26b6:	orr.w	r3, r3, #100	; 0x64
    26ba:	str	r3, [r5, #0]
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    26bc:	ldrb.w	r3, [r0, #306]	; 0x132
    26c0:	add	r3, r6
    26c2:	ldrb	r1, [r3, #18]
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    26c4:	ldrb	r3, [r3, #23]
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    26c6:	add.w	r2, r2, r1, lsl #3
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    26ca:	lsls	r3, r3, #8
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    26cc:	ldr	r2, [r2, #4]
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	setClock(100000);
    26ce:	ldr	r1, [pc, #32]	; (26f0 <TwoWire::begin()+0x88>)
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    26d0:	and.w	r3, r3, #1792	; 0x700
    26d4:	orr.w	r3, r3, #100	; 0x64
    26d8:	str	r3, [r2, #0]
	setClock(100000);
    26da:	bl	2634 <TwoWire::setClock(unsigned long)>
    26de:	ldr	r3, [r0, #16]
	port().C2 = I2C_C2_HDRS;
    26e0:	movs	r2, #32
    26e2:	strb	r2, [r3, #5]
    26e4:	ldr	r3, [r0, #16]
	port().C1 = I2C_C1_IICEN;
    26e6:	movs	r2, #128	; 0x80
    26e8:	strb	r2, [r3, #2]
    26ea:	pop	{r4, r5, r6, pc}
    26ec:	.word	0x00012e88
    26f0:	.word	0x000186a0

000026f4 <TwoWire::isr()>:
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    26f4:	push	{r3, r4, r5, lr}
    26f6:	ldr	r2, [r0, #16]
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
    26f8:	ldrb	r5, [r2, #3]
    26fa:	uxtb	r5, r5
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    26fc:	tst.w	r5, #16
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    2700:	mov	r4, r0
    2702:	and.w	r3, r5, #64	; 0x40
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    2706:	bne.n	2710 <TwoWire::isr()+0x1c>


		}
		if (!(status & I2C_S_IAAS)) return;
	}
	if (status & I2C_S_IAAS) {
    2708:	and.w	r1, r3, #255	; 0xff
    270c:	cbnz	r3, 271a <TwoWire::isr()+0x26>
    270e:	b.n	2768 <TwoWire::isr()+0x74>

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
		// Arbitration Lost
		port().S = I2C_S_ARBL;
    2710:	movs	r1, #16
    2712:	strb	r1, [r2, #3]
		if (receiving && rxBufferLength > 0) {
			// TODO: does this detect the STOP condition in slave receive mode?


		}
		if (!(status & I2C_S_IAAS)) return;
    2714:	cmp	r3, #0
    2716:	bne.n	2708 <TwoWire::isr()+0x14>
    2718:	pop	{r3, r4, r5, pc}
	}
	if (status & I2C_S_IAAS) {
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
    271a:	and.w	r5, r5, #4
    271e:	and.w	r2, r5, #255	; 0xff
    2722:	ldr	r3, [pc, #224]	; (2804 <TwoWire::isr()+0x110>)
    2724:	cbz	r5, 275c <TwoWire::isr()+0x68>
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    2726:	movs	r2, #0
    2728:	strb	r2, [r3, #0]
			txBufferLength = 0;
			if (user_onRequest != NULL) {
    272a:	ldr.w	r3, [r4, #308]	; 0x134
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
			txBufferLength = 0;
    272e:	strb.w	r2, [r4, #301]	; 0x12d
			if (user_onRequest != NULL) {
    2732:	cbz	r3, 2736 <TwoWire::isr()+0x42>
				user_onRequest();
    2734:	blx	r3
			}
			if (txBufferLength == 0) {
    2736:	ldrb.w	r3, [r4, #301]	; 0x12d
    273a:	cbnz	r3, 2746 <TwoWire::isr()+0x52>
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    273c:	movs	r2, #1
    273e:	strb.w	r2, [r4, #301]	; 0x12d
				txBuffer[0] = 0;
    2742:	strb.w	r3, [r4, #163]	; 0xa3
    2746:	ldr	r3, [r4, #16]
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    2748:	movs	r2, #208	; 0xd0
    274a:	strb	r2, [r3, #2]
    274c:	ldr	r3, [r4, #16]
			port().D = txBuffer[0];
    274e:	ldrb.w	r2, [r4, #163]	; 0xa3
    2752:	strb	r2, [r3, #4]
			txBufferIndex = 1;
    2754:	movs	r3, #1
    2756:	strb.w	r3, [r4, #300]	; 0x12c
    275a:	b.n	27fa <TwoWire::isr()+0x106>
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    275c:	movs	r1, #1
    275e:	strb	r1, [r3, #0]
			rxBufferLength = 0;
    2760:	strb.w	r2, [r4, #161]	; 0xa1
    2764:	ldr	r3, [r4, #16]
    2766:	b.n	27c6 <TwoWire::isr()+0xd2>
    2768:	ldr	r2, [r4, #16]
		}
		port().S = I2C_S_IICIF;
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
    276a:	ldrb	r3, [r2, #6]
    276c:	uxtb	r3, r3
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
    276e:	and.w	r0, r3, #96	; 0x60
    2772:	cmp	r0, #96	; 0x60
    2774:	bne.n	278c <TwoWire::isr()+0x98>
		port().FLT = c1 & ~I2C_FLT_STOPIE;
    2776:	and.w	r3, r3, #223	; 0xdf
    277a:	strb	r3, [r2, #6]
		if (user_onReceive != NULL) {
    277c:	ldr.w	r3, [r4, #312]	; 0x138
    2780:	cbz	r3, 278c <TwoWire::isr()+0x98>
			rxBufferIndex = 0;
    2782:	strb.w	r1, [r4, #160]	; 0xa0
			user_onReceive(rxBufferLength);
    2786:	ldrb.w	r0, [r4, #161]	; 0xa1
    278a:	blx	r3
    278c:	ldr	r3, [r4, #16]
		}
	}
	#endif
	c1 = port().C1;
    278e:	ldrb	r2, [r3, #2]
	if (c1 & I2C_C1_TX) {
    2790:	and.w	r2, r2, #16
    2794:	and.w	r1, r2, #255	; 0xff
    2798:	cbz	r2, 27d0 <TwoWire::isr()+0xdc>
		// Continue Slave Transmit
		//serial_print("t");
		if ((status & I2C_S_RXAK) == 0) {
    279a:	ands.w	r5, r5, #1
    279e:	bne.n	27c6 <TwoWire::isr()+0xd2>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
    27a0:	ldrb.w	r2, [r4, #300]	; 0x12c
    27a4:	ldrb.w	r1, [r4, #301]	; 0x12d
    27a8:	cmp	r1, r2
				port().D = txBuffer[txBufferIndex++];
    27aa:	itttt	hi
    27ac:	addhi	r1, r2, #1
    27ae:	addhi	r2, r2, r4
    27b0:	strbhi.w	r1, [r4, #300]	; 0x12c
    27b4:	ldrbhi.w	r2, [r2, #163]	; 0xa3
    27b8:	ite	hi
    27ba:	strbhi	r2, [r3, #4]
			} else {
				port().D = 0;
    27bc:	strbls	r5, [r3, #4]
    27be:	ldr	r3, [r4, #16]
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    27c0:	movs	r2, #208	; 0xd0
    27c2:	strb	r2, [r3, #2]
    27c4:	b.n	27fa <TwoWire::isr()+0x106>
		} else {
			//serial_print("*");
			// Master did not ACK previous byte
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    27c6:	movs	r2, #192	; 0xc0
    27c8:	strb	r2, [r3, #2]
    27ca:	ldr	r3, [r4, #16]
			data = port().D;
    27cc:	ldrb	r3, [r3, #4]
    27ce:	b.n	27fa <TwoWire::isr()+0x106>
		}
	} else {
		// Continue Slave Receive
		irqcount = 0;
    27d0:	strb.w	r1, [r4, #304]	; 0x130
		#ifdef WIRE_HAS_STOP_INTERRUPT
		port().FLT |= I2C_FLT_STOPIE;
    27d4:	ldrb	r2, [r3, #6]
    27d6:	orr.w	r2, r2, #32
    27da:	strb	r2, [r3, #6]
    27dc:	ldr	r3, [r4, #16]
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    27de:	ldrb	r2, [r3, #4]
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    27e0:	ldrb.w	r3, [r4, #161]	; 0xa1
    27e4:	cmp	r3, #135	; 0x87
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    27e6:	uxtb	r2, r2
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    27e8:	bhi.n	27fa <TwoWire::isr()+0x106>
    27ea:	ldr	r1, [pc, #24]	; (2804 <TwoWire::isr()+0x110>)
    27ec:	ldrb	r1, [r1, #0]
    27ee:	cbz	r1, 27fa <TwoWire::isr()+0x106>
			rxBuffer[rxBufferLength++] = data;
    27f0:	adds	r1, r3, #1
    27f2:	add	r3, r4
    27f4:	strb.w	r1, [r4, #161]	; 0xa1
    27f8:	strb	r2, [r3, #24]
    27fa:	ldr	r3, [r4, #16]
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    27fc:	movs	r2, #2
    27fe:	strb	r2, [r3, #3]
    2800:	pop	{r3, r4, r5, pc}
    2802:	nop
    2804:	.word	0x2001a1c4

00002808 <TwoWire::wait_idle()>:
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    2808:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    280c:	ldr	r5, [pc, #208]	; (28e0 <L_1220_delayMicroseconds+0x20>)
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    280e:	ldr	r7, [pc, #212]	; (28e4 <L_1220_delayMicroseconds+0x24>)
    2810:	ldr	r3, [r5, #0]
    2812:	str	r3, [sp, #0]
	return ret;
    2814:	ldr.w	r8, [sp]
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    2818:	mov	r4, r0
	bool reset=false;
    281a:	movs	r1, #0
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    281c:	movs	r6, #160	; 0xa0
    281e:	ldr	r2, [r4, #16]
	uint8_t i2c_status(void) {
		return port().S;
    2820:	ldrb	r3, [r2, #3]
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    2822:	lsls	r3, r3, #26
    2824:	bpl.n	28d8 <L_1220_delayMicroseconds+0x18>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2826:	ldr	r3, [r5, #0]
    2828:	str	r3, [sp, #4]
	return ret;
    282a:	ldr	r3, [sp, #4]
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
    282c:	rsb	r3, r8, r3
#if 1
		if (waited > 15 && !reset) {
    2830:	cmp	r3, #15
    2832:	bls.n	281e <TwoWire::wait_idle()+0x16>
    2834:	cmp	r1, #0
    2836:	bne.n	28c8 <L_1220_delayMicroseconds+0x8>
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
    2838:	ldr	r2, [r4, #20]
    283a:	ldrb.w	r3, [r4, #305]	; 0x131
    283e:	add	r3, r2
			pinMode(sda_pin, INPUT_DISABLE);
    2840:	movs	r1, #5
    2842:	ldrb	r0, [r3, #8]
    2844:	bl	94b0 <pinMode>
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    2848:	ldr	r2, [r4, #20]
    284a:	ldrb.w	r3, [r4, #305]	; 0x131
    284e:	add	r3, r2
			pinMode(scl_pin, OUTPUT);
    2850:	movs	r1, #1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    2852:	ldrb.w	sl, [r3, #18]
			pinMode(scl_pin, OUTPUT);
    2856:	mov	r0, sl
    2858:	bl	94b0 <pinMode>
    285c:	mov.w	r9, #9
			for (int i=0; i < 9; i++) {
				digitalWrite(scl_pin, LOW);
    2860:	movs	r1, #0
    2862:	mov	r0, sl
    2864:	bl	9470 <digitalWrite>
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    2868:	mov	r3, r6

0000286a <L_1161_delayMicroseconds>:
    286a:	subs	r3, #1
    286c:	bne.n	286a <L_1161_delayMicroseconds>
				delayMicroseconds(5);
				digitalWrite(scl_pin, HIGH);
    286e:	movs	r1, #1
    2870:	mov	r0, sl
    2872:	bl	9470 <digitalWrite>
    2876:	mov	r3, r6

00002878 <L_1175_delayMicroseconds>:
    2878:	subs	r3, #1
    287a:	bne.n	2878 <L_1175_delayMicroseconds>
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
			pinMode(scl_pin, OUTPUT);
			for (int i=0; i < 9; i++) {
    287c:	subs.w	r9, r9, #1
    2880:	bne.n	2860 <TwoWire::wait_idle()+0x58>
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    2882:	ldr	r0, [r4, #20]
    2884:	ldrb.w	r2, [r4, #305]	; 0x131
    2888:	add	r2, r0
    288a:	ldrb	r1, [r2, #8]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    288c:	ldrb	r3, [r2, #13]
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    288e:	add.w	r1, r7, r1, lsl #3
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    2892:	lsls	r3, r3, #8
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    2894:	ldr	r1, [r1, #4]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    2896:	and.w	r3, r3, #1792	; 0x700
    289a:	orr.w	r3, r3, #100	; 0x64
    289e:	str	r3, [r1, #0]
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    28a0:	ldrb.w	r3, [r4, #306]	; 0x132
    28a4:	add	r3, r0
    28a6:	ldrb	r2, [r3, #18]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    28a8:	ldrb	r3, [r3, #23]
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    28aa:	add.w	r2, r7, r2, lsl #3
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    28ae:	lsls	r3, r3, #8
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    28b0:	ldr	r2, [r2, #4]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    28b2:	and.w	r3, r3, #1792	; 0x700
    28b6:	orr.w	r3, r3, #100	; 0x64
    28ba:	str	r3, [r2, #0]
    28bc:	mov.w	r3, #320	; 0x140

000028c0 <L_1220_delayMicroseconds>:
    28c0:	subs	r3, #1
    28c2:	bne.n	28c0 <L_1220_delayMicroseconds>
	while (i2c_status() & I2C_S_BUSY) {
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
    28c4:	movs	r1, #1
    28c6:	b.n	281e <TwoWire::wait_idle()+0x16>
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			delayMicroseconds(10);
			continue;
		}
#endif
		if (waited > 16) {
    28c8:	cmp	r3, #16
    28ca:	beq.n	281e <TwoWire::wait_idle()+0x16>
			// bus stuck busy too long
			port().C1 = 0;
    28cc:	movs	r0, #0
    28ce:	strb	r0, [r2, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    28d0:	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    28d2:	movs	r2, #128	; 0x80
    28d4:	strb	r2, [r3, #2]
			//Serial.println("abort");
			//return 4; // timeout waiting for bus
			return false;
    28d6:	b.n	28da <L_1220_delayMicroseconds+0x1a>
		}
	}
	return true;
    28d8:	movs	r0, #1
}
    28da:	add	sp, #8
    28dc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    28e0:	.word	0x2001a6fc
    28e4:	.word	0x00012e88

000028e8 <TwoWire::endTransmission(unsigned char)>:

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    28e8:	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    28ec:	ldr	r3, [r0, #16]
	uint8_t i, status, ret=0;
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    28ee:	movs	r2, #18
    28f0:	strb	r2, [r3, #3]
    28f2:	ldr	r2, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    28f4:	ldrb	r3, [r2, #2]
    28f6:	and.w	r3, r3, #32
	}
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    28fa:	mov	r4, r0
    28fc:	mov	r5, r1
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    28fe:	and.w	r6, r3, #255	; 0xff
    2902:	cbz	r3, 290a <TwoWire::endTransmission(unsigned char)+0x22>
		// we are already the bus master, so send a repeated start
		//Serial.print("rstart:");
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    2904:	movs	r3, #180	; 0xb4
    2906:	strb	r3, [r2, #2]
    2908:	b.n	291c <TwoWire::endTransmission(unsigned char)+0x34>
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    290a:	bl	2808 <TwoWire::wait_idle()>
    290e:	cmp	r0, #0
    2910:	beq.n	29d4 <TwoWire::endTransmission(unsigned char)+0xec>
    2912:	ldr	r3, [r4, #16]
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    2914:	strb.w	r6, [r4, #303]	; 0x12f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    2918:	movs	r2, #176	; 0xb0
    291a:	strb	r2, [r3, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    291c:	ldr	r3, [pc, #188]	; (29dc <TwoWire::endTransmission(unsigned char)+0xf4>)
    291e:	ldr	r1, [r4, #16]
    2920:	ldr	r2, [r3, #0]
    2922:	str	r2, [sp, #0]
	return ret;
    2924:	ldr	r6, [sp, #0]
	uint8_t i2c_status(void) {
		return port().S;
    2926:	ldrb	r2, [r1, #3]
	}
	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    2928:	and.w	r2, r2, #32
    292c:	and.w	r0, r2, #255	; 0xff
    2930:	cmp	r2, #0
    2932:	beq.n	29c0 <TwoWire::endTransmission(unsigned char)+0xd8>
    2934:	movs	r0, #0
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    2936:	movs	r7, #2
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
    2938:	ldrb.w	r2, [r4, #301]	; 0x12d
    293c:	uxtb	r1, r0
    293e:	cmp	r2, r1
    2940:	bls.n	29ae <TwoWire::endTransmission(unsigned char)+0xc6>
		port().D = txBuffer[i];
    2942:	adds	r6, r4, r1
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    2944:	ldr	r2, [r4, #16]
    2946:	ldrb.w	r6, [r6, #163]	; 0xa3
    294a:	strb	r6, [r2, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    294c:	ldr	r2, [r3, #0]
    294e:	str	r2, [sp, #12]
	return ret;
    2950:	ldr.w	r8, [sp, #12]
    2954:	ldr	r6, [r4, #16]
	uint8_t i2c_status(void) {
		return port().S;
    2956:	ldrb	r2, [r6, #3]
    2958:	uxtb	r2, r2
		//Serial.write('^');
		wait_begin = millis();
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
    295a:	and.w	lr, r2, #2
    295e:	and.w	ip, lr, #255	; 0xff
    2962:	cmp.w	lr, #0
    2966:	bne.n	2980 <TwoWire::endTransmission(unsigned char)+0x98>
			if (!(status & I2C_S_BUSY)) break;
    2968:	lsls	r2, r2, #26
    296a:	bpl.n	2980 <TwoWire::endTransmission(unsigned char)+0x98>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    296c:	ldr	r2, [r3, #0]
    296e:	str	r2, [sp, #8]
	return ret;
    2970:	ldr	r2, [sp, #8]
			if (millis() - wait_begin > 5) {
    2972:	rsb	r2, r8, r2
    2976:	cmp	r2, #5
    2978:	bls.n	2956 <TwoWire::endTransmission(unsigned char)+0x6e>
				port().C1 = 0;
    297a:	strb.w	ip, [r6, #2]
    297e:	b.n	29ce <TwoWire::endTransmission(unsigned char)+0xe6>
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    2980:	strb	r7, [r6, #3]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    2982:	ldr	r6, [r4, #16]
	uint8_t i2c_status(void) {
		return port().S;
    2984:	ldrb	r2, [r6, #3]
    2986:	uxtb	r2, r2
		//Serial.write('$');
		status = i2c_status();
		if ((status & I2C_S_ARBL)) {
    2988:	tst.w	r2, #16
    298c:	bne.n	2994 <TwoWire::endTransmission(unsigned char)+0xac>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("endTransmission err4\n");
			ret = 4; // 4:other error
			break;
		}
		if (!(status & I2C_S_BUSY)) {
    298e:	tst.w	r2, #32
    2992:	bne.n	299c <TwoWire::endTransmission(unsigned char)+0xb4>
			// suddenly lost control of the bus!
			port().C1 = I2C_C1_IICEN;
    2994:	movs	r3, #128	; 0x80
    2996:	strb	r3, [r6, #2]
			//Serial.printf("endTransmission err5\n");
			ret = 4; // 4:other error
    2998:	movs	r0, #4
    299a:	b.n	29b0 <TwoWire::endTransmission(unsigned char)+0xc8>
			break;
		}
		if (status & I2C_S_RXAK) {
    299c:	lsls	r2, r2, #31
    299e:	add.w	r0, r0, #1
    29a2:	bpl.n	2938 <TwoWire::endTransmission(unsigned char)+0x50>
			if (i == 0) {
				//Serial.printf("endTransmission err6\n");
				ret = 2; // 2:received NACK on transmit of address
			} else {
				//Serial.printf("endTransmission err7\n");
				ret = 3; // 3:received NACK on transmit of data 
    29a4:	cmp	r1, #0
    29a6:	ite	eq
    29a8:	moveq	r0, #2
    29aa:	movne	r0, #3
    29ac:	b.n	29b2 <TwoWire::endTransmission(unsigned char)+0xca>
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
	uint8_t i, status, ret=0;
    29ae:	movs	r0, #0
			}
			sendStop = 1;
			break;
		}
	}
	if (sendStop) {
    29b0:	cbz	r5, 29b8 <TwoWire::endTransmission(unsigned char)+0xd0>
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    29b2:	ldr	r3, [r4, #16]
		// send the stop condition
		port().C1 = I2C_C1_IICEN;
    29b4:	movs	r2, #128	; 0x80
    29b6:	strb	r2, [r3, #2]
		// TODO: do we wait for this somehow?
	}
	transmitting = 0;
    29b8:	movs	r3, #0
    29ba:	strb.w	r3, [r4, #302]	; 0x12e
    29be:	b.n	29d6 <TwoWire::endTransmission(unsigned char)+0xee>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    29c0:	ldr	r2, [r3, #0]
    29c2:	str	r2, [sp, #4]
	return ret;
    29c4:	ldr	r2, [sp, #4]
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		//Serial.write('*') ;
		if (millis() - wait_begin > 4) {
    29c6:	subs	r2, r2, r6
    29c8:	cmp	r2, #4
    29ca:	bls.n	2926 <TwoWire::endTransmission(unsigned char)+0x3e>
			port().C1 = 0;
    29cc:	strb	r0, [r1, #2]
    29ce:	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    29d0:	movs	r2, #128	; 0x80
    29d2:	strb	r2, [r3, #2]
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
    29d4:	movs	r0, #4
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    29d6:	add	sp, #16
    29d8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    29dc:	.word	0x2001a6fc

000029e0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>:


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    29e0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    29e4:	mov	r9, r3
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
	uint32_t wait_begin;

	rxBufferIndex = 0;
    29e6:	movs	r3, #0
    29e8:	strb.w	r3, [r0, #160]	; 0xa0
	rxBufferLength = 0;
    29ec:	strb.w	r3, [r0, #161]	; 0xa1
    29f0:	ldr	r3, [r0, #16]
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    29f2:	mov	r7, r2

	rxBufferIndex = 0;
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    29f4:	movs	r2, #18
    29f6:	strb	r2, [r3, #3]
    29f8:	ldr	r2, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    29fa:	ldrb	r3, [r2, #2]
    29fc:	and.w	r3, r3, #32
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    2a00:	sub	sp, #36	; 0x24
    2a02:	mov	r5, r0
    2a04:	mov	r8, r1
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    2a06:	and.w	r4, r3, #255	; 0xff
    2a0a:	cbz	r3, 2a12 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x32>
		// we are already the bus master, so send a repeated start
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    2a0c:	movs	r3, #180	; 0xb4
    2a0e:	strb	r3, [r2, #2]
    2a10:	b.n	2a26 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x46>
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    2a12:	bl	2808 <TwoWire::wait_idle()>
    2a16:	cmp	r0, #0
    2a18:	beq.w	2b8e <L_2399_delayMicroseconds+0x3e>
    2a1c:	ldr	r3, [r5, #16]
			//Serial.printf("requestFrom err1\n");
			return 0; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    2a1e:	strb.w	r4, [r5, #303]	; 0x12f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    2a22:	movs	r2, #176	; 0xb0
    2a24:	strb	r2, [r3, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2a26:	ldr	r6, [pc, #368]	; (2b98 <L_2399_delayMicroseconds+0x48>)
    2a28:	ldr	r2, [r5, #16]
    2a2a:	ldr	r3, [r6, #0]
    2a2c:	str	r3, [sp, #0]
	return ret;
    2a2e:	ldr	r1, [sp, #0]
	uint8_t i2c_status(void) {
		return port().S;
    2a30:	ldrb	r3, [r2, #3]
    2a32:	and.w	r3, r3, #32

	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    2a36:	and.w	r4, r3, #255	; 0xff
    2a3a:	cbnz	r3, 2a4a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x6a>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2a3c:	ldr	r3, [r6, #0]
    2a3e:	str	r3, [sp, #4]
	return ret;
    2a40:	ldr	r3, [sp, #4]
		if (millis() - wait_begin > 4) {
    2a42:	subs	r3, r3, r1
    2a44:	cmp	r3, #4
    2a46:	bls.n	2a30 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x50>
    2a48:	b.n	2a7a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x9a>
			//Serial.printf("requestFrom err2\n");
			return 0; // error generating start condition
		}
	}
	// send the address
	port().D = (address << 1) | 1;
    2a4a:	mov.w	r8, r8, lsl #1
    2a4e:	orr.w	r8, r8, #1
    2a52:	uxtb.w	r8, r8
    2a56:	strb.w	r8, [r2, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2a5a:	ldr	r3, [r6, #0]
    2a5c:	str	r3, [sp, #8]
	return ret;
    2a5e:	ldr	r1, [sp, #8]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    2a60:	ldr	r2, [r5, #16]
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    2a62:	ldrb	r3, [r2, #3]
    2a64:	and.w	r3, r3, #2
    2a68:	and.w	r4, r3, #255	; 0xff
    2a6c:	cbnz	r3, 2a82 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xa2>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2a6e:	ldr	r3, [r6, #0]
    2a70:	str	r3, [sp, #12]
	return ret;
    2a72:	ldr	r3, [sp, #12]
		if (millis() - wait_begin > 5) {
    2a74:	subs	r3, r3, r1
    2a76:	cmp	r3, #5
    2a78:	bls.n	2a62 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x82>
			port().C1 = 0;
    2a7a:	strb	r4, [r2, #2]
    2a7c:	ldr	r3, [r5, #16]
			port().C1 = I2C_C1_IICEN;
    2a7e:	movs	r2, #128	; 0x80
    2a80:	b.n	2aa4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xc4>
			//Serial.printf("requestFrom err3\n");
			return 0; // clock stretch too long (during address)
		}
	}
	port().S = I2C_S_IICIF;
    2a82:	movs	r3, #2
    2a84:	strb	r3, [r2, #3]
    2a86:	ldr	r3, [r5, #16]
	uint8_t i2c_status(void) {
		return port().S;
    2a88:	ldrb	r0, [r3, #3]
	status = i2c_status();
	if ((status & I2C_S_RXAK) || (status & I2C_S_ARBL)) {
    2a8a:	ands.w	r4, r0, #17
    2a8e:	beq.n	2a98 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xb8>
		// the slave device did not acknowledge
		// or we lost bus arbitration to another master
		port().C1 = I2C_C1_IICEN;
    2a90:	movs	r2, #128	; 0x80
    2a92:	strb	r2, [r3, #2]
		//Serial.printf("requestFrom err4\n");
		return 0;
    2a94:	movs	r4, #0
    2a96:	b.n	2b8e <L_2399_delayMicroseconds+0x3e>
	}
	if (length == 0) {
    2a98:	cbnz	r7, 2aa8 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xc8>
		// TODO: does anybody really do zero length reads?
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
    2a9a:	cmp.w	r9, #0
    2a9e:	ite	ne
    2aa0:	movne	r2, #128	; 0x80
    2aa2:	moveq	r2, #160	; 0xa0
    2aa4:	strb	r2, [r3, #2]
		//Serial.printf("requestFrom err5\n");
		return 0;
    2aa6:	b.n	2b8e <L_2399_delayMicroseconds+0x3e>
	} else if (length == 1) {
    2aa8:	cmp	r7, #1
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    2aaa:	ite	eq
    2aac:	moveq	r2, #168	; 0xa8
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
    2aae:	movne	r2, #160	; 0xa0
    2ab0:	strb	r2, [r3, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    2ab2:	ldr	r3, [r5, #16]
	}
	tmp = port().D; // initiate the first receive
    2ab4:	ldrb	r3, [r3, #4]


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
    2ab6:	movs	r0, #0
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    2ab8:	movs	r1, #2
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    2aba:	movs	r4, #168	; 0xa8
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
	}
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
    2abc:	cmp	r7, #1
    2abe:	ldr	r2, [r5, #16]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2ac0:	ldr	r3, [r6, #0]
    2ac2:	beq.n	2b1c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x13c>
    2ac4:	str	r3, [sp, #16]
	return ret;
    2ac6:	ldr.w	ip, [sp, #16]
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
    2aca:	ldrb	r3, [r2, #3]
    2acc:	and.w	r3, r3, #2
    2ad0:	and.w	lr, r3, #255	; 0xff
    2ad4:	cbnz	r3, 2aea <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x10a>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2ad6:	ldr	r3, [r6, #0]
    2ad8:	str	r3, [sp, #20]
	return ret;
    2ada:	ldr	r3, [sp, #20]
			if (millis() - wait_begin > 5) {
    2adc:	rsb	r3, ip, r3
    2ae0:	cmp	r3, #5
    2ae2:	bls.n	2aca <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xea>
				port().C1 = 0;
    2ae4:	strb.w	lr, [r2, #2]
    2ae8:	b.n	2b82 <L_2399_delayMicroseconds+0x32>
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    2aea:	strb	r1, [r2, #3]
    2aec:	ldr	r2, [r5, #16]
		status = port().S;
    2aee:	ldrb	r3, [r2, #3]
    2af0:	uxtb	r3, r3
		if ((status & I2C_S_ARBL)) {
    2af2:	tst.w	r3, #16
    2af6:	bne.n	2b8c <L_2399_delayMicroseconds+0x3c>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7a\n");
			return count;
		}
		if (!(status & I2C_S_BUSY)) {
    2af8:	lsls	r3, r3, #26
    2afa:	bpl.n	2b8c <L_2399_delayMicroseconds+0x3c>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
    2afc:	subs	r7, #1
    2afe:	uxtb	r7, r7
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    2b00:	cmp	r7, #1
    2b02:	it	eq
    2b04:	strbeq	r4, [r2, #2]
    2b06:	ldr	r3, [r5, #16]
		if (count < BUFFER_LENGTH) {
    2b08:	cmp	r0, #135	; 0x87
			rxBuffer[count++] = port().D;
    2b0a:	itttt	ls
    2b0c:	addls	r2, r0, #1
    2b0e:	addls	r0, r0, r5
    2b10:	ldrbls	r3, [r3, #4]
    2b12:	strbls	r3, [r0, #24]
		} else {
			tmp = port().D;
    2b14:	ite	hi
    2b16:	ldrbhi	r3, [r3, #4]
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
		if (count < BUFFER_LENGTH) {
			rxBuffer[count++] = port().D;
    2b18:	uxtbls	r0, r2
    2b1a:	b.n	2abc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xdc>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2b1c:	str	r3, [sp, #24]
	return ret;
    2b1e:	ldr	r4, [sp, #24]
		} else {
			tmp = port().D;
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    2b20:	ldrb	r3, [r2, #3]
    2b22:	and.w	r3, r3, #2
    2b26:	and.w	r1, r3, #255	; 0xff
    2b2a:	cbnz	r3, 2b3c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x15c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2b2c:	ldr	r3, [r6, #0]
    2b2e:	str	r3, [sp, #28]
	return ret;
    2b30:	ldr	r3, [sp, #28]
		if (millis() - wait_begin > 5) {
    2b32:	subs	r3, r3, r4
    2b34:	cmp	r3, #5
    2b36:	bls.n	2b20 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x140>
			port().C1 = 0;
    2b38:	strb	r1, [r2, #2]
    2b3a:	b.n	2b82 <L_2399_delayMicroseconds+0x32>
			rxBufferLength = count;
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
		}
	}
	port().S = I2C_S_IICIF;
    2b3c:	movs	r3, #2
    2b3e:	strb	r3, [r2, #3]
    2b40:	ldr	r2, [r5, #16]
	status = port().S;
    2b42:	ldrb	r3, [r2, #3]
    2b44:	uxtb	r3, r3
	if ((status & I2C_S_ARBL)) {
    2b46:	lsls	r1, r3, #27
    2b48:	bpl.n	2b60 <L_2399_delayMicroseconds+0x10>
		// we lost bus arbitration to another master
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//digitalWriteFast(13, HIGH);
		port().S = I2C_S_ARBL;
    2b4a:	movs	r3, #16
    2b4c:	strb	r3, [r2, #3]
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    2b4e:	movs	r3, #160	; 0xa0

00002b50 <L_2399_delayMicroseconds>:
    2b50:	subs	r3, #1
    2b52:	bne.n	2b50 <L_2399_delayMicroseconds>
    2b54:	ldr	r2, [r5, #16]
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
    2b56:	ldrb	r3, [r2, #2]
    2b58:	and.w	r3, r3, #247	; 0xf7
    2b5c:	strb	r3, [r2, #2]
    2b5e:	b.n	2b8c <L_2399_delayMicroseconds+0x3c>
		//Serial.printf("requestFrom err9a\n");
		return count;
	}
	if (!(status & I2C_S_BUSY)) {
    2b60:	lsls	r3, r3, #26
    2b62:	bpl.n	2b8c <L_2399_delayMicroseconds+0x3c>
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    2b64:	movs	r3, #176	; 0xb0
    2b66:	strb	r3, [r2, #2]
	if (count < BUFFER_LENGTH) {
    2b68:	cmp	r0, #135	; 0x87
    2b6a:	ldr	r3, [r5, #16]
		rxBuffer[count++] = port().D;
    2b6c:	itttt	ls
    2b6e:	addls	r2, r0, #1
    2b70:	addls	r0, r0, r5
    2b72:	ldrbls	r3, [r3, #4]
    2b74:	strbls	r3, [r0, #24]
	} else {
		tmp = port().D;
    2b76:	ite	hi
    2b78:	ldrbhi	r3, [r3, #4]
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
	if (count < BUFFER_LENGTH) {
		rxBuffer[count++] = port().D;
    2b7a:	uxtbls	r0, r2
#if F_CPU > 120000000
	__asm__("nop");
	__asm__("nop");
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
    2b7c:	cmp.w	r9, #0
    2b80:	beq.n	2b88 <L_2399_delayMicroseconds+0x38>
    2b82:	ldr	r3, [r5, #16]
    2b84:	movs	r2, #128	; 0x80
    2b86:	strb	r2, [r3, #2]
	rxBufferLength = count;
    2b88:	strb.w	r0, [r5, #161]	; 0xa1
    2b8c:	mov	r4, r0
	return count;
}
    2b8e:	mov	r0, r4
    2b90:	add	sp, #36	; 0x24
    2b92:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    2b96:	nop
    2b98:	.word	0x2001a6fc

00002b9c <i2c0_isr>:
#define MAKE_CONST(x) (__builtin_constant_p(x) ? (x) : (x))

#ifdef WIRE_IMPLEMENT_WIRE
constexpr uintptr_t i2c0_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C0));
TwoWire Wire(i2c0_addr, TwoWire::i2c0_hardware);
void i2c0_isr(void) { Wire.isr(); }
    2b9c:	ldr	r0, [pc, #4]	; (2ba4 <i2c0_isr+0x8>)
    2b9e:	b.w	26f4 <TwoWire::isr()>
    2ba2:	nop
    2ba4:	.word	0x1fff1080

00002ba8 <i2c1_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE1
constexpr uintptr_t i2c1_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C1));
TwoWire Wire1(i2c1_addr, TwoWire::i2c1_hardware);
void i2c1_isr(void) { Wire1.isr(); }
    2ba8:	ldr	r0, [pc, #4]	; (2bb0 <i2c1_isr+0x8>)
    2baa:	b.w	26f4 <TwoWire::isr()>
    2bae:	nop
    2bb0:	.word	0x1fff11bc

00002bb4 <i2c2_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE2
constexpr uintptr_t i2c2_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C2));
TwoWire Wire2(i2c2_addr, TwoWire::i2c2_hardware);
void i2c2_isr(void) { Wire2.isr(); }
    2bb4:	ldr	r0, [pc, #4]	; (2bbc <i2c2_isr+0x8>)
    2bb6:	b.w	26f4 <TwoWire::isr()>
    2bba:	nop
    2bbc:	.word	0x1fff0f44

00002bc0 <DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]>:

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    2bc0:	ldrh	r3, [r0, #30]
    2bc2:	lsls	r3, r3, #16
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    2bc4:	itttt	mi
    2bc6:	ldrhmi	r3, [r0, #30]
    2bc8:	ubfxmi	r1, r1, #0, #9
    2bcc:	andmi.w	r3, r3, #65024	; 0xfe00
    2bd0:	orrmi	r1, r3
#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
    2bd2:	it	pl
    2bd4:	ubfxpl	r1, r1, #0, #15
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    2bd8:	strh	r1, [r0, #30]
	}
	tcd->CITER = tcd->BITER; 
    2bda:	ldrh	r3, [r0, #30]
    2bdc:	uxth	r3, r3
    2bde:	strh	r3, [r0, #22]
    2be0:	bx	lr
    2be2:	Address 0x00002be2 is out of bounds.


00002be4 <SPIClass::begin()>:
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
	const SPI_Hardware_t & hardware() { return *(const SPI_Hardware_t *)hardware_addr; }
    2be4:	ldr	r3, [r0, #4]

void SPIClass::begin()
{
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    2be6:	ldr	r1, [r3, #0]
    2be8:	ldr	r2, [r3, #4]
SPIClass SPI2((uintptr_t)&KINETISK_SPI2, (uintptr_t)&SPIClass::spi2_hardware);
#endif


void SPIClass::begin()
{
    2bea:	push	{r4, lr}
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    2bec:	ldr	r4, [r1, #0]
    2bee:	orrs	r2, r4
    2bf0:	str	r2, [r1, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    2bf2:	ldr	r2, [r0, #0]
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
    2bf4:	ldr	r1, [pc, #84]	; (2c4c <SPIClass::begin()+0x68>)
    2bf6:	str	r1, [r2, #0]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    2bf8:	ldr	r1, [pc, #84]	; (2c50 <SPIClass::begin()+0x6c>)
    2bfa:	str	r1, [r2, #12]
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    2bfc:	add.w	r1, r1, #1073741824	; 0x40000000
    2c00:	str	r1, [r2, #16]
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
    2c02:	ldr	r1, [pc, #80]	; (2c54 <SPIClass::begin()+0x70>)
    2c04:	str	r1, [r2, #0]
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2c06:	ldrb	r1, [r0, #9]
    2c08:	ldr	r2, [pc, #76]	; (2c58 <SPIClass::begin()+0x74>)
    2c0a:	adds	r4, r3, r1
	*reg = hardware().mosi_mux[mosi_pin_index];
    2c0c:	adds	r1, #12
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2c0e:	ldrb.w	r4, [r4, #44]	; 0x2c
	*reg = hardware().mosi_mux[mosi_pin_index];
    2c12:	ldr.w	r1, [r3, r1, lsl #2]
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2c16:	add.w	r4, r2, r4, lsl #3
    2c1a:	ldr	r4, [r4, #4]
	*reg = hardware().mosi_mux[mosi_pin_index];
    2c1c:	str	r1, [r4, #0]
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2c1e:	ldrb	r1, [r0, #8]
    2c20:	adds	r4, r3, r1
	*reg= hardware().miso_mux[miso_pin_index];
    2c22:	add.w	r1, r3, r1, lsl #2
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2c26:	ldrb	r4, [r4, #24]
	*reg= hardware().miso_mux[miso_pin_index];
    2c28:	ldr	r1, [r1, #28]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2c2a:	add.w	r4, r2, r4, lsl #3
    2c2e:	ldr	r4, [r4, #4]
	*reg= hardware().miso_mux[miso_pin_index];
    2c30:	str	r1, [r4, #0]
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2c32:	ldrb	r1, [r0, #10]
    2c34:	adds	r0, r3, r1
	*reg = hardware().sck_mux[sck_pin_index];
    2c36:	add.w	r3, r3, r1, lsl #2
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2c3a:	ldrb.w	r0, [r0, #64]	; 0x40
	*reg = hardware().sck_mux[sck_pin_index];
    2c3e:	ldr	r3, [r3, #68]	; 0x44
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2c40:	add.w	r2, r2, r0, lsl #3
    2c44:	ldr	r2, [r2, #4]
	*reg = hardware().sck_mux[sck_pin_index];
    2c46:	str	r3, [r2, #0]
    2c48:	pop	{r4, pc}
    2c4a:	nop
    2c4c:	.word	0x001f4001
    2c50:	.word	0x38001001
    2c54:	.word	0x801f0000
    2c58:	.word	0x00012e88

00002c5c <SPIClass::setMOSI(unsigned char)>:
	return 0;
}

void SPIClass::setMOSI(uint8_t pin)
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2c5c:	ldr	r3, [r0, #4]
    2c5e:	ldr	r2, [pc, #140]	; (2cec <SPIClass::setMOSI(unsigned char)+0x90>)
    2c60:	cmp	r2, r3
	}
	return 0;
}

void SPIClass::setMOSI(uint8_t pin)
{
    2c62:	push	{r4, r5, r6, lr}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2c64:	bne.n	2c98 <SPIClass::setMOSI(unsigned char)+0x3c>
		pinout = newpinout;
#endif
	}
	inline void setMOSI_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 11) pinout &= ~3;
    2c66:	cmp	r1, #11
    2c68:	bne.n	2c74 <SPIClass::setMOSI(unsigned char)+0x18>
    2c6a:	ldr	r4, [pc, #132]	; (2cf0 <SPIClass::setMOSI(unsigned char)+0x94>)
    2c6c:	ldrb	r2, [r4, #0]
    2c6e:	bic.w	r2, r2, #3
    2c72:	b.n	2c96 <SPIClass::setMOSI(unsigned char)+0x3a>
		if (pin == 7)  pinout = (pinout & ~0x3) | 1;
    2c74:	cmp	r1, #7
    2c76:	bne.n	2c86 <SPIClass::setMOSI(unsigned char)+0x2a>
    2c78:	ldr	r4, [pc, #116]	; (2cf0 <SPIClass::setMOSI(unsigned char)+0x94>)
    2c7a:	ldrb	r2, [r4, #0]
    2c7c:	bic.w	r2, r2, #3
    2c80:	orr.w	r2, r2, #1
    2c84:	b.n	2c96 <SPIClass::setMOSI(unsigned char)+0x3a>
		if (pin == 28) pinout = (pinout & ~0x3) | 2;
    2c86:	cmp	r1, #28
    2c88:	bne.n	2c98 <SPIClass::setMOSI(unsigned char)+0x3c>
    2c8a:	ldr	r4, [pc, #100]	; (2cf0 <SPIClass::setMOSI(unsigned char)+0x94>)
    2c8c:	ldrb	r2, [r4, #0]
    2c8e:	bic.w	r2, r2, #3
    2c92:	orr.w	r2, r2, #2
    2c96:	strb	r2, [r4, #0]
		SPCR.setMOSI_soft(pin);
	}
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
    2c98:	ldrb	r2, [r0, #9]
    2c9a:	add	r2, r3
    2c9c:	ldrb.w	r4, [r2, #44]	; 0x2c
    2ca0:	cmp	r1, r4
    2ca2:	beq.n	2ce8 <SPIClass::setMOSI(unsigned char)+0x8c>
    2ca4:	add.w	r5, r3, #43	; 0x2b
    2ca8:	movs	r2, #0
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
    2caa:	ldrb.w	r6, [r5, #1]!
    2cae:	cmp	r6, r1
    2cb0:	bne.n	2ce2 <SPIClass::setMOSI(unsigned char)+0x86>
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    2cb2:	ldr	r1, [r3, #0]
    2cb4:	ldr	r5, [r1, #0]
    2cb6:	ldr	r1, [r3, #4]
    2cb8:	tst	r5, r1
    2cba:	beq.n	2cde <SPIClass::setMOSI(unsigned char)+0x82>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2cbc:	ldr	r1, [pc, #52]	; (2cf4 <SPIClass::setMOSI(unsigned char)+0x98>)
    2cbe:	add.w	r4, r1, r4, lsl #3
					*reg = 0;
    2cc2:	movs	r5, #0
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2cc4:	ldr	r4, [r4, #4]
					*reg = 0;
    2cc6:	str	r5, [r4, #0]
					reg = portConfigRegister(hardware().mosi_pin[i]);
    2cc8:	adds	r4, r3, r2
    2cca:	ldrb.w	r4, [r4, #44]	; 0x2c
    2cce:	add.w	r1, r1, r4, lsl #3
					*reg = hardware().mosi_mux[i];
    2cd2:	add.w	r4, r2, #12
			if  (pin == hardware().mosi_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().mosi_pin[i]);
    2cd6:	ldr	r1, [r1, #4]
					*reg = hardware().mosi_mux[i];
    2cd8:	ldr.w	r3, [r3, r4, lsl #2]
    2cdc:	str	r3, [r1, #0]
				}	
				mosi_pin_index = i;
    2cde:	strb	r2, [r0, #9]
				return;
    2ce0:	pop	{r4, r5, r6, pc}
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setMOSI_soft(pin);
	}
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
    2ce2:	adds	r2, #1
    2ce4:	cmp	r2, #4
    2ce6:	bne.n	2caa <SPIClass::setMOSI(unsigned char)+0x4e>
    2ce8:	pop	{r4, r5, r6, pc}
    2cea:	nop
    2cec:	.word	0x000129d8
    2cf0:	.word	0x2001a7f5
    2cf4:	.word	0x00012e88

00002cf8 <SPIClass::setMISO(unsigned char)>:
	}
}

void SPIClass::setMISO(uint8_t pin)
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2cf8:	ldr	r3, [r0, #4]
    2cfa:	ldr	r2, [pc, #132]	; (2d80 <SPIClass::setMISO(unsigned char)+0x88>)
    2cfc:	cmp	r2, r3
		}
	}
}

void SPIClass::setMISO(uint8_t pin)
{
    2cfe:	push	{r4, r5, r6, lr}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2d00:	bne.n	2d34 <SPIClass::setMISO(unsigned char)+0x3c>
		pinout = newpinout;
#endif
	}
	inline void setMISO_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 12) pinout &= ~0xc;
    2d02:	cmp	r1, #12
    2d04:	bne.n	2d10 <SPIClass::setMISO(unsigned char)+0x18>
    2d06:	ldr	r4, [pc, #124]	; (2d84 <SPIClass::setMISO(unsigned char)+0x8c>)
    2d08:	ldrb	r2, [r4, #0]
    2d0a:	bic.w	r2, r2, #12
    2d0e:	b.n	2d32 <SPIClass::setMISO(unsigned char)+0x3a>
		if (pin == 8)  pinout = (pinout & ~0xc) | 4;
    2d10:	cmp	r1, #8
    2d12:	bne.n	2d22 <SPIClass::setMISO(unsigned char)+0x2a>
    2d14:	ldr	r4, [pc, #108]	; (2d84 <SPIClass::setMISO(unsigned char)+0x8c>)
    2d16:	ldrb	r2, [r4, #0]
    2d18:	bic.w	r2, r2, #12
    2d1c:	orr.w	r2, r2, #4
    2d20:	b.n	2d32 <SPIClass::setMISO(unsigned char)+0x3a>
		if (pin == 39) pinout = (pinout & ~0xc) | 8;
    2d22:	cmp	r1, #39	; 0x27
    2d24:	bne.n	2d34 <SPIClass::setMISO(unsigned char)+0x3c>
    2d26:	ldr	r4, [pc, #92]	; (2d84 <SPIClass::setMISO(unsigned char)+0x8c>)
    2d28:	ldrb	r2, [r4, #0]
    2d2a:	bic.w	r2, r2, #12
    2d2e:	orr.w	r2, r2, #8
    2d32:	strb	r2, [r4, #0]
		SPCR.setMISO_soft(pin);
	}
	if (pin != hardware().miso_pin[miso_pin_index]) {
    2d34:	ldrb	r2, [r0, #8]
    2d36:	add	r2, r3
    2d38:	ldrb	r4, [r2, #24]
    2d3a:	cmp	r1, r4
    2d3c:	beq.n	2d7e <SPIClass::setMISO(unsigned char)+0x86>
    2d3e:	add.w	r5, r3, #23
    2d42:	movs	r2, #0
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
			if  (pin == hardware().miso_pin[i]) {
    2d44:	ldrb.w	r6, [r5, #1]!
    2d48:	cmp	r6, r1
    2d4a:	bne.n	2d78 <SPIClass::setMISO(unsigned char)+0x80>
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    2d4c:	ldr	r1, [r3, #0]
    2d4e:	ldr	r5, [r1, #0]
    2d50:	ldr	r1, [r3, #4]
    2d52:	tst	r5, r1
    2d54:	beq.n	2d74 <SPIClass::setMISO(unsigned char)+0x7c>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2d56:	ldr	r1, [pc, #48]	; (2d88 <SPIClass::setMISO(unsigned char)+0x90>)
    2d58:	add.w	r4, r1, r4, lsl #3
					*reg = 0;
    2d5c:	movs	r5, #0
	if (pin != hardware().miso_pin[miso_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2d5e:	ldr	r4, [r4, #4]
					*reg = 0;
    2d60:	str	r5, [r4, #0]
					reg = portConfigRegister(hardware().miso_pin[i]);
    2d62:	adds	r4, r3, r2
					*reg = hardware().miso_mux[i];
    2d64:	add.w	r3, r3, r2, lsl #2
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().miso_pin[i]);
    2d68:	ldrb	r4, [r4, #24]
					*reg = hardware().miso_mux[i];
    2d6a:	ldr	r3, [r3, #28]
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().miso_pin[i]);
    2d6c:	add.w	r1, r1, r4, lsl #3
    2d70:	ldr	r1, [r1, #4]
					*reg = hardware().miso_mux[i];
    2d72:	str	r3, [r1, #0]
				}	
				miso_pin_index = i;
    2d74:	strb	r2, [r0, #8]
				return;
    2d76:	pop	{r4, r5, r6, pc}
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setMISO_soft(pin);
	}
	if (pin != hardware().miso_pin[miso_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
    2d78:	adds	r2, #1
    2d7a:	cmp	r2, #4
    2d7c:	bne.n	2d44 <SPIClass::setMISO(unsigned char)+0x4c>
    2d7e:	pop	{r4, r5, r6, pc}
    2d80:	.word	0x000129d8
    2d84:	.word	0x2001a7f5
    2d88:	.word	0x00012e88

00002d8c <SPIClass::setSCK(unsigned char)>:
	}
}

void SPIClass::setSCK(uint8_t pin)
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2d8c:	ldr	r3, [r0, #4]
    2d8e:	ldr	r2, [pc, #148]	; (2e24 <SPIClass::setSCK(unsigned char)+0x98>)
    2d90:	cmp	r2, r3
		}
	}
}

void SPIClass::setSCK(uint8_t pin)
{
    2d92:	push	{r4, r5, lr}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2d94:	bne.n	2dc8 <SPIClass::setSCK(unsigned char)+0x3c>
		pinout = newpinout;
#endif
	}
	inline void setSCK_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 13) pinout &= ~0x30;
    2d96:	cmp	r1, #13
    2d98:	bne.n	2da4 <SPIClass::setSCK(unsigned char)+0x18>
    2d9a:	ldr	r4, [pc, #140]	; (2e28 <SPIClass::setSCK(unsigned char)+0x9c>)
    2d9c:	ldrb	r2, [r4, #0]
    2d9e:	bic.w	r2, r2, #48	; 0x30
    2da2:	b.n	2dc6 <SPIClass::setSCK(unsigned char)+0x3a>
		if (pin == 14) pinout = (pinout & ~0x30) | 0x10;
    2da4:	cmp	r1, #14
    2da6:	bne.n	2db6 <SPIClass::setSCK(unsigned char)+0x2a>
    2da8:	ldr	r4, [pc, #124]	; (2e28 <SPIClass::setSCK(unsigned char)+0x9c>)
    2daa:	ldrb	r2, [r4, #0]
    2dac:	bic.w	r2, r2, #48	; 0x30
    2db0:	orr.w	r2, r2, #16
    2db4:	b.n	2dc6 <SPIClass::setSCK(unsigned char)+0x3a>
		if (pin == 27) pinout = (pinout & ~0x30) | 0x20;
    2db6:	cmp	r1, #27
    2db8:	bne.n	2dc8 <SPIClass::setSCK(unsigned char)+0x3c>
    2dba:	ldr	r4, [pc, #108]	; (2e28 <SPIClass::setSCK(unsigned char)+0x9c>)
    2dbc:	ldrb	r2, [r4, #0]
    2dbe:	bic.w	r2, r2, #48	; 0x30
    2dc2:	orr.w	r2, r2, #32
    2dc6:	strb	r2, [r4, #0]
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
    2dc8:	ldrb	r2, [r0, #10]
    2dca:	add	r2, r3
    2dcc:	ldrb.w	r4, [r2, #64]	; 0x40
    2dd0:	cmp	r1, r4
    2dd2:	beq.n	2e22 <SPIClass::setSCK(unsigned char)+0x96>
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
    2dd4:	ldrb.w	r2, [r3, #64]	; 0x40
    2dd8:	cmp	r2, r1
    2dda:	beq.n	2df0 <SPIClass::setSCK(unsigned char)+0x64>
    2ddc:	ldrb.w	r2, [r3, #65]	; 0x41
    2de0:	cmp	r2, r1
    2de2:	beq.n	2df4 <SPIClass::setSCK(unsigned char)+0x68>
    2de4:	ldrb.w	r2, [r3, #66]	; 0x42
    2de8:	cmp	r2, r1
    2dea:	bne.n	2e22 <SPIClass::setSCK(unsigned char)+0x96>
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
    2dec:	movs	r2, #2
    2dee:	b.n	2df6 <SPIClass::setSCK(unsigned char)+0x6a>
			if  (pin == hardware().sck_pin[i]) {
    2df0:	movs	r2, #0
    2df2:	b.n	2df6 <SPIClass::setSCK(unsigned char)+0x6a>
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
    2df4:	movs	r2, #1
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    2df6:	ldr	r1, [r3, #0]
    2df8:	ldr	r5, [r1, #0]
    2dfa:	ldr	r1, [r3, #4]
    2dfc:	tst	r5, r1
    2dfe:	beq.n	2e20 <SPIClass::setSCK(unsigned char)+0x94>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2e00:	ldr	r1, [pc, #40]	; (2e2c <SPIClass::setSCK(unsigned char)+0xa0>)
    2e02:	add.w	r4, r1, r4, lsl #3
					*reg = 0;
    2e06:	movs	r5, #0
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2e08:	ldr	r4, [r4, #4]
					*reg = 0;
    2e0a:	str	r5, [r4, #0]
					reg = portConfigRegister(hardware().sck_pin[i]);
    2e0c:	adds	r4, r3, r2
					*reg = hardware().sck_mux[i];
    2e0e:	add.w	r3, r3, r2, lsl #2
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().sck_pin[i]);
    2e12:	ldrb.w	r4, [r4, #64]	; 0x40
					*reg = hardware().sck_mux[i];
    2e16:	ldr	r3, [r3, #68]	; 0x44
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().sck_pin[i]);
    2e18:	add.w	r1, r1, r4, lsl #3
    2e1c:	ldr	r1, [r1, #4]
					*reg = hardware().sck_mux[i];
    2e1e:	str	r3, [r1, #0]
				}	
				sck_pin_index = i;
    2e20:	strb	r2, [r0, #10]
    2e22:	pop	{r4, r5, pc}
    2e24:	.word	0x000129d8
    2e28:	.word	0x2001a7f5
    2e2c:	.word	0x00012e88

00002e30 <SPIClass::transfer(void const*, void*, unsigned int)>:
		}
	}
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{
    2e30:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	if (count == 0) return;
    2e34:	cmp	r3, #0
    2e36:	beq.w	2ff2 <SPIClass::transfer(void const*, void*, unsigned int)+0x1c2>
    2e3a:	ldr	r4, [r0, #0]
    2e3c:	ldr	r6, [pc, #440]	; (2ff8 <SPIClass::transfer(void const*, void*, unsigned int)+0x1c8>)
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    2e3e:	ldr	r5, [r4, #12]
		const uint8_t *p_write = (const uint8_t *)buf;
		uint8_t *p_read = (uint8_t *)retbuf;
		size_t count_read = count;

		// Lets clear the reader queue
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);
    2e40:	str	r6, [r4, #0]

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    2e42:	tst.w	r5, #16777216	; 0x1000000
    2e46:	and.w	r5, r3, #1
    2e4a:	bne.n	2f28 <SPIClass::transfer(void const*, void*, unsigned int)+0xf8>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2e4c:	cbz	r5, 2e74 <SPIClass::transfer(void const*, void*, unsigned int)+0x44>
		    if (p_write) {
    2e4e:	cbz	r1, 2e62 <SPIClass::transfer(void const*, void*, unsigned int)+0x32>
    2e50:	adds	r5, r1, #1
    2e52:	ldrb	r1, [r1, #0]
				if (count > 1)
    2e54:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2e56:	it	ne
    2e58:	orrne.w	r1, r1, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    2e5c:	str	r1, [r4, #52]	; 0x34
    2e5e:	mov	r1, r5
    2e60:	b.n	2e70 <SPIClass::transfer(void const*, void*, unsigned int)+0x40>
    2e62:	ldrb.w	r5, [r0, #44]	; 0x2c
			} else {
				if (count > 1)
    2e66:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2e68:	it	ne
    2e6a:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    2e6e:	str	r5, [r4, #52]	; 0x34
			}
			count--;
    2e70:	subs	r6, r3, #1
    2e72:	b.n	2e76 <SPIClass::transfer(void const*, void*, unsigned int)+0x46>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2e74:	mov	r6, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    2e76:	ldrb.w	r4, [r0, #44]	; 0x2c
    2e7a:	orr.w	r4, r4, r4, lsl #8

		while (count > 0) {
    2e7e:	cmp	r6, #0
    2e80:	beq.n	2f00 <SPIClass::transfer(void const*, void*, unsigned int)+0xd0>
			// Push out the next byte; 
		    if (p_write) {
    2e82:	cbz	r1, 2e92 <SPIClass::transfer(void const*, void*, unsigned int)+0x62>
		    	w = (*p_write++) << 8;
    2e84:	mov	r5, r1
				w |= *p_write++;
    2e86:	ldrb	r1, [r1, #1]
	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;

		while (count > 0) {
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
    2e88:	ldrb.w	r4, [r5], #2
				w |= *p_write++;
    2e8c:	orr.w	r4, r1, r4, lsl #8
    2e90:	mov	r1, r5
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2e92:	ldr	r5, [r0, #4]
    2e94:	ldr	r7, [r0, #0]
    2e96:	ldrb	r5, [r5, #8]
			if (count == 2)
    2e98:	cmp	r6, #2
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2e9a:	add.w	r5, r5, #4294967295
    2e9e:	mov.w	r5, r5, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    2ea2:	ite	eq
    2ea4:	orreq.w	lr, r4, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2ea8:	orrne.w	lr, r4, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2eac:	uxth	r5, r5
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2eae:	str.w	lr, [r7, #52]	; 0x34
			count -= 2; // how many bytes to output.
    2eb2:	subs	r6, #2
    2eb4:	ldr.w	lr, [r0]
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    2eb8:	ldr.w	r7, [lr, #44]	; 0x2c
				if (sr & 0xF0)  {
    2ebc:	tst.w	r7, #240	; 0xf0
    2ec0:	beq.n	2eec <SPIClass::transfer(void const*, void*, unsigned int)+0xbc>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    2ec2:	tst.w	r3, #1
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    2ec6:	ldr.w	ip, [lr, #56]	; 0x38
					if (count_read & 1) {
    2eca:	beq.n	2ed8 <SPIClass::transfer(void const*, void*, unsigned int)+0xa8>
						if (p_read) {
    2ecc:	cbz	r2, 2ed4 <SPIClass::transfer(void const*, void*, unsigned int)+0xa4>
							*p_read++ = w;  // Read any pending RX bytes in
    2ece:	strb.w	ip, [r2]
    2ed2:	adds	r2, #1
						} 
						count_read--;
    2ed4:	subs	r3, #1
    2ed6:	b.n	2eec <SPIClass::transfer(void const*, void*, unsigned int)+0xbc>
					} else {
						if (p_read) {
    2ed8:	cbz	r2, 2eea <SPIClass::transfer(void const*, void*, unsigned int)+0xba>
							*p_read++ = w >> 8;
    2eda:	mov	lr, r2
    2edc:	mov.w	r8, ip, asr #8
    2ee0:	strb.w	r8, [lr], #2
							*p_read++ = (w & 0xff);
    2ee4:	strb.w	ip, [r2, #1]
    2ee8:	mov	r2, lr
						}
						count_read -= 2;
    2eea:	subs	r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    2eec:	and.w	r7, r7, #61440	; 0xf000
    2ef0:	cmp	r7, r5
    2ef2:	bhi.n	2eb4 <SPIClass::transfer(void const*, void*, unsigned int)+0x84>
    2ef4:	b.n	2e7e <SPIClass::transfer(void const*, void*, unsigned int)+0x4e>
    2ef6:	ldr	r1, [r0, #0]

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
    2ef8:	ldr	r4, [r1, #44]	; 0x2c
			if (sr & 0xF0)  {
    2efa:	tst.w	r4, #240	; 0xf0
    2efe:	bne.n	2f06 <SPIClass::transfer(void const*, void*, unsigned int)+0xd6>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    2f00:	cmp	r3, #0
    2f02:	bne.n	2ef6 <SPIClass::transfer(void const*, void*, unsigned int)+0xc6>
    2f04:	b.n	2ff2 <SPIClass::transfer(void const*, void*, unsigned int)+0x1c2>
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    2f06:	ldr	r4, [r1, #56]	; 0x38
				if (count_read & 1) {
    2f08:	lsls	r1, r3, #31
    2f0a:	bpl.n	2f16 <SPIClass::transfer(void const*, void*, unsigned int)+0xe6>
					if (p_read)
    2f0c:	cbz	r2, 2f12 <SPIClass::transfer(void const*, void*, unsigned int)+0xe2>
						*p_read++ = w;  // Read any pending RX bytes in
    2f0e:	strb	r4, [r2, #0]
    2f10:	adds	r2, #1
					count_read--;
    2f12:	subs	r3, #1
    2f14:	b.n	2f00 <SPIClass::transfer(void const*, void*, unsigned int)+0xd0>
				} else {
					if (p_read) {
    2f16:	cbz	r2, 2f24 <SPIClass::transfer(void const*, void*, unsigned int)+0xf4>
						*p_read++ = w >> 8;
    2f18:	mov	r1, r2
    2f1a:	asrs	r5, r4, #8
    2f1c:	strb.w	r5, [r1], #2
						*p_read++ = (w & 0xff);
    2f20:	strb	r4, [r2, #1]
    2f22:	mov	r2, r1
					}
					count_read -= 2;
    2f24:	subs	r3, #2
    2f26:	b.n	2f00 <SPIClass::transfer(void const*, void*, unsigned int)+0xd0>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2f28:	cbz	r5, 2f50 <SPIClass::transfer(void const*, void*, unsigned int)+0x120>
		    if (p_write) {
    2f2a:	cbz	r1, 2f3e <SPIClass::transfer(void const*, void*, unsigned int)+0x10e>
    2f2c:	adds	r5, r1, #1
    2f2e:	ldrb	r1, [r1, #0]
				if (count > 1)
    2f30:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2f32:	it	ne
    2f34:	orrne.w	r1, r1, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    2f38:	str	r1, [r4, #52]	; 0x34
    2f3a:	mov	r1, r5
    2f3c:	b.n	2f4c <SPIClass::transfer(void const*, void*, unsigned int)+0x11c>
    2f3e:	ldrb.w	r5, [r0, #44]	; 0x2c
			} else {
				if (count > 1)
    2f42:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2f44:	it	ne
    2f46:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    2f4a:	str	r5, [r4, #52]	; 0x34
			}
			count--;
    2f4c:	subs	r6, r3, #1
    2f4e:	b.n	2f52 <SPIClass::transfer(void const*, void*, unsigned int)+0x122>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2f50:	mov	r6, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w = _transferWriteFill;
    2f52:	ldrb.w	r7, [r0, #44]	; 0x2c

		while (count > 0) {
    2f56:	cmp	r6, #0
    2f58:	beq.n	2fca <SPIClass::transfer(void const*, void*, unsigned int)+0x19a>
			// Push out the next byte; 
		    if (p_write) {
    2f5a:	cbz	r1, 2f66 <SPIClass::transfer(void const*, void*, unsigned int)+0x136>
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
    2f5c:	ldrb	r7, [r1, #1]
    2f5e:	ldrb	r4, [r1, #0]
    2f60:	adds	r1, #2
    2f62:	orr.w	r7, r4, r7, lsl #8
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2f66:	ldr	r4, [r0, #4]
    2f68:	ldr	r5, [r0, #0]
    2f6a:	ldrb	r4, [r4, #8]
			if (count == 2)
    2f6c:	cmp	r6, #2
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2f6e:	add.w	r4, r4, #4294967295
    2f72:	mov.w	r4, r4, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    2f76:	ite	eq
    2f78:	orreq.w	lr, r7, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2f7c:	orrne.w	lr, r7, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2f80:	uxth	r4, r4
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2f82:	str.w	lr, [r5, #52]	; 0x34
			count -= 2; // how many bytes to output.
    2f86:	subs	r6, #2
    2f88:	ldr	r5, [r0, #0]
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    2f8a:	ldr.w	lr, [r5, #44]	; 0x2c
				if (sr & 0xF0)  {
    2f8e:	tst.w	lr, #240	; 0xf0
    2f92:	beq.n	2fb6 <SPIClass::transfer(void const*, void*, unsigned int)+0x186>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    2f94:	tst.w	r3, #1
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    2f98:	ldr	r5, [r5, #56]	; 0x38
					if (count_read & 1) {
    2f9a:	beq.n	2fa6 <SPIClass::transfer(void const*, void*, unsigned int)+0x176>
						if (p_read) {
    2f9c:	cbz	r2, 2fa2 <SPIClass::transfer(void const*, void*, unsigned int)+0x172>
							*p_read++ = w;  // Read any pending RX bytes in
    2f9e:	strb	r5, [r2, #0]
    2fa0:	adds	r2, #1
						} 
						count_read--;
    2fa2:	subs	r3, #1
    2fa4:	b.n	2fb6 <SPIClass::transfer(void const*, void*, unsigned int)+0x186>
					} else {
						if (p_read) {
    2fa6:	cbz	r2, 2fb4 <SPIClass::transfer(void const*, void*, unsigned int)+0x184>
							*p_read++ = (w & 0xff);
    2fa8:	mov	ip, r2
    2faa:	strb.w	r5, [ip], #2
							*p_read++ = w >> 8;
    2fae:	asrs	r5, r5, #8
    2fb0:	strb	r5, [r2, #1]
    2fb2:	mov	r2, ip
						}
						count_read -= 2;
    2fb4:	subs	r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    2fb6:	and.w	lr, lr, #61440	; 0xf000
    2fba:	cmp	lr, r4
    2fbc:	bhi.n	2f88 <SPIClass::transfer(void const*, void*, unsigned int)+0x158>
    2fbe:	b.n	2f56 <SPIClass::transfer(void const*, void*, unsigned int)+0x126>
    2fc0:	ldr	r1, [r0, #0]

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
    2fc2:	ldr	r4, [r1, #44]	; 0x2c
			if (sr & 0xF0)  {
    2fc4:	tst.w	r4, #240	; 0xf0
    2fc8:	bne.n	2fd0 <SPIClass::transfer(void const*, void*, unsigned int)+0x1a0>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    2fca:	cmp	r3, #0
    2fcc:	bne.n	2fc0 <SPIClass::transfer(void const*, void*, unsigned int)+0x190>
    2fce:	b.n	2ff2 <SPIClass::transfer(void const*, void*, unsigned int)+0x1c2>
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
				if (count_read & 1) {
    2fd0:	lsls	r4, r3, #31

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    2fd2:	ldr	r1, [r1, #56]	; 0x38
				if (count_read & 1) {
    2fd4:	bpl.n	2fe0 <SPIClass::transfer(void const*, void*, unsigned int)+0x1b0>
					if (p_read)
    2fd6:	cbz	r2, 2fdc <SPIClass::transfer(void const*, void*, unsigned int)+0x1ac>
						*p_read++ = w;  // Read any pending RX bytes in
    2fd8:	strb	r1, [r2, #0]
    2fda:	adds	r2, #1
					count_read--;
    2fdc:	subs	r3, #1
    2fde:	b.n	2fca <SPIClass::transfer(void const*, void*, unsigned int)+0x19a>
				} else {
					if (p_read) {
    2fe0:	cbz	r2, 2fee <SPIClass::transfer(void const*, void*, unsigned int)+0x1be>
						*p_read++ = (w & 0xff);
    2fe2:	mov	r4, r2
    2fe4:	strb.w	r1, [r4], #2
						*p_read++ = w >> 8;
    2fe8:	asrs	r1, r1, #8
    2fea:	strb	r1, [r2, #1]
    2fec:	mov	r2, r4
					}
					count_read -= 2;
    2fee:	subs	r3, #2
    2ff0:	b.n	2fca <SPIClass::transfer(void const*, void*, unsigned int)+0x19a>
    2ff2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2ff6:	nop
    2ff8:	.word	0x801f0400

00002ffc <SPIClass::dma_rxisr()>:


//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
    2ffc:	push	{r4, r5, r6, lr}
    2ffe:	ldr	r3, [r0, #56]	; 0x38
    3000:	ldrb	r2, [r3, #4]
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    3002:	ldr	r3, [pc, #192]	; (30c4 <SPIClass::dma_rxisr()+0xc8>)
    3004:	strb	r2, [r3, #0]
    3006:	ldr	r3, [r0, #52]	; 0x34
    3008:	ldrb	r2, [r3, #4]
	bool complete(void) {
		if (TCD->CSR & DMA_TCD_CSR_DONE) return true;
		return false;
	}
	void clearComplete(void) {
		DMA_CDNE = channel;
    300a:	ldr	r3, [pc, #188]	; (30c8 <SPIClass::dma_rxisr()+0xcc>)
    300c:	strb	r2, [r3, #0]
    300e:	ldr	r2, [r0, #56]	; 0x38
    3010:	ldrb	r2, [r2, #4]
    3012:	strb	r2, [r3, #0]
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
    3014:	ldr	r2, [r0, #48]	; 0x30


//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
    3016:	mov	r4, r0
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
    3018:	cmp	r2, #0
    301a:	beq.n	309c <SPIClass::dma_rxisr()+0xa0>
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
    301c:	ldr	r3, [r0, #4]
    301e:	ldr	r1, [r3, #12]
    3020:	cmp	r2, r1
    3022:	bls.n	302c <SPIClass::dma_rxisr()+0x30>
			_dma_count_remaining -= hardware().max_dma_count;
    3024:	subs	r2, r2, r1
    3026:	str	r2, [r0, #48]	; 0x30
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    3028:	movs	r1, #1
    302a:	b.n	304e <SPIClass::dma_rxisr()+0x52>
    302c:	ldr	r3, [r0, #52]	; 0x34
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
			_dma_count_remaining -= hardware().max_dma_count;
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
    302e:	subs	r1, r2, #1
    3030:	ldr	r0, [r3, #0]
    3032:	bl	2bc0 <DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]>
    3036:	ldr	r3, [r4, #56]	; 0x38
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
    3038:	ldr	r1, [r4, #48]	; 0x30
    303a:	ldr	r0, [r3, #0]
    303c:	bl	2bc0 <DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]>
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    3040:	ldr	r1, [r4, #48]	; 0x30
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    3042:	movs	r3, #0
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    3044:	adds.w	r1, r1, #4294967295
    3048:	it	ne
    304a:	movne	r1, #1
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    304c:	str	r3, [r4, #48]	; 0x30
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
    304e:	ldr	r3, [r4, #52]	; 0x34
    3050:	ldr	r3, [r3, #0]
    3052:	ldr	r0, [r3, #0]
    3054:	add.w	r2, r4, #44	; 0x2c
    3058:	cmp	r0, r2
    305a:	ldr	r2, [r4, #0]
    305c:	bne.n	306a <SPIClass::dma_rxisr()+0x6e>
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    305e:	ldr	r3, [r2, #12]
    3060:	ldrb.w	r3, [r4, #44]	; 0x2c
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    3064:	orr.w	r3, r3, #2147483648	; 0x80000000
    3068:	b.n	3088 <SPIClass::dma_rxisr()+0x8c>
			} else  {
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    306a:	ldr	r0, [r2, #12]
    306c:	tst.w	r0, #1073741824	; 0x40000000
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    3070:	ldr	r0, [r3, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    3072:	itete	ne
    3074:	ldrne	r5, [r3, #0]
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    3076:	ldreq	r5, [r3, #0]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    3078:	ldrhne	r0, [r0, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
    307a:	ldrbeq	r0, [r0, #0]
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    307c:	ite	ne
    307e:	addne	r5, #2
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    3080:	addeq	r5, #1
    3082:	str	r5, [r3, #0]
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    3084:	orr.w	r3, r0, #2147483648	; 0x80000000
    3088:	str	r3, [r2, #52]	; 0x34
    308a:	ldr	r3, [r4, #56]	; 0x38
    308c:	ldrb	r2, [r3, #4]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    308e:	ldr	r3, [pc, #60]	; (30cc <SPIClass::dma_rxisr()+0xd0>)
    3090:	strb	r2, [r3, #0]
			}
		}
		_dmaRX->enable();
		if (should_reenable_tx)
    3092:	cbz	r1, 30c0 <SPIClass::dma_rxisr()+0xc4>
    3094:	ldr	r2, [r4, #52]	; 0x34
    3096:	ldrb	r2, [r2, #4]
    3098:	strb	r2, [r3, #0]
    309a:	pop	{r4, r5, r6, pc}
    309c:	ldr	r3, [r0, #0]
			_dmaTX->enable();
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    309e:	ldr	r1, [pc, #48]	; (30d0 <SPIClass::dma_rxisr()+0xd4>)
		_dmaRX->enable();
		if (should_reenable_tx)
			_dmaTX->enable();
	} else {

		port().RSER = 0;
    30a0:	str	r2, [r3, #48]	; 0x30
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    30a2:	str	r1, [r3, #44]	; 0x2c
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    30a4:	ldr	r1, [r3, #12]
    30a6:	bic.w	r1, r1, #1073741824	; 0x40000000
    30aa:	str	r1, [r3, #12]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    30ac:	movs	r3, #3
    30ae:	strb.w	r3, [r0, #45]	; 0x2d
		_dma_event_responder->triggerEvent();
    30b2:	ldr	r0, [r0, #60]	; 0x3c
    30b4:	ldr	r3, [r0, #0]
    30b6:	mov	r1, r2
    30b8:	ldr	r3, [r3, #0]

	}
}
    30ba:	ldmia.w	sp!, {r4, r5, r6, lr}
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    30be:	bx	r3
    30c0:	pop	{r4, r5, r6, pc}
    30c2:	nop
    30c4:	.word	0x4000801f
    30c8:	.word	0x4000801c
    30cc:	.word	0x4000801b
    30d0:	.word	0xff0f0000

000030d4 <_spi_dma_rxISR0()>:
};
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    30d4:	push	{r3, lr}
    30d6:	ldr	r0, [pc, #8]	; (30e0 <_spi_dma_rxISR0()+0xc>)
    30d8:	bl	2ffc <SPIClass::dma_rxisr()>
    30dc:	pop	{r3, pc}
    30de:	nop
    30e0:	.word	0x1fff12f8

000030e4 <SDClass::~SDClass()>:
	char *filename;
};



class SDClass : public FS
    30e4:	bx	lr

000030e6 <SDClass::exists(char const*)>:
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
		if (file) return File(new SDFile(file));
		return File();
	}
	bool exists(const char *filepath) {
    30e6:	push	{lr}
    30e8:	mov	r2, r1
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
    30ea:	ldr.w	r1, [r0, #1156]	; 0x484
    30ee:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->exists(path) : false;
    30f0:	cbz	r1, 3108 <SDClass::exists(char const*)+0x22>
    30f2:	movs	r3, #0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    30f4:	mov	r0, sp
    30f6:	strb.w	r3, [sp]
    30fa:	strb.w	r3, [sp, #1]
    30fe:	strb.w	r3, [sp, #2]
    3102:	bl	636c <FatFile::open(FatVolume*, char const*, int)>
    3106:	b.n	3124 <SDClass::exists(char const*)+0x3e>
    3108:	ldr.w	r0, [r0, #1160]	; 0x488
    310c:	cbz	r0, 3124 <SDClass::exists(char const*)+0x3e>
    310e:	strb.w	r1, [sp, #49]	; 0x31
    3112:	strb.w	r1, [sp, #50]	; 0x32
    3116:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    311a:	mov	r3, r1
    311c:	mov	r1, r0
    311e:	mov	r0, sp
    3120:	bl	4826 <ExFatFile::open(ExFatVolume*, char const*, int)>
		return sdfs.exists(filepath);
	}
    3124:	add	sp, #60	; 0x3c
    3126:	ldr.w	pc, [sp], #4

0000312a <SDClass::rmdir(char const*)>:
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
    312a:	push	{lr}
    312c:	mov	r2, r1
   * The subdirectory file will be removed only if it is empty.
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char *path) {
    return m_fVol ? m_fVol->rmdir(path) :
    312e:	ldr.w	r1, [r0, #1156]	; 0x484
    3132:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->rmdir(path) : false;
    3134:	cbz	r1, 3154 <SDClass::rmdir(char const*)+0x2a>
    3136:	movs	r3, #0
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char* path) {
    FatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
    3138:	mov	r0, sp
    313a:	strb.w	r3, [sp]
    313e:	strb.w	r3, [sp, #1]
    3142:	strb.w	r3, [sp, #2]
    3146:	bl	636c <FatFile::open(FatVolume*, char const*, int)>
    314a:	cbz	r0, 3178 <SDClass::rmdir(char const*)+0x4e>
    314c:	mov	r0, sp
    314e:	bl	61e4 <FatFile::rmdir()>
    3152:	b.n	3178 <SDClass::rmdir(char const*)+0x4e>
    3154:	ldr.w	r0, [r0, #1160]	; 0x488
    3158:	cbz	r0, 3178 <SDClass::rmdir(char const*)+0x4e>
    315a:	strb.w	r1, [sp, #49]	; 0x31
    315e:	strb.w	r1, [sp, #50]	; 0x32
    3162:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char* path) {
    ExFatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
    3166:	mov	r3, r1
    3168:	mov	r1, r0
    316a:	mov	r0, sp
    316c:	bl	4826 <ExFatFile::open(ExFatVolume*, char const*, int)>
    3170:	cbz	r0, 3178 <SDClass::rmdir(char const*)+0x4e>
    3172:	mov	r0, sp
    3174:	bl	4e30 <ExFatFile::rmdir()>
		return sdfs.rmdir(filepath);
	}
    3178:	add	sp, #60	; 0x3c
    317a:	ldr.w	pc, [sp], #4

0000317e <SDClass::remove(char const*)>:
		return sdfs.mkdir(filepath);
	}
	bool rename(const char *oldfilepath, const char *newfilepath) {
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
    317e:	push	{lr}
    3180:	mov	r2, r1
  * \param[in] path A path with a valid 8.3 DOS name for the file.
  *
   * \return true for success or false for failure.
  */
  bool remove(const char *path) {
    return m_fVol ? m_fVol->remove(path) :
    3182:	ldr.w	r1, [r0, #1156]	; 0x484
    3186:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->remove(path) : false;
    3188:	cbz	r1, 31aa <SDClass::remove(char const*)+0x2c>
    318a:	movs	r3, #0
    318c:	strb.w	r3, [sp]
    3190:	strb.w	r3, [sp, #1]
    3194:	strb.w	r3, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    3198:	mov	r0, sp
    319a:	movs	r3, #1
    319c:	bl	636c <FatFile::open(FatVolume*, char const*, int)>
    31a0:	cbz	r0, 31ce <SDClass::remove(char const*)+0x50>
    31a2:	mov	r0, sp
    31a4:	bl	73e0 <FatFile::remove()>
    31a8:	b.n	31ce <SDClass::remove(char const*)+0x50>
    31aa:	ldr.w	r0, [r0, #1160]	; 0x488
    31ae:	cbz	r0, 31ce <SDClass::remove(char const*)+0x50>
    31b0:	strb.w	r1, [sp, #49]	; 0x31
    31b4:	strb.w	r1, [sp, #50]	; 0x32
    31b8:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    31bc:	movs	r3, #1
    31be:	mov	r1, r0
    31c0:	mov	r0, sp
    31c2:	bl	4826 <ExFatFile::open(ExFatVolume*, char const*, int)>
    31c6:	cbz	r0, 31ce <SDClass::remove(char const*)+0x50>
    31c8:	mov	r0, sp
    31ca:	bl	4daa <ExFatFile::remove()>
		return sdfs.remove(filepath);
	}
    31ce:	add	sp, #60	; 0x3c
    31d0:	ldr.w	pc, [sp], #4

000031d4 <SDClass::mkdir(char const*)>:
		return File();
	}
	bool exists(const char *filepath) {
		return sdfs.exists(filepath);
	}
	bool mkdir(const char *filepath) {
    31d4:	push	{r4, lr}
   * \param[in] pFlag Create missing parent directories if true.
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
    31d6:	ldr.w	r4, [r0, #1156]	; 0x484
    31da:	sub	sp, #56	; 0x38
    31dc:	mov	r2, r1
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
    31de:	cbz	r4, 31fc <SDClass::mkdir(char const*)+0x28>
    31e0:	movs	r3, #0
    31e2:	strb.w	r3, [sp]
    31e6:	strb.w	r3, [sp, #1]
    31ea:	strb.w	r3, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    31ee:	add.w	r1, r4, #1096	; 0x448
    31f2:	movs	r3, #1
    31f4:	mov	r0, sp
    31f6:	bl	64e8 <FatFile::mkdir(FatFile*, char const*, bool)>
    31fa:	b.n	321e <SDClass::mkdir(char const*)+0x4a>
    31fc:	ldr.w	r1, [r0, #1160]	; 0x488
    3200:	cbz	r1, 321c <SDClass::mkdir(char const*)+0x48>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    3202:	movs	r3, #1
    3204:	add.w	r1, r1, #1096	; 0x448
    3208:	mov	r0, sp
    320a:	strb.w	r4, [sp, #49]	; 0x31
    320e:	strb.w	r4, [sp, #50]	; 0x32
    3212:	strb.w	r4, [sp, #51]	; 0x33
    3216:	bl	50c8 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
    321a:	b.n	321e <SDClass::mkdir(char const*)+0x4a>
    321c:	mov	r0, r1
		return sdfs.mkdir(filepath);
	}
    321e:	add	sp, #56	; 0x38
    3220:	pop	{r4, pc}

00003222 <SDClass::rename(char const*, char const*)>:
	bool rename(const char *oldfilepath, const char *newfilepath) {
    3222:	push	{r4, r5, lr}
   * a file object that was opened before the rename() call.
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    return m_fVol ? m_fVol->rename(oldPath, newPath) :
    3224:	ldr.w	r3, [r0, #1156]	; 0x484
    3228:	sub	sp, #60	; 0x3c
    322a:	mov	r5, r2
           m_xVol ? m_xVol->rename(oldPath, newPath) : false;
    322c:	cbz	r3, 325a <SDClass::rename(char const*, char const*)+0x38>
    322e:	movs	r2, #0
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend FatFile;
  static FatVolume* cwv() {return m_cwv;}
  FatFile* vwd() {return &m_vwd;}
    3230:	add.w	r4, r3, #1096	; 0x448
    3234:	strb.w	r2, [sp]
    3238:	strb.w	r2, [sp, #1]
    323c:	strb.w	r2, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    FatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    3240:	mov	r3, r2
    3242:	mov	r0, sp
    3244:	mov	r2, r1
    3246:	mov	r1, r4
    3248:	bl	62c4 <FatFile::open(FatFile*, char const*, int)>
    324c:	cbz	r0, 3286 <SDClass::rename(char const*, char const*)+0x64>
    324e:	mov	r2, r5
    3250:	mov	r1, r4
    3252:	mov	r0, sp
    3254:	bl	6592 <FatFile::rename(FatFile*, char const*)>
    3258:	b.n	3286 <SDClass::rename(char const*, char const*)+0x64>
    325a:	ldr.w	r0, [r0, #1160]	; 0x488
    325e:	cbz	r0, 3286 <SDClass::rename(char const*, char const*)+0x64>
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend ExFatFile;
  static ExFatVolume* cwv() {return m_cwv;}
  ExFatFile* vwd() {return &m_vwd;}
    3260:	add.w	r4, r0, #1096	; 0x448
   *
   * \return true for success or false for failure.
   */
  bool rename(const char* oldPath, const char* newPath) {
    ExFatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    3264:	mov	r2, r1
    3266:	mov	r0, sp
    3268:	mov	r1, r4
    326a:	strb.w	r3, [sp, #49]	; 0x31
    326e:	strb.w	r3, [sp, #50]	; 0x32
    3272:	strb.w	r3, [sp, #51]	; 0x33
    3276:	bl	476c <ExFatFile::open(ExFatFile*, char const*, int)>
    327a:	cbz	r0, 3286 <SDClass::rename(char const*, char const*)+0x64>
    327c:	mov	r2, r5
    327e:	mov	r1, r4
    3280:	mov	r0, sp
    3282:	bl	5186 <ExFatFile::rename(ExFatFile*, char const*)>
		return sdfs.rename(oldfilepath, newfilepath);
	}
    3286:	add	sp, #60	; 0x3c
    3288:	pop	{r4, r5, pc}

0000328a <SDClass::totalSize()>:
	}
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
		  * (uint64_t)sdfs.bytesPerCluster();
	}
	uint64_t totalSize() {
    328a:	mov	r3, r0
    328c:	push	{r4, lr}
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    328e:	ldr.w	r2, [r3, #1156]	; 0x484
		return (uint64_t)sdfs.clusterCount() * (uint64_t)sdfs.bytesPerCluster();
    3292:	adds	r0, #4
           m_xVol ? m_xVol->clusterCount() : 0;
    3294:	cbz	r2, 329c <SDClass::totalSize()+0x12>
    3296:	ldr	r4, [r2, #28]
    3298:	subs	r4, #1
    329a:	b.n	32a6 <SDClass::totalSize()+0x1c>
    329c:	ldr.w	r4, [r3, #1160]	; 0x488
    32a0:	cbz	r4, 32a6 <SDClass::totalSize()+0x1c>
    32a2:	ldr.w	r4, [r4, #1072]	; 0x430
    32a6:	bl	1a00 <FsVolume::bytesPerCluster() const>
	}
    32aa:	umull	r0, r1, r4, r0
    32ae:	pop	{r4, pc}

000032b0 <SDClass::usedSize()>:
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
		return sdfs.rmdir(filepath);
	}
	uint64_t usedSize() {
    32b0:	push	{r3, r4, r5, lr}
    32b2:	mov	r3, r0
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
    32b4:	adds	r5, r0, #4
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    32b6:	ldr.w	r0, [r0, #1156]	; 0x484
           m_xVol ? m_xVol->clusterCount() : 0;
    32ba:	cbz	r0, 32c6 <SDClass::usedSize()+0x16>
    32bc:	ldr	r4, [r0, #28]
    32be:	subs	r4, #1
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
    32c0:	bl	6c04 <FatPartition::freeClusterCount()>
    32c4:	b.n	32d8 <SDClass::usedSize()+0x28>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    32c6:	ldr.w	r0, [r3, #1160]	; 0x488
    32ca:	cbz	r0, 32d6 <SDClass::usedSize()+0x26>
    32cc:	ldr.w	r4, [r0, #1072]	; 0x430
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
           m_xVol ? m_xVol->freeClusterCount() : 0;
    32d0:	bl	4b28 <ExFatPartition::freeClusterCount()>
    32d4:	b.n	32d8 <SDClass::usedSize()+0x28>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    32d6:	mov	r4, r0
    32d8:	subs	r4, r4, r0
		  * (uint64_t)sdfs.bytesPerCluster();
    32da:	mov	r0, r5
    32dc:	bl	1a00 <FsVolume::bytesPerCluster() const>
	}
    32e0:	umull	r0, r1, r4, r0
    32e4:	pop	{r3, r4, r5, pc}

000032e6 <SdBase<FsVolume>::begin(SdioConfig)>:
  /** Initialize SD card and file system for SDIO mode.
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    32e6:	push	{r3, r4, r5, lr}
   * \param[in] config SDIO configuration.
   * \return generic card pointer or nullptr if SDIO is not supported.
   */
  SdCard* newCard(SdioConfig config) {
#if HAS_SDIO_CLASS
    m_sdioCard.begin(config);
    32e8:	add.w	r5, r0, #1168	; 0x490
    32ec:	mov	r4, r0
    spiConfigBackupPin = 255;
    32ee:	movs	r3, #255	; 0xff
    32f0:	strb.w	r3, [r0, #1200]	; 0x4b0
    sdioConfigBackup = sdioConfig;
    32f4:	strb.w	r1, [r0, #1212]	; 0x4bc
    32f8:	mov	r0, r5
    32fa:	bl	88d0 <SdioCard::begin(SdioConfig)>
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdioConfig sdioConfig) {
    m_card = m_cardFactory.newCard(sdioConfig);
    32fe:	str.w	r5, [r4, #1164]	; 0x48c
    return m_card && !m_card->errorCode();
    3302:	mov	r0, r5
    3304:	bl	80bc <SdioCard::errorCode() const>
    3308:	cbnz	r0, 3318 <SdBase<FsVolume>::begin(SdioConfig)+0x32>
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
    330a:	ldr.w	r1, [r4, #1164]	; 0x48c
    330e:	mov	r0, r4
  }
    3310:	ldmia.w	sp!, {r3, r4, r5, lr}
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
    3314:	b.w	75f8 <FsVolume::begin(BlockDeviceInterface*)>
  }
    3318:	movs	r0, #0
    331a:	pop	{r3, r4, r5, pc}

0000331c <SdBase<FsVolume>::cardBegin(SdSpiConfig)>:
  /** Initialize SD card in SPI mode.
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    331c:	push	{r4, r5, r6, lr}
    331e:	sub	sp, #32
    3320:	mov	r6, r0
    3322:	add	r0, sp, #4
    3324:	stmia.w	r0, {r1, r2, r3}
    3328:	ldmia	r0, {r0, r1, r2}
    332a:	add	r5, sp, #20
    332c:	stmia.w	r5, {r0, r1, r3}
   *
   * \param[in] config SPI configuration.
   * \return generic card pointer.
   */
  SdCard* newCard(SdSpiConfig config) {
    m_spiCard.begin(config);
    3330:	addw	r4, r6, #1180	; 0x49c
    3334:	ldmia.w	r5, {r1, r2, r3}
    3338:	mov	r0, r4
    333a:	bl	7a2c <SdSpiCard::begin(SdSpiConfig)>
    m_card = m_cardFactory.newCard(spiConfig);
    333e:	str.w	r4, [r6, #1164]	; 0x48c
    return m_card && !m_card->errorCode();
    3342:	cbz	r4, 3350 <SdBase<FsVolume>::cardBegin(SdSpiConfig)+0x34>
    3344:	ldrb.w	r0, [r6, #1195]	; 0x4ab
    3348:	clz	r0, r0
    334c:	lsrs	r0, r0, #5
    334e:	b.n	3352 <SdBase<FsVolume>::cardBegin(SdSpiConfig)+0x36>
    3350:	mov	r0, r4
  }
    3352:	add	sp, #32
    3354:	pop	{r4, r5, r6, pc}

00003356 <SdBase<FsVolume>::restart()>:
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
  }
  //----------------------------------------------------------------------------
  /** Restart library with same config, used after media removed and replaced */
  bool restart() {
    3356:	push	{r4, r5, lr}
    if (spiConfigBackupPin == 255) {
    3358:	ldrb.w	r3, [r0, #1200]	; 0x4b0
    335c:	cmp	r3, #255	; 0xff
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
  }
  //----------------------------------------------------------------------------
  /** Restart library with same config, used after media removed and replaced */
  bool restart() {
    335e:	sub	sp, #20
    3360:	mov	r4, r0
    if (spiConfigBackupPin == 255) {
    3362:	bne.n	336e <SdBase<FsVolume>::restart()+0x18>
      return begin(sdioConfigBackup);
    3364:	ldrb.w	r1, [r0, #1212]	; 0x4bc
    3368:	bl	32e6 <SdBase<FsVolume>::begin(SdioConfig)>
    336c:	b.n	33a2 <SdBase<FsVolume>::restart()+0x4c>
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
    336e:	ldr.w	r1, [r0, #1204]	; 0x4b4
    3372:	ldr.w	r2, [r0, #1208]	; 0x4b8
    3376:	ldrb.w	r5, [r0, #1201]	; 0x4b1
    337a:	strb.w	r3, [sp, #4]
    337e:	strb.w	r5, [sp, #5]
    3382:	str	r1, [sp, #8]
    3384:	str	r2, [sp, #12]
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    3386:	add	r3, sp, #16
    3388:	ldmdb	r3, {r1, r2, r3}
    338c:	bl	331c <SdBase<FsVolume>::cardBegin(SdSpiConfig)>
    3390:	cbz	r0, 33a2 <SdBase<FsVolume>::restart()+0x4c>
    3392:	ldr.w	r1, [r4, #1164]	; 0x48c
    3396:	mov	r0, r4
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
      return begin(spiConfig);
    }
  }
    3398:	add	sp, #20
    339a:	ldmia.w	sp!, {r4, r5, lr}
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    339e:	b.w	75f8 <FsVolume::begin(BlockDeviceInterface*)>
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
      return begin(spiConfig);
    }
  }
    33a2:	add	sp, #20
    33a4:	pop	{r4, r5, pc}

000033a6 <SDClass::format(int, char, Print&)>:
	}
}
#endif

bool SDClass::format(int type, char progressChar, Print& pr)
{
    33a6:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    33aa:	ldr.w	r4, [r0, #1168]	; 0x490
    33ae:	sub	sp, #48	; 0x30
    33b0:	mov	r6, r0
    33b2:	mov	r7, r3
	SdCard *card = sdfs.card();
	if (!card) return false; // no SD card
    33b4:	cbnz	r4, 33ba <SDClass::format(int, char, Print&)+0x14>
    33b6:	movs	r0, #0
    33b8:	b.n	3404 <SDClass::format(int, char, Print&)+0x5e>
	uint32_t sectors = card->sectorCount();
    33ba:	ldr	r3, [r4, #0]
    33bc:	mov	r0, r4
    33be:	ldr	r3, [r3, #24]
    33c0:	blx	r3
	if (sectors <= 12288) return false; // card too small
    33c2:	cmp.w	r0, #12288	; 0x3000

bool SDClass::format(int type, char progressChar, Print& pr)
{
	SdCard *card = sdfs.card();
	if (!card) return false; // no SD card
	uint32_t sectors = card->sectorCount();
    33c6:	mov	r8, r0
	if (sectors <= 12288) return false; // card too small
    33c8:	bls.n	33b6 <SDClass::format(int, char, Print&)+0x10>
	uint8_t *buf = (uint8_t *)malloc(512);
    33ca:	mov.w	r0, #512	; 0x200
    33ce:	bl	b318 <malloc>
	if (!buf) return false; // unable to allocate memory
    33d2:	mov	r5, r0
    33d4:	cmp	r0, #0
    33d6:	beq.n	33b6 <SDClass::format(int, char, Print&)+0x10>
	bool ret;
	if (sectors > 67108864) {
    33d8:	cmp.w	r8, #67108864	; 0x4000000
#ifdef __arm__
		ExFatFormatter exFatFormatter;
		ret = exFatFormatter.format(card, buf, &pr);
    33dc:	mov	r2, r0
    33de:	mov	r3, r7
    33e0:	mov	r1, r4
    33e2:	add	r0, sp, #4
	uint32_t sectors = card->sectorCount();
	if (sectors <= 12288) return false; // card too small
	uint8_t *buf = (uint8_t *)malloc(512);
	if (!buf) return false; // unable to allocate memory
	bool ret;
	if (sectors > 67108864) {
    33e4:	bls.n	33ec <SDClass::format(int, char, Print&)+0x46>
#ifdef __arm__
		ExFatFormatter exFatFormatter;
		ret = exFatFormatter.format(card, buf, &pr);
    33e6:	bl	3ab8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>
    33ea:	b.n	33f0 <SDClass::format(int, char, Print&)+0x4a>
#else
		ret = false;
#endif
	} else {
		FatFormatter fatFormatter;
		ret = fatFormatter.format(card, buf, &pr);
    33ec:	bl	5a40 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>
    33f0:	mov	r4, r0
	}
	free(buf);
    33f2:	mov	r0, r5
    33f4:	bl	b328 <free>
	if (ret) {
    33f8:	cmp	r4, #0
    33fa:	beq.n	33b6 <SDClass::format(int, char, Print&)+0x10>
		// TODO: Is begin() really necessary?  Is a quicker way possible?
		sdfs.restart(); // TODO: is sdfs.volumeBegin() enough??
    33fc:	adds	r0, r6, #4
    33fe:	bl	3356 <SdBase<FsVolume>::restart()>
    3402:	movs	r0, #1
	}
	return ret;
}
    3404:	add	sp, #48	; 0x30
    3406:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000340a <SDClass::mediaPresent()>:
	}
	return false;
}

bool SDClass::mediaPresent()
{
    340a:	push	{r4, r5, lr}
    340c:	ldr.w	r4, [r0, #1168]	; 0x490
    3410:	sub	sp, #20
    3412:	mov	r5, r0
	//Serial.print("mediaPresent: ");
	bool ret;
	SdCard *card = sdfs.card();
	if (card) {
    3414:	cbz	r4, 3454 <SDClass::mediaPresent()+0x4a>
		if (cardPreviouslyPresent) {
    3416:	ldrb.w	r3, [r0, #1220]	; 0x4c4
    341a:	cbz	r3, 344c <SDClass::mediaPresent()+0x42>
			#ifdef BUILTIN_SDCARD
			uint32_t s;
			if (csPin_ == BUILTIN_SDCARD) {
    341c:	ldrb.w	r3, [r0, #1221]	; 0x4c5
    3420:	cmp	r3, #254	; 0xfe
    3422:	beq.n	3430 <SDClass::mediaPresent()+0x26>
			const uint32_t s = 0xFFFFFFFF;
			#endif
			if (s == 0xFFFFFFFF) {
				// SPI doesn't have 32 bit status, read CID register
				cid_t cid;
				ret = card->readCID(&cid);
    3424:	ldr	r3, [r4, #0]
    3426:	mov	r1, sp
    3428:	ldr	r3, [r3, #56]	; 0x38
    342a:	mov	r0, r4
    342c:	blx	r3
    342e:	b.n	3456 <SDClass::mediaPresent()+0x4c>
		if (cardPreviouslyPresent) {
			#ifdef BUILTIN_SDCARD
			uint32_t s;
			if (csPin_ == BUILTIN_SDCARD) {
				#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
				card->syncDevice();
    3430:	ldr	r3, [r4, #0]
    3432:	mov	r0, r4
    3434:	ldr	r3, [r3, #28]
    3436:	blx	r3
				#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
				s = card->status();
    3438:	ldr	r3, [r4, #0]
    343a:	mov	r0, r4
    343c:	ldr	r3, [r3, #68]	; 0x44
    343e:	blx	r3
			} else s = 0xFFFFFFFF;
			#else
			const uint32_t s = 0xFFFFFFFF;
			#endif
			if (s == 0xFFFFFFFF) {
    3440:	adds	r3, r0, #1
    3442:	beq.n	3424 <SDClass::mediaPresent()+0x1a>
				// SPI doesn't have 32 bit status, read CID register
				cid_t cid;
				ret = card->readCID(&cid);
				//Serial.print(ret ? "CID=ok" : "CID=unreadable");
			} else if (s == 0) {
    3444:	adds	r0, #0
    3446:	it	ne
    3448:	movne	r0, #1
    344a:	b.n	3456 <SDClass::mediaPresent()+0x4c>
			if ((csPin_ == BUILTIN_SDCARD) && !digitalReadFast(_SD_DAT3))
				ret = false;
			else
			#endif
			{
				ret = sdfs.restart();
    344c:	adds	r0, #4
    344e:	bl	3356 <SdBase<FsVolume>::restart()>
    3452:	b.n	3456 <SDClass::mediaPresent()+0x4c>
			}
			//Serial.print(ret ? "begin ok" : "begin nope");
		}
	} else {
		//Serial.print("no card");
		ret = false;
    3454:	mov	r0, r4
	}
	//Serial.println();
	cardPreviouslyPresent = ret;
    3456:	strb.w	r0, [r5, #1220]	; 0x4c4
	return ret;
}
    345a:	add	sp, #20
    345c:	pop	{r4, r5, pc}
    345e:	Address 0x0000345e is out of bounds.


00003460 <_GLOBAL__sub_I_SD>:


class SDClass : public FS
{
public:
	SDClass() { }
    3460:	ldr	r0, [pc, #72]	; (34ac <_GLOBAL__sub_I_SD+0x4c>)
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    3462:	ldr	r2, [pc, #76]	; (34b0 <_GLOBAL__sub_I_SD+0x50>)
    3464:	str.w	r2, [r0, #1172]	; 0x494
    3468:	ldr	r2, [pc, #72]	; (34b4 <_GLOBAL__sub_I_SD+0x54>)
    346a:	ldr	r3, [pc, #76]	; (34b8 <_GLOBAL__sub_I_SD+0x58>)
    346c:	str.w	r2, [r0, #1184]	; 0x4a0
    3470:	movs	r2, #1
    3472:	str	r3, [r0, #0]
    3474:	strb.w	r2, [r0, #1197]	; 0x4ad
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() {}
    3478:	movs	r3, #0
    347a:	movs	r2, #41	; 0x29
    347c:	str.w	r3, [r0, #1156]	; 0x484
    3480:	str.w	r3, [r0, #1160]	; 0x488
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    3484:	strb.w	r3, [r0, #1180]	; 0x49c
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    3488:	strb.w	r3, [r0, #1181]	; 0x49d
    348c:	strb.w	r2, [r0, #1199]	; 0x4af
    3490:	strb.w	r3, [r0, #1202]	; 0x4b2
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    3494:	strb.w	r3, [r0, #1216]	; 0x4c0
    3498:	strb.w	r3, [r0, #1220]	; 0x4c4
 */

#include <Arduino.h>
#include <SD.h>

SDClass SD;
    349c:	ldr	r2, [pc, #28]	; (34bc <_GLOBAL__sub_I_SD+0x5c>)
    349e:	ldr	r1, [pc, #32]	; (34c0 <_GLOBAL__sub_I_SD+0x60>)
    34a0:	movs	r3, #255	; 0xff
    34a2:	strb.w	r3, [r0, #1221]	; 0x4c5
    34a6:	b.w	a524 <__aeabi_atexit>
    34aa:	nop
    34ac:	.word	0x2001a1c8
    34b0:	.word	0x00012e30
    34b4:	.word	0x00012dd0
    34b8:	.word	0x00012ad0
    34bc:	.word	0x1fff0f30
    34c0:	.word	0x000030e5

000034c4 <FsUtf::cpToMb(unsigned long, char*, char*)>:
#include "FsUtf.h"
namespace FsUtf {
  //----------------------------------------------------------------------------
  char* cpToMb(uint32_t cp, char* str, char* end) {
    size_t n = end - str;
    if (cp < 0X80) {
    34c4:	cmp	r0, #127	; 0x7f
 */
#include "FsUtf.h"
namespace FsUtf {
  //----------------------------------------------------------------------------
  char* cpToMb(uint32_t cp, char* str, char* end) {
    size_t n = end - str;
    34c6:	sub.w	r2, r2, r1
    if (cp < 0X80) {
    34ca:	bhi.n	34d6 <FsUtf::cpToMb(unsigned long, char*, char*)+0x12>
      if (n < 1) goto fail;
    34cc:	cmp	r2, #0
    34ce:	beq.n	3550 <FsUtf::cpToMb(unsigned long, char*, char*)+0x8c>
      *(str++) = static_cast<uint8_t>(cp);
    34d0:	strb	r0, [r1, #0]
    34d2:	adds	r0, r1, #1
    34d4:	bx	lr
    } else if (cp < 0X800) {
    34d6:	cmp.w	r0, #2048	; 0x800
    34da:	bcs.n	34f8 <FsUtf::cpToMb(unsigned long, char*, char*)+0x34>
      if (n < 2) goto fail;
    34dc:	cmp	r2, #1
    34de:	bls.n	3554 <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    34e0:	lsrs	r3, r0, #6
    34e2:	mov	r2, r1
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    34e4:	and.w	r0, r0, #63	; 0x3f
    if (cp < 0X80) {
      if (n < 1) goto fail;
      *(str++) = static_cast<uint8_t>(cp);
    } else if (cp < 0X800) {
      if (n < 2) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    34e8:	orn	r3, r3, #63	; 0x3f
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    34ec:	orn	r0, r0, #127	; 0x7f
    if (cp < 0X80) {
      if (n < 1) goto fail;
      *(str++) = static_cast<uint8_t>(cp);
    } else if (cp < 0X800) {
      if (n < 2) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    34f0:	strb.w	r3, [r2], #2
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    34f4:	strb	r0, [r1, #1]
    34f6:	b.n	3550 <FsUtf::cpToMb(unsigned long, char*, char*)+0x8c>
    } else if (cp < 0X10000) {
    34f8:	cmp.w	r0, #65536	; 0x10000
    34fc:	bcs.n	3522 <FsUtf::cpToMb(unsigned long, char*, char*)+0x5e>
      if (n < 3) goto fail;
    34fe:	cmp	r2, #2
    3500:	bls.n	3554 <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 12)         | 0XE0);
    3502:	lsrs	r3, r0, #12
    3504:	orn	r3, r3, #31
    3508:	strb	r3, [r1, #0]
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    350a:	ubfx	r3, r0, #6, #6
    350e:	orn	r3, r3, #127	; 0x7f
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    3512:	and.w	r0, r0, #63	; 0x3f
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    } else if (cp < 0X10000) {
      if (n < 3) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 12)         | 0XE0);
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    3516:	strb	r3, [r1, #1]
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    3518:	orn	r3, r0, #127	; 0x7f
    351c:	strb	r3, [r1, #2]
    351e:	adds	r0, r1, #3
    3520:	bx	lr
    } else {
       if (n < 4) goto fail;
    3522:	cmp	r2, #3
    3524:	bls.n	3554 <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 18)         | 0XF0);
    3526:	lsrs	r3, r0, #18
    3528:	orn	r3, r3, #15
    352c:	strb	r3, [r1, #0]
      *(str++) = static_cast<uint8_t>(((cp >> 12) & 0X3F)| 0X80);
    352e:	ubfx	r3, r0, #12, #6
    3532:	orn	r3, r3, #127	; 0x7f
    3536:	strb	r3, [r1, #1]
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    3538:	ubfx	r3, r0, #6, #6
    353c:	orn	r3, r3, #127	; 0x7f
    3540:	strb	r3, [r1, #2]
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    3542:	and.w	r3, r0, #63	; 0x3f
    3546:	orn	r3, r3, #127	; 0x7f
    354a:	strb	r3, [r1, #3]
    354c:	adds	r0, r1, #4
    354e:	bx	lr
    }
    return str;

   fail:
    return nullptr;
    3550:	mov	r0, r2
    3552:	bx	lr
    3554:	movs	r0, #0
  }
    3556:	bx	lr

00003558 <FsUtf::mbToCp(char const*, char const*, unsigned long*)>:
  //----------------------------------------------------------------------------
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    size_t n;
    uint32_t cp;
    if (str >= end) {
    3558:	cmp	r0, r1
   fail:
    return nullptr;
  }
  //----------------------------------------------------------------------------
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    355a:	push	{r4, r5, lr}
    size_t n;
    uint32_t cp;
    if (str >= end) {
    355c:	bcs.n	35cc <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
      return nullptr;
    }
    uint8_t ch = str[0];
    355e:	ldrb	r3, [r0, #0]
    if ((ch & 0X80) == 0) {
    3560:	lsls	r4, r3, #24
    3562:	bmi.n	356a <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x12>
      *rtn = ch;
    3564:	str	r3, [r2, #0]
      return str + 1;
    3566:	adds	r4, r0, #1
    3568:	b.n	35d2 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x7a>
    }
    if ((ch & 0XE0) == 0XC0) {
    356a:	and.w	r4, r3, #224	; 0xe0
    356e:	cmp	r4, #192	; 0xc0
    3570:	bne.n	357a <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x22>
      cp = ch & 0X1F;
    3572:	and.w	r3, r3, #31
      n = 2;
    3576:	movs	r4, #2
    3578:	b.n	3598 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x40>
    } else if ((ch & 0XF0) == 0XE0) {
    357a:	and.w	r4, r3, #240	; 0xf0
    357e:	cmp	r4, #224	; 0xe0
    3580:	bne.n	358a <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x32>
      cp = ch & 0X0F;
    3582:	and.w	r3, r3, #15
      n = 3;
    3586:	movs	r4, #3
    3588:	b.n	3598 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x40>
    } else if ((ch & 0XF8) == 0XF0) {
    358a:	and.w	r4, r3, #248	; 0xf8
    358e:	cmp	r4, #240	; 0xf0
    3590:	bne.n	35cc <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
      cp = ch & 0X07;
    3592:	and.w	r3, r3, #7
      n = 4;
    3596:	movs	r4, #4
    } else {
      return nullptr;
    }
    if ((str + n) > end) {
    3598:	add	r4, r0
    359a:	cmp	r1, r4
    359c:	bcc.n	35cc <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
    359e:	adds	r0, #1
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
      ch = str[i];
    35a0:	ldrb.w	r1, [r0], #1
      if ((ch & 0XC0) != 0X80) {
    35a4:	and.w	r5, r1, #192	; 0xc0
    35a8:	cmp	r5, #128	; 0x80
    35aa:	bne.n	35cc <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
        return nullptr;
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    35ac:	and.w	r1, r1, #63	; 0x3f
      return nullptr;
    }
    if ((str + n) > end) {
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
    35b0:	cmp	r0, r4
      ch = str[i];
      if ((ch & 0XC0) != 0X80) {
        return nullptr;
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    35b2:	orr.w	r3, r1, r3, lsl #6
      return nullptr;
    }
    if ((str + n) > end) {
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
    35b6:	bne.n	35a0 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x48>
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    }
    // Don't allow over long as ASCII.
    if (cp < 0X80 || !isValidCp(cp)) {
    35b8:	ldr	r1, [pc, #28]	; (35d8 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x80>)
    35ba:	sub.w	r0, r3, #128	; 0x80
    35be:	cmp	r0, r1
    35c0:	bhi.n	35cc <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
  /** Check for a valid code point.
   * \param[in] cp code point.
   * \return true if valid else false.
   */
  inline bool isValidCp(uint32_t cp) {
    return cp <= 0x10FFFF && (cp < 0XD800 || cp > 0XDFFF);
    35c2:	sub.w	r1, r3, #55296	; 0xd800
    35c6:	cmp.w	r1, #2048	; 0x800
    35ca:	bcs.n	35d0 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x78>
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    size_t n;
    uint32_t cp;
    if (str >= end) {
      return nullptr;
    35cc:	movs	r4, #0
    35ce:	b.n	35d2 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x7a>
    }
    // Don't allow over long as ASCII.
    if (cp < 0X80 || !isValidCp(cp)) {
      return nullptr;
    }
    *rtn = cp;
    35d0:	str	r3, [r2, #0]
    return str + n;
  }
    35d2:	mov	r0, r4
    35d4:	pop	{r4, r5, pc}
    35d6:	nop
    35d8:	.word	0x0010ff7f

000035dc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>:
#include "FsGetPartitionInfo.h"
namespace FsGetPartitionInfo {
  static const uint8_t mbdpGuid[16] PROGMEM = {0xA2, 0xA0, 0xD0, 0xEB, 0xE5, 0xB9, 0x33, 0x44, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7};

  voltype_t getPartitionInfo(BlockDeviceInterface *blockDev, uint8_t part, uint8_t *secBuf,
      uint32_t *pfirstLBA, uint32_t *psectorCount, uint32_t *pmbrLBA, uint8_t *pmbrPart) {
    35dc:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    35e0:	add	r6, sp, #48	; 0x30
    35e2:	mov	r5, r0
    35e4:	mov	r4, r2
    35e6:	mov	sl, r3
    35e8:	ldmia.w	r6, {r6, r7, r8}
    uint32_t firstLBA;
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    35ec:	str	r1, [sp, #4]
    35ee:	cbnz	r1, 35f4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x18>
    35f0:	movs	r0, #0
    35f2:	b.n	377c <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    35f4:	cmp.w	sl, #0
    35f8:	beq.n	35f0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    part--; // zero base it.

    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    35fa:	ldr	r3, [r0, #0]
    35fc:	movs	r1, #0
    35fe:	ldr	r3, [r3, #12]
    3600:	blx	r3
    3602:	cmp	r0, #0
    3604:	beq.n	35f0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    part--; // zero base it.
    3606:	ldr	r3, [sp, #4]
    3608:	add.w	r9, r3, #4294967295
    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    mbr = reinterpret_cast<MbrSector_t*>(secBuf);

    // First check for GPT vs MBR
    mp = &mbr->part[0];
    if (mp->type == 0xee) {
    360c:	ldrb.w	r3, [r4, #450]	; 0x1c2
    3610:	cmp	r3, #238	; 0xee
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    part--; // zero base it.
    3612:	uxtb.w	r9, r9
    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    mbr = reinterpret_cast<MbrSector_t*>(secBuf);

    // First check for GPT vs MBR
    mp = &mbr->part[0];
    if (mp->type == 0xee) {
    3616:	bne.n	3698 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xbc>
      // This is a GPT initialized Disk assume validation done earlier.
      if (!blockDev->readSector(1, secBuf)) return INVALID_VOL; 
    3618:	ldr	r3, [r5, #0]
    361a:	mov	r2, r4
    361c:	ldr	r3, [r3, #12]
    361e:	movs	r1, #1
    3620:	mov	r0, r5
    3622:	blx	r3
    3624:	cmp	r0, #0
    3626:	beq.n	35f0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      GPTPartitionHeader_t* gptph = reinterpret_cast<GPTPartitionHeader_t*>(secBuf);
      // Lets do a little validation of this data.
      if (!gptph || (memcmp(gptph->signature, F("EFI PART"), 8) != 0))  return INVALID_VOL;
    3628:	movs	r2, #8
    362a:	ldr	r1, [pc, #344]	; (3784 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a8>)
    362c:	mov	r0, r4
    362e:	bl	b980 <memcmp>
    3632:	cmp	r0, #0
    3634:	bne.n	35f0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      uint32_t numberPartitions = getLe32(gptph->numberPartitions);
      if (part > numberPartitions)  return INVALID_VOL;
    3636:	ldr	r3, [r4, #80]	; 0x50
    3638:	cmp	r9, r3
    363a:	bhi.n	35f0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>

      // We will overload the mbr part to give clue where GPT data is stored for this volume
      uint32_t mbrLBA = 2 + (part >> 2);
    363c:	mov.w	r1, r9, asr #2
    3640:	adds	r1, #2
      uint8_t mbrPart = part & 0x3;
    3642:	and.w	r9, r9, #3
      if (pmbrLBA) *pmbrLBA = mbrLBA;
    3646:	cbz	r7, 364a <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x6e>
    3648:	str	r1, [r7, #0]
      if (pmbrPart) *pmbrPart =mbrPart;
    364a:	cmp.w	r8, #0
    364e:	beq.n	3654 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x78>
    3650:	strb.w	r9, [r8]
      if (!blockDev->readSector(mbrLBA, secBuf)) return INVALID_VOL; 
    3654:	ldr	r3, [r5, #0]
    3656:	mov	r2, r4
    3658:	ldr	r3, [r3, #12]
    365a:	mov	r0, r5
    365c:	blx	r3
    365e:	cmp	r0, #0
    3660:	beq.n	35f0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      GPTPartitionEntrySector_t *gptes = reinterpret_cast<GPTPartitionEntrySector_t*>(secBuf);
      GPTPartitionEntryItem_t *gptei = &gptes->items[mbrPart];

      // Mow extract the data...
      firstLBA = getLe64(gptei->firstLBA);
    3662:	mov.w	r0, r9, lsl #7
    3666:	add.w	r3, r0, #32
    366a:	ldr	r2, [r4, r3]
      sectorCount = 1 + getLe64(gptei->lastLBA) - getLe64(gptei->firstLBA);
    366c:	add.w	r3, r0, #40	; 0x28
    3670:	ldr	r3, [r4, r3]
    3672:	adds	r3, #1
    3674:	subs	r3, r3, r2
      if ((firstLBA == 0) && (sectorCount == 1)) return INVALID_VOL;
    3676:	cbnz	r2, 367c <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xa0>
    3678:	cmp	r3, #1
    367a:	beq.n	35f0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      
      *pfirstLBA = firstLBA;
    367c:	str.w	r2, [sl]
      if (psectorCount) *psectorCount = sectorCount;
    3680:	cbz	r6, 3684 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xa8>
    3682:	str	r3, [r6, #0]

      if (memcmp((uint8_t *)gptei->partitionTypeGUID, mbdpGuid, 16) != 0) return OTHER_VOL;
    3684:	movs	r2, #16
    3686:	ldr	r1, [pc, #256]	; (3788 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1ac>)
    3688:	add	r0, r4
    368a:	bl	b980 <memcmp>
    368e:	cmp	r0, #0
    3690:	ite	eq
    3692:	moveq	r0, #3
    3694:	movne	r0, #4
    3696:	b.n	377c <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    }
    // So we are now looking a MBR type setups. 
    // Extended support we need to walk through the partitions to see if there is an extended partition
    // that we need to walk into. 
    // short cut:
    if (part < 4) {
    3698:	cmp.w	r9, #3
    369c:	bhi.n	36de <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
      // try quick way through
      mp = &mbr->part[part];
      if (((mp->boot == 0) || (mp->boot == 0X80)) && (mp->type != 0) && (mp->type != 0xf)) {
    369e:	add.w	r3, r4, r9, lsl #4
    36a2:	ldrb.w	r2, [r3, #446]	; 0x1be
    36a6:	lsls	r2, r2, #25
    36a8:	bne.n	36de <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
    36aa:	ldrb.w	r3, [r3, #450]	; 0x1c2
    36ae:	cbz	r3, 36de <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
    36b0:	cmp	r3, #15
    36b2:	beq.n	36de <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
        *pfirstLBA = getLe32(mp->relativeSectors);
    36b4:	add.w	r3, r9, #28
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    36b8:	add.w	r4, r4, r3, lsl #4
    36bc:	ldr.w	r3, [r4, #6]
    36c0:	str.w	r3, [sl]
        if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
    36c4:	cbz	r6, 36cc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xf0>
    36c6:	ldr.w	r3, [r4, #10]
    36ca:	str	r3, [r6, #0]
        if (pmbrLBA) *pmbrLBA = 0;
    36cc:	cbz	r7, 36d2 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xf6>
    36ce:	movs	r3, #0
    36d0:	str	r3, [r7, #0]
        if (pmbrPart) *pmbrPart = part; // zero based. 
    36d2:	cmp.w	r8, #0
    36d6:	beq.n	370c <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x130>
    36d8:	strb.w	r9, [r8]
    36dc:	b.n	370c <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x130>
    36de:	mov	r1, r4
#include "FsGetPartitionInfo.h"
namespace FsGetPartitionInfo {
  static const uint8_t mbdpGuid[16] PROGMEM = {0xA2, 0xA0, 0xD0, 0xEB, 0xE5, 0xB9, 0x33, 0x44, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7};

  voltype_t getPartitionInfo(BlockDeviceInterface *blockDev, uint8_t part, uint8_t *secBuf,
      uint32_t *pfirstLBA, uint32_t *psectorCount, uint32_t *pmbrLBA, uint8_t *pmbrPart) {
    36e0:	movs	r3, #0

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
      mp = &mbr->part[index_part];
      if ((mp->boot != 0 && mp->boot != 0X80) || mp->type == 0 || index_part > part) return INVALID_VOL;
    36e2:	ldrb.w	r0, [r1, #446]	; 0x1be
    36e6:	lsls	r0, r0, #25
    36e8:	uxtb	r2, r3
    36ea:	bne.n	35f0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    36ec:	ldrb.w	r0, [r1, #450]	; 0x1c2
    36f0:	cmp	r0, #0
    36f2:	beq.w	35f0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    36f6:	cmp	r9, r2
    36f8:	bcc.w	35f0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      if (mp->type == 0xf) break;
    36fc:	cmp	r0, #15
    36fe:	beq.n	3710 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x134>
    3700:	adds	r3, #1
      }
    }  

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
    3702:	cmp	r3, #4
    3704:	add.w	r1, r1, #16
    3708:	bne.n	36e2 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x106>
    370a:	b.n	35f0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      if (((mp->boot == 0) || (mp->boot == 0X80)) && (mp->type != 0) && (mp->type != 0xf)) {
        *pfirstLBA = getLe32(mp->relativeSectors);
        if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
        if (pmbrLBA) *pmbrLBA = 0;
        if (pmbrPart) *pmbrPart = part; // zero based. 
        return MBR_VOL;
    370c:	movs	r0, #1
    370e:	b.n	377c <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    }  

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
      mp = &mbr->part[index_part];
    3710:	add.w	r3, r4, r3, lsl #4
    3714:	adds	r2, #1
    3716:	ldr.w	r9, [r3, #454]	; 0x1c6
    371a:	uxtb.w	fp, r2
    if (index_part == 4) return INVALID_VOL; // no extended partition found. 

    // Our partition if it exists is in extended partition. 
    uint32_t next_mbr = getLe32(mp->relativeSectors);
    for(;;) {
      if (!blockDev->readSector(next_mbr, secBuf)) return INVALID_VOL;
    371e:	ldr	r3, [r5, #0]
    3720:	mov	r2, r4
    3722:	ldr	r3, [r3, #12]
    3724:	mov	r1, r9
    3726:	mov	r0, r5
    3728:	blx	r3
    372a:	cmp	r0, #0
    372c:	beq.w	35f0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      mbr = reinterpret_cast<MbrSector_t*>(secBuf);

      if (index_part == part) break; // should be at that entry
    3730:	ldr	r3, [sp, #4]
    3732:	cmp	r3, fp
    3734:	beq.n	3756 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x17a>
      // else we need to see if it points to others...
      mp = &mbr->part[1];
      uint32_t  relSec = getLe32(mp->relativeSectors);
      //Serial.printf("    Check for next: type: %u start:%u\n ", mp->type, volumeStartSector);
      if ((mp->type == 5) && relSec) {
    3736:	ldrb.w	r2, [r4, #466]	; 0x1d2
    373a:	ldr.w	r3, [r4, #470]	; 0x1d6
    373e:	cmp	r2, #5
    3740:	bne.w	35f0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    3744:	add.w	r2, fp, #1
    3748:	uxtb.w	fp, r2
    374c:	cmp	r3, #0
    374e:	beq.w	35f0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
        next_mbr = next_mbr + relSec;
    3752:	add	r9, r3

    if (index_part == 4) return INVALID_VOL; // no extended partition found. 

    // Our partition if it exists is in extended partition. 
    uint32_t next_mbr = getLe32(mp->relativeSectors);
    for(;;) {
    3754:	b.n	371e <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x142>
      } else return INVALID_VOL;
    }
   
    // If we are here than we should hopefully be at start of segment...
    mp = &mbr->part[0];
    *pfirstLBA = getLe32(mp->relativeSectors) + next_mbr;
    3756:	ldr.w	r3, [r4, #454]	; 0x1c6
    375a:	add	r3, r9
    375c:	str.w	r3, [sl]
    if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
    3760:	cbz	r6, 3768 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x18c>
    3762:	ldr.w	r3, [r4, #458]	; 0x1ca
    3766:	str	r3, [r6, #0]
    if (pmbrLBA) *pmbrLBA = next_mbr;
    3768:	cbz	r7, 376e <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x192>
    376a:	str.w	r9, [r7]
    if (pmbrPart) *pmbrPart = 0; // zero based. 
    376e:	cmp.w	r8, #0
    3772:	beq.n	377a <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x19e>
    3774:	movs	r3, #0
    3776:	strb.w	r3, [r8]
    return EXT_VOL;
    377a:	movs	r0, #2
  }
    377c:	add	sp, #12
    377e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3782:	nop
    3784:	.word	0x00012b08
    3788:	.word	0x00012af8

0000378c <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>:
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    378c:	cmp.w	r1, #256	; 0x100
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsStructs.h"
// bgnLba = relSector;
// endLba = relSector + partSize - 1;
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba) {
    3790:	push	{r4, r5, lr}
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    3792:	bhi.n	37a2 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x16>
  if (capacityMB <= 16) {
    3794:	cmp	r1, #16
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    3796:	mov.w	r4, #32
  if (capacityMB <= 16) {
    379a:	bls.n	37c6 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x3a>
    numberOfHeads = 2;
  } else if (capacityMB <= 32) {
    379c:	cmp	r1, #32
    379e:	bls.n	37ca <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x3e>
    37a0:	b.n	37a4 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x18>
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    37a2:	movs	r4, #63	; 0x3f
  if (capacityMB <= 16) {
    numberOfHeads = 2;
  } else if (capacityMB <= 32) {
    numberOfHeads = 4;
  } else if (capacityMB <= 128) {
    37a4:	cmp	r1, #128	; 0x80
    37a6:	bls.n	37ce <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x42>
    numberOfHeads = 8;
  } else if (capacityMB <= 504) {
    37a8:	cmp.w	r1, #504	; 0x1f8
    37ac:	bls.n	37d2 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x46>
    numberOfHeads = 16;
  } else if (capacityMB <= 1008) {
    37ae:	cmp.w	r1, #1008	; 0x3f0
    37b2:	bls.n	37d6 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x4a>
    numberOfHeads = 32;
  } else if (capacityMB <= 2016) {
    37b4:	cmp.w	r1, #2016	; 0x7e0
    37b8:	bls.n	37da <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x4e>
    numberOfHeads = 64;
  } else if (capacityMB <= 4032) {
    37ba:	cmp.w	r1, #4032	; 0xfc0
    numberOfHeads = 128;
  } else {
    numberOfHeads = 255;
    37be:	ite	ls
    37c0:	movls	r3, #128	; 0x80
    37c2:	movhi	r3, #255	; 0xff
    37c4:	b.n	37dc <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
  if (capacityMB <= 16) {
    numberOfHeads = 2;
    37c6:	movs	r3, #2
    37c8:	b.n	37dc <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 32) {
    numberOfHeads = 4;
    37ca:	movs	r3, #4
    37cc:	b.n	37dc <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 128) {
    numberOfHeads = 8;
    37ce:	movs	r3, #8
    37d0:	b.n	37dc <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 504) {
    numberOfHeads = 16;
    37d2:	movs	r3, #16
    37d4:	b.n	37dc <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 1008) {
    numberOfHeads = 32;
    37d6:	movs	r3, #32
    37d8:	b.n	37dc <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 2016) {
    numberOfHeads = 64;
    37da:	movs	r3, #64	; 0x40
  } else if (capacityMB <= 4032) {
    numberOfHeads = 128;
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
    37dc:	smulbb	r3, r3, r4
    37e0:	udiv	r5, r2, r3
  if (c <= 1023) {
    37e4:	cmp.w	r5, #1024	; 0x400
    37e8:	bcs.n	3802 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x76>
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
    37ea:	udiv	r1, r2, r4
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    37ee:	mls	r3, r3, r5, r2
    s = (lba % sectorsPerTrack) + 1;
    37f2:	mls	r2, r4, r1, r2
    37f6:	adds	r2, #1
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    37f8:	udiv	r3, r3, r4
    s = (lba % sectorsPerTrack) + 1;
    37fc:	uxtb	r2, r2
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    37fe:	uxtb	r3, r3
    3800:	b.n	380a <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x7e>
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    h = 254;
    s = 63;
    3802:	movs	r2, #63	; 0x3f
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    h = 254;
    3804:	movs	r3, #254	; 0xfe
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    3806:	movw	r5, #1023	; 0x3ff
    h = 254;
    s = 63;
  }
  chs[0] = h;
    380a:	strb	r3, [r0, #0]
  chs[1] = ((c >> 2) & 0XC0) | s;
    380c:	lsrs	r3, r5, #2
    380e:	bic.w	r3, r3, #63	; 0x3f
    3812:	orrs	r2, r3
    3814:	strb	r2, [r0, #1]
  chs[2] = c;
    3816:	strb	r5, [r0, #2]
    3818:	pop	{r4, r5, pc}

0000381a <FsCache::sync()>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    381a:	push	{r3, r4, r5, r6, r7, lr}
  if (m_status & CACHE_STATUS_DIRTY) {
    381c:	ldrb	r3, [r0, #0]
    381e:	lsls	r2, r3, #31

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    3820:	mov	r4, r0
  if (m_status & CACHE_STATUS_DIRTY) {
    3822:	bpl.n	3860 <FsCache::sync()+0x46>
    if (!m_blockDev->writeSector(m_sector, m_buffer)) {
    3824:	ldr	r0, [r0, #4]
    3826:	ldr	r1, [r4, #12]
    3828:	ldr	r3, [r0, #0]
    382a:	add.w	r6, r4, #16
    382e:	ldr	r3, [r3, #32]
    3830:	mov	r2, r6
    3832:	blx	r3
    3834:	mov	r5, r0
    3836:	cbnz	r0, 383c <FsCache::sync()+0x22>
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;

 fail:
  return false;
    3838:	movs	r5, #0
    383a:	b.n	3862 <FsCache::sync()+0x48>
    if (!m_blockDev->writeSector(m_sector, m_buffer)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
    383c:	ldrb	r3, [r4, #0]
    383e:	lsls	r3, r3, #30
    3840:	bmi.n	384c <FsCache::sync()+0x32>
      if (!m_blockDev->writeSector(sector, m_buffer)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
    3842:	ldrb	r3, [r4, #0]
    3844:	bic.w	r3, r3, #1
    3848:	strb	r3, [r4, #0]
    384a:	b.n	3862 <FsCache::sync()+0x48>
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
      uint32_t sector = m_sector + m_mirrorOffset;
      if (!m_blockDev->writeSector(sector, m_buffer)) {
    384c:	adds	r0, r4, #4
    384e:	ldmia	r0, {r0, r1, r7}
    3850:	ldr	r3, [r0, #0]
    3852:	mov	r2, r6
    3854:	ldr	r3, [r3, #32]
    3856:	add	r1, r7
    3858:	blx	r3
    385a:	cmp	r0, #0
    385c:	bne.n	3842 <FsCache::sync()+0x28>
    385e:	b.n	3838 <FsCache::sync()+0x1e>
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;
    3860:	movs	r5, #1

 fail:
  return false;
}
    3862:	mov	r0, r5
    3864:	pop	{r3, r4, r5, r6, r7, pc}

00003866 <FsCache::get(unsigned long, unsigned char)>:
#define DBG_FILE "FsCache.cpp"
#include "DebugMacros.h"
#include "FsCache.h"
//------------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
  if (!m_blockDev) {
    3866:	ldr	r3, [r0, #4]
 */
#define DBG_FILE "FsCache.cpp"
#include "DebugMacros.h"
#include "FsCache.h"
//------------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
    3868:	push	{r4, r5, r6, lr}
    386a:	mov	r4, r0
    386c:	mov	r6, r1
    386e:	mov	r5, r2
  if (!m_blockDev) {
    3870:	cbnz	r3, 3876 <FsCache::get(unsigned long, unsigned char)+0x10>
  }
  m_status |= option & CACHE_STATUS_MASK;
  return m_buffer;

 fail:
  return nullptr;
    3872:	movs	r0, #0
    3874:	pop	{r4, r5, r6, pc}
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
  if (!m_blockDev) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_sector != sector) {
    3876:	ldr	r3, [r0, #12]
    3878:	cmp	r3, r1
    387a:	beq.n	38a4 <FsCache::get(unsigned long, unsigned char)+0x3e>
    if (!sync()) {
    387c:	bl	381a <FsCache::sync()>
    3880:	cmp	r0, #0
    3882:	beq.n	3872 <FsCache::get(unsigned long, unsigned char)+0xc>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
    3884:	lsls	r3, r5, #29
    3886:	bpl.n	3890 <FsCache::get(unsigned long, unsigned char)+0x2a>
      if (!m_blockDev->readSector(sector, m_buffer)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status = 0;
    3888:	movs	r3, #0
    388a:	strb	r3, [r4, #0]
    m_sector = sector;
    388c:	str	r6, [r4, #12]
    388e:	b.n	38a4 <FsCache::get(unsigned long, unsigned char)+0x3e>
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
      if (!m_blockDev->readSector(sector, m_buffer)) {
    3890:	ldr	r0, [r4, #4]
    3892:	ldr	r3, [r0, #0]
    3894:	add.w	r2, r4, #16
    3898:	ldr	r3, [r3, #12]
    389a:	mov	r1, r6
    389c:	blx	r3
    389e:	cmp	r0, #0
    38a0:	bne.n	3888 <FsCache::get(unsigned long, unsigned char)+0x22>
    38a2:	b.n	3872 <FsCache::get(unsigned long, unsigned char)+0xc>
      }
    }
    m_status = 0;
    m_sector = sector;
  }
  m_status |= option & CACHE_STATUS_MASK;
    38a4:	ldrb	r3, [r4, #0]
    38a6:	mov	r0, r4
    38a8:	and.w	r5, r5, #3
    38ac:	orrs	r5, r3
    38ae:	strb.w	r5, [r0], #16
  return m_buffer;

 fail:
  return nullptr;
}
    38b2:	pop	{r4, r5, r6, pc}

000038b4 <toUpcase(unsigned short)>:
}
//------------------------------------------------------------------------------
uint16_t toUpcase(uint16_t chr) {
  uint16_t i, first;
  // Optimize for simple ASCII.
  if (chr < 127) {
    38b4:	cmp	r0, #126	; 0x7e
    }
  }
  return left;
}
//------------------------------------------------------------------------------
uint16_t toUpcase(uint16_t chr) {
    38b6:	push	{r4, r5, lr}
  uint16_t i, first;
  // Optimize for simple ASCII.
  if (chr < 127) {
    38b8:	bhi.n	38c8 <toUpcase(unsigned short)+0x14>
    return chr - ('a' <= chr && chr <= 'z' ? 'a' - 'A' : 0);
    38ba:	sub.w	r3, r0, #97	; 0x61
    38be:	cmp	r3, #25
    38c0:	ite	hi
    38c2:	movhi	r3, #0
    38c4:	movls	r3, #32
    38c6:	b.n	390a <toUpcase(unsigned short)+0x56>
    38c8:	ldr	r5, [pc, #132]	; (3950 <toUpcase(unsigned short)+0x9c>)
    38ca:	movs	r4, #53	; 0x35
    38cc:	movs	r3, #0
//------------------------------------------------------------------------------
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    38ce:	subs	r2, r4, r3
    38d0:	cmp	r2, #1
    38d2:	ldr	r1, [pc, #124]	; (3950 <toUpcase(unsigned short)+0x9c>)
    38d4:	bls.n	38e8 <toUpcase(unsigned short)+0x34>
    mid = left + (right - left)/2;
    38d6:	add.w	r2, r3, r2, lsr #1
    if (readTable16(table[mid].key) <= key) {
    38da:	ldrh.w	r1, [r5, r2, lsl #2]
    38de:	cmp	r1, r0
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    mid = left + (right - left)/2;
    38e0:	ite	hi
    38e2:	movhi	r4, r2
    38e4:	movls	r3, r2
    38e6:	b.n	38ce <toUpcase(unsigned short)+0x1a>
  // Optimize for simple ASCII.
  if (chr < 127) {
    return chr - ('a' <= chr && chr <= 'z' ? 'a' - 'A' : 0);
  }
  i = searchPair16(reinterpret_cast<const pair16_t*>(mapTable), MAP_DIM, chr);
  first = readTable16(mapTable[i].base);
    38e8:	uxth	r2, r3
    38ea:	ldrh.w	r3, [r1, r2, lsl #2]
  if (first <= chr && (chr - first)  < readTable8(mapTable[i].count)) {
    38ee:	cmp	r0, r3
    38f0:	bcc.n	391e <toUpcase(unsigned short)+0x6a>
    38f2:	add.w	r2, r1, r2, lsl #2
    38f6:	subs	r3, r0, r3
    38f8:	ldrb	r1, [r2, #3]
    38fa:	cmp	r3, r1
    38fc:	bge.n	391e <toUpcase(unsigned short)+0x6a>
    int8_t off = readTable8(mapTable[i].off);
    38fe:	ldrsb.w	r2, [r2, #2]
    if (off == 1) {
    3902:	cmp	r2, #1
    3904:	bne.n	390e <toUpcase(unsigned short)+0x5a>
      return chr - ((chr - first) & 1);
    3906:	and.w	r3, r3, #1
    390a:	subs	r0, r0, r3
    390c:	b.n	391a <toUpcase(unsigned short)+0x66>
    }
    return chr + (off ? off : -0x1C60);
    390e:	cbz	r2, 3914 <toUpcase(unsigned short)+0x60>
    3910:	uxth	r2, r2
    3912:	b.n	3918 <toUpcase(unsigned short)+0x64>
    3914:	movw	r2, #58272	; 0xe3a0
    3918:	add	r0, r2
    391a:	uxth	r0, r0
    391c:	pop	{r4, r5, pc}
    391e:	ldr	r5, [pc, #52]	; (3954 <toUpcase(unsigned short)+0xa0>)
    3920:	movs	r4, #75	; 0x4b
    3922:	movs	r3, #0
//------------------------------------------------------------------------------
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    3924:	subs	r2, r4, r3
    3926:	cmp	r2, #1
    3928:	ldr	r1, [pc, #40]	; (3954 <toUpcase(unsigned short)+0xa0>)
    392a:	bls.n	393e <toUpcase(unsigned short)+0x8a>
    mid = left + (right - left)/2;
    392c:	add.w	r2, r3, r2, lsr #1
    if (readTable16(table[mid].key) <= key) {
    3930:	ldrh.w	r1, [r5, r2, lsl #2]
    3934:	cmp	r1, r0
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    mid = left + (right - left)/2;
    3936:	ite	hi
    3938:	movhi	r4, r2
    393a:	movls	r3, r2
    393c:	b.n	3924 <toUpcase(unsigned short)+0x70>
      return chr - ((chr - first) & 1);
    }
    return chr + (off ? off : -0x1C60);
  }
  i = searchPair16(lookupTable, LOOKUP_DIM, chr);
  if (readTable16(lookupTable[i].key) == chr) {
    393e:	uxth	r3, r3
    3940:	ldrh.w	r2, [r1, r3, lsl #2]
    3944:	cmp	r2, r0
    return readTable16(lookupTable[i].val);
    3946:	itt	eq
    3948:	addeq.w	r3, r1, r3, lsl #2
    394c:	ldrheq	r0, [r3, #2]
  }
  return chr;
}
    394e:	pop	{r4, r5, pc}
    3950:	.word	0x00012c3e
    3954:	.word	0x00012b12

00003958 <FsName::get16()>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsName.h"
#include "FsUtf.h"
#if USE_UTF8_LONG_NAMES
uint16_t FsName::get16() {
    3958:	push	{r0, r1, r4, lr}
    395a:	mov	r4, r0
  uint16_t rtn;
  if (ls) {
    395c:	ldrh	r0, [r0, #12]
    395e:	cbz	r0, 3966 <FsName::get16()+0xe>
    rtn = ls;
    ls = 0;
    3960:	movs	r3, #0
    3962:	strh	r3, [r4, #12]
    3964:	b.n	399c <FsName::get16()+0x44>
  } else if (next >= end) {
    3966:	ldr	r3, [r4, #4]
    3968:	ldr	r1, [r4, #8]
    396a:	cmp	r3, r1
    396c:	bcs.n	399c <FsName::get16()+0x44>
    rtn = 0;
  } else {
    uint32_t cp;
    const char* ptr = FsUtf::mbToCp(next, end, &cp);
    396e:	add	r2, sp, #4
    3970:	mov	r0, r3
    3972:	bl	3558 <FsUtf::mbToCp(char const*, char const*, unsigned long*)>
    if (!ptr) {
    3976:	cbz	r0, 3998 <FsName::get16()+0x40>
      goto fail;
    }
    next = ptr;
    3978:	str	r0, [r4, #4]
    if (cp <= 0XFFFF) {
    397a:	ldr	r0, [sp, #4]
    397c:	cmp.w	r0, #65536	; 0x10000
      rtn = cp;
    } else {
      ls = FsUtf::lowSurrogate(cp);
    3980:	itttt	cs
    3982:	ubfxcs	r3, r0, #0, #10
  /** High surrogate for a code point.
   * \param{in} cp code point.
   * \return high surrogate.
   */
  inline uint16_t highSurrogate(uint32_t cp) {
    return (cp >> 10) + (0XD800 - (0X10000 >> 10));
    3986:	lsrcs	r0, r0, #10
    3988:	subcs.w	r3, r3, #9216	; 0x2400
    398c:	subcs.w	r0, r0, #10304	; 0x2840
    3990:	it	cs
    3992:	strhcs	r3, [r4, #12]
    3994:	uxth	r0, r0
    3996:	b.n	399c <FsName::get16()+0x44>
    }
  }
  return rtn;

 fail:
  return 0XFFFF;
    3998:	movw	r0, #65535	; 0xffff
}
    399c:	add	sp, #8
    399e:	pop	{r4, pc}

000039a0 <ExFatFormatter::syncUpcase()>:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::syncUpcase() {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    39a0:	ldr	r3, [r0, #8]
    39a2:	ubfx	r3, r3, #0, #9
 fail:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::syncUpcase() {
    39a6:	mov	r1, r0
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  if (!index) {
    39a8:	cbz	r3, 39c4 <ExFatFormatter::syncUpcase()+0x24>
    return true;
  }
  for (size_t i = index; i < BYTES_PER_SECTOR; i++) {
    m_secBuf[i] = 0;
    39aa:	movs	r0, #0
    39ac:	ldr	r2, [r1, #16]
    39ae:	strb	r0, [r2, r3]
bool ExFatFormatter::syncUpcase() {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  if (!index) {
    return true;
  }
  for (size_t i = index; i < BYTES_PER_SECTOR; i++) {
    39b0:	adds	r3, #1
    39b2:	cmp.w	r3, #512	; 0x200
    39b6:	bne.n	39ac <ExFatFormatter::syncUpcase()+0xc>
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
    39b8:	ldr	r0, [r1, #12]
    39ba:	ldr	r2, [r1, #16]
    39bc:	ldr	r3, [r0, #0]
    39be:	ldr	r1, [r1, #0]
    39c0:	ldr	r3, [r3, #32]
    39c2:	bx	r3
}
    39c4:	movs	r0, #1
    39c6:	bx	lr

000039c8 <ExFatFormatter::writeUpcaseByte(unsigned char)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    39c8:	ldr	r2, [r0, #8]
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
    39ca:	mov	r3, r0
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    39cc:	ubfx	r2, r2, #0, #9
  m_secBuf[index] = b;
    39d0:	ldr	r0, [r0, #16]
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
    39d2:	push	{r4}
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  m_secBuf[index] = b;
    39d4:	strb	r1, [r0, r2]
  m_upcaseChecksum = exFatChecksum(m_upcaseChecksum, b);
    39d6:	ldr	r0, [r3, #4]
    39d8:	add.w	r1, r1, r0, ror #1
    39dc:	str	r1, [r3, #4]
  m_upcaseSize++;
    39de:	ldr	r1, [r3, #8]
    39e0:	adds	r1, #1
    39e2:	str	r1, [r3, #8]
  if (index == SECTOR_MASK) {
    39e4:	movw	r1, #511	; 0x1ff
    39e8:	cmp	r2, r1
    39ea:	bne.n	3a02 <ExFatFormatter::writeUpcaseByte(unsigned char)+0x3a>
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
    39ec:	ldr	r0, [r3, #12]
    39ee:	ldr	r1, [r3, #0]
    39f0:	ldr	r2, [r0, #0]
    39f2:	ldr	r4, [r2, #32]
    39f4:	adds	r2, r1, #1
    39f6:	str	r2, [r3, #0]
    39f8:	ldr	r2, [r3, #16]
    39fa:	mov	r3, r4
  }
  return true;
}
    39fc:	ldr.w	r4, [sp], #4
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  m_secBuf[index] = b;
  m_upcaseChecksum = exFatChecksum(m_upcaseChecksum, b);
  m_upcaseSize++;
  if (index == SECTOR_MASK) {
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
    3a00:	bx	r3
  }
  return true;
}
    3a02:	movs	r0, #1
    3a04:	ldr.w	r4, [sp], #4
    3a08:	bx	lr

00003a0a <ExFatFormatter::writeUpcaseUnicode(unsigned short)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
    3a0a:	push	{r3, r4, r5, lr}
    3a0c:	mov	r4, r1
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    3a0e:	uxtb	r1, r1
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
  }
  return true;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
    3a10:	mov	r5, r0
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    3a12:	bl	39c8 <ExFatFormatter::writeUpcaseByte(unsigned char)>
    3a16:	cbz	r0, 3a24 <ExFatFormatter::writeUpcaseUnicode(unsigned short)+0x1a>
    3a18:	lsrs	r1, r4, #8
    3a1a:	mov	r0, r5
}
    3a1c:	ldmia.w	sp!, {r3, r4, r5, lr}
  }
  return true;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    3a20:	b.w	39c8 <ExFatFormatter::writeUpcaseByte(unsigned char)>
}
    3a24:	pop	{r3, r4, r5, pc}

00003a26 <ExFatFormatter::writeUpcase(unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcase(uint32_t sector) {
    3a26:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t n;
  uint32_t ns;
  uint32_t ch = 0;
  uint16_t uc;

  m_upcaseSize = 0;
    3a28:	movs	r4, #0
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;
    3a2a:	stmia.w	r0, {r1, r4}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcase(uint32_t sector) {
    3a2e:	mov	r7, r0
  uint32_t n;
  uint32_t ns;
  uint32_t ch = 0;
  uint16_t uc;

  m_upcaseSize = 0;
    3a30:	str	r4, [r0, #8]
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    uc = toUpcase(ch);
    3a32:	uxth	r0, r4
    3a34:	bl	38b4 <toUpcase(unsigned short)>
    if (uc != ch) {
    3a38:	cmp	r0, r4
  m_upcaseSize = 0;
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    uc = toUpcase(ch);
    3a3a:	mov	r6, r0
    if (uc != ch) {
    3a3c:	beq.n	3a54 <ExFatFormatter::writeUpcase(unsigned long)+0x2e>
      if (!writeUpcaseUnicode(uc)) {
    3a3e:	mov	r1, r0
    3a40:	mov	r0, r7
    3a42:	bl	3a0a <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    3a46:	cbz	r0, 3ab2 <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    3a48:	adds	r5, r4, #1

  m_upcaseSize = 0;
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    3a4a:	cmp.w	r5, #65536	; 0x10000
    3a4e:	bcs.n	3a68 <ExFatFormatter::writeUpcase(unsigned long)+0x42>
    3a50:	mov	r4, r5
    3a52:	b.n	3a32 <ExFatFormatter::writeUpcase(unsigned long)+0xc>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
    3a54:	adds	r5, r4, #1
    3a56:	cmp.w	r5, #65536	; 0x10000
    3a5a:	bcs.n	3a72 <ExFatFormatter::writeUpcase(unsigned long)+0x4c>
    3a5c:	uxth	r0, r5
    3a5e:	bl	38b4 <toUpcase(unsigned short)>
    3a62:	cmp	r5, r0
    3a64:	bne.n	3a72 <ExFatFormatter::writeUpcase(unsigned long)+0x4c>
    3a66:	b.n	3aae <ExFatFormatter::writeUpcase(unsigned long)+0x88>
          }
        }
      }
    }
  }
  if (!syncUpcase()) {
    3a68:	mov	r0, r7
  }
  return true;

 fail:
  return false;
}
    3a6a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
          }
        }
      }
    }
  }
  if (!syncUpcase()) {
    3a6e:	b.w	39a0 <ExFatFormatter::syncUpcase()>
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
      ns = n - ch;
    3a72:	subs	r4, r5, r4
      if (ns >= MINIMUM_UPCASE_SKIP) {
    3a74:	cmp.w	r4, #512	; 0x200
    3a78:	bcc.n	3a94 <ExFatFormatter::writeUpcase(unsigned long)+0x6e>
        if (!writeUpcaseUnicode(0XFFFF) || !writeUpcaseUnicode(ns)) {
    3a7a:	movw	r1, #65535	; 0xffff
    3a7e:	mov	r0, r7
    3a80:	bl	3a0a <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    3a84:	cbz	r0, 3ab2 <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
    3a86:	uxth	r1, r4
    3a88:	mov	r0, r7
    3a8a:	bl	3a0a <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    3a8e:	cmp	r0, #0
    3a90:	bne.n	3a4a <ExFatFormatter::writeUpcase(unsigned long)+0x24>
    3a92:	b.n	3ab2 <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
      ns = n - ch;
      if (ns >= MINIMUM_UPCASE_SKIP) {
    3a94:	mov	r4, r6
          DBG_FAIL_MACRO;
          goto fail;
        }
        ch = n;
      } else {
        while (ch < n) {
    3a96:	cmp	r5, r4
    3a98:	bhi.n	3a9e <ExFatFormatter::writeUpcase(unsigned long)+0x78>
    3a9a:	mov	r5, r4
    3a9c:	b.n	3a4a <ExFatFormatter::writeUpcase(unsigned long)+0x24>
          if (!writeUpcaseUnicode(ch++)) {
    3a9e:	uxth	r1, r4
    3aa0:	mov	r0, r7
    3aa2:	bl	3a0a <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    3aa6:	adds	r4, #1
    3aa8:	cmp	r0, #0
    3aaa:	bne.n	3a96 <ExFatFormatter::writeUpcase(unsigned long)+0x70>
    3aac:	b.n	3ab2 <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
    3aae:	adds	r5, #1
    3ab0:	b.n	3a56 <ExFatFormatter::writeUpcase(unsigned long)+0x30>
  }
  return true;

 fail:
  return false;
}
    3ab2:	movs	r0, #0
    3ab4:	pop	{r3, r4, r5, r6, r7, pc}
    3ab6:	Address 0x00003ab6 is out of bounds.


00003ab8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>:
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    3ab8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3abc:	mov	r7, r3
  uint32_t volumeLength;
  uint32_t sectorCount;
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
    3abe:	mov	r3, r0
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    3ac0:	sub	sp, #28
  uint32_t volumeLength;
  uint32_t sectorCount;
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
    3ac2:	str	r1, [r3, #12]
  m_secBuf = secBuf;
    3ac4:	str	r2, [r3, #16]
  sectorCount = dev->sectorCount();
    3ac6:	ldr	r3, [r1, #0]
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    3ac8:	str	r0, [sp, #4]
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    3aca:	ldr	r3, [r3, #24]
    3acc:	mov	r0, r1
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    3ace:	mov	r5, r1
    3ad0:	mov	r4, r2
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    3ad2:	blx	r3
  // Min size is 512 MB
  if (sectorCount < 0X100000) {
    3ad4:	cmp.w	r0, #1048576	; 0x100000
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    3ad8:	mov	r9, r0
  // Min size is 512 MB
  if (sectorCount < 0X100000) {
    3ada:	bcs.n	3aec <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x34>
    writeMsg(pr, "Device is too small\r\n");
    3adc:	cmp	r7, #0
    3ade:	beq.w	3d06 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x24e>
    3ae2:	ldr	r1, [pc, #584]	; (3d2c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x274>)
    3ae4:	mov	r0, r7
    3ae6:	bl	734 <Print::write(char const*)>
    3aea:	b.n	3cfe <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x246>
    3aec:	movs	r6, #0
    3aee:	movs	r3, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
    3af0:	adds	r6, #1
    3af2:	uxtb	r6, r6
    3af4:	cmp	r6, #32
    3af6:	mov.w	r3, r3, lsl #1
    3afa:	beq.n	3b08 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x50>
    3afc:	cmp	r9, r3
    3afe:	bhi.n	3af0 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x38>
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
    3b00:	cmp	r6, #28
    3b02:	bhi.n	3b08 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x50>
    3b04:	movs	r3, #8
    3b06:	b.n	3b10 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x58>
    3b08:	sub.w	r8, r6, #11
    3b0c:	ubfx	r3, r8, #1, #8
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
    3b10:	cmp	r6, #26
    3b12:	it	hi
    3b14:	addhi	r6, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
    3b16:	str	r3, [sp, #8]
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
    3b18:	ittte	hi
    3b1a:	asrhi	r6, r6, #1
    3b1c:	movhi	r3, #1
    3b1e:	lslhi	r3, r6
    3b20:	movls.w	r3, #8192	; 0x2000
    3b24:	str	r3, [sp, #0]
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
    3b26:	ldr	r3, [sp, #0]
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    3b28:	ldr	r2, [sp, #8]
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
    3b2a:	lsls	r6, r3, #1
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
    3b2c:	lsls	r3, r3, #2
    3b2e:	rsb	sl, r3, r9
    3b32:	str	r3, [sp, #16]
    3b34:	ldr	r3, [sp, #8]
    3b36:	lsr.w	r3, sl, r3
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    3b3a:	lsl.w	sl, r3, r2

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3b3e:	movs	r1, #0
    3b40:	mov.w	r2, #512	; 0x200
    3b44:	mov	r0, r4
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
    3b46:	str	r3, [sp, #12]
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3b48:	bl	90bc <memset>
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
  mbr->part->type = 7;
    3b4c:	movs	r3, #7
    3b4e:	strb.w	r3, [r4, #450]	; 0x1c2
  mbr->part->endCHS[0] = 0XFE;
    3b52:	movs	r3, #254	; 0xfe
    3b54:	strb.w	r3, [r4, #451]	; 0x1c3
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
    3b58:	mov.w	fp, #1
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
  mbr->part->type = 7;
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
    3b5c:	movs	r3, #255	; 0xff
  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
    3b5e:	mov.w	r8, #0
  mbr->part->type = 7;
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
    3b62:	strb.w	r3, [r4, #452]	; 0x1c4
  mbr->part->endCHS[2] = 0XFF;
    3b66:	strb.w	r3, [r4, #453]	; 0x1c5
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
    3b6a:	strb.w	fp, [r4, #447]	; 0x1bf
  mbr->part->beginCHS[1] = 1;
    3b6e:	strb.w	fp, [r4, #448]	; 0x1c0
  mbr->part->beginCHS[2] = 0;
    3b72:	strb.w	r8, [r4, #449]	; 0x1c1
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3b76:	movw	r3, #43605	; 0xaa55
    3b7a:	strh.w	r3, [r4, #510]	; 0x1fe
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
  setLe32(mbr->part->relativeSectors, partitionOffset);
  setLe32(mbr->part->totalSectors, volumeLength);
  setLe16(mbr->signature, MBR_SIGNATURE);
  if (!dev->writeSector(0, secBuf)) {
    3b7e:	ldr	r3, [r5, #0]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3b80:	str.w	r6, [r4, #454]	; 0x1c6
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    3b84:	add	sl, r6
    3b86:	str.w	sl, [r4, #458]	; 0x1ca
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
  setLe32(mbr->part->relativeSectors, partitionOffset);
  setLe32(mbr->part->totalSectors, volumeLength);
  setLe16(mbr->signature, MBR_SIGNATURE);
  if (!dev->writeSector(0, secBuf)) {
    3b8a:	ldr	r3, [r3, #32]
    3b8c:	mov	r2, r4
    3b8e:	mov	r1, r8
    3b90:	mov	r0, r5
    3b92:	blx	r3
    3b94:	cmp	r0, #0
    3b96:	beq.w	3cfc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Partition Boot sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3b9a:	mov.w	r2, #512	; 0x200
    3b9e:	mov	r1, r8
    3ba0:	mov	r0, r4
    3ba2:	bl	90bc <memset>
  pbs = reinterpret_cast<ExFatPbs_t*>(secBuf);
  pbs->jmpInstruction[0] = 0XEB;
    3ba6:	movs	r3, #235	; 0xeb
    3ba8:	strb	r3, [r4, #0]
  pbs->jmpInstruction[1] = 0X76;
    3baa:	movs	r3, #118	; 0x76
    3bac:	strb	r3, [r4, #1]
  pbs->jmpInstruction[2] = 0X90;
    3bae:	movs	r3, #144	; 0x90
    3bb0:	strb	r3, [r4, #2]
  pbs->oemName[0] = 'E';
    3bb2:	movs	r3, #69	; 0x45
    3bb4:	strb	r3, [r4, #3]
  pbs->oemName[1] = 'X';
    3bb6:	movs	r3, #88	; 0x58
    3bb8:	strb	r3, [r4, #4]
  pbs->oemName[2] = 'F';
    3bba:	movs	r3, #70	; 0x46
    3bbc:	strb	r3, [r4, #5]
  pbs->oemName[3] = 'A';
    3bbe:	movs	r3, #65	; 0x41
    3bc0:	strb	r3, [r4, #6]
  pbs->oemName[4] = 'T';
    3bc2:	movs	r3, #84	; 0x54
    3bc4:	strb	r3, [r4, #7]
  pbs->oemName[5] = ' ';
    3bc6:	movs	r3, #32
    3bc8:	strb	r3, [r4, #8]
  pbs->oemName[6] = ' ';
    3bca:	strb	r3, [r4, #9]
  pbs->oemName[7] = ' ';
    3bcc:	strb	r3, [r4, #10]
    3bce:	ldr	r3, [sp, #0]
    3bd0:	str	r3, [r4, #80]	; 0x50
    3bd2:	str	r3, [r4, #84]	; 0x54
    3bd4:	ldr	r3, [sp, #12]
    3bd6:	str	r3, [r4, #92]	; 0x5c
    3bd8:	movs	r3, #4
    3bda:	str	r3, [r4, #96]	; 0x60
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3bdc:	mov.w	r3, #256	; 0x100
    3be0:	strh.w	r3, [r4, #104]	; 0x68
  setLe32(pbs->bpb.clusterCount, clusterCount);
  setLe32(pbs->bpb.rootDirectoryCluster, ROOT_CLUSTER);
  setLe32(pbs->bpb.volumeSerialNumber, sectorCount);
  setLe16(pbs->bpb.fileSystemRevision, 0X100);
  setLe16(pbs->bpb.volumeFlags, 0);
  pbs->bpb.bytesPerSectorShift = BYTES_PER_SECTOR_SHIFT;
    3be4:	movs	r3, #9
    3be6:	strb.w	r3, [r4, #108]	; 0x6c
  pbs->bpb.sectorsPerClusterShift = sectorsPerClusterShift;
    3bea:	ldrb.w	r3, [sp, #8]
    3bee:	strb.w	r3, [r4, #109]	; 0x6d
  pbs->bpb.numberOfFats = 1;
  pbs->bpb.driveSelect = 0X80;
    3bf2:	movs	r3, #128	; 0x80
    3bf4:	strb.w	r3, [r4, #111]	; 0x6f

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    3bf8:	str	r6, [r4, #64]	; 0x40
    3bfa:	str.w	r8, [r4, #68]	; 0x44
    3bfe:	str.w	sl, [r4, #72]	; 0x48
    3c02:	str.w	r8, [r4, #76]	; 0x4c
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3c06:	str	r6, [r4, #88]	; 0x58
    3c08:	str.w	r9, [r4, #100]	; 0x64
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3c0c:	strh.w	r8, [r4, #106]	; 0x6a
  setLe32(pbs->bpb.volumeSerialNumber, sectorCount);
  setLe16(pbs->bpb.fileSystemRevision, 0X100);
  setLe16(pbs->bpb.volumeFlags, 0);
  pbs->bpb.bytesPerSectorShift = BYTES_PER_SECTOR_SHIFT;
  pbs->bpb.sectorsPerClusterShift = sectorsPerClusterShift;
  pbs->bpb.numberOfFats = 1;
    3c10:	strb.w	fp, [r4, #110]	; 0x6e
  pbs->bpb.driveSelect = 0X80;
  pbs->bpb.percentInUse = 0;
    3c14:	strb.w	r8, [r4, #112]	; 0x70
    3c18:	add.w	r3, r4, #119	; 0x77
    3c1c:	addw	r2, r4, #509	; 0x1fd

  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
    3c20:	movs	r1, #244	; 0xf4
    3c22:	strb.w	r1, [r3, #1]!
  pbs->bpb.numberOfFats = 1;
  pbs->bpb.driveSelect = 0X80;
  pbs->bpb.percentInUse = 0;

  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    3c26:	cmp	r3, r2
    3c28:	bne.n	3c22 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x16a>
    3c2a:	movw	r3, #43605	; 0xaa55
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    3c2e:	mov.w	r9, #0
    3c32:	strh.w	r3, [r4, #510]	; 0x1fe
  ExFatPbs_t* pbs;
  DirUpcase_t* dup;
  DirBitmap_t* dbm;
  DirLabel_t* label;
  uint32_t bitmapSize;
  uint32_t checksum = 0;
    3c36:	mov	r8, r9
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    if (i == offsetof(ExFatPbs_t, bpb.volumeFlags[0]) ||
    3c38:	sub.w	r3, r9, #106	; 0x6a
    3c3c:	cmp	r3, #1
    3c3e:	bls.n	3c4e <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x196>
        i == offsetof(ExFatPbs_t, bpb.volumeFlags[1]) ||
    3c40:	cmp.w	r9, #112	; 0x70
  uint8_t  mustBeZero2[2];
  uint8_t  unicode3[4];
} DirLfn_t;
//=============================================================================
inline uint32_t exFatChecksum(uint32_t sum, uint8_t data) {
  return (sum << 31) + (sum >> 1) + data;
    3c44:	itt	ne
    3c46:	ldrbne.w	r3, [r4, r9]
    3c4a:	addne.w	r8, r3, r8, ror #1
  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    3c4e:	add.w	r9, r9, #1
    3c52:	cmp.w	r9, #512	; 0x200
    3c56:	bne.n	3c38 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x180>
      continue;
    }
    checksum = exFatChecksum(checksum, secBuf[i]);
  }
  sector = partitionOffset;
  if (!dev->writeSector(sector, secBuf)  ||
    3c58:	ldr	r3, [r5, #0]
    3c5a:	mov	r2, r4
    3c5c:	ldr	r3, [r3, #32]
    3c5e:	mov	r1, r6
    3c60:	mov	r0, r5
    3c62:	blx	r3
    3c64:	cmp	r0, #0
    3c66:	beq.n	3cfc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3c68:	ldr	r3, [r5, #0]
    3c6a:	mov	r2, r4
    3c6c:	ldr	r3, [r3, #32]
    3c6e:	add.w	r1, r6, #12
    3c72:	mov	r0, r5
    3c74:	blx	r3
      continue;
    }
    checksum = exFatChecksum(checksum, secBuf[i]);
  }
  sector = partitionOffset;
  if (!dev->writeSector(sector, secBuf)  ||
    3c76:	cmp	r0, #0
    3c78:	beq.n	3cfc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3c7a:	mov	r2, r9
    3c7c:	movs	r1, #0
    3c7e:	mov	r0, r4
    3c80:	bl	90bc <memset>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3c84:	movw	r3, #43605	; 0xaa55
    3c88:	strh.w	r3, [r4, #510]	; 0x1fe
    3c8c:	subs	r3, r4, #1
  if (!dev->writeSector(sector, secBuf)  ||
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector++;
    3c8e:	add.w	sl, r6, #1
    3c92:	add.w	r9, r6, #9
    3c96:	str	r3, [sp, #20]
    3c98:	addw	fp, r4, #511	; 0x1ff
  ExFatPbs_t* pbs;
  DirUpcase_t* dup;
  DirBitmap_t* dbm;
  DirLabel_t* label;
  uint32_t bitmapSize;
  uint32_t checksum = 0;
    3c9c:	ldr	r3, [sp, #20]
  uint8_t  mustBeZero2[2];
  uint8_t  unicode3[4];
} DirLfn_t;
//=============================================================================
inline uint32_t exFatChecksum(uint32_t sum, uint8_t data) {
  return (sum << 31) + (sum >> 1) + data;
    3c9e:	ldrb.w	r2, [r3, #1]!
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    3ca2:	cmp	fp, r3
    3ca4:	add.w	r8, r2, r8, ror #1
    3ca8:	bne.n	3c9e <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x1e6>
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    3caa:	ldr	r3, [r5, #0]
    3cac:	mov	r2, r4
    3cae:	ldr	r3, [r3, #32]
    3cb0:	mov	r1, sl
    3cb2:	mov	r0, r5
    3cb4:	blx	r3
    3cb6:	cbz	r0, 3cfc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3cb8:	ldr	r3, [r5, #0]
    3cba:	mov	r2, r4
    3cbc:	ldr	r3, [r3, #32]
    3cbe:	add.w	r1, sl, #12
    3cc2:	mov	r0, r5
    3cc4:	blx	r3
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    3cc6:	cbz	r0, 3cfc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    sector++;
    3cc8:	add.w	sl, sl, #1
  }
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    3ccc:	cmp	sl, r9
    3cce:	bne.n	3c9c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x1e4>
      goto fail;
    }
    sector++;
  }
  // Write OEM Parameter Sector and reserved sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3cd0:	mov.w	r2, #512	; 0x200
    3cd4:	movs	r1, #0
    3cd6:	mov	r0, r4
    3cd8:	bl	90bc <memset>
    3cdc:	add.w	sl, r6, #11
    3ce0:	ldr	r3, [sp, #20]
    3ce2:	ldrb.w	r2, [r3, #1]!
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    3ce6:	cmp	fp, r3
    3ce8:	add.w	r8, r2, r8, ror #1
    3cec:	bne.n	3ce2 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x22a>
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    3cee:	ldr	r3, [r5, #0]
    3cf0:	mov	r2, r4
    3cf2:	ldr	r3, [r3, #32]
    3cf4:	mov	r1, r9
    3cf6:	mov	r0, r5
    3cf8:	blx	r3
    3cfa:	cbnz	r0, 3d0c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x254>
  }
  writeMsg(pr, "Format done\r\n");
  return true;

 fail:
  writeMsg(pr, "Format failed\r\n");
    3cfc:	cbz	r7, 3d06 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x24e>
    3cfe:	ldr	r1, [pc, #48]	; (3d30 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x278>)
    3d00:	mov	r0, r7
    3d02:	bl	734 <Print::write(char const*)>
  return false;
    3d06:	mov.w	sl, #0
    3d0a:	b.n	3ef0 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x438>
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3d0c:	ldr	r3, [r5, #0]
    3d0e:	mov	r2, r4
    3d10:	ldr	r3, [r3, #32]
    3d12:	add.w	r1, r9, #12
    3d16:	mov	r0, r5
    3d18:	blx	r3
  memset(secBuf, 0, BYTES_PER_SECTOR);
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    3d1a:	cmp	r0, #0
    3d1c:	beq.n	3cfc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    sector++;
    3d1e:	add.w	r3, r9, #1
    }
    sector++;
  }
  // Write OEM Parameter Sector and reserved sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  for (int j = 0; j < 2; j++) {
    3d22:	cmp	r3, sl
    3d24:	beq.n	3d34 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x27c>
    3d26:	mov	r9, r3
    3d28:	b.n	3ce0 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x228>
    3d2a:	nop
    3d2c:	.word	0x00012d12
    3d30:	.word	0x00012d6b
    3d34:	subs	r3, r4, #4
    3d36:	add.w	r2, r4, #508	; 0x1fc
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3d3a:	str.w	r8, [r3, #4]!
      goto fail;
    }
    sector++;
  }
  // Write Boot CheckSum Sector.
  for (size_t i = 0; i < BYTES_PER_SECTOR; i += 4) {
    3d3e:	cmp	r2, r3
    3d40:	bne.n	3d3a <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x282>
    setLe32(secBuf + i, checksum);
  }
  if (!dev->writeSector(sector, secBuf)  ||
    3d42:	ldr	r3, [r5, #0]
    3d44:	mov	r2, r4
    3d46:	ldr	r3, [r3, #32]
    3d48:	mov	r1, sl
    3d4a:	mov	r0, r5
    3d4c:	blx	r3
    3d4e:	cmp	r0, #0
    3d50:	beq.n	3cfc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3d52:	ldr	r3, [r5, #0]
    3d54:	mov	r2, r4
    3d56:	ldr	r3, [r3, #32]
    3d58:	add.w	r1, r9, #13
    3d5c:	mov	r0, r5
    3d5e:	blx	r3
  }
  // Write Boot CheckSum Sector.
  for (size_t i = 0; i < BYTES_PER_SECTOR; i += 4) {
    setLe32(secBuf + i, checksum);
  }
  if (!dev->writeSector(sector, secBuf)  ||
    3d60:	cmp	r0, #0
    3d62:	beq.n	3cfc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
    3d64:	cbz	r7, 3d6e <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2b6>
    3d66:	ldr	r1, [pc, #400]	; (3ef8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x440>)
    3d68:	mov	r0, r7
    3d6a:	bl	734 <Print::write(char const*)>
  sector = partitionOffset + fatOffset;
    3d6e:	ldr	r3, [sp, #0]
    3d70:	add	r6, r3
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3d72:	ldr	r3, [sp, #12]

  memset(secBuf, 0, BYTES_PER_SECTOR);
    3d74:	mov.w	r2, #512	; 0x200
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3d78:	mov.w	r9, r3, lsl #2

  memset(secBuf, 0, BYTES_PER_SECTOR);
    3d7c:	movs	r1, #0
    3d7e:	mov	r0, r4
    3d80:	bl	90bc <memset>
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3d84:	addw	r9, r9, #519	; 0x207

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
    3d88:	movs	r3, #248	; 0xf8
    3d8a:	strb	r3, [r4, #0]
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3d8c:	mov.w	sl, r9, lsr #9
    3d90:	mov	r3, r4
    3d92:	add.w	r2, r4, #19

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    secBuf[i] = 0XFF;
    3d96:	movs	r1, #255	; 0xff
    3d98:	strb.w	r1, [r3, #1]!
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    3d9c:	cmp	r2, r3
    3d9e:	bne.n	3d98 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2e0>
    secBuf[i] = 0XFF;
  }
  for (uint32_t i = 0; i < ns; i++) {
    if (i%(ns/32) == 0) {
    3da0:	mov.w	r9, r9, lsr #14
    3da4:	mov.w	r8, #0
    3da8:	udiv	r3, r8, r9
    3dac:	mls	r3, r9, r3, r8
    3db0:	cbnz	r3, 3dbc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x304>
      writeMsg(pr, ".");
    3db2:	cbz	r7, 3dbc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x304>
    3db4:	ldr	r1, [pc, #324]	; (3efc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x444>)
    3db6:	mov	r0, r7
    3db8:	bl	734 <Print::write(char const*)>
    }
    if (!dev->writeSector(sector + i, secBuf)) {
    3dbc:	ldr	r3, [r5, #0]
    3dbe:	mov	r2, r4
    3dc0:	ldr	r3, [r3, #32]
    3dc2:	add.w	r1, r6, r8
    3dc6:	mov	r0, r5
    3dc8:	blx	r3
    3dca:	cmp	r0, #0
    3dcc:	beq.n	3cfc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    3dce:	cmp.w	r8, #0
    3dd2:	bne.n	3de0 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x328>
      memset(secBuf, 0, BYTES_PER_SECTOR);
    3dd4:	mov.w	r2, #512	; 0x200
    3dd8:	mov	r1, r8
    3dda:	mov	r0, r4
    3ddc:	bl	90bc <memset>
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    secBuf[i] = 0XFF;
  }
  for (uint32_t i = 0; i < ns; i++) {
    3de0:	add.w	r8, r8, #1
    3de4:	cmp	sl, r8
    3de6:	bne.n	3da8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2f0>
    }
    if (i == 0) {
      memset(secBuf, 0, BYTES_PER_SECTOR);
    }
  }
  writeMsg(pr, "\r\n");
    3de8:	cbz	r7, 3df2 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x33a>
    3dea:	ldr	r1, [pc, #276]	; (3f00 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x448>)
    3dec:	mov	r0, r7
    3dee:	bl	734 <Print::write(char const*)>
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
    3df2:	ldr	r3, [sp, #8]
    3df4:	mov.w	r8, #1
    3df8:	lsl.w	r8, r8, r3
    }
  }
  writeMsg(pr, "\r\n");
  // Write cluster two, bitmap.
  sector = partitionOffset + clusterHeapOffset;
  bitmapSize = (clusterCount + 7)/8;
    3dfc:	ldr	r3, [sp, #12]
    3dfe:	add.w	sl, r3, #7
    3e02:	mov.w	sl, sl, lsr #3
  ns = (bitmapSize + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3e06:	addw	fp, sl, #511	; 0x1ff
    3e0a:	mov.w	fp, fp, lsr #9
  if (ns > sectorsPerCluster) {
    3e0e:	cmp	r8, fp
    3e10:	bcc.w	3cfc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3e14:	mov.w	r2, #512	; 0x200
    3e18:	movs	r1, #0
    3e1a:	mov	r0, r4
    3e1c:	bl	90bc <memset>
  // Allocate clusters for bitmap, upcase, and root.
  secBuf[0] = 0X7;
    3e20:	movs	r3, #7
    3e22:	strb	r3, [r4, #0]
  for (uint32_t i = 0; i < ns; i++) {
    3e24:	mov.w	r9, #0
    if (!dev->writeSector(sector + i, secBuf)) {
    3e28:	ldr	r3, [r5, #0]
    3e2a:	ldr	r1, [sp, #16]
    3e2c:	ldr	r3, [r3, #32]
    3e2e:	mov	r2, r4
    3e30:	add	r1, r9
    3e32:	mov	r0, r5
    3e34:	blx	r3
    3e36:	cmp	r0, #0
    3e38:	beq.w	3cfc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    3e3c:	cmp.w	r9, #0
    3e40:	bne.n	3e46 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x38e>
      secBuf[0] = 0;
    3e42:	strb.w	r9, [r4]
    goto fail;
  }
  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate clusters for bitmap, upcase, and root.
  secBuf[0] = 0X7;
  for (uint32_t i = 0; i < ns; i++) {
    3e46:	add.w	r9, r9, #1
    3e4a:	cmp	fp, r9
    3e4c:	bne.n	3e28 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x370>
    if (i == 0) {
      secBuf[0] = 0;
    }
  }
  // Write cluster three, upcase table.
  writeMsg(pr, "Writing upcase table\r\n");
    3e4e:	cbz	r7, 3e58 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3a0>
    3e50:	ldr	r1, [pc, #176]	; (3f04 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x44c>)
    3e52:	mov	r0, r7
    3e54:	bl	734 <Print::write(char const*)>
  if (!writeUpcase(partitionOffset + clusterHeapOffset + sectorsPerCluster)) {
    3e58:	ldr	r3, [sp, #0]
    3e5a:	ldr	r0, [sp, #4]
    3e5c:	add	r3, r6
    3e5e:	add.w	r9, r3, r8
    3e62:	mov	r1, r9
    3e64:	bl	3a26 <ExFatFormatter::writeUpcase(unsigned long)>
    3e68:	cmp	r0, #0
    3e6a:	beq.w	3cfc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_upcaseSize > BYTES_PER_SECTOR*sectorsPerCluster) {
    3e6e:	ldr	r3, [sp, #4]
    3e70:	ldr	r3, [r3, #8]
    3e72:	cmp.w	r3, r8, lsl #9
    3e76:	bhi.w	3cfc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Initialize first sector of root.
  writeMsg(pr, "Writing root\r\n");
    3e7a:	cbz	r7, 3e84 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3cc>
    3e7c:	ldr	r1, [pc, #136]	; (3f08 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x450>)
    3e7e:	mov	r0, r7
    3e80:	bl	734 <Print::write(char const*)>
  ns = sectorsPerCluster;
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3e84:	mov.w	r2, #512	; 0x200
    3e88:	movs	r1, #0
    3e8a:	mov	r0, r4
    3e8c:	bl	90bc <memset>
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;

  // bitmap directory entry.
  dbm = reinterpret_cast<DirBitmap_t*>(secBuf + 32);
  dbm->type = EXFAT_TYPE_BITMAP;
    3e90:	movs	r2, #129	; 0x81
    3e92:	strb.w	r2, [r4, #32]
    3e96:	movs	r2, #2
    3e98:	str	r2, [r4, #52]	; 0x34
  setLe32(dbm->firstCluster, BITMAP_CLUSTER);
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
    3e9a:	movs	r2, #130	; 0x82
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);

  // Unused Label entry.
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;
    3e9c:	movs	r3, #3
  setLe32(dbm->firstCluster, BITMAP_CLUSTER);
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
    3e9e:	strb.w	r2, [r4, #64]	; 0x40
  setLe32(dup->checksum, m_upcaseChecksum);
    3ea2:	ldr	r2, [sp, #4]
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);

  // Unused Label entry.
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;
    3ea4:	strb	r3, [r4, #0]
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
  setLe32(dup->checksum, m_upcaseChecksum);
    3ea6:	ldr	r2, [r2, #4]
    3ea8:	str	r3, [r4, #84]	; 0x54
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    3eaa:	ldr	r3, [sp, #4]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3eac:	str	r2, [r4, #68]	; 0x44
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    3eae:	ldr	r3, [r3, #8]
    3eb0:	str.w	sl, [r4, #56]	; 0x38
    3eb4:	movs	r6, #0
    goto fail;
  }
  // Initialize first sector of root.
  writeMsg(pr, "Writing root\r\n");
  ns = sectorsPerCluster;
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
    3eb6:	add	r9, r8
    3eb8:	str	r3, [r4, #88]	; 0x58
    3eba:	str	r6, [r4, #92]	; 0x5c
  setLe32(dup->firstCluster, UPCASE_CLUSTER);
  setLe64(dup->size, m_upcaseSize);

  // Write root, cluster four.
  for (uint32_t i = 0; i < ns; i++) {
    if (!dev->writeSector(sector + i, secBuf)) {
    3ebc:	ldr	r3, [r5, #0]
    3ebe:	mov	r2, r4
    3ec0:	ldr	r3, [r3, #32]
    3ec2:	add.w	r1, r6, r9
    3ec6:	mov	r0, r5
    3ec8:	blx	r3
    3eca:	mov	sl, r0
    3ecc:	cmp	r0, #0
    3ece:	beq.w	3cfc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    3ed2:	cbnz	r6, 3ee0 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x428>
      memset(secBuf, 0, BYTES_PER_SECTOR);
    3ed4:	mov.w	r2, #512	; 0x200
    3ed8:	mov	r1, r6
    3eda:	mov	r0, r4
    3edc:	bl	90bc <memset>
  setLe32(dup->checksum, m_upcaseChecksum);
  setLe32(dup->firstCluster, UPCASE_CLUSTER);
  setLe64(dup->size, m_upcaseSize);

  // Write root, cluster four.
  for (uint32_t i = 0; i < ns; i++) {
    3ee0:	adds	r6, #1
    3ee2:	cmp	r8, r6
    3ee4:	bne.n	3ebc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x404>
    }
    if (i == 0) {
      memset(secBuf, 0, BYTES_PER_SECTOR);
    }
  }
  writeMsg(pr, "Format done\r\n");
    3ee6:	cbz	r7, 3ef0 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x438>
    3ee8:	ldr	r1, [pc, #32]	; (3f0c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x454>)
    3eea:	mov	r0, r7
    3eec:	bl	734 <Print::write(char const*)>
  return true;

 fail:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
    3ef0:	mov	r0, sl
    3ef2:	add	sp, #28
    3ef4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3ef8:	.word	0x00012d28
    3efc:	.word	0x00012d35
    3f00:	.word	0x00012da7
    3f04:	.word	0x00012d37
    3f08:	.word	0x00012d4e
    3f0c:	.word	0x00012d5d

00003f10 <ExFatFile::cmpName(DirName_t const*, ExName_t*)>:
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
  return hash;
}
//------------------------------------------------------------------------------
bool ExFatFile::cmpName(const DirName_t* dirName, ExName_t* fname) {
    3f10:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3f14:	mov	r5, r2
    3f16:	mov	r6, r1
    3f18:	add.w	r8, r1, #30
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    3f1c:	ldrh	r3, [r5, #12]
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    3f1e:	ldrh.w	r4, [r6, #2]!
    3f22:	cbnz	r3, 3f36 <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x26>
    3f24:	ldr	r2, [r5, #4]
    3f26:	ldr	r3, [r5, #8]
    3f28:	cmp	r2, r3
    3f2a:	bne.n	3f36 <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x26>
  for (uint8_t i = 0; i < 15; i++) {
    uint16_t u = getLe16(dirName->unicode + 2*i);
    if (fname->atEnd()) {
      return u == 0;
    3f2c:	clz	r0, r4
    3f30:	lsrs	r0, r0, #5
    3f32:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
#if USE_UTF8_LONG_NAMES
    uint16_t cp = fname->get16();
    3f36:	mov	r0, r5
    3f38:	bl	3958 <FsName::get16()>
    if (toUpcase(cp) != toUpcase(u)) {
    3f3c:	bl	38b4 <toUpcase(unsigned short)>
    3f40:	mov	r7, r0
    3f42:	mov	r0, r4
    3f44:	bl	38b4 <toUpcase(unsigned short)>
    3f48:	cmp	r7, r0
    3f4a:	bne.n	3f56 <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x46>
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
  return hash;
}
//------------------------------------------------------------------------------
bool ExFatFile::cmpName(const DirName_t* dirName, ExName_t* fname) {
  for (uint8_t i = 0; i < 15; i++) {
    3f4c:	cmp	r6, r8
    3f4e:	bne.n	3f1c <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0xc>
    if (u >= 0x7F || toUpper(c) != toUpper(u)) {
      return false;
    }
#endif  // USE_UTF8_LONG_NAMES
  }
  return true;
    3f50:	movs	r0, #1
    3f52:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return u == 0;
    }
#if USE_UTF8_LONG_NAMES
    uint16_t cp = fname->get16();
    if (toUpcase(cp) != toUpcase(u)) {
       return false;
    3f56:	movs	r0, #0
    3f58:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00003f5c <ExFatFile::getName8(char*, unsigned int)>:
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName8(char* name, size_t count) {
    3f5c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  char* str = name;
  char* ptr;
  DirName_t* dn;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    3f60:	ldrb.w	r3, [r0, #49]	; 0x31
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName8(char* name, size_t count) {
    3f64:	mov	sl, r0
    3f66:	mov	r9, r1
  char* str = name;
  char* ptr;
  DirName_t* dn;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    3f68:	cmp	r3, #0
    3f6a:	beq.n	3ffc <ExFatFile::getName8(char*, unsigned int)+0xa0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    3f6c:	add.w	r8, r2, #4294967295
    3f70:	mov	r5, r1
    3f72:	movs	r7, #2
    3f74:	movs	r4, #0
    3f76:	add	r8, r1
  uint32_t cp;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 2; is <= m_setCount; is++) {
    3f78:	ldrb.w	r3, [sl, #48]	; 0x30
    3f7c:	cmp	r3, r7
    3f7e:	bcc.n	3ff0 <ExFatFile::getName8(char*, unsigned int)+0x94>
    dn = reinterpret_cast<DirName_t*>
         (dirCache(is, FsCache::CACHE_FOR_READ));
    3f80:	movs	r2, #0
    3f82:	mov	r1, r7
    3f84:	mov	r0, sl
    3f86:	bl	406e <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
    3f8a:	cbz	r0, 3ffc <ExFatFile::getName8(char*, unsigned int)+0xa0>
    3f8c:	ldrb	r3, [r0, #0]
    3f8e:	cmp	r3, #193	; 0xc1
    3f90:	bne.n	3ffc <ExFatFile::getName8(char*, unsigned int)+0xa0>
    3f92:	mov	r6, r0
    3f94:	add.w	fp, r0, #30
    3f98:	mov	r3, r4
    3f9a:	ldrh.w	r4, [r6, #2]!
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
      uint16_t c = getLe16(dn->unicode + 2*in);
      if (hs) {
    3f9e:	cbz	r3, 3fbe <ExFatFile::getName8(char*, unsigned int)+0x62>
        if (!FsUtf::isLowSurrogate(c)) {
    3fa0:	add.w	r2, r4, #9216	; 0x2400
    3fa4:	uxth	r2, r2
    3fa6:	cmp.w	r2, #1024	; 0x400
    3faa:	bcs.n	3ffc <ExFatFile::getName8(char*, unsigned int)+0xa0>
   * \param[in] hs high surrogate.
   * \param[in] ls low surrogate.
   * \return code point.
   */
  inline uint32_t u16ToCp(uint16_t hs, uint16_t ls) {
    return 0X10000 + (((hs & 0X3FF) << 10) | (ls & 0X3FF));
    3fac:	ldr	r0, [pc, #88]	; (4008 <ExFatFile::getName8(char*, unsigned int)+0xac>)
    3fae:	lsls	r3, r3, #10
    3fb0:	ands	r0, r3
    3fb2:	ubfx	r4, r4, #0, #10
    3fb6:	orrs	r4, r0
    3fb8:	add.w	r0, r4, #65536	; 0x10000
    3fbc:	b.n	3fd8 <ExFatFile::getName8(char*, unsigned int)+0x7c>
  /** Check for UTF-16 surrogate.
   * \param[in] c UTF-16 unit.
   * \return true if c is a surrogate else false.
   */
  inline bool isSurrogate(uint16_t c) {
    return 0XD800 <= c && c <= 0XDFFF;
    3fbe:	add.w	r3, r4, #10240	; 0x2800
    3fc2:	uxth	r3, r3
          DBG_FAIL_MACRO;
          goto fail;
        }
        cp = FsUtf::u16ToCp(hs, c);
        hs = 0;
      } else if (!FsUtf::isSurrogate(c)) {
    3fc4:	cmp.w	r3, #2048	; 0x800
    3fc8:	bcc.n	3fd0 <ExFatFile::getName8(char*, unsigned int)+0x74>
        if (c == 0) {
    3fca:	cbz	r4, 3ff0 <ExFatFile::getName8(char*, unsigned int)+0x94>
          goto done;
        }
        cp = c;
    3fcc:	mov	r0, r4
    3fce:	b.n	3fd8 <ExFatFile::getName8(char*, unsigned int)+0x7c>
      } else if (FsUtf::isHighSurrogate(c)) {
    3fd0:	cmp.w	r3, #1024	; 0x400
    3fd4:	bcc.n	3fe6 <ExFatFile::getName8(char*, unsigned int)+0x8a>
    3fd6:	b.n	3ffc <ExFatFile::getName8(char*, unsigned int)+0xa0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    3fd8:	mov	r2, r8
    3fda:	mov	r1, r5
    3fdc:	bl	34c4 <FsUtf::cpToMb(unsigned long, char*, char*)>
      if (!ptr) {
    3fe0:	cbz	r0, 3ff0 <ExFatFile::getName8(char*, unsigned int)+0x94>
    3fe2:	mov	r5, r0
    3fe4:	movs	r4, #0
         (dirCache(is, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
    3fe6:	cmp	fp, r6
    3fe8:	bne.n	3f98 <ExFatFile::getName8(char*, unsigned int)+0x3c>
  uint32_t cp;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 2; is <= m_setCount; is++) {
    3fea:	adds	r7, #1
    3fec:	uxtb	r7, r7
    3fee:	b.n	3f78 <ExFatFile::getName8(char*, unsigned int)+0x1c>
      }
      str = ptr;
    }
  }
 done:
  *str = '\0';
    3ff0:	movs	r3, #0
    3ff2:	strb	r3, [r5, #0]
  return str - name;
    3ff4:	rsb	r0, r9, r5
    3ff8:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

 fail:
  *name = 0;
    3ffc:	movs	r0, #0
    3ffe:	strb.w	r0, [r9]
  return 0;
}
    4002:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4006:	nop
    4008:	.word	0x000ffc00

0000400c <ExFatFile::hashName(ExName_t*)>:
//------------------------------------------------------------------------------
bool ExFatFile::hashName(ExName_t* fname) {
    400c:	push	{r4, r5, r6, lr}
  }
  void reset() {
    next = begin;
    400e:	ldr	r3, [r1, #0]
    4010:	str	r3, [r1, #4]
    ls = 0;
    4012:	movs	r4, #0
    4014:	mov	r5, r1
    4016:	strh	r4, [r1, #12]
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
    4018:	str	r4, [r1, #16]
  while (!fname->atEnd()) {
    uint16_t u = fname->get16();
    if (u == 0XFFFF) {
    401a:	movw	r6, #65535	; 0xffff
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    401e:	ldrh	r3, [r5, #12]
    4020:	cbnz	r3, 402a <ExFatFile::hashName(ExName_t*)+0x1e>
    4022:	ldr	r2, [r5, #4]
    4024:	ldr	r3, [r5, #8]
    4026:	cmp	r2, r3
    4028:	beq.n	405e <ExFatFile::hashName(ExName_t*)+0x52>
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
  while (!fname->atEnd()) {
    uint16_t u = fname->get16();
    402a:	mov	r0, r5
    402c:	bl	3958 <FsName::get16()>
    if (u == 0XFFFF) {
    4030:	cmp	r0, r6
    4032:	beq.n	405a <ExFatFile::hashName(ExName_t*)+0x4e>
  hash = ((hash << 15) | (hash >> 1));
  return hash;
}
//------------------------------------------------------------------------------
inline uint16_t exFatHash(uint16_t u, uint16_t hash) {
  uint16_t c = toUpcase(u);
    4034:	bl	38b4 <toUpcase(unsigned short)>
    4038:	lsls	r3, r4, #15
    403a:	orr.w	r4, r3, r4, lsr #1
    403e:	uxtab	r4, r4, r0
    4042:	ubfx	r3, r4, #1, #15
    4046:	orr.w	r3, r3, r4, lsl #15
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
    404a:	asrs	r4, r0, #8
    404c:	uxtah	r4, r4, r3
    if (u == 0XFFFF) {
    DBG_FAIL_MACRO;
      goto fail;
    }
    hash = exFatHash(u, hash);
    fname->nameLength++;
    4050:	ldr	r3, [r5, #16]
    4052:	adds	r3, #1
}
//------------------------------------------------------------------------------
inline uint16_t exFatHash(uint16_t u, uint16_t hash) {
  uint16_t c = toUpcase(u);
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
    4054:	uxth	r4, r4
    if (u == 0XFFFF) {
    DBG_FAIL_MACRO;
      goto fail;
    }
    hash = exFatHash(u, hash);
    fname->nameLength++;
    4056:	str	r3, [r5, #16]
bool ExFatFile::hashName(ExName_t* fname) {
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
  while (!fname->atEnd()) {
    4058:	b.n	401e <ExFatFile::hashName(ExName_t*)+0x12>
    goto fail;
  }
  return true;

 fail:
  return false;
    405a:	movs	r0, #0
    405c:	pop	{r4, r5, r6, pc}
    hash = exFatHash(c, hash);
  }
  fname->nameLength = fname->end - fname->begin;
#endif  // USE_UTF8_LONG_NAMES
  fname->nameHash = hash;
  if (!fname->nameLength || fname->nameLength > EXFAT_MAX_NAME_LENGTH) {
    405e:	ldr	r0, [r5, #16]
    char c = fname->getch();
    hash = exFatHash(c, hash);
  }
  fname->nameLength = fname->end - fname->begin;
#endif  // USE_UTF8_LONG_NAMES
  fname->nameHash = hash;
    4060:	strh	r4, [r5, #20]
  if (!fname->nameLength || fname->nameLength > EXFAT_MAX_NAME_LENGTH) {
    4062:	subs	r0, #1
    4064:	cmp	r0, #254	; 0xfe
    4066:	ite	hi
    4068:	movhi	r0, #0
    406a:	movls	r0, #1
  }
  return true;

 fail:
  return false;
}
    406c:	pop	{r4, r5, r6, pc}

0000406e <ExFatFile::dirCache(unsigned char, unsigned char)>:
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    406e:	push	{r4, r5, r6, r7, lr}
  DirPos_t pos = m_dirPos;
    4070:	add.w	r3, r0, #36	; 0x24
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    4074:	mov	r5, r0
    4076:	mov	r7, r1
    4078:	mov	r6, r2
  DirPos_t pos = m_dirPos;
    407a:	ldmia.w	r3, {r0, r1, r2}
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    407e:	sub	sp, #20
  DirPos_t pos = m_dirPos;
    4080:	add	r4, sp, #4
    4082:	stmia.w	r4, {r0, r1, r2}
  if (m_vol->dirSeek(&pos, 32*set) != 1) {
    4086:	lsls	r2, r7, #5
    4088:	mov	r1, r4
    408a:	ldr	r0, [r5, #32]
    408c:	bl	4a4c <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    4090:	cmp	r0, #1
    4092:	bne.n	40a0 <ExFatFile::dirCache(unsigned char, unsigned char)+0x32>
    return nullptr;
  }
  return m_vol->dirCache(&pos, options);
    4094:	mov	r2, r6
    4096:	mov	r1, r4
    4098:	ldr	r0, [r5, #32]
    409a:	bl	49ae <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    409e:	b.n	40a2 <ExFatFile::dirCache(unsigned char, unsigned char)+0x34>
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
  DirPos_t pos = m_dirPos;
  if (m_vol->dirSeek(&pos, 32*set) != 1) {
    return nullptr;
    40a0:	movs	r0, #0
  }
  return m_vol->dirCache(&pos, options);
}
    40a2:	add	sp, #20
    40a4:	pop	{r4, r5, r6, r7, pc}

000040a6 <ExFatFile::close()>:
//------------------------------------------------------------------------------
bool ExFatFile::close() {
    40a6:	push	{r4, lr}
    40a8:	mov	r4, r0
  bool rtn = sync();
    40aa:	bl	4f64 <ExFatFile::sync()>
  m_attributes = FILE_ATTR_CLOSED;
    40ae:	movs	r3, #0
    40b0:	strb.w	r3, [r4, #49]	; 0x31
  m_flags = 0;
    40b4:	strb.w	r3, [r4, #51]	; 0x33
  return rtn;
}
    40b8:	pop	{r4, pc}

000040ba <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    40ba:	push	{r3, r4, r5, lr}
    40bc:	mov	r5, r1
    40be:	mov	r4, r2
  DirFile_t* df = reinterpret_cast<DirFile_t*>
                 (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_READ));
    40c0:	add.w	r1, r0, #36	; 0x24
    40c4:	movs	r2, #0
    40c6:	ldr	r0, [r0, #32]
    40c8:	bl	49ae <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    40cc:	cbz	r0, 40d8 <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)+0x1e>
    40ce:	ldrh	r3, [r0, #10]
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(df->createDate);
    40d0:	strh	r3, [r5, #0]
    40d2:	ldrh	r3, [r0, #8]
  *ptime = getLe16(df->createTime);
    40d4:	strh	r3, [r4, #0]
  return true;
    40d6:	movs	r0, #1

 fail:
  return false;
}
    40d8:	pop	{r3, r4, r5, pc}

000040da <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)>:
//------------------------------------------------------------------------------
bool ExFatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    40da:	push	{r3, r4, r5, lr}
    40dc:	mov	r5, r1
    40de:	mov	r4, r2
  DirFile_t* df = reinterpret_cast<DirFile_t*>
                 (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_READ));
    40e0:	add.w	r1, r0, #36	; 0x24
    40e4:	movs	r2, #0
    40e6:	ldr	r0, [r0, #32]
    40e8:	bl	49ae <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    40ec:	cbz	r0, 40f8 <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)+0x1e>
    40ee:	ldrh	r3, [r0, #14]
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(df->modifyDate);
    40f0:	strh	r3, [r5, #0]
    40f2:	ldrh	r3, [r0, #12]
  *ptime = getLe16(df->modifyTime);
    40f4:	strh	r3, [r4, #0]
  return true;
    40f6:	movs	r0, #1

 fail:
  return false;
}
    40f8:	pop	{r3, r4, r5, pc}

000040fa <ExFatFile::openRoot(ExFatVolume*)>:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
    40fa:	push	{r3, r4, r5, lr}
    40fc:	mov	r5, r1
  if (isOpen()) {
    40fe:	ldrb.w	r1, [r0, #49]	; 0x31
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
    4102:	mov	r4, r0
  if (isOpen()) {
    4104:	cbnz	r1, 411c <ExFatFile::openRoot(ExFatVolume*)+0x22>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    4106:	movs	r2, #56	; 0x38
    4108:	bl	90bc <memset>
  m_attributes = FILE_ATTR_ROOT;
    410c:	movs	r3, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    410e:	movs	r0, #1
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
    4110:	strb.w	r3, [r4, #49]	; 0x31
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    4114:	strb.w	r0, [r4, #51]	; 0x33
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
    4118:	str	r5, [r4, #32]
    411a:	pop	{r3, r4, r5, pc}
  m_flags = FILE_FLAG_READ;
  return true;

 fail:
  return false;
    411c:	movs	r0, #0
}
    411e:	pop	{r3, r4, r5, pc}

00004120 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>:
//------------------------------------------------------------------------------
bool ExFatFile::parsePathName(const char* path,
                            ExName_t* fname, const char** ptr) {
    4120:	push	{r4, r5, r6, r7}
  // Skip leading spaces.
  while (*path == ' ') {
    4122:	ldrb	r4, [r1, #0]
    4124:	cmp	r4, #32
    4126:	add.w	r5, r1, #1
    412a:	bne.n	4130 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x10>
    412c:	mov	r1, r5
    412e:	b.n	4122 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x2>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    4130:	ldr	r7, [pc, #100]	; (4198 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x78>)
    path++;
  }
  fname->begin = path;
    4132:	str	r1, [r2, #0]
  fname->end = path;
    4134:	str	r1, [r2, #8]
  while (*path && !isDirSeparator(*path)) {
    4136:	mov	r5, r1
    4138:	mov	r6, r1
    413a:	ldrb.w	r4, [r5], #1
    413e:	cbz	r4, 4178 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x58>
    4140:	cmp	r4, #47	; 0x2f
    4142:	beq.n	416c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x4c>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    4144:	cmp	r4, #31
    4146:	bls.n	4192 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    4148:	sub.w	r1, r4, #34	; 0x22
    414c:	uxtb	r1, r1
    414e:	cmp	r1, #29
    4150:	bhi.n	415a <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x3a>
    4152:	lsr.w	r1, r7, r1
    4156:	lsls	r1, r1, #31
    4158:	bmi.n	4192 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    415a:	and.w	r1, r4, #191	; 0xbf
    415e:	cmp	r1, #60	; 0x3c
    4160:	beq.n	4192 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
    4162:	cmp	r4, #92	; 0x5c
    4164:	bne.n	4182 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    4166:	b.n	4192 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
      // Need to trim trailing dots spaces.
      fname->end = path;
    }
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
    4168:	cmp	r4, #47	; 0x2f
    416a:	bne.n	4178 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x58>
    416c:	mov	r6, r1
    416e:	ldrb.w	r4, [r1], #1
    4172:	cmp	r4, #32
    4174:	bne.n	4168 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x48>
    4176:	b.n	416c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x4c>
  *ptr = path;
    4178:	str	r6, [r3, #0]
  return hashName(fname);
    417a:	mov	r1, r2

 fail:
  return false;
}
    417c:	pop	{r4, r5, r6, r7}
    }
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
  *ptr = path;
  return hashName(fname);
    417e:	b.w	400c <ExFatFile::hashName(ExName_t*)>
    uint8_t c = *path++;
    if (!lfnLegalChar(c)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (c != '.' && c != ' ') {
    4182:	cmp	r4, #46	; 0x2e
    4184:	bne.n	418a <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x6a>
    4186:	mov	r1, r5
    4188:	b.n	4136 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x16>
    418a:	cmp	r4, #32
    418c:	beq.n	4186 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x66>
      // Need to trim trailing dots spaces.
      fname->end = path;
    418e:	str	r5, [r2, #8]
    4190:	b.n	4186 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x66>
  *ptr = path;
  return hashName(fname);

 fail:
  return false;
}
    4192:	movs	r0, #0
    4194:	pop	{r4, r5, r6, r7}
    4196:	bx	lr
    4198:	.word	0x31000101

0000419c <ExFatFile::read(void*, unsigned int)>:
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    419c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    41a0:	ldrb.w	r3, [r0, #51]	; 0x33
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    41a4:	lsls	r7, r3, #31
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    41a6:	mov	r4, r0
    41a8:	mov	r6, r1
    41aa:	mov	r5, r2
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    41ac:	bpl.n	429e <ExFatFile::read(void*, unsigned int)+0x102>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isContiguous() || isFile()) {
    41ae:	lsls	r0, r3, #25
    41b0:	bmi.n	41ba <ExFatFile::read(void*, unsigned int)+0x1e>
    41b2:	ldrb.w	r3, [r4, #49]	; 0x31
    41b6:	lsls	r1, r3, #28
    41b8:	bpl.n	41d4 <ExFatFile::read(void*, unsigned int)+0x38>
    if ((m_curPosition + count) > m_validLength) {
    41ba:	ldrd	r0, r1, [r4]
    41be:	ldrd	r2, r3, [r4, #16]
    41c2:	adds.w	r8, r0, r5
    41c6:	adc.w	r9, r1, #0
    41ca:	cmp	r3, r9
    41cc:	it	eq
    41ce:	cmpeq	r2, r8
    41d0:	bcs.n	41d4 <ExFatFile::read(void*, unsigned int)+0x38>
      count = toRead = m_validLength - m_curPosition;
    41d2:	subs	r5, r2, r0
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    41d4:	mov	r9, r5
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
      } else if (isContiguous()) {
        m_curCluster++;
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    41d6:	add.w	sl, r4, #24
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    41da:	cmp.w	r9, #0
    41de:	beq.n	4268 <ExFatFile::read(void*, unsigned int)+0xcc>
    clusterOffset = m_curPosition & m_vol->clusterMask();
    41e0:	ldr	r0, [r4, #32]
    41e2:	ldrd	r2, r3, [r4]
    41e6:	ldr.w	r1, [r0, #1080]	; 0x438
    41ea:	and.w	r8, r1, r2
    sectorOffset = clusterOffset & m_vol->sectorMask();
    41ee:	ubfx	fp, r8, #0, #9
    if (clusterOffset == 0) {
    41f2:	cmp.w	r8, #0
    41f6:	bne.n	4236 <ExFatFile::read(void*, unsigned int)+0x9a>
      if (m_curPosition == 0) {
    41f8:	orrs	r3, r2
    41fa:	bne.n	420c <ExFatFile::read(void*, unsigned int)+0x70>
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
    41fc:	ldrb.w	r3, [r4, #49]	; 0x31
    4200:	lsls	r2, r3, #25
    4202:	ite	mi
    4204:	ldrmi.w	r3, [r0, #1076]	; 0x434
    4208:	ldrpl	r3, [r4, #28]
    420a:	b.n	4218 <ExFatFile::read(void*, unsigned int)+0x7c>
      } else if (isContiguous()) {
    420c:	ldrb.w	r3, [r4, #51]	; 0x33
    4210:	lsls	r3, r3, #25
    4212:	bpl.n	421c <ExFatFile::read(void*, unsigned int)+0x80>
        m_curCluster++;
    4214:	ldr	r3, [r4, #24]
    4216:	adds	r3, #1
    4218:	str	r3, [r4, #24]
    421a:	b.n	4236 <ExFatFile::read(void*, unsigned int)+0x9a>
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    421c:	mov	r2, sl
    421e:	ldr	r1, [r4, #24]
    4220:	bl	49e4 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
        if (fg < 0) {
    4224:	cmp	r0, #0
    4226:	blt.n	429e <ExFatFile::read(void*, unsigned int)+0x102>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
    4228:	bne.n	4236 <ExFatFile::read(void*, unsigned int)+0x9a>
          // EOF if directory.
          if (isDir()) {
    422a:	ldrb.w	r3, [r4, #49]	; 0x31
    422e:	tst.w	r3, #80	; 0x50
    4232:	bne.n	4268 <ExFatFile::read(void*, unsigned int)+0xcc>
    4234:	b.n	429e <ExFatFile::read(void*, unsigned int)+0x102>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
    4236:	ldr	r7, [r4, #32]
             (clusterOffset >> m_vol->bytesPerSectorShift());
    4238:	ldr	r1, [r4, #24]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    423a:	ldrb.w	lr, [r7, #1093]	; 0x445
    423e:	ldr.w	r0, [r7, #1068]	; 0x42c
    4242:	subs	r1, #2
    4244:	lsl.w	r1, r1, lr
    4248:	mov.w	r2, r8, lsr #9
    424c:	add	r1, r0
    424e:	add.w	r8, r1, r2
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
    4252:	cmp.w	fp, #0
    4256:	bne.n	42f8 <ExFatFile::read(void*, unsigned int)+0x15c>
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
    4258:	cmp.w	r9, #512	; 0x200
    425c:	bcc.n	42f8 <ExFatFile::read(void*, unsigned int)+0x15c>
    425e:	ldr.w	r1, [r7, #540]	; 0x21c
                          || sector == m_vol->dataCacheSector()) {
    4262:	cmp	r8, r1
    4264:	bne.n	4270 <ExFatFile::read(void*, unsigned int)+0xd4>
    4266:	b.n	42f8 <ExFatFile::read(void*, unsigned int)+0x15c>
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return count - toRead;
    4268:	rsb	r0, r9, r5
    426c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    4270:	cmp.w	r9, #1024	; 0x400
    4274:	bcc.n	42cc <ExFatFile::read(void*, unsigned int)+0x130>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      // Limit reads to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    4276:	movs	r3, #1
    4278:	lsl.w	r3, r3, lr
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    427c:	mov.w	fp, r9, lsr #9
      // Limit reads to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    4280:	subs	r2, r3, r2
    4282:	cmp	fp, r2
    4284:	it	cs
    4286:	movcs	fp, r2
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    4288:	cmp	r8, r1
    428a:	bhi.n	42b2 <ExFatFile::read(void*, unsigned int)+0x116>
    428c:	add.w	r3, fp, r8
    4290:	cmp	r1, r3
    4292:	bcs.n	42b2 <ExFatFile::read(void*, unsigned int)+0x116>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    4294:	add.w	r0, r7, #528	; 0x210
    4298:	bl	381a <FsCache::sync()>
    429c:	cbnz	r0, 42b2 <ExFatFile::read(void*, unsigned int)+0x116>
    toRead -= n;
  }
  return count - toRead;

 fail:
  m_error |= READ_ERROR;
    429e:	ldrb.w	r3, [r4, #50]	; 0x32
    42a2:	orr.w	r3, r3, #2
    42a6:	strb.w	r3, [r4, #50]	; 0x32
  return -1;
    42aa:	mov.w	r0, #4294967295
    42ae:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    42b2:	ldr.w	r0, [r7, #532]	; 0x214
    42b6:	ldr	r3, [r0, #0]
    42b8:	mov	r2, r6
    42ba:	ldr	r7, [r3, #16]
    42bc:	mov	r1, r8
    42be:	mov	r3, fp
    42c0:	blx	r7
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
     if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    42c2:	cmp	r0, #0
    42c4:	beq.n	429e <ExFatFile::read(void*, unsigned int)+0x102>
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    42c6:	mov.w	r7, fp, lsl #9
    42ca:	b.n	42e2 <ExFatFile::read(void*, unsigned int)+0x146>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    42cc:	ldr.w	r0, [r7, #532]	; 0x214
    42d0:	ldr	r3, [r0, #0]
    42d2:	mov	r2, r6
    42d4:	ldr	r3, [r3, #12]
    42d6:	mov	r1, r8
    42d8:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    42da:	cmp	r0, #0
    42dc:	beq.n	429e <ExFatFile::read(void*, unsigned int)+0x102>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    42de:	mov.w	r7, #512	; 0x200
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    42e2:	ldrd	r2, r3, [r4]
    42e6:	adds	r2, r2, r7
    42e8:	adc.w	r3, r3, #0
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    42ec:	add	r6, r7
    m_curPosition += n;
    42ee:	strd	r2, r3, [r4]
    toRead -= n;
    42f2:	rsb	r9, r7, r9
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    42f6:	b.n	41da <ExFatFile::read(void*, unsigned int)+0x3e>
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    42f8:	movs	r2, #0
    42fa:	mov	r1, r8
    42fc:	add.w	r0, r7, #528	; 0x210
    4300:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      cache = m_vol->dataCacheGet(sector, FsCache::CACHE_FOR_READ);
      if (!cache) {
    4304:	cmp	r0, #0
    4306:	beq.n	429e <ExFatFile::read(void*, unsigned int)+0x102>
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
      n = m_vol->bytesPerSector() - sectorOffset;
    4308:	rsb	r7, fp, #512	; 0x200
    430c:	cmp	r7, r9
    430e:	it	cs
    4310:	movcs	r7, r9
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
    4312:	add.w	r1, r0, fp
    4316:	mov	r2, r7
    4318:	mov	r0, r6
    431a:	bl	8f14 <memcpy>
    431e:	b.n	42e2 <ExFatFile::read(void*, unsigned int)+0x146>

00004320 <ExFatFile::peek()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int ExFatFile::peek() {
    4320:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    4322:	movs	r2, #1
    4324:	add.w	r1, sp, #7
    4328:	mov	r4, r0
  uint64_t curPosition = m_curPosition;
    432a:	ldrd	r6, r7, [r0]
  uint32_t curCluster = m_curCluster;
    432e:	ldr	r5, [r0, #24]
    4330:	bl	419c <ExFatFile::read(void*, unsigned int)>
    4334:	cmp	r0, #1
    4336:	it	eq
    4338:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
  m_curCluster = curCluster;
    433c:	str	r5, [r4, #24]
    433e:	it	ne
    4340:	movne.w	r0, #4294967295
//------------------------------------------------------------------------------
int ExFatFile::peek() {
  uint64_t curPosition = m_curPosition;
  uint32_t curCluster = m_curCluster;
  int c = read();
  m_curPosition = curPosition;
    4344:	strd	r6, r7, [r4]
  m_curCluster = curCluster;
  return c;
}
    4348:	add	sp, #12
    434a:	pop	{r4, r5, r6, r7, pc}

0000434c <ExFatFile::seekSet(unsigned long long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    434c:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4350:	ldrb.w	fp, [r0, #49]	; 0x31
    4354:	mov	r7, r3
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    4356:	ldr	r3, [r0, #24]
    4358:	str	r3, [sp, #4]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    435a:	mov	r4, r0
    435c:	mov	r6, r2
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    435e:	cmp.w	fp, #0
    4362:	beq.n	440c <ExFatFile::seekSet(unsigned long long)+0xc0>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    4364:	ldrd	r8, r9, [r0]
    4368:	cmp	r9, r7
    436a:	it	eq
    436c:	cmpeq	r8, r2
    436e:	beq.n	4414 <ExFatFile::seekSet(unsigned long long)+0xc8>
    return true;
  }
  if (pos == 0) {
    4370:	orrs.w	r3, r6, r7
    4374:	bne.n	437c <ExFatFile::seekSet(unsigned long long)+0x30>
    // set position to start of file
    m_curCluster = 0;
    4376:	movs	r3, #0
    4378:	str	r3, [r0, #24]
    goto done;
    437a:	b.n	4406 <ExFatFile::seekSet(unsigned long long)+0xba>
  }
  if (isFile()) {
    437c:	tst.w	fp, #8
    4380:	beq.n	438e <ExFatFile::seekSet(unsigned long long)+0x42>
    if (pos > m_validLength) {
    4382:	ldrd	r0, r1, [r0, #16]
    4386:	cmp	r1, r7
    4388:	it	eq
    438a:	cmpeq	r0, r2
    438c:	bcc.n	440c <ExFatFile::seekSet(unsigned long long)+0xc0>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    438e:	ldr	r3, [r4, #32]
    4390:	str	r3, [sp, #0]
    4392:	ldrb.w	sl, [r3, #1093]	; 0x445
    4396:	add.w	sl, sl, #9
    439a:	adds.w	r0, r6, #4294967295
    439e:	uxtb.w	sl, sl
    43a2:	mov	r2, sl
    43a4:	adc.w	r1, r7, #4294967295
    43a8:	bl	a530 <__aeabi_llsr>
  if (isContiguous()) {
    43ac:	ldrb.w	r2, [r4, #51]	; 0x33
    43b0:	lsls	r3, r2, #25
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    43b2:	mov	r5, r0
  if (isContiguous()) {
    43b4:	bpl.n	43be <ExFatFile::seekSet(unsigned long long)+0x72>
    m_curCluster = m_firstCluster + nNew;
    43b6:	ldr	r3, [r4, #28]
    43b8:	add	r5, r3
    43ba:	str	r5, [r4, #24]
    goto done;
    43bc:	b.n	4406 <ExFatFile::seekSet(unsigned long long)+0xba>
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
    43be:	adds.w	r0, r8, #4294967295
    43c2:	adc.w	r1, r9, #4294967295
    43c6:	mov	r2, sl
    43c8:	bl	a530 <__aeabi_llsr>
  if (nNew < nCur || m_curPosition == 0) {
    43cc:	cmp	r5, r0
    43ce:	bcc.n	43d6 <ExFatFile::seekSet(unsigned long long)+0x8a>
    43d0:	orrs.w	r3, r8, r9
    43d4:	bne.n	43ec <ExFatFile::seekSet(unsigned long long)+0xa0>
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
    43d6:	tst.w	fp, #64	; 0x40
    43da:	itet	ne
    43dc:	ldrne	r3, [sp, #0]
    43de:	ldreq	r3, [r4, #28]
    43e0:	ldrne.w	r3, [r3, #1076]	; 0x434
    43e4:	str	r3, [r4, #24]
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    43e6:	add.w	r8, r4, #24
    43ea:	b.n	4402 <ExFatFile::seekSet(unsigned long long)+0xb6>
  if (nNew < nCur || m_curPosition == 0) {
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    43ec:	subs	r5, r5, r0
    43ee:	b.n	43e6 <ExFatFile::seekSet(unsigned long long)+0x9a>
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    43f0:	mov	r2, r8
    43f2:	ldr	r1, [r4, #24]
    43f4:	ldr	r0, [r4, #32]
    43f6:	bl	49e4 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    43fa:	cmp	r0, #0
    43fc:	add.w	r5, r5, #4294967295
    4400:	ble.n	440c <ExFatFile::seekSet(unsigned long long)+0xc0>
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    4402:	cmp	r5, #0
    4404:	bne.n	43f0 <ExFatFile::seekSet(unsigned long long)+0xa4>
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    4406:	strd	r6, r7, [r4]
    440a:	b.n	4414 <ExFatFile::seekSet(unsigned long long)+0xc8>
  return true;

 fail:
  m_curCluster = tmp;
    440c:	ldr	r3, [sp, #4]
    440e:	str	r3, [r4, #24]
  return false;
    4410:	movs	r0, #0
    4412:	b.n	4416 <ExFatFile::seekSet(unsigned long long)+0xca>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    4414:	movs	r0, #1
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    4416:	add	sp, #12
    4418:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000441c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openPrivate(ExFatFile* dir, ExName_t* fname, oflag_t oflag) {
    441c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4420:	mov	sl, r3
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
  bool inSet = false;

  // error if already open, no access mode, or no directory.
  if (isOpen() || !dir->isDir()) {
    4422:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openPrivate(ExFatFile* dir, ExName_t* fname, oflag_t oflag) {
    4426:	sub	sp, #52	; 0x34
    4428:	mov	r4, r0
    442a:	mov	r6, r1
    442c:	mov	r5, r2
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
  bool inSet = false;

  // error if already open, no access mode, or no directory.
  if (isOpen() || !dir->isDir()) {
    442e:	cbnz	r3, 448e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    4430:	ldrb.w	r3, [r1, #49]	; 0x31
    4434:	tst.w	r3, #80	; 0x50
    4438:	beq.n	448e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    DBG_FAIL_MACRO;
    goto fail;
  }

  switch (oflag & O_ACCMODE) {
    443a:	and.w	r3, sl, #3
    443e:	cmp	r3, #1
    4440:	beq.w	4748 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x32c>
    4444:	cmp	r3, #2
    4446:	bne.w	473e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x322>
      break;
    case O_WRONLY:
      modeFlags = FILE_FLAG_WRITE;
      break;
    case O_RDWR:
      modeFlags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    444a:	movs	r3, #3
      break;
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
    444c:	and.w	r9, sl, #8
    4450:	orr.w	r9, r9, r3

  if (fname) {
    4454:	cbz	r5, 449a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x7e>
    freeNeed = 2 + (fname->nameLength + 14)/15;
    4456:	ldr	r3, [r5, #16]
    4458:	mov.w	r8, #15
    445c:	adds	r3, #14
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    445e:	movs	r2, #0
    4460:	udiv	r8, r3, r8
    4464:	mov	r0, r6
    4466:	add.w	r8, r8, #2
    446a:	movs	r3, #0
    446c:	uxtb.w	r8, r8
    4470:	bl	434c <ExFatFile::seekSet(unsigned long long)>
        }
        // Likely openNext call.
        DBG_WARN_MACRO;
        goto fail;
      }
      inSet = false;
    4474:	mov.w	fp, #0
    4478:	mov	r7, fp
    freeNeed = 2 + (fname->nameLength + 14)/15;
    dir->rewind();
  }

  while (1) {
    n = dir->read(buf, 32);
    447a:	movs	r2, #32
    447c:	add	r1, sp, #16
    447e:	mov	r0, r6
    4480:	bl	419c <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    4484:	cmp	r0, #0
    4486:	beq.w	4602 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1e6>
      goto create;
    }
    if (n != 32) {
    448a:	cmp	r0, #32
    448c:	beq.n	44a0 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x84>
  return sync();
#endif  // READ_ONLY

 fail:
  // close file
  m_attributes = FILE_ATTR_CLOSED;
    448e:	movs	r0, #0
    4490:	strb.w	r0, [r4, #49]	; 0x31
  m_flags = 0;
    4494:	strb.w	r0, [r4, #51]	; 0x33
  return false;
    4498:	b.n	4760 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
  DirFile_t*   dirFile;
  DirStream_t* dirStream;
  DirName_t*   dirName;
  uint8_t buf[32];
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
    449a:	mov.w	r8, #3
    449e:	b.n	4474 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x58>
    }
    if (n != 32) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(buf[0] & 0x80)) {
    44a0:	ldrb.w	r2, [sp, #16]
    44a4:	lsls	r1, r2, #24
    44a6:	bmi.n	44cc <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xb0>
      // Unused entry.
      if (freeCount == 0) {
    44a8:	cbnz	r7, 44b4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x98>
        freePos.position = dir->curPosition() - 32;
    44aa:	ldr	r3, [r6, #0]
    44ac:	subs	r3, #32
    44ae:	str	r3, [sp, #4]
    44b0:	ldr	r3, [r6, #24]
    44b2:	str	r3, [sp, #0]
        freePos.cluster = dir->curCluster();
      }
      if (freeCount < freeNeed) {
    44b4:	cmp	r7, r8
        freeCount++;
    44b6:	itt	cc
    44b8:	addcc	r7, #1
    44ba:	uxtbcc	r7, r7
      }
      if (!buf[0]) {
    44bc:	cbz	r2, 44c4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa8>
      }
      if (fname->atEnd()) {
        goto found;
      }
    } else {
      inSet = false;
    44be:	mov.w	fp, #0
    44c2:	b.n	447a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
      }
      if (freeCount < freeNeed) {
        freeCount++;
      }
      if (!buf[0]) {
        if (fname) {
    44c4:	cmp	r5, #0
    44c6:	bne.w	4602 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1e6>
    44ca:	b.n	448e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
        // Likely openNext call.
        DBG_WARN_MACRO;
        goto fail;
      }
      inSet = false;
    } else if (!inSet) {
    44cc:	cmp.w	fp, #0
    44d0:	bne.n	4522 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x106>
      if (freeCount < freeNeed) {
        freeCount = 0;
    44d2:	cmp	r7, r8
    44d4:	it	cc
    44d6:	movcc	r7, #0
      }
      if (buf[0] != EXFAT_TYPE_FILE) {
    44d8:	cmp	r2, #133	; 0x85
    44da:	bne.n	447a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
        continue;
      }
      inSet = true;
      memset(this, 0, sizeof(ExFatFile));
    44dc:	movs	r2, #56	; 0x38
    44de:	mov	r1, fp
    44e0:	mov	r0, r4
    44e2:	bl	90bc <memset>
      dirFile = reinterpret_cast<DirFile_t*>(buf);
      m_setCount = dirFile->setCount;
      m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    44e6:	ldrb.w	r2, [sp, #20]
        continue;
      }
      inSet = true;
      memset(this, 0, sizeof(ExFatFile));
      dirFile = reinterpret_cast<DirFile_t*>(buf);
      m_setCount = dirFile->setCount;
    44ea:	ldrb.w	r3, [sp, #17]
    44ee:	strb.w	r3, [r4, #48]	; 0x30
      m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    44f2:	and.w	r3, r2, #55	; 0x37
      if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
    44f6:	lsls	r2, r2, #27
        m_attributes |= FILE_ATTR_FILE;
    44f8:	it	pl
    44fa:	orrpl.w	r3, r3, #8
    44fe:	strb.w	r3, [r4, #49]	; 0x31
    4502:	ldr	r3, [r6, #32]
      }
      m_vol = dir->volume();
    4504:	str	r3, [r4, #32]
    4506:	ldr	r3, [r6, #24]
      m_dirPos.cluster = dir->curCluster();
    4508:	str	r3, [r4, #36]	; 0x24
      m_dirPos.position = dir->curPosition() - 32;
    450a:	ldr	r3, [r6, #0]
    450c:	subs	r3, #32
    450e:	str	r3, [r4, #40]	; 0x28
      m_dirPos.isContiguous = dir->isContiguous();
    4510:	ldrb.w	r3, [r6, #51]	; 0x33
    4514:	ubfx	r3, r3, #6, #1
    4518:	strb.w	r3, [r4, #44]	; 0x2c
        freeCount = 0;
      }
      if (buf[0] != EXFAT_TYPE_FILE) {
        continue;
      }
      inSet = true;
    451c:	mov.w	fp, #1
    4520:	b.n	447a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
      }
      m_vol = dir->volume();
      m_dirPos.cluster = dir->curCluster();
      m_dirPos.position = dir->curPosition() - 32;
      m_dirPos.isContiguous = dir->isContiguous();
    } else if (buf[0] == EXFAT_TYPE_STREAM) {
    4522:	cmp	r2, #192	; 0xc0
    4524:	bne.n	457e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x162>
      dirStream = reinterpret_cast<DirStream_t*>(buf);
      m_flags = modeFlags;
      if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    4526:	ldrb.w	r3, [sp, #17]
      m_dirPos.cluster = dir->curCluster();
      m_dirPos.position = dir->curPosition() - 32;
      m_dirPos.isContiguous = dir->isContiguous();
    } else if (buf[0] == EXFAT_TYPE_STREAM) {
      dirStream = reinterpret_cast<DirStream_t*>(buf);
      m_flags = modeFlags;
    452a:	strb.w	r9, [r4, #51]	; 0x33
      if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    452e:	lsls	r0, r3, #30
        m_flags |= FILE_FLAG_CONTIGUOUS;
    4530:	itt	mi
    4532:	orrmi.w	r3, r9, #64	; 0x40
    4536:	strbmi.w	r3, [r4, #51]	; 0x33
      }
      m_validLength = getLe64(dirStream->validLength);
    453a:	ldrd	r2, r3, [sp, #24]
    453e:	strd	r2, r3, [r4, #16]
      m_firstCluster = getLe32(dirStream->firstCluster);
    4542:	ldr	r3, [sp, #36]	; 0x24
    4544:	str	r3, [r4, #28]
      m_dataLength = getLe64(dirStream->dataLength);
    4546:	ldrd	r2, r3, [sp, #40]	; 0x28
    454a:	strd	r2, r3, [r4, #8]
      if (!fname) {
    454e:	cbnz	r5, 4558 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x13c>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    4550:	tst.w	sl, #2048	; 0x800
    4554:	bne.n	448e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    4556:	b.n	45a6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x18a>
  }
  void reset() {
    next = begin;
    4558:	ldr	r3, [r5, #0]
    455a:	str	r3, [r5, #4]
    ls = 0;
    455c:	mov.w	r3, #0
    4560:	strh	r3, [r5, #12]
      m_dataLength = getLe64(dirStream->dataLength);
      if (!fname) {
        goto found;
      }
      fname->reset();
      if (fname->nameLength != dirStream->nameLength ||
    4562:	ldr	r2, [r5, #16]
    4564:	ldrb.w	r3, [sp, #19]
    4568:	cmp	r2, r3
    456a:	bne.n	44be <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa2>
    456c:	ldrh.w	r2, [sp, #20]
    4570:	ldrh	r3, [r5, #20]
    4572:	subs	r1, r2, r3
    4574:	rsbs	fp, r1, #0
    4578:	adc.w	fp, fp, r1
    457c:	b.n	447a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
          fname->nameHash != getLe16(dirStream->nameHash)) {
        inSet = false;
      }
    } else if (buf[0] == EXFAT_TYPE_NAME) {
    457e:	cmp	r2, #193	; 0xc1
    4580:	bne.n	44be <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa2>
      dirName = reinterpret_cast<DirName_t*>(buf);
      if (!cmpName(dirName, fname)) {
    4582:	mov	r2, r5
    4584:	add	r1, sp, #16
    4586:	mov	r0, r4
    4588:	bl	3f10 <ExFatFile::cmpName(DirName_t const*, ExName_t*)>
    458c:	cbnz	r0, 4592 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x176>
        inSet = false;
    458e:	mov	fp, r0
    4590:	b.n	447a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    4592:	ldrh	r2, [r5, #12]
    4594:	cmp	r2, #0
    4596:	bne.w	447a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
    459a:	ldr	r1, [r5, #4]
    459c:	ldr	r2, [r5, #8]
    459e:	cmp	r1, r2
    45a0:	bne.w	447a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
    45a4:	b.n	4550 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x134>
  if (oflag & O_EXCL) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Write, truncate, or at end is an error for a directory or read-only file.
  if ((oflag & (O_TRUNC | O_AT_END)) || (m_flags & FILE_FLAG_WRITE)) {
    45a6:	tst.w	sl, #17408	; 0x4400
    45aa:	bne.n	45b4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x198>
    45ac:	ldrb.w	r3, [r4, #51]	; 0x33
    45b0:	lsls	r2, r3, #30
    45b2:	bpl.n	45c0 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1a4>
    if (isSubDir() || isReadOnly() || READ_ONLY) {
    45b4:	ldrb.w	r3, [r4, #49]	; 0x31
    45b8:	tst.w	r3, #17
    45bc:	bne.w	448e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      goto fail;
    }
  }

#if !READ_ONLY
  if (oflag & O_TRUNC) {
    45c0:	tst.w	sl, #1024	; 0x400
    45c4:	beq.n	45e8 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1cc>
    if (!(m_flags & FILE_FLAG_WRITE)) {
    45c6:	ldrb.w	r3, [r4, #51]	; 0x33
    45ca:	lsls	r3, r3, #30
    45cc:	bpl.w	448e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
    45d0:	movs	r2, #0
    45d2:	movs	r3, #0
    45d4:	mov	r0, r4
    45d6:	bl	434c <ExFatFile::seekSet(unsigned long long)>
    45da:	cmp	r0, #0
    45dc:	beq.w	448e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    45e0:	mov	r0, r4
    45e2:	bl	533e <ExFatFile::truncate()>
    45e6:	b.n	45fa <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1de>
    }
    if (!truncate(0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    45e8:	tst.w	sl, #16384	; 0x4000
    45ec:	beq.w	474c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x330>
    45f0:	ldrd	r2, r3, [r4, #16]
    45f4:	mov	r0, r4
    45f6:	bl	434c <ExFatFile::seekSet(unsigned long long)>
    45fa:	cmp	r0, #0
    45fc:	beq.w	448e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    4600:	b.n	474c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x330>
#if READ_ONLY
  DBG_FAIL_MACRO;
  goto fail;
#else  // READ_ONLY
  // don't create unless O_CREAT and write
  if (!(oflag & O_CREAT) || !(modeFlags & FILE_FLAG_WRITE) || !fname) {
    4602:	tst.w	sl, #512	; 0x200
    4606:	beq.w	448e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    460a:	tst.w	r9, #2
    460e:	beq.w	448e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    4612:	cmp	r5, #0
    4614:	beq.w	448e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    DBG_WARN_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    4618:	cmp	r7, r8
    461a:	bcs.n	4656 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x23a>
    n = dir->read(buf, 32);
    461c:	movs	r2, #32
    461e:	add	r1, sp, #16
    4620:	mov	r0, r6
    4622:	bl	419c <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    4626:	cbnz	r0, 463e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x222>
      curCluster = dir->m_curCluster;
      if (!dir->addDirCluster()) {
    4628:	mov	r0, r6
    goto fail;
  }
  while (freeCount < freeNeed) {
    n = dir->read(buf, 32);
    if (n == 0) {
      curCluster = dir->m_curCluster;
    462a:	ldr.w	sl, [r6, #24]
      if (!dir->addDirCluster()) {
    462e:	bl	4fa2 <ExFatFile::addDirCluster()>
    4632:	cmp	r0, #0
    4634:	beq.w	448e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
        DBG_FAIL_MACRO;
        goto fail;
      }
      dir->m_curCluster = curCluster;
    4638:	str.w	sl, [r6, #24]
      continue;
    463c:	b.n	4618 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1fc>
    }
    if (n != 32) {
    463e:	cmp	r0, #32
    4640:	bne.w	448e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (freeCount == 0) {
    4644:	cbnz	r7, 4650 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x234>
      freePos.position = dir->curPosition() - 32;
    4646:	ldr	r3, [r6, #0]
    4648:	subs	r3, #32
    464a:	str	r3, [sp, #4]
    464c:	ldr	r3, [r6, #24]
    464e:	str	r3, [sp, #0]
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
    4650:	adds	r7, #1
    4652:	uxtb	r7, r7
    4654:	b.n	4618 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1fc>
  }
  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
    4656:	movs	r2, #56	; 0x38
    4658:	movs	r1, #0
    465a:	mov	r0, r4
      freePos.position = dir->curPosition() - 32;
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }
  freePos.isContiguous = dir->isContiguous();
    465c:	ldrb.w	r7, [r6, #51]	; 0x33
  memset(this, 0, sizeof(ExFatFile));
    4660:	bl	90bc <memset>
    4664:	ldr	r3, [r6, #32]
  m_vol = dir->volume();
    4666:	str	r3, [r4, #32]
  m_attributes = FILE_ATTR_FILE;
    4668:	movs	r3, #8
    466a:	strb.w	r3, [r4, #49]	; 0x31
  m_dirPos = freePos;
    466e:	ldr	r3, [sp, #0]
    4670:	str	r3, [r4, #36]	; 0x24
      freePos.position = dir->curPosition() - 32;
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }
  freePos.isContiguous = dir->isContiguous();
    4672:	ubfx	r7, r7, #6, #1
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
    4676:	ldr	r3, [sp, #4]
    4678:	strb.w	r7, [r4, #44]	; 0x2c
    467c:	str	r3, [r4, #40]	; 0x28
  }
  void reset() {
    next = begin;
    467e:	ldr	r3, [r5, #0]
    4680:	str	r3, [r5, #4]
    ls = 0;
    4682:	movs	r7, #0
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    4684:	add.w	sl, r8, #4294967295
    4688:	strh	r7, [r5, #12]
    468a:	uxtb.w	sl, sl
    468e:	uxtb.w	fp, r7
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  fname->reset();
  for (uint8_t i = 0; i < freeNeed; i++) {
    4692:	cmp	fp, r8
    4694:	bcs.n	4736 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x31a>
    cache = dirCache(i, FsCache::CACHE_FOR_WRITE);
    4696:	movs	r2, #1
    4698:	mov	r1, fp
    469a:	mov	r0, r4
    469c:	bl	406e <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache || (cache[0] & 0x80)) {
    46a0:	mov	r6, r0
    46a2:	cmp	r0, #0
    46a4:	beq.w	448e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    46a8:	ldrsb.w	r2, [r0]
    46ac:	cmp	r2, #0
    46ae:	blt.w	448e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memset(cache, 0 , 32);
    46b2:	movs	r2, #32
    46b4:	movs	r1, #0
    46b6:	bl	90bc <memset>
    if (i == 0) {
    46ba:	cmp.w	fp, #0
    46be:	bne.n	46fe <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x2e2>
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
    46c0:	movs	r3, #133	; 0x85
    46c2:	strb	r3, [r6, #0]
      m_setCount = freeNeed - 1;
      dirFile->setCount = m_setCount;

      if (FsDateTime::callback) {
    46c4:	ldr	r3, [pc, #160]	; (4768 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x34c>)
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    46c6:	strb.w	sl, [r4, #48]	; 0x30
      dirFile->setCount = m_setCount;
    46ca:	strb.w	sl, [r6, #1]

      if (FsDateTime::callback) {
    46ce:	ldr	r3, [r3, #0]
    46d0:	cbz	r3, 46f2 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x2d6>
        uint16_t date, time;
        uint8_t ms10;
        FsDateTime::callback(&date, &time, &ms10);
    46d2:	add.w	r2, sp, #11
    46d6:	add.w	r1, sp, #14
    46da:	add	r0, sp, #12
    46dc:	blx	r3
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    46de:	ldrh.w	r3, [sp, #12]
    46e2:	strh	r3, [r6, #10]
    46e4:	ldrh.w	r3, [sp, #14]
    46e8:	strh	r3, [r6, #8]
        setLe16(dirFile->createDate, date);
        setLe16(dirFile->createTime, time);
        dirFile->createTimeMs = ms10;
    46ea:	ldrb.w	r3, [sp, #11]
    46ee:	strb	r3, [r6, #20]
    46f0:	b.n	4732 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
    46f2:	movw	r3, #21537	; 0x5421
    46f6:	strh	r3, [r6, #10]
    46f8:	strh	r3, [r6, #14]
    46fa:	strh	r3, [r6, #18]
    46fc:	b.n	4732 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
         setLe16(dirFile->createTime, FS_DEFAULT_TIME);
         setLe16(dirFile->modifyTime, FS_DEFAULT_TIME);
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
    46fe:	cmp.w	fp, #1
    4702:	bne.n	471e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x302>
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
      dirStream->flags = EXFAT_FLAG_ALWAYS1;
      m_flags = modeFlags | FILE_FLAG_DIR_DIRTY;
    4704:	orn	r3, r9, #127	; 0x7f
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
    4708:	movs	r2, #192	; 0xc0
    470a:	strb	r2, [r6, #0]
      dirStream->flags = EXFAT_FLAG_ALWAYS1;
    470c:	strb.w	fp, [r6, #1]
      m_flags = modeFlags | FILE_FLAG_DIR_DIRTY;
    4710:	strb.w	r3, [r4, #51]	; 0x33
      dirStream->nameLength = fname->nameLength;
    4714:	ldr	r3, [r5, #16]
    4716:	strb	r3, [r6, #3]
      setLe16(dirStream->nameHash, fname->nameHash);
    4718:	ldrh	r3, [r5, #20]
    471a:	strh	r3, [r6, #4]
    471c:	b.n	4732 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
    } else {
      dirName = reinterpret_cast<DirName_t*>(cache);
      dirName->type = EXFAT_TYPE_NAME;
    471e:	movs	r3, #193	; 0xc1
    4720:	strb	r3, [r6, #0]
    4722:	add.w	fp, r6, #30
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    4726:	ldrh	r2, [r5, #12]
    4728:	cbnz	r2, 4750 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x334>
    472a:	ldr	r1, [r5, #4]
    472c:	ldr	r2, [r5, #8]
    472e:	cmp	r1, r2
    4730:	bne.n	4750 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x334>
    4732:	adds	r7, #1
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  fname->reset();
  for (uint8_t i = 0; i < freeNeed; i++) {
    4734:	b.n	468e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x272>
        uint16_t u = fname->get16();
        setLe16(dirName->unicode + 2*k, u);
      }
    }
  }
  return sync();
    4736:	mov	r0, r4
    4738:	bl	4f64 <ExFatFile::sync()>
    473c:	b.n	4760 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
  if (isOpen() || !dir->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }

  switch (oflag & O_ACCMODE) {
    473e:	cmp	r3, #0
    4740:	bne.w	448e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    case O_RDONLY:
      modeFlags = FILE_FLAG_READ;
    4744:	movs	r3, #1
    4746:	b.n	444c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30>
      break;
    case O_WRONLY:
      modeFlags = FILE_FLAG_WRITE;
    4748:	movs	r3, #2
    474a:	b.n	444c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30>
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    DBG_FAIL_MACRO;
    goto fail;
  }
#endif  // !READ_ONLY
  return true;
    474c:	movs	r0, #1
    474e:	b.n	4760 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
      dirName->type = EXFAT_TYPE_NAME;
      for (size_t k = 0; k < 15; k++) {
        if (fname->atEnd()) {
          break;
        }
        uint16_t u = fname->get16();
    4750:	mov	r0, r5
    4752:	bl	3958 <FsName::get16()>
    4756:	strh.w	r0, [r6, #2]!
      dirStream->nameLength = fname->nameLength;
      setLe16(dirStream->nameHash, fname->nameHash);
    } else {
      dirName = reinterpret_cast<DirName_t*>(cache);
      dirName->type = EXFAT_TYPE_NAME;
      for (size_t k = 0; k < 15; k++) {
    475a:	cmp	r6, fp
    475c:	bne.n	4726 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30a>
    475e:	b.n	4732 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
 fail:
  // close file
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
    4760:	add	sp, #52	; 0x34
    4762:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4766:	nop
    4768:	.word	0x2001a690

0000476c <ExFatFile::open(ExFatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
    476c:	push	{r4, r5, r6, r7, lr}
    476e:	sub	sp, #92	; 0x5c
    4770:	mov	r7, r3
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    4772:	movs	r3, #0
    4774:	strb.w	r3, [sp, #81]	; 0x51
    4778:	strb.w	r3, [sp, #82]	; 0x52
    477c:	strb.w	r3, [sp, #83]	; 0x53
 */
/**
 * \class FsName
 * \brief Handle UTF-8 file names.
 */
class FsName {
    4780:	strh.w	r3, [sp, #20]
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    4784:	ldrb.w	r3, [r0, #49]	; 0x31
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
    4788:	str	r2, [sp, #4]
    478a:	mov	r5, r0
    478c:	mov	r4, r1
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    478e:	cbz	r3, 4794 <ExFatFile::open(ExFatFile*, char const*, int)+0x28>
    close();
  }
  return openPrivate(dirFile, &fname, oflag);

 fail:
  return false;
    4790:	movs	r0, #0
    4792:	b.n	4822 <ExFatFile::open(ExFatFile*, char const*, int)+0xb6>
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    4794:	ldrb.w	r3, [r1, #49]	; 0x31
    4798:	tst.w	r3, #80	; 0x50
    479c:	beq.n	4790 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    479e:	ldrb	r3, [r2, #0]
    47a0:	cmp	r3, #47	; 0x2f
    47a2:	bne.n	47ca <ExFatFile::open(ExFatFile*, char const*, int)+0x5e>
    while (isDirSeparator(*path)) {
    47a4:	ldr	r3, [sp, #4]
    47a6:	ldrb	r2, [r3, #0]
    47a8:	cmp	r2, #47	; 0x2f
    47aa:	bne.n	47b2 <ExFatFile::open(ExFatFile*, char const*, int)+0x46>
      path++;
    47ac:	adds	r3, #1
    47ae:	str	r3, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    47b0:	b.n	47a4 <ExFatFile::open(ExFatFile*, char const*, int)+0x38>
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    47b2:	ldr	r1, [r4, #32]
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
    47b4:	cbnz	r2, 47be <ExFatFile::open(ExFatFile*, char const*, int)+0x52>
      return openRoot(dirFile->m_vol);
    47b6:	mov	r0, r5
    47b8:	bl	40fa <ExFatFile::openRoot(ExFatVolume*)>
    47bc:	b.n	4822 <ExFatFile::open(ExFatFile*, char const*, int)+0xb6>
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    47be:	add	r0, sp, #32
    47c0:	bl	40fa <ExFatFile::openRoot(ExFatVolume*)>
    47c4:	cmp	r0, #0
    47c6:	beq.n	4790 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    47c8:	add	r4, sp, #32
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    47ca:	add	r3, sp, #4
    47cc:	add	r2, sp, #8
    47ce:	ldr	r1, [sp, #4]
    47d0:	mov	r0, r5
    47d2:	bl	4120 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    47d6:	cmp	r0, #0
    47d8:	beq.n	4790 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    47da:	ldr	r3, [sp, #4]
    47dc:	ldrb	r3, [r3, #0]
    47de:	cbz	r3, 4816 <ExFatFile::open(ExFatFile*, char const*, int)+0xaa>
      break;
    }
    if (!openPrivate(dirFile, &fname, O_RDONLY)) {
    47e0:	movs	r3, #0
    47e2:	add	r2, sp, #8
    47e4:	mov	r1, r4
    47e6:	mov	r0, r5
    47e8:	bl	441c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    47ec:	cmp	r0, #0
    47ee:	beq.n	4790 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_WARN_MACRO;
      goto fail;
    }
    tmpDir = *this;
    47f0:	add	r2, sp, #32
    47f2:	mov	r3, r5
    47f4:	add.w	lr, r5, #48	; 0x30
    47f8:	mov	r4, r2
    47fa:	ldr	r0, [r3, #0]
    47fc:	ldr	r1, [r3, #4]
    47fe:	mov	r6, r2
    4800:	stmia	r6!, {r0, r1}
    4802:	adds	r3, #8
    4804:	cmp	r3, lr
    4806:	mov	r2, r6
    4808:	bne.n	47fa <ExFatFile::open(ExFatFile*, char const*, int)+0x8e>
    480a:	ldr	r0, [r3, #0]
    480c:	str	r0, [r6, #0]
    dirFile = &tmpDir;
    close();
    480e:	mov	r0, r5
    4810:	bl	40a6 <ExFatFile::close()>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    4814:	b.n	47ca <ExFatFile::open(ExFatFile*, char const*, int)+0x5e>
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    close();
  }
  return openPrivate(dirFile, &fname, oflag);
    4816:	mov	r3, r7
    4818:	add	r2, sp, #8
    481a:	mov	r1, r4
    481c:	mov	r0, r5
    481e:	bl	441c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>

 fail:
  return false;
}
    4822:	add	sp, #92	; 0x5c
    4824:	pop	{r4, r5, r6, r7, pc}

00004826 <ExFatFile::open(ExFatVolume*, char const*, int)>:
bool ExFatFile::open(const char* path, oflag_t oflag) {
  return open(ExFatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
    4826:	cbz	r1, 4830 <ExFatFile::open(ExFatVolume*, char const*, int)+0xa>
    4828:	add.w	r1, r1, #1096	; 0x448
    482c:	b.w	476c <ExFatFile::open(ExFatFile*, char const*, int)>
}
    4830:	mov	r0, r1
    4832:	bx	lr

00004834 <ExFatFile::openNext(ExFatFile*, int)>:
    DBG_FAIL_MACRO;
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
    4834:	push	{r4, r5}
    4836:	mov	r3, r2
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    4838:	ldrb.w	r2, [r0, #49]	; 0x31
    483c:	cbnz	r2, 485c <ExFatFile::openNext(ExFatFile*, int)+0x28>
    483e:	ldrb.w	r5, [r1, #49]	; 0x31
    4842:	tst.w	r5, #80	; 0x50
    4846:	beq.n	485c <ExFatFile::openNext(ExFatFile*, int)+0x28>
    4848:	ldrd	r4, r5, [r1]
    484c:	movs	r5, #0
    484e:	and.w	r4, r4, #31
    4852:	orrs	r4, r5
    4854:	bne.n	485c <ExFatFile::openNext(ExFatFile*, int)+0x28>
  }
  return openPrivate(dir, nullptr, oflag);

 fail:
  return false;
}
    4856:	pop	{r4, r5}
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return openPrivate(dir, nullptr, oflag);
    4858:	b.w	441c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>

 fail:
  return false;
}
    485c:	movs	r0, #0
    485e:	pop	{r4, r5}
    4860:	bx	lr

00004862 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>:
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"

//------------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
    4862:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4866:	mov	r8, r0
    4868:	mov	sl, r2
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
    486a:	mov	r9, r1
    486c:	cbz	r1, 4872 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x10>
    486e:	subs	r4, r1, #2
    4870:	b.n	4876 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x14>
    4872:	ldr.w	r4, [r0, #1056]	; 0x420
  if (start >= m_clusterCount) {
    4876:	ldr.w	r3, [r8, #1072]	; 0x430
    start = 0;
    487a:	cmp	r4, r3
    487c:	it	cs
    487e:	movcs	r4, #0
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
  uint16_t sectorSize = 1 << m_bytesPerSectorShift;
  size_t i = (start >> 3) & (sectorSize - 1);
  uint8_t* cache;
  uint8_t mask = 1 << (start & 7);
    4880:	and.w	r7, r4, #7
    4884:	movs	r3, #1
    4886:	lsl.w	r7, r3, r7
    start = 0;
  }
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
  uint16_t sectorSize = 1 << m_bytesPerSectorShift;
  size_t i = (start >> 3) & (sectorSize - 1);
    488a:	ubfx	fp, r4, #3, #9
  uint8_t* cache;
  uint8_t mask = 1 << (start & 7);
    488e:	uxtb	r7, r7
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
  }
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
    4890:	mov	r6, r4
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
  }
  uint32_t endAlloc = start;
    4892:	mov	r5, r4
  bool bitmapModify(uint32_t cluster, uint32_t count, bool value);
  //----------------------------------------------------------------------------
  // Cache functions.
  uint8_t* bitmapCacheGet(uint32_t sector, uint8_t option) {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.get(sector, option);
    4894:	ldr.w	r1, [r8, #1068]	; 0x42c
    4898:	movs	r2, #0
    489a:	add.w	r1, r1, r5, lsr #12
    489e:	mov	r0, r8
    48a0:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
  uint8_t mask = 1 << (start & 7);
  while (true) {
    uint32_t sector = m_clusterHeapStartSector +
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
    48a4:	cbz	r0, 4904 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0xa2>
    48a6:	mov	r3, r7
    48a8:	mov	r1, fp
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
    48aa:	ldrb	r7, [r0, r1]
    48ac:	tst	r7, r3
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
    48ae:	add.w	r5, r5, #1
        if (!(mask & cache[i])) {
    48b2:	bne.n	48d0 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x6e>
          if ((endAlloc - bgnAlloc) == count) {
    48b4:	subs	r2, r5, r6
    48b6:	cmp	r2, sl
    48b8:	bne.n	48d2 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x70>
            if (cluster == 0 && count == 1) {
    48ba:	cmp.w	r9, #0
    48be:	bne.n	48ca <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x68>
    48c0:	cmp.w	sl, #1
              // Start at found sector.  bitmapModify may increase this.
              m_bitmapStart = bgnAlloc;
    48c4:	it	eq
    48c6:	streq.w	r6, [r8, #1056]	; 0x420
            }
            return bgnAlloc + 2;
    48ca:	adds	r0, r6, #2
    48cc:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
    48d0:	mov	r6, r5
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    48d2:	cmp	r4, r5
    48d4:	beq.n	4902 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0xa0>
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
    48d6:	ldr.w	r2, [r8, #1072]	; 0x430
    48da:	cmp	r5, r2
    48dc:	bcs.n	48e8 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x86>
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
    48de:	lsls	r3, r3, #1
    48e0:	ands.w	r3, r3, #255	; 0xff
    48e4:	bne.n	48ac <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x4a>
    48e6:	b.n	48f0 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x8e>
        }
        if (endAlloc == start) {
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
          endAlloc = bgnAlloc = 0;
    48e8:	movs	r6, #0
          i = sectorSize;
    48ea:	mov.w	r1, #512	; 0x200
        }
        if (endAlloc == start) {
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
          endAlloc = bgnAlloc = 0;
    48ee:	mov	r5, r6
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    48f0:	adds	r1, #1
    48f2:	movs	r3, #1
    48f4:	cmp.w	r1, #512	; 0x200
          break;
        }
      }
      mask = 1;
    }
    i = 0;
    48f8:	mov.w	fp, #0
          endAlloc = bgnAlloc = 0;
          i = sectorSize;
          break;
        }
      }
      mask = 1;
    48fc:	mov	r7, r3
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    48fe:	bcc.n	48aa <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x48>
    4900:	b.n	4894 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x32>
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
          return 1;
    4902:	movs	r0, #1
      mask = 1;
    }
    i = 0;
  }
  return 0;
}
    4904:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00004908 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>:
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    4908:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    490c:	mov	r7, r2
    490e:	mov	r6, r0
  uint32_t sector;
  uint32_t start = cluster - 2;
    4910:	subs	r2, r1, #2
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    4912:	ldr.w	r0, [r0, #1072]	; 0x430
    4916:	adds	r1, r2, r7
    4918:	cmp	r1, r0
  }
  return 0;
}
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    491a:	mov	r8, r3
  uint32_t start = cluster - 2;
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    491c:	bhi.n	49a2 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
    491e:	ldr.w	r3, [r6, #1056]	; 0x420
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    4922:	cmp.w	r8, #0
    4926:	beq.n	493c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x34>
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
    4928:	cmp	r2, r3
    492a:	bhi.n	4944 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
    492c:	cmp	r1, r3
    492e:	bls.n	4944 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
      m_bitmapStart = (start + count) < m_clusterCount ? start + count : 0;
    4930:	cmp	r1, r0
    4932:	it	cs
    4934:	movcs	r1, #0
    4936:	str.w	r1, [r6, #1056]	; 0x420
    493a:	b.n	4944 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
    }
  } else {
    if (start < m_bitmapStart) {
    493c:	cmp	r2, r3
      m_bitmapStart = start;
    493e:	it	cc
    4940:	strcc.w	r2, [r6, #1056]	; 0x420
    }
  }
  mask = 1 << (start & 7);
    4944:	and.w	r5, r2, #7
    4948:	movs	r3, #1
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    494a:	ldr.w	r1, [r6, #1068]	; 0x42c
  } else {
    if (start < m_bitmapStart) {
      m_bitmapStart = start;
    }
  }
  mask = 1 << (start & 7);
    494e:	lsl.w	r5, r3, r5
    4952:	uxtb	r5, r5
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    4954:	add.w	r1, r1, r2, lsr #12
  i = (start >> 3) & m_sectorMask;
    4958:	ubfx	r4, r2, #3, #9
    495c:	movs	r2, #1
    495e:	mov	r0, r6
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    4960:	add.w	r9, r1, #1
    4964:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    4968:	cbz	r0, 49a2 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
    496a:	adds	r3, r0, r4
    496c:	mov	r2, r5
    496e:	add.w	r0, r0, #512	; 0x200
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
    4972:	ldrb	r1, [r3, #0]
    4974:	tst	r1, r2
    4976:	ite	ne
    4978:	movne	r4, #1
    497a:	moveq	r4, #0
    497c:	cmp	r4, r8
    497e:	beq.n	49a2 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    4980:	eors	r1, r2
        if (--count == 0) {
    4982:	subs	r7, #1
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    4984:	strb	r1, [r3, #0]
        if (--count == 0) {
    4986:	beq.n	49a8 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0xa0>
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
    4988:	lsls	r2, r2, #1
    498a:	ands.w	r2, r2, #255	; 0xff
    498e:	bne.n	4972 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x6a>
    4990:	adds	r3, #1
          return true;
        }
      }
      mask = 1;
    }
    i = 0;
    4992:	mov	r4, r2
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    4994:	cmp	r0, r3
    4996:	mov.w	r2, #1
  mask = 1 << (start & 7);
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
  i = (start >> 3) & m_sectorMask;
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    499a:	mov	r1, r9
        cache[i] ^= mask;
        if (--count == 0) {
          return true;
        }
      }
      mask = 1;
    499c:	mov	r5, r2
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    499e:	bne.n	4972 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x6a>
    49a0:	b.n	495c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x54>
    }
    i = 0;
  }

 fail:
  return false;
    49a2:	movs	r0, #0
    49a4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
        if (--count == 0) {
          return true;
    49a8:	movs	r0, #1
    i = 0;
  }

 fail:
  return false;
}
    49aa:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000049ae <ExFatPartition::dirCache(DirPos_t*, unsigned char)>:
    n++;
  } while (status);
  return n;
}
//------------------------------------------------------------------------------
uint8_t* ExFatPartition::dirCache(DirPos_t* pos, uint8_t options) {
    49ae:	push	{r3, r4, r5, lr}
    49b0:	mov	r5, r1
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    49b2:	ldr.w	r1, [r0, #1080]	; 0x438
    49b6:	ldr	r3, [r5, #4]
    49b8:	ands	r1, r3
    49ba:	ldr	r3, [r5, #0]
    49bc:	subs	r4, r3, #2
    49be:	ldrb.w	r3, [r0, #1093]	; 0x445
    49c2:	lsl.w	r3, r4, r3
    49c6:	add.w	r3, r3, r1, lsr #9
    49ca:	ldr.w	r1, [r0, #1068]	; 0x42c
    49ce:	add.w	r0, r0, #528	; 0x210
    49d2:	add	r1, r3
    49d4:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
  uint32_t sector = clusterStartSector(pos->cluster);
  sector += (m_clusterMask & pos->position) >> m_bytesPerSectorShift;
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
    49d8:	cbz	r0, 49e2 <ExFatPartition::dirCache(DirPos_t*, unsigned char)+0x34>
    49da:	ldr	r3, [r5, #4]
    49dc:	ubfx	r3, r3, #0, #9
    49e0:	add	r0, r3
}
    49e2:	pop	{r3, r4, r5, pc}

000049e4 <ExFatPartition::fatGet(unsigned long, unsigned long*)>:
  }
  return 1;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    49e4:	push	{r3, r4, r5, lr}
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    49e6:	ldr.w	r3, [r0, #1072]	; 0x430
    49ea:	adds	r3, #1
    49ec:	cmp	r3, r1
  }
  return 1;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    49ee:	mov	r4, r1
    49f0:	mov	r5, r2
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    49f2:	bcs.n	49fa <ExFatPartition::fatGet(unsigned long, unsigned long*)+0x16>
    DBG_FAIL_MACRO;
    return -1;
    49f4:	mov.w	r0, #4294967295
    49f8:	pop	{r3, r4, r5, pc}
    49fa:	ldr.w	r1, [r0, #1060]	; 0x424
    49fe:	movs	r2, #0
    4a00:	add.w	r1, r1, r4, lsr #7
    4a04:	add.w	r0, r0, #528	; 0x210
    4a08:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));

  cache = dataCacheGet(sector, FsCache::CACHE_FOR_READ);
  if (!cache) {
    4a0c:	cmp	r0, #0
    4a0e:	beq.n	49f4 <ExFatPartition::fatGet(unsigned long, unsigned long*)+0x10>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    4a10:	lsls	r4, r4, #2
    4a12:	ubfx	r4, r4, #0, #9
    4a16:	ldr	r0, [r0, r4]
    return -1;
  }
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));
  *value = next;
    4a18:	str	r0, [r5, #0]
  return next == EXFAT_EOC ? 0 : 1;
    4a1a:	adds	r0, #1
    4a1c:	it	ne
    4a1e:	movne	r0, #1
}
    4a20:	pop	{r3, r4, r5, pc}

00004a22 <ExFatPartition::chainSize(unsigned long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
    4a22:	push	{r0, r1, r4, r5, r6, lr}
    4a24:	add	r5, sp, #8
    4a26:	mov	r6, r0
    4a28:	str.w	r1, [r5, #-4]!
  uint32_t n = 0;
    4a2c:	movs	r4, #0
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    4a2e:	mov	r2, r5
    4a30:	ldr	r1, [sp, #4]
    4a32:	mov	r0, r6
    4a34:	bl	49e4 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    if (status < 0) return 0;
    4a38:	cmp	r0, #0
    4a3a:	blt.n	4a46 <ExFatPartition::chainSize(unsigned long)+0x24>
    n++;
    4a3c:	add.w	r4, r4, #1
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    4a40:	bne.n	4a2e <ExFatPartition::chainSize(unsigned long)+0xc>
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    n++;
    4a42:	mov	r0, r4
    4a44:	b.n	4a48 <ExFatPartition::chainSize(unsigned long)+0x26>
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    4a46:	movs	r0, #0
    n++;
  } while (status);
  return n;
}
    4a48:	add	sp, #8
    4a4a:	pop	{r4, r5, r6, pc}

00004a4c <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>:
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    4a4c:	push	{r4, r5, r6, lr}
    4a4e:	mov	r5, r1
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    4a50:	ldr.w	r4, [r0, #1080]	; 0x438
    4a54:	ldr	r1, [r1, #4]
    4a56:	ands	r4, r1
    4a58:	adds	r3, r4, r2
  pos->position += offset;
    4a5a:	add	r2, r1
    4a5c:	str	r2, [r5, #4]
  tmp >>= bytesPerClusterShift();
    4a5e:	ldrb.w	r4, [r0, #1093]	; 0x445
    4a62:	adds	r4, #9
    4a64:	uxtb	r4, r4
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    4a66:	mov	r6, r0
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
    4a68:	lsr.w	r4, r3, r4
  while (tmp--) {
    4a6c:	cbz	r4, 4a8c <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x40>
    if (pos->isContiguous) {
    4a6e:	ldrb	r3, [r5, #8]
    4a70:	cbz	r3, 4a7c <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x30>
      pos->cluster++;
    4a72:	ldr	r3, [r5, #0]
    4a74:	adds	r3, #1
    4a76:	str	r3, [r5, #0]
    4a78:	subs	r4, #1
    4a7a:	b.n	4a6c <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x20>
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    4a7c:	mov	r2, r5
    4a7e:	ldr	r1, [r5, #0]
    4a80:	mov	r0, r6
    4a82:	bl	49e4 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
      if (status != 1) {
    4a86:	cmp	r0, #1
    4a88:	beq.n	4a78 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x2c>
    4a8a:	pop	{r4, r5, r6, pc}
        return status;
      }
    }
  }
  return 1;
    4a8c:	movs	r0, #1
}
    4a8e:	pop	{r4, r5, r6, pc}

00004a90 <ExFatPartition::fatPut(unsigned long, unsigned long)>:
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    4a90:	cmp	r1, #1
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));
  *value = next;
  return next == EXFAT_EOC ? 0 : 1;
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
    4a92:	push	{r3, r4, r5, lr}
    4a94:	mov	r4, r1
    4a96:	mov	r5, r2
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    4a98:	bhi.n	4a9e <ExFatPartition::fatPut(unsigned long, unsigned long)+0xe>
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;

 fail:
  return false;
    4a9a:	movs	r0, #0
    4a9c:	pop	{r3, r4, r5, pc}
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    4a9e:	ldr.w	r3, [r0, #1072]	; 0x430
    4aa2:	adds	r3, #1
    4aa4:	cmp	r1, r3
    4aa6:	bhi.n	4a9a <ExFatPartition::fatPut(unsigned long, unsigned long)+0xa>
    4aa8:	ldr.w	r1, [r0, #1060]	; 0x424
    4aac:	movs	r2, #1
    4aae:	add.w	r1, r1, r4, lsr #7
    4ab2:	add.w	r0, r0, #528	; 0x210
    4ab6:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
  cache = dataCacheGet(sector, FsCache::CACHE_FOR_WRITE);
  if (!cache) {
    4aba:	cmp	r0, #0
    4abc:	beq.n	4a9a <ExFatPartition::fatPut(unsigned long, unsigned long)+0xa>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    4abe:	lsls	r4, r4, #2
    4ac0:	ubfx	r4, r4, #0, #9
    4ac4:	str	r5, [r0, r4]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;
    4ac6:	movs	r0, #1

 fail:
  return false;
}
    4ac8:	pop	{r3, r4, r5, pc}

00004aca <ExFatPartition::freeChain(unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
    4aca:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    4ace:	mov	r7, r0
    4ad0:	mov	r4, r1
  uint32_t next;
  uint32_t start = cluster;
    4ad2:	mov	r6, r1
  int8_t status;
  do {
    status = fatGet(cluster, &next);
    4ad4:	add	r2, sp, #4
    4ad6:	mov	r1, r4
    4ad8:	mov	r0, r7
    4ada:	bl	49e4 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    if (status < 0) {
    4ade:	subs.w	r8, r0, #0
    4ae2:	bge.n	4ae8 <ExFatPartition::freeChain(unsigned long)+0x1e>
  } while (status);

  return true;

 fail:
  return false;
    4ae4:	movs	r5, #0
    4ae6:	b.n	4b20 <ExFatPartition::freeChain(unsigned long)+0x56>
    status = fatGet(cluster, &next);
    if (status < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!fatPut(cluster, 0)) {
    4ae8:	movs	r2, #0
    4aea:	mov	r1, r4
    4aec:	mov	r0, r7
    4aee:	bl	4a90 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4af2:	mov	r5, r0
    4af4:	cmp	r0, #0
    4af6:	beq.n	4ae4 <ExFatPartition::freeChain(unsigned long)+0x1a>
    4af8:	adds	r2, r4, #1
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (status == 0 || (cluster + 1) != next) {
    4afa:	cmp.w	r8, #0
    4afe:	beq.n	4b06 <ExFatPartition::freeChain(unsigned long)+0x3c>
    4b00:	ldr	r3, [sp, #4]
    4b02:	cmp	r2, r3
    4b04:	beq.n	4b18 <ExFatPartition::freeChain(unsigned long)+0x4e>
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    4b06:	movs	r3, #0
    4b08:	subs	r2, r2, r6
    4b0a:	mov	r1, r6
    4b0c:	mov	r0, r7
    4b0e:	bl	4908 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4b12:	cmp	r0, #0
    4b14:	beq.n	4ae4 <ExFatPartition::freeChain(unsigned long)+0x1a>
        DBG_FAIL_MACRO;
        goto fail;
      }
      start = next;
    4b16:	ldr	r6, [sp, #4]
    }
    cluster = next;
    4b18:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  uint32_t start = cluster;
  int8_t status;
  do {
    4b1a:	cmp.w	r8, #0
    4b1e:	bne.n	4ad4 <ExFatPartition::freeChain(unsigned long)+0xa>

  return true;

 fail:
  return false;
}
    4b20:	mov	r0, r5
    4b22:	add	sp, #8
    4b24:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00004b28 <ExFatPartition::freeClusterCount()>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    4b28:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t nc = 0;
  uint32_t sector = m_clusterHeapStartSector;
    4b2c:	ldr.w	r1, [r0, #1068]	; 0x42c
  uint32_t usedCount = 0;
    4b30:	movs	r4, #0

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    4b32:	mov	r6, r0
  uint32_t nc = 0;
    4b34:	mov	r5, r4
    4b36:	add.w	r7, r0, #528	; 0x210
    4b3a:	movs	r2, #0
    4b3c:	mov	r0, r7
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
  uint8_t* cache;

  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    4b3e:	add.w	r8, r1, #1
    4b42:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    4b46:	cbz	r0, 4b88 <ExFatPartition::freeClusterCount()+0x60>
    4b48:	add.w	lr, r0, #4294967295
    4b4c:	add.w	ip, r5, #4096	; 0x1000
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
    4b50:	ldrb.w	r1, [lr, #1]!
    4b54:	cmp	r1, #255	; 0xff
    4b56:	bne.n	4b5c <ExFatPartition::freeClusterCount()+0x34>
        usedCount+= 8;
    4b58:	adds	r4, #8
    4b5a:	b.n	4b70 <ExFatPartition::freeClusterCount()+0x48>
      } else if (cache[i]) {
    4b5c:	cbz	r1, 4b70 <ExFatPartition::freeClusterCount()+0x48>
    4b5e:	movs	r2, #8
    4b60:	movs	r3, #1
        for (uint8_t mask = 1; mask ; mask <<=1) {
          if ((mask & cache[i])) {
    4b62:	tst	r1, r3
            usedCount++;
    4b64:	it	ne
    4b66:	addne	r4, #1
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
      } else if (cache[i]) {
        for (uint8_t mask = 1; mask ; mask <<=1) {
    4b68:	lsls	r3, r3, #1
    4b6a:	subs	r2, #1
    4b6c:	uxtb	r3, r3
    4b6e:	bne.n	4b62 <ExFatPartition::freeClusterCount()+0x3a>
            usedCount++;
          }
        }
      }
      nc += 8;
      if (nc >= m_clusterCount) {
    4b70:	ldr.w	r0, [r6, #1072]	; 0x430
          if ((mask & cache[i])) {
            usedCount++;
          }
        }
      }
      nc += 8;
    4b74:	adds	r5, #8
      if (nc >= m_clusterCount) {
    4b76:	cmp	r5, r0
    4b78:	bcc.n	4b80 <ExFatPartition::freeClusterCount()+0x58>
        return m_clusterCount - usedCount;
    4b7a:	subs	r0, r0, r4
    4b7c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
    4b80:	cmp	r5, ip
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
  uint8_t* cache;

  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    4b82:	mov	r1, r8
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
    4b84:	bne.n	4b50 <ExFatPartition::freeClusterCount()+0x28>
    4b86:	b.n	4b3a <ExFatPartition::freeClusterCount()+0x12>
      if (nc >= m_clusterCount) {
        return m_clusterCount - usedCount;
      }
    }
  }
}
    4b88:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00004b8c <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>:
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    4b8c:	push	{r4, r5, r6, r7, lr}
    4b8e:	mov	r4, r0
    4b90:	sub	sp, #28
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif
  BpbExFat_t* bpb;

  m_fatType = 0;
    4b92:	movs	r5, #0
      }
    }
  }
}
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    4b94:	mov	r0, r1
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    4b96:	mov.w	r3, #4294967295
    4b9a:	mov	r1, r2
    4b9c:	str	r3, [r4, #12]
    4b9e:	str.w	r3, [r4, #540]	; 0x21c
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif
  BpbExFat_t* bpb;

  m_fatType = 0;
    4ba2:	strb.w	r5, [r4, #1092]	; 0x444
  m_blockDev = dev;
    4ba6:	str.w	r0, [r4, #1088]	; 0x440
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    4baa:	str	r0, [r4, #4]
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4bac:	strb	r5, [r4, #0]
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    4bae:	str.w	r0, [r4, #532]	; 0x214
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4bb2:	strb.w	r5, [r4, #528]	; 0x210
  cacheInit(m_blockDev);


  #if SUPPORT_GPT_AND_EXTENDED_PATITIONS 
  cache = cacheClear(); // get buffer to use. 
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part,cache, &firstLBA);
    4bb6:	str	r5, [sp, #8]
    4bb8:	str	r5, [sp, #4]
    4bba:	str	r5, [sp, #0]
    4bbc:	add	r3, sp, #20
    4bbe:	add.w	r2, r4, #544	; 0x220
    4bc2:	bl	35dc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    4bc6:	tst.w	r0, #251	; 0xfb
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    4bca:	add.w	r7, r4, #528	; 0x210
    4bce:	bne.n	4bd4 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x48>
  bitmapFind(0, 1);
  m_fatType = FAT_TYPE_EXFAT;
  return true;

 fail:
  return false;
    4bd0:	movs	r0, #0
    4bd2:	b.n	4c4e <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xc2>
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part,cache, &firstLBA);
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    DBG_FAIL_MACRO;
    goto fail;    
  }
  volStart = firstLBA;
    4bd4:	ldr	r6, [sp, #20]
    4bd6:	mov	r2, r5
    4bd8:	mov	r1, r6
    4bda:	mov	r0, r7
    4bdc:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
  }
  volStart = getLe32(mp->relativeSectors);
  #endif

  cache = dataCacheGet(volStart, FsCache::CACHE_FOR_READ);
  if (!cache) {
    4be0:	mov	r5, r0
    4be2:	cmp	r0, #0
    4be4:	beq.n	4bd0 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  pbs = reinterpret_cast<pbs_t*>(cache);
  if (strncmp(pbs->oemName, "EXFAT", 5)) {
    4be6:	ldr	r1, [pc, #108]	; (4c54 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xc8>)
    4be8:	movs	r2, #5
    4bea:	adds	r0, #3
    4bec:	bl	c05c <strncmp>
    4bf0:	mov	r1, r0
    4bf2:	cmp	r0, #0
    4bf4:	bne.n	4bd0 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  bpb = reinterpret_cast<BpbExFat_t*>(pbs->bpb);
  if (bpb->bytesPerSectorShift != m_bytesPerSectorShift) {
    4bf6:	ldrb.w	r3, [r5, #108]	; 0x6c
    4bfa:	cmp	r3, #9
    4bfc:	bne.n	4bd0 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_fatStartSector = volStart + getLe32(bpb->fatOffset);
    4bfe:	ldr	r3, [r5, #80]	; 0x50
    4c00:	add	r3, r6
    4c02:	str.w	r3, [r4, #1060]	; 0x424
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    4c06:	ldr	r3, [r5, #84]	; 0x54
  m_fatLength = getLe32(bpb->fatLength);
    4c08:	str.w	r3, [r4, #1064]	; 0x428
  m_clusterHeapStartSector = volStart + getLe32(bpb->clusterHeapOffset);
    4c0c:	ldr	r3, [r5, #88]	; 0x58
    4c0e:	add	r6, r3
    4c10:	str.w	r6, [r4, #1068]	; 0x42c
    4c14:	ldr	r3, [r5, #92]	; 0x5c
  m_clusterCount = getLe32(bpb->clusterCount);
    4c16:	str.w	r3, [r4, #1072]	; 0x430
    4c1a:	ldr	r3, [r5, #96]	; 0x60
  m_rootDirectoryCluster = getLe32(bpb->rootDirectoryCluster);
    4c1c:	str.w	r3, [r4, #1076]	; 0x434
  m_sectorsPerClusterShift = bpb->sectorsPerClusterShift;
    4c20:	ldrb.w	r3, [r5, #109]	; 0x6d
    4c24:	strb.w	r3, [r4, #1093]	; 0x445
  m_bytesPerCluster = 1UL << (m_bytesPerSectorShift + m_sectorsPerClusterShift);
    4c28:	movs	r5, #1
    4c2a:	adds	r3, #9
    4c2c:	lsl.w	r3, r5, r3
    4c30:	str.w	r3, [r4, #1084]	; 0x43c
  m_clusterMask = m_bytesPerCluster - 1;
    4c34:	subs	r3, #1
    4c36:	str.w	r3, [r4, #1080]	; 0x438
  // Set m_bitmapStart to first free cluster.
  m_bitmapStart = 0;
    4c3a:	str.w	r0, [r4, #1056]	; 0x420
  bitmapFind(0, 1);
    4c3e:	mov	r2, r5
    4c40:	mov	r0, r4
    4c42:	bl	4862 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  m_fatType = FAT_TYPE_EXFAT;
    4c46:	movs	r3, #64	; 0x40
    4c48:	strb.w	r3, [r4, #1092]	; 0x444
  return true;
    4c4c:	mov	r0, r5

 fail:
  return false;
}
    4c4e:	add	sp, #28
    4c50:	pop	{r4, r5, r6, r7, pc}
    4c52:	nop
    4c54:	.word	0x00012d7b

00004c58 <ExFatPartition::rootLength()>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::rootLength() {
    4c58:	push	{r4, lr}
    4c5a:	mov	r4, r0
  uint32_t nc = chainSize(m_rootDirectoryCluster);
    4c5c:	ldr.w	r1, [r0, #1076]	; 0x434
    4c60:	bl	4a22 <ExFatPartition::chainSize(unsigned long)>
  return nc << bytesPerClusterShift();
    4c64:	ldrb.w	r3, [r4, #1093]	; 0x445
    4c68:	adds	r3, #9
    4c6a:	uxtb	r3, r3
}
    4c6c:	lsls	r0, r3
    4c6e:	pop	{r4, pc}

00004c70 <ExFatVolume::chdir(char const*)>:
#define DBG_FILE "ExFatVolume.cpp"
#include "../common/DebugMacros.h"
#include "ExFatVolume.h"
ExFatVolume* ExFatVolume::m_cwv = nullptr;
//-----------------------------------------------------------------------------
bool ExFatVolume::chdir(const char* path) {
    4c70:	push	{r4, r5, r6, lr}
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend ExFatFile;
  static ExFatVolume* cwv() {return m_cwv;}
  ExFatFile* vwd() {return &m_vwd;}
    4c72:	add.w	r4, r0, #1096	; 0x448
    4c76:	sub	sp, #56	; 0x38
    4c78:	movs	r3, #0
  ExFatFile dir;
  if (!dir.open(vwd(), path, O_RDONLY)) {
    4c7a:	mov	r2, r1
    4c7c:	mov	r0, sp
    4c7e:	mov	r1, r4
    4c80:	strb.w	r3, [sp, #49]	; 0x31
    4c84:	strb.w	r3, [sp, #50]	; 0x32
    4c88:	strb.w	r3, [sp, #51]	; 0x33
    4c8c:	bl	476c <ExFatFile::open(ExFatFile*, char const*, int)>
    4c90:	mov	r5, r0
    4c92:	cbz	r0, 4cbe <ExFatVolume::chdir(char const*)+0x4e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!dir.isDir()) {
    4c94:	ldrb.w	r3, [sp, #49]	; 0x31
    4c98:	ands.w	r3, r3, #80	; 0x50
    4c9c:	beq.n	4cbc <ExFatVolume::chdir(char const*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_vwd = dir;
    4c9e:	mov	r2, sp
    4ca0:	mov	r3, r4
    4ca2:	add	r6, sp, #48	; 0x30
    4ca4:	mov	r4, r2
    4ca6:	ldmia	r4!, {r0, r1}
    4ca8:	cmp	r4, r6
    4caa:	str	r0, [r3, #0]
    4cac:	str	r1, [r3, #4]
    4cae:	mov	r2, r4
    4cb0:	add.w	r3, r3, #8
    4cb4:	bne.n	4ca4 <ExFatVolume::chdir(char const*)+0x34>
    4cb6:	ldr	r0, [r4, #0]
    4cb8:	str	r0, [r3, #0]
  return true;
    4cba:	b.n	4cbe <ExFatVolume::chdir(char const*)+0x4e>

 fail:
  return false;
    4cbc:	mov	r5, r3
}
    4cbe:	mov	r0, r5
    4cc0:	add	sp, #56	; 0x38
    4cc2:	pop	{r4, r5, r6, pc}

00004cc4 <exFatDirChecksum(unsigned char const*, unsigned short)>:
  return false;
}
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
    4cc4:	push	{r4, lr}
  bool skip = data[0] == EXFAT_TYPE_FILE;
    4cc6:	ldrb	r4, [r0, #0]
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    4cc8:	movs	r3, #0
    4cca:	lsls	r2, r1, #15
    4ccc:	orr.w	r1, r2, r1, lsr #1
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    4cd0:	ldrb	r2, [r0, r3]
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    4cd2:	cmp	r3, #1
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    4cd4:	uxtah	r1, r2, r1
    4cd8:	uxth	r1, r1
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    4cda:	bne.n	4ce6 <exFatDirChecksum(unsigned char const*, unsigned short)+0x22>
    4cdc:	cmp	r4, #133	; 0x85
    4cde:	ite	ne
    4ce0:	movne	r2, #1
    4ce2:	moveq	r2, #3
    4ce4:	b.n	4ce8 <exFatDirChecksum(unsigned char const*, unsigned short)+0x24>
    4ce6:	movs	r2, #1
    4ce8:	add	r3, r2
    4cea:	cmp	r3, #31
    4cec:	bls.n	4cca <exFatDirChecksum(unsigned char const*, unsigned short)+0x6>
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
  }
  return checksum;
}
    4cee:	mov	r0, r1
    4cf0:	pop	{r4, pc}

00004cf2 <ExFatPartition::cacheSync()>:
#if USE_EXFAT_BITMAP_CACHE
    m_bitmapCache.init(dev);
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
    4cf2:	push	{r4, lr}
    4cf4:	mov	r4, r0
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    4cf6:	bl	381a <FsCache::sync()>
    4cfa:	cbz	r0, 4d14 <ExFatPartition::cacheSync()+0x22>
    4cfc:	add.w	r0, r4, #528	; 0x210
    4d00:	bl	381a <FsCache::sync()>
    4d04:	cbz	r0, 4d14 <ExFatPartition::cacheSync()+0x22>
    4d06:	ldr.w	r0, [r4, #1088]	; 0x440
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    4d0a:	ldr	r3, [r0, #0]
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
#else  // USE_EXFAT_BITMAP_CACHE
    return m_dataCache.sync() && syncDevice();
#endif  // USE_EXFAT_BITMAP_CACHE
  }
    4d0c:	ldmia.w	sp!, {r4, lr}
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    4d10:	ldr	r3, [r3, #28]
    4d12:	bx	r3
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
#else  // USE_EXFAT_BITMAP_CACHE
    return m_dataCache.sync() && syncDevice();
#endif  // USE_EXFAT_BITMAP_CACHE
  }
    4d14:	movs	r0, #0
    4d16:	pop	{r4, pc}

00004d18 <ExFatFile::addCluster()>:
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
    4d18:	push	{r3, r4, r5, r6, r7, lr}
    4d1a:	mov	r4, r0
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    4d1c:	ldr	r0, [r0, #32]
    4d1e:	ldr	r1, [r4, #24]
    4d20:	cbz	r1, 4d24 <ExFatFile::addCluster()+0xc>
    4d22:	adds	r1, #1
    4d24:	movs	r2, #1
    4d26:	bl	4862 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  if (find < 2) {
    4d2a:	cmp	r0, #1
  }
  return checksum;
}
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    4d2c:	mov	r5, r0
  if (find < 2) {
    4d2e:	bhi.n	4d34 <ExFatFile::addCluster()+0x1c>
 done:
  m_curCluster = find;
  return true;

 fail:
  return false;
    4d30:	movs	r6, #0
    4d32:	b.n	4da6 <ExFatFile::addCluster()+0x8e>
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
  if (find < 2) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    4d34:	movs	r3, #1
    4d36:	mov	r1, r0
    4d38:	mov	r2, r3
    4d3a:	ldr	r0, [r4, #32]
    4d3c:	bl	4908 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4d40:	mov	r6, r0
    4d42:	cmp	r0, #0
    4d44:	beq.n	4d30 <ExFatFile::addCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    4d46:	ldr	r2, [r4, #24]
    m_flags |= FILE_FLAG_CONTIGUOUS;
    4d48:	ldrb.w	r3, [r4, #51]	; 0x33
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    4d4c:	cbnz	r2, 4d58 <ExFatFile::addCluster()+0x40>
    m_flags |= FILE_FLAG_CONTIGUOUS;
    4d4e:	orr.w	r3, r3, #64	; 0x40
    4d52:	strb.w	r3, [r4, #51]	; 0x33
    goto done;
    4d56:	b.n	4da4 <ExFatFile::addCluster()+0x8c>
  }
  if (isContiguous()) {
    4d58:	lsls	r1, r3, #25
    4d5a:	bpl.n	4d84 <ExFatFile::addCluster()+0x6c>
    if (find == (m_curCluster + 1)) {
    4d5c:	adds	r2, #1
    4d5e:	cmp	r5, r2
    4d60:	beq.n	4da4 <ExFatFile::addCluster()+0x8c>
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    4d62:	bic.w	r3, r3, #64	; 0x40

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    4d66:	ldr	r1, [r4, #28]
  if (isContiguous()) {
    if (find == (m_curCluster + 1)) {
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    4d68:	strb.w	r3, [r4, #51]	; 0x33

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    4d6c:	ldr	r3, [r4, #24]
    4d6e:	cmp	r1, r3
    4d70:	bcs.n	4d84 <ExFatFile::addCluster()+0x6c>
      if (!m_vol->fatPut(c, c + 1)) {
    4d72:	adds	r7, r1, #1
    4d74:	mov	r2, r7
    4d76:	ldr	r0, [r4, #32]
    4d78:	bl	4a90 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4d7c:	cmp	r0, #0
    4d7e:	beq.n	4d30 <ExFatFile::addCluster()+0x18>
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    4d80:	mov	r1, r7
    4d82:	b.n	4d6c <ExFatFile::addCluster()+0x54>
        goto fail;
      }
    }
  }
  // New cluster is EOC.
  if (!m_vol->fatPut(find, EXFAT_EOC)) {
    4d84:	mov.w	r2, #4294967295
    4d88:	mov	r1, r5
    4d8a:	ldr	r0, [r4, #32]
    4d8c:	bl	4a90 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4d90:	cmp	r0, #0
    4d92:	beq.n	4d30 <ExFatFile::addCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Connect new cluster to existing chain.
  if (m_curCluster) {
    4d94:	ldr	r1, [r4, #24]
    4d96:	cbz	r1, 4da4 <ExFatFile::addCluster()+0x8c>
    if (!m_vol->fatPut(m_curCluster, find)) {
    4d98:	mov	r2, r5
    4d9a:	ldr	r0, [r4, #32]
    4d9c:	bl	4a90 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4da0:	cmp	r0, #0
    4da2:	beq.n	4d30 <ExFatFile::addCluster()+0x18>
      goto fail;
    }
  }

 done:
  m_curCluster = find;
    4da4:	str	r5, [r4, #24]
  return true;

 fail:
  return false;
}
    4da6:	mov	r0, r6
    4da8:	pop	{r3, r4, r5, r6, r7, pc}

00004daa <ExFatFile::remove()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    4daa:	push	{r4, r5, r6, lr}
    4dac:	ldrb.w	r3, [r0, #51]	; 0x33
  uint8_t* cache;
  if (!isWritable()) {
    4db0:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    4db2:	mov	r4, r0
  uint8_t* cache;
  if (!isWritable()) {
    4db4:	bmi.n	4dba <ExFatFile::remove()+0x10>

  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
    4db6:	movs	r0, #0
    4db8:	pop	{r4, r5, r6, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    4dba:	ldr	r5, [r0, #28]
    4dbc:	cbnz	r5, 4dc2 <ExFatFile::remove()+0x18>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    4dbe:	movs	r5, #0
    4dc0:	b.n	4e14 <ExFatFile::remove()+0x6a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    if (isContiguous()) {
    4dc2:	lsls	r3, r3, #25
    4dc4:	bpl.n	4df0 <ExFatFile::remove()+0x46>
      uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    4dc6:	ldr	r6, [r0, #32]
      if (!m_vol->bitmapModify(m_firstCluster, nc, 0)) {
    4dc8:	ldrd	r0, r1, [r0, #8]
    4dcc:	ldrb.w	r2, [r6, #1093]	; 0x445
    4dd0:	adds.w	r0, r0, #4294967295
    4dd4:	add.w	r2, r2, #9
    4dd8:	uxtb	r2, r2
    4dda:	adc.w	r1, r1, #4294967295
    4dde:	bl	a530 <__aeabi_llsr>
    4de2:	movs	r3, #0
    4de4:	adds	r2, r0, #1
    4de6:	mov	r1, r5
    4de8:	mov	r0, r6
    4dea:	bl	4908 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4dee:	b.n	4df8 <ExFatFile::remove()+0x4e>
        DBG_FAIL_MACRO;
        goto fail;
      }
    } else {
      if (!m_vol->freeChain(m_firstCluster)) {
    4df0:	mov	r1, r5
    4df2:	ldr	r0, [r0, #32]
    4df4:	bl	4aca <ExFatPartition::freeChain(unsigned long)>
    4df8:	cmp	r0, #0
    4dfa:	bne.n	4dbe <ExFatFile::remove()+0x14>
    4dfc:	b.n	4db6 <ExFatFile::remove()+0xc>
      }
    }
  }

  for (uint8_t is = 0; is <= m_setCount; is++) {
    cache = dirCache(is, FsCache::CACHE_FOR_WRITE);
    4dfe:	movs	r2, #1
    4e00:	mov	r0, r4
    4e02:	bl	406e <ExFatFile::dirCache(unsigned char, unsigned char)>
    4e06:	adds	r5, #1
    if (!cache) {
    4e08:	cmp	r0, #0
    4e0a:	beq.n	4db6 <ExFatFile::remove()+0xc>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
    4e0c:	ldrb	r3, [r0, #0]
    4e0e:	and.w	r3, r3, #127	; 0x7f
    4e12:	strb	r3, [r0, #0]
        goto fail;
      }
    }
  }

  for (uint8_t is = 0; is <= m_setCount; is++) {
    4e14:	ldrb.w	r3, [r4, #48]	; 0x30
    4e18:	uxtb	r1, r5
    4e1a:	cmp	r3, r1
    4e1c:	bcs.n	4dfe <ExFatFile::remove()+0x54>
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
  }
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    4e1e:	movs	r3, #0
    4e20:	strb.w	r3, [r4, #49]	; 0x31
  m_flags = 0;
    4e24:	strb.w	r3, [r4, #51]	; 0x33

  // Write entry to device.
  return m_vol->cacheSync();
    4e28:	ldr	r0, [r4, #32]
    4e2a:	bl	4cf2 <ExFatPartition::cacheSync()>

 fail:
  return false;
}
    4e2e:	pop	{r4, r5, r6, pc}

00004e30 <ExFatFile::rmdir()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    4e30:	push	{r4, lr}
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    4e32:	ldrb.w	r3, [r0, #49]	; 0x31
    4e36:	lsls	r1, r3, #27

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    4e38:	sub	sp, #32
    4e3a:	mov	r4, r0
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    4e3c:	bmi.n	4e42 <ExFatFile::rmdir()+0x12>
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();

 fail:
  return false;
    4e3e:	movs	r0, #0
    4e40:	b.n	4e7e <ExFatFile::rmdir()+0x4e>
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    4e42:	movs	r2, #0
    4e44:	movs	r3, #0
    4e46:	bl	434c <ExFatFile::seekSet(unsigned long long)>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    n = read(dir, 32);
    4e4a:	movs	r2, #32
    4e4c:	mov	r1, sp
    4e4e:	mov	r0, r4
    4e50:	bl	419c <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    4e54:	cbz	r0, 4e66 <ExFatFile::rmdir()+0x36>
      break;
    }
    if (n != 32 || dir[0] & 0X80) {
    4e56:	cmp	r0, #32
    4e58:	bne.n	4e3e <ExFatFile::rmdir()+0xe>
    4e5a:	ldrb.w	r3, [sp]
    4e5e:	lsls	r2, r3, #24
    4e60:	bmi.n	4e3e <ExFatFile::rmdir()+0xe>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (dir[0] == 0) {
    4e62:	cmp	r3, #0
    4e64:	bne.n	4e4a <ExFatFile::rmdir()+0x1a>
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    4e66:	movs	r3, #8
    4e68:	strb.w	r3, [r4, #49]	; 0x31
  m_flags |= FILE_FLAG_WRITE;
    4e6c:	ldrb.w	r3, [r4, #51]	; 0x33
    4e70:	orr.w	r3, r3, #2
    4e74:	strb.w	r3, [r4, #51]	; 0x33
  return remove();
    4e78:	mov	r0, r4
    4e7a:	bl	4daa <ExFatFile::remove()>

 fail:
  return false;
}
    4e7e:	add	sp, #32
    4e80:	pop	{r4, pc}
    4e82:	Address 0x00004e82 is out of bounds.


00004e84 <ExFatFile::syncDir()>:
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    4e84:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    4e88:	movs	r6, #0
    }
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    4e8a:	ldr.w	r8, [pc, #212]	; 4f60 <ExFatFile::syncDir()+0xdc>
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    4e8e:	mov	r5, r0
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
    4e90:	mov	r7, r6

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    4e92:	ldrb.w	r3, [r5, #48]	; 0x30
    4e96:	uxtb	r1, r6
    4e98:	cmp	r3, r1
    4e9a:	bcc.n	4f32 <ExFatFile::syncDir()+0xae>
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    4e9c:	movs	r2, #0
    4e9e:	mov	r0, r5
    4ea0:	bl	406e <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache) {
    4ea4:	mov	r4, r0
    4ea6:	cmp	r0, #0
    4ea8:	beq.n	4f4a <ExFatFile::syncDir()+0xc6>
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    4eaa:	ldrb	r3, [r0, #0]
    4eac:	cmp	r3, #192	; 0xc0
    4eae:	beq.n	4eec <ExFatFile::syncDir()+0x68>
    4eb0:	cmp	r3, #193	; 0xc1
    4eb2:	beq.n	4f24 <ExFatFile::syncDir()+0xa0>
    4eb4:	cmp	r3, #133	; 0x85
    4eb6:	bne.n	4f4a <ExFatFile::syncDir()+0xc6>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    4eb8:	ldrb.w	r3, [r5, #49]	; 0x31
    4ebc:	and.w	r3, r3, #55	; 0x37
    4ec0:	strh	r3, [r0, #4]
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    4ec2:	ldr.w	r3, [r8]
    4ec6:	cbz	r3, 4f16 <ExFatFile::syncDir()+0x92>
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
    4ec8:	add.w	r2, sp, #3
    4ecc:	add.w	r1, sp, #6
    4ed0:	add	r0, sp, #4
    4ed2:	blx	r3
          df->modifyTimeMs = ms10;
    4ed4:	ldrb.w	r3, [sp, #3]
          setLe16(df->modifyTime, time);
    4ed8:	ldrh.w	r2, [sp, #6]
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
          df->modifyTimeMs = ms10;
    4edc:	strb	r3, [r4, #21]
          setLe16(df->modifyTime, time);
          setLe16(df->modifyDate, date);
    4ede:	ldrh.w	r3, [sp, #4]
    4ee2:	strh	r2, [r4, #12]
    4ee4:	strh	r3, [r4, #14]
    4ee6:	strh	r2, [r4, #16]
    4ee8:	strh	r3, [r4, #18]
    4eea:	b.n	4f16 <ExFatFile::syncDir()+0x92>
        m_vol->dataCacheDirty();
        break;

      case EXFAT_TYPE_STREAM:
        ds = reinterpret_cast<DirStream_t*>(cache);
        if (isContiguous()) {
    4eec:	ldrb.w	r3, [r5, #51]	; 0x33
    4ef0:	tst.w	r3, #64	; 0x40
    4ef4:	ldrb	r3, [r0, #1]
          ds->flags |= EXFAT_FLAG_CONTIGUOUS;
    4ef6:	ite	ne
    4ef8:	orrne.w	r3, r3, #2
        } else {
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
    4efc:	biceq.w	r3, r3, #2
    4f00:	strb	r3, [r0, #1]
        }
        setLe64(ds->validLength, m_validLength);
    4f02:	ldrd	r2, r3, [r5, #16]

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    4f06:	strd	r2, r3, [r0, #8]
        setLe32(ds->firstCluster, m_firstCluster);
    4f0a:	ldr	r3, [r5, #28]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    4f0c:	str	r3, [r0, #20]
        setLe64(ds->dataLength, m_dataLength);
    4f0e:	ldrd	r2, r3, [r5, #8]
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    4f12:	strd	r2, r3, [r0, #24]
        m_vol->dataCacheDirty();
    4f16:	ldr	r2, [r5, #32]
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    4f18:	ldrb.w	r3, [r2, #528]	; 0x210
    4f1c:	orr.w	r3, r3, #1
    4f20:	strb.w	r3, [r2, #528]	; 0x210
      default:
        DBG_FAIL_MACRO;
        goto fail;
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
    4f24:	mov	r1, r7
    4f26:	mov	r0, r4
    4f28:	bl	4cc4 <exFatDirChecksum(unsigned char const*, unsigned short)>
    4f2c:	adds	r6, #1
    4f2e:	mov	r7, r0
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    4f30:	b.n	4e92 <ExFatFile::syncDir()+0xe>
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
  }
  df = reinterpret_cast<DirFile_t*>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
    4f32:	movs	r2, #1
    4f34:	add.w	r1, r5, #36	; 0x24
    4f38:	ldr	r0, [r5, #32]
    4f3a:	bl	49ae <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    4f3e:	cbz	r0, 4f4a <ExFatFile::syncDir()+0xc6>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    4f40:	strh	r7, [r0, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe16(df->setChecksum, checksum);
  if (!m_vol->cacheSync()) {
    4f42:	ldr	r0, [r5, #32]
    4f44:	bl	4cf2 <ExFatPartition::cacheSync()>
    4f48:	cbnz	r0, 4f58 <ExFatFile::syncDir()+0xd4>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    4f4a:	ldrb.w	r3, [r5, #50]	; 0x32
    4f4e:	orr.w	r3, r3, #1
    4f52:	strb.w	r3, [r5, #50]	; 0x32
  return false;
    4f56:	movs	r0, #0
}
    4f58:	add	sp, #8
    4f5a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4f5e:	nop
    4f60:	.word	0x2001a690

00004f64 <ExFatFile::sync()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
    4f64:	push	{r4, lr}
  if (!isOpen()) {
    4f66:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
    4f6a:	mov	r4, r0
  if (!isOpen()) {
    4f6c:	cbnz	r3, 4f72 <ExFatFile::sync()+0xe>
    return true;
    4f6e:	movs	r0, #1
    4f70:	pop	{r4, pc}
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    4f72:	ldrb.w	r3, [r0, #51]	; 0x33
    4f76:	lsls	r2, r3, #24
    4f78:	bpl.n	4f8a <ExFatFile::sync()+0x26>
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    4f7a:	and.w	r3, r3, #127	; 0x7f
    4f7e:	strb.w	r3, [r0, #51]	; 0x33
  return true;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    4f82:	ldmia.w	sp!, {r4, lr}
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    return syncDir();
    4f86:	b.w	4e84 <ExFatFile::syncDir()>
  }
  if (!m_vol->cacheSync()) {
    4f8a:	ldr	r0, [r0, #32]
    4f8c:	bl	4cf2 <ExFatPartition::cacheSync()>
    4f90:	cmp	r0, #0
    4f92:	bne.n	4f6e <ExFatFile::sync()+0xa>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    4f94:	ldrb.w	r3, [r4, #50]	; 0x32
    4f98:	orr.w	r3, r3, #1
    4f9c:	strb.w	r3, [r4, #50]	; 0x32
  return false;
}
    4fa0:	pop	{r4, pc}

00004fa2 <ExFatFile::addDirCluster()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    4fa2:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    4fa6:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    4faa:	mov	r4, r0
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    4fac:	lsls	r0, r3, #25
    4fae:	bpl.n	4fb8 <ExFatFile::addDirCluster()+0x16>
    4fb0:	ldr	r0, [r4, #32]
    4fb2:	bl	4c58 <ExFatPartition::rootLength()>
    4fb6:	b.n	4fba <ExFatFile::addDirCluster()+0x18>
    4fb8:	ldr	r0, [r4, #8]
    4fba:	ldr	r3, [r4, #32]
  uint8_t* cache;
  dl += m_vol->bytesPerCluster();
  if (dl >= 0X4000000) {
    4fbc:	ldr.w	r3, [r3, #1084]	; 0x43c
    4fc0:	add	r0, r3
    4fc2:	cmp.w	r0, #67108864	; 0x4000000
    4fc6:	bcs.n	507a <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    4fc8:	mov	r0, r4
    4fca:	bl	4d18 <ExFatFile::addCluster()>
    4fce:	cmp	r0, #0
    4fd0:	beq.n	507a <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  cache =  m_vol->cacheClear();
    4fd2:	ldr	r5, [r4, #32]
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    if (isDirty() && !sync()) {
    4fd4:	ldrb.w	r3, [r5, #528]	; 0x210
    4fd8:	lsls	r1, r3, #31
    4fda:	bpl.n	4fe8 <ExFatFile::addDirCluster()+0x46>
    4fdc:	add.w	r0, r5, #528	; 0x210
    4fe0:	bl	381a <FsCache::sync()>
    4fe4:	cmp	r0, #0
    4fe6:	beq.n	507a <ExFatFile::addDirCluster()+0xd8>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    4fe8:	mov.w	r3, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4fec:	movs	r6, #0
    m_sector = 0XFFFFFFFF;
    4fee:	str.w	r3, [r5, #540]	; 0x21c
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4ff2:	strb.w	r6, [r5, #528]	; 0x210
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    4ff6:	add.w	r5, r5, #544	; 0x220
  if (!cache) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
    4ffa:	mov.w	r2, #512	; 0x200
    4ffe:	mov	r1, r6
    5000:	mov	r0, r5
    5002:	bl	90bc <memset>
  sector = m_vol->clusterStartSector(m_curCluster);
    5006:	ldr	r2, [r4, #32]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    5008:	ldr	r3, [r4, #24]
    500a:	ldrb.w	r1, [r2, #1093]	; 0x445
    500e:	ldr.w	r7, [r2, #1068]	; 0x42c
    5012:	subs	r3, #2
    5014:	lsls	r3, r1
    5016:	add	r7, r3
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    5018:	mov.w	r8, #1
    501c:	ldr	r3, [r4, #32]
    501e:	ldrb.w	r2, [r3, #1093]	; 0x445
    5022:	lsl.w	r2, r8, r2
    5026:	cmp	r2, r6
    5028:	bls.n	503e <ExFatFile::addDirCluster()+0x9c>
    502a:	ldr.w	r0, [r3, #1088]	; 0x440
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    502e:	ldr	r3, [r0, #0]
    5030:	mov	r2, r5
    5032:	ldr	r3, [r3, #32]
    5034:	adds	r1, r7, r6
    5036:	blx	r3
    if (!m_vol->writeSector(sector + i, cache)) {
    5038:	cbz	r0, 507a <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
  sector = m_vol->clusterStartSector(m_curCluster);
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    503a:	adds	r6, #1
    503c:	b.n	501c <ExFatFile::addDirCluster()+0x7a>
    if (!m_vol->writeSector(sector + i, cache)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  if (!isRoot()) {
    503e:	ldrb.w	r2, [r4, #49]	; 0x31
    5042:	lsls	r2, r2, #25
    5044:	bmi.n	5070 <ExFatFile::addDirCluster()+0xce>
    m_flags |= FILE_FLAG_DIR_DIRTY;
    5046:	ldrb.w	r2, [r4, #51]	; 0x33
    504a:	orn	r2, r2, #127	; 0x7f
    m_dataLength  += m_vol->bytesPerCluster();
    504e:	ldrd	r0, r1, [r4, #8]
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    5052:	strb.w	r2, [r4, #51]	; 0x33
    m_dataLength  += m_vol->bytesPerCluster();
    5056:	ldr.w	r2, [r3, #1084]	; 0x43c
    505a:	movs	r3, #0
    505c:	adds	r0, r0, r2
    505e:	adcs	r1, r3
    5060:	strd	r0, r1, [r4, #8]
    m_validLength += m_vol->bytesPerCluster();
    5064:	ldrd	r0, r1, [r4, #16]
    5068:	adds	r2, r2, r0
    506a:	adcs	r3, r1
    506c:	strd	r2, r3, [r4, #16]
  }
  return sync();
    5070:	mov	r0, r4

 fail:
  return false;
}
    5072:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    m_validLength += m_vol->bytesPerCluster();
  }
  return sync();
    5076:	b.w	4f64 <ExFatFile::sync()>

 fail:
  return false;
}
    507a:	movs	r0, #0
    507c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00005080 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    5080:	push	{r4, lr}
  if (!parent->isDir()) {
    5082:	ldrb.w	r3, [r1, #49]	; 0x31
    5086:	tst.w	r3, #80	; 0x50

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    508a:	mov	r4, r0
  if (!parent->isDir()) {
    508c:	beq.n	50c4 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!openPrivate(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    508e:	movw	r3, #2562	; 0xa02
    5092:	bl	441c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    5096:	cbz	r0, 50c4 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_attributes = FILE_ATTR_SUBDIR;
    5098:	movs	r3, #16
    509a:	strb.w	r3, [r4, #49]	; 0x31

  // allocate and zero first cluster
  if (!addDirCluster()) {
    509e:	mov	r0, r4
    50a0:	bl	4fa2 <ExFatFile::addDirCluster()>
    50a4:	cbz	r0, 50c4 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    50a6:	ldr	r3, [r4, #24]
    50a8:	str	r3, [r4, #28]
    50aa:	mov	r0, r4
    50ac:	movs	r3, #0
    50ae:	movs	r2, #0
    50b0:	bl	434c <ExFatFile::seekSet(unsigned long long)>

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    50b4:	movs	r3, #193	; 0xc1
    50b6:	strb.w	r3, [r4, #51]	; 0x33
  return sync();
    50ba:	mov	r0, r4

 fail:
  return false;
}
    50bc:	ldmia.w	sp!, {r4, lr}
  m_firstCluster = m_curCluster;

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();
    50c0:	b.w	4f64 <ExFatFile::sync()>

 fail:
  return false;
}
    50c4:	movs	r0, #0
    50c6:	pop	{r4, pc}

000050c8 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const char* path, bool pFlag) {
    50c8:	push	{r4, r5, r6, r7, lr}
    50ca:	sub	sp, #92	; 0x5c
    50cc:	mov	r7, r3
    50ce:	movs	r3, #0
    50d0:	strh.w	r3, [sp, #20]
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    50d4:	strb.w	r3, [sp, #81]	; 0x51
    50d8:	strb.w	r3, [sp, #82]	; 0x52
    50dc:	strb.w	r3, [sp, #83]	; 0x53
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    50e0:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const char* path, bool pFlag) {
    50e4:	str	r2, [sp, #4]
    50e6:	mov	r5, r0
    50e8:	mov	r4, r1
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    50ea:	cmp	r3, #0
    50ec:	bne.n	5180 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    50ee:	ldrb.w	r3, [r1, #49]	; 0x31
    50f2:	tst.w	r3, #80	; 0x50
    50f6:	beq.n	5180 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    50f8:	ldrb	r3, [r2, #0]
    50fa:	cmp	r3, #47	; 0x2f
    50fc:	bne.n	511a <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x52>
    while (isDirSeparator(*path)) {
    50fe:	ldr	r3, [sp, #4]
    5100:	ldrb	r2, [r3, #0]
    5102:	cmp	r2, #47	; 0x2f
    5104:	bne.n	510c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x44>
      path++;
    5106:	adds	r3, #1
    5108:	str	r3, [sp, #4]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    510a:	b.n	50fe <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x36>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    510c:	ldr	r1, [r4, #32]
    510e:	add	r0, sp, #32
    5110:	bl	40fa <ExFatFile::openRoot(ExFatVolume*)>
    5114:	cmp	r0, #0
    5116:	beq.n	5180 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    5118:	add	r4, sp, #32
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    511a:	add	r3, sp, #4
    511c:	add	r2, sp, #8
    511e:	ldr	r1, [sp, #4]
    5120:	mov	r0, r5
    5122:	bl	4120 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    5126:	cbz	r0, 5180 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    5128:	ldr	r3, [sp, #4]
    512a:	ldrb	r3, [r3, #0]
    512c:	cbz	r3, 5174 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xac>
      break;
    }
    if (!openPrivate(parent, &fname, O_RDONLY)) {
    512e:	movs	r3, #0
    5130:	add	r2, sp, #8
    5132:	mov	r1, r4
    5134:	mov	r0, r5
    5136:	bl	441c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    513a:	cbz	r0, 5162 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x9a>
      if (!pFlag || !mkdir(parent, &fname)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    513c:	add	r2, sp, #32
    513e:	mov	r3, r5
    5140:	add.w	lr, r5, #48	; 0x30
    5144:	mov	r4, r2
    5146:	ldr	r0, [r3, #0]
    5148:	ldr	r1, [r3, #4]
    514a:	mov	r6, r2
    514c:	stmia	r6!, {r0, r1}
    514e:	adds	r3, #8
    5150:	cmp	r3, lr
    5152:	mov	r2, r6
    5154:	bne.n	5146 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x7e>
    5156:	ldr	r0, [r3, #0]
    5158:	str	r0, [r6, #0]
    parent = &tmpDir;
    close();
    515a:	mov	r0, r5
    515c:	bl	40a6 <ExFatFile::close()>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    5160:	b.n	511a <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x52>
    }
    if (!*path) {
      break;
    }
    if (!openPrivate(parent, &fname, O_RDONLY)) {
      if (!pFlag || !mkdir(parent, &fname)) {
    5162:	cbz	r7, 5180 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    5164:	add	r2, sp, #8
    5166:	mov	r1, r4
    5168:	mov	r0, r5
    516a:	bl	5080 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    516e:	cmp	r0, #0
    5170:	bne.n	513c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x74>
    5172:	b.n	5180 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    5174:	add	r2, sp, #8
    5176:	mov	r1, r4
    5178:	mov	r0, r5
    517a:	bl	5080 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    517e:	b.n	5182 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xba>

 fail:
  return false;
    5180:	movs	r0, #0
}
    5182:	add	sp, #92	; 0x5c
    5184:	pop	{r4, r5, r6, r7, pc}

00005186 <ExFatFile::rename(ExFatFile*, char const*)>:
//------------------------------------------------------------------------------
bool ExFatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const char* newPath) {
    5186:	push	{r4, r5, r6, r7, lr}
    5188:	sub	sp, #116	; 0x74
    518a:	movs	r3, #0
    518c:	strb.w	r3, [sp, #49]	; 0x31
    5190:	strb.w	r3, [sp, #50]	; 0x32
    5194:	strb.w	r3, [sp, #51]	; 0x33
    5198:	strb.w	r3, [sp, #105]	; 0x69
    519c:	strb.w	r3, [sp, #106]	; 0x6a
    51a0:	strb.w	r3, [sp, #107]	; 0x6b
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    51a4:	ldrb.w	r3, [r0, #49]	; 0x31
    51a8:	tst.w	r3, #24
//------------------------------------------------------------------------------
bool ExFatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const char* newPath) {
    51ac:	mov	r4, r0
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    51ae:	bne.n	51b4 <ExFatFile::rename(ExFatFile*, char const*)+0x2e>
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();

 fail:
  return false;
    51b0:	movs	r0, #0
    51b2:	b.n	5228 <ExFatFile::rename(ExFatFile*, char const*)+0xa2>
  if (!(isFile() || isSubDir())) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    51b4:	ldr	r0, [r0, #32]
    51b6:	ldr	r3, [r1, #32]
    51b8:	cmp	r0, r3
    51ba:	bne.n	51b0 <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    51bc:	movw	r3, #2561	; 0xa01
    51c0:	mov	r0, sp
    51c2:	bl	476c <ExFatFile::open(ExFatFile*, char const*, int)>
    51c6:	cmp	r0, #0
    51c8:	beq.n	51b0 <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  oldFile = *this;
    51ca:	add	r2, sp, #56	; 0x38
    51cc:	mov	r3, r4
    51ce:	add.w	r7, r4, #48	; 0x30
    51d2:	mov	r6, r2
    51d4:	ldr	r0, [r3, #0]
    51d6:	ldr	r1, [r3, #4]
    51d8:	mov	r5, r2
    51da:	stmia	r5!, {r0, r1}
    51dc:	adds	r3, #8
    51de:	cmp	r3, r7
    51e0:	mov	r2, r5
    51e2:	bne.n	51d4 <ExFatFile::rename(ExFatFile*, char const*)+0x4e>
    51e4:	ldr	r0, [r3, #0]
    51e6:	str	r0, [r5, #0]
  m_dirPos = file.m_dirPos;
    51e8:	add	r2, sp, #36	; 0x24
    51ea:	ldmia	r2, {r0, r1, r2}
    51ec:	add.w	r3, r4, #36	; 0x24
    51f0:	stmia.w	r3, {r0, r1, r2}
  m_setCount = file.m_setCount;
    51f4:	ldrb.w	r3, [sp, #48]	; 0x30
    51f8:	strb.w	r3, [r4, #48]	; 0x30
  m_flags |= FILE_FLAG_DIR_DIRTY;
    51fc:	ldrb.w	r3, [r4, #51]	; 0x33
    5200:	orn	r3, r3, #127	; 0x7f
    5204:	strb.w	r3, [r4, #51]	; 0x33
  if (!sync()) {
    5208:	mov	r0, r4
    520a:	bl	4f64 <ExFatFile::sync()>
    520e:	cmp	r0, #0
    5210:	beq.n	51b0 <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    5212:	movs	r3, #0
    5214:	str	r3, [sp, #84]	; 0x54
  oldFile.m_flags = FILE_FLAG_WRITE;
    5216:	movs	r3, #2
    5218:	strb.w	r3, [sp, #107]	; 0x6b
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();
    521c:	mov	r0, r6
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
    521e:	movs	r3, #8
    5220:	strb.w	r3, [sp, #105]	; 0x69
  return oldFile.remove();
    5224:	bl	4daa <ExFatFile::remove()>

 fail:
  return false;
}
    5228:	add	sp, #116	; 0x74
    522a:	pop	{r4, r5, r6, r7, pc}

0000522c <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    522c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5230:	mov	r4, r3
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    5232:	ldrb.w	r3, [r0, #49]	; 0x31
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    5236:	ldrb.w	fp, [sp, #40]	; 0x28
    523a:	ldrb.w	sl, [sp, #44]	; 0x2c
    523e:	ldrb.w	r5, [sp, #48]	; 0x30
    5242:	ldrb.w	r9, [sp, #52]	; 0x34
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    5246:	lsls	r3, r3, #28
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    5248:	mov	r6, r0
    524a:	mov	r8, r1
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    524c:	bpl.n	52c0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
  uint16_t date;
  uint16_t time;
  uint8_t ms10;

  if (!isFile()
      || year < 1980
    524e:	subw	r2, r2, #1980	; 0x7bc
    5252:	uxth	r7, r2
    5254:	cmp	r7, #127	; 0x7f
    5256:	bhi.n	52c0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || year > 2107
      || month < 1
    5258:	subs	r3, r4, #1
    525a:	cmp	r3, #11
    525c:	bhi.n	52c0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || month > 12
      || day < 1
    525e:	add.w	r3, fp, #4294967295
    5262:	cmp	r3, #30
    5264:	bhi.n	52c0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || day > 31
      || hour > 23
    5266:	cmp.w	sl, #23
    526a:	bhi.n	52c0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || minute > 59
    526c:	cmp	r5, #59	; 0x3b
    526e:	bhi.n	52c0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || second > 59) {
    5270:	cmp.w	r9, #59	; 0x3b
    5274:	bhi.n	52c0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // update directory entry
  if (!sync()) {
    5276:	bl	4f64 <ExFatFile::sync()>
    527a:	cbz	r0, 52c0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    527c:	mov.w	r3, r9, asr #1
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    5280:	orr.w	r4, fp, r4, lsl #5
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    5284:	orr.w	r5, r3, r5, lsl #5
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    5288:	orr.w	r4, r4, r7, lsl #9
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    528c:	orr.w	r5, r5, sl, lsl #11
    goto fail;
  }

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;
    5290:	tst.w	r9, #1
    5294:	mov.w	r7, #0
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    5298:	uxth	r4, r4
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    529a:	uxth	r5, r5
    529c:	ite	eq
    529e:	moveq.w	r9, #0
    52a2:	movne.w	r9, #100	; 0x64
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
  DirFile_t* df;
  uint8_t* cache;
  uint16_t checksum = 0;
    52a6:	mov	fp, r7
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        m_vol->dataCacheDirty();
        if (flags & T_ACCESS) {
    52a8:	and.w	sl, r8, #1

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    52ac:	ldrb.w	r3, [r6, #48]	; 0x30
    52b0:	uxtb	r1, r7
    52b2:	cmp	r3, r1
    52b4:	bcc.n	5320 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xf4>
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    52b6:	movs	r2, #0
    52b8:	mov	r0, r6
    52ba:	bl	406e <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache) {
    52be:	cbnz	r0, 52c6 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x9a>
    goto fail;
  }
  return true;

 fail:
  return false;
    52c0:	movs	r0, #0
    52c2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    52c6:	ldrb	r3, [r0, #0]
    52c8:	cmp	r3, #133	; 0x85
    52ca:	beq.n	52d6 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xaa>
    52cc:	bcc.n	52c0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    52ce:	subs	r3, #192	; 0xc0
    52d0:	cmp	r3, #1
    52d2:	bls.n	5314 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xe8>
    52d4:	b.n	52c0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    52d6:	ldrb.w	r3, [r6, #49]	; 0x31
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        m_vol->dataCacheDirty();
    52da:	ldr	r2, [r6, #32]
    52dc:	and.w	r3, r3, #55	; 0x37
    52e0:	strh	r3, [r0, #4]
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    52e2:	ldrb.w	r3, [r2, #528]	; 0x210
    52e6:	orr.w	r3, r3, #1
    52ea:	strb.w	r3, [r2, #528]	; 0x210
        if (flags & T_ACCESS) {
    52ee:	cmp.w	sl, #0
    52f2:	beq.n	52f8 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xcc>
    52f4:	strh	r5, [r0, #16]
    52f6:	strh	r4, [r0, #18]
          setLe16(df->accessTime, time);
          setLe16(df->accessDate, date);
        }
        if (flags & T_CREATE) {
    52f8:	tst.w	r8, #2
          df->createTimeMs = ms10;
    52fc:	ittt	ne
    52fe:	strbne.w	r9, [r0, #20]
    5302:	strhne	r5, [r0, #8]
    5304:	strhne	r4, [r0, #10]
          setLe16(df->createTime, time);
          setLe16(df->createDate, date);
        }
        if (flags & T_WRITE) {
    5306:	tst.w	r8, #4
          df->modifyTimeMs = ms10;
    530a:	ittt	ne
    530c:	strbne.w	r9, [r0, #21]
    5310:	strhne	r5, [r0, #12]
    5312:	strhne	r4, [r0, #14]
      default:
        DBG_FAIL_MACRO;
        goto fail;
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
    5314:	mov	r1, fp
    5316:	bl	4cc4 <exFatDirChecksum(unsigned char const*, unsigned short)>
    531a:	adds	r7, #1
    531c:	mov	fp, r0

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    531e:	b.n	52ac <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x80>
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
  }
  df = reinterpret_cast<DirFile_t*>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
    5320:	movs	r2, #1
    5322:	add.w	r1, r6, #36	; 0x24
    5326:	ldr	r0, [r6, #32]
    5328:	bl	49ae <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    532c:	cmp	r0, #0
    532e:	beq.n	52c0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    5330:	strh.w	fp, [r0, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe16(df->setChecksum, checksum);
  if (!m_vol->cacheSync()) {
    5334:	ldr	r0, [r6, #32]
    5336:	bl	4cf2 <ExFatPartition::cacheSync()>
    533a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000533e <ExFatFile::truncate()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    533e:	push	{r0, r1, r4, r5, r6, lr}
    5340:	ldrb.w	r3, [r0, #51]	; 0x33
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    5344:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    5346:	mov	r4, r0
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    5348:	bmi.n	534e <ExFatFile::truncate()+0x10>
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    534a:	movs	r0, #0
    534c:	b.n	53f8 <ExFatFile::truncate()+0xba>
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    534e:	ldr	r5, [r0, #28]
    5350:	cmp	r5, #0
    5352:	beq.n	53d6 <ExFatFile::truncate()+0x98>
      return true;
  }
  if (isContiguous()) {
    5354:	and.w	r3, r3, #64	; 0x40
    5358:	and.w	r1, r3, #255	; 0xff
    535c:	ldr	r6, [r0, #24]
    535e:	cbz	r3, 539e <ExFatFile::truncate()+0x60>
    5360:	ldr	r3, [r4, #32]
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    5362:	ldrd	r0, r1, [r0, #8]
    5366:	ldrb.w	r2, [r3, #1093]	; 0x445
    536a:	adds.w	r0, r0, #4294967295
    536e:	add.w	r2, r2, #9
    5372:	uxtb	r2, r2
    5374:	adc.w	r1, r1, #4294967295
    5378:	bl	a530 <__aeabi_llsr>
    537c:	adds	r2, r0, #1
    if (m_curCluster) {
    537e:	cbz	r6, 538c <ExFatFile::truncate()+0x4e>
      toFree = m_curCluster + 1;
      nc -= 1 + m_curCluster - m_firstCluster;
    5380:	subs	r5, #1
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    5382:	adds	r3, r6, #1
      nc -= 1 + m_curCluster - m_firstCluster;
    5384:	subs	r5, r5, r6
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    5386:	str	r3, [sp, #4]
      nc -= 1 + m_curCluster - m_firstCluster;
    5388:	add	r2, r5
    538a:	b.n	5390 <ExFatFile::truncate()+0x52>
    } else {
      toFree = m_firstCluster;
    538c:	str	r5, [sp, #4]
      m_firstCluster = 0;
    538e:	str	r6, [r4, #28]
    }
    if (nc && !m_vol->bitmapModify(toFree, nc, 0)) {
    5390:	cbz	r2, 53da <ExFatFile::truncate()+0x9c>
    5392:	movs	r3, #0
    5394:	ldr	r1, [sp, #4]
    5396:	ldr	r0, [r4, #32]
    5398:	bl	4908 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    539c:	b.n	53d2 <ExFatFile::truncate()+0x94>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
    539e:	cbz	r6, 53c4 <ExFatFile::truncate()+0x86>
      toFree = 0;
    53a0:	add	r2, sp, #8
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    53a2:	ldr	r0, [r0, #32]
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
      toFree = 0;
    53a4:	str.w	r1, [r2, #-4]!
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    53a8:	mov	r1, r6
    53aa:	bl	49e4 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
      if (fg < 0) {
    53ae:	cmp	r0, #0
    53b0:	blt.n	534a <ExFatFile::truncate()+0xc>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (fg) {
    53b2:	beq.n	53c8 <ExFatFile::truncate()+0x8a>
        // current cluster is end of chain
        if (!m_vol->fatPut(m_curCluster, EXFAT_EOC)) {
    53b4:	mov.w	r2, #4294967295
    53b8:	ldr	r1, [r4, #24]
    53ba:	ldr	r0, [r4, #32]
    53bc:	bl	4a90 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    53c0:	cbnz	r0, 53c8 <ExFatFile::truncate()+0x8a>
    53c2:	b.n	534a <ExFatFile::truncate()+0xc>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
    } else {
      toFree = m_firstCluster;
    53c4:	str	r5, [sp, #4]
      m_firstCluster = 0;
    53c6:	str	r6, [r0, #28]
    }
    if (toFree) {
    53c8:	ldr	r1, [sp, #4]
    53ca:	cbz	r1, 53da <ExFatFile::truncate()+0x9c>
      if (!m_vol->freeChain(toFree)) {
    53cc:	ldr	r0, [r4, #32]
    53ce:	bl	4aca <ExFatPartition::freeChain(unsigned long)>
    53d2:	cbnz	r0, 53da <ExFatFile::truncate()+0x9c>
    53d4:	b.n	534a <ExFatFile::truncate()+0xc>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    53d6:	movs	r0, #1
    53d8:	b.n	53f8 <ExFatFile::truncate()+0xba>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  }
  m_dataLength = m_curPosition;
    53da:	ldrd	r2, r3, [r4]
    53de:	strd	r2, r3, [r4, #8]
  m_validLength = m_curPosition;
    53e2:	strd	r2, r3, [r4, #16]
  m_flags |= FILE_FLAG_DIR_DIRTY;
    53e6:	ldrb.w	r3, [r4, #51]	; 0x33
    53ea:	orn	r3, r3, #127	; 0x7f
    53ee:	strb.w	r3, [r4, #51]	; 0x33
  return sync();
    53f2:	mov	r0, r4
    53f4:	bl	4f64 <ExFatFile::sync()>

 fail:
  return false;
}
    53f8:	add	sp, #8
    53fa:	pop	{r4, r5, r6, pc}

000053fc <ExFatFile::write(void const*, unsigned int)>:
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    53fc:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5400:	ldrb.w	r3, [r0, #51]	; 0x33
    5404:	mov	r9, r1

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    5406:	lsls	r1, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    5408:	mov	r4, r0
    540a:	mov	sl, r2

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    540c:	bpl.w	5586 <ExFatFile::write(void const*, unsigned int)+0x18a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    5410:	lsls	r2, r3, #28
    5412:	bmi.n	5422 <ExFatFile::write(void const*, unsigned int)+0x26>
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    5414:	add.w	r3, r4, #24

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    5418:	mov	r8, sl
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    541a:	str	r3, [sp, #0]
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    541c:	mov.w	fp, #1
    5420:	b.n	54e8 <ExFatFile::write(void const*, unsigned int)+0xec>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_validLength)) {
    5422:	ldrd	r2, r3, [r0, #16]
    5426:	bl	434c <ExFatFile::seekSet(unsigned long long)>
    542a:	cmp	r0, #0
    542c:	bne.n	5414 <ExFatFile::write(void const*, unsigned int)+0x18>
    542e:	b.n	5586 <ExFatFile::write(void const*, unsigned int)+0x18a>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    clusterOffset = m_curPosition & m_vol->clusterMask();
    5430:	ldr	r0, [r4, #32]
    5432:	ldr	r6, [r4, #0]
    5434:	ldr.w	r3, [r0, #1080]	; 0x438
    5438:	ands	r6, r3
    sectorOffset = clusterOffset & m_vol->sectorMask();
    543a:	ubfx	r5, r6, #0, #9
    if (clusterOffset == 0) {
    543e:	cmp	r6, #0
    5440:	beq.n	54f0 <ExFatFile::write(void const*, unsigned int)+0xf4>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    sector = m_vol->clusterStartSector(m_curCluster) +
    5442:	ldr.w	lr, [r4, #32]
             (clusterOffset >> m_vol->bytesPerSectorShift());
    5446:	ldr	r1, [r4, #24]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    5448:	ldrb.w	r2, [lr, #1093]	; 0x445
    544c:	ldr.w	r3, [lr, #1068]	; 0x42c
    5450:	subs	r1, #2
    5452:	lsls	r1, r2
    5454:	lsrs	r6, r6, #9
    5456:	add	r1, r3
    5458:	add	r1, r6

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
    545a:	cmp	r5, #0
    545c:	bne.n	5558 <ExFatFile::write(void const*, unsigned int)+0x15c>
    545e:	cmp.w	r8, #512	; 0x200
    5462:	bcs.w	559a <ExFatFile::write(void const*, unsigned int)+0x19e>
      // lesser of space and amount to write
      if (n > toWrite) {
        n = toWrite;
      }

      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
    5466:	ldrd	r2, r3, [r4, #16]
    546a:	ldrd	r6, r7, [r4]
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    546e:	cmp	r7, r3
    5470:	it	eq
    5472:	cmpeq	r6, r2
    5474:	ite	cc
    5476:	movcc	r2, #1
    5478:	movcs	r2, #5
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    547a:	add.w	r0, lr, #528	; 0x210
    547e:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      cache = m_vol->dataCacheGet(sector, cacheOption);
      if (!cache) {
    5482:	cmp	r0, #0
    5484:	beq.n	5586 <ExFatFile::write(void const*, unsigned int)+0x18a>
             (clusterOffset >> m_vol->bytesPerSectorShift());

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    5486:	rsb	r6, r5, #512	; 0x200
    548a:	cmp	r6, r8
    548c:	it	cs
    548e:	movcs	r6, r8
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    5490:	add	r0, r5
    5492:	mov	r2, r6
    5494:	mov	r1, r9
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    5496:	add	r5, r6
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    5498:	bl	8f14 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    549c:	cmp.w	r5, #512	; 0x200
    54a0:	bne.n	54b0 <ExFatFile::write(void const*, unsigned int)+0xb4>
  }
  uint32_t dataCacheSector() {return m_dataCache.sector();}
  bool dataCacheSync() {return m_dataCache.sync();}
    54a2:	ldr	r0, [r4, #32]
    54a4:	add.w	r0, r0, #528	; 0x210
    54a8:	bl	381a <FsCache::sync()>
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeWrite(sector, src, ns)) {
    54ac:	cmp	r0, #0
    54ae:	beq.n	5586 <ExFatFile::write(void const*, unsigned int)+0x18a>
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    54b0:	ldrd	r0, r1, [r4]
    54b4:	adds	r2, r0, r6
    54b6:	adc.w	r3, r1, #0
    54ba:	mov	r0, r2
    54bc:	mov	r1, r3
    54be:	strd	r2, r3, [r4]
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    54c2:	ldrd	r2, r3, [r4, #16]
    54c6:	cmp	r3, r1
    54c8:	it	eq
    54ca:	cmpeq	r2, r0
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    src += n;
    54cc:	add	r9, r6
    toWrite -= n;
    54ce:	rsb	r8, r6, r8
    if (m_curPosition > m_validLength) {
    54d2:	bcs.n	54e8 <ExFatFile::write(void const*, unsigned int)+0xec>
      m_flags |= FILE_FLAG_DIR_DIRTY;
    54d4:	ldrb.w	r3, [r4, #51]	; 0x33
    54d8:	orn	r3, r3, #127	; 0x7f
    54dc:	strb.w	r3, [r4, #51]	; 0x33
      m_validLength = m_curPosition;
    54e0:	mov	r2, r0
    54e2:	mov	r3, r1
    54e4:	strd	r2, r3, [r4, #16]
    if (!seekSet(m_validLength)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    54e8:	cmp.w	r8, #0
    54ec:	bne.n	5430 <ExFatFile::write(void const*, unsigned int)+0x34>
    54ee:	b.n	555c <ExFatFile::write(void const*, unsigned int)+0x160>
    clusterOffset = m_curPosition & m_vol->clusterMask();
    sectorOffset = clusterOffset & m_vol->sectorMask();
    if (clusterOffset == 0) {
      // start of new cluster
      if (m_curCluster != 0) {
    54f0:	ldr	r7, [r4, #24]
    54f2:	cbz	r7, 5542 <ExFatFile::write(void const*, unsigned int)+0x146>
        int fg;

        if (isContiguous()) {
    54f4:	ldrb.w	r3, [r4, #51]	; 0x33
    54f8:	lsls	r3, r3, #25
    54fa:	bpl.n	5532 <ExFatFile::write(void const*, unsigned int)+0x136>
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    54fc:	ldrb.w	r2, [r0, #1093]	; 0x445
      // start of new cluster
      if (m_curCluster != 0) {
        int fg;

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
    5500:	ldr	r3, [r4, #28]
    5502:	str	r3, [sp, #4]
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    5504:	ldrd	r0, r1, [r4, #8]
    5508:	adds	r2, #9
    550a:	adds.w	r0, r0, #4294967295
    550e:	adc.w	r1, r1, #4294967295
    5512:	uxtb	r2, r2
    5514:	bl	a530 <__aeabi_llsr>
    5518:	ldr	r3, [sp, #4]
    551a:	add	r0, r3
    551c:	cmp	r7, r0
    551e:	bcc.n	552c <ExFatFile::write(void const*, unsigned int)+0x130>
            goto fail;
          }
        }
        if (fg == 0) {
          // add cluster if at end of chain
          if (!addCluster()) {
    5520:	mov	r0, r4
    5522:	bl	4d18 <ExFatFile::addCluster()>
    5526:	cmp	r0, #0
    5528:	bne.n	5442 <ExFatFile::write(void const*, unsigned int)+0x46>
    552a:	b.n	5586 <ExFatFile::write(void const*, unsigned int)+0x18a>

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
            m_curCluster++;
    552c:	adds	r7, #1
    552e:	str	r7, [r4, #24]
    5530:	b.n	5442 <ExFatFile::write(void const*, unsigned int)+0x46>
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    5532:	ldr	r2, [sp, #0]
    5534:	mov	r1, r7
    5536:	bl	49e4 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    553a:	cmp	r0, #0
    553c:	blt.n	5586 <ExFatFile::write(void const*, unsigned int)+0x18a>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
        if (fg == 0) {
    553e:	bne.n	5442 <ExFatFile::write(void const*, unsigned int)+0x46>
    5540:	b.n	5520 <ExFatFile::write(void const*, unsigned int)+0x124>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    5542:	ldr	r3, [r4, #28]
    5544:	cbnz	r3, 5554 <ExFatFile::write(void const*, unsigned int)+0x158>
          // allocate first cluster of file
          if (!addCluster()) {
    5546:	mov	r0, r4
    5548:	bl	4d18 <ExFatFile::addCluster()>
    554c:	cbz	r0, 5586 <ExFatFile::write(void const*, unsigned int)+0x18a>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    554e:	ldr	r3, [r4, #24]
    5550:	str	r3, [r4, #28]
    5552:	b.n	5442 <ExFatFile::write(void const*, unsigned int)+0x46>
        } else {
          m_curCluster = m_firstCluster;
    5554:	str	r3, [r4, #24]
    5556:	b.n	5442 <ExFatFile::write(void const*, unsigned int)+0x46>
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    5558:	movs	r2, #1
    555a:	b.n	547a <ExFatFile::write(void const*, unsigned int)+0x7e>
    if (m_curPosition > m_validLength) {
      m_flags |= FILE_FLAG_DIR_DIRTY;
      m_validLength = m_curPosition;
    }
  }
  if (m_curPosition > m_dataLength) {
    555c:	ldrd	r0, r1, [r4]
    5560:	ldrd	r2, r3, [r4, #8]
    5564:	cmp	r3, r1
    5566:	it	eq
    5568:	cmpeq	r2, r0
    556a:	bcs.n	5572 <ExFatFile::write(void const*, unsigned int)+0x176>
    m_dataLength = m_curPosition;
    556c:	strd	r0, r1, [r4, #8]
    5570:	b.n	5578 <ExFatFile::write(void const*, unsigned int)+0x17c>
    // update fileSize and insure sync will update dir entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    5572:	ldr	r3, [pc, #148]	; (5608 <ExFatFile::write(void const*, unsigned int)+0x20c>)
    5574:	ldr	r3, [r3, #0]
    5576:	cbz	r3, 5596 <ExFatFile::write(void const*, unsigned int)+0x19a>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    5578:	ldrb.w	r3, [r4, #51]	; 0x33
    557c:	orn	r3, r3, #127	; 0x7f
    5580:	strb.w	r3, [r4, #51]	; 0x33
    5584:	b.n	5596 <ExFatFile::write(void const*, unsigned int)+0x19a>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    5586:	ldrb.w	r3, [r4, #50]	; 0x32
    558a:	orr.w	r3, r3, #1
    558e:	strb.w	r3, [r4, #50]	; 0x32
  return 0;
    5592:	movs	r0, #0
    5594:	b.n	5602 <ExFatFile::write(void const*, unsigned int)+0x206>
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
  }
  return nbyte;
    5596:	mov	r0, sl
    5598:	b.n	5602 <ExFatFile::write(void const*, unsigned int)+0x206>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
    559a:	cmp.w	r8, #1024	; 0x400
    559e:	ldr.w	r7, [lr, #540]	; 0x21c
    55a2:	ldr.w	r0, [lr, #532]	; 0x214
    55a6:	bcc.n	55d2 <ExFatFile::write(void const*, unsigned int)+0x1d6>
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
      // Limit writes to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    55a8:	lsl.w	r3, fp, r2
    55ac:	subs	r6, r3, r6
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
    55ae:	mov.w	ip, r8, lsr #9
    55b2:	cmp	ip, r6
    55b4:	mov	r3, ip
    55b6:	it	cs
    55b8:	movcs	r3, r6
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    55ba:	cmp	r1, r7
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    55bc:	mov.w	r6, r3, lsl #9
    55c0:	bhi.n	55c8 <ExFatFile::write(void const*, unsigned int)+0x1cc>
    55c2:	adds	r2, r1, r3
    55c4:	cmp	r7, r2
    55c6:	bcc.n	55f4 <ExFatFile::write(void const*, unsigned int)+0x1f8>
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    55c8:	ldr	r2, [r0, #0]
    55ca:	ldr	r5, [r2, #36]	; 0x24
    55cc:	mov	r2, r9
    55ce:	blx	r5
    55d0:	b.n	54ac <ExFatFile::write(void const*, unsigned int)+0xb0>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    55d2:	cmp	r1, r7
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    55d4:	ittt	eq
    55d6:	strbeq.w	r5, [lr, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    55da:	moveq.w	r3, #4294967295
    55de:	streq.w	r3, [lr, #540]	; 0x21c
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    55e2:	ldr	r3, [r0, #0]
    55e4:	mov	r2, r9
    55e6:	ldr	r3, [r3, #32]
    55e8:	blx	r3
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    55ea:	cmp	r0, #0
    55ec:	beq.n	5586 <ExFatFile::write(void const*, unsigned int)+0x18a>
         DBG_FAIL_MACRO;
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
    55ee:	mov.w	r6, #512	; 0x200
    55f2:	b.n	54b0 <ExFatFile::write(void const*, unsigned int)+0xb4>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    55f4:	mov.w	r2, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    55f8:	strb.w	r5, [lr, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    55fc:	str.w	r2, [lr, #540]	; 0x21c
    5600:	b.n	55c8 <ExFatFile::write(void const*, unsigned int)+0x1cc>

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
  return 0;
}
    5602:	add	sp, #12
    5604:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5608:	.word	0x2001a690

0000560c <initFatDirCallback(unsigned long, void*)>:
  uint16_t count;
  uint16_t dotcount;
};
static const uint8_t * initFatDirCallback(uint32_t sector, void *context) {
  struct initFatDirState * state = (struct initFatDirState *)context;
  if (state->pr && ++state->count >= state->dotcount) {
    560c:	ldr	r0, [r1, #4]
  uint8_t * buffer;
  print_t * pr;
  uint16_t count;
  uint16_t dotcount;
};
static const uint8_t * initFatDirCallback(uint32_t sector, void *context) {
    560e:	push	{r4, lr}
    5610:	mov	r4, r1
  struct initFatDirState * state = (struct initFatDirState *)context;
  if (state->pr && ++state->count >= state->dotcount) {
    5612:	cbz	r0, 562c <initFatDirCallback(unsigned long, void*)+0x20>
    5614:	ldrh	r3, [r1, #8]
    5616:	ldrh	r2, [r1, #10]
    5618:	adds	r3, #1
    561a:	uxth	r3, r3
    561c:	cmp	r2, r3
    561e:	strh	r3, [r1, #8]
    5620:	bhi.n	562c <initFatDirCallback(unsigned long, void*)+0x20>
    state->pr->write(".");
    5622:	ldr	r1, [pc, #12]	; (5630 <initFatDirCallback(unsigned long, void*)+0x24>)
    5624:	bl	734 <Print::write(char const*)>
    state->count = 0;
    5628:	movs	r3, #0
    562a:	strh	r3, [r4, #8]
  }
  return state->buffer;
    562c:	ldr	r0, [r4, #0]
}
    562e:	pop	{r4, pc}
    5630:	.word	0x00012d35

00005634 <FatFormatter::initFatDir(unsigned char, unsigned long)>:
bool FatFormatter::initFatDir(uint8_t fatType, uint32_t sectorCount) {
    5634:	push	{r4, r5, r6, r7, lr}
    5636:	mov	r4, r0
    5638:	sub	sp, #28
    563a:	mov	r6, r1
    563c:	mov	r5, r2
  size_t n;
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    563e:	movs	r1, #0
    5640:	mov.w	r2, #512	; 0x200
    5644:	ldr	r0, [r0, #36]	; 0x24
    5646:	bl	90bc <memset>
  writeMsg("Writing FAT ");
    564a:	ldr	r0, [r4, #32]
    564c:	cbz	r0, 5654 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x20>
    564e:	ldr	r1, [pc, #128]	; (56d0 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x9c>)
    5650:	bl	734 <Print::write(char const*)>
  struct initFatDirState state;
  state.buffer = m_secBuf;
    5654:	ldr	r3, [r4, #36]	; 0x24
    5656:	str	r3, [sp, #12]
  state.pr = m_pr;
    5658:	ldr	r3, [r4, #32]
    565a:	str	r3, [sp, #16]
  state.count = 0;
  state.dotcount = sectorCount/32;
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    565c:	ldr	r0, [r4, #28]
    565e:	ldr	r1, [r4, #12]
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
  writeMsg("Writing FAT ");
  struct initFatDirState state;
  state.buffer = m_secBuf;
  state.pr = m_pr;
  state.count = 0;
    5660:	movs	r3, #0
    5662:	strh.w	r3, [sp, #20]
  state.dotcount = sectorCount/32;
    5666:	lsrs	r3, r5, #5
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    5668:	add	r2, sp, #12
  writeMsg("Writing FAT ");
  struct initFatDirState state;
  state.buffer = m_secBuf;
  state.pr = m_pr;
  state.count = 0;
  state.dotcount = sectorCount/32;
    566a:	strh.w	r3, [sp, #22]
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    566e:	ldr	r3, [r0, #0]
    5670:	str	r2, [sp, #0]
    5672:	ldr	r7, [r3, #40]	; 0x28
    5674:	ldr	r3, [pc, #92]	; (56d4 <FatFormatter::initFatDir(unsigned char, unsigned long)+0xa0>)
    5676:	subs	r2, r5, #1
    5678:	adds	r1, #1
    567a:	blx	r7
    567c:	cbnz	r0, 5682 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x4e>
     return false;
    567e:	movs	r0, #0
    5680:	b.n	56ca <FatFormatter::initFatDir(unsigned char, unsigned long)+0x96>
  }
  writeMsg("\r\n");
    5682:	ldr	r0, [r4, #32]
    5684:	cbz	r0, 568c <FatFormatter::initFatDir(unsigned char, unsigned long)+0x58>
    5686:	ldr	r1, [pc, #80]	; (56d8 <FatFormatter::initFatDir(unsigned char, unsigned long)+0xa4>)
    5688:	bl	734 <Print::write(char const*)>
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
    568c:	ldr	r3, [r4, #36]	; 0x24
    568e:	movs	r2, #248	; 0xf8
  n = fatType == 16 ? 4 : 12;
    5690:	cmp	r6, #16
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
     return false;
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
    5692:	strb	r2, [r3, #0]
  n = fatType == 16 ? 4 : 12;
  for (size_t i = 1; i < n; i++) {
    m_secBuf[i] = 0XFF;
    5694:	mov.w	r0, #255	; 0xff
     return false;
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
  n = fatType == 16 ? 4 : 12;
    5698:	ite	eq
    569a:	moveq	r2, #4
    569c:	movne	r2, #12
  for (size_t i = 1; i < n; i++) {
    569e:	movs	r3, #1
    m_secBuf[i] = 0XFF;
    56a0:	ldr	r1, [r4, #36]	; 0x24
    56a2:	strb	r0, [r1, r3]
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
  n = fatType == 16 ? 4 : 12;
  for (size_t i = 1; i < n; i++) {
    56a4:	adds	r3, #1
    56a6:	cmp	r2, r3
    56a8:	bne.n	56a0 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x6c>
    m_secBuf[i] = 0XFF;
  }
  return m_dev->writeSector(m_fatStart, m_secBuf) &&
    56aa:	ldr	r0, [r4, #28]
    56ac:	ldr	r2, [r4, #36]	; 0x24
    56ae:	ldr	r3, [r0, #0]
    56b0:	ldr	r1, [r4, #12]
    56b2:	ldr	r3, [r3, #32]
    56b4:	blx	r3
    56b6:	cmp	r0, #0
    56b8:	beq.n	567e <FatFormatter::initFatDir(unsigned char, unsigned long)+0x4a>
         m_dev->writeSector(m_fatStart + m_fatSize, m_secBuf);
    56ba:	ldr	r0, [r4, #28]
    56bc:	ldr	r5, [r4, #12]
    56be:	ldr	r1, [r4, #8]
    56c0:	ldr	r3, [r0, #0]
    56c2:	ldr	r2, [r4, #36]	; 0x24
    56c4:	ldr	r3, [r3, #32]
    56c6:	add	r1, r5
    56c8:	blx	r3
}
    56ca:	add	sp, #28
    56cc:	pop	{r4, r5, r6, r7, pc}
    56ce:	nop
    56d0:	.word	0x00012d28
    56d4:	.word	0x0000560d
    56d8:	.word	0x00012da7

000056dc <FatFormatter::initPbs()>:
//------------------------------------------------------------------------------
void FatFormatter::initPbs() {
    56dc:	push	{r3, r4, r5, lr}
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    56de:	ldr	r4, [r0, #36]	; 0x24
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    56e0:	mov.w	r2, #512	; 0x200
    56e4:	movs	r1, #0
  }
  return m_dev->writeSector(m_fatStart, m_secBuf) &&
         m_dev->writeSector(m_fatStart + m_fatSize, m_secBuf);
}
//------------------------------------------------------------------------------
void FatFormatter::initPbs() {
    56e6:	mov	r5, r0
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    56e8:	mov	r0, r4
    56ea:	bl	90bc <memset>
  pbs->jmpInstruction[0] = 0XEB;
    56ee:	movs	r3, #235	; 0xeb
    56f0:	strb	r3, [r4, #0]
  pbs->jmpInstruction[1] = 0X76;
    56f2:	movs	r3, #118	; 0x76
    56f4:	strb	r3, [r4, #1]
  pbs->jmpInstruction[2] = 0X90;
    56f6:	mov	r3, r4
    56f8:	movs	r2, #144	; 0x90
    56fa:	strb.w	r2, [r3, #2]!
  for (uint8_t i = 0; i < sizeof(pbs->oemName); i++) {
    pbs->oemName[i] = ' ';
    56fe:	movs	r1, #32
    5700:	add.w	r2, r4, #10
    5704:	strb.w	r1, [r3, #1]!
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
  pbs->jmpInstruction[0] = 0XEB;
  pbs->jmpInstruction[1] = 0X76;
  pbs->jmpInstruction[2] = 0X90;
  for (uint8_t i = 0; i < sizeof(pbs->oemName); i++) {
    5708:	cmp	r3, r2
    570a:	bne.n	5704 <FatFormatter::initPbs()+0x28>
    570c:	mov.w	r3, #512	; 0x200
    5710:	strh.w	r3, [r4, #11]
    pbs->oemName[i] = ' ';
  }
  setLe16(pbs->bpb.bpb16.bytesPerSector, BYTES_PER_SECTOR);
  pbs->bpb.bpb16.sectorsPerCluster = m_sectorsPerCluster;
    5714:	ldrb.w	r3, [r5, #43]	; 0x2b
    5718:	strb	r3, [r4, #13]
  setLe16(pbs->bpb.bpb16.reservedSectorCount, m_reservedSectorCount);
    571a:	ldrh	r3, [r5, #40]	; 0x28
    571c:	strh	r3, [r4, #14]
  pbs->bpb.bpb16.fatCount = 2;
    571e:	movs	r3, #2
    5720:	strb	r3, [r4, #16]
  // skip rootDirEntryCount
  // skip totalSectors16
  pbs->bpb.bpb16.mediaType = 0XF8;
    5722:	movs	r3, #248	; 0xf8
    5724:	strb	r3, [r4, #21]
  // skip sectorsPerFat16
  // skip sectorsPerTrack
  // skip headCount
  setLe32(pbs->bpb.bpb16.hidddenSectors, m_relativeSectors);
    5726:	ldr	r3, [r5, #16]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    5728:	str	r3, [r4, #28]
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
    572a:	ldr	r3, [r5, #24]
    572c:	str	r3, [r4, #32]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    572e:	movw	r3, #43605	; 0xaa55
    5732:	strh.w	r3, [r4, #510]	; 0x1fe
    5736:	pop	{r3, r4, r5, pc}

00005738 <FatFormatter::writeMbr()>:
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
}
//------------------------------------------------------------------------------
bool FatFormatter::writeMbr() {
    5738:	push	{r4, r5, r6, lr}
    573a:	mov	r4, r0
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    573c:	mov.w	r2, #512	; 0x200
    5740:	movs	r1, #0
    5742:	ldr	r0, [r0, #36]	; 0x24
    5744:	bl	90bc <memset>
  MbrSector_t* mbr = reinterpret_cast<MbrSector_t*>(m_secBuf);
    5748:	ldr	r5, [r4, #36]	; 0x24

#if USE_LBA_TO_CHS
  lbaToMbrChs(mbr->part->beginCHS, m_capacityMB, m_relativeSectors);
    574a:	ldr	r2, [r4, #16]
    574c:	ldr	r1, [r4, #0]
    574e:	addw	r0, r5, #447	; 0x1bf
    5752:	bl	378c <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>
  lbaToMbrChs(mbr->part->endCHS, m_capacityMB,
              m_relativeSectors + m_totalSectors -1);
    5756:	ldr	r3, [r4, #24]
    5758:	ldr	r2, [r4, #16]
    575a:	ldr	r1, [r4, #0]
    575c:	add	r2, r3
    575e:	addw	r0, r5, #451	; 0x1c3
    5762:	subs	r2, #1
    5764:	bl	378c <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
#endif  // USE_LBA_TO_CHS

  mbr->part->type = m_partType;
    5768:	ldrb.w	r3, [r4, #42]	; 0x2a
    576c:	strb.w	r3, [r5, #450]	; 0x1c2
  setLe32(mbr->part->relativeSectors, m_relativeSectors);
    5770:	ldr	r3, [r4, #16]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    5772:	str.w	r3, [r5, #454]	; 0x1c6
  setLe32(mbr->part->totalSectors, m_totalSectors);
    5776:	ldr	r3, [r4, #24]
  setLe16(mbr->signature, MBR_SIGNATURE);
  return m_dev->writeSector(0, m_secBuf);
    5778:	ldr	r0, [r4, #28]
    577a:	str.w	r3, [r5, #458]	; 0x1ca
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    577e:	movw	r3, #43605	; 0xaa55
    5782:	strh.w	r3, [r5, #510]	; 0x1fe
    5786:	ldr	r3, [r0, #0]
    5788:	ldr	r2, [r4, #36]	; 0x24
    578a:	ldr	r3, [r3, #32]
    578c:	movs	r1, #0
}
    578e:	ldmia.w	sp!, {r4, r5, r6, lr}

  mbr->part->type = m_partType;
  setLe32(mbr->part->relativeSectors, m_relativeSectors);
  setLe32(mbr->part->totalSectors, m_totalSectors);
  setLe16(mbr->signature, MBR_SIGNATURE);
  return m_dev->writeSector(0, m_secBuf);
    5792:	bx	r3

00005794 <FatFormatter::makeFat16()>:
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
  // skip rest of bpb
  setLe16(pbs->signature, PBR_SIGNATURE);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
    5794:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    5796:	mov.w	r3, #256	; 0x100
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    579a:	ldr	r5, [r0, #36]	; 0x24

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    579c:	ldr.w	lr, [r0, #20]
    57a0:	ldrb.w	r2, [r0, #43]	; 0x2b
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    57a4:	str	r3, [r0, #4]
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
  // skip rest of bpb
  setLe16(pbs->signature, PBR_SIGNATURE);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
    57a6:	mov	r4, r0
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    57a8:	ldr	r3, [r4, #4]
    57aa:	rsb	r1, r3, lr
    57ae:	udiv	r1, r1, r2
    m_fatSize = (nc + 2 + (BYTES_PER_SECTOR/2) - 1)/(BYTES_PER_SECTOR/2);
    57b2:	addw	r6, r1, #257	; 0x101
    57b6:	lsrs	r6, r6, #8
    r = BU16 + 1 + 2*m_fatSize + FAT16_ROOT_SECTOR_COUNT;
    57b8:	lsls	r0, r6, #1
    57ba:	add.w	r7, r0, #161	; 0xa1
    if (m_dataStart >= r) {
    57be:	cmp	r3, r7
    57c0:	bcc.n	57d8 <FatFormatter::makeFat16()+0x44>
      m_relativeSectors = m_dataStart - r + BU16;
    57c2:	subs	r3, r3, r7
    57c4:	str	r6, [r4, #8]
    57c6:	add.w	r6, r3, #128	; 0x80
    57ca:	str	r6, [r4, #16]
      break;
    }
  }
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    57cc:	subw	r6, r1, #4085	; 0xff5
    57d0:	cmp.w	r6, #61440	; 0xf000
    57d4:	bcs.n	57de <FatFormatter::makeFat16()+0x4a>
    57d6:	b.n	57ec <FatFormatter::makeFat16()+0x58>
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    57d8:	adds	r3, #128	; 0x80
    57da:	str	r3, [r4, #4]
    57dc:	b.n	57a8 <FatFormatter::makeFat16()+0x14>
      break;
    }
  }
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    57de:	ldr	r0, [r4, #32]
    57e0:	cmp	r0, #0
    57e2:	beq.n	588c <FatFormatter::makeFat16()+0xf8>
    57e4:	ldr	r1, [pc, #168]	; (5890 <FatFormatter::makeFat16()+0xfc>)
    57e6:	bl	734 <Print::write(char const*)>
    57ea:	b.n	588c <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  m_reservedSectorCount = 1;
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
    57ec:	adds	r3, #129	; 0x81
    57ee:	str	r3, [r4, #12]
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
    57f0:	add.w	r3, r0, #33	; 0x21
    57f4:	mla	r3, r1, r2, r3
  if (m_totalSectors < 65536) {
    57f8:	cmp.w	r3, #65536	; 0x10000
    return false;
  }
  m_reservedSectorCount = 1;
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
    57fc:	str	r3, [r4, #24]
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = 1;
    57fe:	mov.w	r6, #1
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
  if (m_totalSectors < 65536) {
    m_partType = 0X04;
    5802:	ite	cc
    5804:	movcc	r3, #4
  } else {
    m_partType = 0X06;
    5806:	movcs	r3, #6
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = 1;
    5808:	strh	r6, [r4, #40]	; 0x28
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
  if (m_totalSectors < 65536) {
    m_partType = 0X04;
  } else {
    m_partType = 0X06;
    580a:	strb.w	r3, [r4, #42]	; 0x2a
  }
  // write MBR
  if (!writeMbr()) {
    580e:	mov	r0, r4
    5810:	bl	5738 <FatFormatter::writeMbr()>
    5814:	cmp	r0, #0
    5816:	beq.n	588c <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  initPbs();
    5818:	mov	r0, r4
    581a:	bl	56dc <FatFormatter::initPbs()>
    581e:	mov.w	r3, #512	; 0x200
    5822:	strh.w	r3, [r5, #17]
    5826:	ldr	r3, [r4, #8]
    5828:	strh	r3, [r5, #22]
  setLe16(pbs->bpb.bpb16.rootDirEntryCount, FAT16_ROOT_ENTRY_COUNT);
  setLe16(pbs->bpb.bpb16.sectorsPerFat16, m_fatSize);
  pbs->bpb.bpb16.physicalDriveNumber = 0X80;
    582a:	movs	r3, #128	; 0x80
    582c:	strb.w	r3, [r5, #36]	; 0x24
  pbs->bpb.bpb16.extSignature = EXTENDED_BOOT_SIGNATURE;
    5830:	movs	r3, #41	; 0x29
    5832:	strb.w	r3, [r5, #38]	; 0x26
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    5836:	ldr	r3, [pc, #92]	; (5894 <FatFormatter::makeFat16()+0x100>)
    5838:	str.w	r3, [r5, #39]	; 0x27
    583c:	add.w	r2, r5, #53	; 0x35
    5840:	add.w	r3, r5, #42	; 0x2a
  setLe32(pbs->bpb.bpb16.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb16.volumeLabel); i++) {
    pbs->bpb.bpb16.volumeLabel[i] = ' ';
    5844:	movs	r1, #32
    5846:	strb.w	r1, [r3, #1]!
  setLe16(pbs->bpb.bpb16.rootDirEntryCount, FAT16_ROOT_ENTRY_COUNT);
  setLe16(pbs->bpb.bpb16.sectorsPerFat16, m_fatSize);
  pbs->bpb.bpb16.physicalDriveNumber = 0X80;
  pbs->bpb.bpb16.extSignature = EXTENDED_BOOT_SIGNATURE;
  setLe32(pbs->bpb.bpb16.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb16.volumeLabel); i++) {
    584a:	cmp	r3, r2
    584c:	bne.n	5846 <FatFormatter::makeFat16()+0xb2>
    pbs->bpb.bpb16.volumeLabel[i] = ' ';
  }
  pbs->bpb.bpb16.volumeType[0] = 'F';
    584e:	movs	r3, #70	; 0x46
    5850:	strb.w	r3, [r5, #54]	; 0x36
  pbs->bpb.bpb16.volumeType[1] = 'A';
    5854:	movs	r3, #65	; 0x41
    5856:	strb.w	r3, [r5, #55]	; 0x37
  pbs->bpb.bpb16.volumeType[2] = 'T';
    585a:	movs	r3, #84	; 0x54
    585c:	strb.w	r3, [r5, #56]	; 0x38
  pbs->bpb.bpb16.volumeType[3] = '1';
    5860:	movs	r3, #49	; 0x31
    5862:	strb.w	r3, [r5, #57]	; 0x39
  pbs->bpb.bpb16.volumeType[4] = '6';
    5866:	movs	r3, #54	; 0x36
    5868:	strb.w	r3, [r5, #58]	; 0x3a
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)) {
    586c:	ldr	r0, [r4, #28]
    586e:	ldr	r2, [r4, #36]	; 0x24
    5870:	ldr	r3, [r0, #0]
    5872:	ldr	r1, [r4, #16]
    5874:	ldr	r3, [r3, #32]
    5876:	blx	r3
    5878:	cbz	r0, 588c <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
    587a:	ldr	r2, [r4, #4]
    587c:	ldr	r3, [r4, #12]
    587e:	mov	r0, r4
    5880:	subs	r2, r2, r3
    5882:	movs	r1, #16
}
    5884:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  pbs->bpb.bpb16.volumeType[3] = '1';
  pbs->bpb.bpb16.volumeType[4] = '6';
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)) {
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
    5888:	b.w	5634 <FatFormatter::initFatDir(unsigned char, unsigned long)>
}
    588c:	movs	r0, #0
    588e:	pop	{r3, r4, r5, r6, r7, pc}
    5890:	.word	0x00012d81
    5894:	.word	0x0012d687

00005898 <FatFormatter::makeFat32()>:
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
    5898:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
    589a:	mov.w	r3, #8192	; 0x2000
    589e:	str	r3, [r0, #16]
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    58a0:	mov.w	r3, #16384	; 0x4000
    58a4:	str	r3, [r0, #4]
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    58a6:	ldr	r5, [r0, #36]	; 0x24
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    58a8:	ldr	r3, [r0, #20]
    58aa:	ldrb.w	r1, [r0, #43]	; 0x2b
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
    58ae:	mov	r4, r0
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    58b0:	ldr	r2, [r4, #4]
    58b2:	subs	r0, r3, r2
    58b4:	udiv	r0, r0, r1
    m_fatSize = (nc + 2 + (BYTES_PER_SECTOR/4) - 1)/(BYTES_PER_SECTOR/4);
    58b8:	add.w	r6, r0, #129	; 0x81
    58bc:	lsrs	r6, r6, #7
    r = m_relativeSectors + 9 + 2*m_fatSize;
    if (m_dataStart >= r) {
    58be:	mov.w	lr, r6, lsl #1
    58c2:	add.w	r7, lr, #8192	; 0x2000
    58c6:	adds	r7, #9
    58c8:	cmp	r2, r7
    58ca:	bcs.n	58d4 <FatFormatter::makeFat32()+0x3c>
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    58cc:	add.w	r2, r2, #8192	; 0x2000
    58d0:	str	r2, [r4, #4]
    58d2:	b.n	58b0 <FatFormatter::makeFat32()+0x18>
    if (m_dataStart >= r) {
      break;
    }
  }
  // error if too few clusters in FAT32 volume
  if (nc < 65525) {
    58d4:	movw	r3, #65524	; 0xfff4
    58d8:	cmp	r0, r3
    58da:	str	r6, [r4, #8]
    58dc:	bhi.n	58ee <FatFormatter::makeFat32()+0x56>
    writeMsg("Bad cluster count\r\n");
    58de:	ldr	r0, [r4, #32]
    58e0:	cmp	r0, #0
    58e2:	beq.w	5a26 <FatFormatter::makeFat32()+0x18e>
    58e6:	ldr	r1, [pc, #324]	; (5a2c <FatFormatter::makeFat32()+0x194>)
    58e8:	bl	734 <Print::write(char const*)>
    58ec:	b.n	5a26 <FatFormatter::makeFat32()+0x18e>
    return false;
  }
  m_reservedSectorCount = m_dataStart - m_relativeSectors - 2*m_fatSize;
    58ee:	sub.w	r3, r2, #8192	; 0x2000
    58f2:	rsb	r3, lr, r3
    58f6:	uxth	r3, r3
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster + m_dataStart - m_relativeSectors;
    58f8:	mla	r2, r0, r1, r2
  // error if too few clusters in FAT32 volume
  if (nc < 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = m_dataStart - m_relativeSectors - 2*m_fatSize;
    58fc:	strh	r3, [r4, #40]	; 0x28
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
    58fe:	add.w	r3, r3, #8192	; 0x2000
    5902:	str	r3, [r4, #12]
  m_totalSectors = nc*m_sectorsPerCluster + m_dataStart - m_relativeSectors;
    5904:	sub.w	r3, r2, #8192	; 0x2000
    5908:	str	r3, [r4, #24]
  // type depends on address of end sector
  // max CHS has lba = 16450560 = 1024*255*63
  if ((m_relativeSectors + m_totalSectors) <= 16450560) {
    590a:	ldr	r3, [pc, #292]	; (5a30 <FatFormatter::makeFat32()+0x198>)
    590c:	cmp	r2, r3
    // FAT32 with CHS and LBA
    m_partType = 0X0B;
    590e:	ite	ls
    5910:	movls	r3, #11
  } else {
    // FAT32 with only LBA
    m_partType = 0X0C;
    5912:	movhi	r3, #12
    5914:	strb.w	r3, [r4, #42]	; 0x2a
  }
  if (!writeMbr()) {
    5918:	mov	r0, r4
    591a:	bl	5738 <FatFormatter::writeMbr()>
    591e:	cmp	r0, #0
    5920:	beq.w	5a26 <FatFormatter::makeFat32()+0x18e>
    return false;
  }
  initPbs();
    5924:	mov	r0, r4
    5926:	bl	56dc <FatFormatter::initPbs()>
  setLe32(pbs->bpb.bpb32.sectorsPerFat32, m_fatSize);
    592a:	ldr	r3, [r4, #8]
    592c:	str	r3, [r5, #36]	; 0x24
    592e:	movs	r3, #2
    5930:	str	r3, [r5, #44]	; 0x2c
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    5932:	movs	r3, #1
    5934:	strh	r3, [r5, #48]	; 0x30
    5936:	movs	r3, #6
    5938:	strh	r3, [r5, #50]	; 0x32
  setLe32(pbs->bpb.bpb32.fat32RootCluster, 2);
  setLe16(pbs->bpb.bpb32.fat32FSInfoSector, 1);
  setLe16(pbs->bpb.bpb32.fat32BackBootSector, 6);
  pbs->bpb.bpb32.physicalDriveNumber = 0X80;
    593a:	movs	r3, #128	; 0x80
    593c:	strb.w	r3, [r5, #64]	; 0x40
  pbs->bpb.bpb32.extSignature = EXTENDED_BOOT_SIGNATURE;
    5940:	movs	r3, #41	; 0x29
    5942:	strb.w	r3, [r5, #66]	; 0x42
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    5946:	ldr	r3, [pc, #236]	; (5a34 <FatFormatter::makeFat32()+0x19c>)
    5948:	str.w	r3, [r5, #67]	; 0x43
    594c:	add.w	r2, r5, #81	; 0x51
    5950:	add.w	r3, r5, #70	; 0x46
  setLe32(pbs->bpb.bpb32.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb32.volumeLabel); i++) {
    pbs->bpb.bpb32.volumeLabel[i] = ' ';
    5954:	movs	r1, #32
    5956:	strb.w	r1, [r3, #1]!
  setLe16(pbs->bpb.bpb32.fat32FSInfoSector, 1);
  setLe16(pbs->bpb.bpb32.fat32BackBootSector, 6);
  pbs->bpb.bpb32.physicalDriveNumber = 0X80;
  pbs->bpb.bpb32.extSignature = EXTENDED_BOOT_SIGNATURE;
  setLe32(pbs->bpb.bpb32.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb32.volumeLabel); i++) {
    595a:	cmp	r3, r2
    595c:	bne.n	5956 <FatFormatter::makeFat32()+0xbe>
    pbs->bpb.bpb32.volumeLabel[i] = ' ';
  }
  pbs->bpb.bpb32.volumeType[0] = 'F';
    595e:	movs	r3, #70	; 0x46
    5960:	strb.w	r3, [r5, #82]	; 0x52
  pbs->bpb.bpb32.volumeType[1] = 'A';
    5964:	movs	r3, #65	; 0x41
    5966:	strb.w	r3, [r5, #83]	; 0x53
  pbs->bpb.bpb32.volumeType[2] = 'T';
    596a:	movs	r3, #84	; 0x54
    596c:	strb.w	r3, [r5, #84]	; 0x54
  pbs->bpb.bpb32.volumeType[3] = '3';
    5970:	movs	r3, #51	; 0x33
    5972:	strb.w	r3, [r5, #85]	; 0x55
  pbs->bpb.bpb32.volumeType[4] = '2';
    5976:	movs	r3, #50	; 0x32
    5978:	strb.w	r3, [r5, #86]	; 0x56
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)  ||
    597c:	ldr	r0, [r4, #28]
    597e:	ldr	r2, [r4, #36]	; 0x24
    5980:	ldr	r3, [r0, #0]
    5982:	ldr	r1, [r4, #16]
    5984:	ldr	r3, [r3, #32]
    5986:	blx	r3
    5988:	cmp	r0, #0
    598a:	beq.n	5a26 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 6, m_secBuf)) {
    598c:	ldr	r0, [r4, #28]
    598e:	ldr	r1, [r4, #16]
    5990:	ldr	r3, [r0, #0]
    5992:	ldr	r2, [r4, #36]	; 0x24
    5994:	ldr	r3, [r3, #32]
    5996:	adds	r1, #6
    5998:	blx	r3
  pbs->bpb.bpb32.volumeType[0] = 'F';
  pbs->bpb.bpb32.volumeType[1] = 'A';
  pbs->bpb.bpb32.volumeType[2] = 'T';
  pbs->bpb.bpb32.volumeType[3] = '3';
  pbs->bpb.bpb32.volumeType[4] = '2';
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)  ||
    599a:	cmp	r0, #0
    599c:	beq.n	5a26 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 6, m_secBuf)) {
    return false;
  }
  // write extra boot area and backup
  memset(m_secBuf, 0 , BYTES_PER_SECTOR);
    599e:	mov.w	r2, #512	; 0x200
    59a2:	movs	r1, #0
    59a4:	ldr	r0, [r4, #36]	; 0x24
    59a6:	bl	90bc <memset>
    59aa:	ldr	r3, [pc, #140]	; (5a38 <FatFormatter::makeFat32()+0x1a0>)
  setLe32(fsi->trailSignature, FSINFO_TRAIL_SIGNATURE);
  if (!m_dev->writeSector(m_relativeSectors + 2, m_secBuf)  ||
    59ac:	ldr	r0, [r4, #28]
    59ae:	str.w	r3, [r5, #508]	; 0x1fc
    59b2:	ldr	r1, [r4, #16]
    59b4:	ldr	r3, [r0, #0]
    59b6:	ldr	r2, [r4, #36]	; 0x24
    59b8:	ldr	r3, [r3, #32]
    59ba:	adds	r1, #2
    59bc:	blx	r3
    59be:	cmp	r0, #0
    59c0:	beq.n	5a26 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 8, m_secBuf)) {
    59c2:	ldr	r0, [r4, #28]
    59c4:	ldr	r1, [r4, #16]
    59c6:	ldr	r3, [r0, #0]
    59c8:	ldr	r2, [r4, #36]	; 0x24
    59ca:	ldr	r3, [r3, #32]
    59cc:	adds	r1, #8
    59ce:	blx	r3
    return false;
  }
  // write extra boot area and backup
  memset(m_secBuf, 0 , BYTES_PER_SECTOR);
  setLe32(fsi->trailSignature, FSINFO_TRAIL_SIGNATURE);
  if (!m_dev->writeSector(m_relativeSectors + 2, m_secBuf)  ||
    59d0:	cbz	r0, 5a26 <FatFormatter::makeFat32()+0x18e>
    59d2:	ldr	r3, [pc, #104]	; (5a3c <FatFormatter::makeFat32()+0x1a4>)
    59d4:	str	r3, [r5, #0]
    59d6:	add.w	r3, r3, #534773760	; 0x1fe00000
    59da:	add.w	r3, r3, #8192	; 0x2000
    59de:	adds	r3, #32
    59e0:	str.w	r3, [r5, #484]	; 0x1e4
  // write FSINFO sector and backup
  setLe32(fsi->leadSignature, FSINFO_LEAD_SIGNATURE);
  setLe32(fsi->structSignature, FSINFO_STRUCT_SIGNATURE);
  setLe32(fsi->freeCount, 0XFFFFFFFF);
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
    59e4:	ldr	r0, [r4, #28]
    59e6:	ldr	r2, [r4, #36]	; 0x24
    59e8:	mov.w	r3, #4294967295
    59ec:	str.w	r3, [r5, #488]	; 0x1e8
    59f0:	str.w	r3, [r5, #492]	; 0x1ec
    59f4:	ldr	r1, [r4, #16]
    59f6:	ldr	r3, [r0, #0]
    59f8:	adds	r1, #1
    59fa:	ldr	r3, [r3, #32]
    59fc:	blx	r3
    59fe:	cbz	r0, 5a26 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    5a00:	ldr	r0, [r4, #28]
    5a02:	ldr	r1, [r4, #16]
    5a04:	ldr	r3, [r0, #0]
    5a06:	ldr	r2, [r4, #36]	; 0x24
    5a08:	ldr	r3, [r3, #32]
    5a0a:	adds	r1, #7
    5a0c:	blx	r3
  // write FSINFO sector and backup
  setLe32(fsi->leadSignature, FSINFO_LEAD_SIGNATURE);
  setLe32(fsi->structSignature, FSINFO_STRUCT_SIGNATURE);
  setLe32(fsi->freeCount, 0XFFFFFFFF);
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
    5a0e:	cbz	r0, 5a26 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
    5a10:	ldr	r2, [r4, #8]
    5a12:	ldrb.w	r3, [r4, #43]	; 0x2b
    5a16:	mov	r0, r4
    5a18:	add.w	r2, r3, r2, lsl #1
    5a1c:	movs	r1, #32
}
    5a1e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
    5a22:	b.w	5634 <FatFormatter::initFatDir(unsigned char, unsigned long)>
}
    5a26:	movs	r0, #0
    5a28:	pop	{r3, r4, r5, r6, r7, pc}
    5a2a:	nop
    5a2c:	.word	0x00012d81
    5a30:	.word	0x00fb0400
    5a34:	.word	0x0012d687
    5a38:	.word	0xaa550000
    5a3c:	.word	0x41615252

00005a40 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>:
#define writeMsg(str) if (m_pr) m_pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    5a40:	push	{r3, r4, r5, lr}
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
    5a42:	str	r3, [r0, #32]
  m_sectorCount = m_dev->sectorCount();
    5a44:	ldr	r3, [r1, #0]
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
  bool rtn;
  m_dev = dev;
    5a46:	str	r1, [r0, #28]
  m_secBuf = secBuf;
    5a48:	str	r2, [r0, #36]	; 0x24
#define writeMsg(str) if (m_pr) m_pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    5a4a:	mov	r4, r0
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
  m_sectorCount = m_dev->sectorCount();
    5a4c:	ldr	r3, [r3, #24]
    5a4e:	mov	r0, r1
    5a50:	blx	r3
  m_capacityMB = (m_sectorCount + SECTORS_PER_MB - 1)/SECTORS_PER_MB;
    5a52:	addw	r3, r0, #2047	; 0x7ff
    5a56:	lsrs	r3, r3, #11

  if (m_capacityMB <= 6) {
    5a58:	cmp	r3, #6
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
  m_sectorCount = m_dev->sectorCount();
    5a5a:	str	r0, [r4, #20]
  m_capacityMB = (m_sectorCount + SECTORS_PER_MB - 1)/SECTORS_PER_MB;
    5a5c:	str	r3, [r4, #0]

  if (m_capacityMB <= 6) {
    5a5e:	bhi.n	5a6e <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2e>
    writeMsg("Card is too small.\r\n");
    5a60:	ldr	r0, [r4, #32]
    5a62:	cbz	r0, 5a6a <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2a>
    5a64:	ldr	r1, [pc, #108]	; (5ad4 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x94>)
    5a66:	bl	734 <Print::write(char const*)>
    return false;
    5a6a:	movs	r0, #0
    5a6c:	pop	{r3, r4, r5, pc}
  } else if (m_capacityMB <= 16) {
    5a6e:	cmp	r3, #16
    5a70:	bhi.n	5a76 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x36>
    m_sectorsPerCluster = 2;
    5a72:	movs	r3, #2
    5a74:	b.n	5aa2 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 32) {
    5a76:	cmp	r3, #32
    5a78:	bhi.n	5a7e <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3e>
    m_sectorsPerCluster = 4;
    5a7a:	movs	r3, #4
    5a7c:	b.n	5aa2 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 64) {
    5a7e:	cmp	r3, #64	; 0x40
    5a80:	bhi.n	5a86 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x46>
    m_sectorsPerCluster = 8;
    5a82:	movs	r3, #8
    5a84:	b.n	5aa2 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 128) {
    5a86:	cmp	r3, #128	; 0x80
    5a88:	bhi.n	5a8e <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x4e>
    m_sectorsPerCluster = 16;
    5a8a:	movs	r3, #16
    5a8c:	b.n	5aa2 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 1024) {
    5a8e:	cmp.w	r3, #1024	; 0x400
    5a92:	bhi.n	5a98 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x58>
    m_sectorsPerCluster = 32;
    5a94:	movs	r3, #32
    5a96:	b.n	5aa2 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 32768) {
    5a98:	cmp.w	r3, #32768	; 0x8000
    m_sectorsPerCluster = 64;
    5a9c:	ite	ls
    5a9e:	movls	r3, #64	; 0x40
  } else {
    // SDXC cards
    m_sectorsPerCluster = 128;
    5aa0:	movhi	r3, #128	; 0x80
  }
  rtn = m_sectorCount < 0X400000 ? makeFat16() : makeFat32();
    5aa2:	cmp.w	r0, #4194304	; 0x400000
    m_sectorsPerCluster = 32;
  } else if (m_capacityMB <= 32768) {
    m_sectorsPerCluster = 64;
  } else {
    // SDXC cards
    m_sectorsPerCluster = 128;
    5aa6:	strb.w	r3, [r4, #43]	; 0x2b
  }
  rtn = m_sectorCount < 0X400000 ? makeFat16() : makeFat32();
    5aaa:	mov	r0, r4
    5aac:	bcs.n	5ab4 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x74>
    5aae:	bl	5794 <FatFormatter::makeFat16()>
    5ab2:	b.n	5ab8 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x78>
    5ab4:	bl	5898 <FatFormatter::makeFat32()>
    5ab8:	mov	r5, r0
    5aba:	ldr	r0, [r4, #32]
  if (rtn) {
    5abc:	cbz	r5, 5ac8 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x88>
    writeMsg("Format Done\r\n");
    5abe:	cbz	r0, 5ad0 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x90>
    5ac0:	ldr	r1, [pc, #20]	; (5ad8 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x98>)
    5ac2:	bl	734 <Print::write(char const*)>
    5ac6:	b.n	5ad0 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x90>
  } else {
    writeMsg("Format Failed\r\n");
    5ac8:	cmp	r0, #0
    5aca:	beq.n	5a6a <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2a>
    5acc:	ldr	r1, [pc, #12]	; (5adc <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x9c>)
    5ace:	b.n	5a66 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x26>
    5ad0:	movs	r0, #1
  }
  return rtn;
}
    5ad2:	pop	{r3, r4, r5, pc}
    5ad4:	.word	0x00012d95
    5ad8:	.word	0x00012daa
    5adc:	.word	0x00012db8

00005ae0 <FatFile::cacheDir(unsigned short)>:

  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    5ae0:	push	{r4, lr}
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    5ae2:	lsls	r1, r1, #5

  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    5ae4:	mov	r4, r0
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    5ae6:	bl	5fde <FatFile::seekSet(unsigned long)>
    5aea:	cbz	r0, 5af8 <FatFile::cacheDir(unsigned short)+0x18>
    5aec:	mov	r0, r4
    5aee:	movs	r1, #0
  }
    5af0:	ldmia.w	sp!, {r4, lr}
  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    5af4:	b.w	5fa4 <FatFile::readDirCache(bool)>
  }
    5af8:	pop	{r4, pc}

00005afa <FatFile::getLfnChar(DirLfn_t*, unsigned char)>:
#include "FatFile.h"
#include "FatVolume.h"

//------------------------------------------------------------------------------
uint16_t FatFile::getLfnChar(DirLfn_t* ldir, uint8_t i) {
  if (i < 5) {
    5afa:	cmp	r2, #4
    5afc:	bhi.n	5b08 <FatFile::getLfnChar(DirLfn_t*, unsigned char)+0xe>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    5afe:	add.w	r1, r1, r2, lsl #1
    5b02:	ldrh.w	r0, [r1, #1]
    return getLe16(ldir->unicode1 + 2*i);
    5b06:	bx	lr
  } else if (i < 11) {
    5b08:	cmp	r2, #10
    5b0a:	bhi.n	5b14 <FatFile::getLfnChar(DirLfn_t*, unsigned char)+0x1a>
    5b0c:	add.w	r1, r1, r2, lsl #1
    5b10:	ldrh	r0, [r1, #4]
    return getLe16(ldir->unicode2 + 2*i - 10);
    5b12:	bx	lr
  } else if (i < 13) {
    5b14:	cmp	r2, #12
    5b16:	itte	ls
    5b18:	addls.w	r1, r1, r2, lsl #1
    5b1c:	ldrhls	r0, [r1, #6]
    return getLe16(ldir->unicode3 + 2*i - 22);
  }
  DBG_HALT_IF(i >= 13);
  return 0;
    5b1e:	movhi	r0, #0
}
    5b20:	bx	lr

00005b22 <FatFile::getSFN(char*, unsigned int)>:
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
    5b22:	push	{r3, r4, r5, r6, r7, lr}
    5b24:	mov	r6, r1
    5b26:	ldrb	r1, [r0, #0]
    5b28:	mov	r7, r2
  char c;
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
  uint8_t* ptr;
  DirFat_t* dir;
  if (!isOpen()) {
    5b2a:	cbz	r1, 5ba4 <FatFile::getSFN(char*, unsigned int)+0x82>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isRoot()) {
    5b2c:	ands.w	r4, r1, #96	; 0x60
    5b30:	beq.n	5b42 <FatFile::getSFN(char*, unsigned int)+0x20>
    if (size < 2) {
    5b32:	cmp	r2, #1
    5b34:	bls.n	5ba4 <FatFile::getSFN(char*, unsigned int)+0x82>
      DBG_FAIL_MACRO;
      goto fail;
    }
    name[0] = '/';
    5b36:	movs	r3, #47	; 0x2f
    5b38:	strb	r3, [r6, #0]
    name[1] = '\0';
    5b3a:	movs	r3, #0
    5b3c:	strb	r3, [r6, #1]
    return 1;
    5b3e:	movs	r0, #1
    5b40:	pop	{r3, r4, r5, r6, r7, pc}
  }
  // cache entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    5b42:	mov	r1, r4
    5b44:	bl	5d88 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    5b48:	cbz	r0, 5ba4 <FatFile::getSFN(char*, unsigned int)+0x82>
    DBG_FAIL_MACRO;
    goto fail;
  }
  ptr = dir->name;
    5b4a:	mov	r5, r0
    5b4c:	mov	r1, r4
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
  char c;
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
    5b4e:	movs	r2, #8
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
  char c;
  uint8_t j = 0;
    5b50:	mov	r3, r4
    goto fail;
  }
  ptr = dir->name;
  // format name
  for (uint8_t i = 0; i < 12; i++) {
    if (i == 8) {
    5b52:	cmp	r1, #8
    5b54:	ldrb	r4, [r5, #0]
    5b56:	bne.n	5b62 <FatFile::getSFN(char*, unsigned int)+0x40>
      if (*ptr == ' ') {
    5b58:	cmp	r4, #32
    5b5a:	beq.n	5b9c <FatFile::getSFN(char*, unsigned int)+0x7a>
        break;
      }
      lcBit = FAT_CASE_LC_EXT;
    5b5c:	movs	r2, #16
      c = '.';
    5b5e:	movs	r4, #46	; 0x2e
    5b60:	b.n	5b84 <FatFile::getSFN(char*, unsigned int)+0x62>
    } else {
      c = *ptr++;
      if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
    5b62:	sub.w	lr, r4, #65	; 0x41
    5b66:	cmp.w	lr, #25
        break;
      }
      lcBit = FAT_CASE_LC_EXT;
      c = '.';
    } else {
      c = *ptr++;
    5b6a:	add.w	r5, r5, #1
      if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
    5b6e:	bhi.n	5b80 <FatFile::getSFN(char*, unsigned int)+0x5e>
    5b70:	ldrb.w	lr, [r0, #12]
    5b74:	tst.w	r2, lr
    5b78:	beq.n	5b84 <FatFile::getSFN(char*, unsigned int)+0x62>
        c += 'a' - 'A';
    5b7a:	adds	r4, #32
    5b7c:	uxtb	r4, r4
    5b7e:	b.n	5b84 <FatFile::getSFN(char*, unsigned int)+0x62>
      }
      if (c == ' ') {
    5b80:	cmp	r4, #32
    5b82:	beq.n	5b96 <FatFile::getSFN(char*, unsigned int)+0x74>
        continue;
      }
    }
    if ((j + 1u) == size) {
    5b84:	add.w	lr, r3, #1
    5b88:	cmp	r7, lr
    5b8a:	mov	ip, r3
    5b8c:	beq.n	5b9c <FatFile::getSFN(char*, unsigned int)+0x7a>
      break;
    }
    name[j++] = c;
    5b8e:	strb.w	r4, [r6, ip]
    5b92:	uxtb.w	r3, lr
    5b96:	adds	r1, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  ptr = dir->name;
  // format name
  for (uint8_t i = 0; i < 12; i++) {
    5b98:	cmp	r1, #12
    5b9a:	bne.n	5b52 <FatFile::getSFN(char*, unsigned int)+0x30>
    if ((j + 1u) == size) {
      break;
    }
    name[j++] = c;
  }
  name[j] = '\0';
    5b9c:	movs	r2, #0
    5b9e:	strb	r2, [r6, r3]
  return j;
    5ba0:	mov	r0, r3
    5ba2:	pop	{r3, r4, r5, r6, r7, pc}

 fail:
  name[0] = '\0';
    5ba4:	movs	r0, #0
    5ba6:	strb	r0, [r6, #0]
  return 0;
}
    5ba8:	pop	{r3, r4, r5, r6, r7, pc}
    5baa:	Address 0x00005baa is out of bounds.


00005bac <FatFile::getName8(char*, unsigned int)>:
 fail:
  name[0] = '\0';
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getName8(char* name, size_t size) {
    5bac:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5bb0:	sub	sp, #44	; 0x2c
  char* ptr;
  FatFile dir;
  DirLfn_t* ldir;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    5bb2:	ldrb	r3, [r0, #0]
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    5bb4:	movs	r4, #0
 fail:
  name[0] = '\0';
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getName8(char* name, size_t size) {
    5bb6:	mov	r7, r0
    5bb8:	mov	r9, r1
    5bba:	mov	r8, r2
    5bbc:	strb.w	r4, [sp, #4]
    5bc0:	strb.w	r4, [sp, #5]
    5bc4:	strb.w	r4, [sp, #6]
  char* ptr;
  FatFile dir;
  DirLfn_t* ldir;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    5bc8:	cmp	r3, #0
    5bca:	beq.n	5c8c <FatFile::getName8(char*, unsigned int)+0xe0>
      DBG_FAIL_MACRO;
      goto fail;
  }
  if (!isLFN()) {
    5bcc:	ldrb	r3, [r0, #3]
    5bce:	cbnz	r3, 5bd6 <FatFile::getName8(char*, unsigned int)+0x2a>
    return getSFN(name, size);
    5bd0:	bl	5b22 <FatFile::getSFN(char*, unsigned int)>
    5bd4:	b.n	5c92 <FatFile::getName8(char*, unsigned int)+0xe6>
  }
  if (!dir.openCluster(this)) {
    5bd6:	mov	r1, r0
    5bd8:	add	r0, sp, #4
    5bda:	bl	5dd6 <FatFile::openCluster(FatFile*)>
    5bde:	cmp	r0, #0
    5be0:	beq.n	5c8c <FatFile::getName8(char*, unsigned int)+0xe0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    5be2:	add.w	r8, r8, #4294967295
    5be6:	mov	r5, r9
    5be8:	movs	r6, #1
    5bea:	add	r8, r9
  }
  if (!dir.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    5bec:	ldrb	r3, [r7, #3]
    5bee:	cmp	r3, r6
    5bf0:	bcc.n	5c82 <FatFile::getName8(char*, unsigned int)+0xd6>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(m_dirIndex - order));
    5bf2:	ldrh	r1, [r7, #4]
    5bf4:	subs	r1, r1, r6
    5bf6:	uxth	r1, r1
    5bf8:	add	r0, sp, #4
    5bfa:	bl	5ae0 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    5bfe:	mov	fp, r0
    5c00:	cmp	r0, #0
    5c02:	beq.n	5c8c <FatFile::getName8(char*, unsigned int)+0xe0>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    5c04:	ldrb	r3, [r0, #11]
    5c06:	cmp	r3, #15
    5c08:	bne.n	5c8c <FatFile::getName8(char*, unsigned int)+0xe0>
    5c0a:	ldrb	r3, [r0, #0]
    5c0c:	and.w	r3, r3, #31
    5c10:	cmp	r6, r3
    5c12:	bne.n	5c8c <FatFile::getName8(char*, unsigned int)+0xe0>
    5c14:	mov	r3, r4
    5c16:	mov.w	sl, #0
        order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t c = getLfnChar(ldir, i);
    5c1a:	uxtb.w	r2, sl
    5c1e:	mov	r1, fp
    5c20:	mov	r0, r7
    5c22:	bl	5afa <FatFile::getLfnChar(DirLfn_t*, unsigned char)>
    5c26:	mov	r4, r0
      if (hs) {
    5c28:	cbz	r3, 5c48 <FatFile::getName8(char*, unsigned int)+0x9c>
        if (!FsUtf::isLowSurrogate(c)) {
    5c2a:	add.w	r2, r0, #9216	; 0x2400
    5c2e:	uxth	r2, r2
    5c30:	cmp.w	r2, #1024	; 0x400
    5c34:	bcs.n	5c8c <FatFile::getName8(char*, unsigned int)+0xe0>
   * \param[in] hs high surrogate.
   * \param[in] ls low surrogate.
   * \return code point.
   */
  inline uint32_t u16ToCp(uint16_t hs, uint16_t ls) {
    return 0X10000 + (((hs & 0X3FF) << 10) | (ls & 0X3FF));
    5c36:	ldr	r0, [pc, #96]	; (5c98 <FatFile::getName8(char*, unsigned int)+0xec>)
    5c38:	lsls	r3, r3, #10
    5c3a:	ands	r0, r3
    5c3c:	ubfx	r4, r4, #0, #10
    5c40:	orrs	r4, r0
    5c42:	add.w	r0, r4, #65536	; 0x10000
    5c46:	b.n	5c60 <FatFile::getName8(char*, unsigned int)+0xb4>
  /** Check for UTF-16 surrogate.
   * \param[in] c UTF-16 unit.
   * \return true if c is a surrogate else false.
   */
  inline bool isSurrogate(uint16_t c) {
    return 0XD800 <= c && c <= 0XDFFF;
    5c48:	add.w	r3, r0, #10240	; 0x2800
    5c4c:	uxth	r3, r3
          DBG_FAIL_MACRO;
          goto fail;
        }
        cp = FsUtf::u16ToCp(hs, c);
        hs = 0;
      } else if (!FsUtf::isSurrogate(c)) {
    5c4e:	cmp.w	r3, #2048	; 0x800
    5c52:	bcc.n	5c58 <FatFile::getName8(char*, unsigned int)+0xac>
        if (c == 0) {
    5c54:	cbnz	r0, 5c60 <FatFile::getName8(char*, unsigned int)+0xb4>
    5c56:	b.n	5c82 <FatFile::getName8(char*, unsigned int)+0xd6>
          goto done;
        }
        cp = c;
      } else if (FsUtf::isHighSurrogate(c)) {
    5c58:	cmp.w	r3, #1024	; 0x400
    5c5c:	bcc.n	5c6e <FatFile::getName8(char*, unsigned int)+0xc2>
    5c5e:	b.n	5c8c <FatFile::getName8(char*, unsigned int)+0xe0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    5c60:	mov	r2, r8
    5c62:	mov	r1, r5
    5c64:	bl	34c4 <FsUtf::cpToMb(unsigned long, char*, char*)>
      if (!ptr) {
    5c68:	cbz	r0, 5c82 <FatFile::getName8(char*, unsigned int)+0xd6>
    5c6a:	mov	r5, r0
    5c6c:	movs	r4, #0
    5c6e:	add.w	sl, sl, #1
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
        order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t i = 0; i < 13; i++) {
    5c72:	cmp.w	sl, #13
    5c76:	beq.n	5c7c <FatFile::getName8(char*, unsigned int)+0xd0>
    5c78:	mov	r3, r4
    5c7a:	b.n	5c1a <FatFile::getName8(char*, unsigned int)+0x6e>
  }
  if (!dir.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    5c7c:	adds	r6, #1
    5c7e:	uxtb	r6, r6
    5c80:	b.n	5bec <FatFile::getName8(char*, unsigned int)+0x40>
      }
      str = ptr;
    }
  }
 done:
  *str = '\0';
    5c82:	movs	r3, #0
    5c84:	strb	r3, [r5, #0]
  return str - name;
    5c86:	rsb	r0, r9, r5
    5c8a:	b.n	5c92 <FatFile::getName8(char*, unsigned int)+0xe6>

 fail:
  *name = 0;
    5c8c:	movs	r0, #0
    5c8e:	strb.w	r0, [r9]
  return 0;
}
    5c92:	add	sp, #44	; 0x2c
    5c94:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5c98:	.word	0x000ffc00

00005c9c <FatFile::getName(char*, unsigned int)>:
//------------------------------------------------------------------------------
size_t FatFile::getName(char* name, size_t size) {
#if !USE_LONG_FILE_NAMES
  return getSFN(name, size);
#elif USE_UTF8_LONG_NAMES
  return getName8(name, size);
    5c9c:	b.w	5bac <FatFile::getName8(char*, unsigned int)>

00005ca0 <FatPartition::cacheSync()>:
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    5ca0:	push	{r4, lr}
    5ca2:	mov	r4, r0
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    5ca4:	adds	r0, #40	; 0x28
    5ca6:	bl	381a <FsCache::sync()>
    5caa:	cbz	r0, 5cc2 <FatPartition::cacheSync()+0x22>
    5cac:	add.w	r0, r4, #568	; 0x238
    5cb0:	bl	381a <FsCache::sync()>
    5cb4:	cbz	r0, 5cc2 <FatPartition::cacheSync()+0x22>
    5cb6:	ldr	r0, [r4, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    5cb8:	ldr	r3, [r0, #0]
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
  }
    5cba:	ldmia.w	sp!, {r4, lr}
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    5cbe:	ldr	r3, [r3, #28]
    5cc0:	bx	r3
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
  }
    5cc2:	movs	r0, #0
    5cc4:	pop	{r4, pc}

00005cc6 <FatFile::addCluster()>:
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    5cc6:	mov	r2, r0
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    5cc8:	push	{r3, r4, r5, lr}
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    5cca:	ldr.w	r5, [r2, #16]!
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    5cce:	mov	r4, r0
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
  if (!m_vol->allocateCluster(m_curCluster, &m_curCluster)) {
    5cd0:	mov	r1, r5
    5cd2:	ldr	r0, [r0, #8]
    5cd4:	bl	6b3e <FatPartition::allocateCluster(unsigned long, unsigned long*)>
    5cd8:	cbz	r0, 5cfa <FatFile::addCluster()+0x34>
    5cda:	ldrb	r3, [r4, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (cc == 0) {
    5cdc:	cbnz	r5, 5ce4 <FatFile::addCluster()+0x1e>
    m_flags |= FILE_FLAG_CONTIGUOUS;
    5cde:	orr.w	r3, r3, #64	; 0x40
    5ce2:	b.n	5cf0 <FatFile::addCluster()+0x2a>
  } else if (m_curCluster != (cc + 1)) {
    5ce4:	ldr	r2, [r4, #16]
    5ce6:	adds	r5, #1
    5ce8:	cmp	r2, r5
    5cea:	beq.n	5cf2 <FatFile::addCluster()+0x2c>
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    5cec:	bic.w	r3, r3, #64	; 0x40
    5cf0:	strb	r3, [r4, #2]
  }
  m_flags |= FILE_FLAG_DIR_DIRTY;
    5cf2:	ldrb	r3, [r4, #2]
    5cf4:	orn	r3, r3, #127	; 0x7f
    5cf8:	strb	r3, [r4, #2]
  return false;
#else  // USE_FAT_FILE_FLAG_CONTIGUOUS
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
    5cfa:	pop	{r3, r4, r5, pc}

00005cfc <FatFile::addDirCluster()>:
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first sector of cluster in the cache.
bool FatFile::addDirCluster() {
    5cfc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    5d00:	ldrb	r3, [r0, #0]
    5d02:	and.w	r3, r3, #32
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first sector of cluster in the cache.
bool FatFile::addDirCluster() {
    5d06:	mov	r4, r0
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    5d08:	and.w	r5, r3, #255	; 0xff
    5d0c:	cbz	r3, 5d12 <FatFile::addDirCluster()+0x16>
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
  return true;

 fail:
  return false;
    5d0e:	movs	r6, #0
    5d10:	b.n	5d7c <FatFile::addDirCluster()+0x80>
  if (isRootFixed()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // max folder size
  if (m_curPosition >= 512UL*4095) {
    5d12:	ldr	r2, [r0, #20]
    5d14:	ldr	r3, [pc, #108]	; (5d84 <FatFile::addDirCluster()+0x88>)
    5d16:	cmp	r2, r3
    5d18:	bhi.n	5d0e <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    5d1a:	bl	5cc6 <FatFile::addCluster()>
    5d1e:	mov	r6, r0
    5d20:	cmp	r0, #0
    5d22:	beq.n	5d0e <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_vol->clusterStartSector(m_curCluster);
    5d24:	ldr	r0, [r4, #8]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    5d26:	ldr	r1, [r4, #16]
    5d28:	ldrb	r3, [r0, #6]
    5d2a:	ldr	r7, [r0, #20]
    5d2c:	subs	r1, #2
    5d2e:	lsls	r1, r3
    5d30:	add	r7, r1
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    5d32:	movs	r2, #5
    5d34:	mov	r1, r7
    5d36:	adds	r0, #40	; 0x28
    5d38:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_RESERVE_FOR_WRITE);
  if (!pc) {
    5d3c:	mov	r8, r0
    5d3e:	cmp	r0, #0
    5d40:	beq.n	5d0e <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
    5d42:	mov	r1, r5
    5d44:	mov.w	r2, #512	; 0x200
    5d48:	bl	90bc <memset>
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    5d4c:	movs	r5, #1
    5d4e:	ldr	r3, [r4, #8]
    5d50:	ldrb	r2, [r3, #4]
    5d52:	cmp	r2, r5
    5d54:	bls.n	5d6c <FatFile::addDirCluster()+0x70>
    5d56:	ldr	r0, [r3, #0]
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    5d58:	ldr	r3, [r0, #0]
    5d5a:	mov	r2, r8
    5d5c:	ldr	r3, [r3, #32]
    5d5e:	adds	r1, r5, r7
    5d60:	blx	r3
    if (!m_vol->writeSector(sector + i, pc->data)) {
    5d62:	cmp	r0, #0
    5d64:	beq.n	5d0e <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    5d66:	adds	r5, #1
    5d68:	uxtb	r5, r5
    5d6a:	b.n	5d4e <FatFile::addDirCluster()+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
    5d6c:	ldrb	r2, [r3, #6]
    5d6e:	mov.w	r3, #512	; 0x200
    5d72:	lsls	r3, r2
    5d74:	ldr	r2, [r4, #20]
    5d76:	uxtah	r3, r2, r3
    5d7a:	str	r3, [r4, #20]
  return true;

 fail:
  return false;
}
    5d7c:	mov	r0, r6
    5d7e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5d82:	nop
    5d84:	.word	0x001ffdff

00005d88 <FatFile::cacheDirEntry(unsigned char)>:
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
DirFat_t* FatFile::cacheDirEntry(uint8_t action) {
    5d88:	push	{r4, lr}
    5d8a:	mov	r4, r0
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    5d8c:	ldr	r0, [r0, #8]
    5d8e:	mov	r2, r1
    5d90:	adds	r0, #40	; 0x28
    5d92:	ldr	r1, [r4, #24]
    5d94:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
  cache_t* pc;
  pc = m_vol->cacheFetchData(m_dirSector, action);
  if (!pc) {
    5d98:	cbz	r0, 5da4 <FatFile::cacheDirEntry(unsigned char)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return pc->dir + (m_dirIndex & 0XF);
    5d9a:	ldrh	r3, [r4, #4]
    5d9c:	and.w	r3, r3, #15
    5da0:	add.w	r0, r0, r3, lsl #5

 fail:
  return nullptr;
}
    5da4:	pop	{r4, pc}

00005da6 <FatFile::openRoot(FatVolume*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    5da6:	push	{r4, r5, r6, lr}
  // error if file is already open
  if (isOpen()) {
    5da8:	ldrb	r4, [r0, #0]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    5daa:	mov	r5, r0
    5dac:	mov	r6, r1
  // error if file is already open
  if (isOpen()) {
    5dae:	cbnz	r4, 5dd2 <FatFile::openRoot(FatVolume*)+0x2c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(FatFile));
    5db0:	movs	r2, #36	; 0x24
    5db2:	mov	r1, r4
    5db4:	bl	90bc <memset>

  m_vol = vol;
    5db8:	str	r6, [r5, #8]
  switch (vol->fatType()) {
    5dba:	ldrb	r3, [r6, #7]
    5dbc:	cmp	r3, #16
    5dbe:	beq.n	5dc8 <FatFile::openRoot(FatVolume*)+0x22>
    5dc0:	cmp	r3, #32
    5dc2:	bne.n	5dd2 <FatFile::openRoot(FatVolume*)+0x2c>
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    5dc4:	movs	r3, #64	; 0x40
    5dc6:	b.n	5dca <FatFile::openRoot(FatVolume*)+0x24>
  switch (vol->fatType()) {
#if FAT12_SUPPORT
  case 12:
#endif  // FAT12_SUPPORT
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    5dc8:	movs	r3, #32
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    5dca:	movs	r0, #1
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    5dcc:	strb	r3, [r5, #0]
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    5dce:	strb	r0, [r5, #2]
    5dd0:	pop	{r4, r5, r6, pc}
  return true;

 fail:
  return false;
    5dd2:	movs	r0, #0
    5dd4:	pop	{r4, r5, r6, pc}

00005dd6 <FatFile::openCluster(FatFile*)>:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    5dd6:	push	{r3, r4, r5, lr}
  if (file->m_dirCluster == 0) {
    5dd8:	ldr	r3, [r1, #12]
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    5dda:	mov	r4, r0
    5ddc:	mov	r5, r1
  if (file->m_dirCluster == 0) {
    5dde:	cbnz	r3, 5dea <FatFile::openCluster(FatFile*)+0x14>
    return openRoot(file->m_vol);
    5de0:	ldr	r1, [r1, #8]
  m_attributes = FILE_ATTR_SUBDIR;
  m_flags = FILE_FLAG_READ;
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
    5de2:	ldmia.w	sp!, {r3, r4, r5, lr}
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
    5de6:	b.w	5da6 <FatFile::openRoot(FatVolume*)>
  }
  memset(this, 0, sizeof(FatFile));
    5dea:	movs	r2, #36	; 0x24
    5dec:	movs	r1, #0
    5dee:	bl	90bc <memset>
  m_attributes = FILE_ATTR_SUBDIR;
    5df2:	movs	r3, #16
  m_flags = FILE_FLAG_READ;
    5df4:	movs	r0, #1
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
  m_attributes = FILE_ATTR_SUBDIR;
    5df6:	strb	r3, [r4, #0]
  m_flags = FILE_FLAG_READ;
    5df8:	strb	r0, [r4, #2]
  m_vol = file->m_vol;
    5dfa:	ldr	r3, [r5, #8]
    5dfc:	str	r3, [r4, #8]
  m_firstCluster = file->m_dirCluster;
    5dfe:	ldr	r3, [r5, #12]
    5e00:	str	r3, [r4, #32]
  return true;
}
    5e02:	pop	{r3, r4, r5, pc}

00005e04 <FatFile::read(void*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    5e04:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    5e08:	ldrb	r3, [r0, #2]
    5e0a:	lsls	r5, r3, #31

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    5e0c:	mov	r4, r0
    5e0e:	mov	r9, r1
    5e10:	mov	r6, r2
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    5e12:	bpl.n	5f04 <FatFile::read(void*, unsigned int)+0x100>
    5e14:	ldrb	r3, [r0, #0]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
    5e16:	lsls	r0, r3, #28
    5e18:	bpl.n	5e22 <FatFile::read(void*, unsigned int)+0x1e>
    uint32_t tmp32 = m_fileSize - m_curPosition;
    5e1a:	ldr	r3, [r4, #28]
    5e1c:	ldr	r2, [r4, #20]
    5e1e:	subs	r3, r3, r2
    5e20:	b.n	5e32 <FatFile::read(void*, unsigned int)+0x2e>
    if (nbyte >= tmp32) {
      nbyte = tmp32;
    }
  } else if (isRootFixed()) {
    5e22:	lsls	r1, r3, #26
    5e24:	bpl.n	5e38 <FatFile::read(void*, unsigned int)+0x34>
    uint16_t tmp16 = 32*m_vol->m_rootDirEntryCount - (uint16_t)m_curPosition;
    5e26:	ldr	r3, [r4, #8]
    if (nbyte > tmp16) {
    5e28:	ldrh	r2, [r3, #8]
    5e2a:	ldr	r3, [r4, #20]
    5e2c:	rsb	r3, r3, r2, lsl #5
    5e30:	uxth	r3, r3
    5e32:	cmp	r6, r3
    5e34:	it	cs
    5e36:	movcs	r6, r3
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
    5e38:	mov	r7, r6
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
  int8_t fg;
  uint8_t sectorOfCluster = 0;
    5e3a:	mov.w	r8, #0
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    5e3e:	add.w	sl, r4, #16
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    5e42:	cmp	r7, #0
    5e44:	beq.n	5eca <FatFile::read(void*, unsigned int)+0xc6>
    5e46:	ldrb	r3, [r4, #0]
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    5e48:	ldr	r2, [r4, #20]
    5e4a:	ldr	r0, [r4, #8]
    if (isRootFixed()) {
    5e4c:	tst.w	r3, #32
    }
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    5e50:	ubfx	r5, r2, #0, #9
    5e54:	mov.w	r1, r2, lsr #9
    if (isRootFixed()) {
    5e58:	beq.n	5e60 <FatFile::read(void*, unsigned int)+0x5c>
      sector = m_vol->rootDirStart()
               + (m_curPosition >> m_vol->bytesPerSectorShift());
    5e5a:	ldr	r3, [r0, #32]
    5e5c:	add	r1, r3
    5e5e:	b.n	5eaa <FatFile::read(void*, unsigned int)+0xa6>
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    5e60:	ldrb.w	r8, [r0, #5]
    5e64:	and.w	r8, r1, r8
    } else {
      sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
      if (offset == 0 && sectorOfCluster == 0) {
    5e68:	cbnz	r5, 5e9a <FatFile::read(void*, unsigned int)+0x96>
    5e6a:	cmp.w	r8, #0
    5e6e:	bne.n	5e9a <FatFile::read(void*, unsigned int)+0x96>
        // start of new cluster
        if (m_curPosition == 0) {
    5e70:	cbnz	r2, 5e7c <FatFile::read(void*, unsigned int)+0x78>
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    5e72:	lsls	r2, r3, #25
    5e74:	ite	mi
    5e76:	ldrmi	r3, [r0, #32]
    5e78:	ldrpl	r3, [r4, #32]
    5e7a:	b.n	5f12 <FatFile::read(void*, unsigned int)+0x10e>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
    5e7c:	lsls	r3, r3, #28
    5e7e:	bpl.n	5e8c <FatFile::read(void*, unsigned int)+0x88>
    5e80:	ldrb	r3, [r4, #2]
    5e82:	lsls	r1, r3, #25
    5e84:	bpl.n	5e8c <FatFile::read(void*, unsigned int)+0x88>
          m_curCluster++;
    5e86:	ldr	r3, [r4, #16]
    5e88:	adds	r3, #1
    5e8a:	b.n	5f12 <FatFile::read(void*, unsigned int)+0x10e>
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    5e8c:	mov	r2, sl
    5e8e:	ldr	r1, [r4, #16]
    5e90:	bl	6a78 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    5e94:	cmp	r0, #0
    5e96:	blt.n	5f04 <FatFile::read(void*, unsigned int)+0x100>
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
    5e98:	beq.n	5ec2 <FatFile::read(void*, unsigned int)+0xbe>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    5e9a:	ldr	r3, [r4, #8]
    5e9c:	ldr	r1, [r4, #16]
    5e9e:	ldrb	r2, [r3, #6]
    5ea0:	ldr	r3, [r3, #20]
    5ea2:	subs	r1, #2
    5ea4:	lsls	r1, r2
    5ea6:	add	r1, r3
    5ea8:	add	r1, r8
    5eaa:	ldr.w	fp, [r4, #8]
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
    5eae:	cmp	r5, #0
    5eb0:	bne.n	5f52 <FatFile::read(void*, unsigned int)+0x14e>
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
    5eb2:	cmp.w	r7, #512	; 0x200
    5eb6:	bcc.n	5f52 <FatFile::read(void*, unsigned int)+0x14e>
    5eb8:	ldr.w	r3, [fp, #52]	; 0x34
        || sector == m_vol->cacheSectorNumber()) {
    5ebc:	cmp	r1, r3
    5ebe:	bne.n	5ece <FatFile::read(void*, unsigned int)+0xca>
    5ec0:	b.n	5f52 <FatFile::read(void*, unsigned int)+0x14e>
          if (fg < 0) {
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
            if (isDir()) {
    5ec2:	ldrb	r3, [r4, #0]
    5ec4:	tst.w	r3, #112	; 0x70
    5ec8:	beq.n	5f04 <FatFile::read(void*, unsigned int)+0x100>
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return nbyte - toRead;
    5eca:	subs	r0, r6, r7
    5ecc:	b.n	5f76 <FatFile::read(void*, unsigned int)+0x172>
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    5ece:	cmp.w	r7, #1024	; 0x400
    5ed2:	bcc.n	5f30 <FatFile::read(void*, unsigned int)+0x12c>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      if (!isRootFixed()) {
    5ed4:	ldrb	r2, [r4, #0]
    5ed6:	lsls	r2, r2, #26
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    5ed8:	mov.w	r5, r7, lsr #9
      if (!isRootFixed()) {
    5edc:	bmi.n	5eec <FatFile::read(void*, unsigned int)+0xe8>
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
    5ede:	ldrb.w	r2, [fp, #4]
    5ee2:	rsb	r2, r8, r2
    5ee6:	cmp	r5, r2
    5ee8:	it	cs
    5eea:	movcs	r5, r2
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    5eec:	cmp	r1, r3
    5eee:	bhi.n	5f16 <FatFile::read(void*, unsigned int)+0x112>
    5ef0:	adds	r2, r1, r5
    5ef2:	cmp	r3, r2
    5ef4:	bcs.n	5f16 <FatFile::read(void*, unsigned int)+0x112>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    5ef6:	add.w	r0, fp, #40	; 0x28
    5efa:	str	r1, [sp, #4]
    5efc:	bl	381a <FsCache::sync()>
    5f00:	ldr	r1, [sp, #4]
    5f02:	cbnz	r0, 5f16 <FatFile::read(void*, unsigned int)+0x112>
    toRead -= n;
  }
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
    5f04:	ldrb	r3, [r4, #1]
    5f06:	orr.w	r3, r3, #2
    5f0a:	strb	r3, [r4, #1]
  return -1;
    5f0c:	mov.w	r0, #4294967295
    5f10:	b.n	5f76 <FatFile::read(void*, unsigned int)+0x172>
        if (m_curPosition == 0) {
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
    5f12:	str	r3, [r4, #16]
    5f14:	b.n	5e9a <FatFile::read(void*, unsigned int)+0x96>
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    5f16:	ldr.w	r0, [fp, #44]	; 0x2c
    5f1a:	ldr	r3, [r0, #0]
    5f1c:	mov	r2, r9
    5f1e:	ldr.w	fp, [r3, #16]
    5f22:	mov	r3, r5
    5f24:	blx	fp
        if (mb < ns) {
          ns = mb;
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    5f26:	cmp	r0, #0
    5f28:	beq.n	5f04 <FatFile::read(void*, unsigned int)+0x100>
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
        if (mb < ns) {
          ns = mb;
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
    5f2a:	mov.w	fp, r5, lsl #9
    5f2e:	b.n	5f44 <FatFile::read(void*, unsigned int)+0x140>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    5f30:	ldr.w	r0, [fp, #44]	; 0x2c
    5f34:	ldr	r3, [r0, #0]
    5f36:	mov	r2, r9
    5f38:	ldr	r3, [r3, #12]
    5f3a:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    5f3c:	cmp	r0, #0
    5f3e:	beq.n	5f04 <FatFile::read(void*, unsigned int)+0x100>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    5f40:	mov.w	fp, #512	; 0x200
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    5f44:	ldr	r3, [r4, #20]
    5f46:	add	r3, fp
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    5f48:	add	r9, fp
    m_curPosition += n;
    5f4a:	str	r3, [r4, #20]
    toRead -= n;
    5f4c:	rsb	r7, fp, r7
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    5f50:	b.n	5e42 <FatFile::read(void*, unsigned int)+0x3e>
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    5f52:	movs	r2, #0
    5f54:	add.w	r0, fp, #40	; 0x28
    5f58:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
      if (!pc) {
    5f5c:	cmp	r0, #0
    5f5e:	beq.n	5f04 <FatFile::read(void*, unsigned int)+0x100>
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
      // amount to be read from current sector
      n = m_vol->bytesPerSector() - offset;
    5f60:	rsb	fp, r5, #512	; 0x200
    5f64:	cmp	fp, r7
    5f66:	it	cs
    5f68:	movcs	fp, r7
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
    5f6a:	adds	r1, r0, r5
    5f6c:	mov	r2, fp
    5f6e:	mov	r0, r9
    5f70:	bl	8f14 <memcpy>
    5f74:	b.n	5f44 <FatFile::read(void*, unsigned int)+0x140>
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
  return -1;
}
    5f76:	add	sp, #12
    5f78:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00005f7c <FatFile::peek()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::peek() {
    5f7c:	push	{r0, r1, r4, r5, r6, lr}
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    5f7e:	movs	r2, #1
    5f80:	add.w	r1, sp, #7
    5f84:	mov	r4, r0
  uint32_t curPosition = m_curPosition;
    5f86:	ldr	r6, [r0, #20]
  uint32_t curCluster = m_curCluster;
    5f88:	ldr	r5, [r0, #16]
    5f8a:	bl	5e04 <FatFile::read(void*, unsigned int)>
    5f8e:	cmp	r0, #1
    5f90:	it	eq
    5f92:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
    5f96:	str	r6, [r4, #20]
    5f98:	it	ne
    5f9a:	movne.w	r0, #4294967295
  m_curCluster = curCluster;
    5f9e:	str	r5, [r4, #16]
  return c;
}
    5fa0:	add	sp, #8
    5fa2:	pop	{r4, r5, r6, pc}

00005fa4 <FatFile::readDirCache(bool)>:
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;
    5fa4:	ldr	r3, [r0, #20]
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    5fa6:	push	{r0, r1, r2, r4, r5, lr}
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;
    5fa8:	ubfx	r5, r3, #5, #4
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    5fac:	mov	r4, r0
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;

  if (i == 0 || !skipReadOk) {
    5fae:	cbz	r5, 5fb2 <FatFile::readDirCache(bool)+0xe>
    5fb0:	cbnz	r1, 5fce <FatFile::readDirCache(bool)+0x2a>
    int8_t n = read(&n, 1);
    5fb2:	movs	r2, #1
    5fb4:	add.w	r1, sp, #7
    5fb8:	mov	r0, r4
    5fba:	bl	5e04 <FatFile::read(void*, unsigned int)>
    5fbe:	sxtb	r0, r0
    if  (n != 1) {
    5fc0:	cmp	r0, #1
    5fc2:	beq.n	5fc8 <FatFile::readDirCache(bool)+0x24>
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;

 fail:
  return nullptr;
    5fc4:	movs	r0, #0
    5fc6:	b.n	5fda <FatFile::readDirCache(bool)+0x36>
      if (n != 0) {
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    m_curPosition += 31;
    5fc8:	ldr	r3, [r4, #20]
    5fca:	adds	r3, #31
    5fcc:	b.n	5fd0 <FatFile::readDirCache(bool)+0x2c>
  } else {
    m_curPosition += 32;
    5fce:	adds	r3, #32
  static const uint8_t CACHE_RESERVE_FOR_WRITE =
    CACHE_STATUS_DIRTY | CACHE_OPTION_NO_READ;
  //----------------------------------------------------------------------------
  /** \return Cache buffer address. */
  uint8_t* cacheBuffer() {
    return m_buffer;
    5fd0:	ldr	r0, [r4, #8]
    5fd2:	str	r3, [r4, #20]
    5fd4:	adds	r0, #56	; 0x38
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;
    5fd6:	add.w	r0, r0, r5, lsl #5

 fail:
  return nullptr;
}
    5fda:	add	sp, #12
    5fdc:	pop	{r4, r5, pc}

00005fde <FatFile::seekSet(unsigned long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    5fde:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5fe2:	mov	r4, r0
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    5fe4:	ldr	r7, [r0, #16]
    5fe6:	ldrb	r0, [r0, #0]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    5fe8:	mov	r6, r1
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    5fea:	cmp	r0, #0
    5fec:	beq.n	607c <FatFile::seekSet(unsigned long)+0x9e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    5fee:	ldr	r5, [r4, #20]
    5ff0:	cmp	r5, r1
    5ff2:	beq.n	6084 <FatFile::seekSet(unsigned long)+0xa6>
    return true;
  }
  if (pos == 0) {
    5ff4:	cbnz	r1, 5ffa <FatFile::seekSet(unsigned long)+0x1c>
    // set position to start of file
    m_curCluster = 0;
    5ff6:	str	r1, [r4, #16]
    goto done;
    5ff8:	b.n	6070 <FatFile::seekSet(unsigned long)+0x92>
  }
  if (isFile()) {
    5ffa:	lsls	r2, r0, #28
    5ffc:	bpl.n	6006 <FatFile::seekSet(unsigned long)+0x28>
    if (pos > m_fileSize) {
    5ffe:	ldr	r3, [r4, #28]
    6000:	cmp	r1, r3
    6002:	bhi.n	607c <FatFile::seekSet(unsigned long)+0x9e>
    6004:	b.n	6016 <FatFile::seekSet(unsigned long)+0x38>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (isRootFixed()) {
    6006:	lsls	r3, r0, #26
    6008:	bpl.n	6016 <FatFile::seekSet(unsigned long)+0x38>
    600a:	ldr	r3, [r4, #8]
    if (pos <= 32*m_vol->rootDirEntryCount()) {
    600c:	ldrh	r3, [r3, #8]
    600e:	cmp.w	r1, r3, lsl #5
    6012:	bhi.n	607c <FatFile::seekSet(unsigned long)+0x9e>
    6014:	b.n	6070 <FatFile::seekSet(unsigned long)+0x92>
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    6016:	ldr.w	lr, [r4, #8]
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    601a:	ldrb	r1, [r4, #2]
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    601c:	ldrb.w	r2, [lr, #6]
    6020:	adds	r2, #9
    6022:	uxtb	r2, r2
    6024:	subs	r3, r6, #1
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    6026:	lsls	r1, r1, #25
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    6028:	lsr.w	r3, r3, r2
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    602c:	bpl.n	6036 <FatFile::seekSet(unsigned long)+0x58>
    m_curCluster = m_firstCluster + nNew;
    602e:	ldr	r2, [r4, #32]
    6030:	add	r3, r2
    6032:	str	r3, [r4, #16]
    goto done;
    6034:	b.n	6070 <FatFile::seekSet(unsigned long)+0x92>
  }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> (m_vol->bytesPerClusterShift());
    6036:	subs	r1, r5, #1
    6038:	lsr.w	r2, r1, r2

  if (nNew < nCur || m_curPosition == 0) {
    603c:	cmp	r3, r2
    603e:	bcc.n	6042 <FatFile::seekSet(unsigned long)+0x64>
    6040:	cbnz	r5, 6056 <FatFile::seekSet(unsigned long)+0x78>
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    6042:	lsls	r2, r0, #25
    6044:	ite	mi
    6046:	ldrmi.w	r2, [lr, #32]
    604a:	ldrpl	r2, [r4, #32]
    604c:	str	r2, [r4, #16]
    604e:	mov	r5, r3
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    6050:	add.w	r8, r4, #16
    6054:	b.n	606c <FatFile::seekSet(unsigned long)+0x8e>
  if (nNew < nCur || m_curPosition == 0) {
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    6056:	subs	r3, r3, r2
    6058:	b.n	604e <FatFile::seekSet(unsigned long)+0x70>
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    605a:	mov	r2, r8
    605c:	ldr	r1, [r4, #16]
    605e:	ldr	r0, [r4, #8]
    6060:	bl	6a78 <FatPartition::fatGet(unsigned long, unsigned long*)>
    6064:	cmp	r0, #0
    6066:	add.w	r5, r5, #4294967295
    606a:	ble.n	607c <FatFile::seekSet(unsigned long)+0x9e>
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    606c:	cmp	r5, #0
    606e:	bne.n	605a <FatFile::seekSet(unsigned long)+0x7c>
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    6070:	ldrb	r3, [r4, #2]
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    6072:	str	r6, [r4, #20]
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    6074:	bic.w	r3, r3, #32
    6078:	strb	r3, [r4, #2]
    607a:	b.n	6084 <FatFile::seekSet(unsigned long)+0xa6>
  return true;

 fail:
  m_curCluster = tmp;
    607c:	str	r7, [r4, #16]
  return false;
    607e:	movs	r0, #0
    6080:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    6084:	movs	r0, #1
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    6086:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000608a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>:
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    608a:	push	{r3, r4, r5, r6, r7, lr}
    608c:	mov	r7, r1
    608e:	mov	r6, r2
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    6090:	movs	r1, #0
    6092:	movs	r2, #36	; 0x24
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    6094:	mov	r4, r0
    6096:	mov	r5, r3
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    6098:	bl	90bc <memset>
  // location of entry in cache
  m_vol = dirFile->m_vol;
    609c:	ldr	r0, [r7, #8]
  m_dirIndex = dirIndex;
    609e:	strh	r6, [r4, #4]
    60a0:	add.w	r2, r0, #56	; 0x38
  m_dirCluster = dirFile->m_firstCluster;
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;
    60a4:	and.w	r6, r6, #15
    60a8:	add.w	r2, r2, r6, lsl #5
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    60ac:	ldr	r3, [r7, #32]
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
    60ae:	str	r0, [r4, #8]
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    60b0:	str	r3, [r4, #12]
    60b2:	ldrb	r1, [r2, #11]
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;

  // Must be file or subdirectory.
  if (!isFileOrSubdir(dir)) {
    60b4:	lsls	r6, r1, #28
    60b6:	bmi.n	6136 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
    60b8:	and.w	r1, r1, #23
    60bc:	strb	r1, [r4, #0]
  if (isFileDir(dir)) {
    60be:	ldrb	r3, [r2, #11]
    60c0:	tst.w	r3, #24
    m_attributes |= FILE_ATTR_FILE;
  }
  m_lfnOrd = lfnOrd;
    60c4:	ldrb.w	r3, [sp, #24]
    60c8:	strb	r3, [r4, #3]
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    m_attributes |= FILE_ATTR_FILE;
    60ca:	it	eq
    60cc:	orreq.w	r1, r1, #8
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    60d0:	and.w	r3, r5, #3
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    m_attributes |= FILE_ATTR_FILE;
    60d4:	it	eq
    60d6:	strbeq	r1, [r4, #0]
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    60d8:	cmp	r3, #1
    60da:	beq.n	60ee <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x64>
    60dc:	cmp	r3, #2
    60de:	beq.n	60ea <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x60>
    60e0:	cbnz	r3, 6136 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    case O_RDONLY:
      if (oflag & O_TRUNC) {
    60e2:	lsls	r3, r5, #21
    60e4:	bmi.n	6136 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
        DBG_FAIL_MACRO;
        goto fail;
      }
      m_flags = FILE_FLAG_READ;
    60e6:	movs	r3, #1
    60e8:	b.n	60f0 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
      break;

    case O_RDWR:
      m_flags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    60ea:	movs	r3, #3
    60ec:	b.n	60f0 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
      break;

    case O_WRONLY:
      m_flags = FILE_FLAG_WRITE;
    60ee:	movs	r3, #2
    60f0:	strb	r3, [r4, #2]
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }

  if (m_flags & FILE_FLAG_WRITE) {
    60f2:	ldrb	r3, [r4, #2]
    60f4:	lsls	r7, r3, #30
    60f6:	bpl.n	6100 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x76>
    if (isSubDir() || isReadOnly()) {
    60f8:	ldrb	r1, [r4, #0]
    60fa:	tst.w	r1, #17
    60fe:	bne.n	6136 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_flags |= (oflag & O_APPEND ? FILE_FLAG_APPEND : 0);
    6100:	and.w	r1, r5, #8
    6104:	orrs	r3, r1
    6106:	strb	r3, [r4, #2]
    6108:	ldr	r3, [r0, #52]	; 0x34

  m_dirSector = m_vol->cacheSectorNumber();
    610a:	str	r3, [r4, #24]

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    610c:	ldrh	r1, [r2, #20]
    610e:	ldrh	r3, [r2, #26]

  if (oflag & O_TRUNC) {
    6110:	lsls	r6, r5, #21

  m_dirSector = m_vol->cacheSectorNumber();

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    6112:	orr.w	r1, r3, r1, lsl #16

  if (oflag & O_TRUNC) {
    6116:	bpl.n	6122 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x98>
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
    6118:	cbz	r1, 613e <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xb4>
    611a:	bl	6bbe <FatPartition::freeChain(unsigned long)>
    611e:	cbnz	r0, 613e <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xb4>
    6120:	b.n	6136 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else {
    m_firstCluster = firstCluster;
    6122:	str	r1, [r4, #32]
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    6124:	ldr	r3, [r2, #28]
    m_fileSize = getLe32(dir->fileSize);
    6126:	str	r3, [r4, #28]
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    6128:	lsls	r3, r5, #17
    612a:	bpl.n	6148 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xbe>
    612c:	ldr	r1, [r4, #28]
    612e:	mov	r0, r4
    6130:	bl	5fde <FatFile::seekSet(unsigned long)>
    6134:	cbnz	r0, 6148 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xbe>
    goto fail;
  }
  return true;

 fail:
  m_attributes = FILE_ATTR_CLOSED;
    6136:	movs	r0, #0
    6138:	strb	r0, [r4, #0]
  m_flags = 0;
    613a:	strb	r0, [r4, #2]
  return false;
    613c:	pop	{r3, r4, r5, r6, r7, pc}
      DBG_FAIL_MACRO;
      goto fail;
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    613e:	ldrb	r3, [r4, #2]
    6140:	orn	r3, r3, #127	; 0x7f
    6144:	strb	r3, [r4, #2]
    6146:	b.n	6128 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x9e>
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return true;
    6148:	movs	r0, #1

 fail:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
    614a:	pop	{r3, r4, r5, r6, r7, pc}

0000614c <FatFile::openNext(FatFile*, int)>:
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    614c:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    6150:	ldrb	r3, [r0, #0]
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    6152:	mov	r6, r0
    6154:	mov	r5, r1
    6156:	mov	r9, r2
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    6158:	cbnz	r3, 61ca <FatFile::openNext(FatFile*, int)+0x7e>
    615a:	ldrb	r3, [r1, #0]
    615c:	tst.w	r3, #112	; 0x70
    6160:	beq.n	61ca <FatFile::openNext(FatFile*, int)+0x7e>
    6162:	ldr	r4, [r1, #20]
    6164:	ands.w	r4, r4, #31
    6168:	bne.n	61ca <FatFile::openNext(FatFile*, int)+0x7e>
    616a:	mov	r7, r4
    goto fail;
  }
  while (1) {
    // read entry into cache
    index = dirFile->curPosition()/32;
    DirFat_t* dir = dirFile->readDirCache();
    616c:	movs	r1, #0
    616e:	mov	r0, r5
    6170:	ldr.w	r8, [r5, #20]
    6174:	bl	5fa4 <FatFile::readDirCache(bool)>
    if (!dir) {
    6178:	cbz	r0, 61ca <FatFile::openNext(FatFile*, int)+0x7e>
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    // done if last entry
    if (dir->name[0] == FAT_NAME_FREE) {
    617a:	ldrb	r3, [r0, #0]
    617c:	cbz	r3, 61ca <FatFile::openNext(FatFile*, int)+0x7e>
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
    617e:	cmp	r3, #46	; 0x2e
    6180:	bne.n	6186 <FatFile::openNext(FatFile*, int)+0x3a>
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
        lfnOrd = ldir->order & 0X1F;
        checksum = ldir->checksum;
      }
    } else {
      lfnOrd = 0;
    6182:	movs	r4, #0
    6184:	b.n	616c <FatFile::openNext(FatFile*, int)+0x20>
    // done if last entry
    if (dir->name[0] == FAT_NAME_FREE) {
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
    6186:	cmp	r3, #229	; 0xe5
    6188:	beq.n	6182 <FatFile::openNext(FatFile*, int)+0x36>
    618a:	ldrb	r2, [r0, #11]
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
    618c:	and.w	lr, r2, #8
    6190:	and.w	r1, lr, #255	; 0xff
    6194:	cmp.w	lr, #0
    6198:	bne.n	61ba <FatFile::openNext(FatFile*, int)+0x6e>
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
    619a:	cbz	r4, 61ce <FatFile::openNext(FatFile*, int)+0x82>
    619c:	subs	r2, r0, #1
    619e:	adds	r0, #10
    61a0:	lsls	r3, r1, #7
    61a2:	orr.w	r1, r3, r1, lsr #1
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    61a6:	ldrb.w	r3, [r2, #1]!
    61aa:	uxtab	r1, r3, r1
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    61ae:	cmp	r0, r2
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    61b0:	uxtb	r1, r1
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    61b2:	bne.n	61a0 <FatFile::openNext(FatFile*, int)+0x54>
    61b4:	cmp	r7, r1
    61b6:	bne.n	61ca <FatFile::openNext(FatFile*, int)+0x7e>
    61b8:	b.n	61ce <FatFile::openNext(FatFile*, int)+0x82>
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      return true;
    } else if (isLongName(dir)) {
    61ba:	cmp	r2, #15
    61bc:	bne.n	6182 <FatFile::openNext(FatFile*, int)+0x36>
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
    61be:	lsls	r2, r3, #25
    61c0:	bpl.n	616c <FatFile::openNext(FatFile*, int)+0x20>
        lfnOrd = ldir->order & 0X1F;
    61c2:	and.w	r4, r3, #31
        checksum = ldir->checksum;
    61c6:	ldrb	r7, [r0, #13]
    61c8:	b.n	616c <FatFile::openNext(FatFile*, int)+0x20>
      lfnOrd = 0;
    }
  }

 fail:
  return false;
    61ca:	movs	r0, #0
    61cc:	b.n	61de <FatFile::openNext(FatFile*, int)+0x92>
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
    61ce:	str	r4, [sp, #0]
    61d0:	mov	r3, r9
    61d2:	ubfx	r2, r8, #5, #16
    61d6:	mov	r1, r5
    61d8:	mov	r0, r6
    61da:	bl	608a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    }
  }

 fail:
  return false;
}
    61de:	add	sp, #12
    61e0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

000061e4 <FatFile::rmdir()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
    61e4:	push	{r4, lr}
  // must be open subdirectory
  if (!isSubDir() || (!USE_LONG_FILE_NAMES && isLFN())) {
    61e6:	ldrb	r3, [r0, #0]
    61e8:	lsls	r2, r3, #27

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
    61ea:	mov	r4, r0
  // must be open subdirectory
  if (!isSubDir() || (!USE_LONG_FILE_NAMES && isLFN())) {
    61ec:	bpl.n	622e <FatFile::rmdir()+0x4a>
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    61ee:	movs	r1, #0
    61f0:	bl	5fde <FatFile::seekSet(unsigned long)>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    DirFat_t* dir = readDirCache(true);
    61f4:	movs	r1, #1
    61f6:	mov	r0, r4
    61f8:	bl	5fa4 <FatFile::readDirCache(bool)>
    if (!dir) {
    61fc:	cbnz	r0, 6204 <FatFile::rmdir()+0x20>
      // EOF if no error.
      if (!getError()) {
    61fe:	ldrb	r3, [r4, #1]
    6200:	cbz	r3, 6218 <FatFile::rmdir()+0x34>
    6202:	b.n	622e <FatFile::rmdir()+0x4a>
      }
      DBG_FAIL_MACRO;
      goto fail;
    }
    // done if past last used entry
    if (dir->name[0] == FAT_NAME_FREE) {
    6204:	ldrb	r3, [r0, #0]
    6206:	cbz	r3, 6218 <FatFile::rmdir()+0x34>
      break;
    }
    // skip empty slot, '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    6208:	cmp	r3, #229	; 0xe5
    620a:	beq.n	61f4 <FatFile::rmdir()+0x10>
    620c:	cmp	r3, #46	; 0x2e
    620e:	beq.n	61f4 <FatFile::rmdir()+0x10>
      continue;
    }
    // error not empty
    if (isFileOrSubdir(dir)) {
    6210:	ldrb	r3, [r0, #11]
    6212:	lsls	r3, r3, #28
    6214:	bmi.n	61f4 <FatFile::rmdir()+0x10>
    6216:	b.n	622e <FatFile::rmdir()+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    6218:	movs	r3, #8
    621a:	strb	r3, [r4, #0]
  m_flags |= FILE_FLAG_WRITE;
    621c:	ldrb	r3, [r4, #2]
    621e:	orr.w	r3, r3, #2
    6222:	strb	r3, [r4, #2]
  return remove();
    6224:	mov	r0, r4

 fail:
  return false;
}
    6226:	ldmia.w	sp!, {r4, lr}
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    622a:	b.w	73e0 <FatFile::remove()>

 fail:
  return false;
}
    622e:	movs	r0, #0
    6230:	pop	{r4, pc}
    6232:	Address 0x00006232 is out of bounds.


00006234 <FatFile::sync()>:
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    6234:	push	{r0, r1, r2, r4, r5, lr}
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    6236:	ldrb	r3, [r0, #0]
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    6238:	mov	r4, r0
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    623a:	cmp	r3, #0
    623c:	beq.n	62a8 <FatFile::sync()+0x74>
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    623e:	ldrsb.w	r3, [r0, #2]
    6242:	cmp	r3, #0
    6244:	bge.n	629c <FatFile::sync()+0x68>
    DirFat_t* dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6246:	movs	r1, #1
    6248:	bl	5d88 <FatFile::cacheDirEntry(unsigned char)>
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
    624c:	mov	r5, r0
    624e:	cbnz	r0, 625c <FatFile::sync()+0x28>
    return true;
  }
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
    6250:	ldrb	r3, [r4, #1]
    6252:	orr.w	r3, r3, #1
    6256:	strb	r3, [r4, #1]
  return false;
    6258:	movs	r0, #0
    625a:	b.n	62aa <FatFile::sync()+0x76>
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    DirFat_t* dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
    625c:	ldrb	r3, [r0, #0]
    625e:	cmp	r3, #229	; 0xe5
    6260:	beq.n	6250 <FatFile::sync()+0x1c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // do not set filesize for dir files
    if (isFile()) {
    6262:	ldrb	r3, [r4, #0]
    6264:	lsls	r3, r3, #28
      setLe32(dir->fileSize, m_fileSize);
    6266:	itt	mi
    6268:	ldrmi	r3, [r4, #28]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    626a:	strmi	r3, [r0, #28]
    }
    // update first cluster fields
    setLe16(dir->firstClusterLow, m_firstCluster & 0XFFFF);
    626c:	ldr	r3, [r4, #32]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    626e:	strh	r3, [r0, #26]
    6270:	lsrs	r3, r3, #16
    6272:	strh	r3, [r0, #20]
    setLe16(dir->firstClusterHigh, m_firstCluster >> 16);

    // set modify time if user supplied a callback date/time function
    if (FsDateTime::callback) {
    6274:	ldr	r3, [pc, #56]	; (62b0 <FatFile::sync()+0x7c>)
    6276:	ldr	r3, [r3, #0]
    6278:	cbz	r3, 6294 <FatFile::sync()+0x60>
      FsDateTime::callback(&date, &time, &ms10);
    627a:	add.w	r2, sp, #3
    627e:	add.w	r1, sp, #6
    6282:	add	r0, sp, #4
    6284:	blx	r3
      setLe16(dir->modifyDate, date);
    6286:	ldrh.w	r3, [sp, #4]
    628a:	strh	r3, [r5, #24]
    628c:	strh	r3, [r5, #18]
    628e:	ldrh.w	r3, [sp, #6]
    6292:	strh	r3, [r5, #22]
      setLe16(dir->accessDate, date);
      setLe16(dir->modifyTime, time);
    }
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    6294:	ldrb	r3, [r4, #2]
    6296:	and.w	r3, r3, #127	; 0x7f
    629a:	strb	r3, [r4, #2]
  }
  if (m_vol->cacheSync()) {
    629c:	ldr	r0, [r4, #8]
    629e:	bl	5ca0 <FatPartition::cacheSync()>
    62a2:	cmp	r0, #0
    62a4:	beq.n	6250 <FatFile::sync()+0x1c>
    62a6:	b.n	62aa <FatFile::sync()+0x76>
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
    62a8:	movs	r0, #1
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    62aa:	add	sp, #12
    62ac:	pop	{r4, r5, pc}
    62ae:	nop
    62b0:	.word	0x2001a690

000062b4 <FatFile::close()>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
    62b4:	push	{r4, lr}
    62b6:	mov	r4, r0
  bool rtn = sync();
    62b8:	bl	6234 <FatFile::sync()>
  m_attributes = FILE_ATTR_CLOSED;
    62bc:	movs	r3, #0
    62be:	strb	r3, [r4, #0]
  m_flags = 0;
    62c0:	strb	r3, [r4, #2]
  return rtn;
}
    62c2:	pop	{r4, pc}

000062c4 <FatFile::open(FatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    62c4:	push	{r4, r5, r6, r7, lr}
    62c6:	sub	sp, #84	; 0x54
    62c8:	mov	r7, r3
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    62ca:	movs	r3, #0
    62cc:	strb.w	r3, [sp, #8]
    62d0:	strb.w	r3, [sp, #9]
    62d4:	strb.w	r3, [sp, #10]
    62d8:	strh.w	r3, [sp, #56]	; 0x38
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    62dc:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    62de:	str	r2, [sp, #4]
    62e0:	mov	r6, r0
    62e2:	mov	r4, r1
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    62e4:	cbz	r3, 62ea <FatFile::open(FatFile*, char const*, int)+0x26>
    close();
  }
  return open(dirFile, &fname, oflag);

 fail:
  return false;
    62e6:	movs	r0, #0
    62e8:	b.n	6368 <FatFile::open(FatFile*, char const*, int)+0xa4>
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    62ea:	ldrb	r3, [r1, #0]
    62ec:	tst.w	r3, #112	; 0x70
    62f0:	beq.n	62e6 <FatFile::open(FatFile*, char const*, int)+0x22>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    62f2:	ldrb	r3, [r2, #0]
    62f4:	cmp	r3, #47	; 0x2f
    62f6:	bne.n	631e <FatFile::open(FatFile*, char const*, int)+0x5a>
    while (isDirSeparator(*path)) {
    62f8:	ldr	r3, [sp, #4]
    62fa:	ldrb	r2, [r3, #0]
    62fc:	cmp	r2, #47	; 0x2f
    62fe:	bne.n	6306 <FatFile::open(FatFile*, char const*, int)+0x42>
      path++;
    6300:	adds	r3, #1
    6302:	str	r3, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    6304:	b.n	62f8 <FatFile::open(FatFile*, char const*, int)+0x34>
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    6306:	ldr	r1, [r4, #8]
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
    6308:	cbnz	r2, 6312 <FatFile::open(FatFile*, char const*, int)+0x4e>
      return openRoot(dirFile->m_vol);
    630a:	mov	r0, r6
    630c:	bl	5da6 <FatFile::openRoot(FatVolume*)>
    6310:	b.n	6368 <FatFile::open(FatFile*, char const*, int)+0xa4>
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    6312:	add	r0, sp, #8
    6314:	bl	5da6 <FatFile::openRoot(FatVolume*)>
    6318:	cmp	r0, #0
    631a:	beq.n	62e6 <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    631c:	add	r4, sp, #8
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    631e:	add	r3, sp, #4
    6320:	add	r2, sp, #44	; 0x2c
    6322:	ldr	r1, [sp, #4]
    6324:	mov	r0, r6
    6326:	bl	7348 <FatFile::parsePathName(char const*, FatName_t*, char const**)>
    632a:	cmp	r0, #0
    632c:	beq.n	62e6 <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    632e:	ldr	r3, [sp, #4]
    6330:	ldrb	r3, [r3, #0]
    6332:	cbz	r3, 635c <FatFile::open(FatFile*, char const*, int)+0x98>
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    6334:	movs	r3, #0
    6336:	add	r2, sp, #44	; 0x2c
    6338:	mov	r1, r4
    633a:	mov	r0, r6
    633c:	bl	70f8 <FatFile::open(FatFile*, FatName_t*, int)>
    6340:	cmp	r0, #0
    6342:	beq.n	62e6 <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_WARN_MACRO;
      goto fail;
    }
    tmpDir = *this;
    6344:	mov	r5, r6
    6346:	ldmia	r5!, {r0, r1, r2, r3}
    6348:	add	r4, sp, #8
    634a:	stmia	r4!, {r0, r1, r2, r3}
    634c:	ldmia	r5!, {r0, r1, r2, r3}
    634e:	stmia	r4!, {r0, r1, r2, r3}
    6350:	ldr	r3, [r5, #0]
    6352:	str	r3, [r4, #0]
    dirFile = &tmpDir;
    close();
    6354:	mov	r0, r6
    6356:	bl	62b4 <FatFile::close()>
    635a:	b.n	631c <FatFile::open(FatFile*, char const*, int)+0x58>
  }
  return open(dirFile, &fname, oflag);
    635c:	mov	r3, r7
    635e:	add	r2, sp, #44	; 0x2c
    6360:	mov	r1, r4
    6362:	mov	r0, r6
    6364:	bl	70f8 <FatFile::open(FatFile*, FatName_t*, int)>

 fail:
  return false;
}
    6368:	add	sp, #84	; 0x54
    636a:	pop	{r4, r5, r6, r7, pc}

0000636c <FatFile::open(FatVolume*, char const*, int)>:
bool FatFile::open(const char* path, oflag_t oflag) {
  return open(FatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
    636c:	cbz	r1, 6376 <FatFile::open(FatVolume*, char const*, int)+0xa>
    636e:	add.w	r1, r1, #1096	; 0x448
    6372:	b.w	62c4 <FatFile::open(FatFile*, char const*, int)>
}
    6376:	mov	r0, r1
    6378:	bx	lr

0000637a <FatFile::dirEntry(DirFat_t*)>:
  close();
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::dirEntry(DirFat_t* dst) {
    637a:	push	{r4, r5, r6, lr}
    637c:	mov	r6, r0
    637e:	mov	r4, r1
  DirFat_t* dir;
  // Make sure fields on device are correct.
  if (!sync()) {
    6380:	bl	6234 <FatFile::sync()>
    6384:	mov	r5, r0
    6386:	cbnz	r0, 638c <FatFile::dirEntry(DirFat_t*)+0x12>
  // copy to caller's struct
  memcpy(dst, dir, sizeof(DirFat_t));
  return true;

 fail:
  return false;
    6388:	movs	r5, #0
    638a:	b.n	63aa <FatFile::dirEntry(DirFat_t*)+0x30>
  if (!sync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    638c:	movs	r1, #0
    638e:	mov	r0, r6
    6390:	bl	5d88 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    6394:	cmp	r0, #0
    6396:	beq.n	6388 <FatFile::dirEntry(DirFat_t*)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy to caller's struct
  memcpy(dst, dir, sizeof(DirFat_t));
    6398:	mov	r1, r4
    639a:	add.w	r3, r0, #32
    639e:	ldr.w	r2, [r0], #4
    63a2:	str.w	r2, [r1], #4
    63a6:	cmp	r0, r3
    63a8:	bne.n	639e <FatFile::dirEntry(DirFat_t*)+0x24>
  return true;

 fail:
  return false;
}
    63aa:	mov	r0, r5
    63ac:	pop	{r4, r5, r6, pc}

000063ae <FatFile::getCreateDateTime(unsigned short*, unsigned short*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    63ae:	push	{r4, r5, lr}
    63b0:	sub	sp, #36	; 0x24
    63b2:	mov	r5, r1
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    63b4:	mov	r1, sp

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    63b6:	mov	r4, r2
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    63b8:	bl	637a <FatFile::dirEntry(DirFat_t*)>
    63bc:	cbz	r0, 63ca <FatFile::getCreateDateTime(unsigned short*, unsigned short*)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(dir.createDate);
    63be:	ldrh.w	r3, [sp, #16]
    63c2:	strh	r3, [r5, #0]
  *ptime = getLe16(dir.createTime);
    63c4:	ldrh.w	r3, [sp, #14]
    63c8:	strh	r3, [r4, #0]
  return true;

 fail:
  return false;
}
    63ca:	add	sp, #36	; 0x24
    63cc:	pop	{r4, r5, pc}

000063ce <FatFile::getModifyDateTime(unsigned short*, unsigned short*)>:
//------------------------------------------------------------------------------
bool FatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    63ce:	push	{r4, r5, lr}
    63d0:	sub	sp, #36	; 0x24
    63d2:	mov	r5, r1
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    63d4:	mov	r1, sp

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    63d6:	mov	r4, r2
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    63d8:	bl	637a <FatFile::dirEntry(DirFat_t*)>
    63dc:	cbz	r0, 63ea <FatFile::getModifyDateTime(unsigned short*, unsigned short*)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(dir.modifyDate);
    63de:	ldrh.w	r3, [sp, #24]
    63e2:	strh	r3, [r5, #0]
  *ptime = getLe16(dir.modifyTime);
    63e4:	ldrh.w	r3, [sp, #22]
    63e8:	strh	r3, [r4, #0]
  return true;

 fail:
  return false;
}
    63ea:	add	sp, #36	; 0x24
    63ec:	pop	{r4, r5, pc}

000063ee <FatFile::mkdir(FatFile*, FatName_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, FatName_t* fname) {
    63ee:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    63f2:	ldrb	r3, [r1, #0]
    63f4:	tst.w	r3, #112	; 0x70

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, FatName_t* fname) {
    63f8:	sub	sp, #32
    63fa:	mov	r4, r0
    63fc:	mov	r6, r1
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    63fe:	beq.n	643a <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    6400:	movw	r3, #2562	; 0xa02
    6404:	bl	70f8 <FatFile::open(FatFile*, FatName_t*, int)>
    6408:	cbz	r0, 643a <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    640a:	movs	r7, #1
  m_attributes = FILE_ATTR_SUBDIR;
    640c:	movs	r5, #16
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    640e:	strb	r7, [r4, #2]
  m_attributes = FILE_ATTR_SUBDIR;
    6410:	strb	r5, [r4, #0]

  // allocate and zero first cluster
  if (!addDirCluster()) {
    6412:	mov	r0, r4
    6414:	bl	5cfc <FatFile::addDirCluster()>
    6418:	cbz	r0, 643a <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    641a:	ldr	r3, [r4, #16]
    641c:	str	r3, [r4, #32]
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    641e:	movs	r1, #0
    6420:	mov	r0, r4
    6422:	bl	5fde <FatFile::seekSet(unsigned long)>
  // Set to start of dir
  rewind();
  // force entry to device
  if (!sync()) {
    6426:	mov	r0, r4
    6428:	bl	6234 <FatFile::sync()>
    642c:	cbz	r0, 643a <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // cache entry - should already be in cache due to sync() call
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    642e:	mov	r1, r7
    6430:	mov	r0, r4
    6432:	bl	5d88 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    6436:	mov	r3, r0
    6438:	cbnz	r0, 643e <FatFile::mkdir(FatFile*, FatName_t*)+0x50>
  memcpy(&pc->dir[1], &dot, sizeof(dot));
  // write first sector
  return m_vol->cacheSync();

 fail:
  return false;
    643a:	movs	r0, #0
    643c:	b.n	64e2 <FatFile::mkdir(FatFile*, FatName_t*)+0xf4>
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // change directory entry attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;
    643e:	strb	r5, [r0, #11]

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
    6440:	mov	r2, r0
    6442:	mov	r7, sp
    6444:	add.w	ip, r0, #32
    6448:	mov	r5, sp
    644a:	ldr	r0, [r2, #0]
    644c:	ldr	r1, [r2, #4]
    644e:	mov	lr, r7
    6450:	stmia.w	lr!, {r0, r1}
    6454:	adds	r2, #8
    6456:	cmp	r2, ip
    6458:	mov	r7, lr
    645a:	bne.n	644a <FatFile::mkdir(FatFile*, FatName_t*)+0x5c>
    645c:	ldrh	r7, [r3, #20]
    645e:	ldrh.w	r8, [r3, #26]
  dot.name[0] = '.';
    6462:	movs	r3, #46	; 0x2e
    6464:	strb.w	r3, [sp]
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    6468:	movs	r1, #32
  // change directory entry attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
    646a:	movs	r3, #0
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    646c:	adds	r2, r5, r3
    646e:	adds	r3, #1
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    6470:	cmp	r3, #10
    dot.name[i] = ' ';
    6472:	strb	r1, [r2, #1]
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    6474:	bne.n	646c <FatFile::mkdir(FatFile*, FatName_t*)+0x7e>
    dot.name[i] = ' ';
  }

  // cache sector for '.'  and '..'
  sector = m_vol->clusterStartSector(m_firstCluster);
    6476:	ldr	r0, [r4, #8]
    6478:	ldr	r1, [r4, #32]
    647a:	ldrb	r3, [r0, #6]
    647c:	subs	r1, #2
    647e:	lsls	r1, r3
    6480:	ldr	r3, [r0, #20]
    6482:	movs	r2, #1
    6484:	add	r1, r3
    6486:	adds	r0, #40	; 0x28
    6488:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
  if (!pc) {
    648c:	mov	r3, r0
    648e:	cmp	r0, #0
    6490:	beq.n	643a <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
    6492:	strh.w	r7, [sp, #20]
    6496:	strh.w	r8, [sp, #26]
    649a:	mov	lr, r5
    649c:	mov	r7, r0
    649e:	add.w	ip, sp, #32
    64a2:	mov	r2, lr
    64a4:	ldmia	r2!, {r0, r1}
    64a6:	cmp	r2, ip
    64a8:	str	r0, [r7, #0]
    64aa:	str	r1, [r7, #4]
    64ac:	mov	lr, r2
    64ae:	add.w	r7, r7, #8
    64b2:	bne.n	64a2 <FatFile::mkdir(FatFile*, FatName_t*)+0xb4>
  // make entry for '..'
  dot.name[1] = '.';
    64b4:	movs	r2, #46	; 0x2e
    64b6:	strb.w	r2, [sp, #1]
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
    64ba:	ldr	r2, [r6, #32]
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    64bc:	strh.w	r2, [sp, #26]
    64c0:	lsrs	r1, r2, #16
    64c2:	strh.w	r1, [sp, #20]
    64c6:	adds	r3, #32
    64c8:	add	r6, sp, #32
    64ca:	mov	r2, r5
    64cc:	ldmia	r2!, {r0, r1}
    64ce:	cmp	r2, r6
    64d0:	str	r0, [r3, #0]
    64d2:	str	r1, [r3, #4]
    64d4:	mov	r5, r2
    64d6:	add.w	r3, r3, #8
    64da:	bne.n	64ca <FatFile::mkdir(FatFile*, FatName_t*)+0xdc>
  // write first sector
  return m_vol->cacheSync();
    64dc:	ldr	r0, [r4, #8]
    64de:	bl	5ca0 <FatPartition::cacheSync()>

 fail:
  return false;
}
    64e2:	add	sp, #32
    64e4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000064e8 <FatFile::mkdir(FatFile*, char const*, bool)>:
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    64e8:	push	{r4, r5, r6, r7, lr}
    64ea:	sub	sp, #84	; 0x54
    64ec:	mov	r7, r3
    64ee:	movs	r3, #0
    64f0:	strh.w	r3, [sp, #20]
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    64f4:	strb.w	r3, [sp, #44]	; 0x2c
    64f8:	strb.w	r3, [sp, #45]	; 0x2d
    64fc:	strb.w	r3, [sp, #46]	; 0x2e
  FatName_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    6500:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    6502:	str	r2, [sp, #4]
    6504:	mov	r6, r0
    6506:	mov	r4, r1
  FatName_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    6508:	cmp	r3, #0
    650a:	bne.n	658c <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    650c:	ldrb	r3, [r1, #0]
    650e:	tst.w	r3, #112	; 0x70
    6512:	beq.n	658c <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    6514:	ldrb	r3, [r2, #0]
    6516:	cmp	r3, #47	; 0x2f
    6518:	bne.n	6534 <FatFile::mkdir(FatFile*, char const*, bool)+0x4c>
    while (isDirSeparator(*path)) {
    651a:	ldr	r3, [sp, #4]
    651c:	ldrb	r2, [r3, #0]
    651e:	cmp	r2, #47	; 0x2f
    6520:	bne.n	6528 <FatFile::mkdir(FatFile*, char const*, bool)+0x40>
      path++;
    6522:	adds	r3, #1
    6524:	str	r3, [sp, #4]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    6526:	b.n	651a <FatFile::mkdir(FatFile*, char const*, bool)+0x32>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    6528:	ldr	r1, [r4, #8]
    652a:	add	r0, sp, #44	; 0x2c
    652c:	bl	5da6 <FatFile::openRoot(FatVolume*)>
    6530:	cbz	r0, 658c <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    6532:	add	r4, sp, #44	; 0x2c
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    6534:	add	r3, sp, #4
    6536:	add	r2, sp, #8
    6538:	ldr	r1, [sp, #4]
    653a:	mov	r0, r6
    653c:	bl	7348 <FatFile::parsePathName(char const*, FatName_t*, char const**)>
    6540:	cbz	r0, 658c <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    6542:	ldr	r3, [sp, #4]
    6544:	ldrb	r3, [r3, #0]
    6546:	cbz	r3, 6580 <FatFile::mkdir(FatFile*, char const*, bool)+0x98>
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    6548:	movs	r3, #0
    654a:	add	r2, sp, #8
    654c:	mov	r1, r4
    654e:	mov	r0, r6
    6550:	bl	70f8 <FatFile::open(FatFile*, FatName_t*, int)>
    6554:	cbz	r0, 656e <FatFile::mkdir(FatFile*, char const*, bool)+0x86>
      if (!pFlag || !mkdir(parent, &fname)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    6556:	mov	r5, r6
    6558:	ldmia	r5!, {r0, r1, r2, r3}
    655a:	add	r4, sp, #44	; 0x2c
    655c:	stmia	r4!, {r0, r1, r2, r3}
    655e:	ldmia	r5!, {r0, r1, r2, r3}
    6560:	stmia	r4!, {r0, r1, r2, r3}
    6562:	ldr	r3, [r5, #0]
    6564:	str	r3, [r4, #0]
    parent = &tmpDir;
    close();
    6566:	mov	r0, r6
    6568:	bl	62b4 <FatFile::close()>
    656c:	b.n	6532 <FatFile::mkdir(FatFile*, char const*, bool)+0x4a>
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
      if (!pFlag || !mkdir(parent, &fname)) {
    656e:	cbz	r7, 658c <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    6570:	add	r2, sp, #8
    6572:	mov	r1, r4
    6574:	mov	r0, r6
    6576:	bl	63ee <FatFile::mkdir(FatFile*, FatName_t*)>
    657a:	cmp	r0, #0
    657c:	bne.n	6556 <FatFile::mkdir(FatFile*, char const*, bool)+0x6e>
    657e:	b.n	658c <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    6580:	add	r2, sp, #8
    6582:	mov	r1, r4
    6584:	mov	r0, r6
    6586:	bl	63ee <FatFile::mkdir(FatFile*, FatName_t*)>
    658a:	b.n	658e <FatFile::mkdir(FatFile*, char const*, bool)+0xa6>

 fail:
  return false;
    658c:	movs	r0, #0
}
    658e:	add	sp, #84	; 0x54
    6590:	pop	{r4, r5, r6, r7, pc}

00006592 <FatFile::rename(FatFile*, char const*)>:
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    6592:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    6596:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    6598:	sub	sp, #108	; 0x6c
    659a:	movs	r7, #0
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    659c:	tst.w	r3, #24
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    65a0:	mov	r4, r0
    65a2:	mov	r8, r1
    65a4:	mov	r9, r2
    65a6:	strb.w	r7, [sp, #32]
    65aa:	strb.w	r7, [sp, #33]	; 0x21
    65ae:	strb.w	r7, [sp, #34]	; 0x22
    65b2:	strb.w	r7, [sp, #68]	; 0x44
    65b6:	strb.w	r7, [sp, #69]	; 0x45
    65ba:	strb.w	r7, [sp, #70]	; 0x46
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    65be:	bne.n	65c4 <FatFile::rename(FatFile*, char const*)+0x32>
    goto fail;
  }
  return m_vol->cacheSync();

 fail:
  return false;
    65c0:	movs	r0, #0
    65c2:	b.n	6722 <FatFile::rename(FatFile*, char const*)+0x190>
  if (!USE_LONG_FILE_NAMES && isLFN()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    65c4:	ldr	r2, [r0, #8]
    65c6:	ldr	r3, [r1, #8]
    65c8:	cmp	r2, r3
    65ca:	bne.n	65c0 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // sync() and cache directory entry
  sync();
  oldFile = *this;
    65cc:	mov	r6, r4
  if (m_vol != dirFile->m_vol) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // sync() and cache directory entry
  sync();
    65ce:	bl	6234 <FatFile::sync()>
  oldFile = *this;
    65d2:	ldmia	r6!, {r0, r1, r2, r3}
    65d4:	add	r5, sp, #68	; 0x44
    65d6:	stmia	r5!, {r0, r1, r2, r3}
    65d8:	ldmia	r6!, {r0, r1, r2, r3}
    65da:	stmia	r5!, {r0, r1, r2, r3}
    65dc:	ldr	r3, [r6, #0]
    65de:	str	r3, [r5, #0]
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    65e0:	mov	r1, r7
    65e2:	mov	r0, r4
    65e4:	bl	5d88 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    65e8:	cmp	r0, #0
    65ea:	beq.n	65c0 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    65ec:	mov	r3, r0
    65ee:	mov	r2, sp
    65f0:	add.w	r7, r0, #32
    65f4:	mov	r5, sp
    65f6:	ldr	r0, [r3, #0]
    65f8:	ldr	r1, [r3, #4]
    65fa:	mov	r6, r2
    65fc:	stmia	r6!, {r0, r1}
    65fe:	adds	r3, #8
    6600:	cmp	r3, r7
    6602:	mov	r2, r6
    6604:	bne.n	65f6 <FatFile::rename(FatFile*, char const*)+0x64>
  // make directory entry for new path
  if (isFile()) {
    6606:	ldrb	r2, [r4, #0]
    6608:	and.w	r2, r2, #8
    660c:	and.w	r3, r2, #255	; 0xff
    6610:	add	r6, sp, #32
    6612:	cbz	r2, 662a <FatFile::rename(FatFile*, char const*)+0x98>
    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    6614:	movw	r3, #2561	; 0xa01
    6618:	mov	r2, r9
    661a:	mov	r1, r8
    661c:	mov	r0, r6
    661e:	bl	62c4 <FatFile::open(FatFile*, char const*, int)>
    6622:	cmp	r0, #0
    6624:	beq.n	65c0 <FatFile::rename(FatFile*, char const*)+0x2e>
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
  DirFat_t entry;
  uint32_t dirCluster = 0;
    6626:	movs	r7, #0
    6628:	b.n	663a <FatFile::rename(FatFile*, char const*)+0xa8>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // don't create missing path prefix components
    if (!file.mkdir(dirFile, newPath, false)) {
    662a:	mov	r2, r9
    662c:	mov	r1, r8
    662e:	mov	r0, r6
    6630:	bl	64e8 <FatFile::mkdir(FatFile*, char const*, bool)>
    6634:	cmp	r0, #0
    6636:	beq.n	65c0 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
    6638:	ldr	r7, [sp, #64]	; 0x40
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
    663a:	ldr	r3, [sp, #56]	; 0x38
    663c:	str	r3, [r4, #24]
  m_dirIndex = file.m_dirIndex;
    663e:	ldrh.w	r3, [sp, #36]	; 0x24
    6642:	strh	r3, [r4, #4]
  m_lfnOrd = file.m_lfnOrd;
    6644:	ldrb.w	r3, [sp, #35]	; 0x23
    6648:	strb	r3, [r4, #3]
  m_dirCluster = file.m_dirCluster;
    664a:	ldr	r3, [sp, #44]	; 0x2c
    664c:	str	r3, [r4, #12]
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    664e:	movs	r1, #1
  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    6650:	movs	r3, #0
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6652:	mov	r0, r4
  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    6654:	strb.w	r3, [sp, #32]
  file.m_flags = 0;
    6658:	strb.w	r3, [sp, #34]	; 0x22

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    665c:	bl	5d88 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    6660:	cmp	r0, #0
    6662:	beq.n	65c0 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy all but name and name flags to new directory entry
  memcpy(&dir->createTimeMs, &entry.createTimeMs,
         sizeof(entry) - sizeof(dir->name) - 2);
    6664:	add.w	r3, sp, #13
    6668:	add.w	r2, r0, #13
    666c:	add.w	r1, sp, #29
    6670:	ldr.w	lr, [r3], #4
    6674:	str.w	lr, [r2], #4
    6678:	cmp	r3, r1
    667a:	bne.n	6670 <FatFile::rename(FatFile*, char const*)+0xde>
    667c:	ldrh	r1, [r3, #0]
    667e:	strh	r1, [r2, #0]
    6680:	ldrb	r3, [r3, #2]
    6682:	strb	r3, [r2, #2]
  dir->attributes = entry.attributes;
    6684:	ldrb.w	r3, [sp, #11]
    6688:	strb	r3, [r0, #11]

  // update dot dot if directory
  if (dirCluster) {
    668a:	cmp	r7, #0
    668c:	beq.n	6700 <FatFile::rename(FatFile*, char const*)+0x16e>
    // get new dot dot
    uint32_t sector = m_vol->clusterStartSector(dirCluster);
    668e:	ldr	r0, [r4, #8]
    6690:	ldrb	r1, [r0, #6]
    6692:	subs	r3, r7, #2
    6694:	lsls	r3, r1
    6696:	ldr	r1, [r0, #20]
    6698:	movs	r2, #0
    669a:	add	r1, r3
    669c:	adds	r0, #40	; 0x28
    669e:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    66a2:	cmp	r0, #0
    66a4:	beq.n	65c0 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&entry, &pc->dir[1], sizeof(entry));
    66a6:	add.w	r3, r0, #32
    66aa:	mov	lr, r5
    66ac:	add.w	ip, r0, #64	; 0x40
    66b0:	ldr	r0, [r3, #0]
    66b2:	ldr	r1, [r3, #4]
    66b4:	mov	r2, lr
    66b6:	stmia	r2!, {r0, r1}
    66b8:	adds	r3, #8
    66ba:	cmp	r3, ip
    66bc:	mov	lr, r2
    66be:	bne.n	66b0 <FatFile::rename(FatFile*, char const*)+0x11e>

    // free unused cluster
    if (!m_vol->freeChain(dirCluster)) {
    66c0:	mov	r1, r7
    66c2:	ldr	r0, [r4, #8]
    66c4:	bl	6bbe <FatPartition::freeChain(unsigned long)>
    66c8:	cmp	r0, #0
    66ca:	beq.w	65c0 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // store new dot dot
    sector = m_vol->clusterStartSector(m_firstCluster);
    66ce:	ldr	r0, [r4, #8]
    66d0:	ldr	r1, [r4, #32]
    66d2:	ldrb	r3, [r0, #6]
    66d4:	subs	r1, #2
    66d6:	lsls	r1, r3
    66d8:	ldr	r3, [r0, #20]
    66da:	movs	r2, #1
    66dc:	add	r1, r3
    66de:	adds	r0, #40	; 0x28
    66e0:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    66e4:	cmp	r0, #0
    66e6:	beq.w	65c0 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&pc->dir[1], &entry, sizeof(entry));
    66ea:	add.w	r3, r0, #32
    66ee:	mov	r2, r5
    66f0:	ldmia	r2!, {r0, r1}
    66f2:	cmp	r2, r6
    66f4:	str	r0, [r3, #0]
    66f6:	str	r1, [r3, #4]
    66f8:	mov	r5, r2
    66fa:	add.w	r3, r3, #8
    66fe:	bne.n	66ee <FatFile::rename(FatFile*, char const*)+0x15c>
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    6700:	movs	r3, #0
    6702:	str	r3, [sp, #100]	; 0x64
  oldFile.m_flags = FILE_FLAG_WRITE;
    6704:	movs	r3, #2
    6706:	strb.w	r3, [sp, #70]	; 0x46
  oldFile.m_attributes = FILE_ATTR_FILE;
  if (!oldFile.remove()) {
    670a:	add	r0, sp, #68	; 0x44
    memcpy(&pc->dir[1], &entry, sizeof(entry));
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
    670c:	movs	r3, #8
    670e:	strb.w	r3, [sp, #68]	; 0x44
  if (!oldFile.remove()) {
    6712:	bl	73e0 <FatFile::remove()>
    6716:	cmp	r0, #0
    6718:	beq.w	65c0 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return m_vol->cacheSync();
    671c:	ldr	r0, [r4, #8]
    671e:	bl	5ca0 <FatPartition::cacheSync()>

 fail:
  return false;
}
    6722:	add	sp, #108	; 0x6c
    6724:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00006728 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    6728:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    672c:	mov	r4, r3
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    672e:	ldrb	r3, [r0, #0]
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    6730:	ldrb.w	fp, [sp, #40]	; 0x28
    6734:	ldrb.w	r9, [sp, #44]	; 0x2c
    6738:	ldrb.w	sl, [sp, #48]	; 0x30
    673c:	ldrb.w	r5, [sp, #52]	; 0x34
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    6740:	lsls	r3, r3, #28
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    6742:	mov	r6, r0
    6744:	mov	r7, r1
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    6746:	bmi.n	674e <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x26>
    setLe16(dir->modifyTime, dirTime);
  }
  return m_vol->cacheSync();

 fail:
  return false;
    6748:	movs	r0, #0
    674a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint16_t dirDate;
  uint16_t dirTime;
  DirFat_t* dir;

  if (!isFile()
      || year < 1980
    674e:	subw	r2, r2, #1980	; 0x7bc
    6752:	uxth.w	r8, r2
    6756:	cmp.w	r8, #127	; 0x7f
    675a:	bhi.n	6748 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || year > 2107
      || month < 1
    675c:	subs	r3, r4, #1
    675e:	cmp	r3, #11
    6760:	bhi.n	6748 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || month > 12
      || day < 1
    6762:	add.w	r3, fp, #4294967295
    6766:	cmp	r3, #30
    6768:	bhi.n	6748 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || day > 31
      || hour > 23
    676a:	cmp.w	r9, #23
    676e:	bhi.n	6748 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || minute > 59
    6770:	cmp.w	sl, #59	; 0x3b
    6774:	bhi.n	6748 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || second > 59) {
    6776:	cmp	r5, #59	; 0x3b
    6778:	bhi.n	6748 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // update directory entry
  if (!sync()) {
    677a:	bl	6234 <FatFile::sync()>
    677e:	cmp	r0, #0
    6780:	beq.n	6748 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
    DBG_FAIL_MACRO;
    goto fail;
  }
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6782:	movs	r1, #1
    6784:	mov	r0, r6
    6786:	bl	5d88 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    678a:	cmp	r0, #0
    678c:	beq.n	6748 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    678e:	orr.w	r4, fp, r4, lsl #5
    6792:	orr.w	r8, r4, r8, lsl #9
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    6796:	asrs	r3, r5, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  dirDate = FS_DATE(year, month, day);
  dirTime = FS_TIME(hour, minute, second);
  if (flags & T_ACCESS) {
    6798:	lsls	r4, r7, #31
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    679a:	uxth.w	r8, r8
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    679e:	orr.w	r3, r3, sl, lsl #5
    67a2:	orr.w	r3, r3, r9, lsl #11
    67a6:	it	mi
    67a8:	strhmi.w	r8, [r0, #18]
    setLe16(dir->accessDate, dirDate);
  }
  if (flags & T_CREATE) {
    67ac:	lsls	r1, r7, #30
    67ae:	uxth	r3, r3
    67b0:	bpl.n	67c2 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x9a>
    setLe16(dir->createDate, dirDate);
    setLe16(dir->createTime, dirTime);
    // units of 10 ms
    dir->createTimeMs = second & 1 ? 100 : 0;
    67b2:	ands.w	r5, r5, #1
    67b6:	it	ne
    67b8:	movne	r5, #100	; 0x64
    67ba:	strh.w	r8, [r0, #16]
    67be:	strh	r3, [r0, #14]
    67c0:	strb	r5, [r0, #13]
  }
  if (flags & T_WRITE) {
    67c2:	lsls	r2, r7, #29
    67c4:	itt	mi
    67c6:	strhmi.w	r8, [r0, #24]
    67ca:	strhmi	r3, [r0, #22]
    setLe16(dir->modifyDate, dirDate);
    setLe16(dir->modifyTime, dirTime);
  }
  return m_vol->cacheSync();
    67cc:	ldr	r0, [r6, #8]
    67ce:	bl	5ca0 <FatPartition::cacheSync()>
    67d2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

000067d6 <FatFile::truncate()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    67d6:	push	{r0, r1, r4, lr}
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    67d8:	ldrb	r3, [r0, #2]
    67da:	lsls	r3, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    67dc:	mov	r4, r0
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    67de:	bmi.n	67e4 <FatFile::truncate()+0xe>
  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    67e0:	movs	r0, #0
    67e2:	b.n	683a <FatFile::truncate()+0x64>
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    67e4:	ldr	r3, [r0, #32]
    67e6:	cbz	r3, 6838 <FatFile::truncate()+0x62>
      return true;
  }
  if (m_curCluster) {
    67e8:	ldr	r1, [r0, #16]
    67ea:	cbz	r1, 6810 <FatFile::truncate()+0x3a>
    toFree = 0;
    67ec:	add	r2, sp, #8
    67ee:	movs	r3, #0
    67f0:	str.w	r3, [r2, #-4]!
    int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    67f4:	ldr	r0, [r0, #8]
    67f6:	bl	6a78 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    67fa:	cmp	r0, #0
    67fc:	blt.n	67e0 <FatFile::truncate()+0xa>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg) {
    67fe:	beq.n	6814 <FatFile::truncate()+0x3e>
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    6800:	mvn.w	r2, #4026531840	; 0xf0000000
    6804:	ldr	r1, [r4, #16]
    6806:	ldr	r0, [r4, #8]
    6808:	bl	6ae2 <FatPartition::fatPut(unsigned long, unsigned long)>
      // current cluster is end of chain
      if (!m_vol->fatPutEOC(m_curCluster)) {
    680c:	cbnz	r0, 6814 <FatFile::truncate()+0x3e>
    680e:	b.n	67e0 <FatFile::truncate()+0xa>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  } else {
    toFree = m_firstCluster;
    6810:	str	r3, [sp, #4]
    m_firstCluster = 0;
    6812:	str	r1, [r0, #32]
  }
  if (toFree) {
    6814:	ldr	r1, [sp, #4]
    6816:	cbnz	r1, 682c <FatFile::truncate()+0x56>
    if (!m_vol->freeChain(toFree)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_fileSize = m_curPosition;
    6818:	ldr	r3, [r4, #20]
    681a:	str	r3, [r4, #28]

  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
    681c:	ldrb	r3, [r4, #2]
    681e:	orn	r3, r3, #127	; 0x7f
    6822:	strb	r3, [r4, #2]
  return sync();
    6824:	mov	r0, r4
    6826:	bl	6234 <FatFile::sync()>
    682a:	b.n	683a <FatFile::truncate()+0x64>
  } else {
    toFree = m_firstCluster;
    m_firstCluster = 0;
  }
  if (toFree) {
    if (!m_vol->freeChain(toFree)) {
    682c:	ldr	r0, [r4, #8]
    682e:	bl	6bbe <FatPartition::freeChain(unsigned long)>
    6832:	cmp	r0, #0
    6834:	bne.n	6818 <FatFile::truncate()+0x42>
    6836:	b.n	67e0 <FatFile::truncate()+0xa>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    6838:	movs	r0, #1
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    683a:	add	sp, #8
    683c:	pop	{r4, pc}
    683e:	Address 0x0000683e is out of bounds.


00006840 <FatFile::write(void const*, unsigned int)>:
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    6840:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6844:	ldrb	r3, [r0, #2]
    6846:	mov	r9, r1
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    6848:	lsls	r1, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    684a:	mov	r4, r0
    684c:	mov	r5, r2
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    684e:	bpl.w	696e <FatFile::write(void const*, unsigned int)+0x12e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    6852:	lsls	r2, r3, #28
    6854:	bmi.n	686c <FatFile::write(void const*, unsigned int)+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    6856:	ldr	r3, [r4, #20]
    6858:	mvns	r3, r3
    685a:	cmp	r5, r3
    685c:	bhi.w	696e <FatFile::write(void const*, unsigned int)+0x12e>
    6860:	mov	r7, r5
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6862:	mov.w	sl, #0
    m_sector = 0XFFFFFFFF;
    6866:	mov.w	fp, #4294967295
    686a:	b.n	68fa <FatFile::write(void const*, unsigned int)+0xba>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_fileSize)) {
    686c:	ldr	r1, [r0, #28]
    686e:	bl	5fde <FatFile::seekSet(unsigned long)>
    6872:	cmp	r0, #0
    6874:	bne.n	6856 <FatFile::write(void const*, unsigned int)+0x16>
    6876:	b.n	696e <FatFile::write(void const*, unsigned int)+0x12e>
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    6878:	ldr	r0, [r4, #8]
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    687a:	ldrb	r6, [r0, #5]
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    687c:	ands.w	r6, r6, r2, lsr #9
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    6880:	ubfx	r8, r2, #0, #9
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    6884:	beq.n	6902 <FatFile::write(void const*, unsigned int)+0xc2>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
    6886:	ldr.w	lr, [r4, #8]
                      + sectorOfCluster;
    688a:	ldr	r1, [r4, #16]
    688c:	ldrb.w	r3, [lr, #6]
    6890:	subs	r1, #2
    6892:	lsls	r1, r3
    6894:	ldr.w	r3, [lr, #20]
    6898:	add	r1, r3
    689a:	add	r1, r6

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
    689c:	cmp.w	r8, #0
    68a0:	bne.n	6934 <FatFile::write(void const*, unsigned int)+0xf4>
    68a2:	cmp.w	r7, #512	; 0x200
    68a6:	bcs.n	6982 <FatFile::write(void const*, unsigned int)+0x142>
      // lesser of space and amount to write
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (sectorOffset == 0 &&
    68a8:	ldr	r2, [r4, #20]
    68aa:	ldr	r3, [r4, #28]
    68ac:	cmp	r2, r3
    68ae:	bcs.n	6938 <FatFile::write(void const*, unsigned int)+0xf8>
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
    68b0:	ldrb	r3, [r4, #2]
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    68b2:	tst.w	r3, #32
    68b6:	ite	eq
    68b8:	moveq	r2, #1
    68ba:	movne	r2, #5
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    68bc:	add.w	r0, lr, #40	; 0x28
    68c0:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      pc = m_vol->cacheFetchData(sector, cacheOption);
      if (!pc) {
    68c4:	cmp	r0, #0
    68c6:	beq.n	696e <FatFile::write(void const*, unsigned int)+0x12e>
                      + sectorOfCluster;

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    68c8:	rsb	r6, r8, #512	; 0x200
    68cc:	cmp	r6, r7
    68ce:	it	cs
    68d0:	movcs	r6, r7
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    68d2:	add	r0, r8
    68d4:	mov	r2, r6
    68d6:	mov	r1, r9
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    68d8:	add	r8, r6
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    68da:	bl	8f14 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    68de:	cmp.w	r8, #512	; 0x200
    68e2:	bne.n	68f0 <FatFile::write(void const*, unsigned int)+0xb0>
  }
  void cacheInvalidate() {
    m_cache.invalidate();
  }
  bool cacheSyncData() {
    return m_cache.sync();
    68e4:	ldr	r0, [r4, #8]
    68e6:	adds	r0, #40	; 0x28
    68e8:	bl	381a <FsCache::sync()>
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
      if (nSector > maxSectors) {
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeWrite(sector, src, nSector)) {
    68ec:	cmp	r0, #0
    68ee:	beq.n	696e <FatFile::write(void const*, unsigned int)+0x12e>
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    68f0:	ldr	r3, [r4, #20]
    68f2:	add	r3, r6
    68f4:	str	r3, [r4, #20]
    src += n;
    68f6:	add	r9, r6
    nToWrite -= n;
    68f8:	subs	r7, r7, r6
    68fa:	ldr	r2, [r4, #20]
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    68fc:	cmp	r7, #0
    68fe:	bne.n	6878 <FatFile::write(void const*, unsigned int)+0x38>
    6900:	b.n	693c <FatFile::write(void const*, unsigned int)+0xfc>
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    6902:	cmp.w	r8, #0
    6906:	bne.n	6886 <FatFile::write(void const*, unsigned int)+0x46>
      // start of new cluster
      if (m_curCluster != 0) {
    6908:	ldr	r1, [r4, #16]
    690a:	cbz	r1, 691e <FatFile::write(void const*, unsigned int)+0xde>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
    690c:	ldrb	r3, [r4, #2]
    690e:	lsls	r3, r3, #25
    6910:	bpl.n	6956 <FatFile::write(void const*, unsigned int)+0x116>
    6912:	ldr	r3, [r4, #28]
    6914:	cmp	r2, r3
    6916:	bcs.n	6956 <FatFile::write(void const*, unsigned int)+0x116>
          m_curCluster++;
    6918:	adds	r1, #1
    691a:	str	r1, [r4, #16]
    691c:	b.n	6886 <FatFile::write(void const*, unsigned int)+0x46>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    691e:	ldr	r3, [r4, #32]
    6920:	cbnz	r3, 6930 <FatFile::write(void const*, unsigned int)+0xf0>
          // allocate first cluster of file
          if (!addCluster()) {
    6922:	mov	r0, r4
    6924:	bl	5cc6 <FatFile::addCluster()>
    6928:	cbz	r0, 696e <FatFile::write(void const*, unsigned int)+0x12e>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    692a:	ldr	r3, [r4, #16]
    692c:	str	r3, [r4, #32]
    692e:	b.n	6886 <FatFile::write(void const*, unsigned int)+0x46>
        } else {
          m_curCluster = m_firstCluster;
    6930:	str	r3, [r4, #16]
    6932:	b.n	6886 <FatFile::write(void const*, unsigned int)+0x46>
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    6934:	movs	r2, #1
    6936:	b.n	68bc <FatFile::write(void const*, unsigned int)+0x7c>
      }

      if (sectorOffset == 0 &&
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    6938:	movs	r2, #5
    693a:	b.n	68bc <FatFile::write(void const*, unsigned int)+0x7c>
    }
    m_curPosition += n;
    src += n;
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    693c:	ldr	r3, [r4, #28]
    693e:	cmp	r2, r3
    6940:	bls.n	6946 <FatFile::write(void const*, unsigned int)+0x106>
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    6942:	str	r2, [r4, #28]
    6944:	b.n	694c <FatFile::write(void const*, unsigned int)+0x10c>
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    6946:	ldr	r3, [pc, #180]	; (69fc <FatFile::write(void const*, unsigned int)+0x1bc>)
    6948:	ldr	r3, [r3, #0]
    694a:	cbz	r3, 697c <FatFile::write(void const*, unsigned int)+0x13c>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    694c:	ldrb	r3, [r4, #2]
    694e:	orn	r3, r3, #127	; 0x7f
    6952:	strb	r3, [r4, #2]
    6954:	b.n	697c <FatFile::write(void const*, unsigned int)+0x13c>
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
          m_curCluster++;
          fg = 1;
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    6956:	add.w	r2, r4, #16
    695a:	bl	6a78 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    695e:	cmp	r0, #0
    6960:	blt.n	696e <FatFile::write(void const*, unsigned int)+0x12e>
        if (fg < 0) {
          DBG_FAIL_MACRO;
          goto fail;
        }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        if (fg == 0) {
    6962:	bne.n	69e4 <FatFile::write(void const*, unsigned int)+0x1a4>
          // add cluster if at end of chain
          if (!addCluster()) {
    6964:	mov	r0, r4
    6966:	bl	5cc6 <FatFile::addCluster()>
    696a:	cmp	r0, #0
    696c:	bne.n	69e4 <FatFile::write(void const*, unsigned int)+0x1a4>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    696e:	ldrb	r3, [r4, #1]
    6970:	orr.w	r3, r3, #1
    6974:	strb	r3, [r4, #1]
  return 0;
    6976:	movs	r0, #0
    6978:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    697c:	mov	r0, r5
    697e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (nToWrite >= 2*m_vol->bytesPerSector()) {
    6982:	cmp.w	r7, #1024	; 0x400
    6986:	ldr.w	r2, [lr, #52]	; 0x34
    698a:	ldr.w	r0, [lr, #44]	; 0x2c
    698e:	bcc.n	69ba <FatFile::write(void const*, unsigned int)+0x17a>
      // use multiple sector write command
      uint32_t maxSectors = m_vol->sectorsPerCluster() - sectorOfCluster;
    6990:	ldrb.w	r3, [lr, #4]
    6994:	subs	r6, r3, r6
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
    6996:	lsrs	r3, r7, #9
    6998:	cmp	r3, r6
    699a:	it	cs
    699c:	movcs	r3, r6
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    699e:	cmp	r2, r1
      if (nSector > maxSectors) {
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
    69a0:	mov.w	r6, r3, lsl #9
    69a4:	bcc.n	69ae <FatFile::write(void const*, unsigned int)+0x16e>
    69a6:	add.w	ip, r3, r1
    69aa:	cmp	r2, ip
    69ac:	bcc.n	69da <FatFile::write(void const*, unsigned int)+0x19a>
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    69ae:	ldr	r2, [r0, #0]
    69b0:	ldr.w	r8, [r2, #36]	; 0x24
    69b4:	mov	r2, r9
    69b6:	blx	r8
    69b8:	b.n	68ec <FatFile::write(void const*, unsigned int)+0xac>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    69ba:	cmp	r2, r1
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    69bc:	it	eq
    69be:	strbeq.w	sl, [lr, #40]	; 0x28
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    69c2:	ldr	r3, [r0, #0]
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    69c4:	it	eq
    69c6:	streq.w	fp, [lr, #52]	; 0x34
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    69ca:	ldr	r3, [r3, #32]
    69cc:	mov	r2, r9
    69ce:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    69d0:	cmp	r0, #0
    69d2:	beq.n	696e <FatFile::write(void const*, unsigned int)+0x12e>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
    69d4:	mov.w	r6, #512	; 0x200
    69d8:	b.n	68f0 <FatFile::write(void const*, unsigned int)+0xb0>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    69da:	strb.w	sl, [lr, #40]	; 0x28
    m_sector = 0XFFFFFFFF;
    69de:	str.w	fp, [lr, #52]	; 0x34
    69e2:	b.n	69ae <FatFile::write(void const*, unsigned int)+0x16e>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
    69e4:	ldr.w	lr, [r4, #8]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    69e8:	ldr	r1, [r4, #16]
    69ea:	ldrb.w	r3, [lr, #6]
    69ee:	subs	r1, #2
    69f0:	lsls	r1, r3
    69f2:	ldr.w	r3, [lr, #20]
    69f6:	add	r1, r3
    69f8:	b.n	68a2 <FatFile::write(void const*, unsigned int)+0x62>
    69fa:	nop
    69fc:	.word	0x2001a690

00006a00 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)>:

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat16(uint32_t sector, uint8_t *buf, void *context) {
   struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint16_t *p = (uint16_t *)buf;
  unsigned int n = state->clusters_to_do;
    6a00:	ldr	r3, [r2, #0]
    6a02:	cmp.w	r3, #256	; 0x100
  uint32_t clusters_to_do;
  uint32_t free_count;
};

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat16(uint32_t sector, uint8_t *buf, void *context) {
    6a06:	push	{r4, r5, lr}
    6a08:	mov	r4, r3
    6a0a:	it	cs
    6a0c:	movcs.w	r4, #256	; 0x100
   struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint16_t *p = (uint16_t *)buf;
  unsigned int n = state->clusters_to_do;
  if (n > 256) n = 256;
  uint16_t *e = p + n;
    6a10:	add.w	r5, r1, r4, lsl #1
  while (p < e) {
    6a14:	cmp	r1, r5
    6a16:	bcs.n	6a28 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x28>
    if (*p++ == 0) state->free_count++;
    6a18:	ldrh.w	r0, [r1], #2
    6a1c:	cmp	r0, #0
    6a1e:	bne.n	6a14 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x14>
    6a20:	ldr	r0, [r2, #4]
    6a22:	adds	r0, #1
    6a24:	str	r0, [r2, #4]
    6a26:	b.n	6a14 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x14>
  }
  state->clusters_to_do -= n;
    6a28:	subs	r3, r3, r4
    6a2a:	str	r3, [r2, #0]
    6a2c:	pop	{r4, r5, pc}

00006a2e <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)>:

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat32(uint32_t sector, uint8_t *buf, void *context) {
  struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint32_t *p = (uint32_t *)buf;
  unsigned int n = state->clusters_to_do;
    6a2e:	ldr	r3, [r2, #0]
    6a30:	cmp	r3, #128	; 0x80
  }
  state->clusters_to_do -= n;
}

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat32(uint32_t sector, uint8_t *buf, void *context) {
    6a32:	push	{r4, r5, lr}
    6a34:	mov	r4, r3
    6a36:	it	cs
    6a38:	movcs	r4, #128	; 0x80
  struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint32_t *p = (uint32_t *)buf;
  unsigned int n = state->clusters_to_do;
  if (n > 128) n = 128;
  uint32_t *e = p + n;
    6a3a:	add.w	r5, r1, r4, lsl #2
  while (p < e) {
    6a3e:	cmp	r1, r5
    6a40:	bcs.n	6a52 <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x24>
    if (*p++ == 0) state->free_count++;
    6a42:	ldr.w	r0, [r1], #4
    6a46:	cmp	r0, #0
    6a48:	bne.n	6a3e <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x10>
    6a4a:	ldr	r0, [r2, #4]
    6a4c:	adds	r0, #1
    6a4e:	str	r0, [r2, #4]
    6a50:	b.n	6a3e <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x10>
  }
  state->clusters_to_do -= n;
    6a52:	subs	r3, r3, r4
    6a54:	str	r3, [r2, #0]
    6a56:	pop	{r4, r5, pc}

00006a58 <FsCache::clear()>:
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    6a58:	push	{r4, lr}
    if (isDirty() && !sync()) {
    6a5a:	ldrb	r3, [r0, #0]
    6a5c:	lsls	r3, r3, #31
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    6a5e:	mov	r4, r0
    if (isDirty() && !sync()) {
    6a60:	bpl.n	6a68 <FsCache::clear()+0x10>
    6a62:	bl	381a <FsCache::sync()>
    6a66:	cbz	r0, 6a76 <FsCache::clear()+0x1e>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6a68:	movs	r3, #0
    6a6a:	strb	r3, [r4, #0]
    m_sector = 0XFFFFFFFF;
    6a6c:	mov.w	r3, #4294967295
    6a70:	str	r3, [r4, #12]
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    6a72:	add.w	r0, r4, #16
  }
    6a76:	pop	{r4, pc}

00006a78 <FatPartition::fatGet(unsigned long, unsigned long*)>:
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6a78:	cmp	r1, #1
 fail:
  return false;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry - return -1 error, 0 EOC, else 1.
int8_t FatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    6a7a:	push	{r4, r5, r6, lr}
    6a7c:	mov	r5, r0
    6a7e:	mov	r4, r1
    6a80:	mov	r6, r2
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6a82:	bhi.n	6a8a <FatPartition::fatGet(unsigned long, unsigned long*)+0x12>
  }
  *value = next;
  return 1;

 fail:
  return -1;
    6a84:	mov.w	r0, #4294967295
    6a88:	pop	{r4, r5, r6, pc}
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6a8a:	ldr	r3, [r0, #28]
    6a8c:	cmp	r1, r3
    6a8e:	bhi.n	6a84 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
    6a90:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    6a92:	cmp	r3, #32
    6a94:	bne.n	6ab4 <FatPartition::fatGet(unsigned long, unsigned long*)+0x3c>
  FsCache m_cache;
#if USE_SEPARATE_FAT_CACHE
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
    6a96:	ldr	r1, [r0, #24]
    6a98:	movs	r2, #2
    6a9a:	add.w	r1, r1, r4, lsr #7
    6a9e:	add.w	r0, r0, #568	; 0x238
    6aa2:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    6aa6:	cmp	r0, #0
    6aa8:	beq.n	6a84 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    6aaa:	and.w	r4, r4, #127	; 0x7f
    6aae:	ldr.w	r3, [r0, r4, lsl #2]
    6ab2:	b.n	6ad4 <FatPartition::fatGet(unsigned long, unsigned long*)+0x5c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe32(reinterpret_cast<uint8_t*>
                  (&pc->fat32[cluster & (m_sectorMask >> 2)]));
  } else if (fatType() == 16) {
    6ab4:	cmp	r3, #16
    6ab6:	bne.n	6a84 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
    6ab8:	ldr	r3, [r0, #24]
    6aba:	ubfx	r1, r1, #8, #8
    6abe:	movs	r2, #2
    6ac0:	add	r1, r3
    6ac2:	add.w	r0, r0, #568	; 0x238
    6ac6:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    6aca:	cmp	r0, #0
    6acc:	beq.n	6a84 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    6ace:	uxtb	r4, r4
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe16(reinterpret_cast<uint8_t*>
                  (&pc->fat16[cluster & (m_sectorMask >> 1)]));
    6ad0:	ldrh.w	r3, [r0, r4, lsl #1]
    next = cluster & 1 ? tmp >> 4 : tmp & 0XFFF;
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    6ad4:	ldr	r2, [r5, #28]
    6ad6:	cmp	r3, r2
    return 0;
  }
  *value = next;
  return 1;
    6ad8:	itte	ls
    6ada:	movls	r0, #1
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
  }
  *value = next;
    6adc:	strls	r3, [r6, #0]
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
    6ade:	movhi	r0, #0
  *value = next;
  return 1;

 fail:
  return -1;
}
    6ae0:	pop	{r4, r5, r6, pc}

00006ae2 <FatPartition::fatPut(unsigned long, unsigned long)>:
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6ae2:	cmp	r1, #1
 fail:
  return -1;
}
//------------------------------------------------------------------------------
// Store a FAT entry
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
    6ae4:	push	{r3, r4, r5, lr}
    6ae6:	mov	r4, r1
    6ae8:	mov	r5, r2
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6aea:	bhi.n	6af0 <FatPartition::fatPut(unsigned long, unsigned long)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }

 fail:
  return false;
    6aec:	movs	r0, #0
    6aee:	pop	{r3, r4, r5, pc}
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6af0:	ldr	r3, [r0, #28]
    6af2:	cmp	r1, r3
    6af4:	bhi.n	6aec <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
    6af6:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    6af8:	cmp	r3, #32
    6afa:	bne.n	6b1a <FatPartition::fatPut(unsigned long, unsigned long)+0x38>
    6afc:	ldr	r1, [r0, #24]
    6afe:	movs	r2, #3
    6b00:	add.w	r1, r1, r4, lsr #7
    6b04:	add.w	r0, r0, #568	; 0x238
    6b08:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    6b0c:	cmp	r0, #0
    6b0e:	beq.n	6aec <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    6b10:	and.w	r4, r4, #127	; 0x7f
    6b14:	str.w	r5, [r0, r4, lsl #2]
    6b18:	b.n	6b3a <FatPartition::fatPut(unsigned long, unsigned long)+0x58>
    setLe32(reinterpret_cast<uint8_t*>
           (&pc->fat32[cluster & (m_sectorMask >> 2)]), value);
    return true;
  }

  if (fatType() == 16) {
    6b1a:	cmp	r3, #16
    6b1c:	bne.n	6aec <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
    6b1e:	ldr	r3, [r0, #24]
    6b20:	ubfx	r1, r1, #8, #8
    6b24:	movs	r2, #3
    6b26:	add	r1, r3
    6b28:	add.w	r0, r0, #568	; 0x238
    6b2c:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    6b30:	cmp	r0, #0
    6b32:	beq.n	6aec <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    6b34:	uxtb	r4, r4
    6b36:	strh.w	r5, [r0, r4, lsl #1]
      DBG_FAIL_MACRO;
      goto fail;
    }
    setLe16(reinterpret_cast<uint8_t*>
           (&pc->fat16[cluster & (m_sectorMask >> 1)]), value);
    return true;
    6b3a:	movs	r0, #1
    goto fail;
  }

 fail:
  return false;
}
    6b3c:	pop	{r3, r4, r5, pc}

00006b3e <FatPartition::allocateCluster(unsigned long, unsigned long*)>:
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"
#include "FatPartition.h"

//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    6b3e:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    6b42:	ldr	r4, [r0, #12]
    6b44:	cmp	r4, r1
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"
#include "FatPartition.h"

//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    6b46:	mov	r5, r0
    6b48:	mov	r6, r1
    6b4a:	mov	r8, r2
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    6b4c:	bcs.n	6b5e <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x20>
    6b4e:	mov	r4, r1
    // Try to keep file contiguous. Start just after current cluster.
    find = current;
    setStart = false;
    6b50:	movs	r7, #0
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    if (find > m_lastCluster) {
    6b52:	ldr	r3, [r5, #28]
  } else {
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    6b54:	adds	r4, #1
    if (find > m_lastCluster) {
    6b56:	cmp	r4, r3
    6b58:	bls.n	6b62 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x24>
      if (setStart) {
    6b5a:	cbnz	r7, 6b90 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
        // Can't find space, checked all clusters.
        DBG_FAIL_MACRO;
        goto fail;
      }
      find = m_allocSearchStart;
    6b5c:	ldr	r4, [r5, #12]
      setStart = true;
    6b5e:	movs	r7, #1
    6b60:	b.n	6b52 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
      continue;
    }
    if (find == current) {
    6b62:	cmp	r6, r4
    6b64:	beq.n	6b90 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    6b66:	add	r2, sp, #4
    6b68:	mov	r1, r4
    6b6a:	mov	r0, r5
    6b6c:	bl	6a78 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    6b70:	cmp	r0, #0
    6b72:	blt.n	6b90 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg && f == 0) {
    6b74:	beq.n	6b52 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
    6b76:	ldr	r3, [sp, #4]
    6b78:	cmp	r3, #0
    6b7a:	bne.n	6b52 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
      break;
    }
  }
  if (setStart) {
    6b7c:	cbz	r7, 6b80 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x42>
    m_allocSearchStart = find;
    6b7e:	str	r4, [r5, #12]
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    6b80:	mvn.w	r2, #4026531840	; 0xf0000000
    6b84:	mov	r1, r4
    6b86:	mov	r0, r5
    6b88:	bl	6ae2 <FatPartition::fatPut(unsigned long, unsigned long)>
  }
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    6b8c:	mov	r7, r0
    6b8e:	cbnz	r0, 6b94 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x56>
  updateFreeClusterCount(-1);
  *next = find;
  return true;

 fail:
  return false;
    6b90:	movs	r7, #0
    6b92:	b.n	6bb6 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
    6b94:	cbnz	r6, 6ba2 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x64>
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
  }
  void updateFreeClusterCount(int32_t change) {
    if (m_freeClusterCount >= 0) {
    6b96:	ldr	r3, [r5, #36]	; 0x24
    6b98:	cmp	r3, #0
    6b9a:	blt.n	6bb2 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x74>
      m_freeClusterCount += change;
    6b9c:	subs	r3, #1
    6b9e:	str	r3, [r5, #36]	; 0x24
    6ba0:	b.n	6bb2 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x74>
    // Link clusters.
    if (!fatPut(current, find)) {
    6ba2:	mov	r2, r4
    6ba4:	mov	r1, r6
    6ba6:	mov	r0, r5
    6ba8:	bl	6ae2 <FatPartition::fatPut(unsigned long, unsigned long)>
    6bac:	cmp	r0, #0
    6bae:	bne.n	6b96 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x58>
    6bb0:	b.n	6b90 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  updateFreeClusterCount(-1);
  *next = find;
    6bb2:	str.w	r4, [r8]
  return true;

 fail:
  return false;
}
    6bb6:	mov	r0, r7
    6bb8:	add	sp, #8
    6bba:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00006bbe <FatPartition::freeChain(unsigned long)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
    6bbe:	push	{r0, r1, r4, r5, r6, lr}
    6bc0:	mov	r5, r0
    6bc2:	mov	r4, r1
  uint32_t next;
  int8_t fg;
  do {
    fg = fatGet(cluster, &next);
    6bc4:	add	r2, sp, #4
    6bc6:	mov	r1, r4
    6bc8:	mov	r0, r5
    6bca:	bl	6a78 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    6bce:	subs	r6, r0, #0
    6bd0:	bge.n	6bd6 <FatPartition::freeChain(unsigned long)+0x18>
  } while (fg);

  return true;

 fail:
  return false;
    6bd2:	movs	r0, #0
    6bd4:	b.n	6c00 <FatPartition::freeChain(unsigned long)+0x42>
    if (fg < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
    6bd6:	movs	r2, #0
    6bd8:	mov	r1, r4
    6bda:	mov	r0, r5
    6bdc:	bl	6ae2 <FatPartition::fatPut(unsigned long, unsigned long)>
    6be0:	cmp	r0, #0
    6be2:	beq.n	6bd2 <FatPartition::freeChain(unsigned long)+0x14>
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
  }
  void updateFreeClusterCount(int32_t change) {
    if (m_freeClusterCount >= 0) {
    6be4:	ldr	r3, [r5, #36]	; 0x24
    6be6:	cmp	r3, #0
      m_freeClusterCount += change;
    6be8:	itt	ge
    6bea:	addge	r3, #1
    6bec:	strge	r3, [r5, #36]	; 0x24
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Add one to count of free clusters.
    updateFreeClusterCount(1);
    if (cluster < m_allocSearchStart) {
    6bee:	ldr	r3, [r5, #12]
    6bf0:	cmp	r4, r3
      m_allocSearchStart = cluster - 1;
    6bf2:	itt	cc
    6bf4:	addcc.w	r4, r4, #4294967295
    6bf8:	strcc	r4, [r5, #12]
    }
    cluster = next;
    6bfa:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  int8_t fg;
  do {
    6bfc:	cmp	r6, #0
    6bfe:	bne.n	6bc4 <FatPartition::freeChain(unsigned long)+0x6>

  return true;

 fail:
  return false;
}
    6c00:	add	sp, #8
    6c02:	pop	{r4, r5, r6, pc}

00006c04 <FatPartition::freeClusterCount()>:
  }
  state->clusters_to_do -= n;
}

//------------------------------------------------------------------------------
int32_t FatPartition::freeClusterCount() {
    6c04:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    6c06:	mov	r4, r0
#if MAINTAIN_FREE_CLUSTER_COUNT
  if (m_freeClusterCount >= 0) {
    6c08:	ldr	r0, [r0, #36]	; 0x24
    6c0a:	cmp	r0, #0
    6c0c:	bge.n	6c52 <FatPartition::freeClusterCount()+0x4e>
    return free;
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
    6c0e:	movs	r3, #0
    6c10:	str	r3, [sp, #12]
  state.clusters_to_do = m_lastCluster + 1;
    6c12:	ldr	r3, [r4, #28]
  uint32_t num_sectors;

  //num_sectors = SD.sdfs.m_fVol->sectorsPerFat(); // edit FsVolume.h for public
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
    6c14:	ldr	r5, [r4, #16]
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
  state.clusters_to_do = m_lastCluster + 1;
    6c16:	adds	r3, #1
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
  //Serial.printf("  num_sectors = %u\n", num_sectors);
#if USE_SEPARATE_FAT_CACHE
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
    6c18:	add.w	r0, r4, #568	; 0x238
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
  state.clusters_to_do = m_lastCluster + 1;
    6c1c:	str	r3, [sp, #8]
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
  //Serial.printf("  num_sectors = %u\n", num_sectors);
#if USE_SEPARATE_FAT_CACHE
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
    6c1e:	bl	6a58 <FsCache::clear()>
#else  
  uint8_t *buf = m_cache.clear();  // will clear out anything and return buffer 
#endif  // USE_SEPARATE_FAT_CACHE
  if (buf == nullptr) return -1;
    6c22:	mov	r2, r0
    6c24:	cbnz	r0, 6c2c <FatPartition::freeClusterCount()+0x28>
    6c26:	mov.w	r0, #4294967295
    6c2a:	b.n	6c52 <FatPartition::freeClusterCount()+0x4e>
  if (fatType() == FAT_TYPE_FAT32) {
    6c2c:	ldrb	r3, [r4, #7]
    6c2e:	ldr	r0, [r4, #0]
    6c30:	cmp	r3, #32
    6c32:	add	r3, sp, #8
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat32, &state)) return -1;
    6c34:	ldr	r1, [r0, #0]
    6c36:	str	r3, [sp, #4]
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
#else  
  uint8_t *buf = m_cache.clear();  // will clear out anything and return buffer 
#endif  // USE_SEPARATE_FAT_CACHE
  if (buf == nullptr) return -1;
  if (fatType() == FAT_TYPE_FAT32) {
    6c38:	bne.n	6c3e <FatPartition::freeClusterCount()+0x3a>
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat32, &state)) return -1;
    6c3a:	ldr	r3, [pc, #28]	; (6c58 <FatPartition::freeClusterCount()+0x54>)
    6c3c:	b.n	6c40 <FatPartition::freeClusterCount()+0x3c>
  } else {
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat16, &state)) return -1;
    6c3e:	ldr	r3, [pc, #28]	; (6c5c <FatPartition::freeClusterCount()+0x58>)
    6c40:	str	r3, [sp, #0]
    6c42:	ldr	r6, [r1, #20]
    6c44:	ldr	r1, [r4, #24]
    6c46:	mov	r3, r5
    6c48:	blx	r6
    6c4a:	cmp	r0, #0
    6c4c:	beq.n	6c26 <FatPartition::freeClusterCount()+0x22>
  }

  setFreeClusterCount(state.free_count);
    6c4e:	ldr	r0, [sp, #12]
    return m_blockDev->writeSector(sector, src);
  }
#if MAINTAIN_FREE_CLUSTER_COUNT
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
    6c50:	str	r0, [r4, #36]	; 0x24
  return state.free_count;
}
    6c52:	add	sp, #16
    6c54:	pop	{r4, r5, r6, pc}
    6c56:	nop
    6c58:	.word	0x00006a2f
    6c5c:	.word	0x00006a01

00006c60 <FatPartition::init(BlockDeviceInterface*, unsigned char)>:


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    6c60:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6c64:	mov	r4, r0
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif

  uint8_t tmp;
  m_fatType = 0;
    6c66:	movs	r7, #0
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    6c68:	mov.w	r3, #4294967295
  m_allocSearchStart = 1;
    6c6c:	movs	r6, #1
  }
  /** Clear the cache and returns a pointer to the cache.  Not for normal apps.
   * \return A pointer to the cache buffer or zero if an error occurs.
   */
  uint8_t* cacheClear() {
    return m_cache.clear();
    6c6e:	add.w	r8, r0, #40	; 0x28
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
//  Serial.printf(" FatPartition::init(%x %u)\n", (uint32_t)dev, part);
  uint32_t clusterCount;
  uint32_t totalSectors;
  uint32_t volumeStartSector = 0;
  m_blockDev = dev;
    6c72:	str	r1, [r4, #0]
  return state.free_count;
}


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    6c74:	sub	sp, #28
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif

  uint8_t tmp;
  m_fatType = 0;
    6c76:	strb	r7, [r0, #7]
  m_allocSearchStart = 1;
    6c78:	str	r6, [r0, #12]
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    6c7a:	str	r1, [r4, #44]	; 0x2c
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    6c7c:	str	r3, [r0, #52]	; 0x34
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6c7e:	strb.w	r7, [r0, #40]	; 0x28
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    6c82:	str.w	r1, [r4, #572]	; 0x23c
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    6c86:	str.w	r3, [r0, #580]	; 0x244
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6c8a:	strb.w	r7, [r0, #568]	; 0x238
    6c8e:	mov	r0, r8
  return state.free_count;
}


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    6c90:	mov	r5, r1
    6c92:	mov	r9, r2
    6c94:	bl	6a58 <FsCache::clear()>
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.init(dev);
#endif  // USE_SEPARATE_FAT_CACHE

  #if SUPPORT_GPT_AND_EXTENDED_PATITIONS 
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part, cacheClear(), &firstLBA);
    6c98:	str	r7, [sp, #8]
    6c9a:	mov	r2, r0
    6c9c:	str	r7, [sp, #4]
    6c9e:	str	r7, [sp, #0]
    6ca0:	add	r3, sp, #20
    6ca2:	mov	r1, r9
    6ca4:	mov	r0, r5
    6ca6:	bl	35dc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    6caa:	tst.w	r0, #251	; 0xfb
    6cae:	beq.n	6d34 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    DBG_FAIL_MACRO;
    goto fail;    
  }
  volumeStartSector = firstLBA;
    6cb0:	ldr	r5, [sp, #20]
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    6cb2:	mov	r2, r7
    6cb4:	mov	r1, r5
    6cb6:	mov	r0, r8
    6cb8:	bl	3866 <FsCache::get(unsigned long, unsigned char)>
  #endif

  pbs = reinterpret_cast<pbs_t*>
        (cacheFetchData(volumeStartSector, FsCache::CACHE_FOR_READ));
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    6cbc:	cmp	r0, #0
    6cbe:	beq.n	6d34 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    6cc0:	ldrb	r3, [r0, #16]
    6cc2:	cmp	r3, #2
    6cc4:	bne.n	6d34 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    6cc6:	ldrh.w	r3, [r0, #11]
    6cca:	cmp.w	r3, #512	; 0x200
    6cce:	bne.n	6d34 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    6cd0:	b.n	6d38 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd8>
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    if (tmp == 0) {
    6cd2:	subs	r2, #1
    6cd4:	beq.n	6d34 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
    6cd6:	ldrb	r6, [r4, #6]
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    6cd8:	lsls	r3, r3, #1
    if (tmp == 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
    6cda:	adds	r6, #1
    6cdc:	strb	r6, [r4, #6]
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    6cde:	uxtb	r3, r3
    6ce0:	cmp	r3, r1
    6ce2:	bne.n	6cd2 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
    6ce4:	ldrh	r3, [r0, #22]
    6ce6:	str	r3, [r4, #16]
  if (m_sectorsPerFat == 0) {
    6ce8:	cbnz	r3, 6cee <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x8e>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    6cea:	ldr	r3, [r0, #36]	; 0x24
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
    6cec:	str	r3, [r4, #16]
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    6cee:	ldrh	r1, [r0, #14]
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    6cf0:	ldrh.w	r2, [r0, #17]

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    6cf4:	ldr	r6, [r4, #16]
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);
    6cf6:	strh	r2, [r4, #8]
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    6cf8:	add	r1, r5

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    6cfa:	add.w	r3, r1, r6, lsl #1
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    6cfe:	str	r1, [r4, #24]
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    6d00:	lsls	r1, r2, #5
    6d02:	addw	r1, r1, #511	; 0x1ff
    6d06:	add.w	r1, r3, r1, asr #9

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    6d0a:	str	r3, [r4, #32]
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
    6d0c:	ldrh.w	r3, [r0, #19]

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);
    6d10:	str	r1, [r4, #20]

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
  if (totalSectors == 0) {
    6d12:	cbnz	r3, 6d16 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xb6>
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    6d14:	ldr	r3, [r0, #32]
    totalSectors = getLe32(bpb->totalSectors32);
  }
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);
    6d16:	subs	r1, r5, r1
    6d18:	add	r1, r3

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
    6d1a:	ldrb	r3, [r4, #6]
    6d1c:	lsrs	r1, r3
  m_lastCluster = clusterCount + 1;
    6d1e:	adds	r3, r1, #1
    6d20:	str	r3, [r4, #28]
    return m_blockDev->writeSector(sector, src);
  }
#if MAINTAIN_FREE_CLUSTER_COUNT
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
    6d22:	mov.w	r3, #4294967295
    6d26:	str	r3, [r4, #36]	; 0x24

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    6d28:	movw	r3, #4084	; 0xff4
    6d2c:	cmp	r1, r3
    6d2e:	bhi.n	6d48 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xe8>
    m_fatType = 12;
    6d30:	movs	r3, #12
    6d32:	strb	r3, [r4, #7]
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;

 fail:
  return false;
    6d34:	movs	r0, #0
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    6d36:	b.n	6d62 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x102>
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
    6d38:	ldrb	r1, [r0, #13]
    6d3a:	strb	r1, [r4, #4]
  m_clusterSectorMask = m_sectorsPerCluster - 1;
    6d3c:	subs	r3, r1, #1
    6d3e:	strb	r3, [r4, #5]
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
    6d40:	strb	r7, [r4, #6]
    6d42:	movs	r2, #9
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    6d44:	mov	r3, r6
    6d46:	b.n	6ce0 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x80>
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    6d48:	movw	r3, #65524	; 0xfff4
    6d4c:	cmp	r1, r3
    6d4e:	ittet	hi
    6d50:	ldrhi	r3, [r0, #44]	; 0x2c
    m_fatType = 16;
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    6d52:	strhi	r3, [r4, #32]
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    m_fatType = 16;
    6d54:	movls	r3, #16
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    m_fatType = 32;
    6d56:	movhi	r3, #32
    6d58:	strb	r3, [r4, #7]
  }
  /** Set the offset to the second FAT for mirroring.
   * \param[in] offset Sector offset to second FAT.
   */
  void setMirrorOffset(uint32_t offset) {
    m_mirrorOffset = offset;
    6d5a:	str	r6, [r4, #48]	; 0x30
    6d5c:	str.w	r6, [r4, #576]	; 0x240
  }
  m_cache.setMirrorOffset(m_sectorsPerFat);
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;
    6d60:	movs	r0, #1

 fail:
  return false;
}
    6d62:	add	sp, #28
    6d64:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00006d68 <FatVolume::chdir(char const*)>:
#define DBG_FILE "FatVolume.cpp"
#include "../common/DebugMacros.h"
#include "FatVolume.h"
FatVolume* FatVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FatVolume::chdir(const char *path) {
    6d68:	push	{r4, r5, r6, lr}
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend FatFile;
  static FatVolume* cwv() {return m_cwv;}
  FatFile* vwd() {return &m_vwd;}
    6d6a:	add.w	r4, r0, #1096	; 0x448
    6d6e:	sub	sp, #40	; 0x28
    6d70:	movs	r3, #0
  FatFile dir;
  if (!dir.open(vwd(), path, O_RDONLY)) {
    6d72:	mov	r2, r1
    6d74:	add	r0, sp, #4
    6d76:	mov	r1, r4
    6d78:	strb.w	r3, [sp, #4]
    6d7c:	strb.w	r3, [sp, #5]
    6d80:	strb.w	r3, [sp, #6]
    6d84:	bl	62c4 <FatFile::open(FatFile*, char const*, int)>
    6d88:	mov	r6, r0
    6d8a:	cbz	r0, 6da8 <FatVolume::chdir(char const*)+0x40>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!dir.isDir()) {
    6d8c:	ldrb.w	r3, [sp, #4]
    6d90:	ands.w	r3, r3, #112	; 0x70
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_vwd = dir;
    6d94:	itttt	ne
    6d96:	addne	r5, sp, #4
    6d98:	ldmiane	r5!, {r0, r1, r2, r3}
    6d9a:	stmiane	r4!, {r0, r1, r2, r3}
    6d9c:	ldmiane	r5!, {r0, r1, r2, r3}
    6d9e:	ittte	ne
    6da0:	stmiane	r4!, {r0, r1, r2, r3}
    6da2:	ldrne	r3, [r5, #0]
    6da4:	strne	r3, [r4, #0]
  return true;

 fail:
  return false;
    6da6:	moveq	r6, r3
}
    6da8:	mov	r0, r6
    6daa:	add	sp, #40	; 0x28
    6dac:	pop	{r4, r5, r6, pc}

00006dae <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>:
  }
  DirFat_t* cacheDirEntry(uint8_t action);
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    6dae:	subs	r1, r0, #1
    6db0:	add.w	r2, r0, #10
    uint8_t sum = 0;
    6db4:	movs	r0, #0
    6db6:	lsls	r3, r0, #7
    6db8:	orr.w	r0, r3, r0, lsr #1
    for (uint8_t i = 0; i < 11; i++) {
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    6dbc:	ldrb.w	r3, [r1, #1]!
    6dc0:	uxtab	r0, r3, r0
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    6dc4:	cmp	r1, r2
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    6dc6:	uxtb	r0, r0
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    6dc8:	bne.n	6db6 <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]+0x8>
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    }
    return sum;
  }
    6dca:	bx	lr

00006dcc <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)>:
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6dcc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  FatFile dir = *this;
    6dd0:	mov	r5, r0
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6dd2:	mov	r6, r2
    6dd4:	mov	r7, r0
    6dd6:	mov	r8, r1
    6dd8:	mov	r9, r3
  FatFile dir = *this;
    6dda:	ldmia	r5!, {r0, r1, r2, r3}
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6ddc:	sub	sp, #52	; 0x34
  FatFile dir = *this;
    6dde:	add	r4, sp, #12
    6de0:	stmia	r4!, {r0, r1, r2, r3}
    6de2:	ldmia	r5!, {r0, r1, r2, r3}
    6de4:	stmia	r4!, {r0, r1, r2, r3}
    6de6:	ldr	r3, [r5, #0]
    6de8:	str	r3, [r4, #0]
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
  }
  void reset() {
    next = begin;
    6dea:	ldr	r3, [r6, #0]
    6dec:	str	r3, [r6, #4]
    ls = 0;
    6dee:	movs	r3, #0
    6df0:	strh	r3, [r6, #12]
  DirLfn_t* ldir;
  fname->reset();
  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6df2:	movs	r5, #1
    6df4:	cmp	r5, r9
    6df6:	bhi.n	6e32 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x66>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(index - order));
    6df8:	rsb	r1, r5, r8
    6dfc:	uxth	r1, r1
    6dfe:	add	r0, sp, #12
    6e00:	bl	5ae0 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    6e04:	mov	fp, r0
    6e06:	cbnz	r0, 6e0c <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x40>
    }
  }
  return true;

 fail:
  return false;
    6e08:	movs	r0, #0
    6e0a:	b.n	6e62 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
    6e0c:	mov.w	sl, #0
    }
    // These should be checked in caller.
    DBG_HALT_IF(ldir->attributes != FAT_ATTRIB_LONG_NAME);
    DBG_HALT_IF(order != (ldir->order & 0X1F));
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t u = getLfnChar(ldir, i);
    6e10:	uxtb.w	r2, sl
    6e14:	mov	r1, fp
    6e16:	mov	r0, r7
    6e18:	bl	5afa <FatFile::getLfnChar(DirLfn_t*, unsigned char)>
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    6e1c:	ldrh	r3, [r6, #12]
    6e1e:	mov	r4, r0
    6e20:	cbnz	r3, 6e36 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x6a>
    6e22:	ldr	r2, [r6, #4]
    6e24:	ldr	r3, [r6, #8]
    6e26:	cmp	r2, r3
    6e28:	bne.n	6e36 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x6a>
      if (fname->atEnd()) {
        return u == 0;
    6e2a:	clz	r0, r0
    6e2e:	lsrs	r0, r0, #5
    6e30:	b.n	6e62 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
        return false;
      }
#endif  // USE_UTF8_LONG_NAMES
    }
  }
  return true;
    6e32:	movs	r0, #1
    6e34:	b.n	6e62 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
      uint16_t u = getLfnChar(ldir, i);
      if (fname->atEnd()) {
        return u == 0;
      }
#if USE_UTF8_LONG_NAMES
      uint16_t cp = fname->get16();
    6e36:	mov	r0, r6
    6e38:	bl	3958 <FsName::get16()>
    6e3c:	str	r0, [sp, #4]
      // Make sure caller checked for valid UTF-8.
      DBG_HALT_IF(cp == 0XFFFF);
      if (toUpcase(u) != toUpcase(cp)) {
    6e3e:	mov	r0, r4
    6e40:	bl	38b4 <toUpcase(unsigned short)>
    6e44:	ldr	r3, [sp, #4]
    6e46:	mov	r4, r0
    6e48:	mov	r0, r3
    6e4a:	bl	38b4 <toUpcase(unsigned short)>
    6e4e:	cmp	r4, r0
    6e50:	bne.n	6e08 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x3c>
    6e52:	add.w	sl, sl, #1
      goto fail;
    }
    // These should be checked in caller.
    DBG_HALT_IF(ldir->attributes != FAT_ATTRIB_LONG_NAME);
    DBG_HALT_IF(order != (ldir->order & 0X1F));
    for (uint8_t i = 0; i < 13; i++) {
    6e56:	cmp.w	sl, #13
    6e5a:	bne.n	6e10 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x44>
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
  FatFile dir = *this;
  DirLfn_t* ldir;
  fname->reset();
  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6e5c:	adds	r5, #1
    6e5e:	uxtb	r5, r5
    6e60:	b.n	6df4 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x28>
  }
  return true;

 fail:
  return false;
}
    6e62:	add	sp, #52	; 0x34
    6e64:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00006e68 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)>:
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6e68:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  FatFile dir = *this;
    6e6c:	mov	r5, r0

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6e6e:	mov	r6, r2
    6e70:	mov	sl, r1
    6e72:	mov	r7, r3
  FatFile dir = *this;
    6e74:	ldmia	r5!, {r0, r1, r2, r3}

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6e76:	sub	sp, #52	; 0x34
  FatFile dir = *this;
    6e78:	add	r4, sp, #12
    6e7a:	stmia	r4!, {r0, r1, r2, r3}
    6e7c:	ldmia	r5!, {r0, r1, r2, r3}
    6e7e:	stmia	r4!, {r0, r1, r2, r3}
    6e80:	ldr	r3, [r5, #0]
    6e82:	str	r3, [r4, #0]
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
    6e84:	add.w	r0, r6, #22
    6e88:	bl	6dae <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>
  }
  void reset() {
    next = begin;
    ls = 0;
    6e8c:	movs	r5, #0
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
  }
  void reset() {
    next = begin;
    6e8e:	ldr	r3, [r6, #0]
    6e90:	str	r3, [r6, #4]
    6e92:	mov	r9, r0
    ls = 0;
    6e94:	strh	r5, [r6, #12]
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6e96:	mov.w	fp, #1
      goto fail;
    }
    dir.m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    6e9a:	mov	r8, r5
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6e9c:	cmp	fp, r7
    6e9e:	bhi.n	6eee <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x86>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(index - order));
    6ea0:	rsb	r1, fp, sl
    6ea4:	uxth	r1, r1
    6ea6:	add	r0, sp, #12
    6ea8:	bl	5ae0 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    6eac:	cmp	r0, #0
    6eae:	beq.n	6f36 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xce>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dir.m_vol->cacheDirty();
    6eb0:	ldr	r2, [sp, #20]
    invalidate();
    return m_buffer;
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    6eb2:	ldrb.w	r3, [r2, #40]	; 0x28
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    6eb6:	cmp	fp, r7
    6eb8:	orr.w	r3, r3, #1
    6ebc:	strb.w	r3, [r2, #40]	; 0x28
    6ec0:	ite	eq
    6ec2:	orreq.w	r3, fp, #64	; 0x40
    6ec6:	movne	r3, fp
    6ec8:	strb	r3, [r0, #0]
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    6eca:	mov.w	r3, #15
    6ece:	strb	r3, [r0, #11]
    ldir->mustBeZero1 = 0;
    6ed0:	strb.w	r8, [r0, #12]
    ldir->checksum = checksum;
    6ed4:	strb.w	r9, [r0, #13]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    6ed8:	strh.w	r8, [r0, #26]
    6edc:	adds	r4, r0, #4
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
    6ede:	movs	r1, #0
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    6ee0:	ldrh	r3, [r6, #12]
    6ee2:	cbnz	r3, 6ef2 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x8a>
    6ee4:	ldr	r2, [r6, #4]
    6ee6:	ldr	r3, [r6, #8]
    6ee8:	cmp	r2, r3
    6eea:	bne.n	6ef2 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x8a>
    6eec:	b.n	6f24 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xbc>
        DBG_HALT_IF(cp == 0XFFFF);
      }
      putLfnChar(ldir, i, cp);
    }
  }
  return true;
    6eee:	movs	r0, #1
    6ef0:	b.n	6f36 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xce>
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t cp;
      if (fname->atEnd()) {
        cp = fc++ ? 0XFFFF : 0;
      } else {
        cp = fname->get16();
    6ef2:	mov	r0, r6
    6ef4:	str	r1, [sp, #4]
    6ef6:	bl	3958 <FsName::get16()>
    6efa:	ldr	r1, [sp, #4]
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c The 16-bit character.
 */
static void putLfnChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    6efc:	cmp	r1, #4
    6efe:	bhi.n	6f06 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x9e>
    6f00:	strh.w	r0, [r4, #-3]
    6f04:	b.n	6f0e <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xa6>
    setLe16(ldir->unicode1 + 2*i, c);
  } else if (i < 11) {
    6f06:	cmp	r1, #10
    6f08:	ite	ls
    6f0a:	strhls	r0, [r4, #0]
    6f0c:	strhhi	r0, [r4, #2]
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    ldir->checksum = checksum;
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
    6f0e:	adds	r1, #1
    6f10:	uxtb	r1, r1
    6f12:	cmp	r1, #13
    6f14:	add.w	r4, r4, #2
    6f18:	bne.n	6ee0 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x78>
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6f1a:	add.w	fp, fp, #1
    6f1e:	uxtb.w	fp, fp
    6f22:	b.n	6e9c <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x34>
    ldir->checksum = checksum;
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t cp;
      if (fname->atEnd()) {
        cp = fc++ ? 0XFFFF : 0;
    6f24:	cbz	r5, 6f30 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xc8>
    6f26:	adds	r5, #1
    6f28:	uxtb	r5, r5
    6f2a:	movw	r0, #65535	; 0xffff
    6f2e:	b.n	6efc <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x94>
    6f30:	mov	r0, r5
    6f32:	movs	r5, #1
    6f34:	b.n	6efc <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x94>
  }
  return true;

 fail:
  return false;
}
    6f36:	add	sp, #52	; 0x34
    6f38:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00006f3c <FatFile::makeSFN(FatName_t*)>:
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
  const char* ptr = fname->begin;
    6f3c:	mov	r2, r0

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::makeSFN(FatName_t* fname) {
    6f3e:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
  const char* ptr = fname->begin;
    6f42:	ldr.w	r3, [r2], #21
  uint8_t lc = 0;
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
    6f46:	ldr	r7, [r0, #8]
    6f48:	add.w	r1, r0, #32
  // Assume blanks removed from start and end.
  DBG_HALT_IF(*ptr == ' ' || *(end - 1) == ' ' || *(end - 1) == '.');

  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    fname->sfn[k] = ' ';
    6f4c:	movs	r4, #32
    6f4e:	strb.w	r4, [r2, #1]!
  DBG_HALT_IF(end == ptr);
  // Assume blanks removed from start and end.
  DBG_HALT_IF(*ptr == ' ' || *(end - 1) == ' ' || *(end - 1) == '.');

  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    6f52:	cmp	r1, r2
    6f54:	bne.n	6f4e <FatFile::makeSFN(FatName_t*)+0x12>
    fname->sfn[k] = ' ';
  }
  // Not 8.3 if starts with dot.
  is83 = *ptr == '.' ? false : true;
    6f56:	ldrb	r6, [r3, #0]
    6f58:	subs	r6, #46	; 0x2e
    6f5a:	it	ne
    6f5c:	movne	r6, #1
    6f5e:	mov	r5, r3
    6f60:	adds	r3, #1
  // Skip leading dots.
  for (; *ptr == '.'; ptr++) {}
    6f62:	ldrb	r2, [r5, #0]
    6f64:	cmp	r2, #46	; 0x2e
    6f66:	beq.n	6f5e <FatFile::makeSFN(FatName_t*)+0x22>
    6f68:	subs	r3, r7, #1
  // Find last dot.
  for (dot = end - 1; dot > ptr && *dot != '.'; dot--) {}
    6f6a:	cmp	r3, r5
    6f6c:	mov	lr, r3
    6f6e:	bhi.n	6f80 <FatFile::makeSFN(FatName_t*)+0x44>
    6f70:	movs	r2, #0
    6f72:	mov.w	ip, #7
    6f76:	mov	r1, r2
    6f78:	mov	r8, r2
    6f7a:	mov.w	r9, #8
    6f7e:	b.n	6fa4 <FatFile::makeSFN(FatName_t*)+0x68>
    6f80:	ldrb.w	r2, [lr]
    6f84:	cmp	r2, #46	; 0x2e
    6f86:	add.w	r3, r3, #4294967295
    6f8a:	bne.n	6f6a <FatFile::makeSFN(FatName_t*)+0x2e>
    6f8c:	b.n	6f70 <FatFile::makeSFN(FatName_t*)+0x34>

  for (; ptr < end; ptr++) {
    c = *ptr;
    6f8e:	ldrb	r3, [r5, #0]
//  Could skip UTF-8 units where (0XC0 & c) == 0X80

    if (c == '.' && ptr == dot) {
    6f90:	cmp	r3, #46	; 0x2e
    6f92:	bne.n	6faa <FatFile::makeSFN(FatName_t*)+0x6e>
    6f94:	cmp	lr, r5
    6f96:	bne.n	6fb2 <FatFile::makeSFN(FatName_t*)+0x76>
      in = 10;  // Max index for full 8.3 name.
    6f98:	mov.w	ip, #10
      i = 8;    // Place for extension.
    6f9c:	movs	r1, #8
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    6f9e:	mov.w	r9, #16
  // Skip leading dots.
  for (; *ptr == '.'; ptr++) {}
  // Find last dot.
  for (dot = end - 1; dot > ptr && *dot != '.'; dot--) {}

  for (; ptr < end; ptr++) {
    6fa2:	adds	r5, #1
    6fa4:	cmp	r5, r7
    6fa6:	bcc.n	6f8e <FatFile::makeSFN(FatName_t*)+0x52>
    6fa8:	b.n	7034 <FatFile::makeSFN(FatName_t*)+0xf8>
  /** Check for a legal 8.3 character.
   * \param[in] c Character to be checked.
   * \return true for a legal 8.3 character.
   */
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
    6faa:	cmp	r3, #34	; 0x22
    6fac:	beq.n	6fd6 <FatFile::makeSFN(FatName_t*)+0x9a>
    6fae:	cmp	r3, #124	; 0x7c
    6fb0:	beq.n	6fd6 <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
    6fb2:	sub.w	r4, r3, #42	; 0x2a
    6fb6:	cmp	r4, #5
    6fb8:	bhi.n	6fbe <FatFile::makeSFN(FatName_t*)+0x82>
    6fba:	cmp	r3, #45	; 0x2d
    6fbc:	bne.n	6fd6 <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // :;<=>?
    if (0X3A <= c && c <= 0X3F) {
    6fbe:	sub.w	r4, r3, #58	; 0x3a
    6fc2:	cmp	r4, #5
    6fc4:	bls.n	6fd6 <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // [\]
    if (0X5B <= c && c <= 0X5D) {
    6fc6:	sub.w	r4, r3, #91	; 0x5b
    6fca:	cmp	r4, #2
    6fcc:	bls.n	6fd6 <FatFile::makeSFN(FatName_t*)+0x9a>
    if (c == '.' && ptr == dot) {
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
    6fce:	sub.w	r4, r3, #33	; 0x21
    6fd2:	cmp	r4, #93	; 0x5d
    6fd4:	bls.n	6fe0 <FatFile::makeSFN(FatName_t*)+0xa4>
        is83 = false;
        // Skip UTF-8 trailing characters.
        if ((c & 0XC0) == 0X80) {
    6fd6:	and.w	r3, r3, #192	; 0xc0
    6fda:	cmp	r3, #128	; 0x80
    6fdc:	bne.n	7006 <FatFile::makeSFN(FatName_t*)+0xca>
    6fde:	b.n	702a <FatFile::makeSFN(FatName_t*)+0xee>
          continue;
        }
        c = '_';
      }
      if (i > in) {
    6fe0:	cmp	r1, ip
    6fe2:	bls.n	6ff4 <FatFile::makeSFN(FatName_t*)+0xb8>
        is83 = false;
        if (in == 10 || ptr > dot) {
    6fe4:	cmp.w	ip, #10
    6fe8:	beq.n	7032 <FatFile::makeSFN(FatName_t*)+0xf6>
    6fea:	cmp	lr, r5
    6fec:	bcc.n	7032 <FatFile::makeSFN(FatName_t*)+0xf6>
         // Done - extension longer than three characters or no extension.
          break;
        }
        // Skip to dot.
        ptr = dot - 1;
    6fee:	add.w	r5, lr, #4294967295
    6ff2:	b.n	702a <FatFile::makeSFN(FatName_t*)+0xee>
        continue;
      }
      if (isLower(c)) {
    6ff4:	sub.w	r4, r3, #97	; 0x61
    6ff8:	cmp	r4, #25
    6ffa:	bhi.n	700e <FatFile::makeSFN(FatName_t*)+0xd2>
        c += 'A' - 'a';
    6ffc:	subs	r3, #32
    6ffe:	uxtb	r3, r3
        lc |= bit;
    7000:	orr.w	r2, r9, r2
    7004:	b.n	701a <FatFile::makeSFN(FatName_t*)+0xde>
        if ((c & 0XC0) == 0X80) {
          continue;
        }
        c = '_';
      }
      if (i > in) {
    7006:	cmp	r1, ip
    7008:	bhi.n	6fe4 <FatFile::makeSFN(FatName_t*)+0xa8>
        is83 = false;
        // Skip UTF-8 trailing characters.
        if ((c & 0XC0) == 0X80) {
          continue;
        }
        c = '_';
    700a:	movs	r3, #95	; 0x5f
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
        is83 = false;
    700c:	movs	r6, #0
        continue;
      }
      if (isLower(c)) {
        c += 'A' - 'a';
        lc |= bit;
      } else if (isUpper(c)) {
    700e:	sub.w	r4, r3, #65	; 0x41
    7012:	cmp	r4, #25
        uc |= bit;
    7014:	it	ls
    7016:	orrls.w	r8, r9, r8
      }
      fname->sfn[i++] = c;
    701a:	adds	r4, r1, #1
    701c:	uxtb	r4, r4
    701e:	add	r1, r0
      if (i < 7) {
    7020:	cmp	r4, #6
        c += 'A' - 'a';
        lc |= bit;
      } else if (isUpper(c)) {
        uc |= bit;
      }
      fname->sfn[i++] = c;
    7022:	strb	r3, [r1, #22]
      if (i < 7) {
    7024:	bhi.n	702e <FatFile::makeSFN(FatName_t*)+0xf2>
        fname->seqPos = i;
    7026:	strb	r4, [r0, #20]
    7028:	b.n	702e <FatFile::makeSFN(FatName_t*)+0xf2>
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
        is83 = false;
    702a:	movs	r6, #0
    702c:	b.n	6fa2 <FatFile::makeSFN(FatName_t*)+0x66>
    702e:	mov	r1, r4
    7030:	b.n	6fa2 <FatFile::makeSFN(FatName_t*)+0x66>
          continue;
        }
        c = '_';
      }
      if (i > in) {
        is83 = false;
    7032:	movs	r6, #0
      if (i < 7) {
        fname->seqPos = i;
      }
    }
  }
  if (fname->sfn[0] == ' ') {
    7034:	ldrb	r3, [r0, #22]
    7036:	cmp	r3, #32
    7038:	beq.n	705e <FatFile::makeSFN(FatName_t*)+0x122>
    DBG_HALT_MACRO;
    goto fail;
  }
  if (is83) {
    703a:	cbz	r6, 704c <FatFile::makeSFN(FatName_t*)+0x110>
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
    703c:	tst.w	r8, r2
    7040:	it	ne
    7042:	movne	r2, #2
    7044:	strb	r2, [r0, #21]
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
    7046:	movs	r0, #1
    7048:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  }
  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    704c:	ldrb	r2, [r0, #20]
    goto fail;
  }
  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    704e:	movs	r3, #1
    7050:	strb	r3, [r0, #21]
    fname->sfn[fname->seqPos] = '~';
    7052:	add	r0, r2
    7054:	movs	r2, #126	; 0x7e
    7056:	strb	r2, [r0, #22]
    fname->sfn[fname->seqPos + 1] = '1';
    7058:	movs	r2, #49	; 0x31
    705a:	strb	r2, [r0, #23]
    705c:	b.n	7046 <FatFile::makeSFN(FatName_t*)+0x10a>
  }
  return true;

 fail:
  return false;
    705e:	movs	r0, #0
    7060:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00007064 <FatFile::makeUniqueSfn(FatName_t*)>:
}
//------------------------------------------------------------------------------
bool FatFile::makeUniqueSfn(FatName_t* fname) {
    7064:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;
    7068:	ldrb	r5, [r1, #20]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::makeUniqueSfn(FatName_t* fname) {
    706a:	mov	r7, r0
    706c:	mov	r6, r1
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;
    706e:	movs	r4, #98	; 0x62
    for (uint8_t i = pos + 4 ; i > pos; i--) {
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
      hex >>= 4;
    }
    fname->sfn[pos] = '~';
    7070:	mov.w	r8, #126	; 0x7e
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    7074:	add.w	r9, r1, #22
  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
     DBG_WARN_IF(seq > FIRST_HASH_SEQ);
#ifdef USE_LFN_HASH
    hex = Bernstein(fname->begin, fname->end, seq);
#else
    hex = micros();
    7078:	bl	9514 <micros>
    707c:	cmp	r5, #3
    707e:	it	cs
    7080:	movcs	r5, #3
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    7082:	adds	r3, r5, #4
  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
     DBG_WARN_IF(seq > FIRST_HASH_SEQ);
#ifdef USE_LFN_HASH
    hex = Bernstein(fname->begin, fname->end, seq);
#else
    hex = micros();
    7084:	uxth	r0, r0
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    7086:	uxtb	r3, r3
      uint8_t h = hex & 0XF;
    7088:	and.w	r2, r0, #15
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    708c:	adds	r1, r6, r3
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    708e:	subs	r3, #1
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    7090:	cmp	r2, #9
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    7092:	uxtb	r3, r3
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    7094:	ite	ls
    7096:	addls	r2, #48	; 0x30
    7098:	addhi	r2, #55	; 0x37
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    709a:	cmp	r5, r3
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    709c:	strb	r2, [r1, #22]
      hex >>= 4;
    709e:	mov.w	r0, r0, lsr #4
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    70a2:	bcc.n	7088 <FatFile::makeUniqueSfn(FatName_t*)+0x24>
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
      hex >>= 4;
    }
    fname->sfn[pos] = '~';
    70a4:	adds	r3, r6, r5
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    70a6:	movs	r1, #0
    70a8:	strb.w	r8, [r3, #22]
    70ac:	mov	r0, r7
    70ae:	bl	5fde <FatFile::seekSet(unsigned long)>
    rewind();
    while (1) {
      dir = readDirCache(true);
    70b2:	movs	r1, #1
    70b4:	mov	r0, r7
    70b6:	bl	5fa4 <FatFile::readDirCache(bool)>
      if (!dir) {
    70ba:	mov	r1, r0
    70bc:	cbnz	r0, 70ca <FatFile::makeUniqueSfn(FatName_t*)+0x66>
        if (!getError()) {
    70be:	ldrb	r0, [r7, #1]
    70c0:	clz	r0, r0
    70c4:	lsrs	r0, r0, #5
    70c6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    70ca:	ldrb	r3, [r0, #0]
    70cc:	cbz	r3, 70e2 <FatFile::makeUniqueSfn(FatName_t*)+0x7e>
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    70ce:	ldrb	r3, [r0, #11]
    70d0:	lsls	r3, r3, #28
    70d2:	bmi.n	70b2 <FatFile::makeUniqueSfn(FatName_t*)+0x4e>
    70d4:	movs	r2, #11
    70d6:	mov	r0, r9
    70d8:	bl	b980 <memcmp>
    70dc:	cmp	r0, #0
    70de:	bne.n	70b2 <FatFile::makeUniqueSfn(FatName_t*)+0x4e>
    70e0:	b.n	70e8 <FatFile::makeUniqueSfn(FatName_t*)+0x84>

 fail:
  return false;

 done:
  return true;
    70e2:	movs	r0, #1
    70e4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    70e8:	subs	r0, r4, #1
  uint16_t hex;

  DBG_HALT_IF(!(fname->flags & FNAME_FLAG_LOST_CHARS));
  DBG_HALT_IF(fname->sfn[pos] != '~' && fname->sfn[pos + 1] != '1');

  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
    70ea:	ands.w	r4, r0, #255	; 0xff
    70ee:	bne.n	7078 <FatFile::makeUniqueSfn(FatName_t*)+0x14>
  }
  // fall inti fail - too many tries.
  DBG_FAIL_MACRO;

 fail:
  return false;
    70f0:	mov	r0, r4
    70f2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    70f6:	Address 0x000070f6 is out of bounds.


000070f8 <FatFile::open(FatFile*, FatName_t*, int)>:

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    70f8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    70fc:	sub	sp, #44	; 0x2c
    70fe:	mov	r6, r1
    7100:	str	r3, [sp, #12]
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    7102:	ldrb	r3, [r1, #0]

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    7104:	str	r0, [sp, #24]
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    7106:	tst.w	r3, #112	; 0x70

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    710a:	mov	sl, r2
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    710c:	bne.n	7112 <FatFile::open(FatFile*, FatName_t*, int)+0x1a>
    goto fail;
  }
  return true;

 fail:
  return false;
    710e:	movs	r0, #0
    7110:	b.n	733c <FatFile::open(FatFile*, FatName_t*, int)+0x244>
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    7112:	ldr	r3, [sp, #24]
    7114:	ldrb	r3, [r3, #0]
    7116:	cmp	r3, #0
    7118:	bne.n	710e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
    711a:	ldr	r3, [r2, #16]
    711c:	movs	r2, #13
    711e:	adds	r3, #12
    7120:	udiv	r3, r3, r2
    7124:	uxtb	r3, r3
    7126:	str	r3, [sp, #8]
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
    7128:	ldrb.w	r3, [sl, #21]
    712c:	lsls	r3, r3, #30
    712e:	beq.w	7336 <FatFile::open(FatFile*, FatName_t*, int)+0x23e>
    7132:	ldr	r3, [sp, #8]
    7134:	add.w	fp, r3, #1
    7138:	uxtb.w	fp, fp
    713c:	movs	r1, #0
    713e:	mov	r0, r6
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
  uint8_t ms10;
  uint8_t nameOrd;
  uint16_t freeIndex = 0;
    7140:	mov.w	r9, #0
    7144:	bl	5fde <FatFile::seekSet(unsigned long)>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    7148:	add.w	r3, sl, #22
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
    714c:	str.w	r9, [sp, #16]
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
    7150:	mov	r8, r9
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
    7152:	mov	r4, r9
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
    7154:	mov	r5, r9
 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
    7156:	str.w	r9, [sp, #20]
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    715a:	str	r3, [sp, #28]
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    715c:	ldr	r7, [r6, #20]
    dir = dirFile->readDirCache();
    715e:	movs	r1, #0
    7160:	mov	r0, r6
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    7162:	ubfx	r7, r7, #5, #16
    dir = dirFile->readDirCache();
    7166:	bl	5fa4 <FatFile::readDirCache(bool)>
    if (!dir) {
    716a:	cbnz	r0, 7174 <FatFile::open(FatFile*, FatName_t*, int)+0x7c>
      if (dirFile->getError()) {
    716c:	ldrb	r3, [r6, #1]
    716e:	cmp	r3, #0
    7170:	beq.n	7234 <FatFile::open(FatFile*, FatName_t*, int)+0x13c>
    7172:	b.n	710e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
        goto fail;
      }
      // At EOF
      goto create;
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
    7174:	ldrb	r3, [r0, #0]
    7176:	cmp	r3, #229	; 0xe5
    7178:	beq.n	717c <FatFile::open(FatFile*, FatName_t*, int)+0x84>
    717a:	cbnz	r3, 718e <FatFile::open(FatFile*, FatName_t*, int)+0x96>
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    717c:	cmp	r4, #0
    717e:	it	eq
    7180:	moveq	r9, r7
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
      if (freeFound == 0) {
        freeIndex = curIndex;
      }
      if (freeFound < freeNeed) {
    7182:	cmp	r4, fp
        freeFound++;
    7184:	itt	cc
    7186:	addcc	r4, #1
    7188:	uxtbcc	r4, r4
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    718a:	cbnz	r3, 7196 <FatFile::open(FatFile*, FatName_t*, int)+0x9e>
    718c:	b.n	7234 <FatFile::open(FatFile*, FatName_t*, int)+0x13c>
        goto create;
      }
    } else {
      if (freeFound < freeNeed) {
        freeFound = 0;
    718e:	cmp	r4, fp
    7190:	it	cc
    7192:	movcc	r4, #0
    7194:	b.n	719e <FatFile::open(FatFile*, FatName_t*, int)+0xa6>
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    7196:	cmp	r3, #229	; 0xe5
    7198:	bne.n	719e <FatFile::open(FatFile*, FatName_t*, int)+0xa6>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    719a:	movs	r5, #0
    719c:	b.n	715c <FatFile::open(FatFile*, FatName_t*, int)+0x64>
      if (freeFound < freeNeed) {
        freeFound = 0;
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    719e:	cmp	r3, #46	; 0x2e
    71a0:	beq.n	719a <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
    71a2:	ldrb	r2, [r0, #11]
      lfnOrd = 0;
    } else if (isLongName(dir)) {
    71a4:	cmp	r2, #15
    71a6:	bne.n	71f8 <FatFile::open(FatFile*, FatName_t*, int)+0x100>
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
    71a8:	cbnz	r5, 71c8 <FatFile::open(FatFile*, FatName_t*, int)+0xd0>
        order = ldir->order & 0X1F;
        if (order != nameOrd ||
    71aa:	ldr	r2, [sp, #8]
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
      lfnOrd = 0;
    } else if (isLongName(dir)) {
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
        order = ldir->order & 0X1F;
    71ac:	and.w	r8, r3, #31
        if (order != nameOrd ||
    71b0:	cmp	r2, r8
    71b2:	bne.n	715c <FatFile::open(FatFile*, FatName_t*, int)+0x64>
    71b4:	lsls	r1, r3, #25
    71b6:	bmi.n	71be <FatFile::open(FatFile*, FatName_t*, int)+0xc6>
    71b8:	ldr.w	r8, [sp, #8]
    71bc:	b.n	715c <FatFile::open(FatFile*, FatName_t*, int)+0x64>
          (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = nameOrd;
        checksum = ldir->checksum;
    71be:	ldrb	r3, [r0, #13]
    71c0:	str	r3, [sp, #16]
    71c2:	mov	r8, r2
    71c4:	mov	r5, r2
    71c6:	b.n	71dc <FatFile::open(FatFile*, FatName_t*, int)+0xe4>
      } else if (ldir->order != --order || checksum != ldir->checksum) {
    71c8:	add.w	r8, r8, #4294967295
    71cc:	uxtb.w	r8, r8
    71d0:	cmp	r3, r8
    71d2:	bne.n	719a <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
    71d4:	ldrb	r3, [r0, #13]
    71d6:	ldr	r2, [sp, #16]
    71d8:	cmp	r2, r3
    71da:	bne.n	719a <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
        lfnOrd = 0;
        continue;
      }
      if (order == 1) {
    71dc:	cmp.w	r8, #1
    71e0:	bne.n	715c <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        if (!dirFile->cmpName(curIndex + 1, fname, lfnOrd)) {
    71e2:	adds	r1, r7, #1
    71e4:	mov	r3, r5
    71e6:	mov	r2, sl
    71e8:	uxth	r1, r1
    71ea:	mov	r0, r6
    71ec:	bl	6dcc <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)>
          lfnOrd = 0;
    71f0:	cmp	r0, #0
    71f2:	it	eq
    71f4:	moveq	r5, #0
    71f6:	b.n	715c <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        }
      }
    } else if (isFileOrSubdir(dir)) {
    71f8:	lsls	r3, r2, #28
    71fa:	bmi.n	719a <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
      if (lfnOrd) {
    71fc:	cbz	r5, 7212 <FatFile::open(FatFile*, FatName_t*, int)+0x11a>
        if (1 == order && lfnChecksum(dir->name) == checksum) {
    71fe:	cmp.w	r8, #1
    7202:	bne.n	710e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    7204:	bl	6dae <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>
    7208:	ldr	r3, [sp, #16]
    720a:	cmp	r3, r0
    720c:	bne.w	710e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    7210:	b.n	722c <FatFile::open(FatFile*, FatName_t*, int)+0x134>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    7212:	movs	r2, #11
    7214:	ldr	r1, [sp, #28]
    7216:	bl	b980 <memcmp>
    721a:	cmp	r0, #0
    721c:	bne.n	715c <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        if (!(fname->flags & FNAME_FLAG_LOST_CHARS)) {
    721e:	ldrb.w	r3, [sl, #21]
    7222:	lsls	r0, r3, #31
    7224:	bpl.n	722c <FatFile::open(FatFile*, FatName_t*, int)+0x134>
          goto found;
        }
        fnameFound = true;
    7226:	movs	r3, #1
    7228:	str	r3, [sp, #20]
    722a:	b.n	715c <FatFile::open(FatFile*, FatName_t*, int)+0x64>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    722c:	ldr	r3, [sp, #12]
    722e:	lsls	r1, r3, #20
    7230:	bpl.n	7326 <FatFile::open(FatFile*, FatName_t*, int)+0x22e>
    7232:	b.n	710e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
  }
  goto open;

 create:
  // don't create unless O_CREAT and write mode
  if (!(oflag & O_CREAT) || !isWriteMode(oflag)) {
    7234:	ldr	r3, [sp, #12]
    7236:	lsls	r2, r3, #22
    7238:	bpl.w	710e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    723c:	and.w	r3, r3, #3
    7240:	subs	r3, #1
    7242:	cmp	r3, #1
    7244:	bhi.w	710e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_WARN_MACRO;
    goto fail;
  }
  // Keep found entries or start at current index if no free entries found.
  if (freeFound == 0) {
    7248:	cmp	r4, #0
    724a:	it	eq
    724c:	moveq	r9, r7
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    724e:	cmp	r4, fp
    7250:	bcc.n	7258 <FatFile::open(FatFile*, FatName_t*, int)+0x160>
      DBG_FAIL_MACRO;
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
  }
  if (fnameFound) {
    7252:	ldr	r3, [sp, #20]
    7254:	cbnz	r3, 7286 <FatFile::open(FatFile*, FatName_t*, int)+0x18e>
    7256:	b.n	7294 <FatFile::open(FatFile*, FatName_t*, int)+0x19c>
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    dir = dirFile->readDirCache();
    7258:	movs	r1, #0
    725a:	mov	r0, r6
    725c:	bl	5fa4 <FatFile::readDirCache(bool)>
    if (!dir) {
    7260:	cbnz	r0, 7268 <FatFile::open(FatFile*, FatName_t*, int)+0x170>
      if (dirFile->getError()) {
    7262:	ldrb	r3, [r6, #1]
    7264:	cbz	r3, 727a <FatFile::open(FatFile*, FatName_t*, int)+0x182>
    7266:	b.n	710e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
        goto fail;
      }
      // EOF if no error.
      break;
    }
    freeFound++;
    7268:	adds	r4, #1
    726a:	uxtb	r4, r4
  // Keep found entries or start at current index if no free entries found.
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    726c:	b.n	724e <FatFile::open(FatFile*, FatName_t*, int)+0x156>
    726e:	ldr	r3, [r6, #8]
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
    7270:	ldrb	r3, [r3, #4]
    7272:	add	r4, r3
    7274:	uxtb	r4, r4
      // EOF if no error.
      break;
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
    7276:	cmp	fp, r4
    7278:	bls.n	7252 <FatFile::open(FatFile*, FatName_t*, int)+0x15a>
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
    727a:	mov	r0, r6
    727c:	bl	5cfc <FatFile::addDirCluster()>
    7280:	cmp	r0, #0
    7282:	bne.n	726e <FatFile::open(FatFile*, FatName_t*, int)+0x176>
    7284:	b.n	710e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
  }
  if (fnameFound) {
    if (!dirFile->makeUniqueSfn(fname)) {
    7286:	mov	r1, sl
    7288:	mov	r0, r6
    728a:	bl	7064 <FatFile::makeUniqueSfn(FatName_t*)>
    728e:	cmp	r0, #0
    7290:	beq.w	710e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
      goto fail;
    }
  }
  lfnOrd = freeNeed - 1;
    7294:	add.w	r5, fp, #4294967295
    7298:	uxtb	r5, r5
  curIndex = freeIndex + lfnOrd;
    729a:	add.w	r7, r9, r5
    729e:	uxth	r7, r7
  if (!dirFile->createLFN(curIndex, fname, lfnOrd)) {
    72a0:	mov	r3, r5
    72a2:	mov	r2, sl
    72a4:	mov	r1, r7
    72a6:	mov	r0, r6
    72a8:	bl	6e68 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)>
    72ac:	cmp	r0, #0
    72ae:	beq.w	710e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    goto fail;
  }
  dir = dirFile->cacheDir(curIndex);
    72b2:	mov	r1, r7
    72b4:	mov	r0, r6
    72b6:	bl	5ae0 <FatFile::cacheDir(unsigned short)>
  if (!dir) {
    72ba:	mov	r4, r0
    72bc:	cmp	r0, #0
    72be:	beq.w	710e <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
    72c2:	movs	r2, #32
    72c4:	movs	r1, #0
    72c6:	bl	90bc <memset>
  memcpy(dir->name, fname->sfn, 11);
    72ca:	mov	r3, sl
    72cc:	ldr.w	r2, [r3, #22]!
    72d0:	str	r2, [r4, #0]
    72d2:	ldr	r2, [r3, #4]
    72d4:	str	r2, [r4, #4]
    72d6:	ldrh	r2, [r3, #8]
    72d8:	strh	r2, [r4, #8]
    72da:	ldrb	r3, [r3, #10]
    72dc:	strb	r3, [r4, #10]

  // Set base-name and extension lower case bits.
  dir->caseFlags = (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;
    72de:	ldrb.w	r3, [sl, #21]
    72e2:	and.w	r3, r3, #24
    72e6:	strb	r3, [r4, #12]

  // Set timestamps.
  if (FsDateTime::callback) {
    72e8:	ldr	r3, [pc, #88]	; (7344 <FatFile::open(FatFile*, FatName_t*, int)+0x24c>)
    72ea:	ldr	r3, [r3, #0]
    72ec:	cbz	r3, 730e <FatFile::open(FatFile*, FatName_t*, int)+0x216>
    // call user date/time function
    FsDateTime::callback(&date, &time, &ms10);
    72ee:	add.w	r2, sp, #35	; 0x23
    72f2:	add.w	r1, sp, #38	; 0x26
    72f6:	add	r0, sp, #36	; 0x24
    72f8:	blx	r3
    72fa:	ldrh.w	r3, [sp, #36]	; 0x24
    72fe:	strh	r3, [r4, #16]
    7300:	ldrh.w	r3, [sp, #38]	; 0x26
    7304:	strh	r3, [r4, #14]
    setLe16(dir->createDate, date);
    setLe16(dir->createTime, time);
    dir->createTimeMs = ms10;
    7306:	ldrb.w	r3, [sp, #35]	; 0x23
    730a:	strb	r3, [r4, #13]
    730c:	b.n	7318 <FatFile::open(FatFile*, FatName_t*, int)+0x220>
    730e:	movw	r3, #21537	; 0x5421
    7312:	strh	r3, [r4, #16]
    7314:	strh	r3, [r4, #24]
    7316:	strh	r3, [r4, #18]
      setLe16(dir->createTime, FS_DEFAULT_TIME);
      setLe16(dir->modifyTime, FS_DEFAULT_TIME);
    }
  }
  // Force write of entry to device.
  dirFile->m_vol->cacheDirty();
    7318:	ldr	r2, [r6, #8]
    731a:	ldrb.w	r3, [r2, #40]	; 0x28
    731e:	orr.w	r3, r3, #1
    7322:	strb.w	r3, [r2, #40]	; 0x28

 open:
  // open entry in cache.
  if (!openCachedEntry(dirFile, curIndex, oflag, lfnOrd)) {
    7326:	str	r5, [sp, #0]
    7328:	ldr	r3, [sp, #12]
    732a:	ldr	r0, [sp, #24]
    732c:	mov	r2, r7
    732e:	mov	r1, r6
    7330:	bl	608a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    7334:	b.n	733c <FatFile::open(FatFile*, FatName_t*, int)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
    7336:	mov.w	fp, #1
    733a:	b.n	713c <FatFile::open(FatFile*, FatName_t*, int)+0x44>
  }
  return true;

 fail:
  return false;
}
    733c:	add	sp, #44	; 0x2c
    733e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7342:	nop
    7344:	.word	0x2001a690

00007348 <FatFile::parsePathName(char const*, FatName_t*, char const**)>:
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            FatName_t* fname, const char** ptr) {
    7348:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    734a:	mov	r4, r2
    734c:	mov	r6, r3
    734e:	mov	r0, r1
    7350:	adds	r1, #1
  size_t len = 0;
  // Skip leading spaces.
  while (*path == ' ') {
    7352:	ldrb	r3, [r0, #0]
    7354:	cmp	r3, #32
    7356:	beq.n	734e <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    7358:	ldr	r7, [pc, #128]	; (73dc <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x94>)
    path++;
  }
  fname->begin = path;
    735a:	str	r0, [r4, #0]
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            FatName_t* fname, const char** ptr) {
  size_t len = 0;
    735c:	movs	r5, #0
  // Skip leading spaces.
  while (*path == ' ') {
    path++;
  }
  fname->begin = path;
  while (*path && !isDirSeparator(*path)) {
    735e:	ldrb	r3, [r0, #0]
    7360:	cbz	r3, 73b4 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6c>
    7362:	cmp	r3, #47	; 0x2f
    7364:	beq.n	73b4 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6c>
#if USE_UTF8_LONG_NAMES
    uint32_t cp;
    // Allow end = path + 4 since path is zero terminated.
    path = FsUtf::mbToCp(path, path + 4, &cp);
    7366:	add	r2, sp, #4
    7368:	adds	r1, r0, #4
    736a:	bl	3558 <FsUtf::mbToCp(char const*, char const*, unsigned long*)>
    if (!path) {
    736e:	cbz	r0, 73d4 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    len += cp <= 0XFFFF ? 1 : 2;
    7370:	ldr	r2, [sp, #4]
    7372:	cmp.w	r2, #65536	; 0x10000
    7376:	ite	cs
    7378:	movcs	r3, #2
    737a:	movcc	r3, #1
    if (cp < 0X80 && lfnReservedChar(cp)) {
    737c:	cmp	r2, #127	; 0x7f
    path = FsUtf::mbToCp(path, path + 4, &cp);
    if (!path) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    len += cp <= 0XFFFF ? 1 : 2;
    737e:	add	r5, r3
    if (cp < 0X80 && lfnReservedChar(cp)) {
    7380:	bhi.n	73aa <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x62>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    7382:	cmp	r2, #31
    7384:	bls.n	73d4 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    7386:	uxtb	r3, r2
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    7388:	sub.w	r1, r3, #34	; 0x22
    738c:	uxtb	r1, r1
    738e:	cmp	r1, #29
    7390:	bhi.n	739a <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x52>
    7392:	lsr.w	r1, r7, r1
    7396:	lsls	r1, r1, #31
    7398:	bmi.n	73d4 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    739a:	and.w	r3, r3, #191	; 0xbf
    739e:	cmp	r3, #60	; 0x3c
    73a0:	beq.n	73d4 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    73a2:	cmp	r2, #92	; 0x5c
    73a4:	beq.n	73d4 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    len++;
#endif  // USE_UTF8_LONG_NAMES
    if (cp != '.' && cp != ' ') {
    73a6:	cmp	r2, #46	; 0x2e
    73a8:	beq.n	735e <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
    73aa:	cmp	r2, #32
    73ac:	beq.n	735e <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
      // Need to trim trailing dots spaces.
      fname->len = len;
    73ae:	str	r5, [r4, #16]
      fname->end = path;
    73b0:	str	r0, [r4, #8]
  // Skip leading spaces.
  while (*path == ' ') {
    path++;
  }
  fname->begin = path;
  while (*path && !isDirSeparator(*path)) {
    73b2:	b.n	735e <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
      // Need to trim trailing dots spaces.
      fname->len = len;
      fname->end = path;
    }
  }
  if (!fname->len || fname->len > FAT_MAX_LFN_LENGTH) {
    73b4:	ldr	r3, [r4, #16]
    73b6:	subs	r3, #1
    73b8:	cmp	r3, #254	; 0xfe
    73ba:	bhi.n	73d4 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    73bc:	mov	r2, r0
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
    73be:	ldrb.w	r3, [r0], #1
    73c2:	cmp	r3, #32
    73c4:	beq.n	73bc <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x74>
    73c6:	cmp	r3, #47	; 0x2f
    73c8:	beq.n	73bc <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x74>
  *ptr = path;
    73ca:	str	r2, [r6, #0]
  return makeSFN(fname);
    73cc:	mov	r0, r4
    73ce:	bl	6f3c <FatFile::makeSFN(FatName_t*)>
    73d2:	b.n	73d6 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8e>

 fail:
  return false;
    73d4:	movs	r0, #0
}
    73d6:	add	sp, #12
    73d8:	pop	{r4, r5, r6, r7, pc}
    73da:	nop
    73dc:	.word	0x31002101

000073e0 <FatFile::remove()>:
//------------------------------------------------------------------------------
bool FatFile::remove() {
    73e0:	push	{r4, r5, r6, r7, lr}
    73e2:	sub	sp, #44	; 0x2c
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    73e4:	movs	r3, #0
    73e6:	strb.w	r3, [sp, #4]
    73ea:	strb.w	r3, [sp, #5]
    73ee:	strb.w	r3, [sp, #6]
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    73f2:	ldrb	r3, [r0, #2]
    73f4:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::remove() {
    73f6:	mov	r4, r0
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    73f8:	bpl.n	742a <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
    73fa:	ldr	r1, [r0, #32]
    73fc:	cbz	r1, 7406 <FatFile::remove()+0x26>
    73fe:	ldr	r0, [r0, #8]
    7400:	bl	6bbe <FatPartition::freeChain(unsigned long)>
    7404:	cbz	r0, 742a <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Cache directory entry.
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    7406:	movs	r1, #1
    7408:	mov	r0, r4
    740a:	bl	5d88 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    740e:	mov	r5, r0
    7410:	cbz	r0, 742a <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  checksum = lfnChecksum(dir->name);
    7412:	bl	6dae <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;
    7416:	movs	r6, #229	; 0xe5
    7418:	strb	r6, [r5, #0]

  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    741a:	movs	r3, #0
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  checksum = lfnChecksum(dir->name);
    741c:	mov	r7, r0

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;

  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    741e:	strb	r3, [r4, #0]
  m_flags = 0;
    7420:	strb	r3, [r4, #2]

  // Write entry to device.
  if (!m_vol->cacheSync()) {
    7422:	ldr	r0, [r4, #8]
    7424:	bl	5ca0 <FatPartition::cacheSync()>
    7428:	cbnz	r0, 742e <FatFile::remove()+0x4e>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  return false;
    742a:	movs	r0, #0
    742c:	b.n	748e <FatFile::remove()+0xae>
  // Write entry to device.
  if (!m_vol->cacheSync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    742e:	ldrb	r3, [r4, #3]
    7430:	cbz	r3, 748e <FatFile::remove()+0xae>
    // Done, no LFN entries.
    return true;
  }
  if (!dirFile.openCluster(this)) {
    7432:	mov	r1, r4
    7434:	add	r0, sp, #4
    7436:	bl	5dd6 <FatFile::openCluster(FatFile*)>
    743a:	cmp	r0, #0
    743c:	beq.n	742a <FatFile::remove()+0x4a>
    743e:	movs	r5, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    7440:	ldrb	r3, [r4, #3]
    7442:	cmp	r3, r5
    7444:	bcc.n	742a <FatFile::remove()+0x4a>
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.cacheDir(m_dirIndex - order));
    7446:	ldrh	r1, [r4, #4]
    7448:	subs	r1, r1, r5
    744a:	uxth	r1, r1
    744c:	add	r0, sp, #4
    744e:	bl	5ae0 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    7452:	cmp	r0, #0
    7454:	beq.n	742a <FatFile::remove()+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    7456:	ldrb	r3, [r0, #11]
    7458:	cmp	r3, #15
    745a:	bne.n	742a <FatFile::remove()+0x4a>
        order != (ldir->order & 0X1F) ||
    745c:	ldrb	r2, [r0, #0]
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.cacheDir(m_dirIndex - order));
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    745e:	and.w	r3, r2, #31
    7462:	cmp	r5, r3
    7464:	bne.n	742a <FatFile::remove()+0x4a>
        order != (ldir->order & 0X1F) ||
    7466:	ldrb	r3, [r0, #13]
    7468:	cmp	r3, r7
    746a:	bne.n	742a <FatFile::remove()+0x4a>
        checksum != ldir->checksum) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    last = ldir->order & FAT_ORDER_LAST_LONG_ENTRY;
    ldir->order = FAT_NAME_DELETED;
    746c:	strb	r6, [r0, #0]
    m_vol->cacheDirty();
    746e:	ldr	r1, [r4, #8]
    7470:	ldrb.w	r3, [r1, #40]	; 0x28
    7474:	orr.w	r3, r3, #1
    7478:	strb.w	r3, [r1, #40]	; 0x28
    if (last) {
    747c:	lsls	r3, r2, #25
    747e:	bpl.n	7488 <FatFile::remove()+0xa8>
      if (!m_vol->cacheSync()) {
    7480:	ldr	r0, [r4, #8]
    7482:	bl	5ca0 <FatPartition::cacheSync()>
    7486:	b.n	748e <FatFile::remove()+0xae>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    7488:	adds	r5, #1
    748a:	uxtb	r5, r5
    748c:	b.n	7440 <FatFile::remove()+0x60>
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  return false;
}
    748e:	add	sp, #44	; 0x2c
    7490:	pop	{r4, r5, r6, r7, pc}

00007492 <FsBaseFile::FsBaseFile(FsBaseFile const&)>:
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    7492:	push	{r3, r4, r5, r6, r7, lr}
    7494:	movs	r4, #0
    7496:	str	r4, [r0, #56]	; 0x38
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    7498:	ldr	r7, [r1, #56]	; 0x38
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    749a:	str	r4, [r0, #60]	; 0x3c
    749c:	mov	r6, r0
    749e:	mov	r5, r1
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    74a0:	cbz	r7, 74c4 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x32>
    m_fFile = new (m_fileMem) FatFile;
    74a2:	mov	r1, r0
    74a4:	movs	r0, #36	; 0x24
    74a6:	bl	76dc <operator new(unsigned int, unsigned long*)>
    74aa:	strb	r4, [r0, #0]
    74ac:	strb	r4, [r0, #1]
    74ae:	strb	r4, [r0, #2]
    74b0:	str	r0, [r6, #56]	; 0x38
    *m_fFile = *from.m_fFile;
    74b2:	ldr	r5, [r5, #56]	; 0x38
    74b4:	mov	r4, r0
    74b6:	ldmia	r5!, {r0, r1, r2, r3}
    74b8:	stmia	r4!, {r0, r1, r2, r3}
    74ba:	ldmia	r5!, {r0, r1, r2, r3}
    74bc:	stmia	r4!, {r0, r1, r2, r3}
    74be:	ldr	r3, [r5, #0]
    74c0:	str	r3, [r4, #0]
    74c2:	b.n	74f0 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x5e>
  } else if (from.m_xFile) {
    74c4:	ldr	r3, [r1, #60]	; 0x3c
    74c6:	cbz	r3, 74f0 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x5e>
    m_xFile = new (m_fileMem) ExFatFile;
    74c8:	mov	r1, r0
    74ca:	movs	r0, #56	; 0x38
    74cc:	bl	76dc <operator new(unsigned int, unsigned long*)>
    74d0:	strb.w	r7, [r0, #49]	; 0x31
    74d4:	strb.w	r7, [r0, #50]	; 0x32
    74d8:	strb.w	r7, [r0, #51]	; 0x33
    74dc:	str	r0, [r6, #60]	; 0x3c
    *m_xFile = *from.m_xFile;
    74de:	ldr	r3, [r5, #60]	; 0x3c
    74e0:	add.w	r2, r3, #52	; 0x34
    74e4:	ldr.w	r1, [r3], #4
    74e8:	str.w	r1, [r0], #4
    74ec:	cmp	r3, r2
    74ee:	bne.n	74e4 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x52>
  }
}
    74f0:	mov	r0, r6
    74f2:	pop	{r3, r4, r5, r6, r7, pc}

000074f4 <FsBaseFile::close()>:
    *m_xFile = *from.m_xFile;
  }
  return *this;
}
//------------------------------------------------------------------------------
bool FsBaseFile::close() {
    74f4:	push	{r4, lr}
    74f6:	mov	r4, r0
  if (m_fFile && m_fFile->close()) {
    74f8:	ldr	r0, [r0, #56]	; 0x38
    74fa:	cbz	r0, 7502 <FsBaseFile::close()+0xe>
    74fc:	bl	62b4 <FatFile::close()>
    7500:	cbnz	r0, 7512 <FsBaseFile::close()+0x1e>
    m_fFile = nullptr;
    return true;
  }
  if (m_xFile && m_xFile->close()) {
    7502:	ldr	r0, [r4, #60]	; 0x3c
    7504:	cbz	r0, 7518 <FsBaseFile::close()+0x24>
    7506:	bl	40a6 <ExFatFile::close()>
    750a:	cbz	r0, 7518 <FsBaseFile::close()+0x24>
    m_xFile = nullptr;
    750c:	movs	r3, #0
    750e:	str	r3, [r4, #60]	; 0x3c
    7510:	pop	{r4, pc}
  return *this;
}
//------------------------------------------------------------------------------
bool FsBaseFile::close() {
  if (m_fFile && m_fFile->close()) {
    m_fFile = nullptr;
    7512:	movs	r3, #0
    7514:	str	r3, [r4, #56]	; 0x38
    return true;
    7516:	pop	{r4, pc}
  }
  if (m_xFile && m_xFile->close()) {
    m_xFile = nullptr;
    return true;
  }
  return false;
    7518:	movs	r0, #0
}
    751a:	pop	{r4, pc}

0000751c <FsBaseFile::open(FsVolume*, char const*, int)>:
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
    751c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7520:	mov	r4, r0
    7522:	mov	r7, r2
    7524:	mov	r8, r3
  if (!vol) {
    7526:	mov	r5, r1
    7528:	cbnz	r1, 7530 <FsBaseFile::open(FsVolume*, char const*, int)+0x14>
    return false;
    752a:	movs	r0, #0
    752c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  close();
    7530:	bl	74f4 <FsBaseFile::close()>
  if (vol->m_fVol) {
    7534:	ldr.w	r6, [r5, #1152]	; 0x480
    7538:	cbz	r6, 7560 <FsBaseFile::open(FsVolume*, char const*, int)+0x44>
    m_fFile = new (m_fileMem) FatFile;
    753a:	mov	r1, r4
    753c:	movs	r0, #36	; 0x24
    753e:	bl	76dc <operator new(unsigned int, unsigned long*)>
    7542:	movs	r2, #0
    7544:	strb	r2, [r0, #0]
    7546:	strb	r2, [r0, #1]
    7548:	strb	r2, [r0, #2]
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    754a:	mov	r3, r8
  if (!vol) {
    return false;
  }
  close();
  if (vol->m_fVol) {
    m_fFile = new (m_fileMem) FatFile;
    754c:	str	r0, [r4, #56]	; 0x38
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    754e:	mov	r2, r7
    7550:	ldr.w	r1, [r5, #1152]	; 0x480
    7554:	bl	636c <FatFile::open(FatVolume*, char const*, int)>
    7558:	cbz	r0, 7594 <FsBaseFile::open(FsVolume*, char const*, int)+0x78>
      return true;
    755a:	movs	r0, #1
    755c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    m_fFile = nullptr;
  } else if (vol->m_xVol) {
    7560:	ldr.w	r3, [r5, #1156]	; 0x484
    7564:	cmp	r3, #0
    7566:	beq.n	752a <FsBaseFile::open(FsVolume*, char const*, int)+0xe>
    m_xFile = new (m_fileMem) ExFatFile;
    7568:	mov	r1, r4
    756a:	movs	r0, #56	; 0x38
    756c:	bl	76dc <operator new(unsigned int, unsigned long*)>
    7570:	strb.w	r6, [r0, #49]	; 0x31
    7574:	strb.w	r6, [r0, #50]	; 0x32
    7578:	strb.w	r6, [r0, #51]	; 0x33
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    757c:	mov	r3, r8
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
      return true;
    }
    m_fFile = nullptr;
  } else if (vol->m_xVol) {
    m_xFile = new (m_fileMem) ExFatFile;
    757e:	str	r0, [r4, #60]	; 0x3c
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    7580:	mov	r2, r7
    7582:	ldr.w	r1, [r5, #1156]	; 0x484
    7586:	bl	4826 <ExFatFile::open(ExFatVolume*, char const*, int)>
    758a:	cmp	r0, #0
    758c:	bne.n	755a <FsBaseFile::open(FsVolume*, char const*, int)+0x3e>
      return true;
    }
    m_xFile = nullptr;
    758e:	str	r0, [r4, #60]	; 0x3c
  }
  return false;
}
    7590:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (vol->m_fVol) {
    m_fFile = new (m_fileMem) FatFile;
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
      return true;
    }
    m_fFile = nullptr;
    7594:	str	r0, [r4, #56]	; 0x38
    7596:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000759a <FsBaseFile::openNext(FsBaseFile*, int)>:
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::openNext(FsBaseFile* dir, oflag_t oflag) {
    759a:	push	{r3, r4, r5, r6, r7, lr}
    759c:	mov	r5, r1
    759e:	mov	r4, r0
    75a0:	mov	r7, r2
  close();
    75a2:	bl	74f4 <FsBaseFile::close()>
  if (dir->m_fFile) {
    75a6:	ldr	r6, [r5, #56]	; 0x38
    75a8:	cbz	r6, 75ce <FsBaseFile::openNext(FsBaseFile*, int)+0x34>
    m_fFile = new (m_fileMem) FatFile;
    75aa:	mov	r1, r4
    75ac:	movs	r0, #36	; 0x24
    75ae:	bl	76dc <operator new(unsigned int, unsigned long*)>
    75b2:	movs	r2, #0
    75b4:	strb	r2, [r0, #0]
    75b6:	strb	r2, [r0, #1]
    75b8:	strb	r2, [r0, #2]
    75ba:	str	r0, [r4, #56]	; 0x38
    if (m_fFile->openNext(dir->m_fFile, oflag)) {
    75bc:	mov	r2, r7
    75be:	ldr	r1, [r5, #56]	; 0x38
    75c0:	bl	614c <FatFile::openNext(FatFile*, int)>
    75c4:	cbz	r0, 75ca <FsBaseFile::openNext(FsBaseFile*, int)+0x30>
      return true;
    75c6:	movs	r0, #1
    75c8:	pop	{r3, r4, r5, r6, r7, pc}
    }
    m_fFile = nullptr;
    75ca:	str	r0, [r4, #56]	; 0x38
    75cc:	pop	{r3, r4, r5, r6, r7, pc}
  } else if (dir->m_xFile) {
    75ce:	ldr	r0, [r5, #60]	; 0x3c
    75d0:	cbz	r0, 75f6 <FsBaseFile::openNext(FsBaseFile*, int)+0x5c>
    m_xFile = new (m_fileMem) ExFatFile;
    75d2:	mov	r1, r4
    75d4:	movs	r0, #56	; 0x38
    75d6:	bl	76dc <operator new(unsigned int, unsigned long*)>
    75da:	strb.w	r6, [r0, #49]	; 0x31
    75de:	strb.w	r6, [r0, #50]	; 0x32
    75e2:	strb.w	r6, [r0, #51]	; 0x33
    75e6:	str	r0, [r4, #60]	; 0x3c
    if (m_xFile->openNext(dir->m_xFile, oflag)) {
    75e8:	mov	r2, r7
    75ea:	ldr	r1, [r5, #60]	; 0x3c
    75ec:	bl	4834 <ExFatFile::openNext(ExFatFile*, int)>
    75f0:	cmp	r0, #0
    75f2:	bne.n	75c6 <FsBaseFile::openNext(FsBaseFile*, int)+0x2c>
      return true;
    }
    m_xFile = nullptr;
    75f4:	str	r0, [r4, #60]	; 0x3c
  }
  return false;
}
    75f6:	pop	{r3, r4, r5, r6, r7, pc}

000075f8 <FsVolume::begin(BlockDeviceInterface*)>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    75f8:	push	{r3, r4, r5, r6, r7, lr}
  m_blockDev = blockDev;
  m_fVol = nullptr;
    75fa:	movs	r6, #0
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    75fc:	mov	r4, r0
  m_blockDev = blockDev;
    75fe:	str.w	r1, [r0, #1160]	; 0x488
  m_fVol = nullptr;
    7602:	str.w	r6, [r0, #1152]	; 0x480
  m_xVol = new (m_volMem) ExFatVolume;
    7606:	mov	r1, r0
    7608:	mov.w	r0, #1152	; 0x480
    760c:	bl	76dc <operator new(unsigned int, unsigned long*)>
 * \class ExFatPartition
 * \brief Access exFat partitions on raw file devices.
 */
class ExFatPartition {
 public:
  ExFatPartition() {}
    7610:	strb.w	r6, [r0, #1092]	; 0x444
    7614:	strb.w	r6, [r0, #1145]	; 0x479
    7618:	strb.w	r6, [r0, #1146]	; 0x47a
    761c:	strb.w	r6, [r0, #1147]	; 0x47b
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    7620:	movs	r2, #1
    7622:	str.w	r0, [r4, #1156]	; 0x484
    7626:	ldr.w	r1, [r4, #1160]	; 0x488
    762a:	ldr	r7, [pc, #124]	; (76a8 <FsVolume::begin(BlockDeviceInterface*)+0xb0>)
    762c:	mov	r5, r0
    762e:	bl	4b8c <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>
    7632:	cbz	r0, 764c <FsVolume::begin(BlockDeviceInterface*)+0x54>
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    7634:	add.w	r6, r5, #1096	; 0x448
    7638:	mov	r0, r6
    763a:	bl	40a6 <ExFatFile::close()>
    return m_vwd.openRoot(this);
    763e:	mov	r1, r5
    7640:	mov	r0, r6
    7642:	bl	40fa <ExFatFile::openRoot(ExFatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    7646:	cbz	r0, 764c <FsVolume::begin(BlockDeviceInterface*)+0x54>
      return false;
    }
    if (setCwv || !m_cwv) {
    7648:	ldr	r3, [pc, #96]	; (76ac <FsVolume::begin(BlockDeviceInterface*)+0xb4>)
    764a:	b.n	7692 <FsVolume::begin(BlockDeviceInterface*)+0x9a>
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    764c:	movs	r6, #0
  m_fVol = new (m_volMem) FatVolume;
    764e:	mov	r1, r4
  m_fVol = nullptr;
  m_xVol = new (m_volMem) ExFatVolume;
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    7650:	str.w	r6, [r4, #1156]	; 0x484
  m_fVol = new (m_volMem) FatVolume;
    7654:	movw	r0, #1132	; 0x46c
    7658:	bl	76dc <operator new(unsigned int, unsigned long*)>
 */
class FatPartition {
 public:
  /** Create an instance of FatPartition
   */
  FatPartition() {}
    765c:	strb	r6, [r0, #7]
    765e:	strb.w	r6, [r0, #1096]	; 0x448
    7662:	strb.w	r6, [r0, #1097]	; 0x449
    7666:	strb.w	r6, [r0, #1098]	; 0x44a
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    766a:	movs	r2, #1
    766c:	str.w	r0, [r4, #1152]	; 0x480
    7670:	ldr.w	r1, [r4, #1160]	; 0x488
    7674:	mov	r5, r0
    7676:	bl	6c60 <FatPartition::init(BlockDeviceInterface*, unsigned char)>
    767a:	cbz	r0, 769e <FsVolume::begin(BlockDeviceInterface*)+0xa6>
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    767c:	add.w	r6, r5, #1096	; 0x448
    7680:	mov	r0, r6
    7682:	bl	62b4 <FatFile::close()>
    return m_vwd.openRoot(this);
    7686:	mov	r1, r5
    7688:	mov	r0, r6
    768a:	bl	5da6 <FatFile::openRoot(FatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    768e:	cbz	r0, 769e <FsVolume::begin(BlockDeviceInterface*)+0xa6>
      return false;
    }
    if (setCwv || !m_cwv) {
    7690:	ldr	r3, [pc, #28]	; (76b0 <FsVolume::begin(BlockDeviceInterface*)+0xb8>)
    7692:	ldr	r2, [r3, #0]
    7694:	cbnz	r2, 7698 <FsVolume::begin(BlockDeviceInterface*)+0xa0>
      m_cwv = this;
    7696:	str	r5, [r3, #0]
  m_cwv = nullptr;
  m_fVol = nullptr;
  return false;

 done:
  m_cwv = this;
    7698:	str	r4, [r7, #0]
  return true;
    769a:	movs	r0, #1
    769c:	pop	{r3, r4, r5, r6, r7, pc}
  m_xVol = nullptr;
  m_fVol = new (m_volMem) FatVolume;
  if (m_fVol && m_fVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_cwv = nullptr;
    769e:	movs	r0, #0
    76a0:	str	r0, [r7, #0]
  m_fVol = nullptr;
    76a2:	str.w	r0, [r4, #1152]	; 0x480
  return false;

 done:
  m_cwv = this;
  return true;
}
    76a6:	pop	{r3, r4, r5, r6, r7, pc}
    76a8:	.word	0x2001a69c
    76ac:	.word	0x2001a694
    76b0:	.word	0x2001a698

000076b4 <FsVolume::open(char const*, int)>:
bool FsVolume::ls(print_t* pr, const char* path, uint8_t flags) {
  FsBaseFile dir;
  return dir.open(this, path, O_RDONLY) && dir.ls(pr, flags);
}
//------------------------------------------------------------------------------
FsFile FsVolume::open(const char *path, oflag_t oflag) {
    76b4:	push	{r3, r4, r5, lr}
    76b6:	mov	r4, r0
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    76b8:	movs	r0, #0
    76ba:	strb	r0, [r4, #4]
    76bc:	strb	r0, [r4, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
    76be:	str	r0, [r4, #72]	; 0x48
    76c0:	str	r0, [r4, #76]	; 0x4c
    76c2:	mov.w	r5, #1000	; 0x3e8
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    76c6:	mov	r0, r4
    76c8:	str	r5, [r4, #8]
    76ca:	ldr	r5, [pc, #12]	; (76d8 <FsVolume::open(char const*, int)+0x24>)
    76cc:	str.w	r5, [r0], #16
  FsFile tmpFile;
  tmpFile.open(this, path, oflag);
    76d0:	bl	751c <FsBaseFile::open(FsVolume*, char const*, int)>
  return tmpFile;
}
    76d4:	mov	r0, r4
    76d6:	pop	{r3, r4, r5, pc}
    76d8:	.word	0x00012554

000076dc <operator new(unsigned int, unsigned long*)>:
 */
#include "FsNew.h"
void* operator new(size_t size, newalign_t* ptr) {
  (void)size;
  return ptr;
}
    76dc:	mov	r0, r1
    76de:	bx	lr

000076e0 <SdSpiCard::errorCode() const>:
  /**
   * \return code for the last error. See SdCardInfo.h for a list of error codes.
   */
  uint8_t errorCode() const {
    return m_errorCode;
  }
    76e0:	ldrb	r0, [r0, #15]
    76e2:	bx	lr

000076e4 <SdSpiCard::errorData() const>:
  /** \return error data for last error. */
  uint32_t errorData() const {
    return m_status;
  }
    76e4:	ldrb	r0, [r0, #17]
    76e6:	bx	lr

000076e8 <SdSpiCard::readSector(unsigned long, unsigned char*)>:
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    76e8:	ldr	r3, [r0, #0]
   *
   * \param[in] sector Logical sector to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
    76ea:	push	{r4}
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    76ec:	ldr	r4, [r3, #16]
    76ee:	movs	r3, #1
    76f0:	mov	ip, r4
#else  // ENABLE_DEDICATED_SPI
    return readSingle(sector, dst);
#endif  // ENABLE_DEDICATED_SPI
  }
    76f2:	ldr.w	r4, [sp], #4
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    76f6:	bx	ip

000076f8 <SdSpiCard::type() const>:
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
  }
    76f8:	ldrb	r0, [r0, #18]
    76fa:	bx	lr

000076fc <SdSpiCard::~SdSpiCard()>:
/**
 * \class SdSpiCard
 * \brief Raw access to SD and SDHC flash memory cards via SPI protocol.
 */
#if HAS_SDIO_CLASS
class SdSpiCard : public SdCardInterface {
    76fc:	bx	lr

000076fe <SdSpiCard::~SdSpiCard()>:
    76fe:	push	{r4, lr}
    7700:	movs	r1, #20
    7702:	mov	r4, r0
    7704:	bl	a3b8 <operator delete(void*, unsigned int)>
    7708:	mov	r0, r4
    770a:	pop	{r4, pc}

0000770c <SdSpiCard::sectorCount()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
uint32_t SdSpiCard::sectorCount() {
    770c:	push	{r0, r1, r2, r3, r4, lr}
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
    770e:	ldr	r3, [r0, #0]
    7710:	mov	r1, sp
    7712:	ldr	r3, [r3, #60]	; 0x3c
    7714:	blx	r3
    7716:	cbz	r0, 7786 <SdSpiCard::sectorCount()+0x7a>
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    7718:	ldrb.w	r3, [sp]
    771c:	ands.w	r3, r3, #192	; 0xc0
    7720:	bne.n	7762 <SdSpiCard::sectorCount()+0x56>
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    7722:	ldrb.w	r0, [sp, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7726:	ldrb.w	r3, [sp, #7]
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    772a:	ldrb.w	r2, [sp, #10]
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    772e:	and.w	r0, r0, #3
    7732:	lsls	r3, r3, #2
    7734:	orr.w	r3, r3, r0, lsl #10
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    7738:	ldrb.w	r0, [sp, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    773c:	orr.w	r0, r3, r0, lsr #6
    7740:	adds	r3, r0, #1
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    7742:	ldrb.w	r0, [sp, #9]
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7746:	and.w	r0, r0, #3
    774a:	lsls	r0, r0, #1
    774c:	orr.w	r0, r0, r2, lsr #7
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    7750:	ldrb.w	r2, [sp, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7754:	and.w	r2, r2, #15
    7758:	add	r0, r2
    775a:	subs	r0, #7
    775c:	lsl.w	r0, r3, r0
    7760:	b.n	7786 <SdSpiCard::sectorCount()+0x7a>
  } else if (csd->v2.csd_ver == 1) {
    7762:	cmp	r3, #64	; 0x40
    7764:	bne.n	7784 <SdSpiCard::sectorCount()+0x78>
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    7766:	ldrb.w	r0, [sp, #9]
    776a:	adds	r3, r0, #1
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    776c:	ldrb.w	r0, [sp, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    7770:	and.w	r0, r0, #63	; 0x3f
    7774:	add.w	r0, r3, r0, lsl #16
    7778:	ldrb.w	r3, [sp, #8]
    777c:	add.w	r0, r0, r3, lsl #8
    7780:	lsls	r0, r0, #10
    7782:	b.n	7786 <SdSpiCard::sectorCount()+0x7a>
    7784:	movs	r0, #0
}
    7786:	add	sp, #20
    7788:	ldr.w	pc, [sp], #4

0000778c <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>:
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spiDriverPtr->receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriverPtr->send(data);
    778c:	ldr	r3, [r0, #0]
    778e:	ldr	r3, [r3, #20]
    7790:	bx	r3

00007792 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>:
  }
  void spiDeactivate() {
    m_spiDriverPtr->deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriverPtr->receive();
    7792:	ldr	r3, [r0, #0]
    7794:	ldr	r3, [r3, #12]
    7796:	bx	r3

00007798 <SysCall::curTimeMS()>:
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    7798:	ldr	r3, [pc, #12]	; (77a8 <SysCall::curTimeMS()+0x10>)
/** Define macro for strings stored in flash. */
#define F(str) (str)
#endif  // F
//------------------------------------------------------------------------------
/** \return the time in milliseconds. */
inline SdMillis_t SysCall::curTimeMS() {
    779a:	sub	sp, #8
    779c:	ldr	r3, [r3, #0]
    779e:	str	r3, [sp, #4]
	return ret;
    77a0:	ldr	r0, [sp, #4]
  return millis();
}
    77a2:	uxth	r0, r0
    77a4:	add	sp, #8
    77a6:	bx	lr
    77a8:	.word	0x2001a6fc

000077ac <SdSpiCard::spiStart()>:
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
    77ac:	push	{r3, r4, r5, lr}
  if (!m_spiActive) {
    77ae:	ldrb	r5, [r0, #16]
uint32_t SdSpiCard::sectorCount() {
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
    77b0:	mov	r4, r0
  if (!m_spiActive) {
    77b2:	cbnz	r5, 77d0 <SdSpiCard::spiStart()+0x24>
    77b4:	ldr	r0, [r0, #4]
    m_spiDriver.setSckSpeed(maxSck);
  }
  SdSpiDriver m_spiDriver;
#else  // SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriverPtr->activate();
    77b6:	ldr	r3, [r0, #0]
    77b8:	ldr	r3, [r3, #0]
    77ba:	blx	r3
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    77bc:	mov	r1, r5
    77be:	ldrb	r0, [r4, #14]
    77c0:	bl	1b80 <sdCsWrite(unsigned char, bool)>
    spiActivate();
    spiSelect();
    // Dummy byte to drive MISO busy status.
    spiSend(0XFF);    
    77c4:	movs	r1, #255	; 0xff
    77c6:	ldr	r0, [r4, #4]
    77c8:	bl	778c <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    m_spiActive = true;
    77cc:	movs	r3, #1
    77ce:	strb	r3, [r4, #16]
    77d0:	pop	{r3, r4, r5, pc}

000077d2 <SdSpiCard::spiStop()>:
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    77d2:	ldrb	r3, [r0, #16]
    spiSend(0XFF);    
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
    77d4:	push	{r4, lr}
    77d6:	mov	r4, r0
  if (m_spiActive) {
    77d8:	cbz	r3, 77f6 <SdSpiCard::spiStop()+0x24>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    77da:	movs	r1, #1
    77dc:	ldrb	r0, [r0, #14]
    77de:	bl	1b80 <sdCsWrite(unsigned char, bool)>
    spiUnselect();
    // Insure MISO goes to low Z.
    spiSend(0XFF);        
    77e2:	movs	r1, #255	; 0xff
    77e4:	ldr	r0, [r4, #4]
    77e6:	bl	778c <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    77ea:	ldr	r0, [r4, #4]
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriverPtr->begin(spiConfig);
  }
  void spiDeactivate() {
    m_spiDriverPtr->deactivate();
    77ec:	ldr	r3, [r0, #0]
    77ee:	ldr	r3, [r3, #8]
    77f0:	blx	r3
    spiDeactivate();
    m_spiActive = false;
    77f2:	movs	r3, #0
    77f4:	strb	r3, [r4, #16]
    77f6:	pop	{r4, pc}

000077f8 <SdSpiCard::isBusy()>:
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    77f8:	push	{r4, r5, r6, lr}
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    77fa:	ldrb	r3, [r0, #12]
    77fc:	cmp	r3, #1
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    77fe:	mov	r5, r0
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    7800:	beq.n	7822 <SdSpiCard::isBusy()+0x2a>
    return false;
  }
#endif  // ENABLE_DEDICATED_SPI
  bool spiActive = m_spiActive;
    7802:	ldrb	r6, [r0, #16]
  if (!spiActive) {
    7804:	cbnz	r6, 780a <SdSpiCard::isBusy()+0x12>
    spiStart();
    7806:	bl	77ac <SdSpiCard::spiStart()>
  }
  bool rtn = 0XFF != spiReceive();
    780a:	ldr	r0, [r5, #4]
    780c:	bl	7792 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7810:	subs.w	r4, r0, #255	; 0xff
    7814:	it	ne
    7816:	movne	r4, #1
  if (!spiActive) {
    7818:	cbnz	r6, 7826 <SdSpiCard::isBusy()+0x2e>
    spiStop();
    781a:	mov	r0, r5
    781c:	bl	77d2 <SdSpiCard::spiStop()>
    7820:	b.n	7826 <SdSpiCard::isBusy()+0x2e>
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    return false;
    7822:	movs	r0, #0
    7824:	pop	{r4, r5, r6, pc}
  }
  bool rtn = 0XFF != spiReceive();
  if (!spiActive) {
    spiStop();
  }
  return rtn;
    7826:	mov	r0, r4
}
    7828:	pop	{r4, r5, r6, pc}

0000782a <SdSpiCard::readData(unsigned char*, unsigned int)>:
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst) {
  return readData(dst, 512);
}
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst, size_t count) {
    782a:	push	{r3, r4, r5, r6, r7, lr}
    782c:	mov	r4, r0
    782e:	mov	r5, r1
    7830:	mov	r6, r2
  uint16_t crc;
#endif  // USE_SD_CRC

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
    7832:	bl	7798 <SysCall::curTimeMS()>
    7836:	mov	r7, r0
  while ((m_status = spiReceive()) == 0XFF) {
    7838:	ldr	r0, [r4, #4]
    783a:	bl	7792 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    783e:	cmp	r0, #255	; 0xff
    7840:	strb	r0, [r4, #17]
    7842:	bne.n	7854 <SdSpiCard::readData(unsigned char*, unsigned int)+0x2a>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    7844:	bl	7798 <SysCall::curTimeMS()>

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
  while ((m_status = spiReceive()) == 0XFF) {
    if (isTimedOut(t0, SD_READ_TIMEOUT)) {
    7848:	subs	r0, r0, r7
    784a:	cmp.w	r0, #300	; 0x12c
    784e:	ble.n	7838 <SdSpiCard::readData(unsigned char*, unsigned int)+0xe>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7850:	movs	r3, #29
    7852:	b.n	786e <SdSpiCard::readData(unsigned char*, unsigned int)+0x44>
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
    }
  }
  DBG_END_TIME(DBG_WAIT_READ);
  if (m_status != DATA_START_SECTOR) {
    7854:	cmp	r0, #254	; 0xfe
    7856:	beq.n	785c <SdSpiCard::readData(unsigned char*, unsigned int)+0x32>
    7858:	movs	r3, #24
    785a:	b.n	786e <SdSpiCard::readData(unsigned char*, unsigned int)+0x44>
    785c:	ldr	r0, [r4, #4]
  }
  uint8_t spiReceive() {
    return m_spiDriverPtr->receive();
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spiDriverPtr->receive(buf, n);
    785e:	ldr	r3, [r0, #0]
    7860:	mov	r2, r6
    7862:	ldr	r3, [r3, #16]
    7864:	mov	r1, r5
    7866:	blx	r3
    error(SD_CARD_ERROR_READ_TOKEN);
    goto fail;
  }
  // transfer data
  if ((m_status = spiReceive(dst, count))) {
    7868:	strb	r0, [r4, #17]
    786a:	cbz	r0, 787a <SdSpiCard::readData(unsigned char*, unsigned int)+0x50>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    786c:	movs	r3, #37	; 0x25
  spiReceive();
#endif  // USE_SD_CRC
  return true;

 fail:
  spiStop();
    786e:	mov	r0, r4
    7870:	strb	r3, [r4, #15]
    7872:	bl	77d2 <SdSpiCard::spiStop()>
  return false;
    7876:	movs	r0, #0
}
    7878:	pop	{r3, r4, r5, r6, r7, pc}
    error(SD_CARD_ERROR_READ_CRC);
    goto fail;
  }
#else  // USE_SD_CRC
  // discard crc
  spiReceive();
    787a:	ldr	r0, [r4, #4]
    787c:	bl	7792 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
  spiReceive();
    7880:	ldr	r0, [r4, #4]
    7882:	bl	7792 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7886:	movs	r0, #1
    7888:	pop	{r3, r4, r5, r6, r7, pc}

0000788a <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    788a:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    788e:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    7890:	ldrb	r3, [r0, #12]
    7892:	cmp	r3, #2
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    7894:	mov	r4, r0
    7896:	mov	r5, r1
    7898:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    789a:	bne.n	78a2 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x18>
    789c:	ldr	r3, [r0, #8]
    789e:	cmp	r3, r1
    78a0:	beq.n	78b4 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2a>
    if (!writeStart(sector)) {
    78a2:	ldr	r3, [r4, #0]
    78a4:	mov	r1, r5
    78a6:	ldr	r3, [r3, #80]	; 0x50
    78a8:	mov	r0, r4
    78aa:	blx	r3
    78ac:	cbz	r0, 78e2 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x58>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
    78ae:	movs	r3, #2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    if (!writeStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    78b0:	str	r5, [r4, #8]
    m_curState = WRITE_STATE;
    78b2:	strb	r3, [r4, #12]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    78b4:	movs	r5, #0
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    78b6:	cmp	r5, r7
    78b8:	add.w	r1, r6, r5, lsl #9
    78bc:	beq.n	78cc <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x42>
    if (!writeData(src)) {
    78be:	ldr	r3, [r4, #0]
    78c0:	mov	r0, r4
    78c2:	ldr	r3, [r3, #76]	; 0x4c
    78c4:	blx	r3
    78c6:	cbz	r0, 78e2 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x58>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    78c8:	adds	r5, #1
    78ca:	b.n	78b6 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2c>
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    78cc:	ldr	r3, [r4, #8]
    78ce:	add	r5, r3
  return m_sharedSpi ? syncDevice() : true;
    78d0:	ldrb	r3, [r4, #13]
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    78d2:	str	r5, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    78d4:	cbz	r3, 78ee <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x64>
    78d6:	ldr	r3, [r4, #0]
    78d8:	mov	r0, r4
    78da:	ldr	r3, [r3, #28]
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    78dc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    78e0:	bx	r3
  }
  return writeStop();
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
    78e2:	mov	r0, r4
    78e4:	bl	77d2 <SdSpiCard::spiStop()>
  return false;
    78e8:	movs	r0, #0
    78ea:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    78ee:	movs	r0, #1
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    78f0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000078f4 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)>:
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    78f4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    78f8:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    78fa:	ldrb	r3, [r0, #12]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    78fc:	ldr.w	r8, [sp, #32]
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    7900:	cmp	r3, #2
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    7902:	mov	r4, r0
    7904:	mov	r5, r1
    7906:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    7908:	bne.n	7910 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x1c>
    790a:	ldr	r3, [r0, #8]
    790c:	cmp	r3, r1
    790e:	beq.n	7922 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x2e>
    if (!writeStart(sector)) {
    7910:	ldr	r3, [r4, #0]
    7912:	mov	r1, r5
    7914:	ldr	r3, [r3, #80]	; 0x50
    7916:	mov	r0, r4
    7918:	blx	r3
    791a:	cbz	r0, 7958 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x64>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
    791c:	movs	r3, #2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    if (!writeStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    791e:	str	r5, [r4, #8]
    m_curState = WRITE_STATE;
    7920:	strb	r3, [r4, #12]
    7922:	add.w	r9, r5, r6
  }
  for (size_t i = 0; i < ns; i++) {
    7926:	cmp	r5, r9
    7928:	beq.n	7942 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x4e>
    const uint8_t *src = callback(sector + i, context);
    792a:	mov	r1, r8
    792c:	mov	r0, r5
    792e:	blx	r7
    if (!writeData(src)) {
    7930:	ldr	r3, [r4, #0]
    7932:	mov	r1, r0
    7934:	ldr	r3, [r3, #76]	; 0x4c
    7936:	mov	r0, r4
    7938:	blx	r3
    793a:	adds	r5, #1
    793c:	cmp	r0, #0
    793e:	bne.n	7926 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x32>
    7940:	b.n	7958 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x64>
      goto fail;
    }
  }
  m_curSector += ns;
    7942:	ldr	r3, [r4, #8]
    7944:	add	r6, r3
  return m_sharedSpi ? syncDevice() : true;
    7946:	ldrb	r3, [r4, #13]
    const uint8_t *src = callback(sector + i, context);
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
    7948:	str	r6, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    794a:	cbz	r3, 7964 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x70>
    794c:	ldr	r3, [r4, #0]
    794e:	mov	r0, r4
    7950:	ldr	r3, [r3, #28]
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    7952:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7956:	bx	r3
  }
  return writeStop();
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
    7958:	mov	r0, r4
    795a:	bl	77d2 <SdSpiCard::spiStop()>
  return false;
    795e:	movs	r0, #0
    7960:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7964:	movs	r0, #1
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    7966:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000796a <SdSpiCard::waitNotBusy(unsigned short)>:
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
//------------------------------------------------------------------------------
// wait for card to go not busy
bool SdSpiCard::waitNotBusy(SdMillis_t timeoutMS) {
    796a:	push	{r4, r5, r6, lr}
    796c:	mov	r6, r0
    796e:	mov	r4, r1
  SdMillis_t t0 = SysCall::curTimeMS();
    7970:	bl	7798 <SysCall::curTimeMS()>
    7974:	mov	r5, r0
    }
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    7976:	ldr	r0, [r6, #4]
    7978:	bl	7792 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    797c:	cmp	r0, #255	; 0xff
    797e:	beq.n	798e <SdSpiCard::waitNotBusy(unsigned short)+0x24>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    7980:	bl	7798 <SysCall::curTimeMS()>
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    if (isTimedOut(t0, timeoutMS)) {
    7984:	subs	r0, r0, r5
    7986:	cmp	r0, r4
    7988:	ble.n	7976 <SdSpiCard::waitNotBusy(unsigned short)+0xc>
      return false;
    798a:	movs	r0, #0
    798c:	pop	{r4, r5, r6, pc}
    }
  }
  return true;
    798e:	movs	r0, #1
#endif  // WDT_YIELD_TIME_MILLIS
}
    7990:	pop	{r4, r5, r6, pc}

00007992 <SdSpiCard::cardCommand(unsigned char, unsigned long)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    7992:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    7994:	ldrb	r3, [r0, #12]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    7996:	str	r2, [sp, #4]
    7998:	mov	r4, r0
    799a:	mov	r5, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    799c:	cbz	r3, 79aa <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x18>
    799e:	ldr	r3, [r0, #0]
    79a0:	ldr	r3, [r3, #28]
    79a2:	blx	r3
    79a4:	cbnz	r0, 79aa <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x18>
    return 0XFF;
    79a6:	movs	r0, #255	; 0xff
    79a8:	b.n	7a0a <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x78>
  }
#endif  // ENABLE_DEDICATED_SPI
  // select card
  if (!m_spiActive) {
    79aa:	ldrb	r3, [r4, #16]
    79ac:	cbnz	r3, 79b4 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x22>
    spiStart();
    79ae:	mov	r0, r4
    79b0:	bl	77ac <SdSpiCard::spiStart()>
  }
  // wait if busy unless CMD0
  if (cmd != CMD0) {
    79b4:	cbz	r5, 79c0 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x2e>
    DBG_BEGIN_TIME(DBG_CMD_BUSY);
    waitNotBusy(SD_CMD_TIMEOUT);
    79b6:	mov.w	r1, #300	; 0x12c
    79ba:	mov	r0, r4
    79bc:	bl	796a <SdSpiCard::waitNotBusy(unsigned short)>

  // send message
  spiSend(buf, 6);
#else  // USE_SD_CRC
  // send command
  spiSend(cmd | 0x40);
    79c0:	orr.w	r1, r5, #64	; 0x40
    79c4:	ldr	r0, [r4, #4]
    79c6:	bl	778c <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    79ca:	add.w	r6, sp, #7
    79ce:	add.w	r7, sp, #3

  // send argument
  uint8_t* pa = reinterpret_cast<uint8_t*>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    spiSend(pa[i]);
    79d2:	ldrb.w	r1, [r6], #-1
    79d6:	ldr	r0, [r4, #4]
    79d8:	bl	778c <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
  // send command
  spiSend(cmd | 0x40);

  // send argument
  uint8_t* pa = reinterpret_cast<uint8_t*>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    79dc:	cmp	r7, r6
    79de:	bne.n	79d2 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x40>
    spiSend(pa[i]);
  }

  // send CRC - correct for CMD0 with arg zero or CMD8 with arg 0X1AA
  spiSend(cmd == CMD0 ? 0X95 : 0X87);
    79e0:	cmp	r5, #0
    79e2:	ite	eq
    79e4:	moveq	r1, #149	; 0x95
    79e6:	movne	r1, #135	; 0x87
    79e8:	ldr	r0, [r4, #4]
    79ea:	bl	778c <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
#endif  // USE_SD_CRC

  // discard first fill byte to avoid MISO pull-up problem.
  spiReceive();
    79ee:	ldr	r0, [r4, #4]
    79f0:	bl	7792 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    79f4:	movs	r5, #11

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
    79f6:	ldr	r0, [r4, #4]
    79f8:	bl	7792 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    79fc:	lsls	r3, r0, #24
    79fe:	strb	r0, [r4, #17]
    7a00:	bpl.n	7a0a <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x78>
    7a02:	subs	r5, #1
    7a04:	ands.w	r5, r5, #255	; 0xff
    7a08:	bne.n	79f6 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x64>
  }
  return m_status;
}
    7a0a:	add	sp, #12
    7a0c:	pop	{r4, r5, r6, r7, pc}

00007a0e <SdSpiCard::cardAcmd(unsigned char, unsigned long)>:
  /** Set CS high and deactivate the card. */
  void spiStop();

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    7a0e:	push	{r4, r5, r6, lr}
    7a10:	mov	r4, r0
    7a12:	mov	r5, r1
    7a14:	mov	r6, r2
    cardCommand(CMD55, 0);
    7a16:	movs	r1, #55	; 0x37
    7a18:	movs	r2, #0
    7a1a:	bl	7992 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    return cardCommand(cmd, arg);
    7a1e:	mov	r2, r6
    7a20:	mov	r1, r5
    7a22:	mov	r0, r4
  }
    7a24:	ldmia.w	sp!, {r4, r5, r6, lr}

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    cardCommand(CMD55, 0);
    return cardCommand(cmd, arg);
    7a28:	b.w	7992 <SdSpiCard::cardCommand(unsigned char, unsigned long)>

00007a2c <SdSpiCard::begin(SdSpiConfig)>:
#endif  // CRC_CCITT
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
    7a2c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7a30:	sub	sp, #36	; 0x24
    7a32:	add	r5, sp, #4
    7a34:	stmia.w	r5, {r1, r2, r3}
    7a38:	mov	r4, r0
    7a3a:	ldrb.w	sl, [sp, #4]
    7a3e:	ldr.w	fp, [sp, #12]
    7a42:	ldrb.w	r8, [sp, #5]
    7a46:	ldr	r6, [sp, #8]
  SdMillis_t t0 = SysCall::curTimeMS();
    7a48:	bl	7798 <SysCall::curTimeMS()>
  m_spiActive = false;
    7a4c:	mov.w	r9, #0
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
  SdMillis_t t0 = SysCall::curTimeMS();
    7a50:	mov	r7, r0
  m_spiActive = false;
    7a52:	strb.w	r9, [r4, #16]
  m_errorCode = SD_CARD_ERROR_NONE;
    7a56:	strb.w	r9, [r4, #15]
  m_type = 0;
    7a5a:	strb.w	r9, [r4, #18]
  m_csPin = spiConfig.csPin;
    7a5e:	strb.w	sl, [r4, #14]
#if SPI_DRIVER_SELECT >= 2
  m_spiDriverPtr = spiConfig.spiPort;
    7a62:	str.w	fp, [r4, #4]
  if (!m_spiDriverPtr) {
    7a66:	cmp.w	fp, #0
    7a6a:	bne.n	7a70 <SdSpiCard::begin(SdSpiConfig)+0x44>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7a6c:	movs	r3, #42	; 0x2a
    7a6e:	b.n	7ba4 <SdSpiCard::begin(SdSpiConfig)+0x178>
    error(SD_CARD_ERROR_INVALID_CARD_CONFIG);
    goto fail;
  }
#endif  // SPI_DRIVER_SELECT
  sdCsInit(m_csPin);
    7a70:	mov	r0, sl
    7a72:	bl	1b64 <sdCsInit(unsigned char)>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    7a76:	movs	r1, #1
    7a78:	ldrb	r0, [r4, #14]
    7a7a:	bl	1b80 <sdCsWrite(unsigned char, bool)>
    7a7e:	ldr	r0, [r4, #4]
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
  }
  void spiSetSckSpeed(uint32_t maxSck) {
    m_spiDriverPtr->setSckSpeed(maxSck);
    7a80:	ldr	r1, [pc, #344]	; (7bdc <SdSpiCard::begin(SdSpiConfig)+0x1b0>)
    7a82:	ldr	r3, [r0, #0]
    7a84:	ldr	r3, [r3, #28]
    7a86:	blx	r3
    7a88:	ldmia.w	r5, {r0, r1, r2}
    7a8c:	add	r3, sp, #20
    7a8e:	ldr.w	lr, [r4, #4]
    7a92:	stmia.w	r3, {r0, r1, r2}
#else  // SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriverPtr->activate();
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriverPtr->begin(spiConfig);
    7a96:	ldr.w	r2, [lr]
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
  m_sharedSpi = spiOptionShared(spiConfig.options);
    7a9a:	and.w	r8, r8, #1
    7a9e:	mov	r0, lr
    7aa0:	ldr	r5, [r2, #4]
    7aa2:	eor.w	r8, r8, #1
    7aa6:	ldmia	r3, {r1, r2, r3}
    7aa8:	blx	r5
#else  // ENABLE_DEDICATED_SPI
  // m_sharedSpi is a static const bool in this case.
  static_assert(m_sharedSpi == true, "m_sharedSpi bug");
#endif  // ENABLE_DEDICATED_SPI
  spiStart();
    7aaa:	mov	r0, r4
  spiUnselect();
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
    7aac:	strb.w	r9, [r4, #12]
  m_sharedSpi = spiOptionShared(spiConfig.options);
    7ab0:	strb.w	r8, [r4, #13]
#else  // ENABLE_DEDICATED_SPI
  // m_sharedSpi is a static const bool in this case.
  static_assert(m_sharedSpi == true, "m_sharedSpi bug");
#endif  // ENABLE_DEDICATED_SPI
  spiStart();
    7ab4:	bl	77ac <SdSpiCard::spiStart()>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    7ab8:	movs	r1, #1
    7aba:	ldrb	r0, [r4, #14]
    7abc:	bl	1b80 <sdCsWrite(unsigned char, bool)>
    7ac0:	movs	r5, #10

  // must supply min of 74 clock cycles with CS high.
  spiUnselect();
  for (uint8_t i = 0; i < 10; i++) {
    spiSend(0XFF);
    7ac2:	movs	r1, #255	; 0xff
    7ac4:	ldr	r0, [r4, #4]
    7ac6:	subs	r5, #1
    7ac8:	bl	778c <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
#endif  // ENABLE_DEDICATED_SPI
  spiStart();

  // must supply min of 74 clock cycles with CS high.
  spiUnselect();
  for (uint8_t i = 0; i < 10; i++) {
    7acc:	ands.w	r5, r5, #255	; 0xff
    7ad0:	bne.n	7ac2 <SdSpiCard::begin(SdSpiConfig)+0x96>
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    7ad2:	mov	r1, r5
    7ad4:	ldrb	r0, [r4, #14]
    7ad6:	bl	1b80 <sdCsWrite(unsigned char, bool)>
    7ada:	movs	r5, #10
  spiSelect();
  DBG_BEGIN_TIME(DBG_CMD0_TIME);
  // command to go idle in SPI mode
  for (uint8_t i = 1;; i++) {
    DBG_EVENT_COUNT(DBG_CMD0_COUNT);
    if (cardCommand(CMD0, 0) == R1_IDLE_STATE) {
    7adc:	movs	r2, #0
    7ade:	mov	r1, r2
    7ae0:	mov	r0, r4
    7ae2:	bl	7992 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7ae6:	cmp	r0, #1
    7ae8:	mov	r8, r0
    7aea:	beq.n	7b12 <SdSpiCard::begin(SdSpiConfig)+0xe6>
    7aec:	subs	r5, #1
      break;
    }
    if (i == SD_CMD0_RETRY) {
    7aee:	ands.w	r5, r5, #255	; 0xff
    7af2:	bne.n	7af8 <SdSpiCard::begin(SdSpiConfig)+0xcc>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7af4:	movs	r3, #1
    7af6:	b.n	7ba4 <SdSpiCard::begin(SdSpiConfig)+0x178>
      error(SD_CARD_ERROR_CMD0);
      goto fail;
    }
    // stop multi-block write
    spiSend(STOP_TRAN_TOKEN);
    7af8:	movs	r1, #253	; 0xfd
    7afa:	ldr	r0, [r4, #4]
    7afc:	bl	778c <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    7b00:	mov.w	r8, #520	; 0x208
    // finish block transfer
    for (int i = 0; i < 520; i++) {
      spiReceive();
    7b04:	ldr	r0, [r4, #4]
    7b06:	bl	7792 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
      goto fail;
    }
    // stop multi-block write
    spiSend(STOP_TRAN_TOKEN);
    // finish block transfer
    for (int i = 0; i < 520; i++) {
    7b0a:	subs.w	r8, r8, #1
    7b0e:	bne.n	7b04 <SdSpiCard::begin(SdSpiConfig)+0xd8>
    7b10:	b.n	7adc <SdSpiCard::begin(SdSpiConfig)+0xb0>
    goto fail;
  }
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    7b12:	mov.w	r2, #426	; 0x1aa
    7b16:	movs	r1, #8
    7b18:	mov	r0, r4
    7b1a:	bl	7992 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7b1e:	lsls	r3, r0, #29
    7b20:	bmi.n	7b40 <SdSpiCard::begin(SdSpiConfig)+0x114>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    7b22:	movs	r3, #2
    7b24:	strb	r3, [r4, #18]
    7b26:	movs	r5, #4
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
      m_status = spiReceive();
    7b28:	ldr	r0, [r4, #4]
    7b2a:	bl	7792 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7b2e:	subs	r5, #1
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    7b30:	ands.w	r5, r5, #255	; 0xff
      m_status = spiReceive();
    7b34:	strb	r0, [r4, #17]
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    7b36:	bne.n	7b28 <SdSpiCard::begin(SdSpiConfig)+0xfc>
      m_status = spiReceive();
    }
    if (m_status != 0XAA) {
    7b38:	cmp	r0, #170	; 0xaa
    7b3a:	beq.n	7b44 <SdSpiCard::begin(SdSpiConfig)+0x118>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7b3c:	movs	r3, #6
    7b3e:	b.n	7ba4 <SdSpiCard::begin(SdSpiConfig)+0x178>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    7b40:	strb.w	r8, [r4, #18]
    }
  } else {
    type(SD_CARD_TYPE_SD1);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
    7b44:	ldr	r3, [r4, #0]
    7b46:	mov	r0, r4
    7b48:	ldr	r3, [r3, #72]	; 0x48
    7b4a:	blx	r3
    7b4c:	cmp	r0, #2
    7b4e:	ite	eq
    7b50:	moveq.w	r8, #1073741824	; 0x40000000
    7b54:	movne.w	r8, #0
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    7b58:	mov	r2, r8
    7b5a:	movs	r1, #41	; 0x29
    7b5c:	mov	r0, r4
    7b5e:	bl	7a0e <SdSpiCard::cardAcmd(unsigned char, unsigned long)>
    7b62:	mov	r5, r0
    7b64:	cbz	r0, 7b76 <SdSpiCard::begin(SdSpiConfig)+0x14a>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    7b66:	bl	7798 <SysCall::curTimeMS()>
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    DBG_EVENT_COUNT(DBG_ACMD41_COUNT);
    // check for timeout
    if (isTimedOut(t0, SD_INIT_TIMEOUT)) {
    7b6a:	subs	r0, r0, r7
    7b6c:	cmp.w	r0, #2000	; 0x7d0
    7b70:	ble.n	7b58 <SdSpiCard::begin(SdSpiConfig)+0x12c>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7b72:	movs	r3, #23
    7b74:	b.n	7ba4 <SdSpiCard::begin(SdSpiConfig)+0x178>
    }
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    7b76:	ldr	r3, [r4, #0]
    7b78:	mov	r0, r4
    7b7a:	ldr	r3, [r3, #72]	; 0x48
    7b7c:	blx	r3
    7b7e:	cmp	r0, #2
    7b80:	beq.n	7b96 <SdSpiCard::begin(SdSpiConfig)+0x16a>
    // Discard rest of ocr - contains allowed voltage range.
    for (uint8_t i = 0; i < 3; i++) {
      spiReceive();
    }
  }
  spiStop();
    7b82:	mov	r0, r4
    7b84:	bl	77d2 <SdSpiCard::spiStop()>
    7b88:	ldr	r0, [r4, #4]
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
  }
  void spiSetSckSpeed(uint32_t maxSck) {
    m_spiDriverPtr->setSckSpeed(maxSck);
    7b8a:	ldr	r3, [r0, #0]
    7b8c:	mov	r1, r6
    7b8e:	ldr	r3, [r3, #28]
    7b90:	blx	r3
  spiSetSckSpeed(spiConfig.maxSck);
  return true;
    7b92:	movs	r0, #1
    7b94:	b.n	7bd6 <SdSpiCard::begin(SdSpiConfig)+0x1aa>
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
    7b96:	mov	r2, r5
    7b98:	movs	r1, #58	; 0x3a
    7b9a:	mov	r0, r4
    7b9c:	bl	7992 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7ba0:	cbz	r0, 7bb0 <SdSpiCard::begin(SdSpiConfig)+0x184>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7ba2:	movs	r3, #18
  spiStop();
  spiSetSckSpeed(spiConfig.maxSck);
  return true;

 fail:
  spiStop();
    7ba4:	mov	r0, r4
    7ba6:	strb	r3, [r4, #15]
    7ba8:	bl	77d2 <SdSpiCard::spiStop()>
  return false;
    7bac:	movs	r0, #0
    7bae:	b.n	7bd6 <SdSpiCard::begin(SdSpiConfig)+0x1aa>
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
      error(SD_CARD_ERROR_CMD58);
      goto fail;
    }
    if ((spiReceive() & 0XC0) == 0XC0) {
    7bb0:	ldr	r0, [r4, #4]
    7bb2:	bl	7792 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7bb6:	and.w	r0, r0, #192	; 0xc0
    7bba:	cmp	r0, #192	; 0xc0
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    7bbc:	itt	eq
    7bbe:	moveq	r3, #3
    7bc0:	strbeq	r3, [r4, #18]
      type(SD_CARD_TYPE_SDHC);
    }
    // Discard rest of ocr - contains allowed voltage range.
    for (uint8_t i = 0; i < 3; i++) {
      spiReceive();
    7bc2:	ldr	r0, [r4, #4]
    7bc4:	bl	7792 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7bc8:	ldr	r0, [r4, #4]
    7bca:	bl	7792 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7bce:	ldr	r0, [r4, #4]
    7bd0:	bl	7792 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7bd4:	b.n	7b82 <SdSpiCard::begin(SdSpiConfig)+0x156>
  return true;

 fail:
  spiStop();
  return false;
}
    7bd6:	add	sp, #36	; 0x24
    7bd8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7bdc:	.word	0x00061a80

00007be0 <SdSpiCard::readOCR(unsigned long*)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7be0:	push	{r4, r5, r6, lr}
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    7be2:	movs	r2, #0
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7be4:	mov	r6, r1
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    7be6:	movs	r1, #58	; 0x3a
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7be8:	mov	r4, r0
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    7bea:	bl	7992 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7bee:	cbz	r0, 7bfe <SdSpiCard::readOCR(unsigned long*)+0x1e>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7bf0:	movs	r3, #18
  }
  spiStop();
  return true;

 fail:
  spiStop();
    7bf2:	mov	r0, r4
    7bf4:	strb	r3, [r4, #15]
    7bf6:	bl	77d2 <SdSpiCard::spiStop()>
  return false;
    7bfa:	movs	r0, #0
    7bfc:	pop	{r4, r5, r6, pc}
    7bfe:	adds	r5, r6, #4
  if (cardCommand(CMD58, 0)) {
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    p[3 - i] = spiReceive();
    7c00:	ldr	r0, [r4, #4]
    7c02:	bl	7792 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7c06:	strb.w	r0, [r5, #-1]!
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    7c0a:	cmp	r5, r6
    7c0c:	bne.n	7c00 <SdSpiCard::readOCR(unsigned long*)+0x20>
    p[3 - i] = spiReceive();
  }
  spiStop();
    7c0e:	mov	r0, r4
    7c10:	bl	77d2 <SdSpiCard::spiStop()>
  return true;
    7c14:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7c16:	pop	{r4, r5, r6, pc}

00007c18 <SdSpiCard::readRegister(unsigned char, void*)>:
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    7c18:	push	{r3, r4, r5, lr}
    7c1a:	mov	r5, r2
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    7c1c:	movs	r2, #0
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    7c1e:	mov	r4, r0
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    7c20:	bl	7992 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7c24:	cbz	r0, 7c2c <SdSpiCard::readRegister(unsigned char, void*)+0x14>
    7c26:	movs	r3, #27
    7c28:	strb	r3, [r4, #15]
    7c2a:	b.n	7c42 <SdSpiCard::readRegister(unsigned char, void*)+0x2a>
    error(SD_CARD_ERROR_READ_REG);
    goto fail;
  }
  if (!readData(dst, 16)) {
    7c2c:	mov	r1, r5
    7c2e:	movs	r2, #16
    7c30:	mov	r0, r4
    7c32:	bl	782a <SdSpiCard::readData(unsigned char*, unsigned int)>
    7c36:	mov	r5, r0
    7c38:	cbz	r0, 7c42 <SdSpiCard::readRegister(unsigned char, void*)+0x2a>
    goto fail;
  }
  spiStop();
    7c3a:	mov	r0, r4
    7c3c:	bl	77d2 <SdSpiCard::spiStop()>
  return true;
    7c40:	b.n	7c4a <SdSpiCard::readRegister(unsigned char, void*)+0x32>

 fail:
  spiStop();
    7c42:	mov	r0, r4
    7c44:	bl	77d2 <SdSpiCard::spiStop()>
  return false;
    7c48:	movs	r5, #0
}
    7c4a:	mov	r0, r5
    7c4c:	pop	{r3, r4, r5, pc}

00007c4e <SdSpiCard::readCSD(csd_t*)>:
   * \param[out] csd pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCSD(csd_t* csd) {
    return readRegister(CMD9, csd);
    7c4e:	mov	r2, r1
    7c50:	movs	r1, #9
    7c52:	b.w	7c18 <SdSpiCard::readRegister(unsigned char, void*)>

00007c56 <SdSpiCard::readCID(CID*)>:
   * \param[out] cid pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCID(cid_t* cid) {
    return readRegister(CMD10, cid);
    7c56:	mov	r2, r1
    7c58:	movs	r1, #10
    7c5a:	b.w	7c18 <SdSpiCard::readRegister(unsigned char, void*)>

00007c5e <SdSpiCard::readStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    7c5e:	push	{r3, r4, r5, lr}
  if (type() != SD_CARD_TYPE_SDHC) {
    7c60:	ldr	r3, [r0, #0]
    7c62:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    7c64:	mov	r5, r1
    7c66:	mov	r4, r0
  if (type() != SD_CARD_TYPE_SDHC) {
    7c68:	blx	r3
    7c6a:	cmp	r0, #3
    sector <<= 9;
    7c6c:	it	ne
    7c6e:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD18, sector)) {
    7c70:	mov	r2, r5
    7c72:	movs	r1, #18
    7c74:	mov	r0, r4
    7c76:	bl	7992 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7c7a:	cbz	r0, 7c8a <SdSpiCard::readStart(unsigned long)+0x2c>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7c7c:	movs	r3, #12
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7c7e:	mov	r0, r4
    7c80:	strb	r3, [r4, #15]
    7c82:	bl	77d2 <SdSpiCard::spiStop()>
  return false;
    7c86:	movs	r0, #0
    7c88:	pop	{r3, r4, r5, pc}
  }
  if (cardCommand(CMD18, sector)) {
    error(SD_CARD_ERROR_CMD18);
    goto fail;
  }
  return true;
    7c8a:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7c8c:	pop	{r3, r4, r5, pc}

00007c8e <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    7c8e:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7c92:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7c94:	ldrb	r3, [r0, #12]
    7c96:	cmp	r3, #1
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    7c98:	mov	r4, r0
    7c9a:	mov	r5, r1
    7c9c:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7c9e:	bne.n	7ca6 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x18>
    7ca0:	ldr	r3, [r0, #8]
    7ca2:	cmp	r3, r1
    7ca4:	beq.n	7cbc <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x2e>
    if (!readStart(sector)) {
    7ca6:	mov	r1, r5
    7ca8:	mov	r0, r4
    7caa:	bl	7c5e <SdSpiCard::readStart(unsigned long)>
    7cae:	cbnz	r0, 7cb6 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x28>
    }
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
    7cb0:	movs	r0, #0
    7cb2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
    7cb6:	movs	r3, #1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    7cb8:	str	r5, [r4, #8]
    m_curState = READ_STATE;
    7cba:	strb	r3, [r4, #12]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    7cbc:	movs	r5, #0
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    7cbe:	cmp	r5, r7
    7cc0:	add.w	r1, r6, r5, lsl #9
    7cc4:	beq.n	7cd8 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4a>
    if (!readData(dst, 512)) {
    7cc6:	mov.w	r2, #512	; 0x200
    7cca:	mov	r0, r4
    7ccc:	bl	782a <SdSpiCard::readData(unsigned char*, unsigned int)>
    7cd0:	cmp	r0, #0
    7cd2:	beq.n	7cb0 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x22>
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    7cd4:	adds	r5, #1
    7cd6:	b.n	7cbe <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x30>
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    7cd8:	ldr	r3, [r4, #8]
    7cda:	add	r5, r3
  return m_sharedSpi ? syncDevice() : true;
    7cdc:	ldrb	r3, [r4, #13]
  for (size_t i = 0; i < ns; i++, dst += 512) {
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    7cde:	str	r5, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    7ce0:	cbz	r3, 7cee <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x60>
    7ce2:	ldr	r3, [r4, #0]
    7ce4:	mov	r0, r4
    7ce6:	ldr	r3, [r3, #28]
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7ce8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7cec:	bx	r3
    7cee:	movs	r0, #1
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7cf0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00007cf4 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)>:
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7cf4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7cf8:	mov	r6, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7cfa:	ldrb	r3, [r0, #12]
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7cfc:	ldr.w	r8, [sp, #32]
    7d00:	ldr.w	r9, [sp, #36]	; 0x24
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7d04:	cmp	r3, #1
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7d06:	mov	r4, r0
    7d08:	mov	r5, r1
    7d0a:	mov	r7, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7d0c:	bne.n	7d14 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x20>
    7d0e:	ldr	r3, [r0, #8]
    7d10:	cmp	r3, r1
    7d12:	beq.n	7d2a <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x36>
    if (!readStart(sector)) {
    7d14:	mov	r1, r5
    7d16:	mov	r0, r4
    7d18:	bl	7c5e <SdSpiCard::readStart(unsigned long)>
    7d1c:	cbnz	r0, 7d24 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x30>
    }
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
    7d1e:	movs	r0, #0
    7d20:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
    7d24:	movs	r3, #1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    7d26:	str	r5, [r4, #8]
    m_curState = READ_STATE;
    7d28:	strb	r3, [r4, #12]
    7d2a:	add.w	sl, r5, r6
  }
  for (size_t i = 0; i < ns; i++) {
    7d2e:	cmp	r5, sl
    7d30:	beq.n	7d4e <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x5a>
    if (readData(dst, 512)) {
    7d32:	mov.w	r2, #512	; 0x200
    7d36:	mov	r1, r7
    7d38:	mov	r0, r4
    7d3a:	bl	782a <SdSpiCard::readData(unsigned char*, unsigned int)>
    7d3e:	cmp	r0, #0
    7d40:	beq.n	7d1e <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x2a>
      callback(sector + i, dst, context);
    7d42:	mov	r0, r5
    7d44:	mov	r2, r9
    7d46:	mov	r1, r7
    7d48:	blx	r8
    7d4a:	adds	r5, #1
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++) {
    7d4c:	b.n	7d2e <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x3a>
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    7d4e:	ldr	r3, [r4, #8]
    7d50:	add	r6, r3
  return m_sharedSpi ? syncDevice() : true;
    7d52:	ldrb	r3, [r4, #13]
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    7d54:	str	r6, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    7d56:	cbz	r3, 7d64 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x70>
    7d58:	ldr	r3, [r4, #0]
    7d5a:	mov	r0, r4
    7d5c:	ldr	r3, [r3, #28]
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7d5e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7d62:	bx	r3
    7d64:	movs	r0, #1
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7d66:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00007d6a <SdSpiCard::readStop()>:
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    7d6a:	push	{r4, lr}
  if (cardCommand(CMD12, 0)) {
    7d6c:	movs	r2, #0
    7d6e:	movs	r1, #12
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    7d70:	mov	r4, r0
  if (cardCommand(CMD12, 0)) {
    7d72:	bl	7992 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7d76:	cbz	r0, 7d86 <SdSpiCard::readStop()+0x1c>
    7d78:	movs	r3, #9
  }
  spiStop();
  return true;

 fail:
  spiStop();
    7d7a:	mov	r0, r4
    7d7c:	strb	r3, [r4, #15]
    7d7e:	bl	77d2 <SdSpiCard::spiStop()>
  return false;
    7d82:	movs	r0, #0
    7d84:	pop	{r4, pc}
bool SdSpiCard::readStop() {
  if (cardCommand(CMD12, 0)) {
    error(SD_CARD_ERROR_CMD12);
    goto fail;
  }
  spiStop();
    7d86:	mov	r0, r4
    7d88:	bl	77d2 <SdSpiCard::spiStop()>
  return true;
    7d8c:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7d8e:	pop	{r4, pc}

00007d90 <SdSpiCard::syncDevice()>:
}
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
    7d90:	ldrb	r2, [r0, #12]
  m_curState = IDLE_STATE;
    7d92:	movs	r1, #0
  if (state == WRITE_STATE) {
    7d94:	cmp	r2, #2
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
  m_curState = IDLE_STATE;
    7d96:	strb	r1, [r0, #12]
  if (state == WRITE_STATE) {
    7d98:	bne.n	7da0 <SdSpiCard::syncDevice()+0x10>
    return writeStop();
    7d9a:	ldr	r3, [r0, #0]
    7d9c:	ldr	r3, [r3, #84]	; 0x54
    7d9e:	bx	r3
  }
  if (state == READ_STATE) {
    7da0:	cmp	r2, #1
    7da2:	bne.n	7da8 <SdSpiCard::syncDevice()+0x18>
    return readStop();
    7da4:	b.w	7d6a <SdSpiCard::readStop()>
  }
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
    7da8:	movs	r0, #1
    7daa:	bx	lr

00007dac <SdSpiCard::writeStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    7dac:	push	{r3, r4, r5, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7dae:	ldr	r3, [r0, #0]
    7db0:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    7db2:	mov	r5, r1
    7db4:	mov	r4, r0
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7db6:	blx	r3
    7db8:	cmp	r0, #3
    sector <<= 9;
    7dba:	it	ne
    7dbc:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD25, sector)) {
    7dbe:	mov	r2, r5
    7dc0:	movs	r1, #25
    7dc2:	mov	r0, r4
    7dc4:	bl	7992 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7dc8:	cbz	r0, 7dd8 <SdSpiCard::writeStart(unsigned long)+0x2c>
    7dca:	movs	r3, #14
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7dcc:	mov	r0, r4
    7dce:	strb	r3, [r4, #15]
    7dd0:	bl	77d2 <SdSpiCard::spiStop()>
  return false;
    7dd4:	movs	r0, #0
    7dd6:	pop	{r3, r4, r5, pc}
  }
  if (cardCommand(CMD25, sector)) {
    error(SD_CARD_ERROR_CMD25);
    goto fail;
  }
  return true;
    7dd8:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7dda:	pop	{r3, r4, r5, pc}

00007ddc <SdSpiCard::erase(unsigned long, unsigned long)>:
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7ddc:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  csd_t csd;
  if (!readCSD(&csd)) {
    7dde:	ldr	r3, [r0, #0]
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7de0:	mov	r6, r1
  csd_t csd;
  if (!readCSD(&csd)) {
    7de2:	ldr	r3, [r3, #60]	; 0x3c
    7de4:	mov	r1, sp
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7de6:	mov	r4, r0
    7de8:	mov	r5, r2
  csd_t csd;
  if (!readCSD(&csd)) {
    7dea:	blx	r3
    7dec:	cbz	r0, 7e54 <SdSpiCard::erase(unsigned long, unsigned long)+0x78>
    goto fail;
  }
  // check for single sector erase
  if (!csd.v1.erase_blk_en) {
    7dee:	ldrb.w	r3, [sp, #10]
    7df2:	lsls	r2, r3, #25
    7df4:	bmi.n	7e10 <SdSpiCard::erase(unsigned long, unsigned long)+0x34>
    // erase size mask
    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
    7df6:	ldrb.w	r2, [sp, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    7dfa:	and.w	r3, r3, #63	; 0x3f
    7dfe:	lsls	r3, r3, #1
    7e00:	orr.w	r3, r3, r2, lsr #7
    7e04:	adds	r2, r5, #1
    7e06:	orrs	r2, r6
    7e08:	tst	r3, r2
    7e0a:	beq.n	7e10 <SdSpiCard::erase(unsigned long, unsigned long)+0x34>
    7e0c:	movs	r3, #39	; 0x27
    7e0e:	b.n	7e52 <SdSpiCard::erase(unsigned long, unsigned long)+0x76>
      // error card can't erase specified area
      error(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    7e10:	ldrb	r3, [r4, #18]
    7e12:	cmp	r3, #3
    firstSector <<= 9;
    7e14:	it	ne
    7e16:	lslne	r6, r6, #9
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
    7e18:	mov	r2, r6
    7e1a:	mov.w	r1, #32
    7e1e:	mov	r0, r4
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
    7e20:	it	ne
    7e22:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD32, firstSector)
    7e24:	bl	7992 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
      || cardCommand(CMD33, lastSector)
      || cardCommand(CMD38, 0)) {
    7e28:	cbnz	r0, 7e5e <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
      || cardCommand(CMD33, lastSector)
    7e2a:	mov	r2, r5
    7e2c:	movs	r1, #33	; 0x21
    7e2e:	mov	r0, r4
    7e30:	bl	7992 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7e34:	mov	r2, r0
    7e36:	cbnz	r0, 7e5e <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
      || cardCommand(CMD38, 0)) {
    7e38:	movs	r1, #38	; 0x26
    7e3a:	mov	r0, r4
    7e3c:	bl	7992 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7e40:	cbnz	r0, 7e5e <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
    error(SD_CARD_ERROR_ERASE);
    goto fail;
  }
  DBG_BEGIN_TIME(DBG_ERASE_BUSY);
  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    7e42:	movw	r1, #10000	; 0x2710
    7e46:	mov	r0, r4
    7e48:	bl	796a <SdSpiCard::waitNotBusy(unsigned short)>
    7e4c:	mov	r5, r0
    7e4e:	cbnz	r0, 7e62 <SdSpiCard::erase(unsigned long, unsigned long)+0x86>
    7e50:	movs	r3, #40	; 0x28
    7e52:	strb	r3, [r4, #15]
  DBG_END_TIME(DBG_ERASE_BUSY);
  spiStop();
  return true;

 fail:
  spiStop();
    7e54:	mov	r0, r4
    7e56:	bl	77d2 <SdSpiCard::spiStop()>
  return false;
    7e5a:	movs	r5, #0
    7e5c:	b.n	7e68 <SdSpiCard::erase(unsigned long, unsigned long)+0x8c>
    7e5e:	movs	r3, #38	; 0x26
    7e60:	b.n	7e52 <SdSpiCard::erase(unsigned long, unsigned long)+0x76>
  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    error(SD_CARD_ERROR_ERASE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_ERASE_BUSY);
  spiStop();
    7e62:	mov	r0, r4
    7e64:	bl	77d2 <SdSpiCard::spiStop()>
  return true;

 fail:
  spiStop();
  return false;
}
    7e68:	mov	r0, r5
    7e6a:	add	sp, #16
    7e6c:	pop	{r4, r5, r6, pc}

00007e6e <SdSpiCard::writeStop()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    7e6e:	push	{r3, r4, r5, lr}
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7e70:	mov.w	r1, #600	; 0x258
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    7e74:	mov	r4, r0
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7e76:	bl	796a <SdSpiCard::waitNotBusy(unsigned short)>
    7e7a:	mov	r5, r0
    7e7c:	cbz	r0, 7e88 <SdSpiCard::writeStop()+0x1a>
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_STOP);
  spiSend(STOP_TRAN_TOKEN);
    7e7e:	movs	r1, #253	; 0xfd
    7e80:	ldr	r0, [r4, #4]
    7e82:	bl	778c <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    7e86:	b.n	7e8c <SdSpiCard::writeStop()+0x1e>
    7e88:	movs	r3, #30
    7e8a:	strb	r3, [r4, #15]
  spiStop();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
    7e8c:	mov	r0, r4
    7e8e:	bl	77d2 <SdSpiCard::spiStop()>
  return false;
}
    7e92:	mov	r0, r5
    7e94:	pop	{r3, r4, r5, pc}

00007e96 <SdSpiCard::writeData(unsigned char, unsigned char const*)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one sector of data for write sector or write multiple sectors
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    7e96:	push	{r3, r4, r5, lr}
    7e98:	mov	r4, r0
#if USE_SD_CRC
  uint16_t crc = CRC_CCITT(src, 512);
#else  // USE_SD_CRC
  uint16_t crc = 0XFFFF;
#endif  // USE_SD_CRC
  spiSend(token);
    7e9a:	ldr	r0, [r0, #4]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one sector of data for write sector or write multiple sectors
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    7e9c:	mov	r5, r2
#if USE_SD_CRC
  uint16_t crc = CRC_CCITT(src, 512);
#else  // USE_SD_CRC
  uint16_t crc = 0XFFFF;
#endif  // USE_SD_CRC
  spiSend(token);
    7e9e:	bl	778c <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    7ea2:	ldr	r0, [r4, #4]
  }
  void spiSend(uint8_t data) {
    m_spiDriverPtr->send(data);
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
    7ea4:	ldr	r3, [r0, #0]
    7ea6:	mov.w	r2, #512	; 0x200
    7eaa:	ldr	r3, [r3, #24]
    7eac:	mov	r1, r5
    7eae:	blx	r3
  spiSend(src, 512);
  spiSend(crc >> 8);
    7eb0:	movs	r1, #255	; 0xff
    7eb2:	ldr	r0, [r4, #4]
    7eb4:	bl	778c <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
  spiSend(crc & 0XFF);
    7eb8:	movs	r1, #255	; 0xff
    7eba:	ldr	r0, [r4, #4]
    7ebc:	bl	778c <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>

  m_status = spiReceive();
    7ec0:	ldr	r0, [r4, #4]
    7ec2:	bl	7792 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7ec6:	strb	r0, [r4, #17]
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    7ec8:	and.w	r0, r0, #31
    7ecc:	cmp	r0, #5
    7ece:	beq.n	7ede <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x48>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7ed0:	movs	r3, #32
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7ed2:	mov	r0, r4
    7ed4:	strb	r3, [r4, #15]
    7ed6:	bl	77d2 <SdSpiCard::spiStop()>
  return false;
    7eda:	movs	r0, #0
    7edc:	pop	{r3, r4, r5, pc}
  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    error(SD_CARD_ERROR_WRITE_DATA);
    goto fail;
  }
  return true;
    7ede:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7ee0:	pop	{r3, r4, r5, pc}

00007ee2 <SdSpiCard::writeData(unsigned char const*)>:
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    7ee2:	push	{r3, r4, r5, lr}
    7ee4:	mov	r5, r1
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7ee6:	mov.w	r1, #600	; 0x258
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    7eea:	mov	r4, r0
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7eec:	bl	796a <SdSpiCard::waitNotBusy(unsigned short)>
    7ef0:	cbnz	r0, 7ef8 <SdSpiCard::writeData(unsigned char const*)+0x16>
    7ef2:	movs	r3, #36	; 0x24
    7ef4:	strb	r3, [r4, #15]
    7ef6:	b.n	7f04 <SdSpiCard::writeData(unsigned char const*)+0x22>
    error(SD_CARD_ERROR_WRITE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_BUSY);
  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) {
    7ef8:	mov	r2, r5
    7efa:	movs	r1, #252	; 0xfc
    7efc:	mov	r0, r4
    7efe:	bl	7e96 <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    7f02:	cbnz	r0, 7f0c <SdSpiCard::writeData(unsigned char const*)+0x2a>
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7f04:	mov	r0, r4
    7f06:	bl	77d2 <SdSpiCard::spiStop()>
  return false;
    7f0a:	movs	r0, #0
}
    7f0c:	pop	{r3, r4, r5, pc}

00007f0e <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7f0e:	ldr	r3, [r0, #0]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    7f10:	push	{r4, r5, r6, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7f12:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    7f14:	mov	r5, r1
    7f16:	mov	r4, r0
    7f18:	mov	r6, r2
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7f1a:	blx	r3
    7f1c:	cmp	r0, #3
    sector <<= 9;
    7f1e:	it	ne
    7f20:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD24, sector)) {
    7f22:	mov	r2, r5
    7f24:	movs	r1, #24
    7f26:	mov	r0, r4
    7f28:	bl	7992 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7f2c:	cbz	r0, 7f34 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x26>
    7f2e:	movs	r3, #13
    7f30:	strb	r3, [r4, #15]
    7f32:	b.n	7f4a <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x3c>
    error(SD_CARD_ERROR_CMD24);
    goto fail;
  }
  if (!writeData(DATA_START_SECTOR, src)) {
    7f34:	mov	r2, r6
    7f36:	movs	r1, #254	; 0xfe
    7f38:	mov	r0, r4
    7f3a:	bl	7e96 <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    7f3e:	mov	r5, r0
    7f40:	cbz	r0, 7f4a <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x3c>
    error(SD_CARD_ERROR_CMD13);
    goto fail;
  }
#endif  // CHECK_FLASH_PROGRAMMING

  spiStop();
    7f42:	mov	r0, r4
    7f44:	bl	77d2 <SdSpiCard::spiStop()>
  return true;
    7f48:	b.n	7f52 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x44>

 fail:
  spiStop();
    7f4a:	mov	r0, r4
    7f4c:	bl	77d2 <SdSpiCard::spiStop()>
  return false;
    7f50:	movs	r5, #0
}
    7f52:	mov	r0, r5
    7f54:	pop	{r4, r5, r6, pc}

00007f56 <SdSpiCard::writeSector(unsigned long, unsigned char const*)>:
   *
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    7f56:	push	{r4}
    if (m_sharedSpi) {
    7f58:	ldrb	r4, [r0, #13]
    7f5a:	cbz	r4, 7f64 <SdSpiCard::writeSector(unsigned long, unsigned char const*)+0xe>
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    }
  }
    7f5c:	ldr.w	r4, [sp], #4
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    7f60:	b.w	7f0e <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>
    } else {
      return writeSectors(sector, src, 1);
    7f64:	ldr	r3, [r0, #0]
    7f66:	ldr	r4, [r3, #36]	; 0x24
    7f68:	movs	r3, #1
    7f6a:	mov	ip, r4
    }
  }
    7f6c:	ldr.w	r4, [sp], #4
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    7f70:	bx	ip
    7f72:	Address 0x00007f72 is out of bounds.


00007f74 <sdIrs()>:
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
  SDHC_IRQSIGEN = 0;
    7f74:	ldr	r2, [pc, #24]	; (7f90 <sdIrs()+0x1c>)
  m_irqstat = SDHC_IRQSTAT;
    7f76:	ldr	r1, [pc, #28]	; (7f94 <sdIrs()+0x20>)
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
  SDHC_IRQSIGEN = 0;
    7f78:	movs	r3, #0
    7f7a:	str	r3, [r2, #0]
  m_irqstat = SDHC_IRQSTAT;
    7f7c:	ldr.w	r0, [r2, #-8]
    7f80:	str	r0, [r1, #0]
  SDHC_IRQSTAT = m_irqstat;
    7f82:	ldr	r1, [r1, #0]
    7f84:	str.w	r1, [r2, #-8]
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN);
#endif
  m_dmaBusy = false;
    7f88:	ldr	r2, [pc, #12]	; (7f98 <sdIrs()+0x24>)
    7f8a:	strb	r3, [r2, #0]
    7f8c:	bx	lr
    7f8e:	nop
    7f90:	.word	0x400b1038
    7f94:	.word	0x2001a6c8
    7f98:	.word	0x2001a6dd

00007f9c <isBusyCommandComplete()>:
static bool isBusyCMD13() {
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
}
//------------------------------------------------------------------------------
static bool isBusyCommandComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_CC | SDHC_IRQSTAT_CMD_ERROR));
    7f9c:	ldr	r3, [pc, #12]	; (7fac <isBusyCommandComplete()+0x10>)
    7f9e:	ldr	r0, [pc, #16]	; (7fb0 <isBusyCommandComplete()+0x14>)
    7fa0:	ldr	r3, [r3, #0]
    7fa2:	ands	r0, r3
}
    7fa4:	clz	r0, r0
    7fa8:	lsrs	r0, r0, #5
    7faa:	bx	lr
    7fac:	.word	0x400b1030
    7fb0:	.word	0x000f0001

00007fb4 <isBusyCommandInhibit()>:
//------------------------------------------------------------------------------
static bool isBusyCommandInhibit() {
  return SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB;
    7fb4:	ldr	r3, [pc, #8]	; (7fc0 <isBusyCommandInhibit()+0xc>)
    7fb6:	ldr	r0, [r3, #0]
}
    7fb8:	and.w	r0, r0, #1
    7fbc:	bx	lr
    7fbe:	nop
    7fc0:	.word	0x400b1024

00007fc4 <isBusyDat()>:
//------------------------------------------------------------------------------
static bool isBusyDat() {
  return SDHC_PRSSTAT & (1 << 24) ? false : true;
    7fc4:	ldr	r3, [pc, #12]	; (7fd4 <isBusyDat()+0x10>)
    7fc6:	ldr	r0, [r3, #0]
    7fc8:	eor.w	r0, r0, #16777216	; 0x1000000
}
    7fcc:	ubfx	r0, r0, #24, #1
    7fd0:	bx	lr
    7fd2:	nop
    7fd4:	.word	0x400b1024

00007fd8 <isBusyDMA()>:
//------------------------------------------------------------------------------
static bool isBusyDMA() {
  return m_dmaBusy;
    7fd8:	ldr	r3, [pc, #4]	; (7fe0 <isBusyDMA()+0x8>)
    7fda:	ldrb	r0, [r3, #0]
}
    7fdc:	bx	lr
    7fde:	nop
    7fe0:	.word	0x2001a6dd

00007fe4 <isBusyFifoRead()>:
//------------------------------------------------------------------------------
static bool isBusyFifoRead() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BREN);
    7fe4:	ldr	r3, [pc, #12]	; (7ff4 <isBusyFifoRead()+0x10>)
    7fe6:	ldr	r0, [r3, #0]
    7fe8:	eor.w	r0, r0, #2048	; 0x800
}
    7fec:	ubfx	r0, r0, #11, #1
    7ff0:	bx	lr
    7ff2:	nop
    7ff4:	.word	0x400b1024

00007ff8 <isBusyFifoWrite()>:
//------------------------------------------------------------------------------
static bool isBusyFifoWrite() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN);
    7ff8:	ldr	r3, [pc, #12]	; (8008 <isBusyFifoWrite()+0x10>)
    7ffa:	ldr	r0, [r3, #0]
    7ffc:	eor.w	r0, r0, #1024	; 0x400
}
    8000:	ubfx	r0, r0, #10, #1
    8004:	bx	lr
    8006:	nop
    8008:	.word	0x400b1024

0000800c <isBusyTransferComplete()>:
//------------------------------------------------------------------------------
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
    800c:	ldr	r3, [pc, #12]	; (801c <isBusyTransferComplete()+0x10>)
    800e:	ldr	r0, [pc, #16]	; (8020 <isBusyTransferComplete()+0x14>)
    8010:	ldr	r3, [r3, #0]
    8012:	ands	r0, r3
}
    8014:	clz	r0, r0
    8018:	lsrs	r0, r0, #5
    801a:	bx	lr
    801c:	.word	0x400b1030
    8020:	.word	0x117f0002

00008024 <setSdclk(unsigned long)>:
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    8024:	mov.w	r3, #1000	; 0x3e8
  }
  d[15] = 0;
  return true;
}
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
    8028:	push	{r4, r5, lr}
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    802a:	ldr	r4, [pc, #128]	; (80ac <setSdclk(unsigned long)+0x88>)
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    802c:	muls	r0, r3
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
    802e:	movs	r2, #1
  uint32_t maxSdclk = 1000*kHzMax;
    8030:	movs	r3, #9
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    8032:	lsls	r1, r2, #4
    8034:	udiv	r1, r4, r1
    8038:	cmp	r0, r1
    803a:	bcc.n	8044 <setSdclk(unsigned long)+0x20>
    803c:	movs	r4, #1
    803e:	mov	r3, r2
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    8040:	ldr	r5, [pc, #104]	; (80ac <setSdclk(unsigned long)+0x88>)
    8042:	b.n	8058 <setSdclk(unsigned long)+0x34>
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    8044:	subs	r3, #1
    8046:	beq.n	803c <setSdclk(unsigned long)+0x18>
    sdclkfs <<= 1;
    8048:	lsls	r2, r2, #1
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    804a:	b.n	8032 <setSdclk(unsigned long)+0xe>
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    804c:	cmp	r4, #16
    804e:	add.w	r1, r3, r2
    8052:	beq.n	8060 <setSdclk(unsigned long)+0x3c>
    dvs++;
    8054:	adds	r4, #1
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    8056:	mov	r3, r1
    8058:	udiv	r1, r5, r3
    805c:	cmp	r0, r1
    805e:	bcc.n	804c <setSdclk(unsigned long)+0x28>
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    8060:	mov.w	r1, #1000	; 0x3e8
    8064:	muls	r3, r1
    8066:	ldr	r1, [pc, #68]	; (80ac <setSdclk(unsigned long)+0x88>)
    8068:	udiv	r3, r1, r3
    806c:	ldr	r1, [pc, #64]	; (80b0 <setSdclk(unsigned long)+0x8c>)
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    806e:	ldr	r0, [pc, #68]	; (80b4 <setSdclk(unsigned long)+0x90>)
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    8070:	str	r3, [r1, #0]
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    8072:	ldr	r3, [r0, #0]
    8074:	bic.w	r3, r3, #8
    8078:	str	r3, [r0, #0]
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)

  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
    807a:	ldr	r1, [r0, #0]
                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    807c:	bic.w	r3, r1, #1044480	; 0xff000
    8080:	lsls	r2, r2, #7
    8082:	bic.w	r3, r3, #4080	; 0xff0
    8086:	orr.w	r3, r3, #917504	; 0xe0000
    808a:	and.w	r2, r2, #65280	; 0xff00
    808e:	orrs	r2, r3
    8090:	subs	r3, r4, #1
    8092:	orr.w	r3, r2, r3, lsl #4

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    8096:	ldr	r2, [pc, #32]	; (80b8 <setSdclk(unsigned long)+0x94>)
  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    8098:	str	r3, [r0, #0]

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    809a:	ldr	r3, [r2, #0]
    809c:	lsls	r3, r3, #28
    809e:	bpl.n	809a <setSdclk(unsigned long)+0x76>
  }

#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Enable the SDHC clock.
  SDHC_SYSCTL |= SDHC_SYSCTL_SDCLKEN;
    80a0:	ldr	r3, [r0, #0]
    80a2:	orr.w	r3, r3, #8
    80a6:	str	r3, [r0, #0]
    80a8:	pop	{r4, r5, pc}
    80aa:	nop
    80ac:	.word	0x05b8d800
    80b0:	.word	0x2001a6e0
    80b4:	.word	0x400b102c
    80b8:	.word	0x400b1024

000080bc <SdioCard::errorCode() const>:
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::errorCode() const {
  return m_errorCode;
}
    80bc:	ldr	r3, [pc, #4]	; (80c4 <SdioCard::errorCode() const+0x8>)
    80be:	ldrb	r0, [r3, #0]
    80c0:	bx	lr
    80c2:	nop
    80c4:	.word	0x1fff1338

000080c8 <SdioCard::errorData() const>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorData() const {
  return m_irqstat;
    80c8:	ldr	r3, [pc, #4]	; (80d0 <SdioCard::errorData() const+0x8>)
    80ca:	ldr	r0, [r3, #0]
}
    80cc:	bx	lr
    80ce:	nop
    80d0:	.word	0x2001a6c8

000080d4 <SdioCard::readCID(CID*)>:
uint32_t SdioCard::kHzSdClk() {
  return m_sdClkKhz;
}
//------------------------------------------------------------------------------
bool SdioCard::readCID(cid_t* cid) {
  memcpy(cid, &m_cid, 16);
    80d4:	ldr	r3, [pc, #20]	; (80ec <SdioCard::readCID(CID*)+0x18>)
    80d6:	add.w	r2, r3, #16
    80da:	ldr.w	r0, [r3], #4
    80de:	str.w	r0, [r1], #4
    80e2:	cmp	r3, r2
    80e4:	bne.n	80da <SdioCard::readCID(CID*)+0x6>
  return true;
}
    80e6:	movs	r0, #1
    80e8:	bx	lr
    80ea:	nop
    80ec:	.word	0x2001a6a1

000080f0 <SdioCard::readCSD(csd_t*)>:
//------------------------------------------------------------------------------
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
    80f0:	ldr	r3, [pc, #20]	; (8108 <SdioCard::readCSD(csd_t*)+0x18>)
    80f2:	add.w	r2, r3, #16
    80f6:	ldr.w	r0, [r3], #4
    80fa:	str.w	r0, [r1], #4
    80fe:	cmp	r3, r2
    8100:	bne.n	80f6 <SdioCard::readCSD(csd_t*)+0x6>
  return true;
}
    8102:	movs	r0, #1
    8104:	bx	lr
    8106:	nop
    8108:	.word	0x2001a6cd

0000810c <SdioCard::readOCR(unsigned long*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
    810c:	ldr	r3, [pc, #8]	; (8118 <SdioCard::readOCR(unsigned long*)+0xc>)
    810e:	ldr	r3, [r3, #0]
    8110:	str	r3, [r1, #0]
  return true;
}
    8112:	movs	r0, #1
    8114:	bx	lr
    8116:	nop
    8118:	.word	0x2001a6bc

0000811c <SdioCard::~SdioCard()>:
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    811c:	bx	lr
    811e:	Address 0x0000811e is out of bounds.


00008120 <waitTimeout(bool (*)())>:
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
    8120:	push	{r3, r4, r5, r6, r7, lr}
    8122:	mov	r7, r0
  uint32_t m = micros();
    8124:	bl	9514 <micros>
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    8128:	ldr	r5, [pc, #20]	; (8140 <waitTimeout(bool (*)())+0x20>)
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
  uint32_t m = micros();
    812a:	mov	r6, r0
  while (fcn()) {
    812c:	blx	r7
    812e:	mov	r4, r0
    8130:	cbz	r0, 813c <waitTimeout(bool (*)())+0x1c>
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    8132:	bl	9514 <micros>
    8136:	subs	r0, r0, r6
    8138:	cmp	r0, r5
    813a:	bls.n	812c <waitTimeout(bool (*)())+0xc>
      return true;
    }
  }
  return false;  // Caller will set errorCode.
}
    813c:	mov	r0, r4
    813e:	pop	{r3, r4, r5, r6, r7, pc}
    8140:	.word	0x000f4240

00008144 <yieldTimeout(bool (*)())>:
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    8144:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  m_busyFcn = fcn;
    8148:	ldr	r4, [pc, #48]	; (817c <yieldTimeout(bool (*)())+0x38>)
  uint32_t m = micros();
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    814a:	ldr.w	r8, [pc, #52]	; 8180 <yieldTimeout(bool (*)())+0x3c>
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
  m_busyFcn = fcn;
    814e:	str	r0, [r4, #0]
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    8150:	mov	r6, r0
  m_busyFcn = fcn;
  uint32_t m = micros();
    8152:	bl	9514 <micros>
    8156:	mov	r7, r0
  while (fcn()) {
    8158:	blx	r6
    815a:	mov	r5, r0
    815c:	cbz	r0, 8174 <yieldTimeout(bool (*)())+0x30>
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    815e:	bl	9514 <micros>
    8162:	subs	r0, r0, r7
    8164:	cmp	r0, r8
    8166:	bls.n	816e <yieldTimeout(bool (*)())+0x2a>
      m_busyFcn = 0;
    8168:	movs	r3, #0
    816a:	str	r3, [r4, #0]
      return true;
    816c:	b.n	8176 <yieldTimeout(bool (*)())+0x32>
  }
}
#elif defined(ARDUINO)
inline void SysCall::yield() {
  // Use the external Arduino yield() function.
  ::yield();
    816e:	bl	9f54 <yield>
    8172:	b.n	8158 <yieldTimeout(bool (*)())+0x14>
    }
    SysCall::yield();
  }
  m_busyFcn = 0;
    8174:	str	r0, [r4, #0]
  return false;  // Caller will set errorCode.
}
    8176:	mov	r0, r5
    8178:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    817c:	.word	0x2001a6b4
    8180:	.word	0x000f4240

00008184 <SdioCard::~SdioCard()>:
    8184:	push	{r4, lr}
    8186:	movs	r1, #12
    8188:	mov	r4, r0
    818a:	bl	a3b8 <operator delete(void*, unsigned int)>
    818e:	mov	r0, r4
    8190:	pop	{r4, pc}
    8192:	Address 0x00008192 is out of bounds.


00008194 <SdioCard::type() const>:
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
    8194:	ldr	r3, [pc, #20]	; (81ac <SdioCard::type() const+0x18>)
    8196:	ldrb	r3, [r3, #0]
    8198:	cbz	r3, 81a8 <SdioCard::type() const+0x14>
    819a:	ldr	r3, [pc, #20]	; (81b0 <SdioCard::type() const+0x1c>)
    819c:	ldrb	r3, [r3, #0]
    819e:	cmp	r3, #0
    81a0:	ite	ne
    81a2:	movne	r0, #3
    81a4:	moveq	r0, #2
    81a6:	bx	lr
    81a8:	movs	r0, #1
}
    81aa:	bx	lr
    81ac:	.word	0x2001a6a0
    81b0:	.word	0x2001a6b8

000081b4 <cardCommand(unsigned long, unsigned long)>:
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    81b4:	push	{r3, r4, r5, lr}
    81b6:	mov	r4, r0
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    81b8:	ldr	r0, [pc, #56]	; (81f4 <cardCommand(unsigned long, unsigned long)+0x40>)
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    81ba:	mov	r5, r1
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    81bc:	bl	8120 <waitTimeout(bool (*)())>
    81c0:	cbnz	r0, 81ea <cardCommand(unsigned long, unsigned long)+0x36>
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    81c2:	ldr	r3, [pc, #52]	; (81f8 <cardCommand(unsigned long, unsigned long)+0x44>)
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
  if (waitTimeout(isBusyCommandComplete)) {
    81c4:	ldr	r0, [pc, #52]	; (81fc <cardCommand(unsigned long, unsigned long)+0x48>)
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    81c6:	str	r5, [r3, #0]
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MASK;
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
    81c8:	str	r4, [r3, #4]
  if (waitTimeout(isBusyCommandComplete)) {
    81ca:	bl	8120 <waitTimeout(bool (*)())>
    81ce:	cbnz	r0, 81ea <cardCommand(unsigned long, unsigned long)+0x36>
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
    81d0:	ldr	r2, [pc, #44]	; (8200 <cardCommand(unsigned long, unsigned long)+0x4c>)
    81d2:	ldr	r3, [pc, #48]	; (8204 <cardCommand(unsigned long, unsigned long)+0x50>)
    81d4:	ldr	r1, [r2, #0]
    81d6:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    81d8:	ldr	r1, [r3, #0]
    81da:	str	r1, [r2, #0]

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    81dc:	ldr	r2, [r3, #0]
    81de:	lsls	r2, r2, #31
    81e0:	bpl.n	81ea <cardCommand(unsigned long, unsigned long)+0x36>
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
    81e2:	ldr	r3, [r3, #0]
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    81e4:	tst.w	r3, #983040	; 0xf0000
    81e8:	beq.n	81ee <cardCommand(unsigned long, unsigned long)+0x3a>
    81ea:	movs	r0, #0
    81ec:	pop	{r3, r4, r5, pc}
    81ee:	movs	r0, #1
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
    81f0:	pop	{r3, r4, r5, pc}
    81f2:	nop
    81f4:	.word	0x00007fb5
    81f8:	.word	0x400b1008
    81fc:	.word	0x00007f9d
    8200:	.word	0x400b1030
    8204:	.word	0x2001a6c8

00008208 <statusCMD13()>:
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
  }
}
//------------------------------------------------------------------------------
static uint32_t statusCMD13() {
    8208:	push	{r3, lr}
  return cardCommand(CMD13_XFERTYP, m_rca) ? SDHC_CMDRSP0 : 0;
    820a:	ldr	r3, [pc, #16]	; (821c <statusCMD13()+0x14>)
    820c:	ldr	r0, [pc, #16]	; (8220 <statusCMD13()+0x18>)
    820e:	ldr	r1, [r3, #0]
    8210:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    8214:	cbz	r0, 821a <statusCMD13()+0x12>
    8216:	ldr	r3, [pc, #12]	; (8224 <statusCMD13()+0x1c>)
    8218:	ldr	r0, [r3, #0]
}
    821a:	pop	{r3, pc}
    821c:	.word	0x2001a6c0
    8220:	.word	0x0d1a0000
    8224:	.word	0x400b1010

00008228 <isBusyCMD13()>:
//------------------------------------------------------------------------------
static bool isBusyCMD13() {
    8228:	push	{r3, lr}
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
    822a:	bl	8208 <statusCMD13()>
    822e:	eor.w	r0, r0, #256	; 0x100
}
    8232:	ubfx	r0, r0, #8, #1
    8236:	pop	{r3, pc}

00008238 <SdioCard::status()>:
uint32_t SdioCard::sectorCount() {
  return sdCardCapacity(&m_csd);
}
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
    8238:	b.w	8208 <statusCMD13()>

0000823c <readReg16(unsigned long, void*)>:
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    823c:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    823e:	ldr	r3, [pc, #80]	; (8290 <readReg16(unsigned long, void*)+0x54>)
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    8240:	mov	r5, r1
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    8242:	ldr	r1, [r3, #0]
    8244:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    8248:	cbz	r0, 828a <readReg16(unsigned long, void*)+0x4e>
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
    824a:	ldr	r3, [pc, #72]	; (8294 <readReg16(unsigned long, void*)+0x58>)
    824c:	ldr	r3, [r3, #0]
    824e:	str	r3, [sp, #0]
    8250:	ldr	r3, [pc, #68]	; (8298 <readReg16(unsigned long, void*)+0x5c>)
    8252:	ldr	r3, [r3, #0]
    8254:	str	r3, [sp, #4]
    8256:	ldr	r3, [pc, #68]	; (829c <readReg16(unsigned long, void*)+0x60>)
    8258:	ldr	r3, [r3, #0]
    825a:	str	r3, [sp, #8]
    825c:	ldr	r3, [pc, #64]	; (82a0 <readReg16(unsigned long, void*)+0x64>)
    825e:	ldr	r3, [r3, #0]
    8260:	str	r3, [sp, #12]
    8262:	add.w	r6, r5, #15
  for (int i = 0; i < 15; i++) {
    8266:	movs	r3, #0
    d[14 - i] = sr[i/4] >> 8*(i%4);
    8268:	bic.w	r4, r3, #3
    826c:	add	r2, sp, #16
    826e:	add	r4, r2
    8270:	and.w	r2, r3, #3
    8274:	lsls	r1, r2, #3
    8276:	ldr.w	r2, [r4, #-16]
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    827a:	adds	r3, #1
    d[14 - i] = sr[i/4] >> 8*(i%4);
    827c:	lsrs	r2, r1
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    827e:	cmp	r3, #15
    d[14 - i] = sr[i/4] >> 8*(i%4);
    8280:	strb.w	r2, [r6, #-1]!
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    8284:	bne.n	8268 <readReg16(unsigned long, void*)+0x2c>
    d[14 - i] = sr[i/4] >> 8*(i%4);
  }
  d[15] = 0;
    8286:	movs	r3, #0
    8288:	strb	r3, [r5, #15]
  return true;
}
    828a:	add	sp, #16
    828c:	pop	{r4, r5, r6, pc}
    828e:	nop
    8290:	.word	0x2001a6c0
    8294:	.word	0x400b1010
    8298:	.word	0x400b1014
    829c:	.word	0x400b1018
    82a0:	.word	0x400b101c

000082a4 <waitDmaStatus() [clone .part.4]>:
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    return false;  // Caller will set errorCode.
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    82a4:	ldr	r3, [pc, #20]	; (82bc <waitDmaStatus() [clone .part.4]+0x18>)
    82a6:	ldr	r0, [r3, #0]
    82a8:	ands.w	r0, r0, #2
    82ac:	beq.n	82ba <waitDmaStatus() [clone .part.4]+0x16>
    82ae:	ldr	r3, [r3, #0]
    82b0:	ldr	r0, [pc, #12]	; (82c0 <waitDmaStatus() [clone .part.4]+0x1c>)
    82b2:	ands	r0, r3
    82b4:	clz	r0, r0
    82b8:	lsrs	r0, r0, #5
}
    82ba:	bx	lr
    82bc:	.word	0x2001a6c8
    82c0:	.word	0x117f0000

000082c4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>:
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
}
//------------------------------------------------------------------------------
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
    82c4:	push	{r3, r4, r5, r6, r7, lr}
    82c6:	mov	r4, r3
  if ((3 & (uint32_t)buf) || n == 0) {
    82c8:	lsls	r3, r2, #30
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
}
//------------------------------------------------------------------------------
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
    82ca:	mov	r7, r0
    82cc:	mov	r5, r1
    82ce:	mov	r6, r2
  if ((3 & (uint32_t)buf) || n == 0) {
    82d0:	bne.n	82d4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x10>
    82d2:	cbnz	r4, 82e0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x1c>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    82d4:	ldr	r3, [pc, #100]	; (833c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x78>)
    82d6:	movs	r2, #37	; 0x25
    82d8:	strb	r2, [r3, #0]
  m_errorLine = line;
    82da:	mov.w	r2, #506	; 0x1fa
    82de:	b.n	82f2 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x2e>
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    82e0:	ldr	r0, [pc, #92]	; (8340 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x7c>)
    82e2:	bl	8144 <yieldTimeout(bool (*)())>
    82e6:	cbz	r0, 82f8 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x34>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    82e8:	ldr	r3, [pc, #80]	; (833c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x78>)
    82ea:	movs	r2, #10
    82ec:	strb	r2, [r3, #0]
  m_errorLine = line;
    82ee:	movw	r2, #509	; 0x1fd
    82f2:	ldr	r3, [pc, #80]	; (8344 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x80>)
    82f4:	str	r2, [r3, #0]
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    82f6:	b.n	8336 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    82f8:	ldr	r3, [pc, #76]	; (8348 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x84>)
    82fa:	movs	r2, #1
    82fc:	strb	r2, [r3, #0]
  m_irqstat = 0;
    82fe:	ldr	r3, [pc, #76]	; (834c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x88>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    8300:	ldr	r2, [pc, #76]	; (8350 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x8c>)
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    8302:	str	r0, [r3, #0]
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    8304:	lsls	r4, r4, #16
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    8306:	ldr	r3, [pc, #76]	; (8354 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x90>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    8308:	orr.w	r4, r4, #512	; 0x200
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    830c:	str	r6, [r3, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    830e:	str	r4, [r3, #4]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    8310:	str	r2, [r3, #56]	; 0x38
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    8312:	ldr	r3, [pc, #68]	; (8358 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x94>)
    8314:	ldrb	r3, [r3, #0]
    8316:	cbnz	r3, 831c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x58>
    8318:	lsls	r1, r5, #9
    831a:	b.n	831e <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x5a>
    831c:	mov	r1, r5
    831e:	mov	r0, r7
    8320:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    8324:	cbz	r0, 8336 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    8326:	ldr	r0, [pc, #52]	; (835c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x98>)
    8328:	bl	8144 <yieldTimeout(bool (*)())>
    832c:	cbnz	r0, 8336 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    return false;
  }
  return waitDmaStatus();
}
    832e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    8332:	b.w	82a4 <waitDmaStatus() [clone .part.4]>
    8336:	movs	r0, #0
    8338:	pop	{r3, r4, r5, r6, r7, pc}
    833a:	nop
    833c:	.word	0x1fff1338
    8340:	.word	0x00008229
    8344:	.word	0x2001a6e4
    8348:	.word	0x2001a6dd
    834c:	.word	0x2001a6c8
    8350:	.word	0x117f0002
    8354:	.word	0x400b1000
    8358:	.word	0x2001a6b8
    835c:	.word	0x00007fd9

00008360 <SdioCard::sectorCount()>:
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    8360:	ldr	r2, [pc, #92]	; (83c0 <SdioCard::sectorCount()+0x60>)
    8362:	ldrb	r3, [r2, #0]
    8364:	ands.w	r3, r3, #192	; 0xc0
    8368:	bne.n	839e <SdioCard::sectorCount()+0x3e>
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    836a:	ldrb	r0, [r2, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    836c:	ldrb	r3, [r2, #7]
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    836e:	ldrb	r1, [r2, #10]
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    8370:	and.w	r0, r0, #3
    8374:	lsls	r3, r3, #2
    8376:	orr.w	r3, r3, r0, lsl #10
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    837a:	ldrb	r0, [r2, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    837c:	orr.w	r0, r3, r0, lsr #6
    8380:	adds	r3, r0, #1
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    8382:	ldrb	r0, [r2, #9]
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    8384:	ldrb	r2, [r2, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    8386:	and.w	r0, r0, #3
    838a:	lsls	r0, r0, #1
    838c:	orr.w	r0, r0, r1, lsr #7
    8390:	and.w	r2, r2, #15
    8394:	add	r0, r2
    8396:	subs	r0, #7
    8398:	lsl.w	r0, r3, r0
    839c:	bx	lr
  } else if (csd->v2.csd_ver == 1) {
    839e:	cmp	r3, #64	; 0x40
    83a0:	bne.n	83ba <SdioCard::sectorCount()+0x5a>
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    83a2:	ldrb	r0, [r2, #9]
    83a4:	adds	r3, r0, #1
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    83a6:	ldrb	r0, [r2, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    83a8:	and.w	r0, r0, #63	; 0x3f
    83ac:	add.w	r0, r3, r0, lsl #16
    83b0:	ldrb	r3, [r2, #8]
    83b2:	add.w	r0, r0, r3, lsl #8
    83b6:	lsls	r0, r0, #10
    83b8:	bx	lr
  } else {
    return 0;
    83ba:	movs	r0, #0
  return transferStop();
}
//------------------------------------------------------------------------------
uint32_t SdioCard::sectorCount() {
  return sdCardCapacity(&m_csd);
}
    83bc:	bx	lr
    83be:	nop
    83c0:	.word	0x2001a6cd

000083c4 <SdioCard::erase(unsigned long, unsigned long)>:
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    83c4:	push	{r4, r5, r6, lr}
    83c6:	mov	r6, r2
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    83c8:	ldrb	r2, [r0, #9]
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    83ca:	mov	r5, r1
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    83cc:	cbz	r2, 83da <SdioCard::erase(unsigned long, unsigned long)+0x16>
    83ce:	ldr	r3, [r0, #0]
    83d0:	ldr	r3, [r3, #28]
    83d2:	blx	r3
    83d4:	mov	r4, r0
    83d6:	cmp	r0, #0
    83d8:	beq.n	8476 <SdioCard::erase(unsigned long, unsigned long)+0xb2>
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  // check for single sector erase
  if (!m_csd.v1.erase_blk_en) {
    83da:	ldr	r1, [pc, #160]	; (847c <SdioCard::erase(unsigned long, unsigned long)+0xb8>)
    83dc:	ldrb	r3, [r1, #10]
    83de:	and.w	r2, r3, #64	; 0x40
    83e2:	and.w	r4, r2, #255	; 0xff
    83e6:	cbnz	r2, 8408 <SdioCard::erase(unsigned long, unsigned long)+0x44>
    // erase size mask
    uint8_t m = (m_csd.v1.sector_size_high << 1) | m_csd.v1.sector_size_low;
    83e8:	ldrb	r2, [r1, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    83ea:	and.w	r3, r3, #63	; 0x3f
    83ee:	lsls	r3, r3, #1
    83f0:	orr.w	r3, r3, r2, lsr #7
    83f4:	adds	r2, r6, #1
    83f6:	orrs	r2, r5
    83f8:	tst	r3, r2
    83fa:	beq.n	8408 <SdioCard::erase(unsigned long, unsigned long)+0x44>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    83fc:	ldr	r3, [pc, #128]	; (8480 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    83fe:	movs	r2, #39	; 0x27
    8400:	strb	r2, [r3, #0]
  m_errorLine = line;
    8402:	movw	r2, #747	; 0x2eb
    8406:	b.n	8458 <SdioCard::erase(unsigned long, unsigned long)+0x94>
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
      // error card can't erase specified area
      return sdError(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
    }
  }
  if (!m_highCapacity) {
    8408:	ldr	r3, [pc, #120]	; (8484 <SdioCard::erase(unsigned long, unsigned long)+0xc0>)
    840a:	ldrb	r3, [r3, #0]
    840c:	cbnz	r3, 8412 <SdioCard::erase(unsigned long, unsigned long)+0x4e>
    firstSector <<= 9;
    840e:	lsls	r5, r5, #9
    lastSector <<= 9;
    8410:	lsls	r6, r6, #9
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    8412:	mov	r1, r5
    8414:	ldr	r0, [pc, #112]	; (8488 <SdioCard::erase(unsigned long, unsigned long)+0xc4>)
    8416:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    841a:	mov	r4, r0
    841c:	cbnz	r0, 842a <SdioCard::erase(unsigned long, unsigned long)+0x66>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    841e:	ldr	r3, [pc, #96]	; (8480 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    8420:	movs	r2, #15
    8422:	strb	r2, [r3, #0]
  m_errorLine = line;
    8424:	movw	r2, #755	; 0x2f3
    8428:	b.n	8458 <SdioCard::erase(unsigned long, unsigned long)+0x94>
    lastSector <<= 9;
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
    842a:	mov	r1, r6
    842c:	ldr	r0, [pc, #92]	; (848c <SdioCard::erase(unsigned long, unsigned long)+0xc8>)
    842e:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    8432:	mov	r4, r0
    8434:	cbnz	r0, 8442 <SdioCard::erase(unsigned long, unsigned long)+0x7e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8436:	ldr	r3, [pc, #72]	; (8480 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    8438:	movs	r2, #16
    843a:	strb	r2, [r3, #0]
  m_errorLine = line;
    843c:	movw	r2, #758	; 0x2f6
    8440:	b.n	8458 <SdioCard::erase(unsigned long, unsigned long)+0x94>
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    8442:	movs	r1, #0
    8444:	ldr	r0, [pc, #72]	; (8490 <SdioCard::erase(unsigned long, unsigned long)+0xcc>)
    8446:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    844a:	mov	r4, r0
    844c:	cbnz	r0, 845e <SdioCard::erase(unsigned long, unsigned long)+0x9a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    844e:	ldr	r3, [pc, #48]	; (8480 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    8450:	movs	r2, #17
    8452:	strb	r2, [r3, #0]
  m_errorLine = line;
    8454:	movw	r2, #761	; 0x2f9
    8458:	ldr	r3, [pc, #56]	; (8494 <SdioCard::erase(unsigned long, unsigned long)+0xd0>)
    845a:	str	r2, [r3, #0]
    845c:	b.n	8476 <SdioCard::erase(unsigned long, unsigned long)+0xb2>
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    845e:	ldr	r0, [pc, #56]	; (8498 <SdioCard::erase(unsigned long, unsigned long)+0xd4>)
    8460:	bl	8120 <waitTimeout(bool (*)())>
    8464:	cbz	r0, 8476 <SdioCard::erase(unsigned long, unsigned long)+0xb2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8466:	ldr	r3, [pc, #24]	; (8480 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    8468:	movs	r2, #40	; 0x28
    846a:	strb	r2, [r3, #0]
  m_errorLine = line;
    846c:	ldr	r3, [pc, #36]	; (8494 <SdioCard::erase(unsigned long, unsigned long)+0xd0>)
    846e:	mov.w	r2, #764	; 0x2fc
    8472:	str	r2, [r3, #0]
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
    8474:	movs	r4, #0
  }
  return true;
}
    8476:	mov	r0, r4
    8478:	pop	{r4, r5, r6, pc}
    847a:	nop
    847c:	.word	0x2001a6cd
    8480:	.word	0x1fff1338
    8484:	.word	0x2001a6b8
    8488:	.word	0x201a0000
    848c:	.word	0x211a0000
    8490:	.word	0x261b0000
    8494:	.word	0x2001a6e4
    8498:	.word	0x00008229

0000849c <waitTransferComplete()>:
  }
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
    849c:	push	{r4, lr}
  if (!m_transferActive) {
    849e:	ldr	r4, [pc, #60]	; (84dc <waitTransferComplete()+0x40>)
    84a0:	ldrb	r3, [r4, #0]
    84a2:	cbnz	r3, 84a8 <waitTransferComplete()+0xc>
    return true;
    84a4:	movs	r0, #1
    84a6:	pop	{r4, pc}
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
    84a8:	ldr	r0, [pc, #52]	; (84e0 <waitTransferComplete()+0x44>)
    84aa:	bl	8120 <waitTimeout(bool (*)())>
  m_transferActive = false;
    84ae:	movs	r3, #0
  m_irqstat = SDHC_IRQSTAT;
    84b0:	ldr	r2, [pc, #48]	; (84e4 <waitTransferComplete()+0x48>)
static bool waitTransferComplete() {
  if (!m_transferActive) {
    return true;
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
    84b2:	strb	r3, [r4, #0]
  m_irqstat = SDHC_IRQSTAT;
    84b4:	ldr	r3, [pc, #48]	; (84e8 <waitTransferComplete()+0x4c>)
    84b6:	ldr	r1, [r2, #0]
    84b8:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    84ba:	ldr	r1, [r3, #0]
    84bc:	str	r1, [r2, #0]
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    84be:	cbnz	r0, 84ca <waitTransferComplete()+0x2e>
    84c0:	ldr	r2, [r3, #0]
    84c2:	ldr	r3, [pc, #40]	; (84ec <waitTransferComplete()+0x50>)
    84c4:	ands	r3, r2
    84c6:	cmp	r3, #0
    84c8:	beq.n	84a4 <waitTransferComplete()+0x8>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    84ca:	ldr	r3, [pc, #36]	; (84f0 <waitTransferComplete()+0x54>)
    84cc:	movs	r2, #31
    84ce:	strb	r2, [r3, #0]
  m_errorLine = line;
    84d0:	ldr	r3, [pc, #32]	; (84f4 <waitTransferComplete()+0x58>)
    84d2:	movw	r2, #641	; 0x281
    84d6:	str	r2, [r3, #0]
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    return sdError(SD_CARD_ERROR_TRANSFER_COMPLETE);
    84d8:	movs	r0, #0
  }
  return true;
}
    84da:	pop	{r4, pc}
    84dc:	.word	0x2001a6c4
    84e0:	.word	0x0000800d
    84e4:	.word	0x400b1030
    84e8:	.word	0x2001a6c8
    84ec:	.word	0x117f0000
    84f0:	.word	0x1fff1338
    84f4:	.word	0x2001a6e4

000084f8 <SdioCard::readStop()>:
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
    84f8:	push	{r4, r5, r6, lr}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    84fa:	ldr	r4, [pc, #100]	; (8560 <SdioCard::readStop()+0x68>)
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    84fc:	ldr	r0, [pc, #100]	; (8564 <SdioCard::readStop()+0x6c>)
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    84fe:	ldr	r3, [r4, #0]
    8500:	bic.w	r3, r3, #65536	; 0x10000
    8504:	str	r3, [r4, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    8506:	movs	r1, #0
    8508:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    850c:	mov	r5, r0
    850e:	cbnz	r0, 8520 <SdioCard::readStop()+0x28>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8510:	ldr	r3, [pc, #84]	; (8568 <SdioCard::readStop()+0x70>)
    8512:	movs	r2, #9
    8514:	strb	r2, [r3, #0]
  m_errorLine = line;
    8516:	ldr	r3, [pc, #84]	; (856c <SdioCard::readStop()+0x74>)
    8518:	movw	r2, #578	; 0x242
    851c:	str	r2, [r3, #0]
    851e:	b.n	855a <SdioCard::readStop()+0x62>
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    8520:	ldr	r0, [pc, #76]	; (8570 <SdioCard::readStop()+0x78>)
    8522:	bl	8144 <yieldTimeout(bool (*)())>
    8526:	cbz	r0, 853a <SdioCard::readStop()+0x42>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8528:	ldr	r3, [pc, #60]	; (8568 <SdioCard::readStop()+0x70>)
    852a:	movs	r2, #10
    852c:	strb	r2, [r3, #0]
  m_errorLine = line;
    852e:	ldr	r3, [pc, #60]	; (856c <SdioCard::readStop()+0x74>)
    8530:	movw	r2, #582	; 0x246
    8534:	str	r2, [r3, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    return sdError(SD_CARD_ERROR_CMD13);
    8536:	movs	r5, #0
    8538:	b.n	855a <SdioCard::readStop()+0x62>
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    853a:	ldr	r3, [pc, #56]	; (8574 <SdioCard::readStop()+0x7c>)
    853c:	ldr	r3, [r3, #0]
    853e:	lsls	r3, r3, #30
    8540:	bpl.n	855a <SdioCard::readStop()+0x62>
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    8542:	ldr	r1, [pc, #52]	; (8578 <SdioCard::readStop()+0x80>)
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    8544:	ldr	r0, [pc, #52]	; (857c <SdioCard::readStop()+0x84>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    8546:	ldr	r6, [r1, #0]
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    8548:	ldr	r3, [r4, #0]
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    854a:	ldr	r2, [r0, #0]
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    854c:	bic.w	r3, r3, #65536	; 0x10000
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    8550:	orr.w	r2, r2, #67108864	; 0x4000000
    8554:	str	r2, [r0, #0]
    // Restore registers.
    SDHC_IRQSTATEN = irqsststen;
    8556:	str	r6, [r1, #0]
    SDHC_PROCTL = proctl;
    8558:	str	r3, [r4, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
}
    855a:	mov	r0, r5
    855c:	pop	{r4, r5, r6, pc}
    855e:	nop
    8560:	.word	0x400b1028
    8564:	.word	0x0cdb0000
    8568:	.word	0x1fff1338
    856c:	.word	0x2001a6e4
    8570:	.word	0x00007fc5
    8574:	.word	0x400b1024
    8578:	.word	0x400b1034
    857c:	.word	0x400b102c

00008580 <SdioCard::writeData(unsigned char const*)>:
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
}
//------------------------------------------------------------------------------
bool SdioCard::writeData(const uint8_t* src) {
    8580:	push	{r4, r5, r6, lr}
    8582:	mov	r4, r1
  DBG_IRQSTAT();
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    8584:	bl	849c <waitTransferComplete()>
    8588:	mov	r6, r0
    858a:	cmp	r0, #0
    858c:	beq.n	85f4 <SdioCard::writeData(unsigned char const*)+0x74>
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    858e:	ldr	r5, [pc, #104]	; (85f8 <SdioCard::writeData(unsigned char const*)+0x78>)
    8590:	ldr	r3, [r5, #0]
    8592:	tst.w	r3, #256	; 0x100
    8596:	ldr	r3, [pc, #100]	; (85fc <SdioCard::writeData(unsigned char const*)+0x7c>)
    8598:	bne.n	85aa <SdioCard::writeData(unsigned char const*)+0x2a>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    859a:	ldr	r2, [r3, #0]
    859c:	bic.w	r2, r2, #65536	; 0x10000
    85a0:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    85a2:	ldr	r2, [r3, #0]
    85a4:	orr.w	r2, r2, #131072	; 0x20000
    85a8:	str	r2, [r3, #0]
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    85aa:	ldr	r2, [r3, #0]
  if (waitTimeout(isBusyFifoWrite)) {
    85ac:	ldr	r0, [pc, #80]	; (8600 <SdioCard::writeData(unsigned char const*)+0x80>)
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    85ae:	orr.w	r2, r2, #65536	; 0x10000
    85b2:	str	r2, [r3, #0]
  if (waitTimeout(isBusyFifoWrite)) {
    85b4:	bl	8120 <waitTimeout(bool (*)())>
    85b8:	cbnz	r0, 85e4 <SdioCard::writeData(unsigned char const*)+0x64>
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    85ba:	ldr	r1, [pc, #72]	; (8604 <SdioCard::writeData(unsigned char const*)+0x84>)
    85bc:	subs	r3, r4, #4
    85be:	add.w	r4, r4, #508	; 0x1fc
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    85c2:	ldr	r2, [r5, #0]
    85c4:	lsls	r2, r2, #21
    85c6:	bpl.n	85c2 <SdioCard::writeData(unsigned char const*)+0x42>
    85c8:	add.w	r2, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    85cc:	ldr.w	r0, [r3, #4]!
    85d0:	str	r0, [r1, #0]
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    85d2:	cmp	r2, r3
    85d4:	bne.n	85cc <SdioCard::writeData(unsigned char const*)+0x4c>
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    85d6:	cmp	r4, r2
    85d8:	mov	r3, r2
    85da:	bne.n	85c2 <SdioCard::writeData(unsigned char const*)+0x42>
      SDHC_DATPORT = p32[i];
    }
    p32 += FIFO_WML;
  }
#if ENABLE_TEENSY_SDIO_MOD
  m_transferActive = true;
    85dc:	ldr	r3, [pc, #40]	; (8608 <SdioCard::writeData(unsigned char const*)+0x88>)
    85de:	movs	r2, #1
    85e0:	strb	r2, [r3, #0]
    85e2:	b.n	85f4 <SdioCard::writeData(unsigned char const*)+0x74>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    85e4:	ldr	r3, [pc, #36]	; (860c <SdioCard::writeData(unsigned char const*)+0x8c>)
    85e6:	movs	r2, #33	; 0x21
    85e8:	strb	r2, [r3, #0]
  m_errorLine = line;
    85ea:	ldr	r3, [pc, #36]	; (8610 <SdioCard::writeData(unsigned char const*)+0x90>)
    85ec:	movw	r2, #1015	; 0x3f7
    85f0:	str	r2, [r3, #0]
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
    85f2:	movs	r6, #0
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    85f4:	mov	r0, r6
    85f6:	pop	{r4, r5, r6, pc}
    85f8:	.word	0x400b1024
    85fc:	.word	0x400b1028
    8600:	.word	0x00007ff9
    8604:	.word	0x400b1020
    8608:	.word	0x2001a6c4
    860c:	.word	0x1fff1338
    8610:	.word	0x2001a6e4

00008614 <SdioCard::writeStart(unsigned long)>:
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    8614:	push	{r4, lr}
  if (yieldTimeout(isBusyCMD13)) {
    8616:	ldr	r0, [pc, #80]	; (8668 <SdioCard::writeStart(unsigned long)+0x54>)
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    8618:	mov	r4, r1
  if (yieldTimeout(isBusyCMD13)) {
    861a:	bl	8144 <yieldTimeout(bool (*)())>
    861e:	cbz	r0, 8632 <SdioCard::writeStart(unsigned long)+0x1e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8620:	ldr	r3, [pc, #72]	; (866c <SdioCard::writeStart(unsigned long)+0x58>)
    8622:	movs	r2, #10
    8624:	strb	r2, [r3, #0]
  m_errorLine = line;
    8626:	ldr	r3, [pc, #72]	; (8670 <SdioCard::writeStart(unsigned long)+0x5c>)
    8628:	movw	r2, #1119	; 0x45f
    862c:	str	r2, [r3, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    862e:	movs	r0, #0
    8630:	pop	{r4, pc}
  }
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8632:	ldr	r2, [pc, #64]	; (8674 <SdioCard::writeStart(unsigned long)+0x60>)
    8634:	ldr	r3, [r2, #0]
    8636:	bic.w	r3, r3, #65536	; 0x10000
    863a:	str	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    863c:	ldr	r3, [pc, #56]	; (8678 <SdioCard::writeStart(unsigned long)+0x64>)
    863e:	ldr	r2, [pc, #60]	; (867c <SdioCard::writeStart(unsigned long)+0x68>)
    8640:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    8642:	ldr	r3, [pc, #60]	; (8680 <SdioCard::writeStart(unsigned long)+0x6c>)
    8644:	ldrb	r3, [r3, #0]
    8646:	cbnz	r3, 864c <SdioCard::writeStart(unsigned long)+0x38>
    8648:	lsls	r1, r4, #9
    864a:	b.n	864e <SdioCard::writeStart(unsigned long)+0x3a>
    864c:	mov	r1, r4
    864e:	ldr	r0, [pc, #52]	; (8684 <SdioCard::writeStart(unsigned long)+0x70>)
    8650:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    8654:	cbnz	r0, 8664 <SdioCard::writeStart(unsigned long)+0x50>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8656:	ldr	r3, [pc, #20]	; (866c <SdioCard::writeStart(unsigned long)+0x58>)
    8658:	movs	r2, #14
    865a:	strb	r2, [r3, #0]
  m_errorLine = line;
    865c:	ldr	r3, [pc, #16]	; (8670 <SdioCard::writeStart(unsigned long)+0x5c>)
    865e:	movw	r2, #1131	; 0x46b
    8662:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
    8664:	pop	{r4, pc}
    8666:	nop
    8668:	.word	0x00008229
    866c:	.word	0x1fff1338
    8670:	.word	0x2001a6e4
    8674:	.word	0x400b1028
    8678:	.word	0x400b1004
    867c:	.word	0xffff0200
    8680:	.word	0x2001a6b8
    8684:	.word	0x193a0022

00008688 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    8688:	push	{r3, r4, r5, r6, r7, lr}
    868a:	mov	r7, r0
    868c:	mov	r4, r1
  if (m_sdioConfig.useDma()) {
    868e:	ldrb	r6, [r7, #8]
    8690:	lsls	r6, r6, #31
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    8692:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    8694:	bpl.n	86d2 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x4a>
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
    8696:	lsls	r6, r2, #30
    8698:	beq.n	86ba <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x32>
    869a:	adds	r6, r1, r3
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    869c:	cmp	r4, r6
    869e:	beq.n	86f0 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
        if (!writeSector(sector, ptr)) {
    86a0:	ldr	r3, [r7, #0]
    86a2:	mov	r2, r5
    86a4:	ldr	r3, [r3, #32]
    86a6:	mov	r1, r4
    86a8:	mov	r0, r7
    86aa:	blx	r3
    86ac:	cbnz	r0, 86b2 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2a>
          return false;  // writeSector will set errorCode.
    86ae:	movs	r0, #0
    86b0:	pop	{r3, r4, r5, r6, r7, pc}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    86b2:	adds	r4, #1
    86b4:	add.w	r5, r5, #512	; 0x200
    86b8:	b.n	869c <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x14>
          return false;  // writeSector will set errorCode.
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
    86ba:	ldr	r0, [pc, #56]	; (86f4 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x6c>)
    86bc:	bl	82c4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    86c0:	cbnz	r0, 86f0 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    86c2:	ldr	r3, [pc, #52]	; (86f8 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x70>)
    86c4:	movs	r2, #14
    86c6:	strb	r2, [r3, #0]
  m_errorLine = line;
    86c8:	ldr	r3, [pc, #48]	; (86fc <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x74>)
    86ca:	movw	r2, #1105	; 0x451
    86ce:	str	r2, [r3, #0]
    86d0:	pop	{r3, r4, r5, r6, r7, pc}
    86d2:	adds	r6, r1, r3
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
      return sdError(SD_CARD_ERROR_CMD25);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    86d4:	cmp	r4, r6
    86d6:	beq.n	86f0 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
      if (!writeSector(sector + i, src + i*512UL)) {
    86d8:	ldr	r3, [r7, #0]
    86da:	mov	r2, r5
    86dc:	mov	r1, r4
    86de:	ldr	r3, [r3, #32]
    86e0:	mov	r0, r7
    86e2:	blx	r3
    86e4:	adds	r4, #1
    86e6:	add.w	r5, r5, #512	; 0x200
    86ea:	cmp	r0, #0
    86ec:	bne.n	86d4 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x4c>
    86ee:	b.n	86ae <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x26>
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
        if (!writeSector(sector, ptr)) {
          return false;  // writeSector will set errorCode.
        }
      }
      return true;
    86f0:	movs	r0, #1
        return false;
      }
    }
  }
  return true;
}
    86f2:	pop	{r3, r4, r5, r6, r7, pc}
    86f4:	.word	0x193a0027
    86f8:	.word	0x1fff1338
    86fc:	.word	0x2001a6e4

00008700 <SdioCard::writeSector(unsigned long, unsigned char const*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    8700:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    8702:	ldrb	r3, [r0, #8]
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    8704:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    8706:	lsls	r2, r3, #31
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    8708:	sub.w	sp, sp, #512	; 0x200
    870c:	mov	r4, r0
    870e:	mov	r6, r1
  if (m_sdioConfig.useDma()) {
    8710:	bpl.n	8744 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x44>
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
    8712:	lsls	r3, r5, #30
    8714:	beq.n	8724 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x24>
      ptr = aligned;
      memcpy(aligned, src, 512);
    8716:	mov	r1, r5
    8718:	mov.w	r2, #512	; 0x200
    871c:	mov	r0, sp
    871e:	bl	8f14 <memcpy>
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
      ptr = aligned;
    8722:	mov	r5, sp
      memcpy(aligned, src, 512);
    } else {
      ptr = const_cast<uint8_t*>(src);
    }
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
    8724:	movs	r3, #1
    8726:	mov	r2, r5
    8728:	mov	r1, r6
    872a:	ldr	r0, [pc, #132]	; (87b0 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb0>)
    872c:	bl	82c4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    8730:	cmp	r0, #0
    8732:	bne.n	87a8 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8734:	ldr	r3, [pc, #124]	; (87b4 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb4>)
    8736:	movs	r2, #13
    8738:	strb	r2, [r3, #0]
  m_errorLine = line;
    873a:	ldr	r3, [pc, #124]	; (87b8 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb8>)
    873c:	movw	r2, #1049	; 0x419
    8740:	str	r2, [r3, #0]
    8742:	b.n	87a8 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD24);
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    8744:	bl	849c <waitTransferComplete()>
    8748:	cbnz	r0, 874e <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4e>
      return false;
    874a:	movs	r0, #0
    874c:	b.n	87a8 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    874e:	ldr	r3, [pc, #108]	; (87bc <SdioCard::writeSector(unsigned long, unsigned char const*)+0xbc>)
    8750:	ldr	r3, [r3, #0]
    8752:	lsrs	r3, r3, #16
    8754:	lsls	r3, r3, #16
    8756:	cbz	r3, 8760 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x60>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    8758:	ldrb	r3, [r4, #9]
    875a:	cmp	r3, #2
    875c:	bne.n	8774 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x74>
    875e:	b.n	876e <SdioCard::writeSector(unsigned long, unsigned char const*)+0x6e>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    8760:	ldr	r3, [r4, #0]
    8762:	mov	r0, r4
    8764:	ldr	r3, [r3, #28]
    8766:	blx	r3
    8768:	cmp	r0, #0
    876a:	bne.n	8758 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x58>
    876c:	b.n	874a <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    876e:	ldr	r3, [r4, #4]
    8770:	cmp	r6, r3
    8772:	beq.n	8794 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x94>
      if (!syncDevice()) {
    8774:	ldr	r3, [r4, #0]
    8776:	mov	r0, r4
    8778:	ldr	r3, [r3, #28]
    877a:	blx	r3
    877c:	cmp	r0, #0
    877e:	beq.n	874a <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
      if (!writeStart(sector )) {
    8780:	ldr	r3, [r4, #0]
    8782:	mov	r1, r6
    8784:	ldr	r3, [r3, #80]	; 0x50
    8786:	mov	r0, r4
    8788:	blx	r3
    878a:	cmp	r0, #0
    878c:	beq.n	874a <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
      m_curSector = sector;
      m_curState = WRITE_STATE;
    878e:	movs	r3, #2
        return false;
      }
      if (!writeStart(sector )) {
        return false;
      }
      m_curSector = sector;
    8790:	str	r6, [r4, #4]
      m_curState = WRITE_STATE;
    8792:	strb	r3, [r4, #9]
    }
    if (!writeData(src)) {
    8794:	ldr	r3, [r4, #0]
    8796:	mov	r1, r5
    8798:	ldr	r3, [r3, #76]	; 0x4c
    879a:	mov	r0, r4
    879c:	blx	r3
    879e:	cmp	r0, #0
    87a0:	beq.n	874a <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
      return false;
    }
    m_curSector++;
    87a2:	ldr	r3, [r4, #4]
    87a4:	adds	r3, #1
    87a6:	str	r3, [r4, #4]
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
    87a8:	add.w	sp, sp, #512	; 0x200
    87ac:	pop	{r4, r5, r6, pc}
    87ae:	nop
    87b0:	.word	0x183a0001
    87b4:	.word	0x1fff1338
    87b8:	.word	0x2001a6e4
    87bc:	.word	0x400b1004

000087c0 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    87c0:	push	{r3, r4, r5, r6, r7, lr}
    87c2:	mov	r7, r0
    87c4:	mov	r4, r1
  if (m_sdioConfig.useDma()) {
    87c6:	ldrb	r6, [r7, #8]
    87c8:	lsls	r6, r6, #31
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    87ca:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    87cc:	bpl.n	880a <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4a>
    if ((uint32_t)dst & 3) {
    87ce:	lsls	r6, r2, #30
    87d0:	beq.n	87f2 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x32>
    87d2:	adds	r6, r1, r3
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    87d4:	cmp	r4, r6
    87d6:	beq.n	8828 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
        if (!readSector(sector, dst)) {
    87d8:	ldr	r3, [r7, #0]
    87da:	mov	r2, r5
    87dc:	ldr	r3, [r3, #12]
    87de:	mov	r1, r4
    87e0:	mov	r0, r7
    87e2:	blx	r3
    87e4:	cbnz	r0, 87ea <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x2a>
          return false;  // readSector will set errorCode.
    87e6:	movs	r0, #0
    87e8:	pop	{r3, r4, r5, r6, r7, pc}
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
  if (m_sdioConfig.useDma()) {
    if ((uint32_t)dst & 3) {
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    87ea:	adds	r4, #1
    87ec:	add.w	r5, r5, #512	; 0x200
    87f0:	b.n	87d4 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x14>
          return false;  // readSector will set errorCode.
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
    87f2:	ldr	r0, [pc, #56]	; (882c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x6c>)
    87f4:	bl	82c4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    87f8:	cbnz	r0, 8828 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    87fa:	ldr	r3, [pc, #52]	; (8830 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x70>)
    87fc:	movs	r2, #12
    87fe:	strb	r2, [r3, #0]
  m_errorLine = line;
    8800:	ldr	r3, [pc, #48]	; (8834 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x74>)
    8802:	mov.w	r2, #912	; 0x390
    8806:	str	r2, [r3, #0]
    8808:	pop	{r3, r4, r5, r6, r7, pc}
    880a:	adds	r6, r1, r3
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
      return sdError(SD_CARD_ERROR_CMD18);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    880c:	cmp	r4, r6
    880e:	beq.n	8828 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
      if (!readSector(sector + i, dst + i*512UL)) {
    8810:	ldr	r3, [r7, #0]
    8812:	mov	r2, r5
    8814:	mov	r1, r4
    8816:	ldr	r3, [r3, #12]
    8818:	mov	r0, r7
    881a:	blx	r3
    881c:	adds	r4, #1
    881e:	add.w	r5, r5, #512	; 0x200
    8822:	cmp	r0, #0
    8824:	bne.n	880c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4c>
    8826:	b.n	87e6 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x26>
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
        if (!readSector(sector, dst)) {
          return false;  // readSector will set errorCode.
        }
      }
      return true;
    8828:	movs	r0, #1
        return false;
      }
    }
  }
  return true;
}
    882a:	pop	{r3, r4, r5, r6, r7, pc}
    882c:	.word	0x123a0037
    8830:	.word	0x1fff1338
    8834:	.word	0x2001a6e4

00008838 <cardCMD6(unsigned long, unsigned char*)>:

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    8838:	push	{r3, r4, r5, lr}
    883a:	mov	r4, r0
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    883c:	ldr	r0, [pc, #104]	; (88a8 <cardCMD6(unsigned long, unsigned char*)+0x70>)

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    883e:	mov	r5, r1
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    8840:	bl	8120 <waitTimeout(bool (*)())>
    8844:	cbz	r0, 8852 <cardCMD6(unsigned long, unsigned char*)+0x1a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8846:	ldr	r3, [pc, #100]	; (88ac <cardCMD6(unsigned long, unsigned char*)+0x74>)
    8848:	movs	r2, #10
    884a:	strb	r2, [r3, #0]
  m_errorLine = line;
    884c:	movw	r2, #413	; 0x19d
    8850:	b.n	8894 <cardCMD6(unsigned long, unsigned char*)+0x5c>
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    8852:	ldr	r3, [pc, #92]	; (88b0 <cardCMD6(unsigned long, unsigned char*)+0x78>)
    8854:	movs	r2, #1
    8856:	strb	r2, [r3, #0]
  m_irqstat = 0;
    8858:	ldr	r3, [pc, #88]	; (88b4 <cardCMD6(unsigned long, unsigned char*)+0x7c>)
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    885a:	ldr	r2, [pc, #92]	; (88b8 <cardCMD6(unsigned long, unsigned char*)+0x80>)
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    885c:	str	r0, [r3, #0]
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    885e:	ldr	r3, [pc, #92]	; (88bc <cardCMD6(unsigned long, unsigned char*)+0x84>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    8860:	ldr	r0, [pc, #92]	; (88c0 <cardCMD6(unsigned long, unsigned char*)+0x88>)
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    8862:	str	r5, [r3, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    8864:	str	r2, [r3, #4]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    8866:	ldr	r2, [pc, #92]	; (88c4 <cardCMD6(unsigned long, unsigned char*)+0x8c>)
    8868:	str	r2, [r3, #56]	; 0x38
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    886a:	mov	r1, r4
    886c:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    8870:	cbnz	r0, 8882 <cardCMD6(unsigned long, unsigned char*)+0x4a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8872:	ldr	r3, [pc, #56]	; (88ac <cardCMD6(unsigned long, unsigned char*)+0x74>)
    8874:	movs	r2, #4
    8876:	strb	r2, [r3, #0]
  m_errorLine = line;
    8878:	ldr	r3, [pc, #76]	; (88c8 <cardCMD6(unsigned long, unsigned char*)+0x90>)
    887a:	mov.w	r2, #420	; 0x1a4
    887e:	str	r2, [r3, #0]
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
    8880:	pop	{r3, r4, r5, pc}
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    8882:	ldr	r0, [pc, #72]	; (88cc <cardCMD6(unsigned long, unsigned char*)+0x94>)
    8884:	bl	8144 <yieldTimeout(bool (*)())>
    8888:	cbz	r0, 889c <cardCMD6(unsigned long, unsigned char*)+0x64>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    888a:	ldr	r3, [pc, #32]	; (88ac <cardCMD6(unsigned long, unsigned char*)+0x74>)
    888c:	movs	r2, #37	; 0x25
    888e:	strb	r2, [r3, #0]
  m_errorLine = line;
    8890:	movw	r2, #423	; 0x1a7
    8894:	ldr	r3, [pc, #48]	; (88c8 <cardCMD6(unsigned long, unsigned char*)+0x90>)
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    return sdError(SD_CARD_ERROR_DMA);
    8896:	movs	r0, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8898:	str	r2, [r3, #0]
    889a:	pop	{r3, r4, r5, pc}
    889c:	bl	82a4 <waitDmaStatus() [clone .part.4]>
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    88a0:	cmp	r0, #0
    88a2:	beq.n	888a <cardCMD6(unsigned long, unsigned char*)+0x52>
    return sdError(SD_CARD_ERROR_DMA);
  }
  return true;
}
    88a4:	pop	{r3, r4, r5, pc}
    88a6:	nop
    88a8:	.word	0x00008229
    88ac:	.word	0x1fff1338
    88b0:	.word	0x2001a6dd
    88b4:	.word	0x2001a6c8
    88b8:	.word	0x00010040
    88bc:	.word	0x400b1000
    88c0:	.word	0x063a0011
    88c4:	.word	0x117f0002
    88c8:	.word	0x2001a6e4
    88cc:	.word	0x00007fd9

000088d0 <SdioCard::begin(SdioConfig)>:
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    88d0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    88d4:	ldr	r4, [pc, #712]	; (8ba0 <SdioCard::begin(SdioConfig)+0x2d0>)
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    88d6:	ldr	r2, [pc, #716]	; (8ba4 <SdioCard::begin(SdioConfig)+0x2d4>)
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
    88d8:	ldr.w	ip, [pc, #828]	; 8c18 <SdioCard::begin(SdioConfig)+0x348>
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    88dc:	ldr.w	lr, [pc, #828]	; 8c1c <SdioCard::begin(SdioConfig)+0x34c>
  m_version2 = false;
    88e0:	ldr.w	sl, [pc, #828]	; 8c20 <SdioCard::begin(SdioConfig)+0x350>
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
    88e4:	strb	r1, [r0, #8]
  m_curState = IDLE_STATE;
    88e6:	movs	r3, #0
    88e8:	strb	r3, [r0, #9]
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    88ea:	strb	r3, [r4, #0]
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
    88ec:	strb.w	r3, [ip]
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    88f0:	strb.w	r3, [lr]
  m_version2 = false;
    88f4:	strb.w	r3, [sl]
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    88f8:	ldr	r3, [r2, #0]
  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    88fa:	ldr	r0, [pc, #684]	; (8ba8 <SdioCard::begin(SdioConfig)+0x2d8>)
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    88fc:	ldr	r5, [pc, #684]	; (8bac <SdioCard::begin(SdioConfig)+0x2dc>)
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    88fe:	ldr	r6, [pc, #688]	; (8bb0 <SdioCard::begin(SdioConfig)+0x2e0>)
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8900:	ldr	r7, [pc, #688]	; (8bb4 <SdioCard::begin(SdioConfig)+0x2e4>)
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8902:	ldr.w	r8, [pc, #800]	; 8c24 <SdioCard::begin(SdioConfig)+0x354>
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    8906:	ldr	r1, [pc, #688]	; (8bb8 <SdioCard::begin(SdioConfig)+0x2e8>)
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    8908:	orr.w	r3, r3, #201326592	; 0xc000000
    890c:	str	r3, [r2, #0]
#endif  // HAS_KINETIS_MPU
  // Enable SDHC clock.
  SIM_SCGC3 |= SIM_SCGC3_SDHC;
    890e:	add.w	r2, r2, #239616	; 0x3a800
    8912:	adds	r2, #48	; 0x30
    8914:	ldr	r3, [r2, #0]
    8916:	orr.w	r3, r3, #131072	; 0x20000
    891a:	str	r3, [r2, #0]
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    891c:	ldr	r2, [pc, #668]	; (8bbc <SdioCard::begin(SdioConfig)+0x2ec>)
    891e:	movw	r3, #259	; 0x103
    8922:	str	r3, [r2, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8924:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8926:	str	r3, [r6, #0]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8928:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    892a:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    892e:	str	r3, [r0, #0]
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    8930:	ldr	r3, [r1, #0]
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    8932:	sub	sp, #84	; 0x54
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    8934:	orr.w	r3, r3, #16777216	; 0x1000000
    8938:	orr.w	r3, r3, #32768	; 0x8000
    893c:	str	r3, [r1, #0]
    893e:	mov	r9, r0
    8940:	str.w	ip, [sp, #4]
    8944:	str.w	lr, [sp, #8]
    8948:	mov	fp, r1

  while (SDHC_SYSCTL & SDHC_SYSCTL_RSTA) {
    894a:	ldr.w	r1, [fp]
    894e:	ldr	r3, [pc, #616]	; (8bb8 <SdioCard::begin(SdioConfig)+0x2e8>)
    8950:	lsls	r1, r1, #7
    8952:	bmi.n	894a <SdioCard::begin(SdioConfig)+0x7a>
  }

  // Set initial SCK rate.
  setSdclk(SD_MAX_INIT_RATE_KHZ);
    8954:	mov.w	r0, #400	; 0x190
    8958:	str	r3, [sp, #0]
    895a:	str	r2, [sp, #12]
    895c:	bl	8024 <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8960:	ldr	r2, [sp, #12]
    8962:	movw	r1, #1091	; 0x443
    8966:	str	r1, [r2, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8968:	mov.w	r2, #1088	; 0x440
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    896c:	str	r1, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    896e:	str	r2, [r6, #0]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    8970:	ldr	r2, [pc, #588]	; (8bc0 <SdioCard::begin(SdioConfig)+0x2f0>)
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8972:	str	r1, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8974:	str.w	r1, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8978:	str.w	r1, [r9]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    897c:	ldr	r1, [pc, #580]	; (8bc4 <SdioCard::begin(SdioConfig)+0x2f4>)
    897e:	str	r1, [r2, #0]

  attachInterruptVector(IRQ_SDHC, sdIrs);
    8980:	movs	r0, #81	; 0x51
    8982:	ldr	r1, [pc, #580]	; (8bc8 <SdioCard::begin(SdioConfig)+0x2f8>)
    8984:	bl	9430 <attachInterruptVector>
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    8988:	ldr	r2, [pc, #576]	; (8bcc <SdioCard::begin(SdioConfig)+0x2fc>)
    898a:	movs	r1, #96	; 0x60
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    898c:	mvn.w	r0, #840	; 0x348

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    8990:	strb	r1, [r2, #0]
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    8992:	add	r2, r0

  // Send 80 clocks to card.
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    8994:	ldr	r3, [sp, #0]
  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    8996:	mov.w	r1, #131072	; 0x20000
    899a:	str	r1, [r2, #0]

  // Send 80 clocks to card.
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    899c:	ldr	r2, [r3, #0]
    899e:	orr.w	r2, r2, #134217728	; 0x8000000
    89a2:	str	r2, [r3, #0]
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
    89a4:	ldr.w	r1, [fp]
    89a8:	ands.w	r1, r1, #134217728	; 0x8000000
    89ac:	bne.n	89a4 <SdioCard::begin(SdioConfig)+0xd4>
  m_highCapacity = false;
  m_version2 = false;

  // initialize controller.
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    89ae:	mov	r0, r1
    89b0:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    89b4:	mov	fp, r0
    89b6:	cbnz	r0, 89c2 <SdioCard::begin(SdioConfig)+0xf2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    89b8:	movs	r3, #1
    89ba:	strb	r3, [r4, #0]
  m_errorLine = line;
    89bc:	movw	r2, #662	; 0x296
    89c0:	b.n	8a6a <SdioCard::begin(SdioConfig)+0x19a>
    89c2:	mov.w	fp, #3
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
    89c6:	mov.w	r1, #426	; 0x1aa
    89ca:	ldr	r0, [pc, #516]	; (8bd0 <SdioCard::begin(SdioConfig)+0x300>)
    89cc:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    89d0:	cbz	r0, 89ee <SdioCard::begin(SdioConfig)+0x11e>
      if (SDHC_CMDRSP0 != 0X1AA) {
    89d2:	ldr	r3, [pc, #512]	; (8bd4 <SdioCard::begin(SdioConfig)+0x304>)
    89d4:	ldr	r3, [r3, #0]
    89d6:	cmp.w	r3, #426	; 0x1aa
    89da:	beq.n	89e6 <SdioCard::begin(SdioConfig)+0x116>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    89dc:	movs	r3, #6
    89de:	strb	r3, [r4, #0]
  m_errorLine = line;
    89e0:	mov.w	r2, #668	; 0x29c
    89e4:	b.n	8b06 <SdioCard::begin(SdioConfig)+0x236>
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
      if (SDHC_CMDRSP0 != 0X1AA) {
        return sdError(SD_CARD_ERROR_CMD8);
      }
      m_version2 = true;
    89e6:	movs	r3, #1
    89e8:	strb.w	r3, [sl]
      break;
    89ec:	b.n	89f4 <SdioCard::begin(SdioConfig)+0x124>
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    89ee:	subs.w	fp, fp, #1
    89f2:	bne.n	89c6 <SdioCard::begin(SdioConfig)+0xf6>
      }
      m_version2 = true;
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
    89f4:	ldrb.w	r3, [sl]
    89f8:	cmp	r3, #0
    89fa:	ldr	r3, [pc, #476]	; (8bd8 <SdioCard::begin(SdioConfig)+0x308>)
    89fc:	ite	eq
    89fe:	moveq.w	fp, #3145728	; 0x300000
    8a02:	movne	fp, r3
  int m = micros();
    8a04:	bl	9514 <micros>
    8a08:	str	r0, [sp, #0]
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    8a0a:	movs	r1, #0
    8a0c:	ldr	r0, [pc, #460]	; (8bdc <SdioCard::begin(SdioConfig)+0x30c>)
    8a0e:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    8a12:	cmp	r0, #0
    8a14:	beq.n	8af4 <SdioCard::begin(SdioConfig)+0x224>
    8a16:	mov	r1, fp
    8a18:	ldr	r0, [pc, #452]	; (8be0 <SdioCard::begin(SdioConfig)+0x310>)
    8a1a:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    8a1e:	cmp	r0, #0
    8a20:	beq.n	8af4 <SdioCard::begin(SdioConfig)+0x224>
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
    8a22:	bl	9514 <micros>
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
    8a26:	ldr	r3, [sp, #0]
    8a28:	subs	r0, r0, r3
    8a2a:	ldr	r3, [pc, #440]	; (8be4 <SdioCard::begin(SdioConfig)+0x314>)
    8a2c:	cmp	r0, r3
    8a2e:	bhi.n	8af4 <SdioCard::begin(SdioConfig)+0x224>
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
    8a30:	ldr	r3, [pc, #416]	; (8bd4 <SdioCard::begin(SdioConfig)+0x304>)
    8a32:	ldr.w	sl, [pc, #416]	; 8bd4 <SdioCard::begin(SdioConfig)+0x304>
    8a36:	ldr	r3, [r3, #0]
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    8a38:	cmp	r3, #0
    8a3a:	bge.n	8a0a <SdioCard::begin(SdioConfig)+0x13a>
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
    8a3c:	ldr	r2, [pc, #424]	; (8be8 <SdioCard::begin(SdioConfig)+0x318>)
    8a3e:	ldr.w	r1, [sl]
    8a42:	str	r1, [r2, #0]
  if (SDHC_CMDRSP0 & 0x40000000) {
    8a44:	ldr.w	r2, [sl]
    // Is high capacity.
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    8a48:	ldr	r0, [pc, #416]	; (8bec <SdioCard::begin(SdioConfig)+0x31c>)
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    8a4a:	lsls	r2, r2, #1
    // Is high capacity.
    m_highCapacity = true;
    8a4c:	itt	mi
    8a4e:	ldrmi	r3, [sp, #8]
    8a50:	movmi	r2, #1
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    8a52:	mov.w	r1, #0
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    // Is high capacity.
    m_highCapacity = true;
    8a56:	it	mi
    8a58:	strbmi	r2, [r3, #0]
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    8a5a:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    8a5e:	mov	fp, r0
    8a60:	cbnz	r0, 8a70 <SdioCard::begin(SdioConfig)+0x1a0>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8a62:	movs	r3, #2
    8a64:	strb	r3, [r4, #0]
  m_errorLine = line;
    8a66:	mov.w	r2, #688	; 0x2b0
    8a6a:	ldr	r3, [pc, #388]	; (8bf0 <SdioCard::begin(SdioConfig)+0x320>)
    8a6c:	str	r2, [r3, #0]
  if (SDHC_CMDRSP0 & 0x40000000) {
    // Is high capacity.
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD2);
    8a6e:	b.n	8b96 <SdioCard::begin(SdioConfig)+0x2c6>
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    8a70:	movs	r1, #0
    8a72:	ldr	r0, [pc, #384]	; (8bf4 <SdioCard::begin(SdioConfig)+0x324>)
    8a74:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    8a78:	mov	fp, r0
    8a7a:	cbnz	r0, 8a86 <SdioCard::begin(SdioConfig)+0x1b6>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8a7c:	movs	r3, #3
    8a7e:	strb	r3, [r4, #0]
  m_errorLine = line;
    8a80:	movw	r2, #691	; 0x2b3
    8a84:	b.n	8a6a <SdioCard::begin(SdioConfig)+0x19a>
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    8a86:	ldr.w	r3, [sl]
    8a8a:	ldr.w	sl, [pc, #412]	; 8c28 <SdioCard::begin(SdioConfig)+0x358>

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    8a8e:	ldr	r1, [pc, #360]	; (8bf8 <SdioCard::begin(SdioConfig)+0x328>)
    8a90:	ldr	r0, [pc, #360]	; (8bfc <SdioCard::begin(SdioConfig)+0x32c>)
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    8a92:	lsrs	r3, r3, #16
    8a94:	lsls	r3, r3, #16
    8a96:	str.w	r3, [sl]

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    8a9a:	bl	823c <readReg16(unsigned long, void*)>
    8a9e:	mov	fp, r0
    8aa0:	cbnz	r0, 8aac <SdioCard::begin(SdioConfig)+0x1dc>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8aa2:	movs	r3, #7
    8aa4:	strb	r3, [r4, #0]
  m_errorLine = line;
    8aa6:	mov.w	r2, #696	; 0x2b8
    8aaa:	b.n	8a6a <SdioCard::begin(SdioConfig)+0x19a>
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    return sdError(SD_CARD_ERROR_CMD9);
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    8aac:	ldr	r1, [pc, #336]	; (8c00 <SdioCard::begin(SdioConfig)+0x330>)
    8aae:	ldr	r0, [pc, #340]	; (8c04 <SdioCard::begin(SdioConfig)+0x334>)
    8ab0:	bl	823c <readReg16(unsigned long, void*)>
    8ab4:	mov	fp, r0
    8ab6:	cbnz	r0, 8ac2 <SdioCard::begin(SdioConfig)+0x1f2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8ab8:	movs	r3, #8
    8aba:	strb	r3, [r4, #0]
  m_errorLine = line;
    8abc:	movw	r2, #699	; 0x2bb
    8ac0:	b.n	8a6a <SdioCard::begin(SdioConfig)+0x19a>
    return sdError(SD_CARD_ERROR_CMD9);
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    return sdError(SD_CARD_ERROR_CMD10);
  }
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    8ac2:	ldr.w	r1, [sl]
    8ac6:	ldr	r0, [pc, #320]	; (8c08 <SdioCard::begin(SdioConfig)+0x338>)
    8ac8:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    8acc:	mov	fp, r0
    8ace:	cbnz	r0, 8ada <SdioCard::begin(SdioConfig)+0x20a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8ad0:	movs	r3, #5
    8ad2:	strb	r3, [r4, #0]
  m_errorLine = line;
    8ad4:	movw	r2, #702	; 0x2be
    8ad8:	b.n	8a6a <SdioCard::begin(SdioConfig)+0x19a>
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    8ada:	ldr.w	r1, [sl]
    8ade:	ldr	r0, [pc, #252]	; (8bdc <SdioCard::begin(SdioConfig)+0x30c>)
    8ae0:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    8ae4:	cbz	r0, 8afe <SdioCard::begin(SdioConfig)+0x22e>
    8ae6:	movs	r1, #2
    8ae8:	ldr	r0, [pc, #288]	; (8c0c <SdioCard::begin(SdioConfig)+0x33c>)
    8aea:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    8aee:	mov	fp, r0
    8af0:	cbz	r0, 8afe <SdioCard::begin(SdioConfig)+0x22e>
    8af2:	b.n	8b10 <SdioCard::begin(SdioConfig)+0x240>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8af4:	movs	r3, #23
    8af6:	strb	r3, [r4, #0]
  m_errorLine = line;
    8af8:	movw	r2, #679	; 0x2a7
    8afc:	b.n	8b06 <SdioCard::begin(SdioConfig)+0x236>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8afe:	movs	r3, #20
    8b00:	strb	r3, [r4, #0]
  m_errorLine = line;
    8b02:	movw	r2, #706	; 0x2c2
    8b06:	ldr	r3, [pc, #232]	; (8bf0 <SdioCard::begin(SdioConfig)+0x320>)
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
  }
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
    8b08:	mov.w	fp, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8b0c:	str	r2, [r3, #0]
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
  }
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
    8b0e:	b.n	8b96 <SdioCard::begin(SdioConfig)+0x2c6>
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
    8b10:	ldr	r3, [pc, #252]	; (8c10 <SdioCard::begin(SdioConfig)+0x340>)
    8b12:	ldr	r2, [r3, #0]
    8b14:	bic.w	r2, r2, #6
    8b18:	str	r2, [r3, #0]
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);
    8b1a:	ldr	r2, [r3, #0]
    8b1c:	orr.w	r2, r2, #2
    8b20:	str	r2, [r3, #0]

  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);
    8b22:	mov.w	r2, #1048592	; 0x100010
    8b26:	str	r2, [r3, #28]

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8b28:	add	r1, sp, #16
    8b2a:	mvn.w	r0, #4278190080	; 0xff000000
    8b2e:	bl	8838 <cardCMD6(unsigned long, unsigned char*)>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    8b32:	cbz	r0, 8b3c <SdioCard::begin(SdioConfig)+0x26c>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8b34:	ldrb.w	r3, [sp, #29]
    8b38:	lsls	r3, r3, #30
    8b3a:	bmi.n	8b42 <SdioCard::begin(SdioConfig)+0x272>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    kHzSdClk = 50000;
  } else {
    kHzSdClk = 25000;
    8b3c:	movw	r0, #25000	; 0x61a8
    8b40:	b.n	8b5e <SdioCard::begin(SdioConfig)+0x28e>

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    8b42:	add	r1, sp, #16
    8b44:	ldr	r0, [pc, #204]	; (8c14 <SdioCard::begin(SdioConfig)+0x344>)
    8b46:	bl	8838 <cardCMD6(unsigned long, unsigned char*)>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8b4a:	cmp	r0, #0
    8b4c:	beq.n	8b3c <SdioCard::begin(SdioConfig)+0x26c>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    8b4e:	ldrb.w	r3, [sp, #32]
    8b52:	and.w	r3, r3, #15
    8b56:	cmp	r3, #1
    8b58:	bne.n	8b3c <SdioCard::begin(SdioConfig)+0x26c>
    kHzSdClk = 50000;
    8b5a:	movw	r0, #50000	; 0xc350
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8b5e:	ldr	r4, [pc, #92]	; (8bbc <SdioCard::begin(SdioConfig)+0x2ec>)
    8b60:	movw	r3, #259	; 0x103
    8b64:	str	r3, [r4, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8b66:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8b68:	str	r3, [r6, #0]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8b6a:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8b6c:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8b70:	str.w	r3, [r9]
  }
  // Disable GPIO.
  enableGPIO(false);

  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);
    8b74:	bl	8024 <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8b78:	movw	r3, #1091	; 0x443
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8b7c:	mov.w	r2, #1088	; 0x440
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8b80:	str	r3, [r4, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8b82:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8b84:	str	r2, [r6, #0]
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    8b86:	ldr	r2, [sp, #4]
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8b88:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8b8a:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8b8e:	str.w	r3, [r9]
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    8b92:	movs	r3, #1
    8b94:	strb	r3, [r2, #0]
  return true;
}
    8b96:	mov	r0, fp
    8b98:	add	sp, #84	; 0x54
    8b9a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8b9e:	nop
    8ba0:	.word	0x1fff1338
    8ba4:	.word	0x4000d800
    8ba8:	.word	0x4004d014
    8bac:	.word	0x4004d004
    8bb0:	.word	0x4004d008
    8bb4:	.word	0x4004d00c
    8bb8:	.word	0x400b102c
    8bbc:	.word	0x4004d000
    8bc0:	.word	0x400b1034
    8bc4:	.word	0x117f000b
    8bc8:	.word	0x00007f75
    8bcc:	.word	0xe000e451
    8bd0:	.word	0x081a0000
    8bd4:	.word	0x400b1010
    8bd8:	.word	0x40300000
    8bdc:	.word	0x371a0000
    8be0:	.word	0x29020000
    8be4:	.word	0x000f4240
    8be8:	.word	0x2001a6bc
    8bec:	.word	0x02090000
    8bf0:	.word	0x2001a6e4
    8bf4:	.word	0x031a0000
    8bf8:	.word	0x2001a6cd
    8bfc:	.word	0x09090000
    8c00:	.word	0x2001a6a1
    8c04:	.word	0x0a090000
    8c08:	.word	0x071b0000
    8c0c:	.word	0x061a0000
    8c10:	.word	0x400b1028
    8c14:	.word	0x80fffff1
    8c18:	.word	0x2001a6cc
    8c1c:	.word	0x2001a6b8
    8c20:	.word	0x2001a6a0
    8c24:	.word	0x4004d010
    8c28:	.word	0x2001a6c0

00008c2c <SdioCard::readData(unsigned char*)>:
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    8c2c:	push	{r3, r4, r5, lr}
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    8c2e:	ldr	r5, [pc, #152]	; (8cc8 <SdioCard::readData(unsigned char*)+0x9c>)
    8c30:	ldr	r3, [r5, #0]
    8c32:	lsls	r3, r3, #22
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    8c34:	mov	r4, r1
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    8c36:	bmi.n	8c56 <SdioCard::readData(unsigned char*)+0x2a>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8c38:	ldr	r3, [pc, #144]	; (8ccc <SdioCard::readData(unsigned char*)+0xa0>)
    8c3a:	ldr	r2, [r3, #0]
    8c3c:	bic.w	r2, r2, #65536	; 0x10000
    8c40:	str	r2, [r3, #0]
    noInterrupts();
    8c42:	cpsid	i
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    8c44:	ldr	r2, [r3, #0]
    8c46:	orr.w	r2, r2, #131072	; 0x20000
    8c4a:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    8c4c:	ldr	r2, [r3, #0]
    8c4e:	orr.w	r2, r2, #65536	; 0x10000
    8c52:	str	r2, [r3, #0]
    interrupts();
    8c54:	cpsie	i
  }
  if (waitTimeout(isBusyFifoRead)) {
    8c56:	ldr	r0, [pc, #120]	; (8cd0 <SdioCard::readData(unsigned char*)+0xa4>)
    8c58:	bl	8120 <waitTimeout(bool (*)())>
    8c5c:	cbnz	r0, 8cb4 <SdioCard::readData(unsigned char*)+0x88>
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    8c5e:	ldr	r1, [pc, #116]	; (8cd4 <SdioCard::readData(unsigned char*)+0xa8>)
    8c60:	subs	r3, r4, #4
    8c62:	add.w	r4, r4, #508	; 0x1fc
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    8c66:	ldr	r2, [r5, #0]
    8c68:	lsls	r0, r2, #20
    8c6a:	bpl.n	8c66 <SdioCard::readData(unsigned char*)+0x3a>
    8c6c:	add.w	r2, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    8c70:	ldr	r0, [r1, #0]
    8c72:	str.w	r0, [r3, #4]!
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    8c76:	cmp	r2, r3
    8c78:	bne.n	8c70 <SdioCard::readData(unsigned char*)+0x44>
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    8c7a:	cmp	r4, r2
    8c7c:	mov	r3, r2
    8c7e:	bne.n	8c66 <SdioCard::readData(unsigned char*)+0x3a>
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    }
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    8c80:	ldr	r0, [pc, #84]	; (8cd8 <SdioCard::readData(unsigned char*)+0xac>)
    8c82:	bl	8120 <waitTimeout(bool (*)())>
    8c86:	cbz	r0, 8c94 <SdioCard::readData(unsigned char*)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8c88:	ldr	r3, [pc, #80]	; (8cdc <SdioCard::readData(unsigned char*)+0xb0>)
    8c8a:	movs	r2, #29
    8c8c:	strb	r2, [r3, #0]
  m_errorLine = line;
    8c8e:	movw	r2, #846	; 0x34e
    8c92:	b.n	8cbe <SdioCard::readData(unsigned char*)+0x92>
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
    8c94:	ldr	r2, [pc, #72]	; (8ce0 <SdioCard::readData(unsigned char*)+0xb4>)
    8c96:	ldr	r3, [pc, #76]	; (8ce4 <SdioCard::readData(unsigned char*)+0xb8>)
    8c98:	ldr	r1, [r2, #0]
    8c9a:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    8c9c:	ldr	r1, [r3, #0]
    8c9e:	str	r1, [r2, #0]
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    8ca0:	ldr	r2, [r3, #0]
    8ca2:	lsls	r2, r2, #30
    8ca4:	bpl.n	8cc4 <SdioCard::readData(unsigned char*)+0x98>
    8ca6:	ldr	r3, [r3, #0]
    8ca8:	ldr	r0, [pc, #60]	; (8ce8 <SdioCard::readData(unsigned char*)+0xbc>)
    8caa:	ands	r0, r3
    8cac:	clz	r0, r0
    8cb0:	lsrs	r0, r0, #5
    8cb2:	pop	{r3, r4, r5, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8cb4:	ldr	r3, [pc, #36]	; (8cdc <SdioCard::readData(unsigned char*)+0xb0>)
    8cb6:	movs	r2, #26
    8cb8:	strb	r2, [r3, #0]
  m_errorLine = line;
    8cba:	movw	r2, #835	; 0x343
    8cbe:	ldr	r3, [pc, #44]	; (8cec <SdioCard::readData(unsigned char*)+0xc0>)
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
    8cc0:	movs	r0, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8cc2:	str	r2, [r3, #0]
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
    8cc4:	pop	{r3, r4, r5, pc}
    8cc6:	nop
    8cc8:	.word	0x400b1024
    8ccc:	.word	0x400b1028
    8cd0:	.word	0x00007fe5
    8cd4:	.word	0x400b1020
    8cd8:	.word	0x0000800d
    8cdc:	.word	0x1fff1338
    8ce0:	.word	0x400b1030
    8ce4:	.word	0x2001a6c8
    8ce8:	.word	0x117f0000
    8cec:	.word	0x2001a6e4

00008cf0 <SdioCard::readStart(unsigned long)>:
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    8cf0:	push	{r4, lr}
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    8cf2:	ldr	r0, [pc, #80]	; (8d44 <SdioCard::readStart(unsigned long)+0x54>)
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    8cf4:	mov	r4, r1
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    8cf6:	bl	8144 <yieldTimeout(bool (*)())>
    8cfa:	cbz	r0, 8d0e <SdioCard::readStart(unsigned long)+0x1e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8cfc:	ldr	r3, [pc, #72]	; (8d48 <SdioCard::readStart(unsigned long)+0x58>)
    8cfe:	movs	r2, #10
    8d00:	strb	r2, [r3, #0]
  m_errorLine = line;
    8d02:	ldr	r3, [pc, #72]	; (8d4c <SdioCard::readStart(unsigned long)+0x5c>)
    8d04:	mov.w	r2, #928	; 0x3a0
    8d08:	str	r2, [r3, #0]
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    8d0a:	movs	r0, #0
    8d0c:	pop	{r4, pc}
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    8d0e:	ldr	r2, [pc, #64]	; (8d50 <SdioCard::readStart(unsigned long)+0x60>)
    8d10:	ldr	r3, [r2, #0]
    8d12:	orr.w	r3, r3, #65536	; 0x10000
    8d16:	str	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    8d18:	ldr	r3, [pc, #56]	; (8d54 <SdioCard::readStart(unsigned long)+0x64>)
    8d1a:	ldr	r2, [pc, #60]	; (8d58 <SdioCard::readStart(unsigned long)+0x68>)
    8d1c:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    8d1e:	ldr	r3, [pc, #60]	; (8d5c <SdioCard::readStart(unsigned long)+0x6c>)
    8d20:	ldrb	r3, [r3, #0]
    8d22:	cbnz	r3, 8d28 <SdioCard::readStart(unsigned long)+0x38>
    8d24:	lsls	r1, r4, #9
    8d26:	b.n	8d2a <SdioCard::readStart(unsigned long)+0x3a>
    8d28:	mov	r1, r4
    8d2a:	ldr	r0, [pc, #52]	; (8d60 <SdioCard::readStart(unsigned long)+0x70>)
    8d2c:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    8d30:	cbnz	r0, 8d40 <SdioCard::readStart(unsigned long)+0x50>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8d32:	ldr	r3, [pc, #20]	; (8d48 <SdioCard::readStart(unsigned long)+0x58>)
    8d34:	movs	r2, #12
    8d36:	strb	r2, [r3, #0]
  m_errorLine = line;
    8d38:	ldr	r3, [pc, #16]	; (8d4c <SdioCard::readStart(unsigned long)+0x5c>)
    8d3a:	mov.w	r2, #940	; 0x3ac
    8d3e:	str	r2, [r3, #0]

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD18);
  }
  return true;
}
    8d40:	pop	{r4, pc}
    8d42:	nop
    8d44:	.word	0x00008229
    8d48:	.word	0x1fff1338
    8d4c:	.word	0x2001a6e4
    8d50:	.word	0x400b1028
    8d54:	.word	0x400b1004
    8d58:	.word	0xffff0200
    8d5c:	.word	0x2001a6b8
    8d60:	.word	0x123a0032

00008d64 <SdioCard::readSector(unsigned long, unsigned char*)>:
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8d64:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    8d66:	ldrb	r3, [r0, #8]
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8d68:	mov	r6, r2
  if (m_sdioConfig.useDma()) {
    8d6a:	lsls	r2, r3, #31
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8d6c:	sub.w	sp, sp, #512	; 0x200
    8d70:	mov	r4, r0
    8d72:	mov	r5, r1
  if (m_sdioConfig.useDma()) {
    8d74:	bpl.n	8dae <SdioCard::readSector(unsigned long, unsigned char*)+0x4a>
    uint8_t aligned[512];

    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;
    8d76:	lsls	r3, r6, #30
    8d78:	ite	eq
    8d7a:	moveq	r4, r6
    8d7c:	movne	r4, sp

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
    8d7e:	movs	r3, #1
    8d80:	mov	r2, r4
    8d82:	ldr	r0, [pc, #148]	; (8e18 <SdioCard::readSector(unsigned long, unsigned char*)+0xb4>)
    8d84:	bl	82c4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    8d88:	mov	r5, r0
    8d8a:	cbnz	r0, 8d9c <SdioCard::readSector(unsigned long, unsigned char*)+0x38>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8d8c:	ldr	r3, [pc, #140]	; (8e1c <SdioCard::readSector(unsigned long, unsigned char*)+0xb8>)
    8d8e:	movs	r2, #11
    8d90:	strb	r2, [r3, #0]
  m_errorLine = line;
    8d92:	ldr	r3, [pc, #140]	; (8e20 <SdioCard::readSector(unsigned long, unsigned char*)+0xbc>)
    8d94:	movw	r2, #865	; 0x361
    8d98:	str	r2, [r3, #0]
    8d9a:	b.n	8e10 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD17);
    }
    if (ptr != dst) {
    8d9c:	cmp	r4, r6
    8d9e:	beq.n	8e10 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
      memcpy(dst, aligned, 512);
    8da0:	mov.w	r2, #512	; 0x200
    8da4:	mov	r1, sp
    8da6:	mov	r0, r6
    8da8:	bl	8f14 <memcpy>
    8dac:	b.n	8e10 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    8dae:	bl	849c <waitTransferComplete()>
    8db2:	cbnz	r0, 8db8 <SdioCard::readSector(unsigned long, unsigned char*)+0x54>
      return false;
    8db4:	movs	r5, #0
    8db6:	b.n	8e10 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    }
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != READ_STATE || sector != m_curSector) {
    8db8:	ldrb	r3, [r4, #9]
    8dba:	cmp	r3, #1
    8dbc:	bne.n	8dc4 <SdioCard::readSector(unsigned long, unsigned char*)+0x60>
    8dbe:	ldr	r3, [r4, #4]
    8dc0:	cmp	r5, r3
    8dc2:	beq.n	8de2 <SdioCard::readSector(unsigned long, unsigned char*)+0x7e>
      if (!syncDevice()) {
    8dc4:	ldr	r3, [r4, #0]
    8dc6:	mov	r0, r4
    8dc8:	ldr	r3, [r3, #28]
    8dca:	blx	r3
    8dcc:	cmp	r0, #0
    8dce:	beq.n	8db4 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
        return false;
      }
      if (!readStart(sector)) {
    8dd0:	mov	r1, r5
    8dd2:	mov	r0, r4
    8dd4:	bl	8cf0 <SdioCard::readStart(unsigned long)>
    8dd8:	cmp	r0, #0
    8dda:	beq.n	8db4 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
        return false;
      }
      m_curSector = sector;
      m_curState = READ_STATE;
    8ddc:	movs	r3, #1
        return false;
      }
      if (!readStart(sector)) {
        return false;
      }
      m_curSector = sector;
    8dde:	str	r5, [r4, #4]
      m_curState = READ_STATE;
    8de0:	strb	r3, [r4, #9]
    }
    if (!readData(dst)) {
    8de2:	mov	r1, r6
    8de4:	mov	r0, r4
    8de6:	bl	8c2c <SdioCard::readData(unsigned char*)>
    8dea:	mov	r5, r0
    8dec:	cmp	r0, #0
    8dee:	beq.n	8db4 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    8df0:	ldr	r3, [pc, #48]	; (8e24 <SdioCard::readSector(unsigned long, unsigned char*)+0xc0>)
    8df2:	ldr	r3, [r3, #0]
    8df4:	lsrs	r3, r3, #16
    8df6:	lsls	r3, r3, #16
    8df8:	cbz	r3, 8e02 <SdioCard::readSector(unsigned long, unsigned char*)+0x9e>
      if (!syncDevice()) {
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
    8dfa:	ldr	r3, [r4, #4]
    8dfc:	adds	r3, #1
    8dfe:	str	r3, [r4, #4]
    8e00:	b.n	8e10 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    if (!readData(dst)) {
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    8e02:	ldr	r3, [r4, #0]
    8e04:	mov	r0, r4
    8e06:	ldr	r3, [r3, #28]
    8e08:	blx	r3
    8e0a:	cmp	r0, #0
    8e0c:	bne.n	8dfa <SdioCard::readSector(unsigned long, unsigned char*)+0x96>
    8e0e:	b.n	8db4 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
}
    8e10:	mov	r0, r5
    8e12:	add.w	sp, sp, #512	; 0x200
    8e16:	pop	{r4, r5, r6, pc}
    8e18:	.word	0x113a0011
    8e1c:	.word	0x1fff1338
    8e20:	.word	0x2001a6e4
    8e24:	.word	0x400b1004

00008e28 <SdioCard::stopTransmission(bool)>:
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    8e28:	push	{r4, r5, r6, lr}
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8e2a:	ldr	r2, [pc, #72]	; (8e74 <SdioCard::stopTransmission(bool)+0x4c>)
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
    8e2c:	movs	r5, #0
    8e2e:	strb	r5, [r0, #9]
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8e30:	ldr	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    8e32:	ldr	r0, [pc, #68]	; (8e78 <SdioCard::stopTransmission(bool)+0x50>)
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8e34:	bic.w	r3, r3, #65536	; 0x10000
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    8e38:	mov	r6, r1
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8e3a:	str	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    8e3c:	mov	r1, r5
    8e3e:	bl	81b4 <cardCommand(unsigned long, unsigned long)>
    8e42:	mov	r4, r0
    8e44:	cbnz	r0, 8e56 <SdioCard::stopTransmission(bool)+0x2e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8e46:	ldr	r3, [pc, #52]	; (8e7c <SdioCard::stopTransmission(bool)+0x54>)
    8e48:	movs	r2, #9
    8e4a:	strb	r2, [r3, #0]
  m_errorLine = line;
    8e4c:	ldr	r3, [pc, #48]	; (8e80 <SdioCard::stopTransmission(bool)+0x58>)
    8e4e:	movw	r2, #962	; 0x3c2
    8e52:	str	r2, [r3, #0]
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
    8e54:	b.n	8e70 <SdioCard::stopTransmission(bool)+0x48>
  }
  if (blocking) {
    8e56:	cbz	r6, 8e70 <SdioCard::stopTransmission(bool)+0x48>
    if (yieldTimeout(isBusyDat)) {
    8e58:	ldr	r0, [pc, #40]	; (8e84 <SdioCard::stopTransmission(bool)+0x5c>)
    8e5a:	bl	8144 <yieldTimeout(bool (*)())>
    8e5e:	cbz	r0, 8e70 <SdioCard::stopTransmission(bool)+0x48>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8e60:	ldr	r3, [pc, #24]	; (8e7c <SdioCard::stopTransmission(bool)+0x54>)
    8e62:	movs	r2, #10
    8e64:	strb	r2, [r3, #0]
  m_errorLine = line;
    8e66:	ldr	r3, [pc, #24]	; (8e80 <SdioCard::stopTransmission(bool)+0x58>)
    8e68:	movw	r2, #966	; 0x3c6
    8e6c:	str	r2, [r3, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
  if (blocking) {
    if (yieldTimeout(isBusyDat)) {
      return sdError(SD_CARD_ERROR_CMD13);
    8e6e:	mov	r4, r5
    }
  }
  return true;
}
    8e70:	mov	r0, r4
    8e72:	pop	{r4, r5, r6, pc}
    8e74:	.word	0x400b1028
    8e78:	.word	0x0cdb0000
    8e7c:	.word	0x1fff1338
    8e80:	.word	0x2001a6e4
    8e84:	.word	0x00007fc5

00008e88 <SdioCard::syncDevice()>:
//------------------------------------------------------------------------------
bool SdioCard::syncDevice() {
    8e88:	push	{r4, lr}
    8e8a:	mov	r4, r0
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    8e8c:	bl	849c <waitTransferComplete()>
    8e90:	cbz	r0, 8ea2 <SdioCard::syncDevice()+0x1a>
    return false;
  }
  if (m_curState != IDLE_STATE) {
    8e92:	ldrb	r3, [r4, #9]
    8e94:	cbz	r3, 8ea2 <SdioCard::syncDevice()+0x1a>
    return stopTransmission(true);
    8e96:	mov	r0, r4
    8e98:	movs	r1, #1
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    8e9a:	ldmia.w	sp!, {r4, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    return false;
  }
  if (m_curState != IDLE_STATE) {
    return stopTransmission(true);
    8e9e:	b.w	8e28 <SdioCard::stopTransmission(bool)>
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    8ea2:	pop	{r4, pc}

00008ea4 <SdioCard::isBusy()>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorLine() const {
  return m_errorLine;
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
    8ea4:	push	{r4, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    8ea6:	ldrb	r3, [r0, #8]
    8ea8:	lsls	r3, r3, #31
//------------------------------------------------------------------------------
uint32_t SdioCard::errorLine() const {
  return m_errorLine;
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
    8eaa:	mov	r2, r0
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    8eac:	bpl.n	8ecc <SdioCard::isBusy()+0x28>
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    8eae:	ldr	r3, [pc, #80]	; (8f00 <SdioCard::isBusy()+0x5c>)
    8eb0:	ldr	r3, [r3, #0]
    8eb2:	cbz	r3, 8eba <SdioCard::isBusy()+0x16>
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    8eb4:	ldmia.w	sp!, {r4, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    8eb8:	bx	r3
    8eba:	ldr	r3, [pc, #72]	; (8f04 <SdioCard::isBusy()+0x60>)
    8ebc:	ldrb	r3, [r3, #0]
    8ebe:	cbnz	r3, 8ec4 <SdioCard::isBusy()+0x20>
    8ec0:	movs	r0, #0
    8ec2:	pop	{r4, pc}
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    8ec4:	ldmia.w	sp!, {r4, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    8ec8:	b.w	8228 <isBusyCMD13()>
  } else {
    if (m_transferActive) {
    8ecc:	ldr	r1, [pc, #56]	; (8f08 <SdioCard::isBusy()+0x64>)
    8ece:	ldrb	r4, [r1, #0]
    8ed0:	cbz	r4, 8ef2 <SdioCard::isBusy()+0x4e>
      if (isBusyTransferComplete()) {
    8ed2:	bl	800c <isBusyTransferComplete()>
    8ed6:	cbnz	r0, 8efe <SdioCard::isBusy()+0x5a>
        return true;
      }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
      if ((SDHC_BLKATTR & 0XFFFF0000) != 0) {
    8ed8:	ldr	r3, [pc, #48]	; (8f0c <SdioCard::isBusy()+0x68>)
    8eda:	ldr	r3, [r3, #0]
    8edc:	lsrs	r3, r3, #16
    8ede:	lsls	r3, r3, #16
    8ee0:	cmp	r3, #0
    8ee2:	bne.n	8ec0 <SdioCard::isBusy()+0x1c>
        return false;
      }
      m_transferActive = false;
    8ee4:	strb	r0, [r1, #0]
      stopTransmission(false);
    8ee6:	mov	r1, r0
    8ee8:	mov	r0, r2
    8eea:	bl	8e28 <SdioCard::stopTransmission(bool)>
    8eee:	mov	r0, r4
    8ef0:	pop	{r4, pc}
#else  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
      return false;
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    }
    // Use DAT0 low as busy.
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
    8ef2:	ldr	r3, [pc, #28]	; (8f10 <SdioCard::isBusy()+0x6c>)
    8ef4:	ldr	r0, [r3, #0]
    8ef6:	eor.w	r0, r0, #16777216	; 0x1000000
    8efa:	ubfx	r0, r0, #24, #1
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    8efe:	pop	{r4, pc}
    8f00:	.word	0x2001a6b4
    8f04:	.word	0x2001a6cc
    8f08:	.word	0x2001a6c4
    8f0c:	.word	0x400b1004
    8f10:	.word	0x400b1024

00008f14 <memcpy>:
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
#else
	push	{r0}
    8f14:	push	{r0}
#endif
	orr	r3, r1, r0
    8f16:	orr.w	r3, r1, r0
	ands	r3, r3, #3
    8f1a:	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    8f1e:	bne.n	9000 <memcpy+0xec>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    8f20:	subs	r2, #64	; 0x40
	blo	.Lmid_block
    8f22:	bcc.n	8fa8 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    8f24:	ldr.w	r3, [r1], #4
    8f28:	str.w	r3, [r0], #4
    8f2c:	ldr.w	r3, [r1], #4
    8f30:	str.w	r3, [r0], #4
    8f34:	ldr.w	r3, [r1], #4
    8f38:	str.w	r3, [r0], #4
    8f3c:	ldr.w	r3, [r1], #4
    8f40:	str.w	r3, [r0], #4
    8f44:	ldr.w	r3, [r1], #4
    8f48:	str.w	r3, [r0], #4
    8f4c:	ldr.w	r3, [r1], #4
    8f50:	str.w	r3, [r0], #4
    8f54:	ldr.w	r3, [r1], #4
    8f58:	str.w	r3, [r0], #4
    8f5c:	ldr.w	r3, [r1], #4
    8f60:	str.w	r3, [r0], #4
    8f64:	ldr.w	r3, [r1], #4
    8f68:	str.w	r3, [r0], #4
    8f6c:	ldr.w	r3, [r1], #4
    8f70:	str.w	r3, [r0], #4
    8f74:	ldr.w	r3, [r1], #4
    8f78:	str.w	r3, [r0], #4
    8f7c:	ldr.w	r3, [r1], #4
    8f80:	str.w	r3, [r0], #4
    8f84:	ldr.w	r3, [r1], #4
    8f88:	str.w	r3, [r0], #4
    8f8c:	ldr.w	r3, [r1], #4
    8f90:	str.w	r3, [r0], #4
    8f94:	ldr.w	r3, [r1], #4
    8f98:	str.w	r3, [r0], #4
    8f9c:	ldr.w	r3, [r1], #4
    8fa0:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    8fa4:	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    8fa6:	bcs.n	8f24 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    8fa8:	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    8faa:	bcc.n	8fd0 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    8fac:	ldr.w	r3, [r1], #4
    8fb0:	str.w	r3, [r0], #4
    8fb4:	ldr.w	r3, [r1], #4
    8fb8:	str.w	r3, [r0], #4
    8fbc:	ldr.w	r3, [r1], #4
    8fc0:	str.w	r3, [r0], #4
    8fc4:	ldr.w	r3, [r1], #4
    8fc8:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    8fcc:	subs	r2, #16
	bhs	.Lmid_block_loop
    8fce:	bcs.n	8fac <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    8fd0:	adds	r2, #12
	blo	.Lcopy_less_than_4
    8fd2:	bcc.n	8fe0 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    8fd4:	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    8fd8:	str.w	r3, [r0], #4
	subs	r2, #4
    8fdc:	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    8fde:	bcs.n	8fd4 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    8fe0:	adds	r2, #4
	beq	.Ldone
    8fe2:	beq.n	8ffa <memcpy+0xe6>

	lsls	r2, r2, #31
    8fe4:	lsls	r2, r2, #31
	itt ne
    8fe6:	itt	ne
	ldrbne  r3, [r1], #1
    8fe8:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    8fec:	strbne.w	r3, [r0], #1

	bcc	.Ldone
    8ff0:	bcc.n	8ffa <memcpy+0xe6>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
	strh	r3, [r0]
#else
	ldrb	r3, [r1]
    8ff2:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    8ff4:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    8ff6:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    8ff8:	strb	r3, [r0, #1]

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    8ffa:	pop	{r0}
#endif
	bx	lr
    8ffc:	bx	lr
    8ffe:	nop
	beq	.Ldst_aligned
#else
	/* if len < 12, misalignment adjustment has more overhead than
	just byte-to-byte copy.  Also, len must >=8 to guarantee code
	afterward work correctly.  */
	cmp	r2, #12
    9000:	cmp	r2, #12
	blo	.Lbyte_copy
    9002:	bcc.n	909a <memcpy+0x186>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    9004:	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    9008:	beq.n	902e <memcpy+0x11a>

	rsb	r3, #4
    900a:	rsb	r3, r3, #4
	subs	r2, r3
    900e:	subs	r2, r2, r3

	lsls    r3, r3, #31
    9010:	lsls	r3, r3, #31
	itt ne
    9012:	itt	ne
	ldrbne  r3, [r1], #1
    9014:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    9018:	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    901c:	bcc.n	902e <memcpy+0x11a>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
	strh    r3, [r0], #2
	b	.Ldst_aligned
#else
	ldrb    r3, [r1], #1
    901e:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    9022:	strb.w	r3, [r0], #1
	ldrb    r3, [r1], #1
    9026:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    902a:	strb.w	r3, [r0], #1
	/* Now that dst is aligned */
.Ldst_aligned:
	/* if r1 is aligned now, it means r0/r1 has the same misalignment,
	and they are both aligned now.  Go aligned copy.  */
	ands	r3, r1, #3
    902e:	ands.w	r3, r1, #3
	beq	.Lbig_block
    9032:	beq.w	8f20 <memcpy+0xc>

	/* dst is aligned, but src isn't.  Misaligned copy.  */

	push	{r4, r5}
    9036:	push	{r4, r5}
	subs	r2, #4
    9038:	subs	r2, #4

	/* Backward r1 by misaligned bytes, to make r1 aligned.
	Since we need to restore r1 to unaligned address after the loop,
	we need keep the offset bytes to ip and sub it from r1 afterward.  */
	subs	r1, r3
    903a:	subs	r1, r1, r3
	rsb	ip, r3, #4
    903c:	rsb	ip, r3, #4

	/* Pre-load on word */
	ldr	r4, [r1], #4
    9040:	ldr.w	r4, [r1], #4

	cmp	r3, #2
    9044:	cmp	r3, #2
	beq	.Lmisaligned_copy_2_2
    9046:	beq.n	907c <memcpy+0x168>
	cmp	r3, #3
    9048:	cmp	r3, #3
	beq	.Lmisaligned_copy_3_1
    904a:	beq.n	9064 <memcpy+0x150>
	subs	r2, #4
	bhs	1b
	.endm

.Lmisaligned_copy_1_3:
	mis_src_copy shift=8
    904c:	lsrs	r4, r4, #8
    904e:	ldr.w	r3, [r1], #4
    9052:	lsls	r5, r3, #24
    9054:	orr.w	r4, r4, r5
    9058:	str.w	r4, [r0], #4
    905c:	mov	r4, r3
    905e:	subs	r2, #4
    9060:	bcs.n	904c <memcpy+0x138>
	b	.Lsrc_misaligned_tail
    9062:	b.n	9092 <memcpy+0x17e>

.Lmisaligned_copy_3_1:
	mis_src_copy shift=24
    9064:	lsrs	r4, r4, #24
    9066:	ldr.w	r3, [r1], #4
    906a:	lsls	r5, r3, #8
    906c:	orr.w	r4, r4, r5
    9070:	str.w	r4, [r0], #4
    9074:	mov	r4, r3
    9076:	subs	r2, #4
    9078:	bcs.n	9064 <memcpy+0x150>
	b	.Lsrc_misaligned_tail
    907a:	b.n	9092 <memcpy+0x17e>

.Lmisaligned_copy_2_2:
	/* For 2_2 misalignment, ldr is still faster than 2 x ldrh.  */
	mis_src_copy shift=16
    907c:	lsrs	r4, r4, #16
    907e:	ldr.w	r3, [r1], #4
    9082:	lsls	r5, r3, #16
    9084:	orr.w	r4, r4, r5
    9088:	str.w	r4, [r0], #4
    908c:	mov	r4, r3
    908e:	subs	r2, #4
    9090:	bcs.n	907c <memcpy+0x168>

.Lsrc_misaligned_tail:
	adds	r2, #4
    9092:	adds	r2, #4
	subs	r1, ip
    9094:	subs.w	r1, r1, ip
	pop	{r4, r5}
    9098:	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    909a:	subs	r2, #4
	blo	.Lcopy_less_than_4
    909c:	bcc.n	8fe0 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    909e:	subs	r2, #1
	ldrb    r3, [r1], #1
    90a0:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    90a4:	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    90a8:	bcs.n	909e <memcpy+0x18a>

	ldrb	r3, [r1]
    90aa:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    90ac:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    90ae:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    90b0:	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    90b2:	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    90b4:	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    90b6:	pop	{r0}
#endif
	bx	lr
    90b8:	bx	lr
    90ba:	nop

000090bc <memset>:
	.type	memset, %function
	.thumb_func
	memset:
//FUNCTION(memset)
    // save the original pointer
    push    { r0, lr }
    90bc:	push	{r0, lr}

    // check for zero length
    cbz     r2, .L_done
    90be:	cbz	r2, 90fc <memset+0x40>

    // short memsets aren't worth optimizing and make sure we have
    // enough headroom to try to do dwordwise move optimization
    cmp     r2, #16
    90c0:	cmp	r2, #16
    blt     .L_bytewise
    90c2:	blt.n	90f4 <memset+0x38>

    // see how many bytes we need to move to align to dword boundaries
    and     r3, r0, #7
    90c4:	and.w	r3, r0, #7
    cbz     r3, .L_prepare_dwordwise
    90c8:	cbz	r3, 90d8 <memset+0x1c>
    rsb     r3, #8
    90ca:	rsb	r3, r3, #8
    subs    r2, r3
    90ce:	subs	r2, r2, r3

.L_bytewise_align:
    // bytewise to align memset
    subs    r3, r3, #1
    90d0:	subs	r3, #1
    strb    r1, [r0], #1
    90d2:	strb.w	r1, [r0], #1
    bgt     .L_bytewise_align
    90d6:	bgt.n	90d0 <memset+0x14>

.L_prepare_dwordwise:
    // fill a pair of 32 bit registers with the 8 bit value
    uxtb    r1, r1
    90d8:	uxtb	r1, r1
    orr     r1, r1, r1, lsl #8
    90da:	orr.w	r1, r1, r1, lsl #8
    orr     r1, r1, r1, lsl #16
    90de:	orr.w	r1, r1, r1, lsl #16
    mov     r12, r1
    90e2:	mov	ip, r1

    // load the number of dwords left
    lsrs    r3, r2, #3
    90e4:	lsrs	r3, r2, #3

.L_dwordwise:
    // dwordwise memset
		
    subs    r3, r3, #1
    90e6:	subs	r3, #1
    strd    r1, r12, [r0], #8
    90e8:	strd	r1, ip, [r0], #8
    bgt     .L_dwordwise
    90ec:	bgt.n	90e6 <memset+0x2a>

    // remaining bytes
    ands     r2, #7
    90ee:	ands.w	r2, r2, #7
    beq     .L_done
    90f2:	beq.n	90fc <memset+0x40>

.L_bytewise:
    // bytewise memset
    subs    r2, r2, #1
    90f4:	subs	r2, #1
    strb    r1, [r0], #1
    90f6:	strb.w	r1, [r0], #1
    bgt     .L_bytewise
    90fa:	bgt.n	90f4 <memset+0x38>

.L_done:
    // restore the base pointer as return value
    pop     { r0, pc }
    90fc:	pop	{r0, pc}
    90fe:	nop

00009100 <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    9100:	push	{r4, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    9102:	ldr	r4, [pc, #64]	; (9144 <usb_serial_getchar+0x44>)
    9104:	ldr	r3, [r4, #0]
    9106:	cbz	r3, 9124 <usb_serial_getchar+0x24>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    9108:	ldr	r0, [r4, #0]
    910a:	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
    910c:	adds	r2, r3, #1
    910e:	add	r3, r0
    9110:	ldrb	r4, [r3, #8]
	if (i >= rx_packet->len) {
    9112:	ldrh	r3, [r0, #0]
    9114:	cmp	r2, r3
    9116:	bcc.n	913e <usb_serial_getchar+0x3e>
		usb_free(rx_packet);
    9118:	bl	96c4 <usb_free>
		rx_packet = NULL;
    911c:	ldr	r3, [pc, #36]	; (9144 <usb_serial_getchar+0x44>)
    911e:	movs	r2, #0
    9120:	str	r2, [r3, #0]
    9122:	b.n	9140 <usb_serial_getchar+0x40>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    9124:	ldr	r3, [pc, #32]	; (9148 <usb_serial_getchar+0x48>)
    9126:	ldrb	r3, [r3, #0]
    9128:	cbnz	r3, 9130 <usb_serial_getchar+0x30>
    912a:	mov.w	r0, #4294967295
    912e:	pop	{r4, pc}
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    9130:	movs	r0, #3
    9132:	bl	9748 <usb_rx>
    9136:	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    9138:	cmp	r0, #0
    913a:	bne.n	9108 <usb_serial_getchar+0x8>
    913c:	b.n	912a <usb_serial_getchar+0x2a>
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    913e:	strh	r2, [r0, #2]
	}
	return c;
    9140:	mov	r0, r4
}
    9142:	pop	{r4, pc}
    9144:	.word	0x2001a6f4
    9148:	.word	0x2001a7df

0000914c <usb_serial_peekchar>:

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    914c:	push	{r4, lr}
	if (!rx_packet) {
    914e:	ldr	r4, [pc, #44]	; (917c <usb_serial_peekchar+0x30>)
    9150:	ldr	r3, [r4, #0]
    9152:	cbz	r3, 915a <usb_serial_peekchar+0xe>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
    9154:	ldr	r2, [r4, #0]
    9156:	cbnz	r2, 9174 <usb_serial_peekchar+0x28>
    9158:	b.n	9160 <usb_serial_peekchar+0x14>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    915a:	ldr	r3, [pc, #36]	; (9180 <usb_serial_peekchar+0x34>)
    915c:	ldrb	r3, [r3, #0]
    915e:	cbnz	r3, 9166 <usb_serial_peekchar+0x1a>
    9160:	mov.w	r0, #4294967295
    9164:	pop	{r4, pc}
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    9166:	movs	r0, #3
    9168:	bl	9748 <usb_rx>
    916c:	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    916e:	cmp	r0, #0
    9170:	bne.n	9154 <usb_serial_peekchar+0x8>
    9172:	b.n	9160 <usb_serial_peekchar+0x14>
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    9174:	ldrh	r3, [r2, #2]
    9176:	add	r3, r2
    9178:	ldrb	r0, [r3, #8]
}
    917a:	pop	{r4, pc}
    917c:	.word	0x2001a6f4
    9180:	.word	0x2001a7df

00009184 <usb_serial_available>:
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    9184:	ldr	r3, [pc, #16]	; (9198 <usb_serial_available+0x14>)

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    9186:	ldrh	r0, [r3, #4]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    9188:	ldr	r3, [pc, #16]	; (919c <usb_serial_available+0x18>)
    918a:	ldr	r2, [r3, #0]
    918c:	cbz	r2, 9196 <usb_serial_available+0x12>
    918e:	ldrh	r3, [r2, #0]
    9190:	ldrh	r2, [r2, #2]
    9192:	subs	r3, r3, r2
    9194:	add	r0, r3
	return count;
}
    9196:	bx	lr
    9198:	.word	0x2001a854
    919c:	.word	0x2001a6f4

000091a0 <usb_serial_flush_input>:
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    91a0:	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
    91a2:	ldr	r3, [pc, #36]	; (91c8 <usb_serial_flush_input+0x28>)
    91a4:	ldrb	r3, [r3, #0]
    91a6:	cbz	r3, 91c4 <usb_serial_flush_input+0x24>
	if (rx_packet) {
    91a8:	ldr	r4, [pc, #32]	; (91cc <usb_serial_flush_input+0x2c>)
    91aa:	ldr	r0, [r4, #0]
    91ac:	cbz	r0, 91b6 <usb_serial_flush_input+0x16>
		usb_free(rx_packet);
    91ae:	bl	96c4 <usb_free>
		rx_packet = NULL;
    91b2:	movs	r3, #0
    91b4:	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    91b6:	movs	r0, #3
    91b8:	bl	9748 <usb_rx>
		if (!rx) break;
    91bc:	cbz	r0, 91c4 <usb_serial_flush_input+0x24>
		usb_free(rx);
    91be:	bl	96c4 <usb_free>
	}
    91c2:	b.n	91b6 <usb_serial_flush_input+0x16>
    91c4:	pop	{r4, pc}
    91c6:	nop
    91c8:	.word	0x2001a7df
    91cc:	.word	0x2001a6f4

000091d0 <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    91d0:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    91d4:	ldr	r5, [pc, #196]	; (929c <usb_serial_write+0xcc>)
	while (size > 0) {
		if (!tx_packet) {
    91d6:	ldr.w	r9, [pc, #212]	; 92ac <usb_serial_write+0xdc>
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    91da:	movs	r3, #1
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    91dc:	mov	sl, r0
    91de:	mov	r4, r1
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    91e0:	strb	r3, [r5, #0]
	while (size > 0) {
    91e2:	mov	r6, r1
    91e4:	mov	r7, r9
    91e6:	cmp	r6, #0
    91e8:	beq.n	9292 <usb_serial_write+0xc2>
		if (!tx_packet) {
    91ea:	ldr.w	r3, [r9]
    91ee:	cbnz	r3, 9240 <usb_serial_write+0x70>
    91f0:	ldr.w	fp, [pc, #176]	; 92a4 <usb_serial_write+0xd4>
    91f4:	movw	r8, #41721	; 0xa2f9
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    91f8:	ldr	r3, [pc, #164]	; (92a0 <usb_serial_write+0xd0>)
    91fa:	ldrb	r3, [r3, #0]
    91fc:	and.w	r1, r3, #255	; 0xff
    9200:	cbnz	r3, 9206 <usb_serial_write+0x36>
					tx_noautoflush = 0;
    9202:	strb	r1, [r5, #0]
    9204:	b.n	9232 <usb_serial_write+0x62>
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    9206:	movs	r0, #4
    9208:	bl	9780 <usb_tx_packet_count>
    920c:	cmp	r0, #7
    920e:	bhi.n	9220 <usb_serial_write+0x50>
					tx_noautoflush = 1;
    9210:	movs	r3, #1
    9212:	strb	r3, [r5, #0]
					tx_packet = usb_malloc();
    9214:	bl	9688 <usb_malloc>
    9218:	str	r0, [r7, #0]
					if (tx_packet) break;
    921a:	cbnz	r0, 9240 <usb_serial_write+0x70>
					tx_noautoflush = 0;
    921c:	ldr	r3, [pc, #124]	; (929c <usb_serial_write+0xcc>)
    921e:	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    9220:	subs.w	r8, r8, #1
    9224:	beq.n	922c <usb_serial_write+0x5c>
    9226:	ldrb.w	r3, [fp]
    922a:	cbz	r3, 923a <usb_serial_write+0x6a>
					transmit_previous_timeout = 1;
    922c:	ldr	r3, [pc, #116]	; (92a4 <usb_serial_write+0xd4>)
    922e:	movs	r2, #1
    9230:	strb	r2, [r3, #0]
					return -1;
    9232:	mov.w	r0, #4294967295
    9236:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				}
				yield();
    923a:	bl	9f54 <yield>
			}
    923e:	b.n	91f8 <usb_serial_write+0x28>
		}
		transmit_previous_timeout = 0;
    9240:	ldr	r3, [pc, #96]	; (92a4 <usb_serial_write+0xd4>)
    9242:	movs	r1, #0
    9244:	strb	r1, [r3, #0]
		len = CDC_TX_SIZE - tx_packet->index;
    9246:	ldr	r1, [r7, #0]
    9248:	ldrh	r3, [r1, #2]
    924a:	rsb	r0, r3, #64	; 0x40
    924e:	cmp	r0, r6
    9250:	it	cs
    9252:	movcs	r0, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    9254:	add.w	lr, r3, r0
    9258:	add	r3, r1
    925a:	strh.w	lr, [r1, #2]
		size -= len;
    925e:	subs	r6, r6, r0
    9260:	adds	r3, #7
    9262:	add.w	r8, sl, r0
		while (len-- > 0) *dest++ = *src++;
    9266:	cmp	sl, r8
    9268:	beq.n	9274 <usb_serial_write+0xa4>
    926a:	ldrb.w	r0, [sl], #1
    926e:	strb.w	r0, [r3, #1]!
    9272:	b.n	9266 <usb_serial_write+0x96>
		if (tx_packet->index >= CDC_TX_SIZE) {
    9274:	ldrh	r3, [r1, #2]
    9276:	cmp	r3, #63	; 0x3f
    9278:	bls.n	9288 <usb_serial_write+0xb8>
			tx_packet->len = CDC_TX_SIZE;
    927a:	movs	r3, #64	; 0x40
    927c:	strh	r3, [r1, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    927e:	movs	r0, #4
    9280:	bl	981c <usb_tx>
			tx_packet = NULL;
    9284:	movs	r3, #0
    9286:	str	r3, [r7, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    9288:	ldr	r3, [pc, #28]	; (92a8 <usb_serial_write+0xd8>)
    928a:	movs	r2, #5
    928c:	strb	r2, [r3, #0]
    928e:	mov	sl, r8
    9290:	b.n	91e6 <usb_serial_write+0x16>
	}
	tx_noautoflush = 0;
    9292:	strb	r6, [r5, #0]
	return ret;
    9294:	mov	r0, r4
}
    9296:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    929a:	nop
    929c:	.word	0x2001a6e9
    92a0:	.word	0x2001a7df
    92a4:	.word	0x2001a6f0
    92a8:	.word	0x2001a6e8
    92ac:	.word	0x2001a6ec

000092b0 <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    92b0:	push	{r0, r1, r2, lr}
    92b2:	add	r3, sp, #8
	return usb_serial_write(&c, 1);
    92b4:	movs	r1, #1
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    92b6:	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    92ba:	mov	r0, r3
    92bc:	bl	91d0 <usb_serial_write>
}
    92c0:	add	sp, #12
    92c2:	ldr.w	pc, [sp], #4
    92c6:	Address 0x000092c6 is out of bounds.


000092c8 <usb_serial_write_buffer_free>:
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    92c8:	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
    92ca:	ldr	r4, [pc, #56]	; (9304 <usb_serial_write_buffer_free+0x3c>)
	if (!tx_packet) {
    92cc:	ldr	r5, [pc, #56]	; (9308 <usb_serial_write_buffer_free+0x40>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    92ce:	movs	r3, #1
    92d0:	strb	r3, [r4, #0]
	if (!tx_packet) {
    92d2:	ldr	r3, [r5, #0]
    92d4:	cbnz	r3, 92f6 <usb_serial_write_buffer_free+0x2e>
		if (!usb_configuration ||
    92d6:	ldr	r3, [pc, #52]	; (930c <usb_serial_write_buffer_free+0x44>)
    92d8:	ldrb	r3, [r3, #0]
    92da:	cbnz	r3, 92e2 <usb_serial_write_buffer_free+0x1a>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    92dc:	movs	r0, #0
    92de:	strb	r0, [r4, #0]
			return 0;
    92e0:	pop	{r3, r4, r5, pc}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    92e2:	movs	r0, #4
    92e4:	bl	9780 <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    92e8:	cmp	r0, #7
    92ea:	bhi.n	92dc <usb_serial_write_buffer_free+0x14>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    92ec:	bl	9688 <usb_malloc>
    92f0:	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    92f2:	cmp	r0, #0
    92f4:	beq.n	92dc <usb_serial_write_buffer_free+0x14>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    92f6:	ldr	r3, [r5, #0]
    92f8:	ldrh	r0, [r3, #2]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    92fa:	movs	r3, #0
    92fc:	strb	r3, [r4, #0]
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    92fe:	rsb	r0, r0, #64	; 0x40
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    9302:	pop	{r3, r4, r5, pc}
    9304:	.word	0x2001a6e9
    9308:	.word	0x2001a6ec
    930c:	.word	0x2001a7df

00009310 <usb_serial_flush_output>:

void usb_serial_flush_output(void)
{
    9310:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!usb_configuration) return;
    9314:	ldr	r3, [pc, #68]	; (935c <usb_serial_flush_output+0x4c>)
    9316:	ldrb	r3, [r3, #0]
    9318:	cbz	r3, 9358 <usb_serial_flush_output+0x48>
	tx_noautoflush = 1;
	if (tx_packet) {
    931a:	ldr	r7, [pc, #68]	; (9360 <usb_serial_flush_output+0x50>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    931c:	ldr	r3, [pc, #68]	; (9364 <usb_serial_flush_output+0x54>)
	if (tx_packet) {
    931e:	ldr	r4, [r7, #0]
    9320:	ldr	r5, [pc, #68]	; (9368 <usb_serial_flush_output+0x58>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    9322:	movs	r6, #1
    9324:	strb	r6, [r3, #0]
    9326:	mov	r8, r3
	if (tx_packet) {
    9328:	cbz	r4, 933e <usb_serial_flush_output+0x2e>
		usb_cdc_transmit_flush_timer = 0;
    932a:	movs	r6, #0
		tx_packet->len = tx_packet->index;
    932c:	ldrh	r3, [r4, #2]
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    932e:	strb	r6, [r5, #0]
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    9330:	mov	r1, r4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    9332:	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    9334:	movs	r0, #4
    9336:	bl	981c <usb_tx>
		tx_packet = NULL;
    933a:	str	r6, [r7, #0]
    933c:	b.n	9352 <usb_serial_flush_output+0x42>
	} else {
		usb_packet_t *tx = usb_malloc();
    933e:	bl	9688 <usb_malloc>
		if (tx) {
    9342:	mov	r1, r0
    9344:	cbz	r0, 9350 <usb_serial_flush_output+0x40>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    9346:	movs	r0, #4
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    9348:	strb	r4, [r5, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    934a:	bl	981c <usb_tx>
    934e:	b.n	9352 <usb_serial_flush_output+0x42>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    9350:	strb	r6, [r5, #0]
		}
	}
	tx_noautoflush = 0;
    9352:	movs	r3, #0
    9354:	strb.w	r3, [r8]
    9358:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    935c:	.word	0x2001a7df
    9360:	.word	0x2001a6ec
    9364:	.word	0x2001a6e9
    9368:	.word	0x2001a6e8

0000936c <usb_serial_flush_callback>:
}

void usb_serial_flush_callback(void)
{
    936c:	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
    936e:	ldr	r3, [pc, #56]	; (93a8 <usb_serial_flush_callback+0x3c>)
    9370:	ldrb	r3, [r3, #0]
    9372:	and.w	r5, r3, #255	; 0xff
    9376:	cbnz	r3, 93a4 <usb_serial_flush_callback+0x38>
	if (tx_packet) {
    9378:	ldr	r4, [pc, #48]	; (93ac <usb_serial_flush_callback+0x40>)
    937a:	ldr	r1, [r4, #0]
    937c:	cbz	r1, 938c <usb_serial_flush_callback+0x20>
		tx_packet->len = tx_packet->index;
    937e:	ldrh	r3, [r1, #2]
    9380:	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    9382:	movs	r0, #4
    9384:	bl	981c <usb_tx>
		tx_packet = NULL;
    9388:	str	r5, [r4, #0]
    938a:	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
    938c:	bl	9688 <usb_malloc>
		if (tx) {
    9390:	mov	r1, r0
    9392:	cbz	r0, 939e <usb_serial_flush_callback+0x32>
			usb_tx(CDC_TX_ENDPOINT, tx);
    9394:	movs	r0, #4
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    9396:	ldmia.w	sp!, {r3, r4, r5, lr}
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
    939a:	b.w	981c <usb_tx>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    939e:	ldr	r3, [pc, #16]	; (93b0 <usb_serial_flush_callback+0x44>)
    93a0:	movs	r2, #1
    93a2:	strb	r2, [r3, #0]
    93a4:	pop	{r3, r4, r5, pc}
    93a6:	nop
    93a8:	.word	0x2001a6e9
    93ac:	.word	0x2001a6ec
    93b0:	.word	0x2001a6e8

000093b4 <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
    93b4:	push	{r3, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    93b6:	ldr	r5, [pc, #44]	; (93e4 <fault_isr+0x30>)
    93b8:	mov	r4, r5
    93ba:	ldr	r3, [r5, #0]
    93bc:	lsls	r0, r3, #13
    93be:	bpl.n	93c4 <fault_isr+0x10>
    93c0:	bl	989c <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    93c4:	ldr	r3, [r4, #0]
    93c6:	lsls	r1, r3, #21
    93c8:	bpl.n	93ce <fault_isr+0x1a>
    93ca:	bl	93e8 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    93ce:	ldr	r3, [r4, #0]
    93d0:	lsls	r2, r3, #20
    93d2:	bpl.n	93d8 <fault_isr+0x24>
    93d4:	bl	93e8 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    93d8:	ldr	r3, [r4, #0]
    93da:	lsls	r3, r3, #19
    93dc:	bpl.n	93ba <fault_isr+0x6>
    93de:	bl	93e8 <unused_isr>
    93e2:	b.n	93ba <fault_isr+0x6>
    93e4:	.word	0x40048034

000093e8 <unused_isr>:
	}
}

void unused_isr(void)
{
    93e8:	push	{r3, lr}
	fault_isr();
    93ea:	bl	93b4 <fault_isr>
    93ee:	Address 0x000093ee is out of bounds.


000093f0 <startup_early_hook>:
extern void rtc_set(unsigned long t);


static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    93f0:	ldr	r3, [pc, #4]	; (93f8 <startup_early_hook+0x8>)
    93f2:	movs	r2, #16
    93f4:	strh	r2, [r3, #0]
    93f6:	bx	lr
    93f8:	.word	0x40052000

000093fc <startup_late_hook>:
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
#endif
}
static void startup_default_late_hook(void) {}
    93fc:	bx	lr
    93fe:	Address 0x000093fe is out of bounds.


00009400 <_sbrk>:

void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
    9400:	ldr	r1, [pc, #36]	; (9428 <_sbrk+0x28>)

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
    9402:	push	{r3, lr}
	char *prev, *stack;

	prev = __brkval;
    9404:	ldr	r3, [r1, #0]
	if (incr != 0) {
    9406:	cbz	r0, 9424 <_sbrk+0x24>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    9408:	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
    940a:	add	r0, r3
    940c:	sub.w	r2, r2, #8192	; 0x2000
    9410:	cmp	r0, r2
    9412:	bcc.n	9422 <_sbrk+0x22>
			errno = ENOMEM;
    9414:	bl	b26c <__errno>
    9418:	movs	r3, #12
    941a:	str	r3, [r0, #0]
			return (void *)-1;
    941c:	mov.w	r0, #4294967295
    9420:	pop	{r3, pc}
		}
		__brkval = prev + incr;
    9422:	str	r0, [r1, #0]
	}
	return prev;
    9424:	mov	r0, r3
}
    9426:	pop	{r3, pc}
    9428:	.word	0x1fff133c

0000942c <__cxa_pure_virtual>:
	while (1);
}

__attribute__((weak)) 
void __cxa_pure_virtual()
{
    942c:	b.n	942c <__cxa_pure_virtual>
    942e:	Address 0x0000942e is out of bounds.


00009430 <attachInterruptVector>:
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    9430:	adds	r0, #16
    9432:	ldr	r3, [pc, #8]	; (943c <attachInterruptVector+0xc>)
    9434:	str.w	r1, [r3, r0, lsl #2]
    9438:	bx	lr
    943a:	nop
    943c:	.word	0x1fff0a00

00009440 <rtc_get>:

#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)

unsigned long rtc_get(void)
{
	return RTC_TSR;
    9440:	ldr	r3, [pc, #4]	; (9448 <rtc_get+0x8>)
    9442:	ldr	r0, [r3, #0]
}
    9444:	bx	lr
    9446:	nop
    9448:	.word	0x4003d000

0000944c <rtc_set>:

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    944c:	ldr	r3, [pc, #16]	; (9460 <rtc_set+0x14>)
	RTC_TPR = 0;
    944e:	ldr	r1, [pc, #20]	; (9464 <rtc_set+0x18>)
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    9450:	movs	r2, #0
    9452:	str	r2, [r3, #0]
	RTC_TPR = 0;
    9454:	str	r2, [r1, #0]
	RTC_TSR = t;
    9456:	ldr	r2, [pc, #16]	; (9468 <rtc_set+0x1c>)
    9458:	str	r0, [r2, #0]
	RTC_SR = RTC_SR_TCE;
    945a:	movs	r2, #16
    945c:	str	r2, [r3, #0]
    945e:	bx	lr
    9460:	.word	0x4003d014
    9464:	.word	0x4003d004
    9468:	.word	0x4003d000

0000946c <startup_middle_hook>:
}
#endif

extern void usb_init(void);

static void startup_default_middle_hook(void) {}
    946c:	bx	lr
    946e:	Address 0x0000946e is out of bounds.


00009470 <digitalWrite>:

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    9470:	cmp	r0, #63	; 0x3f


// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
    9472:	push	{r4, lr}
	if (pin >= CORE_NUM_DIGITAL) return;
    9474:	bhi.n	94a8 <digitalWrite+0x38>
#ifdef KINETISK
	if (*portModeRegister(pin)) {
    9476:	ldr	r3, [pc, #52]	; (94ac <digitalWrite+0x3c>)
    9478:	ldr.w	r2, [r3, r0, lsl #3]
    947c:	ldrb.w	r4, [r2, #640]	; 0x280
    9480:	cbz	r4, 9492 <digitalWrite+0x22>
    9482:	movs	r3, #1
		if (val) {
    9484:	cbz	r1, 948c <digitalWrite+0x1c>
			*portSetRegister(pin) = 1;
    9486:	strb.w	r3, [r2, #128]	; 0x80
    948a:	pop	{r4, pc}
		} else {
			*portClearRegister(pin) = 1;
    948c:	strb.w	r3, [r2, #256]	; 0x100
    9490:	pop	{r4, pc}
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
    9492:	add.w	r3, r3, r0, lsl #3
    9496:	ldr	r3, [r3, #4]
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    9498:	ldr	r2, [r3, #0]
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
    949a:	cbz	r1, 94a2 <digitalWrite+0x32>
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    949c:	orr.w	r2, r2, #3
    94a0:	b.n	94a6 <digitalWrite+0x36>
			//*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else {
			// TODO use bitband for atomic read-mod-write
			*config &= ~(PORT_PCR_PE);
    94a2:	bic.w	r2, r2, #2
    94a6:	str	r2, [r3, #0]
    94a8:	pop	{r4, pc}
    94aa:	nop
    94ac:	.word	0x00012e88

000094b0 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    94b0:	cmp	r0, #63	; 0x3f
}



void pinMode(uint8_t pin, uint8_t mode)
{
    94b2:	push	{r4, lr}
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    94b4:	bhi.n	950e <pinMode+0x5e>
	config = portConfigRegister(pin);
    94b6:	ldr	r2, [pc, #88]	; (9510 <pinMode+0x60>)
    94b8:	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    94bc:	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    94be:	ldr	r3, [r3, #4]
    94c0:	mov	r4, r2

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    94c2:	beq.n	94c8 <pinMode+0x18>
    94c4:	cmp	r1, #4
    94c6:	bne.n	94e8 <pinMode+0x38>
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    94c8:	ldr.w	r2, [r4, r0, lsl #3]
    94cc:	movs	r0, #1
    94ce:	strb.w	r0, [r2, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    94d2:	mov.w	r2, #324	; 0x144
    94d6:	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    94d8:	ldr	r2, [r3, #0]
		*portModeRegister(pin) = 1;
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
		if (mode == OUTPUT_OPENDRAIN) {
    94da:	cmp	r1, #4
		    *config |= PORT_PCR_ODE;
    94dc:	ite	eq
    94de:	orreq.w	r2, r2, #32
		} else {
		    *config &= ~PORT_PCR_ODE;
    94e2:	bicne.w	r2, r2, #32
    94e6:	b.n	950c <pinMode+0x5c>
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    94e8:	ldr.w	r0, [r2, r0, lsl #3]
    94ec:	movs	r2, #0
    94ee:	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    94f2:	cbnz	r1, 94fa <pinMode+0x4a>
			*config = PORT_PCR_MUX(1);
    94f4:	mov.w	r2, #256	; 0x100
    94f8:	b.n	950c <pinMode+0x5c>
		} else if (mode == INPUT_PULLUP) {
    94fa:	cmp	r1, #2
    94fc:	bne.n	9504 <pinMode+0x54>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    94fe:	movw	r2, #259	; 0x103
    9502:	b.n	950c <pinMode+0x5c>
		} else if (mode == INPUT_PULLDOWN) {
    9504:	cmp	r1, #3
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    9506:	it	eq
    9508:	moveq.w	r2, #258	; 0x102
		} else { // INPUT_DISABLE
			*config = 0;
    950c:	str	r2, [r3, #0]
    950e:	pop	{r4, pc}
    9510:	.word	0x00012e88

00009514 <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    9514:	cpsid	i
	current = SYST_CVR;
    9516:	ldr	r3, [pc, #44]	; (9544 <micros+0x30>)
	count = systick_millis_count;
    9518:	ldr	r2, [pc, #44]	; (9548 <micros+0x34>)
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    951a:	ldr	r1, [pc, #48]	; (954c <micros+0x38>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    951c:	ldr	r3, [r3, #0]
	count = systick_millis_count;
    951e:	ldr	r2, [r2, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    9520:	ldr	r1, [r1, #0]
	__enable_irq();
    9522:	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    9524:	lsls	r1, r1, #5
    9526:	bpl.n	952e <micros+0x1a>
    9528:	cmp	r3, #50	; 0x32
    952a:	it	hi
    952c:	addhi	r2, #1
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    952e:	rsb	r3, r3, #95744	; 0x17600
    9532:	movs	r0, #96	; 0x60
    9534:	adds	r3, #255	; 0xff
    9536:	udiv	r3, r3, r0
}
    953a:	mov.w	r0, #1000	; 0x3e8
    953e:	mla	r0, r0, r2, r3
    9542:	bx	lr
    9544:	.word	0xe000e018
    9548:	.word	0x2001a6fc
    954c:	.word	0xe000ed04

00009550 <delay>:

void delay(uint32_t ms)
{
    9550:	push	{r3, r4, r5, lr}
    9552:	mov	r4, r0
	uint32_t start = micros();
    9554:	bl	9514 <micros>
    9558:	mov	r5, r0

	if (ms > 0) {
    955a:	cbnz	r4, 9566 <delay+0x16>
    955c:	pop	{r3, r4, r5, pc}
		while (1) {
			while ((micros() - start) >= 1000) {
				ms--;
				if (ms == 0) return;
    955e:	subs	r4, #1
    9560:	beq.n	9578 <delay+0x28>
				start += 1000;
    9562:	add.w	r5, r5, #1000	; 0x3e8
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    9566:	bl	9514 <micros>
    956a:	subs	r0, r0, r5
    956c:	cmp.w	r0, #1000	; 0x3e8
    9570:	bcs.n	955e <delay+0xe>
				ms--;
				if (ms == 0) return;
				start += 1000;
			}
			yield();
    9572:	bl	9f54 <yield>
		}
    9576:	b.n	9566 <delay+0x16>
    9578:	pop	{r3, r4, r5, pc}
    957a:	Address 0x0000957a is out of bounds.


0000957c <_init_Teensyduino_internal_>:
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    957c:	ldr	r3, [pc, #224]	; (9660 <_init_Teensyduino_internal_+0xe4>)
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    957e:	ldr	r1, [pc, #228]	; (9664 <_init_Teensyduino_internal_+0xe8>)
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    9580:	mov.w	r2, #134217728	; 0x8000000
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    9584:	push	{r4, r5, r6, lr}
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    9586:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    9588:	mov.w	r2, #268435456	; 0x10000000
    958c:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    958e:	mov.w	r2, #536870912	; 0x20000000
    9592:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    9594:	mov.w	r2, #1073741824	; 0x40000000
    9598:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    959a:	mov.w	r2, #2147483648	; 0x80000000
    959e:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    95a0:	ldr	r3, [pc, #196]	; (9668 <_init_Teensyduino_internal_+0xec>)
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    95a2:	ldr	r5, [pc, #200]	; (966c <_init_Teensyduino_internal_+0xf0>)
	FTM3_C1SC = 0x28;
    95a4:	ldr	r4, [pc, #200]	; (9670 <_init_Teensyduino_internal_+0xf4>)
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    95a6:	ldr	r6, [pc, #204]	; (9674 <_init_Teensyduino_internal_+0xf8>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    95a8:	movs	r2, #0
	FTM0_MOD = DEFAULT_FTM_MOD;
    95aa:	movw	r0, #49151	; 0xbfff
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    95ae:	str	r2, [r3, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
    95b0:	str	r0, [r3, #4]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    95b2:	movs	r3, #40	; 0x28
    95b4:	str	r3, [r1, #0]
	FTM0_C1SC = 0x28;
    95b6:	str	r3, [r1, #8]
	FTM0_C2SC = 0x28;
    95b8:	str	r3, [r1, #16]
	FTM0_C3SC = 0x28;
    95ba:	str	r3, [r1, #24]
	FTM0_C4SC = 0x28;
    95bc:	str	r3, [r1, #32]
	FTM0_C5SC = 0x28;
    95be:	str	r3, [r1, #40]	; 0x28
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    95c0:	str	r3, [r1, #48]	; 0x30
	FTM0_C7SC = 0x28;
    95c2:	str	r3, [r1, #56]	; 0x38
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
    95c4:	adds	r1, #16
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    95c6:	add.w	r1, r1, #528384	; 0x81000
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    95ca:	str	r3, [r5, #0]
	FTM3_C1SC = 0x28;
    95cc:	str	r3, [r4, #0]
	FTM3_C2SC = 0x28;
    95ce:	str	r3, [r1, #0]
	FTM3_C3SC = 0x28;
    95d0:	str	r3, [r1, #8]
	FTM3_C4SC = 0x28;
    95d2:	str	r3, [r1, #16]
	FTM3_C5SC = 0x28;
    95d4:	str	r3, [r1, #24]
	FTM3_C6SC = 0x28;
    95d6:	str	r3, [r1, #32]
	FTM3_C7SC = 0x28;
    95d8:	str	r3, [r1, #40]	; 0x28
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    95da:	movs	r1, #9
    95dc:	str	r1, [r6, #0]
	FTM1_CNT = 0;
    95de:	add.w	r6, r6, #4096	; 0x1000
    95e2:	adds	r6, #4
    95e4:	str	r2, [r6, #0]
	FTM1_MOD = DEFAULT_FTM_MOD;
    95e6:	str	r0, [r6, #4]
	FTM1_C0SC = 0x28;
    95e8:	str	r3, [r6, #8]
	FTM1_C1SC = 0x28;
    95ea:	str	r3, [r6, #16]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    95ec:	str.w	r1, [r6, #-4]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    95f0:	add.w	r6, r6, #520192	; 0x7f000
    95f4:	str	r2, [r6, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    95f6:	str	r0, [r6, #4]
	FTM2_C0SC = 0x28;
    95f8:	str	r3, [r6, #8]
	FTM2_C1SC = 0x28;
    95fa:	str	r3, [r6, #16]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    95fc:	str.w	r1, [r6, #-4]
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
    9600:	add.w	r6, r6, #4096	; 0x1000
    9604:	str	r2, [r6, #0]
	FTM3_MOD = DEFAULT_FTM_MOD;
    9606:	str	r0, [r6, #4]
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9608:	ldr	r0, [pc, #108]	; (9678 <_init_Teensyduino_internal_+0xfc>)
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
	FTM3_C0SC = 0x28;
    960a:	str	r3, [r5, #0]
	FTM3_C1SC = 0x28;
    960c:	str	r3, [r4, #0]
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    960e:	str	r1, [r0, #0]
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    9610:	sub.w	r0, r0, #460800	; 0x70800
    9614:	subw	r0, r0, #2004	; 0x7d4
    9618:	ldr	r1, [r0, #0]
    961a:	orr.w	r1, r1, #512	; 0x200
    961e:	str	r1, [r0, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    9620:	ldr.w	r1, [r0, #-40]
    9624:	orr.w	r1, r1, #33554432	; 0x2000000
    9628:	str.w	r1, [r0, #-40]
	TPM1_CNT = 0;
    962c:	ldr	r1, [pc, #76]	; (967c <_init_Teensyduino_internal_+0x100>)
    962e:	str	r2, [r1, #0]
	TPM1_MOD = 32767;
    9630:	ldr	r2, [pc, #76]	; (9680 <_init_Teensyduino_internal_+0x104>)
    9632:	movw	r1, #32767	; 0x7fff
    9636:	str	r1, [r2, #0]
	TPM1_C0SC = 0x28;
    9638:	str	r3, [r2, #4]
	TPM1_C1SC = 0x28;
    963a:	str	r3, [r2, #12]
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    963c:	ldr	r3, [pc, #68]	; (9684 <_init_Teensyduino_internal_+0x108>)
    963e:	movs	r2, #8
    9640:	str	r2, [r3, #0]
#endif
	analog_init();
    9642:	bl	a3bc <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	startup_middle_hook();
    9646:	bl	946c <startup_middle_hook>
	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    964a:	movs	r0, #20
    964c:	bl	9550 <delay>
	usb_init();
    9650:	bl	9ec0 <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    9654:	mov.w	r0, #280	; 0x118
}
    9658:	ldmia.w	sp!, {r4, r5, r6, lr}
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	startup_middle_hook();
	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    965c:	b.w	9550 <delay>
    9660:	.word	0xe000e104
    9664:	.word	0x4003800c
    9668:	.word	0x40038004
    966c:	.word	0x400b900c
    9670:	.word	0x400b9014
    9674:	.word	0x40038000
    9678:	.word	0x400b9000
    967c:	.word	0x400c9004
    9680:	.word	0x400c9008
    9684:	.word	0x400c9000

00009688 <usb_malloc>:
// http://www.archivum.info/gnu.gcc.help/2006-08/00148/Re-GCC-Inline-Assembly.html
// http://gcc.gnu.org/ml/gcc/2012-06/msg00015.html
// __builtin_clz()

usb_packet_t * usb_malloc(void)
{
    9688:	push	{r4, lr}
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    968a:	cpsid	i
	avail = usb_buffer_available;
    968c:	ldr	r0, [pc, #44]	; (96bc <usb_malloc+0x34>)
    968e:	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    9690:	clz	r1, r2
	if (n >= NUM_USB_BUFFERS) {
    9694:	cmp	r1, #11
    9696:	ble.n	969e <usb_malloc+0x16>
		__enable_irq();
    9698:	cpsie	i
		return NULL;
    969a:	movs	r0, #0
    969c:	pop	{r4, pc}
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    969e:	mov.w	r3, #2147483648	; 0x80000000
    96a2:	lsrs	r3, r1
    96a4:	bic.w	r2, r2, r3
    96a8:	str	r2, [r0, #0]
	__enable_irq();
    96aa:	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    96ac:	ldr	r4, [pc, #16]	; (96c0 <usb_malloc+0x38>)
    96ae:	movs	r3, #72	; 0x48
    96b0:	muls	r3, r1
    96b2:	adds	r0, r4, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    96b4:	movs	r2, #0
    96b6:	str	r2, [r4, r3]
	*(uint32_t *)(p + 4) = 0;
    96b8:	str	r2, [r0, #4]
	return (usb_packet_t *)p;
}
    96ba:	pop	{r4, pc}
    96bc:	.word	0x1fff1340
    96c0:	.word	0x1fff0bd0

000096c4 <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    96c4:	ldr	r3, [pc, #48]	; (96f8 <usb_free+0x34>)
    96c6:	movs	r2, #72	; 0x48
    96c8:	subs	r3, r0, r3
    96ca:	udiv	r3, r3, r2
	if (n >= NUM_USB_BUFFERS) return;
    96ce:	cmp	r3, #11
    96d0:	bhi.n	96f6 <usb_free+0x32>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    96d2:	ldr	r2, [pc, #40]	; (96fc <usb_free+0x38>)
    96d4:	ldrb	r2, [r2, #0]
    96d6:	cbz	r2, 96e2 <usb_free+0x1e>
    96d8:	ldr	r2, [pc, #36]	; (9700 <usb_free+0x3c>)
    96da:	ldrb	r2, [r2, #0]
    96dc:	cbz	r2, 96e2 <usb_free+0x1e>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    96de:	b.w	97a4 <usb_rx_memory>
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    96e2:	cpsid	i
	usb_buffer_available |= mask;
    96e4:	ldr	r1, [pc, #28]	; (9704 <usb_free+0x40>)
    96e6:	mov.w	r2, #2147483648	; 0x80000000
    96ea:	lsr.w	r3, r2, r3
    96ee:	ldr	r2, [r1, #0]
    96f0:	orrs	r2, r3
    96f2:	str	r2, [r1, #0]
	__enable_irq();
    96f4:	cpsie	i
    96f6:	bx	lr
    96f8:	.word	0x1fff0bd0
    96fc:	.word	0x2001a7d6
    9700:	.word	0x2001a7df
    9704:	.word	0x1fff1340

00009708 <endpoint0_transmit>:
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
}


static void endpoint0_transmit(const void *data, uint32_t len)
{
    9708:	push	{r4, r5, r6, r7, lr}
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    970a:	ldr	r4, [pc, #48]	; (973c <endpoint0_transmit+0x34>)
    970c:	ldr	r6, [pc, #48]	; (9740 <endpoint0_transmit+0x38>)
    970e:	ldrb	r3, [r4, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9710:	ldr	r5, [pc, #48]	; (9744 <endpoint0_transmit+0x3c>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    9712:	orr.w	r7, r3, #2
    9716:	add.w	r2, r6, r7, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    971a:	eor.w	r3, r3, #1
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    971e:	str	r0, [r2, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9720:	ldrb	r2, [r5, #0]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    9722:	strb	r3, [r4, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9724:	cmp	r2, #0
    9726:	ite	ne
    9728:	movne	r0, #200	; 0xc8
    972a:	moveq	r0, #136	; 0x88
	ep0_tx_data_toggle ^= 1;
    972c:	eor.w	r2, r2, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9730:	orr.w	r1, r0, r1, lsl #16
	ep0_tx_data_toggle ^= 1;
    9734:	strb	r2, [r5, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9736:	str.w	r1, [r6, r7, lsl #3]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    973a:	pop	{r4, r5, r6, r7, pc}
    973c:	.word	0x2001a768
    9740:	.word	0x1fff0000
    9744:	.word	0x2001a7e0

00009748 <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    9748:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    974a:	cmp	r3, #3




usb_packet_t *usb_rx(uint32_t endpoint)
{
    974c:	push	{r4, lr}
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    974e:	bhi.n	9772 <usb_rx+0x2a>
	__disable_irq();
    9750:	cpsid	i
	ret = rx_first[endpoint];
    9752:	ldr	r2, [pc, #36]	; (9778 <usb_rx+0x30>)
    9754:	ldr.w	r0, [r2, r3, lsl #2]
	if (ret) {
    9758:	cbz	r0, 976e <usb_rx+0x26>
		rx_first[endpoint] = ret->next;
    975a:	ldr	r1, [r0, #4]
    975c:	str.w	r1, [r2, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    9760:	ldr	r1, [pc, #24]	; (977c <usb_rx+0x34>)
    9762:	ldrh	r4, [r0, #0]
    9764:	ldrh.w	r2, [r1, r3, lsl #1]
    9768:	subs	r2, r2, r4
    976a:	strh.w	r2, [r1, r3, lsl #1]
	}
	__enable_irq();
    976e:	cpsie	i
	//serial_print("rx, epidx=");
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
    9770:	pop	{r4, pc}

usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    9772:	movs	r0, #0
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    9774:	pop	{r4, pc}
    9776:	nop
    9778:	.word	0x2001a758
    977c:	.word	0x2001a854

00009780 <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    9780:	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    9782:	cmp	r0, #3
    9784:	bhi.n	979c <usb_tx_packet_count+0x1c>
	__disable_irq();
    9786:	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    9788:	ldr	r3, [pc, #20]	; (97a0 <usb_tx_packet_count+0x20>)
    978a:	ldr.w	r3, [r3, r0, lsl #2]
// https://forum.pjrc.com/threads/58663?p=223513&viewfull=1#post223513
//
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;
    978e:	movs	r0, #0

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    9790:	cbz	r3, 9798 <usb_tx_packet_count+0x18>
    9792:	adds	r0, #1
    9794:	ldr	r3, [r3, #4]
    9796:	b.n	9790 <usb_tx_packet_count+0x10>
	__enable_irq();
    9798:	cpsie	i
	return count;
    979a:	bx	lr
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
    979c:	movs	r0, #0
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
	__enable_irq();
	return count;
}
    979e:	bx	lr
    97a0:	.word	0x2001a7ac

000097a4 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    97a4:	push	{r4, r5, r6}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    97a6:	cpsid	i
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    97a8:	ldr	r5, [pc, #92]	; (9808 <usb_rx_memory+0x64>)
			if (table[index(i, RX, EVEN)].desc == 0) {
    97aa:	ldr	r4, [pc, #96]	; (980c <usb_rx_memory+0x68>)
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    97ac:	movs	r3, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    97ae:	adds	r2, r3, r5
    97b0:	ldrb.w	r2, [r2, #-1]
    97b4:	lsls	r2, r2, #28
    97b6:	bpl.n	97f4 <usb_rx_memory+0x50>
			if (table[index(i, RX, EVEN)].desc == 0) {
    97b8:	lsls	r2, r3, #2
    97ba:	ldr	r1, [pc, #80]	; (980c <usb_rx_memory+0x68>)
    97bc:	ldr.w	r6, [r4, r2, lsl #3]
    97c0:	cbnz	r6, 97ce <usb_rx_memory+0x2a>
				table[index(i, RX, EVEN)].addr = packet->buf;
    97c2:	add.w	r3, r1, r3, lsl #5
    97c6:	adds	r0, #8
    97c8:	str	r0, [r3, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    97ca:	ldr	r3, [pc, #68]	; (9810 <usb_rx_memory+0x6c>)
    97cc:	b.n	97e2 <usb_rx_memory+0x3e>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    97ce:	orr.w	r2, r2, #1
    97d2:	ldr.w	r6, [r4, r2, lsl #3]
    97d6:	cbnz	r6, 97f4 <usb_rx_memory+0x50>
				table[index(i, RX, ODD)].addr = packet->buf;
    97d8:	add.w	r3, r1, r2, lsl #3
    97dc:	adds	r0, #8
    97de:	str	r0, [r3, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    97e0:	ldr	r3, [pc, #48]	; (9814 <usb_rx_memory+0x70>)
    97e2:	str.w	r3, [r1, r2, lsl #3]
				usb_rx_memory_needed--;
    97e6:	ldr	r2, [pc, #48]	; (9818 <usb_rx_memory+0x74>)
    97e8:	ldrb	r3, [r2, #0]
    97ea:	subs	r3, #1
    97ec:	strb	r3, [r2, #0]
				__enable_irq();
    97ee:	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
    97f0:	pop	{r4, r5, r6}
    97f2:	bx	lr
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    97f4:	adds	r3, #1
    97f6:	cmp	r3, #5
    97f8:	bne.n	97ae <usb_rx_memory+0xa>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    97fa:	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    97fc:	ldr	r3, [pc, #24]	; (9818 <usb_rx_memory+0x74>)
    97fe:	movs	r2, #0
    9800:	strb	r2, [r3, #0]
	usb_free(packet);
	return;
}
    9802:	pop	{r4, r5, r6}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
    9804:	b.w	96c4 <usb_free>
    9808:	.word	0x000130b2
    980c:	.word	0x1fff0000
    9810:	.word	0x00400088
    9814:	.word	0x004000c8
    9818:	.word	0x2001a7d6

0000981c <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    981c:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    981e:	cmp	r3, #3

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    9820:	push	{r4, lr}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
    9822:	bhi.n	988a <usb_tx+0x6e>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    9824:	ldr	r2, [pc, #100]	; (988c <usb_tx+0x70>)
    9826:	lsls	r0, r0, #5
    9828:	orr.w	r0, r0, #16
    982c:	add	r0, r2
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    982e:	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    9830:	ldr	r2, [pc, #92]	; (9890 <usb_tx+0x74>)
    9832:	ldrb	r4, [r2, r3]
    9834:	cmp	r4, #3
    9836:	bhi.n	9850 <usb_tx+0x34>
    9838:	tbb	[pc, r4]
    983c:	.word	0x07020418
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
		next = TX_STATE_EVEN_FREE;
		break;
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    9840:	movs	r4, #5
    9842:	b.n	986e <usb_tx+0x52>
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    9844:	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    9846:	movs	r4, #2
		break;
    9848:	b.n	986e <usb_tx+0x52>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    984a:	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    984c:	movs	r4, #4
		break;
    984e:	b.n	986e <usb_tx+0x52>
	  default:
		if (tx_first[endpoint] == NULL) {
    9850:	ldr	r0, [pc, #64]	; (9894 <usb_tx+0x78>)
    9852:	ldr	r2, [pc, #68]	; (9898 <usb_tx+0x7c>)
    9854:	ldr.w	r4, [r0, r3, lsl #2]
    9858:	cbnz	r4, 9860 <usb_tx+0x44>
			tx_first[endpoint] = packet;
    985a:	str.w	r1, [r0, r3, lsl #2]
    985e:	b.n	9866 <usb_tx+0x4a>
		} else {
			tx_last[endpoint]->next = packet;
    9860:	ldr.w	r0, [r2, r3, lsl #2]
    9864:	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    9866:	str.w	r1, [r2, r3, lsl #2]
    986a:	b.n	9888 <usb_tx+0x6c>
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    986c:	movs	r4, #3
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    986e:	strb	r4, [r2, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9870:	tst.w	r0, #8
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    9874:	add.w	r3, r1, #8
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9878:	ldrh	r2, [r1, #0]
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    987a:	str	r3, [r0, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    987c:	ite	ne
    987e:	movne	r3, #200	; 0xc8
    9880:	moveq	r3, #136	; 0x88
    9882:	orr.w	r3, r3, r2, lsl #16
    9886:	str	r3, [r0, #0]
	__enable_irq();
    9888:	cpsie	i
    988a:	pop	{r4, pc}
    988c:	.word	0x1fff0000
    9890:	.word	0x2001a714
    9894:	.word	0x2001a7ac
    9898:	.word	0x2001a7bc

0000989c <usb_isr>:
}



void usb_isr(void)
{
    989c:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    98a0:	ldr.w	r8, [pc, #680]	; 9b4c <usb_isr+0x2b0>
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    98a4:	ldr	r3, [pc, #676]	; (9b4c <usb_isr+0x2b0>)
    98a6:	ldrb	r4, [r3, #0]
    98a8:	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    98aa:	tst.w	r4, #4
    98ae:	mov	r5, r3
    98b0:	beq.n	98e8 <usb_isr+0x4c>
		if (usb_configuration) {
    98b2:	ldr	r3, [pc, #668]	; (9b50 <usb_isr+0x2b4>)
    98b4:	ldrb	r3, [r3, #0]
    98b6:	cbz	r3, 98e2 <usb_isr+0x46>
			t = usb_reboot_timer;
    98b8:	ldr	r2, [pc, #664]	; (9b54 <usb_isr+0x2b8>)
    98ba:	ldrb	r1, [r2, #0]
			if (t) {
    98bc:	and.w	r3, r1, #255	; 0xff
    98c0:	cbz	r1, 98cc <usb_isr+0x30>
				usb_reboot_timer = --t;
    98c2:	subs	r3, #1
    98c4:	uxtb	r3, r3
    98c6:	strb	r3, [r2, #0]
				if (!t) _reboot_Teensyduino_();
    98c8:	cbnz	r3, 98cc <usb_isr+0x30>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    98ca:	bkpt	0x0000
			if (t) {
				usb_reboot_timer = --t;
				if (!t) _reboot_Teensyduino_();
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    98cc:	ldr	r2, [pc, #648]	; (9b58 <usb_isr+0x2bc>)
    98ce:	ldrb	r1, [r2, #0]
			if (t) {
    98d0:	and.w	r3, r1, #255	; 0xff
    98d4:	cbz	r1, 98e2 <usb_isr+0x46>
				usb_cdc_transmit_flush_timer = --t;
    98d6:	subs	r3, #1
    98d8:	uxtb	r3, r3
    98da:	strb	r3, [r2, #0]
				if (t == 0) usb_serial_flush_callback();
    98dc:	cbnz	r3, 98e2 <usb_isr+0x46>
    98de:	bl	936c <usb_serial_flush_callback>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    98e2:	movs	r3, #4
    98e4:	strb.w	r3, [r8]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    98e8:	and.w	r3, r4, #8
    98ec:	and.w	r2, r3, #255	; 0xff
    98f0:	cmp	r3, #0
    98f2:	beq.w	9ddc <usb_isr+0x540>
		uint8_t endpoint;
		stat = USB0_STAT;
    98f6:	ldr	r3, [pc, #612]	; (9b5c <usb_isr+0x2c0>)
    98f8:	ldr	r4, [pc, #612]	; (9b60 <usb_isr+0x2c4>)
    98fa:	ldrb	r3, [r3, #0]
    98fc:	uxtb	r3, r3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    98fe:	lsrs	r7, r3, #4
    9900:	mov.w	r6, r3, lsr #2
    9904:	bne.w	9ce4 <usb_isr+0x448>
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
    9908:	ldr.w	r3, [r4, r6, lsl #3]
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    990c:	add.w	r2, r4, r6, lsl #3
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    9910:	ubfx	r3, r3, #2, #4
    9914:	subs	r3, #1
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    9916:	ldr	r2, [r2, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    9918:	cmp	r3, #12
    991a:	bhi.w	9cdc <usb_isr+0x440>
    991e:	tbh	[pc, r3, lsl #1]
    9922:	.short	0x019e
    9924:	.word	0x01dd019e
    9928:	.word	0x01dd01dd
    992c:	.word	0x01dd01dd
    9930:	.word	0x01bb01dd
    9934:	.word	0x01dd01dd
    9938:	.word	0x000d01dd
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    993c:	ldr	r5, [pc, #548]	; (9b64 <usb_isr+0x2c8>)
		setup.word2 = *(uint32_t *)(buf + 4);
    993e:	ldr	r3, [r2, #4]
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    9940:	ldr	r1, [r2, #0]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    9942:	ldr	r0, [pc, #548]	; (9b68 <usb_isr+0x2cc>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    9944:	str	r3, [r5, #4]

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    9946:	ldr	r3, [pc, #548]	; (9b6c <usb_isr+0x2d0>)
    9948:	str.w	r3, [r4, r6, lsl #3]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    994c:	movs	r3, #1
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    994e:	str	r1, [r5, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    9950:	ldr.w	sl, [pc, #584]	; 9b9c <usb_isr+0x300>
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    9954:	strb	r3, [r0, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    9956:	uxth	r1, r1
    9958:	movw	r0, #1665	; 0x681
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    995c:	movs	r2, #0
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    995e:	cmp	r1, r0
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    9960:	str	r2, [r4, #16]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    9962:	str.w	r2, [sl]
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
    9966:	str	r2, [r4, #24]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    9968:	bhi.n	999a <usb_isr+0xfe>
    996a:	cmp.w	r1, #1664	; 0x680
    996e:	bcs.w	9bc2 <usb_isr+0x326>
    9972:	cmp.w	r1, #258	; 0x102
    9976:	beq.w	9b2c <usb_isr+0x290>
    997a:	bhi.n	998a <usb_isr+0xee>
    997c:	cmp	r1, #128	; 0x80
    997e:	beq.w	9b06 <usb_isr+0x26a>
    9982:	cmp	r1, #130	; 0x82
    9984:	beq.w	9b0e <usb_isr+0x272>
    9988:	b.n	9bfc <usb_isr+0x360>
    998a:	movw	r3, #770	; 0x302
    998e:	cmp	r1, r3
    9990:	beq.w	9ba4 <usb_isr+0x308>
    9994:	cmp.w	r1, #1280	; 0x500
    9998:	b.n	99d2 <usb_isr+0x136>
    999a:	movw	r0, #8225	; 0x2021
    999e:	cmp	r1, r0
    99a0:	beq.w	9c58 <usb_isr+0x3bc>
    99a4:	bhi.n	99c2 <usb_isr+0x126>
    99a6:	cmp.w	r1, #2176	; 0x880
    99aa:	beq.w	9afc <usb_isr+0x260>
    99ae:	cmp.w	r1, #2304	; 0x900
    99b2:	bne.w	9bfc <usb_isr+0x360>
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    99b6:	ldr	r3, [pc, #408]	; (9b50 <usb_isr+0x2b4>)
    99b8:	ldrb	r2, [r5, #2]
    99ba:	strb	r2, [r3, #0]
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    99bc:	movs	r6, #4
			if (table[i].desc & BDT_OWN) {
    99be:	ldr	r7, [pc, #416]	; (9b60 <usb_isr+0x2c4>)
    99c0:	b.n	99d8 <usb_isr+0x13c>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    99c2:	movw	r3, #8737	; 0x2221
    99c6:	cmp	r1, r3
    99c8:	beq.w	9be8 <usb_isr+0x34c>
    99cc:	movw	r3, #8993	; 0x2321
    99d0:	cmp	r1, r3
    99d2:	beq.w	9c04 <usb_isr+0x368>
    99d6:	b.n	9bfc <usb_isr+0x360>
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    99d8:	ldr.w	r3, [r4, r6, lsl #3]
    99dc:	lsls	r3, r3, #24
    99de:	bpl.n	99ec <usb_isr+0x150>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    99e0:	add.w	r3, r7, r6, lsl #3
    99e4:	ldr	r0, [r3, #4]
    99e6:	subs	r0, #8
    99e8:	bl	96c4 <usb_free>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    99ec:	adds	r6, #1
    99ee:	cmp	r6, #20
    99f0:	bne.n	99d8 <usb_isr+0x13c>
    99f2:	ldr	r7, [pc, #380]	; (9b70 <usb_isr+0x2d4>)
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    99f4:	ldr.w	fp, [pc, #380]	; 9b74 <usb_isr+0x2d8>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    99f8:	movs	r6, #0
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    99fa:	ldr.w	r0, [fp, r6, lsl #2]
    99fe:	mov.w	r9, r6, lsl #2
			while (p) {
    9a02:	cbz	r0, 9a12 <usb_isr+0x176>
				n = p->next;
    9a04:	ldr	r2, [r0, #4]
    9a06:	str	r2, [sp, #0]
				usb_free(p);
    9a08:	bl	96c4 <usb_free>
				p = n;
    9a0c:	ldr	r2, [sp, #0]
    9a0e:	mov	r0, r2
    9a10:	b.n	9a02 <usb_isr+0x166>
			}
			rx_first[i] = NULL;
    9a12:	ldr	r3, [pc, #352]	; (9b74 <usb_isr+0x2d8>)
			rx_last[i] = NULL;
			p = tx_first[i];
    9a14:	ldr	r2, [pc, #352]	; (9b78 <usb_isr+0x2dc>)
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
    9a16:	str.w	r0, [r3, r9]
			rx_last[i] = NULL;
    9a1a:	ldr	r3, [pc, #352]	; (9b7c <usb_isr+0x2e0>)
    9a1c:	str.w	r0, [r9, r3]
			p = tx_first[i];
    9a20:	ldr.w	r0, [r9, r2]
			while (p) {
    9a24:	cbz	r0, 9a38 <usb_isr+0x19c>
				n = p->next;
    9a26:	ldr	r1, [r0, #4]
    9a28:	str	r2, [sp, #4]
    9a2a:	str	r1, [sp, #0]
				usb_free(p);
    9a2c:	bl	96c4 <usb_free>
				p = n;
    9a30:	ldr	r1, [sp, #0]
    9a32:	ldr	r2, [sp, #4]
    9a34:	mov	r0, r1
    9a36:	b.n	9a24 <usb_isr+0x188>
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    9a38:	ldr	r3, [pc, #324]	; (9b80 <usb_isr+0x2e4>)
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    9a3a:	str.w	r0, [r2, r9]
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    9a3e:	strh.w	r0, [r3, r6, lsl #1]
			switch (tx_state[i]) {
    9a42:	ldrb	r3, [r7, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    9a44:	ldr	r2, [pc, #316]	; (9b84 <usb_isr+0x2e8>)
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    9a46:	subs	r3, #2
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    9a48:	str.w	r0, [r9, r2]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    9a4c:	cmp	r3, #3
    9a4e:	bhi.n	9a60 <usb_isr+0x1c4>
    9a50:	tbb	[pc, r3]
    9a54:	.word	0x04020402
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    9a58:	movs	r3, #0
    9a5a:	b.n	9a5e <usb_isr+0x1c2>
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    9a5c:	movs	r3, #1
    9a5e:	strb	r3, [r7, #0]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    9a60:	adds	r6, #1
    9a62:	cmp	r6, #4
    9a64:	add.w	r7, r7, #1
    9a68:	bne.n	99fa <usb_isr+0x15e>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    9a6a:	ldr	r1, [pc, #284]	; (9b88 <usb_isr+0x2ec>)
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
    9a6c:	ldr.w	r9, [pc, #304]	; 9ba0 <usb_isr+0x304>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    9a70:	movs	r3, #0
    9a72:	strb	r3, [r1, #0]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    9a74:	mov.w	fp, #1
    9a78:	mov	r7, r1
    9a7a:	ldr	r3, [pc, #272]	; (9b8c <usb_isr+0x2f0>)
			epconf = *cfg++;
    9a7c:	add.w	r0, fp, r9
    9a80:	add	r3, fp
    9a82:	ldrb.w	r0, [r0, #-1]
    9a86:	lsls	r3, r3, #2
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    9a88:	tst.w	r0, #8
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
			*reg = epconf;
    9a8c:	strb	r0, [r3, #0]
    9a8e:	mov.w	r6, fp, lsl #2
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    9a92:	beq.n	9adc <usb_isr+0x240>
				usb_packet_t *p;
				p = usb_malloc();
    9a94:	bl	9688 <usb_malloc>
				if (p) {
    9a98:	cbz	r0, 9aac <usb_isr+0x210>
					table[index(i, RX, EVEN)].addr = p->buf;
    9a9a:	add.w	lr, r4, fp, lsl #5
    9a9e:	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    9aa0:	ldr	r3, [pc, #236]	; (9b90 <usb_isr+0x2f4>)
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
    9aa2:	str.w	r0, [lr, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    9aa6:	str.w	r3, [r4, r6, lsl #3]
    9aaa:	b.n	9ab6 <usb_isr+0x21a>
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    9aac:	str.w	r0, [r4, r6, lsl #3]
					usb_rx_memory_needed++;
    9ab0:	ldrb	r0, [r7, #0]
    9ab2:	adds	r0, #1
    9ab4:	strb	r0, [r7, #0]
				}
				p = usb_malloc();
    9ab6:	bl	9688 <usb_malloc>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    9aba:	orr.w	lr, r6, #1
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
    9abe:	cbz	r0, 9ad2 <usb_isr+0x236>
					table[index(i, RX, ODD)].addr = p->buf;
    9ac0:	add.w	ip, r4, lr, lsl #3
    9ac4:	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    9ac6:	ldr	r3, [pc, #164]	; (9b6c <usb_isr+0x2d0>)
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    9ac8:	str.w	r0, [ip, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    9acc:	str.w	r3, [r4, lr, lsl #3]
    9ad0:	b.n	9adc <usb_isr+0x240>
				} else {
					table[index(i, RX, ODD)].desc = 0;
    9ad2:	str.w	r0, [r4, lr, lsl #3]
					usb_rx_memory_needed++;
    9ad6:	ldrb	r0, [r7, #0]
    9ad8:	adds	r0, #1
    9ada:	strb	r0, [r7, #0]
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    9adc:	orr.w	lr, r6, #2
			table[index(i, TX, ODD)].desc = 0;
    9ae0:	orr.w	r3, r6, #3
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    9ae4:	add.w	fp, fp, #1
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    9ae8:	movs	r0, #0
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    9aea:	cmp.w	fp, #5
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    9aee:	str.w	r0, [r4, lr, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
    9af2:	str.w	r0, [r4, r3, lsl #3]
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    9af6:	bne.n	9a7a <usb_isr+0x1de>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    9af8:	mov	r3, r0
    9afa:	b.n	9c0e <usb_isr+0x372>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    9afc:	ldr	r2, [pc, #80]	; (9b50 <usb_isr+0x2b4>)
    9afe:	ldr	r6, [pc, #148]	; (9b94 <usb_isr+0x2f8>)
    9b00:	ldrb	r2, [r2, #0]
    9b02:	strb	r2, [r6, #0]
    9b04:	b.n	9c10 <usb_isr+0x374>
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    9b06:	ldr	r6, [pc, #140]	; (9b94 <usb_isr+0x2f8>)
    9b08:	strb	r2, [r6, #0]
		reply_buffer[1] = 0;
    9b0a:	strb	r2, [r6, #1]
    9b0c:	b.n	9c08 <usb_isr+0x36c>
    9b0e:	ldrh	r1, [r5, #4]
    9b10:	and.w	r1, r1, #127	; 0x7f
		datalen = 2;
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    9b14:	cmp	r1, #4
    9b16:	bhi.n	9bfc <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    9b18:	ldr	r6, [pc, #120]	; (9b94 <usb_isr+0x2f8>)
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    9b1a:	lsls	r1, r1, #2
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    9b1c:	strb	r2, [r6, #0]
		reply_buffer[1] = 0;
    9b1e:	strb	r2, [r6, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    9b20:	ldr	r2, [pc, #116]	; (9b98 <usb_isr+0x2fc>)
    9b22:	ldrb	r2, [r2, r1]
    9b24:	lsls	r4, r2, #30
    9b26:	bpl.n	9c08 <usb_isr+0x36c>
    9b28:	strb	r3, [r6, #0]
    9b2a:	b.n	9c08 <usb_isr+0x36c>
    9b2c:	ldrh	r2, [r5, #4]
    9b2e:	and.w	r2, r2, #127	; 0x7f
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    9b32:	cmp	r2, #4
    9b34:	bhi.n	9bfc <usb_isr+0x360>
    9b36:	ldrh	r3, [r5, #2]
    9b38:	cmp	r3, #0
    9b3a:	bne.n	9bfc <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    9b3c:	ldr	r1, [pc, #88]	; (9b98 <usb_isr+0x2fc>)
    9b3e:	lsls	r2, r2, #2
    9b40:	add	r1, r2
    9b42:	ldrb	r2, [r1, #0]
    9b44:	bic.w	r2, r2, #2
    9b48:	b.n	9bbe <usb_isr+0x322>
    9b4a:	nop
    9b4c:	.word	0x40072080
    9b50:	.word	0x2001a7df
    9b54:	.word	0x2001a769
    9b58:	.word	0x2001a6e8
    9b5c:	.word	0x40072090
    9b60:	.word	0x1fff0000
    9b64:	.word	0x2001a7cc
    9b68:	.word	0x2001a7e0
    9b6c:	.word	0x004000c8
    9b70:	.word	0x2001a714
    9b74:	.word	0x2001a758
    9b78:	.word	0x2001a7ac
    9b7c:	.word	0x2001a704
    9b80:	.word	0x2001a854
    9b84:	.word	0x2001a7bc
    9b88:	.word	0x2001a7d6
    9b8c:	.word	0x1001c830
    9b90:	.word	0x00400088
    9b94:	.word	0x2001a7d7
    9b98:	.word	0x400720c0
    9b9c:	.word	0x2001a700
    9ba0:	.word	0x000130b2
    9ba4:	ldrh	r2, [r5, #4]
    9ba6:	and.w	r2, r2, #127	; 0x7f
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    9baa:	cmp	r2, #4
    9bac:	bhi.n	9bfc <usb_isr+0x360>
    9bae:	ldrh	r3, [r5, #2]
    9bb0:	cbnz	r3, 9bfc <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    9bb2:	ldr	r1, [pc, #620]	; (9e20 <usb_isr+0x584>)
    9bb4:	lsls	r2, r2, #2
    9bb6:	add	r1, r2
    9bb8:	ldrb	r2, [r1, #0]
    9bba:	orr.w	r2, r2, #2
    9bbe:	strb	r2, [r1, #0]
    9bc0:	b.n	9c0e <usb_isr+0x372>
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    9bc2:	ldrh	r2, [r5, #2]
    9bc4:	ldrh	r1, [r5, #4]
    9bc6:	ldr	r3, [pc, #604]	; (9e24 <usb_isr+0x588>)
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    9bc8:	ldr	r6, [r3, #4]
    9bca:	cbz	r6, 9bfc <usb_isr+0x360>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    9bcc:	ldrh	r0, [r3, #0]
    9bce:	cmp	r0, r2
    9bd0:	bne.n	9be4 <usb_isr+0x348>
    9bd2:	ldrh	r0, [r3, #2]
    9bd4:	cmp	r0, r1
    9bd6:	bne.n	9be4 <usb_isr+0x348>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    9bd8:	lsrs	r2, r2, #8
    9bda:	cmp	r2, #3
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    9bdc:	ite	eq
    9bde:	ldrbeq	r3, [r6, #0]
				} else {
					datalen = list->length;
    9be0:	ldrhne	r3, [r3, #8]
    9be2:	b.n	9c10 <usb_isr+0x374>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    9be4:	adds	r3, #12
    9be6:	b.n	9bc8 <usb_isr+0x32c>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    9be8:	ldrh	r3, [r5, #4]
    9bea:	cbnz	r3, 9c0c <usb_isr+0x370>
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    9bec:	ldr	r2, [pc, #568]	; (9e28 <usb_isr+0x58c>)
    9bee:	ldr	r1, [r2, #0]
    9bf0:	ldr	r2, [pc, #568]	; (9e2c <usb_isr+0x590>)
    9bf2:	str	r1, [r2, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    9bf4:	ldr	r2, [pc, #568]	; (9e30 <usb_isr+0x594>)
    9bf6:	ldrb	r1, [r5, #2]
    9bf8:	strb	r1, [r2, #0]
    9bfa:	b.n	9c0e <usb_isr+0x372>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9bfc:	ldr	r3, [pc, #544]	; (9e20 <usb_isr+0x584>)
    9bfe:	movs	r2, #15
    9c00:	strb	r2, [r3, #0]
    9c02:	b.n	9c58 <usb_isr+0x3bc>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    9c04:	movs	r3, #0
    9c06:	b.n	9c0e <usb_isr+0x372>
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    9c08:	movs	r3, #2
    9c0a:	b.n	9c10 <usb_isr+0x374>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    9c0c:	mov	r3, r2

static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
    9c0e:	mov	r6, r3
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    9c10:	ldrh	r4, [r5, #6]
    9c12:	cmp	r4, r3
    9c14:	it	cs
    9c16:	movcs	r4, r3
    9c18:	cmp	r4, #64	; 0x40
    9c1a:	mov	r5, r4
    9c1c:	it	cs
    9c1e:	movcs	r5, #64	; 0x40
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
    9c20:	mov	r0, r6
    9c22:	mov	r1, r5
    9c24:	bl	9708 <endpoint0_transmit>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9c28:	subs	r4, r4, r5

	if (datalen > setup.wLength) datalen = setup.wLength;
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    9c2a:	add	r6, r5
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9c2c:	bne.n	9c36 <usb_isr+0x39a>
    9c2e:	cmp	r5, #64	; 0x40
    9c30:	bne.n	9c58 <usb_isr+0x3bc>
    9c32:	mov	r5, r4
    9c34:	b.n	9c3e <usb_isr+0x3a2>
    9c36:	cmp	r4, #64	; 0x40
    9c38:	mov	r5, r4
    9c3a:	it	cs
    9c3c:	movcs	r5, #64	; 0x40

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
    9c3e:	mov	r0, r6
    9c40:	mov	r1, r5
    9c42:	bl	9708 <endpoint0_transmit>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9c46:	subs	r4, r4, r5
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    9c48:	add	r6, r5
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9c4a:	bne.n	9c50 <usb_isr+0x3b4>
    9c4c:	cmp	r5, #64	; 0x40
    9c4e:	bne.n	9c58 <usb_isr+0x3bc>

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    9c50:	ldr	r3, [pc, #480]	; (9e34 <usb_isr+0x598>)
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    9c52:	str.w	r6, [sl]
	ep0_tx_len = datalen;
    9c56:	strh	r4, [r3, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    9c58:	movs	r2, #1
    9c5a:	ldr	r3, [pc, #476]	; (9e38 <usb_isr+0x59c>)
    9c5c:	b.n	9cda <usb_isr+0x43e>
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    9c5e:	ldr	r3, [pc, #476]	; (9e3c <usb_isr+0x5a0>)
    9c60:	ldrh	r0, [r3, #0]
    9c62:	movw	r1, #8225	; 0x2021
    9c66:	cmp	r0, r1
    9c68:	bne.n	9c90 <usb_isr+0x3f4>
			int i;
			uint32_t *line_coding = NULL;
			switch (setup.wIndex) {
    9c6a:	ldrh	r3, [r3, #4]
    9c6c:	cbnz	r3, 9c88 <usb_isr+0x3ec>
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
					//serial_phex(*buf);
					*dst++ = *buf++;
    9c6e:	ldr	r1, [pc, #464]	; (9e40 <usb_isr+0x5a4>)
    9c70:	ldrb	r0, [r2, r3]
    9c72:	strb	r0, [r3, r1]
#endif
			}
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
    9c74:	adds	r3, #1
    9c76:	cmp	r3, #7
    9c78:	bne.n	9c70 <usb_isr+0x3d4>
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    9c7a:	ldr	r3, [pc, #452]	; (9e40 <usb_isr+0x5a4>)
    9c7c:	ldr	r3, [r3, #0]
    9c7e:	cmp	r3, #134	; 0x86
    9c80:	ittt	eq
    9c82:	ldreq	r3, [pc, #448]	; (9e44 <usb_isr+0x5a8>)
    9c84:	moveq	r2, #15
    9c86:	strbeq	r2, [r3, #0]
			}
			endpoint0_transmit(NULL, 0);
    9c88:	movs	r1, #0
    9c8a:	mov	r0, r1
    9c8c:	bl	9708 <endpoint0_transmit>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    9c90:	ldr	r3, [pc, #436]	; (9e48 <usb_isr+0x5ac>)
    9c92:	str.w	r3, [r4, r6, lsl #3]
    9c96:	b.n	9cdc <usb_isr+0x440>
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    9c98:	ldr	r7, [pc, #432]	; (9e4c <usb_isr+0x5b0>)
    9c9a:	ldr	r6, [r7, #0]
		if (data) {
    9c9c:	cbz	r6, 9cc8 <usb_isr+0x42c>
			size = ep0_tx_len;
    9c9e:	ldr.w	sl, [pc, #404]	; 9e34 <usb_isr+0x598>
    9ca2:	ldrh.w	r4, [sl]
    9ca6:	cmp	r4, #64	; 0x40
    9ca8:	mov	r5, r4
    9caa:	it	cs
    9cac:	movcs	r5, #64	; 0x40
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
    9cae:	mov	r0, r6
    9cb0:	mov	r1, r5
    9cb2:	bl	9708 <endpoint0_transmit>
			data += size;
			ep0_tx_len -= size;
    9cb6:	subs	r0, r4, r5
    9cb8:	uxth	r0, r0
    9cba:	strh.w	r0, [sl]
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    9cbe:	cbnz	r0, 9cc4 <usb_isr+0x428>
    9cc0:	cmp	r5, #64	; 0x40
    9cc2:	bne.n	9cc6 <usb_isr+0x42a>
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    9cc4:	adds	r0, r6, r5
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    9cc6:	str	r0, [r7, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    9cc8:	ldr	r3, [pc, #368]	; (9e3c <usb_isr+0x5a0>)
    9cca:	ldrh	r2, [r3, #0]
    9ccc:	cmp.w	r2, #1280	; 0x500
    9cd0:	bne.n	9cdc <usb_isr+0x440>
			setup.bRequest = 0;
    9cd2:	movs	r2, #0
    9cd4:	strb	r2, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    9cd6:	ldrb	r2, [r3, #2]
    9cd8:	ldr	r3, [pc, #372]	; (9e50 <usb_isr+0x5b4>)
    9cda:	strb	r2, [r3, #0]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    9cdc:	ldr	r3, [pc, #344]	; (9e38 <usb_isr+0x59c>)
    9cde:	movs	r2, #1
    9ce0:	strb	r2, [r3, #0]
    9ce2:	b.n	9dd4 <usb_isr+0x538>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    9ce4:	add.w	r5, r4, r6, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    9ce8:	subs	r7, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    9cea:	ldr	r2, [r5, #4]
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    9cec:	and.w	r3, r3, #8
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    9cf0:	sub.w	r0, r2, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    9cf4:	uxtb	r7, r7
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    9cf6:	and.w	lr, r3, #255	; 0xff
    9cfa:	cmp	r3, #0
    9cfc:	beq.n	9d6c <usb_isr+0x4d0>
				usb_free(packet);
    9cfe:	bl	96c4 <usb_free>
				packet = tx_first[endpoint];
    9d02:	ldr	r0, [pc, #336]	; (9e54 <usb_isr+0x5b8>)
    9d04:	ldr	r3, [pc, #336]	; (9e58 <usb_isr+0x5bc>)
    9d06:	ldr.w	r1, [r0, r7, lsl #2]
				if (packet) {
    9d0a:	cbz	r1, 9d48 <usb_isr+0x4ac>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    9d0c:	ldr	r2, [r1, #4]
    9d0e:	str.w	r2, [r0, r7, lsl #2]
					b->addr = packet->buf;
    9d12:	add.w	r2, r1, #8
    9d16:	str	r2, [r5, #4]
					switch (tx_state[endpoint]) {
    9d18:	ldrb	r2, [r3, r7]
    9d1a:	cmp	r2, #3
    9d1c:	bhi.n	9d36 <usb_isr+0x49a>
    9d1e:	tbb	[pc, r2]
    9d22:	.short	0x0402
    9d24:	.short	0x0806
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    9d26:	movs	r2, #3
    9d28:	b.n	9d34 <usb_isr+0x498>
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    9d2a:	movs	r2, #2
    9d2c:	b.n	9d34 <usb_isr+0x498>
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    9d2e:	movs	r2, #5
    9d30:	b.n	9d34 <usb_isr+0x498>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    9d32:	movs	r2, #4
    9d34:	strb	r2, [r3, r7]
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    9d36:	tst.w	r5, #8
    9d3a:	ldrh	r2, [r1, #0]
    9d3c:	ite	ne
    9d3e:	movne	r3, #200	; 0xc8
    9d40:	moveq	r3, #136	; 0x88
    9d42:	orr.w	r3, r3, r2, lsl #16
    9d46:	b.n	9dd0 <usb_isr+0x534>
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    9d48:	ldrb	r2, [r3, r7]
    9d4a:	cmp	r2, #3
    9d4c:	bhi.n	9d5e <usb_isr+0x4c2>
    9d4e:	tbb	[pc, r2]
    9d52:	.short	0x4141
    9d54:	.short	0x0402
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    9d56:	movs	r2, #0
    9d58:	b.n	9d68 <usb_isr+0x4cc>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    9d5a:	movs	r2, #1
    9d5c:	b.n	9d68 <usb_isr+0x4cc>
						break;
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    9d5e:	tst.w	r5, #8
    9d62:	ite	ne
    9d64:	movne	r2, #3
    9d66:	moveq	r2, #2
    9d68:	strb	r2, [r3, r7]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    9d6a:	b.n	9dd4 <usb_isr+0x538>
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    9d6c:	ldr.w	r3, [r4, r6, lsl #3]
    9d70:	lsrs	r3, r3, #16
    9d72:	uxth	r1, r3
    9d74:	strh.w	r1, [r2, #-8]
				if (packet->len > 0) {
    9d78:	cbz	r3, 9dc4 <usb_isr+0x528>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    9d7a:	ldr	r3, [pc, #224]	; (9e5c <usb_isr+0x5c0>)
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    9d7c:	strh.w	lr, [r2, #-6]
					packet->next = NULL;
    9d80:	str.w	lr, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    9d84:	ldr.w	r2, [r3, r7, lsl #2]
    9d88:	ldr.w	lr, [pc, #252]	; 9e88 <usb_isr+0x5ec>
    9d8c:	cbnz	r2, 9d94 <usb_isr+0x4f8>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    9d8e:	str.w	r0, [r3, r7, lsl #2]
    9d92:	b.n	9d9a <usb_isr+0x4fe>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    9d94:	ldr.w	r3, [lr, r7, lsl #2]
    9d98:	str	r0, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    9d9a:	ldr	r2, [pc, #196]	; (9e60 <usb_isr+0x5c4>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
					}
					rx_last[endpoint] = packet;
    9d9c:	str.w	r0, [lr, r7, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    9da0:	ldrh.w	r3, [r2, r7, lsl #1]
    9da4:	add	r3, r1
    9da6:	strh.w	r3, [r2, r7, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    9daa:	bl	9688 <usb_malloc>
					if (packet) {
    9dae:	cbz	r0, 9db6 <usb_isr+0x51a>
						b->addr = packet->buf;
    9db0:	adds	r0, #8
    9db2:	str	r0, [r5, #4]
    9db4:	b.n	9dc4 <usb_isr+0x528>
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    9db6:	ldr	r2, [pc, #172]	; (9e64 <usb_isr+0x5c8>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    9db8:	str.w	r0, [r4, r6, lsl #3]
						usb_rx_memory_needed++;
    9dbc:	ldrb	r3, [r2, #0]
    9dbe:	adds	r3, #1
    9dc0:	strb	r3, [r2, #0]
    9dc2:	b.n	9dd4 <usb_isr+0x538>
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9dc4:	ldr	r2, [pc, #160]	; (9e68 <usb_isr+0x5cc>)
    9dc6:	ldr	r3, [pc, #128]	; (9e48 <usb_isr+0x5ac>)
    9dc8:	tst.w	r5, #8
    9dcc:	it	eq
    9dce:	moveq	r3, r2
    9dd0:	str.w	r3, [r4, r6, lsl #3]
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    9dd4:	movs	r3, #8
    9dd6:	strb.w	r3, [r8]
		goto restart;
    9dda:	b.n	98a4 <usb_isr+0x8>
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    9ddc:	lsls	r0, r4, #31
    9dde:	bpl.n	9e8c <usb_isr+0x5f0>
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    9de0:	ldr	r1, [pc, #84]	; (9e38 <usb_isr+0x59c>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    9de2:	ldr	r0, [pc, #132]	; (9e68 <usb_isr+0x5cc>)
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    9de4:	ldr	r4, [pc, #132]	; (9e6c <usb_isr+0x5d0>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    9de6:	movs	r3, #2
    9de8:	strb	r3, [r1, #0]
		ep0_tx_bdt_bank = 0;
    9dea:	ldr	r3, [pc, #132]	; (9e70 <usb_isr+0x5d4>)
    9dec:	strb	r2, [r3, #0]

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    9dee:	ldr	r3, [pc, #132]	; (9e74 <usb_isr+0x5d8>)
    9df0:	str	r0, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    9df2:	str	r4, [r3, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    9df4:	str	r0, [r3, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    9df6:	ldr	r0, [pc, #128]	; (9e78 <usb_isr+0x5dc>)
    9df8:	str	r0, [r3, #12]
		table[index(0, TX, EVEN)].desc = 0;
    9dfa:	str	r2, [r3, #16]
		table[index(0, TX, ODD)].desc = 0;
    9dfc:	str	r2, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9dfe:	ldr	r3, [pc, #32]	; (9e20 <usb_isr+0x584>)
    9e00:	movs	r0, #13
    9e02:	strb	r0, [r3, #0]

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    9e04:	ldr	r0, [pc, #116]	; (9e7c <usb_isr+0x5e0>)
    9e06:	movs	r3, #255	; 0xff
    9e08:	strb	r3, [r0, #0]
		USB0_ISTAT = 0xFF;
    9e0a:	strb	r3, [r5, #0]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    9e0c:	strb	r2, [r0, #16]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    9e0e:	ldr	r2, [pc, #112]	; (9e80 <usb_isr+0x5e4>)
    9e10:	strb	r3, [r2, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    9e12:	ldr	r3, [pc, #112]	; (9e84 <usb_isr+0x5e8>)
    9e14:	movs	r2, #159	; 0x9f
    9e16:	strb	r2, [r3, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    9e18:	movs	r3, #1
    9e1a:	strb	r3, [r1, #0]
		return;
    9e1c:	b.n	9eb2 <usb_isr+0x616>
    9e1e:	nop
    9e20:	.word	0x400720c0
    9e24:	.word	0x000130b8
    9e28:	.word	0x2001a6fc
    9e2c:	.word	0x2001a850
    9e30:	.word	0x2001a6f8
    9e34:	.word	0x2001a7d4
    9e38:	.word	0x40072094
    9e3c:	.word	0x2001a7cc
    9e40:	.word	0x2001a848
    9e44:	.word	0x2001a769
    9e48:	.word	0x004000c8
    9e4c:	.word	0x2001a700
    9e50:	.word	0x40072098
    9e54:	.word	0x2001a7ac
    9e58:	.word	0x2001a714
    9e5c:	.word	0x2001a758
    9e60:	.word	0x2001a854
    9e64:	.word	0x2001a7d6
    9e68:	.word	0x00400088
    9e6c:	.word	0x2001a718
    9e70:	.word	0x2001a768
    9e74:	.word	0x1fff0000
    9e78:	.word	0x2001a76c
    9e7c:	.word	0x40072088
    9e80:	.word	0x4007208c
    9e84:	.word	0x40072084
    9e88:	.word	0x2001a704
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    9e8c:	lsls	r1, r4, #24
    9e8e:	bpl.n	9e9a <usb_isr+0x5fe>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9e90:	ldr	r3, [pc, #36]	; (9eb8 <usb_isr+0x61c>)
    9e92:	movs	r2, #13
    9e94:	strb	r2, [r3, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    9e96:	movs	r3, #128	; 0x80
    9e98:	strb	r3, [r5, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    9e9a:	lsls	r2, r4, #30
    9e9c:	bpl.n	9eaa <usb_isr+0x60e>
		uint8_t err = USB0_ERRSTAT;
    9e9e:	ldr	r2, [pc, #28]	; (9ebc <usb_isr+0x620>)
    9ea0:	ldrb	r3, [r2, #0]
    9ea2:	uxtb	r3, r3
		USB0_ERRSTAT = err;
    9ea4:	strb	r3, [r2, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    9ea6:	movs	r3, #2
    9ea8:	strb	r3, [r5, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    9eaa:	lsls	r3, r4, #27
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    9eac:	itt	mi
    9eae:	movmi	r3, #16
    9eb0:	strbmi	r3, [r5, #0]
	}

}
    9eb2:	add	sp, #12
    9eb4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9eb8:	.word	0x400720c0
    9ebc:	.word	0x40072088

00009ec0 <usb_init>:



void usb_init(void)
{
    9ec0:	push	{r4, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    9ec2:	bl	a474 <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    9ec6:	movs	r3, #0
		table[i].desc = 0;
    9ec8:	ldr	r0, [pc, #108]	; (9f38 <usb_init+0x78>)
    9eca:	mov	r1, r3
    9ecc:	str.w	r1, [r0, r3, lsl #3]
		table[i].addr = 0;
    9ed0:	add.w	r4, r0, r3, lsl #3
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    9ed4:	adds	r3, #1
    9ed6:	cmp	r3, #20
		table[i].desc = 0;
    9ed8:	ldr	r2, [pc, #92]	; (9f38 <usb_init+0x78>)
		table[i].addr = 0;
    9eda:	str	r1, [r4, #4]
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    9edc:	bne.n	9ecc <usb_init+0xc>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    9ede:	ldr	r1, [pc, #92]	; (9f3c <usb_init+0x7c>)
    9ee0:	ldr	r3, [r1, #0]
    9ee2:	orr.w	r3, r3, #262144	; 0x40000
    9ee6:	str	r3, [r1, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    9ee8:	ldr	r1, [pc, #84]	; (9f40 <usb_init+0x80>)
    9eea:	ldr	r3, [r1, #0]
    9eec:	orr.w	r3, r3, #50331648	; 0x3000000
    9ef0:	str	r3, [r1, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    9ef2:	ldr	r3, [pc, #80]	; (9f44 <usb_init+0x84>)
    9ef4:	ubfx	r1, r2, #8, #8
    9ef8:	strb	r1, [r3, #0]
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    9efa:	ubfx	r1, r2, #16, #8
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    9efe:	lsrs	r2, r2, #24
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    9f00:	strb	r1, [r3, #20]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    9f02:	strb	r2, [r3, #24]

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    9f04:	ldr	r2, [pc, #64]	; (9f48 <usb_init+0x88>)
    9f06:	movs	r3, #255	; 0xff
    9f08:	strb	r3, [r2, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    9f0a:	movs	r1, #0
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    9f0c:	strb	r3, [r2, #8]
	USB0_OTGISTAT = 0xFF;
    9f0e:	strb.w	r3, [r2, #-112]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    9f12:	movs	r3, #1
    9f14:	strb	r3, [r2, #20]
	USB0_USBCTRL = 0;
    9f16:	strb.w	r1, [r2, #128]	; 0x80

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    9f1a:	strb	r3, [r2, #4]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    9f1c:	ldr	r3, [pc, #44]	; (9f4c <usb_init+0x8c>)
    9f1e:	movs	r2, #112	; 0x70
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    9f20:	mvn.w	r1, #816	; 0x330

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    9f24:	strb	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    9f26:	add	r3, r1
    9f28:	mov.w	r2, #2097152	; 0x200000
    9f2c:	str	r2, [r3, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    9f2e:	ldr	r3, [pc, #32]	; (9f50 <usb_init+0x90>)
    9f30:	movs	r2, #16
    9f32:	strb	r2, [r3, #0]
    9f34:	pop	{r4, pc}
    9f36:	nop
    9f38:	.word	0x1fff0000
    9f3c:	.word	0x40048034
    9f40:	.word	0x4000d800
    9f44:	.word	0x4007209c
    9f48:	.word	0x40072080
    9f4c:	.word	0xe000e435
    9f50:	.word	0x40072108

00009f54 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    9f54:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    9f58:	ldr	r4, [pc, #176]	; (a00c <yield+0xb8>)
    9f5a:	ldrb	r3, [r4, #0]
    9f5c:	cmp	r3, #0
    9f5e:	beq.n	a006 <yield+0xb2>
	if (running) return; // TODO: does this need to be atomic?
    9f60:	ldr	r5, [pc, #172]	; (a010 <yield+0xbc>)
    9f62:	ldrb	r2, [r5, #0]
    9f64:	cmp	r2, #0
    9f66:	bne.n	a006 <yield+0xb2>
	running = 1;
    9f68:	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    9f6a:	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    9f6c:	strb	r2, [r5, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    9f6e:	bpl.n	9f88 <yield+0x34>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    9f70:	bl	9184 <usb_serial_available>
		if (Serial.available()) serialEvent();
    9f74:	cbz	r0, 9f7a <yield+0x26>
    9f76:	bl	a3b2 <serialEvent()>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    9f7a:	ldr	r3, [pc, #152]	; (a014 <yield+0xc0>)
    9f7c:	ldrb	r3, [r3, #0]
    9f7e:	cbz	r3, 9f88 <yield+0x34>
    9f80:	ldrb	r3, [r4, #0]
    9f82:	bic.w	r3, r3, #1
    9f86:	strb	r3, [r4, #0]
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    9f88:	ldrb	r3, [r4, #0]
    9f8a:	lsls	r2, r3, #30
    9f8c:	bpl.n	9fb8 <yield+0x64>
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    9f8e:	ldr.w	r8, [pc, #148]	; a024 <yield+0xd0>
			s_serials_with_serial_events[i]->doYieldCode();
    9f92:	ldr.w	r9, [pc, #148]	; a028 <yield+0xd4>
    9f96:	movs	r6, #0
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    9f98:	ldrb.w	r2, [r8]
    9f9c:	uxtb	r3, r6
    9f9e:	cmp	r2, r3
    9fa0:	bls.n	9fb8 <yield+0x64>
			s_serials_with_serial_events[i]->doYieldCode();
    9fa2:	ldr.w	r7, [r9, r3, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*_serialEvent)();
    9fa6:	ldr	r3, [r7, #0]
    9fa8:	mov	r0, r7
    9faa:	ldr	r3, [r3, #16]
    9fac:	blx	r3
    9fae:	cbz	r0, 9fb4 <yield+0x60>
    9fb0:	ldr	r3, [r7, #16]
    9fb2:	blx	r3
    9fb4:	adds	r6, #1
    9fb6:	b.n	9f98 <yield+0x44>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    9fb8:	movs	r3, #0
    9fba:	strb	r3, [r5, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    9fbc:	ldrb	r3, [r4, #0]
    9fbe:	lsls	r3, r3, #29
    9fc0:	bpl.n	a006 <yield+0xb2>
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
    9fc2:	ldr	r1, [pc, #84]	; (a018 <yield+0xc4>)
    9fc4:	ldr	r3, [r1, #0]
    9fc6:	cbz	r3, a006 <yield+0xb2>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    9fc8:	mrs	r3, IPSR
		if (ipsr != 0) return;
    9fcc:	cbnz	r3, a006 <yield+0xb2>
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    9fce:	mrs	r2, PRIMASK
		__disable_irq();
    9fd2:	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    9fd4:	ldr	r0, [r1, #0]
		if (first == nullptr) {
    9fd6:	cbz	r0, 9fde <yield+0x8a>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    9fd8:	ldr	r4, [pc, #64]	; (a01c <yield+0xc8>)
    9fda:	ldrb	r5, [r4, #0]
    9fdc:	cbz	r5, 9fe6 <yield+0x92>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    9fde:	cbnz	r2, a006 <yield+0xb2>
    9fe0:	cpsie	i
    9fe2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    9fe6:	movs	r3, #1
    9fe8:	strb	r3, [r4, #0]
		firstYield = first->_next;
    9fea:	ldr	r3, [r0, #20]
    9fec:	str	r3, [r1, #0]
		if (firstYield) {
    9fee:	cbz	r3, 9ff4 <yield+0xa0>
			firstYield->_prev = nullptr;
    9ff0:	str	r5, [r3, #24]
    9ff2:	b.n	9ff8 <yield+0xa4>
		} else {
			lastYield = nullptr;
    9ff4:	ldr	r1, [pc, #40]	; (a020 <yield+0xcc>)
    9ff6:	str	r3, [r1, #0]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    9ff8:	cbnz	r2, 9ffc <yield+0xa8>
    9ffa:	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    9ffc:	movs	r5, #0
    9ffe:	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    a000:	ldr	r3, [r0, #8]
    a002:	blx	r3
		runningFromYield = false;
    a004:	strb	r5, [r4, #0]
    a006:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a00a:	nop
    a00c:	.word	0x1fff1344
    a010:	.word	0x2001a7e1
    a014:	.word	0x1fff1358
    a018:	.word	0x2001a7f0
    a01c:	.word	0x2001a7f4
    a020:	.word	0x2001a7ec
    a024:	.word	0x2001a810
    a028:	.word	0x2001a7f8

0000a02c <DMAChannel::begin(bool)>:
/**                     Teensy 3.0 & 3.1                       **/
/****************************************************************/
#if defined(KINETISK)

void DMAChannel::begin(bool force_initialization)
{
    a02c:	push	{r4, r5, lr}
	uint32_t ch = 0;

	__disable_irq();
    a02e:	cpsid	i
    a030:	ldr	r4, [pc, #148]	; (a0c8 <DMAChannel::begin(bool)+0x9c>)
	if (!force_initialization && TCD && channel < DMA_MAX_CHANNELS
    a032:	cbnz	r1, a058 <DMAChannel::begin(bool)+0x2c>
    a034:	ldr	r1, [r0, #0]
    a036:	cbz	r1, a058 <DMAChannel::begin(bool)+0x2c>
    a038:	ldrb	r3, [r0, #4]
    a03a:	cmp	r3, #15
    a03c:	bhi.n	a058 <DMAChannel::begin(bool)+0x2c>
	  && (dma_channel_allocated_mask & (1 << channel))
    a03e:	ldrh	r2, [r4, #0]
    a040:	asrs	r2, r3
    a042:	lsls	r2, r2, #31
    a044:	bpl.n	a058 <DMAChannel::begin(bool)+0x2c>
	  && (uint32_t)TCD == (uint32_t)(0x40009000 + channel * 32)) {
    a046:	add.w	r3, r3, #33554432	; 0x2000000
    a04a:	add.w	r3, r3, #1152	; 0x480
    a04e:	cmp.w	r1, r3, lsl #5
    a052:	bne.n	a058 <DMAChannel::begin(bool)+0x2c>
		// DMA channel already allocated
		__enable_irq();
    a054:	cpsie	i
		return;
    a056:	pop	{r4, r5, pc}
	}
	while (1) {
		if (!(dma_channel_allocated_mask & (1 << ch))) {
    a058:	ldrh	r1, [r4, #0]
    a05a:	movs	r3, #0
    a05c:	asr.w	r2, r1, r3
    a060:	ands.w	r2, r2, #1
    a064:	bne.n	a0b8 <DMAChannel::begin(bool)+0x8c>
			dma_channel_allocated_mask |= (1 << ch);
    a066:	movs	r5, #1
    a068:	lsls	r5, r3
    a06a:	orrs	r1, r5
    a06c:	strh	r1, [r4, #0]
			__enable_irq();
    a06e:	cpsie	i
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    a070:	ldr	r5, [pc, #88]	; (a0cc <DMAChannel::begin(bool)+0xa0>)
			channel = DMA_MAX_CHANNELS;
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
    a072:	uxtb	r1, r3
    a074:	strb	r1, [r0, #4]
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    a076:	ldr	r4, [r5, #0]
    a078:	orr.w	r4, r4, #2
    a07c:	str	r4, [r5, #0]
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    a07e:	ldr.w	r4, [r5, #-4]
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    a082:	add.w	r3, r3, #33554432	; 0x2000000
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    a086:	orr.w	r4, r4, #2
    a08a:	str.w	r4, [r5, #-4]
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    a08e:	add.w	r3, r3, #1152	; 0x480
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
    a092:	ldr	r4, [pc, #60]	; (a0d0 <DMAChannel::begin(bool)+0xa4>)
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    a094:	lsls	r3, r3, #5
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
    a096:	movw	r5, #1154	; 0x482
    a09a:	str	r5, [r4, #0]
#endif
	DMA_CERQ = ch;
    a09c:	strb	r1, [r4, #26]
	DMA_CERR = ch;
    a09e:	strb	r1, [r4, #30]
	DMA_CEEI = ch;
    a0a0:	strb	r1, [r4, #24]
	DMA_CINT = ch;
    a0a2:	strb	r1, [r4, #31]
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    a0a4:	str	r3, [r0, #0]
	uint32_t *p = (uint32_t *)TCD;
	*p++ = 0;
    a0a6:	str	r2, [r3, #0]
	*p++ = 0;
    a0a8:	str	r2, [r3, #4]
	*p++ = 0;
    a0aa:	str	r2, [r3, #8]
	*p++ = 0;
    a0ac:	str	r2, [r3, #12]
	*p++ = 0;
    a0ae:	str	r2, [r3, #16]
	*p++ = 0;
    a0b0:	str	r2, [r3, #20]
	*p++ = 0;
    a0b2:	str	r2, [r3, #24]
	*p++ = 0;
    a0b4:	str	r2, [r3, #28]
    a0b6:	pop	{r4, r5, pc}
		if (!(dma_channel_allocated_mask & (1 << ch))) {
			dma_channel_allocated_mask |= (1 << ch);
			__enable_irq();
			break;
		}
		if (++ch >= DMA_MAX_CHANNELS) {
    a0b8:	adds	r3, #1
    a0ba:	cmp	r3, #16
    a0bc:	bne.n	a05c <DMAChannel::begin(bool)+0x30>
			__enable_irq();
    a0be:	cpsie	i
			TCD = (TCD_t *)0;
    a0c0:	movs	r2, #0
    a0c2:	str	r2, [r0, #0]
			channel = DMA_MAX_CHANNELS;
    a0c4:	strb	r3, [r0, #4]
    a0c6:	pop	{r4, r5, pc}
    a0c8:	.word	0x2001a7e2
    a0cc:	.word	0x40048040
    a0d0:	.word	0x40008000

0000a0d4 <DMAChannel::release()>:
	*p++ = 0;
}

void DMAChannel::release(void)
{
	if (channel >= DMA_MAX_CHANNELS) return;
    a0d4:	ldrb	r3, [r0, #4]
    a0d6:	cmp	r3, #15
    a0d8:	bhi.n	a0fc <DMAChannel::release()+0x28>
	DMA_CERQ = channel;
    a0da:	ldr	r2, [pc, #36]	; (a100 <DMAChannel::release()+0x2c>)
    a0dc:	strb	r3, [r2, #0]
	__disable_irq();
    a0de:	cpsid	i
	dma_channel_allocated_mask &= ~(1 << channel);
    a0e0:	ldr	r1, [pc, #32]	; (a104 <DMAChannel::release()+0x30>)
    a0e2:	ldrb	r2, [r0, #4]
    a0e4:	movs	r3, #1
    a0e6:	lsl.w	r2, r3, r2
    a0ea:	ldrh	r3, [r1, #0]
    a0ec:	bic.w	r3, r3, r2
    a0f0:	strh	r3, [r1, #0]
	__enable_irq();
    a0f2:	cpsie	i
	channel = DMA_MAX_CHANNELS;
    a0f4:	movs	r3, #16
    a0f6:	strb	r3, [r0, #4]
	TCD = (TCD_t *)0;
    a0f8:	movs	r3, #0
    a0fa:	str	r3, [r0, #0]
    a0fc:	bx	lr
    a0fe:	nop
    a100:	.word	0x4000801a
    a104:	.word	0x2001a7e2

0000a108 <MillisTimer::disableTimerInterrupt()>:
	volatile TimerStateType _state = TimerOff;
	static MillisTimer *listWaiting; // single linked list of waiting to start timers
	static MillisTimer *listActive;  // double linked list of running timers
	static bool disableTimerInterrupt() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    a108:	mrs	r0, PRIMASK
		__disable_irq();
    a10c:	cpsid	i
		return (primask == 0) ? true : false;
	}
    a10e:	clz	r0, r0
    a112:	lsrs	r0, r0, #5
    a114:	bx	lr

0000a116 <MillisTimer::enableTimerInterrupt(bool)>:
	static void enableTimerInterrupt(bool doit) {
		if (doit) __enable_irq();
    a116:	cbz	r0, a11a <MillisTimer::enableTimerInterrupt(bool)+0x4>
    a118:	cpsie	i
    a11a:	bx	lr

0000a11c <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    a11c:	push	{r3, r4, r5, r6, r7, lr}
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    a11e:	ldr	r6, [pc, #48]	; (a150 <EventResponder::runFromInterrupt()+0x34>)
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    a120:	ldr	r7, [pc, #48]	; (a154 <EventResponder::runFromInterrupt()+0x38>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    a122:	movs	r5, #0
}

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
    a124:	bl	a108 <MillisTimer::disableTimerInterrupt()>
		EventResponder *first = firstInterrupt;
    a128:	ldr	r4, [r6, #0]
}

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
    a12a:	mov	r2, r0
		EventResponder *first = firstInterrupt;
		if (first) {
    a12c:	cbz	r4, a14a <EventResponder::runFromInterrupt()+0x2e>
			firstInterrupt = first->_next;
    a12e:	ldr	r3, [r4, #20]
    a130:	str	r3, [r6, #0]
			if (firstInterrupt) {
    a132:	cbz	r3, a138 <EventResponder::runFromInterrupt()+0x1c>
				firstInterrupt->_prev = nullptr;
    a134:	str	r5, [r3, #24]
    a136:	b.n	a13a <EventResponder::runFromInterrupt()+0x1e>
			} else {
				lastInterrupt = nullptr;
    a138:	str	r3, [r7, #0]
			}
			enableInterrupts(irq);
    a13a:	mov	r0, r2
    a13c:	bl	a116 <MillisTimer::enableTimerInterrupt(bool)>
			first->_triggered = false;
    a140:	strb	r5, [r4, #29]
			(*(first->_function))(*first);
    a142:	ldr	r3, [r4, #8]
    a144:	mov	r0, r4
    a146:	blx	r3
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
	while (1) {
    a148:	b.n	a124 <EventResponder::runFromInterrupt()+0x8>
			}
			enableInterrupts(irq);
			first->_triggered = false;
			(*(first->_function))(*first);
		} else {
			enableInterrupts(irq);
    a14a:	bl	a116 <MillisTimer::enableTimerInterrupt(bool)>
    a14e:	pop	{r3, r4, r5, r6, r7, pc}
    a150:	.word	0x2001a7e4
    a154:	.word	0x2001a7e8

0000a158 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    a158:	b.w	a11c <EventResponder::runFromInterrupt()>

0000a15c <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
    a15c:	ldr	r2, [pc, #8]	; (a168 <systick_isr+0xc>)
    a15e:	ldr	r3, [r2, #0]
    a160:	adds	r3, #1
    a162:	str	r3, [r2, #0]
    a164:	bx	lr
    a166:	nop
    a168:	.word	0x2001a6fc

0000a16c <usb_serial_class::clear()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    a16c:	b.w	91a0 <usb_serial_flush_input>

0000a170 <usb_serial_class::peek()>:
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    a170:	b.w	914c <usb_serial_peekchar>

0000a174 <usb_serial_class::read()>:
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    a174:	b.w	9100 <usb_serial_getchar>

0000a178 <usb_serial_class::available()>:
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    a178:	b.w	9184 <usb_serial_available>

0000a17c <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    a17c:	b.w	9310 <usb_serial_flush_output>

0000a180 <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    a180:	b.w	92c8 <usb_serial_write_buffer_free>

0000a184 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    a184:	mov	r0, r1
    a186:	mov	r1, r2
    a188:	b.w	91d0 <usb_serial_write>

0000a18c <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    a18c:	mov	r0, r1
    a18e:	b.w	92b0 <usb_serial_putchar>

0000a192 <Print::write(unsigned char const*, unsigned int)>:

#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
    a192:	push	{r3, r4, r5, r6, r7, lr}
    a194:	mov	r7, r0
	if (buffer == nullptr) return 0;
    a196:	mov	r5, r1
    a198:	cbz	r1, a1b2 <Print::write(unsigned char const*, unsigned int)+0x20>
    a19a:	adds	r6, r1, r2
    a19c:	movs	r4, #0
	size_t count = 0;
	while (size--) count += write(*buffer++);
    a19e:	cmp	r5, r6
    a1a0:	beq.n	a1b6 <Print::write(unsigned char const*, unsigned int)+0x24>
    a1a2:	ldr	r3, [r7, #0]
    a1a4:	ldrb.w	r1, [r5], #1
    a1a8:	ldr	r3, [r3, #0]
    a1aa:	mov	r0, r7
    a1ac:	blx	r3
    a1ae:	add	r4, r0
    a1b0:	b.n	a19e <Print::write(unsigned char const*, unsigned int)+0xc>
#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
	if (buffer == nullptr) return 0;
    a1b2:	mov	r0, r1
    a1b4:	pop	{r3, r4, r5, r6, r7, pc}
    a1b6:	mov	r0, r4
	size_t count = 0;
	while (size--) count += write(*buffer++);
	return count;
}
    a1b8:	pop	{r3, r4, r5, r6, r7, pc}
    a1ba:	Address 0x0000a1ba is out of bounds.


0000a1bc <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    a1bc:	push	{r0, r1, r2, lr}
	uint8_t buf[2]={'\r', '\n'};
    a1be:	ldr	r3, [pc, #24]	; (a1d8 <Print::println()+0x1c>)
    a1c0:	ldrh	r3, [r3, #0]
    a1c2:	strh.w	r3, [sp, #4]
	return write(buf, 2);
    a1c6:	ldr	r3, [r0, #0]
    a1c8:	movs	r2, #2
    a1ca:	ldr	r3, [r3, #4]
    a1cc:	add	r1, sp, #4
    a1ce:	blx	r3
}
    a1d0:	add	sp, #12
    a1d2:	ldr.w	pc, [sp], #4
    a1d6:	nop
    a1d8:	.word	0x000130b0

0000a1dc <Print::printf(char const*, ...)>:
	return len;
}
}

int Print::printf(const char *format, ...)
{
    a1dc:	push	{r1, r2, r3}
    a1de:	push	{r0, r1, lr}
    a1e0:	add	r2, sp, #12
    a1e2:	ldr.w	r1, [r2], #4
	va_list ap;
	va_start(ap, format);
    a1e6:	str	r2, [sp, #4]
#ifdef __STRICT_ANSI__
	va_end(ap);
	return 0;  // TODO: make this work with -std=c++0x
#else
	int retval = vdprintf((int)this, format, ap);
    a1e8:	bl	f748 <vdprintf>
	va_end(ap);
	return retval;
#endif
}
    a1ec:	add	sp, #8
    a1ee:	ldr.w	lr, [sp], #4
    a1f2:	add	sp, #12
    a1f4:	bx	lr

0000a1f6 <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
}

#else

size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
{
    a1f6:	push	{r4, r5, r6, lr}
    a1f8:	mov	r5, r0
    a1fa:	sub	sp, #40	; 0x28
	uint8_t digit, i;

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
    a1fc:	cbnz	r2, a208 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x12>
		return write((uint8_t)n);
    a1fe:	ldr	r3, [r0, #0]
    a200:	uxtb	r1, r1
    a202:	ldr	r3, [r3, #0]
    a204:	blx	r3
    a206:	b.n	a268 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x72>
	} else if (base == 1) {
		base = 10;
    a208:	cmp	r2, #1
    a20a:	it	eq
    a20c:	moveq	r2, #10
	}


	if (n == 0) {
    a20e:	cbz	r1, a214 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x1e>
    a210:	movs	r0, #33	; 0x21
    a212:	b.n	a21e <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x28>
		buf[sizeof(buf) - 1] = '0';
    a214:	movs	r2, #48	; 0x30
    a216:	strb.w	r2, [sp, #37]	; 0x25
		i = sizeof(buf) - 1;
    a21a:	movs	r0, #33	; 0x21
    a21c:	b.n	a248 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x52>
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    a21e:	udiv	r6, r1, r2
    a222:	mls	r1, r2, r6, r1
    a226:	uxtb	r4, r1
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a228:	cmp	r1, #9
    a22a:	ite	ls
    a22c:	addls.w	r1, r4, #48	; 0x30
    a230:	addhi.w	r1, r4, #55	; 0x37
    a234:	add	r4, sp, #40	; 0x28
    a236:	add	r4, r0
    a238:	uxtb	r1, r1
    a23a:	strb.w	r1, [r4, #-36]
			n /= base;
			if (n == 0) break;
    a23e:	mov	r1, r6
    a240:	cbz	r6, a248 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x52>
			i--;
    a242:	subs	r0, #1
    a244:	uxtb	r0, r0
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
    a246:	b.n	a21e <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x28>
			n /= base;
			if (n == 0) break;
			i--;
		}
	}
	if (sign) {
    a248:	cbz	r3, a258 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x62>
		i--;
    a24a:	subs	r0, #1
    a24c:	uxtb	r0, r0
		buf[i] = '-';
    a24e:	add	r3, sp, #40	; 0x28
    a250:	add	r3, r0
    a252:	movs	r2, #45	; 0x2d
    a254:	strb.w	r2, [r3, #-36]
	}
	return write(buf + i, sizeof(buf) - i);
    a258:	ldr	r3, [r5, #0]
    a25a:	add	r1, sp, #4
    a25c:	rsb	r2, r0, #34	; 0x22
    a260:	add	r1, r0
    a262:	ldr	r3, [r3, #4]
    a264:	mov	r0, r5
    a266:	blx	r3
}
    a268:	add	sp, #40	; 0x28
    a26a:	pop	{r4, r5, r6, pc}

0000a26c <Print::print(long)>:

size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
    a26c:	cmp	r1, #0
		sign = '-';
		n = -n;
    a26e:	itte	lt
    a270:	neglt	r1, r1
size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
		sign = '-';
    a272:	movlt	r3, #45	; 0x2d
}


size_t Print::print(long n)
{
	uint8_t sign=0;
    a274:	movge	r3, #0

	if (n < 0) {
		sign = '-';
		n = -n;
	}
	return printNumber(n, 10, sign);
    a276:	movs	r2, #10
    a278:	b.w	a1f6 <Print::printNumber(unsigned long, unsigned char, unsigned char)>

0000a27c <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>:
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
    a27c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a280:	sub	sp, #72	; 0x48
    a282:	mov	r5, r0
    a284:	ldrb.w	r8, [sp, #104]	; 0x68
    a288:	ldrb.w	sl, [sp, #108]	; 0x6c
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    a28c:	cmp.w	r8, #1
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
    a290:	mov	r6, r2
    a292:	mov	r7, r3
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    a294:	bls.n	a31a <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x9e>
	if (n == 0) {
    a296:	orrs.w	r3, r6, r7
    a29a:	beq.n	a2a8 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x2c>
    a29c:	movs	r4, #65	; 0x41
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    a29e:	uxtb.w	r8, r8
    a2a2:	mov.w	r9, #0
    a2a6:	b.n	a2b2 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x36>
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    a2a8:	movs	r3, #48	; 0x30
    a2aa:	strb.w	r3, [sp, #69]	; 0x45
		i = sizeof(buf) - 1;
    a2ae:	movs	r4, #65	; 0x41
    a2b0:	b.n	a2f4 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x78>
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    a2b2:	mov	r0, r6
    a2b4:	mov	r1, r7
    a2b6:	mov	r2, r8
    a2b8:	mov	r3, r9
    a2ba:	bl	af48 <__aeabi_uldivmod>
    a2be:	mov	r1, r3
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a2c0:	cmp	r1, #0
    a2c2:	it	eq
    a2c4:	cmpeq	r2, #10
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    a2c6:	uxtb	r3, r2
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a2c8:	add	r2, sp, #72	; 0x48
    a2ca:	ite	cc
    a2cc:	addcc	r3, #48	; 0x30
    a2ce:	addcs	r3, #55	; 0x37
    a2d0:	add	r2, r4
    a2d2:	uxtb	r3, r3
    a2d4:	strb.w	r3, [r2, #-68]
			n /= base;
    a2d8:	mov	r0, r6
    a2da:	mov	r3, r9
    a2dc:	mov	r1, r7
    a2de:	mov	r2, r8
    a2e0:	bl	af48 <__aeabi_uldivmod>
    a2e4:	mov	r6, r0
    a2e6:	mov	r7, r1
			if (n == 0) break;
    a2e8:	orrs.w	r3, r6, r7
    a2ec:	beq.n	a2f4 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x78>
			i--;
    a2ee:	subs	r4, #1
    a2f0:	uxtb	r4, r4
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
    a2f2:	b.n	a2b2 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x36>
			n /= base;
			if (n == 0) break;
			i--;
		}
	}
	if (sign) {
    a2f4:	cmp.w	sl, #0
    a2f8:	beq.n	a308 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x8c>
		i--;
    a2fa:	subs	r4, #1
    a2fc:	uxtb	r4, r4
		buf[i] = '-';
    a2fe:	add	r3, sp, #72	; 0x48
    a300:	add	r3, r4
    a302:	movs	r2, #45	; 0x2d
    a304:	strb.w	r2, [r3, #-68]
	}
	return write(buf + i, sizeof(buf) - i);
    a308:	ldr	r3, [r5, #0]
    a30a:	add	r1, sp, #4
    a30c:	ldr	r3, [r3, #4]
    a30e:	rsb	r2, r4, #66	; 0x42
    a312:	add	r1, r4
    a314:	mov	r0, r5
    a316:	blx	r3
    a318:	b.n	a31c <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0xa0>
size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    a31a:	movs	r0, #0
	if (sign) {
		i--;
		buf[i] = '-';
	}
	return write(buf + i, sizeof(buf) - i);
}
    a31c:	add	sp, #72	; 0x48
    a31e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000a322 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    a322:	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    a324:	bl	79c <setup>
	while (1) {
		loop();
    a328:	bl	82c <loop>
		yield();
    a32c:	bl	9f54 <yield>
    a330:	b.n	a328 <main+0x6>
    a332:	Address 0x0000a332 is out of bounds.


0000a334 <Stream::timedRead()>:
#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field

// private method to read stream with timeout
int Stream::timedRead()
{
    a334:	push	{r0, r1, r4, r5, r6, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    a336:	ldr	r3, [pc, #48]	; (a368 <Stream::timedRead()+0x34>)
    a338:	ldr	r2, [r3, #0]
    a33a:	str	r2, [sp, #0]
	return ret;
    a33c:	ldr	r6, [sp, #0]
    a33e:	mov	r4, r0
    a340:	mov	r5, r3
  int c;
  unsigned long startMillis = millis();
  do {
    c = read();
    a342:	ldr	r3, [r4, #0]
    a344:	mov	r0, r4
    a346:	ldr	r3, [r3, #20]
    a348:	blx	r3
    if (c >= 0) return c;
    a34a:	cmp	r0, #0
    a34c:	bge.n	a364 <Stream::timedRead()+0x30>
    yield();
    a34e:	bl	9f54 <yield>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    a352:	ldr	r3, [r5, #0]
    a354:	str	r3, [sp, #4]
	return ret;
    a356:	ldr	r3, [sp, #4]
// private method to read stream with timeout
int Stream::timedRead()
{
  int c;
  unsigned long startMillis = millis();
  do {
    a358:	ldr	r2, [r4, #8]
    a35a:	subs	r3, r3, r6
    a35c:	cmp	r3, r2
    a35e:	bcc.n	a342 <Stream::timedRead()+0xe>
    c = read();
    if (c >= 0) return c;
    yield();
  } while(millis() - startMillis < _timeout);
  return -1;     // -1 indicates timeout
    a360:	mov.w	r0, #4294967295
}
    a364:	add	sp, #8
    a366:	pop	{r4, r5, r6, pc}
    a368:	.word	0x2001a6fc

0000a36c <Stream::readBytesUntil(char, char*, unsigned int)>:
// as readBytes with terminator character
// terminates if length characters have been read, timeout, or if the terminator character  detected
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
    a36c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    a370:	mov	r7, r0
    a372:	mov	r9, r1
	if (buffer == nullptr) return 0;
    a374:	mov	r5, r2
    a376:	cbz	r2, a3a6 <Stream::readBytesUntil(char, char*, unsigned int)+0x3a>
	if (length < 1) return 0;
    a378:	cbz	r3, a3aa <Stream::readBytesUntil(char, char*, unsigned int)+0x3e>
	length--;
    a37a:	add.w	r8, r3, #4294967295
    a37e:	mov	r6, r2
    a380:	subs	r4, r6, r5
	size_t index = 0;
	while (index < length) {
    a382:	cmp	r8, r4
    a384:	bls.n	a3a0 <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
		int c = timedRead();
    a386:	mov	r0, r7
    a388:	bl	a334 <Stream::timedRead()>
		if (c == terminator) break;
    a38c:	cmp	r0, r9
    a38e:	beq.n	a3a0 <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
		if (c < 0) {
    a390:	cmp	r0, #0
    a392:	bge.n	a39a <Stream::readBytesUntil(char, char*, unsigned int)+0x2e>
	String readString(size_t max = 120);
	String readStringUntil(char terminator, size_t max = 120);
	int getReadError() { return read_error; }
	void clearReadError() { setReadError(0); }
  protected:
	void setReadError(int err = 1) { read_error = err; }
    a394:	movs	r3, #1
    a396:	strb	r3, [r7, #12]
    a398:	b.n	a3a0 <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
			setReadError();
			break;
		}
		*buffer++ = (char)c;
    a39a:	strb.w	r0, [r6], #1
{
	if (buffer == nullptr) return 0;
	if (length < 1) return 0;
	length--;
	size_t index = 0;
	while (index < length) {
    a39e:	b.n	a380 <Stream::readBytesUntil(char, char*, unsigned int)+0x14>
			break;
		}
		*buffer++ = (char)c;
		index++;
	}
	*buffer = 0;
    a3a0:	movs	r3, #0
    a3a2:	strb	r3, [r6, #0]
	return index; // return number of characters, not including null terminator
    a3a4:	b.n	a3ac <Stream::readBytesUntil(char, char*, unsigned int)+0x40>
// terminates if length characters have been read, timeout, or if the terminator character  detected
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
	if (buffer == nullptr) return 0;
    a3a6:	mov	r4, r2
    a3a8:	b.n	a3ac <Stream::readBytesUntil(char, char*, unsigned int)+0x40>
    a3aa:	mov	r4, r3
		*buffer++ = (char)c;
		index++;
	}
	*buffer = 0;
	return index; // return number of characters, not including null terminator
}
    a3ac:	mov	r0, r4
    a3ae:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0000a3b2 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    a3b2:	bx	lr

0000a3b4 <operator new(unsigned int)>:
    a3b4:	b.w	b318 <malloc>

0000a3b8 <operator delete(void*, unsigned int)>:
    a3b8:	b.w	b328 <free>

0000a3bc <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    a3bc:	push	{r4, lr}
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    a3be:	ldr	r3, [pc, #128]	; (a440 <analog_init+0x84>)
    a3c0:	ldr	r0, [pc, #128]	; (a444 <analog_init+0x88>)
    a3c2:	ldr	r1, [pc, #132]	; (a448 <analog_init+0x8c>)
    a3c4:	movs	r2, #96	; 0x60
    a3c6:	strb	r2, [r3, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    a3c8:	movs	r2, #225	; 0xe1
    a3ca:	strb	r2, [r3, #1]
	#endif

	if (analog_config_bits == 8) {
    a3cc:	ldr	r3, [pc, #124]	; (a44c <analog_init+0x90>)
    a3ce:	ldr	r2, [pc, #128]	; (a450 <analog_init+0x94>)
    a3d0:	ldrb	r4, [r3, #0]
    a3d2:	ldr	r3, [pc, #128]	; (a454 <analog_init+0x98>)
    a3d4:	cmp	r4, #8
    a3d6:	bne.n	a3dc <analog_init+0x20>
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    a3d8:	movs	r4, #1
    a3da:	b.n	a3e2 <analog_init+0x26>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    a3dc:	cmp	r4, #10
    a3de:	bne.n	a3e8 <analog_init+0x2c>
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    a3e0:	movs	r4, #57	; 0x39
    a3e2:	str	r4, [r0, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    a3e4:	movs	r0, #19
    a3e6:	b.n	a3f4 <analog_init+0x38>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    a3e8:	cmp	r4, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    a3ea:	ite	eq
    a3ec:	moveq	r4, #53	; 0x35
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    a3ee:	movne	r4, #61	; 0x3d
    a3f0:	str	r4, [r0, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    a3f2:	movs	r0, #18
    a3f4:	str	r0, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    a3f6:	str	r4, [r2, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    a3f8:	str	r0, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    a3fa:	ldr	r3, [pc, #92]	; (a458 <analog_init+0x9c>)
    a3fc:	ldr	r1, [pc, #92]	; (a45c <analog_init+0xa0>)
    a3fe:	ldrb	r3, [r3, #0]
    a400:	ldr	r2, [pc, #92]	; (a460 <analog_init+0xa4>)
    a402:	cbz	r3, a406 <analog_init+0x4a>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    a404:	movs	r3, #1
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    a406:	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    a408:	str	r3, [r2, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    a40a:	ldr	r3, [pc, #88]	; (a464 <analog_init+0xa8>)
    a40c:	ldr	r2, [pc, #88]	; (a468 <analog_init+0xac>)
    a40e:	ldrb	r1, [r3, #0]
    a410:	ldr	r3, [pc, #88]	; (a46c <analog_init+0xb0>)
	if (num <= 1) {
    a412:	cmp	r1, #1
    a414:	bhi.n	a41a <analog_init+0x5e>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    a416:	movs	r1, #128	; 0x80
    a418:	b.n	a432 <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    a41a:	cmp	r1, #4
    a41c:	bhi.n	a422 <analog_init+0x66>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    a41e:	movs	r1, #132	; 0x84
    a420:	b.n	a432 <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    a422:	cmp	r1, #8
    a424:	bhi.n	a42a <analog_init+0x6e>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    a426:	movs	r1, #133	; 0x85
    a428:	b.n	a432 <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    a42a:	cmp	r1, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    a42c:	ite	ls
    a42e:	movls	r1, #134	; 0x86
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    a430:	movhi	r1, #135	; 0x87
    a432:	str	r1, [r2, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    a434:	str	r1, [r3, #0]
		#endif
	}
	calibrating = 1;
    a436:	ldr	r3, [pc, #56]	; (a470 <analog_init+0xb4>)
    a438:	movs	r2, #1
    a43a:	strb	r2, [r3, #0]
    a43c:	pop	{r4, pc}
    a43e:	nop
    a440:	.word	0x40074000
    a444:	.word	0x4003b008
    a448:	.word	0x4003b00c
    a44c:	.word	0x1fff1359
    a450:	.word	0x400bb008
    a454:	.word	0x400bb00c
    a458:	.word	0x2001a812
    a45c:	.word	0x4003b020
    a460:	.word	0x400bb020
    a464:	.word	0x1fff135a
    a468:	.word	0x4003b024
    a46c:	.word	0x400bb024
    a470:	.word	0x2001a811

0000a474 <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    a474:	push	{r0, r1, r2, r3, r4, lr}
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    a476:	cpsid	i
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    a478:	ldr	r3, [pc, #76]	; (a4c8 <usb_init_serialnumber+0x54>)
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    a47a:	ldr	r1, [pc, #80]	; (a4cc <usb_init_serialnumber+0x58>)
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    a47c:	movs	r2, #112	; 0x70
    a47e:	strb	r2, [r3, #0]
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    a480:	ldr	r2, [pc, #76]	; (a4d0 <usb_init_serialnumber+0x5c>)
    a482:	str	r1, [r2, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    a484:	movs	r2, #128	; 0x80
    a486:	strb	r2, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    a488:	ldrb	r2, [r3, #0]
    a48a:	lsls	r2, r2, #24
    a48c:	bpl.n	a488 <usb_init_serialnumber+0x14>
	num = *(uint32_t *)&FTFL_FCCOBB;
    a48e:	ldr	r3, [pc, #68]	; (a4d4 <usb_init_serialnumber+0x60>)
    a490:	ldr	r0, [r3, #0]
	kinetis_hsrun_enable();
#endif
	__enable_irq();
    a492:	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    a494:	ldr	r3, [pc, #64]	; (a4d8 <usb_init_serialnumber+0x64>)
    a496:	cmp	r0, r3
    a498:	it	ls
    a49a:	movls	r3, #10
	ultoa(num, buf, 10);
    a49c:	add	r4, sp, #4
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    a49e:	it	ls
    a4a0:	mulls	r0, r3
	ultoa(num, buf, 10);
    a4a2:	movs	r2, #10
    a4a4:	mov	r1, r4
    a4a6:	bl	a4e4 <ultoa>
    a4aa:	ldr	r2, [pc, #48]	; (a4dc <usb_init_serialnumber+0x68>)
	for (i=0; i<10; i++) {
    a4ac:	movs	r3, #0
		char c = buf[i];
    a4ae:	ldrb	r1, [r4, r3]
		if (!c) break;
    a4b0:	cbz	r1, a4bc <usb_init_serialnumber+0x48>
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    a4b2:	adds	r3, #1
    a4b4:	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    a4b6:	strh.w	r1, [r2], #2
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    a4ba:	bne.n	a4ae <usb_init_serialnumber+0x3a>
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    a4bc:	ldr	r2, [pc, #32]	; (a4e0 <usb_init_serialnumber+0x6c>)
    a4be:	adds	r3, #1
    a4c0:	lsls	r3, r3, #1
    a4c2:	strb	r3, [r2, #0]
}
    a4c4:	add	sp, #16
    a4c6:	pop	{r4, pc}
    a4c8:	.word	0x40020000
    a4cc:	.word	0x41070000
    a4d0:	.word	0x40020004
    a4d4:	.word	0x4002000c
    a4d8:	.word	0x0098967f
    a4dc:	.word	0x1fff13e6
    a4e0:	.word	0x1fff13e4

0000a4e4 <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    a4e4:	push	{r4, r5, lr}
    a4e6:	mov	r3, r0
	unsigned digit;
	int i=0, j;
    a4e8:	movs	r0, #0
	char t;

	while (1) {
		digit = val % radix;
    a4ea:	udiv	r4, r3, r2
    a4ee:	mls	r3, r2, r4, r3
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a4f2:	cmp	r3, #9
    a4f4:	ite	ls
    a4f6:	addls	r3, #48	; 0x30
    a4f8:	addhi	r3, #55	; 0x37
    a4fa:	uxtb	r3, r3
    a4fc:	strb	r3, [r1, r0]
		val /= radix;
		if (val == 0) break;
    a4fe:	mov	r3, r4
    a500:	cbz	r4, a506 <ultoa+0x22>
		i++;
    a502:	adds	r0, #1
	}
    a504:	b.n	a4ea <ultoa+0x6>
	buf[i + 1] = 0;
    a506:	adds	r2, r1, r0
	for (j=0; j < i; j++, i--) {
    a508:	mov	r3, r4
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
    a50a:	strb	r4, [r2, #1]
	for (j=0; j < i; j++, i--) {
    a50c:	subs	r4, r0, r3
    a50e:	cmp	r3, r4
    a510:	bge.n	a520 <ultoa+0x3c>
		t = buf[j];
    a512:	ldrb	r4, [r1, r3]
		buf[j] = buf[i];
    a514:	ldrb	r5, [r2, #0]
    a516:	strb	r5, [r1, r3]
		buf[i] = t;
    a518:	strb.w	r4, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    a51c:	adds	r3, #1
    a51e:	b.n	a50c <ultoa+0x28>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    a520:	mov	r0, r1
    a522:	pop	{r4, r5, pc}

0000a524 <__aeabi_atexit>:
    a524:	mov	r3, r1
    a526:	mov	r1, r0
    a528:	mov	r0, r3
    a52a:	b.w	b260 <__cxa_atexit>
    a52e:	nop

0000a530 <__aeabi_llsr>:
    a530:	lsrs	r0, r2
    a532:	adds	r3, r1, #0
    a534:	lsrs	r1, r2
    a536:	mov	ip, r3
    a538:	subs	r2, #32
    a53a:	lsrs	r3, r2
    a53c:	orrs	r0, r3
    a53e:	negs	r2, r2
    a540:	mov	r3, ip
    a542:	lsls	r3, r2
    a544:	orrs	r0, r3
    a546:	bx	lr

0000a548 <__aeabi_drsub>:
    a548:	eor.w	r1, r1, #2147483648	; 0x80000000
    a54c:	b.n	a554 <__adddf3>
    a54e:	nop

0000a550 <__aeabi_dsub>:
    a550:	eor.w	r3, r3, #2147483648	; 0x80000000

0000a554 <__adddf3>:
    a554:	push	{r4, r5, lr}
    a556:	mov.w	r4, r1, lsl #1
    a55a:	mov.w	r5, r3, lsl #1
    a55e:	teq	r4, r5
    a562:	it	eq
    a564:	teqeq	r0, r2
    a568:	itttt	ne
    a56a:	orrsne.w	ip, r4, r0
    a56e:	orrsne.w	ip, r5, r2
    a572:	mvnsne.w	ip, r4, asr #21
    a576:	mvnsne.w	ip, r5, asr #21
    a57a:	beq.w	a742 <__adddf3+0x1ee>
    a57e:	mov.w	r4, r4, lsr #21
    a582:	rsbs	r5, r4, r5, lsr #21
    a586:	it	lt
    a588:	neglt	r5, r5
    a58a:	ble.n	a5a6 <__adddf3+0x52>
    a58c:	add	r4, r5
    a58e:	eor.w	r2, r0, r2
    a592:	eor.w	r3, r1, r3
    a596:	eor.w	r0, r2, r0
    a59a:	eor.w	r1, r3, r1
    a59e:	eor.w	r2, r0, r2
    a5a2:	eor.w	r3, r1, r3
    a5a6:	cmp	r5, #54	; 0x36
    a5a8:	it	hi
    a5aa:	pophi	{r4, r5, pc}
    a5ac:	tst.w	r1, #2147483648	; 0x80000000
    a5b0:	mov.w	r1, r1, lsl #12
    a5b4:	mov.w	ip, #1048576	; 0x100000
    a5b8:	orr.w	r1, ip, r1, lsr #12
    a5bc:	beq.n	a5c4 <__adddf3+0x70>
    a5be:	negs	r0, r0
    a5c0:	sbc.w	r1, r1, r1, lsl #1
    a5c4:	tst.w	r3, #2147483648	; 0x80000000
    a5c8:	mov.w	r3, r3, lsl #12
    a5cc:	orr.w	r3, ip, r3, lsr #12
    a5d0:	beq.n	a5d8 <__adddf3+0x84>
    a5d2:	negs	r2, r2
    a5d4:	sbc.w	r3, r3, r3, lsl #1
    a5d8:	teq	r4, r5
    a5dc:	beq.w	a72e <__adddf3+0x1da>
    a5e0:	sub.w	r4, r4, #1
    a5e4:	rsbs	lr, r5, #32
    a5e8:	blt.n	a606 <__adddf3+0xb2>
    a5ea:	lsl.w	ip, r2, lr
    a5ee:	lsr.w	r2, r2, r5
    a5f2:	adds	r0, r0, r2
    a5f4:	adc.w	r1, r1, #0
    a5f8:	lsl.w	r2, r3, lr
    a5fc:	adds	r0, r0, r2
    a5fe:	asr.w	r3, r3, r5
    a602:	adcs	r1, r3
    a604:	b.n	a624 <__adddf3+0xd0>
    a606:	sub.w	r5, r5, #32
    a60a:	add.w	lr, lr, #32
    a60e:	cmp	r2, #1
    a610:	lsl.w	ip, r3, lr
    a614:	it	cs
    a616:	orrcs.w	ip, ip, #2
    a61a:	asr.w	r3, r3, r5
    a61e:	adds	r0, r0, r3
    a620:	adcs.w	r1, r1, r3, asr #31
    a624:	and.w	r5, r1, #2147483648	; 0x80000000
    a628:	bpl.n	a63a <__adddf3+0xe6>
    a62a:	mov.w	lr, #0
    a62e:	rsbs	ip, ip, #0
    a632:	sbcs.w	r0, lr, r0
    a636:	sbc.w	r1, lr, r1
    a63a:	cmp.w	r1, #1048576	; 0x100000
    a63e:	bcc.n	a678 <__adddf3+0x124>
    a640:	cmp.w	r1, #2097152	; 0x200000
    a644:	bcc.n	a660 <__adddf3+0x10c>
    a646:	lsrs	r1, r1, #1
    a648:	movs.w	r0, r0, rrx
    a64c:	mov.w	ip, ip, rrx
    a650:	add.w	r4, r4, #1
    a654:	mov.w	r2, r4, lsl #21
    a658:	cmn.w	r2, #4194304	; 0x400000
    a65c:	bcs.w	a794 <__adddf3+0x240>
    a660:	cmp.w	ip, #2147483648	; 0x80000000
    a664:	it	eq
    a666:	movseq.w	ip, r0, lsr #1
    a66a:	adcs.w	r0, r0, #0
    a66e:	adc.w	r1, r1, r4, lsl #20
    a672:	orr.w	r1, r1, r5
    a676:	pop	{r4, r5, pc}
    a678:	movs.w	ip, ip, lsl #1
    a67c:	adcs	r0, r0
    a67e:	adc.w	r1, r1, r1
    a682:	tst.w	r1, #1048576	; 0x100000
    a686:	sub.w	r4, r4, #1
    a68a:	bne.n	a660 <__adddf3+0x10c>
    a68c:	teq	r1, #0
    a690:	itt	eq
    a692:	moveq	r1, r0
    a694:	moveq	r0, #0
    a696:	clz	r3, r1
    a69a:	it	eq
    a69c:	addeq	r3, #32
    a69e:	sub.w	r3, r3, #11
    a6a2:	subs.w	r2, r3, #32
    a6a6:	bge.n	a6c2 <__adddf3+0x16e>
    a6a8:	adds	r2, #12
    a6aa:	ble.n	a6be <__adddf3+0x16a>
    a6ac:	add.w	ip, r2, #20
    a6b0:	rsb	r2, r2, #12
    a6b4:	lsl.w	r0, r1, ip
    a6b8:	lsr.w	r1, r1, r2
    a6bc:	b.n	a6d8 <__adddf3+0x184>
    a6be:	add.w	r2, r2, #20
    a6c2:	it	le
    a6c4:	rsble	ip, r2, #32
    a6c8:	lsl.w	r1, r1, r2
    a6cc:	lsr.w	ip, r0, ip
    a6d0:	itt	le
    a6d2:	orrle.w	r1, r1, ip
    a6d6:	lslle	r0, r2
    a6d8:	subs	r4, r4, r3
    a6da:	ittt	ge
    a6dc:	addge.w	r1, r1, r4, lsl #20
    a6e0:	orrge	r1, r5
    a6e2:	popge	{r4, r5, pc}
    a6e4:	mvn.w	r4, r4
    a6e8:	subs	r4, #31
    a6ea:	bge.n	a726 <__adddf3+0x1d2>
    a6ec:	adds	r4, #12
    a6ee:	bgt.n	a70e <__adddf3+0x1ba>
    a6f0:	add.w	r4, r4, #20
    a6f4:	rsb	r2, r4, #32
    a6f8:	lsr.w	r0, r0, r4
    a6fc:	lsl.w	r3, r1, r2
    a700:	orr.w	r0, r0, r3
    a704:	lsr.w	r3, r1, r4
    a708:	orr.w	r1, r5, r3
    a70c:	pop	{r4, r5, pc}
    a70e:	rsb	r4, r4, #12
    a712:	rsb	r2, r4, #32
    a716:	lsr.w	r0, r0, r2
    a71a:	lsl.w	r3, r1, r4
    a71e:	orr.w	r0, r0, r3
    a722:	mov	r1, r5
    a724:	pop	{r4, r5, pc}
    a726:	lsr.w	r0, r1, r4
    a72a:	mov	r1, r5
    a72c:	pop	{r4, r5, pc}
    a72e:	teq	r4, #0
    a732:	eor.w	r3, r3, #1048576	; 0x100000
    a736:	itte	eq
    a738:	eoreq.w	r1, r1, #1048576	; 0x100000
    a73c:	addeq	r4, #1
    a73e:	subne	r5, #1
    a740:	b.n	a5e0 <__adddf3+0x8c>
    a742:	mvns.w	ip, r4, asr #21
    a746:	it	ne
    a748:	mvnsne.w	ip, r5, asr #21
    a74c:	beq.n	a7a2 <__adddf3+0x24e>
    a74e:	teq	r4, r5
    a752:	it	eq
    a754:	teqeq	r0, r2
    a758:	beq.n	a766 <__adddf3+0x212>
    a75a:	orrs.w	ip, r4, r0
    a75e:	itt	eq
    a760:	moveq	r1, r3
    a762:	moveq	r0, r2
    a764:	pop	{r4, r5, pc}
    a766:	teq	r1, r3
    a76a:	ittt	ne
    a76c:	movne	r1, #0
    a76e:	movne	r0, #0
    a770:	popne	{r4, r5, pc}
    a772:	movs.w	ip, r4, lsr #21
    a776:	bne.n	a784 <__adddf3+0x230>
    a778:	lsls	r0, r0, #1
    a77a:	adcs	r1, r1
    a77c:	it	cs
    a77e:	orrcs.w	r1, r1, #2147483648	; 0x80000000
    a782:	pop	{r4, r5, pc}
    a784:	adds.w	r4, r4, #4194304	; 0x400000
    a788:	itt	cc
    a78a:	addcc.w	r1, r1, #1048576	; 0x100000
    a78e:	popcc	{r4, r5, pc}
    a790:	and.w	r5, r1, #2147483648	; 0x80000000
    a794:	orr.w	r1, r5, #2130706432	; 0x7f000000
    a798:	orr.w	r1, r1, #15728640	; 0xf00000
    a79c:	mov.w	r0, #0
    a7a0:	pop	{r4, r5, pc}
    a7a2:	mvns.w	ip, r4, asr #21
    a7a6:	itte	ne
    a7a8:	movne	r1, r3
    a7aa:	movne	r0, r2
    a7ac:	mvnseq.w	ip, r5, asr #21
    a7b0:	itt	ne
    a7b2:	movne	r3, r1
    a7b4:	movne	r2, r0
    a7b6:	orrs.w	r4, r0, r1, lsl #12
    a7ba:	itte	eq
    a7bc:	orrseq.w	r5, r2, r3, lsl #12
    a7c0:	teqeq	r1, r3
    a7c4:	orrne.w	r1, r1, #524288	; 0x80000
    a7c8:	pop	{r4, r5, pc}
    a7ca:	nop

0000a7cc <__aeabi_ui2d>:
    a7cc:	teq	r0, #0
    a7d0:	itt	eq
    a7d2:	moveq	r1, #0
    a7d4:	bxeq	lr
    a7d6:	push	{r4, r5, lr}
    a7d8:	mov.w	r4, #1024	; 0x400
    a7dc:	add.w	r4, r4, #50	; 0x32
    a7e0:	mov.w	r5, #0
    a7e4:	mov.w	r1, #0
    a7e8:	b.n	a68c <__adddf3+0x138>
    a7ea:	nop

0000a7ec <__aeabi_i2d>:
    a7ec:	teq	r0, #0
    a7f0:	itt	eq
    a7f2:	moveq	r1, #0
    a7f4:	bxeq	lr
    a7f6:	push	{r4, r5, lr}
    a7f8:	mov.w	r4, #1024	; 0x400
    a7fc:	add.w	r4, r4, #50	; 0x32
    a800:	ands.w	r5, r0, #2147483648	; 0x80000000
    a804:	it	mi
    a806:	negmi	r0, r0
    a808:	mov.w	r1, #0
    a80c:	b.n	a68c <__adddf3+0x138>
    a80e:	nop

0000a810 <__aeabi_f2d>:
    a810:	lsls	r2, r0, #1
    a812:	mov.w	r1, r2, asr #3
    a816:	mov.w	r1, r1, rrx
    a81a:	mov.w	r0, r2, lsl #28
    a81e:	itttt	ne
    a820:	andsne.w	r3, r2, #4278190080	; 0xff000000
    a824:	teqne	r3, #4278190080	; 0xff000000
    a828:	eorne.w	r1, r1, #939524096	; 0x38000000
    a82c:	bxne	lr
    a82e:	teq	r2, #0
    a832:	ite	ne
    a834:	teqne	r3, #4278190080	; 0xff000000
    a838:	bxeq	lr
    a83a:	push	{r4, r5, lr}
    a83c:	mov.w	r4, #896	; 0x380
    a840:	and.w	r5, r1, #2147483648	; 0x80000000
    a844:	bic.w	r1, r1, #2147483648	; 0x80000000
    a848:	b.n	a68c <__adddf3+0x138>
    a84a:	nop

0000a84c <__aeabi_ul2d>:
    a84c:	orrs.w	r2, r0, r1
    a850:	it	eq
    a852:	bxeq	lr
    a854:	push	{r4, r5, lr}
    a856:	mov.w	r5, #0
    a85a:	b.n	a872 <__aeabi_l2d+0x16>

0000a85c <__aeabi_l2d>:
    a85c:	orrs.w	r2, r0, r1
    a860:	it	eq
    a862:	bxeq	lr
    a864:	push	{r4, r5, lr}
    a866:	ands.w	r5, r1, #2147483648	; 0x80000000
    a86a:	bpl.n	a872 <__aeabi_l2d+0x16>
    a86c:	negs	r0, r0
    a86e:	sbc.w	r1, r1, r1, lsl #1
    a872:	mov.w	r4, #1024	; 0x400
    a876:	add.w	r4, r4, #50	; 0x32
    a87a:	movs.w	ip, r1, lsr #22
    a87e:	beq.w	a63a <__adddf3+0xe6>
    a882:	mov.w	r2, #3
    a886:	movs.w	ip, ip, lsr #3
    a88a:	it	ne
    a88c:	addne	r2, #3
    a88e:	movs.w	ip, ip, lsr #3
    a892:	it	ne
    a894:	addne	r2, #3
    a896:	add.w	r2, r2, ip, lsr #3
    a89a:	rsb	r3, r2, #32
    a89e:	lsl.w	ip, r0, r3
    a8a2:	lsr.w	r0, r0, r2
    a8a6:	lsl.w	lr, r1, r3
    a8aa:	orr.w	r0, r0, lr
    a8ae:	lsr.w	r1, r1, r2
    a8b2:	add	r4, r2
    a8b4:	b.n	a63a <__adddf3+0xe6>
    a8b6:	nop

0000a8b8 <__aeabi_dmul>:
    a8b8:	push	{r4, r5, r6, lr}
    a8ba:	mov.w	ip, #255	; 0xff
    a8be:	orr.w	ip, ip, #1792	; 0x700
    a8c2:	ands.w	r4, ip, r1, lsr #20
    a8c6:	ittte	ne
    a8c8:	andsne.w	r5, ip, r3, lsr #20
    a8cc:	teqne	r4, ip
    a8d0:	teqne	r5, ip
    a8d4:	bleq	aa94 <__aeabi_dmul+0x1dc>
    a8d8:	add	r4, r5
    a8da:	eor.w	r6, r1, r3
    a8de:	bic.w	r1, r1, ip, lsl #21
    a8e2:	bic.w	r3, r3, ip, lsl #21
    a8e6:	orrs.w	r5, r0, r1, lsl #12
    a8ea:	it	ne
    a8ec:	orrsne.w	r5, r2, r3, lsl #12
    a8f0:	orr.w	r1, r1, #1048576	; 0x100000
    a8f4:	orr.w	r3, r3, #1048576	; 0x100000
    a8f8:	beq.n	a96c <__aeabi_dmul+0xb4>
    a8fa:	umull	ip, lr, r0, r2
    a8fe:	mov.w	r5, #0
    a902:	umlal	lr, r5, r1, r2
    a906:	and.w	r2, r6, #2147483648	; 0x80000000
    a90a:	umlal	lr, r5, r0, r3
    a90e:	mov.w	r6, #0
    a912:	umlal	r5, r6, r1, r3
    a916:	teq	ip, #0
    a91a:	it	ne
    a91c:	orrne.w	lr, lr, #1
    a920:	sub.w	r4, r4, #255	; 0xff
    a924:	cmp.w	r6, #512	; 0x200
    a928:	sbc.w	r4, r4, #768	; 0x300
    a92c:	bcs.n	a938 <__aeabi_dmul+0x80>
    a92e:	movs.w	lr, lr, lsl #1
    a932:	adcs	r5, r5
    a934:	adc.w	r6, r6, r6
    a938:	orr.w	r1, r2, r6, lsl #11
    a93c:	orr.w	r1, r1, r5, lsr #21
    a940:	mov.w	r0, r5, lsl #11
    a944:	orr.w	r0, r0, lr, lsr #21
    a948:	mov.w	lr, lr, lsl #11
    a94c:	subs.w	ip, r4, #253	; 0xfd
    a950:	it	hi
    a952:	cmphi.w	ip, #1792	; 0x700
    a956:	bhi.n	a996 <__aeabi_dmul+0xde>
    a958:	cmp.w	lr, #2147483648	; 0x80000000
    a95c:	it	eq
    a95e:	movseq.w	lr, r0, lsr #1
    a962:	adcs.w	r0, r0, #0
    a966:	adc.w	r1, r1, r4, lsl #20
    a96a:	pop	{r4, r5, r6, pc}
    a96c:	and.w	r6, r6, #2147483648	; 0x80000000
    a970:	orr.w	r1, r6, r1
    a974:	orr.w	r0, r0, r2
    a978:	eor.w	r1, r1, r3
    a97c:	subs.w	r4, r4, ip, lsr #1
    a980:	ittt	gt
    a982:	rsbsgt	r5, r4, ip
    a986:	orrgt.w	r1, r1, r4, lsl #20
    a98a:	popgt	{r4, r5, r6, pc}
    a98c:	orr.w	r1, r1, #1048576	; 0x100000
    a990:	mov.w	lr, #0
    a994:	subs	r4, #1
    a996:	bgt.w	aaf0 <__aeabi_dmul+0x238>
    a99a:	cmn.w	r4, #54	; 0x36
    a99e:	ittt	le
    a9a0:	movle	r0, #0
    a9a2:	andle.w	r1, r1, #2147483648	; 0x80000000
    a9a6:	pople	{r4, r5, r6, pc}
    a9a8:	rsb	r4, r4, #0
    a9ac:	subs	r4, #32
    a9ae:	bge.n	aa1c <__aeabi_dmul+0x164>
    a9b0:	adds	r4, #12
    a9b2:	bgt.n	a9ec <__aeabi_dmul+0x134>
    a9b4:	add.w	r4, r4, #20
    a9b8:	rsb	r5, r4, #32
    a9bc:	lsl.w	r3, r0, r5
    a9c0:	lsr.w	r0, r0, r4
    a9c4:	lsl.w	r2, r1, r5
    a9c8:	orr.w	r0, r0, r2
    a9cc:	and.w	r2, r1, #2147483648	; 0x80000000
    a9d0:	bic.w	r1, r1, #2147483648	; 0x80000000
    a9d4:	adds.w	r0, r0, r3, lsr #31
    a9d8:	lsr.w	r6, r1, r4
    a9dc:	adc.w	r1, r2, r6
    a9e0:	orrs.w	lr, lr, r3, lsl #1
    a9e4:	it	eq
    a9e6:	biceq.w	r0, r0, r3, lsr #31
    a9ea:	pop	{r4, r5, r6, pc}
    a9ec:	rsb	r4, r4, #12
    a9f0:	rsb	r5, r4, #32
    a9f4:	lsl.w	r3, r0, r4
    a9f8:	lsr.w	r0, r0, r5
    a9fc:	lsl.w	r2, r1, r4
    aa00:	orr.w	r0, r0, r2
    aa04:	and.w	r1, r1, #2147483648	; 0x80000000
    aa08:	adds.w	r0, r0, r3, lsr #31
    aa0c:	adc.w	r1, r1, #0
    aa10:	orrs.w	lr, lr, r3, lsl #1
    aa14:	it	eq
    aa16:	biceq.w	r0, r0, r3, lsr #31
    aa1a:	pop	{r4, r5, r6, pc}
    aa1c:	rsb	r5, r4, #32
    aa20:	lsl.w	r2, r0, r5
    aa24:	orr.w	lr, lr, r2
    aa28:	lsr.w	r3, r0, r4
    aa2c:	lsl.w	r2, r1, r5
    aa30:	orr.w	r3, r3, r2
    aa34:	lsr.w	r0, r1, r4
    aa38:	and.w	r1, r1, #2147483648	; 0x80000000
    aa3c:	lsr.w	r2, r1, r4
    aa40:	bic.w	r0, r0, r2
    aa44:	add.w	r0, r0, r3, lsr #31
    aa48:	orrs.w	lr, lr, r3, lsl #1
    aa4c:	it	eq
    aa4e:	biceq.w	r0, r0, r3, lsr #31
    aa52:	pop	{r4, r5, r6, pc}
    aa54:	teq	r4, #0
    aa58:	bne.n	aa7a <__aeabi_dmul+0x1c2>
    aa5a:	and.w	r6, r1, #2147483648	; 0x80000000
    aa5e:	lsls	r0, r0, #1
    aa60:	adc.w	r1, r1, r1
    aa64:	tst.w	r1, #1048576	; 0x100000
    aa68:	it	eq
    aa6a:	subeq	r4, #1
    aa6c:	beq.n	aa5e <__aeabi_dmul+0x1a6>
    aa6e:	orr.w	r1, r1, r6
    aa72:	teq	r5, #0
    aa76:	it	ne
    aa78:	bxne	lr
    aa7a:	and.w	r6, r3, #2147483648	; 0x80000000
    aa7e:	lsls	r2, r2, #1
    aa80:	adc.w	r3, r3, r3
    aa84:	tst.w	r3, #1048576	; 0x100000
    aa88:	it	eq
    aa8a:	subeq	r5, #1
    aa8c:	beq.n	aa7e <__aeabi_dmul+0x1c6>
    aa8e:	orr.w	r3, r3, r6
    aa92:	bx	lr
    aa94:	teq	r4, ip
    aa98:	and.w	r5, ip, r3, lsr #20
    aa9c:	it	ne
    aa9e:	teqne	r5, ip
    aaa2:	beq.n	aabe <__aeabi_dmul+0x206>
    aaa4:	orrs.w	r6, r0, r1, lsl #1
    aaa8:	it	ne
    aaaa:	orrsne.w	r6, r2, r3, lsl #1
    aaae:	bne.n	aa54 <__aeabi_dmul+0x19c>
    aab0:	eor.w	r1, r1, r3
    aab4:	and.w	r1, r1, #2147483648	; 0x80000000
    aab8:	mov.w	r0, #0
    aabc:	pop	{r4, r5, r6, pc}
    aabe:	orrs.w	r6, r0, r1, lsl #1
    aac2:	itte	eq
    aac4:	moveq	r0, r2
    aac6:	moveq	r1, r3
    aac8:	orrsne.w	r6, r2, r3, lsl #1
    aacc:	beq.n	ab02 <__aeabi_dmul+0x24a>
    aace:	teq	r4, ip
    aad2:	bne.n	aada <__aeabi_dmul+0x222>
    aad4:	orrs.w	r6, r0, r1, lsl #12
    aad8:	bne.n	ab02 <__aeabi_dmul+0x24a>
    aada:	teq	r5, ip
    aade:	bne.n	aaec <__aeabi_dmul+0x234>
    aae0:	orrs.w	r6, r2, r3, lsl #12
    aae4:	itt	ne
    aae6:	movne	r0, r2
    aae8:	movne	r1, r3
    aaea:	bne.n	ab02 <__aeabi_dmul+0x24a>
    aaec:	eor.w	r1, r1, r3
    aaf0:	and.w	r1, r1, #2147483648	; 0x80000000
    aaf4:	orr.w	r1, r1, #2130706432	; 0x7f000000
    aaf8:	orr.w	r1, r1, #15728640	; 0xf00000
    aafc:	mov.w	r0, #0
    ab00:	pop	{r4, r5, r6, pc}
    ab02:	orr.w	r1, r1, #2130706432	; 0x7f000000
    ab06:	orr.w	r1, r1, #16252928	; 0xf80000
    ab0a:	pop	{r4, r5, r6, pc}

0000ab0c <__aeabi_ddiv>:
    ab0c:	push	{r4, r5, r6, lr}
    ab0e:	mov.w	ip, #255	; 0xff
    ab12:	orr.w	ip, ip, #1792	; 0x700
    ab16:	ands.w	r4, ip, r1, lsr #20
    ab1a:	ittte	ne
    ab1c:	andsne.w	r5, ip, r3, lsr #20
    ab20:	teqne	r4, ip
    ab24:	teqne	r5, ip
    ab28:	bleq	ac7a <__aeabi_ddiv+0x16e>
    ab2c:	sub.w	r4, r4, r5
    ab30:	eor.w	lr, r1, r3
    ab34:	orrs.w	r5, r2, r3, lsl #12
    ab38:	mov.w	r1, r1, lsl #12
    ab3c:	beq.w	ac50 <__aeabi_ddiv+0x144>
    ab40:	mov.w	r3, r3, lsl #12
    ab44:	mov.w	r5, #268435456	; 0x10000000
    ab48:	orr.w	r3, r5, r3, lsr #4
    ab4c:	orr.w	r3, r3, r2, lsr #24
    ab50:	mov.w	r2, r2, lsl #8
    ab54:	orr.w	r5, r5, r1, lsr #4
    ab58:	orr.w	r5, r5, r0, lsr #24
    ab5c:	mov.w	r6, r0, lsl #8
    ab60:	and.w	r1, lr, #2147483648	; 0x80000000
    ab64:	cmp	r5, r3
    ab66:	it	eq
    ab68:	cmpeq	r6, r2
    ab6a:	adc.w	r4, r4, #253	; 0xfd
    ab6e:	add.w	r4, r4, #768	; 0x300
    ab72:	bcs.n	ab7a <__aeabi_ddiv+0x6e>
    ab74:	lsrs	r3, r3, #1
    ab76:	mov.w	r2, r2, rrx
    ab7a:	subs	r6, r6, r2
    ab7c:	sbc.w	r5, r5, r3
    ab80:	lsrs	r3, r3, #1
    ab82:	mov.w	r2, r2, rrx
    ab86:	mov.w	r0, #1048576	; 0x100000
    ab8a:	mov.w	ip, #524288	; 0x80000
    ab8e:	subs.w	lr, r6, r2
    ab92:	sbcs.w	lr, r5, r3
    ab96:	ittt	cs
    ab98:	subcs	r6, r6, r2
    ab9a:	movcs	r5, lr
    ab9c:	orrcs.w	r0, r0, ip
    aba0:	lsrs	r3, r3, #1
    aba2:	mov.w	r2, r2, rrx
    aba6:	subs.w	lr, r6, r2
    abaa:	sbcs.w	lr, r5, r3
    abae:	ittt	cs
    abb0:	subcs	r6, r6, r2
    abb2:	movcs	r5, lr
    abb4:	orrcs.w	r0, r0, ip, lsr #1
    abb8:	lsrs	r3, r3, #1
    abba:	mov.w	r2, r2, rrx
    abbe:	subs.w	lr, r6, r2
    abc2:	sbcs.w	lr, r5, r3
    abc6:	ittt	cs
    abc8:	subcs	r6, r6, r2
    abca:	movcs	r5, lr
    abcc:	orrcs.w	r0, r0, ip, lsr #2
    abd0:	lsrs	r3, r3, #1
    abd2:	mov.w	r2, r2, rrx
    abd6:	subs.w	lr, r6, r2
    abda:	sbcs.w	lr, r5, r3
    abde:	ittt	cs
    abe0:	subcs	r6, r6, r2
    abe2:	movcs	r5, lr
    abe4:	orrcs.w	r0, r0, ip, lsr #3
    abe8:	orrs.w	lr, r5, r6
    abec:	beq.n	ac20 <__aeabi_ddiv+0x114>
    abee:	mov.w	r5, r5, lsl #4
    abf2:	orr.w	r5, r5, r6, lsr #28
    abf6:	mov.w	r6, r6, lsl #4
    abfa:	mov.w	r3, r3, lsl #3
    abfe:	orr.w	r3, r3, r2, lsr #29
    ac02:	mov.w	r2, r2, lsl #3
    ac06:	movs.w	ip, ip, lsr #4
    ac0a:	bne.n	ab8e <__aeabi_ddiv+0x82>
    ac0c:	tst.w	r1, #1048576	; 0x100000
    ac10:	bne.n	ac2a <__aeabi_ddiv+0x11e>
    ac12:	orr.w	r1, r1, r0
    ac16:	mov.w	r0, #0
    ac1a:	mov.w	ip, #2147483648	; 0x80000000
    ac1e:	b.n	ab8e <__aeabi_ddiv+0x82>
    ac20:	tst.w	r1, #1048576	; 0x100000
    ac24:	itt	eq
    ac26:	orreq	r1, r0
    ac28:	moveq	r0, #0
    ac2a:	subs.w	ip, r4, #253	; 0xfd
    ac2e:	it	hi
    ac30:	cmphi.w	ip, #1792	; 0x700
    ac34:	bhi.w	a996 <__aeabi_dmul+0xde>
    ac38:	subs.w	ip, r5, r3
    ac3c:	itt	eq
    ac3e:	subseq.w	ip, r6, r2
    ac42:	movseq.w	ip, r0, lsr #1
    ac46:	adcs.w	r0, r0, #0
    ac4a:	adc.w	r1, r1, r4, lsl #20
    ac4e:	pop	{r4, r5, r6, pc}
    ac50:	and.w	lr, lr, #2147483648	; 0x80000000
    ac54:	orr.w	r1, lr, r1, lsr #12
    ac58:	adds.w	r4, r4, ip, lsr #1
    ac5c:	ittt	gt
    ac5e:	rsbsgt	r5, r4, ip
    ac62:	orrgt.w	r1, r1, r4, lsl #20
    ac66:	popgt	{r4, r5, r6, pc}
    ac68:	orr.w	r1, r1, #1048576	; 0x100000
    ac6c:	mov.w	lr, #0
    ac70:	subs	r4, #1
    ac72:	b.n	a996 <__aeabi_dmul+0xde>
    ac74:	orr.w	lr, r5, r6
    ac78:	b.n	a996 <__aeabi_dmul+0xde>
    ac7a:	and.w	r5, ip, r3, lsr #20
    ac7e:	teq	r4, ip
    ac82:	it	eq
    ac84:	teqeq	r5, ip
    ac88:	beq.w	ab02 <__aeabi_dmul+0x24a>
    ac8c:	teq	r4, ip
    ac90:	bne.n	aca8 <__aeabi_ddiv+0x19c>
    ac92:	orrs.w	r4, r0, r1, lsl #12
    ac96:	bne.w	ab02 <__aeabi_dmul+0x24a>
    ac9a:	teq	r5, ip
    ac9e:	bne.w	aaec <__aeabi_dmul+0x234>
    aca2:	mov	r0, r2
    aca4:	mov	r1, r3
    aca6:	b.n	ab02 <__aeabi_dmul+0x24a>
    aca8:	teq	r5, ip
    acac:	bne.n	acbc <__aeabi_ddiv+0x1b0>
    acae:	orrs.w	r5, r2, r3, lsl #12
    acb2:	beq.w	aab0 <__aeabi_dmul+0x1f8>
    acb6:	mov	r0, r2
    acb8:	mov	r1, r3
    acba:	b.n	ab02 <__aeabi_dmul+0x24a>
    acbc:	orrs.w	r6, r0, r1, lsl #1
    acc0:	it	ne
    acc2:	orrsne.w	r6, r2, r3, lsl #1
    acc6:	bne.w	aa54 <__aeabi_dmul+0x19c>
    acca:	orrs.w	r4, r0, r1, lsl #1
    acce:	bne.w	aaec <__aeabi_dmul+0x234>
    acd2:	orrs.w	r5, r2, r3, lsl #1
    acd6:	bne.w	aab0 <__aeabi_dmul+0x1f8>
    acda:	b.n	ab02 <__aeabi_dmul+0x24a>

0000acdc <__gedf2>:
    acdc:	mov.w	ip, #4294967295
    ace0:	b.n	acf0 <__cmpdf2+0x4>
    ace2:	nop

0000ace4 <__ledf2>:
    ace4:	mov.w	ip, #1
    ace8:	b.n	acf0 <__cmpdf2+0x4>
    acea:	nop

0000acec <__cmpdf2>:
    acec:	mov.w	ip, #1
    acf0:	str.w	ip, [sp, #-4]!
    acf4:	mov.w	ip, r1, lsl #1
    acf8:	mvns.w	ip, ip, asr #21
    acfc:	mov.w	ip, r3, lsl #1
    ad00:	it	ne
    ad02:	mvnsne.w	ip, ip, asr #21
    ad06:	beq.n	ad40 <__cmpdf2+0x54>
    ad08:	add	sp, #4
    ad0a:	orrs.w	ip, r0, r1, lsl #1
    ad0e:	ite	eq
    ad10:	orrseq.w	ip, r2, r3, lsl #1
    ad14:	teqne	r1, r3
    ad18:	ittt	eq
    ad1a:	teqeq	r0, r2
    ad1e:	moveq	r0, #0
    ad20:	bxeq	lr
    ad22:	cmn.w	r0, #0
    ad26:	teq	r1, r3
    ad2a:	it	pl
    ad2c:	cmppl	r1, r3
    ad2e:	it	eq
    ad30:	cmpeq	r0, r2
    ad32:	ite	cs
    ad34:	asrcs	r0, r3, #31
    ad36:	mvncc.w	r0, r3, asr #31
    ad3a:	orr.w	r0, r0, #1
    ad3e:	bx	lr
    ad40:	mov.w	ip, r1, lsl #1
    ad44:	mvns.w	ip, ip, asr #21
    ad48:	bne.n	ad50 <__cmpdf2+0x64>
    ad4a:	orrs.w	ip, r0, r1, lsl #12
    ad4e:	bne.n	ad60 <__cmpdf2+0x74>
    ad50:	mov.w	ip, r3, lsl #1
    ad54:	mvns.w	ip, ip, asr #21
    ad58:	bne.n	ad08 <__cmpdf2+0x1c>
    ad5a:	orrs.w	ip, r2, r3, lsl #12
    ad5e:	beq.n	ad08 <__cmpdf2+0x1c>
    ad60:	ldr.w	r0, [sp], #4
    ad64:	bx	lr
    ad66:	nop

0000ad68 <__aeabi_cdrcmple>:
    ad68:	mov	ip, r0
    ad6a:	mov	r0, r2
    ad6c:	mov	r2, ip
    ad6e:	mov	ip, r1
    ad70:	mov	r1, r3
    ad72:	mov	r3, ip
    ad74:	b.n	ad78 <__aeabi_cdcmpeq>
    ad76:	nop

0000ad78 <__aeabi_cdcmpeq>:
    ad78:	push	{r0, lr}
    ad7a:	bl	acec <__cmpdf2>
    ad7e:	cmp	r0, #0
    ad80:	it	mi
    ad82:	cmnmi.w	r0, #0
    ad86:	pop	{r0, pc}

0000ad88 <__aeabi_dcmpeq>:
    ad88:	str.w	lr, [sp, #-8]!
    ad8c:	bl	ad78 <__aeabi_cdcmpeq>
    ad90:	ite	eq
    ad92:	moveq	r0, #1
    ad94:	movne	r0, #0
    ad96:	ldr.w	pc, [sp], #8
    ad9a:	nop

0000ad9c <__aeabi_dcmplt>:
    ad9c:	str.w	lr, [sp, #-8]!
    ada0:	bl	ad78 <__aeabi_cdcmpeq>
    ada4:	ite	cc
    ada6:	movcc	r0, #1
    ada8:	movcs	r0, #0
    adaa:	ldr.w	pc, [sp], #8
    adae:	nop

0000adb0 <__aeabi_dcmple>:
    adb0:	str.w	lr, [sp, #-8]!
    adb4:	bl	ad78 <__aeabi_cdcmpeq>
    adb8:	ite	ls
    adba:	movls	r0, #1
    adbc:	movhi	r0, #0
    adbe:	ldr.w	pc, [sp], #8
    adc2:	nop

0000adc4 <__aeabi_dcmpge>:
    adc4:	str.w	lr, [sp, #-8]!
    adc8:	bl	ad68 <__aeabi_cdrcmple>
    adcc:	ite	ls
    adce:	movls	r0, #1
    add0:	movhi	r0, #0
    add2:	ldr.w	pc, [sp], #8
    add6:	nop

0000add8 <__aeabi_dcmpgt>:
    add8:	str.w	lr, [sp, #-8]!
    addc:	bl	ad68 <__aeabi_cdrcmple>
    ade0:	ite	cc
    ade2:	movcc	r0, #1
    ade4:	movcs	r0, #0
    ade6:	ldr.w	pc, [sp], #8
    adea:	nop

0000adec <__aeabi_dcmpun>:
    adec:	mov.w	ip, r1, lsl #1
    adf0:	mvns.w	ip, ip, asr #21
    adf4:	bne.n	adfc <__aeabi_dcmpun+0x10>
    adf6:	orrs.w	ip, r0, r1, lsl #12
    adfa:	bne.n	ae12 <__aeabi_dcmpun+0x26>
    adfc:	mov.w	ip, r3, lsl #1
    ae00:	mvns.w	ip, ip, asr #21
    ae04:	bne.n	ae0c <__aeabi_dcmpun+0x20>
    ae06:	orrs.w	ip, r2, r3, lsl #12
    ae0a:	bne.n	ae12 <__aeabi_dcmpun+0x26>
    ae0c:	mov.w	r0, #0
    ae10:	bx	lr
    ae12:	mov.w	r0, #1
    ae16:	bx	lr

0000ae18 <__aeabi_d2iz>:
    ae18:	mov.w	r2, r1, lsl #1
    ae1c:	adds.w	r2, r2, #2097152	; 0x200000
    ae20:	bcs.n	ae4e <__aeabi_d2iz+0x36>
    ae22:	bpl.n	ae48 <__aeabi_d2iz+0x30>
    ae24:	mvn.w	r3, #992	; 0x3e0
    ae28:	subs.w	r2, r3, r2, asr #21
    ae2c:	bls.n	ae54 <__aeabi_d2iz+0x3c>
    ae2e:	mov.w	r3, r1, lsl #11
    ae32:	orr.w	r3, r3, #2147483648	; 0x80000000
    ae36:	orr.w	r3, r3, r0, lsr #21
    ae3a:	tst.w	r1, #2147483648	; 0x80000000
    ae3e:	lsr.w	r0, r3, r2
    ae42:	it	ne
    ae44:	negne	r0, r0
    ae46:	bx	lr
    ae48:	mov.w	r0, #0
    ae4c:	bx	lr
    ae4e:	orrs.w	r0, r0, r1, lsl #12
    ae52:	bne.n	ae60 <__aeabi_d2iz+0x48>
    ae54:	ands.w	r0, r1, #2147483648	; 0x80000000
    ae58:	it	eq
    ae5a:	mvneq.w	r0, #2147483648	; 0x80000000
    ae5e:	bx	lr
    ae60:	mov.w	r0, #0
    ae64:	bx	lr
    ae66:	nop

0000ae68 <__aeabi_d2uiz>:
    ae68:	lsls	r2, r1, #1
    ae6a:	bcs.n	ae90 <__aeabi_d2uiz+0x28>
    ae6c:	adds.w	r2, r2, #2097152	; 0x200000
    ae70:	bcs.n	ae96 <__aeabi_d2uiz+0x2e>
    ae72:	bpl.n	ae90 <__aeabi_d2uiz+0x28>
    ae74:	mvn.w	r3, #992	; 0x3e0
    ae78:	subs.w	r2, r3, r2, asr #21
    ae7c:	bmi.n	ae9c <__aeabi_d2uiz+0x34>
    ae7e:	mov.w	r3, r1, lsl #11
    ae82:	orr.w	r3, r3, #2147483648	; 0x80000000
    ae86:	orr.w	r3, r3, r0, lsr #21
    ae8a:	lsr.w	r0, r3, r2
    ae8e:	bx	lr
    ae90:	mov.w	r0, #0
    ae94:	bx	lr
    ae96:	orrs.w	r0, r0, r1, lsl #12
    ae9a:	bne.n	aea2 <__aeabi_d2uiz+0x3a>
    ae9c:	mov.w	r0, #4294967295
    aea0:	bx	lr
    aea2:	mov.w	r0, #0
    aea6:	bx	lr

0000aea8 <__aeabi_d2f>:
    aea8:	mov.w	r2, r1, lsl #1
    aeac:	subs.w	r3, r2, #1879048192	; 0x70000000
    aeb0:	itt	cs
    aeb2:	subscs.w	ip, r3, #2097152	; 0x200000
    aeb6:	rsbscs	ip, ip, #532676608	; 0x1fc00000
    aeba:	bls.n	aed8 <__aeabi_d2f+0x30>
    aebc:	and.w	ip, r1, #2147483648	; 0x80000000
    aec0:	mov.w	r2, r0, lsl #3
    aec4:	orr.w	r0, ip, r0, lsr #29
    aec8:	cmp.w	r2, #2147483648	; 0x80000000
    aecc:	adc.w	r0, r0, r3, lsl #2
    aed0:	it	eq
    aed2:	biceq.w	r0, r0, #1
    aed6:	bx	lr
    aed8:	tst.w	r1, #1073741824	; 0x40000000
    aedc:	bne.n	af22 <__aeabi_d2f+0x7a>
    aede:	adds.w	r2, r3, #48234496	; 0x2e00000
    aee2:	itt	lt
    aee4:	andlt.w	r0, r1, #2147483648	; 0x80000000
    aee8:	bxlt	lr
    aeea:	orr.w	r1, r1, #1048576	; 0x100000
    aeee:	mov.w	r2, r2, lsr #21
    aef2:	rsb	r2, r2, #24
    aef6:	rsb	ip, r2, #32
    aefa:	lsls.w	r3, r0, ip
    aefe:	lsr.w	r0, r0, r2
    af02:	it	ne
    af04:	orrne.w	r0, r0, #1
    af08:	mov.w	r3, r1, lsl #11
    af0c:	mov.w	r3, r3, lsr #11
    af10:	lsl.w	ip, r3, ip
    af14:	orr.w	r0, r0, ip
    af18:	lsr.w	r3, r3, r2
    af1c:	mov.w	r3, r3, lsl #1
    af20:	b.n	aebc <__aeabi_d2f+0x14>
    af22:	mvns.w	r3, r2, asr #21
    af26:	bne.n	af38 <__aeabi_d2f+0x90>
    af28:	orrs.w	r3, r0, r1, lsl #12
    af2c:	ittt	ne
    af2e:	movne.w	r0, #2130706432	; 0x7f000000
    af32:	orrne.w	r0, r0, #12582912	; 0xc00000
    af36:	bxne	lr
    af38:	and.w	r0, r1, #2147483648	; 0x80000000
    af3c:	orr.w	r0, r0, #2130706432	; 0x7f000000
    af40:	orr.w	r0, r0, #8388608	; 0x800000
    af44:	bx	lr
    af46:	nop

0000af48 <__aeabi_uldivmod>:
    af48:	cbnz	r3, af60 <__aeabi_uldivmod+0x18>
    af4a:	cbnz	r2, af60 <__aeabi_uldivmod+0x18>
    af4c:	cmp	r1, #0
    af4e:	it	eq
    af50:	cmpeq	r0, #0
    af52:	itt	ne
    af54:	movne.w	r1, #4294967295
    af58:	movne.w	r0, #4294967295
    af5c:	b.w	b25c <__aeabi_idiv0>
    af60:	sub.w	ip, sp, #8
    af64:	strd	ip, lr, [sp, #-16]!
    af68:	bl	af78 <__udivmoddi4>
    af6c:	ldr.w	lr, [sp, #4]
    af70:	ldrd	r2, r3, [sp, #8]
    af74:	add	sp, #16
    af76:	bx	lr

0000af78 <__udivmoddi4>:
    af78:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    af7c:	mov	ip, r1
    af7e:	mov	r6, r1
    af80:	mov	r4, r0
    af82:	ldr	r5, [sp, #32]
    af84:	cmp	r3, #0
    af86:	bne.n	b02a <__udivmoddi4+0xb2>
    af88:	cmp	r2, r1
    af8a:	mov	r7, r2
    af8c:	bls.n	b068 <__udivmoddi4+0xf0>
    af8e:	clz	lr, r2
    af92:	cmp.w	lr, #0
    af96:	beq.n	afb0 <__udivmoddi4+0x38>
    af98:	rsb	r4, lr, #32
    af9c:	lsr.w	r4, r0, r4
    afa0:	lsl.w	r6, r1, lr
    afa4:	orr.w	ip, r4, r6
    afa8:	lsl.w	r7, r2, lr
    afac:	lsl.w	r4, r0, lr
    afb0:	mov.w	r9, r7, lsr #16
    afb4:	lsrs	r2, r4, #16
    afb6:	udiv	r0, ip, r9
    afba:	uxth.w	r8, r7
    afbe:	mls	r6, r9, r0, ip
    afc2:	orr.w	r6, r2, r6, lsl #16
    afc6:	mul.w	r3, r0, r8
    afca:	cmp	r3, r6
    afcc:	bls.n	afe2 <__udivmoddi4+0x6a>
    afce:	adds	r6, r6, r7
    afd0:	add.w	r2, r0, #4294967295
    afd4:	bcs.w	b21c <__udivmoddi4+0x2a4>
    afd8:	cmp	r3, r6
    afda:	bls.w	b21c <__udivmoddi4+0x2a4>
    afde:	subs	r0, #2
    afe0:	add	r6, r7
    afe2:	subs	r6, r6, r3
    afe4:	uxth	r2, r4
    afe6:	udiv	r3, r6, r9
    afea:	mls	r6, r9, r3, r6
    afee:	orr.w	r4, r2, r6, lsl #16
    aff2:	mul.w	r8, r3, r8
    aff6:	cmp	r8, r4
    aff8:	bls.n	b00e <__udivmoddi4+0x96>
    affa:	adds	r4, r4, r7
    affc:	add.w	r2, r3, #4294967295
    b000:	bcs.w	b218 <__udivmoddi4+0x2a0>
    b004:	cmp	r8, r4
    b006:	bls.w	b218 <__udivmoddi4+0x2a0>
    b00a:	subs	r3, #2
    b00c:	add	r4, r7
    b00e:	rsb	r4, r8, r4
    b012:	orr.w	r0, r3, r0, lsl #16
    b016:	movs	r1, #0
    b018:	cmp	r5, #0
    b01a:	beq.n	b0e2 <__udivmoddi4+0x16a>
    b01c:	lsr.w	r4, r4, lr
    b020:	movs	r3, #0
    b022:	str	r4, [r5, #0]
    b024:	str	r3, [r5, #4]
    b026:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b02a:	cmp	r3, r1
    b02c:	bls.n	b03e <__udivmoddi4+0xc6>
    b02e:	cmp	r5, #0
    b030:	beq.n	b0de <__udivmoddi4+0x166>
    b032:	movs	r1, #0
    b034:	stmia.w	r5, {r0, r6}
    b038:	mov	r0, r1
    b03a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b03e:	clz	r1, r3
    b042:	cmp	r1, #0
    b044:	bne.w	b168 <__udivmoddi4+0x1f0>
    b048:	cmp	r3, r6
    b04a:	bcc.n	b052 <__udivmoddi4+0xda>
    b04c:	cmp	r2, r0
    b04e:	bhi.w	b242 <__udivmoddi4+0x2ca>
    b052:	subs	r4, r0, r2
    b054:	sbc.w	r6, r6, r3
    b058:	movs	r0, #1
    b05a:	mov	ip, r6
    b05c:	cmp	r5, #0
    b05e:	beq.n	b0e2 <__udivmoddi4+0x16a>
    b060:	stmia.w	r5, {r4, ip}
    b064:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b068:	cbnz	r2, b070 <__udivmoddi4+0xf8>
    b06a:	movs	r7, #1
    b06c:	udiv	r7, r7, r2
    b070:	clz	lr, r7
    b074:	cmp.w	lr, #0
    b078:	bne.n	b0e6 <__udivmoddi4+0x16e>
    b07a:	subs	r3, r6, r7
    b07c:	mov.w	r8, r7, lsr #16
    b080:	uxth.w	ip, r7
    b084:	movs	r1, #1
    b086:	udiv	r0, r3, r8
    b08a:	lsrs	r2, r4, #16
    b08c:	mls	r6, r8, r0, r3
    b090:	orr.w	r6, r2, r6, lsl #16
    b094:	mul.w	r3, ip, r0
    b098:	cmp	r3, r6
    b09a:	bls.n	b0ac <__udivmoddi4+0x134>
    b09c:	adds	r6, r6, r7
    b09e:	add.w	r2, r0, #4294967295
    b0a2:	bcs.n	b0aa <__udivmoddi4+0x132>
    b0a4:	cmp	r3, r6
    b0a6:	bhi.w	b246 <__udivmoddi4+0x2ce>
    b0aa:	mov	r0, r2
    b0ac:	subs	r6, r6, r3
    b0ae:	uxth	r2, r4
    b0b0:	udiv	r3, r6, r8
    b0b4:	mls	r6, r8, r3, r6
    b0b8:	orr.w	r4, r2, r6, lsl #16
    b0bc:	mul.w	ip, ip, r3
    b0c0:	cmp	ip, r4
    b0c2:	bls.n	b0d4 <__udivmoddi4+0x15c>
    b0c4:	adds	r4, r4, r7
    b0c6:	add.w	r2, r3, #4294967295
    b0ca:	bcs.n	b0d2 <__udivmoddi4+0x15a>
    b0cc:	cmp	ip, r4
    b0ce:	bhi.w	b23c <__udivmoddi4+0x2c4>
    b0d2:	mov	r3, r2
    b0d4:	rsb	r4, ip, r4
    b0d8:	orr.w	r0, r3, r0, lsl #16
    b0dc:	b.n	b018 <__udivmoddi4+0xa0>
    b0de:	mov	r1, r5
    b0e0:	mov	r0, r5
    b0e2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b0e6:	rsb	r1, lr, #32
    b0ea:	lsl.w	r3, r6, lr
    b0ee:	lsl.w	r7, r7, lr
    b0f2:	lsr.w	r9, r0, r1
    b0f6:	mov.w	r8, r7, lsr #16
    b0fa:	lsrs	r6, r1
    b0fc:	orr.w	r9, r9, r3
    b100:	udiv	sl, r6, r8
    b104:	mov.w	r4, r9, lsr #16
    b108:	mls	r6, r8, sl, r6
    b10c:	uxth.w	ip, r7
    b110:	orr.w	r3, r4, r6, lsl #16
    b114:	mul.w	r2, sl, ip
    b118:	cmp	r2, r3
    b11a:	lsl.w	r4, r0, lr
    b11e:	bls.n	b136 <__udivmoddi4+0x1be>
    b120:	adds	r3, r3, r7
    b122:	add.w	r1, sl, #4294967295
    b126:	bcs.w	b238 <__udivmoddi4+0x2c0>
    b12a:	cmp	r2, r3
    b12c:	bls.w	b238 <__udivmoddi4+0x2c0>
    b130:	sub.w	sl, sl, #2
    b134:	add	r3, r7
    b136:	subs	r3, r3, r2
    b138:	uxth.w	r9, r9
    b13c:	udiv	r1, r3, r8
    b140:	mls	r3, r8, r1, r3
    b144:	orr.w	r3, r9, r3, lsl #16
    b148:	mul.w	r6, r1, ip
    b14c:	cmp	r6, r3
    b14e:	bls.n	b160 <__udivmoddi4+0x1e8>
    b150:	adds	r3, r3, r7
    b152:	add.w	r2, r1, #4294967295
    b156:	bcs.n	b230 <__udivmoddi4+0x2b8>
    b158:	cmp	r6, r3
    b15a:	bls.n	b230 <__udivmoddi4+0x2b8>
    b15c:	subs	r1, #2
    b15e:	add	r3, r7
    b160:	subs	r3, r3, r6
    b162:	orr.w	r1, r1, sl, lsl #16
    b166:	b.n	b086 <__udivmoddi4+0x10e>
    b168:	rsb	lr, r1, #32
    b16c:	lsr.w	r4, r2, lr
    b170:	lsls	r3, r1
    b172:	orrs	r3, r4
    b174:	lsr.w	r7, r0, lr
    b178:	lsl.w	r4, r6, r1
    b17c:	mov.w	ip, r3, lsr #16
    b180:	lsr.w	r6, r6, lr
    b184:	orrs	r4, r7
    b186:	udiv	r9, r6, ip
    b18a:	lsrs	r7, r4, #16
    b18c:	mls	r6, ip, r9, r6
    b190:	uxth.w	r8, r3
    b194:	orr.w	r6, r7, r6, lsl #16
    b198:	mul.w	r7, r9, r8
    b19c:	cmp	r7, r6
    b19e:	lsl.w	r2, r2, r1
    b1a2:	lsl.w	sl, r0, r1
    b1a6:	bls.n	b1ba <__udivmoddi4+0x242>
    b1a8:	adds	r6, r6, r3
    b1aa:	add.w	r0, r9, #4294967295
    b1ae:	bcs.n	b234 <__udivmoddi4+0x2bc>
    b1b0:	cmp	r7, r6
    b1b2:	bls.n	b234 <__udivmoddi4+0x2bc>
    b1b4:	sub.w	r9, r9, #2
    b1b8:	add	r6, r3
    b1ba:	subs	r6, r6, r7
    b1bc:	uxth	r0, r4
    b1be:	udiv	r4, r6, ip
    b1c2:	mls	r6, ip, r4, r6
    b1c6:	orr.w	r7, r0, r6, lsl #16
    b1ca:	mul.w	r8, r4, r8
    b1ce:	cmp	r8, r7
    b1d0:	bls.n	b1e2 <__udivmoddi4+0x26a>
    b1d2:	adds	r7, r7, r3
    b1d4:	add.w	r0, r4, #4294967295
    b1d8:	bcs.n	b22c <__udivmoddi4+0x2b4>
    b1da:	cmp	r8, r7
    b1dc:	bls.n	b22c <__udivmoddi4+0x2b4>
    b1de:	subs	r4, #2
    b1e0:	add	r7, r3
    b1e2:	orr.w	r0, r4, r9, lsl #16
    b1e6:	rsb	r7, r8, r7
    b1ea:	umull	r8, r9, r0, r2
    b1ee:	cmp	r7, r9
    b1f0:	mov	r4, r8
    b1f2:	mov	r6, r9
    b1f4:	bcc.n	b220 <__udivmoddi4+0x2a8>
    b1f6:	beq.n	b24c <__udivmoddi4+0x2d4>
    b1f8:	cbz	r5, b254 <__udivmoddi4+0x2dc>
    b1fa:	subs.w	r3, sl, r4
    b1fe:	sbc.w	r7, r7, r6
    b202:	lsl.w	lr, r7, lr
    b206:	lsrs	r3, r1
    b208:	lsrs	r7, r1
    b20a:	orr.w	r3, lr, r3
    b20e:	stmia.w	r5, {r3, r7}
    b212:	movs	r1, #0
    b214:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b218:	mov	r3, r2
    b21a:	b.n	b00e <__udivmoddi4+0x96>
    b21c:	mov	r0, r2
    b21e:	b.n	afe2 <__udivmoddi4+0x6a>
    b220:	subs.w	r4, r8, r2
    b224:	sbc.w	r6, r9, r3
    b228:	subs	r0, #1
    b22a:	b.n	b1f8 <__udivmoddi4+0x280>
    b22c:	mov	r4, r0
    b22e:	b.n	b1e2 <__udivmoddi4+0x26a>
    b230:	mov	r1, r2
    b232:	b.n	b160 <__udivmoddi4+0x1e8>
    b234:	mov	r9, r0
    b236:	b.n	b1ba <__udivmoddi4+0x242>
    b238:	mov	sl, r1
    b23a:	b.n	b136 <__udivmoddi4+0x1be>
    b23c:	subs	r3, #2
    b23e:	add	r4, r7
    b240:	b.n	b0d4 <__udivmoddi4+0x15c>
    b242:	mov	r0, r1
    b244:	b.n	b05c <__udivmoddi4+0xe4>
    b246:	subs	r0, #2
    b248:	add	r6, r7
    b24a:	b.n	b0ac <__udivmoddi4+0x134>
    b24c:	cmp	sl, r8
    b24e:	bcc.n	b220 <__udivmoddi4+0x2a8>
    b250:	mov	r6, r7
    b252:	b.n	b1f8 <__udivmoddi4+0x280>
    b254:	mov	r1, r5
    b256:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b25a:	nop

0000b25c <__aeabi_idiv0>:
    b25c:	bx	lr
    b25e:	nop

0000b260 <__cxa_atexit>:
    b260:	mov	r3, r2
    b262:	mov	r2, r1
    b264:	mov	r1, r0
    b266:	movs	r0, #2
    b268:	b.w	f7a8 <__register_exitproc>

0000b26c <__errno>:
    b26c:	ldr	r3, [pc, #4]	; (b274 <__errno+0x8>)
    b26e:	ldr	r0, [r3, #0]
    b270:	bx	lr
    b272:	nop
    b274:	.word	0x1fff1828

0000b278 <__libc_init_array>:
    b278:	push	{r4, r5, r6, lr}
    b27a:	ldr	r6, [pc, #60]	; (b2b8 <__libc_init_array+0x40>)
    b27c:	ldr	r5, [pc, #60]	; (b2bc <__libc_init_array+0x44>)
    b27e:	subs	r6, r6, r5
    b280:	asrs	r6, r6, #2
    b282:	it	ne
    b284:	movne	r4, #0
    b286:	beq.n	b294 <__libc_init_array+0x1c>
    b288:	adds	r4, #1
    b28a:	ldr.w	r3, [r5], #4
    b28e:	blx	r3
    b290:	cmp	r6, r4
    b292:	bne.n	b288 <__libc_init_array+0x10>
    b294:	ldr	r6, [pc, #40]	; (b2c0 <__libc_init_array+0x48>)
    b296:	ldr	r5, [pc, #44]	; (b2c4 <__libc_init_array+0x4c>)
    b298:	subs	r6, r6, r5
    b29a:	bl	13524 <_init>
    b29e:	asrs	r6, r6, #2
    b2a0:	it	ne
    b2a2:	movne	r4, #0
    b2a4:	beq.n	b2b4 <__libc_init_array+0x3c>
    b2a6:	adds	r4, #1
    b2a8:	ldr.w	r3, [r5], #4
    b2ac:	blx	r3
    b2ae:	cmp	r6, r4
    b2b0:	bne.n	b2a6 <__libc_init_array+0x2e>
    b2b2:	pop	{r4, r5, r6, pc}
    b2b4:	pop	{r4, r5, r6, pc}
    b2b6:	nop
    b2b8:	.word	0x00013530
    b2bc:	.word	0x00013530
    b2c0:	.word	0x00013548
    b2c4:	.word	0x00013530

0000b2c8 <__get_current_locale>:
    b2c8:	ldr	r2, [pc, #12]	; (b2d8 <__get_current_locale+0x10>)
    b2ca:	ldr	r3, [pc, #16]	; (b2dc <__get_current_locale+0x14>)
    b2cc:	ldr	r2, [r2, #0]
    b2ce:	ldr	r0, [r2, #52]	; 0x34
    b2d0:	cmp	r0, #0
    b2d2:	it	eq
    b2d4:	moveq	r0, r3
    b2d6:	bx	lr
    b2d8:	.word	0x1fff1828
    b2dc:	.word	0x1fff182c

0000b2e0 <__locale_mb_cur_max>:
    b2e0:	ldr	r3, [pc, #16]	; (b2f4 <__locale_mb_cur_max+0x14>)
    b2e2:	ldr	r2, [pc, #20]	; (b2f8 <__locale_mb_cur_max+0x18>)
    b2e4:	ldr	r3, [r3, #0]
    b2e6:	ldr	r3, [r3, #52]	; 0x34
    b2e8:	cmp	r3, #0
    b2ea:	it	eq
    b2ec:	moveq	r3, r2
    b2ee:	ldrb.w	r0, [r3, #296]	; 0x128
    b2f2:	bx	lr
    b2f4:	.word	0x1fff1828
    b2f8:	.word	0x1fff182c

0000b2fc <__locale_ctype_ptr_l>:
    b2fc:	ldr.w	r0, [r0, #236]	; 0xec
    b300:	bx	lr
    b302:	nop

0000b304 <__locale_ctype_ptr>:
    b304:	push	{r3, lr}
    b306:	ldr	r3, [pc, #12]	; (b314 <__locale_ctype_ptr+0x10>)
    b308:	ldr	r0, [r3, #0]
    b30a:	bl	b2c8 <__get_current_locale>
    b30e:	ldr.w	r0, [r0, #236]	; 0xec
    b312:	pop	{r3, pc}
    b314:	.word	0x1fff1828

0000b318 <malloc>:
    b318:	ldr	r3, [pc, #8]	; (b324 <malloc+0xc>)
    b31a:	mov	r1, r0
    b31c:	ldr	r0, [r3, #0]
    b31e:	b.w	b338 <_malloc_r>
    b322:	nop
    b324:	.word	0x1fff1828

0000b328 <free>:
    b328:	ldr	r3, [pc, #8]	; (b334 <free+0xc>)
    b32a:	mov	r1, r0
    b32c:	ldr	r0, [r3, #0]
    b32e:	b.w	10890 <_free_r>
    b332:	nop
    b334:	.word	0x1fff1828

0000b338 <_malloc_r>:
    b338:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b33c:	add.w	r5, r1, #11
    b340:	cmp	r5, #22
    b342:	sub	sp, #12
    b344:	mov	r6, r0
    b346:	bls.w	b488 <_malloc_r+0x150>
    b34a:	bics.w	r5, r5, #7
    b34e:	bmi.w	b4d0 <_malloc_r+0x198>
    b352:	cmp	r1, r5
    b354:	bhi.w	b4d0 <_malloc_r+0x198>
    b358:	bl	baac <__malloc_lock>
    b35c:	cmp.w	r5, #504	; 0x1f8
    b360:	bcc.w	b89c <_malloc_r+0x564>
    b364:	lsrs	r3, r5, #9
    b366:	beq.w	b4de <_malloc_r+0x1a6>
    b36a:	cmp	r3, #4
    b36c:	bhi.w	b676 <_malloc_r+0x33e>
    b370:	lsrs	r0, r5, #6
    b372:	add.w	lr, r0, #57	; 0x39
    b376:	mov.w	r3, lr, lsl #1
    b37a:	adds	r0, #56	; 0x38
    b37c:	ldr	r7, [pc, #784]	; (b690 <_malloc_r+0x358>)
    b37e:	add.w	r3, r7, r3, lsl #2
    b382:	sub.w	r1, r3, #8
    b386:	ldr	r4, [r3, #4]
    b388:	cmp	r1, r4
    b38a:	bne.n	b39c <_malloc_r+0x64>
    b38c:	b.n	b4e8 <_malloc_r+0x1b0>
    b38e:	cmp	r2, #0
    b390:	bge.w	b4ec <_malloc_r+0x1b4>
    b394:	ldr	r4, [r4, #12]
    b396:	cmp	r1, r4
    b398:	beq.w	b4e8 <_malloc_r+0x1b0>
    b39c:	ldr	r3, [r4, #4]
    b39e:	bic.w	r3, r3, #3
    b3a2:	subs	r2, r3, r5
    b3a4:	cmp	r2, #15
    b3a6:	ble.n	b38e <_malloc_r+0x56>
    b3a8:	ldr	r1, [pc, #740]	; (b690 <_malloc_r+0x358>)
    b3aa:	ldr	r4, [r7, #16]
    b3ac:	add.w	lr, r1, #8
    b3b0:	cmp	r4, lr
    b3b2:	beq.w	b71c <_malloc_r+0x3e4>
    b3b6:	ldr	r3, [r4, #4]
    b3b8:	bic.w	r3, r3, #3
    b3bc:	subs	r2, r3, r5
    b3be:	cmp	r2, #15
    b3c0:	bgt.w	b6f6 <_malloc_r+0x3be>
    b3c4:	cmp	r2, #0
    b3c6:	str.w	lr, [r1, #20]
    b3ca:	str.w	lr, [r1, #16]
    b3ce:	bge.w	b50e <_malloc_r+0x1d6>
    b3d2:	cmp.w	r3, #512	; 0x200
    b3d6:	bcs.w	b6a8 <_malloc_r+0x370>
    b3da:	lsrs	r3, r3, #3
    b3dc:	add.w	ip, r3, #1
    b3e0:	movs	r2, #1
    b3e2:	asrs	r3, r3, #2
    b3e4:	lsl.w	r3, r2, r3
    b3e8:	ldr	r2, [r1, #4]
    b3ea:	ldr.w	r8, [r1, ip, lsl #3]
    b3ee:	str.w	r8, [r4, #8]
    b3f2:	add.w	r9, r1, ip, lsl #3
    b3f6:	orrs	r2, r3
    b3f8:	sub.w	r3, r9, #8
    b3fc:	str	r3, [r4, #12]
    b3fe:	str	r2, [r1, #4]
    b400:	str.w	r4, [r1, ip, lsl #3]
    b404:	str.w	r4, [r8, #12]
    b408:	asrs	r3, r0, #2
    b40a:	movs	r4, #1
    b40c:	lsls	r4, r3
    b40e:	cmp	r4, r2
    b410:	bhi.w	b528 <_malloc_r+0x1f0>
    b414:	tst	r4, r2
    b416:	bne.n	b426 <_malloc_r+0xee>
    b418:	bic.w	r0, r0, #3
    b41c:	lsls	r4, r4, #1
    b41e:	tst	r4, r2
    b420:	add.w	r0, r0, #4
    b424:	beq.n	b41c <_malloc_r+0xe4>
    b426:	add.w	r9, r7, r0, lsl #3
    b42a:	mov	ip, r9
    b42c:	mov	r8, r0
    b42e:	ldr.w	r1, [ip, #12]
    b432:	cmp	ip, r1
    b434:	bne.n	b446 <_malloc_r+0x10e>
    b436:	b.n	b720 <_malloc_r+0x3e8>
    b438:	cmp	r2, #0
    b43a:	bge.w	b740 <_malloc_r+0x408>
    b43e:	ldr	r1, [r1, #12]
    b440:	cmp	ip, r1
    b442:	beq.w	b720 <_malloc_r+0x3e8>
    b446:	ldr	r3, [r1, #4]
    b448:	bic.w	r3, r3, #3
    b44c:	subs	r2, r3, r5
    b44e:	cmp	r2, #15
    b450:	ble.n	b438 <_malloc_r+0x100>
    b452:	mov	r4, r1
    b454:	ldr.w	ip, [r1, #12]
    b458:	ldr.w	r8, [r4, #8]!
    b45c:	adds	r3, r1, r5
    b45e:	orr.w	r5, r5, #1
    b462:	str	r5, [r1, #4]
    b464:	orr.w	r1, r2, #1
    b468:	str.w	ip, [r8, #12]
    b46c:	mov	r0, r6
    b46e:	str.w	r8, [ip, #8]
    b472:	str	r3, [r7, #20]
    b474:	str	r3, [r7, #16]
    b476:	str.w	lr, [r3, #12]
    b47a:	str.w	lr, [r3, #8]
    b47e:	str	r1, [r3, #4]
    b480:	str	r2, [r3, r2]
    b482:	bl	bab0 <__malloc_unlock>
    b486:	b.n	b4c8 <_malloc_r+0x190>
    b488:	cmp	r1, #16
    b48a:	bhi.n	b4d0 <_malloc_r+0x198>
    b48c:	bl	baac <__malloc_lock>
    b490:	movs	r5, #16
    b492:	movs	r3, #6
    b494:	movs	r0, #2
    b496:	ldr	r7, [pc, #504]	; (b690 <_malloc_r+0x358>)
    b498:	add.w	r3, r7, r3, lsl #2
    b49c:	sub.w	r2, r3, #8
    b4a0:	ldr	r4, [r3, #4]
    b4a2:	cmp	r4, r2
    b4a4:	beq.w	b732 <_malloc_r+0x3fa>
    b4a8:	ldr	r3, [r4, #4]
    b4aa:	ldr	r1, [r4, #12]
    b4ac:	ldr	r5, [r4, #8]
    b4ae:	bic.w	r3, r3, #3
    b4b2:	add	r3, r4
    b4b4:	mov	r0, r6
    b4b6:	ldr	r2, [r3, #4]
    b4b8:	str	r1, [r5, #12]
    b4ba:	orr.w	r2, r2, #1
    b4be:	str	r5, [r1, #8]
    b4c0:	str	r2, [r3, #4]
    b4c2:	bl	bab0 <__malloc_unlock>
    b4c6:	adds	r4, #8
    b4c8:	mov	r0, r4
    b4ca:	add	sp, #12
    b4cc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b4d0:	movs	r4, #0
    b4d2:	movs	r3, #12
    b4d4:	mov	r0, r4
    b4d6:	str	r3, [r6, #0]
    b4d8:	add	sp, #12
    b4da:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b4de:	movs	r3, #128	; 0x80
    b4e0:	mov.w	lr, #64	; 0x40
    b4e4:	movs	r0, #63	; 0x3f
    b4e6:	b.n	b37c <_malloc_r+0x44>
    b4e8:	mov	r0, lr
    b4ea:	b.n	b3a8 <_malloc_r+0x70>
    b4ec:	add	r3, r4
    b4ee:	ldr	r1, [r4, #12]
    b4f0:	ldr	r2, [r3, #4]
    b4f2:	ldr	r5, [r4, #8]
    b4f4:	orr.w	r2, r2, #1
    b4f8:	str	r1, [r5, #12]
    b4fa:	mov	r0, r6
    b4fc:	str	r5, [r1, #8]
    b4fe:	str	r2, [r3, #4]
    b500:	bl	bab0 <__malloc_unlock>
    b504:	adds	r4, #8
    b506:	mov	r0, r4
    b508:	add	sp, #12
    b50a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b50e:	add	r3, r4
    b510:	mov	r0, r6
    b512:	ldr	r2, [r3, #4]
    b514:	orr.w	r2, r2, #1
    b518:	str	r2, [r3, #4]
    b51a:	bl	bab0 <__malloc_unlock>
    b51e:	adds	r4, #8
    b520:	mov	r0, r4
    b522:	add	sp, #12
    b524:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b528:	ldr	r4, [r7, #8]
    b52a:	ldr	r3, [r4, #4]
    b52c:	bic.w	r8, r3, #3
    b530:	cmp	r8, r5
    b532:	bcc.n	b53e <_malloc_r+0x206>
    b534:	rsb	r3, r5, r8
    b538:	cmp	r3, #15
    b53a:	bgt.w	b656 <_malloc_r+0x31e>
    b53e:	ldr	r3, [pc, #340]	; (b694 <_malloc_r+0x35c>)
    b540:	ldr.w	r9, [pc, #352]	; b6a4 <_malloc_r+0x36c>
    b544:	ldr	r2, [r3, #0]
    b546:	ldr.w	r3, [r9]
    b54a:	adds	r3, #1
    b54c:	add	r2, r5
    b54e:	add.w	sl, r4, r8
    b552:	beq.w	b816 <_malloc_r+0x4de>
    b556:	add.w	r2, r2, #4096	; 0x1000
    b55a:	adds	r2, #15
    b55c:	bic.w	r2, r2, #4080	; 0xff0
    b560:	bic.w	r2, r2, #15
    b564:	mov	r1, r2
    b566:	mov	r0, r6
    b568:	str	r2, [sp, #4]
    b56a:	bl	be94 <_sbrk_r>
    b56e:	cmp.w	r0, #4294967295
    b572:	mov	fp, r0
    b574:	ldr	r2, [sp, #4]
    b576:	beq.w	b82a <_malloc_r+0x4f2>
    b57a:	cmp	sl, r0
    b57c:	bhi.w	b778 <_malloc_r+0x440>
    b580:	ldr	r3, [pc, #276]	; (b698 <_malloc_r+0x360>)
    b582:	ldr	r1, [r3, #0]
    b584:	cmp	sl, fp
    b586:	add	r1, r2
    b588:	str	r1, [r3, #0]
    b58a:	beq.w	b834 <_malloc_r+0x4fc>
    b58e:	ldr.w	r0, [r9]
    b592:	ldr.w	lr, [pc, #272]	; b6a4 <_malloc_r+0x36c>
    b596:	adds	r0, #1
    b598:	ittet	ne
    b59a:	rsbne	sl, sl, fp
    b59e:	addne	r1, sl
    b5a0:	streq.w	fp, [lr]
    b5a4:	strne	r1, [r3, #0]
    b5a6:	ands.w	r1, fp, #7
    b5aa:	beq.w	b7dc <_malloc_r+0x4a4>
    b5ae:	rsb	r0, r1, #8
    b5b2:	rsb	r1, r1, #4096	; 0x1000
    b5b6:	add	fp, r0
    b5b8:	adds	r1, #8
    b5ba:	add	r2, fp
    b5bc:	ubfx	r2, r2, #0, #12
    b5c0:	rsb	r9, r2, r1
    b5c4:	mov	r1, r9
    b5c6:	mov	r0, r6
    b5c8:	str	r3, [sp, #4]
    b5ca:	bl	be94 <_sbrk_r>
    b5ce:	adds	r3, r0, #1
    b5d0:	ldr	r3, [sp, #4]
    b5d2:	beq.w	b854 <_malloc_r+0x51c>
    b5d6:	rsb	r2, fp, r0
    b5da:	add	r2, r9
    b5dc:	orr.w	r2, r2, #1
    b5e0:	ldr	r1, [r3, #0]
    b5e2:	str.w	fp, [r7, #8]
    b5e6:	add	r1, r9
    b5e8:	cmp	r4, r7
    b5ea:	str.w	r2, [fp, #4]
    b5ee:	str	r1, [r3, #0]
    b5f0:	ldr.w	r9, [pc, #164]	; b698 <_malloc_r+0x360>
    b5f4:	beq.n	b624 <_malloc_r+0x2ec>
    b5f6:	cmp.w	r8, #15
    b5fa:	bls.w	b7f8 <_malloc_r+0x4c0>
    b5fe:	ldr	r2, [r4, #4]
    b600:	sub.w	r3, r8, #12
    b604:	bic.w	r3, r3, #7
    b608:	adds	r0, r4, r3
    b60a:	and.w	r2, r2, #1
    b60e:	mov.w	lr, #5
    b612:	orrs	r2, r3
    b614:	cmp	r3, #15
    b616:	str	r2, [r4, #4]
    b618:	str.w	lr, [r0, #4]
    b61c:	str.w	lr, [r0, #8]
    b620:	bhi.w	b85c <_malloc_r+0x524>
    b624:	ldr	r3, [pc, #116]	; (b69c <_malloc_r+0x364>)
    b626:	ldr	r4, [r7, #8]
    b628:	ldr	r2, [r3, #0]
    b62a:	cmp	r1, r2
    b62c:	it	hi
    b62e:	strhi	r1, [r3, #0]
    b630:	ldr	r3, [pc, #108]	; (b6a0 <_malloc_r+0x368>)
    b632:	ldr	r2, [r3, #0]
    b634:	cmp	r1, r2
    b636:	ldr	r2, [r4, #4]
    b638:	it	hi
    b63a:	strhi	r1, [r3, #0]
    b63c:	bic.w	r2, r2, #3
    b640:	cmp	r5, r2
    b642:	sub.w	r3, r2, r5
    b646:	bhi.n	b64c <_malloc_r+0x314>
    b648:	cmp	r3, #15
    b64a:	bgt.n	b656 <_malloc_r+0x31e>
    b64c:	mov	r0, r6
    b64e:	bl	bab0 <__malloc_unlock>
    b652:	movs	r4, #0
    b654:	b.n	b4c8 <_malloc_r+0x190>
    b656:	adds	r2, r4, r5
    b658:	orr.w	r3, r3, #1
    b65c:	orr.w	r5, r5, #1
    b660:	str	r5, [r4, #4]
    b662:	mov	r0, r6
    b664:	str	r2, [r7, #8]
    b666:	str	r3, [r2, #4]
    b668:	bl	bab0 <__malloc_unlock>
    b66c:	adds	r4, #8
    b66e:	mov	r0, r4
    b670:	add	sp, #12
    b672:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b676:	cmp	r3, #20
    b678:	bls.n	b75e <_malloc_r+0x426>
    b67a:	cmp	r3, #84	; 0x54
    b67c:	bhi.w	b7c8 <_malloc_r+0x490>
    b680:	lsrs	r0, r5, #12
    b682:	add.w	lr, r0, #111	; 0x6f
    b686:	mov.w	r3, lr, lsl #1
    b68a:	adds	r0, #110	; 0x6e
    b68c:	b.n	b37c <_malloc_r+0x44>
    b68e:	nop
    b690:	.word	0x1fff1998
    b694:	.word	0x2001a81c
    b698:	.word	0x2001a820
    b69c:	.word	0x2001a818
    b6a0:	.word	0x2001a814
    b6a4:	.word	0x1fff1da4
    b6a8:	lsrs	r2, r3, #9
    b6aa:	cmp	r2, #4
    b6ac:	bls.n	b76c <_malloc_r+0x434>
    b6ae:	cmp	r2, #20
    b6b0:	bhi.w	b81a <_malloc_r+0x4e2>
    b6b4:	add.w	r1, r2, #92	; 0x5c
    b6b8:	lsls	r1, r1, #1
    b6ba:	adds	r2, #91	; 0x5b
    b6bc:	add.w	ip, r7, r1, lsl #2
    b6c0:	ldr.w	r1, [r7, r1, lsl #2]
    b6c4:	ldr.w	r8, [pc, #476]	; b8a4 <_malloc_r+0x56c>
    b6c8:	sub.w	ip, ip, #8
    b6cc:	cmp	ip, r1
    b6ce:	beq.w	b7e2 <_malloc_r+0x4aa>
    b6d2:	ldr	r2, [r1, #4]
    b6d4:	bic.w	r2, r2, #3
    b6d8:	cmp	r3, r2
    b6da:	bcs.n	b6e2 <_malloc_r+0x3aa>
    b6dc:	ldr	r1, [r1, #8]
    b6de:	cmp	ip, r1
    b6e0:	bne.n	b6d2 <_malloc_r+0x39a>
    b6e2:	ldr.w	ip, [r1, #12]
    b6e6:	ldr	r2, [r7, #4]
    b6e8:	str.w	ip, [r4, #12]
    b6ec:	str	r1, [r4, #8]
    b6ee:	str.w	r4, [ip, #8]
    b6f2:	str	r4, [r1, #12]
    b6f4:	b.n	b408 <_malloc_r+0xd0>
    b6f6:	adds	r3, r4, r5
    b6f8:	orr.w	r7, r2, #1
    b6fc:	orr.w	r5, r5, #1
    b700:	str	r5, [r4, #4]
    b702:	mov	r0, r6
    b704:	str	r3, [r1, #20]
    b706:	str	r3, [r1, #16]
    b708:	str.w	lr, [r3, #12]
    b70c:	str.w	lr, [r3, #8]
    b710:	str	r7, [r3, #4]
    b712:	str	r2, [r3, r2]
    b714:	adds	r4, #8
    b716:	bl	bab0 <__malloc_unlock>
    b71a:	b.n	b4c8 <_malloc_r+0x190>
    b71c:	ldr	r2, [r1, #4]
    b71e:	b.n	b408 <_malloc_r+0xd0>
    b720:	add.w	r8, r8, #1
    b724:	tst.w	r8, #3
    b728:	add.w	ip, ip, #8
    b72c:	bne.w	b42e <_malloc_r+0xf6>
    b730:	b.n	b794 <_malloc_r+0x45c>
    b732:	ldr	r4, [r3, #12]
    b734:	cmp	r3, r4
    b736:	it	eq
    b738:	addeq	r0, #2
    b73a:	beq.w	b3a8 <_malloc_r+0x70>
    b73e:	b.n	b4a8 <_malloc_r+0x170>
    b740:	add	r3, r1
    b742:	mov	r4, r1
    b744:	ldr	r2, [r3, #4]
    b746:	ldr	r1, [r1, #12]
    b748:	ldr.w	r5, [r4, #8]!
    b74c:	orr.w	r2, r2, #1
    b750:	str	r2, [r3, #4]
    b752:	mov	r0, r6
    b754:	str	r1, [r5, #12]
    b756:	str	r5, [r1, #8]
    b758:	bl	bab0 <__malloc_unlock>
    b75c:	b.n	b4c8 <_malloc_r+0x190>
    b75e:	add.w	lr, r3, #92	; 0x5c
    b762:	add.w	r0, r3, #91	; 0x5b
    b766:	mov.w	r3, lr, lsl #1
    b76a:	b.n	b37c <_malloc_r+0x44>
    b76c:	lsrs	r2, r3, #6
    b76e:	add.w	r1, r2, #57	; 0x39
    b772:	lsls	r1, r1, #1
    b774:	adds	r2, #56	; 0x38
    b776:	b.n	b6bc <_malloc_r+0x384>
    b778:	cmp	r4, r7
    b77a:	ldr	r3, [pc, #296]	; (b8a4 <_malloc_r+0x56c>)
    b77c:	beq.w	b580 <_malloc_r+0x248>
    b780:	ldr	r4, [r3, #8]
    b782:	ldr	r2, [r4, #4]
    b784:	bic.w	r2, r2, #3
    b788:	b.n	b640 <_malloc_r+0x308>
    b78a:	ldr.w	r3, [r9], #-8
    b78e:	cmp	r9, r3
    b790:	bne.w	b898 <_malloc_r+0x560>
    b794:	tst.w	r0, #3
    b798:	add.w	r0, r0, #4294967295
    b79c:	bne.n	b78a <_malloc_r+0x452>
    b79e:	ldr	r3, [r7, #4]
    b7a0:	bic.w	r3, r3, r4
    b7a4:	str	r3, [r7, #4]
    b7a6:	lsls	r4, r4, #1
    b7a8:	cmp	r4, r3
    b7aa:	bhi.w	b528 <_malloc_r+0x1f0>
    b7ae:	cmp	r4, #0
    b7b0:	beq.w	b528 <_malloc_r+0x1f0>
    b7b4:	tst	r4, r3
    b7b6:	mov	r0, r8
    b7b8:	bne.w	b426 <_malloc_r+0xee>
    b7bc:	lsls	r4, r4, #1
    b7be:	tst	r4, r3
    b7c0:	add.w	r0, r0, #4
    b7c4:	beq.n	b7bc <_malloc_r+0x484>
    b7c6:	b.n	b426 <_malloc_r+0xee>
    b7c8:	cmp.w	r3, #340	; 0x154
    b7cc:	bhi.n	b800 <_malloc_r+0x4c8>
    b7ce:	lsrs	r0, r5, #15
    b7d0:	add.w	lr, r0, #120	; 0x78
    b7d4:	mov.w	r3, lr, lsl #1
    b7d8:	adds	r0, #119	; 0x77
    b7da:	b.n	b37c <_malloc_r+0x44>
    b7dc:	mov.w	r1, #4096	; 0x1000
    b7e0:	b.n	b5ba <_malloc_r+0x282>
    b7e2:	movs	r1, #1
    b7e4:	ldr.w	r3, [r8, #4]
    b7e8:	asrs	r2, r2, #2
    b7ea:	lsl.w	r2, r1, r2
    b7ee:	orrs	r2, r3
    b7f0:	str.w	r2, [r8, #4]
    b7f4:	mov	r1, ip
    b7f6:	b.n	b6e8 <_malloc_r+0x3b0>
    b7f8:	movs	r3, #1
    b7fa:	str.w	r3, [fp, #4]
    b7fe:	b.n	b64c <_malloc_r+0x314>
    b800:	movw	r2, #1364	; 0x554
    b804:	cmp	r3, r2
    b806:	bhi.n	b84a <_malloc_r+0x512>
    b808:	lsrs	r0, r5, #18
    b80a:	add.w	lr, r0, #125	; 0x7d
    b80e:	mov.w	r3, lr, lsl #1
    b812:	adds	r0, #124	; 0x7c
    b814:	b.n	b37c <_malloc_r+0x44>
    b816:	adds	r2, #16
    b818:	b.n	b564 <_malloc_r+0x22c>
    b81a:	cmp	r2, #84	; 0x54
    b81c:	bhi.n	b86c <_malloc_r+0x534>
    b81e:	lsrs	r2, r3, #12
    b820:	add.w	r1, r2, #111	; 0x6f
    b824:	lsls	r1, r1, #1
    b826:	adds	r2, #110	; 0x6e
    b828:	b.n	b6bc <_malloc_r+0x384>
    b82a:	ldr	r4, [r7, #8]
    b82c:	ldr	r2, [r4, #4]
    b82e:	bic.w	r2, r2, #3
    b832:	b.n	b640 <_malloc_r+0x308>
    b834:	ubfx	r0, sl, #0, #12
    b838:	cmp	r0, #0
    b83a:	bne.w	b58e <_malloc_r+0x256>
    b83e:	add	r2, r8
    b840:	ldr	r3, [r7, #8]
    b842:	orr.w	r2, r2, #1
    b846:	str	r2, [r3, #4]
    b848:	b.n	b624 <_malloc_r+0x2ec>
    b84a:	movs	r3, #254	; 0xfe
    b84c:	mov.w	lr, #127	; 0x7f
    b850:	movs	r0, #126	; 0x7e
    b852:	b.n	b37c <_malloc_r+0x44>
    b854:	movs	r2, #1
    b856:	mov.w	r9, #0
    b85a:	b.n	b5e0 <_malloc_r+0x2a8>
    b85c:	add.w	r1, r4, #8
    b860:	mov	r0, r6
    b862:	bl	10890 <_free_r>
    b866:	ldr.w	r1, [r9]
    b86a:	b.n	b624 <_malloc_r+0x2ec>
    b86c:	cmp.w	r2, #340	; 0x154
    b870:	bhi.n	b87e <_malloc_r+0x546>
    b872:	lsrs	r2, r3, #15
    b874:	add.w	r1, r2, #120	; 0x78
    b878:	lsls	r1, r1, #1
    b87a:	adds	r2, #119	; 0x77
    b87c:	b.n	b6bc <_malloc_r+0x384>
    b87e:	movw	r1, #1364	; 0x554
    b882:	cmp	r2, r1
    b884:	bhi.n	b892 <_malloc_r+0x55a>
    b886:	lsrs	r2, r3, #18
    b888:	add.w	r1, r2, #125	; 0x7d
    b88c:	lsls	r1, r1, #1
    b88e:	adds	r2, #124	; 0x7c
    b890:	b.n	b6bc <_malloc_r+0x384>
    b892:	movs	r1, #254	; 0xfe
    b894:	movs	r2, #126	; 0x7e
    b896:	b.n	b6bc <_malloc_r+0x384>
    b898:	ldr	r3, [r7, #4]
    b89a:	b.n	b7a6 <_malloc_r+0x46e>
    b89c:	lsrs	r0, r5, #3
    b89e:	adds	r3, r0, #1
    b8a0:	lsls	r3, r3, #1
    b8a2:	b.n	b496 <_malloc_r+0x15e>
    b8a4:	.word	0x1fff1998

0000b8a8 <__ascii_mbtowc>:
    b8a8:	sub	sp, #8
    b8aa:	cbz	r1, b8c0 <__ascii_mbtowc+0x18>
    b8ac:	cbz	r2, b8c6 <__ascii_mbtowc+0x1e>
    b8ae:	cbz	r3, b8cc <__ascii_mbtowc+0x24>
    b8b0:	ldrb	r3, [r2, #0]
    b8b2:	str	r3, [r1, #0]
    b8b4:	ldrb	r2, [r2, #0]
    b8b6:	adds	r0, r2, #0
    b8b8:	it	ne
    b8ba:	movne	r0, #1
    b8bc:	add	sp, #8
    b8be:	bx	lr
    b8c0:	add	r1, sp, #4
    b8c2:	cmp	r2, #0
    b8c4:	bne.n	b8ae <__ascii_mbtowc+0x6>
    b8c6:	mov	r0, r2
    b8c8:	add	sp, #8
    b8ca:	bx	lr
    b8cc:	mvn.w	r0, #1
    b8d0:	b.n	b8bc <__ascii_mbtowc+0x14>
    b8d2:	nop
    b8d4:			; <UNDEFINED> instruction: 0xffffffff
    b8d8:			; <UNDEFINED> instruction: 0xffffffff
    b8dc:			; <UNDEFINED> instruction: 0xffffffff

0000b8e0 <memchr>:
    b8e0:	and.w	r1, r1, #255	; 0xff
    b8e4:	cmp	r2, #16
    b8e6:	blt.n	b940 <memchr+0x60>
    b8e8:	tst.w	r0, #7
    b8ec:	beq.n	b900 <memchr+0x20>
    b8ee:	ldrb.w	r3, [r0], #1
    b8f2:	subs	r2, #1
    b8f4:	cmp	r3, r1
    b8f6:	beq.n	b954 <memchr+0x74>
    b8f8:	tst.w	r0, #7
    b8fc:	cbz	r2, b950 <memchr+0x70>
    b8fe:	bne.n	b8ee <memchr+0xe>
    b900:	push	{r4, r5, r6, r7}
    b902:	orr.w	r1, r1, r1, lsl #8
    b906:	orr.w	r1, r1, r1, lsl #16
    b90a:	bic.w	r4, r2, #7
    b90e:	mvns.w	r7, #0
    b912:	movs	r3, #0
    b914:	ldrd	r5, r6, [r0], #8
    b918:	subs	r4, #8
    b91a:	eor.w	r5, r5, r1
    b91e:	eor.w	r6, r6, r1
    b922:	uadd8	r5, r5, r7
    b926:	sel	r5, r3, r7
    b92a:	uadd8	r6, r6, r7
    b92e:	sel	r6, r5, r7
    b932:	cbnz	r6, b958 <memchr+0x78>
    b934:	bne.n	b914 <memchr+0x34>
    b936:	pop	{r4, r5, r6, r7}
    b938:	and.w	r1, r1, #255	; 0xff
    b93c:	and.w	r2, r2, #7
    b940:	cbz	r2, b950 <memchr+0x70>
    b942:	ldrb.w	r3, [r0], #1
    b946:	subs	r2, #1
    b948:	eor.w	r3, r3, r1
    b94c:	cbz	r3, b954 <memchr+0x74>
    b94e:	bne.n	b942 <memchr+0x62>
    b950:	movs	r0, #0
    b952:	bx	lr
    b954:	subs	r0, #1
    b956:	bx	lr
    b958:	cmp	r5, #0
    b95a:	itte	eq
    b95c:	moveq	r5, r6
    b95e:	subeq	r0, #3
    b960:	subne	r0, #7
    b962:	tst.w	r5, #1
    b966:	bne.n	b978 <memchr+0x98>
    b968:	adds	r0, #1
    b96a:	tst.w	r5, #256	; 0x100
    b96e:	ittt	eq
    b970:	addeq	r0, #1
    b972:	tsteq.w	r5, #98304	; 0x18000
    b976:	addeq	r0, #1
    b978:	pop	{r4, r5, r6, r7}
    b97a:	subs	r0, #1
    b97c:	bx	lr
    b97e:	nop

0000b980 <memcmp>:
    b980:	cmp	r2, #3
    b982:	push	{r4, r5, r6}
    b984:	bls.n	b9d4 <memcmp+0x54>
    b986:	orr.w	r3, r0, r1
    b98a:	lsls	r3, r3, #30
    b98c:	beq.n	b9b2 <memcmp+0x32>
    b98e:	ldrb	r4, [r0, #0]
    b990:	ldrb	r5, [r1, #0]
    b992:	cmp	r4, r5
    b994:	bne.n	b9dc <memcmp+0x5c>
    b996:	add	r2, r0
    b998:	adds	r3, r0, #1
    b99a:	b.n	b9a8 <memcmp+0x28>
    b99c:	ldrb.w	r4, [r3], #1
    b9a0:	ldrb.w	r5, [r1, #1]!
    b9a4:	cmp	r4, r5
    b9a6:	bne.n	b9dc <memcmp+0x5c>
    b9a8:	cmp	r3, r2
    b9aa:	bne.n	b99c <memcmp+0x1c>
    b9ac:	movs	r0, #0
    b9ae:	pop	{r4, r5, r6}
    b9b0:	bx	lr
    b9b2:	mov	r4, r1
    b9b4:	mov	r3, r0
    b9b6:	ldr	r6, [r3, #0]
    b9b8:	ldr	r5, [r4, #0]
    b9ba:	cmp	r6, r5
    b9bc:	mov	r0, r3
    b9be:	mov	r1, r4
    b9c0:	add.w	r3, r3, #4
    b9c4:	add.w	r4, r4, #4
    b9c8:	bne.n	b98e <memcmp+0xe>
    b9ca:	subs	r2, #4
    b9cc:	cmp	r2, #3
    b9ce:	mov	r0, r3
    b9d0:	mov	r1, r4
    b9d2:	bhi.n	b9b6 <memcmp+0x36>
    b9d4:	cmp	r2, #0
    b9d6:	bne.n	b98e <memcmp+0xe>
    b9d8:	mov	r0, r2
    b9da:	b.n	b9ae <memcmp+0x2e>
    b9dc:	subs	r0, r4, r5
    b9de:	pop	{r4, r5, r6}
    b9e0:	bx	lr
    b9e2:	nop

0000b9e4 <memmove>:
    b9e4:	cmp	r0, r1
    b9e6:	push	{r4, r5, r6, r7, lr}
    b9e8:	bls.n	ba06 <memmove+0x22>
    b9ea:	adds	r3, r1, r2
    b9ec:	cmp	r0, r3
    b9ee:	bcs.n	ba06 <memmove+0x22>
    b9f0:	adds	r1, r0, r2
    b9f2:	cmp	r2, #0
    b9f4:	beq.n	ba9a <memmove+0xb6>
    b9f6:	subs	r2, r3, r2
    b9f8:	ldrb.w	r4, [r3, #-1]!
    b9fc:	strb.w	r4, [r1, #-1]!
    ba00:	cmp	r3, r2
    ba02:	bne.n	b9f8 <memmove+0x14>
    ba04:	pop	{r4, r5, r6, r7, pc}
    ba06:	cmp	r2, #15
    ba08:	bls.n	ba9c <memmove+0xb8>
    ba0a:	orr.w	r3, r1, r0
    ba0e:	lsls	r3, r3, #30
    ba10:	bne.n	baa0 <memmove+0xbc>
    ba12:	add.w	r4, r0, #16
    ba16:	add.w	r3, r1, #16
    ba1a:	mov	r5, r2
    ba1c:	ldr.w	r6, [r3, #-16]
    ba20:	str.w	r6, [r4, #-16]
    ba24:	ldr.w	r6, [r3, #-12]
    ba28:	str.w	r6, [r4, #-12]
    ba2c:	ldr.w	r6, [r3, #-8]
    ba30:	str.w	r6, [r4, #-8]
    ba34:	subs	r5, #16
    ba36:	ldr.w	r6, [r3, #-4]
    ba3a:	str.w	r6, [r4, #-4]
    ba3e:	cmp	r5, #15
    ba40:	add.w	r3, r3, #16
    ba44:	add.w	r4, r4, #16
    ba48:	bhi.n	ba1c <memmove+0x38>
    ba4a:	sub.w	r3, r2, #16
    ba4e:	bic.w	r3, r3, #15
    ba52:	and.w	lr, r2, #15
    ba56:	adds	r3, #16
    ba58:	cmp.w	lr, #3
    ba5c:	add	r1, r3
    ba5e:	add	r3, r0
    ba60:	bls.n	baa6 <memmove+0xc2>
    ba62:	subs	r6, r3, #4
    ba64:	mov	r5, r1
    ba66:	mov	r4, lr
    ba68:	subs	r4, #4
    ba6a:	ldr.w	r7, [r5], #4
    ba6e:	str.w	r7, [r6, #4]!
    ba72:	cmp	r4, #3
    ba74:	bhi.n	ba68 <memmove+0x84>
    ba76:	sub.w	r4, lr, #4
    ba7a:	bic.w	r4, r4, #3
    ba7e:	adds	r4, #4
    ba80:	add	r3, r4
    ba82:	add	r1, r4
    ba84:	and.w	r2, r2, #3
    ba88:	cbz	r2, baa4 <memmove+0xc0>
    ba8a:	subs	r3, #1
    ba8c:	add	r2, r1
    ba8e:	ldrb.w	r4, [r1], #1
    ba92:	strb.w	r4, [r3, #1]!
    ba96:	cmp	r2, r1
    ba98:	bne.n	ba8e <memmove+0xaa>
    ba9a:	pop	{r4, r5, r6, r7, pc}
    ba9c:	mov	r3, r0
    ba9e:	b.n	ba88 <memmove+0xa4>
    baa0:	mov	r3, r0
    baa2:	b.n	ba8a <memmove+0xa6>
    baa4:	pop	{r4, r5, r6, r7, pc}
    baa6:	mov	r2, lr
    baa8:	b.n	ba88 <memmove+0xa4>
    baaa:	nop

0000baac <__malloc_lock>:
    baac:	bx	lr
    baae:	nop

0000bab0 <__malloc_unlock>:
    bab0:	bx	lr
    bab2:	nop

0000bab4 <_realloc_r>:
    bab4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bab8:	mov	r7, r2
    baba:	sub	sp, #12
    babc:	cmp	r1, #0
    babe:	beq.w	bc44 <_realloc_r+0x190>
    bac2:	mov	r6, r1
    bac4:	mov	r9, r0
    bac6:	add.w	r5, r7, #11
    baca:	bl	baac <__malloc_lock>
    bace:	ldr.w	lr, [r6, #-4]
    bad2:	cmp	r5, #22
    bad4:	bic.w	r4, lr, #3
    bad8:	sub.w	r8, r6, #8
    badc:	bhi.n	bb60 <_realloc_r+0xac>
    bade:	movs	r2, #16
    bae0:	mov	r5, r2
    bae2:	cmp	r7, r5
    bae4:	bhi.n	bb6a <_realloc_r+0xb6>
    bae6:	cmp	r4, r2
    bae8:	bge.n	bbd6 <_realloc_r+0x122>
    baea:	ldr	r3, [pc, #804]	; (be10 <_realloc_r+0x35c>)
    baec:	ldr	r1, [r3, #8]
    baee:	add.w	r0, r8, r4
    baf2:	cmp	r0, r1
    baf4:	ldr	r1, [r0, #4]
    baf6:	beq.w	bcac <_realloc_r+0x1f8>
    bafa:	bic.w	r3, r1, #1
    bafe:	add	r3, r0
    bb00:	ldr	r3, [r3, #4]
    bb02:	lsls	r3, r3, #31
    bb04:	bpl.n	bc02 <_realloc_r+0x14e>
    bb06:	tst.w	lr, #1
    bb0a:	beq.n	bb78 <_realloc_r+0xc4>
    bb0c:	mov	r1, r7
    bb0e:	mov	r0, r9
    bb10:	bl	b338 <_malloc_r>
    bb14:	mov	r7, r0
    bb16:	cbz	r0, bb52 <_realloc_r+0x9e>
    bb18:	ldr.w	r3, [r6, #-4]
    bb1c:	bic.w	r3, r3, #1
    bb20:	add	r3, r8
    bb22:	sub.w	r2, r0, #8
    bb26:	cmp	r2, r3
    bb28:	beq.w	bdb4 <_realloc_r+0x300>
    bb2c:	subs	r2, r4, #4
    bb2e:	cmp	r2, #36	; 0x24
    bb30:	bhi.w	bd96 <_realloc_r+0x2e2>
    bb34:	cmp	r2, #19
    bb36:	bhi.w	bd42 <_realloc_r+0x28e>
    bb3a:	mov	r3, r0
    bb3c:	mov	r2, r6
    bb3e:	ldr	r1, [r2, #0]
    bb40:	str	r1, [r3, #0]
    bb42:	ldr	r1, [r2, #4]
    bb44:	str	r1, [r3, #4]
    bb46:	ldr	r2, [r2, #8]
    bb48:	str	r2, [r3, #8]
    bb4a:	mov	r1, r6
    bb4c:	mov	r0, r9
    bb4e:	bl	10890 <_free_r>
    bb52:	mov	r0, r9
    bb54:	bl	bab0 <__malloc_unlock>
    bb58:	mov	r0, r7
    bb5a:	add	sp, #12
    bb5c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bb60:	bic.w	r5, r5, #7
    bb64:	cmp	r5, #0
    bb66:	mov	r2, r5
    bb68:	bge.n	bae2 <_realloc_r+0x2e>
    bb6a:	movs	r3, #12
    bb6c:	movs	r0, #0
    bb6e:	str.w	r3, [r9]
    bb72:	add	sp, #12
    bb74:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bb78:	ldr.w	r3, [r6, #-8]
    bb7c:	rsb	sl, r3, r8
    bb80:	ldr.w	r3, [sl, #4]
    bb84:	bic.w	ip, r3, #3
    bb88:	add.w	r3, r4, ip
    bb8c:	cmp	r3, r2
    bb8e:	blt.n	bb0c <_realloc_r+0x58>
    bb90:	mov	r7, sl
    bb92:	ldr.w	r1, [sl, #12]
    bb96:	ldr.w	r0, [r7, #8]!
    bb9a:	subs	r2, r4, #4
    bb9c:	cmp	r2, #36	; 0x24
    bb9e:	str	r1, [r0, #12]
    bba0:	str	r0, [r1, #8]
    bba2:	bhi.w	bdd4 <_realloc_r+0x320>
    bba6:	cmp	r2, #19
    bba8:	bls.w	bdd0 <_realloc_r+0x31c>
    bbac:	ldr	r1, [r6, #0]
    bbae:	str.w	r1, [sl, #8]
    bbb2:	ldr	r1, [r6, #4]
    bbb4:	str.w	r1, [sl, #12]
    bbb8:	cmp	r2, #27
    bbba:	bhi.w	be14 <_realloc_r+0x360>
    bbbe:	adds	r6, #8
    bbc0:	add.w	r2, sl, #16
    bbc4:	ldr	r1, [r6, #0]
    bbc6:	str	r1, [r2, #0]
    bbc8:	ldr	r1, [r6, #4]
    bbca:	str	r1, [r2, #4]
    bbcc:	ldr	r1, [r6, #8]
    bbce:	str	r1, [r2, #8]
    bbd0:	mov	r6, r7
    bbd2:	mov	r4, r3
    bbd4:	mov	r8, sl
    bbd6:	subs	r3, r4, r5
    bbd8:	cmp	r3, #15
    bbda:	bhi.n	bc18 <_realloc_r+0x164>
    bbdc:	ldr.w	r3, [r8, #4]
    bbe0:	and.w	r3, r3, #1
    bbe4:	orrs	r3, r4
    bbe6:	add	r4, r8
    bbe8:	str.w	r3, [r8, #4]
    bbec:	ldr	r3, [r4, #4]
    bbee:	orr.w	r3, r3, #1
    bbf2:	str	r3, [r4, #4]
    bbf4:	mov	r0, r9
    bbf6:	bl	bab0 <__malloc_unlock>
    bbfa:	mov	r0, r6
    bbfc:	add	sp, #12
    bbfe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bc02:	bic.w	r1, r1, #3
    bc06:	add	r1, r4
    bc08:	cmp	r1, r2
    bc0a:	blt.n	bc50 <_realloc_r+0x19c>
    bc0c:	ldr	r3, [r0, #12]
    bc0e:	ldr	r2, [r0, #8]
    bc10:	mov	r4, r1
    bc12:	str	r3, [r2, #12]
    bc14:	str	r2, [r3, #8]
    bc16:	b.n	bbd6 <_realloc_r+0x122>
    bc18:	ldr.w	r2, [r8, #4]
    bc1c:	add.w	r1, r8, r5
    bc20:	and.w	r2, r2, #1
    bc24:	orrs	r5, r2
    bc26:	orr.w	r2, r3, #1
    bc2a:	add	r3, r1
    bc2c:	str.w	r5, [r8, #4]
    bc30:	str	r2, [r1, #4]
    bc32:	ldr	r2, [r3, #4]
    bc34:	orr.w	r2, r2, #1
    bc38:	adds	r1, #8
    bc3a:	str	r2, [r3, #4]
    bc3c:	mov	r0, r9
    bc3e:	bl	10890 <_free_r>
    bc42:	b.n	bbf4 <_realloc_r+0x140>
    bc44:	mov	r1, r2
    bc46:	add	sp, #12
    bc48:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bc4c:	b.w	b338 <_malloc_r>
    bc50:	tst.w	lr, #1
    bc54:	bne.w	bb0c <_realloc_r+0x58>
    bc58:	ldr.w	r3, [r6, #-8]
    bc5c:	rsb	sl, r3, r8
    bc60:	ldr.w	r3, [sl, #4]
    bc64:	bic.w	ip, r3, #3
    bc68:	add.w	lr, r1, ip
    bc6c:	cmp	lr, r2
    bc6e:	blt.n	bb88 <_realloc_r+0xd4>
    bc70:	ldr	r3, [r0, #12]
    bc72:	ldr	r2, [r0, #8]
    bc74:	mov	r7, sl
    bc76:	str	r3, [r2, #12]
    bc78:	str	r2, [r3, #8]
    bc7a:	ldr.w	r1, [r7, #8]!
    bc7e:	ldr.w	r3, [sl, #12]
    bc82:	str	r3, [r1, #12]
    bc84:	subs	r2, r4, #4
    bc86:	cmp	r2, #36	; 0x24
    bc88:	str	r1, [r3, #8]
    bc8a:	bhi.w	bdc0 <_realloc_r+0x30c>
    bc8e:	cmp	r2, #19
    bc90:	bls.n	bd58 <_realloc_r+0x2a4>
    bc92:	ldr	r3, [r6, #0]
    bc94:	str.w	r3, [sl, #8]
    bc98:	ldr	r3, [r6, #4]
    bc9a:	str.w	r3, [sl, #12]
    bc9e:	cmp	r2, #27
    bca0:	bhi.w	bde4 <_realloc_r+0x330>
    bca4:	adds	r6, #8
    bca6:	add.w	r3, sl, #16
    bcaa:	b.n	bd5a <_realloc_r+0x2a6>
    bcac:	bic.w	fp, r1, #3
    bcb0:	add	fp, r4
    bcb2:	add.w	r0, r5, #16
    bcb6:	cmp	fp, r0
    bcb8:	bge.n	bd6e <_realloc_r+0x2ba>
    bcba:	tst.w	lr, #1
    bcbe:	bne.w	bb0c <_realloc_r+0x58>
    bcc2:	ldr.w	r1, [r6, #-8]
    bcc6:	rsb	sl, r1, r8
    bcca:	ldr.w	r1, [sl, #4]
    bcce:	bic.w	ip, r1, #3
    bcd2:	add	fp, ip
    bcd4:	cmp	r0, fp
    bcd6:	bgt.w	bb88 <_realloc_r+0xd4>
    bcda:	mov	r7, sl
    bcdc:	ldr.w	r1, [sl, #12]
    bce0:	ldr.w	r0, [r7, #8]!
    bce4:	subs	r2, r4, #4
    bce6:	cmp	r2, #36	; 0x24
    bce8:	str	r1, [r0, #12]
    bcea:	str	r0, [r1, #8]
    bcec:	bhi.w	be58 <_realloc_r+0x3a4>
    bcf0:	cmp	r2, #19
    bcf2:	bls.w	be40 <_realloc_r+0x38c>
    bcf6:	ldr	r1, [r6, #0]
    bcf8:	str.w	r1, [sl, #8]
    bcfc:	ldr	r1, [r6, #4]
    bcfe:	str.w	r1, [sl, #12]
    bd02:	cmp	r2, #27
    bd04:	bhi.w	be66 <_realloc_r+0x3b2>
    bd08:	adds	r6, #8
    bd0a:	add.w	r2, sl, #16
    bd0e:	ldr	r1, [r6, #0]
    bd10:	str	r1, [r2, #0]
    bd12:	ldr	r1, [r6, #4]
    bd14:	str	r1, [r2, #4]
    bd16:	ldr	r1, [r6, #8]
    bd18:	str	r1, [r2, #8]
    bd1a:	add.w	r1, sl, r5
    bd1e:	rsb	r2, r5, fp
    bd22:	orr.w	r2, r2, #1
    bd26:	str	r1, [r3, #8]
    bd28:	str	r2, [r1, #4]
    bd2a:	ldr.w	r3, [sl, #4]
    bd2e:	and.w	r3, r3, #1
    bd32:	orrs	r5, r3
    bd34:	mov	r0, r9
    bd36:	str.w	r5, [sl, #4]
    bd3a:	bl	bab0 <__malloc_unlock>
    bd3e:	mov	r0, r7
    bd40:	b.n	bbfc <_realloc_r+0x148>
    bd42:	ldr	r3, [r6, #0]
    bd44:	str	r3, [r0, #0]
    bd46:	ldr	r3, [r6, #4]
    bd48:	str	r3, [r0, #4]
    bd4a:	cmp	r2, #27
    bd4c:	bhi.n	bd9e <_realloc_r+0x2ea>
    bd4e:	add.w	r3, r0, #8
    bd52:	add.w	r2, r6, #8
    bd56:	b.n	bb3e <_realloc_r+0x8a>
    bd58:	mov	r3, r7
    bd5a:	ldr	r2, [r6, #0]
    bd5c:	str	r2, [r3, #0]
    bd5e:	ldr	r2, [r6, #4]
    bd60:	str	r2, [r3, #4]
    bd62:	ldr	r2, [r6, #8]
    bd64:	str	r2, [r3, #8]
    bd66:	mov	r6, r7
    bd68:	mov	r4, lr
    bd6a:	mov	r8, sl
    bd6c:	b.n	bbd6 <_realloc_r+0x122>
    bd6e:	add.w	r1, r8, r5
    bd72:	rsb	fp, r5, fp
    bd76:	orr.w	r2, fp, #1
    bd7a:	str	r1, [r3, #8]
    bd7c:	str	r2, [r1, #4]
    bd7e:	ldr.w	r3, [r6, #-4]
    bd82:	and.w	r3, r3, #1
    bd86:	orrs	r5, r3
    bd88:	mov	r0, r9
    bd8a:	str.w	r5, [r6, #-4]
    bd8e:	bl	bab0 <__malloc_unlock>
    bd92:	mov	r0, r6
    bd94:	b.n	bbfc <_realloc_r+0x148>
    bd96:	mov	r1, r6
    bd98:	bl	b9e4 <memmove>
    bd9c:	b.n	bb4a <_realloc_r+0x96>
    bd9e:	ldr	r3, [r6, #8]
    bda0:	str	r3, [r0, #8]
    bda2:	ldr	r3, [r6, #12]
    bda4:	str	r3, [r0, #12]
    bda6:	cmp	r2, #36	; 0x24
    bda8:	beq.n	bdfc <_realloc_r+0x348>
    bdaa:	add.w	r3, r0, #16
    bdae:	add.w	r2, r6, #16
    bdb2:	b.n	bb3e <_realloc_r+0x8a>
    bdb4:	ldr.w	r3, [r0, #-4]
    bdb8:	bic.w	r3, r3, #3
    bdbc:	add	r4, r3
    bdbe:	b.n	bbd6 <_realloc_r+0x122>
    bdc0:	mov	r1, r6
    bdc2:	mov	r0, r7
    bdc4:	mov	r4, lr
    bdc6:	mov	r8, sl
    bdc8:	bl	b9e4 <memmove>
    bdcc:	mov	r6, r7
    bdce:	b.n	bbd6 <_realloc_r+0x122>
    bdd0:	mov	r2, r7
    bdd2:	b.n	bbc4 <_realloc_r+0x110>
    bdd4:	mov	r1, r6
    bdd6:	mov	r0, r7
    bdd8:	mov	r4, r3
    bdda:	mov	r8, sl
    bddc:	bl	b9e4 <memmove>
    bde0:	mov	r6, r7
    bde2:	b.n	bbd6 <_realloc_r+0x122>
    bde4:	ldr	r3, [r6, #8]
    bde6:	str.w	r3, [sl, #16]
    bdea:	ldr	r3, [r6, #12]
    bdec:	str.w	r3, [sl, #20]
    bdf0:	cmp	r2, #36	; 0x24
    bdf2:	beq.n	be2c <_realloc_r+0x378>
    bdf4:	adds	r6, #16
    bdf6:	add.w	r3, sl, #24
    bdfa:	b.n	bd5a <_realloc_r+0x2a6>
    bdfc:	ldr	r3, [r6, #16]
    bdfe:	str	r3, [r0, #16]
    be00:	ldr	r3, [r6, #20]
    be02:	str	r3, [r0, #20]
    be04:	add.w	r2, r6, #24
    be08:	add.w	r3, r0, #24
    be0c:	b.n	bb3e <_realloc_r+0x8a>
    be0e:	nop
    be10:	.word	0x1fff1998
    be14:	ldr	r1, [r6, #8]
    be16:	str.w	r1, [sl, #16]
    be1a:	ldr	r1, [r6, #12]
    be1c:	str.w	r1, [sl, #20]
    be20:	cmp	r2, #36	; 0x24
    be22:	beq.n	be44 <_realloc_r+0x390>
    be24:	adds	r6, #16
    be26:	add.w	r2, sl, #24
    be2a:	b.n	bbc4 <_realloc_r+0x110>
    be2c:	ldr	r3, [r6, #16]
    be2e:	str.w	r3, [sl, #24]
    be32:	ldr	r3, [r6, #20]
    be34:	str.w	r3, [sl, #28]
    be38:	adds	r6, #24
    be3a:	add.w	r3, sl, #32
    be3e:	b.n	bd5a <_realloc_r+0x2a6>
    be40:	mov	r2, r7
    be42:	b.n	bd0e <_realloc_r+0x25a>
    be44:	ldr	r2, [r6, #16]
    be46:	str.w	r2, [sl, #24]
    be4a:	ldr	r2, [r6, #20]
    be4c:	str.w	r2, [sl, #28]
    be50:	adds	r6, #24
    be52:	add.w	r2, sl, #32
    be56:	b.n	bbc4 <_realloc_r+0x110>
    be58:	mov	r1, r6
    be5a:	mov	r0, r7
    be5c:	str	r3, [sp, #4]
    be5e:	bl	b9e4 <memmove>
    be62:	ldr	r3, [sp, #4]
    be64:	b.n	bd1a <_realloc_r+0x266>
    be66:	ldr	r1, [r6, #8]
    be68:	str.w	r1, [sl, #16]
    be6c:	ldr	r1, [r6, #12]
    be6e:	str.w	r1, [sl, #20]
    be72:	cmp	r2, #36	; 0x24
    be74:	beq.n	be7e <_realloc_r+0x3ca>
    be76:	adds	r6, #16
    be78:	add.w	r2, sl, #24
    be7c:	b.n	bd0e <_realloc_r+0x25a>
    be7e:	ldr	r2, [r6, #16]
    be80:	str.w	r2, [sl, #24]
    be84:	ldr	r2, [r6, #20]
    be86:	str.w	r2, [sl, #28]
    be8a:	adds	r6, #24
    be8c:	add.w	r2, sl, #32
    be90:	b.n	bd0e <_realloc_r+0x25a>
    be92:	nop

0000be94 <_sbrk_r>:
    be94:	push	{r3, r4, r5, lr}
    be96:	ldr	r4, [pc, #28]	; (beb4 <_sbrk_r+0x20>)
    be98:	movs	r3, #0
    be9a:	mov	r5, r0
    be9c:	mov	r0, r1
    be9e:	str	r3, [r4, #0]
    bea0:	bl	9400 <_sbrk>
    bea4:	adds	r3, r0, #1
    bea6:	beq.n	beaa <_sbrk_r+0x16>
    bea8:	pop	{r3, r4, r5, pc}
    beaa:	ldr	r3, [r4, #0]
    beac:	cmp	r3, #0
    beae:	beq.n	bea8 <_sbrk_r+0x14>
    beb0:	str	r3, [r5, #0]
    beb2:	pop	{r3, r4, r5, pc}
    beb4:	.word	0x2001a85c

0000beb8 <sprintf>:
    beb8:	push	{r1, r2, r3}
    beba:	push	{r4, r5, r6, r7, lr}
    bebc:	sub	sp, #112	; 0x70
    bebe:	add	r3, sp, #132	; 0x84
    bec0:	ldr	r1, [pc, #60]	; (bf00 <sprintf+0x48>)
    bec2:	ldr.w	r2, [r3], #4
    bec6:	str	r3, [sp, #4]
    bec8:	mov	r5, r0
    beca:	mvn.w	r4, #2147483648	; 0x80000000
    bece:	ldr	r0, [r1, #0]
    bed0:	str	r5, [sp, #8]
    bed2:	mov.w	r7, #520	; 0x208
    bed6:	movw	r6, #65535	; 0xffff
    beda:	add	r1, sp, #8
    bedc:	str	r5, [sp, #24]
    bede:	strh.w	r7, [sp, #20]
    bee2:	str	r4, [sp, #16]
    bee4:	str	r4, [sp, #28]
    bee6:	strh.w	r6, [sp, #22]
    beea:	bl	d190 <_svfprintf_r>
    beee:	ldr	r3, [sp, #8]
    bef0:	movs	r2, #0
    bef2:	strb	r2, [r3, #0]
    bef4:	add	sp, #112	; 0x70
    bef6:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    befa:	add	sp, #12
    befc:	bx	lr
    befe:	nop
    bf00:	.word	0x1fff1828

0000bf04 <sscanf>:
    bf04:	push	{r1, r2, r3}
    bf06:	push	{r4, r5, r6, r7, lr}
    bf08:	sub	sp, #112	; 0x70
    bf0a:	add	r4, sp, #132	; 0x84
    bf0c:	mov.w	r2, #516	; 0x204
    bf10:	ldr.w	r6, [r4], #4
    bf14:	strh.w	r2, [sp, #20]
    bf18:	str	r0, [sp, #8]
    bf1a:	str	r0, [sp, #24]
    bf1c:	bl	bf80 <strlen>
    bf20:	ldr	r3, [pc, #48]	; (bf54 <sscanf+0x50>)
    bf22:	str	r4, [sp, #4]
    bf24:	mov	r5, r0
    bf26:	mov	r2, r6
    bf28:	ldr	r7, [pc, #44]	; (bf58 <sscanf+0x54>)
    bf2a:	ldr	r0, [r3, #0]
    bf2c:	str	r5, [sp, #12]
    bf2e:	mov	r3, r4
    bf30:	movw	r6, #65535	; 0xffff
    bf34:	movs	r4, #0
    bf36:	add	r1, sp, #8
    bf38:	str	r5, [sp, #28]
    bf3a:	str	r7, [sp, #40]	; 0x28
    bf3c:	str	r4, [sp, #56]	; 0x38
    bf3e:	str	r4, [sp, #76]	; 0x4c
    bf40:	strh.w	r6, [sp, #22]
    bf44:	bl	e874 <__ssvfscanf_r>
    bf48:	add	sp, #112	; 0x70
    bf4a:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    bf4e:	add	sp, #12
    bf50:	bx	lr
    bf52:	nop
    bf54:	.word	0x1fff1828
    bf58:	.word	0x0000bf5d

0000bf5c <__seofread>:
    bf5c:	movs	r0, #0
    bf5e:	bx	lr
    bf60:			; <UNDEFINED> instruction: 0xffffffff
    bf64:			; <UNDEFINED> instruction: 0xffffffff
    bf68:			; <UNDEFINED> instruction: 0xffffffff
    bf6c:			; <UNDEFINED> instruction: 0xffffffff
    bf70:			; <UNDEFINED> instruction: 0xffffffff
    bf74:			; <UNDEFINED> instruction: 0xffffffff
    bf78:			; <UNDEFINED> instruction: 0xffffffff
    bf7c:			; <UNDEFINED> instruction: 0xffffffff

0000bf80 <strlen>:
    bf80:	pld	[r0]
    bf84:	strd	r4, r5, [sp, #-8]!
    bf88:	bic.w	r1, r0, #7
    bf8c:	mvn.w	ip, #0
    bf90:	ands.w	r4, r0, #7
    bf94:	pld	[r1, #32]
    bf98:	bne.w	c02e <strlen+0xae>
    bf9c:	mov.w	r4, #0
    bfa0:	mvn.w	r0, #7
    bfa4:	ldrd	r2, r3, [r1]
    bfa8:	pld	[r1, #64]	; 0x40
    bfac:	add.w	r0, r0, #8
    bfb0:	uadd8	r2, r2, ip
    bfb4:	sel	r2, r4, ip
    bfb8:	uadd8	r3, r3, ip
    bfbc:	sel	r3, r2, ip
    bfc0:	cbnz	r3, c016 <strlen+0x96>
    bfc2:	ldrd	r2, r3, [r1, #8]
    bfc6:	uadd8	r2, r2, ip
    bfca:	add.w	r0, r0, #8
    bfce:	sel	r2, r4, ip
    bfd2:	uadd8	r3, r3, ip
    bfd6:	sel	r3, r2, ip
    bfda:	cbnz	r3, c016 <strlen+0x96>
    bfdc:	ldrd	r2, r3, [r1, #16]
    bfe0:	uadd8	r2, r2, ip
    bfe4:	add.w	r0, r0, #8
    bfe8:	sel	r2, r4, ip
    bfec:	uadd8	r3, r3, ip
    bff0:	sel	r3, r2, ip
    bff4:	cbnz	r3, c016 <strlen+0x96>
    bff6:	ldrd	r2, r3, [r1, #24]
    bffa:	add.w	r1, r1, #32
    bffe:	uadd8	r2, r2, ip
    c002:	add.w	r0, r0, #8
    c006:	sel	r2, r4, ip
    c00a:	uadd8	r3, r3, ip
    c00e:	sel	r3, r2, ip
    c012:	cmp	r3, #0
    c014:	beq.n	bfa4 <strlen+0x24>
    c016:	cmp	r2, #0
    c018:	itt	eq
    c01a:	addeq	r0, #4
    c01c:	moveq	r2, r3
    c01e:	rev	r2, r2
    c020:	clz	r2, r2
    c024:	ldrd	r4, r5, [sp], #8
    c028:	add.w	r0, r0, r2, lsr #3
    c02c:	bx	lr
    c02e:	ldrd	r2, r3, [r1]
    c032:	and.w	r5, r4, #3
    c036:	rsb	r0, r4, #0
    c03a:	mov.w	r5, r5, lsl #3
    c03e:	tst.w	r4, #4
    c042:	pld	[r1, #64]	; 0x40
    c046:	lsl.w	r5, ip, r5
    c04a:	orn	r2, r2, r5
    c04e:	itt	ne
    c050:	ornne	r3, r3, r5
    c054:	movne	r2, ip
    c056:	mov.w	r4, #0
    c05a:	b.n	bfb0 <strlen+0x30>

0000c05c <strncmp>:
    c05c:	cmp	r2, #0
    c05e:	beq.n	c0e4 <strncmp+0x88>
    c060:	orr.w	r3, r0, r1
    c064:	ands.w	r3, r3, #3
    c068:	push	{r4, r5, r6, r7}
    c06a:	bne.n	c0b8 <strncmp+0x5c>
    c06c:	cmp	r2, #3
    c06e:	bls.n	c0b8 <strncmp+0x5c>
    c070:	ldr	r4, [r0, #0]
    c072:	ldr	r5, [r1, #0]
    c074:	cmp	r4, r5
    c076:	bne.n	c0b8 <strncmp+0x5c>
    c078:	subs	r2, #4
    c07a:	beq.n	c0e8 <strncmp+0x8c>
    c07c:	sub.w	r5, r4, #16843009	; 0x1010101
    c080:	bic.w	r4, r5, r4
    c084:	tst.w	r4, #2155905152	; 0x80808080
    c088:	bne.n	c0ee <strncmp+0x92>
    c08a:	adds	r7, r0, #4
    c08c:	adds	r5, r1, #4
    c08e:	b.n	c0ac <strncmp+0x50>
    c090:	ldr.w	r3, [r7], #4
    c094:	ldr	r6, [r1, #0]
    c096:	sub.w	r4, r3, #16843009	; 0x1010101
    c09a:	cmp	r3, r6
    c09c:	bic.w	r4, r4, r3
    c0a0:	bne.n	c0b8 <strncmp+0x5c>
    c0a2:	subs	r2, #4
    c0a4:	beq.n	c0e8 <strncmp+0x8c>
    c0a6:	tst.w	r4, #2155905152	; 0x80808080
    c0aa:	bne.n	c0f4 <strncmp+0x98>
    c0ac:	cmp	r2, #3
    c0ae:	mov	r1, r5
    c0b0:	mov	r0, r7
    c0b2:	add.w	r5, r5, #4
    c0b6:	bhi.n	c090 <strncmp+0x34>
    c0b8:	ldrb	r3, [r0, #0]
    c0ba:	ldrb	r4, [r1, #0]
    c0bc:	cmp	r4, r3
    c0be:	add.w	r2, r2, #4294967295
    c0c2:	bne.n	c0de <strncmp+0x82>
    c0c4:	cbz	r2, c0e8 <strncmp+0x8c>
    c0c6:	cbnz	r4, c0ce <strncmp+0x72>
    c0c8:	b.n	c0f8 <strncmp+0x9c>
    c0ca:	cbz	r2, c0e8 <strncmp+0x8c>
    c0cc:	cbz	r3, c0ee <strncmp+0x92>
    c0ce:	ldrb.w	r3, [r0, #1]!
    c0d2:	ldrb.w	r4, [r1, #1]!
    c0d6:	cmp	r3, r4
    c0d8:	add.w	r2, r2, #4294967295
    c0dc:	beq.n	c0ca <strncmp+0x6e>
    c0de:	subs	r0, r3, r4
    c0e0:	pop	{r4, r5, r6, r7}
    c0e2:	bx	lr
    c0e4:	mov	r0, r2
    c0e6:	bx	lr
    c0e8:	mov	r0, r2
    c0ea:	pop	{r4, r5, r6, r7}
    c0ec:	bx	lr
    c0ee:	mov	r0, r3
    c0f0:	pop	{r4, r5, r6, r7}
    c0f2:	bx	lr
    c0f4:	movs	r0, #0
    c0f6:	b.n	c0e0 <strncmp+0x84>
    c0f8:	mov	r0, r4
    c0fa:	b.n	c0e0 <strncmp+0x84>

0000c0fc <sulp>:
    c0fc:	push	{r4, r5, r6, lr}
    c0fe:	mov	r4, r0
    c100:	mov	r5, r1
    c102:	vmov	d0, r4, r5
    c106:	mov	r6, r2
    c108:	bl	11860 <__ulp>
    c10c:	vmov	r0, r1, d0
    c110:	cbz	r6, c132 <sulp+0x36>
    c112:	ubfx	r3, r5, #20, #11
    c116:	rsb	r3, r3, #107	; 0x6b
    c11a:	cmp	r3, #0
    c11c:	ble.n	c132 <sulp+0x36>
    c11e:	lsls	r3, r3, #20
    c120:	add.w	r5, r3, #1069547520	; 0x3fc00000
    c124:	movs	r4, #0
    c126:	add.w	r5, r5, #3145728	; 0x300000
    c12a:	mov	r2, r4
    c12c:	mov	r3, r5
    c12e:	bl	a8b8 <__aeabi_dmul>
    c132:	pop	{r4, r5, r6, pc}
    c134:			; <UNDEFINED> instruction: 0xffffffff

0000c138 <_strtod_l>:
    c138:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c13c:	mov	r5, r3
    c13e:	sub	sp, #132	; 0x84
    c140:	movs	r3, #0
    c142:	mov	fp, r0
    c144:	mov	r0, r5
    c146:	mov	r6, r1
    c148:	str	r2, [sp, #24]
    c14a:	str	r3, [sp, #112]	; 0x70
    c14c:	bl	111e4 <__localeconv_l>
    c150:	movs	r4, #0
    c152:	movs	r3, #0
    c154:	mov	sl, r0
    c156:	ldr	r0, [r0, #0]
    c158:	strd	r3, r4, [sp, #16]
    c15c:	bl	bf80 <strlen>
    c160:	str	r6, [sp, #108]	; 0x6c
    c162:	mov	r9, r0
    c164:	mov	r2, r6
    c166:	mov	r4, r2
    c168:	ldrb.w	r7, [r2], #1
    c16c:	cmp	r7, #45	; 0x2d
    c16e:	bhi.w	c2d0 <_strtod_l+0x198>
    c172:	tbb	[pc, r7]
    c176:	.short	0xad17
    c178:	.word	0xadadadad
    c17c:	.word	0x81adadad
    c180:	.word	0x81818181
    c184:	.word	0xadadadad
    c188:	.word	0xadadadad
    c18c:	.word	0xadadadad
    c190:	.word	0xadadadad
    c194:	.word	0xad81adad
    c198:	.word	0xadadadad
    c19c:	.word	0xadadadad
    c1a0:	.word	0x7ead2bad
    c1a4:	ldr	r3, [sp, #24]
    c1a6:	mov.w	r8, #0
    c1aa:	mov.w	r9, #0
    c1ae:	cbz	r3, c1c2 <_strtod_l+0x8a>
    c1b0:	movs	r3, #0
    c1b2:	str	r3, [sp, #28]
    c1b4:	ldr	r3, [sp, #24]
    c1b6:	str	r6, [r3, #0]
    c1b8:	ldr	r3, [sp, #28]
    c1ba:	cbz	r3, c1c2 <_strtod_l+0x8a>
    c1bc:	add.w	r3, r9, #2147483648	; 0x80000000
    c1c0:	mov	r9, r3
    c1c2:	vmov	d0, r8, r9
    c1c6:	add	sp, #132	; 0x84
    c1c8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c1cc:	movs	r3, #0
    c1ce:	str	r3, [sp, #28]
    c1d0:	adds	r2, r4, #1
    c1d2:	str	r2, [sp, #108]	; 0x6c
    c1d4:	ldrb	r7, [r4, #1]
    c1d6:	cmp	r7, #0
    c1d8:	beq.n	c1a4 <_strtod_l+0x6c>
    c1da:	cmp	r7, #48	; 0x30
    c1dc:	mov	r4, r2
    c1de:	beq.n	c2d8 <_strtod_l+0x1a0>
    c1e0:	movs	r3, #0
    c1e2:	str	r4, [sp, #32]
    c1e4:	str	r3, [sp, #40]	; 0x28
    c1e6:	sub.w	r3, r7, #48	; 0x30
    c1ea:	cmp	r3, #9
    c1ec:	bhi.w	c9fe <_strtod_l+0x8c6>
    c1f0:	mov.w	r8, #0
    c1f4:	mov	r0, r4
    c1f6:	mov	r5, r8
    c1f8:	mov	r4, r8
    c1fa:	cmp	r4, #8
    c1fc:	it	gt
    c1fe:	addgt.w	r8, r8, r8, lsl #2
    c202:	add.w	r3, r5, r5, lsl #2
    c206:	add.w	r0, r0, #1
    c20a:	add.w	r3, r7, r3, lsl #1
    c20e:	str	r0, [sp, #108]	; 0x6c
    c210:	itt	gt
    c212:	addgt.w	r7, r7, r8, lsl #1
    c216:	subgt.w	r8, r7, #48	; 0x30
    c21a:	ldrb	r7, [r0, #0]
    c21c:	it	le
    c21e:	suble.w	r5, r3, #48	; 0x30
    c222:	sub.w	r3, r7, #48	; 0x30
    c226:	cmp	r3, #9
    c228:	add.w	r4, r4, #1
    c22c:	bls.n	c1fa <_strtod_l+0xc2>
    c22e:	ldr.w	r1, [sl]
    c232:	mov	r2, r9
    c234:	bl	c05c <strncmp>
    c238:	cbz	r0, c27c <_strtod_l+0x144>
    c23a:	movs	r0, #0
    c23c:	mov	r3, r7
    c23e:	mov	r9, r0
    c240:	mov	r7, r0
    c242:	mov	sl, r4
    c244:	cmp	r3, #101	; 0x65
    c246:	beq.w	c3ae <_strtod_l+0x276>
    c24a:	cmp	r3, #69	; 0x45
    c24c:	beq.w	c3ae <_strtod_l+0x276>
    c250:	movs	r2, #0
    c252:	cmp	r4, #0
    c254:	bne.n	c2fc <_strtod_l+0x1c4>
    c256:	cbnz	r0, c260 <_strtod_l+0x128>
    c258:	ldr	r2, [sp, #40]	; 0x28
    c25a:	cmp	r2, #0
    c25c:	beq.w	c802 <_strtod_l+0x6ca>
    c260:	mov.w	r8, #0
    c264:	mov.w	r9, #0
    c268:	ldr	r3, [sp, #24]
    c26a:	cmp	r3, #0
    c26c:	beq.n	c1b8 <_strtod_l+0x80>
    c26e:	ldr	r6, [sp, #108]	; 0x6c
    c270:	b.n	c1b4 <_strtod_l+0x7c>
    c272:	movs	r3, #1
    c274:	str	r3, [sp, #28]
    c276:	b.n	c1d0 <_strtod_l+0x98>
    c278:	str	r2, [sp, #108]	; 0x6c
    c27a:	b.n	c166 <_strtod_l+0x2e>
    c27c:	ldr	r3, [sp, #108]	; 0x6c
    c27e:	add.w	r2, r3, r9
    c282:	str	r2, [sp, #108]	; 0x6c
    c284:	ldrb.w	r3, [r3, r9]
    c288:	mov	r7, r0
    c28a:	mov	sl, r4
    c28c:	sub.w	r2, r3, #48	; 0x30
    c290:	cmp	r2, #9
    c292:	bhi.w	c788 <_strtod_l+0x650>
    c296:	adds	r1, r0, #1
    c298:	mov	r3, r2
    c29a:	cmp	r2, #0
    c29c:	beq.w	cfde <_strtod_l+0xea6>
    c2a0:	cmp	r1, #1
    c2a2:	add	r7, r1
    c2a4:	it	ne
    c2a6:	addne	r0, r0, r4
    c2a8:	bne.n	c2b6 <_strtod_l+0x17e>
    c2aa:	b.w	cfd6 <_strtod_l+0xe9e>
    c2ae:	lsls	r5, r1, #1
    c2b0:	cmp	r4, r0
    c2b2:	beq.w	cc2c <_strtod_l+0xaf4>
    c2b6:	adds	r4, #1
    c2b8:	subs	r1, r4, #1
    c2ba:	cmp	r1, #8
    c2bc:	add.w	r1, r5, r5, lsl #2
    c2c0:	ble.n	c2ae <_strtod_l+0x176>
    c2c2:	cmp	r4, #16
    c2c4:	itt	le
    c2c6:	addle.w	r8, r8, r8, lsl #2
    c2ca:	movle.w	r8, r8, lsl #1
    c2ce:	b.n	c2b0 <_strtod_l+0x178>
    c2d0:	movs	r3, #0
    c2d2:	cmp	r7, #48	; 0x30
    c2d4:	str	r3, [sp, #28]
    c2d6:	bne.n	c1e0 <_strtod_l+0xa8>
    c2d8:	ldrb	r3, [r4, #1]
    c2da:	cmp	r3, #88	; 0x58
    c2dc:	beq.w	c9c6 <_strtod_l+0x88e>
    c2e0:	cmp	r3, #120	; 0x78
    c2e2:	beq.w	c9c6 <_strtod_l+0x88e>
    c2e6:	adds	r4, #1
    c2e8:	str	r4, [sp, #108]	; 0x6c
    c2ea:	ldrb	r7, [r4, #0]
    c2ec:	cmp	r7, #48	; 0x30
    c2ee:	beq.n	c2e6 <_strtod_l+0x1ae>
    c2f0:	cmp	r7, #0
    c2f2:	beq.n	c260 <_strtod_l+0x128>
    c2f4:	movs	r3, #1
    c2f6:	str	r4, [sp, #32]
    c2f8:	str	r3, [sp, #40]	; 0x28
    c2fa:	b.n	c1e6 <_strtod_l+0xae>
    c2fc:	cmp	r4, #16
    c2fe:	sub.w	r3, r2, r7
    c302:	mov	r0, r5
    c304:	mov	r9, r4
    c306:	str	r3, [sp, #44]	; 0x2c
    c308:	it	ge
    c30a:	movge.w	r9, #16
    c30e:	bl	a7cc <__aeabi_ui2d>
    c312:	cmp.w	sl, #0
    c316:	it	eq
    c318:	moveq	sl, r4
    c31a:	cmp.w	r9, #9
    c31e:	strd	r0, r1, [sp, #16]
    c322:	ble.n	c34c <_strtod_l+0x214>
    c324:	ldr	r3, [pc, #292]	; (c44c <_strtod_l+0x314>)
    c326:	add.w	r3, r3, r9, lsl #3
    c32a:	ldrd	r2, r3, [r3, #-72]	; 0x48
    c32e:	bl	a8b8 <__aeabi_dmul>
    c332:	mov	r6, r0
    c334:	mov	r0, r8
    c336:	mov	r7, r1
    c338:	bl	a7cc <__aeabi_ui2d>
    c33c:	mov	r2, r0
    c33e:	mov	r3, r1
    c340:	mov	r0, r6
    c342:	mov	r1, r7
    c344:	bl	a554 <__adddf3>
    c348:	strd	r0, r1, [sp, #16]
    c34c:	cmp	r4, #15
    c34e:	bgt.w	c45c <_strtod_l+0x324>
    c352:	ldr	r3, [sp, #44]	; 0x2c
    c354:	cmp	r3, #0
    c356:	beq.n	c3a8 <_strtod_l+0x270>
    c358:	ble.w	cd94 <_strtod_l+0xc5c>
    c35c:	ldr	r3, [sp, #44]	; 0x2c
    c35e:	cmp	r3, #22
    c360:	bgt.w	cc60 <_strtod_l+0xb28>
    c364:	ldr	r7, [pc, #228]	; (c44c <_strtod_l+0x314>)
    c366:	add.w	r7, r7, r3, lsl #3
    c36a:	ldrd	r0, r1, [r7]
    c36e:	ldrd	r2, r3, [sp, #16]
    c372:	bl	a8b8 <__aeabi_dmul>
    c376:	mov	r8, r0
    c378:	mov	r9, r1
    c37a:	b.n	c268 <_strtod_l+0x130>
    c37c:	add	r0, sp, #108	; 0x6c
    c37e:	ldr	r1, [pc, #208]	; (c450 <_strtod_l+0x318>)
    c380:	bl	11018 <__match>
    c384:	cmp	r0, #0
    c386:	beq.w	c1a4 <_strtod_l+0x6c>
    c38a:	ldr	r3, [sp, #108]	; 0x6c
    c38c:	ldr	r1, [pc, #196]	; (c454 <_strtod_l+0x31c>)
    c38e:	subs	r3, #1
    c390:	add	r0, sp, #108	; 0x6c
    c392:	str	r3, [sp, #108]	; 0x6c
    c394:	bl	11018 <__match>
    c398:	cbnz	r0, c3a0 <_strtod_l+0x268>
    c39a:	ldr	r3, [sp, #108]	; 0x6c
    c39c:	adds	r3, #1
    c39e:	str	r3, [sp, #108]	; 0x6c
    c3a0:	ldr	r3, [pc, #180]	; (c458 <_strtod_l+0x320>)
    c3a2:	str	r3, [sp, #20]
    c3a4:	movs	r3, #0
    c3a6:	str	r3, [sp, #16]
    c3a8:	ldrd	r8, r9, [sp, #16]
    c3ac:	b.n	c268 <_strtod_l+0x130>
    c3ae:	cmp	r4, #0
    c3b0:	beq.w	c748 <_strtod_l+0x610>
    c3b4:	ldr	r6, [sp, #108]	; 0x6c
    c3b6:	adds	r3, r6, #1
    c3b8:	str	r3, [sp, #108]	; 0x6c
    c3ba:	ldrb	r3, [r6, #1]
    c3bc:	cmp	r3, #43	; 0x2b
    c3be:	beq.w	c97c <_strtod_l+0x844>
    c3c2:	cmp	r3, #45	; 0x2d
    c3c4:	beq.w	c7f2 <_strtod_l+0x6ba>
    c3c8:	mov.w	ip, #0
    c3cc:	sub.w	r2, r3, #48	; 0x30
    c3d0:	cmp	r2, #9
    c3d2:	bhi.w	c976 <_strtod_l+0x83e>
    c3d6:	cmp	r3, #48	; 0x30
    c3d8:	bne.n	c3e6 <_strtod_l+0x2ae>
    c3da:	ldr	r2, [sp, #108]	; 0x6c
    c3dc:	adds	r2, #1
    c3de:	str	r2, [sp, #108]	; 0x6c
    c3e0:	ldrb	r3, [r2, #0]
    c3e2:	cmp	r3, #48	; 0x30
    c3e4:	beq.n	c3dc <_strtod_l+0x2a4>
    c3e6:	sub.w	r2, r3, #49	; 0x31
    c3ea:	cmp	r2, #8
    c3ec:	bhi.w	c250 <_strtod_l+0x118>
    c3f0:	ldr	r2, [sp, #108]	; 0x6c
    c3f2:	str	r2, [sp, #48]	; 0x30
    c3f4:	adds	r1, r2, #1
    c3f6:	subs	r3, #48	; 0x30
    c3f8:	str	r1, [sp, #108]	; 0x6c
    c3fa:	str	r3, [sp, #44]	; 0x2c
    c3fc:	ldrb	r3, [r2, #1]
    c3fe:	sub.w	lr, r3, #48	; 0x30
    c402:	cmp.w	lr, #9
    c406:	bhi.n	c428 <_strtod_l+0x2f0>
    c408:	ldr	r2, [sp, #44]	; 0x2c
    c40a:	adds	r1, #1
    c40c:	str	r1, [sp, #108]	; 0x6c
    c40e:	add.w	r2, r2, r2, lsl #2
    c412:	add.w	r2, r3, r2, lsl #1
    c416:	ldrb	r3, [r1, #0]
    c418:	sub.w	lr, r3, #48	; 0x30
    c41c:	cmp.w	lr, #9
    c420:	sub.w	r2, r2, #48	; 0x30
    c424:	bls.n	c40a <_strtod_l+0x2d2>
    c426:	str	r2, [sp, #44]	; 0x2c
    c428:	ldr	r2, [sp, #48]	; 0x30
    c42a:	subs	r1, r1, r2
    c42c:	cmp	r1, #8
    c42e:	bgt.w	cc4e <_strtod_l+0xb16>
    c432:	ldr	r2, [sp, #44]	; 0x2c
    c434:	movw	r1, #19999	; 0x4e1f
    c438:	cmp	r2, r1
    c43a:	it	ge
    c43c:	movge	r2, r1
    c43e:	cmp.w	ip, #0
    c442:	beq.w	c252 <_strtod_l+0x11a>
    c446:	negs	r2, r2
    c448:	b.n	c252 <_strtod_l+0x11a>
    c44a:	nop
    c44c:	.word	0x00013428
    c450:	.word	0x00013134
    c454:	.word	0x00013138
    c458:	.word	0x7ff00000
    c45c:	ldr	r3, [sp, #44]	; 0x2c
    c45e:	rsb	r9, r9, r4
    c462:	add	r9, r3
    c464:	cmp.w	r9, #0
    c468:	ble.w	cb7a <_strtod_l+0xa42>
    c46c:	ands.w	r1, r9, #15
    c470:	beq.n	c488 <_strtod_l+0x350>
    c472:	ldr	r3, [pc, #756]	; (c768 <_strtod_l+0x630>)
    c474:	add.w	r1, r3, r1, lsl #3
    c478:	ldrd	r0, r1, [r1]
    c47c:	ldrd	r2, r3, [sp, #16]
    c480:	bl	a8b8 <__aeabi_dmul>
    c484:	strd	r0, r1, [sp, #16]
    c488:	bics.w	r6, r9, #15
    c48c:	bne.w	c8b0 <_strtod_l+0x778>
    c490:	movs	r3, #0
    c492:	str	r3, [sp, #40]	; 0x28
    c494:	str	r5, [sp, #0]
    c496:	mov	r3, r4
    c498:	mov	r2, sl
    c49a:	ldr	r1, [sp, #32]
    c49c:	mov	r0, fp
    c49e:	bl	11340 <__s2b>
    c4a2:	str	r0, [sp, #72]	; 0x48
    c4a4:	cmp	r0, #0
    c4a6:	beq.w	caf6 <_strtod_l+0x9be>
    c4aa:	ldr	r2, [sp, #44]	; 0x2c
    c4ac:	movs	r7, #0
    c4ae:	cmp	r2, #0
    c4b0:	rsb	r3, r2, #0
    c4b4:	it	ge
    c4b6:	movge	r3, r7
    c4b8:	str	r3, [sp, #48]	; 0x30
    c4ba:	bic.w	r3, r2, r2, asr #31
    c4be:	str	r3, [sp, #44]	; 0x2c
    c4c0:	mov	sl, r7
    c4c2:	ldr	r4, [sp, #72]	; 0x48
    c4c4:	mov	r0, fp
    c4c6:	ldr	r1, [r4, #4]
    c4c8:	bl	11260 <_Balloc>
    c4cc:	mov	r6, r0
    c4ce:	cmp	r0, #0
    c4d0:	beq.w	c988 <_strtod_l+0x850>
    c4d4:	ldr	r2, [r4, #16]
    c4d6:	vldr	d7, [sp, #16]
    c4da:	adds	r2, #2
    c4dc:	lsls	r2, r2, #2
    c4de:	add.w	r1, r4, #12
    c4e2:	adds	r0, #12
    c4e4:	vstr	d7, [sp, #32]
    c4e8:	bl	8f14 <memcpy>
    c4ec:	vldr	d0, [sp, #32]
    c4f0:	add	r2, sp, #120	; 0x78
    c4f2:	add	r1, sp, #116	; 0x74
    c4f4:	mov	r0, fp
    c4f6:	bl	11984 <__d2b>
    c4fa:	str	r0, [sp, #112]	; 0x70
    c4fc:	cmp	r0, #0
    c4fe:	beq.w	c98a <_strtod_l+0x852>
    c502:	movs	r1, #1
    c504:	mov	r0, fp
    c506:	bl	11474 <__i2b>
    c50a:	mov	sl, r0
    c50c:	cmp	r0, #0
    c50e:	beq.w	c988 <_strtod_l+0x850>
    c512:	ldr	r2, [sp, #116]	; 0x74
    c514:	cmp	r2, #0
    c516:	blt.w	c780 <_strtod_l+0x648>
    c51a:	ldr	r3, [sp, #48]	; 0x30
    c51c:	ldr	r4, [sp, #44]	; 0x2c
    c51e:	adds	r5, r3, r2
    c520:	ldr	r0, [sp, #40]	; 0x28
    c522:	ldr	r3, [sp, #120]	; 0x78
    c524:	ldr	r1, [pc, #580]	; (c76c <_strtod_l+0x634>)
    c526:	subs	r2, r2, r0
    c528:	add	r2, r3
    c52a:	subs	r2, #1
    c52c:	cmp	r2, r1
    c52e:	rsb	r3, r3, #54	; 0x36
    c532:	bge.w	c712 <_strtod_l+0x5da>
    c536:	subs	r1, r1, r2
    c538:	cmp	r1, #31
    c53a:	sub.w	r3, r3, r1
    c53e:	bgt.w	c78e <_strtod_l+0x656>
    c542:	movs	r2, #1
    c544:	lsls	r2, r1
    c546:	str	r2, [sp, #56]	; 0x38
    c548:	movs	r2, #0
    c54a:	str	r2, [sp, #76]	; 0x4c
    c54c:	add.w	r9, r5, r3
    c550:	add	r4, r3
    c552:	ldr	r3, [sp, #40]	; 0x28
    c554:	cmp	r5, r9
    c556:	mov	r2, r5
    c558:	add	r4, r3
    c55a:	it	ge
    c55c:	movge	r2, r9
    c55e:	cmp	r2, r4
    c560:	it	ge
    c562:	movge	r2, r4
    c564:	cmp	r2, #0
    c566:	ble.n	c570 <_strtod_l+0x438>
    c568:	rsb	r9, r2, r9
    c56c:	subs	r4, r4, r2
    c56e:	subs	r5, r5, r2
    c570:	ldr	r3, [sp, #48]	; 0x30
    c572:	cbz	r3, c5a4 <_strtod_l+0x46c>
    c574:	mov	r1, sl
    c576:	mov	r2, r3
    c578:	mov	r0, fp
    c57a:	bl	115b8 <__pow5mult>
    c57e:	mov	sl, r0
    c580:	cmp	r0, #0
    c582:	beq.w	c988 <_strtod_l+0x850>
    c586:	mov	r1, r0
    c588:	ldr	r2, [sp, #112]	; 0x70
    c58a:	mov	r0, fp
    c58c:	bl	11488 <__multiply>
    c590:	cmp	r0, #0
    c592:	beq.w	c988 <_strtod_l+0x850>
    c596:	str	r0, [sp, #52]	; 0x34
    c598:	ldr	r1, [sp, #112]	; 0x70
    c59a:	mov	r0, fp
    c59c:	bl	112ac <_Bfree>
    c5a0:	ldr	r2, [sp, #52]	; 0x34
    c5a2:	str	r2, [sp, #112]	; 0x70
    c5a4:	cmp.w	r9, #0
    c5a8:	ble.n	c5bc <_strtod_l+0x484>
    c5aa:	mov	r2, r9
    c5ac:	ldr	r1, [sp, #112]	; 0x70
    c5ae:	mov	r0, fp
    c5b0:	bl	11658 <__lshift>
    c5b4:	str	r0, [sp, #112]	; 0x70
    c5b6:	cmp	r0, #0
    c5b8:	beq.w	c98a <_strtod_l+0x852>
    c5bc:	ldr	r3, [sp, #44]	; 0x2c
    c5be:	cbz	r3, c5d2 <_strtod_l+0x49a>
    c5c0:	mov	r1, r6
    c5c2:	ldr	r2, [sp, #44]	; 0x2c
    c5c4:	mov	r0, fp
    c5c6:	bl	115b8 <__pow5mult>
    c5ca:	mov	r6, r0
    c5cc:	cmp	r0, #0
    c5ce:	beq.w	c988 <_strtod_l+0x850>
    c5d2:	cmp	r4, #0
    c5d4:	ble.n	c5e8 <_strtod_l+0x4b0>
    c5d6:	mov	r1, r6
    c5d8:	mov	r2, r4
    c5da:	mov	r0, fp
    c5dc:	bl	11658 <__lshift>
    c5e0:	mov	r6, r0
    c5e2:	cmp	r0, #0
    c5e4:	beq.w	c988 <_strtod_l+0x850>
    c5e8:	cmp	r5, #0
    c5ea:	ble.n	c5fe <_strtod_l+0x4c6>
    c5ec:	mov	r1, sl
    c5ee:	mov	r2, r5
    c5f0:	mov	r0, fp
    c5f2:	bl	11658 <__lshift>
    c5f6:	mov	sl, r0
    c5f8:	cmp	r0, #0
    c5fa:	beq.w	c988 <_strtod_l+0x850>
    c5fe:	mov	r2, r6
    c600:	ldr	r1, [sp, #112]	; 0x70
    c602:	mov	r0, fp
    c604:	bl	1174c <__mdiff>
    c608:	mov	r7, r0
    c60a:	cmp	r0, #0
    c60c:	beq.w	c988 <_strtod_l+0x850>
    c610:	movs	r3, #0
    c612:	ldr	r2, [r0, #12]
    c614:	str	r3, [r0, #12]
    c616:	mov	r1, sl
    c618:	str	r2, [sp, #52]	; 0x34
    c61a:	bl	11708 <__mcmp>
    c61e:	cmp	r0, #0
    c620:	blt.w	ce3e <_strtod_l+0xd06>
    c624:	beq.w	cdb8 <_strtod_l+0xc80>
    c628:	mov	r1, sl
    c62a:	mov	r0, r7
    c62c:	bl	11a40 <__ratio>
    c630:	vmov	r4, r5, d0
    c634:	movs	r2, #0
    c636:	mov.w	r3, #1073741824	; 0x40000000
    c63a:	vmov	r0, s0
    c63e:	mov	r1, r5
    c640:	bl	adb0 <__aeabi_dcmple>
    c644:	cmp	r0, #0
    c646:	beq.n	c71c <_strtod_l+0x5e4>
    c648:	ldr	r3, [sp, #52]	; 0x34
    c64a:	cmp	r3, #0
    c64c:	beq.w	c79e <_strtod_l+0x666>
    c650:	vldr	d7, [pc, #260]	; c758 <_strtod_l+0x620>
    c654:	ldr	r3, [sp, #20]
    c656:	ldr	r5, [pc, #280]	; (c770 <_strtod_l+0x638>)
    c658:	vstr	d7, [sp, #56]	; 0x38
    c65c:	movs	r4, #0
    c65e:	mov	r8, r3
    c660:	ldr.w	r9, [pc, #276]	; c778 <_strtod_l+0x640>
    c664:	ldr	r3, [pc, #268]	; (c774 <_strtod_l+0x63c>)
    c666:	and.w	r9, r8, r9
    c66a:	cmp	r9, r3
    c66c:	beq.w	ca9c <_strtod_l+0x964>
    c670:	ldr	r3, [sp, #40]	; 0x28
    c672:	cbz	r3, c6c0 <_strtod_l+0x588>
    c674:	cmp.w	r9, #111149056	; 0x6a00000
    c678:	bhi.n	c6c0 <_strtod_l+0x588>
    c67a:	add	r3, pc, #228	; (adr r3, c760 <_strtod_l+0x628>)
    c67c:	ldrd	r2, r3, [r3]
    c680:	ldrd	r0, r1, [sp, #56]	; 0x38
    c684:	bl	adb0 <__aeabi_dcmple>
    c688:	cbz	r0, c6b8 <_strtod_l+0x580>
    c68a:	ldrd	r0, r1, [sp, #56]	; 0x38
    c68e:	bl	ae68 <__aeabi_d2uiz>
    c692:	cmp	r0, #0
    c694:	beq.w	cd18 <_strtod_l+0xbe0>
    c698:	bl	a7cc <__aeabi_ui2d>
    c69c:	strd	r0, r1, [sp, #56]	; 0x38
    c6a0:	ldr	r3, [sp, #52]	; 0x34
    c6a2:	cmp	r3, #0
    c6a4:	bne.w	cd0e <_strtod_l+0xbd6>
    c6a8:	ldrd	r1, r2, [sp, #56]	; 0x38
    c6ac:	add.w	r3, r2, #2147483648	; 0x80000000
    c6b0:	str	r1, [sp, #80]	; 0x50
    c6b2:	str	r3, [sp, #84]	; 0x54
    c6b4:	ldrd	r4, r5, [sp, #80]	; 0x50
    c6b8:	add.w	r3, r5, #112197632	; 0x6b00000
    c6bc:	rsb	r5, r9, r3
    c6c0:	vldr	d0, [sp, #32]
    c6c4:	bl	11860 <__ulp>
    c6c8:	mov	r0, r4
    c6ca:	vmov	r2, r3, d0
    c6ce:	mov	r1, r5
    c6d0:	bl	a8b8 <__aeabi_dmul>
    c6d4:	ldrd	r2, r3, [sp, #32]
    c6d8:	bl	a554 <__adddf3>
    c6dc:	strd	r0, r1, [sp, #16]
    c6e0:	mov	r4, r1
    c6e2:	ldr	r3, [sp, #40]	; 0x28
    c6e4:	cbnz	r3, c6f0 <_strtod_l+0x5b8>
    c6e6:	ldr	r3, [pc, #144]	; (c778 <_strtod_l+0x640>)
    c6e8:	ands	r3, r4
    c6ea:	cmp	r9, r3
    c6ec:	beq.w	cb0c <_strtod_l+0x9d4>
    c6f0:	ldr	r1, [sp, #112]	; 0x70
    c6f2:	mov	r0, fp
    c6f4:	bl	112ac <_Bfree>
    c6f8:	mov	r1, r6
    c6fa:	mov	r0, fp
    c6fc:	bl	112ac <_Bfree>
    c700:	mov	r1, sl
    c702:	mov	r0, fp
    c704:	bl	112ac <_Bfree>
    c708:	mov	r1, r7
    c70a:	mov	r0, fp
    c70c:	bl	112ac <_Bfree>
    c710:	b.n	c4c2 <_strtod_l+0x38a>
    c712:	movs	r2, #0
    c714:	str	r2, [sp, #76]	; 0x4c
    c716:	movs	r2, #1
    c718:	str	r2, [sp, #56]	; 0x38
    c71a:	b.n	c54c <_strtod_l+0x414>
    c71c:	ldr	r3, [pc, #92]	; (c77c <_strtod_l+0x644>)
    c71e:	mov	r0, r4
    c720:	mov	r1, r5
    c722:	movs	r2, #0
    c724:	bl	a8b8 <__aeabi_dmul>
    c728:	ldr	r3, [sp, #52]	; 0x34
    c72a:	strd	r0, r1, [sp, #56]	; 0x38
    c72e:	cmp	r3, #0
    c730:	bne.n	c7e8 <_strtod_l+0x6b0>
    c732:	add.w	r3, r1, #2147483648	; 0x80000000
    c736:	str	r0, [sp, #64]	; 0x40
    c738:	str	r3, [sp, #68]	; 0x44
    c73a:	ldr	r3, [sp, #20]
    c73c:	ldrd	r4, r5, [sp, #64]	; 0x40
    c740:	mov	r8, r3
    c742:	b.n	c660 <_strtod_l+0x528>
    c744:	mov.w	r9, #1
    c748:	cmp	r0, #0
    c74a:	bne.n	c7fe <_strtod_l+0x6c6>
    c74c:	ldr	r3, [sp, #40]	; 0x28
    c74e:	cmp	r3, #0
    c750:	beq.w	c1a4 <_strtod_l+0x6c>
    c754:	mov	r4, r0
    c756:	b.n	c3b4 <_strtod_l+0x27c>
    c758:	.word	0x00000000
    c75c:	.word	0x3ff00000
    c760:	.word	0xffc00000
    c764:	.word	0x41dfffff
    c768:	.word	0x00013428
    c76c:	.word	0xfffffc02
    c770:	.word	0x3ff00000
    c774:	.word	0x7fe00000
    c778:	.word	0x7ff00000
    c77c:	.word	0x3fe00000
    c780:	ldr	r3, [sp, #44]	; 0x2c
    c782:	ldr	r5, [sp, #48]	; 0x30
    c784:	subs	r4, r3, r2
    c786:	b.n	c520 <_strtod_l+0x3e8>
    c788:	mov.w	r9, #1
    c78c:	b.n	c244 <_strtod_l+0x10c>
    c78e:	ldr	r1, [pc, #736]	; (ca70 <_strtod_l+0x938>)
    c790:	subs	r1, r1, r2
    c792:	movs	r2, #1
    c794:	lsl.w	r1, r2, r1
    c798:	str	r1, [sp, #76]	; 0x4c
    c79a:	str	r2, [sp, #56]	; 0x38
    c79c:	b.n	c54c <_strtod_l+0x414>
    c79e:	ldrd	r1, r2, [sp, #16]
    c7a2:	cmp	r1, #0
    c7a4:	bne.w	c93a <_strtod_l+0x802>
    c7a8:	ubfx	r3, r2, #0, #20
    c7ac:	mov	r8, r2
    c7ae:	cmp	r3, #0
    c7b0:	bne.w	c946 <_strtod_l+0x80e>
    c7b4:	movs	r2, #0
    c7b6:	ldr	r3, [pc, #700]	; (ca74 <_strtod_l+0x93c>)
    c7b8:	mov	r0, r4
    c7ba:	mov	r1, r5
    c7bc:	bl	ad9c <__aeabi_dcmplt>
    c7c0:	cmp	r0, #0
    c7c2:	bne.w	cec2 <_strtod_l+0xd8a>
    c7c6:	movs	r2, #0
    c7c8:	ldr	r3, [pc, #684]	; (ca78 <_strtod_l+0x940>)
    c7ca:	mov	r0, r4
    c7cc:	mov	r1, r5
    c7ce:	bl	a8b8 <__aeabi_dmul>
    c7d2:	mov	r2, r1
    c7d4:	mov	r1, r0
    c7d6:	strd	r1, r2, [sp, #56]	; 0x38
    c7da:	add.w	r3, r2, #2147483648	; 0x80000000
    c7de:	str	r0, [sp, #96]	; 0x60
    c7e0:	str	r3, [sp, #100]	; 0x64
    c7e2:	ldrd	r4, r5, [sp, #96]	; 0x60
    c7e6:	b.n	c660 <_strtod_l+0x528>
    c7e8:	vldr	d7, [sp, #56]	; 0x38
    c7ec:	vstr	d7, [sp, #64]	; 0x40
    c7f0:	b.n	c73a <_strtod_l+0x602>
    c7f2:	mov.w	ip, #1
    c7f6:	adds	r3, r6, #2
    c7f8:	str	r3, [sp, #108]	; 0x6c
    c7fa:	ldrb	r3, [r6, #2]
    c7fc:	b.n	c3cc <_strtod_l+0x294>
    c7fe:	movs	r4, #0
    c800:	b.n	c3b4 <_strtod_l+0x27c>
    c802:	cmp.w	r9, #0
    c806:	bne.w	c1a4 <_strtod_l+0x6c>
    c80a:	subs	r3, #73	; 0x49
    c80c:	cmp	r3, #37	; 0x25
    c80e:	bhi.w	c1a4 <_strtod_l+0x6c>
    c812:	add	r2, pc, #4	; (adr r2, c818 <_strtod_l+0x6e0>)
    c814:	ldr.w	pc, [r2, r3, lsl #2]
    c818:	.word	0x0000c37d
    c81c:	.word	0x0000c1a5
    c820:	.word	0x0000c1a5
    c824:	.word	0x0000c1a5
    c828:	.word	0x0000c1a5
    c82c:	.word	0x0000c955
    c830:	.word	0x0000c1a5
    c834:	.word	0x0000c1a5
    c838:	.word	0x0000c1a5
    c83c:	.word	0x0000c1a5
    c840:	.word	0x0000c1a5
    c844:	.word	0x0000c1a5
    c848:	.word	0x0000c1a5
    c84c:	.word	0x0000c1a5
    c850:	.word	0x0000c1a5
    c854:	.word	0x0000c1a5
    c858:	.word	0x0000c1a5
    c85c:	.word	0x0000c1a5
    c860:	.word	0x0000c1a5
    c864:	.word	0x0000c1a5
    c868:	.word	0x0000c1a5
    c86c:	.word	0x0000c1a5
    c870:	.word	0x0000c1a5
    c874:	.word	0x0000c1a5
    c878:	.word	0x0000c1a5
    c87c:	.word	0x0000c1a5
    c880:	.word	0x0000c1a5
    c884:	.word	0x0000c1a5
    c888:	.word	0x0000c1a5
    c88c:	.word	0x0000c1a5
    c890:	.word	0x0000c1a5
    c894:	.word	0x0000c1a5
    c898:	.word	0x0000c37d
    c89c:	.word	0x0000c1a5
    c8a0:	.word	0x0000c1a5
    c8a4:	.word	0x0000c1a5
    c8a8:	.word	0x0000c1a5
    c8ac:	.word	0x0000c955
    c8b0:	cmp.w	r6, #308	; 0x134
    c8b4:	bgt.w	caf6 <_strtod_l+0x9be>
    c8b8:	asrs	r6, r6, #4
    c8ba:	cmp	r6, #1
    c8bc:	ldr.w	r9, [pc, #472]	; ca98 <_strtod_l+0x960>
    c8c0:	ble.w	cef6 <_strtod_l+0xdbe>
    c8c4:	ldrd	r0, r1, [sp, #16]
    c8c8:	movs	r3, #0
    c8ca:	mov	r7, r9
    c8cc:	mov	r8, r3
    c8ce:	tst.w	r6, #1
    c8d2:	add.w	r8, r8, #1
    c8d6:	mov.w	r6, r6, asr #1
    c8da:	beq.n	c8e6 <_strtod_l+0x7ae>
    c8dc:	ldrd	r2, r3, [r7]
    c8e0:	bl	a8b8 <__aeabi_dmul>
    c8e4:	movs	r3, #1
    c8e6:	cmp	r6, #1
    c8e8:	add.w	r7, r7, #8
    c8ec:	bne.n	c8ce <_strtod_l+0x796>
    c8ee:	cmp	r3, #0
    c8f0:	bne.w	cfba <_strtod_l+0xe82>
    c8f4:	ldr	r3, [sp, #20]
    c8f6:	sub.w	r3, r3, #55574528	; 0x3500000
    c8fa:	str	r3, [sp, #20]
    c8fc:	add.w	r8, r9, r8, lsl #3
    c900:	ldrd	r2, r3, [sp, #16]
    c904:	ldrd	r0, r1, [r8]
    c908:	bl	a8b8 <__aeabi_dmul>
    c90c:	bic.w	r3, r1, #2147483648	; 0x80000000
    c910:	lsrs	r3, r3, #20
    c912:	ldr	r2, [pc, #360]	; (ca7c <_strtod_l+0x944>)
    c914:	lsls	r3, r3, #20
    c916:	cmp	r3, r2
    c918:	strd	r0, r1, [sp, #16]
    c91c:	bhi.w	caf6 <_strtod_l+0x9be>
    c920:	sub.w	r2, r2, #1048576	; 0x100000
    c924:	cmp	r3, r2
    c926:	bls.w	ceb8 <_strtod_l+0xd80>
    c92a:	ldr	r3, [pc, #340]	; (ca80 <_strtod_l+0x948>)
    c92c:	str	r3, [sp, #20]
    c92e:	movs	r3, #0
    c930:	str	r3, [sp, #40]	; 0x28
    c932:	mov.w	r3, #4294967295
    c936:	str	r3, [sp, #16]
    c938:	b.n	c494 <_strtod_l+0x35c>
    c93a:	ldrd	r1, r2, [sp, #16]
    c93e:	cmp	r1, #1
    c940:	beq.w	cd22 <_strtod_l+0xbea>
    c944:	mov	r8, r2
    c946:	vldr	d7, [pc, #288]	; ca68 <_strtod_l+0x930>
    c94a:	movs	r4, #0
    c94c:	ldr	r5, [pc, #308]	; (ca84 <_strtod_l+0x94c>)
    c94e:	vstr	d7, [sp, #56]	; 0x38
    c952:	b.n	c660 <_strtod_l+0x528>
    c954:	add	r0, sp, #108	; 0x6c
    c956:	ldr	r1, [pc, #304]	; (ca88 <_strtod_l+0x950>)
    c958:	bl	11018 <__match>
    c95c:	cmp	r0, #0
    c95e:	beq.w	c1a4 <_strtod_l+0x6c>
    c962:	ldr	r3, [sp, #108]	; 0x6c
    c964:	ldrb	r3, [r3, #0]
    c966:	cmp	r3, #40	; 0x28
    c968:	beq.w	cf70 <_strtod_l+0xe38>
    c96c:	ldr	r3, [pc, #284]	; (ca8c <_strtod_l+0x954>)
    c96e:	str	r3, [sp, #20]
    c970:	movs	r3, #0
    c972:	str	r3, [sp, #16]
    c974:	b.n	c3a8 <_strtod_l+0x270>
    c976:	str	r6, [sp, #108]	; 0x6c
    c978:	movs	r2, #0
    c97a:	b.n	c252 <_strtod_l+0x11a>
    c97c:	mov.w	ip, #0
    c980:	b.n	c7f6 <_strtod_l+0x6be>
    c982:	adds	r3, #1
    c984:	bne.w	cf56 <_strtod_l+0xe1e>
    c988:	ldr	r0, [sp, #112]	; 0x70
    c98a:	ldr	r3, [pc, #260]	; (ca90 <_strtod_l+0x958>)
    c98c:	str	r3, [sp, #20]
    c98e:	movs	r2, #0
    c990:	str	r2, [sp, #16]
    c992:	ldrd	r8, r9, [sp, #16]
    c996:	movs	r3, #34	; 0x22
    c998:	str.w	r3, [fp]
    c99c:	mov	r1, r0
    c99e:	mov	r0, fp
    c9a0:	bl	112ac <_Bfree>
    c9a4:	mov	r1, r6
    c9a6:	mov	r0, fp
    c9a8:	bl	112ac <_Bfree>
    c9ac:	mov	r1, sl
    c9ae:	mov	r0, fp
    c9b0:	bl	112ac <_Bfree>
    c9b4:	ldr	r1, [sp, #72]	; 0x48
    c9b6:	mov	r0, fp
    c9b8:	bl	112ac <_Bfree>
    c9bc:	mov	r1, r7
    c9be:	mov	r0, fp
    c9c0:	bl	112ac <_Bfree>
    c9c4:	b.n	c268 <_strtod_l+0x130>
    c9c6:	ldr	r2, [sp, #28]
    c9c8:	str	r5, [sp, #8]
    c9ca:	add	r3, sp, #112	; 0x70
    c9cc:	str	r2, [sp, #4]
    c9ce:	str	r3, [sp, #0]
    c9d0:	ldr	r2, [pc, #192]	; (ca94 <_strtod_l+0x95c>)
    c9d2:	add	r3, sp, #116	; 0x74
    c9d4:	add	r1, sp, #108	; 0x6c
    c9d6:	mov	r0, fp
    c9d8:	bl	10b08 <__gethex>
    c9dc:	ands.w	r6, r0, #7
    c9e0:	mov	r5, r0
    c9e2:	beq.w	c260 <_strtod_l+0x128>
    c9e6:	cmp	r6, #6
    c9e8:	bne.w	cc98 <_strtod_l+0xb60>
    c9ec:	adds	r4, #1
    c9ee:	movs	r3, #0
    c9f0:	str	r4, [sp, #108]	; 0x6c
    c9f2:	mov.w	r8, #0
    c9f6:	mov.w	r9, #0
    c9fa:	str	r3, [sp, #28]
    c9fc:	b.n	c268 <_strtod_l+0x130>
    c9fe:	ldr.w	r1, [sl]
    ca02:	mov	r0, r4
    ca04:	mov	r2, r9
    ca06:	bl	c05c <strncmp>
    ca0a:	cbz	r0, ca20 <_strtod_l+0x8e8>
    ca0c:	mov.w	sl, #0
    ca10:	mov	r3, r7
    ca12:	mov	r8, sl
    ca14:	mov	r5, sl
    ca16:	mov	r0, sl
    ca18:	mov	r7, sl
    ca1a:	mov	r4, sl
    ca1c:	mov	r9, sl
    ca1e:	b.n	c244 <_strtod_l+0x10c>
    ca20:	ldr	r3, [sp, #108]	; 0x6c
    ca22:	add.w	r2, r3, r9
    ca26:	str	r2, [sp, #108]	; 0x6c
    ca28:	ldrb.w	r3, [r3, r9]
    ca2c:	cmp	r3, #48	; 0x30
    ca2e:	bne.n	ca3e <_strtod_l+0x906>
    ca30:	adds	r2, #1
    ca32:	str	r2, [sp, #108]	; 0x6c
    ca34:	ldrb	r3, [r2, #0]
    ca36:	cmp	r3, #48	; 0x30
    ca38:	add.w	r0, r0, #1
    ca3c:	beq.n	ca30 <_strtod_l+0x8f8>
    ca3e:	sub.w	r2, r3, #49	; 0x31
    ca42:	cmp	r2, #8
    ca44:	bls.w	cd40 <_strtod_l+0xc08>
    ca48:	mov.w	sl, #0
    ca4c:	cmp	r3, #101	; 0x65
    ca4e:	mov	r8, sl
    ca50:	mov	r5, sl
    ca52:	mov	r7, sl
    ca54:	beq.w	c744 <_strtod_l+0x60c>
    ca58:	mov	r4, sl
    ca5a:	mov.w	r9, #1
    ca5e:	b.w	c24a <_strtod_l+0x112>
    ca62:	nop
    ca64:	nop.w
    ca68:	.word	0x00000000
    ca6c:	.word	0x3ff00000
    ca70:	.word	0xfffffbe2
    ca74:	.word	0x3ff00000
    ca78:	.word	0x3fe00000
    ca7c:	.word	0x7ca00000
    ca80:	.word	0x7fefffff
    ca84:	.word	0xbff00000
    ca88:	.word	0x00013140
    ca8c:	.word	0xfff80000
    ca90:	.word	0x7ff00000
    ca94:	.word	0x00013120
    ca98:	.word	0x000134f0
    ca9c:	sub.w	r3, r8, #55574528	; 0x3500000
    caa0:	str	r3, [sp, #20]
    caa2:	vldr	d7, [sp, #16]
    caa6:	vmov.f32	s0, s14
    caaa:	vmov.f32	s1, s15
    caae:	bl	11860 <__ulp>
    cab2:	mov	r0, r4
    cab4:	vmov	r2, r3, d0
    cab8:	mov	r1, r5
    caba:	bl	a8b8 <__aeabi_dmul>
    cabe:	ldrd	r2, r3, [sp, #16]
    cac2:	bl	a554 <__adddf3>
    cac6:	bic.w	r3, r1, #2147483648	; 0x80000000
    caca:	strd	r0, r1, [sp, #16]
    cace:	lsrs	r3, r3, #20
    cad0:	ldr	r2, [pc, #684]	; (cd80 <_strtod_l+0xc48>)
    cad2:	ldrd	r0, r1, [sp, #32]
    cad6:	lsls	r3, r3, #20
    cad8:	cmp	r3, r2
    cada:	strd	r0, r1, [sp, #88]	; 0x58
    cade:	bls.w	cc56 <_strtod_l+0xb1e>
    cae2:	ldr	r3, [pc, #672]	; (cd84 <_strtod_l+0xc4c>)
    cae4:	cmp	r1, r3
    cae6:	beq.w	ceae <_strtod_l+0xd76>
    caea:	ldr	r3, [pc, #664]	; (cd84 <_strtod_l+0xc4c>)
    caec:	str	r3, [sp, #20]
    caee:	mov.w	r3, #4294967295
    caf2:	str	r3, [sp, #16]
    caf4:	b.n	c6f0 <_strtod_l+0x5b8>
    caf6:	ldr	r3, [pc, #656]	; (cd88 <_strtod_l+0xc50>)
    caf8:	str	r3, [sp, #20]
    cafa:	movs	r2, #0
    cafc:	movs	r3, #34	; 0x22
    cafe:	str	r2, [sp, #16]
    cb00:	ldrd	r8, r9, [sp, #16]
    cb04:	str.w	r3, [fp]
    cb08:	b.w	c268 <_strtod_l+0x130>
    cb0c:	ldrd	r8, r9, [sp, #56]	; 0x38
    cb10:	mov	r1, r9
    cb12:	mov	r0, r8
    cb14:	bl	ae18 <__aeabi_d2iz>
    cb18:	bl	a7ec <__aeabi_i2d>
    cb1c:	mov	r3, r1
    cb1e:	mov	r2, r0
    cb20:	mov	r1, r9
    cb22:	mov	r0, r8
    cb24:	bl	a550 <__aeabi_dsub>
    cb28:	ldr	r3, [sp, #52]	; 0x34
    cb2a:	mov	r8, r0
    cb2c:	mov	r9, r1
    cb2e:	cbnz	r3, cb52 <_strtod_l+0xa1a>
    cb30:	ldr	r3, [sp, #16]
    cb32:	cbnz	r3, cb52 <_strtod_l+0xa1a>
    cb34:	ubfx	r4, r4, #0, #20
    cb38:	cbnz	r4, cb52 <_strtod_l+0xa1a>
    cb3a:	add	r3, pc, #548	; (adr r3, cd60 <_strtod_l+0xc28>)
    cb3c:	ldrd	r2, r3, [r3]
    cb40:	bl	ad9c <__aeabi_dcmplt>
    cb44:	cmp	r0, #0
    cb46:	beq.w	c6f0 <_strtod_l+0x5b8>
    cb4a:	ldrd	r8, r9, [sp, #16]
    cb4e:	ldr	r0, [sp, #112]	; 0x70
    cb50:	b.n	c99c <_strtod_l+0x864>
    cb52:	add	r3, pc, #532	; (adr r3, cd68 <_strtod_l+0xc30>)
    cb54:	ldrd	r2, r3, [r3]
    cb58:	mov	r0, r8
    cb5a:	mov	r1, r9
    cb5c:	bl	ad9c <__aeabi_dcmplt>
    cb60:	cmp	r0, #0
    cb62:	bne.n	cb4a <_strtod_l+0xa12>
    cb64:	mov	r0, r8
    cb66:	mov	r1, r9
    cb68:	add	r3, pc, #516	; (adr r3, cd70 <_strtod_l+0xc38>)
    cb6a:	ldrd	r2, r3, [r3]
    cb6e:	bl	add8 <__aeabi_dcmpgt>
    cb72:	cmp	r0, #0
    cb74:	beq.w	c6f0 <_strtod_l+0x5b8>
    cb78:	b.n	cb4a <_strtod_l+0xa12>
    cb7a:	beq.w	c490 <_strtod_l+0x358>
    cb7e:	rsb	r6, r9, #0
    cb82:	ands.w	r2, r6, #15
    cb86:	beq.n	cb9e <_strtod_l+0xa66>
    cb88:	ldr	r3, [pc, #512]	; (cd8c <_strtod_l+0xc54>)
    cb8a:	add.w	r3, r3, r2, lsl #3
    cb8e:	ldrd	r0, r1, [sp, #16]
    cb92:	ldrd	r2, r3, [r3]
    cb96:	bl	ab0c <__aeabi_ddiv>
    cb9a:	strd	r0, r1, [sp, #16]
    cb9e:	asrs	r6, r6, #4
    cba0:	beq.w	c490 <_strtod_l+0x358>
    cba4:	cmp	r6, #31
    cba6:	bgt.n	cc1a <_strtod_l+0xae2>
    cba8:	ands.w	r3, r6, #16
    cbac:	beq.w	cf20 <_strtod_l+0xde8>
    cbb0:	movs	r3, #106	; 0x6a
    cbb2:	cmp	r6, #0
    cbb4:	str	r3, [sp, #40]	; 0x28
    cbb6:	ble.n	cbe0 <_strtod_l+0xaa8>
    cbb8:	ldrd	r0, r1, [sp, #16]
    cbbc:	ldr	r7, [pc, #464]	; (cd90 <_strtod_l+0xc58>)
    cbbe:	movs	r3, #0
    cbc0:	lsls	r2, r6, #31
    cbc2:	bpl.n	cbce <_strtod_l+0xa96>
    cbc4:	ldrd	r2, r3, [r7]
    cbc8:	bl	a8b8 <__aeabi_dmul>
    cbcc:	movs	r3, #1
    cbce:	asrs	r6, r6, #1
    cbd0:	add.w	r7, r7, #8
    cbd4:	bne.n	cbc0 <_strtod_l+0xa88>
    cbd6:	cmp	r3, #0
    cbd8:	bne.w	cfc0 <_strtod_l+0xe88>
    cbdc:	ldr	r3, [sp, #40]	; 0x28
    cbde:	cbz	r3, cc08 <_strtod_l+0xad0>
    cbe0:	ldrd	r1, r2, [sp, #16]
    cbe4:	ubfx	r3, r2, #20, #11
    cbe8:	rsb	r3, r3, #107	; 0x6b
    cbec:	cmp	r3, #0
    cbee:	mov	r1, r2
    cbf0:	ble.n	cc08 <_strtod_l+0xad0>
    cbf2:	cmp	r3, #31
    cbf4:	ble.w	cfaa <_strtod_l+0xe72>
    cbf8:	movs	r2, #0
    cbfa:	cmp	r3, #52	; 0x34
    cbfc:	str	r2, [sp, #16]
    cbfe:	ble.w	cfc6 <_strtod_l+0xe8e>
    cc02:	mov.w	r3, #57671680	; 0x3700000
    cc06:	str	r3, [sp, #20]
    cc08:	movs	r2, #0
    cc0a:	movs	r3, #0
    cc0c:	ldrd	r0, r1, [sp, #16]
    cc10:	bl	ad88 <__aeabi_dcmpeq>
    cc14:	cmp	r0, #0
    cc16:	beq.w	c494 <_strtod_l+0x35c>
    cc1a:	movs	r3, #34	; 0x22
    cc1c:	str.w	r3, [fp]
    cc20:	mov.w	r8, #0
    cc24:	mov.w	r9, #0
    cc28:	b.w	c268 <_strtod_l+0x130>
    cc2c:	ldr	r1, [sp, #108]	; 0x6c
    cc2e:	adds	r4, #1
    cc30:	cmp	r0, #8
    cc32:	ble.w	cd52 <_strtod_l+0xc1a>
    cc36:	cmp	r4, #16
    cc38:	itt	le
    cc3a:	addle.w	r8, r8, r8, lsl #2
    cc3e:	addle.w	r8, r2, r8, lsl #1
    cc42:	movs	r0, #0
    cc44:	adds	r3, r1, #1
    cc46:	str	r3, [sp, #108]	; 0x6c
    cc48:	ldrb	r3, [r1, #1]
    cc4a:	b.w	c28c <_strtod_l+0x154>
    cc4e:	movw	r2, #19999	; 0x4e1f
    cc52:	b.w	c43e <_strtod_l+0x306>
    cc56:	ldr	r3, [sp, #20]
    cc58:	add.w	r4, r3, #55574528	; 0x3500000
    cc5c:	str	r4, [sp, #20]
    cc5e:	b.n	c6e2 <_strtod_l+0x5aa>
    cc60:	ldr	r6, [sp, #44]	; 0x2c
    cc62:	rsb	r3, r4, #37	; 0x25
    cc66:	cmp	r6, r3
    cc68:	bgt.w	c45c <_strtod_l+0x324>
    cc6c:	ldr	r5, [pc, #284]	; (cd8c <_strtod_l+0xc54>)
    cc6e:	rsb	r4, r4, #15
    cc72:	add.w	r1, r5, r4, lsl #3
    cc76:	subs	r4, r6, r4
    cc78:	ldrd	r2, r3, [sp, #16]
    cc7c:	ldrd	r0, r1, [r1]
    cc80:	add.w	r5, r5, r4, lsl #3
    cc84:	bl	a8b8 <__aeabi_dmul>
    cc88:	ldrd	r2, r3, [r5]
    cc8c:	bl	a8b8 <__aeabi_dmul>
    cc90:	mov	r8, r0
    cc92:	mov	r9, r1
    cc94:	b.w	c268 <_strtod_l+0x130>
    cc98:	ldr	r2, [sp, #112]	; 0x70
    cc9a:	cbz	r2, ccac <_strtod_l+0xb74>
    cc9c:	movs	r1, #53	; 0x35
    cc9e:	add	r0, sp, #120	; 0x78
    cca0:	bl	11aa0 <__copybits>
    cca4:	mov	r0, fp
    cca6:	ldr	r1, [sp, #112]	; 0x70
    cca8:	bl	112ac <_Bfree>
    ccac:	cmp	r6, #6
    ccae:	bhi.n	ccc8 <_strtod_l+0xb90>
    ccb0:	tbb	[pc, r6]
    ccb4:	.word	0x1318211d
    ccb8:	.short	0x2104
    ccba:	.byte	0x1d
    ccbb:	.byte	0x00
    ccbc:	mvn.w	r3, #2147483648	; 0x80000000
    ccc0:	str	r3, [sp, #20]
    ccc2:	mov.w	r3, #4294967295
    ccc6:	str	r3, [sp, #16]
    ccc8:	lsls	r1, r5, #28
    ccca:	bpl.w	c3a8 <_strtod_l+0x270>
    ccce:	ldr	r3, [sp, #20]
    ccd0:	orr.w	r3, r3, #2147483648	; 0x80000000
    ccd4:	str	r3, [sp, #20]
    ccd6:	b.w	c3a8 <_strtod_l+0x270>
    ccda:	ldr	r3, [pc, #172]	; (cd88 <_strtod_l+0xc50>)
    ccdc:	str	r3, [sp, #20]
    ccde:	movs	r3, #0
    cce0:	str	r3, [sp, #16]
    cce2:	b.n	ccc8 <_strtod_l+0xb90>
    cce4:	ldr	r3, [sp, #120]	; 0x78
    cce6:	str	r3, [sp, #16]
    cce8:	ldr	r3, [sp, #124]	; 0x7c
    ccea:	str	r3, [sp, #20]
    ccec:	b.n	ccc8 <_strtod_l+0xb90>
    ccee:	movs	r3, #0
    ccf0:	str	r3, [sp, #20]
    ccf2:	str	r3, [sp, #16]
    ccf4:	b.n	ccc8 <_strtod_l+0xb90>
    ccf6:	ldr	r2, [sp, #116]	; 0x74
    ccf8:	ldr	r3, [sp, #124]	; 0x7c
    ccfa:	ldr	r1, [sp, #120]	; 0x78
    ccfc:	str	r1, [sp, #16]
    ccfe:	addw	r2, r2, #1075	; 0x433
    cd02:	bic.w	r3, r3, #1048576	; 0x100000
    cd06:	orr.w	r3, r3, r2, lsl #20
    cd0a:	str	r3, [sp, #20]
    cd0c:	b.n	ccc8 <_strtod_l+0xb90>
    cd0e:	vldr	d7, [sp, #56]	; 0x38
    cd12:	vstr	d7, [sp, #80]	; 0x50
    cd16:	b.n	c6b4 <_strtod_l+0x57c>
    cd18:	vldr	d7, [pc, #92]	; cd78 <_strtod_l+0xc40>
    cd1c:	vstr	d7, [sp, #56]	; 0x38
    cd20:	b.n	c6a0 <_strtod_l+0x568>
    cd22:	ldrd	r1, r2, [sp, #16]
    cd26:	mov	r8, r2
    cd28:	cmp	r2, #0
    cd2a:	bne.w	c946 <_strtod_l+0x80e>
    cd2e:	movs	r3, #34	; 0x22
    cd30:	str.w	r3, [fp]
    cd34:	ldr	r0, [sp, #112]	; 0x70
    cd36:	mov.w	r8, #0
    cd3a:	mov.w	r9, #0
    cd3e:	b.n	c99c <_strtod_l+0x864>
    cd40:	ldr	r2, [sp, #108]	; 0x6c
    cd42:	str	r2, [sp, #32]
    cd44:	movs	r5, #0
    cd46:	subs	r3, #48	; 0x30
    cd48:	adds	r7, r0, #1
    cd4a:	mov	r1, r2
    cd4c:	mov	sl, r5
    cd4e:	mov	r8, r5
    cd50:	movs	r4, #1
    cd52:	add.w	r5, r5, r5, lsl #2
    cd56:	add.w	r5, r3, r5, lsl #1
    cd5a:	movs	r0, #0
    cd5c:	b.n	cc44 <_strtod_l+0xb0c>
    cd5e:	nop
    cd60:	.word	0x94a03595
    cd64:	.word	0x3fcfffff
    cd68:	.word	0x94a03595
    cd6c:	.word	0x3fdfffff
    cd70:	.word	0x35afe535
    cd74:	.word	0x3fe00000
    cd78:	.word	0x00000000
    cd7c:	.word	0x3ff00000
    cd80:	.word	0x7c9fffff
    cd84:	.word	0x7fefffff
    cd88:	.word	0x7ff00000
    cd8c:	.word	0x00013428
    cd90:	.word	0x00013158
    cd94:	ldr	r1, [sp, #44]	; 0x2c
    cd96:	cmn.w	r1, #22
    cd9a:	blt.w	c45c <_strtod_l+0x324>
    cd9e:	ldr	r2, [pc, #600]	; (cff8 <_strtod_l+0xec0>)
    cda0:	sub.w	r2, r2, r1, lsl #3
    cda4:	ldrd	r2, r3, [r2]
    cda8:	ldrd	r0, r1, [sp, #16]
    cdac:	bl	ab0c <__aeabi_ddiv>
    cdb0:	mov	r8, r0
    cdb2:	mov	r9, r1
    cdb4:	b.w	c268 <_strtod_l+0x130>
    cdb8:	ldr	r3, [sp, #52]	; 0x34
    cdba:	ldrd	r8, r9, [sp, #32]
    cdbe:	cmp	r3, #0
    cdc0:	beq.w	ced4 <_strtod_l+0xd9c>
    cdc4:	ldrd	r4, r5, [sp, #16]
    cdc8:	ldr	r3, [pc, #560]	; (cffc <_strtod_l+0xec4>)
    cdca:	ubfx	r1, r5, #0, #20
    cdce:	cmp	r1, r3
    cdd0:	mov	r2, r5
    cdd2:	beq.w	cf2a <_strtod_l+0xdf2>
    cdd6:	ldr	r3, [sp, #76]	; 0x4c
    cdd8:	cmp	r3, #0
    cdda:	beq.w	ceec <_strtod_l+0xdb4>
    cdde:	ldr	r2, [sp, #20]
    cde0:	tst	r3, r2
    cde2:	beq.n	ce06 <_strtod_l+0xcce>
    cde4:	ldr	r3, [sp, #52]	; 0x34
    cde6:	ldr	r2, [sp, #40]	; 0x28
    cde8:	ldrd	r0, r1, [sp, #16]
    cdec:	cmp	r3, #0
    cdee:	beq.w	cefc <_strtod_l+0xdc4>
    cdf2:	bl	c0fc <sulp>
    cdf6:	mov	r2, r0
    cdf8:	mov	r3, r1
    cdfa:	mov	r0, r8
    cdfc:	mov	r1, r9
    cdfe:	bl	a554 <__adddf3>
    ce02:	mov	r8, r0
    ce04:	mov	r9, r1
    ce06:	ldr	r3, [sp, #40]	; 0x28
    ce08:	cbz	r3, ce3a <_strtod_l+0xd02>
    ce0a:	ldr	r3, [pc, #500]	; (d000 <_strtod_l+0xec8>)
    ce0c:	str	r3, [sp, #92]	; 0x5c
    ce0e:	movs	r3, #0
    ce10:	str	r3, [sp, #88]	; 0x58
    ce12:	ldrd	r2, r3, [sp, #88]	; 0x58
    ce16:	mov	r0, r8
    ce18:	mov	r1, r9
    ce1a:	bl	a8b8 <__aeabi_dmul>
    ce1e:	mov	r3, r0
    ce20:	mov	r4, r1
    ce22:	mov	r8, r0
    ce24:	mov	r9, r1
    ce26:	strd	r3, r4, [sp, #16]
    ce2a:	cbnz	r1, ce3a <_strtod_l+0xd02>
    ce2c:	ldr	r3, [sp, #16]
    ce2e:	cbnz	r3, ce3a <_strtod_l+0xd02>
    ce30:	movs	r3, #34	; 0x22
    ce32:	ldr	r0, [sp, #112]	; 0x70
    ce34:	str.w	r3, [fp]
    ce38:	b.n	c99c <_strtod_l+0x864>
    ce3a:	ldr	r0, [sp, #112]	; 0x70
    ce3c:	b.n	c99c <_strtod_l+0x864>
    ce3e:	ldr	r3, [sp, #52]	; 0x34
    ce40:	ldrd	r8, r9, [sp, #32]
    ce44:	cmp	r3, #0
    ce46:	bne.n	ce06 <_strtod_l+0xcce>
    ce48:	ldrd	r1, r2, [sp, #16]
    ce4c:	cmp	r1, #0
    ce4e:	bne.n	ce06 <_strtod_l+0xcce>
    ce50:	ubfx	r3, r2, #0, #20
    ce54:	mov	r4, r2
    ce56:	cmp	r3, #0
    ce58:	bne.n	ce06 <_strtod_l+0xcce>
    ce5a:	bic.w	r3, r2, #2147483648	; 0x80000000
    ce5e:	lsrs	r3, r3, #20
    ce60:	lsls	r3, r3, #20
    ce62:	cmp.w	r3, #112197632	; 0x6b00000
    ce66:	bls.n	ce06 <_strtod_l+0xcce>
    ce68:	ldr	r3, [r7, #20]
    ce6a:	cbnz	r3, ce72 <_strtod_l+0xd3a>
    ce6c:	ldr	r3, [r7, #16]
    ce6e:	cmp	r3, #1
    ce70:	ble.n	ce06 <_strtod_l+0xcce>
    ce72:	mov	r1, r7
    ce74:	movs	r2, #1
    ce76:	mov	r0, fp
    ce78:	bl	11658 <__lshift>
    ce7c:	mov	r1, sl
    ce7e:	mov	r7, r0
    ce80:	bl	11708 <__mcmp>
    ce84:	cmp	r0, #0
    ce86:	ble.n	ce06 <_strtod_l+0xcce>
    ce88:	ldr	r3, [sp, #40]	; 0x28
    ce8a:	cmp	r3, #0
    ce8c:	bne.w	cf94 <_strtod_l+0xe5c>
    ce90:	ldr	r3, [pc, #368]	; (d004 <_strtod_l+0xecc>)
    ce92:	ands	r3, r4
    ce94:	sub.w	r3, r3, #1048576	; 0x100000
    ce98:	mvn.w	r3, r3, lsr #20
    ce9c:	mvn.w	r3, r3, lsl #20
    cea0:	str	r3, [sp, #20]
    cea2:	mov.w	r3, #4294967295
    cea6:	str	r3, [sp, #16]
    cea8:	ldrd	r8, r9, [sp, #16]
    ceac:	b.n	ce06 <_strtod_l+0xcce>
    ceae:	ldr	r3, [sp, #88]	; 0x58
    ceb0:	adds	r3, #1
    ceb2:	bne.w	caea <_strtod_l+0x9b2>
    ceb6:	b.n	c988 <_strtod_l+0x850>
    ceb8:	add.w	r3, r1, #55574528	; 0x3500000
    cebc:	str	r3, [sp, #20]
    cebe:	b.w	c490 <_strtod_l+0x358>
    cec2:	vldr	d7, [pc, #292]	; cfe8 <_strtod_l+0xeb0>
    cec6:	vstr	d7, [sp, #96]	; 0x60
    ceca:	vldr	d7, [pc, #292]	; cff0 <_strtod_l+0xeb8>
    cece:	vstr	d7, [sp, #56]	; 0x38
    ced2:	b.n	c7e2 <_strtod_l+0x6aa>
    ced4:	ldrd	r1, r2, [sp, #16]
    ced8:	ubfx	r3, r2, #0, #20
    cedc:	mov	r4, r2
    cede:	cmp	r3, #0
    cee0:	bne.w	cdd6 <_strtod_l+0xc9e>
    cee4:	cmp	r1, #0
    cee6:	bne.w	cdd6 <_strtod_l+0xc9e>
    ceea:	b.n	ce88 <_strtod_l+0xd50>
    ceec:	ldr	r3, [sp, #56]	; 0x38
    ceee:	ldr	r2, [sp, #16]
    cef0:	tst	r3, r2
    cef2:	beq.n	ce06 <_strtod_l+0xcce>
    cef4:	b.n	cde4 <_strtod_l+0xcac>
    cef6:	mov.w	r8, #0
    cefa:	b.n	c8f4 <_strtod_l+0x7bc>
    cefc:	bl	c0fc <sulp>
    cf00:	mov	r2, r0
    cf02:	mov	r3, r1
    cf04:	mov	r0, r8
    cf06:	mov	r1, r9
    cf08:	bl	a550 <__aeabi_dsub>
    cf0c:	movs	r2, #0
    cf0e:	movs	r3, #0
    cf10:	mov	r8, r0
    cf12:	mov	r9, r1
    cf14:	bl	ad88 <__aeabi_dcmpeq>
    cf18:	cmp	r0, #0
    cf1a:	bne.w	cd2e <_strtod_l+0xbf6>
    cf1e:	b.n	ce06 <_strtod_l+0xcce>
    cf20:	cmp	r6, #0
    cf22:	str	r3, [sp, #40]	; 0x28
    cf24:	bgt.w	cbb8 <_strtod_l+0xa80>
    cf28:	b.n	cc08 <_strtod_l+0xad0>
    cf2a:	ldr	r3, [sp, #40]	; 0x28
    cf2c:	ldr	r1, [sp, #16]
    cf2e:	cbz	r3, cf6a <_strtod_l+0xe32>
    cf30:	ldr	r3, [pc, #208]	; (d004 <_strtod_l+0xecc>)
    cf32:	ands	r3, r5
    cf34:	cmp.w	r3, #111149056	; 0x6a00000
    cf38:	bhi.n	cf6a <_strtod_l+0xe32>
    cf3a:	lsrs	r3, r3, #20
    cf3c:	rsb	r3, r3, #107	; 0x6b
    cf40:	mov.w	r0, #4294967295
    cf44:	lsl.w	r3, r0, r3
    cf48:	cmp	r3, r1
    cf4a:	bne.w	cdd6 <_strtod_l+0xc9e>
    cf4e:	ldr	r1, [pc, #184]	; (d008 <_strtod_l+0xed0>)
    cf50:	cmp	r2, r1
    cf52:	beq.w	c982 <_strtod_l+0x84a>
    cf56:	ldr	r3, [pc, #172]	; (d004 <_strtod_l+0xecc>)
    cf58:	ands	r3, r2
    cf5a:	add.w	r3, r3, #1048576	; 0x100000
    cf5e:	str	r3, [sp, #20]
    cf60:	movs	r3, #0
    cf62:	str	r3, [sp, #16]
    cf64:	ldrd	r8, r9, [sp, #16]
    cf68:	b.n	ce06 <_strtod_l+0xcce>
    cf6a:	mov.w	r3, #4294967295
    cf6e:	b.n	cf48 <_strtod_l+0xe10>
    cf70:	add	r0, sp, #108	; 0x6c
    cf72:	add	r2, sp, #120	; 0x78
    cf74:	ldr	r1, [pc, #148]	; (d00c <_strtod_l+0xed4>)
    cf76:	bl	11048 <__hexnan>
    cf7a:	cmp	r0, #5
    cf7c:	bne.w	c96c <_strtod_l+0x834>
    cf80:	ldr	r3, [sp, #124]	; 0x7c
    cf82:	orr.w	r3, r3, #2139095040	; 0x7f800000
    cf86:	orr.w	r3, r3, #7340032	; 0x700000
    cf8a:	str	r3, [sp, #20]
    cf8c:	ldr	r3, [sp, #120]	; 0x78
    cf8e:	str	r3, [sp, #16]
    cf90:	b.w	c3a8 <_strtod_l+0x270>
    cf94:	ldr	r3, [pc, #108]	; (d004 <_strtod_l+0xecc>)
    cf96:	ands	r3, r4
    cf98:	cmp.w	r3, #112197632	; 0x6b00000
    cf9c:	bgt.w	ce94 <_strtod_l+0xd5c>
    cfa0:	cmp.w	r3, #57671680	; 0x3700000
    cfa4:	bgt.w	ce0a <_strtod_l+0xcd2>
    cfa8:	b.n	cd2e <_strtod_l+0xbf6>
    cfaa:	mov.w	r2, #4294967295
    cfae:	lsl.w	r3, r2, r3
    cfb2:	ldr	r2, [sp, #16]
    cfb4:	ands	r2, r3
    cfb6:	str	r2, [sp, #16]
    cfb8:	b.n	cc08 <_strtod_l+0xad0>
    cfba:	strd	r0, r1, [sp, #16]
    cfbe:	b.n	c8f4 <_strtod_l+0x7bc>
    cfc0:	strd	r0, r1, [sp, #16]
    cfc4:	b.n	cbdc <_strtod_l+0xaa4>
    cfc6:	subs	r3, #32
    cfc8:	mov.w	r2, #4294967295
    cfcc:	lsl.w	r3, r2, r3
    cfd0:	ands	r3, r1
    cfd2:	str	r3, [sp, #20]
    cfd4:	b.n	cc08 <_strtod_l+0xad0>
    cfd6:	mov	r0, r4
    cfd8:	ldr	r1, [sp, #108]	; 0x6c
    cfda:	adds	r4, #1
    cfdc:	b.n	cc30 <_strtod_l+0xaf8>
    cfde:	mov	r0, r1
    cfe0:	ldr	r1, [sp, #108]	; 0x6c
    cfe2:	b.n	cc44 <_strtod_l+0xb0c>
    cfe4:	nop.w
    cfe8:	.word	0x00000000
    cfec:	.word	0xbfe00000
    cff0:	.word	0x00000000
    cff4:	.word	0x3fe00000
    cff8:	.word	0x00013428
    cffc:	.word	0x000fffff
    d000:	.word	0x39500000
    d004:	.word	0x7ff00000
    d008:	.word	0x7fefffff
    d00c:	.word	0x00013144

0000d010 <_strtod_r>:
    d010:	ldr	r3, [pc, #20]	; (d028 <_strtod_r+0x18>)
    d012:	ldr	r3, [r3, #0]
    d014:	push	{r4}
    d016:	ldr	r3, [r3, #52]	; 0x34
    d018:	ldr	r4, [pc, #16]	; (d02c <_strtod_r+0x1c>)
    d01a:	cmp	r3, #0
    d01c:	it	eq
    d01e:	moveq	r3, r4
    d020:	ldr.w	r4, [sp], #4
    d024:	b.w	c138 <_strtod_l>
    d028:	.word	0x1fff1828
    d02c:	.word	0x1fff182c

0000d030 <_strtol_l.isra.0>:
    d030:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d034:	ldr.w	r9, [sp, #40]	; 0x28
    d038:	mov	r7, r1
    d03a:	mov	r8, r0
    d03c:	mov	r6, r2
    d03e:	mov	r5, r3
    d040:	mov	fp, r1
    d042:	b.n	d046 <_strtol_l.isra.0+0x16>
    d044:	mov	fp, r4
    d046:	mov	r4, fp
    d048:	mov	r0, r9
    d04a:	ldrb.w	sl, [r4], #1
    d04e:	bl	b2fc <__locale_ctype_ptr_l>
    d052:	add	r0, sl
    d054:	ldrb	r1, [r0, #1]
    d056:	and.w	r1, r1, #8
    d05a:	and.w	ip, r1, #255	; 0xff
    d05e:	cmp	r1, #0
    d060:	bne.n	d044 <_strtol_l.isra.0+0x14>
    d062:	mov	r2, sl
    d064:	cmp	r2, #45	; 0x2d
    d066:	beq.n	d12c <_strtol_l.isra.0+0xfc>
    d068:	cmp	r2, #43	; 0x2b
    d06a:	itt	eq
    d06c:	ldrbeq.w	r2, [fp, #1]
    d070:	addeq.w	r4, fp, #2
    d074:	cmp	r5, #0
    d076:	beq.n	d100 <_strtol_l.isra.0+0xd0>
    d078:	cmp	r5, #16
    d07a:	beq.n	d148 <_strtol_l.isra.0+0x118>
    d07c:	mov	r9, r5
    d07e:	cmp.w	ip, #0
    d082:	ite	eq
    d084:	mvneq.w	sl, #2147483648	; 0x80000000
    d088:	movne.w	sl, #2147483648	; 0x80000000
    d08c:	movs	r1, #0
    d08e:	udiv	lr, sl, r9
    d092:	mov	r0, r1
    d094:	mls	sl, r9, lr, sl
    d098:	b.n	d0a6 <_strtol_l.isra.0+0x76>
    d09a:	beq.n	d0f0 <_strtol_l.isra.0+0xc0>
    d09c:	mla	r0, r9, r0, r3
    d0a0:	movs	r1, #1
    d0a2:	ldrb.w	r2, [r4], #1
    d0a6:	sub.w	r3, r2, #48	; 0x30
    d0aa:	cmp	r3, #9
    d0ac:	bls.n	d0ba <_strtol_l.isra.0+0x8a>
    d0ae:	sub.w	r3, r2, #65	; 0x41
    d0b2:	cmp	r3, #25
    d0b4:	bhi.n	d0cc <_strtol_l.isra.0+0x9c>
    d0b6:	sub.w	r3, r2, #55	; 0x37
    d0ba:	cmp	r5, r3
    d0bc:	ble.n	d0dc <_strtol_l.isra.0+0xac>
    d0be:	adds	r2, r1, #1
    d0c0:	beq.n	d0a2 <_strtol_l.isra.0+0x72>
    d0c2:	cmp	lr, r0
    d0c4:	bcs.n	d09a <_strtol_l.isra.0+0x6a>
    d0c6:	mov.w	r1, #4294967295
    d0ca:	b.n	d0a2 <_strtol_l.isra.0+0x72>
    d0cc:	sub.w	r3, r2, #97	; 0x61
    d0d0:	cmp	r3, #25
    d0d2:	bhi.n	d0dc <_strtol_l.isra.0+0xac>
    d0d4:	sub.w	r3, r2, #87	; 0x57
    d0d8:	cmp	r5, r3
    d0da:	bgt.n	d0be <_strtol_l.isra.0+0x8e>
    d0dc:	adds	r3, r1, #1
    d0de:	beq.n	d10c <_strtol_l.isra.0+0xdc>
    d0e0:	cmp.w	ip, #0
    d0e4:	bne.n	d108 <_strtol_l.isra.0+0xd8>
    d0e6:	cbz	r6, d0fc <_strtol_l.isra.0+0xcc>
    d0e8:	cbnz	r1, d124 <_strtol_l.isra.0+0xf4>
    d0ea:	str	r7, [r6, #0]
    d0ec:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d0f0:	cmp	sl, r3
    d0f2:	bge.n	d09c <_strtol_l.isra.0+0x6c>
    d0f4:	mov	r0, lr
    d0f6:	mov.w	r1, #4294967295
    d0fa:	b.n	d0a2 <_strtol_l.isra.0+0x72>
    d0fc:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d100:	cmp	r2, #48	; 0x30
    d102:	beq.n	d13a <_strtol_l.isra.0+0x10a>
    d104:	movs	r5, #10
    d106:	b.n	d07c <_strtol_l.isra.0+0x4c>
    d108:	negs	r0, r0
    d10a:	b.n	d0e6 <_strtol_l.isra.0+0xb6>
    d10c:	cmp.w	ip, #0
    d110:	mov.w	r3, #34	; 0x22
    d114:	ite	eq
    d116:	mvneq.w	r0, #2147483648	; 0x80000000
    d11a:	movne.w	r0, #2147483648	; 0x80000000
    d11e:	str.w	r3, [r8]
    d122:	cbz	r6, d162 <_strtol_l.isra.0+0x132>
    d124:	subs	r7, r4, #1
    d126:	str	r7, [r6, #0]
    d128:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d12c:	add.w	r4, fp, #2
    d130:	ldrb.w	r2, [fp, #1]
    d134:	mov.w	ip, #1
    d138:	b.n	d074 <_strtol_l.isra.0+0x44>
    d13a:	ldrb	r3, [r4, #0]
    d13c:	and.w	r3, r3, #223	; 0xdf
    d140:	cmp	r3, #88	; 0x58
    d142:	beq.n	d156 <_strtol_l.isra.0+0x126>
    d144:	movs	r5, #8
    d146:	b.n	d07c <_strtol_l.isra.0+0x4c>
    d148:	cmp	r2, #48	; 0x30
    d14a:	bne.n	d07c <_strtol_l.isra.0+0x4c>
    d14c:	ldrb	r3, [r4, #0]
    d14e:	and.w	r3, r3, #223	; 0xdf
    d152:	cmp	r3, #88	; 0x58
    d154:	bne.n	d07c <_strtol_l.isra.0+0x4c>
    d156:	mov.w	r9, #16
    d15a:	ldrb	r2, [r4, #1]
    d15c:	mov	r5, r9
    d15e:	adds	r4, #2
    d160:	b.n	d07e <_strtol_l.isra.0+0x4e>
    d162:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d166:	nop

0000d168 <_strtol_r>:
    d168:	push	{r4, r5, lr}
    d16a:	ldr	r4, [pc, #24]	; (d184 <_strtol_r+0x1c>)
    d16c:	ldr	r5, [pc, #24]	; (d188 <_strtol_r+0x20>)
    d16e:	ldr	r4, [r4, #0]
    d170:	ldr	r4, [r4, #52]	; 0x34
    d172:	sub	sp, #12
    d174:	cmp	r4, #0
    d176:	it	eq
    d178:	moveq	r4, r5
    d17a:	str	r4, [sp, #0]
    d17c:	bl	d030 <_strtol_l.isra.0>
    d180:	add	sp, #12
    d182:	pop	{r4, r5, pc}
    d184:	.word	0x1fff1828
    d188:	.word	0x1fff182c
    d18c:	.word	0xffffffff

0000d190 <_svfprintf_r>:
    d190:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d194:	sub	sp, #260	; 0x104
    d196:	mov	r4, r1
    d198:	str	r1, [sp, #20]
    d19a:	mov	r5, r2
    d19c:	str	r3, [sp, #40]	; 0x28
    d19e:	str	r0, [sp, #24]
    d1a0:	bl	111e8 <_localeconv_r>
    d1a4:	ldr	r3, [r0, #0]
    d1a6:	str	r3, [sp, #76]	; 0x4c
    d1a8:	mov	r0, r3
    d1aa:	bl	bf80 <strlen>
    d1ae:	ldrh	r3, [r4, #12]
    d1b0:	str	r0, [sp, #72]	; 0x48
    d1b2:	lsls	r6, r3, #24
    d1b4:	bpl.n	d1be <_svfprintf_r+0x2e>
    d1b6:	ldr	r3, [r4, #16]
    d1b8:	cmp	r3, #0
    d1ba:	beq.w	e420 <_svfprintf_r+0x1290>
    d1be:	vldr	d7, [pc, #664]	; d458 <_svfprintf_r+0x2c8>
    d1c2:	movs	r3, #0
    d1c4:	vstr	d7, [sp, #64]	; 0x40
    d1c8:	str	r3, [sp, #56]	; 0x38
    d1ca:	str	r3, [sp, #148]	; 0x94
    d1cc:	str	r3, [sp, #144]	; 0x90
    d1ce:	str	r3, [sp, #84]	; 0x54
    d1d0:	str	r3, [sp, #28]
    d1d2:	ldr.w	sl, [pc, #656]	; d464 <_svfprintf_r+0x2d4>
    d1d6:	add	r3, sp, #192	; 0xc0
    d1d8:	str	r3, [sp, #140]	; 0x8c
    d1da:	mov	r9, r3
    d1dc:	mov	r8, r5
    d1de:	ldrb.w	r3, [r8]
    d1e2:	mov	r4, r8
    d1e4:	cbz	r3, d222 <_svfprintf_r+0x92>
    d1e6:	cmp	r3, #37	; 0x25
    d1e8:	bne.n	d1f0 <_svfprintf_r+0x60>
    d1ea:	b.n	d222 <_svfprintf_r+0x92>
    d1ec:	cmp	r3, #37	; 0x25
    d1ee:	beq.n	d1f8 <_svfprintf_r+0x68>
    d1f0:	ldrb.w	r3, [r4, #1]!
    d1f4:	cmp	r3, #0
    d1f6:	bne.n	d1ec <_svfprintf_r+0x5c>
    d1f8:	rsb	r5, r8, r4
    d1fc:	cbz	r5, d222 <_svfprintf_r+0x92>
    d1fe:	ldr	r3, [sp, #144]	; 0x90
    d200:	ldr	r2, [sp, #148]	; 0x94
    d202:	str.w	r8, [r9]
    d206:	adds	r3, #1
    d208:	add	r2, r5
    d20a:	cmp	r3, #7
    d20c:	str.w	r5, [r9, #4]
    d210:	str	r2, [sp, #148]	; 0x94
    d212:	str	r3, [sp, #144]	; 0x90
    d214:	bgt.w	d364 <_svfprintf_r+0x1d4>
    d218:	add.w	r9, r9, #8
    d21c:	ldr	r3, [sp, #28]
    d21e:	add	r3, r5
    d220:	str	r3, [sp, #28]
    d222:	ldrb	r3, [r4, #0]
    d224:	cmp	r3, #0
    d226:	beq.w	d376 <_svfprintf_r+0x1e6>
    d22a:	movs	r3, #0
    d22c:	mov	r2, r3
    d22e:	strb.w	r3, [sp, #111]	; 0x6f
    d232:	mov	r1, r3
    d234:	str	r3, [sp, #32]
    d236:	str	r3, [sp, #12]
    d238:	mov.w	fp, #4294967295
    d23c:	ldrb	r3, [r4, #1]
    d23e:	add.w	r8, r4, #1
    d242:	mov	r5, fp
    d244:	add.w	r8, r8, #1
    d248:	sub.w	r0, r3, #32
    d24c:	cmp	r0, #88	; 0x58
    d24e:	bhi.w	daba <_svfprintf_r+0x92a>
    d252:	tbh	[pc, r0, lsl #1]
    d256:	.short	0x03a0
    d258:	.word	0x04320432
    d25c:	.word	0x043203a8
    d260:	.word	0x04320432
    d264:	.word	0x04320432
    d268:	.word	0x03af0432
    d26c:	.word	0x043203bd
    d270:	.word	0x00e2005d
    d274:	.word	0x01090432
    d278:	.word	0x01100110
    d27c:	.word	0x01100110
    d280:	.word	0x01100110
    d284:	.word	0x01100110
    d288:	.word	0x04320110
    d28c:	.word	0x04320432
    d290:	.word	0x04320432
    d294:	.word	0x04320432
    d298:	.word	0x04320432
    d29c:	.word	0x01200432
    d2a0:	.word	0x04320286
    d2a4:	.word	0x04320286
    d2a8:	.word	0x04320432
    d2ac:	.word	0x02d40432
    d2b0:	.word	0x04320432
    d2b4:	.word	0x043202e5
    d2b8:	.word	0x04320432
    d2bc:	.word	0x04320432
    d2c0:	.word	0x0432030f
    d2c4:	.word	0x033d0432
    d2c8:	.word	0x04320432
    d2cc:	.word	0x04320432
    d2d0:	.word	0x04320432
    d2d4:	.word	0x04320432
    d2d8:	.word	0x04320432
    d2dc:	.word	0x0391037e
    d2e0:	.word	0x02860286
    d2e4:	.word	0x03990286
    d2e8:	.word	0x04320391
    d2ec:	.word	0x04070432
    d2f0:	.word	0x04120432
    d2f4:	.word	0x006400a3
    d2f8:	.word	0x043203c2
    d2fc:	.word	0x043203c9
    d300:	.word	0x043203ea
    d304:	.word	0x03f20432
    d308:	ldr	r0, [sp, #32]
    d30a:	str	r3, [sp, #40]	; 0x28
    d30c:	negs	r0, r0
    d30e:	str	r0, [sp, #32]
    d310:	ldr	r3, [sp, #12]
    d312:	orr.w	r3, r3, #4
    d316:	str	r3, [sp, #12]
    d318:	ldrb.w	r3, [r8]
    d31c:	b.n	d244 <_svfprintf_r+0xb4>
    d31e:	ldr	r0, [sp, #40]	; 0x28
    d320:	mov	fp, r5
    d322:	movs	r1, #0
    d324:	ldr	r4, [r0, #0]
    d326:	strb.w	r1, [sp, #111]	; 0x6f
    d32a:	adds	r7, r0, #4
    d32c:	ldr	r0, [sp, #12]
    d32e:	movs	r3, #48	; 0x30
    d330:	movs	r2, #120	; 0x78
    d332:	cmp	fp, r1
    d334:	strb.w	r3, [sp, #112]	; 0x70
    d338:	mov.w	r5, #0
    d33c:	strb.w	r2, [sp, #113]	; 0x71
    d340:	orr.w	r3, r0, #2
    d344:	blt.w	daf4 <_svfprintf_r+0x964>
    d348:	bic.w	r3, r0, #128	; 0x80
    d34c:	orr.w	r3, r3, #2
    d350:	str	r3, [sp, #12]
    d352:	orrs.w	r3, r4, r5
    d356:	str	r7, [sp, #40]	; 0x28
    d358:	beq.w	daa0 <_svfprintf_r+0x910>
    d35c:	mov	r7, r1
    d35e:	str	r2, [sp, #52]	; 0x34
    d360:	ldr	r0, [pc, #252]	; (d460 <_svfprintf_r+0x2d0>)
    d362:	b.n	d932 <_svfprintf_r+0x7a2>
    d364:	add	r2, sp, #140	; 0x8c
    d366:	ldr	r1, [sp, #20]
    d368:	ldr	r0, [sp, #24]
    d36a:	bl	12134 <__ssprint_r>
    d36e:	cbnz	r0, d384 <_svfprintf_r+0x1f4>
    d370:	add.w	r9, sp, #192	; 0xc0
    d374:	b.n	d21c <_svfprintf_r+0x8c>
    d376:	ldr	r3, [sp, #148]	; 0x94
    d378:	cbz	r3, d384 <_svfprintf_r+0x1f4>
    d37a:	ldr	r0, [sp, #24]
    d37c:	ldr	r1, [sp, #20]
    d37e:	add	r2, sp, #140	; 0x8c
    d380:	bl	12134 <__ssprint_r>
    d384:	ldr	r3, [sp, #20]
    d386:	ldrh	r3, [r3, #12]
    d388:	tst.w	r3, #64	; 0x40
    d38c:	ldr	r3, [sp, #28]
    d38e:	it	ne
    d390:	movne.w	r3, #4294967295
    d394:	mov	r0, r3
    d396:	add	sp, #260	; 0x104
    d398:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d39c:	str	r3, [sp, #52]	; 0x34
    d39e:	mov	fp, r5
    d3a0:	cmp	r2, #0
    d3a2:	bne.w	e80c <_svfprintf_r+0x167c>
    d3a6:	ldr	r2, [sp, #12]
    d3a8:	ands.w	r3, r2, #32
    d3ac:	beq.w	d83c <_svfprintf_r+0x6ac>
    d3b0:	ldr	r7, [sp, #40]	; 0x28
    d3b2:	adds	r7, #7
    d3b4:	bic.w	r3, r7, #7
    d3b8:	movs	r7, #0
    d3ba:	add.w	r1, r3, #8
    d3be:	cmp	fp, r7
    d3c0:	str	r1, [sp, #40]	; 0x28
    d3c2:	ldrd	r4, r5, [r3]
    d3c6:	strb.w	r7, [sp, #111]	; 0x6f
    d3ca:	blt.w	e292 <_svfprintf_r+0x1102>
    d3ce:	bic.w	r3, r2, #128	; 0x80
    d3d2:	str	r3, [sp, #12]
    d3d4:	orrs.w	r3, r4, r5
    d3d8:	beq.w	dae4 <_svfprintf_r+0x954>
    d3dc:	add	r6, sp, #192	; 0xc0
    d3de:	lsrs	r2, r4, #3
    d3e0:	orr.w	r2, r2, r5, lsl #29
    d3e4:	lsrs	r1, r5, #3
    d3e6:	and.w	r3, r4, #7
    d3ea:	mov	r5, r1
    d3ec:	mov	r4, r2
    d3ee:	adds	r3, #48	; 0x30
    d3f0:	orrs.w	r2, r4, r5
    d3f4:	strb.w	r3, [r6, #-1]!
    d3f8:	bne.n	d3de <_svfprintf_r+0x24e>
    d3fa:	ldr	r2, [sp, #12]
    d3fc:	lsls	r1, r2, #31
    d3fe:	bpl.w	d520 <_svfprintf_r+0x390>
    d402:	cmp	r3, #48	; 0x30
    d404:	beq.w	d520 <_svfprintf_r+0x390>
    d408:	movs	r2, #48	; 0x30
    d40a:	subs	r3, r6, #1
    d40c:	strb.w	r2, [r6, #-1]
    d410:	add	r2, sp, #192	; 0xc0
    d412:	subs	r2, r2, r3
    d414:	str	r2, [sp, #36]	; 0x24
    d416:	mov	r6, r3
    d418:	b.n	d526 <_svfprintf_r+0x396>
    d41a:	ldrb.w	r3, [r8]
    d41e:	cmp	r3, #42	; 0x2a
    d420:	add.w	r4, r8, #1
    d424:	beq.w	e7f0 <_svfprintf_r+0x1660>
    d428:	sub.w	r0, r3, #48	; 0x30
    d42c:	cmp	r0, #9
    d42e:	it	ls
    d430:	movls	r5, #0
    d432:	bhi.w	e742 <_svfprintf_r+0x15b2>
    d436:	ldrb.w	r3, [r4], #1
    d43a:	add.w	r5, r5, r5, lsl #2
    d43e:	add.w	r5, r0, r5, lsl #1
    d442:	sub.w	r0, r3, #48	; 0x30
    d446:	cmp	r0, #9
    d448:	bls.n	d436 <_svfprintf_r+0x2a6>
    d44a:	orr.w	r5, r5, r5, asr #31
    d44e:	mov	r8, r4
    d450:	b.n	d248 <_svfprintf_r+0xb8>
    d452:	nop
    d454:	nop.w
	...
    d460:	.word	0x000131b4
    d464:	.word	0x00013180
    d468:	ldr	r3, [sp, #12]
    d46a:	orr.w	r3, r3, #128	; 0x80
    d46e:	str	r3, [sp, #12]
    d470:	ldrb.w	r3, [r8]
    d474:	b.n	d244 <_svfprintf_r+0xb4>
    d476:	sub.w	r0, r3, #48	; 0x30
    d47a:	movs	r3, #0
    d47c:	mov	r4, r3
    d47e:	ldrb.w	r3, [r8], #1
    d482:	add.w	r4, r4, r4, lsl #2
    d486:	add.w	r4, r0, r4, lsl #1
    d48a:	sub.w	r0, r3, #48	; 0x30
    d48e:	cmp	r0, #9
    d490:	bls.n	d47e <_svfprintf_r+0x2ee>
    d492:	str	r4, [sp, #32]
    d494:	b.n	d248 <_svfprintf_r+0xb8>
    d496:	str	r3, [sp, #52]	; 0x34
    d498:	mov	fp, r5
    d49a:	cmp	r2, #0
    d49c:	bne.w	e828 <_svfprintf_r+0x1698>
    d4a0:	ldr	r3, [sp, #12]
    d4a2:	orr.w	r3, r3, #16
    d4a6:	str	r3, [sp, #12]
    d4a8:	ldr	r3, [sp, #12]
    d4aa:	lsls	r4, r3, #26
    d4ac:	bpl.w	df1e <_svfprintf_r+0xd8e>
    d4b0:	ldr	r7, [sp, #40]	; 0x28
    d4b2:	adds	r7, #7
    d4b4:	bic.w	r7, r7, #7
    d4b8:	ldrd	r2, r3, [r7]
    d4bc:	add.w	r1, r7, #8
    d4c0:	str	r1, [sp, #40]	; 0x28
    d4c2:	mov	r4, r2
    d4c4:	mov	r5, r3
    d4c6:	cmp	r2, #0
    d4c8:	sbcs.w	r3, r3, #0
    d4cc:	blt.w	df94 <_svfprintf_r+0xe04>
    d4d0:	cmp.w	fp, #0
    d4d4:	ldrb.w	r7, [sp, #111]	; 0x6f
    d4d8:	blt.w	df5a <_svfprintf_r+0xdca>
    d4dc:	ldr	r3, [sp, #12]
    d4de:	bic.w	r3, r3, #128	; 0x80
    d4e2:	str	r3, [sp, #12]
    d4e4:	orrs.w	r3, r4, r5
    d4e8:	beq.w	d8bc <_svfprintf_r+0x72c>
    d4ec:	cmp	r5, #0
    d4ee:	it	eq
    d4f0:	cmpeq	r4, #10
    d4f2:	bcc.w	d8c6 <_svfprintf_r+0x736>
    d4f6:	add	r6, sp, #192	; 0xc0
    d4f8:	mov	r0, r4
    d4fa:	mov	r1, r5
    d4fc:	movs	r2, #10
    d4fe:	movs	r3, #0
    d500:	bl	af48 <__aeabi_uldivmod>
    d504:	adds	r2, #48	; 0x30
    d506:	strb.w	r2, [r6, #-1]!
    d50a:	mov	r0, r4
    d50c:	mov	r1, r5
    d50e:	movs	r3, #0
    d510:	movs	r2, #10
    d512:	bl	af48 <__aeabi_uldivmod>
    d516:	mov	r4, r0
    d518:	mov	r5, r1
    d51a:	orrs.w	r3, r4, r5
    d51e:	bne.n	d4f8 <_svfprintf_r+0x368>
    d520:	add	r3, sp, #192	; 0xc0
    d522:	subs	r3, r3, r6
    d524:	str	r3, [sp, #36]	; 0x24
    d526:	ldr	r3, [sp, #36]	; 0x24
    d528:	cmp	r3, fp
    d52a:	it	lt
    d52c:	movlt	r3, fp
    d52e:	str	r3, [sp, #16]
    d530:	movs	r3, #0
    d532:	str	r3, [sp, #60]	; 0x3c
    d534:	cbz	r7, d53c <_svfprintf_r+0x3ac>
    d536:	ldr	r3, [sp, #16]
    d538:	adds	r3, #1
    d53a:	str	r3, [sp, #16]
    d53c:	ldr	r3, [sp, #12]
    d53e:	ands.w	r3, r3, #2
    d542:	str	r3, [sp, #44]	; 0x2c
    d544:	beq.n	d54c <_svfprintf_r+0x3bc>
    d546:	ldr	r3, [sp, #16]
    d548:	adds	r3, #2
    d54a:	str	r3, [sp, #16]
    d54c:	ldr	r3, [sp, #12]
    d54e:	ands.w	r3, r3, #132	; 0x84
    d552:	str	r3, [sp, #48]	; 0x30
    d554:	bne.w	db0e <_svfprintf_r+0x97e>
    d558:	ldr	r3, [sp, #32]
    d55a:	ldr	r2, [sp, #16]
    d55c:	subs	r5, r3, r2
    d55e:	cmp	r5, #0
    d560:	ble.w	db0e <_svfprintf_r+0x97e>
    d564:	cmp	r5, #16
    d566:	ldr	r1, [sp, #148]	; 0x94
    d568:	ldr	r2, [sp, #144]	; 0x90
    d56a:	ldr	r7, [pc, #672]	; (d80c <_svfprintf_r+0x67c>)
    d56c:	ble.n	d5be <_svfprintf_r+0x42e>
    d56e:	str	r6, [sp, #80]	; 0x50
    d570:	mov	r0, r9
    d572:	movs	r4, #16
    d574:	mov	r9, r7
    d576:	ldr	r6, [sp, #20]
    d578:	mov	r7, r5
    d57a:	ldr	r5, [sp, #24]
    d57c:	b.n	d588 <_svfprintf_r+0x3f8>
    d57e:	subs	r7, #16
    d580:	cmp	r7, #16
    d582:	add.w	r0, r0, #8
    d586:	ble.n	d5b6 <_svfprintf_r+0x426>
    d588:	adds	r2, #1
    d58a:	ldr	r3, [pc, #640]	; (d80c <_svfprintf_r+0x67c>)
    d58c:	str	r2, [sp, #144]	; 0x90
    d58e:	adds	r1, #16
    d590:	cmp	r2, #7
    d592:	str	r1, [sp, #148]	; 0x94
    d594:	stmia.w	r0, {r3, r4}
    d598:	ble.n	d57e <_svfprintf_r+0x3ee>
    d59a:	add	r2, sp, #140	; 0x8c
    d59c:	mov	r1, r6
    d59e:	mov	r0, r5
    d5a0:	bl	12134 <__ssprint_r>
    d5a4:	cmp	r0, #0
    d5a6:	bne.w	d384 <_svfprintf_r+0x1f4>
    d5aa:	subs	r7, #16
    d5ac:	cmp	r7, #16
    d5ae:	ldr	r1, [sp, #148]	; 0x94
    d5b0:	ldr	r2, [sp, #144]	; 0x90
    d5b2:	add	r0, sp, #192	; 0xc0
    d5b4:	bgt.n	d588 <_svfprintf_r+0x3f8>
    d5b6:	ldr	r6, [sp, #80]	; 0x50
    d5b8:	mov	r5, r7
    d5ba:	mov	r7, r9
    d5bc:	mov	r9, r0
    d5be:	adds	r2, #1
    d5c0:	adds	r4, r5, r1
    d5c2:	cmp	r2, #7
    d5c4:	str	r4, [sp, #148]	; 0x94
    d5c6:	str	r2, [sp, #144]	; 0x90
    d5c8:	str.w	r7, [r9]
    d5cc:	str.w	r5, [r9, #4]
    d5d0:	bgt.w	de2e <_svfprintf_r+0xc9e>
    d5d4:	ldrb.w	r7, [sp, #111]	; 0x6f
    d5d8:	add.w	r9, r9, #8
    d5dc:	cbz	r7, d5fc <_svfprintf_r+0x46c>
    d5de:	ldr	r3, [sp, #144]	; 0x90
    d5e0:	adds	r3, #1
    d5e2:	adds	r4, #1
    d5e4:	add.w	r1, sp, #111	; 0x6f
    d5e8:	movs	r2, #1
    d5ea:	cmp	r3, #7
    d5ec:	str	r4, [sp, #148]	; 0x94
    d5ee:	str	r3, [sp, #144]	; 0x90
    d5f0:	stmia.w	r9, {r1, r2}
    d5f4:	bgt.w	dd42 <_svfprintf_r+0xbb2>
    d5f8:	add.w	r9, r9, #8
    d5fc:	ldr	r3, [sp, #44]	; 0x2c
    d5fe:	cbz	r3, d61c <_svfprintf_r+0x48c>
    d600:	ldr	r3, [sp, #144]	; 0x90
    d602:	adds	r3, #1
    d604:	adds	r4, #2
    d606:	add	r1, sp, #112	; 0x70
    d608:	movs	r2, #2
    d60a:	cmp	r3, #7
    d60c:	str	r4, [sp, #148]	; 0x94
    d60e:	str	r3, [sp, #144]	; 0x90
    d610:	stmia.w	r9, {r1, r2}
    d614:	bgt.w	dd5a <_svfprintf_r+0xbca>
    d618:	add.w	r9, r9, #8
    d61c:	ldr	r3, [sp, #48]	; 0x30
    d61e:	cmp	r3, #128	; 0x80
    d620:	beq.w	dbe6 <_svfprintf_r+0xa56>
    d624:	ldr	r3, [sp, #36]	; 0x24
    d626:	rsb	r7, r3, fp
    d62a:	cmp	r7, #0
    d62c:	ble.n	d696 <_svfprintf_r+0x506>
    d62e:	ldr	r2, [pc, #480]	; (d810 <_svfprintf_r+0x680>)
    d630:	ldr	r3, [sp, #144]	; 0x90
    d632:	str	r2, [sp, #44]	; 0x2c
    d634:	cmp	r7, #16
    d636:	ble.n	d67e <_svfprintf_r+0x4ee>
    d638:	mov	r2, r4
    d63a:	mov.w	fp, #16
    d63e:	ldr	r5, [sp, #24]
    d640:	ldr	r4, [sp, #20]
    d642:	b.n	d64e <_svfprintf_r+0x4be>
    d644:	subs	r7, #16
    d646:	cmp	r7, #16
    d648:	add.w	r9, r9, #8
    d64c:	ble.n	d67c <_svfprintf_r+0x4ec>
    d64e:	adds	r3, #1
    d650:	adds	r2, #16
    d652:	cmp	r3, #7
    d654:	str	r2, [sp, #148]	; 0x94
    d656:	str	r3, [sp, #144]	; 0x90
    d658:	stmia.w	r9, {sl, fp}
    d65c:	ble.n	d644 <_svfprintf_r+0x4b4>
    d65e:	add	r2, sp, #140	; 0x8c
    d660:	mov	r1, r4
    d662:	mov	r0, r5
    d664:	bl	12134 <__ssprint_r>
    d668:	cmp	r0, #0
    d66a:	bne.w	d384 <_svfprintf_r+0x1f4>
    d66e:	subs	r7, #16
    d670:	cmp	r7, #16
    d672:	ldr	r2, [sp, #148]	; 0x94
    d674:	ldr	r3, [sp, #144]	; 0x90
    d676:	add.w	r9, sp, #192	; 0xc0
    d67a:	bgt.n	d64e <_svfprintf_r+0x4be>
    d67c:	mov	r4, r2
    d67e:	adds	r3, #1
    d680:	ldr	r2, [sp, #44]	; 0x2c
    d682:	str	r3, [sp, #144]	; 0x90
    d684:	add	r4, r7
    d686:	cmp	r3, #7
    d688:	str	r4, [sp, #148]	; 0x94
    d68a:	stmia.w	r9, {r2, r7}
    d68e:	bgt.w	dd2a <_svfprintf_r+0xb9a>
    d692:	add.w	r9, r9, #8
    d696:	ldr	r3, [sp, #12]
    d698:	lsls	r2, r3, #23
    d69a:	bmi.w	db12 <_svfprintf_r+0x982>
    d69e:	ldr	r3, [sp, #144]	; 0x90
    d6a0:	ldr	r1, [sp, #36]	; 0x24
    d6a2:	str.w	r6, [r9]
    d6a6:	adds	r3, #1
    d6a8:	add	r4, r1
    d6aa:	cmp	r3, #7
    d6ac:	str	r4, [sp, #148]	; 0x94
    d6ae:	str.w	r1, [r9, #4]
    d6b2:	str	r3, [sp, #144]	; 0x90
    d6b4:	bgt.w	dcfe <_svfprintf_r+0xb6e>
    d6b8:	add.w	r9, r9, #8
    d6bc:	ldr	r3, [sp, #12]
    d6be:	lsls	r1, r3, #29
    d6c0:	bpl.n	d742 <_svfprintf_r+0x5b2>
    d6c2:	ldr	r3, [sp, #32]
    d6c4:	ldr	r2, [sp, #16]
    d6c6:	subs	r5, r3, r2
    d6c8:	cmp	r5, #0
    d6ca:	ble.n	d742 <_svfprintf_r+0x5b2>
    d6cc:	cmp	r5, #16
    d6ce:	ldr	r3, [sp, #144]	; 0x90
    d6d0:	ldr	r7, [pc, #312]	; (d80c <_svfprintf_r+0x67c>)
    d6d2:	ble.n	d71c <_svfprintf_r+0x58c>
    d6d4:	mov	r2, r4
    d6d6:	movs	r6, #16
    d6d8:	ldr.w	fp, [sp, #24]
    d6dc:	ldr	r4, [sp, #20]
    d6de:	b.n	d6ea <_svfprintf_r+0x55a>
    d6e0:	subs	r5, #16
    d6e2:	cmp	r5, #16
    d6e4:	add.w	r9, r9, #8
    d6e8:	ble.n	d71a <_svfprintf_r+0x58a>
    d6ea:	adds	r3, #1
    d6ec:	ldr	r1, [pc, #284]	; (d80c <_svfprintf_r+0x67c>)
    d6ee:	str	r3, [sp, #144]	; 0x90
    d6f0:	adds	r2, #16
    d6f2:	cmp	r3, #7
    d6f4:	str	r2, [sp, #148]	; 0x94
    d6f6:	stmia.w	r9, {r1, r6}
    d6fa:	ble.n	d6e0 <_svfprintf_r+0x550>
    d6fc:	add	r2, sp, #140	; 0x8c
    d6fe:	mov	r1, r4
    d700:	mov	r0, fp
    d702:	bl	12134 <__ssprint_r>
    d706:	cmp	r0, #0
    d708:	bne.w	d384 <_svfprintf_r+0x1f4>
    d70c:	subs	r5, #16
    d70e:	cmp	r5, #16
    d710:	ldr	r2, [sp, #148]	; 0x94
    d712:	ldr	r3, [sp, #144]	; 0x90
    d714:	add.w	r9, sp, #192	; 0xc0
    d718:	bgt.n	d6ea <_svfprintf_r+0x55a>
    d71a:	mov	r4, r2
    d71c:	adds	r3, #1
    d71e:	add	r4, r5
    d720:	cmp	r3, #7
    d722:	str	r4, [sp, #148]	; 0x94
    d724:	str	r3, [sp, #144]	; 0x90
    d726:	str.w	r7, [r9]
    d72a:	str.w	r5, [r9, #4]
    d72e:	ble.n	d742 <_svfprintf_r+0x5b2>
    d730:	add	r2, sp, #140	; 0x8c
    d732:	ldr	r1, [sp, #20]
    d734:	ldr	r0, [sp, #24]
    d736:	bl	12134 <__ssprint_r>
    d73a:	cmp	r0, #0
    d73c:	bne.w	d384 <_svfprintf_r+0x1f4>
    d740:	ldr	r4, [sp, #148]	; 0x94
    d742:	ldr	r3, [sp, #28]
    d744:	ldr	r2, [sp, #32]
    d746:	ldr	r1, [sp, #16]
    d748:	cmp	r2, r1
    d74a:	ite	ge
    d74c:	addge	r3, r3, r2
    d74e:	addlt	r3, r3, r1
    d750:	str	r3, [sp, #28]
    d752:	cmp	r4, #0
    d754:	bne.w	dd16 <_svfprintf_r+0xb86>
    d758:	movs	r3, #0
    d75a:	str	r3, [sp, #144]	; 0x90
    d75c:	add.w	r9, sp, #192	; 0xc0
    d760:	b.n	d1de <_svfprintf_r+0x4e>
    d762:	str	r3, [sp, #52]	; 0x34
    d764:	mov	fp, r5
    d766:	cmp	r2, #0
    d768:	bne.w	e830 <_svfprintf_r+0x16a0>
    d76c:	ldr	r3, [sp, #12]
    d76e:	ldr	r7, [sp, #40]	; 0x28
    d770:	lsls	r2, r3, #28
    d772:	add.w	r7, r7, #7
    d776:	bpl.w	e262 <_svfprintf_r+0x10d2>
    d77a:	bic.w	r3, r7, #7
    d77e:	vldr	d7, [r3]
    d782:	vstr	d7, [sp, #64]	; 0x40
    d786:	add.w	r2, r3, #8
    d78a:	str	r2, [sp, #40]	; 0x28
    d78c:	ldrd	r1, r2, [sp, #64]	; 0x40
    d790:	bic.w	r3, r2, #2147483648	; 0x80000000
    d794:	str	r1, [sp, #88]	; 0x58
    d796:	str	r3, [sp, #92]	; 0x5c
    d798:	ldrd	r4, r5, [sp, #88]	; 0x58
    d79c:	mov.w	r2, #4294967295
    d7a0:	mov	r0, r4
    d7a2:	mov	r1, r5
    d7a4:	ldr	r3, [pc, #108]	; (d814 <_svfprintf_r+0x684>)
    d7a6:	bl	adec <__aeabi_dcmpun>
    d7aa:	cmp	r0, #0
    d7ac:	bne.w	e164 <_svfprintf_r+0xfd4>
    d7b0:	mov.w	r2, #4294967295
    d7b4:	ldr	r3, [pc, #92]	; (d814 <_svfprintf_r+0x684>)
    d7b6:	mov	r0, r4
    d7b8:	mov	r1, r5
    d7ba:	bl	adb0 <__aeabi_dcmple>
    d7be:	cmp	r0, #0
    d7c0:	bne.w	e164 <_svfprintf_r+0xfd4>
    d7c4:	movs	r2, #0
    d7c6:	movs	r3, #0
    d7c8:	ldrd	r0, r1, [sp, #64]	; 0x40
    d7cc:	bl	ad9c <__aeabi_dcmplt>
    d7d0:	cmp	r0, #0
    d7d2:	bne.w	e67a <_svfprintf_r+0x14ea>
    d7d6:	ldrb.w	r7, [sp, #111]	; 0x6f
    d7da:	ldr	r6, [pc, #60]	; (d818 <_svfprintf_r+0x688>)
    d7dc:	ldr	r3, [pc, #60]	; (d81c <_svfprintf_r+0x68c>)
    d7de:	ldr	r1, [sp, #12]
    d7e0:	bic.w	r1, r1, #128	; 0x80
    d7e4:	str	r1, [sp, #12]
    d7e6:	ldr	r1, [sp, #52]	; 0x34
    d7e8:	movs	r2, #3
    d7ea:	mov.w	fp, #0
    d7ee:	str	r2, [sp, #16]
    d7f0:	cmp	r1, #71	; 0x47
    d7f2:	it	le
    d7f4:	movle	r6, r3
    d7f6:	str	r2, [sp, #36]	; 0x24
    d7f8:	str.w	fp, [sp, #60]	; 0x3c
    d7fc:	b.n	d534 <_svfprintf_r+0x3a4>
    d7fe:	ldr	r3, [sp, #12]
    d800:	orr.w	r3, r3, #8
    d804:	str	r3, [sp, #12]
    d806:	ldrb.w	r3, [r8]
    d80a:	b.n	d244 <_svfprintf_r+0xb4>
    d80c:	.word	0x000131d4
    d810:	.word	0x00013180
    d814:	.word	0x7fefffff
    d818:	.word	0x00013194
    d81c:	.word	0x00013190
    d820:	str	r3, [sp, #52]	; 0x34
    d822:	mov	fp, r5
    d824:	cmp	r2, #0
    d826:	bne.w	e848 <_svfprintf_r+0x16b8>
    d82a:	ldr	r3, [sp, #12]
    d82c:	orr.w	r3, r3, #16
    d830:	str	r3, [sp, #12]
    d832:	ldr	r2, [sp, #12]
    d834:	ands.w	r3, r2, #32
    d838:	bne.w	d3b0 <_svfprintf_r+0x220>
    d83c:	ldr	r1, [sp, #12]
    d83e:	ands.w	r2, r1, #16
    d842:	beq.w	e0fc <_svfprintf_r+0xf6c>
    d846:	ldr	r0, [sp, #40]	; 0x28
    d848:	strb.w	r3, [sp, #111]	; 0x6f
    d84c:	cmp.w	fp, #0
    d850:	ldr	r4, [r0, #0]
    d852:	add.w	r7, r0, #4
    d856:	mov.w	r5, #0
    d85a:	blt.w	e290 <_svfprintf_r+0x1100>
    d85e:	mov	r2, r1
    d860:	bic.w	r2, r2, #128	; 0x80
    d864:	str	r2, [sp, #12]
    d866:	orrs.w	r2, r4, r5
    d86a:	str	r7, [sp, #40]	; 0x28
    d86c:	beq.w	dae4 <_svfprintf_r+0x954>
    d870:	mov	r7, r3
    d872:	b.n	d3dc <_svfprintf_r+0x24c>
    d874:	str	r3, [sp, #52]	; 0x34
    d876:	mov	fp, r5
    d878:	cmp	r2, #0
    d87a:	bne.w	e840 <_svfprintf_r+0x16b0>
    d87e:	ldr	r3, [sp, #12]
    d880:	orr.w	r3, r3, #16
    d884:	str	r3, [sp, #12]
    d886:	ldr	r2, [sp, #12]
    d888:	ands.w	r3, r2, #32
    d88c:	beq.w	dee8 <_svfprintf_r+0xd58>
    d890:	ldr	r7, [sp, #40]	; 0x28
    d892:	adds	r7, #7
    d894:	bic.w	r3, r7, #7
    d898:	movs	r7, #0
    d89a:	add.w	r1, r3, #8
    d89e:	cmp	fp, r7
    d8a0:	str	r1, [sp, #40]	; 0x28
    d8a2:	ldrd	r4, r5, [r3]
    d8a6:	strb.w	r7, [sp, #111]	; 0x6f
    d8aa:	blt.w	df5a <_svfprintf_r+0xdca>
    d8ae:	bic.w	r3, r2, #128	; 0x80
    d8b2:	str	r3, [sp, #12]
    d8b4:	orrs.w	r3, r4, r5
    d8b8:	bne.w	d4ec <_svfprintf_r+0x35c>
    d8bc:	cmp.w	fp, #0
    d8c0:	beq.w	daae <_svfprintf_r+0x91e>
    d8c4:	movs	r4, #0
    d8c6:	add	r6, sp, #256	; 0x100
    d8c8:	adds	r4, #48	; 0x30
    d8ca:	strb.w	r4, [r6, #-65]!
    d8ce:	b.n	d520 <_svfprintf_r+0x390>
    d8d0:	str	r3, [sp, #52]	; 0x34
    d8d2:	mov	fp, r5
    d8d4:	cmp	r2, #0
    d8d6:	bne.w	e838 <_svfprintf_r+0x16a8>
    d8da:	ldr	r3, [sp, #12]
    d8dc:	ldr	r0, [pc, #700]	; (db9c <_svfprintf_r+0xa0c>)
    d8de:	lsls	r5, r3, #26
    d8e0:	bpl.w	da4e <_svfprintf_r+0x8be>
    d8e4:	ldr	r7, [sp, #40]	; 0x28
    d8e6:	adds	r7, #7
    d8e8:	bic.w	r3, r7, #7
    d8ec:	ldrd	r4, r5, [r3]
    d8f0:	add.w	r2, r3, #8
    d8f4:	str	r2, [sp, #40]	; 0x28
    d8f6:	ldr	r2, [sp, #12]
    d8f8:	ands.w	r7, r2, #1
    d8fc:	beq.w	dd72 <_svfprintf_r+0xbe2>
    d900:	orrs.w	r3, r4, r5
    d904:	beq.w	e30c <_svfprintf_r+0x117c>
    d908:	ldrb.w	r2, [sp, #52]	; 0x34
    d90c:	strb.w	r2, [sp, #113]	; 0x71
    d910:	movs	r7, #0
    d912:	ldr	r2, [sp, #12]
    d914:	strb.w	r7, [sp, #111]	; 0x6f
    d918:	movs	r3, #48	; 0x30
    d91a:	cmp	fp, r7
    d91c:	strb.w	r3, [sp, #112]	; 0x70
    d920:	orr.w	r3, r2, #2
    d924:	blt.w	e684 <_svfprintf_r+0x14f4>
    d928:	bic.w	r3, r2, #128	; 0x80
    d92c:	orr.w	r3, r3, #2
    d930:	str	r3, [sp, #12]
    d932:	add	r6, sp, #192	; 0xc0
    d934:	lsrs	r3, r4, #4
    d936:	and.w	r1, r4, #15
    d93a:	orr.w	r3, r3, r5, lsl #28
    d93e:	lsrs	r2, r5, #4
    d940:	mov	r4, r3
    d942:	mov	r5, r2
    d944:	ldrb	r3, [r0, r1]
    d946:	strb.w	r3, [r6, #-1]!
    d94a:	orrs.w	r3, r4, r5
    d94e:	bne.n	d934 <_svfprintf_r+0x7a4>
    d950:	b.n	d520 <_svfprintf_r+0x390>
    d952:	ldr	r1, [sp, #40]	; 0x28
    d954:	str	r3, [sp, #52]	; 0x34
    d956:	ldr	r2, [r1, #0]
    d958:	strb.w	r2, [sp, #152]	; 0x98
    d95c:	movs	r3, #0
    d95e:	mov	r2, r1
    d960:	mov	r7, r3
    d962:	strb.w	r3, [sp, #111]	; 0x6f
    d966:	adds	r2, #4
    d968:	movs	r3, #1
    d96a:	str	r3, [sp, #16]
    d96c:	mov	fp, r7
    d96e:	str	r7, [sp, #60]	; 0x3c
    d970:	str	r2, [sp, #40]	; 0x28
    d972:	str	r3, [sp, #36]	; 0x24
    d974:	add	r6, sp, #152	; 0x98
    d976:	b.n	d53c <_svfprintf_r+0x3ac>
    d978:	str	r3, [sp, #52]	; 0x34
    d97a:	mov	fp, r5
    d97c:	cmp	r2, #0
    d97e:	beq.w	d4a8 <_svfprintf_r+0x318>
    d982:	strb.w	r1, [sp, #111]	; 0x6f
    d986:	b.n	d4a8 <_svfprintf_r+0x318>
    d988:	ldr	r3, [sp, #12]
    d98a:	orr.w	r3, r3, #64	; 0x40
    d98e:	str	r3, [sp, #12]
    d990:	ldrb.w	r3, [r8]
    d994:	b.n	d244 <_svfprintf_r+0xb4>
    d996:	ldrb.w	r3, [r8]
    d99a:	cmp	r1, #0
    d99c:	bne.w	d244 <_svfprintf_r+0xb4>
    d9a0:	movs	r2, #1
    d9a2:	movs	r1, #32
    d9a4:	b.n	d244 <_svfprintf_r+0xb4>
    d9a6:	ldr	r3, [sp, #12]
    d9a8:	orr.w	r3, r3, #1
    d9ac:	str	r3, [sp, #12]
    d9ae:	ldrb.w	r3, [r8]
    d9b2:	b.n	d244 <_svfprintf_r+0xb4>
    d9b4:	ldr	r4, [sp, #40]	; 0x28
    d9b6:	ldr	r3, [r4, #0]
    d9b8:	str	r3, [sp, #32]
    d9ba:	mov	r0, r3
    d9bc:	cmp	r0, #0
    d9be:	mov	r3, r4
    d9c0:	add.w	r3, r3, #4
    d9c4:	blt.w	d308 <_svfprintf_r+0x178>
    d9c8:	str	r3, [sp, #40]	; 0x28
    d9ca:	ldrb.w	r3, [r8]
    d9ce:	b.n	d244 <_svfprintf_r+0xb4>
    d9d0:	ldrb.w	r3, [r8]
    d9d4:	movs	r2, #1
    d9d6:	movs	r1, #43	; 0x2b
    d9d8:	b.n	d244 <_svfprintf_r+0xb4>
    d9da:	ldr	r3, [sp, #12]
    d9dc:	orr.w	r3, r3, #32
    d9e0:	str	r3, [sp, #12]
    d9e2:	ldrb.w	r3, [r8]
    d9e6:	b.n	d244 <_svfprintf_r+0xb4>
    d9e8:	ldr	r2, [sp, #40]	; 0x28
    d9ea:	str	r3, [sp, #52]	; 0x34
    d9ec:	ldr	r6, [r2, #0]
    d9ee:	movs	r4, #0
    d9f0:	strb.w	r4, [sp, #111]	; 0x6f
    d9f4:	adds	r7, r2, #4
    d9f6:	cmp	r6, #0
    d9f8:	beq.w	e634 <_svfprintf_r+0x14a4>
    d9fc:	cmp	r5, #0
    d9fe:	blt.w	e4c4 <_svfprintf_r+0x1334>
    da02:	mov	r2, r5
    da04:	mov	r1, r4
    da06:	mov	r0, r6
    da08:	bl	b8e0 <memchr>
    da0c:	cmp	r0, #0
    da0e:	beq.w	e6d8 <_svfprintf_r+0x1548>
    da12:	subs	r3, r0, r6
    da14:	str	r3, [sp, #36]	; 0x24
    da16:	mov	fp, r4
    da18:	bic.w	r3, r3, r3, asr #31
    da1c:	str	r7, [sp, #40]	; 0x28
    da1e:	str	r3, [sp, #16]
    da20:	str.w	fp, [sp, #60]	; 0x3c
    da24:	ldrb.w	r7, [sp, #111]	; 0x6f
    da28:	b.n	d534 <_svfprintf_r+0x3a4>
    da2a:	str	r3, [sp, #52]	; 0x34
    da2c:	mov	fp, r5
    da2e:	cmp	r2, #0
    da30:	beq.w	d886 <_svfprintf_r+0x6f6>
    da34:	strb.w	r1, [sp, #111]	; 0x6f
    da38:	b.n	d886 <_svfprintf_r+0x6f6>
    da3a:	str	r3, [sp, #52]	; 0x34
    da3c:	mov	fp, r5
    da3e:	cmp	r2, #0
    da40:	bne.w	e860 <_svfprintf_r+0x16d0>
    da44:	ldr	r3, [sp, #12]
    da46:	ldr	r0, [pc, #344]	; (dba0 <_svfprintf_r+0xa10>)
    da48:	lsls	r5, r3, #26
    da4a:	bmi.w	d8e4 <_svfprintf_r+0x754>
    da4e:	ldr	r3, [sp, #12]
    da50:	lsls	r4, r3, #27
    da52:	bpl.w	e2d2 <_svfprintf_r+0x1142>
    da56:	ldr	r2, [sp, #40]	; 0x28
    da58:	mov	r3, r2
    da5a:	adds	r3, #4
    da5c:	ldr	r4, [r2, #0]
    da5e:	str	r3, [sp, #40]	; 0x28
    da60:	movs	r5, #0
    da62:	b.n	d8f6 <_svfprintf_r+0x766>
    da64:	ldrb.w	r3, [r8]
    da68:	cmp	r3, #108	; 0x6c
    da6a:	beq.w	e3f2 <_svfprintf_r+0x1262>
    da6e:	ldr	r0, [sp, #12]
    da70:	orr.w	r0, r0, #16
    da74:	str	r0, [sp, #12]
    da76:	b.w	d244 <_svfprintf_r+0xb4>
    da7a:	cmp	r2, #0
    da7c:	bne.w	e858 <_svfprintf_r+0x16c8>
    da80:	ldr	r3, [sp, #12]
    da82:	lsls	r3, r3, #26
    da84:	bpl.w	e136 <_svfprintf_r+0xfa6>
    da88:	ldr	r2, [sp, #40]	; 0x28
    da8a:	ldr	r1, [sp, #28]
    da8c:	ldr	r3, [r2, #0]
    da8e:	asrs	r5, r1, #31
    da90:	mov	r0, r1
    da92:	adds	r2, #4
    da94:	mov	r1, r5
    da96:	str	r2, [sp, #40]	; 0x28
    da98:	strd	r0, r1, [r3]
    da9c:	b.w	d1de <_svfprintf_r+0x4e>
    daa0:	ldr	r0, [pc, #252]	; (dba0 <_svfprintf_r+0xa10>)
    daa2:	str	r2, [sp, #52]	; 0x34
    daa4:	cmp.w	fp, #0
    daa8:	bne.w	dd94 <_svfprintf_r+0xc04>
    daac:	mov	r7, fp
    daae:	mov.w	fp, #0
    dab2:	str.w	fp, [sp, #36]	; 0x24
    dab6:	add	r6, sp, #192	; 0xc0
    dab8:	b.n	d526 <_svfprintf_r+0x396>
    daba:	str	r3, [sp, #52]	; 0x34
    dabc:	cmp	r2, #0
    dabe:	bne.w	e850 <_svfprintf_r+0x16c0>
    dac2:	ldr	r2, [sp, #52]	; 0x34
    dac4:	cmp	r2, #0
    dac6:	beq.w	d376 <_svfprintf_r+0x1e6>
    daca:	movs	r3, #0
    dacc:	movs	r1, #1
    dace:	mov	r7, r3
    dad0:	str	r1, [sp, #16]
    dad2:	strb.w	r2, [sp, #152]	; 0x98
    dad6:	strb.w	r3, [sp, #111]	; 0x6f
    dada:	mov	fp, r3
    dadc:	str	r3, [sp, #60]	; 0x3c
    dade:	str	r1, [sp, #36]	; 0x24
    dae0:	add	r6, sp, #152	; 0x98
    dae2:	b.n	d53c <_svfprintf_r+0x3ac>
    dae4:	cmp.w	fp, #0
    dae8:	beq.w	e708 <_svfprintf_r+0x1578>
    daec:	movs	r7, #0
    daee:	movs	r4, #0
    daf0:	movs	r5, #0
    daf2:	b.n	d3dc <_svfprintf_r+0x24c>
    daf4:	ldr	r0, [pc, #168]	; (dba0 <_svfprintf_r+0xa10>)
    daf6:	str	r3, [sp, #12]
    daf8:	str	r2, [sp, #52]	; 0x34
    dafa:	orrs.w	r3, r4, r5
    dafe:	str	r7, [sp, #40]	; 0x28
    db00:	mov.w	r7, #0
    db04:	bne.w	d932 <_svfprintf_r+0x7a2>
    db08:	movs	r4, #0
    db0a:	movs	r5, #0
    db0c:	b.n	d932 <_svfprintf_r+0x7a2>
    db0e:	ldr	r4, [sp, #148]	; 0x94
    db10:	b.n	d5dc <_svfprintf_r+0x44c>
    db12:	ldr	r3, [sp, #52]	; 0x34
    db14:	cmp	r3, #101	; 0x65
    db16:	ble.w	dc6e <_svfprintf_r+0xade>
    db1a:	movs	r2, #0
    db1c:	movs	r3, #0
    db1e:	ldrd	r0, r1, [sp, #64]	; 0x40
    db22:	bl	ad88 <__aeabi_dcmpeq>
    db26:	cmp	r0, #0
    db28:	beq.w	dd98 <_svfprintf_r+0xc08>
    db2c:	ldr	r3, [sp, #144]	; 0x90
    db2e:	ldr	r2, [pc, #116]	; (dba4 <_svfprintf_r+0xa14>)
    db30:	str.w	r2, [r9]
    db34:	adds	r3, #1
    db36:	adds	r4, #1
    db38:	movs	r2, #1
    db3a:	cmp	r3, #7
    db3c:	str	r4, [sp, #148]	; 0x94
    db3e:	str	r3, [sp, #144]	; 0x90
    db40:	str.w	r2, [r9, #4]
    db44:	bgt.w	e324 <_svfprintf_r+0x1194>
    db48:	add.w	r9, r9, #8
    db4c:	ldr	r3, [sp, #116]	; 0x74
    db4e:	ldr	r2, [sp, #56]	; 0x38
    db50:	cmp	r3, r2
    db52:	blt.n	db5c <_svfprintf_r+0x9cc>
    db54:	ldr	r3, [sp, #12]
    db56:	lsls	r3, r3, #31
    db58:	bpl.w	d6bc <_svfprintf_r+0x52c>
    db5c:	ldr	r3, [sp, #144]	; 0x90
    db5e:	ldr	r1, [sp, #72]	; 0x48
    db60:	ldr	r2, [sp, #76]	; 0x4c
    db62:	str.w	r2, [r9]
    db66:	adds	r3, #1
    db68:	add	r4, r1
    db6a:	cmp	r3, #7
    db6c:	str	r4, [sp, #148]	; 0x94
    db6e:	str.w	r1, [r9, #4]
    db72:	str	r3, [sp, #144]	; 0x90
    db74:	bgt.w	e406 <_svfprintf_r+0x1276>
    db78:	add.w	r9, r9, #8
    db7c:	ldr	r3, [sp, #56]	; 0x38
    db7e:	subs	r5, r3, #1
    db80:	cmp	r5, #0
    db82:	ble.w	d6bc <_svfprintf_r+0x52c>
    db86:	ldr	r2, [pc, #32]	; (dba8 <_svfprintf_r+0xa18>)
    db88:	ldr	r3, [sp, #144]	; 0x90
    db8a:	str	r2, [sp, #44]	; 0x2c
    db8c:	cmp	r5, #16
    db8e:	ble.w	df64 <_svfprintf_r+0xdd4>
    db92:	movs	r6, #16
    db94:	ldr	r7, [sp, #24]
    db96:	ldr.w	fp, [sp, #20]
    db9a:	b.n	dbb8 <_svfprintf_r+0xa28>
    db9c:	.word	0x000131a0
    dba0:	.word	0x000131b4
    dba4:	.word	0x000131d0
    dba8:	.word	0x00013180
    dbac:	add.w	r9, r9, #8
    dbb0:	subs	r5, #16
    dbb2:	cmp	r5, #16
    dbb4:	ble.w	df64 <_svfprintf_r+0xdd4>
    dbb8:	adds	r3, #1
    dbba:	adds	r4, #16
    dbbc:	cmp	r3, #7
    dbbe:	str	r4, [sp, #148]	; 0x94
    dbc0:	str	r3, [sp, #144]	; 0x90
    dbc2:	str.w	sl, [r9]
    dbc6:	str.w	r6, [r9, #4]
    dbca:	ble.n	dbac <_svfprintf_r+0xa1c>
    dbcc:	add	r2, sp, #140	; 0x8c
    dbce:	mov	r1, fp
    dbd0:	mov	r0, r7
    dbd2:	bl	12134 <__ssprint_r>
    dbd6:	cmp	r0, #0
    dbd8:	bne.w	d384 <_svfprintf_r+0x1f4>
    dbdc:	ldr	r4, [sp, #148]	; 0x94
    dbde:	ldr	r3, [sp, #144]	; 0x90
    dbe0:	add.w	r9, sp, #192	; 0xc0
    dbe4:	b.n	dbb0 <_svfprintf_r+0xa20>
    dbe6:	ldr	r3, [sp, #32]
    dbe8:	ldr	r2, [sp, #16]
    dbea:	subs	r7, r3, r2
    dbec:	cmp	r7, #0
    dbee:	ble.w	d624 <_svfprintf_r+0x494>
    dbf2:	ldr	r2, [pc, #752]	; (dee4 <_svfprintf_r+0xd54>)
    dbf4:	ldr	r3, [sp, #144]	; 0x90
    dbf6:	str	r2, [sp, #44]	; 0x2c
    dbf8:	cmp	r7, #16
    dbfa:	ble.n	dc54 <_svfprintf_r+0xac4>
    dbfc:	mov	r2, r9
    dbfe:	mov	r1, r4
    dc00:	mov	r9, r7
    dc02:	movs	r5, #16
    dc04:	mov	r7, r6
    dc06:	ldr	r4, [sp, #24]
    dc08:	ldr	r6, [sp, #20]
    dc0a:	b.n	dc1a <_svfprintf_r+0xa8a>
    dc0c:	sub.w	r9, r9, #16
    dc10:	cmp.w	r9, #16
    dc14:	add.w	r2, r2, #8
    dc18:	ble.n	dc4c <_svfprintf_r+0xabc>
    dc1a:	adds	r3, #1
    dc1c:	adds	r1, #16
    dc1e:	cmp	r3, #7
    dc20:	str	r1, [sp, #148]	; 0x94
    dc22:	str	r3, [sp, #144]	; 0x90
    dc24:	str.w	sl, [r2]
    dc28:	str	r5, [r2, #4]
    dc2a:	ble.n	dc0c <_svfprintf_r+0xa7c>
    dc2c:	add	r2, sp, #140	; 0x8c
    dc2e:	mov	r1, r6
    dc30:	mov	r0, r4
    dc32:	bl	12134 <__ssprint_r>
    dc36:	cmp	r0, #0
    dc38:	bne.w	d384 <_svfprintf_r+0x1f4>
    dc3c:	sub.w	r9, r9, #16
    dc40:	cmp.w	r9, #16
    dc44:	ldr	r1, [sp, #148]	; 0x94
    dc46:	ldr	r3, [sp, #144]	; 0x90
    dc48:	add	r2, sp, #192	; 0xc0
    dc4a:	bgt.n	dc1a <_svfprintf_r+0xa8a>
    dc4c:	mov	r6, r7
    dc4e:	mov	r4, r1
    dc50:	mov	r7, r9
    dc52:	mov	r9, r2
    dc54:	adds	r3, #1
    dc56:	ldr	r2, [sp, #44]	; 0x2c
    dc58:	str	r3, [sp, #144]	; 0x90
    dc5a:	add	r4, r7
    dc5c:	cmp	r3, #7
    dc5e:	str	r4, [sp, #148]	; 0x94
    dc60:	stmia.w	r9, {r2, r7}
    dc64:	bgt.w	e0e2 <_svfprintf_r+0xf52>
    dc68:	add.w	r9, r9, #8
    dc6c:	b.n	d624 <_svfprintf_r+0x494>
    dc6e:	ldr	r3, [sp, #56]	; 0x38
    dc70:	ldr	r5, [sp, #144]	; 0x90
    dc72:	cmp	r3, #1
    dc74:	ble.w	e08c <_svfprintf_r+0xefc>
    dc78:	adds	r5, #1
    dc7a:	adds	r4, #1
    dc7c:	movs	r3, #1
    dc7e:	cmp	r5, #7
    dc80:	str	r4, [sp, #148]	; 0x94
    dc82:	str	r5, [sp, #144]	; 0x90
    dc84:	str.w	r6, [r9]
    dc88:	str.w	r3, [r9, #4]
    dc8c:	bgt.w	e0ae <_svfprintf_r+0xf1e>
    dc90:	add.w	r9, r9, #8
    dc94:	ldr	r2, [sp, #72]	; 0x48
    dc96:	ldr	r3, [sp, #76]	; 0x4c
    dc98:	str.w	r3, [r9]
    dc9c:	adds	r5, #1
    dc9e:	add	r4, r2
    dca0:	cmp	r5, #7
    dca2:	str	r4, [sp, #148]	; 0x94
    dca4:	str	r5, [sp, #144]	; 0x90
    dca6:	str.w	r2, [r9, #4]
    dcaa:	bgt.w	e0c8 <_svfprintf_r+0xf38>
    dcae:	add.w	r9, r9, #8
    dcb2:	movs	r3, #0
    dcb4:	movs	r2, #0
    dcb6:	ldrd	r0, r1, [sp, #64]	; 0x40
    dcba:	bl	ad88 <__aeabi_dcmpeq>
    dcbe:	ldr	r3, [sp, #56]	; 0x38
    dcc0:	cmp	r0, #0
    dcc2:	bne.w	de4c <_svfprintf_r+0xcbc>
    dcc6:	subs	r3, #1
    dcc8:	adds	r5, #1
    dcca:	adds	r6, #1
    dccc:	add	r4, r3
    dcce:	cmp	r5, #7
    dcd0:	str	r5, [sp, #144]	; 0x90
    dcd2:	str	r4, [sp, #148]	; 0x94
    dcd4:	str.w	r6, [r9]
    dcd8:	str.w	r3, [r9, #4]
    dcdc:	bgt.w	deca <_svfprintf_r+0xd3a>
    dce0:	add.w	r9, r9, #8
    dce4:	ldr	r2, [sp, #84]	; 0x54
    dce6:	str.w	r2, [r9, #4]
    dcea:	adds	r5, #1
    dcec:	add	r4, r2
    dcee:	add	r3, sp, #124	; 0x7c
    dcf0:	cmp	r5, #7
    dcf2:	str	r4, [sp, #148]	; 0x94
    dcf4:	str	r5, [sp, #144]	; 0x90
    dcf6:	str.w	r3, [r9]
    dcfa:	ble.w	d6b8 <_svfprintf_r+0x528>
    dcfe:	add	r2, sp, #140	; 0x8c
    dd00:	ldr	r1, [sp, #20]
    dd02:	ldr	r0, [sp, #24]
    dd04:	bl	12134 <__ssprint_r>
    dd08:	cmp	r0, #0
    dd0a:	bne.w	d384 <_svfprintf_r+0x1f4>
    dd0e:	ldr	r4, [sp, #148]	; 0x94
    dd10:	add.w	r9, sp, #192	; 0xc0
    dd14:	b.n	d6bc <_svfprintf_r+0x52c>
    dd16:	add	r2, sp, #140	; 0x8c
    dd18:	ldr	r1, [sp, #20]
    dd1a:	ldr	r0, [sp, #24]
    dd1c:	bl	12134 <__ssprint_r>
    dd20:	cmp	r0, #0
    dd22:	beq.w	d758 <_svfprintf_r+0x5c8>
    dd26:	b.w	d384 <_svfprintf_r+0x1f4>
    dd2a:	add	r2, sp, #140	; 0x8c
    dd2c:	ldr	r1, [sp, #20]
    dd2e:	ldr	r0, [sp, #24]
    dd30:	bl	12134 <__ssprint_r>
    dd34:	cmp	r0, #0
    dd36:	bne.w	d384 <_svfprintf_r+0x1f4>
    dd3a:	ldr	r4, [sp, #148]	; 0x94
    dd3c:	add.w	r9, sp, #192	; 0xc0
    dd40:	b.n	d696 <_svfprintf_r+0x506>
    dd42:	add	r2, sp, #140	; 0x8c
    dd44:	ldr	r1, [sp, #20]
    dd46:	ldr	r0, [sp, #24]
    dd48:	bl	12134 <__ssprint_r>
    dd4c:	cmp	r0, #0
    dd4e:	bne.w	d384 <_svfprintf_r+0x1f4>
    dd52:	ldr	r4, [sp, #148]	; 0x94
    dd54:	add.w	r9, sp, #192	; 0xc0
    dd58:	b.n	d5fc <_svfprintf_r+0x46c>
    dd5a:	add	r2, sp, #140	; 0x8c
    dd5c:	ldr	r1, [sp, #20]
    dd5e:	ldr	r0, [sp, #24]
    dd60:	bl	12134 <__ssprint_r>
    dd64:	cmp	r0, #0
    dd66:	bne.w	d384 <_svfprintf_r+0x1f4>
    dd6a:	ldr	r4, [sp, #148]	; 0x94
    dd6c:	add.w	r9, sp, #192	; 0xc0
    dd70:	b.n	d61c <_svfprintf_r+0x48c>
    dd72:	cmp.w	fp, #0
    dd76:	strb.w	r7, [sp, #111]	; 0x6f
    dd7a:	blt.w	e33c <_svfprintf_r+0x11ac>
    dd7e:	bic.w	r3, r2, #128	; 0x80
    dd82:	str	r3, [sp, #12]
    dd84:	orrs.w	r3, r4, r5
    dd88:	bne.w	d932 <_svfprintf_r+0x7a2>
    dd8c:	cmp.w	fp, #0
    dd90:	beq.w	daac <_svfprintf_r+0x91c>
    dd94:	movs	r7, #0
    dd96:	b.n	db08 <_svfprintf_r+0x978>
    dd98:	ldr	r5, [sp, #116]	; 0x74
    dd9a:	cmp	r5, #0
    dd9c:	ble.w	e342 <_svfprintf_r+0x11b2>
    dda0:	ldr	r3, [sp, #60]	; 0x3c
    dda2:	ldr	r2, [sp, #56]	; 0x38
    dda4:	cmp	r3, r2
    dda6:	it	ge
    dda8:	movge	r3, r2
    ddaa:	cmp	r3, #0
    ddac:	mov	r5, r3
    ddae:	ble.n	ddcc <_svfprintf_r+0xc3c>
    ddb0:	ldr	r3, [sp, #144]	; 0x90
    ddb2:	str.w	r6, [r9]
    ddb6:	adds	r3, #1
    ddb8:	add	r4, r5
    ddba:	cmp	r3, #7
    ddbc:	str	r4, [sp, #148]	; 0x94
    ddbe:	str.w	r5, [r9, #4]
    ddc2:	str	r3, [sp, #144]	; 0x90
    ddc4:	bgt.w	e51a <_svfprintf_r+0x138a>
    ddc8:	add.w	r9, r9, #8
    ddcc:	ldr	r3, [sp, #60]	; 0x3c
    ddce:	cmp	r5, #0
    ddd0:	it	ge
    ddd2:	subge	r3, r3, r5
    ddd4:	cmp	r3, #0
    ddd6:	mov	r5, r3
    ddd8:	ble.w	dfcc <_svfprintf_r+0xe3c>
    dddc:	ldr	r2, [pc, #260]	; (dee4 <_svfprintf_r+0xd54>)
    ddde:	ldr	r3, [sp, #144]	; 0x90
    dde0:	str	r2, [sp, #44]	; 0x2c
    dde2:	cmp	r5, #16
    dde4:	ble.w	e2ee <_svfprintf_r+0x115e>
    dde8:	mov	r2, r4
    ddea:	movs	r7, #16
    ddec:	ldr.w	fp, [sp, #24]
    ddf0:	ldr	r4, [sp, #20]
    ddf2:	b.n	de00 <_svfprintf_r+0xc70>
    ddf4:	add.w	r9, r9, #8
    ddf8:	subs	r5, #16
    ddfa:	cmp	r5, #16
    ddfc:	ble.w	e2ec <_svfprintf_r+0x115c>
    de00:	adds	r3, #1
    de02:	adds	r2, #16
    de04:	cmp	r3, #7
    de06:	str	r2, [sp, #148]	; 0x94
    de08:	str	r3, [sp, #144]	; 0x90
    de0a:	str.w	sl, [r9]
    de0e:	str.w	r7, [r9, #4]
    de12:	ble.n	ddf4 <_svfprintf_r+0xc64>
    de14:	add	r2, sp, #140	; 0x8c
    de16:	mov	r1, r4
    de18:	mov	r0, fp
    de1a:	bl	12134 <__ssprint_r>
    de1e:	cmp	r0, #0
    de20:	bne.w	d384 <_svfprintf_r+0x1f4>
    de24:	ldr	r2, [sp, #148]	; 0x94
    de26:	ldr	r3, [sp, #144]	; 0x90
    de28:	add.w	r9, sp, #192	; 0xc0
    de2c:	b.n	ddf8 <_svfprintf_r+0xc68>
    de2e:	add	r2, sp, #140	; 0x8c
    de30:	ldr	r1, [sp, #20]
    de32:	ldr	r0, [sp, #24]
    de34:	bl	12134 <__ssprint_r>
    de38:	cmp	r0, #0
    de3a:	bne.w	d384 <_svfprintf_r+0x1f4>
    de3e:	ldrb.w	r7, [sp, #111]	; 0x6f
    de42:	ldr	r4, [sp, #148]	; 0x94
    de44:	add.w	r9, sp, #192	; 0xc0
    de48:	b.w	d5dc <_svfprintf_r+0x44c>
    de4c:	subs	r6, r3, #1
    de4e:	cmp	r6, #0
    de50:	ble.w	dce4 <_svfprintf_r+0xb54>
    de54:	ldr	r3, [pc, #140]	; (dee4 <_svfprintf_r+0xd54>)
    de56:	str	r3, [sp, #44]	; 0x2c
    de58:	cmp	r6, #16
    de5a:	ble.n	deb6 <_svfprintf_r+0xd26>
    de5c:	str.w	r8, [sp, #36]	; 0x24
    de60:	movs	r7, #16
    de62:	mov	r8, r6
    de64:	ldr.w	fp, [sp, #24]
    de68:	ldr	r6, [sp, #20]
    de6a:	b.n	de7a <_svfprintf_r+0xcea>
    de6c:	sub.w	r8, r8, #16
    de70:	cmp.w	r8, #16
    de74:	add.w	r9, r9, #8
    de78:	ble.n	deb0 <_svfprintf_r+0xd20>
    de7a:	adds	r5, #1
    de7c:	adds	r4, #16
    de7e:	cmp	r5, #7
    de80:	str	r4, [sp, #148]	; 0x94
    de82:	str	r5, [sp, #144]	; 0x90
    de84:	str.w	sl, [r9]
    de88:	str.w	r7, [r9, #4]
    de8c:	ble.n	de6c <_svfprintf_r+0xcdc>
    de8e:	add	r2, sp, #140	; 0x8c
    de90:	mov	r1, r6
    de92:	mov	r0, fp
    de94:	bl	12134 <__ssprint_r>
    de98:	cmp	r0, #0
    de9a:	bne.w	d384 <_svfprintf_r+0x1f4>
    de9e:	sub.w	r8, r8, #16
    dea2:	cmp.w	r8, #16
    dea6:	ldr	r4, [sp, #148]	; 0x94
    dea8:	ldr	r5, [sp, #144]	; 0x90
    deaa:	add.w	r9, sp, #192	; 0xc0
    deae:	bgt.n	de7a <_svfprintf_r+0xcea>
    deb0:	mov	r6, r8
    deb2:	ldr.w	r8, [sp, #36]	; 0x24
    deb6:	ldr	r3, [sp, #44]	; 0x2c
    deb8:	adds	r5, #1
    deba:	add	r4, r6
    debc:	cmp	r5, #7
    debe:	str	r4, [sp, #148]	; 0x94
    dec0:	str	r5, [sp, #144]	; 0x90
    dec2:	stmia.w	r9, {r3, r6}
    dec6:	ble.w	dce0 <_svfprintf_r+0xb50>
    deca:	add	r2, sp, #140	; 0x8c
    decc:	ldr	r1, [sp, #20]
    dece:	ldr	r0, [sp, #24]
    ded0:	bl	12134 <__ssprint_r>
    ded4:	cmp	r0, #0
    ded6:	bne.w	d384 <_svfprintf_r+0x1f4>
    deda:	ldr	r4, [sp, #148]	; 0x94
    dedc:	ldr	r5, [sp, #144]	; 0x90
    dede:	add.w	r9, sp, #192	; 0xc0
    dee2:	b.n	dce4 <_svfprintf_r+0xb54>
    dee4:	.word	0x00013180
    dee8:	ldr	r1, [sp, #12]
    deea:	ands.w	r2, r1, #16
    deee:	beq.w	e298 <_svfprintf_r+0x1108>
    def2:	ldr	r0, [sp, #40]	; 0x28
    def4:	strb.w	r3, [sp, #111]	; 0x6f
    def8:	cmp.w	fp, #0
    defc:	ldr	r4, [r0, #0]
    defe:	add.w	r7, r0, #4
    df02:	mov.w	r5, #0
    df06:	blt.n	df56 <_svfprintf_r+0xdc6>
    df08:	mov	r2, r1
    df0a:	bic.w	r2, r2, #128	; 0x80
    df0e:	str	r2, [sp, #12]
    df10:	orrs.w	r2, r4, r5
    df14:	str	r7, [sp, #40]	; 0x28
    df16:	mov	r7, r3
    df18:	bne.w	d4ec <_svfprintf_r+0x35c>
    df1c:	b.n	d8bc <_svfprintf_r+0x72c>
    df1e:	ldr	r3, [sp, #12]
    df20:	lsls	r0, r3, #27
    df22:	bmi.n	df7a <_svfprintf_r+0xdea>
    df24:	ldr	r3, [sp, #12]
    df26:	lsls	r1, r3, #25
    df28:	bpl.n	df7a <_svfprintf_r+0xdea>
    df2a:	ldr	r1, [sp, #40]	; 0x28
    df2c:	ldrsh.w	r4, [r1]
    df30:	adds	r1, #4
    df32:	asrs	r5, r4, #31
    df34:	mov	r2, r4
    df36:	mov	r3, r5
    df38:	str	r1, [sp, #40]	; 0x28
    df3a:	b.w	d4c6 <_svfprintf_r+0x336>
    df3e:	ldr	r1, [sp, #40]	; 0x28
    df40:	strb.w	r3, [sp, #111]	; 0x6f
    df44:	cmp.w	fp, #0
    df48:	ldr	r4, [r1, #0]
    df4a:	add.w	r7, r1, #4
    df4e:	mov.w	r5, #0
    df52:	bge.w	e3ee <_svfprintf_r+0x125e>
    df56:	str	r7, [sp, #40]	; 0x28
    df58:	mov	r7, r3
    df5a:	orrs.w	r3, r4, r5
    df5e:	bne.w	d4ec <_svfprintf_r+0x35c>
    df62:	b.n	d8c6 <_svfprintf_r+0x736>
    df64:	adds	r3, #1
    df66:	ldr	r2, [sp, #44]	; 0x2c
    df68:	str	r3, [sp, #144]	; 0x90
    df6a:	add	r4, r5
    df6c:	cmp	r3, #7
    df6e:	str	r4, [sp, #148]	; 0x94
    df70:	stmia.w	r9, {r2, r5}
    df74:	ble.w	d6b8 <_svfprintf_r+0x528>
    df78:	b.n	dcfe <_svfprintf_r+0xb6e>
    df7a:	ldr	r2, [sp, #40]	; 0x28
    df7c:	ldr	r4, [r2, #0]
    df7e:	mov	r3, r2
    df80:	adds	r3, #4
    df82:	asrs	r5, r4, #31
    df84:	mov	r2, r4
    df86:	str	r3, [sp, #40]	; 0x28
    df88:	cmp	r2, #0
    df8a:	mov	r3, r5
    df8c:	sbcs.w	r3, r3, #0
    df90:	bge.w	d4d0 <_svfprintf_r+0x340>
    df94:	negs	r4, r4
    df96:	mov.w	r7, #45	; 0x2d
    df9a:	sbc.w	r5, r5, r5, lsl #1
    df9e:	cmp.w	fp, #0
    dfa2:	strb.w	r7, [sp, #111]	; 0x6f
    dfa6:	blt.w	d4ec <_svfprintf_r+0x35c>
    dfaa:	ldr	r3, [sp, #12]
    dfac:	bic.w	r3, r3, #128	; 0x80
    dfb0:	str	r3, [sp, #12]
    dfb2:	b.w	d4ec <_svfprintf_r+0x35c>
    dfb6:	add	r2, sp, #140	; 0x8c
    dfb8:	ldr	r1, [sp, #20]
    dfba:	ldr	r0, [sp, #24]
    dfbc:	bl	12134 <__ssprint_r>
    dfc0:	cmp	r0, #0
    dfc2:	bne.w	d384 <_svfprintf_r+0x1f4>
    dfc6:	ldr	r4, [sp, #148]	; 0x94
    dfc8:	add.w	r9, sp, #192	; 0xc0
    dfcc:	ldr	r2, [sp, #60]	; 0x3c
    dfce:	ldr	r3, [sp, #116]	; 0x74
    dfd0:	add	r2, r6
    dfd2:	mov	r7, r2
    dfd4:	ldr	r2, [sp, #56]	; 0x38
    dfd6:	cmp	r3, r2
    dfd8:	blt.n	e06a <_svfprintf_r+0xeda>
    dfda:	ldr	r2, [sp, #12]
    dfdc:	lsls	r5, r2, #31
    dfde:	bmi.n	e06a <_svfprintf_r+0xeda>
    dfe0:	ldr	r1, [sp, #56]	; 0x38
    dfe2:	add	r6, r1
    dfe4:	subs	r5, r6, r7
    dfe6:	subs	r3, r1, r3
    dfe8:	cmp	r5, r3
    dfea:	it	ge
    dfec:	movge	r5, r3
    dfee:	cmp	r5, #0
    dff0:	mov	r6, r5
    dff2:	ble.n	e010 <_svfprintf_r+0xe80>
    dff4:	ldr	r2, [sp, #144]	; 0x90
    dff6:	str.w	r7, [r9]
    dffa:	adds	r2, #1
    dffc:	add	r4, r5
    dffe:	cmp	r2, #7
    e000:	str	r4, [sp, #148]	; 0x94
    e002:	str.w	r5, [r9, #4]
    e006:	str	r2, [sp, #144]	; 0x90
    e008:	bgt.w	e608 <_svfprintf_r+0x1478>
    e00c:	add.w	r9, r9, #8
    e010:	cmp	r6, #0
    e012:	ite	ge
    e014:	subge	r5, r3, r6
    e016:	movlt	r5, r3
    e018:	cmp	r5, #0
    e01a:	ble.w	d6bc <_svfprintf_r+0x52c>
    e01e:	ldr	r2, [pc, #744]	; (e308 <_svfprintf_r+0x1178>)
    e020:	ldr	r3, [sp, #144]	; 0x90
    e022:	str	r2, [sp, #44]	; 0x2c
    e024:	cmp	r5, #16
    e026:	ble.n	df64 <_svfprintf_r+0xdd4>
    e028:	movs	r6, #16
    e02a:	ldr	r7, [sp, #24]
    e02c:	ldr.w	fp, [sp, #20]
    e030:	b.n	e03c <_svfprintf_r+0xeac>
    e032:	add.w	r9, r9, #8
    e036:	subs	r5, #16
    e038:	cmp	r5, #16
    e03a:	ble.n	df64 <_svfprintf_r+0xdd4>
    e03c:	adds	r3, #1
    e03e:	adds	r4, #16
    e040:	cmp	r3, #7
    e042:	str	r4, [sp, #148]	; 0x94
    e044:	str	r3, [sp, #144]	; 0x90
    e046:	str.w	sl, [r9]
    e04a:	str.w	r6, [r9, #4]
    e04e:	ble.n	e032 <_svfprintf_r+0xea2>
    e050:	add	r2, sp, #140	; 0x8c
    e052:	mov	r1, fp
    e054:	mov	r0, r7
    e056:	bl	12134 <__ssprint_r>
    e05a:	cmp	r0, #0
    e05c:	bne.w	d384 <_svfprintf_r+0x1f4>
    e060:	ldr	r4, [sp, #148]	; 0x94
    e062:	ldr	r3, [sp, #144]	; 0x90
    e064:	add.w	r9, sp, #192	; 0xc0
    e068:	b.n	e036 <_svfprintf_r+0xea6>
    e06a:	ldr	r2, [sp, #144]	; 0x90
    e06c:	ldr	r0, [sp, #72]	; 0x48
    e06e:	ldr	r1, [sp, #76]	; 0x4c
    e070:	str.w	r1, [r9]
    e074:	adds	r2, #1
    e076:	add	r4, r0
    e078:	cmp	r2, #7
    e07a:	str	r4, [sp, #148]	; 0x94
    e07c:	str.w	r0, [r9, #4]
    e080:	str	r2, [sp, #144]	; 0x90
    e082:	bgt.w	e5ee <_svfprintf_r+0x145e>
    e086:	add.w	r9, r9, #8
    e08a:	b.n	dfe0 <_svfprintf_r+0xe50>
    e08c:	ldr	r3, [sp, #12]
    e08e:	lsls	r0, r3, #31
    e090:	bmi.w	dc78 <_svfprintf_r+0xae8>
    e094:	adds	r5, #1
    e096:	adds	r4, #1
    e098:	movs	r3, #1
    e09a:	cmp	r5, #7
    e09c:	str	r4, [sp, #148]	; 0x94
    e09e:	str	r5, [sp, #144]	; 0x90
    e0a0:	str.w	r6, [r9]
    e0a4:	str.w	r3, [r9, #4]
    e0a8:	ble.w	dce0 <_svfprintf_r+0xb50>
    e0ac:	b.n	deca <_svfprintf_r+0xd3a>
    e0ae:	add	r2, sp, #140	; 0x8c
    e0b0:	ldr	r1, [sp, #20]
    e0b2:	ldr	r0, [sp, #24]
    e0b4:	bl	12134 <__ssprint_r>
    e0b8:	cmp	r0, #0
    e0ba:	bne.w	d384 <_svfprintf_r+0x1f4>
    e0be:	ldr	r4, [sp, #148]	; 0x94
    e0c0:	ldr	r5, [sp, #144]	; 0x90
    e0c2:	add.w	r9, sp, #192	; 0xc0
    e0c6:	b.n	dc94 <_svfprintf_r+0xb04>
    e0c8:	add	r2, sp, #140	; 0x8c
    e0ca:	ldr	r1, [sp, #20]
    e0cc:	ldr	r0, [sp, #24]
    e0ce:	bl	12134 <__ssprint_r>
    e0d2:	cmp	r0, #0
    e0d4:	bne.w	d384 <_svfprintf_r+0x1f4>
    e0d8:	ldr	r4, [sp, #148]	; 0x94
    e0da:	ldr	r5, [sp, #144]	; 0x90
    e0dc:	add.w	r9, sp, #192	; 0xc0
    e0e0:	b.n	dcb2 <_svfprintf_r+0xb22>
    e0e2:	add	r2, sp, #140	; 0x8c
    e0e4:	ldr	r1, [sp, #20]
    e0e6:	ldr	r0, [sp, #24]
    e0e8:	bl	12134 <__ssprint_r>
    e0ec:	cmp	r0, #0
    e0ee:	bne.w	d384 <_svfprintf_r+0x1f4>
    e0f2:	ldr	r4, [sp, #148]	; 0x94
    e0f4:	add.w	r9, sp, #192	; 0xc0
    e0f8:	b.w	d624 <_svfprintf_r+0x494>
    e0fc:	ldr	r1, [sp, #12]
    e0fe:	ands.w	r3, r1, #64	; 0x40
    e102:	beq.w	e278 <_svfprintf_r+0x10e8>
    e106:	ldr	r0, [sp, #40]	; 0x28
    e108:	strb.w	r2, [sp, #111]	; 0x6f
    e10c:	mov	r3, r0
    e10e:	cmp.w	fp, #0
    e112:	add.w	r3, r3, #4
    e116:	ldrh	r4, [r0, #0]
    e118:	mov.w	r5, #0
    e11c:	blt.w	e4a0 <_svfprintf_r+0x1310>
    e120:	bic.w	r1, r1, #128	; 0x80
    e124:	str	r1, [sp, #12]
    e126:	orrs.w	r1, r4, r5
    e12a:	str	r3, [sp, #40]	; 0x28
    e12c:	beq.w	dae4 <_svfprintf_r+0x954>
    e130:	mov	r7, r2
    e132:	b.w	d3dc <_svfprintf_r+0x24c>
    e136:	ldr	r3, [sp, #12]
    e138:	lsls	r7, r3, #27
    e13a:	bmi.n	e154 <_svfprintf_r+0xfc4>
    e13c:	ldr	r3, [sp, #12]
    e13e:	lsls	r6, r3, #25
    e140:	bpl.n	e154 <_svfprintf_r+0xfc4>
    e142:	ldr	r2, [sp, #40]	; 0x28
    e144:	ldr	r3, [r2, #0]
    e146:	adds	r2, #4
    e148:	str	r2, [sp, #40]	; 0x28
    e14a:	ldrh.w	r2, [sp, #28]
    e14e:	strh	r2, [r3, #0]
    e150:	b.w	d1de <_svfprintf_r+0x4e>
    e154:	ldr	r2, [sp, #40]	; 0x28
    e156:	ldr	r3, [r2, #0]
    e158:	adds	r2, #4
    e15a:	str	r2, [sp, #40]	; 0x28
    e15c:	ldr	r2, [sp, #28]
    e15e:	str	r2, [r3, #0]
    e160:	b.w	d1de <_svfprintf_r+0x4e>
    e164:	ldrd	r0, r1, [sp, #64]	; 0x40
    e168:	mov	r2, r0
    e16a:	mov	r3, r1
    e16c:	bl	adec <__aeabi_dcmpun>
    e170:	cmp	r0, #0
    e172:	bne.w	e770 <_svfprintf_r+0x15e0>
    e176:	ldr	r3, [sp, #52]	; 0x34
    e178:	cmp.w	fp, #4294967295
    e17c:	bic.w	r7, r3, #32
    e180:	beq.w	e652 <_svfprintf_r+0x14c2>
    e184:	cmp	r7, #71	; 0x47
    e186:	beq.w	e48e <_svfprintf_r+0x12fe>
    e18a:	ldr	r3, [sp, #68]	; 0x44
    e18c:	ldr	r2, [sp, #12]
    e18e:	cmp	r3, #0
    e190:	orr.w	r2, r2, #256	; 0x100
    e194:	str	r2, [sp, #44]	; 0x2c
    e196:	blt.w	e68a <_svfprintf_r+0x14fa>
    e19a:	vldr	d7, [sp, #64]	; 0x40
    e19e:	vstr	d7, [sp, #96]	; 0x60
    e1a2:	movs	r3, #0
    e1a4:	str	r3, [sp, #16]
    e1a6:	ldr	r3, [sp, #52]	; 0x34
    e1a8:	cmp	r3, #102	; 0x66
    e1aa:	beq.w	e658 <_svfprintf_r+0x14c8>
    e1ae:	cmp	r3, #70	; 0x46
    e1b0:	beq.w	e43e <_svfprintf_r+0x12ae>
    e1b4:	cmp	r7, #69	; 0x45
    e1b6:	ite	eq
    e1b8:	addeq.w	r5, fp, #1
    e1bc:	movne	r5, fp
    e1be:	add	r2, sp, #132	; 0x84
    e1c0:	add	r3, sp, #120	; 0x78
    e1c2:	str	r2, [sp, #4]
    e1c4:	str	r3, [sp, #0]
    e1c6:	mov	r2, r5
    e1c8:	add	r3, sp, #116	; 0x74
    e1ca:	movs	r1, #2
    e1cc:	vldr	d0, [sp, #96]	; 0x60
    e1d0:	ldr	r0, [sp, #24]
    e1d2:	bl	f998 <_dtoa_r>
    e1d6:	ldr	r3, [sp, #52]	; 0x34
    e1d8:	cmp	r3, #103	; 0x67
    e1da:	mov	r6, r0
    e1dc:	bne.w	e6b6 <_svfprintf_r+0x1526>
    e1e0:	ldr	r3, [sp, #12]
    e1e2:	lsls	r2, r3, #31
    e1e4:	bpl.w	e75a <_svfprintf_r+0x15ca>
    e1e8:	adds	r4, r6, r5
    e1ea:	movs	r2, #0
    e1ec:	movs	r3, #0
    e1ee:	ldrd	r0, r1, [sp, #96]	; 0x60
    e1f2:	bl	ad88 <__aeabi_dcmpeq>
    e1f6:	cmp	r0, #0
    e1f8:	bne.w	e516 <_svfprintf_r+0x1386>
    e1fc:	ldr	r3, [sp, #132]	; 0x84
    e1fe:	cmp	r4, r3
    e200:	bls.n	e210 <_svfprintf_r+0x1080>
    e202:	movs	r1, #48	; 0x30
    e204:	adds	r2, r3, #1
    e206:	str	r2, [sp, #132]	; 0x84
    e208:	strb	r1, [r3, #0]
    e20a:	ldr	r3, [sp, #132]	; 0x84
    e20c:	cmp	r4, r3
    e20e:	bhi.n	e204 <_svfprintf_r+0x1074>
    e210:	subs	r3, r3, r6
    e212:	cmp	r7, #71	; 0x47
    e214:	str	r3, [sp, #56]	; 0x38
    e216:	beq.w	e508 <_svfprintf_r+0x1378>
    e21a:	ldr	r3, [sp, #52]	; 0x34
    e21c:	cmp	r3, #101	; 0x65
    e21e:	ble.w	e6d4 <_svfprintf_r+0x1544>
    e222:	ldr	r3, [sp, #52]	; 0x34
    e224:	cmp	r3, #102	; 0x66
    e226:	ldr	r3, [sp, #116]	; 0x74
    e228:	str	r3, [sp, #60]	; 0x3c
    e22a:	beq.w	e6ee <_svfprintf_r+0x155e>
    e22e:	ldr	r2, [sp, #60]	; 0x3c
    e230:	ldr	r1, [sp, #56]	; 0x38
    e232:	cmp	r2, r1
    e234:	blt.w	e69c <_svfprintf_r+0x150c>
    e238:	ldr	r3, [sp, #12]
    e23a:	lsls	r1, r3, #31
    e23c:	bmi.w	e75e <_svfprintf_r+0x15ce>
    e240:	bic.w	r3, r2, r2, asr #31
    e244:	str	r2, [sp, #36]	; 0x24
    e246:	movs	r2, #103	; 0x67
    e248:	str	r2, [sp, #52]	; 0x34
    e24a:	ldr	r2, [sp, #16]
    e24c:	cmp	r2, #0
    e24e:	bne.w	e4b0 <_svfprintf_r+0x1320>
    e252:	str	r3, [sp, #16]
    e254:	ldr	r3, [sp, #44]	; 0x2c
    e256:	str	r3, [sp, #12]
    e258:	mov	fp, r2
    e25a:	ldrb.w	r7, [sp, #111]	; 0x6f
    e25e:	b.w	d534 <_svfprintf_r+0x3a4>
    e262:	bic.w	r7, r7, #7
    e266:	vldr	d7, [r7]
    e26a:	add.w	r3, r7, #8
    e26e:	vstr	d7, [sp, #64]	; 0x40
    e272:	str	r3, [sp, #40]	; 0x28
    e274:	b.w	d78c <_svfprintf_r+0x5fc>
    e278:	ldr	r1, [sp, #40]	; 0x28
    e27a:	strb.w	r3, [sp, #111]	; 0x6f
    e27e:	cmp.w	fp, #0
    e282:	ldr	r4, [r1, #0]
    e284:	add.w	r7, r1, #4
    e288:	mov.w	r5, #0
    e28c:	bge.w	e3e8 <_svfprintf_r+0x1258>
    e290:	str	r7, [sp, #40]	; 0x28
    e292:	movs	r7, #0
    e294:	b.w	d3dc <_svfprintf_r+0x24c>
    e298:	ldr	r1, [sp, #12]
    e29a:	ands.w	r3, r1, #64	; 0x40
    e29e:	beq.w	df3e <_svfprintf_r+0xdae>
    e2a2:	ldr	r0, [sp, #40]	; 0x28
    e2a4:	strb.w	r2, [sp, #111]	; 0x6f
    e2a8:	mov	r3, r0
    e2aa:	cmp.w	fp, #0
    e2ae:	add.w	r3, r3, #4
    e2b2:	ldrh	r4, [r0, #0]
    e2b4:	mov.w	r5, #0
    e2b8:	blt.w	e49a <_svfprintf_r+0x130a>
    e2bc:	bic.w	r1, r1, #128	; 0x80
    e2c0:	str	r1, [sp, #12]
    e2c2:	orrs.w	r1, r4, r5
    e2c6:	str	r3, [sp, #40]	; 0x28
    e2c8:	mov	r7, r2
    e2ca:	bne.w	d4ec <_svfprintf_r+0x35c>
    e2ce:	b.w	d8bc <_svfprintf_r+0x72c>
    e2d2:	ldr	r3, [sp, #12]
    e2d4:	ldr	r2, [sp, #40]	; 0x28
    e2d6:	tst.w	r3, #64	; 0x40
    e2da:	mov	r3, r2
    e2dc:	beq.w	e4a4 <_svfprintf_r+0x1314>
    e2e0:	adds	r3, #4
    e2e2:	ldrh	r4, [r2, #0]
    e2e4:	str	r3, [sp, #40]	; 0x28
    e2e6:	movs	r5, #0
    e2e8:	b.w	d8f6 <_svfprintf_r+0x766>
    e2ec:	mov	r4, r2
    e2ee:	adds	r3, #1
    e2f0:	ldr	r2, [sp, #44]	; 0x2c
    e2f2:	str	r3, [sp, #144]	; 0x90
    e2f4:	add	r4, r5
    e2f6:	cmp	r3, #7
    e2f8:	str	r4, [sp, #148]	; 0x94
    e2fa:	stmia.w	r9, {r2, r5}
    e2fe:	bgt.w	dfb6 <_svfprintf_r+0xe26>
    e302:	add.w	r9, r9, #8
    e306:	b.n	dfcc <_svfprintf_r+0xe3c>
    e308:	.word	0x00013180
    e30c:	movs	r7, #0
    e30e:	cmp	fp, r7
    e310:	strb.w	r7, [sp, #111]	; 0x6f
    e314:	blt.w	db08 <_svfprintf_r+0x978>
    e318:	ldr	r3, [sp, #12]
    e31a:	bic.w	r3, r3, #128	; 0x80
    e31e:	str	r3, [sp, #12]
    e320:	b.w	daa4 <_svfprintf_r+0x914>
    e324:	add	r2, sp, #140	; 0x8c
    e326:	ldr	r1, [sp, #20]
    e328:	ldr	r0, [sp, #24]
    e32a:	bl	12134 <__ssprint_r>
    e32e:	cmp	r0, #0
    e330:	bne.w	d384 <_svfprintf_r+0x1f4>
    e334:	ldr	r4, [sp, #148]	; 0x94
    e336:	add.w	r9, sp, #192	; 0xc0
    e33a:	b.n	db4c <_svfprintf_r+0x9bc>
    e33c:	ldr	r7, [sp, #40]	; 0x28
    e33e:	b.w	dafa <_svfprintf_r+0x96a>
    e342:	ldr	r3, [sp, #144]	; 0x90
    e344:	ldr	r2, [pc, #736]	; (e628 <_svfprintf_r+0x1498>)
    e346:	str.w	r2, [r9]
    e34a:	adds	r3, #1
    e34c:	adds	r4, #1
    e34e:	movs	r2, #1
    e350:	cmp	r3, #7
    e352:	str	r4, [sp, #148]	; 0x94
    e354:	str	r3, [sp, #144]	; 0x90
    e356:	str.w	r2, [r9, #4]
    e35a:	bgt.w	e474 <_svfprintf_r+0x12e4>
    e35e:	add.w	r9, r9, #8
    e362:	cbnz	r5, e370 <_svfprintf_r+0x11e0>
    e364:	ldr	r3, [sp, #56]	; 0x38
    e366:	cbnz	r3, e370 <_svfprintf_r+0x11e0>
    e368:	ldr	r3, [sp, #12]
    e36a:	lsls	r7, r3, #31
    e36c:	bpl.w	d6bc <_svfprintf_r+0x52c>
    e370:	ldr	r3, [sp, #144]	; 0x90
    e372:	ldr	r1, [sp, #72]	; 0x48
    e374:	ldr	r2, [sp, #76]	; 0x4c
    e376:	str.w	r2, [r9]
    e37a:	adds	r3, #1
    e37c:	add	r4, r1
    e37e:	cmp	r3, #7
    e380:	str	r4, [sp, #148]	; 0x94
    e382:	str.w	r1, [r9, #4]
    e386:	str	r3, [sp, #144]	; 0x90
    e388:	bgt.w	e726 <_svfprintf_r+0x1596>
    e38c:	add.w	r9, r9, #8
    e390:	negs	r5, r5
    e392:	cmp	r5, #0
    e394:	ble.w	e4ec <_svfprintf_r+0x135c>
    e398:	ldr	r2, [pc, #656]	; (e62c <_svfprintf_r+0x149c>)
    e39a:	str	r2, [sp, #44]	; 0x2c
    e39c:	cmp	r5, #16
    e39e:	ble.w	e534 <_svfprintf_r+0x13a4>
    e3a2:	mov	r2, r4
    e3a4:	movs	r7, #16
    e3a6:	ldr.w	fp, [sp, #24]
    e3aa:	ldr	r4, [sp, #20]
    e3ac:	b.n	e3ba <_svfprintf_r+0x122a>
    e3ae:	add.w	r9, r9, #8
    e3b2:	subs	r5, #16
    e3b4:	cmp	r5, #16
    e3b6:	ble.w	e532 <_svfprintf_r+0x13a2>
    e3ba:	adds	r3, #1
    e3bc:	adds	r2, #16
    e3be:	cmp	r3, #7
    e3c0:	str	r2, [sp, #148]	; 0x94
    e3c2:	str	r3, [sp, #144]	; 0x90
    e3c4:	str.w	sl, [r9]
    e3c8:	str.w	r7, [r9, #4]
    e3cc:	ble.n	e3ae <_svfprintf_r+0x121e>
    e3ce:	add	r2, sp, #140	; 0x8c
    e3d0:	mov	r1, r4
    e3d2:	mov	r0, fp
    e3d4:	bl	12134 <__ssprint_r>
    e3d8:	cmp	r0, #0
    e3da:	bne.w	d384 <_svfprintf_r+0x1f4>
    e3de:	ldr	r2, [sp, #148]	; 0x94
    e3e0:	ldr	r3, [sp, #144]	; 0x90
    e3e2:	add.w	r9, sp, #192	; 0xc0
    e3e6:	b.n	e3b2 <_svfprintf_r+0x1222>
    e3e8:	ldr	r2, [sp, #12]
    e3ea:	b.w	d860 <_svfprintf_r+0x6d0>
    e3ee:	ldr	r2, [sp, #12]
    e3f0:	b.n	df0a <_svfprintf_r+0xd7a>
    e3f2:	ldr	r3, [sp, #12]
    e3f4:	orr.w	r3, r3, #32
    e3f8:	str	r3, [sp, #12]
    e3fa:	add.w	r8, r8, #1
    e3fe:	ldrb.w	r3, [r8]
    e402:	b.w	d244 <_svfprintf_r+0xb4>
    e406:	add	r2, sp, #140	; 0x8c
    e408:	ldr	r1, [sp, #20]
    e40a:	ldr	r0, [sp, #24]
    e40c:	bl	12134 <__ssprint_r>
    e410:	cmp	r0, #0
    e412:	bne.w	d384 <_svfprintf_r+0x1f4>
    e416:	ldr	r4, [sp, #148]	; 0x94
    e418:	add.w	r9, sp, #192	; 0xc0
    e41c:	b.w	db7c <_svfprintf_r+0x9ec>
    e420:	movs	r1, #64	; 0x40
    e422:	ldr	r0, [sp, #24]
    e424:	bl	b338 <_malloc_r>
    e428:	ldr	r2, [sp, #20]
    e42a:	str	r0, [r2, #0]
    e42c:	str	r0, [r2, #16]
    e42e:	cmp	r0, #0
    e430:	beq.w	e81a <_svfprintf_r+0x168a>
    e434:	ldr	r2, [sp, #20]
    e436:	movs	r3, #64	; 0x40
    e438:	str	r3, [r2, #20]
    e43a:	b.w	d1be <_svfprintf_r+0x2e>
    e43e:	add	r2, sp, #132	; 0x84
    e440:	add	r3, sp, #120	; 0x78
    e442:	str	r2, [sp, #4]
    e444:	str	r3, [sp, #0]
    e446:	mov	r2, fp
    e448:	add	r3, sp, #116	; 0x74
    e44a:	movs	r1, #3
    e44c:	vldr	d0, [sp, #96]	; 0x60
    e450:	ldr	r0, [sp, #24]
    e452:	bl	f998 <_dtoa_r>
    e456:	mov	r5, fp
    e458:	mov	r6, r0
    e45a:	ldr	r3, [sp, #52]	; 0x34
    e45c:	cmp	r3, #70	; 0x46
    e45e:	add.w	r4, r6, r5
    e462:	bne.w	e1ea <_svfprintf_r+0x105a>
    e466:	ldrb	r3, [r6, #0]
    e468:	cmp	r3, #48	; 0x30
    e46a:	beq.w	e77c <_svfprintf_r+0x15ec>
    e46e:	ldr	r5, [sp, #116]	; 0x74
    e470:	add	r4, r5
    e472:	b.n	e1ea <_svfprintf_r+0x105a>
    e474:	add	r2, sp, #140	; 0x8c
    e476:	ldr	r1, [sp, #20]
    e478:	ldr	r0, [sp, #24]
    e47a:	bl	12134 <__ssprint_r>
    e47e:	cmp	r0, #0
    e480:	bne.w	d384 <_svfprintf_r+0x1f4>
    e484:	ldr	r5, [sp, #116]	; 0x74
    e486:	ldr	r4, [sp, #148]	; 0x94
    e488:	add.w	r9, sp, #192	; 0xc0
    e48c:	b.n	e362 <_svfprintf_r+0x11d2>
    e48e:	cmp.w	fp, #0
    e492:	it	eq
    e494:	moveq.w	fp, #1
    e498:	b.n	e18a <_svfprintf_r+0xffa>
    e49a:	str	r3, [sp, #40]	; 0x28
    e49c:	mov	r7, r2
    e49e:	b.n	df5a <_svfprintf_r+0xdca>
    e4a0:	str	r3, [sp, #40]	; 0x28
    e4a2:	b.n	e292 <_svfprintf_r+0x1102>
    e4a4:	adds	r3, #4
    e4a6:	ldr	r4, [r2, #0]
    e4a8:	str	r3, [sp, #40]	; 0x28
    e4aa:	movs	r5, #0
    e4ac:	b.w	d8f6 <_svfprintf_r+0x766>
    e4b0:	movs	r7, #45	; 0x2d
    e4b2:	str	r3, [sp, #16]
    e4b4:	ldr	r3, [sp, #44]	; 0x2c
    e4b6:	str	r3, [sp, #12]
    e4b8:	strb.w	r7, [sp, #111]	; 0x6f
    e4bc:	mov.w	fp, #0
    e4c0:	b.w	d536 <_svfprintf_r+0x3a6>
    e4c4:	mov	r0, r6
    e4c6:	bl	bf80 <strlen>
    e4ca:	mov	fp, r4
    e4cc:	mov	r3, r0
    e4ce:	str	r0, [sp, #36]	; 0x24
    e4d0:	b.w	da18 <_svfprintf_r+0x888>
    e4d4:	add	r2, sp, #140	; 0x8c
    e4d6:	ldr	r1, [sp, #20]
    e4d8:	ldr	r0, [sp, #24]
    e4da:	bl	12134 <__ssprint_r>
    e4de:	cmp	r0, #0
    e4e0:	bne.w	d384 <_svfprintf_r+0x1f4>
    e4e4:	ldr	r4, [sp, #148]	; 0x94
    e4e6:	ldr	r3, [sp, #144]	; 0x90
    e4e8:	add.w	r9, sp, #192	; 0xc0
    e4ec:	ldr	r1, [sp, #56]	; 0x38
    e4ee:	str.w	r6, [r9]
    e4f2:	adds	r3, #1
    e4f4:	add	r4, r1
    e4f6:	cmp	r3, #7
    e4f8:	str	r4, [sp, #148]	; 0x94
    e4fa:	str	r3, [sp, #144]	; 0x90
    e4fc:	str.w	r1, [r9, #4]
    e500:	ble.w	d6b8 <_svfprintf_r+0x528>
    e504:	b.w	dcfe <_svfprintf_r+0xb6e>
    e508:	ldr	r3, [sp, #116]	; 0x74
    e50a:	adds	r5, r3, #3
    e50c:	blt.n	e54c <_svfprintf_r+0x13bc>
    e50e:	cmp	fp, r3
    e510:	blt.n	e54c <_svfprintf_r+0x13bc>
    e512:	str	r3, [sp, #60]	; 0x3c
    e514:	b.n	e22e <_svfprintf_r+0x109e>
    e516:	mov	r3, r4
    e518:	b.n	e210 <_svfprintf_r+0x1080>
    e51a:	add	r2, sp, #140	; 0x8c
    e51c:	ldr	r1, [sp, #20]
    e51e:	ldr	r0, [sp, #24]
    e520:	bl	12134 <__ssprint_r>
    e524:	cmp	r0, #0
    e526:	bne.w	d384 <_svfprintf_r+0x1f4>
    e52a:	ldr	r4, [sp, #148]	; 0x94
    e52c:	add.w	r9, sp, #192	; 0xc0
    e530:	b.n	ddcc <_svfprintf_r+0xc3c>
    e532:	mov	r4, r2
    e534:	adds	r3, #1
    e536:	ldr	r2, [sp, #44]	; 0x2c
    e538:	str	r3, [sp, #144]	; 0x90
    e53a:	add	r4, r5
    e53c:	cmp	r3, #7
    e53e:	str	r4, [sp, #148]	; 0x94
    e540:	stmia.w	r9, {r2, r5}
    e544:	bgt.n	e4d4 <_svfprintf_r+0x1344>
    e546:	add.w	r9, r9, #8
    e54a:	b.n	e4ec <_svfprintf_r+0x135c>
    e54c:	ldr	r2, [sp, #52]	; 0x34
    e54e:	subs	r2, #2
    e550:	str	r2, [sp, #52]	; 0x34
    e552:	subs	r3, #1
    e554:	cmp	r3, #0
    e556:	ldrb.w	r2, [sp, #52]	; 0x34
    e55a:	str	r3, [sp, #116]	; 0x74
    e55c:	it	lt
    e55e:	neglt	r3, r3
    e560:	strb.w	r2, [sp, #124]	; 0x7c
    e564:	ite	lt
    e566:	movlt	r2, #45	; 0x2d
    e568:	movge	r2, #43	; 0x2b
    e56a:	cmp	r3, #9
    e56c:	strb.w	r2, [sp, #125]	; 0x7d
    e570:	ble.w	e74a <_svfprintf_r+0x15ba>
    e574:	add.w	r0, sp, #139	; 0x8b
    e578:	mov	r4, r0
    e57a:	ldr	r2, [pc, #180]	; (e630 <_svfprintf_r+0x14a0>)
    e57c:	smull	r2, r1, r2, r3
    e580:	asrs	r2, r3, #31
    e582:	rsb	r2, r2, r1, asr #2
    e586:	add.w	r1, r2, r2, lsl #2
    e58a:	sub.w	r3, r3, r1, lsl #1
    e58e:	add.w	r1, r3, #48	; 0x30
    e592:	cmp	r2, #9
    e594:	mov	r3, r2
    e596:	strb.w	r1, [r4, #-1]!
    e59a:	bgt.n	e57a <_svfprintf_r+0x13ea>
    e59c:	mov	r1, r4
    e59e:	adds	r3, #48	; 0x30
    e5a0:	uxtb	r2, r3
    e5a2:	strb.w	r2, [r1, #-1]!
    e5a6:	cmp	r0, r1
    e5a8:	bls.w	e814 <_svfprintf_r+0x1684>
    e5ac:	add.w	r1, sp, #126	; 0x7e
    e5b0:	mov	r3, r4
    e5b2:	b.n	e5b8 <_svfprintf_r+0x1428>
    e5b4:	ldrb.w	r2, [r3], #1
    e5b8:	strb.w	r2, [r1], #1
    e5bc:	cmp	r0, r3
    e5be:	bne.n	e5b4 <_svfprintf_r+0x1424>
    e5c0:	adds	r3, r0, #1
    e5c2:	subs	r3, r3, r4
    e5c4:	add.w	r2, sp, #126	; 0x7e
    e5c8:	add	r3, r2
    e5ca:	add	r2, sp, #124	; 0x7c
    e5cc:	subs	r3, r3, r2
    e5ce:	ldr	r2, [sp, #56]	; 0x38
    e5d0:	str	r3, [sp, #84]	; 0x54
    e5d2:	cmp	r2, #1
    e5d4:	add	r3, r2
    e5d6:	str	r3, [sp, #36]	; 0x24
    e5d8:	ble.w	e7aa <_svfprintf_r+0x161a>
    e5dc:	ldr	r3, [sp, #36]	; 0x24
    e5de:	ldr	r2, [sp, #72]	; 0x48
    e5e0:	add	r3, r2
    e5e2:	movs	r2, #0
    e5e4:	str	r3, [sp, #36]	; 0x24
    e5e6:	str	r2, [sp, #60]	; 0x3c
    e5e8:	bic.w	r3, r3, r3, asr #31
    e5ec:	b.n	e24a <_svfprintf_r+0x10ba>
    e5ee:	add	r2, sp, #140	; 0x8c
    e5f0:	ldr	r1, [sp, #20]
    e5f2:	ldr	r0, [sp, #24]
    e5f4:	bl	12134 <__ssprint_r>
    e5f8:	cmp	r0, #0
    e5fa:	bne.w	d384 <_svfprintf_r+0x1f4>
    e5fe:	ldr	r3, [sp, #116]	; 0x74
    e600:	ldr	r4, [sp, #148]	; 0x94
    e602:	add.w	r9, sp, #192	; 0xc0
    e606:	b.n	dfe0 <_svfprintf_r+0xe50>
    e608:	add	r2, sp, #140	; 0x8c
    e60a:	ldr	r1, [sp, #20]
    e60c:	ldr	r0, [sp, #24]
    e60e:	bl	12134 <__ssprint_r>
    e612:	cmp	r0, #0
    e614:	bne.w	d384 <_svfprintf_r+0x1f4>
    e618:	ldr	r3, [sp, #116]	; 0x74
    e61a:	ldr	r2, [sp, #56]	; 0x38
    e61c:	ldr	r4, [sp, #148]	; 0x94
    e61e:	subs	r3, r2, r3
    e620:	add.w	r9, sp, #192	; 0xc0
    e624:	b.n	e010 <_svfprintf_r+0xe80>
    e626:	nop
    e628:	.word	0x000131d0
    e62c:	.word	0x00013180
    e630:	.word	0x66666667
    e634:	cmp	r5, #6
    e636:	mov	r3, r5
    e638:	it	cs
    e63a:	movcs	r3, #6
    e63c:	str	r3, [sp, #36]	; 0x24
    e63e:	bic.w	r3, r3, r3, asr #31
    e642:	mov	fp, r6
    e644:	str	r7, [sp, #40]	; 0x28
    e646:	str	r6, [sp, #60]	; 0x3c
    e648:	mov	r7, r6
    e64a:	str	r3, [sp, #16]
    e64c:	ldr	r6, [pc, #536]	; (e868 <_svfprintf_r+0x16d8>)
    e64e:	b.w	d534 <_svfprintf_r+0x3a4>
    e652:	mov.w	fp, #6
    e656:	b.n	e18a <_svfprintf_r+0xffa>
    e658:	add	r2, sp, #132	; 0x84
    e65a:	add	r3, sp, #120	; 0x78
    e65c:	str	r2, [sp, #4]
    e65e:	str	r3, [sp, #0]
    e660:	mov	r2, fp
    e662:	add	r3, sp, #116	; 0x74
    e664:	movs	r1, #3
    e666:	vldr	d0, [sp, #96]	; 0x60
    e66a:	ldr	r0, [sp, #24]
    e66c:	bl	f998 <_dtoa_r>
    e670:	mov	r5, fp
    e672:	mov	r6, r0
    e674:	add.w	r4, r0, fp
    e678:	b.n	e466 <_svfprintf_r+0x12d6>
    e67a:	movs	r7, #45	; 0x2d
    e67c:	strb.w	r7, [sp, #111]	; 0x6f
    e680:	b.w	d7da <_svfprintf_r+0x64a>
    e684:	str	r3, [sp, #12]
    e686:	b.w	d932 <_svfprintf_r+0x7a2>
    e68a:	ldrd	r1, r2, [sp, #64]	; 0x40
    e68e:	add.w	r3, r2, #2147483648	; 0x80000000
    e692:	str	r3, [sp, #100]	; 0x64
    e694:	movs	r3, #45	; 0x2d
    e696:	str	r1, [sp, #96]	; 0x60
    e698:	str	r3, [sp, #16]
    e69a:	b.n	e1a6 <_svfprintf_r+0x1016>
    e69c:	ldr	r2, [sp, #72]	; 0x48
    e69e:	ldr	r3, [sp, #56]	; 0x38
    e6a0:	add	r3, r2
    e6a2:	ldr	r2, [sp, #60]	; 0x3c
    e6a4:	str	r3, [sp, #36]	; 0x24
    e6a6:	cmp	r2, #0
    e6a8:	ble.w	e7be <_svfprintf_r+0x162e>
    e6ac:	movs	r2, #103	; 0x67
    e6ae:	bic.w	r3, r3, r3, asr #31
    e6b2:	str	r2, [sp, #52]	; 0x34
    e6b4:	b.n	e24a <_svfprintf_r+0x10ba>
    e6b6:	ldr	r3, [sp, #52]	; 0x34
    e6b8:	cmp	r3, #71	; 0x47
    e6ba:	bne.w	e1e8 <_svfprintf_r+0x1058>
    e6be:	ldr	r3, [sp, #12]
    e6c0:	lsls	r3, r3, #31
    e6c2:	bmi.w	e45a <_svfprintf_r+0x12ca>
    e6c6:	ldr	r3, [sp, #132]	; 0x84
    e6c8:	cmp	r7, #71	; 0x47
    e6ca:	sub.w	r3, r3, r6
    e6ce:	str	r3, [sp, #56]	; 0x38
    e6d0:	beq.w	e508 <_svfprintf_r+0x1378>
    e6d4:	ldr	r3, [sp, #116]	; 0x74
    e6d6:	b.n	e552 <_svfprintf_r+0x13c2>
    e6d8:	bic.w	r3, r5, r5, asr #31
    e6dc:	str	r7, [sp, #40]	; 0x28
    e6de:	str	r3, [sp, #16]
    e6e0:	str	r5, [sp, #36]	; 0x24
    e6e2:	mov	fp, r0
    e6e4:	str	r0, [sp, #60]	; 0x3c
    e6e6:	ldrb.w	r7, [sp, #111]	; 0x6f
    e6ea:	b.w	d534 <_svfprintf_r+0x3a4>
    e6ee:	cmp	r3, #0
    e6f0:	ble.n	e7ce <_svfprintf_r+0x163e>
    e6f2:	cmp.w	fp, #0
    e6f6:	bne.n	e798 <_svfprintf_r+0x1608>
    e6f8:	ldr	r2, [sp, #12]
    e6fa:	lsls	r4, r2, #31
    e6fc:	bmi.n	e798 <_svfprintf_r+0x1608>
    e6fe:	mov	r2, r3
    e700:	str	r2, [sp, #36]	; 0x24
    e702:	bic.w	r3, r3, r3, asr #31
    e706:	b.n	e24a <_svfprintf_r+0x10ba>
    e708:	ldr	r3, [sp, #12]
    e70a:	lsls	r3, r3, #31
    e70c:	mov	r7, fp
    e70e:	bpl.n	e71c <_svfprintf_r+0x158c>
    e710:	add	r6, sp, #256	; 0x100
    e712:	movs	r3, #48	; 0x30
    e714:	strb.w	r3, [r6, #-65]!
    e718:	b.w	d520 <_svfprintf_r+0x390>
    e71c:	str.w	fp, [sp, #36]	; 0x24
    e720:	add	r6, sp, #192	; 0xc0
    e722:	b.w	d526 <_svfprintf_r+0x396>
    e726:	add	r2, sp, #140	; 0x8c
    e728:	ldr	r1, [sp, #20]
    e72a:	ldr	r0, [sp, #24]
    e72c:	bl	12134 <__ssprint_r>
    e730:	cmp	r0, #0
    e732:	bne.w	d384 <_svfprintf_r+0x1f4>
    e736:	ldr	r5, [sp, #116]	; 0x74
    e738:	ldr	r4, [sp, #148]	; 0x94
    e73a:	ldr	r3, [sp, #144]	; 0x90
    e73c:	add.w	r9, sp, #192	; 0xc0
    e740:	b.n	e390 <_svfprintf_r+0x1200>
    e742:	mov	r8, r4
    e744:	movs	r5, #0
    e746:	b.w	d248 <_svfprintf_r+0xb8>
    e74a:	adds	r3, #48	; 0x30
    e74c:	movs	r2, #48	; 0x30
    e74e:	strb.w	r3, [sp, #127]	; 0x7f
    e752:	strb.w	r2, [sp, #126]	; 0x7e
    e756:	add	r3, sp, #128	; 0x80
    e758:	b.n	e5ca <_svfprintf_r+0x143a>
    e75a:	ldr	r3, [sp, #132]	; 0x84
    e75c:	b.n	e210 <_svfprintf_r+0x1080>
    e75e:	ldr	r2, [sp, #72]	; 0x48
    e760:	ldr	r3, [sp, #60]	; 0x3c
    e762:	add	r3, r2
    e764:	movs	r2, #103	; 0x67
    e766:	str	r3, [sp, #36]	; 0x24
    e768:	str	r2, [sp, #52]	; 0x34
    e76a:	bic.w	r3, r3, r3, asr #31
    e76e:	b.n	e24a <_svfprintf_r+0x10ba>
    e770:	ldr	r6, [pc, #248]	; (e86c <_svfprintf_r+0x16dc>)
    e772:	ldr	r3, [pc, #252]	; (e870 <_svfprintf_r+0x16e0>)
    e774:	ldrb.w	r7, [sp, #111]	; 0x6f
    e778:	b.w	d7de <_svfprintf_r+0x64e>
    e77c:	movs	r2, #0
    e77e:	movs	r3, #0
    e780:	ldrd	r0, r1, [sp, #96]	; 0x60
    e784:	bl	ad88 <__aeabi_dcmpeq>
    e788:	cmp	r0, #0
    e78a:	bne.w	e46e <_svfprintf_r+0x12de>
    e78e:	rsb	r5, r5, #1
    e792:	str	r5, [sp, #116]	; 0x74
    e794:	add	r4, r5
    e796:	b.n	e1ea <_svfprintf_r+0x105a>
    e798:	ldr	r3, [sp, #60]	; 0x3c
    e79a:	ldr	r2, [sp, #72]	; 0x48
    e79c:	adds	r5, r3, r2
    e79e:	add.w	r3, r5, fp
    e7a2:	str	r3, [sp, #36]	; 0x24
    e7a4:	bic.w	r3, r3, r3, asr #31
    e7a8:	b.n	e24a <_svfprintf_r+0x10ba>
    e7aa:	ldr	r3, [sp, #12]
    e7ac:	ands.w	r3, r3, #1
    e7b0:	bne.w	e5dc <_svfprintf_r+0x144c>
    e7b4:	str	r3, [sp, #60]	; 0x3c
    e7b6:	ldr	r3, [sp, #36]	; 0x24
    e7b8:	bic.w	r3, r3, r3, asr #31
    e7bc:	b.n	e24a <_svfprintf_r+0x10ba>
    e7be:	ldr	r3, [sp, #60]	; 0x3c
    e7c0:	ldr	r2, [sp, #36]	; 0x24
    e7c2:	rsb	r3, r3, #1
    e7c6:	add	r2, r3
    e7c8:	mov	r3, r2
    e7ca:	str	r2, [sp, #36]	; 0x24
    e7cc:	b.n	e6ac <_svfprintf_r+0x151c>
    e7ce:	cmp.w	fp, #0
    e7d2:	bne.n	e7da <_svfprintf_r+0x164a>
    e7d4:	ldr	r3, [sp, #12]
    e7d6:	lsls	r0, r3, #31
    e7d8:	bpl.n	e7ea <_svfprintf_r+0x165a>
    e7da:	ldr	r3, [sp, #72]	; 0x48
    e7dc:	adds	r5, r3, #1
    e7de:	add.w	r3, r5, fp
    e7e2:	str	r3, [sp, #36]	; 0x24
    e7e4:	bic.w	r3, r3, r3, asr #31
    e7e8:	b.n	e24a <_svfprintf_r+0x10ba>
    e7ea:	movs	r3, #1
    e7ec:	str	r3, [sp, #36]	; 0x24
    e7ee:	b.n	e24a <_svfprintf_r+0x10ba>
    e7f0:	ldr	r0, [sp, #40]	; 0x28
    e7f2:	ldrb.w	r3, [r8, #1]
    e7f6:	ldr	r5, [r0, #0]
    e7f8:	adds	r0, #4
    e7fa:	cmp	r5, #0
    e7fc:	str	r0, [sp, #40]	; 0x28
    e7fe:	mov	r8, r4
    e800:	bge.w	d244 <_svfprintf_r+0xb4>
    e804:	mov.w	r5, #4294967295
    e808:	b.w	d244 <_svfprintf_r+0xb4>
    e80c:	strb.w	r1, [sp, #111]	; 0x6f
    e810:	b.w	d3a6 <_svfprintf_r+0x216>
    e814:	add.w	r3, sp, #126	; 0x7e
    e818:	b.n	e5ca <_svfprintf_r+0x143a>
    e81a:	ldr	r2, [sp, #24]
    e81c:	movs	r3, #12
    e81e:	str	r3, [r2, #0]
    e820:	mov.w	r0, #4294967295
    e824:	b.w	d396 <_svfprintf_r+0x206>
    e828:	strb.w	r1, [sp, #111]	; 0x6f
    e82c:	b.w	d4a0 <_svfprintf_r+0x310>
    e830:	strb.w	r1, [sp, #111]	; 0x6f
    e834:	b.w	d76c <_svfprintf_r+0x5dc>
    e838:	strb.w	r1, [sp, #111]	; 0x6f
    e83c:	b.w	d8da <_svfprintf_r+0x74a>
    e840:	strb.w	r1, [sp, #111]	; 0x6f
    e844:	b.w	d87e <_svfprintf_r+0x6ee>
    e848:	strb.w	r1, [sp, #111]	; 0x6f
    e84c:	b.w	d82a <_svfprintf_r+0x69a>
    e850:	strb.w	r1, [sp, #111]	; 0x6f
    e854:	b.w	dac2 <_svfprintf_r+0x932>
    e858:	strb.w	r1, [sp, #111]	; 0x6f
    e85c:	b.w	da80 <_svfprintf_r+0x8f0>
    e860:	strb.w	r1, [sp, #111]	; 0x6f
    e864:	b.w	da44 <_svfprintf_r+0x8b4>
    e868:	.word	0x000131c8
    e86c:	.word	0x0001319c
    e870:	.word	0x00013198

0000e874 <__ssvfscanf_r>:
    e874:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e878:	mov	fp, r1
    e87a:	ldrsh.w	r1, [r1, #12]
    e87e:	sub.w	sp, sp, #692	; 0x2b4
    e882:	mov	sl, r0
    e884:	lsls	r0, r1, #18
    e886:	mov	r4, r2
    e888:	str	r3, [sp, #20]
    e88a:	bmi.n	e8a0 <__ssvfscanf_r+0x2c>
    e88c:	ldr.w	r3, [fp, #100]	; 0x64
    e890:	orr.w	r1, r1, #8192	; 0x2000
    e894:	bic.w	r3, r3, #8192	; 0x2000
    e898:	strh.w	r1, [fp, #12]
    e89c:	str.w	r3, [fp, #100]	; 0x64
    e8a0:	mov	r6, r4
    e8a2:	movs	r3, #0
    e8a4:	str	r3, [sp, #28]
    e8a6:	str	r3, [sp, #16]
    e8a8:	mov	r7, r3
    e8aa:	str	r3, [sp, #24]
    e8ac:	ldrb.w	r3, [r6], #1
    e8b0:	str	r3, [sp, #68]	; 0x44
    e8b2:	cbz	r3, e910 <__ssvfscanf_r+0x9c>
    e8b4:	bl	b304 <__locale_ctype_ptr>
    e8b8:	ldr	r2, [sp, #68]	; 0x44
    e8ba:	add	r0, r2
    e8bc:	ldrb	r3, [r0, #1]
    e8be:	and.w	r3, r3, #8
    e8c2:	and.w	r5, r3, #255	; 0xff
    e8c6:	cbz	r3, e91a <__ssvfscanf_r+0xa6>
    e8c8:	ldr.w	r3, [fp, #4]
    e8cc:	b.n	e8f2 <__ssvfscanf_r+0x7e>
    e8ce:	bl	b304 <__locale_ctype_ptr>
    e8d2:	ldr.w	r3, [fp]
    e8d6:	ldrb	r2, [r3, #0]
    e8d8:	add	r0, r2
    e8da:	adds	r3, #1
    e8dc:	ldrb	r2, [r0, #1]
    e8de:	lsls	r1, r2, #28
    e8e0:	bpl.n	e902 <__ssvfscanf_r+0x8e>
    e8e2:	ldr.w	r2, [fp, #4]
    e8e6:	str.w	r3, [fp]
    e8ea:	subs	r3, r2, #1
    e8ec:	adds	r7, #1
    e8ee:	str.w	r3, [fp, #4]
    e8f2:	cmp	r3, #0
    e8f4:	bgt.n	e8ce <__ssvfscanf_r+0x5a>
    e8f6:	mov	r1, fp
    e8f8:	mov	r0, sl
    e8fa:	bl	122b8 <__ssrefill_r>
    e8fe:	cmp	r0, #0
    e900:	beq.n	e8ce <__ssvfscanf_r+0x5a>
    e902:	mov	r4, r6
    e904:	mov	r6, r4
    e906:	ldrb.w	r3, [r6], #1
    e90a:	str	r3, [sp, #68]	; 0x44
    e90c:	cmp	r3, #0
    e90e:	bne.n	e8b4 <__ssvfscanf_r+0x40>
    e910:	ldr	r0, [sp, #24]
    e912:	add.w	sp, sp, #692	; 0x2b4
    e916:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e91a:	cmp	r2, #37	; 0x25
    e91c:	bne.w	ea28 <__ssvfscanf_r+0x1b4>
    e920:	ldrb.w	r8, [r4, #1]
    e924:	mov	r4, r5
    e926:	adds	r3, r6, #1
    e928:	cmp.w	r8, #120	; 0x78
    e92c:	bhi.w	edb6 <__ssvfscanf_r+0x542>
    e930:	tbh	[pc, r8, lsl #1]
    e934:	.word	0x02410092
    e938:	.word	0x02410241
    e93c:	.word	0x02410241
    e940:	.word	0x02410241
    e944:	.word	0x02410241
    e948:	.word	0x02410241
    e94c:	.word	0x02410241
    e950:	.word	0x02410241
    e954:	.word	0x02410241
    e958:	.word	0x02410241
    e95c:	.word	0x02410241
    e960:	.word	0x02410241
    e964:	.word	0x02410241
    e968:	.word	0x02410241
    e96c:	.word	0x02410241
    e970:	.word	0x02410241
    e974:	.word	0x02410241
    e978:	.word	0x02410241
    e97c:	.word	0x00790241
    e980:	.word	0x02410241
    e984:	.word	0x02410241
    e988:	.word	0x024101d8
    e98c:	.word	0x02410241
    e990:	.word	0x02410241
    e994:	.word	0x01cf01cf
    e998:	.word	0x01cf01cf
    e99c:	.word	0x01cf01cf
    e9a0:	.word	0x01cf01cf
    e9a4:	.word	0x01cf01cf
    e9a8:	.word	0x02410241
    e9ac:	.word	0x02410241
    e9b0:	.word	0x02410241
    e9b4:	.word	0x02410241
    e9b8:	.word	0x02410241
    e9bc:	.word	0x01b901c1
    e9c0:	.word	0x01b90241
    e9c4:	.word	0x02410241
    e9c8:	.word	0x02410241
    e9cc:	.word	0x024101b3
    e9d0:	.word	0x01a30241
    e9d4:	.word	0x02410241
    e9d8:	.word	0x02410241
    e9dc:	.word	0x02410241
    e9e0:	.word	0x02410241
    e9e4:	.word	0x02410193
    e9e8:	.word	0x01510241
    e9ec:	.word	0x02410241
    e9f0:	.word	0x02410241
    e9f4:	.word	0x02410241
    e9f8:	.word	0x01220241
    e9fc:	.word	0x01b90188
    ea00:	.word	0x01b901b9
    ea04:	.word	0x0098011c
    ea08:	.word	0x02410241
    ea0c:	.word	0x024100d5
    ea10:	.word	0x0101010d
    ea14:	.word	0x024100f3
    ea18:	.word	0x00eb0241
    ea1c:	.word	0x00df0241
    ea20:	.word	0x02410241
    ea24:	.short	0x0193
    ea26:	mov	r6, r3
    ea28:	ldr.w	r3, [fp, #4]
    ea2c:	cmp	r3, #0
    ea2e:	ble.w	eed8 <__ssvfscanf_r+0x664>
    ea32:	ldr.w	r3, [fp]
    ea36:	ldrb.w	r2, [r6, #-1]
    ea3a:	ldrb	r1, [r3, #0]
    ea3c:	cmp	r1, r2
    ea3e:	bne.w	e910 <__ssvfscanf_r+0x9c>
    ea42:	ldr.w	r2, [fp, #4]
    ea46:	adds	r3, #1
    ea48:	subs	r2, #1
    ea4a:	str.w	r3, [fp]
    ea4e:	adds	r7, #1
    ea50:	str.w	r2, [fp, #4]
    ea54:	mov	r4, r6
    ea56:	b.n	e904 <__ssvfscanf_r+0x90>
    ea58:	mov.w	r0, #4294967295
    ea5c:	add.w	sp, sp, #692	; 0x2b4
    ea60:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ea64:	str	r3, [sp, #12]
    ea66:	ldr.w	r3, [fp, #4]
    ea6a:	cmp	r3, #0
    ea6c:	ble.w	ef36 <__ssvfscanf_r+0x6c2>
    ea70:	ldr	r3, [pc, #736]	; (ed54 <__ssvfscanf_r+0x4e0>)
    ea72:	str	r3, [sp, #28]
    ea74:	movs	r3, #0
    ea76:	str	r3, [sp, #16]
    ea78:	movs	r6, #3
    ea7a:	b.n	ea80 <__ssvfscanf_r+0x20c>
    ea7c:	str.w	lr, [fp]
    ea80:	bl	b304 <__locale_ctype_ptr>
    ea84:	ldr.w	r2, [fp]
    ea88:	ldrb	r1, [r2, #0]
    ea8a:	add	r0, r1
    ea8c:	add.w	lr, r2, #1
    ea90:	ldrb	r3, [r0, #1]
    ea92:	and.w	r3, r3, #8
    ea96:	and.w	r8, r3, #255	; 0xff
    ea9a:	cmp	r3, #0
    ea9c:	beq.w	ef9e <__ssvfscanf_r+0x72a>
    eaa0:	ldr.w	r3, [fp, #4]
    eaa4:	subs	r3, #1
    eaa6:	cmp	r3, #0
    eaa8:	add.w	r7, r7, #1
    eaac:	str.w	r3, [fp, #4]
    eab0:	bgt.n	ea7c <__ssvfscanf_r+0x208>
    eab2:	mov	r1, fp
    eab4:	mov	r0, sl
    eab6:	bl	122b8 <__ssrefill_r>
    eaba:	cmp	r0, #0
    eabc:	beq.n	ea80 <__ssvfscanf_r+0x20c>
    eabe:	ldr	r2, [sp, #24]
    eac0:	cmp	r2, #0
    eac2:	beq.n	ea58 <__ssvfscanf_r+0x1e4>
    eac4:	ldrh.w	r3, [fp, #12]
    eac8:	tst.w	r3, #64	; 0x40
    eacc:	mov	r3, r2
    eace:	it	ne
    ead0:	movne.w	r3, #4294967295
    ead4:	mov	r0, r3
    ead6:	add.w	sp, sp, #692	; 0x2b4
    eada:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    eade:	ldrb.w	r8, [r6, #1]
    eae2:	cmp.w	r8, #108	; 0x6c
    eae6:	beq.w	eeee <__ssvfscanf_r+0x67a>
    eaea:	orr.w	r5, r5, #1
    eaee:	mov	r6, r3
    eaf0:	b.n	e926 <__ssvfscanf_r+0xb2>
    eaf2:	str	r3, [sp, #12]
    eaf4:	ldr.w	r3, [fp, #4]
    eaf8:	cmp	r3, #0
    eafa:	ble.w	ef8e <__ssvfscanf_r+0x71a>
    eafe:	ldr	r3, [pc, #600]	; (ed58 <__ssvfscanf_r+0x4e4>)
    eb00:	str	r3, [sp, #28]
    eb02:	movs	r3, #10
    eb04:	str	r3, [sp, #16]
    eb06:	movs	r6, #3
    eb08:	b.n	ea80 <__ssvfscanf_r+0x20c>
    eb0a:	str	r3, [sp, #12]
    eb0c:	ldr.w	r3, [fp, #4]
    eb10:	cmp	r3, #0
    eb12:	ble.w	ef7e <__ssvfscanf_r+0x70a>
    eb16:	movs	r6, #2
    eb18:	b.n	ea80 <__ssvfscanf_r+0x20c>
    eb1a:	str	r3, [sp, #12]
    eb1c:	ldr.w	r3, [fp, #4]
    eb20:	cmp	r3, #0
    eb22:	orr.w	r5, r5, #544	; 0x220
    eb26:	ble.w	ec6a <__ssvfscanf_r+0x3f6>
    eb2a:	ldr	r3, [pc, #556]	; (ed58 <__ssvfscanf_r+0x4e4>)
    eb2c:	str	r3, [sp, #28]
    eb2e:	movs	r3, #16
    eb30:	str	r3, [sp, #16]
    eb32:	movs	r6, #3
    eb34:	b.n	ea80 <__ssvfscanf_r+0x20c>
    eb36:	str	r3, [sp, #12]
    eb38:	ldr.w	r3, [fp, #4]
    eb3c:	cmp	r3, #0
    eb3e:	ble.w	ec8a <__ssvfscanf_r+0x416>
    eb42:	ldr	r3, [pc, #532]	; (ed58 <__ssvfscanf_r+0x4e4>)
    eb44:	str	r3, [sp, #28]
    eb46:	movs	r3, #8
    eb48:	str	r3, [sp, #16]
    eb4a:	movs	r6, #3
    eb4c:	b.n	ea80 <__ssvfscanf_r+0x20c>
    eb4e:	lsls	r2, r5, #27
    eb50:	mov	r6, r3
    eb52:	str	r3, [sp, #12]
    eb54:	bmi.w	ed3c <__ssvfscanf_r+0x4c8>
    eb58:	lsls	r3, r5, #29
    eb5a:	bpl.w	ef06 <__ssvfscanf_r+0x692>
    eb5e:	ldr	r1, [sp, #20]
    eb60:	ldr	r3, [r1, #0]
    eb62:	strh	r7, [r3, #0]
    eb64:	adds	r3, r1, #4
    eb66:	str	r3, [sp, #20]
    eb68:	mov	r4, r6
    eb6a:	b.n	e904 <__ssvfscanf_r+0x90>
    eb6c:	ldrb.w	r8, [r6, #1]
    eb70:	orr.w	r5, r5, #4
    eb74:	mov	r6, r3
    eb76:	b.n	e926 <__ssvfscanf_r+0xb2>
    eb78:	str	r3, [sp, #12]
    eb7a:	ldr.w	r3, [fp, #4]
    eb7e:	cmp	r3, #0
    eb80:	ble.w	ef5e <__ssvfscanf_r+0x6ea>
    eb84:	cmp	r4, #0
    eb86:	it	eq
    eb88:	moveq	r4, #1
    eb8a:	ands.w	r3, r5, #1
    eb8e:	bne.w	edd6 <__ssvfscanf_r+0x562>
    eb92:	lsls	r2, r5, #27
    eb94:	bpl.w	eeae <__ssvfscanf_r+0x63a>
    eb98:	mov	r5, r3
    eb9a:	b.n	ebb0 <__ssvfscanf_r+0x33c>
    eb9c:	add	r3, r2
    eb9e:	str.w	r3, [fp]
    eba2:	add	r5, r2
    eba4:	subs	r4, r4, r2
    eba6:	bl	122b8 <__ssrefill_r>
    ebaa:	cmp	r0, #0
    ebac:	bne.w	eea6 <__ssvfscanf_r+0x632>
    ebb0:	ldr.w	r2, [fp, #4]
    ebb4:	ldr.w	r3, [fp]
    ebb8:	cmp	r2, r4
    ebba:	mov	r1, fp
    ebbc:	mov	r0, sl
    ebbe:	blt.n	eb9c <__ssvfscanf_r+0x328>
    ebc0:	subs	r2, r2, r4
    ebc2:	add	r3, r4
    ebc4:	str.w	r2, [fp, #4]
    ebc8:	add	r5, r4
    ebca:	str.w	r3, [fp]
    ebce:	ldr	r6, [sp, #12]
    ebd0:	add	r7, r5
    ebd2:	mov	r4, r6
    ebd4:	b.n	e904 <__ssvfscanf_r+0x90>
    ebd6:	add.w	r9, sp, #80	; 0x50
    ebda:	mov	r1, r3
    ebdc:	mov	r0, r9
    ebde:	bl	11b48 <__sccl>
    ebe2:	ldr.w	r3, [fp, #4]
    ebe6:	cmp	r3, #0
    ebe8:	mov	r6, r0
    ebea:	ble.w	ef4e <__ssvfscanf_r+0x6da>
    ebee:	cmp	r4, #0
    ebf0:	ldr.w	r2, [fp]
    ebf4:	it	eq
    ebf6:	moveq.w	r4, #4294967295
    ebfa:	lsls	r3, r5, #27
    ebfc:	ldrb	r1, [r2, #0]
    ebfe:	bpl.w	ed42 <__ssvfscanf_r+0x4ce>
    ec02:	mov	r8, r4
    ec04:	movs	r5, #0
    ec06:	b.n	ec0a <__ssvfscanf_r+0x396>
    ec08:	ldrb	r1, [r2, #0]
    ec0a:	ldrb.w	r3, [r9, r1]
    ec0e:	adds	r2, #1
    ec10:	cmp	r3, #0
    ec12:	beq.w	ee9c <__ssvfscanf_r+0x628>
    ec16:	ldr.w	r3, [fp, #4]
    ec1a:	str.w	r2, [fp]
    ec1e:	adds	r5, #1
    ec20:	subs	r3, #1
    ec22:	cmp	r5, r4
    ec24:	str.w	r3, [fp, #4]
    ec28:	beq.w	ee96 <__ssvfscanf_r+0x622>
    ec2c:	cmp	r3, #0
    ec2e:	bgt.n	ec08 <__ssvfscanf_r+0x394>
    ec30:	mov	r1, fp
    ec32:	mov	r0, sl
    ec34:	bl	122b8 <__ssrefill_r>
    ec38:	cmp	r0, #0
    ec3a:	bne.w	ee94 <__ssvfscanf_r+0x620>
    ec3e:	ldr.w	r2, [fp]
    ec42:	b.n	ec08 <__ssvfscanf_r+0x394>
    ec44:	str	r3, [sp, #12]
    ec46:	ldr.w	r3, [fp, #4]
    ec4a:	cmp	r3, #0
    ec4c:	ble.n	ecc4 <__ssvfscanf_r+0x450>
    ec4e:	ldr	r3, [pc, #260]	; (ed54 <__ssvfscanf_r+0x4e0>)
    ec50:	str	r3, [sp, #28]
    ec52:	movs	r3, #10
    ec54:	str	r3, [sp, #16]
    ec56:	movs	r6, #3
    ec58:	b.n	ea80 <__ssvfscanf_r+0x20c>
    ec5a:	str	r3, [sp, #12]
    ec5c:	ldr.w	r3, [fp, #4]
    ec60:	cmp	r3, #0
    ec62:	orr.w	r5, r5, #512	; 0x200
    ec66:	bgt.w	eb2a <__ssvfscanf_r+0x2b6>
    ec6a:	mov	r1, fp
    ec6c:	mov	r0, sl
    ec6e:	bl	122b8 <__ssrefill_r>
    ec72:	cmp	r0, #0
    ec74:	beq.w	eb2a <__ssvfscanf_r+0x2b6>
    ec78:	b.n	eabe <__ssvfscanf_r+0x24a>
    ec7a:	str	r3, [sp, #12]
    ec7c:	ldr.w	r3, [fp, #4]
    ec80:	cmp	r3, #0
    ec82:	orr.w	r5, r5, #1
    ec86:	bgt.w	eb42 <__ssvfscanf_r+0x2ce>
    ec8a:	mov	r1, fp
    ec8c:	mov	r0, sl
    ec8e:	bl	122b8 <__ssrefill_r>
    ec92:	cmp	r0, #0
    ec94:	beq.w	eb42 <__ssvfscanf_r+0x2ce>
    ec98:	b.n	eabe <__ssvfscanf_r+0x24a>
    ec9a:	ldrb.w	r8, [r6, #1]
    ec9e:	orr.w	r5, r5, #2
    eca2:	mov	r6, r3
    eca4:	b.n	e926 <__ssvfscanf_r+0xb2>
    eca6:	str	r3, [sp, #12]
    eca8:	ldr.w	r3, [fp, #4]
    ecac:	cmp	r3, #0
    ecae:	ble.w	ef6e <__ssvfscanf_r+0x6fa>
    ecb2:	movs	r6, #4
    ecb4:	b.n	ea80 <__ssvfscanf_r+0x20c>
    ecb6:	str	r3, [sp, #12]
    ecb8:	ldr.w	r3, [fp, #4]
    ecbc:	cmp	r3, #0
    ecbe:	orr.w	r5, r5, #1
    ecc2:	bgt.n	ec4e <__ssvfscanf_r+0x3da>
    ecc4:	mov	r1, fp
    ecc6:	mov	r0, sl
    ecc8:	bl	122b8 <__ssrefill_r>
    eccc:	cmp	r0, #0
    ecce:	beq.n	ec4e <__ssvfscanf_r+0x3da>
    ecd0:	b.n	eabe <__ssvfscanf_r+0x24a>
    ecd2:	add.w	r4, r4, r4, lsl #2
    ecd6:	add.w	r4, r8, r4, lsl #1
    ecda:	subs	r4, #48	; 0x30
    ecdc:	ldrb.w	r8, [r6, #1]
    ece0:	mov	r6, r3
    ece2:	b.n	e926 <__ssvfscanf_r+0xb2>
    ece4:	ldrb.w	r8, [r6, #1]
    ece8:	orr.w	r5, r5, #16
    ecec:	mov	r6, r3
    ecee:	b.n	e926 <__ssvfscanf_r+0xb2>
    ecf0:	add	r3, sp, #72	; 0x48
    ecf2:	mov	r1, r8
    ecf4:	mov	r0, r3
    ecf6:	movs	r2, #8
    ecf8:	str	r3, [sp, #32]
    ecfa:	bl	90bc <memset>
    ecfe:	ands.w	r9, r5, #16
    ed02:	bne.w	f5c8 <__ssvfscanf_r+0xd54>
    ed06:	ldr	r2, [sp, #20]
    ed08:	mov	r3, r2
    ed0a:	adds	r3, #4
    ed0c:	ldr.w	r8, [r2]
    ed10:	str	r3, [sp, #20]
    ed12:	movs	r6, #0
    ed14:	bl	b304 <__locale_ctype_ptr>
    ed18:	ldr.w	r3, [fp]
    ed1c:	ldrb	r3, [r3, #0]
    ed1e:	add	r0, r3
    ed20:	ldrb	r3, [r0, #1]
    ed22:	lsls	r0, r3, #28
    ed24:	bmi.n	ed2c <__ssvfscanf_r+0x4b8>
    ed26:	cmp	r4, #0
    ed28:	bne.w	f52c <__ssvfscanf_r+0xcb8>
    ed2c:	cmp.w	r9, #0
    ed30:	bne.n	ed3c <__ssvfscanf_r+0x4c8>
    ed32:	str.w	r9, [r8]
    ed36:	ldr	r3, [sp, #24]
    ed38:	adds	r3, #1
    ed3a:	str	r3, [sp, #24]
    ed3c:	ldr	r6, [sp, #12]
    ed3e:	mov	r4, r6
    ed40:	b.n	e904 <__ssvfscanf_r+0x90>
    ed42:	ldr	r0, [sp, #20]
    ed44:	ldr	r5, [r0, #0]
    ed46:	mov	r3, r0
    ed48:	adds	r3, #4
    ed4a:	add.w	r8, r5, r4
    ed4e:	str	r3, [sp, #12]
    ed50:	mov	r4, r5
    ed52:	b.n	ed62 <__ssvfscanf_r+0x4ee>
    ed54:	.word	0x0000d169
    ed58:	.word	0x00011f01
    ed5c:	ldr.w	r2, [fp]
    ed60:	ldrb	r1, [r2, #0]
    ed62:	ldrb.w	r3, [r9, r1]
    ed66:	adds	r0, r2, #1
    ed68:	cbz	r3, ed9c <__ssvfscanf_r+0x528>
    ed6a:	ldr.w	r3, [fp, #4]
    ed6e:	str.w	r0, [fp]
    ed72:	subs	r3, #1
    ed74:	str.w	r3, [fp, #4]
    ed78:	ldrb	r3, [r2, #0]
    ed7a:	strb.w	r3, [r4], #1
    ed7e:	cmp	r8, r4
    ed80:	beq.n	ed9c <__ssvfscanf_r+0x528>
    ed82:	ldr.w	r3, [fp, #4]
    ed86:	cmp	r3, #0
    ed88:	bgt.n	ed5c <__ssvfscanf_r+0x4e8>
    ed8a:	mov	r1, fp
    ed8c:	mov	r0, sl
    ed8e:	bl	122b8 <__ssrefill_r>
    ed92:	cmp	r0, #0
    ed94:	beq.n	ed5c <__ssvfscanf_r+0x4e8>
    ed96:	cmp	r5, r4
    ed98:	beq.w	eabe <__ssvfscanf_r+0x24a>
    ed9c:	subs	r5, r4, r5
    ed9e:	beq.w	e910 <__ssvfscanf_r+0x9c>
    eda2:	ldr	r2, [sp, #24]
    eda4:	adds	r2, #1
    eda6:	movs	r3, #0
    eda8:	str	r2, [sp, #24]
    edaa:	ldr	r2, [sp, #12]
    edac:	str	r2, [sp, #20]
    edae:	strb	r3, [r4, #0]
    edb0:	add	r7, r5
    edb2:	mov	r4, r6
    edb4:	b.n	e904 <__ssvfscanf_r+0x90>
    edb6:	str	r3, [sp, #12]
    edb8:	bl	b304 <__locale_ctype_ptr>
    edbc:	add	r0, r8
    edbe:	ldrb	r3, [r0, #1]
    edc0:	and.w	r3, r3, #3
    edc4:	cmp	r3, #1
    edc6:	ldr.w	r3, [fp, #4]
    edca:	beq.w	eefa <__ssvfscanf_r+0x686>
    edce:	cmp	r3, #0
    edd0:	bgt.w	ec4e <__ssvfscanf_r+0x3da>
    edd4:	b.n	ecc4 <__ssvfscanf_r+0x450>
    edd6:	add	r3, sp, #72	; 0x48
    edd8:	mov	r0, r3
    edda:	movs	r2, #8
    eddc:	movs	r1, #0
    edde:	str	r3, [sp, #32]
    ede0:	bl	90bc <memset>
    ede4:	ands.w	r3, r5, #16
    ede8:	str	r3, [sp, #40]	; 0x28
    edea:	bne.n	eee8 <__ssvfscanf_r+0x674>
    edec:	ldr	r2, [sp, #20]
    edee:	mov	r3, r2
    edf0:	adds	r3, #4
    edf2:	ldr.w	r9, [r2]
    edf6:	str	r3, [sp, #20]
    edf8:	movs	r5, #0
    edfa:	add.w	r8, sp, #336	; 0x150
    edfe:	bl	b2e0 <__locale_mb_cur_max>
    ee02:	cmp	r0, r5
    ee04:	beq.w	eabe <__ssvfscanf_r+0x24a>
    ee08:	ldmia.w	fp, {r2, r3}
    ee0c:	ldrb.w	r0, [r2], #1
    ee10:	str.w	r2, [fp]
    ee14:	subs	r3, #1
    ee16:	ldr	r2, [sp, #32]
    ee18:	str	r2, [sp, #0]
    ee1a:	adds	r6, r5, #1
    ee1c:	str.w	r3, [fp, #4]
    ee20:	mov	r1, r9
    ee22:	strb.w	r0, [r8, r5]
    ee26:	mov	r3, r6
    ee28:	mov	r2, r8
    ee2a:	mov	r0, sl
    ee2c:	bl	11204 <_mbrtowc_r>
    ee30:	adds	r1, r0, #1
    ee32:	beq.w	eabe <__ssvfscanf_r+0x24a>
    ee36:	cbnz	r0, ee62 <__ssvfscanf_r+0x5ee>
    ee38:	ldr	r3, [sp, #40]	; 0x28
    ee3a:	cbnz	r3, ee82 <__ssvfscanf_r+0x60e>
    ee3c:	str.w	r3, [r9]
    ee40:	add	r7, r6
    ee42:	subs	r4, #1
    ee44:	add.w	r9, r9, #4
    ee48:	ldr.w	r3, [fp, #4]
    ee4c:	cmp	r3, #0
    ee4e:	mov.w	r5, #0
    ee52:	ble.n	ee70 <__ssvfscanf_r+0x5fc>
    ee54:	cmp	r4, #0
    ee56:	bne.n	edfe <__ssvfscanf_r+0x58a>
    ee58:	ldr	r3, [sp, #40]	; 0x28
    ee5a:	cmp	r3, #0
    ee5c:	beq.w	ed36 <__ssvfscanf_r+0x4c2>
    ee60:	b.n	ed3c <__ssvfscanf_r+0x4c8>
    ee62:	adds	r0, #2
    ee64:	bne.n	ee88 <__ssvfscanf_r+0x614>
    ee66:	ldr.w	r3, [fp, #4]
    ee6a:	cmp	r3, #0
    ee6c:	mov	r5, r6
    ee6e:	bgt.n	edfe <__ssvfscanf_r+0x58a>
    ee70:	mov	r1, fp
    ee72:	mov	r0, sl
    ee74:	bl	122b8 <__ssrefill_r>
    ee78:	cmp	r0, #0
    ee7a:	beq.n	ee54 <__ssvfscanf_r+0x5e0>
    ee7c:	cmp	r5, #0
    ee7e:	beq.n	ee58 <__ssvfscanf_r+0x5e4>
    ee80:	b.n	eabe <__ssvfscanf_r+0x24a>
    ee82:	add	r7, r6
    ee84:	subs	r4, #1
    ee86:	b.n	ee48 <__ssvfscanf_r+0x5d4>
    ee88:	ldr	r3, [sp, #40]	; 0x28
    ee8a:	add	r7, r6
    ee8c:	subs	r4, #1
    ee8e:	cmp	r3, #0
    ee90:	bne.n	ee48 <__ssvfscanf_r+0x5d4>
    ee92:	b.n	ee44 <__ssvfscanf_r+0x5d0>
    ee94:	mov	r8, r5
    ee96:	mov	r5, r8
    ee98:	add	r7, r5
    ee9a:	b.n	edb2 <__ssvfscanf_r+0x53e>
    ee9c:	cmp	r5, #0
    ee9e:	beq.w	e910 <__ssvfscanf_r+0x9c>
    eea2:	add	r7, r5
    eea4:	b.n	edb2 <__ssvfscanf_r+0x53e>
    eea6:	cmp	r5, #0
    eea8:	bne.w	ebce <__ssvfscanf_r+0x35a>
    eeac:	b.n	eabe <__ssvfscanf_r+0x24a>
    eeae:	ldr	r5, [sp, #20]
    eeb0:	mov	r3, r4
    eeb2:	ldr	r1, [r5, #0]
    eeb4:	str.w	fp, [sp]
    eeb8:	movs	r2, #1
    eeba:	mov	r0, sl
    eebc:	bl	122f4 <_sfread_r>
    eec0:	adds	r6, r5, #4
    eec2:	cmp	r0, #0
    eec4:	beq.w	eabe <__ssvfscanf_r+0x24a>
    eec8:	ldr	r3, [sp, #24]
    eeca:	str	r6, [sp, #20]
    eecc:	ldr	r6, [sp, #12]
    eece:	adds	r3, #1
    eed0:	add	r7, r0
    eed2:	str	r3, [sp, #24]
    eed4:	mov	r4, r6
    eed6:	b.n	e904 <__ssvfscanf_r+0x90>
    eed8:	mov	r1, fp
    eeda:	mov	r0, sl
    eedc:	bl	122b8 <__ssrefill_r>
    eee0:	cmp	r0, #0
    eee2:	beq.w	ea32 <__ssvfscanf_r+0x1be>
    eee6:	b.n	eabe <__ssvfscanf_r+0x24a>
    eee8:	mov.w	r9, #0
    eeec:	b.n	edf8 <__ssvfscanf_r+0x584>
    eeee:	ldrb.w	r8, [r6, #2]
    eef2:	orr.w	r5, r5, #2
    eef6:	adds	r6, #2
    eef8:	b.n	e926 <__ssvfscanf_r+0xb2>
    eefa:	cmp	r3, #0
    eefc:	orr.w	r5, r5, #1
    ef00:	bgt.w	ec4e <__ssvfscanf_r+0x3da>
    ef04:	b.n	ecc4 <__ssvfscanf_r+0x450>
    ef06:	lsls	r4, r5, #31
    ef08:	bmi.n	ef24 <__ssvfscanf_r+0x6b0>
    ef0a:	lsls	r0, r5, #30
    ef0c:	bpl.n	ef24 <__ssvfscanf_r+0x6b0>
    ef0e:	ldr	r2, [sp, #20]
    ef10:	ldr	r6, [sp, #12]
    ef12:	ldr	r3, [r2, #0]
    ef14:	mov	r0, r7
    ef16:	asrs	r1, r7, #31
    ef18:	adds	r2, #4
    ef1a:	str	r2, [sp, #20]
    ef1c:	strd	r0, r1, [r3]
    ef20:	mov	r4, r6
    ef22:	b.n	e904 <__ssvfscanf_r+0x90>
    ef24:	ldr	r2, [sp, #20]
    ef26:	ldr	r6, [sp, #12]
    ef28:	ldr	r3, [r2, #0]
    ef2a:	str	r7, [r3, #0]
    ef2c:	mov	r3, r2
    ef2e:	adds	r3, #4
    ef30:	str	r3, [sp, #20]
    ef32:	mov	r4, r6
    ef34:	b.n	e904 <__ssvfscanf_r+0x90>
    ef36:	mov	r1, fp
    ef38:	mov	r0, sl
    ef3a:	bl	122b8 <__ssrefill_r>
    ef3e:	cmp	r0, #0
    ef40:	bne.w	eabe <__ssvfscanf_r+0x24a>
    ef44:	ldr	r3, [pc, #504]	; (f140 <__ssvfscanf_r+0x8cc>)
    ef46:	str	r0, [sp, #16]
    ef48:	str	r3, [sp, #28]
    ef4a:	movs	r6, #3
    ef4c:	b.n	ea80 <__ssvfscanf_r+0x20c>
    ef4e:	mov	r1, fp
    ef50:	mov	r0, sl
    ef52:	bl	122b8 <__ssrefill_r>
    ef56:	cmp	r0, #0
    ef58:	beq.w	ebee <__ssvfscanf_r+0x37a>
    ef5c:	b.n	eabe <__ssvfscanf_r+0x24a>
    ef5e:	mov	r1, fp
    ef60:	mov	r0, sl
    ef62:	bl	122b8 <__ssrefill_r>
    ef66:	cmp	r0, #0
    ef68:	beq.w	eb84 <__ssvfscanf_r+0x310>
    ef6c:	b.n	eabe <__ssvfscanf_r+0x24a>
    ef6e:	mov	r1, fp
    ef70:	mov	r0, sl
    ef72:	bl	122b8 <__ssrefill_r>
    ef76:	cmp	r0, #0
    ef78:	beq.w	ecb2 <__ssvfscanf_r+0x43e>
    ef7c:	b.n	eabe <__ssvfscanf_r+0x24a>
    ef7e:	mov	r1, fp
    ef80:	mov	r0, sl
    ef82:	bl	122b8 <__ssrefill_r>
    ef86:	cmp	r0, #0
    ef88:	beq.w	eb16 <__ssvfscanf_r+0x2a2>
    ef8c:	b.n	eabe <__ssvfscanf_r+0x24a>
    ef8e:	mov	r1, fp
    ef90:	mov	r0, sl
    ef92:	bl	122b8 <__ssrefill_r>
    ef96:	cmp	r0, #0
    ef98:	beq.w	eafe <__ssvfscanf_r+0x28a>
    ef9c:	b.n	eabe <__ssvfscanf_r+0x24a>
    ef9e:	cmp	r6, #3
    efa0:	beq.w	f2e2 <__ssvfscanf_r+0xa6e>
    efa4:	cmp	r6, #4
    efa6:	bne.w	f424 <__ssvfscanf_r+0xbb0>
    efaa:	mov	r0, sl
    efac:	bl	111e8 <_localeconv_r>
    efb0:	subs	r3, r4, #1
    efb2:	ldr	r2, [r0, #0]
    efb4:	str	r2, [sp, #48]	; 0x30
    efb6:	cmp.w	r3, #348	; 0x15c
    efba:	bls.w	f48c <__ssvfscanf_r+0xc18>
    efbe:	mvn.w	r1, #348	; 0x15c
    efc2:	adds	r3, r4, r1
    efc4:	str	r3, [sp, #56]	; 0x38
    efc6:	movw	r4, #349	; 0x15d
    efca:	add	r3, sp, #336	; 0x150
    efcc:	mov.w	r8, #0
    efd0:	mov	r2, r3
    efd2:	str	r3, [sp, #40]	; 0x28
    efd4:	orr.w	r5, r5, #1920	; 0x780
    efd8:	mov	r3, r8
    efda:	str.w	r8, [sp, #60]	; 0x3c
    efde:	str.w	r8, [sp, #52]	; 0x34
    efe2:	mov	r6, r8
    efe4:	str.w	r8, [sp, #44]	; 0x2c
    efe8:	mov	r9, r2
    efea:	ldr.w	r0, [fp]
    efee:	ldrb	r1, [r0, #0]
    eff0:	sub.w	lr, r1, #43	; 0x2b
    eff4:	cmp.w	lr, #78	; 0x4e
    eff8:	bhi.w	f292 <__ssvfscanf_r+0xa1e>
    effc:	tbh	[pc, lr, lsl #1]
    f000:	.word	0x0149007a
    f004:	.word	0x0149007a
    f008:	.word	0x006e0149
    f00c:	.word	0x004f004f
    f010:	.word	0x004f004f
    f014:	.word	0x004f004f
    f018:	.word	0x004f004f
    f01c:	.word	0x0149004f
    f020:	.word	0x01490149
    f024:	.word	0x01490149
    f028:	.word	0x01490149
    f02c:	.word	0x01490144
    f030:	.word	0x01490149
    f034:	.word	0x0125012c
    f038:	.word	0x01490149
    f03c:	.word	0x014900a2
    f040:	.word	0x01490149
    f044:	.word	0x008b0149
    f048:	.word	0x01490149
    f04c:	.word	0x01490149
    f050:	.word	0x00850149
    f054:	.word	0x01490149
    f058:	.word	0x01490149
    f05c:	.word	0x0149007f
    f060:	.word	0x01490149
    f064:	.word	0x01490149
    f068:	.word	0x01490149
    f06c:	.word	0x01490144
    f070:	.word	0x01490149
    f074:	.word	0x0125012c
    f078:	.word	0x01490149
    f07c:	.word	0x014900a2
    f080:	.word	0x01490149
    f084:	.word	0x008b0149
    f088:	.word	0x01490149
    f08c:	.word	0x01490149
    f090:	.word	0x00850149
    f094:	.word	0x01490149
    f098:	.word	0x01490149
    f09c:	.short	0x007f
    f09e:	cmn.w	r3, r8
    f0a2:	bne.n	f0d2 <__ssvfscanf_r+0x85e>
    f0a4:	bic.w	r5, r5, #384	; 0x180
    f0a8:	strb.w	r1, [r9]
    f0ac:	add.w	r9, r9, #1
    f0b0:	ldr.w	r1, [fp, #4]
    f0b4:	subs	r1, #1
    f0b6:	cmp	r1, #0
    f0b8:	add.w	r4, r4, #4294967295
    f0bc:	add.w	r7, r7, #1
    f0c0:	str.w	r1, [fp, #4]
    f0c4:	ble.w	f2ac <__ssvfscanf_r+0xa38>
    f0c8:	adds	r0, #1
    f0ca:	str.w	r0, [fp]
    f0ce:	cmp	r4, #0
    f0d0:	bne.n	efea <__ssvfscanf_r+0x776>
    f0d2:	cmp	r6, #0
    f0d4:	beq.n	f15c <__ssvfscanf_r+0x8e8>
    f0d6:	bic.w	r5, r5, #256	; 0x100
    f0da:	b.n	f15c <__ssvfscanf_r+0x8e8>
    f0dc:	lsls	r2, r5, #23
    f0de:	bpl.n	f09e <__ssvfscanf_r+0x82a>
    f0e0:	ldr	r2, [sp, #56]	; 0x38
    f0e2:	bic.w	r5, r5, #128	; 0x80
    f0e6:	adds	r6, #1
    f0e8:	cmp	r2, #0
    f0ea:	beq.n	f0b0 <__ssvfscanf_r+0x83c>
    f0ec:	subs	r2, #1
    f0ee:	str	r2, [sp, #56]	; 0x38
    f0f0:	adds	r4, #1
    f0f2:	b.n	f0b0 <__ssvfscanf_r+0x83c>
    f0f4:	lsls	r2, r5, #24
    f0f6:	bpl.n	f0d2 <__ssvfscanf_r+0x85e>
    f0f8:	bic.w	r5, r5, #128	; 0x80
    f0fc:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f0fe:	cmp.w	r8, #7
    f102:	bne.n	f0d2 <__ssvfscanf_r+0x85e>
    f104:	mov.w	r8, #8
    f108:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f10a:	cmp.w	r8, #6
    f10e:	bne.n	f0d2 <__ssvfscanf_r+0x85e>
    f110:	mov.w	r8, #7
    f114:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f116:	cmp	r3, #0
    f118:	bne.w	f2d8 <__ssvfscanf_r+0xa64>
    f11c:	cbnz	r6, f12a <__ssvfscanf_r+0x8b6>
    f11e:	and.w	lr, r5, #1792	; 0x700
    f122:	cmp.w	lr, #1792	; 0x700
    f126:	beq.w	f5b0 <__ssvfscanf_r+0xd3c>
    f12a:	cmp.w	r8, #1
    f12e:	beq.n	f136 <__ssvfscanf_r+0x8c2>
    f130:	cmp.w	r8, #4
    f134:	bne.n	f0d2 <__ssvfscanf_r+0x85e>
    f136:	add.w	r8, r8, #1
    f13a:	uxtb.w	r8, r8
    f13e:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f140:	.word	0x0000d169
    f144:	cmp.w	r8, #0
    f148:	bne.w	f2c6 <__ssvfscanf_r+0xa52>
    f14c:	cmp	r6, #0
    f14e:	bne.n	f0d6 <__ssvfscanf_r+0x862>
    f150:	and.w	lr, r5, #1792	; 0x700
    f154:	cmp.w	lr, #1792	; 0x700
    f158:	beq.w	f5d0 <__ssvfscanf_r+0xd5c>
    f15c:	subs	r3, #1
    f15e:	cmp	r3, #1
    f160:	bls.w	f666 <__ssvfscanf_r+0xdf2>
    f164:	add.w	r3, r8, #4294967295
    f168:	cmp	r3, #6
    f16a:	bhi.n	f19a <__ssvfscanf_r+0x926>
    f16c:	cmp.w	r8, #2
    f170:	bls.w	f6b4 <__ssvfscanf_r+0xe40>
    f174:	cmp.w	r8, #3
    f178:	beq.n	f19a <__ssvfscanf_r+0x926>
    f17a:	sub.w	r4, r8, #4
    f17e:	uxtb	r4, r4
    f180:	mvn.w	r8, r4
    f184:	add	r8, r9
    f186:	ldrb.w	r1, [r9, #-1]!
    f18a:	mov	r2, fp
    f18c:	mov	r0, sl
    f18e:	bl	12234 <_sungetc_r>
    f192:	cmp	r8, r9
    f194:	bne.n	f186 <__ssvfscanf_r+0x912>
    f196:	subs	r7, #1
    f198:	subs	r7, r7, r4
    f19a:	lsls	r1, r5, #23
    f19c:	bpl.n	f1d8 <__ssvfscanf_r+0x964>
    f19e:	lsls	r2, r5, #21
    f1a0:	bmi.w	f68a <__ssvfscanf_r+0xe16>
    f1a4:	ldrb.w	r1, [r9, #-1]
    f1a8:	cmp	r1, #101	; 0x65
    f1aa:	add.w	r4, r9, #4294967295
    f1ae:	add.w	r8, r7, #4294967295
    f1b2:	beq.n	f1cc <__ssvfscanf_r+0x958>
    f1b4:	cmp	r1, #69	; 0x45
    f1b6:	beq.n	f1cc <__ssvfscanf_r+0x958>
    f1b8:	mov	r2, fp
    f1ba:	mov	r0, sl
    f1bc:	bl	12234 <_sungetc_r>
    f1c0:	ldrb.w	r1, [r9, #-2]
    f1c4:	sub.w	r8, r7, #2
    f1c8:	sub.w	r4, r9, #2
    f1cc:	mov	r2, fp
    f1ce:	mov	r0, sl
    f1d0:	bl	12234 <_sungetc_r>
    f1d4:	mov	r7, r8
    f1d6:	mov	r9, r4
    f1d8:	ands.w	r2, r5, #16
    f1dc:	bne.w	ed3c <__ssvfscanf_r+0x4c8>
    f1e0:	and.w	r3, r5, #1536	; 0x600
    f1e4:	cmp.w	r3, #1024	; 0x400
    f1e8:	strb.w	r2, [r9]
    f1ec:	beq.w	f5da <__ssvfscanf_r+0xd66>
    f1f0:	ldr	r3, [sp, #52]	; 0x34
    f1f2:	cmp	r3, #0
    f1f4:	bne.w	f5fc <__ssvfscanf_r+0xd88>
    f1f8:	ldr	r1, [sp, #40]	; 0x28
    f1fa:	movs	r2, #0
    f1fc:	mov	r0, sl
    f1fe:	bl	d010 <_strtod_r>
    f202:	lsls	r3, r5, #31
    f204:	bmi.w	f492 <__ssvfscanf_r+0xc1e>
    f208:	ands.w	r5, r5, #2
    f20c:	bne.w	f492 <__ssvfscanf_r+0xc1e>
    f210:	vmov	r2, r3, d0
    f214:	vmov	r0, r1, d0
    f218:	vstr	d0, [sp, #32]
    f21c:	bl	adec <__aeabi_dcmpun>
    f220:	ldr	r4, [sp, #20]
    f222:	vldr	d0, [sp, #32]
    f226:	adds	r6, r4, #4
    f228:	ldr	r4, [r4, #0]
    f22a:	cmp	r0, #0
    f22c:	bne.w	f6e8 <__ssvfscanf_r+0xe74>
    f230:	vmov	r0, r1, d0
    f234:	bl	aea8 <__aeabi_d2f>
    f238:	str	r6, [sp, #20]
    f23a:	str	r0, [r4, #0]
    f23c:	ldr	r3, [sp, #24]
    f23e:	ldr	r6, [sp, #12]
    f240:	adds	r3, #1
    f242:	str	r3, [sp, #24]
    f244:	mov	r4, r6
    f246:	b.w	e904 <__ssvfscanf_r+0x90>
    f24a:	cmp.w	r8, #2
    f24e:	bne.w	f0d2 <__ssvfscanf_r+0x85e>
    f252:	mov.w	r8, #3
    f256:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f258:	and.w	lr, r5, #1280	; 0x500
    f25c:	cmp.w	lr, #1024	; 0x400
    f260:	beq.n	f26e <__ssvfscanf_r+0x9fa>
    f262:	lsls	r2, r5, #21
    f264:	bpl.w	f0d2 <__ssvfscanf_r+0x85e>
    f268:	cmp	r6, #0
    f26a:	beq.w	f15c <__ssvfscanf_r+0x8e8>
    f26e:	lsls	r2, r5, #22
    f270:	bmi.n	f27c <__ssvfscanf_r+0xa08>
    f272:	ldr	r2, [sp, #44]	; 0x2c
    f274:	str.w	r9, [sp, #60]	; 0x3c
    f278:	subs	r2, r6, r2
    f27a:	str	r2, [sp, #52]	; 0x34
    f27c:	bic.w	r5, r5, #1920	; 0x780
    f280:	orr.w	r5, r5, #384	; 0x180
    f284:	movs	r6, #0
    f286:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f288:	cmp	r3, #1
    f28a:	bne.w	f0d2 <__ssvfscanf_r+0x85e>
    f28e:	movs	r3, #2
    f290:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f292:	ldr	r2, [sp, #48]	; 0x30
    f294:	ldrb.w	lr, [r2]
    f298:	cmp	lr, r1
    f29a:	bne.w	f0d2 <__ssvfscanf_r+0x85e>
    f29e:	lsls	r2, r5, #22
    f2a0:	bpl.w	f0d2 <__ssvfscanf_r+0x85e>
    f2a4:	bic.w	r5, r5, #640	; 0x280
    f2a8:	str	r6, [sp, #44]	; 0x2c
    f2aa:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f2ac:	mov	r1, fp
    f2ae:	mov	r0, sl
    f2b0:	str	r3, [sp, #32]
    f2b2:	bl	122b8 <__ssrefill_r>
    f2b6:	ldr	r3, [sp, #32]
    f2b8:	cmp	r0, #0
    f2ba:	bne.w	f0d2 <__ssvfscanf_r+0x85e>
    f2be:	cmp	r4, #0
    f2c0:	bne.w	efea <__ssvfscanf_r+0x776>
    f2c4:	b.n	f0d2 <__ssvfscanf_r+0x85e>
    f2c6:	cmp.w	r8, #3
    f2ca:	beq.w	f136 <__ssvfscanf_r+0x8c2>
    f2ce:	cmp.w	r8, #5
    f2d2:	beq.w	f136 <__ssvfscanf_r+0x8c2>
    f2d6:	b.n	f0d2 <__ssvfscanf_r+0x85e>
    f2d8:	cmp	r3, #2
    f2da:	bne.w	f12a <__ssvfscanf_r+0x8b6>
    f2de:	movs	r3, #3
    f2e0:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f2e2:	subs	r3, r4, #1
    f2e4:	cmp.w	r3, #348	; 0x15c
    f2e8:	itte	hi
    f2ea:	mvnhi.w	r0, #348	; 0x15c
    f2ee:	addhi.w	r9, r4, r0
    f2f2:	movls	r9, r8
    f2f4:	add	r3, sp, #336	; 0x150
    f2f6:	mov	r0, r2
    f2f8:	mov	r2, r7
    f2fa:	mov	r7, r9
    f2fc:	ldr.w	r9, [sp, #16]
    f300:	str	r3, [sp, #40]	; 0x28
    f302:	it	hi
    f304:	movwhi	r4, #349	; 0x15d
    f308:	orr.w	r5, r5, #3456	; 0xd80
    f30c:	mov	r6, r3
    f30e:	mov.w	r8, #0
    f312:	sub.w	r3, r1, #43	; 0x2b
    f316:	cmp	r3, #77	; 0x4d
    f318:	bhi.n	f3be <__ssvfscanf_r+0xb4a>
    f31a:	tbb	[pc, r3]
    f31e:	.short	0x507e
    f320:	.word	0x6f50507e
    f324:	.word	0x69696969
    f328:	.word	0x4a696969
    f32c:	.word	0x5050504a
    f330:	.word	0x50505050
    f334:	.word	0x44444444
    f338:	.word	0x50504444
    f33c:	.word	0x50505050
    f340:	.word	0x50505050
    f344:	.word	0x50505050
    f348:	.word	0x27505050
    f34c:	.word	0x50505050
    f350:	.word	0x50505050
    f354:	.word	0x44444444
    f358:	.word	0x50504444
    f35c:	.word	0x50505050
    f360:	.word	0x50505050
    f364:	.word	0x50505050
    f368:	.word	0x27505050
    f36c:	and.w	r3, r5, #1536	; 0x600
    f370:	cmp.w	r3, #512	; 0x200
    f374:	bne.n	f3be <__ssvfscanf_r+0xb4a>
    f376:	bic.w	r5, r5, #512	; 0x200
    f37a:	orr.w	r5, r5, #1280	; 0x500
    f37e:	mov.w	r9, #16
    f382:	strb	r1, [r6, #0]
    f384:	adds	r6, #1
    f386:	ldr.w	r3, [fp, #4]
    f38a:	subs	r3, #1
    f38c:	cmp	r3, #0
    f38e:	str.w	r3, [fp, #4]
    f392:	ble.n	f47a <__ssvfscanf_r+0xc06>
    f394:	adds	r0, #1
    f396:	str.w	r0, [fp]
    f39a:	subs	r4, #1
    f39c:	beq.n	f3be <__ssvfscanf_r+0xb4a>
    f39e:	ldr.w	r0, [fp]
    f3a2:	ldrb	r1, [r0, #0]
    f3a4:	b.n	f312 <__ssvfscanf_r+0xa9e>
    f3a6:	cmp.w	r9, #10
    f3aa:	ble.n	f3be <__ssvfscanf_r+0xb4a>
    f3ac:	bic.w	r5, r5, #2944	; 0xb80
    f3b0:	b.n	f382 <__ssvfscanf_r+0xb0e>
    f3b2:	ldr	r3, [pc, #756]	; (f6a8 <__ssvfscanf_r+0xe34>)
    f3b4:	ldrsh.w	r9, [r3, r9, lsl #1]
    f3b8:	cmp.w	r9, #8
    f3bc:	bgt.n	f3ac <__ssvfscanf_r+0xb38>
    f3be:	lsls	r1, r5, #23
    f3c0:	mov	r7, r2
    f3c2:	str.w	r9, [sp, #16]
    f3c6:	bpl.n	f3d8 <__ssvfscanf_r+0xb64>
    f3c8:	ldr	r3, [sp, #40]	; 0x28
    f3ca:	cmp	r6, r3
    f3cc:	bhi.w	f5b8 <__ssvfscanf_r+0xd44>
    f3d0:	ldr	r3, [sp, #40]	; 0x28
    f3d2:	cmp	r6, r3
    f3d4:	beq.w	e910 <__ssvfscanf_r+0x9c>
    f3d8:	ands.w	r4, r5, #16
    f3dc:	beq.w	f504 <__ssvfscanf_r+0xc90>
    f3e0:	ldr	r3, [sp, #40]	; 0x28
    f3e2:	subs	r6, r6, r3
    f3e4:	add	r6, r8
    f3e6:	add	r7, r6
    f3e8:	ldr	r6, [sp, #12]
    f3ea:	mov	r4, r6
    f3ec:	b.w	e904 <__ssvfscanf_r+0x90>
    f3f0:	ldr	r3, [pc, #692]	; (f6a8 <__ssvfscanf_r+0xe34>)
    f3f2:	bic.w	r5, r5, #2944	; 0xb80
    f3f6:	ldrsh.w	r9, [r3, r9, lsl #1]
    f3fa:	b.n	f382 <__ssvfscanf_r+0xb0e>
    f3fc:	lsls	r3, r5, #20
    f3fe:	bpl.n	f382 <__ssvfscanf_r+0xb0e>
    f400:	cmp.w	r9, #0
    f404:	bne.n	f40e <__ssvfscanf_r+0xb9a>
    f406:	orr.w	r5, r5, #512	; 0x200
    f40a:	mov.w	r9, #8
    f40e:	lsls	r3, r5, #21
    f410:	bpl.w	f594 <__ssvfscanf_r+0xd20>
    f414:	bic.w	r5, r5, #1408	; 0x580
    f418:	b.n	f382 <__ssvfscanf_r+0xb0e>
    f41a:	lsls	r3, r5, #24
    f41c:	bpl.n	f3be <__ssvfscanf_r+0xb4a>
    f41e:	bic.w	r5, r5, #128	; 0x80
    f422:	b.n	f382 <__ssvfscanf_r+0xb0e>
    f424:	cmp	r4, #0
    f426:	it	eq
    f428:	moveq.w	r4, #4294967295
    f42c:	ands.w	r3, r5, #1
    f430:	bne.w	ecf0 <__ssvfscanf_r+0x47c>
    f434:	lsls	r1, r5, #27
    f436:	bpl.n	f4a0 <__ssvfscanf_r+0xc2c>
    f438:	mov	r5, r3
    f43a:	bl	b304 <__locale_ctype_ptr>
    f43e:	ldr.w	r3, [fp]
    f442:	ldrb	r2, [r3, #0]
    f444:	add	r0, r2
    f446:	adds	r3, #1
    f448:	ldrb	r2, [r0, #1]
    f44a:	lsls	r2, r2, #28
    f44c:	bmi.w	ebce <__ssvfscanf_r+0x35a>
    f450:	ldr.w	r2, [fp, #4]
    f454:	str.w	r3, [fp]
    f458:	adds	r5, #1
    f45a:	subs	r3, r2, #1
    f45c:	cmp	r4, r5
    f45e:	str.w	r3, [fp, #4]
    f462:	beq.w	ebce <__ssvfscanf_r+0x35a>
    f466:	cmp	r3, #0
    f468:	bgt.n	f43a <__ssvfscanf_r+0xbc6>
    f46a:	mov	r1, fp
    f46c:	mov	r0, sl
    f46e:	bl	122b8 <__ssrefill_r>
    f472:	cmp	r0, #0
    f474:	beq.n	f43a <__ssvfscanf_r+0xbc6>
    f476:	b.w	ebce <__ssvfscanf_r+0x35a>
    f47a:	mov	r1, fp
    f47c:	mov	r0, sl
    f47e:	str	r2, [sp, #16]
    f480:	bl	122b8 <__ssrefill_r>
    f484:	ldr	r2, [sp, #16]
    f486:	cmp	r0, #0
    f488:	beq.n	f39a <__ssvfscanf_r+0xb26>
    f48a:	b.n	f3be <__ssvfscanf_r+0xb4a>
    f48c:	str.w	r8, [sp, #56]	; 0x38
    f490:	b.n	efca <__ssvfscanf_r+0x756>
    f492:	ldr	r2, [sp, #20]
    f494:	ldr	r3, [r2, #0]
    f496:	adds	r2, #4
    f498:	str	r2, [sp, #20]
    f49a:	vstr	d0, [r3]
    f49e:	b.n	f23c <__ssvfscanf_r+0x9c8>
    f4a0:	ldr	r2, [sp, #20]
    f4a2:	ldr	r5, [r2, #0]
    f4a4:	adds	r6, r2, #4
    f4a6:	add	r4, r5
    f4a8:	mov	r8, r5
    f4aa:	bl	b304 <__locale_ctype_ptr>
    f4ae:	ldr.w	r2, [fp]
    f4b2:	ldrb	r3, [r2, #0]
    f4b4:	add	r0, r3
    f4b6:	adds	r1, r2, #1
    f4b8:	ldrb	r3, [r0, #1]
    f4ba:	lsls	r3, r3, #28
    f4bc:	bmi.n	f4ea <__ssvfscanf_r+0xc76>
    f4be:	ldr.w	r3, [fp, #4]
    f4c2:	str.w	r1, [fp]
    f4c6:	subs	r3, #1
    f4c8:	str.w	r3, [fp, #4]
    f4cc:	ldrb	r3, [r2, #0]
    f4ce:	strb.w	r3, [r8], #1
    f4d2:	cmp	r4, r8
    f4d4:	beq.n	f4ec <__ssvfscanf_r+0xc78>
    f4d6:	ldr.w	r3, [fp, #4]
    f4da:	cmp	r3, #0
    f4dc:	bgt.n	f4aa <__ssvfscanf_r+0xc36>
    f4de:	mov	r1, fp
    f4e0:	mov	r0, sl
    f4e2:	bl	122b8 <__ssrefill_r>
    f4e6:	cmp	r0, #0
    f4e8:	beq.n	f4aa <__ssvfscanf_r+0xc36>
    f4ea:	mov	r4, r8
    f4ec:	ldr	r2, [sp, #24]
    f4ee:	str	r6, [sp, #20]
    f4f0:	ldr	r6, [sp, #12]
    f4f2:	subs	r5, r4, r5
    f4f4:	movs	r3, #0
    f4f6:	adds	r2, #1
    f4f8:	strb	r3, [r4, #0]
    f4fa:	add	r7, r5
    f4fc:	str	r2, [sp, #24]
    f4fe:	mov	r4, r6
    f500:	b.w	e904 <__ssvfscanf_r+0x90>
    f504:	mov	r2, r4
    f506:	strb	r4, [r6, #0]
    f508:	ldr	r3, [sp, #16]
    f50a:	ldr	r1, [sp, #40]	; 0x28
    f50c:	ldr	r4, [sp, #28]
    f50e:	mov	r0, sl
    f510:	blx	r4
    f512:	lsls	r2, r5, #26
    f514:	bmi.n	f5a4 <__ssvfscanf_r+0xd30>
    f516:	lsls	r3, r5, #29
    f518:	bpl.n	f612 <__ssvfscanf_r+0xd9e>
    f51a:	ldr	r2, [sp, #20]
    f51c:	ldr	r3, [r2, #0]
    f51e:	adds	r2, #4
    f520:	str	r2, [sp, #20]
    f522:	strh	r0, [r3, #0]
    f524:	ldr	r3, [sp, #24]
    f526:	adds	r3, #1
    f528:	str	r3, [sp, #24]
    f52a:	b.n	f3e0 <__ssvfscanf_r+0xb6c>
    f52c:	bl	b2e0 <__locale_mb_cur_max>
    f530:	cmp	r6, r0
    f532:	beq.w	eabe <__ssvfscanf_r+0x24a>
    f536:	ldmia.w	fp, {r2, r3}
    f53a:	ldrb.w	r0, [r2], #1
    f53e:	str.w	r2, [fp]
    f542:	ldr	r2, [sp, #32]
    f544:	str	r2, [sp, #0]
    f546:	add	r2, sp, #336	; 0x150
    f548:	adds	r5, r6, #1
    f54a:	subs	r3, #1
    f54c:	strb	r0, [r2, r6]
    f54e:	str.w	r3, [fp, #4]
    f552:	mov	r1, r8
    f554:	mov	r3, r5
    f556:	mov	r0, sl
    f558:	bl	11204 <_mbrtowc_r>
    f55c:	adds	r6, r0, #1
    f55e:	beq.w	eabe <__ssvfscanf_r+0x24a>
    f562:	cmp	r0, #0
    f564:	bne.n	f63e <__ssvfscanf_r+0xdca>
    f566:	str.w	r0, [r8]
    f56a:	bl	111c8 <iswspace>
    f56e:	cmp	r0, #0
    f570:	beq.w	f6d2 <__ssvfscanf_r+0xe5e>
    f574:	cmp	r5, #0
    f576:	beq.w	ed2c <__ssvfscanf_r+0x4b8>
    f57a:	add	r3, sp, #336	; 0x150
    f57c:	adds	r4, r3, r5
    f57e:	subs	r5, #1
    f580:	mov	r2, fp
    f582:	ldrb.w	r1, [r4, #-1]!
    f586:	mov	r0, sl
    f588:	bl	12234 <_sungetc_r>
    f58c:	cmp	r5, #0
    f58e:	bne.n	f57e <__ssvfscanf_r+0xd0a>
    f590:	b.w	ed2c <__ssvfscanf_r+0x4b8>
    f594:	bic.w	r5, r5, #896	; 0x380
    f598:	cbz	r7, f59e <__ssvfscanf_r+0xd2a>
    f59a:	subs	r7, #1
    f59c:	adds	r4, #1
    f59e:	add.w	r8, r8, #1
    f5a2:	b.n	f386 <__ssvfscanf_r+0xb12>
    f5a4:	ldr	r2, [sp, #20]
    f5a6:	ldr	r3, [r2, #0]
    f5a8:	adds	r2, #4
    f5aa:	str	r2, [sp, #20]
    f5ac:	str	r0, [r3, #0]
    f5ae:	b.n	f524 <__ssvfscanf_r+0xcb0>
    f5b0:	bic.w	r5, r5, #1920	; 0x780
    f5b4:	movs	r3, #1
    f5b6:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f5b8:	ldrb.w	r1, [r6, #-1]
    f5bc:	mov	r2, fp
    f5be:	mov	r0, sl
    f5c0:	bl	12234 <_sungetc_r>
    f5c4:	subs	r6, #1
    f5c6:	b.n	f3d0 <__ssvfscanf_r+0xb5c>
    f5c8:	add.w	r8, sp, #68	; 0x44
    f5cc:	b.w	ed12 <__ssvfscanf_r+0x49e>
    f5d0:	bic.w	r5, r5, #1920	; 0x780
    f5d4:	mov.w	r8, #1
    f5d8:	b.n	f0a8 <__ssvfscanf_r+0x834>
    f5da:	ldr	r3, [sp, #44]	; 0x2c
    f5dc:	subs	r6, r6, r3
    f5de:	negs	r2, r6
    f5e0:	cmp	r6, #0
    f5e2:	beq.w	f1f8 <__ssvfscanf_r+0x984>
    f5e6:	addw	r3, sp, #675	; 0x2a3
    f5ea:	cmp	r9, r3
    f5ec:	it	cs
    f5ee:	addwcs	r9, sp, #674	; 0x2a2
    f5f2:	mov	r0, r9
    f5f4:	ldr	r1, [pc, #180]	; (f6ac <__ssvfscanf_r+0xe38>)
    f5f6:	bl	beb8 <sprintf>
    f5fa:	b.n	f1f8 <__ssvfscanf_r+0x984>
    f5fc:	ldr	r4, [sp, #60]	; 0x3c
    f5fe:	mov	r1, r4
    f600:	movs	r3, #10
    f602:	adds	r1, #1
    f604:	mov	r0, sl
    f606:	bl	d168 <_strtol_r>
    f60a:	ldr	r3, [sp, #52]	; 0x34
    f60c:	mov	r9, r4
    f60e:	subs	r2, r0, r3
    f610:	b.n	f5e6 <__ssvfscanf_r+0xd72>
    f612:	ands.w	r2, r5, #1
    f616:	bne.n	f5a4 <__ssvfscanf_r+0xd30>
    f618:	lsls	r4, r5, #30
    f61a:	bpl.n	f5a4 <__ssvfscanf_r+0xd30>
    f61c:	ldr	r3, [sp, #28]
    f61e:	mov	r1, r3
    f620:	ldr	r3, [pc, #140]	; (f6b0 <__ssvfscanf_r+0xe3c>)
    f622:	cmp	r1, r3
    f624:	mov	r0, sl
    f626:	ldr	r3, [sp, #16]
    f628:	ldr	r1, [sp, #40]	; 0x28
    f62a:	beq.n	f6f6 <__ssvfscanf_r+0xe82>
    f62c:	bl	11d74 <_strtoll_r>
    f630:	ldr	r2, [sp, #20]
    f632:	ldr	r3, [r2, #0]
    f634:	adds	r2, #4
    f636:	str	r2, [sp, #20]
    f638:	strd	r0, r1, [r3]
    f63c:	b.n	f524 <__ssvfscanf_r+0xcb0>
    f63e:	adds	r0, #2
    f640:	bne.n	f684 <__ssvfscanf_r+0xe10>
    f642:	mov	r6, r5
    f644:	ldr.w	r3, [fp, #4]
    f648:	cmp	r3, #0
    f64a:	bgt.w	ed14 <__ssvfscanf_r+0x4a0>
    f64e:	mov	r1, fp
    f650:	mov	r0, sl
    f652:	bl	122b8 <__ssrefill_r>
    f656:	cmp	r0, #0
    f658:	beq.w	ed14 <__ssvfscanf_r+0x4a0>
    f65c:	cmp	r6, #0
    f65e:	bne.w	eabe <__ssvfscanf_r+0x24a>
    f662:	b.w	ed2c <__ssvfscanf_r+0x4b8>
    f666:	ldr	r3, [sp, #40]	; 0x28
    f668:	cmp	r9, r3
    f66a:	bls.w	e910 <__ssvfscanf_r+0x9c>
    f66e:	ldrb.w	r1, [r9, #-1]!
    f672:	mov	r2, fp
    f674:	mov	r0, sl
    f676:	bl	12234 <_sungetc_r>
    f67a:	ldr	r3, [sp, #40]	; 0x28
    f67c:	cmp	r9, r3
    f67e:	bne.n	f66e <__ssvfscanf_r+0xdfa>
    f680:	b.w	e910 <__ssvfscanf_r+0x9c>
    f684:	ldr.w	r0, [r8]
    f688:	b.n	f56a <__ssvfscanf_r+0xcf6>
    f68a:	ldr	r3, [sp, #40]	; 0x28
    f68c:	cmp	r9, r3
    f68e:	bls.w	e910 <__ssvfscanf_r+0x9c>
    f692:	ldrb.w	r1, [r9, #-1]!
    f696:	mov	r2, fp
    f698:	mov	r0, sl
    f69a:	bl	12234 <_sungetc_r>
    f69e:	ldr	r3, [sp, #40]	; 0x28
    f6a0:	cmp	r9, r3
    f6a2:	bne.n	f692 <__ssvfscanf_r+0xe1e>
    f6a4:	b.w	e910 <__ssvfscanf_r+0x9c>
    f6a8:	.word	0x000131e4
    f6ac:	.word	0x00013208
    f6b0:	.word	0x00011f01
    f6b4:	ldr	r3, [sp, #40]	; 0x28
    f6b6:	cmp	r9, r3
    f6b8:	bls.w	e910 <__ssvfscanf_r+0x9c>
    f6bc:	ldrb.w	r1, [r9, #-1]!
    f6c0:	mov	r2, fp
    f6c2:	mov	r0, sl
    f6c4:	bl	12234 <_sungetc_r>
    f6c8:	ldr	r3, [sp, #40]	; 0x28
    f6ca:	cmp	r9, r3
    f6cc:	bne.n	f6bc <__ssvfscanf_r+0xe48>
    f6ce:	b.w	e910 <__ssvfscanf_r+0x9c>
    f6d2:	add	r7, r5
    f6d4:	subs	r4, #1
    f6d6:	cmp.w	r9, #0
    f6da:	bne.n	f6e4 <__ssvfscanf_r+0xe70>
    f6dc:	add.w	r8, r8, #4
    f6e0:	mov	r6, r9
    f6e2:	b.n	f644 <__ssvfscanf_r+0xdd0>
    f6e4:	mov	r6, r0
    f6e6:	b.n	f644 <__ssvfscanf_r+0xdd0>
    f6e8:	mov	r0, r5
    f6ea:	bl	11bbc <nanf>
    f6ee:	str	r6, [sp, #20]
    f6f0:	vstr	s0, [r4]
    f6f4:	b.n	f23c <__ssvfscanf_r+0x9c8>
    f6f6:	bl	12110 <_strtoull_r>
    f6fa:	b.n	f630 <__ssvfscanf_r+0xdbc>

0000f6fc <_vdprintf_r>:
    f6fc:	push	{r4, r5, r6, r7, lr}
    f6fe:	sub.w	sp, sp, #532	; 0x214
    f702:	add	r5, sp, #16
    f704:	str	r3, [sp, #0]
    f706:	mov	r7, r1
    f708:	mov	r3, r2
    f70a:	mov.w	r4, #512	; 0x200
    f70e:	add	r2, sp, #12
    f710:	mov	r1, r5
    f712:	str	r4, [sp, #12]
    f714:	mov	r6, r0
    f716:	bl	123f0 <_vasnprintf_r>
    f71a:	cbz	r0, f740 <_vdprintf_r+0x44>
    f71c:	mov	r4, r0
    f71e:	mov	r2, r0
    f720:	mov	r1, r7
    f722:	ldr	r3, [sp, #12]
    f724:	mov	r0, r6
    f726:	bl	f77c <_write_r>
    f72a:	cmp	r4, r5
    f72c:	str	r0, [sp, #12]
    f72e:	beq.n	f73a <_vdprintf_r+0x3e>
    f730:	mov	r0, r6
    f732:	mov	r1, r4
    f734:	bl	10890 <_free_r>
    f738:	ldr	r0, [sp, #12]
    f73a:	add.w	sp, sp, #532	; 0x214
    f73e:	pop	{r4, r5, r6, r7, pc}
    f740:	mov.w	r0, #4294967295
    f744:	b.n	f73a <_vdprintf_r+0x3e>
    f746:	nop

0000f748 <vdprintf>:
    f748:	push	{r4}
    f74a:	ldr	r4, [pc, #16]	; (f75c <vdprintf+0x14>)
    f74c:	mov	r3, r2
    f74e:	mov	r2, r1
    f750:	mov	r1, r0
    f752:	ldr	r0, [r4, #0]
    f754:	ldr.w	r4, [sp], #4
    f758:	b.w	f6fc <_vdprintf_r>
    f75c:	.word	0x1fff1828

0000f760 <__ascii_wctomb>:
    f760:	cbz	r1, f76c <__ascii_wctomb+0xc>
    f762:	cmp	r2, #255	; 0xff
    f764:	bhi.n	f770 <__ascii_wctomb+0x10>
    f766:	strb	r2, [r1, #0]
    f768:	movs	r0, #1
    f76a:	bx	lr
    f76c:	mov	r0, r1
    f76e:	bx	lr
    f770:	movs	r3, #138	; 0x8a
    f772:	str	r3, [r0, #0]
    f774:	mov.w	r0, #4294967295
    f778:	bx	lr
    f77a:	nop

0000f77c <_write_r>:
    f77c:	push	{r4, r5, r6, lr}
    f77e:	mov	r5, r1
    f780:	ldr	r4, [pc, #32]	; (f7a4 <_write_r+0x28>)
    f782:	mov	r1, r2
    f784:	mov	r6, r0
    f786:	mov	r2, r3
    f788:	mov	r0, r5
    f78a:	movs	r3, #0
    f78c:	str	r3, [r4, #0]
    f78e:	bl	14dc <_write>
    f792:	adds	r3, r0, #1
    f794:	beq.n	f798 <_write_r+0x1c>
    f796:	pop	{r4, r5, r6, pc}
    f798:	ldr	r3, [r4, #0]
    f79a:	cmp	r3, #0
    f79c:	beq.n	f796 <_write_r+0x1a>
    f79e:	str	r3, [r6, #0]
    f7a0:	pop	{r4, r5, r6, pc}
    f7a2:	nop
    f7a4:	.word	0x2001a85c

0000f7a8 <__register_exitproc>:
    f7a8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    f7ac:	ldr	r4, [pc, #148]	; (f844 <__register_exitproc+0x9c>)
    f7ae:	ldr	r5, [r4, #0]
    f7b0:	ldr.w	r4, [r5, #328]	; 0x148
    f7b4:	mov	r6, r0
    f7b6:	mov	r8, r1
    f7b8:	mov	sl, r2
    f7ba:	mov	r9, r3
    f7bc:	cbz	r4, f830 <__register_exitproc+0x88>
    f7be:	ldr	r0, [r4, #4]
    f7c0:	cmp	r0, #31
    f7c2:	bgt.n	f7f4 <__register_exitproc+0x4c>
    f7c4:	adds	r3, r0, #1
    f7c6:	cbz	r6, f7e6 <__register_exitproc+0x3e>
    f7c8:	add.w	r5, r4, r0, lsl #2
    f7cc:	movs	r2, #1
    f7ce:	str.w	sl, [r5, #136]	; 0x88
    f7d2:	ldr.w	r1, [r4, #392]	; 0x188
    f7d6:	lsls	r2, r0
    f7d8:	orrs	r1, r2
    f7da:	cmp	r6, #2
    f7dc:	str.w	r1, [r4, #392]	; 0x188
    f7e0:	str.w	r9, [r5, #264]	; 0x108
    f7e4:	beq.n	f824 <__register_exitproc+0x7c>
    f7e6:	adds	r0, #2
    f7e8:	str	r3, [r4, #4]
    f7ea:	str.w	r8, [r4, r0, lsl #2]
    f7ee:	movs	r0, #0
    f7f0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f7f4:	ldr	r3, [pc, #80]	; (f848 <__register_exitproc+0xa0>)
    f7f6:	cbz	r3, f83a <__register_exitproc+0x92>
    f7f8:	mov.w	r0, #400	; 0x190
    f7fc:	bl	b318 <malloc>
    f800:	mov	r4, r0
    f802:	cbz	r0, f83a <__register_exitproc+0x92>
    f804:	ldr.w	r3, [r5, #328]	; 0x148
    f808:	movs	r7, #0
    f80a:	stmia.w	r0, {r3, r7}
    f80e:	str.w	r4, [r5, #328]	; 0x148
    f812:	mov	r0, r7
    f814:	movs	r3, #1
    f816:	str.w	r7, [r4, #392]	; 0x188
    f81a:	str.w	r7, [r4, #396]	; 0x18c
    f81e:	cmp	r6, #0
    f820:	beq.n	f7e6 <__register_exitproc+0x3e>
    f822:	b.n	f7c8 <__register_exitproc+0x20>
    f824:	ldr.w	r1, [r4, #396]	; 0x18c
    f828:	orrs	r2, r1
    f82a:	str.w	r2, [r4, #396]	; 0x18c
    f82e:	b.n	f7e6 <__register_exitproc+0x3e>
    f830:	add.w	r4, r5, #332	; 0x14c
    f834:	str.w	r4, [r5, #328]	; 0x148
    f838:	b.n	f7be <__register_exitproc+0x16>
    f83a:	mov.w	r0, #4294967295
    f83e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f842:	nop
    f844:	.word	0x0001310c
    f848:	.word	0x0000b319

0000f84c <register_fini>:
    f84c:	ldr	r3, [pc, #8]	; (f858 <register_fini+0xc>)
    f84e:	cbz	r3, f856 <register_fini+0xa>
    f850:	ldr	r0, [pc, #8]	; (f85c <register_fini+0x10>)
    f852:	b.w	f860 <atexit>
    f856:	bx	lr
    f858:	.word	0x00000000
    f85c:	.word	0x000107cd

0000f860 <atexit>:
    f860:	movs	r3, #0
    f862:	mov	r1, r0
    f864:	mov	r2, r3
    f866:	mov	r0, r3
    f868:	b.w	f7a8 <__register_exitproc>

0000f86c <quorem>:
    f86c:	ldr	r2, [r0, #16]
    f86e:	ldr	r3, [r1, #16]
    f870:	cmp	r3, r2
    f872:	bgt.w	f990 <quorem+0x124>
    f876:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f87a:	add.w	r8, r3, #4294967295
    f87e:	add.w	r7, r1, #20
    f882:	add.w	fp, r0, #20
    f886:	ldr.w	r2, [r7, r8, lsl #2]
    f88a:	ldr.w	r3, [fp, r8, lsl #2]
    f88e:	mov.w	r4, r8, lsl #2
    f892:	sub	sp, #12
    f894:	adds	r2, #1
    f896:	udiv	r9, r3, r2
    f89a:	add.w	r3, fp, r4
    f89e:	str	r4, [sp, #0]
    f8a0:	add.w	sl, r7, r4
    f8a4:	str	r3, [sp, #4]
    f8a6:	cmp.w	r9, #0
    f8aa:	beq.n	f920 <quorem+0xb4>
    f8ac:	movs	r5, #0
    f8ae:	mov	ip, r7
    f8b0:	mov	lr, fp
    f8b2:	mov	r3, r5
    f8b4:	ldr.w	r6, [ip], #4
    f8b8:	ldr.w	r2, [lr]
    f8bc:	uxth	r4, r6
    f8be:	mla	r5, r9, r4, r5
    f8c2:	lsrs	r6, r6, #16
    f8c4:	lsrs	r4, r5, #16
    f8c6:	mla	r4, r9, r6, r4
    f8ca:	uxth	r5, r5
    f8cc:	subs	r3, r3, r5
    f8ce:	uxth	r6, r4
    f8d0:	uxtah	r3, r3, r2
    f8d4:	rsb	r6, r6, r2, lsr #16
    f8d8:	add.w	r6, r6, r3, asr #16
    f8dc:	uxth	r3, r3
    f8de:	orr.w	r3, r3, r6, lsl #16
    f8e2:	cmp	sl, ip
    f8e4:	str.w	r3, [lr], #4
    f8e8:	mov.w	r5, r4, lsr #16
    f8ec:	mov.w	r3, r6, asr #16
    f8f0:	bcs.n	f8b4 <quorem+0x48>
    f8f2:	ldr	r3, [sp, #0]
    f8f4:	ldr.w	r3, [fp, r3]
    f8f8:	cbnz	r3, f920 <quorem+0xb4>
    f8fa:	ldr	r4, [sp, #4]
    f8fc:	subs	r3, r4, #4
    f8fe:	cmp	fp, r3
    f900:	bcs.n	f91c <quorem+0xb0>
    f902:	ldr.w	r3, [r4, #-4]
    f906:	cbnz	r3, f91c <quorem+0xb0>
    f908:	sub.w	r3, r4, #8
    f90c:	b.n	f914 <quorem+0xa8>
    f90e:	ldr	r2, [r3, #0]
    f910:	subs	r3, #4
    f912:	cbnz	r2, f91c <quorem+0xb0>
    f914:	cmp	fp, r3
    f916:	add.w	r8, r8, #4294967295
    f91a:	bcc.n	f90e <quorem+0xa2>
    f91c:	str.w	r8, [r0, #16]
    f920:	mov	r4, r0
    f922:	bl	11708 <__mcmp>
    f926:	cmp	r0, #0
    f928:	blt.n	f988 <quorem+0x11c>
    f92a:	add.w	r9, r9, #1
    f92e:	mov	r5, fp
    f930:	movs	r3, #0
    f932:	ldr.w	r1, [r7], #4
    f936:	ldr	r0, [r5, #0]
    f938:	uxth	r2, r1
    f93a:	subs	r2, r3, r2
    f93c:	lsrs	r1, r1, #16
    f93e:	uxtah	r2, r2, r0
    f942:	rsb	r3, r1, r0, lsr #16
    f946:	add.w	r3, r3, r2, asr #16
    f94a:	uxth	r1, r2
    f94c:	orr.w	r1, r1, r3, lsl #16
    f950:	cmp	sl, r7
    f952:	str.w	r1, [r5], #4
    f956:	mov.w	r3, r3, asr #16
    f95a:	bcs.n	f932 <quorem+0xc6>
    f95c:	ldr.w	r2, [fp, r8, lsl #2]
    f960:	add.w	r3, fp, r8, lsl #2
    f964:	cbnz	r2, f988 <quorem+0x11c>
    f966:	subs	r2, r3, #4
    f968:	cmp	fp, r2
    f96a:	bcs.n	f984 <quorem+0x118>
    f96c:	ldr.w	r2, [r3, #-4]
    f970:	cbnz	r2, f984 <quorem+0x118>
    f972:	subs	r3, #8
    f974:	b.n	f97c <quorem+0x110>
    f976:	ldr	r2, [r3, #0]
    f978:	subs	r3, #4
    f97a:	cbnz	r2, f984 <quorem+0x118>
    f97c:	cmp	fp, r3
    f97e:	add.w	r8, r8, #4294967295
    f982:	bcc.n	f976 <quorem+0x10a>
    f984:	str.w	r8, [r4, #16]
    f988:	mov	r0, r9
    f98a:	add	sp, #12
    f98c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f990:	movs	r0, #0
    f992:	bx	lr
    f994:			; <UNDEFINED> instruction: 0xffffffff

0000f998 <_dtoa_r>:
    f998:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f99c:	vmov	r6, r7, d0
    f9a0:	sub	sp, #108	; 0x6c
    f9a2:	ldr	r4, [r0, #64]	; 0x40
    f9a4:	ldr	r5, [sp, #144]	; 0x90
    f9a6:	str	r1, [sp, #0]
    f9a8:	mov	r9, r0
    f9aa:	str	r2, [sp, #20]
    f9ac:	str	r3, [sp, #12]
    f9ae:	vmov	sl, s0
    f9b2:	mov	fp, r7
    f9b4:	cbz	r4, f9cc <_dtoa_r+0x34>
    f9b6:	ldr	r2, [r0, #68]	; 0x44
    f9b8:	str	r2, [r4, #4]
    f9ba:	movs	r3, #1
    f9bc:	lsls	r3, r2
    f9be:	str	r3, [r4, #8]
    f9c0:	mov	r1, r4
    f9c2:	bl	112ac <_Bfree>
    f9c6:	movs	r3, #0
    f9c8:	str.w	r3, [r9, #64]	; 0x40
    f9cc:	cmp.w	fp, #0
    f9d0:	mov	r4, fp
    f9d2:	blt.n	fa3e <_dtoa_r+0xa6>
    f9d4:	movs	r3, #0
    f9d6:	str	r3, [r5, #0]
    f9d8:	ldr	r3, [pc, #644]	; (fc60 <_dtoa_r+0x2c8>)
    f9da:	mov	r2, r3
    f9dc:	ands	r3, r4
    f9de:	cmp	r3, r2
    f9e0:	beq.n	fa10 <_dtoa_r+0x78>
    f9e2:	movs	r2, #0
    f9e4:	movs	r3, #0
    f9e6:	mov	r0, sl
    f9e8:	mov	r1, fp
    f9ea:	bl	ad88 <__aeabi_dcmpeq>
    f9ee:	mov	r6, sl
    f9f0:	mov	r7, fp
    f9f2:	mov	r8, r0
    f9f4:	cbz	r0, fa4a <_dtoa_r+0xb2>
    f9f6:	ldr	r2, [sp, #12]
    f9f8:	movs	r3, #1
    f9fa:	str	r3, [r2, #0]
    f9fc:	ldr	r3, [sp, #148]	; 0x94
    f9fe:	cmp	r3, #0
    fa00:	beq.w	fb80 <_dtoa_r+0x1e8>
    fa04:	ldr	r0, [pc, #604]	; (fc64 <_dtoa_r+0x2cc>)
    fa06:	str	r0, [r3, #0]
    fa08:	subs	r0, #1
    fa0a:	add	sp, #108	; 0x6c
    fa0c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fa10:	ldr	r2, [sp, #12]
    fa12:	movw	r3, #9999	; 0x270f
    fa16:	str	r3, [r2, #0]
    fa18:	cmp.w	sl, #0
    fa1c:	beq.w	fb54 <_dtoa_r+0x1bc>
    fa20:	ldr	r0, [pc, #580]	; (fc68 <_dtoa_r+0x2d0>)
    fa22:	ldr	r3, [sp, #148]	; 0x94
    fa24:	cmp	r3, #0
    fa26:	beq.n	fa0a <_dtoa_r+0x72>
    fa28:	ldrb	r3, [r0, #3]
    fa2a:	cmp	r3, #0
    fa2c:	beq.w	fb84 <_dtoa_r+0x1ec>
    fa30:	add.w	r3, r0, #8
    fa34:	ldr	r2, [sp, #148]	; 0x94
    fa36:	str	r3, [r2, #0]
    fa38:	add	sp, #108	; 0x6c
    fa3a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fa3e:	movs	r3, #1
    fa40:	bic.w	r4, fp, #2147483648	; 0x80000000
    fa44:	str	r3, [r5, #0]
    fa46:	mov	fp, r4
    fa48:	b.n	f9d8 <_dtoa_r+0x40>
    fa4a:	add	r2, sp, #96	; 0x60
    fa4c:	add	r1, sp, #100	; 0x64
    fa4e:	vmov	d0, r6, r7
    fa52:	mov	r0, r9
    fa54:	bl	11984 <__d2b>
    fa58:	lsrs	r5, r4, #20
    fa5a:	str	r0, [sp, #40]	; 0x28
    fa5c:	bne.w	fb66 <_dtoa_r+0x1ce>
    fa60:	ldr	r5, [sp, #96]	; 0x60
    fa62:	ldr	r6, [sp, #100]	; 0x64
    fa64:	add	r6, r5
    fa66:	addw	r3, r6, #1074	; 0x432
    fa6a:	cmp	r3, #32
    fa6c:	ble.w	ff80 <_dtoa_r+0x5e8>
    fa70:	rsb	r3, r3, #64	; 0x40
    fa74:	addw	r0, r6, #1042	; 0x412
    fa78:	lsls	r4, r3
    fa7a:	lsr.w	r0, sl, r0
    fa7e:	orrs	r0, r4
    fa80:	bl	a7cc <__aeabi_ui2d>
    fa84:	movs	r3, #1
    fa86:	subs	r4, r6, #1
    fa88:	sub.w	r1, r1, #32505856	; 0x1f00000
    fa8c:	str	r3, [sp, #60]	; 0x3c
    fa8e:	movs	r2, #0
    fa90:	ldr	r3, [pc, #472]	; (fc6c <_dtoa_r+0x2d4>)
    fa92:	bl	a550 <__aeabi_dsub>
    fa96:	add	r3, pc, #432	; (adr r3, fc48 <_dtoa_r+0x2b0>)
    fa98:	ldrd	r2, r3, [r3]
    fa9c:	bl	a8b8 <__aeabi_dmul>
    faa0:	add	r3, pc, #428	; (adr r3, fc50 <_dtoa_r+0x2b8>)
    faa2:	ldrd	r2, r3, [r3]
    faa6:	bl	a554 <__adddf3>
    faaa:	mov	r6, r0
    faac:	mov	r0, r4
    faae:	mov	r7, r1
    fab0:	bl	a7ec <__aeabi_i2d>
    fab4:	add	r3, pc, #416	; (adr r3, fc58 <_dtoa_r+0x2c0>)
    fab6:	ldrd	r2, r3, [r3]
    faba:	bl	a8b8 <__aeabi_dmul>
    fabe:	mov	r2, r0
    fac0:	mov	r3, r1
    fac2:	mov	r0, r6
    fac4:	mov	r1, r7
    fac6:	bl	a554 <__adddf3>
    faca:	mov	r6, r0
    facc:	mov	r7, r1
    face:	bl	ae18 <__aeabi_d2iz>
    fad2:	movs	r2, #0
    fad4:	str	r0, [sp, #16]
    fad6:	movs	r3, #0
    fad8:	mov	r0, r6
    fada:	mov	r1, r7
    fadc:	bl	ad9c <__aeabi_dcmplt>
    fae0:	cmp	r0, #0
    fae2:	bne.w	ff36 <_dtoa_r+0x59e>
    fae6:	ldr	r6, [sp, #16]
    fae8:	cmp	r6, #22
    faea:	bhi.w	ff30 <_dtoa_r+0x598>
    faee:	ldr	r3, [pc, #384]	; (fc70 <_dtoa_r+0x2d8>)
    faf0:	add.w	r3, r3, r6, lsl #3
    faf4:	ldrd	r0, r1, [r3]
    faf8:	mov	r2, sl
    fafa:	mov	r3, fp
    fafc:	bl	add8 <__aeabi_dcmpgt>
    fb00:	cmp	r0, #0
    fb02:	beq.w	ff8a <_dtoa_r+0x5f2>
    fb06:	subs	r3, r6, #1
    fb08:	str	r3, [sp, #16]
    fb0a:	movs	r3, #0
    fb0c:	str	r3, [sp, #52]	; 0x34
    fb0e:	subs	r5, r5, r4
    fb10:	subs.w	r8, r5, #1
    fb14:	bmi.w	ff6c <_dtoa_r+0x5d4>
    fb18:	movs	r3, #0
    fb1a:	str	r3, [sp, #28]
    fb1c:	ldr	r3, [sp, #16]
    fb1e:	cmp	r3, #0
    fb20:	blt.w	ff5a <_dtoa_r+0x5c2>
    fb24:	add	r8, r3
    fb26:	str	r3, [sp, #48]	; 0x30
    fb28:	movs	r3, #0
    fb2a:	str	r3, [sp, #24]
    fb2c:	ldr	r3, [sp, #0]
    fb2e:	cmp	r3, #9
    fb30:	bhi.n	fb88 <_dtoa_r+0x1f0>
    fb32:	cmp	r3, #5
    fb34:	ble.w	107c0 <_dtoa_r+0xe28>
    fb38:	subs	r3, #4
    fb3a:	str	r3, [sp, #0]
    fb3c:	movs	r6, #0
    fb3e:	ldr	r3, [sp, #0]
    fb40:	subs	r3, #2
    fb42:	cmp	r3, #3
    fb44:	bhi.w	1078e <_dtoa_r+0xdf6>
    fb48:	tbh	[pc, r3, lsl #1]
    fb4c:	.word	0x0224032b
    fb50:	.word	0x04500336
    fb54:	ldr	r3, [pc, #272]	; (fc68 <_dtoa_r+0x2d0>)
    fb56:	ldr	r2, [pc, #284]	; (fc74 <_dtoa_r+0x2dc>)
    fb58:	ubfx	r0, r4, #0, #20
    fb5c:	cmp	r0, #0
    fb5e:	ite	ne
    fb60:	movne	r0, r3
    fb62:	moveq	r0, r2
    fb64:	b.n	fa22 <_dtoa_r+0x8a>
    fb66:	ubfx	r3, fp, #0, #20
    fb6a:	orr.w	r1, r3, #1069547520	; 0x3fc00000
    fb6e:	subw	r4, r5, #1023	; 0x3ff
    fb72:	mov	r0, sl
    fb74:	str.w	r8, [sp, #60]	; 0x3c
    fb78:	orr.w	r1, r1, #3145728	; 0x300000
    fb7c:	ldr	r5, [sp, #96]	; 0x60
    fb7e:	b.n	fa8e <_dtoa_r+0xf6>
    fb80:	ldr	r0, [pc, #244]	; (fc78 <_dtoa_r+0x2e0>)
    fb82:	b.n	fa0a <_dtoa_r+0x72>
    fb84:	adds	r3, r0, #3
    fb86:	b.n	fa34 <_dtoa_r+0x9c>
    fb88:	movs	r1, #0
    fb8a:	str.w	r1, [r9, #68]	; 0x44
    fb8e:	mov	r0, r9
    fb90:	mov	r4, r1
    fb92:	str	r1, [sp, #0]
    fb94:	bl	11260 <_Balloc>
    fb98:	mov.w	r3, #4294967295
    fb9c:	str	r3, [sp, #32]
    fb9e:	str	r3, [sp, #56]	; 0x38
    fba0:	movs	r3, #1
    fba2:	str	r0, [sp, #36]	; 0x24
    fba4:	str.w	r0, [r9, #64]	; 0x40
    fba8:	str	r4, [sp, #20]
    fbaa:	str	r3, [sp, #44]	; 0x2c
    fbac:	ldr	r3, [sp, #100]	; 0x64
    fbae:	cmp	r3, #0
    fbb0:	blt.w	fd54 <_dtoa_r+0x3bc>
    fbb4:	ldr	r2, [sp, #16]
    fbb6:	cmp	r2, #14
    fbb8:	bgt.w	fd54 <_dtoa_r+0x3bc>
    fbbc:	ldr	r3, [pc, #176]	; (fc70 <_dtoa_r+0x2d8>)
    fbbe:	add.w	r3, r3, r2, lsl #3
    fbc2:	vldr	d7, [r3]
    fbc6:	ldr	r3, [sp, #20]
    fbc8:	cmp	r3, #0
    fbca:	vstr	d7, [sp]
    fbce:	blt.w	101ce <_dtoa_r+0x836>
    fbd2:	mov	r6, sl
    fbd4:	mov	r7, fp
    fbd6:	ldrd	sl, fp, [sp]
    fbda:	mov	r0, r6
    fbdc:	mov	r2, sl
    fbde:	mov	r3, fp
    fbe0:	mov	r1, r7
    fbe2:	bl	ab0c <__aeabi_ddiv>
    fbe6:	bl	ae18 <__aeabi_d2iz>
    fbea:	mov	r4, r0
    fbec:	bl	a7ec <__aeabi_i2d>
    fbf0:	mov	r2, sl
    fbf2:	mov	r3, fp
    fbf4:	bl	a8b8 <__aeabi_dmul>
    fbf8:	mov	r3, r1
    fbfa:	mov	r2, r0
    fbfc:	mov	r1, r7
    fbfe:	mov	r0, r6
    fc00:	bl	a550 <__aeabi_dsub>
    fc04:	ldr	r5, [sp, #36]	; 0x24
    fc06:	add.w	r3, r4, #48	; 0x30
    fc0a:	strb	r3, [r5, #0]
    fc0c:	ldr	r3, [sp, #32]
    fc0e:	cmp	r3, #1
    fc10:	mov	r6, r0
    fc12:	mov	r7, r1
    fc14:	add.w	r5, r5, #1
    fc18:	beq.n	fcde <_dtoa_r+0x346>
    fc1a:	movs	r2, #0
    fc1c:	ldr	r3, [pc, #92]	; (fc7c <_dtoa_r+0x2e4>)
    fc1e:	bl	a8b8 <__aeabi_dmul>
    fc22:	movs	r2, #0
    fc24:	movs	r3, #0
    fc26:	mov	r6, r0
    fc28:	mov	r7, r1
    fc2a:	bl	ad88 <__aeabi_dcmpeq>
    fc2e:	cmp	r0, #0
    fc30:	bne.n	fd2e <_dtoa_r+0x396>
    fc32:	str.w	r9, [sp, #20]
    fc36:	ldr.w	sl, [sp, #32]
    fc3a:	ldr.w	fp, [sp, #36]	; 0x24
    fc3e:	ldrd	r8, r9, [sp]
    fc42:	b.n	fc96 <_dtoa_r+0x2fe>
    fc44:	nop.w
    fc48:	.word	0x636f4361
    fc4c:	.word	0x3fd287a7
    fc50:	.word	0x8b60c8b3
    fc54:	.word	0x3fc68a28
    fc58:	.word	0x509f79fb
    fc5c:	.word	0x3fd34413
    fc60:	.word	0x7ff00000
    fc64:	.word	0x000131d1
    fc68:	.word	0x00013320
    fc6c:	.word	0x3ff80000
    fc70:	.word	0x00013428
    fc74:	.word	0x00013314
    fc78:	.word	0x000131d0
    fc7c:	.word	0x40240000
    fc80:	bl	a8b8 <__aeabi_dmul>
    fc84:	movs	r2, #0
    fc86:	movs	r3, #0
    fc88:	mov	r6, r0
    fc8a:	mov	r7, r1
    fc8c:	bl	ad88 <__aeabi_dcmpeq>
    fc90:	cmp	r0, #0
    fc92:	bne.w	103f2 <_dtoa_r+0xa5a>
    fc96:	mov	r2, r8
    fc98:	mov	r3, r9
    fc9a:	mov	r0, r6
    fc9c:	mov	r1, r7
    fc9e:	bl	ab0c <__aeabi_ddiv>
    fca2:	bl	ae18 <__aeabi_d2iz>
    fca6:	mov	r4, r0
    fca8:	bl	a7ec <__aeabi_i2d>
    fcac:	mov	r2, r8
    fcae:	mov	r3, r9
    fcb0:	bl	a8b8 <__aeabi_dmul>
    fcb4:	mov	r2, r0
    fcb6:	mov	r3, r1
    fcb8:	mov	r0, r6
    fcba:	mov	r1, r7
    fcbc:	bl	a550 <__aeabi_dsub>
    fcc0:	add.w	lr, r4, #48	; 0x30
    fcc4:	strb.w	lr, [r5], #1
    fcc8:	rsb	lr, fp, r5
    fccc:	cmp	lr, sl
    fcce:	mov	r6, r0
    fcd0:	mov	r7, r1
    fcd2:	mov.w	r2, #0
    fcd6:	ldr	r3, [pc, #696]	; (ff90 <_dtoa_r+0x5f8>)
    fcd8:	bne.n	fc80 <_dtoa_r+0x2e8>
    fcda:	ldr.w	r9, [sp, #20]
    fcde:	mov	r2, r6
    fce0:	mov	r3, r7
    fce2:	mov	r0, r6
    fce4:	mov	r1, r7
    fce6:	bl	a554 <__adddf3>
    fcea:	mov	r6, r0
    fcec:	mov	r7, r1
    fcee:	mov	r2, r0
    fcf0:	mov	r3, r1
    fcf2:	ldrd	r0, r1, [sp]
    fcf6:	bl	ad9c <__aeabi_dcmplt>
    fcfa:	cbnz	r0, fd0e <_dtoa_r+0x376>
    fcfc:	mov	r2, r6
    fcfe:	mov	r3, r7
    fd00:	ldrd	r0, r1, [sp]
    fd04:	bl	ad88 <__aeabi_dcmpeq>
    fd08:	cbz	r0, fd2e <_dtoa_r+0x396>
    fd0a:	lsls	r3, r4, #31
    fd0c:	bpl.n	fd2e <_dtoa_r+0x396>
    fd0e:	ldrb.w	r4, [r5, #-1]
    fd12:	ldr	r2, [sp, #36]	; 0x24
    fd14:	subs	r3, r5, #1
    fd16:	b.n	fd22 <_dtoa_r+0x38a>
    fd18:	cmp	r2, r3
    fd1a:	beq.w	10516 <_dtoa_r+0xb7e>
    fd1e:	ldrb.w	r4, [r3, #-1]!
    fd22:	cmp	r4, #57	; 0x39
    fd24:	add.w	r5, r3, #1
    fd28:	beq.n	fd18 <_dtoa_r+0x380>
    fd2a:	adds	r4, #1
    fd2c:	strb	r4, [r3, #0]
    fd2e:	ldr	r1, [sp, #40]	; 0x28
    fd30:	mov	r0, r9
    fd32:	bl	112ac <_Bfree>
    fd36:	movs	r2, #0
    fd38:	ldr	r3, [sp, #16]
    fd3a:	strb	r2, [r5, #0]
    fd3c:	ldr	r2, [sp, #12]
    fd3e:	adds	r3, #1
    fd40:	str	r3, [r2, #0]
    fd42:	ldr	r3, [sp, #148]	; 0x94
    fd44:	cmp	r3, #0
    fd46:	beq.w	10480 <_dtoa_r+0xae8>
    fd4a:	ldr	r0, [sp, #36]	; 0x24
    fd4c:	str	r5, [r3, #0]
    fd4e:	add	sp, #108	; 0x6c
    fd50:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fd54:	ldr	r2, [sp, #44]	; 0x2c
    fd56:	cmp	r2, #0
    fd58:	beq.w	ff78 <_dtoa_r+0x5e0>
    fd5c:	ldr	r2, [sp, #0]
    fd5e:	cmp	r2, #1
    fd60:	ble.w	10212 <_dtoa_r+0x87a>
    fd64:	ldr	r3, [sp, #32]
    fd66:	ldr	r2, [sp, #24]
    fd68:	subs	r7, r3, #1
    fd6a:	cmp	r2, r7
    fd6c:	blt.w	10486 <_dtoa_r+0xaee>
    fd70:	subs	r7, r2, r7
    fd72:	ldr	r3, [sp, #32]
    fd74:	cmp	r3, #0
    fd76:	blt.w	1067a <_dtoa_r+0xce2>
    fd7a:	ldr	r5, [sp, #28]
    fd7c:	ldr	r3, [sp, #32]
    fd7e:	ldr	r2, [sp, #28]
    fd80:	movs	r1, #1
    fd82:	add	r2, r3
    fd84:	mov	r0, r9
    fd86:	str	r2, [sp, #28]
    fd88:	add	r8, r3
    fd8a:	bl	11474 <__i2b>
    fd8e:	mov	r6, r0
    fd90:	cbz	r5, fdac <_dtoa_r+0x414>
    fd92:	cmp.w	r8, #0
    fd96:	ble.n	fdac <_dtoa_r+0x414>
    fd98:	cmp	r5, r8
    fd9a:	ldr	r2, [sp, #28]
    fd9c:	mov	r3, r5
    fd9e:	it	ge
    fda0:	movge	r3, r8
    fda2:	subs	r2, r2, r3
    fda4:	str	r2, [sp, #28]
    fda6:	subs	r5, r5, r3
    fda8:	rsb	r8, r3, r8
    fdac:	ldr	r3, [sp, #24]
    fdae:	cmp	r3, #0
    fdb0:	ble.w	1039e <_dtoa_r+0xa06>
    fdb4:	ldr	r2, [sp, #44]	; 0x2c
    fdb6:	cmp	r2, #0
    fdb8:	beq.w	101c0 <_dtoa_r+0x828>
    fdbc:	cmp	r7, #0
    fdbe:	beq.w	101c0 <_dtoa_r+0x828>
    fdc2:	mov	r1, r6
    fdc4:	mov	r2, r7
    fdc6:	mov	r0, r9
    fdc8:	bl	115b8 <__pow5mult>
    fdcc:	ldr	r2, [sp, #40]	; 0x28
    fdce:	mov	r1, r0
    fdd0:	mov	r6, r0
    fdd2:	mov	r0, r9
    fdd4:	bl	11488 <__multiply>
    fdd8:	ldr	r1, [sp, #40]	; 0x28
    fdda:	mov	r4, r0
    fddc:	mov	r0, r9
    fdde:	bl	112ac <_Bfree>
    fde2:	ldr	r3, [sp, #24]
    fde4:	subs	r3, r3, r7
    fde6:	str	r3, [sp, #24]
    fde8:	bne.w	101be <_dtoa_r+0x826>
    fdec:	movs	r1, #1
    fdee:	mov	r0, r9
    fdf0:	bl	11474 <__i2b>
    fdf4:	ldr	r3, [sp, #48]	; 0x30
    fdf6:	str	r0, [sp, #24]
    fdf8:	cmp	r3, #0
    fdfa:	beq.w	10228 <_dtoa_r+0x890>
    fdfe:	mov	r1, r0
    fe00:	mov	r2, r3
    fe02:	mov	r0, r9
    fe04:	bl	115b8 <__pow5mult>
    fe08:	ldr	r3, [sp, #0]
    fe0a:	str	r0, [sp, #24]
    fe0c:	cmp	r3, #1
    fe0e:	ble.w	103f8 <_dtoa_r+0xa60>
    fe12:	movs	r7, #0
    fe14:	ldr	r2, [sp, #24]
    fe16:	ldr	r3, [r2, #16]
    fe18:	add.w	r3, r2, r3, lsl #2
    fe1c:	ldr	r0, [r3, #16]
    fe1e:	bl	113d8 <__hi0bits>
    fe22:	rsb	r0, r0, #32
    fe26:	add	r0, r8
    fe28:	ands.w	r0, r0, #31
    fe2c:	beq.w	10224 <_dtoa_r+0x88c>
    fe30:	rsb	r3, r0, #32
    fe34:	cmp	r3, #4
    fe36:	ble.w	107b4 <_dtoa_r+0xe1c>
    fe3a:	rsb	r0, r0, #28
    fe3e:	ldr	r3, [sp, #28]
    fe40:	add	r3, r0
    fe42:	str	r3, [sp, #28]
    fe44:	add	r5, r0
    fe46:	add	r8, r0
    fe48:	ldr	r3, [sp, #28]
    fe4a:	cmp	r3, #0
    fe4c:	ble.n	fe5a <_dtoa_r+0x4c2>
    fe4e:	mov	r1, r4
    fe50:	mov	r2, r3
    fe52:	mov	r0, r9
    fe54:	bl	11658 <__lshift>
    fe58:	mov	r4, r0
    fe5a:	cmp.w	r8, #0
    fe5e:	ble.n	fe6c <_dtoa_r+0x4d4>
    fe60:	mov	r2, r8
    fe62:	ldr	r1, [sp, #24]
    fe64:	mov	r0, r9
    fe66:	bl	11658 <__lshift>
    fe6a:	str	r0, [sp, #24]
    fe6c:	ldr	r3, [sp, #52]	; 0x34
    fe6e:	cmp	r3, #0
    fe70:	bne.w	10368 <_dtoa_r+0x9d0>
    fe74:	ldr	r3, [sp, #32]
    fe76:	cmp	r3, #0
    fe78:	ble.w	103a2 <_dtoa_r+0xa0a>
    fe7c:	ldr	r3, [sp, #44]	; 0x2c
    fe7e:	cmp	r3, #0
    fe80:	bne.w	1026c <_dtoa_r+0x8d4>
    fe84:	ldr.w	fp, [sp, #36]	; 0x24
    fe88:	ldr	r7, [sp, #32]
    fe8a:	ldr.w	r8, [sp, #24]
    fe8e:	mov	r5, fp
    fe90:	b.n	fe98 <_dtoa_r+0x500>
    fe92:	bl	112c0 <__multadd>
    fe96:	mov	r4, r0
    fe98:	mov	r1, r8
    fe9a:	mov	r0, r4
    fe9c:	bl	f86c <quorem>
    fea0:	add.w	sl, r0, #48	; 0x30
    fea4:	strb.w	sl, [r5], #1
    fea8:	rsb	r3, fp, r5
    feac:	cmp	r3, r7
    feae:	mov.w	r2, #10
    feb2:	mov.w	r3, #0
    feb6:	mov	r1, r4
    feb8:	mov	r0, r9
    feba:	blt.n	fe92 <_dtoa_r+0x4fa>
    febc:	ldr	r3, [sp, #36]	; 0x24
    febe:	ldr	r2, [sp, #32]
    fec0:	cmp	r2, #1
    fec2:	ite	ge
    fec4:	addge	r3, r3, r2
    fec6:	addlt	r3, #1
    fec8:	mov	r5, r3
    feca:	mov.w	fp, #0
    fece:	mov	r1, r4
    fed0:	movs	r2, #1
    fed2:	mov	r0, r9
    fed4:	bl	11658 <__lshift>
    fed8:	ldr	r1, [sp, #24]
    feda:	str	r0, [sp, #40]	; 0x28
    fedc:	bl	11708 <__mcmp>
    fee0:	cmp	r0, #0
    fee2:	ble.w	104f0 <_dtoa_r+0xb58>
    fee6:	ldrb.w	r2, [r5, #-1]
    feea:	ldr	r1, [sp, #36]	; 0x24
    feec:	subs	r3, r5, #1
    feee:	b.n	fefa <_dtoa_r+0x562>
    fef0:	cmp	r3, r1
    fef2:	beq.w	103de <_dtoa_r+0xa46>
    fef6:	ldrb.w	r2, [r3, #-1]!
    fefa:	cmp	r2, #57	; 0x39
    fefc:	add.w	r5, r3, #1
    ff00:	beq.n	fef0 <_dtoa_r+0x558>
    ff02:	adds	r2, #1
    ff04:	strb	r2, [r3, #0]
    ff06:	ldr	r1, [sp, #24]
    ff08:	mov	r0, r9
    ff0a:	bl	112ac <_Bfree>
    ff0e:	cmp	r6, #0
    ff10:	beq.w	fd2e <_dtoa_r+0x396>
    ff14:	cmp.w	fp, #0
    ff18:	beq.n	ff26 <_dtoa_r+0x58e>
    ff1a:	cmp	fp, r6
    ff1c:	beq.n	ff26 <_dtoa_r+0x58e>
    ff1e:	mov	r1, fp
    ff20:	mov	r0, r9
    ff22:	bl	112ac <_Bfree>
    ff26:	mov	r1, r6
    ff28:	mov	r0, r9
    ff2a:	bl	112ac <_Bfree>
    ff2e:	b.n	fd2e <_dtoa_r+0x396>
    ff30:	movs	r3, #1
    ff32:	str	r3, [sp, #52]	; 0x34
    ff34:	b.n	fb0e <_dtoa_r+0x176>
    ff36:	ldr.w	r8, [sp, #16]
    ff3a:	mov	r0, r8
    ff3c:	bl	a7ec <__aeabi_i2d>
    ff40:	mov	r2, r0
    ff42:	mov	r3, r1
    ff44:	mov	r0, r6
    ff46:	mov	r1, r7
    ff48:	bl	ad88 <__aeabi_dcmpeq>
    ff4c:	cmp	r0, #0
    ff4e:	bne.w	fae6 <_dtoa_r+0x14e>
    ff52:	add.w	r3, r8, #4294967295
    ff56:	str	r3, [sp, #16]
    ff58:	b.n	fae6 <_dtoa_r+0x14e>
    ff5a:	ldr	r2, [sp, #28]
    ff5c:	ldr	r3, [sp, #16]
    ff5e:	subs	r2, r2, r3
    ff60:	negs	r3, r3
    ff62:	str	r3, [sp, #24]
    ff64:	movs	r3, #0
    ff66:	str	r2, [sp, #28]
    ff68:	str	r3, [sp, #48]	; 0x30
    ff6a:	b.n	fb2c <_dtoa_r+0x194>
    ff6c:	rsb	r3, r8, #0
    ff70:	str	r3, [sp, #28]
    ff72:	mov.w	r8, #0
    ff76:	b.n	fb1c <_dtoa_r+0x184>
    ff78:	ldr	r7, [sp, #24]
    ff7a:	ldr	r5, [sp, #28]
    ff7c:	ldr	r6, [sp, #44]	; 0x2c
    ff7e:	b.n	fd90 <_dtoa_r+0x3f8>
    ff80:	rsb	r4, r3, #32
    ff84:	lsl.w	r0, sl, r4
    ff88:	b.n	fa80 <_dtoa_r+0xe8>
    ff8a:	str	r0, [sp, #52]	; 0x34
    ff8c:	b.n	fb0e <_dtoa_r+0x176>
    ff8e:	nop
    ff90:	.word	0x40240000
    ff94:	movs	r3, #0
    ff96:	str	r3, [sp, #44]	; 0x2c
    ff98:	ldr	r3, [sp, #16]
    ff9a:	ldr	r2, [sp, #20]
    ff9c:	add	r3, r2
    ff9e:	str	r3, [sp, #56]	; 0x38
    ffa0:	adds	r3, #1
    ffa2:	cmp	r3, #0
    ffa4:	str	r3, [sp, #32]
    ffa6:	ble.w	104a4 <_dtoa_r+0xb0c>
    ffaa:	ldr	r4, [sp, #32]
    ffac:	mov	r5, r4
    ffae:	movs	r1, #0
    ffb0:	cmp	r5, #23
    ffb2:	str.w	r1, [r9, #68]	; 0x44
    ffb6:	bls.n	ffd0 <_dtoa_r+0x638>
    ffb8:	movs	r2, #1
    ffba:	movs	r3, #4
    ffbc:	lsls	r3, r3, #1
    ffbe:	add.w	r0, r3, #20
    ffc2:	cmp	r0, r5
    ffc4:	mov	r1, r2
    ffc6:	add.w	r2, r2, #1
    ffca:	bls.n	ffbc <_dtoa_r+0x624>
    ffcc:	str.w	r1, [r9, #68]	; 0x44
    ffd0:	mov	r0, r9
    ffd2:	bl	11260 <_Balloc>
    ffd6:	cmp	r4, #14
    ffd8:	str	r0, [sp, #36]	; 0x24
    ffda:	str.w	r0, [r9, #64]	; 0x40
    ffde:	bhi.w	fbac <_dtoa_r+0x214>
    ffe2:	cmp	r6, #0
    ffe4:	beq.w	fbac <_dtoa_r+0x214>
    ffe8:	ldr	r1, [sp, #16]
    ffea:	cmp	r1, #0
    ffec:	strd	sl, fp, [sp, #64]	; 0x40
    fff0:	ble.w	10528 <_dtoa_r+0xb90>
    fff4:	ldr	r3, [pc, #576]	; (10238 <_dtoa_r+0x8a0>)
    fff6:	and.w	r2, r1, #15
    fffa:	asrs	r6, r1, #4
    fffc:	add.w	r3, r3, r2, lsl #3
   10000:	lsls	r0, r6, #27
   10002:	ldrd	r4, r5, [r3]
   10006:	bpl.w	10496 <_dtoa_r+0xafe>
   1000a:	ldr	r3, [pc, #560]	; (1023c <_dtoa_r+0x8a4>)
   1000c:	mov	r0, sl
   1000e:	mov	r1, fp
   10010:	ldrd	r2, r3, [r3, #32]
   10014:	bl	ab0c <__aeabi_ddiv>
   10018:	strd	r0, r1, [sp, #72]	; 0x48
   1001c:	and.w	r6, r6, #15
   10020:	mov.w	sl, #3
   10024:	cbz	r6, 10048 <_dtoa_r+0x6b0>
   10026:	ldr	r7, [pc, #532]	; (1023c <_dtoa_r+0x8a4>)
   10028:	lsls	r1, r6, #31
   1002a:	bpl.n	10040 <_dtoa_r+0x6a8>
   1002c:	mov	r0, r4
   1002e:	mov	r1, r5
   10030:	ldrd	r2, r3, [r7]
   10034:	bl	a8b8 <__aeabi_dmul>
   10038:	add.w	sl, sl, #1
   1003c:	mov	r4, r0
   1003e:	mov	r5, r1
   10040:	asrs	r6, r6, #1
   10042:	add.w	r7, r7, #8
   10046:	bne.n	10028 <_dtoa_r+0x690>
   10048:	mov	r2, r4
   1004a:	mov	r3, r5
   1004c:	ldrd	r0, r1, [sp, #72]	; 0x48
   10050:	bl	ab0c <__aeabi_ddiv>
   10054:	mov	r6, r0
   10056:	mov	r7, r1
   10058:	ldr	r3, [sp, #52]	; 0x34
   1005a:	cbz	r3, 1006e <_dtoa_r+0x6d6>
   1005c:	movs	r2, #0
   1005e:	ldr	r3, [pc, #480]	; (10240 <_dtoa_r+0x8a8>)
   10060:	mov	r0, r6
   10062:	mov	r1, r7
   10064:	bl	ad9c <__aeabi_dcmplt>
   10068:	cmp	r0, #0
   1006a:	bne.w	106a2 <_dtoa_r+0xd0a>
   1006e:	mov	r0, sl
   10070:	bl	a7ec <__aeabi_i2d>
   10074:	mov	r2, r6
   10076:	mov	r3, r7
   10078:	bl	a8b8 <__aeabi_dmul>
   1007c:	ldr	r3, [pc, #452]	; (10244 <_dtoa_r+0x8ac>)
   1007e:	movs	r2, #0
   10080:	bl	a554 <__adddf3>
   10084:	ldr	r3, [sp, #32]
   10086:	mov	r4, r0
   10088:	sub.w	r5, r1, #54525952	; 0x3400000
   1008c:	cmp	r3, #0
   1008e:	beq.w	10448 <_dtoa_r+0xab0>
   10092:	ldr	r3, [sp, #16]
   10094:	str	r3, [sp, #88]	; 0x58
   10096:	ldr	r3, [sp, #32]
   10098:	str	r3, [sp, #72]	; 0x48
   1009a:	ldr	r3, [sp, #44]	; 0x2c
   1009c:	cmp	r3, #0
   1009e:	beq.w	105ca <_dtoa_r+0xc32>
   100a2:	ldr	r2, [sp, #72]	; 0x48
   100a4:	ldr	r3, [pc, #400]	; (10238 <_dtoa_r+0x8a0>)
   100a6:	ldr	r1, [pc, #416]	; (10248 <_dtoa_r+0x8b0>)
   100a8:	add.w	r3, r3, r2, lsl #3
   100ac:	ldrd	r2, r3, [r3, #-8]
   100b0:	movs	r0, #0
   100b2:	bl	ab0c <__aeabi_ddiv>
   100b6:	mov	r2, r4
   100b8:	mov	r3, r5
   100ba:	bl	a550 <__aeabi_dsub>
   100be:	mov	sl, r0
   100c0:	mov	fp, r1
   100c2:	mov	r0, r6
   100c4:	mov	r1, r7
   100c6:	bl	ae18 <__aeabi_d2iz>
   100ca:	mov	r4, r0
   100cc:	bl	a7ec <__aeabi_i2d>
   100d0:	mov	r2, r0
   100d2:	mov	r3, r1
   100d4:	mov	r0, r6
   100d6:	mov	r1, r7
   100d8:	bl	a550 <__aeabi_dsub>
   100dc:	adds	r4, #48	; 0x30
   100de:	ldr	r5, [sp, #36]	; 0x24
   100e0:	uxtb	r4, r4
   100e2:	mov	r6, r0
   100e4:	mov	r7, r1
   100e6:	strb	r4, [r5, #0]
   100e8:	mov	r2, r0
   100ea:	mov	r3, r1
   100ec:	mov	r0, sl
   100ee:	mov	r1, fp
   100f0:	adds	r5, #1
   100f2:	bl	add8 <__aeabi_dcmpgt>
   100f6:	cmp	r0, #0
   100f8:	bne.n	1019c <_dtoa_r+0x804>
   100fa:	mov	r2, r6
   100fc:	mov	r3, r7
   100fe:	movs	r0, #0
   10100:	ldr	r1, [pc, #316]	; (10240 <_dtoa_r+0x8a8>)
   10102:	bl	a550 <__aeabi_dsub>
   10106:	mov	r2, r0
   10108:	mov	r3, r1
   1010a:	mov	r0, sl
   1010c:	mov	r1, fp
   1010e:	bl	add8 <__aeabi_dcmpgt>
   10112:	cmp	r0, #0
   10114:	bne.w	10728 <_dtoa_r+0xd90>
   10118:	ldr	r2, [sp, #72]	; 0x48
   1011a:	cmp	r2, #1
   1011c:	ble.w	1050e <_dtoa_r+0xb76>
   10120:	ldr	r3, [sp, #72]	; 0x48
   10122:	ldr	r2, [sp, #36]	; 0x24
   10124:	str.w	r8, [sp, #72]	; 0x48
   10128:	add	r3, r2
   1012a:	mov	r8, r3
   1012c:	b.n	1014a <_dtoa_r+0x7b2>
   1012e:	movs	r0, #0
   10130:	ldr	r1, [pc, #268]	; (10240 <_dtoa_r+0x8a8>)
   10132:	bl	a550 <__aeabi_dsub>
   10136:	mov	r2, sl
   10138:	mov	r3, fp
   1013a:	bl	ad9c <__aeabi_dcmplt>
   1013e:	cmp	r0, #0
   10140:	bne.w	10728 <_dtoa_r+0xd90>
   10144:	cmp	r5, r8
   10146:	beq.w	1050a <_dtoa_r+0xb72>
   1014a:	mov	r0, sl
   1014c:	mov	r1, fp
   1014e:	movs	r2, #0
   10150:	ldr	r3, [pc, #248]	; (1024c <_dtoa_r+0x8b4>)
   10152:	bl	a8b8 <__aeabi_dmul>
   10156:	movs	r2, #0
   10158:	ldr	r3, [pc, #240]	; (1024c <_dtoa_r+0x8b4>)
   1015a:	mov	sl, r0
   1015c:	mov	fp, r1
   1015e:	mov	r0, r6
   10160:	mov	r1, r7
   10162:	bl	a8b8 <__aeabi_dmul>
   10166:	mov	r7, r1
   10168:	mov	r6, r0
   1016a:	bl	ae18 <__aeabi_d2iz>
   1016e:	mov	r4, r0
   10170:	bl	a7ec <__aeabi_i2d>
   10174:	mov	r2, r0
   10176:	mov	r3, r1
   10178:	mov	r0, r6
   1017a:	mov	r1, r7
   1017c:	bl	a550 <__aeabi_dsub>
   10180:	adds	r4, #48	; 0x30
   10182:	uxtb	r4, r4
   10184:	mov	r2, sl
   10186:	mov	r3, fp
   10188:	strb.w	r4, [r5], #1
   1018c:	mov	r6, r0
   1018e:	mov	r7, r1
   10190:	bl	ad9c <__aeabi_dcmplt>
   10194:	mov	r2, r6
   10196:	mov	r3, r7
   10198:	cmp	r0, #0
   1019a:	beq.n	1012e <_dtoa_r+0x796>
   1019c:	ldr	r3, [sp, #88]	; 0x58
   1019e:	str	r3, [sp, #16]
   101a0:	b.n	fd2e <_dtoa_r+0x396>
   101a2:	movs	r3, #0
   101a4:	str	r3, [sp, #44]	; 0x2c
   101a6:	ldr	r3, [sp, #20]
   101a8:	cmp	r3, #0
   101aa:	ble.w	104ae <_dtoa_r+0xb16>
   101ae:	mov	r5, r3
   101b0:	mov	r4, r3
   101b2:	str	r3, [sp, #56]	; 0x38
   101b4:	str	r3, [sp, #32]
   101b6:	b.n	ffae <_dtoa_r+0x616>
   101b8:	movs	r3, #1
   101ba:	str	r3, [sp, #44]	; 0x2c
   101bc:	b.n	101a6 <_dtoa_r+0x80e>
   101be:	str	r4, [sp, #40]	; 0x28
   101c0:	ldr	r2, [sp, #24]
   101c2:	ldr	r1, [sp, #40]	; 0x28
   101c4:	mov	r0, r9
   101c6:	bl	115b8 <__pow5mult>
   101ca:	mov	r4, r0
   101cc:	b.n	fdec <_dtoa_r+0x454>
   101ce:	ldr	r3, [sp, #32]
   101d0:	cmp	r3, #0
   101d2:	bgt.w	fbd2 <_dtoa_r+0x23a>
   101d6:	bne.w	10478 <_dtoa_r+0xae0>
   101da:	movs	r2, #0
   101dc:	ldr	r3, [pc, #112]	; (10250 <_dtoa_r+0x8b8>)
   101de:	ldrd	r0, r1, [sp]
   101e2:	bl	a8b8 <__aeabi_dmul>
   101e6:	mov	r3, fp
   101e8:	mov	r2, sl
   101ea:	bl	adc4 <__aeabi_dcmpge>
   101ee:	ldr	r3, [sp, #32]
   101f0:	str	r3, [sp, #24]
   101f2:	mov	r6, r3
   101f4:	cmp	r0, #0
   101f6:	beq.w	103ce <_dtoa_r+0xa36>
   101fa:	ldr	r3, [sp, #20]
   101fc:	ldr	r5, [sp, #36]	; 0x24
   101fe:	mvns	r3, r3
   10200:	str	r3, [sp, #16]
   10202:	ldr	r1, [sp, #24]
   10204:	mov	r0, r9
   10206:	bl	112ac <_Bfree>
   1020a:	cmp	r6, #0
   1020c:	beq.w	fd2e <_dtoa_r+0x396>
   10210:	b.n	ff26 <_dtoa_r+0x58e>
   10212:	ldr	r2, [sp, #60]	; 0x3c
   10214:	cmp	r2, #0
   10216:	beq.w	1068a <_dtoa_r+0xcf2>
   1021a:	addw	r3, r3, #1075	; 0x433
   1021e:	ldr	r7, [sp, #24]
   10220:	ldr	r5, [sp, #28]
   10222:	b.n	fd7e <_dtoa_r+0x3e6>
   10224:	movs	r0, #28
   10226:	b.n	fe3e <_dtoa_r+0x4a6>
   10228:	ldr	r3, [sp, #0]
   1022a:	cmp	r3, #1
   1022c:	ble.w	10730 <_dtoa_r+0xd98>
   10230:	ldr	r7, [sp, #48]	; 0x30
   10232:	movs	r0, #1
   10234:	b.n	fe26 <_dtoa_r+0x48e>
   10236:	nop
   10238:	.word	0x00013428
   1023c:	.word	0x000134f0
   10240:	.word	0x3ff00000
   10244:	.word	0x401c0000
   10248:	.word	0x3fe00000
   1024c:	.word	0x40240000
   10250:	.word	0x40140000
   10254:	mov	r1, r6
   10256:	movs	r3, #0
   10258:	movs	r2, #10
   1025a:	mov	r0, r9
   1025c:	bl	112c0 <__multadd>
   10260:	ldr	r3, [sp, #56]	; 0x38
   10262:	cmp	r3, #0
   10264:	mov	r6, r0
   10266:	ble.w	10784 <_dtoa_r+0xdec>
   1026a:	str	r3, [sp, #32]
   1026c:	cmp	r5, #0
   1026e:	ble.n	1027c <_dtoa_r+0x8e4>
   10270:	mov	r1, r6
   10272:	mov	r2, r5
   10274:	mov	r0, r9
   10276:	bl	11658 <__lshift>
   1027a:	mov	r6, r0
   1027c:	cmp	r7, #0
   1027e:	bne.w	1057a <_dtoa_r+0xbe2>
   10282:	mov	r8, r6
   10284:	ldr	r3, [sp, #32]
   10286:	ldr	r2, [sp, #36]	; 0x24
   10288:	subs	r3, #1
   1028a:	adds	r3, r2, r3
   1028c:	str	r3, [sp, #32]
   1028e:	and.w	r3, sl, #1
   10292:	str	r3, [sp, #40]	; 0x28
   10294:	mov	r7, r2
   10296:	ldr.w	fp, [sp, #24]
   1029a:	mov	r0, r4
   1029c:	mov	r1, fp
   1029e:	bl	f86c <quorem>
   102a2:	mov	r1, r6
   102a4:	mov	r5, r0
   102a6:	mov	r0, r4
   102a8:	bl	11708 <__mcmp>
   102ac:	mov	r2, r8
   102ae:	mov	r1, fp
   102b0:	mov	sl, r0
   102b2:	mov	r0, r9
   102b4:	bl	1174c <__mdiff>
   102b8:	ldr	r2, [r0, #12]
   102ba:	mov	fp, r0
   102bc:	add.w	r3, r5, #48	; 0x30
   102c0:	cmp	r2, #0
   102c2:	bne.n	10358 <_dtoa_r+0x9c0>
   102c4:	mov	r1, r0
   102c6:	mov	r0, r4
   102c8:	str	r3, [sp, #28]
   102ca:	bl	11708 <__mcmp>
   102ce:	mov	r1, fp
   102d0:	str	r0, [sp, #20]
   102d2:	mov	r0, r9
   102d4:	bl	112ac <_Bfree>
   102d8:	ldr	r2, [sp, #20]
   102da:	ldr	r3, [sp, #28]
   102dc:	cbnz	r2, 102ea <_dtoa_r+0x952>
   102de:	ldr	r1, [sp, #0]
   102e0:	cbnz	r1, 102ea <_dtoa_r+0x952>
   102e2:	ldr	r1, [sp, #40]	; 0x28
   102e4:	cmp	r1, #0
   102e6:	beq.w	10754 <_dtoa_r+0xdbc>
   102ea:	cmp.w	sl, #0
   102ee:	blt.w	104b8 <_dtoa_r+0xb20>
   102f2:	bne.n	10300 <_dtoa_r+0x968>
   102f4:	ldr	r1, [sp, #0]
   102f6:	cbnz	r1, 10300 <_dtoa_r+0x968>
   102f8:	ldr	r1, [sp, #40]	; 0x28
   102fa:	cmp	r1, #0
   102fc:	beq.w	104b8 <_dtoa_r+0xb20>
   10300:	cmp	r2, #0
   10302:	bgt.w	105a2 <_dtoa_r+0xc0a>
   10306:	ldr	r2, [sp, #32]
   10308:	strb	r3, [r7, #0]
   1030a:	add.w	sl, r7, #1
   1030e:	cmp	r7, r2
   10310:	mov	r5, sl
   10312:	beq.w	105ba <_dtoa_r+0xc22>
   10316:	mov	r1, r4
   10318:	movs	r3, #0
   1031a:	movs	r2, #10
   1031c:	mov	r0, r9
   1031e:	bl	112c0 <__multadd>
   10322:	cmp	r6, r8
   10324:	mov	r4, r0
   10326:	mov	r1, r6
   10328:	mov.w	r3, #0
   1032c:	mov.w	r2, #10
   10330:	mov	r0, r9
   10332:	beq.n	1034c <_dtoa_r+0x9b4>
   10334:	bl	112c0 <__multadd>
   10338:	mov	r1, r8
   1033a:	mov	r6, r0
   1033c:	movs	r3, #0
   1033e:	movs	r2, #10
   10340:	mov	r0, r9
   10342:	bl	112c0 <__multadd>
   10346:	mov	r7, sl
   10348:	mov	r8, r0
   1034a:	b.n	10296 <_dtoa_r+0x8fe>
   1034c:	bl	112c0 <__multadd>
   10350:	mov	r7, sl
   10352:	mov	r6, r0
   10354:	mov	r8, r0
   10356:	b.n	10296 <_dtoa_r+0x8fe>
   10358:	mov	r1, r0
   1035a:	mov	r0, r9
   1035c:	str	r3, [sp, #20]
   1035e:	bl	112ac <_Bfree>
   10362:	movs	r2, #1
   10364:	ldr	r3, [sp, #20]
   10366:	b.n	102ea <_dtoa_r+0x952>
   10368:	ldr	r1, [sp, #24]
   1036a:	mov	r0, r4
   1036c:	bl	11708 <__mcmp>
   10370:	cmp	r0, #0
   10372:	bge.w	fe74 <_dtoa_r+0x4dc>
   10376:	mov	r1, r4
   10378:	ldr	r4, [sp, #16]
   1037a:	movs	r3, #0
   1037c:	subs	r4, #1
   1037e:	movs	r2, #10
   10380:	mov	r0, r9
   10382:	str	r4, [sp, #16]
   10384:	bl	112c0 <__multadd>
   10388:	ldr	r3, [sp, #44]	; 0x2c
   1038a:	mov	r4, r0
   1038c:	cmp	r3, #0
   1038e:	bne.w	10254 <_dtoa_r+0x8bc>
   10392:	ldr	r3, [sp, #56]	; 0x38
   10394:	cmp	r3, #0
   10396:	ble.w	10774 <_dtoa_r+0xddc>
   1039a:	str	r3, [sp, #32]
   1039c:	b.n	fe84 <_dtoa_r+0x4ec>
   1039e:	ldr	r4, [sp, #40]	; 0x28
   103a0:	b.n	fdec <_dtoa_r+0x454>
   103a2:	ldr	r3, [sp, #0]
   103a4:	cmp	r3, #2
   103a6:	ble.w	fe7c <_dtoa_r+0x4e4>
   103aa:	ldr	r3, [sp, #32]
   103ac:	cmp	r3, #0
   103ae:	bne.w	106ec <_dtoa_r+0xd54>
   103b2:	ldr	r1, [sp, #24]
   103b4:	movs	r2, #5
   103b6:	mov	r0, r9
   103b8:	bl	112c0 <__multadd>
   103bc:	mov	r1, r0
   103be:	str	r0, [sp, #24]
   103c0:	mov	r0, r4
   103c2:	bl	11708 <__mcmp>
   103c6:	cmp	r0, #0
   103c8:	str	r4, [sp, #40]	; 0x28
   103ca:	ble.w	101fa <_dtoa_r+0x862>
   103ce:	ldr	r2, [sp, #16]
   103d0:	ldr	r1, [sp, #36]	; 0x24
   103d2:	movs	r3, #49	; 0x31
   103d4:	adds	r2, #1
   103d6:	str	r2, [sp, #16]
   103d8:	strb	r3, [r1, #0]
   103da:	adds	r5, r1, #1
   103dc:	b.n	10202 <_dtoa_r+0x86a>
   103de:	ldr	r2, [sp, #16]
   103e0:	adds	r2, #1
   103e2:	str	r2, [sp, #16]
   103e4:	ldr	r2, [sp, #36]	; 0x24
   103e6:	movs	r3, #49	; 0x31
   103e8:	strb	r3, [r2, #0]
   103ea:	b.n	ff06 <_dtoa_r+0x56e>
   103ec:	movs	r3, #1
   103ee:	str	r3, [sp, #44]	; 0x2c
   103f0:	b.n	ff98 <_dtoa_r+0x600>
   103f2:	ldr.w	r9, [sp, #20]
   103f6:	b.n	fd2e <_dtoa_r+0x396>
   103f8:	cmp.w	sl, #0
   103fc:	bne.w	fe12 <_dtoa_r+0x47a>
   10400:	ubfx	r3, fp, #0, #20
   10404:	cmp	r3, #0
   10406:	bne.w	10686 <_dtoa_r+0xcee>
   1040a:	bic.w	r7, fp, #2147483648	; 0x80000000
   1040e:	lsrs	r7, r7, #20
   10410:	lsls	r7, r7, #20
   10412:	cbz	r7, 10420 <_dtoa_r+0xa88>
   10414:	ldr	r3, [sp, #28]
   10416:	adds	r3, #1
   10418:	str	r3, [sp, #28]
   1041a:	add.w	r8, r8, #1
   1041e:	movs	r7, #1
   10420:	ldr	r3, [sp, #48]	; 0x30
   10422:	movs	r0, #1
   10424:	cmp	r3, #0
   10426:	beq.w	fe26 <_dtoa_r+0x48e>
   1042a:	b.n	fe14 <_dtoa_r+0x47c>
   1042c:	mov	r0, sl
   1042e:	bl	a7ec <__aeabi_i2d>
   10432:	mov	r2, r6
   10434:	mov	r3, r7
   10436:	bl	a8b8 <__aeabi_dmul>
   1043a:	movs	r2, #0
   1043c:	ldr	r3, [pc, #764]	; (1073c <_dtoa_r+0xda4>)
   1043e:	bl	a554 <__adddf3>
   10442:	mov	r4, r0
   10444:	sub.w	r5, r1, #54525952	; 0x3400000
   10448:	mov	r0, r6
   1044a:	mov	r1, r7
   1044c:	movs	r2, #0
   1044e:	ldr	r3, [pc, #752]	; (10740 <_dtoa_r+0xda8>)
   10450:	bl	a550 <__aeabi_dsub>
   10454:	mov	r2, r4
   10456:	mov	r3, r5
   10458:	mov	r6, r0
   1045a:	mov	r7, r1
   1045c:	bl	add8 <__aeabi_dcmpgt>
   10460:	cmp	r0, #0
   10462:	bne.w	105c2 <_dtoa_r+0xc2a>
   10466:	mov	r2, r4
   10468:	add.w	r3, r5, #2147483648	; 0x80000000
   1046c:	mov	r0, r6
   1046e:	mov	r1, r7
   10470:	bl	ad9c <__aeabi_dcmplt>
   10474:	cmp	r0, #0
   10476:	beq.n	1050e <_dtoa_r+0xb76>
   10478:	movs	r3, #0
   1047a:	str	r3, [sp, #24]
   1047c:	mov	r6, r3
   1047e:	b.n	101fa <_dtoa_r+0x862>
   10480:	ldr	r0, [sp, #36]	; 0x24
   10482:	b.w	fa0a <_dtoa_r+0x72>
   10486:	ldr	r3, [sp, #24]
   10488:	ldr	r2, [sp, #48]	; 0x30
   1048a:	str	r7, [sp, #24]
   1048c:	subs	r3, r7, r3
   1048e:	add	r2, r3
   10490:	str	r2, [sp, #48]	; 0x30
   10492:	movs	r7, #0
   10494:	b.n	fd72 <_dtoa_r+0x3da>
   10496:	vldr	d7, [sp, #64]	; 0x40
   1049a:	mov.w	sl, #2
   1049e:	vstr	d7, [sp, #72]	; 0x48
   104a2:	b.n	10024 <_dtoa_r+0x68c>
   104a4:	mov	r4, r3
   104a6:	movs	r1, #0
   104a8:	str.w	r1, [r9, #68]	; 0x44
   104ac:	b.n	ffd0 <_dtoa_r+0x638>
   104ae:	movs	r4, #1
   104b0:	str	r4, [sp, #56]	; 0x38
   104b2:	str	r4, [sp, #32]
   104b4:	str	r4, [sp, #20]
   104b6:	b.n	104a6 <_dtoa_r+0xb0e>
   104b8:	cmp	r2, #0
   104ba:	mov	sl, r3
   104bc:	ble.n	104e2 <_dtoa_r+0xb4a>
   104be:	mov	r1, r4
   104c0:	movs	r2, #1
   104c2:	mov	r0, r9
   104c4:	bl	11658 <__lshift>
   104c8:	ldr	r1, [sp, #24]
   104ca:	mov	r4, r0
   104cc:	bl	11708 <__mcmp>
   104d0:	cmp	r0, #0
   104d2:	ble.w	10766 <_dtoa_r+0xdce>
   104d6:	cmp.w	sl, #57	; 0x39
   104da:	beq.w	106f0 <_dtoa_r+0xd58>
   104de:	add.w	sl, r5, #49	; 0x31
   104e2:	mov	fp, r6
   104e4:	strb.w	sl, [r7]
   104e8:	adds	r5, r7, #1
   104ea:	mov	r6, r8
   104ec:	str	r4, [sp, #40]	; 0x28
   104ee:	b.n	ff06 <_dtoa_r+0x56e>
   104f0:	bne.n	104fc <_dtoa_r+0xb64>
   104f2:	tst.w	sl, #1
   104f6:	beq.n	104fc <_dtoa_r+0xb64>
   104f8:	b.n	fee6 <_dtoa_r+0x54e>
   104fa:	mov	r5, r2
   104fc:	ldrb.w	r3, [r5, #-1]
   10500:	cmp	r3, #48	; 0x30
   10502:	add.w	r2, r5, #4294967295
   10506:	beq.n	104fa <_dtoa_r+0xb62>
   10508:	b.n	ff06 <_dtoa_r+0x56e>
   1050a:	ldr.w	r8, [sp, #72]	; 0x48
   1050e:	ldrd	sl, fp, [sp, #64]	; 0x40
   10512:	b.w	fbac <_dtoa_r+0x214>
   10516:	ldr	r1, [sp, #36]	; 0x24
   10518:	movs	r2, #48	; 0x30
   1051a:	strb	r2, [r1, #0]
   1051c:	ldr	r2, [sp, #16]
   1051e:	ldrb.w	r4, [r5, #-1]
   10522:	adds	r2, #1
   10524:	str	r2, [sp, #16]
   10526:	b.n	fd2a <_dtoa_r+0x392>
   10528:	ldr	r3, [sp, #16]
   1052a:	negs	r4, r3
   1052c:	cmp	r4, #0
   1052e:	beq.w	10698 <_dtoa_r+0xd00>
   10532:	ldr	r3, [pc, #528]	; (10744 <_dtoa_r+0xdac>)
   10534:	and.w	r2, r4, #15
   10538:	add.w	r3, r3, r2, lsl #3
   1053c:	ldrd	r2, r3, [r3]
   10540:	ldrd	r0, r1, [sp, #64]	; 0x40
   10544:	bl	a8b8 <__aeabi_dmul>
   10548:	asrs	r4, r4, #4
   1054a:	mov	r6, r0
   1054c:	mov	r7, r1
   1054e:	beq.w	1077e <_dtoa_r+0xde6>
   10552:	ldr	r5, [pc, #500]	; (10748 <_dtoa_r+0xdb0>)
   10554:	mov.w	sl, #2
   10558:	lsls	r2, r4, #31
   1055a:	bpl.n	10570 <_dtoa_r+0xbd8>
   1055c:	mov	r0, r6
   1055e:	mov	r1, r7
   10560:	ldrd	r2, r3, [r5]
   10564:	bl	a8b8 <__aeabi_dmul>
   10568:	add.w	sl, sl, #1
   1056c:	mov	r6, r0
   1056e:	mov	r7, r1
   10570:	asrs	r4, r4, #1
   10572:	add.w	r5, r5, #8
   10576:	bne.n	10558 <_dtoa_r+0xbc0>
   10578:	b.n	10058 <_dtoa_r+0x6c0>
   1057a:	ldr	r1, [r6, #4]
   1057c:	mov	r0, r9
   1057e:	bl	11260 <_Balloc>
   10582:	ldr	r3, [r6, #16]
   10584:	adds	r2, r3, #2
   10586:	mov	r5, r0
   10588:	lsls	r2, r2, #2
   1058a:	add.w	r1, r6, #12
   1058e:	adds	r0, #12
   10590:	bl	8f14 <memcpy>
   10594:	mov	r1, r5
   10596:	movs	r2, #1
   10598:	mov	r0, r9
   1059a:	bl	11658 <__lshift>
   1059e:	mov	r8, r0
   105a0:	b.n	10284 <_dtoa_r+0x8ec>
   105a2:	cmp	r3, #57	; 0x39
   105a4:	beq.w	106f0 <_dtoa_r+0xd58>
   105a8:	add.w	sl, r3, #1
   105ac:	mov	fp, r6
   105ae:	strb.w	sl, [r7]
   105b2:	adds	r5, r7, #1
   105b4:	mov	r6, r8
   105b6:	str	r4, [sp, #40]	; 0x28
   105b8:	b.n	ff06 <_dtoa_r+0x56e>
   105ba:	mov	fp, r6
   105bc:	mov	sl, r3
   105be:	mov	r6, r8
   105c0:	b.n	fece <_dtoa_r+0x536>
   105c2:	movs	r3, #0
   105c4:	str	r3, [sp, #24]
   105c6:	mov	r6, r3
   105c8:	b.n	103ce <_dtoa_r+0xa36>
   105ca:	ldr	r3, [sp, #72]	; 0x48
   105cc:	ldr	r1, [pc, #372]	; (10744 <_dtoa_r+0xdac>)
   105ce:	subs	r2, r3, #1
   105d0:	add.w	r1, r1, r2, lsl #3
   105d4:	mov	r3, r5
   105d6:	str	r2, [sp, #92]	; 0x5c
   105d8:	ldrd	r0, r1, [r1]
   105dc:	mov	r2, r4
   105de:	bl	a8b8 <__aeabi_dmul>
   105e2:	strd	r0, r1, [sp, #80]	; 0x50
   105e6:	mov	r1, r7
   105e8:	mov	r0, r6
   105ea:	bl	ae18 <__aeabi_d2iz>
   105ee:	mov	r4, r0
   105f0:	bl	a7ec <__aeabi_i2d>
   105f4:	mov	r3, r1
   105f6:	mov	r2, r0
   105f8:	mov	r1, r7
   105fa:	mov	r0, r6
   105fc:	bl	a550 <__aeabi_dsub>
   10600:	ldr	r3, [sp, #72]	; 0x48
   10602:	mov	r7, r1
   10604:	ldr	r1, [sp, #36]	; 0x24
   10606:	adds	r4, #48	; 0x30
   10608:	cmp	r3, #1
   1060a:	mov	r6, r0
   1060c:	strb	r4, [r1, #0]
   1060e:	add.w	r5, r1, #1
   10612:	beq.n	10656 <_dtoa_r+0xcbe>
   10614:	ldr	r3, [sp, #72]	; 0x48
   10616:	ldr	r2, [sp, #36]	; 0x24
   10618:	add	r3, r2
   1061a:	mov	sl, r3
   1061c:	mov	fp, r5
   1061e:	movs	r2, #0
   10620:	ldr	r3, [pc, #296]	; (1074c <_dtoa_r+0xdb4>)
   10622:	mov	r0, r6
   10624:	mov	r1, r7
   10626:	bl	a8b8 <__aeabi_dmul>
   1062a:	mov	r7, r1
   1062c:	mov	r6, r0
   1062e:	bl	ae18 <__aeabi_d2iz>
   10632:	mov	r4, r0
   10634:	bl	a7ec <__aeabi_i2d>
   10638:	adds	r4, #48	; 0x30
   1063a:	mov	r2, r0
   1063c:	mov	r3, r1
   1063e:	mov	r0, r6
   10640:	mov	r1, r7
   10642:	bl	a550 <__aeabi_dsub>
   10646:	strb.w	r4, [fp], #1
   1064a:	cmp	sl, fp
   1064c:	mov	r6, r0
   1064e:	mov	r7, r1
   10650:	bne.n	1061e <_dtoa_r+0xc86>
   10652:	ldr	r3, [sp, #92]	; 0x5c
   10654:	add	r5, r3
   10656:	movs	r2, #0
   10658:	ldr	r3, [pc, #244]	; (10750 <_dtoa_r+0xdb8>)
   1065a:	ldrd	r0, r1, [sp, #80]	; 0x50
   1065e:	bl	a554 <__adddf3>
   10662:	mov	r2, r6
   10664:	mov	r3, r7
   10666:	bl	ad9c <__aeabi_dcmplt>
   1066a:	cmp	r0, #0
   1066c:	beq.n	10700 <_dtoa_r+0xd68>
   1066e:	ldr	r3, [sp, #88]	; 0x58
   10670:	str	r3, [sp, #16]
   10672:	ldrb.w	r4, [r5, #-1]
   10676:	b.w	fd12 <_dtoa_r+0x37a>
   1067a:	ldr	r3, [sp, #28]
   1067c:	ldr	r2, [sp, #32]
   1067e:	subs	r5, r3, r2
   10680:	movs	r3, #0
   10682:	b.w	fd7e <_dtoa_r+0x3e6>
   10686:	movs	r7, #0
   10688:	b.n	10420 <_dtoa_r+0xa88>
   1068a:	ldr	r3, [sp, #96]	; 0x60
   1068c:	ldr	r7, [sp, #24]
   1068e:	ldr	r5, [sp, #28]
   10690:	rsb	r3, r3, #54	; 0x36
   10694:	b.w	fd7e <_dtoa_r+0x3e6>
   10698:	ldrd	r6, r7, [sp, #64]	; 0x40
   1069c:	mov.w	sl, #2
   106a0:	b.n	10058 <_dtoa_r+0x6c0>
   106a2:	ldr	r3, [sp, #32]
   106a4:	cmp	r3, #0
   106a6:	beq.w	1042c <_dtoa_r+0xa94>
   106aa:	ldr	r3, [sp, #56]	; 0x38
   106ac:	cmp	r3, #0
   106ae:	ble.w	1050e <_dtoa_r+0xb76>
   106b2:	movs	r2, #0
   106b4:	ldr	r3, [pc, #148]	; (1074c <_dtoa_r+0xdb4>)
   106b6:	mov	r0, r6
   106b8:	mov	r1, r7
   106ba:	bl	a8b8 <__aeabi_dmul>
   106be:	mov	r6, r0
   106c0:	mov	r7, r1
   106c2:	add.w	r0, sl, #1
   106c6:	bl	a7ec <__aeabi_i2d>
   106ca:	mov	r2, r6
   106cc:	mov	r3, r7
   106ce:	bl	a8b8 <__aeabi_dmul>
   106d2:	movs	r2, #0
   106d4:	ldr	r3, [pc, #100]	; (1073c <_dtoa_r+0xda4>)
   106d6:	bl	a554 <__adddf3>
   106da:	ldr	r2, [sp, #16]
   106dc:	ldr	r3, [sp, #56]	; 0x38
   106de:	str	r3, [sp, #72]	; 0x48
   106e0:	subs	r2, #1
   106e2:	mov	r4, r0
   106e4:	sub.w	r5, r1, #54525952	; 0x3400000
   106e8:	str	r2, [sp, #88]	; 0x58
   106ea:	b.n	1009a <_dtoa_r+0x702>
   106ec:	str	r4, [sp, #40]	; 0x28
   106ee:	b.n	101fa <_dtoa_r+0x862>
   106f0:	movs	r2, #57	; 0x39
   106f2:	mov	fp, r6
   106f4:	str	r4, [sp, #40]	; 0x28
   106f6:	mov	r6, r8
   106f8:	strb	r2, [r7, #0]
   106fa:	adds	r5, r7, #1
   106fc:	b.w	feea <_dtoa_r+0x552>
   10700:	ldrd	r2, r3, [sp, #80]	; 0x50
   10704:	movs	r0, #0
   10706:	ldr	r1, [pc, #72]	; (10750 <_dtoa_r+0xdb8>)
   10708:	bl	a550 <__aeabi_dsub>
   1070c:	mov	r2, r6
   1070e:	mov	r3, r7
   10710:	bl	add8 <__aeabi_dcmpgt>
   10714:	cbnz	r0, 1071a <_dtoa_r+0xd82>
   10716:	b.n	1050e <_dtoa_r+0xb76>
   10718:	mov	r5, r2
   1071a:	ldrb.w	r3, [r5, #-1]
   1071e:	cmp	r3, #48	; 0x30
   10720:	add.w	r2, r5, #4294967295
   10724:	beq.n	10718 <_dtoa_r+0xd80>
   10726:	b.n	1019c <_dtoa_r+0x804>
   10728:	ldr	r3, [sp, #88]	; 0x58
   1072a:	str	r3, [sp, #16]
   1072c:	b.w	fd12 <_dtoa_r+0x37a>
   10730:	cmp.w	sl, #0
   10734:	bne.w	10230 <_dtoa_r+0x898>
   10738:	b.n	10400 <_dtoa_r+0xa68>
   1073a:	nop
   1073c:	.word	0x401c0000
   10740:	.word	0x40140000
   10744:	.word	0x00013428
   10748:	.word	0x000134f0
   1074c:	.word	0x40240000
   10750:	.word	0x3fe00000
   10754:	cmp	r3, #57	; 0x39
   10756:	mov	fp, sl
   10758:	mov	sl, r3
   1075a:	beq.n	106f0 <_dtoa_r+0xd58>
   1075c:	cmp.w	fp, #0
   10760:	bgt.w	104de <_dtoa_r+0xb46>
   10764:	b.n	104e2 <_dtoa_r+0xb4a>
   10766:	bne.w	104e2 <_dtoa_r+0xb4a>
   1076a:	tst.w	sl, #1
   1076e:	beq.w	104e2 <_dtoa_r+0xb4a>
   10772:	b.n	104d6 <_dtoa_r+0xb3e>
   10774:	ldr	r3, [sp, #0]
   10776:	cmp	r3, #2
   10778:	bgt.n	107c6 <_dtoa_r+0xe2e>
   1077a:	ldr	r3, [sp, #56]	; 0x38
   1077c:	b.n	1039a <_dtoa_r+0xa02>
   1077e:	mov.w	sl, #2
   10782:	b.n	10058 <_dtoa_r+0x6c0>
   10784:	ldr	r3, [sp, #0]
   10786:	cmp	r3, #2
   10788:	bgt.n	107c6 <_dtoa_r+0xe2e>
   1078a:	ldr	r3, [sp, #56]	; 0x38
   1078c:	b.n	1026a <_dtoa_r+0x8d2>
   1078e:	movs	r4, #0
   10790:	str.w	r4, [r9, #68]	; 0x44
   10794:	mov	r1, r4
   10796:	mov	r0, r9
   10798:	bl	11260 <_Balloc>
   1079c:	mov.w	r3, #4294967295
   107a0:	str	r3, [sp, #32]
   107a2:	str	r3, [sp, #56]	; 0x38
   107a4:	movs	r3, #1
   107a6:	str	r0, [sp, #36]	; 0x24
   107a8:	str	r4, [sp, #20]
   107aa:	str.w	r0, [r9, #64]	; 0x40
   107ae:	str	r3, [sp, #44]	; 0x2c
   107b0:	b.w	fbac <_dtoa_r+0x214>
   107b4:	beq.w	fe48 <_dtoa_r+0x4b0>
   107b8:	rsb	r0, r0, #60	; 0x3c
   107bc:	b.w	fe3e <_dtoa_r+0x4a6>
   107c0:	movs	r6, #1
   107c2:	b.w	fb3e <_dtoa_r+0x1a6>
   107c6:	ldr	r3, [sp, #56]	; 0x38
   107c8:	str	r3, [sp, #32]
   107ca:	b.n	103aa <_dtoa_r+0xa12>

000107cc <__libc_fini_array>:
   107cc:	push	{r3, r4, r5, lr}
   107ce:	ldr	r5, [pc, #28]	; (107ec <__libc_fini_array+0x20>)
   107d0:	ldr	r4, [pc, #28]	; (107f0 <__libc_fini_array+0x24>)
   107d2:	subs	r4, r5, r4
   107d4:	asrs	r4, r4, #2
   107d6:	beq.n	107e4 <__libc_fini_array+0x18>
   107d8:	subs	r4, #1
   107da:	ldr.w	r3, [r5, #-4]!
   107de:	blx	r3
   107e0:	cmp	r4, #0
   107e2:	bne.n	107d8 <__libc_fini_array+0xc>
   107e4:	ldmia.w	sp!, {r3, r4, r5, lr}
   107e8:	b.w	13548 <__init_array_end>
	...

000107f4 <_malloc_trim_r>:
   107f4:	push	{r3, r4, r5, r6, r7, lr}
   107f6:	ldr	r7, [pc, #140]	; (10884 <_malloc_trim_r+0x90>)
   107f8:	mov	r4, r1
   107fa:	mov	r6, r0
   107fc:	bl	baac <__malloc_lock>
   10800:	ldr	r3, [r7, #8]
   10802:	ldr	r5, [r3, #4]
   10804:	bic.w	r5, r5, #3
   10808:	subs	r1, r5, r4
   1080a:	addw	r1, r1, #4079	; 0xfef
   1080e:	bic.w	r1, r1, #4080	; 0xff0
   10812:	bic.w	r1, r1, #15
   10816:	sub.w	r4, r1, #4096	; 0x1000
   1081a:	cmp.w	r4, #4096	; 0x1000
   1081e:	blt.n	10830 <_malloc_trim_r+0x3c>
   10820:	movs	r1, #0
   10822:	mov	r0, r6
   10824:	bl	be94 <_sbrk_r>
   10828:	ldr	r3, [r7, #8]
   1082a:	add	r3, r5
   1082c:	cmp	r0, r3
   1082e:	beq.n	1083a <_malloc_trim_r+0x46>
   10830:	mov	r0, r6
   10832:	bl	bab0 <__malloc_unlock>
   10836:	movs	r0, #0
   10838:	pop	{r3, r4, r5, r6, r7, pc}
   1083a:	negs	r1, r4
   1083c:	mov	r0, r6
   1083e:	bl	be94 <_sbrk_r>
   10842:	adds	r0, #1
   10844:	beq.n	10862 <_malloc_trim_r+0x6e>
   10846:	ldr	r3, [pc, #64]	; (10888 <_malloc_trim_r+0x94>)
   10848:	ldr	r2, [r7, #8]
   1084a:	ldr	r1, [r3, #0]
   1084c:	subs	r5, r5, r4
   1084e:	orr.w	r5, r5, #1
   10852:	mov	r0, r6
   10854:	subs	r1, r1, r4
   10856:	str	r5, [r2, #4]
   10858:	str	r1, [r3, #0]
   1085a:	bl	bab0 <__malloc_unlock>
   1085e:	movs	r0, #1
   10860:	pop	{r3, r4, r5, r6, r7, pc}
   10862:	movs	r1, #0
   10864:	mov	r0, r6
   10866:	bl	be94 <_sbrk_r>
   1086a:	ldr	r2, [r7, #8]
   1086c:	subs	r3, r0, r2
   1086e:	cmp	r3, #15
   10870:	ble.n	10830 <_malloc_trim_r+0x3c>
   10872:	ldr	r4, [pc, #24]	; (1088c <_malloc_trim_r+0x98>)
   10874:	ldr	r1, [pc, #16]	; (10888 <_malloc_trim_r+0x94>)
   10876:	ldr	r4, [r4, #0]
   10878:	orr.w	r3, r3, #1
   1087c:	subs	r0, r0, r4
   1087e:	str	r3, [r2, #4]
   10880:	str	r0, [r1, #0]
   10882:	b.n	10830 <_malloc_trim_r+0x3c>
   10884:	.word	0x1fff1998
   10888:	.word	0x2001a820
   1088c:	.word	0x1fff1da4

00010890 <_free_r>:
   10890:	cmp	r1, #0
   10892:	beq.n	10920 <_free_r+0x90>
   10894:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10898:	mov	r5, r1
   1089a:	mov	r8, r0
   1089c:	bl	baac <__malloc_lock>
   108a0:	ldr.w	r7, [r5, #-4]
   108a4:	ldr	r1, [pc, #424]	; (10a50 <_free_r+0x1c0>)
   108a6:	bic.w	r3, r7, #1
   108aa:	sub.w	r4, r5, #8
   108ae:	adds	r2, r4, r3
   108b0:	ldr	r6, [r1, #8]
   108b2:	ldr	r0, [r2, #4]
   108b4:	cmp	r2, r6
   108b6:	bic.w	r0, r0, #3
   108ba:	beq.n	10982 <_free_r+0xf2>
   108bc:	lsls	r6, r7, #31
   108be:	str	r0, [r2, #4]
   108c0:	bmi.n	108da <_free_r+0x4a>
   108c2:	ldr.w	r7, [r5, #-8]
   108c6:	subs	r4, r4, r7
   108c8:	add.w	lr, r1, #8
   108cc:	ldr	r5, [r4, #8]
   108ce:	cmp	r5, lr
   108d0:	add	r3, r7
   108d2:	beq.n	109b4 <_free_r+0x124>
   108d4:	ldr	r7, [r4, #12]
   108d6:	str	r7, [r5, #12]
   108d8:	str	r5, [r7, #8]
   108da:	adds	r5, r2, r0
   108dc:	ldr	r5, [r5, #4]
   108de:	lsls	r5, r5, #31
   108e0:	bpl.n	10968 <_free_r+0xd8>
   108e2:	orr.w	r2, r3, #1
   108e6:	str	r2, [r4, #4]
   108e8:	str	r3, [r4, r3]
   108ea:	cmp.w	r3, #512	; 0x200
   108ee:	bcs.n	10922 <_free_r+0x92>
   108f0:	lsrs	r3, r3, #3
   108f2:	adds	r2, r3, #1
   108f4:	ldr	r5, [r1, #4]
   108f6:	ldr.w	r7, [r1, r2, lsl #3]
   108fa:	str	r7, [r4, #8]
   108fc:	movs	r0, #1
   108fe:	asrs	r3, r3, #2
   10900:	lsl.w	r3, r0, r3
   10904:	add.w	r0, r1, r2, lsl #3
   10908:	orrs	r5, r3
   1090a:	subs	r0, #8
   1090c:	str	r0, [r4, #12]
   1090e:	str	r5, [r1, #4]
   10910:	str.w	r4, [r1, r2, lsl #3]
   10914:	str	r4, [r7, #12]
   10916:	mov	r0, r8
   10918:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1091c:	b.w	bab0 <__malloc_unlock>
   10920:	bx	lr
   10922:	lsrs	r2, r3, #9
   10924:	cmp	r2, #4
   10926:	bhi.n	109d0 <_free_r+0x140>
   10928:	lsrs	r2, r3, #6
   1092a:	add.w	r7, r2, #57	; 0x39
   1092e:	lsls	r7, r7, #1
   10930:	add.w	r5, r2, #56	; 0x38
   10934:	add.w	r0, r1, r7, lsl #2
   10938:	ldr.w	r2, [r1, r7, lsl #2]
   1093c:	ldr	r1, [pc, #272]	; (10a50 <_free_r+0x1c0>)
   1093e:	subs	r0, #8
   10940:	cmp	r0, r2
   10942:	beq.n	109e0 <_free_r+0x150>
   10944:	ldr	r1, [r2, #4]
   10946:	bic.w	r1, r1, #3
   1094a:	cmp	r3, r1
   1094c:	bcs.n	10954 <_free_r+0xc4>
   1094e:	ldr	r2, [r2, #8]
   10950:	cmp	r0, r2
   10952:	bne.n	10944 <_free_r+0xb4>
   10954:	ldr	r0, [r2, #12]
   10956:	str	r0, [r4, #12]
   10958:	str	r2, [r4, #8]
   1095a:	str	r4, [r0, #8]
   1095c:	str	r4, [r2, #12]
   1095e:	mov	r0, r8
   10960:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   10964:	b.w	bab0 <__malloc_unlock>
   10968:	ldr	r5, [r2, #8]
   1096a:	ldr	r7, [pc, #232]	; (10a54 <_free_r+0x1c4>)
   1096c:	cmp	r5, r7
   1096e:	add	r3, r0
   10970:	beq.n	109f2 <_free_r+0x162>
   10972:	ldr	r0, [r2, #12]
   10974:	str	r0, [r5, #12]
   10976:	orr.w	r2, r3, #1
   1097a:	str	r5, [r0, #8]
   1097c:	str	r2, [r4, #4]
   1097e:	str	r3, [r4, r3]
   10980:	b.n	108ea <_free_r+0x5a>
   10982:	lsls	r7, r7, #31
   10984:	add	r3, r0
   10986:	bmi.n	10998 <_free_r+0x108>
   10988:	ldr.w	r2, [r5, #-8]
   1098c:	subs	r4, r4, r2
   1098e:	add	r3, r2
   10990:	ldr	r0, [r4, #8]
   10992:	ldr	r2, [r4, #12]
   10994:	str	r2, [r0, #12]
   10996:	str	r0, [r2, #8]
   10998:	ldr	r2, [pc, #188]	; (10a58 <_free_r+0x1c8>)
   1099a:	ldr	r2, [r2, #0]
   1099c:	orr.w	r0, r3, #1
   109a0:	cmp	r3, r2
   109a2:	str	r0, [r4, #4]
   109a4:	str	r4, [r1, #8]
   109a6:	bcc.n	10916 <_free_r+0x86>
   109a8:	ldr	r3, [pc, #176]	; (10a5c <_free_r+0x1cc>)
   109aa:	mov	r0, r8
   109ac:	ldr	r1, [r3, #0]
   109ae:	bl	107f4 <_malloc_trim_r>
   109b2:	b.n	10916 <_free_r+0x86>
   109b4:	adds	r1, r2, r0
   109b6:	ldr	r1, [r1, #4]
   109b8:	lsls	r1, r1, #31
   109ba:	bmi.n	10a46 <_free_r+0x1b6>
   109bc:	ldr	r1, [r2, #8]
   109be:	ldr	r2, [r2, #12]
   109c0:	str	r2, [r1, #12]
   109c2:	add	r3, r0
   109c4:	orr.w	r0, r3, #1
   109c8:	str	r1, [r2, #8]
   109ca:	str	r0, [r4, #4]
   109cc:	str	r3, [r4, r3]
   109ce:	b.n	10916 <_free_r+0x86>
   109d0:	cmp	r2, #20
   109d2:	bhi.n	10a04 <_free_r+0x174>
   109d4:	add.w	r7, r2, #92	; 0x5c
   109d8:	lsls	r7, r7, #1
   109da:	add.w	r5, r2, #91	; 0x5b
   109de:	b.n	10934 <_free_r+0xa4>
   109e0:	asrs	r2, r5, #2
   109e2:	ldr	r3, [r1, #4]
   109e4:	movs	r5, #1
   109e6:	lsl.w	r2, r5, r2
   109ea:	orrs	r3, r2
   109ec:	str	r3, [r1, #4]
   109ee:	mov	r2, r0
   109f0:	b.n	10956 <_free_r+0xc6>
   109f2:	orr.w	r2, r3, #1
   109f6:	str	r4, [r1, #20]
   109f8:	str	r4, [r1, #16]
   109fa:	str	r5, [r4, #12]
   109fc:	str	r5, [r4, #8]
   109fe:	str	r2, [r4, #4]
   10a00:	str	r3, [r4, r3]
   10a02:	b.n	10916 <_free_r+0x86>
   10a04:	cmp	r2, #84	; 0x54
   10a06:	bhi.n	10a16 <_free_r+0x186>
   10a08:	lsrs	r2, r3, #12
   10a0a:	add.w	r7, r2, #111	; 0x6f
   10a0e:	lsls	r7, r7, #1
   10a10:	add.w	r5, r2, #110	; 0x6e
   10a14:	b.n	10934 <_free_r+0xa4>
   10a16:	cmp.w	r2, #340	; 0x154
   10a1a:	bhi.n	10a2a <_free_r+0x19a>
   10a1c:	lsrs	r2, r3, #15
   10a1e:	add.w	r7, r2, #120	; 0x78
   10a22:	lsls	r7, r7, #1
   10a24:	add.w	r5, r2, #119	; 0x77
   10a28:	b.n	10934 <_free_r+0xa4>
   10a2a:	movw	r0, #1364	; 0x554
   10a2e:	cmp	r2, r0
   10a30:	bhi.n	10a40 <_free_r+0x1b0>
   10a32:	lsrs	r2, r3, #18
   10a34:	add.w	r7, r2, #125	; 0x7d
   10a38:	lsls	r7, r7, #1
   10a3a:	add.w	r5, r2, #124	; 0x7c
   10a3e:	b.n	10934 <_free_r+0xa4>
   10a40:	movs	r7, #254	; 0xfe
   10a42:	movs	r5, #126	; 0x7e
   10a44:	b.n	10934 <_free_r+0xa4>
   10a46:	orr.w	r2, r3, #1
   10a4a:	str	r2, [r4, #4]
   10a4c:	str	r3, [r4, r3]
   10a4e:	b.n	10916 <_free_r+0x86>
   10a50:	.word	0x1fff1998
   10a54:	.word	0x1fff19a0
   10a58:	.word	0x1fff1da0
   10a5c:	.word	0x2001a81c

00010a60 <rshift>:
   10a60:	ldr	r2, [r0, #16]
   10a62:	asrs	r3, r1, #5
   10a64:	cmp	r3, r2
   10a66:	bge.n	10ac6 <rshift+0x66>
   10a68:	push	{r4, r5, r6, r7, lr}
   10a6a:	ands.w	r1, r1, #31
   10a6e:	add.w	r6, r0, #20
   10a72:	add.w	r2, r6, r2, lsl #2
   10a76:	add.w	lr, r6, r3, lsl #2
   10a7a:	beq.n	10ad0 <rshift+0x70>
   10a7c:	ldr.w	r3, [r6, r3, lsl #2]
   10a80:	add.w	r5, lr, #4
   10a84:	cmp	r2, r5
   10a86:	lsr.w	r4, r3, r1
   10a8a:	rsb	ip, r1, #32
   10a8e:	bls.n	10b04 <rshift+0xa4>
   10a90:	add.w	r7, r0, #16
   10a94:	ldr	r3, [r5, #0]
   10a96:	lsl.w	r3, r3, ip
   10a9a:	orrs	r3, r4
   10a9c:	str.w	r3, [r7, #4]!
   10aa0:	ldr.w	r3, [r5], #4
   10aa4:	cmp	r2, r5
   10aa6:	lsr.w	r4, r3, r1
   10aaa:	bhi.n	10a94 <rshift+0x34>
   10aac:	rsb	r2, lr, r2
   10ab0:	subs	r2, #5
   10ab2:	bic.w	r2, r2, #3
   10ab6:	adds	r2, #4
   10ab8:	add	r2, r6
   10aba:	str	r4, [r2, #0]
   10abc:	cbz	r4, 10ac0 <rshift+0x60>
   10abe:	adds	r2, #4
   10ac0:	subs	r3, r2, r6
   10ac2:	asrs	r3, r3, #2
   10ac4:	b.n	10af4 <rshift+0x94>
   10ac6:	movs	r3, #0
   10ac8:	str	r3, [r0, #16]
   10aca:	movs	r3, #0
   10acc:	str	r3, [r0, #20]
   10ace:	bx	lr
   10ad0:	cmp	r2, lr
   10ad2:	bls.n	10afa <rshift+0x9a>
   10ad4:	add.w	r4, r0, #16
   10ad8:	mov	r1, lr
   10ada:	ldr.w	r5, [r1], #4
   10ade:	str.w	r5, [r4, #4]!
   10ae2:	cmp	r2, r1
   10ae4:	bhi.n	10ada <rshift+0x7a>
   10ae6:	mvn.w	r3, lr
   10aea:	add	r3, r2
   10aec:	bic.w	r3, r3, #3
   10af0:	adds	r3, #4
   10af2:	asrs	r3, r3, #2
   10af4:	str	r3, [r0, #16]
   10af6:	cbz	r3, 10afe <rshift+0x9e>
   10af8:	pop	{r4, r5, r6, r7, pc}
   10afa:	movs	r3, #0
   10afc:	str	r3, [r0, #16]
   10afe:	movs	r3, #0
   10b00:	str	r3, [r0, #20]
   10b02:	pop	{r4, r5, r6, r7, pc}
   10b04:	mov	r2, r6
   10b06:	b.n	10aba <rshift+0x5a>

00010b08 <__gethex>:
   10b08:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10b0c:	sub	sp, #44	; 0x2c
   10b0e:	mov	r9, r1
   10b10:	str	r0, [sp, #20]
   10b12:	ldr	r0, [sp, #88]	; 0x58
   10b14:	str	r2, [sp, #12]
   10b16:	str	r3, [sp, #32]
   10b18:	bl	111e4 <__localeconv_l>
   10b1c:	ldr	r3, [r0, #0]
   10b1e:	str	r3, [sp, #8]
   10b20:	mov	r0, r3
   10b22:	mov	r4, r3
   10b24:	bl	bf80 <strlen>
   10b28:	ldr.w	r3, [r9]
   10b2c:	str	r0, [sp, #0]
   10b2e:	ldrb	r2, [r3, #2]
   10b30:	adds	r1, r4, r0
   10b32:	cmp	r2, #48	; 0x30
   10b34:	ldrb.w	fp, [r1, #-1]
   10b38:	bne.w	10e8e <__gethex+0x386>
   10b3c:	adds	r3, #3
   10b3e:	mov.w	r8, #0
   10b42:	mov	r4, r3
   10b44:	ldrb.w	r2, [r3], #1
   10b48:	cmp	r2, #48	; 0x30
   10b4a:	add.w	r8, r8, #1
   10b4e:	beq.n	10b42 <__gethex+0x3a>
   10b50:	ldr	r6, [pc, #712]	; (10e1c <__gethex+0x314>)
   10b52:	ldrb	r3, [r6, r2]
   10b54:	cmp	r3, #0
   10b56:	beq.w	10d3a <__gethex+0x232>
   10b5a:	ldrb	r3, [r4, #0]
   10b5c:	mov.w	sl, #0
   10b60:	ldrb	r3, [r6, r3]
   10b62:	mov	r5, sl
   10b64:	mov	r7, r4
   10b66:	cbz	r3, 10b72 <__gethex+0x6a>
   10b68:	ldrb.w	r3, [r7, #1]!
   10b6c:	ldrb	r3, [r6, r3]
   10b6e:	cmp	r3, #0
   10b70:	bne.n	10b68 <__gethex+0x60>
   10b72:	ldr	r2, [sp, #0]
   10b74:	ldr	r1, [sp, #8]
   10b76:	mov	r0, r7
   10b78:	bl	c05c <strncmp>
   10b7c:	cmp	r0, #0
   10b7e:	beq.w	10ca6 <__gethex+0x19e>
   10b82:	ldrb	r3, [r7, #0]
   10b84:	cmp	r5, #0
   10b86:	beq.w	10e6c <__gethex+0x364>
   10b8a:	subs	r5, r5, r7
   10b8c:	lsls	r2, r5, #2
   10b8e:	str	r2, [sp, #4]
   10b90:	cmp	r3, #80	; 0x50
   10b92:	beq.w	10cb8 <__gethex+0x1b0>
   10b96:	cmp	r3, #112	; 0x70
   10b98:	beq.w	10cb8 <__gethex+0x1b0>
   10b9c:	mov	r5, r7
   10b9e:	str.w	r7, [r9]
   10ba2:	cmp.w	sl, #0
   10ba6:	bne.w	10d18 <__gethex+0x210>
   10baa:	subs	r3, r5, r4
   10bac:	subs	r3, #1
   10bae:	cmp	r3, #7
   10bb0:	mov	r1, sl
   10bb2:	ble.n	10bbe <__gethex+0xb6>
   10bb4:	asrs	r3, r3, #1
   10bb6:	cmp	r3, #7
   10bb8:	add.w	r1, r1, #1
   10bbc:	bgt.n	10bb4 <__gethex+0xac>
   10bbe:	ldr	r0, [sp, #20]
   10bc0:	bl	11260 <_Balloc>
   10bc4:	mov	r3, r0
   10bc6:	adds	r3, #20
   10bc8:	cmp	r5, r4
   10bca:	str	r0, [sp, #16]
   10bcc:	str	r3, [sp, #28]
   10bce:	bls.w	10f78 <__gethex+0x470>
   10bd2:	mov	r9, r3
   10bd4:	ldr	r3, [sp, #0]
   10bd6:	mov.w	r8, #0
   10bda:	rsb	r3, r3, #1
   10bde:	mov	r7, r8
   10be0:	str	r3, [sp, #24]
   10be2:	b.n	10c04 <__gethex+0xfc>
   10be4:	cmp	r7, #32
   10be6:	beq.w	10d28 <__gethex+0x220>
   10bea:	mov	r2, r7
   10bec:	adds	r7, #4
   10bee:	ldrb.w	r3, [r5, #-1]
   10bf2:	ldrb	r3, [r6, r3]
   10bf4:	mov	r5, sl
   10bf6:	and.w	r3, r3, #15
   10bfa:	lsls	r3, r2
   10bfc:	cmp	r5, r4
   10bfe:	orr.w	r8, r8, r3
   10c02:	bls.n	10c30 <__gethex+0x128>
   10c04:	ldrb.w	r3, [r5, #-1]
   10c08:	cmp	r3, fp
   10c0a:	add.w	sl, r5, #4294967295
   10c0e:	bne.n	10be4 <__gethex+0xdc>
   10c10:	ldr	r3, [sp, #24]
   10c12:	add	r3, sl
   10c14:	cmp	r3, r4
   10c16:	bcc.n	10be4 <__gethex+0xdc>
   10c18:	mov	r0, r3
   10c1a:	ldr	r2, [sp, #0]
   10c1c:	ldr	r1, [sp, #8]
   10c1e:	str	r3, [sp, #36]	; 0x24
   10c20:	bl	c05c <strncmp>
   10c24:	ldr	r3, [sp, #36]	; 0x24
   10c26:	cmp	r0, #0
   10c28:	bne.n	10be4 <__gethex+0xdc>
   10c2a:	mov	r5, r3
   10c2c:	cmp	r5, r4
   10c2e:	bhi.n	10c04 <__gethex+0xfc>
   10c30:	str.w	r8, [r9], #4
   10c34:	ldr	r3, [sp, #28]
   10c36:	ldr	r2, [sp, #16]
   10c38:	rsb	r9, r3, r9
   10c3c:	mov.w	r3, r9, asr #2
   10c40:	str	r3, [r2, #16]
   10c42:	mov	r0, r8
   10c44:	mov.w	r9, r3, lsl #5
   10c48:	bl	113d8 <__hi0bits>
   10c4c:	ldr	r3, [sp, #12]
   10c4e:	ldr	r6, [r3, #0]
   10c50:	rsb	r0, r0, r9
   10c54:	cmp	r0, r6
   10c56:	bgt.w	10e20 <__gethex+0x318>
   10c5a:	blt.w	10e70 <__gethex+0x368>
   10c5e:	movs	r7, #0
   10c60:	ldr	r3, [sp, #12]
   10c62:	ldr	r2, [sp, #4]
   10c64:	ldr	r3, [r3, #8]
   10c66:	cmp	r2, r3
   10c68:	bgt.w	10d9a <__gethex+0x292>
   10c6c:	ldr	r0, [sp, #12]
   10c6e:	ldr	r1, [sp, #4]
   10c70:	ldr	r3, [r0, #4]
   10c72:	cmp	r1, r3
   10c74:	bge.w	10de2 <__gethex+0x2da>
   10c78:	subs	r5, r3, r1
   10c7a:	cmp	r6, r5
   10c7c:	bgt.w	10e9e <__gethex+0x396>
   10c80:	ldr	r2, [r0, #12]
   10c82:	cmp	r2, #2
   10c84:	beq.w	10f86 <__gethex+0x47e>
   10c88:	cmp	r2, #3
   10c8a:	beq.w	10f46 <__gethex+0x43e>
   10c8e:	cmp	r2, #1
   10c90:	beq.w	10f8e <__gethex+0x486>
   10c94:	ldr	r0, [sp, #20]
   10c96:	ldr	r1, [sp, #16]
   10c98:	bl	112ac <_Bfree>
   10c9c:	ldr	r2, [sp, #80]	; 0x50
   10c9e:	movs	r3, #0
   10ca0:	str	r3, [r2, #0]
   10ca2:	movs	r0, #80	; 0x50
   10ca4:	b.n	10d22 <__gethex+0x21a>
   10ca6:	cmp	r5, #0
   10ca8:	beq.w	10ede <__gethex+0x3d6>
   10cac:	ldrb	r3, [r7, #0]
   10cae:	b.n	10b8a <__gethex+0x82>
   10cb0:	movs	r3, #0
   10cb2:	str	r3, [sp, #4]
   10cb4:	mov.w	sl, #1
   10cb8:	ldrb	r3, [r7, #1]
   10cba:	cmp	r3, #43	; 0x2b
   10cbc:	beq.w	10e18 <__gethex+0x310>
   10cc0:	cmp	r3, #45	; 0x2d
   10cc2:	beq.n	10db0 <__gethex+0x2a8>
   10cc4:	adds	r1, r7, #1
   10cc6:	movs	r5, #0
   10cc8:	ldrb	r3, [r6, r3]
   10cca:	ldr	r0, [pc, #336]	; (10e1c <__gethex+0x314>)
   10ccc:	subs	r2, r3, #1
   10cce:	cmp	r2, #24
   10cd0:	bhi.w	10b9c <__gethex+0x94>
   10cd4:	ldrb	r2, [r1, #1]
   10cd6:	ldrb	r2, [r0, r2]
   10cd8:	subs	r0, r2, #1
   10cda:	cmp	r0, #24
   10cdc:	sub.w	r3, r3, #16
   10ce0:	add.w	r1, r1, #1
   10ce4:	bhi.n	10cfe <__gethex+0x1f6>
   10ce6:	ldrb.w	r0, [r1, #1]!
   10cea:	add.w	r3, r3, r3, lsl #2
   10cee:	add.w	r3, r2, r3, lsl #1
   10cf2:	ldrb	r2, [r6, r0]
   10cf4:	subs	r0, r2, #1
   10cf6:	cmp	r0, #24
   10cf8:	sub.w	r3, r3, #16
   10cfc:	bls.n	10ce6 <__gethex+0x1de>
   10cfe:	cbz	r5, 10d02 <__gethex+0x1fa>
   10d00:	negs	r3, r3
   10d02:	ldr	r2, [sp, #4]
   10d04:	mov	r5, r7
   10d06:	add	r2, r3
   10d08:	mov	r7, r1
   10d0a:	str	r2, [sp, #4]
   10d0c:	str.w	r7, [r9]
   10d10:	cmp.w	sl, #0
   10d14:	beq.w	10baa <__gethex+0xa2>
   10d18:	cmp.w	r8, #0
   10d1c:	ite	eq
   10d1e:	moveq	r0, #6
   10d20:	movne	r0, #0
   10d22:	add	sp, #44	; 0x2c
   10d24:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10d28:	str.w	r8, [r9]
   10d2c:	mov.w	r8, #0
   10d30:	add.w	r9, r9, #4
   10d34:	mov	r2, r8
   10d36:	movs	r7, #4
   10d38:	b.n	10bee <__gethex+0xe6>
   10d3a:	ldr	r5, [sp, #0]
   10d3c:	ldr	r1, [sp, #8]
   10d3e:	mov	r2, r5
   10d40:	mov	r0, r4
   10d42:	bl	c05c <strncmp>
   10d46:	cmp	r0, #0
   10d48:	beq.n	10db8 <__gethex+0x2b0>
   10d4a:	ldrb	r3, [r4, #0]
   10d4c:	mov	r7, r4
   10d4e:	cmp	r3, #80	; 0x50
   10d50:	beq.n	10cb0 <__gethex+0x1a8>
   10d52:	cmp	r3, #112	; 0x70
   10d54:	beq.n	10cb0 <__gethex+0x1a8>
   10d56:	str.w	r7, [r9]
   10d5a:	b.n	10d18 <__gethex+0x210>
   10d5c:	ldr	r3, [sp, #16]
   10d5e:	ldr	r3, [r3, #8]
   10d60:	cmp	r7, r3
   10d62:	bge.w	10fce <__gethex+0x4c6>
   10d66:	mov	r3, r7
   10d68:	ldr	r0, [sp, #16]
   10d6a:	add.w	r2, r0, r3, lsl #2
   10d6e:	movs	r1, #1
   10d70:	adds	r3, #1
   10d72:	cmp	r4, #2
   10d74:	str	r3, [r0, #16]
   10d76:	str	r1, [r2, #20]
   10d78:	beq.w	10fac <__gethex+0x4a4>
   10d7c:	cmp	r7, r3
   10d7e:	bge.w	10f38 <__gethex+0x430>
   10d82:	movs	r1, #1
   10d84:	ldr	r0, [sp, #16]
   10d86:	bl	10a60 <rshift>
   10d8a:	ldr	r3, [sp, #12]
   10d8c:	ldr	r2, [sp, #4]
   10d8e:	ldr	r3, [r3, #8]
   10d90:	adds	r2, #1
   10d92:	cmp	r2, r3
   10d94:	str	r2, [sp, #4]
   10d96:	ble.w	10f3e <__gethex+0x436>
   10d9a:	ldr	r0, [sp, #20]
   10d9c:	ldr	r1, [sp, #16]
   10d9e:	bl	112ac <_Bfree>
   10da2:	ldr	r2, [sp, #80]	; 0x50
   10da4:	movs	r3, #0
   10da6:	movs	r0, #163	; 0xa3
   10da8:	str	r3, [r2, #0]
   10daa:	add	sp, #44	; 0x2c
   10dac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10db0:	movs	r5, #1
   10db2:	ldrb	r3, [r7, #2]
   10db4:	adds	r1, r7, #2
   10db6:	b.n	10cc8 <__gethex+0x1c0>
   10db8:	ldrb	r2, [r4, r5]
   10dba:	ldrb	r3, [r6, r2]
   10dbc:	adds	r7, r4, r5
   10dbe:	cmp	r3, #0
   10dc0:	beq.n	10e96 <__gethex+0x38e>
   10dc2:	cmp	r2, #48	; 0x30
   10dc4:	mov	r4, r7
   10dc6:	bne.n	10dd2 <__gethex+0x2ca>
   10dc8:	ldrb.w	r3, [r4, #1]!
   10dcc:	cmp	r3, #48	; 0x30
   10dce:	beq.n	10dc8 <__gethex+0x2c0>
   10dd0:	ldrb	r3, [r6, r3]
   10dd2:	clz	sl, r3
   10dd6:	mov	r5, r7
   10dd8:	mov.w	sl, sl, lsr #5
   10ddc:	mov.w	r8, #1
   10de0:	b.n	10b64 <__gethex+0x5c>
   10de2:	movs	r4, #1
   10de4:	cbz	r7, 10e00 <__gethex+0x2f8>
   10de6:	ldr	r3, [sp, #12]
   10de8:	ldr	r3, [r3, #12]
   10dea:	cmp	r3, #2
   10dec:	beq.w	10efa <__gethex+0x3f2>
   10df0:	cmp	r3, #3
   10df2:	beq.w	10f02 <__gethex+0x3fa>
   10df6:	cmp	r3, #1
   10df8:	beq.w	10f66 <__gethex+0x45e>
   10dfc:	orr.w	r4, r4, #16
   10e00:	ldr	r3, [sp, #80]	; 0x50
   10e02:	mov	r2, r3
   10e04:	ldr	r3, [sp, #16]
   10e06:	str	r3, [r2, #0]
   10e08:	ldr	r3, [sp, #32]
   10e0a:	mov	r2, r3
   10e0c:	ldr	r3, [sp, #4]
   10e0e:	str	r3, [r2, #0]
   10e10:	mov	r0, r4
   10e12:	add	sp, #44	; 0x2c
   10e14:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10e18:	movs	r5, #0
   10e1a:	b.n	10db2 <__gethex+0x2aa>
   10e1c:	.word	0x00013324
   10e20:	subs	r4, r0, r6
   10e22:	mov	r1, r4
   10e24:	ldr	r0, [sp, #16]
   10e26:	bl	11ae8 <__any_on>
   10e2a:	cmp	r0, #0
   10e2c:	beq.n	10e9a <__gethex+0x392>
   10e2e:	subs	r2, r4, #1
   10e30:	asrs	r1, r2, #5
   10e32:	ldr	r0, [sp, #28]
   10e34:	and.w	r3, r2, #31
   10e38:	ldr.w	r1, [r0, r1, lsl #2]
   10e3c:	movs	r7, #1
   10e3e:	lsl.w	r3, r7, r3
   10e42:	tst	r3, r1
   10e44:	beq.n	10e5c <__gethex+0x354>
   10e46:	cmp	r2, r7
   10e48:	ble.w	10f82 <__gethex+0x47a>
   10e4c:	subs	r1, r4, #2
   10e4e:	ldr	r0, [sp, #16]
   10e50:	bl	11ae8 <__any_on>
   10e54:	cmp	r0, #0
   10e56:	beq.w	10f82 <__gethex+0x47a>
   10e5a:	movs	r7, #3
   10e5c:	ldr	r3, [sp, #4]
   10e5e:	ldr	r0, [sp, #16]
   10e60:	add	r3, r4
   10e62:	mov	r1, r4
   10e64:	str	r3, [sp, #4]
   10e66:	bl	10a60 <rshift>
   10e6a:	b.n	10c60 <__gethex+0x158>
   10e6c:	str	r5, [sp, #4]
   10e6e:	b.n	10b90 <__gethex+0x88>
   10e70:	subs	r4, r6, r0
   10e72:	ldr	r1, [sp, #16]
   10e74:	ldr	r0, [sp, #20]
   10e76:	mov	r2, r4
   10e78:	bl	11658 <__lshift>
   10e7c:	ldr	r3, [sp, #4]
   10e7e:	str	r0, [sp, #16]
   10e80:	subs	r3, r3, r4
   10e82:	str	r3, [sp, #4]
   10e84:	mov	r3, r0
   10e86:	adds	r3, #20
   10e88:	str	r3, [sp, #28]
   10e8a:	movs	r7, #0
   10e8c:	b.n	10c60 <__gethex+0x158>
   10e8e:	adds	r4, r3, #2
   10e90:	mov.w	r8, #0
   10e94:	b.n	10b50 <__gethex+0x48>
   10e96:	mov	r3, r2
   10e98:	b.n	10d4e <__gethex+0x246>
   10e9a:	mov	r7, r0
   10e9c:	b.n	10e5c <__gethex+0x354>
   10e9e:	subs	r4, r5, #1
   10ea0:	cmp	r7, #0
   10ea2:	bne.n	10f42 <__gethex+0x43a>
   10ea4:	cbz	r4, 10eb0 <__gethex+0x3a8>
   10ea6:	mov	r1, r4
   10ea8:	ldr	r0, [sp, #16]
   10eaa:	bl	11ae8 <__any_on>
   10eae:	mov	r7, r0
   10eb0:	asrs	r3, r4, #5
   10eb2:	ldr	r2, [sp, #28]
   10eb4:	ldr	r0, [sp, #16]
   10eb6:	ldr.w	r2, [r2, r3, lsl #2]
   10eba:	and.w	r4, r4, #31
   10ebe:	movs	r3, #1
   10ec0:	lsl.w	r4, r3, r4
   10ec4:	tst	r4, r2
   10ec6:	mov	r1, r5
   10ec8:	it	ne
   10eca:	orrne.w	r7, r7, #2
   10ece:	bl	10a60 <rshift>
   10ed2:	ldr	r3, [sp, #12]
   10ed4:	ldr	r3, [r3, #4]
   10ed6:	str	r3, [sp, #4]
   10ed8:	subs	r6, r6, r5
   10eda:	movs	r4, #2
   10edc:	b.n	10de4 <__gethex+0x2dc>
   10ede:	ldr	r1, [sp, #0]
   10ee0:	ldrb	r3, [r7, r1]
   10ee2:	ldrb	r2, [r6, r3]
   10ee4:	adds	r5, r7, r1
   10ee6:	mov	r7, r5
   10ee8:	cmp	r2, #0
   10eea:	beq.w	10b8a <__gethex+0x82>
   10eee:	ldrb.w	r3, [r7, #1]!
   10ef2:	ldrb	r2, [r6, r3]
   10ef4:	cmp	r2, #0
   10ef6:	bne.n	10eee <__gethex+0x3e6>
   10ef8:	b.n	10b8a <__gethex+0x82>
   10efa:	ldr	r3, [sp, #84]	; 0x54
   10efc:	rsb	r3, r3, #1
   10f00:	str	r3, [sp, #84]	; 0x54
   10f02:	ldr	r3, [sp, #84]	; 0x54
   10f04:	cmp	r3, #0
   10f06:	beq.w	10dfc <__gethex+0x2f4>
   10f0a:	ldr	r3, [sp, #16]
   10f0c:	ldr	r5, [sp, #28]
   10f0e:	ldr	r7, [r3, #16]
   10f10:	mov.w	r8, r7, lsl #2
   10f14:	add.w	r0, r5, r8
   10f18:	mov	r3, r5
   10f1a:	movs	r1, #0
   10f1c:	b.n	10f28 <__gethex+0x420>
   10f1e:	str.w	r1, [r3], #4
   10f22:	cmp	r0, r3
   10f24:	bls.w	10d5c <__gethex+0x254>
   10f28:	ldr	r2, [r3, #0]
   10f2a:	cmp.w	r2, #4294967295
   10f2e:	beq.n	10f1e <__gethex+0x416>
   10f30:	adds	r2, #1
   10f32:	cmp	r4, #2
   10f34:	str	r2, [r3, #0]
   10f36:	beq.n	10fac <__gethex+0x4a4>
   10f38:	ands.w	r6, r6, #31
   10f3c:	bne.n	10fba <__gethex+0x4b2>
   10f3e:	movs	r4, #33	; 0x21
   10f40:	b.n	10e00 <__gethex+0x2f8>
   10f42:	movs	r7, #1
   10f44:	b.n	10eb0 <__gethex+0x3a8>
   10f46:	ldr	r2, [sp, #84]	; 0x54
   10f48:	cmp	r2, #0
   10f4a:	beq.w	10c94 <__gethex+0x18c>
   10f4e:	ldr	r1, [sp, #32]
   10f50:	str	r3, [r1, #0]
   10f52:	ldr	r3, [sp, #28]
   10f54:	ldr	r1, [sp, #16]
   10f56:	movs	r2, #1
   10f58:	str	r2, [r1, #16]
   10f5a:	str	r2, [r3, #0]
   10f5c:	ldr	r3, [sp, #80]	; 0x50
   10f5e:	mov	r2, r3
   10f60:	movs	r0, #98	; 0x62
   10f62:	str	r1, [r2, #0]
   10f64:	b.n	10d22 <__gethex+0x21a>
   10f66:	lsls	r2, r7, #30
   10f68:	bpl.w	10dfc <__gethex+0x2f4>
   10f6c:	ldr	r3, [sp, #28]
   10f6e:	ldr	r3, [r3, #0]
   10f70:	orrs	r3, r7
   10f72:	lsls	r3, r3, #31
   10f74:	bmi.n	10f0a <__gethex+0x402>
   10f76:	b.n	10dfc <__gethex+0x2f4>
   10f78:	ldr.w	r9, [sp, #28]
   10f7c:	mov.w	r8, #0
   10f80:	b.n	10c30 <__gethex+0x128>
   10f82:	movs	r7, #2
   10f84:	b.n	10e5c <__gethex+0x354>
   10f86:	ldr	r2, [sp, #84]	; 0x54
   10f88:	cmp	r2, #0
   10f8a:	beq.n	10f4e <__gethex+0x446>
   10f8c:	b.n	10c94 <__gethex+0x18c>
   10f8e:	cmp	r6, r5
   10f90:	bne.w	10c94 <__gethex+0x18c>
   10f94:	cmp	r6, #1
   10f96:	ble.n	10f4e <__gethex+0x446>
   10f98:	subs	r1, r6, #1
   10f9a:	ldr	r0, [sp, #16]
   10f9c:	bl	11ae8 <__any_on>
   10fa0:	cmp	r0, #0
   10fa2:	beq.w	10c94 <__gethex+0x18c>
   10fa6:	ldr	r3, [sp, #12]
   10fa8:	ldr	r3, [r3, #4]
   10faa:	b.n	10f4e <__gethex+0x446>
   10fac:	ldr	r3, [sp, #12]
   10fae:	ldr	r3, [r3, #0]
   10fb0:	subs	r3, #1
   10fb2:	cmp	r6, r3
   10fb4:	beq.n	11000 <__gethex+0x4f8>
   10fb6:	movs	r4, #34	; 0x22
   10fb8:	b.n	10e00 <__gethex+0x2f8>
   10fba:	add	r5, r8
   10fbc:	rsb	r6, r6, #32
   10fc0:	ldr.w	r0, [r5, #-4]
   10fc4:	bl	113d8 <__hi0bits>
   10fc8:	cmp	r0, r6
   10fca:	bge.n	10f3e <__gethex+0x436>
   10fcc:	b.n	10d82 <__gethex+0x27a>
   10fce:	ldr	r3, [sp, #16]
   10fd0:	ldr.w	r9, [sp, #20]
   10fd4:	ldr	r1, [r3, #4]
   10fd6:	mov	r0, r9
   10fd8:	adds	r1, #1
   10fda:	bl	11260 <_Balloc>
   10fde:	ldr	r1, [sp, #16]
   10fe0:	ldr	r3, [r1, #16]
   10fe2:	adds	r2, r3, #2
   10fe4:	mov	r5, r0
   10fe6:	lsls	r2, r2, #2
   10fe8:	adds	r1, #12
   10fea:	adds	r0, #12
   10fec:	bl	8f14 <memcpy>
   10ff0:	ldr	r1, [sp, #16]
   10ff2:	mov	r0, r9
   10ff4:	bl	112ac <_Bfree>
   10ff8:	str	r5, [sp, #16]
   10ffa:	ldr	r3, [r5, #16]
   10ffc:	adds	r5, #20
   10ffe:	b.n	10d68 <__gethex+0x260>
   11000:	asrs	r3, r6, #5
   11002:	and.w	r6, r6, #31
   11006:	ldr.w	r2, [r5, r3, lsl #2]
   1100a:	movs	r3, #1
   1100c:	lsls	r3, r6
   1100e:	tst	r3, r2
   11010:	ite	ne
   11012:	movne	r4, #33	; 0x21
   11014:	moveq	r4, #34	; 0x22
   11016:	b.n	10e00 <__gethex+0x2f8>

00011018 <__match>:
   11018:	push	{r4, r5}
   1101a:	ldr	r4, [r0, #0]
   1101c:	b.n	11030 <__match+0x18>
   1101e:	ldrb.w	r3, [r4, #1]!
   11022:	sub.w	r5, r3, #65	; 0x41
   11026:	cmp	r5, #25
   11028:	it	ls
   1102a:	addls	r3, #32
   1102c:	cmp	r3, r2
   1102e:	bne.n	11042 <__match+0x2a>
   11030:	ldrb.w	r2, [r1], #1
   11034:	cmp	r2, #0
   11036:	bne.n	1101e <__match+0x6>
   11038:	adds	r4, #1
   1103a:	str	r4, [r0, #0]
   1103c:	movs	r0, #1
   1103e:	pop	{r4, r5}
   11040:	bx	lr
   11042:	movs	r0, #0
   11044:	pop	{r4, r5}
   11046:	bx	lr

00011048 <__hexnan>:
   11048:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1104c:	ldr	r3, [r1, #0]
   1104e:	ldr.w	r9, [pc, #372]	; 111c4 <__hexnan+0x17c>
   11052:	sub	sp, #20
   11054:	asrs	r1, r3, #5
   11056:	add.w	r1, r2, r1, lsl #2
   1105a:	ands.w	r3, r3, #31
   1105e:	str	r1, [sp, #4]
   11060:	itt	ne
   11062:	addne	r1, #4
   11064:	strne	r1, [sp, #4]
   11066:	ldr	r4, [sp, #4]
   11068:	str	r0, [sp, #8]
   1106a:	str	r3, [sp, #12]
   1106c:	movs	r3, #0
   1106e:	mov	r1, r3
   11070:	str.w	r3, [r4, #-4]
   11074:	mov	sl, r3
   11076:	mov	lr, r3
   11078:	ldr	r3, [sp, #8]
   1107a:	sub.w	ip, r4, #4
   1107e:	ldr	r5, [r3, #0]
   11080:	mov	r8, ip
   11082:	mov	r0, ip
   11084:	ldrb.w	r3, [r5, #1]!
   11088:	cbz	r3, 110d4 <__hexnan+0x8c>
   1108a:	ldrb.w	r4, [r9, r3]
   1108e:	cmp	r4, #0
   11090:	bne.n	1111a <__hexnan+0xd2>
   11092:	cmp	r3, #32
   11094:	bhi.n	11152 <__hexnan+0x10a>
   11096:	cmp	lr, sl
   11098:	ble.n	11084 <__hexnan+0x3c>
   1109a:	cmp	r0, r8
   1109c:	bcs.n	110c6 <__hexnan+0x7e>
   1109e:	cmp	r1, #7
   110a0:	bgt.n	110c6 <__hexnan+0x7e>
   110a2:	rsb	r1, r1, #8
   110a6:	lsls	r1, r1, #2
   110a8:	ldr	r6, [r0, #0]
   110aa:	rsb	fp, r1, #32
   110ae:	mov	r3, r0
   110b0:	ldr	r7, [r3, #4]
   110b2:	lsl.w	r4, r7, fp
   110b6:	orrs	r4, r6
   110b8:	lsr.w	r6, r7, r1
   110bc:	str	r4, [r3, #0]
   110be:	str.w	r6, [r3, #4]!
   110c2:	cmp	r8, r3
   110c4:	bhi.n	110b0 <__hexnan+0x68>
   110c6:	cmp	r0, r2
   110c8:	bhi.n	11140 <__hexnan+0xf8>
   110ca:	ldrb.w	r3, [r5, #1]!
   110ce:	movs	r1, #8
   110d0:	cmp	r3, #0
   110d2:	bne.n	1108a <__hexnan+0x42>
   110d4:	cmp.w	lr, #0
   110d8:	beq.n	11156 <__hexnan+0x10e>
   110da:	cmp	r0, r8
   110dc:	bcs.n	110e2 <__hexnan+0x9a>
   110de:	cmp	r1, #7
   110e0:	ble.n	1119c <__hexnan+0x154>
   110e2:	cmp	r0, r2
   110e4:	bls.n	1115e <__hexnan+0x116>
   110e6:	mov	r3, r2
   110e8:	ldr.w	r1, [r0], #4
   110ec:	str.w	r1, [r3], #4
   110f0:	cmp	ip, r0
   110f2:	bcs.n	110e8 <__hexnan+0xa0>
   110f4:	movs	r1, #0
   110f6:	str.w	r1, [r3], #4
   110fa:	cmp	ip, r3
   110fc:	bcs.n	110f6 <__hexnan+0xae>
   110fe:	ldr	r3, [sp, #4]
   11100:	ldr.w	r3, [r3, #-4]
   11104:	cbnz	r3, 11112 <__hexnan+0xca>
   11106:	cmp	r2, ip
   11108:	beq.n	11180 <__hexnan+0x138>
   1110a:	ldr.w	r3, [ip, #-4]!
   1110e:	cmp	r3, #0
   11110:	beq.n	11106 <__hexnan+0xbe>
   11112:	movs	r0, #5
   11114:	add	sp, #20
   11116:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1111a:	adds	r1, #1
   1111c:	cmp	r1, #8
   1111e:	add.w	lr, lr, #1
   11122:	ble.n	11132 <__hexnan+0xea>
   11124:	cmp	r0, r2
   11126:	bls.n	11084 <__hexnan+0x3c>
   11128:	movs	r3, #0
   1112a:	str.w	r3, [r0, #-4]
   1112e:	movs	r1, #1
   11130:	subs	r0, #4
   11132:	ldr	r3, [r0, #0]
   11134:	and.w	r4, r4, #15
   11138:	orr.w	r4, r4, r3, lsl #4
   1113c:	str	r4, [r0, #0]
   1113e:	b.n	11084 <__hexnan+0x3c>
   11140:	movs	r3, #0
   11142:	sub.w	r8, r0, #4
   11146:	str.w	r3, [r0, #-4]
   1114a:	mov	sl, lr
   1114c:	mov	r0, r8
   1114e:	mov	r1, r3
   11150:	b.n	11084 <__hexnan+0x3c>
   11152:	cmp	r3, #41	; 0x29
   11154:	beq.n	1118e <__hexnan+0x146>
   11156:	movs	r0, #4
   11158:	add	sp, #20
   1115a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1115e:	ldr	r3, [sp, #12]
   11160:	cmp	r3, #0
   11162:	beq.n	110fe <__hexnan+0xb6>
   11164:	ldr	r4, [sp, #4]
   11166:	ldr	r3, [sp, #12]
   11168:	ldr.w	r1, [r4, #-4]
   1116c:	rsb	r3, r3, #32
   11170:	mov.w	r0, #4294967295
   11174:	lsr.w	r3, r0, r3
   11178:	ands	r3, r1
   1117a:	str.w	r3, [r4, #-4]
   1117e:	b.n	11104 <__hexnan+0xbc>
   11180:	movs	r3, #1
   11182:	movs	r0, #5
   11184:	str.w	r3, [ip]
   11188:	add	sp, #20
   1118a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1118e:	ldr	r3, [sp, #8]
   11190:	adds	r5, #1
   11192:	str	r5, [r3, #0]
   11194:	cmp.w	lr, #0
   11198:	bne.n	110da <__hexnan+0x92>
   1119a:	b.n	11156 <__hexnan+0x10e>
   1119c:	rsb	r3, r1, #8
   111a0:	lsls	r3, r3, #2
   111a2:	ldr	r5, [r0, #0]
   111a4:	rsb	r7, r3, #32
   111a8:	mov	r1, r0
   111aa:	ldr	r6, [r1, #4]
   111ac:	lsl.w	r4, r6, r7
   111b0:	orrs	r4, r5
   111b2:	lsr.w	r5, r6, r3
   111b6:	str	r4, [r1, #0]
   111b8:	str.w	r5, [r1, #4]!
   111bc:	cmp	r8, r1
   111be:	bhi.n	111aa <__hexnan+0x162>
   111c0:	b.n	110e2 <__hexnan+0x9a>
   111c2:	nop
   111c4:	.word	0x00013324

000111c8 <iswspace>:
   111c8:	cmp	r0, #255	; 0xff
   111ca:	bls.n	111d0 <iswspace+0x8>
   111cc:	movs	r0, #0
   111ce:	bx	lr
   111d0:	push	{r4, lr}
   111d2:	mov	r4, r0
   111d4:	bl	b304 <__locale_ctype_ptr>
   111d8:	add	r0, r4
   111da:	ldrb	r0, [r0, #1]
   111dc:	and.w	r0, r0, #8
   111e0:	uxtb	r0, r0
   111e2:	pop	{r4, pc}

000111e4 <__localeconv_l>:
   111e4:	adds	r0, #240	; 0xf0
   111e6:	bx	lr

000111e8 <_localeconv_r>:
   111e8:	ldr	r2, [pc, #16]	; (111fc <_localeconv_r+0x14>)
   111ea:	ldr	r3, [pc, #20]	; (11200 <_localeconv_r+0x18>)
   111ec:	ldr	r2, [r2, #0]
   111ee:	ldr	r0, [r2, #52]	; 0x34
   111f0:	cmp	r0, #0
   111f2:	it	eq
   111f4:	moveq	r0, r3
   111f6:	adds	r0, #240	; 0xf0
   111f8:	bx	lr
   111fa:	nop
   111fc:	.word	0x1fff1828
   11200:	.word	0x1fff182c

00011204 <_mbrtowc_r>:
   11204:	push	{r4, r5, r6, r7, lr}
   11206:	sub	sp, #12
   11208:	mov	r7, r0
   1120a:	ldr	r5, [sp, #32]
   1120c:	cbz	r2, 11234 <_mbrtowc_r+0x30>
   1120e:	ldr	r4, [pc, #68]	; (11254 <_mbrtowc_r+0x50>)
   11210:	ldr	r6, [pc, #68]	; (11258 <_mbrtowc_r+0x54>)
   11212:	ldr	r4, [r4, #0]
   11214:	ldr	r4, [r4, #52]	; 0x34
   11216:	str	r5, [sp, #0]
   11218:	cmp	r4, #0
   1121a:	it	eq
   1121c:	moveq	r4, r6
   1121e:	ldr.w	r4, [r4, #228]	; 0xe4
   11222:	blx	r4
   11224:	adds	r3, r0, #1
   11226:	bne.n	11230 <_mbrtowc_r+0x2c>
   11228:	movs	r2, #0
   1122a:	movs	r3, #138	; 0x8a
   1122c:	str	r2, [r5, #0]
   1122e:	str	r3, [r7, #0]
   11230:	add	sp, #12
   11232:	pop	{r4, r5, r6, r7, pc}
   11234:	ldr	r3, [pc, #28]	; (11254 <_mbrtowc_r+0x50>)
   11236:	ldr	r1, [pc, #32]	; (11258 <_mbrtowc_r+0x54>)
   11238:	ldr	r3, [r3, #0]
   1123a:	ldr	r3, [r3, #52]	; 0x34
   1123c:	str	r5, [sp, #0]
   1123e:	cmp	r3, #0
   11240:	it	eq
   11242:	moveq	r3, r1
   11244:	mov	r4, r2
   11246:	mov	r1, r4
   11248:	ldr	r2, [pc, #16]	; (1125c <_mbrtowc_r+0x58>)
   1124a:	ldr.w	r4, [r3, #228]	; 0xe4
   1124e:	movs	r3, #1
   11250:	blx	r4
   11252:	b.n	11224 <_mbrtowc_r+0x20>
   11254:	.word	0x1fff1828
   11258:	.word	0x1fff182c
   1125c:	.word	0x000131b0

00011260 <_Balloc>:
   11260:	ldr	r3, [r0, #76]	; 0x4c
   11262:	push	{r4, r5, r6, lr}
   11264:	mov	r5, r0
   11266:	mov	r4, r1
   11268:	cbz	r3, 1127e <_Balloc+0x1e>
   1126a:	ldr.w	r0, [r3, r4, lsl #2]
   1126e:	cbz	r0, 11292 <_Balloc+0x32>
   11270:	ldr	r2, [r0, #0]
   11272:	str.w	r2, [r3, r4, lsl #2]
   11276:	movs	r3, #0
   11278:	str	r3, [r0, #16]
   1127a:	str	r3, [r0, #12]
   1127c:	pop	{r4, r5, r6, pc}
   1127e:	movs	r2, #33	; 0x21
   11280:	movs	r1, #4
   11282:	bl	12450 <_calloc_r>
   11286:	str	r0, [r5, #76]	; 0x4c
   11288:	mov	r3, r0
   1128a:	cmp	r0, #0
   1128c:	bne.n	1126a <_Balloc+0xa>
   1128e:	movs	r0, #0
   11290:	pop	{r4, r5, r6, pc}
   11292:	movs	r1, #1
   11294:	lsl.w	r6, r1, r4
   11298:	adds	r2, r6, #5
   1129a:	mov	r0, r5
   1129c:	lsls	r2, r2, #2
   1129e:	bl	12450 <_calloc_r>
   112a2:	cmp	r0, #0
   112a4:	beq.n	1128e <_Balloc+0x2e>
   112a6:	str	r4, [r0, #4]
   112a8:	str	r6, [r0, #8]
   112aa:	b.n	11276 <_Balloc+0x16>

000112ac <_Bfree>:
   112ac:	cbz	r1, 112bc <_Bfree+0x10>
   112ae:	ldr	r3, [r0, #76]	; 0x4c
   112b0:	ldr	r2, [r1, #4]
   112b2:	ldr.w	r0, [r3, r2, lsl #2]
   112b6:	str	r0, [r1, #0]
   112b8:	str.w	r1, [r3, r2, lsl #2]
   112bc:	bx	lr
   112be:	nop

000112c0 <__multadd>:
   112c0:	push	{r4, r5, r6, r7, lr}
   112c2:	ldr	r4, [r1, #16]
   112c4:	sub	sp, #12
   112c6:	mov	r5, r1
   112c8:	mov	r6, r0
   112ca:	add.w	lr, r1, #20
   112ce:	movs	r7, #0
   112d0:	ldr.w	r0, [lr]
   112d4:	uxth	r1, r0
   112d6:	mla	r1, r2, r1, r3
   112da:	lsrs	r3, r1, #16
   112dc:	lsrs	r0, r0, #16
   112de:	mla	r3, r2, r0, r3
   112e2:	uxth	r1, r1
   112e4:	adds	r7, #1
   112e6:	add.w	r1, r1, r3, lsl #16
   112ea:	cmp	r4, r7
   112ec:	str.w	r1, [lr], #4
   112f0:	mov.w	r3, r3, lsr #16
   112f4:	bgt.n	112d0 <__multadd+0x10>
   112f6:	cbz	r3, 11308 <__multadd+0x48>
   112f8:	ldr	r2, [r5, #8]
   112fa:	cmp	r4, r2
   112fc:	bge.n	1130e <__multadd+0x4e>
   112fe:	add.w	r2, r5, r4, lsl #2
   11302:	adds	r4, #1
   11304:	str	r3, [r2, #20]
   11306:	str	r4, [r5, #16]
   11308:	mov	r0, r5
   1130a:	add	sp, #12
   1130c:	pop	{r4, r5, r6, r7, pc}
   1130e:	ldr	r1, [r5, #4]
   11310:	str	r3, [sp, #4]
   11312:	adds	r1, #1
   11314:	mov	r0, r6
   11316:	bl	11260 <_Balloc>
   1131a:	ldr	r2, [r5, #16]
   1131c:	adds	r2, #2
   1131e:	add.w	r1, r5, #12
   11322:	mov	r7, r0
   11324:	lsls	r2, r2, #2
   11326:	adds	r0, #12
   11328:	bl	8f14 <memcpy>
   1132c:	ldr	r2, [r6, #76]	; 0x4c
   1132e:	ldr	r1, [r5, #4]
   11330:	ldr	r3, [sp, #4]
   11332:	ldr.w	r0, [r2, r1, lsl #2]
   11336:	str	r0, [r5, #0]
   11338:	str.w	r5, [r2, r1, lsl #2]
   1133c:	mov	r5, r7
   1133e:	b.n	112fe <__multadd+0x3e>

00011340 <__s2b>:
   11340:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   11344:	ldr	r4, [pc, #140]	; (113d4 <__s2b+0x94>)
   11346:	ldr	r5, [sp, #32]
   11348:	mov	r7, r3
   1134a:	adds	r3, #8
   1134c:	smull	r4, lr, r4, r3
   11350:	asrs	r3, r3, #31
   11352:	rsb	lr, r3, lr, asr #1
   11356:	cmp.w	lr, #1
   1135a:	mov	r6, r0
   1135c:	mov	r4, r1
   1135e:	mov	r8, r2
   11360:	ble.n	113ce <__s2b+0x8e>
   11362:	movs	r3, #1
   11364:	movs	r1, #0
   11366:	lsls	r3, r3, #1
   11368:	cmp	lr, r3
   1136a:	add.w	r1, r1, #1
   1136e:	bgt.n	11366 <__s2b+0x26>
   11370:	mov	r0, r6
   11372:	bl	11260 <_Balloc>
   11376:	movs	r3, #1
   11378:	cmp.w	r8, #9
   1137c:	str	r5, [r0, #20]
   1137e:	str	r3, [r0, #16]
   11380:	ble.n	113c6 <__s2b+0x86>
   11382:	add.w	r9, r4, #9
   11386:	mov	r5, r9
   11388:	add	r4, r8
   1138a:	ldrb.w	r3, [r5], #1
   1138e:	mov	r1, r0
   11390:	subs	r3, #48	; 0x30
   11392:	movs	r2, #10
   11394:	mov	r0, r6
   11396:	bl	112c0 <__multadd>
   1139a:	cmp	r5, r4
   1139c:	bne.n	1138a <__s2b+0x4a>
   1139e:	add.w	r4, r9, r8
   113a2:	subs	r4, #8
   113a4:	cmp	r7, r8
   113a6:	ble.n	113c2 <__s2b+0x82>
   113a8:	rsb	r7, r8, r7
   113ac:	add	r7, r4
   113ae:	ldrb.w	r3, [r4], #1
   113b2:	mov	r1, r0
   113b4:	subs	r3, #48	; 0x30
   113b6:	movs	r2, #10
   113b8:	mov	r0, r6
   113ba:	bl	112c0 <__multadd>
   113be:	cmp	r7, r4
   113c0:	bne.n	113ae <__s2b+0x6e>
   113c2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   113c6:	adds	r4, #10
   113c8:	mov.w	r8, #9
   113cc:	b.n	113a4 <__s2b+0x64>
   113ce:	movs	r1, #0
   113d0:	b.n	11370 <__s2b+0x30>
   113d2:	nop
   113d4:	.word	0x38e38e39

000113d8 <__hi0bits>:
   113d8:	lsrs	r3, r0, #16
   113da:	lsls	r3, r3, #16
   113dc:	cbnz	r3, 1140c <__hi0bits+0x34>
   113de:	lsls	r0, r0, #16
   113e0:	movs	r3, #16
   113e2:	tst.w	r0, #4278190080	; 0xff000000
   113e6:	itt	eq
   113e8:	lsleq	r0, r0, #8
   113ea:	addeq	r3, #8
   113ec:	tst.w	r0, #4026531840	; 0xf0000000
   113f0:	itt	eq
   113f2:	lsleq	r0, r0, #4
   113f4:	addeq	r3, #4
   113f6:	tst.w	r0, #3221225472	; 0xc0000000
   113fa:	itt	eq
   113fc:	lsleq	r0, r0, #2
   113fe:	addeq	r3, #2
   11400:	cmp	r0, #0
   11402:	blt.n	11414 <__hi0bits+0x3c>
   11404:	lsls	r2, r0, #1
   11406:	bmi.n	11410 <__hi0bits+0x38>
   11408:	movs	r0, #32
   1140a:	bx	lr
   1140c:	movs	r3, #0
   1140e:	b.n	113e2 <__hi0bits+0xa>
   11410:	adds	r0, r3, #1
   11412:	bx	lr
   11414:	mov	r0, r3
   11416:	bx	lr

00011418 <__lo0bits>:
   11418:	ldr	r3, [r0, #0]
   1141a:	ands.w	r2, r3, #7
   1141e:	beq.n	11430 <__lo0bits+0x18>
   11420:	lsls	r1, r3, #31
   11422:	bmi.n	11466 <__lo0bits+0x4e>
   11424:	lsls	r2, r3, #30
   11426:	bmi.n	1146a <__lo0bits+0x52>
   11428:	lsrs	r3, r3, #2
   1142a:	str	r3, [r0, #0]
   1142c:	movs	r0, #2
   1142e:	bx	lr
   11430:	uxth	r1, r3
   11432:	cbnz	r1, 11438 <__lo0bits+0x20>
   11434:	lsrs	r3, r3, #16
   11436:	movs	r2, #16
   11438:	tst.w	r3, #255	; 0xff
   1143c:	itt	eq
   1143e:	lsreq	r3, r3, #8
   11440:	addeq	r2, #8
   11442:	lsls	r1, r3, #28
   11444:	itt	eq
   11446:	lsreq	r3, r3, #4
   11448:	addeq	r2, #4
   1144a:	lsls	r1, r3, #30
   1144c:	itt	eq
   1144e:	lsreq	r3, r3, #2
   11450:	addeq	r2, #2
   11452:	lsls	r1, r3, #31
   11454:	bmi.n	11460 <__lo0bits+0x48>
   11456:	lsrs	r3, r3, #1
   11458:	bne.n	1145e <__lo0bits+0x46>
   1145a:	movs	r0, #32
   1145c:	bx	lr
   1145e:	adds	r2, #1
   11460:	str	r3, [r0, #0]
   11462:	mov	r0, r2
   11464:	bx	lr
   11466:	movs	r0, #0
   11468:	bx	lr
   1146a:	lsrs	r3, r3, #1
   1146c:	str	r3, [r0, #0]
   1146e:	movs	r0, #1
   11470:	bx	lr
   11472:	nop

00011474 <__i2b>:
   11474:	push	{r4, lr}
   11476:	mov	r4, r1
   11478:	movs	r1, #1
   1147a:	bl	11260 <_Balloc>
   1147e:	movs	r2, #1
   11480:	str	r4, [r0, #20]
   11482:	str	r2, [r0, #16]
   11484:	pop	{r4, pc}
   11486:	nop

00011488 <__multiply>:
   11488:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1148c:	ldr	r5, [r1, #16]
   1148e:	ldr	r7, [r2, #16]
   11490:	cmp	r5, r7
   11492:	sub	sp, #12
   11494:	mov	r4, r1
   11496:	mov	r6, r2
   11498:	bge.n	114a4 <__multiply+0x1c>
   1149a:	mov	r2, r5
   1149c:	mov	r4, r6
   1149e:	mov	r5, r7
   114a0:	mov	r6, r1
   114a2:	mov	r7, r2
   114a4:	ldr	r3, [r4, #8]
   114a6:	ldr	r1, [r4, #4]
   114a8:	add.w	r8, r5, r7
   114ac:	cmp	r8, r3
   114ae:	it	gt
   114b0:	addgt	r1, #1
   114b2:	bl	11260 <_Balloc>
   114b6:	add.w	ip, r0, #20
   114ba:	add.w	r9, ip, r8, lsl #2
   114be:	cmp	ip, r9
   114c0:	str	r0, [sp, #0]
   114c2:	bcs.n	114d0 <__multiply+0x48>
   114c4:	mov	r3, ip
   114c6:	movs	r1, #0
   114c8:	str.w	r1, [r3], #4
   114cc:	cmp	r9, r3
   114ce:	bhi.n	114c8 <__multiply+0x40>
   114d0:	add.w	r2, r6, #20
   114d4:	add.w	sl, r2, r7, lsl #2
   114d8:	add.w	r3, r4, #20
   114dc:	cmp	r2, sl
   114de:	add.w	lr, r3, r5, lsl #2
   114e2:	bcs.n	1158e <__multiply+0x106>
   114e4:	str.w	r9, [sp, #4]
   114e8:	mov	r9, r3
   114ea:	ldr.w	r3, [r2], #4
   114ee:	uxth.w	fp, r3
   114f2:	cmp.w	fp, #0
   114f6:	beq.n	1153a <__multiply+0xb2>
   114f8:	movs	r0, #0
   114fa:	mov	r7, r9
   114fc:	mov	r6, ip
   114fe:	mov	r5, r0
   11500:	b.n	11504 <__multiply+0x7c>
   11502:	mov	r6, r3
   11504:	ldr.w	r4, [r7], #4
   11508:	ldr	r0, [r6, #0]
   1150a:	uxth	r1, r4
   1150c:	uxth	r3, r0
   1150e:	mla	r1, fp, r1, r3
   11512:	lsrs	r4, r4, #16
   11514:	lsrs	r0, r0, #16
   11516:	adds	r3, r1, r5
   11518:	mla	r0, fp, r4, r0
   1151c:	add.w	r0, r0, r3, lsr #16
   11520:	uxth	r1, r3
   11522:	mov	r3, r6
   11524:	orr.w	r1, r1, r0, lsl #16
   11528:	cmp	lr, r7
   1152a:	mov.w	r5, r0, lsr #16
   1152e:	str.w	r1, [r3], #4
   11532:	bhi.n	11502 <__multiply+0x7a>
   11534:	str	r5, [r6, #4]
   11536:	ldr.w	r3, [r2, #-4]
   1153a:	movs.w	fp, r3, lsr #16
   1153e:	beq.n	11582 <__multiply+0xfa>
   11540:	ldr.w	r3, [ip]
   11544:	mov	r7, ip
   11546:	mov	r0, r3
   11548:	mov	r5, r9
   1154a:	movs	r1, #0
   1154c:	b.n	11550 <__multiply+0xc8>
   1154e:	mov	r7, r6
   11550:	ldrh	r4, [r5, #0]
   11552:	lsrs	r0, r0, #16
   11554:	mla	r0, fp, r4, r0
   11558:	add	r1, r0
   1155a:	uxth	r4, r3
   1155c:	mov	r6, r7
   1155e:	orr.w	r3, r4, r1, lsl #16
   11562:	str.w	r3, [r6], #4
   11566:	ldr	r0, [r7, #4]
   11568:	ldr.w	r4, [r5], #4
   1156c:	uxth	r3, r0
   1156e:	lsrs	r4, r4, #16
   11570:	mla	r4, fp, r4, r3
   11574:	add.w	r3, r4, r1, lsr #16
   11578:	cmp	lr, r5
   1157a:	mov.w	r1, r3, lsr #16
   1157e:	bhi.n	1154e <__multiply+0xc6>
   11580:	str	r3, [r7, #4]
   11582:	cmp	sl, r2
   11584:	add.w	ip, ip, #4
   11588:	bhi.n	114ea <__multiply+0x62>
   1158a:	ldr.w	r9, [sp, #4]
   1158e:	cmp.w	r8, #0
   11592:	ble.n	115ac <__multiply+0x124>
   11594:	ldr.w	r3, [r9, #-4]
   11598:	sub.w	r9, r9, #4
   1159c:	cbz	r3, 115a6 <__multiply+0x11e>
   1159e:	b.n	115ac <__multiply+0x124>
   115a0:	ldr.w	r3, [r9, #-4]!
   115a4:	cbnz	r3, 115ac <__multiply+0x124>
   115a6:	subs.w	r8, r8, #1
   115aa:	bne.n	115a0 <__multiply+0x118>
   115ac:	ldr	r0, [sp, #0]
   115ae:	str.w	r8, [r0, #16]
   115b2:	add	sp, #12
   115b4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000115b8 <__pow5mult>:
   115b8:	ands.w	r3, r2, #3
   115bc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   115c0:	mov	r4, r2
   115c2:	mov	r7, r0
   115c4:	bne.n	11624 <__pow5mult+0x6c>
   115c6:	mov	r6, r1
   115c8:	asrs	r4, r4, #2
   115ca:	beq.n	11606 <__pow5mult+0x4e>
   115cc:	ldr	r5, [r7, #72]	; 0x48
   115ce:	cbz	r5, 11636 <__pow5mult+0x7e>
   115d0:	lsls	r3, r4, #31
   115d2:	mov.w	r8, #0
   115d6:	bmi.n	115e6 <__pow5mult+0x2e>
   115d8:	asrs	r4, r4, #1
   115da:	beq.n	11606 <__pow5mult+0x4e>
   115dc:	ldr	r0, [r5, #0]
   115de:	cbz	r0, 1160c <__pow5mult+0x54>
   115e0:	mov	r5, r0
   115e2:	lsls	r3, r4, #31
   115e4:	bpl.n	115d8 <__pow5mult+0x20>
   115e6:	mov	r2, r5
   115e8:	mov	r1, r6
   115ea:	mov	r0, r7
   115ec:	bl	11488 <__multiply>
   115f0:	cbz	r6, 11620 <__pow5mult+0x68>
   115f2:	ldr	r2, [r6, #4]
   115f4:	ldr	r3, [r7, #76]	; 0x4c
   115f6:	asrs	r4, r4, #1
   115f8:	ldr.w	r1, [r3, r2, lsl #2]
   115fc:	str	r1, [r6, #0]
   115fe:	str.w	r6, [r3, r2, lsl #2]
   11602:	mov	r6, r0
   11604:	bne.n	115dc <__pow5mult+0x24>
   11606:	mov	r0, r6
   11608:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1160c:	mov	r2, r5
   1160e:	mov	r1, r5
   11610:	mov	r0, r7
   11612:	bl	11488 <__multiply>
   11616:	str	r0, [r5, #0]
   11618:	str.w	r8, [r0]
   1161c:	mov	r5, r0
   1161e:	b.n	115e2 <__pow5mult+0x2a>
   11620:	mov	r6, r0
   11622:	b.n	115d8 <__pow5mult+0x20>
   11624:	subs	r2, r3, #1
   11626:	ldr	r5, [pc, #44]	; (11654 <__pow5mult+0x9c>)
   11628:	movs	r3, #0
   1162a:	ldr.w	r2, [r5, r2, lsl #2]
   1162e:	bl	112c0 <__multadd>
   11632:	mov	r6, r0
   11634:	b.n	115c8 <__pow5mult+0x10>
   11636:	movs	r1, #1
   11638:	mov	r0, r7
   1163a:	bl	11260 <_Balloc>
   1163e:	movw	r1, #625	; 0x271
   11642:	movs	r2, #1
   11644:	movs	r3, #0
   11646:	str	r1, [r0, #20]
   11648:	str	r2, [r0, #16]
   1164a:	mov	r5, r0
   1164c:	str	r0, [r7, #72]	; 0x48
   1164e:	str	r3, [r0, #0]
   11650:	b.n	115d0 <__pow5mult+0x18>
   11652:	nop
   11654:	.word	0x00013518

00011658 <__lshift>:
   11658:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1165c:	mov	r9, r2
   1165e:	ldr	r2, [r1, #16]
   11660:	ldr	r3, [r1, #8]
   11662:	mov.w	r4, r9, asr #5
   11666:	add.w	r8, r4, r2
   1166a:	add.w	r5, r8, #1
   1166e:	cmp	r5, r3
   11670:	mov	r6, r1
   11672:	mov	sl, r0
   11674:	ldr	r1, [r1, #4]
   11676:	ble.n	11682 <__lshift+0x2a>
   11678:	lsls	r3, r3, #1
   1167a:	cmp	r5, r3
   1167c:	add.w	r1, r1, #1
   11680:	bgt.n	11678 <__lshift+0x20>
   11682:	mov	r0, sl
   11684:	bl	11260 <_Balloc>
   11688:	cmp	r4, #0
   1168a:	add.w	r2, r0, #20
   1168e:	ble.n	11702 <__lshift+0xaa>
   11690:	add.w	r3, r2, r4, lsl #2
   11694:	movs	r1, #0
   11696:	str.w	r1, [r2], #4
   1169a:	cmp	r3, r2
   1169c:	bne.n	11696 <__lshift+0x3e>
   1169e:	ldr	r4, [r6, #16]
   116a0:	add.w	r1, r6, #20
   116a4:	ands.w	r9, r9, #31
   116a8:	add.w	lr, r1, r4, lsl #2
   116ac:	beq.n	116f2 <__lshift+0x9a>
   116ae:	rsb	r2, r9, #32
   116b2:	movs	r4, #0
   116b4:	ldr	r7, [r1, #0]
   116b6:	lsl.w	ip, r7, r9
   116ba:	orr.w	r4, ip, r4
   116be:	mov	ip, r3
   116c0:	str.w	r4, [r3], #4
   116c4:	ldr.w	r4, [r1], #4
   116c8:	cmp	lr, r1
   116ca:	lsr.w	r4, r4, r2
   116ce:	bhi.n	116b4 <__lshift+0x5c>
   116d0:	str.w	r4, [ip, #4]
   116d4:	cbz	r4, 116da <__lshift+0x82>
   116d6:	add.w	r5, r8, #2
   116da:	ldr.w	r3, [sl, #76]	; 0x4c
   116de:	ldr	r2, [r6, #4]
   116e0:	subs	r5, #1
   116e2:	ldr.w	r1, [r3, r2, lsl #2]
   116e6:	str	r5, [r0, #16]
   116e8:	str	r1, [r6, #0]
   116ea:	str.w	r6, [r3, r2, lsl #2]
   116ee:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   116f2:	subs	r3, #4
   116f4:	ldr.w	r2, [r1], #4
   116f8:	str.w	r2, [r3, #4]!
   116fc:	cmp	lr, r1
   116fe:	bhi.n	116f4 <__lshift+0x9c>
   11700:	b.n	116da <__lshift+0x82>
   11702:	mov	r3, r2
   11704:	b.n	1169e <__lshift+0x46>
   11706:	nop

00011708 <__mcmp>:
   11708:	ldr	r2, [r0, #16]
   1170a:	ldr	r3, [r1, #16]
   1170c:	subs	r2, r2, r3
   1170e:	bne.n	11738 <__mcmp+0x30>
   11710:	lsls	r3, r3, #2
   11712:	adds	r0, #20
   11714:	adds	r1, #20
   11716:	add	r1, r3
   11718:	push	{r4}
   1171a:	add	r3, r0
   1171c:	b.n	11722 <__mcmp+0x1a>
   1171e:	cmp	r0, r3
   11720:	bcs.n	1173c <__mcmp+0x34>
   11722:	ldr.w	r4, [r3, #-4]!
   11726:	ldr.w	r2, [r1, #-4]!
   1172a:	cmp	r4, r2
   1172c:	beq.n	1171e <__mcmp+0x16>
   1172e:	bcc.n	11744 <__mcmp+0x3c>
   11730:	movs	r0, #1
   11732:	ldr.w	r4, [sp], #4
   11736:	bx	lr
   11738:	mov	r0, r2
   1173a:	bx	lr
   1173c:	movs	r0, #0
   1173e:	ldr.w	r4, [sp], #4
   11742:	bx	lr
   11744:	mov.w	r0, #4294967295
   11748:	b.n	11732 <__mcmp+0x2a>
   1174a:	nop

0001174c <__mdiff>:
   1174c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   11750:	ldr	r3, [r1, #16]
   11752:	mov	r7, r1
   11754:	ldr	r1, [r2, #16]
   11756:	subs	r3, r3, r1
   11758:	cmp	r3, #0
   1175a:	mov	r8, r2
   1175c:	bne.n	1178e <__mdiff+0x42>
   1175e:	lsls	r1, r1, #2
   11760:	add.w	r2, r7, #20
   11764:	add.w	r5, r8, #20
   11768:	adds	r3, r2, r1
   1176a:	add	r1, r5
   1176c:	b.n	11772 <__mdiff+0x26>
   1176e:	cmp	r2, r3
   11770:	bcs.n	11830 <__mdiff+0xe4>
   11772:	ldr.w	r6, [r3, #-4]!
   11776:	ldr.w	r4, [r1, #-4]!
   1177a:	cmp	r6, r4
   1177c:	beq.n	1176e <__mdiff+0x22>
   1177e:	bcs.n	11842 <__mdiff+0xf6>
   11780:	mov	r3, r7
   11782:	mov	r4, r2
   11784:	mov	r7, r8
   11786:	mov.w	r9, #1
   1178a:	mov	r8, r3
   1178c:	b.n	1179c <__mdiff+0x50>
   1178e:	blt.n	1184c <__mdiff+0x100>
   11790:	add.w	r5, r7, #20
   11794:	add.w	r4, r2, #20
   11798:	mov.w	r9, #0
   1179c:	ldr	r1, [r7, #4]
   1179e:	bl	11260 <_Balloc>
   117a2:	ldr.w	r3, [r8, #16]
   117a6:	ldr	r6, [r7, #16]
   117a8:	str.w	r9, [r0, #12]
   117ac:	add.w	ip, r4, r3, lsl #2
   117b0:	mov	lr, r4
   117b2:	add.w	r7, r5, r6, lsl #2
   117b6:	add.w	r4, r0, #20
   117ba:	movs	r3, #0
   117bc:	ldr.w	r1, [lr], #4
   117c0:	ldr.w	r8, [r5], #4
   117c4:	uxth	r2, r1
   117c6:	uxtah	r3, r3, r8
   117ca:	lsrs	r1, r1, #16
   117cc:	subs	r2, r3, r2
   117ce:	rsb	r3, r1, r8, lsr #16
   117d2:	add.w	r3, r3, r2, asr #16
   117d6:	uxth	r2, r2
   117d8:	orr.w	r2, r2, r3, lsl #16
   117dc:	cmp	ip, lr
   117de:	str.w	r2, [r4], #4
   117e2:	mov.w	r3, r3, asr #16
   117e6:	bhi.n	117bc <__mdiff+0x70>
   117e8:	cmp	r7, r5
   117ea:	bls.n	1181c <__mdiff+0xd0>
   117ec:	mov	ip, r4
   117ee:	mov	r1, r5
   117f0:	ldr.w	lr, [r1], #4
   117f4:	uxtah	r2, r3, lr
   117f8:	asrs	r3, r2, #16
   117fa:	add.w	r3, r3, lr, lsr #16
   117fe:	uxth	r2, r2
   11800:	orr.w	r2, r2, r3, lsl #16
   11804:	cmp	r7, r1
   11806:	str.w	r2, [ip], #4
   1180a:	mov.w	r3, r3, asr #16
   1180e:	bhi.n	117f0 <__mdiff+0xa4>
   11810:	mvns	r5, r5
   11812:	add	r5, r7
   11814:	bic.w	r5, r5, #3
   11818:	adds	r5, #4
   1181a:	add	r4, r5
   1181c:	subs	r4, #4
   1181e:	cbnz	r2, 1182a <__mdiff+0xde>
   11820:	ldr.w	r3, [r4, #-4]!
   11824:	subs	r6, #1
   11826:	cmp	r3, #0
   11828:	beq.n	11820 <__mdiff+0xd4>
   1182a:	str	r6, [r0, #16]
   1182c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   11830:	movs	r1, #0
   11832:	bl	11260 <_Balloc>
   11836:	movs	r2, #1
   11838:	movs	r3, #0
   1183a:	str	r2, [r0, #16]
   1183c:	str	r3, [r0, #20]
   1183e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   11842:	mov	r4, r5
   11844:	mov.w	r9, #0
   11848:	mov	r5, r2
   1184a:	b.n	1179c <__mdiff+0x50>
   1184c:	mov	r3, r7
   1184e:	add.w	r4, r7, #20
   11852:	add.w	r5, r8, #20
   11856:	mov	r7, r8
   11858:	mov.w	r9, #1
   1185c:	mov	r8, r3
   1185e:	b.n	1179c <__mdiff+0x50>

00011860 <__ulp>:
   11860:	ldr	r3, [pc, #76]	; (118b0 <__ulp+0x50>)
   11862:	vmov	r2, s1
   11866:	ands	r2, r3
   11868:	sub.w	r3, r2, #54525952	; 0x3400000
   1186c:	cmp	r3, #0
   1186e:	ble.n	1187a <__ulp+0x1a>
   11870:	movs	r0, #0
   11872:	mov	r1, r3
   11874:	vmov	d0, r0, r1
   11878:	bx	lr
   1187a:	negs	r3, r3
   1187c:	asrs	r3, r3, #20
   1187e:	cmp	r3, #19
   11880:	ble.n	1189e <__ulp+0x3e>
   11882:	subs	r3, #20
   11884:	cmp	r3, #30
   11886:	ittte	le
   11888:	rsble	r3, r3, #31
   1188c:	movle	r2, #1
   1188e:	lslle.w	r3, r2, r3
   11892:	movgt	r3, #1
   11894:	movs	r1, #0
   11896:	mov	r0, r3
   11898:	vmov	d0, r0, r1
   1189c:	bx	lr
   1189e:	mov.w	r2, #524288	; 0x80000
   118a2:	movs	r0, #0
   118a4:	asr.w	r1, r2, r3
   118a8:	vmov	d0, r0, r1
   118ac:	bx	lr
   118ae:	nop
   118b0:	.word	0x7ff00000

000118b4 <__b2d>:
   118b4:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   118b8:	ldr	r6, [r0, #16]
   118ba:	add.w	r8, r0, #20
   118be:	add.w	r6, r8, r6, lsl #2
   118c2:	ldr.w	r7, [r6, #-4]
   118c6:	mov	r0, r7
   118c8:	bl	113d8 <__hi0bits>
   118cc:	rsb	r3, r0, #32
   118d0:	cmp	r0, #10
   118d2:	str	r3, [r1, #0]
   118d4:	sub.w	r3, r6, #4
   118d8:	bgt.n	1190c <__b2d+0x58>
   118da:	cmp	r8, r3
   118dc:	rsb	r2, r0, #11
   118e0:	it	cc
   118e2:	ldrcc.w	r3, [r6, #-8]
   118e6:	lsr.w	r1, r7, r2
   118ea:	add.w	r0, r0, #21
   118ee:	orr.w	r5, r1, #1069547520	; 0x3fc00000
   118f2:	ite	cc
   118f4:	lsrcc	r3, r2
   118f6:	movcs	r3, #0
   118f8:	lsl.w	r0, r7, r0
   118fc:	orr.w	r5, r5, #3145728	; 0x300000
   11900:	orr.w	r4, r0, r3
   11904:	vmov	d0, r4, r5
   11908:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1190c:	cmp	r8, r3
   1190e:	bcs.n	11952 <__b2d+0x9e>
   11910:	subs.w	r3, r0, #11
   11914:	ldr.w	r2, [r6, #-8]
   11918:	beq.n	11958 <__b2d+0xa4>
   1191a:	lsl.w	r0, r7, r3
   1191e:	orr.w	r7, r0, #1069547520	; 0x3fc00000
   11922:	rsb	lr, r3, #32
   11926:	sub.w	r1, r6, #8
   1192a:	orr.w	r7, r7, #3145728	; 0x300000
   1192e:	lsr.w	r0, r2, lr
   11932:	cmp	r8, r1
   11934:	orr.w	r5, r7, r0
   11938:	bcs.n	1197c <__b2d+0xc8>
   1193a:	ldr.w	r1, [r6, #-12]
   1193e:	lsl.w	r0, r2, r3
   11942:	lsr.w	r3, r1, lr
   11946:	orrs	r0, r3
   11948:	mov	r4, r0
   1194a:	vmov	d0, r4, r5
   1194e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11952:	subs	r0, #11
   11954:	bne.n	1196a <__b2d+0xb6>
   11956:	mov	r2, r0
   11958:	orr.w	r5, r7, #1069547520	; 0x3fc00000
   1195c:	orr.w	r5, r5, #3145728	; 0x300000
   11960:	mov	r4, r2
   11962:	vmov	d0, r4, r5
   11966:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1196a:	lsl.w	r0, r7, r0
   1196e:	orr.w	r5, r0, #1069547520	; 0x3fc00000
   11972:	movs	r0, #0
   11974:	orr.w	r5, r5, #3145728	; 0x300000
   11978:	mov	r4, r0
   1197a:	b.n	1194a <__b2d+0x96>
   1197c:	lsl.w	r0, r2, r3
   11980:	mov	r4, r0
   11982:	b.n	1194a <__b2d+0x96>

00011984 <__d2b>:
   11984:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11988:	vmov	r6, r7, d0
   1198c:	sub	sp, #12
   1198e:	mov	r8, r1
   11990:	movs	r1, #1
   11992:	mov	r4, r7
   11994:	ubfx	r5, r7, #20, #11
   11998:	mov	r7, r2
   1199a:	bl	11260 <_Balloc>
   1199e:	ubfx	r4, r4, #0, #20
   119a2:	mov	r9, r0
   119a4:	cbz	r5, 119aa <__d2b+0x26>
   119a6:	orr.w	r4, r4, #1048576	; 0x100000
   119aa:	str	r4, [sp, #4]
   119ac:	cbz	r6, 119f6 <__d2b+0x72>
   119ae:	add	r0, sp, #8
   119b0:	str.w	r6, [r0, #-8]!
   119b4:	bl	11418 <__lo0bits>
   119b8:	cmp	r0, #0
   119ba:	bne.n	11a26 <__d2b+0xa2>
   119bc:	ldmia.w	sp, {r2, r3}
   119c0:	str.w	r2, [r9, #20]
   119c4:	cmp	r3, #0
   119c6:	ite	eq
   119c8:	moveq	r1, #1
   119ca:	movne	r1, #2
   119cc:	str.w	r3, [r9, #24]
   119d0:	str.w	r1, [r9, #16]
   119d4:	cbnz	r5, 11a0e <__d2b+0x8a>
   119d6:	add.w	r3, r9, r1, lsl #2
   119da:	subw	r0, r0, #1074	; 0x432
   119de:	str.w	r0, [r8]
   119e2:	ldr	r0, [r3, #16]
   119e4:	bl	113d8 <__hi0bits>
   119e8:	rsb	r0, r0, r1, lsl #5
   119ec:	str	r0, [r7, #0]
   119ee:	mov	r0, r9
   119f0:	add	sp, #12
   119f2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   119f6:	add	r0, sp, #4
   119f8:	bl	11418 <__lo0bits>
   119fc:	ldr	r3, [sp, #4]
   119fe:	str.w	r3, [r9, #20]
   11a02:	movs	r1, #1
   11a04:	adds	r0, #32
   11a06:	str.w	r1, [r9, #16]
   11a0a:	cmp	r5, #0
   11a0c:	beq.n	119d6 <__d2b+0x52>
   11a0e:	subw	r5, r5, #1075	; 0x433
   11a12:	add	r5, r0
   11a14:	rsb	r0, r0, #53	; 0x35
   11a18:	str.w	r5, [r8]
   11a1c:	str	r0, [r7, #0]
   11a1e:	mov	r0, r9
   11a20:	add	sp, #12
   11a22:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   11a26:	ldmia.w	sp, {r2, r3}
   11a2a:	rsb	r1, r0, #32
   11a2e:	lsl.w	r1, r3, r1
   11a32:	orrs	r2, r1
   11a34:	lsrs	r3, r0
   11a36:	str	r3, [sp, #4]
   11a38:	str.w	r2, [r9, #20]
   11a3c:	b.n	119c4 <__d2b+0x40>
   11a3e:	nop

00011a40 <__ratio>:
   11a40:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11a44:	sub	sp, #12
   11a46:	mov	r8, r1
   11a48:	mov	r1, sp
   11a4a:	mov	r9, r0
   11a4c:	bl	118b4 <__b2d>
   11a50:	mov	r0, r8
   11a52:	add	r1, sp, #4
   11a54:	vmov	r4, r5, d0
   11a58:	bl	118b4 <__b2d>
   11a5c:	ldmia.w	sp, {r1, r3}
   11a60:	ldr.w	r2, [r9, #16]
   11a64:	ldr.w	r0, [r8, #16]
   11a68:	subs	r1, r1, r3
   11a6a:	subs	r0, r2, r0
   11a6c:	add.w	r3, r1, r0, lsl #5
   11a70:	cmp	r3, #0
   11a72:	vmov	r6, r7, d0
   11a76:	ble.n	11a94 <__ratio+0x54>
   11a78:	add.w	r1, r5, r3, lsl #20
   11a7c:	mov	r5, r1
   11a7e:	mov	r2, r6
   11a80:	mov	r3, r7
   11a82:	mov	r0, r4
   11a84:	mov	r1, r5
   11a86:	bl	ab0c <__aeabi_ddiv>
   11a8a:	vmov	d0, r0, r1
   11a8e:	add	sp, #12
   11a90:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   11a94:	sub.w	r9, r7, r3, lsl #20
   11a98:	vmov	r6, s0
   11a9c:	mov	r7, r9
   11a9e:	b.n	11a7e <__ratio+0x3e>

00011aa0 <__copybits>:
   11aa0:	push	{r4, r5, r6}
   11aa2:	ldr	r4, [r2, #16]
   11aa4:	add.w	r3, r2, #20
   11aa8:	subs	r1, #1
   11aaa:	asrs	r6, r1, #5
   11aac:	add.w	r4, r3, r4, lsl #2
   11ab0:	adds	r6, #1
   11ab2:	cmp	r3, r4
   11ab4:	add.w	r6, r0, r6, lsl #2
   11ab8:	bcs.n	11ad4 <__copybits+0x34>
   11aba:	subs	r1, r0, #4
   11abc:	ldr.w	r5, [r3], #4
   11ac0:	str.w	r5, [r1, #4]!
   11ac4:	cmp	r4, r3
   11ac6:	bhi.n	11abc <__copybits+0x1c>
   11ac8:	subs	r3, r4, r2
   11aca:	subs	r3, #21
   11acc:	bic.w	r3, r3, #3
   11ad0:	adds	r3, #4
   11ad2:	add	r0, r3
   11ad4:	cmp	r6, r0
   11ad6:	bls.n	11ae2 <__copybits+0x42>
   11ad8:	movs	r3, #0
   11ada:	str.w	r3, [r0], #4
   11ade:	cmp	r6, r0
   11ae0:	bhi.n	11ada <__copybits+0x3a>
   11ae2:	pop	{r4, r5, r6}
   11ae4:	bx	lr
   11ae6:	nop

00011ae8 <__any_on>:
   11ae8:	ldr	r3, [r0, #16]
   11aea:	asrs	r2, r1, #5
   11aec:	cmp	r3, r2
   11aee:	push	{r4}
   11af0:	add.w	r4, r0, #20
   11af4:	bge.n	11b18 <__any_on+0x30>
   11af6:	add.w	r3, r4, r3, lsl #2
   11afa:	cmp	r4, r3
   11afc:	bcs.n	11b42 <__any_on+0x5a>
   11afe:	ldr.w	r0, [r3, #-4]
   11b02:	subs	r3, #4
   11b04:	cbz	r0, 11b0e <__any_on+0x26>
   11b06:	b.n	11b34 <__any_on+0x4c>
   11b08:	ldr.w	r2, [r3, #-4]!
   11b0c:	cbnz	r2, 11b34 <__any_on+0x4c>
   11b0e:	cmp	r4, r3
   11b10:	bcc.n	11b08 <__any_on+0x20>
   11b12:	ldr.w	r4, [sp], #4
   11b16:	bx	lr
   11b18:	ble.n	11b3c <__any_on+0x54>
   11b1a:	ands.w	r1, r1, #31
   11b1e:	beq.n	11b3c <__any_on+0x54>
   11b20:	ldr.w	r0, [r4, r2, lsl #2]
   11b24:	lsr.w	r3, r0, r1
   11b28:	lsl.w	r1, r3, r1
   11b2c:	cmp	r0, r1
   11b2e:	add.w	r3, r4, r2, lsl #2
   11b32:	beq.n	11afa <__any_on+0x12>
   11b34:	movs	r0, #1
   11b36:	ldr.w	r4, [sp], #4
   11b3a:	bx	lr
   11b3c:	add.w	r3, r4, r2, lsl #2
   11b40:	b.n	11afa <__any_on+0x12>
   11b42:	movs	r0, #0
   11b44:	b.n	11b12 <__any_on+0x2a>
   11b46:	nop

00011b48 <__sccl>:
   11b48:	push	{r4, r5, r6}
   11b4a:	ldrb	r5, [r1, #0]
   11b4c:	cmp	r5, #94	; 0x5e
   11b4e:	beq.n	11bb0 <__sccl+0x68>
   11b50:	movs	r2, #0
   11b52:	adds	r1, #1
   11b54:	mov	r6, r2
   11b56:	subs	r3, r0, #1
   11b58:	add.w	r4, r0, #255	; 0xff
   11b5c:	strb.w	r2, [r3, #1]!
   11b60:	cmp	r3, r4
   11b62:	bne.n	11b5c <__sccl+0x14>
   11b64:	cbz	r5, 11b88 <__sccl+0x40>
   11b66:	eor.w	r2, r6, #1
   11b6a:	strb	r2, [r0, r5]
   11b6c:	adds	r4, r1, #1
   11b6e:	ldrb.w	r3, [r4, #-1]
   11b72:	cmp	r3, #45	; 0x2d
   11b74:	beq.n	11b94 <__sccl+0x4c>
   11b76:	cmp	r3, #93	; 0x5d
   11b78:	beq.n	11b8e <__sccl+0x46>
   11b7a:	cbz	r3, 11b82 <__sccl+0x3a>
   11b7c:	mov	r5, r3
   11b7e:	mov	r1, r4
   11b80:	b.n	11b6a <__sccl+0x22>
   11b82:	mov	r0, r1
   11b84:	pop	{r4, r5, r6}
   11b86:	bx	lr
   11b88:	subs	r0, r1, #1
   11b8a:	pop	{r4, r5, r6}
   11b8c:	bx	lr
   11b8e:	mov	r0, r4
   11b90:	pop	{r4, r5, r6}
   11b92:	bx	lr
   11b94:	ldrb	r6, [r1, #1]
   11b96:	cmp	r6, #93	; 0x5d
   11b98:	beq.n	11b7c <__sccl+0x34>
   11b9a:	cmp	r5, r6
   11b9c:	bgt.n	11b7c <__sccl+0x34>
   11b9e:	adds	r1, #2
   11ba0:	adds	r3, r0, r5
   11ba2:	adds	r5, #1
   11ba4:	cmp	r6, r5
   11ba6:	strb.w	r2, [r3, #1]!
   11baa:	bgt.n	11ba2 <__sccl+0x5a>
   11bac:	adds	r4, #2
   11bae:	b.n	11b6e <__sccl+0x26>
   11bb0:	movs	r2, #1
   11bb2:	ldrb	r5, [r1, #1]
   11bb4:	mov	r6, r2
   11bb6:	adds	r1, #2
   11bb8:	b.n	11b56 <__sccl+0xe>
   11bba:	nop

00011bbc <nanf>:
   11bbc:	vldr	s0, [pc, #4]	; 11bc4 <nanf+0x8>
   11bc0:	bx	lr
   11bc2:	nop
   11bc4:	.word	0x7fc00000

00011bc8 <_strtoll_l.isra.0>:
   11bc8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11bcc:	sub	sp, #20
   11bce:	mov	sl, r3
   11bd0:	str	r1, [sp, #8]
   11bd2:	str	r0, [sp, #12]
   11bd4:	str	r2, [sp, #4]
   11bd6:	mov	r7, r1
   11bd8:	ldr	r6, [sp, #56]	; 0x38
   11bda:	b.n	11bde <_strtoll_l.isra.0+0x16>
   11bdc:	mov	r7, r5
   11bde:	mov	r5, r7
   11be0:	mov	r0, r6
   11be2:	ldrb.w	r4, [r5], #1
   11be6:	bl	b2fc <__locale_ctype_ptr_l>
   11bea:	add	r0, r4
   11bec:	ldrb	r3, [r0, #1]
   11bee:	and.w	r3, r3, #8
   11bf2:	and.w	r2, r3, #255	; 0xff
   11bf6:	cmp	r3, #0
   11bf8:	bne.n	11bdc <_strtoll_l.isra.0+0x14>
   11bfa:	cmp	r4, #45	; 0x2d
   11bfc:	beq.w	11d06 <_strtoll_l.isra.0+0x13e>
   11c00:	cmp	r4, #43	; 0x2b
   11c02:	it	eq
   11c04:	ldrbeq	r4, [r7, #1]
   11c06:	str	r2, [sp, #0]
   11c08:	it	eq
   11c0a:	addeq	r5, r7, #2
   11c0c:	cmp.w	sl, #0
   11c10:	beq.n	11c2c <_strtoll_l.isra.0+0x64>
   11c12:	cmp.w	sl, #16
   11c16:	beq.w	11d44 <_strtoll_l.isra.0+0x17c>
   11c1a:	ldr	r3, [sp, #0]
   11c1c:	mov	r6, sl
   11c1e:	asrs	r7, r6, #31
   11c20:	cbnz	r3, 11c3e <_strtoll_l.isra.0+0x76>
   11c22:	mov.w	r8, #4294967295
   11c26:	mvn.w	r9, #2147483648	; 0x80000000
   11c2a:	b.n	11c46 <_strtoll_l.isra.0+0x7e>
   11c2c:	cmp	r4, #48	; 0x30
   11c2e:	beq.n	11d30 <_strtoll_l.isra.0+0x168>
   11c30:	movs	r6, #10
   11c32:	movs	r7, #0
   11c34:	mov.w	sl, #10
   11c38:	ldr	r3, [sp, #0]
   11c3a:	cmp	r3, #0
   11c3c:	beq.n	11c22 <_strtoll_l.isra.0+0x5a>
   11c3e:	mov.w	r8, #0
   11c42:	mov.w	r9, #2147483648	; 0x80000000
   11c46:	mov	r2, r6
   11c48:	mov	r3, r7
   11c4a:	mov	r0, r8
   11c4c:	mov	r1, r9
   11c4e:	bl	af48 <__aeabi_uldivmod>
   11c52:	mov	r3, r7
   11c54:	mov	fp, r2
   11c56:	mov	r0, r8
   11c58:	mov	r2, r6
   11c5a:	mov	r1, r9
   11c5c:	bl	af48 <__aeabi_uldivmod>
   11c60:	mov.w	lr, #0
   11c64:	movs	r2, #0
   11c66:	movs	r3, #0
   11c68:	b.n	11c8a <_strtoll_l.isra.0+0xc2>
   11c6a:	beq.n	11cf8 <_strtoll_l.isra.0+0x130>
   11c6c:	mul.w	r4, r2, r7
   11c70:	mla	r4, r6, r3, r4
   11c74:	umull	r2, r3, r2, r6
   11c78:	add	r3, r4
   11c7a:	adds.w	r2, r2, ip
   11c7e:	adc.w	r3, r3, ip, asr #31
   11c82:	mov.w	lr, #1
   11c86:	ldrb.w	r4, [r5], #1
   11c8a:	sub.w	ip, r4, #48	; 0x30
   11c8e:	cmp.w	ip, #9
   11c92:	bls.n	11ca2 <_strtoll_l.isra.0+0xda>
   11c94:	sub.w	ip, r4, #65	; 0x41
   11c98:	cmp.w	ip, #25
   11c9c:	bhi.n	11cba <_strtoll_l.isra.0+0xf2>
   11c9e:	sub.w	ip, r4, #55	; 0x37
   11ca2:	cmp	sl, ip
   11ca4:	ble.n	11ccc <_strtoll_l.isra.0+0x104>
   11ca6:	cmp.w	lr, #4294967295
   11caa:	beq.n	11c86 <_strtoll_l.isra.0+0xbe>
   11cac:	cmp	r1, r3
   11cae:	it	eq
   11cb0:	cmpeq	r0, r2
   11cb2:	bcs.n	11c6a <_strtoll_l.isra.0+0xa2>
   11cb4:	mov.w	lr, #4294967295
   11cb8:	b.n	11c86 <_strtoll_l.isra.0+0xbe>
   11cba:	sub.w	ip, r4, #97	; 0x61
   11cbe:	cmp.w	ip, #25
   11cc2:	bhi.n	11ccc <_strtoll_l.isra.0+0x104>
   11cc4:	sub.w	ip, r4, #87	; 0x57
   11cc8:	cmp	sl, ip
   11cca:	bgt.n	11ca6 <_strtoll_l.isra.0+0xde>
   11ccc:	cmp.w	lr, #4294967295
   11cd0:	beq.n	11d10 <_strtoll_l.isra.0+0x148>
   11cd2:	ldr	r1, [sp, #0]
   11cd4:	cbz	r1, 11cdc <_strtoll_l.isra.0+0x114>
   11cd6:	negs	r2, r2
   11cd8:	sbc.w	r3, r3, r3, lsl #1
   11cdc:	ldr	r1, [sp, #4]
   11cde:	cmp	r1, #0
   11ce0:	beq.n	11d68 <_strtoll_l.isra.0+0x1a0>
   11ce2:	cmp.w	lr, #0
   11ce6:	bne.n	11d28 <_strtoll_l.isra.0+0x160>
   11ce8:	ldr	r5, [sp, #8]
   11cea:	mov	r0, r2
   11cec:	mov	r1, r3
   11cee:	ldr	r3, [sp, #4]
   11cf0:	str	r5, [r3, #0]
   11cf2:	add	sp, #20
   11cf4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11cf8:	cmp	fp, ip
   11cfa:	bge.n	11c6c <_strtoll_l.isra.0+0xa4>
   11cfc:	mov	r2, r0
   11cfe:	mov	r3, r1
   11d00:	mov.w	lr, #4294967295
   11d04:	b.n	11c86 <_strtoll_l.isra.0+0xbe>
   11d06:	movs	r3, #1
   11d08:	adds	r5, r7, #2
   11d0a:	ldrb	r4, [r7, #1]
   11d0c:	str	r3, [sp, #0]
   11d0e:	b.n	11c0c <_strtoll_l.isra.0+0x44>
   11d10:	ldr	r3, [sp, #0]
   11d12:	cbnz	r3, 11d60 <_strtoll_l.isra.0+0x198>
   11d14:	mov.w	r0, #4294967295
   11d18:	mvn.w	r1, #2147483648	; 0x80000000
   11d1c:	ldr	r2, [sp, #12]
   11d1e:	movs	r3, #34	; 0x22
   11d20:	str	r3, [r2, #0]
   11d22:	ldr	r3, [sp, #4]
   11d24:	cbnz	r3, 11d2c <_strtoll_l.isra.0+0x164>
   11d26:	b.n	11cf2 <_strtoll_l.isra.0+0x12a>
   11d28:	mov	r0, r2
   11d2a:	mov	r1, r3
   11d2c:	subs	r5, #1
   11d2e:	b.n	11cee <_strtoll_l.isra.0+0x126>
   11d30:	ldrb	r3, [r5, #0]
   11d32:	and.w	r3, r3, #223	; 0xdf
   11d36:	cmp	r3, #88	; 0x58
   11d38:	beq.n	11d52 <_strtoll_l.isra.0+0x18a>
   11d3a:	movs	r6, #8
   11d3c:	movs	r7, #0
   11d3e:	mov.w	sl, #8
   11d42:	b.n	11c38 <_strtoll_l.isra.0+0x70>
   11d44:	cmp	r4, #48	; 0x30
   11d46:	bne.n	11d6e <_strtoll_l.isra.0+0x1a6>
   11d48:	ldrb	r3, [r5, #0]
   11d4a:	and.w	r3, r3, #223	; 0xdf
   11d4e:	cmp	r3, #88	; 0x58
   11d50:	bne.n	11d6e <_strtoll_l.isra.0+0x1a6>
   11d52:	ldrb	r4, [r5, #1]
   11d54:	movs	r6, #16
   11d56:	movs	r7, #0
   11d58:	adds	r5, #2
   11d5a:	mov.w	sl, #16
   11d5e:	b.n	11c38 <_strtoll_l.isra.0+0x70>
   11d60:	movs	r0, #0
   11d62:	mov.w	r1, #2147483648	; 0x80000000
   11d66:	b.n	11d1c <_strtoll_l.isra.0+0x154>
   11d68:	mov	r0, r2
   11d6a:	mov	r1, r3
   11d6c:	b.n	11cf2 <_strtoll_l.isra.0+0x12a>
   11d6e:	movs	r6, #16
   11d70:	movs	r7, #0
   11d72:	b.n	11c38 <_strtoll_l.isra.0+0x70>

00011d74 <_strtoll_r>:
   11d74:	push	{r4, r5, lr}
   11d76:	ldr	r4, [pc, #24]	; (11d90 <_strtoll_r+0x1c>)
   11d78:	ldr	r5, [pc, #24]	; (11d94 <_strtoll_r+0x20>)
   11d7a:	ldr	r4, [r4, #0]
   11d7c:	ldr	r4, [r4, #52]	; 0x34
   11d7e:	sub	sp, #12
   11d80:	cmp	r4, #0
   11d82:	it	eq
   11d84:	moveq	r4, r5
   11d86:	str	r4, [sp, #0]
   11d88:	bl	11bc8 <_strtoll_l.isra.0>
   11d8c:	add	sp, #12
   11d8e:	pop	{r4, r5, pc}
   11d90:	.word	0x1fff1828
   11d94:	.word	0x1fff182c

00011d98 <_strtoul_l.isra.0>:
   11d98:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11d9c:	ldr.w	r9, [sp, #40]	; 0x28
   11da0:	mov	r6, r1
   11da2:	mov	r7, r0
   11da4:	mov	r5, r2
   11da6:	mov	r8, r3
   11da8:	mov	fp, r1
   11daa:	b.n	11dae <_strtoul_l.isra.0+0x16>
   11dac:	mov	fp, r4
   11dae:	mov	r4, fp
   11db0:	mov	r0, r9
   11db2:	ldrb.w	sl, [r4], #1
   11db6:	bl	b2fc <__locale_ctype_ptr_l>
   11dba:	add	r0, sl
   11dbc:	ldrb	r0, [r0, #1]
   11dbe:	and.w	r0, r0, #8
   11dc2:	and.w	ip, r0, #255	; 0xff
   11dc6:	cmp	r0, #0
   11dc8:	bne.n	11dac <_strtoul_l.isra.0+0x14>
   11dca:	mov	r1, sl
   11dcc:	cmp	r1, #45	; 0x2d
   11dce:	beq.n	11e94 <_strtoul_l.isra.0+0xfc>
   11dd0:	cmp	r1, #43	; 0x2b
   11dd2:	itt	eq
   11dd4:	ldrbeq.w	r1, [fp, #1]
   11dd8:	addeq.w	r4, fp, #2
   11ddc:	cmp.w	r8, #0
   11de0:	beq.n	11dfc <_strtoul_l.isra.0+0x64>
   11de2:	cmp.w	r8, #16
   11de6:	beq.n	11ea2 <_strtoul_l.isra.0+0x10a>
   11de8:	mov.w	r3, #4294967295
   11dec:	udiv	r3, r3, r8
   11df0:	mul.w	sl, r8, r3
   11df4:	mvn.w	sl, sl
   11df8:	mov	r9, r8
   11dfa:	b.n	11e0c <_strtoul_l.isra.0+0x74>
   11dfc:	cmp	r1, #48	; 0x30
   11dfe:	beq.n	11ec4 <_strtoul_l.isra.0+0x12c>
   11e00:	mov.w	r8, #10
   11e04:	ldr	r3, [pc, #244]	; (11efc <_strtoul_l.isra.0+0x164>)
   11e06:	mov	r9, r8
   11e08:	mov.w	sl, #5
   11e0c:	mov.w	lr, #0
   11e10:	mov	r0, lr
   11e12:	b.n	11e22 <_strtoul_l.isra.0+0x8a>
   11e14:	beq.n	11e76 <_strtoul_l.isra.0+0xde>
   11e16:	mla	r0, r9, r0, r2
   11e1a:	mov.w	lr, #1
   11e1e:	ldrb.w	r1, [r4], #1
   11e22:	sub.w	r2, r1, #48	; 0x30
   11e26:	cmp	r2, #9
   11e28:	bls.n	11e36 <_strtoul_l.isra.0+0x9e>
   11e2a:	sub.w	r2, r1, #65	; 0x41
   11e2e:	cmp	r2, #25
   11e30:	bhi.n	11e4a <_strtoul_l.isra.0+0xb2>
   11e32:	sub.w	r2, r1, #55	; 0x37
   11e36:	cmp	r8, r2
   11e38:	ble.n	11e5a <_strtoul_l.isra.0+0xc2>
   11e3a:	cmp.w	lr, #4294967295
   11e3e:	beq.n	11e1e <_strtoul_l.isra.0+0x86>
   11e40:	cmp	r0, r3
   11e42:	bls.n	11e14 <_strtoul_l.isra.0+0x7c>
   11e44:	mov.w	lr, #4294967295
   11e48:	b.n	11e1e <_strtoul_l.isra.0+0x86>
   11e4a:	sub.w	r2, r1, #97	; 0x61
   11e4e:	cmp	r2, #25
   11e50:	bhi.n	11e5a <_strtoul_l.isra.0+0xc2>
   11e52:	sub.w	r2, r1, #87	; 0x57
   11e56:	cmp	r8, r2
   11e58:	bgt.n	11e3a <_strtoul_l.isra.0+0xa2>
   11e5a:	cmp.w	lr, #4294967295
   11e5e:	beq.n	11e84 <_strtoul_l.isra.0+0xec>
   11e60:	cmp.w	ip, #0
   11e64:	beq.n	11e68 <_strtoul_l.isra.0+0xd0>
   11e66:	negs	r0, r0
   11e68:	cbz	r5, 11e80 <_strtoul_l.isra.0+0xe8>
   11e6a:	cmp.w	lr, #0
   11e6e:	bne.n	11e8c <_strtoul_l.isra.0+0xf4>
   11e70:	str	r6, [r5, #0]
   11e72:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11e76:	cmp	r2, sl
   11e78:	ble.n	11e16 <_strtoul_l.isra.0+0x7e>
   11e7a:	mov.w	lr, #4294967295
   11e7e:	b.n	11e1e <_strtoul_l.isra.0+0x86>
   11e80:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11e84:	movs	r3, #34	; 0x22
   11e86:	str	r3, [r7, #0]
   11e88:	mov	r0, lr
   11e8a:	cbz	r5, 11ede <_strtoul_l.isra.0+0x146>
   11e8c:	subs	r6, r4, #1
   11e8e:	str	r6, [r5, #0]
   11e90:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11e94:	add.w	r4, fp, #2
   11e98:	ldrb.w	r1, [fp, #1]
   11e9c:	mov.w	ip, #1
   11ea0:	b.n	11ddc <_strtoul_l.isra.0+0x44>
   11ea2:	cmp	r1, #48	; 0x30
   11ea4:	bne.n	11ee2 <_strtoul_l.isra.0+0x14a>
   11ea6:	ldrb	r3, [r4, #0]
   11ea8:	and.w	r3, r3, #223	; 0xdf
   11eac:	cmp	r3, #88	; 0x58
   11eae:	bne.n	11eee <_strtoul_l.isra.0+0x156>
   11eb0:	mov.w	r9, #16
   11eb4:	ldrb	r1, [r4, #1]
   11eb6:	mov	r8, r9
   11eb8:	mov.w	sl, #15
   11ebc:	adds	r4, #2
   11ebe:	mvn.w	r3, #4026531840	; 0xf0000000
   11ec2:	b.n	11e0c <_strtoul_l.isra.0+0x74>
   11ec4:	ldrb	r3, [r4, #0]
   11ec6:	and.w	r3, r3, #223	; 0xdf
   11eca:	cmp	r3, #88	; 0x58
   11ecc:	beq.n	11eb0 <_strtoul_l.isra.0+0x118>
   11ece:	mov.w	r8, #8
   11ed2:	mov	r9, r8
   11ed4:	mov.w	sl, #7
   11ed8:	mvn.w	r3, #3758096384	; 0xe0000000
   11edc:	b.n	11e0c <_strtoul_l.isra.0+0x74>
   11ede:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11ee2:	mov.w	sl, #15
   11ee6:	mvn.w	r3, #4026531840	; 0xf0000000
   11eea:	mov	r9, r8
   11eec:	b.n	11e0c <_strtoul_l.isra.0+0x74>
   11eee:	mov	r9, r8
   11ef0:	mov.w	sl, #15
   11ef4:	mvn.w	r3, #4026531840	; 0xf0000000
   11ef8:	b.n	11e0c <_strtoul_l.isra.0+0x74>
   11efa:	nop
   11efc:	.word	0x19999999

00011f00 <_strtoul_r>:
   11f00:	push	{r4, r5, lr}
   11f02:	ldr	r4, [pc, #24]	; (11f1c <_strtoul_r+0x1c>)
   11f04:	ldr	r5, [pc, #24]	; (11f20 <_strtoul_r+0x20>)
   11f06:	ldr	r4, [r4, #0]
   11f08:	ldr	r4, [r4, #52]	; 0x34
   11f0a:	sub	sp, #12
   11f0c:	cmp	r4, #0
   11f0e:	it	eq
   11f10:	moveq	r4, r5
   11f12:	str	r4, [sp, #0]
   11f14:	bl	11d98 <_strtoul_l.isra.0>
   11f18:	add	sp, #12
   11f1a:	pop	{r4, r5, pc}
   11f1c:	.word	0x1fff1828
   11f20:	.word	0x1fff182c

00011f24 <_strtoull_l.isra.0>:
   11f24:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11f28:	sub	sp, #20
   11f2a:	mov	fp, r1
   11f2c:	str	r0, [sp, #8]
   11f2e:	mov	r7, r2
   11f30:	mov	r6, r3
   11f32:	mov	r8, r1
   11f34:	ldr	r4, [sp, #56]	; 0x38
   11f36:	b.n	11f3a <_strtoull_l.isra.0+0x16>
   11f38:	mov	r8, r5
   11f3a:	mov	r5, r8
   11f3c:	mov	r0, r4
   11f3e:	ldrb.w	r9, [r5], #1
   11f42:	bl	b2fc <__locale_ctype_ptr_l>
   11f46:	add	r0, r9
   11f48:	ldrb	r3, [r0, #1]
   11f4a:	and.w	r3, r3, #8
   11f4e:	and.w	r2, r3, #255	; 0xff
   11f52:	cmp	r3, #0
   11f54:	bne.n	11f38 <_strtoull_l.isra.0+0x14>
   11f56:	mov	r4, r9
   11f58:	cmp	r4, #45	; 0x2d
   11f5a:	beq.w	12076 <_strtoull_l.isra.0+0x152>
   11f5e:	cmp	r4, #43	; 0x2b
   11f60:	it	eq
   11f62:	ldrbeq.w	r4, [r8, #1]
   11f66:	str	r2, [sp, #4]
   11f68:	it	eq
   11f6a:	addeq.w	r5, r8, #2
   11f6e:	cbz	r6, 11fa8 <_strtoull_l.isra.0+0x84>
   11f70:	cmp	r6, #16
   11f72:	beq.w	12084 <_strtoull_l.isra.0+0x160>
   11f76:	mov.w	r9, r6, asr #31
   11f7a:	mov	r2, r6
   11f7c:	mov	r3, r9
   11f7e:	mov.w	r0, #4294967295
   11f82:	mov.w	r1, #4294967295
   11f86:	bl	af48 <__aeabi_uldivmod>
   11f8a:	mov	r2, r6
   11f8c:	str	r0, [sp, #12]
   11f8e:	mov	sl, r1
   11f90:	mov	r3, r9
   11f92:	mov.w	r0, #4294967295
   11f96:	mov.w	r1, #4294967295
   11f9a:	bl	af48 <__aeabi_uldivmod>
   11f9e:	mov	r8, r6
   11fa0:	mov	lr, r2
   11fa2:	ldr	r2, [sp, #12]
   11fa4:	mov	r3, sl
   11fa6:	b.n	11fc2 <_strtoull_l.isra.0+0x9e>
   11fa8:	cmp	r4, #48	; 0x30
   11faa:	beq.w	120b0 <_strtoull_l.isra.0+0x18c>
   11fae:	ldr	r3, [pc, #348]	; (1210c <_strtoull_l.isra.0+0x1e8>)
   11fb0:	mov.w	lr, #5
   11fb4:	mov.w	r2, #2576980377	; 0x99999999
   11fb8:	mov.w	r8, #10
   11fbc:	mov.w	r9, #0
   11fc0:	movs	r6, #10
   11fc2:	mov.w	ip, #0
   11fc6:	movs	r0, #0
   11fc8:	movs	r1, #0
   11fca:	b.n	11ff2 <_strtoull_l.isra.0+0xce>
   11fcc:	cmp	r1, r3
   11fce:	it	eq
   11fd0:	cmpeq	r0, r2
   11fd2:	beq.n	12056 <_strtoull_l.isra.0+0x132>
   11fd4:	mul.w	r4, r0, r9
   11fd8:	mla	r4, r8, r1, r4
   11fdc:	umull	r0, r1, r0, r8
   11fe0:	add	r1, r4
   11fe2:	adds.w	r0, r0, sl
   11fe6:	adc.w	r1, r1, sl, asr #31
   11fea:	mov.w	ip, #1
   11fee:	ldrb.w	r4, [r5], #1
   11ff2:	sub.w	sl, r4, #48	; 0x30
   11ff6:	cmp.w	sl, #9
   11ffa:	bls.n	1200a <_strtoull_l.isra.0+0xe6>
   11ffc:	sub.w	sl, r4, #65	; 0x41
   12000:	cmp.w	sl, #25
   12004:	bhi.n	12022 <_strtoull_l.isra.0+0xfe>
   12006:	sub.w	sl, r4, #55	; 0x37
   1200a:	cmp	r6, sl
   1200c:	ble.n	12034 <_strtoull_l.isra.0+0x110>
   1200e:	cmp.w	ip, #4294967295
   12012:	beq.n	11fee <_strtoull_l.isra.0+0xca>
   12014:	cmp	r3, r1
   12016:	it	eq
   12018:	cmpeq	r2, r0
   1201a:	bcs.n	11fcc <_strtoull_l.isra.0+0xa8>
   1201c:	mov.w	ip, #4294967295
   12020:	b.n	11fee <_strtoull_l.isra.0+0xca>
   12022:	sub.w	sl, r4, #97	; 0x61
   12026:	cmp.w	sl, #25
   1202a:	bhi.n	12034 <_strtoull_l.isra.0+0x110>
   1202c:	sub.w	sl, r4, #87	; 0x57
   12030:	cmp	r6, sl
   12032:	bgt.n	1200e <_strtoull_l.isra.0+0xea>
   12034:	cmp.w	ip, #4294967295
   12038:	beq.n	12060 <_strtoull_l.isra.0+0x13c>
   1203a:	ldr	r3, [sp, #4]
   1203c:	cbz	r3, 12044 <_strtoull_l.isra.0+0x120>
   1203e:	negs	r0, r0
   12040:	sbc.w	r1, r1, r1, lsl #1
   12044:	cbz	r7, 12050 <_strtoull_l.isra.0+0x12c>
   12046:	cmp.w	ip, #0
   1204a:	bne.n	12072 <_strtoull_l.isra.0+0x14e>
   1204c:	mov	r5, fp
   1204e:	str	r5, [r7, #0]
   12050:	add	sp, #20
   12052:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12056:	cmp	sl, lr
   12058:	ble.n	11fd4 <_strtoull_l.isra.0+0xb0>
   1205a:	mov.w	ip, #4294967295
   1205e:	b.n	11fee <_strtoull_l.isra.0+0xca>
   12060:	ldr	r2, [sp, #8]
   12062:	movs	r3, #34	; 0x22
   12064:	str	r3, [r2, #0]
   12066:	mov.w	r0, #4294967295
   1206a:	mov.w	r1, #4294967295
   1206e:	cmp	r7, #0
   12070:	beq.n	12050 <_strtoull_l.isra.0+0x12c>
   12072:	subs	r5, #1
   12074:	b.n	1204e <_strtoull_l.isra.0+0x12a>
   12076:	movs	r3, #1
   12078:	add.w	r5, r8, #2
   1207c:	ldrb.w	r4, [r8, #1]
   12080:	str	r3, [sp, #4]
   12082:	b.n	11f6e <_strtoull_l.isra.0+0x4a>
   12084:	cmp	r4, #48	; 0x30
   12086:	bne.n	120d2 <_strtoull_l.isra.0+0x1ae>
   12088:	ldrb	r3, [r5, #0]
   1208a:	and.w	r3, r3, #223	; 0xdf
   1208e:	cmp	r3, #88	; 0x58
   12090:	bne.n	120e8 <_strtoull_l.isra.0+0x1c4>
   12092:	mov.w	r3, #4294967295
   12096:	ldrb	r4, [r5, #1]
   12098:	str	r3, [sp, #12]
   1209a:	mov.w	lr, #15
   1209e:	adds	r5, #2
   120a0:	mvn.w	sl, #4026531840	; 0xf0000000
   120a4:	mov.w	r8, #16
   120a8:	mov.w	r9, #0
   120ac:	movs	r6, #16
   120ae:	b.n	11fa2 <_strtoull_l.isra.0+0x7e>
   120b0:	ldrb	r3, [r5, #0]
   120b2:	and.w	r3, r3, #223	; 0xdf
   120b6:	cmp	r3, #88	; 0x58
   120b8:	beq.n	12092 <_strtoull_l.isra.0+0x16e>
   120ba:	mov.w	lr, #7
   120be:	mov.w	r2, #4294967295
   120c2:	mvn.w	r3, #3758096384	; 0xe0000000
   120c6:	mov.w	r8, #8
   120ca:	mov.w	r9, #0
   120ce:	movs	r6, #8
   120d0:	b.n	11fc2 <_strtoull_l.isra.0+0x9e>
   120d2:	mov.w	lr, #15
   120d6:	mov.w	r2, #4294967295
   120da:	mvn.w	r3, #4026531840	; 0xf0000000
   120de:	mov.w	r8, #16
   120e2:	mov.w	r9, #0
   120e6:	b.n	11fc2 <_strtoull_l.isra.0+0x9e>
   120e8:	mov.w	r8, #16
   120ec:	mov.w	r9, #0
   120f0:	mov	r2, r8
   120f2:	mov	r3, r9
   120f4:	mov.w	r0, #4294967295
   120f8:	mov.w	r1, #4294967295
   120fc:	bl	af48 <__aeabi_uldivmod>
   12100:	mvn.w	r3, #4026531840	; 0xf0000000
   12104:	mov	lr, r2
   12106:	mov.w	r2, #4294967295
   1210a:	b.n	11fc2 <_strtoull_l.isra.0+0x9e>
   1210c:	.word	0x19999999

00012110 <_strtoull_r>:
   12110:	push	{r4, r5, lr}
   12112:	ldr	r4, [pc, #24]	; (1212c <_strtoull_r+0x1c>)
   12114:	ldr	r5, [pc, #24]	; (12130 <_strtoull_r+0x20>)
   12116:	ldr	r4, [r4, #0]
   12118:	ldr	r4, [r4, #52]	; 0x34
   1211a:	sub	sp, #12
   1211c:	cmp	r4, #0
   1211e:	it	eq
   12120:	moveq	r4, r5
   12122:	str	r4, [sp, #0]
   12124:	bl	11f24 <_strtoull_l.isra.0>
   12128:	add	sp, #12
   1212a:	pop	{r4, r5, pc}
   1212c:	.word	0x1fff1828
   12130:	.word	0x1fff182c

00012134 <__ssprint_r>:
   12134:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12138:	ldr	r3, [r2, #8]
   1213a:	sub	sp, #12
   1213c:	mov	r8, r2
   1213e:	cmp	r3, #0
   12140:	beq.n	12228 <__ssprint_r+0xf4>
   12142:	mov	fp, r0
   12144:	mov.w	r9, #0
   12148:	ldr	r6, [r2, #0]
   1214a:	ldr	r0, [r1, #0]
   1214c:	ldr	r3, [r1, #8]
   1214e:	mov	r5, r1
   12150:	mov	r4, r9
   12152:	cmp	r4, #0
   12154:	beq.n	121e2 <__ssprint_r+0xae>
   12156:	cmp	r4, r3
   12158:	mov	r7, r3
   1215a:	mov	sl, r3
   1215c:	bcc.n	121ec <__ssprint_r+0xb8>
   1215e:	ldrh	r3, [r5, #12]
   12160:	tst.w	r3, #1152	; 0x480
   12164:	beq.n	121c2 <__ssprint_r+0x8e>
   12166:	ldr	r7, [r5, #20]
   12168:	ldr	r1, [r5, #16]
   1216a:	add.w	r7, r7, r7, lsl #1
   1216e:	rsb	sl, r1, r0
   12172:	add.w	r7, r7, r7, lsr #31
   12176:	adds	r0, r4, #1
   12178:	asrs	r7, r7, #1
   1217a:	add	r0, sl
   1217c:	cmp	r0, r7
   1217e:	mov	r2, r7
   12180:	itt	hi
   12182:	movhi	r7, r0
   12184:	movhi	r2, r7
   12186:	lsls	r3, r3, #21
   12188:	bpl.n	121f2 <__ssprint_r+0xbe>
   1218a:	mov	r1, r2
   1218c:	mov	r0, fp
   1218e:	bl	b338 <_malloc_r>
   12192:	cmp	r0, #0
   12194:	beq.n	12206 <__ssprint_r+0xd2>
   12196:	mov	r2, sl
   12198:	ldr	r1, [r5, #16]
   1219a:	str	r0, [sp, #4]
   1219c:	bl	8f14 <memcpy>
   121a0:	ldrh	r2, [r5, #12]
   121a2:	ldr	r3, [sp, #4]
   121a4:	bic.w	r2, r2, #1152	; 0x480
   121a8:	orr.w	r2, r2, #128	; 0x80
   121ac:	strh	r2, [r5, #12]
   121ae:	rsb	r2, sl, r7
   121b2:	add.w	r0, r3, sl
   121b6:	str	r7, [r5, #20]
   121b8:	str	r3, [r5, #16]
   121ba:	str	r0, [r5, #0]
   121bc:	str	r2, [r5, #8]
   121be:	mov	r7, r4
   121c0:	mov	sl, r4
   121c2:	mov	r2, sl
   121c4:	mov	r1, r9
   121c6:	bl	b9e4 <memmove>
   121ca:	ldr.w	r2, [r8, #8]
   121ce:	ldr	r3, [r5, #8]
   121d0:	ldr	r0, [r5, #0]
   121d2:	subs	r3, r3, r7
   121d4:	add	r0, sl
   121d6:	subs	r4, r2, r4
   121d8:	str	r3, [r5, #8]
   121da:	str	r0, [r5, #0]
   121dc:	str.w	r4, [r8, #8]
   121e0:	cbz	r4, 12228 <__ssprint_r+0xf4>
   121e2:	ldr.w	r9, [r6]
   121e6:	ldr	r4, [r6, #4]
   121e8:	adds	r6, #8
   121ea:	b.n	12152 <__ssprint_r+0x1e>
   121ec:	mov	r7, r4
   121ee:	mov	sl, r4
   121f0:	b.n	121c2 <__ssprint_r+0x8e>
   121f2:	mov	r0, fp
   121f4:	bl	bab4 <_realloc_r>
   121f8:	mov	r3, r0
   121fa:	cmp	r0, #0
   121fc:	bne.n	121ae <__ssprint_r+0x7a>
   121fe:	ldr	r1, [r5, #16]
   12200:	mov	r0, fp
   12202:	bl	10890 <_free_r>
   12206:	movs	r3, #12
   12208:	str.w	r3, [fp]
   1220c:	ldrh	r3, [r5, #12]
   1220e:	movs	r2, #0
   12210:	orr.w	r3, r3, #64	; 0x40
   12214:	mov.w	r0, #4294967295
   12218:	strh	r3, [r5, #12]
   1221a:	str.w	r2, [r8, #8]
   1221e:	str.w	r2, [r8, #4]
   12222:	add	sp, #12
   12224:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12228:	movs	r0, #0
   1222a:	str.w	r0, [r8, #4]
   1222e:	add	sp, #12
   12230:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00012234 <_sungetc_r>:
   12234:	adds	r3, r1, #1
   12236:	push	{r4, r5, r6, lr}
   12238:	beq.n	12272 <_sungetc_r+0x3e>
   1223a:	ldrh	r3, [r2, #12]
   1223c:	ldr	r4, [r2, #48]	; 0x30
   1223e:	bic.w	r3, r3, #32
   12242:	strh	r3, [r2, #12]
   12244:	uxtb	r5, r1
   12246:	cbz	r4, 12278 <_sungetc_r+0x44>
   12248:	mov	r4, r2
   1224a:	ldr	r2, [r2, #4]
   1224c:	ldr	r3, [r4, #52]	; 0x34
   1224e:	cmp	r2, r3
   12250:	mov	r6, r1
   12252:	bge.n	12268 <_sungetc_r+0x34>
   12254:	ldr	r3, [r4, #0]
   12256:	subs	r2, r3, #1
   12258:	str	r2, [r4, #0]
   1225a:	strb.w	r6, [r3, #-1]
   1225e:	ldr	r3, [r4, #4]
   12260:	adds	r3, #1
   12262:	str	r3, [r4, #4]
   12264:	mov	r0, r5
   12266:	pop	{r4, r5, r6, pc}
   12268:	mov	r1, r4
   1226a:	bl	12378 <__submore>
   1226e:	cmp	r0, #0
   12270:	beq.n	12254 <_sungetc_r+0x20>
   12272:	mov.w	r5, #4294967295
   12276:	b.n	12264 <_sungetc_r+0x30>
   12278:	ldr	r0, [r2, #16]
   1227a:	ldr	r3, [r2, #0]
   1227c:	cbz	r0, 1228a <_sungetc_r+0x56>
   1227e:	cmp	r0, r3
   12280:	bcs.n	1228a <_sungetc_r+0x56>
   12282:	ldrb.w	r0, [r3, #-1]
   12286:	cmp	r5, r0
   12288:	beq.n	122aa <_sungetc_r+0x76>
   1228a:	str	r3, [r2, #56]	; 0x38
   1228c:	mov	r3, r2
   1228e:	ldr	r6, [r2, #4]
   12290:	str	r6, [r2, #60]	; 0x3c
   12292:	add.w	r4, r2, #64	; 0x40
   12296:	movs	r0, #3
   12298:	str	r0, [r2, #52]	; 0x34
   1229a:	str	r4, [r2, #48]	; 0x30
   1229c:	strb.w	r1, [r3, #66]!
   122a0:	movs	r1, #1
   122a2:	str	r3, [r2, #0]
   122a4:	str	r1, [r2, #4]
   122a6:	mov	r0, r5
   122a8:	pop	{r4, r5, r6, pc}
   122aa:	ldr	r1, [r2, #4]
   122ac:	subs	r3, #1
   122ae:	adds	r1, #1
   122b0:	str	r3, [r2, #0]
   122b2:	str	r1, [r2, #4]
   122b4:	b.n	12264 <_sungetc_r+0x30>
   122b6:	nop

000122b8 <__ssrefill_r>:
   122b8:	push	{r4, lr}
   122ba:	mov	r4, r1
   122bc:	ldr	r1, [r1, #48]	; 0x30
   122be:	cbz	r1, 122dc <__ssrefill_r+0x24>
   122c0:	add.w	r3, r4, #64	; 0x40
   122c4:	cmp	r1, r3
   122c6:	beq.n	122cc <__ssrefill_r+0x14>
   122c8:	bl	10890 <_free_r>
   122cc:	ldr	r3, [r4, #60]	; 0x3c
   122ce:	str	r3, [r4, #4]
   122d0:	movs	r0, #0
   122d2:	str	r0, [r4, #48]	; 0x30
   122d4:	cbz	r3, 122dc <__ssrefill_r+0x24>
   122d6:	ldr	r3, [r4, #56]	; 0x38
   122d8:	str	r3, [r4, #0]
   122da:	pop	{r4, pc}
   122dc:	ldrh	r3, [r4, #12]
   122de:	ldr	r2, [r4, #16]
   122e0:	str	r2, [r4, #0]
   122e2:	orr.w	r3, r3, #32
   122e6:	movs	r2, #0
   122e8:	strh	r3, [r4, #12]
   122ea:	str	r2, [r4, #4]
   122ec:	mov.w	r0, #4294967295
   122f0:	pop	{r4, pc}
   122f2:	nop

000122f4 <_sfread_r>:
   122f4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   122f8:	sub	sp, #12
   122fa:	mul.w	r9, r2, r3
   122fe:	str	r2, [sp, #4]
   12300:	mov	sl, r3
   12302:	ldr	r4, [sp, #48]	; 0x30
   12304:	cmp.w	r9, #0
   12308:	beq.n	1235e <_sfread_r+0x6a>
   1230a:	mov	r7, r0
   1230c:	mov	r6, r1
   1230e:	mov	r5, r9
   12310:	mov.w	r8, #0
   12314:	b.n	12336 <_sfread_r+0x42>
   12316:	ldr	r1, [r4, #0]
   12318:	bl	8f14 <memcpy>
   1231c:	ldr	r2, [r4, #0]
   1231e:	str.w	r8, [r4, #4]
   12322:	add	r2, fp
   12324:	str	r2, [r4, #0]
   12326:	mov	r1, r4
   12328:	mov	r0, r7
   1232a:	add	r6, fp
   1232c:	rsb	r5, fp, r5
   12330:	bl	122b8 <__ssrefill_r>
   12334:	cbnz	r0, 12366 <_sfread_r+0x72>
   12336:	ldr.w	fp, [r4, #4]
   1233a:	cmp	r5, fp
   1233c:	mov	r0, r6
   1233e:	mov	r2, fp
   12340:	bhi.n	12316 <_sfread_r+0x22>
   12342:	mov	r2, r5
   12344:	ldr	r1, [r4, #0]
   12346:	bl	8f14 <memcpy>
   1234a:	ldr	r2, [r4, #4]
   1234c:	ldr	r3, [r4, #0]
   1234e:	subs	r2, r2, r5
   12350:	add	r3, r5
   12352:	mov	r0, sl
   12354:	str	r2, [r4, #4]
   12356:	str	r3, [r4, #0]
   12358:	add	sp, #12
   1235a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1235e:	mov	r0, r9
   12360:	add	sp, #12
   12362:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12366:	ldr	r3, [sp, #4]
   12368:	rsb	r9, r5, r9
   1236c:	udiv	r0, r9, r3
   12370:	add	sp, #12
   12372:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12376:	nop

00012378 <__submore>:
   12378:	add.w	r3, r1, #64	; 0x40
   1237c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12380:	mov	r4, r1
   12382:	ldr	r1, [r1, #48]	; 0x30
   12384:	cmp	r1, r3
   12386:	beq.n	123b2 <__submore+0x3a>
   12388:	ldr	r6, [r4, #52]	; 0x34
   1238a:	lsls	r7, r6, #1
   1238c:	mov	r2, r7
   1238e:	bl	bab4 <_realloc_r>
   12392:	mov	r5, r0
   12394:	cbz	r0, 123e8 <__submore+0x70>
   12396:	add.w	r8, r0, r6
   1239a:	mov	r2, r6
   1239c:	mov	r0, r8
   1239e:	mov	r1, r5
   123a0:	bl	8f14 <memcpy>
   123a4:	str.w	r8, [r4]
   123a8:	str	r5, [r4, #48]	; 0x30
   123aa:	str	r7, [r4, #52]	; 0x34
   123ac:	movs	r0, #0
   123ae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   123b2:	mov.w	r1, #1024	; 0x400
   123b6:	bl	b338 <_malloc_r>
   123ba:	cbz	r0, 123e8 <__submore+0x70>
   123bc:	ldrb.w	r3, [r4, #66]	; 0x42
   123c0:	str	r0, [r4, #48]	; 0x30
   123c2:	mov.w	r2, #1024	; 0x400
   123c6:	str	r2, [r4, #52]	; 0x34
   123c8:	strb.w	r3, [r0, #1023]	; 0x3ff
   123cc:	ldrb.w	r3, [r4, #65]	; 0x41
   123d0:	strb.w	r3, [r0, #1022]	; 0x3fe
   123d4:	ldrb.w	r3, [r4, #64]	; 0x40
   123d8:	strb.w	r3, [r0, #1021]	; 0x3fd
   123dc:	addw	r0, r0, #1021	; 0x3fd
   123e0:	str	r0, [r4, #0]
   123e2:	movs	r0, #0
   123e4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   123e8:	mov.w	r0, #4294967295
   123ec:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000123f0 <_vasnprintf_r>:
   123f0:	push	{r4, r5, r6, lr}
   123f2:	mov	r5, r2
   123f4:	sub	sp, #104	; 0x68
   123f6:	ldr	r4, [r2, #0]
   123f8:	cbz	r1, 123fe <_vasnprintf_r+0xe>
   123fa:	cmp	r4, #0
   123fc:	bne.n	12434 <_vasnprintf_r+0x44>
   123fe:	movs	r4, #0
   12400:	mov.w	r2, #648	; 0x288
   12404:	strh.w	r2, [sp, #12]
   12408:	str	r4, [sp, #0]
   1240a:	str	r4, [sp, #16]
   1240c:	mov	r2, r3
   1240e:	movw	r6, #65535	; 0xffff
   12412:	ldr	r3, [sp, #120]	; 0x78
   12414:	str	r4, [sp, #8]
   12416:	mov	r1, sp
   12418:	str	r4, [sp, #20]
   1241a:	strh.w	r6, [sp, #14]
   1241e:	bl	d190 <_svfprintf_r>
   12422:	cmp	r0, #0
   12424:	blt.n	1244a <_vasnprintf_r+0x5a>
   12426:	ldr	r3, [sp, #0]
   12428:	str	r0, [r5, #0]
   1242a:	movs	r2, #0
   1242c:	strb	r2, [r3, #0]
   1242e:	ldr	r0, [sp, #16]
   12430:	add	sp, #104	; 0x68
   12432:	pop	{r4, r5, r6, pc}
   12434:	mov.w	r2, #1544	; 0x608
   12438:	str	r1, [sp, #0]
   1243a:	str	r1, [sp, #16]
   1243c:	strh.w	r2, [sp, #12]
   12440:	bge.n	1240c <_vasnprintf_r+0x1c>
   12442:	movs	r3, #139	; 0x8b
   12444:	str	r3, [r0, #0]
   12446:	movs	r0, #0
   12448:	b.n	12430 <_vasnprintf_r+0x40>
   1244a:	movs	r0, #0
   1244c:	b.n	12430 <_vasnprintf_r+0x40>
   1244e:	nop

00012450 <_calloc_r>:
   12450:	push	{r4, lr}
   12452:	mul.w	r1, r2, r1
   12456:	bl	b338 <_malloc_r>
   1245a:	mov	r4, r0
   1245c:	cbz	r0, 12496 <_calloc_r+0x46>
   1245e:	ldr.w	r2, [r0, #-4]
   12462:	bic.w	r2, r2, #3
   12466:	subs	r2, #4
   12468:	cmp	r2, #36	; 0x24
   1246a:	bhi.n	1249e <_calloc_r+0x4e>
   1246c:	cmp	r2, #19
   1246e:	bls.n	1249a <_calloc_r+0x4a>
   12470:	movs	r3, #0
   12472:	cmp	r2, #27
   12474:	str	r3, [r0, #0]
   12476:	str	r3, [r0, #4]
   12478:	bls.n	124a8 <_calloc_r+0x58>
   1247a:	cmp	r2, #36	; 0x24
   1247c:	str	r3, [r0, #8]
   1247e:	str	r3, [r0, #12]
   12480:	iteee	ne
   12482:	addne.w	r2, r0, #16
   12486:	streq	r3, [r0, #16]
   12488:	streq	r3, [r0, #20]
   1248a:	addeq.w	r2, r0, #24
   1248e:	movs	r3, #0
   12490:	str	r3, [r2, #0]
   12492:	str	r3, [r2, #4]
   12494:	str	r3, [r2, #8]
   12496:	mov	r0, r4
   12498:	pop	{r4, pc}
   1249a:	mov	r2, r0
   1249c:	b.n	1248e <_calloc_r+0x3e>
   1249e:	movs	r1, #0
   124a0:	bl	90bc <memset>
   124a4:	mov	r0, r4
   124a6:	pop	{r4, pc}
   124a8:	add.w	r2, r0, #8
   124ac:	b.n	1248e <_calloc_r+0x3e>
   124ae:	nop
   124b0:	.word	0x25206425
   124b4:	.short	0x0a64
   124b6:	.byte	0x00
   124b7:	.byte	0x62
   124b8:	.word	0x63697361
   124bc:	.word	0x756f5320
   124c0:	.word	0x5220646e
   124c4:	.word	0x726f6365
   124c8:	.word	0x20726564
   124cc:	.word	0x73726556
   124d0:	.word	0x3a6e6f69
   124d4:	.word	0x62654620
   124d8:	.word	0x20372020
   124dc:	.word	0x32323032
   124e0:	.word	0x3a323120
   124e4:	.word	0x353a3935
   124e8:	.word	0x6e450035
   124ec:	.word	0x666f2064
   124f0:	.word	0x74655320
   124f4:	.word	0x0a007075
   124f8:	.word	0x706f6f4c
   124fc:	.word	0x2000203a
   12500:	.word	0xff00203a

00012504 <vtable for Stream>:
	...
   1250c:	-...............
   1251c:	-...-...-...

00012528 <vtable for StreamFile<FsBaseFile, unsigned long long>>:
	...
   12530:	................
   12540:	)...O...#...

0001254c <vtable for FsFile>:
	...
   12554:	................
   12564:	)...O...#...

00012570 <vtable for File>:
	...
   12578:	................
   12588:	............u...
   12598:	....

0001259c <vtable for SDFile>:
	...
   125a4:	........o.......
   125b4:	3...-...........
   125c4:	................
   125d4:	........]...i...
   125e4:	g.......o.......
   125f4:	e.../Config.txt.
   12604:	%10d.... Menu. '
   12614:	:h'  : print hel
   12624:	p. ':s'  : start
   12634:	 acquisition. ':
   12644:	e'  : stop acqui
   12654:	sition. ':w'  : 
   12664:	write parameters
   12674:	 to microSD card
   12684:	. ':l'  : list d
   12694:	isks. ':r'  : re
   126a4:	set MTP. ':b'  :
   126b4:	 reboot CPU. '?p
   126c4:	'  : show all pa
   126d4:	rameters. '?d'  
   126e4:	: get date. '?t'
   126f4:	  : get time. '?
   12704:	a'  : get file d
   12714:	uration (s). '!d
   12724:	 yyyy/mm/dd<cr>'
   12734:	  : set date. '!
   12744:	t hh:mm:ss<cr>' 
   12754:	   : set time. '
   12764:	!a val<cr>'  : s
   12774:	et file duration
   12784:	 (s).CVAS_V3 Ver
   12794:	sion: Feb  7 202
   127a4:	2 12:59:55.Teens
   127b4:	y: %d: %06x..Dat
   127c4:	e d = %04d/%02d/
   127d4:	%02d..Time t = %
   127e4:	02d:%02d:%02d..T
   127f4:	_acq a = %d..%d%
   12804:	c%d%c%d.start.st
   12814:	op.rebooting CPU
	...

00012825 <monthDays>:
   12825:	...............

00012834 <vtable for MySpiClass>:
	...
   1283c:	....9...q.......
   1284c:	....m...........
   1285c:	No spi storage.S
   1286c:	torage %d %d %s 
   1287c:	.%d %d.D./%s%06x
   1288c:	_%04d%02d%02d/%0
   1289c:	2d/./%s%06x_%04d
   128ac:	%02d%02d/%02d_%0
   128bc:	2d/.F.%s_%02d%02
   128cc:	d%02d.bin.Failin
   128dc:	g open file.WMXZ
   128ec:	.%s%04d%02d%02d_
   128fc:	%02d%02d%02d.sd1
   1290c:	.No I2C address 
   1291c:	found...

00012924 <TwoWire::i2c0_hardware>:
   12924:	4..@@.....".0...
   12934:	....!./.........

00012944 <TwoWire::i2c1_hardware>:
   12944:	4..@....&:......
   12954:	..%;............

00012964 <TwoWire::i2c2_hardware>:
   12964:	(..@@...........
   12974:	............J...

00012984 <vtable for TwoWire>:
	...
   1298c:	.%...%.......%..
   1299c:	.%...%...%..

000129a8 <SPISettings::ctar_div_table>:
   129a8:	................
   129b8:	...... .(.8.@.`.
   129c8:	................

000129d8 <SPIClass::spi0_hardware>:
   129d8:	<..@............
   129e8:	.....0....'.....
   129f8:	................
   12a08:	................
   12a18:	................
   12a28:	..........-.....
   12a38:	................
   12a48:	................
   12a58:	................
   12a68:	.. .

00012a6c <SPISettings::ctar_clock_table>:
   12a6c:	................
   12a7c:	................
   12a8c:	. ....... ...0..
   12a9c:	. ... ...@...@..
   12aac:	.P...P...`...`..
   12abc:	.p...`...p..

00012ac8 <vtable for SDClass>:
	...
   12ad0:	.....0...1..#2..
   12ae0:	.1..+1...2...2..
   12af0:	.3...4..

00012af8 <FsGetPartitionInfo::mbdpGuid>:
   12af8:	......3D..h..&..
   12b08:	EFI PART..

00012b12 <lookupTable>:
   12b12:	..x...C.........
   12b22:	..............=.
   12b32:	.. .............
   12b42:	................
   12b52:	................
   12b62:	....:.e,<.;.>.f,
   12b72:	B.A.S...T...V...
   12b82:	W...Y...[...`...
   12b92:	c...h...i...k.b,
   12ba2:	o...r...u...}.d,
   12bb2:	..............D.
   12bc2:	..........E.....
   12bd2:	{...|...}.......
   12be2:	................
   12bf2:	................
   12c02:	}.c,Q.Y.S.[.U.].
   12c12:	W._.x...y.......
   12c22:	............N!2!
   12c32:	.!.!a,`,v,u,

00012c3e <mapTable>:
   12c3e:	a..............0
   12c4e:	2...9...J...y...
   12c5e:	................
   12c6e:	.......("...F...
   12c7e:	................
   12c8e:	0.. P...`.."...6
   12c9e:	.......Da..&....
   12cae:	...Z........ ...
   12cbe:	0...@...`...p.J.
   12cce:	r.V.v.d.z.p.|.~.
   12cde:	................
   12cee:	........p!...$..
   12cfe:	0,./g,...,.d.-.&
   12d0e:	A...Device is to
   12d1e:	o small...Writin
   12d2e:	g FAT ...Writing
   12d3e:	 upcase table...
   12d4e:	Writing root...F
   12d5e:	ormat done...For
   12d6e:	mat failed...EXF
   12d7e:	AT.Bad cluster c
   12d8e:	ount...Card is t
   12d9e:	oo small....Form
   12dae:	at Done...Format
   12dbe:	 Failed...

00012dc8 <vtable for SdSpiCard>:
	...
   12dd0:	.v...v...w...v..
   12de0:	.|...|...w...}..
   12df0:	W....x...x...}..
   12e00:	.v...v..W|..O|..
   12e10:	.{.......v...~..
   12e20:	.}..o~..

00012e28 <vtable for SdioCard>:
	...
   12e30:	............e...
   12e40:	...._...a.......
   12e50:	................
   12e60:	................
   12e70:	....9...........
   12e80:	........

00012e88 <digital_pin_to_info_PGM>:
   12e88:	@..C@..@D..CD..@
   12e98:	...C...@0..C0..@
   12ea8:	4..C4..@...C...@
   12eb8:	...C...@...C...@
   12ec8:	...C...@...C...@
   12ed8:	...C...@...C...@
   12ee8:	...C...@...C...@
   12ef8:	...C...@...C...@
   12f08:	...C...@...C...@
   12f18:	...C...@...C...@
   12f28:	...C...@...C...@
   12f38:	...C...@...C...@
   12f48:	h .Ch..@...C...@
   12f58:	8..C8..@<..C<..@
   12f68:	@..C@..@H..CH..@
   12f78:	L..CL..@(..C(..@
   12f88:	,..C,..@` .C`..@
   12f98:	d .Cd..@ ..C ..@
   12fa8:	$..C$..@(..C(..@
   12fb8:	,..C,..@D..CD..@
   12fc8:	p..Cp..@t..Ct..@
   12fd8:	h..Ch..@P..CP..@
   12fe8:	X..CX..@\..C\..@
   12ff8:	T..CT..@ ..C ..@
   13008:	$..C$..@...C...@
   13018:	...C...@8..C8..@
   13028:	4..C4..@0..C0..@
   13038:	<..C<..@,..C,..@
   13048:	( .C(..@, .C,..@
   13058:	. .C...@. .C...@
   13068:	. .C...@. .C...@
   13078:	. .C...@. .C...@

00013088 <vtable for usb_serial_class>:
	...
   13090:	............}...
   130a0:	y...u...q...m...
   130b0:	..

000130b2 <usb_endpoint_config_table>:
   130b2:	......

000130b8 <usb_descriptor_list>:
   130b8:	....[...........
   130c8:	....C...........
   130d8:	........n.......
   130e8:	................
   130f8:	................
   13108:	....

0001310c <_global_impure_ptr>:
   1310c:	....C...POSIX...
   1311c:	....

00013120 <fpi.6173>:
   13120:	5...............
   13130:	....nf..inity...
   13140:	an..

00013144 <fpinan.6209>:
   13144:	4...............
   13154:	....

00013158 <tinytens>:
   13158:	.......<3...#.I9
   13168:	=..D...2......[%
   13178:	Co.d(.h.

00013180 <zeroes.7258>:
   13180:	0000000000000000
   13190:	INF.inf.NAN.nan.
   131a0:	0123456789ABCDEF
   131b0:	....0123456789ab
   131c0:	cdef....(null)..
   131d0:	0...

000131d4 <blanks.7257>:
   131d4:	                

000131e4 <basefix.7328>:
   131e4:	................
   131f4:	................
   13204:	....e%ld....

00013210 <_ctype_>:
   13210:	.         ((((( 
   13220:	                
   13230:	 ...............
   13240:	................
   13250:	..AAAAAA........
   13260:	................
   13270:	..BBBBBB........
   13280:	................
   13290:	 ...............
	...
   13310:	....Infinity....
   13320:	NaN.

00013324 <__hexdig>:
	...
   13354:	................
   13364:	................
	...
   13384:	................
	...
   13424:	....

00013428 <__mprec_tens>:
   13428:	.......?......$@
   13438:	......Y@.....@.@
   13448:	.......@.....j.@
   13458:	.......A......cA
   13468:	.......A....e..A
   13478:	... _..B....vH7B
   13488:	......mB..@..0.B
   13498:	.......B..4&.k.C
   134a8:	...7y.AC....W4vC
   134b8:	..Ngm..C.=.`.X.C
   134c8:	@..x...DP.....KD
   134d8:	..M....D.J...-.D
   134e8:	...yCx.D

000134f0 <__mprec_bigtens>:
   134f0:	...7y.AC.n.....F
   13500:	..?..O8M2.0.Hw.Z
   13510:	<.s..O.u

00013518 <p05.6087>:
   13518:	........}...

00013524 <_init>:
   13524:	push	{r3, r4, r5, r6, r7, lr}
   13526:	nop
   13528:	pop	{r3, r4, r5, r6, r7}
   1352a:	pop	{r3}
   1352c:	mov	lr, r3
   1352e:	bx	lr

00013530 <__init_array_start>:
   13530:	.word	0x0000f84d

00013534 <__frame_dummy_init_array_entry>:
   13534:	5.......-"...%..
   13544:	a4..

Disassembly of section .fini:

00013548 <_fini>:
   13548:	push	{r3, r4, r5, r6, r7, lr}
   1354a:	nop
