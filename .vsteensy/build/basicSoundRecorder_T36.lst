
.vsteensy/build/basicSoundRecorder_T36.elf:     file format elf32-littlearm

SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
00013510 l    d  .fini	00000000 .fini
00013514 l    d  .ARM.exidx	00000000 .ARM.exidx
1fff0000 l    d  .usbdescriptortable	00000000 .usbdescriptortable
1fff0200 l    d  .dmabuffers	00000000 .dmabuffers
1fff0bd0 l    d  .usbbuffers	00000000 .usbbuffers
1fff0f30 l    d  .data	00000000 .data
1fff1dc8 l    d  .bss	00000000 .bss
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 mk20dx128.c
000093ac l     F .text	0000000c startup_default_early_hook
000093b8 l     F .text	00000002 startup_default_late_hook
00000000 l    df *ABS*	00000000 crtstuff.c
00000410 l     F .text	00000000 __do_global_dtors_aux
1fff1dc8 l       .bss	00000000 completed.8605
00000434 l     F .text	00000000 frame_dummy
1fff1dcc l       .bss	00000000 object.8610
000134fc l     O .text	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 acq.cpp
000006e0 l     F .text	00000058 acq_isr()
00000738 l     F .text	00000028 _GLOBAL__sub_I_acq_count
1fff0200 l     O .dmabuffers	00000800 tdm_rx_buffer
1fff1dec l     O .bss	00000400 acq_rx_buffer
1fff21ec l     O .bss	00000008 dma
00000000 l    df *ABS*	00000000 main.cpp
1fff21f8 l     O .bss	00000004 checkToCloseFile(short, unsigned long)::to
1fff0f34 l     O .data	00000002 loop::status
1fff21fc l     O .bss	00000004 loop::t0
1fff2204 l     O .bss	00000004 loop::loop_count
00000000 l    df *ABS*	00000000 menu.cpp
00000b94 l     F .text	00000024 File::dec_refcount() [clone .isra.15]
00000000 l    df *ABS*	00000000 utils.cpp
00000000 l    df *ABS*	00000000 mTime.cpp
000127e9 l     O .text	0000000c monthDays
00000000 l    df *ABS*	00000000 filing.cpp
000018cc l     F .text	00000002 __tcf_0
00001990 l     F .text	00000024 File::dec_refcount() [clone .isra.23]
00002280 l     F .text	000000bc _GLOBAL__sub_I_data_buffer
1fff224c l     O .bss	00000004 isd
1fff0f40 l     O .data	00000004 checkDiskSpace()::isd_
2001a254 l     O .bss	00000200 saveData(short)::header
2001a920 l     O .bss	00000050 saveData(short)::fileName
2001a970 l     O .bss	00000004 saveData(short)::dirFlag
2001a980 l     O .bss	00000050 saveData(short)::dirName
2001a9d0 l     O .bss	00001000 dummy_buffer
00000000 l    df *ABS*	00000000 adc.cpp
0000252c l     F .text	00000024 _GLOBAL__sub_I_gain
00000000 l    df *ABS*	00000000 WireKinetis.cpp
00002826 l       .text	00000000 L_1161_delayMicroseconds
00002834 l       .text	00000000 L_1175_delayMicroseconds
0000287c l       .text	00000000 L_1220_delayMicroseconds
00002b0c l       .text	00000000 L_2399_delayMicroseconds
2001c9e8 l     O .bss	00000001 TwoWire::isr()::receiving
00000000 l    df *ABS*	00000000 SPI.cpp
00002b7c l     F .text	00000022 DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]
00000000 l    df *ABS*	00000000 SD.cpp
0000341c l     F .text	00000064 _GLOBAL__sub_I_SD
00000000 l    df *ABS*	00000000 FsUtf.cpp
00000000 l    df *ABS*	00000000 FsGetPartitionInfo.cpp
00012abc l     O .text	00000010 FsGetPartitionInfo::mbdpGuid
00000000 l    df *ABS*	00000000 FsStructs.cpp
00000000 l    df *ABS*	00000000 FsCache.cpp
00000000 l    df *ABS*	00000000 upcase.cpp
00012ad6 l     O .text	0000012c lookupTable
00012c02 l     O .text	000000d4 mapTable
00000000 l    df *ABS*	00000000 FsName.cpp
00000000 l    df *ABS*	00000000 ExFatFormatter.cpp
00000000 l    df *ABS*	00000000 ExFatName.cpp
00000000 l    df *ABS*	00000000 ExFatFile.cpp
00000000 l    df *ABS*	00000000 ExFatPartition.cpp
00000000 l    df *ABS*	00000000 ExFatVolume.cpp
00000000 l    df *ABS*	00000000 ExFatFileWrite.cpp
00004c80 l     F .text	0000002e exFatDirChecksum(unsigned char const*, unsigned short)
00000000 l    df *ABS*	00000000 FatFormatter.cpp
000055c8 l     F .text	00000028 initFatDirCallback(unsigned long, void*)
00000000 l    df *ABS*	00000000 FatName.cpp
00000000 l    df *ABS*	00000000 FatFile.cpp
00000000 l    df *ABS*	00000000 FatPartition.cpp
00000000 l    df *ABS*	00000000 FatVolume.cpp
00000000 l    df *ABS*	00000000 FatFileLFN.cpp
00006d6a l     F .text	0000001e FatFile::lfnChecksum(unsigned char*) [clone .isra.14]
00000000 l    df *ABS*	00000000 FsFile.cpp
00000000 l    df *ABS*	00000000 FsVolume.cpp
00000000 l    df *ABS*	00000000 FsNew.cpp
00000000 l    df *ABS*	00000000 SdSpiCard.cpp
00007748 l     F .text	00000006 SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]
0000774e l     F .text	00000006 SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]
00000000 l    df *ABS*	00000000 SdioTeensy.cpp
00007f30 l     F .text	00000028 sdIrs()
00007f58 l     F .text	00000018 isBusyCommandComplete()
00007f70 l     F .text	00000010 isBusyCommandInhibit()
00007f80 l     F .text	00000014 isBusyDat()
00007f94 l     F .text	0000000c isBusyDMA()
00007fa0 l     F .text	00000014 isBusyFifoRead()
00007fb4 l     F .text	00000014 isBusyFifoWrite()
00007fc8 l     F .text	00000018 isBusyTransferComplete()
00007fe0 l     F .text	00000098 setSdclk(unsigned long)
000080dc l     F .text	00000024 waitTimeout(bool (*)())
00008100 l     F .text	00000040 yieldTimeout(bool (*)())
00008170 l     F .text	00000054 cardCommand(unsigned long, unsigned long)
000081c4 l     F .text	00000020 statusCMD13()
000081e4 l     F .text	00000010 isBusyCMD13()
000081f8 l     F .text	00000068 readReg16(unsigned long, void*)
00008260 l     F .text	00000020 waitDmaStatus() [clone .part.4]
00008280 l     F .text	0000009c rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)
00008458 l     F .text	0000005c waitTransferComplete()
000087f4 l     F .text	00000098 cardCMD6(unsigned long, unsigned char*)
2001cec4 l     O .bss	00000001 m_version2
2001cec5 l     O .bss	00000010 m_cid
2001ced8 l     O .bss	00000004 m_busyFcn
2001cedc l     O .bss	00000001 m_highCapacity
2001cee0 l     O .bss	00000004 m_ocr
2001cee4 l     O .bss	00000004 m_rca
2001cee8 l     O .bss	00000001 m_transferActive
2001ceec l     O .bss	00000004 m_irqstat
1fff135c l     O .data	00000001 m_errorCode
2001cef0 l     O .bss	00000001 m_initDone
2001cef1 l     O .bss	00000010 m_csd
2001cf01 l     O .bss	00000001 m_dmaBusy
2001cf04 l     O .bss	00000004 m_sdClkKhz
2001cf08 l     O .bss	00000004 m_errorLine
00000000 l    df *ABS*	00000000 memcpy-armv7m.o
00000000 l    df *ABS*	00000000 memset.o
00000000 l    df *ABS*	00000000 usb_serial.c
2001cf0d l     O .bss	00000001 tx_noautoflush
2001cf10 l     O .bss	00000004 tx_packet
2001cf14 l     O .bss	00000001 transmit_previous_timeout
2001cf18 l     O .bss	00000004 rx_packet
00000000 l    df *ABS*	00000000 pins_teensy.c
00009428 l     F .text	00000002 startup_default_middle_hook
00000000 l    df *ABS*	00000000 usb_mem.c
1fff1364 l     O .data	00000004 usb_buffer_available
00000000 l    df *ABS*	00000000 usb_dev.c
000096c4 l     F .text	00000040 endpoint0_transmit
2001cf24 l     O .bss	00000004 ep0_tx_ptr
2001cf28 l     O .bss	00000010 rx_last
2001cf38 l     O .bss	00000004 tx_state
2001cf3c l     O .bss	00000040 ep0_rx0_buf
2001cf7c l     O .bss	00000010 rx_first
2001cf8c l     O .bss	00000001 ep0_tx_bdt_bank
2001cf90 l     O .bss	00000040 ep0_rx1_buf
2001cfd0 l     O .bss	00000010 tx_first
1fff0000 l     O .usbdescriptortable	000000a0 table
2001cfe0 l     O .bss	00000010 tx_last
2001cff0 l     O .bss	00000008 setup
2001cff8 l     O .bss	00000002 ep0_tx_len
2001cffb l     O .bss	00000008 reply_buffer
2001d004 l     O .bss	00000001 ep0_tx_data_toggle
00000000 l    df *ABS*	00000000 yield.cpp
2001d005 l     O .bss	00000001 yield::running
00000000 l    df *ABS*	00000000 DMAChannel.cpp
00000000 l    df *ABS*	00000000 EventResponder.cpp
00000000 l    df *ABS*	00000000 usb_inst.cpp
00000000 l    df *ABS*	00000000 Print.cpp
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 Stream.cpp
00000000 l    df *ABS*	00000000 serialEvent.cpp
00000000 l    df *ABS*	00000000 new.cpp
00000000 l    df *ABS*	00000000 analog.c
2001d035 l     O .bss	00000001 calibrating
1fff137d l     O .data	00000001 analog_config_bits
2001d036 l     O .bss	00000001 analog_reference_internal
1fff137e l     O .data	00000001 analog_num_average
00000000 l    df *ABS*	00000000 usb_desc.c
1fff137f l     O .data	00000012 device_descriptor
1fff13aa l     O .data	00000043 config_descriptor
00000000 l    df *ABS*	00000000 nonstd.c
00000000 l    df *ABS*	00000000 atexit_arm.cc
00000000 l    df *ABS*	00000000 _lshrdi3.o
00000000 l    df *ABS*	00000000 _arm_addsubdf3.o
00000000 l    df *ABS*	00000000 _arm_muldivdf3.o
00000000 l    df *ABS*	00000000 _arm_cmpdf2.o
00000000 l    df *ABS*	00000000 _arm_unorddf2.o
00000000 l    df *ABS*	00000000 _arm_fixdfsi.o
00000000 l    df *ABS*	00000000 _arm_fixunsdfsi.o
00000000 l    df *ABS*	00000000 _arm_truncdfsf2.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 cxa_atexit.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 locale.c
0000b284 l     F .text	00000018 __get_current_locale
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 lib_a-memchr.o
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 sscanf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 lib_a-strlen.o
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strtod.c
0000c0bc l     F .text	00000038 sulp
000130e4 l     O .text	00000014 fpi.6173
00013108 l     O .text	00000014 fpinan.6209
00013120 l     O .text	00000028 tinytens
00000000 l    df *ABS*	00000000 strtol.c
0000cff0 l     F .text	00000136 _strtol_l.isra.0
00000000 l    df *ABS*	00000000 vfprintf.c
00013148 l     O .text	00000010 zeroes.7258
0001319c l     O .text	00000010 blanks.7257
00000000 l    df *ABS*	00000000 vfscanf.c
000131ac l     O .text	00000022 basefix.7328
00000000 l    df *ABS*	00000000 vdprintf.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0000f80c l     F .text	00000014 register_fini
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 dtoa.c
0000f82c l     F .text	00000128 quorem
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
00010a20 l     F .text	000000a8 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 localeconv.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mprec.c
000134e0 l     O .text	0000000c p05.6087
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strtoll.c
00011b88 l     F .text	000001ac _strtoll_l.isra.0
00000000 l    df *ABS*	00000000 strtoul.c
00011d58 l     F .text	00000168 _strtoul_l.isra.0
00000000 l    df *ABS*	00000000 strtoull.c
00011ee4 l     F .text	000001ec _strtoull_l.isra.0
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 vfscanf.c
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vasnprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 impure.c
1fff1420 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 ctype_.c
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.19/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crti.o
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.19/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crtn.o
00000000 l    df *ABS*	00000000 FsDateTime.cpp
00000000 l    df *ABS*	00000000 avr_emulation.cpp
00000000 l    df *ABS*	00000000 HardwareSerial.cpp
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 
1fff1dc8 l       .bss	00000000 __bss_start__
2001d084 l       .bss	00000000 __bss_end__
00000000 l       *UND*	00000000 software_init_hook
00000000 l       *UND*	00000000 hardware_init_hook
00000000 l       *UND*	00000000 __stack
00005c5c  w    F .text	00000026 FatPartition::cacheSync()
000093a4  w    F .text	00000006 adc0_isr
00000ab2  w    F .text	00000066 SDFile::getModifyTime(DateTimeFields&)
00003870 g     F .text	000000a4 toUpcase(unsigned short)
00001b30 g     F .text	00000034 pushData(unsigned long*)
0000ada8 g     F .text	0000002c .hidden __aeabi_dcmpun
00009140 g     F .text	0000001c usb_serial_available
00001338 g     F .text	000001b4 menu()
00011aa8 g     F .text	0000005e __any_on
0000ad6c g     F .text	00000012 .hidden __aeabi_dcmple
1fff0f48 g     O .data	00000020 fsamps
00002344  w    F .text	0000004a i2c_class::write16(unsigned char, unsigned short, unsigned short)
000069bc g     F .text	0000002e FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)
0000aca8 g     F .text	0000007a .hidden __cmpdf2
0000877c g     F .text	00000078 SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)
00009f10  w    F .text	000000d8 yield
1fff1de8 g     O .bss	00000004 acq_miss
000067fc g     F .text	000001c0 FatFile::write(void const*, unsigned int)
0000aca8 g     F .text	0000007a .hidden __eqdf2
000076b8  w    F .text	00000002 SdSpiCard::~SdSpiCard()
0000a238 g     F .text	000000a6 Print::printNumber64(unsigned long long, unsigned char, unsigned char)
1fff1392 g     O .data	00000018 usb_string_manufacturer_name_default
00006792 g     F .text	00000068 FatFile::truncate()
1fff11e0 g     O .data	0000013c Wire1
00003a74 g     F .text	00000458 ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)
2001a97c g     O .bss	00000004 clusterSize
0000a818 g     F .text	0000005a .hidden __floatdidf
0000155c g     F .text	00000024 newHour()
00009370  w    F .text	00000034 hard_fault_isr
000093a4  w    F .text	00000006 dma_ch6_isr
000019b4  w    F .text	00000054 MySpiClass::deactivate()
2001ceb4 g     O .bss	00000004 FsDateTime::callback
00002fb8  w    F .text	000000d8 SPIClass::dma_rxisr()
00003312  w    F .text	00000050 SdBase<FsVolume>::restart()
00005698 g     F .text	0000005c FatFormatter::initPbs()
0000a178 g     F .text	00000020 Print::println()
000026b0 g     F .text	00000114 TwoWire::isr()
000093a4  w    F .text	00000006 uart0_lon_isr
00004308 g     F .text	000000d0 ExFatFile::seekSet(unsigned long long)
00009760 g     F .text	00000078 usb_rx_memory
0000769c  w    F .text	00000004 SdSpiCard::errorCode() const
000009fe  w    F .text	0000000c File::flush()
00000a4c  w    F .text	00000066 SDFile::getCreateTime(DateTimeFields&)
000093a4  w    F .text	00000006 dma_ch8_isr
0000ba60 g     F .text	00000002 __malloc_unlock
00007768 g     F .text	00000026 SdSpiCard::spiStart()
00000fac  w    F .text	00000088 SDFile::openNextFile(unsigned char)
2001cec0 g     O .bss	00000004 FsVolume::m_cwv
00006280 g     F .text	000000a8 FatFile::open(FatFile*, char const*, int)
1fff222c g     O .bss	00000004 SerNum
0000a378 g     F .text	000000b8 analog_init
0000197c  w    F .text	00000014 MySpiClass::begin(SdSpiConfig)
000097d8 g     F .text	00000080 usb_tx
0000cfd0 g     F .text	00000020 _strtod_r
000093a4  w    F .text	00000006 portcd_isr
00001b00  w    F .text	00000016 MySpiClass::setSckSpeed(unsigned long)
0000f6bc g     F .text	0000004a _vdprintf_r
0000636a g     F .text	00000020 FatFile::getCreateDateTime(unsigned short*, unsigned short*)
00002d48 g     F .text	000000a4 SPIClass::setSCK(unsigned char)
00001e54 g     F .text	0000042c saveData(short)
0000a4ec g     F .text	00000018 .hidden __aeabi_llsr
00012560  w    O .text	0000005c vtable for SDFile
000122b4 g     F .text	00000082 _sfread_r
0000b994 g     F .text	000000c6 memmove
0000b2c0 g     F .text	00000014 __locale_ctype_ptr
00008de4 g     F .text	00000060 SdioCard::stopTransmission(bool)
00011220 g     F .text	0000004c _Balloc
000093a4  w    F .text	00000006 can1_rx_warn_isr
0001351c g       .ARM.exidx	00000000 __exidx_end
000093a4  w    F .text	00000006 dma_error_isr
000032d8  w    F .text	0000003a SdBase<FsVolume>::cardBegin(SdSpiConfig)
00006b7a g     F .text	00000046 FatPartition::freeChain(unsigned long)
2001d018 g     O .bss	00000001 EventResponder::runningFromYield
0000794e g     F .text	0000007c SdSpiCard::cardCommand(unsigned char, unsigned long)
00002b58 g     F .text	0000000c i2c0_isr
00001814  w    F .text	0000009c MySpiClass::activate()
0000a14e g     F .text	00000028 Print::write(unsigned char const*, unsigned int)
0000ac98 g     F .text	0000008a .hidden __gtdf2
0000b228 g     F .text	0000000c __errno
00000ca0  w    F .text	0000000a SDFile::isDirectory()
000051e8 g     F .text	00000112 ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
000009d6  w    F .text	0000000c File::write(unsigned char const*, unsigned int)
000093a4  w    F .text	00000006 portd_isr
0000113c g     F .text	0000001c saveParameters()
000093a4  w    F .text	00000006 enet_error_isr
000079ca  w    F .text	0000001e SdSpiCard::cardAcmd(unsigned char, unsigned long)
00002394 g     F .text	00000198 adc_enable()
00012928 g     O .text	00000020 TwoWire::i2c2_hardware
00000bb8  w    F .text	0000001c File::~File()
2001d008 g     O .bss	00000004 EventResponder::firstInterrupt
000111a4 g     F .text	00000004 __localeconv_l
000076ba  w    F .text	0000000e SdSpiCard::~SdSpiCard()
000039c6 g     F .text	0000001c ExFatFormatter::writeUpcaseUnicode(unsigned short)
000004a0 g     F .text	00000028 acq_startClocks()
0000744e g     F .text	00000062 FsBaseFile::FsBaseFile(FsBaseFile const&)
000093a4  w    F .text	00000006 tpm1_isr
00004c14 g     F .text	00000018 ExFatPartition::rootLength()
00000ede  w    F .text	00000036 SDFile::setCreateTime(DateTimeFields const&)
000076a0  w    F .text	00000004 SdSpiCard::errorData() const
0000a140  w    F .text	00000008 usb_serial_class::write(unsigned char const*, unsigned int)
00012e4c g     O .text	00000200 digital_pin_to_info_PGM
00000478 g     F .text	00000028 acq_stopClocks()
2001d080 g     O .bss	00000004 errno
00007b9c g     F .text	00000038 SdSpiCard::readOCR(unsigned long*)
000049a0 g     F .text	0000003e ExFatPartition::fatGet(unsigned long, unsigned long*)
0000bf0c g     F .text	00000004 __seofread
0001351c g       .ARM.exidx	00000000 _etext
00003090 g     F .text	00000010 _spi_dma_rxISR0()
00001df0 g     F .text	0000005c listDisks()
1fff1dc8 g       .bss	00000000 _sbss
000056f4 g     F .text	0000005c FatFormatter::writeMbr()
00001ba8 g     F .text	0000001c sdCsInit(unsigned char)
000033c6 g     F .text	00000054 SDClass::mediaPresent()
0000ad34 g     F .text	00000010 .hidden __aeabi_cdcmple
00008084 g     F .text	0000000c SdioCard::errorData() const
00000d4e  w    F .text	00000018 FsBaseFile::peek()
000086bc g     F .text	000000c0 SdioCard::writeSector(unsigned long, unsigned char const*)
000093a4  w    F .text	00000006 porte_isr
0000084c g     F .text	00000184 loop
000093a4  w    F .text	00000006 portb_isr
000093a4  w    F .text	00000006 spi1_isr
000093a4  w    F .text	00000006 uart3_status_isr
000040dc g     F .text	0000007c ExFatFile::parsePathName(char const*, ExName_t*, char const**)
000093a4  w    F .text	00000006 mcm_isr
00008be8 g     F .text	000000c4 SdioCard::readData(unsigned char*)
000077e6 g     F .text	00000060 SdSpiCard::readData(unsigned char*, unsigned int)
000028a4 g     F .text	000000f8 TwoWire::endTransmission(unsigned char)
2001d00c g     O .bss	00000004 EventResponder::lastInterrupt
000093a4  w    F .text	00000006 uart1_status_isr
000074b0 g     F .text	00000028 FsBaseFile::close()
00008ed0 g     F .text	000001a6 memcpy
000093a4  w    F .text	00000006 randnum_isr
00011008 g     F .text	00000180 __hexnan
0000ad24 g     F .text	00000020 .hidden __aeabi_cdrcmple
000009e2  w    F .text	0000000c File::available()
00001a30  w    F .text	00000014 Print::println(unsigned long)
00003480 g     F .text	00000094 FsUtf::cpToMb(unsigned long, char*, char*)
000010ac g     F .text	00000090 storeConfig(unsigned short*, int)
00004a86 g     F .text	0000005e ExFatPartition::freeChain(unsigned long)
00005f38 g     F .text	00000028 FatFile::peek()
0000d150 g     F .text	000016e4 _svfprintf_r
0000a7a8 g     F .text	00000022 .hidden __floatsidf
1fff2208  w    O .bss	00000001 SDFile::name()::zeroterm
2001cf20 g     O .bss	00000004 systick_millis_count
0000aca0 g     F .text	00000082 .hidden __ltdf2
00005142 g     F .text	000000a6 ExFatFile::rename(ExFatFile*, char const*)
00009370  w    F .text	00000034 bus_fault_isr
00000b58  w    F .text	0000003c SDFile::truncate(unsigned long long)
000027c4 g     F .text	000000e0 TwoWire::wait_idle()
000093a4  w    F .text	00000006 watchdog_isr
0000af04 g     F .text	00000000 .hidden __aeabi_uldivmod
00002b64 g     F .text	0000000c i2c1_isr
2001d003 g     O .bss	00000001 usb_configuration
000093a4  w    F .text	00000006 dma_ch11_isr
0000180e  w    F .text	00000006 SdCardInterface::status()
00008e44 g     F .text	0000001c SdioCard::syncDevice()
0000853c g     F .text	00000094 SdioCard::writeData(unsigned char const*)
00000000  w      *UND*	00000000 __fini_array_end
2001d019 g     O .bss	00000001 SPCRemulation::pinout
00000c6c  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::available()
1fff220a g     O .bss	00000020 store
00005f60 g     F .text	0000003a FatFile::readDirCache(bool)
00011a00 g     F .text	00000060 __ratio
00002b70 g     F .text	0000000c i2c2_isr
1fff1392  w    O .data	00000018 usb_string_manufacturer_name
2001d078 g     O .bss	00000008 usb_rx_byte_count_data
000093a4  w    F .text	00000006 pit1_isr
0000b2d4 g     F .text	00000010 malloc
000093a4  w    F .text	00000006 dma_ch4_isr
00012908 g     O .text	00000020 TwoWire::i2c1_hardware
000093a4  w    F .text	00000006 software_isr
00007754  w    F .text	00000014 SysCall::curTimeMS()
00003362 g     F .text	00000064 SDClass::format(int, char, Print&)
00012510  w    O .text	00000024 vtable for FsFile
00011188 g     F .text	0000001c iswspace
000093a4  w    F .text	00000006 dma_ch7_isr
0000255c  w    F .text	0000001e TwoWire::read()
000133f0 g     O .text	000000c8 __mprec_tens
00009e7c g     F .text	00000094 usb_init
000076b4  w    F .text	00000004 SdSpiCard::type() const
0000ae24 g     F .text	00000040 .hidden __fixunsdfsi
000093a4  w    F .text	00000006 lptmr_isr
00000de4  w    F .text	00000058 SDFile::seek(unsigned long long, int)
2001d040 g     O .bss	00000004 __malloc_top_pad
00009408 g     F .text	00000020 rtc_set
00012278 g     F .text	0000003a __ssrefill_r
00007846 g     F .text	0000006a SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
000052fa g     F .text	000000be ExFatFile::truncate()
1fff0f30 g     O .data	00000000 .hidden __dso_handle
0000a788 g     F .text	0000001e .hidden __aeabi_ui2d
000111a8 g     F .text	0000001c _localeconv_r
1fff0f44 g     O .data	00000004 sd_str
000120d0 g     F .text	00000024 _strtoull_r
000093ec g     F .text	00000010 attachInterruptVector
00011434 g     F .text	00000012 __i2b
1fff0f30 g       .data	00000000 _sdata
000128e8 g     O .text	00000020 TwoWire::i2c0_hardware
00005854 g     F .text	000001a8 FatFormatter::makeFat32()
0000af34 g     F .text	000002e2 .hidden __udivmoddi4
0000a504 g     F .text	00000000 .hidden __aeabi_drsub
00005c82 g     F .text	00000036 FatFile::addCluster()
0000be44 g     F .text	00000024 _sbrk_r
00007bd4 g     F .text	00000036 SdSpiCard::readRegister(unsigned char, void*)
00008150 g     F .text	00000020 SdioCard::type() const
000001d0 g     F .text	000001f0 ResetHandler
000090bc g     F .text	0000004c usb_serial_getchar
000093a4  w    F .text	00000006 can1_bus_off_isr
00001a64  w    F .text	00000018 FsVolume::clusterCount() const
000093a4  w    F .text	00000006 ftm2_isr
00000b18  w    F .text	00000040 SDFile::name()
2001d06c g     O .bss	00000008 usb_cdc_line_coding
0000942c g     F .text	00000040 digitalWrite
2001d010 g     O .bss	00000004 EventResponder::lastYield
000093a4  w    F .text	00000006 uart5_status_isr
000093a4  w    F .text	00000006 lpuart0_status_isr
000040b6 g     F .text	00000026 ExFatFile::openRoot(ExFatVolume*)
00013076 g     O .text	00000004 usb_endpoint_config_table
000093a4  w    F .text	00000006 dma_ch9_isr
00000760  w    F .text	0000001c Print::write(char const*)
00000d92  w    F .text	00000020 StreamFile<FsBaseFile, unsigned long long>::read()
000093a4  w    F .text	00000006 pit2_isr
0000395c g     F .text	00000028 ExFatFormatter::syncUpcase()
00000ea8  w    F .text	00000036 SDFile::setModifyTime(DateTimeFields const&)
0000ad58 g     F .text	00000012 .hidden __aeabi_dcmplt
00012a30 g     O .text	0000005c SPISettings::ctar_clock_table
2001d03c g     O .bss	00000004 __malloc_max_sbrked_mem
00000be8  w    F .text	00000018 SDFile::position()
0000946c g     F .text	00000064 pinMode
000014ec g     F .text	00000034 getTeensySerial()
00007e2a g     F .text	00000028 SdSpiCard::writeStop()
00009680 g     F .text	00000044 usb_free
000093a4  w    F .text	00000006 i2c3_isr
0000a7cc g     F .text	0000003a .hidden __extendsfdf2
0000e834 g     F .text	00000e88 __ssvfscanf_r
0000aac8 g     F .text	000001d0 .hidden __aeabi_ddiv
00000d7a  w    F .text	00000018 FsBaseFile::read(void*, unsigned int)
0000a510 g     F .text	00000276 .hidden __adddf3
1fff0f68 g     O .data	0000013c Wire2
00000798 g     F .text	00000030 checkToCloseFile(short, unsigned long)
00007e9e g     F .text	0000002c SdSpiCard::writeData(unsigned char const*)
000009ee  w    F .text	00000010 File::peek()
00006bc0 g     F .text	0000005c FatPartition::freeClusterCount()
00001034  w    F .text	00000078 SDClass::open(char const*, unsigned char)
00011874 g     F .text	000000d0 __b2d
0000238e g     F .text	00000002 adc_init()
00013514 g       .ARM.exidx	00000000 __exidx_start
0000a874 g     F .text	00000254 .hidden __aeabi_dmul
0000046c  w    F .text	0000000c DMAChannel::~DMAChannel()
00007d68 g     F .text	00000030 SdSpiCard::writeStart(unsigned long)
000093a4  w    F .text	00000006 pit0_isr
2001d014 g     O .bss	00000004 EventResponder::firstYield
000130d0 g     O .text	00000004 _global_impure_ptr
0000077c  w    F .text	00000008 Print::print(unsigned long)
000093a4  w    F .text	00000006 can1_error_isr
00003514 g     F .text	00000084 FsUtf::mbToCp(char const*, char const*, unsigned long*)
00000f32  w    F .text	00000018 StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)
00000f70  w    F .text	0000003c SDFile::SDFile(FsFile const&)
0000ba64 g     F .text	000003de _realloc_r
00000db2  w    F .text	0000000a SDFile::read(void*, unsigned int)
0000b234 g     F .text	00000050 __libc_init_array
2001d084 g       .bss	00000000 __bss_end
00000caa  w    F .text	00000028 SDFile::rewindDirectory()
00002550  w    F .text	0000000c TwoWire::available()
000093a4  w    F .text	00000006 can0_wakeup_isr
000047e2 g     F .text	0000000e ExFatFile::open(ExFatVolume*, char const*, int)
00008090 g     F .text	0000001c SdioCard::readCID(CID*)
000132ec g     O .text	00000100 __hexdig
00004f5e g     F .text	000000de ExFatFile::addDirCluster()
000093a4  w    F .text	00000006 flash_cmd_isr
00007cb0 g     F .text	00000076 SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)
00007e52 g     F .text	0000004c SdSpiCard::writeData(unsigned char, unsigned char const*)
000134b8 g     O .text	00000028 __mprec_bigtens
00011300 g     F .text	00000098 __s2b
0000299c g     F .text	000001bc TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)
0000a128  w    F .text	00000004 usb_serial_class::clear()
0000a788 g     F .text	0000001e .hidden __floatunsidf
000093a4  w    F .text	00000006 uart2_status_isr
000093bc g     F .text	0000002c _sbrk
000018b0  w    F .text	0000001c MySpiClass::send(unsigned char)
000116c8 g     F .text	00000042 __mcmp
00012a8c g     O .text	00000030 vtable for SDClass
1fff1360 g     O .data	00000004 __brkval
2001cf1c g     O .bss	00000001 usb_cdc_line_rtsdtr
00009328 g     F .text	00000048 usb_serial_flush_callback
000134ec g     F .text	00000000 _init
00005d44 g     F .text	0000001e FatFile::cacheDirEntry(unsigned char)
000093a4  w    F .text	00000006 svcall_isr
0000313a  w    F .text	00000056 SDClass::remove(char const*)
00000ce4  w    F .text	00000026 SDFile::close()
000093a4  w    F .text	00000006 dma_ch15_isr
00000d0c  w    F .text	00000024 SDFile::~SDFile()
0000ae64 g     F .text	0000009e .hidden __aeabi_d2f
00012948 g     O .text	00000024 vtable for TwoWire
000093a4  w    F .text	00000006 uart1_error_isr
0001078c g     F .text	00000028 __libc_fini_array
0000c0f8 g     F .text	00000ed8 _strtod_l
00010fd8 g     F .text	00000030 __match
000093a4  w    F .text	00000006 usbhs_phy_isr
2001d084 g       .bss	00000000 _ebss
00008644 g     F .text	00000078 SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
1fff2230 g     O .bss	00000004 hour_
00000e50  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::flush()
0000233c  w    F .text	00000008 TwoWire::write(int)
000017da  w    F .text	00000034 BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)
00011398 g     F .text	00000040 __hi0bits
0000402a g     F .text	00000038 ExFatFile::dirCache(unsigned char, unsigned char)
0000add4 g     F .text	0000004e .hidden __fixdfsi
0000503c g     F .text	00000048 ExFatFile::mkdir(ExFatFile*, ExName_t*)
000093a4 g     F .text	00000006 unused_isr
00000f70  w    F .text	0000003c SDFile::SDFile(FsFile const&)
000093a4  w    F .text	00000006 spi0_isr
000093a4  w    F .text	00000006 dma_ch3_isr
000030a0  w    F .text	00000002 SDClass::~SDClass()
00004c2c g     F .text	00000054 ExFatVolume::chdir(char const*)
0000046c  w    F .text	0000000c DMAChannel::~DMAChannel()
2001b9e0 g     O .bss	00001000 diskBuffer
2001a458 g     O .bss	000004c8 sdx
00007020 g     F .text	00000092 FatFile::makeUniqueSfn(FatName_t*)
00000bb8  w    F .text	0000001c File::~File()
00001be0 g     F .text	00000210 storage_configure()
000059fc g     F .text	000000a0 FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)
00005ab6 g     F .text	00000028 FatFile::getLfnChar(DirLfn_t*, unsigned char)
0000a374 g     F .text	00000004 operator delete(void*, unsigned int)
000093a4  w    F .text	00000006 flash_error_isr
0000a4ec g     F .text	00000018 .hidden __lshrdi3
0000a510 g     F .text	00000276 .hidden __aeabi_dadd
1fff2234 g     O .bss	00000014 file
0000aca0 g     F .text	00000082 .hidden __ledf2
000093a4  w    F .text	00000006 uart5_error_isr
000093a4  w    F .text	00000006 rtc_seconds_isr
0001299c g     O .text	00000094 SPIClass::spi0_hardware
000093a4  w    F .text	00000006 pdb_isr
00011578 g     F .text	000000a0 __pow5mult
000061a0 g     F .text	0000004e FatFile::rmdir()
0000a808 g     F .text	0000006a .hidden __aeabi_ul2d
00009370  w    F .text	00000034 usage_fault_isr
000093a4  w    F .text	00000006 dac1_isr
00000000 g     O .text	000001d0 _VectorsFlash
00006afa g     F .text	00000080 FatPartition::allocateCluster(unsigned long, unsigned long*)
000093a4  w    F .text	00000006 dma_ch14_isr
0000a0d2  w    F .text	00000006 MillisTimer::enableTimerInterrupt(bool)
000030a2  w    F .text	00000044 SDClass::exists(char const*)
00000000  w      *UND*	00000000 __deregister_frame_info
2001d074 g     O .bss	00000004 usb_cdc_line_rtsdtr_millis
00000784  w    F .text	00000014 Print::println(char const*)
0000a118 g     F .text	00000010 systick_isr
000006c0 g     F .text	0000001e extract(void*, void*)
000012ec g     F .text	0000004c menuGet3Int(int*, int*, int*)
000093a4  w    F .text	00000006 rtc_alarm_isr
2001b9d0 g     O .bss	0000000c mySpi
00007c4a g     F .text	00000066 SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)
000093a4  w    F .text	00000006 dma_ch2_isr
1fff136c g     O .data	00000010 Serial
000093a4  w    F .text	00000006 ftm1_isr
0000a148  w    F .text	00000006 usb_serial_class::write(unsigned char)
00007556 g     F .text	0000005e FsBaseFile::openNext(FsBaseFile*, int)
000093ac  w    F .text	0000000c startup_early_hook
00007eca g     F .text	00000048 SdSpiCard::writeSingle(unsigned long, unsigned char const*)
000093a4  w    F .text	00000006 dma_ch13_isr
00004cd4 g     F .text	00000092 ExFatFile::addCluster()
00012534  w    O .text	0000002c vtable for File
000093a4  w    F .text	00000006 uart2_error_isr
0000326c  w    F .text	00000036 SDClass::usedSize()
00009108 g     F .text	00000038 usb_serial_peekchar
0000ad94 g     F .text	00000012 .hidden __aeabi_dcmpgt
00001158 g     F .text	000000d4 printMenu()
0000b890 g     F .text	00000000 memchr
00006a9e g     F .text	0000005c FatPartition::fatPut(unsigned long, unsigned long)
1fff1408 g     O .data	00000016 usb_string_serial_number_default
00009370 g     F .text	00000034 fault_isr
00010850 g     F .text	000001d0 _free_r
000084b4 g     F .text	00000088 SdioCard::readStop()
00003822 g     F .text	0000004e FsCache::get(unsigned long, unsigned char)
0000b29c g     F .text	0000001c __locale_mb_cur_max
0000ad80 g     F .text	00000012 .hidden __aeabi_dcmpge
000093a4  w    F .text	00000006 usb_charge_isr
00006ef8 g     F .text	00000128 FatFile::makeSFN(FatName_t*)
0000a138  w    F .text	00000004 usb_serial_class::flush()
000039e2 g     F .text	00000090 ExFatFormatter::writeUpcase(unsigned long)
000121f4 g     F .text	00000082 _sungetc_r
000093a4  w    F .text	00000006 cmt_isr
0000a50c g     F .text	0000027a .hidden __aeabi_dsub
00006c1c g     F .text	00000108 FatPartition::init(BlockDeviceInterface*, unsigned char)
000093a4  w    F .text	00000006 usbhs_isr
1fff1dc4 g     O .data	00000004 __malloc_sbrk_base
0000a130  w    F .text	00000004 usb_serial_class::read()
000093a4  w    F .text	00000006 ftm3_isr
00011d34 g     F .text	00000024 _strtoll_r
000093a4  w    F .text	00000006 tsi0_isr
0000739c g     F .text	000000b2 FatFile::remove()
0000a808 g     F .text	0000006a .hidden __floatundidf
2001a454 g     O .bss	00000004 msd
000093e8  w    F .text	00000002 __cxa_pure_virtual
00002390 g     F .text	00000002 adcStatus()
00011618 g     F .text	000000ae __lshift
000064a4 g     F .text	000000aa FatFile::mkdir(FatFile*, char const*, bool)
000004e0 g     F .text	00000014 acq_stop()
000093a4  w    F .text	00000006 spi2_isr
000120f4 g     F .text	00000100 __ssprint_r
000123b0 g     F .text	0000005e _vasnprintf_r
0000a36e  w    F .text	00000002 serialEvent()
2001cf8d g     O .bss	00000001 usb_reboot_timer
0000f768 g     F .text	000000a4 __register_exitproc
00004728 g     F .text	000000ba ExFatFile::open(ExFatFile*, char const*, int)
0000c01c g     F .text	000000a0 strncmp
00000e64  w    F .text	00000044 FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
00005084 g     F .text	000000be ExFatFile::mkdir(ExFatFile*, char const*, bool)
00005750 g     F .text	00000104 FatFormatter::makeFat16()
0000915c g     F .text	00000030 usb_serial_flush_input
2001c9e0 g     O .bss	00000004 fsamp
00004ae4 g     F .text	00000064 ExFatPartition::freeClusterCount()
00011448 g     F .text	00000130 __multiply
1fff1de4 g     O .bss	00000004 acq_count
0000926c g     F .text	00000016 usb_serial_putchar
00000022 g       *ABS*	00000000 _teensy_model_identifier
2001d044 g     O .bss	00000028 __malloc_current_mallinfo
00011944 g     F .text	000000ba __d2b
2001d01c g     O .bss	00000018 HardwareSerial::s_serials_with_serial_events
000093a4  w    F .text	00000006 can0_bus_off_isr
00008140  w    F .text	0000000e SdioCard::~SdioCard()
00001af4  w    F .text	0000000c SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)
2001cffa g     O .bss	00000001 usb_rx_memory_needed
000085d0 g     F .text	00000074 SdioCard::writeStart(unsigned long)
00011ec0 g     F .text	00000024 _strtoul_r
00009858 g     F .text	00000624 usb_isr
0000b21c g     F .text	0000000c __cxa_atexit
00004158 g     F .text	00000184 ExFatFile::read(void*, unsigned int)
2001c9e4 g     O .bss	00000004 i2c
0000a7a8 g     F .text	00000022 .hidden __aeabi_i2d
00000d70  w    F .text	0000000a SDFile::peek()
000037d6 g     F .text	0000004c FsCache::sync()
1fff131c g     O .data	00000040 SPI
0000b930 g     F .text	00000062 memcmp
0001304c  w    O .text	00000028 vtable for usb_serial_class
00006e24 g     F .text	000000d4 FatFile::createLFN(unsigned short, FatName_t*, unsigned char)
000093a4  w    F .text	00000006 uart3_error_isr
00001bc4 g     F .text	0000001c sdCsWrite(unsigned char, bool)
0000beb4 g     F .text	00000058 sscanf
0000b218  w    F .text	00000002 .hidden __aeabi_ldiv0
00004dec g     F .text	00000052 ExFatFile::rmdir()
000012b0 g     F .text	0000003c menuGetInt(int*)
000093a4  w    F .text	00000006 porta_isr
00001a44  w    F .text	00000020 FsVolume::bytesPerCluster() const
0000aac8 g     F .text	000001d0 .hidden __divdf3
00011a60 g     F .text	00000046 __copybits
1fff0bd0 g     O .usbbuffers	00000360 usb_buffer_memory
000076c8 g     F .text	00000080 SdSpiCard::sectorCount()
000093a4  w    F .text	00000006 low_voltage_isr
1fff19b8 g     O .data	00000408 __malloc_av_
000093a4  w    F .text	00000006 can0_error_isr
1fff21f4 g     O .bss	00000004 max_write
00009538 g     F .text	0000010c _init_Teensyduino_internal_
00000e5a  w    F .text	0000000a SDFile::flush()
0000a874 g     F .text	00000254 .hidden __muldf3
000092cc g     F .text	0000005c usb_serial_flush_output
000093a4  w    F .text	00000006 dma_ch12_isr
0000ba5c g     F .text	00000002 __malloc_lock
00003f18 g     F .text	000000b0 ExFatFile::getName8(char*, unsigned int)
00000000  w      *UND*	00000000 __fini_array_start
000093a4  w    F .text	00000006 can1_wakeup_isr
1fff0a00 g     O .dmabuffers	000001d0 _VectorsRam
000055f0 g     F .text	000000a8 FatFormatter::initFatDir(unsigned char, unsigned long)
00012410 g     F .text	0000005e _calloc_r
000093a4  w    F .text	00000006 pit3_isr
00002ba0 g     F .text	00000078 SPIClass::begin()
1fff0f38 g     O .data	00000004 t_acq
1fff1368 g     O .data	00000001 yield_active_check_flags
000093a4  w    F .text	00000006 enet_rx_isr
00004f20 g     F .text	0000003e ExFatFile::sync()
0000654e g     F .text	00000196 FatFile::rename(FatFile*, char const*)
00008e60 g     F .text	00000070 SdioCard::isBusy()
000093a4  w    F .text	00000006 portc_isr
00007d26 g     F .text	00000026 SdSpiCard::readStop()
00009078 g     F .text	00000000 memset
00001b18 g     F .text	00000018 getCount()
0000a2de g     F .text	00000010 main
1fff2200 g     O .bss	00000004 max_count
2001a974 g     O .bss	00000008 rawData
2001d038 g     O .bss	00000004 __malloc_max_total_mem
0000481e g     F .text	000000a6 ExFatPartition::bitmapFind(unsigned long, unsigned long)
00001e4c g     F .text	00000006 checkReboot()
000053b8 g     F .text	00000210 ExFatFile::write(void const*, unsigned int)
00009370  w    F .text	00000034 memmanage_fault_isr
00003748 g     F .text	0000008e lbaToMbrChs(unsigned char*, unsigned long, unsigned long)
00006336 g     F .text	00000034 FatFile::dirEntry(DirFat_t*)
00000c76  w    F .text	0000000a SDFile::available()
00000f54  w    F .text	0000001c File::close()
0000a430 g     F .text	00000070 usb_init_serialnumber
0000176c g     F .text	00000036 setRTCTime(int, int, int, int, int, int)
0000d128 g     F .text	00000024 _strtol_r
0000ae64 g     F .text	0000009e .hidden __truncdfsf2
00013510 g       .text	00000000 __init_array_end
0000f958 g     F .text	00000e34 _dtoa_r
0000b2f4 g     F .text	00000570 _malloc_r
2001d034 g     O .bss	00000001 HardwareSerial::s_count_serials_with_serial_events
000093a4  w    F .text	00000006 debugmonitor_isr
0000f720 g     F .text	0000001a __ascii_wctomb
00000d44  w    F .text	0000000a SDFile::isOpen()
0000744e g     F .text	00000062 FsBaseFile::FsBaseFile(FsBaseFile const&)
0000a818 g     F .text	0000005a .hidden __aeabi_l2d
2001cebc g     O .bss	00000004 FatVolume::m_cwv
00001a28  w    F .text	00000008 Print::print(char const*)
00012338 g     F .text	00000078 __submore
0000a328 g     F .text	00000046 Stream::readBytesUntil(char, char*, unsigned int)
00002dec g     F .text	000001cc SPIClass::transfer(void const*, void*, unsigned int)
62037937 g       *ABS*	00000000 __rtc_localtime
000094d0 g     F .text	0000003c micros
00000000  w      *UND*	00000000 __libc_fini
000093a4  w    F .text	00000006 cmp1_isr
000093a4  w    F .text	00000006 ftm0_isr
00004e40 g     F .text	000000e0 ExFatFile::syncDir()
000025f0 g     F .text	00000034 TwoWire::setClock(unsigned long)
000107b4 g     F .text	0000009c _malloc_trim_r
1fff1404 g     O .data	00000004 string0
0000918c g     F .text	000000e0 usb_serial_write
000093b8  w    F .text	00000002 startup_late_hook
00000c18  w    F .text	00000054 FsBaseFile::available() const
0000a134  w    F .text	00000004 usb_serial_class::available()
1fff137c g     O .data	00000001 _serialEvent_default
000061f0 g     F .text	00000080 FatFile::sync()
00000538 g     F .text	00000188 acq_init(int)
00006d88 g     F .text	0000009c FatFile::cmpName(unsigned short, FatName_t*, unsigned char)
00003190  w    F .text	0000004e SDClass::mkdir(char const*)
00004cae  w    F .text	00000026 ExFatPartition::cacheSync()
1fff13ee  w    O .data	00000016 usb_string_product_name
0000950c g     F .text	0000002a delay
0000aca8 g     F .text	0000007a .hidden __nedf2
000093a4  w    F .text	00000006 tpm0_isr
2001d006 g     O .bss	00000002 dma_channel_allocated_mask
00004096 g     F .text	00000020 ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)
00000dbc  w    F .text	00000028 FsBaseFile::seekSet(unsigned long long)
00013510 g     F .fini	00000000 _fini
00000e3c  w    F .text	00000014 FsBaseFile::sync()
00002592 g     F .text	00000026 TwoWire::write(unsigned char)
0001296c g     O .text	0000002e SPISettings::ctar_div_table
00007c1a g     F .text	00000030 SdSpiCard::readStart(unsigned long)
000047f0 g     F .text	0000002e ExFatFile::openNext(ExFatFile*, int)
000078b0 g     F .text	00000076 SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)
0000be68 g     F .text	0000004c sprintf
0000a198 g     F .text	0000001a Print::printf(char const*, ...)
000093a4  w    F .text	00000006 i2s0_rx_isr
000093a4  w    F .text	00000006 uart4_error_isr
0000a228 g     F .text	00000010 Print::print(long)
00006270 g     F .text	00000010 FatFile::close()
00000d30  w    F .text	00000014 SDFile::~SDFile()
0000f820 g     F .text	0000000c atexit
000080d8  w    F .text	00000002 SdioCard::~SdioCard()
00000d66  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::peek()
00000a30  w    F .text	0000001c File::write(unsigned char)
0000f73c g     F .text	0000002c _write_r
2001c9ec g     O .bss	000004c8 SD
00001580 g     F .text	0000012c breakTime(unsigned long, tmElements_t&)
00008380 g     F .text	000000d8 SdioCard::erase(unsigned long, unsigned long)
00006a14  w    F .text	00000020 FsCache::clear()
000093a4  w    F .text	00000006 can0_message_isr
00002c18 g     F .text	0000009c SPIClass::setMOSI(unsigned char)
00011b7c g     F .text	0000000c nanf
1fff1848 g     O .data	00000004 _impure_ptr
000124c8  w    O .text	00000024 vtable for Stream
000093a4  w    F .text	00000006 can1_message_isr
000042dc g     F .text	0000002c ExFatFile::peek()
000124ec  w    O .text	00000024 vtable for StreamFile<FsBaseFile, unsigned long long>
000111c4 g     F .text	0000005c _mbrtowc_r
000093a4  w    F .text	00000006 nmi_isr
1fff10a4 g     O .data	0000013c Wire
00001a94  w    F .text	00000060 SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)
00000f4a  w    F .text	0000000a SDFile::write(void const*, unsigned int)
00007670 g     F .text	00000028 FsVolume::open(char const*, int)
00008078 g     F .text	0000000c SdioCard::errorCode() const
00006328 g     F .text	0000000e FatFile::open(FatVolume*, char const*, int)
00000f28  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)
1fff2250 g     O .bss	00000004 diskSize
000134f8 g       .text	00000000 __preinit_array_end
000018ce g     F .text	00000076 dateTime(unsigned short*, unsigned short*, unsigned char*)
000076b8  w    F .text	00000002 SdSpiCard::~SdSpiCard()
000093a4  w    F .text	00000006 sdhc_isr
00004b48 g     F .text	000000cc ExFatPartition::init(BlockDeviceInterface*, unsigned char)
0000496a g     F .text	00000036 ExFatPartition::dirCache(DirPos_t*, unsigned char)
00007d98 g     F .text	00000092 SdSpiCard::erase(unsigned long, unsigned long)
0000b864 g     F .text	0000002a __ascii_mbtowc
000077b4 g     F .text	00000032 SdSpiCard::isBusy()
00011820 g     F .text	00000054 __ulp
00012d8c g     O .text	00000060 vtable for SdSpiCard
00007c12  w    F .text	00000008 SdSpiCard::readCID(CID*)
0000257a  w    F .text	00000016 TwoWire::peek()
00002590  w    F .text	00000002 TwoWire::flush()
000007c8 g     F .text	00000084 setup
0001307c g     O .text	00000054 usb_descriptor_list
00009704 g     F .text	00000038 usb_rx
000081f4 g     F .text	00000004 SdioCard::status()
000093a4  w    F .text	00000006 dma_ch10_isr
00001944  w    F .text	00000014 MySpiClass::send(unsigned char const*, unsigned int)
0000638a g     F .text	00000020 FatFile::getModifyDateTime(unsigned short*, unsigned short*)
000009d4  w    F .text	00000002 Print::flush()
00000cd2  w    F .text	00000012 FsBaseFile::isOpen() const
0000ae24 g     F .text	00000040 .hidden __aeabi_d2uiz
000093a4  w    F .text	00000006 uart0_error_isr
00000c80  w    F .text	00000020 FsBaseFile::isDir() const
000030e6  w    F .text	00000054 SDClass::rmdir(char const*)
000127f8  w    O .text	00000028 vtable for MySpiClass
00009644 g     F .text	0000003c usb_malloc
00005dc0 g     F .text	00000178 FatFile::read(void*, unsigned int)
000093a4  w    F .text	00000006 i2s0_isr
00005d62 g     F .text	00000030 FatFile::openRoot(FatVolume*)
2001ceb8 g     O .bss	00000004 ExFatVolume::m_cwv
00001a7c  w    F .text	00000018 FsVolume::freeClusterCount() const
20030000 g       .bss	00000000 _estack
00007698 g     F .text	00000004 operator new(unsigned int, unsigned long*)
00007c0a  w    F .text	00000008 SdSpiCard::readCSD(csd_t*)
0000a090 g     F .text	00000034 DMAChannel::release()
00000a0a  w    F .text	00000026 File::read()
00009284 g     F .text	00000048 usb_serial_write_buffer_free
00007926 g     F .text	00000028 SdSpiCard::waitNotBusy(unsigned short)
0000778e g     F .text	00000026 SdSpiCard::spiStop()
000093a4  w    F .text	00000006 enet_timer_isr
000070b4 g     F .text	00000250 FatFile::open(FatFile*, FatName_t*, int)
0000ad44 g     F .text	00000012 .hidden __aeabi_dcmpeq
000016ac g     F .text	000000c0 makeTime(tmElements_t const&)
000025b8 g     F .text	00000038 TwoWire::write(unsigned char const*, unsigned int)
00000bd4  w    F .text	00000014 File::~File()
00001520 g     F .text	0000003c _write
1fff1dc8 g       .data	00000000 _edata
00004a4c g     F .text	0000003a ExFatPartition::fatPut(unsigned long, unsigned long)
000080d8  w    F .text	00000002 SdioCard::~SdioCard()
000093a4  w    F .text	00000006 i2s0_tx_isr
000093a4  w    F .text	00000006 adc1_isr
00003914 g     F .text	00000048 FsName::get16()
00007d4c g     F .text	0000001c SdSpiCard::syncDevice()
00003fc8 g     F .text	00000062 ExFatFile::hashName(ExName_t*)
00005cb8 g     F .text	0000008c FatFile::addDirCluster()
000063aa g     F .text	000000fa FatFile::mkdir(FatFile*, FatName_t*)
0000a13c  w    F .text	00000004 usb_serial_class::availableForWrite()
000093a4  w    F .text	00000006 cmp0_isr
00001a08  w    F .text	00000020 MySpiClass::receive()
000069ea g     F .text	0000002a FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)
0000a4a0 g     F .text	00000040 ultoa
000030a0  w    F .text	00000002 SDClass::~SDClass()
000079e8 g     F .text	000001b4 SdSpiCard::begin(SdSpiConfig)
00002624 g     F .text	0000008c TwoWire::begin()
000074d8 g     F .text	0000007e FsBaseFile::open(FsVolume*, char const*, int)
0000a0c4  w    F .text	0000000e MillisTimer::disableTimerInterrupt()
0000a370 g     F .text	00000004 operator new(unsigned int)
0000a0d8 g     F .text	0000003c EventResponder::runFromInterrupt()
0000122c g     F .text	00000084 printMenuEntries()
1fff1dc0 g     O .data	00000004 __malloc_trim_threshold
0000a12c  w    F .text	00000004 usb_serial_class::peek()
0001170c g     F .text	00000114 __mdiff
000080c8 g     F .text	00000010 SdioCard::readOCR(unsigned long*)
0000add4 g     F .text	0000004e .hidden __aeabi_d2iz
00004a08 g     F .text	00000044 ExFatPartition::dirSeek(DirPos_t*, unsigned long)
2001cf0c g     O .bss	00000001 usb_cdc_transmit_flush_timer
00005b68 g     F .text	000000f0 FatFile::getName8(char*, unsigned int)
000043d8 g     F .text	00000350 ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)
000093a4  w    F .text	00000006 pit_isr
000084b4 g     F .text	00000088 SdioCard::writeStop()
00007f12  w    F .text	0000001c SdSpiCard::writeSector(unsigned long, unsigned char const*)
00011b08 g     F .text	00000072 __sccl
00004062 g     F .text	00000014 ExFatFile::close()
000131d8 g     O .text	00000101 _ctype_
000093a4  w    F .text	00000006 dac0_isr
000076a4  w    F .text	00000010 SdSpiCard::readSector(unsigned long, unsigned char*)
000134f8 g       .text	00000000 __init_array_start
0000b218  w    F .text	00000002 .hidden __aeabi_idiv0
000093a4  w    F .text	00000006 can1_tx_warn_isr
0000ada8 g     F .text	0000002c .hidden __unorddf2
2001b9dc g     O .bss	00000004 disk_count
00003984 g     F .text	00000042 ExFatFormatter::writeUpcaseByte(unsigned char)
00003598 g     F .text	000001b0 FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)
000031de  w    F .text	00000068 SDClass::rename(char const*, char const*)
000093a4  w    F .text	00000006 uart0_status_isr
00006d24 g     F .text	00000046 FatVolume::chdir(char const*)
000004c8 g     F .text	00000018 acq_start()
000093a4  w    F .text	00000006 mcg_isr
0000a2f0 g     F .text	00000038 Stream::timedRead()
00000400 g     O .text	00000010 flashconfigbytes
00009fe8 g     F .text	000000a8 DMAChannel::begin(bool)
0000bf40 g     F .text	000000dc strlen
00005d92 g     F .text	0000002e FatFile::openCluster(FatFile*)
0000b2b8 g     F .text	00000006 __locale_ctype_ptr_l
000032a2  w    F .text	00000036 SdBase<FsVolume>::begin(SdioConfig)
0000ad34 g     F .text	00000010 .hidden __aeabi_cdcmpeq
0000ac98 g     F .text	0000008a .hidden __gedf2
00005f9a g     F .text	000000ac FatFile::seekSet(unsigned long)
00007304 g     F .text	00000098 FatFile::parsePathName(char const*, FatName_t*, char const**)
00010ac8 g     F .text	00000510 __gethex
1fff13ee g     O .data	00000016 usb_string_product_name_default
0000f708 g     F .text	00000018 vdprintf
000093a4  w    F .text	00000006 dma_ch1_isr
0000831c g     F .text	00000064 SdioCard::sectorCount()
000075b4 g     F .text	000000bc FsVolume::begin(BlockDeviceInterface*)
00001958  w    F .text	00000024 MySpiClass::receive(unsigned char*, unsigned int)
0000973c g     F .text	00000024 usb_tx_packet_count
00006108 g     F .text	00000098 FatFile::openNext(FatFile*, int)
1fff2248 g     O .bss	00000004 diskSpace
000004f4 g     F .text	00000044 mckl_init(int, int, int)
00009428  w    F .text	00000002 startup_middle_hook
00012dec g     O .text	00000060 vtable for SdioCard
0000a7cc g     F .text	0000003a .hidden __aeabi_f2d
000093a4  w    F .text	00000006 dma_ch5_isr
00005c58 g     F .text	00000004 FatFile::getName(char*, unsigned int)
000093a4  w    F .text	00000006 can0_rx_warn_isr
00001af4  w    F .text	0000000c SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)
000093a4  w    F .text	00000006 can0_tx_warn_isr
000093a4  w    F .text	00000006 uart4_status_isr
00008cac g     F .text	00000074 SdioCard::readStart(unsigned long)
00000000  w      *UND*	00000000 _Jv_RegisterClasses
00005a9c  w    F .text	0000001a FatFile::cacheDir(unsigned short)
0000a50c g     F .text	0000027a .hidden __subdf3
00001b64 g     F .text	00000044 pullData(unsigned long*, unsigned long)
000134f8 g       .text	00000000 __preinit_array_start
000048c4 g     F .text	000000a6 ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)
00000f14  w    F .text	00000014 FsBaseFile::write(void const*, unsigned int)
1fff2254 g     O .bss	00028000 data_buffer
000113d8 g     F .text	0000005a __lo0bits
000049de g     F .text	0000002a ExFatPartition::chainSize(unsigned long)
00006046 g     F .text	000000c2 FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)
000066e4 g     F .text	000000ae FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
1fff0f3c g     O .data	00000004 stdPrint
000017a2  w    F .text	00000038 BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)
0000a4e0 g     F .text	0000000a __aeabi_atexit
00000000  w      *UND*	00000000 __register_frame_info
000093fc g     F .text	0000000c rtc_get
00004d66 g     F .text	00000086 ExFatFile::remove()
000093a4  w    F .text	00000006 cmp2_isr
0000a114 g     F .text	00000004 pendablesrvreq_isr
00003246  w    F .text	00000026 SDClass::totalSize()
000009d0  w    F .text	00000004 Print::availableForWrite()
1fff184c g     O .data	0000016c __global_locale
000093a4  w    F .text	00000006 wakeup_isr
00002cb4 g     F .text	00000094 SPIClass::setMISO(unsigned char)
0000888c g     F .text	0000035c SdioCard::begin(SdioConfig)
00004076 g     F .text	00000020 ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)
000093a4  w    F .text	00000006 cmp3_isr
0000a1b2 g     F .text	00000076 Print::printNumber(unsigned long, unsigned char, unsigned char)
00006a34 g     F .text	0000006a FatPartition::fatGet(unsigned long, unsigned long*)
0000b2e4 g     F .text	00000010 free
000093a4  w    F .text	00000006 tpm2_isr
00003ecc g     F .text	0000004c ExFatFile::cmpName(DirName_t const*, ExName_t*)
00011280 g     F .text	00000080 __multadd
0001126c g     F .text	00000012 _Bfree
00000c00  w    F .text	00000018 SDFile::size()
00005ade g     F .text	00000088 FatFile::getSFN(char*, unsigned int)
000093a4  w    F .text	00000006 dma_ch0_isr
00000d0c  w    F .text	00000024 SDFile::~SDFile()
1fff1408  w    O .data	00000016 usb_string_serial_number
000093a4  w    F .text	00000006 enet_tx_isr
00008d20 g     F .text	000000c4 SdioCard::readSector(unsigned long, unsigned char*)
000080ac g     F .text	0000001c SdioCard::readCSD(csd_t*)



Disassembly of section .text:

00000000 <_VectorsFlash>:
  return fsFmtTime(str, time);
}
//------------------------------------------------------------------------------
char* fsFmtTimeZone(char* str, int8_t tz) {
  char sign;
  if (tz & 0X80) {
       0:	... ........q...
    if (tz & 0X40) {
      sign = '-';
      10:	q...q...q...q...
    } else {
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      str = fsFmtField(str, 15*(tz%4), 0);
      20:	q...q...q.......
      30:	....q...........
      str = fsFmtField(str, tz/4, ':');
      40:	................
      *--str = sign;
      50:	................
    }
    *--str = 'C';
    *--str = 'T';
    *--str = 'U';
      60:	................
      70:	................
      80:	................
      90:	................
      a0:	Y+..e+..........
      b0:	................
      c0:	................
      d0:	................
      e0:	................
      f0:	................
     100:	................
     110:	....Y...........
     120:	................
     130:	................
     140:	................
     150:	................
     160:	........q+......
     170:	................
     180:	................
     190:	................
     1a0:	................
     1b0:	................
     1c0:	................

000001d0 <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d0:	ldr	r3, [pc, #356]	; (338 <ResetHandler+0x168>)
     1d2:	movw	r2, #50464	; 0xc520
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
     1d6:	push	{r4, lr}
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d8:	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
     1da:	movw	r2, #55592	; 0xd928
     1de:	strh	r2, [r3, #0]
	__asm__ volatile ("nop");
     1e0:	nop
	__asm__ volatile ("nop");
     1e2:	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
     1e4:	bl	93ac <startup_early_hook>
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1e8:	ldr	r3, [pc, #336]	; (33c <ResetHandler+0x16c>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     1ea:	ldr	r1, [pc, #340]	; (340 <ResetHandler+0x170>)
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1ec:	mov.w	r2, #184549376	; 0xb000000
     1f0:	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
     1f2:	ldr	r2, [pc, #336]	; (344 <ResetHandler+0x174>)
     1f4:	str	r2, [r3, #8]
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
     1f6:	ldr	r2, [pc, #336]	; (348 <ResetHandler+0x178>)
     1f8:	str	r2, [r3, #12]
	SIM_SCGC4 = SIM_SCGC4_USBOTG | 0xF0000030;
	SIM_SCGC5 = 0x00003F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_ADC0 | SIM_SCGC6_TPM0 | SIM_SCGC6_TPM1 | SIM_SCGC6_TPM2 | SIM_SCGC6_FTFL;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SCB_CPACR = 0x00F00000;
     1fa:	ldr	r3, [pc, #336]	; (34c <ResetHandler+0x17c>)
     1fc:	mov.w	r2, #15728640	; 0xf00000
     200:	str	r2, [r3, #0]
#endif
#if defined(__MK66FX1M0__)
	LMEM_PCCCR = 0x85000003;
     202:	ldr	r3, [pc, #332]	; (350 <ResetHandler+0x180>)
     204:	ldr	r2, [pc, #332]	; (354 <ResetHandler+0x184>)
     206:	str	r2, [r3, #0]
		RTC_SR = 0;
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     208:	ldr	r3, [pc, #332]	; (358 <ResetHandler+0x188>)
     20a:	ldrb	r2, [r3, #0]
     20c:	lsls	r0, r2, #28
     20e:	ittt	mi
     210:	ldrbmi	r2, [r3, #0]
     212:	orrmi.w	r2, r2, #8
     216:	strbmi	r2, [r3, #0]

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     218:	ldr	r3, [pc, #320]	; (35c <ResetHandler+0x18c>)
     21a:	movs	r2, #170	; 0xaa
     21c:	strb	r2, [r3, #0]
     21e:	ldr	r2, [pc, #320]	; (360 <ResetHandler+0x190>)
     220:	ldr	r3, [pc, #320]	; (364 <ResetHandler+0x194>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     222:	cmp	r3, r1
     224:	bcs.n	230 <ResetHandler+0x60>
     226:	ldr.w	r0, [r2, #4]!
     22a:	str.w	r0, [r3], #4
     22e:	b.n	222 <ResetHandler+0x52>
     230:	ldr	r3, [pc, #308]	; (368 <ResetHandler+0x198>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     232:	ldr	r2, [pc, #312]	; (36c <ResetHandler+0x19c>)
     234:	movs	r1, #0
     236:	cmp	r3, r2
     238:	bcs.n	240 <ResetHandler+0x70>
     23a:	str.w	r1, [r3], #4
     23e:	b.n	236 <ResetHandler+0x66>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     240:	ldr	r2, [pc, #300]	; (370 <ResetHandler+0x1a0>)
     242:	ldr	r0, [pc, #304]	; (374 <ResetHandler+0x1a4>)
     244:	movs	r3, #0
     246:	ldr.w	r1, [r0, r3, lsl #2]
     24a:	str.w	r1, [r2, r3, lsl #2]
     24e:	adds	r3, #1
     250:	cmp	r3, #116	; 0x74
     252:	bne.n	246 <ResetHandler+0x76>
     254:	ldr	r3, [pc, #288]	; (378 <ResetHandler+0x1a8>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     256:	ldr	r2, [pc, #292]	; (37c <ResetHandler+0x1ac>)
     258:	movs	r1, #128	; 0x80
     25a:	strb.w	r1, [r3], #1
     25e:	cmp	r3, r2
     260:	bne.n	25a <ResetHandler+0x8a>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     262:	ldr	r3, [pc, #284]	; (380 <ResetHandler+0x1b0>)
     264:	ldr	r2, [pc, #264]	; (370 <ResetHandler+0x1a0>)
     266:	str	r2, [r3, #0]
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     268:	ldr	r3, [pc, #280]	; (384 <ResetHandler+0x1b4>)
     26a:	movs	r2, #138	; 0x8a
     26c:	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     26e:	sub.w	r3, r3, #4096	; 0x1000
     272:	movs	r2, #36	; 0x24
     274:	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     276:	movs	r2, #160	; 0xa0
     278:	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     27a:	ldrb	r2, [r3, #6]
     27c:	lsls	r1, r2, #30
     27e:	bpl.n	27a <ResetHandler+0xaa>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     280:	ldrb	r2, [r3, #6]
     282:	lsls	r2, r2, #27
     284:	bmi.n	280 <ResetHandler+0xb0>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     286:	ldr	r2, [pc, #256]	; (388 <ResetHandler+0x1b8>)
     288:	ldrb	r3, [r2, #6]
     28a:	and.w	r3, r3, #12
     28e:	cmp	r3, #8
     290:	ldr	r3, [pc, #244]	; (388 <ResetHandler+0x1b8>)
     292:	bne.n	288 <ResetHandler+0xb8>
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(2);
    #elif F_CPU == 120000000
	MCG_C5 = MCG_C5_PRDIV0(1);
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(14);
    #elif F_CPU == 96000000 || F_CPU == 48000000 || F_CPU == 24000000
	MCG_C5 = MCG_C5_PRDIV0(1);
     294:	movs	r2, #1
     296:	strb	r2, [r3, #4]
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(8);
     298:	movs	r2, #72	; 0x48
     29a:	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     29c:	ldrb	r2, [r3, #6]
     29e:	lsls	r4, r2, #26
     2a0:	bpl.n	29c <ResetHandler+0xcc>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     2a2:	ldr	r1, [pc, #228]	; (388 <ResetHandler+0x1b8>)
     2a4:	ldrb	r2, [r1, #6]
     2a6:	ldr	r3, [pc, #224]	; (388 <ResetHandler+0x1b8>)
     2a8:	lsls	r0, r2, #25
     2aa:	bpl.n	2a4 <ResetHandler+0xd4>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC;
#elif F_CPU == 96000000
	// config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash, USB = 96 / 2
	#if F_BUS == 48000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(3);
     2ac:	ldr	r2, [pc, #220]	; (38c <ResetHandler+0x1bc>)
     2ae:	ldr	r1, [pc, #224]	; (390 <ResetHandler+0x1c0>)
     2b0:	str	r1, [r2, #0]
	#elif F_BUS == 96000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(0) | SIM_CLKDIV1_OUTDIV4(3);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1);
     2b2:	movs	r1, #2
     2b4:	str	r1, [r2, #4]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     2b6:	movs	r2, #32
     2b8:	strb	r2, [r3, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     2ba:	ldrb	r2, [r3, #6]
     2bc:	and.w	r2, r2, #12
     2c0:	cmp	r2, #12
     2c2:	bne.n	2ba <ResetHandler+0xea>
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#else
	// USB uses PLL clock
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     2c4:	ldr	r3, [pc, #204]	; (394 <ResetHandler+0x1c4>)
     2c6:	ldr	r2, [pc, #208]	; (398 <ResetHandler+0x1c8>)
     2c8:	str	r2, [r3, #0]
#endif

#if defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started.  For Teensy 3.6
	// we don't do this early.  See comment above about slow rising power.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     2ca:	ldr	r2, [pc, #208]	; (39c <ResetHandler+0x1cc>)
     2cc:	ldr	r4, [pc, #208]	; (3a0 <ResetHandler+0x1d0>)
     2ce:	ldr	r3, [r2, #0]
     2d0:	ands.w	r3, r3, #256	; 0x100
		RTC_SR = 0;
     2d4:	ittt	eq
     2d6:	streq	r3, [r4, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     2d8:	moveq.w	r3, #5376	; 0x1500
     2dc:	streq	r3, [r2, #0]
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2de:	ldr	r3, [pc, #196]	; (3a4 <ResetHandler+0x1d4>)
     2e0:	ldr	r2, [pc, #196]	; (3a8 <ResetHandler+0x1d8>)
     2e2:	str	r2, [r3, #0]
	SYST_CVR = 0;
     2e4:	movs	r2, #0
     2e6:	str	r2, [r3, #4]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2e8:	movs	r2, #7
     2ea:	str.w	r2, [r3, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2ee:	ldr	r2, [pc, #188]	; (3ac <ResetHandler+0x1dc>)
     2f0:	str.w	r2, [r3, #3340]	; 0xd0c

	//init_pins();
	__enable_irq();
     2f4:	cpsie	i

	_init_Teensyduino_internal_();
     2f6:	bl	9538 <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     2fa:	ldr	r3, [r4, #0]
     2fc:	lsls	r2, r3, #31
     2fe:	bpl.n	30c <ResetHandler+0x13c>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     300:	ldr	r0, [pc, #172]	; (3b0 <ResetHandler+0x1e0>)
     302:	bl	9408 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     306:	ldr	r3, [pc, #172]	; (3b4 <ResetHandler+0x1e4>)
     308:	ldr	r2, [pc, #172]	; (3b8 <ResetHandler+0x1e8>)
     30a:	str	r2, [r3, #0]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     30c:	ldr	r3, [pc, #172]	; (3bc <ResetHandler+0x1ec>)
     30e:	ldrb	r3, [r3, #0]
     310:	lsls	r3, r3, #25
     312:	bpl.n	328 <ResetHandler+0x158>
     314:	ldr	r4, [pc, #156]	; (3b4 <ResetHandler+0x1e4>)
     316:	ldr	r3, [pc, #160]	; (3b8 <ResetHandler+0x1e8>)
     318:	ldr	r2, [r4, #0]
     31a:	cmp	r2, r3
     31c:	bne.n	328 <ResetHandler+0x158>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     31e:	ldr	r0, [pc, #144]	; (3b0 <ResetHandler+0x1e0>)
     320:	bl	9408 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     324:	movs	r3, #0
     326:	str	r3, [r4, #0]
	}
#endif

	startup_late_hook();
     328:	bl	93b8 <startup_late_hook>
	__libc_init_array();
     32c:	bl	b234 <__libc_init_array>

	main();
     330:	bl	a2de <main>
     334:	b.n	334 <ResetHandler+0x164>
     336:	nop
     338:	.word	0x4005200e
     33c:	.word	0x40048030
     340:	.word	0x1fff1dc8
     344:	.word	0x00043f82
     348:	.word	0x2b000001
     34c:	.word	0xe000ed88
     350:	.word	0xe0082000
     354:	.word	0x85000003
     358:	.word	0x4007d002
     35c:	.word	0x4007e000
     360:	.word	0x00013518
     364:	.word	0x1fff0f30
     368:	.word	0x1fff1dc8
     36c:	.word	0x2001d084
     370:	.word	0x1fff0a00
     374:	.word	0x00000000
     378:	.word	0xe000e400
     37c:	.word	0xe000e464
     380:	.word	0xe000ed08
     384:	.word	0x40065000
     388:	.word	0x40064000
     38c:	.word	0x40048044
     390:	.word	0x01030000
     394:	.word	0x40048004
     398:	.word	0x000510c0
     39c:	.word	0x4003d010
     3a0:	.word	0x4003d014
     3a4:	.word	0xe000e014
     3a8:	.word	0x000176ff
     3ac:	.word	0x20200000
     3b0:	.word	0x62037937
     3b4:	.word	0x4003e01c
     3b8:	.word	0x5a94c3a5
     3bc:	.word	0x4007f000
     3c0:	.word	0xffffffff
     3c4:	.word	0xffffffff
     3c8:	.word	0xffffffff
     3cc:	.word	0xffffffff
     3d0:	.word	0xffffffff
     3d4:	.word	0xffffffff
     3d8:	.word	0xffffffff
     3dc:	.word	0xffffffff
     3e0:	.word	0xffffffff
     3e4:	.word	0xffffffff
     3e8:	.word	0xffffffff
     3ec:	.word	0xffffffff
     3f0:	.word	0xffffffff
     3f4:	.word	0xffffffff
     3f8:	.word	0xffffffff
     3fc:	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	................

00000410 <__do_global_dtors_aux>:
     410:	push	{r4, lr}
     412:	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
     414:	ldrb	r3, [r4, #0]
     416:	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
     41a:	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
     41e:	nop.w
     422:	movs	r3, #1
     424:	strb	r3, [r4, #0]
     426:	pop	{r4, pc}
     428:	.word	0x1fff1dc8
     42c:	.word	0x00000000
     430:	.word	0x00013514

00000434 <frame_dummy>:
     434:	ldr	r3, [pc, #32]	; (458 <frame_dummy+0x24>)
     436:	push	{r4, lr}
     438:	cbz	r3, 442 <frame_dummy+0xe>
     43a:	ldr	r1, [pc, #32]	; (45c <frame_dummy+0x28>)
     43c:	ldr	r0, [pc, #32]	; (460 <frame_dummy+0x2c>)
     43e:	nop.w
     442:	ldr	r0, [pc, #32]	; (464 <frame_dummy+0x30>)
     444:	ldr	r3, [r0, #0]
     446:	cbnz	r3, 44a <frame_dummy+0x16>
     448:	pop	{r4, pc}
     44a:	ldr	r3, [pc, #28]	; (468 <frame_dummy+0x34>)
     44c:	cmp	r3, #0
     44e:	beq.n	448 <frame_dummy+0x14>
     450:	ldmia.w	sp!, {r4, lr}
     454:	bx	r3
     456:	nop
     458:	.word	0x00000000
     45c:	.word	0x1fff1dcc
     460:	.word	0x00013514
     464:	.word	0x1fff1dc8
     468:	.word	0x00000000

0000046c <DMAChannel::~DMAChannel()>:
	}
	DMAChannel & operator = (const DMASetting &rhs) {
		copy_tcd(TCD, rhs.TCD);
		return *this;
	}
	~DMAChannel() {
     46c:	push	{r4, lr}
     46e:	mov	r4, r0
		release();
     470:	bl	a090 <DMAChannel::release()>
	}
     474:	mov	r0, r4
     476:	pop	{r4, pc}

00000478 <acq_stopClocks()>:
    } 


    void acq_stopClocks(void)
    {
        SIM_SCGC6 &= ~SIM_SCGC6_DMAMUX;
     478:	ldr	r3, [pc, #28]	; (498 <acq_stopClocks()+0x20>)
        SIM_SCGC7 &= ~SIM_SCGC7_DMA;
     47a:	ldr	r1, [pc, #32]	; (49c <acq_stopClocks()+0x24>)
    } 


    void acq_stopClocks(void)
    {
        SIM_SCGC6 &= ~SIM_SCGC6_DMAMUX;
     47c:	ldr	r2, [r3, #0]
     47e:	bic.w	r2, r2, #2
     482:	str	r2, [r3, #0]
        SIM_SCGC7 &= ~SIM_SCGC7_DMA;
     484:	ldr	r2, [r1, #0]
     486:	bic.w	r2, r2, #2
     48a:	str	r2, [r1, #0]
        SIM_SCGC6 &= ~SIM_SCGC6_I2S;
     48c:	ldr	r2, [r3, #0]
     48e:	bic.w	r2, r2, #32768	; 0x8000
     492:	str	r2, [r3, #0]
     494:	bx	lr
     496:	nop
     498:	.word	0x4004803c
     49c:	.word	0x40048040

000004a0 <acq_startClocks()>:
    }

    void acq_startClocks(void)
    {
    SIM_SCGC6 |= SIM_SCGC6_I2S;
     4a0:	ldr	r3, [pc, #28]	; (4c0 <acq_startClocks()+0x20>)
    SIM_SCGC7 |= SIM_SCGC7_DMA;
     4a2:	ldr	r1, [pc, #32]	; (4c4 <acq_startClocks()+0x24>)
        SIM_SCGC6 &= ~SIM_SCGC6_I2S;
    }

    void acq_startClocks(void)
    {
    SIM_SCGC6 |= SIM_SCGC6_I2S;
     4a4:	ldr	r2, [r3, #0]
     4a6:	orr.w	r2, r2, #32768	; 0x8000
     4aa:	str	r2, [r3, #0]
    SIM_SCGC7 |= SIM_SCGC7_DMA;
     4ac:	ldr	r2, [r1, #0]
     4ae:	orr.w	r2, r2, #2
     4b2:	str	r2, [r1, #0]
    SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
     4b4:	ldr	r2, [r3, #0]
     4b6:	orr.w	r2, r2, #2
     4ba:	str	r2, [r3, #0]
     4bc:	bx	lr
     4be:	nop
     4c0:	.word	0x4004803c
     4c4:	.word	0x40048040

000004c8 <acq_start()>:
    }

    void acq_start(void)
    {
     4c8:	push	{r3, lr}
        acq_startClocks();
     4ca:	bl	4a0 <acq_startClocks()>
        I2S0_RCSR |= (I2S_RCSR_RE | I2S_RCSR_BCE);
     4ce:	ldr	r2, [pc, #12]	; (4dc <acq_start()+0x14>)
     4d0:	ldr	r3, [r2, #0]
     4d2:	orr.w	r3, r3, #2415919104	; 0x90000000
     4d6:	str	r3, [r2, #0]
     4d8:	pop	{r3, pc}
     4da:	nop
     4dc:	.word	0x4002f080

000004e0 <acq_stop()>:
    }

    void acq_stop(void)
    {
        I2S0_RCSR &= ~(I2S_RCSR_RE | I2S_RCSR_BCE);
     4e0:	ldr	r2, [pc, #12]	; (4f0 <acq_stop()+0x10>)
     4e2:	ldr	r3, [r2, #0]
     4e4:	bic.w	r3, r3, #2415919104	; 0x90000000
     4e8:	str	r3, [r2, #0]
        acq_stopClocks();
     4ea:	b.w	478 <acq_stopClocks()>
     4ee:	nop
     4f0:	.word	0x4002f080

000004f4 <mckl_init(int, int, int)>:
    }

    void mckl_init(int src, int mult, int div)
    {
     4f4:	push	{r4, lr}
        SIM_SCGC6 |= SIM_SCGC6_I2S;
     4f6:	ldr	r4, [pc, #52]	; (52c <mckl_init(int, int, int)+0x38>)
     4f8:	ldr	r3, [r4, #0]
        // enable MCLK output
        I2S0_MDR = I2S_MDR_FRACT((mult-1)) | I2S_MDR_DIVIDE((div-1));
     4fa:	subs	r1, #1
        acq_stopClocks();
    }

    void mckl_init(int src, int mult, int div)
    {
        SIM_SCGC6 |= SIM_SCGC6_I2S;
     4fc:	orr.w	r3, r3, #32768	; 0x8000
        // enable MCLK output
        I2S0_MDR = I2S_MDR_FRACT((mult-1)) | I2S_MDR_DIVIDE((div-1));
     500:	lsls	r1, r1, #12
     502:	subs	r2, #1
        acq_stopClocks();
    }

    void mckl_init(int src, int mult, int div)
    {
        SIM_SCGC6 |= SIM_SCGC6_I2S;
     504:	str	r3, [r4, #0]
        // enable MCLK output
        I2S0_MDR = I2S_MDR_FRACT((mult-1)) | I2S_MDR_DIVIDE((div-1));
     506:	and.w	r1, r1, #1044480	; 0xff000
     50a:	ubfx	r2, r2, #0, #12
     50e:	ldr	r3, [pc, #32]	; (530 <mckl_init(int, int, int)+0x3c>)
     510:	orrs	r2, r1
     512:	str	r2, [r3, #0]
        while(I2S0_MCR & I2S_MCR_DUF);
     514:	ldr	r2, [pc, #28]	; (534 <mckl_init(int, int, int)+0x40>)
     516:	ldr	r3, [r2, #0]
     518:	cmp	r3, #0
     51a:	blt.n	516 <mckl_init(int, int, int)+0x22>
        I2S0_MCR = I2S_MCR_MICS(src) | I2S_MCR_MOE;
     51c:	lsls	r0, r0, #24
     51e:	and.w	r0, r0, #50331648	; 0x3000000
     522:	ldr	r3, [pc, #16]	; (534 <mckl_init(int, int, int)+0x40>)
     524:	orr.w	r0, r0, #1073741824	; 0x40000000
     528:	str	r0, [r3, #0]
     52a:	pop	{r4, pc}
     52c:	.word	0x4004803c
     530:	.word	0x4002f104
     534:	.word	0x4002f100

00000538 <acq_init(int)>:

    }

    void acq_init(int fsamp)
    {   uint32_t iscl[3]={MCLK_MULT,MCLK_DIV,BCLK_DIV};
     538:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
        
//        Serial.println(I2S_dividers(iscl, fsamp, 32));
        Serial.printf("%d %d %d\n",iscl[0],iscl[1],iscl[2]); 
     53a:	ldr	r4, [pc, #292]	; (660 <acq_init(int)+0x128>)
     53c:	ldr	r6, [pc, #292]	; (664 <acq_init(int)+0x12c>)
     53e:	movs	r5, #4
        I2S0_MCR = I2S_MCR_MICS(src) | I2S_MCR_MOE;

    }

    void acq_init(int fsamp)
    {   uint32_t iscl[3]={MCLK_MULT,MCLK_DIV,BCLK_DIV};
     540:	mov	r7, r0
        
//        Serial.println(I2S_dividers(iscl, fsamp, 32));
        Serial.printf("%d %d %d\n",iscl[0],iscl[1],iscl[2]); 
     542:	str	r5, [sp, #0]
     544:	mov	r1, r6
     546:	movs	r3, #2
     548:	movs	r2, #1
     54a:	mov	r0, r4
     54c:	bl	a198 <Print::printf(char const*, ...)>
        Serial.printf("%d %d %d\n",MCLK_MULT,MCLK_DIV,BCLK_DIV); 
     550:	str	r5, [sp, #0]
     552:	mov	r1, r6
     554:	movs	r3, #2
     556:	movs	r2, #1
     558:	mov	r0, r4
     55a:	bl	a198 <Print::printf(char const*, ...)>
        Serial.printf("%d %d\n",fsamp,fsamp0);
     55e:	mov	r2, r7
     560:	ldr	r3, [pc, #260]	; (668 <acq_init(int)+0x130>)
     562:	ldr	r1, [pc, #264]	; (66c <acq_init(int)+0x134>)
            CORE_PIN35_CONFIG = PORT_PCR_MUX(4) | PORT_PCR_SRE | PORT_PCR_DSE;  //pin35, PTC8,   I2S0_MCLK (SLEW rate (SRE)?)
            CORE_PIN36_CONFIG = PORT_PCR_MUX(4);  //pin36, PTC9,   I2S0_RX_BCLK
            CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
            CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
        #endif
        I2S0_RCSR=0;
     564:	ldr	r6, [pc, #264]	; (670 <acq_init(int)+0x138>)
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV((iscl[2]-1));
	I2S0_TCR3 = I2S_TCR3_TCE;
	I2S0_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(31) | I2S_TCR4_MF
		| I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD;
	I2S0_TCR5 = I2S_TCR5_WNW(31) | I2S_TCR5_W0W(31) | I2S_TCR5_FBT(31);
     566:	ldr	r7, [pc, #268]	; (674 <acq_init(int)+0x13c>)
    {   uint32_t iscl[3]={MCLK_MULT,MCLK_DIV,BCLK_DIV};
        
//        Serial.println(I2S_dividers(iscl, fsamp, 32));
        Serial.printf("%d %d %d\n",iscl[0],iscl[1],iscl[2]); 
        Serial.printf("%d %d %d\n",MCLK_MULT,MCLK_DIV,BCLK_DIV); 
        Serial.printf("%d %d\n",fsamp,fsamp0);
     568:	mov	r0, r4
     56a:	bl	a198 <Print::printf(char const*, ...)>

        acq_startClocks();
     56e:	bl	4a0 <acq_startClocks()>

        #if I2S_CONFIG==0
            CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
     572:	ldr	r2, [pc, #260]	; (678 <acq_init(int)+0x140>)
     574:	mov.w	r3, #1536	; 0x600
     578:	str	r3, [r2, #0]
        	CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK
     57a:	str.w	r3, [r2, #-12]
            CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
     57e:	str.w	r3, [r2, #-16]
            CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  //pin 13, PTC5,  I2S0_RXD0
     582:	ldr	r3, [pc, #248]	; (67c <acq_init(int)+0x144>)
            CORE_PIN35_CONFIG = PORT_PCR_MUX(4) | PORT_PCR_SRE | PORT_PCR_DSE;  //pin35, PTC8,   I2S0_MCLK (SLEW rate (SRE)?)
            CORE_PIN36_CONFIG = PORT_PCR_MUX(4);  //pin36, PTC9,   I2S0_RX_BCLK
            CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
            CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
        #endif
        I2S0_RCSR=0;
     584:	movs	r4, #0

        #if I2S_CONFIG==0
            CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
        	CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK
            CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
            CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  //pin 13, PTC5,  I2S0_RXD0
     586:	mov.w	r2, #1024	; 0x400
     58a:	str	r2, [r3, #0]
            CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
        #endif
        I2S0_RCSR=0;

//        mckl_init(MCLK_SRC, MCLK_MULT, MCLK_DIV);
        mckl_init(MCLK_SRC, iscl[0],iscl[1]);
     58c:	movs	r1, #1
            CORE_PIN35_CONFIG = PORT_PCR_MUX(4) | PORT_PCR_SRE | PORT_PCR_DSE;  //pin35, PTC8,   I2S0_MCLK (SLEW rate (SRE)?)
            CORE_PIN36_CONFIG = PORT_PCR_MUX(4);  //pin36, PTC9,   I2S0_RX_BCLK
            CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
            CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
        #endif
        I2S0_RCSR=0;
     58e:	str	r4, [r6, #0]

//        mckl_init(MCLK_SRC, MCLK_MULT, MCLK_DIV);
        mckl_init(MCLK_SRC, iscl[0],iscl[1]);
     590:	movs	r2, #2
     592:	movs	r0, #3
     594:	bl	4f4 <mckl_init(int, int, int)>
        #endif
        
        I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
#else
	// configure transmitter
	I2S0_TMR = 0;
     598:	ldr	r3, [pc, #228]	; (680 <acq_init(int)+0x148>)
	I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV((iscl[2]-1));
     59a:	ldr	r2, [pc, #232]	; (684 <acq_init(int)+0x14c>)
        #endif
        
        I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
#else
	// configure transmitter
	I2S0_TMR = 0;
     59c:	str	r4, [r3, #0]
	I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
     59e:	movs	r1, #1
     5a0:	str.w	r1, [r3, #-92]
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV((iscl[2]-1));
	I2S0_TCR3 = I2S_TCR3_TCE;
     5a4:	mov.w	r0, #65536	; 0x10000
#else
	// configure transmitter
	I2S0_TMR = 0;
	I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV((iscl[2]-1));
     5a8:	str.w	r2, [r3, #-88]
	I2S0_TCR3 = I2S_TCR3_TCE;
	I2S0_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(31) | I2S_TCR4_MF
		| I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD;
     5ac:	ldr	r2, [pc, #216]	; (688 <acq_init(int)+0x150>)
	// configure transmitter
	I2S0_TMR = 0;
	I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV((iscl[2]-1));
	I2S0_TCR3 = I2S_TCR3_TCE;
     5ae:	str.w	r0, [r3, #-84]

	// configure receiver (sync'd to transmitter clocks)
	I2S0_RMR = 0;
	I2S0_RCR1 = I2S_RCR1_RFW(1);
	I2S0_RCR2 = I2S_RCR2_SYNC(1) | I2S_TCR2_BCP | I2S_RCR2_MSEL(1)
		| I2S_RCR2_BCD | I2S_RCR2_DIV((iscl[2]-1));
     5b2:	ldr.w	lr, [pc, #264]	; 6bc <acq_init(int)+0x184>
	I2S0_TCR1 = I2S_TCR1_TFW(1);  // watermark at half fifo size
	I2S0_TCR2 = I2S_TCR2_SYNC(0) | I2S_TCR2_BCP | I2S_TCR2_MSEL(1)
		| I2S_TCR2_BCD | I2S_TCR2_DIV((iscl[2]-1));
	I2S0_TCR3 = I2S_TCR3_TCE;
	I2S0_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(31) | I2S_TCR4_MF
		| I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD;
     5b6:	str.w	r2, [r3, #-80]
	I2S0_TCR5 = I2S_TCR5_WNW(31) | I2S_TCR5_W0W(31) | I2S_TCR5_FBT(31);
     5ba:	ldr	r3, [pc, #208]	; (68c <acq_init(int)+0x154>)
     5bc:	str	r3, [r7, #0]

	// configure receiver (sync'd to transmitter clocks)
	I2S0_RMR = 0;
     5be:	str.w	r4, [r7, #204]	; 0xcc
	I2S0_RCR1 = I2S_RCR1_RFW(1);
     5c2:	str	r1, [r7, #112]	; 0x70
	I2S0_RCR2 = I2S_RCR2_SYNC(1) | I2S_TCR2_BCP | I2S_RCR2_MSEL(1)
		| I2S_RCR2_BCD | I2S_RCR2_DIV((iscl[2]-1));
     5c4:	str.w	lr, [r7, #116]	; 0x74
	I2S0_RCR3 = I2S_RCR3_RCE;
     5c8:	str	r0, [r7, #120]	; 0x78
	I2S0_RCR4 = I2S_RCR4_FRSZ(1) | I2S_RCR4_SYWD(31) | I2S_RCR4_MF
		| I2S_RCR4_FSE | I2S_RCR4_FSP | I2S_RCR4_FSD;
     5ca:	ldr	r0, [pc, #196]	; (690 <acq_init(int)+0x158>)
     5cc:	str	r2, [r0, #0]
	I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
     5ce:	ldr	r2, [pc, #196]	; (694 <acq_init(int)+0x15c>)
     5d0:	str	r3, [r2, #0]

	I2S0_TCSR = I2S_TCSR_SR;
     5d2:	ldr	r3, [pc, #196]	; (698 <acq_init(int)+0x160>)
     5d4:	mov.w	r2, #16777216	; 0x1000000
     5d8:	str	r2, [r3, #0]
	I2S0_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;
     5da:	ldr	r2, [pc, #192]	; (69c <acq_init(int)+0x164>)
     5dc:	str	r2, [r3, #0]

#endif
// configuration of DMA
        dma.TCD->SADDR = &I2S0_RDR0;
     5de:	ldr	r2, [pc, #192]	; (6a0 <acq_init(int)+0x168>)
     5e0:	ldr	r3, [r2, #0]
     5e2:	adds	r0, #16
     5e4:	str	r0, [r3, #0]
        dma.TCD->SOFF = 0;
        dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
     5e6:	movw	r0, #514	; 0x202
     5ea:	strh	r0, [r3, #6]
	    dma.TCD->NBYTES_MLOFFNO = 4;
        dma.TCD->SLAST = 0;
        dma.TCD->DADDR = tdm_rx_buffer;
     5ec:	ldr	r0, [pc, #180]	; (6a4 <acq_init(int)+0x16c>)
     5ee:	str	r0, [r3, #16]
        dma.TCD->DOFF = 4;
        dma.TCD->CITER_ELINKNO = 2*NBUF_I2S;
     5f0:	mov.w	r0, #512	; 0x200
     5f4:	strh	r0, [r3, #22]
	I2S0_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;

#endif
// configuration of DMA
        dma.TCD->SADDR = &I2S0_RDR0;
        dma.TCD->SOFF = 0;
     5f6:	strh	r4, [r3, #4]
        dma.TCD->SLAST = 0;
        dma.TCD->DADDR = tdm_rx_buffer;
        dma.TCD->DOFF = 4;
        dma.TCD->CITER_ELINKNO = 2*NBUF_I2S;
        dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
        dma.TCD->BITER_ELINKNO = 2*NBUF_I2S;
     5f8:	strh	r0, [r3, #30]
#endif
// configuration of DMA
        dma.TCD->SADDR = &I2S0_RDR0;
        dma.TCD->SOFF = 0;
        dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
	    dma.TCD->NBYTES_MLOFFNO = 4;
     5fa:	str	r5, [r3, #8]
        dma.TCD->SLAST = 0;
        dma.TCD->DADDR = tdm_rx_buffer;
        dma.TCD->DOFF = 4;
     5fc:	strh	r5, [r3, #20]
        dma.TCD->CITER_ELINKNO = 2*NBUF_I2S;
        dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
        dma.TCD->BITER_ELINKNO = 2*NBUF_I2S;
        dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
     5fe:	movs	r0, #6
	    dma.TCD->NBYTES_MLOFFNO = 4;
        dma.TCD->SLAST = 0;
        dma.TCD->DADDR = tdm_rx_buffer;
        dma.TCD->DOFF = 4;
        dma.TCD->CITER_ELINKNO = 2*NBUF_I2S;
        dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
     600:	subw	r5, r5, #2052	; 0x804
        dma.TCD->BITER_ELINKNO = 2*NBUF_I2S;
        dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
     604:	strh	r0, [r3, #28]
// configuration of DMA
        dma.TCD->SADDR = &I2S0_RDR0;
        dma.TCD->SOFF = 0;
        dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
	    dma.TCD->NBYTES_MLOFFNO = 4;
        dma.TCD->SLAST = 0;
     606:	str	r4, [r3, #12]
        dma.TCD->DADDR = tdm_rx_buffer;
        dma.TCD->DOFF = 4;
        dma.TCD->CITER_ELINKNO = 2*NBUF_I2S;
        dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
     608:	str	r5, [r3, #24]
	// 32 bits.  If a channel is configured for 200 transfers

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
     60a:	ldrb	r3, [r2, #4]
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void attachInterrupt(void (*isr)(void), uint8_t prio) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
     60c:	ldr	r5, [pc, #152]	; (6a8 <acq_init(int)+0x170>)
	// 32 bits.  If a channel is configured for 200 transfers

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
     60e:	add.w	r3, r3, #1073741824	; 0x40000000
     612:	add.w	r3, r3, #135168	; 0x21000
		*mux = 0;
		*mux = (source & 63) | DMAMUX_ENABLE;
     616:	movs	r0, #140	; 0x8c

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
		*mux = 0;
     618:	strb	r4, [r3, #0]
		*mux = (source & 63) | DMAMUX_ENABLE;
     61a:	strb	r0, [r3, #0]
        dma.TCD->BITER_ELINKNO = 2*NBUF_I2S;
        dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
        //
        dma.triggerAtHardwareEvent(DMAMUX_SOURCE_I2S0_RX);
        NVIC_SET_PRIORITY(DMAMUX_SOURCE_I2S0_RX,I2S_SAI_PRIO);
     61c:	ldr	r3, [pc, #140]	; (6ac <acq_init(int)+0x174>)
     61e:	movs	r0, #64	; 0x40
     620:	strb	r0, [r3, #0]
        //
        I2S0_RCSR =  I2S_RCSR_FRDE | I2S_RCSR_FR;
     622:	ldr	r3, [pc, #140]	; (6b0 <acq_init(int)+0x178>)
     624:	str	r3, [r6, #0]
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void attachInterrupt(void (*isr)(void), uint8_t prio) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
     626:	ldrb	r0, [r2, #4]
     628:	ldr	r3, [pc, #136]	; (6b4 <acq_init(int)+0x17c>)
     62a:	add.w	r4, r0, #16
     62e:	str.w	r5, [r3, r4, lsl #2]
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
     632:	asrs	r3, r0, #5
     634:	lsls	r3, r3, #2
     636:	add.w	r3, r3, #3758096384	; 0xe0000000
     63a:	add.w	r3, r3, #57600	; 0xe100
     63e:	and.w	r0, r0, #31
     642:	lsls	r1, r0
     644:	str	r1, [r3, #0]
		NVIC_SET_PRIORITY(IRQ_DMA_CH0 + channel, prio);
     646:	ldrb	r3, [r2, #4]
     648:	add.w	r3, r3, #3758096384	; 0xe0000000
     64c:	add.w	r3, r3, #58368	; 0xe400
     650:	movs	r1, #80	; 0x50
     652:	strb	r1, [r3, #0]
     654:	ldrb	r2, [r2, #4]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
     656:	ldr	r3, [pc, #96]	; (6b8 <acq_init(int)+0x180>)
     658:	strb	r2, [r3, #0]
        dma.attachInterrupt(acq_isr, I2S_DMA_PRIO);	
        //
        dma.enable();        
    }
     65a:	add	sp, #12
     65c:	pop	{r4, r5, r6, r7, pc}
     65e:	nop
     660:	.word	0x1fff136c
     664:	.word	0x00012470
     668:	.word	0x00016e36
     66c:	.word	0x00012473
     670:	.word	0x4002f080
     674:	.word	0x4002f014
     678:	.word	0x4004b018
     67c:	.word	0x4004b014
     680:	.word	0x4002f060
     684:	.word	0x07000003
     688:	.word	0x00011f1b
     68c:	.word	0x1f1f1f00
     690:	.word	0x4002f090
     694:	.word	0x4002f094
     698:	.word	0x4002f000
     69c:	.word	0x90000001
     6a0:	.word	0x1fff21ec
     6a4:	.word	0x1fff0200
     6a8:	.word	0x000006e1
     6ac:	.word	0xe000e40c
     6b0:	.word	0x02000001
     6b4:	.word	0x1fff0a00
     6b8:	.word	0x4000801b
     6bc:	.word	0x47000003

000006c0 <extract(void*, void*)>:


const int adc_shift=8;
#if ADC_STEREO // have stereo I2S
    void extract(void *out, void *inp)
    {   
     6c0:	push	{r4, lr}
     6c2:	movs	r3, #0
        int32_t *dout = (int32_t *) out;
        int32_t *din  = (int32_t *) inp;
        for(int ii=0; ii < NSAMP; ii++)
        {   dout[0+ii*NCHAN_ACQ] = din[0+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     6c4:	ldr	r2, [r1, r3]
     6c6:	asrs	r2, r2, #8
     6c8:	str	r2, [r0, r3]
            dout[1+ii*NCHAN_ACQ] = din[1+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     6ca:	adds	r2, r1, r3
     6cc:	adds	r4, r0, r3
     6ce:	ldr	r2, [r2, #4]
     6d0:	adds	r3, #8
     6d2:	asrs	r2, r2, #8
#if ADC_STEREO // have stereo I2S
    void extract(void *out, void *inp)
    {   
        int32_t *dout = (int32_t *) out;
        int32_t *din  = (int32_t *) inp;
        for(int ii=0; ii < NSAMP; ii++)
     6d4:	cmp.w	r3, #1024	; 0x400
        {   dout[0+ii*NCHAN_ACQ] = din[0+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
            dout[1+ii*NCHAN_ACQ] = din[1+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     6d8:	str	r2, [r4, #4]
#if ADC_STEREO // have stereo I2S
    void extract(void *out, void *inp)
    {   
        int32_t *dout = (int32_t *) out;
        int32_t *din  = (int32_t *) inp;
        for(int ii=0; ii < NSAMP; ii++)
     6da:	bne.n	6c4 <extract(void*, void*)+0x4>
        {   dout[0+ii*NCHAN_ACQ] = din[0+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
            dout[1+ii*NCHAN_ACQ] = din[1+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
        }
    }
     6dc:	pop	{r4, pc}
     6de:	Address 0x000006de is out of bounds.


000006e0 <acq_isr()>:
        }
    }
#endif

    void acq_isr(void)
    {
     6e0:	push	{r3, lr}
     6e2:	ldr	r3, [pc, #60]	; (720 <acq_isr()+0x40>)
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
     6e4:	ldr	r2, [pc, #60]	; (724 <acq_isr()+0x44>)
     6e6:	ldrb	r1, [r3, #4]
     6e8:	strb	r1, [r2, #0]
        uint32_t daddr;
        uint32_t *src;

        dma.clearInterrupt();
        asm volatile("dsb");
     6ea:	dsb	sy
     6ee:	ldr	r3, [r3, #0]

        #if IMXRT_CACHE_ENABLED >=1
            arm_dcache_delete((void*)src, sizeof(tdm_rx_buffer) / 2);
        #endif

        extract((void *) acq_rx_buffer, (void *) src);
     6f0:	ldr	r0, [pc, #52]	; (728 <acq_isr()+0x48>)
	}
	void * sourceAddress(void) {
		return (void *)(TCD->SADDR);
	}
	void * destinationAddress(void) {
		return (void *)(TCD->DADDR);
     6f2:	ldr	r1, [r3, #16]

        dma.clearInterrupt();
        asm volatile("dsb");
        daddr = (uint32_t) dma.destinationAddress();

        if (daddr < (uint32_t) &tdm_rx_buffer[NBUF_I2S]) {
     6f4:	ldr	r3, [pc, #52]	; (72c <acq_isr()+0x4c>)
            // need to remove data from the second half
            src = &tdm_rx_buffer[NBUF_I2S];
        } else {
            // DMA is receiving to the second half of the buffer
            // need to remove data from the first half
            src = &tdm_rx_buffer[0];
     6f6:	sub.w	r2, r3, #1024	; 0x400

        #if IMXRT_CACHE_ENABLED >=1
            arm_dcache_delete((void*)src, sizeof(tdm_rx_buffer) / 2);
        #endif

        extract((void *) acq_rx_buffer, (void *) src);
     6fa:	cmp	r1, r3
     6fc:	ite	cc
     6fe:	movcc	r1, r3
     700:	movcs	r1, r2
     702:	bl	6c0 <extract(void*, void*)>
        if(!pushData(acq_rx_buffer)) acq_miss++;
     706:	ldr	r0, [pc, #32]	; (728 <acq_isr()+0x48>)
     708:	bl	1b30 <pushData(unsigned long*)>
     70c:	cbnz	r0, 716 <acq_isr()+0x36>
     70e:	ldr	r2, [pc, #32]	; (730 <acq_isr()+0x50>)
     710:	ldr	r3, [r2, #0]
     712:	adds	r3, #1
     714:	str	r3, [r2, #0]
        acq_count++;
     716:	ldr	r2, [pc, #28]	; (734 <acq_isr()+0x54>)
     718:	ldr	r3, [r2, #0]
     71a:	adds	r3, #1
     71c:	str	r3, [r2, #0]
     71e:	pop	{r3, pc}
     720:	.word	0x1fff21ec
     724:	.word	0x4000801f
     728:	.word	0x1fff1dec
     72c:	.word	0x1fff0600
     730:	.word	0x1fff1de8
     734:	.word	0x1fff1de4

00000738 <_GLOBAL__sub_I_acq_count>:
    }
     738:	push	{r4, lr}
	/*************************************************/
	/**    Channel Allocation                       **/
	/*************************************************/

	DMAChannel() {
		begin();
     73a:	ldr	r4, [pc, #24]	; (754 <_GLOBAL__sub_I_acq_count+0x1c>)
     73c:	movs	r1, #0
     73e:	mov	r0, r4
     740:	bl	9fe8 <DMAChannel::begin(bool)>
#include "acq.h"
#include "adc.h"

/********************************************************************************/
#include "DMAChannel.h"
static DMAChannel dma;
     744:	mov	r0, r4
     746:	ldr	r2, [pc, #16]	; (758 <_GLOBAL__sub_I_acq_count+0x20>)
     748:	ldr	r1, [pc, #16]	; (75c <_GLOBAL__sub_I_acq_count+0x24>)
        #endif

        extract((void *) acq_rx_buffer, (void *) src);
        if(!pushData(acq_rx_buffer)) acq_miss++;
        acq_count++;
    }
     74a:	ldmia.w	sp!, {r4, lr}
#include "acq.h"
#include "adc.h"

/********************************************************************************/
#include "DMAChannel.h"
static DMAChannel dma;
     74e:	b.w	a4e0 <__aeabi_atexit>
     752:	nop
     754:	.word	0x1fff21ec
     758:	.word	0x1fff0f30
     75c:	.word	0x0000046d

00000760 <Print::write(char const*)>:
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     760:	push	{r4, r5, r6, lr}
     762:	mov	r4, r0
     764:	mov	r0, r1
     766:	mov	r5, r1
     768:	bl	bf40 <strlen>
     76c:	ldr	r3, [r4, #0]
     76e:	mov	r2, r0
     770:	mov	r1, r5
     772:	mov	r0, r4
     774:	ldr	r3, [r3, #4]
     776:	ldmia.w	sp!, {r4, r5, r6, lr}
     77a:	bx	r3

0000077c <Print::print(unsigned long)>:

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
     77c:	movs	r3, #0
     77e:	movs	r2, #10
     780:	b.w	a1b2 <Print::printNumber(unsigned long, unsigned char, unsigned char)>

00000784 <Print::println(char const*)>:
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     784:	push	{r3, r4, r5, lr}
     786:	mov	r5, r0
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
     788:	bl	760 <Print::write(char const*)>
     78c:	mov	r4, r0
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     78e:	mov	r0, r5
     790:	bl	a178 <Print::println()>
     794:	add	r0, r4
     796:	pop	{r3, r4, r5, pc}

00000798 <checkToCloseFile(short, unsigned long)>:

/* check if we should close file */
int t_acq = 60; // close file on the minute

int16_t checkToCloseFile(int16_t status, uint32_t t_acq)
{ if((status == OPENED) || (status == RUNNING))
     798:	push	{r3, r4, r5, lr}
     79a:	subs	r3, r0, #1
     79c:	uxth	r3, r3
     79e:	cmp	r3, #1
     7a0:	mov	r5, r0
     7a2:	mov	r4, r1
     7a4:	bhi.n	7be <checkToCloseFile(short, unsigned long)+0x26>
  { //
    static uint32_t to =0;
    uint32_t tx=rtc_get();
     7a6:	bl	93fc <rtc_get>
    tx %= t_acq;
    if(tx<to) status = DOCLOSE; // time wrapped, file must be closed
     7aa:	ldr	r3, [pc, #24]	; (7c4 <checkToCloseFile(short, unsigned long)+0x2c>)
int16_t checkToCloseFile(int16_t status, uint32_t t_acq)
{ if((status == OPENED) || (status == RUNNING))
  { //
    static uint32_t to =0;
    uint32_t tx=rtc_get();
    tx %= t_acq;
     7ac:	udiv	r1, r0, r4
    if(tx<to) status = DOCLOSE; // time wrapped, file must be closed
     7b0:	ldr	r2, [r3, #0]
int16_t checkToCloseFile(int16_t status, uint32_t t_acq)
{ if((status == OPENED) || (status == RUNNING))
  { //
    static uint32_t to =0;
    uint32_t tx=rtc_get();
    tx %= t_acq;
     7b2:	mls	r0, r1, r4, r0
    if(tx<to) status = DOCLOSE; // time wrapped, file must be closed
     7b6:	cmp	r0, r2
     7b8:	it	cc
     7ba:	movcc	r5, #3
    to=tx;
     7bc:	str	r0, [r3, #0]
  } 
  return status;
}
     7be:	mov	r0, r5
     7c0:	pop	{r3, r4, r5, pc}
     7c2:	nop
     7c4:	.word	0x1fff21f8

000007c8 <setup>:

void setup()
{
     7c8:	push	{r3, r4, r5, lr}
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     7ca:	ldr	r0, [pc, #92]	; (828 <setup+0x60>)
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     7cc:	ldr	r4, [pc, #92]	; (82c <setup+0x64>)
     7ce:	ldr	r5, [pc, #96]	; (830 <setup+0x68>)
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     7d0:	ldr	r1, [pc, #96]	; (834 <setup+0x6c>)
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     7d2:	ldrb	r3, [r4, #0]
     7d4:	cmp	r3, #0
     7d6:	beq.n	7d2 <setup+0xa>
     7d8:	ldrb	r3, [r5, #0]
     7da:	lsls	r3, r3, #31
     7dc:	bpl.n	7d2 <setup+0xa>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     7de:	ldr	r3, [r0, #0]
     7e0:	ldr	r2, [r1, #0]
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     7e2:	subs	r3, r3, r2
     7e4:	cmp	r3, #14
     7e6:	bls.n	7d2 <setup+0xa>
  while(!Serial) continue;
  Serial.println("basic Sound Recorder Version: " __DATE__  " " __TIME__ );
     7e8:	ldr	r1, [pc, #76]	; (838 <setup+0x70>)
     7ea:	ldr	r0, [pc, #80]	; (83c <setup+0x74>)
     7ec:	bl	784 <Print::println(char const*)>
  SerNum = getTeensySerial();
     7f0:	bl	14ec <getTeensySerial()>
     7f4:	ldr	r3, [pc, #72]	; (840 <setup+0x78>)
     7f6:	mov	r1, r0
	size_t print(uint64_t n)			{ return printNumber64(n, 10, 0); }

	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
     7f8:	movs	r2, #16
     7fa:	str	r0, [r3, #0]
     7fc:	movs	r3, #0
     7fe:	ldr	r0, [pc, #60]	; (83c <setup+0x74>)
     800:	bl	a1b2 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	size_t println(uint64_t n)			{ return print(n) + println(); }

	size_t println(unsigned char n, int base)	{ return print(n, base) + println(); }
	size_t println(int n, int base)			{ return print(n, base) + println(); }
	size_t println(unsigned int n, int base)	{ return print(n, base) + println(); }
	size_t println(long n, int base)		{ return print(n, base) + println(); }
     804:	ldr	r0, [pc, #52]	; (83c <setup+0x74>)
     806:	bl	a178 <Print::println()>
  Serial.println((int32_t)SerNum,HEX);

  storage_configure();
     80a:	bl	1be0 <storage_configure()>

  adc_init();
     80e:	bl	238e <adc_init()>
  acq_init(fsamp);
     812:	ldr	r3, [pc, #48]	; (844 <setup+0x7c>)
     814:	ldr	r0, [r3, #0]
     816:	bl	538 <acq_init(int)>
  adc_enable();
     81a:	bl	2394 <adc_enable()>

  #if START_MODE==CLOSED
    acq_start(); 
  #endif

  Serial.println("End of Setup");
     81e:	ldr	r1, [pc, #40]	; (848 <setup+0x80>)
     820:	ldr	r0, [pc, #24]	; (83c <setup+0x74>)
     822:	bl	784 <Print::println(char const*)>
     826:	pop	{r3, r4, r5, pc}
     828:	.word	0x2001cf20
     82c:	.word	0x2001d003
     830:	.word	0x2001cf1c
     834:	.word	0x2001d074
     838:	.word	0x0001247a
     83c:	.word	0x1fff136c
     840:	.word	0x1fff222c
     844:	.word	0x2001c9e0
     848:	.word	0x000124ad

0000084c <loop>:
}

void loop()
{ static int16_t status=START_MODE; 
     84c:	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}

  if(status==MUST_REBOOT) status=checkReboot(); // hapens only if microSD card write fails: reboot if space on disk
     850:	ldr	r4, [pc, #328]	; (99c <loop+0x150>)
     852:	ldrsh.w	r3, [r4]
     856:	adds	r3, #2
     858:	bne.n	860 <loop+0x14>
     85a:	bl	1e4c <checkReboot()>
     85e:	strh	r0, [r4, #0]

  // normal operation
  int16_t ch=menu();  // check if we have serial line command (0: no input; 1: start; -1: stop)
     860:	bl	1338 <menu()>

  if(ch>0 && status==STOPPED)  // was stopped, should run now 
     864:	cmp	r0, #0
     866:	ble.n	880 <loop+0x34>
     868:	ldrsh.w	r3, [r4]
     86c:	adds	r3, #1
     86e:	bne.n	894 <loop+0x48>
  { 
    status=CLOSED; acq_start(); adcStatus();
     870:	ldr	r3, [pc, #296]	; (99c <loop+0x150>)
     872:	movs	r2, #0
     874:	strh	r2, [r3, #0]
     876:	bl	4c8 <acq_start()>
     87a:	bl	2390 <adcStatus()>
     87e:	b.n	894 <loop+0x48>
  }  
  
  if(ch<0 && status>=CLOSED)  // was running, should stop now
     880:	beq.n	894 <loop+0x48>
     882:	ldrsh.w	r3, [r4]
     886:	cmp	r3, #0
     888:	blt.n	894 <loop+0x48>
  { 
    status=MUSTSTOP;  acq_stop();  
     88a:	ldr	r3, [pc, #272]	; (99c <loop+0x150>)
     88c:	movs	r2, #4
     88e:	strh	r2, [r3, #0]
     890:	bl	4e0 <acq_stop()>
  } 

  if(status > CLOSED) // RUNNING
     894:	ldrsh.w	r0, [r4]
     898:	cmp	r0, #0
     89a:	ble.n	8a8 <loop+0x5c>
  {
    status = checkToCloseFile(status, (uint32_t) t_acq); // check if we reached file size or aquisition time
     89c:	ldr	r3, [pc, #256]	; (9a0 <loop+0x154>)
     89e:	ldr	r1, [r3, #0]
     8a0:	bl	798 <checkToCloseFile(short, unsigned long)>
     8a4:	ldr	r3, [pc, #244]	; (99c <loop+0x150>)
     8a6:	strh	r0, [r3, #0]
  }

  if(status >= CLOSED) // NOT STOPPED
     8a8:	ldrsh.w	r3, [r4]
     8ac:	ldr	r6, [pc, #244]	; (9a4 <loop+0x158>)
     8ae:	cmp	r3, #0
     8b0:	blt.n	8e2 <loop+0x96>
  {
    uint32_t mc = getCount();
     8b2:	bl	1b18 <getCount()>
    if(mc>max_count) max_count=mc;
     8b6:	ldr	r3, [pc, #240]	; (9a8 <loop+0x15c>)
     8b8:	ldr	r2, [r3, #0]
     8ba:	cmp	r0, r2
     8bc:	it	hi
     8be:	strhi	r0, [r3, #0]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     8c0:	ldr	r3, [r6, #0]
     8c2:	str	r3, [sp, #4]
    //
    uint32_t to=millis();
    status = saveData(status);  
     8c4:	ldrsh.w	r0, [r4]
	return ret;
     8c8:	ldr	r5, [sp, #4]
     8ca:	bl	1e54 <saveData(short)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     8ce:	ldr	r3, [r6, #0]
    uint32_t dt=millis()-to;
    if(max_write<dt) max_write=dt;
     8d0:	ldr	r2, [pc, #216]	; (9ac <loop+0x160>)
     8d2:	str	r3, [sp, #0]
	return ret;
     8d4:	ldr	r3, [sp, #0]
     8d6:	ldr	r1, [r2, #0]
  {
    uint32_t mc = getCount();
    if(mc>max_count) max_count=mc;
    //
    uint32_t to=millis();
    status = saveData(status);  
     8d8:	strh	r0, [r4, #0]
    uint32_t dt=millis()-to;
     8da:	subs	r3, r3, r5
    if(max_write<dt) max_write=dt;
     8dc:	cmp	r3, r1
     8de:	it	hi
     8e0:	strhi	r3, [r2, #0]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     8e2:	ldr	r3, [r6, #0]
  }

  static uint32_t t0;
  static uint32_t loop_count=0;
  if(millis()-t0>1000)
     8e4:	ldr	r2, [pc, #200]	; (9b0 <loop+0x164>)
     8e6:	str	r3, [sp, #8]
	return ret;
     8e8:	ldr	r3, [sp, #8]
     8ea:	ldr	r1, [r2, #0]
     8ec:	ldr	r5, [pc, #196]	; (9b4 <loop+0x168>)
     8ee:	subs	r3, r3, r1
     8f0:	cmp.w	r3, #1000	; 0x3e8
     8f4:	mov	sl, r2
     8f6:	bls.n	98e <loop+0x142>
  {
    if(status>=CLOSED)
     8f8:	ldrsh.w	r3, [r4]
     8fc:	ldr	r7, [pc, #168]	; (9a8 <loop+0x15c>)
     8fe:	ldr	r4, [pc, #172]	; (9ac <loop+0x160>)
     900:	ldr.w	r9, [pc, #196]	; 9c8 <loop+0x17c>
     904:	ldr.w	r8, [pc, #196]	; 9cc <loop+0x180>
     908:	cmp	r3, #0
     90a:	blt.n	974 <loop+0x128>
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
     90c:	ldr	r1, [pc, #168]	; (9b8 <loop+0x16c>)
     90e:	ldr	r0, [pc, #172]	; (9bc <loop+0x170>)
     910:	bl	760 <Print::write(char const*)>
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
     914:	ldr	r3, [pc, #132]	; (99c <loop+0x150>)
     916:	ldr	r0, [pc, #164]	; (9bc <loop+0x170>)
     918:	ldrsh.w	r1, [r3]
     91c:	bl	a228 <Print::print(long)>
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
     920:	ldr	r1, [pc, #156]	; (9c0 <loop+0x174>)
     922:	ldr	r0, [pc, #152]	; (9bc <loop+0x170>)
     924:	bl	760 <Print::write(char const*)>
    {
      Serial.print("\nLoop: ");
        Serial.print(status);     Serial.print(" "); 
        Serial.print(loop_count); Serial.print(" : "); 
     928:	ldr	r1, [r5, #0]
     92a:	ldr	r0, [pc, #144]	; (9bc <loop+0x170>)
     92c:	bl	77c <Print::print(unsigned long)>
     930:	ldr	r1, [pc, #144]	; (9c4 <loop+0x178>)
     932:	ldr	r0, [pc, #136]	; (9bc <loop+0x170>)
     934:	bl	760 <Print::write(char const*)>
        Serial.print(acq_count);  Serial.print(" ");
     938:	ldr.w	r1, [r9]
     93c:	ldr	r0, [pc, #124]	; (9bc <loop+0x170>)
     93e:	bl	77c <Print::print(unsigned long)>
     942:	ldr	r1, [pc, #124]	; (9c0 <loop+0x174>)
     944:	ldr	r0, [pc, #116]	; (9bc <loop+0x170>)
     946:	bl	760 <Print::write(char const*)>
        Serial.print(acq_miss);   Serial.print(" ");
     94a:	ldr.w	r1, [r8]
     94e:	ldr	r0, [pc, #108]	; (9bc <loop+0x170>)
     950:	bl	77c <Print::print(unsigned long)>
     954:	ldr	r1, [pc, #104]	; (9c0 <loop+0x174>)
     956:	ldr	r0, [pc, #100]	; (9bc <loop+0x170>)
     958:	bl	760 <Print::write(char const*)>
        Serial.print(max_count);  Serial.print(" ");
     95c:	ldr	r1, [r7, #0]
     95e:	ldr	r0, [pc, #92]	; (9bc <loop+0x170>)
     960:	bl	77c <Print::print(unsigned long)>
     964:	ldr	r1, [pc, #88]	; (9c0 <loop+0x174>)
     966:	ldr	r0, [pc, #84]	; (9bc <loop+0x170>)
     968:	bl	760 <Print::write(char const*)>
        Serial.print(max_write);
     96c:	ldr	r1, [r4, #0]
     96e:	ldr	r0, [pc, #76]	; (9bc <loop+0x170>)
     970:	bl	77c <Print::print(unsigned long)>
    }
    loop_count=0;
     974:	movs	r3, #0
    acq_count=0;
     976:	str.w	r3, [r9]
    acq_miss=0;
     97a:	str.w	r3, [r8]
        Serial.print(acq_count);  Serial.print(" ");
        Serial.print(acq_miss);   Serial.print(" ");
        Serial.print(max_count);  Serial.print(" ");
        Serial.print(max_write);
    }
    loop_count=0;
     97e:	str	r3, [r5, #0]
    acq_count=0;
    acq_miss=0;
    max_count=0;
     980:	str	r3, [r7, #0]
    max_write=0;
     982:	str	r3, [r4, #0]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     984:	ldr	r3, [r6, #0]
     986:	str	r3, [sp, #12]
	return ret;
     988:	ldr	r3, [sp, #12]
    t0=millis();
     98a:	str.w	r3, [sl]
  }
  loop_count++;
     98e:	ldr	r3, [r5, #0]
     990:	adds	r3, #1
     992:	str	r3, [r5, #0]
     994:	add	sp, #16
     996:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     99a:	nop
     99c:	.word	0x1fff0f34
     9a0:	.word	0x1fff0f38
     9a4:	.word	0x2001cf20
     9a8:	.word	0x1fff2200
     9ac:	.word	0x1fff21f4
     9b0:	.word	0x1fff21fc
     9b4:	.word	0x1fff2204
     9b8:	.word	0x000124ba
     9bc:	.word	0x1fff136c
     9c0:	.word	0x000124c4
     9c4:	.word	0x000124c2
     9c8:	.word	0x1fff1de4
     9cc:	.word	0x1fff1de8

000009d0 <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
     9d0:	movs	r0, #0
     9d2:	bx	lr

000009d4 <Print::flush()>:
	virtual void flush()				{ }
     9d4:	bx	lr

000009d6 <File::write(unsigned char const*, unsigned int)>:
		return (f) ? f->read(buf, nbyte) : 0;
	}
	
	// override print version
	virtual size_t write(const uint8_t *buf, size_t size) {
		return (f) ? f->write((void*)buf, size) : 0;
     9d6:	ldr	r0, [r0, #16]
     9d8:	cbz	r0, 9e0 <File::write(unsigned char const*, unsigned int)+0xa>
     9da:	ldr	r3, [r0, #0]
     9dc:	ldr	r3, [r3, #12]
     9de:	bx	r3
	}
     9e0:	bx	lr

000009e2 <File::available()>:

	size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
	}
	int available() {
		return (f) ? f->available() : 0;
     9e2:	ldr	r0, [r0, #16]
     9e4:	cbz	r0, 9ec <File::available()+0xa>
     9e6:	ldr	r3, [r0, #0]
     9e8:	ldr	r3, [r3, #16]
     9ea:	bx	r3
	}
     9ec:	bx	lr

000009ee <File::peek()>:
	int peek() {
		return (f) ? f->peek() : -1;
     9ee:	ldr	r0, [r0, #16]
     9f0:	cbz	r0, 9f8 <File::peek()+0xa>
     9f2:	ldr	r3, [r0, #0]
     9f4:	ldr	r3, [r3, #20]
     9f6:	bx	r3
	}
     9f8:	mov.w	r0, #4294967295
     9fc:	bx	lr

000009fe <File::flush()>:
	void flush() {
		if (f) f->flush();
     9fe:	ldr	r0, [r0, #16]
     a00:	cbz	r0, a08 <File::flush()+0xa>
     a02:	ldr	r3, [r0, #0]
     a04:	ldr	r3, [r3, #24]
     a06:	bx	r3
     a08:	bx	lr

00000a0a <File::read()>:
		return (f) ? f->setModifyTime(tm) : false;
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
     a0a:	push	{r0, r1, r2, lr}
		if (!f) return -1;
     a0c:	ldr	r0, [r0, #16]
     a0e:	cbnz	r0, a16 <File::read()+0xc>
     a10:	mov.w	r0, #4294967295
     a14:	b.n	a2a <File::read()+0x20>
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
     a16:	ldr	r3, [r0, #0]
     a18:	movs	r2, #1
     a1a:	ldr	r3, [r3, #8]
     a1c:	add.w	r1, sp, #7
     a20:	blx	r3
     a22:	cmp	r0, #0
     a24:	beq.n	a10 <File::read()+0x6>
		return b;
     a26:	ldrb.w	r0, [sp, #7]
	}
     a2a:	add	sp, #12
     a2c:	ldr.w	pc, [sp], #4

00000a30 <File::write(unsigned char)>:
	size_t write(uint8_t b) {
     a30:	push	{r0, r1, r2, lr}
		return (f) ? f->write(&b, 1) : 0;
     a32:	ldr	r0, [r0, #16]
		if (!f) return -1;
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
		return b;
	}
	size_t write(uint8_t b) {
     a34:	strb.w	r1, [sp, #7]
		return (f) ? f->write(&b, 1) : 0;
     a38:	cbz	r0, a46 <File::write(unsigned char)+0x16>
     a3a:	ldr	r3, [r0, #0]
     a3c:	movs	r2, #1
     a3e:	ldr	r3, [r3, #12]
     a40:	add.w	r1, sp, #7
     a44:	blx	r3
	}
     a46:	add	sp, #12
     a48:	ldr.w	pc, [sp], #4

00000a4c <SDFile::getCreateTime(DateTimeFields&)>:
		return File();
	}
	virtual void rewindDirectory(void) {
		sdfatfile.rewindDirectory();
	}
	virtual bool getCreateTime(DateTimeFields &tm) {
     a4c:	push	{r0, r1, r4, lr}
     a4e:	mov	r3, r0
   * \param[out] ptime Packed time for directory entry.
   *
   * \return true for success or false for failure.
   */
  bool getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    return m_fFile ? m_fFile->getCreateDateTime(pdate, ptime) :
     a50:	ldr	r0, [r0, #80]	; 0x50
     a52:	mov	r4, r1
           m_xFile ? m_xFile->getCreateDateTime(pdate, ptime) : false;
     a54:	cbz	r0, a62 <SDFile::getCreateTime(DateTimeFields&)+0x16>
     a56:	add.w	r2, sp, #6
     a5a:	add	r1, sp, #4
     a5c:	bl	636a <FatFile::getCreateDateTime(unsigned short*, unsigned short*)>
     a60:	b.n	a74 <SDFile::getCreateTime(DateTimeFields&)+0x28>
     a62:	ldr	r0, [r3, #84]	; 0x54
     a64:	cbnz	r0, a6a <SDFile::getCreateTime(DateTimeFields&)+0x1e>
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getCreateDateTime(&fat_date, &fat_time)) return false;
     a66:	movs	r0, #0
     a68:	b.n	aae <SDFile::getCreateTime(DateTimeFields&)+0x62>
     a6a:	add.w	r2, sp, #6
     a6e:	add	r1, sp, #4
     a70:	bl	4076 <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)>
     a74:	cmp	r0, #0
     a76:	beq.n	a66 <SDFile::getCreateTime(DateTimeFields&)+0x1a>
		if ((fat_date == 0) && (fat_time == 0)) return false;
     a78:	ldrh.w	r3, [sp, #4]
     a7c:	ldrh.w	r2, [sp, #6]
     a80:	cbnz	r3, a86 <SDFile::getCreateTime(DateTimeFields&)+0x3a>
     a82:	cmp	r2, #0
     a84:	beq.n	a66 <SDFile::getCreateTime(DateTimeFields&)+0x1a>
		tm.sec = FS_SECOND(fat_time);
     a86:	and.w	r1, r2, #31
     a8a:	lsls	r1, r1, #1
     a8c:	strb	r1, [r4, #0]
		tm.min = FS_MINUTE(fat_time);
     a8e:	ubfx	r1, r2, #5, #6
		tm.hour = FS_HOUR(fat_time);
     a92:	asrs	r2, r2, #11
     a94:	strb	r2, [r4, #2]
		tm.mday = FS_DAY(fat_date);
     a96:	and.w	r2, r3, #31
     a9a:	strb	r2, [r4, #4]
		tm.mon = FS_MONTH(fat_date) - 1;
     a9c:	ubfx	r2, r3, #5, #4
		tm.year = FS_YEAR(fat_date) - 1900;
     aa0:	asrs	r3, r3, #9
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     aa2:	subs	r2, #1
		tm.year = FS_YEAR(fat_date) - 1900;
     aa4:	add.w	r3, r3, #1872	; 0x750
	virtual bool getCreateTime(DateTimeFields &tm) {
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getCreateDateTime(&fat_date, &fat_time)) return false;
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
     aa8:	strb	r1, [r4, #1]
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     aaa:	strb	r2, [r4, #5]
		tm.year = FS_YEAR(fat_date) - 1900;
     aac:	strb	r3, [r4, #6]
		return true;
	}
     aae:	add	sp, #8
     ab0:	pop	{r4, pc}

00000ab2 <SDFile::getModifyTime(DateTimeFields&)>:
	virtual bool getModifyTime(DateTimeFields &tm) {
     ab2:	push	{r0, r1, r4, lr}
     ab4:	mov	r3, r0
   * \param[out] ptime Packed time for directory entry.
   *
   * \return true for success or false for failure.
   */
  bool getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    return m_fFile ? m_fFile->getModifyDateTime(pdate, ptime) :
     ab6:	ldr	r0, [r0, #80]	; 0x50
     ab8:	mov	r4, r1
           m_xFile ? m_xFile->getModifyDateTime(pdate, ptime) : false;
     aba:	cbz	r0, ac8 <SDFile::getModifyTime(DateTimeFields&)+0x16>
     abc:	add.w	r2, sp, #6
     ac0:	add	r1, sp, #4
     ac2:	bl	638a <FatFile::getModifyDateTime(unsigned short*, unsigned short*)>
     ac6:	b.n	ada <SDFile::getModifyTime(DateTimeFields&)+0x28>
     ac8:	ldr	r0, [r3, #84]	; 0x54
     aca:	cbnz	r0, ad0 <SDFile::getModifyTime(DateTimeFields&)+0x1e>
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getModifyDateTime(&fat_date, &fat_time)) return false;
     acc:	movs	r0, #0
     ace:	b.n	b14 <SDFile::getModifyTime(DateTimeFields&)+0x62>
     ad0:	add.w	r2, sp, #6
     ad4:	add	r1, sp, #4
     ad6:	bl	4096 <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)>
     ada:	cmp	r0, #0
     adc:	beq.n	acc <SDFile::getModifyTime(DateTimeFields&)+0x1a>
		if ((fat_date == 0) && (fat_time == 0)) return false;
     ade:	ldrh.w	r3, [sp, #4]
     ae2:	ldrh.w	r2, [sp, #6]
     ae6:	cbnz	r3, aec <SDFile::getModifyTime(DateTimeFields&)+0x3a>
     ae8:	cmp	r2, #0
     aea:	beq.n	acc <SDFile::getModifyTime(DateTimeFields&)+0x1a>
		tm.sec = FS_SECOND(fat_time);
     aec:	and.w	r1, r2, #31
     af0:	lsls	r1, r1, #1
     af2:	strb	r1, [r4, #0]
		tm.min = FS_MINUTE(fat_time);
     af4:	ubfx	r1, r2, #5, #6
		tm.hour = FS_HOUR(fat_time);
     af8:	asrs	r2, r2, #11
     afa:	strb	r2, [r4, #2]
		tm.mday = FS_DAY(fat_date);
     afc:	and.w	r2, r3, #31
     b00:	strb	r2, [r4, #4]
		tm.mon = FS_MONTH(fat_date) - 1;
     b02:	ubfx	r2, r3, #5, #4
		tm.year = FS_YEAR(fat_date) - 1900;
     b06:	asrs	r3, r3, #9
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     b08:	subs	r2, #1
		tm.year = FS_YEAR(fat_date) - 1900;
     b0a:	add.w	r3, r3, #1872	; 0x750
	virtual bool getModifyTime(DateTimeFields &tm) {
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getModifyDateTime(&fat_date, &fat_time)) return false;
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
     b0e:	strb	r1, [r4, #1]
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     b10:	strb	r2, [r4, #5]
		tm.year = FS_YEAR(fat_date) - 1900;
     b12:	strb	r3, [r4, #6]
		return true;
	}
     b14:	add	sp, #8
     b16:	pop	{r4, pc}

00000b18 <SDFile::name()>:
		}
	}
	virtual bool isOpen() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
     b18:	push	{r3, r4, r5, lr}
		if (!filename) {
     b1a:	ldr	r5, [r0, #88]	; 0x58
		}
	}
	virtual bool isOpen() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
     b1c:	mov	r4, r0
		if (!filename) {
     b1e:	cbnz	r5, b50 <SDFile::name()+0x38>
			filename = (char *)malloc(MAX_FILENAME_LEN);
     b20:	mov.w	r0, #256	; 0x100
     b24:	bl	b2d4 <malloc>
     b28:	mov	r1, r0
     b2a:	str	r0, [r4, #88]	; 0x58
			if (filename) {
     b2c:	cbz	r0, b4c <SDFile::name()+0x34>
   *             must be at least 13 bytes long.  The file's name will be
   *             truncated if the file's name is too long.
   * \return The length of the returned string.
   */
  size_t getName(char* name, size_t len) {
    *name = 0;
     b2e:	strb	r5, [r0, #0]
    return m_fFile ? m_fFile->getName(name, len) :
     b30:	ldr	r0, [r4, #80]	; 0x50
           m_xFile ? m_xFile->getName(name, len) : 0;
     b32:	cbz	r0, b3e <SDFile::name()+0x26>
     b34:	mov.w	r2, #256	; 0x100
     b38:	bl	5c58 <FatFile::getName(char*, unsigned int)>
     b3c:	b.n	b50 <SDFile::name()+0x38>
     b3e:	ldr	r0, [r4, #84]	; 0x54
     b40:	cbz	r0, b50 <SDFile::name()+0x38>
   * \param[in] size The size of the array in characters.
   * \return the name length.
   */
  size_t getName(char* name, size_t size) {
#if USE_UTF8_LONG_NAMES
    return getName8(name, size);
     b42:	mov.w	r2, #256	; 0x100
     b46:	bl	3f18 <ExFatFile::getName8(char*, unsigned int)>
     b4a:	b.n	b50 <SDFile::name()+0x38>
				sdfatfile.getName(filename, MAX_FILENAME_LEN);
			} else {
				static char zeroterm = 0;
				filename = &zeroterm;
     b4c:	ldr	r3, [pc, #4]	; (b54 <SDFile::name()+0x3c>)
     b4e:	str	r3, [r4, #88]	; 0x58
			}
		}
		return filename;
	}
     b50:	ldr	r0, [r4, #88]	; 0x58
     b52:	pop	{r3, r4, r5, pc}
     b54:	.word	0x1fff2208

00000b58 <SDFile::truncate(unsigned long long)>:
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
		return sdfatfile.read(buf, nbyte);
	}
	virtual bool truncate(uint64_t size=0) {
     b58:	push	{r4, r6, r7, lr}
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     b5a:	ldr	r4, [r0, #80]	; 0x50
           m_xFile ? m_xFile->truncate(length) : false;
     b5c:	cbz	r4, b7a <SDFile::truncate(unsigned long long)+0x22>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     b5e:	cmp	r3, #1
     b60:	it	eq
     b62:	cmpeq	r2, #0
     b64:	bcs.n	b90 <SDFile::truncate(unsigned long long)+0x38>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint32_t length) {
    return seekSet(length) && truncate();
     b66:	mov	r1, r2
     b68:	mov	r0, r4
     b6a:	bl	5f9a <FatFile::seekSet(unsigned long)>
     b6e:	cbz	r0, b90 <SDFile::truncate(unsigned long long)+0x38>
     b70:	mov	r0, r4
     b72:	bl	6792 <FatFile::truncate()>
     b76:	cbz	r0, b90 <SDFile::truncate(unsigned long long)+0x38>
     b78:	pop	{r4, r6, r7, pc}
           m_xFile ? m_xFile->truncate(length) : false;
     b7a:	ldr	r4, [r0, #84]	; 0x54
     b7c:	cbz	r4, b90 <SDFile::truncate(unsigned long long)+0x38>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
     b7e:	mov	r0, r4
     b80:	bl	4308 <ExFatFile::seekSet(unsigned long long)>
     b84:	cbz	r0, b90 <SDFile::truncate(unsigned long long)+0x38>
     b86:	mov	r0, r4
		return sdfatfile.truncate(size);
	}
     b88:	ldmia.w	sp!, {r4, r6, r7, lr}
     b8c:	b.w	52fa <ExFatFile::truncate()>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     b90:	movs	r0, #0
     b92:	pop	{r4, r6, r7, pc}

00000b94 <File::dec_refcount() [clone .isra.15]>:
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	using Print::write;
private:
	void dec_refcount() {
     b94:	push	{r4, lr}
     b96:	mov	r4, r0
		if (--(f->refcount) == 0) {
     b98:	ldr	r0, [r0, #0]
     b9a:	ldr	r3, [r0, #4]
     b9c:	subs	r3, #1
     b9e:	str	r3, [r0, #4]
     ba0:	cbnz	r3, bb2 <File::dec_refcount() [clone .isra.15]+0x1e>
			f->close();
     ba2:	ldr	r3, [r0, #0]
     ba4:	ldr	r3, [r3, #44]	; 0x2c
     ba6:	blx	r3
			delete f;
     ba8:	ldr	r0, [r4, #0]
     baa:	cbz	r0, bb2 <File::dec_refcount() [clone .isra.15]+0x1e>
     bac:	ldr	r3, [r0, #0]
     bae:	ldr	r3, [r3, #4]
     bb0:	blx	r3
		}
		f = nullptr;
     bb2:	movs	r3, #0
     bb4:	str	r3, [r4, #0]
     bb6:	pop	{r4, pc}

00000bb8 <File::~File()>:
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
     bb8:	ldr	r3, [pc, #20]	; (bd0 <File::~File()+0x18>)
     bba:	push	{r4, lr}
     bbc:	str	r3, [r0, #0]
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
     bbe:	ldr	r3, [r0, #16]
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
     bc0:	mov	r4, r0
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
     bc2:	cbz	r3, bca <File::~File()+0x12>
     bc4:	adds	r0, #16
     bc6:	bl	b94 <File::dec_refcount() [clone .isra.15]>
	}
     bca:	mov	r0, r4
     bcc:	pop	{r4, pc}
     bce:	nop
     bd0:	.word	0x0001253c

00000bd4 <File::~File()>:
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
     bd4:	push	{r4, lr}
     bd6:	mov	r4, r0
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
	}
     bd8:	bl	bb8 <File::~File()>
     bdc:	mov	r0, r4
     bde:	movs	r1, #20
     be0:	bl	a374 <operator delete(void*, unsigned int)>
     be4:	mov	r0, r4
     be6:	pop	{r4, pc}

00000be8 <SDFile::position()>:
    return m_fFile ? m_fFile->contiguousRange(bgnSector, endSector) :
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
     be8:	ldr	r3, [r0, #80]	; 0x50
           m_xFile ? m_xFile->curPosition() : 0;
     bea:	cbz	r3, bf2 <SDFile::position()+0xa>
     bec:	ldr	r0, [r3, #20]
     bee:	movs	r1, #0
     bf0:	bx	lr
     bf2:	ldr	r3, [r0, #84]	; 0x54
     bf4:	cbz	r3, bfc <SDFile::position()+0x14>
   *
   * \return true for success or false for failure.
   */
  bool contiguousRange(uint32_t* bgnSector, uint32_t* endSector);
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {return m_curPosition;}
     bf6:	ldmia.w	r3, {r0, r1}
     bfa:	bx	lr
     bfc:	mov	r0, r3
     bfe:	b.n	bee <SDFile::position()+0x6>

00000c00 <SDFile::size()>:
    return m_fFile ? m_fFile->fgets(str, num, delim) :
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
     c00:	ldr	r3, [r0, #80]	; 0x50
           m_xFile ? m_xFile->fileSize() : 0;
     c02:	cbz	r3, c0a <SDFile::size()+0xa>
     c04:	ldr	r0, [r3, #28]
     c06:	movs	r1, #0
     c08:	bx	lr
     c0a:	ldr	r3, [r0, #84]	; 0x54
     c0c:	cbz	r3, c14 <SDFile::size()+0x14>
   * If no data is read, fgets() returns zero for EOF or -1 if an error
   * occurred.
   */
  int fgets(char* str, int num, char* delim = nullptr);
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {return m_validLength;}
     c0e:	ldr	r0, [r3, #16]
     c10:	ldr	r1, [r3, #20]
     c12:	bx	lr
     c14:	mov	r0, r3
     c16:	b.n	c06 <SDFile::size()+0x6>

00000c18 <FsBaseFile::available() const>:
  operator bool() const {return isOpen();}
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
    return m_fFile ? m_fFile->available() :
     c18:	ldr	r2, [r0, #56]	; 0x38
    */
  operator bool() const {return isOpen();}
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
     c1a:	push	{r4, r5, lr}
    return m_fFile ? m_fFile->available() :
           m_xFile ? m_xFile->available() : 0;
     c1c:	cbz	r2, c38 <FsBaseFile::available() const+0x20>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available32() const {
    return isFile() ? fileSize() - curPosition() : 0;
     c1e:	ldrb	r3, [r2, #0]
     c20:	and.w	r3, r3, #8
     c24:	and.w	r0, r3, #255	; 0xff
     c28:	cbz	r3, c6a <FsBaseFile::available() const+0x52>
     c2a:	ldr	r3, [r2, #28]
     c2c:	ldr	r0, [r2, #20]
   * Zero is returned for directory files.
   *
   */
  int available() const {
    uint32_t n = available32();
    return n > INT_MAX ? INT_MAX : n;
     c2e:	subs	r0, r3, r0
     c30:	bpl.n	c6a <FsBaseFile::available() const+0x52>
     c32:	mvn.w	r0, #2147483648	; 0x80000000
     c36:	b.n	c6a <FsBaseFile::available() const+0x52>
     c38:	ldr	r0, [r0, #60]	; 0x3c
     c3a:	cbz	r0, c6a <FsBaseFile::available() const+0x52>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint64_t available64() {
    return isFile() ? fileSize() - curPosition() : 0;
     c3c:	ldrb.w	r3, [r0, #49]	; 0x31
     c40:	lsls	r3, r3, #28
     c42:	bpl.n	c54 <FsBaseFile::available() const+0x3c>
     c44:	ldrd	r4, r5, [r0, #16]
     c48:	ldrd	r2, r3, [r0]
     c4c:	subs	r0, r4, r2
     c4e:	sbc.w	r1, r5, r3
     c52:	b.n	c58 <FsBaseFile::available() const+0x40>
     c54:	movs	r0, #0
     c56:	movs	r1, #0
   * Zero is returned for directory files.
   *
   */
  int available() {
    uint64_t n = available64();
    return n > INT_MAX ? INT_MAX : n;
     c58:	movs	r3, #0
     c5a:	mvn.w	r2, #2147483648	; 0x80000000
     c5e:	cmp	r3, r1
     c60:	it	eq
     c62:	cmpeq	r2, r0
     c64:	bcs.n	c6a <FsBaseFile::available() const+0x52>
     c66:	mov	r0, r2
     c68:	pop	{r4, r5, pc}
  }
     c6a:	pop	{r4, r5, pc}

00000c6c <StreamFile<FsBaseFile, unsigned long long>::available()>:
  StreamFile() {}

  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
     c6c:	push	{r3, lr}
    return BaseFile::available();
     c6e:	adds	r0, #16
     c70:	bl	c18 <FsBaseFile::available() const>
  }
     c74:	pop	{r3, pc}

00000c76 <SDFile::available()>:
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
		return sdfatfile.peek();
	}
	virtual int available() {
     c76:	push	{r3, lr}

  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
    return BaseFile::available();
     c78:	adds	r0, #24
     c7a:	bl	c18 <FsBaseFile::available() const>
		return sdfatfile.available();
	}
     c7e:	pop	{r3, pc}

00000c80 <FsBaseFile::isDir() const>:
    return m_xFile ? m_xFile->isContiguous() : false;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  }
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_fFile ? m_fFile->isDir() :
     c80:	ldr	r3, [r0, #56]	; 0x38
           m_xFile ? m_xFile->isDir() : false;
     c82:	cbz	r3, c8c <FsBaseFile::isDir() const+0xc>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
    /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  /** \return True if this is a directory. */
  bool isDir() const {return m_attributes & FILE_ATTR_DIR;}
     c84:	ldrb	r3, [r3, #0]
     c86:	tst.w	r3, #112	; 0x70
     c8a:	b.n	c98 <FsBaseFile::isDir() const+0x18>
     c8c:	ldr	r0, [r0, #60]	; 0x3c
     c8e:	cbz	r0, c9e <FsBaseFile::isDir() const+0x1e>
   */
  bool isBusy();
  /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
  /** \return True if this is a directory. */
  bool isDir() const  {return m_attributes & FILE_ATTR_DIR;}
     c90:	ldrb.w	r3, [r0, #49]	; 0x31
     c94:	tst.w	r3, #80	; 0x50
     c98:	ite	ne
     c9a:	movne	r0, #1
     c9c:	moveq	r0, #0
  }
     c9e:	bx	lr

00000ca0 <SDFile::isDirectory()>:
				filename = &zeroterm;
			}
		}
		return filename;
	}
	virtual boolean isDirectory(void) {
     ca0:	push	{r3, lr}
  }
  /** This function reports if the current file is a directory or not.
  * \return true if the file is a directory.
  */
  bool isDirectory() {
    return BaseFile::isDir();
     ca2:	adds	r0, #24
     ca4:	bl	c80 <FsBaseFile::isDir() const>
		return sdfatfile.isDirectory();
	}
     ca8:	pop	{r3, pc}

00000caa <SDFile::rewindDirectory()>:
	virtual File openNextFile(uint8_t mode=0) {
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
		return File();
	}
	virtual void rewindDirectory(void) {
     caa:	push	{r4, lr}
     cac:	mov	r4, r0
  int read() {
    return BaseFile::read();
  }
  /** Rewind a file if it is a directory */
  void rewindDirectory() {
    if (BaseFile::isDir()) {
     cae:	adds	r0, #24
     cb0:	bl	c80 <FsBaseFile::isDir() const>
     cb4:	cbz	r0, cd0 <SDFile::rewindDirectory()+0x26>
    return m_fFile ? m_fFile->rename(dirFile->m_fFile, newPath) :
           m_xFile ? m_xFile->rename(dirFile->m_xFile, newPath) : false;
  }
  /** Set the file's current position to zero. */
  void rewind() {
    if (m_fFile) m_fFile->rewind();
     cb6:	ldr	r0, [r4, #80]	; 0x50
     cb8:	cbz	r0, cc0 <SDFile::rewindDirectory()+0x16>
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
     cba:	movs	r1, #0
     cbc:	bl	5f9a <FatFile::seekSet(unsigned long)>
    if (m_xFile) m_xFile->rewind();
     cc0:	ldr	r0, [r4, #84]	; 0x54
     cc2:	cbz	r0, cd0 <SDFile::rewindDirectory()+0x26>
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
     cc4:	movs	r2, #0
     cc6:	movs	r3, #0
		sdfatfile.rewindDirectory();
	}
     cc8:	ldmia.w	sp!, {r4, lr}
     ccc:	b.w	4308 <ExFatFile::seekSet(unsigned long long)>
     cd0:	pop	{r4, pc}

00000cd2 <FsBaseFile::isOpen() const>:
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     cd2:	ldr	r3, [r0, #56]	; 0x38
     cd4:	cbnz	r3, ce0 <FsBaseFile::isOpen() const+0xe>
     cd6:	ldr	r0, [r0, #60]	; 0x3c
     cd8:	adds	r0, #0
     cda:	it	ne
     cdc:	movne	r0, #1
     cde:	bx	lr
     ce0:	movs	r0, #1
     ce2:	bx	lr

00000ce4 <SDFile::close()>:
		return sdfatfile.curPosition();
	}
	virtual uint64_t size() {
		return sdfatfile.size();
	}
	virtual void close() {
     ce4:	push	{r4, lr}
     ce6:	mov	r4, r0
		if (filename) {
     ce8:	ldr	r0, [r0, #88]	; 0x58
     cea:	cbz	r0, cf4 <SDFile::close()+0x10>
			free(filename);
     cec:	bl	b2e4 <free>
			filename = nullptr;
     cf0:	movs	r3, #0
     cf2:	str	r3, [r4, #88]	; 0x58
		}
		if (sdfatfile.isOpen()) {
     cf4:	adds	r4, #24
     cf6:	mov	r0, r4
     cf8:	bl	cd2 <FsBaseFile::isOpen() const>
     cfc:	cbz	r0, d08 <SDFile::close()+0x24>
			sdfatfile.close();
     cfe:	mov	r0, r4
		}
	}
     d00:	ldmia.w	sp!, {r4, lr}
		if (filename) {
			free(filename);
			filename = nullptr;
		}
		if (sdfatfile.isOpen()) {
			sdfatfile.close();
     d04:	b.w	74b0 <FsBaseFile::close()>
     d08:	pop	{r4, pc}
     d0a:	Address 0x00000d0a is out of bounds.


00000d0c <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     d0c:	push	{r4, lr}
     d0e:	ldr	r3, [pc, #24]	; (d28 <SDFile::~SDFile()+0x1c>)
     d10:	str	r3, [r0, #0]
     d12:	mov	r4, r0
		close();
     d14:	bl	ce4 <SDFile::close()>
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     d18:	ldr	r3, [pc, #16]	; (d2c <SDFile::~SDFile()+0x20>)
     d1a:	str	r3, [r4, #8]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     d1c:	add.w	r0, r4, #24
     d20:	bl	74b0 <FsBaseFile::close()>
	}
     d24:	mov	r0, r4
     d26:	pop	{r4, pc}
     d28:	.word	0x00012568
     d2c:	.word	0x000124f4

00000d30 <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     d30:	push	{r4, lr}
     d32:	mov	r4, r0
		close();
	}
     d34:	bl	d0c <SDFile::~SDFile()>
     d38:	mov	r0, r4
     d3a:	movs	r1, #92	; 0x5c
     d3c:	bl	a374 <operator delete(void*, unsigned int)>
     d40:	mov	r0, r4
     d42:	pop	{r4, pc}

00000d44 <SDFile::isOpen()>:
		}
		if (sdfatfile.isOpen()) {
			sdfatfile.close();
		}
	}
	virtual bool isOpen() {
     d44:	push	{r3, lr}
		return sdfatfile.isOpen();
     d46:	adds	r0, #24
     d48:	bl	cd2 <FsBaseFile::isOpen() const>
	}
     d4c:	pop	{r3, pc}

00000d4e <FsBaseFile::peek()>:
  uint64_t position() const {return curPosition();}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
     d4e:	mov	r3, r0
    return m_fFile ? m_fFile->peek() :
     d50:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->peek() : -1;
     d52:	cbz	r0, d58 <FsBaseFile::peek()+0xa>
     d54:	b.w	5f38 <FatFile::peek()>
     d58:	ldr	r0, [r3, #60]	; 0x3c
     d5a:	cbz	r0, d60 <FsBaseFile::peek()+0x12>
     d5c:	b.w	42dc <ExFatFile::peek()>
  }
     d60:	mov.w	r0, #4294967295
     d64:	bx	lr

00000d66 <StreamFile<FsBaseFile, unsigned long long>::peek()>:
  const char* name() const {return "use getName()";}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
     d66:	push	{r3, lr}
    return BaseFile::peek();
     d68:	adds	r0, #16
     d6a:	bl	d4e <FsBaseFile::peek()>
  }
     d6e:	pop	{r3, pc}

00000d70 <SDFile::peek()>:
		close();
	}
	virtual size_t write(const void *buf, size_t size) {
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
     d70:	push	{r3, lr}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    return BaseFile::peek();
     d72:	adds	r0, #24
     d74:	bl	d4e <FsBaseFile::peek()>
		return sdfatfile.peek();
	}
     d78:	pop	{r3, pc}

00000d7a <FsBaseFile::read(void*, unsigned int)>:
   * if end of file is reached.
   * If an error occurs, read() returns -1.  Possible errors include
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
     d7a:	mov	r3, r0
    return m_fFile ? m_fFile->read(buf, count) :
     d7c:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->read(buf, count) : -1;
     d7e:	cbz	r0, d84 <FsBaseFile::read(void*, unsigned int)+0xa>
     d80:	b.w	5dc0 <FatFile::read(void*, unsigned int)>
     d84:	ldr	r0, [r3, #60]	; 0x3c
     d86:	cbz	r0, d8c <FsBaseFile::read(void*, unsigned int)+0x12>
     d88:	b.w	4158 <ExFatFile::read(void*, unsigned int)>
  }
     d8c:	mov.w	r0, #4294967295
     d90:	bx	lr

00000d92 <StreamFile<FsBaseFile, unsigned long long>::read()>:
  /** Read the next byte from a file.
   *
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
     d92:	push	{r0, r1, r2, lr}
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
     d94:	movs	r2, #1
     d96:	add.w	r1, sp, #7
     d9a:	adds	r0, #16
     d9c:	bl	d7a <FsBaseFile::read(void*, unsigned int)>
     da0:	cmp	r0, #1
     da2:	ite	eq
     da4:	ldrbeq.w	r0, [sp, #7]
     da8:	movne.w	r0, #4294967295
    return BaseFile::read();
  }
     dac:	add	sp, #12
     dae:	ldr.w	pc, [sp], #4

00000db2 <SDFile::read(void*, unsigned int)>:
		return sdfatfile.available();
	}
	virtual void flush() {
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
     db2:	push	{r3, lr}
		return sdfatfile.read(buf, nbyte);
     db4:	adds	r0, #24
     db6:	bl	d7a <FsBaseFile::read(void*, unsigned int)>
	}
     dba:	pop	{r3, pc}

00000dbc <FsBaseFile::seekSet(unsigned long long)>:
   *
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
     dbc:	push	{r4, r6, r7}
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     dbe:	ldr	r4, [r0, #56]	; 0x38
           m_xFile ? m_xFile->seekSet(pos) : false;
     dc0:	cbz	r4, dd4 <FsBaseFile::seekSet(unsigned long long)+0x18>
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     dc2:	cmp	r3, #1
     dc4:	it	eq
     dc6:	cmpeq	r2, #0
     dc8:	bcs.n	dde <FsBaseFile::seekSet(unsigned long long)+0x22>
     dca:	mov	r0, r4
     dcc:	mov	r1, r2
           m_xFile ? m_xFile->seekSet(pos) : false;
  }
     dce:	pop	{r4, r6, r7}
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     dd0:	b.w	5f9a <FatFile::seekSet(unsigned long)>
           m_xFile ? m_xFile->seekSet(pos) : false;
     dd4:	ldr	r0, [r0, #60]	; 0x3c
     dd6:	cbz	r0, dde <FsBaseFile::seekSet(unsigned long long)+0x22>
  }
     dd8:	pop	{r4, r6, r7}
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     dda:	b.w	4308 <ExFatFile::seekSet(unsigned long long)>
  }
     dde:	movs	r0, #0
     de0:	pop	{r4, r6, r7}
     de2:	bx	lr

00000de4 <SDFile::seek(unsigned long long, int)>:
	virtual bool truncate(uint64_t size=0) {
		return sdfatfile.truncate(size);
	}
	virtual bool seek(uint64_t pos, int mode = SeekSet) {
     de4:	push	{r3, r4, r5, lr}
     de6:	mov	r1, r0
     de8:	ldr	r0, [sp, #16]
     dea:	mov	r4, r2
     dec:	mov	r5, r3
		if (mode == SeekSet) return sdfatfile.seekSet(pos);
     dee:	cbnz	r0, df6 <SDFile::seek(unsigned long long, int)+0x12>
     df0:	add.w	r0, r1, #24
     df4:	b.n	e32 <SDFile::seek(unsigned long long, int)+0x4e>
		if (mode == SeekCur) return sdfatfile.seekCur(pos);
     df6:	cmp	r0, #1
     df8:	bne.n	e10 <SDFile::seek(unsigned long long, int)+0x2c>
    return m_fFile ? m_fFile->contiguousRange(bgnSector, endSector) :
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
     dfa:	ldr	r3, [r1, #80]	; 0x50
     dfc:	add.w	r0, r1, #24
           m_xFile ? m_xFile->curPosition() : 0;
     e00:	cbz	r3, e06 <SDFile::seek(unsigned long long, int)+0x22>
     e02:	ldr	r2, [r3, #20]
     e04:	b.n	e2c <SDFile::seek(unsigned long long, int)+0x48>
     e06:	ldr	r3, [r1, #84]	; 0x54
     e08:	cbz	r3, e2a <SDFile::seek(unsigned long long, int)+0x46>
   *
   * \return true for success or false for failure.
   */
  bool contiguousRange(uint32_t* bgnSector, uint32_t* endSector);
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {return m_curPosition;}
     e0a:	ldrd	r2, r3, [r3]
     e0e:	b.n	e2e <SDFile::seek(unsigned long long, int)+0x4a>
		if (mode == SeekEnd) return sdfatfile.seekEnd(pos);
     e10:	cmp	r0, #2
     e12:	bne.n	e38 <SDFile::seek(unsigned long long, int)+0x54>
    return m_fFile ? m_fFile->fgets(str, num, delim) :
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
     e14:	ldr	r3, [r1, #80]	; 0x50
     e16:	add.w	r0, r1, #24
           m_xFile ? m_xFile->fileSize() : 0;
     e1a:	cbz	r3, e20 <SDFile::seek(unsigned long long, int)+0x3c>
     e1c:	ldr	r2, [r3, #28]
     e1e:	b.n	e2c <SDFile::seek(unsigned long long, int)+0x48>
     e20:	ldr	r3, [r1, #84]	; 0x54
     e22:	cbz	r3, e2a <SDFile::seek(unsigned long long, int)+0x46>
   * If no data is read, fgets() returns zero for EOF or -1 if an error
   * occurred.
   */
  int fgets(char* str, int num, char* delim = nullptr);
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {return m_validLength;}
     e24:	ldrd	r2, r3, [r3, #16]
     e28:	b.n	e2e <SDFile::seek(unsigned long long, int)+0x4a>
     e2a:	movs	r2, #0
     e2c:	movs	r3, #0
   * Can't be used for directory files since file size is not defined.
   * \param[in] offset The new position in bytes from end-of-file.
   * \return true for success or false for failure.
   */
  bool seekEnd(int64_t offset = 0) {
    return seekSet(fileSize() + offset);
     e2e:	adds	r2, r2, r4
     e30:	adcs	r3, r5
     e32:	bl	dbc <FsBaseFile::seekSet(unsigned long long)>
     e36:	pop	{r3, r4, r5, pc}
		return false;
     e38:	movs	r0, #0
	}
     e3a:	pop	{r3, r4, r5, pc}

00000e3c <FsBaseFile::sync()>:
  /** The sync() call causes all modified data and directory fields
   * to be written to the storage device.
   *
   * \return true for success or false for failure.
   */
  bool sync() {
     e3c:	mov	r3, r0
    return m_fFile ? m_fFile->sync() :
     e3e:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->sync() : false;
     e40:	cbz	r0, e46 <FsBaseFile::sync()+0xa>
     e42:	b.w	61f0 <FatFile::sync()>
     e46:	ldr	r0, [r3, #60]	; 0x3c
     e48:	cbz	r0, e4e <FsBaseFile::sync()+0x12>
     e4a:	b.w	4f20 <ExFatFile::sync()>
  }
     e4e:	bx	lr

00000e50 <StreamFile<FsBaseFile, unsigned long long>::flush()>:
   */
  int available() {
    return BaseFile::available();
  }
  /** Ensure that any bytes written to the file are saved to the SD card. */
  void flush() {
     e50:	push	{r3, lr}
    BaseFile::sync();
     e52:	adds	r0, #16
     e54:	bl	e3c <FsBaseFile::sync()>
     e58:	pop	{r3, pc}

00000e5a <SDFile::flush()>:
		return sdfatfile.peek();
	}
	virtual int available() {
		return sdfatfile.available();
	}
	virtual void flush() {
     e5a:	push	{r3, lr}
     e5c:	adds	r0, #24
     e5e:	bl	e3c <FsBaseFile::sync()>
     e62:	pop	{r3, pc}

00000e64 <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
   * Modify and access timestamps may be overwritten if a date time callback
   * function has been set by dateTimeCallback().
   *
   * \return true for success or false for failure.
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
     e64:	push	{r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
     e66:	ldr.w	lr, [r0, #56]	; 0x38
   * Modify and access timestamps may be overwritten if a date time callback
   * function has been set by dateTimeCallback().
   *
   * \return true for success or false for failure.
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
     e6a:	ldrb.w	r4, [sp, #20]
     e6e:	ldrb.w	r5, [sp, #24]
     e72:	ldrb.w	r6, [sp, #28]
     e76:	ldrb.w	r7, [sp, #32]
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     e7a:	cmp.w	lr, #0
     e7e:	beq.n	e92 <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x2e>
     e80:	str	r7, [sp, #32]
     e82:	str	r6, [sp, #28]
     e84:	str	r5, [sp, #24]
     e86:	str	r4, [sp, #20]
     e88:	mov	r0, lr
  }
     e8a:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     e8e:	b.w	66e4 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
     e92:	ldr	r0, [r0, #60]	; 0x3c
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     e94:	cbz	r0, ea6 <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x42>
     e96:	str	r7, [sp, #32]
     e98:	str	r6, [sp, #28]
     e9a:	str	r5, [sp, #24]
     e9c:	str	r4, [sp, #20]
  }
     e9e:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     ea2:	b.w	51e8 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
  }
     ea6:	pop	{r4, r5, r6, r7, pc}

00000ea8 <SDFile::setModifyTime(DateTimeFields const&)>:
	virtual bool setCreateTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
	virtual bool setModifyTime(const DateTimeFields &tm) {
     ea8:	push	{r0, r1, r2, r3, r4, lr}
		if (tm.year < 80 || tm.year > 207) return false;
     eaa:	ldrb	r2, [r1, #6]
     eac:	sub.w	r3, r2, #80	; 0x50
     eb0:	lsls	r3, r3, #24
     eb2:	bmi.n	ed8 <SDFile::setModifyTime(DateTimeFields const&)+0x30>
		return sdfatfile.timestamp(T_WRITE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
     eb4:	ldrb	r4, [r1, #0]
     eb6:	ldrb	r3, [r1, #5]
     eb8:	str	r4, [sp, #12]
     eba:	ldrb	r4, [r1, #1]
     ebc:	str	r4, [sp, #8]
     ebe:	ldrb	r4, [r1, #2]
     ec0:	str	r4, [sp, #4]
     ec2:	ldrb	r1, [r1, #4]
     ec4:	str	r1, [sp, #0]
     ec6:	adds	r3, #1
     ec8:	uxtb	r3, r3
     eca:	addw	r2, r2, #1900	; 0x76c
     ece:	movs	r1, #4
     ed0:	adds	r0, #24
     ed2:	bl	e64 <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
     ed6:	b.n	eda <SDFile::setModifyTime(DateTimeFields const&)+0x32>
		if (tm.year < 80 || tm.year > 207) return false;
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
	virtual bool setModifyTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
     ed8:	movs	r0, #0
		return sdfatfile.timestamp(T_WRITE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
     eda:	add	sp, #16
     edc:	pop	{r4, pc}

00000ede <SDFile::setCreateTime(DateTimeFields const&)>:
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
		tm.year = FS_YEAR(fat_date) - 1900;
		return true;
	}
	virtual bool setCreateTime(const DateTimeFields &tm) {
     ede:	push	{r0, r1, r2, r3, r4, lr}
		if (tm.year < 80 || tm.year > 207) return false;
     ee0:	ldrb	r2, [r1, #6]
     ee2:	sub.w	r3, r2, #80	; 0x50
     ee6:	lsls	r3, r3, #24
     ee8:	bmi.n	f0e <SDFile::setCreateTime(DateTimeFields const&)+0x30>
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
     eea:	ldrb	r4, [r1, #0]
     eec:	ldrb	r3, [r1, #5]
     eee:	str	r4, [sp, #12]
     ef0:	ldrb	r4, [r1, #1]
     ef2:	str	r4, [sp, #8]
     ef4:	ldrb	r4, [r1, #2]
     ef6:	str	r4, [sp, #4]
     ef8:	ldrb	r1, [r1, #4]
     efa:	str	r1, [sp, #0]
     efc:	adds	r3, #1
     efe:	uxtb	r3, r3
     f00:	addw	r2, r2, #1900	; 0x76c
     f04:	movs	r1, #2
     f06:	adds	r0, #24
     f08:	bl	e64 <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
     f0c:	b.n	f10 <SDFile::setCreateTime(DateTimeFields const&)+0x32>
		tm.mon = FS_MONTH(fat_date) - 1;
		tm.year = FS_YEAR(fat_date) - 1900;
		return true;
	}
	virtual bool setCreateTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
     f0e:	movs	r0, #0
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
     f10:	add	sp, #16
     f12:	pop	{r4, pc}

00000f14 <FsBaseFile::write(void const*, unsigned int)>:
   * \param[in] count Number of bytes to write.
   *
   * \return For success write() returns the number of bytes written, always
   * \a nbyte.  If an error occurs, write() returns zero and writeError is set.
   */
  size_t write(const void* buf, size_t count) {
     f14:	mov	r3, r0
    return m_fFile ? m_fFile->write(buf, count) :
     f16:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->write(buf, count) : 0;
     f18:	cbz	r0, f1e <FsBaseFile::write(void const*, unsigned int)+0xa>
     f1a:	b.w	67fc <FatFile::write(void const*, unsigned int)>
     f1e:	ldr	r0, [r3, #60]	; 0x3c
     f20:	cbz	r0, f26 <FsBaseFile::write(void const*, unsigned int)+0x12>
     f22:	b.w	53b8 <ExFatFile::write(void const*, unsigned int)>
  }
     f26:	bx	lr

00000f28 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)>:
   * \param[in] size Number of bytes to write.
   *
   * \return For success write() returns the number of bytes written, always
   * \a size.
   */
  size_t write(const uint8_t* buffer, size_t size) {
     f28:	push	{r3, lr}
    return BaseFile::write(buffer, size);
     f2a:	adds	r0, #16
     f2c:	bl	f14 <FsBaseFile::write(void const*, unsigned int)>
  }
     f30:	pop	{r3, pc}

00000f32 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)>:
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {
     f32:	push	{r0, r1, r2, lr}
     f34:	add	r3, sp, #8
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {return write(&b, 1);}
     f36:	movs	r2, #1
     f38:	strb.w	r1, [r3, #-1]!
     f3c:	adds	r0, #16
     f3e:	mov	r1, r3
     f40:	bl	f14 <FsBaseFile::write(void const*, unsigned int)>
    return BaseFile::write(b);
  }
     f44:	add	sp, #12
     f46:	ldr.w	pc, [sp], #4

00000f4a <SDFile::write(void const*, unsigned int)>:
	friend class SDClass;
public:
	virtual ~SDFile(void) {
		close();
	}
	virtual size_t write(const void *buf, size_t size) {
     f4a:	push	{r3, lr}
		return sdfatfile.write(buf, size);
     f4c:	adds	r0, #24
     f4e:	bl	f14 <FsBaseFile::write(void const*, unsigned int)>
	}
     f52:	pop	{r3, pc}

00000f54 <File::close()>:
		return (f) ? f->position() : 0;
	}
	uint64_t size() {
		return (f) ? f->size() : 0;
	}
	void close() {
     f54:	push	{r4, lr}
     f56:	mov	r4, r0
		if (f) {
     f58:	ldr	r0, [r0, #16]
     f5a:	cbz	r0, f6e <File::close()+0x1a>
			f->close();
     f5c:	ldr	r3, [r0, #0]
     f5e:	ldr	r3, [r3, #44]	; 0x2c
     f60:	blx	r3
			dec_refcount();
     f62:	add.w	r0, r4, #16
		}
	}
     f66:	ldmia.w	sp!, {r4, lr}
		return (f) ? f->size() : 0;
	}
	void close() {
		if (f) {
			f->close();
			dec_refcount();
     f6a:	b.w	b94 <File::dec_refcount() [clone .isra.15]>
     f6e:	pop	{r4, pc}

00000f70 <SDFile::SDFile(FsFile const&)>:
	// Classes derived from File are never meant to be constructed
	// anywhere other than open() in the parent FS class and
	// openNextFile() while traversing a directory.
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
     f70:	push	{r3, r4, r5, lr}
// FileImpl instances are automatically deleted when the last referencing
// File is closed or goes out of scope.  The refcount variable is meant to
// be maintained by File class instances, never access by FileImpl functions.
// The FileImpl functions are meant to be called only by use of File instances.
//
class FileImpl {
     f72:	movs	r5, #0
     f74:	ldr	r3, [pc, #40]	; (fa0 <SDFile::SDFile(FsFile const&)+0x30>)
     f76:	str	r5, [r0, #4]
     f78:	str	r3, [r0, #0]
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
     f7a:	ldrb	r3, [r1, #4]
     f7c:	strb	r3, [r0, #12]
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
     f7e:	ldr	r3, [pc, #36]	; (fa4 <SDFile::SDFile(FsFile const&)+0x34>)
     f80:	str	r3, [r0, #8]
     f82:	ldr	r3, [r1, #8]
     f84:	str	r3, [r0, #16]
     f86:	ldrb	r3, [r1, #12]
     f88:	strb	r3, [r0, #20]
     f8a:	mov	r4, r0
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     f8c:	adds	r1, #16
     f8e:	adds	r0, #24
     f90:	bl	744e <FsBaseFile::FsBaseFile(FsBaseFile const&)>
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     f94:	ldr	r3, [pc, #16]	; (fa8 <SDFile::SDFile(FsFile const&)+0x38>)
     f96:	str	r3, [r4, #8]
     f98:	str	r5, [r4, #88]	; 0x58
     f9a:	mov	r0, r4
     f9c:	pop	{r3, r4, r5, pc}
     f9e:	nop
     fa0:	.word	0x00012568
     fa4:	.word	0x000124d0
     fa8:	.word	0x00012518

00000fac <SDFile::openNextFile(unsigned char)>:
		return filename;
	}
	virtual boolean isDirectory(void) {
		return sdfatfile.isDirectory();
	}
	virtual File openNextFile(uint8_t mode=0) {
     fac:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     fb0:	sub	sp, #84	; 0x54
{
  public:
	constexpr Print() : write_error(0) {}
     fb2:	movs	r5, #0
     fb4:	add.w	r8, sp, #80	; 0x50
     fb8:	ldr	r3, [pc, #108]	; (1028 <SDFile::openNextFile(unsigned char)+0x7c>)
     fba:	str.w	r3, [r8, #-80]!
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
     fbe:	mov	r2, r5
     fc0:	adds	r1, #24
     fc2:	mov	r4, r0
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     fc4:	mov.w	r6, #1000	; 0x3e8
     fc8:	add	r0, sp, #16
     fca:	strb.w	r5, [sp, #4]
     fce:	str	r6, [sp, #8]
     fd0:	strb.w	r5, [sp, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
     fd4:	str	r5, [sp, #72]	; 0x48
     fd6:	str	r5, [sp, #76]	; 0x4c
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
     fd8:	bl	7556 <FsBaseFile::openNext(FsBaseFile*, int)>
  FsBaseFile& operator=(const FsBaseFile& from);
  /** The parenthesis operator.
    *
    * \return true if a file is open.
    */
  operator bool() const {return isOpen();}
     fdc:	add	r0, sp, #16
     fde:	bl	cd2 <FsBaseFile::isOpen() const>
     fe2:	ldr.w	r9, [pc, #76]	; 1030 <SDFile::openNextFile(unsigned char)+0x84>
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
     fe6:	cbz	r0, 100a <SDFile::openNextFile(unsigned char)+0x5e>
     fe8:	movs	r0, #92	; 0x5c
     fea:	bl	a370 <operator new(unsigned int)>
     fee:	mov	r7, r0
     ff0:	mov	r1, r8
     ff2:	bl	f70 <SDFile::SDFile(FsFile const&)>
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
		if (f) f->refcount++;
     ff6:	ldr	r3, [r7, #4]
     ff8:	strb	r5, [r4, #4]
     ffa:	adds	r3, #1
     ffc:	str	r6, [r4, #8]
     ffe:	strb	r5, [r4, #12]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
    1000:	str.w	r9, [r4]
		f = file;
    1004:	str	r7, [r4, #16]
		if (f) f->refcount++;
    1006:	str	r3, [r7, #4]
    1008:	b.n	1016 <SDFile::openNextFile(unsigned char)+0x6a>
    100a:	strb	r0, [r4, #4]
    100c:	str	r6, [r4, #8]
    100e:	strb	r0, [r4, #12]
//
class File final : public Stream {
public:
	// Empty constructor, used when a program creates a File variable
	// but does not immediately assign or initialize it.
	constexpr File() : f(nullptr) { }
    1010:	str.w	r9, [r4]
    1014:	str	r0, [r4, #16]
    1016:	ldr	r3, [pc, #20]	; (102c <SDFile::openNextFile(unsigned char)+0x80>)
    1018:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
    101a:	add	r0, sp, #16
    101c:	bl	74b0 <FsBaseFile::close()>
		return File();
	}
    1020:	mov	r0, r4
    1022:	add	sp, #84	; 0x54
    1024:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    1028:	.word	0x00012518
    102c:	.word	0x000124f4
    1030:	.word	0x0001253c

00001034 <SDClass::open(char const*, unsigned char)>:
class SDClass : public FS
{
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
    1034:	push	{r4, r5, r6, lr}
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
    1036:	cmp	r3, #1
class SDClass : public FS
{
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
    1038:	sub	sp, #80	; 0x50
    103a:	mov	r4, r0
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
    103c:	beq.n	104a <SDClass::open(char const*, unsigned char)+0x16>
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
    103e:	cmp	r3, #2
    1040:	movw	r3, #514	; 0x202
    1044:	it	ne
    1046:	movne	r3, #0
    1048:	b.n	104e <SDClass::open(char const*, unsigned char)+0x1a>
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
    104a:	movw	r3, #16898	; 0x4202
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
    104e:	adds	r1, #4
    1050:	mov	r0, sp
    1052:	bl	7670 <FsVolume::open(char const*, int)>
  FsBaseFile& operator=(const FsBaseFile& from);
  /** The parenthesis operator.
    *
    * \return true if a file is open.
    */
  operator bool() const {return isOpen();}
    1056:	add	r0, sp, #16
    1058:	bl	cd2 <FsBaseFile::isOpen() const>
    105c:	ldr	r6, [pc, #68]	; (10a4 <SDClass::open(char const*, unsigned char)+0x70>)
		if (file) return File(new SDFile(file));
    105e:	cbz	r0, 1086 <SDClass::open(char const*, unsigned char)+0x52>
    1060:	movs	r0, #92	; 0x5c
    1062:	bl	a370 <operator new(unsigned int)>
    1066:	mov	r1, sp
    1068:	mov	r5, r0
    106a:	bl	f70 <SDFile::SDFile(FsFile const&)>
    106e:	movs	r3, #0
    1070:	strb	r3, [r4, #4]
    1072:	strb	r3, [r4, #12]
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
		if (f) f->refcount++;
    1074:	ldr	r3, [r5, #4]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
    1076:	str	r6, [r4, #0]
    1078:	mov.w	r2, #1000	; 0x3e8
		f = file;
		if (f) f->refcount++;
    107c:	adds	r3, #1
    107e:	str	r2, [r4, #8]
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
    1080:	str	r5, [r4, #16]
		if (f) f->refcount++;
    1082:	str	r3, [r5, #4]
    1084:	b.n	1094 <SDClass::open(char const*, unsigned char)+0x60>
    1086:	mov.w	r3, #1000	; 0x3e8
    108a:	strb	r0, [r4, #4]
    108c:	str	r3, [r4, #8]
    108e:	strb	r0, [r4, #12]
//
class File final : public Stream {
public:
	// Empty constructor, used when a program creates a File variable
	// but does not immediately assign or initialize it.
	constexpr File() : f(nullptr) { }
    1090:	str	r6, [r4, #0]
    1092:	str	r0, [r4, #16]
    1094:	ldr	r3, [pc, #16]	; (10a8 <SDClass::open(char const*, unsigned char)+0x74>)
    1096:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
    1098:	add	r0, sp, #16
    109a:	bl	74b0 <FsBaseFile::close()>
		return File();
	}
    109e:	mov	r0, r4
    10a0:	add	sp, #80	; 0x50
    10a2:	pop	{r4, r5, r6, pc}
    10a4:	.word	0x0001253c
    10a8:	.word	0x000124f4

000010ac <storeConfig(unsigned short*, int)>:
uint16_t store[16];

extern  int t_acq;

void storeConfig(uint16_t *store, int ns)
{ 
    10ac:	push	{r4, r5, r6, lr}
    10ae:	sub	sp, #56	; 0x38
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    10b0:	ldr	r3, [pc, #120]	; (112c <storeConfig(unsigned short*, int)+0x80>)
    10b2:	str	r3, [sp, #4]
    10b4:	mov.w	r2, #1000	; 0x3e8
    10b8:	movs	r3, #0
    10ba:	strb.w	r3, [sp, #8]
    10be:	str	r2, [sp, #12]
    10c0:	strb.w	r3, [sp, #16]
    10c4:	str	r3, [sp, #20]
uint16_t store[16];

extern  int t_acq;

void storeConfig(uint16_t *store, int ns)
{ 
    10c6:	mov	r5, r0
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    char text[32];
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
    10c8:	movs	r3, #2
uint16_t store[16];

extern  int t_acq;

void storeConfig(uint16_t *store, int ns)
{ 
    10ca:	mov	r6, r1
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    char text[32];
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
    10cc:	ldr	r2, [pc, #96]	; (1130 <storeConfig(unsigned short*, int)+0x84>)
    10ce:	ldr	r1, [pc, #100]	; (1134 <storeConfig(unsigned short*, int)+0x88>)
    10d0:	add	r0, sp, #24
    10d2:	bl	1034 <SDClass::open(char const*, unsigned char)>
	}
#ifdef FILE_USE_MOVE
	// Move assignment.
	File& operator = (const File&& file) {
		//Serial.println("File move assignment");
		if (file.f) file.f->refcount++;
    10d6:	ldr	r3, [sp, #40]	; 0x28
    10d8:	cbz	r3, 10e0 <storeConfig(unsigned short*, int)+0x34>
    10da:	ldr	r2, [r3, #4]
    10dc:	adds	r2, #1
    10de:	str	r2, [r3, #4]
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
    10e0:	ldr	r3, [sp, #20]
    10e2:	cbz	r3, 10ea <storeConfig(unsigned short*, int)+0x3e>
    10e4:	add	r0, sp, #20
    10e6:	bl	b94 <File::dec_refcount() [clone .isra.15]>
		f = file.f;
    10ea:	ldr	r3, [sp, #40]	; 0x28
    10ec:	str	r3, [sp, #20]
    10ee:	add	r0, sp, #24
    10f0:	bl	bb8 <File::~File()>
      for(int ii=0; ii<ns; ii++)
    10f4:	movs	r4, #0
    10f6:	cmp	r4, r6
    10f8:	bge.n	111a <storeConfig(unsigned short*, int)+0x6e>
      { sprintf(text,"%10d\r\n",(int) store[ii]); configFile.write((uint8_t*)text,strlen(text)); }
    10fa:	ldrh.w	r2, [r5, r4, lsl #1]
    10fe:	ldr	r1, [pc, #56]	; (1138 <storeConfig(unsigned short*, int)+0x8c>)
    1100:	add	r0, sp, #24
    1102:	bl	be68 <sprintf>
    1106:	add	r0, sp, #24
    1108:	bl	bf40 <strlen>
    110c:	add	r1, sp, #24
    110e:	mov	r2, r0
    1110:	add	r0, sp, #4
    1112:	bl	9d6 <File::write(unsigned char const*, unsigned int)>
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    char text[32];
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
      for(int ii=0; ii<ns; ii++)
    1116:	adds	r4, #1
    1118:	b.n	10f6 <storeConfig(unsigned short*, int)+0x4a>
      { sprintf(text,"%10d\r\n",(int) store[ii]); configFile.write((uint8_t*)text,strlen(text)); }
    configFile.close();
    111a:	add	r0, sp, #4
    111c:	bl	f54 <File::close()>

void storeConfig(uint16_t *store, int ns)
{ 
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    1120:	add	r0, sp, #4
    1122:	bl	bb8 <File::~File()>
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
      for(int ii=0; ii<ns; ii++)
      { sprintf(text,"%10d\r\n",(int) store[ii]); configFile.write((uint8_t*)text,strlen(text)); }
    configFile.close();
  
}
    1126:	add	sp, #56	; 0x38
    1128:	pop	{r4, r5, r6, pc}
    112a:	nop
    112c:	.word	0x0001253c
    1130:	.word	0x000125bc
    1134:	.word	0x2001a458
    1138:	.word	0x000125c8

0000113c <saveParameters()>:
    configFile.close();
}

void saveParameters(void)
{
  store[0]= 1;
    113c:	ldr	r0, [pc, #16]	; (1150 <saveParameters()+0x14>)
    113e:	movs	r3, #1
    1140:	strh	r3, [r0, #0]
  store[2]= t_acq;
    1142:	ldr	r3, [pc, #16]	; (1154 <saveParameters()+0x18>)

  storeConfig(store, 16);
    1144:	movs	r1, #16
}

void saveParameters(void)
{
  store[0]= 1;
  store[2]= t_acq;
    1146:	ldr	r3, [r3, #0]
    1148:	strh	r3, [r0, #4]

  storeConfig(store, 16);
    114a:	b.w	10ac <storeConfig(unsigned short*, int)>
    114e:	nop
    1150:	.word	0x1fff220a
    1154:	.word	0x1fff0f38

00001158 <printMenu()>:
  }
}


void printMenu(void)
{
    1158:	push	{r4, lr}
  Serial.println("\n Menu");
    115a:	ldr	r4, [pc, #144]	; (11ec <printMenu()+0x94>)
    115c:	ldr	r1, [pc, #144]	; (11f0 <printMenu()+0x98>)
    115e:	mov	r0, r4
    1160:	bl	784 <Print::println(char const*)>
  Serial.println(" ':h'  : print help");
    1164:	ldr	r1, [pc, #140]	; (11f4 <printMenu()+0x9c>)
    1166:	mov	r0, r4
    1168:	bl	784 <Print::println(char const*)>
  Serial.println(" ':s'  : start acquisition");
    116c:	ldr	r1, [pc, #136]	; (11f8 <printMenu()+0xa0>)
    116e:	mov	r0, r4
    1170:	bl	784 <Print::println(char const*)>
  Serial.println(" ':e'  : stop acquisition");
    1174:	ldr	r1, [pc, #132]	; (11fc <printMenu()+0xa4>)
    1176:	mov	r0, r4
    1178:	bl	784 <Print::println(char const*)>
  Serial.println(" ':w'  : write parameters to microSD card");
    117c:	ldr	r1, [pc, #128]	; (1200 <printMenu()+0xa8>)
    117e:	mov	r0, r4
    1180:	bl	784 <Print::println(char const*)>
  Serial.println(" ':l'  : list disks");
    1184:	ldr	r1, [pc, #124]	; (1204 <printMenu()+0xac>)
    1186:	mov	r0, r4
    1188:	bl	784 <Print::println(char const*)>
  Serial.println(" ':r'  : reset MTP");
    118c:	ldr	r1, [pc, #120]	; (1208 <printMenu()+0xb0>)
    118e:	mov	r0, r4
    1190:	bl	784 <Print::println(char const*)>
  Serial.println(" ':b'  : reboot CPU");
    1194:	ldr	r1, [pc, #116]	; (120c <printMenu()+0xb4>)
    1196:	mov	r0, r4
    1198:	bl	784 <Print::println(char const*)>
//  Serial.println(" ':d'  : dump Index List (testing)");
  Serial.println();
    119c:	mov	r0, r4
    119e:	bl	a178 <Print::println()>
  Serial.println(" '?p'  : show all parameters");
    11a2:	ldr	r1, [pc, #108]	; (1210 <printMenu()+0xb8>)
    11a4:	mov	r0, r4
    11a6:	bl	784 <Print::println(char const*)>
  Serial.println(" '?d'  : get date");
    11aa:	ldr	r1, [pc, #104]	; (1214 <printMenu()+0xbc>)
    11ac:	mov	r0, r4
    11ae:	bl	784 <Print::println(char const*)>
  Serial.println(" '?t'  : get time");
    11b2:	ldr	r1, [pc, #100]	; (1218 <printMenu()+0xc0>)
    11b4:	mov	r0, r4
    11b6:	bl	784 <Print::println(char const*)>
  Serial.println(" '?a'  : get file duration (s)");
    11ba:	ldr	r1, [pc, #96]	; (121c <printMenu()+0xc4>)
    11bc:	mov	r0, r4
    11be:	bl	784 <Print::println(char const*)>
  Serial.println();
    11c2:	mov	r0, r4
    11c4:	bl	a178 <Print::println()>
  Serial.println(" '!d yyyy/mm/dd<cr>'  : set date");
    11c8:	ldr	r1, [pc, #84]	; (1220 <printMenu()+0xc8>)
    11ca:	mov	r0, r4
    11cc:	bl	784 <Print::println(char const*)>
  Serial.println(" '!t hh:mm:ss<cr>'    : set time");
    11d0:	ldr	r1, [pc, #80]	; (1224 <printMenu()+0xcc>)
    11d2:	mov	r0, r4
    11d4:	bl	784 <Print::println(char const*)>
  Serial.println(" '!a val<cr>'  : set file duration (s)");
    11d8:	mov	r0, r4
    11da:	ldr	r1, [pc, #76]	; (1228 <printMenu()+0xd0>)
    11dc:	bl	784 <Print::println(char const*)>
  Serial.println();
    11e0:	mov	r0, r4
}
    11e2:	ldmia.w	sp!, {r4, lr}
  Serial.println(" '?a'  : get file duration (s)");
  Serial.println();
  Serial.println(" '!d yyyy/mm/dd<cr>'  : set date");
  Serial.println(" '!t hh:mm:ss<cr>'    : set time");
  Serial.println(" '!a val<cr>'  : set file duration (s)");
  Serial.println();
    11e6:	b.w	a178 <Print::println()>
    11ea:	nop
    11ec:	.word	0x1fff136c
    11f0:	.word	0x000125cf
    11f4:	.word	0x000125d6
    11f8:	.word	0x000125ea
    11fc:	.word	0x00012605
    1200:	.word	0x0001261f
    1204:	.word	0x00012649
    1208:	.word	0x0001265d
    120c:	.word	0x00012670
    1210:	.word	0x00012684
    1214:	.word	0x000126a1
    1218:	.word	0x000126b3
    121c:	.word	0x000126c5
    1220:	.word	0x000126e4
    1224:	.word	0x00012705
    1228:	.word	0x00012726

0000122c <printMenuEntries()>:
}

void printMenuEntries(void)
{
    122c:	push	{r0, r1, r2, r3, r4, lr}
    tmElements_t tm;
    breakTime(rtc_get(), tm);

  Serial.println("CVAS_V3 Version: " __DATE__  " " __TIME__ );
    122e:	ldr	r4, [pc, #96]	; (1290 <printMenuEntries()+0x64>)
}

void printMenuEntries(void)
{
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    1230:	bl	93fc <rtc_get>
    1234:	add	r1, sp, #8
    1236:	bl	1580 <breakTime(unsigned long, tmElements_t&)>

  Serial.println("CVAS_V3 Version: " __DATE__  " " __TIME__ );
    123a:	ldr	r1, [pc, #88]	; (1294 <printMenuEntries()+0x68>)
    123c:	mov	r0, r4
    123e:	bl	784 <Print::println(char const*)>
  Serial.printf("Teensy: %d: %06x\n",teensy,SerNum);
    1242:	ldr	r3, [pc, #84]	; (1298 <printMenuEntries()+0x6c>)
    1244:	ldr	r1, [pc, #84]	; (129c <printMenuEntries()+0x70>)
    1246:	ldr	r3, [r3, #0]
    1248:	movs	r2, #36	; 0x24
    124a:	mov	r0, r4
    124c:	bl	a198 <Print::printf(char const*, ...)>
  Serial.printf("Date d = %04d/%02d/%02d\n",tmYearToCalendar(tm.Year), tm.Month, tm.Day); 
    1250:	ldrb.w	r2, [sp, #14]
    1254:	ldrb.w	r1, [sp, #12]
    1258:	ldrb.w	r3, [sp, #13]
    125c:	str	r1, [sp, #0]
    125e:	addw	r2, r2, #1970	; 0x7b2
    1262:	ldr	r1, [pc, #60]	; (12a0 <printMenuEntries()+0x74>)
    1264:	mov	r0, r4
    1266:	bl	a198 <Print::printf(char const*, ...)>
  Serial.printf("Time t = %02d:%02d:%02d\n",tm.Hour, tm.Minute, tm.Second); 
    126a:	ldrb.w	r1, [sp, #8]
    126e:	ldrb.w	r3, [sp, #9]
    1272:	ldrb.w	r2, [sp, #10]
    1276:	str	r1, [sp, #0]
    1278:	mov	r0, r4
    127a:	ldr	r1, [pc, #40]	; (12a4 <printMenuEntries()+0x78>)
    127c:	bl	a198 <Print::printf(char const*, ...)>
  Serial.printf("T_acq a = %d\n",t_acq); 
    1280:	ldr	r3, [pc, #36]	; (12a8 <printMenuEntries()+0x7c>)
    1282:	ldr	r1, [pc, #40]	; (12ac <printMenuEntries()+0x80>)
    1284:	ldr	r2, [r3, #0]
    1286:	mov	r0, r4
    1288:	bl	a198 <Print::printf(char const*, ...)>
}
    128c:	add	sp, #16
    128e:	pop	{r4, pc}
    1290:	.word	0x1fff136c
    1294:	.word	0x0001274d
    1298:	.word	0x1fff222c
    129c:	.word	0x00012773
    12a0:	.word	0x00012785
    12a4:	.word	0x0001279e
    12a8:	.word	0x1fff0f38
    12ac:	.word	0x000127b7

000012b0 <menuGetInt(int*)>:

int menuGetInt(int *val)
{ char buffer[40];
    12b0:	push	{r4, lr}
    12b2:	mov	r4, r0
    12b4:	sub	sp, #40	; 0x28
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    12b6:	bl	9140 <usb_serial_available>
  while(!Serial.available());
    12ba:	cmp	r0, #0
    12bc:	beq.n	12b6 <menuGetInt(int*)+0x6>
  int count = Serial.readBytesUntil('\r',buffer,40);
    12be:	mov	r2, sp
    12c0:	movs	r3, #40	; 0x28
    12c2:	movs	r1, #13
    12c4:	ldr	r0, [pc, #28]	; (12e4 <menuGetInt(int*)+0x34>)
    12c6:	bl	a328 <Stream::readBytesUntil(char, char*, unsigned int)>
  buffer[count]=0;
    12ca:	add	r3, sp, #40	; 0x28
    12cc:	add	r0, r3
    12ce:	movs	r3, #0
    12d0:	strb.w	r3, [r0, #-40]
//  Serial.println(buffer);
  return sscanf(buffer,"%d",val);
    12d4:	mov	r2, r4
    12d6:	ldr	r1, [pc, #16]	; (12e8 <menuGetInt(int*)+0x38>)
    12d8:	mov	r0, sp
    12da:	bl	beb4 <sscanf>
}
    12de:	add	sp, #40	; 0x28
    12e0:	pop	{r4, pc}
    12e2:	nop
    12e4:	.word	0x1fff136c
    12e8:	.word	0x00012844

000012ec <menuGet3Int(int*, int*, int*)>:

int menuGet3Int(int *val1, int *val2, int *val3)
{ char buffer[40];
    12ec:	push	{r4, r5, r6, lr}
    12ee:	mov	r4, r0
    12f0:	sub	sp, #64	; 0x40
    12f2:	mov	r5, r1
    12f4:	mov	r6, r2
    12f6:	bl	9140 <usb_serial_available>
  while(!Serial.available());
    12fa:	cmp	r0, #0
    12fc:	beq.n	12f6 <menuGet3Int(int*, int*, int*)+0xa>
  int count = Serial.readBytesUntil('\r',buffer,40);
    12fe:	add	r2, sp, #24
    1300:	movs	r3, #40	; 0x28
    1302:	movs	r1, #13
    1304:	ldr	r0, [pc, #40]	; (1330 <menuGet3Int(int*, int*, int*)+0x44>)
    1306:	bl	a328 <Stream::readBytesUntil(char, char*, unsigned int)>
  buffer[count]=0;
    130a:	add	r3, sp, #64	; 0x40
    130c:	add	r0, r3
    130e:	movs	r3, #0
    1310:	strb.w	r3, [r0, #-40]
//  Serial.println(buffer);
  char c1,c2;
  return sscanf(buffer,"%d%c%d%c%d",val1,&c1,val2,&c2,val3);
    1314:	add.w	r3, sp, #23
    1318:	str	r3, [sp, #4]
    131a:	str	r6, [sp, #8]
    131c:	str	r5, [sp, #0]
    131e:	add.w	r3, sp, #22
    1322:	mov	r2, r4
    1324:	ldr	r1, [pc, #12]	; (1334 <menuGet3Int(int*, int*, int*)+0x48>)
    1326:	add	r0, sp, #24
    1328:	bl	beb4 <sscanf>
}
    132c:	add	sp, #64	; 0x40
    132e:	pop	{r4, r5, r6, pc}
    1330:	.word	0x1fff136c
    1334:	.word	0x000127c5

00001338 <menu()>:
#if defined (KINETISK) 
#define CPU_RESTART 
#endif

int16_t menu(void)
{
    1338:	push	{r4, lr}
    133a:	sub	sp, #32
    133c:	bl	9140 <usb_serial_available>
  if(!Serial.available()) return 0;
    1340:	cmp	r0, #0
    1342:	beq.w	14c0 <menu()+0x188>
        virtual int read() { return usb_serial_getchar(); }
    1346:	bl	90bc <usb_serial_getchar>

  char ch=Serial.read();
    134a:	uxtb	r0, r0
  if(ch==':')
    134c:	cmp	r0, #58	; 0x3a
    134e:	bne.n	13d0 <menu()+0x98>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    1350:	bl	9140 <usb_serial_available>
  { while(!Serial.available()) ; ch=Serial.read();
    1354:	cmp	r0, #0
    1356:	beq.n	1350 <menu()+0x18>
        virtual int read() { return usb_serial_getchar(); }
    1358:	bl	90bc <usb_serial_getchar>
    135c:	uxtb	r0, r0

    if(ch=='s') { Serial.print("\n"); Serial.print("start"); return  +1;} // start acq
    135e:	cmp	r0, #115	; 0x73
    1360:	bne.n	1376 <menu()+0x3e>
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
    1362:	ldr	r1, [pc, #356]	; (14c8 <menu()+0x190>)
    1364:	ldr	r0, [pc, #356]	; (14cc <menu()+0x194>)
    1366:	bl	760 <Print::write(char const*)>
    136a:	ldr	r1, [pc, #356]	; (14d0 <menu()+0x198>)
    136c:	ldr	r0, [pc, #348]	; (14cc <menu()+0x194>)
    136e:	bl	760 <Print::write(char const*)>
    1372:	movs	r0, #1
    1374:	b.n	14c2 <menu()+0x18a>
    else if(ch=='e') { Serial.print("\n"); Serial.print("stop");  return  -1;} // end acq
    1376:	cmp	r0, #101	; 0x65
    1378:	bne.n	1390 <menu()+0x58>
    137a:	ldr	r1, [pc, #332]	; (14c8 <menu()+0x190>)
    137c:	ldr	r0, [pc, #332]	; (14cc <menu()+0x194>)
    137e:	bl	760 <Print::write(char const*)>
    1382:	ldr	r1, [pc, #336]	; (14d4 <menu()+0x19c>)
    1384:	ldr	r0, [pc, #324]	; (14cc <menu()+0x194>)
    1386:	bl	760 <Print::write(char const*)>
    138a:	mov.w	r0, #4294967295
    138e:	b.n	14c2 <menu()+0x18a>
    else if(ch=='h') { printMenu(); return 0;} 
    1390:	cmp	r0, #104	; 0x68
    1392:	bne.n	139a <menu()+0x62>
    1394:	bl	1158 <printMenu()>
    1398:	b.n	14c0 <menu()+0x188>
    else if(ch=='w') { saveParameters(); return 0;} 
    139a:	cmp	r0, #119	; 0x77
    139c:	bne.n	13a4 <menu()+0x6c>
    139e:	bl	113c <saveParameters()>
    13a2:	b.n	14c0 <menu()+0x188>
    else if(ch=='l') { listDisks(); return 0;} 
    13a4:	cmp	r0, #108	; 0x6c
    13a6:	bne.n	13ae <menu()+0x76>
    13a8:	bl	1df0 <listDisks()>
    13ac:	b.n	14c0 <menu()+0x188>
    else if(ch=='b') { Serial.print("\n"); Serial.print("rebooting CPU"); Serial.flush(); delay(100); CPU_RESTART; return 0;} 
    13ae:	cmp	r0, #98	; 0x62
    13b0:	bne.w	14c0 <menu()+0x188>
    13b4:	ldr	r1, [pc, #272]	; (14c8 <menu()+0x190>)
    13b6:	ldr	r0, [pc, #276]	; (14cc <menu()+0x194>)
    13b8:	bl	760 <Print::write(char const*)>
    13bc:	ldr	r1, [pc, #280]	; (14d8 <menu()+0x1a0>)
    13be:	ldr	r0, [pc, #268]	; (14cc <menu()+0x194>)
    13c0:	bl	760 <Print::write(char const*)>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    13c4:	bl	92cc <usb_serial_flush_output>
    13c8:	movs	r0, #100	; 0x64
    13ca:	bl	950c <delay>
    13ce:	b.n	14c0 <menu()+0x188>
  }
  else if(ch=='?') // get info
    13d0:	cmp	r0, #63	; 0x3f
    13d2:	bne.n	143e <menu()+0x106>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    13d4:	bl	9140 <usb_serial_available>
  {
    while(!Serial.available()) ; ch=Serial.read();
    13d8:	cmp	r0, #0
    13da:	beq.n	13d4 <menu()+0x9c>
        virtual int read() { return usb_serial_getchar(); }
    13dc:	bl	90bc <usb_serial_getchar>
    13e0:	uxtb	r4, r0

    tmElements_t tm;
    breakTime(rtc_get(), tm);
    13e2:	bl	93fc <rtc_get>
    13e6:	add	r1, sp, #24
    13e8:	bl	1580 <breakTime(unsigned long, tmElements_t&)>

    if(ch=='p') { printMenuEntries(); return 0;} 
    13ec:	cmp	r4, #112	; 0x70
    13ee:	bne.n	13f6 <menu()+0xbe>
    13f0:	bl	122c <printMenuEntries()>
    13f4:	b.n	14c0 <menu()+0x188>
    else if(ch=='d') { Serial.printf("%04d/%02d/%02d\n",tmYearToCalendar(tm.Year), tm.Month, tm.Day); return  0;} // display date
    13f6:	cmp	r4, #100	; 0x64
    13f8:	bne.n	1410 <menu()+0xd8>
    13fa:	ldrb.w	r2, [sp, #30]
    13fe:	ldrb.w	r1, [sp, #28]
    1402:	str	r1, [sp, #0]
    1404:	ldrb.w	r3, [sp, #29]
    1408:	ldr	r1, [pc, #208]	; (14dc <menu()+0x1a4>)
    140a:	addw	r2, r2, #1970	; 0x7b2
    140e:	b.n	1424 <menu()+0xec>
    else if(ch=='t') { Serial.printf("%02d:%02d:%02d\n",tm.Hour, tm.Minute, tm.Second); return  0;} // display time
    1410:	cmp	r4, #116	; 0x74
    1412:	bne.n	142c <menu()+0xf4>
    1414:	ldrb.w	r1, [sp, #24]
    1418:	str	r1, [sp, #0]
    141a:	ldrb.w	r3, [sp, #25]
    141e:	ldrb.w	r2, [sp, #26]
    1422:	ldr	r1, [pc, #188]	; (14e0 <menu()+0x1a8>)
    1424:	ldr	r0, [pc, #164]	; (14cc <menu()+0x194>)
    1426:	bl	a198 <Print::printf(char const*, ...)>
    142a:	b.n	14c0 <menu()+0x188>
    else if(ch=='a') { Serial.printf("%d\n",t_acq); return  0;} // file size
    142c:	cmp	r4, #97	; 0x61
    142e:	bne.n	14c0 <menu()+0x188>
    1430:	ldr	r3, [pc, #176]	; (14e4 <menu()+0x1ac>)
    1432:	ldr	r1, [pc, #180]	; (14e8 <menu()+0x1b0>)
    1434:	ldr	r2, [r3, #0]
    1436:	ldr	r0, [pc, #148]	; (14cc <menu()+0x194>)
    1438:	bl	a198 <Print::printf(char const*, ...)>
    143c:	b.n	14c0 <menu()+0x188>
  }
  else if(ch=='!') // set 
    143e:	cmp	r0, #33	; 0x21
    1440:	bne.n	14c0 <menu()+0x188>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    1442:	bl	9140 <usb_serial_available>
  { 
    while(!Serial.available()) ;
    1446:	cmp	r0, #0
    1448:	beq.n	1442 <menu()+0x10a>
        virtual int read() { return usb_serial_getchar(); }
    144a:	bl	90bc <usb_serial_getchar>
    ch=Serial.read();
    144e:	uxtb	r0, r0
    if(ch=='d') // set date
    1450:	cmp	r0, #100	; 0x64
    1452:	bne.n	1480 <menu()+0x148>
    { int year,month,day;
      menuGet3Int(&year,&month,&day);
    1454:	add	r2, sp, #20
    1456:	add	r1, sp, #16
    1458:	add	r0, sp, #12
    145a:	bl	12ec <menuGet3Int(int*, int*, int*)>
      tmElements_t tm;
      breakTime(rtc_get(), tm);
    145e:	bl	93fc <rtc_get>
    1462:	add	r1, sp, #24
    1464:	bl	1580 <breakTime(unsigned long, tmElements_t&)>

      setRTCTime(tm.Hour, tm.Minute, tm.Second, day, month, year);
    1468:	ldr	r3, [sp, #12]
    146a:	str	r3, [sp, #4]
    146c:	ldr	r3, [sp, #16]
    146e:	str	r3, [sp, #0]
    1470:	ldrb.w	r2, [sp, #24]
    1474:	ldrb.w	r1, [sp, #25]
    1478:	ldrb.w	r0, [sp, #26]
    147c:	ldr	r3, [sp, #20]
    147e:	b.n	14b0 <menu()+0x178>
      return  0;
    } 
    else if(ch=='t') // set time
    1480:	cmp	r0, #116	; 0x74
    1482:	bne.n	14b6 <menu()+0x17e>
    { int hour,minutes,seconds;
      menuGet3Int(&hour,&minutes,&seconds);
    1484:	add	r2, sp, #20
    1486:	add	r1, sp, #16
    1488:	add	r0, sp, #12
    148a:	bl	12ec <menuGet3Int(int*, int*, int*)>

      tmElements_t tm;
      breakTime(rtc_get(), tm);
    148e:	bl	93fc <rtc_get>
    1492:	add	r1, sp, #24
    1494:	bl	1580 <breakTime(unsigned long, tmElements_t&)>
      setRTCTime(hour, minutes, seconds, tm.Day, tm.Month, tmYearToCalendar(tm.Year));
    1498:	ldrb.w	r2, [sp, #30]
    149c:	ldrb.w	r3, [sp, #28]
    14a0:	addw	r2, r2, #1970	; 0x7b2
    14a4:	str	r2, [sp, #4]
    14a6:	ldrb.w	r2, [sp, #29]
    14aa:	str	r2, [sp, #0]
    14ac:	add	r0, sp, #12
    14ae:	ldmia	r0, {r0, r1, r2}
    14b0:	bl	176c <setRTCTime(int, int, int, int, int, int)>
    14b4:	b.n	14c0 <menu()+0x188>
      return  0;
    } 
    else if(ch=='a') { menuGetInt(&t_acq); return  0;} // file size
    14b6:	cmp	r0, #97	; 0x61
    14b8:	bne.n	14c0 <menu()+0x188>
    14ba:	ldr	r0, [pc, #40]	; (14e4 <menu()+0x1ac>)
    14bc:	bl	12b0 <menuGetInt(int*)>
    14c0:	movs	r0, #0
  }
  return 0;
}
    14c2:	add	sp, #32
    14c4:	pop	{r4, pc}
    14c6:	nop
    14c8:	.word	0x00012d6c
    14cc:	.word	0x1fff136c
    14d0:	.word	0x000127d0
    14d4:	.word	0x000127d6
    14d8:	.word	0x000127db
    14dc:	.word	0x0001278e
    14e0:	.word	0x000127a7
    14e4:	.word	0x1fff0f38
    14e8:	.word	0x000127c1

000014ec <getTeensySerial()>:

#else
  uint32_t getTeensySerial(void) 
  {
    uint32_t num = 0;
    __disable_irq();
    14ec:	cpsid	i
      FTFL_FSTAT = FTFL_FSTAT_CCIF;
      while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
      num = *(uint32_t *)&FTFL_FCCOB7;
    #elif defined(HAS_KINETIS_FLASH_FTFE)
      kinetis_hsrun_disable();
      FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    14ee:	ldr	r3, [pc, #32]	; (1510 <getTeensySerial()+0x24>)
      *(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    14f0:	ldr	r1, [pc, #32]	; (1514 <getTeensySerial()+0x28>)
      FTFL_FSTAT = FTFL_FSTAT_CCIF;
      while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
      num = *(uint32_t *)&FTFL_FCCOB7;
    #elif defined(HAS_KINETIS_FLASH_FTFE)
      kinetis_hsrun_disable();
      FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    14f2:	movs	r2, #112	; 0x70
    14f4:	strb	r2, [r3, #0]
      *(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    14f6:	ldr	r2, [pc, #32]	; (1518 <getTeensySerial()+0x2c>)
    14f8:	str	r1, [r2, #0]
      FTFL_FSTAT = FTFL_FSTAT_CCIF;
    14fa:	movs	r2, #128	; 0x80
    14fc:	strb	r2, [r3, #0]
      while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    14fe:	ldrb	r2, [r3, #0]
    1500:	lsls	r2, r2, #24
    1502:	bpl.n	14fe <getTeensySerial()+0x12>
      num = *(uint32_t *)&FTFL_FCCOBB;
    1504:	ldr	r3, [pc, #20]	; (151c <getTeensySerial()+0x30>)
    1506:	ldr	r0, [r3, #0]
      kinetis_hsrun_enable();
    #endif
    __enable_irq();
    1508:	cpsie	i
    return num & 0xFFFFFF;
  }
    150a:	bic.w	r0, r0, #4278190080	; 0xff000000
    150e:	bx	lr
    1510:	.word	0x40020000
    1514:	.word	0x41070000
    1518:	.word	0x40020004
    151c:	.word	0x4002000c

00001520 <_write>:
  int _write(int file, const void *buf, size_t len) {
    // https://forum.pjrc.com/threads/28473-Quick-Guide-Using-printf()-on-Teensy-ARM
    Print *out;
  
    // Send both stdout and stderr to stdPrint
    if (file == stdout->_file || file == stderr->_file) {
    1520:	ldr	r3, [pc, #48]	; (1554 <_write+0x34>)
    1522:	ldr	r3, [r3, #0]
#include "usb_serial.h"
Print *stdPrint = &Serial;

extern "C"
{
  int _write(int file, const void *buf, size_t len) {
    1524:	push	{r4}
    // https://forum.pjrc.com/threads/28473-Quick-Guide-Using-printf()-on-Teensy-ARM
    Print *out;
  
    // Send both stdout and stderr to stdPrint
    if (file == stdout->_file || file == stderr->_file) {
    1526:	ldr	r4, [r3, #8]
    1528:	ldrsh.w	r4, [r4, #14]
    152c:	cmp	r4, r0
    152e:	beq.n	153a <_write+0x1a>
    1530:	ldr	r3, [r3, #12]
    1532:	ldrsh.w	r3, [r3, #14]
    1536:	cmp	r0, r3
    1538:	bne.n	153e <_write+0x1e>
      out = stdPrint;
    153a:	ldr	r3, [pc, #28]	; (1558 <_write+0x38>)
    153c:	ldr	r0, [r3, #0]
    } else {
      out = (Print *)file;
    }
  
    if (out == nullptr) {
    153e:	cbz	r0, 154a <_write+0x2a>
      return len;
    }
  
    // Don't check for len == 0 for returning early, in case there's side effects
    return out->write((const uint8_t *)buf, len);
    1540:	ldr	r3, [r0, #0]
  }
    1542:	ldr.w	r4, [sp], #4
    if (out == nullptr) {
      return len;
    }
  
    // Don't check for len == 0 for returning early, in case there's side effects
    return out->write((const uint8_t *)buf, len);
    1546:	ldr	r3, [r3, #4]
    1548:	bx	r3
  }
    154a:	mov	r0, r2
    154c:	ldr.w	r4, [sp], #4
    1550:	bx	lr
    1552:	nop
    1554:	.word	0x1fff1848
    1558:	.word	0x1fff0f3c

0000155c <newHour()>:
    return 1;
}

int32_t hour_ = 0;
int16_t newHour(void)
{   uint32_t tx=rtc_get();
    155c:	push	{r3, lr}
    155e:	bl	93fc <rtc_get>
    int32_t h_ = (int32_t) tx/SECS_PER_HOUR;  // use hours since 1970 as measures
    1562:	mov.w	r3, #3600	; 0xe10
    1566:	udiv	r0, r0, r3
    if(hour_== h_) return 0;
    156a:	ldr	r3, [pc, #16]	; (157c <newHour()+0x20>)
    156c:	ldr	r2, [r3, #0]
    156e:	cmp	r0, r2
    hour_ = h_;
    1570:	itte	ne
    1572:	strne	r0, [r3, #0]
    return 1;
    1574:	movne	r0, #1

int32_t hour_ = 0;
int16_t newHour(void)
{   uint32_t tx=rtc_get();
    int32_t h_ = (int32_t) tx/SECS_PER_HOUR;  // use hours since 1970 as measures
    if(hour_== h_) return 0;
    1576:	moveq	r0, #0
    hour_ = h_;
    return 1;
}
    1578:	pop	{r3, pc}
    157a:	nop
    157c:	.word	0x1fff2230

00001580 <breakTime(unsigned long, tmElements_t&)>:
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    1580:	movs	r3, #60	; 0x3c
/* functions to convert to and from system time */
/* These are for interfacing with time services and are not normally needed in a sketch */

static  const uint8_t monthDays[]={31,28,31,30,31,30,31,31,30,31,30,31}; // API starts months from 1, this array starts from 0
 
void breakTime(uint32_t timeInput, tmElements_t &tm){
    1582:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    1586:	udiv	r4, r0, r3
    158a:	mls	r2, r3, r4, r0
    158e:	strb	r2, [r1, #0]
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    1590:	udiv	r2, r4, r3
    1594:	mls	r3, r3, r2, r4
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    1598:	movs	r4, #24
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    159a:	strb	r3, [r1, #1]
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    159c:	mov.w	r3, #3600	; 0xe10
    15a0:	udiv	r3, r0, r3
    15a4:	udiv	r2, r3, r4
    15a8:	mls	r3, r4, r2, r3
    15ac:	strb	r3, [r1, #2]
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    15ae:	movs	r2, #7
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
    15b0:	ldr	r3, [pc, #240]	; (16a4 <breakTime(unsigned long, tmElements_t&)+0x124>)
    15b2:	udiv	r0, r0, r3
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    15b6:	adds	r3, r0, #4
    15b8:	udiv	r2, r3, r2
    15bc:	rsb	r2, r2, r2, lsl #3
    15c0:	subs	r3, r3, r2
    15c2:	adds	r3, #1
    15c4:	movs	r4, #0
    15c6:	strb	r3, [r1, #3]
  
  year = 0;  
  days = 0;
    15c8:	mov	r2, r4
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    15ca:	movw	r8, #365	; 0x16d
    15ce:	mov.w	lr, #100	; 0x64
    15d2:	mov.w	ip, #400	; 0x190
    15d6:	uxtb	r6, r4
    15d8:	addw	r3, r6, #1970	; 0x7b2
    15dc:	ands.w	r7, r3, #3
    15e0:	bne.n	1600 <breakTime(unsigned long, tmElements_t&)+0x80>
    15e2:	sdiv	r5, r3, lr
    15e6:	mls	r5, lr, r5, r3
    15ea:	cbnz	r5, 1606 <breakTime(unsigned long, tmElements_t&)+0x86>
    15ec:	sdiv	r5, r3, ip
    15f0:	mls	r5, ip, r5, r3
    15f4:	cmp	r5, #0
    15f6:	ite	ne
    15f8:	movne	r5, r8
    15fa:	moveq.w	r5, #366	; 0x16e
    15fe:	b.n	160a <breakTime(unsigned long, tmElements_t&)+0x8a>
    1600:	movw	r5, #365	; 0x16d
    1604:	b.n	160a <breakTime(unsigned long, tmElements_t&)+0x8a>
    1606:	mov.w	r5, #366	; 0x16e
    160a:	add	r2, r5
    160c:	cmp	r0, r2
    160e:	add.w	r4, r4, #1
    1612:	bcs.n	15d6 <breakTime(unsigned long, tmElements_t&)+0x56>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
    1614:	strb	r6, [r1, #6]
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    1616:	cbnz	r7, 163e <breakTime(unsigned long, tmElements_t&)+0xbe>
    1618:	movs	r5, #100	; 0x64
    161a:	sdiv	r4, r3, r5
    161e:	mls	r4, r5, r4, r3
    1622:	cbnz	r4, 1644 <breakTime(unsigned long, tmElements_t&)+0xc4>
    1624:	mov.w	r5, #400	; 0x190
    1628:	sdiv	r4, r3, r5
    162c:	mls	r4, r5, r4, r3
    1630:	cmp	r4, #0
    1632:	movw	r4, #365	; 0x16d
    1636:	it	eq
    1638:	moveq.w	r4, #366	; 0x16e
    163c:	b.n	1648 <breakTime(unsigned long, tmElements_t&)+0xc8>
    163e:	movw	r4, #365	; 0x16d
    1642:	b.n	1648 <breakTime(unsigned long, tmElements_t&)+0xc8>
    1644:	mov.w	r4, #366	; 0x16e
  time  -= days; // now it is days in this year, starting at 0
    1648:	subs	r2, r2, r4
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    164a:	movs	r6, #100	; 0x64
    164c:	mov.w	r4, #400	; 0x190
        monthLength=29;
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    1650:	ldr.w	lr, [pc, #84]	; 16a8 <breakTime(unsigned long, tmElements_t&)+0x128>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
  time  -= days; // now it is days in this year, starting at 0
    1654:	subs	r0, r0, r2
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    1656:	sdiv	r2, r3, r6
    165a:	mls	r6, r6, r2, r3
    165e:	sdiv	r2, r3, r4
    1662:	mls	r3, r4, r2, r3
    1666:	movs	r2, #0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
    1668:	cmp	r2, #1
    166a:	uxtb	r5, r2
    166c:	bne.n	167c <breakTime(unsigned long, tmElements_t&)+0xfc>
      if (LEAP_YEAR(year)) {
    166e:	cbnz	r7, 1682 <breakTime(unsigned long, tmElements_t&)+0x102>
    1670:	cbnz	r6, 1686 <breakTime(unsigned long, tmElements_t&)+0x106>
        monthLength=29;
    1672:	cmp	r3, #0
    1674:	ite	ne
    1676:	movne	r4, #28
    1678:	moveq	r4, #29
    167a:	b.n	1688 <breakTime(unsigned long, tmElements_t&)+0x108>
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    167c:	ldrb.w	r4, [r2, lr]
    1680:	b.n	1688 <breakTime(unsigned long, tmElements_t&)+0x108>
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
        monthLength=29;
      } else {
        monthLength=28;
    1682:	movs	r4, #28
    1684:	b.n	1688 <breakTime(unsigned long, tmElements_t&)+0x108>
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
        monthLength=29;
    1686:	movs	r4, #29
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    1688:	cmp	r4, r0
    168a:	bhi.n	1698 <breakTime(unsigned long, tmElements_t&)+0x118>
    168c:	adds	r2, #1
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    168e:	cmp	r2, #12
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
      time -= monthLength;
    1690:	sub.w	r0, r0, r4
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    1694:	bne.n	1668 <breakTime(unsigned long, tmElements_t&)+0xe8>
    1696:	mov	r5, r2
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    1698:	adds	r5, #1
  tm.Day = time + 1;     // day of month
    169a:	adds	r0, #1
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    169c:	strb	r5, [r1, #5]
  tm.Day = time + 1;     // day of month
    169e:	strb	r0, [r1, #4]
    16a0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    16a4:	.word	0x00015180
    16a8:	.word	0x000127e9

000016ac <makeTime(tmElements_t const&)>:
}

uint32_t makeTime(const tmElements_t &tm){   
    16ac:	push	{r4, r5, r6, r7, lr}
  
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
    16ae:	ldr	r3, [pc, #176]	; (1760 <makeTime(tmElements_t const&)+0xb4>)
    16b0:	ldrb	r2, [r0, #6]
    16b2:	movw	r1, #1970	; 0x7b2
    16b6:	muls	r3, r2
  for (i = 0; i < tm.Year; i++) {
    if (LEAP_YEAR(i)) {
    16b8:	movs	r5, #100	; 0x64
    16ba:	mov.w	r6, #400	; 0x190
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
  for (i = 0; i < tm.Year; i++) {
    16be:	subw	r4, r1, #1970	; 0x7b2
    16c2:	cmp	r2, r4
    16c4:	ble.n	16ea <makeTime(tmElements_t const&)+0x3e>
    if (LEAP_YEAR(i)) {
    16c6:	lsls	r4, r1, #30
    16c8:	bne.n	16e6 <makeTime(tmElements_t const&)+0x3a>
    16ca:	sdiv	r4, r1, r5
    16ce:	mls	r4, r5, r4, r1
    16d2:	cbnz	r4, 16de <makeTime(tmElements_t const&)+0x32>
    16d4:	sdiv	r4, r1, r6
    16d8:	mls	r4, r6, r4, r1
    16dc:	cbnz	r4, 16e6 <makeTime(tmElements_t const&)+0x3a>
      seconds += SECS_PER_DAY;   // add extra days for leap years
    16de:	add.w	r3, r3, #86016	; 0x15000
    16e2:	add.w	r3, r3, #384	; 0x180
    16e6:	adds	r1, #1
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
  for (i = 0; i < tm.Year; i++) {
    16e8:	b.n	16be <makeTime(tmElements_t const&)+0x12>
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    16ea:	addw	r2, r2, #1970	; 0x7b2
    16ee:	movs	r4, #100	; 0x64
    16f0:	mov.w	r5, #400	; 0x190
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    16f4:	ldrb	r6, [r0, #5]
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
      seconds += SECS_PER_DAY * 29;
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    16f6:	ldr	r7, [pc, #108]	; (1764 <makeTime(tmElements_t const&)+0xb8>)
    16f8:	ldr.w	lr, [pc, #108]	; 1768 <makeTime(tmElements_t const&)+0xbc>
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    16fc:	sdiv	r1, r2, r4
    1700:	mls	r4, r4, r1, r2
    1704:	sdiv	r1, r2, r5
    1708:	mls	r5, r5, r1, r2
    170c:	movs	r1, #1
    170e:	and.w	r2, r2, #3
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    1712:	cmp	r6, r1
    1714:	ble.n	173a <makeTime(tmElements_t const&)+0x8e>
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    1716:	cmp	r1, #2
    1718:	bne.n	172a <makeTime(tmElements_t const&)+0x7e>
    171a:	cbnz	r2, 172a <makeTime(tmElements_t const&)+0x7e>
    171c:	cbnz	r4, 1720 <makeTime(tmElements_t const&)+0x74>
    171e:	cbnz	r5, 172a <makeTime(tmElements_t const&)+0x7e>
      seconds += SECS_PER_DAY * 29;
    1720:	add.w	r3, r3, #2490368	; 0x260000
    1724:	add.w	r3, r3, #15232	; 0x3b80
    1728:	b.n	1736 <makeTime(tmElements_t const&)+0x8a>
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    172a:	add.w	ip, r7, r1
    172e:	ldrb.w	ip, [ip, #-1]
    1732:	mla	r3, lr, ip, r3
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    1736:	adds	r1, #1
    1738:	b.n	1712 <makeTime(tmElements_t const&)+0x66>
  }
  seconds+= (tm.Day-1) * SECS_PER_DAY;
  seconds+= tm.Hour * SECS_PER_HOUR;
  seconds+= tm.Minute * SECS_PER_MIN;
  seconds+= tm.Second;
  return seconds; 
    173a:	ldrb	r2, [r0, #1]
    173c:	ldrb	r1, [r0, #2]
    173e:	rsb	r2, r2, r2, lsl #4
    1742:	mov.w	r4, #3600	; 0xe10
    1746:	lsls	r2, r2, #2
    1748:	mla	r2, r4, r1, r2
    174c:	ldrb	r1, [r0, #0]
    174e:	add	r2, r1
    1750:	ldrb	r1, [r0, #4]
    1752:	ldr	r0, [pc, #20]	; (1768 <makeTime(tmElements_t const&)+0xbc>)
    1754:	subs	r1, #1
    1756:	mla	r0, r0, r1, r2
}
    175a:	add	r0, r3
    175c:	pop	{r4, r5, r6, r7, pc}
    175e:	nop
    1760:	.word	0x01e13380
    1764:	.word	0x000127e9
    1768:	.word	0x00015180

0000176c <setRTCTime(int, int, int, int, int, int)>:

extern "C" void rtc_set(uint32_t tt);

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
    176c:	push	{r0, r1, r4, lr}
    176e:	ldr	r4, [sp, #20]
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
    1770:	strb.w	r0, [sp, #2]
extern "C" void rtc_set(uint32_t tt);

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
 // year can be given as full four digit year or two digts (2010 or 10 for 2010);  
 // it is converted to years since 1970
  if( yr > 99)
    1774:	cmp	r4, #99	; 0x63
  tm.Year = yr;
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;
    1776:	add	r0, sp, #8

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
 // year can be given as full four digit year or two digts (2010 or 10 for 2010);  
 // it is converted to years since 1970
  if( yr > 99)
      yr = yr - 1970;
    1778:	ite	gt
    177a:	subwgt	r4, r4, #1970	; 0x7b2
  else
      yr += 30;  
    177e:	addle	r4, #30
  
  tmElements_t tm;
  tm.Year = yr;
    1780:	strb.w	r4, [sp, #6]
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;
    1784:	strb.w	r2, [r0, #-8]!
  else
      yr += 30;  
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
    1788:	ldr	r4, [sp, #16]
  tm.Day = dy;
    178a:	strb.w	r3, [sp, #4]
  tm.Hour = hr;
  tm.Minute = min;
    178e:	strb.w	r1, [sp, #1]
  else
      yr += 30;  
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
    1792:	strb.w	r4, [sp, #5]
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;

  uint32_t tt = makeTime(tm);
    1796:	bl	16ac <makeTime(tmElements_t const&)>
  rtc_set(tt); // for RTC
    179a:	bl	9408 <rtc_set>
}
    179e:	add	sp, #8
    17a0:	pop	{r4, pc}

000017a2 <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)>:
   * \param[out] dst Pointer to the location that will receive the data.
   * \param[in] callback Function to be called with each sector's data
   * \param[in] context Pointer to be passed to the callback function
   * \return true for success or false for failure.
   */
  virtual bool readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
    17a2:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    17a6:	ldr	r5, [sp, #32]
    17a8:	mov	r7, r0
    17aa:	mov	r6, r2
    17ac:	add.w	r9, r3, r1
    17b0:	mov	r4, r1
   void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
    17b2:	cmp	r4, r9
    17b4:	beq.n	17d4 <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x32>
       if (!readSector(sector + i, dst)) return false;
    17b6:	ldr	r3, [r7, #0]
    17b8:	mov	r2, r6
    17ba:	ldr	r3, [r3, #12]
    17bc:	mov	r1, r4
    17be:	mov	r0, r7
    17c0:	blx	r3
    17c2:	add.w	r8, r4, #1
    17c6:	cbz	r0, 17d6 <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x34>
       callback(sector + i, dst, context);
    17c8:	mov	r0, r4
    17ca:	ldr	r2, [sp, #36]	; 0x24
    17cc:	mov	r1, r6
    17ce:	blx	r5
   * \param[in] context Pointer to be passed to the callback function
   * \return true for success or false for failure.
   */
  virtual bool readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
   void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
    17d0:	mov	r4, r8
    17d2:	b.n	17b2 <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x10>
       if (!readSector(sector + i, dst)) return false;
       callback(sector + i, dst, context);
     }
     return true;
    17d4:	movs	r0, #1
  }
    17d6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000017da <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)>:
   * \param[in] ns Number of sectors to be written.
   * \param[in] callback Function to be called for each sector's data
   * \param[in] context Context to pass to callback function
   * \return true for success or false for failure.
   */
  virtual bool writeSectorsCallback(uint32_t sector, size_t ns,
    17da:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    17de:	mov	r5, r0
    17e0:	mov	r7, r3
    17e2:	add.w	r8, r2, r1
    17e6:	mov	r4, r1
   const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
    17e8:	cmp	r4, r8
    17ea:	beq.n	1808 <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x2e>
       if (!writeSector(sector + i, callback(sector + i, context))) return false;
    17ec:	ldr	r3, [r5, #0]
    17ee:	ldr	r1, [sp, #24]
    17f0:	ldr	r6, [r3, #32]
    17f2:	mov	r0, r4
    17f4:	blx	r7
    17f6:	mov	r1, r4
    17f8:	mov	r2, r0
    17fa:	mov	r0, r5
    17fc:	blx	r6
    17fe:	adds	r4, #1
    1800:	cmp	r0, #0
    1802:	bne.n	17e8 <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0xe>
    1804:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     }
    return true;
    1808:	movs	r0, #1
  }
    180a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000180e <SdCardInterface::status()>:
   * \return The number of 512 byte data sectors in the card
   *         or zero if an error occurs.
   */
  virtual uint32_t sectorCount() = 0;
  /** \return card status. */
  virtual uint32_t status() {return 0XFFFFFFFF;}
    180e:	mov.w	r0, #4294967295
    1812:	bx	lr

00001814 <MySpiClass::activate()>:
    public:
        // Initialize the SPI bus.
        void begin(SdSpiConfig config) {  (void) config; SPI.begin(); }

        // Activate SPI hardware with correct speed and mode.
        void activate() { if(doTransactions) SPI.beginTransaction(m_spiSettings); }
    1814:	ldrb	r3, [r0, #8]
    1816:	push	{r4, r5, lr}
    1818:	cmp	r3, #0
    181a:	beq.n	1890 <MySpiClass::activate()+0x7c>

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    181c:	ldr	r3, [pc, #116]	; (1894 <MySpiClass::activate()+0x80>)
    181e:	ldr	r2, [r0, #4]
    1820:	ldrb	r1, [r3, #11]
    1822:	cmp	r1, #0
    1824:	beq.n	1878 <MySpiClass::activate()+0x64>
			__disable_irq();
    1826:	cpsid	i
			if (interruptMasksUsed & 0x01) {
    1828:	ldrb	r1, [r3, #11]
    182a:	lsls	r1, r1, #31
    182c:	bpl.n	183a <MySpiClass::activate()+0x26>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    182e:	ldr	r0, [pc, #104]	; (1898 <MySpiClass::activate()+0x84>)
    1830:	ldr	r1, [r3, #12]
    1832:	ldr	r4, [r0, #0]
    1834:	ands	r1, r4
    1836:	str	r1, [r3, #28]
				NVIC_ICER0 = interruptSave[0];
    1838:	str	r1, [r0, #0]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    183a:	ldrb	r1, [r3, #11]
    183c:	ldr	r4, [pc, #84]	; (1894 <MySpiClass::activate()+0x80>)
    183e:	lsls	r5, r1, #30
    1840:	bpl.n	184e <MySpiClass::activate()+0x3a>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    1842:	ldr	r0, [pc, #88]	; (189c <MySpiClass::activate()+0x88>)
    1844:	ldr	r1, [r4, #16]
    1846:	ldr	r5, [r0, #0]
    1848:	ands	r1, r5
    184a:	str	r1, [r4, #32]
				NVIC_ICER1 = interruptSave[1];
    184c:	str	r1, [r0, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    184e:	ldrb	r1, [r3, #11]
    1850:	ldr	r4, [pc, #64]	; (1894 <MySpiClass::activate()+0x80>)
    1852:	lsls	r0, r1, #29
    1854:	bpl.n	1862 <MySpiClass::activate()+0x4e>
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    1856:	ldr	r0, [pc, #72]	; (18a0 <MySpiClass::activate()+0x8c>)
    1858:	ldr	r1, [r4, #20]
    185a:	ldr	r5, [r0, #0]
    185c:	ands	r1, r5
    185e:	str	r1, [r4, #36]	; 0x24
				NVIC_ICER2 = interruptSave[2];
    1860:	str	r1, [r0, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    1862:	ldrb	r1, [r3, #11]
    1864:	ldr	r4, [pc, #44]	; (1894 <MySpiClass::activate()+0x80>)
    1866:	lsls	r1, r1, #28
    1868:	bpl.n	1876 <MySpiClass::activate()+0x62>
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
    186a:	ldr	r0, [pc, #56]	; (18a4 <MySpiClass::activate()+0x90>)
    186c:	ldr	r1, [r4, #24]
    186e:	ldr	r5, [r0, #0]
    1870:	ands	r1, r5
    1872:	str	r1, [r4, #40]	; 0x28
				NVIC_ICER3 = interruptSave[3];
    1874:	str	r1, [r0, #0]
			}
			#endif
			__enable_irq();
    1876:	cpsie	i
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    1878:	ldr	r3, [r3, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
    187a:	ldr	r1, [r3, #12]
    187c:	cmp	r1, r2
    187e:	beq.n	1890 <MySpiClass::activate()+0x7c>
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
    1880:	ldr	r1, [pc, #36]	; (18a8 <MySpiClass::activate()+0x94>)
    1882:	str	r1, [r3, #0]
			port().CTAR0 = settings.ctar;
    1884:	str	r2, [r3, #12]
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
    1886:	orr.w	r2, r2, #1073741824	; 0x40000000
    188a:	str	r2, [r3, #16]
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    188c:	ldr	r2, [pc, #28]	; (18ac <MySpiClass::activate()+0x98>)
    188e:	str	r2, [r3, #0]
    1890:	pop	{r4, r5, pc}
    1892:	nop
    1894:	.word	0x1fff131c
    1898:	.word	0xe000e180
    189c:	.word	0xe000e184
    18a0:	.word	0xe000e188
    18a4:	.word	0xe000e18c
    18a8:	.word	0x003f4001
    18ac:	.word	0x803f0000

000018b0 <MySpiClass::send(unsigned char)>:

        // Receive a byte.
        uint8_t receive() { return SPI.transfer(0XFF); }

        // Send a byte.
        void send(uint8_t data) { SPI.transfer(data); }
    18b0:	ldr	r3, [pc, #20]	; (18c8 <MySpiClass::send(unsigned char)+0x18>)
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    18b2:	ldr	r3, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    18b4:	mov.w	r2, #2147483648	; 0x80000000
    18b8:	str	r2, [r3, #44]	; 0x2c
		port().PUSHR = data;
    18ba:	str	r1, [r3, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    18bc:	ldr	r2, [r3, #44]	; 0x2c
    18be:	cmp	r2, #0
    18c0:	bge.n	18bc <MySpiClass::send(unsigned char)+0xc>
		return port().POPR;
    18c2:	ldr	r3, [r3, #56]	; 0x38
    18c4:	bx	lr
    18c6:	nop
    18c8:	.word	0x1fff131c

000018cc <__tcf_0>:
    const char *sd_str[]={"sd1"};
    const int cs[] = {10 };

    const int nsd = sizeof(cs)/sizeof(int);

    SDClass sdx[nsd];
    18cc:	bx	lr

000018ce <dateTime(unsigned short*, unsigned short*, unsigned char*)>:
    uint32_t diskSpace[nsd];
    uint32_t clusterSize[nsd];

// Call back for file timestamps.  Only called for file create and sync(). needed by SDFat-beta
void dateTime(uint16_t* date, uint16_t* time, uint8_t* ms10) 
{       
    18ce:	push	{r0, r1, r4, r5, r6, lr}
    18d0:	mov	r5, r2
    18d2:	mov	r4, r1
    18d4:	mov	r6, r0
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    18d6:	bl	93fc <rtc_get>
    18da:	mov	r1, sp
    18dc:	bl	1580 <breakTime(unsigned long, tmElements_t&)>
 * \param[in] day [1,31]
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
    18e0:	ldrb.w	r3, [sp, #6]

    *date = FS_DATE(tmYearToCalendar(tm.Year),tm.Month, tm.Day);
    18e4:	ldrb.w	r2, [sp, #5]
    18e8:	ldrb.w	r1, [sp, #4]
    18ec:	subs	r3, #10
    18ee:	uxth	r3, r3
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    18f0:	cmp	r3, #127	; 0x7f
    18f2:	bhi.n	1908 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3a>
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
    18f4:	cmp	r2, #12
    18f6:	bhi.n	1908 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3a>
    18f8:	cmp	r1, #31
    18fa:	bhi.n	1908 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3a>
         year << 9 | month << 5 | day;
    18fc:	orr.w	r1, r1, r2, lsl #5
    1900:	orr.w	r3, r1, r3, lsl #9
    1904:	uxth	r3, r3
    1906:	b.n	190a <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3c>
    1908:	movs	r3, #0
    190a:	strh	r3, [r6, #0]
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    190c:	ldrb.w	r3, [sp, #2]
    1910:	ldrb.w	r1, [sp, #1]
    1914:	ldrb.w	r2, [sp]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    1918:	cmp	r3, #23
    191a:	bhi.n	1932 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
 * \param[in] second [0,59]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
    191c:	cmp	r1, #59	; 0x3b
    191e:	bhi.n	1932 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
    1920:	cmp	r2, #59	; 0x3b
    1922:	bhi.n	1932 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
         hour << 11 | minute << 5 | second >> 1;
    1924:	lsls	r1, r1, #5
    1926:	orr.w	r3, r1, r3, lsl #11
    192a:	orr.w	r3, r3, r2, lsr #1
    192e:	uxth	r3, r3
    1930:	b.n	1934 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x66>
    1932:	movs	r3, #0
    *ms10 = tm.Second & 1 ? 100 : 0;
    1934:	ands.w	r2, r2, #1
    1938:	it	ne
    193a:	movne	r2, #100	; 0x64
{       
    tmElements_t tm;
    breakTime(rtc_get(), tm);

    *date = FS_DATE(tmYearToCalendar(tm.Year),tm.Month, tm.Day);
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    193c:	strh	r3, [r4, #0]
    *ms10 = tm.Second & 1 ? 100 : 0;
    193e:	strb	r2, [r5, #0]
}
    1940:	add	sp, #8
    1942:	pop	{r4, r5, r6, pc}

00001944 <MySpiClass::send(unsigned char const*, unsigned int)>:
        { memset(buf, 0XFF, count); SPI.transfer(buf, count); return 0; }

        // Send multiple bytes.
        // Replace this function if your board has multiple byte send.
        void send(const uint8_t* buf, size_t count) 
        {  SPI.transfer((void *)buf, (void *) dummy_buffer, count); }
    1944:	mov	r3, r2
    1946:	ldr	r0, [pc, #8]	; (1950 <MySpiClass::send(unsigned char const*, unsigned int)+0xc>)
    1948:	ldr	r2, [pc, #8]	; (1954 <MySpiClass::send(unsigned char const*, unsigned int)+0x10>)
    194a:	b.w	2dec <SPIClass::transfer(void const*, void*, unsigned int)>
    194e:	nop
    1950:	.word	0x1fff131c
    1954:	.word	0x2001a9d0

00001958 <MySpiClass::receive(unsigned char*, unsigned int)>:
        // Send a byte.
        void send(uint8_t data) { SPI.transfer(data); }

        // Receive multiple bytes.  
        // Replace this function if your board has multiple byte receive.
        uint8_t receive(uint8_t* buf, size_t count) 
    1958:	push	{r3, r4, r5, lr}
    195a:	mov	r4, r1
    195c:	mov	r5, r2
        { memset(buf, 0XFF, count); SPI.transfer(buf, count); return 0; }
    195e:	movs	r1, #255	; 0xff
    1960:	mov	r0, r4
    1962:	bl	9078 <memset>
		port().PUSHR = data | SPI_PUSHR_CTAS(1);
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
	}

	void inline transfer(void *buf, size_t count) {transfer(buf, buf, count);}
    1966:	mov	r3, r5
    1968:	mov	r2, r4
    196a:	mov	r1, r4
    196c:	ldr	r0, [pc, #8]	; (1978 <MySpiClass::receive(unsigned char*, unsigned int)+0x20>)
    196e:	bl	2dec <SPIClass::transfer(void const*, void*, unsigned int)>
    1972:	movs	r0, #0
    1974:	pop	{r3, r4, r5, pc}
    1976:	nop
    1978:	.word	0x1fff131c

0000197c <MySpiClass::begin(SdSpiConfig)>:
     * 
     */

    public:
        // Initialize the SPI bus.
        void begin(SdSpiConfig config) {  (void) config; SPI.begin(); }
    197c:	sub	sp, #16
    197e:	add	r0, sp, #16
    1980:	stmdb	r0, {r1, r2, r3}
    1984:	ldr	r0, [pc, #4]	; (198c <MySpiClass::begin(SdSpiConfig)+0x10>)
    1986:	add	sp, #16
    1988:	b.w	2ba0 <SPIClass::begin()>
    198c:	.word	0x1fff131c

00001990 <File::dec_refcount() [clone .isra.23]>:
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	using Print::write;
private:
	void dec_refcount() {
    1990:	push	{r4, lr}
    1992:	mov	r4, r0
		if (--(f->refcount) == 0) {
    1994:	ldr	r0, [r0, #0]
    1996:	ldr	r3, [r0, #4]
    1998:	subs	r3, #1
    199a:	str	r3, [r0, #4]
    199c:	cbnz	r3, 19ae <File::dec_refcount() [clone .isra.23]+0x1e>
			f->close();
    199e:	ldr	r3, [r0, #0]
    19a0:	ldr	r3, [r3, #44]	; 0x2c
    19a2:	blx	r3
			delete f;
    19a4:	ldr	r0, [r4, #0]
    19a6:	cbz	r0, 19ae <File::dec_refcount() [clone .isra.23]+0x1e>
    19a8:	ldr	r3, [r0, #0]
    19aa:	ldr	r3, [r3, #4]
    19ac:	blx	r3
		}
		f = nullptr;
    19ae:	movs	r3, #0
    19b0:	str	r3, [r4, #0]
    19b2:	pop	{r4, pc}

000019b4 <MySpiClass::deactivate()>:

        // Activate SPI hardware with correct speed and mode.
        void activate() { if(doTransactions) SPI.beginTransaction(m_spiSettings); }
        // Deactivate SPI hardware.
        void deactivate() { if(doTransactions) SPI.endTransaction(); }
    19b4:	ldrb	r3, [r0, #8]
    19b6:	cbz	r3, 19f2 <MySpiClass::deactivate()+0x3e>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    19b8:	ldr	r3, [pc, #56]	; (19f4 <MySpiClass::deactivate()+0x40>)
    19ba:	ldrb	r2, [r3, #11]
    19bc:	cbz	r2, 19f2 <MySpiClass::deactivate()+0x3e>
			if (interruptMasksUsed & 0x01) {
    19be:	lsls	r0, r2, #31
				NVIC_ISER0 = interruptSave[0];
    19c0:	ittt	mi
    19c2:	ldrmi	r2, [pc, #52]	; (19f8 <MySpiClass::deactivate()+0x44>)
    19c4:	ldrmi	r1, [r3, #28]
    19c6:	strmi	r1, [r2, #0]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    19c8:	ldrb	r2, [r3, #11]
    19ca:	lsls	r1, r2, #30
				NVIC_ISER1 = interruptSave[1];
    19cc:	itttt	mi
    19ce:	ldrmi	r2, [pc, #36]	; (19f4 <MySpiClass::deactivate()+0x40>)
    19d0:	ldrmi	r1, [r2, #32]
    19d2:	ldrmi	r2, [pc, #40]	; (19fc <MySpiClass::deactivate()+0x48>)
    19d4:	strmi	r1, [r2, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    19d6:	ldrb	r2, [r3, #11]
    19d8:	lsls	r2, r2, #29
				NVIC_ISER2 = interruptSave[2];
    19da:	itttt	mi
    19dc:	ldrmi	r2, [pc, #20]	; (19f4 <MySpiClass::deactivate()+0x40>)
    19de:	ldrmi	r1, [r2, #36]	; 0x24
    19e0:	ldrmi	r2, [pc, #28]	; (1a00 <MySpiClass::deactivate()+0x4c>)
    19e2:	strmi	r1, [r2, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    19e4:	ldrb	r3, [r3, #11]
    19e6:	lsls	r3, r3, #28
				NVIC_ISER3 = interruptSave[3];
    19e8:	itttt	mi
    19ea:	ldrmi	r3, [pc, #8]	; (19f4 <MySpiClass::deactivate()+0x40>)
    19ec:	ldrmi	r2, [r3, #40]	; 0x28
    19ee:	ldrmi	r3, [pc, #20]	; (1a04 <MySpiClass::deactivate()+0x50>)
    19f0:	strmi	r2, [r3, #0]
    19f2:	bx	lr
    19f4:	.word	0x1fff131c
    19f8:	.word	0xe000e100
    19fc:	.word	0xe000e104
    1a00:	.word	0xe000e108
    1a04:	.word	0xe000e10c

00001a08 <MySpiClass::receive()>:

        // Receive a byte.
        uint8_t receive() { return SPI.transfer(0XFF); }
    1a08:	ldr	r3, [pc, #24]	; (1a24 <MySpiClass::receive()+0x1c>)
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    1a0a:	ldr	r3, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    1a0c:	mov.w	r2, #2147483648	; 0x80000000
    1a10:	str	r2, [r3, #44]	; 0x2c
		port().PUSHR = data;
    1a12:	movs	r2, #255	; 0xff
    1a14:	str	r2, [r3, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    1a16:	ldr	r2, [r3, #44]	; 0x2c
    1a18:	cmp	r2, #0
    1a1a:	bge.n	1a16 <MySpiClass::receive()+0xe>
		return port().POPR;
    1a1c:	ldr	r0, [r3, #56]	; 0x38
    1a1e:	uxtb	r0, r0
    1a20:	bx	lr
    1a22:	nop
    1a24:	.word	0x1fff131c

00001a28 <Print::print(char const*)>:
    1a28:	push	{r3, lr}
    1a2a:	bl	760 <Print::write(char const*)>
    1a2e:	pop	{r3, pc}

00001a30 <Print::println(unsigned long)>:

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
    1a30:	push	{r3, r4, r5, lr}
    1a32:	mov	r5, r0
    1a34:	bl	77c <Print::print(unsigned long)>
    1a38:	mov	r4, r0
    1a3a:	mov	r0, r5
    1a3c:	bl	a178 <Print::println()>
    1a40:	add	r0, r4
    1a42:	pop	{r3, r4, r5, pc}

00001a44 <FsVolume::bytesPerCluster() const>:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  uint32_t __attribute__((error("use sectorsPerCluster()"))) blocksPerCluster();
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
    1a44:	ldr.w	r3, [r0, #1152]	; 0x480
           m_xVol ? m_xVol->bytesPerCluster() : 0;
    1a48:	cbz	r3, 1a58 <FsVolume::bytesPerCluster() const+0x14>
    1a4a:	ldrb	r0, [r3, #6]
    1a4c:	mov.w	r3, #512	; 0x200
    1a50:	lsl.w	r0, r3, r0
    1a54:	uxth	r0, r0
    1a56:	bx	lr
    1a58:	ldr.w	r0, [r0, #1156]	; 0x484
    1a5c:	cbz	r0, 1a62 <FsVolume::bytesPerCluster() const+0x1e>
    1a5e:	ldr.w	r0, [r0, #1084]	; 0x43c
  }
    1a62:	bx	lr

00001a64 <FsVolume::clusterCount() const>:
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    1a64:	ldr.w	r3, [r0, #1152]	; 0x480
           m_xVol ? m_xVol->clusterCount() : 0;
    1a68:	cbz	r3, 1a70 <FsVolume::clusterCount() const+0xc>
  uint8_t* cacheClear() {
    return m_cache.clear();
  }
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_lastCluster - 1;
    1a6a:	ldr	r0, [r3, #28]
    1a6c:	subs	r0, #1
    1a6e:	bx	lr
    1a70:	ldr.w	r0, [r0, #1156]	; 0x484
    1a74:	cbz	r0, 1a7a <FsVolume::clusterCount() const+0x16>
    1a76:	ldr.w	r0, [r0, #1072]	; 0x430
  }
    1a7a:	bx	lr

00001a7c <FsVolume::freeClusterCount() const>:
  uint8_t fatType() const {
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    1a7c:	mov	r3, r0
    return m_fVol ? m_fVol->freeClusterCount() :
    1a7e:	ldr.w	r0, [r0, #1152]	; 0x480
           m_xVol ? m_xVol->freeClusterCount() : 0;
    1a82:	cbz	r0, 1a88 <FsVolume::freeClusterCount() const+0xc>
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
    1a84:	b.w	6bc0 <FatPartition::freeClusterCount()>
           m_xVol ? m_xVol->freeClusterCount() : 0;
    1a88:	ldr.w	r0, [r3, #1156]	; 0x484
    1a8c:	cbz	r0, 1a92 <FsVolume::freeClusterCount() const+0x16>
    1a8e:	b.w	4ae4 <ExFatPartition::freeClusterCount()>
  }
    1a92:	bx	lr

00001a94 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)>:
	}
	SPISettings() {
		init_AlwaysInline(4000000, MSBFIRST, SPI_MODE0);
	}
private:
	void init_MightInline(uint32_t clock, uint8_t bitOrder, uint8_t dataMode) {
    1a94:	push	{r4, r5, r6, r7, lr}
		init_AlwaysInline(clock, bitOrder, dataMode);
	}
	void init_AlwaysInline(uint32_t clock, uint8_t bitOrder, uint8_t dataMode)
	  __attribute__((__always_inline__)) {
		uint32_t t, c = SPI_CTAR_FMSZ(7);
		if (bitOrder == LSBFIRST) c |= SPI_CTAR_LSBFE;
    1a96:	cmp	r2, #0
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    1a98:	ldr	r6, [pc, #76]	; (1ae8 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x54>)
    1a9a:	ldr	r7, [pc, #80]	; (1aec <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x58>)
		init_AlwaysInline(clock, bitOrder, dataMode);
	}
	void init_AlwaysInline(uint32_t clock, uint8_t bitOrder, uint8_t dataMode)
	  __attribute__((__always_inline__)) {
		uint32_t t, c = SPI_CTAR_FMSZ(7);
		if (bitOrder == LSBFIRST) c |= SPI_CTAR_LSBFE;
    1a9c:	ite	ne
    1a9e:	movne.w	r4, #939524096	; 0x38000000
    1aa2:	moveq.w	r4, #956301312	; 0x39000000
				t = SPI_CTAR_PBR(2) | SPI_CTAR_BR(7) | SPI_CTAR_CSSCK(6);
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
    1aa6:	movs	r2, #0
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    1aa8:	ldrh.w	r5, [r6, r2, lsl #1]
    1aac:	sdiv	r5, r7, r5
    1ab0:	cmp	r1, r5
    1ab2:	bcc.n	1abe <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x2a>
			}
		}
		if (dataMode & 0x08) {
    1ab4:	lsls	r1, r3, #28
    1ab6:	bpl.n	1ac8 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x34>
			c |= SPI_CTAR_CPOL;
    1ab8:	orr.w	r4, r4, #67108864	; 0x4000000
    1abc:	b.n	1ac8 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x34>
				t = SPI_CTAR_PBR(2) | SPI_CTAR_BR(7) | SPI_CTAR_CSSCK(6);
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
    1abe:	adds	r5, r2, #1
    1ac0:	cmp	r5, #23
    1ac2:	beq.n	1ab4 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x20>
    1ac4:	mov	r2, r5
    1ac6:	b.n	1aa8 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x14>
				t = ctar_clock_table[i];
    1ac8:	ldr	r1, [pc, #36]	; (1af0 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x5c>)
			}
		}
		if (dataMode & 0x08) {
			c |= SPI_CTAR_CPOL;
		}
		if (dataMode & 0x04) {
    1aca:	lsls	r3, r3, #29
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
				t = ctar_clock_table[i];
    1acc:	ldr.w	r2, [r1, r2, lsl #2]
			}
		}
		if (dataMode & 0x08) {
			c |= SPI_CTAR_CPOL;
		}
		if (dataMode & 0x04) {
    1ad0:	bpl.n	1ae2 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x4e>
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
    1ad2:	bic.w	r3, r2, #61440	; 0xf000
    1ad6:	lsrs	r2, r2, #4
    1ad8:	and.w	r2, r2, #3840	; 0xf00
		}
		if (dataMode & 0x08) {
			c |= SPI_CTAR_CPOL;
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
    1adc:	orr.w	r4, r4, #33554432	; 0x2000000
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
    1ae0:	orrs	r2, r3
		}
		ctar = c | t;
    1ae2:	orrs	r2, r4
    1ae4:	str	r2, [r0, #0]
    1ae6:	pop	{r4, r5, r6, r7, pc}
    1ae8:	.word	0x0001296c
    1aec:	.word	0x02dc6c00
    1af0:	.word	0x00012a30

00001af4 <SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)>:
#define SPI_HAS_NOTUSINGINTERRUPT 1
#define SPI_ATOMIC_VERSION 1

class SPISettings {
public:
	SPISettings(uint32_t clock, uint8_t bitOrder, uint8_t dataMode) {
    1af4:	push	{r4, lr}
    1af6:	mov	r4, r0
		if (__builtin_constant_p(clock)) {
			init_AlwaysInline(clock, bitOrder, dataMode);
		} else {
			init_MightInline(clock, bitOrder, dataMode);
    1af8:	bl	1a94 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)>
		}
	}
    1afc:	mov	r0, r4
    1afe:	pop	{r4, pc}

00001b00 <MySpiClass::setSckSpeed(unsigned long)>:
        // Replace this function if your board has multiple byte send.
        void send(const uint8_t* buf, size_t count) 
        {  SPI.transfer((void *)buf, (void *) dummy_buffer, count); }

        // Save SPISettings for new max SCK frequency
        void setSckSpeed(uint32_t maxSck) {  m_spiSettings = SPISettings(maxSck, MSBFIRST, SPI_MODE0); }
    1b00:	push	{r0, r1, r4, lr}
    1b02:	movs	r3, #0
    1b04:	mov	r4, r0
    1b06:	movs	r2, #1
    1b08:	add	r0, sp, #4
    1b0a:	bl	1af4 <SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)>
    1b0e:	ldr	r3, [sp, #4]
    1b10:	str	r3, [r4, #4]
    1b12:	add	sp, #8
    1b14:	pop	{r4, pc}
    1b16:	Address 0x00001b16 is out of bounds.


00001b18 <getCount()>:

    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    1b18:	ldr	r2, [pc, #16]	; (1b2c <getCount()+0x14>)
    1b1a:	ldrh	r3, [r2, #0]
    1b1c:	ldrh	r0, [r2, #2]
            {  
                /**
                 * @brief get number of data blocks in storage
                 * 
                 */
                if(front_ >= rear_) return front_ - rear_; return front_+ MAXBUF -rear_; 
    1b1e:	cmp	r3, r0
    1b20:	it	cc
    1b22:	addcc	r3, #160	; 0xa0
    1b24:	subs	r0, r3, r0
    1b26:	uxth	r0, r0

    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    1b28:	bx	lr
    1b2a:	nop
    1b2c:	.word	0x2001a974

00001b30 <pushData(unsigned long*)>:
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    1b30:	push	{r3, r4, r5, lr}
            { 
                /** 
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
    1b32:	ldr	r5, [pc, #44]	; (1b60 <pushData(unsigned long*)+0x30>)
    1b34:	ldrh	r4, [r5, #0]
                if(f >= MAXBUF) f=0;
                if(f == rear_) return 0;
    1b36:	ldrh	r3, [r5, #2]
            { 
                /** 
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
    1b38:	adds	r4, #1
    1b3a:	uxth	r4, r4
                if(f >= MAXBUF) f=0;
    1b3c:	cmp	r4, #160	; 0xa0
    1b3e:	it	cs
    1b40:	movcs	r4, #0
                if(f == rear_) return 0;
    1b42:	cmp	r3, r4
    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    1b44:	mov	r1, r0
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
                if(f >= MAXBUF) f=0;
                if(f == rear_) return 0;
    1b46:	beq.n	1b5c <pushData(unsigned long*)+0x2c>

                uint32_t *ptr= data_buffer+f*NBUF_ACQ;
                memcpy(ptr,src,NBUF_ACQ*4);
    1b48:	ldr	r0, [r5, #4]
    1b4a:	mov.w	r2, #1024	; 0x400
    1b4e:	add.w	r0, r0, r4, lsl #10
    1b52:	bl	8ed0 <memcpy>
                front_ = f;
    1b56:	strh	r4, [r5, #0]
                return 1;
    1b58:	movs	r0, #1
    1b5a:	pop	{r3, r4, r5, pc}
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
                if(f >= MAXBUF) f=0;
                if(f == rear_) return 0;
    1b5c:	movs	r0, #0
    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    1b5e:	pop	{r3, r4, r5, pc}
    1b60:	.word	0x2001a974

00001b64 <pullData(unsigned long*, unsigned long)>:
    uint16_t pullData(uint32_t * dst, uint32_t ndbl) {return rawData.pull(dst,ndbl);}
    1b64:	push	{r4, r5, r6, lr}
                /** 
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
    1b66:	ldr	r6, [pc, #60]	; (1ba4 <pullData(unsigned long*, unsigned long)+0x40>)
    1b68:	ldrh	r4, [r6, #2]
                if(r == (front_/ndbl)) return 0;
    1b6a:	ldrh	r3, [r6, #0]
                /** 
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
    1b6c:	udiv	r4, r4, r1
                if(r == (front_/ndbl)) return 0;
    1b70:	udiv	r3, r3, r1
    1b74:	cmp	r4, r3

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    uint16_t pullData(uint32_t * dst, uint32_t ndbl) {return rawData.pull(dst,ndbl);}
    1b76:	mov	r5, r1
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
                if(r == (front_/ndbl)) return 0;
    1b78:	beq.n	1ba0 <pullData(unsigned long*, unsigned long)+0x3c>
    1b7a:	lsls	r2, r1, #10

                uint32_t *ptr= data_buffer + r*ndbl*NBUF_ACQ;
                memcpy(dst,ptr,ndbl*NBUF_ACQ*4);
    1b7c:	ldr	r1, [r6, #4]
    1b7e:	mla	r1, r2, r4, r1
    1b82:	bl	8ed0 <memcpy>
                if(++r >= (MAXBUF/ndbl)) r=0;
    1b86:	adds	r1, r4, #1
    1b88:	uxth	r1, r1
    1b8a:	movs	r3, #160	; 0xa0
    1b8c:	udiv	r3, r3, r5
    1b90:	cmp	r1, r3
    1b92:	it	cs
    1b94:	movcs	r1, #0
                rear_ = r*ndbl;
    1b96:	smulbb	r1, r5, r1
    1b9a:	strh	r1, [r6, #2]
                return 1;
    1b9c:	movs	r0, #1
    1b9e:	pop	{r4, r5, r6, pc}
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
                if(r == (front_/ndbl)) return 0;
    1ba0:	movs	r0, #0

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    uint16_t pullData(uint32_t * dst, uint32_t ndbl) {return rawData.pull(dst,ndbl);}
    1ba2:	pop	{r4, r5, r6, pc}
    1ba4:	.word	0x2001a974

00001ba8 <sdCsInit(unsigned char)>:
};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}

void sdCsInit(SdCsPin_t pin) { pinMode(pin, OUTPUT); digitalWriteFast(pin, HIGH);}
    1ba8:	push	{r4, lr}
    1baa:	movs	r1, #1
    1bac:	mov	r4, r0
    1bae:	bl	946c <pinMode>
			}
			#endif
		}
	} else {
		if (val) {
			*portSetRegister(pin) = digitalPinToBitMask(pin);
    1bb2:	ldr	r3, [pc, #12]	; (1bc0 <sdCsInit(unsigned char)+0x18>)
    1bb4:	ldr.w	r3, [r3, r4, lsl #3]
    1bb8:	movs	r2, #1
    1bba:	strb.w	r2, [r3, #128]	; 0x80
    1bbe:	pop	{r4, pc}
    1bc0:	.word	0x00012e4c

00001bc4 <sdCsWrite(unsigned char, bool)>:
void sdCsWrite(SdCsPin_t pin, bool level) { digitalWriteFast(pin, level); }
    1bc4:	ldr	r2, [pc, #20]	; (1bdc <sdCsWrite(unsigned char, bool)+0x18>)
    1bc6:	movs	r3, #1
    1bc8:	ldr.w	r2, [r2, r0, lsl #3]
				CORE_PIN63_PORTCLEAR = CORE_PIN63_BITMASK;
			}
			#endif
		}
	} else {
		if (val) {
    1bcc:	cbz	r1, 1bd4 <sdCsWrite(unsigned char, bool)+0x10>
			*portSetRegister(pin) = digitalPinToBitMask(pin);
    1bce:	strb.w	r3, [r2, #128]	; 0x80
    1bd2:	bx	lr
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
    1bd4:	strb.w	r3, [r2, #256]	; 0x100
    1bd8:	bx	lr
    1bda:	nop
    1bdc:	.word	0x00012e4c

00001be0 <storage_configure()>:
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    *ms10 = tm.Second & 1 ? 100 : 0;
}

void storage_configure()
{
    1be0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    #if defined SD_SCK
      SPI.setMOSI(SD_MOSI);
    1be4:	movs	r1, #7
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    *ms10 = tm.Second & 1 ? 100 : 0;
}

void storage_configure()
{
    1be6:	sub	sp, #56	; 0x38
    #if defined SD_SCK
      SPI.setMOSI(SD_MOSI);
    1be8:	ldr	r0, [pc, #452]	; (1db0 <storage_configure()+0x1d0>)
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    1bea:	ldr	r5, [pc, #456]	; (1db4 <storage_configure()+0x1d4>)
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    1bec:	ldr.w	r8, [pc, #508]	; 1dec <storage_configure()+0x20c>
    1bf0:	bl	2c18 <SPIClass::setMOSI(unsigned char)>
      SPI.setMISO(SD_MISO);
    1bf4:	movs	r1, #12
    1bf6:	ldr	r0, [pc, #440]	; (1db0 <storage_configure()+0x1d0>)
    1bf8:	bl	2cb4 <SPIClass::setMISO(unsigned char)>
      SPI.setSCK(SD_SCK);
    1bfc:	movs	r1, #14
    1bfe:	ldr	r0, [pc, #432]	; (1db0 <storage_configure()+0x1d0>)
    1c00:	bl	2d48 <SPIClass::setSCK(unsigned char)>
    #endif

    // Set Time callback
    FsDateTime::callback = dateTime;
    1c04:	ldr	r3, [pc, #432]	; (1db8 <storage_configure()+0x1d8>)
    1c06:	ldr	r2, [pc, #436]	; (1dbc <storage_configure()+0x1dc>)
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    1c08:	ldr	r0, [pc, #436]	; (1dc0 <storage_configure()+0x1e0>)
    1c0a:	str	r2, [r3, #0]
    1c0c:	movs	r1, #0
    1c0e:	bl	a228 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    1c12:	ldr	r0, [pc, #428]	; (1dc0 <storage_configure()+0x1e0>)
    1c14:	bl	a178 <Print::println()>
                Serial.println("No sdio storage"); 
            }
      }
      else if(cs[ii]<BUILTIN_SDCARD)
      { 
            sdCsInit(cs[ii]);
    1c18:	movs	r0, #10
    1c1a:	bl	1ba8 <sdCsInit(unsigned char)>
            delay(100);
    1c1e:	movs	r0, #100	; 0x64
    1c20:	bl	950c <delay>
    1c24:	movs	r6, #0
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    1c26:	mov.w	ip, #10
    spiConfigBackupOptions = spiConfig.options;
    1c2a:	mov.w	lr, #0
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    1c2e:	ldr	r3, [pc, #404]	; (1dc4 <storage_configure()+0x1e4>)
    1c30:	str	r3, [sp, #28]
    1c32:	strb.w	ip, [sp, #20]
    1c36:	strb.w	lr, [sp, #21]
    1c3a:	str.w	r8, [sp, #24]
    1c3e:	add	r2, sp, #20
    1c40:	ldmia	r2, {r0, r1, r2}
    1c42:	add	r4, sp, #32
    1c44:	stmia.w	r4, {r0, r1, r2}
    1c48:	str	r3, [sp, #40]	; 0x28
    1c4a:	strb.w	ip, [sp, #32]
    1c4e:	strb.w	lr, [sp, #33]	; 0x21
    1c52:	str.w	r8, [sp, #36]	; 0x24
    1c56:	ldmia.w	r4, {r0, r1, r2}
    1c5a:	str.w	r3, [r5, #1212]	; 0x4bc
    1c5e:	add	r3, sp, #44	; 0x2c
    1c60:	stmia.w	r3, {r0, r1, r2}
   *
   * \param[in] config SPI configuration.
   * \return generic card pointer.
   */
  SdCard* newCard(SdSpiConfig config) {
    m_spiCard.begin(config);
    1c64:	ldr	r4, [pc, #352]	; (1dc8 <storage_configure()+0x1e8>)
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    1c66:	strb.w	ip, [r5, #1204]	; 0x4b4
    spiConfigBackupOptions = spiConfig.options;
    1c6a:	strb.w	lr, [r5, #1205]	; 0x4b5
    spiConfigBackupClock = spiConfig.maxSck;
    1c6e:	str.w	r8, [r5, #1208]	; 0x4b8
    1c72:	ldmia	r3, {r1, r2, r3}
    1c74:	mov	r0, r4
    1c76:	bl	79e8 <SdSpiCard::begin(SdSpiConfig)>
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    m_card = m_cardFactory.newCard(spiConfig);
    return m_card && !m_card->errorCode();
    1c7a:	ldrb.w	r9, [r5, #1199]	; 0x4af
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    m_card = m_cardFactory.newCard(spiConfig);
    1c7e:	str.w	r4, [r5, #1168]	; 0x490
    1c82:	uxth	r7, r6
    return m_card && !m_card->errorCode();
    1c84:	cmp.w	r9, #0
    1c88:	beq.n	1c94 <storage_configure()+0xb4>
            uint16_t tries=0;
            while(!sdx[ii].sdfs.begin(SdSpiConfig(cs[ii], SHARED_SPI, SPI_SPEED, &mySpi)) && tries<10)
    1c8a:	cmp	r7, #9
    1c8c:	ite	hi
    1c8e:	movhi	r4, #0
    1c90:	movls	r4, #1
    1c92:	b.n	1ca4 <storage_configure()+0xc4>
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    1c94:	mov	r1, r4
    1c96:	subw	r0, r4, #1180	; 0x49c
    1c9a:	bl	75b4 <FsVolume::begin(BlockDeviceInterface*)>
    1c9e:	cmp	r0, #0
    1ca0:	beq.n	1c8a <storage_configure()+0xaa>
    1ca2:	mov	r4, r9
    1ca4:	adds	r6, #1
    1ca6:	cbz	r4, 1cc2 <storage_configure()+0xe2>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    1ca8:	mov	r1, r7
    1caa:	ldr	r0, [pc, #276]	; (1dc0 <storage_configure()+0x1e0>)
    1cac:	bl	a228 <Print::print(long)>
            { Serial.print(tries); Serial.print(" "); tries++; delay(1000); } 
    1cb0:	ldr	r1, [pc, #280]	; (1dcc <storage_configure()+0x1ec>)
    1cb2:	ldr	r0, [pc, #268]	; (1dc0 <storage_configure()+0x1e0>)
    1cb4:	bl	1a28 <Print::print(char const*)>
    1cb8:	mov.w	r0, #1000	; 0x3e8
    1cbc:	bl	950c <delay>
      else if(cs[ii]<BUILTIN_SDCARD)
      { 
            sdCsInit(cs[ii]);
            delay(100);
            uint16_t tries=0;
            while(!sdx[ii].sdfs.begin(SdSpiConfig(cs[ii], SHARED_SPI, SPI_SPEED, &mySpi)) && tries<10)
    1cc0:	b.n	1c26 <storage_configure()+0x46>
            { Serial.print(tries); Serial.print(" "); tries++; delay(1000); } 

            if(tries<10) 
    1cc2:	cmp	r7, #9
    1cc4:	ldr	r6, [pc, #264]	; (1dd0 <storage_configure()+0x1f0>)
    1cc6:	ldr	r5, [pc, #268]	; (1dd4 <storage_configure()+0x1f4>)
    1cc8:	ldr	r7, [pc, #268]	; (1dd8 <storage_configure()+0x1f8>)
    1cca:	bls.n	1cde <storage_configure()+0xfe>
            {
                status=1;
            }
            else
            {
                Serial.println("No spi storage");
    1ccc:	ldr	r1, [pc, #268]	; (1ddc <storage_configure()+0x1fc>)
    1cce:	ldr	r0, [pc, #240]	; (1dc0 <storage_configure()+0x1e0>)
    1cd0:	bl	784 <Print::println(char const*)>
      }
      else
      {
            diskSize[ii]=0;
            diskSpace[ii]=0;
            clusterSize[ii]=1;
    1cd4:	movs	r3, #1
            diskSpace[ii]=diskSize[ii]=sdx[ii].sdfs.freeClusterCount();
            Serial.println(diskSize[ii]) ;Serial.print(" ");
      }
      else
      {
            diskSize[ii]=0;
    1cd6:	str	r4, [r6, #0]
            diskSpace[ii]=0;
    1cd8:	str	r4, [r5, #0]
            clusterSize[ii]=1;
    1cda:	str	r3, [r7, #0]
      }
    }
}
    1cdc:	b.n	1daa <storage_configure()+0x1ca>
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
		  * (uint64_t)sdfs.bytesPerCluster();
	}
	uint64_t totalSize() {
		return (uint64_t)sdfs.clusterCount() * (uint64_t)sdfs.bytesPerCluster();
    1cde:	ldr	r0, [pc, #256]	; (1de0 <storage_configure()+0x200>)
    1ce0:	bl	1a64 <FsVolume::clusterCount() const>
    1ce4:	mov	sl, r0
    1ce6:	ldr	r0, [pc, #248]	; (1de0 <storage_configure()+0x200>)
    1ce8:	bl	1a44 <FsVolume::bytesPerCluster() const>
    1cec:	umull	r8, r9, sl, r0
	}
	bool rmdir(const char *filepath) {
		return sdfs.rmdir(filepath);
	}
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
    1cf0:	ldr	r0, [pc, #236]	; (1de0 <storage_configure()+0x200>)
    1cf2:	bl	1a7c <FsVolume::freeClusterCount() const>
    1cf6:	rsb	sl, r0, sl
		  * (uint64_t)sdfs.bytesPerCluster();
    1cfa:	ldr	r0, [pc, #228]	; (1de0 <storage_configure()+0x200>)
    1cfc:	bl	1a44 <FsVolume::bytesPerCluster() const>
    1d00:	umull	r2, r3, sl, r0
    1d04:	strd	r2, r3, [sp, #8]
      if (status)
      {
            uint64_t totalSize = sdx[ii].totalSize();
            uint64_t usedSize  = sdx[ii].usedSize();

            Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]); 
    1d08:	ldr	r3, [pc, #216]	; (1de4 <storage_configure()+0x204>)
    1d0a:	ldr	r1, [pc, #220]	; (1de8 <storage_configure()+0x208>)
    1d0c:	ldr	r3, [r3, #0]
    1d0e:	str	r3, [sp, #0]
    1d10:	mov	r2, r4
    1d12:	movs	r3, #10
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
	size_t print(int64_t n);
	size_t print(uint64_t n)			{ return printNumber64(n, 10, 0); }
    1d14:	mov.w	sl, #10
    1d18:	ldr	r0, [pc, #164]	; (1dc0 <storage_configure()+0x1e0>)
    1d1a:	bl	a198 <Print::printf(char const*, ...)>
    1d1e:	mov	r2, r8
    1d20:	mov	r3, r9
    1d22:	str	r4, [sp, #4]
    1d24:	str.w	sl, [sp]
    1d28:	ldr	r0, [pc, #148]	; (1dc0 <storage_configure()+0x1e0>)
    1d2a:	bl	a238 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
            Serial.print(totalSize); Serial.print(" "); Serial.println(usedSize);
    1d2e:	ldr	r1, [pc, #156]	; (1dcc <storage_configure()+0x1ec>)
    1d30:	ldr	r0, [pc, #140]	; (1dc0 <storage_configure()+0x1e0>)
    1d32:	bl	1a28 <Print::print(char const*)>
    1d36:	ldrd	r2, r3, [sp, #8]
    1d3a:	str	r4, [sp, #4]
    1d3c:	str.w	sl, [sp]
    1d40:	ldr	r0, [pc, #124]	; (1dc0 <storage_configure()+0x1e0>)
    1d42:	bl	a238 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
	size_t println(int64_t n)			{ return print(n) + println(); }
	size_t println(uint64_t n)			{ return print(n) + println(); }
    1d46:	ldr	r0, [pc, #120]	; (1dc0 <storage_configure()+0x1e0>)
    1d48:	bl	a178 <Print::println()>

            Serial.print(sdx[ii].sdfs.clusterCount()); Serial.print(" "); 
    1d4c:	ldr	r0, [pc, #144]	; (1de0 <storage_configure()+0x200>)
    1d4e:	bl	1a64 <FsVolume::clusterCount() const>
    1d52:	mov	r1, r0
    1d54:	ldr	r0, [pc, #104]	; (1dc0 <storage_configure()+0x1e0>)
    1d56:	bl	77c <Print::print(unsigned long)>
    1d5a:	ldr	r1, [pc, #112]	; (1dcc <storage_configure()+0x1ec>)
    1d5c:	ldr	r0, [pc, #96]	; (1dc0 <storage_configure()+0x1e0>)
    1d5e:	bl	1a28 <Print::print(char const*)>
            Serial.print(sdx[ii].sdfs.freeClusterCount()); Serial.print(" ");
    1d62:	ldr	r0, [pc, #124]	; (1de0 <storage_configure()+0x200>)
    1d64:	bl	1a7c <FsVolume::freeClusterCount() const>
    1d68:	mov	r1, r0
    1d6a:	ldr	r0, [pc, #84]	; (1dc0 <storage_configure()+0x1e0>)
    1d6c:	bl	77c <Print::print(unsigned long)>
    1d70:	ldr	r1, [pc, #88]	; (1dcc <storage_configure()+0x1ec>)
    1d72:	ldr	r0, [pc, #76]	; (1dc0 <storage_configure()+0x1e0>)
    1d74:	bl	1a28 <Print::print(char const*)>

            clusterSize[ii] = sdx[ii].sdfs.bytesPerCluster()/512; // count sectors
    1d78:	ldr	r0, [pc, #100]	; (1de0 <storage_configure()+0x200>)
    1d7a:	bl	1a44 <FsVolume::bytesPerCluster() const>
    1d7e:	lsrs	r1, r0, #9
            Serial.println(clusterSize[ii]) ;Serial.print(" ");
    1d80:	ldr	r0, [pc, #60]	; (1dc0 <storage_configure()+0x1e0>)
            Serial.print(totalSize); Serial.print(" "); Serial.println(usedSize);

            Serial.print(sdx[ii].sdfs.clusterCount()); Serial.print(" "); 
            Serial.print(sdx[ii].sdfs.freeClusterCount()); Serial.print(" ");

            clusterSize[ii] = sdx[ii].sdfs.bytesPerCluster()/512; // count sectors
    1d82:	str	r1, [r7, #0]
            Serial.println(clusterSize[ii]) ;Serial.print(" ");
    1d84:	bl	1a30 <Print::println(unsigned long)>
    1d88:	ldr	r1, [pc, #64]	; (1dcc <storage_configure()+0x1ec>)
    1d8a:	ldr	r0, [pc, #52]	; (1dc0 <storage_configure()+0x1e0>)
    1d8c:	bl	1a28 <Print::print(char const*)>

            diskSpace[ii]=diskSize[ii]=sdx[ii].sdfs.freeClusterCount();
    1d90:	ldr	r0, [pc, #76]	; (1de0 <storage_configure()+0x200>)
    1d92:	bl	1a7c <FsVolume::freeClusterCount() const>
    1d96:	mov	r1, r0
    1d98:	str	r0, [r6, #0]
    1d9a:	str	r0, [r5, #0]
            Serial.println(diskSize[ii]) ;Serial.print(" ");
    1d9c:	ldr	r0, [pc, #32]	; (1dc0 <storage_configure()+0x1e0>)
    1d9e:	bl	1a30 <Print::println(unsigned long)>
    1da2:	ldr	r1, [pc, #40]	; (1dcc <storage_configure()+0x1ec>)
    1da4:	ldr	r0, [pc, #24]	; (1dc0 <storage_configure()+0x1e0>)
    1da6:	bl	1a28 <Print::print(char const*)>
            diskSize[ii]=0;
            diskSpace[ii]=0;
            clusterSize[ii]=1;
      }
    }
}
    1daa:	add	sp, #56	; 0x38
    1dac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1db0:	.word	0x1fff131c
    1db4:	.word	0x2001a458
    1db8:	.word	0x2001ceb4
    1dbc:	.word	0x000018cf
    1dc0:	.word	0x1fff136c
    1dc4:	.word	0x2001b9d0
    1dc8:	.word	0x2001a8f8
    1dcc:	.word	0x000124c4
    1dd0:	.word	0x1fff2250
    1dd4:	.word	0x1fff2248
    1dd8:	.word	0x2001a97c
    1ddc:	.word	0x00012820
    1de0:	.word	0x2001a45c
    1de4:	.word	0x1fff0f44
    1de8:	.word	0x0001282f
    1dec:	.word	0x01f78a40

00001df0 <listDisks()>:

void listDisks(void)
{
    1df0:	push	{r0, r1, r2, r4, r5, lr}
    for(int ii=0;ii<nsd;ii++)
    {
        Serial.print("\n"); 
    1df2:	ldr	r4, [pc, #60]	; (1e30 <listDisks()+0x40>)
    1df4:	ldr	r5, [pc, #60]	; (1e34 <listDisks()+0x44>)
    1df6:	mov	r0, r4
    1df8:	mov	r1, r5
    1dfa:	bl	1a28 <Print::print(char const*)>
        Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]);
    1dfe:	ldr	r3, [pc, #56]	; (1e38 <listDisks()+0x48>)
    1e00:	ldr	r1, [pc, #56]	; (1e3c <listDisks()+0x4c>)
    1e02:	ldr	r3, [r3, #0]
    1e04:	str	r3, [sp, #0]
    1e06:	movs	r2, #0
    1e08:	movs	r3, #10
    1e0a:	mov	r0, r4
    1e0c:	bl	a198 <Print::printf(char const*, ...)>
        Serial.printf("%d %d",sdx[ii].sdfs.freeClusterCount(),diskSize[ii]);
    1e10:	ldr	r0, [pc, #44]	; (1e40 <listDisks()+0x50>)
    1e12:	bl	1a7c <FsVolume::freeClusterCount() const>
    1e16:	ldr	r3, [pc, #44]	; (1e44 <listDisks()+0x54>)
    1e18:	ldr	r1, [pc, #44]	; (1e48 <listDisks()+0x58>)
    1e1a:	ldr	r3, [r3, #0]
    1e1c:	mov	r2, r0
    1e1e:	mov	r0, r4
    1e20:	bl	a198 <Print::printf(char const*, ...)>
    }
    Serial.print("\n"); 
    1e24:	mov	r1, r5
    1e26:	mov	r0, r4
    1e28:	bl	1a28 <Print::print(char const*)>
}
    1e2c:	add	sp, #12
    1e2e:	pop	{r4, r5, pc}
    1e30:	.word	0x1fff136c
    1e34:	.word	0x00012d6c
    1e38:	.word	0x1fff0f44
    1e3c:	.word	0x0001282f
    1e40:	.word	0x2001a45c
    1e44:	.word	0x1fff2250
    1e48:	.word	0x00012841

00001e4c <checkReboot()>:
{
    int ii=0;
    while((ii<nsd) && (diskSpace[ii]<MIN_SPACE)) ii++;
    if(ii<nsd) CPU_RESTART;
    return -1;
}
    1e4c:	mov.w	r0, #4294967295
    1e50:	bx	lr
    1e52:	Address 0x00001e52 is out of bounds.


00001e54 <saveData(short)>:
    return 1;
}

/* main data filing routine */
int16_t saveData(int16_t status)
{   static char dirName[80];
    1e54:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    static char fileName[80];
    static char header[512];
    static int dirFlag=0;

    if(status<CLOSED) return status; // we are stopped: don't do anything
    1e58:	subs	r4, r0, #0
    return 1;
}

/* main data filing routine */
int16_t saveData(int16_t status)
{   static char dirName[80];
    1e5a:	sub	sp, #84	; 0x54
    static char fileName[80];
    static char header[512];
    static int dirFlag=0;

    if(status<CLOSED) return status; // we are stopped: don't do anything
    1e5c:	blt.w	202a <saveData(short)+0x1d6>

    //fetch data from circular buffer
    if(pullData(diskBuffer,NDBL))
    1e60:	movs	r1, #4
    1e62:	ldr	r0, [pc, #688]	; (2114 <saveData(short)+0x2c0>)
    1e64:	bl	1b64 <pullData(unsigned long*, unsigned long)>
    1e68:	cmp	r0, #0
    1e6a:	beq.w	1f76 <saveData(short)+0x122>
    {   disk_count++;
    1e6e:	ldr	r2, [pc, #680]	; (2118 <saveData(short)+0x2c4>)
    1e70:	ldr	r3, [r2, #0]
    1e72:	adds	r3, #1
    1e74:	str	r3, [r2, #0]
        if(status==CLOSED) // file closed: should open
    1e76:	cbnz	r4, 1eca <saveData(short)+0x76>
        bool doTransactions=true;

};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}
    1e78:	ldr	r4, [pc, #672]	; (211c <saveData(short)+0x2c8>)

static SDClass *checkDiskSpace(void)
{   static int isd_ = nsd;

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
    1e7a:	ldr.w	r8, [pc, #676]	; 2120 <saveData(short)+0x2cc>
    1e7e:	ldr.w	r9, [pc, #760]	; 2178 <saveData(short)+0x324>
        bool doTransactions=true;

};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}
    1e82:	movs	r3, #1
    1e84:	strb	r3, [r4, #8]
    1e86:	mov	r7, r8

static SDClass *checkDiskSpace(void)
{   static int isd_ = nsd;

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
    1e88:	ldr.w	r5, [r8]
    1e8c:	ldr	r6, [pc, #656]	; (2120 <saveData(short)+0x2cc>)
    1e8e:	cmp	r5, #0
    1e90:	bgt.w	1f9e <saveData(short)+0x14a>
    1e94:	ldr.w	r3, [r9, r5, lsl #2]
    1e98:	cmp	r3, #0
    1e9a:	beq.w	202e <saveData(short)+0x1da>
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    1e9e:	ldr	r0, [pc, #644]	; (2124 <saveData(short)+0x2d0>)
    1ea0:	mov.w	r3, #1224	; 0x4c8
    1ea4:	mla	r0, r3, r5, r0
    1ea8:	adds	r0, #4
    1eaa:	bl	1a7c <FsVolume::freeClusterCount() const>
    1eae:	ldr	r3, [pc, #632]	; (2128 <saveData(short)+0x2d4>)
    1eb0:	str.w	r0, [r3, r5, lsl #2]
    1eb4:	ldr	r3, [pc, #628]	; (212c <saveData(short)+0x2d8>)
    1eb6:	ldr	r3, [r3, #0]
    1eb8:	lsrs	r2, r3, #9
    1eba:	mov.w	r3, #2400	; 0x960
    1ebe:	muls	r3, r2
    1ec0:	cmp.w	r0, r3, lsr #10
    1ec4:	bcc.w	202e <saveData(short)+0x1da>
    1ec8:	b.n	1f9e <saveData(short)+0x14a>
            {
               return MUST_REBOOT; // if file open fails: don't do anything
            }
        }
        //
        if(status==OPENED) // file is open: write first record (header)
    1eca:	cmp	r4, #1
    1ecc:	bne.n	1f5c <saveData(short)+0x108>
     * @param header is pointer to header
     * 
     */
    #define MAGIC "WMXZ"
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    1ece:	bl	93fc <rtc_get>
    1ed2:	add	r1, sp, #24
    1ed4:	bl	1580 <breakTime(unsigned long, tmElements_t&)>

    int nd=sprintf(header,"%s%04d%02d%02d_%02d%02d%02d",
            MAGIC,tmYearToCalendar(tm.Year),tm.Month,tm.Day,tm.Hour,tm.Minute,tm.Second);
    1ed8:	ldrb.w	r2, [sp, #24]
    1edc:	str	r2, [sp, #16]
    1ede:	ldrb.w	r2, [sp, #25]
    1ee2:	str	r2, [sp, #12]
    1ee4:	ldrb.w	r2, [sp, #26]
    1ee8:	ldr	r5, [pc, #580]	; (2130 <saveData(short)+0x2dc>)
    1eea:	ldrb.w	r3, [sp, #30]
    1eee:	str	r2, [sp, #8]
    1ef0:	ldrb.w	r2, [sp, #28]
    1ef4:	str	r2, [sp, #4]
    1ef6:	ldrb.w	r2, [sp, #29]
    1efa:	str	r2, [sp, #0]
    1efc:	addw	r3, r3, #1970	; 0x7b2
    1f00:	ldr	r2, [pc, #560]	; (2134 <saveData(short)+0x2e0>)
    1f02:	ldr	r1, [pc, #564]	; (2138 <saveData(short)+0x2e4>)
    1f04:	mov	r0, r5
    1f06:	bl	be68 <sprintf>
    char *ptr = header+(nd+1);
    1f0a:	adds	r0, #1

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    1f0c:	movs	r2, #4
    1f0e:	str	r2, [r5, r0]
    iptr[1] = (int32_t)SerNum;      // serial number
    1f10:	ldr	r2, [pc, #552]	; (213c <saveData(short)+0x2e8>)
    tmElements_t tm;
    breakTime(rtc_get(), tm);

    int nd=sprintf(header,"%s%04d%02d%02d_%02d%02d%02d",
            MAGIC,tmYearToCalendar(tm.Year),tm.Month,tm.Day,tm.Hour,tm.Minute,tm.Second);
    char *ptr = header+(nd+1);
    1f12:	adds	r3, r5, r0

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    iptr[1] = (int32_t)SerNum;      // serial number
    1f14:	ldr	r2, [r2, #0]
    1f16:	str	r2, [r3, #4]
    iptr[2] = fsamp;
    1f18:	ldr	r2, [pc, #528]	; (212c <saveData(short)+0x2d8>)
    1f1a:	ldr	r2, [r2, #0]
    1f1c:	str	r2, [r3, #8]
    iptr[3] = NCHAN_ACQ;
    iptr[4] = t_acq;
    1f1e:	ldr	r2, [pc, #544]	; (2140 <saveData(short)+0x2ec>)
    1f20:	ldr	r2, [r2, #0]
    1f22:	str	r2, [r3, #16]

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    iptr[1] = (int32_t)SerNum;      // serial number
    iptr[2] = fsamp;
    iptr[3] = NCHAN_ACQ;
    1f24:	movs	r4, #2
    iptr[4] = t_acq;
    iptr[5] = 0;
    1f26:	movs	r2, #0

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    iptr[1] = (int32_t)SerNum;      // serial number
    iptr[2] = fsamp;
    iptr[3] = NCHAN_ACQ;
    1f28:	str	r4, [r3, #12]
    iptr[4] = t_acq;
    iptr[5] = 0;
    1f2a:	str	r2, [r3, #20]

    uint32_t *uptr = (uint32_t*) header;
    uptr[127] = 0x55555555;
    1f2c:	movs	r3, #85	; 0x55
    1f2e:	strb.w	r3, [r5, #508]	; 0x1fc
    1f32:	strb.w	r3, [r5, #509]	; 0x1fd
    1f36:	strb.w	r3, [r5, #510]	; 0x1fe
    1f3a:	strb.w	r3, [r5, #511]	; 0x1ff
    1f3e:	ldr	r3, [pc, #516]	; (2144 <saveData(short)+0x2f0>)
    1f40:	ldr	r0, [r3, #16]
	virtual size_t write(const uint8_t *buf, size_t size) {
		return (f) ? f->write((void*)buf, size) : 0;
	}

	size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    1f42:	cbnz	r0, 1f4a <saveData(short)+0xf6>
                file = msd->open(fileName, FILE_WRITE_BEGIN); 
                if(file) 
                    status = OPENED; 
                else 
                {   Serial.println("Failing open file");
                    return MUST_REBOOT; 
    1f44:	mvn.w	r0, #1
    1f48:	b.n	2256 <saveData(short)+0x402>
    1f4a:	ldr	r3, [r0, #0]
    1f4c:	mov.w	r2, #512	; 0x200
    1f50:	ldr	r3, [r3, #12]
    1f52:	mov	r1, r5
    1f54:	blx	r3
            }
        }
        //
        if(status==OPENED) // file is open: write first record (header)
        {   makeHeader(header);
            if(file.write((const void*)header,512) < 512) return MUST_REBOOT; else status=2;
    1f56:	cmp.w	r0, #512	; 0x200
    1f5a:	bcc.n	1f44 <saveData(short)+0xf0>
    1f5c:	ldr	r3, [pc, #484]	; (2144 <saveData(short)+0x2f0>)
    1f5e:	ldr	r0, [r3, #16]
    1f60:	cmp	r0, #0
    1f62:	beq.n	1f44 <saveData(short)+0xf0>
    1f64:	ldr	r3, [r0, #0]
    1f66:	ldr	r1, [pc, #428]	; (2114 <saveData(short)+0x2c0>)
    1f68:	ldr	r3, [r3, #12]
    1f6a:	mov.w	r2, #4096	; 0x1000
    1f6e:	blx	r3
        }
        //
        if(status>=RUNNING) // file is open, header written: store data records
        {   
            if(file.write((const void *)diskBuffer,4*MAX_DISK_BUFFER) < 4*MAX_DISK_BUFFER) return MUST_REBOOT;
    1f70:	cmp.w	r0, #4096	; 0x1000
    1f74:	bcc.n	1f44 <saveData(short)+0xf0>
        }
    }
    // following is done independent of data availability
    if(status==DOCLOSE) // should close file
    1f76:	cmp	r4, #3
    1f78:	bne.n	1f88 <saveData(short)+0x134>
    {
        // writes are done, so enable again transaction activations
        file.flush();
    1f7a:	ldr	r0, [pc, #456]	; (2144 <saveData(short)+0x2f0>)
    1f7c:	bl	9fe <File::flush()>
        file.close();
    1f80:	ldr	r0, [pc, #448]	; (2144 <saveData(short)+0x2f0>)
    1f82:	bl	f54 <File::close()>
    1f86:	b.n	2026 <saveData(short)+0x1d2>
        status = CLOSED;
    }
    if(status==MUSTSTOP) // should close file and stop
    1f88:	cmp	r4, #4
    1f8a:	bne.n	202a <saveData(short)+0x1d6>
    {   
        file.flush();
    1f8c:	ldr	r0, [pc, #436]	; (2144 <saveData(short)+0x2f0>)
    1f8e:	bl	9fe <File::flush()>
        file.close();
    1f92:	ldr	r0, [pc, #432]	; (2144 <saveData(short)+0x2f0>)
    1f94:	bl	f54 <File::close()>
        status = STOPPED;
    1f98:	mov.w	r0, #4294967295
    1f9c:	b.n	2256 <saveData(short)+0x402>
        bool doTransactions=true;

};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}
    1f9e:	movs	r3, #0
    1fa0:	strb	r3, [r4, #8]

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    doTransactions(false);
    if(isd<nsd) 
    1fa2:	ldr	r3, [r6, #0]
    1fa4:	ldr	r4, [pc, #376]	; (2120 <saveData(short)+0x2cc>)
    1fa6:	cmp	r3, #0
    1fa8:	bgt.n	1fe4 <saveData(short)+0x190>
    {   sdx[isd].sdfs.chvol();
    1faa:	ldr	r5, [pc, #376]	; (2124 <saveData(short)+0x2d0>)
    bool chdir(const char* path) {
    return m_fVol ? m_fVol->chdir(path) :
           m_xVol ? m_xVol->chdir(path) : false;
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
    1fac:	ldr	r2, [pc, #408]	; (2148 <saveData(short)+0x2f4>)
        Serial.println(); Serial.print(isd);
    1fae:	ldr	r0, [pc, #412]	; (214c <saveData(short)+0x2f8>)
    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    doTransactions(false);
    if(isd<nsd) 
    {   sdx[isd].sdfs.chvol();
    1fb0:	mov.w	r7, #1224	; 0x4c8
    1fb4:	mla	r3, r7, r3, r5
    1fb8:	adds	r3, #4
    1fba:	str	r3, [r2, #0]
        Serial.println(); Serial.print(isd);
    1fbc:	bl	a178 <Print::println()>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    1fc0:	ldr	r1, [r4, #0]
    1fc2:	ldr	r0, [pc, #392]	; (214c <saveData(short)+0x2f8>)
    1fc4:	bl	a228 <Print::print(long)>
        Serial.print(": "); Serial.print(sdx[isd].sdfs.freeClusterCount());
    1fc8:	ldr	r1, [pc, #388]	; (2150 <saveData(short)+0x2fc>)
    1fca:	ldr	r0, [pc, #384]	; (214c <saveData(short)+0x2f8>)
    1fcc:	bl	1a28 <Print::print(char const*)>
    1fd0:	ldr	r0, [r4, #0]
    1fd2:	mla	r0, r7, r0, r5
    1fd6:	adds	r0, #4
    1fd8:	bl	1a7c <FsVolume::freeClusterCount() const>
    1fdc:	mov	r1, r0
    1fde:	ldr	r0, [pc, #364]	; (214c <saveData(short)+0x2f8>)
    1fe0:	bl	77c <Print::print(unsigned long)>
    }
    //
    if(isd != isd_) hour_=0; // set hour_ to zero to trigger creation of directories in new disk
    1fe4:	ldr	r2, [pc, #364]	; (2154 <saveData(short)+0x300>)
    1fe6:	ldr	r3, [r6, #0]
    1fe8:	ldr	r1, [r2, #0]
    isd_=isd;
    1fea:	str	r3, [r2, #0]
    {   sdx[isd].sdfs.chvol();
        Serial.println(); Serial.print(isd);
        Serial.print(": "); Serial.print(sdx[isd].sdfs.freeClusterCount());
    }
    //
    if(isd != isd_) hour_=0; // set hour_ to zero to trigger creation of directories in new disk
    1fec:	cmp	r3, r1
    1fee:	it	ne
    1ff0:	ldrne	r1, [pc, #356]	; (2158 <saveData(short)+0x304>)
    //fetch data from circular buffer
    if(pullData(diskBuffer,NDBL))
    {   disk_count++;
        if(status==CLOSED) // file closed: should open
        {   //doTransactions(true);
            if(!(msd=checkDiskSpace())) return MUST_REBOOT;
    1ff2:	ldr	r5, [pc, #360]	; (215c <saveData(short)+0x308>)
    {   sdx[isd].sdfs.chvol();
        Serial.println(); Serial.print(isd);
        Serial.print(": "); Serial.print(sdx[isd].sdfs.freeClusterCount());
    }
    //
    if(isd != isd_) hour_=0; // set hour_ to zero to trigger creation of directories in new disk
    1ff4:	itt	ne
    1ff6:	movne	r0, #0
    1ff8:	strne	r0, [r1, #0]
    isd_=isd;
    if(isd==nsd) return (SDClass *) 0; else return &sdx[isd];
    1ffa:	cmp	r3, #1
    1ffc:	ittte	ne
    1ffe:	ldrne	r2, [pc, #292]	; (2124 <saveData(short)+0x2d0>)
    2000:	movne.w	r1, #1224	; 0x4c8
    2004:	mlane	r3, r1, r3, r2
    2008:	moveq	r3, #0
    //fetch data from circular buffer
    if(pullData(diskBuffer,NDBL))
    {   disk_count++;
        if(status==CLOSED) // file closed: should open
        {   //doTransactions(true);
            if(!(msd=checkDiskSpace())) return MUST_REBOOT;
    200a:	str	r3, [r5, #0]
    200c:	cmp	r3, #0
    200e:	beq.n	1f44 <saveData(short)+0xf0>
            //
            if(newDirectory(dirName,dirFlag)) 
    2010:	ldr	r4, [pc, #332]	; (2160 <saveData(short)+0x30c>)
    2012:	ldr	r7, [r4, #0]
    isd_=isd;
    if(isd==nsd) return (SDClass *) 0; else return &sdx[isd];
}

static int16_t newDirectory(char *dirName, int dirFlag)
{ if(newHour())
    2014:	bl	155c <newHour()>
    2018:	cbnz	r0, 2036 <saveData(short)+0x1e2>
            if(newDirectory(dirName,dirFlag)) 
            {   if(!msd->sdfs.exists(dirName) && !msd->sdfs.mkdir(dirName)) dirFlag++;          
                if(!msd->sdfs.chdir(dirName)) dirFlag++; else dirFlag=0;
            }
            //
            if(dirFlag>5) return MUST_REBOOT;   // too many directory errors
    201a:	ldr	r3, [r4, #0]
    201c:	cmp	r3, #5
    201e:	bgt.n	1f44 <saveData(short)+0xf0>
            if(dirFlag>0) return CLOSED;        // create new directory with different name
    2020:	cmp	r3, #0
    2022:	ble.w	21c6 <saveData(short)+0x372>
    2026:	movs	r0, #0
    2028:	b.n	2256 <saveData(short)+0x402>
    202a:	mov	r0, r4
    202c:	b.n	2256 <saveData(short)+0x402>
static SDClass *checkDiskSpace(void)
{   static int isd_ = nsd;

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    202e:	ldr	r3, [r7, #0]
    2030:	adds	r3, #1
    2032:	str	r3, [r7, #0]
    2034:	b.n	1e88 <saveData(short)+0x34>

static int16_t newDirectory(char *dirName, int dirFlag)
{ if(newHour())
    {   
        tmElements_t tm;
        breakTime(rtc_get(), tm);
    2036:	bl	93fc <rtc_get>
    203a:	add	r1, sp, #24
    203c:	bl	1580 <breakTime(unsigned long, tmElements_t&)>
    2040:	ldr	r2, [pc, #248]	; (213c <saveData(short)+0x2e8>)
    2042:	ldrb.w	lr, [sp, #26]
    2046:	ldrb.w	r0, [sp, #28]
    204a:	ldrb.w	r1, [sp, #29]
    204e:	ldrb.w	r3, [sp, #30]
        if(!dirFlag)
    2052:	cbnz	r7, 2070 <saveData(short)+0x21c>
        {
            sprintf(dirName, "/%s%06x_%04d%02d%02d/%02d/", 
                          DirPrefix,(unsigned int)SerNum,
                                  tmYearToCalendar(tm.Year),tm.Month, tm.Day, tm.Hour);
    2054:	addw	r3, r3, #1970	; 0x7b2
    2058:	str	r0, [sp, #8]
    205a:	str	r1, [sp, #4]
    205c:	str.w	lr, [sp, #12]
    2060:	str	r3, [sp, #0]
    2062:	ldr	r3, [r2, #0]
    2064:	ldr	r1, [pc, #252]	; (2164 <saveData(short)+0x310>)
    2066:	ldr	r2, [pc, #256]	; (2168 <saveData(short)+0x314>)
    2068:	ldr	r0, [pc, #256]	; (216c <saveData(short)+0x318>)
    206a:	bl	be68 <sprintf>
    206e:	b.n	208c <saveData(short)+0x238>
        }
        else
        {
            sprintf(dirName, "/%s%06x_%04d%02d%02d/%02d_%02d/", 
                          DirPrefix,(unsigned int)SerNum,
                                  tmYearToCalendar(tm.Year),tm.Month, tm.Day, tm.Hour,dirFlag);
    2070:	addw	r3, r3, #1970	; 0x7b2
    2074:	str	r0, [sp, #8]
    2076:	str	r1, [sp, #4]
    2078:	str	r7, [sp, #16]
    207a:	str.w	lr, [sp, #12]
    207e:	str	r3, [sp, #0]
    2080:	ldr	r3, [r2, #0]
    2082:	ldr	r1, [pc, #236]	; (2170 <saveData(short)+0x31c>)
    2084:	ldr	r2, [pc, #224]	; (2168 <saveData(short)+0x314>)
    2086:	ldr	r0, [pc, #228]	; (216c <saveData(short)+0x318>)
    2088:	bl	be68 <sprintf>
        }

        //
        Serial.print("\n"); Serial.print(dirName);
    208c:	ldr	r1, [pc, #228]	; (2174 <saveData(short)+0x320>)
    208e:	ldr	r0, [pc, #188]	; (214c <saveData(short)+0x2f8>)
    2090:	bl	1a28 <Print::print(char const*)>
    2094:	ldr	r1, [pc, #212]	; (216c <saveData(short)+0x318>)
    2096:	ldr	r0, [pc, #180]	; (214c <saveData(short)+0x2f8>)
    2098:	bl	1a28 <Print::print(char const*)>
        if(status==CLOSED) // file closed: should open
        {   //doTransactions(true);
            if(!(msd=checkDiskSpace())) return MUST_REBOOT;
            //
            if(newDirectory(dirName,dirFlag)) 
            {   if(!msd->sdfs.exists(dirName) && !msd->sdfs.mkdir(dirName)) dirFlag++;          
    209c:	ldr	r3, [r5, #0]
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
    209e:	ldr.w	r1, [r3, #1156]	; 0x484
           m_xVol ? m_xVol->exists(path) : false;
    20a2:	cbz	r1, 20bc <saveData(short)+0x268>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    20a4:	movs	r3, #0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    20a6:	ldr	r2, [pc, #196]	; (216c <saveData(short)+0x318>)
    20a8:	strb.w	r3, [sp, #24]
    20ac:	add	r0, sp, #24
    20ae:	strb.w	r3, [sp, #25]
    20b2:	strb.w	r3, [sp, #26]
    20b6:	bl	6328 <FatFile::open(FatVolume*, char const*, int)>
    20ba:	b.n	2100 <saveData(short)+0x2ac>
    20bc:	ldr.w	r0, [r3, #1160]	; 0x488
    20c0:	cbnz	r0, 20e8 <saveData(short)+0x294>
    20c2:	ldr	r3, [r5, #0]
   * \param[in] pFlag Create missing parent directories if true.
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
    20c4:	ldr.w	r1, [r3, #1156]	; 0x484
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
    20c8:	cbz	r1, 2106 <saveData(short)+0x2b2>
    20ca:	movs	r3, #0
    20cc:	strb.w	r3, [sp, #24]
    20d0:	strb.w	r3, [sp, #25]
    20d4:	strb.w	r3, [sp, #26]
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    20d8:	ldr	r2, [pc, #144]	; (216c <saveData(short)+0x318>)
    20da:	movs	r3, #1
    20dc:	add.w	r1, r1, #1096	; 0x448
    20e0:	add	r0, sp, #24
    20e2:	bl	64a4 <FatFile::mkdir(FatFile*, char const*, bool)>
    20e6:	b.n	2196 <saveData(short)+0x342>
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    20e8:	strb.w	r1, [sp, #73]	; 0x49
    20ec:	strb.w	r1, [sp, #74]	; 0x4a
    20f0:	strb.w	r1, [sp, #75]	; 0x4b
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    20f4:	mov	r3, r1
    20f6:	ldr	r2, [pc, #116]	; (216c <saveData(short)+0x318>)
    20f8:	mov	r1, r0
    20fa:	add	r0, sp, #24
    20fc:	bl	47e2 <ExFatFile::open(ExFatVolume*, char const*, int)>
    2100:	cmp	r0, #0
    2102:	bne.n	219a <saveData(short)+0x346>
    2104:	b.n	20c2 <saveData(short)+0x26e>
    2106:	ldr.w	r0, [r3, #1160]	; 0x488
    210a:	cbnz	r0, 217c <saveData(short)+0x328>
    210c:	ldr	r3, [r4, #0]
    210e:	adds	r3, #1
    2110:	str	r3, [r4, #0]
    2112:	b.n	219a <saveData(short)+0x346>
    2114:	.word	0x2001b9e0
    2118:	.word	0x2001b9dc
    211c:	.word	0x2001b9d0
    2120:	.word	0x1fff224c
    2124:	.word	0x2001a458
    2128:	.word	0x1fff2248
    212c:	.word	0x2001c9e0
    2130:	.word	0x2001a254
    2134:	.word	0x000128ac
    2138:	.word	0x000128b1
    213c:	.word	0x1fff222c
    2140:	.word	0x1fff0f38
    2144:	.word	0x1fff2234
    2148:	.word	0x2001cec0
    214c:	.word	0x1fff136c
    2150:	.word	0x000124c3
    2154:	.word	0x1fff0f40
    2158:	.word	0x1fff2230
    215c:	.word	0x2001a454
    2160:	.word	0x2001a970
    2164:	.word	0x00012849
    2168:	.word	0x00012847
    216c:	.word	0x2001a980
    2170:	.word	0x00012864
    2174:	.word	0x00012d6c
    2178:	.word	0x1fff2250
    217c:	strb.w	r1, [sp, #73]	; 0x49
    2180:	strb.w	r1, [sp, #74]	; 0x4a
    2184:	strb.w	r1, [sp, #75]	; 0x4b
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    2188:	movs	r3, #1
    218a:	add.w	r1, r0, #1096	; 0x448
    218e:	ldr	r2, [pc, #204]	; (225c <saveData(short)+0x408>)
    2190:	add	r0, sp, #24
    2192:	bl	5084 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
    2196:	cmp	r0, #0
    2198:	beq.n	210c <saveData(short)+0x2b8>
                if(!msd->sdfs.chdir(dirName)) dirFlag++; else dirFlag=0;
    219a:	ldr	r3, [r5, #0]
   * Set volume working directory.
   * \param[in] path Path for volume working directory.
   * \return true for success or false for failure.
   */
    bool chdir(const char* path) {
    return m_fVol ? m_fVol->chdir(path) :
    219c:	ldr.w	r0, [r3, #1156]	; 0x484
           m_xVol ? m_xVol->chdir(path) : false;
    21a0:	cbz	r0, 21aa <saveData(short)+0x356>
    21a2:	ldr	r1, [pc, #184]	; (225c <saveData(short)+0x408>)
    21a4:	bl	6d24 <FatVolume::chdir(char const*)>
    21a8:	b.n	21bc <saveData(short)+0x368>
    21aa:	ldr.w	r0, [r3, #1160]	; 0x488
    21ae:	cbnz	r0, 21b6 <saveData(short)+0x362>
    21b0:	ldr	r3, [r4, #0]
    21b2:	adds	r3, #1
    21b4:	b.n	21c2 <saveData(short)+0x36e>
    21b6:	ldr	r1, [pc, #164]	; (225c <saveData(short)+0x408>)
    21b8:	bl	4c2c <ExFatVolume::chdir(char const*)>
    21bc:	cmp	r0, #0
    21be:	beq.n	21b0 <saveData(short)+0x35c>
    21c0:	movs	r3, #0
    21c2:	str	r3, [r4, #0]
    21c4:	b.n	201a <saveData(short)+0x1c6>

}
static int16_t newFileName(char *fileName)
{
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    21c6:	bl	93fc <rtc_get>
    21ca:	add	r1, sp, #24
    21cc:	bl	1580 <breakTime(unsigned long, tmElements_t&)>
	sprintf(fileName, "%s_%02d%02d%02d.bin", FilePrefix, tm.Hour, tm.Minute, tm.Second);
    21d0:	ldrb.w	r2, [sp, #24]
    21d4:	str	r2, [sp, #4]
    21d6:	ldrb.w	r2, [sp, #25]
    21da:	ldrb.w	r3, [sp, #26]
    21de:	str	r2, [sp, #0]
    21e0:	ldr	r1, [pc, #124]	; (2260 <saveData(short)+0x40c>)
    21e2:	ldr	r2, [pc, #128]	; (2264 <saveData(short)+0x410>)
    21e4:	ldr	r0, [pc, #128]	; (2268 <saveData(short)+0x414>)
    21e6:	bl	be68 <sprintf>
    //
    Serial.print("\n"); Serial.print(isd); Serial.print(": ");Serial.print(fileName);
    21ea:	ldr	r1, [pc, #128]	; (226c <saveData(short)+0x418>)
    21ec:	ldr	r0, [pc, #128]	; (2270 <saveData(short)+0x41c>)
    21ee:	bl	1a28 <Print::print(char const*)>
    21f2:	ldr	r1, [r6, #0]
    21f4:	ldr	r0, [pc, #120]	; (2270 <saveData(short)+0x41c>)
    21f6:	bl	a228 <Print::print(long)>
    21fa:	ldr	r1, [pc, #120]	; (2274 <saveData(short)+0x420>)
    21fc:	ldr	r0, [pc, #112]	; (2270 <saveData(short)+0x41c>)
    21fe:	bl	1a28 <Print::print(char const*)>
    2202:	ldr	r1, [pc, #100]	; (2268 <saveData(short)+0x414>)
    2204:	ldr	r0, [pc, #104]	; (2270 <saveData(short)+0x41c>)
    2206:	bl	1a28 <Print::print(char const*)>
            if(dirFlag>5) return MUST_REBOOT;   // too many directory errors
            if(dirFlag>0) return CLOSED;        // create new directory with different name

            if(newFileName(fileName))
            {   
                file = msd->open(fileName, FILE_WRITE_BEGIN); 
    220a:	ldr	r1, [r5, #0]
    220c:	ldr	r2, [pc, #88]	; (2268 <saveData(short)+0x414>)
    220e:	ldr	r3, [r1, #0]
    2210:	add	r0, sp, #24
    2212:	ldr	r4, [r3, #0]
    2214:	movs	r3, #2
    2216:	blx	r4
	}
#ifdef FILE_USE_MOVE
	// Move assignment.
	File& operator = (const File&& file) {
		//Serial.println("File move assignment");
		if (file.f) file.f->refcount++;
    2218:	ldr	r3, [sp, #40]	; 0x28
    221a:	cbz	r3, 2222 <saveData(short)+0x3ce>
    221c:	ldr	r2, [r3, #4]
    221e:	adds	r2, #1
    2220:	str	r2, [r3, #4]
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
    2222:	ldr	r4, [pc, #84]	; (2278 <saveData(short)+0x424>)
    2224:	ldr	r3, [r4, #16]
    2226:	cbz	r3, 2230 <saveData(short)+0x3dc>
    2228:	add.w	r0, r4, #16
    222c:	bl	1990 <File::dec_refcount() [clone .isra.23]>
		f = file.f;
    2230:	ldr	r3, [sp, #40]	; 0x28
    2232:	str	r3, [r4, #16]
    2234:	add	r0, sp, #24
    2236:	bl	bb8 <File::~File()>
    223a:	ldr	r0, [r4, #16]
			f->close();
			dec_refcount();
		}
	}
	operator bool() {
		return (f) ? f->isOpen() : false;
    223c:	cbnz	r0, 2248 <saveData(short)+0x3f4>
                if(file) 
                    status = OPENED; 
                else 
                {   Serial.println("Failing open file");
    223e:	ldr	r1, [pc, #60]	; (227c <saveData(short)+0x428>)
    2240:	ldr	r0, [pc, #44]	; (2270 <saveData(short)+0x41c>)
    2242:	bl	784 <Print::println(char const*)>
    2246:	b.n	1f44 <saveData(short)+0xf0>
    2248:	ldr	r3, [r0, #0]
    224a:	ldr	r3, [r3, #48]	; 0x30
    224c:	blx	r3
            if(dirFlag>0) return CLOSED;        // create new directory with different name

            if(newFileName(fileName))
            {   
                file = msd->open(fileName, FILE_WRITE_BEGIN); 
                if(file) 
    224e:	cmp	r0, #0
    2250:	bne.w	1ece <saveData(short)+0x7a>
    2254:	b.n	223e <saveData(short)+0x3ea>
        file.flush();
        file.close();
        status = STOPPED;
    }
    return status;
}
    2256:	add	sp, #84	; 0x54
    2258:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    225c:	.word	0x2001a980
    2260:	.word	0x00012886
    2264:	.word	0x00012884
    2268:	.word	0x2001a920
    226c:	.word	0x00012d6c
    2270:	.word	0x1fff136c
    2274:	.word	0x000124c3
    2278:	.word	0x1fff2234
    227c:	.word	0x0001289a

00002280 <_GLOBAL__sub_I_data_buffer>:
    2280:	push	{r3, r4, r5, lr}
            { /**
             * @brief Constructor
             * @param buffer is pointer to data store
             * 
             */
                data_buffer=buffer; front_=rear_=0;
    2282:	ldr	r3, [pc, #128]	; (2304 <_GLOBAL__sub_I_data_buffer+0x84>)
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    2284:	ldr	r0, [pc, #128]	; (2308 <_GLOBAL__sub_I_data_buffer+0x88>)

/****************************** Filing Utility *******************************************/

extern int t_acq;

File file=NULL; // is used by saveData and saveNAD
    2286:	ldr	r5, [pc, #132]	; (230c <_GLOBAL__sub_I_data_buffer+0x8c>)
            { /**
             * @brief Constructor
             * @param buffer is pointer to data store
             * 
             */
                data_buffer=buffer; front_=rear_=0;
    2288:	ldr	r2, [pc, #132]	; (2310 <_GLOBAL__sub_I_data_buffer+0x90>)
    228a:	str	r2, [r3, #4]
    228c:	movs	r4, #0
    228e:	strh	r4, [r3, #2]
    2290:	strh	r4, [r3, #0]
    2292:	mov.w	r3, #1000	; 0x3e8

/****************************** Filing Utility *******************************************/

extern int t_acq;

File file=NULL; // is used by saveData and saveNAD
    2296:	mov	r2, r5
    2298:	strb	r4, [r0, #4]
    229a:	str	r3, [r0, #8]
    229c:	strb	r4, [r0, #12]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
    229e:	ldr	r3, [pc, #116]	; (2314 <_GLOBAL__sub_I_data_buffer+0x94>)
    22a0:	ldr	r1, [pc, #116]	; (2318 <_GLOBAL__sub_I_data_buffer+0x98>)
    22a2:	str	r3, [r0, #0]
		f = file;
    22a4:	str	r4, [r0, #16]
    22a6:	bl	a4e0 <__aeabi_atexit>
// This is a simple driver based on the the standard SPI.h library.
// You can write a driver entirely independent of SPI.h.
// It can be optimized for your board or a different SPI port can be used.
// The driver must be derived from SdSpiBaseClass.
// See: SdFat/src/SpiDriver/SdSpiBaseClass.h
class MySpiClass : public SdSpiBaseClass {
    22aa:	ldr	r3, [pc, #112]	; (231c <_GLOBAL__sub_I_data_buffer+0x9c>)
    22ac:	ldr	r2, [pc, #112]	; (2320 <_GLOBAL__sub_I_data_buffer+0xa0>)
    22ae:	str	r2, [r3, #0]
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
		}
		ctar = c | t;
    22b0:	ldr	r2, [pc, #112]	; (2324 <_GLOBAL__sub_I_data_buffer+0xa4>)
    22b2:	str	r2, [r3, #4]
    22b4:	movs	r2, #1
    22b6:	strb	r2, [r3, #8]


class SDClass : public FS
{
public:
	SDClass() { }
    22b8:	ldr	r3, [pc, #108]	; (2328 <_GLOBAL__sub_I_data_buffer+0xa8>)
    22ba:	ldr	r1, [pc, #112]	; (232c <_GLOBAL__sub_I_data_buffer+0xac>)
#else  // HAS_SDIO_CLASS
class SdSpiCard {
#endif  // HAS_SDIO_CLASS
 public:
  /** Construct an instance of SdSpiCard. */
  SdSpiCard() {}
    22bc:	strb.w	r2, [r3, #1197]	; 0x4ad
    22c0:	movs	r2, #41	; 0x29
    22c2:	str	r1, [r3, #0]
    22c4:	strb.w	r2, [r3, #1199]	; 0x4af
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    22c8:	ldr	r1, [pc, #100]	; (2330 <_GLOBAL__sub_I_data_buffer+0xb0>)
    22ca:	str.w	r1, [r3, #1172]	; 0x494
    22ce:	movs	r2, #255	; 0xff
    22d0:	ldr	r1, [pc, #96]	; (2334 <_GLOBAL__sub_I_data_buffer+0xb4>)
    22d2:	strb.w	r2, [r3, #1221]	; 0x4c5
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    22d6:	strb.w	r4, [r3, #1180]	; 0x49c
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    22da:	strb.w	r4, [r3, #1181]	; 0x49d
    22de:	strb.w	r4, [r3, #1202]	; 0x4b2
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    22e2:	strb.w	r4, [r3, #1216]	; 0x4c0
    22e6:	str.w	r1, [r3, #1184]	; 0x4a0
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() {}
    22ea:	str.w	r4, [r3, #1156]	; 0x484
    22ee:	str.w	r4, [r3, #1160]	; 0x488
    22f2:	strb.w	r4, [r3, #1220]	; 0x4c4
    const char *sd_str[]={"sd1"};
    const int cs[] = {10 };

    const int nsd = sizeof(cs)/sizeof(int);

    SDClass sdx[nsd];
    22f6:	mov	r2, r5
    22f8:	mov	r0, r4
    22fa:	ldr	r1, [pc, #60]	; (2338 <_GLOBAL__sub_I_data_buffer+0xb8>)
        file.flush();
        file.close();
        status = STOPPED;
    }
    return status;
}
    22fc:	ldmia.w	sp!, {r3, r4, r5, lr}
    const char *sd_str[]={"sd1"};
    const int cs[] = {10 };

    const int nsd = sizeof(cs)/sizeof(int);

    SDClass sdx[nsd];
    2300:	b.w	a4e0 <__aeabi_atexit>
    2304:	.word	0x2001a974
    2308:	.word	0x1fff2234
    230c:	.word	0x1fff0f30
    2310:	.word	0x1fff2254
    2314:	.word	0x0001253c
    2318:	.word	0x00000bb9
    231c:	.word	0x2001b9d0
    2320:	.word	0x00012800
    2324:	.word	0x38011001
    2328:	.word	0x2001a458
    232c:	.word	0x00012a94
    2330:	.word	0x00012df4
    2334:	.word	0x00012d94
    2338:	.word	0x000018cd

0000233c <TwoWire::write(int)>:
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
	}
	size_t write(int n) {
		return write((uint8_t)n);
    233c:	ldr	r3, [r0, #0]
    233e:	uxtb	r1, r1
    2340:	ldr	r3, [r3, #0]
    2342:	bx	r3

00002344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>:
        val = wire->read()<<8;
        val |= wire->read();
        return val;
    }
    
    uint8_t write16(uint8_t addr, uint16_t reg, uint16_t val) 
    2344:	push	{r3, r4, r5, r6, r7, lr}
    2346:	mov	r6, r3
    { 
        wire->beginTransmission(addr);
    2348:	ldr	r3, [r0, #0]
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
		transmitting = 1;
    234a:	movs	r5, #1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    234c:	lsls	r1, r1, #1
    234e:	strb.w	r1, [r3, #163]	; 0xa3
		transmitting = 1;
    2352:	strb.w	r5, [r3, #302]	; 0x12e
		txBufferLength = 1;
    2356:	strb.w	r5, [r3, #301]	; 0x12d
        val = wire->read()<<8;
        val |= wire->read();
        return val;
    }
    
    uint8_t write16(uint8_t addr, uint16_t reg, uint16_t val) 
    235a:	mov	r4, r0
    235c:	mov	r7, r2
    { 
        wire->beginTransmission(addr);
        wire->write(reg >> 8);
    235e:	lsrs	r1, r2, #8
    2360:	ldr	r0, [r0, #0]
    2362:	bl	233c <TwoWire::write(int)>
        wire->write(reg);
    2366:	mov	r1, r7
    2368:	ldr	r0, [r4, #0]
    236a:	bl	233c <TwoWire::write(int)>
        wire->write(val >> 8);
    236e:	lsrs	r1, r6, #8
    2370:	ldr	r0, [r4, #0]
    2372:	bl	233c <TwoWire::write(int)>
        wire->write(val);
    2376:	mov	r1, r6
    2378:	ldr	r0, [r4, #0]
    237a:	bl	233c <TwoWire::write(int)>
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    237e:	mov	r1, r5
    2380:	ldr	r0, [r4, #0]
    2382:	bl	28a4 <TwoWire::endTransmission(unsigned char)>
        return (wire->endTransmission() == 0) ;
    }
    2386:	clz	r0, r0
    238a:	lsrs	r0, r0, #5
    238c:	pop	{r3, r4, r5, r6, r7, pc}

0000238e <adc_init()>:
    238e:	bx	lr

00002390 <adcStatus()>:
    static uint8_t addr = SGTL5000_I2C_ADDR_CS_LOW;
    i2c_class i2c(&Wire);
    
    void adc_init(void) {  }
    void setAGain(int8_t again) {  }
    void adcStatus(void) {  }
    2390:	bx	lr
    2392:	Address 0x00002392 is out of bounds.


00002394 <adc_enable()>:

    bool adc_enable(void) 
    {   const unsigned extMCLK=0;   // slave
    2394:	push	{r4, r5, r6, lr}
        wire->setSDA(sda);
    }

    uint8_t exist(uint8_t addr)
    {
        wire->beginTransmission(addr);
    2396:	ldr	r4, [pc, #392]	; (2520 <adc_enable()+0x18c>)
    2398:	ldr	r0, [r4, #0]
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
		transmitting = 1;
    239a:	movs	r1, #1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    239c:	movs	r5, #20
    239e:	strb.w	r5, [r0, #163]	; 0xa3
		transmitting = 1;
    23a2:	strb.w	r1, [r0, #302]	; 0x12e
		txBufferLength = 1;
    23a6:	strb.w	r1, [r0, #301]	; 0x12d
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    23aa:	bl	28a4 <TwoWire::endTransmission(unsigned char)>
        const uint32_t pllFreq=1;   // pll
        if(!i2c.exist(addr)) Serial.println("No I2C address found");
    23ae:	cbz	r0, 23be <adc_enable()+0x2a>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    23b0:	mov	r1, r5
    23b2:	ldr	r0, [pc, #368]	; (2524 <adc_enable()+0x190>)
    23b4:	bl	918c <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    23b8:	ldr	r0, [pc, #364]	; (2528 <adc_enable()+0x194>)
    23ba:	bl	a178 <Print::println()>
    }

    uint16_t read16(uint8_t addr, uint16_t reg) 
    { 
        unsigned int val;
        wire->beginTransmission(addr);
    23be:	ldr	r0, [r4, #0]
    23c0:	ldr	r5, [pc, #348]	; (2520 <adc_enable()+0x18c>)
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    23c2:	movs	r3, #20
		transmitting = 1;
    23c4:	movs	r6, #1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    23c6:	strb.w	r3, [r0, #163]	; 0xa3
        wire->write(reg >> 8);
    23ca:	movs	r1, #0
		transmitting = 1;
    23cc:	strb.w	r6, [r0, #302]	; 0x12e
		txBufferLength = 1;
    23d0:	strb.w	r6, [r0, #301]	; 0x12d
    23d4:	bl	233c <TwoWire::write(int)>
        wire->write(reg);
    23d8:	movs	r1, #6
    23da:	ldr	r0, [r4, #0]
    23dc:	bl	233c <TwoWire::write(int)>
        if (wire->endTransmission(false) != 0) return 0;
    23e0:	movs	r1, #0
    23e2:	ldr	r0, [r4, #0]
    23e4:	bl	28a4 <TwoWire::endTransmission(unsigned char)>
    23e8:	cbnz	r0, 2408 <adc_enable()+0x74>
	uint8_t requestFrom(int address, int quantity, int sendStop) {
		return requestFrom((uint8_t)address, (uint8_t)quantity,
			(uint8_t)(sendStop ? 1 : 0));
	}
	uint8_t requestFrom(int address, int quantity) {
		return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)1);
    23ea:	mov	r3, r6
    23ec:	mov	r2, r6
    23ee:	movs	r1, #10
    23f0:	ldr	r0, [r5, #0]
    23f2:	bl	299c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
        if (wire->requestFrom((int)addr, 1) < 1) return 0;
    23f6:	cbz	r0, 2408 <adc_enable()+0x74>
        val = wire->read()<<8;
    23f8:	ldr	r0, [r5, #0]
    23fa:	ldr	r3, [r0, #0]
    23fc:	ldr	r3, [r3, #20]
    23fe:	blx	r3
        val |= wire->read();
    2400:	ldr	r0, [r5, #0]
    2402:	ldr	r3, [r0, #0]
    2404:	ldr	r3, [r3, #20]
    2406:	blx	r3
        if ( (extMCLK > 0) && (n == (0x0030 | (1<<7))) ) 
        {   //Yes. Do not initialize.
            return true;
        }

        int r = i2c.write16(addr,CHIP_ANA_POWER, 0x4060);  // VDDD is externally driven with 1.8V
    2408:	movw	r3, #16480	; 0x4060
    240c:	movs	r2, #48	; 0x30
    240e:	movs	r1, #10
    2410:	ldr	r0, [pc, #268]	; (2520 <adc_enable()+0x18c>)
    2412:	bl	2344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        if (!r) return false;
    2416:	cbnz	r0, 241c <adc_enable()+0x88>
    2418:	movs	r0, #0
    241a:	pop	{r4, r5, r6, pc}
        i2c.write16(addr,CHIP_LINREG_CTRL, 0x006C);  // VDDA & VDDIO both over 3.1V
    241c:	movs	r3, #108	; 0x6c
    241e:	movs	r2, #38	; 0x26
    2420:	movs	r1, #10
    2422:	ldr	r0, [pc, #252]	; (2520 <adc_enable()+0x18c>)
    2424:	bl	2344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_REF_CTRL, 0x01F2); // VAG=1.575, normal ramp, +12.5% bias current
    2428:	mov.w	r3, #498	; 0x1f2
    242c:	movs	r2, #40	; 0x28
    242e:	movs	r1, #10
    2430:	ldr	r0, [pc, #236]	; (2520 <adc_enable()+0x18c>)
    2432:	bl	2344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_LINE_OUT_CTRL, 0x0F22); // LO_VAGCNTRL=1.65V, OUT_CURRENT=0.54mA
    2436:	movw	r3, #3874	; 0xf22
    243a:	movs	r2, #44	; 0x2c
    243c:	movs	r1, #10
    243e:	ldr	r0, [pc, #224]	; (2520 <adc_enable()+0x18c>)
    2440:	bl	2344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_SHORT_CTRL, 0x4446);  // allow up to 125mA
    2444:	movw	r3, #17478	; 0x4446
    2448:	movs	r2, #60	; 0x3c
    244a:	movs	r1, #10
    244c:	ldr	r0, [pc, #208]	; (2520 <adc_enable()+0x18c>)
    244e:	bl	2344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_ANA_CTRL, 0x0137);  // enable zero cross detectors
    2452:	movw	r3, #311	; 0x137
    2456:	movs	r2, #36	; 0x24
    2458:	movs	r1, #10
    245a:	ldr	r0, [pc, #196]	; (2520 <adc_enable()+0x18c>)
    245c:	bl	2344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
            i2c.write16(addr,CHIP_PLL_CTRL, (int_divisor << 11) | frac_divisor);		
            i2c.write16(addr,CHIP_ANA_POWER, 0x40FF | (1<<10) | (1<<8) ); // power up: lineout, hp, adc, dac, PLL_POWERUP, VCOAMP_POWERUP
        } 
        else 
        {   //SGTL is I2S Slave
            i2c.write16(addr,CHIP_ANA_POWER, 0x40FF); // power up: lineout, hp, adc, dac
    2460:	movw	r3, #16639	; 0x40ff
    2464:	movs	r2, #48	; 0x30
    2466:	movs	r1, #10
    2468:	ldr	r0, [pc, #180]	; (2520 <adc_enable()+0x18c>)
    246a:	bl	2344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        }

        i2c.write16(addr,CHIP_DIG_POWER, 0x0073); // power up all digital stuff
    246e:	movs	r3, #115	; 0x73
    2470:	movs	r2, #2
    2472:	movs	r1, #10
    2474:	ldr	r0, [pc, #168]	; (2520 <adc_enable()+0x18c>)
    2476:	bl	2344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        delay(400);
    247a:	mov.w	r0, #400	; 0x190
    247e:	bl	950c <delay>
        i2c.write16(addr,CHIP_LINE_OUT_VOL, 0x1D1D); // default approx 1.3 volts peak-to-peak
    2482:	movw	r3, #7453	; 0x1d1d
    2486:	movs	r2, #46	; 0x2e
    2488:	movs	r1, #10
    248a:	ldr	r0, [pc, #148]	; (2520 <adc_enable()+0x18c>)
    248c:	bl	2344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        }
        else 
        {   //SGTL is I2S Slave
            int fs_mode=IFR;
            if(fs_mode>3) fs_mode = 3;  // 256*Fs fs_mode = 0:32 kHz; 1:44.1 kHz; 2:48 kHz; 3:96 kHz 
            i2c.write16(addr,CHIP_CLK_CTRL, fs_mode<<2); 
    2490:	movs	r3, #12
    2492:	movs	r2, #4
    2494:	movs	r1, #10
    2496:	ldr	r0, [pc, #136]	; (2520 <adc_enable()+0x18c>)
    2498:	bl	2344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
            i2c.write16(addr,CHIP_I2S_CTRL,0); // SCLK=64*Fs, 32bit, I2S format
    249c:	movs	r3, #0
    249e:	movs	r2, #6
    24a0:	movs	r1, #10
    24a2:	ldr	r0, [pc, #124]	; (2520 <adc_enable()+0x18c>)
    24a4:	bl	2344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        }

        // default signal routing is ok?
        i2c.write16(addr,CHIP_SSS_CTRL, 0x0010); // ADC->I2S, I2S->DAC
    24a8:	movs	r2, #10
    24aa:	mov	r1, r2
    24ac:	movs	r3, #16
    24ae:	ldr	r0, [pc, #112]	; (2520 <adc_enable()+0x18c>)
    24b0:	bl	2344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_ADCDAC_CTRL, 0x0000); // disable dac mute
    24b4:	movs	r3, #0
    24b6:	movs	r2, #14
    24b8:	movs	r1, #10
    24ba:	ldr	r0, [pc, #100]	; (2520 <adc_enable()+0x18c>)
    24bc:	bl	2344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_DAC_VOL, 0x3C3C); // digital gain, 0dB
    24c0:	movw	r3, #15420	; 0x3c3c
    24c4:	movs	r2, #16
    24c6:	movs	r1, #10
    24c8:	ldr	r0, [pc, #84]	; (2520 <adc_enable()+0x18c>)
    24ca:	bl	2344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_ANA_HP_CTRL, 0x7F7F); // set volume (lowest level)
    24ce:	movw	r3, #32639	; 0x7f7f
    24d2:	movs	r2, #34	; 0x22
    24d4:	movs	r1, #10
    24d6:	ldr	r0, [pc, #72]	; (2520 <adc_enable()+0x18c>)
    24d8:	bl	2344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_ANA_CTRL, 0x0036);  // enable zero cross detectors
    24dc:	movs	r3, #54	; 0x36
    24de:	movs	r2, #36	; 0x24
    24e0:	movs	r1, #10
    24e2:	ldr	r0, [pc, #60]	; (2520 <adc_enable()+0x18c>)
    24e4:	bl	2344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        uint16_t ana_ctrl=0x0036;

        return i2c.write16(addr,0x002A, 0x0173) // mic preamp gain = +40dB
    24e8:	movw	r3, #371	; 0x173
    24ec:	movs	r2, #42	; 0x2a
    24ee:	movs	r1, #10
    24f0:	ldr	r0, [pc, #44]	; (2520 <adc_enable()+0x18c>)
    24f2:	bl	2344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
                && i2c.write16(addr,0x0020, 0x088)     // input gain +12dB (is this enough?)
                && i2c.write16(addr,0x0024, ana_ctrl & ~(1<<2)); // enable mic
    24f6:	cmp	r0, #0
    24f8:	beq.n	2418 <adc_enable()+0x84>
        i2c.write16(addr,CHIP_ANA_HP_CTRL, 0x7F7F); // set volume (lowest level)
        i2c.write16(addr,CHIP_ANA_CTRL, 0x0036);  // enable zero cross detectors
        uint16_t ana_ctrl=0x0036;

        return i2c.write16(addr,0x002A, 0x0173) // mic preamp gain = +40dB
                && i2c.write16(addr,0x0020, 0x088)     // input gain +12dB (is this enough?)
    24fa:	movs	r3, #136	; 0x88
    24fc:	movs	r2, #32
    24fe:	movs	r1, #10
    2500:	ldr	r0, [pc, #28]	; (2520 <adc_enable()+0x18c>)
    2502:	bl	2344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
    2506:	cmp	r0, #0
    2508:	beq.n	2418 <adc_enable()+0x84>
                && i2c.write16(addr,0x0024, ana_ctrl & ~(1<<2)); // enable mic
    250a:	movs	r3, #50	; 0x32
    250c:	movs	r2, #36	; 0x24
    250e:	movs	r1, #10
    2510:	ldr	r0, [pc, #12]	; (2520 <adc_enable()+0x18c>)
    2512:	bl	2344 <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
    2516:	adds	r0, #0
    2518:	it	ne
    251a:	movne	r0, #1
    }
    251c:	pop	{r4, r5, r6, pc}
    251e:	nop
    2520:	.word	0x2001c9e4
    2524:	.word	0x000128d1
    2528:	.word	0x1fff136c

0000252c <_GLOBAL__sub_I_gain>:
#include "config.h"
#include "adc.h"

int gain=0;
uint32_t fsamps[] = FREQS;
uint32_t fsamp = fsamps[IFR];
    252c:	ldr	r3, [pc, #16]	; (2540 <_GLOBAL__sub_I_gain+0x14>)
class i2c_class
{ TwoWire *wire;
    public:

    i2c_class(TwoWire *wire) 
    {   this->wire = wire;
    252e:	ldr	r0, [pc, #20]	; (2544 <_GLOBAL__sub_I_gain+0x18>)
    2530:	ldr	r2, [r3, #12]
    2532:	ldr	r3, [pc, #20]	; (2548 <_GLOBAL__sub_I_gain+0x1c>)
    2534:	str	r2, [r3, #0]
    2536:	ldr	r3, [pc, #20]	; (254c <_GLOBAL__sub_I_gain+0x20>)
    2538:	str	r0, [r3, #0]
        wire->begin();
    253a:	b.w	2624 <TwoWire::begin()>
    253e:	nop
    2540:	.word	0x1fff0f48
    2544:	.word	0x1fff10a4
    2548:	.word	0x2001c9e0
    254c:	.word	0x2001c9e4

00002550 <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    2550:	ldrb.w	r2, [r0, #161]	; 0xa1
    2554:	ldrb.w	r0, [r0, #160]	; 0xa0
	}
    2558:	subs	r0, r2, r0
    255a:	bx	lr

0000255c <TwoWire::read()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    255c:	ldrb.w	r3, [r0, #160]	; 0xa0
    2560:	ldrb.w	r2, [r0, #161]	; 0xa1
    2564:	cmp	r2, r3
		return rxBuffer[rxBufferIndex++];
    2566:	itttt	hi
    2568:	addhi	r2, r3, #1
    256a:	addhi	r3, r3, r0
    256c:	strbhi.w	r2, [r0, #160]	; 0xa0
    2570:	ldrbhi	r0, [r3, #24]
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2572:	it	ls
    2574:	movls.w	r0, #4294967295
		return rxBuffer[rxBufferIndex++];
	}
    2578:	bx	lr

0000257a <TwoWire::peek()>:
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    257a:	ldrb.w	r3, [r0, #160]	; 0xa0
    257e:	ldrb.w	r2, [r0, #161]	; 0xa1
    2582:	cmp	r2, r3
		return rxBuffer[rxBufferIndex];
    2584:	itte	hi
    2586:	addhi	r3, r3, r0
    2588:	ldrbhi	r0, [r3, #24]
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    258a:	movls.w	r0, #4294967295
		return rxBuffer[rxBufferIndex];
	}
    258e:	bx	lr

00002590 <TwoWire::flush()>:
	virtual void flush(void) {
    2590:	bx	lr

00002592 <TwoWire::write(unsigned char)>:
//  I2C0_C2      // I2C Control Register 2
//  I2C0_FLT     // I2C Programmable Input Glitch Filter register

size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
    2592:	ldrh.w	r3, [r0, #302]	; 0x12e
    2596:	cbz	r3, 25a4 <TwoWire::write(unsigned char)+0x12>
		if (txBufferLength >= BUFFER_LENGTH+1) {
    2598:	ldrb.w	r3, [r0, #301]	; 0x12d
    259c:	cmp	r3, #136	; 0x88
    259e:	bls.n	25a8 <TwoWire::write(unsigned char)+0x16>
	// format warnings are too pedantic - disable until newer toolchain offers better...
	// https://forum.pjrc.com/threads/62473?p=256873&viewfull=1#post256873
	int printf(const char *format, ...) /*__attribute__ ((format (printf, 2, 3)))*/;
	int printf(const __FlashStringHelper *format, ...);
  protected:
	void setWriteError(int err = 1) { write_error = err; }
    25a0:	movs	r3, #1
    25a2:	strb	r3, [r0, #4]
			setWriteError();
			return 0;
    25a4:	movs	r0, #0
    25a6:	bx	lr
		}
		txBuffer[txBufferLength++] = data;
    25a8:	adds	r2, r3, #1
    25aa:	add	r3, r0
    25ac:	strb.w	r2, [r0, #301]	; 0x12d
    25b0:	strb.w	r1, [r3, #163]	; 0xa3
		return 1;
    25b4:	movs	r0, #1
    25b6:	bx	lr

000025b8 <TwoWire::write(unsigned char const*, unsigned int)>:
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    25b8:	push	{r3, r4, r5, lr}
    25ba:	mov	r4, r0
	if (transmitting || slave_mode) {
    25bc:	ldrh.w	r0, [r0, #302]	; 0x12e
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    25c0:	mov	r5, r2
	if (transmitting || slave_mode) {
    25c2:	cbz	r0, 25ee <TwoWire::write(unsigned char const*, unsigned int)+0x36>
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
    25c4:	ldrb.w	r3, [r4, #301]	; 0x12d
    25c8:	rsb	r2, r3, #137	; 0x89
		if (quantity > avail) {
    25cc:	cmp	r5, r2
    25ce:	ittt	hi
    25d0:	movhi	r0, #1
    25d2:	movhi	r5, r2
    25d4:	strbhi	r0, [r4, #4]
			quantity = avail;
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
    25d6:	add.w	r0, r4, #163	; 0xa3
    25da:	add	r0, r3
    25dc:	mov	r2, r5
    25de:	bl	8ed0 <memcpy>
		txBufferLength += quantity;
    25e2:	ldrb.w	r3, [r4, #301]	; 0x12d
    25e6:	add	r3, r5
    25e8:	strb.w	r3, [r4, #301]	; 0x12d
    25ec:	mov	r0, r5
		return quantity;
	}
	return 0;
}
    25ee:	pop	{r3, r4, r5, pc}

000025f0 <TwoWire::setClock(unsigned long)>:
	//pinMode(4, OUTPUT);
}

void TwoWire::setClock(uint32_t frequency)
{
	if (!(hardware.clock_gate_register & hardware.clock_gate_mask)) return;
    25f0:	ldr	r3, [r0, #20]
    25f2:	ldr	r2, [r3, #0]
    25f4:	ldr	r3, [r3, #4]
    25f6:	ldr	r2, [r2, #0]
    25f8:	tst	r2, r3
    25fa:	beq.n	261a <TwoWire::setClock(unsigned long)+0x2a>
	} else {
		port().F = I2C_F_DIV56; // 0.96 MHz
	}
	port().FLT = 4;
#elif F_BUS == 48000000
	if (frequency < 400000) {
    25fc:	ldr	r3, [pc, #28]	; (261c <TwoWire::setClock(unsigned long)+0x2c>)
    25fe:	cmp	r1, r3
    2600:	ldr	r3, [r0, #16]
    2602:	bhi.n	2608 <TwoWire::setClock(unsigned long)+0x18>
		port().F = 0x27;	// 100 kHz
    2604:	movs	r2, #39	; 0x27
    2606:	b.n	2612 <TwoWire::setClock(unsigned long)+0x22>
	} else if (frequency < 1000000) {
    2608:	ldr	r2, [pc, #20]	; (2620 <TwoWire::setClock(unsigned long)+0x30>)
    260a:	cmp	r1, r2
		port().F = 0x1A; // 400 kHz
    260c:	ite	ls
    260e:	movls	r2, #26
	} else {
		port().F = 0x0D; // 1 MHz
    2610:	movhi	r2, #13
    2612:	strb	r2, [r3, #1]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    2614:	ldr	r3, [r0, #16]
	}
	port().FLT = 4;
    2616:	movs	r2, #4
    2618:	strb	r2, [r3, #6]
    261a:	bx	lr
    261c:	.word	0x00061a7f
    2620:	.word	0x000f423f

00002624 <TwoWire::begin()>:

void sda_rising_isr0(void);
void sda_rising_isr1(void);

void TwoWire::begin(void)
{
    2624:	push	{r4, r5, r6, lr}
	//serial_begin(BAUD2DIV(115200));
	//serial_print("\nWire Begin\n");

	rxBufferIndex = 0;
    2626:	movs	r3, #0
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    2628:	ldr	r5, [r0, #20]
void TwoWire::begin(void)
{
	//serial_begin(BAUD2DIV(115200));
	//serial_print("\nWire Begin\n");

	rxBufferIndex = 0;
    262a:	strb.w	r3, [r0, #160]	; 0xa0
	rxBufferLength = 0;
    262e:	strb.w	r3, [r0, #161]	; 0xa1
	txBufferIndex = 0;
    2632:	strb.w	r3, [r0, #300]	; 0x12c
	txBufferLength = 0;
    2636:	strb.w	r3, [r0, #301]	; 0x12d
	transmitting = 0;
    263a:	strb.w	r3, [r0, #302]	; 0x12e
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
    263e:	strb.w	r3, [r0, #303]	; 0x12f
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    2642:	ldr	r1, [r5, #0]
    2644:	ldr	r2, [r5, #4]
    2646:	ldr	r6, [r1, #0]
	rxBufferIndex = 0;
	rxBufferLength = 0;
	txBufferIndex = 0;
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
    2648:	str.w	r3, [r0, #308]	; 0x134
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    264c:	orrs	r2, r6
	rxBufferLength = 0;
	txBufferIndex = 0;
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
    264e:	str.w	r3, [r0, #312]	; 0x138
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    2652:	str	r2, [r1, #0]
    2654:	ldr	r2, [r0, #16]
	port().C1 = 0;
    2656:	strb	r3, [r2, #2]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    2658:	ldr	r6, [r0, #20]
    265a:	ldrb.w	r1, [r0, #305]	; 0x131
    265e:	ldr	r2, [pc, #72]	; (26a8 <TwoWire::begin()+0x84>)
    2660:	add	r1, r6
    2662:	ldrb	r5, [r1, #8]
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    2664:	ldrb	r3, [r1, #13]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    2666:	add.w	r5, r2, r5, lsl #3
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    266a:	lsls	r3, r3, #8
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    266c:	ldr	r5, [r5, #4]
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    266e:	and.w	r3, r3, #1792	; 0x700
    2672:	orr.w	r3, r3, #100	; 0x64
    2676:	str	r3, [r5, #0]
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    2678:	ldrb.w	r3, [r0, #306]	; 0x132
    267c:	add	r3, r6
    267e:	ldrb	r1, [r3, #18]
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    2680:	ldrb	r3, [r3, #23]
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    2682:	add.w	r2, r2, r1, lsl #3
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    2686:	lsls	r3, r3, #8
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    2688:	ldr	r2, [r2, #4]
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	setClock(100000);
    268a:	ldr	r1, [pc, #32]	; (26ac <TwoWire::begin()+0x88>)
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    268c:	and.w	r3, r3, #1792	; 0x700
    2690:	orr.w	r3, r3, #100	; 0x64
    2694:	str	r3, [r2, #0]
	setClock(100000);
    2696:	bl	25f0 <TwoWire::setClock(unsigned long)>
    269a:	ldr	r3, [r0, #16]
	port().C2 = I2C_C2_HDRS;
    269c:	movs	r2, #32
    269e:	strb	r2, [r3, #5]
    26a0:	ldr	r3, [r0, #16]
	port().C1 = I2C_C1_IICEN;
    26a2:	movs	r2, #128	; 0x80
    26a4:	strb	r2, [r3, #2]
    26a6:	pop	{r4, r5, r6, pc}
    26a8:	.word	0x00012e4c
    26ac:	.word	0x000186a0

000026b0 <TwoWire::isr()>:
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    26b0:	push	{r3, r4, r5, lr}
    26b2:	ldr	r2, [r0, #16]
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
    26b4:	ldrb	r5, [r2, #3]
    26b6:	uxtb	r5, r5
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    26b8:	tst.w	r5, #16
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    26bc:	mov	r4, r0
    26be:	and.w	r3, r5, #64	; 0x40
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    26c2:	bne.n	26cc <TwoWire::isr()+0x1c>


		}
		if (!(status & I2C_S_IAAS)) return;
	}
	if (status & I2C_S_IAAS) {
    26c4:	and.w	r1, r3, #255	; 0xff
    26c8:	cbnz	r3, 26d6 <TwoWire::isr()+0x26>
    26ca:	b.n	2724 <TwoWire::isr()+0x74>

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
		// Arbitration Lost
		port().S = I2C_S_ARBL;
    26cc:	movs	r1, #16
    26ce:	strb	r1, [r2, #3]
		if (receiving && rxBufferLength > 0) {
			// TODO: does this detect the STOP condition in slave receive mode?


		}
		if (!(status & I2C_S_IAAS)) return;
    26d0:	cmp	r3, #0
    26d2:	bne.n	26c4 <TwoWire::isr()+0x14>
    26d4:	pop	{r3, r4, r5, pc}
	}
	if (status & I2C_S_IAAS) {
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
    26d6:	and.w	r5, r5, #4
    26da:	and.w	r2, r5, #255	; 0xff
    26de:	ldr	r3, [pc, #224]	; (27c0 <TwoWire::isr()+0x110>)
    26e0:	cbz	r5, 2718 <TwoWire::isr()+0x68>
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    26e2:	movs	r2, #0
    26e4:	strb	r2, [r3, #0]
			txBufferLength = 0;
			if (user_onRequest != NULL) {
    26e6:	ldr.w	r3, [r4, #308]	; 0x134
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
			txBufferLength = 0;
    26ea:	strb.w	r2, [r4, #301]	; 0x12d
			if (user_onRequest != NULL) {
    26ee:	cbz	r3, 26f2 <TwoWire::isr()+0x42>
				user_onRequest();
    26f0:	blx	r3
			}
			if (txBufferLength == 0) {
    26f2:	ldrb.w	r3, [r4, #301]	; 0x12d
    26f6:	cbnz	r3, 2702 <TwoWire::isr()+0x52>
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    26f8:	movs	r2, #1
    26fa:	strb.w	r2, [r4, #301]	; 0x12d
				txBuffer[0] = 0;
    26fe:	strb.w	r3, [r4, #163]	; 0xa3
    2702:	ldr	r3, [r4, #16]
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    2704:	movs	r2, #208	; 0xd0
    2706:	strb	r2, [r3, #2]
    2708:	ldr	r3, [r4, #16]
			port().D = txBuffer[0];
    270a:	ldrb.w	r2, [r4, #163]	; 0xa3
    270e:	strb	r2, [r3, #4]
			txBufferIndex = 1;
    2710:	movs	r3, #1
    2712:	strb.w	r3, [r4, #300]	; 0x12c
    2716:	b.n	27b6 <TwoWire::isr()+0x106>
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    2718:	movs	r1, #1
    271a:	strb	r1, [r3, #0]
			rxBufferLength = 0;
    271c:	strb.w	r2, [r4, #161]	; 0xa1
    2720:	ldr	r3, [r4, #16]
    2722:	b.n	2782 <TwoWire::isr()+0xd2>
    2724:	ldr	r2, [r4, #16]
		}
		port().S = I2C_S_IICIF;
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
    2726:	ldrb	r3, [r2, #6]
    2728:	uxtb	r3, r3
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
    272a:	and.w	r0, r3, #96	; 0x60
    272e:	cmp	r0, #96	; 0x60
    2730:	bne.n	2748 <TwoWire::isr()+0x98>
		port().FLT = c1 & ~I2C_FLT_STOPIE;
    2732:	and.w	r3, r3, #223	; 0xdf
    2736:	strb	r3, [r2, #6]
		if (user_onReceive != NULL) {
    2738:	ldr.w	r3, [r4, #312]	; 0x138
    273c:	cbz	r3, 2748 <TwoWire::isr()+0x98>
			rxBufferIndex = 0;
    273e:	strb.w	r1, [r4, #160]	; 0xa0
			user_onReceive(rxBufferLength);
    2742:	ldrb.w	r0, [r4, #161]	; 0xa1
    2746:	blx	r3
    2748:	ldr	r3, [r4, #16]
		}
	}
	#endif
	c1 = port().C1;
    274a:	ldrb	r2, [r3, #2]
	if (c1 & I2C_C1_TX) {
    274c:	and.w	r2, r2, #16
    2750:	and.w	r1, r2, #255	; 0xff
    2754:	cbz	r2, 278c <TwoWire::isr()+0xdc>
		// Continue Slave Transmit
		//serial_print("t");
		if ((status & I2C_S_RXAK) == 0) {
    2756:	ands.w	r5, r5, #1
    275a:	bne.n	2782 <TwoWire::isr()+0xd2>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
    275c:	ldrb.w	r2, [r4, #300]	; 0x12c
    2760:	ldrb.w	r1, [r4, #301]	; 0x12d
    2764:	cmp	r1, r2
				port().D = txBuffer[txBufferIndex++];
    2766:	itttt	hi
    2768:	addhi	r1, r2, #1
    276a:	addhi	r2, r2, r4
    276c:	strbhi.w	r1, [r4, #300]	; 0x12c
    2770:	ldrbhi.w	r2, [r2, #163]	; 0xa3
    2774:	ite	hi
    2776:	strbhi	r2, [r3, #4]
			} else {
				port().D = 0;
    2778:	strbls	r5, [r3, #4]
    277a:	ldr	r3, [r4, #16]
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    277c:	movs	r2, #208	; 0xd0
    277e:	strb	r2, [r3, #2]
    2780:	b.n	27b6 <TwoWire::isr()+0x106>
		} else {
			//serial_print("*");
			// Master did not ACK previous byte
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    2782:	movs	r2, #192	; 0xc0
    2784:	strb	r2, [r3, #2]
    2786:	ldr	r3, [r4, #16]
			data = port().D;
    2788:	ldrb	r3, [r3, #4]
    278a:	b.n	27b6 <TwoWire::isr()+0x106>
		}
	} else {
		// Continue Slave Receive
		irqcount = 0;
    278c:	strb.w	r1, [r4, #304]	; 0x130
		#ifdef WIRE_HAS_STOP_INTERRUPT
		port().FLT |= I2C_FLT_STOPIE;
    2790:	ldrb	r2, [r3, #6]
    2792:	orr.w	r2, r2, #32
    2796:	strb	r2, [r3, #6]
    2798:	ldr	r3, [r4, #16]
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    279a:	ldrb	r2, [r3, #4]
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    279c:	ldrb.w	r3, [r4, #161]	; 0xa1
    27a0:	cmp	r3, #135	; 0x87
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    27a2:	uxtb	r2, r2
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    27a4:	bhi.n	27b6 <TwoWire::isr()+0x106>
    27a6:	ldr	r1, [pc, #24]	; (27c0 <TwoWire::isr()+0x110>)
    27a8:	ldrb	r1, [r1, #0]
    27aa:	cbz	r1, 27b6 <TwoWire::isr()+0x106>
			rxBuffer[rxBufferLength++] = data;
    27ac:	adds	r1, r3, #1
    27ae:	add	r3, r4
    27b0:	strb.w	r1, [r4, #161]	; 0xa1
    27b4:	strb	r2, [r3, #24]
    27b6:	ldr	r3, [r4, #16]
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    27b8:	movs	r2, #2
    27ba:	strb	r2, [r3, #3]
    27bc:	pop	{r3, r4, r5, pc}
    27be:	nop
    27c0:	.word	0x2001c9e8

000027c4 <TwoWire::wait_idle()>:
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    27c4:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    27c8:	ldr	r5, [pc, #208]	; (289c <L_1220_delayMicroseconds+0x20>)
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    27ca:	ldr	r7, [pc, #212]	; (28a0 <L_1220_delayMicroseconds+0x24>)
    27cc:	ldr	r3, [r5, #0]
    27ce:	str	r3, [sp, #0]
	return ret;
    27d0:	ldr.w	r8, [sp]
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    27d4:	mov	r4, r0
	bool reset=false;
    27d6:	movs	r1, #0
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    27d8:	movs	r6, #160	; 0xa0
    27da:	ldr	r2, [r4, #16]
	uint8_t i2c_status(void) {
		return port().S;
    27dc:	ldrb	r3, [r2, #3]
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    27de:	lsls	r3, r3, #26
    27e0:	bpl.n	2894 <L_1220_delayMicroseconds+0x18>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    27e2:	ldr	r3, [r5, #0]
    27e4:	str	r3, [sp, #4]
	return ret;
    27e6:	ldr	r3, [sp, #4]
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
    27e8:	rsb	r3, r8, r3
#if 1
		if (waited > 15 && !reset) {
    27ec:	cmp	r3, #15
    27ee:	bls.n	27da <TwoWire::wait_idle()+0x16>
    27f0:	cmp	r1, #0
    27f2:	bne.n	2884 <L_1220_delayMicroseconds+0x8>
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
    27f4:	ldr	r2, [r4, #20]
    27f6:	ldrb.w	r3, [r4, #305]	; 0x131
    27fa:	add	r3, r2
			pinMode(sda_pin, INPUT_DISABLE);
    27fc:	movs	r1, #5
    27fe:	ldrb	r0, [r3, #8]
    2800:	bl	946c <pinMode>
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    2804:	ldr	r2, [r4, #20]
    2806:	ldrb.w	r3, [r4, #305]	; 0x131
    280a:	add	r3, r2
			pinMode(scl_pin, OUTPUT);
    280c:	movs	r1, #1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    280e:	ldrb.w	sl, [r3, #18]
			pinMode(scl_pin, OUTPUT);
    2812:	mov	r0, sl
    2814:	bl	946c <pinMode>
    2818:	mov.w	r9, #9
			for (int i=0; i < 9; i++) {
				digitalWrite(scl_pin, LOW);
    281c:	movs	r1, #0
    281e:	mov	r0, sl
    2820:	bl	942c <digitalWrite>
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    2824:	mov	r3, r6

00002826 <L_1161_delayMicroseconds>:
    2826:	subs	r3, #1
    2828:	bne.n	2826 <L_1161_delayMicroseconds>
				delayMicroseconds(5);
				digitalWrite(scl_pin, HIGH);
    282a:	movs	r1, #1
    282c:	mov	r0, sl
    282e:	bl	942c <digitalWrite>
    2832:	mov	r3, r6

00002834 <L_1175_delayMicroseconds>:
    2834:	subs	r3, #1
    2836:	bne.n	2834 <L_1175_delayMicroseconds>
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
			pinMode(scl_pin, OUTPUT);
			for (int i=0; i < 9; i++) {
    2838:	subs.w	r9, r9, #1
    283c:	bne.n	281c <TwoWire::wait_idle()+0x58>
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    283e:	ldr	r0, [r4, #20]
    2840:	ldrb.w	r2, [r4, #305]	; 0x131
    2844:	add	r2, r0
    2846:	ldrb	r1, [r2, #8]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    2848:	ldrb	r3, [r2, #13]
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    284a:	add.w	r1, r7, r1, lsl #3
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    284e:	lsls	r3, r3, #8
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    2850:	ldr	r1, [r1, #4]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    2852:	and.w	r3, r3, #1792	; 0x700
    2856:	orr.w	r3, r3, #100	; 0x64
    285a:	str	r3, [r1, #0]
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    285c:	ldrb.w	r3, [r4, #306]	; 0x132
    2860:	add	r3, r0
    2862:	ldrb	r2, [r3, #18]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    2864:	ldrb	r3, [r3, #23]
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    2866:	add.w	r2, r7, r2, lsl #3
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    286a:	lsls	r3, r3, #8
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    286c:	ldr	r2, [r2, #4]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    286e:	and.w	r3, r3, #1792	; 0x700
    2872:	orr.w	r3, r3, #100	; 0x64
    2876:	str	r3, [r2, #0]
    2878:	mov.w	r3, #320	; 0x140

0000287c <L_1220_delayMicroseconds>:
    287c:	subs	r3, #1
    287e:	bne.n	287c <L_1220_delayMicroseconds>
	while (i2c_status() & I2C_S_BUSY) {
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
    2880:	movs	r1, #1
    2882:	b.n	27da <TwoWire::wait_idle()+0x16>
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			delayMicroseconds(10);
			continue;
		}
#endif
		if (waited > 16) {
    2884:	cmp	r3, #16
    2886:	beq.n	27da <TwoWire::wait_idle()+0x16>
			// bus stuck busy too long
			port().C1 = 0;
    2888:	movs	r0, #0
    288a:	strb	r0, [r2, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    288c:	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    288e:	movs	r2, #128	; 0x80
    2890:	strb	r2, [r3, #2]
			//Serial.println("abort");
			//return 4; // timeout waiting for bus
			return false;
    2892:	b.n	2896 <L_1220_delayMicroseconds+0x1a>
		}
	}
	return true;
    2894:	movs	r0, #1
}
    2896:	add	sp, #8
    2898:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    289c:	.word	0x2001cf20
    28a0:	.word	0x00012e4c

000028a4 <TwoWire::endTransmission(unsigned char)>:

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    28a4:	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    28a8:	ldr	r3, [r0, #16]
	uint8_t i, status, ret=0;
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    28aa:	movs	r2, #18
    28ac:	strb	r2, [r3, #3]
    28ae:	ldr	r2, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    28b0:	ldrb	r3, [r2, #2]
    28b2:	and.w	r3, r3, #32
	}
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    28b6:	mov	r4, r0
    28b8:	mov	r5, r1
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    28ba:	and.w	r6, r3, #255	; 0xff
    28be:	cbz	r3, 28c6 <TwoWire::endTransmission(unsigned char)+0x22>
		// we are already the bus master, so send a repeated start
		//Serial.print("rstart:");
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    28c0:	movs	r3, #180	; 0xb4
    28c2:	strb	r3, [r2, #2]
    28c4:	b.n	28d8 <TwoWire::endTransmission(unsigned char)+0x34>
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    28c6:	bl	27c4 <TwoWire::wait_idle()>
    28ca:	cmp	r0, #0
    28cc:	beq.n	2990 <TwoWire::endTransmission(unsigned char)+0xec>
    28ce:	ldr	r3, [r4, #16]
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    28d0:	strb.w	r6, [r4, #303]	; 0x12f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    28d4:	movs	r2, #176	; 0xb0
    28d6:	strb	r2, [r3, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    28d8:	ldr	r3, [pc, #188]	; (2998 <TwoWire::endTransmission(unsigned char)+0xf4>)
    28da:	ldr	r1, [r4, #16]
    28dc:	ldr	r2, [r3, #0]
    28de:	str	r2, [sp, #0]
	return ret;
    28e0:	ldr	r6, [sp, #0]
	uint8_t i2c_status(void) {
		return port().S;
    28e2:	ldrb	r2, [r1, #3]
	}
	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    28e4:	and.w	r2, r2, #32
    28e8:	and.w	r0, r2, #255	; 0xff
    28ec:	cmp	r2, #0
    28ee:	beq.n	297c <TwoWire::endTransmission(unsigned char)+0xd8>
    28f0:	movs	r0, #0
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    28f2:	movs	r7, #2
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
    28f4:	ldrb.w	r2, [r4, #301]	; 0x12d
    28f8:	uxtb	r1, r0
    28fa:	cmp	r2, r1
    28fc:	bls.n	296a <TwoWire::endTransmission(unsigned char)+0xc6>
		port().D = txBuffer[i];
    28fe:	adds	r6, r4, r1
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    2900:	ldr	r2, [r4, #16]
    2902:	ldrb.w	r6, [r6, #163]	; 0xa3
    2906:	strb	r6, [r2, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2908:	ldr	r2, [r3, #0]
    290a:	str	r2, [sp, #12]
	return ret;
    290c:	ldr.w	r8, [sp, #12]
    2910:	ldr	r6, [r4, #16]
	uint8_t i2c_status(void) {
		return port().S;
    2912:	ldrb	r2, [r6, #3]
    2914:	uxtb	r2, r2
		//Serial.write('^');
		wait_begin = millis();
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
    2916:	and.w	lr, r2, #2
    291a:	and.w	ip, lr, #255	; 0xff
    291e:	cmp.w	lr, #0
    2922:	bne.n	293c <TwoWire::endTransmission(unsigned char)+0x98>
			if (!(status & I2C_S_BUSY)) break;
    2924:	lsls	r2, r2, #26
    2926:	bpl.n	293c <TwoWire::endTransmission(unsigned char)+0x98>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2928:	ldr	r2, [r3, #0]
    292a:	str	r2, [sp, #8]
	return ret;
    292c:	ldr	r2, [sp, #8]
			if (millis() - wait_begin > 5) {
    292e:	rsb	r2, r8, r2
    2932:	cmp	r2, #5
    2934:	bls.n	2912 <TwoWire::endTransmission(unsigned char)+0x6e>
				port().C1 = 0;
    2936:	strb.w	ip, [r6, #2]
    293a:	b.n	298a <TwoWire::endTransmission(unsigned char)+0xe6>
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    293c:	strb	r7, [r6, #3]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    293e:	ldr	r6, [r4, #16]
	uint8_t i2c_status(void) {
		return port().S;
    2940:	ldrb	r2, [r6, #3]
    2942:	uxtb	r2, r2
		//Serial.write('$');
		status = i2c_status();
		if ((status & I2C_S_ARBL)) {
    2944:	tst.w	r2, #16
    2948:	bne.n	2950 <TwoWire::endTransmission(unsigned char)+0xac>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("endTransmission err4\n");
			ret = 4; // 4:other error
			break;
		}
		if (!(status & I2C_S_BUSY)) {
    294a:	tst.w	r2, #32
    294e:	bne.n	2958 <TwoWire::endTransmission(unsigned char)+0xb4>
			// suddenly lost control of the bus!
			port().C1 = I2C_C1_IICEN;
    2950:	movs	r3, #128	; 0x80
    2952:	strb	r3, [r6, #2]
			//Serial.printf("endTransmission err5\n");
			ret = 4; // 4:other error
    2954:	movs	r0, #4
    2956:	b.n	296c <TwoWire::endTransmission(unsigned char)+0xc8>
			break;
		}
		if (status & I2C_S_RXAK) {
    2958:	lsls	r2, r2, #31
    295a:	add.w	r0, r0, #1
    295e:	bpl.n	28f4 <TwoWire::endTransmission(unsigned char)+0x50>
			if (i == 0) {
				//Serial.printf("endTransmission err6\n");
				ret = 2; // 2:received NACK on transmit of address
			} else {
				//Serial.printf("endTransmission err7\n");
				ret = 3; // 3:received NACK on transmit of data 
    2960:	cmp	r1, #0
    2962:	ite	eq
    2964:	moveq	r0, #2
    2966:	movne	r0, #3
    2968:	b.n	296e <TwoWire::endTransmission(unsigned char)+0xca>
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
	uint8_t i, status, ret=0;
    296a:	movs	r0, #0
			}
			sendStop = 1;
			break;
		}
	}
	if (sendStop) {
    296c:	cbz	r5, 2974 <TwoWire::endTransmission(unsigned char)+0xd0>
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    296e:	ldr	r3, [r4, #16]
		// send the stop condition
		port().C1 = I2C_C1_IICEN;
    2970:	movs	r2, #128	; 0x80
    2972:	strb	r2, [r3, #2]
		// TODO: do we wait for this somehow?
	}
	transmitting = 0;
    2974:	movs	r3, #0
    2976:	strb.w	r3, [r4, #302]	; 0x12e
    297a:	b.n	2992 <TwoWire::endTransmission(unsigned char)+0xee>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    297c:	ldr	r2, [r3, #0]
    297e:	str	r2, [sp, #4]
	return ret;
    2980:	ldr	r2, [sp, #4]
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		//Serial.write('*') ;
		if (millis() - wait_begin > 4) {
    2982:	subs	r2, r2, r6
    2984:	cmp	r2, #4
    2986:	bls.n	28e2 <TwoWire::endTransmission(unsigned char)+0x3e>
			port().C1 = 0;
    2988:	strb	r0, [r1, #2]
    298a:	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    298c:	movs	r2, #128	; 0x80
    298e:	strb	r2, [r3, #2]
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
    2990:	movs	r0, #4
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    2992:	add	sp, #16
    2994:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2998:	.word	0x2001cf20

0000299c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>:


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    299c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    29a0:	mov	r9, r3
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
	uint32_t wait_begin;

	rxBufferIndex = 0;
    29a2:	movs	r3, #0
    29a4:	strb.w	r3, [r0, #160]	; 0xa0
	rxBufferLength = 0;
    29a8:	strb.w	r3, [r0, #161]	; 0xa1
    29ac:	ldr	r3, [r0, #16]
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    29ae:	mov	r7, r2

	rxBufferIndex = 0;
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    29b0:	movs	r2, #18
    29b2:	strb	r2, [r3, #3]
    29b4:	ldr	r2, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    29b6:	ldrb	r3, [r2, #2]
    29b8:	and.w	r3, r3, #32
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    29bc:	sub	sp, #36	; 0x24
    29be:	mov	r5, r0
    29c0:	mov	r8, r1
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    29c2:	and.w	r4, r3, #255	; 0xff
    29c6:	cbz	r3, 29ce <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x32>
		// we are already the bus master, so send a repeated start
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    29c8:	movs	r3, #180	; 0xb4
    29ca:	strb	r3, [r2, #2]
    29cc:	b.n	29e2 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x46>
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    29ce:	bl	27c4 <TwoWire::wait_idle()>
    29d2:	cmp	r0, #0
    29d4:	beq.w	2b4a <L_2399_delayMicroseconds+0x3e>
    29d8:	ldr	r3, [r5, #16]
			//Serial.printf("requestFrom err1\n");
			return 0; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    29da:	strb.w	r4, [r5, #303]	; 0x12f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    29de:	movs	r2, #176	; 0xb0
    29e0:	strb	r2, [r3, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    29e2:	ldr	r6, [pc, #368]	; (2b54 <L_2399_delayMicroseconds+0x48>)
    29e4:	ldr	r2, [r5, #16]
    29e6:	ldr	r3, [r6, #0]
    29e8:	str	r3, [sp, #0]
	return ret;
    29ea:	ldr	r1, [sp, #0]
	uint8_t i2c_status(void) {
		return port().S;
    29ec:	ldrb	r3, [r2, #3]
    29ee:	and.w	r3, r3, #32

	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    29f2:	and.w	r4, r3, #255	; 0xff
    29f6:	cbnz	r3, 2a06 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x6a>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    29f8:	ldr	r3, [r6, #0]
    29fa:	str	r3, [sp, #4]
	return ret;
    29fc:	ldr	r3, [sp, #4]
		if (millis() - wait_begin > 4) {
    29fe:	subs	r3, r3, r1
    2a00:	cmp	r3, #4
    2a02:	bls.n	29ec <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x50>
    2a04:	b.n	2a36 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x9a>
			//Serial.printf("requestFrom err2\n");
			return 0; // error generating start condition
		}
	}
	// send the address
	port().D = (address << 1) | 1;
    2a06:	mov.w	r8, r8, lsl #1
    2a0a:	orr.w	r8, r8, #1
    2a0e:	uxtb.w	r8, r8
    2a12:	strb.w	r8, [r2, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2a16:	ldr	r3, [r6, #0]
    2a18:	str	r3, [sp, #8]
	return ret;
    2a1a:	ldr	r1, [sp, #8]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    2a1c:	ldr	r2, [r5, #16]
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    2a1e:	ldrb	r3, [r2, #3]
    2a20:	and.w	r3, r3, #2
    2a24:	and.w	r4, r3, #255	; 0xff
    2a28:	cbnz	r3, 2a3e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xa2>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2a2a:	ldr	r3, [r6, #0]
    2a2c:	str	r3, [sp, #12]
	return ret;
    2a2e:	ldr	r3, [sp, #12]
		if (millis() - wait_begin > 5) {
    2a30:	subs	r3, r3, r1
    2a32:	cmp	r3, #5
    2a34:	bls.n	2a1e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x82>
			port().C1 = 0;
    2a36:	strb	r4, [r2, #2]
    2a38:	ldr	r3, [r5, #16]
			port().C1 = I2C_C1_IICEN;
    2a3a:	movs	r2, #128	; 0x80
    2a3c:	b.n	2a60 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xc4>
			//Serial.printf("requestFrom err3\n");
			return 0; // clock stretch too long (during address)
		}
	}
	port().S = I2C_S_IICIF;
    2a3e:	movs	r3, #2
    2a40:	strb	r3, [r2, #3]
    2a42:	ldr	r3, [r5, #16]
	uint8_t i2c_status(void) {
		return port().S;
    2a44:	ldrb	r0, [r3, #3]
	status = i2c_status();
	if ((status & I2C_S_RXAK) || (status & I2C_S_ARBL)) {
    2a46:	ands.w	r4, r0, #17
    2a4a:	beq.n	2a54 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xb8>
		// the slave device did not acknowledge
		// or we lost bus arbitration to another master
		port().C1 = I2C_C1_IICEN;
    2a4c:	movs	r2, #128	; 0x80
    2a4e:	strb	r2, [r3, #2]
		//Serial.printf("requestFrom err4\n");
		return 0;
    2a50:	movs	r4, #0
    2a52:	b.n	2b4a <L_2399_delayMicroseconds+0x3e>
	}
	if (length == 0) {
    2a54:	cbnz	r7, 2a64 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xc8>
		// TODO: does anybody really do zero length reads?
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
    2a56:	cmp.w	r9, #0
    2a5a:	ite	ne
    2a5c:	movne	r2, #128	; 0x80
    2a5e:	moveq	r2, #160	; 0xa0
    2a60:	strb	r2, [r3, #2]
		//Serial.printf("requestFrom err5\n");
		return 0;
    2a62:	b.n	2b4a <L_2399_delayMicroseconds+0x3e>
	} else if (length == 1) {
    2a64:	cmp	r7, #1
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    2a66:	ite	eq
    2a68:	moveq	r2, #168	; 0xa8
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
    2a6a:	movne	r2, #160	; 0xa0
    2a6c:	strb	r2, [r3, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    2a6e:	ldr	r3, [r5, #16]
	}
	tmp = port().D; // initiate the first receive
    2a70:	ldrb	r3, [r3, #4]


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
    2a72:	movs	r0, #0
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    2a74:	movs	r1, #2
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    2a76:	movs	r4, #168	; 0xa8
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
	}
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
    2a78:	cmp	r7, #1
    2a7a:	ldr	r2, [r5, #16]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2a7c:	ldr	r3, [r6, #0]
    2a7e:	beq.n	2ad8 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x13c>
    2a80:	str	r3, [sp, #16]
	return ret;
    2a82:	ldr.w	ip, [sp, #16]
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
    2a86:	ldrb	r3, [r2, #3]
    2a88:	and.w	r3, r3, #2
    2a8c:	and.w	lr, r3, #255	; 0xff
    2a90:	cbnz	r3, 2aa6 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x10a>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2a92:	ldr	r3, [r6, #0]
    2a94:	str	r3, [sp, #20]
	return ret;
    2a96:	ldr	r3, [sp, #20]
			if (millis() - wait_begin > 5) {
    2a98:	rsb	r3, ip, r3
    2a9c:	cmp	r3, #5
    2a9e:	bls.n	2a86 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xea>
				port().C1 = 0;
    2aa0:	strb.w	lr, [r2, #2]
    2aa4:	b.n	2b3e <L_2399_delayMicroseconds+0x32>
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    2aa6:	strb	r1, [r2, #3]
    2aa8:	ldr	r2, [r5, #16]
		status = port().S;
    2aaa:	ldrb	r3, [r2, #3]
    2aac:	uxtb	r3, r3
		if ((status & I2C_S_ARBL)) {
    2aae:	tst.w	r3, #16
    2ab2:	bne.n	2b48 <L_2399_delayMicroseconds+0x3c>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7a\n");
			return count;
		}
		if (!(status & I2C_S_BUSY)) {
    2ab4:	lsls	r3, r3, #26
    2ab6:	bpl.n	2b48 <L_2399_delayMicroseconds+0x3c>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
    2ab8:	subs	r7, #1
    2aba:	uxtb	r7, r7
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    2abc:	cmp	r7, #1
    2abe:	it	eq
    2ac0:	strbeq	r4, [r2, #2]
    2ac2:	ldr	r3, [r5, #16]
		if (count < BUFFER_LENGTH) {
    2ac4:	cmp	r0, #135	; 0x87
			rxBuffer[count++] = port().D;
    2ac6:	itttt	ls
    2ac8:	addls	r2, r0, #1
    2aca:	addls	r0, r0, r5
    2acc:	ldrbls	r3, [r3, #4]
    2ace:	strbls	r3, [r0, #24]
		} else {
			tmp = port().D;
    2ad0:	ite	hi
    2ad2:	ldrbhi	r3, [r3, #4]
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
		if (count < BUFFER_LENGTH) {
			rxBuffer[count++] = port().D;
    2ad4:	uxtbls	r0, r2
    2ad6:	b.n	2a78 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xdc>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2ad8:	str	r3, [sp, #24]
	return ret;
    2ada:	ldr	r4, [sp, #24]
		} else {
			tmp = port().D;
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    2adc:	ldrb	r3, [r2, #3]
    2ade:	and.w	r3, r3, #2
    2ae2:	and.w	r1, r3, #255	; 0xff
    2ae6:	cbnz	r3, 2af8 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x15c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2ae8:	ldr	r3, [r6, #0]
    2aea:	str	r3, [sp, #28]
	return ret;
    2aec:	ldr	r3, [sp, #28]
		if (millis() - wait_begin > 5) {
    2aee:	subs	r3, r3, r4
    2af0:	cmp	r3, #5
    2af2:	bls.n	2adc <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x140>
			port().C1 = 0;
    2af4:	strb	r1, [r2, #2]
    2af6:	b.n	2b3e <L_2399_delayMicroseconds+0x32>
			rxBufferLength = count;
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
		}
	}
	port().S = I2C_S_IICIF;
    2af8:	movs	r3, #2
    2afa:	strb	r3, [r2, #3]
    2afc:	ldr	r2, [r5, #16]
	status = port().S;
    2afe:	ldrb	r3, [r2, #3]
    2b00:	uxtb	r3, r3
	if ((status & I2C_S_ARBL)) {
    2b02:	lsls	r1, r3, #27
    2b04:	bpl.n	2b1c <L_2399_delayMicroseconds+0x10>
		// we lost bus arbitration to another master
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//digitalWriteFast(13, HIGH);
		port().S = I2C_S_ARBL;
    2b06:	movs	r3, #16
    2b08:	strb	r3, [r2, #3]
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    2b0a:	movs	r3, #160	; 0xa0

00002b0c <L_2399_delayMicroseconds>:
    2b0c:	subs	r3, #1
    2b0e:	bne.n	2b0c <L_2399_delayMicroseconds>
    2b10:	ldr	r2, [r5, #16]
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
    2b12:	ldrb	r3, [r2, #2]
    2b14:	and.w	r3, r3, #247	; 0xf7
    2b18:	strb	r3, [r2, #2]
    2b1a:	b.n	2b48 <L_2399_delayMicroseconds+0x3c>
		//Serial.printf("requestFrom err9a\n");
		return count;
	}
	if (!(status & I2C_S_BUSY)) {
    2b1c:	lsls	r3, r3, #26
    2b1e:	bpl.n	2b48 <L_2399_delayMicroseconds+0x3c>
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    2b20:	movs	r3, #176	; 0xb0
    2b22:	strb	r3, [r2, #2]
	if (count < BUFFER_LENGTH) {
    2b24:	cmp	r0, #135	; 0x87
    2b26:	ldr	r3, [r5, #16]
		rxBuffer[count++] = port().D;
    2b28:	itttt	ls
    2b2a:	addls	r2, r0, #1
    2b2c:	addls	r0, r0, r5
    2b2e:	ldrbls	r3, [r3, #4]
    2b30:	strbls	r3, [r0, #24]
	} else {
		tmp = port().D;
    2b32:	ite	hi
    2b34:	ldrbhi	r3, [r3, #4]
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
	if (count < BUFFER_LENGTH) {
		rxBuffer[count++] = port().D;
    2b36:	uxtbls	r0, r2
#if F_CPU > 120000000
	__asm__("nop");
	__asm__("nop");
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
    2b38:	cmp.w	r9, #0
    2b3c:	beq.n	2b44 <L_2399_delayMicroseconds+0x38>
    2b3e:	ldr	r3, [r5, #16]
    2b40:	movs	r2, #128	; 0x80
    2b42:	strb	r2, [r3, #2]
	rxBufferLength = count;
    2b44:	strb.w	r0, [r5, #161]	; 0xa1
    2b48:	mov	r4, r0
	return count;
}
    2b4a:	mov	r0, r4
    2b4c:	add	sp, #36	; 0x24
    2b4e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    2b52:	nop
    2b54:	.word	0x2001cf20

00002b58 <i2c0_isr>:
#define MAKE_CONST(x) (__builtin_constant_p(x) ? (x) : (x))

#ifdef WIRE_IMPLEMENT_WIRE
constexpr uintptr_t i2c0_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C0));
TwoWire Wire(i2c0_addr, TwoWire::i2c0_hardware);
void i2c0_isr(void) { Wire.isr(); }
    2b58:	ldr	r0, [pc, #4]	; (2b60 <i2c0_isr+0x8>)
    2b5a:	b.w	26b0 <TwoWire::isr()>
    2b5e:	nop
    2b60:	.word	0x1fff10a4

00002b64 <i2c1_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE1
constexpr uintptr_t i2c1_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C1));
TwoWire Wire1(i2c1_addr, TwoWire::i2c1_hardware);
void i2c1_isr(void) { Wire1.isr(); }
    2b64:	ldr	r0, [pc, #4]	; (2b6c <i2c1_isr+0x8>)
    2b66:	b.w	26b0 <TwoWire::isr()>
    2b6a:	nop
    2b6c:	.word	0x1fff11e0

00002b70 <i2c2_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE2
constexpr uintptr_t i2c2_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C2));
TwoWire Wire2(i2c2_addr, TwoWire::i2c2_hardware);
void i2c2_isr(void) { Wire2.isr(); }
    2b70:	ldr	r0, [pc, #4]	; (2b78 <i2c2_isr+0x8>)
    2b72:	b.w	26b0 <TwoWire::isr()>
    2b76:	nop
    2b78:	.word	0x1fff0f68

00002b7c <DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]>:

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    2b7c:	ldrh	r3, [r0, #30]
    2b7e:	lsls	r3, r3, #16
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    2b80:	itttt	mi
    2b82:	ldrhmi	r3, [r0, #30]
    2b84:	ubfxmi	r1, r1, #0, #9
    2b88:	andmi.w	r3, r3, #65024	; 0xfe00
    2b8c:	orrmi	r1, r3
#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
    2b8e:	it	pl
    2b90:	ubfxpl	r1, r1, #0, #15
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    2b94:	strh	r1, [r0, #30]
	}
	tcd->CITER = tcd->BITER; 
    2b96:	ldrh	r3, [r0, #30]
    2b98:	uxth	r3, r3
    2b9a:	strh	r3, [r0, #22]
    2b9c:	bx	lr
    2b9e:	Address 0x00002b9e is out of bounds.


00002ba0 <SPIClass::begin()>:
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
	const SPI_Hardware_t & hardware() { return *(const SPI_Hardware_t *)hardware_addr; }
    2ba0:	ldr	r3, [r0, #4]

void SPIClass::begin()
{
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    2ba2:	ldr	r1, [r3, #0]
    2ba4:	ldr	r2, [r3, #4]
SPIClass SPI2((uintptr_t)&KINETISK_SPI2, (uintptr_t)&SPIClass::spi2_hardware);
#endif


void SPIClass::begin()
{
    2ba6:	push	{r4, lr}
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    2ba8:	ldr	r4, [r1, #0]
    2baa:	orrs	r2, r4
    2bac:	str	r2, [r1, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    2bae:	ldr	r2, [r0, #0]
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
    2bb0:	ldr	r1, [pc, #84]	; (2c08 <SPIClass::begin()+0x68>)
    2bb2:	str	r1, [r2, #0]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    2bb4:	ldr	r1, [pc, #84]	; (2c0c <SPIClass::begin()+0x6c>)
    2bb6:	str	r1, [r2, #12]
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    2bb8:	add.w	r1, r1, #1073741824	; 0x40000000
    2bbc:	str	r1, [r2, #16]
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
    2bbe:	ldr	r1, [pc, #80]	; (2c10 <SPIClass::begin()+0x70>)
    2bc0:	str	r1, [r2, #0]
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2bc2:	ldrb	r1, [r0, #9]
    2bc4:	ldr	r2, [pc, #76]	; (2c14 <SPIClass::begin()+0x74>)
    2bc6:	adds	r4, r3, r1
	*reg = hardware().mosi_mux[mosi_pin_index];
    2bc8:	adds	r1, #12
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2bca:	ldrb.w	r4, [r4, #44]	; 0x2c
	*reg = hardware().mosi_mux[mosi_pin_index];
    2bce:	ldr.w	r1, [r3, r1, lsl #2]
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2bd2:	add.w	r4, r2, r4, lsl #3
    2bd6:	ldr	r4, [r4, #4]
	*reg = hardware().mosi_mux[mosi_pin_index];
    2bd8:	str	r1, [r4, #0]
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2bda:	ldrb	r1, [r0, #8]
    2bdc:	adds	r4, r3, r1
	*reg= hardware().miso_mux[miso_pin_index];
    2bde:	add.w	r1, r3, r1, lsl #2
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2be2:	ldrb	r4, [r4, #24]
	*reg= hardware().miso_mux[miso_pin_index];
    2be4:	ldr	r1, [r1, #28]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2be6:	add.w	r4, r2, r4, lsl #3
    2bea:	ldr	r4, [r4, #4]
	*reg= hardware().miso_mux[miso_pin_index];
    2bec:	str	r1, [r4, #0]
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2bee:	ldrb	r1, [r0, #10]
    2bf0:	adds	r0, r3, r1
	*reg = hardware().sck_mux[sck_pin_index];
    2bf2:	add.w	r3, r3, r1, lsl #2
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2bf6:	ldrb.w	r0, [r0, #64]	; 0x40
	*reg = hardware().sck_mux[sck_pin_index];
    2bfa:	ldr	r3, [r3, #68]	; 0x44
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2bfc:	add.w	r2, r2, r0, lsl #3
    2c00:	ldr	r2, [r2, #4]
	*reg = hardware().sck_mux[sck_pin_index];
    2c02:	str	r3, [r2, #0]
    2c04:	pop	{r4, pc}
    2c06:	nop
    2c08:	.word	0x001f4001
    2c0c:	.word	0x38001001
    2c10:	.word	0x801f0000
    2c14:	.word	0x00012e4c

00002c18 <SPIClass::setMOSI(unsigned char)>:
	return 0;
}

void SPIClass::setMOSI(uint8_t pin)
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2c18:	ldr	r3, [r0, #4]
    2c1a:	ldr	r2, [pc, #140]	; (2ca8 <SPIClass::setMOSI(unsigned char)+0x90>)
    2c1c:	cmp	r2, r3
	}
	return 0;
}

void SPIClass::setMOSI(uint8_t pin)
{
    2c1e:	push	{r4, r5, r6, lr}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2c20:	bne.n	2c54 <SPIClass::setMOSI(unsigned char)+0x3c>
		pinout = newpinout;
#endif
	}
	inline void setMOSI_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 11) pinout &= ~3;
    2c22:	cmp	r1, #11
    2c24:	bne.n	2c30 <SPIClass::setMOSI(unsigned char)+0x18>
    2c26:	ldr	r4, [pc, #132]	; (2cac <SPIClass::setMOSI(unsigned char)+0x94>)
    2c28:	ldrb	r2, [r4, #0]
    2c2a:	bic.w	r2, r2, #3
    2c2e:	b.n	2c52 <SPIClass::setMOSI(unsigned char)+0x3a>
		if (pin == 7)  pinout = (pinout & ~0x3) | 1;
    2c30:	cmp	r1, #7
    2c32:	bne.n	2c42 <SPIClass::setMOSI(unsigned char)+0x2a>
    2c34:	ldr	r4, [pc, #116]	; (2cac <SPIClass::setMOSI(unsigned char)+0x94>)
    2c36:	ldrb	r2, [r4, #0]
    2c38:	bic.w	r2, r2, #3
    2c3c:	orr.w	r2, r2, #1
    2c40:	b.n	2c52 <SPIClass::setMOSI(unsigned char)+0x3a>
		if (pin == 28) pinout = (pinout & ~0x3) | 2;
    2c42:	cmp	r1, #28
    2c44:	bne.n	2c54 <SPIClass::setMOSI(unsigned char)+0x3c>
    2c46:	ldr	r4, [pc, #100]	; (2cac <SPIClass::setMOSI(unsigned char)+0x94>)
    2c48:	ldrb	r2, [r4, #0]
    2c4a:	bic.w	r2, r2, #3
    2c4e:	orr.w	r2, r2, #2
    2c52:	strb	r2, [r4, #0]
		SPCR.setMOSI_soft(pin);
	}
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
    2c54:	ldrb	r2, [r0, #9]
    2c56:	add	r2, r3
    2c58:	ldrb.w	r4, [r2, #44]	; 0x2c
    2c5c:	cmp	r1, r4
    2c5e:	beq.n	2ca4 <SPIClass::setMOSI(unsigned char)+0x8c>
    2c60:	add.w	r5, r3, #43	; 0x2b
    2c64:	movs	r2, #0
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
    2c66:	ldrb.w	r6, [r5, #1]!
    2c6a:	cmp	r6, r1
    2c6c:	bne.n	2c9e <SPIClass::setMOSI(unsigned char)+0x86>
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    2c6e:	ldr	r1, [r3, #0]
    2c70:	ldr	r5, [r1, #0]
    2c72:	ldr	r1, [r3, #4]
    2c74:	tst	r5, r1
    2c76:	beq.n	2c9a <SPIClass::setMOSI(unsigned char)+0x82>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2c78:	ldr	r1, [pc, #52]	; (2cb0 <SPIClass::setMOSI(unsigned char)+0x98>)
    2c7a:	add.w	r4, r1, r4, lsl #3
					*reg = 0;
    2c7e:	movs	r5, #0
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2c80:	ldr	r4, [r4, #4]
					*reg = 0;
    2c82:	str	r5, [r4, #0]
					reg = portConfigRegister(hardware().mosi_pin[i]);
    2c84:	adds	r4, r3, r2
    2c86:	ldrb.w	r4, [r4, #44]	; 0x2c
    2c8a:	add.w	r1, r1, r4, lsl #3
					*reg = hardware().mosi_mux[i];
    2c8e:	add.w	r4, r2, #12
			if  (pin == hardware().mosi_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().mosi_pin[i]);
    2c92:	ldr	r1, [r1, #4]
					*reg = hardware().mosi_mux[i];
    2c94:	ldr.w	r3, [r3, r4, lsl #2]
    2c98:	str	r3, [r1, #0]
				}	
				mosi_pin_index = i;
    2c9a:	strb	r2, [r0, #9]
				return;
    2c9c:	pop	{r4, r5, r6, pc}
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setMOSI_soft(pin);
	}
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
    2c9e:	adds	r2, #1
    2ca0:	cmp	r2, #4
    2ca2:	bne.n	2c66 <SPIClass::setMOSI(unsigned char)+0x4e>
    2ca4:	pop	{r4, r5, r6, pc}
    2ca6:	nop
    2ca8:	.word	0x0001299c
    2cac:	.word	0x2001d019
    2cb0:	.word	0x00012e4c

00002cb4 <SPIClass::setMISO(unsigned char)>:
	}
}

void SPIClass::setMISO(uint8_t pin)
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2cb4:	ldr	r3, [r0, #4]
    2cb6:	ldr	r2, [pc, #132]	; (2d3c <SPIClass::setMISO(unsigned char)+0x88>)
    2cb8:	cmp	r2, r3
		}
	}
}

void SPIClass::setMISO(uint8_t pin)
{
    2cba:	push	{r4, r5, r6, lr}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2cbc:	bne.n	2cf0 <SPIClass::setMISO(unsigned char)+0x3c>
		pinout = newpinout;
#endif
	}
	inline void setMISO_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 12) pinout &= ~0xc;
    2cbe:	cmp	r1, #12
    2cc0:	bne.n	2ccc <SPIClass::setMISO(unsigned char)+0x18>
    2cc2:	ldr	r4, [pc, #124]	; (2d40 <SPIClass::setMISO(unsigned char)+0x8c>)
    2cc4:	ldrb	r2, [r4, #0]
    2cc6:	bic.w	r2, r2, #12
    2cca:	b.n	2cee <SPIClass::setMISO(unsigned char)+0x3a>
		if (pin == 8)  pinout = (pinout & ~0xc) | 4;
    2ccc:	cmp	r1, #8
    2cce:	bne.n	2cde <SPIClass::setMISO(unsigned char)+0x2a>
    2cd0:	ldr	r4, [pc, #108]	; (2d40 <SPIClass::setMISO(unsigned char)+0x8c>)
    2cd2:	ldrb	r2, [r4, #0]
    2cd4:	bic.w	r2, r2, #12
    2cd8:	orr.w	r2, r2, #4
    2cdc:	b.n	2cee <SPIClass::setMISO(unsigned char)+0x3a>
		if (pin == 39) pinout = (pinout & ~0xc) | 8;
    2cde:	cmp	r1, #39	; 0x27
    2ce0:	bne.n	2cf0 <SPIClass::setMISO(unsigned char)+0x3c>
    2ce2:	ldr	r4, [pc, #92]	; (2d40 <SPIClass::setMISO(unsigned char)+0x8c>)
    2ce4:	ldrb	r2, [r4, #0]
    2ce6:	bic.w	r2, r2, #12
    2cea:	orr.w	r2, r2, #8
    2cee:	strb	r2, [r4, #0]
		SPCR.setMISO_soft(pin);
	}
	if (pin != hardware().miso_pin[miso_pin_index]) {
    2cf0:	ldrb	r2, [r0, #8]
    2cf2:	add	r2, r3
    2cf4:	ldrb	r4, [r2, #24]
    2cf6:	cmp	r1, r4
    2cf8:	beq.n	2d3a <SPIClass::setMISO(unsigned char)+0x86>
    2cfa:	add.w	r5, r3, #23
    2cfe:	movs	r2, #0
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
			if  (pin == hardware().miso_pin[i]) {
    2d00:	ldrb.w	r6, [r5, #1]!
    2d04:	cmp	r6, r1
    2d06:	bne.n	2d34 <SPIClass::setMISO(unsigned char)+0x80>
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    2d08:	ldr	r1, [r3, #0]
    2d0a:	ldr	r5, [r1, #0]
    2d0c:	ldr	r1, [r3, #4]
    2d0e:	tst	r5, r1
    2d10:	beq.n	2d30 <SPIClass::setMISO(unsigned char)+0x7c>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2d12:	ldr	r1, [pc, #48]	; (2d44 <SPIClass::setMISO(unsigned char)+0x90>)
    2d14:	add.w	r4, r1, r4, lsl #3
					*reg = 0;
    2d18:	movs	r5, #0
	if (pin != hardware().miso_pin[miso_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2d1a:	ldr	r4, [r4, #4]
					*reg = 0;
    2d1c:	str	r5, [r4, #0]
					reg = portConfigRegister(hardware().miso_pin[i]);
    2d1e:	adds	r4, r3, r2
					*reg = hardware().miso_mux[i];
    2d20:	add.w	r3, r3, r2, lsl #2
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().miso_pin[i]);
    2d24:	ldrb	r4, [r4, #24]
					*reg = hardware().miso_mux[i];
    2d26:	ldr	r3, [r3, #28]
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().miso_pin[i]);
    2d28:	add.w	r1, r1, r4, lsl #3
    2d2c:	ldr	r1, [r1, #4]
					*reg = hardware().miso_mux[i];
    2d2e:	str	r3, [r1, #0]
				}	
				miso_pin_index = i;
    2d30:	strb	r2, [r0, #8]
				return;
    2d32:	pop	{r4, r5, r6, pc}
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setMISO_soft(pin);
	}
	if (pin != hardware().miso_pin[miso_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
    2d34:	adds	r2, #1
    2d36:	cmp	r2, #4
    2d38:	bne.n	2d00 <SPIClass::setMISO(unsigned char)+0x4c>
    2d3a:	pop	{r4, r5, r6, pc}
    2d3c:	.word	0x0001299c
    2d40:	.word	0x2001d019
    2d44:	.word	0x00012e4c

00002d48 <SPIClass::setSCK(unsigned char)>:
	}
}

void SPIClass::setSCK(uint8_t pin)
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2d48:	ldr	r3, [r0, #4]
    2d4a:	ldr	r2, [pc, #148]	; (2de0 <SPIClass::setSCK(unsigned char)+0x98>)
    2d4c:	cmp	r2, r3
		}
	}
}

void SPIClass::setSCK(uint8_t pin)
{
    2d4e:	push	{r4, r5, lr}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2d50:	bne.n	2d84 <SPIClass::setSCK(unsigned char)+0x3c>
		pinout = newpinout;
#endif
	}
	inline void setSCK_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 13) pinout &= ~0x30;
    2d52:	cmp	r1, #13
    2d54:	bne.n	2d60 <SPIClass::setSCK(unsigned char)+0x18>
    2d56:	ldr	r4, [pc, #140]	; (2de4 <SPIClass::setSCK(unsigned char)+0x9c>)
    2d58:	ldrb	r2, [r4, #0]
    2d5a:	bic.w	r2, r2, #48	; 0x30
    2d5e:	b.n	2d82 <SPIClass::setSCK(unsigned char)+0x3a>
		if (pin == 14) pinout = (pinout & ~0x30) | 0x10;
    2d60:	cmp	r1, #14
    2d62:	bne.n	2d72 <SPIClass::setSCK(unsigned char)+0x2a>
    2d64:	ldr	r4, [pc, #124]	; (2de4 <SPIClass::setSCK(unsigned char)+0x9c>)
    2d66:	ldrb	r2, [r4, #0]
    2d68:	bic.w	r2, r2, #48	; 0x30
    2d6c:	orr.w	r2, r2, #16
    2d70:	b.n	2d82 <SPIClass::setSCK(unsigned char)+0x3a>
		if (pin == 27) pinout = (pinout & ~0x30) | 0x20;
    2d72:	cmp	r1, #27
    2d74:	bne.n	2d84 <SPIClass::setSCK(unsigned char)+0x3c>
    2d76:	ldr	r4, [pc, #108]	; (2de4 <SPIClass::setSCK(unsigned char)+0x9c>)
    2d78:	ldrb	r2, [r4, #0]
    2d7a:	bic.w	r2, r2, #48	; 0x30
    2d7e:	orr.w	r2, r2, #32
    2d82:	strb	r2, [r4, #0]
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
    2d84:	ldrb	r2, [r0, #10]
    2d86:	add	r2, r3
    2d88:	ldrb.w	r4, [r2, #64]	; 0x40
    2d8c:	cmp	r1, r4
    2d8e:	beq.n	2dde <SPIClass::setSCK(unsigned char)+0x96>
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
    2d90:	ldrb.w	r2, [r3, #64]	; 0x40
    2d94:	cmp	r2, r1
    2d96:	beq.n	2dac <SPIClass::setSCK(unsigned char)+0x64>
    2d98:	ldrb.w	r2, [r3, #65]	; 0x41
    2d9c:	cmp	r2, r1
    2d9e:	beq.n	2db0 <SPIClass::setSCK(unsigned char)+0x68>
    2da0:	ldrb.w	r2, [r3, #66]	; 0x42
    2da4:	cmp	r2, r1
    2da6:	bne.n	2dde <SPIClass::setSCK(unsigned char)+0x96>
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
    2da8:	movs	r2, #2
    2daa:	b.n	2db2 <SPIClass::setSCK(unsigned char)+0x6a>
			if  (pin == hardware().sck_pin[i]) {
    2dac:	movs	r2, #0
    2dae:	b.n	2db2 <SPIClass::setSCK(unsigned char)+0x6a>
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
    2db0:	movs	r2, #1
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    2db2:	ldr	r1, [r3, #0]
    2db4:	ldr	r5, [r1, #0]
    2db6:	ldr	r1, [r3, #4]
    2db8:	tst	r5, r1
    2dba:	beq.n	2ddc <SPIClass::setSCK(unsigned char)+0x94>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2dbc:	ldr	r1, [pc, #40]	; (2de8 <SPIClass::setSCK(unsigned char)+0xa0>)
    2dbe:	add.w	r4, r1, r4, lsl #3
					*reg = 0;
    2dc2:	movs	r5, #0
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2dc4:	ldr	r4, [r4, #4]
					*reg = 0;
    2dc6:	str	r5, [r4, #0]
					reg = portConfigRegister(hardware().sck_pin[i]);
    2dc8:	adds	r4, r3, r2
					*reg = hardware().sck_mux[i];
    2dca:	add.w	r3, r3, r2, lsl #2
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().sck_pin[i]);
    2dce:	ldrb.w	r4, [r4, #64]	; 0x40
					*reg = hardware().sck_mux[i];
    2dd2:	ldr	r3, [r3, #68]	; 0x44
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().sck_pin[i]);
    2dd4:	add.w	r1, r1, r4, lsl #3
    2dd8:	ldr	r1, [r1, #4]
					*reg = hardware().sck_mux[i];
    2dda:	str	r3, [r1, #0]
				}	
				sck_pin_index = i;
    2ddc:	strb	r2, [r0, #10]
    2dde:	pop	{r4, r5, pc}
    2de0:	.word	0x0001299c
    2de4:	.word	0x2001d019
    2de8:	.word	0x00012e4c

00002dec <SPIClass::transfer(void const*, void*, unsigned int)>:
		}
	}
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{
    2dec:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	if (count == 0) return;
    2df0:	cmp	r3, #0
    2df2:	beq.w	2fae <SPIClass::transfer(void const*, void*, unsigned int)+0x1c2>
    2df6:	ldr	r4, [r0, #0]
    2df8:	ldr	r6, [pc, #440]	; (2fb4 <SPIClass::transfer(void const*, void*, unsigned int)+0x1c8>)
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    2dfa:	ldr	r5, [r4, #12]
		const uint8_t *p_write = (const uint8_t *)buf;
		uint8_t *p_read = (uint8_t *)retbuf;
		size_t count_read = count;

		// Lets clear the reader queue
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);
    2dfc:	str	r6, [r4, #0]

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    2dfe:	tst.w	r5, #16777216	; 0x1000000
    2e02:	and.w	r5, r3, #1
    2e06:	bne.n	2ee4 <SPIClass::transfer(void const*, void*, unsigned int)+0xf8>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2e08:	cbz	r5, 2e30 <SPIClass::transfer(void const*, void*, unsigned int)+0x44>
		    if (p_write) {
    2e0a:	cbz	r1, 2e1e <SPIClass::transfer(void const*, void*, unsigned int)+0x32>
    2e0c:	adds	r5, r1, #1
    2e0e:	ldrb	r1, [r1, #0]
				if (count > 1)
    2e10:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2e12:	it	ne
    2e14:	orrne.w	r1, r1, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    2e18:	str	r1, [r4, #52]	; 0x34
    2e1a:	mov	r1, r5
    2e1c:	b.n	2e2c <SPIClass::transfer(void const*, void*, unsigned int)+0x40>
    2e1e:	ldrb.w	r5, [r0, #44]	; 0x2c
			} else {
				if (count > 1)
    2e22:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2e24:	it	ne
    2e26:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    2e2a:	str	r5, [r4, #52]	; 0x34
			}
			count--;
    2e2c:	subs	r6, r3, #1
    2e2e:	b.n	2e32 <SPIClass::transfer(void const*, void*, unsigned int)+0x46>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2e30:	mov	r6, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    2e32:	ldrb.w	r4, [r0, #44]	; 0x2c
    2e36:	orr.w	r4, r4, r4, lsl #8

		while (count > 0) {
    2e3a:	cmp	r6, #0
    2e3c:	beq.n	2ebc <SPIClass::transfer(void const*, void*, unsigned int)+0xd0>
			// Push out the next byte; 
		    if (p_write) {
    2e3e:	cbz	r1, 2e4e <SPIClass::transfer(void const*, void*, unsigned int)+0x62>
		    	w = (*p_write++) << 8;
    2e40:	mov	r5, r1
				w |= *p_write++;
    2e42:	ldrb	r1, [r1, #1]
	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;

		while (count > 0) {
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
    2e44:	ldrb.w	r4, [r5], #2
				w |= *p_write++;
    2e48:	orr.w	r4, r1, r4, lsl #8
    2e4c:	mov	r1, r5
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2e4e:	ldr	r5, [r0, #4]
    2e50:	ldr	r7, [r0, #0]
    2e52:	ldrb	r5, [r5, #8]
			if (count == 2)
    2e54:	cmp	r6, #2
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2e56:	add.w	r5, r5, #4294967295
    2e5a:	mov.w	r5, r5, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    2e5e:	ite	eq
    2e60:	orreq.w	lr, r4, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2e64:	orrne.w	lr, r4, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2e68:	uxth	r5, r5
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2e6a:	str.w	lr, [r7, #52]	; 0x34
			count -= 2; // how many bytes to output.
    2e6e:	subs	r6, #2
    2e70:	ldr.w	lr, [r0]
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    2e74:	ldr.w	r7, [lr, #44]	; 0x2c
				if (sr & 0xF0)  {
    2e78:	tst.w	r7, #240	; 0xf0
    2e7c:	beq.n	2ea8 <SPIClass::transfer(void const*, void*, unsigned int)+0xbc>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    2e7e:	tst.w	r3, #1
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    2e82:	ldr.w	ip, [lr, #56]	; 0x38
					if (count_read & 1) {
    2e86:	beq.n	2e94 <SPIClass::transfer(void const*, void*, unsigned int)+0xa8>
						if (p_read) {
    2e88:	cbz	r2, 2e90 <SPIClass::transfer(void const*, void*, unsigned int)+0xa4>
							*p_read++ = w;  // Read any pending RX bytes in
    2e8a:	strb.w	ip, [r2]
    2e8e:	adds	r2, #1
						} 
						count_read--;
    2e90:	subs	r3, #1
    2e92:	b.n	2ea8 <SPIClass::transfer(void const*, void*, unsigned int)+0xbc>
					} else {
						if (p_read) {
    2e94:	cbz	r2, 2ea6 <SPIClass::transfer(void const*, void*, unsigned int)+0xba>
							*p_read++ = w >> 8;
    2e96:	mov	lr, r2
    2e98:	mov.w	r8, ip, asr #8
    2e9c:	strb.w	r8, [lr], #2
							*p_read++ = (w & 0xff);
    2ea0:	strb.w	ip, [r2, #1]
    2ea4:	mov	r2, lr
						}
						count_read -= 2;
    2ea6:	subs	r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    2ea8:	and.w	r7, r7, #61440	; 0xf000
    2eac:	cmp	r7, r5
    2eae:	bhi.n	2e70 <SPIClass::transfer(void const*, void*, unsigned int)+0x84>
    2eb0:	b.n	2e3a <SPIClass::transfer(void const*, void*, unsigned int)+0x4e>
    2eb2:	ldr	r1, [r0, #0]

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
    2eb4:	ldr	r4, [r1, #44]	; 0x2c
			if (sr & 0xF0)  {
    2eb6:	tst.w	r4, #240	; 0xf0
    2eba:	bne.n	2ec2 <SPIClass::transfer(void const*, void*, unsigned int)+0xd6>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    2ebc:	cmp	r3, #0
    2ebe:	bne.n	2eb2 <SPIClass::transfer(void const*, void*, unsigned int)+0xc6>
    2ec0:	b.n	2fae <SPIClass::transfer(void const*, void*, unsigned int)+0x1c2>
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    2ec2:	ldr	r4, [r1, #56]	; 0x38
				if (count_read & 1) {
    2ec4:	lsls	r1, r3, #31
    2ec6:	bpl.n	2ed2 <SPIClass::transfer(void const*, void*, unsigned int)+0xe6>
					if (p_read)
    2ec8:	cbz	r2, 2ece <SPIClass::transfer(void const*, void*, unsigned int)+0xe2>
						*p_read++ = w;  // Read any pending RX bytes in
    2eca:	strb	r4, [r2, #0]
    2ecc:	adds	r2, #1
					count_read--;
    2ece:	subs	r3, #1
    2ed0:	b.n	2ebc <SPIClass::transfer(void const*, void*, unsigned int)+0xd0>
				} else {
					if (p_read) {
    2ed2:	cbz	r2, 2ee0 <SPIClass::transfer(void const*, void*, unsigned int)+0xf4>
						*p_read++ = w >> 8;
    2ed4:	mov	r1, r2
    2ed6:	asrs	r5, r4, #8
    2ed8:	strb.w	r5, [r1], #2
						*p_read++ = (w & 0xff);
    2edc:	strb	r4, [r2, #1]
    2ede:	mov	r2, r1
					}
					count_read -= 2;
    2ee0:	subs	r3, #2
    2ee2:	b.n	2ebc <SPIClass::transfer(void const*, void*, unsigned int)+0xd0>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2ee4:	cbz	r5, 2f0c <SPIClass::transfer(void const*, void*, unsigned int)+0x120>
		    if (p_write) {
    2ee6:	cbz	r1, 2efa <SPIClass::transfer(void const*, void*, unsigned int)+0x10e>
    2ee8:	adds	r5, r1, #1
    2eea:	ldrb	r1, [r1, #0]
				if (count > 1)
    2eec:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2eee:	it	ne
    2ef0:	orrne.w	r1, r1, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    2ef4:	str	r1, [r4, #52]	; 0x34
    2ef6:	mov	r1, r5
    2ef8:	b.n	2f08 <SPIClass::transfer(void const*, void*, unsigned int)+0x11c>
    2efa:	ldrb.w	r5, [r0, #44]	; 0x2c
			} else {
				if (count > 1)
    2efe:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2f00:	it	ne
    2f02:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    2f06:	str	r5, [r4, #52]	; 0x34
			}
			count--;
    2f08:	subs	r6, r3, #1
    2f0a:	b.n	2f0e <SPIClass::transfer(void const*, void*, unsigned int)+0x122>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2f0c:	mov	r6, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w = _transferWriteFill;
    2f0e:	ldrb.w	r7, [r0, #44]	; 0x2c

		while (count > 0) {
    2f12:	cmp	r6, #0
    2f14:	beq.n	2f86 <SPIClass::transfer(void const*, void*, unsigned int)+0x19a>
			// Push out the next byte; 
		    if (p_write) {
    2f16:	cbz	r1, 2f22 <SPIClass::transfer(void const*, void*, unsigned int)+0x136>
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
    2f18:	ldrb	r7, [r1, #1]
    2f1a:	ldrb	r4, [r1, #0]
    2f1c:	adds	r1, #2
    2f1e:	orr.w	r7, r4, r7, lsl #8
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2f22:	ldr	r4, [r0, #4]
    2f24:	ldr	r5, [r0, #0]
    2f26:	ldrb	r4, [r4, #8]
			if (count == 2)
    2f28:	cmp	r6, #2
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2f2a:	add.w	r4, r4, #4294967295
    2f2e:	mov.w	r4, r4, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    2f32:	ite	eq
    2f34:	orreq.w	lr, r7, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2f38:	orrne.w	lr, r7, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2f3c:	uxth	r4, r4
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2f3e:	str.w	lr, [r5, #52]	; 0x34
			count -= 2; // how many bytes to output.
    2f42:	subs	r6, #2
    2f44:	ldr	r5, [r0, #0]
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    2f46:	ldr.w	lr, [r5, #44]	; 0x2c
				if (sr & 0xF0)  {
    2f4a:	tst.w	lr, #240	; 0xf0
    2f4e:	beq.n	2f72 <SPIClass::transfer(void const*, void*, unsigned int)+0x186>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    2f50:	tst.w	r3, #1
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    2f54:	ldr	r5, [r5, #56]	; 0x38
					if (count_read & 1) {
    2f56:	beq.n	2f62 <SPIClass::transfer(void const*, void*, unsigned int)+0x176>
						if (p_read) {
    2f58:	cbz	r2, 2f5e <SPIClass::transfer(void const*, void*, unsigned int)+0x172>
							*p_read++ = w;  // Read any pending RX bytes in
    2f5a:	strb	r5, [r2, #0]
    2f5c:	adds	r2, #1
						} 
						count_read--;
    2f5e:	subs	r3, #1
    2f60:	b.n	2f72 <SPIClass::transfer(void const*, void*, unsigned int)+0x186>
					} else {
						if (p_read) {
    2f62:	cbz	r2, 2f70 <SPIClass::transfer(void const*, void*, unsigned int)+0x184>
							*p_read++ = (w & 0xff);
    2f64:	mov	ip, r2
    2f66:	strb.w	r5, [ip], #2
							*p_read++ = w >> 8;
    2f6a:	asrs	r5, r5, #8
    2f6c:	strb	r5, [r2, #1]
    2f6e:	mov	r2, ip
						}
						count_read -= 2;
    2f70:	subs	r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    2f72:	and.w	lr, lr, #61440	; 0xf000
    2f76:	cmp	lr, r4
    2f78:	bhi.n	2f44 <SPIClass::transfer(void const*, void*, unsigned int)+0x158>
    2f7a:	b.n	2f12 <SPIClass::transfer(void const*, void*, unsigned int)+0x126>
    2f7c:	ldr	r1, [r0, #0]

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
    2f7e:	ldr	r4, [r1, #44]	; 0x2c
			if (sr & 0xF0)  {
    2f80:	tst.w	r4, #240	; 0xf0
    2f84:	bne.n	2f8c <SPIClass::transfer(void const*, void*, unsigned int)+0x1a0>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    2f86:	cmp	r3, #0
    2f88:	bne.n	2f7c <SPIClass::transfer(void const*, void*, unsigned int)+0x190>
    2f8a:	b.n	2fae <SPIClass::transfer(void const*, void*, unsigned int)+0x1c2>
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
				if (count_read & 1) {
    2f8c:	lsls	r4, r3, #31

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    2f8e:	ldr	r1, [r1, #56]	; 0x38
				if (count_read & 1) {
    2f90:	bpl.n	2f9c <SPIClass::transfer(void const*, void*, unsigned int)+0x1b0>
					if (p_read)
    2f92:	cbz	r2, 2f98 <SPIClass::transfer(void const*, void*, unsigned int)+0x1ac>
						*p_read++ = w;  // Read any pending RX bytes in
    2f94:	strb	r1, [r2, #0]
    2f96:	adds	r2, #1
					count_read--;
    2f98:	subs	r3, #1
    2f9a:	b.n	2f86 <SPIClass::transfer(void const*, void*, unsigned int)+0x19a>
				} else {
					if (p_read) {
    2f9c:	cbz	r2, 2faa <SPIClass::transfer(void const*, void*, unsigned int)+0x1be>
						*p_read++ = (w & 0xff);
    2f9e:	mov	r4, r2
    2fa0:	strb.w	r1, [r4], #2
						*p_read++ = w >> 8;
    2fa4:	asrs	r1, r1, #8
    2fa6:	strb	r1, [r2, #1]
    2fa8:	mov	r2, r4
					}
					count_read -= 2;
    2faa:	subs	r3, #2
    2fac:	b.n	2f86 <SPIClass::transfer(void const*, void*, unsigned int)+0x19a>
    2fae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2fb2:	nop
    2fb4:	.word	0x801f0400

00002fb8 <SPIClass::dma_rxisr()>:


//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
    2fb8:	push	{r4, r5, r6, lr}
    2fba:	ldr	r3, [r0, #56]	; 0x38
    2fbc:	ldrb	r2, [r3, #4]
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    2fbe:	ldr	r3, [pc, #192]	; (3080 <SPIClass::dma_rxisr()+0xc8>)
    2fc0:	strb	r2, [r3, #0]
    2fc2:	ldr	r3, [r0, #52]	; 0x34
    2fc4:	ldrb	r2, [r3, #4]
	bool complete(void) {
		if (TCD->CSR & DMA_TCD_CSR_DONE) return true;
		return false;
	}
	void clearComplete(void) {
		DMA_CDNE = channel;
    2fc6:	ldr	r3, [pc, #188]	; (3084 <SPIClass::dma_rxisr()+0xcc>)
    2fc8:	strb	r2, [r3, #0]
    2fca:	ldr	r2, [r0, #56]	; 0x38
    2fcc:	ldrb	r2, [r2, #4]
    2fce:	strb	r2, [r3, #0]
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
    2fd0:	ldr	r2, [r0, #48]	; 0x30


//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
    2fd2:	mov	r4, r0
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
    2fd4:	cmp	r2, #0
    2fd6:	beq.n	3058 <SPIClass::dma_rxisr()+0xa0>
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
    2fd8:	ldr	r3, [r0, #4]
    2fda:	ldr	r1, [r3, #12]
    2fdc:	cmp	r2, r1
    2fde:	bls.n	2fe8 <SPIClass::dma_rxisr()+0x30>
			_dma_count_remaining -= hardware().max_dma_count;
    2fe0:	subs	r2, r2, r1
    2fe2:	str	r2, [r0, #48]	; 0x30
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    2fe4:	movs	r1, #1
    2fe6:	b.n	300a <SPIClass::dma_rxisr()+0x52>
    2fe8:	ldr	r3, [r0, #52]	; 0x34
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
			_dma_count_remaining -= hardware().max_dma_count;
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
    2fea:	subs	r1, r2, #1
    2fec:	ldr	r0, [r3, #0]
    2fee:	bl	2b7c <DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]>
    2ff2:	ldr	r3, [r4, #56]	; 0x38
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
    2ff4:	ldr	r1, [r4, #48]	; 0x30
    2ff6:	ldr	r0, [r3, #0]
    2ff8:	bl	2b7c <DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]>
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    2ffc:	ldr	r1, [r4, #48]	; 0x30
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    2ffe:	movs	r3, #0
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    3000:	adds.w	r1, r1, #4294967295
    3004:	it	ne
    3006:	movne	r1, #1
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    3008:	str	r3, [r4, #48]	; 0x30
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
    300a:	ldr	r3, [r4, #52]	; 0x34
    300c:	ldr	r3, [r3, #0]
    300e:	ldr	r0, [r3, #0]
    3010:	add.w	r2, r4, #44	; 0x2c
    3014:	cmp	r0, r2
    3016:	ldr	r2, [r4, #0]
    3018:	bne.n	3026 <SPIClass::dma_rxisr()+0x6e>
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    301a:	ldr	r3, [r2, #12]
    301c:	ldrb.w	r3, [r4, #44]	; 0x2c
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    3020:	orr.w	r3, r3, #2147483648	; 0x80000000
    3024:	b.n	3044 <SPIClass::dma_rxisr()+0x8c>
			} else  {
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    3026:	ldr	r0, [r2, #12]
    3028:	tst.w	r0, #1073741824	; 0x40000000
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    302c:	ldr	r0, [r3, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    302e:	itete	ne
    3030:	ldrne	r5, [r3, #0]
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    3032:	ldreq	r5, [r3, #0]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    3034:	ldrhne	r0, [r0, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
    3036:	ldrbeq	r0, [r0, #0]
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    3038:	ite	ne
    303a:	addne	r5, #2
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    303c:	addeq	r5, #1
    303e:	str	r5, [r3, #0]
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    3040:	orr.w	r3, r0, #2147483648	; 0x80000000
    3044:	str	r3, [r2, #52]	; 0x34
    3046:	ldr	r3, [r4, #56]	; 0x38
    3048:	ldrb	r2, [r3, #4]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    304a:	ldr	r3, [pc, #60]	; (3088 <SPIClass::dma_rxisr()+0xd0>)
    304c:	strb	r2, [r3, #0]
			}
		}
		_dmaRX->enable();
		if (should_reenable_tx)
    304e:	cbz	r1, 307c <SPIClass::dma_rxisr()+0xc4>
    3050:	ldr	r2, [r4, #52]	; 0x34
    3052:	ldrb	r2, [r2, #4]
    3054:	strb	r2, [r3, #0]
    3056:	pop	{r4, r5, r6, pc}
    3058:	ldr	r3, [r0, #0]
			_dmaTX->enable();
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    305a:	ldr	r1, [pc, #48]	; (308c <SPIClass::dma_rxisr()+0xd4>)
		_dmaRX->enable();
		if (should_reenable_tx)
			_dmaTX->enable();
	} else {

		port().RSER = 0;
    305c:	str	r2, [r3, #48]	; 0x30
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    305e:	str	r1, [r3, #44]	; 0x2c
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    3060:	ldr	r1, [r3, #12]
    3062:	bic.w	r1, r1, #1073741824	; 0x40000000
    3066:	str	r1, [r3, #12]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    3068:	movs	r3, #3
    306a:	strb.w	r3, [r0, #45]	; 0x2d
		_dma_event_responder->triggerEvent();
    306e:	ldr	r0, [r0, #60]	; 0x3c
    3070:	ldr	r3, [r0, #0]
    3072:	mov	r1, r2
    3074:	ldr	r3, [r3, #0]

	}
}
    3076:	ldmia.w	sp!, {r4, r5, r6, lr}
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    307a:	bx	r3
    307c:	pop	{r4, r5, r6, pc}
    307e:	nop
    3080:	.word	0x4000801f
    3084:	.word	0x4000801c
    3088:	.word	0x4000801b
    308c:	.word	0xff0f0000

00003090 <_spi_dma_rxISR0()>:
};
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    3090:	push	{r3, lr}
    3092:	ldr	r0, [pc, #8]	; (309c <_spi_dma_rxISR0()+0xc>)
    3094:	bl	2fb8 <SPIClass::dma_rxisr()>
    3098:	pop	{r3, pc}
    309a:	nop
    309c:	.word	0x1fff131c

000030a0 <SDClass::~SDClass()>:
	char *filename;
};



class SDClass : public FS
    30a0:	bx	lr

000030a2 <SDClass::exists(char const*)>:
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
		if (file) return File(new SDFile(file));
		return File();
	}
	bool exists(const char *filepath) {
    30a2:	push	{lr}
    30a4:	mov	r2, r1
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
    30a6:	ldr.w	r1, [r0, #1156]	; 0x484
    30aa:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->exists(path) : false;
    30ac:	cbz	r1, 30c4 <SDClass::exists(char const*)+0x22>
    30ae:	movs	r3, #0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    30b0:	mov	r0, sp
    30b2:	strb.w	r3, [sp]
    30b6:	strb.w	r3, [sp, #1]
    30ba:	strb.w	r3, [sp, #2]
    30be:	bl	6328 <FatFile::open(FatVolume*, char const*, int)>
    30c2:	b.n	30e0 <SDClass::exists(char const*)+0x3e>
    30c4:	ldr.w	r0, [r0, #1160]	; 0x488
    30c8:	cbz	r0, 30e0 <SDClass::exists(char const*)+0x3e>
    30ca:	strb.w	r1, [sp, #49]	; 0x31
    30ce:	strb.w	r1, [sp, #50]	; 0x32
    30d2:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    30d6:	mov	r3, r1
    30d8:	mov	r1, r0
    30da:	mov	r0, sp
    30dc:	bl	47e2 <ExFatFile::open(ExFatVolume*, char const*, int)>
		return sdfs.exists(filepath);
	}
    30e0:	add	sp, #60	; 0x3c
    30e2:	ldr.w	pc, [sp], #4

000030e6 <SDClass::rmdir(char const*)>:
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
    30e6:	push	{lr}
    30e8:	mov	r2, r1
   * The subdirectory file will be removed only if it is empty.
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char *path) {
    return m_fVol ? m_fVol->rmdir(path) :
    30ea:	ldr.w	r1, [r0, #1156]	; 0x484
    30ee:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->rmdir(path) : false;
    30f0:	cbz	r1, 3110 <SDClass::rmdir(char const*)+0x2a>
    30f2:	movs	r3, #0
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char* path) {
    FatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
    30f4:	mov	r0, sp
    30f6:	strb.w	r3, [sp]
    30fa:	strb.w	r3, [sp, #1]
    30fe:	strb.w	r3, [sp, #2]
    3102:	bl	6328 <FatFile::open(FatVolume*, char const*, int)>
    3106:	cbz	r0, 3134 <SDClass::rmdir(char const*)+0x4e>
    3108:	mov	r0, sp
    310a:	bl	61a0 <FatFile::rmdir()>
    310e:	b.n	3134 <SDClass::rmdir(char const*)+0x4e>
    3110:	ldr.w	r0, [r0, #1160]	; 0x488
    3114:	cbz	r0, 3134 <SDClass::rmdir(char const*)+0x4e>
    3116:	strb.w	r1, [sp, #49]	; 0x31
    311a:	strb.w	r1, [sp, #50]	; 0x32
    311e:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char* path) {
    ExFatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
    3122:	mov	r3, r1
    3124:	mov	r1, r0
    3126:	mov	r0, sp
    3128:	bl	47e2 <ExFatFile::open(ExFatVolume*, char const*, int)>
    312c:	cbz	r0, 3134 <SDClass::rmdir(char const*)+0x4e>
    312e:	mov	r0, sp
    3130:	bl	4dec <ExFatFile::rmdir()>
		return sdfs.rmdir(filepath);
	}
    3134:	add	sp, #60	; 0x3c
    3136:	ldr.w	pc, [sp], #4

0000313a <SDClass::remove(char const*)>:
		return sdfs.mkdir(filepath);
	}
	bool rename(const char *oldfilepath, const char *newfilepath) {
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
    313a:	push	{lr}
    313c:	mov	r2, r1
  * \param[in] path A path with a valid 8.3 DOS name for the file.
  *
   * \return true for success or false for failure.
  */
  bool remove(const char *path) {
    return m_fVol ? m_fVol->remove(path) :
    313e:	ldr.w	r1, [r0, #1156]	; 0x484
    3142:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->remove(path) : false;
    3144:	cbz	r1, 3166 <SDClass::remove(char const*)+0x2c>
    3146:	movs	r3, #0
    3148:	strb.w	r3, [sp]
    314c:	strb.w	r3, [sp, #1]
    3150:	strb.w	r3, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    3154:	mov	r0, sp
    3156:	movs	r3, #1
    3158:	bl	6328 <FatFile::open(FatVolume*, char const*, int)>
    315c:	cbz	r0, 318a <SDClass::remove(char const*)+0x50>
    315e:	mov	r0, sp
    3160:	bl	739c <FatFile::remove()>
    3164:	b.n	318a <SDClass::remove(char const*)+0x50>
    3166:	ldr.w	r0, [r0, #1160]	; 0x488
    316a:	cbz	r0, 318a <SDClass::remove(char const*)+0x50>
    316c:	strb.w	r1, [sp, #49]	; 0x31
    3170:	strb.w	r1, [sp, #50]	; 0x32
    3174:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    3178:	movs	r3, #1
    317a:	mov	r1, r0
    317c:	mov	r0, sp
    317e:	bl	47e2 <ExFatFile::open(ExFatVolume*, char const*, int)>
    3182:	cbz	r0, 318a <SDClass::remove(char const*)+0x50>
    3184:	mov	r0, sp
    3186:	bl	4d66 <ExFatFile::remove()>
		return sdfs.remove(filepath);
	}
    318a:	add	sp, #60	; 0x3c
    318c:	ldr.w	pc, [sp], #4

00003190 <SDClass::mkdir(char const*)>:
		return File();
	}
	bool exists(const char *filepath) {
		return sdfs.exists(filepath);
	}
	bool mkdir(const char *filepath) {
    3190:	push	{r4, lr}
   * \param[in] pFlag Create missing parent directories if true.
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
    3192:	ldr.w	r4, [r0, #1156]	; 0x484
    3196:	sub	sp, #56	; 0x38
    3198:	mov	r2, r1
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
    319a:	cbz	r4, 31b8 <SDClass::mkdir(char const*)+0x28>
    319c:	movs	r3, #0
    319e:	strb.w	r3, [sp]
    31a2:	strb.w	r3, [sp, #1]
    31a6:	strb.w	r3, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    31aa:	add.w	r1, r4, #1096	; 0x448
    31ae:	movs	r3, #1
    31b0:	mov	r0, sp
    31b2:	bl	64a4 <FatFile::mkdir(FatFile*, char const*, bool)>
    31b6:	b.n	31da <SDClass::mkdir(char const*)+0x4a>
    31b8:	ldr.w	r1, [r0, #1160]	; 0x488
    31bc:	cbz	r1, 31d8 <SDClass::mkdir(char const*)+0x48>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    31be:	movs	r3, #1
    31c0:	add.w	r1, r1, #1096	; 0x448
    31c4:	mov	r0, sp
    31c6:	strb.w	r4, [sp, #49]	; 0x31
    31ca:	strb.w	r4, [sp, #50]	; 0x32
    31ce:	strb.w	r4, [sp, #51]	; 0x33
    31d2:	bl	5084 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
    31d6:	b.n	31da <SDClass::mkdir(char const*)+0x4a>
    31d8:	mov	r0, r1
		return sdfs.mkdir(filepath);
	}
    31da:	add	sp, #56	; 0x38
    31dc:	pop	{r4, pc}

000031de <SDClass::rename(char const*, char const*)>:
	bool rename(const char *oldfilepath, const char *newfilepath) {
    31de:	push	{r4, r5, lr}
   * a file object that was opened before the rename() call.
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    return m_fVol ? m_fVol->rename(oldPath, newPath) :
    31e0:	ldr.w	r3, [r0, #1156]	; 0x484
    31e4:	sub	sp, #60	; 0x3c
    31e6:	mov	r5, r2
           m_xVol ? m_xVol->rename(oldPath, newPath) : false;
    31e8:	cbz	r3, 3216 <SDClass::rename(char const*, char const*)+0x38>
    31ea:	movs	r2, #0
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend FatFile;
  static FatVolume* cwv() {return m_cwv;}
  FatFile* vwd() {return &m_vwd;}
    31ec:	add.w	r4, r3, #1096	; 0x448
    31f0:	strb.w	r2, [sp]
    31f4:	strb.w	r2, [sp, #1]
    31f8:	strb.w	r2, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    FatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    31fc:	mov	r3, r2
    31fe:	mov	r0, sp
    3200:	mov	r2, r1
    3202:	mov	r1, r4
    3204:	bl	6280 <FatFile::open(FatFile*, char const*, int)>
    3208:	cbz	r0, 3242 <SDClass::rename(char const*, char const*)+0x64>
    320a:	mov	r2, r5
    320c:	mov	r1, r4
    320e:	mov	r0, sp
    3210:	bl	654e <FatFile::rename(FatFile*, char const*)>
    3214:	b.n	3242 <SDClass::rename(char const*, char const*)+0x64>
    3216:	ldr.w	r0, [r0, #1160]	; 0x488
    321a:	cbz	r0, 3242 <SDClass::rename(char const*, char const*)+0x64>
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend ExFatFile;
  static ExFatVolume* cwv() {return m_cwv;}
  ExFatFile* vwd() {return &m_vwd;}
    321c:	add.w	r4, r0, #1096	; 0x448
   *
   * \return true for success or false for failure.
   */
  bool rename(const char* oldPath, const char* newPath) {
    ExFatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    3220:	mov	r2, r1
    3222:	mov	r0, sp
    3224:	mov	r1, r4
    3226:	strb.w	r3, [sp, #49]	; 0x31
    322a:	strb.w	r3, [sp, #50]	; 0x32
    322e:	strb.w	r3, [sp, #51]	; 0x33
    3232:	bl	4728 <ExFatFile::open(ExFatFile*, char const*, int)>
    3236:	cbz	r0, 3242 <SDClass::rename(char const*, char const*)+0x64>
    3238:	mov	r2, r5
    323a:	mov	r1, r4
    323c:	mov	r0, sp
    323e:	bl	5142 <ExFatFile::rename(ExFatFile*, char const*)>
		return sdfs.rename(oldfilepath, newfilepath);
	}
    3242:	add	sp, #60	; 0x3c
    3244:	pop	{r4, r5, pc}

00003246 <SDClass::totalSize()>:
	}
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
		  * (uint64_t)sdfs.bytesPerCluster();
	}
	uint64_t totalSize() {
    3246:	mov	r3, r0
    3248:	push	{r4, lr}
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    324a:	ldr.w	r2, [r3, #1156]	; 0x484
		return (uint64_t)sdfs.clusterCount() * (uint64_t)sdfs.bytesPerCluster();
    324e:	adds	r0, #4
           m_xVol ? m_xVol->clusterCount() : 0;
    3250:	cbz	r2, 3258 <SDClass::totalSize()+0x12>
    3252:	ldr	r4, [r2, #28]
    3254:	subs	r4, #1
    3256:	b.n	3262 <SDClass::totalSize()+0x1c>
    3258:	ldr.w	r4, [r3, #1160]	; 0x488
    325c:	cbz	r4, 3262 <SDClass::totalSize()+0x1c>
    325e:	ldr.w	r4, [r4, #1072]	; 0x430
    3262:	bl	1a44 <FsVolume::bytesPerCluster() const>
	}
    3266:	umull	r0, r1, r4, r0
    326a:	pop	{r4, pc}

0000326c <SDClass::usedSize()>:
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
		return sdfs.rmdir(filepath);
	}
	uint64_t usedSize() {
    326c:	push	{r3, r4, r5, lr}
    326e:	mov	r3, r0
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
    3270:	adds	r5, r0, #4
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    3272:	ldr.w	r0, [r0, #1156]	; 0x484
           m_xVol ? m_xVol->clusterCount() : 0;
    3276:	cbz	r0, 3282 <SDClass::usedSize()+0x16>
    3278:	ldr	r4, [r0, #28]
    327a:	subs	r4, #1
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
    327c:	bl	6bc0 <FatPartition::freeClusterCount()>
    3280:	b.n	3294 <SDClass::usedSize()+0x28>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    3282:	ldr.w	r0, [r3, #1160]	; 0x488
    3286:	cbz	r0, 3292 <SDClass::usedSize()+0x26>
    3288:	ldr.w	r4, [r0, #1072]	; 0x430
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
           m_xVol ? m_xVol->freeClusterCount() : 0;
    328c:	bl	4ae4 <ExFatPartition::freeClusterCount()>
    3290:	b.n	3294 <SDClass::usedSize()+0x28>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    3292:	mov	r4, r0
    3294:	subs	r4, r4, r0
		  * (uint64_t)sdfs.bytesPerCluster();
    3296:	mov	r0, r5
    3298:	bl	1a44 <FsVolume::bytesPerCluster() const>
	}
    329c:	umull	r0, r1, r4, r0
    32a0:	pop	{r3, r4, r5, pc}

000032a2 <SdBase<FsVolume>::begin(SdioConfig)>:
  /** Initialize SD card and file system for SDIO mode.
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    32a2:	push	{r3, r4, r5, lr}
   * \param[in] config SDIO configuration.
   * \return generic card pointer or nullptr if SDIO is not supported.
   */
  SdCard* newCard(SdioConfig config) {
#if HAS_SDIO_CLASS
    m_sdioCard.begin(config);
    32a4:	add.w	r5, r0, #1168	; 0x490
    32a8:	mov	r4, r0
    spiConfigBackupPin = 255;
    32aa:	movs	r3, #255	; 0xff
    32ac:	strb.w	r3, [r0, #1200]	; 0x4b0
    sdioConfigBackup = sdioConfig;
    32b0:	strb.w	r1, [r0, #1212]	; 0x4bc
    32b4:	mov	r0, r5
    32b6:	bl	888c <SdioCard::begin(SdioConfig)>
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdioConfig sdioConfig) {
    m_card = m_cardFactory.newCard(sdioConfig);
    32ba:	str.w	r5, [r4, #1164]	; 0x48c
    return m_card && !m_card->errorCode();
    32be:	mov	r0, r5
    32c0:	bl	8078 <SdioCard::errorCode() const>
    32c4:	cbnz	r0, 32d4 <SdBase<FsVolume>::begin(SdioConfig)+0x32>
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
    32c6:	ldr.w	r1, [r4, #1164]	; 0x48c
    32ca:	mov	r0, r4
  }
    32cc:	ldmia.w	sp!, {r3, r4, r5, lr}
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
    32d0:	b.w	75b4 <FsVolume::begin(BlockDeviceInterface*)>
  }
    32d4:	movs	r0, #0
    32d6:	pop	{r3, r4, r5, pc}

000032d8 <SdBase<FsVolume>::cardBegin(SdSpiConfig)>:
  /** Initialize SD card in SPI mode.
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    32d8:	push	{r4, r5, r6, lr}
    32da:	sub	sp, #32
    32dc:	mov	r6, r0
    32de:	add	r0, sp, #4
    32e0:	stmia.w	r0, {r1, r2, r3}
    32e4:	ldmia	r0, {r0, r1, r2}
    32e6:	add	r5, sp, #20
    32e8:	stmia.w	r5, {r0, r1, r3}
   *
   * \param[in] config SPI configuration.
   * \return generic card pointer.
   */
  SdCard* newCard(SdSpiConfig config) {
    m_spiCard.begin(config);
    32ec:	addw	r4, r6, #1180	; 0x49c
    32f0:	ldmia.w	r5, {r1, r2, r3}
    32f4:	mov	r0, r4
    32f6:	bl	79e8 <SdSpiCard::begin(SdSpiConfig)>
    m_card = m_cardFactory.newCard(spiConfig);
    32fa:	str.w	r4, [r6, #1164]	; 0x48c
    return m_card && !m_card->errorCode();
    32fe:	cbz	r4, 330c <SdBase<FsVolume>::cardBegin(SdSpiConfig)+0x34>
    3300:	ldrb.w	r0, [r6, #1195]	; 0x4ab
    3304:	clz	r0, r0
    3308:	lsrs	r0, r0, #5
    330a:	b.n	330e <SdBase<FsVolume>::cardBegin(SdSpiConfig)+0x36>
    330c:	mov	r0, r4
  }
    330e:	add	sp, #32
    3310:	pop	{r4, r5, r6, pc}

00003312 <SdBase<FsVolume>::restart()>:
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
  }
  //----------------------------------------------------------------------------
  /** Restart library with same config, used after media removed and replaced */
  bool restart() {
    3312:	push	{r4, r5, lr}
    if (spiConfigBackupPin == 255) {
    3314:	ldrb.w	r3, [r0, #1200]	; 0x4b0
    3318:	cmp	r3, #255	; 0xff
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
  }
  //----------------------------------------------------------------------------
  /** Restart library with same config, used after media removed and replaced */
  bool restart() {
    331a:	sub	sp, #20
    331c:	mov	r4, r0
    if (spiConfigBackupPin == 255) {
    331e:	bne.n	332a <SdBase<FsVolume>::restart()+0x18>
      return begin(sdioConfigBackup);
    3320:	ldrb.w	r1, [r0, #1212]	; 0x4bc
    3324:	bl	32a2 <SdBase<FsVolume>::begin(SdioConfig)>
    3328:	b.n	335e <SdBase<FsVolume>::restart()+0x4c>
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
    332a:	ldr.w	r1, [r0, #1204]	; 0x4b4
    332e:	ldr.w	r2, [r0, #1208]	; 0x4b8
    3332:	ldrb.w	r5, [r0, #1201]	; 0x4b1
    3336:	strb.w	r3, [sp, #4]
    333a:	strb.w	r5, [sp, #5]
    333e:	str	r1, [sp, #8]
    3340:	str	r2, [sp, #12]
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    3342:	add	r3, sp, #16
    3344:	ldmdb	r3, {r1, r2, r3}
    3348:	bl	32d8 <SdBase<FsVolume>::cardBegin(SdSpiConfig)>
    334c:	cbz	r0, 335e <SdBase<FsVolume>::restart()+0x4c>
    334e:	ldr.w	r1, [r4, #1164]	; 0x48c
    3352:	mov	r0, r4
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
      return begin(spiConfig);
    }
  }
    3354:	add	sp, #20
    3356:	ldmia.w	sp!, {r4, r5, lr}
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    335a:	b.w	75b4 <FsVolume::begin(BlockDeviceInterface*)>
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
      return begin(spiConfig);
    }
  }
    335e:	add	sp, #20
    3360:	pop	{r4, r5, pc}

00003362 <SDClass::format(int, char, Print&)>:
	}
}
#endif

bool SDClass::format(int type, char progressChar, Print& pr)
{
    3362:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3366:	ldr.w	r4, [r0, #1168]	; 0x490
    336a:	sub	sp, #48	; 0x30
    336c:	mov	r6, r0
    336e:	mov	r7, r3
	SdCard *card = sdfs.card();
	if (!card) return false; // no SD card
    3370:	cbnz	r4, 3376 <SDClass::format(int, char, Print&)+0x14>
    3372:	movs	r0, #0
    3374:	b.n	33c0 <SDClass::format(int, char, Print&)+0x5e>
	uint32_t sectors = card->sectorCount();
    3376:	ldr	r3, [r4, #0]
    3378:	mov	r0, r4
    337a:	ldr	r3, [r3, #24]
    337c:	blx	r3
	if (sectors <= 12288) return false; // card too small
    337e:	cmp.w	r0, #12288	; 0x3000

bool SDClass::format(int type, char progressChar, Print& pr)
{
	SdCard *card = sdfs.card();
	if (!card) return false; // no SD card
	uint32_t sectors = card->sectorCount();
    3382:	mov	r8, r0
	if (sectors <= 12288) return false; // card too small
    3384:	bls.n	3372 <SDClass::format(int, char, Print&)+0x10>
	uint8_t *buf = (uint8_t *)malloc(512);
    3386:	mov.w	r0, #512	; 0x200
    338a:	bl	b2d4 <malloc>
	if (!buf) return false; // unable to allocate memory
    338e:	mov	r5, r0
    3390:	cmp	r0, #0
    3392:	beq.n	3372 <SDClass::format(int, char, Print&)+0x10>
	bool ret;
	if (sectors > 67108864) {
    3394:	cmp.w	r8, #67108864	; 0x4000000
#ifdef __arm__
		ExFatFormatter exFatFormatter;
		ret = exFatFormatter.format(card, buf, &pr);
    3398:	mov	r2, r0
    339a:	mov	r3, r7
    339c:	mov	r1, r4
    339e:	add	r0, sp, #4
	uint32_t sectors = card->sectorCount();
	if (sectors <= 12288) return false; // card too small
	uint8_t *buf = (uint8_t *)malloc(512);
	if (!buf) return false; // unable to allocate memory
	bool ret;
	if (sectors > 67108864) {
    33a0:	bls.n	33a8 <SDClass::format(int, char, Print&)+0x46>
#ifdef __arm__
		ExFatFormatter exFatFormatter;
		ret = exFatFormatter.format(card, buf, &pr);
    33a2:	bl	3a74 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>
    33a6:	b.n	33ac <SDClass::format(int, char, Print&)+0x4a>
#else
		ret = false;
#endif
	} else {
		FatFormatter fatFormatter;
		ret = fatFormatter.format(card, buf, &pr);
    33a8:	bl	59fc <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>
    33ac:	mov	r4, r0
	}
	free(buf);
    33ae:	mov	r0, r5
    33b0:	bl	b2e4 <free>
	if (ret) {
    33b4:	cmp	r4, #0
    33b6:	beq.n	3372 <SDClass::format(int, char, Print&)+0x10>
		// TODO: Is begin() really necessary?  Is a quicker way possible?
		sdfs.restart(); // TODO: is sdfs.volumeBegin() enough??
    33b8:	adds	r0, r6, #4
    33ba:	bl	3312 <SdBase<FsVolume>::restart()>
    33be:	movs	r0, #1
	}
	return ret;
}
    33c0:	add	sp, #48	; 0x30
    33c2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000033c6 <SDClass::mediaPresent()>:
	}
	return false;
}

bool SDClass::mediaPresent()
{
    33c6:	push	{r4, r5, lr}
    33c8:	ldr.w	r4, [r0, #1168]	; 0x490
    33cc:	sub	sp, #20
    33ce:	mov	r5, r0
	//Serial.print("mediaPresent: ");
	bool ret;
	SdCard *card = sdfs.card();
	if (card) {
    33d0:	cbz	r4, 3410 <SDClass::mediaPresent()+0x4a>
		if (cardPreviouslyPresent) {
    33d2:	ldrb.w	r3, [r0, #1220]	; 0x4c4
    33d6:	cbz	r3, 3408 <SDClass::mediaPresent()+0x42>
			#ifdef BUILTIN_SDCARD
			uint32_t s;
			if (csPin_ == BUILTIN_SDCARD) {
    33d8:	ldrb.w	r3, [r0, #1221]	; 0x4c5
    33dc:	cmp	r3, #254	; 0xfe
    33de:	beq.n	33ec <SDClass::mediaPresent()+0x26>
			const uint32_t s = 0xFFFFFFFF;
			#endif
			if (s == 0xFFFFFFFF) {
				// SPI doesn't have 32 bit status, read CID register
				cid_t cid;
				ret = card->readCID(&cid);
    33e0:	ldr	r3, [r4, #0]
    33e2:	mov	r1, sp
    33e4:	ldr	r3, [r3, #56]	; 0x38
    33e6:	mov	r0, r4
    33e8:	blx	r3
    33ea:	b.n	3412 <SDClass::mediaPresent()+0x4c>
		if (cardPreviouslyPresent) {
			#ifdef BUILTIN_SDCARD
			uint32_t s;
			if (csPin_ == BUILTIN_SDCARD) {
				#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
				card->syncDevice();
    33ec:	ldr	r3, [r4, #0]
    33ee:	mov	r0, r4
    33f0:	ldr	r3, [r3, #28]
    33f2:	blx	r3
				#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
				s = card->status();
    33f4:	ldr	r3, [r4, #0]
    33f6:	mov	r0, r4
    33f8:	ldr	r3, [r3, #68]	; 0x44
    33fa:	blx	r3
			} else s = 0xFFFFFFFF;
			#else
			const uint32_t s = 0xFFFFFFFF;
			#endif
			if (s == 0xFFFFFFFF) {
    33fc:	adds	r3, r0, #1
    33fe:	beq.n	33e0 <SDClass::mediaPresent()+0x1a>
				// SPI doesn't have 32 bit status, read CID register
				cid_t cid;
				ret = card->readCID(&cid);
				//Serial.print(ret ? "CID=ok" : "CID=unreadable");
			} else if (s == 0) {
    3400:	adds	r0, #0
    3402:	it	ne
    3404:	movne	r0, #1
    3406:	b.n	3412 <SDClass::mediaPresent()+0x4c>
			if ((csPin_ == BUILTIN_SDCARD) && !digitalReadFast(_SD_DAT3))
				ret = false;
			else
			#endif
			{
				ret = sdfs.restart();
    3408:	adds	r0, #4
    340a:	bl	3312 <SdBase<FsVolume>::restart()>
    340e:	b.n	3412 <SDClass::mediaPresent()+0x4c>
			}
			//Serial.print(ret ? "begin ok" : "begin nope");
		}
	} else {
		//Serial.print("no card");
		ret = false;
    3410:	mov	r0, r4
	}
	//Serial.println();
	cardPreviouslyPresent = ret;
    3412:	strb.w	r0, [r5, #1220]	; 0x4c4
	return ret;
}
    3416:	add	sp, #20
    3418:	pop	{r4, r5, pc}
    341a:	Address 0x0000341a is out of bounds.


0000341c <_GLOBAL__sub_I_SD>:


class SDClass : public FS
{
public:
	SDClass() { }
    341c:	ldr	r0, [pc, #72]	; (3468 <_GLOBAL__sub_I_SD+0x4c>)
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    341e:	ldr	r2, [pc, #76]	; (346c <_GLOBAL__sub_I_SD+0x50>)
    3420:	str.w	r2, [r0, #1172]	; 0x494
    3424:	ldr	r2, [pc, #72]	; (3470 <_GLOBAL__sub_I_SD+0x54>)
    3426:	ldr	r3, [pc, #76]	; (3474 <_GLOBAL__sub_I_SD+0x58>)
    3428:	str.w	r2, [r0, #1184]	; 0x4a0
    342c:	movs	r2, #1
    342e:	str	r3, [r0, #0]
    3430:	strb.w	r2, [r0, #1197]	; 0x4ad
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() {}
    3434:	movs	r3, #0
    3436:	movs	r2, #41	; 0x29
    3438:	str.w	r3, [r0, #1156]	; 0x484
    343c:	str.w	r3, [r0, #1160]	; 0x488
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    3440:	strb.w	r3, [r0, #1180]	; 0x49c
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    3444:	strb.w	r3, [r0, #1181]	; 0x49d
    3448:	strb.w	r2, [r0, #1199]	; 0x4af
    344c:	strb.w	r3, [r0, #1202]	; 0x4b2
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    3450:	strb.w	r3, [r0, #1216]	; 0x4c0
    3454:	strb.w	r3, [r0, #1220]	; 0x4c4
 */

#include <Arduino.h>
#include <SD.h>

SDClass SD;
    3458:	ldr	r2, [pc, #28]	; (3478 <_GLOBAL__sub_I_SD+0x5c>)
    345a:	ldr	r1, [pc, #32]	; (347c <_GLOBAL__sub_I_SD+0x60>)
    345c:	movs	r3, #255	; 0xff
    345e:	strb.w	r3, [r0, #1221]	; 0x4c5
    3462:	b.w	a4e0 <__aeabi_atexit>
    3466:	nop
    3468:	.word	0x2001c9ec
    346c:	.word	0x00012df4
    3470:	.word	0x00012d94
    3474:	.word	0x00012a94
    3478:	.word	0x1fff0f30
    347c:	.word	0x000030a1

00003480 <FsUtf::cpToMb(unsigned long, char*, char*)>:
#include "FsUtf.h"
namespace FsUtf {
  //----------------------------------------------------------------------------
  char* cpToMb(uint32_t cp, char* str, char* end) {
    size_t n = end - str;
    if (cp < 0X80) {
    3480:	cmp	r0, #127	; 0x7f
 */
#include "FsUtf.h"
namespace FsUtf {
  //----------------------------------------------------------------------------
  char* cpToMb(uint32_t cp, char* str, char* end) {
    size_t n = end - str;
    3482:	sub.w	r2, r2, r1
    if (cp < 0X80) {
    3486:	bhi.n	3492 <FsUtf::cpToMb(unsigned long, char*, char*)+0x12>
      if (n < 1) goto fail;
    3488:	cmp	r2, #0
    348a:	beq.n	350c <FsUtf::cpToMb(unsigned long, char*, char*)+0x8c>
      *(str++) = static_cast<uint8_t>(cp);
    348c:	strb	r0, [r1, #0]
    348e:	adds	r0, r1, #1
    3490:	bx	lr
    } else if (cp < 0X800) {
    3492:	cmp.w	r0, #2048	; 0x800
    3496:	bcs.n	34b4 <FsUtf::cpToMb(unsigned long, char*, char*)+0x34>
      if (n < 2) goto fail;
    3498:	cmp	r2, #1
    349a:	bls.n	3510 <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    349c:	lsrs	r3, r0, #6
    349e:	mov	r2, r1
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    34a0:	and.w	r0, r0, #63	; 0x3f
    if (cp < 0X80) {
      if (n < 1) goto fail;
      *(str++) = static_cast<uint8_t>(cp);
    } else if (cp < 0X800) {
      if (n < 2) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    34a4:	orn	r3, r3, #63	; 0x3f
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    34a8:	orn	r0, r0, #127	; 0x7f
    if (cp < 0X80) {
      if (n < 1) goto fail;
      *(str++) = static_cast<uint8_t>(cp);
    } else if (cp < 0X800) {
      if (n < 2) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    34ac:	strb.w	r3, [r2], #2
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    34b0:	strb	r0, [r1, #1]
    34b2:	b.n	350c <FsUtf::cpToMb(unsigned long, char*, char*)+0x8c>
    } else if (cp < 0X10000) {
    34b4:	cmp.w	r0, #65536	; 0x10000
    34b8:	bcs.n	34de <FsUtf::cpToMb(unsigned long, char*, char*)+0x5e>
      if (n < 3) goto fail;
    34ba:	cmp	r2, #2
    34bc:	bls.n	3510 <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 12)         | 0XE0);
    34be:	lsrs	r3, r0, #12
    34c0:	orn	r3, r3, #31
    34c4:	strb	r3, [r1, #0]
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    34c6:	ubfx	r3, r0, #6, #6
    34ca:	orn	r3, r3, #127	; 0x7f
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    34ce:	and.w	r0, r0, #63	; 0x3f
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    } else if (cp < 0X10000) {
      if (n < 3) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 12)         | 0XE0);
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    34d2:	strb	r3, [r1, #1]
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    34d4:	orn	r3, r0, #127	; 0x7f
    34d8:	strb	r3, [r1, #2]
    34da:	adds	r0, r1, #3
    34dc:	bx	lr
    } else {
       if (n < 4) goto fail;
    34de:	cmp	r2, #3
    34e0:	bls.n	3510 <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 18)         | 0XF0);
    34e2:	lsrs	r3, r0, #18
    34e4:	orn	r3, r3, #15
    34e8:	strb	r3, [r1, #0]
      *(str++) = static_cast<uint8_t>(((cp >> 12) & 0X3F)| 0X80);
    34ea:	ubfx	r3, r0, #12, #6
    34ee:	orn	r3, r3, #127	; 0x7f
    34f2:	strb	r3, [r1, #1]
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    34f4:	ubfx	r3, r0, #6, #6
    34f8:	orn	r3, r3, #127	; 0x7f
    34fc:	strb	r3, [r1, #2]
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    34fe:	and.w	r3, r0, #63	; 0x3f
    3502:	orn	r3, r3, #127	; 0x7f
    3506:	strb	r3, [r1, #3]
    3508:	adds	r0, r1, #4
    350a:	bx	lr
    }
    return str;

   fail:
    return nullptr;
    350c:	mov	r0, r2
    350e:	bx	lr
    3510:	movs	r0, #0
  }
    3512:	bx	lr

00003514 <FsUtf::mbToCp(char const*, char const*, unsigned long*)>:
  //----------------------------------------------------------------------------
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    size_t n;
    uint32_t cp;
    if (str >= end) {
    3514:	cmp	r0, r1
   fail:
    return nullptr;
  }
  //----------------------------------------------------------------------------
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    3516:	push	{r4, r5, lr}
    size_t n;
    uint32_t cp;
    if (str >= end) {
    3518:	bcs.n	3588 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
      return nullptr;
    }
    uint8_t ch = str[0];
    351a:	ldrb	r3, [r0, #0]
    if ((ch & 0X80) == 0) {
    351c:	lsls	r4, r3, #24
    351e:	bmi.n	3526 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x12>
      *rtn = ch;
    3520:	str	r3, [r2, #0]
      return str + 1;
    3522:	adds	r4, r0, #1
    3524:	b.n	358e <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x7a>
    }
    if ((ch & 0XE0) == 0XC0) {
    3526:	and.w	r4, r3, #224	; 0xe0
    352a:	cmp	r4, #192	; 0xc0
    352c:	bne.n	3536 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x22>
      cp = ch & 0X1F;
    352e:	and.w	r3, r3, #31
      n = 2;
    3532:	movs	r4, #2
    3534:	b.n	3554 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x40>
    } else if ((ch & 0XF0) == 0XE0) {
    3536:	and.w	r4, r3, #240	; 0xf0
    353a:	cmp	r4, #224	; 0xe0
    353c:	bne.n	3546 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x32>
      cp = ch & 0X0F;
    353e:	and.w	r3, r3, #15
      n = 3;
    3542:	movs	r4, #3
    3544:	b.n	3554 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x40>
    } else if ((ch & 0XF8) == 0XF0) {
    3546:	and.w	r4, r3, #248	; 0xf8
    354a:	cmp	r4, #240	; 0xf0
    354c:	bne.n	3588 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
      cp = ch & 0X07;
    354e:	and.w	r3, r3, #7
      n = 4;
    3552:	movs	r4, #4
    } else {
      return nullptr;
    }
    if ((str + n) > end) {
    3554:	add	r4, r0
    3556:	cmp	r1, r4
    3558:	bcc.n	3588 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
    355a:	adds	r0, #1
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
      ch = str[i];
    355c:	ldrb.w	r1, [r0], #1
      if ((ch & 0XC0) != 0X80) {
    3560:	and.w	r5, r1, #192	; 0xc0
    3564:	cmp	r5, #128	; 0x80
    3566:	bne.n	3588 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
        return nullptr;
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    3568:	and.w	r1, r1, #63	; 0x3f
      return nullptr;
    }
    if ((str + n) > end) {
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
    356c:	cmp	r0, r4
      ch = str[i];
      if ((ch & 0XC0) != 0X80) {
        return nullptr;
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    356e:	orr.w	r3, r1, r3, lsl #6
      return nullptr;
    }
    if ((str + n) > end) {
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
    3572:	bne.n	355c <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x48>
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    }
    // Don't allow over long as ASCII.
    if (cp < 0X80 || !isValidCp(cp)) {
    3574:	ldr	r1, [pc, #28]	; (3594 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x80>)
    3576:	sub.w	r0, r3, #128	; 0x80
    357a:	cmp	r0, r1
    357c:	bhi.n	3588 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
  /** Check for a valid code point.
   * \param[in] cp code point.
   * \return true if valid else false.
   */
  inline bool isValidCp(uint32_t cp) {
    return cp <= 0x10FFFF && (cp < 0XD800 || cp > 0XDFFF);
    357e:	sub.w	r1, r3, #55296	; 0xd800
    3582:	cmp.w	r1, #2048	; 0x800
    3586:	bcs.n	358c <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x78>
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    size_t n;
    uint32_t cp;
    if (str >= end) {
      return nullptr;
    3588:	movs	r4, #0
    358a:	b.n	358e <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x7a>
    }
    // Don't allow over long as ASCII.
    if (cp < 0X80 || !isValidCp(cp)) {
      return nullptr;
    }
    *rtn = cp;
    358c:	str	r3, [r2, #0]
    return str + n;
  }
    358e:	mov	r0, r4
    3590:	pop	{r4, r5, pc}
    3592:	nop
    3594:	.word	0x0010ff7f

00003598 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>:
#include "FsGetPartitionInfo.h"
namespace FsGetPartitionInfo {
  static const uint8_t mbdpGuid[16] PROGMEM = {0xA2, 0xA0, 0xD0, 0xEB, 0xE5, 0xB9, 0x33, 0x44, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7};

  voltype_t getPartitionInfo(BlockDeviceInterface *blockDev, uint8_t part, uint8_t *secBuf,
      uint32_t *pfirstLBA, uint32_t *psectorCount, uint32_t *pmbrLBA, uint8_t *pmbrPart) {
    3598:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    359c:	add	r6, sp, #48	; 0x30
    359e:	mov	r5, r0
    35a0:	mov	r4, r2
    35a2:	mov	sl, r3
    35a4:	ldmia.w	r6, {r6, r7, r8}
    uint32_t firstLBA;
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    35a8:	str	r1, [sp, #4]
    35aa:	cbnz	r1, 35b0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x18>
    35ac:	movs	r0, #0
    35ae:	b.n	3738 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    35b0:	cmp.w	sl, #0
    35b4:	beq.n	35ac <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    part--; // zero base it.

    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    35b6:	ldr	r3, [r0, #0]
    35b8:	movs	r1, #0
    35ba:	ldr	r3, [r3, #12]
    35bc:	blx	r3
    35be:	cmp	r0, #0
    35c0:	beq.n	35ac <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    part--; // zero base it.
    35c2:	ldr	r3, [sp, #4]
    35c4:	add.w	r9, r3, #4294967295
    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    mbr = reinterpret_cast<MbrSector_t*>(secBuf);

    // First check for GPT vs MBR
    mp = &mbr->part[0];
    if (mp->type == 0xee) {
    35c8:	ldrb.w	r3, [r4, #450]	; 0x1c2
    35cc:	cmp	r3, #238	; 0xee
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    part--; // zero base it.
    35ce:	uxtb.w	r9, r9
    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    mbr = reinterpret_cast<MbrSector_t*>(secBuf);

    // First check for GPT vs MBR
    mp = &mbr->part[0];
    if (mp->type == 0xee) {
    35d2:	bne.n	3654 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xbc>
      // This is a GPT initialized Disk assume validation done earlier.
      if (!blockDev->readSector(1, secBuf)) return INVALID_VOL; 
    35d4:	ldr	r3, [r5, #0]
    35d6:	mov	r2, r4
    35d8:	ldr	r3, [r3, #12]
    35da:	movs	r1, #1
    35dc:	mov	r0, r5
    35de:	blx	r3
    35e0:	cmp	r0, #0
    35e2:	beq.n	35ac <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      GPTPartitionHeader_t* gptph = reinterpret_cast<GPTPartitionHeader_t*>(secBuf);
      // Lets do a little validation of this data.
      if (!gptph || (memcmp(gptph->signature, F("EFI PART"), 8) != 0))  return INVALID_VOL;
    35e4:	movs	r2, #8
    35e6:	ldr	r1, [pc, #344]	; (3740 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a8>)
    35e8:	mov	r0, r4
    35ea:	bl	b930 <memcmp>
    35ee:	cmp	r0, #0
    35f0:	bne.n	35ac <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      uint32_t numberPartitions = getLe32(gptph->numberPartitions);
      if (part > numberPartitions)  return INVALID_VOL;
    35f2:	ldr	r3, [r4, #80]	; 0x50
    35f4:	cmp	r9, r3
    35f6:	bhi.n	35ac <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>

      // We will overload the mbr part to give clue where GPT data is stored for this volume
      uint32_t mbrLBA = 2 + (part >> 2);
    35f8:	mov.w	r1, r9, asr #2
    35fc:	adds	r1, #2
      uint8_t mbrPart = part & 0x3;
    35fe:	and.w	r9, r9, #3
      if (pmbrLBA) *pmbrLBA = mbrLBA;
    3602:	cbz	r7, 3606 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x6e>
    3604:	str	r1, [r7, #0]
      if (pmbrPart) *pmbrPart =mbrPart;
    3606:	cmp.w	r8, #0
    360a:	beq.n	3610 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x78>
    360c:	strb.w	r9, [r8]
      if (!blockDev->readSector(mbrLBA, secBuf)) return INVALID_VOL; 
    3610:	ldr	r3, [r5, #0]
    3612:	mov	r2, r4
    3614:	ldr	r3, [r3, #12]
    3616:	mov	r0, r5
    3618:	blx	r3
    361a:	cmp	r0, #0
    361c:	beq.n	35ac <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      GPTPartitionEntrySector_t *gptes = reinterpret_cast<GPTPartitionEntrySector_t*>(secBuf);
      GPTPartitionEntryItem_t *gptei = &gptes->items[mbrPart];

      // Mow extract the data...
      firstLBA = getLe64(gptei->firstLBA);
    361e:	mov.w	r0, r9, lsl #7
    3622:	add.w	r3, r0, #32
    3626:	ldr	r2, [r4, r3]
      sectorCount = 1 + getLe64(gptei->lastLBA) - getLe64(gptei->firstLBA);
    3628:	add.w	r3, r0, #40	; 0x28
    362c:	ldr	r3, [r4, r3]
    362e:	adds	r3, #1
    3630:	subs	r3, r3, r2
      if ((firstLBA == 0) && (sectorCount == 1)) return INVALID_VOL;
    3632:	cbnz	r2, 3638 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xa0>
    3634:	cmp	r3, #1
    3636:	beq.n	35ac <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      
      *pfirstLBA = firstLBA;
    3638:	str.w	r2, [sl]
      if (psectorCount) *psectorCount = sectorCount;
    363c:	cbz	r6, 3640 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xa8>
    363e:	str	r3, [r6, #0]

      if (memcmp((uint8_t *)gptei->partitionTypeGUID, mbdpGuid, 16) != 0) return OTHER_VOL;
    3640:	movs	r2, #16
    3642:	ldr	r1, [pc, #256]	; (3744 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1ac>)
    3644:	add	r0, r4
    3646:	bl	b930 <memcmp>
    364a:	cmp	r0, #0
    364c:	ite	eq
    364e:	moveq	r0, #3
    3650:	movne	r0, #4
    3652:	b.n	3738 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    }
    // So we are now looking a MBR type setups. 
    // Extended support we need to walk through the partitions to see if there is an extended partition
    // that we need to walk into. 
    // short cut:
    if (part < 4) {
    3654:	cmp.w	r9, #3
    3658:	bhi.n	369a <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
      // try quick way through
      mp = &mbr->part[part];
      if (((mp->boot == 0) || (mp->boot == 0X80)) && (mp->type != 0) && (mp->type != 0xf)) {
    365a:	add.w	r3, r4, r9, lsl #4
    365e:	ldrb.w	r2, [r3, #446]	; 0x1be
    3662:	lsls	r2, r2, #25
    3664:	bne.n	369a <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
    3666:	ldrb.w	r3, [r3, #450]	; 0x1c2
    366a:	cbz	r3, 369a <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
    366c:	cmp	r3, #15
    366e:	beq.n	369a <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
        *pfirstLBA = getLe32(mp->relativeSectors);
    3670:	add.w	r3, r9, #28
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    3674:	add.w	r4, r4, r3, lsl #4
    3678:	ldr.w	r3, [r4, #6]
    367c:	str.w	r3, [sl]
        if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
    3680:	cbz	r6, 3688 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xf0>
    3682:	ldr.w	r3, [r4, #10]
    3686:	str	r3, [r6, #0]
        if (pmbrLBA) *pmbrLBA = 0;
    3688:	cbz	r7, 368e <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xf6>
    368a:	movs	r3, #0
    368c:	str	r3, [r7, #0]
        if (pmbrPart) *pmbrPart = part; // zero based. 
    368e:	cmp.w	r8, #0
    3692:	beq.n	36c8 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x130>
    3694:	strb.w	r9, [r8]
    3698:	b.n	36c8 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x130>
    369a:	mov	r1, r4
#include "FsGetPartitionInfo.h"
namespace FsGetPartitionInfo {
  static const uint8_t mbdpGuid[16] PROGMEM = {0xA2, 0xA0, 0xD0, 0xEB, 0xE5, 0xB9, 0x33, 0x44, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7};

  voltype_t getPartitionInfo(BlockDeviceInterface *blockDev, uint8_t part, uint8_t *secBuf,
      uint32_t *pfirstLBA, uint32_t *psectorCount, uint32_t *pmbrLBA, uint8_t *pmbrPart) {
    369c:	movs	r3, #0

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
      mp = &mbr->part[index_part];
      if ((mp->boot != 0 && mp->boot != 0X80) || mp->type == 0 || index_part > part) return INVALID_VOL;
    369e:	ldrb.w	r0, [r1, #446]	; 0x1be
    36a2:	lsls	r0, r0, #25
    36a4:	uxtb	r2, r3
    36a6:	bne.n	35ac <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    36a8:	ldrb.w	r0, [r1, #450]	; 0x1c2
    36ac:	cmp	r0, #0
    36ae:	beq.w	35ac <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    36b2:	cmp	r9, r2
    36b4:	bcc.w	35ac <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      if (mp->type == 0xf) break;
    36b8:	cmp	r0, #15
    36ba:	beq.n	36cc <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x134>
    36bc:	adds	r3, #1
      }
    }  

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
    36be:	cmp	r3, #4
    36c0:	add.w	r1, r1, #16
    36c4:	bne.n	369e <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x106>
    36c6:	b.n	35ac <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      if (((mp->boot == 0) || (mp->boot == 0X80)) && (mp->type != 0) && (mp->type != 0xf)) {
        *pfirstLBA = getLe32(mp->relativeSectors);
        if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
        if (pmbrLBA) *pmbrLBA = 0;
        if (pmbrPart) *pmbrPart = part; // zero based. 
        return MBR_VOL;
    36c8:	movs	r0, #1
    36ca:	b.n	3738 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    }  

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
      mp = &mbr->part[index_part];
    36cc:	add.w	r3, r4, r3, lsl #4
    36d0:	adds	r2, #1
    36d2:	ldr.w	r9, [r3, #454]	; 0x1c6
    36d6:	uxtb.w	fp, r2
    if (index_part == 4) return INVALID_VOL; // no extended partition found. 

    // Our partition if it exists is in extended partition. 
    uint32_t next_mbr = getLe32(mp->relativeSectors);
    for(;;) {
      if (!blockDev->readSector(next_mbr, secBuf)) return INVALID_VOL;
    36da:	ldr	r3, [r5, #0]
    36dc:	mov	r2, r4
    36de:	ldr	r3, [r3, #12]
    36e0:	mov	r1, r9
    36e2:	mov	r0, r5
    36e4:	blx	r3
    36e6:	cmp	r0, #0
    36e8:	beq.w	35ac <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      mbr = reinterpret_cast<MbrSector_t*>(secBuf);

      if (index_part == part) break; // should be at that entry
    36ec:	ldr	r3, [sp, #4]
    36ee:	cmp	r3, fp
    36f0:	beq.n	3712 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x17a>
      // else we need to see if it points to others...
      mp = &mbr->part[1];
      uint32_t  relSec = getLe32(mp->relativeSectors);
      //Serial.printf("    Check for next: type: %u start:%u\n ", mp->type, volumeStartSector);
      if ((mp->type == 5) && relSec) {
    36f2:	ldrb.w	r2, [r4, #466]	; 0x1d2
    36f6:	ldr.w	r3, [r4, #470]	; 0x1d6
    36fa:	cmp	r2, #5
    36fc:	bne.w	35ac <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    3700:	add.w	r2, fp, #1
    3704:	uxtb.w	fp, r2
    3708:	cmp	r3, #0
    370a:	beq.w	35ac <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
        next_mbr = next_mbr + relSec;
    370e:	add	r9, r3

    if (index_part == 4) return INVALID_VOL; // no extended partition found. 

    // Our partition if it exists is in extended partition. 
    uint32_t next_mbr = getLe32(mp->relativeSectors);
    for(;;) {
    3710:	b.n	36da <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x142>
      } else return INVALID_VOL;
    }
   
    // If we are here than we should hopefully be at start of segment...
    mp = &mbr->part[0];
    *pfirstLBA = getLe32(mp->relativeSectors) + next_mbr;
    3712:	ldr.w	r3, [r4, #454]	; 0x1c6
    3716:	add	r3, r9
    3718:	str.w	r3, [sl]
    if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
    371c:	cbz	r6, 3724 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x18c>
    371e:	ldr.w	r3, [r4, #458]	; 0x1ca
    3722:	str	r3, [r6, #0]
    if (pmbrLBA) *pmbrLBA = next_mbr;
    3724:	cbz	r7, 372a <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x192>
    3726:	str.w	r9, [r7]
    if (pmbrPart) *pmbrPart = 0; // zero based. 
    372a:	cmp.w	r8, #0
    372e:	beq.n	3736 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x19e>
    3730:	movs	r3, #0
    3732:	strb.w	r3, [r8]
    return EXT_VOL;
    3736:	movs	r0, #2
  }
    3738:	add	sp, #12
    373a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    373e:	nop
    3740:	.word	0x00012acc
    3744:	.word	0x00012abc

00003748 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>:
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    3748:	cmp.w	r1, #256	; 0x100
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsStructs.h"
// bgnLba = relSector;
// endLba = relSector + partSize - 1;
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba) {
    374c:	push	{r4, r5, lr}
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    374e:	bhi.n	375e <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x16>
  if (capacityMB <= 16) {
    3750:	cmp	r1, #16
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    3752:	mov.w	r4, #32
  if (capacityMB <= 16) {
    3756:	bls.n	3782 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x3a>
    numberOfHeads = 2;
  } else if (capacityMB <= 32) {
    3758:	cmp	r1, #32
    375a:	bls.n	3786 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x3e>
    375c:	b.n	3760 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x18>
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    375e:	movs	r4, #63	; 0x3f
  if (capacityMB <= 16) {
    numberOfHeads = 2;
  } else if (capacityMB <= 32) {
    numberOfHeads = 4;
  } else if (capacityMB <= 128) {
    3760:	cmp	r1, #128	; 0x80
    3762:	bls.n	378a <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x42>
    numberOfHeads = 8;
  } else if (capacityMB <= 504) {
    3764:	cmp.w	r1, #504	; 0x1f8
    3768:	bls.n	378e <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x46>
    numberOfHeads = 16;
  } else if (capacityMB <= 1008) {
    376a:	cmp.w	r1, #1008	; 0x3f0
    376e:	bls.n	3792 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x4a>
    numberOfHeads = 32;
  } else if (capacityMB <= 2016) {
    3770:	cmp.w	r1, #2016	; 0x7e0
    3774:	bls.n	3796 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x4e>
    numberOfHeads = 64;
  } else if (capacityMB <= 4032) {
    3776:	cmp.w	r1, #4032	; 0xfc0
    numberOfHeads = 128;
  } else {
    numberOfHeads = 255;
    377a:	ite	ls
    377c:	movls	r3, #128	; 0x80
    377e:	movhi	r3, #255	; 0xff
    3780:	b.n	3798 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
  if (capacityMB <= 16) {
    numberOfHeads = 2;
    3782:	movs	r3, #2
    3784:	b.n	3798 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 32) {
    numberOfHeads = 4;
    3786:	movs	r3, #4
    3788:	b.n	3798 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 128) {
    numberOfHeads = 8;
    378a:	movs	r3, #8
    378c:	b.n	3798 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 504) {
    numberOfHeads = 16;
    378e:	movs	r3, #16
    3790:	b.n	3798 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 1008) {
    numberOfHeads = 32;
    3792:	movs	r3, #32
    3794:	b.n	3798 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 2016) {
    numberOfHeads = 64;
    3796:	movs	r3, #64	; 0x40
  } else if (capacityMB <= 4032) {
    numberOfHeads = 128;
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
    3798:	smulbb	r3, r3, r4
    379c:	udiv	r5, r2, r3
  if (c <= 1023) {
    37a0:	cmp.w	r5, #1024	; 0x400
    37a4:	bcs.n	37be <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x76>
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
    37a6:	udiv	r1, r2, r4
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    37aa:	mls	r3, r3, r5, r2
    s = (lba % sectorsPerTrack) + 1;
    37ae:	mls	r2, r4, r1, r2
    37b2:	adds	r2, #1
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    37b4:	udiv	r3, r3, r4
    s = (lba % sectorsPerTrack) + 1;
    37b8:	uxtb	r2, r2
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    37ba:	uxtb	r3, r3
    37bc:	b.n	37c6 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x7e>
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    h = 254;
    s = 63;
    37be:	movs	r2, #63	; 0x3f
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    h = 254;
    37c0:	movs	r3, #254	; 0xfe
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    37c2:	movw	r5, #1023	; 0x3ff
    h = 254;
    s = 63;
  }
  chs[0] = h;
    37c6:	strb	r3, [r0, #0]
  chs[1] = ((c >> 2) & 0XC0) | s;
    37c8:	lsrs	r3, r5, #2
    37ca:	bic.w	r3, r3, #63	; 0x3f
    37ce:	orrs	r2, r3
    37d0:	strb	r2, [r0, #1]
  chs[2] = c;
    37d2:	strb	r5, [r0, #2]
    37d4:	pop	{r4, r5, pc}

000037d6 <FsCache::sync()>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    37d6:	push	{r3, r4, r5, r6, r7, lr}
  if (m_status & CACHE_STATUS_DIRTY) {
    37d8:	ldrb	r3, [r0, #0]
    37da:	lsls	r2, r3, #31

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    37dc:	mov	r4, r0
  if (m_status & CACHE_STATUS_DIRTY) {
    37de:	bpl.n	381c <FsCache::sync()+0x46>
    if (!m_blockDev->writeSector(m_sector, m_buffer)) {
    37e0:	ldr	r0, [r0, #4]
    37e2:	ldr	r1, [r4, #12]
    37e4:	ldr	r3, [r0, #0]
    37e6:	add.w	r6, r4, #16
    37ea:	ldr	r3, [r3, #32]
    37ec:	mov	r2, r6
    37ee:	blx	r3
    37f0:	mov	r5, r0
    37f2:	cbnz	r0, 37f8 <FsCache::sync()+0x22>
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;

 fail:
  return false;
    37f4:	movs	r5, #0
    37f6:	b.n	381e <FsCache::sync()+0x48>
    if (!m_blockDev->writeSector(m_sector, m_buffer)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
    37f8:	ldrb	r3, [r4, #0]
    37fa:	lsls	r3, r3, #30
    37fc:	bmi.n	3808 <FsCache::sync()+0x32>
      if (!m_blockDev->writeSector(sector, m_buffer)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
    37fe:	ldrb	r3, [r4, #0]
    3800:	bic.w	r3, r3, #1
    3804:	strb	r3, [r4, #0]
    3806:	b.n	381e <FsCache::sync()+0x48>
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
      uint32_t sector = m_sector + m_mirrorOffset;
      if (!m_blockDev->writeSector(sector, m_buffer)) {
    3808:	adds	r0, r4, #4
    380a:	ldmia	r0, {r0, r1, r7}
    380c:	ldr	r3, [r0, #0]
    380e:	mov	r2, r6
    3810:	ldr	r3, [r3, #32]
    3812:	add	r1, r7
    3814:	blx	r3
    3816:	cmp	r0, #0
    3818:	bne.n	37fe <FsCache::sync()+0x28>
    381a:	b.n	37f4 <FsCache::sync()+0x1e>
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;
    381c:	movs	r5, #1

 fail:
  return false;
}
    381e:	mov	r0, r5
    3820:	pop	{r3, r4, r5, r6, r7, pc}

00003822 <FsCache::get(unsigned long, unsigned char)>:
#define DBG_FILE "FsCache.cpp"
#include "DebugMacros.h"
#include "FsCache.h"
//------------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
  if (!m_blockDev) {
    3822:	ldr	r3, [r0, #4]
 */
#define DBG_FILE "FsCache.cpp"
#include "DebugMacros.h"
#include "FsCache.h"
//------------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
    3824:	push	{r4, r5, r6, lr}
    3826:	mov	r4, r0
    3828:	mov	r6, r1
    382a:	mov	r5, r2
  if (!m_blockDev) {
    382c:	cbnz	r3, 3832 <FsCache::get(unsigned long, unsigned char)+0x10>
  }
  m_status |= option & CACHE_STATUS_MASK;
  return m_buffer;

 fail:
  return nullptr;
    382e:	movs	r0, #0
    3830:	pop	{r4, r5, r6, pc}
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
  if (!m_blockDev) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_sector != sector) {
    3832:	ldr	r3, [r0, #12]
    3834:	cmp	r3, r1
    3836:	beq.n	3860 <FsCache::get(unsigned long, unsigned char)+0x3e>
    if (!sync()) {
    3838:	bl	37d6 <FsCache::sync()>
    383c:	cmp	r0, #0
    383e:	beq.n	382e <FsCache::get(unsigned long, unsigned char)+0xc>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
    3840:	lsls	r3, r5, #29
    3842:	bpl.n	384c <FsCache::get(unsigned long, unsigned char)+0x2a>
      if (!m_blockDev->readSector(sector, m_buffer)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status = 0;
    3844:	movs	r3, #0
    3846:	strb	r3, [r4, #0]
    m_sector = sector;
    3848:	str	r6, [r4, #12]
    384a:	b.n	3860 <FsCache::get(unsigned long, unsigned char)+0x3e>
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
      if (!m_blockDev->readSector(sector, m_buffer)) {
    384c:	ldr	r0, [r4, #4]
    384e:	ldr	r3, [r0, #0]
    3850:	add.w	r2, r4, #16
    3854:	ldr	r3, [r3, #12]
    3856:	mov	r1, r6
    3858:	blx	r3
    385a:	cmp	r0, #0
    385c:	bne.n	3844 <FsCache::get(unsigned long, unsigned char)+0x22>
    385e:	b.n	382e <FsCache::get(unsigned long, unsigned char)+0xc>
      }
    }
    m_status = 0;
    m_sector = sector;
  }
  m_status |= option & CACHE_STATUS_MASK;
    3860:	ldrb	r3, [r4, #0]
    3862:	mov	r0, r4
    3864:	and.w	r5, r5, #3
    3868:	orrs	r5, r3
    386a:	strb.w	r5, [r0], #16
  return m_buffer;

 fail:
  return nullptr;
}
    386e:	pop	{r4, r5, r6, pc}

00003870 <toUpcase(unsigned short)>:
}
//------------------------------------------------------------------------------
uint16_t toUpcase(uint16_t chr) {
  uint16_t i, first;
  // Optimize for simple ASCII.
  if (chr < 127) {
    3870:	cmp	r0, #126	; 0x7e
    }
  }
  return left;
}
//------------------------------------------------------------------------------
uint16_t toUpcase(uint16_t chr) {
    3872:	push	{r4, r5, lr}
  uint16_t i, first;
  // Optimize for simple ASCII.
  if (chr < 127) {
    3874:	bhi.n	3884 <toUpcase(unsigned short)+0x14>
    return chr - ('a' <= chr && chr <= 'z' ? 'a' - 'A' : 0);
    3876:	sub.w	r3, r0, #97	; 0x61
    387a:	cmp	r3, #25
    387c:	ite	hi
    387e:	movhi	r3, #0
    3880:	movls	r3, #32
    3882:	b.n	38c6 <toUpcase(unsigned short)+0x56>
    3884:	ldr	r5, [pc, #132]	; (390c <toUpcase(unsigned short)+0x9c>)
    3886:	movs	r4, #53	; 0x35
    3888:	movs	r3, #0
//------------------------------------------------------------------------------
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    388a:	subs	r2, r4, r3
    388c:	cmp	r2, #1
    388e:	ldr	r1, [pc, #124]	; (390c <toUpcase(unsigned short)+0x9c>)
    3890:	bls.n	38a4 <toUpcase(unsigned short)+0x34>
    mid = left + (right - left)/2;
    3892:	add.w	r2, r3, r2, lsr #1
    if (readTable16(table[mid].key) <= key) {
    3896:	ldrh.w	r1, [r5, r2, lsl #2]
    389a:	cmp	r1, r0
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    mid = left + (right - left)/2;
    389c:	ite	hi
    389e:	movhi	r4, r2
    38a0:	movls	r3, r2
    38a2:	b.n	388a <toUpcase(unsigned short)+0x1a>
  // Optimize for simple ASCII.
  if (chr < 127) {
    return chr - ('a' <= chr && chr <= 'z' ? 'a' - 'A' : 0);
  }
  i = searchPair16(reinterpret_cast<const pair16_t*>(mapTable), MAP_DIM, chr);
  first = readTable16(mapTable[i].base);
    38a4:	uxth	r2, r3
    38a6:	ldrh.w	r3, [r1, r2, lsl #2]
  if (first <= chr && (chr - first)  < readTable8(mapTable[i].count)) {
    38aa:	cmp	r0, r3
    38ac:	bcc.n	38da <toUpcase(unsigned short)+0x6a>
    38ae:	add.w	r2, r1, r2, lsl #2
    38b2:	subs	r3, r0, r3
    38b4:	ldrb	r1, [r2, #3]
    38b6:	cmp	r3, r1
    38b8:	bge.n	38da <toUpcase(unsigned short)+0x6a>
    int8_t off = readTable8(mapTable[i].off);
    38ba:	ldrsb.w	r2, [r2, #2]
    if (off == 1) {
    38be:	cmp	r2, #1
    38c0:	bne.n	38ca <toUpcase(unsigned short)+0x5a>
      return chr - ((chr - first) & 1);
    38c2:	and.w	r3, r3, #1
    38c6:	subs	r0, r0, r3
    38c8:	b.n	38d6 <toUpcase(unsigned short)+0x66>
    }
    return chr + (off ? off : -0x1C60);
    38ca:	cbz	r2, 38d0 <toUpcase(unsigned short)+0x60>
    38cc:	uxth	r2, r2
    38ce:	b.n	38d4 <toUpcase(unsigned short)+0x64>
    38d0:	movw	r2, #58272	; 0xe3a0
    38d4:	add	r0, r2
    38d6:	uxth	r0, r0
    38d8:	pop	{r4, r5, pc}
    38da:	ldr	r5, [pc, #52]	; (3910 <toUpcase(unsigned short)+0xa0>)
    38dc:	movs	r4, #75	; 0x4b
    38de:	movs	r3, #0
//------------------------------------------------------------------------------
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    38e0:	subs	r2, r4, r3
    38e2:	cmp	r2, #1
    38e4:	ldr	r1, [pc, #40]	; (3910 <toUpcase(unsigned short)+0xa0>)
    38e6:	bls.n	38fa <toUpcase(unsigned short)+0x8a>
    mid = left + (right - left)/2;
    38e8:	add.w	r2, r3, r2, lsr #1
    if (readTable16(table[mid].key) <= key) {
    38ec:	ldrh.w	r1, [r5, r2, lsl #2]
    38f0:	cmp	r1, r0
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    mid = left + (right - left)/2;
    38f2:	ite	hi
    38f4:	movhi	r4, r2
    38f6:	movls	r3, r2
    38f8:	b.n	38e0 <toUpcase(unsigned short)+0x70>
      return chr - ((chr - first) & 1);
    }
    return chr + (off ? off : -0x1C60);
  }
  i = searchPair16(lookupTable, LOOKUP_DIM, chr);
  if (readTable16(lookupTable[i].key) == chr) {
    38fa:	uxth	r3, r3
    38fc:	ldrh.w	r2, [r1, r3, lsl #2]
    3900:	cmp	r2, r0
    return readTable16(lookupTable[i].val);
    3902:	itt	eq
    3904:	addeq.w	r3, r1, r3, lsl #2
    3908:	ldrheq	r0, [r3, #2]
  }
  return chr;
}
    390a:	pop	{r4, r5, pc}
    390c:	.word	0x00012c02
    3910:	.word	0x00012ad6

00003914 <FsName::get16()>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsName.h"
#include "FsUtf.h"
#if USE_UTF8_LONG_NAMES
uint16_t FsName::get16() {
    3914:	push	{r0, r1, r4, lr}
    3916:	mov	r4, r0
  uint16_t rtn;
  if (ls) {
    3918:	ldrh	r0, [r0, #12]
    391a:	cbz	r0, 3922 <FsName::get16()+0xe>
    rtn = ls;
    ls = 0;
    391c:	movs	r3, #0
    391e:	strh	r3, [r4, #12]
    3920:	b.n	3958 <FsName::get16()+0x44>
  } else if (next >= end) {
    3922:	ldr	r3, [r4, #4]
    3924:	ldr	r1, [r4, #8]
    3926:	cmp	r3, r1
    3928:	bcs.n	3958 <FsName::get16()+0x44>
    rtn = 0;
  } else {
    uint32_t cp;
    const char* ptr = FsUtf::mbToCp(next, end, &cp);
    392a:	add	r2, sp, #4
    392c:	mov	r0, r3
    392e:	bl	3514 <FsUtf::mbToCp(char const*, char const*, unsigned long*)>
    if (!ptr) {
    3932:	cbz	r0, 3954 <FsName::get16()+0x40>
      goto fail;
    }
    next = ptr;
    3934:	str	r0, [r4, #4]
    if (cp <= 0XFFFF) {
    3936:	ldr	r0, [sp, #4]
    3938:	cmp.w	r0, #65536	; 0x10000
      rtn = cp;
    } else {
      ls = FsUtf::lowSurrogate(cp);
    393c:	itttt	cs
    393e:	ubfxcs	r3, r0, #0, #10
  /** High surrogate for a code point.
   * \param{in} cp code point.
   * \return high surrogate.
   */
  inline uint16_t highSurrogate(uint32_t cp) {
    return (cp >> 10) + (0XD800 - (0X10000 >> 10));
    3942:	lsrcs	r0, r0, #10
    3944:	subcs.w	r3, r3, #9216	; 0x2400
    3948:	subcs.w	r0, r0, #10304	; 0x2840
    394c:	it	cs
    394e:	strhcs	r3, [r4, #12]
    3950:	uxth	r0, r0
    3952:	b.n	3958 <FsName::get16()+0x44>
    }
  }
  return rtn;

 fail:
  return 0XFFFF;
    3954:	movw	r0, #65535	; 0xffff
}
    3958:	add	sp, #8
    395a:	pop	{r4, pc}

0000395c <ExFatFormatter::syncUpcase()>:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::syncUpcase() {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    395c:	ldr	r3, [r0, #8]
    395e:	ubfx	r3, r3, #0, #9
 fail:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::syncUpcase() {
    3962:	mov	r1, r0
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  if (!index) {
    3964:	cbz	r3, 3980 <ExFatFormatter::syncUpcase()+0x24>
    return true;
  }
  for (size_t i = index; i < BYTES_PER_SECTOR; i++) {
    m_secBuf[i] = 0;
    3966:	movs	r0, #0
    3968:	ldr	r2, [r1, #16]
    396a:	strb	r0, [r2, r3]
bool ExFatFormatter::syncUpcase() {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  if (!index) {
    return true;
  }
  for (size_t i = index; i < BYTES_PER_SECTOR; i++) {
    396c:	adds	r3, #1
    396e:	cmp.w	r3, #512	; 0x200
    3972:	bne.n	3968 <ExFatFormatter::syncUpcase()+0xc>
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
    3974:	ldr	r0, [r1, #12]
    3976:	ldr	r2, [r1, #16]
    3978:	ldr	r3, [r0, #0]
    397a:	ldr	r1, [r1, #0]
    397c:	ldr	r3, [r3, #32]
    397e:	bx	r3
}
    3980:	movs	r0, #1
    3982:	bx	lr

00003984 <ExFatFormatter::writeUpcaseByte(unsigned char)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    3984:	ldr	r2, [r0, #8]
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
    3986:	mov	r3, r0
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    3988:	ubfx	r2, r2, #0, #9
  m_secBuf[index] = b;
    398c:	ldr	r0, [r0, #16]
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
    398e:	push	{r4}
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  m_secBuf[index] = b;
    3990:	strb	r1, [r0, r2]
  m_upcaseChecksum = exFatChecksum(m_upcaseChecksum, b);
    3992:	ldr	r0, [r3, #4]
    3994:	add.w	r1, r1, r0, ror #1
    3998:	str	r1, [r3, #4]
  m_upcaseSize++;
    399a:	ldr	r1, [r3, #8]
    399c:	adds	r1, #1
    399e:	str	r1, [r3, #8]
  if (index == SECTOR_MASK) {
    39a0:	movw	r1, #511	; 0x1ff
    39a4:	cmp	r2, r1
    39a6:	bne.n	39be <ExFatFormatter::writeUpcaseByte(unsigned char)+0x3a>
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
    39a8:	ldr	r0, [r3, #12]
    39aa:	ldr	r1, [r3, #0]
    39ac:	ldr	r2, [r0, #0]
    39ae:	ldr	r4, [r2, #32]
    39b0:	adds	r2, r1, #1
    39b2:	str	r2, [r3, #0]
    39b4:	ldr	r2, [r3, #16]
    39b6:	mov	r3, r4
  }
  return true;
}
    39b8:	ldr.w	r4, [sp], #4
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  m_secBuf[index] = b;
  m_upcaseChecksum = exFatChecksum(m_upcaseChecksum, b);
  m_upcaseSize++;
  if (index == SECTOR_MASK) {
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
    39bc:	bx	r3
  }
  return true;
}
    39be:	movs	r0, #1
    39c0:	ldr.w	r4, [sp], #4
    39c4:	bx	lr

000039c6 <ExFatFormatter::writeUpcaseUnicode(unsigned short)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
    39c6:	push	{r3, r4, r5, lr}
    39c8:	mov	r4, r1
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    39ca:	uxtb	r1, r1
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
  }
  return true;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
    39cc:	mov	r5, r0
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    39ce:	bl	3984 <ExFatFormatter::writeUpcaseByte(unsigned char)>
    39d2:	cbz	r0, 39e0 <ExFatFormatter::writeUpcaseUnicode(unsigned short)+0x1a>
    39d4:	lsrs	r1, r4, #8
    39d6:	mov	r0, r5
}
    39d8:	ldmia.w	sp!, {r3, r4, r5, lr}
  }
  return true;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    39dc:	b.w	3984 <ExFatFormatter::writeUpcaseByte(unsigned char)>
}
    39e0:	pop	{r3, r4, r5, pc}

000039e2 <ExFatFormatter::writeUpcase(unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcase(uint32_t sector) {
    39e2:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t n;
  uint32_t ns;
  uint32_t ch = 0;
  uint16_t uc;

  m_upcaseSize = 0;
    39e4:	movs	r4, #0
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;
    39e6:	stmia.w	r0, {r1, r4}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcase(uint32_t sector) {
    39ea:	mov	r7, r0
  uint32_t n;
  uint32_t ns;
  uint32_t ch = 0;
  uint16_t uc;

  m_upcaseSize = 0;
    39ec:	str	r4, [r0, #8]
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    uc = toUpcase(ch);
    39ee:	uxth	r0, r4
    39f0:	bl	3870 <toUpcase(unsigned short)>
    if (uc != ch) {
    39f4:	cmp	r0, r4
  m_upcaseSize = 0;
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    uc = toUpcase(ch);
    39f6:	mov	r6, r0
    if (uc != ch) {
    39f8:	beq.n	3a10 <ExFatFormatter::writeUpcase(unsigned long)+0x2e>
      if (!writeUpcaseUnicode(uc)) {
    39fa:	mov	r1, r0
    39fc:	mov	r0, r7
    39fe:	bl	39c6 <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    3a02:	cbz	r0, 3a6e <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    3a04:	adds	r5, r4, #1

  m_upcaseSize = 0;
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    3a06:	cmp.w	r5, #65536	; 0x10000
    3a0a:	bcs.n	3a24 <ExFatFormatter::writeUpcase(unsigned long)+0x42>
    3a0c:	mov	r4, r5
    3a0e:	b.n	39ee <ExFatFormatter::writeUpcase(unsigned long)+0xc>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
    3a10:	adds	r5, r4, #1
    3a12:	cmp.w	r5, #65536	; 0x10000
    3a16:	bcs.n	3a2e <ExFatFormatter::writeUpcase(unsigned long)+0x4c>
    3a18:	uxth	r0, r5
    3a1a:	bl	3870 <toUpcase(unsigned short)>
    3a1e:	cmp	r5, r0
    3a20:	bne.n	3a2e <ExFatFormatter::writeUpcase(unsigned long)+0x4c>
    3a22:	b.n	3a6a <ExFatFormatter::writeUpcase(unsigned long)+0x88>
          }
        }
      }
    }
  }
  if (!syncUpcase()) {
    3a24:	mov	r0, r7
  }
  return true;

 fail:
  return false;
}
    3a26:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
          }
        }
      }
    }
  }
  if (!syncUpcase()) {
    3a2a:	b.w	395c <ExFatFormatter::syncUpcase()>
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
      ns = n - ch;
    3a2e:	subs	r4, r5, r4
      if (ns >= MINIMUM_UPCASE_SKIP) {
    3a30:	cmp.w	r4, #512	; 0x200
    3a34:	bcc.n	3a50 <ExFatFormatter::writeUpcase(unsigned long)+0x6e>
        if (!writeUpcaseUnicode(0XFFFF) || !writeUpcaseUnicode(ns)) {
    3a36:	movw	r1, #65535	; 0xffff
    3a3a:	mov	r0, r7
    3a3c:	bl	39c6 <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    3a40:	cbz	r0, 3a6e <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
    3a42:	uxth	r1, r4
    3a44:	mov	r0, r7
    3a46:	bl	39c6 <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    3a4a:	cmp	r0, #0
    3a4c:	bne.n	3a06 <ExFatFormatter::writeUpcase(unsigned long)+0x24>
    3a4e:	b.n	3a6e <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
      ns = n - ch;
      if (ns >= MINIMUM_UPCASE_SKIP) {
    3a50:	mov	r4, r6
          DBG_FAIL_MACRO;
          goto fail;
        }
        ch = n;
      } else {
        while (ch < n) {
    3a52:	cmp	r5, r4
    3a54:	bhi.n	3a5a <ExFatFormatter::writeUpcase(unsigned long)+0x78>
    3a56:	mov	r5, r4
    3a58:	b.n	3a06 <ExFatFormatter::writeUpcase(unsigned long)+0x24>
          if (!writeUpcaseUnicode(ch++)) {
    3a5a:	uxth	r1, r4
    3a5c:	mov	r0, r7
    3a5e:	bl	39c6 <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    3a62:	adds	r4, #1
    3a64:	cmp	r0, #0
    3a66:	bne.n	3a52 <ExFatFormatter::writeUpcase(unsigned long)+0x70>
    3a68:	b.n	3a6e <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
    3a6a:	adds	r5, #1
    3a6c:	b.n	3a12 <ExFatFormatter::writeUpcase(unsigned long)+0x30>
  }
  return true;

 fail:
  return false;
}
    3a6e:	movs	r0, #0
    3a70:	pop	{r3, r4, r5, r6, r7, pc}
    3a72:	Address 0x00003a72 is out of bounds.


00003a74 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>:
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    3a74:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3a78:	mov	r7, r3
  uint32_t volumeLength;
  uint32_t sectorCount;
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
    3a7a:	mov	r3, r0
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    3a7c:	sub	sp, #28
  uint32_t volumeLength;
  uint32_t sectorCount;
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
    3a7e:	str	r1, [r3, #12]
  m_secBuf = secBuf;
    3a80:	str	r2, [r3, #16]
  sectorCount = dev->sectorCount();
    3a82:	ldr	r3, [r1, #0]
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    3a84:	str	r0, [sp, #4]
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    3a86:	ldr	r3, [r3, #24]
    3a88:	mov	r0, r1
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    3a8a:	mov	r5, r1
    3a8c:	mov	r4, r2
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    3a8e:	blx	r3
  // Min size is 512 MB
  if (sectorCount < 0X100000) {
    3a90:	cmp.w	r0, #1048576	; 0x100000
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    3a94:	mov	r9, r0
  // Min size is 512 MB
  if (sectorCount < 0X100000) {
    3a96:	bcs.n	3aa8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x34>
    writeMsg(pr, "Device is too small\r\n");
    3a98:	cmp	r7, #0
    3a9a:	beq.w	3cc2 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x24e>
    3a9e:	ldr	r1, [pc, #584]	; (3ce8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x274>)
    3aa0:	mov	r0, r7
    3aa2:	bl	760 <Print::write(char const*)>
    3aa6:	b.n	3cba <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x246>
    3aa8:	movs	r6, #0
    3aaa:	movs	r3, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
    3aac:	adds	r6, #1
    3aae:	uxtb	r6, r6
    3ab0:	cmp	r6, #32
    3ab2:	mov.w	r3, r3, lsl #1
    3ab6:	beq.n	3ac4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x50>
    3ab8:	cmp	r9, r3
    3aba:	bhi.n	3aac <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x38>
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
    3abc:	cmp	r6, #28
    3abe:	bhi.n	3ac4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x50>
    3ac0:	movs	r3, #8
    3ac2:	b.n	3acc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x58>
    3ac4:	sub.w	r8, r6, #11
    3ac8:	ubfx	r3, r8, #1, #8
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
    3acc:	cmp	r6, #26
    3ace:	it	hi
    3ad0:	addhi	r6, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
    3ad2:	str	r3, [sp, #8]
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
    3ad4:	ittte	hi
    3ad6:	asrhi	r6, r6, #1
    3ad8:	movhi	r3, #1
    3ada:	lslhi	r3, r6
    3adc:	movls.w	r3, #8192	; 0x2000
    3ae0:	str	r3, [sp, #0]
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
    3ae2:	ldr	r3, [sp, #0]
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    3ae4:	ldr	r2, [sp, #8]
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
    3ae6:	lsls	r6, r3, #1
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
    3ae8:	lsls	r3, r3, #2
    3aea:	rsb	sl, r3, r9
    3aee:	str	r3, [sp, #16]
    3af0:	ldr	r3, [sp, #8]
    3af2:	lsr.w	r3, sl, r3
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    3af6:	lsl.w	sl, r3, r2

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3afa:	movs	r1, #0
    3afc:	mov.w	r2, #512	; 0x200
    3b00:	mov	r0, r4
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
    3b02:	str	r3, [sp, #12]
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3b04:	bl	9078 <memset>
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
  mbr->part->type = 7;
    3b08:	movs	r3, #7
    3b0a:	strb.w	r3, [r4, #450]	; 0x1c2
  mbr->part->endCHS[0] = 0XFE;
    3b0e:	movs	r3, #254	; 0xfe
    3b10:	strb.w	r3, [r4, #451]	; 0x1c3
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
    3b14:	mov.w	fp, #1
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
  mbr->part->type = 7;
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
    3b18:	movs	r3, #255	; 0xff
  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
    3b1a:	mov.w	r8, #0
  mbr->part->type = 7;
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
    3b1e:	strb.w	r3, [r4, #452]	; 0x1c4
  mbr->part->endCHS[2] = 0XFF;
    3b22:	strb.w	r3, [r4, #453]	; 0x1c5
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
    3b26:	strb.w	fp, [r4, #447]	; 0x1bf
  mbr->part->beginCHS[1] = 1;
    3b2a:	strb.w	fp, [r4, #448]	; 0x1c0
  mbr->part->beginCHS[2] = 0;
    3b2e:	strb.w	r8, [r4, #449]	; 0x1c1
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3b32:	movw	r3, #43605	; 0xaa55
    3b36:	strh.w	r3, [r4, #510]	; 0x1fe
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
  setLe32(mbr->part->relativeSectors, partitionOffset);
  setLe32(mbr->part->totalSectors, volumeLength);
  setLe16(mbr->signature, MBR_SIGNATURE);
  if (!dev->writeSector(0, secBuf)) {
    3b3a:	ldr	r3, [r5, #0]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3b3c:	str.w	r6, [r4, #454]	; 0x1c6
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    3b40:	add	sl, r6
    3b42:	str.w	sl, [r4, #458]	; 0x1ca
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
  setLe32(mbr->part->relativeSectors, partitionOffset);
  setLe32(mbr->part->totalSectors, volumeLength);
  setLe16(mbr->signature, MBR_SIGNATURE);
  if (!dev->writeSector(0, secBuf)) {
    3b46:	ldr	r3, [r3, #32]
    3b48:	mov	r2, r4
    3b4a:	mov	r1, r8
    3b4c:	mov	r0, r5
    3b4e:	blx	r3
    3b50:	cmp	r0, #0
    3b52:	beq.w	3cb8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Partition Boot sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3b56:	mov.w	r2, #512	; 0x200
    3b5a:	mov	r1, r8
    3b5c:	mov	r0, r4
    3b5e:	bl	9078 <memset>
  pbs = reinterpret_cast<ExFatPbs_t*>(secBuf);
  pbs->jmpInstruction[0] = 0XEB;
    3b62:	movs	r3, #235	; 0xeb
    3b64:	strb	r3, [r4, #0]
  pbs->jmpInstruction[1] = 0X76;
    3b66:	movs	r3, #118	; 0x76
    3b68:	strb	r3, [r4, #1]
  pbs->jmpInstruction[2] = 0X90;
    3b6a:	movs	r3, #144	; 0x90
    3b6c:	strb	r3, [r4, #2]
  pbs->oemName[0] = 'E';
    3b6e:	movs	r3, #69	; 0x45
    3b70:	strb	r3, [r4, #3]
  pbs->oemName[1] = 'X';
    3b72:	movs	r3, #88	; 0x58
    3b74:	strb	r3, [r4, #4]
  pbs->oemName[2] = 'F';
    3b76:	movs	r3, #70	; 0x46
    3b78:	strb	r3, [r4, #5]
  pbs->oemName[3] = 'A';
    3b7a:	movs	r3, #65	; 0x41
    3b7c:	strb	r3, [r4, #6]
  pbs->oemName[4] = 'T';
    3b7e:	movs	r3, #84	; 0x54
    3b80:	strb	r3, [r4, #7]
  pbs->oemName[5] = ' ';
    3b82:	movs	r3, #32
    3b84:	strb	r3, [r4, #8]
  pbs->oemName[6] = ' ';
    3b86:	strb	r3, [r4, #9]
  pbs->oemName[7] = ' ';
    3b88:	strb	r3, [r4, #10]
    3b8a:	ldr	r3, [sp, #0]
    3b8c:	str	r3, [r4, #80]	; 0x50
    3b8e:	str	r3, [r4, #84]	; 0x54
    3b90:	ldr	r3, [sp, #12]
    3b92:	str	r3, [r4, #92]	; 0x5c
    3b94:	movs	r3, #4
    3b96:	str	r3, [r4, #96]	; 0x60
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3b98:	mov.w	r3, #256	; 0x100
    3b9c:	strh.w	r3, [r4, #104]	; 0x68
  setLe32(pbs->bpb.clusterCount, clusterCount);
  setLe32(pbs->bpb.rootDirectoryCluster, ROOT_CLUSTER);
  setLe32(pbs->bpb.volumeSerialNumber, sectorCount);
  setLe16(pbs->bpb.fileSystemRevision, 0X100);
  setLe16(pbs->bpb.volumeFlags, 0);
  pbs->bpb.bytesPerSectorShift = BYTES_PER_SECTOR_SHIFT;
    3ba0:	movs	r3, #9
    3ba2:	strb.w	r3, [r4, #108]	; 0x6c
  pbs->bpb.sectorsPerClusterShift = sectorsPerClusterShift;
    3ba6:	ldrb.w	r3, [sp, #8]
    3baa:	strb.w	r3, [r4, #109]	; 0x6d
  pbs->bpb.numberOfFats = 1;
  pbs->bpb.driveSelect = 0X80;
    3bae:	movs	r3, #128	; 0x80
    3bb0:	strb.w	r3, [r4, #111]	; 0x6f

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    3bb4:	str	r6, [r4, #64]	; 0x40
    3bb6:	str.w	r8, [r4, #68]	; 0x44
    3bba:	str.w	sl, [r4, #72]	; 0x48
    3bbe:	str.w	r8, [r4, #76]	; 0x4c
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3bc2:	str	r6, [r4, #88]	; 0x58
    3bc4:	str.w	r9, [r4, #100]	; 0x64
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3bc8:	strh.w	r8, [r4, #106]	; 0x6a
  setLe32(pbs->bpb.volumeSerialNumber, sectorCount);
  setLe16(pbs->bpb.fileSystemRevision, 0X100);
  setLe16(pbs->bpb.volumeFlags, 0);
  pbs->bpb.bytesPerSectorShift = BYTES_PER_SECTOR_SHIFT;
  pbs->bpb.sectorsPerClusterShift = sectorsPerClusterShift;
  pbs->bpb.numberOfFats = 1;
    3bcc:	strb.w	fp, [r4, #110]	; 0x6e
  pbs->bpb.driveSelect = 0X80;
  pbs->bpb.percentInUse = 0;
    3bd0:	strb.w	r8, [r4, #112]	; 0x70
    3bd4:	add.w	r3, r4, #119	; 0x77
    3bd8:	addw	r2, r4, #509	; 0x1fd

  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
    3bdc:	movs	r1, #244	; 0xf4
    3bde:	strb.w	r1, [r3, #1]!
  pbs->bpb.numberOfFats = 1;
  pbs->bpb.driveSelect = 0X80;
  pbs->bpb.percentInUse = 0;

  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    3be2:	cmp	r3, r2
    3be4:	bne.n	3bde <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x16a>
    3be6:	movw	r3, #43605	; 0xaa55
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    3bea:	mov.w	r9, #0
    3bee:	strh.w	r3, [r4, #510]	; 0x1fe
  ExFatPbs_t* pbs;
  DirUpcase_t* dup;
  DirBitmap_t* dbm;
  DirLabel_t* label;
  uint32_t bitmapSize;
  uint32_t checksum = 0;
    3bf2:	mov	r8, r9
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    if (i == offsetof(ExFatPbs_t, bpb.volumeFlags[0]) ||
    3bf4:	sub.w	r3, r9, #106	; 0x6a
    3bf8:	cmp	r3, #1
    3bfa:	bls.n	3c0a <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x196>
        i == offsetof(ExFatPbs_t, bpb.volumeFlags[1]) ||
    3bfc:	cmp.w	r9, #112	; 0x70
  uint8_t  mustBeZero2[2];
  uint8_t  unicode3[4];
} DirLfn_t;
//=============================================================================
inline uint32_t exFatChecksum(uint32_t sum, uint8_t data) {
  return (sum << 31) + (sum >> 1) + data;
    3c00:	itt	ne
    3c02:	ldrbne.w	r3, [r4, r9]
    3c06:	addne.w	r8, r3, r8, ror #1
  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    3c0a:	add.w	r9, r9, #1
    3c0e:	cmp.w	r9, #512	; 0x200
    3c12:	bne.n	3bf4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x180>
      continue;
    }
    checksum = exFatChecksum(checksum, secBuf[i]);
  }
  sector = partitionOffset;
  if (!dev->writeSector(sector, secBuf)  ||
    3c14:	ldr	r3, [r5, #0]
    3c16:	mov	r2, r4
    3c18:	ldr	r3, [r3, #32]
    3c1a:	mov	r1, r6
    3c1c:	mov	r0, r5
    3c1e:	blx	r3
    3c20:	cmp	r0, #0
    3c22:	beq.n	3cb8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3c24:	ldr	r3, [r5, #0]
    3c26:	mov	r2, r4
    3c28:	ldr	r3, [r3, #32]
    3c2a:	add.w	r1, r6, #12
    3c2e:	mov	r0, r5
    3c30:	blx	r3
      continue;
    }
    checksum = exFatChecksum(checksum, secBuf[i]);
  }
  sector = partitionOffset;
  if (!dev->writeSector(sector, secBuf)  ||
    3c32:	cmp	r0, #0
    3c34:	beq.n	3cb8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3c36:	mov	r2, r9
    3c38:	movs	r1, #0
    3c3a:	mov	r0, r4
    3c3c:	bl	9078 <memset>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3c40:	movw	r3, #43605	; 0xaa55
    3c44:	strh.w	r3, [r4, #510]	; 0x1fe
    3c48:	subs	r3, r4, #1
  if (!dev->writeSector(sector, secBuf)  ||
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector++;
    3c4a:	add.w	sl, r6, #1
    3c4e:	add.w	r9, r6, #9
    3c52:	str	r3, [sp, #20]
    3c54:	addw	fp, r4, #511	; 0x1ff
  ExFatPbs_t* pbs;
  DirUpcase_t* dup;
  DirBitmap_t* dbm;
  DirLabel_t* label;
  uint32_t bitmapSize;
  uint32_t checksum = 0;
    3c58:	ldr	r3, [sp, #20]
  uint8_t  mustBeZero2[2];
  uint8_t  unicode3[4];
} DirLfn_t;
//=============================================================================
inline uint32_t exFatChecksum(uint32_t sum, uint8_t data) {
  return (sum << 31) + (sum >> 1) + data;
    3c5a:	ldrb.w	r2, [r3, #1]!
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    3c5e:	cmp	fp, r3
    3c60:	add.w	r8, r2, r8, ror #1
    3c64:	bne.n	3c5a <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x1e6>
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    3c66:	ldr	r3, [r5, #0]
    3c68:	mov	r2, r4
    3c6a:	ldr	r3, [r3, #32]
    3c6c:	mov	r1, sl
    3c6e:	mov	r0, r5
    3c70:	blx	r3
    3c72:	cbz	r0, 3cb8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3c74:	ldr	r3, [r5, #0]
    3c76:	mov	r2, r4
    3c78:	ldr	r3, [r3, #32]
    3c7a:	add.w	r1, sl, #12
    3c7e:	mov	r0, r5
    3c80:	blx	r3
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    3c82:	cbz	r0, 3cb8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    sector++;
    3c84:	add.w	sl, sl, #1
  }
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    3c88:	cmp	sl, r9
    3c8a:	bne.n	3c58 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x1e4>
      goto fail;
    }
    sector++;
  }
  // Write OEM Parameter Sector and reserved sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3c8c:	mov.w	r2, #512	; 0x200
    3c90:	movs	r1, #0
    3c92:	mov	r0, r4
    3c94:	bl	9078 <memset>
    3c98:	add.w	sl, r6, #11
    3c9c:	ldr	r3, [sp, #20]
    3c9e:	ldrb.w	r2, [r3, #1]!
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    3ca2:	cmp	fp, r3
    3ca4:	add.w	r8, r2, r8, ror #1
    3ca8:	bne.n	3c9e <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x22a>
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    3caa:	ldr	r3, [r5, #0]
    3cac:	mov	r2, r4
    3cae:	ldr	r3, [r3, #32]
    3cb0:	mov	r1, r9
    3cb2:	mov	r0, r5
    3cb4:	blx	r3
    3cb6:	cbnz	r0, 3cc8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x254>
  }
  writeMsg(pr, "Format done\r\n");
  return true;

 fail:
  writeMsg(pr, "Format failed\r\n");
    3cb8:	cbz	r7, 3cc2 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x24e>
    3cba:	ldr	r1, [pc, #48]	; (3cec <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x278>)
    3cbc:	mov	r0, r7
    3cbe:	bl	760 <Print::write(char const*)>
  return false;
    3cc2:	mov.w	sl, #0
    3cc6:	b.n	3eac <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x438>
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3cc8:	ldr	r3, [r5, #0]
    3cca:	mov	r2, r4
    3ccc:	ldr	r3, [r3, #32]
    3cce:	add.w	r1, r9, #12
    3cd2:	mov	r0, r5
    3cd4:	blx	r3
  memset(secBuf, 0, BYTES_PER_SECTOR);
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    3cd6:	cmp	r0, #0
    3cd8:	beq.n	3cb8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    sector++;
    3cda:	add.w	r3, r9, #1
    }
    sector++;
  }
  // Write OEM Parameter Sector and reserved sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  for (int j = 0; j < 2; j++) {
    3cde:	cmp	r3, sl
    3ce0:	beq.n	3cf0 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x27c>
    3ce2:	mov	r9, r3
    3ce4:	b.n	3c9c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x228>
    3ce6:	nop
    3ce8:	.word	0x00012cd6
    3cec:	.word	0x00012d2f
    3cf0:	subs	r3, r4, #4
    3cf2:	add.w	r2, r4, #508	; 0x1fc
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3cf6:	str.w	r8, [r3, #4]!
      goto fail;
    }
    sector++;
  }
  // Write Boot CheckSum Sector.
  for (size_t i = 0; i < BYTES_PER_SECTOR; i += 4) {
    3cfa:	cmp	r2, r3
    3cfc:	bne.n	3cf6 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x282>
    setLe32(secBuf + i, checksum);
  }
  if (!dev->writeSector(sector, secBuf)  ||
    3cfe:	ldr	r3, [r5, #0]
    3d00:	mov	r2, r4
    3d02:	ldr	r3, [r3, #32]
    3d04:	mov	r1, sl
    3d06:	mov	r0, r5
    3d08:	blx	r3
    3d0a:	cmp	r0, #0
    3d0c:	beq.n	3cb8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3d0e:	ldr	r3, [r5, #0]
    3d10:	mov	r2, r4
    3d12:	ldr	r3, [r3, #32]
    3d14:	add.w	r1, r9, #13
    3d18:	mov	r0, r5
    3d1a:	blx	r3
  }
  // Write Boot CheckSum Sector.
  for (size_t i = 0; i < BYTES_PER_SECTOR; i += 4) {
    setLe32(secBuf + i, checksum);
  }
  if (!dev->writeSector(sector, secBuf)  ||
    3d1c:	cmp	r0, #0
    3d1e:	beq.n	3cb8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
    3d20:	cbz	r7, 3d2a <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2b6>
    3d22:	ldr	r1, [pc, #400]	; (3eb4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x440>)
    3d24:	mov	r0, r7
    3d26:	bl	760 <Print::write(char const*)>
  sector = partitionOffset + fatOffset;
    3d2a:	ldr	r3, [sp, #0]
    3d2c:	add	r6, r3
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3d2e:	ldr	r3, [sp, #12]

  memset(secBuf, 0, BYTES_PER_SECTOR);
    3d30:	mov.w	r2, #512	; 0x200
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3d34:	mov.w	r9, r3, lsl #2

  memset(secBuf, 0, BYTES_PER_SECTOR);
    3d38:	movs	r1, #0
    3d3a:	mov	r0, r4
    3d3c:	bl	9078 <memset>
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3d40:	addw	r9, r9, #519	; 0x207

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
    3d44:	movs	r3, #248	; 0xf8
    3d46:	strb	r3, [r4, #0]
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3d48:	mov.w	sl, r9, lsr #9
    3d4c:	mov	r3, r4
    3d4e:	add.w	r2, r4, #19

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    secBuf[i] = 0XFF;
    3d52:	movs	r1, #255	; 0xff
    3d54:	strb.w	r1, [r3, #1]!
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    3d58:	cmp	r2, r3
    3d5a:	bne.n	3d54 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2e0>
    secBuf[i] = 0XFF;
  }
  for (uint32_t i = 0; i < ns; i++) {
    if (i%(ns/32) == 0) {
    3d5c:	mov.w	r9, r9, lsr #14
    3d60:	mov.w	r8, #0
    3d64:	udiv	r3, r8, r9
    3d68:	mls	r3, r9, r3, r8
    3d6c:	cbnz	r3, 3d78 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x304>
      writeMsg(pr, ".");
    3d6e:	cbz	r7, 3d78 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x304>
    3d70:	ldr	r1, [pc, #324]	; (3eb8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x444>)
    3d72:	mov	r0, r7
    3d74:	bl	760 <Print::write(char const*)>
    }
    if (!dev->writeSector(sector + i, secBuf)) {
    3d78:	ldr	r3, [r5, #0]
    3d7a:	mov	r2, r4
    3d7c:	ldr	r3, [r3, #32]
    3d7e:	add.w	r1, r6, r8
    3d82:	mov	r0, r5
    3d84:	blx	r3
    3d86:	cmp	r0, #0
    3d88:	beq.n	3cb8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    3d8a:	cmp.w	r8, #0
    3d8e:	bne.n	3d9c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x328>
      memset(secBuf, 0, BYTES_PER_SECTOR);
    3d90:	mov.w	r2, #512	; 0x200
    3d94:	mov	r1, r8
    3d96:	mov	r0, r4
    3d98:	bl	9078 <memset>
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    secBuf[i] = 0XFF;
  }
  for (uint32_t i = 0; i < ns; i++) {
    3d9c:	add.w	r8, r8, #1
    3da0:	cmp	sl, r8
    3da2:	bne.n	3d64 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2f0>
    }
    if (i == 0) {
      memset(secBuf, 0, BYTES_PER_SECTOR);
    }
  }
  writeMsg(pr, "\r\n");
    3da4:	cbz	r7, 3dae <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x33a>
    3da6:	ldr	r1, [pc, #276]	; (3ebc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x448>)
    3da8:	mov	r0, r7
    3daa:	bl	760 <Print::write(char const*)>
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
    3dae:	ldr	r3, [sp, #8]
    3db0:	mov.w	r8, #1
    3db4:	lsl.w	r8, r8, r3
    }
  }
  writeMsg(pr, "\r\n");
  // Write cluster two, bitmap.
  sector = partitionOffset + clusterHeapOffset;
  bitmapSize = (clusterCount + 7)/8;
    3db8:	ldr	r3, [sp, #12]
    3dba:	add.w	sl, r3, #7
    3dbe:	mov.w	sl, sl, lsr #3
  ns = (bitmapSize + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3dc2:	addw	fp, sl, #511	; 0x1ff
    3dc6:	mov.w	fp, fp, lsr #9
  if (ns > sectorsPerCluster) {
    3dca:	cmp	r8, fp
    3dcc:	bcc.w	3cb8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3dd0:	mov.w	r2, #512	; 0x200
    3dd4:	movs	r1, #0
    3dd6:	mov	r0, r4
    3dd8:	bl	9078 <memset>
  // Allocate clusters for bitmap, upcase, and root.
  secBuf[0] = 0X7;
    3ddc:	movs	r3, #7
    3dde:	strb	r3, [r4, #0]
  for (uint32_t i = 0; i < ns; i++) {
    3de0:	mov.w	r9, #0
    if (!dev->writeSector(sector + i, secBuf)) {
    3de4:	ldr	r3, [r5, #0]
    3de6:	ldr	r1, [sp, #16]
    3de8:	ldr	r3, [r3, #32]
    3dea:	mov	r2, r4
    3dec:	add	r1, r9
    3dee:	mov	r0, r5
    3df0:	blx	r3
    3df2:	cmp	r0, #0
    3df4:	beq.w	3cb8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    3df8:	cmp.w	r9, #0
    3dfc:	bne.n	3e02 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x38e>
      secBuf[0] = 0;
    3dfe:	strb.w	r9, [r4]
    goto fail;
  }
  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate clusters for bitmap, upcase, and root.
  secBuf[0] = 0X7;
  for (uint32_t i = 0; i < ns; i++) {
    3e02:	add.w	r9, r9, #1
    3e06:	cmp	fp, r9
    3e08:	bne.n	3de4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x370>
    if (i == 0) {
      secBuf[0] = 0;
    }
  }
  // Write cluster three, upcase table.
  writeMsg(pr, "Writing upcase table\r\n");
    3e0a:	cbz	r7, 3e14 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3a0>
    3e0c:	ldr	r1, [pc, #176]	; (3ec0 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x44c>)
    3e0e:	mov	r0, r7
    3e10:	bl	760 <Print::write(char const*)>
  if (!writeUpcase(partitionOffset + clusterHeapOffset + sectorsPerCluster)) {
    3e14:	ldr	r3, [sp, #0]
    3e16:	ldr	r0, [sp, #4]
    3e18:	add	r3, r6
    3e1a:	add.w	r9, r3, r8
    3e1e:	mov	r1, r9
    3e20:	bl	39e2 <ExFatFormatter::writeUpcase(unsigned long)>
    3e24:	cmp	r0, #0
    3e26:	beq.w	3cb8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_upcaseSize > BYTES_PER_SECTOR*sectorsPerCluster) {
    3e2a:	ldr	r3, [sp, #4]
    3e2c:	ldr	r3, [r3, #8]
    3e2e:	cmp.w	r3, r8, lsl #9
    3e32:	bhi.w	3cb8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Initialize first sector of root.
  writeMsg(pr, "Writing root\r\n");
    3e36:	cbz	r7, 3e40 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3cc>
    3e38:	ldr	r1, [pc, #136]	; (3ec4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x450>)
    3e3a:	mov	r0, r7
    3e3c:	bl	760 <Print::write(char const*)>
  ns = sectorsPerCluster;
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3e40:	mov.w	r2, #512	; 0x200
    3e44:	movs	r1, #0
    3e46:	mov	r0, r4
    3e48:	bl	9078 <memset>
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;

  // bitmap directory entry.
  dbm = reinterpret_cast<DirBitmap_t*>(secBuf + 32);
  dbm->type = EXFAT_TYPE_BITMAP;
    3e4c:	movs	r2, #129	; 0x81
    3e4e:	strb.w	r2, [r4, #32]
    3e52:	movs	r2, #2
    3e54:	str	r2, [r4, #52]	; 0x34
  setLe32(dbm->firstCluster, BITMAP_CLUSTER);
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
    3e56:	movs	r2, #130	; 0x82
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);

  // Unused Label entry.
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;
    3e58:	movs	r3, #3
  setLe32(dbm->firstCluster, BITMAP_CLUSTER);
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
    3e5a:	strb.w	r2, [r4, #64]	; 0x40
  setLe32(dup->checksum, m_upcaseChecksum);
    3e5e:	ldr	r2, [sp, #4]
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);

  // Unused Label entry.
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;
    3e60:	strb	r3, [r4, #0]
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
  setLe32(dup->checksum, m_upcaseChecksum);
    3e62:	ldr	r2, [r2, #4]
    3e64:	str	r3, [r4, #84]	; 0x54
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    3e66:	ldr	r3, [sp, #4]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3e68:	str	r2, [r4, #68]	; 0x44
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    3e6a:	ldr	r3, [r3, #8]
    3e6c:	str.w	sl, [r4, #56]	; 0x38
    3e70:	movs	r6, #0
    goto fail;
  }
  // Initialize first sector of root.
  writeMsg(pr, "Writing root\r\n");
  ns = sectorsPerCluster;
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
    3e72:	add	r9, r8
    3e74:	str	r3, [r4, #88]	; 0x58
    3e76:	str	r6, [r4, #92]	; 0x5c
  setLe32(dup->firstCluster, UPCASE_CLUSTER);
  setLe64(dup->size, m_upcaseSize);

  // Write root, cluster four.
  for (uint32_t i = 0; i < ns; i++) {
    if (!dev->writeSector(sector + i, secBuf)) {
    3e78:	ldr	r3, [r5, #0]
    3e7a:	mov	r2, r4
    3e7c:	ldr	r3, [r3, #32]
    3e7e:	add.w	r1, r6, r9
    3e82:	mov	r0, r5
    3e84:	blx	r3
    3e86:	mov	sl, r0
    3e88:	cmp	r0, #0
    3e8a:	beq.w	3cb8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    3e8e:	cbnz	r6, 3e9c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x428>
      memset(secBuf, 0, BYTES_PER_SECTOR);
    3e90:	mov.w	r2, #512	; 0x200
    3e94:	mov	r1, r6
    3e96:	mov	r0, r4
    3e98:	bl	9078 <memset>
  setLe32(dup->checksum, m_upcaseChecksum);
  setLe32(dup->firstCluster, UPCASE_CLUSTER);
  setLe64(dup->size, m_upcaseSize);

  // Write root, cluster four.
  for (uint32_t i = 0; i < ns; i++) {
    3e9c:	adds	r6, #1
    3e9e:	cmp	r8, r6
    3ea0:	bne.n	3e78 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x404>
    }
    if (i == 0) {
      memset(secBuf, 0, BYTES_PER_SECTOR);
    }
  }
  writeMsg(pr, "Format done\r\n");
    3ea2:	cbz	r7, 3eac <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x438>
    3ea4:	ldr	r1, [pc, #32]	; (3ec8 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x454>)
    3ea6:	mov	r0, r7
    3ea8:	bl	760 <Print::write(char const*)>
  return true;

 fail:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
    3eac:	mov	r0, sl
    3eae:	add	sp, #28
    3eb0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3eb4:	.word	0x00012cec
    3eb8:	.word	0x00012cf9
    3ebc:	.word	0x00012d6b
    3ec0:	.word	0x00012cfb
    3ec4:	.word	0x00012d12
    3ec8:	.word	0x00012d21

00003ecc <ExFatFile::cmpName(DirName_t const*, ExName_t*)>:
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
  return hash;
}
//------------------------------------------------------------------------------
bool ExFatFile::cmpName(const DirName_t* dirName, ExName_t* fname) {
    3ecc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3ed0:	mov	r5, r2
    3ed2:	mov	r6, r1
    3ed4:	add.w	r8, r1, #30
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    3ed8:	ldrh	r3, [r5, #12]
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    3eda:	ldrh.w	r4, [r6, #2]!
    3ede:	cbnz	r3, 3ef2 <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x26>
    3ee0:	ldr	r2, [r5, #4]
    3ee2:	ldr	r3, [r5, #8]
    3ee4:	cmp	r2, r3
    3ee6:	bne.n	3ef2 <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x26>
  for (uint8_t i = 0; i < 15; i++) {
    uint16_t u = getLe16(dirName->unicode + 2*i);
    if (fname->atEnd()) {
      return u == 0;
    3ee8:	clz	r0, r4
    3eec:	lsrs	r0, r0, #5
    3eee:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
#if USE_UTF8_LONG_NAMES
    uint16_t cp = fname->get16();
    3ef2:	mov	r0, r5
    3ef4:	bl	3914 <FsName::get16()>
    if (toUpcase(cp) != toUpcase(u)) {
    3ef8:	bl	3870 <toUpcase(unsigned short)>
    3efc:	mov	r7, r0
    3efe:	mov	r0, r4
    3f00:	bl	3870 <toUpcase(unsigned short)>
    3f04:	cmp	r7, r0
    3f06:	bne.n	3f12 <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x46>
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
  return hash;
}
//------------------------------------------------------------------------------
bool ExFatFile::cmpName(const DirName_t* dirName, ExName_t* fname) {
  for (uint8_t i = 0; i < 15; i++) {
    3f08:	cmp	r6, r8
    3f0a:	bne.n	3ed8 <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0xc>
    if (u >= 0x7F || toUpper(c) != toUpper(u)) {
      return false;
    }
#endif  // USE_UTF8_LONG_NAMES
  }
  return true;
    3f0c:	movs	r0, #1
    3f0e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return u == 0;
    }
#if USE_UTF8_LONG_NAMES
    uint16_t cp = fname->get16();
    if (toUpcase(cp) != toUpcase(u)) {
       return false;
    3f12:	movs	r0, #0
    3f14:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00003f18 <ExFatFile::getName8(char*, unsigned int)>:
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName8(char* name, size_t count) {
    3f18:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  char* str = name;
  char* ptr;
  DirName_t* dn;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    3f1c:	ldrb.w	r3, [r0, #49]	; 0x31
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName8(char* name, size_t count) {
    3f20:	mov	sl, r0
    3f22:	mov	r9, r1
  char* str = name;
  char* ptr;
  DirName_t* dn;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    3f24:	cmp	r3, #0
    3f26:	beq.n	3fb8 <ExFatFile::getName8(char*, unsigned int)+0xa0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    3f28:	add.w	r8, r2, #4294967295
    3f2c:	mov	r5, r1
    3f2e:	movs	r7, #2
    3f30:	movs	r4, #0
    3f32:	add	r8, r1
  uint32_t cp;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 2; is <= m_setCount; is++) {
    3f34:	ldrb.w	r3, [sl, #48]	; 0x30
    3f38:	cmp	r3, r7
    3f3a:	bcc.n	3fac <ExFatFile::getName8(char*, unsigned int)+0x94>
    dn = reinterpret_cast<DirName_t*>
         (dirCache(is, FsCache::CACHE_FOR_READ));
    3f3c:	movs	r2, #0
    3f3e:	mov	r1, r7
    3f40:	mov	r0, sl
    3f42:	bl	402a <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
    3f46:	cbz	r0, 3fb8 <ExFatFile::getName8(char*, unsigned int)+0xa0>
    3f48:	ldrb	r3, [r0, #0]
    3f4a:	cmp	r3, #193	; 0xc1
    3f4c:	bne.n	3fb8 <ExFatFile::getName8(char*, unsigned int)+0xa0>
    3f4e:	mov	r6, r0
    3f50:	add.w	fp, r0, #30
    3f54:	mov	r3, r4
    3f56:	ldrh.w	r4, [r6, #2]!
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
      uint16_t c = getLe16(dn->unicode + 2*in);
      if (hs) {
    3f5a:	cbz	r3, 3f7a <ExFatFile::getName8(char*, unsigned int)+0x62>
        if (!FsUtf::isLowSurrogate(c)) {
    3f5c:	add.w	r2, r4, #9216	; 0x2400
    3f60:	uxth	r2, r2
    3f62:	cmp.w	r2, #1024	; 0x400
    3f66:	bcs.n	3fb8 <ExFatFile::getName8(char*, unsigned int)+0xa0>
   * \param[in] hs high surrogate.
   * \param[in] ls low surrogate.
   * \return code point.
   */
  inline uint32_t u16ToCp(uint16_t hs, uint16_t ls) {
    return 0X10000 + (((hs & 0X3FF) << 10) | (ls & 0X3FF));
    3f68:	ldr	r0, [pc, #88]	; (3fc4 <ExFatFile::getName8(char*, unsigned int)+0xac>)
    3f6a:	lsls	r3, r3, #10
    3f6c:	ands	r0, r3
    3f6e:	ubfx	r4, r4, #0, #10
    3f72:	orrs	r4, r0
    3f74:	add.w	r0, r4, #65536	; 0x10000
    3f78:	b.n	3f94 <ExFatFile::getName8(char*, unsigned int)+0x7c>
  /** Check for UTF-16 surrogate.
   * \param[in] c UTF-16 unit.
   * \return true if c is a surrogate else false.
   */
  inline bool isSurrogate(uint16_t c) {
    return 0XD800 <= c && c <= 0XDFFF;
    3f7a:	add.w	r3, r4, #10240	; 0x2800
    3f7e:	uxth	r3, r3
          DBG_FAIL_MACRO;
          goto fail;
        }
        cp = FsUtf::u16ToCp(hs, c);
        hs = 0;
      } else if (!FsUtf::isSurrogate(c)) {
    3f80:	cmp.w	r3, #2048	; 0x800
    3f84:	bcc.n	3f8c <ExFatFile::getName8(char*, unsigned int)+0x74>
        if (c == 0) {
    3f86:	cbz	r4, 3fac <ExFatFile::getName8(char*, unsigned int)+0x94>
          goto done;
        }
        cp = c;
    3f88:	mov	r0, r4
    3f8a:	b.n	3f94 <ExFatFile::getName8(char*, unsigned int)+0x7c>
      } else if (FsUtf::isHighSurrogate(c)) {
    3f8c:	cmp.w	r3, #1024	; 0x400
    3f90:	bcc.n	3fa2 <ExFatFile::getName8(char*, unsigned int)+0x8a>
    3f92:	b.n	3fb8 <ExFatFile::getName8(char*, unsigned int)+0xa0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    3f94:	mov	r2, r8
    3f96:	mov	r1, r5
    3f98:	bl	3480 <FsUtf::cpToMb(unsigned long, char*, char*)>
      if (!ptr) {
    3f9c:	cbz	r0, 3fac <ExFatFile::getName8(char*, unsigned int)+0x94>
    3f9e:	mov	r5, r0
    3fa0:	movs	r4, #0
         (dirCache(is, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
    3fa2:	cmp	fp, r6
    3fa4:	bne.n	3f54 <ExFatFile::getName8(char*, unsigned int)+0x3c>
  uint32_t cp;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 2; is <= m_setCount; is++) {
    3fa6:	adds	r7, #1
    3fa8:	uxtb	r7, r7
    3faa:	b.n	3f34 <ExFatFile::getName8(char*, unsigned int)+0x1c>
      }
      str = ptr;
    }
  }
 done:
  *str = '\0';
    3fac:	movs	r3, #0
    3fae:	strb	r3, [r5, #0]
  return str - name;
    3fb0:	rsb	r0, r9, r5
    3fb4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

 fail:
  *name = 0;
    3fb8:	movs	r0, #0
    3fba:	strb.w	r0, [r9]
  return 0;
}
    3fbe:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3fc2:	nop
    3fc4:	.word	0x000ffc00

00003fc8 <ExFatFile::hashName(ExName_t*)>:
//------------------------------------------------------------------------------
bool ExFatFile::hashName(ExName_t* fname) {
    3fc8:	push	{r4, r5, r6, lr}
  }
  void reset() {
    next = begin;
    3fca:	ldr	r3, [r1, #0]
    3fcc:	str	r3, [r1, #4]
    ls = 0;
    3fce:	movs	r4, #0
    3fd0:	mov	r5, r1
    3fd2:	strh	r4, [r1, #12]
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
    3fd4:	str	r4, [r1, #16]
  while (!fname->atEnd()) {
    uint16_t u = fname->get16();
    if (u == 0XFFFF) {
    3fd6:	movw	r6, #65535	; 0xffff
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    3fda:	ldrh	r3, [r5, #12]
    3fdc:	cbnz	r3, 3fe6 <ExFatFile::hashName(ExName_t*)+0x1e>
    3fde:	ldr	r2, [r5, #4]
    3fe0:	ldr	r3, [r5, #8]
    3fe2:	cmp	r2, r3
    3fe4:	beq.n	401a <ExFatFile::hashName(ExName_t*)+0x52>
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
  while (!fname->atEnd()) {
    uint16_t u = fname->get16();
    3fe6:	mov	r0, r5
    3fe8:	bl	3914 <FsName::get16()>
    if (u == 0XFFFF) {
    3fec:	cmp	r0, r6
    3fee:	beq.n	4016 <ExFatFile::hashName(ExName_t*)+0x4e>
  hash = ((hash << 15) | (hash >> 1));
  return hash;
}
//------------------------------------------------------------------------------
inline uint16_t exFatHash(uint16_t u, uint16_t hash) {
  uint16_t c = toUpcase(u);
    3ff0:	bl	3870 <toUpcase(unsigned short)>
    3ff4:	lsls	r3, r4, #15
    3ff6:	orr.w	r4, r3, r4, lsr #1
    3ffa:	uxtab	r4, r4, r0
    3ffe:	ubfx	r3, r4, #1, #15
    4002:	orr.w	r3, r3, r4, lsl #15
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
    4006:	asrs	r4, r0, #8
    4008:	uxtah	r4, r4, r3
    if (u == 0XFFFF) {
    DBG_FAIL_MACRO;
      goto fail;
    }
    hash = exFatHash(u, hash);
    fname->nameLength++;
    400c:	ldr	r3, [r5, #16]
    400e:	adds	r3, #1
}
//------------------------------------------------------------------------------
inline uint16_t exFatHash(uint16_t u, uint16_t hash) {
  uint16_t c = toUpcase(u);
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
    4010:	uxth	r4, r4
    if (u == 0XFFFF) {
    DBG_FAIL_MACRO;
      goto fail;
    }
    hash = exFatHash(u, hash);
    fname->nameLength++;
    4012:	str	r3, [r5, #16]
bool ExFatFile::hashName(ExName_t* fname) {
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
  while (!fname->atEnd()) {
    4014:	b.n	3fda <ExFatFile::hashName(ExName_t*)+0x12>
    goto fail;
  }
  return true;

 fail:
  return false;
    4016:	movs	r0, #0
    4018:	pop	{r4, r5, r6, pc}
    hash = exFatHash(c, hash);
  }
  fname->nameLength = fname->end - fname->begin;
#endif  // USE_UTF8_LONG_NAMES
  fname->nameHash = hash;
  if (!fname->nameLength || fname->nameLength > EXFAT_MAX_NAME_LENGTH) {
    401a:	ldr	r0, [r5, #16]
    char c = fname->getch();
    hash = exFatHash(c, hash);
  }
  fname->nameLength = fname->end - fname->begin;
#endif  // USE_UTF8_LONG_NAMES
  fname->nameHash = hash;
    401c:	strh	r4, [r5, #20]
  if (!fname->nameLength || fname->nameLength > EXFAT_MAX_NAME_LENGTH) {
    401e:	subs	r0, #1
    4020:	cmp	r0, #254	; 0xfe
    4022:	ite	hi
    4024:	movhi	r0, #0
    4026:	movls	r0, #1
  }
  return true;

 fail:
  return false;
}
    4028:	pop	{r4, r5, r6, pc}

0000402a <ExFatFile::dirCache(unsigned char, unsigned char)>:
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    402a:	push	{r4, r5, r6, r7, lr}
  DirPos_t pos = m_dirPos;
    402c:	add.w	r3, r0, #36	; 0x24
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    4030:	mov	r5, r0
    4032:	mov	r7, r1
    4034:	mov	r6, r2
  DirPos_t pos = m_dirPos;
    4036:	ldmia.w	r3, {r0, r1, r2}
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    403a:	sub	sp, #20
  DirPos_t pos = m_dirPos;
    403c:	add	r4, sp, #4
    403e:	stmia.w	r4, {r0, r1, r2}
  if (m_vol->dirSeek(&pos, 32*set) != 1) {
    4042:	lsls	r2, r7, #5
    4044:	mov	r1, r4
    4046:	ldr	r0, [r5, #32]
    4048:	bl	4a08 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    404c:	cmp	r0, #1
    404e:	bne.n	405c <ExFatFile::dirCache(unsigned char, unsigned char)+0x32>
    return nullptr;
  }
  return m_vol->dirCache(&pos, options);
    4050:	mov	r2, r6
    4052:	mov	r1, r4
    4054:	ldr	r0, [r5, #32]
    4056:	bl	496a <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    405a:	b.n	405e <ExFatFile::dirCache(unsigned char, unsigned char)+0x34>
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
  DirPos_t pos = m_dirPos;
  if (m_vol->dirSeek(&pos, 32*set) != 1) {
    return nullptr;
    405c:	movs	r0, #0
  }
  return m_vol->dirCache(&pos, options);
}
    405e:	add	sp, #20
    4060:	pop	{r4, r5, r6, r7, pc}

00004062 <ExFatFile::close()>:
//------------------------------------------------------------------------------
bool ExFatFile::close() {
    4062:	push	{r4, lr}
    4064:	mov	r4, r0
  bool rtn = sync();
    4066:	bl	4f20 <ExFatFile::sync()>
  m_attributes = FILE_ATTR_CLOSED;
    406a:	movs	r3, #0
    406c:	strb.w	r3, [r4, #49]	; 0x31
  m_flags = 0;
    4070:	strb.w	r3, [r4, #51]	; 0x33
  return rtn;
}
    4074:	pop	{r4, pc}

00004076 <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    4076:	push	{r3, r4, r5, lr}
    4078:	mov	r5, r1
    407a:	mov	r4, r2
  DirFile_t* df = reinterpret_cast<DirFile_t*>
                 (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_READ));
    407c:	add.w	r1, r0, #36	; 0x24
    4080:	movs	r2, #0
    4082:	ldr	r0, [r0, #32]
    4084:	bl	496a <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    4088:	cbz	r0, 4094 <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)+0x1e>
    408a:	ldrh	r3, [r0, #10]
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(df->createDate);
    408c:	strh	r3, [r5, #0]
    408e:	ldrh	r3, [r0, #8]
  *ptime = getLe16(df->createTime);
    4090:	strh	r3, [r4, #0]
  return true;
    4092:	movs	r0, #1

 fail:
  return false;
}
    4094:	pop	{r3, r4, r5, pc}

00004096 <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)>:
//------------------------------------------------------------------------------
bool ExFatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    4096:	push	{r3, r4, r5, lr}
    4098:	mov	r5, r1
    409a:	mov	r4, r2
  DirFile_t* df = reinterpret_cast<DirFile_t*>
                 (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_READ));
    409c:	add.w	r1, r0, #36	; 0x24
    40a0:	movs	r2, #0
    40a2:	ldr	r0, [r0, #32]
    40a4:	bl	496a <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    40a8:	cbz	r0, 40b4 <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)+0x1e>
    40aa:	ldrh	r3, [r0, #14]
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(df->modifyDate);
    40ac:	strh	r3, [r5, #0]
    40ae:	ldrh	r3, [r0, #12]
  *ptime = getLe16(df->modifyTime);
    40b0:	strh	r3, [r4, #0]
  return true;
    40b2:	movs	r0, #1

 fail:
  return false;
}
    40b4:	pop	{r3, r4, r5, pc}

000040b6 <ExFatFile::openRoot(ExFatVolume*)>:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
    40b6:	push	{r3, r4, r5, lr}
    40b8:	mov	r5, r1
  if (isOpen()) {
    40ba:	ldrb.w	r1, [r0, #49]	; 0x31
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
    40be:	mov	r4, r0
  if (isOpen()) {
    40c0:	cbnz	r1, 40d8 <ExFatFile::openRoot(ExFatVolume*)+0x22>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    40c2:	movs	r2, #56	; 0x38
    40c4:	bl	9078 <memset>
  m_attributes = FILE_ATTR_ROOT;
    40c8:	movs	r3, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    40ca:	movs	r0, #1
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
    40cc:	strb.w	r3, [r4, #49]	; 0x31
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    40d0:	strb.w	r0, [r4, #51]	; 0x33
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
    40d4:	str	r5, [r4, #32]
    40d6:	pop	{r3, r4, r5, pc}
  m_flags = FILE_FLAG_READ;
  return true;

 fail:
  return false;
    40d8:	movs	r0, #0
}
    40da:	pop	{r3, r4, r5, pc}

000040dc <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>:
//------------------------------------------------------------------------------
bool ExFatFile::parsePathName(const char* path,
                            ExName_t* fname, const char** ptr) {
    40dc:	push	{r4, r5, r6, r7}
  // Skip leading spaces.
  while (*path == ' ') {
    40de:	ldrb	r4, [r1, #0]
    40e0:	cmp	r4, #32
    40e2:	add.w	r5, r1, #1
    40e6:	bne.n	40ec <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x10>
    40e8:	mov	r1, r5
    40ea:	b.n	40de <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x2>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    40ec:	ldr	r7, [pc, #100]	; (4154 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x78>)
    path++;
  }
  fname->begin = path;
    40ee:	str	r1, [r2, #0]
  fname->end = path;
    40f0:	str	r1, [r2, #8]
  while (*path && !isDirSeparator(*path)) {
    40f2:	mov	r5, r1
    40f4:	mov	r6, r1
    40f6:	ldrb.w	r4, [r5], #1
    40fa:	cbz	r4, 4134 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x58>
    40fc:	cmp	r4, #47	; 0x2f
    40fe:	beq.n	4128 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x4c>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    4100:	cmp	r4, #31
    4102:	bls.n	414e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    4104:	sub.w	r1, r4, #34	; 0x22
    4108:	uxtb	r1, r1
    410a:	cmp	r1, #29
    410c:	bhi.n	4116 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x3a>
    410e:	lsr.w	r1, r7, r1
    4112:	lsls	r1, r1, #31
    4114:	bmi.n	414e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    4116:	and.w	r1, r4, #191	; 0xbf
    411a:	cmp	r1, #60	; 0x3c
    411c:	beq.n	414e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
    411e:	cmp	r4, #92	; 0x5c
    4120:	bne.n	413e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    4122:	b.n	414e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
      // Need to trim trailing dots spaces.
      fname->end = path;
    }
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
    4124:	cmp	r4, #47	; 0x2f
    4126:	bne.n	4134 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x58>
    4128:	mov	r6, r1
    412a:	ldrb.w	r4, [r1], #1
    412e:	cmp	r4, #32
    4130:	bne.n	4124 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x48>
    4132:	b.n	4128 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x4c>
  *ptr = path;
    4134:	str	r6, [r3, #0]
  return hashName(fname);
    4136:	mov	r1, r2

 fail:
  return false;
}
    4138:	pop	{r4, r5, r6, r7}
    }
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
  *ptr = path;
  return hashName(fname);
    413a:	b.w	3fc8 <ExFatFile::hashName(ExName_t*)>
    uint8_t c = *path++;
    if (!lfnLegalChar(c)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (c != '.' && c != ' ') {
    413e:	cmp	r4, #46	; 0x2e
    4140:	bne.n	4146 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x6a>
    4142:	mov	r1, r5
    4144:	b.n	40f2 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x16>
    4146:	cmp	r4, #32
    4148:	beq.n	4142 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x66>
      // Need to trim trailing dots spaces.
      fname->end = path;
    414a:	str	r5, [r2, #8]
    414c:	b.n	4142 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x66>
  *ptr = path;
  return hashName(fname);

 fail:
  return false;
}
    414e:	movs	r0, #0
    4150:	pop	{r4, r5, r6, r7}
    4152:	bx	lr
    4154:	.word	0x31000101

00004158 <ExFatFile::read(void*, unsigned int)>:
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    4158:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    415c:	ldrb.w	r3, [r0, #51]	; 0x33
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    4160:	lsls	r7, r3, #31
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    4162:	mov	r4, r0
    4164:	mov	r6, r1
    4166:	mov	r5, r2
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    4168:	bpl.n	425a <ExFatFile::read(void*, unsigned int)+0x102>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isContiguous() || isFile()) {
    416a:	lsls	r0, r3, #25
    416c:	bmi.n	4176 <ExFatFile::read(void*, unsigned int)+0x1e>
    416e:	ldrb.w	r3, [r4, #49]	; 0x31
    4172:	lsls	r1, r3, #28
    4174:	bpl.n	4190 <ExFatFile::read(void*, unsigned int)+0x38>
    if ((m_curPosition + count) > m_validLength) {
    4176:	ldrd	r0, r1, [r4]
    417a:	ldrd	r2, r3, [r4, #16]
    417e:	adds.w	r8, r0, r5
    4182:	adc.w	r9, r1, #0
    4186:	cmp	r3, r9
    4188:	it	eq
    418a:	cmpeq	r2, r8
    418c:	bcs.n	4190 <ExFatFile::read(void*, unsigned int)+0x38>
      count = toRead = m_validLength - m_curPosition;
    418e:	subs	r5, r2, r0
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    4190:	mov	r9, r5
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
      } else if (isContiguous()) {
        m_curCluster++;
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    4192:	add.w	sl, r4, #24
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    4196:	cmp.w	r9, #0
    419a:	beq.n	4224 <ExFatFile::read(void*, unsigned int)+0xcc>
    clusterOffset = m_curPosition & m_vol->clusterMask();
    419c:	ldr	r0, [r4, #32]
    419e:	ldrd	r2, r3, [r4]
    41a2:	ldr.w	r1, [r0, #1080]	; 0x438
    41a6:	and.w	r8, r1, r2
    sectorOffset = clusterOffset & m_vol->sectorMask();
    41aa:	ubfx	fp, r8, #0, #9
    if (clusterOffset == 0) {
    41ae:	cmp.w	r8, #0
    41b2:	bne.n	41f2 <ExFatFile::read(void*, unsigned int)+0x9a>
      if (m_curPosition == 0) {
    41b4:	orrs	r3, r2
    41b6:	bne.n	41c8 <ExFatFile::read(void*, unsigned int)+0x70>
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
    41b8:	ldrb.w	r3, [r4, #49]	; 0x31
    41bc:	lsls	r2, r3, #25
    41be:	ite	mi
    41c0:	ldrmi.w	r3, [r0, #1076]	; 0x434
    41c4:	ldrpl	r3, [r4, #28]
    41c6:	b.n	41d4 <ExFatFile::read(void*, unsigned int)+0x7c>
      } else if (isContiguous()) {
    41c8:	ldrb.w	r3, [r4, #51]	; 0x33
    41cc:	lsls	r3, r3, #25
    41ce:	bpl.n	41d8 <ExFatFile::read(void*, unsigned int)+0x80>
        m_curCluster++;
    41d0:	ldr	r3, [r4, #24]
    41d2:	adds	r3, #1
    41d4:	str	r3, [r4, #24]
    41d6:	b.n	41f2 <ExFatFile::read(void*, unsigned int)+0x9a>
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    41d8:	mov	r2, sl
    41da:	ldr	r1, [r4, #24]
    41dc:	bl	49a0 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
        if (fg < 0) {
    41e0:	cmp	r0, #0
    41e2:	blt.n	425a <ExFatFile::read(void*, unsigned int)+0x102>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
    41e4:	bne.n	41f2 <ExFatFile::read(void*, unsigned int)+0x9a>
          // EOF if directory.
          if (isDir()) {
    41e6:	ldrb.w	r3, [r4, #49]	; 0x31
    41ea:	tst.w	r3, #80	; 0x50
    41ee:	bne.n	4224 <ExFatFile::read(void*, unsigned int)+0xcc>
    41f0:	b.n	425a <ExFatFile::read(void*, unsigned int)+0x102>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
    41f2:	ldr	r7, [r4, #32]
             (clusterOffset >> m_vol->bytesPerSectorShift());
    41f4:	ldr	r1, [r4, #24]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    41f6:	ldrb.w	lr, [r7, #1093]	; 0x445
    41fa:	ldr.w	r0, [r7, #1068]	; 0x42c
    41fe:	subs	r1, #2
    4200:	lsl.w	r1, r1, lr
    4204:	mov.w	r2, r8, lsr #9
    4208:	add	r1, r0
    420a:	add.w	r8, r1, r2
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
    420e:	cmp.w	fp, #0
    4212:	bne.n	42b4 <ExFatFile::read(void*, unsigned int)+0x15c>
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
    4214:	cmp.w	r9, #512	; 0x200
    4218:	bcc.n	42b4 <ExFatFile::read(void*, unsigned int)+0x15c>
    421a:	ldr.w	r1, [r7, #540]	; 0x21c
                          || sector == m_vol->dataCacheSector()) {
    421e:	cmp	r8, r1
    4220:	bne.n	422c <ExFatFile::read(void*, unsigned int)+0xd4>
    4222:	b.n	42b4 <ExFatFile::read(void*, unsigned int)+0x15c>
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return count - toRead;
    4224:	rsb	r0, r9, r5
    4228:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    422c:	cmp.w	r9, #1024	; 0x400
    4230:	bcc.n	4288 <ExFatFile::read(void*, unsigned int)+0x130>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      // Limit reads to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    4232:	movs	r3, #1
    4234:	lsl.w	r3, r3, lr
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    4238:	mov.w	fp, r9, lsr #9
      // Limit reads to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    423c:	subs	r2, r3, r2
    423e:	cmp	fp, r2
    4240:	it	cs
    4242:	movcs	fp, r2
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    4244:	cmp	r8, r1
    4246:	bhi.n	426e <ExFatFile::read(void*, unsigned int)+0x116>
    4248:	add.w	r3, fp, r8
    424c:	cmp	r1, r3
    424e:	bcs.n	426e <ExFatFile::read(void*, unsigned int)+0x116>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    4250:	add.w	r0, r7, #528	; 0x210
    4254:	bl	37d6 <FsCache::sync()>
    4258:	cbnz	r0, 426e <ExFatFile::read(void*, unsigned int)+0x116>
    toRead -= n;
  }
  return count - toRead;

 fail:
  m_error |= READ_ERROR;
    425a:	ldrb.w	r3, [r4, #50]	; 0x32
    425e:	orr.w	r3, r3, #2
    4262:	strb.w	r3, [r4, #50]	; 0x32
  return -1;
    4266:	mov.w	r0, #4294967295
    426a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    426e:	ldr.w	r0, [r7, #532]	; 0x214
    4272:	ldr	r3, [r0, #0]
    4274:	mov	r2, r6
    4276:	ldr	r7, [r3, #16]
    4278:	mov	r1, r8
    427a:	mov	r3, fp
    427c:	blx	r7
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
     if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    427e:	cmp	r0, #0
    4280:	beq.n	425a <ExFatFile::read(void*, unsigned int)+0x102>
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    4282:	mov.w	r7, fp, lsl #9
    4286:	b.n	429e <ExFatFile::read(void*, unsigned int)+0x146>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    4288:	ldr.w	r0, [r7, #532]	; 0x214
    428c:	ldr	r3, [r0, #0]
    428e:	mov	r2, r6
    4290:	ldr	r3, [r3, #12]
    4292:	mov	r1, r8
    4294:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    4296:	cmp	r0, #0
    4298:	beq.n	425a <ExFatFile::read(void*, unsigned int)+0x102>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    429a:	mov.w	r7, #512	; 0x200
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    429e:	ldrd	r2, r3, [r4]
    42a2:	adds	r2, r2, r7
    42a4:	adc.w	r3, r3, #0
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    42a8:	add	r6, r7
    m_curPosition += n;
    42aa:	strd	r2, r3, [r4]
    toRead -= n;
    42ae:	rsb	r9, r7, r9
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    42b2:	b.n	4196 <ExFatFile::read(void*, unsigned int)+0x3e>
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    42b4:	movs	r2, #0
    42b6:	mov	r1, r8
    42b8:	add.w	r0, r7, #528	; 0x210
    42bc:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      cache = m_vol->dataCacheGet(sector, FsCache::CACHE_FOR_READ);
      if (!cache) {
    42c0:	cmp	r0, #0
    42c2:	beq.n	425a <ExFatFile::read(void*, unsigned int)+0x102>
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
      n = m_vol->bytesPerSector() - sectorOffset;
    42c4:	rsb	r7, fp, #512	; 0x200
    42c8:	cmp	r7, r9
    42ca:	it	cs
    42cc:	movcs	r7, r9
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
    42ce:	add.w	r1, r0, fp
    42d2:	mov	r2, r7
    42d4:	mov	r0, r6
    42d6:	bl	8ed0 <memcpy>
    42da:	b.n	429e <ExFatFile::read(void*, unsigned int)+0x146>

000042dc <ExFatFile::peek()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int ExFatFile::peek() {
    42dc:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    42de:	movs	r2, #1
    42e0:	add.w	r1, sp, #7
    42e4:	mov	r4, r0
  uint64_t curPosition = m_curPosition;
    42e6:	ldrd	r6, r7, [r0]
  uint32_t curCluster = m_curCluster;
    42ea:	ldr	r5, [r0, #24]
    42ec:	bl	4158 <ExFatFile::read(void*, unsigned int)>
    42f0:	cmp	r0, #1
    42f2:	it	eq
    42f4:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
  m_curCluster = curCluster;
    42f8:	str	r5, [r4, #24]
    42fa:	it	ne
    42fc:	movne.w	r0, #4294967295
//------------------------------------------------------------------------------
int ExFatFile::peek() {
  uint64_t curPosition = m_curPosition;
  uint32_t curCluster = m_curCluster;
  int c = read();
  m_curPosition = curPosition;
    4300:	strd	r6, r7, [r4]
  m_curCluster = curCluster;
  return c;
}
    4304:	add	sp, #12
    4306:	pop	{r4, r5, r6, r7, pc}

00004308 <ExFatFile::seekSet(unsigned long long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    4308:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    430c:	ldrb.w	fp, [r0, #49]	; 0x31
    4310:	mov	r7, r3
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    4312:	ldr	r3, [r0, #24]
    4314:	str	r3, [sp, #4]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    4316:	mov	r4, r0
    4318:	mov	r6, r2
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    431a:	cmp.w	fp, #0
    431e:	beq.n	43c8 <ExFatFile::seekSet(unsigned long long)+0xc0>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    4320:	ldrd	r8, r9, [r0]
    4324:	cmp	r9, r7
    4326:	it	eq
    4328:	cmpeq	r8, r2
    432a:	beq.n	43d0 <ExFatFile::seekSet(unsigned long long)+0xc8>
    return true;
  }
  if (pos == 0) {
    432c:	orrs.w	r3, r6, r7
    4330:	bne.n	4338 <ExFatFile::seekSet(unsigned long long)+0x30>
    // set position to start of file
    m_curCluster = 0;
    4332:	movs	r3, #0
    4334:	str	r3, [r0, #24]
    goto done;
    4336:	b.n	43c2 <ExFatFile::seekSet(unsigned long long)+0xba>
  }
  if (isFile()) {
    4338:	tst.w	fp, #8
    433c:	beq.n	434a <ExFatFile::seekSet(unsigned long long)+0x42>
    if (pos > m_validLength) {
    433e:	ldrd	r0, r1, [r0, #16]
    4342:	cmp	r1, r7
    4344:	it	eq
    4346:	cmpeq	r0, r2
    4348:	bcc.n	43c8 <ExFatFile::seekSet(unsigned long long)+0xc0>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    434a:	ldr	r3, [r4, #32]
    434c:	str	r3, [sp, #0]
    434e:	ldrb.w	sl, [r3, #1093]	; 0x445
    4352:	add.w	sl, sl, #9
    4356:	adds.w	r0, r6, #4294967295
    435a:	uxtb.w	sl, sl
    435e:	mov	r2, sl
    4360:	adc.w	r1, r7, #4294967295
    4364:	bl	a4ec <__aeabi_llsr>
  if (isContiguous()) {
    4368:	ldrb.w	r2, [r4, #51]	; 0x33
    436c:	lsls	r3, r2, #25
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    436e:	mov	r5, r0
  if (isContiguous()) {
    4370:	bpl.n	437a <ExFatFile::seekSet(unsigned long long)+0x72>
    m_curCluster = m_firstCluster + nNew;
    4372:	ldr	r3, [r4, #28]
    4374:	add	r5, r3
    4376:	str	r5, [r4, #24]
    goto done;
    4378:	b.n	43c2 <ExFatFile::seekSet(unsigned long long)+0xba>
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
    437a:	adds.w	r0, r8, #4294967295
    437e:	adc.w	r1, r9, #4294967295
    4382:	mov	r2, sl
    4384:	bl	a4ec <__aeabi_llsr>
  if (nNew < nCur || m_curPosition == 0) {
    4388:	cmp	r5, r0
    438a:	bcc.n	4392 <ExFatFile::seekSet(unsigned long long)+0x8a>
    438c:	orrs.w	r3, r8, r9
    4390:	bne.n	43a8 <ExFatFile::seekSet(unsigned long long)+0xa0>
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
    4392:	tst.w	fp, #64	; 0x40
    4396:	itet	ne
    4398:	ldrne	r3, [sp, #0]
    439a:	ldreq	r3, [r4, #28]
    439c:	ldrne.w	r3, [r3, #1076]	; 0x434
    43a0:	str	r3, [r4, #24]
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    43a2:	add.w	r8, r4, #24
    43a6:	b.n	43be <ExFatFile::seekSet(unsigned long long)+0xb6>
  if (nNew < nCur || m_curPosition == 0) {
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    43a8:	subs	r5, r5, r0
    43aa:	b.n	43a2 <ExFatFile::seekSet(unsigned long long)+0x9a>
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    43ac:	mov	r2, r8
    43ae:	ldr	r1, [r4, #24]
    43b0:	ldr	r0, [r4, #32]
    43b2:	bl	49a0 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    43b6:	cmp	r0, #0
    43b8:	add.w	r5, r5, #4294967295
    43bc:	ble.n	43c8 <ExFatFile::seekSet(unsigned long long)+0xc0>
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    43be:	cmp	r5, #0
    43c0:	bne.n	43ac <ExFatFile::seekSet(unsigned long long)+0xa4>
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    43c2:	strd	r6, r7, [r4]
    43c6:	b.n	43d0 <ExFatFile::seekSet(unsigned long long)+0xc8>
  return true;

 fail:
  m_curCluster = tmp;
    43c8:	ldr	r3, [sp, #4]
    43ca:	str	r3, [r4, #24]
  return false;
    43cc:	movs	r0, #0
    43ce:	b.n	43d2 <ExFatFile::seekSet(unsigned long long)+0xca>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    43d0:	movs	r0, #1
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    43d2:	add	sp, #12
    43d4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000043d8 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openPrivate(ExFatFile* dir, ExName_t* fname, oflag_t oflag) {
    43d8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    43dc:	mov	sl, r3
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
  bool inSet = false;

  // error if already open, no access mode, or no directory.
  if (isOpen() || !dir->isDir()) {
    43de:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openPrivate(ExFatFile* dir, ExName_t* fname, oflag_t oflag) {
    43e2:	sub	sp, #52	; 0x34
    43e4:	mov	r4, r0
    43e6:	mov	r6, r1
    43e8:	mov	r5, r2
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
  bool inSet = false;

  // error if already open, no access mode, or no directory.
  if (isOpen() || !dir->isDir()) {
    43ea:	cbnz	r3, 444a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    43ec:	ldrb.w	r3, [r1, #49]	; 0x31
    43f0:	tst.w	r3, #80	; 0x50
    43f4:	beq.n	444a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    DBG_FAIL_MACRO;
    goto fail;
  }

  switch (oflag & O_ACCMODE) {
    43f6:	and.w	r3, sl, #3
    43fa:	cmp	r3, #1
    43fc:	beq.w	4704 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x32c>
    4400:	cmp	r3, #2
    4402:	bne.w	46fa <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x322>
      break;
    case O_WRONLY:
      modeFlags = FILE_FLAG_WRITE;
      break;
    case O_RDWR:
      modeFlags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    4406:	movs	r3, #3
      break;
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
    4408:	and.w	r9, sl, #8
    440c:	orr.w	r9, r9, r3

  if (fname) {
    4410:	cbz	r5, 4456 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x7e>
    freeNeed = 2 + (fname->nameLength + 14)/15;
    4412:	ldr	r3, [r5, #16]
    4414:	mov.w	r8, #15
    4418:	adds	r3, #14
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    441a:	movs	r2, #0
    441c:	udiv	r8, r3, r8
    4420:	mov	r0, r6
    4422:	add.w	r8, r8, #2
    4426:	movs	r3, #0
    4428:	uxtb.w	r8, r8
    442c:	bl	4308 <ExFatFile::seekSet(unsigned long long)>
        }
        // Likely openNext call.
        DBG_WARN_MACRO;
        goto fail;
      }
      inSet = false;
    4430:	mov.w	fp, #0
    4434:	mov	r7, fp
    freeNeed = 2 + (fname->nameLength + 14)/15;
    dir->rewind();
  }

  while (1) {
    n = dir->read(buf, 32);
    4436:	movs	r2, #32
    4438:	add	r1, sp, #16
    443a:	mov	r0, r6
    443c:	bl	4158 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    4440:	cmp	r0, #0
    4442:	beq.w	45be <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1e6>
      goto create;
    }
    if (n != 32) {
    4446:	cmp	r0, #32
    4448:	beq.n	445c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x84>
  return sync();
#endif  // READ_ONLY

 fail:
  // close file
  m_attributes = FILE_ATTR_CLOSED;
    444a:	movs	r0, #0
    444c:	strb.w	r0, [r4, #49]	; 0x31
  m_flags = 0;
    4450:	strb.w	r0, [r4, #51]	; 0x33
  return false;
    4454:	b.n	471c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
  DirFile_t*   dirFile;
  DirStream_t* dirStream;
  DirName_t*   dirName;
  uint8_t buf[32];
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
    4456:	mov.w	r8, #3
    445a:	b.n	4430 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x58>
    }
    if (n != 32) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(buf[0] & 0x80)) {
    445c:	ldrb.w	r2, [sp, #16]
    4460:	lsls	r1, r2, #24
    4462:	bmi.n	4488 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xb0>
      // Unused entry.
      if (freeCount == 0) {
    4464:	cbnz	r7, 4470 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x98>
        freePos.position = dir->curPosition() - 32;
    4466:	ldr	r3, [r6, #0]
    4468:	subs	r3, #32
    446a:	str	r3, [sp, #4]
    446c:	ldr	r3, [r6, #24]
    446e:	str	r3, [sp, #0]
        freePos.cluster = dir->curCluster();
      }
      if (freeCount < freeNeed) {
    4470:	cmp	r7, r8
        freeCount++;
    4472:	itt	cc
    4474:	addcc	r7, #1
    4476:	uxtbcc	r7, r7
      }
      if (!buf[0]) {
    4478:	cbz	r2, 4480 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa8>
      }
      if (fname->atEnd()) {
        goto found;
      }
    } else {
      inSet = false;
    447a:	mov.w	fp, #0
    447e:	b.n	4436 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
      }
      if (freeCount < freeNeed) {
        freeCount++;
      }
      if (!buf[0]) {
        if (fname) {
    4480:	cmp	r5, #0
    4482:	bne.w	45be <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1e6>
    4486:	b.n	444a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
        // Likely openNext call.
        DBG_WARN_MACRO;
        goto fail;
      }
      inSet = false;
    } else if (!inSet) {
    4488:	cmp.w	fp, #0
    448c:	bne.n	44de <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x106>
      if (freeCount < freeNeed) {
        freeCount = 0;
    448e:	cmp	r7, r8
    4490:	it	cc
    4492:	movcc	r7, #0
      }
      if (buf[0] != EXFAT_TYPE_FILE) {
    4494:	cmp	r2, #133	; 0x85
    4496:	bne.n	4436 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
        continue;
      }
      inSet = true;
      memset(this, 0, sizeof(ExFatFile));
    4498:	movs	r2, #56	; 0x38
    449a:	mov	r1, fp
    449c:	mov	r0, r4
    449e:	bl	9078 <memset>
      dirFile = reinterpret_cast<DirFile_t*>(buf);
      m_setCount = dirFile->setCount;
      m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    44a2:	ldrb.w	r2, [sp, #20]
        continue;
      }
      inSet = true;
      memset(this, 0, sizeof(ExFatFile));
      dirFile = reinterpret_cast<DirFile_t*>(buf);
      m_setCount = dirFile->setCount;
    44a6:	ldrb.w	r3, [sp, #17]
    44aa:	strb.w	r3, [r4, #48]	; 0x30
      m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    44ae:	and.w	r3, r2, #55	; 0x37
      if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
    44b2:	lsls	r2, r2, #27
        m_attributes |= FILE_ATTR_FILE;
    44b4:	it	pl
    44b6:	orrpl.w	r3, r3, #8
    44ba:	strb.w	r3, [r4, #49]	; 0x31
    44be:	ldr	r3, [r6, #32]
      }
      m_vol = dir->volume();
    44c0:	str	r3, [r4, #32]
    44c2:	ldr	r3, [r6, #24]
      m_dirPos.cluster = dir->curCluster();
    44c4:	str	r3, [r4, #36]	; 0x24
      m_dirPos.position = dir->curPosition() - 32;
    44c6:	ldr	r3, [r6, #0]
    44c8:	subs	r3, #32
    44ca:	str	r3, [r4, #40]	; 0x28
      m_dirPos.isContiguous = dir->isContiguous();
    44cc:	ldrb.w	r3, [r6, #51]	; 0x33
    44d0:	ubfx	r3, r3, #6, #1
    44d4:	strb.w	r3, [r4, #44]	; 0x2c
        freeCount = 0;
      }
      if (buf[0] != EXFAT_TYPE_FILE) {
        continue;
      }
      inSet = true;
    44d8:	mov.w	fp, #1
    44dc:	b.n	4436 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
      }
      m_vol = dir->volume();
      m_dirPos.cluster = dir->curCluster();
      m_dirPos.position = dir->curPosition() - 32;
      m_dirPos.isContiguous = dir->isContiguous();
    } else if (buf[0] == EXFAT_TYPE_STREAM) {
    44de:	cmp	r2, #192	; 0xc0
    44e0:	bne.n	453a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x162>
      dirStream = reinterpret_cast<DirStream_t*>(buf);
      m_flags = modeFlags;
      if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    44e2:	ldrb.w	r3, [sp, #17]
      m_dirPos.cluster = dir->curCluster();
      m_dirPos.position = dir->curPosition() - 32;
      m_dirPos.isContiguous = dir->isContiguous();
    } else if (buf[0] == EXFAT_TYPE_STREAM) {
      dirStream = reinterpret_cast<DirStream_t*>(buf);
      m_flags = modeFlags;
    44e6:	strb.w	r9, [r4, #51]	; 0x33
      if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    44ea:	lsls	r0, r3, #30
        m_flags |= FILE_FLAG_CONTIGUOUS;
    44ec:	itt	mi
    44ee:	orrmi.w	r3, r9, #64	; 0x40
    44f2:	strbmi.w	r3, [r4, #51]	; 0x33
      }
      m_validLength = getLe64(dirStream->validLength);
    44f6:	ldrd	r2, r3, [sp, #24]
    44fa:	strd	r2, r3, [r4, #16]
      m_firstCluster = getLe32(dirStream->firstCluster);
    44fe:	ldr	r3, [sp, #36]	; 0x24
    4500:	str	r3, [r4, #28]
      m_dataLength = getLe64(dirStream->dataLength);
    4502:	ldrd	r2, r3, [sp, #40]	; 0x28
    4506:	strd	r2, r3, [r4, #8]
      if (!fname) {
    450a:	cbnz	r5, 4514 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x13c>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    450c:	tst.w	sl, #2048	; 0x800
    4510:	bne.n	444a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    4512:	b.n	4562 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x18a>
  }
  void reset() {
    next = begin;
    4514:	ldr	r3, [r5, #0]
    4516:	str	r3, [r5, #4]
    ls = 0;
    4518:	mov.w	r3, #0
    451c:	strh	r3, [r5, #12]
      m_dataLength = getLe64(dirStream->dataLength);
      if (!fname) {
        goto found;
      }
      fname->reset();
      if (fname->nameLength != dirStream->nameLength ||
    451e:	ldr	r2, [r5, #16]
    4520:	ldrb.w	r3, [sp, #19]
    4524:	cmp	r2, r3
    4526:	bne.n	447a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa2>
    4528:	ldrh.w	r2, [sp, #20]
    452c:	ldrh	r3, [r5, #20]
    452e:	subs	r1, r2, r3
    4530:	rsbs	fp, r1, #0
    4534:	adc.w	fp, fp, r1
    4538:	b.n	4436 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
          fname->nameHash != getLe16(dirStream->nameHash)) {
        inSet = false;
      }
    } else if (buf[0] == EXFAT_TYPE_NAME) {
    453a:	cmp	r2, #193	; 0xc1
    453c:	bne.n	447a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa2>
      dirName = reinterpret_cast<DirName_t*>(buf);
      if (!cmpName(dirName, fname)) {
    453e:	mov	r2, r5
    4540:	add	r1, sp, #16
    4542:	mov	r0, r4
    4544:	bl	3ecc <ExFatFile::cmpName(DirName_t const*, ExName_t*)>
    4548:	cbnz	r0, 454e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x176>
        inSet = false;
    454a:	mov	fp, r0
    454c:	b.n	4436 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    454e:	ldrh	r2, [r5, #12]
    4550:	cmp	r2, #0
    4552:	bne.w	4436 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
    4556:	ldr	r1, [r5, #4]
    4558:	ldr	r2, [r5, #8]
    455a:	cmp	r1, r2
    455c:	bne.w	4436 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
    4560:	b.n	450c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x134>
  if (oflag & O_EXCL) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Write, truncate, or at end is an error for a directory or read-only file.
  if ((oflag & (O_TRUNC | O_AT_END)) || (m_flags & FILE_FLAG_WRITE)) {
    4562:	tst.w	sl, #17408	; 0x4400
    4566:	bne.n	4570 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x198>
    4568:	ldrb.w	r3, [r4, #51]	; 0x33
    456c:	lsls	r2, r3, #30
    456e:	bpl.n	457c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1a4>
    if (isSubDir() || isReadOnly() || READ_ONLY) {
    4570:	ldrb.w	r3, [r4, #49]	; 0x31
    4574:	tst.w	r3, #17
    4578:	bne.w	444a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      goto fail;
    }
  }

#if !READ_ONLY
  if (oflag & O_TRUNC) {
    457c:	tst.w	sl, #1024	; 0x400
    4580:	beq.n	45a4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1cc>
    if (!(m_flags & FILE_FLAG_WRITE)) {
    4582:	ldrb.w	r3, [r4, #51]	; 0x33
    4586:	lsls	r3, r3, #30
    4588:	bpl.w	444a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
    458c:	movs	r2, #0
    458e:	movs	r3, #0
    4590:	mov	r0, r4
    4592:	bl	4308 <ExFatFile::seekSet(unsigned long long)>
    4596:	cmp	r0, #0
    4598:	beq.w	444a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    459c:	mov	r0, r4
    459e:	bl	52fa <ExFatFile::truncate()>
    45a2:	b.n	45b6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1de>
    }
    if (!truncate(0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    45a4:	tst.w	sl, #16384	; 0x4000
    45a8:	beq.w	4708 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x330>
    45ac:	ldrd	r2, r3, [r4, #16]
    45b0:	mov	r0, r4
    45b2:	bl	4308 <ExFatFile::seekSet(unsigned long long)>
    45b6:	cmp	r0, #0
    45b8:	beq.w	444a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    45bc:	b.n	4708 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x330>
#if READ_ONLY
  DBG_FAIL_MACRO;
  goto fail;
#else  // READ_ONLY
  // don't create unless O_CREAT and write
  if (!(oflag & O_CREAT) || !(modeFlags & FILE_FLAG_WRITE) || !fname) {
    45be:	tst.w	sl, #512	; 0x200
    45c2:	beq.w	444a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    45c6:	tst.w	r9, #2
    45ca:	beq.w	444a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    45ce:	cmp	r5, #0
    45d0:	beq.w	444a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    DBG_WARN_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    45d4:	cmp	r7, r8
    45d6:	bcs.n	4612 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x23a>
    n = dir->read(buf, 32);
    45d8:	movs	r2, #32
    45da:	add	r1, sp, #16
    45dc:	mov	r0, r6
    45de:	bl	4158 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    45e2:	cbnz	r0, 45fa <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x222>
      curCluster = dir->m_curCluster;
      if (!dir->addDirCluster()) {
    45e4:	mov	r0, r6
    goto fail;
  }
  while (freeCount < freeNeed) {
    n = dir->read(buf, 32);
    if (n == 0) {
      curCluster = dir->m_curCluster;
    45e6:	ldr.w	sl, [r6, #24]
      if (!dir->addDirCluster()) {
    45ea:	bl	4f5e <ExFatFile::addDirCluster()>
    45ee:	cmp	r0, #0
    45f0:	beq.w	444a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
        DBG_FAIL_MACRO;
        goto fail;
      }
      dir->m_curCluster = curCluster;
    45f4:	str.w	sl, [r6, #24]
      continue;
    45f8:	b.n	45d4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1fc>
    }
    if (n != 32) {
    45fa:	cmp	r0, #32
    45fc:	bne.w	444a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (freeCount == 0) {
    4600:	cbnz	r7, 460c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x234>
      freePos.position = dir->curPosition() - 32;
    4602:	ldr	r3, [r6, #0]
    4604:	subs	r3, #32
    4606:	str	r3, [sp, #4]
    4608:	ldr	r3, [r6, #24]
    460a:	str	r3, [sp, #0]
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
    460c:	adds	r7, #1
    460e:	uxtb	r7, r7
    4610:	b.n	45d4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1fc>
  }
  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
    4612:	movs	r2, #56	; 0x38
    4614:	movs	r1, #0
    4616:	mov	r0, r4
      freePos.position = dir->curPosition() - 32;
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }
  freePos.isContiguous = dir->isContiguous();
    4618:	ldrb.w	r7, [r6, #51]	; 0x33
  memset(this, 0, sizeof(ExFatFile));
    461c:	bl	9078 <memset>
    4620:	ldr	r3, [r6, #32]
  m_vol = dir->volume();
    4622:	str	r3, [r4, #32]
  m_attributes = FILE_ATTR_FILE;
    4624:	movs	r3, #8
    4626:	strb.w	r3, [r4, #49]	; 0x31
  m_dirPos = freePos;
    462a:	ldr	r3, [sp, #0]
    462c:	str	r3, [r4, #36]	; 0x24
      freePos.position = dir->curPosition() - 32;
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }
  freePos.isContiguous = dir->isContiguous();
    462e:	ubfx	r7, r7, #6, #1
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
    4632:	ldr	r3, [sp, #4]
    4634:	strb.w	r7, [r4, #44]	; 0x2c
    4638:	str	r3, [r4, #40]	; 0x28
  }
  void reset() {
    next = begin;
    463a:	ldr	r3, [r5, #0]
    463c:	str	r3, [r5, #4]
    ls = 0;
    463e:	movs	r7, #0
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    4640:	add.w	sl, r8, #4294967295
    4644:	strh	r7, [r5, #12]
    4646:	uxtb.w	sl, sl
    464a:	uxtb.w	fp, r7
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  fname->reset();
  for (uint8_t i = 0; i < freeNeed; i++) {
    464e:	cmp	fp, r8
    4650:	bcs.n	46f2 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x31a>
    cache = dirCache(i, FsCache::CACHE_FOR_WRITE);
    4652:	movs	r2, #1
    4654:	mov	r1, fp
    4656:	mov	r0, r4
    4658:	bl	402a <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache || (cache[0] & 0x80)) {
    465c:	mov	r6, r0
    465e:	cmp	r0, #0
    4660:	beq.w	444a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    4664:	ldrsb.w	r2, [r0]
    4668:	cmp	r2, #0
    466a:	blt.w	444a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memset(cache, 0 , 32);
    466e:	movs	r2, #32
    4670:	movs	r1, #0
    4672:	bl	9078 <memset>
    if (i == 0) {
    4676:	cmp.w	fp, #0
    467a:	bne.n	46ba <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x2e2>
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
    467c:	movs	r3, #133	; 0x85
    467e:	strb	r3, [r6, #0]
      m_setCount = freeNeed - 1;
      dirFile->setCount = m_setCount;

      if (FsDateTime::callback) {
    4680:	ldr	r3, [pc, #160]	; (4724 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x34c>)
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    4682:	strb.w	sl, [r4, #48]	; 0x30
      dirFile->setCount = m_setCount;
    4686:	strb.w	sl, [r6, #1]

      if (FsDateTime::callback) {
    468a:	ldr	r3, [r3, #0]
    468c:	cbz	r3, 46ae <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x2d6>
        uint16_t date, time;
        uint8_t ms10;
        FsDateTime::callback(&date, &time, &ms10);
    468e:	add.w	r2, sp, #11
    4692:	add.w	r1, sp, #14
    4696:	add	r0, sp, #12
    4698:	blx	r3
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    469a:	ldrh.w	r3, [sp, #12]
    469e:	strh	r3, [r6, #10]
    46a0:	ldrh.w	r3, [sp, #14]
    46a4:	strh	r3, [r6, #8]
        setLe16(dirFile->createDate, date);
        setLe16(dirFile->createTime, time);
        dirFile->createTimeMs = ms10;
    46a6:	ldrb.w	r3, [sp, #11]
    46aa:	strb	r3, [r6, #20]
    46ac:	b.n	46ee <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
    46ae:	movw	r3, #21537	; 0x5421
    46b2:	strh	r3, [r6, #10]
    46b4:	strh	r3, [r6, #14]
    46b6:	strh	r3, [r6, #18]
    46b8:	b.n	46ee <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
         setLe16(dirFile->createTime, FS_DEFAULT_TIME);
         setLe16(dirFile->modifyTime, FS_DEFAULT_TIME);
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
    46ba:	cmp.w	fp, #1
    46be:	bne.n	46da <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x302>
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
      dirStream->flags = EXFAT_FLAG_ALWAYS1;
      m_flags = modeFlags | FILE_FLAG_DIR_DIRTY;
    46c0:	orn	r3, r9, #127	; 0x7f
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
    46c4:	movs	r2, #192	; 0xc0
    46c6:	strb	r2, [r6, #0]
      dirStream->flags = EXFAT_FLAG_ALWAYS1;
    46c8:	strb.w	fp, [r6, #1]
      m_flags = modeFlags | FILE_FLAG_DIR_DIRTY;
    46cc:	strb.w	r3, [r4, #51]	; 0x33
      dirStream->nameLength = fname->nameLength;
    46d0:	ldr	r3, [r5, #16]
    46d2:	strb	r3, [r6, #3]
      setLe16(dirStream->nameHash, fname->nameHash);
    46d4:	ldrh	r3, [r5, #20]
    46d6:	strh	r3, [r6, #4]
    46d8:	b.n	46ee <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
    } else {
      dirName = reinterpret_cast<DirName_t*>(cache);
      dirName->type = EXFAT_TYPE_NAME;
    46da:	movs	r3, #193	; 0xc1
    46dc:	strb	r3, [r6, #0]
    46de:	add.w	fp, r6, #30
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    46e2:	ldrh	r2, [r5, #12]
    46e4:	cbnz	r2, 470c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x334>
    46e6:	ldr	r1, [r5, #4]
    46e8:	ldr	r2, [r5, #8]
    46ea:	cmp	r1, r2
    46ec:	bne.n	470c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x334>
    46ee:	adds	r7, #1
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  fname->reset();
  for (uint8_t i = 0; i < freeNeed; i++) {
    46f0:	b.n	464a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x272>
        uint16_t u = fname->get16();
        setLe16(dirName->unicode + 2*k, u);
      }
    }
  }
  return sync();
    46f2:	mov	r0, r4
    46f4:	bl	4f20 <ExFatFile::sync()>
    46f8:	b.n	471c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
  if (isOpen() || !dir->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }

  switch (oflag & O_ACCMODE) {
    46fa:	cmp	r3, #0
    46fc:	bne.w	444a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    case O_RDONLY:
      modeFlags = FILE_FLAG_READ;
    4700:	movs	r3, #1
    4702:	b.n	4408 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30>
      break;
    case O_WRONLY:
      modeFlags = FILE_FLAG_WRITE;
    4704:	movs	r3, #2
    4706:	b.n	4408 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30>
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    DBG_FAIL_MACRO;
    goto fail;
  }
#endif  // !READ_ONLY
  return true;
    4708:	movs	r0, #1
    470a:	b.n	471c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
      dirName->type = EXFAT_TYPE_NAME;
      for (size_t k = 0; k < 15; k++) {
        if (fname->atEnd()) {
          break;
        }
        uint16_t u = fname->get16();
    470c:	mov	r0, r5
    470e:	bl	3914 <FsName::get16()>
    4712:	strh.w	r0, [r6, #2]!
      dirStream->nameLength = fname->nameLength;
      setLe16(dirStream->nameHash, fname->nameHash);
    } else {
      dirName = reinterpret_cast<DirName_t*>(cache);
      dirName->type = EXFAT_TYPE_NAME;
      for (size_t k = 0; k < 15; k++) {
    4716:	cmp	r6, fp
    4718:	bne.n	46e2 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30a>
    471a:	b.n	46ee <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
 fail:
  // close file
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
    471c:	add	sp, #52	; 0x34
    471e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4722:	nop
    4724:	.word	0x2001ceb4

00004728 <ExFatFile::open(ExFatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
    4728:	push	{r4, r5, r6, r7, lr}
    472a:	sub	sp, #92	; 0x5c
    472c:	mov	r7, r3
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    472e:	movs	r3, #0
    4730:	strb.w	r3, [sp, #81]	; 0x51
    4734:	strb.w	r3, [sp, #82]	; 0x52
    4738:	strb.w	r3, [sp, #83]	; 0x53
 */
/**
 * \class FsName
 * \brief Handle UTF-8 file names.
 */
class FsName {
    473c:	strh.w	r3, [sp, #20]
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    4740:	ldrb.w	r3, [r0, #49]	; 0x31
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
    4744:	str	r2, [sp, #4]
    4746:	mov	r5, r0
    4748:	mov	r4, r1
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    474a:	cbz	r3, 4750 <ExFatFile::open(ExFatFile*, char const*, int)+0x28>
    close();
  }
  return openPrivate(dirFile, &fname, oflag);

 fail:
  return false;
    474c:	movs	r0, #0
    474e:	b.n	47de <ExFatFile::open(ExFatFile*, char const*, int)+0xb6>
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    4750:	ldrb.w	r3, [r1, #49]	; 0x31
    4754:	tst.w	r3, #80	; 0x50
    4758:	beq.n	474c <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    475a:	ldrb	r3, [r2, #0]
    475c:	cmp	r3, #47	; 0x2f
    475e:	bne.n	4786 <ExFatFile::open(ExFatFile*, char const*, int)+0x5e>
    while (isDirSeparator(*path)) {
    4760:	ldr	r3, [sp, #4]
    4762:	ldrb	r2, [r3, #0]
    4764:	cmp	r2, #47	; 0x2f
    4766:	bne.n	476e <ExFatFile::open(ExFatFile*, char const*, int)+0x46>
      path++;
    4768:	adds	r3, #1
    476a:	str	r3, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    476c:	b.n	4760 <ExFatFile::open(ExFatFile*, char const*, int)+0x38>
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    476e:	ldr	r1, [r4, #32]
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
    4770:	cbnz	r2, 477a <ExFatFile::open(ExFatFile*, char const*, int)+0x52>
      return openRoot(dirFile->m_vol);
    4772:	mov	r0, r5
    4774:	bl	40b6 <ExFatFile::openRoot(ExFatVolume*)>
    4778:	b.n	47de <ExFatFile::open(ExFatFile*, char const*, int)+0xb6>
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    477a:	add	r0, sp, #32
    477c:	bl	40b6 <ExFatFile::openRoot(ExFatVolume*)>
    4780:	cmp	r0, #0
    4782:	beq.n	474c <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    4784:	add	r4, sp, #32
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    4786:	add	r3, sp, #4
    4788:	add	r2, sp, #8
    478a:	ldr	r1, [sp, #4]
    478c:	mov	r0, r5
    478e:	bl	40dc <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    4792:	cmp	r0, #0
    4794:	beq.n	474c <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    4796:	ldr	r3, [sp, #4]
    4798:	ldrb	r3, [r3, #0]
    479a:	cbz	r3, 47d2 <ExFatFile::open(ExFatFile*, char const*, int)+0xaa>
      break;
    }
    if (!openPrivate(dirFile, &fname, O_RDONLY)) {
    479c:	movs	r3, #0
    479e:	add	r2, sp, #8
    47a0:	mov	r1, r4
    47a2:	mov	r0, r5
    47a4:	bl	43d8 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    47a8:	cmp	r0, #0
    47aa:	beq.n	474c <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_WARN_MACRO;
      goto fail;
    }
    tmpDir = *this;
    47ac:	add	r2, sp, #32
    47ae:	mov	r3, r5
    47b0:	add.w	lr, r5, #48	; 0x30
    47b4:	mov	r4, r2
    47b6:	ldr	r0, [r3, #0]
    47b8:	ldr	r1, [r3, #4]
    47ba:	mov	r6, r2
    47bc:	stmia	r6!, {r0, r1}
    47be:	adds	r3, #8
    47c0:	cmp	r3, lr
    47c2:	mov	r2, r6
    47c4:	bne.n	47b6 <ExFatFile::open(ExFatFile*, char const*, int)+0x8e>
    47c6:	ldr	r0, [r3, #0]
    47c8:	str	r0, [r6, #0]
    dirFile = &tmpDir;
    close();
    47ca:	mov	r0, r5
    47cc:	bl	4062 <ExFatFile::close()>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    47d0:	b.n	4786 <ExFatFile::open(ExFatFile*, char const*, int)+0x5e>
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    close();
  }
  return openPrivate(dirFile, &fname, oflag);
    47d2:	mov	r3, r7
    47d4:	add	r2, sp, #8
    47d6:	mov	r1, r4
    47d8:	mov	r0, r5
    47da:	bl	43d8 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>

 fail:
  return false;
}
    47de:	add	sp, #92	; 0x5c
    47e0:	pop	{r4, r5, r6, r7, pc}

000047e2 <ExFatFile::open(ExFatVolume*, char const*, int)>:
bool ExFatFile::open(const char* path, oflag_t oflag) {
  return open(ExFatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
    47e2:	cbz	r1, 47ec <ExFatFile::open(ExFatVolume*, char const*, int)+0xa>
    47e4:	add.w	r1, r1, #1096	; 0x448
    47e8:	b.w	4728 <ExFatFile::open(ExFatFile*, char const*, int)>
}
    47ec:	mov	r0, r1
    47ee:	bx	lr

000047f0 <ExFatFile::openNext(ExFatFile*, int)>:
    DBG_FAIL_MACRO;
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
    47f0:	push	{r4, r5}
    47f2:	mov	r3, r2
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    47f4:	ldrb.w	r2, [r0, #49]	; 0x31
    47f8:	cbnz	r2, 4818 <ExFatFile::openNext(ExFatFile*, int)+0x28>
    47fa:	ldrb.w	r5, [r1, #49]	; 0x31
    47fe:	tst.w	r5, #80	; 0x50
    4802:	beq.n	4818 <ExFatFile::openNext(ExFatFile*, int)+0x28>
    4804:	ldrd	r4, r5, [r1]
    4808:	movs	r5, #0
    480a:	and.w	r4, r4, #31
    480e:	orrs	r4, r5
    4810:	bne.n	4818 <ExFatFile::openNext(ExFatFile*, int)+0x28>
  }
  return openPrivate(dir, nullptr, oflag);

 fail:
  return false;
}
    4812:	pop	{r4, r5}
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return openPrivate(dir, nullptr, oflag);
    4814:	b.w	43d8 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>

 fail:
  return false;
}
    4818:	movs	r0, #0
    481a:	pop	{r4, r5}
    481c:	bx	lr

0000481e <ExFatPartition::bitmapFind(unsigned long, unsigned long)>:
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"

//------------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
    481e:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4822:	mov	r8, r0
    4824:	mov	sl, r2
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
    4826:	mov	r9, r1
    4828:	cbz	r1, 482e <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x10>
    482a:	subs	r4, r1, #2
    482c:	b.n	4832 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x14>
    482e:	ldr.w	r4, [r0, #1056]	; 0x420
  if (start >= m_clusterCount) {
    4832:	ldr.w	r3, [r8, #1072]	; 0x430
    start = 0;
    4836:	cmp	r4, r3
    4838:	it	cs
    483a:	movcs	r4, #0
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
  uint16_t sectorSize = 1 << m_bytesPerSectorShift;
  size_t i = (start >> 3) & (sectorSize - 1);
  uint8_t* cache;
  uint8_t mask = 1 << (start & 7);
    483c:	and.w	r7, r4, #7
    4840:	movs	r3, #1
    4842:	lsl.w	r7, r3, r7
    start = 0;
  }
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
  uint16_t sectorSize = 1 << m_bytesPerSectorShift;
  size_t i = (start >> 3) & (sectorSize - 1);
    4846:	ubfx	fp, r4, #3, #9
  uint8_t* cache;
  uint8_t mask = 1 << (start & 7);
    484a:	uxtb	r7, r7
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
  }
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
    484c:	mov	r6, r4
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
  }
  uint32_t endAlloc = start;
    484e:	mov	r5, r4
  bool bitmapModify(uint32_t cluster, uint32_t count, bool value);
  //----------------------------------------------------------------------------
  // Cache functions.
  uint8_t* bitmapCacheGet(uint32_t sector, uint8_t option) {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.get(sector, option);
    4850:	ldr.w	r1, [r8, #1068]	; 0x42c
    4854:	movs	r2, #0
    4856:	add.w	r1, r1, r5, lsr #12
    485a:	mov	r0, r8
    485c:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
  uint8_t mask = 1 << (start & 7);
  while (true) {
    uint32_t sector = m_clusterHeapStartSector +
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
    4860:	cbz	r0, 48c0 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0xa2>
    4862:	mov	r3, r7
    4864:	mov	r1, fp
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
    4866:	ldrb	r7, [r0, r1]
    4868:	tst	r7, r3
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
    486a:	add.w	r5, r5, #1
        if (!(mask & cache[i])) {
    486e:	bne.n	488c <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x6e>
          if ((endAlloc - bgnAlloc) == count) {
    4870:	subs	r2, r5, r6
    4872:	cmp	r2, sl
    4874:	bne.n	488e <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x70>
            if (cluster == 0 && count == 1) {
    4876:	cmp.w	r9, #0
    487a:	bne.n	4886 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x68>
    487c:	cmp.w	sl, #1
              // Start at found sector.  bitmapModify may increase this.
              m_bitmapStart = bgnAlloc;
    4880:	it	eq
    4882:	streq.w	r6, [r8, #1056]	; 0x420
            }
            return bgnAlloc + 2;
    4886:	adds	r0, r6, #2
    4888:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
    488c:	mov	r6, r5
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    488e:	cmp	r4, r5
    4890:	beq.n	48be <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0xa0>
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
    4892:	ldr.w	r2, [r8, #1072]	; 0x430
    4896:	cmp	r5, r2
    4898:	bcs.n	48a4 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x86>
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
    489a:	lsls	r3, r3, #1
    489c:	ands.w	r3, r3, #255	; 0xff
    48a0:	bne.n	4868 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x4a>
    48a2:	b.n	48ac <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x8e>
        }
        if (endAlloc == start) {
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
          endAlloc = bgnAlloc = 0;
    48a4:	movs	r6, #0
          i = sectorSize;
    48a6:	mov.w	r1, #512	; 0x200
        }
        if (endAlloc == start) {
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
          endAlloc = bgnAlloc = 0;
    48aa:	mov	r5, r6
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    48ac:	adds	r1, #1
    48ae:	movs	r3, #1
    48b0:	cmp.w	r1, #512	; 0x200
          break;
        }
      }
      mask = 1;
    }
    i = 0;
    48b4:	mov.w	fp, #0
          endAlloc = bgnAlloc = 0;
          i = sectorSize;
          break;
        }
      }
      mask = 1;
    48b8:	mov	r7, r3
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    48ba:	bcc.n	4866 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x48>
    48bc:	b.n	4850 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x32>
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
          return 1;
    48be:	movs	r0, #1
      mask = 1;
    }
    i = 0;
  }
  return 0;
}
    48c0:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

000048c4 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>:
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    48c4:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    48c8:	mov	r7, r2
    48ca:	mov	r6, r0
  uint32_t sector;
  uint32_t start = cluster - 2;
    48cc:	subs	r2, r1, #2
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    48ce:	ldr.w	r0, [r0, #1072]	; 0x430
    48d2:	adds	r1, r2, r7
    48d4:	cmp	r1, r0
  }
  return 0;
}
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    48d6:	mov	r8, r3
  uint32_t start = cluster - 2;
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    48d8:	bhi.n	495e <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
    48da:	ldr.w	r3, [r6, #1056]	; 0x420
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    48de:	cmp.w	r8, #0
    48e2:	beq.n	48f8 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x34>
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
    48e4:	cmp	r2, r3
    48e6:	bhi.n	4900 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
    48e8:	cmp	r1, r3
    48ea:	bls.n	4900 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
      m_bitmapStart = (start + count) < m_clusterCount ? start + count : 0;
    48ec:	cmp	r1, r0
    48ee:	it	cs
    48f0:	movcs	r1, #0
    48f2:	str.w	r1, [r6, #1056]	; 0x420
    48f6:	b.n	4900 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
    }
  } else {
    if (start < m_bitmapStart) {
    48f8:	cmp	r2, r3
      m_bitmapStart = start;
    48fa:	it	cc
    48fc:	strcc.w	r2, [r6, #1056]	; 0x420
    }
  }
  mask = 1 << (start & 7);
    4900:	and.w	r5, r2, #7
    4904:	movs	r3, #1
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    4906:	ldr.w	r1, [r6, #1068]	; 0x42c
  } else {
    if (start < m_bitmapStart) {
      m_bitmapStart = start;
    }
  }
  mask = 1 << (start & 7);
    490a:	lsl.w	r5, r3, r5
    490e:	uxtb	r5, r5
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    4910:	add.w	r1, r1, r2, lsr #12
  i = (start >> 3) & m_sectorMask;
    4914:	ubfx	r4, r2, #3, #9
    4918:	movs	r2, #1
    491a:	mov	r0, r6
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    491c:	add.w	r9, r1, #1
    4920:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    4924:	cbz	r0, 495e <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
    4926:	adds	r3, r0, r4
    4928:	mov	r2, r5
    492a:	add.w	r0, r0, #512	; 0x200
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
    492e:	ldrb	r1, [r3, #0]
    4930:	tst	r1, r2
    4932:	ite	ne
    4934:	movne	r4, #1
    4936:	moveq	r4, #0
    4938:	cmp	r4, r8
    493a:	beq.n	495e <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    493c:	eors	r1, r2
        if (--count == 0) {
    493e:	subs	r7, #1
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    4940:	strb	r1, [r3, #0]
        if (--count == 0) {
    4942:	beq.n	4964 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0xa0>
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
    4944:	lsls	r2, r2, #1
    4946:	ands.w	r2, r2, #255	; 0xff
    494a:	bne.n	492e <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x6a>
    494c:	adds	r3, #1
          return true;
        }
      }
      mask = 1;
    }
    i = 0;
    494e:	mov	r4, r2
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    4950:	cmp	r0, r3
    4952:	mov.w	r2, #1
  mask = 1 << (start & 7);
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
  i = (start >> 3) & m_sectorMask;
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    4956:	mov	r1, r9
        cache[i] ^= mask;
        if (--count == 0) {
          return true;
        }
      }
      mask = 1;
    4958:	mov	r5, r2
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    495a:	bne.n	492e <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x6a>
    495c:	b.n	4918 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x54>
    }
    i = 0;
  }

 fail:
  return false;
    495e:	movs	r0, #0
    4960:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
        if (--count == 0) {
          return true;
    4964:	movs	r0, #1
    i = 0;
  }

 fail:
  return false;
}
    4966:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0000496a <ExFatPartition::dirCache(DirPos_t*, unsigned char)>:
    n++;
  } while (status);
  return n;
}
//------------------------------------------------------------------------------
uint8_t* ExFatPartition::dirCache(DirPos_t* pos, uint8_t options) {
    496a:	push	{r3, r4, r5, lr}
    496c:	mov	r5, r1
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    496e:	ldr.w	r1, [r0, #1080]	; 0x438
    4972:	ldr	r3, [r5, #4]
    4974:	ands	r1, r3
    4976:	ldr	r3, [r5, #0]
    4978:	subs	r4, r3, #2
    497a:	ldrb.w	r3, [r0, #1093]	; 0x445
    497e:	lsl.w	r3, r4, r3
    4982:	add.w	r3, r3, r1, lsr #9
    4986:	ldr.w	r1, [r0, #1068]	; 0x42c
    498a:	add.w	r0, r0, #528	; 0x210
    498e:	add	r1, r3
    4990:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
  uint32_t sector = clusterStartSector(pos->cluster);
  sector += (m_clusterMask & pos->position) >> m_bytesPerSectorShift;
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
    4994:	cbz	r0, 499e <ExFatPartition::dirCache(DirPos_t*, unsigned char)+0x34>
    4996:	ldr	r3, [r5, #4]
    4998:	ubfx	r3, r3, #0, #9
    499c:	add	r0, r3
}
    499e:	pop	{r3, r4, r5, pc}

000049a0 <ExFatPartition::fatGet(unsigned long, unsigned long*)>:
  }
  return 1;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    49a0:	push	{r3, r4, r5, lr}
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    49a2:	ldr.w	r3, [r0, #1072]	; 0x430
    49a6:	adds	r3, #1
    49a8:	cmp	r3, r1
  }
  return 1;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    49aa:	mov	r4, r1
    49ac:	mov	r5, r2
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    49ae:	bcs.n	49b6 <ExFatPartition::fatGet(unsigned long, unsigned long*)+0x16>
    DBG_FAIL_MACRO;
    return -1;
    49b0:	mov.w	r0, #4294967295
    49b4:	pop	{r3, r4, r5, pc}
    49b6:	ldr.w	r1, [r0, #1060]	; 0x424
    49ba:	movs	r2, #0
    49bc:	add.w	r1, r1, r4, lsr #7
    49c0:	add.w	r0, r0, #528	; 0x210
    49c4:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));

  cache = dataCacheGet(sector, FsCache::CACHE_FOR_READ);
  if (!cache) {
    49c8:	cmp	r0, #0
    49ca:	beq.n	49b0 <ExFatPartition::fatGet(unsigned long, unsigned long*)+0x10>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    49cc:	lsls	r4, r4, #2
    49ce:	ubfx	r4, r4, #0, #9
    49d2:	ldr	r0, [r0, r4]
    return -1;
  }
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));
  *value = next;
    49d4:	str	r0, [r5, #0]
  return next == EXFAT_EOC ? 0 : 1;
    49d6:	adds	r0, #1
    49d8:	it	ne
    49da:	movne	r0, #1
}
    49dc:	pop	{r3, r4, r5, pc}

000049de <ExFatPartition::chainSize(unsigned long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
    49de:	push	{r0, r1, r4, r5, r6, lr}
    49e0:	add	r5, sp, #8
    49e2:	mov	r6, r0
    49e4:	str.w	r1, [r5, #-4]!
  uint32_t n = 0;
    49e8:	movs	r4, #0
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    49ea:	mov	r2, r5
    49ec:	ldr	r1, [sp, #4]
    49ee:	mov	r0, r6
    49f0:	bl	49a0 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    if (status < 0) return 0;
    49f4:	cmp	r0, #0
    49f6:	blt.n	4a02 <ExFatPartition::chainSize(unsigned long)+0x24>
    n++;
    49f8:	add.w	r4, r4, #1
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    49fc:	bne.n	49ea <ExFatPartition::chainSize(unsigned long)+0xc>
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    n++;
    49fe:	mov	r0, r4
    4a00:	b.n	4a04 <ExFatPartition::chainSize(unsigned long)+0x26>
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    4a02:	movs	r0, #0
    n++;
  } while (status);
  return n;
}
    4a04:	add	sp, #8
    4a06:	pop	{r4, r5, r6, pc}

00004a08 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>:
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    4a08:	push	{r4, r5, r6, lr}
    4a0a:	mov	r5, r1
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    4a0c:	ldr.w	r4, [r0, #1080]	; 0x438
    4a10:	ldr	r1, [r1, #4]
    4a12:	ands	r4, r1
    4a14:	adds	r3, r4, r2
  pos->position += offset;
    4a16:	add	r2, r1
    4a18:	str	r2, [r5, #4]
  tmp >>= bytesPerClusterShift();
    4a1a:	ldrb.w	r4, [r0, #1093]	; 0x445
    4a1e:	adds	r4, #9
    4a20:	uxtb	r4, r4
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    4a22:	mov	r6, r0
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
    4a24:	lsr.w	r4, r3, r4
  while (tmp--) {
    4a28:	cbz	r4, 4a48 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x40>
    if (pos->isContiguous) {
    4a2a:	ldrb	r3, [r5, #8]
    4a2c:	cbz	r3, 4a38 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x30>
      pos->cluster++;
    4a2e:	ldr	r3, [r5, #0]
    4a30:	adds	r3, #1
    4a32:	str	r3, [r5, #0]
    4a34:	subs	r4, #1
    4a36:	b.n	4a28 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x20>
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    4a38:	mov	r2, r5
    4a3a:	ldr	r1, [r5, #0]
    4a3c:	mov	r0, r6
    4a3e:	bl	49a0 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
      if (status != 1) {
    4a42:	cmp	r0, #1
    4a44:	beq.n	4a34 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x2c>
    4a46:	pop	{r4, r5, r6, pc}
        return status;
      }
    }
  }
  return 1;
    4a48:	movs	r0, #1
}
    4a4a:	pop	{r4, r5, r6, pc}

00004a4c <ExFatPartition::fatPut(unsigned long, unsigned long)>:
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    4a4c:	cmp	r1, #1
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));
  *value = next;
  return next == EXFAT_EOC ? 0 : 1;
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
    4a4e:	push	{r3, r4, r5, lr}
    4a50:	mov	r4, r1
    4a52:	mov	r5, r2
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    4a54:	bhi.n	4a5a <ExFatPartition::fatPut(unsigned long, unsigned long)+0xe>
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;

 fail:
  return false;
    4a56:	movs	r0, #0
    4a58:	pop	{r3, r4, r5, pc}
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    4a5a:	ldr.w	r3, [r0, #1072]	; 0x430
    4a5e:	adds	r3, #1
    4a60:	cmp	r1, r3
    4a62:	bhi.n	4a56 <ExFatPartition::fatPut(unsigned long, unsigned long)+0xa>
    4a64:	ldr.w	r1, [r0, #1060]	; 0x424
    4a68:	movs	r2, #1
    4a6a:	add.w	r1, r1, r4, lsr #7
    4a6e:	add.w	r0, r0, #528	; 0x210
    4a72:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
  cache = dataCacheGet(sector, FsCache::CACHE_FOR_WRITE);
  if (!cache) {
    4a76:	cmp	r0, #0
    4a78:	beq.n	4a56 <ExFatPartition::fatPut(unsigned long, unsigned long)+0xa>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    4a7a:	lsls	r4, r4, #2
    4a7c:	ubfx	r4, r4, #0, #9
    4a80:	str	r5, [r0, r4]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;
    4a82:	movs	r0, #1

 fail:
  return false;
}
    4a84:	pop	{r3, r4, r5, pc}

00004a86 <ExFatPartition::freeChain(unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
    4a86:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    4a8a:	mov	r7, r0
    4a8c:	mov	r4, r1
  uint32_t next;
  uint32_t start = cluster;
    4a8e:	mov	r6, r1
  int8_t status;
  do {
    status = fatGet(cluster, &next);
    4a90:	add	r2, sp, #4
    4a92:	mov	r1, r4
    4a94:	mov	r0, r7
    4a96:	bl	49a0 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    if (status < 0) {
    4a9a:	subs.w	r8, r0, #0
    4a9e:	bge.n	4aa4 <ExFatPartition::freeChain(unsigned long)+0x1e>
  } while (status);

  return true;

 fail:
  return false;
    4aa0:	movs	r5, #0
    4aa2:	b.n	4adc <ExFatPartition::freeChain(unsigned long)+0x56>
    status = fatGet(cluster, &next);
    if (status < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!fatPut(cluster, 0)) {
    4aa4:	movs	r2, #0
    4aa6:	mov	r1, r4
    4aa8:	mov	r0, r7
    4aaa:	bl	4a4c <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4aae:	mov	r5, r0
    4ab0:	cmp	r0, #0
    4ab2:	beq.n	4aa0 <ExFatPartition::freeChain(unsigned long)+0x1a>
    4ab4:	adds	r2, r4, #1
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (status == 0 || (cluster + 1) != next) {
    4ab6:	cmp.w	r8, #0
    4aba:	beq.n	4ac2 <ExFatPartition::freeChain(unsigned long)+0x3c>
    4abc:	ldr	r3, [sp, #4]
    4abe:	cmp	r2, r3
    4ac0:	beq.n	4ad4 <ExFatPartition::freeChain(unsigned long)+0x4e>
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    4ac2:	movs	r3, #0
    4ac4:	subs	r2, r2, r6
    4ac6:	mov	r1, r6
    4ac8:	mov	r0, r7
    4aca:	bl	48c4 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4ace:	cmp	r0, #0
    4ad0:	beq.n	4aa0 <ExFatPartition::freeChain(unsigned long)+0x1a>
        DBG_FAIL_MACRO;
        goto fail;
      }
      start = next;
    4ad2:	ldr	r6, [sp, #4]
    }
    cluster = next;
    4ad4:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  uint32_t start = cluster;
  int8_t status;
  do {
    4ad6:	cmp.w	r8, #0
    4ada:	bne.n	4a90 <ExFatPartition::freeChain(unsigned long)+0xa>

  return true;

 fail:
  return false;
}
    4adc:	mov	r0, r5
    4ade:	add	sp, #8
    4ae0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00004ae4 <ExFatPartition::freeClusterCount()>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    4ae4:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t nc = 0;
  uint32_t sector = m_clusterHeapStartSector;
    4ae8:	ldr.w	r1, [r0, #1068]	; 0x42c
  uint32_t usedCount = 0;
    4aec:	movs	r4, #0

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    4aee:	mov	r6, r0
  uint32_t nc = 0;
    4af0:	mov	r5, r4
    4af2:	add.w	r7, r0, #528	; 0x210
    4af6:	movs	r2, #0
    4af8:	mov	r0, r7
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
  uint8_t* cache;

  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    4afa:	add.w	r8, r1, #1
    4afe:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    4b02:	cbz	r0, 4b44 <ExFatPartition::freeClusterCount()+0x60>
    4b04:	add.w	lr, r0, #4294967295
    4b08:	add.w	ip, r5, #4096	; 0x1000
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
    4b0c:	ldrb.w	r1, [lr, #1]!
    4b10:	cmp	r1, #255	; 0xff
    4b12:	bne.n	4b18 <ExFatPartition::freeClusterCount()+0x34>
        usedCount+= 8;
    4b14:	adds	r4, #8
    4b16:	b.n	4b2c <ExFatPartition::freeClusterCount()+0x48>
      } else if (cache[i]) {
    4b18:	cbz	r1, 4b2c <ExFatPartition::freeClusterCount()+0x48>
    4b1a:	movs	r2, #8
    4b1c:	movs	r3, #1
        for (uint8_t mask = 1; mask ; mask <<=1) {
          if ((mask & cache[i])) {
    4b1e:	tst	r1, r3
            usedCount++;
    4b20:	it	ne
    4b22:	addne	r4, #1
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
      } else if (cache[i]) {
        for (uint8_t mask = 1; mask ; mask <<=1) {
    4b24:	lsls	r3, r3, #1
    4b26:	subs	r2, #1
    4b28:	uxtb	r3, r3
    4b2a:	bne.n	4b1e <ExFatPartition::freeClusterCount()+0x3a>
            usedCount++;
          }
        }
      }
      nc += 8;
      if (nc >= m_clusterCount) {
    4b2c:	ldr.w	r0, [r6, #1072]	; 0x430
          if ((mask & cache[i])) {
            usedCount++;
          }
        }
      }
      nc += 8;
    4b30:	adds	r5, #8
      if (nc >= m_clusterCount) {
    4b32:	cmp	r5, r0
    4b34:	bcc.n	4b3c <ExFatPartition::freeClusterCount()+0x58>
        return m_clusterCount - usedCount;
    4b36:	subs	r0, r0, r4
    4b38:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
    4b3c:	cmp	r5, ip
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
  uint8_t* cache;

  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    4b3e:	mov	r1, r8
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
    4b40:	bne.n	4b0c <ExFatPartition::freeClusterCount()+0x28>
    4b42:	b.n	4af6 <ExFatPartition::freeClusterCount()+0x12>
      if (nc >= m_clusterCount) {
        return m_clusterCount - usedCount;
      }
    }
  }
}
    4b44:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00004b48 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>:
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    4b48:	push	{r4, r5, r6, r7, lr}
    4b4a:	mov	r4, r0
    4b4c:	sub	sp, #28
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif
  BpbExFat_t* bpb;

  m_fatType = 0;
    4b4e:	movs	r5, #0
      }
    }
  }
}
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    4b50:	mov	r0, r1
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    4b52:	mov.w	r3, #4294967295
    4b56:	mov	r1, r2
    4b58:	str	r3, [r4, #12]
    4b5a:	str.w	r3, [r4, #540]	; 0x21c
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif
  BpbExFat_t* bpb;

  m_fatType = 0;
    4b5e:	strb.w	r5, [r4, #1092]	; 0x444
  m_blockDev = dev;
    4b62:	str.w	r0, [r4, #1088]	; 0x440
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    4b66:	str	r0, [r4, #4]
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4b68:	strb	r5, [r4, #0]
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    4b6a:	str.w	r0, [r4, #532]	; 0x214
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4b6e:	strb.w	r5, [r4, #528]	; 0x210
  cacheInit(m_blockDev);


  #if SUPPORT_GPT_AND_EXTENDED_PATITIONS 
  cache = cacheClear(); // get buffer to use. 
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part,cache, &firstLBA);
    4b72:	str	r5, [sp, #8]
    4b74:	str	r5, [sp, #4]
    4b76:	str	r5, [sp, #0]
    4b78:	add	r3, sp, #20
    4b7a:	add.w	r2, r4, #544	; 0x220
    4b7e:	bl	3598 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    4b82:	tst.w	r0, #251	; 0xfb
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    4b86:	add.w	r7, r4, #528	; 0x210
    4b8a:	bne.n	4b90 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x48>
  bitmapFind(0, 1);
  m_fatType = FAT_TYPE_EXFAT;
  return true;

 fail:
  return false;
    4b8c:	movs	r0, #0
    4b8e:	b.n	4c0a <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xc2>
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part,cache, &firstLBA);
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    DBG_FAIL_MACRO;
    goto fail;    
  }
  volStart = firstLBA;
    4b90:	ldr	r6, [sp, #20]
    4b92:	mov	r2, r5
    4b94:	mov	r1, r6
    4b96:	mov	r0, r7
    4b98:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
  }
  volStart = getLe32(mp->relativeSectors);
  #endif

  cache = dataCacheGet(volStart, FsCache::CACHE_FOR_READ);
  if (!cache) {
    4b9c:	mov	r5, r0
    4b9e:	cmp	r0, #0
    4ba0:	beq.n	4b8c <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  pbs = reinterpret_cast<pbs_t*>(cache);
  if (strncmp(pbs->oemName, "EXFAT", 5)) {
    4ba2:	ldr	r1, [pc, #108]	; (4c10 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xc8>)
    4ba4:	movs	r2, #5
    4ba6:	adds	r0, #3
    4ba8:	bl	c01c <strncmp>
    4bac:	mov	r1, r0
    4bae:	cmp	r0, #0
    4bb0:	bne.n	4b8c <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  bpb = reinterpret_cast<BpbExFat_t*>(pbs->bpb);
  if (bpb->bytesPerSectorShift != m_bytesPerSectorShift) {
    4bb2:	ldrb.w	r3, [r5, #108]	; 0x6c
    4bb6:	cmp	r3, #9
    4bb8:	bne.n	4b8c <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_fatStartSector = volStart + getLe32(bpb->fatOffset);
    4bba:	ldr	r3, [r5, #80]	; 0x50
    4bbc:	add	r3, r6
    4bbe:	str.w	r3, [r4, #1060]	; 0x424
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    4bc2:	ldr	r3, [r5, #84]	; 0x54
  m_fatLength = getLe32(bpb->fatLength);
    4bc4:	str.w	r3, [r4, #1064]	; 0x428
  m_clusterHeapStartSector = volStart + getLe32(bpb->clusterHeapOffset);
    4bc8:	ldr	r3, [r5, #88]	; 0x58
    4bca:	add	r6, r3
    4bcc:	str.w	r6, [r4, #1068]	; 0x42c
    4bd0:	ldr	r3, [r5, #92]	; 0x5c
  m_clusterCount = getLe32(bpb->clusterCount);
    4bd2:	str.w	r3, [r4, #1072]	; 0x430
    4bd6:	ldr	r3, [r5, #96]	; 0x60
  m_rootDirectoryCluster = getLe32(bpb->rootDirectoryCluster);
    4bd8:	str.w	r3, [r4, #1076]	; 0x434
  m_sectorsPerClusterShift = bpb->sectorsPerClusterShift;
    4bdc:	ldrb.w	r3, [r5, #109]	; 0x6d
    4be0:	strb.w	r3, [r4, #1093]	; 0x445
  m_bytesPerCluster = 1UL << (m_bytesPerSectorShift + m_sectorsPerClusterShift);
    4be4:	movs	r5, #1
    4be6:	adds	r3, #9
    4be8:	lsl.w	r3, r5, r3
    4bec:	str.w	r3, [r4, #1084]	; 0x43c
  m_clusterMask = m_bytesPerCluster - 1;
    4bf0:	subs	r3, #1
    4bf2:	str.w	r3, [r4, #1080]	; 0x438
  // Set m_bitmapStart to first free cluster.
  m_bitmapStart = 0;
    4bf6:	str.w	r0, [r4, #1056]	; 0x420
  bitmapFind(0, 1);
    4bfa:	mov	r2, r5
    4bfc:	mov	r0, r4
    4bfe:	bl	481e <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  m_fatType = FAT_TYPE_EXFAT;
    4c02:	movs	r3, #64	; 0x40
    4c04:	strb.w	r3, [r4, #1092]	; 0x444
  return true;
    4c08:	mov	r0, r5

 fail:
  return false;
}
    4c0a:	add	sp, #28
    4c0c:	pop	{r4, r5, r6, r7, pc}
    4c0e:	nop
    4c10:	.word	0x00012d3f

00004c14 <ExFatPartition::rootLength()>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::rootLength() {
    4c14:	push	{r4, lr}
    4c16:	mov	r4, r0
  uint32_t nc = chainSize(m_rootDirectoryCluster);
    4c18:	ldr.w	r1, [r0, #1076]	; 0x434
    4c1c:	bl	49de <ExFatPartition::chainSize(unsigned long)>
  return nc << bytesPerClusterShift();
    4c20:	ldrb.w	r3, [r4, #1093]	; 0x445
    4c24:	adds	r3, #9
    4c26:	uxtb	r3, r3
}
    4c28:	lsls	r0, r3
    4c2a:	pop	{r4, pc}

00004c2c <ExFatVolume::chdir(char const*)>:
#define DBG_FILE "ExFatVolume.cpp"
#include "../common/DebugMacros.h"
#include "ExFatVolume.h"
ExFatVolume* ExFatVolume::m_cwv = nullptr;
//-----------------------------------------------------------------------------
bool ExFatVolume::chdir(const char* path) {
    4c2c:	push	{r4, r5, r6, lr}
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend ExFatFile;
  static ExFatVolume* cwv() {return m_cwv;}
  ExFatFile* vwd() {return &m_vwd;}
    4c2e:	add.w	r4, r0, #1096	; 0x448
    4c32:	sub	sp, #56	; 0x38
    4c34:	movs	r3, #0
  ExFatFile dir;
  if (!dir.open(vwd(), path, O_RDONLY)) {
    4c36:	mov	r2, r1
    4c38:	mov	r0, sp
    4c3a:	mov	r1, r4
    4c3c:	strb.w	r3, [sp, #49]	; 0x31
    4c40:	strb.w	r3, [sp, #50]	; 0x32
    4c44:	strb.w	r3, [sp, #51]	; 0x33
    4c48:	bl	4728 <ExFatFile::open(ExFatFile*, char const*, int)>
    4c4c:	mov	r5, r0
    4c4e:	cbz	r0, 4c7a <ExFatVolume::chdir(char const*)+0x4e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!dir.isDir()) {
    4c50:	ldrb.w	r3, [sp, #49]	; 0x31
    4c54:	ands.w	r3, r3, #80	; 0x50
    4c58:	beq.n	4c78 <ExFatVolume::chdir(char const*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_vwd = dir;
    4c5a:	mov	r2, sp
    4c5c:	mov	r3, r4
    4c5e:	add	r6, sp, #48	; 0x30
    4c60:	mov	r4, r2
    4c62:	ldmia	r4!, {r0, r1}
    4c64:	cmp	r4, r6
    4c66:	str	r0, [r3, #0]
    4c68:	str	r1, [r3, #4]
    4c6a:	mov	r2, r4
    4c6c:	add.w	r3, r3, #8
    4c70:	bne.n	4c60 <ExFatVolume::chdir(char const*)+0x34>
    4c72:	ldr	r0, [r4, #0]
    4c74:	str	r0, [r3, #0]
  return true;
    4c76:	b.n	4c7a <ExFatVolume::chdir(char const*)+0x4e>

 fail:
  return false;
    4c78:	mov	r5, r3
}
    4c7a:	mov	r0, r5
    4c7c:	add	sp, #56	; 0x38
    4c7e:	pop	{r4, r5, r6, pc}

00004c80 <exFatDirChecksum(unsigned char const*, unsigned short)>:
  return false;
}
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
    4c80:	push	{r4, lr}
  bool skip = data[0] == EXFAT_TYPE_FILE;
    4c82:	ldrb	r4, [r0, #0]
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    4c84:	movs	r3, #0
    4c86:	lsls	r2, r1, #15
    4c88:	orr.w	r1, r2, r1, lsr #1
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    4c8c:	ldrb	r2, [r0, r3]
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    4c8e:	cmp	r3, #1
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    4c90:	uxtah	r1, r2, r1
    4c94:	uxth	r1, r1
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    4c96:	bne.n	4ca2 <exFatDirChecksum(unsigned char const*, unsigned short)+0x22>
    4c98:	cmp	r4, #133	; 0x85
    4c9a:	ite	ne
    4c9c:	movne	r2, #1
    4c9e:	moveq	r2, #3
    4ca0:	b.n	4ca4 <exFatDirChecksum(unsigned char const*, unsigned short)+0x24>
    4ca2:	movs	r2, #1
    4ca4:	add	r3, r2
    4ca6:	cmp	r3, #31
    4ca8:	bls.n	4c86 <exFatDirChecksum(unsigned char const*, unsigned short)+0x6>
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
  }
  return checksum;
}
    4caa:	mov	r0, r1
    4cac:	pop	{r4, pc}

00004cae <ExFatPartition::cacheSync()>:
#if USE_EXFAT_BITMAP_CACHE
    m_bitmapCache.init(dev);
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
    4cae:	push	{r4, lr}
    4cb0:	mov	r4, r0
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    4cb2:	bl	37d6 <FsCache::sync()>
    4cb6:	cbz	r0, 4cd0 <ExFatPartition::cacheSync()+0x22>
    4cb8:	add.w	r0, r4, #528	; 0x210
    4cbc:	bl	37d6 <FsCache::sync()>
    4cc0:	cbz	r0, 4cd0 <ExFatPartition::cacheSync()+0x22>
    4cc2:	ldr.w	r0, [r4, #1088]	; 0x440
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    4cc6:	ldr	r3, [r0, #0]
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
#else  // USE_EXFAT_BITMAP_CACHE
    return m_dataCache.sync() && syncDevice();
#endif  // USE_EXFAT_BITMAP_CACHE
  }
    4cc8:	ldmia.w	sp!, {r4, lr}
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    4ccc:	ldr	r3, [r3, #28]
    4cce:	bx	r3
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
#else  // USE_EXFAT_BITMAP_CACHE
    return m_dataCache.sync() && syncDevice();
#endif  // USE_EXFAT_BITMAP_CACHE
  }
    4cd0:	movs	r0, #0
    4cd2:	pop	{r4, pc}

00004cd4 <ExFatFile::addCluster()>:
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
    4cd4:	push	{r3, r4, r5, r6, r7, lr}
    4cd6:	mov	r4, r0
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    4cd8:	ldr	r0, [r0, #32]
    4cda:	ldr	r1, [r4, #24]
    4cdc:	cbz	r1, 4ce0 <ExFatFile::addCluster()+0xc>
    4cde:	adds	r1, #1
    4ce0:	movs	r2, #1
    4ce2:	bl	481e <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  if (find < 2) {
    4ce6:	cmp	r0, #1
  }
  return checksum;
}
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    4ce8:	mov	r5, r0
  if (find < 2) {
    4cea:	bhi.n	4cf0 <ExFatFile::addCluster()+0x1c>
 done:
  m_curCluster = find;
  return true;

 fail:
  return false;
    4cec:	movs	r6, #0
    4cee:	b.n	4d62 <ExFatFile::addCluster()+0x8e>
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
  if (find < 2) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    4cf0:	movs	r3, #1
    4cf2:	mov	r1, r0
    4cf4:	mov	r2, r3
    4cf6:	ldr	r0, [r4, #32]
    4cf8:	bl	48c4 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4cfc:	mov	r6, r0
    4cfe:	cmp	r0, #0
    4d00:	beq.n	4cec <ExFatFile::addCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    4d02:	ldr	r2, [r4, #24]
    m_flags |= FILE_FLAG_CONTIGUOUS;
    4d04:	ldrb.w	r3, [r4, #51]	; 0x33
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    4d08:	cbnz	r2, 4d14 <ExFatFile::addCluster()+0x40>
    m_flags |= FILE_FLAG_CONTIGUOUS;
    4d0a:	orr.w	r3, r3, #64	; 0x40
    4d0e:	strb.w	r3, [r4, #51]	; 0x33
    goto done;
    4d12:	b.n	4d60 <ExFatFile::addCluster()+0x8c>
  }
  if (isContiguous()) {
    4d14:	lsls	r1, r3, #25
    4d16:	bpl.n	4d40 <ExFatFile::addCluster()+0x6c>
    if (find == (m_curCluster + 1)) {
    4d18:	adds	r2, #1
    4d1a:	cmp	r5, r2
    4d1c:	beq.n	4d60 <ExFatFile::addCluster()+0x8c>
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    4d1e:	bic.w	r3, r3, #64	; 0x40

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    4d22:	ldr	r1, [r4, #28]
  if (isContiguous()) {
    if (find == (m_curCluster + 1)) {
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    4d24:	strb.w	r3, [r4, #51]	; 0x33

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    4d28:	ldr	r3, [r4, #24]
    4d2a:	cmp	r1, r3
    4d2c:	bcs.n	4d40 <ExFatFile::addCluster()+0x6c>
      if (!m_vol->fatPut(c, c + 1)) {
    4d2e:	adds	r7, r1, #1
    4d30:	mov	r2, r7
    4d32:	ldr	r0, [r4, #32]
    4d34:	bl	4a4c <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4d38:	cmp	r0, #0
    4d3a:	beq.n	4cec <ExFatFile::addCluster()+0x18>
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    4d3c:	mov	r1, r7
    4d3e:	b.n	4d28 <ExFatFile::addCluster()+0x54>
        goto fail;
      }
    }
  }
  // New cluster is EOC.
  if (!m_vol->fatPut(find, EXFAT_EOC)) {
    4d40:	mov.w	r2, #4294967295
    4d44:	mov	r1, r5
    4d46:	ldr	r0, [r4, #32]
    4d48:	bl	4a4c <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4d4c:	cmp	r0, #0
    4d4e:	beq.n	4cec <ExFatFile::addCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Connect new cluster to existing chain.
  if (m_curCluster) {
    4d50:	ldr	r1, [r4, #24]
    4d52:	cbz	r1, 4d60 <ExFatFile::addCluster()+0x8c>
    if (!m_vol->fatPut(m_curCluster, find)) {
    4d54:	mov	r2, r5
    4d56:	ldr	r0, [r4, #32]
    4d58:	bl	4a4c <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4d5c:	cmp	r0, #0
    4d5e:	beq.n	4cec <ExFatFile::addCluster()+0x18>
      goto fail;
    }
  }

 done:
  m_curCluster = find;
    4d60:	str	r5, [r4, #24]
  return true;

 fail:
  return false;
}
    4d62:	mov	r0, r6
    4d64:	pop	{r3, r4, r5, r6, r7, pc}

00004d66 <ExFatFile::remove()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    4d66:	push	{r4, r5, r6, lr}
    4d68:	ldrb.w	r3, [r0, #51]	; 0x33
  uint8_t* cache;
  if (!isWritable()) {
    4d6c:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    4d6e:	mov	r4, r0
  uint8_t* cache;
  if (!isWritable()) {
    4d70:	bmi.n	4d76 <ExFatFile::remove()+0x10>

  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
    4d72:	movs	r0, #0
    4d74:	pop	{r4, r5, r6, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    4d76:	ldr	r5, [r0, #28]
    4d78:	cbnz	r5, 4d7e <ExFatFile::remove()+0x18>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    4d7a:	movs	r5, #0
    4d7c:	b.n	4dd0 <ExFatFile::remove()+0x6a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    if (isContiguous()) {
    4d7e:	lsls	r3, r3, #25
    4d80:	bpl.n	4dac <ExFatFile::remove()+0x46>
      uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    4d82:	ldr	r6, [r0, #32]
      if (!m_vol->bitmapModify(m_firstCluster, nc, 0)) {
    4d84:	ldrd	r0, r1, [r0, #8]
    4d88:	ldrb.w	r2, [r6, #1093]	; 0x445
    4d8c:	adds.w	r0, r0, #4294967295
    4d90:	add.w	r2, r2, #9
    4d94:	uxtb	r2, r2
    4d96:	adc.w	r1, r1, #4294967295
    4d9a:	bl	a4ec <__aeabi_llsr>
    4d9e:	movs	r3, #0
    4da0:	adds	r2, r0, #1
    4da2:	mov	r1, r5
    4da4:	mov	r0, r6
    4da6:	bl	48c4 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4daa:	b.n	4db4 <ExFatFile::remove()+0x4e>
        DBG_FAIL_MACRO;
        goto fail;
      }
    } else {
      if (!m_vol->freeChain(m_firstCluster)) {
    4dac:	mov	r1, r5
    4dae:	ldr	r0, [r0, #32]
    4db0:	bl	4a86 <ExFatPartition::freeChain(unsigned long)>
    4db4:	cmp	r0, #0
    4db6:	bne.n	4d7a <ExFatFile::remove()+0x14>
    4db8:	b.n	4d72 <ExFatFile::remove()+0xc>
      }
    }
  }

  for (uint8_t is = 0; is <= m_setCount; is++) {
    cache = dirCache(is, FsCache::CACHE_FOR_WRITE);
    4dba:	movs	r2, #1
    4dbc:	mov	r0, r4
    4dbe:	bl	402a <ExFatFile::dirCache(unsigned char, unsigned char)>
    4dc2:	adds	r5, #1
    if (!cache) {
    4dc4:	cmp	r0, #0
    4dc6:	beq.n	4d72 <ExFatFile::remove()+0xc>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
    4dc8:	ldrb	r3, [r0, #0]
    4dca:	and.w	r3, r3, #127	; 0x7f
    4dce:	strb	r3, [r0, #0]
        goto fail;
      }
    }
  }

  for (uint8_t is = 0; is <= m_setCount; is++) {
    4dd0:	ldrb.w	r3, [r4, #48]	; 0x30
    4dd4:	uxtb	r1, r5
    4dd6:	cmp	r3, r1
    4dd8:	bcs.n	4dba <ExFatFile::remove()+0x54>
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
  }
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    4dda:	movs	r3, #0
    4ddc:	strb.w	r3, [r4, #49]	; 0x31
  m_flags = 0;
    4de0:	strb.w	r3, [r4, #51]	; 0x33

  // Write entry to device.
  return m_vol->cacheSync();
    4de4:	ldr	r0, [r4, #32]
    4de6:	bl	4cae <ExFatPartition::cacheSync()>

 fail:
  return false;
}
    4dea:	pop	{r4, r5, r6, pc}

00004dec <ExFatFile::rmdir()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    4dec:	push	{r4, lr}
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    4dee:	ldrb.w	r3, [r0, #49]	; 0x31
    4df2:	lsls	r1, r3, #27

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    4df4:	sub	sp, #32
    4df6:	mov	r4, r0
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    4df8:	bmi.n	4dfe <ExFatFile::rmdir()+0x12>
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();

 fail:
  return false;
    4dfa:	movs	r0, #0
    4dfc:	b.n	4e3a <ExFatFile::rmdir()+0x4e>
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    4dfe:	movs	r2, #0
    4e00:	movs	r3, #0
    4e02:	bl	4308 <ExFatFile::seekSet(unsigned long long)>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    n = read(dir, 32);
    4e06:	movs	r2, #32
    4e08:	mov	r1, sp
    4e0a:	mov	r0, r4
    4e0c:	bl	4158 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    4e10:	cbz	r0, 4e22 <ExFatFile::rmdir()+0x36>
      break;
    }
    if (n != 32 || dir[0] & 0X80) {
    4e12:	cmp	r0, #32
    4e14:	bne.n	4dfa <ExFatFile::rmdir()+0xe>
    4e16:	ldrb.w	r3, [sp]
    4e1a:	lsls	r2, r3, #24
    4e1c:	bmi.n	4dfa <ExFatFile::rmdir()+0xe>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (dir[0] == 0) {
    4e1e:	cmp	r3, #0
    4e20:	bne.n	4e06 <ExFatFile::rmdir()+0x1a>
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    4e22:	movs	r3, #8
    4e24:	strb.w	r3, [r4, #49]	; 0x31
  m_flags |= FILE_FLAG_WRITE;
    4e28:	ldrb.w	r3, [r4, #51]	; 0x33
    4e2c:	orr.w	r3, r3, #2
    4e30:	strb.w	r3, [r4, #51]	; 0x33
  return remove();
    4e34:	mov	r0, r4
    4e36:	bl	4d66 <ExFatFile::remove()>

 fail:
  return false;
}
    4e3a:	add	sp, #32
    4e3c:	pop	{r4, pc}
    4e3e:	Address 0x00004e3e is out of bounds.


00004e40 <ExFatFile::syncDir()>:
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    4e40:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    4e44:	movs	r6, #0
    }
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    4e46:	ldr.w	r8, [pc, #212]	; 4f1c <ExFatFile::syncDir()+0xdc>
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    4e4a:	mov	r5, r0
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
    4e4c:	mov	r7, r6

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    4e4e:	ldrb.w	r3, [r5, #48]	; 0x30
    4e52:	uxtb	r1, r6
    4e54:	cmp	r3, r1
    4e56:	bcc.n	4eee <ExFatFile::syncDir()+0xae>
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    4e58:	movs	r2, #0
    4e5a:	mov	r0, r5
    4e5c:	bl	402a <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache) {
    4e60:	mov	r4, r0
    4e62:	cmp	r0, #0
    4e64:	beq.n	4f06 <ExFatFile::syncDir()+0xc6>
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    4e66:	ldrb	r3, [r0, #0]
    4e68:	cmp	r3, #192	; 0xc0
    4e6a:	beq.n	4ea8 <ExFatFile::syncDir()+0x68>
    4e6c:	cmp	r3, #193	; 0xc1
    4e6e:	beq.n	4ee0 <ExFatFile::syncDir()+0xa0>
    4e70:	cmp	r3, #133	; 0x85
    4e72:	bne.n	4f06 <ExFatFile::syncDir()+0xc6>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    4e74:	ldrb.w	r3, [r5, #49]	; 0x31
    4e78:	and.w	r3, r3, #55	; 0x37
    4e7c:	strh	r3, [r0, #4]
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    4e7e:	ldr.w	r3, [r8]
    4e82:	cbz	r3, 4ed2 <ExFatFile::syncDir()+0x92>
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
    4e84:	add.w	r2, sp, #3
    4e88:	add.w	r1, sp, #6
    4e8c:	add	r0, sp, #4
    4e8e:	blx	r3
          df->modifyTimeMs = ms10;
    4e90:	ldrb.w	r3, [sp, #3]
          setLe16(df->modifyTime, time);
    4e94:	ldrh.w	r2, [sp, #6]
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
          df->modifyTimeMs = ms10;
    4e98:	strb	r3, [r4, #21]
          setLe16(df->modifyTime, time);
          setLe16(df->modifyDate, date);
    4e9a:	ldrh.w	r3, [sp, #4]
    4e9e:	strh	r2, [r4, #12]
    4ea0:	strh	r3, [r4, #14]
    4ea2:	strh	r2, [r4, #16]
    4ea4:	strh	r3, [r4, #18]
    4ea6:	b.n	4ed2 <ExFatFile::syncDir()+0x92>
        m_vol->dataCacheDirty();
        break;

      case EXFAT_TYPE_STREAM:
        ds = reinterpret_cast<DirStream_t*>(cache);
        if (isContiguous()) {
    4ea8:	ldrb.w	r3, [r5, #51]	; 0x33
    4eac:	tst.w	r3, #64	; 0x40
    4eb0:	ldrb	r3, [r0, #1]
          ds->flags |= EXFAT_FLAG_CONTIGUOUS;
    4eb2:	ite	ne
    4eb4:	orrne.w	r3, r3, #2
        } else {
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
    4eb8:	biceq.w	r3, r3, #2
    4ebc:	strb	r3, [r0, #1]
        }
        setLe64(ds->validLength, m_validLength);
    4ebe:	ldrd	r2, r3, [r5, #16]

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    4ec2:	strd	r2, r3, [r0, #8]
        setLe32(ds->firstCluster, m_firstCluster);
    4ec6:	ldr	r3, [r5, #28]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    4ec8:	str	r3, [r0, #20]
        setLe64(ds->dataLength, m_dataLength);
    4eca:	ldrd	r2, r3, [r5, #8]
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    4ece:	strd	r2, r3, [r0, #24]
        m_vol->dataCacheDirty();
    4ed2:	ldr	r2, [r5, #32]
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    4ed4:	ldrb.w	r3, [r2, #528]	; 0x210
    4ed8:	orr.w	r3, r3, #1
    4edc:	strb.w	r3, [r2, #528]	; 0x210
      default:
        DBG_FAIL_MACRO;
        goto fail;
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
    4ee0:	mov	r1, r7
    4ee2:	mov	r0, r4
    4ee4:	bl	4c80 <exFatDirChecksum(unsigned char const*, unsigned short)>
    4ee8:	adds	r6, #1
    4eea:	mov	r7, r0
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    4eec:	b.n	4e4e <ExFatFile::syncDir()+0xe>
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
  }
  df = reinterpret_cast<DirFile_t*>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
    4eee:	movs	r2, #1
    4ef0:	add.w	r1, r5, #36	; 0x24
    4ef4:	ldr	r0, [r5, #32]
    4ef6:	bl	496a <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    4efa:	cbz	r0, 4f06 <ExFatFile::syncDir()+0xc6>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    4efc:	strh	r7, [r0, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe16(df->setChecksum, checksum);
  if (!m_vol->cacheSync()) {
    4efe:	ldr	r0, [r5, #32]
    4f00:	bl	4cae <ExFatPartition::cacheSync()>
    4f04:	cbnz	r0, 4f14 <ExFatFile::syncDir()+0xd4>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    4f06:	ldrb.w	r3, [r5, #50]	; 0x32
    4f0a:	orr.w	r3, r3, #1
    4f0e:	strb.w	r3, [r5, #50]	; 0x32
  return false;
    4f12:	movs	r0, #0
}
    4f14:	add	sp, #8
    4f16:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4f1a:	nop
    4f1c:	.word	0x2001ceb4

00004f20 <ExFatFile::sync()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
    4f20:	push	{r4, lr}
  if (!isOpen()) {
    4f22:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
    4f26:	mov	r4, r0
  if (!isOpen()) {
    4f28:	cbnz	r3, 4f2e <ExFatFile::sync()+0xe>
    return true;
    4f2a:	movs	r0, #1
    4f2c:	pop	{r4, pc}
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    4f2e:	ldrb.w	r3, [r0, #51]	; 0x33
    4f32:	lsls	r2, r3, #24
    4f34:	bpl.n	4f46 <ExFatFile::sync()+0x26>
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    4f36:	and.w	r3, r3, #127	; 0x7f
    4f3a:	strb.w	r3, [r0, #51]	; 0x33
  return true;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    4f3e:	ldmia.w	sp!, {r4, lr}
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    return syncDir();
    4f42:	b.w	4e40 <ExFatFile::syncDir()>
  }
  if (!m_vol->cacheSync()) {
    4f46:	ldr	r0, [r0, #32]
    4f48:	bl	4cae <ExFatPartition::cacheSync()>
    4f4c:	cmp	r0, #0
    4f4e:	bne.n	4f2a <ExFatFile::sync()+0xa>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    4f50:	ldrb.w	r3, [r4, #50]	; 0x32
    4f54:	orr.w	r3, r3, #1
    4f58:	strb.w	r3, [r4, #50]	; 0x32
  return false;
}
    4f5c:	pop	{r4, pc}

00004f5e <ExFatFile::addDirCluster()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    4f5e:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    4f62:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    4f66:	mov	r4, r0
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    4f68:	lsls	r0, r3, #25
    4f6a:	bpl.n	4f74 <ExFatFile::addDirCluster()+0x16>
    4f6c:	ldr	r0, [r4, #32]
    4f6e:	bl	4c14 <ExFatPartition::rootLength()>
    4f72:	b.n	4f76 <ExFatFile::addDirCluster()+0x18>
    4f74:	ldr	r0, [r4, #8]
    4f76:	ldr	r3, [r4, #32]
  uint8_t* cache;
  dl += m_vol->bytesPerCluster();
  if (dl >= 0X4000000) {
    4f78:	ldr.w	r3, [r3, #1084]	; 0x43c
    4f7c:	add	r0, r3
    4f7e:	cmp.w	r0, #67108864	; 0x4000000
    4f82:	bcs.n	5036 <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    4f84:	mov	r0, r4
    4f86:	bl	4cd4 <ExFatFile::addCluster()>
    4f8a:	cmp	r0, #0
    4f8c:	beq.n	5036 <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  cache =  m_vol->cacheClear();
    4f8e:	ldr	r5, [r4, #32]
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    if (isDirty() && !sync()) {
    4f90:	ldrb.w	r3, [r5, #528]	; 0x210
    4f94:	lsls	r1, r3, #31
    4f96:	bpl.n	4fa4 <ExFatFile::addDirCluster()+0x46>
    4f98:	add.w	r0, r5, #528	; 0x210
    4f9c:	bl	37d6 <FsCache::sync()>
    4fa0:	cmp	r0, #0
    4fa2:	beq.n	5036 <ExFatFile::addDirCluster()+0xd8>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    4fa4:	mov.w	r3, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4fa8:	movs	r6, #0
    m_sector = 0XFFFFFFFF;
    4faa:	str.w	r3, [r5, #540]	; 0x21c
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4fae:	strb.w	r6, [r5, #528]	; 0x210
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    4fb2:	add.w	r5, r5, #544	; 0x220
  if (!cache) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
    4fb6:	mov.w	r2, #512	; 0x200
    4fba:	mov	r1, r6
    4fbc:	mov	r0, r5
    4fbe:	bl	9078 <memset>
  sector = m_vol->clusterStartSector(m_curCluster);
    4fc2:	ldr	r2, [r4, #32]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    4fc4:	ldr	r3, [r4, #24]
    4fc6:	ldrb.w	r1, [r2, #1093]	; 0x445
    4fca:	ldr.w	r7, [r2, #1068]	; 0x42c
    4fce:	subs	r3, #2
    4fd0:	lsls	r3, r1
    4fd2:	add	r7, r3
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    4fd4:	mov.w	r8, #1
    4fd8:	ldr	r3, [r4, #32]
    4fda:	ldrb.w	r2, [r3, #1093]	; 0x445
    4fde:	lsl.w	r2, r8, r2
    4fe2:	cmp	r2, r6
    4fe4:	bls.n	4ffa <ExFatFile::addDirCluster()+0x9c>
    4fe6:	ldr.w	r0, [r3, #1088]	; 0x440
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    4fea:	ldr	r3, [r0, #0]
    4fec:	mov	r2, r5
    4fee:	ldr	r3, [r3, #32]
    4ff0:	adds	r1, r7, r6
    4ff2:	blx	r3
    if (!m_vol->writeSector(sector + i, cache)) {
    4ff4:	cbz	r0, 5036 <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
  sector = m_vol->clusterStartSector(m_curCluster);
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    4ff6:	adds	r6, #1
    4ff8:	b.n	4fd8 <ExFatFile::addDirCluster()+0x7a>
    if (!m_vol->writeSector(sector + i, cache)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  if (!isRoot()) {
    4ffa:	ldrb.w	r2, [r4, #49]	; 0x31
    4ffe:	lsls	r2, r2, #25
    5000:	bmi.n	502c <ExFatFile::addDirCluster()+0xce>
    m_flags |= FILE_FLAG_DIR_DIRTY;
    5002:	ldrb.w	r2, [r4, #51]	; 0x33
    5006:	orn	r2, r2, #127	; 0x7f
    m_dataLength  += m_vol->bytesPerCluster();
    500a:	ldrd	r0, r1, [r4, #8]
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    500e:	strb.w	r2, [r4, #51]	; 0x33
    m_dataLength  += m_vol->bytesPerCluster();
    5012:	ldr.w	r2, [r3, #1084]	; 0x43c
    5016:	movs	r3, #0
    5018:	adds	r0, r0, r2
    501a:	adcs	r1, r3
    501c:	strd	r0, r1, [r4, #8]
    m_validLength += m_vol->bytesPerCluster();
    5020:	ldrd	r0, r1, [r4, #16]
    5024:	adds	r2, r2, r0
    5026:	adcs	r3, r1
    5028:	strd	r2, r3, [r4, #16]
  }
  return sync();
    502c:	mov	r0, r4

 fail:
  return false;
}
    502e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    m_validLength += m_vol->bytesPerCluster();
  }
  return sync();
    5032:	b.w	4f20 <ExFatFile::sync()>

 fail:
  return false;
}
    5036:	movs	r0, #0
    5038:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000503c <ExFatFile::mkdir(ExFatFile*, ExName_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    503c:	push	{r4, lr}
  if (!parent->isDir()) {
    503e:	ldrb.w	r3, [r1, #49]	; 0x31
    5042:	tst.w	r3, #80	; 0x50

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    5046:	mov	r4, r0
  if (!parent->isDir()) {
    5048:	beq.n	5080 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!openPrivate(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    504a:	movw	r3, #2562	; 0xa02
    504e:	bl	43d8 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    5052:	cbz	r0, 5080 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_attributes = FILE_ATTR_SUBDIR;
    5054:	movs	r3, #16
    5056:	strb.w	r3, [r4, #49]	; 0x31

  // allocate and zero first cluster
  if (!addDirCluster()) {
    505a:	mov	r0, r4
    505c:	bl	4f5e <ExFatFile::addDirCluster()>
    5060:	cbz	r0, 5080 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    5062:	ldr	r3, [r4, #24]
    5064:	str	r3, [r4, #28]
    5066:	mov	r0, r4
    5068:	movs	r3, #0
    506a:	movs	r2, #0
    506c:	bl	4308 <ExFatFile::seekSet(unsigned long long)>

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    5070:	movs	r3, #193	; 0xc1
    5072:	strb.w	r3, [r4, #51]	; 0x33
  return sync();
    5076:	mov	r0, r4

 fail:
  return false;
}
    5078:	ldmia.w	sp!, {r4, lr}
  m_firstCluster = m_curCluster;

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();
    507c:	b.w	4f20 <ExFatFile::sync()>

 fail:
  return false;
}
    5080:	movs	r0, #0
    5082:	pop	{r4, pc}

00005084 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const char* path, bool pFlag) {
    5084:	push	{r4, r5, r6, r7, lr}
    5086:	sub	sp, #92	; 0x5c
    5088:	mov	r7, r3
    508a:	movs	r3, #0
    508c:	strh.w	r3, [sp, #20]
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    5090:	strb.w	r3, [sp, #81]	; 0x51
    5094:	strb.w	r3, [sp, #82]	; 0x52
    5098:	strb.w	r3, [sp, #83]	; 0x53
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    509c:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const char* path, bool pFlag) {
    50a0:	str	r2, [sp, #4]
    50a2:	mov	r5, r0
    50a4:	mov	r4, r1
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    50a6:	cmp	r3, #0
    50a8:	bne.n	513c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    50aa:	ldrb.w	r3, [r1, #49]	; 0x31
    50ae:	tst.w	r3, #80	; 0x50
    50b2:	beq.n	513c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    50b4:	ldrb	r3, [r2, #0]
    50b6:	cmp	r3, #47	; 0x2f
    50b8:	bne.n	50d6 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x52>
    while (isDirSeparator(*path)) {
    50ba:	ldr	r3, [sp, #4]
    50bc:	ldrb	r2, [r3, #0]
    50be:	cmp	r2, #47	; 0x2f
    50c0:	bne.n	50c8 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x44>
      path++;
    50c2:	adds	r3, #1
    50c4:	str	r3, [sp, #4]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    50c6:	b.n	50ba <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x36>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    50c8:	ldr	r1, [r4, #32]
    50ca:	add	r0, sp, #32
    50cc:	bl	40b6 <ExFatFile::openRoot(ExFatVolume*)>
    50d0:	cmp	r0, #0
    50d2:	beq.n	513c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    50d4:	add	r4, sp, #32
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    50d6:	add	r3, sp, #4
    50d8:	add	r2, sp, #8
    50da:	ldr	r1, [sp, #4]
    50dc:	mov	r0, r5
    50de:	bl	40dc <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    50e2:	cbz	r0, 513c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    50e4:	ldr	r3, [sp, #4]
    50e6:	ldrb	r3, [r3, #0]
    50e8:	cbz	r3, 5130 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xac>
      break;
    }
    if (!openPrivate(parent, &fname, O_RDONLY)) {
    50ea:	movs	r3, #0
    50ec:	add	r2, sp, #8
    50ee:	mov	r1, r4
    50f0:	mov	r0, r5
    50f2:	bl	43d8 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    50f6:	cbz	r0, 511e <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x9a>
      if (!pFlag || !mkdir(parent, &fname)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    50f8:	add	r2, sp, #32
    50fa:	mov	r3, r5
    50fc:	add.w	lr, r5, #48	; 0x30
    5100:	mov	r4, r2
    5102:	ldr	r0, [r3, #0]
    5104:	ldr	r1, [r3, #4]
    5106:	mov	r6, r2
    5108:	stmia	r6!, {r0, r1}
    510a:	adds	r3, #8
    510c:	cmp	r3, lr
    510e:	mov	r2, r6
    5110:	bne.n	5102 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x7e>
    5112:	ldr	r0, [r3, #0]
    5114:	str	r0, [r6, #0]
    parent = &tmpDir;
    close();
    5116:	mov	r0, r5
    5118:	bl	4062 <ExFatFile::close()>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    511c:	b.n	50d6 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x52>
    }
    if (!*path) {
      break;
    }
    if (!openPrivate(parent, &fname, O_RDONLY)) {
      if (!pFlag || !mkdir(parent, &fname)) {
    511e:	cbz	r7, 513c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    5120:	add	r2, sp, #8
    5122:	mov	r1, r4
    5124:	mov	r0, r5
    5126:	bl	503c <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    512a:	cmp	r0, #0
    512c:	bne.n	50f8 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x74>
    512e:	b.n	513c <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    5130:	add	r2, sp, #8
    5132:	mov	r1, r4
    5134:	mov	r0, r5
    5136:	bl	503c <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    513a:	b.n	513e <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xba>

 fail:
  return false;
    513c:	movs	r0, #0
}
    513e:	add	sp, #92	; 0x5c
    5140:	pop	{r4, r5, r6, r7, pc}

00005142 <ExFatFile::rename(ExFatFile*, char const*)>:
//------------------------------------------------------------------------------
bool ExFatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const char* newPath) {
    5142:	push	{r4, r5, r6, r7, lr}
    5144:	sub	sp, #116	; 0x74
    5146:	movs	r3, #0
    5148:	strb.w	r3, [sp, #49]	; 0x31
    514c:	strb.w	r3, [sp, #50]	; 0x32
    5150:	strb.w	r3, [sp, #51]	; 0x33
    5154:	strb.w	r3, [sp, #105]	; 0x69
    5158:	strb.w	r3, [sp, #106]	; 0x6a
    515c:	strb.w	r3, [sp, #107]	; 0x6b
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    5160:	ldrb.w	r3, [r0, #49]	; 0x31
    5164:	tst.w	r3, #24
//------------------------------------------------------------------------------
bool ExFatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const char* newPath) {
    5168:	mov	r4, r0
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    516a:	bne.n	5170 <ExFatFile::rename(ExFatFile*, char const*)+0x2e>
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();

 fail:
  return false;
    516c:	movs	r0, #0
    516e:	b.n	51e4 <ExFatFile::rename(ExFatFile*, char const*)+0xa2>
  if (!(isFile() || isSubDir())) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    5170:	ldr	r0, [r0, #32]
    5172:	ldr	r3, [r1, #32]
    5174:	cmp	r0, r3
    5176:	bne.n	516c <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    5178:	movw	r3, #2561	; 0xa01
    517c:	mov	r0, sp
    517e:	bl	4728 <ExFatFile::open(ExFatFile*, char const*, int)>
    5182:	cmp	r0, #0
    5184:	beq.n	516c <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  oldFile = *this;
    5186:	add	r2, sp, #56	; 0x38
    5188:	mov	r3, r4
    518a:	add.w	r7, r4, #48	; 0x30
    518e:	mov	r6, r2
    5190:	ldr	r0, [r3, #0]
    5192:	ldr	r1, [r3, #4]
    5194:	mov	r5, r2
    5196:	stmia	r5!, {r0, r1}
    5198:	adds	r3, #8
    519a:	cmp	r3, r7
    519c:	mov	r2, r5
    519e:	bne.n	5190 <ExFatFile::rename(ExFatFile*, char const*)+0x4e>
    51a0:	ldr	r0, [r3, #0]
    51a2:	str	r0, [r5, #0]
  m_dirPos = file.m_dirPos;
    51a4:	add	r2, sp, #36	; 0x24
    51a6:	ldmia	r2, {r0, r1, r2}
    51a8:	add.w	r3, r4, #36	; 0x24
    51ac:	stmia.w	r3, {r0, r1, r2}
  m_setCount = file.m_setCount;
    51b0:	ldrb.w	r3, [sp, #48]	; 0x30
    51b4:	strb.w	r3, [r4, #48]	; 0x30
  m_flags |= FILE_FLAG_DIR_DIRTY;
    51b8:	ldrb.w	r3, [r4, #51]	; 0x33
    51bc:	orn	r3, r3, #127	; 0x7f
    51c0:	strb.w	r3, [r4, #51]	; 0x33
  if (!sync()) {
    51c4:	mov	r0, r4
    51c6:	bl	4f20 <ExFatFile::sync()>
    51ca:	cmp	r0, #0
    51cc:	beq.n	516c <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    51ce:	movs	r3, #0
    51d0:	str	r3, [sp, #84]	; 0x54
  oldFile.m_flags = FILE_FLAG_WRITE;
    51d2:	movs	r3, #2
    51d4:	strb.w	r3, [sp, #107]	; 0x6b
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();
    51d8:	mov	r0, r6
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
    51da:	movs	r3, #8
    51dc:	strb.w	r3, [sp, #105]	; 0x69
  return oldFile.remove();
    51e0:	bl	4d66 <ExFatFile::remove()>

 fail:
  return false;
}
    51e4:	add	sp, #116	; 0x74
    51e6:	pop	{r4, r5, r6, r7, pc}

000051e8 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    51e8:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    51ec:	mov	r4, r3
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    51ee:	ldrb.w	r3, [r0, #49]	; 0x31
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    51f2:	ldrb.w	fp, [sp, #40]	; 0x28
    51f6:	ldrb.w	sl, [sp, #44]	; 0x2c
    51fa:	ldrb.w	r5, [sp, #48]	; 0x30
    51fe:	ldrb.w	r9, [sp, #52]	; 0x34
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    5202:	lsls	r3, r3, #28
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    5204:	mov	r6, r0
    5206:	mov	r8, r1
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    5208:	bpl.n	527c <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
  uint16_t date;
  uint16_t time;
  uint8_t ms10;

  if (!isFile()
      || year < 1980
    520a:	subw	r2, r2, #1980	; 0x7bc
    520e:	uxth	r7, r2
    5210:	cmp	r7, #127	; 0x7f
    5212:	bhi.n	527c <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || year > 2107
      || month < 1
    5214:	subs	r3, r4, #1
    5216:	cmp	r3, #11
    5218:	bhi.n	527c <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || month > 12
      || day < 1
    521a:	add.w	r3, fp, #4294967295
    521e:	cmp	r3, #30
    5220:	bhi.n	527c <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || day > 31
      || hour > 23
    5222:	cmp.w	sl, #23
    5226:	bhi.n	527c <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || minute > 59
    5228:	cmp	r5, #59	; 0x3b
    522a:	bhi.n	527c <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || second > 59) {
    522c:	cmp.w	r9, #59	; 0x3b
    5230:	bhi.n	527c <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // update directory entry
  if (!sync()) {
    5232:	bl	4f20 <ExFatFile::sync()>
    5236:	cbz	r0, 527c <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    5238:	mov.w	r3, r9, asr #1
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    523c:	orr.w	r4, fp, r4, lsl #5
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    5240:	orr.w	r5, r3, r5, lsl #5
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    5244:	orr.w	r4, r4, r7, lsl #9
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    5248:	orr.w	r5, r5, sl, lsl #11
    goto fail;
  }

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;
    524c:	tst.w	r9, #1
    5250:	mov.w	r7, #0
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    5254:	uxth	r4, r4
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    5256:	uxth	r5, r5
    5258:	ite	eq
    525a:	moveq.w	r9, #0
    525e:	movne.w	r9, #100	; 0x64
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
  DirFile_t* df;
  uint8_t* cache;
  uint16_t checksum = 0;
    5262:	mov	fp, r7
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        m_vol->dataCacheDirty();
        if (flags & T_ACCESS) {
    5264:	and.w	sl, r8, #1

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    5268:	ldrb.w	r3, [r6, #48]	; 0x30
    526c:	uxtb	r1, r7
    526e:	cmp	r3, r1
    5270:	bcc.n	52dc <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xf4>
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    5272:	movs	r2, #0
    5274:	mov	r0, r6
    5276:	bl	402a <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache) {
    527a:	cbnz	r0, 5282 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x9a>
    goto fail;
  }
  return true;

 fail:
  return false;
    527c:	movs	r0, #0
    527e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    5282:	ldrb	r3, [r0, #0]
    5284:	cmp	r3, #133	; 0x85
    5286:	beq.n	5292 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xaa>
    5288:	bcc.n	527c <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    528a:	subs	r3, #192	; 0xc0
    528c:	cmp	r3, #1
    528e:	bls.n	52d0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xe8>
    5290:	b.n	527c <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    5292:	ldrb.w	r3, [r6, #49]	; 0x31
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        m_vol->dataCacheDirty();
    5296:	ldr	r2, [r6, #32]
    5298:	and.w	r3, r3, #55	; 0x37
    529c:	strh	r3, [r0, #4]
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    529e:	ldrb.w	r3, [r2, #528]	; 0x210
    52a2:	orr.w	r3, r3, #1
    52a6:	strb.w	r3, [r2, #528]	; 0x210
        if (flags & T_ACCESS) {
    52aa:	cmp.w	sl, #0
    52ae:	beq.n	52b4 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xcc>
    52b0:	strh	r5, [r0, #16]
    52b2:	strh	r4, [r0, #18]
          setLe16(df->accessTime, time);
          setLe16(df->accessDate, date);
        }
        if (flags & T_CREATE) {
    52b4:	tst.w	r8, #2
          df->createTimeMs = ms10;
    52b8:	ittt	ne
    52ba:	strbne.w	r9, [r0, #20]
    52be:	strhne	r5, [r0, #8]
    52c0:	strhne	r4, [r0, #10]
          setLe16(df->createTime, time);
          setLe16(df->createDate, date);
        }
        if (flags & T_WRITE) {
    52c2:	tst.w	r8, #4
          df->modifyTimeMs = ms10;
    52c6:	ittt	ne
    52c8:	strbne.w	r9, [r0, #21]
    52cc:	strhne	r5, [r0, #12]
    52ce:	strhne	r4, [r0, #14]
      default:
        DBG_FAIL_MACRO;
        goto fail;
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
    52d0:	mov	r1, fp
    52d2:	bl	4c80 <exFatDirChecksum(unsigned char const*, unsigned short)>
    52d6:	adds	r7, #1
    52d8:	mov	fp, r0

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    52da:	b.n	5268 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x80>
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
  }
  df = reinterpret_cast<DirFile_t*>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
    52dc:	movs	r2, #1
    52de:	add.w	r1, r6, #36	; 0x24
    52e2:	ldr	r0, [r6, #32]
    52e4:	bl	496a <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    52e8:	cmp	r0, #0
    52ea:	beq.n	527c <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    52ec:	strh.w	fp, [r0, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe16(df->setChecksum, checksum);
  if (!m_vol->cacheSync()) {
    52f0:	ldr	r0, [r6, #32]
    52f2:	bl	4cae <ExFatPartition::cacheSync()>
    52f6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

000052fa <ExFatFile::truncate()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    52fa:	push	{r0, r1, r4, r5, r6, lr}
    52fc:	ldrb.w	r3, [r0, #51]	; 0x33
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    5300:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    5302:	mov	r4, r0
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    5304:	bmi.n	530a <ExFatFile::truncate()+0x10>
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    5306:	movs	r0, #0
    5308:	b.n	53b4 <ExFatFile::truncate()+0xba>
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    530a:	ldr	r5, [r0, #28]
    530c:	cmp	r5, #0
    530e:	beq.n	5392 <ExFatFile::truncate()+0x98>
      return true;
  }
  if (isContiguous()) {
    5310:	and.w	r3, r3, #64	; 0x40
    5314:	and.w	r1, r3, #255	; 0xff
    5318:	ldr	r6, [r0, #24]
    531a:	cbz	r3, 535a <ExFatFile::truncate()+0x60>
    531c:	ldr	r3, [r4, #32]
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    531e:	ldrd	r0, r1, [r0, #8]
    5322:	ldrb.w	r2, [r3, #1093]	; 0x445
    5326:	adds.w	r0, r0, #4294967295
    532a:	add.w	r2, r2, #9
    532e:	uxtb	r2, r2
    5330:	adc.w	r1, r1, #4294967295
    5334:	bl	a4ec <__aeabi_llsr>
    5338:	adds	r2, r0, #1
    if (m_curCluster) {
    533a:	cbz	r6, 5348 <ExFatFile::truncate()+0x4e>
      toFree = m_curCluster + 1;
      nc -= 1 + m_curCluster - m_firstCluster;
    533c:	subs	r5, #1
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    533e:	adds	r3, r6, #1
      nc -= 1 + m_curCluster - m_firstCluster;
    5340:	subs	r5, r5, r6
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    5342:	str	r3, [sp, #4]
      nc -= 1 + m_curCluster - m_firstCluster;
    5344:	add	r2, r5
    5346:	b.n	534c <ExFatFile::truncate()+0x52>
    } else {
      toFree = m_firstCluster;
    5348:	str	r5, [sp, #4]
      m_firstCluster = 0;
    534a:	str	r6, [r4, #28]
    }
    if (nc && !m_vol->bitmapModify(toFree, nc, 0)) {
    534c:	cbz	r2, 5396 <ExFatFile::truncate()+0x9c>
    534e:	movs	r3, #0
    5350:	ldr	r1, [sp, #4]
    5352:	ldr	r0, [r4, #32]
    5354:	bl	48c4 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    5358:	b.n	538e <ExFatFile::truncate()+0x94>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
    535a:	cbz	r6, 5380 <ExFatFile::truncate()+0x86>
      toFree = 0;
    535c:	add	r2, sp, #8
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    535e:	ldr	r0, [r0, #32]
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
      toFree = 0;
    5360:	str.w	r1, [r2, #-4]!
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    5364:	mov	r1, r6
    5366:	bl	49a0 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
      if (fg < 0) {
    536a:	cmp	r0, #0
    536c:	blt.n	5306 <ExFatFile::truncate()+0xc>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (fg) {
    536e:	beq.n	5384 <ExFatFile::truncate()+0x8a>
        // current cluster is end of chain
        if (!m_vol->fatPut(m_curCluster, EXFAT_EOC)) {
    5370:	mov.w	r2, #4294967295
    5374:	ldr	r1, [r4, #24]
    5376:	ldr	r0, [r4, #32]
    5378:	bl	4a4c <ExFatPartition::fatPut(unsigned long, unsigned long)>
    537c:	cbnz	r0, 5384 <ExFatFile::truncate()+0x8a>
    537e:	b.n	5306 <ExFatFile::truncate()+0xc>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
    } else {
      toFree = m_firstCluster;
    5380:	str	r5, [sp, #4]
      m_firstCluster = 0;
    5382:	str	r6, [r0, #28]
    }
    if (toFree) {
    5384:	ldr	r1, [sp, #4]
    5386:	cbz	r1, 5396 <ExFatFile::truncate()+0x9c>
      if (!m_vol->freeChain(toFree)) {
    5388:	ldr	r0, [r4, #32]
    538a:	bl	4a86 <ExFatPartition::freeChain(unsigned long)>
    538e:	cbnz	r0, 5396 <ExFatFile::truncate()+0x9c>
    5390:	b.n	5306 <ExFatFile::truncate()+0xc>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    5392:	movs	r0, #1
    5394:	b.n	53b4 <ExFatFile::truncate()+0xba>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  }
  m_dataLength = m_curPosition;
    5396:	ldrd	r2, r3, [r4]
    539a:	strd	r2, r3, [r4, #8]
  m_validLength = m_curPosition;
    539e:	strd	r2, r3, [r4, #16]
  m_flags |= FILE_FLAG_DIR_DIRTY;
    53a2:	ldrb.w	r3, [r4, #51]	; 0x33
    53a6:	orn	r3, r3, #127	; 0x7f
    53aa:	strb.w	r3, [r4, #51]	; 0x33
  return sync();
    53ae:	mov	r0, r4
    53b0:	bl	4f20 <ExFatFile::sync()>

 fail:
  return false;
}
    53b4:	add	sp, #8
    53b6:	pop	{r4, r5, r6, pc}

000053b8 <ExFatFile::write(void const*, unsigned int)>:
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    53b8:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    53bc:	ldrb.w	r3, [r0, #51]	; 0x33
    53c0:	mov	r9, r1

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    53c2:	lsls	r1, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    53c4:	mov	r4, r0
    53c6:	mov	sl, r2

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    53c8:	bpl.w	5542 <ExFatFile::write(void const*, unsigned int)+0x18a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    53cc:	lsls	r2, r3, #28
    53ce:	bmi.n	53de <ExFatFile::write(void const*, unsigned int)+0x26>
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    53d0:	add.w	r3, r4, #24

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    53d4:	mov	r8, sl
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    53d6:	str	r3, [sp, #0]
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    53d8:	mov.w	fp, #1
    53dc:	b.n	54a4 <ExFatFile::write(void const*, unsigned int)+0xec>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_validLength)) {
    53de:	ldrd	r2, r3, [r0, #16]
    53e2:	bl	4308 <ExFatFile::seekSet(unsigned long long)>
    53e6:	cmp	r0, #0
    53e8:	bne.n	53d0 <ExFatFile::write(void const*, unsigned int)+0x18>
    53ea:	b.n	5542 <ExFatFile::write(void const*, unsigned int)+0x18a>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    clusterOffset = m_curPosition & m_vol->clusterMask();
    53ec:	ldr	r0, [r4, #32]
    53ee:	ldr	r6, [r4, #0]
    53f0:	ldr.w	r3, [r0, #1080]	; 0x438
    53f4:	ands	r6, r3
    sectorOffset = clusterOffset & m_vol->sectorMask();
    53f6:	ubfx	r5, r6, #0, #9
    if (clusterOffset == 0) {
    53fa:	cmp	r6, #0
    53fc:	beq.n	54ac <ExFatFile::write(void const*, unsigned int)+0xf4>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    sector = m_vol->clusterStartSector(m_curCluster) +
    53fe:	ldr.w	lr, [r4, #32]
             (clusterOffset >> m_vol->bytesPerSectorShift());
    5402:	ldr	r1, [r4, #24]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    5404:	ldrb.w	r2, [lr, #1093]	; 0x445
    5408:	ldr.w	r3, [lr, #1068]	; 0x42c
    540c:	subs	r1, #2
    540e:	lsls	r1, r2
    5410:	lsrs	r6, r6, #9
    5412:	add	r1, r3
    5414:	add	r1, r6

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
    5416:	cmp	r5, #0
    5418:	bne.n	5514 <ExFatFile::write(void const*, unsigned int)+0x15c>
    541a:	cmp.w	r8, #512	; 0x200
    541e:	bcs.w	5556 <ExFatFile::write(void const*, unsigned int)+0x19e>
      // lesser of space and amount to write
      if (n > toWrite) {
        n = toWrite;
      }

      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
    5422:	ldrd	r2, r3, [r4, #16]
    5426:	ldrd	r6, r7, [r4]
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    542a:	cmp	r7, r3
    542c:	it	eq
    542e:	cmpeq	r6, r2
    5430:	ite	cc
    5432:	movcc	r2, #1
    5434:	movcs	r2, #5
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    5436:	add.w	r0, lr, #528	; 0x210
    543a:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      cache = m_vol->dataCacheGet(sector, cacheOption);
      if (!cache) {
    543e:	cmp	r0, #0
    5440:	beq.n	5542 <ExFatFile::write(void const*, unsigned int)+0x18a>
             (clusterOffset >> m_vol->bytesPerSectorShift());

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    5442:	rsb	r6, r5, #512	; 0x200
    5446:	cmp	r6, r8
    5448:	it	cs
    544a:	movcs	r6, r8
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    544c:	add	r0, r5
    544e:	mov	r2, r6
    5450:	mov	r1, r9
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    5452:	add	r5, r6
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    5454:	bl	8ed0 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    5458:	cmp.w	r5, #512	; 0x200
    545c:	bne.n	546c <ExFatFile::write(void const*, unsigned int)+0xb4>
  }
  uint32_t dataCacheSector() {return m_dataCache.sector();}
  bool dataCacheSync() {return m_dataCache.sync();}
    545e:	ldr	r0, [r4, #32]
    5460:	add.w	r0, r0, #528	; 0x210
    5464:	bl	37d6 <FsCache::sync()>
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeWrite(sector, src, ns)) {
    5468:	cmp	r0, #0
    546a:	beq.n	5542 <ExFatFile::write(void const*, unsigned int)+0x18a>
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    546c:	ldrd	r0, r1, [r4]
    5470:	adds	r2, r0, r6
    5472:	adc.w	r3, r1, #0
    5476:	mov	r0, r2
    5478:	mov	r1, r3
    547a:	strd	r2, r3, [r4]
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    547e:	ldrd	r2, r3, [r4, #16]
    5482:	cmp	r3, r1
    5484:	it	eq
    5486:	cmpeq	r2, r0
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    src += n;
    5488:	add	r9, r6
    toWrite -= n;
    548a:	rsb	r8, r6, r8
    if (m_curPosition > m_validLength) {
    548e:	bcs.n	54a4 <ExFatFile::write(void const*, unsigned int)+0xec>
      m_flags |= FILE_FLAG_DIR_DIRTY;
    5490:	ldrb.w	r3, [r4, #51]	; 0x33
    5494:	orn	r3, r3, #127	; 0x7f
    5498:	strb.w	r3, [r4, #51]	; 0x33
      m_validLength = m_curPosition;
    549c:	mov	r2, r0
    549e:	mov	r3, r1
    54a0:	strd	r2, r3, [r4, #16]
    if (!seekSet(m_validLength)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    54a4:	cmp.w	r8, #0
    54a8:	bne.n	53ec <ExFatFile::write(void const*, unsigned int)+0x34>
    54aa:	b.n	5518 <ExFatFile::write(void const*, unsigned int)+0x160>
    clusterOffset = m_curPosition & m_vol->clusterMask();
    sectorOffset = clusterOffset & m_vol->sectorMask();
    if (clusterOffset == 0) {
      // start of new cluster
      if (m_curCluster != 0) {
    54ac:	ldr	r7, [r4, #24]
    54ae:	cbz	r7, 54fe <ExFatFile::write(void const*, unsigned int)+0x146>
        int fg;

        if (isContiguous()) {
    54b0:	ldrb.w	r3, [r4, #51]	; 0x33
    54b4:	lsls	r3, r3, #25
    54b6:	bpl.n	54ee <ExFatFile::write(void const*, unsigned int)+0x136>
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    54b8:	ldrb.w	r2, [r0, #1093]	; 0x445
      // start of new cluster
      if (m_curCluster != 0) {
        int fg;

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
    54bc:	ldr	r3, [r4, #28]
    54be:	str	r3, [sp, #4]
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    54c0:	ldrd	r0, r1, [r4, #8]
    54c4:	adds	r2, #9
    54c6:	adds.w	r0, r0, #4294967295
    54ca:	adc.w	r1, r1, #4294967295
    54ce:	uxtb	r2, r2
    54d0:	bl	a4ec <__aeabi_llsr>
    54d4:	ldr	r3, [sp, #4]
    54d6:	add	r0, r3
    54d8:	cmp	r7, r0
    54da:	bcc.n	54e8 <ExFatFile::write(void const*, unsigned int)+0x130>
            goto fail;
          }
        }
        if (fg == 0) {
          // add cluster if at end of chain
          if (!addCluster()) {
    54dc:	mov	r0, r4
    54de:	bl	4cd4 <ExFatFile::addCluster()>
    54e2:	cmp	r0, #0
    54e4:	bne.n	53fe <ExFatFile::write(void const*, unsigned int)+0x46>
    54e6:	b.n	5542 <ExFatFile::write(void const*, unsigned int)+0x18a>

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
            m_curCluster++;
    54e8:	adds	r7, #1
    54ea:	str	r7, [r4, #24]
    54ec:	b.n	53fe <ExFatFile::write(void const*, unsigned int)+0x46>
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    54ee:	ldr	r2, [sp, #0]
    54f0:	mov	r1, r7
    54f2:	bl	49a0 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    54f6:	cmp	r0, #0
    54f8:	blt.n	5542 <ExFatFile::write(void const*, unsigned int)+0x18a>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
        if (fg == 0) {
    54fa:	bne.n	53fe <ExFatFile::write(void const*, unsigned int)+0x46>
    54fc:	b.n	54dc <ExFatFile::write(void const*, unsigned int)+0x124>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    54fe:	ldr	r3, [r4, #28]
    5500:	cbnz	r3, 5510 <ExFatFile::write(void const*, unsigned int)+0x158>
          // allocate first cluster of file
          if (!addCluster()) {
    5502:	mov	r0, r4
    5504:	bl	4cd4 <ExFatFile::addCluster()>
    5508:	cbz	r0, 5542 <ExFatFile::write(void const*, unsigned int)+0x18a>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    550a:	ldr	r3, [r4, #24]
    550c:	str	r3, [r4, #28]
    550e:	b.n	53fe <ExFatFile::write(void const*, unsigned int)+0x46>
        } else {
          m_curCluster = m_firstCluster;
    5510:	str	r3, [r4, #24]
    5512:	b.n	53fe <ExFatFile::write(void const*, unsigned int)+0x46>
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    5514:	movs	r2, #1
    5516:	b.n	5436 <ExFatFile::write(void const*, unsigned int)+0x7e>
    if (m_curPosition > m_validLength) {
      m_flags |= FILE_FLAG_DIR_DIRTY;
      m_validLength = m_curPosition;
    }
  }
  if (m_curPosition > m_dataLength) {
    5518:	ldrd	r0, r1, [r4]
    551c:	ldrd	r2, r3, [r4, #8]
    5520:	cmp	r3, r1
    5522:	it	eq
    5524:	cmpeq	r2, r0
    5526:	bcs.n	552e <ExFatFile::write(void const*, unsigned int)+0x176>
    m_dataLength = m_curPosition;
    5528:	strd	r0, r1, [r4, #8]
    552c:	b.n	5534 <ExFatFile::write(void const*, unsigned int)+0x17c>
    // update fileSize and insure sync will update dir entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    552e:	ldr	r3, [pc, #148]	; (55c4 <ExFatFile::write(void const*, unsigned int)+0x20c>)
    5530:	ldr	r3, [r3, #0]
    5532:	cbz	r3, 5552 <ExFatFile::write(void const*, unsigned int)+0x19a>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    5534:	ldrb.w	r3, [r4, #51]	; 0x33
    5538:	orn	r3, r3, #127	; 0x7f
    553c:	strb.w	r3, [r4, #51]	; 0x33
    5540:	b.n	5552 <ExFatFile::write(void const*, unsigned int)+0x19a>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    5542:	ldrb.w	r3, [r4, #50]	; 0x32
    5546:	orr.w	r3, r3, #1
    554a:	strb.w	r3, [r4, #50]	; 0x32
  return 0;
    554e:	movs	r0, #0
    5550:	b.n	55be <ExFatFile::write(void const*, unsigned int)+0x206>
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
  }
  return nbyte;
    5552:	mov	r0, sl
    5554:	b.n	55be <ExFatFile::write(void const*, unsigned int)+0x206>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
    5556:	cmp.w	r8, #1024	; 0x400
    555a:	ldr.w	r7, [lr, #540]	; 0x21c
    555e:	ldr.w	r0, [lr, #532]	; 0x214
    5562:	bcc.n	558e <ExFatFile::write(void const*, unsigned int)+0x1d6>
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
      // Limit writes to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    5564:	lsl.w	r3, fp, r2
    5568:	subs	r6, r3, r6
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
    556a:	mov.w	ip, r8, lsr #9
    556e:	cmp	ip, r6
    5570:	mov	r3, ip
    5572:	it	cs
    5574:	movcs	r3, r6
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    5576:	cmp	r1, r7
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    5578:	mov.w	r6, r3, lsl #9
    557c:	bhi.n	5584 <ExFatFile::write(void const*, unsigned int)+0x1cc>
    557e:	adds	r2, r1, r3
    5580:	cmp	r7, r2
    5582:	bcc.n	55b0 <ExFatFile::write(void const*, unsigned int)+0x1f8>
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    5584:	ldr	r2, [r0, #0]
    5586:	ldr	r5, [r2, #36]	; 0x24
    5588:	mov	r2, r9
    558a:	blx	r5
    558c:	b.n	5468 <ExFatFile::write(void const*, unsigned int)+0xb0>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    558e:	cmp	r1, r7
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    5590:	ittt	eq
    5592:	strbeq.w	r5, [lr, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    5596:	moveq.w	r3, #4294967295
    559a:	streq.w	r3, [lr, #540]	; 0x21c
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    559e:	ldr	r3, [r0, #0]
    55a0:	mov	r2, r9
    55a2:	ldr	r3, [r3, #32]
    55a4:	blx	r3
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    55a6:	cmp	r0, #0
    55a8:	beq.n	5542 <ExFatFile::write(void const*, unsigned int)+0x18a>
         DBG_FAIL_MACRO;
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
    55aa:	mov.w	r6, #512	; 0x200
    55ae:	b.n	546c <ExFatFile::write(void const*, unsigned int)+0xb4>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    55b0:	mov.w	r2, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    55b4:	strb.w	r5, [lr, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    55b8:	str.w	r2, [lr, #540]	; 0x21c
    55bc:	b.n	5584 <ExFatFile::write(void const*, unsigned int)+0x1cc>

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
  return 0;
}
    55be:	add	sp, #12
    55c0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    55c4:	.word	0x2001ceb4

000055c8 <initFatDirCallback(unsigned long, void*)>:
  uint16_t count;
  uint16_t dotcount;
};
static const uint8_t * initFatDirCallback(uint32_t sector, void *context) {
  struct initFatDirState * state = (struct initFatDirState *)context;
  if (state->pr && ++state->count >= state->dotcount) {
    55c8:	ldr	r0, [r1, #4]
  uint8_t * buffer;
  print_t * pr;
  uint16_t count;
  uint16_t dotcount;
};
static const uint8_t * initFatDirCallback(uint32_t sector, void *context) {
    55ca:	push	{r4, lr}
    55cc:	mov	r4, r1
  struct initFatDirState * state = (struct initFatDirState *)context;
  if (state->pr && ++state->count >= state->dotcount) {
    55ce:	cbz	r0, 55e8 <initFatDirCallback(unsigned long, void*)+0x20>
    55d0:	ldrh	r3, [r1, #8]
    55d2:	ldrh	r2, [r1, #10]
    55d4:	adds	r3, #1
    55d6:	uxth	r3, r3
    55d8:	cmp	r2, r3
    55da:	strh	r3, [r1, #8]
    55dc:	bhi.n	55e8 <initFatDirCallback(unsigned long, void*)+0x20>
    state->pr->write(".");
    55de:	ldr	r1, [pc, #12]	; (55ec <initFatDirCallback(unsigned long, void*)+0x24>)
    55e0:	bl	760 <Print::write(char const*)>
    state->count = 0;
    55e4:	movs	r3, #0
    55e6:	strh	r3, [r4, #8]
  }
  return state->buffer;
    55e8:	ldr	r0, [r4, #0]
}
    55ea:	pop	{r4, pc}
    55ec:	.word	0x00012cf9

000055f0 <FatFormatter::initFatDir(unsigned char, unsigned long)>:
bool FatFormatter::initFatDir(uint8_t fatType, uint32_t sectorCount) {
    55f0:	push	{r4, r5, r6, r7, lr}
    55f2:	mov	r4, r0
    55f4:	sub	sp, #28
    55f6:	mov	r6, r1
    55f8:	mov	r5, r2
  size_t n;
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    55fa:	movs	r1, #0
    55fc:	mov.w	r2, #512	; 0x200
    5600:	ldr	r0, [r0, #36]	; 0x24
    5602:	bl	9078 <memset>
  writeMsg("Writing FAT ");
    5606:	ldr	r0, [r4, #32]
    5608:	cbz	r0, 5610 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x20>
    560a:	ldr	r1, [pc, #128]	; (568c <FatFormatter::initFatDir(unsigned char, unsigned long)+0x9c>)
    560c:	bl	760 <Print::write(char const*)>
  struct initFatDirState state;
  state.buffer = m_secBuf;
    5610:	ldr	r3, [r4, #36]	; 0x24
    5612:	str	r3, [sp, #12]
  state.pr = m_pr;
    5614:	ldr	r3, [r4, #32]
    5616:	str	r3, [sp, #16]
  state.count = 0;
  state.dotcount = sectorCount/32;
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    5618:	ldr	r0, [r4, #28]
    561a:	ldr	r1, [r4, #12]
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
  writeMsg("Writing FAT ");
  struct initFatDirState state;
  state.buffer = m_secBuf;
  state.pr = m_pr;
  state.count = 0;
    561c:	movs	r3, #0
    561e:	strh.w	r3, [sp, #20]
  state.dotcount = sectorCount/32;
    5622:	lsrs	r3, r5, #5
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    5624:	add	r2, sp, #12
  writeMsg("Writing FAT ");
  struct initFatDirState state;
  state.buffer = m_secBuf;
  state.pr = m_pr;
  state.count = 0;
  state.dotcount = sectorCount/32;
    5626:	strh.w	r3, [sp, #22]
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    562a:	ldr	r3, [r0, #0]
    562c:	str	r2, [sp, #0]
    562e:	ldr	r7, [r3, #40]	; 0x28
    5630:	ldr	r3, [pc, #92]	; (5690 <FatFormatter::initFatDir(unsigned char, unsigned long)+0xa0>)
    5632:	subs	r2, r5, #1
    5634:	adds	r1, #1
    5636:	blx	r7
    5638:	cbnz	r0, 563e <FatFormatter::initFatDir(unsigned char, unsigned long)+0x4e>
     return false;
    563a:	movs	r0, #0
    563c:	b.n	5686 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x96>
  }
  writeMsg("\r\n");
    563e:	ldr	r0, [r4, #32]
    5640:	cbz	r0, 5648 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x58>
    5642:	ldr	r1, [pc, #80]	; (5694 <FatFormatter::initFatDir(unsigned char, unsigned long)+0xa4>)
    5644:	bl	760 <Print::write(char const*)>
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
    5648:	ldr	r3, [r4, #36]	; 0x24
    564a:	movs	r2, #248	; 0xf8
  n = fatType == 16 ? 4 : 12;
    564c:	cmp	r6, #16
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
     return false;
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
    564e:	strb	r2, [r3, #0]
  n = fatType == 16 ? 4 : 12;
  for (size_t i = 1; i < n; i++) {
    m_secBuf[i] = 0XFF;
    5650:	mov.w	r0, #255	; 0xff
     return false;
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
  n = fatType == 16 ? 4 : 12;
    5654:	ite	eq
    5656:	moveq	r2, #4
    5658:	movne	r2, #12
  for (size_t i = 1; i < n; i++) {
    565a:	movs	r3, #1
    m_secBuf[i] = 0XFF;
    565c:	ldr	r1, [r4, #36]	; 0x24
    565e:	strb	r0, [r1, r3]
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
  n = fatType == 16 ? 4 : 12;
  for (size_t i = 1; i < n; i++) {
    5660:	adds	r3, #1
    5662:	cmp	r2, r3
    5664:	bne.n	565c <FatFormatter::initFatDir(unsigned char, unsigned long)+0x6c>
    m_secBuf[i] = 0XFF;
  }
  return m_dev->writeSector(m_fatStart, m_secBuf) &&
    5666:	ldr	r0, [r4, #28]
    5668:	ldr	r2, [r4, #36]	; 0x24
    566a:	ldr	r3, [r0, #0]
    566c:	ldr	r1, [r4, #12]
    566e:	ldr	r3, [r3, #32]
    5670:	blx	r3
    5672:	cmp	r0, #0
    5674:	beq.n	563a <FatFormatter::initFatDir(unsigned char, unsigned long)+0x4a>
         m_dev->writeSector(m_fatStart + m_fatSize, m_secBuf);
    5676:	ldr	r0, [r4, #28]
    5678:	ldr	r5, [r4, #12]
    567a:	ldr	r1, [r4, #8]
    567c:	ldr	r3, [r0, #0]
    567e:	ldr	r2, [r4, #36]	; 0x24
    5680:	ldr	r3, [r3, #32]
    5682:	add	r1, r5
    5684:	blx	r3
}
    5686:	add	sp, #28
    5688:	pop	{r4, r5, r6, r7, pc}
    568a:	nop
    568c:	.word	0x00012cec
    5690:	.word	0x000055c9
    5694:	.word	0x00012d6b

00005698 <FatFormatter::initPbs()>:
//------------------------------------------------------------------------------
void FatFormatter::initPbs() {
    5698:	push	{r3, r4, r5, lr}
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    569a:	ldr	r4, [r0, #36]	; 0x24
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    569c:	mov.w	r2, #512	; 0x200
    56a0:	movs	r1, #0
  }
  return m_dev->writeSector(m_fatStart, m_secBuf) &&
         m_dev->writeSector(m_fatStart + m_fatSize, m_secBuf);
}
//------------------------------------------------------------------------------
void FatFormatter::initPbs() {
    56a2:	mov	r5, r0
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    56a4:	mov	r0, r4
    56a6:	bl	9078 <memset>
  pbs->jmpInstruction[0] = 0XEB;
    56aa:	movs	r3, #235	; 0xeb
    56ac:	strb	r3, [r4, #0]
  pbs->jmpInstruction[1] = 0X76;
    56ae:	movs	r3, #118	; 0x76
    56b0:	strb	r3, [r4, #1]
  pbs->jmpInstruction[2] = 0X90;
    56b2:	mov	r3, r4
    56b4:	movs	r2, #144	; 0x90
    56b6:	strb.w	r2, [r3, #2]!
  for (uint8_t i = 0; i < sizeof(pbs->oemName); i++) {
    pbs->oemName[i] = ' ';
    56ba:	movs	r1, #32
    56bc:	add.w	r2, r4, #10
    56c0:	strb.w	r1, [r3, #1]!
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
  pbs->jmpInstruction[0] = 0XEB;
  pbs->jmpInstruction[1] = 0X76;
  pbs->jmpInstruction[2] = 0X90;
  for (uint8_t i = 0; i < sizeof(pbs->oemName); i++) {
    56c4:	cmp	r3, r2
    56c6:	bne.n	56c0 <FatFormatter::initPbs()+0x28>
    56c8:	mov.w	r3, #512	; 0x200
    56cc:	strh.w	r3, [r4, #11]
    pbs->oemName[i] = ' ';
  }
  setLe16(pbs->bpb.bpb16.bytesPerSector, BYTES_PER_SECTOR);
  pbs->bpb.bpb16.sectorsPerCluster = m_sectorsPerCluster;
    56d0:	ldrb.w	r3, [r5, #43]	; 0x2b
    56d4:	strb	r3, [r4, #13]
  setLe16(pbs->bpb.bpb16.reservedSectorCount, m_reservedSectorCount);
    56d6:	ldrh	r3, [r5, #40]	; 0x28
    56d8:	strh	r3, [r4, #14]
  pbs->bpb.bpb16.fatCount = 2;
    56da:	movs	r3, #2
    56dc:	strb	r3, [r4, #16]
  // skip rootDirEntryCount
  // skip totalSectors16
  pbs->bpb.bpb16.mediaType = 0XF8;
    56de:	movs	r3, #248	; 0xf8
    56e0:	strb	r3, [r4, #21]
  // skip sectorsPerFat16
  // skip sectorsPerTrack
  // skip headCount
  setLe32(pbs->bpb.bpb16.hidddenSectors, m_relativeSectors);
    56e2:	ldr	r3, [r5, #16]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    56e4:	str	r3, [r4, #28]
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
    56e6:	ldr	r3, [r5, #24]
    56e8:	str	r3, [r4, #32]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    56ea:	movw	r3, #43605	; 0xaa55
    56ee:	strh.w	r3, [r4, #510]	; 0x1fe
    56f2:	pop	{r3, r4, r5, pc}

000056f4 <FatFormatter::writeMbr()>:
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
}
//------------------------------------------------------------------------------
bool FatFormatter::writeMbr() {
    56f4:	push	{r4, r5, r6, lr}
    56f6:	mov	r4, r0
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    56f8:	mov.w	r2, #512	; 0x200
    56fc:	movs	r1, #0
    56fe:	ldr	r0, [r0, #36]	; 0x24
    5700:	bl	9078 <memset>
  MbrSector_t* mbr = reinterpret_cast<MbrSector_t*>(m_secBuf);
    5704:	ldr	r5, [r4, #36]	; 0x24

#if USE_LBA_TO_CHS
  lbaToMbrChs(mbr->part->beginCHS, m_capacityMB, m_relativeSectors);
    5706:	ldr	r2, [r4, #16]
    5708:	ldr	r1, [r4, #0]
    570a:	addw	r0, r5, #447	; 0x1bf
    570e:	bl	3748 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>
  lbaToMbrChs(mbr->part->endCHS, m_capacityMB,
              m_relativeSectors + m_totalSectors -1);
    5712:	ldr	r3, [r4, #24]
    5714:	ldr	r2, [r4, #16]
    5716:	ldr	r1, [r4, #0]
    5718:	add	r2, r3
    571a:	addw	r0, r5, #451	; 0x1c3
    571e:	subs	r2, #1
    5720:	bl	3748 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
#endif  // USE_LBA_TO_CHS

  mbr->part->type = m_partType;
    5724:	ldrb.w	r3, [r4, #42]	; 0x2a
    5728:	strb.w	r3, [r5, #450]	; 0x1c2
  setLe32(mbr->part->relativeSectors, m_relativeSectors);
    572c:	ldr	r3, [r4, #16]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    572e:	str.w	r3, [r5, #454]	; 0x1c6
  setLe32(mbr->part->totalSectors, m_totalSectors);
    5732:	ldr	r3, [r4, #24]
  setLe16(mbr->signature, MBR_SIGNATURE);
  return m_dev->writeSector(0, m_secBuf);
    5734:	ldr	r0, [r4, #28]
    5736:	str.w	r3, [r5, #458]	; 0x1ca
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    573a:	movw	r3, #43605	; 0xaa55
    573e:	strh.w	r3, [r5, #510]	; 0x1fe
    5742:	ldr	r3, [r0, #0]
    5744:	ldr	r2, [r4, #36]	; 0x24
    5746:	ldr	r3, [r3, #32]
    5748:	movs	r1, #0
}
    574a:	ldmia.w	sp!, {r4, r5, r6, lr}

  mbr->part->type = m_partType;
  setLe32(mbr->part->relativeSectors, m_relativeSectors);
  setLe32(mbr->part->totalSectors, m_totalSectors);
  setLe16(mbr->signature, MBR_SIGNATURE);
  return m_dev->writeSector(0, m_secBuf);
    574e:	bx	r3

00005750 <FatFormatter::makeFat16()>:
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
  // skip rest of bpb
  setLe16(pbs->signature, PBR_SIGNATURE);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
    5750:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    5752:	mov.w	r3, #256	; 0x100
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    5756:	ldr	r5, [r0, #36]	; 0x24

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    5758:	ldr.w	lr, [r0, #20]
    575c:	ldrb.w	r2, [r0, #43]	; 0x2b
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    5760:	str	r3, [r0, #4]
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
  // skip rest of bpb
  setLe16(pbs->signature, PBR_SIGNATURE);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
    5762:	mov	r4, r0
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    5764:	ldr	r3, [r4, #4]
    5766:	rsb	r1, r3, lr
    576a:	udiv	r1, r1, r2
    m_fatSize = (nc + 2 + (BYTES_PER_SECTOR/2) - 1)/(BYTES_PER_SECTOR/2);
    576e:	addw	r6, r1, #257	; 0x101
    5772:	lsrs	r6, r6, #8
    r = BU16 + 1 + 2*m_fatSize + FAT16_ROOT_SECTOR_COUNT;
    5774:	lsls	r0, r6, #1
    5776:	add.w	r7, r0, #161	; 0xa1
    if (m_dataStart >= r) {
    577a:	cmp	r3, r7
    577c:	bcc.n	5794 <FatFormatter::makeFat16()+0x44>
      m_relativeSectors = m_dataStart - r + BU16;
    577e:	subs	r3, r3, r7
    5780:	str	r6, [r4, #8]
    5782:	add.w	r6, r3, #128	; 0x80
    5786:	str	r6, [r4, #16]
      break;
    }
  }
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    5788:	subw	r6, r1, #4085	; 0xff5
    578c:	cmp.w	r6, #61440	; 0xf000
    5790:	bcs.n	579a <FatFormatter::makeFat16()+0x4a>
    5792:	b.n	57a8 <FatFormatter::makeFat16()+0x58>
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    5794:	adds	r3, #128	; 0x80
    5796:	str	r3, [r4, #4]
    5798:	b.n	5764 <FatFormatter::makeFat16()+0x14>
      break;
    }
  }
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    579a:	ldr	r0, [r4, #32]
    579c:	cmp	r0, #0
    579e:	beq.n	5848 <FatFormatter::makeFat16()+0xf8>
    57a0:	ldr	r1, [pc, #168]	; (584c <FatFormatter::makeFat16()+0xfc>)
    57a2:	bl	760 <Print::write(char const*)>
    57a6:	b.n	5848 <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  m_reservedSectorCount = 1;
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
    57a8:	adds	r3, #129	; 0x81
    57aa:	str	r3, [r4, #12]
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
    57ac:	add.w	r3, r0, #33	; 0x21
    57b0:	mla	r3, r1, r2, r3
  if (m_totalSectors < 65536) {
    57b4:	cmp.w	r3, #65536	; 0x10000
    return false;
  }
  m_reservedSectorCount = 1;
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
    57b8:	str	r3, [r4, #24]
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = 1;
    57ba:	mov.w	r6, #1
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
  if (m_totalSectors < 65536) {
    m_partType = 0X04;
    57be:	ite	cc
    57c0:	movcc	r3, #4
  } else {
    m_partType = 0X06;
    57c2:	movcs	r3, #6
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = 1;
    57c4:	strh	r6, [r4, #40]	; 0x28
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
  if (m_totalSectors < 65536) {
    m_partType = 0X04;
  } else {
    m_partType = 0X06;
    57c6:	strb.w	r3, [r4, #42]	; 0x2a
  }
  // write MBR
  if (!writeMbr()) {
    57ca:	mov	r0, r4
    57cc:	bl	56f4 <FatFormatter::writeMbr()>
    57d0:	cmp	r0, #0
    57d2:	beq.n	5848 <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  initPbs();
    57d4:	mov	r0, r4
    57d6:	bl	5698 <FatFormatter::initPbs()>
    57da:	mov.w	r3, #512	; 0x200
    57de:	strh.w	r3, [r5, #17]
    57e2:	ldr	r3, [r4, #8]
    57e4:	strh	r3, [r5, #22]
  setLe16(pbs->bpb.bpb16.rootDirEntryCount, FAT16_ROOT_ENTRY_COUNT);
  setLe16(pbs->bpb.bpb16.sectorsPerFat16, m_fatSize);
  pbs->bpb.bpb16.physicalDriveNumber = 0X80;
    57e6:	movs	r3, #128	; 0x80
    57e8:	strb.w	r3, [r5, #36]	; 0x24
  pbs->bpb.bpb16.extSignature = EXTENDED_BOOT_SIGNATURE;
    57ec:	movs	r3, #41	; 0x29
    57ee:	strb.w	r3, [r5, #38]	; 0x26
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    57f2:	ldr	r3, [pc, #92]	; (5850 <FatFormatter::makeFat16()+0x100>)
    57f4:	str.w	r3, [r5, #39]	; 0x27
    57f8:	add.w	r2, r5, #53	; 0x35
    57fc:	add.w	r3, r5, #42	; 0x2a
  setLe32(pbs->bpb.bpb16.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb16.volumeLabel); i++) {
    pbs->bpb.bpb16.volumeLabel[i] = ' ';
    5800:	movs	r1, #32
    5802:	strb.w	r1, [r3, #1]!
  setLe16(pbs->bpb.bpb16.rootDirEntryCount, FAT16_ROOT_ENTRY_COUNT);
  setLe16(pbs->bpb.bpb16.sectorsPerFat16, m_fatSize);
  pbs->bpb.bpb16.physicalDriveNumber = 0X80;
  pbs->bpb.bpb16.extSignature = EXTENDED_BOOT_SIGNATURE;
  setLe32(pbs->bpb.bpb16.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb16.volumeLabel); i++) {
    5806:	cmp	r3, r2
    5808:	bne.n	5802 <FatFormatter::makeFat16()+0xb2>
    pbs->bpb.bpb16.volumeLabel[i] = ' ';
  }
  pbs->bpb.bpb16.volumeType[0] = 'F';
    580a:	movs	r3, #70	; 0x46
    580c:	strb.w	r3, [r5, #54]	; 0x36
  pbs->bpb.bpb16.volumeType[1] = 'A';
    5810:	movs	r3, #65	; 0x41
    5812:	strb.w	r3, [r5, #55]	; 0x37
  pbs->bpb.bpb16.volumeType[2] = 'T';
    5816:	movs	r3, #84	; 0x54
    5818:	strb.w	r3, [r5, #56]	; 0x38
  pbs->bpb.bpb16.volumeType[3] = '1';
    581c:	movs	r3, #49	; 0x31
    581e:	strb.w	r3, [r5, #57]	; 0x39
  pbs->bpb.bpb16.volumeType[4] = '6';
    5822:	movs	r3, #54	; 0x36
    5824:	strb.w	r3, [r5, #58]	; 0x3a
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)) {
    5828:	ldr	r0, [r4, #28]
    582a:	ldr	r2, [r4, #36]	; 0x24
    582c:	ldr	r3, [r0, #0]
    582e:	ldr	r1, [r4, #16]
    5830:	ldr	r3, [r3, #32]
    5832:	blx	r3
    5834:	cbz	r0, 5848 <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
    5836:	ldr	r2, [r4, #4]
    5838:	ldr	r3, [r4, #12]
    583a:	mov	r0, r4
    583c:	subs	r2, r2, r3
    583e:	movs	r1, #16
}
    5840:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  pbs->bpb.bpb16.volumeType[3] = '1';
  pbs->bpb.bpb16.volumeType[4] = '6';
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)) {
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
    5844:	b.w	55f0 <FatFormatter::initFatDir(unsigned char, unsigned long)>
}
    5848:	movs	r0, #0
    584a:	pop	{r3, r4, r5, r6, r7, pc}
    584c:	.word	0x00012d45
    5850:	.word	0x0012d687

00005854 <FatFormatter::makeFat32()>:
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
    5854:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
    5856:	mov.w	r3, #8192	; 0x2000
    585a:	str	r3, [r0, #16]
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    585c:	mov.w	r3, #16384	; 0x4000
    5860:	str	r3, [r0, #4]
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    5862:	ldr	r5, [r0, #36]	; 0x24
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    5864:	ldr	r3, [r0, #20]
    5866:	ldrb.w	r1, [r0, #43]	; 0x2b
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
    586a:	mov	r4, r0
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    586c:	ldr	r2, [r4, #4]
    586e:	subs	r0, r3, r2
    5870:	udiv	r0, r0, r1
    m_fatSize = (nc + 2 + (BYTES_PER_SECTOR/4) - 1)/(BYTES_PER_SECTOR/4);
    5874:	add.w	r6, r0, #129	; 0x81
    5878:	lsrs	r6, r6, #7
    r = m_relativeSectors + 9 + 2*m_fatSize;
    if (m_dataStart >= r) {
    587a:	mov.w	lr, r6, lsl #1
    587e:	add.w	r7, lr, #8192	; 0x2000
    5882:	adds	r7, #9
    5884:	cmp	r2, r7
    5886:	bcs.n	5890 <FatFormatter::makeFat32()+0x3c>
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    5888:	add.w	r2, r2, #8192	; 0x2000
    588c:	str	r2, [r4, #4]
    588e:	b.n	586c <FatFormatter::makeFat32()+0x18>
    if (m_dataStart >= r) {
      break;
    }
  }
  // error if too few clusters in FAT32 volume
  if (nc < 65525) {
    5890:	movw	r3, #65524	; 0xfff4
    5894:	cmp	r0, r3
    5896:	str	r6, [r4, #8]
    5898:	bhi.n	58aa <FatFormatter::makeFat32()+0x56>
    writeMsg("Bad cluster count\r\n");
    589a:	ldr	r0, [r4, #32]
    589c:	cmp	r0, #0
    589e:	beq.w	59e2 <FatFormatter::makeFat32()+0x18e>
    58a2:	ldr	r1, [pc, #324]	; (59e8 <FatFormatter::makeFat32()+0x194>)
    58a4:	bl	760 <Print::write(char const*)>
    58a8:	b.n	59e2 <FatFormatter::makeFat32()+0x18e>
    return false;
  }
  m_reservedSectorCount = m_dataStart - m_relativeSectors - 2*m_fatSize;
    58aa:	sub.w	r3, r2, #8192	; 0x2000
    58ae:	rsb	r3, lr, r3
    58b2:	uxth	r3, r3
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster + m_dataStart - m_relativeSectors;
    58b4:	mla	r2, r0, r1, r2
  // error if too few clusters in FAT32 volume
  if (nc < 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = m_dataStart - m_relativeSectors - 2*m_fatSize;
    58b8:	strh	r3, [r4, #40]	; 0x28
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
    58ba:	add.w	r3, r3, #8192	; 0x2000
    58be:	str	r3, [r4, #12]
  m_totalSectors = nc*m_sectorsPerCluster + m_dataStart - m_relativeSectors;
    58c0:	sub.w	r3, r2, #8192	; 0x2000
    58c4:	str	r3, [r4, #24]
  // type depends on address of end sector
  // max CHS has lba = 16450560 = 1024*255*63
  if ((m_relativeSectors + m_totalSectors) <= 16450560) {
    58c6:	ldr	r3, [pc, #292]	; (59ec <FatFormatter::makeFat32()+0x198>)
    58c8:	cmp	r2, r3
    // FAT32 with CHS and LBA
    m_partType = 0X0B;
    58ca:	ite	ls
    58cc:	movls	r3, #11
  } else {
    // FAT32 with only LBA
    m_partType = 0X0C;
    58ce:	movhi	r3, #12
    58d0:	strb.w	r3, [r4, #42]	; 0x2a
  }
  if (!writeMbr()) {
    58d4:	mov	r0, r4
    58d6:	bl	56f4 <FatFormatter::writeMbr()>
    58da:	cmp	r0, #0
    58dc:	beq.w	59e2 <FatFormatter::makeFat32()+0x18e>
    return false;
  }
  initPbs();
    58e0:	mov	r0, r4
    58e2:	bl	5698 <FatFormatter::initPbs()>
  setLe32(pbs->bpb.bpb32.sectorsPerFat32, m_fatSize);
    58e6:	ldr	r3, [r4, #8]
    58e8:	str	r3, [r5, #36]	; 0x24
    58ea:	movs	r3, #2
    58ec:	str	r3, [r5, #44]	; 0x2c
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    58ee:	movs	r3, #1
    58f0:	strh	r3, [r5, #48]	; 0x30
    58f2:	movs	r3, #6
    58f4:	strh	r3, [r5, #50]	; 0x32
  setLe32(pbs->bpb.bpb32.fat32RootCluster, 2);
  setLe16(pbs->bpb.bpb32.fat32FSInfoSector, 1);
  setLe16(pbs->bpb.bpb32.fat32BackBootSector, 6);
  pbs->bpb.bpb32.physicalDriveNumber = 0X80;
    58f6:	movs	r3, #128	; 0x80
    58f8:	strb.w	r3, [r5, #64]	; 0x40
  pbs->bpb.bpb32.extSignature = EXTENDED_BOOT_SIGNATURE;
    58fc:	movs	r3, #41	; 0x29
    58fe:	strb.w	r3, [r5, #66]	; 0x42
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    5902:	ldr	r3, [pc, #236]	; (59f0 <FatFormatter::makeFat32()+0x19c>)
    5904:	str.w	r3, [r5, #67]	; 0x43
    5908:	add.w	r2, r5, #81	; 0x51
    590c:	add.w	r3, r5, #70	; 0x46
  setLe32(pbs->bpb.bpb32.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb32.volumeLabel); i++) {
    pbs->bpb.bpb32.volumeLabel[i] = ' ';
    5910:	movs	r1, #32
    5912:	strb.w	r1, [r3, #1]!
  setLe16(pbs->bpb.bpb32.fat32FSInfoSector, 1);
  setLe16(pbs->bpb.bpb32.fat32BackBootSector, 6);
  pbs->bpb.bpb32.physicalDriveNumber = 0X80;
  pbs->bpb.bpb32.extSignature = EXTENDED_BOOT_SIGNATURE;
  setLe32(pbs->bpb.bpb32.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb32.volumeLabel); i++) {
    5916:	cmp	r3, r2
    5918:	bne.n	5912 <FatFormatter::makeFat32()+0xbe>
    pbs->bpb.bpb32.volumeLabel[i] = ' ';
  }
  pbs->bpb.bpb32.volumeType[0] = 'F';
    591a:	movs	r3, #70	; 0x46
    591c:	strb.w	r3, [r5, #82]	; 0x52
  pbs->bpb.bpb32.volumeType[1] = 'A';
    5920:	movs	r3, #65	; 0x41
    5922:	strb.w	r3, [r5, #83]	; 0x53
  pbs->bpb.bpb32.volumeType[2] = 'T';
    5926:	movs	r3, #84	; 0x54
    5928:	strb.w	r3, [r5, #84]	; 0x54
  pbs->bpb.bpb32.volumeType[3] = '3';
    592c:	movs	r3, #51	; 0x33
    592e:	strb.w	r3, [r5, #85]	; 0x55
  pbs->bpb.bpb32.volumeType[4] = '2';
    5932:	movs	r3, #50	; 0x32
    5934:	strb.w	r3, [r5, #86]	; 0x56
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)  ||
    5938:	ldr	r0, [r4, #28]
    593a:	ldr	r2, [r4, #36]	; 0x24
    593c:	ldr	r3, [r0, #0]
    593e:	ldr	r1, [r4, #16]
    5940:	ldr	r3, [r3, #32]
    5942:	blx	r3
    5944:	cmp	r0, #0
    5946:	beq.n	59e2 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 6, m_secBuf)) {
    5948:	ldr	r0, [r4, #28]
    594a:	ldr	r1, [r4, #16]
    594c:	ldr	r3, [r0, #0]
    594e:	ldr	r2, [r4, #36]	; 0x24
    5950:	ldr	r3, [r3, #32]
    5952:	adds	r1, #6
    5954:	blx	r3
  pbs->bpb.bpb32.volumeType[0] = 'F';
  pbs->bpb.bpb32.volumeType[1] = 'A';
  pbs->bpb.bpb32.volumeType[2] = 'T';
  pbs->bpb.bpb32.volumeType[3] = '3';
  pbs->bpb.bpb32.volumeType[4] = '2';
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)  ||
    5956:	cmp	r0, #0
    5958:	beq.n	59e2 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 6, m_secBuf)) {
    return false;
  }
  // write extra boot area and backup
  memset(m_secBuf, 0 , BYTES_PER_SECTOR);
    595a:	mov.w	r2, #512	; 0x200
    595e:	movs	r1, #0
    5960:	ldr	r0, [r4, #36]	; 0x24
    5962:	bl	9078 <memset>
    5966:	ldr	r3, [pc, #140]	; (59f4 <FatFormatter::makeFat32()+0x1a0>)
  setLe32(fsi->trailSignature, FSINFO_TRAIL_SIGNATURE);
  if (!m_dev->writeSector(m_relativeSectors + 2, m_secBuf)  ||
    5968:	ldr	r0, [r4, #28]
    596a:	str.w	r3, [r5, #508]	; 0x1fc
    596e:	ldr	r1, [r4, #16]
    5970:	ldr	r3, [r0, #0]
    5972:	ldr	r2, [r4, #36]	; 0x24
    5974:	ldr	r3, [r3, #32]
    5976:	adds	r1, #2
    5978:	blx	r3
    597a:	cmp	r0, #0
    597c:	beq.n	59e2 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 8, m_secBuf)) {
    597e:	ldr	r0, [r4, #28]
    5980:	ldr	r1, [r4, #16]
    5982:	ldr	r3, [r0, #0]
    5984:	ldr	r2, [r4, #36]	; 0x24
    5986:	ldr	r3, [r3, #32]
    5988:	adds	r1, #8
    598a:	blx	r3
    return false;
  }
  // write extra boot area and backup
  memset(m_secBuf, 0 , BYTES_PER_SECTOR);
  setLe32(fsi->trailSignature, FSINFO_TRAIL_SIGNATURE);
  if (!m_dev->writeSector(m_relativeSectors + 2, m_secBuf)  ||
    598c:	cbz	r0, 59e2 <FatFormatter::makeFat32()+0x18e>
    598e:	ldr	r3, [pc, #104]	; (59f8 <FatFormatter::makeFat32()+0x1a4>)
    5990:	str	r3, [r5, #0]
    5992:	add.w	r3, r3, #534773760	; 0x1fe00000
    5996:	add.w	r3, r3, #8192	; 0x2000
    599a:	adds	r3, #32
    599c:	str.w	r3, [r5, #484]	; 0x1e4
  // write FSINFO sector and backup
  setLe32(fsi->leadSignature, FSINFO_LEAD_SIGNATURE);
  setLe32(fsi->structSignature, FSINFO_STRUCT_SIGNATURE);
  setLe32(fsi->freeCount, 0XFFFFFFFF);
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
    59a0:	ldr	r0, [r4, #28]
    59a2:	ldr	r2, [r4, #36]	; 0x24
    59a4:	mov.w	r3, #4294967295
    59a8:	str.w	r3, [r5, #488]	; 0x1e8
    59ac:	str.w	r3, [r5, #492]	; 0x1ec
    59b0:	ldr	r1, [r4, #16]
    59b2:	ldr	r3, [r0, #0]
    59b4:	adds	r1, #1
    59b6:	ldr	r3, [r3, #32]
    59b8:	blx	r3
    59ba:	cbz	r0, 59e2 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    59bc:	ldr	r0, [r4, #28]
    59be:	ldr	r1, [r4, #16]
    59c0:	ldr	r3, [r0, #0]
    59c2:	ldr	r2, [r4, #36]	; 0x24
    59c4:	ldr	r3, [r3, #32]
    59c6:	adds	r1, #7
    59c8:	blx	r3
  // write FSINFO sector and backup
  setLe32(fsi->leadSignature, FSINFO_LEAD_SIGNATURE);
  setLe32(fsi->structSignature, FSINFO_STRUCT_SIGNATURE);
  setLe32(fsi->freeCount, 0XFFFFFFFF);
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
    59ca:	cbz	r0, 59e2 <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
    59cc:	ldr	r2, [r4, #8]
    59ce:	ldrb.w	r3, [r4, #43]	; 0x2b
    59d2:	mov	r0, r4
    59d4:	add.w	r2, r3, r2, lsl #1
    59d8:	movs	r1, #32
}
    59da:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
    59de:	b.w	55f0 <FatFormatter::initFatDir(unsigned char, unsigned long)>
}
    59e2:	movs	r0, #0
    59e4:	pop	{r3, r4, r5, r6, r7, pc}
    59e6:	nop
    59e8:	.word	0x00012d45
    59ec:	.word	0x00fb0400
    59f0:	.word	0x0012d687
    59f4:	.word	0xaa550000
    59f8:	.word	0x41615252

000059fc <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>:
#define writeMsg(str) if (m_pr) m_pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    59fc:	push	{r3, r4, r5, lr}
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
    59fe:	str	r3, [r0, #32]
  m_sectorCount = m_dev->sectorCount();
    5a00:	ldr	r3, [r1, #0]
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
  bool rtn;
  m_dev = dev;
    5a02:	str	r1, [r0, #28]
  m_secBuf = secBuf;
    5a04:	str	r2, [r0, #36]	; 0x24
#define writeMsg(str) if (m_pr) m_pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    5a06:	mov	r4, r0
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
  m_sectorCount = m_dev->sectorCount();
    5a08:	ldr	r3, [r3, #24]
    5a0a:	mov	r0, r1
    5a0c:	blx	r3
  m_capacityMB = (m_sectorCount + SECTORS_PER_MB - 1)/SECTORS_PER_MB;
    5a0e:	addw	r3, r0, #2047	; 0x7ff
    5a12:	lsrs	r3, r3, #11

  if (m_capacityMB <= 6) {
    5a14:	cmp	r3, #6
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
  m_sectorCount = m_dev->sectorCount();
    5a16:	str	r0, [r4, #20]
  m_capacityMB = (m_sectorCount + SECTORS_PER_MB - 1)/SECTORS_PER_MB;
    5a18:	str	r3, [r4, #0]

  if (m_capacityMB <= 6) {
    5a1a:	bhi.n	5a2a <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2e>
    writeMsg("Card is too small.\r\n");
    5a1c:	ldr	r0, [r4, #32]
    5a1e:	cbz	r0, 5a26 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2a>
    5a20:	ldr	r1, [pc, #108]	; (5a90 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x94>)
    5a22:	bl	760 <Print::write(char const*)>
    return false;
    5a26:	movs	r0, #0
    5a28:	pop	{r3, r4, r5, pc}
  } else if (m_capacityMB <= 16) {
    5a2a:	cmp	r3, #16
    5a2c:	bhi.n	5a32 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x36>
    m_sectorsPerCluster = 2;
    5a2e:	movs	r3, #2
    5a30:	b.n	5a5e <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 32) {
    5a32:	cmp	r3, #32
    5a34:	bhi.n	5a3a <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3e>
    m_sectorsPerCluster = 4;
    5a36:	movs	r3, #4
    5a38:	b.n	5a5e <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 64) {
    5a3a:	cmp	r3, #64	; 0x40
    5a3c:	bhi.n	5a42 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x46>
    m_sectorsPerCluster = 8;
    5a3e:	movs	r3, #8
    5a40:	b.n	5a5e <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 128) {
    5a42:	cmp	r3, #128	; 0x80
    5a44:	bhi.n	5a4a <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x4e>
    m_sectorsPerCluster = 16;
    5a46:	movs	r3, #16
    5a48:	b.n	5a5e <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 1024) {
    5a4a:	cmp.w	r3, #1024	; 0x400
    5a4e:	bhi.n	5a54 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x58>
    m_sectorsPerCluster = 32;
    5a50:	movs	r3, #32
    5a52:	b.n	5a5e <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 32768) {
    5a54:	cmp.w	r3, #32768	; 0x8000
    m_sectorsPerCluster = 64;
    5a58:	ite	ls
    5a5a:	movls	r3, #64	; 0x40
  } else {
    // SDXC cards
    m_sectorsPerCluster = 128;
    5a5c:	movhi	r3, #128	; 0x80
  }
  rtn = m_sectorCount < 0X400000 ? makeFat16() : makeFat32();
    5a5e:	cmp.w	r0, #4194304	; 0x400000
    m_sectorsPerCluster = 32;
  } else if (m_capacityMB <= 32768) {
    m_sectorsPerCluster = 64;
  } else {
    // SDXC cards
    m_sectorsPerCluster = 128;
    5a62:	strb.w	r3, [r4, #43]	; 0x2b
  }
  rtn = m_sectorCount < 0X400000 ? makeFat16() : makeFat32();
    5a66:	mov	r0, r4
    5a68:	bcs.n	5a70 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x74>
    5a6a:	bl	5750 <FatFormatter::makeFat16()>
    5a6e:	b.n	5a74 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x78>
    5a70:	bl	5854 <FatFormatter::makeFat32()>
    5a74:	mov	r5, r0
    5a76:	ldr	r0, [r4, #32]
  if (rtn) {
    5a78:	cbz	r5, 5a84 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x88>
    writeMsg("Format Done\r\n");
    5a7a:	cbz	r0, 5a8c <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x90>
    5a7c:	ldr	r1, [pc, #20]	; (5a94 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x98>)
    5a7e:	bl	760 <Print::write(char const*)>
    5a82:	b.n	5a8c <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x90>
  } else {
    writeMsg("Format Failed\r\n");
    5a84:	cmp	r0, #0
    5a86:	beq.n	5a26 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2a>
    5a88:	ldr	r1, [pc, #12]	; (5a98 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x9c>)
    5a8a:	b.n	5a22 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x26>
    5a8c:	movs	r0, #1
  }
  return rtn;
}
    5a8e:	pop	{r3, r4, r5, pc}
    5a90:	.word	0x00012d59
    5a94:	.word	0x00012d6e
    5a98:	.word	0x00012d7c

00005a9c <FatFile::cacheDir(unsigned short)>:

  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    5a9c:	push	{r4, lr}
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    5a9e:	lsls	r1, r1, #5

  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    5aa0:	mov	r4, r0
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    5aa2:	bl	5f9a <FatFile::seekSet(unsigned long)>
    5aa6:	cbz	r0, 5ab4 <FatFile::cacheDir(unsigned short)+0x18>
    5aa8:	mov	r0, r4
    5aaa:	movs	r1, #0
  }
    5aac:	ldmia.w	sp!, {r4, lr}
  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    5ab0:	b.w	5f60 <FatFile::readDirCache(bool)>
  }
    5ab4:	pop	{r4, pc}

00005ab6 <FatFile::getLfnChar(DirLfn_t*, unsigned char)>:
#include "FatFile.h"
#include "FatVolume.h"

//------------------------------------------------------------------------------
uint16_t FatFile::getLfnChar(DirLfn_t* ldir, uint8_t i) {
  if (i < 5) {
    5ab6:	cmp	r2, #4
    5ab8:	bhi.n	5ac4 <FatFile::getLfnChar(DirLfn_t*, unsigned char)+0xe>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    5aba:	add.w	r1, r1, r2, lsl #1
    5abe:	ldrh.w	r0, [r1, #1]
    return getLe16(ldir->unicode1 + 2*i);
    5ac2:	bx	lr
  } else if (i < 11) {
    5ac4:	cmp	r2, #10
    5ac6:	bhi.n	5ad0 <FatFile::getLfnChar(DirLfn_t*, unsigned char)+0x1a>
    5ac8:	add.w	r1, r1, r2, lsl #1
    5acc:	ldrh	r0, [r1, #4]
    return getLe16(ldir->unicode2 + 2*i - 10);
    5ace:	bx	lr
  } else if (i < 13) {
    5ad0:	cmp	r2, #12
    5ad2:	itte	ls
    5ad4:	addls.w	r1, r1, r2, lsl #1
    5ad8:	ldrhls	r0, [r1, #6]
    return getLe16(ldir->unicode3 + 2*i - 22);
  }
  DBG_HALT_IF(i >= 13);
  return 0;
    5ada:	movhi	r0, #0
}
    5adc:	bx	lr

00005ade <FatFile::getSFN(char*, unsigned int)>:
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
    5ade:	push	{r3, r4, r5, r6, r7, lr}
    5ae0:	mov	r6, r1
    5ae2:	ldrb	r1, [r0, #0]
    5ae4:	mov	r7, r2
  char c;
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
  uint8_t* ptr;
  DirFat_t* dir;
  if (!isOpen()) {
    5ae6:	cbz	r1, 5b60 <FatFile::getSFN(char*, unsigned int)+0x82>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isRoot()) {
    5ae8:	ands.w	r4, r1, #96	; 0x60
    5aec:	beq.n	5afe <FatFile::getSFN(char*, unsigned int)+0x20>
    if (size < 2) {
    5aee:	cmp	r2, #1
    5af0:	bls.n	5b60 <FatFile::getSFN(char*, unsigned int)+0x82>
      DBG_FAIL_MACRO;
      goto fail;
    }
    name[0] = '/';
    5af2:	movs	r3, #47	; 0x2f
    5af4:	strb	r3, [r6, #0]
    name[1] = '\0';
    5af6:	movs	r3, #0
    5af8:	strb	r3, [r6, #1]
    return 1;
    5afa:	movs	r0, #1
    5afc:	pop	{r3, r4, r5, r6, r7, pc}
  }
  // cache entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    5afe:	mov	r1, r4
    5b00:	bl	5d44 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    5b04:	cbz	r0, 5b60 <FatFile::getSFN(char*, unsigned int)+0x82>
    DBG_FAIL_MACRO;
    goto fail;
  }
  ptr = dir->name;
    5b06:	mov	r5, r0
    5b08:	mov	r1, r4
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
  char c;
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
    5b0a:	movs	r2, #8
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
  char c;
  uint8_t j = 0;
    5b0c:	mov	r3, r4
    goto fail;
  }
  ptr = dir->name;
  // format name
  for (uint8_t i = 0; i < 12; i++) {
    if (i == 8) {
    5b0e:	cmp	r1, #8
    5b10:	ldrb	r4, [r5, #0]
    5b12:	bne.n	5b1e <FatFile::getSFN(char*, unsigned int)+0x40>
      if (*ptr == ' ') {
    5b14:	cmp	r4, #32
    5b16:	beq.n	5b58 <FatFile::getSFN(char*, unsigned int)+0x7a>
        break;
      }
      lcBit = FAT_CASE_LC_EXT;
    5b18:	movs	r2, #16
      c = '.';
    5b1a:	movs	r4, #46	; 0x2e
    5b1c:	b.n	5b40 <FatFile::getSFN(char*, unsigned int)+0x62>
    } else {
      c = *ptr++;
      if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
    5b1e:	sub.w	lr, r4, #65	; 0x41
    5b22:	cmp.w	lr, #25
        break;
      }
      lcBit = FAT_CASE_LC_EXT;
      c = '.';
    } else {
      c = *ptr++;
    5b26:	add.w	r5, r5, #1
      if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
    5b2a:	bhi.n	5b3c <FatFile::getSFN(char*, unsigned int)+0x5e>
    5b2c:	ldrb.w	lr, [r0, #12]
    5b30:	tst.w	r2, lr
    5b34:	beq.n	5b40 <FatFile::getSFN(char*, unsigned int)+0x62>
        c += 'a' - 'A';
    5b36:	adds	r4, #32
    5b38:	uxtb	r4, r4
    5b3a:	b.n	5b40 <FatFile::getSFN(char*, unsigned int)+0x62>
      }
      if (c == ' ') {
    5b3c:	cmp	r4, #32
    5b3e:	beq.n	5b52 <FatFile::getSFN(char*, unsigned int)+0x74>
        continue;
      }
    }
    if ((j + 1u) == size) {
    5b40:	add.w	lr, r3, #1
    5b44:	cmp	r7, lr
    5b46:	mov	ip, r3
    5b48:	beq.n	5b58 <FatFile::getSFN(char*, unsigned int)+0x7a>
      break;
    }
    name[j++] = c;
    5b4a:	strb.w	r4, [r6, ip]
    5b4e:	uxtb.w	r3, lr
    5b52:	adds	r1, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  ptr = dir->name;
  // format name
  for (uint8_t i = 0; i < 12; i++) {
    5b54:	cmp	r1, #12
    5b56:	bne.n	5b0e <FatFile::getSFN(char*, unsigned int)+0x30>
    if ((j + 1u) == size) {
      break;
    }
    name[j++] = c;
  }
  name[j] = '\0';
    5b58:	movs	r2, #0
    5b5a:	strb	r2, [r6, r3]
  return j;
    5b5c:	mov	r0, r3
    5b5e:	pop	{r3, r4, r5, r6, r7, pc}

 fail:
  name[0] = '\0';
    5b60:	movs	r0, #0
    5b62:	strb	r0, [r6, #0]
  return 0;
}
    5b64:	pop	{r3, r4, r5, r6, r7, pc}
    5b66:	Address 0x00005b66 is out of bounds.


00005b68 <FatFile::getName8(char*, unsigned int)>:
 fail:
  name[0] = '\0';
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getName8(char* name, size_t size) {
    5b68:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5b6c:	sub	sp, #44	; 0x2c
  char* ptr;
  FatFile dir;
  DirLfn_t* ldir;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    5b6e:	ldrb	r3, [r0, #0]
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    5b70:	movs	r4, #0
 fail:
  name[0] = '\0';
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getName8(char* name, size_t size) {
    5b72:	mov	r7, r0
    5b74:	mov	r9, r1
    5b76:	mov	r8, r2
    5b78:	strb.w	r4, [sp, #4]
    5b7c:	strb.w	r4, [sp, #5]
    5b80:	strb.w	r4, [sp, #6]
  char* ptr;
  FatFile dir;
  DirLfn_t* ldir;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    5b84:	cmp	r3, #0
    5b86:	beq.n	5c48 <FatFile::getName8(char*, unsigned int)+0xe0>
      DBG_FAIL_MACRO;
      goto fail;
  }
  if (!isLFN()) {
    5b88:	ldrb	r3, [r0, #3]
    5b8a:	cbnz	r3, 5b92 <FatFile::getName8(char*, unsigned int)+0x2a>
    return getSFN(name, size);
    5b8c:	bl	5ade <FatFile::getSFN(char*, unsigned int)>
    5b90:	b.n	5c4e <FatFile::getName8(char*, unsigned int)+0xe6>
  }
  if (!dir.openCluster(this)) {
    5b92:	mov	r1, r0
    5b94:	add	r0, sp, #4
    5b96:	bl	5d92 <FatFile::openCluster(FatFile*)>
    5b9a:	cmp	r0, #0
    5b9c:	beq.n	5c48 <FatFile::getName8(char*, unsigned int)+0xe0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    5b9e:	add.w	r8, r8, #4294967295
    5ba2:	mov	r5, r9
    5ba4:	movs	r6, #1
    5ba6:	add	r8, r9
  }
  if (!dir.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    5ba8:	ldrb	r3, [r7, #3]
    5baa:	cmp	r3, r6
    5bac:	bcc.n	5c3e <FatFile::getName8(char*, unsigned int)+0xd6>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(m_dirIndex - order));
    5bae:	ldrh	r1, [r7, #4]
    5bb0:	subs	r1, r1, r6
    5bb2:	uxth	r1, r1
    5bb4:	add	r0, sp, #4
    5bb6:	bl	5a9c <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    5bba:	mov	fp, r0
    5bbc:	cmp	r0, #0
    5bbe:	beq.n	5c48 <FatFile::getName8(char*, unsigned int)+0xe0>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    5bc0:	ldrb	r3, [r0, #11]
    5bc2:	cmp	r3, #15
    5bc4:	bne.n	5c48 <FatFile::getName8(char*, unsigned int)+0xe0>
    5bc6:	ldrb	r3, [r0, #0]
    5bc8:	and.w	r3, r3, #31
    5bcc:	cmp	r6, r3
    5bce:	bne.n	5c48 <FatFile::getName8(char*, unsigned int)+0xe0>
    5bd0:	mov	r3, r4
    5bd2:	mov.w	sl, #0
        order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t c = getLfnChar(ldir, i);
    5bd6:	uxtb.w	r2, sl
    5bda:	mov	r1, fp
    5bdc:	mov	r0, r7
    5bde:	bl	5ab6 <FatFile::getLfnChar(DirLfn_t*, unsigned char)>
    5be2:	mov	r4, r0
      if (hs) {
    5be4:	cbz	r3, 5c04 <FatFile::getName8(char*, unsigned int)+0x9c>
        if (!FsUtf::isLowSurrogate(c)) {
    5be6:	add.w	r2, r0, #9216	; 0x2400
    5bea:	uxth	r2, r2
    5bec:	cmp.w	r2, #1024	; 0x400
    5bf0:	bcs.n	5c48 <FatFile::getName8(char*, unsigned int)+0xe0>
   * \param[in] hs high surrogate.
   * \param[in] ls low surrogate.
   * \return code point.
   */
  inline uint32_t u16ToCp(uint16_t hs, uint16_t ls) {
    return 0X10000 + (((hs & 0X3FF) << 10) | (ls & 0X3FF));
    5bf2:	ldr	r0, [pc, #96]	; (5c54 <FatFile::getName8(char*, unsigned int)+0xec>)
    5bf4:	lsls	r3, r3, #10
    5bf6:	ands	r0, r3
    5bf8:	ubfx	r4, r4, #0, #10
    5bfc:	orrs	r4, r0
    5bfe:	add.w	r0, r4, #65536	; 0x10000
    5c02:	b.n	5c1c <FatFile::getName8(char*, unsigned int)+0xb4>
  /** Check for UTF-16 surrogate.
   * \param[in] c UTF-16 unit.
   * \return true if c is a surrogate else false.
   */
  inline bool isSurrogate(uint16_t c) {
    return 0XD800 <= c && c <= 0XDFFF;
    5c04:	add.w	r3, r0, #10240	; 0x2800
    5c08:	uxth	r3, r3
          DBG_FAIL_MACRO;
          goto fail;
        }
        cp = FsUtf::u16ToCp(hs, c);
        hs = 0;
      } else if (!FsUtf::isSurrogate(c)) {
    5c0a:	cmp.w	r3, #2048	; 0x800
    5c0e:	bcc.n	5c14 <FatFile::getName8(char*, unsigned int)+0xac>
        if (c == 0) {
    5c10:	cbnz	r0, 5c1c <FatFile::getName8(char*, unsigned int)+0xb4>
    5c12:	b.n	5c3e <FatFile::getName8(char*, unsigned int)+0xd6>
          goto done;
        }
        cp = c;
      } else if (FsUtf::isHighSurrogate(c)) {
    5c14:	cmp.w	r3, #1024	; 0x400
    5c18:	bcc.n	5c2a <FatFile::getName8(char*, unsigned int)+0xc2>
    5c1a:	b.n	5c48 <FatFile::getName8(char*, unsigned int)+0xe0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    5c1c:	mov	r2, r8
    5c1e:	mov	r1, r5
    5c20:	bl	3480 <FsUtf::cpToMb(unsigned long, char*, char*)>
      if (!ptr) {
    5c24:	cbz	r0, 5c3e <FatFile::getName8(char*, unsigned int)+0xd6>
    5c26:	mov	r5, r0
    5c28:	movs	r4, #0
    5c2a:	add.w	sl, sl, #1
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
        order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t i = 0; i < 13; i++) {
    5c2e:	cmp.w	sl, #13
    5c32:	beq.n	5c38 <FatFile::getName8(char*, unsigned int)+0xd0>
    5c34:	mov	r3, r4
    5c36:	b.n	5bd6 <FatFile::getName8(char*, unsigned int)+0x6e>
  }
  if (!dir.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    5c38:	adds	r6, #1
    5c3a:	uxtb	r6, r6
    5c3c:	b.n	5ba8 <FatFile::getName8(char*, unsigned int)+0x40>
      }
      str = ptr;
    }
  }
 done:
  *str = '\0';
    5c3e:	movs	r3, #0
    5c40:	strb	r3, [r5, #0]
  return str - name;
    5c42:	rsb	r0, r9, r5
    5c46:	b.n	5c4e <FatFile::getName8(char*, unsigned int)+0xe6>

 fail:
  *name = 0;
    5c48:	movs	r0, #0
    5c4a:	strb.w	r0, [r9]
  return 0;
}
    5c4e:	add	sp, #44	; 0x2c
    5c50:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5c54:	.word	0x000ffc00

00005c58 <FatFile::getName(char*, unsigned int)>:
//------------------------------------------------------------------------------
size_t FatFile::getName(char* name, size_t size) {
#if !USE_LONG_FILE_NAMES
  return getSFN(name, size);
#elif USE_UTF8_LONG_NAMES
  return getName8(name, size);
    5c58:	b.w	5b68 <FatFile::getName8(char*, unsigned int)>

00005c5c <FatPartition::cacheSync()>:
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    5c5c:	push	{r4, lr}
    5c5e:	mov	r4, r0
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    5c60:	adds	r0, #40	; 0x28
    5c62:	bl	37d6 <FsCache::sync()>
    5c66:	cbz	r0, 5c7e <FatPartition::cacheSync()+0x22>
    5c68:	add.w	r0, r4, #568	; 0x238
    5c6c:	bl	37d6 <FsCache::sync()>
    5c70:	cbz	r0, 5c7e <FatPartition::cacheSync()+0x22>
    5c72:	ldr	r0, [r4, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    5c74:	ldr	r3, [r0, #0]
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
  }
    5c76:	ldmia.w	sp!, {r4, lr}
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    5c7a:	ldr	r3, [r3, #28]
    5c7c:	bx	r3
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
  }
    5c7e:	movs	r0, #0
    5c80:	pop	{r4, pc}

00005c82 <FatFile::addCluster()>:
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    5c82:	mov	r2, r0
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    5c84:	push	{r3, r4, r5, lr}
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    5c86:	ldr.w	r5, [r2, #16]!
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    5c8a:	mov	r4, r0
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
  if (!m_vol->allocateCluster(m_curCluster, &m_curCluster)) {
    5c8c:	mov	r1, r5
    5c8e:	ldr	r0, [r0, #8]
    5c90:	bl	6afa <FatPartition::allocateCluster(unsigned long, unsigned long*)>
    5c94:	cbz	r0, 5cb6 <FatFile::addCluster()+0x34>
    5c96:	ldrb	r3, [r4, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (cc == 0) {
    5c98:	cbnz	r5, 5ca0 <FatFile::addCluster()+0x1e>
    m_flags |= FILE_FLAG_CONTIGUOUS;
    5c9a:	orr.w	r3, r3, #64	; 0x40
    5c9e:	b.n	5cac <FatFile::addCluster()+0x2a>
  } else if (m_curCluster != (cc + 1)) {
    5ca0:	ldr	r2, [r4, #16]
    5ca2:	adds	r5, #1
    5ca4:	cmp	r2, r5
    5ca6:	beq.n	5cae <FatFile::addCluster()+0x2c>
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    5ca8:	bic.w	r3, r3, #64	; 0x40
    5cac:	strb	r3, [r4, #2]
  }
  m_flags |= FILE_FLAG_DIR_DIRTY;
    5cae:	ldrb	r3, [r4, #2]
    5cb0:	orn	r3, r3, #127	; 0x7f
    5cb4:	strb	r3, [r4, #2]
  return false;
#else  // USE_FAT_FILE_FLAG_CONTIGUOUS
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
    5cb6:	pop	{r3, r4, r5, pc}

00005cb8 <FatFile::addDirCluster()>:
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first sector of cluster in the cache.
bool FatFile::addDirCluster() {
    5cb8:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    5cbc:	ldrb	r3, [r0, #0]
    5cbe:	and.w	r3, r3, #32
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first sector of cluster in the cache.
bool FatFile::addDirCluster() {
    5cc2:	mov	r4, r0
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    5cc4:	and.w	r5, r3, #255	; 0xff
    5cc8:	cbz	r3, 5cce <FatFile::addDirCluster()+0x16>
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
  return true;

 fail:
  return false;
    5cca:	movs	r6, #0
    5ccc:	b.n	5d38 <FatFile::addDirCluster()+0x80>
  if (isRootFixed()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // max folder size
  if (m_curPosition >= 512UL*4095) {
    5cce:	ldr	r2, [r0, #20]
    5cd0:	ldr	r3, [pc, #108]	; (5d40 <FatFile::addDirCluster()+0x88>)
    5cd2:	cmp	r2, r3
    5cd4:	bhi.n	5cca <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    5cd6:	bl	5c82 <FatFile::addCluster()>
    5cda:	mov	r6, r0
    5cdc:	cmp	r0, #0
    5cde:	beq.n	5cca <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_vol->clusterStartSector(m_curCluster);
    5ce0:	ldr	r0, [r4, #8]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    5ce2:	ldr	r1, [r4, #16]
    5ce4:	ldrb	r3, [r0, #6]
    5ce6:	ldr	r7, [r0, #20]
    5ce8:	subs	r1, #2
    5cea:	lsls	r1, r3
    5cec:	add	r7, r1
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    5cee:	movs	r2, #5
    5cf0:	mov	r1, r7
    5cf2:	adds	r0, #40	; 0x28
    5cf4:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_RESERVE_FOR_WRITE);
  if (!pc) {
    5cf8:	mov	r8, r0
    5cfa:	cmp	r0, #0
    5cfc:	beq.n	5cca <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
    5cfe:	mov	r1, r5
    5d00:	mov.w	r2, #512	; 0x200
    5d04:	bl	9078 <memset>
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    5d08:	movs	r5, #1
    5d0a:	ldr	r3, [r4, #8]
    5d0c:	ldrb	r2, [r3, #4]
    5d0e:	cmp	r2, r5
    5d10:	bls.n	5d28 <FatFile::addDirCluster()+0x70>
    5d12:	ldr	r0, [r3, #0]
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    5d14:	ldr	r3, [r0, #0]
    5d16:	mov	r2, r8
    5d18:	ldr	r3, [r3, #32]
    5d1a:	adds	r1, r5, r7
    5d1c:	blx	r3
    if (!m_vol->writeSector(sector + i, pc->data)) {
    5d1e:	cmp	r0, #0
    5d20:	beq.n	5cca <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    5d22:	adds	r5, #1
    5d24:	uxtb	r5, r5
    5d26:	b.n	5d0a <FatFile::addDirCluster()+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
    5d28:	ldrb	r2, [r3, #6]
    5d2a:	mov.w	r3, #512	; 0x200
    5d2e:	lsls	r3, r2
    5d30:	ldr	r2, [r4, #20]
    5d32:	uxtah	r3, r2, r3
    5d36:	str	r3, [r4, #20]
  return true;

 fail:
  return false;
}
    5d38:	mov	r0, r6
    5d3a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5d3e:	nop
    5d40:	.word	0x001ffdff

00005d44 <FatFile::cacheDirEntry(unsigned char)>:
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
DirFat_t* FatFile::cacheDirEntry(uint8_t action) {
    5d44:	push	{r4, lr}
    5d46:	mov	r4, r0
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    5d48:	ldr	r0, [r0, #8]
    5d4a:	mov	r2, r1
    5d4c:	adds	r0, #40	; 0x28
    5d4e:	ldr	r1, [r4, #24]
    5d50:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
  cache_t* pc;
  pc = m_vol->cacheFetchData(m_dirSector, action);
  if (!pc) {
    5d54:	cbz	r0, 5d60 <FatFile::cacheDirEntry(unsigned char)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return pc->dir + (m_dirIndex & 0XF);
    5d56:	ldrh	r3, [r4, #4]
    5d58:	and.w	r3, r3, #15
    5d5c:	add.w	r0, r0, r3, lsl #5

 fail:
  return nullptr;
}
    5d60:	pop	{r4, pc}

00005d62 <FatFile::openRoot(FatVolume*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    5d62:	push	{r4, r5, r6, lr}
  // error if file is already open
  if (isOpen()) {
    5d64:	ldrb	r4, [r0, #0]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    5d66:	mov	r5, r0
    5d68:	mov	r6, r1
  // error if file is already open
  if (isOpen()) {
    5d6a:	cbnz	r4, 5d8e <FatFile::openRoot(FatVolume*)+0x2c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(FatFile));
    5d6c:	movs	r2, #36	; 0x24
    5d6e:	mov	r1, r4
    5d70:	bl	9078 <memset>

  m_vol = vol;
    5d74:	str	r6, [r5, #8]
  switch (vol->fatType()) {
    5d76:	ldrb	r3, [r6, #7]
    5d78:	cmp	r3, #16
    5d7a:	beq.n	5d84 <FatFile::openRoot(FatVolume*)+0x22>
    5d7c:	cmp	r3, #32
    5d7e:	bne.n	5d8e <FatFile::openRoot(FatVolume*)+0x2c>
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    5d80:	movs	r3, #64	; 0x40
    5d82:	b.n	5d86 <FatFile::openRoot(FatVolume*)+0x24>
  switch (vol->fatType()) {
#if FAT12_SUPPORT
  case 12:
#endif  // FAT12_SUPPORT
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    5d84:	movs	r3, #32
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    5d86:	movs	r0, #1
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    5d88:	strb	r3, [r5, #0]
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    5d8a:	strb	r0, [r5, #2]
    5d8c:	pop	{r4, r5, r6, pc}
  return true;

 fail:
  return false;
    5d8e:	movs	r0, #0
    5d90:	pop	{r4, r5, r6, pc}

00005d92 <FatFile::openCluster(FatFile*)>:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    5d92:	push	{r3, r4, r5, lr}
  if (file->m_dirCluster == 0) {
    5d94:	ldr	r3, [r1, #12]
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    5d96:	mov	r4, r0
    5d98:	mov	r5, r1
  if (file->m_dirCluster == 0) {
    5d9a:	cbnz	r3, 5da6 <FatFile::openCluster(FatFile*)+0x14>
    return openRoot(file->m_vol);
    5d9c:	ldr	r1, [r1, #8]
  m_attributes = FILE_ATTR_SUBDIR;
  m_flags = FILE_FLAG_READ;
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
    5d9e:	ldmia.w	sp!, {r3, r4, r5, lr}
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
    5da2:	b.w	5d62 <FatFile::openRoot(FatVolume*)>
  }
  memset(this, 0, sizeof(FatFile));
    5da6:	movs	r2, #36	; 0x24
    5da8:	movs	r1, #0
    5daa:	bl	9078 <memset>
  m_attributes = FILE_ATTR_SUBDIR;
    5dae:	movs	r3, #16
  m_flags = FILE_FLAG_READ;
    5db0:	movs	r0, #1
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
  m_attributes = FILE_ATTR_SUBDIR;
    5db2:	strb	r3, [r4, #0]
  m_flags = FILE_FLAG_READ;
    5db4:	strb	r0, [r4, #2]
  m_vol = file->m_vol;
    5db6:	ldr	r3, [r5, #8]
    5db8:	str	r3, [r4, #8]
  m_firstCluster = file->m_dirCluster;
    5dba:	ldr	r3, [r5, #12]
    5dbc:	str	r3, [r4, #32]
  return true;
}
    5dbe:	pop	{r3, r4, r5, pc}

00005dc0 <FatFile::read(void*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    5dc0:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    5dc4:	ldrb	r3, [r0, #2]
    5dc6:	lsls	r5, r3, #31

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    5dc8:	mov	r4, r0
    5dca:	mov	r9, r1
    5dcc:	mov	r6, r2
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    5dce:	bpl.n	5ec0 <FatFile::read(void*, unsigned int)+0x100>
    5dd0:	ldrb	r3, [r0, #0]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
    5dd2:	lsls	r0, r3, #28
    5dd4:	bpl.n	5dde <FatFile::read(void*, unsigned int)+0x1e>
    uint32_t tmp32 = m_fileSize - m_curPosition;
    5dd6:	ldr	r3, [r4, #28]
    5dd8:	ldr	r2, [r4, #20]
    5dda:	subs	r3, r3, r2
    5ddc:	b.n	5dee <FatFile::read(void*, unsigned int)+0x2e>
    if (nbyte >= tmp32) {
      nbyte = tmp32;
    }
  } else if (isRootFixed()) {
    5dde:	lsls	r1, r3, #26
    5de0:	bpl.n	5df4 <FatFile::read(void*, unsigned int)+0x34>
    uint16_t tmp16 = 32*m_vol->m_rootDirEntryCount - (uint16_t)m_curPosition;
    5de2:	ldr	r3, [r4, #8]
    if (nbyte > tmp16) {
    5de4:	ldrh	r2, [r3, #8]
    5de6:	ldr	r3, [r4, #20]
    5de8:	rsb	r3, r3, r2, lsl #5
    5dec:	uxth	r3, r3
    5dee:	cmp	r6, r3
    5df0:	it	cs
    5df2:	movcs	r6, r3
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
    5df4:	mov	r7, r6
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
  int8_t fg;
  uint8_t sectorOfCluster = 0;
    5df6:	mov.w	r8, #0
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    5dfa:	add.w	sl, r4, #16
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    5dfe:	cmp	r7, #0
    5e00:	beq.n	5e86 <FatFile::read(void*, unsigned int)+0xc6>
    5e02:	ldrb	r3, [r4, #0]
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    5e04:	ldr	r2, [r4, #20]
    5e06:	ldr	r0, [r4, #8]
    if (isRootFixed()) {
    5e08:	tst.w	r3, #32
    }
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    5e0c:	ubfx	r5, r2, #0, #9
    5e10:	mov.w	r1, r2, lsr #9
    if (isRootFixed()) {
    5e14:	beq.n	5e1c <FatFile::read(void*, unsigned int)+0x5c>
      sector = m_vol->rootDirStart()
               + (m_curPosition >> m_vol->bytesPerSectorShift());
    5e16:	ldr	r3, [r0, #32]
    5e18:	add	r1, r3
    5e1a:	b.n	5e66 <FatFile::read(void*, unsigned int)+0xa6>
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    5e1c:	ldrb.w	r8, [r0, #5]
    5e20:	and.w	r8, r1, r8
    } else {
      sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
      if (offset == 0 && sectorOfCluster == 0) {
    5e24:	cbnz	r5, 5e56 <FatFile::read(void*, unsigned int)+0x96>
    5e26:	cmp.w	r8, #0
    5e2a:	bne.n	5e56 <FatFile::read(void*, unsigned int)+0x96>
        // start of new cluster
        if (m_curPosition == 0) {
    5e2c:	cbnz	r2, 5e38 <FatFile::read(void*, unsigned int)+0x78>
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    5e2e:	lsls	r2, r3, #25
    5e30:	ite	mi
    5e32:	ldrmi	r3, [r0, #32]
    5e34:	ldrpl	r3, [r4, #32]
    5e36:	b.n	5ece <FatFile::read(void*, unsigned int)+0x10e>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
    5e38:	lsls	r3, r3, #28
    5e3a:	bpl.n	5e48 <FatFile::read(void*, unsigned int)+0x88>
    5e3c:	ldrb	r3, [r4, #2]
    5e3e:	lsls	r1, r3, #25
    5e40:	bpl.n	5e48 <FatFile::read(void*, unsigned int)+0x88>
          m_curCluster++;
    5e42:	ldr	r3, [r4, #16]
    5e44:	adds	r3, #1
    5e46:	b.n	5ece <FatFile::read(void*, unsigned int)+0x10e>
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    5e48:	mov	r2, sl
    5e4a:	ldr	r1, [r4, #16]
    5e4c:	bl	6a34 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    5e50:	cmp	r0, #0
    5e52:	blt.n	5ec0 <FatFile::read(void*, unsigned int)+0x100>
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
    5e54:	beq.n	5e7e <FatFile::read(void*, unsigned int)+0xbe>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    5e56:	ldr	r3, [r4, #8]
    5e58:	ldr	r1, [r4, #16]
    5e5a:	ldrb	r2, [r3, #6]
    5e5c:	ldr	r3, [r3, #20]
    5e5e:	subs	r1, #2
    5e60:	lsls	r1, r2
    5e62:	add	r1, r3
    5e64:	add	r1, r8
    5e66:	ldr.w	fp, [r4, #8]
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
    5e6a:	cmp	r5, #0
    5e6c:	bne.n	5f0e <FatFile::read(void*, unsigned int)+0x14e>
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
    5e6e:	cmp.w	r7, #512	; 0x200
    5e72:	bcc.n	5f0e <FatFile::read(void*, unsigned int)+0x14e>
    5e74:	ldr.w	r3, [fp, #52]	; 0x34
        || sector == m_vol->cacheSectorNumber()) {
    5e78:	cmp	r1, r3
    5e7a:	bne.n	5e8a <FatFile::read(void*, unsigned int)+0xca>
    5e7c:	b.n	5f0e <FatFile::read(void*, unsigned int)+0x14e>
          if (fg < 0) {
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
            if (isDir()) {
    5e7e:	ldrb	r3, [r4, #0]
    5e80:	tst.w	r3, #112	; 0x70
    5e84:	beq.n	5ec0 <FatFile::read(void*, unsigned int)+0x100>
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return nbyte - toRead;
    5e86:	subs	r0, r6, r7
    5e88:	b.n	5f32 <FatFile::read(void*, unsigned int)+0x172>
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    5e8a:	cmp.w	r7, #1024	; 0x400
    5e8e:	bcc.n	5eec <FatFile::read(void*, unsigned int)+0x12c>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      if (!isRootFixed()) {
    5e90:	ldrb	r2, [r4, #0]
    5e92:	lsls	r2, r2, #26
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    5e94:	mov.w	r5, r7, lsr #9
      if (!isRootFixed()) {
    5e98:	bmi.n	5ea8 <FatFile::read(void*, unsigned int)+0xe8>
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
    5e9a:	ldrb.w	r2, [fp, #4]
    5e9e:	rsb	r2, r8, r2
    5ea2:	cmp	r5, r2
    5ea4:	it	cs
    5ea6:	movcs	r5, r2
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    5ea8:	cmp	r1, r3
    5eaa:	bhi.n	5ed2 <FatFile::read(void*, unsigned int)+0x112>
    5eac:	adds	r2, r1, r5
    5eae:	cmp	r3, r2
    5eb0:	bcs.n	5ed2 <FatFile::read(void*, unsigned int)+0x112>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    5eb2:	add.w	r0, fp, #40	; 0x28
    5eb6:	str	r1, [sp, #4]
    5eb8:	bl	37d6 <FsCache::sync()>
    5ebc:	ldr	r1, [sp, #4]
    5ebe:	cbnz	r0, 5ed2 <FatFile::read(void*, unsigned int)+0x112>
    toRead -= n;
  }
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
    5ec0:	ldrb	r3, [r4, #1]
    5ec2:	orr.w	r3, r3, #2
    5ec6:	strb	r3, [r4, #1]
  return -1;
    5ec8:	mov.w	r0, #4294967295
    5ecc:	b.n	5f32 <FatFile::read(void*, unsigned int)+0x172>
        if (m_curPosition == 0) {
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
    5ece:	str	r3, [r4, #16]
    5ed0:	b.n	5e56 <FatFile::read(void*, unsigned int)+0x96>
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    5ed2:	ldr.w	r0, [fp, #44]	; 0x2c
    5ed6:	ldr	r3, [r0, #0]
    5ed8:	mov	r2, r9
    5eda:	ldr.w	fp, [r3, #16]
    5ede:	mov	r3, r5
    5ee0:	blx	fp
        if (mb < ns) {
          ns = mb;
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    5ee2:	cmp	r0, #0
    5ee4:	beq.n	5ec0 <FatFile::read(void*, unsigned int)+0x100>
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
        if (mb < ns) {
          ns = mb;
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
    5ee6:	mov.w	fp, r5, lsl #9
    5eea:	b.n	5f00 <FatFile::read(void*, unsigned int)+0x140>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    5eec:	ldr.w	r0, [fp, #44]	; 0x2c
    5ef0:	ldr	r3, [r0, #0]
    5ef2:	mov	r2, r9
    5ef4:	ldr	r3, [r3, #12]
    5ef6:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    5ef8:	cmp	r0, #0
    5efa:	beq.n	5ec0 <FatFile::read(void*, unsigned int)+0x100>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    5efc:	mov.w	fp, #512	; 0x200
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    5f00:	ldr	r3, [r4, #20]
    5f02:	add	r3, fp
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    5f04:	add	r9, fp
    m_curPosition += n;
    5f06:	str	r3, [r4, #20]
    toRead -= n;
    5f08:	rsb	r7, fp, r7
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    5f0c:	b.n	5dfe <FatFile::read(void*, unsigned int)+0x3e>
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    5f0e:	movs	r2, #0
    5f10:	add.w	r0, fp, #40	; 0x28
    5f14:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
      if (!pc) {
    5f18:	cmp	r0, #0
    5f1a:	beq.n	5ec0 <FatFile::read(void*, unsigned int)+0x100>
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
      // amount to be read from current sector
      n = m_vol->bytesPerSector() - offset;
    5f1c:	rsb	fp, r5, #512	; 0x200
    5f20:	cmp	fp, r7
    5f22:	it	cs
    5f24:	movcs	fp, r7
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
    5f26:	adds	r1, r0, r5
    5f28:	mov	r2, fp
    5f2a:	mov	r0, r9
    5f2c:	bl	8ed0 <memcpy>
    5f30:	b.n	5f00 <FatFile::read(void*, unsigned int)+0x140>
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
  return -1;
}
    5f32:	add	sp, #12
    5f34:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00005f38 <FatFile::peek()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::peek() {
    5f38:	push	{r0, r1, r4, r5, r6, lr}
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    5f3a:	movs	r2, #1
    5f3c:	add.w	r1, sp, #7
    5f40:	mov	r4, r0
  uint32_t curPosition = m_curPosition;
    5f42:	ldr	r6, [r0, #20]
  uint32_t curCluster = m_curCluster;
    5f44:	ldr	r5, [r0, #16]
    5f46:	bl	5dc0 <FatFile::read(void*, unsigned int)>
    5f4a:	cmp	r0, #1
    5f4c:	it	eq
    5f4e:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
    5f52:	str	r6, [r4, #20]
    5f54:	it	ne
    5f56:	movne.w	r0, #4294967295
  m_curCluster = curCluster;
    5f5a:	str	r5, [r4, #16]
  return c;
}
    5f5c:	add	sp, #8
    5f5e:	pop	{r4, r5, r6, pc}

00005f60 <FatFile::readDirCache(bool)>:
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;
    5f60:	ldr	r3, [r0, #20]
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    5f62:	push	{r0, r1, r2, r4, r5, lr}
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;
    5f64:	ubfx	r5, r3, #5, #4
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    5f68:	mov	r4, r0
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;

  if (i == 0 || !skipReadOk) {
    5f6a:	cbz	r5, 5f6e <FatFile::readDirCache(bool)+0xe>
    5f6c:	cbnz	r1, 5f8a <FatFile::readDirCache(bool)+0x2a>
    int8_t n = read(&n, 1);
    5f6e:	movs	r2, #1
    5f70:	add.w	r1, sp, #7
    5f74:	mov	r0, r4
    5f76:	bl	5dc0 <FatFile::read(void*, unsigned int)>
    5f7a:	sxtb	r0, r0
    if  (n != 1) {
    5f7c:	cmp	r0, #1
    5f7e:	beq.n	5f84 <FatFile::readDirCache(bool)+0x24>
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;

 fail:
  return nullptr;
    5f80:	movs	r0, #0
    5f82:	b.n	5f96 <FatFile::readDirCache(bool)+0x36>
      if (n != 0) {
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    m_curPosition += 31;
    5f84:	ldr	r3, [r4, #20]
    5f86:	adds	r3, #31
    5f88:	b.n	5f8c <FatFile::readDirCache(bool)+0x2c>
  } else {
    m_curPosition += 32;
    5f8a:	adds	r3, #32
  static const uint8_t CACHE_RESERVE_FOR_WRITE =
    CACHE_STATUS_DIRTY | CACHE_OPTION_NO_READ;
  //----------------------------------------------------------------------------
  /** \return Cache buffer address. */
  uint8_t* cacheBuffer() {
    return m_buffer;
    5f8c:	ldr	r0, [r4, #8]
    5f8e:	str	r3, [r4, #20]
    5f90:	adds	r0, #56	; 0x38
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;
    5f92:	add.w	r0, r0, r5, lsl #5

 fail:
  return nullptr;
}
    5f96:	add	sp, #12
    5f98:	pop	{r4, r5, pc}

00005f9a <FatFile::seekSet(unsigned long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    5f9a:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5f9e:	mov	r4, r0
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    5fa0:	ldr	r7, [r0, #16]
    5fa2:	ldrb	r0, [r0, #0]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    5fa4:	mov	r6, r1
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    5fa6:	cmp	r0, #0
    5fa8:	beq.n	6038 <FatFile::seekSet(unsigned long)+0x9e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    5faa:	ldr	r5, [r4, #20]
    5fac:	cmp	r5, r1
    5fae:	beq.n	6040 <FatFile::seekSet(unsigned long)+0xa6>
    return true;
  }
  if (pos == 0) {
    5fb0:	cbnz	r1, 5fb6 <FatFile::seekSet(unsigned long)+0x1c>
    // set position to start of file
    m_curCluster = 0;
    5fb2:	str	r1, [r4, #16]
    goto done;
    5fb4:	b.n	602c <FatFile::seekSet(unsigned long)+0x92>
  }
  if (isFile()) {
    5fb6:	lsls	r2, r0, #28
    5fb8:	bpl.n	5fc2 <FatFile::seekSet(unsigned long)+0x28>
    if (pos > m_fileSize) {
    5fba:	ldr	r3, [r4, #28]
    5fbc:	cmp	r1, r3
    5fbe:	bhi.n	6038 <FatFile::seekSet(unsigned long)+0x9e>
    5fc0:	b.n	5fd2 <FatFile::seekSet(unsigned long)+0x38>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (isRootFixed()) {
    5fc2:	lsls	r3, r0, #26
    5fc4:	bpl.n	5fd2 <FatFile::seekSet(unsigned long)+0x38>
    5fc6:	ldr	r3, [r4, #8]
    if (pos <= 32*m_vol->rootDirEntryCount()) {
    5fc8:	ldrh	r3, [r3, #8]
    5fca:	cmp.w	r1, r3, lsl #5
    5fce:	bhi.n	6038 <FatFile::seekSet(unsigned long)+0x9e>
    5fd0:	b.n	602c <FatFile::seekSet(unsigned long)+0x92>
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    5fd2:	ldr.w	lr, [r4, #8]
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    5fd6:	ldrb	r1, [r4, #2]
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    5fd8:	ldrb.w	r2, [lr, #6]
    5fdc:	adds	r2, #9
    5fde:	uxtb	r2, r2
    5fe0:	subs	r3, r6, #1
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    5fe2:	lsls	r1, r1, #25
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    5fe4:	lsr.w	r3, r3, r2
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    5fe8:	bpl.n	5ff2 <FatFile::seekSet(unsigned long)+0x58>
    m_curCluster = m_firstCluster + nNew;
    5fea:	ldr	r2, [r4, #32]
    5fec:	add	r3, r2
    5fee:	str	r3, [r4, #16]
    goto done;
    5ff0:	b.n	602c <FatFile::seekSet(unsigned long)+0x92>
  }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> (m_vol->bytesPerClusterShift());
    5ff2:	subs	r1, r5, #1
    5ff4:	lsr.w	r2, r1, r2

  if (nNew < nCur || m_curPosition == 0) {
    5ff8:	cmp	r3, r2
    5ffa:	bcc.n	5ffe <FatFile::seekSet(unsigned long)+0x64>
    5ffc:	cbnz	r5, 6012 <FatFile::seekSet(unsigned long)+0x78>
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    5ffe:	lsls	r2, r0, #25
    6000:	ite	mi
    6002:	ldrmi.w	r2, [lr, #32]
    6006:	ldrpl	r2, [r4, #32]
    6008:	str	r2, [r4, #16]
    600a:	mov	r5, r3
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    600c:	add.w	r8, r4, #16
    6010:	b.n	6028 <FatFile::seekSet(unsigned long)+0x8e>
  if (nNew < nCur || m_curPosition == 0) {
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    6012:	subs	r3, r3, r2
    6014:	b.n	600a <FatFile::seekSet(unsigned long)+0x70>
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    6016:	mov	r2, r8
    6018:	ldr	r1, [r4, #16]
    601a:	ldr	r0, [r4, #8]
    601c:	bl	6a34 <FatPartition::fatGet(unsigned long, unsigned long*)>
    6020:	cmp	r0, #0
    6022:	add.w	r5, r5, #4294967295
    6026:	ble.n	6038 <FatFile::seekSet(unsigned long)+0x9e>
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    6028:	cmp	r5, #0
    602a:	bne.n	6016 <FatFile::seekSet(unsigned long)+0x7c>
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    602c:	ldrb	r3, [r4, #2]
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    602e:	str	r6, [r4, #20]
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    6030:	bic.w	r3, r3, #32
    6034:	strb	r3, [r4, #2]
    6036:	b.n	6040 <FatFile::seekSet(unsigned long)+0xa6>
  return true;

 fail:
  m_curCluster = tmp;
    6038:	str	r7, [r4, #16]
  return false;
    603a:	movs	r0, #0
    603c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    6040:	movs	r0, #1
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    6042:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00006046 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>:
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    6046:	push	{r3, r4, r5, r6, r7, lr}
    6048:	mov	r7, r1
    604a:	mov	r6, r2
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    604c:	movs	r1, #0
    604e:	movs	r2, #36	; 0x24
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    6050:	mov	r4, r0
    6052:	mov	r5, r3
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    6054:	bl	9078 <memset>
  // location of entry in cache
  m_vol = dirFile->m_vol;
    6058:	ldr	r0, [r7, #8]
  m_dirIndex = dirIndex;
    605a:	strh	r6, [r4, #4]
    605c:	add.w	r2, r0, #56	; 0x38
  m_dirCluster = dirFile->m_firstCluster;
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;
    6060:	and.w	r6, r6, #15
    6064:	add.w	r2, r2, r6, lsl #5
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    6068:	ldr	r3, [r7, #32]
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
    606a:	str	r0, [r4, #8]
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    606c:	str	r3, [r4, #12]
    606e:	ldrb	r1, [r2, #11]
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;

  // Must be file or subdirectory.
  if (!isFileOrSubdir(dir)) {
    6070:	lsls	r6, r1, #28
    6072:	bmi.n	60f2 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
    6074:	and.w	r1, r1, #23
    6078:	strb	r1, [r4, #0]
  if (isFileDir(dir)) {
    607a:	ldrb	r3, [r2, #11]
    607c:	tst.w	r3, #24
    m_attributes |= FILE_ATTR_FILE;
  }
  m_lfnOrd = lfnOrd;
    6080:	ldrb.w	r3, [sp, #24]
    6084:	strb	r3, [r4, #3]
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    m_attributes |= FILE_ATTR_FILE;
    6086:	it	eq
    6088:	orreq.w	r1, r1, #8
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    608c:	and.w	r3, r5, #3
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    m_attributes |= FILE_ATTR_FILE;
    6090:	it	eq
    6092:	strbeq	r1, [r4, #0]
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    6094:	cmp	r3, #1
    6096:	beq.n	60aa <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x64>
    6098:	cmp	r3, #2
    609a:	beq.n	60a6 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x60>
    609c:	cbnz	r3, 60f2 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    case O_RDONLY:
      if (oflag & O_TRUNC) {
    609e:	lsls	r3, r5, #21
    60a0:	bmi.n	60f2 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
        DBG_FAIL_MACRO;
        goto fail;
      }
      m_flags = FILE_FLAG_READ;
    60a2:	movs	r3, #1
    60a4:	b.n	60ac <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
      break;

    case O_RDWR:
      m_flags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    60a6:	movs	r3, #3
    60a8:	b.n	60ac <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
      break;

    case O_WRONLY:
      m_flags = FILE_FLAG_WRITE;
    60aa:	movs	r3, #2
    60ac:	strb	r3, [r4, #2]
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }

  if (m_flags & FILE_FLAG_WRITE) {
    60ae:	ldrb	r3, [r4, #2]
    60b0:	lsls	r7, r3, #30
    60b2:	bpl.n	60bc <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x76>
    if (isSubDir() || isReadOnly()) {
    60b4:	ldrb	r1, [r4, #0]
    60b6:	tst.w	r1, #17
    60ba:	bne.n	60f2 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_flags |= (oflag & O_APPEND ? FILE_FLAG_APPEND : 0);
    60bc:	and.w	r1, r5, #8
    60c0:	orrs	r3, r1
    60c2:	strb	r3, [r4, #2]
    60c4:	ldr	r3, [r0, #52]	; 0x34

  m_dirSector = m_vol->cacheSectorNumber();
    60c6:	str	r3, [r4, #24]

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    60c8:	ldrh	r1, [r2, #20]
    60ca:	ldrh	r3, [r2, #26]

  if (oflag & O_TRUNC) {
    60cc:	lsls	r6, r5, #21

  m_dirSector = m_vol->cacheSectorNumber();

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    60ce:	orr.w	r1, r3, r1, lsl #16

  if (oflag & O_TRUNC) {
    60d2:	bpl.n	60de <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x98>
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
    60d4:	cbz	r1, 60fa <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xb4>
    60d6:	bl	6b7a <FatPartition::freeChain(unsigned long)>
    60da:	cbnz	r0, 60fa <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xb4>
    60dc:	b.n	60f2 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else {
    m_firstCluster = firstCluster;
    60de:	str	r1, [r4, #32]
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    60e0:	ldr	r3, [r2, #28]
    m_fileSize = getLe32(dir->fileSize);
    60e2:	str	r3, [r4, #28]
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    60e4:	lsls	r3, r5, #17
    60e6:	bpl.n	6104 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xbe>
    60e8:	ldr	r1, [r4, #28]
    60ea:	mov	r0, r4
    60ec:	bl	5f9a <FatFile::seekSet(unsigned long)>
    60f0:	cbnz	r0, 6104 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xbe>
    goto fail;
  }
  return true;

 fail:
  m_attributes = FILE_ATTR_CLOSED;
    60f2:	movs	r0, #0
    60f4:	strb	r0, [r4, #0]
  m_flags = 0;
    60f6:	strb	r0, [r4, #2]
  return false;
    60f8:	pop	{r3, r4, r5, r6, r7, pc}
      DBG_FAIL_MACRO;
      goto fail;
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    60fa:	ldrb	r3, [r4, #2]
    60fc:	orn	r3, r3, #127	; 0x7f
    6100:	strb	r3, [r4, #2]
    6102:	b.n	60e4 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x9e>
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return true;
    6104:	movs	r0, #1

 fail:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
    6106:	pop	{r3, r4, r5, r6, r7, pc}

00006108 <FatFile::openNext(FatFile*, int)>:
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    6108:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    610c:	ldrb	r3, [r0, #0]
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    610e:	mov	r6, r0
    6110:	mov	r5, r1
    6112:	mov	r9, r2
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    6114:	cbnz	r3, 6186 <FatFile::openNext(FatFile*, int)+0x7e>
    6116:	ldrb	r3, [r1, #0]
    6118:	tst.w	r3, #112	; 0x70
    611c:	beq.n	6186 <FatFile::openNext(FatFile*, int)+0x7e>
    611e:	ldr	r4, [r1, #20]
    6120:	ands.w	r4, r4, #31
    6124:	bne.n	6186 <FatFile::openNext(FatFile*, int)+0x7e>
    6126:	mov	r7, r4
    goto fail;
  }
  while (1) {
    // read entry into cache
    index = dirFile->curPosition()/32;
    DirFat_t* dir = dirFile->readDirCache();
    6128:	movs	r1, #0
    612a:	mov	r0, r5
    612c:	ldr.w	r8, [r5, #20]
    6130:	bl	5f60 <FatFile::readDirCache(bool)>
    if (!dir) {
    6134:	cbz	r0, 6186 <FatFile::openNext(FatFile*, int)+0x7e>
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    // done if last entry
    if (dir->name[0] == FAT_NAME_FREE) {
    6136:	ldrb	r3, [r0, #0]
    6138:	cbz	r3, 6186 <FatFile::openNext(FatFile*, int)+0x7e>
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
    613a:	cmp	r3, #46	; 0x2e
    613c:	bne.n	6142 <FatFile::openNext(FatFile*, int)+0x3a>
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
        lfnOrd = ldir->order & 0X1F;
        checksum = ldir->checksum;
      }
    } else {
      lfnOrd = 0;
    613e:	movs	r4, #0
    6140:	b.n	6128 <FatFile::openNext(FatFile*, int)+0x20>
    // done if last entry
    if (dir->name[0] == FAT_NAME_FREE) {
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
    6142:	cmp	r3, #229	; 0xe5
    6144:	beq.n	613e <FatFile::openNext(FatFile*, int)+0x36>
    6146:	ldrb	r2, [r0, #11]
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
    6148:	and.w	lr, r2, #8
    614c:	and.w	r1, lr, #255	; 0xff
    6150:	cmp.w	lr, #0
    6154:	bne.n	6176 <FatFile::openNext(FatFile*, int)+0x6e>
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
    6156:	cbz	r4, 618a <FatFile::openNext(FatFile*, int)+0x82>
    6158:	subs	r2, r0, #1
    615a:	adds	r0, #10
    615c:	lsls	r3, r1, #7
    615e:	orr.w	r1, r3, r1, lsr #1
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    6162:	ldrb.w	r3, [r2, #1]!
    6166:	uxtab	r1, r3, r1
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    616a:	cmp	r0, r2
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    616c:	uxtb	r1, r1
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    616e:	bne.n	615c <FatFile::openNext(FatFile*, int)+0x54>
    6170:	cmp	r7, r1
    6172:	bne.n	6186 <FatFile::openNext(FatFile*, int)+0x7e>
    6174:	b.n	618a <FatFile::openNext(FatFile*, int)+0x82>
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      return true;
    } else if (isLongName(dir)) {
    6176:	cmp	r2, #15
    6178:	bne.n	613e <FatFile::openNext(FatFile*, int)+0x36>
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
    617a:	lsls	r2, r3, #25
    617c:	bpl.n	6128 <FatFile::openNext(FatFile*, int)+0x20>
        lfnOrd = ldir->order & 0X1F;
    617e:	and.w	r4, r3, #31
        checksum = ldir->checksum;
    6182:	ldrb	r7, [r0, #13]
    6184:	b.n	6128 <FatFile::openNext(FatFile*, int)+0x20>
      lfnOrd = 0;
    }
  }

 fail:
  return false;
    6186:	movs	r0, #0
    6188:	b.n	619a <FatFile::openNext(FatFile*, int)+0x92>
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
    618a:	str	r4, [sp, #0]
    618c:	mov	r3, r9
    618e:	ubfx	r2, r8, #5, #16
    6192:	mov	r1, r5
    6194:	mov	r0, r6
    6196:	bl	6046 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    }
  }

 fail:
  return false;
}
    619a:	add	sp, #12
    619c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

000061a0 <FatFile::rmdir()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
    61a0:	push	{r4, lr}
  // must be open subdirectory
  if (!isSubDir() || (!USE_LONG_FILE_NAMES && isLFN())) {
    61a2:	ldrb	r3, [r0, #0]
    61a4:	lsls	r2, r3, #27

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
    61a6:	mov	r4, r0
  // must be open subdirectory
  if (!isSubDir() || (!USE_LONG_FILE_NAMES && isLFN())) {
    61a8:	bpl.n	61ea <FatFile::rmdir()+0x4a>
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    61aa:	movs	r1, #0
    61ac:	bl	5f9a <FatFile::seekSet(unsigned long)>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    DirFat_t* dir = readDirCache(true);
    61b0:	movs	r1, #1
    61b2:	mov	r0, r4
    61b4:	bl	5f60 <FatFile::readDirCache(bool)>
    if (!dir) {
    61b8:	cbnz	r0, 61c0 <FatFile::rmdir()+0x20>
      // EOF if no error.
      if (!getError()) {
    61ba:	ldrb	r3, [r4, #1]
    61bc:	cbz	r3, 61d4 <FatFile::rmdir()+0x34>
    61be:	b.n	61ea <FatFile::rmdir()+0x4a>
      }
      DBG_FAIL_MACRO;
      goto fail;
    }
    // done if past last used entry
    if (dir->name[0] == FAT_NAME_FREE) {
    61c0:	ldrb	r3, [r0, #0]
    61c2:	cbz	r3, 61d4 <FatFile::rmdir()+0x34>
      break;
    }
    // skip empty slot, '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    61c4:	cmp	r3, #229	; 0xe5
    61c6:	beq.n	61b0 <FatFile::rmdir()+0x10>
    61c8:	cmp	r3, #46	; 0x2e
    61ca:	beq.n	61b0 <FatFile::rmdir()+0x10>
      continue;
    }
    // error not empty
    if (isFileOrSubdir(dir)) {
    61cc:	ldrb	r3, [r0, #11]
    61ce:	lsls	r3, r3, #28
    61d0:	bmi.n	61b0 <FatFile::rmdir()+0x10>
    61d2:	b.n	61ea <FatFile::rmdir()+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    61d4:	movs	r3, #8
    61d6:	strb	r3, [r4, #0]
  m_flags |= FILE_FLAG_WRITE;
    61d8:	ldrb	r3, [r4, #2]
    61da:	orr.w	r3, r3, #2
    61de:	strb	r3, [r4, #2]
  return remove();
    61e0:	mov	r0, r4

 fail:
  return false;
}
    61e2:	ldmia.w	sp!, {r4, lr}
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    61e6:	b.w	739c <FatFile::remove()>

 fail:
  return false;
}
    61ea:	movs	r0, #0
    61ec:	pop	{r4, pc}
    61ee:	Address 0x000061ee is out of bounds.


000061f0 <FatFile::sync()>:
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    61f0:	push	{r0, r1, r2, r4, r5, lr}
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    61f2:	ldrb	r3, [r0, #0]
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    61f4:	mov	r4, r0
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    61f6:	cmp	r3, #0
    61f8:	beq.n	6264 <FatFile::sync()+0x74>
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    61fa:	ldrsb.w	r3, [r0, #2]
    61fe:	cmp	r3, #0
    6200:	bge.n	6258 <FatFile::sync()+0x68>
    DirFat_t* dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6202:	movs	r1, #1
    6204:	bl	5d44 <FatFile::cacheDirEntry(unsigned char)>
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
    6208:	mov	r5, r0
    620a:	cbnz	r0, 6218 <FatFile::sync()+0x28>
    return true;
  }
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
    620c:	ldrb	r3, [r4, #1]
    620e:	orr.w	r3, r3, #1
    6212:	strb	r3, [r4, #1]
  return false;
    6214:	movs	r0, #0
    6216:	b.n	6266 <FatFile::sync()+0x76>
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    DirFat_t* dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
    6218:	ldrb	r3, [r0, #0]
    621a:	cmp	r3, #229	; 0xe5
    621c:	beq.n	620c <FatFile::sync()+0x1c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // do not set filesize for dir files
    if (isFile()) {
    621e:	ldrb	r3, [r4, #0]
    6220:	lsls	r3, r3, #28
      setLe32(dir->fileSize, m_fileSize);
    6222:	itt	mi
    6224:	ldrmi	r3, [r4, #28]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    6226:	strmi	r3, [r0, #28]
    }
    // update first cluster fields
    setLe16(dir->firstClusterLow, m_firstCluster & 0XFFFF);
    6228:	ldr	r3, [r4, #32]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    622a:	strh	r3, [r0, #26]
    622c:	lsrs	r3, r3, #16
    622e:	strh	r3, [r0, #20]
    setLe16(dir->firstClusterHigh, m_firstCluster >> 16);

    // set modify time if user supplied a callback date/time function
    if (FsDateTime::callback) {
    6230:	ldr	r3, [pc, #56]	; (626c <FatFile::sync()+0x7c>)
    6232:	ldr	r3, [r3, #0]
    6234:	cbz	r3, 6250 <FatFile::sync()+0x60>
      FsDateTime::callback(&date, &time, &ms10);
    6236:	add.w	r2, sp, #3
    623a:	add.w	r1, sp, #6
    623e:	add	r0, sp, #4
    6240:	blx	r3
      setLe16(dir->modifyDate, date);
    6242:	ldrh.w	r3, [sp, #4]
    6246:	strh	r3, [r5, #24]
    6248:	strh	r3, [r5, #18]
    624a:	ldrh.w	r3, [sp, #6]
    624e:	strh	r3, [r5, #22]
      setLe16(dir->accessDate, date);
      setLe16(dir->modifyTime, time);
    }
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    6250:	ldrb	r3, [r4, #2]
    6252:	and.w	r3, r3, #127	; 0x7f
    6256:	strb	r3, [r4, #2]
  }
  if (m_vol->cacheSync()) {
    6258:	ldr	r0, [r4, #8]
    625a:	bl	5c5c <FatPartition::cacheSync()>
    625e:	cmp	r0, #0
    6260:	beq.n	620c <FatFile::sync()+0x1c>
    6262:	b.n	6266 <FatFile::sync()+0x76>
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
    6264:	movs	r0, #1
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    6266:	add	sp, #12
    6268:	pop	{r4, r5, pc}
    626a:	nop
    626c:	.word	0x2001ceb4

00006270 <FatFile::close()>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
    6270:	push	{r4, lr}
    6272:	mov	r4, r0
  bool rtn = sync();
    6274:	bl	61f0 <FatFile::sync()>
  m_attributes = FILE_ATTR_CLOSED;
    6278:	movs	r3, #0
    627a:	strb	r3, [r4, #0]
  m_flags = 0;
    627c:	strb	r3, [r4, #2]
  return rtn;
}
    627e:	pop	{r4, pc}

00006280 <FatFile::open(FatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    6280:	push	{r4, r5, r6, r7, lr}
    6282:	sub	sp, #84	; 0x54
    6284:	mov	r7, r3
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    6286:	movs	r3, #0
    6288:	strb.w	r3, [sp, #8]
    628c:	strb.w	r3, [sp, #9]
    6290:	strb.w	r3, [sp, #10]
    6294:	strh.w	r3, [sp, #56]	; 0x38
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    6298:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    629a:	str	r2, [sp, #4]
    629c:	mov	r6, r0
    629e:	mov	r4, r1
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    62a0:	cbz	r3, 62a6 <FatFile::open(FatFile*, char const*, int)+0x26>
    close();
  }
  return open(dirFile, &fname, oflag);

 fail:
  return false;
    62a2:	movs	r0, #0
    62a4:	b.n	6324 <FatFile::open(FatFile*, char const*, int)+0xa4>
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    62a6:	ldrb	r3, [r1, #0]
    62a8:	tst.w	r3, #112	; 0x70
    62ac:	beq.n	62a2 <FatFile::open(FatFile*, char const*, int)+0x22>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    62ae:	ldrb	r3, [r2, #0]
    62b0:	cmp	r3, #47	; 0x2f
    62b2:	bne.n	62da <FatFile::open(FatFile*, char const*, int)+0x5a>
    while (isDirSeparator(*path)) {
    62b4:	ldr	r3, [sp, #4]
    62b6:	ldrb	r2, [r3, #0]
    62b8:	cmp	r2, #47	; 0x2f
    62ba:	bne.n	62c2 <FatFile::open(FatFile*, char const*, int)+0x42>
      path++;
    62bc:	adds	r3, #1
    62be:	str	r3, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    62c0:	b.n	62b4 <FatFile::open(FatFile*, char const*, int)+0x34>
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    62c2:	ldr	r1, [r4, #8]
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
    62c4:	cbnz	r2, 62ce <FatFile::open(FatFile*, char const*, int)+0x4e>
      return openRoot(dirFile->m_vol);
    62c6:	mov	r0, r6
    62c8:	bl	5d62 <FatFile::openRoot(FatVolume*)>
    62cc:	b.n	6324 <FatFile::open(FatFile*, char const*, int)+0xa4>
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    62ce:	add	r0, sp, #8
    62d0:	bl	5d62 <FatFile::openRoot(FatVolume*)>
    62d4:	cmp	r0, #0
    62d6:	beq.n	62a2 <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    62d8:	add	r4, sp, #8
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    62da:	add	r3, sp, #4
    62dc:	add	r2, sp, #44	; 0x2c
    62de:	ldr	r1, [sp, #4]
    62e0:	mov	r0, r6
    62e2:	bl	7304 <FatFile::parsePathName(char const*, FatName_t*, char const**)>
    62e6:	cmp	r0, #0
    62e8:	beq.n	62a2 <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    62ea:	ldr	r3, [sp, #4]
    62ec:	ldrb	r3, [r3, #0]
    62ee:	cbz	r3, 6318 <FatFile::open(FatFile*, char const*, int)+0x98>
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    62f0:	movs	r3, #0
    62f2:	add	r2, sp, #44	; 0x2c
    62f4:	mov	r1, r4
    62f6:	mov	r0, r6
    62f8:	bl	70b4 <FatFile::open(FatFile*, FatName_t*, int)>
    62fc:	cmp	r0, #0
    62fe:	beq.n	62a2 <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_WARN_MACRO;
      goto fail;
    }
    tmpDir = *this;
    6300:	mov	r5, r6
    6302:	ldmia	r5!, {r0, r1, r2, r3}
    6304:	add	r4, sp, #8
    6306:	stmia	r4!, {r0, r1, r2, r3}
    6308:	ldmia	r5!, {r0, r1, r2, r3}
    630a:	stmia	r4!, {r0, r1, r2, r3}
    630c:	ldr	r3, [r5, #0]
    630e:	str	r3, [r4, #0]
    dirFile = &tmpDir;
    close();
    6310:	mov	r0, r6
    6312:	bl	6270 <FatFile::close()>
    6316:	b.n	62d8 <FatFile::open(FatFile*, char const*, int)+0x58>
  }
  return open(dirFile, &fname, oflag);
    6318:	mov	r3, r7
    631a:	add	r2, sp, #44	; 0x2c
    631c:	mov	r1, r4
    631e:	mov	r0, r6
    6320:	bl	70b4 <FatFile::open(FatFile*, FatName_t*, int)>

 fail:
  return false;
}
    6324:	add	sp, #84	; 0x54
    6326:	pop	{r4, r5, r6, r7, pc}

00006328 <FatFile::open(FatVolume*, char const*, int)>:
bool FatFile::open(const char* path, oflag_t oflag) {
  return open(FatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
    6328:	cbz	r1, 6332 <FatFile::open(FatVolume*, char const*, int)+0xa>
    632a:	add.w	r1, r1, #1096	; 0x448
    632e:	b.w	6280 <FatFile::open(FatFile*, char const*, int)>
}
    6332:	mov	r0, r1
    6334:	bx	lr

00006336 <FatFile::dirEntry(DirFat_t*)>:
  close();
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::dirEntry(DirFat_t* dst) {
    6336:	push	{r4, r5, r6, lr}
    6338:	mov	r6, r0
    633a:	mov	r4, r1
  DirFat_t* dir;
  // Make sure fields on device are correct.
  if (!sync()) {
    633c:	bl	61f0 <FatFile::sync()>
    6340:	mov	r5, r0
    6342:	cbnz	r0, 6348 <FatFile::dirEntry(DirFat_t*)+0x12>
  // copy to caller's struct
  memcpy(dst, dir, sizeof(DirFat_t));
  return true;

 fail:
  return false;
    6344:	movs	r5, #0
    6346:	b.n	6366 <FatFile::dirEntry(DirFat_t*)+0x30>
  if (!sync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    6348:	movs	r1, #0
    634a:	mov	r0, r6
    634c:	bl	5d44 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    6350:	cmp	r0, #0
    6352:	beq.n	6344 <FatFile::dirEntry(DirFat_t*)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy to caller's struct
  memcpy(dst, dir, sizeof(DirFat_t));
    6354:	mov	r1, r4
    6356:	add.w	r3, r0, #32
    635a:	ldr.w	r2, [r0], #4
    635e:	str.w	r2, [r1], #4
    6362:	cmp	r0, r3
    6364:	bne.n	635a <FatFile::dirEntry(DirFat_t*)+0x24>
  return true;

 fail:
  return false;
}
    6366:	mov	r0, r5
    6368:	pop	{r4, r5, r6, pc}

0000636a <FatFile::getCreateDateTime(unsigned short*, unsigned short*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    636a:	push	{r4, r5, lr}
    636c:	sub	sp, #36	; 0x24
    636e:	mov	r5, r1
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    6370:	mov	r1, sp

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    6372:	mov	r4, r2
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    6374:	bl	6336 <FatFile::dirEntry(DirFat_t*)>
    6378:	cbz	r0, 6386 <FatFile::getCreateDateTime(unsigned short*, unsigned short*)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(dir.createDate);
    637a:	ldrh.w	r3, [sp, #16]
    637e:	strh	r3, [r5, #0]
  *ptime = getLe16(dir.createTime);
    6380:	ldrh.w	r3, [sp, #14]
    6384:	strh	r3, [r4, #0]
  return true;

 fail:
  return false;
}
    6386:	add	sp, #36	; 0x24
    6388:	pop	{r4, r5, pc}

0000638a <FatFile::getModifyDateTime(unsigned short*, unsigned short*)>:
//------------------------------------------------------------------------------
bool FatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    638a:	push	{r4, r5, lr}
    638c:	sub	sp, #36	; 0x24
    638e:	mov	r5, r1
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    6390:	mov	r1, sp

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    6392:	mov	r4, r2
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    6394:	bl	6336 <FatFile::dirEntry(DirFat_t*)>
    6398:	cbz	r0, 63a6 <FatFile::getModifyDateTime(unsigned short*, unsigned short*)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(dir.modifyDate);
    639a:	ldrh.w	r3, [sp, #24]
    639e:	strh	r3, [r5, #0]
  *ptime = getLe16(dir.modifyTime);
    63a0:	ldrh.w	r3, [sp, #22]
    63a4:	strh	r3, [r4, #0]
  return true;

 fail:
  return false;
}
    63a6:	add	sp, #36	; 0x24
    63a8:	pop	{r4, r5, pc}

000063aa <FatFile::mkdir(FatFile*, FatName_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, FatName_t* fname) {
    63aa:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    63ae:	ldrb	r3, [r1, #0]
    63b0:	tst.w	r3, #112	; 0x70

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, FatName_t* fname) {
    63b4:	sub	sp, #32
    63b6:	mov	r4, r0
    63b8:	mov	r6, r1
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    63ba:	beq.n	63f6 <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    63bc:	movw	r3, #2562	; 0xa02
    63c0:	bl	70b4 <FatFile::open(FatFile*, FatName_t*, int)>
    63c4:	cbz	r0, 63f6 <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    63c6:	movs	r7, #1
  m_attributes = FILE_ATTR_SUBDIR;
    63c8:	movs	r5, #16
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    63ca:	strb	r7, [r4, #2]
  m_attributes = FILE_ATTR_SUBDIR;
    63cc:	strb	r5, [r4, #0]

  // allocate and zero first cluster
  if (!addDirCluster()) {
    63ce:	mov	r0, r4
    63d0:	bl	5cb8 <FatFile::addDirCluster()>
    63d4:	cbz	r0, 63f6 <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    63d6:	ldr	r3, [r4, #16]
    63d8:	str	r3, [r4, #32]
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    63da:	movs	r1, #0
    63dc:	mov	r0, r4
    63de:	bl	5f9a <FatFile::seekSet(unsigned long)>
  // Set to start of dir
  rewind();
  // force entry to device
  if (!sync()) {
    63e2:	mov	r0, r4
    63e4:	bl	61f0 <FatFile::sync()>
    63e8:	cbz	r0, 63f6 <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // cache entry - should already be in cache due to sync() call
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    63ea:	mov	r1, r7
    63ec:	mov	r0, r4
    63ee:	bl	5d44 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    63f2:	mov	r3, r0
    63f4:	cbnz	r0, 63fa <FatFile::mkdir(FatFile*, FatName_t*)+0x50>
  memcpy(&pc->dir[1], &dot, sizeof(dot));
  // write first sector
  return m_vol->cacheSync();

 fail:
  return false;
    63f6:	movs	r0, #0
    63f8:	b.n	649e <FatFile::mkdir(FatFile*, FatName_t*)+0xf4>
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // change directory entry attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;
    63fa:	strb	r5, [r0, #11]

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
    63fc:	mov	r2, r0
    63fe:	mov	r7, sp
    6400:	add.w	ip, r0, #32
    6404:	mov	r5, sp
    6406:	ldr	r0, [r2, #0]
    6408:	ldr	r1, [r2, #4]
    640a:	mov	lr, r7
    640c:	stmia.w	lr!, {r0, r1}
    6410:	adds	r2, #8
    6412:	cmp	r2, ip
    6414:	mov	r7, lr
    6416:	bne.n	6406 <FatFile::mkdir(FatFile*, FatName_t*)+0x5c>
    6418:	ldrh	r7, [r3, #20]
    641a:	ldrh.w	r8, [r3, #26]
  dot.name[0] = '.';
    641e:	movs	r3, #46	; 0x2e
    6420:	strb.w	r3, [sp]
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    6424:	movs	r1, #32
  // change directory entry attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
    6426:	movs	r3, #0
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    6428:	adds	r2, r5, r3
    642a:	adds	r3, #1
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    642c:	cmp	r3, #10
    dot.name[i] = ' ';
    642e:	strb	r1, [r2, #1]
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    6430:	bne.n	6428 <FatFile::mkdir(FatFile*, FatName_t*)+0x7e>
    dot.name[i] = ' ';
  }

  // cache sector for '.'  and '..'
  sector = m_vol->clusterStartSector(m_firstCluster);
    6432:	ldr	r0, [r4, #8]
    6434:	ldr	r1, [r4, #32]
    6436:	ldrb	r3, [r0, #6]
    6438:	subs	r1, #2
    643a:	lsls	r1, r3
    643c:	ldr	r3, [r0, #20]
    643e:	movs	r2, #1
    6440:	add	r1, r3
    6442:	adds	r0, #40	; 0x28
    6444:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
  if (!pc) {
    6448:	mov	r3, r0
    644a:	cmp	r0, #0
    644c:	beq.n	63f6 <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
    644e:	strh.w	r7, [sp, #20]
    6452:	strh.w	r8, [sp, #26]
    6456:	mov	lr, r5
    6458:	mov	r7, r0
    645a:	add.w	ip, sp, #32
    645e:	mov	r2, lr
    6460:	ldmia	r2!, {r0, r1}
    6462:	cmp	r2, ip
    6464:	str	r0, [r7, #0]
    6466:	str	r1, [r7, #4]
    6468:	mov	lr, r2
    646a:	add.w	r7, r7, #8
    646e:	bne.n	645e <FatFile::mkdir(FatFile*, FatName_t*)+0xb4>
  // make entry for '..'
  dot.name[1] = '.';
    6470:	movs	r2, #46	; 0x2e
    6472:	strb.w	r2, [sp, #1]
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
    6476:	ldr	r2, [r6, #32]
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    6478:	strh.w	r2, [sp, #26]
    647c:	lsrs	r1, r2, #16
    647e:	strh.w	r1, [sp, #20]
    6482:	adds	r3, #32
    6484:	add	r6, sp, #32
    6486:	mov	r2, r5
    6488:	ldmia	r2!, {r0, r1}
    648a:	cmp	r2, r6
    648c:	str	r0, [r3, #0]
    648e:	str	r1, [r3, #4]
    6490:	mov	r5, r2
    6492:	add.w	r3, r3, #8
    6496:	bne.n	6486 <FatFile::mkdir(FatFile*, FatName_t*)+0xdc>
  // write first sector
  return m_vol->cacheSync();
    6498:	ldr	r0, [r4, #8]
    649a:	bl	5c5c <FatPartition::cacheSync()>

 fail:
  return false;
}
    649e:	add	sp, #32
    64a0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000064a4 <FatFile::mkdir(FatFile*, char const*, bool)>:
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    64a4:	push	{r4, r5, r6, r7, lr}
    64a6:	sub	sp, #84	; 0x54
    64a8:	mov	r7, r3
    64aa:	movs	r3, #0
    64ac:	strh.w	r3, [sp, #20]
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    64b0:	strb.w	r3, [sp, #44]	; 0x2c
    64b4:	strb.w	r3, [sp, #45]	; 0x2d
    64b8:	strb.w	r3, [sp, #46]	; 0x2e
  FatName_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    64bc:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    64be:	str	r2, [sp, #4]
    64c0:	mov	r6, r0
    64c2:	mov	r4, r1
  FatName_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    64c4:	cmp	r3, #0
    64c6:	bne.n	6548 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    64c8:	ldrb	r3, [r1, #0]
    64ca:	tst.w	r3, #112	; 0x70
    64ce:	beq.n	6548 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    64d0:	ldrb	r3, [r2, #0]
    64d2:	cmp	r3, #47	; 0x2f
    64d4:	bne.n	64f0 <FatFile::mkdir(FatFile*, char const*, bool)+0x4c>
    while (isDirSeparator(*path)) {
    64d6:	ldr	r3, [sp, #4]
    64d8:	ldrb	r2, [r3, #0]
    64da:	cmp	r2, #47	; 0x2f
    64dc:	bne.n	64e4 <FatFile::mkdir(FatFile*, char const*, bool)+0x40>
      path++;
    64de:	adds	r3, #1
    64e0:	str	r3, [sp, #4]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    64e2:	b.n	64d6 <FatFile::mkdir(FatFile*, char const*, bool)+0x32>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    64e4:	ldr	r1, [r4, #8]
    64e6:	add	r0, sp, #44	; 0x2c
    64e8:	bl	5d62 <FatFile::openRoot(FatVolume*)>
    64ec:	cbz	r0, 6548 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    64ee:	add	r4, sp, #44	; 0x2c
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    64f0:	add	r3, sp, #4
    64f2:	add	r2, sp, #8
    64f4:	ldr	r1, [sp, #4]
    64f6:	mov	r0, r6
    64f8:	bl	7304 <FatFile::parsePathName(char const*, FatName_t*, char const**)>
    64fc:	cbz	r0, 6548 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    64fe:	ldr	r3, [sp, #4]
    6500:	ldrb	r3, [r3, #0]
    6502:	cbz	r3, 653c <FatFile::mkdir(FatFile*, char const*, bool)+0x98>
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    6504:	movs	r3, #0
    6506:	add	r2, sp, #8
    6508:	mov	r1, r4
    650a:	mov	r0, r6
    650c:	bl	70b4 <FatFile::open(FatFile*, FatName_t*, int)>
    6510:	cbz	r0, 652a <FatFile::mkdir(FatFile*, char const*, bool)+0x86>
      if (!pFlag || !mkdir(parent, &fname)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    6512:	mov	r5, r6
    6514:	ldmia	r5!, {r0, r1, r2, r3}
    6516:	add	r4, sp, #44	; 0x2c
    6518:	stmia	r4!, {r0, r1, r2, r3}
    651a:	ldmia	r5!, {r0, r1, r2, r3}
    651c:	stmia	r4!, {r0, r1, r2, r3}
    651e:	ldr	r3, [r5, #0]
    6520:	str	r3, [r4, #0]
    parent = &tmpDir;
    close();
    6522:	mov	r0, r6
    6524:	bl	6270 <FatFile::close()>
    6528:	b.n	64ee <FatFile::mkdir(FatFile*, char const*, bool)+0x4a>
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
      if (!pFlag || !mkdir(parent, &fname)) {
    652a:	cbz	r7, 6548 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    652c:	add	r2, sp, #8
    652e:	mov	r1, r4
    6530:	mov	r0, r6
    6532:	bl	63aa <FatFile::mkdir(FatFile*, FatName_t*)>
    6536:	cmp	r0, #0
    6538:	bne.n	6512 <FatFile::mkdir(FatFile*, char const*, bool)+0x6e>
    653a:	b.n	6548 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    653c:	add	r2, sp, #8
    653e:	mov	r1, r4
    6540:	mov	r0, r6
    6542:	bl	63aa <FatFile::mkdir(FatFile*, FatName_t*)>
    6546:	b.n	654a <FatFile::mkdir(FatFile*, char const*, bool)+0xa6>

 fail:
  return false;
    6548:	movs	r0, #0
}
    654a:	add	sp, #84	; 0x54
    654c:	pop	{r4, r5, r6, r7, pc}

0000654e <FatFile::rename(FatFile*, char const*)>:
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    654e:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    6552:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    6554:	sub	sp, #108	; 0x6c
    6556:	movs	r7, #0
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    6558:	tst.w	r3, #24
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    655c:	mov	r4, r0
    655e:	mov	r8, r1
    6560:	mov	r9, r2
    6562:	strb.w	r7, [sp, #32]
    6566:	strb.w	r7, [sp, #33]	; 0x21
    656a:	strb.w	r7, [sp, #34]	; 0x22
    656e:	strb.w	r7, [sp, #68]	; 0x44
    6572:	strb.w	r7, [sp, #69]	; 0x45
    6576:	strb.w	r7, [sp, #70]	; 0x46
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    657a:	bne.n	6580 <FatFile::rename(FatFile*, char const*)+0x32>
    goto fail;
  }
  return m_vol->cacheSync();

 fail:
  return false;
    657c:	movs	r0, #0
    657e:	b.n	66de <FatFile::rename(FatFile*, char const*)+0x190>
  if (!USE_LONG_FILE_NAMES && isLFN()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    6580:	ldr	r2, [r0, #8]
    6582:	ldr	r3, [r1, #8]
    6584:	cmp	r2, r3
    6586:	bne.n	657c <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // sync() and cache directory entry
  sync();
  oldFile = *this;
    6588:	mov	r6, r4
  if (m_vol != dirFile->m_vol) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // sync() and cache directory entry
  sync();
    658a:	bl	61f0 <FatFile::sync()>
  oldFile = *this;
    658e:	ldmia	r6!, {r0, r1, r2, r3}
    6590:	add	r5, sp, #68	; 0x44
    6592:	stmia	r5!, {r0, r1, r2, r3}
    6594:	ldmia	r6!, {r0, r1, r2, r3}
    6596:	stmia	r5!, {r0, r1, r2, r3}
    6598:	ldr	r3, [r6, #0]
    659a:	str	r3, [r5, #0]
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    659c:	mov	r1, r7
    659e:	mov	r0, r4
    65a0:	bl	5d44 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    65a4:	cmp	r0, #0
    65a6:	beq.n	657c <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    65a8:	mov	r3, r0
    65aa:	mov	r2, sp
    65ac:	add.w	r7, r0, #32
    65b0:	mov	r5, sp
    65b2:	ldr	r0, [r3, #0]
    65b4:	ldr	r1, [r3, #4]
    65b6:	mov	r6, r2
    65b8:	stmia	r6!, {r0, r1}
    65ba:	adds	r3, #8
    65bc:	cmp	r3, r7
    65be:	mov	r2, r6
    65c0:	bne.n	65b2 <FatFile::rename(FatFile*, char const*)+0x64>
  // make directory entry for new path
  if (isFile()) {
    65c2:	ldrb	r2, [r4, #0]
    65c4:	and.w	r2, r2, #8
    65c8:	and.w	r3, r2, #255	; 0xff
    65cc:	add	r6, sp, #32
    65ce:	cbz	r2, 65e6 <FatFile::rename(FatFile*, char const*)+0x98>
    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    65d0:	movw	r3, #2561	; 0xa01
    65d4:	mov	r2, r9
    65d6:	mov	r1, r8
    65d8:	mov	r0, r6
    65da:	bl	6280 <FatFile::open(FatFile*, char const*, int)>
    65de:	cmp	r0, #0
    65e0:	beq.n	657c <FatFile::rename(FatFile*, char const*)+0x2e>
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
  DirFat_t entry;
  uint32_t dirCluster = 0;
    65e2:	movs	r7, #0
    65e4:	b.n	65f6 <FatFile::rename(FatFile*, char const*)+0xa8>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // don't create missing path prefix components
    if (!file.mkdir(dirFile, newPath, false)) {
    65e6:	mov	r2, r9
    65e8:	mov	r1, r8
    65ea:	mov	r0, r6
    65ec:	bl	64a4 <FatFile::mkdir(FatFile*, char const*, bool)>
    65f0:	cmp	r0, #0
    65f2:	beq.n	657c <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
    65f4:	ldr	r7, [sp, #64]	; 0x40
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
    65f6:	ldr	r3, [sp, #56]	; 0x38
    65f8:	str	r3, [r4, #24]
  m_dirIndex = file.m_dirIndex;
    65fa:	ldrh.w	r3, [sp, #36]	; 0x24
    65fe:	strh	r3, [r4, #4]
  m_lfnOrd = file.m_lfnOrd;
    6600:	ldrb.w	r3, [sp, #35]	; 0x23
    6604:	strb	r3, [r4, #3]
  m_dirCluster = file.m_dirCluster;
    6606:	ldr	r3, [sp, #44]	; 0x2c
    6608:	str	r3, [r4, #12]
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    660a:	movs	r1, #1
  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    660c:	movs	r3, #0
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    660e:	mov	r0, r4
  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    6610:	strb.w	r3, [sp, #32]
  file.m_flags = 0;
    6614:	strb.w	r3, [sp, #34]	; 0x22

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6618:	bl	5d44 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    661c:	cmp	r0, #0
    661e:	beq.n	657c <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy all but name and name flags to new directory entry
  memcpy(&dir->createTimeMs, &entry.createTimeMs,
         sizeof(entry) - sizeof(dir->name) - 2);
    6620:	add.w	r3, sp, #13
    6624:	add.w	r2, r0, #13
    6628:	add.w	r1, sp, #29
    662c:	ldr.w	lr, [r3], #4
    6630:	str.w	lr, [r2], #4
    6634:	cmp	r3, r1
    6636:	bne.n	662c <FatFile::rename(FatFile*, char const*)+0xde>
    6638:	ldrh	r1, [r3, #0]
    663a:	strh	r1, [r2, #0]
    663c:	ldrb	r3, [r3, #2]
    663e:	strb	r3, [r2, #2]
  dir->attributes = entry.attributes;
    6640:	ldrb.w	r3, [sp, #11]
    6644:	strb	r3, [r0, #11]

  // update dot dot if directory
  if (dirCluster) {
    6646:	cmp	r7, #0
    6648:	beq.n	66bc <FatFile::rename(FatFile*, char const*)+0x16e>
    // get new dot dot
    uint32_t sector = m_vol->clusterStartSector(dirCluster);
    664a:	ldr	r0, [r4, #8]
    664c:	ldrb	r1, [r0, #6]
    664e:	subs	r3, r7, #2
    6650:	lsls	r3, r1
    6652:	ldr	r1, [r0, #20]
    6654:	movs	r2, #0
    6656:	add	r1, r3
    6658:	adds	r0, #40	; 0x28
    665a:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    665e:	cmp	r0, #0
    6660:	beq.n	657c <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&entry, &pc->dir[1], sizeof(entry));
    6662:	add.w	r3, r0, #32
    6666:	mov	lr, r5
    6668:	add.w	ip, r0, #64	; 0x40
    666c:	ldr	r0, [r3, #0]
    666e:	ldr	r1, [r3, #4]
    6670:	mov	r2, lr
    6672:	stmia	r2!, {r0, r1}
    6674:	adds	r3, #8
    6676:	cmp	r3, ip
    6678:	mov	lr, r2
    667a:	bne.n	666c <FatFile::rename(FatFile*, char const*)+0x11e>

    // free unused cluster
    if (!m_vol->freeChain(dirCluster)) {
    667c:	mov	r1, r7
    667e:	ldr	r0, [r4, #8]
    6680:	bl	6b7a <FatPartition::freeChain(unsigned long)>
    6684:	cmp	r0, #0
    6686:	beq.w	657c <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // store new dot dot
    sector = m_vol->clusterStartSector(m_firstCluster);
    668a:	ldr	r0, [r4, #8]
    668c:	ldr	r1, [r4, #32]
    668e:	ldrb	r3, [r0, #6]
    6690:	subs	r1, #2
    6692:	lsls	r1, r3
    6694:	ldr	r3, [r0, #20]
    6696:	movs	r2, #1
    6698:	add	r1, r3
    669a:	adds	r0, #40	; 0x28
    669c:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    66a0:	cmp	r0, #0
    66a2:	beq.w	657c <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&pc->dir[1], &entry, sizeof(entry));
    66a6:	add.w	r3, r0, #32
    66aa:	mov	r2, r5
    66ac:	ldmia	r2!, {r0, r1}
    66ae:	cmp	r2, r6
    66b0:	str	r0, [r3, #0]
    66b2:	str	r1, [r3, #4]
    66b4:	mov	r5, r2
    66b6:	add.w	r3, r3, #8
    66ba:	bne.n	66aa <FatFile::rename(FatFile*, char const*)+0x15c>
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    66bc:	movs	r3, #0
    66be:	str	r3, [sp, #100]	; 0x64
  oldFile.m_flags = FILE_FLAG_WRITE;
    66c0:	movs	r3, #2
    66c2:	strb.w	r3, [sp, #70]	; 0x46
  oldFile.m_attributes = FILE_ATTR_FILE;
  if (!oldFile.remove()) {
    66c6:	add	r0, sp, #68	; 0x44
    memcpy(&pc->dir[1], &entry, sizeof(entry));
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
    66c8:	movs	r3, #8
    66ca:	strb.w	r3, [sp, #68]	; 0x44
  if (!oldFile.remove()) {
    66ce:	bl	739c <FatFile::remove()>
    66d2:	cmp	r0, #0
    66d4:	beq.w	657c <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return m_vol->cacheSync();
    66d8:	ldr	r0, [r4, #8]
    66da:	bl	5c5c <FatPartition::cacheSync()>

 fail:
  return false;
}
    66de:	add	sp, #108	; 0x6c
    66e0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

000066e4 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    66e4:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    66e8:	mov	r4, r3
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    66ea:	ldrb	r3, [r0, #0]
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    66ec:	ldrb.w	fp, [sp, #40]	; 0x28
    66f0:	ldrb.w	r9, [sp, #44]	; 0x2c
    66f4:	ldrb.w	sl, [sp, #48]	; 0x30
    66f8:	ldrb.w	r5, [sp, #52]	; 0x34
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    66fc:	lsls	r3, r3, #28
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    66fe:	mov	r6, r0
    6700:	mov	r7, r1
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    6702:	bmi.n	670a <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x26>
    setLe16(dir->modifyTime, dirTime);
  }
  return m_vol->cacheSync();

 fail:
  return false;
    6704:	movs	r0, #0
    6706:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint16_t dirDate;
  uint16_t dirTime;
  DirFat_t* dir;

  if (!isFile()
      || year < 1980
    670a:	subw	r2, r2, #1980	; 0x7bc
    670e:	uxth.w	r8, r2
    6712:	cmp.w	r8, #127	; 0x7f
    6716:	bhi.n	6704 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || year > 2107
      || month < 1
    6718:	subs	r3, r4, #1
    671a:	cmp	r3, #11
    671c:	bhi.n	6704 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || month > 12
      || day < 1
    671e:	add.w	r3, fp, #4294967295
    6722:	cmp	r3, #30
    6724:	bhi.n	6704 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || day > 31
      || hour > 23
    6726:	cmp.w	r9, #23
    672a:	bhi.n	6704 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || minute > 59
    672c:	cmp.w	sl, #59	; 0x3b
    6730:	bhi.n	6704 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || second > 59) {
    6732:	cmp	r5, #59	; 0x3b
    6734:	bhi.n	6704 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // update directory entry
  if (!sync()) {
    6736:	bl	61f0 <FatFile::sync()>
    673a:	cmp	r0, #0
    673c:	beq.n	6704 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
    DBG_FAIL_MACRO;
    goto fail;
  }
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    673e:	movs	r1, #1
    6740:	mov	r0, r6
    6742:	bl	5d44 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    6746:	cmp	r0, #0
    6748:	beq.n	6704 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    674a:	orr.w	r4, fp, r4, lsl #5
    674e:	orr.w	r8, r4, r8, lsl #9
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    6752:	asrs	r3, r5, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  dirDate = FS_DATE(year, month, day);
  dirTime = FS_TIME(hour, minute, second);
  if (flags & T_ACCESS) {
    6754:	lsls	r4, r7, #31
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    6756:	uxth.w	r8, r8
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    675a:	orr.w	r3, r3, sl, lsl #5
    675e:	orr.w	r3, r3, r9, lsl #11
    6762:	it	mi
    6764:	strhmi.w	r8, [r0, #18]
    setLe16(dir->accessDate, dirDate);
  }
  if (flags & T_CREATE) {
    6768:	lsls	r1, r7, #30
    676a:	uxth	r3, r3
    676c:	bpl.n	677e <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x9a>
    setLe16(dir->createDate, dirDate);
    setLe16(dir->createTime, dirTime);
    // units of 10 ms
    dir->createTimeMs = second & 1 ? 100 : 0;
    676e:	ands.w	r5, r5, #1
    6772:	it	ne
    6774:	movne	r5, #100	; 0x64
    6776:	strh.w	r8, [r0, #16]
    677a:	strh	r3, [r0, #14]
    677c:	strb	r5, [r0, #13]
  }
  if (flags & T_WRITE) {
    677e:	lsls	r2, r7, #29
    6780:	itt	mi
    6782:	strhmi.w	r8, [r0, #24]
    6786:	strhmi	r3, [r0, #22]
    setLe16(dir->modifyDate, dirDate);
    setLe16(dir->modifyTime, dirTime);
  }
  return m_vol->cacheSync();
    6788:	ldr	r0, [r6, #8]
    678a:	bl	5c5c <FatPartition::cacheSync()>
    678e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00006792 <FatFile::truncate()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    6792:	push	{r0, r1, r4, lr}
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    6794:	ldrb	r3, [r0, #2]
    6796:	lsls	r3, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    6798:	mov	r4, r0
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    679a:	bmi.n	67a0 <FatFile::truncate()+0xe>
  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    679c:	movs	r0, #0
    679e:	b.n	67f6 <FatFile::truncate()+0x64>
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    67a0:	ldr	r3, [r0, #32]
    67a2:	cbz	r3, 67f4 <FatFile::truncate()+0x62>
      return true;
  }
  if (m_curCluster) {
    67a4:	ldr	r1, [r0, #16]
    67a6:	cbz	r1, 67cc <FatFile::truncate()+0x3a>
    toFree = 0;
    67a8:	add	r2, sp, #8
    67aa:	movs	r3, #0
    67ac:	str.w	r3, [r2, #-4]!
    int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    67b0:	ldr	r0, [r0, #8]
    67b2:	bl	6a34 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    67b6:	cmp	r0, #0
    67b8:	blt.n	679c <FatFile::truncate()+0xa>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg) {
    67ba:	beq.n	67d0 <FatFile::truncate()+0x3e>
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    67bc:	mvn.w	r2, #4026531840	; 0xf0000000
    67c0:	ldr	r1, [r4, #16]
    67c2:	ldr	r0, [r4, #8]
    67c4:	bl	6a9e <FatPartition::fatPut(unsigned long, unsigned long)>
      // current cluster is end of chain
      if (!m_vol->fatPutEOC(m_curCluster)) {
    67c8:	cbnz	r0, 67d0 <FatFile::truncate()+0x3e>
    67ca:	b.n	679c <FatFile::truncate()+0xa>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  } else {
    toFree = m_firstCluster;
    67cc:	str	r3, [sp, #4]
    m_firstCluster = 0;
    67ce:	str	r1, [r0, #32]
  }
  if (toFree) {
    67d0:	ldr	r1, [sp, #4]
    67d2:	cbnz	r1, 67e8 <FatFile::truncate()+0x56>
    if (!m_vol->freeChain(toFree)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_fileSize = m_curPosition;
    67d4:	ldr	r3, [r4, #20]
    67d6:	str	r3, [r4, #28]

  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
    67d8:	ldrb	r3, [r4, #2]
    67da:	orn	r3, r3, #127	; 0x7f
    67de:	strb	r3, [r4, #2]
  return sync();
    67e0:	mov	r0, r4
    67e2:	bl	61f0 <FatFile::sync()>
    67e6:	b.n	67f6 <FatFile::truncate()+0x64>
  } else {
    toFree = m_firstCluster;
    m_firstCluster = 0;
  }
  if (toFree) {
    if (!m_vol->freeChain(toFree)) {
    67e8:	ldr	r0, [r4, #8]
    67ea:	bl	6b7a <FatPartition::freeChain(unsigned long)>
    67ee:	cmp	r0, #0
    67f0:	bne.n	67d4 <FatFile::truncate()+0x42>
    67f2:	b.n	679c <FatFile::truncate()+0xa>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    67f4:	movs	r0, #1
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    67f6:	add	sp, #8
    67f8:	pop	{r4, pc}
    67fa:	Address 0x000067fa is out of bounds.


000067fc <FatFile::write(void const*, unsigned int)>:
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    67fc:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6800:	ldrb	r3, [r0, #2]
    6802:	mov	r9, r1
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    6804:	lsls	r1, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    6806:	mov	r4, r0
    6808:	mov	r5, r2
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    680a:	bpl.w	692a <FatFile::write(void const*, unsigned int)+0x12e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    680e:	lsls	r2, r3, #28
    6810:	bmi.n	6828 <FatFile::write(void const*, unsigned int)+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    6812:	ldr	r3, [r4, #20]
    6814:	mvns	r3, r3
    6816:	cmp	r5, r3
    6818:	bhi.w	692a <FatFile::write(void const*, unsigned int)+0x12e>
    681c:	mov	r7, r5
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    681e:	mov.w	sl, #0
    m_sector = 0XFFFFFFFF;
    6822:	mov.w	fp, #4294967295
    6826:	b.n	68b6 <FatFile::write(void const*, unsigned int)+0xba>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_fileSize)) {
    6828:	ldr	r1, [r0, #28]
    682a:	bl	5f9a <FatFile::seekSet(unsigned long)>
    682e:	cmp	r0, #0
    6830:	bne.n	6812 <FatFile::write(void const*, unsigned int)+0x16>
    6832:	b.n	692a <FatFile::write(void const*, unsigned int)+0x12e>
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    6834:	ldr	r0, [r4, #8]
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    6836:	ldrb	r6, [r0, #5]
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    6838:	ands.w	r6, r6, r2, lsr #9
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    683c:	ubfx	r8, r2, #0, #9
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    6840:	beq.n	68be <FatFile::write(void const*, unsigned int)+0xc2>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
    6842:	ldr.w	lr, [r4, #8]
                      + sectorOfCluster;
    6846:	ldr	r1, [r4, #16]
    6848:	ldrb.w	r3, [lr, #6]
    684c:	subs	r1, #2
    684e:	lsls	r1, r3
    6850:	ldr.w	r3, [lr, #20]
    6854:	add	r1, r3
    6856:	add	r1, r6

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
    6858:	cmp.w	r8, #0
    685c:	bne.n	68f0 <FatFile::write(void const*, unsigned int)+0xf4>
    685e:	cmp.w	r7, #512	; 0x200
    6862:	bcs.n	693e <FatFile::write(void const*, unsigned int)+0x142>
      // lesser of space and amount to write
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (sectorOffset == 0 &&
    6864:	ldr	r2, [r4, #20]
    6866:	ldr	r3, [r4, #28]
    6868:	cmp	r2, r3
    686a:	bcs.n	68f4 <FatFile::write(void const*, unsigned int)+0xf8>
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
    686c:	ldrb	r3, [r4, #2]
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    686e:	tst.w	r3, #32
    6872:	ite	eq
    6874:	moveq	r2, #1
    6876:	movne	r2, #5
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    6878:	add.w	r0, lr, #40	; 0x28
    687c:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      pc = m_vol->cacheFetchData(sector, cacheOption);
      if (!pc) {
    6880:	cmp	r0, #0
    6882:	beq.n	692a <FatFile::write(void const*, unsigned int)+0x12e>
                      + sectorOfCluster;

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    6884:	rsb	r6, r8, #512	; 0x200
    6888:	cmp	r6, r7
    688a:	it	cs
    688c:	movcs	r6, r7
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    688e:	add	r0, r8
    6890:	mov	r2, r6
    6892:	mov	r1, r9
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    6894:	add	r8, r6
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    6896:	bl	8ed0 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    689a:	cmp.w	r8, #512	; 0x200
    689e:	bne.n	68ac <FatFile::write(void const*, unsigned int)+0xb0>
  }
  void cacheInvalidate() {
    m_cache.invalidate();
  }
  bool cacheSyncData() {
    return m_cache.sync();
    68a0:	ldr	r0, [r4, #8]
    68a2:	adds	r0, #40	; 0x28
    68a4:	bl	37d6 <FsCache::sync()>
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
      if (nSector > maxSectors) {
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeWrite(sector, src, nSector)) {
    68a8:	cmp	r0, #0
    68aa:	beq.n	692a <FatFile::write(void const*, unsigned int)+0x12e>
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    68ac:	ldr	r3, [r4, #20]
    68ae:	add	r3, r6
    68b0:	str	r3, [r4, #20]
    src += n;
    68b2:	add	r9, r6
    nToWrite -= n;
    68b4:	subs	r7, r7, r6
    68b6:	ldr	r2, [r4, #20]
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    68b8:	cmp	r7, #0
    68ba:	bne.n	6834 <FatFile::write(void const*, unsigned int)+0x38>
    68bc:	b.n	68f8 <FatFile::write(void const*, unsigned int)+0xfc>
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    68be:	cmp.w	r8, #0
    68c2:	bne.n	6842 <FatFile::write(void const*, unsigned int)+0x46>
      // start of new cluster
      if (m_curCluster != 0) {
    68c4:	ldr	r1, [r4, #16]
    68c6:	cbz	r1, 68da <FatFile::write(void const*, unsigned int)+0xde>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
    68c8:	ldrb	r3, [r4, #2]
    68ca:	lsls	r3, r3, #25
    68cc:	bpl.n	6912 <FatFile::write(void const*, unsigned int)+0x116>
    68ce:	ldr	r3, [r4, #28]
    68d0:	cmp	r2, r3
    68d2:	bcs.n	6912 <FatFile::write(void const*, unsigned int)+0x116>
          m_curCluster++;
    68d4:	adds	r1, #1
    68d6:	str	r1, [r4, #16]
    68d8:	b.n	6842 <FatFile::write(void const*, unsigned int)+0x46>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    68da:	ldr	r3, [r4, #32]
    68dc:	cbnz	r3, 68ec <FatFile::write(void const*, unsigned int)+0xf0>
          // allocate first cluster of file
          if (!addCluster()) {
    68de:	mov	r0, r4
    68e0:	bl	5c82 <FatFile::addCluster()>
    68e4:	cbz	r0, 692a <FatFile::write(void const*, unsigned int)+0x12e>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    68e6:	ldr	r3, [r4, #16]
    68e8:	str	r3, [r4, #32]
    68ea:	b.n	6842 <FatFile::write(void const*, unsigned int)+0x46>
        } else {
          m_curCluster = m_firstCluster;
    68ec:	str	r3, [r4, #16]
    68ee:	b.n	6842 <FatFile::write(void const*, unsigned int)+0x46>
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    68f0:	movs	r2, #1
    68f2:	b.n	6878 <FatFile::write(void const*, unsigned int)+0x7c>
      }

      if (sectorOffset == 0 &&
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    68f4:	movs	r2, #5
    68f6:	b.n	6878 <FatFile::write(void const*, unsigned int)+0x7c>
    }
    m_curPosition += n;
    src += n;
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    68f8:	ldr	r3, [r4, #28]
    68fa:	cmp	r2, r3
    68fc:	bls.n	6902 <FatFile::write(void const*, unsigned int)+0x106>
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    68fe:	str	r2, [r4, #28]
    6900:	b.n	6908 <FatFile::write(void const*, unsigned int)+0x10c>
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    6902:	ldr	r3, [pc, #180]	; (69b8 <FatFile::write(void const*, unsigned int)+0x1bc>)
    6904:	ldr	r3, [r3, #0]
    6906:	cbz	r3, 6938 <FatFile::write(void const*, unsigned int)+0x13c>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    6908:	ldrb	r3, [r4, #2]
    690a:	orn	r3, r3, #127	; 0x7f
    690e:	strb	r3, [r4, #2]
    6910:	b.n	6938 <FatFile::write(void const*, unsigned int)+0x13c>
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
          m_curCluster++;
          fg = 1;
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    6912:	add.w	r2, r4, #16
    6916:	bl	6a34 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    691a:	cmp	r0, #0
    691c:	blt.n	692a <FatFile::write(void const*, unsigned int)+0x12e>
        if (fg < 0) {
          DBG_FAIL_MACRO;
          goto fail;
        }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        if (fg == 0) {
    691e:	bne.n	69a0 <FatFile::write(void const*, unsigned int)+0x1a4>
          // add cluster if at end of chain
          if (!addCluster()) {
    6920:	mov	r0, r4
    6922:	bl	5c82 <FatFile::addCluster()>
    6926:	cmp	r0, #0
    6928:	bne.n	69a0 <FatFile::write(void const*, unsigned int)+0x1a4>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    692a:	ldrb	r3, [r4, #1]
    692c:	orr.w	r3, r3, #1
    6930:	strb	r3, [r4, #1]
  return 0;
    6932:	movs	r0, #0
    6934:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6938:	mov	r0, r5
    693a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (nToWrite >= 2*m_vol->bytesPerSector()) {
    693e:	cmp.w	r7, #1024	; 0x400
    6942:	ldr.w	r2, [lr, #52]	; 0x34
    6946:	ldr.w	r0, [lr, #44]	; 0x2c
    694a:	bcc.n	6976 <FatFile::write(void const*, unsigned int)+0x17a>
      // use multiple sector write command
      uint32_t maxSectors = m_vol->sectorsPerCluster() - sectorOfCluster;
    694c:	ldrb.w	r3, [lr, #4]
    6950:	subs	r6, r3, r6
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
    6952:	lsrs	r3, r7, #9
    6954:	cmp	r3, r6
    6956:	it	cs
    6958:	movcs	r3, r6
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    695a:	cmp	r2, r1
      if (nSector > maxSectors) {
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
    695c:	mov.w	r6, r3, lsl #9
    6960:	bcc.n	696a <FatFile::write(void const*, unsigned int)+0x16e>
    6962:	add.w	ip, r3, r1
    6966:	cmp	r2, ip
    6968:	bcc.n	6996 <FatFile::write(void const*, unsigned int)+0x19a>
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    696a:	ldr	r2, [r0, #0]
    696c:	ldr.w	r8, [r2, #36]	; 0x24
    6970:	mov	r2, r9
    6972:	blx	r8
    6974:	b.n	68a8 <FatFile::write(void const*, unsigned int)+0xac>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    6976:	cmp	r2, r1
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6978:	it	eq
    697a:	strbeq.w	sl, [lr, #40]	; 0x28
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    697e:	ldr	r3, [r0, #0]
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    6980:	it	eq
    6982:	streq.w	fp, [lr, #52]	; 0x34
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    6986:	ldr	r3, [r3, #32]
    6988:	mov	r2, r9
    698a:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    698c:	cmp	r0, #0
    698e:	beq.n	692a <FatFile::write(void const*, unsigned int)+0x12e>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
    6990:	mov.w	r6, #512	; 0x200
    6994:	b.n	68ac <FatFile::write(void const*, unsigned int)+0xb0>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6996:	strb.w	sl, [lr, #40]	; 0x28
    m_sector = 0XFFFFFFFF;
    699a:	str.w	fp, [lr, #52]	; 0x34
    699e:	b.n	696a <FatFile::write(void const*, unsigned int)+0x16e>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
    69a0:	ldr.w	lr, [r4, #8]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    69a4:	ldr	r1, [r4, #16]
    69a6:	ldrb.w	r3, [lr, #6]
    69aa:	subs	r1, #2
    69ac:	lsls	r1, r3
    69ae:	ldr.w	r3, [lr, #20]
    69b2:	add	r1, r3
    69b4:	b.n	685e <FatFile::write(void const*, unsigned int)+0x62>
    69b6:	nop
    69b8:	.word	0x2001ceb4

000069bc <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)>:

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat16(uint32_t sector, uint8_t *buf, void *context) {
   struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint16_t *p = (uint16_t *)buf;
  unsigned int n = state->clusters_to_do;
    69bc:	ldr	r3, [r2, #0]
    69be:	cmp.w	r3, #256	; 0x100
  uint32_t clusters_to_do;
  uint32_t free_count;
};

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat16(uint32_t sector, uint8_t *buf, void *context) {
    69c2:	push	{r4, r5, lr}
    69c4:	mov	r4, r3
    69c6:	it	cs
    69c8:	movcs.w	r4, #256	; 0x100
   struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint16_t *p = (uint16_t *)buf;
  unsigned int n = state->clusters_to_do;
  if (n > 256) n = 256;
  uint16_t *e = p + n;
    69cc:	add.w	r5, r1, r4, lsl #1
  while (p < e) {
    69d0:	cmp	r1, r5
    69d2:	bcs.n	69e4 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x28>
    if (*p++ == 0) state->free_count++;
    69d4:	ldrh.w	r0, [r1], #2
    69d8:	cmp	r0, #0
    69da:	bne.n	69d0 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x14>
    69dc:	ldr	r0, [r2, #4]
    69de:	adds	r0, #1
    69e0:	str	r0, [r2, #4]
    69e2:	b.n	69d0 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x14>
  }
  state->clusters_to_do -= n;
    69e4:	subs	r3, r3, r4
    69e6:	str	r3, [r2, #0]
    69e8:	pop	{r4, r5, pc}

000069ea <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)>:

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat32(uint32_t sector, uint8_t *buf, void *context) {
  struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint32_t *p = (uint32_t *)buf;
  unsigned int n = state->clusters_to_do;
    69ea:	ldr	r3, [r2, #0]
    69ec:	cmp	r3, #128	; 0x80
  }
  state->clusters_to_do -= n;
}

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat32(uint32_t sector, uint8_t *buf, void *context) {
    69ee:	push	{r4, r5, lr}
    69f0:	mov	r4, r3
    69f2:	it	cs
    69f4:	movcs	r4, #128	; 0x80
  struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint32_t *p = (uint32_t *)buf;
  unsigned int n = state->clusters_to_do;
  if (n > 128) n = 128;
  uint32_t *e = p + n;
    69f6:	add.w	r5, r1, r4, lsl #2
  while (p < e) {
    69fa:	cmp	r1, r5
    69fc:	bcs.n	6a0e <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x24>
    if (*p++ == 0) state->free_count++;
    69fe:	ldr.w	r0, [r1], #4
    6a02:	cmp	r0, #0
    6a04:	bne.n	69fa <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x10>
    6a06:	ldr	r0, [r2, #4]
    6a08:	adds	r0, #1
    6a0a:	str	r0, [r2, #4]
    6a0c:	b.n	69fa <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x10>
  }
  state->clusters_to_do -= n;
    6a0e:	subs	r3, r3, r4
    6a10:	str	r3, [r2, #0]
    6a12:	pop	{r4, r5, pc}

00006a14 <FsCache::clear()>:
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    6a14:	push	{r4, lr}
    if (isDirty() && !sync()) {
    6a16:	ldrb	r3, [r0, #0]
    6a18:	lsls	r3, r3, #31
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    6a1a:	mov	r4, r0
    if (isDirty() && !sync()) {
    6a1c:	bpl.n	6a24 <FsCache::clear()+0x10>
    6a1e:	bl	37d6 <FsCache::sync()>
    6a22:	cbz	r0, 6a32 <FsCache::clear()+0x1e>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6a24:	movs	r3, #0
    6a26:	strb	r3, [r4, #0]
    m_sector = 0XFFFFFFFF;
    6a28:	mov.w	r3, #4294967295
    6a2c:	str	r3, [r4, #12]
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    6a2e:	add.w	r0, r4, #16
  }
    6a32:	pop	{r4, pc}

00006a34 <FatPartition::fatGet(unsigned long, unsigned long*)>:
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6a34:	cmp	r1, #1
 fail:
  return false;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry - return -1 error, 0 EOC, else 1.
int8_t FatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    6a36:	push	{r4, r5, r6, lr}
    6a38:	mov	r5, r0
    6a3a:	mov	r4, r1
    6a3c:	mov	r6, r2
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6a3e:	bhi.n	6a46 <FatPartition::fatGet(unsigned long, unsigned long*)+0x12>
  }
  *value = next;
  return 1;

 fail:
  return -1;
    6a40:	mov.w	r0, #4294967295
    6a44:	pop	{r4, r5, r6, pc}
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6a46:	ldr	r3, [r0, #28]
    6a48:	cmp	r1, r3
    6a4a:	bhi.n	6a40 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
    6a4c:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    6a4e:	cmp	r3, #32
    6a50:	bne.n	6a70 <FatPartition::fatGet(unsigned long, unsigned long*)+0x3c>
  FsCache m_cache;
#if USE_SEPARATE_FAT_CACHE
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
    6a52:	ldr	r1, [r0, #24]
    6a54:	movs	r2, #2
    6a56:	add.w	r1, r1, r4, lsr #7
    6a5a:	add.w	r0, r0, #568	; 0x238
    6a5e:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    6a62:	cmp	r0, #0
    6a64:	beq.n	6a40 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    6a66:	and.w	r4, r4, #127	; 0x7f
    6a6a:	ldr.w	r3, [r0, r4, lsl #2]
    6a6e:	b.n	6a90 <FatPartition::fatGet(unsigned long, unsigned long*)+0x5c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe32(reinterpret_cast<uint8_t*>
                  (&pc->fat32[cluster & (m_sectorMask >> 2)]));
  } else if (fatType() == 16) {
    6a70:	cmp	r3, #16
    6a72:	bne.n	6a40 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
    6a74:	ldr	r3, [r0, #24]
    6a76:	ubfx	r1, r1, #8, #8
    6a7a:	movs	r2, #2
    6a7c:	add	r1, r3
    6a7e:	add.w	r0, r0, #568	; 0x238
    6a82:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    6a86:	cmp	r0, #0
    6a88:	beq.n	6a40 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    6a8a:	uxtb	r4, r4
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe16(reinterpret_cast<uint8_t*>
                  (&pc->fat16[cluster & (m_sectorMask >> 1)]));
    6a8c:	ldrh.w	r3, [r0, r4, lsl #1]
    next = cluster & 1 ? tmp >> 4 : tmp & 0XFFF;
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    6a90:	ldr	r2, [r5, #28]
    6a92:	cmp	r3, r2
    return 0;
  }
  *value = next;
  return 1;
    6a94:	itte	ls
    6a96:	movls	r0, #1
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
  }
  *value = next;
    6a98:	strls	r3, [r6, #0]
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
    6a9a:	movhi	r0, #0
  *value = next;
  return 1;

 fail:
  return -1;
}
    6a9c:	pop	{r4, r5, r6, pc}

00006a9e <FatPartition::fatPut(unsigned long, unsigned long)>:
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6a9e:	cmp	r1, #1
 fail:
  return -1;
}
//------------------------------------------------------------------------------
// Store a FAT entry
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
    6aa0:	push	{r3, r4, r5, lr}
    6aa2:	mov	r4, r1
    6aa4:	mov	r5, r2
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6aa6:	bhi.n	6aac <FatPartition::fatPut(unsigned long, unsigned long)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }

 fail:
  return false;
    6aa8:	movs	r0, #0
    6aaa:	pop	{r3, r4, r5, pc}
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6aac:	ldr	r3, [r0, #28]
    6aae:	cmp	r1, r3
    6ab0:	bhi.n	6aa8 <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
    6ab2:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    6ab4:	cmp	r3, #32
    6ab6:	bne.n	6ad6 <FatPartition::fatPut(unsigned long, unsigned long)+0x38>
    6ab8:	ldr	r1, [r0, #24]
    6aba:	movs	r2, #3
    6abc:	add.w	r1, r1, r4, lsr #7
    6ac0:	add.w	r0, r0, #568	; 0x238
    6ac4:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    6ac8:	cmp	r0, #0
    6aca:	beq.n	6aa8 <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    6acc:	and.w	r4, r4, #127	; 0x7f
    6ad0:	str.w	r5, [r0, r4, lsl #2]
    6ad4:	b.n	6af6 <FatPartition::fatPut(unsigned long, unsigned long)+0x58>
    setLe32(reinterpret_cast<uint8_t*>
           (&pc->fat32[cluster & (m_sectorMask >> 2)]), value);
    return true;
  }

  if (fatType() == 16) {
    6ad6:	cmp	r3, #16
    6ad8:	bne.n	6aa8 <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
    6ada:	ldr	r3, [r0, #24]
    6adc:	ubfx	r1, r1, #8, #8
    6ae0:	movs	r2, #3
    6ae2:	add	r1, r3
    6ae4:	add.w	r0, r0, #568	; 0x238
    6ae8:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    6aec:	cmp	r0, #0
    6aee:	beq.n	6aa8 <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    6af0:	uxtb	r4, r4
    6af2:	strh.w	r5, [r0, r4, lsl #1]
      DBG_FAIL_MACRO;
      goto fail;
    }
    setLe16(reinterpret_cast<uint8_t*>
           (&pc->fat16[cluster & (m_sectorMask >> 1)]), value);
    return true;
    6af6:	movs	r0, #1
    goto fail;
  }

 fail:
  return false;
}
    6af8:	pop	{r3, r4, r5, pc}

00006afa <FatPartition::allocateCluster(unsigned long, unsigned long*)>:
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"
#include "FatPartition.h"

//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    6afa:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    6afe:	ldr	r4, [r0, #12]
    6b00:	cmp	r4, r1
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"
#include "FatPartition.h"

//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    6b02:	mov	r5, r0
    6b04:	mov	r6, r1
    6b06:	mov	r8, r2
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    6b08:	bcs.n	6b1a <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x20>
    6b0a:	mov	r4, r1
    // Try to keep file contiguous. Start just after current cluster.
    find = current;
    setStart = false;
    6b0c:	movs	r7, #0
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    if (find > m_lastCluster) {
    6b0e:	ldr	r3, [r5, #28]
  } else {
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    6b10:	adds	r4, #1
    if (find > m_lastCluster) {
    6b12:	cmp	r4, r3
    6b14:	bls.n	6b1e <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x24>
      if (setStart) {
    6b16:	cbnz	r7, 6b4c <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
        // Can't find space, checked all clusters.
        DBG_FAIL_MACRO;
        goto fail;
      }
      find = m_allocSearchStart;
    6b18:	ldr	r4, [r5, #12]
      setStart = true;
    6b1a:	movs	r7, #1
    6b1c:	b.n	6b0e <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
      continue;
    }
    if (find == current) {
    6b1e:	cmp	r6, r4
    6b20:	beq.n	6b4c <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    6b22:	add	r2, sp, #4
    6b24:	mov	r1, r4
    6b26:	mov	r0, r5
    6b28:	bl	6a34 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    6b2c:	cmp	r0, #0
    6b2e:	blt.n	6b4c <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg && f == 0) {
    6b30:	beq.n	6b0e <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
    6b32:	ldr	r3, [sp, #4]
    6b34:	cmp	r3, #0
    6b36:	bne.n	6b0e <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
      break;
    }
  }
  if (setStart) {
    6b38:	cbz	r7, 6b3c <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x42>
    m_allocSearchStart = find;
    6b3a:	str	r4, [r5, #12]
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    6b3c:	mvn.w	r2, #4026531840	; 0xf0000000
    6b40:	mov	r1, r4
    6b42:	mov	r0, r5
    6b44:	bl	6a9e <FatPartition::fatPut(unsigned long, unsigned long)>
  }
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    6b48:	mov	r7, r0
    6b4a:	cbnz	r0, 6b50 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x56>
  updateFreeClusterCount(-1);
  *next = find;
  return true;

 fail:
  return false;
    6b4c:	movs	r7, #0
    6b4e:	b.n	6b72 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
    6b50:	cbnz	r6, 6b5e <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x64>
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
  }
  void updateFreeClusterCount(int32_t change) {
    if (m_freeClusterCount >= 0) {
    6b52:	ldr	r3, [r5, #36]	; 0x24
    6b54:	cmp	r3, #0
    6b56:	blt.n	6b6e <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x74>
      m_freeClusterCount += change;
    6b58:	subs	r3, #1
    6b5a:	str	r3, [r5, #36]	; 0x24
    6b5c:	b.n	6b6e <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x74>
    // Link clusters.
    if (!fatPut(current, find)) {
    6b5e:	mov	r2, r4
    6b60:	mov	r1, r6
    6b62:	mov	r0, r5
    6b64:	bl	6a9e <FatPartition::fatPut(unsigned long, unsigned long)>
    6b68:	cmp	r0, #0
    6b6a:	bne.n	6b52 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x58>
    6b6c:	b.n	6b4c <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  updateFreeClusterCount(-1);
  *next = find;
    6b6e:	str.w	r4, [r8]
  return true;

 fail:
  return false;
}
    6b72:	mov	r0, r7
    6b74:	add	sp, #8
    6b76:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00006b7a <FatPartition::freeChain(unsigned long)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
    6b7a:	push	{r0, r1, r4, r5, r6, lr}
    6b7c:	mov	r5, r0
    6b7e:	mov	r4, r1
  uint32_t next;
  int8_t fg;
  do {
    fg = fatGet(cluster, &next);
    6b80:	add	r2, sp, #4
    6b82:	mov	r1, r4
    6b84:	mov	r0, r5
    6b86:	bl	6a34 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    6b8a:	subs	r6, r0, #0
    6b8c:	bge.n	6b92 <FatPartition::freeChain(unsigned long)+0x18>
  } while (fg);

  return true;

 fail:
  return false;
    6b8e:	movs	r0, #0
    6b90:	b.n	6bbc <FatPartition::freeChain(unsigned long)+0x42>
    if (fg < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
    6b92:	movs	r2, #0
    6b94:	mov	r1, r4
    6b96:	mov	r0, r5
    6b98:	bl	6a9e <FatPartition::fatPut(unsigned long, unsigned long)>
    6b9c:	cmp	r0, #0
    6b9e:	beq.n	6b8e <FatPartition::freeChain(unsigned long)+0x14>
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
  }
  void updateFreeClusterCount(int32_t change) {
    if (m_freeClusterCount >= 0) {
    6ba0:	ldr	r3, [r5, #36]	; 0x24
    6ba2:	cmp	r3, #0
      m_freeClusterCount += change;
    6ba4:	itt	ge
    6ba6:	addge	r3, #1
    6ba8:	strge	r3, [r5, #36]	; 0x24
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Add one to count of free clusters.
    updateFreeClusterCount(1);
    if (cluster < m_allocSearchStart) {
    6baa:	ldr	r3, [r5, #12]
    6bac:	cmp	r4, r3
      m_allocSearchStart = cluster - 1;
    6bae:	itt	cc
    6bb0:	addcc.w	r4, r4, #4294967295
    6bb4:	strcc	r4, [r5, #12]
    }
    cluster = next;
    6bb6:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  int8_t fg;
  do {
    6bb8:	cmp	r6, #0
    6bba:	bne.n	6b80 <FatPartition::freeChain(unsigned long)+0x6>

  return true;

 fail:
  return false;
}
    6bbc:	add	sp, #8
    6bbe:	pop	{r4, r5, r6, pc}

00006bc0 <FatPartition::freeClusterCount()>:
  }
  state->clusters_to_do -= n;
}

//------------------------------------------------------------------------------
int32_t FatPartition::freeClusterCount() {
    6bc0:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    6bc2:	mov	r4, r0
#if MAINTAIN_FREE_CLUSTER_COUNT
  if (m_freeClusterCount >= 0) {
    6bc4:	ldr	r0, [r0, #36]	; 0x24
    6bc6:	cmp	r0, #0
    6bc8:	bge.n	6c0e <FatPartition::freeClusterCount()+0x4e>
    return free;
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
    6bca:	movs	r3, #0
    6bcc:	str	r3, [sp, #12]
  state.clusters_to_do = m_lastCluster + 1;
    6bce:	ldr	r3, [r4, #28]
  uint32_t num_sectors;

  //num_sectors = SD.sdfs.m_fVol->sectorsPerFat(); // edit FsVolume.h for public
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
    6bd0:	ldr	r5, [r4, #16]
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
  state.clusters_to_do = m_lastCluster + 1;
    6bd2:	adds	r3, #1
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
  //Serial.printf("  num_sectors = %u\n", num_sectors);
#if USE_SEPARATE_FAT_CACHE
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
    6bd4:	add.w	r0, r4, #568	; 0x238
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
  state.clusters_to_do = m_lastCluster + 1;
    6bd8:	str	r3, [sp, #8]
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
  //Serial.printf("  num_sectors = %u\n", num_sectors);
#if USE_SEPARATE_FAT_CACHE
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
    6bda:	bl	6a14 <FsCache::clear()>
#else  
  uint8_t *buf = m_cache.clear();  // will clear out anything and return buffer 
#endif  // USE_SEPARATE_FAT_CACHE
  if (buf == nullptr) return -1;
    6bde:	mov	r2, r0
    6be0:	cbnz	r0, 6be8 <FatPartition::freeClusterCount()+0x28>
    6be2:	mov.w	r0, #4294967295
    6be6:	b.n	6c0e <FatPartition::freeClusterCount()+0x4e>
  if (fatType() == FAT_TYPE_FAT32) {
    6be8:	ldrb	r3, [r4, #7]
    6bea:	ldr	r0, [r4, #0]
    6bec:	cmp	r3, #32
    6bee:	add	r3, sp, #8
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat32, &state)) return -1;
    6bf0:	ldr	r1, [r0, #0]
    6bf2:	str	r3, [sp, #4]
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
#else  
  uint8_t *buf = m_cache.clear();  // will clear out anything and return buffer 
#endif  // USE_SEPARATE_FAT_CACHE
  if (buf == nullptr) return -1;
  if (fatType() == FAT_TYPE_FAT32) {
    6bf4:	bne.n	6bfa <FatPartition::freeClusterCount()+0x3a>
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat32, &state)) return -1;
    6bf6:	ldr	r3, [pc, #28]	; (6c14 <FatPartition::freeClusterCount()+0x54>)
    6bf8:	b.n	6bfc <FatPartition::freeClusterCount()+0x3c>
  } else {
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat16, &state)) return -1;
    6bfa:	ldr	r3, [pc, #28]	; (6c18 <FatPartition::freeClusterCount()+0x58>)
    6bfc:	str	r3, [sp, #0]
    6bfe:	ldr	r6, [r1, #20]
    6c00:	ldr	r1, [r4, #24]
    6c02:	mov	r3, r5
    6c04:	blx	r6
    6c06:	cmp	r0, #0
    6c08:	beq.n	6be2 <FatPartition::freeClusterCount()+0x22>
  }

  setFreeClusterCount(state.free_count);
    6c0a:	ldr	r0, [sp, #12]
    return m_blockDev->writeSector(sector, src);
  }
#if MAINTAIN_FREE_CLUSTER_COUNT
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
    6c0c:	str	r0, [r4, #36]	; 0x24
  return state.free_count;
}
    6c0e:	add	sp, #16
    6c10:	pop	{r4, r5, r6, pc}
    6c12:	nop
    6c14:	.word	0x000069eb
    6c18:	.word	0x000069bd

00006c1c <FatPartition::init(BlockDeviceInterface*, unsigned char)>:


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    6c1c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6c20:	mov	r4, r0
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif

  uint8_t tmp;
  m_fatType = 0;
    6c22:	movs	r7, #0
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    6c24:	mov.w	r3, #4294967295
  m_allocSearchStart = 1;
    6c28:	movs	r6, #1
  }
  /** Clear the cache and returns a pointer to the cache.  Not for normal apps.
   * \return A pointer to the cache buffer or zero if an error occurs.
   */
  uint8_t* cacheClear() {
    return m_cache.clear();
    6c2a:	add.w	r8, r0, #40	; 0x28
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
//  Serial.printf(" FatPartition::init(%x %u)\n", (uint32_t)dev, part);
  uint32_t clusterCount;
  uint32_t totalSectors;
  uint32_t volumeStartSector = 0;
  m_blockDev = dev;
    6c2e:	str	r1, [r4, #0]
  return state.free_count;
}


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    6c30:	sub	sp, #28
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif

  uint8_t tmp;
  m_fatType = 0;
    6c32:	strb	r7, [r0, #7]
  m_allocSearchStart = 1;
    6c34:	str	r6, [r0, #12]
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    6c36:	str	r1, [r4, #44]	; 0x2c
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    6c38:	str	r3, [r0, #52]	; 0x34
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6c3a:	strb.w	r7, [r0, #40]	; 0x28
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    6c3e:	str.w	r1, [r4, #572]	; 0x23c
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    6c42:	str.w	r3, [r0, #580]	; 0x244
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6c46:	strb.w	r7, [r0, #568]	; 0x238
    6c4a:	mov	r0, r8
  return state.free_count;
}


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    6c4c:	mov	r5, r1
    6c4e:	mov	r9, r2
    6c50:	bl	6a14 <FsCache::clear()>
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.init(dev);
#endif  // USE_SEPARATE_FAT_CACHE

  #if SUPPORT_GPT_AND_EXTENDED_PATITIONS 
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part, cacheClear(), &firstLBA);
    6c54:	str	r7, [sp, #8]
    6c56:	mov	r2, r0
    6c58:	str	r7, [sp, #4]
    6c5a:	str	r7, [sp, #0]
    6c5c:	add	r3, sp, #20
    6c5e:	mov	r1, r9
    6c60:	mov	r0, r5
    6c62:	bl	3598 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    6c66:	tst.w	r0, #251	; 0xfb
    6c6a:	beq.n	6cf0 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    DBG_FAIL_MACRO;
    goto fail;    
  }
  volumeStartSector = firstLBA;
    6c6c:	ldr	r5, [sp, #20]
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    6c6e:	mov	r2, r7
    6c70:	mov	r1, r5
    6c72:	mov	r0, r8
    6c74:	bl	3822 <FsCache::get(unsigned long, unsigned char)>
  #endif

  pbs = reinterpret_cast<pbs_t*>
        (cacheFetchData(volumeStartSector, FsCache::CACHE_FOR_READ));
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    6c78:	cmp	r0, #0
    6c7a:	beq.n	6cf0 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    6c7c:	ldrb	r3, [r0, #16]
    6c7e:	cmp	r3, #2
    6c80:	bne.n	6cf0 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    6c82:	ldrh.w	r3, [r0, #11]
    6c86:	cmp.w	r3, #512	; 0x200
    6c8a:	bne.n	6cf0 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    6c8c:	b.n	6cf4 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd8>
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    if (tmp == 0) {
    6c8e:	subs	r2, #1
    6c90:	beq.n	6cf0 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
    6c92:	ldrb	r6, [r4, #6]
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    6c94:	lsls	r3, r3, #1
    if (tmp == 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
    6c96:	adds	r6, #1
    6c98:	strb	r6, [r4, #6]
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    6c9a:	uxtb	r3, r3
    6c9c:	cmp	r3, r1
    6c9e:	bne.n	6c8e <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
    6ca0:	ldrh	r3, [r0, #22]
    6ca2:	str	r3, [r4, #16]
  if (m_sectorsPerFat == 0) {
    6ca4:	cbnz	r3, 6caa <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x8e>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    6ca6:	ldr	r3, [r0, #36]	; 0x24
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
    6ca8:	str	r3, [r4, #16]
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    6caa:	ldrh	r1, [r0, #14]
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    6cac:	ldrh.w	r2, [r0, #17]

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    6cb0:	ldr	r6, [r4, #16]
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);
    6cb2:	strh	r2, [r4, #8]
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    6cb4:	add	r1, r5

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    6cb6:	add.w	r3, r1, r6, lsl #1
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    6cba:	str	r1, [r4, #24]
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    6cbc:	lsls	r1, r2, #5
    6cbe:	addw	r1, r1, #511	; 0x1ff
    6cc2:	add.w	r1, r3, r1, asr #9

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    6cc6:	str	r3, [r4, #32]
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
    6cc8:	ldrh.w	r3, [r0, #19]

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);
    6ccc:	str	r1, [r4, #20]

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
  if (totalSectors == 0) {
    6cce:	cbnz	r3, 6cd2 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xb6>
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    6cd0:	ldr	r3, [r0, #32]
    totalSectors = getLe32(bpb->totalSectors32);
  }
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);
    6cd2:	subs	r1, r5, r1
    6cd4:	add	r1, r3

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
    6cd6:	ldrb	r3, [r4, #6]
    6cd8:	lsrs	r1, r3
  m_lastCluster = clusterCount + 1;
    6cda:	adds	r3, r1, #1
    6cdc:	str	r3, [r4, #28]
    return m_blockDev->writeSector(sector, src);
  }
#if MAINTAIN_FREE_CLUSTER_COUNT
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
    6cde:	mov.w	r3, #4294967295
    6ce2:	str	r3, [r4, #36]	; 0x24

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    6ce4:	movw	r3, #4084	; 0xff4
    6ce8:	cmp	r1, r3
    6cea:	bhi.n	6d04 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xe8>
    m_fatType = 12;
    6cec:	movs	r3, #12
    6cee:	strb	r3, [r4, #7]
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;

 fail:
  return false;
    6cf0:	movs	r0, #0
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    6cf2:	b.n	6d1e <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x102>
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
    6cf4:	ldrb	r1, [r0, #13]
    6cf6:	strb	r1, [r4, #4]
  m_clusterSectorMask = m_sectorsPerCluster - 1;
    6cf8:	subs	r3, r1, #1
    6cfa:	strb	r3, [r4, #5]
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
    6cfc:	strb	r7, [r4, #6]
    6cfe:	movs	r2, #9
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    6d00:	mov	r3, r6
    6d02:	b.n	6c9c <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x80>
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    6d04:	movw	r3, #65524	; 0xfff4
    6d08:	cmp	r1, r3
    6d0a:	ittet	hi
    6d0c:	ldrhi	r3, [r0, #44]	; 0x2c
    m_fatType = 16;
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    6d0e:	strhi	r3, [r4, #32]
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    m_fatType = 16;
    6d10:	movls	r3, #16
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    m_fatType = 32;
    6d12:	movhi	r3, #32
    6d14:	strb	r3, [r4, #7]
  }
  /** Set the offset to the second FAT for mirroring.
   * \param[in] offset Sector offset to second FAT.
   */
  void setMirrorOffset(uint32_t offset) {
    m_mirrorOffset = offset;
    6d16:	str	r6, [r4, #48]	; 0x30
    6d18:	str.w	r6, [r4, #576]	; 0x240
  }
  m_cache.setMirrorOffset(m_sectorsPerFat);
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;
    6d1c:	movs	r0, #1

 fail:
  return false;
}
    6d1e:	add	sp, #28
    6d20:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00006d24 <FatVolume::chdir(char const*)>:
#define DBG_FILE "FatVolume.cpp"
#include "../common/DebugMacros.h"
#include "FatVolume.h"
FatVolume* FatVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FatVolume::chdir(const char *path) {
    6d24:	push	{r4, r5, r6, lr}
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend FatFile;
  static FatVolume* cwv() {return m_cwv;}
  FatFile* vwd() {return &m_vwd;}
    6d26:	add.w	r4, r0, #1096	; 0x448
    6d2a:	sub	sp, #40	; 0x28
    6d2c:	movs	r3, #0
  FatFile dir;
  if (!dir.open(vwd(), path, O_RDONLY)) {
    6d2e:	mov	r2, r1
    6d30:	add	r0, sp, #4
    6d32:	mov	r1, r4
    6d34:	strb.w	r3, [sp, #4]
    6d38:	strb.w	r3, [sp, #5]
    6d3c:	strb.w	r3, [sp, #6]
    6d40:	bl	6280 <FatFile::open(FatFile*, char const*, int)>
    6d44:	mov	r6, r0
    6d46:	cbz	r0, 6d64 <FatVolume::chdir(char const*)+0x40>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!dir.isDir()) {
    6d48:	ldrb.w	r3, [sp, #4]
    6d4c:	ands.w	r3, r3, #112	; 0x70
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_vwd = dir;
    6d50:	itttt	ne
    6d52:	addne	r5, sp, #4
    6d54:	ldmiane	r5!, {r0, r1, r2, r3}
    6d56:	stmiane	r4!, {r0, r1, r2, r3}
    6d58:	ldmiane	r5!, {r0, r1, r2, r3}
    6d5a:	ittte	ne
    6d5c:	stmiane	r4!, {r0, r1, r2, r3}
    6d5e:	ldrne	r3, [r5, #0]
    6d60:	strne	r3, [r4, #0]
  return true;

 fail:
  return false;
    6d62:	moveq	r6, r3
}
    6d64:	mov	r0, r6
    6d66:	add	sp, #40	; 0x28
    6d68:	pop	{r4, r5, r6, pc}

00006d6a <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>:
  }
  DirFat_t* cacheDirEntry(uint8_t action);
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    6d6a:	subs	r1, r0, #1
    6d6c:	add.w	r2, r0, #10
    uint8_t sum = 0;
    6d70:	movs	r0, #0
    6d72:	lsls	r3, r0, #7
    6d74:	orr.w	r0, r3, r0, lsr #1
    for (uint8_t i = 0; i < 11; i++) {
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    6d78:	ldrb.w	r3, [r1, #1]!
    6d7c:	uxtab	r0, r3, r0
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    6d80:	cmp	r1, r2
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    6d82:	uxtb	r0, r0
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    6d84:	bne.n	6d72 <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]+0x8>
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    }
    return sum;
  }
    6d86:	bx	lr

00006d88 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)>:
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6d88:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  FatFile dir = *this;
    6d8c:	mov	r5, r0
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6d8e:	mov	r6, r2
    6d90:	mov	r7, r0
    6d92:	mov	r8, r1
    6d94:	mov	r9, r3
  FatFile dir = *this;
    6d96:	ldmia	r5!, {r0, r1, r2, r3}
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6d98:	sub	sp, #52	; 0x34
  FatFile dir = *this;
    6d9a:	add	r4, sp, #12
    6d9c:	stmia	r4!, {r0, r1, r2, r3}
    6d9e:	ldmia	r5!, {r0, r1, r2, r3}
    6da0:	stmia	r4!, {r0, r1, r2, r3}
    6da2:	ldr	r3, [r5, #0]
    6da4:	str	r3, [r4, #0]
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
  }
  void reset() {
    next = begin;
    6da6:	ldr	r3, [r6, #0]
    6da8:	str	r3, [r6, #4]
    ls = 0;
    6daa:	movs	r3, #0
    6dac:	strh	r3, [r6, #12]
  DirLfn_t* ldir;
  fname->reset();
  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6dae:	movs	r5, #1
    6db0:	cmp	r5, r9
    6db2:	bhi.n	6dee <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x66>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(index - order));
    6db4:	rsb	r1, r5, r8
    6db8:	uxth	r1, r1
    6dba:	add	r0, sp, #12
    6dbc:	bl	5a9c <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    6dc0:	mov	fp, r0
    6dc2:	cbnz	r0, 6dc8 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x40>
    }
  }
  return true;

 fail:
  return false;
    6dc4:	movs	r0, #0
    6dc6:	b.n	6e1e <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
    6dc8:	mov.w	sl, #0
    }
    // These should be checked in caller.
    DBG_HALT_IF(ldir->attributes != FAT_ATTRIB_LONG_NAME);
    DBG_HALT_IF(order != (ldir->order & 0X1F));
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t u = getLfnChar(ldir, i);
    6dcc:	uxtb.w	r2, sl
    6dd0:	mov	r1, fp
    6dd2:	mov	r0, r7
    6dd4:	bl	5ab6 <FatFile::getLfnChar(DirLfn_t*, unsigned char)>
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    6dd8:	ldrh	r3, [r6, #12]
    6dda:	mov	r4, r0
    6ddc:	cbnz	r3, 6df2 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x6a>
    6dde:	ldr	r2, [r6, #4]
    6de0:	ldr	r3, [r6, #8]
    6de2:	cmp	r2, r3
    6de4:	bne.n	6df2 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x6a>
      if (fname->atEnd()) {
        return u == 0;
    6de6:	clz	r0, r0
    6dea:	lsrs	r0, r0, #5
    6dec:	b.n	6e1e <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
        return false;
      }
#endif  // USE_UTF8_LONG_NAMES
    }
  }
  return true;
    6dee:	movs	r0, #1
    6df0:	b.n	6e1e <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
      uint16_t u = getLfnChar(ldir, i);
      if (fname->atEnd()) {
        return u == 0;
      }
#if USE_UTF8_LONG_NAMES
      uint16_t cp = fname->get16();
    6df2:	mov	r0, r6
    6df4:	bl	3914 <FsName::get16()>
    6df8:	str	r0, [sp, #4]
      // Make sure caller checked for valid UTF-8.
      DBG_HALT_IF(cp == 0XFFFF);
      if (toUpcase(u) != toUpcase(cp)) {
    6dfa:	mov	r0, r4
    6dfc:	bl	3870 <toUpcase(unsigned short)>
    6e00:	ldr	r3, [sp, #4]
    6e02:	mov	r4, r0
    6e04:	mov	r0, r3
    6e06:	bl	3870 <toUpcase(unsigned short)>
    6e0a:	cmp	r4, r0
    6e0c:	bne.n	6dc4 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x3c>
    6e0e:	add.w	sl, sl, #1
      goto fail;
    }
    // These should be checked in caller.
    DBG_HALT_IF(ldir->attributes != FAT_ATTRIB_LONG_NAME);
    DBG_HALT_IF(order != (ldir->order & 0X1F));
    for (uint8_t i = 0; i < 13; i++) {
    6e12:	cmp.w	sl, #13
    6e16:	bne.n	6dcc <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x44>
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
  FatFile dir = *this;
  DirLfn_t* ldir;
  fname->reset();
  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6e18:	adds	r5, #1
    6e1a:	uxtb	r5, r5
    6e1c:	b.n	6db0 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x28>
  }
  return true;

 fail:
  return false;
}
    6e1e:	add	sp, #52	; 0x34
    6e20:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00006e24 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)>:
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6e24:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  FatFile dir = *this;
    6e28:	mov	r5, r0

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6e2a:	mov	r6, r2
    6e2c:	mov	sl, r1
    6e2e:	mov	r7, r3
  FatFile dir = *this;
    6e30:	ldmia	r5!, {r0, r1, r2, r3}

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6e32:	sub	sp, #52	; 0x34
  FatFile dir = *this;
    6e34:	add	r4, sp, #12
    6e36:	stmia	r4!, {r0, r1, r2, r3}
    6e38:	ldmia	r5!, {r0, r1, r2, r3}
    6e3a:	stmia	r4!, {r0, r1, r2, r3}
    6e3c:	ldr	r3, [r5, #0]
    6e3e:	str	r3, [r4, #0]
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
    6e40:	add.w	r0, r6, #22
    6e44:	bl	6d6a <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>
  }
  void reset() {
    next = begin;
    ls = 0;
    6e48:	movs	r5, #0
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
  }
  void reset() {
    next = begin;
    6e4a:	ldr	r3, [r6, #0]
    6e4c:	str	r3, [r6, #4]
    6e4e:	mov	r9, r0
    ls = 0;
    6e50:	strh	r5, [r6, #12]
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6e52:	mov.w	fp, #1
      goto fail;
    }
    dir.m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    6e56:	mov	r8, r5
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6e58:	cmp	fp, r7
    6e5a:	bhi.n	6eaa <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x86>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(index - order));
    6e5c:	rsb	r1, fp, sl
    6e60:	uxth	r1, r1
    6e62:	add	r0, sp, #12
    6e64:	bl	5a9c <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    6e68:	cmp	r0, #0
    6e6a:	beq.n	6ef2 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xce>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dir.m_vol->cacheDirty();
    6e6c:	ldr	r2, [sp, #20]
    invalidate();
    return m_buffer;
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    6e6e:	ldrb.w	r3, [r2, #40]	; 0x28
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    6e72:	cmp	fp, r7
    6e74:	orr.w	r3, r3, #1
    6e78:	strb.w	r3, [r2, #40]	; 0x28
    6e7c:	ite	eq
    6e7e:	orreq.w	r3, fp, #64	; 0x40
    6e82:	movne	r3, fp
    6e84:	strb	r3, [r0, #0]
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    6e86:	mov.w	r3, #15
    6e8a:	strb	r3, [r0, #11]
    ldir->mustBeZero1 = 0;
    6e8c:	strb.w	r8, [r0, #12]
    ldir->checksum = checksum;
    6e90:	strb.w	r9, [r0, #13]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    6e94:	strh.w	r8, [r0, #26]
    6e98:	adds	r4, r0, #4
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
    6e9a:	movs	r1, #0
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    6e9c:	ldrh	r3, [r6, #12]
    6e9e:	cbnz	r3, 6eae <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x8a>
    6ea0:	ldr	r2, [r6, #4]
    6ea2:	ldr	r3, [r6, #8]
    6ea4:	cmp	r2, r3
    6ea6:	bne.n	6eae <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x8a>
    6ea8:	b.n	6ee0 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xbc>
        DBG_HALT_IF(cp == 0XFFFF);
      }
      putLfnChar(ldir, i, cp);
    }
  }
  return true;
    6eaa:	movs	r0, #1
    6eac:	b.n	6ef2 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xce>
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t cp;
      if (fname->atEnd()) {
        cp = fc++ ? 0XFFFF : 0;
      } else {
        cp = fname->get16();
    6eae:	mov	r0, r6
    6eb0:	str	r1, [sp, #4]
    6eb2:	bl	3914 <FsName::get16()>
    6eb6:	ldr	r1, [sp, #4]
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c The 16-bit character.
 */
static void putLfnChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    6eb8:	cmp	r1, #4
    6eba:	bhi.n	6ec2 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x9e>
    6ebc:	strh.w	r0, [r4, #-3]
    6ec0:	b.n	6eca <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xa6>
    setLe16(ldir->unicode1 + 2*i, c);
  } else if (i < 11) {
    6ec2:	cmp	r1, #10
    6ec4:	ite	ls
    6ec6:	strhls	r0, [r4, #0]
    6ec8:	strhhi	r0, [r4, #2]
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    ldir->checksum = checksum;
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
    6eca:	adds	r1, #1
    6ecc:	uxtb	r1, r1
    6ece:	cmp	r1, #13
    6ed0:	add.w	r4, r4, #2
    6ed4:	bne.n	6e9c <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x78>
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6ed6:	add.w	fp, fp, #1
    6eda:	uxtb.w	fp, fp
    6ede:	b.n	6e58 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x34>
    ldir->checksum = checksum;
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t cp;
      if (fname->atEnd()) {
        cp = fc++ ? 0XFFFF : 0;
    6ee0:	cbz	r5, 6eec <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xc8>
    6ee2:	adds	r5, #1
    6ee4:	uxtb	r5, r5
    6ee6:	movw	r0, #65535	; 0xffff
    6eea:	b.n	6eb8 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x94>
    6eec:	mov	r0, r5
    6eee:	movs	r5, #1
    6ef0:	b.n	6eb8 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x94>
  }
  return true;

 fail:
  return false;
}
    6ef2:	add	sp, #52	; 0x34
    6ef4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00006ef8 <FatFile::makeSFN(FatName_t*)>:
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
  const char* ptr = fname->begin;
    6ef8:	mov	r2, r0

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::makeSFN(FatName_t* fname) {
    6efa:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
  const char* ptr = fname->begin;
    6efe:	ldr.w	r3, [r2], #21
  uint8_t lc = 0;
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
    6f02:	ldr	r7, [r0, #8]
    6f04:	add.w	r1, r0, #32
  // Assume blanks removed from start and end.
  DBG_HALT_IF(*ptr == ' ' || *(end - 1) == ' ' || *(end - 1) == '.');

  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    fname->sfn[k] = ' ';
    6f08:	movs	r4, #32
    6f0a:	strb.w	r4, [r2, #1]!
  DBG_HALT_IF(end == ptr);
  // Assume blanks removed from start and end.
  DBG_HALT_IF(*ptr == ' ' || *(end - 1) == ' ' || *(end - 1) == '.');

  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    6f0e:	cmp	r1, r2
    6f10:	bne.n	6f0a <FatFile::makeSFN(FatName_t*)+0x12>
    fname->sfn[k] = ' ';
  }
  // Not 8.3 if starts with dot.
  is83 = *ptr == '.' ? false : true;
    6f12:	ldrb	r6, [r3, #0]
    6f14:	subs	r6, #46	; 0x2e
    6f16:	it	ne
    6f18:	movne	r6, #1
    6f1a:	mov	r5, r3
    6f1c:	adds	r3, #1
  // Skip leading dots.
  for (; *ptr == '.'; ptr++) {}
    6f1e:	ldrb	r2, [r5, #0]
    6f20:	cmp	r2, #46	; 0x2e
    6f22:	beq.n	6f1a <FatFile::makeSFN(FatName_t*)+0x22>
    6f24:	subs	r3, r7, #1
  // Find last dot.
  for (dot = end - 1; dot > ptr && *dot != '.'; dot--) {}
    6f26:	cmp	r3, r5
    6f28:	mov	lr, r3
    6f2a:	bhi.n	6f3c <FatFile::makeSFN(FatName_t*)+0x44>
    6f2c:	movs	r2, #0
    6f2e:	mov.w	ip, #7
    6f32:	mov	r1, r2
    6f34:	mov	r8, r2
    6f36:	mov.w	r9, #8
    6f3a:	b.n	6f60 <FatFile::makeSFN(FatName_t*)+0x68>
    6f3c:	ldrb.w	r2, [lr]
    6f40:	cmp	r2, #46	; 0x2e
    6f42:	add.w	r3, r3, #4294967295
    6f46:	bne.n	6f26 <FatFile::makeSFN(FatName_t*)+0x2e>
    6f48:	b.n	6f2c <FatFile::makeSFN(FatName_t*)+0x34>

  for (; ptr < end; ptr++) {
    c = *ptr;
    6f4a:	ldrb	r3, [r5, #0]
//  Could skip UTF-8 units where (0XC0 & c) == 0X80

    if (c == '.' && ptr == dot) {
    6f4c:	cmp	r3, #46	; 0x2e
    6f4e:	bne.n	6f66 <FatFile::makeSFN(FatName_t*)+0x6e>
    6f50:	cmp	lr, r5
    6f52:	bne.n	6f6e <FatFile::makeSFN(FatName_t*)+0x76>
      in = 10;  // Max index for full 8.3 name.
    6f54:	mov.w	ip, #10
      i = 8;    // Place for extension.
    6f58:	movs	r1, #8
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    6f5a:	mov.w	r9, #16
  // Skip leading dots.
  for (; *ptr == '.'; ptr++) {}
  // Find last dot.
  for (dot = end - 1; dot > ptr && *dot != '.'; dot--) {}

  for (; ptr < end; ptr++) {
    6f5e:	adds	r5, #1
    6f60:	cmp	r5, r7
    6f62:	bcc.n	6f4a <FatFile::makeSFN(FatName_t*)+0x52>
    6f64:	b.n	6ff0 <FatFile::makeSFN(FatName_t*)+0xf8>
  /** Check for a legal 8.3 character.
   * \param[in] c Character to be checked.
   * \return true for a legal 8.3 character.
   */
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
    6f66:	cmp	r3, #34	; 0x22
    6f68:	beq.n	6f92 <FatFile::makeSFN(FatName_t*)+0x9a>
    6f6a:	cmp	r3, #124	; 0x7c
    6f6c:	beq.n	6f92 <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
    6f6e:	sub.w	r4, r3, #42	; 0x2a
    6f72:	cmp	r4, #5
    6f74:	bhi.n	6f7a <FatFile::makeSFN(FatName_t*)+0x82>
    6f76:	cmp	r3, #45	; 0x2d
    6f78:	bne.n	6f92 <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // :;<=>?
    if (0X3A <= c && c <= 0X3F) {
    6f7a:	sub.w	r4, r3, #58	; 0x3a
    6f7e:	cmp	r4, #5
    6f80:	bls.n	6f92 <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // [\]
    if (0X5B <= c && c <= 0X5D) {
    6f82:	sub.w	r4, r3, #91	; 0x5b
    6f86:	cmp	r4, #2
    6f88:	bls.n	6f92 <FatFile::makeSFN(FatName_t*)+0x9a>
    if (c == '.' && ptr == dot) {
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
    6f8a:	sub.w	r4, r3, #33	; 0x21
    6f8e:	cmp	r4, #93	; 0x5d
    6f90:	bls.n	6f9c <FatFile::makeSFN(FatName_t*)+0xa4>
        is83 = false;
        // Skip UTF-8 trailing characters.
        if ((c & 0XC0) == 0X80) {
    6f92:	and.w	r3, r3, #192	; 0xc0
    6f96:	cmp	r3, #128	; 0x80
    6f98:	bne.n	6fc2 <FatFile::makeSFN(FatName_t*)+0xca>
    6f9a:	b.n	6fe6 <FatFile::makeSFN(FatName_t*)+0xee>
          continue;
        }
        c = '_';
      }
      if (i > in) {
    6f9c:	cmp	r1, ip
    6f9e:	bls.n	6fb0 <FatFile::makeSFN(FatName_t*)+0xb8>
        is83 = false;
        if (in == 10 || ptr > dot) {
    6fa0:	cmp.w	ip, #10
    6fa4:	beq.n	6fee <FatFile::makeSFN(FatName_t*)+0xf6>
    6fa6:	cmp	lr, r5
    6fa8:	bcc.n	6fee <FatFile::makeSFN(FatName_t*)+0xf6>
         // Done - extension longer than three characters or no extension.
          break;
        }
        // Skip to dot.
        ptr = dot - 1;
    6faa:	add.w	r5, lr, #4294967295
    6fae:	b.n	6fe6 <FatFile::makeSFN(FatName_t*)+0xee>
        continue;
      }
      if (isLower(c)) {
    6fb0:	sub.w	r4, r3, #97	; 0x61
    6fb4:	cmp	r4, #25
    6fb6:	bhi.n	6fca <FatFile::makeSFN(FatName_t*)+0xd2>
        c += 'A' - 'a';
    6fb8:	subs	r3, #32
    6fba:	uxtb	r3, r3
        lc |= bit;
    6fbc:	orr.w	r2, r9, r2
    6fc0:	b.n	6fd6 <FatFile::makeSFN(FatName_t*)+0xde>
        if ((c & 0XC0) == 0X80) {
          continue;
        }
        c = '_';
      }
      if (i > in) {
    6fc2:	cmp	r1, ip
    6fc4:	bhi.n	6fa0 <FatFile::makeSFN(FatName_t*)+0xa8>
        is83 = false;
        // Skip UTF-8 trailing characters.
        if ((c & 0XC0) == 0X80) {
          continue;
        }
        c = '_';
    6fc6:	movs	r3, #95	; 0x5f
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
        is83 = false;
    6fc8:	movs	r6, #0
        continue;
      }
      if (isLower(c)) {
        c += 'A' - 'a';
        lc |= bit;
      } else if (isUpper(c)) {
    6fca:	sub.w	r4, r3, #65	; 0x41
    6fce:	cmp	r4, #25
        uc |= bit;
    6fd0:	it	ls
    6fd2:	orrls.w	r8, r9, r8
      }
      fname->sfn[i++] = c;
    6fd6:	adds	r4, r1, #1
    6fd8:	uxtb	r4, r4
    6fda:	add	r1, r0
      if (i < 7) {
    6fdc:	cmp	r4, #6
        c += 'A' - 'a';
        lc |= bit;
      } else if (isUpper(c)) {
        uc |= bit;
      }
      fname->sfn[i++] = c;
    6fde:	strb	r3, [r1, #22]
      if (i < 7) {
    6fe0:	bhi.n	6fea <FatFile::makeSFN(FatName_t*)+0xf2>
        fname->seqPos = i;
    6fe2:	strb	r4, [r0, #20]
    6fe4:	b.n	6fea <FatFile::makeSFN(FatName_t*)+0xf2>
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
        is83 = false;
    6fe6:	movs	r6, #0
    6fe8:	b.n	6f5e <FatFile::makeSFN(FatName_t*)+0x66>
    6fea:	mov	r1, r4
    6fec:	b.n	6f5e <FatFile::makeSFN(FatName_t*)+0x66>
          continue;
        }
        c = '_';
      }
      if (i > in) {
        is83 = false;
    6fee:	movs	r6, #0
      if (i < 7) {
        fname->seqPos = i;
      }
    }
  }
  if (fname->sfn[0] == ' ') {
    6ff0:	ldrb	r3, [r0, #22]
    6ff2:	cmp	r3, #32
    6ff4:	beq.n	701a <FatFile::makeSFN(FatName_t*)+0x122>
    DBG_HALT_MACRO;
    goto fail;
  }
  if (is83) {
    6ff6:	cbz	r6, 7008 <FatFile::makeSFN(FatName_t*)+0x110>
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
    6ff8:	tst.w	r8, r2
    6ffc:	it	ne
    6ffe:	movne	r2, #2
    7000:	strb	r2, [r0, #21]
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
    7002:	movs	r0, #1
    7004:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  }
  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    7008:	ldrb	r2, [r0, #20]
    goto fail;
  }
  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    700a:	movs	r3, #1
    700c:	strb	r3, [r0, #21]
    fname->sfn[fname->seqPos] = '~';
    700e:	add	r0, r2
    7010:	movs	r2, #126	; 0x7e
    7012:	strb	r2, [r0, #22]
    fname->sfn[fname->seqPos + 1] = '1';
    7014:	movs	r2, #49	; 0x31
    7016:	strb	r2, [r0, #23]
    7018:	b.n	7002 <FatFile::makeSFN(FatName_t*)+0x10a>
  }
  return true;

 fail:
  return false;
    701a:	movs	r0, #0
    701c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00007020 <FatFile::makeUniqueSfn(FatName_t*)>:
}
//------------------------------------------------------------------------------
bool FatFile::makeUniqueSfn(FatName_t* fname) {
    7020:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;
    7024:	ldrb	r5, [r1, #20]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::makeUniqueSfn(FatName_t* fname) {
    7026:	mov	r7, r0
    7028:	mov	r6, r1
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;
    702a:	movs	r4, #98	; 0x62
    for (uint8_t i = pos + 4 ; i > pos; i--) {
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
      hex >>= 4;
    }
    fname->sfn[pos] = '~';
    702c:	mov.w	r8, #126	; 0x7e
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    7030:	add.w	r9, r1, #22
  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
     DBG_WARN_IF(seq > FIRST_HASH_SEQ);
#ifdef USE_LFN_HASH
    hex = Bernstein(fname->begin, fname->end, seq);
#else
    hex = micros();
    7034:	bl	94d0 <micros>
    7038:	cmp	r5, #3
    703a:	it	cs
    703c:	movcs	r5, #3
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    703e:	adds	r3, r5, #4
  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
     DBG_WARN_IF(seq > FIRST_HASH_SEQ);
#ifdef USE_LFN_HASH
    hex = Bernstein(fname->begin, fname->end, seq);
#else
    hex = micros();
    7040:	uxth	r0, r0
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    7042:	uxtb	r3, r3
      uint8_t h = hex & 0XF;
    7044:	and.w	r2, r0, #15
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    7048:	adds	r1, r6, r3
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    704a:	subs	r3, #1
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    704c:	cmp	r2, #9
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    704e:	uxtb	r3, r3
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    7050:	ite	ls
    7052:	addls	r2, #48	; 0x30
    7054:	addhi	r2, #55	; 0x37
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    7056:	cmp	r5, r3
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    7058:	strb	r2, [r1, #22]
      hex >>= 4;
    705a:	mov.w	r0, r0, lsr #4
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    705e:	bcc.n	7044 <FatFile::makeUniqueSfn(FatName_t*)+0x24>
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
      hex >>= 4;
    }
    fname->sfn[pos] = '~';
    7060:	adds	r3, r6, r5
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    7062:	movs	r1, #0
    7064:	strb.w	r8, [r3, #22]
    7068:	mov	r0, r7
    706a:	bl	5f9a <FatFile::seekSet(unsigned long)>
    rewind();
    while (1) {
      dir = readDirCache(true);
    706e:	movs	r1, #1
    7070:	mov	r0, r7
    7072:	bl	5f60 <FatFile::readDirCache(bool)>
      if (!dir) {
    7076:	mov	r1, r0
    7078:	cbnz	r0, 7086 <FatFile::makeUniqueSfn(FatName_t*)+0x66>
        if (!getError()) {
    707a:	ldrb	r0, [r7, #1]
    707c:	clz	r0, r0
    7080:	lsrs	r0, r0, #5
    7082:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    7086:	ldrb	r3, [r0, #0]
    7088:	cbz	r3, 709e <FatFile::makeUniqueSfn(FatName_t*)+0x7e>
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    708a:	ldrb	r3, [r0, #11]
    708c:	lsls	r3, r3, #28
    708e:	bmi.n	706e <FatFile::makeUniqueSfn(FatName_t*)+0x4e>
    7090:	movs	r2, #11
    7092:	mov	r0, r9
    7094:	bl	b930 <memcmp>
    7098:	cmp	r0, #0
    709a:	bne.n	706e <FatFile::makeUniqueSfn(FatName_t*)+0x4e>
    709c:	b.n	70a4 <FatFile::makeUniqueSfn(FatName_t*)+0x84>

 fail:
  return false;

 done:
  return true;
    709e:	movs	r0, #1
    70a0:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    70a4:	subs	r0, r4, #1
  uint16_t hex;

  DBG_HALT_IF(!(fname->flags & FNAME_FLAG_LOST_CHARS));
  DBG_HALT_IF(fname->sfn[pos] != '~' && fname->sfn[pos + 1] != '1');

  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
    70a6:	ands.w	r4, r0, #255	; 0xff
    70aa:	bne.n	7034 <FatFile::makeUniqueSfn(FatName_t*)+0x14>
  }
  // fall inti fail - too many tries.
  DBG_FAIL_MACRO;

 fail:
  return false;
    70ac:	mov	r0, r4
    70ae:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    70b2:	Address 0x000070b2 is out of bounds.


000070b4 <FatFile::open(FatFile*, FatName_t*, int)>:

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    70b4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    70b8:	sub	sp, #44	; 0x2c
    70ba:	mov	r6, r1
    70bc:	str	r3, [sp, #12]
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    70be:	ldrb	r3, [r1, #0]

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    70c0:	str	r0, [sp, #24]
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    70c2:	tst.w	r3, #112	; 0x70

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    70c6:	mov	sl, r2
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    70c8:	bne.n	70ce <FatFile::open(FatFile*, FatName_t*, int)+0x1a>
    goto fail;
  }
  return true;

 fail:
  return false;
    70ca:	movs	r0, #0
    70cc:	b.n	72f8 <FatFile::open(FatFile*, FatName_t*, int)+0x244>
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    70ce:	ldr	r3, [sp, #24]
    70d0:	ldrb	r3, [r3, #0]
    70d2:	cmp	r3, #0
    70d4:	bne.n	70ca <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
    70d6:	ldr	r3, [r2, #16]
    70d8:	movs	r2, #13
    70da:	adds	r3, #12
    70dc:	udiv	r3, r3, r2
    70e0:	uxtb	r3, r3
    70e2:	str	r3, [sp, #8]
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
    70e4:	ldrb.w	r3, [sl, #21]
    70e8:	lsls	r3, r3, #30
    70ea:	beq.w	72f2 <FatFile::open(FatFile*, FatName_t*, int)+0x23e>
    70ee:	ldr	r3, [sp, #8]
    70f0:	add.w	fp, r3, #1
    70f4:	uxtb.w	fp, fp
    70f8:	movs	r1, #0
    70fa:	mov	r0, r6
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
  uint8_t ms10;
  uint8_t nameOrd;
  uint16_t freeIndex = 0;
    70fc:	mov.w	r9, #0
    7100:	bl	5f9a <FatFile::seekSet(unsigned long)>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    7104:	add.w	r3, sl, #22
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
    7108:	str.w	r9, [sp, #16]
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
    710c:	mov	r8, r9
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
    710e:	mov	r4, r9
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
    7110:	mov	r5, r9
 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
    7112:	str.w	r9, [sp, #20]
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    7116:	str	r3, [sp, #28]
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    7118:	ldr	r7, [r6, #20]
    dir = dirFile->readDirCache();
    711a:	movs	r1, #0
    711c:	mov	r0, r6
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    711e:	ubfx	r7, r7, #5, #16
    dir = dirFile->readDirCache();
    7122:	bl	5f60 <FatFile::readDirCache(bool)>
    if (!dir) {
    7126:	cbnz	r0, 7130 <FatFile::open(FatFile*, FatName_t*, int)+0x7c>
      if (dirFile->getError()) {
    7128:	ldrb	r3, [r6, #1]
    712a:	cmp	r3, #0
    712c:	beq.n	71f0 <FatFile::open(FatFile*, FatName_t*, int)+0x13c>
    712e:	b.n	70ca <FatFile::open(FatFile*, FatName_t*, int)+0x16>
        goto fail;
      }
      // At EOF
      goto create;
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
    7130:	ldrb	r3, [r0, #0]
    7132:	cmp	r3, #229	; 0xe5
    7134:	beq.n	7138 <FatFile::open(FatFile*, FatName_t*, int)+0x84>
    7136:	cbnz	r3, 714a <FatFile::open(FatFile*, FatName_t*, int)+0x96>
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    7138:	cmp	r4, #0
    713a:	it	eq
    713c:	moveq	r9, r7
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
      if (freeFound == 0) {
        freeIndex = curIndex;
      }
      if (freeFound < freeNeed) {
    713e:	cmp	r4, fp
        freeFound++;
    7140:	itt	cc
    7142:	addcc	r4, #1
    7144:	uxtbcc	r4, r4
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    7146:	cbnz	r3, 7152 <FatFile::open(FatFile*, FatName_t*, int)+0x9e>
    7148:	b.n	71f0 <FatFile::open(FatFile*, FatName_t*, int)+0x13c>
        goto create;
      }
    } else {
      if (freeFound < freeNeed) {
        freeFound = 0;
    714a:	cmp	r4, fp
    714c:	it	cc
    714e:	movcc	r4, #0
    7150:	b.n	715a <FatFile::open(FatFile*, FatName_t*, int)+0xa6>
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    7152:	cmp	r3, #229	; 0xe5
    7154:	bne.n	715a <FatFile::open(FatFile*, FatName_t*, int)+0xa6>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    7156:	movs	r5, #0
    7158:	b.n	7118 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
      if (freeFound < freeNeed) {
        freeFound = 0;
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    715a:	cmp	r3, #46	; 0x2e
    715c:	beq.n	7156 <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
    715e:	ldrb	r2, [r0, #11]
      lfnOrd = 0;
    } else if (isLongName(dir)) {
    7160:	cmp	r2, #15
    7162:	bne.n	71b4 <FatFile::open(FatFile*, FatName_t*, int)+0x100>
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
    7164:	cbnz	r5, 7184 <FatFile::open(FatFile*, FatName_t*, int)+0xd0>
        order = ldir->order & 0X1F;
        if (order != nameOrd ||
    7166:	ldr	r2, [sp, #8]
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
      lfnOrd = 0;
    } else if (isLongName(dir)) {
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
        order = ldir->order & 0X1F;
    7168:	and.w	r8, r3, #31
        if (order != nameOrd ||
    716c:	cmp	r2, r8
    716e:	bne.n	7118 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
    7170:	lsls	r1, r3, #25
    7172:	bmi.n	717a <FatFile::open(FatFile*, FatName_t*, int)+0xc6>
    7174:	ldr.w	r8, [sp, #8]
    7178:	b.n	7118 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
          (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = nameOrd;
        checksum = ldir->checksum;
    717a:	ldrb	r3, [r0, #13]
    717c:	str	r3, [sp, #16]
    717e:	mov	r8, r2
    7180:	mov	r5, r2
    7182:	b.n	7198 <FatFile::open(FatFile*, FatName_t*, int)+0xe4>
      } else if (ldir->order != --order || checksum != ldir->checksum) {
    7184:	add.w	r8, r8, #4294967295
    7188:	uxtb.w	r8, r8
    718c:	cmp	r3, r8
    718e:	bne.n	7156 <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
    7190:	ldrb	r3, [r0, #13]
    7192:	ldr	r2, [sp, #16]
    7194:	cmp	r2, r3
    7196:	bne.n	7156 <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
        lfnOrd = 0;
        continue;
      }
      if (order == 1) {
    7198:	cmp.w	r8, #1
    719c:	bne.n	7118 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        if (!dirFile->cmpName(curIndex + 1, fname, lfnOrd)) {
    719e:	adds	r1, r7, #1
    71a0:	mov	r3, r5
    71a2:	mov	r2, sl
    71a4:	uxth	r1, r1
    71a6:	mov	r0, r6
    71a8:	bl	6d88 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)>
          lfnOrd = 0;
    71ac:	cmp	r0, #0
    71ae:	it	eq
    71b0:	moveq	r5, #0
    71b2:	b.n	7118 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        }
      }
    } else if (isFileOrSubdir(dir)) {
    71b4:	lsls	r3, r2, #28
    71b6:	bmi.n	7156 <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
      if (lfnOrd) {
    71b8:	cbz	r5, 71ce <FatFile::open(FatFile*, FatName_t*, int)+0x11a>
        if (1 == order && lfnChecksum(dir->name) == checksum) {
    71ba:	cmp.w	r8, #1
    71be:	bne.n	70ca <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    71c0:	bl	6d6a <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>
    71c4:	ldr	r3, [sp, #16]
    71c6:	cmp	r3, r0
    71c8:	bne.w	70ca <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    71cc:	b.n	71e8 <FatFile::open(FatFile*, FatName_t*, int)+0x134>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    71ce:	movs	r2, #11
    71d0:	ldr	r1, [sp, #28]
    71d2:	bl	b930 <memcmp>
    71d6:	cmp	r0, #0
    71d8:	bne.n	7118 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        if (!(fname->flags & FNAME_FLAG_LOST_CHARS)) {
    71da:	ldrb.w	r3, [sl, #21]
    71de:	lsls	r0, r3, #31
    71e0:	bpl.n	71e8 <FatFile::open(FatFile*, FatName_t*, int)+0x134>
          goto found;
        }
        fnameFound = true;
    71e2:	movs	r3, #1
    71e4:	str	r3, [sp, #20]
    71e6:	b.n	7118 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    71e8:	ldr	r3, [sp, #12]
    71ea:	lsls	r1, r3, #20
    71ec:	bpl.n	72e2 <FatFile::open(FatFile*, FatName_t*, int)+0x22e>
    71ee:	b.n	70ca <FatFile::open(FatFile*, FatName_t*, int)+0x16>
  }
  goto open;

 create:
  // don't create unless O_CREAT and write mode
  if (!(oflag & O_CREAT) || !isWriteMode(oflag)) {
    71f0:	ldr	r3, [sp, #12]
    71f2:	lsls	r2, r3, #22
    71f4:	bpl.w	70ca <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    71f8:	and.w	r3, r3, #3
    71fc:	subs	r3, #1
    71fe:	cmp	r3, #1
    7200:	bhi.w	70ca <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_WARN_MACRO;
    goto fail;
  }
  // Keep found entries or start at current index if no free entries found.
  if (freeFound == 0) {
    7204:	cmp	r4, #0
    7206:	it	eq
    7208:	moveq	r9, r7
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    720a:	cmp	r4, fp
    720c:	bcc.n	7214 <FatFile::open(FatFile*, FatName_t*, int)+0x160>
      DBG_FAIL_MACRO;
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
  }
  if (fnameFound) {
    720e:	ldr	r3, [sp, #20]
    7210:	cbnz	r3, 7242 <FatFile::open(FatFile*, FatName_t*, int)+0x18e>
    7212:	b.n	7250 <FatFile::open(FatFile*, FatName_t*, int)+0x19c>
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    dir = dirFile->readDirCache();
    7214:	movs	r1, #0
    7216:	mov	r0, r6
    7218:	bl	5f60 <FatFile::readDirCache(bool)>
    if (!dir) {
    721c:	cbnz	r0, 7224 <FatFile::open(FatFile*, FatName_t*, int)+0x170>
      if (dirFile->getError()) {
    721e:	ldrb	r3, [r6, #1]
    7220:	cbz	r3, 7236 <FatFile::open(FatFile*, FatName_t*, int)+0x182>
    7222:	b.n	70ca <FatFile::open(FatFile*, FatName_t*, int)+0x16>
        goto fail;
      }
      // EOF if no error.
      break;
    }
    freeFound++;
    7224:	adds	r4, #1
    7226:	uxtb	r4, r4
  // Keep found entries or start at current index if no free entries found.
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    7228:	b.n	720a <FatFile::open(FatFile*, FatName_t*, int)+0x156>
    722a:	ldr	r3, [r6, #8]
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
    722c:	ldrb	r3, [r3, #4]
    722e:	add	r4, r3
    7230:	uxtb	r4, r4
      // EOF if no error.
      break;
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
    7232:	cmp	fp, r4
    7234:	bls.n	720e <FatFile::open(FatFile*, FatName_t*, int)+0x15a>
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
    7236:	mov	r0, r6
    7238:	bl	5cb8 <FatFile::addDirCluster()>
    723c:	cmp	r0, #0
    723e:	bne.n	722a <FatFile::open(FatFile*, FatName_t*, int)+0x176>
    7240:	b.n	70ca <FatFile::open(FatFile*, FatName_t*, int)+0x16>
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
  }
  if (fnameFound) {
    if (!dirFile->makeUniqueSfn(fname)) {
    7242:	mov	r1, sl
    7244:	mov	r0, r6
    7246:	bl	7020 <FatFile::makeUniqueSfn(FatName_t*)>
    724a:	cmp	r0, #0
    724c:	beq.w	70ca <FatFile::open(FatFile*, FatName_t*, int)+0x16>
      goto fail;
    }
  }
  lfnOrd = freeNeed - 1;
    7250:	add.w	r5, fp, #4294967295
    7254:	uxtb	r5, r5
  curIndex = freeIndex + lfnOrd;
    7256:	add.w	r7, r9, r5
    725a:	uxth	r7, r7
  if (!dirFile->createLFN(curIndex, fname, lfnOrd)) {
    725c:	mov	r3, r5
    725e:	mov	r2, sl
    7260:	mov	r1, r7
    7262:	mov	r0, r6
    7264:	bl	6e24 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)>
    7268:	cmp	r0, #0
    726a:	beq.w	70ca <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    goto fail;
  }
  dir = dirFile->cacheDir(curIndex);
    726e:	mov	r1, r7
    7270:	mov	r0, r6
    7272:	bl	5a9c <FatFile::cacheDir(unsigned short)>
  if (!dir) {
    7276:	mov	r4, r0
    7278:	cmp	r0, #0
    727a:	beq.w	70ca <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
    727e:	movs	r2, #32
    7280:	movs	r1, #0
    7282:	bl	9078 <memset>
  memcpy(dir->name, fname->sfn, 11);
    7286:	mov	r3, sl
    7288:	ldr.w	r2, [r3, #22]!
    728c:	str	r2, [r4, #0]
    728e:	ldr	r2, [r3, #4]
    7290:	str	r2, [r4, #4]
    7292:	ldrh	r2, [r3, #8]
    7294:	strh	r2, [r4, #8]
    7296:	ldrb	r3, [r3, #10]
    7298:	strb	r3, [r4, #10]

  // Set base-name and extension lower case bits.
  dir->caseFlags = (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;
    729a:	ldrb.w	r3, [sl, #21]
    729e:	and.w	r3, r3, #24
    72a2:	strb	r3, [r4, #12]

  // Set timestamps.
  if (FsDateTime::callback) {
    72a4:	ldr	r3, [pc, #88]	; (7300 <FatFile::open(FatFile*, FatName_t*, int)+0x24c>)
    72a6:	ldr	r3, [r3, #0]
    72a8:	cbz	r3, 72ca <FatFile::open(FatFile*, FatName_t*, int)+0x216>
    // call user date/time function
    FsDateTime::callback(&date, &time, &ms10);
    72aa:	add.w	r2, sp, #35	; 0x23
    72ae:	add.w	r1, sp, #38	; 0x26
    72b2:	add	r0, sp, #36	; 0x24
    72b4:	blx	r3
    72b6:	ldrh.w	r3, [sp, #36]	; 0x24
    72ba:	strh	r3, [r4, #16]
    72bc:	ldrh.w	r3, [sp, #38]	; 0x26
    72c0:	strh	r3, [r4, #14]
    setLe16(dir->createDate, date);
    setLe16(dir->createTime, time);
    dir->createTimeMs = ms10;
    72c2:	ldrb.w	r3, [sp, #35]	; 0x23
    72c6:	strb	r3, [r4, #13]
    72c8:	b.n	72d4 <FatFile::open(FatFile*, FatName_t*, int)+0x220>
    72ca:	movw	r3, #21537	; 0x5421
    72ce:	strh	r3, [r4, #16]
    72d0:	strh	r3, [r4, #24]
    72d2:	strh	r3, [r4, #18]
      setLe16(dir->createTime, FS_DEFAULT_TIME);
      setLe16(dir->modifyTime, FS_DEFAULT_TIME);
    }
  }
  // Force write of entry to device.
  dirFile->m_vol->cacheDirty();
    72d4:	ldr	r2, [r6, #8]
    72d6:	ldrb.w	r3, [r2, #40]	; 0x28
    72da:	orr.w	r3, r3, #1
    72de:	strb.w	r3, [r2, #40]	; 0x28

 open:
  // open entry in cache.
  if (!openCachedEntry(dirFile, curIndex, oflag, lfnOrd)) {
    72e2:	str	r5, [sp, #0]
    72e4:	ldr	r3, [sp, #12]
    72e6:	ldr	r0, [sp, #24]
    72e8:	mov	r2, r7
    72ea:	mov	r1, r6
    72ec:	bl	6046 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    72f0:	b.n	72f8 <FatFile::open(FatFile*, FatName_t*, int)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
    72f2:	mov.w	fp, #1
    72f6:	b.n	70f8 <FatFile::open(FatFile*, FatName_t*, int)+0x44>
  }
  return true;

 fail:
  return false;
}
    72f8:	add	sp, #44	; 0x2c
    72fa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    72fe:	nop
    7300:	.word	0x2001ceb4

00007304 <FatFile::parsePathName(char const*, FatName_t*, char const**)>:
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            FatName_t* fname, const char** ptr) {
    7304:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    7306:	mov	r4, r2
    7308:	mov	r6, r3
    730a:	mov	r0, r1
    730c:	adds	r1, #1
  size_t len = 0;
  // Skip leading spaces.
  while (*path == ' ') {
    730e:	ldrb	r3, [r0, #0]
    7310:	cmp	r3, #32
    7312:	beq.n	730a <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    7314:	ldr	r7, [pc, #128]	; (7398 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x94>)
    path++;
  }
  fname->begin = path;
    7316:	str	r0, [r4, #0]
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            FatName_t* fname, const char** ptr) {
  size_t len = 0;
    7318:	movs	r5, #0
  // Skip leading spaces.
  while (*path == ' ') {
    path++;
  }
  fname->begin = path;
  while (*path && !isDirSeparator(*path)) {
    731a:	ldrb	r3, [r0, #0]
    731c:	cbz	r3, 7370 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6c>
    731e:	cmp	r3, #47	; 0x2f
    7320:	beq.n	7370 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6c>
#if USE_UTF8_LONG_NAMES
    uint32_t cp;
    // Allow end = path + 4 since path is zero terminated.
    path = FsUtf::mbToCp(path, path + 4, &cp);
    7322:	add	r2, sp, #4
    7324:	adds	r1, r0, #4
    7326:	bl	3514 <FsUtf::mbToCp(char const*, char const*, unsigned long*)>
    if (!path) {
    732a:	cbz	r0, 7390 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    len += cp <= 0XFFFF ? 1 : 2;
    732c:	ldr	r2, [sp, #4]
    732e:	cmp.w	r2, #65536	; 0x10000
    7332:	ite	cs
    7334:	movcs	r3, #2
    7336:	movcc	r3, #1
    if (cp < 0X80 && lfnReservedChar(cp)) {
    7338:	cmp	r2, #127	; 0x7f
    path = FsUtf::mbToCp(path, path + 4, &cp);
    if (!path) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    len += cp <= 0XFFFF ? 1 : 2;
    733a:	add	r5, r3
    if (cp < 0X80 && lfnReservedChar(cp)) {
    733c:	bhi.n	7366 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x62>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    733e:	cmp	r2, #31
    7340:	bls.n	7390 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    7342:	uxtb	r3, r2
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    7344:	sub.w	r1, r3, #34	; 0x22
    7348:	uxtb	r1, r1
    734a:	cmp	r1, #29
    734c:	bhi.n	7356 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x52>
    734e:	lsr.w	r1, r7, r1
    7352:	lsls	r1, r1, #31
    7354:	bmi.n	7390 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    7356:	and.w	r3, r3, #191	; 0xbf
    735a:	cmp	r3, #60	; 0x3c
    735c:	beq.n	7390 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    735e:	cmp	r2, #92	; 0x5c
    7360:	beq.n	7390 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    len++;
#endif  // USE_UTF8_LONG_NAMES
    if (cp != '.' && cp != ' ') {
    7362:	cmp	r2, #46	; 0x2e
    7364:	beq.n	731a <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
    7366:	cmp	r2, #32
    7368:	beq.n	731a <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
      // Need to trim trailing dots spaces.
      fname->len = len;
    736a:	str	r5, [r4, #16]
      fname->end = path;
    736c:	str	r0, [r4, #8]
  // Skip leading spaces.
  while (*path == ' ') {
    path++;
  }
  fname->begin = path;
  while (*path && !isDirSeparator(*path)) {
    736e:	b.n	731a <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
      // Need to trim trailing dots spaces.
      fname->len = len;
      fname->end = path;
    }
  }
  if (!fname->len || fname->len > FAT_MAX_LFN_LENGTH) {
    7370:	ldr	r3, [r4, #16]
    7372:	subs	r3, #1
    7374:	cmp	r3, #254	; 0xfe
    7376:	bhi.n	7390 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    7378:	mov	r2, r0
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
    737a:	ldrb.w	r3, [r0], #1
    737e:	cmp	r3, #32
    7380:	beq.n	7378 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x74>
    7382:	cmp	r3, #47	; 0x2f
    7384:	beq.n	7378 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x74>
  *ptr = path;
    7386:	str	r2, [r6, #0]
  return makeSFN(fname);
    7388:	mov	r0, r4
    738a:	bl	6ef8 <FatFile::makeSFN(FatName_t*)>
    738e:	b.n	7392 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8e>

 fail:
  return false;
    7390:	movs	r0, #0
}
    7392:	add	sp, #12
    7394:	pop	{r4, r5, r6, r7, pc}
    7396:	nop
    7398:	.word	0x31002101

0000739c <FatFile::remove()>:
//------------------------------------------------------------------------------
bool FatFile::remove() {
    739c:	push	{r4, r5, r6, r7, lr}
    739e:	sub	sp, #44	; 0x2c
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    73a0:	movs	r3, #0
    73a2:	strb.w	r3, [sp, #4]
    73a6:	strb.w	r3, [sp, #5]
    73aa:	strb.w	r3, [sp, #6]
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    73ae:	ldrb	r3, [r0, #2]
    73b0:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::remove() {
    73b2:	mov	r4, r0
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    73b4:	bpl.n	73e6 <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
    73b6:	ldr	r1, [r0, #32]
    73b8:	cbz	r1, 73c2 <FatFile::remove()+0x26>
    73ba:	ldr	r0, [r0, #8]
    73bc:	bl	6b7a <FatPartition::freeChain(unsigned long)>
    73c0:	cbz	r0, 73e6 <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Cache directory entry.
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    73c2:	movs	r1, #1
    73c4:	mov	r0, r4
    73c6:	bl	5d44 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    73ca:	mov	r5, r0
    73cc:	cbz	r0, 73e6 <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  checksum = lfnChecksum(dir->name);
    73ce:	bl	6d6a <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;
    73d2:	movs	r6, #229	; 0xe5
    73d4:	strb	r6, [r5, #0]

  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    73d6:	movs	r3, #0
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  checksum = lfnChecksum(dir->name);
    73d8:	mov	r7, r0

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;

  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    73da:	strb	r3, [r4, #0]
  m_flags = 0;
    73dc:	strb	r3, [r4, #2]

  // Write entry to device.
  if (!m_vol->cacheSync()) {
    73de:	ldr	r0, [r4, #8]
    73e0:	bl	5c5c <FatPartition::cacheSync()>
    73e4:	cbnz	r0, 73ea <FatFile::remove()+0x4e>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  return false;
    73e6:	movs	r0, #0
    73e8:	b.n	744a <FatFile::remove()+0xae>
  // Write entry to device.
  if (!m_vol->cacheSync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    73ea:	ldrb	r3, [r4, #3]
    73ec:	cbz	r3, 744a <FatFile::remove()+0xae>
    // Done, no LFN entries.
    return true;
  }
  if (!dirFile.openCluster(this)) {
    73ee:	mov	r1, r4
    73f0:	add	r0, sp, #4
    73f2:	bl	5d92 <FatFile::openCluster(FatFile*)>
    73f6:	cmp	r0, #0
    73f8:	beq.n	73e6 <FatFile::remove()+0x4a>
    73fa:	movs	r5, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    73fc:	ldrb	r3, [r4, #3]
    73fe:	cmp	r3, r5
    7400:	bcc.n	73e6 <FatFile::remove()+0x4a>
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.cacheDir(m_dirIndex - order));
    7402:	ldrh	r1, [r4, #4]
    7404:	subs	r1, r1, r5
    7406:	uxth	r1, r1
    7408:	add	r0, sp, #4
    740a:	bl	5a9c <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    740e:	cmp	r0, #0
    7410:	beq.n	73e6 <FatFile::remove()+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    7412:	ldrb	r3, [r0, #11]
    7414:	cmp	r3, #15
    7416:	bne.n	73e6 <FatFile::remove()+0x4a>
        order != (ldir->order & 0X1F) ||
    7418:	ldrb	r2, [r0, #0]
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.cacheDir(m_dirIndex - order));
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    741a:	and.w	r3, r2, #31
    741e:	cmp	r5, r3
    7420:	bne.n	73e6 <FatFile::remove()+0x4a>
        order != (ldir->order & 0X1F) ||
    7422:	ldrb	r3, [r0, #13]
    7424:	cmp	r3, r7
    7426:	bne.n	73e6 <FatFile::remove()+0x4a>
        checksum != ldir->checksum) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    last = ldir->order & FAT_ORDER_LAST_LONG_ENTRY;
    ldir->order = FAT_NAME_DELETED;
    7428:	strb	r6, [r0, #0]
    m_vol->cacheDirty();
    742a:	ldr	r1, [r4, #8]
    742c:	ldrb.w	r3, [r1, #40]	; 0x28
    7430:	orr.w	r3, r3, #1
    7434:	strb.w	r3, [r1, #40]	; 0x28
    if (last) {
    7438:	lsls	r3, r2, #25
    743a:	bpl.n	7444 <FatFile::remove()+0xa8>
      if (!m_vol->cacheSync()) {
    743c:	ldr	r0, [r4, #8]
    743e:	bl	5c5c <FatPartition::cacheSync()>
    7442:	b.n	744a <FatFile::remove()+0xae>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    7444:	adds	r5, #1
    7446:	uxtb	r5, r5
    7448:	b.n	73fc <FatFile::remove()+0x60>
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  return false;
}
    744a:	add	sp, #44	; 0x2c
    744c:	pop	{r4, r5, r6, r7, pc}

0000744e <FsBaseFile::FsBaseFile(FsBaseFile const&)>:
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    744e:	push	{r3, r4, r5, r6, r7, lr}
    7450:	movs	r4, #0
    7452:	str	r4, [r0, #56]	; 0x38
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    7454:	ldr	r7, [r1, #56]	; 0x38
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    7456:	str	r4, [r0, #60]	; 0x3c
    7458:	mov	r6, r0
    745a:	mov	r5, r1
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    745c:	cbz	r7, 7480 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x32>
    m_fFile = new (m_fileMem) FatFile;
    745e:	mov	r1, r0
    7460:	movs	r0, #36	; 0x24
    7462:	bl	7698 <operator new(unsigned int, unsigned long*)>
    7466:	strb	r4, [r0, #0]
    7468:	strb	r4, [r0, #1]
    746a:	strb	r4, [r0, #2]
    746c:	str	r0, [r6, #56]	; 0x38
    *m_fFile = *from.m_fFile;
    746e:	ldr	r5, [r5, #56]	; 0x38
    7470:	mov	r4, r0
    7472:	ldmia	r5!, {r0, r1, r2, r3}
    7474:	stmia	r4!, {r0, r1, r2, r3}
    7476:	ldmia	r5!, {r0, r1, r2, r3}
    7478:	stmia	r4!, {r0, r1, r2, r3}
    747a:	ldr	r3, [r5, #0]
    747c:	str	r3, [r4, #0]
    747e:	b.n	74ac <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x5e>
  } else if (from.m_xFile) {
    7480:	ldr	r3, [r1, #60]	; 0x3c
    7482:	cbz	r3, 74ac <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x5e>
    m_xFile = new (m_fileMem) ExFatFile;
    7484:	mov	r1, r0
    7486:	movs	r0, #56	; 0x38
    7488:	bl	7698 <operator new(unsigned int, unsigned long*)>
    748c:	strb.w	r7, [r0, #49]	; 0x31
    7490:	strb.w	r7, [r0, #50]	; 0x32
    7494:	strb.w	r7, [r0, #51]	; 0x33
    7498:	str	r0, [r6, #60]	; 0x3c
    *m_xFile = *from.m_xFile;
    749a:	ldr	r3, [r5, #60]	; 0x3c
    749c:	add.w	r2, r3, #52	; 0x34
    74a0:	ldr.w	r1, [r3], #4
    74a4:	str.w	r1, [r0], #4
    74a8:	cmp	r3, r2
    74aa:	bne.n	74a0 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x52>
  }
}
    74ac:	mov	r0, r6
    74ae:	pop	{r3, r4, r5, r6, r7, pc}

000074b0 <FsBaseFile::close()>:
    *m_xFile = *from.m_xFile;
  }
  return *this;
}
//------------------------------------------------------------------------------
bool FsBaseFile::close() {
    74b0:	push	{r4, lr}
    74b2:	mov	r4, r0
  if (m_fFile && m_fFile->close()) {
    74b4:	ldr	r0, [r0, #56]	; 0x38
    74b6:	cbz	r0, 74be <FsBaseFile::close()+0xe>
    74b8:	bl	6270 <FatFile::close()>
    74bc:	cbnz	r0, 74ce <FsBaseFile::close()+0x1e>
    m_fFile = nullptr;
    return true;
  }
  if (m_xFile && m_xFile->close()) {
    74be:	ldr	r0, [r4, #60]	; 0x3c
    74c0:	cbz	r0, 74d4 <FsBaseFile::close()+0x24>
    74c2:	bl	4062 <ExFatFile::close()>
    74c6:	cbz	r0, 74d4 <FsBaseFile::close()+0x24>
    m_xFile = nullptr;
    74c8:	movs	r3, #0
    74ca:	str	r3, [r4, #60]	; 0x3c
    74cc:	pop	{r4, pc}
  return *this;
}
//------------------------------------------------------------------------------
bool FsBaseFile::close() {
  if (m_fFile && m_fFile->close()) {
    m_fFile = nullptr;
    74ce:	movs	r3, #0
    74d0:	str	r3, [r4, #56]	; 0x38
    return true;
    74d2:	pop	{r4, pc}
  }
  if (m_xFile && m_xFile->close()) {
    m_xFile = nullptr;
    return true;
  }
  return false;
    74d4:	movs	r0, #0
}
    74d6:	pop	{r4, pc}

000074d8 <FsBaseFile::open(FsVolume*, char const*, int)>:
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
    74d8:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    74dc:	mov	r4, r0
    74de:	mov	r7, r2
    74e0:	mov	r8, r3
  if (!vol) {
    74e2:	mov	r5, r1
    74e4:	cbnz	r1, 74ec <FsBaseFile::open(FsVolume*, char const*, int)+0x14>
    return false;
    74e6:	movs	r0, #0
    74e8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  close();
    74ec:	bl	74b0 <FsBaseFile::close()>
  if (vol->m_fVol) {
    74f0:	ldr.w	r6, [r5, #1152]	; 0x480
    74f4:	cbz	r6, 751c <FsBaseFile::open(FsVolume*, char const*, int)+0x44>
    m_fFile = new (m_fileMem) FatFile;
    74f6:	mov	r1, r4
    74f8:	movs	r0, #36	; 0x24
    74fa:	bl	7698 <operator new(unsigned int, unsigned long*)>
    74fe:	movs	r2, #0
    7500:	strb	r2, [r0, #0]
    7502:	strb	r2, [r0, #1]
    7504:	strb	r2, [r0, #2]
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    7506:	mov	r3, r8
  if (!vol) {
    return false;
  }
  close();
  if (vol->m_fVol) {
    m_fFile = new (m_fileMem) FatFile;
    7508:	str	r0, [r4, #56]	; 0x38
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    750a:	mov	r2, r7
    750c:	ldr.w	r1, [r5, #1152]	; 0x480
    7510:	bl	6328 <FatFile::open(FatVolume*, char const*, int)>
    7514:	cbz	r0, 7550 <FsBaseFile::open(FsVolume*, char const*, int)+0x78>
      return true;
    7516:	movs	r0, #1
    7518:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    m_fFile = nullptr;
  } else if (vol->m_xVol) {
    751c:	ldr.w	r3, [r5, #1156]	; 0x484
    7520:	cmp	r3, #0
    7522:	beq.n	74e6 <FsBaseFile::open(FsVolume*, char const*, int)+0xe>
    m_xFile = new (m_fileMem) ExFatFile;
    7524:	mov	r1, r4
    7526:	movs	r0, #56	; 0x38
    7528:	bl	7698 <operator new(unsigned int, unsigned long*)>
    752c:	strb.w	r6, [r0, #49]	; 0x31
    7530:	strb.w	r6, [r0, #50]	; 0x32
    7534:	strb.w	r6, [r0, #51]	; 0x33
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    7538:	mov	r3, r8
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
      return true;
    }
    m_fFile = nullptr;
  } else if (vol->m_xVol) {
    m_xFile = new (m_fileMem) ExFatFile;
    753a:	str	r0, [r4, #60]	; 0x3c
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    753c:	mov	r2, r7
    753e:	ldr.w	r1, [r5, #1156]	; 0x484
    7542:	bl	47e2 <ExFatFile::open(ExFatVolume*, char const*, int)>
    7546:	cmp	r0, #0
    7548:	bne.n	7516 <FsBaseFile::open(FsVolume*, char const*, int)+0x3e>
      return true;
    }
    m_xFile = nullptr;
    754a:	str	r0, [r4, #60]	; 0x3c
  }
  return false;
}
    754c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (vol->m_fVol) {
    m_fFile = new (m_fileMem) FatFile;
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
      return true;
    }
    m_fFile = nullptr;
    7550:	str	r0, [r4, #56]	; 0x38
    7552:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00007556 <FsBaseFile::openNext(FsBaseFile*, int)>:
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::openNext(FsBaseFile* dir, oflag_t oflag) {
    7556:	push	{r3, r4, r5, r6, r7, lr}
    7558:	mov	r5, r1
    755a:	mov	r4, r0
    755c:	mov	r7, r2
  close();
    755e:	bl	74b0 <FsBaseFile::close()>
  if (dir->m_fFile) {
    7562:	ldr	r6, [r5, #56]	; 0x38
    7564:	cbz	r6, 758a <FsBaseFile::openNext(FsBaseFile*, int)+0x34>
    m_fFile = new (m_fileMem) FatFile;
    7566:	mov	r1, r4
    7568:	movs	r0, #36	; 0x24
    756a:	bl	7698 <operator new(unsigned int, unsigned long*)>
    756e:	movs	r2, #0
    7570:	strb	r2, [r0, #0]
    7572:	strb	r2, [r0, #1]
    7574:	strb	r2, [r0, #2]
    7576:	str	r0, [r4, #56]	; 0x38
    if (m_fFile->openNext(dir->m_fFile, oflag)) {
    7578:	mov	r2, r7
    757a:	ldr	r1, [r5, #56]	; 0x38
    757c:	bl	6108 <FatFile::openNext(FatFile*, int)>
    7580:	cbz	r0, 7586 <FsBaseFile::openNext(FsBaseFile*, int)+0x30>
      return true;
    7582:	movs	r0, #1
    7584:	pop	{r3, r4, r5, r6, r7, pc}
    }
    m_fFile = nullptr;
    7586:	str	r0, [r4, #56]	; 0x38
    7588:	pop	{r3, r4, r5, r6, r7, pc}
  } else if (dir->m_xFile) {
    758a:	ldr	r0, [r5, #60]	; 0x3c
    758c:	cbz	r0, 75b2 <FsBaseFile::openNext(FsBaseFile*, int)+0x5c>
    m_xFile = new (m_fileMem) ExFatFile;
    758e:	mov	r1, r4
    7590:	movs	r0, #56	; 0x38
    7592:	bl	7698 <operator new(unsigned int, unsigned long*)>
    7596:	strb.w	r6, [r0, #49]	; 0x31
    759a:	strb.w	r6, [r0, #50]	; 0x32
    759e:	strb.w	r6, [r0, #51]	; 0x33
    75a2:	str	r0, [r4, #60]	; 0x3c
    if (m_xFile->openNext(dir->m_xFile, oflag)) {
    75a4:	mov	r2, r7
    75a6:	ldr	r1, [r5, #60]	; 0x3c
    75a8:	bl	47f0 <ExFatFile::openNext(ExFatFile*, int)>
    75ac:	cmp	r0, #0
    75ae:	bne.n	7582 <FsBaseFile::openNext(FsBaseFile*, int)+0x2c>
      return true;
    }
    m_xFile = nullptr;
    75b0:	str	r0, [r4, #60]	; 0x3c
  }
  return false;
}
    75b2:	pop	{r3, r4, r5, r6, r7, pc}

000075b4 <FsVolume::begin(BlockDeviceInterface*)>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    75b4:	push	{r3, r4, r5, r6, r7, lr}
  m_blockDev = blockDev;
  m_fVol = nullptr;
    75b6:	movs	r6, #0
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    75b8:	mov	r4, r0
  m_blockDev = blockDev;
    75ba:	str.w	r1, [r0, #1160]	; 0x488
  m_fVol = nullptr;
    75be:	str.w	r6, [r0, #1152]	; 0x480
  m_xVol = new (m_volMem) ExFatVolume;
    75c2:	mov	r1, r0
    75c4:	mov.w	r0, #1152	; 0x480
    75c8:	bl	7698 <operator new(unsigned int, unsigned long*)>
 * \class ExFatPartition
 * \brief Access exFat partitions on raw file devices.
 */
class ExFatPartition {
 public:
  ExFatPartition() {}
    75cc:	strb.w	r6, [r0, #1092]	; 0x444
    75d0:	strb.w	r6, [r0, #1145]	; 0x479
    75d4:	strb.w	r6, [r0, #1146]	; 0x47a
    75d8:	strb.w	r6, [r0, #1147]	; 0x47b
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    75dc:	movs	r2, #1
    75de:	str.w	r0, [r4, #1156]	; 0x484
    75e2:	ldr.w	r1, [r4, #1160]	; 0x488
    75e6:	ldr	r7, [pc, #124]	; (7664 <FsVolume::begin(BlockDeviceInterface*)+0xb0>)
    75e8:	mov	r5, r0
    75ea:	bl	4b48 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>
    75ee:	cbz	r0, 7608 <FsVolume::begin(BlockDeviceInterface*)+0x54>
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    75f0:	add.w	r6, r5, #1096	; 0x448
    75f4:	mov	r0, r6
    75f6:	bl	4062 <ExFatFile::close()>
    return m_vwd.openRoot(this);
    75fa:	mov	r1, r5
    75fc:	mov	r0, r6
    75fe:	bl	40b6 <ExFatFile::openRoot(ExFatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    7602:	cbz	r0, 7608 <FsVolume::begin(BlockDeviceInterface*)+0x54>
      return false;
    }
    if (setCwv || !m_cwv) {
    7604:	ldr	r3, [pc, #96]	; (7668 <FsVolume::begin(BlockDeviceInterface*)+0xb4>)
    7606:	b.n	764e <FsVolume::begin(BlockDeviceInterface*)+0x9a>
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    7608:	movs	r6, #0
  m_fVol = new (m_volMem) FatVolume;
    760a:	mov	r1, r4
  m_fVol = nullptr;
  m_xVol = new (m_volMem) ExFatVolume;
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    760c:	str.w	r6, [r4, #1156]	; 0x484
  m_fVol = new (m_volMem) FatVolume;
    7610:	movw	r0, #1132	; 0x46c
    7614:	bl	7698 <operator new(unsigned int, unsigned long*)>
 */
class FatPartition {
 public:
  /** Create an instance of FatPartition
   */
  FatPartition() {}
    7618:	strb	r6, [r0, #7]
    761a:	strb.w	r6, [r0, #1096]	; 0x448
    761e:	strb.w	r6, [r0, #1097]	; 0x449
    7622:	strb.w	r6, [r0, #1098]	; 0x44a
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    7626:	movs	r2, #1
    7628:	str.w	r0, [r4, #1152]	; 0x480
    762c:	ldr.w	r1, [r4, #1160]	; 0x488
    7630:	mov	r5, r0
    7632:	bl	6c1c <FatPartition::init(BlockDeviceInterface*, unsigned char)>
    7636:	cbz	r0, 765a <FsVolume::begin(BlockDeviceInterface*)+0xa6>
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    7638:	add.w	r6, r5, #1096	; 0x448
    763c:	mov	r0, r6
    763e:	bl	6270 <FatFile::close()>
    return m_vwd.openRoot(this);
    7642:	mov	r1, r5
    7644:	mov	r0, r6
    7646:	bl	5d62 <FatFile::openRoot(FatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    764a:	cbz	r0, 765a <FsVolume::begin(BlockDeviceInterface*)+0xa6>
      return false;
    }
    if (setCwv || !m_cwv) {
    764c:	ldr	r3, [pc, #28]	; (766c <FsVolume::begin(BlockDeviceInterface*)+0xb8>)
    764e:	ldr	r2, [r3, #0]
    7650:	cbnz	r2, 7654 <FsVolume::begin(BlockDeviceInterface*)+0xa0>
      m_cwv = this;
    7652:	str	r5, [r3, #0]
  m_cwv = nullptr;
  m_fVol = nullptr;
  return false;

 done:
  m_cwv = this;
    7654:	str	r4, [r7, #0]
  return true;
    7656:	movs	r0, #1
    7658:	pop	{r3, r4, r5, r6, r7, pc}
  m_xVol = nullptr;
  m_fVol = new (m_volMem) FatVolume;
  if (m_fVol && m_fVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_cwv = nullptr;
    765a:	movs	r0, #0
    765c:	str	r0, [r7, #0]
  m_fVol = nullptr;
    765e:	str.w	r0, [r4, #1152]	; 0x480
  return false;

 done:
  m_cwv = this;
  return true;
}
    7662:	pop	{r3, r4, r5, r6, r7, pc}
    7664:	.word	0x2001cec0
    7668:	.word	0x2001ceb8
    766c:	.word	0x2001cebc

00007670 <FsVolume::open(char const*, int)>:
bool FsVolume::ls(print_t* pr, const char* path, uint8_t flags) {
  FsBaseFile dir;
  return dir.open(this, path, O_RDONLY) && dir.ls(pr, flags);
}
//------------------------------------------------------------------------------
FsFile FsVolume::open(const char *path, oflag_t oflag) {
    7670:	push	{r3, r4, r5, lr}
    7672:	mov	r4, r0
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    7674:	movs	r0, #0
    7676:	strb	r0, [r4, #4]
    7678:	strb	r0, [r4, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
    767a:	str	r0, [r4, #72]	; 0x48
    767c:	str	r0, [r4, #76]	; 0x4c
    767e:	mov.w	r5, #1000	; 0x3e8
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    7682:	mov	r0, r4
    7684:	str	r5, [r4, #8]
    7686:	ldr	r5, [pc, #12]	; (7694 <FsVolume::open(char const*, int)+0x24>)
    7688:	str.w	r5, [r0], #16
  FsFile tmpFile;
  tmpFile.open(this, path, oflag);
    768c:	bl	74d8 <FsBaseFile::open(FsVolume*, char const*, int)>
  return tmpFile;
}
    7690:	mov	r0, r4
    7692:	pop	{r3, r4, r5, pc}
    7694:	.word	0x00012518

00007698 <operator new(unsigned int, unsigned long*)>:
 */
#include "FsNew.h"
void* operator new(size_t size, newalign_t* ptr) {
  (void)size;
  return ptr;
}
    7698:	mov	r0, r1
    769a:	bx	lr

0000769c <SdSpiCard::errorCode() const>:
  /**
   * \return code for the last error. See SdCardInfo.h for a list of error codes.
   */
  uint8_t errorCode() const {
    return m_errorCode;
  }
    769c:	ldrb	r0, [r0, #15]
    769e:	bx	lr

000076a0 <SdSpiCard::errorData() const>:
  /** \return error data for last error. */
  uint32_t errorData() const {
    return m_status;
  }
    76a0:	ldrb	r0, [r0, #17]
    76a2:	bx	lr

000076a4 <SdSpiCard::readSector(unsigned long, unsigned char*)>:
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    76a4:	ldr	r3, [r0, #0]
   *
   * \param[in] sector Logical sector to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
    76a6:	push	{r4}
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    76a8:	ldr	r4, [r3, #16]
    76aa:	movs	r3, #1
    76ac:	mov	ip, r4
#else  // ENABLE_DEDICATED_SPI
    return readSingle(sector, dst);
#endif  // ENABLE_DEDICATED_SPI
  }
    76ae:	ldr.w	r4, [sp], #4
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    76b2:	bx	ip

000076b4 <SdSpiCard::type() const>:
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
  }
    76b4:	ldrb	r0, [r0, #18]
    76b6:	bx	lr

000076b8 <SdSpiCard::~SdSpiCard()>:
/**
 * \class SdSpiCard
 * \brief Raw access to SD and SDHC flash memory cards via SPI protocol.
 */
#if HAS_SDIO_CLASS
class SdSpiCard : public SdCardInterface {
    76b8:	bx	lr

000076ba <SdSpiCard::~SdSpiCard()>:
    76ba:	push	{r4, lr}
    76bc:	movs	r1, #20
    76be:	mov	r4, r0
    76c0:	bl	a374 <operator delete(void*, unsigned int)>
    76c4:	mov	r0, r4
    76c6:	pop	{r4, pc}

000076c8 <SdSpiCard::sectorCount()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
uint32_t SdSpiCard::sectorCount() {
    76c8:	push	{r0, r1, r2, r3, r4, lr}
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
    76ca:	ldr	r3, [r0, #0]
    76cc:	mov	r1, sp
    76ce:	ldr	r3, [r3, #60]	; 0x3c
    76d0:	blx	r3
    76d2:	cbz	r0, 7742 <SdSpiCard::sectorCount()+0x7a>
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    76d4:	ldrb.w	r3, [sp]
    76d8:	ands.w	r3, r3, #192	; 0xc0
    76dc:	bne.n	771e <SdSpiCard::sectorCount()+0x56>
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    76de:	ldrb.w	r0, [sp, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    76e2:	ldrb.w	r3, [sp, #7]
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    76e6:	ldrb.w	r2, [sp, #10]
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    76ea:	and.w	r0, r0, #3
    76ee:	lsls	r3, r3, #2
    76f0:	orr.w	r3, r3, r0, lsl #10
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    76f4:	ldrb.w	r0, [sp, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    76f8:	orr.w	r0, r3, r0, lsr #6
    76fc:	adds	r3, r0, #1
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    76fe:	ldrb.w	r0, [sp, #9]
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7702:	and.w	r0, r0, #3
    7706:	lsls	r0, r0, #1
    7708:	orr.w	r0, r0, r2, lsr #7
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    770c:	ldrb.w	r2, [sp, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7710:	and.w	r2, r2, #15
    7714:	add	r0, r2
    7716:	subs	r0, #7
    7718:	lsl.w	r0, r3, r0
    771c:	b.n	7742 <SdSpiCard::sectorCount()+0x7a>
  } else if (csd->v2.csd_ver == 1) {
    771e:	cmp	r3, #64	; 0x40
    7720:	bne.n	7740 <SdSpiCard::sectorCount()+0x78>
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    7722:	ldrb.w	r0, [sp, #9]
    7726:	adds	r3, r0, #1
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    7728:	ldrb.w	r0, [sp, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    772c:	and.w	r0, r0, #63	; 0x3f
    7730:	add.w	r0, r3, r0, lsl #16
    7734:	ldrb.w	r3, [sp, #8]
    7738:	add.w	r0, r0, r3, lsl #8
    773c:	lsls	r0, r0, #10
    773e:	b.n	7742 <SdSpiCard::sectorCount()+0x7a>
    7740:	movs	r0, #0
}
    7742:	add	sp, #20
    7744:	ldr.w	pc, [sp], #4

00007748 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>:
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spiDriverPtr->receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriverPtr->send(data);
    7748:	ldr	r3, [r0, #0]
    774a:	ldr	r3, [r3, #20]
    774c:	bx	r3

0000774e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>:
  }
  void spiDeactivate() {
    m_spiDriverPtr->deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriverPtr->receive();
    774e:	ldr	r3, [r0, #0]
    7750:	ldr	r3, [r3, #12]
    7752:	bx	r3

00007754 <SysCall::curTimeMS()>:
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    7754:	ldr	r3, [pc, #12]	; (7764 <SysCall::curTimeMS()+0x10>)
/** Define macro for strings stored in flash. */
#define F(str) (str)
#endif  // F
//------------------------------------------------------------------------------
/** \return the time in milliseconds. */
inline SdMillis_t SysCall::curTimeMS() {
    7756:	sub	sp, #8
    7758:	ldr	r3, [r3, #0]
    775a:	str	r3, [sp, #4]
	return ret;
    775c:	ldr	r0, [sp, #4]
  return millis();
}
    775e:	uxth	r0, r0
    7760:	add	sp, #8
    7762:	bx	lr
    7764:	.word	0x2001cf20

00007768 <SdSpiCard::spiStart()>:
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
    7768:	push	{r3, r4, r5, lr}
  if (!m_spiActive) {
    776a:	ldrb	r5, [r0, #16]
uint32_t SdSpiCard::sectorCount() {
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
    776c:	mov	r4, r0
  if (!m_spiActive) {
    776e:	cbnz	r5, 778c <SdSpiCard::spiStart()+0x24>
    7770:	ldr	r0, [r0, #4]
    m_spiDriver.setSckSpeed(maxSck);
  }
  SdSpiDriver m_spiDriver;
#else  // SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriverPtr->activate();
    7772:	ldr	r3, [r0, #0]
    7774:	ldr	r3, [r3, #0]
    7776:	blx	r3
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    7778:	mov	r1, r5
    777a:	ldrb	r0, [r4, #14]
    777c:	bl	1bc4 <sdCsWrite(unsigned char, bool)>
    spiActivate();
    spiSelect();
    // Dummy byte to drive MISO busy status.
    spiSend(0XFF);    
    7780:	movs	r1, #255	; 0xff
    7782:	ldr	r0, [r4, #4]
    7784:	bl	7748 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    m_spiActive = true;
    7788:	movs	r3, #1
    778a:	strb	r3, [r4, #16]
    778c:	pop	{r3, r4, r5, pc}

0000778e <SdSpiCard::spiStop()>:
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    778e:	ldrb	r3, [r0, #16]
    spiSend(0XFF);    
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
    7790:	push	{r4, lr}
    7792:	mov	r4, r0
  if (m_spiActive) {
    7794:	cbz	r3, 77b2 <SdSpiCard::spiStop()+0x24>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    7796:	movs	r1, #1
    7798:	ldrb	r0, [r0, #14]
    779a:	bl	1bc4 <sdCsWrite(unsigned char, bool)>
    spiUnselect();
    // Insure MISO goes to low Z.
    spiSend(0XFF);        
    779e:	movs	r1, #255	; 0xff
    77a0:	ldr	r0, [r4, #4]
    77a2:	bl	7748 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    77a6:	ldr	r0, [r4, #4]
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriverPtr->begin(spiConfig);
  }
  void spiDeactivate() {
    m_spiDriverPtr->deactivate();
    77a8:	ldr	r3, [r0, #0]
    77aa:	ldr	r3, [r3, #8]
    77ac:	blx	r3
    spiDeactivate();
    m_spiActive = false;
    77ae:	movs	r3, #0
    77b0:	strb	r3, [r4, #16]
    77b2:	pop	{r4, pc}

000077b4 <SdSpiCard::isBusy()>:
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    77b4:	push	{r4, r5, r6, lr}
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    77b6:	ldrb	r3, [r0, #12]
    77b8:	cmp	r3, #1
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    77ba:	mov	r5, r0
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    77bc:	beq.n	77de <SdSpiCard::isBusy()+0x2a>
    return false;
  }
#endif  // ENABLE_DEDICATED_SPI
  bool spiActive = m_spiActive;
    77be:	ldrb	r6, [r0, #16]
  if (!spiActive) {
    77c0:	cbnz	r6, 77c6 <SdSpiCard::isBusy()+0x12>
    spiStart();
    77c2:	bl	7768 <SdSpiCard::spiStart()>
  }
  bool rtn = 0XFF != spiReceive();
    77c6:	ldr	r0, [r5, #4]
    77c8:	bl	774e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    77cc:	subs.w	r4, r0, #255	; 0xff
    77d0:	it	ne
    77d2:	movne	r4, #1
  if (!spiActive) {
    77d4:	cbnz	r6, 77e2 <SdSpiCard::isBusy()+0x2e>
    spiStop();
    77d6:	mov	r0, r5
    77d8:	bl	778e <SdSpiCard::spiStop()>
    77dc:	b.n	77e2 <SdSpiCard::isBusy()+0x2e>
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    return false;
    77de:	movs	r0, #0
    77e0:	pop	{r4, r5, r6, pc}
  }
  bool rtn = 0XFF != spiReceive();
  if (!spiActive) {
    spiStop();
  }
  return rtn;
    77e2:	mov	r0, r4
}
    77e4:	pop	{r4, r5, r6, pc}

000077e6 <SdSpiCard::readData(unsigned char*, unsigned int)>:
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst) {
  return readData(dst, 512);
}
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst, size_t count) {
    77e6:	push	{r3, r4, r5, r6, r7, lr}
    77e8:	mov	r4, r0
    77ea:	mov	r5, r1
    77ec:	mov	r6, r2
  uint16_t crc;
#endif  // USE_SD_CRC

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
    77ee:	bl	7754 <SysCall::curTimeMS()>
    77f2:	mov	r7, r0
  while ((m_status = spiReceive()) == 0XFF) {
    77f4:	ldr	r0, [r4, #4]
    77f6:	bl	774e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    77fa:	cmp	r0, #255	; 0xff
    77fc:	strb	r0, [r4, #17]
    77fe:	bne.n	7810 <SdSpiCard::readData(unsigned char*, unsigned int)+0x2a>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    7800:	bl	7754 <SysCall::curTimeMS()>

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
  while ((m_status = spiReceive()) == 0XFF) {
    if (isTimedOut(t0, SD_READ_TIMEOUT)) {
    7804:	subs	r0, r0, r7
    7806:	cmp.w	r0, #300	; 0x12c
    780a:	ble.n	77f4 <SdSpiCard::readData(unsigned char*, unsigned int)+0xe>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    780c:	movs	r3, #29
    780e:	b.n	782a <SdSpiCard::readData(unsigned char*, unsigned int)+0x44>
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
    }
  }
  DBG_END_TIME(DBG_WAIT_READ);
  if (m_status != DATA_START_SECTOR) {
    7810:	cmp	r0, #254	; 0xfe
    7812:	beq.n	7818 <SdSpiCard::readData(unsigned char*, unsigned int)+0x32>
    7814:	movs	r3, #24
    7816:	b.n	782a <SdSpiCard::readData(unsigned char*, unsigned int)+0x44>
    7818:	ldr	r0, [r4, #4]
  }
  uint8_t spiReceive() {
    return m_spiDriverPtr->receive();
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spiDriverPtr->receive(buf, n);
    781a:	ldr	r3, [r0, #0]
    781c:	mov	r2, r6
    781e:	ldr	r3, [r3, #16]
    7820:	mov	r1, r5
    7822:	blx	r3
    error(SD_CARD_ERROR_READ_TOKEN);
    goto fail;
  }
  // transfer data
  if ((m_status = spiReceive(dst, count))) {
    7824:	strb	r0, [r4, #17]
    7826:	cbz	r0, 7836 <SdSpiCard::readData(unsigned char*, unsigned int)+0x50>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7828:	movs	r3, #37	; 0x25
  spiReceive();
#endif  // USE_SD_CRC
  return true;

 fail:
  spiStop();
    782a:	mov	r0, r4
    782c:	strb	r3, [r4, #15]
    782e:	bl	778e <SdSpiCard::spiStop()>
  return false;
    7832:	movs	r0, #0
}
    7834:	pop	{r3, r4, r5, r6, r7, pc}
    error(SD_CARD_ERROR_READ_CRC);
    goto fail;
  }
#else  // USE_SD_CRC
  // discard crc
  spiReceive();
    7836:	ldr	r0, [r4, #4]
    7838:	bl	774e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
  spiReceive();
    783c:	ldr	r0, [r4, #4]
    783e:	bl	774e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7842:	movs	r0, #1
    7844:	pop	{r3, r4, r5, r6, r7, pc}

00007846 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    7846:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    784a:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    784c:	ldrb	r3, [r0, #12]
    784e:	cmp	r3, #2
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    7850:	mov	r4, r0
    7852:	mov	r5, r1
    7854:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    7856:	bne.n	785e <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x18>
    7858:	ldr	r3, [r0, #8]
    785a:	cmp	r3, r1
    785c:	beq.n	7870 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2a>
    if (!writeStart(sector)) {
    785e:	ldr	r3, [r4, #0]
    7860:	mov	r1, r5
    7862:	ldr	r3, [r3, #80]	; 0x50
    7864:	mov	r0, r4
    7866:	blx	r3
    7868:	cbz	r0, 789e <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x58>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
    786a:	movs	r3, #2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    if (!writeStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    786c:	str	r5, [r4, #8]
    m_curState = WRITE_STATE;
    786e:	strb	r3, [r4, #12]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    7870:	movs	r5, #0
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    7872:	cmp	r5, r7
    7874:	add.w	r1, r6, r5, lsl #9
    7878:	beq.n	7888 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x42>
    if (!writeData(src)) {
    787a:	ldr	r3, [r4, #0]
    787c:	mov	r0, r4
    787e:	ldr	r3, [r3, #76]	; 0x4c
    7880:	blx	r3
    7882:	cbz	r0, 789e <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x58>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    7884:	adds	r5, #1
    7886:	b.n	7872 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2c>
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    7888:	ldr	r3, [r4, #8]
    788a:	add	r5, r3
  return m_sharedSpi ? syncDevice() : true;
    788c:	ldrb	r3, [r4, #13]
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    788e:	str	r5, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    7890:	cbz	r3, 78aa <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x64>
    7892:	ldr	r3, [r4, #0]
    7894:	mov	r0, r4
    7896:	ldr	r3, [r3, #28]
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    7898:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    789c:	bx	r3
  }
  return writeStop();
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
    789e:	mov	r0, r4
    78a0:	bl	778e <SdSpiCard::spiStop()>
  return false;
    78a4:	movs	r0, #0
    78a6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    78aa:	movs	r0, #1
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    78ac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000078b0 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)>:
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    78b0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    78b4:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    78b6:	ldrb	r3, [r0, #12]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    78b8:	ldr.w	r8, [sp, #32]
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    78bc:	cmp	r3, #2
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    78be:	mov	r4, r0
    78c0:	mov	r5, r1
    78c2:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    78c4:	bne.n	78cc <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x1c>
    78c6:	ldr	r3, [r0, #8]
    78c8:	cmp	r3, r1
    78ca:	beq.n	78de <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x2e>
    if (!writeStart(sector)) {
    78cc:	ldr	r3, [r4, #0]
    78ce:	mov	r1, r5
    78d0:	ldr	r3, [r3, #80]	; 0x50
    78d2:	mov	r0, r4
    78d4:	blx	r3
    78d6:	cbz	r0, 7914 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x64>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
    78d8:	movs	r3, #2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    if (!writeStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    78da:	str	r5, [r4, #8]
    m_curState = WRITE_STATE;
    78dc:	strb	r3, [r4, #12]
    78de:	add.w	r9, r5, r6
  }
  for (size_t i = 0; i < ns; i++) {
    78e2:	cmp	r5, r9
    78e4:	beq.n	78fe <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x4e>
    const uint8_t *src = callback(sector + i, context);
    78e6:	mov	r1, r8
    78e8:	mov	r0, r5
    78ea:	blx	r7
    if (!writeData(src)) {
    78ec:	ldr	r3, [r4, #0]
    78ee:	mov	r1, r0
    78f0:	ldr	r3, [r3, #76]	; 0x4c
    78f2:	mov	r0, r4
    78f4:	blx	r3
    78f6:	adds	r5, #1
    78f8:	cmp	r0, #0
    78fa:	bne.n	78e2 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x32>
    78fc:	b.n	7914 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x64>
      goto fail;
    }
  }
  m_curSector += ns;
    78fe:	ldr	r3, [r4, #8]
    7900:	add	r6, r3
  return m_sharedSpi ? syncDevice() : true;
    7902:	ldrb	r3, [r4, #13]
    const uint8_t *src = callback(sector + i, context);
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
    7904:	str	r6, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    7906:	cbz	r3, 7920 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x70>
    7908:	ldr	r3, [r4, #0]
    790a:	mov	r0, r4
    790c:	ldr	r3, [r3, #28]
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    790e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7912:	bx	r3
  }
  return writeStop();
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
    7914:	mov	r0, r4
    7916:	bl	778e <SdSpiCard::spiStop()>
  return false;
    791a:	movs	r0, #0
    791c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7920:	movs	r0, #1
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    7922:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00007926 <SdSpiCard::waitNotBusy(unsigned short)>:
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
//------------------------------------------------------------------------------
// wait for card to go not busy
bool SdSpiCard::waitNotBusy(SdMillis_t timeoutMS) {
    7926:	push	{r4, r5, r6, lr}
    7928:	mov	r6, r0
    792a:	mov	r4, r1
  SdMillis_t t0 = SysCall::curTimeMS();
    792c:	bl	7754 <SysCall::curTimeMS()>
    7930:	mov	r5, r0
    }
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    7932:	ldr	r0, [r6, #4]
    7934:	bl	774e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7938:	cmp	r0, #255	; 0xff
    793a:	beq.n	794a <SdSpiCard::waitNotBusy(unsigned short)+0x24>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    793c:	bl	7754 <SysCall::curTimeMS()>
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    if (isTimedOut(t0, timeoutMS)) {
    7940:	subs	r0, r0, r5
    7942:	cmp	r0, r4
    7944:	ble.n	7932 <SdSpiCard::waitNotBusy(unsigned short)+0xc>
      return false;
    7946:	movs	r0, #0
    7948:	pop	{r4, r5, r6, pc}
    }
  }
  return true;
    794a:	movs	r0, #1
#endif  // WDT_YIELD_TIME_MILLIS
}
    794c:	pop	{r4, r5, r6, pc}

0000794e <SdSpiCard::cardCommand(unsigned char, unsigned long)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    794e:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    7950:	ldrb	r3, [r0, #12]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    7952:	str	r2, [sp, #4]
    7954:	mov	r4, r0
    7956:	mov	r5, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    7958:	cbz	r3, 7966 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x18>
    795a:	ldr	r3, [r0, #0]
    795c:	ldr	r3, [r3, #28]
    795e:	blx	r3
    7960:	cbnz	r0, 7966 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x18>
    return 0XFF;
    7962:	movs	r0, #255	; 0xff
    7964:	b.n	79c6 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x78>
  }
#endif  // ENABLE_DEDICATED_SPI
  // select card
  if (!m_spiActive) {
    7966:	ldrb	r3, [r4, #16]
    7968:	cbnz	r3, 7970 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x22>
    spiStart();
    796a:	mov	r0, r4
    796c:	bl	7768 <SdSpiCard::spiStart()>
  }
  // wait if busy unless CMD0
  if (cmd != CMD0) {
    7970:	cbz	r5, 797c <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x2e>
    DBG_BEGIN_TIME(DBG_CMD_BUSY);
    waitNotBusy(SD_CMD_TIMEOUT);
    7972:	mov.w	r1, #300	; 0x12c
    7976:	mov	r0, r4
    7978:	bl	7926 <SdSpiCard::waitNotBusy(unsigned short)>

  // send message
  spiSend(buf, 6);
#else  // USE_SD_CRC
  // send command
  spiSend(cmd | 0x40);
    797c:	orr.w	r1, r5, #64	; 0x40
    7980:	ldr	r0, [r4, #4]
    7982:	bl	7748 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    7986:	add.w	r6, sp, #7
    798a:	add.w	r7, sp, #3

  // send argument
  uint8_t* pa = reinterpret_cast<uint8_t*>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    spiSend(pa[i]);
    798e:	ldrb.w	r1, [r6], #-1
    7992:	ldr	r0, [r4, #4]
    7994:	bl	7748 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
  // send command
  spiSend(cmd | 0x40);

  // send argument
  uint8_t* pa = reinterpret_cast<uint8_t*>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    7998:	cmp	r7, r6
    799a:	bne.n	798e <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x40>
    spiSend(pa[i]);
  }

  // send CRC - correct for CMD0 with arg zero or CMD8 with arg 0X1AA
  spiSend(cmd == CMD0 ? 0X95 : 0X87);
    799c:	cmp	r5, #0
    799e:	ite	eq
    79a0:	moveq	r1, #149	; 0x95
    79a2:	movne	r1, #135	; 0x87
    79a4:	ldr	r0, [r4, #4]
    79a6:	bl	7748 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
#endif  // USE_SD_CRC

  // discard first fill byte to avoid MISO pull-up problem.
  spiReceive();
    79aa:	ldr	r0, [r4, #4]
    79ac:	bl	774e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    79b0:	movs	r5, #11

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
    79b2:	ldr	r0, [r4, #4]
    79b4:	bl	774e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    79b8:	lsls	r3, r0, #24
    79ba:	strb	r0, [r4, #17]
    79bc:	bpl.n	79c6 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x78>
    79be:	subs	r5, #1
    79c0:	ands.w	r5, r5, #255	; 0xff
    79c4:	bne.n	79b2 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x64>
  }
  return m_status;
}
    79c6:	add	sp, #12
    79c8:	pop	{r4, r5, r6, r7, pc}

000079ca <SdSpiCard::cardAcmd(unsigned char, unsigned long)>:
  /** Set CS high and deactivate the card. */
  void spiStop();

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    79ca:	push	{r4, r5, r6, lr}
    79cc:	mov	r4, r0
    79ce:	mov	r5, r1
    79d0:	mov	r6, r2
    cardCommand(CMD55, 0);
    79d2:	movs	r1, #55	; 0x37
    79d4:	movs	r2, #0
    79d6:	bl	794e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    return cardCommand(cmd, arg);
    79da:	mov	r2, r6
    79dc:	mov	r1, r5
    79de:	mov	r0, r4
  }
    79e0:	ldmia.w	sp!, {r4, r5, r6, lr}

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    cardCommand(CMD55, 0);
    return cardCommand(cmd, arg);
    79e4:	b.w	794e <SdSpiCard::cardCommand(unsigned char, unsigned long)>

000079e8 <SdSpiCard::begin(SdSpiConfig)>:
#endif  // CRC_CCITT
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
    79e8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    79ec:	sub	sp, #36	; 0x24
    79ee:	add	r5, sp, #4
    79f0:	stmia.w	r5, {r1, r2, r3}
    79f4:	mov	r4, r0
    79f6:	ldrb.w	sl, [sp, #4]
    79fa:	ldr.w	fp, [sp, #12]
    79fe:	ldrb.w	r8, [sp, #5]
    7a02:	ldr	r6, [sp, #8]
  SdMillis_t t0 = SysCall::curTimeMS();
    7a04:	bl	7754 <SysCall::curTimeMS()>
  m_spiActive = false;
    7a08:	mov.w	r9, #0
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
  SdMillis_t t0 = SysCall::curTimeMS();
    7a0c:	mov	r7, r0
  m_spiActive = false;
    7a0e:	strb.w	r9, [r4, #16]
  m_errorCode = SD_CARD_ERROR_NONE;
    7a12:	strb.w	r9, [r4, #15]
  m_type = 0;
    7a16:	strb.w	r9, [r4, #18]
  m_csPin = spiConfig.csPin;
    7a1a:	strb.w	sl, [r4, #14]
#if SPI_DRIVER_SELECT >= 2
  m_spiDriverPtr = spiConfig.spiPort;
    7a1e:	str.w	fp, [r4, #4]
  if (!m_spiDriverPtr) {
    7a22:	cmp.w	fp, #0
    7a26:	bne.n	7a2c <SdSpiCard::begin(SdSpiConfig)+0x44>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7a28:	movs	r3, #42	; 0x2a
    7a2a:	b.n	7b60 <SdSpiCard::begin(SdSpiConfig)+0x178>
    error(SD_CARD_ERROR_INVALID_CARD_CONFIG);
    goto fail;
  }
#endif  // SPI_DRIVER_SELECT
  sdCsInit(m_csPin);
    7a2c:	mov	r0, sl
    7a2e:	bl	1ba8 <sdCsInit(unsigned char)>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    7a32:	movs	r1, #1
    7a34:	ldrb	r0, [r4, #14]
    7a36:	bl	1bc4 <sdCsWrite(unsigned char, bool)>
    7a3a:	ldr	r0, [r4, #4]
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
  }
  void spiSetSckSpeed(uint32_t maxSck) {
    m_spiDriverPtr->setSckSpeed(maxSck);
    7a3c:	ldr	r1, [pc, #344]	; (7b98 <SdSpiCard::begin(SdSpiConfig)+0x1b0>)
    7a3e:	ldr	r3, [r0, #0]
    7a40:	ldr	r3, [r3, #28]
    7a42:	blx	r3
    7a44:	ldmia.w	r5, {r0, r1, r2}
    7a48:	add	r3, sp, #20
    7a4a:	ldr.w	lr, [r4, #4]
    7a4e:	stmia.w	r3, {r0, r1, r2}
#else  // SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriverPtr->activate();
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriverPtr->begin(spiConfig);
    7a52:	ldr.w	r2, [lr]
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
  m_sharedSpi = spiOptionShared(spiConfig.options);
    7a56:	and.w	r8, r8, #1
    7a5a:	mov	r0, lr
    7a5c:	ldr	r5, [r2, #4]
    7a5e:	eor.w	r8, r8, #1
    7a62:	ldmia	r3, {r1, r2, r3}
    7a64:	blx	r5
#else  // ENABLE_DEDICATED_SPI
  // m_sharedSpi is a static const bool in this case.
  static_assert(m_sharedSpi == true, "m_sharedSpi bug");
#endif  // ENABLE_DEDICATED_SPI
  spiStart();
    7a66:	mov	r0, r4
  spiUnselect();
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
    7a68:	strb.w	r9, [r4, #12]
  m_sharedSpi = spiOptionShared(spiConfig.options);
    7a6c:	strb.w	r8, [r4, #13]
#else  // ENABLE_DEDICATED_SPI
  // m_sharedSpi is a static const bool in this case.
  static_assert(m_sharedSpi == true, "m_sharedSpi bug");
#endif  // ENABLE_DEDICATED_SPI
  spiStart();
    7a70:	bl	7768 <SdSpiCard::spiStart()>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    7a74:	movs	r1, #1
    7a76:	ldrb	r0, [r4, #14]
    7a78:	bl	1bc4 <sdCsWrite(unsigned char, bool)>
    7a7c:	movs	r5, #10

  // must supply min of 74 clock cycles with CS high.
  spiUnselect();
  for (uint8_t i = 0; i < 10; i++) {
    spiSend(0XFF);
    7a7e:	movs	r1, #255	; 0xff
    7a80:	ldr	r0, [r4, #4]
    7a82:	subs	r5, #1
    7a84:	bl	7748 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
#endif  // ENABLE_DEDICATED_SPI
  spiStart();

  // must supply min of 74 clock cycles with CS high.
  spiUnselect();
  for (uint8_t i = 0; i < 10; i++) {
    7a88:	ands.w	r5, r5, #255	; 0xff
    7a8c:	bne.n	7a7e <SdSpiCard::begin(SdSpiConfig)+0x96>
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    7a8e:	mov	r1, r5
    7a90:	ldrb	r0, [r4, #14]
    7a92:	bl	1bc4 <sdCsWrite(unsigned char, bool)>
    7a96:	movs	r5, #10
  spiSelect();
  DBG_BEGIN_TIME(DBG_CMD0_TIME);
  // command to go idle in SPI mode
  for (uint8_t i = 1;; i++) {
    DBG_EVENT_COUNT(DBG_CMD0_COUNT);
    if (cardCommand(CMD0, 0) == R1_IDLE_STATE) {
    7a98:	movs	r2, #0
    7a9a:	mov	r1, r2
    7a9c:	mov	r0, r4
    7a9e:	bl	794e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7aa2:	cmp	r0, #1
    7aa4:	mov	r8, r0
    7aa6:	beq.n	7ace <SdSpiCard::begin(SdSpiConfig)+0xe6>
    7aa8:	subs	r5, #1
      break;
    }
    if (i == SD_CMD0_RETRY) {
    7aaa:	ands.w	r5, r5, #255	; 0xff
    7aae:	bne.n	7ab4 <SdSpiCard::begin(SdSpiConfig)+0xcc>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7ab0:	movs	r3, #1
    7ab2:	b.n	7b60 <SdSpiCard::begin(SdSpiConfig)+0x178>
      error(SD_CARD_ERROR_CMD0);
      goto fail;
    }
    // stop multi-block write
    spiSend(STOP_TRAN_TOKEN);
    7ab4:	movs	r1, #253	; 0xfd
    7ab6:	ldr	r0, [r4, #4]
    7ab8:	bl	7748 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    7abc:	mov.w	r8, #520	; 0x208
    // finish block transfer
    for (int i = 0; i < 520; i++) {
      spiReceive();
    7ac0:	ldr	r0, [r4, #4]
    7ac2:	bl	774e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
      goto fail;
    }
    // stop multi-block write
    spiSend(STOP_TRAN_TOKEN);
    // finish block transfer
    for (int i = 0; i < 520; i++) {
    7ac6:	subs.w	r8, r8, #1
    7aca:	bne.n	7ac0 <SdSpiCard::begin(SdSpiConfig)+0xd8>
    7acc:	b.n	7a98 <SdSpiCard::begin(SdSpiConfig)+0xb0>
    goto fail;
  }
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    7ace:	mov.w	r2, #426	; 0x1aa
    7ad2:	movs	r1, #8
    7ad4:	mov	r0, r4
    7ad6:	bl	794e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7ada:	lsls	r3, r0, #29
    7adc:	bmi.n	7afc <SdSpiCard::begin(SdSpiConfig)+0x114>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    7ade:	movs	r3, #2
    7ae0:	strb	r3, [r4, #18]
    7ae2:	movs	r5, #4
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
      m_status = spiReceive();
    7ae4:	ldr	r0, [r4, #4]
    7ae6:	bl	774e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7aea:	subs	r5, #1
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    7aec:	ands.w	r5, r5, #255	; 0xff
      m_status = spiReceive();
    7af0:	strb	r0, [r4, #17]
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    7af2:	bne.n	7ae4 <SdSpiCard::begin(SdSpiConfig)+0xfc>
      m_status = spiReceive();
    }
    if (m_status != 0XAA) {
    7af4:	cmp	r0, #170	; 0xaa
    7af6:	beq.n	7b00 <SdSpiCard::begin(SdSpiConfig)+0x118>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7af8:	movs	r3, #6
    7afa:	b.n	7b60 <SdSpiCard::begin(SdSpiConfig)+0x178>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    7afc:	strb.w	r8, [r4, #18]
    }
  } else {
    type(SD_CARD_TYPE_SD1);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
    7b00:	ldr	r3, [r4, #0]
    7b02:	mov	r0, r4
    7b04:	ldr	r3, [r3, #72]	; 0x48
    7b06:	blx	r3
    7b08:	cmp	r0, #2
    7b0a:	ite	eq
    7b0c:	moveq.w	r8, #1073741824	; 0x40000000
    7b10:	movne.w	r8, #0
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    7b14:	mov	r2, r8
    7b16:	movs	r1, #41	; 0x29
    7b18:	mov	r0, r4
    7b1a:	bl	79ca <SdSpiCard::cardAcmd(unsigned char, unsigned long)>
    7b1e:	mov	r5, r0
    7b20:	cbz	r0, 7b32 <SdSpiCard::begin(SdSpiConfig)+0x14a>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    7b22:	bl	7754 <SysCall::curTimeMS()>
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    DBG_EVENT_COUNT(DBG_ACMD41_COUNT);
    // check for timeout
    if (isTimedOut(t0, SD_INIT_TIMEOUT)) {
    7b26:	subs	r0, r0, r7
    7b28:	cmp.w	r0, #2000	; 0x7d0
    7b2c:	ble.n	7b14 <SdSpiCard::begin(SdSpiConfig)+0x12c>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7b2e:	movs	r3, #23
    7b30:	b.n	7b60 <SdSpiCard::begin(SdSpiConfig)+0x178>
    }
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    7b32:	ldr	r3, [r4, #0]
    7b34:	mov	r0, r4
    7b36:	ldr	r3, [r3, #72]	; 0x48
    7b38:	blx	r3
    7b3a:	cmp	r0, #2
    7b3c:	beq.n	7b52 <SdSpiCard::begin(SdSpiConfig)+0x16a>
    // Discard rest of ocr - contains allowed voltage range.
    for (uint8_t i = 0; i < 3; i++) {
      spiReceive();
    }
  }
  spiStop();
    7b3e:	mov	r0, r4
    7b40:	bl	778e <SdSpiCard::spiStop()>
    7b44:	ldr	r0, [r4, #4]
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
  }
  void spiSetSckSpeed(uint32_t maxSck) {
    m_spiDriverPtr->setSckSpeed(maxSck);
    7b46:	ldr	r3, [r0, #0]
    7b48:	mov	r1, r6
    7b4a:	ldr	r3, [r3, #28]
    7b4c:	blx	r3
  spiSetSckSpeed(spiConfig.maxSck);
  return true;
    7b4e:	movs	r0, #1
    7b50:	b.n	7b92 <SdSpiCard::begin(SdSpiConfig)+0x1aa>
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
    7b52:	mov	r2, r5
    7b54:	movs	r1, #58	; 0x3a
    7b56:	mov	r0, r4
    7b58:	bl	794e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7b5c:	cbz	r0, 7b6c <SdSpiCard::begin(SdSpiConfig)+0x184>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7b5e:	movs	r3, #18
  spiStop();
  spiSetSckSpeed(spiConfig.maxSck);
  return true;

 fail:
  spiStop();
    7b60:	mov	r0, r4
    7b62:	strb	r3, [r4, #15]
    7b64:	bl	778e <SdSpiCard::spiStop()>
  return false;
    7b68:	movs	r0, #0
    7b6a:	b.n	7b92 <SdSpiCard::begin(SdSpiConfig)+0x1aa>
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
      error(SD_CARD_ERROR_CMD58);
      goto fail;
    }
    if ((spiReceive() & 0XC0) == 0XC0) {
    7b6c:	ldr	r0, [r4, #4]
    7b6e:	bl	774e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7b72:	and.w	r0, r0, #192	; 0xc0
    7b76:	cmp	r0, #192	; 0xc0
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    7b78:	itt	eq
    7b7a:	moveq	r3, #3
    7b7c:	strbeq	r3, [r4, #18]
      type(SD_CARD_TYPE_SDHC);
    }
    // Discard rest of ocr - contains allowed voltage range.
    for (uint8_t i = 0; i < 3; i++) {
      spiReceive();
    7b7e:	ldr	r0, [r4, #4]
    7b80:	bl	774e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7b84:	ldr	r0, [r4, #4]
    7b86:	bl	774e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7b8a:	ldr	r0, [r4, #4]
    7b8c:	bl	774e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7b90:	b.n	7b3e <SdSpiCard::begin(SdSpiConfig)+0x156>
  return true;

 fail:
  spiStop();
  return false;
}
    7b92:	add	sp, #36	; 0x24
    7b94:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7b98:	.word	0x00061a80

00007b9c <SdSpiCard::readOCR(unsigned long*)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7b9c:	push	{r4, r5, r6, lr}
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    7b9e:	movs	r2, #0
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7ba0:	mov	r6, r1
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    7ba2:	movs	r1, #58	; 0x3a
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7ba4:	mov	r4, r0
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    7ba6:	bl	794e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7baa:	cbz	r0, 7bba <SdSpiCard::readOCR(unsigned long*)+0x1e>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7bac:	movs	r3, #18
  }
  spiStop();
  return true;

 fail:
  spiStop();
    7bae:	mov	r0, r4
    7bb0:	strb	r3, [r4, #15]
    7bb2:	bl	778e <SdSpiCard::spiStop()>
  return false;
    7bb6:	movs	r0, #0
    7bb8:	pop	{r4, r5, r6, pc}
    7bba:	adds	r5, r6, #4
  if (cardCommand(CMD58, 0)) {
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    p[3 - i] = spiReceive();
    7bbc:	ldr	r0, [r4, #4]
    7bbe:	bl	774e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7bc2:	strb.w	r0, [r5, #-1]!
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    7bc6:	cmp	r5, r6
    7bc8:	bne.n	7bbc <SdSpiCard::readOCR(unsigned long*)+0x20>
    p[3 - i] = spiReceive();
  }
  spiStop();
    7bca:	mov	r0, r4
    7bcc:	bl	778e <SdSpiCard::spiStop()>
  return true;
    7bd0:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7bd2:	pop	{r4, r5, r6, pc}

00007bd4 <SdSpiCard::readRegister(unsigned char, void*)>:
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    7bd4:	push	{r3, r4, r5, lr}
    7bd6:	mov	r5, r2
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    7bd8:	movs	r2, #0
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    7bda:	mov	r4, r0
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    7bdc:	bl	794e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7be0:	cbz	r0, 7be8 <SdSpiCard::readRegister(unsigned char, void*)+0x14>
    7be2:	movs	r3, #27
    7be4:	strb	r3, [r4, #15]
    7be6:	b.n	7bfe <SdSpiCard::readRegister(unsigned char, void*)+0x2a>
    error(SD_CARD_ERROR_READ_REG);
    goto fail;
  }
  if (!readData(dst, 16)) {
    7be8:	mov	r1, r5
    7bea:	movs	r2, #16
    7bec:	mov	r0, r4
    7bee:	bl	77e6 <SdSpiCard::readData(unsigned char*, unsigned int)>
    7bf2:	mov	r5, r0
    7bf4:	cbz	r0, 7bfe <SdSpiCard::readRegister(unsigned char, void*)+0x2a>
    goto fail;
  }
  spiStop();
    7bf6:	mov	r0, r4
    7bf8:	bl	778e <SdSpiCard::spiStop()>
  return true;
    7bfc:	b.n	7c06 <SdSpiCard::readRegister(unsigned char, void*)+0x32>

 fail:
  spiStop();
    7bfe:	mov	r0, r4
    7c00:	bl	778e <SdSpiCard::spiStop()>
  return false;
    7c04:	movs	r5, #0
}
    7c06:	mov	r0, r5
    7c08:	pop	{r3, r4, r5, pc}

00007c0a <SdSpiCard::readCSD(csd_t*)>:
   * \param[out] csd pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCSD(csd_t* csd) {
    return readRegister(CMD9, csd);
    7c0a:	mov	r2, r1
    7c0c:	movs	r1, #9
    7c0e:	b.w	7bd4 <SdSpiCard::readRegister(unsigned char, void*)>

00007c12 <SdSpiCard::readCID(CID*)>:
   * \param[out] cid pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCID(cid_t* cid) {
    return readRegister(CMD10, cid);
    7c12:	mov	r2, r1
    7c14:	movs	r1, #10
    7c16:	b.w	7bd4 <SdSpiCard::readRegister(unsigned char, void*)>

00007c1a <SdSpiCard::readStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    7c1a:	push	{r3, r4, r5, lr}
  if (type() != SD_CARD_TYPE_SDHC) {
    7c1c:	ldr	r3, [r0, #0]
    7c1e:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    7c20:	mov	r5, r1
    7c22:	mov	r4, r0
  if (type() != SD_CARD_TYPE_SDHC) {
    7c24:	blx	r3
    7c26:	cmp	r0, #3
    sector <<= 9;
    7c28:	it	ne
    7c2a:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD18, sector)) {
    7c2c:	mov	r2, r5
    7c2e:	movs	r1, #18
    7c30:	mov	r0, r4
    7c32:	bl	794e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7c36:	cbz	r0, 7c46 <SdSpiCard::readStart(unsigned long)+0x2c>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7c38:	movs	r3, #12
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7c3a:	mov	r0, r4
    7c3c:	strb	r3, [r4, #15]
    7c3e:	bl	778e <SdSpiCard::spiStop()>
  return false;
    7c42:	movs	r0, #0
    7c44:	pop	{r3, r4, r5, pc}
  }
  if (cardCommand(CMD18, sector)) {
    error(SD_CARD_ERROR_CMD18);
    goto fail;
  }
  return true;
    7c46:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7c48:	pop	{r3, r4, r5, pc}

00007c4a <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    7c4a:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7c4e:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7c50:	ldrb	r3, [r0, #12]
    7c52:	cmp	r3, #1
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    7c54:	mov	r4, r0
    7c56:	mov	r5, r1
    7c58:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7c5a:	bne.n	7c62 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x18>
    7c5c:	ldr	r3, [r0, #8]
    7c5e:	cmp	r3, r1
    7c60:	beq.n	7c78 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x2e>
    if (!readStart(sector)) {
    7c62:	mov	r1, r5
    7c64:	mov	r0, r4
    7c66:	bl	7c1a <SdSpiCard::readStart(unsigned long)>
    7c6a:	cbnz	r0, 7c72 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x28>
    }
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
    7c6c:	movs	r0, #0
    7c6e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
    7c72:	movs	r3, #1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    7c74:	str	r5, [r4, #8]
    m_curState = READ_STATE;
    7c76:	strb	r3, [r4, #12]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    7c78:	movs	r5, #0
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    7c7a:	cmp	r5, r7
    7c7c:	add.w	r1, r6, r5, lsl #9
    7c80:	beq.n	7c94 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4a>
    if (!readData(dst, 512)) {
    7c82:	mov.w	r2, #512	; 0x200
    7c86:	mov	r0, r4
    7c88:	bl	77e6 <SdSpiCard::readData(unsigned char*, unsigned int)>
    7c8c:	cmp	r0, #0
    7c8e:	beq.n	7c6c <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x22>
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    7c90:	adds	r5, #1
    7c92:	b.n	7c7a <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x30>
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    7c94:	ldr	r3, [r4, #8]
    7c96:	add	r5, r3
  return m_sharedSpi ? syncDevice() : true;
    7c98:	ldrb	r3, [r4, #13]
  for (size_t i = 0; i < ns; i++, dst += 512) {
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    7c9a:	str	r5, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    7c9c:	cbz	r3, 7caa <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x60>
    7c9e:	ldr	r3, [r4, #0]
    7ca0:	mov	r0, r4
    7ca2:	ldr	r3, [r3, #28]
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7ca4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7ca8:	bx	r3
    7caa:	movs	r0, #1
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7cac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00007cb0 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)>:
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7cb0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7cb4:	mov	r6, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7cb6:	ldrb	r3, [r0, #12]
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7cb8:	ldr.w	r8, [sp, #32]
    7cbc:	ldr.w	r9, [sp, #36]	; 0x24
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7cc0:	cmp	r3, #1
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7cc2:	mov	r4, r0
    7cc4:	mov	r5, r1
    7cc6:	mov	r7, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7cc8:	bne.n	7cd0 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x20>
    7cca:	ldr	r3, [r0, #8]
    7ccc:	cmp	r3, r1
    7cce:	beq.n	7ce6 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x36>
    if (!readStart(sector)) {
    7cd0:	mov	r1, r5
    7cd2:	mov	r0, r4
    7cd4:	bl	7c1a <SdSpiCard::readStart(unsigned long)>
    7cd8:	cbnz	r0, 7ce0 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x30>
    }
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
    7cda:	movs	r0, #0
    7cdc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
    7ce0:	movs	r3, #1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    7ce2:	str	r5, [r4, #8]
    m_curState = READ_STATE;
    7ce4:	strb	r3, [r4, #12]
    7ce6:	add.w	sl, r5, r6
  }
  for (size_t i = 0; i < ns; i++) {
    7cea:	cmp	r5, sl
    7cec:	beq.n	7d0a <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x5a>
    if (readData(dst, 512)) {
    7cee:	mov.w	r2, #512	; 0x200
    7cf2:	mov	r1, r7
    7cf4:	mov	r0, r4
    7cf6:	bl	77e6 <SdSpiCard::readData(unsigned char*, unsigned int)>
    7cfa:	cmp	r0, #0
    7cfc:	beq.n	7cda <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x2a>
      callback(sector + i, dst, context);
    7cfe:	mov	r0, r5
    7d00:	mov	r2, r9
    7d02:	mov	r1, r7
    7d04:	blx	r8
    7d06:	adds	r5, #1
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++) {
    7d08:	b.n	7cea <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x3a>
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    7d0a:	ldr	r3, [r4, #8]
    7d0c:	add	r6, r3
  return m_sharedSpi ? syncDevice() : true;
    7d0e:	ldrb	r3, [r4, #13]
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    7d10:	str	r6, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    7d12:	cbz	r3, 7d20 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x70>
    7d14:	ldr	r3, [r4, #0]
    7d16:	mov	r0, r4
    7d18:	ldr	r3, [r3, #28]
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7d1a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7d1e:	bx	r3
    7d20:	movs	r0, #1
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7d22:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00007d26 <SdSpiCard::readStop()>:
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    7d26:	push	{r4, lr}
  if (cardCommand(CMD12, 0)) {
    7d28:	movs	r2, #0
    7d2a:	movs	r1, #12
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    7d2c:	mov	r4, r0
  if (cardCommand(CMD12, 0)) {
    7d2e:	bl	794e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7d32:	cbz	r0, 7d42 <SdSpiCard::readStop()+0x1c>
    7d34:	movs	r3, #9
  }
  spiStop();
  return true;

 fail:
  spiStop();
    7d36:	mov	r0, r4
    7d38:	strb	r3, [r4, #15]
    7d3a:	bl	778e <SdSpiCard::spiStop()>
  return false;
    7d3e:	movs	r0, #0
    7d40:	pop	{r4, pc}
bool SdSpiCard::readStop() {
  if (cardCommand(CMD12, 0)) {
    error(SD_CARD_ERROR_CMD12);
    goto fail;
  }
  spiStop();
    7d42:	mov	r0, r4
    7d44:	bl	778e <SdSpiCard::spiStop()>
  return true;
    7d48:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7d4a:	pop	{r4, pc}

00007d4c <SdSpiCard::syncDevice()>:
}
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
    7d4c:	ldrb	r2, [r0, #12]
  m_curState = IDLE_STATE;
    7d4e:	movs	r1, #0
  if (state == WRITE_STATE) {
    7d50:	cmp	r2, #2
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
  m_curState = IDLE_STATE;
    7d52:	strb	r1, [r0, #12]
  if (state == WRITE_STATE) {
    7d54:	bne.n	7d5c <SdSpiCard::syncDevice()+0x10>
    return writeStop();
    7d56:	ldr	r3, [r0, #0]
    7d58:	ldr	r3, [r3, #84]	; 0x54
    7d5a:	bx	r3
  }
  if (state == READ_STATE) {
    7d5c:	cmp	r2, #1
    7d5e:	bne.n	7d64 <SdSpiCard::syncDevice()+0x18>
    return readStop();
    7d60:	b.w	7d26 <SdSpiCard::readStop()>
  }
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
    7d64:	movs	r0, #1
    7d66:	bx	lr

00007d68 <SdSpiCard::writeStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    7d68:	push	{r3, r4, r5, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7d6a:	ldr	r3, [r0, #0]
    7d6c:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    7d6e:	mov	r5, r1
    7d70:	mov	r4, r0
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7d72:	blx	r3
    7d74:	cmp	r0, #3
    sector <<= 9;
    7d76:	it	ne
    7d78:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD25, sector)) {
    7d7a:	mov	r2, r5
    7d7c:	movs	r1, #25
    7d7e:	mov	r0, r4
    7d80:	bl	794e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7d84:	cbz	r0, 7d94 <SdSpiCard::writeStart(unsigned long)+0x2c>
    7d86:	movs	r3, #14
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7d88:	mov	r0, r4
    7d8a:	strb	r3, [r4, #15]
    7d8c:	bl	778e <SdSpiCard::spiStop()>
  return false;
    7d90:	movs	r0, #0
    7d92:	pop	{r3, r4, r5, pc}
  }
  if (cardCommand(CMD25, sector)) {
    error(SD_CARD_ERROR_CMD25);
    goto fail;
  }
  return true;
    7d94:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7d96:	pop	{r3, r4, r5, pc}

00007d98 <SdSpiCard::erase(unsigned long, unsigned long)>:
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7d98:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  csd_t csd;
  if (!readCSD(&csd)) {
    7d9a:	ldr	r3, [r0, #0]
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7d9c:	mov	r6, r1
  csd_t csd;
  if (!readCSD(&csd)) {
    7d9e:	ldr	r3, [r3, #60]	; 0x3c
    7da0:	mov	r1, sp
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7da2:	mov	r4, r0
    7da4:	mov	r5, r2
  csd_t csd;
  if (!readCSD(&csd)) {
    7da6:	blx	r3
    7da8:	cbz	r0, 7e10 <SdSpiCard::erase(unsigned long, unsigned long)+0x78>
    goto fail;
  }
  // check for single sector erase
  if (!csd.v1.erase_blk_en) {
    7daa:	ldrb.w	r3, [sp, #10]
    7dae:	lsls	r2, r3, #25
    7db0:	bmi.n	7dcc <SdSpiCard::erase(unsigned long, unsigned long)+0x34>
    // erase size mask
    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
    7db2:	ldrb.w	r2, [sp, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    7db6:	and.w	r3, r3, #63	; 0x3f
    7dba:	lsls	r3, r3, #1
    7dbc:	orr.w	r3, r3, r2, lsr #7
    7dc0:	adds	r2, r5, #1
    7dc2:	orrs	r2, r6
    7dc4:	tst	r3, r2
    7dc6:	beq.n	7dcc <SdSpiCard::erase(unsigned long, unsigned long)+0x34>
    7dc8:	movs	r3, #39	; 0x27
    7dca:	b.n	7e0e <SdSpiCard::erase(unsigned long, unsigned long)+0x76>
      // error card can't erase specified area
      error(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    7dcc:	ldrb	r3, [r4, #18]
    7dce:	cmp	r3, #3
    firstSector <<= 9;
    7dd0:	it	ne
    7dd2:	lslne	r6, r6, #9
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
    7dd4:	mov	r2, r6
    7dd6:	mov.w	r1, #32
    7dda:	mov	r0, r4
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
    7ddc:	it	ne
    7dde:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD32, firstSector)
    7de0:	bl	794e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
      || cardCommand(CMD33, lastSector)
      || cardCommand(CMD38, 0)) {
    7de4:	cbnz	r0, 7e1a <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
      || cardCommand(CMD33, lastSector)
    7de6:	mov	r2, r5
    7de8:	movs	r1, #33	; 0x21
    7dea:	mov	r0, r4
    7dec:	bl	794e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7df0:	mov	r2, r0
    7df2:	cbnz	r0, 7e1a <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
      || cardCommand(CMD38, 0)) {
    7df4:	movs	r1, #38	; 0x26
    7df6:	mov	r0, r4
    7df8:	bl	794e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7dfc:	cbnz	r0, 7e1a <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
    error(SD_CARD_ERROR_ERASE);
    goto fail;
  }
  DBG_BEGIN_TIME(DBG_ERASE_BUSY);
  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    7dfe:	movw	r1, #10000	; 0x2710
    7e02:	mov	r0, r4
    7e04:	bl	7926 <SdSpiCard::waitNotBusy(unsigned short)>
    7e08:	mov	r5, r0
    7e0a:	cbnz	r0, 7e1e <SdSpiCard::erase(unsigned long, unsigned long)+0x86>
    7e0c:	movs	r3, #40	; 0x28
    7e0e:	strb	r3, [r4, #15]
  DBG_END_TIME(DBG_ERASE_BUSY);
  spiStop();
  return true;

 fail:
  spiStop();
    7e10:	mov	r0, r4
    7e12:	bl	778e <SdSpiCard::spiStop()>
  return false;
    7e16:	movs	r5, #0
    7e18:	b.n	7e24 <SdSpiCard::erase(unsigned long, unsigned long)+0x8c>
    7e1a:	movs	r3, #38	; 0x26
    7e1c:	b.n	7e0e <SdSpiCard::erase(unsigned long, unsigned long)+0x76>
  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    error(SD_CARD_ERROR_ERASE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_ERASE_BUSY);
  spiStop();
    7e1e:	mov	r0, r4
    7e20:	bl	778e <SdSpiCard::spiStop()>
  return true;

 fail:
  spiStop();
  return false;
}
    7e24:	mov	r0, r5
    7e26:	add	sp, #16
    7e28:	pop	{r4, r5, r6, pc}

00007e2a <SdSpiCard::writeStop()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    7e2a:	push	{r3, r4, r5, lr}
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7e2c:	mov.w	r1, #600	; 0x258
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    7e30:	mov	r4, r0
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7e32:	bl	7926 <SdSpiCard::waitNotBusy(unsigned short)>
    7e36:	mov	r5, r0
    7e38:	cbz	r0, 7e44 <SdSpiCard::writeStop()+0x1a>
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_STOP);
  spiSend(STOP_TRAN_TOKEN);
    7e3a:	movs	r1, #253	; 0xfd
    7e3c:	ldr	r0, [r4, #4]
    7e3e:	bl	7748 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    7e42:	b.n	7e48 <SdSpiCard::writeStop()+0x1e>
    7e44:	movs	r3, #30
    7e46:	strb	r3, [r4, #15]
  spiStop();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
    7e48:	mov	r0, r4
    7e4a:	bl	778e <SdSpiCard::spiStop()>
  return false;
}
    7e4e:	mov	r0, r5
    7e50:	pop	{r3, r4, r5, pc}

00007e52 <SdSpiCard::writeData(unsigned char, unsigned char const*)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one sector of data for write sector or write multiple sectors
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    7e52:	push	{r3, r4, r5, lr}
    7e54:	mov	r4, r0
#if USE_SD_CRC
  uint16_t crc = CRC_CCITT(src, 512);
#else  // USE_SD_CRC
  uint16_t crc = 0XFFFF;
#endif  // USE_SD_CRC
  spiSend(token);
    7e56:	ldr	r0, [r0, #4]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one sector of data for write sector or write multiple sectors
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    7e58:	mov	r5, r2
#if USE_SD_CRC
  uint16_t crc = CRC_CCITT(src, 512);
#else  // USE_SD_CRC
  uint16_t crc = 0XFFFF;
#endif  // USE_SD_CRC
  spiSend(token);
    7e5a:	bl	7748 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    7e5e:	ldr	r0, [r4, #4]
  }
  void spiSend(uint8_t data) {
    m_spiDriverPtr->send(data);
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
    7e60:	ldr	r3, [r0, #0]
    7e62:	mov.w	r2, #512	; 0x200
    7e66:	ldr	r3, [r3, #24]
    7e68:	mov	r1, r5
    7e6a:	blx	r3
  spiSend(src, 512);
  spiSend(crc >> 8);
    7e6c:	movs	r1, #255	; 0xff
    7e6e:	ldr	r0, [r4, #4]
    7e70:	bl	7748 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
  spiSend(crc & 0XFF);
    7e74:	movs	r1, #255	; 0xff
    7e76:	ldr	r0, [r4, #4]
    7e78:	bl	7748 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>

  m_status = spiReceive();
    7e7c:	ldr	r0, [r4, #4]
    7e7e:	bl	774e <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7e82:	strb	r0, [r4, #17]
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    7e84:	and.w	r0, r0, #31
    7e88:	cmp	r0, #5
    7e8a:	beq.n	7e9a <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x48>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7e8c:	movs	r3, #32
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7e8e:	mov	r0, r4
    7e90:	strb	r3, [r4, #15]
    7e92:	bl	778e <SdSpiCard::spiStop()>
  return false;
    7e96:	movs	r0, #0
    7e98:	pop	{r3, r4, r5, pc}
  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    error(SD_CARD_ERROR_WRITE_DATA);
    goto fail;
  }
  return true;
    7e9a:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7e9c:	pop	{r3, r4, r5, pc}

00007e9e <SdSpiCard::writeData(unsigned char const*)>:
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    7e9e:	push	{r3, r4, r5, lr}
    7ea0:	mov	r5, r1
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7ea2:	mov.w	r1, #600	; 0x258
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    7ea6:	mov	r4, r0
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7ea8:	bl	7926 <SdSpiCard::waitNotBusy(unsigned short)>
    7eac:	cbnz	r0, 7eb4 <SdSpiCard::writeData(unsigned char const*)+0x16>
    7eae:	movs	r3, #36	; 0x24
    7eb0:	strb	r3, [r4, #15]
    7eb2:	b.n	7ec0 <SdSpiCard::writeData(unsigned char const*)+0x22>
    error(SD_CARD_ERROR_WRITE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_BUSY);
  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) {
    7eb4:	mov	r2, r5
    7eb6:	movs	r1, #252	; 0xfc
    7eb8:	mov	r0, r4
    7eba:	bl	7e52 <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    7ebe:	cbnz	r0, 7ec8 <SdSpiCard::writeData(unsigned char const*)+0x2a>
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7ec0:	mov	r0, r4
    7ec2:	bl	778e <SdSpiCard::spiStop()>
  return false;
    7ec6:	movs	r0, #0
}
    7ec8:	pop	{r3, r4, r5, pc}

00007eca <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7eca:	ldr	r3, [r0, #0]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    7ecc:	push	{r4, r5, r6, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7ece:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    7ed0:	mov	r5, r1
    7ed2:	mov	r4, r0
    7ed4:	mov	r6, r2
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7ed6:	blx	r3
    7ed8:	cmp	r0, #3
    sector <<= 9;
    7eda:	it	ne
    7edc:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD24, sector)) {
    7ede:	mov	r2, r5
    7ee0:	movs	r1, #24
    7ee2:	mov	r0, r4
    7ee4:	bl	794e <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7ee8:	cbz	r0, 7ef0 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x26>
    7eea:	movs	r3, #13
    7eec:	strb	r3, [r4, #15]
    7eee:	b.n	7f06 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x3c>
    error(SD_CARD_ERROR_CMD24);
    goto fail;
  }
  if (!writeData(DATA_START_SECTOR, src)) {
    7ef0:	mov	r2, r6
    7ef2:	movs	r1, #254	; 0xfe
    7ef4:	mov	r0, r4
    7ef6:	bl	7e52 <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    7efa:	mov	r5, r0
    7efc:	cbz	r0, 7f06 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x3c>
    error(SD_CARD_ERROR_CMD13);
    goto fail;
  }
#endif  // CHECK_FLASH_PROGRAMMING

  spiStop();
    7efe:	mov	r0, r4
    7f00:	bl	778e <SdSpiCard::spiStop()>
  return true;
    7f04:	b.n	7f0e <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x44>

 fail:
  spiStop();
    7f06:	mov	r0, r4
    7f08:	bl	778e <SdSpiCard::spiStop()>
  return false;
    7f0c:	movs	r5, #0
}
    7f0e:	mov	r0, r5
    7f10:	pop	{r4, r5, r6, pc}

00007f12 <SdSpiCard::writeSector(unsigned long, unsigned char const*)>:
   *
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    7f12:	push	{r4}
    if (m_sharedSpi) {
    7f14:	ldrb	r4, [r0, #13]
    7f16:	cbz	r4, 7f20 <SdSpiCard::writeSector(unsigned long, unsigned char const*)+0xe>
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    }
  }
    7f18:	ldr.w	r4, [sp], #4
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    7f1c:	b.w	7eca <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>
    } else {
      return writeSectors(sector, src, 1);
    7f20:	ldr	r3, [r0, #0]
    7f22:	ldr	r4, [r3, #36]	; 0x24
    7f24:	movs	r3, #1
    7f26:	mov	ip, r4
    }
  }
    7f28:	ldr.w	r4, [sp], #4
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    7f2c:	bx	ip
    7f2e:	Address 0x00007f2e is out of bounds.


00007f30 <sdIrs()>:
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
  SDHC_IRQSIGEN = 0;
    7f30:	ldr	r2, [pc, #24]	; (7f4c <sdIrs()+0x1c>)
  m_irqstat = SDHC_IRQSTAT;
    7f32:	ldr	r1, [pc, #28]	; (7f50 <sdIrs()+0x20>)
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
  SDHC_IRQSIGEN = 0;
    7f34:	movs	r3, #0
    7f36:	str	r3, [r2, #0]
  m_irqstat = SDHC_IRQSTAT;
    7f38:	ldr.w	r0, [r2, #-8]
    7f3c:	str	r0, [r1, #0]
  SDHC_IRQSTAT = m_irqstat;
    7f3e:	ldr	r1, [r1, #0]
    7f40:	str.w	r1, [r2, #-8]
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN);
#endif
  m_dmaBusy = false;
    7f44:	ldr	r2, [pc, #12]	; (7f54 <sdIrs()+0x24>)
    7f46:	strb	r3, [r2, #0]
    7f48:	bx	lr
    7f4a:	nop
    7f4c:	.word	0x400b1038
    7f50:	.word	0x2001ceec
    7f54:	.word	0x2001cf01

00007f58 <isBusyCommandComplete()>:
static bool isBusyCMD13() {
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
}
//------------------------------------------------------------------------------
static bool isBusyCommandComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_CC | SDHC_IRQSTAT_CMD_ERROR));
    7f58:	ldr	r3, [pc, #12]	; (7f68 <isBusyCommandComplete()+0x10>)
    7f5a:	ldr	r0, [pc, #16]	; (7f6c <isBusyCommandComplete()+0x14>)
    7f5c:	ldr	r3, [r3, #0]
    7f5e:	ands	r0, r3
}
    7f60:	clz	r0, r0
    7f64:	lsrs	r0, r0, #5
    7f66:	bx	lr
    7f68:	.word	0x400b1030
    7f6c:	.word	0x000f0001

00007f70 <isBusyCommandInhibit()>:
//------------------------------------------------------------------------------
static bool isBusyCommandInhibit() {
  return SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB;
    7f70:	ldr	r3, [pc, #8]	; (7f7c <isBusyCommandInhibit()+0xc>)
    7f72:	ldr	r0, [r3, #0]
}
    7f74:	and.w	r0, r0, #1
    7f78:	bx	lr
    7f7a:	nop
    7f7c:	.word	0x400b1024

00007f80 <isBusyDat()>:
//------------------------------------------------------------------------------
static bool isBusyDat() {
  return SDHC_PRSSTAT & (1 << 24) ? false : true;
    7f80:	ldr	r3, [pc, #12]	; (7f90 <isBusyDat()+0x10>)
    7f82:	ldr	r0, [r3, #0]
    7f84:	eor.w	r0, r0, #16777216	; 0x1000000
}
    7f88:	ubfx	r0, r0, #24, #1
    7f8c:	bx	lr
    7f8e:	nop
    7f90:	.word	0x400b1024

00007f94 <isBusyDMA()>:
//------------------------------------------------------------------------------
static bool isBusyDMA() {
  return m_dmaBusy;
    7f94:	ldr	r3, [pc, #4]	; (7f9c <isBusyDMA()+0x8>)
    7f96:	ldrb	r0, [r3, #0]
}
    7f98:	bx	lr
    7f9a:	nop
    7f9c:	.word	0x2001cf01

00007fa0 <isBusyFifoRead()>:
//------------------------------------------------------------------------------
static bool isBusyFifoRead() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BREN);
    7fa0:	ldr	r3, [pc, #12]	; (7fb0 <isBusyFifoRead()+0x10>)
    7fa2:	ldr	r0, [r3, #0]
    7fa4:	eor.w	r0, r0, #2048	; 0x800
}
    7fa8:	ubfx	r0, r0, #11, #1
    7fac:	bx	lr
    7fae:	nop
    7fb0:	.word	0x400b1024

00007fb4 <isBusyFifoWrite()>:
//------------------------------------------------------------------------------
static bool isBusyFifoWrite() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN);
    7fb4:	ldr	r3, [pc, #12]	; (7fc4 <isBusyFifoWrite()+0x10>)
    7fb6:	ldr	r0, [r3, #0]
    7fb8:	eor.w	r0, r0, #1024	; 0x400
}
    7fbc:	ubfx	r0, r0, #10, #1
    7fc0:	bx	lr
    7fc2:	nop
    7fc4:	.word	0x400b1024

00007fc8 <isBusyTransferComplete()>:
//------------------------------------------------------------------------------
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
    7fc8:	ldr	r3, [pc, #12]	; (7fd8 <isBusyTransferComplete()+0x10>)
    7fca:	ldr	r0, [pc, #16]	; (7fdc <isBusyTransferComplete()+0x14>)
    7fcc:	ldr	r3, [r3, #0]
    7fce:	ands	r0, r3
}
    7fd0:	clz	r0, r0
    7fd4:	lsrs	r0, r0, #5
    7fd6:	bx	lr
    7fd8:	.word	0x400b1030
    7fdc:	.word	0x117f0002

00007fe0 <setSdclk(unsigned long)>:
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    7fe0:	mov.w	r3, #1000	; 0x3e8
  }
  d[15] = 0;
  return true;
}
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
    7fe4:	push	{r4, r5, lr}
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    7fe6:	ldr	r4, [pc, #128]	; (8068 <setSdclk(unsigned long)+0x88>)
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    7fe8:	muls	r0, r3
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
    7fea:	movs	r2, #1
  uint32_t maxSdclk = 1000*kHzMax;
    7fec:	movs	r3, #9
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    7fee:	lsls	r1, r2, #4
    7ff0:	udiv	r1, r4, r1
    7ff4:	cmp	r0, r1
    7ff6:	bcc.n	8000 <setSdclk(unsigned long)+0x20>
    7ff8:	movs	r4, #1
    7ffa:	mov	r3, r2
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    7ffc:	ldr	r5, [pc, #104]	; (8068 <setSdclk(unsigned long)+0x88>)
    7ffe:	b.n	8014 <setSdclk(unsigned long)+0x34>
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    8000:	subs	r3, #1
    8002:	beq.n	7ff8 <setSdclk(unsigned long)+0x18>
    sdclkfs <<= 1;
    8004:	lsls	r2, r2, #1
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    8006:	b.n	7fee <setSdclk(unsigned long)+0xe>
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    8008:	cmp	r4, #16
    800a:	add.w	r1, r3, r2
    800e:	beq.n	801c <setSdclk(unsigned long)+0x3c>
    dvs++;
    8010:	adds	r4, #1
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    8012:	mov	r3, r1
    8014:	udiv	r1, r5, r3
    8018:	cmp	r0, r1
    801a:	bcc.n	8008 <setSdclk(unsigned long)+0x28>
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    801c:	mov.w	r1, #1000	; 0x3e8
    8020:	muls	r3, r1
    8022:	ldr	r1, [pc, #68]	; (8068 <setSdclk(unsigned long)+0x88>)
    8024:	udiv	r3, r1, r3
    8028:	ldr	r1, [pc, #64]	; (806c <setSdclk(unsigned long)+0x8c>)
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    802a:	ldr	r0, [pc, #68]	; (8070 <setSdclk(unsigned long)+0x90>)
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    802c:	str	r3, [r1, #0]
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    802e:	ldr	r3, [r0, #0]
    8030:	bic.w	r3, r3, #8
    8034:	str	r3, [r0, #0]
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)

  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
    8036:	ldr	r1, [r0, #0]
                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    8038:	bic.w	r3, r1, #1044480	; 0xff000
    803c:	lsls	r2, r2, #7
    803e:	bic.w	r3, r3, #4080	; 0xff0
    8042:	orr.w	r3, r3, #917504	; 0xe0000
    8046:	and.w	r2, r2, #65280	; 0xff00
    804a:	orrs	r2, r3
    804c:	subs	r3, r4, #1
    804e:	orr.w	r3, r2, r3, lsl #4

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    8052:	ldr	r2, [pc, #32]	; (8074 <setSdclk(unsigned long)+0x94>)
  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    8054:	str	r3, [r0, #0]

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    8056:	ldr	r3, [r2, #0]
    8058:	lsls	r3, r3, #28
    805a:	bpl.n	8056 <setSdclk(unsigned long)+0x76>
  }

#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Enable the SDHC clock.
  SDHC_SYSCTL |= SDHC_SYSCTL_SDCLKEN;
    805c:	ldr	r3, [r0, #0]
    805e:	orr.w	r3, r3, #8
    8062:	str	r3, [r0, #0]
    8064:	pop	{r4, r5, pc}
    8066:	nop
    8068:	.word	0x05b8d800
    806c:	.word	0x2001cf04
    8070:	.word	0x400b102c
    8074:	.word	0x400b1024

00008078 <SdioCard::errorCode() const>:
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::errorCode() const {
  return m_errorCode;
}
    8078:	ldr	r3, [pc, #4]	; (8080 <SdioCard::errorCode() const+0x8>)
    807a:	ldrb	r0, [r3, #0]
    807c:	bx	lr
    807e:	nop
    8080:	.word	0x1fff135c

00008084 <SdioCard::errorData() const>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorData() const {
  return m_irqstat;
    8084:	ldr	r3, [pc, #4]	; (808c <SdioCard::errorData() const+0x8>)
    8086:	ldr	r0, [r3, #0]
}
    8088:	bx	lr
    808a:	nop
    808c:	.word	0x2001ceec

00008090 <SdioCard::readCID(CID*)>:
uint32_t SdioCard::kHzSdClk() {
  return m_sdClkKhz;
}
//------------------------------------------------------------------------------
bool SdioCard::readCID(cid_t* cid) {
  memcpy(cid, &m_cid, 16);
    8090:	ldr	r3, [pc, #20]	; (80a8 <SdioCard::readCID(CID*)+0x18>)
    8092:	add.w	r2, r3, #16
    8096:	ldr.w	r0, [r3], #4
    809a:	str.w	r0, [r1], #4
    809e:	cmp	r3, r2
    80a0:	bne.n	8096 <SdioCard::readCID(CID*)+0x6>
  return true;
}
    80a2:	movs	r0, #1
    80a4:	bx	lr
    80a6:	nop
    80a8:	.word	0x2001cec5

000080ac <SdioCard::readCSD(csd_t*)>:
//------------------------------------------------------------------------------
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
    80ac:	ldr	r3, [pc, #20]	; (80c4 <SdioCard::readCSD(csd_t*)+0x18>)
    80ae:	add.w	r2, r3, #16
    80b2:	ldr.w	r0, [r3], #4
    80b6:	str.w	r0, [r1], #4
    80ba:	cmp	r3, r2
    80bc:	bne.n	80b2 <SdioCard::readCSD(csd_t*)+0x6>
  return true;
}
    80be:	movs	r0, #1
    80c0:	bx	lr
    80c2:	nop
    80c4:	.word	0x2001cef1

000080c8 <SdioCard::readOCR(unsigned long*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
    80c8:	ldr	r3, [pc, #8]	; (80d4 <SdioCard::readOCR(unsigned long*)+0xc>)
    80ca:	ldr	r3, [r3, #0]
    80cc:	str	r3, [r1, #0]
  return true;
}
    80ce:	movs	r0, #1
    80d0:	bx	lr
    80d2:	nop
    80d4:	.word	0x2001cee0

000080d8 <SdioCard::~SdioCard()>:
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    80d8:	bx	lr
    80da:	Address 0x000080da is out of bounds.


000080dc <waitTimeout(bool (*)())>:
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
    80dc:	push	{r3, r4, r5, r6, r7, lr}
    80de:	mov	r7, r0
  uint32_t m = micros();
    80e0:	bl	94d0 <micros>
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    80e4:	ldr	r5, [pc, #20]	; (80fc <waitTimeout(bool (*)())+0x20>)
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
  uint32_t m = micros();
    80e6:	mov	r6, r0
  while (fcn()) {
    80e8:	blx	r7
    80ea:	mov	r4, r0
    80ec:	cbz	r0, 80f8 <waitTimeout(bool (*)())+0x1c>
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    80ee:	bl	94d0 <micros>
    80f2:	subs	r0, r0, r6
    80f4:	cmp	r0, r5
    80f6:	bls.n	80e8 <waitTimeout(bool (*)())+0xc>
      return true;
    }
  }
  return false;  // Caller will set errorCode.
}
    80f8:	mov	r0, r4
    80fa:	pop	{r3, r4, r5, r6, r7, pc}
    80fc:	.word	0x000f4240

00008100 <yieldTimeout(bool (*)())>:
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    8100:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  m_busyFcn = fcn;
    8104:	ldr	r4, [pc, #48]	; (8138 <yieldTimeout(bool (*)())+0x38>)
  uint32_t m = micros();
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    8106:	ldr.w	r8, [pc, #52]	; 813c <yieldTimeout(bool (*)())+0x3c>
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
  m_busyFcn = fcn;
    810a:	str	r0, [r4, #0]
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    810c:	mov	r6, r0
  m_busyFcn = fcn;
  uint32_t m = micros();
    810e:	bl	94d0 <micros>
    8112:	mov	r7, r0
  while (fcn()) {
    8114:	blx	r6
    8116:	mov	r5, r0
    8118:	cbz	r0, 8130 <yieldTimeout(bool (*)())+0x30>
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    811a:	bl	94d0 <micros>
    811e:	subs	r0, r0, r7
    8120:	cmp	r0, r8
    8122:	bls.n	812a <yieldTimeout(bool (*)())+0x2a>
      m_busyFcn = 0;
    8124:	movs	r3, #0
    8126:	str	r3, [r4, #0]
      return true;
    8128:	b.n	8132 <yieldTimeout(bool (*)())+0x32>
  }
}
#elif defined(ARDUINO)
inline void SysCall::yield() {
  // Use the external Arduino yield() function.
  ::yield();
    812a:	bl	9f10 <yield>
    812e:	b.n	8114 <yieldTimeout(bool (*)())+0x14>
    }
    SysCall::yield();
  }
  m_busyFcn = 0;
    8130:	str	r0, [r4, #0]
  return false;  // Caller will set errorCode.
}
    8132:	mov	r0, r5
    8134:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8138:	.word	0x2001ced8
    813c:	.word	0x000f4240

00008140 <SdioCard::~SdioCard()>:
    8140:	push	{r4, lr}
    8142:	movs	r1, #12
    8144:	mov	r4, r0
    8146:	bl	a374 <operator delete(void*, unsigned int)>
    814a:	mov	r0, r4
    814c:	pop	{r4, pc}
    814e:	Address 0x0000814e is out of bounds.


00008150 <SdioCard::type() const>:
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
    8150:	ldr	r3, [pc, #20]	; (8168 <SdioCard::type() const+0x18>)
    8152:	ldrb	r3, [r3, #0]
    8154:	cbz	r3, 8164 <SdioCard::type() const+0x14>
    8156:	ldr	r3, [pc, #20]	; (816c <SdioCard::type() const+0x1c>)
    8158:	ldrb	r3, [r3, #0]
    815a:	cmp	r3, #0
    815c:	ite	ne
    815e:	movne	r0, #3
    8160:	moveq	r0, #2
    8162:	bx	lr
    8164:	movs	r0, #1
}
    8166:	bx	lr
    8168:	.word	0x2001cec4
    816c:	.word	0x2001cedc

00008170 <cardCommand(unsigned long, unsigned long)>:
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    8170:	push	{r3, r4, r5, lr}
    8172:	mov	r4, r0
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    8174:	ldr	r0, [pc, #56]	; (81b0 <cardCommand(unsigned long, unsigned long)+0x40>)
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    8176:	mov	r5, r1
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    8178:	bl	80dc <waitTimeout(bool (*)())>
    817c:	cbnz	r0, 81a6 <cardCommand(unsigned long, unsigned long)+0x36>
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    817e:	ldr	r3, [pc, #52]	; (81b4 <cardCommand(unsigned long, unsigned long)+0x44>)
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
  if (waitTimeout(isBusyCommandComplete)) {
    8180:	ldr	r0, [pc, #52]	; (81b8 <cardCommand(unsigned long, unsigned long)+0x48>)
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    8182:	str	r5, [r3, #0]
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MASK;
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
    8184:	str	r4, [r3, #4]
  if (waitTimeout(isBusyCommandComplete)) {
    8186:	bl	80dc <waitTimeout(bool (*)())>
    818a:	cbnz	r0, 81a6 <cardCommand(unsigned long, unsigned long)+0x36>
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
    818c:	ldr	r2, [pc, #44]	; (81bc <cardCommand(unsigned long, unsigned long)+0x4c>)
    818e:	ldr	r3, [pc, #48]	; (81c0 <cardCommand(unsigned long, unsigned long)+0x50>)
    8190:	ldr	r1, [r2, #0]
    8192:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    8194:	ldr	r1, [r3, #0]
    8196:	str	r1, [r2, #0]

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    8198:	ldr	r2, [r3, #0]
    819a:	lsls	r2, r2, #31
    819c:	bpl.n	81a6 <cardCommand(unsigned long, unsigned long)+0x36>
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
    819e:	ldr	r3, [r3, #0]
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    81a0:	tst.w	r3, #983040	; 0xf0000
    81a4:	beq.n	81aa <cardCommand(unsigned long, unsigned long)+0x3a>
    81a6:	movs	r0, #0
    81a8:	pop	{r3, r4, r5, pc}
    81aa:	movs	r0, #1
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
    81ac:	pop	{r3, r4, r5, pc}
    81ae:	nop
    81b0:	.word	0x00007f71
    81b4:	.word	0x400b1008
    81b8:	.word	0x00007f59
    81bc:	.word	0x400b1030
    81c0:	.word	0x2001ceec

000081c4 <statusCMD13()>:
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
  }
}
//------------------------------------------------------------------------------
static uint32_t statusCMD13() {
    81c4:	push	{r3, lr}
  return cardCommand(CMD13_XFERTYP, m_rca) ? SDHC_CMDRSP0 : 0;
    81c6:	ldr	r3, [pc, #16]	; (81d8 <statusCMD13()+0x14>)
    81c8:	ldr	r0, [pc, #16]	; (81dc <statusCMD13()+0x18>)
    81ca:	ldr	r1, [r3, #0]
    81cc:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    81d0:	cbz	r0, 81d6 <statusCMD13()+0x12>
    81d2:	ldr	r3, [pc, #12]	; (81e0 <statusCMD13()+0x1c>)
    81d4:	ldr	r0, [r3, #0]
}
    81d6:	pop	{r3, pc}
    81d8:	.word	0x2001cee4
    81dc:	.word	0x0d1a0000
    81e0:	.word	0x400b1010

000081e4 <isBusyCMD13()>:
//------------------------------------------------------------------------------
static bool isBusyCMD13() {
    81e4:	push	{r3, lr}
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
    81e6:	bl	81c4 <statusCMD13()>
    81ea:	eor.w	r0, r0, #256	; 0x100
}
    81ee:	ubfx	r0, r0, #8, #1
    81f2:	pop	{r3, pc}

000081f4 <SdioCard::status()>:
uint32_t SdioCard::sectorCount() {
  return sdCardCapacity(&m_csd);
}
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
    81f4:	b.w	81c4 <statusCMD13()>

000081f8 <readReg16(unsigned long, void*)>:
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    81f8:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    81fa:	ldr	r3, [pc, #80]	; (824c <readReg16(unsigned long, void*)+0x54>)
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    81fc:	mov	r5, r1
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    81fe:	ldr	r1, [r3, #0]
    8200:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    8204:	cbz	r0, 8246 <readReg16(unsigned long, void*)+0x4e>
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
    8206:	ldr	r3, [pc, #72]	; (8250 <readReg16(unsigned long, void*)+0x58>)
    8208:	ldr	r3, [r3, #0]
    820a:	str	r3, [sp, #0]
    820c:	ldr	r3, [pc, #68]	; (8254 <readReg16(unsigned long, void*)+0x5c>)
    820e:	ldr	r3, [r3, #0]
    8210:	str	r3, [sp, #4]
    8212:	ldr	r3, [pc, #68]	; (8258 <readReg16(unsigned long, void*)+0x60>)
    8214:	ldr	r3, [r3, #0]
    8216:	str	r3, [sp, #8]
    8218:	ldr	r3, [pc, #64]	; (825c <readReg16(unsigned long, void*)+0x64>)
    821a:	ldr	r3, [r3, #0]
    821c:	str	r3, [sp, #12]
    821e:	add.w	r6, r5, #15
  for (int i = 0; i < 15; i++) {
    8222:	movs	r3, #0
    d[14 - i] = sr[i/4] >> 8*(i%4);
    8224:	bic.w	r4, r3, #3
    8228:	add	r2, sp, #16
    822a:	add	r4, r2
    822c:	and.w	r2, r3, #3
    8230:	lsls	r1, r2, #3
    8232:	ldr.w	r2, [r4, #-16]
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    8236:	adds	r3, #1
    d[14 - i] = sr[i/4] >> 8*(i%4);
    8238:	lsrs	r2, r1
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    823a:	cmp	r3, #15
    d[14 - i] = sr[i/4] >> 8*(i%4);
    823c:	strb.w	r2, [r6, #-1]!
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    8240:	bne.n	8224 <readReg16(unsigned long, void*)+0x2c>
    d[14 - i] = sr[i/4] >> 8*(i%4);
  }
  d[15] = 0;
    8242:	movs	r3, #0
    8244:	strb	r3, [r5, #15]
  return true;
}
    8246:	add	sp, #16
    8248:	pop	{r4, r5, r6, pc}
    824a:	nop
    824c:	.word	0x2001cee4
    8250:	.word	0x400b1010
    8254:	.word	0x400b1014
    8258:	.word	0x400b1018
    825c:	.word	0x400b101c

00008260 <waitDmaStatus() [clone .part.4]>:
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    return false;  // Caller will set errorCode.
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    8260:	ldr	r3, [pc, #20]	; (8278 <waitDmaStatus() [clone .part.4]+0x18>)
    8262:	ldr	r0, [r3, #0]
    8264:	ands.w	r0, r0, #2
    8268:	beq.n	8276 <waitDmaStatus() [clone .part.4]+0x16>
    826a:	ldr	r3, [r3, #0]
    826c:	ldr	r0, [pc, #12]	; (827c <waitDmaStatus() [clone .part.4]+0x1c>)
    826e:	ands	r0, r3
    8270:	clz	r0, r0
    8274:	lsrs	r0, r0, #5
}
    8276:	bx	lr
    8278:	.word	0x2001ceec
    827c:	.word	0x117f0000

00008280 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>:
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
}
//------------------------------------------------------------------------------
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
    8280:	push	{r3, r4, r5, r6, r7, lr}
    8282:	mov	r4, r3
  if ((3 & (uint32_t)buf) || n == 0) {
    8284:	lsls	r3, r2, #30
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
}
//------------------------------------------------------------------------------
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
    8286:	mov	r7, r0
    8288:	mov	r5, r1
    828a:	mov	r6, r2
  if ((3 & (uint32_t)buf) || n == 0) {
    828c:	bne.n	8290 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x10>
    828e:	cbnz	r4, 829c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x1c>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8290:	ldr	r3, [pc, #100]	; (82f8 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x78>)
    8292:	movs	r2, #37	; 0x25
    8294:	strb	r2, [r3, #0]
  m_errorLine = line;
    8296:	mov.w	r2, #506	; 0x1fa
    829a:	b.n	82ae <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x2e>
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    829c:	ldr	r0, [pc, #92]	; (82fc <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x7c>)
    829e:	bl	8100 <yieldTimeout(bool (*)())>
    82a2:	cbz	r0, 82b4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x34>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    82a4:	ldr	r3, [pc, #80]	; (82f8 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x78>)
    82a6:	movs	r2, #10
    82a8:	strb	r2, [r3, #0]
  m_errorLine = line;
    82aa:	movw	r2, #509	; 0x1fd
    82ae:	ldr	r3, [pc, #80]	; (8300 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x80>)
    82b0:	str	r2, [r3, #0]
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    82b2:	b.n	82f2 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    82b4:	ldr	r3, [pc, #76]	; (8304 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x84>)
    82b6:	movs	r2, #1
    82b8:	strb	r2, [r3, #0]
  m_irqstat = 0;
    82ba:	ldr	r3, [pc, #76]	; (8308 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x88>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    82bc:	ldr	r2, [pc, #76]	; (830c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x8c>)
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    82be:	str	r0, [r3, #0]
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    82c0:	lsls	r4, r4, #16
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    82c2:	ldr	r3, [pc, #76]	; (8310 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x90>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    82c4:	orr.w	r4, r4, #512	; 0x200
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    82c8:	str	r6, [r3, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    82ca:	str	r4, [r3, #4]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    82cc:	str	r2, [r3, #56]	; 0x38
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    82ce:	ldr	r3, [pc, #68]	; (8314 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x94>)
    82d0:	ldrb	r3, [r3, #0]
    82d2:	cbnz	r3, 82d8 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x58>
    82d4:	lsls	r1, r5, #9
    82d6:	b.n	82da <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x5a>
    82d8:	mov	r1, r5
    82da:	mov	r0, r7
    82dc:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    82e0:	cbz	r0, 82f2 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    82e2:	ldr	r0, [pc, #52]	; (8318 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x98>)
    82e4:	bl	8100 <yieldTimeout(bool (*)())>
    82e8:	cbnz	r0, 82f2 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    return false;
  }
  return waitDmaStatus();
}
    82ea:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    82ee:	b.w	8260 <waitDmaStatus() [clone .part.4]>
    82f2:	movs	r0, #0
    82f4:	pop	{r3, r4, r5, r6, r7, pc}
    82f6:	nop
    82f8:	.word	0x1fff135c
    82fc:	.word	0x000081e5
    8300:	.word	0x2001cf08
    8304:	.word	0x2001cf01
    8308:	.word	0x2001ceec
    830c:	.word	0x117f0002
    8310:	.word	0x400b1000
    8314:	.word	0x2001cedc
    8318:	.word	0x00007f95

0000831c <SdioCard::sectorCount()>:
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    831c:	ldr	r2, [pc, #92]	; (837c <SdioCard::sectorCount()+0x60>)
    831e:	ldrb	r3, [r2, #0]
    8320:	ands.w	r3, r3, #192	; 0xc0
    8324:	bne.n	835a <SdioCard::sectorCount()+0x3e>
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    8326:	ldrb	r0, [r2, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    8328:	ldrb	r3, [r2, #7]
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    832a:	ldrb	r1, [r2, #10]
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    832c:	and.w	r0, r0, #3
    8330:	lsls	r3, r3, #2
    8332:	orr.w	r3, r3, r0, lsl #10
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    8336:	ldrb	r0, [r2, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    8338:	orr.w	r0, r3, r0, lsr #6
    833c:	adds	r3, r0, #1
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    833e:	ldrb	r0, [r2, #9]
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    8340:	ldrb	r2, [r2, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    8342:	and.w	r0, r0, #3
    8346:	lsls	r0, r0, #1
    8348:	orr.w	r0, r0, r1, lsr #7
    834c:	and.w	r2, r2, #15
    8350:	add	r0, r2
    8352:	subs	r0, #7
    8354:	lsl.w	r0, r3, r0
    8358:	bx	lr
  } else if (csd->v2.csd_ver == 1) {
    835a:	cmp	r3, #64	; 0x40
    835c:	bne.n	8376 <SdioCard::sectorCount()+0x5a>
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    835e:	ldrb	r0, [r2, #9]
    8360:	adds	r3, r0, #1
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    8362:	ldrb	r0, [r2, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    8364:	and.w	r0, r0, #63	; 0x3f
    8368:	add.w	r0, r3, r0, lsl #16
    836c:	ldrb	r3, [r2, #8]
    836e:	add.w	r0, r0, r3, lsl #8
    8372:	lsls	r0, r0, #10
    8374:	bx	lr
  } else {
    return 0;
    8376:	movs	r0, #0
  return transferStop();
}
//------------------------------------------------------------------------------
uint32_t SdioCard::sectorCount() {
  return sdCardCapacity(&m_csd);
}
    8378:	bx	lr
    837a:	nop
    837c:	.word	0x2001cef1

00008380 <SdioCard::erase(unsigned long, unsigned long)>:
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    8380:	push	{r4, r5, r6, lr}
    8382:	mov	r6, r2
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    8384:	ldrb	r2, [r0, #9]
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    8386:	mov	r5, r1
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    8388:	cbz	r2, 8396 <SdioCard::erase(unsigned long, unsigned long)+0x16>
    838a:	ldr	r3, [r0, #0]
    838c:	ldr	r3, [r3, #28]
    838e:	blx	r3
    8390:	mov	r4, r0
    8392:	cmp	r0, #0
    8394:	beq.n	8432 <SdioCard::erase(unsigned long, unsigned long)+0xb2>
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  // check for single sector erase
  if (!m_csd.v1.erase_blk_en) {
    8396:	ldr	r1, [pc, #160]	; (8438 <SdioCard::erase(unsigned long, unsigned long)+0xb8>)
    8398:	ldrb	r3, [r1, #10]
    839a:	and.w	r2, r3, #64	; 0x40
    839e:	and.w	r4, r2, #255	; 0xff
    83a2:	cbnz	r2, 83c4 <SdioCard::erase(unsigned long, unsigned long)+0x44>
    // erase size mask
    uint8_t m = (m_csd.v1.sector_size_high << 1) | m_csd.v1.sector_size_low;
    83a4:	ldrb	r2, [r1, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    83a6:	and.w	r3, r3, #63	; 0x3f
    83aa:	lsls	r3, r3, #1
    83ac:	orr.w	r3, r3, r2, lsr #7
    83b0:	adds	r2, r6, #1
    83b2:	orrs	r2, r5
    83b4:	tst	r3, r2
    83b6:	beq.n	83c4 <SdioCard::erase(unsigned long, unsigned long)+0x44>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    83b8:	ldr	r3, [pc, #128]	; (843c <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    83ba:	movs	r2, #39	; 0x27
    83bc:	strb	r2, [r3, #0]
  m_errorLine = line;
    83be:	movw	r2, #747	; 0x2eb
    83c2:	b.n	8414 <SdioCard::erase(unsigned long, unsigned long)+0x94>
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
      // error card can't erase specified area
      return sdError(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
    }
  }
  if (!m_highCapacity) {
    83c4:	ldr	r3, [pc, #120]	; (8440 <SdioCard::erase(unsigned long, unsigned long)+0xc0>)
    83c6:	ldrb	r3, [r3, #0]
    83c8:	cbnz	r3, 83ce <SdioCard::erase(unsigned long, unsigned long)+0x4e>
    firstSector <<= 9;
    83ca:	lsls	r5, r5, #9
    lastSector <<= 9;
    83cc:	lsls	r6, r6, #9
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    83ce:	mov	r1, r5
    83d0:	ldr	r0, [pc, #112]	; (8444 <SdioCard::erase(unsigned long, unsigned long)+0xc4>)
    83d2:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    83d6:	mov	r4, r0
    83d8:	cbnz	r0, 83e6 <SdioCard::erase(unsigned long, unsigned long)+0x66>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    83da:	ldr	r3, [pc, #96]	; (843c <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    83dc:	movs	r2, #15
    83de:	strb	r2, [r3, #0]
  m_errorLine = line;
    83e0:	movw	r2, #755	; 0x2f3
    83e4:	b.n	8414 <SdioCard::erase(unsigned long, unsigned long)+0x94>
    lastSector <<= 9;
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
    83e6:	mov	r1, r6
    83e8:	ldr	r0, [pc, #92]	; (8448 <SdioCard::erase(unsigned long, unsigned long)+0xc8>)
    83ea:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    83ee:	mov	r4, r0
    83f0:	cbnz	r0, 83fe <SdioCard::erase(unsigned long, unsigned long)+0x7e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    83f2:	ldr	r3, [pc, #72]	; (843c <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    83f4:	movs	r2, #16
    83f6:	strb	r2, [r3, #0]
  m_errorLine = line;
    83f8:	movw	r2, #758	; 0x2f6
    83fc:	b.n	8414 <SdioCard::erase(unsigned long, unsigned long)+0x94>
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    83fe:	movs	r1, #0
    8400:	ldr	r0, [pc, #72]	; (844c <SdioCard::erase(unsigned long, unsigned long)+0xcc>)
    8402:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    8406:	mov	r4, r0
    8408:	cbnz	r0, 841a <SdioCard::erase(unsigned long, unsigned long)+0x9a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    840a:	ldr	r3, [pc, #48]	; (843c <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    840c:	movs	r2, #17
    840e:	strb	r2, [r3, #0]
  m_errorLine = line;
    8410:	movw	r2, #761	; 0x2f9
    8414:	ldr	r3, [pc, #56]	; (8450 <SdioCard::erase(unsigned long, unsigned long)+0xd0>)
    8416:	str	r2, [r3, #0]
    8418:	b.n	8432 <SdioCard::erase(unsigned long, unsigned long)+0xb2>
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    841a:	ldr	r0, [pc, #56]	; (8454 <SdioCard::erase(unsigned long, unsigned long)+0xd4>)
    841c:	bl	80dc <waitTimeout(bool (*)())>
    8420:	cbz	r0, 8432 <SdioCard::erase(unsigned long, unsigned long)+0xb2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8422:	ldr	r3, [pc, #24]	; (843c <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    8424:	movs	r2, #40	; 0x28
    8426:	strb	r2, [r3, #0]
  m_errorLine = line;
    8428:	ldr	r3, [pc, #36]	; (8450 <SdioCard::erase(unsigned long, unsigned long)+0xd0>)
    842a:	mov.w	r2, #764	; 0x2fc
    842e:	str	r2, [r3, #0]
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
    8430:	movs	r4, #0
  }
  return true;
}
    8432:	mov	r0, r4
    8434:	pop	{r4, r5, r6, pc}
    8436:	nop
    8438:	.word	0x2001cef1
    843c:	.word	0x1fff135c
    8440:	.word	0x2001cedc
    8444:	.word	0x201a0000
    8448:	.word	0x211a0000
    844c:	.word	0x261b0000
    8450:	.word	0x2001cf08
    8454:	.word	0x000081e5

00008458 <waitTransferComplete()>:
  }
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
    8458:	push	{r4, lr}
  if (!m_transferActive) {
    845a:	ldr	r4, [pc, #60]	; (8498 <waitTransferComplete()+0x40>)
    845c:	ldrb	r3, [r4, #0]
    845e:	cbnz	r3, 8464 <waitTransferComplete()+0xc>
    return true;
    8460:	movs	r0, #1
    8462:	pop	{r4, pc}
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
    8464:	ldr	r0, [pc, #52]	; (849c <waitTransferComplete()+0x44>)
    8466:	bl	80dc <waitTimeout(bool (*)())>
  m_transferActive = false;
    846a:	movs	r3, #0
  m_irqstat = SDHC_IRQSTAT;
    846c:	ldr	r2, [pc, #48]	; (84a0 <waitTransferComplete()+0x48>)
static bool waitTransferComplete() {
  if (!m_transferActive) {
    return true;
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
    846e:	strb	r3, [r4, #0]
  m_irqstat = SDHC_IRQSTAT;
    8470:	ldr	r3, [pc, #48]	; (84a4 <waitTransferComplete()+0x4c>)
    8472:	ldr	r1, [r2, #0]
    8474:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    8476:	ldr	r1, [r3, #0]
    8478:	str	r1, [r2, #0]
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    847a:	cbnz	r0, 8486 <waitTransferComplete()+0x2e>
    847c:	ldr	r2, [r3, #0]
    847e:	ldr	r3, [pc, #40]	; (84a8 <waitTransferComplete()+0x50>)
    8480:	ands	r3, r2
    8482:	cmp	r3, #0
    8484:	beq.n	8460 <waitTransferComplete()+0x8>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8486:	ldr	r3, [pc, #36]	; (84ac <waitTransferComplete()+0x54>)
    8488:	movs	r2, #31
    848a:	strb	r2, [r3, #0]
  m_errorLine = line;
    848c:	ldr	r3, [pc, #32]	; (84b0 <waitTransferComplete()+0x58>)
    848e:	movw	r2, #641	; 0x281
    8492:	str	r2, [r3, #0]
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    return sdError(SD_CARD_ERROR_TRANSFER_COMPLETE);
    8494:	movs	r0, #0
  }
  return true;
}
    8496:	pop	{r4, pc}
    8498:	.word	0x2001cee8
    849c:	.word	0x00007fc9
    84a0:	.word	0x400b1030
    84a4:	.word	0x2001ceec
    84a8:	.word	0x117f0000
    84ac:	.word	0x1fff135c
    84b0:	.word	0x2001cf08

000084b4 <SdioCard::readStop()>:
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
    84b4:	push	{r4, r5, r6, lr}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    84b6:	ldr	r4, [pc, #100]	; (851c <SdioCard::readStop()+0x68>)
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    84b8:	ldr	r0, [pc, #100]	; (8520 <SdioCard::readStop()+0x6c>)
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    84ba:	ldr	r3, [r4, #0]
    84bc:	bic.w	r3, r3, #65536	; 0x10000
    84c0:	str	r3, [r4, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    84c2:	movs	r1, #0
    84c4:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    84c8:	mov	r5, r0
    84ca:	cbnz	r0, 84dc <SdioCard::readStop()+0x28>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    84cc:	ldr	r3, [pc, #84]	; (8524 <SdioCard::readStop()+0x70>)
    84ce:	movs	r2, #9
    84d0:	strb	r2, [r3, #0]
  m_errorLine = line;
    84d2:	ldr	r3, [pc, #84]	; (8528 <SdioCard::readStop()+0x74>)
    84d4:	movw	r2, #578	; 0x242
    84d8:	str	r2, [r3, #0]
    84da:	b.n	8516 <SdioCard::readStop()+0x62>
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    84dc:	ldr	r0, [pc, #76]	; (852c <SdioCard::readStop()+0x78>)
    84de:	bl	8100 <yieldTimeout(bool (*)())>
    84e2:	cbz	r0, 84f6 <SdioCard::readStop()+0x42>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    84e4:	ldr	r3, [pc, #60]	; (8524 <SdioCard::readStop()+0x70>)
    84e6:	movs	r2, #10
    84e8:	strb	r2, [r3, #0]
  m_errorLine = line;
    84ea:	ldr	r3, [pc, #60]	; (8528 <SdioCard::readStop()+0x74>)
    84ec:	movw	r2, #582	; 0x246
    84f0:	str	r2, [r3, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    return sdError(SD_CARD_ERROR_CMD13);
    84f2:	movs	r5, #0
    84f4:	b.n	8516 <SdioCard::readStop()+0x62>
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    84f6:	ldr	r3, [pc, #56]	; (8530 <SdioCard::readStop()+0x7c>)
    84f8:	ldr	r3, [r3, #0]
    84fa:	lsls	r3, r3, #30
    84fc:	bpl.n	8516 <SdioCard::readStop()+0x62>
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    84fe:	ldr	r1, [pc, #52]	; (8534 <SdioCard::readStop()+0x80>)
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    8500:	ldr	r0, [pc, #52]	; (8538 <SdioCard::readStop()+0x84>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    8502:	ldr	r6, [r1, #0]
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    8504:	ldr	r3, [r4, #0]
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    8506:	ldr	r2, [r0, #0]
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    8508:	bic.w	r3, r3, #65536	; 0x10000
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    850c:	orr.w	r2, r2, #67108864	; 0x4000000
    8510:	str	r2, [r0, #0]
    // Restore registers.
    SDHC_IRQSTATEN = irqsststen;
    8512:	str	r6, [r1, #0]
    SDHC_PROCTL = proctl;
    8514:	str	r3, [r4, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
}
    8516:	mov	r0, r5
    8518:	pop	{r4, r5, r6, pc}
    851a:	nop
    851c:	.word	0x400b1028
    8520:	.word	0x0cdb0000
    8524:	.word	0x1fff135c
    8528:	.word	0x2001cf08
    852c:	.word	0x00007f81
    8530:	.word	0x400b1024
    8534:	.word	0x400b1034
    8538:	.word	0x400b102c

0000853c <SdioCard::writeData(unsigned char const*)>:
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
}
//------------------------------------------------------------------------------
bool SdioCard::writeData(const uint8_t* src) {
    853c:	push	{r4, r5, r6, lr}
    853e:	mov	r4, r1
  DBG_IRQSTAT();
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    8540:	bl	8458 <waitTransferComplete()>
    8544:	mov	r6, r0
    8546:	cmp	r0, #0
    8548:	beq.n	85b0 <SdioCard::writeData(unsigned char const*)+0x74>
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    854a:	ldr	r5, [pc, #104]	; (85b4 <SdioCard::writeData(unsigned char const*)+0x78>)
    854c:	ldr	r3, [r5, #0]
    854e:	tst.w	r3, #256	; 0x100
    8552:	ldr	r3, [pc, #100]	; (85b8 <SdioCard::writeData(unsigned char const*)+0x7c>)
    8554:	bne.n	8566 <SdioCard::writeData(unsigned char const*)+0x2a>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8556:	ldr	r2, [r3, #0]
    8558:	bic.w	r2, r2, #65536	; 0x10000
    855c:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    855e:	ldr	r2, [r3, #0]
    8560:	orr.w	r2, r2, #131072	; 0x20000
    8564:	str	r2, [r3, #0]
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    8566:	ldr	r2, [r3, #0]
  if (waitTimeout(isBusyFifoWrite)) {
    8568:	ldr	r0, [pc, #80]	; (85bc <SdioCard::writeData(unsigned char const*)+0x80>)
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    856a:	orr.w	r2, r2, #65536	; 0x10000
    856e:	str	r2, [r3, #0]
  if (waitTimeout(isBusyFifoWrite)) {
    8570:	bl	80dc <waitTimeout(bool (*)())>
    8574:	cbnz	r0, 85a0 <SdioCard::writeData(unsigned char const*)+0x64>
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    8576:	ldr	r1, [pc, #72]	; (85c0 <SdioCard::writeData(unsigned char const*)+0x84>)
    8578:	subs	r3, r4, #4
    857a:	add.w	r4, r4, #508	; 0x1fc
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    857e:	ldr	r2, [r5, #0]
    8580:	lsls	r2, r2, #21
    8582:	bpl.n	857e <SdioCard::writeData(unsigned char const*)+0x42>
    8584:	add.w	r2, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    8588:	ldr.w	r0, [r3, #4]!
    858c:	str	r0, [r1, #0]
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    858e:	cmp	r2, r3
    8590:	bne.n	8588 <SdioCard::writeData(unsigned char const*)+0x4c>
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    8592:	cmp	r4, r2
    8594:	mov	r3, r2
    8596:	bne.n	857e <SdioCard::writeData(unsigned char const*)+0x42>
      SDHC_DATPORT = p32[i];
    }
    p32 += FIFO_WML;
  }
#if ENABLE_TEENSY_SDIO_MOD
  m_transferActive = true;
    8598:	ldr	r3, [pc, #40]	; (85c4 <SdioCard::writeData(unsigned char const*)+0x88>)
    859a:	movs	r2, #1
    859c:	strb	r2, [r3, #0]
    859e:	b.n	85b0 <SdioCard::writeData(unsigned char const*)+0x74>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    85a0:	ldr	r3, [pc, #36]	; (85c8 <SdioCard::writeData(unsigned char const*)+0x8c>)
    85a2:	movs	r2, #33	; 0x21
    85a4:	strb	r2, [r3, #0]
  m_errorLine = line;
    85a6:	ldr	r3, [pc, #36]	; (85cc <SdioCard::writeData(unsigned char const*)+0x90>)
    85a8:	movw	r2, #1015	; 0x3f7
    85ac:	str	r2, [r3, #0]
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
    85ae:	movs	r6, #0
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    85b0:	mov	r0, r6
    85b2:	pop	{r4, r5, r6, pc}
    85b4:	.word	0x400b1024
    85b8:	.word	0x400b1028
    85bc:	.word	0x00007fb5
    85c0:	.word	0x400b1020
    85c4:	.word	0x2001cee8
    85c8:	.word	0x1fff135c
    85cc:	.word	0x2001cf08

000085d0 <SdioCard::writeStart(unsigned long)>:
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    85d0:	push	{r4, lr}
  if (yieldTimeout(isBusyCMD13)) {
    85d2:	ldr	r0, [pc, #80]	; (8624 <SdioCard::writeStart(unsigned long)+0x54>)
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    85d4:	mov	r4, r1
  if (yieldTimeout(isBusyCMD13)) {
    85d6:	bl	8100 <yieldTimeout(bool (*)())>
    85da:	cbz	r0, 85ee <SdioCard::writeStart(unsigned long)+0x1e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    85dc:	ldr	r3, [pc, #72]	; (8628 <SdioCard::writeStart(unsigned long)+0x58>)
    85de:	movs	r2, #10
    85e0:	strb	r2, [r3, #0]
  m_errorLine = line;
    85e2:	ldr	r3, [pc, #72]	; (862c <SdioCard::writeStart(unsigned long)+0x5c>)
    85e4:	movw	r2, #1119	; 0x45f
    85e8:	str	r2, [r3, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    85ea:	movs	r0, #0
    85ec:	pop	{r4, pc}
  }
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    85ee:	ldr	r2, [pc, #64]	; (8630 <SdioCard::writeStart(unsigned long)+0x60>)
    85f0:	ldr	r3, [r2, #0]
    85f2:	bic.w	r3, r3, #65536	; 0x10000
    85f6:	str	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    85f8:	ldr	r3, [pc, #56]	; (8634 <SdioCard::writeStart(unsigned long)+0x64>)
    85fa:	ldr	r2, [pc, #60]	; (8638 <SdioCard::writeStart(unsigned long)+0x68>)
    85fc:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    85fe:	ldr	r3, [pc, #60]	; (863c <SdioCard::writeStart(unsigned long)+0x6c>)
    8600:	ldrb	r3, [r3, #0]
    8602:	cbnz	r3, 8608 <SdioCard::writeStart(unsigned long)+0x38>
    8604:	lsls	r1, r4, #9
    8606:	b.n	860a <SdioCard::writeStart(unsigned long)+0x3a>
    8608:	mov	r1, r4
    860a:	ldr	r0, [pc, #52]	; (8640 <SdioCard::writeStart(unsigned long)+0x70>)
    860c:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    8610:	cbnz	r0, 8620 <SdioCard::writeStart(unsigned long)+0x50>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8612:	ldr	r3, [pc, #20]	; (8628 <SdioCard::writeStart(unsigned long)+0x58>)
    8614:	movs	r2, #14
    8616:	strb	r2, [r3, #0]
  m_errorLine = line;
    8618:	ldr	r3, [pc, #16]	; (862c <SdioCard::writeStart(unsigned long)+0x5c>)
    861a:	movw	r2, #1131	; 0x46b
    861e:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
    8620:	pop	{r4, pc}
    8622:	nop
    8624:	.word	0x000081e5
    8628:	.word	0x1fff135c
    862c:	.word	0x2001cf08
    8630:	.word	0x400b1028
    8634:	.word	0x400b1004
    8638:	.word	0xffff0200
    863c:	.word	0x2001cedc
    8640:	.word	0x193a0022

00008644 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    8644:	push	{r3, r4, r5, r6, r7, lr}
    8646:	mov	r7, r0
    8648:	mov	r4, r1
  if (m_sdioConfig.useDma()) {
    864a:	ldrb	r6, [r7, #8]
    864c:	lsls	r6, r6, #31
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    864e:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    8650:	bpl.n	868e <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x4a>
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
    8652:	lsls	r6, r2, #30
    8654:	beq.n	8676 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x32>
    8656:	adds	r6, r1, r3
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    8658:	cmp	r4, r6
    865a:	beq.n	86ac <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
        if (!writeSector(sector, ptr)) {
    865c:	ldr	r3, [r7, #0]
    865e:	mov	r2, r5
    8660:	ldr	r3, [r3, #32]
    8662:	mov	r1, r4
    8664:	mov	r0, r7
    8666:	blx	r3
    8668:	cbnz	r0, 866e <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2a>
          return false;  // writeSector will set errorCode.
    866a:	movs	r0, #0
    866c:	pop	{r3, r4, r5, r6, r7, pc}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    866e:	adds	r4, #1
    8670:	add.w	r5, r5, #512	; 0x200
    8674:	b.n	8658 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x14>
          return false;  // writeSector will set errorCode.
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
    8676:	ldr	r0, [pc, #56]	; (86b0 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x6c>)
    8678:	bl	8280 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    867c:	cbnz	r0, 86ac <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    867e:	ldr	r3, [pc, #52]	; (86b4 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x70>)
    8680:	movs	r2, #14
    8682:	strb	r2, [r3, #0]
  m_errorLine = line;
    8684:	ldr	r3, [pc, #48]	; (86b8 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x74>)
    8686:	movw	r2, #1105	; 0x451
    868a:	str	r2, [r3, #0]
    868c:	pop	{r3, r4, r5, r6, r7, pc}
    868e:	adds	r6, r1, r3
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
      return sdError(SD_CARD_ERROR_CMD25);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    8690:	cmp	r4, r6
    8692:	beq.n	86ac <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
      if (!writeSector(sector + i, src + i*512UL)) {
    8694:	ldr	r3, [r7, #0]
    8696:	mov	r2, r5
    8698:	mov	r1, r4
    869a:	ldr	r3, [r3, #32]
    869c:	mov	r0, r7
    869e:	blx	r3
    86a0:	adds	r4, #1
    86a2:	add.w	r5, r5, #512	; 0x200
    86a6:	cmp	r0, #0
    86a8:	bne.n	8690 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x4c>
    86aa:	b.n	866a <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x26>
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
        if (!writeSector(sector, ptr)) {
          return false;  // writeSector will set errorCode.
        }
      }
      return true;
    86ac:	movs	r0, #1
        return false;
      }
    }
  }
  return true;
}
    86ae:	pop	{r3, r4, r5, r6, r7, pc}
    86b0:	.word	0x193a0027
    86b4:	.word	0x1fff135c
    86b8:	.word	0x2001cf08

000086bc <SdioCard::writeSector(unsigned long, unsigned char const*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    86bc:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    86be:	ldrb	r3, [r0, #8]
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    86c0:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    86c2:	lsls	r2, r3, #31
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    86c4:	sub.w	sp, sp, #512	; 0x200
    86c8:	mov	r4, r0
    86ca:	mov	r6, r1
  if (m_sdioConfig.useDma()) {
    86cc:	bpl.n	8700 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x44>
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
    86ce:	lsls	r3, r5, #30
    86d0:	beq.n	86e0 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x24>
      ptr = aligned;
      memcpy(aligned, src, 512);
    86d2:	mov	r1, r5
    86d4:	mov.w	r2, #512	; 0x200
    86d8:	mov	r0, sp
    86da:	bl	8ed0 <memcpy>
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
      ptr = aligned;
    86de:	mov	r5, sp
      memcpy(aligned, src, 512);
    } else {
      ptr = const_cast<uint8_t*>(src);
    }
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
    86e0:	movs	r3, #1
    86e2:	mov	r2, r5
    86e4:	mov	r1, r6
    86e6:	ldr	r0, [pc, #132]	; (876c <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb0>)
    86e8:	bl	8280 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    86ec:	cmp	r0, #0
    86ee:	bne.n	8764 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    86f0:	ldr	r3, [pc, #124]	; (8770 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb4>)
    86f2:	movs	r2, #13
    86f4:	strb	r2, [r3, #0]
  m_errorLine = line;
    86f6:	ldr	r3, [pc, #124]	; (8774 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb8>)
    86f8:	movw	r2, #1049	; 0x419
    86fc:	str	r2, [r3, #0]
    86fe:	b.n	8764 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD24);
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    8700:	bl	8458 <waitTransferComplete()>
    8704:	cbnz	r0, 870a <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4e>
      return false;
    8706:	movs	r0, #0
    8708:	b.n	8764 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    870a:	ldr	r3, [pc, #108]	; (8778 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xbc>)
    870c:	ldr	r3, [r3, #0]
    870e:	lsrs	r3, r3, #16
    8710:	lsls	r3, r3, #16
    8712:	cbz	r3, 871c <SdioCard::writeSector(unsigned long, unsigned char const*)+0x60>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    8714:	ldrb	r3, [r4, #9]
    8716:	cmp	r3, #2
    8718:	bne.n	8730 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x74>
    871a:	b.n	872a <SdioCard::writeSector(unsigned long, unsigned char const*)+0x6e>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    871c:	ldr	r3, [r4, #0]
    871e:	mov	r0, r4
    8720:	ldr	r3, [r3, #28]
    8722:	blx	r3
    8724:	cmp	r0, #0
    8726:	bne.n	8714 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x58>
    8728:	b.n	8706 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    872a:	ldr	r3, [r4, #4]
    872c:	cmp	r6, r3
    872e:	beq.n	8750 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x94>
      if (!syncDevice()) {
    8730:	ldr	r3, [r4, #0]
    8732:	mov	r0, r4
    8734:	ldr	r3, [r3, #28]
    8736:	blx	r3
    8738:	cmp	r0, #0
    873a:	beq.n	8706 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
      if (!writeStart(sector )) {
    873c:	ldr	r3, [r4, #0]
    873e:	mov	r1, r6
    8740:	ldr	r3, [r3, #80]	; 0x50
    8742:	mov	r0, r4
    8744:	blx	r3
    8746:	cmp	r0, #0
    8748:	beq.n	8706 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
      m_curSector = sector;
      m_curState = WRITE_STATE;
    874a:	movs	r3, #2
        return false;
      }
      if (!writeStart(sector )) {
        return false;
      }
      m_curSector = sector;
    874c:	str	r6, [r4, #4]
      m_curState = WRITE_STATE;
    874e:	strb	r3, [r4, #9]
    }
    if (!writeData(src)) {
    8750:	ldr	r3, [r4, #0]
    8752:	mov	r1, r5
    8754:	ldr	r3, [r3, #76]	; 0x4c
    8756:	mov	r0, r4
    8758:	blx	r3
    875a:	cmp	r0, #0
    875c:	beq.n	8706 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
      return false;
    }
    m_curSector++;
    875e:	ldr	r3, [r4, #4]
    8760:	adds	r3, #1
    8762:	str	r3, [r4, #4]
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
    8764:	add.w	sp, sp, #512	; 0x200
    8768:	pop	{r4, r5, r6, pc}
    876a:	nop
    876c:	.word	0x183a0001
    8770:	.word	0x1fff135c
    8774:	.word	0x2001cf08
    8778:	.word	0x400b1004

0000877c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    877c:	push	{r3, r4, r5, r6, r7, lr}
    877e:	mov	r7, r0
    8780:	mov	r4, r1
  if (m_sdioConfig.useDma()) {
    8782:	ldrb	r6, [r7, #8]
    8784:	lsls	r6, r6, #31
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    8786:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    8788:	bpl.n	87c6 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4a>
    if ((uint32_t)dst & 3) {
    878a:	lsls	r6, r2, #30
    878c:	beq.n	87ae <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x32>
    878e:	adds	r6, r1, r3
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    8790:	cmp	r4, r6
    8792:	beq.n	87e4 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
        if (!readSector(sector, dst)) {
    8794:	ldr	r3, [r7, #0]
    8796:	mov	r2, r5
    8798:	ldr	r3, [r3, #12]
    879a:	mov	r1, r4
    879c:	mov	r0, r7
    879e:	blx	r3
    87a0:	cbnz	r0, 87a6 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x2a>
          return false;  // readSector will set errorCode.
    87a2:	movs	r0, #0
    87a4:	pop	{r3, r4, r5, r6, r7, pc}
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
  if (m_sdioConfig.useDma()) {
    if ((uint32_t)dst & 3) {
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    87a6:	adds	r4, #1
    87a8:	add.w	r5, r5, #512	; 0x200
    87ac:	b.n	8790 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x14>
          return false;  // readSector will set errorCode.
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
    87ae:	ldr	r0, [pc, #56]	; (87e8 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x6c>)
    87b0:	bl	8280 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    87b4:	cbnz	r0, 87e4 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    87b6:	ldr	r3, [pc, #52]	; (87ec <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x70>)
    87b8:	movs	r2, #12
    87ba:	strb	r2, [r3, #0]
  m_errorLine = line;
    87bc:	ldr	r3, [pc, #48]	; (87f0 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x74>)
    87be:	mov.w	r2, #912	; 0x390
    87c2:	str	r2, [r3, #0]
    87c4:	pop	{r3, r4, r5, r6, r7, pc}
    87c6:	adds	r6, r1, r3
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
      return sdError(SD_CARD_ERROR_CMD18);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    87c8:	cmp	r4, r6
    87ca:	beq.n	87e4 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
      if (!readSector(sector + i, dst + i*512UL)) {
    87cc:	ldr	r3, [r7, #0]
    87ce:	mov	r2, r5
    87d0:	mov	r1, r4
    87d2:	ldr	r3, [r3, #12]
    87d4:	mov	r0, r7
    87d6:	blx	r3
    87d8:	adds	r4, #1
    87da:	add.w	r5, r5, #512	; 0x200
    87de:	cmp	r0, #0
    87e0:	bne.n	87c8 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4c>
    87e2:	b.n	87a2 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x26>
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
        if (!readSector(sector, dst)) {
          return false;  // readSector will set errorCode.
        }
      }
      return true;
    87e4:	movs	r0, #1
        return false;
      }
    }
  }
  return true;
}
    87e6:	pop	{r3, r4, r5, r6, r7, pc}
    87e8:	.word	0x123a0037
    87ec:	.word	0x1fff135c
    87f0:	.word	0x2001cf08

000087f4 <cardCMD6(unsigned long, unsigned char*)>:

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    87f4:	push	{r3, r4, r5, lr}
    87f6:	mov	r4, r0
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    87f8:	ldr	r0, [pc, #104]	; (8864 <cardCMD6(unsigned long, unsigned char*)+0x70>)

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    87fa:	mov	r5, r1
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    87fc:	bl	80dc <waitTimeout(bool (*)())>
    8800:	cbz	r0, 880e <cardCMD6(unsigned long, unsigned char*)+0x1a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8802:	ldr	r3, [pc, #100]	; (8868 <cardCMD6(unsigned long, unsigned char*)+0x74>)
    8804:	movs	r2, #10
    8806:	strb	r2, [r3, #0]
  m_errorLine = line;
    8808:	movw	r2, #413	; 0x19d
    880c:	b.n	8850 <cardCMD6(unsigned long, unsigned char*)+0x5c>
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    880e:	ldr	r3, [pc, #92]	; (886c <cardCMD6(unsigned long, unsigned char*)+0x78>)
    8810:	movs	r2, #1
    8812:	strb	r2, [r3, #0]
  m_irqstat = 0;
    8814:	ldr	r3, [pc, #88]	; (8870 <cardCMD6(unsigned long, unsigned char*)+0x7c>)
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    8816:	ldr	r2, [pc, #92]	; (8874 <cardCMD6(unsigned long, unsigned char*)+0x80>)
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    8818:	str	r0, [r3, #0]
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    881a:	ldr	r3, [pc, #92]	; (8878 <cardCMD6(unsigned long, unsigned char*)+0x84>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    881c:	ldr	r0, [pc, #92]	; (887c <cardCMD6(unsigned long, unsigned char*)+0x88>)
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    881e:	str	r5, [r3, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    8820:	str	r2, [r3, #4]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    8822:	ldr	r2, [pc, #92]	; (8880 <cardCMD6(unsigned long, unsigned char*)+0x8c>)
    8824:	str	r2, [r3, #56]	; 0x38
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    8826:	mov	r1, r4
    8828:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    882c:	cbnz	r0, 883e <cardCMD6(unsigned long, unsigned char*)+0x4a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    882e:	ldr	r3, [pc, #56]	; (8868 <cardCMD6(unsigned long, unsigned char*)+0x74>)
    8830:	movs	r2, #4
    8832:	strb	r2, [r3, #0]
  m_errorLine = line;
    8834:	ldr	r3, [pc, #76]	; (8884 <cardCMD6(unsigned long, unsigned char*)+0x90>)
    8836:	mov.w	r2, #420	; 0x1a4
    883a:	str	r2, [r3, #0]
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
    883c:	pop	{r3, r4, r5, pc}
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    883e:	ldr	r0, [pc, #72]	; (8888 <cardCMD6(unsigned long, unsigned char*)+0x94>)
    8840:	bl	8100 <yieldTimeout(bool (*)())>
    8844:	cbz	r0, 8858 <cardCMD6(unsigned long, unsigned char*)+0x64>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8846:	ldr	r3, [pc, #32]	; (8868 <cardCMD6(unsigned long, unsigned char*)+0x74>)
    8848:	movs	r2, #37	; 0x25
    884a:	strb	r2, [r3, #0]
  m_errorLine = line;
    884c:	movw	r2, #423	; 0x1a7
    8850:	ldr	r3, [pc, #48]	; (8884 <cardCMD6(unsigned long, unsigned char*)+0x90>)
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    return sdError(SD_CARD_ERROR_DMA);
    8852:	movs	r0, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8854:	str	r2, [r3, #0]
    8856:	pop	{r3, r4, r5, pc}
    8858:	bl	8260 <waitDmaStatus() [clone .part.4]>
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    885c:	cmp	r0, #0
    885e:	beq.n	8846 <cardCMD6(unsigned long, unsigned char*)+0x52>
    return sdError(SD_CARD_ERROR_DMA);
  }
  return true;
}
    8860:	pop	{r3, r4, r5, pc}
    8862:	nop
    8864:	.word	0x000081e5
    8868:	.word	0x1fff135c
    886c:	.word	0x2001cf01
    8870:	.word	0x2001ceec
    8874:	.word	0x00010040
    8878:	.word	0x400b1000
    887c:	.word	0x063a0011
    8880:	.word	0x117f0002
    8884:	.word	0x2001cf08
    8888:	.word	0x00007f95

0000888c <SdioCard::begin(SdioConfig)>:
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    888c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    8890:	ldr	r4, [pc, #712]	; (8b5c <SdioCard::begin(SdioConfig)+0x2d0>)
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    8892:	ldr	r2, [pc, #716]	; (8b60 <SdioCard::begin(SdioConfig)+0x2d4>)
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
    8894:	ldr.w	ip, [pc, #828]	; 8bd4 <SdioCard::begin(SdioConfig)+0x348>
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    8898:	ldr.w	lr, [pc, #828]	; 8bd8 <SdioCard::begin(SdioConfig)+0x34c>
  m_version2 = false;
    889c:	ldr.w	sl, [pc, #828]	; 8bdc <SdioCard::begin(SdioConfig)+0x350>
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
    88a0:	strb	r1, [r0, #8]
  m_curState = IDLE_STATE;
    88a2:	movs	r3, #0
    88a4:	strb	r3, [r0, #9]
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    88a6:	strb	r3, [r4, #0]
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
    88a8:	strb.w	r3, [ip]
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    88ac:	strb.w	r3, [lr]
  m_version2 = false;
    88b0:	strb.w	r3, [sl]
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    88b4:	ldr	r3, [r2, #0]
  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    88b6:	ldr	r0, [pc, #684]	; (8b64 <SdioCard::begin(SdioConfig)+0x2d8>)
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    88b8:	ldr	r5, [pc, #684]	; (8b68 <SdioCard::begin(SdioConfig)+0x2dc>)
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    88ba:	ldr	r6, [pc, #688]	; (8b6c <SdioCard::begin(SdioConfig)+0x2e0>)
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    88bc:	ldr	r7, [pc, #688]	; (8b70 <SdioCard::begin(SdioConfig)+0x2e4>)
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    88be:	ldr.w	r8, [pc, #800]	; 8be0 <SdioCard::begin(SdioConfig)+0x354>
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    88c2:	ldr	r1, [pc, #688]	; (8b74 <SdioCard::begin(SdioConfig)+0x2e8>)
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    88c4:	orr.w	r3, r3, #201326592	; 0xc000000
    88c8:	str	r3, [r2, #0]
#endif  // HAS_KINETIS_MPU
  // Enable SDHC clock.
  SIM_SCGC3 |= SIM_SCGC3_SDHC;
    88ca:	add.w	r2, r2, #239616	; 0x3a800
    88ce:	adds	r2, #48	; 0x30
    88d0:	ldr	r3, [r2, #0]
    88d2:	orr.w	r3, r3, #131072	; 0x20000
    88d6:	str	r3, [r2, #0]
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    88d8:	ldr	r2, [pc, #668]	; (8b78 <SdioCard::begin(SdioConfig)+0x2ec>)
    88da:	movw	r3, #259	; 0x103
    88de:	str	r3, [r2, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    88e0:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    88e2:	str	r3, [r6, #0]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    88e4:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    88e6:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    88ea:	str	r3, [r0, #0]
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    88ec:	ldr	r3, [r1, #0]
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    88ee:	sub	sp, #84	; 0x54
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    88f0:	orr.w	r3, r3, #16777216	; 0x1000000
    88f4:	orr.w	r3, r3, #32768	; 0x8000
    88f8:	str	r3, [r1, #0]
    88fa:	mov	r9, r0
    88fc:	str.w	ip, [sp, #4]
    8900:	str.w	lr, [sp, #8]
    8904:	mov	fp, r1

  while (SDHC_SYSCTL & SDHC_SYSCTL_RSTA) {
    8906:	ldr.w	r1, [fp]
    890a:	ldr	r3, [pc, #616]	; (8b74 <SdioCard::begin(SdioConfig)+0x2e8>)
    890c:	lsls	r1, r1, #7
    890e:	bmi.n	8906 <SdioCard::begin(SdioConfig)+0x7a>
  }

  // Set initial SCK rate.
  setSdclk(SD_MAX_INIT_RATE_KHZ);
    8910:	mov.w	r0, #400	; 0x190
    8914:	str	r3, [sp, #0]
    8916:	str	r2, [sp, #12]
    8918:	bl	7fe0 <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    891c:	ldr	r2, [sp, #12]
    891e:	movw	r1, #1091	; 0x443
    8922:	str	r1, [r2, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8924:	mov.w	r2, #1088	; 0x440
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8928:	str	r1, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    892a:	str	r2, [r6, #0]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    892c:	ldr	r2, [pc, #588]	; (8b7c <SdioCard::begin(SdioConfig)+0x2f0>)
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    892e:	str	r1, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8930:	str.w	r1, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8934:	str.w	r1, [r9]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    8938:	ldr	r1, [pc, #580]	; (8b80 <SdioCard::begin(SdioConfig)+0x2f4>)
    893a:	str	r1, [r2, #0]

  attachInterruptVector(IRQ_SDHC, sdIrs);
    893c:	movs	r0, #81	; 0x51
    893e:	ldr	r1, [pc, #580]	; (8b84 <SdioCard::begin(SdioConfig)+0x2f8>)
    8940:	bl	93ec <attachInterruptVector>
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    8944:	ldr	r2, [pc, #576]	; (8b88 <SdioCard::begin(SdioConfig)+0x2fc>)
    8946:	movs	r1, #96	; 0x60
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    8948:	mvn.w	r0, #840	; 0x348

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    894c:	strb	r1, [r2, #0]
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    894e:	add	r2, r0

  // Send 80 clocks to card.
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    8950:	ldr	r3, [sp, #0]
  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    8952:	mov.w	r1, #131072	; 0x20000
    8956:	str	r1, [r2, #0]

  // Send 80 clocks to card.
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    8958:	ldr	r2, [r3, #0]
    895a:	orr.w	r2, r2, #134217728	; 0x8000000
    895e:	str	r2, [r3, #0]
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
    8960:	ldr.w	r1, [fp]
    8964:	ands.w	r1, r1, #134217728	; 0x8000000
    8968:	bne.n	8960 <SdioCard::begin(SdioConfig)+0xd4>
  m_highCapacity = false;
  m_version2 = false;

  // initialize controller.
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    896a:	mov	r0, r1
    896c:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    8970:	mov	fp, r0
    8972:	cbnz	r0, 897e <SdioCard::begin(SdioConfig)+0xf2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8974:	movs	r3, #1
    8976:	strb	r3, [r4, #0]
  m_errorLine = line;
    8978:	movw	r2, #662	; 0x296
    897c:	b.n	8a26 <SdioCard::begin(SdioConfig)+0x19a>
    897e:	mov.w	fp, #3
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
    8982:	mov.w	r1, #426	; 0x1aa
    8986:	ldr	r0, [pc, #516]	; (8b8c <SdioCard::begin(SdioConfig)+0x300>)
    8988:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    898c:	cbz	r0, 89aa <SdioCard::begin(SdioConfig)+0x11e>
      if (SDHC_CMDRSP0 != 0X1AA) {
    898e:	ldr	r3, [pc, #512]	; (8b90 <SdioCard::begin(SdioConfig)+0x304>)
    8990:	ldr	r3, [r3, #0]
    8992:	cmp.w	r3, #426	; 0x1aa
    8996:	beq.n	89a2 <SdioCard::begin(SdioConfig)+0x116>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8998:	movs	r3, #6
    899a:	strb	r3, [r4, #0]
  m_errorLine = line;
    899c:	mov.w	r2, #668	; 0x29c
    89a0:	b.n	8ac2 <SdioCard::begin(SdioConfig)+0x236>
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
      if (SDHC_CMDRSP0 != 0X1AA) {
        return sdError(SD_CARD_ERROR_CMD8);
      }
      m_version2 = true;
    89a2:	movs	r3, #1
    89a4:	strb.w	r3, [sl]
      break;
    89a8:	b.n	89b0 <SdioCard::begin(SdioConfig)+0x124>
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    89aa:	subs.w	fp, fp, #1
    89ae:	bne.n	8982 <SdioCard::begin(SdioConfig)+0xf6>
      }
      m_version2 = true;
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
    89b0:	ldrb.w	r3, [sl]
    89b4:	cmp	r3, #0
    89b6:	ldr	r3, [pc, #476]	; (8b94 <SdioCard::begin(SdioConfig)+0x308>)
    89b8:	ite	eq
    89ba:	moveq.w	fp, #3145728	; 0x300000
    89be:	movne	fp, r3
  int m = micros();
    89c0:	bl	94d0 <micros>
    89c4:	str	r0, [sp, #0]
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    89c6:	movs	r1, #0
    89c8:	ldr	r0, [pc, #460]	; (8b98 <SdioCard::begin(SdioConfig)+0x30c>)
    89ca:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    89ce:	cmp	r0, #0
    89d0:	beq.n	8ab0 <SdioCard::begin(SdioConfig)+0x224>
    89d2:	mov	r1, fp
    89d4:	ldr	r0, [pc, #452]	; (8b9c <SdioCard::begin(SdioConfig)+0x310>)
    89d6:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    89da:	cmp	r0, #0
    89dc:	beq.n	8ab0 <SdioCard::begin(SdioConfig)+0x224>
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
    89de:	bl	94d0 <micros>
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
    89e2:	ldr	r3, [sp, #0]
    89e4:	subs	r0, r0, r3
    89e6:	ldr	r3, [pc, #440]	; (8ba0 <SdioCard::begin(SdioConfig)+0x314>)
    89e8:	cmp	r0, r3
    89ea:	bhi.n	8ab0 <SdioCard::begin(SdioConfig)+0x224>
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
    89ec:	ldr	r3, [pc, #416]	; (8b90 <SdioCard::begin(SdioConfig)+0x304>)
    89ee:	ldr.w	sl, [pc, #416]	; 8b90 <SdioCard::begin(SdioConfig)+0x304>
    89f2:	ldr	r3, [r3, #0]
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    89f4:	cmp	r3, #0
    89f6:	bge.n	89c6 <SdioCard::begin(SdioConfig)+0x13a>
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
    89f8:	ldr	r2, [pc, #424]	; (8ba4 <SdioCard::begin(SdioConfig)+0x318>)
    89fa:	ldr.w	r1, [sl]
    89fe:	str	r1, [r2, #0]
  if (SDHC_CMDRSP0 & 0x40000000) {
    8a00:	ldr.w	r2, [sl]
    // Is high capacity.
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    8a04:	ldr	r0, [pc, #416]	; (8ba8 <SdioCard::begin(SdioConfig)+0x31c>)
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    8a06:	lsls	r2, r2, #1
    // Is high capacity.
    m_highCapacity = true;
    8a08:	itt	mi
    8a0a:	ldrmi	r3, [sp, #8]
    8a0c:	movmi	r2, #1
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    8a0e:	mov.w	r1, #0
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    // Is high capacity.
    m_highCapacity = true;
    8a12:	it	mi
    8a14:	strbmi	r2, [r3, #0]
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    8a16:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    8a1a:	mov	fp, r0
    8a1c:	cbnz	r0, 8a2c <SdioCard::begin(SdioConfig)+0x1a0>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8a1e:	movs	r3, #2
    8a20:	strb	r3, [r4, #0]
  m_errorLine = line;
    8a22:	mov.w	r2, #688	; 0x2b0
    8a26:	ldr	r3, [pc, #388]	; (8bac <SdioCard::begin(SdioConfig)+0x320>)
    8a28:	str	r2, [r3, #0]
  if (SDHC_CMDRSP0 & 0x40000000) {
    // Is high capacity.
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD2);
    8a2a:	b.n	8b52 <SdioCard::begin(SdioConfig)+0x2c6>
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    8a2c:	movs	r1, #0
    8a2e:	ldr	r0, [pc, #384]	; (8bb0 <SdioCard::begin(SdioConfig)+0x324>)
    8a30:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    8a34:	mov	fp, r0
    8a36:	cbnz	r0, 8a42 <SdioCard::begin(SdioConfig)+0x1b6>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8a38:	movs	r3, #3
    8a3a:	strb	r3, [r4, #0]
  m_errorLine = line;
    8a3c:	movw	r2, #691	; 0x2b3
    8a40:	b.n	8a26 <SdioCard::begin(SdioConfig)+0x19a>
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    8a42:	ldr.w	r3, [sl]
    8a46:	ldr.w	sl, [pc, #412]	; 8be4 <SdioCard::begin(SdioConfig)+0x358>

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    8a4a:	ldr	r1, [pc, #360]	; (8bb4 <SdioCard::begin(SdioConfig)+0x328>)
    8a4c:	ldr	r0, [pc, #360]	; (8bb8 <SdioCard::begin(SdioConfig)+0x32c>)
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    8a4e:	lsrs	r3, r3, #16
    8a50:	lsls	r3, r3, #16
    8a52:	str.w	r3, [sl]

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    8a56:	bl	81f8 <readReg16(unsigned long, void*)>
    8a5a:	mov	fp, r0
    8a5c:	cbnz	r0, 8a68 <SdioCard::begin(SdioConfig)+0x1dc>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8a5e:	movs	r3, #7
    8a60:	strb	r3, [r4, #0]
  m_errorLine = line;
    8a62:	mov.w	r2, #696	; 0x2b8
    8a66:	b.n	8a26 <SdioCard::begin(SdioConfig)+0x19a>
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    return sdError(SD_CARD_ERROR_CMD9);
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    8a68:	ldr	r1, [pc, #336]	; (8bbc <SdioCard::begin(SdioConfig)+0x330>)
    8a6a:	ldr	r0, [pc, #340]	; (8bc0 <SdioCard::begin(SdioConfig)+0x334>)
    8a6c:	bl	81f8 <readReg16(unsigned long, void*)>
    8a70:	mov	fp, r0
    8a72:	cbnz	r0, 8a7e <SdioCard::begin(SdioConfig)+0x1f2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8a74:	movs	r3, #8
    8a76:	strb	r3, [r4, #0]
  m_errorLine = line;
    8a78:	movw	r2, #699	; 0x2bb
    8a7c:	b.n	8a26 <SdioCard::begin(SdioConfig)+0x19a>
    return sdError(SD_CARD_ERROR_CMD9);
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    return sdError(SD_CARD_ERROR_CMD10);
  }
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    8a7e:	ldr.w	r1, [sl]
    8a82:	ldr	r0, [pc, #320]	; (8bc4 <SdioCard::begin(SdioConfig)+0x338>)
    8a84:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    8a88:	mov	fp, r0
    8a8a:	cbnz	r0, 8a96 <SdioCard::begin(SdioConfig)+0x20a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8a8c:	movs	r3, #5
    8a8e:	strb	r3, [r4, #0]
  m_errorLine = line;
    8a90:	movw	r2, #702	; 0x2be
    8a94:	b.n	8a26 <SdioCard::begin(SdioConfig)+0x19a>
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    8a96:	ldr.w	r1, [sl]
    8a9a:	ldr	r0, [pc, #252]	; (8b98 <SdioCard::begin(SdioConfig)+0x30c>)
    8a9c:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    8aa0:	cbz	r0, 8aba <SdioCard::begin(SdioConfig)+0x22e>
    8aa2:	movs	r1, #2
    8aa4:	ldr	r0, [pc, #288]	; (8bc8 <SdioCard::begin(SdioConfig)+0x33c>)
    8aa6:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    8aaa:	mov	fp, r0
    8aac:	cbz	r0, 8aba <SdioCard::begin(SdioConfig)+0x22e>
    8aae:	b.n	8acc <SdioCard::begin(SdioConfig)+0x240>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8ab0:	movs	r3, #23
    8ab2:	strb	r3, [r4, #0]
  m_errorLine = line;
    8ab4:	movw	r2, #679	; 0x2a7
    8ab8:	b.n	8ac2 <SdioCard::begin(SdioConfig)+0x236>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8aba:	movs	r3, #20
    8abc:	strb	r3, [r4, #0]
  m_errorLine = line;
    8abe:	movw	r2, #706	; 0x2c2
    8ac2:	ldr	r3, [pc, #232]	; (8bac <SdioCard::begin(SdioConfig)+0x320>)
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
  }
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
    8ac4:	mov.w	fp, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8ac8:	str	r2, [r3, #0]
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
  }
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
    8aca:	b.n	8b52 <SdioCard::begin(SdioConfig)+0x2c6>
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
    8acc:	ldr	r3, [pc, #252]	; (8bcc <SdioCard::begin(SdioConfig)+0x340>)
    8ace:	ldr	r2, [r3, #0]
    8ad0:	bic.w	r2, r2, #6
    8ad4:	str	r2, [r3, #0]
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);
    8ad6:	ldr	r2, [r3, #0]
    8ad8:	orr.w	r2, r2, #2
    8adc:	str	r2, [r3, #0]

  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);
    8ade:	mov.w	r2, #1048592	; 0x100010
    8ae2:	str	r2, [r3, #28]

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8ae4:	add	r1, sp, #16
    8ae6:	mvn.w	r0, #4278190080	; 0xff000000
    8aea:	bl	87f4 <cardCMD6(unsigned long, unsigned char*)>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    8aee:	cbz	r0, 8af8 <SdioCard::begin(SdioConfig)+0x26c>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8af0:	ldrb.w	r3, [sp, #29]
    8af4:	lsls	r3, r3, #30
    8af6:	bmi.n	8afe <SdioCard::begin(SdioConfig)+0x272>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    kHzSdClk = 50000;
  } else {
    kHzSdClk = 25000;
    8af8:	movw	r0, #25000	; 0x61a8
    8afc:	b.n	8b1a <SdioCard::begin(SdioConfig)+0x28e>

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    8afe:	add	r1, sp, #16
    8b00:	ldr	r0, [pc, #204]	; (8bd0 <SdioCard::begin(SdioConfig)+0x344>)
    8b02:	bl	87f4 <cardCMD6(unsigned long, unsigned char*)>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8b06:	cmp	r0, #0
    8b08:	beq.n	8af8 <SdioCard::begin(SdioConfig)+0x26c>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    8b0a:	ldrb.w	r3, [sp, #32]
    8b0e:	and.w	r3, r3, #15
    8b12:	cmp	r3, #1
    8b14:	bne.n	8af8 <SdioCard::begin(SdioConfig)+0x26c>
    kHzSdClk = 50000;
    8b16:	movw	r0, #50000	; 0xc350
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8b1a:	ldr	r4, [pc, #92]	; (8b78 <SdioCard::begin(SdioConfig)+0x2ec>)
    8b1c:	movw	r3, #259	; 0x103
    8b20:	str	r3, [r4, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8b22:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8b24:	str	r3, [r6, #0]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8b26:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8b28:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8b2c:	str.w	r3, [r9]
  }
  // Disable GPIO.
  enableGPIO(false);

  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);
    8b30:	bl	7fe0 <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8b34:	movw	r3, #1091	; 0x443
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8b38:	mov.w	r2, #1088	; 0x440
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8b3c:	str	r3, [r4, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8b3e:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8b40:	str	r2, [r6, #0]
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    8b42:	ldr	r2, [sp, #4]
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8b44:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8b46:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8b4a:	str.w	r3, [r9]
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    8b4e:	movs	r3, #1
    8b50:	strb	r3, [r2, #0]
  return true;
}
    8b52:	mov	r0, fp
    8b54:	add	sp, #84	; 0x54
    8b56:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8b5a:	nop
    8b5c:	.word	0x1fff135c
    8b60:	.word	0x4000d800
    8b64:	.word	0x4004d014
    8b68:	.word	0x4004d004
    8b6c:	.word	0x4004d008
    8b70:	.word	0x4004d00c
    8b74:	.word	0x400b102c
    8b78:	.word	0x4004d000
    8b7c:	.word	0x400b1034
    8b80:	.word	0x117f000b
    8b84:	.word	0x00007f31
    8b88:	.word	0xe000e451
    8b8c:	.word	0x081a0000
    8b90:	.word	0x400b1010
    8b94:	.word	0x40300000
    8b98:	.word	0x371a0000
    8b9c:	.word	0x29020000
    8ba0:	.word	0x000f4240
    8ba4:	.word	0x2001cee0
    8ba8:	.word	0x02090000
    8bac:	.word	0x2001cf08
    8bb0:	.word	0x031a0000
    8bb4:	.word	0x2001cef1
    8bb8:	.word	0x09090000
    8bbc:	.word	0x2001cec5
    8bc0:	.word	0x0a090000
    8bc4:	.word	0x071b0000
    8bc8:	.word	0x061a0000
    8bcc:	.word	0x400b1028
    8bd0:	.word	0x80fffff1
    8bd4:	.word	0x2001cef0
    8bd8:	.word	0x2001cedc
    8bdc:	.word	0x2001cec4
    8be0:	.word	0x4004d010
    8be4:	.word	0x2001cee4

00008be8 <SdioCard::readData(unsigned char*)>:
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    8be8:	push	{r3, r4, r5, lr}
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    8bea:	ldr	r5, [pc, #152]	; (8c84 <SdioCard::readData(unsigned char*)+0x9c>)
    8bec:	ldr	r3, [r5, #0]
    8bee:	lsls	r3, r3, #22
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    8bf0:	mov	r4, r1
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    8bf2:	bmi.n	8c12 <SdioCard::readData(unsigned char*)+0x2a>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8bf4:	ldr	r3, [pc, #144]	; (8c88 <SdioCard::readData(unsigned char*)+0xa0>)
    8bf6:	ldr	r2, [r3, #0]
    8bf8:	bic.w	r2, r2, #65536	; 0x10000
    8bfc:	str	r2, [r3, #0]
    noInterrupts();
    8bfe:	cpsid	i
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    8c00:	ldr	r2, [r3, #0]
    8c02:	orr.w	r2, r2, #131072	; 0x20000
    8c06:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    8c08:	ldr	r2, [r3, #0]
    8c0a:	orr.w	r2, r2, #65536	; 0x10000
    8c0e:	str	r2, [r3, #0]
    interrupts();
    8c10:	cpsie	i
  }
  if (waitTimeout(isBusyFifoRead)) {
    8c12:	ldr	r0, [pc, #120]	; (8c8c <SdioCard::readData(unsigned char*)+0xa4>)
    8c14:	bl	80dc <waitTimeout(bool (*)())>
    8c18:	cbnz	r0, 8c70 <SdioCard::readData(unsigned char*)+0x88>
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    8c1a:	ldr	r1, [pc, #116]	; (8c90 <SdioCard::readData(unsigned char*)+0xa8>)
    8c1c:	subs	r3, r4, #4
    8c1e:	add.w	r4, r4, #508	; 0x1fc
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    8c22:	ldr	r2, [r5, #0]
    8c24:	lsls	r0, r2, #20
    8c26:	bpl.n	8c22 <SdioCard::readData(unsigned char*)+0x3a>
    8c28:	add.w	r2, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    8c2c:	ldr	r0, [r1, #0]
    8c2e:	str.w	r0, [r3, #4]!
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    8c32:	cmp	r2, r3
    8c34:	bne.n	8c2c <SdioCard::readData(unsigned char*)+0x44>
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    8c36:	cmp	r4, r2
    8c38:	mov	r3, r2
    8c3a:	bne.n	8c22 <SdioCard::readData(unsigned char*)+0x3a>
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    }
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    8c3c:	ldr	r0, [pc, #84]	; (8c94 <SdioCard::readData(unsigned char*)+0xac>)
    8c3e:	bl	80dc <waitTimeout(bool (*)())>
    8c42:	cbz	r0, 8c50 <SdioCard::readData(unsigned char*)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8c44:	ldr	r3, [pc, #80]	; (8c98 <SdioCard::readData(unsigned char*)+0xb0>)
    8c46:	movs	r2, #29
    8c48:	strb	r2, [r3, #0]
  m_errorLine = line;
    8c4a:	movw	r2, #846	; 0x34e
    8c4e:	b.n	8c7a <SdioCard::readData(unsigned char*)+0x92>
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
    8c50:	ldr	r2, [pc, #72]	; (8c9c <SdioCard::readData(unsigned char*)+0xb4>)
    8c52:	ldr	r3, [pc, #76]	; (8ca0 <SdioCard::readData(unsigned char*)+0xb8>)
    8c54:	ldr	r1, [r2, #0]
    8c56:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    8c58:	ldr	r1, [r3, #0]
    8c5a:	str	r1, [r2, #0]
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    8c5c:	ldr	r2, [r3, #0]
    8c5e:	lsls	r2, r2, #30
    8c60:	bpl.n	8c80 <SdioCard::readData(unsigned char*)+0x98>
    8c62:	ldr	r3, [r3, #0]
    8c64:	ldr	r0, [pc, #60]	; (8ca4 <SdioCard::readData(unsigned char*)+0xbc>)
    8c66:	ands	r0, r3
    8c68:	clz	r0, r0
    8c6c:	lsrs	r0, r0, #5
    8c6e:	pop	{r3, r4, r5, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8c70:	ldr	r3, [pc, #36]	; (8c98 <SdioCard::readData(unsigned char*)+0xb0>)
    8c72:	movs	r2, #26
    8c74:	strb	r2, [r3, #0]
  m_errorLine = line;
    8c76:	movw	r2, #835	; 0x343
    8c7a:	ldr	r3, [pc, #44]	; (8ca8 <SdioCard::readData(unsigned char*)+0xc0>)
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
    8c7c:	movs	r0, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8c7e:	str	r2, [r3, #0]
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
    8c80:	pop	{r3, r4, r5, pc}
    8c82:	nop
    8c84:	.word	0x400b1024
    8c88:	.word	0x400b1028
    8c8c:	.word	0x00007fa1
    8c90:	.word	0x400b1020
    8c94:	.word	0x00007fc9
    8c98:	.word	0x1fff135c
    8c9c:	.word	0x400b1030
    8ca0:	.word	0x2001ceec
    8ca4:	.word	0x117f0000
    8ca8:	.word	0x2001cf08

00008cac <SdioCard::readStart(unsigned long)>:
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    8cac:	push	{r4, lr}
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    8cae:	ldr	r0, [pc, #80]	; (8d00 <SdioCard::readStart(unsigned long)+0x54>)
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    8cb0:	mov	r4, r1
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    8cb2:	bl	8100 <yieldTimeout(bool (*)())>
    8cb6:	cbz	r0, 8cca <SdioCard::readStart(unsigned long)+0x1e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8cb8:	ldr	r3, [pc, #72]	; (8d04 <SdioCard::readStart(unsigned long)+0x58>)
    8cba:	movs	r2, #10
    8cbc:	strb	r2, [r3, #0]
  m_errorLine = line;
    8cbe:	ldr	r3, [pc, #72]	; (8d08 <SdioCard::readStart(unsigned long)+0x5c>)
    8cc0:	mov.w	r2, #928	; 0x3a0
    8cc4:	str	r2, [r3, #0]
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    8cc6:	movs	r0, #0
    8cc8:	pop	{r4, pc}
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    8cca:	ldr	r2, [pc, #64]	; (8d0c <SdioCard::readStart(unsigned long)+0x60>)
    8ccc:	ldr	r3, [r2, #0]
    8cce:	orr.w	r3, r3, #65536	; 0x10000
    8cd2:	str	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    8cd4:	ldr	r3, [pc, #56]	; (8d10 <SdioCard::readStart(unsigned long)+0x64>)
    8cd6:	ldr	r2, [pc, #60]	; (8d14 <SdioCard::readStart(unsigned long)+0x68>)
    8cd8:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    8cda:	ldr	r3, [pc, #60]	; (8d18 <SdioCard::readStart(unsigned long)+0x6c>)
    8cdc:	ldrb	r3, [r3, #0]
    8cde:	cbnz	r3, 8ce4 <SdioCard::readStart(unsigned long)+0x38>
    8ce0:	lsls	r1, r4, #9
    8ce2:	b.n	8ce6 <SdioCard::readStart(unsigned long)+0x3a>
    8ce4:	mov	r1, r4
    8ce6:	ldr	r0, [pc, #52]	; (8d1c <SdioCard::readStart(unsigned long)+0x70>)
    8ce8:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    8cec:	cbnz	r0, 8cfc <SdioCard::readStart(unsigned long)+0x50>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8cee:	ldr	r3, [pc, #20]	; (8d04 <SdioCard::readStart(unsigned long)+0x58>)
    8cf0:	movs	r2, #12
    8cf2:	strb	r2, [r3, #0]
  m_errorLine = line;
    8cf4:	ldr	r3, [pc, #16]	; (8d08 <SdioCard::readStart(unsigned long)+0x5c>)
    8cf6:	mov.w	r2, #940	; 0x3ac
    8cfa:	str	r2, [r3, #0]

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD18);
  }
  return true;
}
    8cfc:	pop	{r4, pc}
    8cfe:	nop
    8d00:	.word	0x000081e5
    8d04:	.word	0x1fff135c
    8d08:	.word	0x2001cf08
    8d0c:	.word	0x400b1028
    8d10:	.word	0x400b1004
    8d14:	.word	0xffff0200
    8d18:	.word	0x2001cedc
    8d1c:	.word	0x123a0032

00008d20 <SdioCard::readSector(unsigned long, unsigned char*)>:
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8d20:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    8d22:	ldrb	r3, [r0, #8]
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8d24:	mov	r6, r2
  if (m_sdioConfig.useDma()) {
    8d26:	lsls	r2, r3, #31
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8d28:	sub.w	sp, sp, #512	; 0x200
    8d2c:	mov	r4, r0
    8d2e:	mov	r5, r1
  if (m_sdioConfig.useDma()) {
    8d30:	bpl.n	8d6a <SdioCard::readSector(unsigned long, unsigned char*)+0x4a>
    uint8_t aligned[512];

    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;
    8d32:	lsls	r3, r6, #30
    8d34:	ite	eq
    8d36:	moveq	r4, r6
    8d38:	movne	r4, sp

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
    8d3a:	movs	r3, #1
    8d3c:	mov	r2, r4
    8d3e:	ldr	r0, [pc, #148]	; (8dd4 <SdioCard::readSector(unsigned long, unsigned char*)+0xb4>)
    8d40:	bl	8280 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    8d44:	mov	r5, r0
    8d46:	cbnz	r0, 8d58 <SdioCard::readSector(unsigned long, unsigned char*)+0x38>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8d48:	ldr	r3, [pc, #140]	; (8dd8 <SdioCard::readSector(unsigned long, unsigned char*)+0xb8>)
    8d4a:	movs	r2, #11
    8d4c:	strb	r2, [r3, #0]
  m_errorLine = line;
    8d4e:	ldr	r3, [pc, #140]	; (8ddc <SdioCard::readSector(unsigned long, unsigned char*)+0xbc>)
    8d50:	movw	r2, #865	; 0x361
    8d54:	str	r2, [r3, #0]
    8d56:	b.n	8dcc <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD17);
    }
    if (ptr != dst) {
    8d58:	cmp	r4, r6
    8d5a:	beq.n	8dcc <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
      memcpy(dst, aligned, 512);
    8d5c:	mov.w	r2, #512	; 0x200
    8d60:	mov	r1, sp
    8d62:	mov	r0, r6
    8d64:	bl	8ed0 <memcpy>
    8d68:	b.n	8dcc <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    8d6a:	bl	8458 <waitTransferComplete()>
    8d6e:	cbnz	r0, 8d74 <SdioCard::readSector(unsigned long, unsigned char*)+0x54>
      return false;
    8d70:	movs	r5, #0
    8d72:	b.n	8dcc <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    }
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != READ_STATE || sector != m_curSector) {
    8d74:	ldrb	r3, [r4, #9]
    8d76:	cmp	r3, #1
    8d78:	bne.n	8d80 <SdioCard::readSector(unsigned long, unsigned char*)+0x60>
    8d7a:	ldr	r3, [r4, #4]
    8d7c:	cmp	r5, r3
    8d7e:	beq.n	8d9e <SdioCard::readSector(unsigned long, unsigned char*)+0x7e>
      if (!syncDevice()) {
    8d80:	ldr	r3, [r4, #0]
    8d82:	mov	r0, r4
    8d84:	ldr	r3, [r3, #28]
    8d86:	blx	r3
    8d88:	cmp	r0, #0
    8d8a:	beq.n	8d70 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
        return false;
      }
      if (!readStart(sector)) {
    8d8c:	mov	r1, r5
    8d8e:	mov	r0, r4
    8d90:	bl	8cac <SdioCard::readStart(unsigned long)>
    8d94:	cmp	r0, #0
    8d96:	beq.n	8d70 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
        return false;
      }
      m_curSector = sector;
      m_curState = READ_STATE;
    8d98:	movs	r3, #1
        return false;
      }
      if (!readStart(sector)) {
        return false;
      }
      m_curSector = sector;
    8d9a:	str	r5, [r4, #4]
      m_curState = READ_STATE;
    8d9c:	strb	r3, [r4, #9]
    }
    if (!readData(dst)) {
    8d9e:	mov	r1, r6
    8da0:	mov	r0, r4
    8da2:	bl	8be8 <SdioCard::readData(unsigned char*)>
    8da6:	mov	r5, r0
    8da8:	cmp	r0, #0
    8daa:	beq.n	8d70 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    8dac:	ldr	r3, [pc, #48]	; (8de0 <SdioCard::readSector(unsigned long, unsigned char*)+0xc0>)
    8dae:	ldr	r3, [r3, #0]
    8db0:	lsrs	r3, r3, #16
    8db2:	lsls	r3, r3, #16
    8db4:	cbz	r3, 8dbe <SdioCard::readSector(unsigned long, unsigned char*)+0x9e>
      if (!syncDevice()) {
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
    8db6:	ldr	r3, [r4, #4]
    8db8:	adds	r3, #1
    8dba:	str	r3, [r4, #4]
    8dbc:	b.n	8dcc <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    if (!readData(dst)) {
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    8dbe:	ldr	r3, [r4, #0]
    8dc0:	mov	r0, r4
    8dc2:	ldr	r3, [r3, #28]
    8dc4:	blx	r3
    8dc6:	cmp	r0, #0
    8dc8:	bne.n	8db6 <SdioCard::readSector(unsigned long, unsigned char*)+0x96>
    8dca:	b.n	8d70 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
}
    8dcc:	mov	r0, r5
    8dce:	add.w	sp, sp, #512	; 0x200
    8dd2:	pop	{r4, r5, r6, pc}
    8dd4:	.word	0x113a0011
    8dd8:	.word	0x1fff135c
    8ddc:	.word	0x2001cf08
    8de0:	.word	0x400b1004

00008de4 <SdioCard::stopTransmission(bool)>:
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    8de4:	push	{r4, r5, r6, lr}
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8de6:	ldr	r2, [pc, #72]	; (8e30 <SdioCard::stopTransmission(bool)+0x4c>)
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
    8de8:	movs	r5, #0
    8dea:	strb	r5, [r0, #9]
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8dec:	ldr	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    8dee:	ldr	r0, [pc, #68]	; (8e34 <SdioCard::stopTransmission(bool)+0x50>)
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8df0:	bic.w	r3, r3, #65536	; 0x10000
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    8df4:	mov	r6, r1
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8df6:	str	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    8df8:	mov	r1, r5
    8dfa:	bl	8170 <cardCommand(unsigned long, unsigned long)>
    8dfe:	mov	r4, r0
    8e00:	cbnz	r0, 8e12 <SdioCard::stopTransmission(bool)+0x2e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8e02:	ldr	r3, [pc, #52]	; (8e38 <SdioCard::stopTransmission(bool)+0x54>)
    8e04:	movs	r2, #9
    8e06:	strb	r2, [r3, #0]
  m_errorLine = line;
    8e08:	ldr	r3, [pc, #48]	; (8e3c <SdioCard::stopTransmission(bool)+0x58>)
    8e0a:	movw	r2, #962	; 0x3c2
    8e0e:	str	r2, [r3, #0]
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
    8e10:	b.n	8e2c <SdioCard::stopTransmission(bool)+0x48>
  }
  if (blocking) {
    8e12:	cbz	r6, 8e2c <SdioCard::stopTransmission(bool)+0x48>
    if (yieldTimeout(isBusyDat)) {
    8e14:	ldr	r0, [pc, #40]	; (8e40 <SdioCard::stopTransmission(bool)+0x5c>)
    8e16:	bl	8100 <yieldTimeout(bool (*)())>
    8e1a:	cbz	r0, 8e2c <SdioCard::stopTransmission(bool)+0x48>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8e1c:	ldr	r3, [pc, #24]	; (8e38 <SdioCard::stopTransmission(bool)+0x54>)
    8e1e:	movs	r2, #10
    8e20:	strb	r2, [r3, #0]
  m_errorLine = line;
    8e22:	ldr	r3, [pc, #24]	; (8e3c <SdioCard::stopTransmission(bool)+0x58>)
    8e24:	movw	r2, #966	; 0x3c6
    8e28:	str	r2, [r3, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
  if (blocking) {
    if (yieldTimeout(isBusyDat)) {
      return sdError(SD_CARD_ERROR_CMD13);
    8e2a:	mov	r4, r5
    }
  }
  return true;
}
    8e2c:	mov	r0, r4
    8e2e:	pop	{r4, r5, r6, pc}
    8e30:	.word	0x400b1028
    8e34:	.word	0x0cdb0000
    8e38:	.word	0x1fff135c
    8e3c:	.word	0x2001cf08
    8e40:	.word	0x00007f81

00008e44 <SdioCard::syncDevice()>:
//------------------------------------------------------------------------------
bool SdioCard::syncDevice() {
    8e44:	push	{r4, lr}
    8e46:	mov	r4, r0
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    8e48:	bl	8458 <waitTransferComplete()>
    8e4c:	cbz	r0, 8e5e <SdioCard::syncDevice()+0x1a>
    return false;
  }
  if (m_curState != IDLE_STATE) {
    8e4e:	ldrb	r3, [r4, #9]
    8e50:	cbz	r3, 8e5e <SdioCard::syncDevice()+0x1a>
    return stopTransmission(true);
    8e52:	mov	r0, r4
    8e54:	movs	r1, #1
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    8e56:	ldmia.w	sp!, {r4, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    return false;
  }
  if (m_curState != IDLE_STATE) {
    return stopTransmission(true);
    8e5a:	b.w	8de4 <SdioCard::stopTransmission(bool)>
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    8e5e:	pop	{r4, pc}

00008e60 <SdioCard::isBusy()>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorLine() const {
  return m_errorLine;
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
    8e60:	push	{r4, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    8e62:	ldrb	r3, [r0, #8]
    8e64:	lsls	r3, r3, #31
//------------------------------------------------------------------------------
uint32_t SdioCard::errorLine() const {
  return m_errorLine;
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
    8e66:	mov	r2, r0
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    8e68:	bpl.n	8e88 <SdioCard::isBusy()+0x28>
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    8e6a:	ldr	r3, [pc, #80]	; (8ebc <SdioCard::isBusy()+0x5c>)
    8e6c:	ldr	r3, [r3, #0]
    8e6e:	cbz	r3, 8e76 <SdioCard::isBusy()+0x16>
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    8e70:	ldmia.w	sp!, {r4, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    8e74:	bx	r3
    8e76:	ldr	r3, [pc, #72]	; (8ec0 <SdioCard::isBusy()+0x60>)
    8e78:	ldrb	r3, [r3, #0]
    8e7a:	cbnz	r3, 8e80 <SdioCard::isBusy()+0x20>
    8e7c:	movs	r0, #0
    8e7e:	pop	{r4, pc}
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    8e80:	ldmia.w	sp!, {r4, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    8e84:	b.w	81e4 <isBusyCMD13()>
  } else {
    if (m_transferActive) {
    8e88:	ldr	r1, [pc, #56]	; (8ec4 <SdioCard::isBusy()+0x64>)
    8e8a:	ldrb	r4, [r1, #0]
    8e8c:	cbz	r4, 8eae <SdioCard::isBusy()+0x4e>
      if (isBusyTransferComplete()) {
    8e8e:	bl	7fc8 <isBusyTransferComplete()>
    8e92:	cbnz	r0, 8eba <SdioCard::isBusy()+0x5a>
        return true;
      }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
      if ((SDHC_BLKATTR & 0XFFFF0000) != 0) {
    8e94:	ldr	r3, [pc, #48]	; (8ec8 <SdioCard::isBusy()+0x68>)
    8e96:	ldr	r3, [r3, #0]
    8e98:	lsrs	r3, r3, #16
    8e9a:	lsls	r3, r3, #16
    8e9c:	cmp	r3, #0
    8e9e:	bne.n	8e7c <SdioCard::isBusy()+0x1c>
        return false;
      }
      m_transferActive = false;
    8ea0:	strb	r0, [r1, #0]
      stopTransmission(false);
    8ea2:	mov	r1, r0
    8ea4:	mov	r0, r2
    8ea6:	bl	8de4 <SdioCard::stopTransmission(bool)>
    8eaa:	mov	r0, r4
    8eac:	pop	{r4, pc}
#else  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
      return false;
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    }
    // Use DAT0 low as busy.
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
    8eae:	ldr	r3, [pc, #28]	; (8ecc <SdioCard::isBusy()+0x6c>)
    8eb0:	ldr	r0, [r3, #0]
    8eb2:	eor.w	r0, r0, #16777216	; 0x1000000
    8eb6:	ubfx	r0, r0, #24, #1
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    8eba:	pop	{r4, pc}
    8ebc:	.word	0x2001ced8
    8ec0:	.word	0x2001cef0
    8ec4:	.word	0x2001cee8
    8ec8:	.word	0x400b1004
    8ecc:	.word	0x400b1024

00008ed0 <memcpy>:
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
#else
	push	{r0}
    8ed0:	push	{r0}
#endif
	orr	r3, r1, r0
    8ed2:	orr.w	r3, r1, r0
	ands	r3, r3, #3
    8ed6:	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    8eda:	bne.n	8fbc <memcpy+0xec>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    8edc:	subs	r2, #64	; 0x40
	blo	.Lmid_block
    8ede:	bcc.n	8f64 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    8ee0:	ldr.w	r3, [r1], #4
    8ee4:	str.w	r3, [r0], #4
    8ee8:	ldr.w	r3, [r1], #4
    8eec:	str.w	r3, [r0], #4
    8ef0:	ldr.w	r3, [r1], #4
    8ef4:	str.w	r3, [r0], #4
    8ef8:	ldr.w	r3, [r1], #4
    8efc:	str.w	r3, [r0], #4
    8f00:	ldr.w	r3, [r1], #4
    8f04:	str.w	r3, [r0], #4
    8f08:	ldr.w	r3, [r1], #4
    8f0c:	str.w	r3, [r0], #4
    8f10:	ldr.w	r3, [r1], #4
    8f14:	str.w	r3, [r0], #4
    8f18:	ldr.w	r3, [r1], #4
    8f1c:	str.w	r3, [r0], #4
    8f20:	ldr.w	r3, [r1], #4
    8f24:	str.w	r3, [r0], #4
    8f28:	ldr.w	r3, [r1], #4
    8f2c:	str.w	r3, [r0], #4
    8f30:	ldr.w	r3, [r1], #4
    8f34:	str.w	r3, [r0], #4
    8f38:	ldr.w	r3, [r1], #4
    8f3c:	str.w	r3, [r0], #4
    8f40:	ldr.w	r3, [r1], #4
    8f44:	str.w	r3, [r0], #4
    8f48:	ldr.w	r3, [r1], #4
    8f4c:	str.w	r3, [r0], #4
    8f50:	ldr.w	r3, [r1], #4
    8f54:	str.w	r3, [r0], #4
    8f58:	ldr.w	r3, [r1], #4
    8f5c:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    8f60:	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    8f62:	bcs.n	8ee0 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    8f64:	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    8f66:	bcc.n	8f8c <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    8f68:	ldr.w	r3, [r1], #4
    8f6c:	str.w	r3, [r0], #4
    8f70:	ldr.w	r3, [r1], #4
    8f74:	str.w	r3, [r0], #4
    8f78:	ldr.w	r3, [r1], #4
    8f7c:	str.w	r3, [r0], #4
    8f80:	ldr.w	r3, [r1], #4
    8f84:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    8f88:	subs	r2, #16
	bhs	.Lmid_block_loop
    8f8a:	bcs.n	8f68 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    8f8c:	adds	r2, #12
	blo	.Lcopy_less_than_4
    8f8e:	bcc.n	8f9c <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    8f90:	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    8f94:	str.w	r3, [r0], #4
	subs	r2, #4
    8f98:	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    8f9a:	bcs.n	8f90 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    8f9c:	adds	r2, #4
	beq	.Ldone
    8f9e:	beq.n	8fb6 <memcpy+0xe6>

	lsls	r2, r2, #31
    8fa0:	lsls	r2, r2, #31
	itt ne
    8fa2:	itt	ne
	ldrbne  r3, [r1], #1
    8fa4:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    8fa8:	strbne.w	r3, [r0], #1

	bcc	.Ldone
    8fac:	bcc.n	8fb6 <memcpy+0xe6>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
	strh	r3, [r0]
#else
	ldrb	r3, [r1]
    8fae:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    8fb0:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    8fb2:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    8fb4:	strb	r3, [r0, #1]

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    8fb6:	pop	{r0}
#endif
	bx	lr
    8fb8:	bx	lr
    8fba:	nop
	beq	.Ldst_aligned
#else
	/* if len < 12, misalignment adjustment has more overhead than
	just byte-to-byte copy.  Also, len must >=8 to guarantee code
	afterward work correctly.  */
	cmp	r2, #12
    8fbc:	cmp	r2, #12
	blo	.Lbyte_copy
    8fbe:	bcc.n	9056 <memcpy+0x186>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    8fc0:	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    8fc4:	beq.n	8fea <memcpy+0x11a>

	rsb	r3, #4
    8fc6:	rsb	r3, r3, #4
	subs	r2, r3
    8fca:	subs	r2, r2, r3

	lsls    r3, r3, #31
    8fcc:	lsls	r3, r3, #31
	itt ne
    8fce:	itt	ne
	ldrbne  r3, [r1], #1
    8fd0:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    8fd4:	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    8fd8:	bcc.n	8fea <memcpy+0x11a>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
	strh    r3, [r0], #2
	b	.Ldst_aligned
#else
	ldrb    r3, [r1], #1
    8fda:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    8fde:	strb.w	r3, [r0], #1
	ldrb    r3, [r1], #1
    8fe2:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    8fe6:	strb.w	r3, [r0], #1
	/* Now that dst is aligned */
.Ldst_aligned:
	/* if r1 is aligned now, it means r0/r1 has the same misalignment,
	and they are both aligned now.  Go aligned copy.  */
	ands	r3, r1, #3
    8fea:	ands.w	r3, r1, #3
	beq	.Lbig_block
    8fee:	beq.w	8edc <memcpy+0xc>

	/* dst is aligned, but src isn't.  Misaligned copy.  */

	push	{r4, r5}
    8ff2:	push	{r4, r5}
	subs	r2, #4
    8ff4:	subs	r2, #4

	/* Backward r1 by misaligned bytes, to make r1 aligned.
	Since we need to restore r1 to unaligned address after the loop,
	we need keep the offset bytes to ip and sub it from r1 afterward.  */
	subs	r1, r3
    8ff6:	subs	r1, r1, r3
	rsb	ip, r3, #4
    8ff8:	rsb	ip, r3, #4

	/* Pre-load on word */
	ldr	r4, [r1], #4
    8ffc:	ldr.w	r4, [r1], #4

	cmp	r3, #2
    9000:	cmp	r3, #2
	beq	.Lmisaligned_copy_2_2
    9002:	beq.n	9038 <memcpy+0x168>
	cmp	r3, #3
    9004:	cmp	r3, #3
	beq	.Lmisaligned_copy_3_1
    9006:	beq.n	9020 <memcpy+0x150>
	subs	r2, #4
	bhs	1b
	.endm

.Lmisaligned_copy_1_3:
	mis_src_copy shift=8
    9008:	lsrs	r4, r4, #8
    900a:	ldr.w	r3, [r1], #4
    900e:	lsls	r5, r3, #24
    9010:	orr.w	r4, r4, r5
    9014:	str.w	r4, [r0], #4
    9018:	mov	r4, r3
    901a:	subs	r2, #4
    901c:	bcs.n	9008 <memcpy+0x138>
	b	.Lsrc_misaligned_tail
    901e:	b.n	904e <memcpy+0x17e>

.Lmisaligned_copy_3_1:
	mis_src_copy shift=24
    9020:	lsrs	r4, r4, #24
    9022:	ldr.w	r3, [r1], #4
    9026:	lsls	r5, r3, #8
    9028:	orr.w	r4, r4, r5
    902c:	str.w	r4, [r0], #4
    9030:	mov	r4, r3
    9032:	subs	r2, #4
    9034:	bcs.n	9020 <memcpy+0x150>
	b	.Lsrc_misaligned_tail
    9036:	b.n	904e <memcpy+0x17e>

.Lmisaligned_copy_2_2:
	/* For 2_2 misalignment, ldr is still faster than 2 x ldrh.  */
	mis_src_copy shift=16
    9038:	lsrs	r4, r4, #16
    903a:	ldr.w	r3, [r1], #4
    903e:	lsls	r5, r3, #16
    9040:	orr.w	r4, r4, r5
    9044:	str.w	r4, [r0], #4
    9048:	mov	r4, r3
    904a:	subs	r2, #4
    904c:	bcs.n	9038 <memcpy+0x168>

.Lsrc_misaligned_tail:
	adds	r2, #4
    904e:	adds	r2, #4
	subs	r1, ip
    9050:	subs.w	r1, r1, ip
	pop	{r4, r5}
    9054:	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    9056:	subs	r2, #4
	blo	.Lcopy_less_than_4
    9058:	bcc.n	8f9c <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    905a:	subs	r2, #1
	ldrb    r3, [r1], #1
    905c:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    9060:	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    9064:	bcs.n	905a <memcpy+0x18a>

	ldrb	r3, [r1]
    9066:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    9068:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    906a:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    906c:	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    906e:	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    9070:	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    9072:	pop	{r0}
#endif
	bx	lr
    9074:	bx	lr
    9076:	nop

00009078 <memset>:
	.type	memset, %function
	.thumb_func
	memset:
//FUNCTION(memset)
    // save the original pointer
    push    { r0, lr }
    9078:	push	{r0, lr}

    // check for zero length
    cbz     r2, .L_done
    907a:	cbz	r2, 90b8 <memset+0x40>

    // short memsets aren't worth optimizing and make sure we have
    // enough headroom to try to do dwordwise move optimization
    cmp     r2, #16
    907c:	cmp	r2, #16
    blt     .L_bytewise
    907e:	blt.n	90b0 <memset+0x38>

    // see how many bytes we need to move to align to dword boundaries
    and     r3, r0, #7
    9080:	and.w	r3, r0, #7
    cbz     r3, .L_prepare_dwordwise
    9084:	cbz	r3, 9094 <memset+0x1c>
    rsb     r3, #8
    9086:	rsb	r3, r3, #8
    subs    r2, r3
    908a:	subs	r2, r2, r3

.L_bytewise_align:
    // bytewise to align memset
    subs    r3, r3, #1
    908c:	subs	r3, #1
    strb    r1, [r0], #1
    908e:	strb.w	r1, [r0], #1
    bgt     .L_bytewise_align
    9092:	bgt.n	908c <memset+0x14>

.L_prepare_dwordwise:
    // fill a pair of 32 bit registers with the 8 bit value
    uxtb    r1, r1
    9094:	uxtb	r1, r1
    orr     r1, r1, r1, lsl #8
    9096:	orr.w	r1, r1, r1, lsl #8
    orr     r1, r1, r1, lsl #16
    909a:	orr.w	r1, r1, r1, lsl #16
    mov     r12, r1
    909e:	mov	ip, r1

    // load the number of dwords left
    lsrs    r3, r2, #3
    90a0:	lsrs	r3, r2, #3

.L_dwordwise:
    // dwordwise memset
		
    subs    r3, r3, #1
    90a2:	subs	r3, #1
    strd    r1, r12, [r0], #8
    90a4:	strd	r1, ip, [r0], #8
    bgt     .L_dwordwise
    90a8:	bgt.n	90a2 <memset+0x2a>

    // remaining bytes
    ands     r2, #7
    90aa:	ands.w	r2, r2, #7
    beq     .L_done
    90ae:	beq.n	90b8 <memset+0x40>

.L_bytewise:
    // bytewise memset
    subs    r2, r2, #1
    90b0:	subs	r2, #1
    strb    r1, [r0], #1
    90b2:	strb.w	r1, [r0], #1
    bgt     .L_bytewise
    90b6:	bgt.n	90b0 <memset+0x38>

.L_done:
    // restore the base pointer as return value
    pop     { r0, pc }
    90b8:	pop	{r0, pc}
    90ba:	nop

000090bc <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    90bc:	push	{r4, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    90be:	ldr	r4, [pc, #64]	; (9100 <usb_serial_getchar+0x44>)
    90c0:	ldr	r3, [r4, #0]
    90c2:	cbz	r3, 90e0 <usb_serial_getchar+0x24>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    90c4:	ldr	r0, [r4, #0]
    90c6:	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
    90c8:	adds	r2, r3, #1
    90ca:	add	r3, r0
    90cc:	ldrb	r4, [r3, #8]
	if (i >= rx_packet->len) {
    90ce:	ldrh	r3, [r0, #0]
    90d0:	cmp	r2, r3
    90d2:	bcc.n	90fa <usb_serial_getchar+0x3e>
		usb_free(rx_packet);
    90d4:	bl	9680 <usb_free>
		rx_packet = NULL;
    90d8:	ldr	r3, [pc, #36]	; (9100 <usb_serial_getchar+0x44>)
    90da:	movs	r2, #0
    90dc:	str	r2, [r3, #0]
    90de:	b.n	90fc <usb_serial_getchar+0x40>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    90e0:	ldr	r3, [pc, #32]	; (9104 <usb_serial_getchar+0x48>)
    90e2:	ldrb	r3, [r3, #0]
    90e4:	cbnz	r3, 90ec <usb_serial_getchar+0x30>
    90e6:	mov.w	r0, #4294967295
    90ea:	pop	{r4, pc}
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    90ec:	movs	r0, #3
    90ee:	bl	9704 <usb_rx>
    90f2:	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    90f4:	cmp	r0, #0
    90f6:	bne.n	90c4 <usb_serial_getchar+0x8>
    90f8:	b.n	90e6 <usb_serial_getchar+0x2a>
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    90fa:	strh	r2, [r0, #2]
	}
	return c;
    90fc:	mov	r0, r4
}
    90fe:	pop	{r4, pc}
    9100:	.word	0x2001cf18
    9104:	.word	0x2001d003

00009108 <usb_serial_peekchar>:

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    9108:	push	{r4, lr}
	if (!rx_packet) {
    910a:	ldr	r4, [pc, #44]	; (9138 <usb_serial_peekchar+0x30>)
    910c:	ldr	r3, [r4, #0]
    910e:	cbz	r3, 9116 <usb_serial_peekchar+0xe>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
    9110:	ldr	r2, [r4, #0]
    9112:	cbnz	r2, 9130 <usb_serial_peekchar+0x28>
    9114:	b.n	911c <usb_serial_peekchar+0x14>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    9116:	ldr	r3, [pc, #36]	; (913c <usb_serial_peekchar+0x34>)
    9118:	ldrb	r3, [r3, #0]
    911a:	cbnz	r3, 9122 <usb_serial_peekchar+0x1a>
    911c:	mov.w	r0, #4294967295
    9120:	pop	{r4, pc}
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    9122:	movs	r0, #3
    9124:	bl	9704 <usb_rx>
    9128:	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    912a:	cmp	r0, #0
    912c:	bne.n	9110 <usb_serial_peekchar+0x8>
    912e:	b.n	911c <usb_serial_peekchar+0x14>
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    9130:	ldrh	r3, [r2, #2]
    9132:	add	r3, r2
    9134:	ldrb	r0, [r3, #8]
}
    9136:	pop	{r4, pc}
    9138:	.word	0x2001cf18
    913c:	.word	0x2001d003

00009140 <usb_serial_available>:
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    9140:	ldr	r3, [pc, #16]	; (9154 <usb_serial_available+0x14>)

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    9142:	ldrh	r0, [r3, #4]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    9144:	ldr	r3, [pc, #16]	; (9158 <usb_serial_available+0x18>)
    9146:	ldr	r2, [r3, #0]
    9148:	cbz	r2, 9152 <usb_serial_available+0x12>
    914a:	ldrh	r3, [r2, #0]
    914c:	ldrh	r2, [r2, #2]
    914e:	subs	r3, r3, r2
    9150:	add	r0, r3
	return count;
}
    9152:	bx	lr
    9154:	.word	0x2001d078
    9158:	.word	0x2001cf18

0000915c <usb_serial_flush_input>:
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    915c:	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
    915e:	ldr	r3, [pc, #36]	; (9184 <usb_serial_flush_input+0x28>)
    9160:	ldrb	r3, [r3, #0]
    9162:	cbz	r3, 9180 <usb_serial_flush_input+0x24>
	if (rx_packet) {
    9164:	ldr	r4, [pc, #32]	; (9188 <usb_serial_flush_input+0x2c>)
    9166:	ldr	r0, [r4, #0]
    9168:	cbz	r0, 9172 <usb_serial_flush_input+0x16>
		usb_free(rx_packet);
    916a:	bl	9680 <usb_free>
		rx_packet = NULL;
    916e:	movs	r3, #0
    9170:	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    9172:	movs	r0, #3
    9174:	bl	9704 <usb_rx>
		if (!rx) break;
    9178:	cbz	r0, 9180 <usb_serial_flush_input+0x24>
		usb_free(rx);
    917a:	bl	9680 <usb_free>
	}
    917e:	b.n	9172 <usb_serial_flush_input+0x16>
    9180:	pop	{r4, pc}
    9182:	nop
    9184:	.word	0x2001d003
    9188:	.word	0x2001cf18

0000918c <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    918c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    9190:	ldr	r5, [pc, #196]	; (9258 <usb_serial_write+0xcc>)
	while (size > 0) {
		if (!tx_packet) {
    9192:	ldr.w	r9, [pc, #212]	; 9268 <usb_serial_write+0xdc>
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    9196:	movs	r3, #1
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    9198:	mov	sl, r0
    919a:	mov	r4, r1
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    919c:	strb	r3, [r5, #0]
	while (size > 0) {
    919e:	mov	r6, r1
    91a0:	mov	r7, r9
    91a2:	cmp	r6, #0
    91a4:	beq.n	924e <usb_serial_write+0xc2>
		if (!tx_packet) {
    91a6:	ldr.w	r3, [r9]
    91aa:	cbnz	r3, 91fc <usb_serial_write+0x70>
    91ac:	ldr.w	fp, [pc, #176]	; 9260 <usb_serial_write+0xd4>
    91b0:	movw	r8, #41721	; 0xa2f9
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    91b4:	ldr	r3, [pc, #164]	; (925c <usb_serial_write+0xd0>)
    91b6:	ldrb	r3, [r3, #0]
    91b8:	and.w	r1, r3, #255	; 0xff
    91bc:	cbnz	r3, 91c2 <usb_serial_write+0x36>
					tx_noautoflush = 0;
    91be:	strb	r1, [r5, #0]
    91c0:	b.n	91ee <usb_serial_write+0x62>
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    91c2:	movs	r0, #4
    91c4:	bl	973c <usb_tx_packet_count>
    91c8:	cmp	r0, #7
    91ca:	bhi.n	91dc <usb_serial_write+0x50>
					tx_noautoflush = 1;
    91cc:	movs	r3, #1
    91ce:	strb	r3, [r5, #0]
					tx_packet = usb_malloc();
    91d0:	bl	9644 <usb_malloc>
    91d4:	str	r0, [r7, #0]
					if (tx_packet) break;
    91d6:	cbnz	r0, 91fc <usb_serial_write+0x70>
					tx_noautoflush = 0;
    91d8:	ldr	r3, [pc, #124]	; (9258 <usb_serial_write+0xcc>)
    91da:	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    91dc:	subs.w	r8, r8, #1
    91e0:	beq.n	91e8 <usb_serial_write+0x5c>
    91e2:	ldrb.w	r3, [fp]
    91e6:	cbz	r3, 91f6 <usb_serial_write+0x6a>
					transmit_previous_timeout = 1;
    91e8:	ldr	r3, [pc, #116]	; (9260 <usb_serial_write+0xd4>)
    91ea:	movs	r2, #1
    91ec:	strb	r2, [r3, #0]
					return -1;
    91ee:	mov.w	r0, #4294967295
    91f2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				}
				yield();
    91f6:	bl	9f10 <yield>
			}
    91fa:	b.n	91b4 <usb_serial_write+0x28>
		}
		transmit_previous_timeout = 0;
    91fc:	ldr	r3, [pc, #96]	; (9260 <usb_serial_write+0xd4>)
    91fe:	movs	r1, #0
    9200:	strb	r1, [r3, #0]
		len = CDC_TX_SIZE - tx_packet->index;
    9202:	ldr	r1, [r7, #0]
    9204:	ldrh	r3, [r1, #2]
    9206:	rsb	r0, r3, #64	; 0x40
    920a:	cmp	r0, r6
    920c:	it	cs
    920e:	movcs	r0, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    9210:	add.w	lr, r3, r0
    9214:	add	r3, r1
    9216:	strh.w	lr, [r1, #2]
		size -= len;
    921a:	subs	r6, r6, r0
    921c:	adds	r3, #7
    921e:	add.w	r8, sl, r0
		while (len-- > 0) *dest++ = *src++;
    9222:	cmp	sl, r8
    9224:	beq.n	9230 <usb_serial_write+0xa4>
    9226:	ldrb.w	r0, [sl], #1
    922a:	strb.w	r0, [r3, #1]!
    922e:	b.n	9222 <usb_serial_write+0x96>
		if (tx_packet->index >= CDC_TX_SIZE) {
    9230:	ldrh	r3, [r1, #2]
    9232:	cmp	r3, #63	; 0x3f
    9234:	bls.n	9244 <usb_serial_write+0xb8>
			tx_packet->len = CDC_TX_SIZE;
    9236:	movs	r3, #64	; 0x40
    9238:	strh	r3, [r1, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    923a:	movs	r0, #4
    923c:	bl	97d8 <usb_tx>
			tx_packet = NULL;
    9240:	movs	r3, #0
    9242:	str	r3, [r7, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    9244:	ldr	r3, [pc, #28]	; (9264 <usb_serial_write+0xd8>)
    9246:	movs	r2, #5
    9248:	strb	r2, [r3, #0]
    924a:	mov	sl, r8
    924c:	b.n	91a2 <usb_serial_write+0x16>
	}
	tx_noautoflush = 0;
    924e:	strb	r6, [r5, #0]
	return ret;
    9250:	mov	r0, r4
}
    9252:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9256:	nop
    9258:	.word	0x2001cf0d
    925c:	.word	0x2001d003
    9260:	.word	0x2001cf14
    9264:	.word	0x2001cf0c
    9268:	.word	0x2001cf10

0000926c <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    926c:	push	{r0, r1, r2, lr}
    926e:	add	r3, sp, #8
	return usb_serial_write(&c, 1);
    9270:	movs	r1, #1
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    9272:	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    9276:	mov	r0, r3
    9278:	bl	918c <usb_serial_write>
}
    927c:	add	sp, #12
    927e:	ldr.w	pc, [sp], #4
    9282:	Address 0x00009282 is out of bounds.


00009284 <usb_serial_write_buffer_free>:
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    9284:	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
    9286:	ldr	r4, [pc, #56]	; (92c0 <usb_serial_write_buffer_free+0x3c>)
	if (!tx_packet) {
    9288:	ldr	r5, [pc, #56]	; (92c4 <usb_serial_write_buffer_free+0x40>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    928a:	movs	r3, #1
    928c:	strb	r3, [r4, #0]
	if (!tx_packet) {
    928e:	ldr	r3, [r5, #0]
    9290:	cbnz	r3, 92b2 <usb_serial_write_buffer_free+0x2e>
		if (!usb_configuration ||
    9292:	ldr	r3, [pc, #52]	; (92c8 <usb_serial_write_buffer_free+0x44>)
    9294:	ldrb	r3, [r3, #0]
    9296:	cbnz	r3, 929e <usb_serial_write_buffer_free+0x1a>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    9298:	movs	r0, #0
    929a:	strb	r0, [r4, #0]
			return 0;
    929c:	pop	{r3, r4, r5, pc}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    929e:	movs	r0, #4
    92a0:	bl	973c <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    92a4:	cmp	r0, #7
    92a6:	bhi.n	9298 <usb_serial_write_buffer_free+0x14>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    92a8:	bl	9644 <usb_malloc>
    92ac:	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    92ae:	cmp	r0, #0
    92b0:	beq.n	9298 <usb_serial_write_buffer_free+0x14>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    92b2:	ldr	r3, [r5, #0]
    92b4:	ldrh	r0, [r3, #2]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    92b6:	movs	r3, #0
    92b8:	strb	r3, [r4, #0]
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    92ba:	rsb	r0, r0, #64	; 0x40
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    92be:	pop	{r3, r4, r5, pc}
    92c0:	.word	0x2001cf0d
    92c4:	.word	0x2001cf10
    92c8:	.word	0x2001d003

000092cc <usb_serial_flush_output>:

void usb_serial_flush_output(void)
{
    92cc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!usb_configuration) return;
    92d0:	ldr	r3, [pc, #68]	; (9318 <usb_serial_flush_output+0x4c>)
    92d2:	ldrb	r3, [r3, #0]
    92d4:	cbz	r3, 9314 <usb_serial_flush_output+0x48>
	tx_noautoflush = 1;
	if (tx_packet) {
    92d6:	ldr	r7, [pc, #68]	; (931c <usb_serial_flush_output+0x50>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    92d8:	ldr	r3, [pc, #68]	; (9320 <usb_serial_flush_output+0x54>)
	if (tx_packet) {
    92da:	ldr	r4, [r7, #0]
    92dc:	ldr	r5, [pc, #68]	; (9324 <usb_serial_flush_output+0x58>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    92de:	movs	r6, #1
    92e0:	strb	r6, [r3, #0]
    92e2:	mov	r8, r3
	if (tx_packet) {
    92e4:	cbz	r4, 92fa <usb_serial_flush_output+0x2e>
		usb_cdc_transmit_flush_timer = 0;
    92e6:	movs	r6, #0
		tx_packet->len = tx_packet->index;
    92e8:	ldrh	r3, [r4, #2]
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    92ea:	strb	r6, [r5, #0]
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    92ec:	mov	r1, r4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    92ee:	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    92f0:	movs	r0, #4
    92f2:	bl	97d8 <usb_tx>
		tx_packet = NULL;
    92f6:	str	r6, [r7, #0]
    92f8:	b.n	930e <usb_serial_flush_output+0x42>
	} else {
		usb_packet_t *tx = usb_malloc();
    92fa:	bl	9644 <usb_malloc>
		if (tx) {
    92fe:	mov	r1, r0
    9300:	cbz	r0, 930c <usb_serial_flush_output+0x40>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    9302:	movs	r0, #4
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    9304:	strb	r4, [r5, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    9306:	bl	97d8 <usb_tx>
    930a:	b.n	930e <usb_serial_flush_output+0x42>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    930c:	strb	r6, [r5, #0]
		}
	}
	tx_noautoflush = 0;
    930e:	movs	r3, #0
    9310:	strb.w	r3, [r8]
    9314:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9318:	.word	0x2001d003
    931c:	.word	0x2001cf10
    9320:	.word	0x2001cf0d
    9324:	.word	0x2001cf0c

00009328 <usb_serial_flush_callback>:
}

void usb_serial_flush_callback(void)
{
    9328:	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
    932a:	ldr	r3, [pc, #56]	; (9364 <usb_serial_flush_callback+0x3c>)
    932c:	ldrb	r3, [r3, #0]
    932e:	and.w	r5, r3, #255	; 0xff
    9332:	cbnz	r3, 9360 <usb_serial_flush_callback+0x38>
	if (tx_packet) {
    9334:	ldr	r4, [pc, #48]	; (9368 <usb_serial_flush_callback+0x40>)
    9336:	ldr	r1, [r4, #0]
    9338:	cbz	r1, 9348 <usb_serial_flush_callback+0x20>
		tx_packet->len = tx_packet->index;
    933a:	ldrh	r3, [r1, #2]
    933c:	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    933e:	movs	r0, #4
    9340:	bl	97d8 <usb_tx>
		tx_packet = NULL;
    9344:	str	r5, [r4, #0]
    9346:	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
    9348:	bl	9644 <usb_malloc>
		if (tx) {
    934c:	mov	r1, r0
    934e:	cbz	r0, 935a <usb_serial_flush_callback+0x32>
			usb_tx(CDC_TX_ENDPOINT, tx);
    9350:	movs	r0, #4
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    9352:	ldmia.w	sp!, {r3, r4, r5, lr}
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
    9356:	b.w	97d8 <usb_tx>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    935a:	ldr	r3, [pc, #16]	; (936c <usb_serial_flush_callback+0x44>)
    935c:	movs	r2, #1
    935e:	strb	r2, [r3, #0]
    9360:	pop	{r3, r4, r5, pc}
    9362:	nop
    9364:	.word	0x2001cf0d
    9368:	.word	0x2001cf10
    936c:	.word	0x2001cf0c

00009370 <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
    9370:	push	{r3, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    9372:	ldr	r5, [pc, #44]	; (93a0 <fault_isr+0x30>)
    9374:	mov	r4, r5
    9376:	ldr	r3, [r5, #0]
    9378:	lsls	r0, r3, #13
    937a:	bpl.n	9380 <fault_isr+0x10>
    937c:	bl	9858 <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    9380:	ldr	r3, [r4, #0]
    9382:	lsls	r1, r3, #21
    9384:	bpl.n	938a <fault_isr+0x1a>
    9386:	bl	93a4 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    938a:	ldr	r3, [r4, #0]
    938c:	lsls	r2, r3, #20
    938e:	bpl.n	9394 <fault_isr+0x24>
    9390:	bl	93a4 <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    9394:	ldr	r3, [r4, #0]
    9396:	lsls	r3, r3, #19
    9398:	bpl.n	9376 <fault_isr+0x6>
    939a:	bl	93a4 <unused_isr>
    939e:	b.n	9376 <fault_isr+0x6>
    93a0:	.word	0x40048034

000093a4 <unused_isr>:
	}
}

void unused_isr(void)
{
    93a4:	push	{r3, lr}
	fault_isr();
    93a6:	bl	9370 <fault_isr>
    93aa:	Address 0x000093aa is out of bounds.


000093ac <startup_early_hook>:
extern void rtc_set(unsigned long t);


static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    93ac:	ldr	r3, [pc, #4]	; (93b4 <startup_early_hook+0x8>)
    93ae:	movs	r2, #16
    93b0:	strh	r2, [r3, #0]
    93b2:	bx	lr
    93b4:	.word	0x40052000

000093b8 <startup_late_hook>:
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
#endif
}
static void startup_default_late_hook(void) {}
    93b8:	bx	lr
    93ba:	Address 0x000093ba is out of bounds.


000093bc <_sbrk>:

void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
    93bc:	ldr	r1, [pc, #36]	; (93e4 <_sbrk+0x28>)

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
    93be:	push	{r3, lr}
	char *prev, *stack;

	prev = __brkval;
    93c0:	ldr	r3, [r1, #0]
	if (incr != 0) {
    93c2:	cbz	r0, 93e0 <_sbrk+0x24>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    93c4:	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
    93c6:	add	r0, r3
    93c8:	sub.w	r2, r2, #8192	; 0x2000
    93cc:	cmp	r0, r2
    93ce:	bcc.n	93de <_sbrk+0x22>
			errno = ENOMEM;
    93d0:	bl	b228 <__errno>
    93d4:	movs	r3, #12
    93d6:	str	r3, [r0, #0]
			return (void *)-1;
    93d8:	mov.w	r0, #4294967295
    93dc:	pop	{r3, pc}
		}
		__brkval = prev + incr;
    93de:	str	r0, [r1, #0]
	}
	return prev;
    93e0:	mov	r0, r3
}
    93e2:	pop	{r3, pc}
    93e4:	.word	0x1fff1360

000093e8 <__cxa_pure_virtual>:
	while (1);
}

__attribute__((weak)) 
void __cxa_pure_virtual()
{
    93e8:	b.n	93e8 <__cxa_pure_virtual>
    93ea:	Address 0x000093ea is out of bounds.


000093ec <attachInterruptVector>:
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    93ec:	adds	r0, #16
    93ee:	ldr	r3, [pc, #8]	; (93f8 <attachInterruptVector+0xc>)
    93f0:	str.w	r1, [r3, r0, lsl #2]
    93f4:	bx	lr
    93f6:	nop
    93f8:	.word	0x1fff0a00

000093fc <rtc_get>:

#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)

unsigned long rtc_get(void)
{
	return RTC_TSR;
    93fc:	ldr	r3, [pc, #4]	; (9404 <rtc_get+0x8>)
    93fe:	ldr	r0, [r3, #0]
}
    9400:	bx	lr
    9402:	nop
    9404:	.word	0x4003d000

00009408 <rtc_set>:

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    9408:	ldr	r3, [pc, #16]	; (941c <rtc_set+0x14>)
	RTC_TPR = 0;
    940a:	ldr	r1, [pc, #20]	; (9420 <rtc_set+0x18>)
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    940c:	movs	r2, #0
    940e:	str	r2, [r3, #0]
	RTC_TPR = 0;
    9410:	str	r2, [r1, #0]
	RTC_TSR = t;
    9412:	ldr	r2, [pc, #16]	; (9424 <rtc_set+0x1c>)
    9414:	str	r0, [r2, #0]
	RTC_SR = RTC_SR_TCE;
    9416:	movs	r2, #16
    9418:	str	r2, [r3, #0]
    941a:	bx	lr
    941c:	.word	0x4003d014
    9420:	.word	0x4003d004
    9424:	.word	0x4003d000

00009428 <startup_middle_hook>:
}
#endif

extern void usb_init(void);

static void startup_default_middle_hook(void) {}
    9428:	bx	lr
    942a:	Address 0x0000942a is out of bounds.


0000942c <digitalWrite>:

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    942c:	cmp	r0, #63	; 0x3f


// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
    942e:	push	{r4, lr}
	if (pin >= CORE_NUM_DIGITAL) return;
    9430:	bhi.n	9464 <digitalWrite+0x38>
#ifdef KINETISK
	if (*portModeRegister(pin)) {
    9432:	ldr	r3, [pc, #52]	; (9468 <digitalWrite+0x3c>)
    9434:	ldr.w	r2, [r3, r0, lsl #3]
    9438:	ldrb.w	r4, [r2, #640]	; 0x280
    943c:	cbz	r4, 944e <digitalWrite+0x22>
    943e:	movs	r3, #1
		if (val) {
    9440:	cbz	r1, 9448 <digitalWrite+0x1c>
			*portSetRegister(pin) = 1;
    9442:	strb.w	r3, [r2, #128]	; 0x80
    9446:	pop	{r4, pc}
		} else {
			*portClearRegister(pin) = 1;
    9448:	strb.w	r3, [r2, #256]	; 0x100
    944c:	pop	{r4, pc}
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
    944e:	add.w	r3, r3, r0, lsl #3
    9452:	ldr	r3, [r3, #4]
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    9454:	ldr	r2, [r3, #0]
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
    9456:	cbz	r1, 945e <digitalWrite+0x32>
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    9458:	orr.w	r2, r2, #3
    945c:	b.n	9462 <digitalWrite+0x36>
			//*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else {
			// TODO use bitband for atomic read-mod-write
			*config &= ~(PORT_PCR_PE);
    945e:	bic.w	r2, r2, #2
    9462:	str	r2, [r3, #0]
    9464:	pop	{r4, pc}
    9466:	nop
    9468:	.word	0x00012e4c

0000946c <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    946c:	cmp	r0, #63	; 0x3f
}



void pinMode(uint8_t pin, uint8_t mode)
{
    946e:	push	{r4, lr}
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    9470:	bhi.n	94ca <pinMode+0x5e>
	config = portConfigRegister(pin);
    9472:	ldr	r2, [pc, #88]	; (94cc <pinMode+0x60>)
    9474:	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    9478:	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    947a:	ldr	r3, [r3, #4]
    947c:	mov	r4, r2

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    947e:	beq.n	9484 <pinMode+0x18>
    9480:	cmp	r1, #4
    9482:	bne.n	94a4 <pinMode+0x38>
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    9484:	ldr.w	r2, [r4, r0, lsl #3]
    9488:	movs	r0, #1
    948a:	strb.w	r0, [r2, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    948e:	mov.w	r2, #324	; 0x144
    9492:	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    9494:	ldr	r2, [r3, #0]
		*portModeRegister(pin) = 1;
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
		if (mode == OUTPUT_OPENDRAIN) {
    9496:	cmp	r1, #4
		    *config |= PORT_PCR_ODE;
    9498:	ite	eq
    949a:	orreq.w	r2, r2, #32
		} else {
		    *config &= ~PORT_PCR_ODE;
    949e:	bicne.w	r2, r2, #32
    94a2:	b.n	94c8 <pinMode+0x5c>
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    94a4:	ldr.w	r0, [r2, r0, lsl #3]
    94a8:	movs	r2, #0
    94aa:	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    94ae:	cbnz	r1, 94b6 <pinMode+0x4a>
			*config = PORT_PCR_MUX(1);
    94b0:	mov.w	r2, #256	; 0x100
    94b4:	b.n	94c8 <pinMode+0x5c>
		} else if (mode == INPUT_PULLUP) {
    94b6:	cmp	r1, #2
    94b8:	bne.n	94c0 <pinMode+0x54>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    94ba:	movw	r2, #259	; 0x103
    94be:	b.n	94c8 <pinMode+0x5c>
		} else if (mode == INPUT_PULLDOWN) {
    94c0:	cmp	r1, #3
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    94c2:	it	eq
    94c4:	moveq.w	r2, #258	; 0x102
		} else { // INPUT_DISABLE
			*config = 0;
    94c8:	str	r2, [r3, #0]
    94ca:	pop	{r4, pc}
    94cc:	.word	0x00012e4c

000094d0 <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    94d0:	cpsid	i
	current = SYST_CVR;
    94d2:	ldr	r3, [pc, #44]	; (9500 <micros+0x30>)
	count = systick_millis_count;
    94d4:	ldr	r2, [pc, #44]	; (9504 <micros+0x34>)
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    94d6:	ldr	r1, [pc, #48]	; (9508 <micros+0x38>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    94d8:	ldr	r3, [r3, #0]
	count = systick_millis_count;
    94da:	ldr	r2, [r2, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    94dc:	ldr	r1, [r1, #0]
	__enable_irq();
    94de:	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    94e0:	lsls	r1, r1, #5
    94e2:	bpl.n	94ea <micros+0x1a>
    94e4:	cmp	r3, #50	; 0x32
    94e6:	it	hi
    94e8:	addhi	r2, #1
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    94ea:	rsb	r3, r3, #95744	; 0x17600
    94ee:	movs	r0, #96	; 0x60
    94f0:	adds	r3, #255	; 0xff
    94f2:	udiv	r3, r3, r0
}
    94f6:	mov.w	r0, #1000	; 0x3e8
    94fa:	mla	r0, r0, r2, r3
    94fe:	bx	lr
    9500:	.word	0xe000e018
    9504:	.word	0x2001cf20
    9508:	.word	0xe000ed04

0000950c <delay>:

void delay(uint32_t ms)
{
    950c:	push	{r3, r4, r5, lr}
    950e:	mov	r4, r0
	uint32_t start = micros();
    9510:	bl	94d0 <micros>
    9514:	mov	r5, r0

	if (ms > 0) {
    9516:	cbnz	r4, 9522 <delay+0x16>
    9518:	pop	{r3, r4, r5, pc}
		while (1) {
			while ((micros() - start) >= 1000) {
				ms--;
				if (ms == 0) return;
    951a:	subs	r4, #1
    951c:	beq.n	9534 <delay+0x28>
				start += 1000;
    951e:	add.w	r5, r5, #1000	; 0x3e8
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    9522:	bl	94d0 <micros>
    9526:	subs	r0, r0, r5
    9528:	cmp.w	r0, #1000	; 0x3e8
    952c:	bcs.n	951a <delay+0xe>
				ms--;
				if (ms == 0) return;
				start += 1000;
			}
			yield();
    952e:	bl	9f10 <yield>
		}
    9532:	b.n	9522 <delay+0x16>
    9534:	pop	{r3, r4, r5, pc}
    9536:	Address 0x00009536 is out of bounds.


00009538 <_init_Teensyduino_internal_>:
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    9538:	ldr	r3, [pc, #224]	; (961c <_init_Teensyduino_internal_+0xe4>)
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    953a:	ldr	r1, [pc, #228]	; (9620 <_init_Teensyduino_internal_+0xe8>)
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    953c:	mov.w	r2, #134217728	; 0x8000000
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    9540:	push	{r4, r5, r6, lr}
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    9542:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    9544:	mov.w	r2, #268435456	; 0x10000000
    9548:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    954a:	mov.w	r2, #536870912	; 0x20000000
    954e:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    9550:	mov.w	r2, #1073741824	; 0x40000000
    9554:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    9556:	mov.w	r2, #2147483648	; 0x80000000
    955a:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    955c:	ldr	r3, [pc, #196]	; (9624 <_init_Teensyduino_internal_+0xec>)
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    955e:	ldr	r5, [pc, #200]	; (9628 <_init_Teensyduino_internal_+0xf0>)
	FTM3_C1SC = 0x28;
    9560:	ldr	r4, [pc, #200]	; (962c <_init_Teensyduino_internal_+0xf4>)
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9562:	ldr	r6, [pc, #204]	; (9630 <_init_Teensyduino_internal_+0xf8>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    9564:	movs	r2, #0
	FTM0_MOD = DEFAULT_FTM_MOD;
    9566:	movw	r0, #49151	; 0xbfff
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    956a:	str	r2, [r3, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
    956c:	str	r0, [r3, #4]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    956e:	movs	r3, #40	; 0x28
    9570:	str	r3, [r1, #0]
	FTM0_C1SC = 0x28;
    9572:	str	r3, [r1, #8]
	FTM0_C2SC = 0x28;
    9574:	str	r3, [r1, #16]
	FTM0_C3SC = 0x28;
    9576:	str	r3, [r1, #24]
	FTM0_C4SC = 0x28;
    9578:	str	r3, [r1, #32]
	FTM0_C5SC = 0x28;
    957a:	str	r3, [r1, #40]	; 0x28
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    957c:	str	r3, [r1, #48]	; 0x30
	FTM0_C7SC = 0x28;
    957e:	str	r3, [r1, #56]	; 0x38
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
    9580:	adds	r1, #16
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    9582:	add.w	r1, r1, #528384	; 0x81000
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    9586:	str	r3, [r5, #0]
	FTM3_C1SC = 0x28;
    9588:	str	r3, [r4, #0]
	FTM3_C2SC = 0x28;
    958a:	str	r3, [r1, #0]
	FTM3_C3SC = 0x28;
    958c:	str	r3, [r1, #8]
	FTM3_C4SC = 0x28;
    958e:	str	r3, [r1, #16]
	FTM3_C5SC = 0x28;
    9590:	str	r3, [r1, #24]
	FTM3_C6SC = 0x28;
    9592:	str	r3, [r1, #32]
	FTM3_C7SC = 0x28;
    9594:	str	r3, [r1, #40]	; 0x28
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9596:	movs	r1, #9
    9598:	str	r1, [r6, #0]
	FTM1_CNT = 0;
    959a:	add.w	r6, r6, #4096	; 0x1000
    959e:	adds	r6, #4
    95a0:	str	r2, [r6, #0]
	FTM1_MOD = DEFAULT_FTM_MOD;
    95a2:	str	r0, [r6, #4]
	FTM1_C0SC = 0x28;
    95a4:	str	r3, [r6, #8]
	FTM1_C1SC = 0x28;
    95a6:	str	r3, [r6, #16]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    95a8:	str.w	r1, [r6, #-4]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    95ac:	add.w	r6, r6, #520192	; 0x7f000
    95b0:	str	r2, [r6, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    95b2:	str	r0, [r6, #4]
	FTM2_C0SC = 0x28;
    95b4:	str	r3, [r6, #8]
	FTM2_C1SC = 0x28;
    95b6:	str	r3, [r6, #16]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    95b8:	str.w	r1, [r6, #-4]
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
    95bc:	add.w	r6, r6, #4096	; 0x1000
    95c0:	str	r2, [r6, #0]
	FTM3_MOD = DEFAULT_FTM_MOD;
    95c2:	str	r0, [r6, #4]
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    95c4:	ldr	r0, [pc, #108]	; (9634 <_init_Teensyduino_internal_+0xfc>)
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
	FTM3_C0SC = 0x28;
    95c6:	str	r3, [r5, #0]
	FTM3_C1SC = 0x28;
    95c8:	str	r3, [r4, #0]
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    95ca:	str	r1, [r0, #0]
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    95cc:	sub.w	r0, r0, #460800	; 0x70800
    95d0:	subw	r0, r0, #2004	; 0x7d4
    95d4:	ldr	r1, [r0, #0]
    95d6:	orr.w	r1, r1, #512	; 0x200
    95da:	str	r1, [r0, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    95dc:	ldr.w	r1, [r0, #-40]
    95e0:	orr.w	r1, r1, #33554432	; 0x2000000
    95e4:	str.w	r1, [r0, #-40]
	TPM1_CNT = 0;
    95e8:	ldr	r1, [pc, #76]	; (9638 <_init_Teensyduino_internal_+0x100>)
    95ea:	str	r2, [r1, #0]
	TPM1_MOD = 32767;
    95ec:	ldr	r2, [pc, #76]	; (963c <_init_Teensyduino_internal_+0x104>)
    95ee:	movw	r1, #32767	; 0x7fff
    95f2:	str	r1, [r2, #0]
	TPM1_C0SC = 0x28;
    95f4:	str	r3, [r2, #4]
	TPM1_C1SC = 0x28;
    95f6:	str	r3, [r2, #12]
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    95f8:	ldr	r3, [pc, #68]	; (9640 <_init_Teensyduino_internal_+0x108>)
    95fa:	movs	r2, #8
    95fc:	str	r2, [r3, #0]
#endif
	analog_init();
    95fe:	bl	a378 <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	startup_middle_hook();
    9602:	bl	9428 <startup_middle_hook>
	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    9606:	movs	r0, #20
    9608:	bl	950c <delay>
	usb_init();
    960c:	bl	9e7c <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    9610:	mov.w	r0, #280	; 0x118
}
    9614:	ldmia.w	sp!, {r4, r5, r6, lr}
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	startup_middle_hook();
	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    9618:	b.w	950c <delay>
    961c:	.word	0xe000e104
    9620:	.word	0x4003800c
    9624:	.word	0x40038004
    9628:	.word	0x400b900c
    962c:	.word	0x400b9014
    9630:	.word	0x40038000
    9634:	.word	0x400b9000
    9638:	.word	0x400c9004
    963c:	.word	0x400c9008
    9640:	.word	0x400c9000

00009644 <usb_malloc>:
// http://www.archivum.info/gnu.gcc.help/2006-08/00148/Re-GCC-Inline-Assembly.html
// http://gcc.gnu.org/ml/gcc/2012-06/msg00015.html
// __builtin_clz()

usb_packet_t * usb_malloc(void)
{
    9644:	push	{r4, lr}
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    9646:	cpsid	i
	avail = usb_buffer_available;
    9648:	ldr	r0, [pc, #44]	; (9678 <usb_malloc+0x34>)
    964a:	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    964c:	clz	r1, r2
	if (n >= NUM_USB_BUFFERS) {
    9650:	cmp	r1, #11
    9652:	ble.n	965a <usb_malloc+0x16>
		__enable_irq();
    9654:	cpsie	i
		return NULL;
    9656:	movs	r0, #0
    9658:	pop	{r4, pc}
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    965a:	mov.w	r3, #2147483648	; 0x80000000
    965e:	lsrs	r3, r1
    9660:	bic.w	r2, r2, r3
    9664:	str	r2, [r0, #0]
	__enable_irq();
    9666:	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    9668:	ldr	r4, [pc, #16]	; (967c <usb_malloc+0x38>)
    966a:	movs	r3, #72	; 0x48
    966c:	muls	r3, r1
    966e:	adds	r0, r4, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    9670:	movs	r2, #0
    9672:	str	r2, [r4, r3]
	*(uint32_t *)(p + 4) = 0;
    9674:	str	r2, [r0, #4]
	return (usb_packet_t *)p;
}
    9676:	pop	{r4, pc}
    9678:	.word	0x1fff1364
    967c:	.word	0x1fff0bd0

00009680 <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    9680:	ldr	r3, [pc, #48]	; (96b4 <usb_free+0x34>)
    9682:	movs	r2, #72	; 0x48
    9684:	subs	r3, r0, r3
    9686:	udiv	r3, r3, r2
	if (n >= NUM_USB_BUFFERS) return;
    968a:	cmp	r3, #11
    968c:	bhi.n	96b2 <usb_free+0x32>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    968e:	ldr	r2, [pc, #40]	; (96b8 <usb_free+0x38>)
    9690:	ldrb	r2, [r2, #0]
    9692:	cbz	r2, 969e <usb_free+0x1e>
    9694:	ldr	r2, [pc, #36]	; (96bc <usb_free+0x3c>)
    9696:	ldrb	r2, [r2, #0]
    9698:	cbz	r2, 969e <usb_free+0x1e>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    969a:	b.w	9760 <usb_rx_memory>
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    969e:	cpsid	i
	usb_buffer_available |= mask;
    96a0:	ldr	r1, [pc, #28]	; (96c0 <usb_free+0x40>)
    96a2:	mov.w	r2, #2147483648	; 0x80000000
    96a6:	lsr.w	r3, r2, r3
    96aa:	ldr	r2, [r1, #0]
    96ac:	orrs	r2, r3
    96ae:	str	r2, [r1, #0]
	__enable_irq();
    96b0:	cpsie	i
    96b2:	bx	lr
    96b4:	.word	0x1fff0bd0
    96b8:	.word	0x2001cffa
    96bc:	.word	0x2001d003
    96c0:	.word	0x1fff1364

000096c4 <endpoint0_transmit>:
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
}


static void endpoint0_transmit(const void *data, uint32_t len)
{
    96c4:	push	{r4, r5, r6, r7, lr}
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    96c6:	ldr	r4, [pc, #48]	; (96f8 <endpoint0_transmit+0x34>)
    96c8:	ldr	r6, [pc, #48]	; (96fc <endpoint0_transmit+0x38>)
    96ca:	ldrb	r3, [r4, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    96cc:	ldr	r5, [pc, #48]	; (9700 <endpoint0_transmit+0x3c>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    96ce:	orr.w	r7, r3, #2
    96d2:	add.w	r2, r6, r7, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    96d6:	eor.w	r3, r3, #1
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    96da:	str	r0, [r2, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    96dc:	ldrb	r2, [r5, #0]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    96de:	strb	r3, [r4, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    96e0:	cmp	r2, #0
    96e2:	ite	ne
    96e4:	movne	r0, #200	; 0xc8
    96e6:	moveq	r0, #136	; 0x88
	ep0_tx_data_toggle ^= 1;
    96e8:	eor.w	r2, r2, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    96ec:	orr.w	r1, r0, r1, lsl #16
	ep0_tx_data_toggle ^= 1;
    96f0:	strb	r2, [r5, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    96f2:	str.w	r1, [r6, r7, lsl #3]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    96f6:	pop	{r4, r5, r6, r7, pc}
    96f8:	.word	0x2001cf8c
    96fc:	.word	0x1fff0000
    9700:	.word	0x2001d004

00009704 <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    9704:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    9706:	cmp	r3, #3




usb_packet_t *usb_rx(uint32_t endpoint)
{
    9708:	push	{r4, lr}
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    970a:	bhi.n	972e <usb_rx+0x2a>
	__disable_irq();
    970c:	cpsid	i
	ret = rx_first[endpoint];
    970e:	ldr	r2, [pc, #36]	; (9734 <usb_rx+0x30>)
    9710:	ldr.w	r0, [r2, r3, lsl #2]
	if (ret) {
    9714:	cbz	r0, 972a <usb_rx+0x26>
		rx_first[endpoint] = ret->next;
    9716:	ldr	r1, [r0, #4]
    9718:	str.w	r1, [r2, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    971c:	ldr	r1, [pc, #24]	; (9738 <usb_rx+0x34>)
    971e:	ldrh	r4, [r0, #0]
    9720:	ldrh.w	r2, [r1, r3, lsl #1]
    9724:	subs	r2, r2, r4
    9726:	strh.w	r2, [r1, r3, lsl #1]
	}
	__enable_irq();
    972a:	cpsie	i
	//serial_print("rx, epidx=");
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
    972c:	pop	{r4, pc}

usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    972e:	movs	r0, #0
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    9730:	pop	{r4, pc}
    9732:	nop
    9734:	.word	0x2001cf7c
    9738:	.word	0x2001d078

0000973c <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    973c:	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    973e:	cmp	r0, #3
    9740:	bhi.n	9758 <usb_tx_packet_count+0x1c>
	__disable_irq();
    9742:	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    9744:	ldr	r3, [pc, #20]	; (975c <usb_tx_packet_count+0x20>)
    9746:	ldr.w	r3, [r3, r0, lsl #2]
// https://forum.pjrc.com/threads/58663?p=223513&viewfull=1#post223513
//
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;
    974a:	movs	r0, #0

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    974c:	cbz	r3, 9754 <usb_tx_packet_count+0x18>
    974e:	adds	r0, #1
    9750:	ldr	r3, [r3, #4]
    9752:	b.n	974c <usb_tx_packet_count+0x10>
	__enable_irq();
    9754:	cpsie	i
	return count;
    9756:	bx	lr
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
    9758:	movs	r0, #0
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
	__enable_irq();
	return count;
}
    975a:	bx	lr
    975c:	.word	0x2001cfd0

00009760 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    9760:	push	{r4, r5, r6}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    9762:	cpsid	i
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    9764:	ldr	r5, [pc, #92]	; (97c4 <usb_rx_memory+0x64>)
			if (table[index(i, RX, EVEN)].desc == 0) {
    9766:	ldr	r4, [pc, #96]	; (97c8 <usb_rx_memory+0x68>)
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    9768:	movs	r3, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    976a:	adds	r2, r3, r5
    976c:	ldrb.w	r2, [r2, #-1]
    9770:	lsls	r2, r2, #28
    9772:	bpl.n	97b0 <usb_rx_memory+0x50>
			if (table[index(i, RX, EVEN)].desc == 0) {
    9774:	lsls	r2, r3, #2
    9776:	ldr	r1, [pc, #80]	; (97c8 <usb_rx_memory+0x68>)
    9778:	ldr.w	r6, [r4, r2, lsl #3]
    977c:	cbnz	r6, 978a <usb_rx_memory+0x2a>
				table[index(i, RX, EVEN)].addr = packet->buf;
    977e:	add.w	r3, r1, r3, lsl #5
    9782:	adds	r0, #8
    9784:	str	r0, [r3, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    9786:	ldr	r3, [pc, #68]	; (97cc <usb_rx_memory+0x6c>)
    9788:	b.n	979e <usb_rx_memory+0x3e>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    978a:	orr.w	r2, r2, #1
    978e:	ldr.w	r6, [r4, r2, lsl #3]
    9792:	cbnz	r6, 97b0 <usb_rx_memory+0x50>
				table[index(i, RX, ODD)].addr = packet->buf;
    9794:	add.w	r3, r1, r2, lsl #3
    9798:	adds	r0, #8
    979a:	str	r0, [r3, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    979c:	ldr	r3, [pc, #48]	; (97d0 <usb_rx_memory+0x70>)
    979e:	str.w	r3, [r1, r2, lsl #3]
				usb_rx_memory_needed--;
    97a2:	ldr	r2, [pc, #48]	; (97d4 <usb_rx_memory+0x74>)
    97a4:	ldrb	r3, [r2, #0]
    97a6:	subs	r3, #1
    97a8:	strb	r3, [r2, #0]
				__enable_irq();
    97aa:	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
    97ac:	pop	{r4, r5, r6}
    97ae:	bx	lr
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    97b0:	adds	r3, #1
    97b2:	cmp	r3, #5
    97b4:	bne.n	976a <usb_rx_memory+0xa>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    97b6:	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    97b8:	ldr	r3, [pc, #24]	; (97d4 <usb_rx_memory+0x74>)
    97ba:	movs	r2, #0
    97bc:	strb	r2, [r3, #0]
	usb_free(packet);
	return;
}
    97be:	pop	{r4, r5, r6}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
    97c0:	b.w	9680 <usb_free>
    97c4:	.word	0x00013076
    97c8:	.word	0x1fff0000
    97cc:	.word	0x00400088
    97d0:	.word	0x004000c8
    97d4:	.word	0x2001cffa

000097d8 <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    97d8:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    97da:	cmp	r3, #3

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    97dc:	push	{r4, lr}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
    97de:	bhi.n	9846 <usb_tx+0x6e>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    97e0:	ldr	r2, [pc, #100]	; (9848 <usb_tx+0x70>)
    97e2:	lsls	r0, r0, #5
    97e4:	orr.w	r0, r0, #16
    97e8:	add	r0, r2
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    97ea:	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    97ec:	ldr	r2, [pc, #92]	; (984c <usb_tx+0x74>)
    97ee:	ldrb	r4, [r2, r3]
    97f0:	cmp	r4, #3
    97f2:	bhi.n	980c <usb_tx+0x34>
    97f4:	tbb	[pc, r4]
    97f8:	.word	0x07020418
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
		next = TX_STATE_EVEN_FREE;
		break;
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    97fc:	movs	r4, #5
    97fe:	b.n	982a <usb_tx+0x52>
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    9800:	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    9802:	movs	r4, #2
		break;
    9804:	b.n	982a <usb_tx+0x52>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    9806:	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    9808:	movs	r4, #4
		break;
    980a:	b.n	982a <usb_tx+0x52>
	  default:
		if (tx_first[endpoint] == NULL) {
    980c:	ldr	r0, [pc, #64]	; (9850 <usb_tx+0x78>)
    980e:	ldr	r2, [pc, #68]	; (9854 <usb_tx+0x7c>)
    9810:	ldr.w	r4, [r0, r3, lsl #2]
    9814:	cbnz	r4, 981c <usb_tx+0x44>
			tx_first[endpoint] = packet;
    9816:	str.w	r1, [r0, r3, lsl #2]
    981a:	b.n	9822 <usb_tx+0x4a>
		} else {
			tx_last[endpoint]->next = packet;
    981c:	ldr.w	r0, [r2, r3, lsl #2]
    9820:	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    9822:	str.w	r1, [r2, r3, lsl #2]
    9826:	b.n	9844 <usb_tx+0x6c>
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    9828:	movs	r4, #3
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    982a:	strb	r4, [r2, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    982c:	tst.w	r0, #8
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    9830:	add.w	r3, r1, #8
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9834:	ldrh	r2, [r1, #0]
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    9836:	str	r3, [r0, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9838:	ite	ne
    983a:	movne	r3, #200	; 0xc8
    983c:	moveq	r3, #136	; 0x88
    983e:	orr.w	r3, r3, r2, lsl #16
    9842:	str	r3, [r0, #0]
	__enable_irq();
    9844:	cpsie	i
    9846:	pop	{r4, pc}
    9848:	.word	0x1fff0000
    984c:	.word	0x2001cf38
    9850:	.word	0x2001cfd0
    9854:	.word	0x2001cfe0

00009858 <usb_isr>:
}



void usb_isr(void)
{
    9858:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    985c:	ldr.w	r8, [pc, #680]	; 9b08 <usb_isr+0x2b0>
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    9860:	ldr	r3, [pc, #676]	; (9b08 <usb_isr+0x2b0>)
    9862:	ldrb	r4, [r3, #0]
    9864:	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    9866:	tst.w	r4, #4
    986a:	mov	r5, r3
    986c:	beq.n	98a4 <usb_isr+0x4c>
		if (usb_configuration) {
    986e:	ldr	r3, [pc, #668]	; (9b0c <usb_isr+0x2b4>)
    9870:	ldrb	r3, [r3, #0]
    9872:	cbz	r3, 989e <usb_isr+0x46>
			t = usb_reboot_timer;
    9874:	ldr	r2, [pc, #664]	; (9b10 <usb_isr+0x2b8>)
    9876:	ldrb	r1, [r2, #0]
			if (t) {
    9878:	and.w	r3, r1, #255	; 0xff
    987c:	cbz	r1, 9888 <usb_isr+0x30>
				usb_reboot_timer = --t;
    987e:	subs	r3, #1
    9880:	uxtb	r3, r3
    9882:	strb	r3, [r2, #0]
				if (!t) _reboot_Teensyduino_();
    9884:	cbnz	r3, 9888 <usb_isr+0x30>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    9886:	bkpt	0x0000
			if (t) {
				usb_reboot_timer = --t;
				if (!t) _reboot_Teensyduino_();
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    9888:	ldr	r2, [pc, #648]	; (9b14 <usb_isr+0x2bc>)
    988a:	ldrb	r1, [r2, #0]
			if (t) {
    988c:	and.w	r3, r1, #255	; 0xff
    9890:	cbz	r1, 989e <usb_isr+0x46>
				usb_cdc_transmit_flush_timer = --t;
    9892:	subs	r3, #1
    9894:	uxtb	r3, r3
    9896:	strb	r3, [r2, #0]
				if (t == 0) usb_serial_flush_callback();
    9898:	cbnz	r3, 989e <usb_isr+0x46>
    989a:	bl	9328 <usb_serial_flush_callback>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    989e:	movs	r3, #4
    98a0:	strb.w	r3, [r8]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    98a4:	and.w	r3, r4, #8
    98a8:	and.w	r2, r3, #255	; 0xff
    98ac:	cmp	r3, #0
    98ae:	beq.w	9d98 <usb_isr+0x540>
		uint8_t endpoint;
		stat = USB0_STAT;
    98b2:	ldr	r3, [pc, #612]	; (9b18 <usb_isr+0x2c0>)
    98b4:	ldr	r4, [pc, #612]	; (9b1c <usb_isr+0x2c4>)
    98b6:	ldrb	r3, [r3, #0]
    98b8:	uxtb	r3, r3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    98ba:	lsrs	r7, r3, #4
    98bc:	mov.w	r6, r3, lsr #2
    98c0:	bne.w	9ca0 <usb_isr+0x448>
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
    98c4:	ldr.w	r3, [r4, r6, lsl #3]
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    98c8:	add.w	r2, r4, r6, lsl #3
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    98cc:	ubfx	r3, r3, #2, #4
    98d0:	subs	r3, #1
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    98d2:	ldr	r2, [r2, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    98d4:	cmp	r3, #12
    98d6:	bhi.w	9c98 <usb_isr+0x440>
    98da:	tbh	[pc, r3, lsl #1]
    98de:	.short	0x019e
    98e0:	.word	0x01dd019e
    98e4:	.word	0x01dd01dd
    98e8:	.word	0x01dd01dd
    98ec:	.word	0x01bb01dd
    98f0:	.word	0x01dd01dd
    98f4:	.word	0x000d01dd
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    98f8:	ldr	r5, [pc, #548]	; (9b20 <usb_isr+0x2c8>)
		setup.word2 = *(uint32_t *)(buf + 4);
    98fa:	ldr	r3, [r2, #4]
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    98fc:	ldr	r1, [r2, #0]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    98fe:	ldr	r0, [pc, #548]	; (9b24 <usb_isr+0x2cc>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    9900:	str	r3, [r5, #4]

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    9902:	ldr	r3, [pc, #548]	; (9b28 <usb_isr+0x2d0>)
    9904:	str.w	r3, [r4, r6, lsl #3]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    9908:	movs	r3, #1
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    990a:	str	r1, [r5, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    990c:	ldr.w	sl, [pc, #584]	; 9b58 <usb_isr+0x300>
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    9910:	strb	r3, [r0, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    9912:	uxth	r1, r1
    9914:	movw	r0, #1665	; 0x681
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    9918:	movs	r2, #0
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    991a:	cmp	r1, r0
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    991c:	str	r2, [r4, #16]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    991e:	str.w	r2, [sl]
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
    9922:	str	r2, [r4, #24]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    9924:	bhi.n	9956 <usb_isr+0xfe>
    9926:	cmp.w	r1, #1664	; 0x680
    992a:	bcs.w	9b7e <usb_isr+0x326>
    992e:	cmp.w	r1, #258	; 0x102
    9932:	beq.w	9ae8 <usb_isr+0x290>
    9936:	bhi.n	9946 <usb_isr+0xee>
    9938:	cmp	r1, #128	; 0x80
    993a:	beq.w	9ac2 <usb_isr+0x26a>
    993e:	cmp	r1, #130	; 0x82
    9940:	beq.w	9aca <usb_isr+0x272>
    9944:	b.n	9bb8 <usb_isr+0x360>
    9946:	movw	r3, #770	; 0x302
    994a:	cmp	r1, r3
    994c:	beq.w	9b60 <usb_isr+0x308>
    9950:	cmp.w	r1, #1280	; 0x500
    9954:	b.n	998e <usb_isr+0x136>
    9956:	movw	r0, #8225	; 0x2021
    995a:	cmp	r1, r0
    995c:	beq.w	9c14 <usb_isr+0x3bc>
    9960:	bhi.n	997e <usb_isr+0x126>
    9962:	cmp.w	r1, #2176	; 0x880
    9966:	beq.w	9ab8 <usb_isr+0x260>
    996a:	cmp.w	r1, #2304	; 0x900
    996e:	bne.w	9bb8 <usb_isr+0x360>
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    9972:	ldr	r3, [pc, #408]	; (9b0c <usb_isr+0x2b4>)
    9974:	ldrb	r2, [r5, #2]
    9976:	strb	r2, [r3, #0]
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    9978:	movs	r6, #4
			if (table[i].desc & BDT_OWN) {
    997a:	ldr	r7, [pc, #416]	; (9b1c <usb_isr+0x2c4>)
    997c:	b.n	9994 <usb_isr+0x13c>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    997e:	movw	r3, #8737	; 0x2221
    9982:	cmp	r1, r3
    9984:	beq.w	9ba4 <usb_isr+0x34c>
    9988:	movw	r3, #8993	; 0x2321
    998c:	cmp	r1, r3
    998e:	beq.w	9bc0 <usb_isr+0x368>
    9992:	b.n	9bb8 <usb_isr+0x360>
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    9994:	ldr.w	r3, [r4, r6, lsl #3]
    9998:	lsls	r3, r3, #24
    999a:	bpl.n	99a8 <usb_isr+0x150>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    999c:	add.w	r3, r7, r6, lsl #3
    99a0:	ldr	r0, [r3, #4]
    99a2:	subs	r0, #8
    99a4:	bl	9680 <usb_free>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    99a8:	adds	r6, #1
    99aa:	cmp	r6, #20
    99ac:	bne.n	9994 <usb_isr+0x13c>
    99ae:	ldr	r7, [pc, #380]	; (9b2c <usb_isr+0x2d4>)
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    99b0:	ldr.w	fp, [pc, #380]	; 9b30 <usb_isr+0x2d8>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    99b4:	movs	r6, #0
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    99b6:	ldr.w	r0, [fp, r6, lsl #2]
    99ba:	mov.w	r9, r6, lsl #2
			while (p) {
    99be:	cbz	r0, 99ce <usb_isr+0x176>
				n = p->next;
    99c0:	ldr	r2, [r0, #4]
    99c2:	str	r2, [sp, #0]
				usb_free(p);
    99c4:	bl	9680 <usb_free>
				p = n;
    99c8:	ldr	r2, [sp, #0]
    99ca:	mov	r0, r2
    99cc:	b.n	99be <usb_isr+0x166>
			}
			rx_first[i] = NULL;
    99ce:	ldr	r3, [pc, #352]	; (9b30 <usb_isr+0x2d8>)
			rx_last[i] = NULL;
			p = tx_first[i];
    99d0:	ldr	r2, [pc, #352]	; (9b34 <usb_isr+0x2dc>)
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
    99d2:	str.w	r0, [r3, r9]
			rx_last[i] = NULL;
    99d6:	ldr	r3, [pc, #352]	; (9b38 <usb_isr+0x2e0>)
    99d8:	str.w	r0, [r9, r3]
			p = tx_first[i];
    99dc:	ldr.w	r0, [r9, r2]
			while (p) {
    99e0:	cbz	r0, 99f4 <usb_isr+0x19c>
				n = p->next;
    99e2:	ldr	r1, [r0, #4]
    99e4:	str	r2, [sp, #4]
    99e6:	str	r1, [sp, #0]
				usb_free(p);
    99e8:	bl	9680 <usb_free>
				p = n;
    99ec:	ldr	r1, [sp, #0]
    99ee:	ldr	r2, [sp, #4]
    99f0:	mov	r0, r1
    99f2:	b.n	99e0 <usb_isr+0x188>
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    99f4:	ldr	r3, [pc, #324]	; (9b3c <usb_isr+0x2e4>)
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    99f6:	str.w	r0, [r2, r9]
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    99fa:	strh.w	r0, [r3, r6, lsl #1]
			switch (tx_state[i]) {
    99fe:	ldrb	r3, [r7, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    9a00:	ldr	r2, [pc, #316]	; (9b40 <usb_isr+0x2e8>)
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    9a02:	subs	r3, #2
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    9a04:	str.w	r0, [r9, r2]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    9a08:	cmp	r3, #3
    9a0a:	bhi.n	9a1c <usb_isr+0x1c4>
    9a0c:	tbb	[pc, r3]
    9a10:	.word	0x04020402
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    9a14:	movs	r3, #0
    9a16:	b.n	9a1a <usb_isr+0x1c2>
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    9a18:	movs	r3, #1
    9a1a:	strb	r3, [r7, #0]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    9a1c:	adds	r6, #1
    9a1e:	cmp	r6, #4
    9a20:	add.w	r7, r7, #1
    9a24:	bne.n	99b6 <usb_isr+0x15e>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    9a26:	ldr	r1, [pc, #284]	; (9b44 <usb_isr+0x2ec>)
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
    9a28:	ldr.w	r9, [pc, #304]	; 9b5c <usb_isr+0x304>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    9a2c:	movs	r3, #0
    9a2e:	strb	r3, [r1, #0]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    9a30:	mov.w	fp, #1
    9a34:	mov	r7, r1
    9a36:	ldr	r3, [pc, #272]	; (9b48 <usb_isr+0x2f0>)
			epconf = *cfg++;
    9a38:	add.w	r0, fp, r9
    9a3c:	add	r3, fp
    9a3e:	ldrb.w	r0, [r0, #-1]
    9a42:	lsls	r3, r3, #2
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    9a44:	tst.w	r0, #8
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
			*reg = epconf;
    9a48:	strb	r0, [r3, #0]
    9a4a:	mov.w	r6, fp, lsl #2
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    9a4e:	beq.n	9a98 <usb_isr+0x240>
				usb_packet_t *p;
				p = usb_malloc();
    9a50:	bl	9644 <usb_malloc>
				if (p) {
    9a54:	cbz	r0, 9a68 <usb_isr+0x210>
					table[index(i, RX, EVEN)].addr = p->buf;
    9a56:	add.w	lr, r4, fp, lsl #5
    9a5a:	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    9a5c:	ldr	r3, [pc, #236]	; (9b4c <usb_isr+0x2f4>)
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
    9a5e:	str.w	r0, [lr, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    9a62:	str.w	r3, [r4, r6, lsl #3]
    9a66:	b.n	9a72 <usb_isr+0x21a>
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    9a68:	str.w	r0, [r4, r6, lsl #3]
					usb_rx_memory_needed++;
    9a6c:	ldrb	r0, [r7, #0]
    9a6e:	adds	r0, #1
    9a70:	strb	r0, [r7, #0]
				}
				p = usb_malloc();
    9a72:	bl	9644 <usb_malloc>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    9a76:	orr.w	lr, r6, #1
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
    9a7a:	cbz	r0, 9a8e <usb_isr+0x236>
					table[index(i, RX, ODD)].addr = p->buf;
    9a7c:	add.w	ip, r4, lr, lsl #3
    9a80:	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    9a82:	ldr	r3, [pc, #164]	; (9b28 <usb_isr+0x2d0>)
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    9a84:	str.w	r0, [ip, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    9a88:	str.w	r3, [r4, lr, lsl #3]
    9a8c:	b.n	9a98 <usb_isr+0x240>
				} else {
					table[index(i, RX, ODD)].desc = 0;
    9a8e:	str.w	r0, [r4, lr, lsl #3]
					usb_rx_memory_needed++;
    9a92:	ldrb	r0, [r7, #0]
    9a94:	adds	r0, #1
    9a96:	strb	r0, [r7, #0]
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    9a98:	orr.w	lr, r6, #2
			table[index(i, TX, ODD)].desc = 0;
    9a9c:	orr.w	r3, r6, #3
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    9aa0:	add.w	fp, fp, #1
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    9aa4:	movs	r0, #0
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    9aa6:	cmp.w	fp, #5
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    9aaa:	str.w	r0, [r4, lr, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
    9aae:	str.w	r0, [r4, r3, lsl #3]
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    9ab2:	bne.n	9a36 <usb_isr+0x1de>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    9ab4:	mov	r3, r0
    9ab6:	b.n	9bca <usb_isr+0x372>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    9ab8:	ldr	r2, [pc, #80]	; (9b0c <usb_isr+0x2b4>)
    9aba:	ldr	r6, [pc, #148]	; (9b50 <usb_isr+0x2f8>)
    9abc:	ldrb	r2, [r2, #0]
    9abe:	strb	r2, [r6, #0]
    9ac0:	b.n	9bcc <usb_isr+0x374>
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    9ac2:	ldr	r6, [pc, #140]	; (9b50 <usb_isr+0x2f8>)
    9ac4:	strb	r2, [r6, #0]
		reply_buffer[1] = 0;
    9ac6:	strb	r2, [r6, #1]
    9ac8:	b.n	9bc4 <usb_isr+0x36c>
    9aca:	ldrh	r1, [r5, #4]
    9acc:	and.w	r1, r1, #127	; 0x7f
		datalen = 2;
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    9ad0:	cmp	r1, #4
    9ad2:	bhi.n	9bb8 <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    9ad4:	ldr	r6, [pc, #120]	; (9b50 <usb_isr+0x2f8>)
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    9ad6:	lsls	r1, r1, #2
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    9ad8:	strb	r2, [r6, #0]
		reply_buffer[1] = 0;
    9ada:	strb	r2, [r6, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    9adc:	ldr	r2, [pc, #116]	; (9b54 <usb_isr+0x2fc>)
    9ade:	ldrb	r2, [r2, r1]
    9ae0:	lsls	r4, r2, #30
    9ae2:	bpl.n	9bc4 <usb_isr+0x36c>
    9ae4:	strb	r3, [r6, #0]
    9ae6:	b.n	9bc4 <usb_isr+0x36c>
    9ae8:	ldrh	r2, [r5, #4]
    9aea:	and.w	r2, r2, #127	; 0x7f
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    9aee:	cmp	r2, #4
    9af0:	bhi.n	9bb8 <usb_isr+0x360>
    9af2:	ldrh	r3, [r5, #2]
    9af4:	cmp	r3, #0
    9af6:	bne.n	9bb8 <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    9af8:	ldr	r1, [pc, #88]	; (9b54 <usb_isr+0x2fc>)
    9afa:	lsls	r2, r2, #2
    9afc:	add	r1, r2
    9afe:	ldrb	r2, [r1, #0]
    9b00:	bic.w	r2, r2, #2
    9b04:	b.n	9b7a <usb_isr+0x322>
    9b06:	nop
    9b08:	.word	0x40072080
    9b0c:	.word	0x2001d003
    9b10:	.word	0x2001cf8d
    9b14:	.word	0x2001cf0c
    9b18:	.word	0x40072090
    9b1c:	.word	0x1fff0000
    9b20:	.word	0x2001cff0
    9b24:	.word	0x2001d004
    9b28:	.word	0x004000c8
    9b2c:	.word	0x2001cf38
    9b30:	.word	0x2001cf7c
    9b34:	.word	0x2001cfd0
    9b38:	.word	0x2001cf28
    9b3c:	.word	0x2001d078
    9b40:	.word	0x2001cfe0
    9b44:	.word	0x2001cffa
    9b48:	.word	0x1001c830
    9b4c:	.word	0x00400088
    9b50:	.word	0x2001cffb
    9b54:	.word	0x400720c0
    9b58:	.word	0x2001cf24
    9b5c:	.word	0x00013076
    9b60:	ldrh	r2, [r5, #4]
    9b62:	and.w	r2, r2, #127	; 0x7f
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    9b66:	cmp	r2, #4
    9b68:	bhi.n	9bb8 <usb_isr+0x360>
    9b6a:	ldrh	r3, [r5, #2]
    9b6c:	cbnz	r3, 9bb8 <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    9b6e:	ldr	r1, [pc, #620]	; (9ddc <usb_isr+0x584>)
    9b70:	lsls	r2, r2, #2
    9b72:	add	r1, r2
    9b74:	ldrb	r2, [r1, #0]
    9b76:	orr.w	r2, r2, #2
    9b7a:	strb	r2, [r1, #0]
    9b7c:	b.n	9bca <usb_isr+0x372>
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    9b7e:	ldrh	r2, [r5, #2]
    9b80:	ldrh	r1, [r5, #4]
    9b82:	ldr	r3, [pc, #604]	; (9de0 <usb_isr+0x588>)
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    9b84:	ldr	r6, [r3, #4]
    9b86:	cbz	r6, 9bb8 <usb_isr+0x360>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    9b88:	ldrh	r0, [r3, #0]
    9b8a:	cmp	r0, r2
    9b8c:	bne.n	9ba0 <usb_isr+0x348>
    9b8e:	ldrh	r0, [r3, #2]
    9b90:	cmp	r0, r1
    9b92:	bne.n	9ba0 <usb_isr+0x348>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    9b94:	lsrs	r2, r2, #8
    9b96:	cmp	r2, #3
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    9b98:	ite	eq
    9b9a:	ldrbeq	r3, [r6, #0]
				} else {
					datalen = list->length;
    9b9c:	ldrhne	r3, [r3, #8]
    9b9e:	b.n	9bcc <usb_isr+0x374>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    9ba0:	adds	r3, #12
    9ba2:	b.n	9b84 <usb_isr+0x32c>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    9ba4:	ldrh	r3, [r5, #4]
    9ba6:	cbnz	r3, 9bc8 <usb_isr+0x370>
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    9ba8:	ldr	r2, [pc, #568]	; (9de4 <usb_isr+0x58c>)
    9baa:	ldr	r1, [r2, #0]
    9bac:	ldr	r2, [pc, #568]	; (9de8 <usb_isr+0x590>)
    9bae:	str	r1, [r2, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    9bb0:	ldr	r2, [pc, #568]	; (9dec <usb_isr+0x594>)
    9bb2:	ldrb	r1, [r5, #2]
    9bb4:	strb	r1, [r2, #0]
    9bb6:	b.n	9bca <usb_isr+0x372>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9bb8:	ldr	r3, [pc, #544]	; (9ddc <usb_isr+0x584>)
    9bba:	movs	r2, #15
    9bbc:	strb	r2, [r3, #0]
    9bbe:	b.n	9c14 <usb_isr+0x3bc>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    9bc0:	movs	r3, #0
    9bc2:	b.n	9bca <usb_isr+0x372>
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    9bc4:	movs	r3, #2
    9bc6:	b.n	9bcc <usb_isr+0x374>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    9bc8:	mov	r3, r2

static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
    9bca:	mov	r6, r3
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    9bcc:	ldrh	r4, [r5, #6]
    9bce:	cmp	r4, r3
    9bd0:	it	cs
    9bd2:	movcs	r4, r3
    9bd4:	cmp	r4, #64	; 0x40
    9bd6:	mov	r5, r4
    9bd8:	it	cs
    9bda:	movcs	r5, #64	; 0x40
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
    9bdc:	mov	r0, r6
    9bde:	mov	r1, r5
    9be0:	bl	96c4 <endpoint0_transmit>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9be4:	subs	r4, r4, r5

	if (datalen > setup.wLength) datalen = setup.wLength;
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    9be6:	add	r6, r5
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9be8:	bne.n	9bf2 <usb_isr+0x39a>
    9bea:	cmp	r5, #64	; 0x40
    9bec:	bne.n	9c14 <usb_isr+0x3bc>
    9bee:	mov	r5, r4
    9bf0:	b.n	9bfa <usb_isr+0x3a2>
    9bf2:	cmp	r4, #64	; 0x40
    9bf4:	mov	r5, r4
    9bf6:	it	cs
    9bf8:	movcs	r5, #64	; 0x40

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
    9bfa:	mov	r0, r6
    9bfc:	mov	r1, r5
    9bfe:	bl	96c4 <endpoint0_transmit>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9c02:	subs	r4, r4, r5
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    9c04:	add	r6, r5
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9c06:	bne.n	9c0c <usb_isr+0x3b4>
    9c08:	cmp	r5, #64	; 0x40
    9c0a:	bne.n	9c14 <usb_isr+0x3bc>

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    9c0c:	ldr	r3, [pc, #480]	; (9df0 <usb_isr+0x598>)
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    9c0e:	str.w	r6, [sl]
	ep0_tx_len = datalen;
    9c12:	strh	r4, [r3, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    9c14:	movs	r2, #1
    9c16:	ldr	r3, [pc, #476]	; (9df4 <usb_isr+0x59c>)
    9c18:	b.n	9c96 <usb_isr+0x43e>
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    9c1a:	ldr	r3, [pc, #476]	; (9df8 <usb_isr+0x5a0>)
    9c1c:	ldrh	r0, [r3, #0]
    9c1e:	movw	r1, #8225	; 0x2021
    9c22:	cmp	r0, r1
    9c24:	bne.n	9c4c <usb_isr+0x3f4>
			int i;
			uint32_t *line_coding = NULL;
			switch (setup.wIndex) {
    9c26:	ldrh	r3, [r3, #4]
    9c28:	cbnz	r3, 9c44 <usb_isr+0x3ec>
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
					//serial_phex(*buf);
					*dst++ = *buf++;
    9c2a:	ldr	r1, [pc, #464]	; (9dfc <usb_isr+0x5a4>)
    9c2c:	ldrb	r0, [r2, r3]
    9c2e:	strb	r0, [r3, r1]
#endif
			}
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
    9c30:	adds	r3, #1
    9c32:	cmp	r3, #7
    9c34:	bne.n	9c2c <usb_isr+0x3d4>
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    9c36:	ldr	r3, [pc, #452]	; (9dfc <usb_isr+0x5a4>)
    9c38:	ldr	r3, [r3, #0]
    9c3a:	cmp	r3, #134	; 0x86
    9c3c:	ittt	eq
    9c3e:	ldreq	r3, [pc, #448]	; (9e00 <usb_isr+0x5a8>)
    9c40:	moveq	r2, #15
    9c42:	strbeq	r2, [r3, #0]
			}
			endpoint0_transmit(NULL, 0);
    9c44:	movs	r1, #0
    9c46:	mov	r0, r1
    9c48:	bl	96c4 <endpoint0_transmit>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    9c4c:	ldr	r3, [pc, #436]	; (9e04 <usb_isr+0x5ac>)
    9c4e:	str.w	r3, [r4, r6, lsl #3]
    9c52:	b.n	9c98 <usb_isr+0x440>
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    9c54:	ldr	r7, [pc, #432]	; (9e08 <usb_isr+0x5b0>)
    9c56:	ldr	r6, [r7, #0]
		if (data) {
    9c58:	cbz	r6, 9c84 <usb_isr+0x42c>
			size = ep0_tx_len;
    9c5a:	ldr.w	sl, [pc, #404]	; 9df0 <usb_isr+0x598>
    9c5e:	ldrh.w	r4, [sl]
    9c62:	cmp	r4, #64	; 0x40
    9c64:	mov	r5, r4
    9c66:	it	cs
    9c68:	movcs	r5, #64	; 0x40
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
    9c6a:	mov	r0, r6
    9c6c:	mov	r1, r5
    9c6e:	bl	96c4 <endpoint0_transmit>
			data += size;
			ep0_tx_len -= size;
    9c72:	subs	r0, r4, r5
    9c74:	uxth	r0, r0
    9c76:	strh.w	r0, [sl]
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    9c7a:	cbnz	r0, 9c80 <usb_isr+0x428>
    9c7c:	cmp	r5, #64	; 0x40
    9c7e:	bne.n	9c82 <usb_isr+0x42a>
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    9c80:	adds	r0, r6, r5
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    9c82:	str	r0, [r7, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    9c84:	ldr	r3, [pc, #368]	; (9df8 <usb_isr+0x5a0>)
    9c86:	ldrh	r2, [r3, #0]
    9c88:	cmp.w	r2, #1280	; 0x500
    9c8c:	bne.n	9c98 <usb_isr+0x440>
			setup.bRequest = 0;
    9c8e:	movs	r2, #0
    9c90:	strb	r2, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    9c92:	ldrb	r2, [r3, #2]
    9c94:	ldr	r3, [pc, #372]	; (9e0c <usb_isr+0x5b4>)
    9c96:	strb	r2, [r3, #0]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    9c98:	ldr	r3, [pc, #344]	; (9df4 <usb_isr+0x59c>)
    9c9a:	movs	r2, #1
    9c9c:	strb	r2, [r3, #0]
    9c9e:	b.n	9d90 <usb_isr+0x538>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    9ca0:	add.w	r5, r4, r6, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    9ca4:	subs	r7, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    9ca6:	ldr	r2, [r5, #4]
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    9ca8:	and.w	r3, r3, #8
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    9cac:	sub.w	r0, r2, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    9cb0:	uxtb	r7, r7
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    9cb2:	and.w	lr, r3, #255	; 0xff
    9cb6:	cmp	r3, #0
    9cb8:	beq.n	9d28 <usb_isr+0x4d0>
				usb_free(packet);
    9cba:	bl	9680 <usb_free>
				packet = tx_first[endpoint];
    9cbe:	ldr	r0, [pc, #336]	; (9e10 <usb_isr+0x5b8>)
    9cc0:	ldr	r3, [pc, #336]	; (9e14 <usb_isr+0x5bc>)
    9cc2:	ldr.w	r1, [r0, r7, lsl #2]
				if (packet) {
    9cc6:	cbz	r1, 9d04 <usb_isr+0x4ac>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    9cc8:	ldr	r2, [r1, #4]
    9cca:	str.w	r2, [r0, r7, lsl #2]
					b->addr = packet->buf;
    9cce:	add.w	r2, r1, #8
    9cd2:	str	r2, [r5, #4]
					switch (tx_state[endpoint]) {
    9cd4:	ldrb	r2, [r3, r7]
    9cd6:	cmp	r2, #3
    9cd8:	bhi.n	9cf2 <usb_isr+0x49a>
    9cda:	tbb	[pc, r2]
    9cde:	.short	0x0402
    9ce0:	.short	0x0806
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    9ce2:	movs	r2, #3
    9ce4:	b.n	9cf0 <usb_isr+0x498>
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    9ce6:	movs	r2, #2
    9ce8:	b.n	9cf0 <usb_isr+0x498>
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    9cea:	movs	r2, #5
    9cec:	b.n	9cf0 <usb_isr+0x498>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    9cee:	movs	r2, #4
    9cf0:	strb	r2, [r3, r7]
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    9cf2:	tst.w	r5, #8
    9cf6:	ldrh	r2, [r1, #0]
    9cf8:	ite	ne
    9cfa:	movne	r3, #200	; 0xc8
    9cfc:	moveq	r3, #136	; 0x88
    9cfe:	orr.w	r3, r3, r2, lsl #16
    9d02:	b.n	9d8c <usb_isr+0x534>
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    9d04:	ldrb	r2, [r3, r7]
    9d06:	cmp	r2, #3
    9d08:	bhi.n	9d1a <usb_isr+0x4c2>
    9d0a:	tbb	[pc, r2]
    9d0e:	.short	0x4141
    9d10:	.short	0x0402
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    9d12:	movs	r2, #0
    9d14:	b.n	9d24 <usb_isr+0x4cc>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    9d16:	movs	r2, #1
    9d18:	b.n	9d24 <usb_isr+0x4cc>
						break;
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    9d1a:	tst.w	r5, #8
    9d1e:	ite	ne
    9d20:	movne	r2, #3
    9d22:	moveq	r2, #2
    9d24:	strb	r2, [r3, r7]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    9d26:	b.n	9d90 <usb_isr+0x538>
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    9d28:	ldr.w	r3, [r4, r6, lsl #3]
    9d2c:	lsrs	r3, r3, #16
    9d2e:	uxth	r1, r3
    9d30:	strh.w	r1, [r2, #-8]
				if (packet->len > 0) {
    9d34:	cbz	r3, 9d80 <usb_isr+0x528>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    9d36:	ldr	r3, [pc, #224]	; (9e18 <usb_isr+0x5c0>)
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    9d38:	strh.w	lr, [r2, #-6]
					packet->next = NULL;
    9d3c:	str.w	lr, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    9d40:	ldr.w	r2, [r3, r7, lsl #2]
    9d44:	ldr.w	lr, [pc, #252]	; 9e44 <usb_isr+0x5ec>
    9d48:	cbnz	r2, 9d50 <usb_isr+0x4f8>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    9d4a:	str.w	r0, [r3, r7, lsl #2]
    9d4e:	b.n	9d56 <usb_isr+0x4fe>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    9d50:	ldr.w	r3, [lr, r7, lsl #2]
    9d54:	str	r0, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    9d56:	ldr	r2, [pc, #196]	; (9e1c <usb_isr+0x5c4>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
					}
					rx_last[endpoint] = packet;
    9d58:	str.w	r0, [lr, r7, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    9d5c:	ldrh.w	r3, [r2, r7, lsl #1]
    9d60:	add	r3, r1
    9d62:	strh.w	r3, [r2, r7, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    9d66:	bl	9644 <usb_malloc>
					if (packet) {
    9d6a:	cbz	r0, 9d72 <usb_isr+0x51a>
						b->addr = packet->buf;
    9d6c:	adds	r0, #8
    9d6e:	str	r0, [r5, #4]
    9d70:	b.n	9d80 <usb_isr+0x528>
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    9d72:	ldr	r2, [pc, #172]	; (9e20 <usb_isr+0x5c8>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    9d74:	str.w	r0, [r4, r6, lsl #3]
						usb_rx_memory_needed++;
    9d78:	ldrb	r3, [r2, #0]
    9d7a:	adds	r3, #1
    9d7c:	strb	r3, [r2, #0]
    9d7e:	b.n	9d90 <usb_isr+0x538>
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9d80:	ldr	r2, [pc, #160]	; (9e24 <usb_isr+0x5cc>)
    9d82:	ldr	r3, [pc, #128]	; (9e04 <usb_isr+0x5ac>)
    9d84:	tst.w	r5, #8
    9d88:	it	eq
    9d8a:	moveq	r3, r2
    9d8c:	str.w	r3, [r4, r6, lsl #3]
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    9d90:	movs	r3, #8
    9d92:	strb.w	r3, [r8]
		goto restart;
    9d96:	b.n	9860 <usb_isr+0x8>
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    9d98:	lsls	r0, r4, #31
    9d9a:	bpl.n	9e48 <usb_isr+0x5f0>
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    9d9c:	ldr	r1, [pc, #84]	; (9df4 <usb_isr+0x59c>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    9d9e:	ldr	r0, [pc, #132]	; (9e24 <usb_isr+0x5cc>)
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    9da0:	ldr	r4, [pc, #132]	; (9e28 <usb_isr+0x5d0>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    9da2:	movs	r3, #2
    9da4:	strb	r3, [r1, #0]
		ep0_tx_bdt_bank = 0;
    9da6:	ldr	r3, [pc, #132]	; (9e2c <usb_isr+0x5d4>)
    9da8:	strb	r2, [r3, #0]

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    9daa:	ldr	r3, [pc, #132]	; (9e30 <usb_isr+0x5d8>)
    9dac:	str	r0, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    9dae:	str	r4, [r3, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    9db0:	str	r0, [r3, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    9db2:	ldr	r0, [pc, #128]	; (9e34 <usb_isr+0x5dc>)
    9db4:	str	r0, [r3, #12]
		table[index(0, TX, EVEN)].desc = 0;
    9db6:	str	r2, [r3, #16]
		table[index(0, TX, ODD)].desc = 0;
    9db8:	str	r2, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9dba:	ldr	r3, [pc, #32]	; (9ddc <usb_isr+0x584>)
    9dbc:	movs	r0, #13
    9dbe:	strb	r0, [r3, #0]

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    9dc0:	ldr	r0, [pc, #116]	; (9e38 <usb_isr+0x5e0>)
    9dc2:	movs	r3, #255	; 0xff
    9dc4:	strb	r3, [r0, #0]
		USB0_ISTAT = 0xFF;
    9dc6:	strb	r3, [r5, #0]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    9dc8:	strb	r2, [r0, #16]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    9dca:	ldr	r2, [pc, #112]	; (9e3c <usb_isr+0x5e4>)
    9dcc:	strb	r3, [r2, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    9dce:	ldr	r3, [pc, #112]	; (9e40 <usb_isr+0x5e8>)
    9dd0:	movs	r2, #159	; 0x9f
    9dd2:	strb	r2, [r3, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    9dd4:	movs	r3, #1
    9dd6:	strb	r3, [r1, #0]
		return;
    9dd8:	b.n	9e6e <usb_isr+0x616>
    9dda:	nop
    9ddc:	.word	0x400720c0
    9de0:	.word	0x0001307c
    9de4:	.word	0x2001cf20
    9de8:	.word	0x2001d074
    9dec:	.word	0x2001cf1c
    9df0:	.word	0x2001cff8
    9df4:	.word	0x40072094
    9df8:	.word	0x2001cff0
    9dfc:	.word	0x2001d06c
    9e00:	.word	0x2001cf8d
    9e04:	.word	0x004000c8
    9e08:	.word	0x2001cf24
    9e0c:	.word	0x40072098
    9e10:	.word	0x2001cfd0
    9e14:	.word	0x2001cf38
    9e18:	.word	0x2001cf7c
    9e1c:	.word	0x2001d078
    9e20:	.word	0x2001cffa
    9e24:	.word	0x00400088
    9e28:	.word	0x2001cf3c
    9e2c:	.word	0x2001cf8c
    9e30:	.word	0x1fff0000
    9e34:	.word	0x2001cf90
    9e38:	.word	0x40072088
    9e3c:	.word	0x4007208c
    9e40:	.word	0x40072084
    9e44:	.word	0x2001cf28
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    9e48:	lsls	r1, r4, #24
    9e4a:	bpl.n	9e56 <usb_isr+0x5fe>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9e4c:	ldr	r3, [pc, #36]	; (9e74 <usb_isr+0x61c>)
    9e4e:	movs	r2, #13
    9e50:	strb	r2, [r3, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    9e52:	movs	r3, #128	; 0x80
    9e54:	strb	r3, [r5, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    9e56:	lsls	r2, r4, #30
    9e58:	bpl.n	9e66 <usb_isr+0x60e>
		uint8_t err = USB0_ERRSTAT;
    9e5a:	ldr	r2, [pc, #28]	; (9e78 <usb_isr+0x620>)
    9e5c:	ldrb	r3, [r2, #0]
    9e5e:	uxtb	r3, r3
		USB0_ERRSTAT = err;
    9e60:	strb	r3, [r2, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    9e62:	movs	r3, #2
    9e64:	strb	r3, [r5, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    9e66:	lsls	r3, r4, #27
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    9e68:	itt	mi
    9e6a:	movmi	r3, #16
    9e6c:	strbmi	r3, [r5, #0]
	}

}
    9e6e:	add	sp, #12
    9e70:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9e74:	.word	0x400720c0
    9e78:	.word	0x40072088

00009e7c <usb_init>:



void usb_init(void)
{
    9e7c:	push	{r4, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    9e7e:	bl	a430 <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    9e82:	movs	r3, #0
		table[i].desc = 0;
    9e84:	ldr	r0, [pc, #108]	; (9ef4 <usb_init+0x78>)
    9e86:	mov	r1, r3
    9e88:	str.w	r1, [r0, r3, lsl #3]
		table[i].addr = 0;
    9e8c:	add.w	r4, r0, r3, lsl #3
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    9e90:	adds	r3, #1
    9e92:	cmp	r3, #20
		table[i].desc = 0;
    9e94:	ldr	r2, [pc, #92]	; (9ef4 <usb_init+0x78>)
		table[i].addr = 0;
    9e96:	str	r1, [r4, #4]
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    9e98:	bne.n	9e88 <usb_init+0xc>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    9e9a:	ldr	r1, [pc, #92]	; (9ef8 <usb_init+0x7c>)
    9e9c:	ldr	r3, [r1, #0]
    9e9e:	orr.w	r3, r3, #262144	; 0x40000
    9ea2:	str	r3, [r1, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    9ea4:	ldr	r1, [pc, #84]	; (9efc <usb_init+0x80>)
    9ea6:	ldr	r3, [r1, #0]
    9ea8:	orr.w	r3, r3, #50331648	; 0x3000000
    9eac:	str	r3, [r1, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    9eae:	ldr	r3, [pc, #80]	; (9f00 <usb_init+0x84>)
    9eb0:	ubfx	r1, r2, #8, #8
    9eb4:	strb	r1, [r3, #0]
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    9eb6:	ubfx	r1, r2, #16, #8
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    9eba:	lsrs	r2, r2, #24
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    9ebc:	strb	r1, [r3, #20]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    9ebe:	strb	r2, [r3, #24]

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    9ec0:	ldr	r2, [pc, #64]	; (9f04 <usb_init+0x88>)
    9ec2:	movs	r3, #255	; 0xff
    9ec4:	strb	r3, [r2, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    9ec6:	movs	r1, #0
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    9ec8:	strb	r3, [r2, #8]
	USB0_OTGISTAT = 0xFF;
    9eca:	strb.w	r3, [r2, #-112]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    9ece:	movs	r3, #1
    9ed0:	strb	r3, [r2, #20]
	USB0_USBCTRL = 0;
    9ed2:	strb.w	r1, [r2, #128]	; 0x80

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    9ed6:	strb	r3, [r2, #4]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    9ed8:	ldr	r3, [pc, #44]	; (9f08 <usb_init+0x8c>)
    9eda:	movs	r2, #112	; 0x70
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    9edc:	mvn.w	r1, #816	; 0x330

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    9ee0:	strb	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    9ee2:	add	r3, r1
    9ee4:	mov.w	r2, #2097152	; 0x200000
    9ee8:	str	r2, [r3, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    9eea:	ldr	r3, [pc, #32]	; (9f0c <usb_init+0x90>)
    9eec:	movs	r2, #16
    9eee:	strb	r2, [r3, #0]
    9ef0:	pop	{r4, pc}
    9ef2:	nop
    9ef4:	.word	0x1fff0000
    9ef8:	.word	0x40048034
    9efc:	.word	0x4000d800
    9f00:	.word	0x4007209c
    9f04:	.word	0x40072080
    9f08:	.word	0xe000e435
    9f0c:	.word	0x40072108

00009f10 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    9f10:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    9f14:	ldr	r4, [pc, #176]	; (9fc8 <yield+0xb8>)
    9f16:	ldrb	r3, [r4, #0]
    9f18:	cmp	r3, #0
    9f1a:	beq.n	9fc2 <yield+0xb2>
	if (running) return; // TODO: does this need to be atomic?
    9f1c:	ldr	r5, [pc, #172]	; (9fcc <yield+0xbc>)
    9f1e:	ldrb	r2, [r5, #0]
    9f20:	cmp	r2, #0
    9f22:	bne.n	9fc2 <yield+0xb2>
	running = 1;
    9f24:	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    9f26:	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    9f28:	strb	r2, [r5, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    9f2a:	bpl.n	9f44 <yield+0x34>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    9f2c:	bl	9140 <usb_serial_available>
		if (Serial.available()) serialEvent();
    9f30:	cbz	r0, 9f36 <yield+0x26>
    9f32:	bl	a36e <serialEvent()>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    9f36:	ldr	r3, [pc, #152]	; (9fd0 <yield+0xc0>)
    9f38:	ldrb	r3, [r3, #0]
    9f3a:	cbz	r3, 9f44 <yield+0x34>
    9f3c:	ldrb	r3, [r4, #0]
    9f3e:	bic.w	r3, r3, #1
    9f42:	strb	r3, [r4, #0]
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    9f44:	ldrb	r3, [r4, #0]
    9f46:	lsls	r2, r3, #30
    9f48:	bpl.n	9f74 <yield+0x64>
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    9f4a:	ldr.w	r8, [pc, #148]	; 9fe0 <yield+0xd0>
			s_serials_with_serial_events[i]->doYieldCode();
    9f4e:	ldr.w	r9, [pc, #148]	; 9fe4 <yield+0xd4>
    9f52:	movs	r6, #0
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    9f54:	ldrb.w	r2, [r8]
    9f58:	uxtb	r3, r6
    9f5a:	cmp	r2, r3
    9f5c:	bls.n	9f74 <yield+0x64>
			s_serials_with_serial_events[i]->doYieldCode();
    9f5e:	ldr.w	r7, [r9, r3, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*_serialEvent)();
    9f62:	ldr	r3, [r7, #0]
    9f64:	mov	r0, r7
    9f66:	ldr	r3, [r3, #16]
    9f68:	blx	r3
    9f6a:	cbz	r0, 9f70 <yield+0x60>
    9f6c:	ldr	r3, [r7, #16]
    9f6e:	blx	r3
    9f70:	adds	r6, #1
    9f72:	b.n	9f54 <yield+0x44>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    9f74:	movs	r3, #0
    9f76:	strb	r3, [r5, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    9f78:	ldrb	r3, [r4, #0]
    9f7a:	lsls	r3, r3, #29
    9f7c:	bpl.n	9fc2 <yield+0xb2>
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
    9f7e:	ldr	r1, [pc, #84]	; (9fd4 <yield+0xc4>)
    9f80:	ldr	r3, [r1, #0]
    9f82:	cbz	r3, 9fc2 <yield+0xb2>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    9f84:	mrs	r3, IPSR
		if (ipsr != 0) return;
    9f88:	cbnz	r3, 9fc2 <yield+0xb2>
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    9f8a:	mrs	r2, PRIMASK
		__disable_irq();
    9f8e:	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    9f90:	ldr	r0, [r1, #0]
		if (first == nullptr) {
    9f92:	cbz	r0, 9f9a <yield+0x8a>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    9f94:	ldr	r4, [pc, #64]	; (9fd8 <yield+0xc8>)
    9f96:	ldrb	r5, [r4, #0]
    9f98:	cbz	r5, 9fa2 <yield+0x92>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    9f9a:	cbnz	r2, 9fc2 <yield+0xb2>
    9f9c:	cpsie	i
    9f9e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    9fa2:	movs	r3, #1
    9fa4:	strb	r3, [r4, #0]
		firstYield = first->_next;
    9fa6:	ldr	r3, [r0, #20]
    9fa8:	str	r3, [r1, #0]
		if (firstYield) {
    9faa:	cbz	r3, 9fb0 <yield+0xa0>
			firstYield->_prev = nullptr;
    9fac:	str	r5, [r3, #24]
    9fae:	b.n	9fb4 <yield+0xa4>
		} else {
			lastYield = nullptr;
    9fb0:	ldr	r1, [pc, #40]	; (9fdc <yield+0xcc>)
    9fb2:	str	r3, [r1, #0]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    9fb4:	cbnz	r2, 9fb8 <yield+0xa8>
    9fb6:	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    9fb8:	movs	r5, #0
    9fba:	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    9fbc:	ldr	r3, [r0, #8]
    9fbe:	blx	r3
		runningFromYield = false;
    9fc0:	strb	r5, [r4, #0]
    9fc2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    9fc6:	nop
    9fc8:	.word	0x1fff1368
    9fcc:	.word	0x2001d005
    9fd0:	.word	0x1fff137c
    9fd4:	.word	0x2001d014
    9fd8:	.word	0x2001d018
    9fdc:	.word	0x2001d010
    9fe0:	.word	0x2001d034
    9fe4:	.word	0x2001d01c

00009fe8 <DMAChannel::begin(bool)>:
/**                     Teensy 3.0 & 3.1                       **/
/****************************************************************/
#if defined(KINETISK)

void DMAChannel::begin(bool force_initialization)
{
    9fe8:	push	{r4, r5, lr}
	uint32_t ch = 0;

	__disable_irq();
    9fea:	cpsid	i
    9fec:	ldr	r4, [pc, #148]	; (a084 <DMAChannel::begin(bool)+0x9c>)
	if (!force_initialization && TCD && channel < DMA_MAX_CHANNELS
    9fee:	cbnz	r1, a014 <DMAChannel::begin(bool)+0x2c>
    9ff0:	ldr	r1, [r0, #0]
    9ff2:	cbz	r1, a014 <DMAChannel::begin(bool)+0x2c>
    9ff4:	ldrb	r3, [r0, #4]
    9ff6:	cmp	r3, #15
    9ff8:	bhi.n	a014 <DMAChannel::begin(bool)+0x2c>
	  && (dma_channel_allocated_mask & (1 << channel))
    9ffa:	ldrh	r2, [r4, #0]
    9ffc:	asrs	r2, r3
    9ffe:	lsls	r2, r2, #31
    a000:	bpl.n	a014 <DMAChannel::begin(bool)+0x2c>
	  && (uint32_t)TCD == (uint32_t)(0x40009000 + channel * 32)) {
    a002:	add.w	r3, r3, #33554432	; 0x2000000
    a006:	add.w	r3, r3, #1152	; 0x480
    a00a:	cmp.w	r1, r3, lsl #5
    a00e:	bne.n	a014 <DMAChannel::begin(bool)+0x2c>
		// DMA channel already allocated
		__enable_irq();
    a010:	cpsie	i
		return;
    a012:	pop	{r4, r5, pc}
	}
	while (1) {
		if (!(dma_channel_allocated_mask & (1 << ch))) {
    a014:	ldrh	r1, [r4, #0]
    a016:	movs	r3, #0
    a018:	asr.w	r2, r1, r3
    a01c:	ands.w	r2, r2, #1
    a020:	bne.n	a074 <DMAChannel::begin(bool)+0x8c>
			dma_channel_allocated_mask |= (1 << ch);
    a022:	movs	r5, #1
    a024:	lsls	r5, r3
    a026:	orrs	r1, r5
    a028:	strh	r1, [r4, #0]
			__enable_irq();
    a02a:	cpsie	i
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    a02c:	ldr	r5, [pc, #88]	; (a088 <DMAChannel::begin(bool)+0xa0>)
			channel = DMA_MAX_CHANNELS;
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
    a02e:	uxtb	r1, r3
    a030:	strb	r1, [r0, #4]
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    a032:	ldr	r4, [r5, #0]
    a034:	orr.w	r4, r4, #2
    a038:	str	r4, [r5, #0]
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    a03a:	ldr.w	r4, [r5, #-4]
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    a03e:	add.w	r3, r3, #33554432	; 0x2000000
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    a042:	orr.w	r4, r4, #2
    a046:	str.w	r4, [r5, #-4]
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    a04a:	add.w	r3, r3, #1152	; 0x480
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
    a04e:	ldr	r4, [pc, #60]	; (a08c <DMAChannel::begin(bool)+0xa4>)
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    a050:	lsls	r3, r3, #5
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
    a052:	movw	r5, #1154	; 0x482
    a056:	str	r5, [r4, #0]
#endif
	DMA_CERQ = ch;
    a058:	strb	r1, [r4, #26]
	DMA_CERR = ch;
    a05a:	strb	r1, [r4, #30]
	DMA_CEEI = ch;
    a05c:	strb	r1, [r4, #24]
	DMA_CINT = ch;
    a05e:	strb	r1, [r4, #31]
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    a060:	str	r3, [r0, #0]
	uint32_t *p = (uint32_t *)TCD;
	*p++ = 0;
    a062:	str	r2, [r3, #0]
	*p++ = 0;
    a064:	str	r2, [r3, #4]
	*p++ = 0;
    a066:	str	r2, [r3, #8]
	*p++ = 0;
    a068:	str	r2, [r3, #12]
	*p++ = 0;
    a06a:	str	r2, [r3, #16]
	*p++ = 0;
    a06c:	str	r2, [r3, #20]
	*p++ = 0;
    a06e:	str	r2, [r3, #24]
	*p++ = 0;
    a070:	str	r2, [r3, #28]
    a072:	pop	{r4, r5, pc}
		if (!(dma_channel_allocated_mask & (1 << ch))) {
			dma_channel_allocated_mask |= (1 << ch);
			__enable_irq();
			break;
		}
		if (++ch >= DMA_MAX_CHANNELS) {
    a074:	adds	r3, #1
    a076:	cmp	r3, #16
    a078:	bne.n	a018 <DMAChannel::begin(bool)+0x30>
			__enable_irq();
    a07a:	cpsie	i
			TCD = (TCD_t *)0;
    a07c:	movs	r2, #0
    a07e:	str	r2, [r0, #0]
			channel = DMA_MAX_CHANNELS;
    a080:	strb	r3, [r0, #4]
    a082:	pop	{r4, r5, pc}
    a084:	.word	0x2001d006
    a088:	.word	0x40048040
    a08c:	.word	0x40008000

0000a090 <DMAChannel::release()>:
	*p++ = 0;
}

void DMAChannel::release(void)
{
	if (channel >= DMA_MAX_CHANNELS) return;
    a090:	ldrb	r3, [r0, #4]
    a092:	cmp	r3, #15
    a094:	bhi.n	a0b8 <DMAChannel::release()+0x28>
	DMA_CERQ = channel;
    a096:	ldr	r2, [pc, #36]	; (a0bc <DMAChannel::release()+0x2c>)
    a098:	strb	r3, [r2, #0]
	__disable_irq();
    a09a:	cpsid	i
	dma_channel_allocated_mask &= ~(1 << channel);
    a09c:	ldr	r1, [pc, #32]	; (a0c0 <DMAChannel::release()+0x30>)
    a09e:	ldrb	r2, [r0, #4]
    a0a0:	movs	r3, #1
    a0a2:	lsl.w	r2, r3, r2
    a0a6:	ldrh	r3, [r1, #0]
    a0a8:	bic.w	r3, r3, r2
    a0ac:	strh	r3, [r1, #0]
	__enable_irq();
    a0ae:	cpsie	i
	channel = DMA_MAX_CHANNELS;
    a0b0:	movs	r3, #16
    a0b2:	strb	r3, [r0, #4]
	TCD = (TCD_t *)0;
    a0b4:	movs	r3, #0
    a0b6:	str	r3, [r0, #0]
    a0b8:	bx	lr
    a0ba:	nop
    a0bc:	.word	0x4000801a
    a0c0:	.word	0x2001d006

0000a0c4 <MillisTimer::disableTimerInterrupt()>:
	volatile TimerStateType _state = TimerOff;
	static MillisTimer *listWaiting; // single linked list of waiting to start timers
	static MillisTimer *listActive;  // double linked list of running timers
	static bool disableTimerInterrupt() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    a0c4:	mrs	r0, PRIMASK
		__disable_irq();
    a0c8:	cpsid	i
		return (primask == 0) ? true : false;
	}
    a0ca:	clz	r0, r0
    a0ce:	lsrs	r0, r0, #5
    a0d0:	bx	lr

0000a0d2 <MillisTimer::enableTimerInterrupt(bool)>:
	static void enableTimerInterrupt(bool doit) {
		if (doit) __enable_irq();
    a0d2:	cbz	r0, a0d6 <MillisTimer::enableTimerInterrupt(bool)+0x4>
    a0d4:	cpsie	i
    a0d6:	bx	lr

0000a0d8 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    a0d8:	push	{r3, r4, r5, r6, r7, lr}
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    a0da:	ldr	r6, [pc, #48]	; (a10c <EventResponder::runFromInterrupt()+0x34>)
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    a0dc:	ldr	r7, [pc, #48]	; (a110 <EventResponder::runFromInterrupt()+0x38>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    a0de:	movs	r5, #0
}

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
    a0e0:	bl	a0c4 <MillisTimer::disableTimerInterrupt()>
		EventResponder *first = firstInterrupt;
    a0e4:	ldr	r4, [r6, #0]
}

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
    a0e6:	mov	r2, r0
		EventResponder *first = firstInterrupt;
		if (first) {
    a0e8:	cbz	r4, a106 <EventResponder::runFromInterrupt()+0x2e>
			firstInterrupt = first->_next;
    a0ea:	ldr	r3, [r4, #20]
    a0ec:	str	r3, [r6, #0]
			if (firstInterrupt) {
    a0ee:	cbz	r3, a0f4 <EventResponder::runFromInterrupt()+0x1c>
				firstInterrupt->_prev = nullptr;
    a0f0:	str	r5, [r3, #24]
    a0f2:	b.n	a0f6 <EventResponder::runFromInterrupt()+0x1e>
			} else {
				lastInterrupt = nullptr;
    a0f4:	str	r3, [r7, #0]
			}
			enableInterrupts(irq);
    a0f6:	mov	r0, r2
    a0f8:	bl	a0d2 <MillisTimer::enableTimerInterrupt(bool)>
			first->_triggered = false;
    a0fc:	strb	r5, [r4, #29]
			(*(first->_function))(*first);
    a0fe:	ldr	r3, [r4, #8]
    a100:	mov	r0, r4
    a102:	blx	r3
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
	while (1) {
    a104:	b.n	a0e0 <EventResponder::runFromInterrupt()+0x8>
			}
			enableInterrupts(irq);
			first->_triggered = false;
			(*(first->_function))(*first);
		} else {
			enableInterrupts(irq);
    a106:	bl	a0d2 <MillisTimer::enableTimerInterrupt(bool)>
    a10a:	pop	{r3, r4, r5, r6, r7, pc}
    a10c:	.word	0x2001d008
    a110:	.word	0x2001d00c

0000a114 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    a114:	b.w	a0d8 <EventResponder::runFromInterrupt()>

0000a118 <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
    a118:	ldr	r2, [pc, #8]	; (a124 <systick_isr+0xc>)
    a11a:	ldr	r3, [r2, #0]
    a11c:	adds	r3, #1
    a11e:	str	r3, [r2, #0]
    a120:	bx	lr
    a122:	nop
    a124:	.word	0x2001cf20

0000a128 <usb_serial_class::clear()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    a128:	b.w	915c <usb_serial_flush_input>

0000a12c <usb_serial_class::peek()>:
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    a12c:	b.w	9108 <usb_serial_peekchar>

0000a130 <usb_serial_class::read()>:
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    a130:	b.w	90bc <usb_serial_getchar>

0000a134 <usb_serial_class::available()>:
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    a134:	b.w	9140 <usb_serial_available>

0000a138 <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    a138:	b.w	92cc <usb_serial_flush_output>

0000a13c <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    a13c:	b.w	9284 <usb_serial_write_buffer_free>

0000a140 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    a140:	mov	r0, r1
    a142:	mov	r1, r2
    a144:	b.w	918c <usb_serial_write>

0000a148 <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    a148:	mov	r0, r1
    a14a:	b.w	926c <usb_serial_putchar>

0000a14e <Print::write(unsigned char const*, unsigned int)>:

#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
    a14e:	push	{r3, r4, r5, r6, r7, lr}
    a150:	mov	r7, r0
	if (buffer == nullptr) return 0;
    a152:	mov	r5, r1
    a154:	cbz	r1, a16e <Print::write(unsigned char const*, unsigned int)+0x20>
    a156:	adds	r6, r1, r2
    a158:	movs	r4, #0
	size_t count = 0;
	while (size--) count += write(*buffer++);
    a15a:	cmp	r5, r6
    a15c:	beq.n	a172 <Print::write(unsigned char const*, unsigned int)+0x24>
    a15e:	ldr	r3, [r7, #0]
    a160:	ldrb.w	r1, [r5], #1
    a164:	ldr	r3, [r3, #0]
    a166:	mov	r0, r7
    a168:	blx	r3
    a16a:	add	r4, r0
    a16c:	b.n	a15a <Print::write(unsigned char const*, unsigned int)+0xc>
#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
	if (buffer == nullptr) return 0;
    a16e:	mov	r0, r1
    a170:	pop	{r3, r4, r5, r6, r7, pc}
    a172:	mov	r0, r4
	size_t count = 0;
	while (size--) count += write(*buffer++);
	return count;
}
    a174:	pop	{r3, r4, r5, r6, r7, pc}
    a176:	Address 0x0000a176 is out of bounds.


0000a178 <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    a178:	push	{r0, r1, r2, lr}
	uint8_t buf[2]={'\r', '\n'};
    a17a:	ldr	r3, [pc, #24]	; (a194 <Print::println()+0x1c>)
    a17c:	ldrh	r3, [r3, #0]
    a17e:	strh.w	r3, [sp, #4]
	return write(buf, 2);
    a182:	ldr	r3, [r0, #0]
    a184:	movs	r2, #2
    a186:	ldr	r3, [r3, #4]
    a188:	add	r1, sp, #4
    a18a:	blx	r3
}
    a18c:	add	sp, #12
    a18e:	ldr.w	pc, [sp], #4
    a192:	nop
    a194:	.word	0x00013074

0000a198 <Print::printf(char const*, ...)>:
	return len;
}
}

int Print::printf(const char *format, ...)
{
    a198:	push	{r1, r2, r3}
    a19a:	push	{r0, r1, lr}
    a19c:	add	r2, sp, #12
    a19e:	ldr.w	r1, [r2], #4
	va_list ap;
	va_start(ap, format);
    a1a2:	str	r2, [sp, #4]
#ifdef __STRICT_ANSI__
	va_end(ap);
	return 0;  // TODO: make this work with -std=c++0x
#else
	int retval = vdprintf((int)this, format, ap);
    a1a4:	bl	f708 <vdprintf>
	va_end(ap);
	return retval;
#endif
}
    a1a8:	add	sp, #8
    a1aa:	ldr.w	lr, [sp], #4
    a1ae:	add	sp, #12
    a1b0:	bx	lr

0000a1b2 <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
}

#else

size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
{
    a1b2:	push	{r4, r5, r6, lr}
    a1b4:	mov	r5, r0
    a1b6:	sub	sp, #40	; 0x28
	uint8_t digit, i;

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
    a1b8:	cbnz	r2, a1c4 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x12>
		return write((uint8_t)n);
    a1ba:	ldr	r3, [r0, #0]
    a1bc:	uxtb	r1, r1
    a1be:	ldr	r3, [r3, #0]
    a1c0:	blx	r3
    a1c2:	b.n	a224 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x72>
	} else if (base == 1) {
		base = 10;
    a1c4:	cmp	r2, #1
    a1c6:	it	eq
    a1c8:	moveq	r2, #10
	}


	if (n == 0) {
    a1ca:	cbz	r1, a1d0 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x1e>
    a1cc:	movs	r0, #33	; 0x21
    a1ce:	b.n	a1da <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x28>
		buf[sizeof(buf) - 1] = '0';
    a1d0:	movs	r2, #48	; 0x30
    a1d2:	strb.w	r2, [sp, #37]	; 0x25
		i = sizeof(buf) - 1;
    a1d6:	movs	r0, #33	; 0x21
    a1d8:	b.n	a204 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x52>
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    a1da:	udiv	r6, r1, r2
    a1de:	mls	r1, r2, r6, r1
    a1e2:	uxtb	r4, r1
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a1e4:	cmp	r1, #9
    a1e6:	ite	ls
    a1e8:	addls.w	r1, r4, #48	; 0x30
    a1ec:	addhi.w	r1, r4, #55	; 0x37
    a1f0:	add	r4, sp, #40	; 0x28
    a1f2:	add	r4, r0
    a1f4:	uxtb	r1, r1
    a1f6:	strb.w	r1, [r4, #-36]
			n /= base;
			if (n == 0) break;
    a1fa:	mov	r1, r6
    a1fc:	cbz	r6, a204 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x52>
			i--;
    a1fe:	subs	r0, #1
    a200:	uxtb	r0, r0
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
    a202:	b.n	a1da <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x28>
			n /= base;
			if (n == 0) break;
			i--;
		}
	}
	if (sign) {
    a204:	cbz	r3, a214 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x62>
		i--;
    a206:	subs	r0, #1
    a208:	uxtb	r0, r0
		buf[i] = '-';
    a20a:	add	r3, sp, #40	; 0x28
    a20c:	add	r3, r0
    a20e:	movs	r2, #45	; 0x2d
    a210:	strb.w	r2, [r3, #-36]
	}
	return write(buf + i, sizeof(buf) - i);
    a214:	ldr	r3, [r5, #0]
    a216:	add	r1, sp, #4
    a218:	rsb	r2, r0, #34	; 0x22
    a21c:	add	r1, r0
    a21e:	ldr	r3, [r3, #4]
    a220:	mov	r0, r5
    a222:	blx	r3
}
    a224:	add	sp, #40	; 0x28
    a226:	pop	{r4, r5, r6, pc}

0000a228 <Print::print(long)>:

size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
    a228:	cmp	r1, #0
		sign = '-';
		n = -n;
    a22a:	itte	lt
    a22c:	neglt	r1, r1
size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
		sign = '-';
    a22e:	movlt	r3, #45	; 0x2d
}


size_t Print::print(long n)
{
	uint8_t sign=0;
    a230:	movge	r3, #0

	if (n < 0) {
		sign = '-';
		n = -n;
	}
	return printNumber(n, 10, sign);
    a232:	movs	r2, #10
    a234:	b.w	a1b2 <Print::printNumber(unsigned long, unsigned char, unsigned char)>

0000a238 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>:
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
    a238:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a23c:	sub	sp, #72	; 0x48
    a23e:	mov	r5, r0
    a240:	ldrb.w	r8, [sp, #104]	; 0x68
    a244:	ldrb.w	sl, [sp, #108]	; 0x6c
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    a248:	cmp.w	r8, #1
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
    a24c:	mov	r6, r2
    a24e:	mov	r7, r3
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    a250:	bls.n	a2d6 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x9e>
	if (n == 0) {
    a252:	orrs.w	r3, r6, r7
    a256:	beq.n	a264 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x2c>
    a258:	movs	r4, #65	; 0x41
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    a25a:	uxtb.w	r8, r8
    a25e:	mov.w	r9, #0
    a262:	b.n	a26e <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x36>
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    a264:	movs	r3, #48	; 0x30
    a266:	strb.w	r3, [sp, #69]	; 0x45
		i = sizeof(buf) - 1;
    a26a:	movs	r4, #65	; 0x41
    a26c:	b.n	a2b0 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x78>
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    a26e:	mov	r0, r6
    a270:	mov	r1, r7
    a272:	mov	r2, r8
    a274:	mov	r3, r9
    a276:	bl	af04 <__aeabi_uldivmod>
    a27a:	mov	r1, r3
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a27c:	cmp	r1, #0
    a27e:	it	eq
    a280:	cmpeq	r2, #10
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    a282:	uxtb	r3, r2
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a284:	add	r2, sp, #72	; 0x48
    a286:	ite	cc
    a288:	addcc	r3, #48	; 0x30
    a28a:	addcs	r3, #55	; 0x37
    a28c:	add	r2, r4
    a28e:	uxtb	r3, r3
    a290:	strb.w	r3, [r2, #-68]
			n /= base;
    a294:	mov	r0, r6
    a296:	mov	r3, r9
    a298:	mov	r1, r7
    a29a:	mov	r2, r8
    a29c:	bl	af04 <__aeabi_uldivmod>
    a2a0:	mov	r6, r0
    a2a2:	mov	r7, r1
			if (n == 0) break;
    a2a4:	orrs.w	r3, r6, r7
    a2a8:	beq.n	a2b0 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x78>
			i--;
    a2aa:	subs	r4, #1
    a2ac:	uxtb	r4, r4
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
    a2ae:	b.n	a26e <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x36>
			n /= base;
			if (n == 0) break;
			i--;
		}
	}
	if (sign) {
    a2b0:	cmp.w	sl, #0
    a2b4:	beq.n	a2c4 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x8c>
		i--;
    a2b6:	subs	r4, #1
    a2b8:	uxtb	r4, r4
		buf[i] = '-';
    a2ba:	add	r3, sp, #72	; 0x48
    a2bc:	add	r3, r4
    a2be:	movs	r2, #45	; 0x2d
    a2c0:	strb.w	r2, [r3, #-68]
	}
	return write(buf + i, sizeof(buf) - i);
    a2c4:	ldr	r3, [r5, #0]
    a2c6:	add	r1, sp, #4
    a2c8:	ldr	r3, [r3, #4]
    a2ca:	rsb	r2, r4, #66	; 0x42
    a2ce:	add	r1, r4
    a2d0:	mov	r0, r5
    a2d2:	blx	r3
    a2d4:	b.n	a2d8 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0xa0>
size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    a2d6:	movs	r0, #0
	if (sign) {
		i--;
		buf[i] = '-';
	}
	return write(buf + i, sizeof(buf) - i);
}
    a2d8:	add	sp, #72	; 0x48
    a2da:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000a2de <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    a2de:	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    a2e0:	bl	7c8 <setup>
	while (1) {
		loop();
    a2e4:	bl	84c <loop>
		yield();
    a2e8:	bl	9f10 <yield>
    a2ec:	b.n	a2e4 <main+0x6>
    a2ee:	Address 0x0000a2ee is out of bounds.


0000a2f0 <Stream::timedRead()>:
#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field

// private method to read stream with timeout
int Stream::timedRead()
{
    a2f0:	push	{r0, r1, r4, r5, r6, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    a2f2:	ldr	r3, [pc, #48]	; (a324 <Stream::timedRead()+0x34>)
    a2f4:	ldr	r2, [r3, #0]
    a2f6:	str	r2, [sp, #0]
	return ret;
    a2f8:	ldr	r6, [sp, #0]
    a2fa:	mov	r4, r0
    a2fc:	mov	r5, r3
  int c;
  unsigned long startMillis = millis();
  do {
    c = read();
    a2fe:	ldr	r3, [r4, #0]
    a300:	mov	r0, r4
    a302:	ldr	r3, [r3, #20]
    a304:	blx	r3
    if (c >= 0) return c;
    a306:	cmp	r0, #0
    a308:	bge.n	a320 <Stream::timedRead()+0x30>
    yield();
    a30a:	bl	9f10 <yield>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    a30e:	ldr	r3, [r5, #0]
    a310:	str	r3, [sp, #4]
	return ret;
    a312:	ldr	r3, [sp, #4]
// private method to read stream with timeout
int Stream::timedRead()
{
  int c;
  unsigned long startMillis = millis();
  do {
    a314:	ldr	r2, [r4, #8]
    a316:	subs	r3, r3, r6
    a318:	cmp	r3, r2
    a31a:	bcc.n	a2fe <Stream::timedRead()+0xe>
    c = read();
    if (c >= 0) return c;
    yield();
  } while(millis() - startMillis < _timeout);
  return -1;     // -1 indicates timeout
    a31c:	mov.w	r0, #4294967295
}
    a320:	add	sp, #8
    a322:	pop	{r4, r5, r6, pc}
    a324:	.word	0x2001cf20

0000a328 <Stream::readBytesUntil(char, char*, unsigned int)>:
// as readBytes with terminator character
// terminates if length characters have been read, timeout, or if the terminator character  detected
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
    a328:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    a32c:	mov	r7, r0
    a32e:	mov	r9, r1
	if (buffer == nullptr) return 0;
    a330:	mov	r5, r2
    a332:	cbz	r2, a362 <Stream::readBytesUntil(char, char*, unsigned int)+0x3a>
	if (length < 1) return 0;
    a334:	cbz	r3, a366 <Stream::readBytesUntil(char, char*, unsigned int)+0x3e>
	length--;
    a336:	add.w	r8, r3, #4294967295
    a33a:	mov	r6, r2
    a33c:	subs	r4, r6, r5
	size_t index = 0;
	while (index < length) {
    a33e:	cmp	r8, r4
    a340:	bls.n	a35c <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
		int c = timedRead();
    a342:	mov	r0, r7
    a344:	bl	a2f0 <Stream::timedRead()>
		if (c == terminator) break;
    a348:	cmp	r0, r9
    a34a:	beq.n	a35c <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
		if (c < 0) {
    a34c:	cmp	r0, #0
    a34e:	bge.n	a356 <Stream::readBytesUntil(char, char*, unsigned int)+0x2e>
	String readString(size_t max = 120);
	String readStringUntil(char terminator, size_t max = 120);
	int getReadError() { return read_error; }
	void clearReadError() { setReadError(0); }
  protected:
	void setReadError(int err = 1) { read_error = err; }
    a350:	movs	r3, #1
    a352:	strb	r3, [r7, #12]
    a354:	b.n	a35c <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
			setReadError();
			break;
		}
		*buffer++ = (char)c;
    a356:	strb.w	r0, [r6], #1
{
	if (buffer == nullptr) return 0;
	if (length < 1) return 0;
	length--;
	size_t index = 0;
	while (index < length) {
    a35a:	b.n	a33c <Stream::readBytesUntil(char, char*, unsigned int)+0x14>
			break;
		}
		*buffer++ = (char)c;
		index++;
	}
	*buffer = 0;
    a35c:	movs	r3, #0
    a35e:	strb	r3, [r6, #0]
	return index; // return number of characters, not including null terminator
    a360:	b.n	a368 <Stream::readBytesUntil(char, char*, unsigned int)+0x40>
// terminates if length characters have been read, timeout, or if the terminator character  detected
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
	if (buffer == nullptr) return 0;
    a362:	mov	r4, r2
    a364:	b.n	a368 <Stream::readBytesUntil(char, char*, unsigned int)+0x40>
    a366:	mov	r4, r3
		*buffer++ = (char)c;
		index++;
	}
	*buffer = 0;
	return index; // return number of characters, not including null terminator
}
    a368:	mov	r0, r4
    a36a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0000a36e <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    a36e:	bx	lr

0000a370 <operator new(unsigned int)>:
    a370:	b.w	b2d4 <malloc>

0000a374 <operator delete(void*, unsigned int)>:
    a374:	b.w	b2e4 <free>

0000a378 <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    a378:	push	{r4, lr}
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    a37a:	ldr	r3, [pc, #128]	; (a3fc <analog_init+0x84>)
    a37c:	ldr	r0, [pc, #128]	; (a400 <analog_init+0x88>)
    a37e:	ldr	r1, [pc, #132]	; (a404 <analog_init+0x8c>)
    a380:	movs	r2, #96	; 0x60
    a382:	strb	r2, [r3, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    a384:	movs	r2, #225	; 0xe1
    a386:	strb	r2, [r3, #1]
	#endif

	if (analog_config_bits == 8) {
    a388:	ldr	r3, [pc, #124]	; (a408 <analog_init+0x90>)
    a38a:	ldr	r2, [pc, #128]	; (a40c <analog_init+0x94>)
    a38c:	ldrb	r4, [r3, #0]
    a38e:	ldr	r3, [pc, #128]	; (a410 <analog_init+0x98>)
    a390:	cmp	r4, #8
    a392:	bne.n	a398 <analog_init+0x20>
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    a394:	movs	r4, #1
    a396:	b.n	a39e <analog_init+0x26>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    a398:	cmp	r4, #10
    a39a:	bne.n	a3a4 <analog_init+0x2c>
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    a39c:	movs	r4, #57	; 0x39
    a39e:	str	r4, [r0, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    a3a0:	movs	r0, #19
    a3a2:	b.n	a3b0 <analog_init+0x38>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    a3a4:	cmp	r4, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    a3a6:	ite	eq
    a3a8:	moveq	r4, #53	; 0x35
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    a3aa:	movne	r4, #61	; 0x3d
    a3ac:	str	r4, [r0, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    a3ae:	movs	r0, #18
    a3b0:	str	r0, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    a3b2:	str	r4, [r2, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    a3b4:	str	r0, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    a3b6:	ldr	r3, [pc, #92]	; (a414 <analog_init+0x9c>)
    a3b8:	ldr	r1, [pc, #92]	; (a418 <analog_init+0xa0>)
    a3ba:	ldrb	r3, [r3, #0]
    a3bc:	ldr	r2, [pc, #92]	; (a41c <analog_init+0xa4>)
    a3be:	cbz	r3, a3c2 <analog_init+0x4a>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    a3c0:	movs	r3, #1
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    a3c2:	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    a3c4:	str	r3, [r2, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    a3c6:	ldr	r3, [pc, #88]	; (a420 <analog_init+0xa8>)
    a3c8:	ldr	r2, [pc, #88]	; (a424 <analog_init+0xac>)
    a3ca:	ldrb	r1, [r3, #0]
    a3cc:	ldr	r3, [pc, #88]	; (a428 <analog_init+0xb0>)
	if (num <= 1) {
    a3ce:	cmp	r1, #1
    a3d0:	bhi.n	a3d6 <analog_init+0x5e>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    a3d2:	movs	r1, #128	; 0x80
    a3d4:	b.n	a3ee <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    a3d6:	cmp	r1, #4
    a3d8:	bhi.n	a3de <analog_init+0x66>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    a3da:	movs	r1, #132	; 0x84
    a3dc:	b.n	a3ee <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    a3de:	cmp	r1, #8
    a3e0:	bhi.n	a3e6 <analog_init+0x6e>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    a3e2:	movs	r1, #133	; 0x85
    a3e4:	b.n	a3ee <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    a3e6:	cmp	r1, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    a3e8:	ite	ls
    a3ea:	movls	r1, #134	; 0x86
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    a3ec:	movhi	r1, #135	; 0x87
    a3ee:	str	r1, [r2, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    a3f0:	str	r1, [r3, #0]
		#endif
	}
	calibrating = 1;
    a3f2:	ldr	r3, [pc, #56]	; (a42c <analog_init+0xb4>)
    a3f4:	movs	r2, #1
    a3f6:	strb	r2, [r3, #0]
    a3f8:	pop	{r4, pc}
    a3fa:	nop
    a3fc:	.word	0x40074000
    a400:	.word	0x4003b008
    a404:	.word	0x4003b00c
    a408:	.word	0x1fff137d
    a40c:	.word	0x400bb008
    a410:	.word	0x400bb00c
    a414:	.word	0x2001d036
    a418:	.word	0x4003b020
    a41c:	.word	0x400bb020
    a420:	.word	0x1fff137e
    a424:	.word	0x4003b024
    a428:	.word	0x400bb024
    a42c:	.word	0x2001d035

0000a430 <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    a430:	push	{r0, r1, r2, r3, r4, lr}
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    a432:	cpsid	i
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    a434:	ldr	r3, [pc, #76]	; (a484 <usb_init_serialnumber+0x54>)
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    a436:	ldr	r1, [pc, #80]	; (a488 <usb_init_serialnumber+0x58>)
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    a438:	movs	r2, #112	; 0x70
    a43a:	strb	r2, [r3, #0]
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    a43c:	ldr	r2, [pc, #76]	; (a48c <usb_init_serialnumber+0x5c>)
    a43e:	str	r1, [r2, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    a440:	movs	r2, #128	; 0x80
    a442:	strb	r2, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    a444:	ldrb	r2, [r3, #0]
    a446:	lsls	r2, r2, #24
    a448:	bpl.n	a444 <usb_init_serialnumber+0x14>
	num = *(uint32_t *)&FTFL_FCCOBB;
    a44a:	ldr	r3, [pc, #68]	; (a490 <usb_init_serialnumber+0x60>)
    a44c:	ldr	r0, [r3, #0]
	kinetis_hsrun_enable();
#endif
	__enable_irq();
    a44e:	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    a450:	ldr	r3, [pc, #64]	; (a494 <usb_init_serialnumber+0x64>)
    a452:	cmp	r0, r3
    a454:	it	ls
    a456:	movls	r3, #10
	ultoa(num, buf, 10);
    a458:	add	r4, sp, #4
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    a45a:	it	ls
    a45c:	mulls	r0, r3
	ultoa(num, buf, 10);
    a45e:	movs	r2, #10
    a460:	mov	r1, r4
    a462:	bl	a4a0 <ultoa>
    a466:	ldr	r2, [pc, #48]	; (a498 <usb_init_serialnumber+0x68>)
	for (i=0; i<10; i++) {
    a468:	movs	r3, #0
		char c = buf[i];
    a46a:	ldrb	r1, [r4, r3]
		if (!c) break;
    a46c:	cbz	r1, a478 <usb_init_serialnumber+0x48>
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    a46e:	adds	r3, #1
    a470:	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    a472:	strh.w	r1, [r2], #2
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    a476:	bne.n	a46a <usb_init_serialnumber+0x3a>
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    a478:	ldr	r2, [pc, #32]	; (a49c <usb_init_serialnumber+0x6c>)
    a47a:	adds	r3, #1
    a47c:	lsls	r3, r3, #1
    a47e:	strb	r3, [r2, #0]
}
    a480:	add	sp, #16
    a482:	pop	{r4, pc}
    a484:	.word	0x40020000
    a488:	.word	0x41070000
    a48c:	.word	0x40020004
    a490:	.word	0x4002000c
    a494:	.word	0x0098967f
    a498:	.word	0x1fff140a
    a49c:	.word	0x1fff1408

0000a4a0 <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    a4a0:	push	{r4, r5, lr}
    a4a2:	mov	r3, r0
	unsigned digit;
	int i=0, j;
    a4a4:	movs	r0, #0
	char t;

	while (1) {
		digit = val % radix;
    a4a6:	udiv	r4, r3, r2
    a4aa:	mls	r3, r2, r4, r3
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a4ae:	cmp	r3, #9
    a4b0:	ite	ls
    a4b2:	addls	r3, #48	; 0x30
    a4b4:	addhi	r3, #55	; 0x37
    a4b6:	uxtb	r3, r3
    a4b8:	strb	r3, [r1, r0]
		val /= radix;
		if (val == 0) break;
    a4ba:	mov	r3, r4
    a4bc:	cbz	r4, a4c2 <ultoa+0x22>
		i++;
    a4be:	adds	r0, #1
	}
    a4c0:	b.n	a4a6 <ultoa+0x6>
	buf[i + 1] = 0;
    a4c2:	adds	r2, r1, r0
	for (j=0; j < i; j++, i--) {
    a4c4:	mov	r3, r4
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
    a4c6:	strb	r4, [r2, #1]
	for (j=0; j < i; j++, i--) {
    a4c8:	subs	r4, r0, r3
    a4ca:	cmp	r3, r4
    a4cc:	bge.n	a4dc <ultoa+0x3c>
		t = buf[j];
    a4ce:	ldrb	r4, [r1, r3]
		buf[j] = buf[i];
    a4d0:	ldrb	r5, [r2, #0]
    a4d2:	strb	r5, [r1, r3]
		buf[i] = t;
    a4d4:	strb.w	r4, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    a4d8:	adds	r3, #1
    a4da:	b.n	a4c8 <ultoa+0x28>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    a4dc:	mov	r0, r1
    a4de:	pop	{r4, r5, pc}

0000a4e0 <__aeabi_atexit>:
    a4e0:	mov	r3, r1
    a4e2:	mov	r1, r0
    a4e4:	mov	r0, r3
    a4e6:	b.w	b21c <__cxa_atexit>
    a4ea:	nop

0000a4ec <__aeabi_llsr>:
    a4ec:	lsrs	r0, r2
    a4ee:	adds	r3, r1, #0
    a4f0:	lsrs	r1, r2
    a4f2:	mov	ip, r3
    a4f4:	subs	r2, #32
    a4f6:	lsrs	r3, r2
    a4f8:	orrs	r0, r3
    a4fa:	negs	r2, r2
    a4fc:	mov	r3, ip
    a4fe:	lsls	r3, r2
    a500:	orrs	r0, r3
    a502:	bx	lr

0000a504 <__aeabi_drsub>:
    a504:	eor.w	r1, r1, #2147483648	; 0x80000000
    a508:	b.n	a510 <__adddf3>
    a50a:	nop

0000a50c <__aeabi_dsub>:
    a50c:	eor.w	r3, r3, #2147483648	; 0x80000000

0000a510 <__adddf3>:
    a510:	push	{r4, r5, lr}
    a512:	mov.w	r4, r1, lsl #1
    a516:	mov.w	r5, r3, lsl #1
    a51a:	teq	r4, r5
    a51e:	it	eq
    a520:	teqeq	r0, r2
    a524:	itttt	ne
    a526:	orrsne.w	ip, r4, r0
    a52a:	orrsne.w	ip, r5, r2
    a52e:	mvnsne.w	ip, r4, asr #21
    a532:	mvnsne.w	ip, r5, asr #21
    a536:	beq.w	a6fe <__adddf3+0x1ee>
    a53a:	mov.w	r4, r4, lsr #21
    a53e:	rsbs	r5, r4, r5, lsr #21
    a542:	it	lt
    a544:	neglt	r5, r5
    a546:	ble.n	a562 <__adddf3+0x52>
    a548:	add	r4, r5
    a54a:	eor.w	r2, r0, r2
    a54e:	eor.w	r3, r1, r3
    a552:	eor.w	r0, r2, r0
    a556:	eor.w	r1, r3, r1
    a55a:	eor.w	r2, r0, r2
    a55e:	eor.w	r3, r1, r3
    a562:	cmp	r5, #54	; 0x36
    a564:	it	hi
    a566:	pophi	{r4, r5, pc}
    a568:	tst.w	r1, #2147483648	; 0x80000000
    a56c:	mov.w	r1, r1, lsl #12
    a570:	mov.w	ip, #1048576	; 0x100000
    a574:	orr.w	r1, ip, r1, lsr #12
    a578:	beq.n	a580 <__adddf3+0x70>
    a57a:	negs	r0, r0
    a57c:	sbc.w	r1, r1, r1, lsl #1
    a580:	tst.w	r3, #2147483648	; 0x80000000
    a584:	mov.w	r3, r3, lsl #12
    a588:	orr.w	r3, ip, r3, lsr #12
    a58c:	beq.n	a594 <__adddf3+0x84>
    a58e:	negs	r2, r2
    a590:	sbc.w	r3, r3, r3, lsl #1
    a594:	teq	r4, r5
    a598:	beq.w	a6ea <__adddf3+0x1da>
    a59c:	sub.w	r4, r4, #1
    a5a0:	rsbs	lr, r5, #32
    a5a4:	blt.n	a5c2 <__adddf3+0xb2>
    a5a6:	lsl.w	ip, r2, lr
    a5aa:	lsr.w	r2, r2, r5
    a5ae:	adds	r0, r0, r2
    a5b0:	adc.w	r1, r1, #0
    a5b4:	lsl.w	r2, r3, lr
    a5b8:	adds	r0, r0, r2
    a5ba:	asr.w	r3, r3, r5
    a5be:	adcs	r1, r3
    a5c0:	b.n	a5e0 <__adddf3+0xd0>
    a5c2:	sub.w	r5, r5, #32
    a5c6:	add.w	lr, lr, #32
    a5ca:	cmp	r2, #1
    a5cc:	lsl.w	ip, r3, lr
    a5d0:	it	cs
    a5d2:	orrcs.w	ip, ip, #2
    a5d6:	asr.w	r3, r3, r5
    a5da:	adds	r0, r0, r3
    a5dc:	adcs.w	r1, r1, r3, asr #31
    a5e0:	and.w	r5, r1, #2147483648	; 0x80000000
    a5e4:	bpl.n	a5f6 <__adddf3+0xe6>
    a5e6:	mov.w	lr, #0
    a5ea:	rsbs	ip, ip, #0
    a5ee:	sbcs.w	r0, lr, r0
    a5f2:	sbc.w	r1, lr, r1
    a5f6:	cmp.w	r1, #1048576	; 0x100000
    a5fa:	bcc.n	a634 <__adddf3+0x124>
    a5fc:	cmp.w	r1, #2097152	; 0x200000
    a600:	bcc.n	a61c <__adddf3+0x10c>
    a602:	lsrs	r1, r1, #1
    a604:	movs.w	r0, r0, rrx
    a608:	mov.w	ip, ip, rrx
    a60c:	add.w	r4, r4, #1
    a610:	mov.w	r2, r4, lsl #21
    a614:	cmn.w	r2, #4194304	; 0x400000
    a618:	bcs.w	a750 <__adddf3+0x240>
    a61c:	cmp.w	ip, #2147483648	; 0x80000000
    a620:	it	eq
    a622:	movseq.w	ip, r0, lsr #1
    a626:	adcs.w	r0, r0, #0
    a62a:	adc.w	r1, r1, r4, lsl #20
    a62e:	orr.w	r1, r1, r5
    a632:	pop	{r4, r5, pc}
    a634:	movs.w	ip, ip, lsl #1
    a638:	adcs	r0, r0
    a63a:	adc.w	r1, r1, r1
    a63e:	tst.w	r1, #1048576	; 0x100000
    a642:	sub.w	r4, r4, #1
    a646:	bne.n	a61c <__adddf3+0x10c>
    a648:	teq	r1, #0
    a64c:	itt	eq
    a64e:	moveq	r1, r0
    a650:	moveq	r0, #0
    a652:	clz	r3, r1
    a656:	it	eq
    a658:	addeq	r3, #32
    a65a:	sub.w	r3, r3, #11
    a65e:	subs.w	r2, r3, #32
    a662:	bge.n	a67e <__adddf3+0x16e>
    a664:	adds	r2, #12
    a666:	ble.n	a67a <__adddf3+0x16a>
    a668:	add.w	ip, r2, #20
    a66c:	rsb	r2, r2, #12
    a670:	lsl.w	r0, r1, ip
    a674:	lsr.w	r1, r1, r2
    a678:	b.n	a694 <__adddf3+0x184>
    a67a:	add.w	r2, r2, #20
    a67e:	it	le
    a680:	rsble	ip, r2, #32
    a684:	lsl.w	r1, r1, r2
    a688:	lsr.w	ip, r0, ip
    a68c:	itt	le
    a68e:	orrle.w	r1, r1, ip
    a692:	lslle	r0, r2
    a694:	subs	r4, r4, r3
    a696:	ittt	ge
    a698:	addge.w	r1, r1, r4, lsl #20
    a69c:	orrge	r1, r5
    a69e:	popge	{r4, r5, pc}
    a6a0:	mvn.w	r4, r4
    a6a4:	subs	r4, #31
    a6a6:	bge.n	a6e2 <__adddf3+0x1d2>
    a6a8:	adds	r4, #12
    a6aa:	bgt.n	a6ca <__adddf3+0x1ba>
    a6ac:	add.w	r4, r4, #20
    a6b0:	rsb	r2, r4, #32
    a6b4:	lsr.w	r0, r0, r4
    a6b8:	lsl.w	r3, r1, r2
    a6bc:	orr.w	r0, r0, r3
    a6c0:	lsr.w	r3, r1, r4
    a6c4:	orr.w	r1, r5, r3
    a6c8:	pop	{r4, r5, pc}
    a6ca:	rsb	r4, r4, #12
    a6ce:	rsb	r2, r4, #32
    a6d2:	lsr.w	r0, r0, r2
    a6d6:	lsl.w	r3, r1, r4
    a6da:	orr.w	r0, r0, r3
    a6de:	mov	r1, r5
    a6e0:	pop	{r4, r5, pc}
    a6e2:	lsr.w	r0, r1, r4
    a6e6:	mov	r1, r5
    a6e8:	pop	{r4, r5, pc}
    a6ea:	teq	r4, #0
    a6ee:	eor.w	r3, r3, #1048576	; 0x100000
    a6f2:	itte	eq
    a6f4:	eoreq.w	r1, r1, #1048576	; 0x100000
    a6f8:	addeq	r4, #1
    a6fa:	subne	r5, #1
    a6fc:	b.n	a59c <__adddf3+0x8c>
    a6fe:	mvns.w	ip, r4, asr #21
    a702:	it	ne
    a704:	mvnsne.w	ip, r5, asr #21
    a708:	beq.n	a75e <__adddf3+0x24e>
    a70a:	teq	r4, r5
    a70e:	it	eq
    a710:	teqeq	r0, r2
    a714:	beq.n	a722 <__adddf3+0x212>
    a716:	orrs.w	ip, r4, r0
    a71a:	itt	eq
    a71c:	moveq	r1, r3
    a71e:	moveq	r0, r2
    a720:	pop	{r4, r5, pc}
    a722:	teq	r1, r3
    a726:	ittt	ne
    a728:	movne	r1, #0
    a72a:	movne	r0, #0
    a72c:	popne	{r4, r5, pc}
    a72e:	movs.w	ip, r4, lsr #21
    a732:	bne.n	a740 <__adddf3+0x230>
    a734:	lsls	r0, r0, #1
    a736:	adcs	r1, r1
    a738:	it	cs
    a73a:	orrcs.w	r1, r1, #2147483648	; 0x80000000
    a73e:	pop	{r4, r5, pc}
    a740:	adds.w	r4, r4, #4194304	; 0x400000
    a744:	itt	cc
    a746:	addcc.w	r1, r1, #1048576	; 0x100000
    a74a:	popcc	{r4, r5, pc}
    a74c:	and.w	r5, r1, #2147483648	; 0x80000000
    a750:	orr.w	r1, r5, #2130706432	; 0x7f000000
    a754:	orr.w	r1, r1, #15728640	; 0xf00000
    a758:	mov.w	r0, #0
    a75c:	pop	{r4, r5, pc}
    a75e:	mvns.w	ip, r4, asr #21
    a762:	itte	ne
    a764:	movne	r1, r3
    a766:	movne	r0, r2
    a768:	mvnseq.w	ip, r5, asr #21
    a76c:	itt	ne
    a76e:	movne	r3, r1
    a770:	movne	r2, r0
    a772:	orrs.w	r4, r0, r1, lsl #12
    a776:	itte	eq
    a778:	orrseq.w	r5, r2, r3, lsl #12
    a77c:	teqeq	r1, r3
    a780:	orrne.w	r1, r1, #524288	; 0x80000
    a784:	pop	{r4, r5, pc}
    a786:	nop

0000a788 <__aeabi_ui2d>:
    a788:	teq	r0, #0
    a78c:	itt	eq
    a78e:	moveq	r1, #0
    a790:	bxeq	lr
    a792:	push	{r4, r5, lr}
    a794:	mov.w	r4, #1024	; 0x400
    a798:	add.w	r4, r4, #50	; 0x32
    a79c:	mov.w	r5, #0
    a7a0:	mov.w	r1, #0
    a7a4:	b.n	a648 <__adddf3+0x138>
    a7a6:	nop

0000a7a8 <__aeabi_i2d>:
    a7a8:	teq	r0, #0
    a7ac:	itt	eq
    a7ae:	moveq	r1, #0
    a7b0:	bxeq	lr
    a7b2:	push	{r4, r5, lr}
    a7b4:	mov.w	r4, #1024	; 0x400
    a7b8:	add.w	r4, r4, #50	; 0x32
    a7bc:	ands.w	r5, r0, #2147483648	; 0x80000000
    a7c0:	it	mi
    a7c2:	negmi	r0, r0
    a7c4:	mov.w	r1, #0
    a7c8:	b.n	a648 <__adddf3+0x138>
    a7ca:	nop

0000a7cc <__aeabi_f2d>:
    a7cc:	lsls	r2, r0, #1
    a7ce:	mov.w	r1, r2, asr #3
    a7d2:	mov.w	r1, r1, rrx
    a7d6:	mov.w	r0, r2, lsl #28
    a7da:	itttt	ne
    a7dc:	andsne.w	r3, r2, #4278190080	; 0xff000000
    a7e0:	teqne	r3, #4278190080	; 0xff000000
    a7e4:	eorne.w	r1, r1, #939524096	; 0x38000000
    a7e8:	bxne	lr
    a7ea:	teq	r2, #0
    a7ee:	ite	ne
    a7f0:	teqne	r3, #4278190080	; 0xff000000
    a7f4:	bxeq	lr
    a7f6:	push	{r4, r5, lr}
    a7f8:	mov.w	r4, #896	; 0x380
    a7fc:	and.w	r5, r1, #2147483648	; 0x80000000
    a800:	bic.w	r1, r1, #2147483648	; 0x80000000
    a804:	b.n	a648 <__adddf3+0x138>
    a806:	nop

0000a808 <__aeabi_ul2d>:
    a808:	orrs.w	r2, r0, r1
    a80c:	it	eq
    a80e:	bxeq	lr
    a810:	push	{r4, r5, lr}
    a812:	mov.w	r5, #0
    a816:	b.n	a82e <__aeabi_l2d+0x16>

0000a818 <__aeabi_l2d>:
    a818:	orrs.w	r2, r0, r1
    a81c:	it	eq
    a81e:	bxeq	lr
    a820:	push	{r4, r5, lr}
    a822:	ands.w	r5, r1, #2147483648	; 0x80000000
    a826:	bpl.n	a82e <__aeabi_l2d+0x16>
    a828:	negs	r0, r0
    a82a:	sbc.w	r1, r1, r1, lsl #1
    a82e:	mov.w	r4, #1024	; 0x400
    a832:	add.w	r4, r4, #50	; 0x32
    a836:	movs.w	ip, r1, lsr #22
    a83a:	beq.w	a5f6 <__adddf3+0xe6>
    a83e:	mov.w	r2, #3
    a842:	movs.w	ip, ip, lsr #3
    a846:	it	ne
    a848:	addne	r2, #3
    a84a:	movs.w	ip, ip, lsr #3
    a84e:	it	ne
    a850:	addne	r2, #3
    a852:	add.w	r2, r2, ip, lsr #3
    a856:	rsb	r3, r2, #32
    a85a:	lsl.w	ip, r0, r3
    a85e:	lsr.w	r0, r0, r2
    a862:	lsl.w	lr, r1, r3
    a866:	orr.w	r0, r0, lr
    a86a:	lsr.w	r1, r1, r2
    a86e:	add	r4, r2
    a870:	b.n	a5f6 <__adddf3+0xe6>
    a872:	nop

0000a874 <__aeabi_dmul>:
    a874:	push	{r4, r5, r6, lr}
    a876:	mov.w	ip, #255	; 0xff
    a87a:	orr.w	ip, ip, #1792	; 0x700
    a87e:	ands.w	r4, ip, r1, lsr #20
    a882:	ittte	ne
    a884:	andsne.w	r5, ip, r3, lsr #20
    a888:	teqne	r4, ip
    a88c:	teqne	r5, ip
    a890:	bleq	aa50 <__aeabi_dmul+0x1dc>
    a894:	add	r4, r5
    a896:	eor.w	r6, r1, r3
    a89a:	bic.w	r1, r1, ip, lsl #21
    a89e:	bic.w	r3, r3, ip, lsl #21
    a8a2:	orrs.w	r5, r0, r1, lsl #12
    a8a6:	it	ne
    a8a8:	orrsne.w	r5, r2, r3, lsl #12
    a8ac:	orr.w	r1, r1, #1048576	; 0x100000
    a8b0:	orr.w	r3, r3, #1048576	; 0x100000
    a8b4:	beq.n	a928 <__aeabi_dmul+0xb4>
    a8b6:	umull	ip, lr, r0, r2
    a8ba:	mov.w	r5, #0
    a8be:	umlal	lr, r5, r1, r2
    a8c2:	and.w	r2, r6, #2147483648	; 0x80000000
    a8c6:	umlal	lr, r5, r0, r3
    a8ca:	mov.w	r6, #0
    a8ce:	umlal	r5, r6, r1, r3
    a8d2:	teq	ip, #0
    a8d6:	it	ne
    a8d8:	orrne.w	lr, lr, #1
    a8dc:	sub.w	r4, r4, #255	; 0xff
    a8e0:	cmp.w	r6, #512	; 0x200
    a8e4:	sbc.w	r4, r4, #768	; 0x300
    a8e8:	bcs.n	a8f4 <__aeabi_dmul+0x80>
    a8ea:	movs.w	lr, lr, lsl #1
    a8ee:	adcs	r5, r5
    a8f0:	adc.w	r6, r6, r6
    a8f4:	orr.w	r1, r2, r6, lsl #11
    a8f8:	orr.w	r1, r1, r5, lsr #21
    a8fc:	mov.w	r0, r5, lsl #11
    a900:	orr.w	r0, r0, lr, lsr #21
    a904:	mov.w	lr, lr, lsl #11
    a908:	subs.w	ip, r4, #253	; 0xfd
    a90c:	it	hi
    a90e:	cmphi.w	ip, #1792	; 0x700
    a912:	bhi.n	a952 <__aeabi_dmul+0xde>
    a914:	cmp.w	lr, #2147483648	; 0x80000000
    a918:	it	eq
    a91a:	movseq.w	lr, r0, lsr #1
    a91e:	adcs.w	r0, r0, #0
    a922:	adc.w	r1, r1, r4, lsl #20
    a926:	pop	{r4, r5, r6, pc}
    a928:	and.w	r6, r6, #2147483648	; 0x80000000
    a92c:	orr.w	r1, r6, r1
    a930:	orr.w	r0, r0, r2
    a934:	eor.w	r1, r1, r3
    a938:	subs.w	r4, r4, ip, lsr #1
    a93c:	ittt	gt
    a93e:	rsbsgt	r5, r4, ip
    a942:	orrgt.w	r1, r1, r4, lsl #20
    a946:	popgt	{r4, r5, r6, pc}
    a948:	orr.w	r1, r1, #1048576	; 0x100000
    a94c:	mov.w	lr, #0
    a950:	subs	r4, #1
    a952:	bgt.w	aaac <__aeabi_dmul+0x238>
    a956:	cmn.w	r4, #54	; 0x36
    a95a:	ittt	le
    a95c:	movle	r0, #0
    a95e:	andle.w	r1, r1, #2147483648	; 0x80000000
    a962:	pople	{r4, r5, r6, pc}
    a964:	rsb	r4, r4, #0
    a968:	subs	r4, #32
    a96a:	bge.n	a9d8 <__aeabi_dmul+0x164>
    a96c:	adds	r4, #12
    a96e:	bgt.n	a9a8 <__aeabi_dmul+0x134>
    a970:	add.w	r4, r4, #20
    a974:	rsb	r5, r4, #32
    a978:	lsl.w	r3, r0, r5
    a97c:	lsr.w	r0, r0, r4
    a980:	lsl.w	r2, r1, r5
    a984:	orr.w	r0, r0, r2
    a988:	and.w	r2, r1, #2147483648	; 0x80000000
    a98c:	bic.w	r1, r1, #2147483648	; 0x80000000
    a990:	adds.w	r0, r0, r3, lsr #31
    a994:	lsr.w	r6, r1, r4
    a998:	adc.w	r1, r2, r6
    a99c:	orrs.w	lr, lr, r3, lsl #1
    a9a0:	it	eq
    a9a2:	biceq.w	r0, r0, r3, lsr #31
    a9a6:	pop	{r4, r5, r6, pc}
    a9a8:	rsb	r4, r4, #12
    a9ac:	rsb	r5, r4, #32
    a9b0:	lsl.w	r3, r0, r4
    a9b4:	lsr.w	r0, r0, r5
    a9b8:	lsl.w	r2, r1, r4
    a9bc:	orr.w	r0, r0, r2
    a9c0:	and.w	r1, r1, #2147483648	; 0x80000000
    a9c4:	adds.w	r0, r0, r3, lsr #31
    a9c8:	adc.w	r1, r1, #0
    a9cc:	orrs.w	lr, lr, r3, lsl #1
    a9d0:	it	eq
    a9d2:	biceq.w	r0, r0, r3, lsr #31
    a9d6:	pop	{r4, r5, r6, pc}
    a9d8:	rsb	r5, r4, #32
    a9dc:	lsl.w	r2, r0, r5
    a9e0:	orr.w	lr, lr, r2
    a9e4:	lsr.w	r3, r0, r4
    a9e8:	lsl.w	r2, r1, r5
    a9ec:	orr.w	r3, r3, r2
    a9f0:	lsr.w	r0, r1, r4
    a9f4:	and.w	r1, r1, #2147483648	; 0x80000000
    a9f8:	lsr.w	r2, r1, r4
    a9fc:	bic.w	r0, r0, r2
    aa00:	add.w	r0, r0, r3, lsr #31
    aa04:	orrs.w	lr, lr, r3, lsl #1
    aa08:	it	eq
    aa0a:	biceq.w	r0, r0, r3, lsr #31
    aa0e:	pop	{r4, r5, r6, pc}
    aa10:	teq	r4, #0
    aa14:	bne.n	aa36 <__aeabi_dmul+0x1c2>
    aa16:	and.w	r6, r1, #2147483648	; 0x80000000
    aa1a:	lsls	r0, r0, #1
    aa1c:	adc.w	r1, r1, r1
    aa20:	tst.w	r1, #1048576	; 0x100000
    aa24:	it	eq
    aa26:	subeq	r4, #1
    aa28:	beq.n	aa1a <__aeabi_dmul+0x1a6>
    aa2a:	orr.w	r1, r1, r6
    aa2e:	teq	r5, #0
    aa32:	it	ne
    aa34:	bxne	lr
    aa36:	and.w	r6, r3, #2147483648	; 0x80000000
    aa3a:	lsls	r2, r2, #1
    aa3c:	adc.w	r3, r3, r3
    aa40:	tst.w	r3, #1048576	; 0x100000
    aa44:	it	eq
    aa46:	subeq	r5, #1
    aa48:	beq.n	aa3a <__aeabi_dmul+0x1c6>
    aa4a:	orr.w	r3, r3, r6
    aa4e:	bx	lr
    aa50:	teq	r4, ip
    aa54:	and.w	r5, ip, r3, lsr #20
    aa58:	it	ne
    aa5a:	teqne	r5, ip
    aa5e:	beq.n	aa7a <__aeabi_dmul+0x206>
    aa60:	orrs.w	r6, r0, r1, lsl #1
    aa64:	it	ne
    aa66:	orrsne.w	r6, r2, r3, lsl #1
    aa6a:	bne.n	aa10 <__aeabi_dmul+0x19c>
    aa6c:	eor.w	r1, r1, r3
    aa70:	and.w	r1, r1, #2147483648	; 0x80000000
    aa74:	mov.w	r0, #0
    aa78:	pop	{r4, r5, r6, pc}
    aa7a:	orrs.w	r6, r0, r1, lsl #1
    aa7e:	itte	eq
    aa80:	moveq	r0, r2
    aa82:	moveq	r1, r3
    aa84:	orrsne.w	r6, r2, r3, lsl #1
    aa88:	beq.n	aabe <__aeabi_dmul+0x24a>
    aa8a:	teq	r4, ip
    aa8e:	bne.n	aa96 <__aeabi_dmul+0x222>
    aa90:	orrs.w	r6, r0, r1, lsl #12
    aa94:	bne.n	aabe <__aeabi_dmul+0x24a>
    aa96:	teq	r5, ip
    aa9a:	bne.n	aaa8 <__aeabi_dmul+0x234>
    aa9c:	orrs.w	r6, r2, r3, lsl #12
    aaa0:	itt	ne
    aaa2:	movne	r0, r2
    aaa4:	movne	r1, r3
    aaa6:	bne.n	aabe <__aeabi_dmul+0x24a>
    aaa8:	eor.w	r1, r1, r3
    aaac:	and.w	r1, r1, #2147483648	; 0x80000000
    aab0:	orr.w	r1, r1, #2130706432	; 0x7f000000
    aab4:	orr.w	r1, r1, #15728640	; 0xf00000
    aab8:	mov.w	r0, #0
    aabc:	pop	{r4, r5, r6, pc}
    aabe:	orr.w	r1, r1, #2130706432	; 0x7f000000
    aac2:	orr.w	r1, r1, #16252928	; 0xf80000
    aac6:	pop	{r4, r5, r6, pc}

0000aac8 <__aeabi_ddiv>:
    aac8:	push	{r4, r5, r6, lr}
    aaca:	mov.w	ip, #255	; 0xff
    aace:	orr.w	ip, ip, #1792	; 0x700
    aad2:	ands.w	r4, ip, r1, lsr #20
    aad6:	ittte	ne
    aad8:	andsne.w	r5, ip, r3, lsr #20
    aadc:	teqne	r4, ip
    aae0:	teqne	r5, ip
    aae4:	bleq	ac36 <__aeabi_ddiv+0x16e>
    aae8:	sub.w	r4, r4, r5
    aaec:	eor.w	lr, r1, r3
    aaf0:	orrs.w	r5, r2, r3, lsl #12
    aaf4:	mov.w	r1, r1, lsl #12
    aaf8:	beq.w	ac0c <__aeabi_ddiv+0x144>
    aafc:	mov.w	r3, r3, lsl #12
    ab00:	mov.w	r5, #268435456	; 0x10000000
    ab04:	orr.w	r3, r5, r3, lsr #4
    ab08:	orr.w	r3, r3, r2, lsr #24
    ab0c:	mov.w	r2, r2, lsl #8
    ab10:	orr.w	r5, r5, r1, lsr #4
    ab14:	orr.w	r5, r5, r0, lsr #24
    ab18:	mov.w	r6, r0, lsl #8
    ab1c:	and.w	r1, lr, #2147483648	; 0x80000000
    ab20:	cmp	r5, r3
    ab22:	it	eq
    ab24:	cmpeq	r6, r2
    ab26:	adc.w	r4, r4, #253	; 0xfd
    ab2a:	add.w	r4, r4, #768	; 0x300
    ab2e:	bcs.n	ab36 <__aeabi_ddiv+0x6e>
    ab30:	lsrs	r3, r3, #1
    ab32:	mov.w	r2, r2, rrx
    ab36:	subs	r6, r6, r2
    ab38:	sbc.w	r5, r5, r3
    ab3c:	lsrs	r3, r3, #1
    ab3e:	mov.w	r2, r2, rrx
    ab42:	mov.w	r0, #1048576	; 0x100000
    ab46:	mov.w	ip, #524288	; 0x80000
    ab4a:	subs.w	lr, r6, r2
    ab4e:	sbcs.w	lr, r5, r3
    ab52:	ittt	cs
    ab54:	subcs	r6, r6, r2
    ab56:	movcs	r5, lr
    ab58:	orrcs.w	r0, r0, ip
    ab5c:	lsrs	r3, r3, #1
    ab5e:	mov.w	r2, r2, rrx
    ab62:	subs.w	lr, r6, r2
    ab66:	sbcs.w	lr, r5, r3
    ab6a:	ittt	cs
    ab6c:	subcs	r6, r6, r2
    ab6e:	movcs	r5, lr
    ab70:	orrcs.w	r0, r0, ip, lsr #1
    ab74:	lsrs	r3, r3, #1
    ab76:	mov.w	r2, r2, rrx
    ab7a:	subs.w	lr, r6, r2
    ab7e:	sbcs.w	lr, r5, r3
    ab82:	ittt	cs
    ab84:	subcs	r6, r6, r2
    ab86:	movcs	r5, lr
    ab88:	orrcs.w	r0, r0, ip, lsr #2
    ab8c:	lsrs	r3, r3, #1
    ab8e:	mov.w	r2, r2, rrx
    ab92:	subs.w	lr, r6, r2
    ab96:	sbcs.w	lr, r5, r3
    ab9a:	ittt	cs
    ab9c:	subcs	r6, r6, r2
    ab9e:	movcs	r5, lr
    aba0:	orrcs.w	r0, r0, ip, lsr #3
    aba4:	orrs.w	lr, r5, r6
    aba8:	beq.n	abdc <__aeabi_ddiv+0x114>
    abaa:	mov.w	r5, r5, lsl #4
    abae:	orr.w	r5, r5, r6, lsr #28
    abb2:	mov.w	r6, r6, lsl #4
    abb6:	mov.w	r3, r3, lsl #3
    abba:	orr.w	r3, r3, r2, lsr #29
    abbe:	mov.w	r2, r2, lsl #3
    abc2:	movs.w	ip, ip, lsr #4
    abc6:	bne.n	ab4a <__aeabi_ddiv+0x82>
    abc8:	tst.w	r1, #1048576	; 0x100000
    abcc:	bne.n	abe6 <__aeabi_ddiv+0x11e>
    abce:	orr.w	r1, r1, r0
    abd2:	mov.w	r0, #0
    abd6:	mov.w	ip, #2147483648	; 0x80000000
    abda:	b.n	ab4a <__aeabi_ddiv+0x82>
    abdc:	tst.w	r1, #1048576	; 0x100000
    abe0:	itt	eq
    abe2:	orreq	r1, r0
    abe4:	moveq	r0, #0
    abe6:	subs.w	ip, r4, #253	; 0xfd
    abea:	it	hi
    abec:	cmphi.w	ip, #1792	; 0x700
    abf0:	bhi.w	a952 <__aeabi_dmul+0xde>
    abf4:	subs.w	ip, r5, r3
    abf8:	itt	eq
    abfa:	subseq.w	ip, r6, r2
    abfe:	movseq.w	ip, r0, lsr #1
    ac02:	adcs.w	r0, r0, #0
    ac06:	adc.w	r1, r1, r4, lsl #20
    ac0a:	pop	{r4, r5, r6, pc}
    ac0c:	and.w	lr, lr, #2147483648	; 0x80000000
    ac10:	orr.w	r1, lr, r1, lsr #12
    ac14:	adds.w	r4, r4, ip, lsr #1
    ac18:	ittt	gt
    ac1a:	rsbsgt	r5, r4, ip
    ac1e:	orrgt.w	r1, r1, r4, lsl #20
    ac22:	popgt	{r4, r5, r6, pc}
    ac24:	orr.w	r1, r1, #1048576	; 0x100000
    ac28:	mov.w	lr, #0
    ac2c:	subs	r4, #1
    ac2e:	b.n	a952 <__aeabi_dmul+0xde>
    ac30:	orr.w	lr, r5, r6
    ac34:	b.n	a952 <__aeabi_dmul+0xde>
    ac36:	and.w	r5, ip, r3, lsr #20
    ac3a:	teq	r4, ip
    ac3e:	it	eq
    ac40:	teqeq	r5, ip
    ac44:	beq.w	aabe <__aeabi_dmul+0x24a>
    ac48:	teq	r4, ip
    ac4c:	bne.n	ac64 <__aeabi_ddiv+0x19c>
    ac4e:	orrs.w	r4, r0, r1, lsl #12
    ac52:	bne.w	aabe <__aeabi_dmul+0x24a>
    ac56:	teq	r5, ip
    ac5a:	bne.w	aaa8 <__aeabi_dmul+0x234>
    ac5e:	mov	r0, r2
    ac60:	mov	r1, r3
    ac62:	b.n	aabe <__aeabi_dmul+0x24a>
    ac64:	teq	r5, ip
    ac68:	bne.n	ac78 <__aeabi_ddiv+0x1b0>
    ac6a:	orrs.w	r5, r2, r3, lsl #12
    ac6e:	beq.w	aa6c <__aeabi_dmul+0x1f8>
    ac72:	mov	r0, r2
    ac74:	mov	r1, r3
    ac76:	b.n	aabe <__aeabi_dmul+0x24a>
    ac78:	orrs.w	r6, r0, r1, lsl #1
    ac7c:	it	ne
    ac7e:	orrsne.w	r6, r2, r3, lsl #1
    ac82:	bne.w	aa10 <__aeabi_dmul+0x19c>
    ac86:	orrs.w	r4, r0, r1, lsl #1
    ac8a:	bne.w	aaa8 <__aeabi_dmul+0x234>
    ac8e:	orrs.w	r5, r2, r3, lsl #1
    ac92:	bne.w	aa6c <__aeabi_dmul+0x1f8>
    ac96:	b.n	aabe <__aeabi_dmul+0x24a>

0000ac98 <__gedf2>:
    ac98:	mov.w	ip, #4294967295
    ac9c:	b.n	acac <__cmpdf2+0x4>
    ac9e:	nop

0000aca0 <__ledf2>:
    aca0:	mov.w	ip, #1
    aca4:	b.n	acac <__cmpdf2+0x4>
    aca6:	nop

0000aca8 <__cmpdf2>:
    aca8:	mov.w	ip, #1
    acac:	str.w	ip, [sp, #-4]!
    acb0:	mov.w	ip, r1, lsl #1
    acb4:	mvns.w	ip, ip, asr #21
    acb8:	mov.w	ip, r3, lsl #1
    acbc:	it	ne
    acbe:	mvnsne.w	ip, ip, asr #21
    acc2:	beq.n	acfc <__cmpdf2+0x54>
    acc4:	add	sp, #4
    acc6:	orrs.w	ip, r0, r1, lsl #1
    acca:	ite	eq
    accc:	orrseq.w	ip, r2, r3, lsl #1
    acd0:	teqne	r1, r3
    acd4:	ittt	eq
    acd6:	teqeq	r0, r2
    acda:	moveq	r0, #0
    acdc:	bxeq	lr
    acde:	cmn.w	r0, #0
    ace2:	teq	r1, r3
    ace6:	it	pl
    ace8:	cmppl	r1, r3
    acea:	it	eq
    acec:	cmpeq	r0, r2
    acee:	ite	cs
    acf0:	asrcs	r0, r3, #31
    acf2:	mvncc.w	r0, r3, asr #31
    acf6:	orr.w	r0, r0, #1
    acfa:	bx	lr
    acfc:	mov.w	ip, r1, lsl #1
    ad00:	mvns.w	ip, ip, asr #21
    ad04:	bne.n	ad0c <__cmpdf2+0x64>
    ad06:	orrs.w	ip, r0, r1, lsl #12
    ad0a:	bne.n	ad1c <__cmpdf2+0x74>
    ad0c:	mov.w	ip, r3, lsl #1
    ad10:	mvns.w	ip, ip, asr #21
    ad14:	bne.n	acc4 <__cmpdf2+0x1c>
    ad16:	orrs.w	ip, r2, r3, lsl #12
    ad1a:	beq.n	acc4 <__cmpdf2+0x1c>
    ad1c:	ldr.w	r0, [sp], #4
    ad20:	bx	lr
    ad22:	nop

0000ad24 <__aeabi_cdrcmple>:
    ad24:	mov	ip, r0
    ad26:	mov	r0, r2
    ad28:	mov	r2, ip
    ad2a:	mov	ip, r1
    ad2c:	mov	r1, r3
    ad2e:	mov	r3, ip
    ad30:	b.n	ad34 <__aeabi_cdcmpeq>
    ad32:	nop

0000ad34 <__aeabi_cdcmpeq>:
    ad34:	push	{r0, lr}
    ad36:	bl	aca8 <__cmpdf2>
    ad3a:	cmp	r0, #0
    ad3c:	it	mi
    ad3e:	cmnmi.w	r0, #0
    ad42:	pop	{r0, pc}

0000ad44 <__aeabi_dcmpeq>:
    ad44:	str.w	lr, [sp, #-8]!
    ad48:	bl	ad34 <__aeabi_cdcmpeq>
    ad4c:	ite	eq
    ad4e:	moveq	r0, #1
    ad50:	movne	r0, #0
    ad52:	ldr.w	pc, [sp], #8
    ad56:	nop

0000ad58 <__aeabi_dcmplt>:
    ad58:	str.w	lr, [sp, #-8]!
    ad5c:	bl	ad34 <__aeabi_cdcmpeq>
    ad60:	ite	cc
    ad62:	movcc	r0, #1
    ad64:	movcs	r0, #0
    ad66:	ldr.w	pc, [sp], #8
    ad6a:	nop

0000ad6c <__aeabi_dcmple>:
    ad6c:	str.w	lr, [sp, #-8]!
    ad70:	bl	ad34 <__aeabi_cdcmpeq>
    ad74:	ite	ls
    ad76:	movls	r0, #1
    ad78:	movhi	r0, #0
    ad7a:	ldr.w	pc, [sp], #8
    ad7e:	nop

0000ad80 <__aeabi_dcmpge>:
    ad80:	str.w	lr, [sp, #-8]!
    ad84:	bl	ad24 <__aeabi_cdrcmple>
    ad88:	ite	ls
    ad8a:	movls	r0, #1
    ad8c:	movhi	r0, #0
    ad8e:	ldr.w	pc, [sp], #8
    ad92:	nop

0000ad94 <__aeabi_dcmpgt>:
    ad94:	str.w	lr, [sp, #-8]!
    ad98:	bl	ad24 <__aeabi_cdrcmple>
    ad9c:	ite	cc
    ad9e:	movcc	r0, #1
    ada0:	movcs	r0, #0
    ada2:	ldr.w	pc, [sp], #8
    ada6:	nop

0000ada8 <__aeabi_dcmpun>:
    ada8:	mov.w	ip, r1, lsl #1
    adac:	mvns.w	ip, ip, asr #21
    adb0:	bne.n	adb8 <__aeabi_dcmpun+0x10>
    adb2:	orrs.w	ip, r0, r1, lsl #12
    adb6:	bne.n	adce <__aeabi_dcmpun+0x26>
    adb8:	mov.w	ip, r3, lsl #1
    adbc:	mvns.w	ip, ip, asr #21
    adc0:	bne.n	adc8 <__aeabi_dcmpun+0x20>
    adc2:	orrs.w	ip, r2, r3, lsl #12
    adc6:	bne.n	adce <__aeabi_dcmpun+0x26>
    adc8:	mov.w	r0, #0
    adcc:	bx	lr
    adce:	mov.w	r0, #1
    add2:	bx	lr

0000add4 <__aeabi_d2iz>:
    add4:	mov.w	r2, r1, lsl #1
    add8:	adds.w	r2, r2, #2097152	; 0x200000
    addc:	bcs.n	ae0a <__aeabi_d2iz+0x36>
    adde:	bpl.n	ae04 <__aeabi_d2iz+0x30>
    ade0:	mvn.w	r3, #992	; 0x3e0
    ade4:	subs.w	r2, r3, r2, asr #21
    ade8:	bls.n	ae10 <__aeabi_d2iz+0x3c>
    adea:	mov.w	r3, r1, lsl #11
    adee:	orr.w	r3, r3, #2147483648	; 0x80000000
    adf2:	orr.w	r3, r3, r0, lsr #21
    adf6:	tst.w	r1, #2147483648	; 0x80000000
    adfa:	lsr.w	r0, r3, r2
    adfe:	it	ne
    ae00:	negne	r0, r0
    ae02:	bx	lr
    ae04:	mov.w	r0, #0
    ae08:	bx	lr
    ae0a:	orrs.w	r0, r0, r1, lsl #12
    ae0e:	bne.n	ae1c <__aeabi_d2iz+0x48>
    ae10:	ands.w	r0, r1, #2147483648	; 0x80000000
    ae14:	it	eq
    ae16:	mvneq.w	r0, #2147483648	; 0x80000000
    ae1a:	bx	lr
    ae1c:	mov.w	r0, #0
    ae20:	bx	lr
    ae22:	nop

0000ae24 <__aeabi_d2uiz>:
    ae24:	lsls	r2, r1, #1
    ae26:	bcs.n	ae4c <__aeabi_d2uiz+0x28>
    ae28:	adds.w	r2, r2, #2097152	; 0x200000
    ae2c:	bcs.n	ae52 <__aeabi_d2uiz+0x2e>
    ae2e:	bpl.n	ae4c <__aeabi_d2uiz+0x28>
    ae30:	mvn.w	r3, #992	; 0x3e0
    ae34:	subs.w	r2, r3, r2, asr #21
    ae38:	bmi.n	ae58 <__aeabi_d2uiz+0x34>
    ae3a:	mov.w	r3, r1, lsl #11
    ae3e:	orr.w	r3, r3, #2147483648	; 0x80000000
    ae42:	orr.w	r3, r3, r0, lsr #21
    ae46:	lsr.w	r0, r3, r2
    ae4a:	bx	lr
    ae4c:	mov.w	r0, #0
    ae50:	bx	lr
    ae52:	orrs.w	r0, r0, r1, lsl #12
    ae56:	bne.n	ae5e <__aeabi_d2uiz+0x3a>
    ae58:	mov.w	r0, #4294967295
    ae5c:	bx	lr
    ae5e:	mov.w	r0, #0
    ae62:	bx	lr

0000ae64 <__aeabi_d2f>:
    ae64:	mov.w	r2, r1, lsl #1
    ae68:	subs.w	r3, r2, #1879048192	; 0x70000000
    ae6c:	itt	cs
    ae6e:	subscs.w	ip, r3, #2097152	; 0x200000
    ae72:	rsbscs	ip, ip, #532676608	; 0x1fc00000
    ae76:	bls.n	ae94 <__aeabi_d2f+0x30>
    ae78:	and.w	ip, r1, #2147483648	; 0x80000000
    ae7c:	mov.w	r2, r0, lsl #3
    ae80:	orr.w	r0, ip, r0, lsr #29
    ae84:	cmp.w	r2, #2147483648	; 0x80000000
    ae88:	adc.w	r0, r0, r3, lsl #2
    ae8c:	it	eq
    ae8e:	biceq.w	r0, r0, #1
    ae92:	bx	lr
    ae94:	tst.w	r1, #1073741824	; 0x40000000
    ae98:	bne.n	aede <__aeabi_d2f+0x7a>
    ae9a:	adds.w	r2, r3, #48234496	; 0x2e00000
    ae9e:	itt	lt
    aea0:	andlt.w	r0, r1, #2147483648	; 0x80000000
    aea4:	bxlt	lr
    aea6:	orr.w	r1, r1, #1048576	; 0x100000
    aeaa:	mov.w	r2, r2, lsr #21
    aeae:	rsb	r2, r2, #24
    aeb2:	rsb	ip, r2, #32
    aeb6:	lsls.w	r3, r0, ip
    aeba:	lsr.w	r0, r0, r2
    aebe:	it	ne
    aec0:	orrne.w	r0, r0, #1
    aec4:	mov.w	r3, r1, lsl #11
    aec8:	mov.w	r3, r3, lsr #11
    aecc:	lsl.w	ip, r3, ip
    aed0:	orr.w	r0, r0, ip
    aed4:	lsr.w	r3, r3, r2
    aed8:	mov.w	r3, r3, lsl #1
    aedc:	b.n	ae78 <__aeabi_d2f+0x14>
    aede:	mvns.w	r3, r2, asr #21
    aee2:	bne.n	aef4 <__aeabi_d2f+0x90>
    aee4:	orrs.w	r3, r0, r1, lsl #12
    aee8:	ittt	ne
    aeea:	movne.w	r0, #2130706432	; 0x7f000000
    aeee:	orrne.w	r0, r0, #12582912	; 0xc00000
    aef2:	bxne	lr
    aef4:	and.w	r0, r1, #2147483648	; 0x80000000
    aef8:	orr.w	r0, r0, #2130706432	; 0x7f000000
    aefc:	orr.w	r0, r0, #8388608	; 0x800000
    af00:	bx	lr
    af02:	nop

0000af04 <__aeabi_uldivmod>:
    af04:	cbnz	r3, af1c <__aeabi_uldivmod+0x18>
    af06:	cbnz	r2, af1c <__aeabi_uldivmod+0x18>
    af08:	cmp	r1, #0
    af0a:	it	eq
    af0c:	cmpeq	r0, #0
    af0e:	itt	ne
    af10:	movne.w	r1, #4294967295
    af14:	movne.w	r0, #4294967295
    af18:	b.w	b218 <__aeabi_idiv0>
    af1c:	sub.w	ip, sp, #8
    af20:	strd	ip, lr, [sp, #-16]!
    af24:	bl	af34 <__udivmoddi4>
    af28:	ldr.w	lr, [sp, #4]
    af2c:	ldrd	r2, r3, [sp, #8]
    af30:	add	sp, #16
    af32:	bx	lr

0000af34 <__udivmoddi4>:
    af34:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    af38:	mov	ip, r1
    af3a:	mov	r6, r1
    af3c:	mov	r4, r0
    af3e:	ldr	r5, [sp, #32]
    af40:	cmp	r3, #0
    af42:	bne.n	afe6 <__udivmoddi4+0xb2>
    af44:	cmp	r2, r1
    af46:	mov	r7, r2
    af48:	bls.n	b024 <__udivmoddi4+0xf0>
    af4a:	clz	lr, r2
    af4e:	cmp.w	lr, #0
    af52:	beq.n	af6c <__udivmoddi4+0x38>
    af54:	rsb	r4, lr, #32
    af58:	lsr.w	r4, r0, r4
    af5c:	lsl.w	r6, r1, lr
    af60:	orr.w	ip, r4, r6
    af64:	lsl.w	r7, r2, lr
    af68:	lsl.w	r4, r0, lr
    af6c:	mov.w	r9, r7, lsr #16
    af70:	lsrs	r2, r4, #16
    af72:	udiv	r0, ip, r9
    af76:	uxth.w	r8, r7
    af7a:	mls	r6, r9, r0, ip
    af7e:	orr.w	r6, r2, r6, lsl #16
    af82:	mul.w	r3, r0, r8
    af86:	cmp	r3, r6
    af88:	bls.n	af9e <__udivmoddi4+0x6a>
    af8a:	adds	r6, r6, r7
    af8c:	add.w	r2, r0, #4294967295
    af90:	bcs.w	b1d8 <__udivmoddi4+0x2a4>
    af94:	cmp	r3, r6
    af96:	bls.w	b1d8 <__udivmoddi4+0x2a4>
    af9a:	subs	r0, #2
    af9c:	add	r6, r7
    af9e:	subs	r6, r6, r3
    afa0:	uxth	r2, r4
    afa2:	udiv	r3, r6, r9
    afa6:	mls	r6, r9, r3, r6
    afaa:	orr.w	r4, r2, r6, lsl #16
    afae:	mul.w	r8, r3, r8
    afb2:	cmp	r8, r4
    afb4:	bls.n	afca <__udivmoddi4+0x96>
    afb6:	adds	r4, r4, r7
    afb8:	add.w	r2, r3, #4294967295
    afbc:	bcs.w	b1d4 <__udivmoddi4+0x2a0>
    afc0:	cmp	r8, r4
    afc2:	bls.w	b1d4 <__udivmoddi4+0x2a0>
    afc6:	subs	r3, #2
    afc8:	add	r4, r7
    afca:	rsb	r4, r8, r4
    afce:	orr.w	r0, r3, r0, lsl #16
    afd2:	movs	r1, #0
    afd4:	cmp	r5, #0
    afd6:	beq.n	b09e <__udivmoddi4+0x16a>
    afd8:	lsr.w	r4, r4, lr
    afdc:	movs	r3, #0
    afde:	str	r4, [r5, #0]
    afe0:	str	r3, [r5, #4]
    afe2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    afe6:	cmp	r3, r1
    afe8:	bls.n	affa <__udivmoddi4+0xc6>
    afea:	cmp	r5, #0
    afec:	beq.n	b09a <__udivmoddi4+0x166>
    afee:	movs	r1, #0
    aff0:	stmia.w	r5, {r0, r6}
    aff4:	mov	r0, r1
    aff6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    affa:	clz	r1, r3
    affe:	cmp	r1, #0
    b000:	bne.w	b124 <__udivmoddi4+0x1f0>
    b004:	cmp	r3, r6
    b006:	bcc.n	b00e <__udivmoddi4+0xda>
    b008:	cmp	r2, r0
    b00a:	bhi.w	b1fe <__udivmoddi4+0x2ca>
    b00e:	subs	r4, r0, r2
    b010:	sbc.w	r6, r6, r3
    b014:	movs	r0, #1
    b016:	mov	ip, r6
    b018:	cmp	r5, #0
    b01a:	beq.n	b09e <__udivmoddi4+0x16a>
    b01c:	stmia.w	r5, {r4, ip}
    b020:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b024:	cbnz	r2, b02c <__udivmoddi4+0xf8>
    b026:	movs	r7, #1
    b028:	udiv	r7, r7, r2
    b02c:	clz	lr, r7
    b030:	cmp.w	lr, #0
    b034:	bne.n	b0a2 <__udivmoddi4+0x16e>
    b036:	subs	r3, r6, r7
    b038:	mov.w	r8, r7, lsr #16
    b03c:	uxth.w	ip, r7
    b040:	movs	r1, #1
    b042:	udiv	r0, r3, r8
    b046:	lsrs	r2, r4, #16
    b048:	mls	r6, r8, r0, r3
    b04c:	orr.w	r6, r2, r6, lsl #16
    b050:	mul.w	r3, ip, r0
    b054:	cmp	r3, r6
    b056:	bls.n	b068 <__udivmoddi4+0x134>
    b058:	adds	r6, r6, r7
    b05a:	add.w	r2, r0, #4294967295
    b05e:	bcs.n	b066 <__udivmoddi4+0x132>
    b060:	cmp	r3, r6
    b062:	bhi.w	b202 <__udivmoddi4+0x2ce>
    b066:	mov	r0, r2
    b068:	subs	r6, r6, r3
    b06a:	uxth	r2, r4
    b06c:	udiv	r3, r6, r8
    b070:	mls	r6, r8, r3, r6
    b074:	orr.w	r4, r2, r6, lsl #16
    b078:	mul.w	ip, ip, r3
    b07c:	cmp	ip, r4
    b07e:	bls.n	b090 <__udivmoddi4+0x15c>
    b080:	adds	r4, r4, r7
    b082:	add.w	r2, r3, #4294967295
    b086:	bcs.n	b08e <__udivmoddi4+0x15a>
    b088:	cmp	ip, r4
    b08a:	bhi.w	b1f8 <__udivmoddi4+0x2c4>
    b08e:	mov	r3, r2
    b090:	rsb	r4, ip, r4
    b094:	orr.w	r0, r3, r0, lsl #16
    b098:	b.n	afd4 <__udivmoddi4+0xa0>
    b09a:	mov	r1, r5
    b09c:	mov	r0, r5
    b09e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b0a2:	rsb	r1, lr, #32
    b0a6:	lsl.w	r3, r6, lr
    b0aa:	lsl.w	r7, r7, lr
    b0ae:	lsr.w	r9, r0, r1
    b0b2:	mov.w	r8, r7, lsr #16
    b0b6:	lsrs	r6, r1
    b0b8:	orr.w	r9, r9, r3
    b0bc:	udiv	sl, r6, r8
    b0c0:	mov.w	r4, r9, lsr #16
    b0c4:	mls	r6, r8, sl, r6
    b0c8:	uxth.w	ip, r7
    b0cc:	orr.w	r3, r4, r6, lsl #16
    b0d0:	mul.w	r2, sl, ip
    b0d4:	cmp	r2, r3
    b0d6:	lsl.w	r4, r0, lr
    b0da:	bls.n	b0f2 <__udivmoddi4+0x1be>
    b0dc:	adds	r3, r3, r7
    b0de:	add.w	r1, sl, #4294967295
    b0e2:	bcs.w	b1f4 <__udivmoddi4+0x2c0>
    b0e6:	cmp	r2, r3
    b0e8:	bls.w	b1f4 <__udivmoddi4+0x2c0>
    b0ec:	sub.w	sl, sl, #2
    b0f0:	add	r3, r7
    b0f2:	subs	r3, r3, r2
    b0f4:	uxth.w	r9, r9
    b0f8:	udiv	r1, r3, r8
    b0fc:	mls	r3, r8, r1, r3
    b100:	orr.w	r3, r9, r3, lsl #16
    b104:	mul.w	r6, r1, ip
    b108:	cmp	r6, r3
    b10a:	bls.n	b11c <__udivmoddi4+0x1e8>
    b10c:	adds	r3, r3, r7
    b10e:	add.w	r2, r1, #4294967295
    b112:	bcs.n	b1ec <__udivmoddi4+0x2b8>
    b114:	cmp	r6, r3
    b116:	bls.n	b1ec <__udivmoddi4+0x2b8>
    b118:	subs	r1, #2
    b11a:	add	r3, r7
    b11c:	subs	r3, r3, r6
    b11e:	orr.w	r1, r1, sl, lsl #16
    b122:	b.n	b042 <__udivmoddi4+0x10e>
    b124:	rsb	lr, r1, #32
    b128:	lsr.w	r4, r2, lr
    b12c:	lsls	r3, r1
    b12e:	orrs	r3, r4
    b130:	lsr.w	r7, r0, lr
    b134:	lsl.w	r4, r6, r1
    b138:	mov.w	ip, r3, lsr #16
    b13c:	lsr.w	r6, r6, lr
    b140:	orrs	r4, r7
    b142:	udiv	r9, r6, ip
    b146:	lsrs	r7, r4, #16
    b148:	mls	r6, ip, r9, r6
    b14c:	uxth.w	r8, r3
    b150:	orr.w	r6, r7, r6, lsl #16
    b154:	mul.w	r7, r9, r8
    b158:	cmp	r7, r6
    b15a:	lsl.w	r2, r2, r1
    b15e:	lsl.w	sl, r0, r1
    b162:	bls.n	b176 <__udivmoddi4+0x242>
    b164:	adds	r6, r6, r3
    b166:	add.w	r0, r9, #4294967295
    b16a:	bcs.n	b1f0 <__udivmoddi4+0x2bc>
    b16c:	cmp	r7, r6
    b16e:	bls.n	b1f0 <__udivmoddi4+0x2bc>
    b170:	sub.w	r9, r9, #2
    b174:	add	r6, r3
    b176:	subs	r6, r6, r7
    b178:	uxth	r0, r4
    b17a:	udiv	r4, r6, ip
    b17e:	mls	r6, ip, r4, r6
    b182:	orr.w	r7, r0, r6, lsl #16
    b186:	mul.w	r8, r4, r8
    b18a:	cmp	r8, r7
    b18c:	bls.n	b19e <__udivmoddi4+0x26a>
    b18e:	adds	r7, r7, r3
    b190:	add.w	r0, r4, #4294967295
    b194:	bcs.n	b1e8 <__udivmoddi4+0x2b4>
    b196:	cmp	r8, r7
    b198:	bls.n	b1e8 <__udivmoddi4+0x2b4>
    b19a:	subs	r4, #2
    b19c:	add	r7, r3
    b19e:	orr.w	r0, r4, r9, lsl #16
    b1a2:	rsb	r7, r8, r7
    b1a6:	umull	r8, r9, r0, r2
    b1aa:	cmp	r7, r9
    b1ac:	mov	r4, r8
    b1ae:	mov	r6, r9
    b1b0:	bcc.n	b1dc <__udivmoddi4+0x2a8>
    b1b2:	beq.n	b208 <__udivmoddi4+0x2d4>
    b1b4:	cbz	r5, b210 <__udivmoddi4+0x2dc>
    b1b6:	subs.w	r3, sl, r4
    b1ba:	sbc.w	r7, r7, r6
    b1be:	lsl.w	lr, r7, lr
    b1c2:	lsrs	r3, r1
    b1c4:	lsrs	r7, r1
    b1c6:	orr.w	r3, lr, r3
    b1ca:	stmia.w	r5, {r3, r7}
    b1ce:	movs	r1, #0
    b1d0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b1d4:	mov	r3, r2
    b1d6:	b.n	afca <__udivmoddi4+0x96>
    b1d8:	mov	r0, r2
    b1da:	b.n	af9e <__udivmoddi4+0x6a>
    b1dc:	subs.w	r4, r8, r2
    b1e0:	sbc.w	r6, r9, r3
    b1e4:	subs	r0, #1
    b1e6:	b.n	b1b4 <__udivmoddi4+0x280>
    b1e8:	mov	r4, r0
    b1ea:	b.n	b19e <__udivmoddi4+0x26a>
    b1ec:	mov	r1, r2
    b1ee:	b.n	b11c <__udivmoddi4+0x1e8>
    b1f0:	mov	r9, r0
    b1f2:	b.n	b176 <__udivmoddi4+0x242>
    b1f4:	mov	sl, r1
    b1f6:	b.n	b0f2 <__udivmoddi4+0x1be>
    b1f8:	subs	r3, #2
    b1fa:	add	r4, r7
    b1fc:	b.n	b090 <__udivmoddi4+0x15c>
    b1fe:	mov	r0, r1
    b200:	b.n	b018 <__udivmoddi4+0xe4>
    b202:	subs	r0, #2
    b204:	add	r6, r7
    b206:	b.n	b068 <__udivmoddi4+0x134>
    b208:	cmp	sl, r8
    b20a:	bcc.n	b1dc <__udivmoddi4+0x2a8>
    b20c:	mov	r6, r7
    b20e:	b.n	b1b4 <__udivmoddi4+0x280>
    b210:	mov	r1, r5
    b212:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b216:	nop

0000b218 <__aeabi_idiv0>:
    b218:	bx	lr
    b21a:	nop

0000b21c <__cxa_atexit>:
    b21c:	mov	r3, r2
    b21e:	mov	r2, r1
    b220:	mov	r1, r0
    b222:	movs	r0, #2
    b224:	b.w	f768 <__register_exitproc>

0000b228 <__errno>:
    b228:	ldr	r3, [pc, #4]	; (b230 <__errno+0x8>)
    b22a:	ldr	r0, [r3, #0]
    b22c:	bx	lr
    b22e:	nop
    b230:	.word	0x1fff1848

0000b234 <__libc_init_array>:
    b234:	push	{r4, r5, r6, lr}
    b236:	ldr	r6, [pc, #60]	; (b274 <__libc_init_array+0x40>)
    b238:	ldr	r5, [pc, #60]	; (b278 <__libc_init_array+0x44>)
    b23a:	subs	r6, r6, r5
    b23c:	asrs	r6, r6, #2
    b23e:	it	ne
    b240:	movne	r4, #0
    b242:	beq.n	b250 <__libc_init_array+0x1c>
    b244:	adds	r4, #1
    b246:	ldr.w	r3, [r5], #4
    b24a:	blx	r3
    b24c:	cmp	r6, r4
    b24e:	bne.n	b244 <__libc_init_array+0x10>
    b250:	ldr	r6, [pc, #40]	; (b27c <__libc_init_array+0x48>)
    b252:	ldr	r5, [pc, #44]	; (b280 <__libc_init_array+0x4c>)
    b254:	subs	r6, r6, r5
    b256:	bl	134ec <_init>
    b25a:	asrs	r6, r6, #2
    b25c:	it	ne
    b25e:	movne	r4, #0
    b260:	beq.n	b270 <__libc_init_array+0x3c>
    b262:	adds	r4, #1
    b264:	ldr.w	r3, [r5], #4
    b268:	blx	r3
    b26a:	cmp	r6, r4
    b26c:	bne.n	b262 <__libc_init_array+0x2e>
    b26e:	pop	{r4, r5, r6, pc}
    b270:	pop	{r4, r5, r6, pc}
    b272:	nop
    b274:	.word	0x000134f8
    b278:	.word	0x000134f8
    b27c:	.word	0x00013510
    b280:	.word	0x000134f8

0000b284 <__get_current_locale>:
    b284:	ldr	r2, [pc, #12]	; (b294 <__get_current_locale+0x10>)
    b286:	ldr	r3, [pc, #16]	; (b298 <__get_current_locale+0x14>)
    b288:	ldr	r2, [r2, #0]
    b28a:	ldr	r0, [r2, #52]	; 0x34
    b28c:	cmp	r0, #0
    b28e:	it	eq
    b290:	moveq	r0, r3
    b292:	bx	lr
    b294:	.word	0x1fff1848
    b298:	.word	0x1fff184c

0000b29c <__locale_mb_cur_max>:
    b29c:	ldr	r3, [pc, #16]	; (b2b0 <__locale_mb_cur_max+0x14>)
    b29e:	ldr	r2, [pc, #20]	; (b2b4 <__locale_mb_cur_max+0x18>)
    b2a0:	ldr	r3, [r3, #0]
    b2a2:	ldr	r3, [r3, #52]	; 0x34
    b2a4:	cmp	r3, #0
    b2a6:	it	eq
    b2a8:	moveq	r3, r2
    b2aa:	ldrb.w	r0, [r3, #296]	; 0x128
    b2ae:	bx	lr
    b2b0:	.word	0x1fff1848
    b2b4:	.word	0x1fff184c

0000b2b8 <__locale_ctype_ptr_l>:
    b2b8:	ldr.w	r0, [r0, #236]	; 0xec
    b2bc:	bx	lr
    b2be:	nop

0000b2c0 <__locale_ctype_ptr>:
    b2c0:	push	{r3, lr}
    b2c2:	ldr	r3, [pc, #12]	; (b2d0 <__locale_ctype_ptr+0x10>)
    b2c4:	ldr	r0, [r3, #0]
    b2c6:	bl	b284 <__get_current_locale>
    b2ca:	ldr.w	r0, [r0, #236]	; 0xec
    b2ce:	pop	{r3, pc}
    b2d0:	.word	0x1fff1848

0000b2d4 <malloc>:
    b2d4:	ldr	r3, [pc, #8]	; (b2e0 <malloc+0xc>)
    b2d6:	mov	r1, r0
    b2d8:	ldr	r0, [r3, #0]
    b2da:	b.w	b2f4 <_malloc_r>
    b2de:	nop
    b2e0:	.word	0x1fff1848

0000b2e4 <free>:
    b2e4:	ldr	r3, [pc, #8]	; (b2f0 <free+0xc>)
    b2e6:	mov	r1, r0
    b2e8:	ldr	r0, [r3, #0]
    b2ea:	b.w	10850 <_free_r>
    b2ee:	nop
    b2f0:	.word	0x1fff1848

0000b2f4 <_malloc_r>:
    b2f4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b2f8:	add.w	r5, r1, #11
    b2fc:	cmp	r5, #22
    b2fe:	sub	sp, #12
    b300:	mov	r6, r0
    b302:	bls.w	b444 <_malloc_r+0x150>
    b306:	bics.w	r5, r5, #7
    b30a:	bmi.w	b48c <_malloc_r+0x198>
    b30e:	cmp	r1, r5
    b310:	bhi.w	b48c <_malloc_r+0x198>
    b314:	bl	ba5c <__malloc_lock>
    b318:	cmp.w	r5, #504	; 0x1f8
    b31c:	bcc.w	b858 <_malloc_r+0x564>
    b320:	lsrs	r3, r5, #9
    b322:	beq.w	b49a <_malloc_r+0x1a6>
    b326:	cmp	r3, #4
    b328:	bhi.w	b632 <_malloc_r+0x33e>
    b32c:	lsrs	r0, r5, #6
    b32e:	add.w	lr, r0, #57	; 0x39
    b332:	mov.w	r3, lr, lsl #1
    b336:	adds	r0, #56	; 0x38
    b338:	ldr	r7, [pc, #784]	; (b64c <_malloc_r+0x358>)
    b33a:	add.w	r3, r7, r3, lsl #2
    b33e:	sub.w	r1, r3, #8
    b342:	ldr	r4, [r3, #4]
    b344:	cmp	r1, r4
    b346:	bne.n	b358 <_malloc_r+0x64>
    b348:	b.n	b4a4 <_malloc_r+0x1b0>
    b34a:	cmp	r2, #0
    b34c:	bge.w	b4a8 <_malloc_r+0x1b4>
    b350:	ldr	r4, [r4, #12]
    b352:	cmp	r1, r4
    b354:	beq.w	b4a4 <_malloc_r+0x1b0>
    b358:	ldr	r3, [r4, #4]
    b35a:	bic.w	r3, r3, #3
    b35e:	subs	r2, r3, r5
    b360:	cmp	r2, #15
    b362:	ble.n	b34a <_malloc_r+0x56>
    b364:	ldr	r1, [pc, #740]	; (b64c <_malloc_r+0x358>)
    b366:	ldr	r4, [r7, #16]
    b368:	add.w	lr, r1, #8
    b36c:	cmp	r4, lr
    b36e:	beq.w	b6d8 <_malloc_r+0x3e4>
    b372:	ldr	r3, [r4, #4]
    b374:	bic.w	r3, r3, #3
    b378:	subs	r2, r3, r5
    b37a:	cmp	r2, #15
    b37c:	bgt.w	b6b2 <_malloc_r+0x3be>
    b380:	cmp	r2, #0
    b382:	str.w	lr, [r1, #20]
    b386:	str.w	lr, [r1, #16]
    b38a:	bge.w	b4ca <_malloc_r+0x1d6>
    b38e:	cmp.w	r3, #512	; 0x200
    b392:	bcs.w	b664 <_malloc_r+0x370>
    b396:	lsrs	r3, r3, #3
    b398:	add.w	ip, r3, #1
    b39c:	movs	r2, #1
    b39e:	asrs	r3, r3, #2
    b3a0:	lsl.w	r3, r2, r3
    b3a4:	ldr	r2, [r1, #4]
    b3a6:	ldr.w	r8, [r1, ip, lsl #3]
    b3aa:	str.w	r8, [r4, #8]
    b3ae:	add.w	r9, r1, ip, lsl #3
    b3b2:	orrs	r2, r3
    b3b4:	sub.w	r3, r9, #8
    b3b8:	str	r3, [r4, #12]
    b3ba:	str	r2, [r1, #4]
    b3bc:	str.w	r4, [r1, ip, lsl #3]
    b3c0:	str.w	r4, [r8, #12]
    b3c4:	asrs	r3, r0, #2
    b3c6:	movs	r4, #1
    b3c8:	lsls	r4, r3
    b3ca:	cmp	r4, r2
    b3cc:	bhi.w	b4e4 <_malloc_r+0x1f0>
    b3d0:	tst	r4, r2
    b3d2:	bne.n	b3e2 <_malloc_r+0xee>
    b3d4:	bic.w	r0, r0, #3
    b3d8:	lsls	r4, r4, #1
    b3da:	tst	r4, r2
    b3dc:	add.w	r0, r0, #4
    b3e0:	beq.n	b3d8 <_malloc_r+0xe4>
    b3e2:	add.w	r9, r7, r0, lsl #3
    b3e6:	mov	ip, r9
    b3e8:	mov	r8, r0
    b3ea:	ldr.w	r1, [ip, #12]
    b3ee:	cmp	ip, r1
    b3f0:	bne.n	b402 <_malloc_r+0x10e>
    b3f2:	b.n	b6dc <_malloc_r+0x3e8>
    b3f4:	cmp	r2, #0
    b3f6:	bge.w	b6fc <_malloc_r+0x408>
    b3fa:	ldr	r1, [r1, #12]
    b3fc:	cmp	ip, r1
    b3fe:	beq.w	b6dc <_malloc_r+0x3e8>
    b402:	ldr	r3, [r1, #4]
    b404:	bic.w	r3, r3, #3
    b408:	subs	r2, r3, r5
    b40a:	cmp	r2, #15
    b40c:	ble.n	b3f4 <_malloc_r+0x100>
    b40e:	mov	r4, r1
    b410:	ldr.w	ip, [r1, #12]
    b414:	ldr.w	r8, [r4, #8]!
    b418:	adds	r3, r1, r5
    b41a:	orr.w	r5, r5, #1
    b41e:	str	r5, [r1, #4]
    b420:	orr.w	r1, r2, #1
    b424:	str.w	ip, [r8, #12]
    b428:	mov	r0, r6
    b42a:	str.w	r8, [ip, #8]
    b42e:	str	r3, [r7, #20]
    b430:	str	r3, [r7, #16]
    b432:	str.w	lr, [r3, #12]
    b436:	str.w	lr, [r3, #8]
    b43a:	str	r1, [r3, #4]
    b43c:	str	r2, [r3, r2]
    b43e:	bl	ba60 <__malloc_unlock>
    b442:	b.n	b484 <_malloc_r+0x190>
    b444:	cmp	r1, #16
    b446:	bhi.n	b48c <_malloc_r+0x198>
    b448:	bl	ba5c <__malloc_lock>
    b44c:	movs	r5, #16
    b44e:	movs	r3, #6
    b450:	movs	r0, #2
    b452:	ldr	r7, [pc, #504]	; (b64c <_malloc_r+0x358>)
    b454:	add.w	r3, r7, r3, lsl #2
    b458:	sub.w	r2, r3, #8
    b45c:	ldr	r4, [r3, #4]
    b45e:	cmp	r4, r2
    b460:	beq.w	b6ee <_malloc_r+0x3fa>
    b464:	ldr	r3, [r4, #4]
    b466:	ldr	r1, [r4, #12]
    b468:	ldr	r5, [r4, #8]
    b46a:	bic.w	r3, r3, #3
    b46e:	add	r3, r4
    b470:	mov	r0, r6
    b472:	ldr	r2, [r3, #4]
    b474:	str	r1, [r5, #12]
    b476:	orr.w	r2, r2, #1
    b47a:	str	r5, [r1, #8]
    b47c:	str	r2, [r3, #4]
    b47e:	bl	ba60 <__malloc_unlock>
    b482:	adds	r4, #8
    b484:	mov	r0, r4
    b486:	add	sp, #12
    b488:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b48c:	movs	r4, #0
    b48e:	movs	r3, #12
    b490:	mov	r0, r4
    b492:	str	r3, [r6, #0]
    b494:	add	sp, #12
    b496:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b49a:	movs	r3, #128	; 0x80
    b49c:	mov.w	lr, #64	; 0x40
    b4a0:	movs	r0, #63	; 0x3f
    b4a2:	b.n	b338 <_malloc_r+0x44>
    b4a4:	mov	r0, lr
    b4a6:	b.n	b364 <_malloc_r+0x70>
    b4a8:	add	r3, r4
    b4aa:	ldr	r1, [r4, #12]
    b4ac:	ldr	r2, [r3, #4]
    b4ae:	ldr	r5, [r4, #8]
    b4b0:	orr.w	r2, r2, #1
    b4b4:	str	r1, [r5, #12]
    b4b6:	mov	r0, r6
    b4b8:	str	r5, [r1, #8]
    b4ba:	str	r2, [r3, #4]
    b4bc:	bl	ba60 <__malloc_unlock>
    b4c0:	adds	r4, #8
    b4c2:	mov	r0, r4
    b4c4:	add	sp, #12
    b4c6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b4ca:	add	r3, r4
    b4cc:	mov	r0, r6
    b4ce:	ldr	r2, [r3, #4]
    b4d0:	orr.w	r2, r2, #1
    b4d4:	str	r2, [r3, #4]
    b4d6:	bl	ba60 <__malloc_unlock>
    b4da:	adds	r4, #8
    b4dc:	mov	r0, r4
    b4de:	add	sp, #12
    b4e0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b4e4:	ldr	r4, [r7, #8]
    b4e6:	ldr	r3, [r4, #4]
    b4e8:	bic.w	r8, r3, #3
    b4ec:	cmp	r8, r5
    b4ee:	bcc.n	b4fa <_malloc_r+0x206>
    b4f0:	rsb	r3, r5, r8
    b4f4:	cmp	r3, #15
    b4f6:	bgt.w	b612 <_malloc_r+0x31e>
    b4fa:	ldr	r3, [pc, #340]	; (b650 <_malloc_r+0x35c>)
    b4fc:	ldr.w	r9, [pc, #352]	; b660 <_malloc_r+0x36c>
    b500:	ldr	r2, [r3, #0]
    b502:	ldr.w	r3, [r9]
    b506:	adds	r3, #1
    b508:	add	r2, r5
    b50a:	add.w	sl, r4, r8
    b50e:	beq.w	b7d2 <_malloc_r+0x4de>
    b512:	add.w	r2, r2, #4096	; 0x1000
    b516:	adds	r2, #15
    b518:	bic.w	r2, r2, #4080	; 0xff0
    b51c:	bic.w	r2, r2, #15
    b520:	mov	r1, r2
    b522:	mov	r0, r6
    b524:	str	r2, [sp, #4]
    b526:	bl	be44 <_sbrk_r>
    b52a:	cmp.w	r0, #4294967295
    b52e:	mov	fp, r0
    b530:	ldr	r2, [sp, #4]
    b532:	beq.w	b7e6 <_malloc_r+0x4f2>
    b536:	cmp	sl, r0
    b538:	bhi.w	b734 <_malloc_r+0x440>
    b53c:	ldr	r3, [pc, #276]	; (b654 <_malloc_r+0x360>)
    b53e:	ldr	r1, [r3, #0]
    b540:	cmp	sl, fp
    b542:	add	r1, r2
    b544:	str	r1, [r3, #0]
    b546:	beq.w	b7f0 <_malloc_r+0x4fc>
    b54a:	ldr.w	r0, [r9]
    b54e:	ldr.w	lr, [pc, #272]	; b660 <_malloc_r+0x36c>
    b552:	adds	r0, #1
    b554:	ittet	ne
    b556:	rsbne	sl, sl, fp
    b55a:	addne	r1, sl
    b55c:	streq.w	fp, [lr]
    b560:	strne	r1, [r3, #0]
    b562:	ands.w	r1, fp, #7
    b566:	beq.w	b798 <_malloc_r+0x4a4>
    b56a:	rsb	r0, r1, #8
    b56e:	rsb	r1, r1, #4096	; 0x1000
    b572:	add	fp, r0
    b574:	adds	r1, #8
    b576:	add	r2, fp
    b578:	ubfx	r2, r2, #0, #12
    b57c:	rsb	r9, r2, r1
    b580:	mov	r1, r9
    b582:	mov	r0, r6
    b584:	str	r3, [sp, #4]
    b586:	bl	be44 <_sbrk_r>
    b58a:	adds	r3, r0, #1
    b58c:	ldr	r3, [sp, #4]
    b58e:	beq.w	b810 <_malloc_r+0x51c>
    b592:	rsb	r2, fp, r0
    b596:	add	r2, r9
    b598:	orr.w	r2, r2, #1
    b59c:	ldr	r1, [r3, #0]
    b59e:	str.w	fp, [r7, #8]
    b5a2:	add	r1, r9
    b5a4:	cmp	r4, r7
    b5a6:	str.w	r2, [fp, #4]
    b5aa:	str	r1, [r3, #0]
    b5ac:	ldr.w	r9, [pc, #164]	; b654 <_malloc_r+0x360>
    b5b0:	beq.n	b5e0 <_malloc_r+0x2ec>
    b5b2:	cmp.w	r8, #15
    b5b6:	bls.w	b7b4 <_malloc_r+0x4c0>
    b5ba:	ldr	r2, [r4, #4]
    b5bc:	sub.w	r3, r8, #12
    b5c0:	bic.w	r3, r3, #7
    b5c4:	adds	r0, r4, r3
    b5c6:	and.w	r2, r2, #1
    b5ca:	mov.w	lr, #5
    b5ce:	orrs	r2, r3
    b5d0:	cmp	r3, #15
    b5d2:	str	r2, [r4, #4]
    b5d4:	str.w	lr, [r0, #4]
    b5d8:	str.w	lr, [r0, #8]
    b5dc:	bhi.w	b818 <_malloc_r+0x524>
    b5e0:	ldr	r3, [pc, #116]	; (b658 <_malloc_r+0x364>)
    b5e2:	ldr	r4, [r7, #8]
    b5e4:	ldr	r2, [r3, #0]
    b5e6:	cmp	r1, r2
    b5e8:	it	hi
    b5ea:	strhi	r1, [r3, #0]
    b5ec:	ldr	r3, [pc, #108]	; (b65c <_malloc_r+0x368>)
    b5ee:	ldr	r2, [r3, #0]
    b5f0:	cmp	r1, r2
    b5f2:	ldr	r2, [r4, #4]
    b5f4:	it	hi
    b5f6:	strhi	r1, [r3, #0]
    b5f8:	bic.w	r2, r2, #3
    b5fc:	cmp	r5, r2
    b5fe:	sub.w	r3, r2, r5
    b602:	bhi.n	b608 <_malloc_r+0x314>
    b604:	cmp	r3, #15
    b606:	bgt.n	b612 <_malloc_r+0x31e>
    b608:	mov	r0, r6
    b60a:	bl	ba60 <__malloc_unlock>
    b60e:	movs	r4, #0
    b610:	b.n	b484 <_malloc_r+0x190>
    b612:	adds	r2, r4, r5
    b614:	orr.w	r3, r3, #1
    b618:	orr.w	r5, r5, #1
    b61c:	str	r5, [r4, #4]
    b61e:	mov	r0, r6
    b620:	str	r2, [r7, #8]
    b622:	str	r3, [r2, #4]
    b624:	bl	ba60 <__malloc_unlock>
    b628:	adds	r4, #8
    b62a:	mov	r0, r4
    b62c:	add	sp, #12
    b62e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b632:	cmp	r3, #20
    b634:	bls.n	b71a <_malloc_r+0x426>
    b636:	cmp	r3, #84	; 0x54
    b638:	bhi.w	b784 <_malloc_r+0x490>
    b63c:	lsrs	r0, r5, #12
    b63e:	add.w	lr, r0, #111	; 0x6f
    b642:	mov.w	r3, lr, lsl #1
    b646:	adds	r0, #110	; 0x6e
    b648:	b.n	b338 <_malloc_r+0x44>
    b64a:	nop
    b64c:	.word	0x1fff19b8
    b650:	.word	0x2001d040
    b654:	.word	0x2001d044
    b658:	.word	0x2001d03c
    b65c:	.word	0x2001d038
    b660:	.word	0x1fff1dc4
    b664:	lsrs	r2, r3, #9
    b666:	cmp	r2, #4
    b668:	bls.n	b728 <_malloc_r+0x434>
    b66a:	cmp	r2, #20
    b66c:	bhi.w	b7d6 <_malloc_r+0x4e2>
    b670:	add.w	r1, r2, #92	; 0x5c
    b674:	lsls	r1, r1, #1
    b676:	adds	r2, #91	; 0x5b
    b678:	add.w	ip, r7, r1, lsl #2
    b67c:	ldr.w	r1, [r7, r1, lsl #2]
    b680:	ldr.w	r8, [pc, #476]	; b860 <_malloc_r+0x56c>
    b684:	sub.w	ip, ip, #8
    b688:	cmp	ip, r1
    b68a:	beq.w	b79e <_malloc_r+0x4aa>
    b68e:	ldr	r2, [r1, #4]
    b690:	bic.w	r2, r2, #3
    b694:	cmp	r3, r2
    b696:	bcs.n	b69e <_malloc_r+0x3aa>
    b698:	ldr	r1, [r1, #8]
    b69a:	cmp	ip, r1
    b69c:	bne.n	b68e <_malloc_r+0x39a>
    b69e:	ldr.w	ip, [r1, #12]
    b6a2:	ldr	r2, [r7, #4]
    b6a4:	str.w	ip, [r4, #12]
    b6a8:	str	r1, [r4, #8]
    b6aa:	str.w	r4, [ip, #8]
    b6ae:	str	r4, [r1, #12]
    b6b0:	b.n	b3c4 <_malloc_r+0xd0>
    b6b2:	adds	r3, r4, r5
    b6b4:	orr.w	r7, r2, #1
    b6b8:	orr.w	r5, r5, #1
    b6bc:	str	r5, [r4, #4]
    b6be:	mov	r0, r6
    b6c0:	str	r3, [r1, #20]
    b6c2:	str	r3, [r1, #16]
    b6c4:	str.w	lr, [r3, #12]
    b6c8:	str.w	lr, [r3, #8]
    b6cc:	str	r7, [r3, #4]
    b6ce:	str	r2, [r3, r2]
    b6d0:	adds	r4, #8
    b6d2:	bl	ba60 <__malloc_unlock>
    b6d6:	b.n	b484 <_malloc_r+0x190>
    b6d8:	ldr	r2, [r1, #4]
    b6da:	b.n	b3c4 <_malloc_r+0xd0>
    b6dc:	add.w	r8, r8, #1
    b6e0:	tst.w	r8, #3
    b6e4:	add.w	ip, ip, #8
    b6e8:	bne.w	b3ea <_malloc_r+0xf6>
    b6ec:	b.n	b750 <_malloc_r+0x45c>
    b6ee:	ldr	r4, [r3, #12]
    b6f0:	cmp	r3, r4
    b6f2:	it	eq
    b6f4:	addeq	r0, #2
    b6f6:	beq.w	b364 <_malloc_r+0x70>
    b6fa:	b.n	b464 <_malloc_r+0x170>
    b6fc:	add	r3, r1
    b6fe:	mov	r4, r1
    b700:	ldr	r2, [r3, #4]
    b702:	ldr	r1, [r1, #12]
    b704:	ldr.w	r5, [r4, #8]!
    b708:	orr.w	r2, r2, #1
    b70c:	str	r2, [r3, #4]
    b70e:	mov	r0, r6
    b710:	str	r1, [r5, #12]
    b712:	str	r5, [r1, #8]
    b714:	bl	ba60 <__malloc_unlock>
    b718:	b.n	b484 <_malloc_r+0x190>
    b71a:	add.w	lr, r3, #92	; 0x5c
    b71e:	add.w	r0, r3, #91	; 0x5b
    b722:	mov.w	r3, lr, lsl #1
    b726:	b.n	b338 <_malloc_r+0x44>
    b728:	lsrs	r2, r3, #6
    b72a:	add.w	r1, r2, #57	; 0x39
    b72e:	lsls	r1, r1, #1
    b730:	adds	r2, #56	; 0x38
    b732:	b.n	b678 <_malloc_r+0x384>
    b734:	cmp	r4, r7
    b736:	ldr	r3, [pc, #296]	; (b860 <_malloc_r+0x56c>)
    b738:	beq.w	b53c <_malloc_r+0x248>
    b73c:	ldr	r4, [r3, #8]
    b73e:	ldr	r2, [r4, #4]
    b740:	bic.w	r2, r2, #3
    b744:	b.n	b5fc <_malloc_r+0x308>
    b746:	ldr.w	r3, [r9], #-8
    b74a:	cmp	r9, r3
    b74c:	bne.w	b854 <_malloc_r+0x560>
    b750:	tst.w	r0, #3
    b754:	add.w	r0, r0, #4294967295
    b758:	bne.n	b746 <_malloc_r+0x452>
    b75a:	ldr	r3, [r7, #4]
    b75c:	bic.w	r3, r3, r4
    b760:	str	r3, [r7, #4]
    b762:	lsls	r4, r4, #1
    b764:	cmp	r4, r3
    b766:	bhi.w	b4e4 <_malloc_r+0x1f0>
    b76a:	cmp	r4, #0
    b76c:	beq.w	b4e4 <_malloc_r+0x1f0>
    b770:	tst	r4, r3
    b772:	mov	r0, r8
    b774:	bne.w	b3e2 <_malloc_r+0xee>
    b778:	lsls	r4, r4, #1
    b77a:	tst	r4, r3
    b77c:	add.w	r0, r0, #4
    b780:	beq.n	b778 <_malloc_r+0x484>
    b782:	b.n	b3e2 <_malloc_r+0xee>
    b784:	cmp.w	r3, #340	; 0x154
    b788:	bhi.n	b7bc <_malloc_r+0x4c8>
    b78a:	lsrs	r0, r5, #15
    b78c:	add.w	lr, r0, #120	; 0x78
    b790:	mov.w	r3, lr, lsl #1
    b794:	adds	r0, #119	; 0x77
    b796:	b.n	b338 <_malloc_r+0x44>
    b798:	mov.w	r1, #4096	; 0x1000
    b79c:	b.n	b576 <_malloc_r+0x282>
    b79e:	movs	r1, #1
    b7a0:	ldr.w	r3, [r8, #4]
    b7a4:	asrs	r2, r2, #2
    b7a6:	lsl.w	r2, r1, r2
    b7aa:	orrs	r2, r3
    b7ac:	str.w	r2, [r8, #4]
    b7b0:	mov	r1, ip
    b7b2:	b.n	b6a4 <_malloc_r+0x3b0>
    b7b4:	movs	r3, #1
    b7b6:	str.w	r3, [fp, #4]
    b7ba:	b.n	b608 <_malloc_r+0x314>
    b7bc:	movw	r2, #1364	; 0x554
    b7c0:	cmp	r3, r2
    b7c2:	bhi.n	b806 <_malloc_r+0x512>
    b7c4:	lsrs	r0, r5, #18
    b7c6:	add.w	lr, r0, #125	; 0x7d
    b7ca:	mov.w	r3, lr, lsl #1
    b7ce:	adds	r0, #124	; 0x7c
    b7d0:	b.n	b338 <_malloc_r+0x44>
    b7d2:	adds	r2, #16
    b7d4:	b.n	b520 <_malloc_r+0x22c>
    b7d6:	cmp	r2, #84	; 0x54
    b7d8:	bhi.n	b828 <_malloc_r+0x534>
    b7da:	lsrs	r2, r3, #12
    b7dc:	add.w	r1, r2, #111	; 0x6f
    b7e0:	lsls	r1, r1, #1
    b7e2:	adds	r2, #110	; 0x6e
    b7e4:	b.n	b678 <_malloc_r+0x384>
    b7e6:	ldr	r4, [r7, #8]
    b7e8:	ldr	r2, [r4, #4]
    b7ea:	bic.w	r2, r2, #3
    b7ee:	b.n	b5fc <_malloc_r+0x308>
    b7f0:	ubfx	r0, sl, #0, #12
    b7f4:	cmp	r0, #0
    b7f6:	bne.w	b54a <_malloc_r+0x256>
    b7fa:	add	r2, r8
    b7fc:	ldr	r3, [r7, #8]
    b7fe:	orr.w	r2, r2, #1
    b802:	str	r2, [r3, #4]
    b804:	b.n	b5e0 <_malloc_r+0x2ec>
    b806:	movs	r3, #254	; 0xfe
    b808:	mov.w	lr, #127	; 0x7f
    b80c:	movs	r0, #126	; 0x7e
    b80e:	b.n	b338 <_malloc_r+0x44>
    b810:	movs	r2, #1
    b812:	mov.w	r9, #0
    b816:	b.n	b59c <_malloc_r+0x2a8>
    b818:	add.w	r1, r4, #8
    b81c:	mov	r0, r6
    b81e:	bl	10850 <_free_r>
    b822:	ldr.w	r1, [r9]
    b826:	b.n	b5e0 <_malloc_r+0x2ec>
    b828:	cmp.w	r2, #340	; 0x154
    b82c:	bhi.n	b83a <_malloc_r+0x546>
    b82e:	lsrs	r2, r3, #15
    b830:	add.w	r1, r2, #120	; 0x78
    b834:	lsls	r1, r1, #1
    b836:	adds	r2, #119	; 0x77
    b838:	b.n	b678 <_malloc_r+0x384>
    b83a:	movw	r1, #1364	; 0x554
    b83e:	cmp	r2, r1
    b840:	bhi.n	b84e <_malloc_r+0x55a>
    b842:	lsrs	r2, r3, #18
    b844:	add.w	r1, r2, #125	; 0x7d
    b848:	lsls	r1, r1, #1
    b84a:	adds	r2, #124	; 0x7c
    b84c:	b.n	b678 <_malloc_r+0x384>
    b84e:	movs	r1, #254	; 0xfe
    b850:	movs	r2, #126	; 0x7e
    b852:	b.n	b678 <_malloc_r+0x384>
    b854:	ldr	r3, [r7, #4]
    b856:	b.n	b762 <_malloc_r+0x46e>
    b858:	lsrs	r0, r5, #3
    b85a:	adds	r3, r0, #1
    b85c:	lsls	r3, r3, #1
    b85e:	b.n	b452 <_malloc_r+0x15e>
    b860:	.word	0x1fff19b8

0000b864 <__ascii_mbtowc>:
    b864:	sub	sp, #8
    b866:	cbz	r1, b87c <__ascii_mbtowc+0x18>
    b868:	cbz	r2, b882 <__ascii_mbtowc+0x1e>
    b86a:	cbz	r3, b888 <__ascii_mbtowc+0x24>
    b86c:	ldrb	r3, [r2, #0]
    b86e:	str	r3, [r1, #0]
    b870:	ldrb	r2, [r2, #0]
    b872:	adds	r0, r2, #0
    b874:	it	ne
    b876:	movne	r0, #1
    b878:	add	sp, #8
    b87a:	bx	lr
    b87c:	add	r1, sp, #4
    b87e:	cmp	r2, #0
    b880:	bne.n	b86a <__ascii_mbtowc+0x6>
    b882:	mov	r0, r2
    b884:	add	sp, #8
    b886:	bx	lr
    b888:	mvn.w	r0, #1
    b88c:	b.n	b878 <__ascii_mbtowc+0x14>
    b88e:	nop

0000b890 <memchr>:
    b890:	and.w	r1, r1, #255	; 0xff
    b894:	cmp	r2, #16
    b896:	blt.n	b8f0 <memchr+0x60>
    b898:	tst.w	r0, #7
    b89c:	beq.n	b8b0 <memchr+0x20>
    b89e:	ldrb.w	r3, [r0], #1
    b8a2:	subs	r2, #1
    b8a4:	cmp	r3, r1
    b8a6:	beq.n	b904 <memchr+0x74>
    b8a8:	tst.w	r0, #7
    b8ac:	cbz	r2, b900 <memchr+0x70>
    b8ae:	bne.n	b89e <memchr+0xe>
    b8b0:	push	{r4, r5, r6, r7}
    b8b2:	orr.w	r1, r1, r1, lsl #8
    b8b6:	orr.w	r1, r1, r1, lsl #16
    b8ba:	bic.w	r4, r2, #7
    b8be:	mvns.w	r7, #0
    b8c2:	movs	r3, #0
    b8c4:	ldrd	r5, r6, [r0], #8
    b8c8:	subs	r4, #8
    b8ca:	eor.w	r5, r5, r1
    b8ce:	eor.w	r6, r6, r1
    b8d2:	uadd8	r5, r5, r7
    b8d6:	sel	r5, r3, r7
    b8da:	uadd8	r6, r6, r7
    b8de:	sel	r6, r5, r7
    b8e2:	cbnz	r6, b908 <memchr+0x78>
    b8e4:	bne.n	b8c4 <memchr+0x34>
    b8e6:	pop	{r4, r5, r6, r7}
    b8e8:	and.w	r1, r1, #255	; 0xff
    b8ec:	and.w	r2, r2, #7
    b8f0:	cbz	r2, b900 <memchr+0x70>
    b8f2:	ldrb.w	r3, [r0], #1
    b8f6:	subs	r2, #1
    b8f8:	eor.w	r3, r3, r1
    b8fc:	cbz	r3, b904 <memchr+0x74>
    b8fe:	bne.n	b8f2 <memchr+0x62>
    b900:	movs	r0, #0
    b902:	bx	lr
    b904:	subs	r0, #1
    b906:	bx	lr
    b908:	cmp	r5, #0
    b90a:	itte	eq
    b90c:	moveq	r5, r6
    b90e:	subeq	r0, #3
    b910:	subne	r0, #7
    b912:	tst.w	r5, #1
    b916:	bne.n	b928 <memchr+0x98>
    b918:	adds	r0, #1
    b91a:	tst.w	r5, #256	; 0x100
    b91e:	ittt	eq
    b920:	addeq	r0, #1
    b922:	tsteq.w	r5, #98304	; 0x18000
    b926:	addeq	r0, #1
    b928:	pop	{r4, r5, r6, r7}
    b92a:	subs	r0, #1
    b92c:	bx	lr
    b92e:	nop

0000b930 <memcmp>:
    b930:	cmp	r2, #3
    b932:	push	{r4, r5, r6}
    b934:	bls.n	b984 <memcmp+0x54>
    b936:	orr.w	r3, r0, r1
    b93a:	lsls	r3, r3, #30
    b93c:	beq.n	b962 <memcmp+0x32>
    b93e:	ldrb	r4, [r0, #0]
    b940:	ldrb	r5, [r1, #0]
    b942:	cmp	r4, r5
    b944:	bne.n	b98c <memcmp+0x5c>
    b946:	add	r2, r0
    b948:	adds	r3, r0, #1
    b94a:	b.n	b958 <memcmp+0x28>
    b94c:	ldrb.w	r4, [r3], #1
    b950:	ldrb.w	r5, [r1, #1]!
    b954:	cmp	r4, r5
    b956:	bne.n	b98c <memcmp+0x5c>
    b958:	cmp	r3, r2
    b95a:	bne.n	b94c <memcmp+0x1c>
    b95c:	movs	r0, #0
    b95e:	pop	{r4, r5, r6}
    b960:	bx	lr
    b962:	mov	r4, r1
    b964:	mov	r3, r0
    b966:	ldr	r6, [r3, #0]
    b968:	ldr	r5, [r4, #0]
    b96a:	cmp	r6, r5
    b96c:	mov	r0, r3
    b96e:	mov	r1, r4
    b970:	add.w	r3, r3, #4
    b974:	add.w	r4, r4, #4
    b978:	bne.n	b93e <memcmp+0xe>
    b97a:	subs	r2, #4
    b97c:	cmp	r2, #3
    b97e:	mov	r0, r3
    b980:	mov	r1, r4
    b982:	bhi.n	b966 <memcmp+0x36>
    b984:	cmp	r2, #0
    b986:	bne.n	b93e <memcmp+0xe>
    b988:	mov	r0, r2
    b98a:	b.n	b95e <memcmp+0x2e>
    b98c:	subs	r0, r4, r5
    b98e:	pop	{r4, r5, r6}
    b990:	bx	lr
    b992:	nop

0000b994 <memmove>:
    b994:	cmp	r0, r1
    b996:	push	{r4, r5, r6, r7, lr}
    b998:	bls.n	b9b6 <memmove+0x22>
    b99a:	adds	r3, r1, r2
    b99c:	cmp	r0, r3
    b99e:	bcs.n	b9b6 <memmove+0x22>
    b9a0:	adds	r1, r0, r2
    b9a2:	cmp	r2, #0
    b9a4:	beq.n	ba4a <memmove+0xb6>
    b9a6:	subs	r2, r3, r2
    b9a8:	ldrb.w	r4, [r3, #-1]!
    b9ac:	strb.w	r4, [r1, #-1]!
    b9b0:	cmp	r3, r2
    b9b2:	bne.n	b9a8 <memmove+0x14>
    b9b4:	pop	{r4, r5, r6, r7, pc}
    b9b6:	cmp	r2, #15
    b9b8:	bls.n	ba4c <memmove+0xb8>
    b9ba:	orr.w	r3, r1, r0
    b9be:	lsls	r3, r3, #30
    b9c0:	bne.n	ba50 <memmove+0xbc>
    b9c2:	add.w	r4, r0, #16
    b9c6:	add.w	r3, r1, #16
    b9ca:	mov	r5, r2
    b9cc:	ldr.w	r6, [r3, #-16]
    b9d0:	str.w	r6, [r4, #-16]
    b9d4:	ldr.w	r6, [r3, #-12]
    b9d8:	str.w	r6, [r4, #-12]
    b9dc:	ldr.w	r6, [r3, #-8]
    b9e0:	str.w	r6, [r4, #-8]
    b9e4:	subs	r5, #16
    b9e6:	ldr.w	r6, [r3, #-4]
    b9ea:	str.w	r6, [r4, #-4]
    b9ee:	cmp	r5, #15
    b9f0:	add.w	r3, r3, #16
    b9f4:	add.w	r4, r4, #16
    b9f8:	bhi.n	b9cc <memmove+0x38>
    b9fa:	sub.w	r3, r2, #16
    b9fe:	bic.w	r3, r3, #15
    ba02:	and.w	lr, r2, #15
    ba06:	adds	r3, #16
    ba08:	cmp.w	lr, #3
    ba0c:	add	r1, r3
    ba0e:	add	r3, r0
    ba10:	bls.n	ba56 <memmove+0xc2>
    ba12:	subs	r6, r3, #4
    ba14:	mov	r5, r1
    ba16:	mov	r4, lr
    ba18:	subs	r4, #4
    ba1a:	ldr.w	r7, [r5], #4
    ba1e:	str.w	r7, [r6, #4]!
    ba22:	cmp	r4, #3
    ba24:	bhi.n	ba18 <memmove+0x84>
    ba26:	sub.w	r4, lr, #4
    ba2a:	bic.w	r4, r4, #3
    ba2e:	adds	r4, #4
    ba30:	add	r3, r4
    ba32:	add	r1, r4
    ba34:	and.w	r2, r2, #3
    ba38:	cbz	r2, ba54 <memmove+0xc0>
    ba3a:	subs	r3, #1
    ba3c:	add	r2, r1
    ba3e:	ldrb.w	r4, [r1], #1
    ba42:	strb.w	r4, [r3, #1]!
    ba46:	cmp	r2, r1
    ba48:	bne.n	ba3e <memmove+0xaa>
    ba4a:	pop	{r4, r5, r6, r7, pc}
    ba4c:	mov	r3, r0
    ba4e:	b.n	ba38 <memmove+0xa4>
    ba50:	mov	r3, r0
    ba52:	b.n	ba3a <memmove+0xa6>
    ba54:	pop	{r4, r5, r6, r7, pc}
    ba56:	mov	r2, lr
    ba58:	b.n	ba38 <memmove+0xa4>
    ba5a:	nop

0000ba5c <__malloc_lock>:
    ba5c:	bx	lr
    ba5e:	nop

0000ba60 <__malloc_unlock>:
    ba60:	bx	lr
    ba62:	nop

0000ba64 <_realloc_r>:
    ba64:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ba68:	mov	r7, r2
    ba6a:	sub	sp, #12
    ba6c:	cmp	r1, #0
    ba6e:	beq.w	bbf4 <_realloc_r+0x190>
    ba72:	mov	r6, r1
    ba74:	mov	r9, r0
    ba76:	add.w	r5, r7, #11
    ba7a:	bl	ba5c <__malloc_lock>
    ba7e:	ldr.w	lr, [r6, #-4]
    ba82:	cmp	r5, #22
    ba84:	bic.w	r4, lr, #3
    ba88:	sub.w	r8, r6, #8
    ba8c:	bhi.n	bb10 <_realloc_r+0xac>
    ba8e:	movs	r2, #16
    ba90:	mov	r5, r2
    ba92:	cmp	r7, r5
    ba94:	bhi.n	bb1a <_realloc_r+0xb6>
    ba96:	cmp	r4, r2
    ba98:	bge.n	bb86 <_realloc_r+0x122>
    ba9a:	ldr	r3, [pc, #804]	; (bdc0 <_realloc_r+0x35c>)
    ba9c:	ldr	r1, [r3, #8]
    ba9e:	add.w	r0, r8, r4
    baa2:	cmp	r0, r1
    baa4:	ldr	r1, [r0, #4]
    baa6:	beq.w	bc5c <_realloc_r+0x1f8>
    baaa:	bic.w	r3, r1, #1
    baae:	add	r3, r0
    bab0:	ldr	r3, [r3, #4]
    bab2:	lsls	r3, r3, #31
    bab4:	bpl.n	bbb2 <_realloc_r+0x14e>
    bab6:	tst.w	lr, #1
    baba:	beq.n	bb28 <_realloc_r+0xc4>
    babc:	mov	r1, r7
    babe:	mov	r0, r9
    bac0:	bl	b2f4 <_malloc_r>
    bac4:	mov	r7, r0
    bac6:	cbz	r0, bb02 <_realloc_r+0x9e>
    bac8:	ldr.w	r3, [r6, #-4]
    bacc:	bic.w	r3, r3, #1
    bad0:	add	r3, r8
    bad2:	sub.w	r2, r0, #8
    bad6:	cmp	r2, r3
    bad8:	beq.w	bd64 <_realloc_r+0x300>
    badc:	subs	r2, r4, #4
    bade:	cmp	r2, #36	; 0x24
    bae0:	bhi.w	bd46 <_realloc_r+0x2e2>
    bae4:	cmp	r2, #19
    bae6:	bhi.w	bcf2 <_realloc_r+0x28e>
    baea:	mov	r3, r0
    baec:	mov	r2, r6
    baee:	ldr	r1, [r2, #0]
    baf0:	str	r1, [r3, #0]
    baf2:	ldr	r1, [r2, #4]
    baf4:	str	r1, [r3, #4]
    baf6:	ldr	r2, [r2, #8]
    baf8:	str	r2, [r3, #8]
    bafa:	mov	r1, r6
    bafc:	mov	r0, r9
    bafe:	bl	10850 <_free_r>
    bb02:	mov	r0, r9
    bb04:	bl	ba60 <__malloc_unlock>
    bb08:	mov	r0, r7
    bb0a:	add	sp, #12
    bb0c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bb10:	bic.w	r5, r5, #7
    bb14:	cmp	r5, #0
    bb16:	mov	r2, r5
    bb18:	bge.n	ba92 <_realloc_r+0x2e>
    bb1a:	movs	r3, #12
    bb1c:	movs	r0, #0
    bb1e:	str.w	r3, [r9]
    bb22:	add	sp, #12
    bb24:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bb28:	ldr.w	r3, [r6, #-8]
    bb2c:	rsb	sl, r3, r8
    bb30:	ldr.w	r3, [sl, #4]
    bb34:	bic.w	ip, r3, #3
    bb38:	add.w	r3, r4, ip
    bb3c:	cmp	r3, r2
    bb3e:	blt.n	babc <_realloc_r+0x58>
    bb40:	mov	r7, sl
    bb42:	ldr.w	r1, [sl, #12]
    bb46:	ldr.w	r0, [r7, #8]!
    bb4a:	subs	r2, r4, #4
    bb4c:	cmp	r2, #36	; 0x24
    bb4e:	str	r1, [r0, #12]
    bb50:	str	r0, [r1, #8]
    bb52:	bhi.w	bd84 <_realloc_r+0x320>
    bb56:	cmp	r2, #19
    bb58:	bls.w	bd80 <_realloc_r+0x31c>
    bb5c:	ldr	r1, [r6, #0]
    bb5e:	str.w	r1, [sl, #8]
    bb62:	ldr	r1, [r6, #4]
    bb64:	str.w	r1, [sl, #12]
    bb68:	cmp	r2, #27
    bb6a:	bhi.w	bdc4 <_realloc_r+0x360>
    bb6e:	adds	r6, #8
    bb70:	add.w	r2, sl, #16
    bb74:	ldr	r1, [r6, #0]
    bb76:	str	r1, [r2, #0]
    bb78:	ldr	r1, [r6, #4]
    bb7a:	str	r1, [r2, #4]
    bb7c:	ldr	r1, [r6, #8]
    bb7e:	str	r1, [r2, #8]
    bb80:	mov	r6, r7
    bb82:	mov	r4, r3
    bb84:	mov	r8, sl
    bb86:	subs	r3, r4, r5
    bb88:	cmp	r3, #15
    bb8a:	bhi.n	bbc8 <_realloc_r+0x164>
    bb8c:	ldr.w	r3, [r8, #4]
    bb90:	and.w	r3, r3, #1
    bb94:	orrs	r3, r4
    bb96:	add	r4, r8
    bb98:	str.w	r3, [r8, #4]
    bb9c:	ldr	r3, [r4, #4]
    bb9e:	orr.w	r3, r3, #1
    bba2:	str	r3, [r4, #4]
    bba4:	mov	r0, r9
    bba6:	bl	ba60 <__malloc_unlock>
    bbaa:	mov	r0, r6
    bbac:	add	sp, #12
    bbae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bbb2:	bic.w	r1, r1, #3
    bbb6:	add	r1, r4
    bbb8:	cmp	r1, r2
    bbba:	blt.n	bc00 <_realloc_r+0x19c>
    bbbc:	ldr	r3, [r0, #12]
    bbbe:	ldr	r2, [r0, #8]
    bbc0:	mov	r4, r1
    bbc2:	str	r3, [r2, #12]
    bbc4:	str	r2, [r3, #8]
    bbc6:	b.n	bb86 <_realloc_r+0x122>
    bbc8:	ldr.w	r2, [r8, #4]
    bbcc:	add.w	r1, r8, r5
    bbd0:	and.w	r2, r2, #1
    bbd4:	orrs	r5, r2
    bbd6:	orr.w	r2, r3, #1
    bbda:	add	r3, r1
    bbdc:	str.w	r5, [r8, #4]
    bbe0:	str	r2, [r1, #4]
    bbe2:	ldr	r2, [r3, #4]
    bbe4:	orr.w	r2, r2, #1
    bbe8:	adds	r1, #8
    bbea:	str	r2, [r3, #4]
    bbec:	mov	r0, r9
    bbee:	bl	10850 <_free_r>
    bbf2:	b.n	bba4 <_realloc_r+0x140>
    bbf4:	mov	r1, r2
    bbf6:	add	sp, #12
    bbf8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bbfc:	b.w	b2f4 <_malloc_r>
    bc00:	tst.w	lr, #1
    bc04:	bne.w	babc <_realloc_r+0x58>
    bc08:	ldr.w	r3, [r6, #-8]
    bc0c:	rsb	sl, r3, r8
    bc10:	ldr.w	r3, [sl, #4]
    bc14:	bic.w	ip, r3, #3
    bc18:	add.w	lr, r1, ip
    bc1c:	cmp	lr, r2
    bc1e:	blt.n	bb38 <_realloc_r+0xd4>
    bc20:	ldr	r3, [r0, #12]
    bc22:	ldr	r2, [r0, #8]
    bc24:	mov	r7, sl
    bc26:	str	r3, [r2, #12]
    bc28:	str	r2, [r3, #8]
    bc2a:	ldr.w	r1, [r7, #8]!
    bc2e:	ldr.w	r3, [sl, #12]
    bc32:	str	r3, [r1, #12]
    bc34:	subs	r2, r4, #4
    bc36:	cmp	r2, #36	; 0x24
    bc38:	str	r1, [r3, #8]
    bc3a:	bhi.w	bd70 <_realloc_r+0x30c>
    bc3e:	cmp	r2, #19
    bc40:	bls.n	bd08 <_realloc_r+0x2a4>
    bc42:	ldr	r3, [r6, #0]
    bc44:	str.w	r3, [sl, #8]
    bc48:	ldr	r3, [r6, #4]
    bc4a:	str.w	r3, [sl, #12]
    bc4e:	cmp	r2, #27
    bc50:	bhi.w	bd94 <_realloc_r+0x330>
    bc54:	adds	r6, #8
    bc56:	add.w	r3, sl, #16
    bc5a:	b.n	bd0a <_realloc_r+0x2a6>
    bc5c:	bic.w	fp, r1, #3
    bc60:	add	fp, r4
    bc62:	add.w	r0, r5, #16
    bc66:	cmp	fp, r0
    bc68:	bge.n	bd1e <_realloc_r+0x2ba>
    bc6a:	tst.w	lr, #1
    bc6e:	bne.w	babc <_realloc_r+0x58>
    bc72:	ldr.w	r1, [r6, #-8]
    bc76:	rsb	sl, r1, r8
    bc7a:	ldr.w	r1, [sl, #4]
    bc7e:	bic.w	ip, r1, #3
    bc82:	add	fp, ip
    bc84:	cmp	r0, fp
    bc86:	bgt.w	bb38 <_realloc_r+0xd4>
    bc8a:	mov	r7, sl
    bc8c:	ldr.w	r1, [sl, #12]
    bc90:	ldr.w	r0, [r7, #8]!
    bc94:	subs	r2, r4, #4
    bc96:	cmp	r2, #36	; 0x24
    bc98:	str	r1, [r0, #12]
    bc9a:	str	r0, [r1, #8]
    bc9c:	bhi.w	be08 <_realloc_r+0x3a4>
    bca0:	cmp	r2, #19
    bca2:	bls.w	bdf0 <_realloc_r+0x38c>
    bca6:	ldr	r1, [r6, #0]
    bca8:	str.w	r1, [sl, #8]
    bcac:	ldr	r1, [r6, #4]
    bcae:	str.w	r1, [sl, #12]
    bcb2:	cmp	r2, #27
    bcb4:	bhi.w	be16 <_realloc_r+0x3b2>
    bcb8:	adds	r6, #8
    bcba:	add.w	r2, sl, #16
    bcbe:	ldr	r1, [r6, #0]
    bcc0:	str	r1, [r2, #0]
    bcc2:	ldr	r1, [r6, #4]
    bcc4:	str	r1, [r2, #4]
    bcc6:	ldr	r1, [r6, #8]
    bcc8:	str	r1, [r2, #8]
    bcca:	add.w	r1, sl, r5
    bcce:	rsb	r2, r5, fp
    bcd2:	orr.w	r2, r2, #1
    bcd6:	str	r1, [r3, #8]
    bcd8:	str	r2, [r1, #4]
    bcda:	ldr.w	r3, [sl, #4]
    bcde:	and.w	r3, r3, #1
    bce2:	orrs	r5, r3
    bce4:	mov	r0, r9
    bce6:	str.w	r5, [sl, #4]
    bcea:	bl	ba60 <__malloc_unlock>
    bcee:	mov	r0, r7
    bcf0:	b.n	bbac <_realloc_r+0x148>
    bcf2:	ldr	r3, [r6, #0]
    bcf4:	str	r3, [r0, #0]
    bcf6:	ldr	r3, [r6, #4]
    bcf8:	str	r3, [r0, #4]
    bcfa:	cmp	r2, #27
    bcfc:	bhi.n	bd4e <_realloc_r+0x2ea>
    bcfe:	add.w	r3, r0, #8
    bd02:	add.w	r2, r6, #8
    bd06:	b.n	baee <_realloc_r+0x8a>
    bd08:	mov	r3, r7
    bd0a:	ldr	r2, [r6, #0]
    bd0c:	str	r2, [r3, #0]
    bd0e:	ldr	r2, [r6, #4]
    bd10:	str	r2, [r3, #4]
    bd12:	ldr	r2, [r6, #8]
    bd14:	str	r2, [r3, #8]
    bd16:	mov	r6, r7
    bd18:	mov	r4, lr
    bd1a:	mov	r8, sl
    bd1c:	b.n	bb86 <_realloc_r+0x122>
    bd1e:	add.w	r1, r8, r5
    bd22:	rsb	fp, r5, fp
    bd26:	orr.w	r2, fp, #1
    bd2a:	str	r1, [r3, #8]
    bd2c:	str	r2, [r1, #4]
    bd2e:	ldr.w	r3, [r6, #-4]
    bd32:	and.w	r3, r3, #1
    bd36:	orrs	r5, r3
    bd38:	mov	r0, r9
    bd3a:	str.w	r5, [r6, #-4]
    bd3e:	bl	ba60 <__malloc_unlock>
    bd42:	mov	r0, r6
    bd44:	b.n	bbac <_realloc_r+0x148>
    bd46:	mov	r1, r6
    bd48:	bl	b994 <memmove>
    bd4c:	b.n	bafa <_realloc_r+0x96>
    bd4e:	ldr	r3, [r6, #8]
    bd50:	str	r3, [r0, #8]
    bd52:	ldr	r3, [r6, #12]
    bd54:	str	r3, [r0, #12]
    bd56:	cmp	r2, #36	; 0x24
    bd58:	beq.n	bdac <_realloc_r+0x348>
    bd5a:	add.w	r3, r0, #16
    bd5e:	add.w	r2, r6, #16
    bd62:	b.n	baee <_realloc_r+0x8a>
    bd64:	ldr.w	r3, [r0, #-4]
    bd68:	bic.w	r3, r3, #3
    bd6c:	add	r4, r3
    bd6e:	b.n	bb86 <_realloc_r+0x122>
    bd70:	mov	r1, r6
    bd72:	mov	r0, r7
    bd74:	mov	r4, lr
    bd76:	mov	r8, sl
    bd78:	bl	b994 <memmove>
    bd7c:	mov	r6, r7
    bd7e:	b.n	bb86 <_realloc_r+0x122>
    bd80:	mov	r2, r7
    bd82:	b.n	bb74 <_realloc_r+0x110>
    bd84:	mov	r1, r6
    bd86:	mov	r0, r7
    bd88:	mov	r4, r3
    bd8a:	mov	r8, sl
    bd8c:	bl	b994 <memmove>
    bd90:	mov	r6, r7
    bd92:	b.n	bb86 <_realloc_r+0x122>
    bd94:	ldr	r3, [r6, #8]
    bd96:	str.w	r3, [sl, #16]
    bd9a:	ldr	r3, [r6, #12]
    bd9c:	str.w	r3, [sl, #20]
    bda0:	cmp	r2, #36	; 0x24
    bda2:	beq.n	bddc <_realloc_r+0x378>
    bda4:	adds	r6, #16
    bda6:	add.w	r3, sl, #24
    bdaa:	b.n	bd0a <_realloc_r+0x2a6>
    bdac:	ldr	r3, [r6, #16]
    bdae:	str	r3, [r0, #16]
    bdb0:	ldr	r3, [r6, #20]
    bdb2:	str	r3, [r0, #20]
    bdb4:	add.w	r2, r6, #24
    bdb8:	add.w	r3, r0, #24
    bdbc:	b.n	baee <_realloc_r+0x8a>
    bdbe:	nop
    bdc0:	.word	0x1fff19b8
    bdc4:	ldr	r1, [r6, #8]
    bdc6:	str.w	r1, [sl, #16]
    bdca:	ldr	r1, [r6, #12]
    bdcc:	str.w	r1, [sl, #20]
    bdd0:	cmp	r2, #36	; 0x24
    bdd2:	beq.n	bdf4 <_realloc_r+0x390>
    bdd4:	adds	r6, #16
    bdd6:	add.w	r2, sl, #24
    bdda:	b.n	bb74 <_realloc_r+0x110>
    bddc:	ldr	r3, [r6, #16]
    bdde:	str.w	r3, [sl, #24]
    bde2:	ldr	r3, [r6, #20]
    bde4:	str.w	r3, [sl, #28]
    bde8:	adds	r6, #24
    bdea:	add.w	r3, sl, #32
    bdee:	b.n	bd0a <_realloc_r+0x2a6>
    bdf0:	mov	r2, r7
    bdf2:	b.n	bcbe <_realloc_r+0x25a>
    bdf4:	ldr	r2, [r6, #16]
    bdf6:	str.w	r2, [sl, #24]
    bdfa:	ldr	r2, [r6, #20]
    bdfc:	str.w	r2, [sl, #28]
    be00:	adds	r6, #24
    be02:	add.w	r2, sl, #32
    be06:	b.n	bb74 <_realloc_r+0x110>
    be08:	mov	r1, r6
    be0a:	mov	r0, r7
    be0c:	str	r3, [sp, #4]
    be0e:	bl	b994 <memmove>
    be12:	ldr	r3, [sp, #4]
    be14:	b.n	bcca <_realloc_r+0x266>
    be16:	ldr	r1, [r6, #8]
    be18:	str.w	r1, [sl, #16]
    be1c:	ldr	r1, [r6, #12]
    be1e:	str.w	r1, [sl, #20]
    be22:	cmp	r2, #36	; 0x24
    be24:	beq.n	be2e <_realloc_r+0x3ca>
    be26:	adds	r6, #16
    be28:	add.w	r2, sl, #24
    be2c:	b.n	bcbe <_realloc_r+0x25a>
    be2e:	ldr	r2, [r6, #16]
    be30:	str.w	r2, [sl, #24]
    be34:	ldr	r2, [r6, #20]
    be36:	str.w	r2, [sl, #28]
    be3a:	adds	r6, #24
    be3c:	add.w	r2, sl, #32
    be40:	b.n	bcbe <_realloc_r+0x25a>
    be42:	nop

0000be44 <_sbrk_r>:
    be44:	push	{r3, r4, r5, lr}
    be46:	ldr	r4, [pc, #28]	; (be64 <_sbrk_r+0x20>)
    be48:	movs	r3, #0
    be4a:	mov	r5, r0
    be4c:	mov	r0, r1
    be4e:	str	r3, [r4, #0]
    be50:	bl	93bc <_sbrk>
    be54:	adds	r3, r0, #1
    be56:	beq.n	be5a <_sbrk_r+0x16>
    be58:	pop	{r3, r4, r5, pc}
    be5a:	ldr	r3, [r4, #0]
    be5c:	cmp	r3, #0
    be5e:	beq.n	be58 <_sbrk_r+0x14>
    be60:	str	r3, [r5, #0]
    be62:	pop	{r3, r4, r5, pc}
    be64:	.word	0x2001d080

0000be68 <sprintf>:
    be68:	push	{r1, r2, r3}
    be6a:	push	{r4, r5, r6, r7, lr}
    be6c:	sub	sp, #112	; 0x70
    be6e:	add	r3, sp, #132	; 0x84
    be70:	ldr	r1, [pc, #60]	; (beb0 <sprintf+0x48>)
    be72:	ldr.w	r2, [r3], #4
    be76:	str	r3, [sp, #4]
    be78:	mov	r5, r0
    be7a:	mvn.w	r4, #2147483648	; 0x80000000
    be7e:	ldr	r0, [r1, #0]
    be80:	str	r5, [sp, #8]
    be82:	mov.w	r7, #520	; 0x208
    be86:	movw	r6, #65535	; 0xffff
    be8a:	add	r1, sp, #8
    be8c:	str	r5, [sp, #24]
    be8e:	strh.w	r7, [sp, #20]
    be92:	str	r4, [sp, #16]
    be94:	str	r4, [sp, #28]
    be96:	strh.w	r6, [sp, #22]
    be9a:	bl	d150 <_svfprintf_r>
    be9e:	ldr	r3, [sp, #8]
    bea0:	movs	r2, #0
    bea2:	strb	r2, [r3, #0]
    bea4:	add	sp, #112	; 0x70
    bea6:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    beaa:	add	sp, #12
    beac:	bx	lr
    beae:	nop
    beb0:	.word	0x1fff1848

0000beb4 <sscanf>:
    beb4:	push	{r1, r2, r3}
    beb6:	push	{r4, r5, r6, r7, lr}
    beb8:	sub	sp, #112	; 0x70
    beba:	add	r4, sp, #132	; 0x84
    bebc:	mov.w	r2, #516	; 0x204
    bec0:	ldr.w	r6, [r4], #4
    bec4:	strh.w	r2, [sp, #20]
    bec8:	str	r0, [sp, #8]
    beca:	str	r0, [sp, #24]
    becc:	bl	bf40 <strlen>
    bed0:	ldr	r3, [pc, #48]	; (bf04 <sscanf+0x50>)
    bed2:	str	r4, [sp, #4]
    bed4:	mov	r5, r0
    bed6:	mov	r2, r6
    bed8:	ldr	r7, [pc, #44]	; (bf08 <sscanf+0x54>)
    beda:	ldr	r0, [r3, #0]
    bedc:	str	r5, [sp, #12]
    bede:	mov	r3, r4
    bee0:	movw	r6, #65535	; 0xffff
    bee4:	movs	r4, #0
    bee6:	add	r1, sp, #8
    bee8:	str	r5, [sp, #28]
    beea:	str	r7, [sp, #40]	; 0x28
    beec:	str	r4, [sp, #56]	; 0x38
    beee:	str	r4, [sp, #76]	; 0x4c
    bef0:	strh.w	r6, [sp, #22]
    bef4:	bl	e834 <__ssvfscanf_r>
    bef8:	add	sp, #112	; 0x70
    befa:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    befe:	add	sp, #12
    bf00:	bx	lr
    bf02:	nop
    bf04:	.word	0x1fff1848
    bf08:	.word	0x0000bf0d

0000bf0c <__seofread>:
    bf0c:	movs	r0, #0
    bf0e:	bx	lr
    bf10:			; <UNDEFINED> instruction: 0xffffffff
    bf14:			; <UNDEFINED> instruction: 0xffffffff
    bf18:			; <UNDEFINED> instruction: 0xffffffff
    bf1c:			; <UNDEFINED> instruction: 0xffffffff
    bf20:			; <UNDEFINED> instruction: 0xffffffff
    bf24:			; <UNDEFINED> instruction: 0xffffffff
    bf28:			; <UNDEFINED> instruction: 0xffffffff
    bf2c:			; <UNDEFINED> instruction: 0xffffffff
    bf30:			; <UNDEFINED> instruction: 0xffffffff
    bf34:			; <UNDEFINED> instruction: 0xffffffff
    bf38:			; <UNDEFINED> instruction: 0xffffffff
    bf3c:			; <UNDEFINED> instruction: 0xffffffff

0000bf40 <strlen>:
    bf40:	pld	[r0]
    bf44:	strd	r4, r5, [sp, #-8]!
    bf48:	bic.w	r1, r0, #7
    bf4c:	mvn.w	ip, #0
    bf50:	ands.w	r4, r0, #7
    bf54:	pld	[r1, #32]
    bf58:	bne.w	bfee <strlen+0xae>
    bf5c:	mov.w	r4, #0
    bf60:	mvn.w	r0, #7
    bf64:	ldrd	r2, r3, [r1]
    bf68:	pld	[r1, #64]	; 0x40
    bf6c:	add.w	r0, r0, #8
    bf70:	uadd8	r2, r2, ip
    bf74:	sel	r2, r4, ip
    bf78:	uadd8	r3, r3, ip
    bf7c:	sel	r3, r2, ip
    bf80:	cbnz	r3, bfd6 <strlen+0x96>
    bf82:	ldrd	r2, r3, [r1, #8]
    bf86:	uadd8	r2, r2, ip
    bf8a:	add.w	r0, r0, #8
    bf8e:	sel	r2, r4, ip
    bf92:	uadd8	r3, r3, ip
    bf96:	sel	r3, r2, ip
    bf9a:	cbnz	r3, bfd6 <strlen+0x96>
    bf9c:	ldrd	r2, r3, [r1, #16]
    bfa0:	uadd8	r2, r2, ip
    bfa4:	add.w	r0, r0, #8
    bfa8:	sel	r2, r4, ip
    bfac:	uadd8	r3, r3, ip
    bfb0:	sel	r3, r2, ip
    bfb4:	cbnz	r3, bfd6 <strlen+0x96>
    bfb6:	ldrd	r2, r3, [r1, #24]
    bfba:	add.w	r1, r1, #32
    bfbe:	uadd8	r2, r2, ip
    bfc2:	add.w	r0, r0, #8
    bfc6:	sel	r2, r4, ip
    bfca:	uadd8	r3, r3, ip
    bfce:	sel	r3, r2, ip
    bfd2:	cmp	r3, #0
    bfd4:	beq.n	bf64 <strlen+0x24>
    bfd6:	cmp	r2, #0
    bfd8:	itt	eq
    bfda:	addeq	r0, #4
    bfdc:	moveq	r2, r3
    bfde:	rev	r2, r2
    bfe0:	clz	r2, r2
    bfe4:	ldrd	r4, r5, [sp], #8
    bfe8:	add.w	r0, r0, r2, lsr #3
    bfec:	bx	lr
    bfee:	ldrd	r2, r3, [r1]
    bff2:	and.w	r5, r4, #3
    bff6:	rsb	r0, r4, #0
    bffa:	mov.w	r5, r5, lsl #3
    bffe:	tst.w	r4, #4
    c002:	pld	[r1, #64]	; 0x40
    c006:	lsl.w	r5, ip, r5
    c00a:	orn	r2, r2, r5
    c00e:	itt	ne
    c010:	ornne	r3, r3, r5
    c014:	movne	r2, ip
    c016:	mov.w	r4, #0
    c01a:	b.n	bf70 <strlen+0x30>

0000c01c <strncmp>:
    c01c:	cmp	r2, #0
    c01e:	beq.n	c0a4 <strncmp+0x88>
    c020:	orr.w	r3, r0, r1
    c024:	ands.w	r3, r3, #3
    c028:	push	{r4, r5, r6, r7}
    c02a:	bne.n	c078 <strncmp+0x5c>
    c02c:	cmp	r2, #3
    c02e:	bls.n	c078 <strncmp+0x5c>
    c030:	ldr	r4, [r0, #0]
    c032:	ldr	r5, [r1, #0]
    c034:	cmp	r4, r5
    c036:	bne.n	c078 <strncmp+0x5c>
    c038:	subs	r2, #4
    c03a:	beq.n	c0a8 <strncmp+0x8c>
    c03c:	sub.w	r5, r4, #16843009	; 0x1010101
    c040:	bic.w	r4, r5, r4
    c044:	tst.w	r4, #2155905152	; 0x80808080
    c048:	bne.n	c0ae <strncmp+0x92>
    c04a:	adds	r7, r0, #4
    c04c:	adds	r5, r1, #4
    c04e:	b.n	c06c <strncmp+0x50>
    c050:	ldr.w	r3, [r7], #4
    c054:	ldr	r6, [r1, #0]
    c056:	sub.w	r4, r3, #16843009	; 0x1010101
    c05a:	cmp	r3, r6
    c05c:	bic.w	r4, r4, r3
    c060:	bne.n	c078 <strncmp+0x5c>
    c062:	subs	r2, #4
    c064:	beq.n	c0a8 <strncmp+0x8c>
    c066:	tst.w	r4, #2155905152	; 0x80808080
    c06a:	bne.n	c0b4 <strncmp+0x98>
    c06c:	cmp	r2, #3
    c06e:	mov	r1, r5
    c070:	mov	r0, r7
    c072:	add.w	r5, r5, #4
    c076:	bhi.n	c050 <strncmp+0x34>
    c078:	ldrb	r3, [r0, #0]
    c07a:	ldrb	r4, [r1, #0]
    c07c:	cmp	r4, r3
    c07e:	add.w	r2, r2, #4294967295
    c082:	bne.n	c09e <strncmp+0x82>
    c084:	cbz	r2, c0a8 <strncmp+0x8c>
    c086:	cbnz	r4, c08e <strncmp+0x72>
    c088:	b.n	c0b8 <strncmp+0x9c>
    c08a:	cbz	r2, c0a8 <strncmp+0x8c>
    c08c:	cbz	r3, c0ae <strncmp+0x92>
    c08e:	ldrb.w	r3, [r0, #1]!
    c092:	ldrb.w	r4, [r1, #1]!
    c096:	cmp	r3, r4
    c098:	add.w	r2, r2, #4294967295
    c09c:	beq.n	c08a <strncmp+0x6e>
    c09e:	subs	r0, r3, r4
    c0a0:	pop	{r4, r5, r6, r7}
    c0a2:	bx	lr
    c0a4:	mov	r0, r2
    c0a6:	bx	lr
    c0a8:	mov	r0, r2
    c0aa:	pop	{r4, r5, r6, r7}
    c0ac:	bx	lr
    c0ae:	mov	r0, r3
    c0b0:	pop	{r4, r5, r6, r7}
    c0b2:	bx	lr
    c0b4:	movs	r0, #0
    c0b6:	b.n	c0a0 <strncmp+0x84>
    c0b8:	mov	r0, r4
    c0ba:	b.n	c0a0 <strncmp+0x84>

0000c0bc <sulp>:
    c0bc:	push	{r4, r5, r6, lr}
    c0be:	mov	r4, r0
    c0c0:	mov	r5, r1
    c0c2:	vmov	d0, r4, r5
    c0c6:	mov	r6, r2
    c0c8:	bl	11820 <__ulp>
    c0cc:	vmov	r0, r1, d0
    c0d0:	cbz	r6, c0f2 <sulp+0x36>
    c0d2:	ubfx	r3, r5, #20, #11
    c0d6:	rsb	r3, r3, #107	; 0x6b
    c0da:	cmp	r3, #0
    c0dc:	ble.n	c0f2 <sulp+0x36>
    c0de:	lsls	r3, r3, #20
    c0e0:	add.w	r5, r3, #1069547520	; 0x3fc00000
    c0e4:	movs	r4, #0
    c0e6:	add.w	r5, r5, #3145728	; 0x300000
    c0ea:	mov	r2, r4
    c0ec:	mov	r3, r5
    c0ee:	bl	a874 <__aeabi_dmul>
    c0f2:	pop	{r4, r5, r6, pc}
    c0f4:			; <UNDEFINED> instruction: 0xffffffff

0000c0f8 <_strtod_l>:
    c0f8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c0fc:	mov	r5, r3
    c0fe:	sub	sp, #132	; 0x84
    c100:	movs	r3, #0
    c102:	mov	fp, r0
    c104:	mov	r0, r5
    c106:	mov	r6, r1
    c108:	str	r2, [sp, #24]
    c10a:	str	r3, [sp, #112]	; 0x70
    c10c:	bl	111a4 <__localeconv_l>
    c110:	movs	r4, #0
    c112:	movs	r3, #0
    c114:	mov	sl, r0
    c116:	ldr	r0, [r0, #0]
    c118:	strd	r3, r4, [sp, #16]
    c11c:	bl	bf40 <strlen>
    c120:	str	r6, [sp, #108]	; 0x6c
    c122:	mov	r9, r0
    c124:	mov	r2, r6
    c126:	mov	r4, r2
    c128:	ldrb.w	r7, [r2], #1
    c12c:	cmp	r7, #45	; 0x2d
    c12e:	bhi.w	c290 <_strtod_l+0x198>
    c132:	tbb	[pc, r7]
    c136:	.short	0xad17
    c138:	.word	0xadadadad
    c13c:	.word	0x81adadad
    c140:	.word	0x81818181
    c144:	.word	0xadadadad
    c148:	.word	0xadadadad
    c14c:	.word	0xadadadad
    c150:	.word	0xadadadad
    c154:	.word	0xad81adad
    c158:	.word	0xadadadad
    c15c:	.word	0xadadadad
    c160:	.word	0x7ead2bad
    c164:	ldr	r3, [sp, #24]
    c166:	mov.w	r8, #0
    c16a:	mov.w	r9, #0
    c16e:	cbz	r3, c182 <_strtod_l+0x8a>
    c170:	movs	r3, #0
    c172:	str	r3, [sp, #28]
    c174:	ldr	r3, [sp, #24]
    c176:	str	r6, [r3, #0]
    c178:	ldr	r3, [sp, #28]
    c17a:	cbz	r3, c182 <_strtod_l+0x8a>
    c17c:	add.w	r3, r9, #2147483648	; 0x80000000
    c180:	mov	r9, r3
    c182:	vmov	d0, r8, r9
    c186:	add	sp, #132	; 0x84
    c188:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c18c:	movs	r3, #0
    c18e:	str	r3, [sp, #28]
    c190:	adds	r2, r4, #1
    c192:	str	r2, [sp, #108]	; 0x6c
    c194:	ldrb	r7, [r4, #1]
    c196:	cmp	r7, #0
    c198:	beq.n	c164 <_strtod_l+0x6c>
    c19a:	cmp	r7, #48	; 0x30
    c19c:	mov	r4, r2
    c19e:	beq.n	c298 <_strtod_l+0x1a0>
    c1a0:	movs	r3, #0
    c1a2:	str	r4, [sp, #32]
    c1a4:	str	r3, [sp, #40]	; 0x28
    c1a6:	sub.w	r3, r7, #48	; 0x30
    c1aa:	cmp	r3, #9
    c1ac:	bhi.w	c9be <_strtod_l+0x8c6>
    c1b0:	mov.w	r8, #0
    c1b4:	mov	r0, r4
    c1b6:	mov	r5, r8
    c1b8:	mov	r4, r8
    c1ba:	cmp	r4, #8
    c1bc:	it	gt
    c1be:	addgt.w	r8, r8, r8, lsl #2
    c1c2:	add.w	r3, r5, r5, lsl #2
    c1c6:	add.w	r0, r0, #1
    c1ca:	add.w	r3, r7, r3, lsl #1
    c1ce:	str	r0, [sp, #108]	; 0x6c
    c1d0:	itt	gt
    c1d2:	addgt.w	r7, r7, r8, lsl #1
    c1d6:	subgt.w	r8, r7, #48	; 0x30
    c1da:	ldrb	r7, [r0, #0]
    c1dc:	it	le
    c1de:	suble.w	r5, r3, #48	; 0x30
    c1e2:	sub.w	r3, r7, #48	; 0x30
    c1e6:	cmp	r3, #9
    c1e8:	add.w	r4, r4, #1
    c1ec:	bls.n	c1ba <_strtod_l+0xc2>
    c1ee:	ldr.w	r1, [sl]
    c1f2:	mov	r2, r9
    c1f4:	bl	c01c <strncmp>
    c1f8:	cbz	r0, c23c <_strtod_l+0x144>
    c1fa:	movs	r0, #0
    c1fc:	mov	r3, r7
    c1fe:	mov	r9, r0
    c200:	mov	r7, r0
    c202:	mov	sl, r4
    c204:	cmp	r3, #101	; 0x65
    c206:	beq.w	c36e <_strtod_l+0x276>
    c20a:	cmp	r3, #69	; 0x45
    c20c:	beq.w	c36e <_strtod_l+0x276>
    c210:	movs	r2, #0
    c212:	cmp	r4, #0
    c214:	bne.n	c2bc <_strtod_l+0x1c4>
    c216:	cbnz	r0, c220 <_strtod_l+0x128>
    c218:	ldr	r2, [sp, #40]	; 0x28
    c21a:	cmp	r2, #0
    c21c:	beq.w	c7c2 <_strtod_l+0x6ca>
    c220:	mov.w	r8, #0
    c224:	mov.w	r9, #0
    c228:	ldr	r3, [sp, #24]
    c22a:	cmp	r3, #0
    c22c:	beq.n	c178 <_strtod_l+0x80>
    c22e:	ldr	r6, [sp, #108]	; 0x6c
    c230:	b.n	c174 <_strtod_l+0x7c>
    c232:	movs	r3, #1
    c234:	str	r3, [sp, #28]
    c236:	b.n	c190 <_strtod_l+0x98>
    c238:	str	r2, [sp, #108]	; 0x6c
    c23a:	b.n	c126 <_strtod_l+0x2e>
    c23c:	ldr	r3, [sp, #108]	; 0x6c
    c23e:	add.w	r2, r3, r9
    c242:	str	r2, [sp, #108]	; 0x6c
    c244:	ldrb.w	r3, [r3, r9]
    c248:	mov	r7, r0
    c24a:	mov	sl, r4
    c24c:	sub.w	r2, r3, #48	; 0x30
    c250:	cmp	r2, #9
    c252:	bhi.w	c748 <_strtod_l+0x650>
    c256:	adds	r1, r0, #1
    c258:	mov	r3, r2
    c25a:	cmp	r2, #0
    c25c:	beq.w	cf9e <_strtod_l+0xea6>
    c260:	cmp	r1, #1
    c262:	add	r7, r1
    c264:	it	ne
    c266:	addne	r0, r0, r4
    c268:	bne.n	c276 <_strtod_l+0x17e>
    c26a:	b.w	cf96 <_strtod_l+0xe9e>
    c26e:	lsls	r5, r1, #1
    c270:	cmp	r4, r0
    c272:	beq.w	cbec <_strtod_l+0xaf4>
    c276:	adds	r4, #1
    c278:	subs	r1, r4, #1
    c27a:	cmp	r1, #8
    c27c:	add.w	r1, r5, r5, lsl #2
    c280:	ble.n	c26e <_strtod_l+0x176>
    c282:	cmp	r4, #16
    c284:	itt	le
    c286:	addle.w	r8, r8, r8, lsl #2
    c28a:	movle.w	r8, r8, lsl #1
    c28e:	b.n	c270 <_strtod_l+0x178>
    c290:	movs	r3, #0
    c292:	cmp	r7, #48	; 0x30
    c294:	str	r3, [sp, #28]
    c296:	bne.n	c1a0 <_strtod_l+0xa8>
    c298:	ldrb	r3, [r4, #1]
    c29a:	cmp	r3, #88	; 0x58
    c29c:	beq.w	c986 <_strtod_l+0x88e>
    c2a0:	cmp	r3, #120	; 0x78
    c2a2:	beq.w	c986 <_strtod_l+0x88e>
    c2a6:	adds	r4, #1
    c2a8:	str	r4, [sp, #108]	; 0x6c
    c2aa:	ldrb	r7, [r4, #0]
    c2ac:	cmp	r7, #48	; 0x30
    c2ae:	beq.n	c2a6 <_strtod_l+0x1ae>
    c2b0:	cmp	r7, #0
    c2b2:	beq.n	c220 <_strtod_l+0x128>
    c2b4:	movs	r3, #1
    c2b6:	str	r4, [sp, #32]
    c2b8:	str	r3, [sp, #40]	; 0x28
    c2ba:	b.n	c1a6 <_strtod_l+0xae>
    c2bc:	cmp	r4, #16
    c2be:	sub.w	r3, r2, r7
    c2c2:	mov	r0, r5
    c2c4:	mov	r9, r4
    c2c6:	str	r3, [sp, #44]	; 0x2c
    c2c8:	it	ge
    c2ca:	movge.w	r9, #16
    c2ce:	bl	a788 <__aeabi_ui2d>
    c2d2:	cmp.w	sl, #0
    c2d6:	it	eq
    c2d8:	moveq	sl, r4
    c2da:	cmp.w	r9, #9
    c2de:	strd	r0, r1, [sp, #16]
    c2e2:	ble.n	c30c <_strtod_l+0x214>
    c2e4:	ldr	r3, [pc, #292]	; (c40c <_strtod_l+0x314>)
    c2e6:	add.w	r3, r3, r9, lsl #3
    c2ea:	ldrd	r2, r3, [r3, #-72]	; 0x48
    c2ee:	bl	a874 <__aeabi_dmul>
    c2f2:	mov	r6, r0
    c2f4:	mov	r0, r8
    c2f6:	mov	r7, r1
    c2f8:	bl	a788 <__aeabi_ui2d>
    c2fc:	mov	r2, r0
    c2fe:	mov	r3, r1
    c300:	mov	r0, r6
    c302:	mov	r1, r7
    c304:	bl	a510 <__adddf3>
    c308:	strd	r0, r1, [sp, #16]
    c30c:	cmp	r4, #15
    c30e:	bgt.w	c41c <_strtod_l+0x324>
    c312:	ldr	r3, [sp, #44]	; 0x2c
    c314:	cmp	r3, #0
    c316:	beq.n	c368 <_strtod_l+0x270>
    c318:	ble.w	cd54 <_strtod_l+0xc5c>
    c31c:	ldr	r3, [sp, #44]	; 0x2c
    c31e:	cmp	r3, #22
    c320:	bgt.w	cc20 <_strtod_l+0xb28>
    c324:	ldr	r7, [pc, #228]	; (c40c <_strtod_l+0x314>)
    c326:	add.w	r7, r7, r3, lsl #3
    c32a:	ldrd	r0, r1, [r7]
    c32e:	ldrd	r2, r3, [sp, #16]
    c332:	bl	a874 <__aeabi_dmul>
    c336:	mov	r8, r0
    c338:	mov	r9, r1
    c33a:	b.n	c228 <_strtod_l+0x130>
    c33c:	add	r0, sp, #108	; 0x6c
    c33e:	ldr	r1, [pc, #208]	; (c410 <_strtod_l+0x318>)
    c340:	bl	10fd8 <__match>
    c344:	cmp	r0, #0
    c346:	beq.w	c164 <_strtod_l+0x6c>
    c34a:	ldr	r3, [sp, #108]	; 0x6c
    c34c:	ldr	r1, [pc, #196]	; (c414 <_strtod_l+0x31c>)
    c34e:	subs	r3, #1
    c350:	add	r0, sp, #108	; 0x6c
    c352:	str	r3, [sp, #108]	; 0x6c
    c354:	bl	10fd8 <__match>
    c358:	cbnz	r0, c360 <_strtod_l+0x268>
    c35a:	ldr	r3, [sp, #108]	; 0x6c
    c35c:	adds	r3, #1
    c35e:	str	r3, [sp, #108]	; 0x6c
    c360:	ldr	r3, [pc, #180]	; (c418 <_strtod_l+0x320>)
    c362:	str	r3, [sp, #20]
    c364:	movs	r3, #0
    c366:	str	r3, [sp, #16]
    c368:	ldrd	r8, r9, [sp, #16]
    c36c:	b.n	c228 <_strtod_l+0x130>
    c36e:	cmp	r4, #0
    c370:	beq.w	c708 <_strtod_l+0x610>
    c374:	ldr	r6, [sp, #108]	; 0x6c
    c376:	adds	r3, r6, #1
    c378:	str	r3, [sp, #108]	; 0x6c
    c37a:	ldrb	r3, [r6, #1]
    c37c:	cmp	r3, #43	; 0x2b
    c37e:	beq.w	c93c <_strtod_l+0x844>
    c382:	cmp	r3, #45	; 0x2d
    c384:	beq.w	c7b2 <_strtod_l+0x6ba>
    c388:	mov.w	ip, #0
    c38c:	sub.w	r2, r3, #48	; 0x30
    c390:	cmp	r2, #9
    c392:	bhi.w	c936 <_strtod_l+0x83e>
    c396:	cmp	r3, #48	; 0x30
    c398:	bne.n	c3a6 <_strtod_l+0x2ae>
    c39a:	ldr	r2, [sp, #108]	; 0x6c
    c39c:	adds	r2, #1
    c39e:	str	r2, [sp, #108]	; 0x6c
    c3a0:	ldrb	r3, [r2, #0]
    c3a2:	cmp	r3, #48	; 0x30
    c3a4:	beq.n	c39c <_strtod_l+0x2a4>
    c3a6:	sub.w	r2, r3, #49	; 0x31
    c3aa:	cmp	r2, #8
    c3ac:	bhi.w	c210 <_strtod_l+0x118>
    c3b0:	ldr	r2, [sp, #108]	; 0x6c
    c3b2:	str	r2, [sp, #48]	; 0x30
    c3b4:	adds	r1, r2, #1
    c3b6:	subs	r3, #48	; 0x30
    c3b8:	str	r1, [sp, #108]	; 0x6c
    c3ba:	str	r3, [sp, #44]	; 0x2c
    c3bc:	ldrb	r3, [r2, #1]
    c3be:	sub.w	lr, r3, #48	; 0x30
    c3c2:	cmp.w	lr, #9
    c3c6:	bhi.n	c3e8 <_strtod_l+0x2f0>
    c3c8:	ldr	r2, [sp, #44]	; 0x2c
    c3ca:	adds	r1, #1
    c3cc:	str	r1, [sp, #108]	; 0x6c
    c3ce:	add.w	r2, r2, r2, lsl #2
    c3d2:	add.w	r2, r3, r2, lsl #1
    c3d6:	ldrb	r3, [r1, #0]
    c3d8:	sub.w	lr, r3, #48	; 0x30
    c3dc:	cmp.w	lr, #9
    c3e0:	sub.w	r2, r2, #48	; 0x30
    c3e4:	bls.n	c3ca <_strtod_l+0x2d2>
    c3e6:	str	r2, [sp, #44]	; 0x2c
    c3e8:	ldr	r2, [sp, #48]	; 0x30
    c3ea:	subs	r1, r1, r2
    c3ec:	cmp	r1, #8
    c3ee:	bgt.w	cc0e <_strtod_l+0xb16>
    c3f2:	ldr	r2, [sp, #44]	; 0x2c
    c3f4:	movw	r1, #19999	; 0x4e1f
    c3f8:	cmp	r2, r1
    c3fa:	it	ge
    c3fc:	movge	r2, r1
    c3fe:	cmp.w	ip, #0
    c402:	beq.w	c212 <_strtod_l+0x11a>
    c406:	negs	r2, r2
    c408:	b.n	c212 <_strtod_l+0x11a>
    c40a:	nop
    c40c:	.word	0x000133f0
    c410:	.word	0x000130f8
    c414:	.word	0x000130fc
    c418:	.word	0x7ff00000
    c41c:	ldr	r3, [sp, #44]	; 0x2c
    c41e:	rsb	r9, r9, r4
    c422:	add	r9, r3
    c424:	cmp.w	r9, #0
    c428:	ble.w	cb3a <_strtod_l+0xa42>
    c42c:	ands.w	r1, r9, #15
    c430:	beq.n	c448 <_strtod_l+0x350>
    c432:	ldr	r3, [pc, #756]	; (c728 <_strtod_l+0x630>)
    c434:	add.w	r1, r3, r1, lsl #3
    c438:	ldrd	r0, r1, [r1]
    c43c:	ldrd	r2, r3, [sp, #16]
    c440:	bl	a874 <__aeabi_dmul>
    c444:	strd	r0, r1, [sp, #16]
    c448:	bics.w	r6, r9, #15
    c44c:	bne.w	c870 <_strtod_l+0x778>
    c450:	movs	r3, #0
    c452:	str	r3, [sp, #40]	; 0x28
    c454:	str	r5, [sp, #0]
    c456:	mov	r3, r4
    c458:	mov	r2, sl
    c45a:	ldr	r1, [sp, #32]
    c45c:	mov	r0, fp
    c45e:	bl	11300 <__s2b>
    c462:	str	r0, [sp, #72]	; 0x48
    c464:	cmp	r0, #0
    c466:	beq.w	cab6 <_strtod_l+0x9be>
    c46a:	ldr	r2, [sp, #44]	; 0x2c
    c46c:	movs	r7, #0
    c46e:	cmp	r2, #0
    c470:	rsb	r3, r2, #0
    c474:	it	ge
    c476:	movge	r3, r7
    c478:	str	r3, [sp, #48]	; 0x30
    c47a:	bic.w	r3, r2, r2, asr #31
    c47e:	str	r3, [sp, #44]	; 0x2c
    c480:	mov	sl, r7
    c482:	ldr	r4, [sp, #72]	; 0x48
    c484:	mov	r0, fp
    c486:	ldr	r1, [r4, #4]
    c488:	bl	11220 <_Balloc>
    c48c:	mov	r6, r0
    c48e:	cmp	r0, #0
    c490:	beq.w	c948 <_strtod_l+0x850>
    c494:	ldr	r2, [r4, #16]
    c496:	vldr	d7, [sp, #16]
    c49a:	adds	r2, #2
    c49c:	lsls	r2, r2, #2
    c49e:	add.w	r1, r4, #12
    c4a2:	adds	r0, #12
    c4a4:	vstr	d7, [sp, #32]
    c4a8:	bl	8ed0 <memcpy>
    c4ac:	vldr	d0, [sp, #32]
    c4b0:	add	r2, sp, #120	; 0x78
    c4b2:	add	r1, sp, #116	; 0x74
    c4b4:	mov	r0, fp
    c4b6:	bl	11944 <__d2b>
    c4ba:	str	r0, [sp, #112]	; 0x70
    c4bc:	cmp	r0, #0
    c4be:	beq.w	c94a <_strtod_l+0x852>
    c4c2:	movs	r1, #1
    c4c4:	mov	r0, fp
    c4c6:	bl	11434 <__i2b>
    c4ca:	mov	sl, r0
    c4cc:	cmp	r0, #0
    c4ce:	beq.w	c948 <_strtod_l+0x850>
    c4d2:	ldr	r2, [sp, #116]	; 0x74
    c4d4:	cmp	r2, #0
    c4d6:	blt.w	c740 <_strtod_l+0x648>
    c4da:	ldr	r3, [sp, #48]	; 0x30
    c4dc:	ldr	r4, [sp, #44]	; 0x2c
    c4de:	adds	r5, r3, r2
    c4e0:	ldr	r0, [sp, #40]	; 0x28
    c4e2:	ldr	r3, [sp, #120]	; 0x78
    c4e4:	ldr	r1, [pc, #580]	; (c72c <_strtod_l+0x634>)
    c4e6:	subs	r2, r2, r0
    c4e8:	add	r2, r3
    c4ea:	subs	r2, #1
    c4ec:	cmp	r2, r1
    c4ee:	rsb	r3, r3, #54	; 0x36
    c4f2:	bge.w	c6d2 <_strtod_l+0x5da>
    c4f6:	subs	r1, r1, r2
    c4f8:	cmp	r1, #31
    c4fa:	sub.w	r3, r3, r1
    c4fe:	bgt.w	c74e <_strtod_l+0x656>
    c502:	movs	r2, #1
    c504:	lsls	r2, r1
    c506:	str	r2, [sp, #56]	; 0x38
    c508:	movs	r2, #0
    c50a:	str	r2, [sp, #76]	; 0x4c
    c50c:	add.w	r9, r5, r3
    c510:	add	r4, r3
    c512:	ldr	r3, [sp, #40]	; 0x28
    c514:	cmp	r5, r9
    c516:	mov	r2, r5
    c518:	add	r4, r3
    c51a:	it	ge
    c51c:	movge	r2, r9
    c51e:	cmp	r2, r4
    c520:	it	ge
    c522:	movge	r2, r4
    c524:	cmp	r2, #0
    c526:	ble.n	c530 <_strtod_l+0x438>
    c528:	rsb	r9, r2, r9
    c52c:	subs	r4, r4, r2
    c52e:	subs	r5, r5, r2
    c530:	ldr	r3, [sp, #48]	; 0x30
    c532:	cbz	r3, c564 <_strtod_l+0x46c>
    c534:	mov	r1, sl
    c536:	mov	r2, r3
    c538:	mov	r0, fp
    c53a:	bl	11578 <__pow5mult>
    c53e:	mov	sl, r0
    c540:	cmp	r0, #0
    c542:	beq.w	c948 <_strtod_l+0x850>
    c546:	mov	r1, r0
    c548:	ldr	r2, [sp, #112]	; 0x70
    c54a:	mov	r0, fp
    c54c:	bl	11448 <__multiply>
    c550:	cmp	r0, #0
    c552:	beq.w	c948 <_strtod_l+0x850>
    c556:	str	r0, [sp, #52]	; 0x34
    c558:	ldr	r1, [sp, #112]	; 0x70
    c55a:	mov	r0, fp
    c55c:	bl	1126c <_Bfree>
    c560:	ldr	r2, [sp, #52]	; 0x34
    c562:	str	r2, [sp, #112]	; 0x70
    c564:	cmp.w	r9, #0
    c568:	ble.n	c57c <_strtod_l+0x484>
    c56a:	mov	r2, r9
    c56c:	ldr	r1, [sp, #112]	; 0x70
    c56e:	mov	r0, fp
    c570:	bl	11618 <__lshift>
    c574:	str	r0, [sp, #112]	; 0x70
    c576:	cmp	r0, #0
    c578:	beq.w	c94a <_strtod_l+0x852>
    c57c:	ldr	r3, [sp, #44]	; 0x2c
    c57e:	cbz	r3, c592 <_strtod_l+0x49a>
    c580:	mov	r1, r6
    c582:	ldr	r2, [sp, #44]	; 0x2c
    c584:	mov	r0, fp
    c586:	bl	11578 <__pow5mult>
    c58a:	mov	r6, r0
    c58c:	cmp	r0, #0
    c58e:	beq.w	c948 <_strtod_l+0x850>
    c592:	cmp	r4, #0
    c594:	ble.n	c5a8 <_strtod_l+0x4b0>
    c596:	mov	r1, r6
    c598:	mov	r2, r4
    c59a:	mov	r0, fp
    c59c:	bl	11618 <__lshift>
    c5a0:	mov	r6, r0
    c5a2:	cmp	r0, #0
    c5a4:	beq.w	c948 <_strtod_l+0x850>
    c5a8:	cmp	r5, #0
    c5aa:	ble.n	c5be <_strtod_l+0x4c6>
    c5ac:	mov	r1, sl
    c5ae:	mov	r2, r5
    c5b0:	mov	r0, fp
    c5b2:	bl	11618 <__lshift>
    c5b6:	mov	sl, r0
    c5b8:	cmp	r0, #0
    c5ba:	beq.w	c948 <_strtod_l+0x850>
    c5be:	mov	r2, r6
    c5c0:	ldr	r1, [sp, #112]	; 0x70
    c5c2:	mov	r0, fp
    c5c4:	bl	1170c <__mdiff>
    c5c8:	mov	r7, r0
    c5ca:	cmp	r0, #0
    c5cc:	beq.w	c948 <_strtod_l+0x850>
    c5d0:	movs	r3, #0
    c5d2:	ldr	r2, [r0, #12]
    c5d4:	str	r3, [r0, #12]
    c5d6:	mov	r1, sl
    c5d8:	str	r2, [sp, #52]	; 0x34
    c5da:	bl	116c8 <__mcmp>
    c5de:	cmp	r0, #0
    c5e0:	blt.w	cdfe <_strtod_l+0xd06>
    c5e4:	beq.w	cd78 <_strtod_l+0xc80>
    c5e8:	mov	r1, sl
    c5ea:	mov	r0, r7
    c5ec:	bl	11a00 <__ratio>
    c5f0:	vmov	r4, r5, d0
    c5f4:	movs	r2, #0
    c5f6:	mov.w	r3, #1073741824	; 0x40000000
    c5fa:	vmov	r0, s0
    c5fe:	mov	r1, r5
    c600:	bl	ad6c <__aeabi_dcmple>
    c604:	cmp	r0, #0
    c606:	beq.n	c6dc <_strtod_l+0x5e4>
    c608:	ldr	r3, [sp, #52]	; 0x34
    c60a:	cmp	r3, #0
    c60c:	beq.w	c75e <_strtod_l+0x666>
    c610:	vldr	d7, [pc, #260]	; c718 <_strtod_l+0x620>
    c614:	ldr	r3, [sp, #20]
    c616:	ldr	r5, [pc, #280]	; (c730 <_strtod_l+0x638>)
    c618:	vstr	d7, [sp, #56]	; 0x38
    c61c:	movs	r4, #0
    c61e:	mov	r8, r3
    c620:	ldr.w	r9, [pc, #276]	; c738 <_strtod_l+0x640>
    c624:	ldr	r3, [pc, #268]	; (c734 <_strtod_l+0x63c>)
    c626:	and.w	r9, r8, r9
    c62a:	cmp	r9, r3
    c62c:	beq.w	ca5c <_strtod_l+0x964>
    c630:	ldr	r3, [sp, #40]	; 0x28
    c632:	cbz	r3, c680 <_strtod_l+0x588>
    c634:	cmp.w	r9, #111149056	; 0x6a00000
    c638:	bhi.n	c680 <_strtod_l+0x588>
    c63a:	add	r3, pc, #228	; (adr r3, c720 <_strtod_l+0x628>)
    c63c:	ldrd	r2, r3, [r3]
    c640:	ldrd	r0, r1, [sp, #56]	; 0x38
    c644:	bl	ad6c <__aeabi_dcmple>
    c648:	cbz	r0, c678 <_strtod_l+0x580>
    c64a:	ldrd	r0, r1, [sp, #56]	; 0x38
    c64e:	bl	ae24 <__aeabi_d2uiz>
    c652:	cmp	r0, #0
    c654:	beq.w	ccd8 <_strtod_l+0xbe0>
    c658:	bl	a788 <__aeabi_ui2d>
    c65c:	strd	r0, r1, [sp, #56]	; 0x38
    c660:	ldr	r3, [sp, #52]	; 0x34
    c662:	cmp	r3, #0
    c664:	bne.w	ccce <_strtod_l+0xbd6>
    c668:	ldrd	r1, r2, [sp, #56]	; 0x38
    c66c:	add.w	r3, r2, #2147483648	; 0x80000000
    c670:	str	r1, [sp, #80]	; 0x50
    c672:	str	r3, [sp, #84]	; 0x54
    c674:	ldrd	r4, r5, [sp, #80]	; 0x50
    c678:	add.w	r3, r5, #112197632	; 0x6b00000
    c67c:	rsb	r5, r9, r3
    c680:	vldr	d0, [sp, #32]
    c684:	bl	11820 <__ulp>
    c688:	mov	r0, r4
    c68a:	vmov	r2, r3, d0
    c68e:	mov	r1, r5
    c690:	bl	a874 <__aeabi_dmul>
    c694:	ldrd	r2, r3, [sp, #32]
    c698:	bl	a510 <__adddf3>
    c69c:	strd	r0, r1, [sp, #16]
    c6a0:	mov	r4, r1
    c6a2:	ldr	r3, [sp, #40]	; 0x28
    c6a4:	cbnz	r3, c6b0 <_strtod_l+0x5b8>
    c6a6:	ldr	r3, [pc, #144]	; (c738 <_strtod_l+0x640>)
    c6a8:	ands	r3, r4
    c6aa:	cmp	r9, r3
    c6ac:	beq.w	cacc <_strtod_l+0x9d4>
    c6b0:	ldr	r1, [sp, #112]	; 0x70
    c6b2:	mov	r0, fp
    c6b4:	bl	1126c <_Bfree>
    c6b8:	mov	r1, r6
    c6ba:	mov	r0, fp
    c6bc:	bl	1126c <_Bfree>
    c6c0:	mov	r1, sl
    c6c2:	mov	r0, fp
    c6c4:	bl	1126c <_Bfree>
    c6c8:	mov	r1, r7
    c6ca:	mov	r0, fp
    c6cc:	bl	1126c <_Bfree>
    c6d0:	b.n	c482 <_strtod_l+0x38a>
    c6d2:	movs	r2, #0
    c6d4:	str	r2, [sp, #76]	; 0x4c
    c6d6:	movs	r2, #1
    c6d8:	str	r2, [sp, #56]	; 0x38
    c6da:	b.n	c50c <_strtod_l+0x414>
    c6dc:	ldr	r3, [pc, #92]	; (c73c <_strtod_l+0x644>)
    c6de:	mov	r0, r4
    c6e0:	mov	r1, r5
    c6e2:	movs	r2, #0
    c6e4:	bl	a874 <__aeabi_dmul>
    c6e8:	ldr	r3, [sp, #52]	; 0x34
    c6ea:	strd	r0, r1, [sp, #56]	; 0x38
    c6ee:	cmp	r3, #0
    c6f0:	bne.n	c7a8 <_strtod_l+0x6b0>
    c6f2:	add.w	r3, r1, #2147483648	; 0x80000000
    c6f6:	str	r0, [sp, #64]	; 0x40
    c6f8:	str	r3, [sp, #68]	; 0x44
    c6fa:	ldr	r3, [sp, #20]
    c6fc:	ldrd	r4, r5, [sp, #64]	; 0x40
    c700:	mov	r8, r3
    c702:	b.n	c620 <_strtod_l+0x528>
    c704:	mov.w	r9, #1
    c708:	cmp	r0, #0
    c70a:	bne.n	c7be <_strtod_l+0x6c6>
    c70c:	ldr	r3, [sp, #40]	; 0x28
    c70e:	cmp	r3, #0
    c710:	beq.w	c164 <_strtod_l+0x6c>
    c714:	mov	r4, r0
    c716:	b.n	c374 <_strtod_l+0x27c>
    c718:	.word	0x00000000
    c71c:	.word	0x3ff00000
    c720:	.word	0xffc00000
    c724:	.word	0x41dfffff
    c728:	.word	0x000133f0
    c72c:	.word	0xfffffc02
    c730:	.word	0x3ff00000
    c734:	.word	0x7fe00000
    c738:	.word	0x7ff00000
    c73c:	.word	0x3fe00000
    c740:	ldr	r3, [sp, #44]	; 0x2c
    c742:	ldr	r5, [sp, #48]	; 0x30
    c744:	subs	r4, r3, r2
    c746:	b.n	c4e0 <_strtod_l+0x3e8>
    c748:	mov.w	r9, #1
    c74c:	b.n	c204 <_strtod_l+0x10c>
    c74e:	ldr	r1, [pc, #736]	; (ca30 <_strtod_l+0x938>)
    c750:	subs	r1, r1, r2
    c752:	movs	r2, #1
    c754:	lsl.w	r1, r2, r1
    c758:	str	r1, [sp, #76]	; 0x4c
    c75a:	str	r2, [sp, #56]	; 0x38
    c75c:	b.n	c50c <_strtod_l+0x414>
    c75e:	ldrd	r1, r2, [sp, #16]
    c762:	cmp	r1, #0
    c764:	bne.w	c8fa <_strtod_l+0x802>
    c768:	ubfx	r3, r2, #0, #20
    c76c:	mov	r8, r2
    c76e:	cmp	r3, #0
    c770:	bne.w	c906 <_strtod_l+0x80e>
    c774:	movs	r2, #0
    c776:	ldr	r3, [pc, #700]	; (ca34 <_strtod_l+0x93c>)
    c778:	mov	r0, r4
    c77a:	mov	r1, r5
    c77c:	bl	ad58 <__aeabi_dcmplt>
    c780:	cmp	r0, #0
    c782:	bne.w	ce82 <_strtod_l+0xd8a>
    c786:	movs	r2, #0
    c788:	ldr	r3, [pc, #684]	; (ca38 <_strtod_l+0x940>)
    c78a:	mov	r0, r4
    c78c:	mov	r1, r5
    c78e:	bl	a874 <__aeabi_dmul>
    c792:	mov	r2, r1
    c794:	mov	r1, r0
    c796:	strd	r1, r2, [sp, #56]	; 0x38
    c79a:	add.w	r3, r2, #2147483648	; 0x80000000
    c79e:	str	r0, [sp, #96]	; 0x60
    c7a0:	str	r3, [sp, #100]	; 0x64
    c7a2:	ldrd	r4, r5, [sp, #96]	; 0x60
    c7a6:	b.n	c620 <_strtod_l+0x528>
    c7a8:	vldr	d7, [sp, #56]	; 0x38
    c7ac:	vstr	d7, [sp, #64]	; 0x40
    c7b0:	b.n	c6fa <_strtod_l+0x602>
    c7b2:	mov.w	ip, #1
    c7b6:	adds	r3, r6, #2
    c7b8:	str	r3, [sp, #108]	; 0x6c
    c7ba:	ldrb	r3, [r6, #2]
    c7bc:	b.n	c38c <_strtod_l+0x294>
    c7be:	movs	r4, #0
    c7c0:	b.n	c374 <_strtod_l+0x27c>
    c7c2:	cmp.w	r9, #0
    c7c6:	bne.w	c164 <_strtod_l+0x6c>
    c7ca:	subs	r3, #73	; 0x49
    c7cc:	cmp	r3, #37	; 0x25
    c7ce:	bhi.w	c164 <_strtod_l+0x6c>
    c7d2:	add	r2, pc, #4	; (adr r2, c7d8 <_strtod_l+0x6e0>)
    c7d4:	ldr.w	pc, [r2, r3, lsl #2]
    c7d8:	.word	0x0000c33d
    c7dc:	.word	0x0000c165
    c7e0:	.word	0x0000c165
    c7e4:	.word	0x0000c165
    c7e8:	.word	0x0000c165
    c7ec:	.word	0x0000c915
    c7f0:	.word	0x0000c165
    c7f4:	.word	0x0000c165
    c7f8:	.word	0x0000c165
    c7fc:	.word	0x0000c165
    c800:	.word	0x0000c165
    c804:	.word	0x0000c165
    c808:	.word	0x0000c165
    c80c:	.word	0x0000c165
    c810:	.word	0x0000c165
    c814:	.word	0x0000c165
    c818:	.word	0x0000c165
    c81c:	.word	0x0000c165
    c820:	.word	0x0000c165
    c824:	.word	0x0000c165
    c828:	.word	0x0000c165
    c82c:	.word	0x0000c165
    c830:	.word	0x0000c165
    c834:	.word	0x0000c165
    c838:	.word	0x0000c165
    c83c:	.word	0x0000c165
    c840:	.word	0x0000c165
    c844:	.word	0x0000c165
    c848:	.word	0x0000c165
    c84c:	.word	0x0000c165
    c850:	.word	0x0000c165
    c854:	.word	0x0000c165
    c858:	.word	0x0000c33d
    c85c:	.word	0x0000c165
    c860:	.word	0x0000c165
    c864:	.word	0x0000c165
    c868:	.word	0x0000c165
    c86c:	.word	0x0000c915
    c870:	cmp.w	r6, #308	; 0x134
    c874:	bgt.w	cab6 <_strtod_l+0x9be>
    c878:	asrs	r6, r6, #4
    c87a:	cmp	r6, #1
    c87c:	ldr.w	r9, [pc, #472]	; ca58 <_strtod_l+0x960>
    c880:	ble.w	ceb6 <_strtod_l+0xdbe>
    c884:	ldrd	r0, r1, [sp, #16]
    c888:	movs	r3, #0
    c88a:	mov	r7, r9
    c88c:	mov	r8, r3
    c88e:	tst.w	r6, #1
    c892:	add.w	r8, r8, #1
    c896:	mov.w	r6, r6, asr #1
    c89a:	beq.n	c8a6 <_strtod_l+0x7ae>
    c89c:	ldrd	r2, r3, [r7]
    c8a0:	bl	a874 <__aeabi_dmul>
    c8a4:	movs	r3, #1
    c8a6:	cmp	r6, #1
    c8a8:	add.w	r7, r7, #8
    c8ac:	bne.n	c88e <_strtod_l+0x796>
    c8ae:	cmp	r3, #0
    c8b0:	bne.w	cf7a <_strtod_l+0xe82>
    c8b4:	ldr	r3, [sp, #20]
    c8b6:	sub.w	r3, r3, #55574528	; 0x3500000
    c8ba:	str	r3, [sp, #20]
    c8bc:	add.w	r8, r9, r8, lsl #3
    c8c0:	ldrd	r2, r3, [sp, #16]
    c8c4:	ldrd	r0, r1, [r8]
    c8c8:	bl	a874 <__aeabi_dmul>
    c8cc:	bic.w	r3, r1, #2147483648	; 0x80000000
    c8d0:	lsrs	r3, r3, #20
    c8d2:	ldr	r2, [pc, #360]	; (ca3c <_strtod_l+0x944>)
    c8d4:	lsls	r3, r3, #20
    c8d6:	cmp	r3, r2
    c8d8:	strd	r0, r1, [sp, #16]
    c8dc:	bhi.w	cab6 <_strtod_l+0x9be>
    c8e0:	sub.w	r2, r2, #1048576	; 0x100000
    c8e4:	cmp	r3, r2
    c8e6:	bls.w	ce78 <_strtod_l+0xd80>
    c8ea:	ldr	r3, [pc, #340]	; (ca40 <_strtod_l+0x948>)
    c8ec:	str	r3, [sp, #20]
    c8ee:	movs	r3, #0
    c8f0:	str	r3, [sp, #40]	; 0x28
    c8f2:	mov.w	r3, #4294967295
    c8f6:	str	r3, [sp, #16]
    c8f8:	b.n	c454 <_strtod_l+0x35c>
    c8fa:	ldrd	r1, r2, [sp, #16]
    c8fe:	cmp	r1, #1
    c900:	beq.w	cce2 <_strtod_l+0xbea>
    c904:	mov	r8, r2
    c906:	vldr	d7, [pc, #288]	; ca28 <_strtod_l+0x930>
    c90a:	movs	r4, #0
    c90c:	ldr	r5, [pc, #308]	; (ca44 <_strtod_l+0x94c>)
    c90e:	vstr	d7, [sp, #56]	; 0x38
    c912:	b.n	c620 <_strtod_l+0x528>
    c914:	add	r0, sp, #108	; 0x6c
    c916:	ldr	r1, [pc, #304]	; (ca48 <_strtod_l+0x950>)
    c918:	bl	10fd8 <__match>
    c91c:	cmp	r0, #0
    c91e:	beq.w	c164 <_strtod_l+0x6c>
    c922:	ldr	r3, [sp, #108]	; 0x6c
    c924:	ldrb	r3, [r3, #0]
    c926:	cmp	r3, #40	; 0x28
    c928:	beq.w	cf30 <_strtod_l+0xe38>
    c92c:	ldr	r3, [pc, #284]	; (ca4c <_strtod_l+0x954>)
    c92e:	str	r3, [sp, #20]
    c930:	movs	r3, #0
    c932:	str	r3, [sp, #16]
    c934:	b.n	c368 <_strtod_l+0x270>
    c936:	str	r6, [sp, #108]	; 0x6c
    c938:	movs	r2, #0
    c93a:	b.n	c212 <_strtod_l+0x11a>
    c93c:	mov.w	ip, #0
    c940:	b.n	c7b6 <_strtod_l+0x6be>
    c942:	adds	r3, #1
    c944:	bne.w	cf16 <_strtod_l+0xe1e>
    c948:	ldr	r0, [sp, #112]	; 0x70
    c94a:	ldr	r3, [pc, #260]	; (ca50 <_strtod_l+0x958>)
    c94c:	str	r3, [sp, #20]
    c94e:	movs	r2, #0
    c950:	str	r2, [sp, #16]
    c952:	ldrd	r8, r9, [sp, #16]
    c956:	movs	r3, #34	; 0x22
    c958:	str.w	r3, [fp]
    c95c:	mov	r1, r0
    c95e:	mov	r0, fp
    c960:	bl	1126c <_Bfree>
    c964:	mov	r1, r6
    c966:	mov	r0, fp
    c968:	bl	1126c <_Bfree>
    c96c:	mov	r1, sl
    c96e:	mov	r0, fp
    c970:	bl	1126c <_Bfree>
    c974:	ldr	r1, [sp, #72]	; 0x48
    c976:	mov	r0, fp
    c978:	bl	1126c <_Bfree>
    c97c:	mov	r1, r7
    c97e:	mov	r0, fp
    c980:	bl	1126c <_Bfree>
    c984:	b.n	c228 <_strtod_l+0x130>
    c986:	ldr	r2, [sp, #28]
    c988:	str	r5, [sp, #8]
    c98a:	add	r3, sp, #112	; 0x70
    c98c:	str	r2, [sp, #4]
    c98e:	str	r3, [sp, #0]
    c990:	ldr	r2, [pc, #192]	; (ca54 <_strtod_l+0x95c>)
    c992:	add	r3, sp, #116	; 0x74
    c994:	add	r1, sp, #108	; 0x6c
    c996:	mov	r0, fp
    c998:	bl	10ac8 <__gethex>
    c99c:	ands.w	r6, r0, #7
    c9a0:	mov	r5, r0
    c9a2:	beq.w	c220 <_strtod_l+0x128>
    c9a6:	cmp	r6, #6
    c9a8:	bne.w	cc58 <_strtod_l+0xb60>
    c9ac:	adds	r4, #1
    c9ae:	movs	r3, #0
    c9b0:	str	r4, [sp, #108]	; 0x6c
    c9b2:	mov.w	r8, #0
    c9b6:	mov.w	r9, #0
    c9ba:	str	r3, [sp, #28]
    c9bc:	b.n	c228 <_strtod_l+0x130>
    c9be:	ldr.w	r1, [sl]
    c9c2:	mov	r0, r4
    c9c4:	mov	r2, r9
    c9c6:	bl	c01c <strncmp>
    c9ca:	cbz	r0, c9e0 <_strtod_l+0x8e8>
    c9cc:	mov.w	sl, #0
    c9d0:	mov	r3, r7
    c9d2:	mov	r8, sl
    c9d4:	mov	r5, sl
    c9d6:	mov	r0, sl
    c9d8:	mov	r7, sl
    c9da:	mov	r4, sl
    c9dc:	mov	r9, sl
    c9de:	b.n	c204 <_strtod_l+0x10c>
    c9e0:	ldr	r3, [sp, #108]	; 0x6c
    c9e2:	add.w	r2, r3, r9
    c9e6:	str	r2, [sp, #108]	; 0x6c
    c9e8:	ldrb.w	r3, [r3, r9]
    c9ec:	cmp	r3, #48	; 0x30
    c9ee:	bne.n	c9fe <_strtod_l+0x906>
    c9f0:	adds	r2, #1
    c9f2:	str	r2, [sp, #108]	; 0x6c
    c9f4:	ldrb	r3, [r2, #0]
    c9f6:	cmp	r3, #48	; 0x30
    c9f8:	add.w	r0, r0, #1
    c9fc:	beq.n	c9f0 <_strtod_l+0x8f8>
    c9fe:	sub.w	r2, r3, #49	; 0x31
    ca02:	cmp	r2, #8
    ca04:	bls.w	cd00 <_strtod_l+0xc08>
    ca08:	mov.w	sl, #0
    ca0c:	cmp	r3, #101	; 0x65
    ca0e:	mov	r8, sl
    ca10:	mov	r5, sl
    ca12:	mov	r7, sl
    ca14:	beq.w	c704 <_strtod_l+0x60c>
    ca18:	mov	r4, sl
    ca1a:	mov.w	r9, #1
    ca1e:	b.w	c20a <_strtod_l+0x112>
    ca22:	nop
    ca24:	nop.w
    ca28:	.word	0x00000000
    ca2c:	.word	0x3ff00000
    ca30:	.word	0xfffffbe2
    ca34:	.word	0x3ff00000
    ca38:	.word	0x3fe00000
    ca3c:	.word	0x7ca00000
    ca40:	.word	0x7fefffff
    ca44:	.word	0xbff00000
    ca48:	.word	0x00013104
    ca4c:	.word	0xfff80000
    ca50:	.word	0x7ff00000
    ca54:	.word	0x000130e4
    ca58:	.word	0x000134b8
    ca5c:	sub.w	r3, r8, #55574528	; 0x3500000
    ca60:	str	r3, [sp, #20]
    ca62:	vldr	d7, [sp, #16]
    ca66:	vmov.f32	s0, s14
    ca6a:	vmov.f32	s1, s15
    ca6e:	bl	11820 <__ulp>
    ca72:	mov	r0, r4
    ca74:	vmov	r2, r3, d0
    ca78:	mov	r1, r5
    ca7a:	bl	a874 <__aeabi_dmul>
    ca7e:	ldrd	r2, r3, [sp, #16]
    ca82:	bl	a510 <__adddf3>
    ca86:	bic.w	r3, r1, #2147483648	; 0x80000000
    ca8a:	strd	r0, r1, [sp, #16]
    ca8e:	lsrs	r3, r3, #20
    ca90:	ldr	r2, [pc, #684]	; (cd40 <_strtod_l+0xc48>)
    ca92:	ldrd	r0, r1, [sp, #32]
    ca96:	lsls	r3, r3, #20
    ca98:	cmp	r3, r2
    ca9a:	strd	r0, r1, [sp, #88]	; 0x58
    ca9e:	bls.w	cc16 <_strtod_l+0xb1e>
    caa2:	ldr	r3, [pc, #672]	; (cd44 <_strtod_l+0xc4c>)
    caa4:	cmp	r1, r3
    caa6:	beq.w	ce6e <_strtod_l+0xd76>
    caaa:	ldr	r3, [pc, #664]	; (cd44 <_strtod_l+0xc4c>)
    caac:	str	r3, [sp, #20]
    caae:	mov.w	r3, #4294967295
    cab2:	str	r3, [sp, #16]
    cab4:	b.n	c6b0 <_strtod_l+0x5b8>
    cab6:	ldr	r3, [pc, #656]	; (cd48 <_strtod_l+0xc50>)
    cab8:	str	r3, [sp, #20]
    caba:	movs	r2, #0
    cabc:	movs	r3, #34	; 0x22
    cabe:	str	r2, [sp, #16]
    cac0:	ldrd	r8, r9, [sp, #16]
    cac4:	str.w	r3, [fp]
    cac8:	b.w	c228 <_strtod_l+0x130>
    cacc:	ldrd	r8, r9, [sp, #56]	; 0x38
    cad0:	mov	r1, r9
    cad2:	mov	r0, r8
    cad4:	bl	add4 <__aeabi_d2iz>
    cad8:	bl	a7a8 <__aeabi_i2d>
    cadc:	mov	r3, r1
    cade:	mov	r2, r0
    cae0:	mov	r1, r9
    cae2:	mov	r0, r8
    cae4:	bl	a50c <__aeabi_dsub>
    cae8:	ldr	r3, [sp, #52]	; 0x34
    caea:	mov	r8, r0
    caec:	mov	r9, r1
    caee:	cbnz	r3, cb12 <_strtod_l+0xa1a>
    caf0:	ldr	r3, [sp, #16]
    caf2:	cbnz	r3, cb12 <_strtod_l+0xa1a>
    caf4:	ubfx	r4, r4, #0, #20
    caf8:	cbnz	r4, cb12 <_strtod_l+0xa1a>
    cafa:	add	r3, pc, #548	; (adr r3, cd20 <_strtod_l+0xc28>)
    cafc:	ldrd	r2, r3, [r3]
    cb00:	bl	ad58 <__aeabi_dcmplt>
    cb04:	cmp	r0, #0
    cb06:	beq.w	c6b0 <_strtod_l+0x5b8>
    cb0a:	ldrd	r8, r9, [sp, #16]
    cb0e:	ldr	r0, [sp, #112]	; 0x70
    cb10:	b.n	c95c <_strtod_l+0x864>
    cb12:	add	r3, pc, #532	; (adr r3, cd28 <_strtod_l+0xc30>)
    cb14:	ldrd	r2, r3, [r3]
    cb18:	mov	r0, r8
    cb1a:	mov	r1, r9
    cb1c:	bl	ad58 <__aeabi_dcmplt>
    cb20:	cmp	r0, #0
    cb22:	bne.n	cb0a <_strtod_l+0xa12>
    cb24:	mov	r0, r8
    cb26:	mov	r1, r9
    cb28:	add	r3, pc, #516	; (adr r3, cd30 <_strtod_l+0xc38>)
    cb2a:	ldrd	r2, r3, [r3]
    cb2e:	bl	ad94 <__aeabi_dcmpgt>
    cb32:	cmp	r0, #0
    cb34:	beq.w	c6b0 <_strtod_l+0x5b8>
    cb38:	b.n	cb0a <_strtod_l+0xa12>
    cb3a:	beq.w	c450 <_strtod_l+0x358>
    cb3e:	rsb	r6, r9, #0
    cb42:	ands.w	r2, r6, #15
    cb46:	beq.n	cb5e <_strtod_l+0xa66>
    cb48:	ldr	r3, [pc, #512]	; (cd4c <_strtod_l+0xc54>)
    cb4a:	add.w	r3, r3, r2, lsl #3
    cb4e:	ldrd	r0, r1, [sp, #16]
    cb52:	ldrd	r2, r3, [r3]
    cb56:	bl	aac8 <__aeabi_ddiv>
    cb5a:	strd	r0, r1, [sp, #16]
    cb5e:	asrs	r6, r6, #4
    cb60:	beq.w	c450 <_strtod_l+0x358>
    cb64:	cmp	r6, #31
    cb66:	bgt.n	cbda <_strtod_l+0xae2>
    cb68:	ands.w	r3, r6, #16
    cb6c:	beq.w	cee0 <_strtod_l+0xde8>
    cb70:	movs	r3, #106	; 0x6a
    cb72:	cmp	r6, #0
    cb74:	str	r3, [sp, #40]	; 0x28
    cb76:	ble.n	cba0 <_strtod_l+0xaa8>
    cb78:	ldrd	r0, r1, [sp, #16]
    cb7c:	ldr	r7, [pc, #464]	; (cd50 <_strtod_l+0xc58>)
    cb7e:	movs	r3, #0
    cb80:	lsls	r2, r6, #31
    cb82:	bpl.n	cb8e <_strtod_l+0xa96>
    cb84:	ldrd	r2, r3, [r7]
    cb88:	bl	a874 <__aeabi_dmul>
    cb8c:	movs	r3, #1
    cb8e:	asrs	r6, r6, #1
    cb90:	add.w	r7, r7, #8
    cb94:	bne.n	cb80 <_strtod_l+0xa88>
    cb96:	cmp	r3, #0
    cb98:	bne.w	cf80 <_strtod_l+0xe88>
    cb9c:	ldr	r3, [sp, #40]	; 0x28
    cb9e:	cbz	r3, cbc8 <_strtod_l+0xad0>
    cba0:	ldrd	r1, r2, [sp, #16]
    cba4:	ubfx	r3, r2, #20, #11
    cba8:	rsb	r3, r3, #107	; 0x6b
    cbac:	cmp	r3, #0
    cbae:	mov	r1, r2
    cbb0:	ble.n	cbc8 <_strtod_l+0xad0>
    cbb2:	cmp	r3, #31
    cbb4:	ble.w	cf6a <_strtod_l+0xe72>
    cbb8:	movs	r2, #0
    cbba:	cmp	r3, #52	; 0x34
    cbbc:	str	r2, [sp, #16]
    cbbe:	ble.w	cf86 <_strtod_l+0xe8e>
    cbc2:	mov.w	r3, #57671680	; 0x3700000
    cbc6:	str	r3, [sp, #20]
    cbc8:	movs	r2, #0
    cbca:	movs	r3, #0
    cbcc:	ldrd	r0, r1, [sp, #16]
    cbd0:	bl	ad44 <__aeabi_dcmpeq>
    cbd4:	cmp	r0, #0
    cbd6:	beq.w	c454 <_strtod_l+0x35c>
    cbda:	movs	r3, #34	; 0x22
    cbdc:	str.w	r3, [fp]
    cbe0:	mov.w	r8, #0
    cbe4:	mov.w	r9, #0
    cbe8:	b.w	c228 <_strtod_l+0x130>
    cbec:	ldr	r1, [sp, #108]	; 0x6c
    cbee:	adds	r4, #1
    cbf0:	cmp	r0, #8
    cbf2:	ble.w	cd12 <_strtod_l+0xc1a>
    cbf6:	cmp	r4, #16
    cbf8:	itt	le
    cbfa:	addle.w	r8, r8, r8, lsl #2
    cbfe:	addle.w	r8, r2, r8, lsl #1
    cc02:	movs	r0, #0
    cc04:	adds	r3, r1, #1
    cc06:	str	r3, [sp, #108]	; 0x6c
    cc08:	ldrb	r3, [r1, #1]
    cc0a:	b.w	c24c <_strtod_l+0x154>
    cc0e:	movw	r2, #19999	; 0x4e1f
    cc12:	b.w	c3fe <_strtod_l+0x306>
    cc16:	ldr	r3, [sp, #20]
    cc18:	add.w	r4, r3, #55574528	; 0x3500000
    cc1c:	str	r4, [sp, #20]
    cc1e:	b.n	c6a2 <_strtod_l+0x5aa>
    cc20:	ldr	r6, [sp, #44]	; 0x2c
    cc22:	rsb	r3, r4, #37	; 0x25
    cc26:	cmp	r6, r3
    cc28:	bgt.w	c41c <_strtod_l+0x324>
    cc2c:	ldr	r5, [pc, #284]	; (cd4c <_strtod_l+0xc54>)
    cc2e:	rsb	r4, r4, #15
    cc32:	add.w	r1, r5, r4, lsl #3
    cc36:	subs	r4, r6, r4
    cc38:	ldrd	r2, r3, [sp, #16]
    cc3c:	ldrd	r0, r1, [r1]
    cc40:	add.w	r5, r5, r4, lsl #3
    cc44:	bl	a874 <__aeabi_dmul>
    cc48:	ldrd	r2, r3, [r5]
    cc4c:	bl	a874 <__aeabi_dmul>
    cc50:	mov	r8, r0
    cc52:	mov	r9, r1
    cc54:	b.w	c228 <_strtod_l+0x130>
    cc58:	ldr	r2, [sp, #112]	; 0x70
    cc5a:	cbz	r2, cc6c <_strtod_l+0xb74>
    cc5c:	movs	r1, #53	; 0x35
    cc5e:	add	r0, sp, #120	; 0x78
    cc60:	bl	11a60 <__copybits>
    cc64:	mov	r0, fp
    cc66:	ldr	r1, [sp, #112]	; 0x70
    cc68:	bl	1126c <_Bfree>
    cc6c:	cmp	r6, #6
    cc6e:	bhi.n	cc88 <_strtod_l+0xb90>
    cc70:	tbb	[pc, r6]
    cc74:	.word	0x1318211d
    cc78:	.short	0x2104
    cc7a:	.byte	0x1d
    cc7b:	.byte	0x00
    cc7c:	mvn.w	r3, #2147483648	; 0x80000000
    cc80:	str	r3, [sp, #20]
    cc82:	mov.w	r3, #4294967295
    cc86:	str	r3, [sp, #16]
    cc88:	lsls	r1, r5, #28
    cc8a:	bpl.w	c368 <_strtod_l+0x270>
    cc8e:	ldr	r3, [sp, #20]
    cc90:	orr.w	r3, r3, #2147483648	; 0x80000000
    cc94:	str	r3, [sp, #20]
    cc96:	b.w	c368 <_strtod_l+0x270>
    cc9a:	ldr	r3, [pc, #172]	; (cd48 <_strtod_l+0xc50>)
    cc9c:	str	r3, [sp, #20]
    cc9e:	movs	r3, #0
    cca0:	str	r3, [sp, #16]
    cca2:	b.n	cc88 <_strtod_l+0xb90>
    cca4:	ldr	r3, [sp, #120]	; 0x78
    cca6:	str	r3, [sp, #16]
    cca8:	ldr	r3, [sp, #124]	; 0x7c
    ccaa:	str	r3, [sp, #20]
    ccac:	b.n	cc88 <_strtod_l+0xb90>
    ccae:	movs	r3, #0
    ccb0:	str	r3, [sp, #20]
    ccb2:	str	r3, [sp, #16]
    ccb4:	b.n	cc88 <_strtod_l+0xb90>
    ccb6:	ldr	r2, [sp, #116]	; 0x74
    ccb8:	ldr	r3, [sp, #124]	; 0x7c
    ccba:	ldr	r1, [sp, #120]	; 0x78
    ccbc:	str	r1, [sp, #16]
    ccbe:	addw	r2, r2, #1075	; 0x433
    ccc2:	bic.w	r3, r3, #1048576	; 0x100000
    ccc6:	orr.w	r3, r3, r2, lsl #20
    ccca:	str	r3, [sp, #20]
    cccc:	b.n	cc88 <_strtod_l+0xb90>
    ccce:	vldr	d7, [sp, #56]	; 0x38
    ccd2:	vstr	d7, [sp, #80]	; 0x50
    ccd6:	b.n	c674 <_strtod_l+0x57c>
    ccd8:	vldr	d7, [pc, #92]	; cd38 <_strtod_l+0xc40>
    ccdc:	vstr	d7, [sp, #56]	; 0x38
    cce0:	b.n	c660 <_strtod_l+0x568>
    cce2:	ldrd	r1, r2, [sp, #16]
    cce6:	mov	r8, r2
    cce8:	cmp	r2, #0
    ccea:	bne.w	c906 <_strtod_l+0x80e>
    ccee:	movs	r3, #34	; 0x22
    ccf0:	str.w	r3, [fp]
    ccf4:	ldr	r0, [sp, #112]	; 0x70
    ccf6:	mov.w	r8, #0
    ccfa:	mov.w	r9, #0
    ccfe:	b.n	c95c <_strtod_l+0x864>
    cd00:	ldr	r2, [sp, #108]	; 0x6c
    cd02:	str	r2, [sp, #32]
    cd04:	movs	r5, #0
    cd06:	subs	r3, #48	; 0x30
    cd08:	adds	r7, r0, #1
    cd0a:	mov	r1, r2
    cd0c:	mov	sl, r5
    cd0e:	mov	r8, r5
    cd10:	movs	r4, #1
    cd12:	add.w	r5, r5, r5, lsl #2
    cd16:	add.w	r5, r3, r5, lsl #1
    cd1a:	movs	r0, #0
    cd1c:	b.n	cc04 <_strtod_l+0xb0c>
    cd1e:	nop
    cd20:	.word	0x94a03595
    cd24:	.word	0x3fcfffff
    cd28:	.word	0x94a03595
    cd2c:	.word	0x3fdfffff
    cd30:	.word	0x35afe535
    cd34:	.word	0x3fe00000
    cd38:	.word	0x00000000
    cd3c:	.word	0x3ff00000
    cd40:	.word	0x7c9fffff
    cd44:	.word	0x7fefffff
    cd48:	.word	0x7ff00000
    cd4c:	.word	0x000133f0
    cd50:	.word	0x00013120
    cd54:	ldr	r1, [sp, #44]	; 0x2c
    cd56:	cmn.w	r1, #22
    cd5a:	blt.w	c41c <_strtod_l+0x324>
    cd5e:	ldr	r2, [pc, #600]	; (cfb8 <_strtod_l+0xec0>)
    cd60:	sub.w	r2, r2, r1, lsl #3
    cd64:	ldrd	r2, r3, [r2]
    cd68:	ldrd	r0, r1, [sp, #16]
    cd6c:	bl	aac8 <__aeabi_ddiv>
    cd70:	mov	r8, r0
    cd72:	mov	r9, r1
    cd74:	b.w	c228 <_strtod_l+0x130>
    cd78:	ldr	r3, [sp, #52]	; 0x34
    cd7a:	ldrd	r8, r9, [sp, #32]
    cd7e:	cmp	r3, #0
    cd80:	beq.w	ce94 <_strtod_l+0xd9c>
    cd84:	ldrd	r4, r5, [sp, #16]
    cd88:	ldr	r3, [pc, #560]	; (cfbc <_strtod_l+0xec4>)
    cd8a:	ubfx	r1, r5, #0, #20
    cd8e:	cmp	r1, r3
    cd90:	mov	r2, r5
    cd92:	beq.w	ceea <_strtod_l+0xdf2>
    cd96:	ldr	r3, [sp, #76]	; 0x4c
    cd98:	cmp	r3, #0
    cd9a:	beq.w	ceac <_strtod_l+0xdb4>
    cd9e:	ldr	r2, [sp, #20]
    cda0:	tst	r3, r2
    cda2:	beq.n	cdc6 <_strtod_l+0xcce>
    cda4:	ldr	r3, [sp, #52]	; 0x34
    cda6:	ldr	r2, [sp, #40]	; 0x28
    cda8:	ldrd	r0, r1, [sp, #16]
    cdac:	cmp	r3, #0
    cdae:	beq.w	cebc <_strtod_l+0xdc4>
    cdb2:	bl	c0bc <sulp>
    cdb6:	mov	r2, r0
    cdb8:	mov	r3, r1
    cdba:	mov	r0, r8
    cdbc:	mov	r1, r9
    cdbe:	bl	a510 <__adddf3>
    cdc2:	mov	r8, r0
    cdc4:	mov	r9, r1
    cdc6:	ldr	r3, [sp, #40]	; 0x28
    cdc8:	cbz	r3, cdfa <_strtod_l+0xd02>
    cdca:	ldr	r3, [pc, #500]	; (cfc0 <_strtod_l+0xec8>)
    cdcc:	str	r3, [sp, #92]	; 0x5c
    cdce:	movs	r3, #0
    cdd0:	str	r3, [sp, #88]	; 0x58
    cdd2:	ldrd	r2, r3, [sp, #88]	; 0x58
    cdd6:	mov	r0, r8
    cdd8:	mov	r1, r9
    cdda:	bl	a874 <__aeabi_dmul>
    cdde:	mov	r3, r0
    cde0:	mov	r4, r1
    cde2:	mov	r8, r0
    cde4:	mov	r9, r1
    cde6:	strd	r3, r4, [sp, #16]
    cdea:	cbnz	r1, cdfa <_strtod_l+0xd02>
    cdec:	ldr	r3, [sp, #16]
    cdee:	cbnz	r3, cdfa <_strtod_l+0xd02>
    cdf0:	movs	r3, #34	; 0x22
    cdf2:	ldr	r0, [sp, #112]	; 0x70
    cdf4:	str.w	r3, [fp]
    cdf8:	b.n	c95c <_strtod_l+0x864>
    cdfa:	ldr	r0, [sp, #112]	; 0x70
    cdfc:	b.n	c95c <_strtod_l+0x864>
    cdfe:	ldr	r3, [sp, #52]	; 0x34
    ce00:	ldrd	r8, r9, [sp, #32]
    ce04:	cmp	r3, #0
    ce06:	bne.n	cdc6 <_strtod_l+0xcce>
    ce08:	ldrd	r1, r2, [sp, #16]
    ce0c:	cmp	r1, #0
    ce0e:	bne.n	cdc6 <_strtod_l+0xcce>
    ce10:	ubfx	r3, r2, #0, #20
    ce14:	mov	r4, r2
    ce16:	cmp	r3, #0
    ce18:	bne.n	cdc6 <_strtod_l+0xcce>
    ce1a:	bic.w	r3, r2, #2147483648	; 0x80000000
    ce1e:	lsrs	r3, r3, #20
    ce20:	lsls	r3, r3, #20
    ce22:	cmp.w	r3, #112197632	; 0x6b00000
    ce26:	bls.n	cdc6 <_strtod_l+0xcce>
    ce28:	ldr	r3, [r7, #20]
    ce2a:	cbnz	r3, ce32 <_strtod_l+0xd3a>
    ce2c:	ldr	r3, [r7, #16]
    ce2e:	cmp	r3, #1
    ce30:	ble.n	cdc6 <_strtod_l+0xcce>
    ce32:	mov	r1, r7
    ce34:	movs	r2, #1
    ce36:	mov	r0, fp
    ce38:	bl	11618 <__lshift>
    ce3c:	mov	r1, sl
    ce3e:	mov	r7, r0
    ce40:	bl	116c8 <__mcmp>
    ce44:	cmp	r0, #0
    ce46:	ble.n	cdc6 <_strtod_l+0xcce>
    ce48:	ldr	r3, [sp, #40]	; 0x28
    ce4a:	cmp	r3, #0
    ce4c:	bne.w	cf54 <_strtod_l+0xe5c>
    ce50:	ldr	r3, [pc, #368]	; (cfc4 <_strtod_l+0xecc>)
    ce52:	ands	r3, r4
    ce54:	sub.w	r3, r3, #1048576	; 0x100000
    ce58:	mvn.w	r3, r3, lsr #20
    ce5c:	mvn.w	r3, r3, lsl #20
    ce60:	str	r3, [sp, #20]
    ce62:	mov.w	r3, #4294967295
    ce66:	str	r3, [sp, #16]
    ce68:	ldrd	r8, r9, [sp, #16]
    ce6c:	b.n	cdc6 <_strtod_l+0xcce>
    ce6e:	ldr	r3, [sp, #88]	; 0x58
    ce70:	adds	r3, #1
    ce72:	bne.w	caaa <_strtod_l+0x9b2>
    ce76:	b.n	c948 <_strtod_l+0x850>
    ce78:	add.w	r3, r1, #55574528	; 0x3500000
    ce7c:	str	r3, [sp, #20]
    ce7e:	b.w	c450 <_strtod_l+0x358>
    ce82:	vldr	d7, [pc, #292]	; cfa8 <_strtod_l+0xeb0>
    ce86:	vstr	d7, [sp, #96]	; 0x60
    ce8a:	vldr	d7, [pc, #292]	; cfb0 <_strtod_l+0xeb8>
    ce8e:	vstr	d7, [sp, #56]	; 0x38
    ce92:	b.n	c7a2 <_strtod_l+0x6aa>
    ce94:	ldrd	r1, r2, [sp, #16]
    ce98:	ubfx	r3, r2, #0, #20
    ce9c:	mov	r4, r2
    ce9e:	cmp	r3, #0
    cea0:	bne.w	cd96 <_strtod_l+0xc9e>
    cea4:	cmp	r1, #0
    cea6:	bne.w	cd96 <_strtod_l+0xc9e>
    ceaa:	b.n	ce48 <_strtod_l+0xd50>
    ceac:	ldr	r3, [sp, #56]	; 0x38
    ceae:	ldr	r2, [sp, #16]
    ceb0:	tst	r3, r2
    ceb2:	beq.n	cdc6 <_strtod_l+0xcce>
    ceb4:	b.n	cda4 <_strtod_l+0xcac>
    ceb6:	mov.w	r8, #0
    ceba:	b.n	c8b4 <_strtod_l+0x7bc>
    cebc:	bl	c0bc <sulp>
    cec0:	mov	r2, r0
    cec2:	mov	r3, r1
    cec4:	mov	r0, r8
    cec6:	mov	r1, r9
    cec8:	bl	a50c <__aeabi_dsub>
    cecc:	movs	r2, #0
    cece:	movs	r3, #0
    ced0:	mov	r8, r0
    ced2:	mov	r9, r1
    ced4:	bl	ad44 <__aeabi_dcmpeq>
    ced8:	cmp	r0, #0
    ceda:	bne.w	ccee <_strtod_l+0xbf6>
    cede:	b.n	cdc6 <_strtod_l+0xcce>
    cee0:	cmp	r6, #0
    cee2:	str	r3, [sp, #40]	; 0x28
    cee4:	bgt.w	cb78 <_strtod_l+0xa80>
    cee8:	b.n	cbc8 <_strtod_l+0xad0>
    ceea:	ldr	r3, [sp, #40]	; 0x28
    ceec:	ldr	r1, [sp, #16]
    ceee:	cbz	r3, cf2a <_strtod_l+0xe32>
    cef0:	ldr	r3, [pc, #208]	; (cfc4 <_strtod_l+0xecc>)
    cef2:	ands	r3, r5
    cef4:	cmp.w	r3, #111149056	; 0x6a00000
    cef8:	bhi.n	cf2a <_strtod_l+0xe32>
    cefa:	lsrs	r3, r3, #20
    cefc:	rsb	r3, r3, #107	; 0x6b
    cf00:	mov.w	r0, #4294967295
    cf04:	lsl.w	r3, r0, r3
    cf08:	cmp	r3, r1
    cf0a:	bne.w	cd96 <_strtod_l+0xc9e>
    cf0e:	ldr	r1, [pc, #184]	; (cfc8 <_strtod_l+0xed0>)
    cf10:	cmp	r2, r1
    cf12:	beq.w	c942 <_strtod_l+0x84a>
    cf16:	ldr	r3, [pc, #172]	; (cfc4 <_strtod_l+0xecc>)
    cf18:	ands	r3, r2
    cf1a:	add.w	r3, r3, #1048576	; 0x100000
    cf1e:	str	r3, [sp, #20]
    cf20:	movs	r3, #0
    cf22:	str	r3, [sp, #16]
    cf24:	ldrd	r8, r9, [sp, #16]
    cf28:	b.n	cdc6 <_strtod_l+0xcce>
    cf2a:	mov.w	r3, #4294967295
    cf2e:	b.n	cf08 <_strtod_l+0xe10>
    cf30:	add	r0, sp, #108	; 0x6c
    cf32:	add	r2, sp, #120	; 0x78
    cf34:	ldr	r1, [pc, #148]	; (cfcc <_strtod_l+0xed4>)
    cf36:	bl	11008 <__hexnan>
    cf3a:	cmp	r0, #5
    cf3c:	bne.w	c92c <_strtod_l+0x834>
    cf40:	ldr	r3, [sp, #124]	; 0x7c
    cf42:	orr.w	r3, r3, #2139095040	; 0x7f800000
    cf46:	orr.w	r3, r3, #7340032	; 0x700000
    cf4a:	str	r3, [sp, #20]
    cf4c:	ldr	r3, [sp, #120]	; 0x78
    cf4e:	str	r3, [sp, #16]
    cf50:	b.w	c368 <_strtod_l+0x270>
    cf54:	ldr	r3, [pc, #108]	; (cfc4 <_strtod_l+0xecc>)
    cf56:	ands	r3, r4
    cf58:	cmp.w	r3, #112197632	; 0x6b00000
    cf5c:	bgt.w	ce54 <_strtod_l+0xd5c>
    cf60:	cmp.w	r3, #57671680	; 0x3700000
    cf64:	bgt.w	cdca <_strtod_l+0xcd2>
    cf68:	b.n	ccee <_strtod_l+0xbf6>
    cf6a:	mov.w	r2, #4294967295
    cf6e:	lsl.w	r3, r2, r3
    cf72:	ldr	r2, [sp, #16]
    cf74:	ands	r2, r3
    cf76:	str	r2, [sp, #16]
    cf78:	b.n	cbc8 <_strtod_l+0xad0>
    cf7a:	strd	r0, r1, [sp, #16]
    cf7e:	b.n	c8b4 <_strtod_l+0x7bc>
    cf80:	strd	r0, r1, [sp, #16]
    cf84:	b.n	cb9c <_strtod_l+0xaa4>
    cf86:	subs	r3, #32
    cf88:	mov.w	r2, #4294967295
    cf8c:	lsl.w	r3, r2, r3
    cf90:	ands	r3, r1
    cf92:	str	r3, [sp, #20]
    cf94:	b.n	cbc8 <_strtod_l+0xad0>
    cf96:	mov	r0, r4
    cf98:	ldr	r1, [sp, #108]	; 0x6c
    cf9a:	adds	r4, #1
    cf9c:	b.n	cbf0 <_strtod_l+0xaf8>
    cf9e:	mov	r0, r1
    cfa0:	ldr	r1, [sp, #108]	; 0x6c
    cfa2:	b.n	cc04 <_strtod_l+0xb0c>
    cfa4:	nop.w
    cfa8:	.word	0x00000000
    cfac:	.word	0xbfe00000
    cfb0:	.word	0x00000000
    cfb4:	.word	0x3fe00000
    cfb8:	.word	0x000133f0
    cfbc:	.word	0x000fffff
    cfc0:	.word	0x39500000
    cfc4:	.word	0x7ff00000
    cfc8:	.word	0x7fefffff
    cfcc:	.word	0x00013108

0000cfd0 <_strtod_r>:
    cfd0:	ldr	r3, [pc, #20]	; (cfe8 <_strtod_r+0x18>)
    cfd2:	ldr	r3, [r3, #0]
    cfd4:	push	{r4}
    cfd6:	ldr	r3, [r3, #52]	; 0x34
    cfd8:	ldr	r4, [pc, #16]	; (cfec <_strtod_r+0x1c>)
    cfda:	cmp	r3, #0
    cfdc:	it	eq
    cfde:	moveq	r3, r4
    cfe0:	ldr.w	r4, [sp], #4
    cfe4:	b.w	c0f8 <_strtod_l>
    cfe8:	.word	0x1fff1848
    cfec:	.word	0x1fff184c

0000cff0 <_strtol_l.isra.0>:
    cff0:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cff4:	ldr.w	r9, [sp, #40]	; 0x28
    cff8:	mov	r7, r1
    cffa:	mov	r8, r0
    cffc:	mov	r6, r2
    cffe:	mov	r5, r3
    d000:	mov	fp, r1
    d002:	b.n	d006 <_strtol_l.isra.0+0x16>
    d004:	mov	fp, r4
    d006:	mov	r4, fp
    d008:	mov	r0, r9
    d00a:	ldrb.w	sl, [r4], #1
    d00e:	bl	b2b8 <__locale_ctype_ptr_l>
    d012:	add	r0, sl
    d014:	ldrb	r1, [r0, #1]
    d016:	and.w	r1, r1, #8
    d01a:	and.w	ip, r1, #255	; 0xff
    d01e:	cmp	r1, #0
    d020:	bne.n	d004 <_strtol_l.isra.0+0x14>
    d022:	mov	r2, sl
    d024:	cmp	r2, #45	; 0x2d
    d026:	beq.n	d0ec <_strtol_l.isra.0+0xfc>
    d028:	cmp	r2, #43	; 0x2b
    d02a:	itt	eq
    d02c:	ldrbeq.w	r2, [fp, #1]
    d030:	addeq.w	r4, fp, #2
    d034:	cmp	r5, #0
    d036:	beq.n	d0c0 <_strtol_l.isra.0+0xd0>
    d038:	cmp	r5, #16
    d03a:	beq.n	d108 <_strtol_l.isra.0+0x118>
    d03c:	mov	r9, r5
    d03e:	cmp.w	ip, #0
    d042:	ite	eq
    d044:	mvneq.w	sl, #2147483648	; 0x80000000
    d048:	movne.w	sl, #2147483648	; 0x80000000
    d04c:	movs	r1, #0
    d04e:	udiv	lr, sl, r9
    d052:	mov	r0, r1
    d054:	mls	sl, r9, lr, sl
    d058:	b.n	d066 <_strtol_l.isra.0+0x76>
    d05a:	beq.n	d0b0 <_strtol_l.isra.0+0xc0>
    d05c:	mla	r0, r9, r0, r3
    d060:	movs	r1, #1
    d062:	ldrb.w	r2, [r4], #1
    d066:	sub.w	r3, r2, #48	; 0x30
    d06a:	cmp	r3, #9
    d06c:	bls.n	d07a <_strtol_l.isra.0+0x8a>
    d06e:	sub.w	r3, r2, #65	; 0x41
    d072:	cmp	r3, #25
    d074:	bhi.n	d08c <_strtol_l.isra.0+0x9c>
    d076:	sub.w	r3, r2, #55	; 0x37
    d07a:	cmp	r5, r3
    d07c:	ble.n	d09c <_strtol_l.isra.0+0xac>
    d07e:	adds	r2, r1, #1
    d080:	beq.n	d062 <_strtol_l.isra.0+0x72>
    d082:	cmp	lr, r0
    d084:	bcs.n	d05a <_strtol_l.isra.0+0x6a>
    d086:	mov.w	r1, #4294967295
    d08a:	b.n	d062 <_strtol_l.isra.0+0x72>
    d08c:	sub.w	r3, r2, #97	; 0x61
    d090:	cmp	r3, #25
    d092:	bhi.n	d09c <_strtol_l.isra.0+0xac>
    d094:	sub.w	r3, r2, #87	; 0x57
    d098:	cmp	r5, r3
    d09a:	bgt.n	d07e <_strtol_l.isra.0+0x8e>
    d09c:	adds	r3, r1, #1
    d09e:	beq.n	d0cc <_strtol_l.isra.0+0xdc>
    d0a0:	cmp.w	ip, #0
    d0a4:	bne.n	d0c8 <_strtol_l.isra.0+0xd8>
    d0a6:	cbz	r6, d0bc <_strtol_l.isra.0+0xcc>
    d0a8:	cbnz	r1, d0e4 <_strtol_l.isra.0+0xf4>
    d0aa:	str	r7, [r6, #0]
    d0ac:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d0b0:	cmp	sl, r3
    d0b2:	bge.n	d05c <_strtol_l.isra.0+0x6c>
    d0b4:	mov	r0, lr
    d0b6:	mov.w	r1, #4294967295
    d0ba:	b.n	d062 <_strtol_l.isra.0+0x72>
    d0bc:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d0c0:	cmp	r2, #48	; 0x30
    d0c2:	beq.n	d0fa <_strtol_l.isra.0+0x10a>
    d0c4:	movs	r5, #10
    d0c6:	b.n	d03c <_strtol_l.isra.0+0x4c>
    d0c8:	negs	r0, r0
    d0ca:	b.n	d0a6 <_strtol_l.isra.0+0xb6>
    d0cc:	cmp.w	ip, #0
    d0d0:	mov.w	r3, #34	; 0x22
    d0d4:	ite	eq
    d0d6:	mvneq.w	r0, #2147483648	; 0x80000000
    d0da:	movne.w	r0, #2147483648	; 0x80000000
    d0de:	str.w	r3, [r8]
    d0e2:	cbz	r6, d122 <_strtol_l.isra.0+0x132>
    d0e4:	subs	r7, r4, #1
    d0e6:	str	r7, [r6, #0]
    d0e8:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d0ec:	add.w	r4, fp, #2
    d0f0:	ldrb.w	r2, [fp, #1]
    d0f4:	mov.w	ip, #1
    d0f8:	b.n	d034 <_strtol_l.isra.0+0x44>
    d0fa:	ldrb	r3, [r4, #0]
    d0fc:	and.w	r3, r3, #223	; 0xdf
    d100:	cmp	r3, #88	; 0x58
    d102:	beq.n	d116 <_strtol_l.isra.0+0x126>
    d104:	movs	r5, #8
    d106:	b.n	d03c <_strtol_l.isra.0+0x4c>
    d108:	cmp	r2, #48	; 0x30
    d10a:	bne.n	d03c <_strtol_l.isra.0+0x4c>
    d10c:	ldrb	r3, [r4, #0]
    d10e:	and.w	r3, r3, #223	; 0xdf
    d112:	cmp	r3, #88	; 0x58
    d114:	bne.n	d03c <_strtol_l.isra.0+0x4c>
    d116:	mov.w	r9, #16
    d11a:	ldrb	r2, [r4, #1]
    d11c:	mov	r5, r9
    d11e:	adds	r4, #2
    d120:	b.n	d03e <_strtol_l.isra.0+0x4e>
    d122:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d126:	nop

0000d128 <_strtol_r>:
    d128:	push	{r4, r5, lr}
    d12a:	ldr	r4, [pc, #24]	; (d144 <_strtol_r+0x1c>)
    d12c:	ldr	r5, [pc, #24]	; (d148 <_strtol_r+0x20>)
    d12e:	ldr	r4, [r4, #0]
    d130:	ldr	r4, [r4, #52]	; 0x34
    d132:	sub	sp, #12
    d134:	cmp	r4, #0
    d136:	it	eq
    d138:	moveq	r4, r5
    d13a:	str	r4, [sp, #0]
    d13c:	bl	cff0 <_strtol_l.isra.0>
    d140:	add	sp, #12
    d142:	pop	{r4, r5, pc}
    d144:	.word	0x1fff1848
    d148:	.word	0x1fff184c
    d14c:	.word	0xffffffff

0000d150 <_svfprintf_r>:
    d150:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d154:	sub	sp, #260	; 0x104
    d156:	mov	r4, r1
    d158:	str	r1, [sp, #20]
    d15a:	mov	r5, r2
    d15c:	str	r3, [sp, #40]	; 0x28
    d15e:	str	r0, [sp, #24]
    d160:	bl	111a8 <_localeconv_r>
    d164:	ldr	r3, [r0, #0]
    d166:	str	r3, [sp, #76]	; 0x4c
    d168:	mov	r0, r3
    d16a:	bl	bf40 <strlen>
    d16e:	ldrh	r3, [r4, #12]
    d170:	str	r0, [sp, #72]	; 0x48
    d172:	lsls	r6, r3, #24
    d174:	bpl.n	d17e <_svfprintf_r+0x2e>
    d176:	ldr	r3, [r4, #16]
    d178:	cmp	r3, #0
    d17a:	beq.w	e3e0 <_svfprintf_r+0x1290>
    d17e:	vldr	d7, [pc, #664]	; d418 <_svfprintf_r+0x2c8>
    d182:	movs	r3, #0
    d184:	vstr	d7, [sp, #64]	; 0x40
    d188:	str	r3, [sp, #56]	; 0x38
    d18a:	str	r3, [sp, #148]	; 0x94
    d18c:	str	r3, [sp, #144]	; 0x90
    d18e:	str	r3, [sp, #84]	; 0x54
    d190:	str	r3, [sp, #28]
    d192:	ldr.w	sl, [pc, #656]	; d424 <_svfprintf_r+0x2d4>
    d196:	add	r3, sp, #192	; 0xc0
    d198:	str	r3, [sp, #140]	; 0x8c
    d19a:	mov	r9, r3
    d19c:	mov	r8, r5
    d19e:	ldrb.w	r3, [r8]
    d1a2:	mov	r4, r8
    d1a4:	cbz	r3, d1e2 <_svfprintf_r+0x92>
    d1a6:	cmp	r3, #37	; 0x25
    d1a8:	bne.n	d1b0 <_svfprintf_r+0x60>
    d1aa:	b.n	d1e2 <_svfprintf_r+0x92>
    d1ac:	cmp	r3, #37	; 0x25
    d1ae:	beq.n	d1b8 <_svfprintf_r+0x68>
    d1b0:	ldrb.w	r3, [r4, #1]!
    d1b4:	cmp	r3, #0
    d1b6:	bne.n	d1ac <_svfprintf_r+0x5c>
    d1b8:	rsb	r5, r8, r4
    d1bc:	cbz	r5, d1e2 <_svfprintf_r+0x92>
    d1be:	ldr	r3, [sp, #144]	; 0x90
    d1c0:	ldr	r2, [sp, #148]	; 0x94
    d1c2:	str.w	r8, [r9]
    d1c6:	adds	r3, #1
    d1c8:	add	r2, r5
    d1ca:	cmp	r3, #7
    d1cc:	str.w	r5, [r9, #4]
    d1d0:	str	r2, [sp, #148]	; 0x94
    d1d2:	str	r3, [sp, #144]	; 0x90
    d1d4:	bgt.w	d324 <_svfprintf_r+0x1d4>
    d1d8:	add.w	r9, r9, #8
    d1dc:	ldr	r3, [sp, #28]
    d1de:	add	r3, r5
    d1e0:	str	r3, [sp, #28]
    d1e2:	ldrb	r3, [r4, #0]
    d1e4:	cmp	r3, #0
    d1e6:	beq.w	d336 <_svfprintf_r+0x1e6>
    d1ea:	movs	r3, #0
    d1ec:	mov	r2, r3
    d1ee:	strb.w	r3, [sp, #111]	; 0x6f
    d1f2:	mov	r1, r3
    d1f4:	str	r3, [sp, #32]
    d1f6:	str	r3, [sp, #12]
    d1f8:	mov.w	fp, #4294967295
    d1fc:	ldrb	r3, [r4, #1]
    d1fe:	add.w	r8, r4, #1
    d202:	mov	r5, fp
    d204:	add.w	r8, r8, #1
    d208:	sub.w	r0, r3, #32
    d20c:	cmp	r0, #88	; 0x58
    d20e:	bhi.w	da7a <_svfprintf_r+0x92a>
    d212:	tbh	[pc, r0, lsl #1]
    d216:	.short	0x03a0
    d218:	.word	0x04320432
    d21c:	.word	0x043203a8
    d220:	.word	0x04320432
    d224:	.word	0x04320432
    d228:	.word	0x03af0432
    d22c:	.word	0x043203bd
    d230:	.word	0x00e2005d
    d234:	.word	0x01090432
    d238:	.word	0x01100110
    d23c:	.word	0x01100110
    d240:	.word	0x01100110
    d244:	.word	0x01100110
    d248:	.word	0x04320110
    d24c:	.word	0x04320432
    d250:	.word	0x04320432
    d254:	.word	0x04320432
    d258:	.word	0x04320432
    d25c:	.word	0x01200432
    d260:	.word	0x04320286
    d264:	.word	0x04320286
    d268:	.word	0x04320432
    d26c:	.word	0x02d40432
    d270:	.word	0x04320432
    d274:	.word	0x043202e5
    d278:	.word	0x04320432
    d27c:	.word	0x04320432
    d280:	.word	0x0432030f
    d284:	.word	0x033d0432
    d288:	.word	0x04320432
    d28c:	.word	0x04320432
    d290:	.word	0x04320432
    d294:	.word	0x04320432
    d298:	.word	0x04320432
    d29c:	.word	0x0391037e
    d2a0:	.word	0x02860286
    d2a4:	.word	0x03990286
    d2a8:	.word	0x04320391
    d2ac:	.word	0x04070432
    d2b0:	.word	0x04120432
    d2b4:	.word	0x006400a3
    d2b8:	.word	0x043203c2
    d2bc:	.word	0x043203c9
    d2c0:	.word	0x043203ea
    d2c4:	.word	0x03f20432
    d2c8:	ldr	r0, [sp, #32]
    d2ca:	str	r3, [sp, #40]	; 0x28
    d2cc:	negs	r0, r0
    d2ce:	str	r0, [sp, #32]
    d2d0:	ldr	r3, [sp, #12]
    d2d2:	orr.w	r3, r3, #4
    d2d6:	str	r3, [sp, #12]
    d2d8:	ldrb.w	r3, [r8]
    d2dc:	b.n	d204 <_svfprintf_r+0xb4>
    d2de:	ldr	r0, [sp, #40]	; 0x28
    d2e0:	mov	fp, r5
    d2e2:	movs	r1, #0
    d2e4:	ldr	r4, [r0, #0]
    d2e6:	strb.w	r1, [sp, #111]	; 0x6f
    d2ea:	adds	r7, r0, #4
    d2ec:	ldr	r0, [sp, #12]
    d2ee:	movs	r3, #48	; 0x30
    d2f0:	movs	r2, #120	; 0x78
    d2f2:	cmp	fp, r1
    d2f4:	strb.w	r3, [sp, #112]	; 0x70
    d2f8:	mov.w	r5, #0
    d2fc:	strb.w	r2, [sp, #113]	; 0x71
    d300:	orr.w	r3, r0, #2
    d304:	blt.w	dab4 <_svfprintf_r+0x964>
    d308:	bic.w	r3, r0, #128	; 0x80
    d30c:	orr.w	r3, r3, #2
    d310:	str	r3, [sp, #12]
    d312:	orrs.w	r3, r4, r5
    d316:	str	r7, [sp, #40]	; 0x28
    d318:	beq.w	da60 <_svfprintf_r+0x910>
    d31c:	mov	r7, r1
    d31e:	str	r2, [sp, #52]	; 0x34
    d320:	ldr	r0, [pc, #252]	; (d420 <_svfprintf_r+0x2d0>)
    d322:	b.n	d8f2 <_svfprintf_r+0x7a2>
    d324:	add	r2, sp, #140	; 0x8c
    d326:	ldr	r1, [sp, #20]
    d328:	ldr	r0, [sp, #24]
    d32a:	bl	120f4 <__ssprint_r>
    d32e:	cbnz	r0, d344 <_svfprintf_r+0x1f4>
    d330:	add.w	r9, sp, #192	; 0xc0
    d334:	b.n	d1dc <_svfprintf_r+0x8c>
    d336:	ldr	r3, [sp, #148]	; 0x94
    d338:	cbz	r3, d344 <_svfprintf_r+0x1f4>
    d33a:	ldr	r0, [sp, #24]
    d33c:	ldr	r1, [sp, #20]
    d33e:	add	r2, sp, #140	; 0x8c
    d340:	bl	120f4 <__ssprint_r>
    d344:	ldr	r3, [sp, #20]
    d346:	ldrh	r3, [r3, #12]
    d348:	tst.w	r3, #64	; 0x40
    d34c:	ldr	r3, [sp, #28]
    d34e:	it	ne
    d350:	movne.w	r3, #4294967295
    d354:	mov	r0, r3
    d356:	add	sp, #260	; 0x104
    d358:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d35c:	str	r3, [sp, #52]	; 0x34
    d35e:	mov	fp, r5
    d360:	cmp	r2, #0
    d362:	bne.w	e7cc <_svfprintf_r+0x167c>
    d366:	ldr	r2, [sp, #12]
    d368:	ands.w	r3, r2, #32
    d36c:	beq.w	d7fc <_svfprintf_r+0x6ac>
    d370:	ldr	r7, [sp, #40]	; 0x28
    d372:	adds	r7, #7
    d374:	bic.w	r3, r7, #7
    d378:	movs	r7, #0
    d37a:	add.w	r1, r3, #8
    d37e:	cmp	fp, r7
    d380:	str	r1, [sp, #40]	; 0x28
    d382:	ldrd	r4, r5, [r3]
    d386:	strb.w	r7, [sp, #111]	; 0x6f
    d38a:	blt.w	e252 <_svfprintf_r+0x1102>
    d38e:	bic.w	r3, r2, #128	; 0x80
    d392:	str	r3, [sp, #12]
    d394:	orrs.w	r3, r4, r5
    d398:	beq.w	daa4 <_svfprintf_r+0x954>
    d39c:	add	r6, sp, #192	; 0xc0
    d39e:	lsrs	r2, r4, #3
    d3a0:	orr.w	r2, r2, r5, lsl #29
    d3a4:	lsrs	r1, r5, #3
    d3a6:	and.w	r3, r4, #7
    d3aa:	mov	r5, r1
    d3ac:	mov	r4, r2
    d3ae:	adds	r3, #48	; 0x30
    d3b0:	orrs.w	r2, r4, r5
    d3b4:	strb.w	r3, [r6, #-1]!
    d3b8:	bne.n	d39e <_svfprintf_r+0x24e>
    d3ba:	ldr	r2, [sp, #12]
    d3bc:	lsls	r1, r2, #31
    d3be:	bpl.w	d4e0 <_svfprintf_r+0x390>
    d3c2:	cmp	r3, #48	; 0x30
    d3c4:	beq.w	d4e0 <_svfprintf_r+0x390>
    d3c8:	movs	r2, #48	; 0x30
    d3ca:	subs	r3, r6, #1
    d3cc:	strb.w	r2, [r6, #-1]
    d3d0:	add	r2, sp, #192	; 0xc0
    d3d2:	subs	r2, r2, r3
    d3d4:	str	r2, [sp, #36]	; 0x24
    d3d6:	mov	r6, r3
    d3d8:	b.n	d4e6 <_svfprintf_r+0x396>
    d3da:	ldrb.w	r3, [r8]
    d3de:	cmp	r3, #42	; 0x2a
    d3e0:	add.w	r4, r8, #1
    d3e4:	beq.w	e7b0 <_svfprintf_r+0x1660>
    d3e8:	sub.w	r0, r3, #48	; 0x30
    d3ec:	cmp	r0, #9
    d3ee:	it	ls
    d3f0:	movls	r5, #0
    d3f2:	bhi.w	e702 <_svfprintf_r+0x15b2>
    d3f6:	ldrb.w	r3, [r4], #1
    d3fa:	add.w	r5, r5, r5, lsl #2
    d3fe:	add.w	r5, r0, r5, lsl #1
    d402:	sub.w	r0, r3, #48	; 0x30
    d406:	cmp	r0, #9
    d408:	bls.n	d3f6 <_svfprintf_r+0x2a6>
    d40a:	orr.w	r5, r5, r5, asr #31
    d40e:	mov	r8, r4
    d410:	b.n	d208 <_svfprintf_r+0xb8>
    d412:	nop
    d414:	nop.w
	...
    d420:	.word	0x0001317c
    d424:	.word	0x00013148
    d428:	ldr	r3, [sp, #12]
    d42a:	orr.w	r3, r3, #128	; 0x80
    d42e:	str	r3, [sp, #12]
    d430:	ldrb.w	r3, [r8]
    d434:	b.n	d204 <_svfprintf_r+0xb4>
    d436:	sub.w	r0, r3, #48	; 0x30
    d43a:	movs	r3, #0
    d43c:	mov	r4, r3
    d43e:	ldrb.w	r3, [r8], #1
    d442:	add.w	r4, r4, r4, lsl #2
    d446:	add.w	r4, r0, r4, lsl #1
    d44a:	sub.w	r0, r3, #48	; 0x30
    d44e:	cmp	r0, #9
    d450:	bls.n	d43e <_svfprintf_r+0x2ee>
    d452:	str	r4, [sp, #32]
    d454:	b.n	d208 <_svfprintf_r+0xb8>
    d456:	str	r3, [sp, #52]	; 0x34
    d458:	mov	fp, r5
    d45a:	cmp	r2, #0
    d45c:	bne.w	e7e8 <_svfprintf_r+0x1698>
    d460:	ldr	r3, [sp, #12]
    d462:	orr.w	r3, r3, #16
    d466:	str	r3, [sp, #12]
    d468:	ldr	r3, [sp, #12]
    d46a:	lsls	r4, r3, #26
    d46c:	bpl.w	dede <_svfprintf_r+0xd8e>
    d470:	ldr	r7, [sp, #40]	; 0x28
    d472:	adds	r7, #7
    d474:	bic.w	r7, r7, #7
    d478:	ldrd	r2, r3, [r7]
    d47c:	add.w	r1, r7, #8
    d480:	str	r1, [sp, #40]	; 0x28
    d482:	mov	r4, r2
    d484:	mov	r5, r3
    d486:	cmp	r2, #0
    d488:	sbcs.w	r3, r3, #0
    d48c:	blt.w	df54 <_svfprintf_r+0xe04>
    d490:	cmp.w	fp, #0
    d494:	ldrb.w	r7, [sp, #111]	; 0x6f
    d498:	blt.w	df1a <_svfprintf_r+0xdca>
    d49c:	ldr	r3, [sp, #12]
    d49e:	bic.w	r3, r3, #128	; 0x80
    d4a2:	str	r3, [sp, #12]
    d4a4:	orrs.w	r3, r4, r5
    d4a8:	beq.w	d87c <_svfprintf_r+0x72c>
    d4ac:	cmp	r5, #0
    d4ae:	it	eq
    d4b0:	cmpeq	r4, #10
    d4b2:	bcc.w	d886 <_svfprintf_r+0x736>
    d4b6:	add	r6, sp, #192	; 0xc0
    d4b8:	mov	r0, r4
    d4ba:	mov	r1, r5
    d4bc:	movs	r2, #10
    d4be:	movs	r3, #0
    d4c0:	bl	af04 <__aeabi_uldivmod>
    d4c4:	adds	r2, #48	; 0x30
    d4c6:	strb.w	r2, [r6, #-1]!
    d4ca:	mov	r0, r4
    d4cc:	mov	r1, r5
    d4ce:	movs	r3, #0
    d4d0:	movs	r2, #10
    d4d2:	bl	af04 <__aeabi_uldivmod>
    d4d6:	mov	r4, r0
    d4d8:	mov	r5, r1
    d4da:	orrs.w	r3, r4, r5
    d4de:	bne.n	d4b8 <_svfprintf_r+0x368>
    d4e0:	add	r3, sp, #192	; 0xc0
    d4e2:	subs	r3, r3, r6
    d4e4:	str	r3, [sp, #36]	; 0x24
    d4e6:	ldr	r3, [sp, #36]	; 0x24
    d4e8:	cmp	r3, fp
    d4ea:	it	lt
    d4ec:	movlt	r3, fp
    d4ee:	str	r3, [sp, #16]
    d4f0:	movs	r3, #0
    d4f2:	str	r3, [sp, #60]	; 0x3c
    d4f4:	cbz	r7, d4fc <_svfprintf_r+0x3ac>
    d4f6:	ldr	r3, [sp, #16]
    d4f8:	adds	r3, #1
    d4fa:	str	r3, [sp, #16]
    d4fc:	ldr	r3, [sp, #12]
    d4fe:	ands.w	r3, r3, #2
    d502:	str	r3, [sp, #44]	; 0x2c
    d504:	beq.n	d50c <_svfprintf_r+0x3bc>
    d506:	ldr	r3, [sp, #16]
    d508:	adds	r3, #2
    d50a:	str	r3, [sp, #16]
    d50c:	ldr	r3, [sp, #12]
    d50e:	ands.w	r3, r3, #132	; 0x84
    d512:	str	r3, [sp, #48]	; 0x30
    d514:	bne.w	dace <_svfprintf_r+0x97e>
    d518:	ldr	r3, [sp, #32]
    d51a:	ldr	r2, [sp, #16]
    d51c:	subs	r5, r3, r2
    d51e:	cmp	r5, #0
    d520:	ble.w	dace <_svfprintf_r+0x97e>
    d524:	cmp	r5, #16
    d526:	ldr	r1, [sp, #148]	; 0x94
    d528:	ldr	r2, [sp, #144]	; 0x90
    d52a:	ldr	r7, [pc, #672]	; (d7cc <_svfprintf_r+0x67c>)
    d52c:	ble.n	d57e <_svfprintf_r+0x42e>
    d52e:	str	r6, [sp, #80]	; 0x50
    d530:	mov	r0, r9
    d532:	movs	r4, #16
    d534:	mov	r9, r7
    d536:	ldr	r6, [sp, #20]
    d538:	mov	r7, r5
    d53a:	ldr	r5, [sp, #24]
    d53c:	b.n	d548 <_svfprintf_r+0x3f8>
    d53e:	subs	r7, #16
    d540:	cmp	r7, #16
    d542:	add.w	r0, r0, #8
    d546:	ble.n	d576 <_svfprintf_r+0x426>
    d548:	adds	r2, #1
    d54a:	ldr	r3, [pc, #640]	; (d7cc <_svfprintf_r+0x67c>)
    d54c:	str	r2, [sp, #144]	; 0x90
    d54e:	adds	r1, #16
    d550:	cmp	r2, #7
    d552:	str	r1, [sp, #148]	; 0x94
    d554:	stmia.w	r0, {r3, r4}
    d558:	ble.n	d53e <_svfprintf_r+0x3ee>
    d55a:	add	r2, sp, #140	; 0x8c
    d55c:	mov	r1, r6
    d55e:	mov	r0, r5
    d560:	bl	120f4 <__ssprint_r>
    d564:	cmp	r0, #0
    d566:	bne.w	d344 <_svfprintf_r+0x1f4>
    d56a:	subs	r7, #16
    d56c:	cmp	r7, #16
    d56e:	ldr	r1, [sp, #148]	; 0x94
    d570:	ldr	r2, [sp, #144]	; 0x90
    d572:	add	r0, sp, #192	; 0xc0
    d574:	bgt.n	d548 <_svfprintf_r+0x3f8>
    d576:	ldr	r6, [sp, #80]	; 0x50
    d578:	mov	r5, r7
    d57a:	mov	r7, r9
    d57c:	mov	r9, r0
    d57e:	adds	r2, #1
    d580:	adds	r4, r5, r1
    d582:	cmp	r2, #7
    d584:	str	r4, [sp, #148]	; 0x94
    d586:	str	r2, [sp, #144]	; 0x90
    d588:	str.w	r7, [r9]
    d58c:	str.w	r5, [r9, #4]
    d590:	bgt.w	ddee <_svfprintf_r+0xc9e>
    d594:	ldrb.w	r7, [sp, #111]	; 0x6f
    d598:	add.w	r9, r9, #8
    d59c:	cbz	r7, d5bc <_svfprintf_r+0x46c>
    d59e:	ldr	r3, [sp, #144]	; 0x90
    d5a0:	adds	r3, #1
    d5a2:	adds	r4, #1
    d5a4:	add.w	r1, sp, #111	; 0x6f
    d5a8:	movs	r2, #1
    d5aa:	cmp	r3, #7
    d5ac:	str	r4, [sp, #148]	; 0x94
    d5ae:	str	r3, [sp, #144]	; 0x90
    d5b0:	stmia.w	r9, {r1, r2}
    d5b4:	bgt.w	dd02 <_svfprintf_r+0xbb2>
    d5b8:	add.w	r9, r9, #8
    d5bc:	ldr	r3, [sp, #44]	; 0x2c
    d5be:	cbz	r3, d5dc <_svfprintf_r+0x48c>
    d5c0:	ldr	r3, [sp, #144]	; 0x90
    d5c2:	adds	r3, #1
    d5c4:	adds	r4, #2
    d5c6:	add	r1, sp, #112	; 0x70
    d5c8:	movs	r2, #2
    d5ca:	cmp	r3, #7
    d5cc:	str	r4, [sp, #148]	; 0x94
    d5ce:	str	r3, [sp, #144]	; 0x90
    d5d0:	stmia.w	r9, {r1, r2}
    d5d4:	bgt.w	dd1a <_svfprintf_r+0xbca>
    d5d8:	add.w	r9, r9, #8
    d5dc:	ldr	r3, [sp, #48]	; 0x30
    d5de:	cmp	r3, #128	; 0x80
    d5e0:	beq.w	dba6 <_svfprintf_r+0xa56>
    d5e4:	ldr	r3, [sp, #36]	; 0x24
    d5e6:	rsb	r7, r3, fp
    d5ea:	cmp	r7, #0
    d5ec:	ble.n	d656 <_svfprintf_r+0x506>
    d5ee:	ldr	r2, [pc, #480]	; (d7d0 <_svfprintf_r+0x680>)
    d5f0:	ldr	r3, [sp, #144]	; 0x90
    d5f2:	str	r2, [sp, #44]	; 0x2c
    d5f4:	cmp	r7, #16
    d5f6:	ble.n	d63e <_svfprintf_r+0x4ee>
    d5f8:	mov	r2, r4
    d5fa:	mov.w	fp, #16
    d5fe:	ldr	r5, [sp, #24]
    d600:	ldr	r4, [sp, #20]
    d602:	b.n	d60e <_svfprintf_r+0x4be>
    d604:	subs	r7, #16
    d606:	cmp	r7, #16
    d608:	add.w	r9, r9, #8
    d60c:	ble.n	d63c <_svfprintf_r+0x4ec>
    d60e:	adds	r3, #1
    d610:	adds	r2, #16
    d612:	cmp	r3, #7
    d614:	str	r2, [sp, #148]	; 0x94
    d616:	str	r3, [sp, #144]	; 0x90
    d618:	stmia.w	r9, {sl, fp}
    d61c:	ble.n	d604 <_svfprintf_r+0x4b4>
    d61e:	add	r2, sp, #140	; 0x8c
    d620:	mov	r1, r4
    d622:	mov	r0, r5
    d624:	bl	120f4 <__ssprint_r>
    d628:	cmp	r0, #0
    d62a:	bne.w	d344 <_svfprintf_r+0x1f4>
    d62e:	subs	r7, #16
    d630:	cmp	r7, #16
    d632:	ldr	r2, [sp, #148]	; 0x94
    d634:	ldr	r3, [sp, #144]	; 0x90
    d636:	add.w	r9, sp, #192	; 0xc0
    d63a:	bgt.n	d60e <_svfprintf_r+0x4be>
    d63c:	mov	r4, r2
    d63e:	adds	r3, #1
    d640:	ldr	r2, [sp, #44]	; 0x2c
    d642:	str	r3, [sp, #144]	; 0x90
    d644:	add	r4, r7
    d646:	cmp	r3, #7
    d648:	str	r4, [sp, #148]	; 0x94
    d64a:	stmia.w	r9, {r2, r7}
    d64e:	bgt.w	dcea <_svfprintf_r+0xb9a>
    d652:	add.w	r9, r9, #8
    d656:	ldr	r3, [sp, #12]
    d658:	lsls	r2, r3, #23
    d65a:	bmi.w	dad2 <_svfprintf_r+0x982>
    d65e:	ldr	r3, [sp, #144]	; 0x90
    d660:	ldr	r1, [sp, #36]	; 0x24
    d662:	str.w	r6, [r9]
    d666:	adds	r3, #1
    d668:	add	r4, r1
    d66a:	cmp	r3, #7
    d66c:	str	r4, [sp, #148]	; 0x94
    d66e:	str.w	r1, [r9, #4]
    d672:	str	r3, [sp, #144]	; 0x90
    d674:	bgt.w	dcbe <_svfprintf_r+0xb6e>
    d678:	add.w	r9, r9, #8
    d67c:	ldr	r3, [sp, #12]
    d67e:	lsls	r1, r3, #29
    d680:	bpl.n	d702 <_svfprintf_r+0x5b2>
    d682:	ldr	r3, [sp, #32]
    d684:	ldr	r2, [sp, #16]
    d686:	subs	r5, r3, r2
    d688:	cmp	r5, #0
    d68a:	ble.n	d702 <_svfprintf_r+0x5b2>
    d68c:	cmp	r5, #16
    d68e:	ldr	r3, [sp, #144]	; 0x90
    d690:	ldr	r7, [pc, #312]	; (d7cc <_svfprintf_r+0x67c>)
    d692:	ble.n	d6dc <_svfprintf_r+0x58c>
    d694:	mov	r2, r4
    d696:	movs	r6, #16
    d698:	ldr.w	fp, [sp, #24]
    d69c:	ldr	r4, [sp, #20]
    d69e:	b.n	d6aa <_svfprintf_r+0x55a>
    d6a0:	subs	r5, #16
    d6a2:	cmp	r5, #16
    d6a4:	add.w	r9, r9, #8
    d6a8:	ble.n	d6da <_svfprintf_r+0x58a>
    d6aa:	adds	r3, #1
    d6ac:	ldr	r1, [pc, #284]	; (d7cc <_svfprintf_r+0x67c>)
    d6ae:	str	r3, [sp, #144]	; 0x90
    d6b0:	adds	r2, #16
    d6b2:	cmp	r3, #7
    d6b4:	str	r2, [sp, #148]	; 0x94
    d6b6:	stmia.w	r9, {r1, r6}
    d6ba:	ble.n	d6a0 <_svfprintf_r+0x550>
    d6bc:	add	r2, sp, #140	; 0x8c
    d6be:	mov	r1, r4
    d6c0:	mov	r0, fp
    d6c2:	bl	120f4 <__ssprint_r>
    d6c6:	cmp	r0, #0
    d6c8:	bne.w	d344 <_svfprintf_r+0x1f4>
    d6cc:	subs	r5, #16
    d6ce:	cmp	r5, #16
    d6d0:	ldr	r2, [sp, #148]	; 0x94
    d6d2:	ldr	r3, [sp, #144]	; 0x90
    d6d4:	add.w	r9, sp, #192	; 0xc0
    d6d8:	bgt.n	d6aa <_svfprintf_r+0x55a>
    d6da:	mov	r4, r2
    d6dc:	adds	r3, #1
    d6de:	add	r4, r5
    d6e0:	cmp	r3, #7
    d6e2:	str	r4, [sp, #148]	; 0x94
    d6e4:	str	r3, [sp, #144]	; 0x90
    d6e6:	str.w	r7, [r9]
    d6ea:	str.w	r5, [r9, #4]
    d6ee:	ble.n	d702 <_svfprintf_r+0x5b2>
    d6f0:	add	r2, sp, #140	; 0x8c
    d6f2:	ldr	r1, [sp, #20]
    d6f4:	ldr	r0, [sp, #24]
    d6f6:	bl	120f4 <__ssprint_r>
    d6fa:	cmp	r0, #0
    d6fc:	bne.w	d344 <_svfprintf_r+0x1f4>
    d700:	ldr	r4, [sp, #148]	; 0x94
    d702:	ldr	r3, [sp, #28]
    d704:	ldr	r2, [sp, #32]
    d706:	ldr	r1, [sp, #16]
    d708:	cmp	r2, r1
    d70a:	ite	ge
    d70c:	addge	r3, r3, r2
    d70e:	addlt	r3, r3, r1
    d710:	str	r3, [sp, #28]
    d712:	cmp	r4, #0
    d714:	bne.w	dcd6 <_svfprintf_r+0xb86>
    d718:	movs	r3, #0
    d71a:	str	r3, [sp, #144]	; 0x90
    d71c:	add.w	r9, sp, #192	; 0xc0
    d720:	b.n	d19e <_svfprintf_r+0x4e>
    d722:	str	r3, [sp, #52]	; 0x34
    d724:	mov	fp, r5
    d726:	cmp	r2, #0
    d728:	bne.w	e7f0 <_svfprintf_r+0x16a0>
    d72c:	ldr	r3, [sp, #12]
    d72e:	ldr	r7, [sp, #40]	; 0x28
    d730:	lsls	r2, r3, #28
    d732:	add.w	r7, r7, #7
    d736:	bpl.w	e222 <_svfprintf_r+0x10d2>
    d73a:	bic.w	r3, r7, #7
    d73e:	vldr	d7, [r3]
    d742:	vstr	d7, [sp, #64]	; 0x40
    d746:	add.w	r2, r3, #8
    d74a:	str	r2, [sp, #40]	; 0x28
    d74c:	ldrd	r1, r2, [sp, #64]	; 0x40
    d750:	bic.w	r3, r2, #2147483648	; 0x80000000
    d754:	str	r1, [sp, #88]	; 0x58
    d756:	str	r3, [sp, #92]	; 0x5c
    d758:	ldrd	r4, r5, [sp, #88]	; 0x58
    d75c:	mov.w	r2, #4294967295
    d760:	mov	r0, r4
    d762:	mov	r1, r5
    d764:	ldr	r3, [pc, #108]	; (d7d4 <_svfprintf_r+0x684>)
    d766:	bl	ada8 <__aeabi_dcmpun>
    d76a:	cmp	r0, #0
    d76c:	bne.w	e124 <_svfprintf_r+0xfd4>
    d770:	mov.w	r2, #4294967295
    d774:	ldr	r3, [pc, #92]	; (d7d4 <_svfprintf_r+0x684>)
    d776:	mov	r0, r4
    d778:	mov	r1, r5
    d77a:	bl	ad6c <__aeabi_dcmple>
    d77e:	cmp	r0, #0
    d780:	bne.w	e124 <_svfprintf_r+0xfd4>
    d784:	movs	r2, #0
    d786:	movs	r3, #0
    d788:	ldrd	r0, r1, [sp, #64]	; 0x40
    d78c:	bl	ad58 <__aeabi_dcmplt>
    d790:	cmp	r0, #0
    d792:	bne.w	e63a <_svfprintf_r+0x14ea>
    d796:	ldrb.w	r7, [sp, #111]	; 0x6f
    d79a:	ldr	r6, [pc, #60]	; (d7d8 <_svfprintf_r+0x688>)
    d79c:	ldr	r3, [pc, #60]	; (d7dc <_svfprintf_r+0x68c>)
    d79e:	ldr	r1, [sp, #12]
    d7a0:	bic.w	r1, r1, #128	; 0x80
    d7a4:	str	r1, [sp, #12]
    d7a6:	ldr	r1, [sp, #52]	; 0x34
    d7a8:	movs	r2, #3
    d7aa:	mov.w	fp, #0
    d7ae:	str	r2, [sp, #16]
    d7b0:	cmp	r1, #71	; 0x47
    d7b2:	it	le
    d7b4:	movle	r6, r3
    d7b6:	str	r2, [sp, #36]	; 0x24
    d7b8:	str.w	fp, [sp, #60]	; 0x3c
    d7bc:	b.n	d4f4 <_svfprintf_r+0x3a4>
    d7be:	ldr	r3, [sp, #12]
    d7c0:	orr.w	r3, r3, #8
    d7c4:	str	r3, [sp, #12]
    d7c6:	ldrb.w	r3, [r8]
    d7ca:	b.n	d204 <_svfprintf_r+0xb4>
    d7cc:	.word	0x0001319c
    d7d0:	.word	0x00013148
    d7d4:	.word	0x7fefffff
    d7d8:	.word	0x0001315c
    d7dc:	.word	0x00013158
    d7e0:	str	r3, [sp, #52]	; 0x34
    d7e2:	mov	fp, r5
    d7e4:	cmp	r2, #0
    d7e6:	bne.w	e808 <_svfprintf_r+0x16b8>
    d7ea:	ldr	r3, [sp, #12]
    d7ec:	orr.w	r3, r3, #16
    d7f0:	str	r3, [sp, #12]
    d7f2:	ldr	r2, [sp, #12]
    d7f4:	ands.w	r3, r2, #32
    d7f8:	bne.w	d370 <_svfprintf_r+0x220>
    d7fc:	ldr	r1, [sp, #12]
    d7fe:	ands.w	r2, r1, #16
    d802:	beq.w	e0bc <_svfprintf_r+0xf6c>
    d806:	ldr	r0, [sp, #40]	; 0x28
    d808:	strb.w	r3, [sp, #111]	; 0x6f
    d80c:	cmp.w	fp, #0
    d810:	ldr	r4, [r0, #0]
    d812:	add.w	r7, r0, #4
    d816:	mov.w	r5, #0
    d81a:	blt.w	e250 <_svfprintf_r+0x1100>
    d81e:	mov	r2, r1
    d820:	bic.w	r2, r2, #128	; 0x80
    d824:	str	r2, [sp, #12]
    d826:	orrs.w	r2, r4, r5
    d82a:	str	r7, [sp, #40]	; 0x28
    d82c:	beq.w	daa4 <_svfprintf_r+0x954>
    d830:	mov	r7, r3
    d832:	b.n	d39c <_svfprintf_r+0x24c>
    d834:	str	r3, [sp, #52]	; 0x34
    d836:	mov	fp, r5
    d838:	cmp	r2, #0
    d83a:	bne.w	e800 <_svfprintf_r+0x16b0>
    d83e:	ldr	r3, [sp, #12]
    d840:	orr.w	r3, r3, #16
    d844:	str	r3, [sp, #12]
    d846:	ldr	r2, [sp, #12]
    d848:	ands.w	r3, r2, #32
    d84c:	beq.w	dea8 <_svfprintf_r+0xd58>
    d850:	ldr	r7, [sp, #40]	; 0x28
    d852:	adds	r7, #7
    d854:	bic.w	r3, r7, #7
    d858:	movs	r7, #0
    d85a:	add.w	r1, r3, #8
    d85e:	cmp	fp, r7
    d860:	str	r1, [sp, #40]	; 0x28
    d862:	ldrd	r4, r5, [r3]
    d866:	strb.w	r7, [sp, #111]	; 0x6f
    d86a:	blt.w	df1a <_svfprintf_r+0xdca>
    d86e:	bic.w	r3, r2, #128	; 0x80
    d872:	str	r3, [sp, #12]
    d874:	orrs.w	r3, r4, r5
    d878:	bne.w	d4ac <_svfprintf_r+0x35c>
    d87c:	cmp.w	fp, #0
    d880:	beq.w	da6e <_svfprintf_r+0x91e>
    d884:	movs	r4, #0
    d886:	add	r6, sp, #256	; 0x100
    d888:	adds	r4, #48	; 0x30
    d88a:	strb.w	r4, [r6, #-65]!
    d88e:	b.n	d4e0 <_svfprintf_r+0x390>
    d890:	str	r3, [sp, #52]	; 0x34
    d892:	mov	fp, r5
    d894:	cmp	r2, #0
    d896:	bne.w	e7f8 <_svfprintf_r+0x16a8>
    d89a:	ldr	r3, [sp, #12]
    d89c:	ldr	r0, [pc, #700]	; (db5c <_svfprintf_r+0xa0c>)
    d89e:	lsls	r5, r3, #26
    d8a0:	bpl.w	da0e <_svfprintf_r+0x8be>
    d8a4:	ldr	r7, [sp, #40]	; 0x28
    d8a6:	adds	r7, #7
    d8a8:	bic.w	r3, r7, #7
    d8ac:	ldrd	r4, r5, [r3]
    d8b0:	add.w	r2, r3, #8
    d8b4:	str	r2, [sp, #40]	; 0x28
    d8b6:	ldr	r2, [sp, #12]
    d8b8:	ands.w	r7, r2, #1
    d8bc:	beq.w	dd32 <_svfprintf_r+0xbe2>
    d8c0:	orrs.w	r3, r4, r5
    d8c4:	beq.w	e2cc <_svfprintf_r+0x117c>
    d8c8:	ldrb.w	r2, [sp, #52]	; 0x34
    d8cc:	strb.w	r2, [sp, #113]	; 0x71
    d8d0:	movs	r7, #0
    d8d2:	ldr	r2, [sp, #12]
    d8d4:	strb.w	r7, [sp, #111]	; 0x6f
    d8d8:	movs	r3, #48	; 0x30
    d8da:	cmp	fp, r7
    d8dc:	strb.w	r3, [sp, #112]	; 0x70
    d8e0:	orr.w	r3, r2, #2
    d8e4:	blt.w	e644 <_svfprintf_r+0x14f4>
    d8e8:	bic.w	r3, r2, #128	; 0x80
    d8ec:	orr.w	r3, r3, #2
    d8f0:	str	r3, [sp, #12]
    d8f2:	add	r6, sp, #192	; 0xc0
    d8f4:	lsrs	r3, r4, #4
    d8f6:	and.w	r1, r4, #15
    d8fa:	orr.w	r3, r3, r5, lsl #28
    d8fe:	lsrs	r2, r5, #4
    d900:	mov	r4, r3
    d902:	mov	r5, r2
    d904:	ldrb	r3, [r0, r1]
    d906:	strb.w	r3, [r6, #-1]!
    d90a:	orrs.w	r3, r4, r5
    d90e:	bne.n	d8f4 <_svfprintf_r+0x7a4>
    d910:	b.n	d4e0 <_svfprintf_r+0x390>
    d912:	ldr	r1, [sp, #40]	; 0x28
    d914:	str	r3, [sp, #52]	; 0x34
    d916:	ldr	r2, [r1, #0]
    d918:	strb.w	r2, [sp, #152]	; 0x98
    d91c:	movs	r3, #0
    d91e:	mov	r2, r1
    d920:	mov	r7, r3
    d922:	strb.w	r3, [sp, #111]	; 0x6f
    d926:	adds	r2, #4
    d928:	movs	r3, #1
    d92a:	str	r3, [sp, #16]
    d92c:	mov	fp, r7
    d92e:	str	r7, [sp, #60]	; 0x3c
    d930:	str	r2, [sp, #40]	; 0x28
    d932:	str	r3, [sp, #36]	; 0x24
    d934:	add	r6, sp, #152	; 0x98
    d936:	b.n	d4fc <_svfprintf_r+0x3ac>
    d938:	str	r3, [sp, #52]	; 0x34
    d93a:	mov	fp, r5
    d93c:	cmp	r2, #0
    d93e:	beq.w	d468 <_svfprintf_r+0x318>
    d942:	strb.w	r1, [sp, #111]	; 0x6f
    d946:	b.n	d468 <_svfprintf_r+0x318>
    d948:	ldr	r3, [sp, #12]
    d94a:	orr.w	r3, r3, #64	; 0x40
    d94e:	str	r3, [sp, #12]
    d950:	ldrb.w	r3, [r8]
    d954:	b.n	d204 <_svfprintf_r+0xb4>
    d956:	ldrb.w	r3, [r8]
    d95a:	cmp	r1, #0
    d95c:	bne.w	d204 <_svfprintf_r+0xb4>
    d960:	movs	r2, #1
    d962:	movs	r1, #32
    d964:	b.n	d204 <_svfprintf_r+0xb4>
    d966:	ldr	r3, [sp, #12]
    d968:	orr.w	r3, r3, #1
    d96c:	str	r3, [sp, #12]
    d96e:	ldrb.w	r3, [r8]
    d972:	b.n	d204 <_svfprintf_r+0xb4>
    d974:	ldr	r4, [sp, #40]	; 0x28
    d976:	ldr	r3, [r4, #0]
    d978:	str	r3, [sp, #32]
    d97a:	mov	r0, r3
    d97c:	cmp	r0, #0
    d97e:	mov	r3, r4
    d980:	add.w	r3, r3, #4
    d984:	blt.w	d2c8 <_svfprintf_r+0x178>
    d988:	str	r3, [sp, #40]	; 0x28
    d98a:	ldrb.w	r3, [r8]
    d98e:	b.n	d204 <_svfprintf_r+0xb4>
    d990:	ldrb.w	r3, [r8]
    d994:	movs	r2, #1
    d996:	movs	r1, #43	; 0x2b
    d998:	b.n	d204 <_svfprintf_r+0xb4>
    d99a:	ldr	r3, [sp, #12]
    d99c:	orr.w	r3, r3, #32
    d9a0:	str	r3, [sp, #12]
    d9a2:	ldrb.w	r3, [r8]
    d9a6:	b.n	d204 <_svfprintf_r+0xb4>
    d9a8:	ldr	r2, [sp, #40]	; 0x28
    d9aa:	str	r3, [sp, #52]	; 0x34
    d9ac:	ldr	r6, [r2, #0]
    d9ae:	movs	r4, #0
    d9b0:	strb.w	r4, [sp, #111]	; 0x6f
    d9b4:	adds	r7, r2, #4
    d9b6:	cmp	r6, #0
    d9b8:	beq.w	e5f4 <_svfprintf_r+0x14a4>
    d9bc:	cmp	r5, #0
    d9be:	blt.w	e484 <_svfprintf_r+0x1334>
    d9c2:	mov	r2, r5
    d9c4:	mov	r1, r4
    d9c6:	mov	r0, r6
    d9c8:	bl	b890 <memchr>
    d9cc:	cmp	r0, #0
    d9ce:	beq.w	e698 <_svfprintf_r+0x1548>
    d9d2:	subs	r3, r0, r6
    d9d4:	str	r3, [sp, #36]	; 0x24
    d9d6:	mov	fp, r4
    d9d8:	bic.w	r3, r3, r3, asr #31
    d9dc:	str	r7, [sp, #40]	; 0x28
    d9de:	str	r3, [sp, #16]
    d9e0:	str.w	fp, [sp, #60]	; 0x3c
    d9e4:	ldrb.w	r7, [sp, #111]	; 0x6f
    d9e8:	b.n	d4f4 <_svfprintf_r+0x3a4>
    d9ea:	str	r3, [sp, #52]	; 0x34
    d9ec:	mov	fp, r5
    d9ee:	cmp	r2, #0
    d9f0:	beq.w	d846 <_svfprintf_r+0x6f6>
    d9f4:	strb.w	r1, [sp, #111]	; 0x6f
    d9f8:	b.n	d846 <_svfprintf_r+0x6f6>
    d9fa:	str	r3, [sp, #52]	; 0x34
    d9fc:	mov	fp, r5
    d9fe:	cmp	r2, #0
    da00:	bne.w	e820 <_svfprintf_r+0x16d0>
    da04:	ldr	r3, [sp, #12]
    da06:	ldr	r0, [pc, #344]	; (db60 <_svfprintf_r+0xa10>)
    da08:	lsls	r5, r3, #26
    da0a:	bmi.w	d8a4 <_svfprintf_r+0x754>
    da0e:	ldr	r3, [sp, #12]
    da10:	lsls	r4, r3, #27
    da12:	bpl.w	e292 <_svfprintf_r+0x1142>
    da16:	ldr	r2, [sp, #40]	; 0x28
    da18:	mov	r3, r2
    da1a:	adds	r3, #4
    da1c:	ldr	r4, [r2, #0]
    da1e:	str	r3, [sp, #40]	; 0x28
    da20:	movs	r5, #0
    da22:	b.n	d8b6 <_svfprintf_r+0x766>
    da24:	ldrb.w	r3, [r8]
    da28:	cmp	r3, #108	; 0x6c
    da2a:	beq.w	e3b2 <_svfprintf_r+0x1262>
    da2e:	ldr	r0, [sp, #12]
    da30:	orr.w	r0, r0, #16
    da34:	str	r0, [sp, #12]
    da36:	b.w	d204 <_svfprintf_r+0xb4>
    da3a:	cmp	r2, #0
    da3c:	bne.w	e818 <_svfprintf_r+0x16c8>
    da40:	ldr	r3, [sp, #12]
    da42:	lsls	r3, r3, #26
    da44:	bpl.w	e0f6 <_svfprintf_r+0xfa6>
    da48:	ldr	r2, [sp, #40]	; 0x28
    da4a:	ldr	r1, [sp, #28]
    da4c:	ldr	r3, [r2, #0]
    da4e:	asrs	r5, r1, #31
    da50:	mov	r0, r1
    da52:	adds	r2, #4
    da54:	mov	r1, r5
    da56:	str	r2, [sp, #40]	; 0x28
    da58:	strd	r0, r1, [r3]
    da5c:	b.w	d19e <_svfprintf_r+0x4e>
    da60:	ldr	r0, [pc, #252]	; (db60 <_svfprintf_r+0xa10>)
    da62:	str	r2, [sp, #52]	; 0x34
    da64:	cmp.w	fp, #0
    da68:	bne.w	dd54 <_svfprintf_r+0xc04>
    da6c:	mov	r7, fp
    da6e:	mov.w	fp, #0
    da72:	str.w	fp, [sp, #36]	; 0x24
    da76:	add	r6, sp, #192	; 0xc0
    da78:	b.n	d4e6 <_svfprintf_r+0x396>
    da7a:	str	r3, [sp, #52]	; 0x34
    da7c:	cmp	r2, #0
    da7e:	bne.w	e810 <_svfprintf_r+0x16c0>
    da82:	ldr	r2, [sp, #52]	; 0x34
    da84:	cmp	r2, #0
    da86:	beq.w	d336 <_svfprintf_r+0x1e6>
    da8a:	movs	r3, #0
    da8c:	movs	r1, #1
    da8e:	mov	r7, r3
    da90:	str	r1, [sp, #16]
    da92:	strb.w	r2, [sp, #152]	; 0x98
    da96:	strb.w	r3, [sp, #111]	; 0x6f
    da9a:	mov	fp, r3
    da9c:	str	r3, [sp, #60]	; 0x3c
    da9e:	str	r1, [sp, #36]	; 0x24
    daa0:	add	r6, sp, #152	; 0x98
    daa2:	b.n	d4fc <_svfprintf_r+0x3ac>
    daa4:	cmp.w	fp, #0
    daa8:	beq.w	e6c8 <_svfprintf_r+0x1578>
    daac:	movs	r7, #0
    daae:	movs	r4, #0
    dab0:	movs	r5, #0
    dab2:	b.n	d39c <_svfprintf_r+0x24c>
    dab4:	ldr	r0, [pc, #168]	; (db60 <_svfprintf_r+0xa10>)
    dab6:	str	r3, [sp, #12]
    dab8:	str	r2, [sp, #52]	; 0x34
    daba:	orrs.w	r3, r4, r5
    dabe:	str	r7, [sp, #40]	; 0x28
    dac0:	mov.w	r7, #0
    dac4:	bne.w	d8f2 <_svfprintf_r+0x7a2>
    dac8:	movs	r4, #0
    daca:	movs	r5, #0
    dacc:	b.n	d8f2 <_svfprintf_r+0x7a2>
    dace:	ldr	r4, [sp, #148]	; 0x94
    dad0:	b.n	d59c <_svfprintf_r+0x44c>
    dad2:	ldr	r3, [sp, #52]	; 0x34
    dad4:	cmp	r3, #101	; 0x65
    dad6:	ble.w	dc2e <_svfprintf_r+0xade>
    dada:	movs	r2, #0
    dadc:	movs	r3, #0
    dade:	ldrd	r0, r1, [sp, #64]	; 0x40
    dae2:	bl	ad44 <__aeabi_dcmpeq>
    dae6:	cmp	r0, #0
    dae8:	beq.w	dd58 <_svfprintf_r+0xc08>
    daec:	ldr	r3, [sp, #144]	; 0x90
    daee:	ldr	r2, [pc, #116]	; (db64 <_svfprintf_r+0xa14>)
    daf0:	str.w	r2, [r9]
    daf4:	adds	r3, #1
    daf6:	adds	r4, #1
    daf8:	movs	r2, #1
    dafa:	cmp	r3, #7
    dafc:	str	r4, [sp, #148]	; 0x94
    dafe:	str	r3, [sp, #144]	; 0x90
    db00:	str.w	r2, [r9, #4]
    db04:	bgt.w	e2e4 <_svfprintf_r+0x1194>
    db08:	add.w	r9, r9, #8
    db0c:	ldr	r3, [sp, #116]	; 0x74
    db0e:	ldr	r2, [sp, #56]	; 0x38
    db10:	cmp	r3, r2
    db12:	blt.n	db1c <_svfprintf_r+0x9cc>
    db14:	ldr	r3, [sp, #12]
    db16:	lsls	r3, r3, #31
    db18:	bpl.w	d67c <_svfprintf_r+0x52c>
    db1c:	ldr	r3, [sp, #144]	; 0x90
    db1e:	ldr	r1, [sp, #72]	; 0x48
    db20:	ldr	r2, [sp, #76]	; 0x4c
    db22:	str.w	r2, [r9]
    db26:	adds	r3, #1
    db28:	add	r4, r1
    db2a:	cmp	r3, #7
    db2c:	str	r4, [sp, #148]	; 0x94
    db2e:	str.w	r1, [r9, #4]
    db32:	str	r3, [sp, #144]	; 0x90
    db34:	bgt.w	e3c6 <_svfprintf_r+0x1276>
    db38:	add.w	r9, r9, #8
    db3c:	ldr	r3, [sp, #56]	; 0x38
    db3e:	subs	r5, r3, #1
    db40:	cmp	r5, #0
    db42:	ble.w	d67c <_svfprintf_r+0x52c>
    db46:	ldr	r2, [pc, #32]	; (db68 <_svfprintf_r+0xa18>)
    db48:	ldr	r3, [sp, #144]	; 0x90
    db4a:	str	r2, [sp, #44]	; 0x2c
    db4c:	cmp	r5, #16
    db4e:	ble.w	df24 <_svfprintf_r+0xdd4>
    db52:	movs	r6, #16
    db54:	ldr	r7, [sp, #24]
    db56:	ldr.w	fp, [sp, #20]
    db5a:	b.n	db78 <_svfprintf_r+0xa28>
    db5c:	.word	0x00013168
    db60:	.word	0x0001317c
    db64:	.word	0x00013198
    db68:	.word	0x00013148
    db6c:	add.w	r9, r9, #8
    db70:	subs	r5, #16
    db72:	cmp	r5, #16
    db74:	ble.w	df24 <_svfprintf_r+0xdd4>
    db78:	adds	r3, #1
    db7a:	adds	r4, #16
    db7c:	cmp	r3, #7
    db7e:	str	r4, [sp, #148]	; 0x94
    db80:	str	r3, [sp, #144]	; 0x90
    db82:	str.w	sl, [r9]
    db86:	str.w	r6, [r9, #4]
    db8a:	ble.n	db6c <_svfprintf_r+0xa1c>
    db8c:	add	r2, sp, #140	; 0x8c
    db8e:	mov	r1, fp
    db90:	mov	r0, r7
    db92:	bl	120f4 <__ssprint_r>
    db96:	cmp	r0, #0
    db98:	bne.w	d344 <_svfprintf_r+0x1f4>
    db9c:	ldr	r4, [sp, #148]	; 0x94
    db9e:	ldr	r3, [sp, #144]	; 0x90
    dba0:	add.w	r9, sp, #192	; 0xc0
    dba4:	b.n	db70 <_svfprintf_r+0xa20>
    dba6:	ldr	r3, [sp, #32]
    dba8:	ldr	r2, [sp, #16]
    dbaa:	subs	r7, r3, r2
    dbac:	cmp	r7, #0
    dbae:	ble.w	d5e4 <_svfprintf_r+0x494>
    dbb2:	ldr	r2, [pc, #752]	; (dea4 <_svfprintf_r+0xd54>)
    dbb4:	ldr	r3, [sp, #144]	; 0x90
    dbb6:	str	r2, [sp, #44]	; 0x2c
    dbb8:	cmp	r7, #16
    dbba:	ble.n	dc14 <_svfprintf_r+0xac4>
    dbbc:	mov	r2, r9
    dbbe:	mov	r1, r4
    dbc0:	mov	r9, r7
    dbc2:	movs	r5, #16
    dbc4:	mov	r7, r6
    dbc6:	ldr	r4, [sp, #24]
    dbc8:	ldr	r6, [sp, #20]
    dbca:	b.n	dbda <_svfprintf_r+0xa8a>
    dbcc:	sub.w	r9, r9, #16
    dbd0:	cmp.w	r9, #16
    dbd4:	add.w	r2, r2, #8
    dbd8:	ble.n	dc0c <_svfprintf_r+0xabc>
    dbda:	adds	r3, #1
    dbdc:	adds	r1, #16
    dbde:	cmp	r3, #7
    dbe0:	str	r1, [sp, #148]	; 0x94
    dbe2:	str	r3, [sp, #144]	; 0x90
    dbe4:	str.w	sl, [r2]
    dbe8:	str	r5, [r2, #4]
    dbea:	ble.n	dbcc <_svfprintf_r+0xa7c>
    dbec:	add	r2, sp, #140	; 0x8c
    dbee:	mov	r1, r6
    dbf0:	mov	r0, r4
    dbf2:	bl	120f4 <__ssprint_r>
    dbf6:	cmp	r0, #0
    dbf8:	bne.w	d344 <_svfprintf_r+0x1f4>
    dbfc:	sub.w	r9, r9, #16
    dc00:	cmp.w	r9, #16
    dc04:	ldr	r1, [sp, #148]	; 0x94
    dc06:	ldr	r3, [sp, #144]	; 0x90
    dc08:	add	r2, sp, #192	; 0xc0
    dc0a:	bgt.n	dbda <_svfprintf_r+0xa8a>
    dc0c:	mov	r6, r7
    dc0e:	mov	r4, r1
    dc10:	mov	r7, r9
    dc12:	mov	r9, r2
    dc14:	adds	r3, #1
    dc16:	ldr	r2, [sp, #44]	; 0x2c
    dc18:	str	r3, [sp, #144]	; 0x90
    dc1a:	add	r4, r7
    dc1c:	cmp	r3, #7
    dc1e:	str	r4, [sp, #148]	; 0x94
    dc20:	stmia.w	r9, {r2, r7}
    dc24:	bgt.w	e0a2 <_svfprintf_r+0xf52>
    dc28:	add.w	r9, r9, #8
    dc2c:	b.n	d5e4 <_svfprintf_r+0x494>
    dc2e:	ldr	r3, [sp, #56]	; 0x38
    dc30:	ldr	r5, [sp, #144]	; 0x90
    dc32:	cmp	r3, #1
    dc34:	ble.w	e04c <_svfprintf_r+0xefc>
    dc38:	adds	r5, #1
    dc3a:	adds	r4, #1
    dc3c:	movs	r3, #1
    dc3e:	cmp	r5, #7
    dc40:	str	r4, [sp, #148]	; 0x94
    dc42:	str	r5, [sp, #144]	; 0x90
    dc44:	str.w	r6, [r9]
    dc48:	str.w	r3, [r9, #4]
    dc4c:	bgt.w	e06e <_svfprintf_r+0xf1e>
    dc50:	add.w	r9, r9, #8
    dc54:	ldr	r2, [sp, #72]	; 0x48
    dc56:	ldr	r3, [sp, #76]	; 0x4c
    dc58:	str.w	r3, [r9]
    dc5c:	adds	r5, #1
    dc5e:	add	r4, r2
    dc60:	cmp	r5, #7
    dc62:	str	r4, [sp, #148]	; 0x94
    dc64:	str	r5, [sp, #144]	; 0x90
    dc66:	str.w	r2, [r9, #4]
    dc6a:	bgt.w	e088 <_svfprintf_r+0xf38>
    dc6e:	add.w	r9, r9, #8
    dc72:	movs	r3, #0
    dc74:	movs	r2, #0
    dc76:	ldrd	r0, r1, [sp, #64]	; 0x40
    dc7a:	bl	ad44 <__aeabi_dcmpeq>
    dc7e:	ldr	r3, [sp, #56]	; 0x38
    dc80:	cmp	r0, #0
    dc82:	bne.w	de0c <_svfprintf_r+0xcbc>
    dc86:	subs	r3, #1
    dc88:	adds	r5, #1
    dc8a:	adds	r6, #1
    dc8c:	add	r4, r3
    dc8e:	cmp	r5, #7
    dc90:	str	r5, [sp, #144]	; 0x90
    dc92:	str	r4, [sp, #148]	; 0x94
    dc94:	str.w	r6, [r9]
    dc98:	str.w	r3, [r9, #4]
    dc9c:	bgt.w	de8a <_svfprintf_r+0xd3a>
    dca0:	add.w	r9, r9, #8
    dca4:	ldr	r2, [sp, #84]	; 0x54
    dca6:	str.w	r2, [r9, #4]
    dcaa:	adds	r5, #1
    dcac:	add	r4, r2
    dcae:	add	r3, sp, #124	; 0x7c
    dcb0:	cmp	r5, #7
    dcb2:	str	r4, [sp, #148]	; 0x94
    dcb4:	str	r5, [sp, #144]	; 0x90
    dcb6:	str.w	r3, [r9]
    dcba:	ble.w	d678 <_svfprintf_r+0x528>
    dcbe:	add	r2, sp, #140	; 0x8c
    dcc0:	ldr	r1, [sp, #20]
    dcc2:	ldr	r0, [sp, #24]
    dcc4:	bl	120f4 <__ssprint_r>
    dcc8:	cmp	r0, #0
    dcca:	bne.w	d344 <_svfprintf_r+0x1f4>
    dcce:	ldr	r4, [sp, #148]	; 0x94
    dcd0:	add.w	r9, sp, #192	; 0xc0
    dcd4:	b.n	d67c <_svfprintf_r+0x52c>
    dcd6:	add	r2, sp, #140	; 0x8c
    dcd8:	ldr	r1, [sp, #20]
    dcda:	ldr	r0, [sp, #24]
    dcdc:	bl	120f4 <__ssprint_r>
    dce0:	cmp	r0, #0
    dce2:	beq.w	d718 <_svfprintf_r+0x5c8>
    dce6:	b.w	d344 <_svfprintf_r+0x1f4>
    dcea:	add	r2, sp, #140	; 0x8c
    dcec:	ldr	r1, [sp, #20]
    dcee:	ldr	r0, [sp, #24]
    dcf0:	bl	120f4 <__ssprint_r>
    dcf4:	cmp	r0, #0
    dcf6:	bne.w	d344 <_svfprintf_r+0x1f4>
    dcfa:	ldr	r4, [sp, #148]	; 0x94
    dcfc:	add.w	r9, sp, #192	; 0xc0
    dd00:	b.n	d656 <_svfprintf_r+0x506>
    dd02:	add	r2, sp, #140	; 0x8c
    dd04:	ldr	r1, [sp, #20]
    dd06:	ldr	r0, [sp, #24]
    dd08:	bl	120f4 <__ssprint_r>
    dd0c:	cmp	r0, #0
    dd0e:	bne.w	d344 <_svfprintf_r+0x1f4>
    dd12:	ldr	r4, [sp, #148]	; 0x94
    dd14:	add.w	r9, sp, #192	; 0xc0
    dd18:	b.n	d5bc <_svfprintf_r+0x46c>
    dd1a:	add	r2, sp, #140	; 0x8c
    dd1c:	ldr	r1, [sp, #20]
    dd1e:	ldr	r0, [sp, #24]
    dd20:	bl	120f4 <__ssprint_r>
    dd24:	cmp	r0, #0
    dd26:	bne.w	d344 <_svfprintf_r+0x1f4>
    dd2a:	ldr	r4, [sp, #148]	; 0x94
    dd2c:	add.w	r9, sp, #192	; 0xc0
    dd30:	b.n	d5dc <_svfprintf_r+0x48c>
    dd32:	cmp.w	fp, #0
    dd36:	strb.w	r7, [sp, #111]	; 0x6f
    dd3a:	blt.w	e2fc <_svfprintf_r+0x11ac>
    dd3e:	bic.w	r3, r2, #128	; 0x80
    dd42:	str	r3, [sp, #12]
    dd44:	orrs.w	r3, r4, r5
    dd48:	bne.w	d8f2 <_svfprintf_r+0x7a2>
    dd4c:	cmp.w	fp, #0
    dd50:	beq.w	da6c <_svfprintf_r+0x91c>
    dd54:	movs	r7, #0
    dd56:	b.n	dac8 <_svfprintf_r+0x978>
    dd58:	ldr	r5, [sp, #116]	; 0x74
    dd5a:	cmp	r5, #0
    dd5c:	ble.w	e302 <_svfprintf_r+0x11b2>
    dd60:	ldr	r3, [sp, #60]	; 0x3c
    dd62:	ldr	r2, [sp, #56]	; 0x38
    dd64:	cmp	r3, r2
    dd66:	it	ge
    dd68:	movge	r3, r2
    dd6a:	cmp	r3, #0
    dd6c:	mov	r5, r3
    dd6e:	ble.n	dd8c <_svfprintf_r+0xc3c>
    dd70:	ldr	r3, [sp, #144]	; 0x90
    dd72:	str.w	r6, [r9]
    dd76:	adds	r3, #1
    dd78:	add	r4, r5
    dd7a:	cmp	r3, #7
    dd7c:	str	r4, [sp, #148]	; 0x94
    dd7e:	str.w	r5, [r9, #4]
    dd82:	str	r3, [sp, #144]	; 0x90
    dd84:	bgt.w	e4da <_svfprintf_r+0x138a>
    dd88:	add.w	r9, r9, #8
    dd8c:	ldr	r3, [sp, #60]	; 0x3c
    dd8e:	cmp	r5, #0
    dd90:	it	ge
    dd92:	subge	r3, r3, r5
    dd94:	cmp	r3, #0
    dd96:	mov	r5, r3
    dd98:	ble.w	df8c <_svfprintf_r+0xe3c>
    dd9c:	ldr	r2, [pc, #260]	; (dea4 <_svfprintf_r+0xd54>)
    dd9e:	ldr	r3, [sp, #144]	; 0x90
    dda0:	str	r2, [sp, #44]	; 0x2c
    dda2:	cmp	r5, #16
    dda4:	ble.w	e2ae <_svfprintf_r+0x115e>
    dda8:	mov	r2, r4
    ddaa:	movs	r7, #16
    ddac:	ldr.w	fp, [sp, #24]
    ddb0:	ldr	r4, [sp, #20]
    ddb2:	b.n	ddc0 <_svfprintf_r+0xc70>
    ddb4:	add.w	r9, r9, #8
    ddb8:	subs	r5, #16
    ddba:	cmp	r5, #16
    ddbc:	ble.w	e2ac <_svfprintf_r+0x115c>
    ddc0:	adds	r3, #1
    ddc2:	adds	r2, #16
    ddc4:	cmp	r3, #7
    ddc6:	str	r2, [sp, #148]	; 0x94
    ddc8:	str	r3, [sp, #144]	; 0x90
    ddca:	str.w	sl, [r9]
    ddce:	str.w	r7, [r9, #4]
    ddd2:	ble.n	ddb4 <_svfprintf_r+0xc64>
    ddd4:	add	r2, sp, #140	; 0x8c
    ddd6:	mov	r1, r4
    ddd8:	mov	r0, fp
    ddda:	bl	120f4 <__ssprint_r>
    ddde:	cmp	r0, #0
    dde0:	bne.w	d344 <_svfprintf_r+0x1f4>
    dde4:	ldr	r2, [sp, #148]	; 0x94
    dde6:	ldr	r3, [sp, #144]	; 0x90
    dde8:	add.w	r9, sp, #192	; 0xc0
    ddec:	b.n	ddb8 <_svfprintf_r+0xc68>
    ddee:	add	r2, sp, #140	; 0x8c
    ddf0:	ldr	r1, [sp, #20]
    ddf2:	ldr	r0, [sp, #24]
    ddf4:	bl	120f4 <__ssprint_r>
    ddf8:	cmp	r0, #0
    ddfa:	bne.w	d344 <_svfprintf_r+0x1f4>
    ddfe:	ldrb.w	r7, [sp, #111]	; 0x6f
    de02:	ldr	r4, [sp, #148]	; 0x94
    de04:	add.w	r9, sp, #192	; 0xc0
    de08:	b.w	d59c <_svfprintf_r+0x44c>
    de0c:	subs	r6, r3, #1
    de0e:	cmp	r6, #0
    de10:	ble.w	dca4 <_svfprintf_r+0xb54>
    de14:	ldr	r3, [pc, #140]	; (dea4 <_svfprintf_r+0xd54>)
    de16:	str	r3, [sp, #44]	; 0x2c
    de18:	cmp	r6, #16
    de1a:	ble.n	de76 <_svfprintf_r+0xd26>
    de1c:	str.w	r8, [sp, #36]	; 0x24
    de20:	movs	r7, #16
    de22:	mov	r8, r6
    de24:	ldr.w	fp, [sp, #24]
    de28:	ldr	r6, [sp, #20]
    de2a:	b.n	de3a <_svfprintf_r+0xcea>
    de2c:	sub.w	r8, r8, #16
    de30:	cmp.w	r8, #16
    de34:	add.w	r9, r9, #8
    de38:	ble.n	de70 <_svfprintf_r+0xd20>
    de3a:	adds	r5, #1
    de3c:	adds	r4, #16
    de3e:	cmp	r5, #7
    de40:	str	r4, [sp, #148]	; 0x94
    de42:	str	r5, [sp, #144]	; 0x90
    de44:	str.w	sl, [r9]
    de48:	str.w	r7, [r9, #4]
    de4c:	ble.n	de2c <_svfprintf_r+0xcdc>
    de4e:	add	r2, sp, #140	; 0x8c
    de50:	mov	r1, r6
    de52:	mov	r0, fp
    de54:	bl	120f4 <__ssprint_r>
    de58:	cmp	r0, #0
    de5a:	bne.w	d344 <_svfprintf_r+0x1f4>
    de5e:	sub.w	r8, r8, #16
    de62:	cmp.w	r8, #16
    de66:	ldr	r4, [sp, #148]	; 0x94
    de68:	ldr	r5, [sp, #144]	; 0x90
    de6a:	add.w	r9, sp, #192	; 0xc0
    de6e:	bgt.n	de3a <_svfprintf_r+0xcea>
    de70:	mov	r6, r8
    de72:	ldr.w	r8, [sp, #36]	; 0x24
    de76:	ldr	r3, [sp, #44]	; 0x2c
    de78:	adds	r5, #1
    de7a:	add	r4, r6
    de7c:	cmp	r5, #7
    de7e:	str	r4, [sp, #148]	; 0x94
    de80:	str	r5, [sp, #144]	; 0x90
    de82:	stmia.w	r9, {r3, r6}
    de86:	ble.w	dca0 <_svfprintf_r+0xb50>
    de8a:	add	r2, sp, #140	; 0x8c
    de8c:	ldr	r1, [sp, #20]
    de8e:	ldr	r0, [sp, #24]
    de90:	bl	120f4 <__ssprint_r>
    de94:	cmp	r0, #0
    de96:	bne.w	d344 <_svfprintf_r+0x1f4>
    de9a:	ldr	r4, [sp, #148]	; 0x94
    de9c:	ldr	r5, [sp, #144]	; 0x90
    de9e:	add.w	r9, sp, #192	; 0xc0
    dea2:	b.n	dca4 <_svfprintf_r+0xb54>
    dea4:	.word	0x00013148
    dea8:	ldr	r1, [sp, #12]
    deaa:	ands.w	r2, r1, #16
    deae:	beq.w	e258 <_svfprintf_r+0x1108>
    deb2:	ldr	r0, [sp, #40]	; 0x28
    deb4:	strb.w	r3, [sp, #111]	; 0x6f
    deb8:	cmp.w	fp, #0
    debc:	ldr	r4, [r0, #0]
    debe:	add.w	r7, r0, #4
    dec2:	mov.w	r5, #0
    dec6:	blt.n	df16 <_svfprintf_r+0xdc6>
    dec8:	mov	r2, r1
    deca:	bic.w	r2, r2, #128	; 0x80
    dece:	str	r2, [sp, #12]
    ded0:	orrs.w	r2, r4, r5
    ded4:	str	r7, [sp, #40]	; 0x28
    ded6:	mov	r7, r3
    ded8:	bne.w	d4ac <_svfprintf_r+0x35c>
    dedc:	b.n	d87c <_svfprintf_r+0x72c>
    dede:	ldr	r3, [sp, #12]
    dee0:	lsls	r0, r3, #27
    dee2:	bmi.n	df3a <_svfprintf_r+0xdea>
    dee4:	ldr	r3, [sp, #12]
    dee6:	lsls	r1, r3, #25
    dee8:	bpl.n	df3a <_svfprintf_r+0xdea>
    deea:	ldr	r1, [sp, #40]	; 0x28
    deec:	ldrsh.w	r4, [r1]
    def0:	adds	r1, #4
    def2:	asrs	r5, r4, #31
    def4:	mov	r2, r4
    def6:	mov	r3, r5
    def8:	str	r1, [sp, #40]	; 0x28
    defa:	b.w	d486 <_svfprintf_r+0x336>
    defe:	ldr	r1, [sp, #40]	; 0x28
    df00:	strb.w	r3, [sp, #111]	; 0x6f
    df04:	cmp.w	fp, #0
    df08:	ldr	r4, [r1, #0]
    df0a:	add.w	r7, r1, #4
    df0e:	mov.w	r5, #0
    df12:	bge.w	e3ae <_svfprintf_r+0x125e>
    df16:	str	r7, [sp, #40]	; 0x28
    df18:	mov	r7, r3
    df1a:	orrs.w	r3, r4, r5
    df1e:	bne.w	d4ac <_svfprintf_r+0x35c>
    df22:	b.n	d886 <_svfprintf_r+0x736>
    df24:	adds	r3, #1
    df26:	ldr	r2, [sp, #44]	; 0x2c
    df28:	str	r3, [sp, #144]	; 0x90
    df2a:	add	r4, r5
    df2c:	cmp	r3, #7
    df2e:	str	r4, [sp, #148]	; 0x94
    df30:	stmia.w	r9, {r2, r5}
    df34:	ble.w	d678 <_svfprintf_r+0x528>
    df38:	b.n	dcbe <_svfprintf_r+0xb6e>
    df3a:	ldr	r2, [sp, #40]	; 0x28
    df3c:	ldr	r4, [r2, #0]
    df3e:	mov	r3, r2
    df40:	adds	r3, #4
    df42:	asrs	r5, r4, #31
    df44:	mov	r2, r4
    df46:	str	r3, [sp, #40]	; 0x28
    df48:	cmp	r2, #0
    df4a:	mov	r3, r5
    df4c:	sbcs.w	r3, r3, #0
    df50:	bge.w	d490 <_svfprintf_r+0x340>
    df54:	negs	r4, r4
    df56:	mov.w	r7, #45	; 0x2d
    df5a:	sbc.w	r5, r5, r5, lsl #1
    df5e:	cmp.w	fp, #0
    df62:	strb.w	r7, [sp, #111]	; 0x6f
    df66:	blt.w	d4ac <_svfprintf_r+0x35c>
    df6a:	ldr	r3, [sp, #12]
    df6c:	bic.w	r3, r3, #128	; 0x80
    df70:	str	r3, [sp, #12]
    df72:	b.w	d4ac <_svfprintf_r+0x35c>
    df76:	add	r2, sp, #140	; 0x8c
    df78:	ldr	r1, [sp, #20]
    df7a:	ldr	r0, [sp, #24]
    df7c:	bl	120f4 <__ssprint_r>
    df80:	cmp	r0, #0
    df82:	bne.w	d344 <_svfprintf_r+0x1f4>
    df86:	ldr	r4, [sp, #148]	; 0x94
    df88:	add.w	r9, sp, #192	; 0xc0
    df8c:	ldr	r2, [sp, #60]	; 0x3c
    df8e:	ldr	r3, [sp, #116]	; 0x74
    df90:	add	r2, r6
    df92:	mov	r7, r2
    df94:	ldr	r2, [sp, #56]	; 0x38
    df96:	cmp	r3, r2
    df98:	blt.n	e02a <_svfprintf_r+0xeda>
    df9a:	ldr	r2, [sp, #12]
    df9c:	lsls	r5, r2, #31
    df9e:	bmi.n	e02a <_svfprintf_r+0xeda>
    dfa0:	ldr	r1, [sp, #56]	; 0x38
    dfa2:	add	r6, r1
    dfa4:	subs	r5, r6, r7
    dfa6:	subs	r3, r1, r3
    dfa8:	cmp	r5, r3
    dfaa:	it	ge
    dfac:	movge	r5, r3
    dfae:	cmp	r5, #0
    dfb0:	mov	r6, r5
    dfb2:	ble.n	dfd0 <_svfprintf_r+0xe80>
    dfb4:	ldr	r2, [sp, #144]	; 0x90
    dfb6:	str.w	r7, [r9]
    dfba:	adds	r2, #1
    dfbc:	add	r4, r5
    dfbe:	cmp	r2, #7
    dfc0:	str	r4, [sp, #148]	; 0x94
    dfc2:	str.w	r5, [r9, #4]
    dfc6:	str	r2, [sp, #144]	; 0x90
    dfc8:	bgt.w	e5c8 <_svfprintf_r+0x1478>
    dfcc:	add.w	r9, r9, #8
    dfd0:	cmp	r6, #0
    dfd2:	ite	ge
    dfd4:	subge	r5, r3, r6
    dfd6:	movlt	r5, r3
    dfd8:	cmp	r5, #0
    dfda:	ble.w	d67c <_svfprintf_r+0x52c>
    dfde:	ldr	r2, [pc, #744]	; (e2c8 <_svfprintf_r+0x1178>)
    dfe0:	ldr	r3, [sp, #144]	; 0x90
    dfe2:	str	r2, [sp, #44]	; 0x2c
    dfe4:	cmp	r5, #16
    dfe6:	ble.n	df24 <_svfprintf_r+0xdd4>
    dfe8:	movs	r6, #16
    dfea:	ldr	r7, [sp, #24]
    dfec:	ldr.w	fp, [sp, #20]
    dff0:	b.n	dffc <_svfprintf_r+0xeac>
    dff2:	add.w	r9, r9, #8
    dff6:	subs	r5, #16
    dff8:	cmp	r5, #16
    dffa:	ble.n	df24 <_svfprintf_r+0xdd4>
    dffc:	adds	r3, #1
    dffe:	adds	r4, #16
    e000:	cmp	r3, #7
    e002:	str	r4, [sp, #148]	; 0x94
    e004:	str	r3, [sp, #144]	; 0x90
    e006:	str.w	sl, [r9]
    e00a:	str.w	r6, [r9, #4]
    e00e:	ble.n	dff2 <_svfprintf_r+0xea2>
    e010:	add	r2, sp, #140	; 0x8c
    e012:	mov	r1, fp
    e014:	mov	r0, r7
    e016:	bl	120f4 <__ssprint_r>
    e01a:	cmp	r0, #0
    e01c:	bne.w	d344 <_svfprintf_r+0x1f4>
    e020:	ldr	r4, [sp, #148]	; 0x94
    e022:	ldr	r3, [sp, #144]	; 0x90
    e024:	add.w	r9, sp, #192	; 0xc0
    e028:	b.n	dff6 <_svfprintf_r+0xea6>
    e02a:	ldr	r2, [sp, #144]	; 0x90
    e02c:	ldr	r0, [sp, #72]	; 0x48
    e02e:	ldr	r1, [sp, #76]	; 0x4c
    e030:	str.w	r1, [r9]
    e034:	adds	r2, #1
    e036:	add	r4, r0
    e038:	cmp	r2, #7
    e03a:	str	r4, [sp, #148]	; 0x94
    e03c:	str.w	r0, [r9, #4]
    e040:	str	r2, [sp, #144]	; 0x90
    e042:	bgt.w	e5ae <_svfprintf_r+0x145e>
    e046:	add.w	r9, r9, #8
    e04a:	b.n	dfa0 <_svfprintf_r+0xe50>
    e04c:	ldr	r3, [sp, #12]
    e04e:	lsls	r0, r3, #31
    e050:	bmi.w	dc38 <_svfprintf_r+0xae8>
    e054:	adds	r5, #1
    e056:	adds	r4, #1
    e058:	movs	r3, #1
    e05a:	cmp	r5, #7
    e05c:	str	r4, [sp, #148]	; 0x94
    e05e:	str	r5, [sp, #144]	; 0x90
    e060:	str.w	r6, [r9]
    e064:	str.w	r3, [r9, #4]
    e068:	ble.w	dca0 <_svfprintf_r+0xb50>
    e06c:	b.n	de8a <_svfprintf_r+0xd3a>
    e06e:	add	r2, sp, #140	; 0x8c
    e070:	ldr	r1, [sp, #20]
    e072:	ldr	r0, [sp, #24]
    e074:	bl	120f4 <__ssprint_r>
    e078:	cmp	r0, #0
    e07a:	bne.w	d344 <_svfprintf_r+0x1f4>
    e07e:	ldr	r4, [sp, #148]	; 0x94
    e080:	ldr	r5, [sp, #144]	; 0x90
    e082:	add.w	r9, sp, #192	; 0xc0
    e086:	b.n	dc54 <_svfprintf_r+0xb04>
    e088:	add	r2, sp, #140	; 0x8c
    e08a:	ldr	r1, [sp, #20]
    e08c:	ldr	r0, [sp, #24]
    e08e:	bl	120f4 <__ssprint_r>
    e092:	cmp	r0, #0
    e094:	bne.w	d344 <_svfprintf_r+0x1f4>
    e098:	ldr	r4, [sp, #148]	; 0x94
    e09a:	ldr	r5, [sp, #144]	; 0x90
    e09c:	add.w	r9, sp, #192	; 0xc0
    e0a0:	b.n	dc72 <_svfprintf_r+0xb22>
    e0a2:	add	r2, sp, #140	; 0x8c
    e0a4:	ldr	r1, [sp, #20]
    e0a6:	ldr	r0, [sp, #24]
    e0a8:	bl	120f4 <__ssprint_r>
    e0ac:	cmp	r0, #0
    e0ae:	bne.w	d344 <_svfprintf_r+0x1f4>
    e0b2:	ldr	r4, [sp, #148]	; 0x94
    e0b4:	add.w	r9, sp, #192	; 0xc0
    e0b8:	b.w	d5e4 <_svfprintf_r+0x494>
    e0bc:	ldr	r1, [sp, #12]
    e0be:	ands.w	r3, r1, #64	; 0x40
    e0c2:	beq.w	e238 <_svfprintf_r+0x10e8>
    e0c6:	ldr	r0, [sp, #40]	; 0x28
    e0c8:	strb.w	r2, [sp, #111]	; 0x6f
    e0cc:	mov	r3, r0
    e0ce:	cmp.w	fp, #0
    e0d2:	add.w	r3, r3, #4
    e0d6:	ldrh	r4, [r0, #0]
    e0d8:	mov.w	r5, #0
    e0dc:	blt.w	e460 <_svfprintf_r+0x1310>
    e0e0:	bic.w	r1, r1, #128	; 0x80
    e0e4:	str	r1, [sp, #12]
    e0e6:	orrs.w	r1, r4, r5
    e0ea:	str	r3, [sp, #40]	; 0x28
    e0ec:	beq.w	daa4 <_svfprintf_r+0x954>
    e0f0:	mov	r7, r2
    e0f2:	b.w	d39c <_svfprintf_r+0x24c>
    e0f6:	ldr	r3, [sp, #12]
    e0f8:	lsls	r7, r3, #27
    e0fa:	bmi.n	e114 <_svfprintf_r+0xfc4>
    e0fc:	ldr	r3, [sp, #12]
    e0fe:	lsls	r6, r3, #25
    e100:	bpl.n	e114 <_svfprintf_r+0xfc4>
    e102:	ldr	r2, [sp, #40]	; 0x28
    e104:	ldr	r3, [r2, #0]
    e106:	adds	r2, #4
    e108:	str	r2, [sp, #40]	; 0x28
    e10a:	ldrh.w	r2, [sp, #28]
    e10e:	strh	r2, [r3, #0]
    e110:	b.w	d19e <_svfprintf_r+0x4e>
    e114:	ldr	r2, [sp, #40]	; 0x28
    e116:	ldr	r3, [r2, #0]
    e118:	adds	r2, #4
    e11a:	str	r2, [sp, #40]	; 0x28
    e11c:	ldr	r2, [sp, #28]
    e11e:	str	r2, [r3, #0]
    e120:	b.w	d19e <_svfprintf_r+0x4e>
    e124:	ldrd	r0, r1, [sp, #64]	; 0x40
    e128:	mov	r2, r0
    e12a:	mov	r3, r1
    e12c:	bl	ada8 <__aeabi_dcmpun>
    e130:	cmp	r0, #0
    e132:	bne.w	e730 <_svfprintf_r+0x15e0>
    e136:	ldr	r3, [sp, #52]	; 0x34
    e138:	cmp.w	fp, #4294967295
    e13c:	bic.w	r7, r3, #32
    e140:	beq.w	e612 <_svfprintf_r+0x14c2>
    e144:	cmp	r7, #71	; 0x47
    e146:	beq.w	e44e <_svfprintf_r+0x12fe>
    e14a:	ldr	r3, [sp, #68]	; 0x44
    e14c:	ldr	r2, [sp, #12]
    e14e:	cmp	r3, #0
    e150:	orr.w	r2, r2, #256	; 0x100
    e154:	str	r2, [sp, #44]	; 0x2c
    e156:	blt.w	e64a <_svfprintf_r+0x14fa>
    e15a:	vldr	d7, [sp, #64]	; 0x40
    e15e:	vstr	d7, [sp, #96]	; 0x60
    e162:	movs	r3, #0
    e164:	str	r3, [sp, #16]
    e166:	ldr	r3, [sp, #52]	; 0x34
    e168:	cmp	r3, #102	; 0x66
    e16a:	beq.w	e618 <_svfprintf_r+0x14c8>
    e16e:	cmp	r3, #70	; 0x46
    e170:	beq.w	e3fe <_svfprintf_r+0x12ae>
    e174:	cmp	r7, #69	; 0x45
    e176:	ite	eq
    e178:	addeq.w	r5, fp, #1
    e17c:	movne	r5, fp
    e17e:	add	r2, sp, #132	; 0x84
    e180:	add	r3, sp, #120	; 0x78
    e182:	str	r2, [sp, #4]
    e184:	str	r3, [sp, #0]
    e186:	mov	r2, r5
    e188:	add	r3, sp, #116	; 0x74
    e18a:	movs	r1, #2
    e18c:	vldr	d0, [sp, #96]	; 0x60
    e190:	ldr	r0, [sp, #24]
    e192:	bl	f958 <_dtoa_r>
    e196:	ldr	r3, [sp, #52]	; 0x34
    e198:	cmp	r3, #103	; 0x67
    e19a:	mov	r6, r0
    e19c:	bne.w	e676 <_svfprintf_r+0x1526>
    e1a0:	ldr	r3, [sp, #12]
    e1a2:	lsls	r2, r3, #31
    e1a4:	bpl.w	e71a <_svfprintf_r+0x15ca>
    e1a8:	adds	r4, r6, r5
    e1aa:	movs	r2, #0
    e1ac:	movs	r3, #0
    e1ae:	ldrd	r0, r1, [sp, #96]	; 0x60
    e1b2:	bl	ad44 <__aeabi_dcmpeq>
    e1b6:	cmp	r0, #0
    e1b8:	bne.w	e4d6 <_svfprintf_r+0x1386>
    e1bc:	ldr	r3, [sp, #132]	; 0x84
    e1be:	cmp	r4, r3
    e1c0:	bls.n	e1d0 <_svfprintf_r+0x1080>
    e1c2:	movs	r1, #48	; 0x30
    e1c4:	adds	r2, r3, #1
    e1c6:	str	r2, [sp, #132]	; 0x84
    e1c8:	strb	r1, [r3, #0]
    e1ca:	ldr	r3, [sp, #132]	; 0x84
    e1cc:	cmp	r4, r3
    e1ce:	bhi.n	e1c4 <_svfprintf_r+0x1074>
    e1d0:	subs	r3, r3, r6
    e1d2:	cmp	r7, #71	; 0x47
    e1d4:	str	r3, [sp, #56]	; 0x38
    e1d6:	beq.w	e4c8 <_svfprintf_r+0x1378>
    e1da:	ldr	r3, [sp, #52]	; 0x34
    e1dc:	cmp	r3, #101	; 0x65
    e1de:	ble.w	e694 <_svfprintf_r+0x1544>
    e1e2:	ldr	r3, [sp, #52]	; 0x34
    e1e4:	cmp	r3, #102	; 0x66
    e1e6:	ldr	r3, [sp, #116]	; 0x74
    e1e8:	str	r3, [sp, #60]	; 0x3c
    e1ea:	beq.w	e6ae <_svfprintf_r+0x155e>
    e1ee:	ldr	r2, [sp, #60]	; 0x3c
    e1f0:	ldr	r1, [sp, #56]	; 0x38
    e1f2:	cmp	r2, r1
    e1f4:	blt.w	e65c <_svfprintf_r+0x150c>
    e1f8:	ldr	r3, [sp, #12]
    e1fa:	lsls	r1, r3, #31
    e1fc:	bmi.w	e71e <_svfprintf_r+0x15ce>
    e200:	bic.w	r3, r2, r2, asr #31
    e204:	str	r2, [sp, #36]	; 0x24
    e206:	movs	r2, #103	; 0x67
    e208:	str	r2, [sp, #52]	; 0x34
    e20a:	ldr	r2, [sp, #16]
    e20c:	cmp	r2, #0
    e20e:	bne.w	e470 <_svfprintf_r+0x1320>
    e212:	str	r3, [sp, #16]
    e214:	ldr	r3, [sp, #44]	; 0x2c
    e216:	str	r3, [sp, #12]
    e218:	mov	fp, r2
    e21a:	ldrb.w	r7, [sp, #111]	; 0x6f
    e21e:	b.w	d4f4 <_svfprintf_r+0x3a4>
    e222:	bic.w	r7, r7, #7
    e226:	vldr	d7, [r7]
    e22a:	add.w	r3, r7, #8
    e22e:	vstr	d7, [sp, #64]	; 0x40
    e232:	str	r3, [sp, #40]	; 0x28
    e234:	b.w	d74c <_svfprintf_r+0x5fc>
    e238:	ldr	r1, [sp, #40]	; 0x28
    e23a:	strb.w	r3, [sp, #111]	; 0x6f
    e23e:	cmp.w	fp, #0
    e242:	ldr	r4, [r1, #0]
    e244:	add.w	r7, r1, #4
    e248:	mov.w	r5, #0
    e24c:	bge.w	e3a8 <_svfprintf_r+0x1258>
    e250:	str	r7, [sp, #40]	; 0x28
    e252:	movs	r7, #0
    e254:	b.w	d39c <_svfprintf_r+0x24c>
    e258:	ldr	r1, [sp, #12]
    e25a:	ands.w	r3, r1, #64	; 0x40
    e25e:	beq.w	defe <_svfprintf_r+0xdae>
    e262:	ldr	r0, [sp, #40]	; 0x28
    e264:	strb.w	r2, [sp, #111]	; 0x6f
    e268:	mov	r3, r0
    e26a:	cmp.w	fp, #0
    e26e:	add.w	r3, r3, #4
    e272:	ldrh	r4, [r0, #0]
    e274:	mov.w	r5, #0
    e278:	blt.w	e45a <_svfprintf_r+0x130a>
    e27c:	bic.w	r1, r1, #128	; 0x80
    e280:	str	r1, [sp, #12]
    e282:	orrs.w	r1, r4, r5
    e286:	str	r3, [sp, #40]	; 0x28
    e288:	mov	r7, r2
    e28a:	bne.w	d4ac <_svfprintf_r+0x35c>
    e28e:	b.w	d87c <_svfprintf_r+0x72c>
    e292:	ldr	r3, [sp, #12]
    e294:	ldr	r2, [sp, #40]	; 0x28
    e296:	tst.w	r3, #64	; 0x40
    e29a:	mov	r3, r2
    e29c:	beq.w	e464 <_svfprintf_r+0x1314>
    e2a0:	adds	r3, #4
    e2a2:	ldrh	r4, [r2, #0]
    e2a4:	str	r3, [sp, #40]	; 0x28
    e2a6:	movs	r5, #0
    e2a8:	b.w	d8b6 <_svfprintf_r+0x766>
    e2ac:	mov	r4, r2
    e2ae:	adds	r3, #1
    e2b0:	ldr	r2, [sp, #44]	; 0x2c
    e2b2:	str	r3, [sp, #144]	; 0x90
    e2b4:	add	r4, r5
    e2b6:	cmp	r3, #7
    e2b8:	str	r4, [sp, #148]	; 0x94
    e2ba:	stmia.w	r9, {r2, r5}
    e2be:	bgt.w	df76 <_svfprintf_r+0xe26>
    e2c2:	add.w	r9, r9, #8
    e2c6:	b.n	df8c <_svfprintf_r+0xe3c>
    e2c8:	.word	0x00013148
    e2cc:	movs	r7, #0
    e2ce:	cmp	fp, r7
    e2d0:	strb.w	r7, [sp, #111]	; 0x6f
    e2d4:	blt.w	dac8 <_svfprintf_r+0x978>
    e2d8:	ldr	r3, [sp, #12]
    e2da:	bic.w	r3, r3, #128	; 0x80
    e2de:	str	r3, [sp, #12]
    e2e0:	b.w	da64 <_svfprintf_r+0x914>
    e2e4:	add	r2, sp, #140	; 0x8c
    e2e6:	ldr	r1, [sp, #20]
    e2e8:	ldr	r0, [sp, #24]
    e2ea:	bl	120f4 <__ssprint_r>
    e2ee:	cmp	r0, #0
    e2f0:	bne.w	d344 <_svfprintf_r+0x1f4>
    e2f4:	ldr	r4, [sp, #148]	; 0x94
    e2f6:	add.w	r9, sp, #192	; 0xc0
    e2fa:	b.n	db0c <_svfprintf_r+0x9bc>
    e2fc:	ldr	r7, [sp, #40]	; 0x28
    e2fe:	b.w	daba <_svfprintf_r+0x96a>
    e302:	ldr	r3, [sp, #144]	; 0x90
    e304:	ldr	r2, [pc, #736]	; (e5e8 <_svfprintf_r+0x1498>)
    e306:	str.w	r2, [r9]
    e30a:	adds	r3, #1
    e30c:	adds	r4, #1
    e30e:	movs	r2, #1
    e310:	cmp	r3, #7
    e312:	str	r4, [sp, #148]	; 0x94
    e314:	str	r3, [sp, #144]	; 0x90
    e316:	str.w	r2, [r9, #4]
    e31a:	bgt.w	e434 <_svfprintf_r+0x12e4>
    e31e:	add.w	r9, r9, #8
    e322:	cbnz	r5, e330 <_svfprintf_r+0x11e0>
    e324:	ldr	r3, [sp, #56]	; 0x38
    e326:	cbnz	r3, e330 <_svfprintf_r+0x11e0>
    e328:	ldr	r3, [sp, #12]
    e32a:	lsls	r7, r3, #31
    e32c:	bpl.w	d67c <_svfprintf_r+0x52c>
    e330:	ldr	r3, [sp, #144]	; 0x90
    e332:	ldr	r1, [sp, #72]	; 0x48
    e334:	ldr	r2, [sp, #76]	; 0x4c
    e336:	str.w	r2, [r9]
    e33a:	adds	r3, #1
    e33c:	add	r4, r1
    e33e:	cmp	r3, #7
    e340:	str	r4, [sp, #148]	; 0x94
    e342:	str.w	r1, [r9, #4]
    e346:	str	r3, [sp, #144]	; 0x90
    e348:	bgt.w	e6e6 <_svfprintf_r+0x1596>
    e34c:	add.w	r9, r9, #8
    e350:	negs	r5, r5
    e352:	cmp	r5, #0
    e354:	ble.w	e4ac <_svfprintf_r+0x135c>
    e358:	ldr	r2, [pc, #656]	; (e5ec <_svfprintf_r+0x149c>)
    e35a:	str	r2, [sp, #44]	; 0x2c
    e35c:	cmp	r5, #16
    e35e:	ble.w	e4f4 <_svfprintf_r+0x13a4>
    e362:	mov	r2, r4
    e364:	movs	r7, #16
    e366:	ldr.w	fp, [sp, #24]
    e36a:	ldr	r4, [sp, #20]
    e36c:	b.n	e37a <_svfprintf_r+0x122a>
    e36e:	add.w	r9, r9, #8
    e372:	subs	r5, #16
    e374:	cmp	r5, #16
    e376:	ble.w	e4f2 <_svfprintf_r+0x13a2>
    e37a:	adds	r3, #1
    e37c:	adds	r2, #16
    e37e:	cmp	r3, #7
    e380:	str	r2, [sp, #148]	; 0x94
    e382:	str	r3, [sp, #144]	; 0x90
    e384:	str.w	sl, [r9]
    e388:	str.w	r7, [r9, #4]
    e38c:	ble.n	e36e <_svfprintf_r+0x121e>
    e38e:	add	r2, sp, #140	; 0x8c
    e390:	mov	r1, r4
    e392:	mov	r0, fp
    e394:	bl	120f4 <__ssprint_r>
    e398:	cmp	r0, #0
    e39a:	bne.w	d344 <_svfprintf_r+0x1f4>
    e39e:	ldr	r2, [sp, #148]	; 0x94
    e3a0:	ldr	r3, [sp, #144]	; 0x90
    e3a2:	add.w	r9, sp, #192	; 0xc0
    e3a6:	b.n	e372 <_svfprintf_r+0x1222>
    e3a8:	ldr	r2, [sp, #12]
    e3aa:	b.w	d820 <_svfprintf_r+0x6d0>
    e3ae:	ldr	r2, [sp, #12]
    e3b0:	b.n	deca <_svfprintf_r+0xd7a>
    e3b2:	ldr	r3, [sp, #12]
    e3b4:	orr.w	r3, r3, #32
    e3b8:	str	r3, [sp, #12]
    e3ba:	add.w	r8, r8, #1
    e3be:	ldrb.w	r3, [r8]
    e3c2:	b.w	d204 <_svfprintf_r+0xb4>
    e3c6:	add	r2, sp, #140	; 0x8c
    e3c8:	ldr	r1, [sp, #20]
    e3ca:	ldr	r0, [sp, #24]
    e3cc:	bl	120f4 <__ssprint_r>
    e3d0:	cmp	r0, #0
    e3d2:	bne.w	d344 <_svfprintf_r+0x1f4>
    e3d6:	ldr	r4, [sp, #148]	; 0x94
    e3d8:	add.w	r9, sp, #192	; 0xc0
    e3dc:	b.w	db3c <_svfprintf_r+0x9ec>
    e3e0:	movs	r1, #64	; 0x40
    e3e2:	ldr	r0, [sp, #24]
    e3e4:	bl	b2f4 <_malloc_r>
    e3e8:	ldr	r2, [sp, #20]
    e3ea:	str	r0, [r2, #0]
    e3ec:	str	r0, [r2, #16]
    e3ee:	cmp	r0, #0
    e3f0:	beq.w	e7da <_svfprintf_r+0x168a>
    e3f4:	ldr	r2, [sp, #20]
    e3f6:	movs	r3, #64	; 0x40
    e3f8:	str	r3, [r2, #20]
    e3fa:	b.w	d17e <_svfprintf_r+0x2e>
    e3fe:	add	r2, sp, #132	; 0x84
    e400:	add	r3, sp, #120	; 0x78
    e402:	str	r2, [sp, #4]
    e404:	str	r3, [sp, #0]
    e406:	mov	r2, fp
    e408:	add	r3, sp, #116	; 0x74
    e40a:	movs	r1, #3
    e40c:	vldr	d0, [sp, #96]	; 0x60
    e410:	ldr	r0, [sp, #24]
    e412:	bl	f958 <_dtoa_r>
    e416:	mov	r5, fp
    e418:	mov	r6, r0
    e41a:	ldr	r3, [sp, #52]	; 0x34
    e41c:	cmp	r3, #70	; 0x46
    e41e:	add.w	r4, r6, r5
    e422:	bne.w	e1aa <_svfprintf_r+0x105a>
    e426:	ldrb	r3, [r6, #0]
    e428:	cmp	r3, #48	; 0x30
    e42a:	beq.w	e73c <_svfprintf_r+0x15ec>
    e42e:	ldr	r5, [sp, #116]	; 0x74
    e430:	add	r4, r5
    e432:	b.n	e1aa <_svfprintf_r+0x105a>
    e434:	add	r2, sp, #140	; 0x8c
    e436:	ldr	r1, [sp, #20]
    e438:	ldr	r0, [sp, #24]
    e43a:	bl	120f4 <__ssprint_r>
    e43e:	cmp	r0, #0
    e440:	bne.w	d344 <_svfprintf_r+0x1f4>
    e444:	ldr	r5, [sp, #116]	; 0x74
    e446:	ldr	r4, [sp, #148]	; 0x94
    e448:	add.w	r9, sp, #192	; 0xc0
    e44c:	b.n	e322 <_svfprintf_r+0x11d2>
    e44e:	cmp.w	fp, #0
    e452:	it	eq
    e454:	moveq.w	fp, #1
    e458:	b.n	e14a <_svfprintf_r+0xffa>
    e45a:	str	r3, [sp, #40]	; 0x28
    e45c:	mov	r7, r2
    e45e:	b.n	df1a <_svfprintf_r+0xdca>
    e460:	str	r3, [sp, #40]	; 0x28
    e462:	b.n	e252 <_svfprintf_r+0x1102>
    e464:	adds	r3, #4
    e466:	ldr	r4, [r2, #0]
    e468:	str	r3, [sp, #40]	; 0x28
    e46a:	movs	r5, #0
    e46c:	b.w	d8b6 <_svfprintf_r+0x766>
    e470:	movs	r7, #45	; 0x2d
    e472:	str	r3, [sp, #16]
    e474:	ldr	r3, [sp, #44]	; 0x2c
    e476:	str	r3, [sp, #12]
    e478:	strb.w	r7, [sp, #111]	; 0x6f
    e47c:	mov.w	fp, #0
    e480:	b.w	d4f6 <_svfprintf_r+0x3a6>
    e484:	mov	r0, r6
    e486:	bl	bf40 <strlen>
    e48a:	mov	fp, r4
    e48c:	mov	r3, r0
    e48e:	str	r0, [sp, #36]	; 0x24
    e490:	b.w	d9d8 <_svfprintf_r+0x888>
    e494:	add	r2, sp, #140	; 0x8c
    e496:	ldr	r1, [sp, #20]
    e498:	ldr	r0, [sp, #24]
    e49a:	bl	120f4 <__ssprint_r>
    e49e:	cmp	r0, #0
    e4a0:	bne.w	d344 <_svfprintf_r+0x1f4>
    e4a4:	ldr	r4, [sp, #148]	; 0x94
    e4a6:	ldr	r3, [sp, #144]	; 0x90
    e4a8:	add.w	r9, sp, #192	; 0xc0
    e4ac:	ldr	r1, [sp, #56]	; 0x38
    e4ae:	str.w	r6, [r9]
    e4b2:	adds	r3, #1
    e4b4:	add	r4, r1
    e4b6:	cmp	r3, #7
    e4b8:	str	r4, [sp, #148]	; 0x94
    e4ba:	str	r3, [sp, #144]	; 0x90
    e4bc:	str.w	r1, [r9, #4]
    e4c0:	ble.w	d678 <_svfprintf_r+0x528>
    e4c4:	b.w	dcbe <_svfprintf_r+0xb6e>
    e4c8:	ldr	r3, [sp, #116]	; 0x74
    e4ca:	adds	r5, r3, #3
    e4cc:	blt.n	e50c <_svfprintf_r+0x13bc>
    e4ce:	cmp	fp, r3
    e4d0:	blt.n	e50c <_svfprintf_r+0x13bc>
    e4d2:	str	r3, [sp, #60]	; 0x3c
    e4d4:	b.n	e1ee <_svfprintf_r+0x109e>
    e4d6:	mov	r3, r4
    e4d8:	b.n	e1d0 <_svfprintf_r+0x1080>
    e4da:	add	r2, sp, #140	; 0x8c
    e4dc:	ldr	r1, [sp, #20]
    e4de:	ldr	r0, [sp, #24]
    e4e0:	bl	120f4 <__ssprint_r>
    e4e4:	cmp	r0, #0
    e4e6:	bne.w	d344 <_svfprintf_r+0x1f4>
    e4ea:	ldr	r4, [sp, #148]	; 0x94
    e4ec:	add.w	r9, sp, #192	; 0xc0
    e4f0:	b.n	dd8c <_svfprintf_r+0xc3c>
    e4f2:	mov	r4, r2
    e4f4:	adds	r3, #1
    e4f6:	ldr	r2, [sp, #44]	; 0x2c
    e4f8:	str	r3, [sp, #144]	; 0x90
    e4fa:	add	r4, r5
    e4fc:	cmp	r3, #7
    e4fe:	str	r4, [sp, #148]	; 0x94
    e500:	stmia.w	r9, {r2, r5}
    e504:	bgt.n	e494 <_svfprintf_r+0x1344>
    e506:	add.w	r9, r9, #8
    e50a:	b.n	e4ac <_svfprintf_r+0x135c>
    e50c:	ldr	r2, [sp, #52]	; 0x34
    e50e:	subs	r2, #2
    e510:	str	r2, [sp, #52]	; 0x34
    e512:	subs	r3, #1
    e514:	cmp	r3, #0
    e516:	ldrb.w	r2, [sp, #52]	; 0x34
    e51a:	str	r3, [sp, #116]	; 0x74
    e51c:	it	lt
    e51e:	neglt	r3, r3
    e520:	strb.w	r2, [sp, #124]	; 0x7c
    e524:	ite	lt
    e526:	movlt	r2, #45	; 0x2d
    e528:	movge	r2, #43	; 0x2b
    e52a:	cmp	r3, #9
    e52c:	strb.w	r2, [sp, #125]	; 0x7d
    e530:	ble.w	e70a <_svfprintf_r+0x15ba>
    e534:	add.w	r0, sp, #139	; 0x8b
    e538:	mov	r4, r0
    e53a:	ldr	r2, [pc, #180]	; (e5f0 <_svfprintf_r+0x14a0>)
    e53c:	smull	r2, r1, r2, r3
    e540:	asrs	r2, r3, #31
    e542:	rsb	r2, r2, r1, asr #2
    e546:	add.w	r1, r2, r2, lsl #2
    e54a:	sub.w	r3, r3, r1, lsl #1
    e54e:	add.w	r1, r3, #48	; 0x30
    e552:	cmp	r2, #9
    e554:	mov	r3, r2
    e556:	strb.w	r1, [r4, #-1]!
    e55a:	bgt.n	e53a <_svfprintf_r+0x13ea>
    e55c:	mov	r1, r4
    e55e:	adds	r3, #48	; 0x30
    e560:	uxtb	r2, r3
    e562:	strb.w	r2, [r1, #-1]!
    e566:	cmp	r0, r1
    e568:	bls.w	e7d4 <_svfprintf_r+0x1684>
    e56c:	add.w	r1, sp, #126	; 0x7e
    e570:	mov	r3, r4
    e572:	b.n	e578 <_svfprintf_r+0x1428>
    e574:	ldrb.w	r2, [r3], #1
    e578:	strb.w	r2, [r1], #1
    e57c:	cmp	r0, r3
    e57e:	bne.n	e574 <_svfprintf_r+0x1424>
    e580:	adds	r3, r0, #1
    e582:	subs	r3, r3, r4
    e584:	add.w	r2, sp, #126	; 0x7e
    e588:	add	r3, r2
    e58a:	add	r2, sp, #124	; 0x7c
    e58c:	subs	r3, r3, r2
    e58e:	ldr	r2, [sp, #56]	; 0x38
    e590:	str	r3, [sp, #84]	; 0x54
    e592:	cmp	r2, #1
    e594:	add	r3, r2
    e596:	str	r3, [sp, #36]	; 0x24
    e598:	ble.w	e76a <_svfprintf_r+0x161a>
    e59c:	ldr	r3, [sp, #36]	; 0x24
    e59e:	ldr	r2, [sp, #72]	; 0x48
    e5a0:	add	r3, r2
    e5a2:	movs	r2, #0
    e5a4:	str	r3, [sp, #36]	; 0x24
    e5a6:	str	r2, [sp, #60]	; 0x3c
    e5a8:	bic.w	r3, r3, r3, asr #31
    e5ac:	b.n	e20a <_svfprintf_r+0x10ba>
    e5ae:	add	r2, sp, #140	; 0x8c
    e5b0:	ldr	r1, [sp, #20]
    e5b2:	ldr	r0, [sp, #24]
    e5b4:	bl	120f4 <__ssprint_r>
    e5b8:	cmp	r0, #0
    e5ba:	bne.w	d344 <_svfprintf_r+0x1f4>
    e5be:	ldr	r3, [sp, #116]	; 0x74
    e5c0:	ldr	r4, [sp, #148]	; 0x94
    e5c2:	add.w	r9, sp, #192	; 0xc0
    e5c6:	b.n	dfa0 <_svfprintf_r+0xe50>
    e5c8:	add	r2, sp, #140	; 0x8c
    e5ca:	ldr	r1, [sp, #20]
    e5cc:	ldr	r0, [sp, #24]
    e5ce:	bl	120f4 <__ssprint_r>
    e5d2:	cmp	r0, #0
    e5d4:	bne.w	d344 <_svfprintf_r+0x1f4>
    e5d8:	ldr	r3, [sp, #116]	; 0x74
    e5da:	ldr	r2, [sp, #56]	; 0x38
    e5dc:	ldr	r4, [sp, #148]	; 0x94
    e5de:	subs	r3, r2, r3
    e5e0:	add.w	r9, sp, #192	; 0xc0
    e5e4:	b.n	dfd0 <_svfprintf_r+0xe80>
    e5e6:	nop
    e5e8:	.word	0x00013198
    e5ec:	.word	0x00013148
    e5f0:	.word	0x66666667
    e5f4:	cmp	r5, #6
    e5f6:	mov	r3, r5
    e5f8:	it	cs
    e5fa:	movcs	r3, #6
    e5fc:	str	r3, [sp, #36]	; 0x24
    e5fe:	bic.w	r3, r3, r3, asr #31
    e602:	mov	fp, r6
    e604:	str	r7, [sp, #40]	; 0x28
    e606:	str	r6, [sp, #60]	; 0x3c
    e608:	mov	r7, r6
    e60a:	str	r3, [sp, #16]
    e60c:	ldr	r6, [pc, #536]	; (e828 <_svfprintf_r+0x16d8>)
    e60e:	b.w	d4f4 <_svfprintf_r+0x3a4>
    e612:	mov.w	fp, #6
    e616:	b.n	e14a <_svfprintf_r+0xffa>
    e618:	add	r2, sp, #132	; 0x84
    e61a:	add	r3, sp, #120	; 0x78
    e61c:	str	r2, [sp, #4]
    e61e:	str	r3, [sp, #0]
    e620:	mov	r2, fp
    e622:	add	r3, sp, #116	; 0x74
    e624:	movs	r1, #3
    e626:	vldr	d0, [sp, #96]	; 0x60
    e62a:	ldr	r0, [sp, #24]
    e62c:	bl	f958 <_dtoa_r>
    e630:	mov	r5, fp
    e632:	mov	r6, r0
    e634:	add.w	r4, r0, fp
    e638:	b.n	e426 <_svfprintf_r+0x12d6>
    e63a:	movs	r7, #45	; 0x2d
    e63c:	strb.w	r7, [sp, #111]	; 0x6f
    e640:	b.w	d79a <_svfprintf_r+0x64a>
    e644:	str	r3, [sp, #12]
    e646:	b.w	d8f2 <_svfprintf_r+0x7a2>
    e64a:	ldrd	r1, r2, [sp, #64]	; 0x40
    e64e:	add.w	r3, r2, #2147483648	; 0x80000000
    e652:	str	r3, [sp, #100]	; 0x64
    e654:	movs	r3, #45	; 0x2d
    e656:	str	r1, [sp, #96]	; 0x60
    e658:	str	r3, [sp, #16]
    e65a:	b.n	e166 <_svfprintf_r+0x1016>
    e65c:	ldr	r2, [sp, #72]	; 0x48
    e65e:	ldr	r3, [sp, #56]	; 0x38
    e660:	add	r3, r2
    e662:	ldr	r2, [sp, #60]	; 0x3c
    e664:	str	r3, [sp, #36]	; 0x24
    e666:	cmp	r2, #0
    e668:	ble.w	e77e <_svfprintf_r+0x162e>
    e66c:	movs	r2, #103	; 0x67
    e66e:	bic.w	r3, r3, r3, asr #31
    e672:	str	r2, [sp, #52]	; 0x34
    e674:	b.n	e20a <_svfprintf_r+0x10ba>
    e676:	ldr	r3, [sp, #52]	; 0x34
    e678:	cmp	r3, #71	; 0x47
    e67a:	bne.w	e1a8 <_svfprintf_r+0x1058>
    e67e:	ldr	r3, [sp, #12]
    e680:	lsls	r3, r3, #31
    e682:	bmi.w	e41a <_svfprintf_r+0x12ca>
    e686:	ldr	r3, [sp, #132]	; 0x84
    e688:	cmp	r7, #71	; 0x47
    e68a:	sub.w	r3, r3, r6
    e68e:	str	r3, [sp, #56]	; 0x38
    e690:	beq.w	e4c8 <_svfprintf_r+0x1378>
    e694:	ldr	r3, [sp, #116]	; 0x74
    e696:	b.n	e512 <_svfprintf_r+0x13c2>
    e698:	bic.w	r3, r5, r5, asr #31
    e69c:	str	r7, [sp, #40]	; 0x28
    e69e:	str	r3, [sp, #16]
    e6a0:	str	r5, [sp, #36]	; 0x24
    e6a2:	mov	fp, r0
    e6a4:	str	r0, [sp, #60]	; 0x3c
    e6a6:	ldrb.w	r7, [sp, #111]	; 0x6f
    e6aa:	b.w	d4f4 <_svfprintf_r+0x3a4>
    e6ae:	cmp	r3, #0
    e6b0:	ble.n	e78e <_svfprintf_r+0x163e>
    e6b2:	cmp.w	fp, #0
    e6b6:	bne.n	e758 <_svfprintf_r+0x1608>
    e6b8:	ldr	r2, [sp, #12]
    e6ba:	lsls	r4, r2, #31
    e6bc:	bmi.n	e758 <_svfprintf_r+0x1608>
    e6be:	mov	r2, r3
    e6c0:	str	r2, [sp, #36]	; 0x24
    e6c2:	bic.w	r3, r3, r3, asr #31
    e6c6:	b.n	e20a <_svfprintf_r+0x10ba>
    e6c8:	ldr	r3, [sp, #12]
    e6ca:	lsls	r3, r3, #31
    e6cc:	mov	r7, fp
    e6ce:	bpl.n	e6dc <_svfprintf_r+0x158c>
    e6d0:	add	r6, sp, #256	; 0x100
    e6d2:	movs	r3, #48	; 0x30
    e6d4:	strb.w	r3, [r6, #-65]!
    e6d8:	b.w	d4e0 <_svfprintf_r+0x390>
    e6dc:	str.w	fp, [sp, #36]	; 0x24
    e6e0:	add	r6, sp, #192	; 0xc0
    e6e2:	b.w	d4e6 <_svfprintf_r+0x396>
    e6e6:	add	r2, sp, #140	; 0x8c
    e6e8:	ldr	r1, [sp, #20]
    e6ea:	ldr	r0, [sp, #24]
    e6ec:	bl	120f4 <__ssprint_r>
    e6f0:	cmp	r0, #0
    e6f2:	bne.w	d344 <_svfprintf_r+0x1f4>
    e6f6:	ldr	r5, [sp, #116]	; 0x74
    e6f8:	ldr	r4, [sp, #148]	; 0x94
    e6fa:	ldr	r3, [sp, #144]	; 0x90
    e6fc:	add.w	r9, sp, #192	; 0xc0
    e700:	b.n	e350 <_svfprintf_r+0x1200>
    e702:	mov	r8, r4
    e704:	movs	r5, #0
    e706:	b.w	d208 <_svfprintf_r+0xb8>
    e70a:	adds	r3, #48	; 0x30
    e70c:	movs	r2, #48	; 0x30
    e70e:	strb.w	r3, [sp, #127]	; 0x7f
    e712:	strb.w	r2, [sp, #126]	; 0x7e
    e716:	add	r3, sp, #128	; 0x80
    e718:	b.n	e58a <_svfprintf_r+0x143a>
    e71a:	ldr	r3, [sp, #132]	; 0x84
    e71c:	b.n	e1d0 <_svfprintf_r+0x1080>
    e71e:	ldr	r2, [sp, #72]	; 0x48
    e720:	ldr	r3, [sp, #60]	; 0x3c
    e722:	add	r3, r2
    e724:	movs	r2, #103	; 0x67
    e726:	str	r3, [sp, #36]	; 0x24
    e728:	str	r2, [sp, #52]	; 0x34
    e72a:	bic.w	r3, r3, r3, asr #31
    e72e:	b.n	e20a <_svfprintf_r+0x10ba>
    e730:	ldr	r6, [pc, #248]	; (e82c <_svfprintf_r+0x16dc>)
    e732:	ldr	r3, [pc, #252]	; (e830 <_svfprintf_r+0x16e0>)
    e734:	ldrb.w	r7, [sp, #111]	; 0x6f
    e738:	b.w	d79e <_svfprintf_r+0x64e>
    e73c:	movs	r2, #0
    e73e:	movs	r3, #0
    e740:	ldrd	r0, r1, [sp, #96]	; 0x60
    e744:	bl	ad44 <__aeabi_dcmpeq>
    e748:	cmp	r0, #0
    e74a:	bne.w	e42e <_svfprintf_r+0x12de>
    e74e:	rsb	r5, r5, #1
    e752:	str	r5, [sp, #116]	; 0x74
    e754:	add	r4, r5
    e756:	b.n	e1aa <_svfprintf_r+0x105a>
    e758:	ldr	r3, [sp, #60]	; 0x3c
    e75a:	ldr	r2, [sp, #72]	; 0x48
    e75c:	adds	r5, r3, r2
    e75e:	add.w	r3, r5, fp
    e762:	str	r3, [sp, #36]	; 0x24
    e764:	bic.w	r3, r3, r3, asr #31
    e768:	b.n	e20a <_svfprintf_r+0x10ba>
    e76a:	ldr	r3, [sp, #12]
    e76c:	ands.w	r3, r3, #1
    e770:	bne.w	e59c <_svfprintf_r+0x144c>
    e774:	str	r3, [sp, #60]	; 0x3c
    e776:	ldr	r3, [sp, #36]	; 0x24
    e778:	bic.w	r3, r3, r3, asr #31
    e77c:	b.n	e20a <_svfprintf_r+0x10ba>
    e77e:	ldr	r3, [sp, #60]	; 0x3c
    e780:	ldr	r2, [sp, #36]	; 0x24
    e782:	rsb	r3, r3, #1
    e786:	add	r2, r3
    e788:	mov	r3, r2
    e78a:	str	r2, [sp, #36]	; 0x24
    e78c:	b.n	e66c <_svfprintf_r+0x151c>
    e78e:	cmp.w	fp, #0
    e792:	bne.n	e79a <_svfprintf_r+0x164a>
    e794:	ldr	r3, [sp, #12]
    e796:	lsls	r0, r3, #31
    e798:	bpl.n	e7aa <_svfprintf_r+0x165a>
    e79a:	ldr	r3, [sp, #72]	; 0x48
    e79c:	adds	r5, r3, #1
    e79e:	add.w	r3, r5, fp
    e7a2:	str	r3, [sp, #36]	; 0x24
    e7a4:	bic.w	r3, r3, r3, asr #31
    e7a8:	b.n	e20a <_svfprintf_r+0x10ba>
    e7aa:	movs	r3, #1
    e7ac:	str	r3, [sp, #36]	; 0x24
    e7ae:	b.n	e20a <_svfprintf_r+0x10ba>
    e7b0:	ldr	r0, [sp, #40]	; 0x28
    e7b2:	ldrb.w	r3, [r8, #1]
    e7b6:	ldr	r5, [r0, #0]
    e7b8:	adds	r0, #4
    e7ba:	cmp	r5, #0
    e7bc:	str	r0, [sp, #40]	; 0x28
    e7be:	mov	r8, r4
    e7c0:	bge.w	d204 <_svfprintf_r+0xb4>
    e7c4:	mov.w	r5, #4294967295
    e7c8:	b.w	d204 <_svfprintf_r+0xb4>
    e7cc:	strb.w	r1, [sp, #111]	; 0x6f
    e7d0:	b.w	d366 <_svfprintf_r+0x216>
    e7d4:	add.w	r3, sp, #126	; 0x7e
    e7d8:	b.n	e58a <_svfprintf_r+0x143a>
    e7da:	ldr	r2, [sp, #24]
    e7dc:	movs	r3, #12
    e7de:	str	r3, [r2, #0]
    e7e0:	mov.w	r0, #4294967295
    e7e4:	b.w	d356 <_svfprintf_r+0x206>
    e7e8:	strb.w	r1, [sp, #111]	; 0x6f
    e7ec:	b.w	d460 <_svfprintf_r+0x310>
    e7f0:	strb.w	r1, [sp, #111]	; 0x6f
    e7f4:	b.w	d72c <_svfprintf_r+0x5dc>
    e7f8:	strb.w	r1, [sp, #111]	; 0x6f
    e7fc:	b.w	d89a <_svfprintf_r+0x74a>
    e800:	strb.w	r1, [sp, #111]	; 0x6f
    e804:	b.w	d83e <_svfprintf_r+0x6ee>
    e808:	strb.w	r1, [sp, #111]	; 0x6f
    e80c:	b.w	d7ea <_svfprintf_r+0x69a>
    e810:	strb.w	r1, [sp, #111]	; 0x6f
    e814:	b.w	da82 <_svfprintf_r+0x932>
    e818:	strb.w	r1, [sp, #111]	; 0x6f
    e81c:	b.w	da40 <_svfprintf_r+0x8f0>
    e820:	strb.w	r1, [sp, #111]	; 0x6f
    e824:	b.w	da04 <_svfprintf_r+0x8b4>
    e828:	.word	0x00013190
    e82c:	.word	0x00013164
    e830:	.word	0x00013160

0000e834 <__ssvfscanf_r>:
    e834:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e838:	mov	fp, r1
    e83a:	ldrsh.w	r1, [r1, #12]
    e83e:	sub.w	sp, sp, #692	; 0x2b4
    e842:	mov	sl, r0
    e844:	lsls	r0, r1, #18
    e846:	mov	r4, r2
    e848:	str	r3, [sp, #20]
    e84a:	bmi.n	e860 <__ssvfscanf_r+0x2c>
    e84c:	ldr.w	r3, [fp, #100]	; 0x64
    e850:	orr.w	r1, r1, #8192	; 0x2000
    e854:	bic.w	r3, r3, #8192	; 0x2000
    e858:	strh.w	r1, [fp, #12]
    e85c:	str.w	r3, [fp, #100]	; 0x64
    e860:	mov	r6, r4
    e862:	movs	r3, #0
    e864:	str	r3, [sp, #28]
    e866:	str	r3, [sp, #16]
    e868:	mov	r7, r3
    e86a:	str	r3, [sp, #24]
    e86c:	ldrb.w	r3, [r6], #1
    e870:	str	r3, [sp, #68]	; 0x44
    e872:	cbz	r3, e8d0 <__ssvfscanf_r+0x9c>
    e874:	bl	b2c0 <__locale_ctype_ptr>
    e878:	ldr	r2, [sp, #68]	; 0x44
    e87a:	add	r0, r2
    e87c:	ldrb	r3, [r0, #1]
    e87e:	and.w	r3, r3, #8
    e882:	and.w	r5, r3, #255	; 0xff
    e886:	cbz	r3, e8da <__ssvfscanf_r+0xa6>
    e888:	ldr.w	r3, [fp, #4]
    e88c:	b.n	e8b2 <__ssvfscanf_r+0x7e>
    e88e:	bl	b2c0 <__locale_ctype_ptr>
    e892:	ldr.w	r3, [fp]
    e896:	ldrb	r2, [r3, #0]
    e898:	add	r0, r2
    e89a:	adds	r3, #1
    e89c:	ldrb	r2, [r0, #1]
    e89e:	lsls	r1, r2, #28
    e8a0:	bpl.n	e8c2 <__ssvfscanf_r+0x8e>
    e8a2:	ldr.w	r2, [fp, #4]
    e8a6:	str.w	r3, [fp]
    e8aa:	subs	r3, r2, #1
    e8ac:	adds	r7, #1
    e8ae:	str.w	r3, [fp, #4]
    e8b2:	cmp	r3, #0
    e8b4:	bgt.n	e88e <__ssvfscanf_r+0x5a>
    e8b6:	mov	r1, fp
    e8b8:	mov	r0, sl
    e8ba:	bl	12278 <__ssrefill_r>
    e8be:	cmp	r0, #0
    e8c0:	beq.n	e88e <__ssvfscanf_r+0x5a>
    e8c2:	mov	r4, r6
    e8c4:	mov	r6, r4
    e8c6:	ldrb.w	r3, [r6], #1
    e8ca:	str	r3, [sp, #68]	; 0x44
    e8cc:	cmp	r3, #0
    e8ce:	bne.n	e874 <__ssvfscanf_r+0x40>
    e8d0:	ldr	r0, [sp, #24]
    e8d2:	add.w	sp, sp, #692	; 0x2b4
    e8d6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e8da:	cmp	r2, #37	; 0x25
    e8dc:	bne.w	e9e8 <__ssvfscanf_r+0x1b4>
    e8e0:	ldrb.w	r8, [r4, #1]
    e8e4:	mov	r4, r5
    e8e6:	adds	r3, r6, #1
    e8e8:	cmp.w	r8, #120	; 0x78
    e8ec:	bhi.w	ed76 <__ssvfscanf_r+0x542>
    e8f0:	tbh	[pc, r8, lsl #1]
    e8f4:	.word	0x02410092
    e8f8:	.word	0x02410241
    e8fc:	.word	0x02410241
    e900:	.word	0x02410241
    e904:	.word	0x02410241
    e908:	.word	0x02410241
    e90c:	.word	0x02410241
    e910:	.word	0x02410241
    e914:	.word	0x02410241
    e918:	.word	0x02410241
    e91c:	.word	0x02410241
    e920:	.word	0x02410241
    e924:	.word	0x02410241
    e928:	.word	0x02410241
    e92c:	.word	0x02410241
    e930:	.word	0x02410241
    e934:	.word	0x02410241
    e938:	.word	0x02410241
    e93c:	.word	0x00790241
    e940:	.word	0x02410241
    e944:	.word	0x02410241
    e948:	.word	0x024101d8
    e94c:	.word	0x02410241
    e950:	.word	0x02410241
    e954:	.word	0x01cf01cf
    e958:	.word	0x01cf01cf
    e95c:	.word	0x01cf01cf
    e960:	.word	0x01cf01cf
    e964:	.word	0x01cf01cf
    e968:	.word	0x02410241
    e96c:	.word	0x02410241
    e970:	.word	0x02410241
    e974:	.word	0x02410241
    e978:	.word	0x02410241
    e97c:	.word	0x01b901c1
    e980:	.word	0x01b90241
    e984:	.word	0x02410241
    e988:	.word	0x02410241
    e98c:	.word	0x024101b3
    e990:	.word	0x01a30241
    e994:	.word	0x02410241
    e998:	.word	0x02410241
    e99c:	.word	0x02410241
    e9a0:	.word	0x02410241
    e9a4:	.word	0x02410193
    e9a8:	.word	0x01510241
    e9ac:	.word	0x02410241
    e9b0:	.word	0x02410241
    e9b4:	.word	0x02410241
    e9b8:	.word	0x01220241
    e9bc:	.word	0x01b90188
    e9c0:	.word	0x01b901b9
    e9c4:	.word	0x0098011c
    e9c8:	.word	0x02410241
    e9cc:	.word	0x024100d5
    e9d0:	.word	0x0101010d
    e9d4:	.word	0x024100f3
    e9d8:	.word	0x00eb0241
    e9dc:	.word	0x00df0241
    e9e0:	.word	0x02410241
    e9e4:	.short	0x0193
    e9e6:	mov	r6, r3
    e9e8:	ldr.w	r3, [fp, #4]
    e9ec:	cmp	r3, #0
    e9ee:	ble.w	ee98 <__ssvfscanf_r+0x664>
    e9f2:	ldr.w	r3, [fp]
    e9f6:	ldrb.w	r2, [r6, #-1]
    e9fa:	ldrb	r1, [r3, #0]
    e9fc:	cmp	r1, r2
    e9fe:	bne.w	e8d0 <__ssvfscanf_r+0x9c>
    ea02:	ldr.w	r2, [fp, #4]
    ea06:	adds	r3, #1
    ea08:	subs	r2, #1
    ea0a:	str.w	r3, [fp]
    ea0e:	adds	r7, #1
    ea10:	str.w	r2, [fp, #4]
    ea14:	mov	r4, r6
    ea16:	b.n	e8c4 <__ssvfscanf_r+0x90>
    ea18:	mov.w	r0, #4294967295
    ea1c:	add.w	sp, sp, #692	; 0x2b4
    ea20:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ea24:	str	r3, [sp, #12]
    ea26:	ldr.w	r3, [fp, #4]
    ea2a:	cmp	r3, #0
    ea2c:	ble.w	eef6 <__ssvfscanf_r+0x6c2>
    ea30:	ldr	r3, [pc, #736]	; (ed14 <__ssvfscanf_r+0x4e0>)
    ea32:	str	r3, [sp, #28]
    ea34:	movs	r3, #0
    ea36:	str	r3, [sp, #16]
    ea38:	movs	r6, #3
    ea3a:	b.n	ea40 <__ssvfscanf_r+0x20c>
    ea3c:	str.w	lr, [fp]
    ea40:	bl	b2c0 <__locale_ctype_ptr>
    ea44:	ldr.w	r2, [fp]
    ea48:	ldrb	r1, [r2, #0]
    ea4a:	add	r0, r1
    ea4c:	add.w	lr, r2, #1
    ea50:	ldrb	r3, [r0, #1]
    ea52:	and.w	r3, r3, #8
    ea56:	and.w	r8, r3, #255	; 0xff
    ea5a:	cmp	r3, #0
    ea5c:	beq.w	ef5e <__ssvfscanf_r+0x72a>
    ea60:	ldr.w	r3, [fp, #4]
    ea64:	subs	r3, #1
    ea66:	cmp	r3, #0
    ea68:	add.w	r7, r7, #1
    ea6c:	str.w	r3, [fp, #4]
    ea70:	bgt.n	ea3c <__ssvfscanf_r+0x208>
    ea72:	mov	r1, fp
    ea74:	mov	r0, sl
    ea76:	bl	12278 <__ssrefill_r>
    ea7a:	cmp	r0, #0
    ea7c:	beq.n	ea40 <__ssvfscanf_r+0x20c>
    ea7e:	ldr	r2, [sp, #24]
    ea80:	cmp	r2, #0
    ea82:	beq.n	ea18 <__ssvfscanf_r+0x1e4>
    ea84:	ldrh.w	r3, [fp, #12]
    ea88:	tst.w	r3, #64	; 0x40
    ea8c:	mov	r3, r2
    ea8e:	it	ne
    ea90:	movne.w	r3, #4294967295
    ea94:	mov	r0, r3
    ea96:	add.w	sp, sp, #692	; 0x2b4
    ea9a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ea9e:	ldrb.w	r8, [r6, #1]
    eaa2:	cmp.w	r8, #108	; 0x6c
    eaa6:	beq.w	eeae <__ssvfscanf_r+0x67a>
    eaaa:	orr.w	r5, r5, #1
    eaae:	mov	r6, r3
    eab0:	b.n	e8e6 <__ssvfscanf_r+0xb2>
    eab2:	str	r3, [sp, #12]
    eab4:	ldr.w	r3, [fp, #4]
    eab8:	cmp	r3, #0
    eaba:	ble.w	ef4e <__ssvfscanf_r+0x71a>
    eabe:	ldr	r3, [pc, #600]	; (ed18 <__ssvfscanf_r+0x4e4>)
    eac0:	str	r3, [sp, #28]
    eac2:	movs	r3, #10
    eac4:	str	r3, [sp, #16]
    eac6:	movs	r6, #3
    eac8:	b.n	ea40 <__ssvfscanf_r+0x20c>
    eaca:	str	r3, [sp, #12]
    eacc:	ldr.w	r3, [fp, #4]
    ead0:	cmp	r3, #0
    ead2:	ble.w	ef3e <__ssvfscanf_r+0x70a>
    ead6:	movs	r6, #2
    ead8:	b.n	ea40 <__ssvfscanf_r+0x20c>
    eada:	str	r3, [sp, #12]
    eadc:	ldr.w	r3, [fp, #4]
    eae0:	cmp	r3, #0
    eae2:	orr.w	r5, r5, #544	; 0x220
    eae6:	ble.w	ec2a <__ssvfscanf_r+0x3f6>
    eaea:	ldr	r3, [pc, #556]	; (ed18 <__ssvfscanf_r+0x4e4>)
    eaec:	str	r3, [sp, #28]
    eaee:	movs	r3, #16
    eaf0:	str	r3, [sp, #16]
    eaf2:	movs	r6, #3
    eaf4:	b.n	ea40 <__ssvfscanf_r+0x20c>
    eaf6:	str	r3, [sp, #12]
    eaf8:	ldr.w	r3, [fp, #4]
    eafc:	cmp	r3, #0
    eafe:	ble.w	ec4a <__ssvfscanf_r+0x416>
    eb02:	ldr	r3, [pc, #532]	; (ed18 <__ssvfscanf_r+0x4e4>)
    eb04:	str	r3, [sp, #28]
    eb06:	movs	r3, #8
    eb08:	str	r3, [sp, #16]
    eb0a:	movs	r6, #3
    eb0c:	b.n	ea40 <__ssvfscanf_r+0x20c>
    eb0e:	lsls	r2, r5, #27
    eb10:	mov	r6, r3
    eb12:	str	r3, [sp, #12]
    eb14:	bmi.w	ecfc <__ssvfscanf_r+0x4c8>
    eb18:	lsls	r3, r5, #29
    eb1a:	bpl.w	eec6 <__ssvfscanf_r+0x692>
    eb1e:	ldr	r1, [sp, #20]
    eb20:	ldr	r3, [r1, #0]
    eb22:	strh	r7, [r3, #0]
    eb24:	adds	r3, r1, #4
    eb26:	str	r3, [sp, #20]
    eb28:	mov	r4, r6
    eb2a:	b.n	e8c4 <__ssvfscanf_r+0x90>
    eb2c:	ldrb.w	r8, [r6, #1]
    eb30:	orr.w	r5, r5, #4
    eb34:	mov	r6, r3
    eb36:	b.n	e8e6 <__ssvfscanf_r+0xb2>
    eb38:	str	r3, [sp, #12]
    eb3a:	ldr.w	r3, [fp, #4]
    eb3e:	cmp	r3, #0
    eb40:	ble.w	ef1e <__ssvfscanf_r+0x6ea>
    eb44:	cmp	r4, #0
    eb46:	it	eq
    eb48:	moveq	r4, #1
    eb4a:	ands.w	r3, r5, #1
    eb4e:	bne.w	ed96 <__ssvfscanf_r+0x562>
    eb52:	lsls	r2, r5, #27
    eb54:	bpl.w	ee6e <__ssvfscanf_r+0x63a>
    eb58:	mov	r5, r3
    eb5a:	b.n	eb70 <__ssvfscanf_r+0x33c>
    eb5c:	add	r3, r2
    eb5e:	str.w	r3, [fp]
    eb62:	add	r5, r2
    eb64:	subs	r4, r4, r2
    eb66:	bl	12278 <__ssrefill_r>
    eb6a:	cmp	r0, #0
    eb6c:	bne.w	ee66 <__ssvfscanf_r+0x632>
    eb70:	ldr.w	r2, [fp, #4]
    eb74:	ldr.w	r3, [fp]
    eb78:	cmp	r2, r4
    eb7a:	mov	r1, fp
    eb7c:	mov	r0, sl
    eb7e:	blt.n	eb5c <__ssvfscanf_r+0x328>
    eb80:	subs	r2, r2, r4
    eb82:	add	r3, r4
    eb84:	str.w	r2, [fp, #4]
    eb88:	add	r5, r4
    eb8a:	str.w	r3, [fp]
    eb8e:	ldr	r6, [sp, #12]
    eb90:	add	r7, r5
    eb92:	mov	r4, r6
    eb94:	b.n	e8c4 <__ssvfscanf_r+0x90>
    eb96:	add.w	r9, sp, #80	; 0x50
    eb9a:	mov	r1, r3
    eb9c:	mov	r0, r9
    eb9e:	bl	11b08 <__sccl>
    eba2:	ldr.w	r3, [fp, #4]
    eba6:	cmp	r3, #0
    eba8:	mov	r6, r0
    ebaa:	ble.w	ef0e <__ssvfscanf_r+0x6da>
    ebae:	cmp	r4, #0
    ebb0:	ldr.w	r2, [fp]
    ebb4:	it	eq
    ebb6:	moveq.w	r4, #4294967295
    ebba:	lsls	r3, r5, #27
    ebbc:	ldrb	r1, [r2, #0]
    ebbe:	bpl.w	ed02 <__ssvfscanf_r+0x4ce>
    ebc2:	mov	r8, r4
    ebc4:	movs	r5, #0
    ebc6:	b.n	ebca <__ssvfscanf_r+0x396>
    ebc8:	ldrb	r1, [r2, #0]
    ebca:	ldrb.w	r3, [r9, r1]
    ebce:	adds	r2, #1
    ebd0:	cmp	r3, #0
    ebd2:	beq.w	ee5c <__ssvfscanf_r+0x628>
    ebd6:	ldr.w	r3, [fp, #4]
    ebda:	str.w	r2, [fp]
    ebde:	adds	r5, #1
    ebe0:	subs	r3, #1
    ebe2:	cmp	r5, r4
    ebe4:	str.w	r3, [fp, #4]
    ebe8:	beq.w	ee56 <__ssvfscanf_r+0x622>
    ebec:	cmp	r3, #0
    ebee:	bgt.n	ebc8 <__ssvfscanf_r+0x394>
    ebf0:	mov	r1, fp
    ebf2:	mov	r0, sl
    ebf4:	bl	12278 <__ssrefill_r>
    ebf8:	cmp	r0, #0
    ebfa:	bne.w	ee54 <__ssvfscanf_r+0x620>
    ebfe:	ldr.w	r2, [fp]
    ec02:	b.n	ebc8 <__ssvfscanf_r+0x394>
    ec04:	str	r3, [sp, #12]
    ec06:	ldr.w	r3, [fp, #4]
    ec0a:	cmp	r3, #0
    ec0c:	ble.n	ec84 <__ssvfscanf_r+0x450>
    ec0e:	ldr	r3, [pc, #260]	; (ed14 <__ssvfscanf_r+0x4e0>)
    ec10:	str	r3, [sp, #28]
    ec12:	movs	r3, #10
    ec14:	str	r3, [sp, #16]
    ec16:	movs	r6, #3
    ec18:	b.n	ea40 <__ssvfscanf_r+0x20c>
    ec1a:	str	r3, [sp, #12]
    ec1c:	ldr.w	r3, [fp, #4]
    ec20:	cmp	r3, #0
    ec22:	orr.w	r5, r5, #512	; 0x200
    ec26:	bgt.w	eaea <__ssvfscanf_r+0x2b6>
    ec2a:	mov	r1, fp
    ec2c:	mov	r0, sl
    ec2e:	bl	12278 <__ssrefill_r>
    ec32:	cmp	r0, #0
    ec34:	beq.w	eaea <__ssvfscanf_r+0x2b6>
    ec38:	b.n	ea7e <__ssvfscanf_r+0x24a>
    ec3a:	str	r3, [sp, #12]
    ec3c:	ldr.w	r3, [fp, #4]
    ec40:	cmp	r3, #0
    ec42:	orr.w	r5, r5, #1
    ec46:	bgt.w	eb02 <__ssvfscanf_r+0x2ce>
    ec4a:	mov	r1, fp
    ec4c:	mov	r0, sl
    ec4e:	bl	12278 <__ssrefill_r>
    ec52:	cmp	r0, #0
    ec54:	beq.w	eb02 <__ssvfscanf_r+0x2ce>
    ec58:	b.n	ea7e <__ssvfscanf_r+0x24a>
    ec5a:	ldrb.w	r8, [r6, #1]
    ec5e:	orr.w	r5, r5, #2
    ec62:	mov	r6, r3
    ec64:	b.n	e8e6 <__ssvfscanf_r+0xb2>
    ec66:	str	r3, [sp, #12]
    ec68:	ldr.w	r3, [fp, #4]
    ec6c:	cmp	r3, #0
    ec6e:	ble.w	ef2e <__ssvfscanf_r+0x6fa>
    ec72:	movs	r6, #4
    ec74:	b.n	ea40 <__ssvfscanf_r+0x20c>
    ec76:	str	r3, [sp, #12]
    ec78:	ldr.w	r3, [fp, #4]
    ec7c:	cmp	r3, #0
    ec7e:	orr.w	r5, r5, #1
    ec82:	bgt.n	ec0e <__ssvfscanf_r+0x3da>
    ec84:	mov	r1, fp
    ec86:	mov	r0, sl
    ec88:	bl	12278 <__ssrefill_r>
    ec8c:	cmp	r0, #0
    ec8e:	beq.n	ec0e <__ssvfscanf_r+0x3da>
    ec90:	b.n	ea7e <__ssvfscanf_r+0x24a>
    ec92:	add.w	r4, r4, r4, lsl #2
    ec96:	add.w	r4, r8, r4, lsl #1
    ec9a:	subs	r4, #48	; 0x30
    ec9c:	ldrb.w	r8, [r6, #1]
    eca0:	mov	r6, r3
    eca2:	b.n	e8e6 <__ssvfscanf_r+0xb2>
    eca4:	ldrb.w	r8, [r6, #1]
    eca8:	orr.w	r5, r5, #16
    ecac:	mov	r6, r3
    ecae:	b.n	e8e6 <__ssvfscanf_r+0xb2>
    ecb0:	add	r3, sp, #72	; 0x48
    ecb2:	mov	r1, r8
    ecb4:	mov	r0, r3
    ecb6:	movs	r2, #8
    ecb8:	str	r3, [sp, #32]
    ecba:	bl	9078 <memset>
    ecbe:	ands.w	r9, r5, #16
    ecc2:	bne.w	f588 <__ssvfscanf_r+0xd54>
    ecc6:	ldr	r2, [sp, #20]
    ecc8:	mov	r3, r2
    ecca:	adds	r3, #4
    eccc:	ldr.w	r8, [r2]
    ecd0:	str	r3, [sp, #20]
    ecd2:	movs	r6, #0
    ecd4:	bl	b2c0 <__locale_ctype_ptr>
    ecd8:	ldr.w	r3, [fp]
    ecdc:	ldrb	r3, [r3, #0]
    ecde:	add	r0, r3
    ece0:	ldrb	r3, [r0, #1]
    ece2:	lsls	r0, r3, #28
    ece4:	bmi.n	ecec <__ssvfscanf_r+0x4b8>
    ece6:	cmp	r4, #0
    ece8:	bne.w	f4ec <__ssvfscanf_r+0xcb8>
    ecec:	cmp.w	r9, #0
    ecf0:	bne.n	ecfc <__ssvfscanf_r+0x4c8>
    ecf2:	str.w	r9, [r8]
    ecf6:	ldr	r3, [sp, #24]
    ecf8:	adds	r3, #1
    ecfa:	str	r3, [sp, #24]
    ecfc:	ldr	r6, [sp, #12]
    ecfe:	mov	r4, r6
    ed00:	b.n	e8c4 <__ssvfscanf_r+0x90>
    ed02:	ldr	r0, [sp, #20]
    ed04:	ldr	r5, [r0, #0]
    ed06:	mov	r3, r0
    ed08:	adds	r3, #4
    ed0a:	add.w	r8, r5, r4
    ed0e:	str	r3, [sp, #12]
    ed10:	mov	r4, r5
    ed12:	b.n	ed22 <__ssvfscanf_r+0x4ee>
    ed14:	.word	0x0000d129
    ed18:	.word	0x00011ec1
    ed1c:	ldr.w	r2, [fp]
    ed20:	ldrb	r1, [r2, #0]
    ed22:	ldrb.w	r3, [r9, r1]
    ed26:	adds	r0, r2, #1
    ed28:	cbz	r3, ed5c <__ssvfscanf_r+0x528>
    ed2a:	ldr.w	r3, [fp, #4]
    ed2e:	str.w	r0, [fp]
    ed32:	subs	r3, #1
    ed34:	str.w	r3, [fp, #4]
    ed38:	ldrb	r3, [r2, #0]
    ed3a:	strb.w	r3, [r4], #1
    ed3e:	cmp	r8, r4
    ed40:	beq.n	ed5c <__ssvfscanf_r+0x528>
    ed42:	ldr.w	r3, [fp, #4]
    ed46:	cmp	r3, #0
    ed48:	bgt.n	ed1c <__ssvfscanf_r+0x4e8>
    ed4a:	mov	r1, fp
    ed4c:	mov	r0, sl
    ed4e:	bl	12278 <__ssrefill_r>
    ed52:	cmp	r0, #0
    ed54:	beq.n	ed1c <__ssvfscanf_r+0x4e8>
    ed56:	cmp	r5, r4
    ed58:	beq.w	ea7e <__ssvfscanf_r+0x24a>
    ed5c:	subs	r5, r4, r5
    ed5e:	beq.w	e8d0 <__ssvfscanf_r+0x9c>
    ed62:	ldr	r2, [sp, #24]
    ed64:	adds	r2, #1
    ed66:	movs	r3, #0
    ed68:	str	r2, [sp, #24]
    ed6a:	ldr	r2, [sp, #12]
    ed6c:	str	r2, [sp, #20]
    ed6e:	strb	r3, [r4, #0]
    ed70:	add	r7, r5
    ed72:	mov	r4, r6
    ed74:	b.n	e8c4 <__ssvfscanf_r+0x90>
    ed76:	str	r3, [sp, #12]
    ed78:	bl	b2c0 <__locale_ctype_ptr>
    ed7c:	add	r0, r8
    ed7e:	ldrb	r3, [r0, #1]
    ed80:	and.w	r3, r3, #3
    ed84:	cmp	r3, #1
    ed86:	ldr.w	r3, [fp, #4]
    ed8a:	beq.w	eeba <__ssvfscanf_r+0x686>
    ed8e:	cmp	r3, #0
    ed90:	bgt.w	ec0e <__ssvfscanf_r+0x3da>
    ed94:	b.n	ec84 <__ssvfscanf_r+0x450>
    ed96:	add	r3, sp, #72	; 0x48
    ed98:	mov	r0, r3
    ed9a:	movs	r2, #8
    ed9c:	movs	r1, #0
    ed9e:	str	r3, [sp, #32]
    eda0:	bl	9078 <memset>
    eda4:	ands.w	r3, r5, #16
    eda8:	str	r3, [sp, #40]	; 0x28
    edaa:	bne.n	eea8 <__ssvfscanf_r+0x674>
    edac:	ldr	r2, [sp, #20]
    edae:	mov	r3, r2
    edb0:	adds	r3, #4
    edb2:	ldr.w	r9, [r2]
    edb6:	str	r3, [sp, #20]
    edb8:	movs	r5, #0
    edba:	add.w	r8, sp, #336	; 0x150
    edbe:	bl	b29c <__locale_mb_cur_max>
    edc2:	cmp	r0, r5
    edc4:	beq.w	ea7e <__ssvfscanf_r+0x24a>
    edc8:	ldmia.w	fp, {r2, r3}
    edcc:	ldrb.w	r0, [r2], #1
    edd0:	str.w	r2, [fp]
    edd4:	subs	r3, #1
    edd6:	ldr	r2, [sp, #32]
    edd8:	str	r2, [sp, #0]
    edda:	adds	r6, r5, #1
    eddc:	str.w	r3, [fp, #4]
    ede0:	mov	r1, r9
    ede2:	strb.w	r0, [r8, r5]
    ede6:	mov	r3, r6
    ede8:	mov	r2, r8
    edea:	mov	r0, sl
    edec:	bl	111c4 <_mbrtowc_r>
    edf0:	adds	r1, r0, #1
    edf2:	beq.w	ea7e <__ssvfscanf_r+0x24a>
    edf6:	cbnz	r0, ee22 <__ssvfscanf_r+0x5ee>
    edf8:	ldr	r3, [sp, #40]	; 0x28
    edfa:	cbnz	r3, ee42 <__ssvfscanf_r+0x60e>
    edfc:	str.w	r3, [r9]
    ee00:	add	r7, r6
    ee02:	subs	r4, #1
    ee04:	add.w	r9, r9, #4
    ee08:	ldr.w	r3, [fp, #4]
    ee0c:	cmp	r3, #0
    ee0e:	mov.w	r5, #0
    ee12:	ble.n	ee30 <__ssvfscanf_r+0x5fc>
    ee14:	cmp	r4, #0
    ee16:	bne.n	edbe <__ssvfscanf_r+0x58a>
    ee18:	ldr	r3, [sp, #40]	; 0x28
    ee1a:	cmp	r3, #0
    ee1c:	beq.w	ecf6 <__ssvfscanf_r+0x4c2>
    ee20:	b.n	ecfc <__ssvfscanf_r+0x4c8>
    ee22:	adds	r0, #2
    ee24:	bne.n	ee48 <__ssvfscanf_r+0x614>
    ee26:	ldr.w	r3, [fp, #4]
    ee2a:	cmp	r3, #0
    ee2c:	mov	r5, r6
    ee2e:	bgt.n	edbe <__ssvfscanf_r+0x58a>
    ee30:	mov	r1, fp
    ee32:	mov	r0, sl
    ee34:	bl	12278 <__ssrefill_r>
    ee38:	cmp	r0, #0
    ee3a:	beq.n	ee14 <__ssvfscanf_r+0x5e0>
    ee3c:	cmp	r5, #0
    ee3e:	beq.n	ee18 <__ssvfscanf_r+0x5e4>
    ee40:	b.n	ea7e <__ssvfscanf_r+0x24a>
    ee42:	add	r7, r6
    ee44:	subs	r4, #1
    ee46:	b.n	ee08 <__ssvfscanf_r+0x5d4>
    ee48:	ldr	r3, [sp, #40]	; 0x28
    ee4a:	add	r7, r6
    ee4c:	subs	r4, #1
    ee4e:	cmp	r3, #0
    ee50:	bne.n	ee08 <__ssvfscanf_r+0x5d4>
    ee52:	b.n	ee04 <__ssvfscanf_r+0x5d0>
    ee54:	mov	r8, r5
    ee56:	mov	r5, r8
    ee58:	add	r7, r5
    ee5a:	b.n	ed72 <__ssvfscanf_r+0x53e>
    ee5c:	cmp	r5, #0
    ee5e:	beq.w	e8d0 <__ssvfscanf_r+0x9c>
    ee62:	add	r7, r5
    ee64:	b.n	ed72 <__ssvfscanf_r+0x53e>
    ee66:	cmp	r5, #0
    ee68:	bne.w	eb8e <__ssvfscanf_r+0x35a>
    ee6c:	b.n	ea7e <__ssvfscanf_r+0x24a>
    ee6e:	ldr	r5, [sp, #20]
    ee70:	mov	r3, r4
    ee72:	ldr	r1, [r5, #0]
    ee74:	str.w	fp, [sp]
    ee78:	movs	r2, #1
    ee7a:	mov	r0, sl
    ee7c:	bl	122b4 <_sfread_r>
    ee80:	adds	r6, r5, #4
    ee82:	cmp	r0, #0
    ee84:	beq.w	ea7e <__ssvfscanf_r+0x24a>
    ee88:	ldr	r3, [sp, #24]
    ee8a:	str	r6, [sp, #20]
    ee8c:	ldr	r6, [sp, #12]
    ee8e:	adds	r3, #1
    ee90:	add	r7, r0
    ee92:	str	r3, [sp, #24]
    ee94:	mov	r4, r6
    ee96:	b.n	e8c4 <__ssvfscanf_r+0x90>
    ee98:	mov	r1, fp
    ee9a:	mov	r0, sl
    ee9c:	bl	12278 <__ssrefill_r>
    eea0:	cmp	r0, #0
    eea2:	beq.w	e9f2 <__ssvfscanf_r+0x1be>
    eea6:	b.n	ea7e <__ssvfscanf_r+0x24a>
    eea8:	mov.w	r9, #0
    eeac:	b.n	edb8 <__ssvfscanf_r+0x584>
    eeae:	ldrb.w	r8, [r6, #2]
    eeb2:	orr.w	r5, r5, #2
    eeb6:	adds	r6, #2
    eeb8:	b.n	e8e6 <__ssvfscanf_r+0xb2>
    eeba:	cmp	r3, #0
    eebc:	orr.w	r5, r5, #1
    eec0:	bgt.w	ec0e <__ssvfscanf_r+0x3da>
    eec4:	b.n	ec84 <__ssvfscanf_r+0x450>
    eec6:	lsls	r4, r5, #31
    eec8:	bmi.n	eee4 <__ssvfscanf_r+0x6b0>
    eeca:	lsls	r0, r5, #30
    eecc:	bpl.n	eee4 <__ssvfscanf_r+0x6b0>
    eece:	ldr	r2, [sp, #20]
    eed0:	ldr	r6, [sp, #12]
    eed2:	ldr	r3, [r2, #0]
    eed4:	mov	r0, r7
    eed6:	asrs	r1, r7, #31
    eed8:	adds	r2, #4
    eeda:	str	r2, [sp, #20]
    eedc:	strd	r0, r1, [r3]
    eee0:	mov	r4, r6
    eee2:	b.n	e8c4 <__ssvfscanf_r+0x90>
    eee4:	ldr	r2, [sp, #20]
    eee6:	ldr	r6, [sp, #12]
    eee8:	ldr	r3, [r2, #0]
    eeea:	str	r7, [r3, #0]
    eeec:	mov	r3, r2
    eeee:	adds	r3, #4
    eef0:	str	r3, [sp, #20]
    eef2:	mov	r4, r6
    eef4:	b.n	e8c4 <__ssvfscanf_r+0x90>
    eef6:	mov	r1, fp
    eef8:	mov	r0, sl
    eefa:	bl	12278 <__ssrefill_r>
    eefe:	cmp	r0, #0
    ef00:	bne.w	ea7e <__ssvfscanf_r+0x24a>
    ef04:	ldr	r3, [pc, #504]	; (f100 <__ssvfscanf_r+0x8cc>)
    ef06:	str	r0, [sp, #16]
    ef08:	str	r3, [sp, #28]
    ef0a:	movs	r6, #3
    ef0c:	b.n	ea40 <__ssvfscanf_r+0x20c>
    ef0e:	mov	r1, fp
    ef10:	mov	r0, sl
    ef12:	bl	12278 <__ssrefill_r>
    ef16:	cmp	r0, #0
    ef18:	beq.w	ebae <__ssvfscanf_r+0x37a>
    ef1c:	b.n	ea7e <__ssvfscanf_r+0x24a>
    ef1e:	mov	r1, fp
    ef20:	mov	r0, sl
    ef22:	bl	12278 <__ssrefill_r>
    ef26:	cmp	r0, #0
    ef28:	beq.w	eb44 <__ssvfscanf_r+0x310>
    ef2c:	b.n	ea7e <__ssvfscanf_r+0x24a>
    ef2e:	mov	r1, fp
    ef30:	mov	r0, sl
    ef32:	bl	12278 <__ssrefill_r>
    ef36:	cmp	r0, #0
    ef38:	beq.w	ec72 <__ssvfscanf_r+0x43e>
    ef3c:	b.n	ea7e <__ssvfscanf_r+0x24a>
    ef3e:	mov	r1, fp
    ef40:	mov	r0, sl
    ef42:	bl	12278 <__ssrefill_r>
    ef46:	cmp	r0, #0
    ef48:	beq.w	ead6 <__ssvfscanf_r+0x2a2>
    ef4c:	b.n	ea7e <__ssvfscanf_r+0x24a>
    ef4e:	mov	r1, fp
    ef50:	mov	r0, sl
    ef52:	bl	12278 <__ssrefill_r>
    ef56:	cmp	r0, #0
    ef58:	beq.w	eabe <__ssvfscanf_r+0x28a>
    ef5c:	b.n	ea7e <__ssvfscanf_r+0x24a>
    ef5e:	cmp	r6, #3
    ef60:	beq.w	f2a2 <__ssvfscanf_r+0xa6e>
    ef64:	cmp	r6, #4
    ef66:	bne.w	f3e4 <__ssvfscanf_r+0xbb0>
    ef6a:	mov	r0, sl
    ef6c:	bl	111a8 <_localeconv_r>
    ef70:	subs	r3, r4, #1
    ef72:	ldr	r2, [r0, #0]
    ef74:	str	r2, [sp, #48]	; 0x30
    ef76:	cmp.w	r3, #348	; 0x15c
    ef7a:	bls.w	f44c <__ssvfscanf_r+0xc18>
    ef7e:	mvn.w	r1, #348	; 0x15c
    ef82:	adds	r3, r4, r1
    ef84:	str	r3, [sp, #56]	; 0x38
    ef86:	movw	r4, #349	; 0x15d
    ef8a:	add	r3, sp, #336	; 0x150
    ef8c:	mov.w	r8, #0
    ef90:	mov	r2, r3
    ef92:	str	r3, [sp, #40]	; 0x28
    ef94:	orr.w	r5, r5, #1920	; 0x780
    ef98:	mov	r3, r8
    ef9a:	str.w	r8, [sp, #60]	; 0x3c
    ef9e:	str.w	r8, [sp, #52]	; 0x34
    efa2:	mov	r6, r8
    efa4:	str.w	r8, [sp, #44]	; 0x2c
    efa8:	mov	r9, r2
    efaa:	ldr.w	r0, [fp]
    efae:	ldrb	r1, [r0, #0]
    efb0:	sub.w	lr, r1, #43	; 0x2b
    efb4:	cmp.w	lr, #78	; 0x4e
    efb8:	bhi.w	f252 <__ssvfscanf_r+0xa1e>
    efbc:	tbh	[pc, lr, lsl #1]
    efc0:	.word	0x0149007a
    efc4:	.word	0x0149007a
    efc8:	.word	0x006e0149
    efcc:	.word	0x004f004f
    efd0:	.word	0x004f004f
    efd4:	.word	0x004f004f
    efd8:	.word	0x004f004f
    efdc:	.word	0x0149004f
    efe0:	.word	0x01490149
    efe4:	.word	0x01490149
    efe8:	.word	0x01490149
    efec:	.word	0x01490144
    eff0:	.word	0x01490149
    eff4:	.word	0x0125012c
    eff8:	.word	0x01490149
    effc:	.word	0x014900a2
    f000:	.word	0x01490149
    f004:	.word	0x008b0149
    f008:	.word	0x01490149
    f00c:	.word	0x01490149
    f010:	.word	0x00850149
    f014:	.word	0x01490149
    f018:	.word	0x01490149
    f01c:	.word	0x0149007f
    f020:	.word	0x01490149
    f024:	.word	0x01490149
    f028:	.word	0x01490149
    f02c:	.word	0x01490144
    f030:	.word	0x01490149
    f034:	.word	0x0125012c
    f038:	.word	0x01490149
    f03c:	.word	0x014900a2
    f040:	.word	0x01490149
    f044:	.word	0x008b0149
    f048:	.word	0x01490149
    f04c:	.word	0x01490149
    f050:	.word	0x00850149
    f054:	.word	0x01490149
    f058:	.word	0x01490149
    f05c:	.short	0x007f
    f05e:	cmn.w	r3, r8
    f062:	bne.n	f092 <__ssvfscanf_r+0x85e>
    f064:	bic.w	r5, r5, #384	; 0x180
    f068:	strb.w	r1, [r9]
    f06c:	add.w	r9, r9, #1
    f070:	ldr.w	r1, [fp, #4]
    f074:	subs	r1, #1
    f076:	cmp	r1, #0
    f078:	add.w	r4, r4, #4294967295
    f07c:	add.w	r7, r7, #1
    f080:	str.w	r1, [fp, #4]
    f084:	ble.w	f26c <__ssvfscanf_r+0xa38>
    f088:	adds	r0, #1
    f08a:	str.w	r0, [fp]
    f08e:	cmp	r4, #0
    f090:	bne.n	efaa <__ssvfscanf_r+0x776>
    f092:	cmp	r6, #0
    f094:	beq.n	f11c <__ssvfscanf_r+0x8e8>
    f096:	bic.w	r5, r5, #256	; 0x100
    f09a:	b.n	f11c <__ssvfscanf_r+0x8e8>
    f09c:	lsls	r2, r5, #23
    f09e:	bpl.n	f05e <__ssvfscanf_r+0x82a>
    f0a0:	ldr	r2, [sp, #56]	; 0x38
    f0a2:	bic.w	r5, r5, #128	; 0x80
    f0a6:	adds	r6, #1
    f0a8:	cmp	r2, #0
    f0aa:	beq.n	f070 <__ssvfscanf_r+0x83c>
    f0ac:	subs	r2, #1
    f0ae:	str	r2, [sp, #56]	; 0x38
    f0b0:	adds	r4, #1
    f0b2:	b.n	f070 <__ssvfscanf_r+0x83c>
    f0b4:	lsls	r2, r5, #24
    f0b6:	bpl.n	f092 <__ssvfscanf_r+0x85e>
    f0b8:	bic.w	r5, r5, #128	; 0x80
    f0bc:	b.n	f068 <__ssvfscanf_r+0x834>
    f0be:	cmp.w	r8, #7
    f0c2:	bne.n	f092 <__ssvfscanf_r+0x85e>
    f0c4:	mov.w	r8, #8
    f0c8:	b.n	f068 <__ssvfscanf_r+0x834>
    f0ca:	cmp.w	r8, #6
    f0ce:	bne.n	f092 <__ssvfscanf_r+0x85e>
    f0d0:	mov.w	r8, #7
    f0d4:	b.n	f068 <__ssvfscanf_r+0x834>
    f0d6:	cmp	r3, #0
    f0d8:	bne.w	f298 <__ssvfscanf_r+0xa64>
    f0dc:	cbnz	r6, f0ea <__ssvfscanf_r+0x8b6>
    f0de:	and.w	lr, r5, #1792	; 0x700
    f0e2:	cmp.w	lr, #1792	; 0x700
    f0e6:	beq.w	f570 <__ssvfscanf_r+0xd3c>
    f0ea:	cmp.w	r8, #1
    f0ee:	beq.n	f0f6 <__ssvfscanf_r+0x8c2>
    f0f0:	cmp.w	r8, #4
    f0f4:	bne.n	f092 <__ssvfscanf_r+0x85e>
    f0f6:	add.w	r8, r8, #1
    f0fa:	uxtb.w	r8, r8
    f0fe:	b.n	f068 <__ssvfscanf_r+0x834>
    f100:	.word	0x0000d129
    f104:	cmp.w	r8, #0
    f108:	bne.w	f286 <__ssvfscanf_r+0xa52>
    f10c:	cmp	r6, #0
    f10e:	bne.n	f096 <__ssvfscanf_r+0x862>
    f110:	and.w	lr, r5, #1792	; 0x700
    f114:	cmp.w	lr, #1792	; 0x700
    f118:	beq.w	f590 <__ssvfscanf_r+0xd5c>
    f11c:	subs	r3, #1
    f11e:	cmp	r3, #1
    f120:	bls.w	f626 <__ssvfscanf_r+0xdf2>
    f124:	add.w	r3, r8, #4294967295
    f128:	cmp	r3, #6
    f12a:	bhi.n	f15a <__ssvfscanf_r+0x926>
    f12c:	cmp.w	r8, #2
    f130:	bls.w	f674 <__ssvfscanf_r+0xe40>
    f134:	cmp.w	r8, #3
    f138:	beq.n	f15a <__ssvfscanf_r+0x926>
    f13a:	sub.w	r4, r8, #4
    f13e:	uxtb	r4, r4
    f140:	mvn.w	r8, r4
    f144:	add	r8, r9
    f146:	ldrb.w	r1, [r9, #-1]!
    f14a:	mov	r2, fp
    f14c:	mov	r0, sl
    f14e:	bl	121f4 <_sungetc_r>
    f152:	cmp	r8, r9
    f154:	bne.n	f146 <__ssvfscanf_r+0x912>
    f156:	subs	r7, #1
    f158:	subs	r7, r7, r4
    f15a:	lsls	r1, r5, #23
    f15c:	bpl.n	f198 <__ssvfscanf_r+0x964>
    f15e:	lsls	r2, r5, #21
    f160:	bmi.w	f64a <__ssvfscanf_r+0xe16>
    f164:	ldrb.w	r1, [r9, #-1]
    f168:	cmp	r1, #101	; 0x65
    f16a:	add.w	r4, r9, #4294967295
    f16e:	add.w	r8, r7, #4294967295
    f172:	beq.n	f18c <__ssvfscanf_r+0x958>
    f174:	cmp	r1, #69	; 0x45
    f176:	beq.n	f18c <__ssvfscanf_r+0x958>
    f178:	mov	r2, fp
    f17a:	mov	r0, sl
    f17c:	bl	121f4 <_sungetc_r>
    f180:	ldrb.w	r1, [r9, #-2]
    f184:	sub.w	r8, r7, #2
    f188:	sub.w	r4, r9, #2
    f18c:	mov	r2, fp
    f18e:	mov	r0, sl
    f190:	bl	121f4 <_sungetc_r>
    f194:	mov	r7, r8
    f196:	mov	r9, r4
    f198:	ands.w	r2, r5, #16
    f19c:	bne.w	ecfc <__ssvfscanf_r+0x4c8>
    f1a0:	and.w	r3, r5, #1536	; 0x600
    f1a4:	cmp.w	r3, #1024	; 0x400
    f1a8:	strb.w	r2, [r9]
    f1ac:	beq.w	f59a <__ssvfscanf_r+0xd66>
    f1b0:	ldr	r3, [sp, #52]	; 0x34
    f1b2:	cmp	r3, #0
    f1b4:	bne.w	f5bc <__ssvfscanf_r+0xd88>
    f1b8:	ldr	r1, [sp, #40]	; 0x28
    f1ba:	movs	r2, #0
    f1bc:	mov	r0, sl
    f1be:	bl	cfd0 <_strtod_r>
    f1c2:	lsls	r3, r5, #31
    f1c4:	bmi.w	f452 <__ssvfscanf_r+0xc1e>
    f1c8:	ands.w	r5, r5, #2
    f1cc:	bne.w	f452 <__ssvfscanf_r+0xc1e>
    f1d0:	vmov	r2, r3, d0
    f1d4:	vmov	r0, r1, d0
    f1d8:	vstr	d0, [sp, #32]
    f1dc:	bl	ada8 <__aeabi_dcmpun>
    f1e0:	ldr	r4, [sp, #20]
    f1e2:	vldr	d0, [sp, #32]
    f1e6:	adds	r6, r4, #4
    f1e8:	ldr	r4, [r4, #0]
    f1ea:	cmp	r0, #0
    f1ec:	bne.w	f6a8 <__ssvfscanf_r+0xe74>
    f1f0:	vmov	r0, r1, d0
    f1f4:	bl	ae64 <__aeabi_d2f>
    f1f8:	str	r6, [sp, #20]
    f1fa:	str	r0, [r4, #0]
    f1fc:	ldr	r3, [sp, #24]
    f1fe:	ldr	r6, [sp, #12]
    f200:	adds	r3, #1
    f202:	str	r3, [sp, #24]
    f204:	mov	r4, r6
    f206:	b.w	e8c4 <__ssvfscanf_r+0x90>
    f20a:	cmp.w	r8, #2
    f20e:	bne.w	f092 <__ssvfscanf_r+0x85e>
    f212:	mov.w	r8, #3
    f216:	b.n	f068 <__ssvfscanf_r+0x834>
    f218:	and.w	lr, r5, #1280	; 0x500
    f21c:	cmp.w	lr, #1024	; 0x400
    f220:	beq.n	f22e <__ssvfscanf_r+0x9fa>
    f222:	lsls	r2, r5, #21
    f224:	bpl.w	f092 <__ssvfscanf_r+0x85e>
    f228:	cmp	r6, #0
    f22a:	beq.w	f11c <__ssvfscanf_r+0x8e8>
    f22e:	lsls	r2, r5, #22
    f230:	bmi.n	f23c <__ssvfscanf_r+0xa08>
    f232:	ldr	r2, [sp, #44]	; 0x2c
    f234:	str.w	r9, [sp, #60]	; 0x3c
    f238:	subs	r2, r6, r2
    f23a:	str	r2, [sp, #52]	; 0x34
    f23c:	bic.w	r5, r5, #1920	; 0x780
    f240:	orr.w	r5, r5, #384	; 0x180
    f244:	movs	r6, #0
    f246:	b.n	f068 <__ssvfscanf_r+0x834>
    f248:	cmp	r3, #1
    f24a:	bne.w	f092 <__ssvfscanf_r+0x85e>
    f24e:	movs	r3, #2
    f250:	b.n	f068 <__ssvfscanf_r+0x834>
    f252:	ldr	r2, [sp, #48]	; 0x30
    f254:	ldrb.w	lr, [r2]
    f258:	cmp	lr, r1
    f25a:	bne.w	f092 <__ssvfscanf_r+0x85e>
    f25e:	lsls	r2, r5, #22
    f260:	bpl.w	f092 <__ssvfscanf_r+0x85e>
    f264:	bic.w	r5, r5, #640	; 0x280
    f268:	str	r6, [sp, #44]	; 0x2c
    f26a:	b.n	f068 <__ssvfscanf_r+0x834>
    f26c:	mov	r1, fp
    f26e:	mov	r0, sl
    f270:	str	r3, [sp, #32]
    f272:	bl	12278 <__ssrefill_r>
    f276:	ldr	r3, [sp, #32]
    f278:	cmp	r0, #0
    f27a:	bne.w	f092 <__ssvfscanf_r+0x85e>
    f27e:	cmp	r4, #0
    f280:	bne.w	efaa <__ssvfscanf_r+0x776>
    f284:	b.n	f092 <__ssvfscanf_r+0x85e>
    f286:	cmp.w	r8, #3
    f28a:	beq.w	f0f6 <__ssvfscanf_r+0x8c2>
    f28e:	cmp.w	r8, #5
    f292:	beq.w	f0f6 <__ssvfscanf_r+0x8c2>
    f296:	b.n	f092 <__ssvfscanf_r+0x85e>
    f298:	cmp	r3, #2
    f29a:	bne.w	f0ea <__ssvfscanf_r+0x8b6>
    f29e:	movs	r3, #3
    f2a0:	b.n	f068 <__ssvfscanf_r+0x834>
    f2a2:	subs	r3, r4, #1
    f2a4:	cmp.w	r3, #348	; 0x15c
    f2a8:	itte	hi
    f2aa:	mvnhi.w	r0, #348	; 0x15c
    f2ae:	addhi.w	r9, r4, r0
    f2b2:	movls	r9, r8
    f2b4:	add	r3, sp, #336	; 0x150
    f2b6:	mov	r0, r2
    f2b8:	mov	r2, r7
    f2ba:	mov	r7, r9
    f2bc:	ldr.w	r9, [sp, #16]
    f2c0:	str	r3, [sp, #40]	; 0x28
    f2c2:	it	hi
    f2c4:	movwhi	r4, #349	; 0x15d
    f2c8:	orr.w	r5, r5, #3456	; 0xd80
    f2cc:	mov	r6, r3
    f2ce:	mov.w	r8, #0
    f2d2:	sub.w	r3, r1, #43	; 0x2b
    f2d6:	cmp	r3, #77	; 0x4d
    f2d8:	bhi.n	f37e <__ssvfscanf_r+0xb4a>
    f2da:	tbb	[pc, r3]
    f2de:	.short	0x507e
    f2e0:	.word	0x6f50507e
    f2e4:	.word	0x69696969
    f2e8:	.word	0x4a696969
    f2ec:	.word	0x5050504a
    f2f0:	.word	0x50505050
    f2f4:	.word	0x44444444
    f2f8:	.word	0x50504444
    f2fc:	.word	0x50505050
    f300:	.word	0x50505050
    f304:	.word	0x50505050
    f308:	.word	0x27505050
    f30c:	.word	0x50505050
    f310:	.word	0x50505050
    f314:	.word	0x44444444
    f318:	.word	0x50504444
    f31c:	.word	0x50505050
    f320:	.word	0x50505050
    f324:	.word	0x50505050
    f328:	.word	0x27505050
    f32c:	and.w	r3, r5, #1536	; 0x600
    f330:	cmp.w	r3, #512	; 0x200
    f334:	bne.n	f37e <__ssvfscanf_r+0xb4a>
    f336:	bic.w	r5, r5, #512	; 0x200
    f33a:	orr.w	r5, r5, #1280	; 0x500
    f33e:	mov.w	r9, #16
    f342:	strb	r1, [r6, #0]
    f344:	adds	r6, #1
    f346:	ldr.w	r3, [fp, #4]
    f34a:	subs	r3, #1
    f34c:	cmp	r3, #0
    f34e:	str.w	r3, [fp, #4]
    f352:	ble.n	f43a <__ssvfscanf_r+0xc06>
    f354:	adds	r0, #1
    f356:	str.w	r0, [fp]
    f35a:	subs	r4, #1
    f35c:	beq.n	f37e <__ssvfscanf_r+0xb4a>
    f35e:	ldr.w	r0, [fp]
    f362:	ldrb	r1, [r0, #0]
    f364:	b.n	f2d2 <__ssvfscanf_r+0xa9e>
    f366:	cmp.w	r9, #10
    f36a:	ble.n	f37e <__ssvfscanf_r+0xb4a>
    f36c:	bic.w	r5, r5, #2944	; 0xb80
    f370:	b.n	f342 <__ssvfscanf_r+0xb0e>
    f372:	ldr	r3, [pc, #756]	; (f668 <__ssvfscanf_r+0xe34>)
    f374:	ldrsh.w	r9, [r3, r9, lsl #1]
    f378:	cmp.w	r9, #8
    f37c:	bgt.n	f36c <__ssvfscanf_r+0xb38>
    f37e:	lsls	r1, r5, #23
    f380:	mov	r7, r2
    f382:	str.w	r9, [sp, #16]
    f386:	bpl.n	f398 <__ssvfscanf_r+0xb64>
    f388:	ldr	r3, [sp, #40]	; 0x28
    f38a:	cmp	r6, r3
    f38c:	bhi.w	f578 <__ssvfscanf_r+0xd44>
    f390:	ldr	r3, [sp, #40]	; 0x28
    f392:	cmp	r6, r3
    f394:	beq.w	e8d0 <__ssvfscanf_r+0x9c>
    f398:	ands.w	r4, r5, #16
    f39c:	beq.w	f4c4 <__ssvfscanf_r+0xc90>
    f3a0:	ldr	r3, [sp, #40]	; 0x28
    f3a2:	subs	r6, r6, r3
    f3a4:	add	r6, r8
    f3a6:	add	r7, r6
    f3a8:	ldr	r6, [sp, #12]
    f3aa:	mov	r4, r6
    f3ac:	b.w	e8c4 <__ssvfscanf_r+0x90>
    f3b0:	ldr	r3, [pc, #692]	; (f668 <__ssvfscanf_r+0xe34>)
    f3b2:	bic.w	r5, r5, #2944	; 0xb80
    f3b6:	ldrsh.w	r9, [r3, r9, lsl #1]
    f3ba:	b.n	f342 <__ssvfscanf_r+0xb0e>
    f3bc:	lsls	r3, r5, #20
    f3be:	bpl.n	f342 <__ssvfscanf_r+0xb0e>
    f3c0:	cmp.w	r9, #0
    f3c4:	bne.n	f3ce <__ssvfscanf_r+0xb9a>
    f3c6:	orr.w	r5, r5, #512	; 0x200
    f3ca:	mov.w	r9, #8
    f3ce:	lsls	r3, r5, #21
    f3d0:	bpl.w	f554 <__ssvfscanf_r+0xd20>
    f3d4:	bic.w	r5, r5, #1408	; 0x580
    f3d8:	b.n	f342 <__ssvfscanf_r+0xb0e>
    f3da:	lsls	r3, r5, #24
    f3dc:	bpl.n	f37e <__ssvfscanf_r+0xb4a>
    f3de:	bic.w	r5, r5, #128	; 0x80
    f3e2:	b.n	f342 <__ssvfscanf_r+0xb0e>
    f3e4:	cmp	r4, #0
    f3e6:	it	eq
    f3e8:	moveq.w	r4, #4294967295
    f3ec:	ands.w	r3, r5, #1
    f3f0:	bne.w	ecb0 <__ssvfscanf_r+0x47c>
    f3f4:	lsls	r1, r5, #27
    f3f6:	bpl.n	f460 <__ssvfscanf_r+0xc2c>
    f3f8:	mov	r5, r3
    f3fa:	bl	b2c0 <__locale_ctype_ptr>
    f3fe:	ldr.w	r3, [fp]
    f402:	ldrb	r2, [r3, #0]
    f404:	add	r0, r2
    f406:	adds	r3, #1
    f408:	ldrb	r2, [r0, #1]
    f40a:	lsls	r2, r2, #28
    f40c:	bmi.w	eb8e <__ssvfscanf_r+0x35a>
    f410:	ldr.w	r2, [fp, #4]
    f414:	str.w	r3, [fp]
    f418:	adds	r5, #1
    f41a:	subs	r3, r2, #1
    f41c:	cmp	r4, r5
    f41e:	str.w	r3, [fp, #4]
    f422:	beq.w	eb8e <__ssvfscanf_r+0x35a>
    f426:	cmp	r3, #0
    f428:	bgt.n	f3fa <__ssvfscanf_r+0xbc6>
    f42a:	mov	r1, fp
    f42c:	mov	r0, sl
    f42e:	bl	12278 <__ssrefill_r>
    f432:	cmp	r0, #0
    f434:	beq.n	f3fa <__ssvfscanf_r+0xbc6>
    f436:	b.w	eb8e <__ssvfscanf_r+0x35a>
    f43a:	mov	r1, fp
    f43c:	mov	r0, sl
    f43e:	str	r2, [sp, #16]
    f440:	bl	12278 <__ssrefill_r>
    f444:	ldr	r2, [sp, #16]
    f446:	cmp	r0, #0
    f448:	beq.n	f35a <__ssvfscanf_r+0xb26>
    f44a:	b.n	f37e <__ssvfscanf_r+0xb4a>
    f44c:	str.w	r8, [sp, #56]	; 0x38
    f450:	b.n	ef8a <__ssvfscanf_r+0x756>
    f452:	ldr	r2, [sp, #20]
    f454:	ldr	r3, [r2, #0]
    f456:	adds	r2, #4
    f458:	str	r2, [sp, #20]
    f45a:	vstr	d0, [r3]
    f45e:	b.n	f1fc <__ssvfscanf_r+0x9c8>
    f460:	ldr	r2, [sp, #20]
    f462:	ldr	r5, [r2, #0]
    f464:	adds	r6, r2, #4
    f466:	add	r4, r5
    f468:	mov	r8, r5
    f46a:	bl	b2c0 <__locale_ctype_ptr>
    f46e:	ldr.w	r2, [fp]
    f472:	ldrb	r3, [r2, #0]
    f474:	add	r0, r3
    f476:	adds	r1, r2, #1
    f478:	ldrb	r3, [r0, #1]
    f47a:	lsls	r3, r3, #28
    f47c:	bmi.n	f4aa <__ssvfscanf_r+0xc76>
    f47e:	ldr.w	r3, [fp, #4]
    f482:	str.w	r1, [fp]
    f486:	subs	r3, #1
    f488:	str.w	r3, [fp, #4]
    f48c:	ldrb	r3, [r2, #0]
    f48e:	strb.w	r3, [r8], #1
    f492:	cmp	r4, r8
    f494:	beq.n	f4ac <__ssvfscanf_r+0xc78>
    f496:	ldr.w	r3, [fp, #4]
    f49a:	cmp	r3, #0
    f49c:	bgt.n	f46a <__ssvfscanf_r+0xc36>
    f49e:	mov	r1, fp
    f4a0:	mov	r0, sl
    f4a2:	bl	12278 <__ssrefill_r>
    f4a6:	cmp	r0, #0
    f4a8:	beq.n	f46a <__ssvfscanf_r+0xc36>
    f4aa:	mov	r4, r8
    f4ac:	ldr	r2, [sp, #24]
    f4ae:	str	r6, [sp, #20]
    f4b0:	ldr	r6, [sp, #12]
    f4b2:	subs	r5, r4, r5
    f4b4:	movs	r3, #0
    f4b6:	adds	r2, #1
    f4b8:	strb	r3, [r4, #0]
    f4ba:	add	r7, r5
    f4bc:	str	r2, [sp, #24]
    f4be:	mov	r4, r6
    f4c0:	b.w	e8c4 <__ssvfscanf_r+0x90>
    f4c4:	mov	r2, r4
    f4c6:	strb	r4, [r6, #0]
    f4c8:	ldr	r3, [sp, #16]
    f4ca:	ldr	r1, [sp, #40]	; 0x28
    f4cc:	ldr	r4, [sp, #28]
    f4ce:	mov	r0, sl
    f4d0:	blx	r4
    f4d2:	lsls	r2, r5, #26
    f4d4:	bmi.n	f564 <__ssvfscanf_r+0xd30>
    f4d6:	lsls	r3, r5, #29
    f4d8:	bpl.n	f5d2 <__ssvfscanf_r+0xd9e>
    f4da:	ldr	r2, [sp, #20]
    f4dc:	ldr	r3, [r2, #0]
    f4de:	adds	r2, #4
    f4e0:	str	r2, [sp, #20]
    f4e2:	strh	r0, [r3, #0]
    f4e4:	ldr	r3, [sp, #24]
    f4e6:	adds	r3, #1
    f4e8:	str	r3, [sp, #24]
    f4ea:	b.n	f3a0 <__ssvfscanf_r+0xb6c>
    f4ec:	bl	b29c <__locale_mb_cur_max>
    f4f0:	cmp	r6, r0
    f4f2:	beq.w	ea7e <__ssvfscanf_r+0x24a>
    f4f6:	ldmia.w	fp, {r2, r3}
    f4fa:	ldrb.w	r0, [r2], #1
    f4fe:	str.w	r2, [fp]
    f502:	ldr	r2, [sp, #32]
    f504:	str	r2, [sp, #0]
    f506:	add	r2, sp, #336	; 0x150
    f508:	adds	r5, r6, #1
    f50a:	subs	r3, #1
    f50c:	strb	r0, [r2, r6]
    f50e:	str.w	r3, [fp, #4]
    f512:	mov	r1, r8
    f514:	mov	r3, r5
    f516:	mov	r0, sl
    f518:	bl	111c4 <_mbrtowc_r>
    f51c:	adds	r6, r0, #1
    f51e:	beq.w	ea7e <__ssvfscanf_r+0x24a>
    f522:	cmp	r0, #0
    f524:	bne.n	f5fe <__ssvfscanf_r+0xdca>
    f526:	str.w	r0, [r8]
    f52a:	bl	11188 <iswspace>
    f52e:	cmp	r0, #0
    f530:	beq.w	f692 <__ssvfscanf_r+0xe5e>
    f534:	cmp	r5, #0
    f536:	beq.w	ecec <__ssvfscanf_r+0x4b8>
    f53a:	add	r3, sp, #336	; 0x150
    f53c:	adds	r4, r3, r5
    f53e:	subs	r5, #1
    f540:	mov	r2, fp
    f542:	ldrb.w	r1, [r4, #-1]!
    f546:	mov	r0, sl
    f548:	bl	121f4 <_sungetc_r>
    f54c:	cmp	r5, #0
    f54e:	bne.n	f53e <__ssvfscanf_r+0xd0a>
    f550:	b.w	ecec <__ssvfscanf_r+0x4b8>
    f554:	bic.w	r5, r5, #896	; 0x380
    f558:	cbz	r7, f55e <__ssvfscanf_r+0xd2a>
    f55a:	subs	r7, #1
    f55c:	adds	r4, #1
    f55e:	add.w	r8, r8, #1
    f562:	b.n	f346 <__ssvfscanf_r+0xb12>
    f564:	ldr	r2, [sp, #20]
    f566:	ldr	r3, [r2, #0]
    f568:	adds	r2, #4
    f56a:	str	r2, [sp, #20]
    f56c:	str	r0, [r3, #0]
    f56e:	b.n	f4e4 <__ssvfscanf_r+0xcb0>
    f570:	bic.w	r5, r5, #1920	; 0x780
    f574:	movs	r3, #1
    f576:	b.n	f068 <__ssvfscanf_r+0x834>
    f578:	ldrb.w	r1, [r6, #-1]
    f57c:	mov	r2, fp
    f57e:	mov	r0, sl
    f580:	bl	121f4 <_sungetc_r>
    f584:	subs	r6, #1
    f586:	b.n	f390 <__ssvfscanf_r+0xb5c>
    f588:	add.w	r8, sp, #68	; 0x44
    f58c:	b.w	ecd2 <__ssvfscanf_r+0x49e>
    f590:	bic.w	r5, r5, #1920	; 0x780
    f594:	mov.w	r8, #1
    f598:	b.n	f068 <__ssvfscanf_r+0x834>
    f59a:	ldr	r3, [sp, #44]	; 0x2c
    f59c:	subs	r6, r6, r3
    f59e:	negs	r2, r6
    f5a0:	cmp	r6, #0
    f5a2:	beq.w	f1b8 <__ssvfscanf_r+0x984>
    f5a6:	addw	r3, sp, #675	; 0x2a3
    f5aa:	cmp	r9, r3
    f5ac:	it	cs
    f5ae:	addwcs	r9, sp, #674	; 0x2a2
    f5b2:	mov	r0, r9
    f5b4:	ldr	r1, [pc, #180]	; (f66c <__ssvfscanf_r+0xe38>)
    f5b6:	bl	be68 <sprintf>
    f5ba:	b.n	f1b8 <__ssvfscanf_r+0x984>
    f5bc:	ldr	r4, [sp, #60]	; 0x3c
    f5be:	mov	r1, r4
    f5c0:	movs	r3, #10
    f5c2:	adds	r1, #1
    f5c4:	mov	r0, sl
    f5c6:	bl	d128 <_strtol_r>
    f5ca:	ldr	r3, [sp, #52]	; 0x34
    f5cc:	mov	r9, r4
    f5ce:	subs	r2, r0, r3
    f5d0:	b.n	f5a6 <__ssvfscanf_r+0xd72>
    f5d2:	ands.w	r2, r5, #1
    f5d6:	bne.n	f564 <__ssvfscanf_r+0xd30>
    f5d8:	lsls	r4, r5, #30
    f5da:	bpl.n	f564 <__ssvfscanf_r+0xd30>
    f5dc:	ldr	r3, [sp, #28]
    f5de:	mov	r1, r3
    f5e0:	ldr	r3, [pc, #140]	; (f670 <__ssvfscanf_r+0xe3c>)
    f5e2:	cmp	r1, r3
    f5e4:	mov	r0, sl
    f5e6:	ldr	r3, [sp, #16]
    f5e8:	ldr	r1, [sp, #40]	; 0x28
    f5ea:	beq.n	f6b6 <__ssvfscanf_r+0xe82>
    f5ec:	bl	11d34 <_strtoll_r>
    f5f0:	ldr	r2, [sp, #20]
    f5f2:	ldr	r3, [r2, #0]
    f5f4:	adds	r2, #4
    f5f6:	str	r2, [sp, #20]
    f5f8:	strd	r0, r1, [r3]
    f5fc:	b.n	f4e4 <__ssvfscanf_r+0xcb0>
    f5fe:	adds	r0, #2
    f600:	bne.n	f644 <__ssvfscanf_r+0xe10>
    f602:	mov	r6, r5
    f604:	ldr.w	r3, [fp, #4]
    f608:	cmp	r3, #0
    f60a:	bgt.w	ecd4 <__ssvfscanf_r+0x4a0>
    f60e:	mov	r1, fp
    f610:	mov	r0, sl
    f612:	bl	12278 <__ssrefill_r>
    f616:	cmp	r0, #0
    f618:	beq.w	ecd4 <__ssvfscanf_r+0x4a0>
    f61c:	cmp	r6, #0
    f61e:	bne.w	ea7e <__ssvfscanf_r+0x24a>
    f622:	b.w	ecec <__ssvfscanf_r+0x4b8>
    f626:	ldr	r3, [sp, #40]	; 0x28
    f628:	cmp	r9, r3
    f62a:	bls.w	e8d0 <__ssvfscanf_r+0x9c>
    f62e:	ldrb.w	r1, [r9, #-1]!
    f632:	mov	r2, fp
    f634:	mov	r0, sl
    f636:	bl	121f4 <_sungetc_r>
    f63a:	ldr	r3, [sp, #40]	; 0x28
    f63c:	cmp	r9, r3
    f63e:	bne.n	f62e <__ssvfscanf_r+0xdfa>
    f640:	b.w	e8d0 <__ssvfscanf_r+0x9c>
    f644:	ldr.w	r0, [r8]
    f648:	b.n	f52a <__ssvfscanf_r+0xcf6>
    f64a:	ldr	r3, [sp, #40]	; 0x28
    f64c:	cmp	r9, r3
    f64e:	bls.w	e8d0 <__ssvfscanf_r+0x9c>
    f652:	ldrb.w	r1, [r9, #-1]!
    f656:	mov	r2, fp
    f658:	mov	r0, sl
    f65a:	bl	121f4 <_sungetc_r>
    f65e:	ldr	r3, [sp, #40]	; 0x28
    f660:	cmp	r9, r3
    f662:	bne.n	f652 <__ssvfscanf_r+0xe1e>
    f664:	b.w	e8d0 <__ssvfscanf_r+0x9c>
    f668:	.word	0x000131ac
    f66c:	.word	0x000131d0
    f670:	.word	0x00011ec1
    f674:	ldr	r3, [sp, #40]	; 0x28
    f676:	cmp	r9, r3
    f678:	bls.w	e8d0 <__ssvfscanf_r+0x9c>
    f67c:	ldrb.w	r1, [r9, #-1]!
    f680:	mov	r2, fp
    f682:	mov	r0, sl
    f684:	bl	121f4 <_sungetc_r>
    f688:	ldr	r3, [sp, #40]	; 0x28
    f68a:	cmp	r9, r3
    f68c:	bne.n	f67c <__ssvfscanf_r+0xe48>
    f68e:	b.w	e8d0 <__ssvfscanf_r+0x9c>
    f692:	add	r7, r5
    f694:	subs	r4, #1
    f696:	cmp.w	r9, #0
    f69a:	bne.n	f6a4 <__ssvfscanf_r+0xe70>
    f69c:	add.w	r8, r8, #4
    f6a0:	mov	r6, r9
    f6a2:	b.n	f604 <__ssvfscanf_r+0xdd0>
    f6a4:	mov	r6, r0
    f6a6:	b.n	f604 <__ssvfscanf_r+0xdd0>
    f6a8:	mov	r0, r5
    f6aa:	bl	11b7c <nanf>
    f6ae:	str	r6, [sp, #20]
    f6b0:	vstr	s0, [r4]
    f6b4:	b.n	f1fc <__ssvfscanf_r+0x9c8>
    f6b6:	bl	120d0 <_strtoull_r>
    f6ba:	b.n	f5f0 <__ssvfscanf_r+0xdbc>

0000f6bc <_vdprintf_r>:
    f6bc:	push	{r4, r5, r6, r7, lr}
    f6be:	sub.w	sp, sp, #532	; 0x214
    f6c2:	add	r5, sp, #16
    f6c4:	str	r3, [sp, #0]
    f6c6:	mov	r7, r1
    f6c8:	mov	r3, r2
    f6ca:	mov.w	r4, #512	; 0x200
    f6ce:	add	r2, sp, #12
    f6d0:	mov	r1, r5
    f6d2:	str	r4, [sp, #12]
    f6d4:	mov	r6, r0
    f6d6:	bl	123b0 <_vasnprintf_r>
    f6da:	cbz	r0, f700 <_vdprintf_r+0x44>
    f6dc:	mov	r4, r0
    f6de:	mov	r2, r0
    f6e0:	mov	r1, r7
    f6e2:	ldr	r3, [sp, #12]
    f6e4:	mov	r0, r6
    f6e6:	bl	f73c <_write_r>
    f6ea:	cmp	r4, r5
    f6ec:	str	r0, [sp, #12]
    f6ee:	beq.n	f6fa <_vdprintf_r+0x3e>
    f6f0:	mov	r0, r6
    f6f2:	mov	r1, r4
    f6f4:	bl	10850 <_free_r>
    f6f8:	ldr	r0, [sp, #12]
    f6fa:	add.w	sp, sp, #532	; 0x214
    f6fe:	pop	{r4, r5, r6, r7, pc}
    f700:	mov.w	r0, #4294967295
    f704:	b.n	f6fa <_vdprintf_r+0x3e>
    f706:	nop

0000f708 <vdprintf>:
    f708:	push	{r4}
    f70a:	ldr	r4, [pc, #16]	; (f71c <vdprintf+0x14>)
    f70c:	mov	r3, r2
    f70e:	mov	r2, r1
    f710:	mov	r1, r0
    f712:	ldr	r0, [r4, #0]
    f714:	ldr.w	r4, [sp], #4
    f718:	b.w	f6bc <_vdprintf_r>
    f71c:	.word	0x1fff1848

0000f720 <__ascii_wctomb>:
    f720:	cbz	r1, f72c <__ascii_wctomb+0xc>
    f722:	cmp	r2, #255	; 0xff
    f724:	bhi.n	f730 <__ascii_wctomb+0x10>
    f726:	strb	r2, [r1, #0]
    f728:	movs	r0, #1
    f72a:	bx	lr
    f72c:	mov	r0, r1
    f72e:	bx	lr
    f730:	movs	r3, #138	; 0x8a
    f732:	str	r3, [r0, #0]
    f734:	mov.w	r0, #4294967295
    f738:	bx	lr
    f73a:	nop

0000f73c <_write_r>:
    f73c:	push	{r4, r5, r6, lr}
    f73e:	mov	r5, r1
    f740:	ldr	r4, [pc, #32]	; (f764 <_write_r+0x28>)
    f742:	mov	r1, r2
    f744:	mov	r6, r0
    f746:	mov	r2, r3
    f748:	mov	r0, r5
    f74a:	movs	r3, #0
    f74c:	str	r3, [r4, #0]
    f74e:	bl	1520 <_write>
    f752:	adds	r3, r0, #1
    f754:	beq.n	f758 <_write_r+0x1c>
    f756:	pop	{r4, r5, r6, pc}
    f758:	ldr	r3, [r4, #0]
    f75a:	cmp	r3, #0
    f75c:	beq.n	f756 <_write_r+0x1a>
    f75e:	str	r3, [r6, #0]
    f760:	pop	{r4, r5, r6, pc}
    f762:	nop
    f764:	.word	0x2001d080

0000f768 <__register_exitproc>:
    f768:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    f76c:	ldr	r4, [pc, #148]	; (f804 <__register_exitproc+0x9c>)
    f76e:	ldr	r5, [r4, #0]
    f770:	ldr.w	r4, [r5, #328]	; 0x148
    f774:	mov	r6, r0
    f776:	mov	r8, r1
    f778:	mov	sl, r2
    f77a:	mov	r9, r3
    f77c:	cbz	r4, f7f0 <__register_exitproc+0x88>
    f77e:	ldr	r0, [r4, #4]
    f780:	cmp	r0, #31
    f782:	bgt.n	f7b4 <__register_exitproc+0x4c>
    f784:	adds	r3, r0, #1
    f786:	cbz	r6, f7a6 <__register_exitproc+0x3e>
    f788:	add.w	r5, r4, r0, lsl #2
    f78c:	movs	r2, #1
    f78e:	str.w	sl, [r5, #136]	; 0x88
    f792:	ldr.w	r1, [r4, #392]	; 0x188
    f796:	lsls	r2, r0
    f798:	orrs	r1, r2
    f79a:	cmp	r6, #2
    f79c:	str.w	r1, [r4, #392]	; 0x188
    f7a0:	str.w	r9, [r5, #264]	; 0x108
    f7a4:	beq.n	f7e4 <__register_exitproc+0x7c>
    f7a6:	adds	r0, #2
    f7a8:	str	r3, [r4, #4]
    f7aa:	str.w	r8, [r4, r0, lsl #2]
    f7ae:	movs	r0, #0
    f7b0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f7b4:	ldr	r3, [pc, #80]	; (f808 <__register_exitproc+0xa0>)
    f7b6:	cbz	r3, f7fa <__register_exitproc+0x92>
    f7b8:	mov.w	r0, #400	; 0x190
    f7bc:	bl	b2d4 <malloc>
    f7c0:	mov	r4, r0
    f7c2:	cbz	r0, f7fa <__register_exitproc+0x92>
    f7c4:	ldr.w	r3, [r5, #328]	; 0x148
    f7c8:	movs	r7, #0
    f7ca:	stmia.w	r0, {r3, r7}
    f7ce:	str.w	r4, [r5, #328]	; 0x148
    f7d2:	mov	r0, r7
    f7d4:	movs	r3, #1
    f7d6:	str.w	r7, [r4, #392]	; 0x188
    f7da:	str.w	r7, [r4, #396]	; 0x18c
    f7de:	cmp	r6, #0
    f7e0:	beq.n	f7a6 <__register_exitproc+0x3e>
    f7e2:	b.n	f788 <__register_exitproc+0x20>
    f7e4:	ldr.w	r1, [r4, #396]	; 0x18c
    f7e8:	orrs	r2, r1
    f7ea:	str.w	r2, [r4, #396]	; 0x18c
    f7ee:	b.n	f7a6 <__register_exitproc+0x3e>
    f7f0:	add.w	r4, r5, #332	; 0x14c
    f7f4:	str.w	r4, [r5, #328]	; 0x148
    f7f8:	b.n	f77e <__register_exitproc+0x16>
    f7fa:	mov.w	r0, #4294967295
    f7fe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f802:	nop
    f804:	.word	0x000130d0
    f808:	.word	0x0000b2d5

0000f80c <register_fini>:
    f80c:	ldr	r3, [pc, #8]	; (f818 <register_fini+0xc>)
    f80e:	cbz	r3, f816 <register_fini+0xa>
    f810:	ldr	r0, [pc, #8]	; (f81c <register_fini+0x10>)
    f812:	b.w	f820 <atexit>
    f816:	bx	lr
    f818:	.word	0x00000000
    f81c:	.word	0x0001078d

0000f820 <atexit>:
    f820:	movs	r3, #0
    f822:	mov	r1, r0
    f824:	mov	r2, r3
    f826:	mov	r0, r3
    f828:	b.w	f768 <__register_exitproc>

0000f82c <quorem>:
    f82c:	ldr	r2, [r0, #16]
    f82e:	ldr	r3, [r1, #16]
    f830:	cmp	r3, r2
    f832:	bgt.w	f950 <quorem+0x124>
    f836:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f83a:	add.w	r8, r3, #4294967295
    f83e:	add.w	r7, r1, #20
    f842:	add.w	fp, r0, #20
    f846:	ldr.w	r2, [r7, r8, lsl #2]
    f84a:	ldr.w	r3, [fp, r8, lsl #2]
    f84e:	mov.w	r4, r8, lsl #2
    f852:	sub	sp, #12
    f854:	adds	r2, #1
    f856:	udiv	r9, r3, r2
    f85a:	add.w	r3, fp, r4
    f85e:	str	r4, [sp, #0]
    f860:	add.w	sl, r7, r4
    f864:	str	r3, [sp, #4]
    f866:	cmp.w	r9, #0
    f86a:	beq.n	f8e0 <quorem+0xb4>
    f86c:	movs	r5, #0
    f86e:	mov	ip, r7
    f870:	mov	lr, fp
    f872:	mov	r3, r5
    f874:	ldr.w	r6, [ip], #4
    f878:	ldr.w	r2, [lr]
    f87c:	uxth	r4, r6
    f87e:	mla	r5, r9, r4, r5
    f882:	lsrs	r6, r6, #16
    f884:	lsrs	r4, r5, #16
    f886:	mla	r4, r9, r6, r4
    f88a:	uxth	r5, r5
    f88c:	subs	r3, r3, r5
    f88e:	uxth	r6, r4
    f890:	uxtah	r3, r3, r2
    f894:	rsb	r6, r6, r2, lsr #16
    f898:	add.w	r6, r6, r3, asr #16
    f89c:	uxth	r3, r3
    f89e:	orr.w	r3, r3, r6, lsl #16
    f8a2:	cmp	sl, ip
    f8a4:	str.w	r3, [lr], #4
    f8a8:	mov.w	r5, r4, lsr #16
    f8ac:	mov.w	r3, r6, asr #16
    f8b0:	bcs.n	f874 <quorem+0x48>
    f8b2:	ldr	r3, [sp, #0]
    f8b4:	ldr.w	r3, [fp, r3]
    f8b8:	cbnz	r3, f8e0 <quorem+0xb4>
    f8ba:	ldr	r4, [sp, #4]
    f8bc:	subs	r3, r4, #4
    f8be:	cmp	fp, r3
    f8c0:	bcs.n	f8dc <quorem+0xb0>
    f8c2:	ldr.w	r3, [r4, #-4]
    f8c6:	cbnz	r3, f8dc <quorem+0xb0>
    f8c8:	sub.w	r3, r4, #8
    f8cc:	b.n	f8d4 <quorem+0xa8>
    f8ce:	ldr	r2, [r3, #0]
    f8d0:	subs	r3, #4
    f8d2:	cbnz	r2, f8dc <quorem+0xb0>
    f8d4:	cmp	fp, r3
    f8d6:	add.w	r8, r8, #4294967295
    f8da:	bcc.n	f8ce <quorem+0xa2>
    f8dc:	str.w	r8, [r0, #16]
    f8e0:	mov	r4, r0
    f8e2:	bl	116c8 <__mcmp>
    f8e6:	cmp	r0, #0
    f8e8:	blt.n	f948 <quorem+0x11c>
    f8ea:	add.w	r9, r9, #1
    f8ee:	mov	r5, fp
    f8f0:	movs	r3, #0
    f8f2:	ldr.w	r1, [r7], #4
    f8f6:	ldr	r0, [r5, #0]
    f8f8:	uxth	r2, r1
    f8fa:	subs	r2, r3, r2
    f8fc:	lsrs	r1, r1, #16
    f8fe:	uxtah	r2, r2, r0
    f902:	rsb	r3, r1, r0, lsr #16
    f906:	add.w	r3, r3, r2, asr #16
    f90a:	uxth	r1, r2
    f90c:	orr.w	r1, r1, r3, lsl #16
    f910:	cmp	sl, r7
    f912:	str.w	r1, [r5], #4
    f916:	mov.w	r3, r3, asr #16
    f91a:	bcs.n	f8f2 <quorem+0xc6>
    f91c:	ldr.w	r2, [fp, r8, lsl #2]
    f920:	add.w	r3, fp, r8, lsl #2
    f924:	cbnz	r2, f948 <quorem+0x11c>
    f926:	subs	r2, r3, #4
    f928:	cmp	fp, r2
    f92a:	bcs.n	f944 <quorem+0x118>
    f92c:	ldr.w	r2, [r3, #-4]
    f930:	cbnz	r2, f944 <quorem+0x118>
    f932:	subs	r3, #8
    f934:	b.n	f93c <quorem+0x110>
    f936:	ldr	r2, [r3, #0]
    f938:	subs	r3, #4
    f93a:	cbnz	r2, f944 <quorem+0x118>
    f93c:	cmp	fp, r3
    f93e:	add.w	r8, r8, #4294967295
    f942:	bcc.n	f936 <quorem+0x10a>
    f944:	str.w	r8, [r4, #16]
    f948:	mov	r0, r9
    f94a:	add	sp, #12
    f94c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f950:	movs	r0, #0
    f952:	bx	lr
    f954:			; <UNDEFINED> instruction: 0xffffffff

0000f958 <_dtoa_r>:
    f958:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f95c:	vmov	r6, r7, d0
    f960:	sub	sp, #108	; 0x6c
    f962:	ldr	r4, [r0, #64]	; 0x40
    f964:	ldr	r5, [sp, #144]	; 0x90
    f966:	str	r1, [sp, #0]
    f968:	mov	r9, r0
    f96a:	str	r2, [sp, #20]
    f96c:	str	r3, [sp, #12]
    f96e:	vmov	sl, s0
    f972:	mov	fp, r7
    f974:	cbz	r4, f98c <_dtoa_r+0x34>
    f976:	ldr	r2, [r0, #68]	; 0x44
    f978:	str	r2, [r4, #4]
    f97a:	movs	r3, #1
    f97c:	lsls	r3, r2
    f97e:	str	r3, [r4, #8]
    f980:	mov	r1, r4
    f982:	bl	1126c <_Bfree>
    f986:	movs	r3, #0
    f988:	str.w	r3, [r9, #64]	; 0x40
    f98c:	cmp.w	fp, #0
    f990:	mov	r4, fp
    f992:	blt.n	f9fe <_dtoa_r+0xa6>
    f994:	movs	r3, #0
    f996:	str	r3, [r5, #0]
    f998:	ldr	r3, [pc, #644]	; (fc20 <_dtoa_r+0x2c8>)
    f99a:	mov	r2, r3
    f99c:	ands	r3, r4
    f99e:	cmp	r3, r2
    f9a0:	beq.n	f9d0 <_dtoa_r+0x78>
    f9a2:	movs	r2, #0
    f9a4:	movs	r3, #0
    f9a6:	mov	r0, sl
    f9a8:	mov	r1, fp
    f9aa:	bl	ad44 <__aeabi_dcmpeq>
    f9ae:	mov	r6, sl
    f9b0:	mov	r7, fp
    f9b2:	mov	r8, r0
    f9b4:	cbz	r0, fa0a <_dtoa_r+0xb2>
    f9b6:	ldr	r2, [sp, #12]
    f9b8:	movs	r3, #1
    f9ba:	str	r3, [r2, #0]
    f9bc:	ldr	r3, [sp, #148]	; 0x94
    f9be:	cmp	r3, #0
    f9c0:	beq.w	fb40 <_dtoa_r+0x1e8>
    f9c4:	ldr	r0, [pc, #604]	; (fc24 <_dtoa_r+0x2cc>)
    f9c6:	str	r0, [r3, #0]
    f9c8:	subs	r0, #1
    f9ca:	add	sp, #108	; 0x6c
    f9cc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f9d0:	ldr	r2, [sp, #12]
    f9d2:	movw	r3, #9999	; 0x270f
    f9d6:	str	r3, [r2, #0]
    f9d8:	cmp.w	sl, #0
    f9dc:	beq.w	fb14 <_dtoa_r+0x1bc>
    f9e0:	ldr	r0, [pc, #580]	; (fc28 <_dtoa_r+0x2d0>)
    f9e2:	ldr	r3, [sp, #148]	; 0x94
    f9e4:	cmp	r3, #0
    f9e6:	beq.n	f9ca <_dtoa_r+0x72>
    f9e8:	ldrb	r3, [r0, #3]
    f9ea:	cmp	r3, #0
    f9ec:	beq.w	fb44 <_dtoa_r+0x1ec>
    f9f0:	add.w	r3, r0, #8
    f9f4:	ldr	r2, [sp, #148]	; 0x94
    f9f6:	str	r3, [r2, #0]
    f9f8:	add	sp, #108	; 0x6c
    f9fa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f9fe:	movs	r3, #1
    fa00:	bic.w	r4, fp, #2147483648	; 0x80000000
    fa04:	str	r3, [r5, #0]
    fa06:	mov	fp, r4
    fa08:	b.n	f998 <_dtoa_r+0x40>
    fa0a:	add	r2, sp, #96	; 0x60
    fa0c:	add	r1, sp, #100	; 0x64
    fa0e:	vmov	d0, r6, r7
    fa12:	mov	r0, r9
    fa14:	bl	11944 <__d2b>
    fa18:	lsrs	r5, r4, #20
    fa1a:	str	r0, [sp, #40]	; 0x28
    fa1c:	bne.w	fb26 <_dtoa_r+0x1ce>
    fa20:	ldr	r5, [sp, #96]	; 0x60
    fa22:	ldr	r6, [sp, #100]	; 0x64
    fa24:	add	r6, r5
    fa26:	addw	r3, r6, #1074	; 0x432
    fa2a:	cmp	r3, #32
    fa2c:	ble.w	ff40 <_dtoa_r+0x5e8>
    fa30:	rsb	r3, r3, #64	; 0x40
    fa34:	addw	r0, r6, #1042	; 0x412
    fa38:	lsls	r4, r3
    fa3a:	lsr.w	r0, sl, r0
    fa3e:	orrs	r0, r4
    fa40:	bl	a788 <__aeabi_ui2d>
    fa44:	movs	r3, #1
    fa46:	subs	r4, r6, #1
    fa48:	sub.w	r1, r1, #32505856	; 0x1f00000
    fa4c:	str	r3, [sp, #60]	; 0x3c
    fa4e:	movs	r2, #0
    fa50:	ldr	r3, [pc, #472]	; (fc2c <_dtoa_r+0x2d4>)
    fa52:	bl	a50c <__aeabi_dsub>
    fa56:	add	r3, pc, #432	; (adr r3, fc08 <_dtoa_r+0x2b0>)
    fa58:	ldrd	r2, r3, [r3]
    fa5c:	bl	a874 <__aeabi_dmul>
    fa60:	add	r3, pc, #428	; (adr r3, fc10 <_dtoa_r+0x2b8>)
    fa62:	ldrd	r2, r3, [r3]
    fa66:	bl	a510 <__adddf3>
    fa6a:	mov	r6, r0
    fa6c:	mov	r0, r4
    fa6e:	mov	r7, r1
    fa70:	bl	a7a8 <__aeabi_i2d>
    fa74:	add	r3, pc, #416	; (adr r3, fc18 <_dtoa_r+0x2c0>)
    fa76:	ldrd	r2, r3, [r3]
    fa7a:	bl	a874 <__aeabi_dmul>
    fa7e:	mov	r2, r0
    fa80:	mov	r3, r1
    fa82:	mov	r0, r6
    fa84:	mov	r1, r7
    fa86:	bl	a510 <__adddf3>
    fa8a:	mov	r6, r0
    fa8c:	mov	r7, r1
    fa8e:	bl	add4 <__aeabi_d2iz>
    fa92:	movs	r2, #0
    fa94:	str	r0, [sp, #16]
    fa96:	movs	r3, #0
    fa98:	mov	r0, r6
    fa9a:	mov	r1, r7
    fa9c:	bl	ad58 <__aeabi_dcmplt>
    faa0:	cmp	r0, #0
    faa2:	bne.w	fef6 <_dtoa_r+0x59e>
    faa6:	ldr	r6, [sp, #16]
    faa8:	cmp	r6, #22
    faaa:	bhi.w	fef0 <_dtoa_r+0x598>
    faae:	ldr	r3, [pc, #384]	; (fc30 <_dtoa_r+0x2d8>)
    fab0:	add.w	r3, r3, r6, lsl #3
    fab4:	ldrd	r0, r1, [r3]
    fab8:	mov	r2, sl
    faba:	mov	r3, fp
    fabc:	bl	ad94 <__aeabi_dcmpgt>
    fac0:	cmp	r0, #0
    fac2:	beq.w	ff4a <_dtoa_r+0x5f2>
    fac6:	subs	r3, r6, #1
    fac8:	str	r3, [sp, #16]
    faca:	movs	r3, #0
    facc:	str	r3, [sp, #52]	; 0x34
    face:	subs	r5, r5, r4
    fad0:	subs.w	r8, r5, #1
    fad4:	bmi.w	ff2c <_dtoa_r+0x5d4>
    fad8:	movs	r3, #0
    fada:	str	r3, [sp, #28]
    fadc:	ldr	r3, [sp, #16]
    fade:	cmp	r3, #0
    fae0:	blt.w	ff1a <_dtoa_r+0x5c2>
    fae4:	add	r8, r3
    fae6:	str	r3, [sp, #48]	; 0x30
    fae8:	movs	r3, #0
    faea:	str	r3, [sp, #24]
    faec:	ldr	r3, [sp, #0]
    faee:	cmp	r3, #9
    faf0:	bhi.n	fb48 <_dtoa_r+0x1f0>
    faf2:	cmp	r3, #5
    faf4:	ble.w	10780 <_dtoa_r+0xe28>
    faf8:	subs	r3, #4
    fafa:	str	r3, [sp, #0]
    fafc:	movs	r6, #0
    fafe:	ldr	r3, [sp, #0]
    fb00:	subs	r3, #2
    fb02:	cmp	r3, #3
    fb04:	bhi.w	1074e <_dtoa_r+0xdf6>
    fb08:	tbh	[pc, r3, lsl #1]
    fb0c:	.word	0x0224032b
    fb10:	.word	0x04500336
    fb14:	ldr	r3, [pc, #272]	; (fc28 <_dtoa_r+0x2d0>)
    fb16:	ldr	r2, [pc, #284]	; (fc34 <_dtoa_r+0x2dc>)
    fb18:	ubfx	r0, r4, #0, #20
    fb1c:	cmp	r0, #0
    fb1e:	ite	ne
    fb20:	movne	r0, r3
    fb22:	moveq	r0, r2
    fb24:	b.n	f9e2 <_dtoa_r+0x8a>
    fb26:	ubfx	r3, fp, #0, #20
    fb2a:	orr.w	r1, r3, #1069547520	; 0x3fc00000
    fb2e:	subw	r4, r5, #1023	; 0x3ff
    fb32:	mov	r0, sl
    fb34:	str.w	r8, [sp, #60]	; 0x3c
    fb38:	orr.w	r1, r1, #3145728	; 0x300000
    fb3c:	ldr	r5, [sp, #96]	; 0x60
    fb3e:	b.n	fa4e <_dtoa_r+0xf6>
    fb40:	ldr	r0, [pc, #244]	; (fc38 <_dtoa_r+0x2e0>)
    fb42:	b.n	f9ca <_dtoa_r+0x72>
    fb44:	adds	r3, r0, #3
    fb46:	b.n	f9f4 <_dtoa_r+0x9c>
    fb48:	movs	r1, #0
    fb4a:	str.w	r1, [r9, #68]	; 0x44
    fb4e:	mov	r0, r9
    fb50:	mov	r4, r1
    fb52:	str	r1, [sp, #0]
    fb54:	bl	11220 <_Balloc>
    fb58:	mov.w	r3, #4294967295
    fb5c:	str	r3, [sp, #32]
    fb5e:	str	r3, [sp, #56]	; 0x38
    fb60:	movs	r3, #1
    fb62:	str	r0, [sp, #36]	; 0x24
    fb64:	str.w	r0, [r9, #64]	; 0x40
    fb68:	str	r4, [sp, #20]
    fb6a:	str	r3, [sp, #44]	; 0x2c
    fb6c:	ldr	r3, [sp, #100]	; 0x64
    fb6e:	cmp	r3, #0
    fb70:	blt.w	fd14 <_dtoa_r+0x3bc>
    fb74:	ldr	r2, [sp, #16]
    fb76:	cmp	r2, #14
    fb78:	bgt.w	fd14 <_dtoa_r+0x3bc>
    fb7c:	ldr	r3, [pc, #176]	; (fc30 <_dtoa_r+0x2d8>)
    fb7e:	add.w	r3, r3, r2, lsl #3
    fb82:	vldr	d7, [r3]
    fb86:	ldr	r3, [sp, #20]
    fb88:	cmp	r3, #0
    fb8a:	vstr	d7, [sp]
    fb8e:	blt.w	1018e <_dtoa_r+0x836>
    fb92:	mov	r6, sl
    fb94:	mov	r7, fp
    fb96:	ldrd	sl, fp, [sp]
    fb9a:	mov	r0, r6
    fb9c:	mov	r2, sl
    fb9e:	mov	r3, fp
    fba0:	mov	r1, r7
    fba2:	bl	aac8 <__aeabi_ddiv>
    fba6:	bl	add4 <__aeabi_d2iz>
    fbaa:	mov	r4, r0
    fbac:	bl	a7a8 <__aeabi_i2d>
    fbb0:	mov	r2, sl
    fbb2:	mov	r3, fp
    fbb4:	bl	a874 <__aeabi_dmul>
    fbb8:	mov	r3, r1
    fbba:	mov	r2, r0
    fbbc:	mov	r1, r7
    fbbe:	mov	r0, r6
    fbc0:	bl	a50c <__aeabi_dsub>
    fbc4:	ldr	r5, [sp, #36]	; 0x24
    fbc6:	add.w	r3, r4, #48	; 0x30
    fbca:	strb	r3, [r5, #0]
    fbcc:	ldr	r3, [sp, #32]
    fbce:	cmp	r3, #1
    fbd0:	mov	r6, r0
    fbd2:	mov	r7, r1
    fbd4:	add.w	r5, r5, #1
    fbd8:	beq.n	fc9e <_dtoa_r+0x346>
    fbda:	movs	r2, #0
    fbdc:	ldr	r3, [pc, #92]	; (fc3c <_dtoa_r+0x2e4>)
    fbde:	bl	a874 <__aeabi_dmul>
    fbe2:	movs	r2, #0
    fbe4:	movs	r3, #0
    fbe6:	mov	r6, r0
    fbe8:	mov	r7, r1
    fbea:	bl	ad44 <__aeabi_dcmpeq>
    fbee:	cmp	r0, #0
    fbf0:	bne.n	fcee <_dtoa_r+0x396>
    fbf2:	str.w	r9, [sp, #20]
    fbf6:	ldr.w	sl, [sp, #32]
    fbfa:	ldr.w	fp, [sp, #36]	; 0x24
    fbfe:	ldrd	r8, r9, [sp]
    fc02:	b.n	fc56 <_dtoa_r+0x2fe>
    fc04:	nop.w
    fc08:	.word	0x636f4361
    fc0c:	.word	0x3fd287a7
    fc10:	.word	0x8b60c8b3
    fc14:	.word	0x3fc68a28
    fc18:	.word	0x509f79fb
    fc1c:	.word	0x3fd34413
    fc20:	.word	0x7ff00000
    fc24:	.word	0x00013199
    fc28:	.word	0x000132e8
    fc2c:	.word	0x3ff80000
    fc30:	.word	0x000133f0
    fc34:	.word	0x000132dc
    fc38:	.word	0x00013198
    fc3c:	.word	0x40240000
    fc40:	bl	a874 <__aeabi_dmul>
    fc44:	movs	r2, #0
    fc46:	movs	r3, #0
    fc48:	mov	r6, r0
    fc4a:	mov	r7, r1
    fc4c:	bl	ad44 <__aeabi_dcmpeq>
    fc50:	cmp	r0, #0
    fc52:	bne.w	103b2 <_dtoa_r+0xa5a>
    fc56:	mov	r2, r8
    fc58:	mov	r3, r9
    fc5a:	mov	r0, r6
    fc5c:	mov	r1, r7
    fc5e:	bl	aac8 <__aeabi_ddiv>
    fc62:	bl	add4 <__aeabi_d2iz>
    fc66:	mov	r4, r0
    fc68:	bl	a7a8 <__aeabi_i2d>
    fc6c:	mov	r2, r8
    fc6e:	mov	r3, r9
    fc70:	bl	a874 <__aeabi_dmul>
    fc74:	mov	r2, r0
    fc76:	mov	r3, r1
    fc78:	mov	r0, r6
    fc7a:	mov	r1, r7
    fc7c:	bl	a50c <__aeabi_dsub>
    fc80:	add.w	lr, r4, #48	; 0x30
    fc84:	strb.w	lr, [r5], #1
    fc88:	rsb	lr, fp, r5
    fc8c:	cmp	lr, sl
    fc8e:	mov	r6, r0
    fc90:	mov	r7, r1
    fc92:	mov.w	r2, #0
    fc96:	ldr	r3, [pc, #696]	; (ff50 <_dtoa_r+0x5f8>)
    fc98:	bne.n	fc40 <_dtoa_r+0x2e8>
    fc9a:	ldr.w	r9, [sp, #20]
    fc9e:	mov	r2, r6
    fca0:	mov	r3, r7
    fca2:	mov	r0, r6
    fca4:	mov	r1, r7
    fca6:	bl	a510 <__adddf3>
    fcaa:	mov	r6, r0
    fcac:	mov	r7, r1
    fcae:	mov	r2, r0
    fcb0:	mov	r3, r1
    fcb2:	ldrd	r0, r1, [sp]
    fcb6:	bl	ad58 <__aeabi_dcmplt>
    fcba:	cbnz	r0, fcce <_dtoa_r+0x376>
    fcbc:	mov	r2, r6
    fcbe:	mov	r3, r7
    fcc0:	ldrd	r0, r1, [sp]
    fcc4:	bl	ad44 <__aeabi_dcmpeq>
    fcc8:	cbz	r0, fcee <_dtoa_r+0x396>
    fcca:	lsls	r3, r4, #31
    fccc:	bpl.n	fcee <_dtoa_r+0x396>
    fcce:	ldrb.w	r4, [r5, #-1]
    fcd2:	ldr	r2, [sp, #36]	; 0x24
    fcd4:	subs	r3, r5, #1
    fcd6:	b.n	fce2 <_dtoa_r+0x38a>
    fcd8:	cmp	r2, r3
    fcda:	beq.w	104d6 <_dtoa_r+0xb7e>
    fcde:	ldrb.w	r4, [r3, #-1]!
    fce2:	cmp	r4, #57	; 0x39
    fce4:	add.w	r5, r3, #1
    fce8:	beq.n	fcd8 <_dtoa_r+0x380>
    fcea:	adds	r4, #1
    fcec:	strb	r4, [r3, #0]
    fcee:	ldr	r1, [sp, #40]	; 0x28
    fcf0:	mov	r0, r9
    fcf2:	bl	1126c <_Bfree>
    fcf6:	movs	r2, #0
    fcf8:	ldr	r3, [sp, #16]
    fcfa:	strb	r2, [r5, #0]
    fcfc:	ldr	r2, [sp, #12]
    fcfe:	adds	r3, #1
    fd00:	str	r3, [r2, #0]
    fd02:	ldr	r3, [sp, #148]	; 0x94
    fd04:	cmp	r3, #0
    fd06:	beq.w	10440 <_dtoa_r+0xae8>
    fd0a:	ldr	r0, [sp, #36]	; 0x24
    fd0c:	str	r5, [r3, #0]
    fd0e:	add	sp, #108	; 0x6c
    fd10:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fd14:	ldr	r2, [sp, #44]	; 0x2c
    fd16:	cmp	r2, #0
    fd18:	beq.w	ff38 <_dtoa_r+0x5e0>
    fd1c:	ldr	r2, [sp, #0]
    fd1e:	cmp	r2, #1
    fd20:	ble.w	101d2 <_dtoa_r+0x87a>
    fd24:	ldr	r3, [sp, #32]
    fd26:	ldr	r2, [sp, #24]
    fd28:	subs	r7, r3, #1
    fd2a:	cmp	r2, r7
    fd2c:	blt.w	10446 <_dtoa_r+0xaee>
    fd30:	subs	r7, r2, r7
    fd32:	ldr	r3, [sp, #32]
    fd34:	cmp	r3, #0
    fd36:	blt.w	1063a <_dtoa_r+0xce2>
    fd3a:	ldr	r5, [sp, #28]
    fd3c:	ldr	r3, [sp, #32]
    fd3e:	ldr	r2, [sp, #28]
    fd40:	movs	r1, #1
    fd42:	add	r2, r3
    fd44:	mov	r0, r9
    fd46:	str	r2, [sp, #28]
    fd48:	add	r8, r3
    fd4a:	bl	11434 <__i2b>
    fd4e:	mov	r6, r0
    fd50:	cbz	r5, fd6c <_dtoa_r+0x414>
    fd52:	cmp.w	r8, #0
    fd56:	ble.n	fd6c <_dtoa_r+0x414>
    fd58:	cmp	r5, r8
    fd5a:	ldr	r2, [sp, #28]
    fd5c:	mov	r3, r5
    fd5e:	it	ge
    fd60:	movge	r3, r8
    fd62:	subs	r2, r2, r3
    fd64:	str	r2, [sp, #28]
    fd66:	subs	r5, r5, r3
    fd68:	rsb	r8, r3, r8
    fd6c:	ldr	r3, [sp, #24]
    fd6e:	cmp	r3, #0
    fd70:	ble.w	1035e <_dtoa_r+0xa06>
    fd74:	ldr	r2, [sp, #44]	; 0x2c
    fd76:	cmp	r2, #0
    fd78:	beq.w	10180 <_dtoa_r+0x828>
    fd7c:	cmp	r7, #0
    fd7e:	beq.w	10180 <_dtoa_r+0x828>
    fd82:	mov	r1, r6
    fd84:	mov	r2, r7
    fd86:	mov	r0, r9
    fd88:	bl	11578 <__pow5mult>
    fd8c:	ldr	r2, [sp, #40]	; 0x28
    fd8e:	mov	r1, r0
    fd90:	mov	r6, r0
    fd92:	mov	r0, r9
    fd94:	bl	11448 <__multiply>
    fd98:	ldr	r1, [sp, #40]	; 0x28
    fd9a:	mov	r4, r0
    fd9c:	mov	r0, r9
    fd9e:	bl	1126c <_Bfree>
    fda2:	ldr	r3, [sp, #24]
    fda4:	subs	r3, r3, r7
    fda6:	str	r3, [sp, #24]
    fda8:	bne.w	1017e <_dtoa_r+0x826>
    fdac:	movs	r1, #1
    fdae:	mov	r0, r9
    fdb0:	bl	11434 <__i2b>
    fdb4:	ldr	r3, [sp, #48]	; 0x30
    fdb6:	str	r0, [sp, #24]
    fdb8:	cmp	r3, #0
    fdba:	beq.w	101e8 <_dtoa_r+0x890>
    fdbe:	mov	r1, r0
    fdc0:	mov	r2, r3
    fdc2:	mov	r0, r9
    fdc4:	bl	11578 <__pow5mult>
    fdc8:	ldr	r3, [sp, #0]
    fdca:	str	r0, [sp, #24]
    fdcc:	cmp	r3, #1
    fdce:	ble.w	103b8 <_dtoa_r+0xa60>
    fdd2:	movs	r7, #0
    fdd4:	ldr	r2, [sp, #24]
    fdd6:	ldr	r3, [r2, #16]
    fdd8:	add.w	r3, r2, r3, lsl #2
    fddc:	ldr	r0, [r3, #16]
    fdde:	bl	11398 <__hi0bits>
    fde2:	rsb	r0, r0, #32
    fde6:	add	r0, r8
    fde8:	ands.w	r0, r0, #31
    fdec:	beq.w	101e4 <_dtoa_r+0x88c>
    fdf0:	rsb	r3, r0, #32
    fdf4:	cmp	r3, #4
    fdf6:	ble.w	10774 <_dtoa_r+0xe1c>
    fdfa:	rsb	r0, r0, #28
    fdfe:	ldr	r3, [sp, #28]
    fe00:	add	r3, r0
    fe02:	str	r3, [sp, #28]
    fe04:	add	r5, r0
    fe06:	add	r8, r0
    fe08:	ldr	r3, [sp, #28]
    fe0a:	cmp	r3, #0
    fe0c:	ble.n	fe1a <_dtoa_r+0x4c2>
    fe0e:	mov	r1, r4
    fe10:	mov	r2, r3
    fe12:	mov	r0, r9
    fe14:	bl	11618 <__lshift>
    fe18:	mov	r4, r0
    fe1a:	cmp.w	r8, #0
    fe1e:	ble.n	fe2c <_dtoa_r+0x4d4>
    fe20:	mov	r2, r8
    fe22:	ldr	r1, [sp, #24]
    fe24:	mov	r0, r9
    fe26:	bl	11618 <__lshift>
    fe2a:	str	r0, [sp, #24]
    fe2c:	ldr	r3, [sp, #52]	; 0x34
    fe2e:	cmp	r3, #0
    fe30:	bne.w	10328 <_dtoa_r+0x9d0>
    fe34:	ldr	r3, [sp, #32]
    fe36:	cmp	r3, #0
    fe38:	ble.w	10362 <_dtoa_r+0xa0a>
    fe3c:	ldr	r3, [sp, #44]	; 0x2c
    fe3e:	cmp	r3, #0
    fe40:	bne.w	1022c <_dtoa_r+0x8d4>
    fe44:	ldr.w	fp, [sp, #36]	; 0x24
    fe48:	ldr	r7, [sp, #32]
    fe4a:	ldr.w	r8, [sp, #24]
    fe4e:	mov	r5, fp
    fe50:	b.n	fe58 <_dtoa_r+0x500>
    fe52:	bl	11280 <__multadd>
    fe56:	mov	r4, r0
    fe58:	mov	r1, r8
    fe5a:	mov	r0, r4
    fe5c:	bl	f82c <quorem>
    fe60:	add.w	sl, r0, #48	; 0x30
    fe64:	strb.w	sl, [r5], #1
    fe68:	rsb	r3, fp, r5
    fe6c:	cmp	r3, r7
    fe6e:	mov.w	r2, #10
    fe72:	mov.w	r3, #0
    fe76:	mov	r1, r4
    fe78:	mov	r0, r9
    fe7a:	blt.n	fe52 <_dtoa_r+0x4fa>
    fe7c:	ldr	r3, [sp, #36]	; 0x24
    fe7e:	ldr	r2, [sp, #32]
    fe80:	cmp	r2, #1
    fe82:	ite	ge
    fe84:	addge	r3, r3, r2
    fe86:	addlt	r3, #1
    fe88:	mov	r5, r3
    fe8a:	mov.w	fp, #0
    fe8e:	mov	r1, r4
    fe90:	movs	r2, #1
    fe92:	mov	r0, r9
    fe94:	bl	11618 <__lshift>
    fe98:	ldr	r1, [sp, #24]
    fe9a:	str	r0, [sp, #40]	; 0x28
    fe9c:	bl	116c8 <__mcmp>
    fea0:	cmp	r0, #0
    fea2:	ble.w	104b0 <_dtoa_r+0xb58>
    fea6:	ldrb.w	r2, [r5, #-1]
    feaa:	ldr	r1, [sp, #36]	; 0x24
    feac:	subs	r3, r5, #1
    feae:	b.n	feba <_dtoa_r+0x562>
    feb0:	cmp	r3, r1
    feb2:	beq.w	1039e <_dtoa_r+0xa46>
    feb6:	ldrb.w	r2, [r3, #-1]!
    feba:	cmp	r2, #57	; 0x39
    febc:	add.w	r5, r3, #1
    fec0:	beq.n	feb0 <_dtoa_r+0x558>
    fec2:	adds	r2, #1
    fec4:	strb	r2, [r3, #0]
    fec6:	ldr	r1, [sp, #24]
    fec8:	mov	r0, r9
    feca:	bl	1126c <_Bfree>
    fece:	cmp	r6, #0
    fed0:	beq.w	fcee <_dtoa_r+0x396>
    fed4:	cmp.w	fp, #0
    fed8:	beq.n	fee6 <_dtoa_r+0x58e>
    feda:	cmp	fp, r6
    fedc:	beq.n	fee6 <_dtoa_r+0x58e>
    fede:	mov	r1, fp
    fee0:	mov	r0, r9
    fee2:	bl	1126c <_Bfree>
    fee6:	mov	r1, r6
    fee8:	mov	r0, r9
    feea:	bl	1126c <_Bfree>
    feee:	b.n	fcee <_dtoa_r+0x396>
    fef0:	movs	r3, #1
    fef2:	str	r3, [sp, #52]	; 0x34
    fef4:	b.n	face <_dtoa_r+0x176>
    fef6:	ldr.w	r8, [sp, #16]
    fefa:	mov	r0, r8
    fefc:	bl	a7a8 <__aeabi_i2d>
    ff00:	mov	r2, r0
    ff02:	mov	r3, r1
    ff04:	mov	r0, r6
    ff06:	mov	r1, r7
    ff08:	bl	ad44 <__aeabi_dcmpeq>
    ff0c:	cmp	r0, #0
    ff0e:	bne.w	faa6 <_dtoa_r+0x14e>
    ff12:	add.w	r3, r8, #4294967295
    ff16:	str	r3, [sp, #16]
    ff18:	b.n	faa6 <_dtoa_r+0x14e>
    ff1a:	ldr	r2, [sp, #28]
    ff1c:	ldr	r3, [sp, #16]
    ff1e:	subs	r2, r2, r3
    ff20:	negs	r3, r3
    ff22:	str	r3, [sp, #24]
    ff24:	movs	r3, #0
    ff26:	str	r2, [sp, #28]
    ff28:	str	r3, [sp, #48]	; 0x30
    ff2a:	b.n	faec <_dtoa_r+0x194>
    ff2c:	rsb	r3, r8, #0
    ff30:	str	r3, [sp, #28]
    ff32:	mov.w	r8, #0
    ff36:	b.n	fadc <_dtoa_r+0x184>
    ff38:	ldr	r7, [sp, #24]
    ff3a:	ldr	r5, [sp, #28]
    ff3c:	ldr	r6, [sp, #44]	; 0x2c
    ff3e:	b.n	fd50 <_dtoa_r+0x3f8>
    ff40:	rsb	r4, r3, #32
    ff44:	lsl.w	r0, sl, r4
    ff48:	b.n	fa40 <_dtoa_r+0xe8>
    ff4a:	str	r0, [sp, #52]	; 0x34
    ff4c:	b.n	face <_dtoa_r+0x176>
    ff4e:	nop
    ff50:	.word	0x40240000
    ff54:	movs	r3, #0
    ff56:	str	r3, [sp, #44]	; 0x2c
    ff58:	ldr	r3, [sp, #16]
    ff5a:	ldr	r2, [sp, #20]
    ff5c:	add	r3, r2
    ff5e:	str	r3, [sp, #56]	; 0x38
    ff60:	adds	r3, #1
    ff62:	cmp	r3, #0
    ff64:	str	r3, [sp, #32]
    ff66:	ble.w	10464 <_dtoa_r+0xb0c>
    ff6a:	ldr	r4, [sp, #32]
    ff6c:	mov	r5, r4
    ff6e:	movs	r1, #0
    ff70:	cmp	r5, #23
    ff72:	str.w	r1, [r9, #68]	; 0x44
    ff76:	bls.n	ff90 <_dtoa_r+0x638>
    ff78:	movs	r2, #1
    ff7a:	movs	r3, #4
    ff7c:	lsls	r3, r3, #1
    ff7e:	add.w	r0, r3, #20
    ff82:	cmp	r0, r5
    ff84:	mov	r1, r2
    ff86:	add.w	r2, r2, #1
    ff8a:	bls.n	ff7c <_dtoa_r+0x624>
    ff8c:	str.w	r1, [r9, #68]	; 0x44
    ff90:	mov	r0, r9
    ff92:	bl	11220 <_Balloc>
    ff96:	cmp	r4, #14
    ff98:	str	r0, [sp, #36]	; 0x24
    ff9a:	str.w	r0, [r9, #64]	; 0x40
    ff9e:	bhi.w	fb6c <_dtoa_r+0x214>
    ffa2:	cmp	r6, #0
    ffa4:	beq.w	fb6c <_dtoa_r+0x214>
    ffa8:	ldr	r1, [sp, #16]
    ffaa:	cmp	r1, #0
    ffac:	strd	sl, fp, [sp, #64]	; 0x40
    ffb0:	ble.w	104e8 <_dtoa_r+0xb90>
    ffb4:	ldr	r3, [pc, #576]	; (101f8 <_dtoa_r+0x8a0>)
    ffb6:	and.w	r2, r1, #15
    ffba:	asrs	r6, r1, #4
    ffbc:	add.w	r3, r3, r2, lsl #3
    ffc0:	lsls	r0, r6, #27
    ffc2:	ldrd	r4, r5, [r3]
    ffc6:	bpl.w	10456 <_dtoa_r+0xafe>
    ffca:	ldr	r3, [pc, #560]	; (101fc <_dtoa_r+0x8a4>)
    ffcc:	mov	r0, sl
    ffce:	mov	r1, fp
    ffd0:	ldrd	r2, r3, [r3, #32]
    ffd4:	bl	aac8 <__aeabi_ddiv>
    ffd8:	strd	r0, r1, [sp, #72]	; 0x48
    ffdc:	and.w	r6, r6, #15
    ffe0:	mov.w	sl, #3
    ffe4:	cbz	r6, 10008 <_dtoa_r+0x6b0>
    ffe6:	ldr	r7, [pc, #532]	; (101fc <_dtoa_r+0x8a4>)
    ffe8:	lsls	r1, r6, #31
    ffea:	bpl.n	10000 <_dtoa_r+0x6a8>
    ffec:	mov	r0, r4
    ffee:	mov	r1, r5
    fff0:	ldrd	r2, r3, [r7]
    fff4:	bl	a874 <__aeabi_dmul>
    fff8:	add.w	sl, sl, #1
    fffc:	mov	r4, r0
    fffe:	mov	r5, r1
   10000:	asrs	r6, r6, #1
   10002:	add.w	r7, r7, #8
   10006:	bne.n	ffe8 <_dtoa_r+0x690>
   10008:	mov	r2, r4
   1000a:	mov	r3, r5
   1000c:	ldrd	r0, r1, [sp, #72]	; 0x48
   10010:	bl	aac8 <__aeabi_ddiv>
   10014:	mov	r6, r0
   10016:	mov	r7, r1
   10018:	ldr	r3, [sp, #52]	; 0x34
   1001a:	cbz	r3, 1002e <_dtoa_r+0x6d6>
   1001c:	movs	r2, #0
   1001e:	ldr	r3, [pc, #480]	; (10200 <_dtoa_r+0x8a8>)
   10020:	mov	r0, r6
   10022:	mov	r1, r7
   10024:	bl	ad58 <__aeabi_dcmplt>
   10028:	cmp	r0, #0
   1002a:	bne.w	10662 <_dtoa_r+0xd0a>
   1002e:	mov	r0, sl
   10030:	bl	a7a8 <__aeabi_i2d>
   10034:	mov	r2, r6
   10036:	mov	r3, r7
   10038:	bl	a874 <__aeabi_dmul>
   1003c:	ldr	r3, [pc, #452]	; (10204 <_dtoa_r+0x8ac>)
   1003e:	movs	r2, #0
   10040:	bl	a510 <__adddf3>
   10044:	ldr	r3, [sp, #32]
   10046:	mov	r4, r0
   10048:	sub.w	r5, r1, #54525952	; 0x3400000
   1004c:	cmp	r3, #0
   1004e:	beq.w	10408 <_dtoa_r+0xab0>
   10052:	ldr	r3, [sp, #16]
   10054:	str	r3, [sp, #88]	; 0x58
   10056:	ldr	r3, [sp, #32]
   10058:	str	r3, [sp, #72]	; 0x48
   1005a:	ldr	r3, [sp, #44]	; 0x2c
   1005c:	cmp	r3, #0
   1005e:	beq.w	1058a <_dtoa_r+0xc32>
   10062:	ldr	r2, [sp, #72]	; 0x48
   10064:	ldr	r3, [pc, #400]	; (101f8 <_dtoa_r+0x8a0>)
   10066:	ldr	r1, [pc, #416]	; (10208 <_dtoa_r+0x8b0>)
   10068:	add.w	r3, r3, r2, lsl #3
   1006c:	ldrd	r2, r3, [r3, #-8]
   10070:	movs	r0, #0
   10072:	bl	aac8 <__aeabi_ddiv>
   10076:	mov	r2, r4
   10078:	mov	r3, r5
   1007a:	bl	a50c <__aeabi_dsub>
   1007e:	mov	sl, r0
   10080:	mov	fp, r1
   10082:	mov	r0, r6
   10084:	mov	r1, r7
   10086:	bl	add4 <__aeabi_d2iz>
   1008a:	mov	r4, r0
   1008c:	bl	a7a8 <__aeabi_i2d>
   10090:	mov	r2, r0
   10092:	mov	r3, r1
   10094:	mov	r0, r6
   10096:	mov	r1, r7
   10098:	bl	a50c <__aeabi_dsub>
   1009c:	adds	r4, #48	; 0x30
   1009e:	ldr	r5, [sp, #36]	; 0x24
   100a0:	uxtb	r4, r4
   100a2:	mov	r6, r0
   100a4:	mov	r7, r1
   100a6:	strb	r4, [r5, #0]
   100a8:	mov	r2, r0
   100aa:	mov	r3, r1
   100ac:	mov	r0, sl
   100ae:	mov	r1, fp
   100b0:	adds	r5, #1
   100b2:	bl	ad94 <__aeabi_dcmpgt>
   100b6:	cmp	r0, #0
   100b8:	bne.n	1015c <_dtoa_r+0x804>
   100ba:	mov	r2, r6
   100bc:	mov	r3, r7
   100be:	movs	r0, #0
   100c0:	ldr	r1, [pc, #316]	; (10200 <_dtoa_r+0x8a8>)
   100c2:	bl	a50c <__aeabi_dsub>
   100c6:	mov	r2, r0
   100c8:	mov	r3, r1
   100ca:	mov	r0, sl
   100cc:	mov	r1, fp
   100ce:	bl	ad94 <__aeabi_dcmpgt>
   100d2:	cmp	r0, #0
   100d4:	bne.w	106e8 <_dtoa_r+0xd90>
   100d8:	ldr	r2, [sp, #72]	; 0x48
   100da:	cmp	r2, #1
   100dc:	ble.w	104ce <_dtoa_r+0xb76>
   100e0:	ldr	r3, [sp, #72]	; 0x48
   100e2:	ldr	r2, [sp, #36]	; 0x24
   100e4:	str.w	r8, [sp, #72]	; 0x48
   100e8:	add	r3, r2
   100ea:	mov	r8, r3
   100ec:	b.n	1010a <_dtoa_r+0x7b2>
   100ee:	movs	r0, #0
   100f0:	ldr	r1, [pc, #268]	; (10200 <_dtoa_r+0x8a8>)
   100f2:	bl	a50c <__aeabi_dsub>
   100f6:	mov	r2, sl
   100f8:	mov	r3, fp
   100fa:	bl	ad58 <__aeabi_dcmplt>
   100fe:	cmp	r0, #0
   10100:	bne.w	106e8 <_dtoa_r+0xd90>
   10104:	cmp	r5, r8
   10106:	beq.w	104ca <_dtoa_r+0xb72>
   1010a:	mov	r0, sl
   1010c:	mov	r1, fp
   1010e:	movs	r2, #0
   10110:	ldr	r3, [pc, #248]	; (1020c <_dtoa_r+0x8b4>)
   10112:	bl	a874 <__aeabi_dmul>
   10116:	movs	r2, #0
   10118:	ldr	r3, [pc, #240]	; (1020c <_dtoa_r+0x8b4>)
   1011a:	mov	sl, r0
   1011c:	mov	fp, r1
   1011e:	mov	r0, r6
   10120:	mov	r1, r7
   10122:	bl	a874 <__aeabi_dmul>
   10126:	mov	r7, r1
   10128:	mov	r6, r0
   1012a:	bl	add4 <__aeabi_d2iz>
   1012e:	mov	r4, r0
   10130:	bl	a7a8 <__aeabi_i2d>
   10134:	mov	r2, r0
   10136:	mov	r3, r1
   10138:	mov	r0, r6
   1013a:	mov	r1, r7
   1013c:	bl	a50c <__aeabi_dsub>
   10140:	adds	r4, #48	; 0x30
   10142:	uxtb	r4, r4
   10144:	mov	r2, sl
   10146:	mov	r3, fp
   10148:	strb.w	r4, [r5], #1
   1014c:	mov	r6, r0
   1014e:	mov	r7, r1
   10150:	bl	ad58 <__aeabi_dcmplt>
   10154:	mov	r2, r6
   10156:	mov	r3, r7
   10158:	cmp	r0, #0
   1015a:	beq.n	100ee <_dtoa_r+0x796>
   1015c:	ldr	r3, [sp, #88]	; 0x58
   1015e:	str	r3, [sp, #16]
   10160:	b.n	fcee <_dtoa_r+0x396>
   10162:	movs	r3, #0
   10164:	str	r3, [sp, #44]	; 0x2c
   10166:	ldr	r3, [sp, #20]
   10168:	cmp	r3, #0
   1016a:	ble.w	1046e <_dtoa_r+0xb16>
   1016e:	mov	r5, r3
   10170:	mov	r4, r3
   10172:	str	r3, [sp, #56]	; 0x38
   10174:	str	r3, [sp, #32]
   10176:	b.n	ff6e <_dtoa_r+0x616>
   10178:	movs	r3, #1
   1017a:	str	r3, [sp, #44]	; 0x2c
   1017c:	b.n	10166 <_dtoa_r+0x80e>
   1017e:	str	r4, [sp, #40]	; 0x28
   10180:	ldr	r2, [sp, #24]
   10182:	ldr	r1, [sp, #40]	; 0x28
   10184:	mov	r0, r9
   10186:	bl	11578 <__pow5mult>
   1018a:	mov	r4, r0
   1018c:	b.n	fdac <_dtoa_r+0x454>
   1018e:	ldr	r3, [sp, #32]
   10190:	cmp	r3, #0
   10192:	bgt.w	fb92 <_dtoa_r+0x23a>
   10196:	bne.w	10438 <_dtoa_r+0xae0>
   1019a:	movs	r2, #0
   1019c:	ldr	r3, [pc, #112]	; (10210 <_dtoa_r+0x8b8>)
   1019e:	ldrd	r0, r1, [sp]
   101a2:	bl	a874 <__aeabi_dmul>
   101a6:	mov	r3, fp
   101a8:	mov	r2, sl
   101aa:	bl	ad80 <__aeabi_dcmpge>
   101ae:	ldr	r3, [sp, #32]
   101b0:	str	r3, [sp, #24]
   101b2:	mov	r6, r3
   101b4:	cmp	r0, #0
   101b6:	beq.w	1038e <_dtoa_r+0xa36>
   101ba:	ldr	r3, [sp, #20]
   101bc:	ldr	r5, [sp, #36]	; 0x24
   101be:	mvns	r3, r3
   101c0:	str	r3, [sp, #16]
   101c2:	ldr	r1, [sp, #24]
   101c4:	mov	r0, r9
   101c6:	bl	1126c <_Bfree>
   101ca:	cmp	r6, #0
   101cc:	beq.w	fcee <_dtoa_r+0x396>
   101d0:	b.n	fee6 <_dtoa_r+0x58e>
   101d2:	ldr	r2, [sp, #60]	; 0x3c
   101d4:	cmp	r2, #0
   101d6:	beq.w	1064a <_dtoa_r+0xcf2>
   101da:	addw	r3, r3, #1075	; 0x433
   101de:	ldr	r7, [sp, #24]
   101e0:	ldr	r5, [sp, #28]
   101e2:	b.n	fd3e <_dtoa_r+0x3e6>
   101e4:	movs	r0, #28
   101e6:	b.n	fdfe <_dtoa_r+0x4a6>
   101e8:	ldr	r3, [sp, #0]
   101ea:	cmp	r3, #1
   101ec:	ble.w	106f0 <_dtoa_r+0xd98>
   101f0:	ldr	r7, [sp, #48]	; 0x30
   101f2:	movs	r0, #1
   101f4:	b.n	fde6 <_dtoa_r+0x48e>
   101f6:	nop
   101f8:	.word	0x000133f0
   101fc:	.word	0x000134b8
   10200:	.word	0x3ff00000
   10204:	.word	0x401c0000
   10208:	.word	0x3fe00000
   1020c:	.word	0x40240000
   10210:	.word	0x40140000
   10214:	mov	r1, r6
   10216:	movs	r3, #0
   10218:	movs	r2, #10
   1021a:	mov	r0, r9
   1021c:	bl	11280 <__multadd>
   10220:	ldr	r3, [sp, #56]	; 0x38
   10222:	cmp	r3, #0
   10224:	mov	r6, r0
   10226:	ble.w	10744 <_dtoa_r+0xdec>
   1022a:	str	r3, [sp, #32]
   1022c:	cmp	r5, #0
   1022e:	ble.n	1023c <_dtoa_r+0x8e4>
   10230:	mov	r1, r6
   10232:	mov	r2, r5
   10234:	mov	r0, r9
   10236:	bl	11618 <__lshift>
   1023a:	mov	r6, r0
   1023c:	cmp	r7, #0
   1023e:	bne.w	1053a <_dtoa_r+0xbe2>
   10242:	mov	r8, r6
   10244:	ldr	r3, [sp, #32]
   10246:	ldr	r2, [sp, #36]	; 0x24
   10248:	subs	r3, #1
   1024a:	adds	r3, r2, r3
   1024c:	str	r3, [sp, #32]
   1024e:	and.w	r3, sl, #1
   10252:	str	r3, [sp, #40]	; 0x28
   10254:	mov	r7, r2
   10256:	ldr.w	fp, [sp, #24]
   1025a:	mov	r0, r4
   1025c:	mov	r1, fp
   1025e:	bl	f82c <quorem>
   10262:	mov	r1, r6
   10264:	mov	r5, r0
   10266:	mov	r0, r4
   10268:	bl	116c8 <__mcmp>
   1026c:	mov	r2, r8
   1026e:	mov	r1, fp
   10270:	mov	sl, r0
   10272:	mov	r0, r9
   10274:	bl	1170c <__mdiff>
   10278:	ldr	r2, [r0, #12]
   1027a:	mov	fp, r0
   1027c:	add.w	r3, r5, #48	; 0x30
   10280:	cmp	r2, #0
   10282:	bne.n	10318 <_dtoa_r+0x9c0>
   10284:	mov	r1, r0
   10286:	mov	r0, r4
   10288:	str	r3, [sp, #28]
   1028a:	bl	116c8 <__mcmp>
   1028e:	mov	r1, fp
   10290:	str	r0, [sp, #20]
   10292:	mov	r0, r9
   10294:	bl	1126c <_Bfree>
   10298:	ldr	r2, [sp, #20]
   1029a:	ldr	r3, [sp, #28]
   1029c:	cbnz	r2, 102aa <_dtoa_r+0x952>
   1029e:	ldr	r1, [sp, #0]
   102a0:	cbnz	r1, 102aa <_dtoa_r+0x952>
   102a2:	ldr	r1, [sp, #40]	; 0x28
   102a4:	cmp	r1, #0
   102a6:	beq.w	10714 <_dtoa_r+0xdbc>
   102aa:	cmp.w	sl, #0
   102ae:	blt.w	10478 <_dtoa_r+0xb20>
   102b2:	bne.n	102c0 <_dtoa_r+0x968>
   102b4:	ldr	r1, [sp, #0]
   102b6:	cbnz	r1, 102c0 <_dtoa_r+0x968>
   102b8:	ldr	r1, [sp, #40]	; 0x28
   102ba:	cmp	r1, #0
   102bc:	beq.w	10478 <_dtoa_r+0xb20>
   102c0:	cmp	r2, #0
   102c2:	bgt.w	10562 <_dtoa_r+0xc0a>
   102c6:	ldr	r2, [sp, #32]
   102c8:	strb	r3, [r7, #0]
   102ca:	add.w	sl, r7, #1
   102ce:	cmp	r7, r2
   102d0:	mov	r5, sl
   102d2:	beq.w	1057a <_dtoa_r+0xc22>
   102d6:	mov	r1, r4
   102d8:	movs	r3, #0
   102da:	movs	r2, #10
   102dc:	mov	r0, r9
   102de:	bl	11280 <__multadd>
   102e2:	cmp	r6, r8
   102e4:	mov	r4, r0
   102e6:	mov	r1, r6
   102e8:	mov.w	r3, #0
   102ec:	mov.w	r2, #10
   102f0:	mov	r0, r9
   102f2:	beq.n	1030c <_dtoa_r+0x9b4>
   102f4:	bl	11280 <__multadd>
   102f8:	mov	r1, r8
   102fa:	mov	r6, r0
   102fc:	movs	r3, #0
   102fe:	movs	r2, #10
   10300:	mov	r0, r9
   10302:	bl	11280 <__multadd>
   10306:	mov	r7, sl
   10308:	mov	r8, r0
   1030a:	b.n	10256 <_dtoa_r+0x8fe>
   1030c:	bl	11280 <__multadd>
   10310:	mov	r7, sl
   10312:	mov	r6, r0
   10314:	mov	r8, r0
   10316:	b.n	10256 <_dtoa_r+0x8fe>
   10318:	mov	r1, r0
   1031a:	mov	r0, r9
   1031c:	str	r3, [sp, #20]
   1031e:	bl	1126c <_Bfree>
   10322:	movs	r2, #1
   10324:	ldr	r3, [sp, #20]
   10326:	b.n	102aa <_dtoa_r+0x952>
   10328:	ldr	r1, [sp, #24]
   1032a:	mov	r0, r4
   1032c:	bl	116c8 <__mcmp>
   10330:	cmp	r0, #0
   10332:	bge.w	fe34 <_dtoa_r+0x4dc>
   10336:	mov	r1, r4
   10338:	ldr	r4, [sp, #16]
   1033a:	movs	r3, #0
   1033c:	subs	r4, #1
   1033e:	movs	r2, #10
   10340:	mov	r0, r9
   10342:	str	r4, [sp, #16]
   10344:	bl	11280 <__multadd>
   10348:	ldr	r3, [sp, #44]	; 0x2c
   1034a:	mov	r4, r0
   1034c:	cmp	r3, #0
   1034e:	bne.w	10214 <_dtoa_r+0x8bc>
   10352:	ldr	r3, [sp, #56]	; 0x38
   10354:	cmp	r3, #0
   10356:	ble.w	10734 <_dtoa_r+0xddc>
   1035a:	str	r3, [sp, #32]
   1035c:	b.n	fe44 <_dtoa_r+0x4ec>
   1035e:	ldr	r4, [sp, #40]	; 0x28
   10360:	b.n	fdac <_dtoa_r+0x454>
   10362:	ldr	r3, [sp, #0]
   10364:	cmp	r3, #2
   10366:	ble.w	fe3c <_dtoa_r+0x4e4>
   1036a:	ldr	r3, [sp, #32]
   1036c:	cmp	r3, #0
   1036e:	bne.w	106ac <_dtoa_r+0xd54>
   10372:	ldr	r1, [sp, #24]
   10374:	movs	r2, #5
   10376:	mov	r0, r9
   10378:	bl	11280 <__multadd>
   1037c:	mov	r1, r0
   1037e:	str	r0, [sp, #24]
   10380:	mov	r0, r4
   10382:	bl	116c8 <__mcmp>
   10386:	cmp	r0, #0
   10388:	str	r4, [sp, #40]	; 0x28
   1038a:	ble.w	101ba <_dtoa_r+0x862>
   1038e:	ldr	r2, [sp, #16]
   10390:	ldr	r1, [sp, #36]	; 0x24
   10392:	movs	r3, #49	; 0x31
   10394:	adds	r2, #1
   10396:	str	r2, [sp, #16]
   10398:	strb	r3, [r1, #0]
   1039a:	adds	r5, r1, #1
   1039c:	b.n	101c2 <_dtoa_r+0x86a>
   1039e:	ldr	r2, [sp, #16]
   103a0:	adds	r2, #1
   103a2:	str	r2, [sp, #16]
   103a4:	ldr	r2, [sp, #36]	; 0x24
   103a6:	movs	r3, #49	; 0x31
   103a8:	strb	r3, [r2, #0]
   103aa:	b.n	fec6 <_dtoa_r+0x56e>
   103ac:	movs	r3, #1
   103ae:	str	r3, [sp, #44]	; 0x2c
   103b0:	b.n	ff58 <_dtoa_r+0x600>
   103b2:	ldr.w	r9, [sp, #20]
   103b6:	b.n	fcee <_dtoa_r+0x396>
   103b8:	cmp.w	sl, #0
   103bc:	bne.w	fdd2 <_dtoa_r+0x47a>
   103c0:	ubfx	r3, fp, #0, #20
   103c4:	cmp	r3, #0
   103c6:	bne.w	10646 <_dtoa_r+0xcee>
   103ca:	bic.w	r7, fp, #2147483648	; 0x80000000
   103ce:	lsrs	r7, r7, #20
   103d0:	lsls	r7, r7, #20
   103d2:	cbz	r7, 103e0 <_dtoa_r+0xa88>
   103d4:	ldr	r3, [sp, #28]
   103d6:	adds	r3, #1
   103d8:	str	r3, [sp, #28]
   103da:	add.w	r8, r8, #1
   103de:	movs	r7, #1
   103e0:	ldr	r3, [sp, #48]	; 0x30
   103e2:	movs	r0, #1
   103e4:	cmp	r3, #0
   103e6:	beq.w	fde6 <_dtoa_r+0x48e>
   103ea:	b.n	fdd4 <_dtoa_r+0x47c>
   103ec:	mov	r0, sl
   103ee:	bl	a7a8 <__aeabi_i2d>
   103f2:	mov	r2, r6
   103f4:	mov	r3, r7
   103f6:	bl	a874 <__aeabi_dmul>
   103fa:	movs	r2, #0
   103fc:	ldr	r3, [pc, #764]	; (106fc <_dtoa_r+0xda4>)
   103fe:	bl	a510 <__adddf3>
   10402:	mov	r4, r0
   10404:	sub.w	r5, r1, #54525952	; 0x3400000
   10408:	mov	r0, r6
   1040a:	mov	r1, r7
   1040c:	movs	r2, #0
   1040e:	ldr	r3, [pc, #752]	; (10700 <_dtoa_r+0xda8>)
   10410:	bl	a50c <__aeabi_dsub>
   10414:	mov	r2, r4
   10416:	mov	r3, r5
   10418:	mov	r6, r0
   1041a:	mov	r7, r1
   1041c:	bl	ad94 <__aeabi_dcmpgt>
   10420:	cmp	r0, #0
   10422:	bne.w	10582 <_dtoa_r+0xc2a>
   10426:	mov	r2, r4
   10428:	add.w	r3, r5, #2147483648	; 0x80000000
   1042c:	mov	r0, r6
   1042e:	mov	r1, r7
   10430:	bl	ad58 <__aeabi_dcmplt>
   10434:	cmp	r0, #0
   10436:	beq.n	104ce <_dtoa_r+0xb76>
   10438:	movs	r3, #0
   1043a:	str	r3, [sp, #24]
   1043c:	mov	r6, r3
   1043e:	b.n	101ba <_dtoa_r+0x862>
   10440:	ldr	r0, [sp, #36]	; 0x24
   10442:	b.w	f9ca <_dtoa_r+0x72>
   10446:	ldr	r3, [sp, #24]
   10448:	ldr	r2, [sp, #48]	; 0x30
   1044a:	str	r7, [sp, #24]
   1044c:	subs	r3, r7, r3
   1044e:	add	r2, r3
   10450:	str	r2, [sp, #48]	; 0x30
   10452:	movs	r7, #0
   10454:	b.n	fd32 <_dtoa_r+0x3da>
   10456:	vldr	d7, [sp, #64]	; 0x40
   1045a:	mov.w	sl, #2
   1045e:	vstr	d7, [sp, #72]	; 0x48
   10462:	b.n	ffe4 <_dtoa_r+0x68c>
   10464:	mov	r4, r3
   10466:	movs	r1, #0
   10468:	str.w	r1, [r9, #68]	; 0x44
   1046c:	b.n	ff90 <_dtoa_r+0x638>
   1046e:	movs	r4, #1
   10470:	str	r4, [sp, #56]	; 0x38
   10472:	str	r4, [sp, #32]
   10474:	str	r4, [sp, #20]
   10476:	b.n	10466 <_dtoa_r+0xb0e>
   10478:	cmp	r2, #0
   1047a:	mov	sl, r3
   1047c:	ble.n	104a2 <_dtoa_r+0xb4a>
   1047e:	mov	r1, r4
   10480:	movs	r2, #1
   10482:	mov	r0, r9
   10484:	bl	11618 <__lshift>
   10488:	ldr	r1, [sp, #24]
   1048a:	mov	r4, r0
   1048c:	bl	116c8 <__mcmp>
   10490:	cmp	r0, #0
   10492:	ble.w	10726 <_dtoa_r+0xdce>
   10496:	cmp.w	sl, #57	; 0x39
   1049a:	beq.w	106b0 <_dtoa_r+0xd58>
   1049e:	add.w	sl, r5, #49	; 0x31
   104a2:	mov	fp, r6
   104a4:	strb.w	sl, [r7]
   104a8:	adds	r5, r7, #1
   104aa:	mov	r6, r8
   104ac:	str	r4, [sp, #40]	; 0x28
   104ae:	b.n	fec6 <_dtoa_r+0x56e>
   104b0:	bne.n	104bc <_dtoa_r+0xb64>
   104b2:	tst.w	sl, #1
   104b6:	beq.n	104bc <_dtoa_r+0xb64>
   104b8:	b.n	fea6 <_dtoa_r+0x54e>
   104ba:	mov	r5, r2
   104bc:	ldrb.w	r3, [r5, #-1]
   104c0:	cmp	r3, #48	; 0x30
   104c2:	add.w	r2, r5, #4294967295
   104c6:	beq.n	104ba <_dtoa_r+0xb62>
   104c8:	b.n	fec6 <_dtoa_r+0x56e>
   104ca:	ldr.w	r8, [sp, #72]	; 0x48
   104ce:	ldrd	sl, fp, [sp, #64]	; 0x40
   104d2:	b.w	fb6c <_dtoa_r+0x214>
   104d6:	ldr	r1, [sp, #36]	; 0x24
   104d8:	movs	r2, #48	; 0x30
   104da:	strb	r2, [r1, #0]
   104dc:	ldr	r2, [sp, #16]
   104de:	ldrb.w	r4, [r5, #-1]
   104e2:	adds	r2, #1
   104e4:	str	r2, [sp, #16]
   104e6:	b.n	fcea <_dtoa_r+0x392>
   104e8:	ldr	r3, [sp, #16]
   104ea:	negs	r4, r3
   104ec:	cmp	r4, #0
   104ee:	beq.w	10658 <_dtoa_r+0xd00>
   104f2:	ldr	r3, [pc, #528]	; (10704 <_dtoa_r+0xdac>)
   104f4:	and.w	r2, r4, #15
   104f8:	add.w	r3, r3, r2, lsl #3
   104fc:	ldrd	r2, r3, [r3]
   10500:	ldrd	r0, r1, [sp, #64]	; 0x40
   10504:	bl	a874 <__aeabi_dmul>
   10508:	asrs	r4, r4, #4
   1050a:	mov	r6, r0
   1050c:	mov	r7, r1
   1050e:	beq.w	1073e <_dtoa_r+0xde6>
   10512:	ldr	r5, [pc, #500]	; (10708 <_dtoa_r+0xdb0>)
   10514:	mov.w	sl, #2
   10518:	lsls	r2, r4, #31
   1051a:	bpl.n	10530 <_dtoa_r+0xbd8>
   1051c:	mov	r0, r6
   1051e:	mov	r1, r7
   10520:	ldrd	r2, r3, [r5]
   10524:	bl	a874 <__aeabi_dmul>
   10528:	add.w	sl, sl, #1
   1052c:	mov	r6, r0
   1052e:	mov	r7, r1
   10530:	asrs	r4, r4, #1
   10532:	add.w	r5, r5, #8
   10536:	bne.n	10518 <_dtoa_r+0xbc0>
   10538:	b.n	10018 <_dtoa_r+0x6c0>
   1053a:	ldr	r1, [r6, #4]
   1053c:	mov	r0, r9
   1053e:	bl	11220 <_Balloc>
   10542:	ldr	r3, [r6, #16]
   10544:	adds	r2, r3, #2
   10546:	mov	r5, r0
   10548:	lsls	r2, r2, #2
   1054a:	add.w	r1, r6, #12
   1054e:	adds	r0, #12
   10550:	bl	8ed0 <memcpy>
   10554:	mov	r1, r5
   10556:	movs	r2, #1
   10558:	mov	r0, r9
   1055a:	bl	11618 <__lshift>
   1055e:	mov	r8, r0
   10560:	b.n	10244 <_dtoa_r+0x8ec>
   10562:	cmp	r3, #57	; 0x39
   10564:	beq.w	106b0 <_dtoa_r+0xd58>
   10568:	add.w	sl, r3, #1
   1056c:	mov	fp, r6
   1056e:	strb.w	sl, [r7]
   10572:	adds	r5, r7, #1
   10574:	mov	r6, r8
   10576:	str	r4, [sp, #40]	; 0x28
   10578:	b.n	fec6 <_dtoa_r+0x56e>
   1057a:	mov	fp, r6
   1057c:	mov	sl, r3
   1057e:	mov	r6, r8
   10580:	b.n	fe8e <_dtoa_r+0x536>
   10582:	movs	r3, #0
   10584:	str	r3, [sp, #24]
   10586:	mov	r6, r3
   10588:	b.n	1038e <_dtoa_r+0xa36>
   1058a:	ldr	r3, [sp, #72]	; 0x48
   1058c:	ldr	r1, [pc, #372]	; (10704 <_dtoa_r+0xdac>)
   1058e:	subs	r2, r3, #1
   10590:	add.w	r1, r1, r2, lsl #3
   10594:	mov	r3, r5
   10596:	str	r2, [sp, #92]	; 0x5c
   10598:	ldrd	r0, r1, [r1]
   1059c:	mov	r2, r4
   1059e:	bl	a874 <__aeabi_dmul>
   105a2:	strd	r0, r1, [sp, #80]	; 0x50
   105a6:	mov	r1, r7
   105a8:	mov	r0, r6
   105aa:	bl	add4 <__aeabi_d2iz>
   105ae:	mov	r4, r0
   105b0:	bl	a7a8 <__aeabi_i2d>
   105b4:	mov	r3, r1
   105b6:	mov	r2, r0
   105b8:	mov	r1, r7
   105ba:	mov	r0, r6
   105bc:	bl	a50c <__aeabi_dsub>
   105c0:	ldr	r3, [sp, #72]	; 0x48
   105c2:	mov	r7, r1
   105c4:	ldr	r1, [sp, #36]	; 0x24
   105c6:	adds	r4, #48	; 0x30
   105c8:	cmp	r3, #1
   105ca:	mov	r6, r0
   105cc:	strb	r4, [r1, #0]
   105ce:	add.w	r5, r1, #1
   105d2:	beq.n	10616 <_dtoa_r+0xcbe>
   105d4:	ldr	r3, [sp, #72]	; 0x48
   105d6:	ldr	r2, [sp, #36]	; 0x24
   105d8:	add	r3, r2
   105da:	mov	sl, r3
   105dc:	mov	fp, r5
   105de:	movs	r2, #0
   105e0:	ldr	r3, [pc, #296]	; (1070c <_dtoa_r+0xdb4>)
   105e2:	mov	r0, r6
   105e4:	mov	r1, r7
   105e6:	bl	a874 <__aeabi_dmul>
   105ea:	mov	r7, r1
   105ec:	mov	r6, r0
   105ee:	bl	add4 <__aeabi_d2iz>
   105f2:	mov	r4, r0
   105f4:	bl	a7a8 <__aeabi_i2d>
   105f8:	adds	r4, #48	; 0x30
   105fa:	mov	r2, r0
   105fc:	mov	r3, r1
   105fe:	mov	r0, r6
   10600:	mov	r1, r7
   10602:	bl	a50c <__aeabi_dsub>
   10606:	strb.w	r4, [fp], #1
   1060a:	cmp	sl, fp
   1060c:	mov	r6, r0
   1060e:	mov	r7, r1
   10610:	bne.n	105de <_dtoa_r+0xc86>
   10612:	ldr	r3, [sp, #92]	; 0x5c
   10614:	add	r5, r3
   10616:	movs	r2, #0
   10618:	ldr	r3, [pc, #244]	; (10710 <_dtoa_r+0xdb8>)
   1061a:	ldrd	r0, r1, [sp, #80]	; 0x50
   1061e:	bl	a510 <__adddf3>
   10622:	mov	r2, r6
   10624:	mov	r3, r7
   10626:	bl	ad58 <__aeabi_dcmplt>
   1062a:	cmp	r0, #0
   1062c:	beq.n	106c0 <_dtoa_r+0xd68>
   1062e:	ldr	r3, [sp, #88]	; 0x58
   10630:	str	r3, [sp, #16]
   10632:	ldrb.w	r4, [r5, #-1]
   10636:	b.w	fcd2 <_dtoa_r+0x37a>
   1063a:	ldr	r3, [sp, #28]
   1063c:	ldr	r2, [sp, #32]
   1063e:	subs	r5, r3, r2
   10640:	movs	r3, #0
   10642:	b.w	fd3e <_dtoa_r+0x3e6>
   10646:	movs	r7, #0
   10648:	b.n	103e0 <_dtoa_r+0xa88>
   1064a:	ldr	r3, [sp, #96]	; 0x60
   1064c:	ldr	r7, [sp, #24]
   1064e:	ldr	r5, [sp, #28]
   10650:	rsb	r3, r3, #54	; 0x36
   10654:	b.w	fd3e <_dtoa_r+0x3e6>
   10658:	ldrd	r6, r7, [sp, #64]	; 0x40
   1065c:	mov.w	sl, #2
   10660:	b.n	10018 <_dtoa_r+0x6c0>
   10662:	ldr	r3, [sp, #32]
   10664:	cmp	r3, #0
   10666:	beq.w	103ec <_dtoa_r+0xa94>
   1066a:	ldr	r3, [sp, #56]	; 0x38
   1066c:	cmp	r3, #0
   1066e:	ble.w	104ce <_dtoa_r+0xb76>
   10672:	movs	r2, #0
   10674:	ldr	r3, [pc, #148]	; (1070c <_dtoa_r+0xdb4>)
   10676:	mov	r0, r6
   10678:	mov	r1, r7
   1067a:	bl	a874 <__aeabi_dmul>
   1067e:	mov	r6, r0
   10680:	mov	r7, r1
   10682:	add.w	r0, sl, #1
   10686:	bl	a7a8 <__aeabi_i2d>
   1068a:	mov	r2, r6
   1068c:	mov	r3, r7
   1068e:	bl	a874 <__aeabi_dmul>
   10692:	movs	r2, #0
   10694:	ldr	r3, [pc, #100]	; (106fc <_dtoa_r+0xda4>)
   10696:	bl	a510 <__adddf3>
   1069a:	ldr	r2, [sp, #16]
   1069c:	ldr	r3, [sp, #56]	; 0x38
   1069e:	str	r3, [sp, #72]	; 0x48
   106a0:	subs	r2, #1
   106a2:	mov	r4, r0
   106a4:	sub.w	r5, r1, #54525952	; 0x3400000
   106a8:	str	r2, [sp, #88]	; 0x58
   106aa:	b.n	1005a <_dtoa_r+0x702>
   106ac:	str	r4, [sp, #40]	; 0x28
   106ae:	b.n	101ba <_dtoa_r+0x862>
   106b0:	movs	r2, #57	; 0x39
   106b2:	mov	fp, r6
   106b4:	str	r4, [sp, #40]	; 0x28
   106b6:	mov	r6, r8
   106b8:	strb	r2, [r7, #0]
   106ba:	adds	r5, r7, #1
   106bc:	b.w	feaa <_dtoa_r+0x552>
   106c0:	ldrd	r2, r3, [sp, #80]	; 0x50
   106c4:	movs	r0, #0
   106c6:	ldr	r1, [pc, #72]	; (10710 <_dtoa_r+0xdb8>)
   106c8:	bl	a50c <__aeabi_dsub>
   106cc:	mov	r2, r6
   106ce:	mov	r3, r7
   106d0:	bl	ad94 <__aeabi_dcmpgt>
   106d4:	cbnz	r0, 106da <_dtoa_r+0xd82>
   106d6:	b.n	104ce <_dtoa_r+0xb76>
   106d8:	mov	r5, r2
   106da:	ldrb.w	r3, [r5, #-1]
   106de:	cmp	r3, #48	; 0x30
   106e0:	add.w	r2, r5, #4294967295
   106e4:	beq.n	106d8 <_dtoa_r+0xd80>
   106e6:	b.n	1015c <_dtoa_r+0x804>
   106e8:	ldr	r3, [sp, #88]	; 0x58
   106ea:	str	r3, [sp, #16]
   106ec:	b.w	fcd2 <_dtoa_r+0x37a>
   106f0:	cmp.w	sl, #0
   106f4:	bne.w	101f0 <_dtoa_r+0x898>
   106f8:	b.n	103c0 <_dtoa_r+0xa68>
   106fa:	nop
   106fc:	.word	0x401c0000
   10700:	.word	0x40140000
   10704:	.word	0x000133f0
   10708:	.word	0x000134b8
   1070c:	.word	0x40240000
   10710:	.word	0x3fe00000
   10714:	cmp	r3, #57	; 0x39
   10716:	mov	fp, sl
   10718:	mov	sl, r3
   1071a:	beq.n	106b0 <_dtoa_r+0xd58>
   1071c:	cmp.w	fp, #0
   10720:	bgt.w	1049e <_dtoa_r+0xb46>
   10724:	b.n	104a2 <_dtoa_r+0xb4a>
   10726:	bne.w	104a2 <_dtoa_r+0xb4a>
   1072a:	tst.w	sl, #1
   1072e:	beq.w	104a2 <_dtoa_r+0xb4a>
   10732:	b.n	10496 <_dtoa_r+0xb3e>
   10734:	ldr	r3, [sp, #0]
   10736:	cmp	r3, #2
   10738:	bgt.n	10786 <_dtoa_r+0xe2e>
   1073a:	ldr	r3, [sp, #56]	; 0x38
   1073c:	b.n	1035a <_dtoa_r+0xa02>
   1073e:	mov.w	sl, #2
   10742:	b.n	10018 <_dtoa_r+0x6c0>
   10744:	ldr	r3, [sp, #0]
   10746:	cmp	r3, #2
   10748:	bgt.n	10786 <_dtoa_r+0xe2e>
   1074a:	ldr	r3, [sp, #56]	; 0x38
   1074c:	b.n	1022a <_dtoa_r+0x8d2>
   1074e:	movs	r4, #0
   10750:	str.w	r4, [r9, #68]	; 0x44
   10754:	mov	r1, r4
   10756:	mov	r0, r9
   10758:	bl	11220 <_Balloc>
   1075c:	mov.w	r3, #4294967295
   10760:	str	r3, [sp, #32]
   10762:	str	r3, [sp, #56]	; 0x38
   10764:	movs	r3, #1
   10766:	str	r0, [sp, #36]	; 0x24
   10768:	str	r4, [sp, #20]
   1076a:	str.w	r0, [r9, #64]	; 0x40
   1076e:	str	r3, [sp, #44]	; 0x2c
   10770:	b.w	fb6c <_dtoa_r+0x214>
   10774:	beq.w	fe08 <_dtoa_r+0x4b0>
   10778:	rsb	r0, r0, #60	; 0x3c
   1077c:	b.w	fdfe <_dtoa_r+0x4a6>
   10780:	movs	r6, #1
   10782:	b.w	fafe <_dtoa_r+0x1a6>
   10786:	ldr	r3, [sp, #56]	; 0x38
   10788:	str	r3, [sp, #32]
   1078a:	b.n	1036a <_dtoa_r+0xa12>

0001078c <__libc_fini_array>:
   1078c:	push	{r3, r4, r5, lr}
   1078e:	ldr	r5, [pc, #28]	; (107ac <__libc_fini_array+0x20>)
   10790:	ldr	r4, [pc, #28]	; (107b0 <__libc_fini_array+0x24>)
   10792:	subs	r4, r5, r4
   10794:	asrs	r4, r4, #2
   10796:	beq.n	107a4 <__libc_fini_array+0x18>
   10798:	subs	r4, #1
   1079a:	ldr.w	r3, [r5, #-4]!
   1079e:	blx	r3
   107a0:	cmp	r4, #0
   107a2:	bne.n	10798 <__libc_fini_array+0xc>
   107a4:	ldmia.w	sp!, {r3, r4, r5, lr}
   107a8:	b.w	13510 <__init_array_end>
	...

000107b4 <_malloc_trim_r>:
   107b4:	push	{r3, r4, r5, r6, r7, lr}
   107b6:	ldr	r7, [pc, #140]	; (10844 <_malloc_trim_r+0x90>)
   107b8:	mov	r4, r1
   107ba:	mov	r6, r0
   107bc:	bl	ba5c <__malloc_lock>
   107c0:	ldr	r3, [r7, #8]
   107c2:	ldr	r5, [r3, #4]
   107c4:	bic.w	r5, r5, #3
   107c8:	subs	r1, r5, r4
   107ca:	addw	r1, r1, #4079	; 0xfef
   107ce:	bic.w	r1, r1, #4080	; 0xff0
   107d2:	bic.w	r1, r1, #15
   107d6:	sub.w	r4, r1, #4096	; 0x1000
   107da:	cmp.w	r4, #4096	; 0x1000
   107de:	blt.n	107f0 <_malloc_trim_r+0x3c>
   107e0:	movs	r1, #0
   107e2:	mov	r0, r6
   107e4:	bl	be44 <_sbrk_r>
   107e8:	ldr	r3, [r7, #8]
   107ea:	add	r3, r5
   107ec:	cmp	r0, r3
   107ee:	beq.n	107fa <_malloc_trim_r+0x46>
   107f0:	mov	r0, r6
   107f2:	bl	ba60 <__malloc_unlock>
   107f6:	movs	r0, #0
   107f8:	pop	{r3, r4, r5, r6, r7, pc}
   107fa:	negs	r1, r4
   107fc:	mov	r0, r6
   107fe:	bl	be44 <_sbrk_r>
   10802:	adds	r0, #1
   10804:	beq.n	10822 <_malloc_trim_r+0x6e>
   10806:	ldr	r3, [pc, #64]	; (10848 <_malloc_trim_r+0x94>)
   10808:	ldr	r2, [r7, #8]
   1080a:	ldr	r1, [r3, #0]
   1080c:	subs	r5, r5, r4
   1080e:	orr.w	r5, r5, #1
   10812:	mov	r0, r6
   10814:	subs	r1, r1, r4
   10816:	str	r5, [r2, #4]
   10818:	str	r1, [r3, #0]
   1081a:	bl	ba60 <__malloc_unlock>
   1081e:	movs	r0, #1
   10820:	pop	{r3, r4, r5, r6, r7, pc}
   10822:	movs	r1, #0
   10824:	mov	r0, r6
   10826:	bl	be44 <_sbrk_r>
   1082a:	ldr	r2, [r7, #8]
   1082c:	subs	r3, r0, r2
   1082e:	cmp	r3, #15
   10830:	ble.n	107f0 <_malloc_trim_r+0x3c>
   10832:	ldr	r4, [pc, #24]	; (1084c <_malloc_trim_r+0x98>)
   10834:	ldr	r1, [pc, #16]	; (10848 <_malloc_trim_r+0x94>)
   10836:	ldr	r4, [r4, #0]
   10838:	orr.w	r3, r3, #1
   1083c:	subs	r0, r0, r4
   1083e:	str	r3, [r2, #4]
   10840:	str	r0, [r1, #0]
   10842:	b.n	107f0 <_malloc_trim_r+0x3c>
   10844:	.word	0x1fff19b8
   10848:	.word	0x2001d044
   1084c:	.word	0x1fff1dc4

00010850 <_free_r>:
   10850:	cmp	r1, #0
   10852:	beq.n	108e0 <_free_r+0x90>
   10854:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10858:	mov	r5, r1
   1085a:	mov	r8, r0
   1085c:	bl	ba5c <__malloc_lock>
   10860:	ldr.w	r7, [r5, #-4]
   10864:	ldr	r1, [pc, #424]	; (10a10 <_free_r+0x1c0>)
   10866:	bic.w	r3, r7, #1
   1086a:	sub.w	r4, r5, #8
   1086e:	adds	r2, r4, r3
   10870:	ldr	r6, [r1, #8]
   10872:	ldr	r0, [r2, #4]
   10874:	cmp	r2, r6
   10876:	bic.w	r0, r0, #3
   1087a:	beq.n	10942 <_free_r+0xf2>
   1087c:	lsls	r6, r7, #31
   1087e:	str	r0, [r2, #4]
   10880:	bmi.n	1089a <_free_r+0x4a>
   10882:	ldr.w	r7, [r5, #-8]
   10886:	subs	r4, r4, r7
   10888:	add.w	lr, r1, #8
   1088c:	ldr	r5, [r4, #8]
   1088e:	cmp	r5, lr
   10890:	add	r3, r7
   10892:	beq.n	10974 <_free_r+0x124>
   10894:	ldr	r7, [r4, #12]
   10896:	str	r7, [r5, #12]
   10898:	str	r5, [r7, #8]
   1089a:	adds	r5, r2, r0
   1089c:	ldr	r5, [r5, #4]
   1089e:	lsls	r5, r5, #31
   108a0:	bpl.n	10928 <_free_r+0xd8>
   108a2:	orr.w	r2, r3, #1
   108a6:	str	r2, [r4, #4]
   108a8:	str	r3, [r4, r3]
   108aa:	cmp.w	r3, #512	; 0x200
   108ae:	bcs.n	108e2 <_free_r+0x92>
   108b0:	lsrs	r3, r3, #3
   108b2:	adds	r2, r3, #1
   108b4:	ldr	r5, [r1, #4]
   108b6:	ldr.w	r7, [r1, r2, lsl #3]
   108ba:	str	r7, [r4, #8]
   108bc:	movs	r0, #1
   108be:	asrs	r3, r3, #2
   108c0:	lsl.w	r3, r0, r3
   108c4:	add.w	r0, r1, r2, lsl #3
   108c8:	orrs	r5, r3
   108ca:	subs	r0, #8
   108cc:	str	r0, [r4, #12]
   108ce:	str	r5, [r1, #4]
   108d0:	str.w	r4, [r1, r2, lsl #3]
   108d4:	str	r4, [r7, #12]
   108d6:	mov	r0, r8
   108d8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   108dc:	b.w	ba60 <__malloc_unlock>
   108e0:	bx	lr
   108e2:	lsrs	r2, r3, #9
   108e4:	cmp	r2, #4
   108e6:	bhi.n	10990 <_free_r+0x140>
   108e8:	lsrs	r2, r3, #6
   108ea:	add.w	r7, r2, #57	; 0x39
   108ee:	lsls	r7, r7, #1
   108f0:	add.w	r5, r2, #56	; 0x38
   108f4:	add.w	r0, r1, r7, lsl #2
   108f8:	ldr.w	r2, [r1, r7, lsl #2]
   108fc:	ldr	r1, [pc, #272]	; (10a10 <_free_r+0x1c0>)
   108fe:	subs	r0, #8
   10900:	cmp	r0, r2
   10902:	beq.n	109a0 <_free_r+0x150>
   10904:	ldr	r1, [r2, #4]
   10906:	bic.w	r1, r1, #3
   1090a:	cmp	r3, r1
   1090c:	bcs.n	10914 <_free_r+0xc4>
   1090e:	ldr	r2, [r2, #8]
   10910:	cmp	r0, r2
   10912:	bne.n	10904 <_free_r+0xb4>
   10914:	ldr	r0, [r2, #12]
   10916:	str	r0, [r4, #12]
   10918:	str	r2, [r4, #8]
   1091a:	str	r4, [r0, #8]
   1091c:	str	r4, [r2, #12]
   1091e:	mov	r0, r8
   10920:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   10924:	b.w	ba60 <__malloc_unlock>
   10928:	ldr	r5, [r2, #8]
   1092a:	ldr	r7, [pc, #232]	; (10a14 <_free_r+0x1c4>)
   1092c:	cmp	r5, r7
   1092e:	add	r3, r0
   10930:	beq.n	109b2 <_free_r+0x162>
   10932:	ldr	r0, [r2, #12]
   10934:	str	r0, [r5, #12]
   10936:	orr.w	r2, r3, #1
   1093a:	str	r5, [r0, #8]
   1093c:	str	r2, [r4, #4]
   1093e:	str	r3, [r4, r3]
   10940:	b.n	108aa <_free_r+0x5a>
   10942:	lsls	r7, r7, #31
   10944:	add	r3, r0
   10946:	bmi.n	10958 <_free_r+0x108>
   10948:	ldr.w	r2, [r5, #-8]
   1094c:	subs	r4, r4, r2
   1094e:	add	r3, r2
   10950:	ldr	r0, [r4, #8]
   10952:	ldr	r2, [r4, #12]
   10954:	str	r2, [r0, #12]
   10956:	str	r0, [r2, #8]
   10958:	ldr	r2, [pc, #188]	; (10a18 <_free_r+0x1c8>)
   1095a:	ldr	r2, [r2, #0]
   1095c:	orr.w	r0, r3, #1
   10960:	cmp	r3, r2
   10962:	str	r0, [r4, #4]
   10964:	str	r4, [r1, #8]
   10966:	bcc.n	108d6 <_free_r+0x86>
   10968:	ldr	r3, [pc, #176]	; (10a1c <_free_r+0x1cc>)
   1096a:	mov	r0, r8
   1096c:	ldr	r1, [r3, #0]
   1096e:	bl	107b4 <_malloc_trim_r>
   10972:	b.n	108d6 <_free_r+0x86>
   10974:	adds	r1, r2, r0
   10976:	ldr	r1, [r1, #4]
   10978:	lsls	r1, r1, #31
   1097a:	bmi.n	10a06 <_free_r+0x1b6>
   1097c:	ldr	r1, [r2, #8]
   1097e:	ldr	r2, [r2, #12]
   10980:	str	r2, [r1, #12]
   10982:	add	r3, r0
   10984:	orr.w	r0, r3, #1
   10988:	str	r1, [r2, #8]
   1098a:	str	r0, [r4, #4]
   1098c:	str	r3, [r4, r3]
   1098e:	b.n	108d6 <_free_r+0x86>
   10990:	cmp	r2, #20
   10992:	bhi.n	109c4 <_free_r+0x174>
   10994:	add.w	r7, r2, #92	; 0x5c
   10998:	lsls	r7, r7, #1
   1099a:	add.w	r5, r2, #91	; 0x5b
   1099e:	b.n	108f4 <_free_r+0xa4>
   109a0:	asrs	r2, r5, #2
   109a2:	ldr	r3, [r1, #4]
   109a4:	movs	r5, #1
   109a6:	lsl.w	r2, r5, r2
   109aa:	orrs	r3, r2
   109ac:	str	r3, [r1, #4]
   109ae:	mov	r2, r0
   109b0:	b.n	10916 <_free_r+0xc6>
   109b2:	orr.w	r2, r3, #1
   109b6:	str	r4, [r1, #20]
   109b8:	str	r4, [r1, #16]
   109ba:	str	r5, [r4, #12]
   109bc:	str	r5, [r4, #8]
   109be:	str	r2, [r4, #4]
   109c0:	str	r3, [r4, r3]
   109c2:	b.n	108d6 <_free_r+0x86>
   109c4:	cmp	r2, #84	; 0x54
   109c6:	bhi.n	109d6 <_free_r+0x186>
   109c8:	lsrs	r2, r3, #12
   109ca:	add.w	r7, r2, #111	; 0x6f
   109ce:	lsls	r7, r7, #1
   109d0:	add.w	r5, r2, #110	; 0x6e
   109d4:	b.n	108f4 <_free_r+0xa4>
   109d6:	cmp.w	r2, #340	; 0x154
   109da:	bhi.n	109ea <_free_r+0x19a>
   109dc:	lsrs	r2, r3, #15
   109de:	add.w	r7, r2, #120	; 0x78
   109e2:	lsls	r7, r7, #1
   109e4:	add.w	r5, r2, #119	; 0x77
   109e8:	b.n	108f4 <_free_r+0xa4>
   109ea:	movw	r0, #1364	; 0x554
   109ee:	cmp	r2, r0
   109f0:	bhi.n	10a00 <_free_r+0x1b0>
   109f2:	lsrs	r2, r3, #18
   109f4:	add.w	r7, r2, #125	; 0x7d
   109f8:	lsls	r7, r7, #1
   109fa:	add.w	r5, r2, #124	; 0x7c
   109fe:	b.n	108f4 <_free_r+0xa4>
   10a00:	movs	r7, #254	; 0xfe
   10a02:	movs	r5, #126	; 0x7e
   10a04:	b.n	108f4 <_free_r+0xa4>
   10a06:	orr.w	r2, r3, #1
   10a0a:	str	r2, [r4, #4]
   10a0c:	str	r3, [r4, r3]
   10a0e:	b.n	108d6 <_free_r+0x86>
   10a10:	.word	0x1fff19b8
   10a14:	.word	0x1fff19c0
   10a18:	.word	0x1fff1dc0
   10a1c:	.word	0x2001d040

00010a20 <rshift>:
   10a20:	ldr	r2, [r0, #16]
   10a22:	asrs	r3, r1, #5
   10a24:	cmp	r3, r2
   10a26:	bge.n	10a86 <rshift+0x66>
   10a28:	push	{r4, r5, r6, r7, lr}
   10a2a:	ands.w	r1, r1, #31
   10a2e:	add.w	r6, r0, #20
   10a32:	add.w	r2, r6, r2, lsl #2
   10a36:	add.w	lr, r6, r3, lsl #2
   10a3a:	beq.n	10a90 <rshift+0x70>
   10a3c:	ldr.w	r3, [r6, r3, lsl #2]
   10a40:	add.w	r5, lr, #4
   10a44:	cmp	r2, r5
   10a46:	lsr.w	r4, r3, r1
   10a4a:	rsb	ip, r1, #32
   10a4e:	bls.n	10ac4 <rshift+0xa4>
   10a50:	add.w	r7, r0, #16
   10a54:	ldr	r3, [r5, #0]
   10a56:	lsl.w	r3, r3, ip
   10a5a:	orrs	r3, r4
   10a5c:	str.w	r3, [r7, #4]!
   10a60:	ldr.w	r3, [r5], #4
   10a64:	cmp	r2, r5
   10a66:	lsr.w	r4, r3, r1
   10a6a:	bhi.n	10a54 <rshift+0x34>
   10a6c:	rsb	r2, lr, r2
   10a70:	subs	r2, #5
   10a72:	bic.w	r2, r2, #3
   10a76:	adds	r2, #4
   10a78:	add	r2, r6
   10a7a:	str	r4, [r2, #0]
   10a7c:	cbz	r4, 10a80 <rshift+0x60>
   10a7e:	adds	r2, #4
   10a80:	subs	r3, r2, r6
   10a82:	asrs	r3, r3, #2
   10a84:	b.n	10ab4 <rshift+0x94>
   10a86:	movs	r3, #0
   10a88:	str	r3, [r0, #16]
   10a8a:	movs	r3, #0
   10a8c:	str	r3, [r0, #20]
   10a8e:	bx	lr
   10a90:	cmp	r2, lr
   10a92:	bls.n	10aba <rshift+0x9a>
   10a94:	add.w	r4, r0, #16
   10a98:	mov	r1, lr
   10a9a:	ldr.w	r5, [r1], #4
   10a9e:	str.w	r5, [r4, #4]!
   10aa2:	cmp	r2, r1
   10aa4:	bhi.n	10a9a <rshift+0x7a>
   10aa6:	mvn.w	r3, lr
   10aaa:	add	r3, r2
   10aac:	bic.w	r3, r3, #3
   10ab0:	adds	r3, #4
   10ab2:	asrs	r3, r3, #2
   10ab4:	str	r3, [r0, #16]
   10ab6:	cbz	r3, 10abe <rshift+0x9e>
   10ab8:	pop	{r4, r5, r6, r7, pc}
   10aba:	movs	r3, #0
   10abc:	str	r3, [r0, #16]
   10abe:	movs	r3, #0
   10ac0:	str	r3, [r0, #20]
   10ac2:	pop	{r4, r5, r6, r7, pc}
   10ac4:	mov	r2, r6
   10ac6:	b.n	10a7a <rshift+0x5a>

00010ac8 <__gethex>:
   10ac8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10acc:	sub	sp, #44	; 0x2c
   10ace:	mov	r9, r1
   10ad0:	str	r0, [sp, #20]
   10ad2:	ldr	r0, [sp, #88]	; 0x58
   10ad4:	str	r2, [sp, #12]
   10ad6:	str	r3, [sp, #32]
   10ad8:	bl	111a4 <__localeconv_l>
   10adc:	ldr	r3, [r0, #0]
   10ade:	str	r3, [sp, #8]
   10ae0:	mov	r0, r3
   10ae2:	mov	r4, r3
   10ae4:	bl	bf40 <strlen>
   10ae8:	ldr.w	r3, [r9]
   10aec:	str	r0, [sp, #0]
   10aee:	ldrb	r2, [r3, #2]
   10af0:	adds	r1, r4, r0
   10af2:	cmp	r2, #48	; 0x30
   10af4:	ldrb.w	fp, [r1, #-1]
   10af8:	bne.w	10e4e <__gethex+0x386>
   10afc:	adds	r3, #3
   10afe:	mov.w	r8, #0
   10b02:	mov	r4, r3
   10b04:	ldrb.w	r2, [r3], #1
   10b08:	cmp	r2, #48	; 0x30
   10b0a:	add.w	r8, r8, #1
   10b0e:	beq.n	10b02 <__gethex+0x3a>
   10b10:	ldr	r6, [pc, #712]	; (10ddc <__gethex+0x314>)
   10b12:	ldrb	r3, [r6, r2]
   10b14:	cmp	r3, #0
   10b16:	beq.w	10cfa <__gethex+0x232>
   10b1a:	ldrb	r3, [r4, #0]
   10b1c:	mov.w	sl, #0
   10b20:	ldrb	r3, [r6, r3]
   10b22:	mov	r5, sl
   10b24:	mov	r7, r4
   10b26:	cbz	r3, 10b32 <__gethex+0x6a>
   10b28:	ldrb.w	r3, [r7, #1]!
   10b2c:	ldrb	r3, [r6, r3]
   10b2e:	cmp	r3, #0
   10b30:	bne.n	10b28 <__gethex+0x60>
   10b32:	ldr	r2, [sp, #0]
   10b34:	ldr	r1, [sp, #8]
   10b36:	mov	r0, r7
   10b38:	bl	c01c <strncmp>
   10b3c:	cmp	r0, #0
   10b3e:	beq.w	10c66 <__gethex+0x19e>
   10b42:	ldrb	r3, [r7, #0]
   10b44:	cmp	r5, #0
   10b46:	beq.w	10e2c <__gethex+0x364>
   10b4a:	subs	r5, r5, r7
   10b4c:	lsls	r2, r5, #2
   10b4e:	str	r2, [sp, #4]
   10b50:	cmp	r3, #80	; 0x50
   10b52:	beq.w	10c78 <__gethex+0x1b0>
   10b56:	cmp	r3, #112	; 0x70
   10b58:	beq.w	10c78 <__gethex+0x1b0>
   10b5c:	mov	r5, r7
   10b5e:	str.w	r7, [r9]
   10b62:	cmp.w	sl, #0
   10b66:	bne.w	10cd8 <__gethex+0x210>
   10b6a:	subs	r3, r5, r4
   10b6c:	subs	r3, #1
   10b6e:	cmp	r3, #7
   10b70:	mov	r1, sl
   10b72:	ble.n	10b7e <__gethex+0xb6>
   10b74:	asrs	r3, r3, #1
   10b76:	cmp	r3, #7
   10b78:	add.w	r1, r1, #1
   10b7c:	bgt.n	10b74 <__gethex+0xac>
   10b7e:	ldr	r0, [sp, #20]
   10b80:	bl	11220 <_Balloc>
   10b84:	mov	r3, r0
   10b86:	adds	r3, #20
   10b88:	cmp	r5, r4
   10b8a:	str	r0, [sp, #16]
   10b8c:	str	r3, [sp, #28]
   10b8e:	bls.w	10f38 <__gethex+0x470>
   10b92:	mov	r9, r3
   10b94:	ldr	r3, [sp, #0]
   10b96:	mov.w	r8, #0
   10b9a:	rsb	r3, r3, #1
   10b9e:	mov	r7, r8
   10ba0:	str	r3, [sp, #24]
   10ba2:	b.n	10bc4 <__gethex+0xfc>
   10ba4:	cmp	r7, #32
   10ba6:	beq.w	10ce8 <__gethex+0x220>
   10baa:	mov	r2, r7
   10bac:	adds	r7, #4
   10bae:	ldrb.w	r3, [r5, #-1]
   10bb2:	ldrb	r3, [r6, r3]
   10bb4:	mov	r5, sl
   10bb6:	and.w	r3, r3, #15
   10bba:	lsls	r3, r2
   10bbc:	cmp	r5, r4
   10bbe:	orr.w	r8, r8, r3
   10bc2:	bls.n	10bf0 <__gethex+0x128>
   10bc4:	ldrb.w	r3, [r5, #-1]
   10bc8:	cmp	r3, fp
   10bca:	add.w	sl, r5, #4294967295
   10bce:	bne.n	10ba4 <__gethex+0xdc>
   10bd0:	ldr	r3, [sp, #24]
   10bd2:	add	r3, sl
   10bd4:	cmp	r3, r4
   10bd6:	bcc.n	10ba4 <__gethex+0xdc>
   10bd8:	mov	r0, r3
   10bda:	ldr	r2, [sp, #0]
   10bdc:	ldr	r1, [sp, #8]
   10bde:	str	r3, [sp, #36]	; 0x24
   10be0:	bl	c01c <strncmp>
   10be4:	ldr	r3, [sp, #36]	; 0x24
   10be6:	cmp	r0, #0
   10be8:	bne.n	10ba4 <__gethex+0xdc>
   10bea:	mov	r5, r3
   10bec:	cmp	r5, r4
   10bee:	bhi.n	10bc4 <__gethex+0xfc>
   10bf0:	str.w	r8, [r9], #4
   10bf4:	ldr	r3, [sp, #28]
   10bf6:	ldr	r2, [sp, #16]
   10bf8:	rsb	r9, r3, r9
   10bfc:	mov.w	r3, r9, asr #2
   10c00:	str	r3, [r2, #16]
   10c02:	mov	r0, r8
   10c04:	mov.w	r9, r3, lsl #5
   10c08:	bl	11398 <__hi0bits>
   10c0c:	ldr	r3, [sp, #12]
   10c0e:	ldr	r6, [r3, #0]
   10c10:	rsb	r0, r0, r9
   10c14:	cmp	r0, r6
   10c16:	bgt.w	10de0 <__gethex+0x318>
   10c1a:	blt.w	10e30 <__gethex+0x368>
   10c1e:	movs	r7, #0
   10c20:	ldr	r3, [sp, #12]
   10c22:	ldr	r2, [sp, #4]
   10c24:	ldr	r3, [r3, #8]
   10c26:	cmp	r2, r3
   10c28:	bgt.w	10d5a <__gethex+0x292>
   10c2c:	ldr	r0, [sp, #12]
   10c2e:	ldr	r1, [sp, #4]
   10c30:	ldr	r3, [r0, #4]
   10c32:	cmp	r1, r3
   10c34:	bge.w	10da2 <__gethex+0x2da>
   10c38:	subs	r5, r3, r1
   10c3a:	cmp	r6, r5
   10c3c:	bgt.w	10e5e <__gethex+0x396>
   10c40:	ldr	r2, [r0, #12]
   10c42:	cmp	r2, #2
   10c44:	beq.w	10f46 <__gethex+0x47e>
   10c48:	cmp	r2, #3
   10c4a:	beq.w	10f06 <__gethex+0x43e>
   10c4e:	cmp	r2, #1
   10c50:	beq.w	10f4e <__gethex+0x486>
   10c54:	ldr	r0, [sp, #20]
   10c56:	ldr	r1, [sp, #16]
   10c58:	bl	1126c <_Bfree>
   10c5c:	ldr	r2, [sp, #80]	; 0x50
   10c5e:	movs	r3, #0
   10c60:	str	r3, [r2, #0]
   10c62:	movs	r0, #80	; 0x50
   10c64:	b.n	10ce2 <__gethex+0x21a>
   10c66:	cmp	r5, #0
   10c68:	beq.w	10e9e <__gethex+0x3d6>
   10c6c:	ldrb	r3, [r7, #0]
   10c6e:	b.n	10b4a <__gethex+0x82>
   10c70:	movs	r3, #0
   10c72:	str	r3, [sp, #4]
   10c74:	mov.w	sl, #1
   10c78:	ldrb	r3, [r7, #1]
   10c7a:	cmp	r3, #43	; 0x2b
   10c7c:	beq.w	10dd8 <__gethex+0x310>
   10c80:	cmp	r3, #45	; 0x2d
   10c82:	beq.n	10d70 <__gethex+0x2a8>
   10c84:	adds	r1, r7, #1
   10c86:	movs	r5, #0
   10c88:	ldrb	r3, [r6, r3]
   10c8a:	ldr	r0, [pc, #336]	; (10ddc <__gethex+0x314>)
   10c8c:	subs	r2, r3, #1
   10c8e:	cmp	r2, #24
   10c90:	bhi.w	10b5c <__gethex+0x94>
   10c94:	ldrb	r2, [r1, #1]
   10c96:	ldrb	r2, [r0, r2]
   10c98:	subs	r0, r2, #1
   10c9a:	cmp	r0, #24
   10c9c:	sub.w	r3, r3, #16
   10ca0:	add.w	r1, r1, #1
   10ca4:	bhi.n	10cbe <__gethex+0x1f6>
   10ca6:	ldrb.w	r0, [r1, #1]!
   10caa:	add.w	r3, r3, r3, lsl #2
   10cae:	add.w	r3, r2, r3, lsl #1
   10cb2:	ldrb	r2, [r6, r0]
   10cb4:	subs	r0, r2, #1
   10cb6:	cmp	r0, #24
   10cb8:	sub.w	r3, r3, #16
   10cbc:	bls.n	10ca6 <__gethex+0x1de>
   10cbe:	cbz	r5, 10cc2 <__gethex+0x1fa>
   10cc0:	negs	r3, r3
   10cc2:	ldr	r2, [sp, #4]
   10cc4:	mov	r5, r7
   10cc6:	add	r2, r3
   10cc8:	mov	r7, r1
   10cca:	str	r2, [sp, #4]
   10ccc:	str.w	r7, [r9]
   10cd0:	cmp.w	sl, #0
   10cd4:	beq.w	10b6a <__gethex+0xa2>
   10cd8:	cmp.w	r8, #0
   10cdc:	ite	eq
   10cde:	moveq	r0, #6
   10ce0:	movne	r0, #0
   10ce2:	add	sp, #44	; 0x2c
   10ce4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10ce8:	str.w	r8, [r9]
   10cec:	mov.w	r8, #0
   10cf0:	add.w	r9, r9, #4
   10cf4:	mov	r2, r8
   10cf6:	movs	r7, #4
   10cf8:	b.n	10bae <__gethex+0xe6>
   10cfa:	ldr	r5, [sp, #0]
   10cfc:	ldr	r1, [sp, #8]
   10cfe:	mov	r2, r5
   10d00:	mov	r0, r4
   10d02:	bl	c01c <strncmp>
   10d06:	cmp	r0, #0
   10d08:	beq.n	10d78 <__gethex+0x2b0>
   10d0a:	ldrb	r3, [r4, #0]
   10d0c:	mov	r7, r4
   10d0e:	cmp	r3, #80	; 0x50
   10d10:	beq.n	10c70 <__gethex+0x1a8>
   10d12:	cmp	r3, #112	; 0x70
   10d14:	beq.n	10c70 <__gethex+0x1a8>
   10d16:	str.w	r7, [r9]
   10d1a:	b.n	10cd8 <__gethex+0x210>
   10d1c:	ldr	r3, [sp, #16]
   10d1e:	ldr	r3, [r3, #8]
   10d20:	cmp	r7, r3
   10d22:	bge.w	10f8e <__gethex+0x4c6>
   10d26:	mov	r3, r7
   10d28:	ldr	r0, [sp, #16]
   10d2a:	add.w	r2, r0, r3, lsl #2
   10d2e:	movs	r1, #1
   10d30:	adds	r3, #1
   10d32:	cmp	r4, #2
   10d34:	str	r3, [r0, #16]
   10d36:	str	r1, [r2, #20]
   10d38:	beq.w	10f6c <__gethex+0x4a4>
   10d3c:	cmp	r7, r3
   10d3e:	bge.w	10ef8 <__gethex+0x430>
   10d42:	movs	r1, #1
   10d44:	ldr	r0, [sp, #16]
   10d46:	bl	10a20 <rshift>
   10d4a:	ldr	r3, [sp, #12]
   10d4c:	ldr	r2, [sp, #4]
   10d4e:	ldr	r3, [r3, #8]
   10d50:	adds	r2, #1
   10d52:	cmp	r2, r3
   10d54:	str	r2, [sp, #4]
   10d56:	ble.w	10efe <__gethex+0x436>
   10d5a:	ldr	r0, [sp, #20]
   10d5c:	ldr	r1, [sp, #16]
   10d5e:	bl	1126c <_Bfree>
   10d62:	ldr	r2, [sp, #80]	; 0x50
   10d64:	movs	r3, #0
   10d66:	movs	r0, #163	; 0xa3
   10d68:	str	r3, [r2, #0]
   10d6a:	add	sp, #44	; 0x2c
   10d6c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10d70:	movs	r5, #1
   10d72:	ldrb	r3, [r7, #2]
   10d74:	adds	r1, r7, #2
   10d76:	b.n	10c88 <__gethex+0x1c0>
   10d78:	ldrb	r2, [r4, r5]
   10d7a:	ldrb	r3, [r6, r2]
   10d7c:	adds	r7, r4, r5
   10d7e:	cmp	r3, #0
   10d80:	beq.n	10e56 <__gethex+0x38e>
   10d82:	cmp	r2, #48	; 0x30
   10d84:	mov	r4, r7
   10d86:	bne.n	10d92 <__gethex+0x2ca>
   10d88:	ldrb.w	r3, [r4, #1]!
   10d8c:	cmp	r3, #48	; 0x30
   10d8e:	beq.n	10d88 <__gethex+0x2c0>
   10d90:	ldrb	r3, [r6, r3]
   10d92:	clz	sl, r3
   10d96:	mov	r5, r7
   10d98:	mov.w	sl, sl, lsr #5
   10d9c:	mov.w	r8, #1
   10da0:	b.n	10b24 <__gethex+0x5c>
   10da2:	movs	r4, #1
   10da4:	cbz	r7, 10dc0 <__gethex+0x2f8>
   10da6:	ldr	r3, [sp, #12]
   10da8:	ldr	r3, [r3, #12]
   10daa:	cmp	r3, #2
   10dac:	beq.w	10eba <__gethex+0x3f2>
   10db0:	cmp	r3, #3
   10db2:	beq.w	10ec2 <__gethex+0x3fa>
   10db6:	cmp	r3, #1
   10db8:	beq.w	10f26 <__gethex+0x45e>
   10dbc:	orr.w	r4, r4, #16
   10dc0:	ldr	r3, [sp, #80]	; 0x50
   10dc2:	mov	r2, r3
   10dc4:	ldr	r3, [sp, #16]
   10dc6:	str	r3, [r2, #0]
   10dc8:	ldr	r3, [sp, #32]
   10dca:	mov	r2, r3
   10dcc:	ldr	r3, [sp, #4]
   10dce:	str	r3, [r2, #0]
   10dd0:	mov	r0, r4
   10dd2:	add	sp, #44	; 0x2c
   10dd4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10dd8:	movs	r5, #0
   10dda:	b.n	10d72 <__gethex+0x2aa>
   10ddc:	.word	0x000132ec
   10de0:	subs	r4, r0, r6
   10de2:	mov	r1, r4
   10de4:	ldr	r0, [sp, #16]
   10de6:	bl	11aa8 <__any_on>
   10dea:	cmp	r0, #0
   10dec:	beq.n	10e5a <__gethex+0x392>
   10dee:	subs	r2, r4, #1
   10df0:	asrs	r1, r2, #5
   10df2:	ldr	r0, [sp, #28]
   10df4:	and.w	r3, r2, #31
   10df8:	ldr.w	r1, [r0, r1, lsl #2]
   10dfc:	movs	r7, #1
   10dfe:	lsl.w	r3, r7, r3
   10e02:	tst	r3, r1
   10e04:	beq.n	10e1c <__gethex+0x354>
   10e06:	cmp	r2, r7
   10e08:	ble.w	10f42 <__gethex+0x47a>
   10e0c:	subs	r1, r4, #2
   10e0e:	ldr	r0, [sp, #16]
   10e10:	bl	11aa8 <__any_on>
   10e14:	cmp	r0, #0
   10e16:	beq.w	10f42 <__gethex+0x47a>
   10e1a:	movs	r7, #3
   10e1c:	ldr	r3, [sp, #4]
   10e1e:	ldr	r0, [sp, #16]
   10e20:	add	r3, r4
   10e22:	mov	r1, r4
   10e24:	str	r3, [sp, #4]
   10e26:	bl	10a20 <rshift>
   10e2a:	b.n	10c20 <__gethex+0x158>
   10e2c:	str	r5, [sp, #4]
   10e2e:	b.n	10b50 <__gethex+0x88>
   10e30:	subs	r4, r6, r0
   10e32:	ldr	r1, [sp, #16]
   10e34:	ldr	r0, [sp, #20]
   10e36:	mov	r2, r4
   10e38:	bl	11618 <__lshift>
   10e3c:	ldr	r3, [sp, #4]
   10e3e:	str	r0, [sp, #16]
   10e40:	subs	r3, r3, r4
   10e42:	str	r3, [sp, #4]
   10e44:	mov	r3, r0
   10e46:	adds	r3, #20
   10e48:	str	r3, [sp, #28]
   10e4a:	movs	r7, #0
   10e4c:	b.n	10c20 <__gethex+0x158>
   10e4e:	adds	r4, r3, #2
   10e50:	mov.w	r8, #0
   10e54:	b.n	10b10 <__gethex+0x48>
   10e56:	mov	r3, r2
   10e58:	b.n	10d0e <__gethex+0x246>
   10e5a:	mov	r7, r0
   10e5c:	b.n	10e1c <__gethex+0x354>
   10e5e:	subs	r4, r5, #1
   10e60:	cmp	r7, #0
   10e62:	bne.n	10f02 <__gethex+0x43a>
   10e64:	cbz	r4, 10e70 <__gethex+0x3a8>
   10e66:	mov	r1, r4
   10e68:	ldr	r0, [sp, #16]
   10e6a:	bl	11aa8 <__any_on>
   10e6e:	mov	r7, r0
   10e70:	asrs	r3, r4, #5
   10e72:	ldr	r2, [sp, #28]
   10e74:	ldr	r0, [sp, #16]
   10e76:	ldr.w	r2, [r2, r3, lsl #2]
   10e7a:	and.w	r4, r4, #31
   10e7e:	movs	r3, #1
   10e80:	lsl.w	r4, r3, r4
   10e84:	tst	r4, r2
   10e86:	mov	r1, r5
   10e88:	it	ne
   10e8a:	orrne.w	r7, r7, #2
   10e8e:	bl	10a20 <rshift>
   10e92:	ldr	r3, [sp, #12]
   10e94:	ldr	r3, [r3, #4]
   10e96:	str	r3, [sp, #4]
   10e98:	subs	r6, r6, r5
   10e9a:	movs	r4, #2
   10e9c:	b.n	10da4 <__gethex+0x2dc>
   10e9e:	ldr	r1, [sp, #0]
   10ea0:	ldrb	r3, [r7, r1]
   10ea2:	ldrb	r2, [r6, r3]
   10ea4:	adds	r5, r7, r1
   10ea6:	mov	r7, r5
   10ea8:	cmp	r2, #0
   10eaa:	beq.w	10b4a <__gethex+0x82>
   10eae:	ldrb.w	r3, [r7, #1]!
   10eb2:	ldrb	r2, [r6, r3]
   10eb4:	cmp	r2, #0
   10eb6:	bne.n	10eae <__gethex+0x3e6>
   10eb8:	b.n	10b4a <__gethex+0x82>
   10eba:	ldr	r3, [sp, #84]	; 0x54
   10ebc:	rsb	r3, r3, #1
   10ec0:	str	r3, [sp, #84]	; 0x54
   10ec2:	ldr	r3, [sp, #84]	; 0x54
   10ec4:	cmp	r3, #0
   10ec6:	beq.w	10dbc <__gethex+0x2f4>
   10eca:	ldr	r3, [sp, #16]
   10ecc:	ldr	r5, [sp, #28]
   10ece:	ldr	r7, [r3, #16]
   10ed0:	mov.w	r8, r7, lsl #2
   10ed4:	add.w	r0, r5, r8
   10ed8:	mov	r3, r5
   10eda:	movs	r1, #0
   10edc:	b.n	10ee8 <__gethex+0x420>
   10ede:	str.w	r1, [r3], #4
   10ee2:	cmp	r0, r3
   10ee4:	bls.w	10d1c <__gethex+0x254>
   10ee8:	ldr	r2, [r3, #0]
   10eea:	cmp.w	r2, #4294967295
   10eee:	beq.n	10ede <__gethex+0x416>
   10ef0:	adds	r2, #1
   10ef2:	cmp	r4, #2
   10ef4:	str	r2, [r3, #0]
   10ef6:	beq.n	10f6c <__gethex+0x4a4>
   10ef8:	ands.w	r6, r6, #31
   10efc:	bne.n	10f7a <__gethex+0x4b2>
   10efe:	movs	r4, #33	; 0x21
   10f00:	b.n	10dc0 <__gethex+0x2f8>
   10f02:	movs	r7, #1
   10f04:	b.n	10e70 <__gethex+0x3a8>
   10f06:	ldr	r2, [sp, #84]	; 0x54
   10f08:	cmp	r2, #0
   10f0a:	beq.w	10c54 <__gethex+0x18c>
   10f0e:	ldr	r1, [sp, #32]
   10f10:	str	r3, [r1, #0]
   10f12:	ldr	r3, [sp, #28]
   10f14:	ldr	r1, [sp, #16]
   10f16:	movs	r2, #1
   10f18:	str	r2, [r1, #16]
   10f1a:	str	r2, [r3, #0]
   10f1c:	ldr	r3, [sp, #80]	; 0x50
   10f1e:	mov	r2, r3
   10f20:	movs	r0, #98	; 0x62
   10f22:	str	r1, [r2, #0]
   10f24:	b.n	10ce2 <__gethex+0x21a>
   10f26:	lsls	r2, r7, #30
   10f28:	bpl.w	10dbc <__gethex+0x2f4>
   10f2c:	ldr	r3, [sp, #28]
   10f2e:	ldr	r3, [r3, #0]
   10f30:	orrs	r3, r7
   10f32:	lsls	r3, r3, #31
   10f34:	bmi.n	10eca <__gethex+0x402>
   10f36:	b.n	10dbc <__gethex+0x2f4>
   10f38:	ldr.w	r9, [sp, #28]
   10f3c:	mov.w	r8, #0
   10f40:	b.n	10bf0 <__gethex+0x128>
   10f42:	movs	r7, #2
   10f44:	b.n	10e1c <__gethex+0x354>
   10f46:	ldr	r2, [sp, #84]	; 0x54
   10f48:	cmp	r2, #0
   10f4a:	beq.n	10f0e <__gethex+0x446>
   10f4c:	b.n	10c54 <__gethex+0x18c>
   10f4e:	cmp	r6, r5
   10f50:	bne.w	10c54 <__gethex+0x18c>
   10f54:	cmp	r6, #1
   10f56:	ble.n	10f0e <__gethex+0x446>
   10f58:	subs	r1, r6, #1
   10f5a:	ldr	r0, [sp, #16]
   10f5c:	bl	11aa8 <__any_on>
   10f60:	cmp	r0, #0
   10f62:	beq.w	10c54 <__gethex+0x18c>
   10f66:	ldr	r3, [sp, #12]
   10f68:	ldr	r3, [r3, #4]
   10f6a:	b.n	10f0e <__gethex+0x446>
   10f6c:	ldr	r3, [sp, #12]
   10f6e:	ldr	r3, [r3, #0]
   10f70:	subs	r3, #1
   10f72:	cmp	r6, r3
   10f74:	beq.n	10fc0 <__gethex+0x4f8>
   10f76:	movs	r4, #34	; 0x22
   10f78:	b.n	10dc0 <__gethex+0x2f8>
   10f7a:	add	r5, r8
   10f7c:	rsb	r6, r6, #32
   10f80:	ldr.w	r0, [r5, #-4]
   10f84:	bl	11398 <__hi0bits>
   10f88:	cmp	r0, r6
   10f8a:	bge.n	10efe <__gethex+0x436>
   10f8c:	b.n	10d42 <__gethex+0x27a>
   10f8e:	ldr	r3, [sp, #16]
   10f90:	ldr.w	r9, [sp, #20]
   10f94:	ldr	r1, [r3, #4]
   10f96:	mov	r0, r9
   10f98:	adds	r1, #1
   10f9a:	bl	11220 <_Balloc>
   10f9e:	ldr	r1, [sp, #16]
   10fa0:	ldr	r3, [r1, #16]
   10fa2:	adds	r2, r3, #2
   10fa4:	mov	r5, r0
   10fa6:	lsls	r2, r2, #2
   10fa8:	adds	r1, #12
   10faa:	adds	r0, #12
   10fac:	bl	8ed0 <memcpy>
   10fb0:	ldr	r1, [sp, #16]
   10fb2:	mov	r0, r9
   10fb4:	bl	1126c <_Bfree>
   10fb8:	str	r5, [sp, #16]
   10fba:	ldr	r3, [r5, #16]
   10fbc:	adds	r5, #20
   10fbe:	b.n	10d28 <__gethex+0x260>
   10fc0:	asrs	r3, r6, #5
   10fc2:	and.w	r6, r6, #31
   10fc6:	ldr.w	r2, [r5, r3, lsl #2]
   10fca:	movs	r3, #1
   10fcc:	lsls	r3, r6
   10fce:	tst	r3, r2
   10fd0:	ite	ne
   10fd2:	movne	r4, #33	; 0x21
   10fd4:	moveq	r4, #34	; 0x22
   10fd6:	b.n	10dc0 <__gethex+0x2f8>

00010fd8 <__match>:
   10fd8:	push	{r4, r5}
   10fda:	ldr	r4, [r0, #0]
   10fdc:	b.n	10ff0 <__match+0x18>
   10fde:	ldrb.w	r3, [r4, #1]!
   10fe2:	sub.w	r5, r3, #65	; 0x41
   10fe6:	cmp	r5, #25
   10fe8:	it	ls
   10fea:	addls	r3, #32
   10fec:	cmp	r3, r2
   10fee:	bne.n	11002 <__match+0x2a>
   10ff0:	ldrb.w	r2, [r1], #1
   10ff4:	cmp	r2, #0
   10ff6:	bne.n	10fde <__match+0x6>
   10ff8:	adds	r4, #1
   10ffa:	str	r4, [r0, #0]
   10ffc:	movs	r0, #1
   10ffe:	pop	{r4, r5}
   11000:	bx	lr
   11002:	movs	r0, #0
   11004:	pop	{r4, r5}
   11006:	bx	lr

00011008 <__hexnan>:
   11008:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1100c:	ldr	r3, [r1, #0]
   1100e:	ldr.w	r9, [pc, #372]	; 11184 <__hexnan+0x17c>
   11012:	sub	sp, #20
   11014:	asrs	r1, r3, #5
   11016:	add.w	r1, r2, r1, lsl #2
   1101a:	ands.w	r3, r3, #31
   1101e:	str	r1, [sp, #4]
   11020:	itt	ne
   11022:	addne	r1, #4
   11024:	strne	r1, [sp, #4]
   11026:	ldr	r4, [sp, #4]
   11028:	str	r0, [sp, #8]
   1102a:	str	r3, [sp, #12]
   1102c:	movs	r3, #0
   1102e:	mov	r1, r3
   11030:	str.w	r3, [r4, #-4]
   11034:	mov	sl, r3
   11036:	mov	lr, r3
   11038:	ldr	r3, [sp, #8]
   1103a:	sub.w	ip, r4, #4
   1103e:	ldr	r5, [r3, #0]
   11040:	mov	r8, ip
   11042:	mov	r0, ip
   11044:	ldrb.w	r3, [r5, #1]!
   11048:	cbz	r3, 11094 <__hexnan+0x8c>
   1104a:	ldrb.w	r4, [r9, r3]
   1104e:	cmp	r4, #0
   11050:	bne.n	110da <__hexnan+0xd2>
   11052:	cmp	r3, #32
   11054:	bhi.n	11112 <__hexnan+0x10a>
   11056:	cmp	lr, sl
   11058:	ble.n	11044 <__hexnan+0x3c>
   1105a:	cmp	r0, r8
   1105c:	bcs.n	11086 <__hexnan+0x7e>
   1105e:	cmp	r1, #7
   11060:	bgt.n	11086 <__hexnan+0x7e>
   11062:	rsb	r1, r1, #8
   11066:	lsls	r1, r1, #2
   11068:	ldr	r6, [r0, #0]
   1106a:	rsb	fp, r1, #32
   1106e:	mov	r3, r0
   11070:	ldr	r7, [r3, #4]
   11072:	lsl.w	r4, r7, fp
   11076:	orrs	r4, r6
   11078:	lsr.w	r6, r7, r1
   1107c:	str	r4, [r3, #0]
   1107e:	str.w	r6, [r3, #4]!
   11082:	cmp	r8, r3
   11084:	bhi.n	11070 <__hexnan+0x68>
   11086:	cmp	r0, r2
   11088:	bhi.n	11100 <__hexnan+0xf8>
   1108a:	ldrb.w	r3, [r5, #1]!
   1108e:	movs	r1, #8
   11090:	cmp	r3, #0
   11092:	bne.n	1104a <__hexnan+0x42>
   11094:	cmp.w	lr, #0
   11098:	beq.n	11116 <__hexnan+0x10e>
   1109a:	cmp	r0, r8
   1109c:	bcs.n	110a2 <__hexnan+0x9a>
   1109e:	cmp	r1, #7
   110a0:	ble.n	1115c <__hexnan+0x154>
   110a2:	cmp	r0, r2
   110a4:	bls.n	1111e <__hexnan+0x116>
   110a6:	mov	r3, r2
   110a8:	ldr.w	r1, [r0], #4
   110ac:	str.w	r1, [r3], #4
   110b0:	cmp	ip, r0
   110b2:	bcs.n	110a8 <__hexnan+0xa0>
   110b4:	movs	r1, #0
   110b6:	str.w	r1, [r3], #4
   110ba:	cmp	ip, r3
   110bc:	bcs.n	110b6 <__hexnan+0xae>
   110be:	ldr	r3, [sp, #4]
   110c0:	ldr.w	r3, [r3, #-4]
   110c4:	cbnz	r3, 110d2 <__hexnan+0xca>
   110c6:	cmp	r2, ip
   110c8:	beq.n	11140 <__hexnan+0x138>
   110ca:	ldr.w	r3, [ip, #-4]!
   110ce:	cmp	r3, #0
   110d0:	beq.n	110c6 <__hexnan+0xbe>
   110d2:	movs	r0, #5
   110d4:	add	sp, #20
   110d6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   110da:	adds	r1, #1
   110dc:	cmp	r1, #8
   110de:	add.w	lr, lr, #1
   110e2:	ble.n	110f2 <__hexnan+0xea>
   110e4:	cmp	r0, r2
   110e6:	bls.n	11044 <__hexnan+0x3c>
   110e8:	movs	r3, #0
   110ea:	str.w	r3, [r0, #-4]
   110ee:	movs	r1, #1
   110f0:	subs	r0, #4
   110f2:	ldr	r3, [r0, #0]
   110f4:	and.w	r4, r4, #15
   110f8:	orr.w	r4, r4, r3, lsl #4
   110fc:	str	r4, [r0, #0]
   110fe:	b.n	11044 <__hexnan+0x3c>
   11100:	movs	r3, #0
   11102:	sub.w	r8, r0, #4
   11106:	str.w	r3, [r0, #-4]
   1110a:	mov	sl, lr
   1110c:	mov	r0, r8
   1110e:	mov	r1, r3
   11110:	b.n	11044 <__hexnan+0x3c>
   11112:	cmp	r3, #41	; 0x29
   11114:	beq.n	1114e <__hexnan+0x146>
   11116:	movs	r0, #4
   11118:	add	sp, #20
   1111a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1111e:	ldr	r3, [sp, #12]
   11120:	cmp	r3, #0
   11122:	beq.n	110be <__hexnan+0xb6>
   11124:	ldr	r4, [sp, #4]
   11126:	ldr	r3, [sp, #12]
   11128:	ldr.w	r1, [r4, #-4]
   1112c:	rsb	r3, r3, #32
   11130:	mov.w	r0, #4294967295
   11134:	lsr.w	r3, r0, r3
   11138:	ands	r3, r1
   1113a:	str.w	r3, [r4, #-4]
   1113e:	b.n	110c4 <__hexnan+0xbc>
   11140:	movs	r3, #1
   11142:	movs	r0, #5
   11144:	str.w	r3, [ip]
   11148:	add	sp, #20
   1114a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1114e:	ldr	r3, [sp, #8]
   11150:	adds	r5, #1
   11152:	str	r5, [r3, #0]
   11154:	cmp.w	lr, #0
   11158:	bne.n	1109a <__hexnan+0x92>
   1115a:	b.n	11116 <__hexnan+0x10e>
   1115c:	rsb	r3, r1, #8
   11160:	lsls	r3, r3, #2
   11162:	ldr	r5, [r0, #0]
   11164:	rsb	r7, r3, #32
   11168:	mov	r1, r0
   1116a:	ldr	r6, [r1, #4]
   1116c:	lsl.w	r4, r6, r7
   11170:	orrs	r4, r5
   11172:	lsr.w	r5, r6, r3
   11176:	str	r4, [r1, #0]
   11178:	str.w	r5, [r1, #4]!
   1117c:	cmp	r8, r1
   1117e:	bhi.n	1116a <__hexnan+0x162>
   11180:	b.n	110a2 <__hexnan+0x9a>
   11182:	nop
   11184:	.word	0x000132ec

00011188 <iswspace>:
   11188:	cmp	r0, #255	; 0xff
   1118a:	bls.n	11190 <iswspace+0x8>
   1118c:	movs	r0, #0
   1118e:	bx	lr
   11190:	push	{r4, lr}
   11192:	mov	r4, r0
   11194:	bl	b2c0 <__locale_ctype_ptr>
   11198:	add	r0, r4
   1119a:	ldrb	r0, [r0, #1]
   1119c:	and.w	r0, r0, #8
   111a0:	uxtb	r0, r0
   111a2:	pop	{r4, pc}

000111a4 <__localeconv_l>:
   111a4:	adds	r0, #240	; 0xf0
   111a6:	bx	lr

000111a8 <_localeconv_r>:
   111a8:	ldr	r2, [pc, #16]	; (111bc <_localeconv_r+0x14>)
   111aa:	ldr	r3, [pc, #20]	; (111c0 <_localeconv_r+0x18>)
   111ac:	ldr	r2, [r2, #0]
   111ae:	ldr	r0, [r2, #52]	; 0x34
   111b0:	cmp	r0, #0
   111b2:	it	eq
   111b4:	moveq	r0, r3
   111b6:	adds	r0, #240	; 0xf0
   111b8:	bx	lr
   111ba:	nop
   111bc:	.word	0x1fff1848
   111c0:	.word	0x1fff184c

000111c4 <_mbrtowc_r>:
   111c4:	push	{r4, r5, r6, r7, lr}
   111c6:	sub	sp, #12
   111c8:	mov	r7, r0
   111ca:	ldr	r5, [sp, #32]
   111cc:	cbz	r2, 111f4 <_mbrtowc_r+0x30>
   111ce:	ldr	r4, [pc, #68]	; (11214 <_mbrtowc_r+0x50>)
   111d0:	ldr	r6, [pc, #68]	; (11218 <_mbrtowc_r+0x54>)
   111d2:	ldr	r4, [r4, #0]
   111d4:	ldr	r4, [r4, #52]	; 0x34
   111d6:	str	r5, [sp, #0]
   111d8:	cmp	r4, #0
   111da:	it	eq
   111dc:	moveq	r4, r6
   111de:	ldr.w	r4, [r4, #228]	; 0xe4
   111e2:	blx	r4
   111e4:	adds	r3, r0, #1
   111e6:	bne.n	111f0 <_mbrtowc_r+0x2c>
   111e8:	movs	r2, #0
   111ea:	movs	r3, #138	; 0x8a
   111ec:	str	r2, [r5, #0]
   111ee:	str	r3, [r7, #0]
   111f0:	add	sp, #12
   111f2:	pop	{r4, r5, r6, r7, pc}
   111f4:	ldr	r3, [pc, #28]	; (11214 <_mbrtowc_r+0x50>)
   111f6:	ldr	r1, [pc, #32]	; (11218 <_mbrtowc_r+0x54>)
   111f8:	ldr	r3, [r3, #0]
   111fa:	ldr	r3, [r3, #52]	; 0x34
   111fc:	str	r5, [sp, #0]
   111fe:	cmp	r3, #0
   11200:	it	eq
   11202:	moveq	r3, r1
   11204:	mov	r4, r2
   11206:	mov	r1, r4
   11208:	ldr	r2, [pc, #16]	; (1121c <_mbrtowc_r+0x58>)
   1120a:	ldr.w	r4, [r3, #228]	; 0xe4
   1120e:	movs	r3, #1
   11210:	blx	r4
   11212:	b.n	111e4 <_mbrtowc_r+0x20>
   11214:	.word	0x1fff1848
   11218:	.word	0x1fff184c
   1121c:	.word	0x00013178

00011220 <_Balloc>:
   11220:	ldr	r3, [r0, #76]	; 0x4c
   11222:	push	{r4, r5, r6, lr}
   11224:	mov	r5, r0
   11226:	mov	r4, r1
   11228:	cbz	r3, 1123e <_Balloc+0x1e>
   1122a:	ldr.w	r0, [r3, r4, lsl #2]
   1122e:	cbz	r0, 11252 <_Balloc+0x32>
   11230:	ldr	r2, [r0, #0]
   11232:	str.w	r2, [r3, r4, lsl #2]
   11236:	movs	r3, #0
   11238:	str	r3, [r0, #16]
   1123a:	str	r3, [r0, #12]
   1123c:	pop	{r4, r5, r6, pc}
   1123e:	movs	r2, #33	; 0x21
   11240:	movs	r1, #4
   11242:	bl	12410 <_calloc_r>
   11246:	str	r0, [r5, #76]	; 0x4c
   11248:	mov	r3, r0
   1124a:	cmp	r0, #0
   1124c:	bne.n	1122a <_Balloc+0xa>
   1124e:	movs	r0, #0
   11250:	pop	{r4, r5, r6, pc}
   11252:	movs	r1, #1
   11254:	lsl.w	r6, r1, r4
   11258:	adds	r2, r6, #5
   1125a:	mov	r0, r5
   1125c:	lsls	r2, r2, #2
   1125e:	bl	12410 <_calloc_r>
   11262:	cmp	r0, #0
   11264:	beq.n	1124e <_Balloc+0x2e>
   11266:	str	r4, [r0, #4]
   11268:	str	r6, [r0, #8]
   1126a:	b.n	11236 <_Balloc+0x16>

0001126c <_Bfree>:
   1126c:	cbz	r1, 1127c <_Bfree+0x10>
   1126e:	ldr	r3, [r0, #76]	; 0x4c
   11270:	ldr	r2, [r1, #4]
   11272:	ldr.w	r0, [r3, r2, lsl #2]
   11276:	str	r0, [r1, #0]
   11278:	str.w	r1, [r3, r2, lsl #2]
   1127c:	bx	lr
   1127e:	nop

00011280 <__multadd>:
   11280:	push	{r4, r5, r6, r7, lr}
   11282:	ldr	r4, [r1, #16]
   11284:	sub	sp, #12
   11286:	mov	r5, r1
   11288:	mov	r6, r0
   1128a:	add.w	lr, r1, #20
   1128e:	movs	r7, #0
   11290:	ldr.w	r0, [lr]
   11294:	uxth	r1, r0
   11296:	mla	r1, r2, r1, r3
   1129a:	lsrs	r3, r1, #16
   1129c:	lsrs	r0, r0, #16
   1129e:	mla	r3, r2, r0, r3
   112a2:	uxth	r1, r1
   112a4:	adds	r7, #1
   112a6:	add.w	r1, r1, r3, lsl #16
   112aa:	cmp	r4, r7
   112ac:	str.w	r1, [lr], #4
   112b0:	mov.w	r3, r3, lsr #16
   112b4:	bgt.n	11290 <__multadd+0x10>
   112b6:	cbz	r3, 112c8 <__multadd+0x48>
   112b8:	ldr	r2, [r5, #8]
   112ba:	cmp	r4, r2
   112bc:	bge.n	112ce <__multadd+0x4e>
   112be:	add.w	r2, r5, r4, lsl #2
   112c2:	adds	r4, #1
   112c4:	str	r3, [r2, #20]
   112c6:	str	r4, [r5, #16]
   112c8:	mov	r0, r5
   112ca:	add	sp, #12
   112cc:	pop	{r4, r5, r6, r7, pc}
   112ce:	ldr	r1, [r5, #4]
   112d0:	str	r3, [sp, #4]
   112d2:	adds	r1, #1
   112d4:	mov	r0, r6
   112d6:	bl	11220 <_Balloc>
   112da:	ldr	r2, [r5, #16]
   112dc:	adds	r2, #2
   112de:	add.w	r1, r5, #12
   112e2:	mov	r7, r0
   112e4:	lsls	r2, r2, #2
   112e6:	adds	r0, #12
   112e8:	bl	8ed0 <memcpy>
   112ec:	ldr	r2, [r6, #76]	; 0x4c
   112ee:	ldr	r1, [r5, #4]
   112f0:	ldr	r3, [sp, #4]
   112f2:	ldr.w	r0, [r2, r1, lsl #2]
   112f6:	str	r0, [r5, #0]
   112f8:	str.w	r5, [r2, r1, lsl #2]
   112fc:	mov	r5, r7
   112fe:	b.n	112be <__multadd+0x3e>

00011300 <__s2b>:
   11300:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   11304:	ldr	r4, [pc, #140]	; (11394 <__s2b+0x94>)
   11306:	ldr	r5, [sp, #32]
   11308:	mov	r7, r3
   1130a:	adds	r3, #8
   1130c:	smull	r4, lr, r4, r3
   11310:	asrs	r3, r3, #31
   11312:	rsb	lr, r3, lr, asr #1
   11316:	cmp.w	lr, #1
   1131a:	mov	r6, r0
   1131c:	mov	r4, r1
   1131e:	mov	r8, r2
   11320:	ble.n	1138e <__s2b+0x8e>
   11322:	movs	r3, #1
   11324:	movs	r1, #0
   11326:	lsls	r3, r3, #1
   11328:	cmp	lr, r3
   1132a:	add.w	r1, r1, #1
   1132e:	bgt.n	11326 <__s2b+0x26>
   11330:	mov	r0, r6
   11332:	bl	11220 <_Balloc>
   11336:	movs	r3, #1
   11338:	cmp.w	r8, #9
   1133c:	str	r5, [r0, #20]
   1133e:	str	r3, [r0, #16]
   11340:	ble.n	11386 <__s2b+0x86>
   11342:	add.w	r9, r4, #9
   11346:	mov	r5, r9
   11348:	add	r4, r8
   1134a:	ldrb.w	r3, [r5], #1
   1134e:	mov	r1, r0
   11350:	subs	r3, #48	; 0x30
   11352:	movs	r2, #10
   11354:	mov	r0, r6
   11356:	bl	11280 <__multadd>
   1135a:	cmp	r5, r4
   1135c:	bne.n	1134a <__s2b+0x4a>
   1135e:	add.w	r4, r9, r8
   11362:	subs	r4, #8
   11364:	cmp	r7, r8
   11366:	ble.n	11382 <__s2b+0x82>
   11368:	rsb	r7, r8, r7
   1136c:	add	r7, r4
   1136e:	ldrb.w	r3, [r4], #1
   11372:	mov	r1, r0
   11374:	subs	r3, #48	; 0x30
   11376:	movs	r2, #10
   11378:	mov	r0, r6
   1137a:	bl	11280 <__multadd>
   1137e:	cmp	r7, r4
   11380:	bne.n	1136e <__s2b+0x6e>
   11382:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   11386:	adds	r4, #10
   11388:	mov.w	r8, #9
   1138c:	b.n	11364 <__s2b+0x64>
   1138e:	movs	r1, #0
   11390:	b.n	11330 <__s2b+0x30>
   11392:	nop
   11394:	.word	0x38e38e39

00011398 <__hi0bits>:
   11398:	lsrs	r3, r0, #16
   1139a:	lsls	r3, r3, #16
   1139c:	cbnz	r3, 113cc <__hi0bits+0x34>
   1139e:	lsls	r0, r0, #16
   113a0:	movs	r3, #16
   113a2:	tst.w	r0, #4278190080	; 0xff000000
   113a6:	itt	eq
   113a8:	lsleq	r0, r0, #8
   113aa:	addeq	r3, #8
   113ac:	tst.w	r0, #4026531840	; 0xf0000000
   113b0:	itt	eq
   113b2:	lsleq	r0, r0, #4
   113b4:	addeq	r3, #4
   113b6:	tst.w	r0, #3221225472	; 0xc0000000
   113ba:	itt	eq
   113bc:	lsleq	r0, r0, #2
   113be:	addeq	r3, #2
   113c0:	cmp	r0, #0
   113c2:	blt.n	113d4 <__hi0bits+0x3c>
   113c4:	lsls	r2, r0, #1
   113c6:	bmi.n	113d0 <__hi0bits+0x38>
   113c8:	movs	r0, #32
   113ca:	bx	lr
   113cc:	movs	r3, #0
   113ce:	b.n	113a2 <__hi0bits+0xa>
   113d0:	adds	r0, r3, #1
   113d2:	bx	lr
   113d4:	mov	r0, r3
   113d6:	bx	lr

000113d8 <__lo0bits>:
   113d8:	ldr	r3, [r0, #0]
   113da:	ands.w	r2, r3, #7
   113de:	beq.n	113f0 <__lo0bits+0x18>
   113e0:	lsls	r1, r3, #31
   113e2:	bmi.n	11426 <__lo0bits+0x4e>
   113e4:	lsls	r2, r3, #30
   113e6:	bmi.n	1142a <__lo0bits+0x52>
   113e8:	lsrs	r3, r3, #2
   113ea:	str	r3, [r0, #0]
   113ec:	movs	r0, #2
   113ee:	bx	lr
   113f0:	uxth	r1, r3
   113f2:	cbnz	r1, 113f8 <__lo0bits+0x20>
   113f4:	lsrs	r3, r3, #16
   113f6:	movs	r2, #16
   113f8:	tst.w	r3, #255	; 0xff
   113fc:	itt	eq
   113fe:	lsreq	r3, r3, #8
   11400:	addeq	r2, #8
   11402:	lsls	r1, r3, #28
   11404:	itt	eq
   11406:	lsreq	r3, r3, #4
   11408:	addeq	r2, #4
   1140a:	lsls	r1, r3, #30
   1140c:	itt	eq
   1140e:	lsreq	r3, r3, #2
   11410:	addeq	r2, #2
   11412:	lsls	r1, r3, #31
   11414:	bmi.n	11420 <__lo0bits+0x48>
   11416:	lsrs	r3, r3, #1
   11418:	bne.n	1141e <__lo0bits+0x46>
   1141a:	movs	r0, #32
   1141c:	bx	lr
   1141e:	adds	r2, #1
   11420:	str	r3, [r0, #0]
   11422:	mov	r0, r2
   11424:	bx	lr
   11426:	movs	r0, #0
   11428:	bx	lr
   1142a:	lsrs	r3, r3, #1
   1142c:	str	r3, [r0, #0]
   1142e:	movs	r0, #1
   11430:	bx	lr
   11432:	nop

00011434 <__i2b>:
   11434:	push	{r4, lr}
   11436:	mov	r4, r1
   11438:	movs	r1, #1
   1143a:	bl	11220 <_Balloc>
   1143e:	movs	r2, #1
   11440:	str	r4, [r0, #20]
   11442:	str	r2, [r0, #16]
   11444:	pop	{r4, pc}
   11446:	nop

00011448 <__multiply>:
   11448:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1144c:	ldr	r5, [r1, #16]
   1144e:	ldr	r7, [r2, #16]
   11450:	cmp	r5, r7
   11452:	sub	sp, #12
   11454:	mov	r4, r1
   11456:	mov	r6, r2
   11458:	bge.n	11464 <__multiply+0x1c>
   1145a:	mov	r2, r5
   1145c:	mov	r4, r6
   1145e:	mov	r5, r7
   11460:	mov	r6, r1
   11462:	mov	r7, r2
   11464:	ldr	r3, [r4, #8]
   11466:	ldr	r1, [r4, #4]
   11468:	add.w	r8, r5, r7
   1146c:	cmp	r8, r3
   1146e:	it	gt
   11470:	addgt	r1, #1
   11472:	bl	11220 <_Balloc>
   11476:	add.w	ip, r0, #20
   1147a:	add.w	r9, ip, r8, lsl #2
   1147e:	cmp	ip, r9
   11480:	str	r0, [sp, #0]
   11482:	bcs.n	11490 <__multiply+0x48>
   11484:	mov	r3, ip
   11486:	movs	r1, #0
   11488:	str.w	r1, [r3], #4
   1148c:	cmp	r9, r3
   1148e:	bhi.n	11488 <__multiply+0x40>
   11490:	add.w	r2, r6, #20
   11494:	add.w	sl, r2, r7, lsl #2
   11498:	add.w	r3, r4, #20
   1149c:	cmp	r2, sl
   1149e:	add.w	lr, r3, r5, lsl #2
   114a2:	bcs.n	1154e <__multiply+0x106>
   114a4:	str.w	r9, [sp, #4]
   114a8:	mov	r9, r3
   114aa:	ldr.w	r3, [r2], #4
   114ae:	uxth.w	fp, r3
   114b2:	cmp.w	fp, #0
   114b6:	beq.n	114fa <__multiply+0xb2>
   114b8:	movs	r0, #0
   114ba:	mov	r7, r9
   114bc:	mov	r6, ip
   114be:	mov	r5, r0
   114c0:	b.n	114c4 <__multiply+0x7c>
   114c2:	mov	r6, r3
   114c4:	ldr.w	r4, [r7], #4
   114c8:	ldr	r0, [r6, #0]
   114ca:	uxth	r1, r4
   114cc:	uxth	r3, r0
   114ce:	mla	r1, fp, r1, r3
   114d2:	lsrs	r4, r4, #16
   114d4:	lsrs	r0, r0, #16
   114d6:	adds	r3, r1, r5
   114d8:	mla	r0, fp, r4, r0
   114dc:	add.w	r0, r0, r3, lsr #16
   114e0:	uxth	r1, r3
   114e2:	mov	r3, r6
   114e4:	orr.w	r1, r1, r0, lsl #16
   114e8:	cmp	lr, r7
   114ea:	mov.w	r5, r0, lsr #16
   114ee:	str.w	r1, [r3], #4
   114f2:	bhi.n	114c2 <__multiply+0x7a>
   114f4:	str	r5, [r6, #4]
   114f6:	ldr.w	r3, [r2, #-4]
   114fa:	movs.w	fp, r3, lsr #16
   114fe:	beq.n	11542 <__multiply+0xfa>
   11500:	ldr.w	r3, [ip]
   11504:	mov	r7, ip
   11506:	mov	r0, r3
   11508:	mov	r5, r9
   1150a:	movs	r1, #0
   1150c:	b.n	11510 <__multiply+0xc8>
   1150e:	mov	r7, r6
   11510:	ldrh	r4, [r5, #0]
   11512:	lsrs	r0, r0, #16
   11514:	mla	r0, fp, r4, r0
   11518:	add	r1, r0
   1151a:	uxth	r4, r3
   1151c:	mov	r6, r7
   1151e:	orr.w	r3, r4, r1, lsl #16
   11522:	str.w	r3, [r6], #4
   11526:	ldr	r0, [r7, #4]
   11528:	ldr.w	r4, [r5], #4
   1152c:	uxth	r3, r0
   1152e:	lsrs	r4, r4, #16
   11530:	mla	r4, fp, r4, r3
   11534:	add.w	r3, r4, r1, lsr #16
   11538:	cmp	lr, r5
   1153a:	mov.w	r1, r3, lsr #16
   1153e:	bhi.n	1150e <__multiply+0xc6>
   11540:	str	r3, [r7, #4]
   11542:	cmp	sl, r2
   11544:	add.w	ip, ip, #4
   11548:	bhi.n	114aa <__multiply+0x62>
   1154a:	ldr.w	r9, [sp, #4]
   1154e:	cmp.w	r8, #0
   11552:	ble.n	1156c <__multiply+0x124>
   11554:	ldr.w	r3, [r9, #-4]
   11558:	sub.w	r9, r9, #4
   1155c:	cbz	r3, 11566 <__multiply+0x11e>
   1155e:	b.n	1156c <__multiply+0x124>
   11560:	ldr.w	r3, [r9, #-4]!
   11564:	cbnz	r3, 1156c <__multiply+0x124>
   11566:	subs.w	r8, r8, #1
   1156a:	bne.n	11560 <__multiply+0x118>
   1156c:	ldr	r0, [sp, #0]
   1156e:	str.w	r8, [r0, #16]
   11572:	add	sp, #12
   11574:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00011578 <__pow5mult>:
   11578:	ands.w	r3, r2, #3
   1157c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11580:	mov	r4, r2
   11582:	mov	r7, r0
   11584:	bne.n	115e4 <__pow5mult+0x6c>
   11586:	mov	r6, r1
   11588:	asrs	r4, r4, #2
   1158a:	beq.n	115c6 <__pow5mult+0x4e>
   1158c:	ldr	r5, [r7, #72]	; 0x48
   1158e:	cbz	r5, 115f6 <__pow5mult+0x7e>
   11590:	lsls	r3, r4, #31
   11592:	mov.w	r8, #0
   11596:	bmi.n	115a6 <__pow5mult+0x2e>
   11598:	asrs	r4, r4, #1
   1159a:	beq.n	115c6 <__pow5mult+0x4e>
   1159c:	ldr	r0, [r5, #0]
   1159e:	cbz	r0, 115cc <__pow5mult+0x54>
   115a0:	mov	r5, r0
   115a2:	lsls	r3, r4, #31
   115a4:	bpl.n	11598 <__pow5mult+0x20>
   115a6:	mov	r2, r5
   115a8:	mov	r1, r6
   115aa:	mov	r0, r7
   115ac:	bl	11448 <__multiply>
   115b0:	cbz	r6, 115e0 <__pow5mult+0x68>
   115b2:	ldr	r2, [r6, #4]
   115b4:	ldr	r3, [r7, #76]	; 0x4c
   115b6:	asrs	r4, r4, #1
   115b8:	ldr.w	r1, [r3, r2, lsl #2]
   115bc:	str	r1, [r6, #0]
   115be:	str.w	r6, [r3, r2, lsl #2]
   115c2:	mov	r6, r0
   115c4:	bne.n	1159c <__pow5mult+0x24>
   115c6:	mov	r0, r6
   115c8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   115cc:	mov	r2, r5
   115ce:	mov	r1, r5
   115d0:	mov	r0, r7
   115d2:	bl	11448 <__multiply>
   115d6:	str	r0, [r5, #0]
   115d8:	str.w	r8, [r0]
   115dc:	mov	r5, r0
   115de:	b.n	115a2 <__pow5mult+0x2a>
   115e0:	mov	r6, r0
   115e2:	b.n	11598 <__pow5mult+0x20>
   115e4:	subs	r2, r3, #1
   115e6:	ldr	r5, [pc, #44]	; (11614 <__pow5mult+0x9c>)
   115e8:	movs	r3, #0
   115ea:	ldr.w	r2, [r5, r2, lsl #2]
   115ee:	bl	11280 <__multadd>
   115f2:	mov	r6, r0
   115f4:	b.n	11588 <__pow5mult+0x10>
   115f6:	movs	r1, #1
   115f8:	mov	r0, r7
   115fa:	bl	11220 <_Balloc>
   115fe:	movw	r1, #625	; 0x271
   11602:	movs	r2, #1
   11604:	movs	r3, #0
   11606:	str	r1, [r0, #20]
   11608:	str	r2, [r0, #16]
   1160a:	mov	r5, r0
   1160c:	str	r0, [r7, #72]	; 0x48
   1160e:	str	r3, [r0, #0]
   11610:	b.n	11590 <__pow5mult+0x18>
   11612:	nop
   11614:	.word	0x000134e0

00011618 <__lshift>:
   11618:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1161c:	mov	r9, r2
   1161e:	ldr	r2, [r1, #16]
   11620:	ldr	r3, [r1, #8]
   11622:	mov.w	r4, r9, asr #5
   11626:	add.w	r8, r4, r2
   1162a:	add.w	r5, r8, #1
   1162e:	cmp	r5, r3
   11630:	mov	r6, r1
   11632:	mov	sl, r0
   11634:	ldr	r1, [r1, #4]
   11636:	ble.n	11642 <__lshift+0x2a>
   11638:	lsls	r3, r3, #1
   1163a:	cmp	r5, r3
   1163c:	add.w	r1, r1, #1
   11640:	bgt.n	11638 <__lshift+0x20>
   11642:	mov	r0, sl
   11644:	bl	11220 <_Balloc>
   11648:	cmp	r4, #0
   1164a:	add.w	r2, r0, #20
   1164e:	ble.n	116c2 <__lshift+0xaa>
   11650:	add.w	r3, r2, r4, lsl #2
   11654:	movs	r1, #0
   11656:	str.w	r1, [r2], #4
   1165a:	cmp	r3, r2
   1165c:	bne.n	11656 <__lshift+0x3e>
   1165e:	ldr	r4, [r6, #16]
   11660:	add.w	r1, r6, #20
   11664:	ands.w	r9, r9, #31
   11668:	add.w	lr, r1, r4, lsl #2
   1166c:	beq.n	116b2 <__lshift+0x9a>
   1166e:	rsb	r2, r9, #32
   11672:	movs	r4, #0
   11674:	ldr	r7, [r1, #0]
   11676:	lsl.w	ip, r7, r9
   1167a:	orr.w	r4, ip, r4
   1167e:	mov	ip, r3
   11680:	str.w	r4, [r3], #4
   11684:	ldr.w	r4, [r1], #4
   11688:	cmp	lr, r1
   1168a:	lsr.w	r4, r4, r2
   1168e:	bhi.n	11674 <__lshift+0x5c>
   11690:	str.w	r4, [ip, #4]
   11694:	cbz	r4, 1169a <__lshift+0x82>
   11696:	add.w	r5, r8, #2
   1169a:	ldr.w	r3, [sl, #76]	; 0x4c
   1169e:	ldr	r2, [r6, #4]
   116a0:	subs	r5, #1
   116a2:	ldr.w	r1, [r3, r2, lsl #2]
   116a6:	str	r5, [r0, #16]
   116a8:	str	r1, [r6, #0]
   116aa:	str.w	r6, [r3, r2, lsl #2]
   116ae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   116b2:	subs	r3, #4
   116b4:	ldr.w	r2, [r1], #4
   116b8:	str.w	r2, [r3, #4]!
   116bc:	cmp	lr, r1
   116be:	bhi.n	116b4 <__lshift+0x9c>
   116c0:	b.n	1169a <__lshift+0x82>
   116c2:	mov	r3, r2
   116c4:	b.n	1165e <__lshift+0x46>
   116c6:	nop

000116c8 <__mcmp>:
   116c8:	ldr	r2, [r0, #16]
   116ca:	ldr	r3, [r1, #16]
   116cc:	subs	r2, r2, r3
   116ce:	bne.n	116f8 <__mcmp+0x30>
   116d0:	lsls	r3, r3, #2
   116d2:	adds	r0, #20
   116d4:	adds	r1, #20
   116d6:	add	r1, r3
   116d8:	push	{r4}
   116da:	add	r3, r0
   116dc:	b.n	116e2 <__mcmp+0x1a>
   116de:	cmp	r0, r3
   116e0:	bcs.n	116fc <__mcmp+0x34>
   116e2:	ldr.w	r4, [r3, #-4]!
   116e6:	ldr.w	r2, [r1, #-4]!
   116ea:	cmp	r4, r2
   116ec:	beq.n	116de <__mcmp+0x16>
   116ee:	bcc.n	11704 <__mcmp+0x3c>
   116f0:	movs	r0, #1
   116f2:	ldr.w	r4, [sp], #4
   116f6:	bx	lr
   116f8:	mov	r0, r2
   116fa:	bx	lr
   116fc:	movs	r0, #0
   116fe:	ldr.w	r4, [sp], #4
   11702:	bx	lr
   11704:	mov.w	r0, #4294967295
   11708:	b.n	116f2 <__mcmp+0x2a>
   1170a:	nop

0001170c <__mdiff>:
   1170c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   11710:	ldr	r3, [r1, #16]
   11712:	mov	r7, r1
   11714:	ldr	r1, [r2, #16]
   11716:	subs	r3, r3, r1
   11718:	cmp	r3, #0
   1171a:	mov	r8, r2
   1171c:	bne.n	1174e <__mdiff+0x42>
   1171e:	lsls	r1, r1, #2
   11720:	add.w	r2, r7, #20
   11724:	add.w	r5, r8, #20
   11728:	adds	r3, r2, r1
   1172a:	add	r1, r5
   1172c:	b.n	11732 <__mdiff+0x26>
   1172e:	cmp	r2, r3
   11730:	bcs.n	117f0 <__mdiff+0xe4>
   11732:	ldr.w	r6, [r3, #-4]!
   11736:	ldr.w	r4, [r1, #-4]!
   1173a:	cmp	r6, r4
   1173c:	beq.n	1172e <__mdiff+0x22>
   1173e:	bcs.n	11802 <__mdiff+0xf6>
   11740:	mov	r3, r7
   11742:	mov	r4, r2
   11744:	mov	r7, r8
   11746:	mov.w	r9, #1
   1174a:	mov	r8, r3
   1174c:	b.n	1175c <__mdiff+0x50>
   1174e:	blt.n	1180c <__mdiff+0x100>
   11750:	add.w	r5, r7, #20
   11754:	add.w	r4, r2, #20
   11758:	mov.w	r9, #0
   1175c:	ldr	r1, [r7, #4]
   1175e:	bl	11220 <_Balloc>
   11762:	ldr.w	r3, [r8, #16]
   11766:	ldr	r6, [r7, #16]
   11768:	str.w	r9, [r0, #12]
   1176c:	add.w	ip, r4, r3, lsl #2
   11770:	mov	lr, r4
   11772:	add.w	r7, r5, r6, lsl #2
   11776:	add.w	r4, r0, #20
   1177a:	movs	r3, #0
   1177c:	ldr.w	r1, [lr], #4
   11780:	ldr.w	r8, [r5], #4
   11784:	uxth	r2, r1
   11786:	uxtah	r3, r3, r8
   1178a:	lsrs	r1, r1, #16
   1178c:	subs	r2, r3, r2
   1178e:	rsb	r3, r1, r8, lsr #16
   11792:	add.w	r3, r3, r2, asr #16
   11796:	uxth	r2, r2
   11798:	orr.w	r2, r2, r3, lsl #16
   1179c:	cmp	ip, lr
   1179e:	str.w	r2, [r4], #4
   117a2:	mov.w	r3, r3, asr #16
   117a6:	bhi.n	1177c <__mdiff+0x70>
   117a8:	cmp	r7, r5
   117aa:	bls.n	117dc <__mdiff+0xd0>
   117ac:	mov	ip, r4
   117ae:	mov	r1, r5
   117b0:	ldr.w	lr, [r1], #4
   117b4:	uxtah	r2, r3, lr
   117b8:	asrs	r3, r2, #16
   117ba:	add.w	r3, r3, lr, lsr #16
   117be:	uxth	r2, r2
   117c0:	orr.w	r2, r2, r3, lsl #16
   117c4:	cmp	r7, r1
   117c6:	str.w	r2, [ip], #4
   117ca:	mov.w	r3, r3, asr #16
   117ce:	bhi.n	117b0 <__mdiff+0xa4>
   117d0:	mvns	r5, r5
   117d2:	add	r5, r7
   117d4:	bic.w	r5, r5, #3
   117d8:	adds	r5, #4
   117da:	add	r4, r5
   117dc:	subs	r4, #4
   117de:	cbnz	r2, 117ea <__mdiff+0xde>
   117e0:	ldr.w	r3, [r4, #-4]!
   117e4:	subs	r6, #1
   117e6:	cmp	r3, #0
   117e8:	beq.n	117e0 <__mdiff+0xd4>
   117ea:	str	r6, [r0, #16]
   117ec:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   117f0:	movs	r1, #0
   117f2:	bl	11220 <_Balloc>
   117f6:	movs	r2, #1
   117f8:	movs	r3, #0
   117fa:	str	r2, [r0, #16]
   117fc:	str	r3, [r0, #20]
   117fe:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   11802:	mov	r4, r5
   11804:	mov.w	r9, #0
   11808:	mov	r5, r2
   1180a:	b.n	1175c <__mdiff+0x50>
   1180c:	mov	r3, r7
   1180e:	add.w	r4, r7, #20
   11812:	add.w	r5, r8, #20
   11816:	mov	r7, r8
   11818:	mov.w	r9, #1
   1181c:	mov	r8, r3
   1181e:	b.n	1175c <__mdiff+0x50>

00011820 <__ulp>:
   11820:	ldr	r3, [pc, #76]	; (11870 <__ulp+0x50>)
   11822:	vmov	r2, s1
   11826:	ands	r2, r3
   11828:	sub.w	r3, r2, #54525952	; 0x3400000
   1182c:	cmp	r3, #0
   1182e:	ble.n	1183a <__ulp+0x1a>
   11830:	movs	r0, #0
   11832:	mov	r1, r3
   11834:	vmov	d0, r0, r1
   11838:	bx	lr
   1183a:	negs	r3, r3
   1183c:	asrs	r3, r3, #20
   1183e:	cmp	r3, #19
   11840:	ble.n	1185e <__ulp+0x3e>
   11842:	subs	r3, #20
   11844:	cmp	r3, #30
   11846:	ittte	le
   11848:	rsble	r3, r3, #31
   1184c:	movle	r2, #1
   1184e:	lslle.w	r3, r2, r3
   11852:	movgt	r3, #1
   11854:	movs	r1, #0
   11856:	mov	r0, r3
   11858:	vmov	d0, r0, r1
   1185c:	bx	lr
   1185e:	mov.w	r2, #524288	; 0x80000
   11862:	movs	r0, #0
   11864:	asr.w	r1, r2, r3
   11868:	vmov	d0, r0, r1
   1186c:	bx	lr
   1186e:	nop
   11870:	.word	0x7ff00000

00011874 <__b2d>:
   11874:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11878:	ldr	r6, [r0, #16]
   1187a:	add.w	r8, r0, #20
   1187e:	add.w	r6, r8, r6, lsl #2
   11882:	ldr.w	r7, [r6, #-4]
   11886:	mov	r0, r7
   11888:	bl	11398 <__hi0bits>
   1188c:	rsb	r3, r0, #32
   11890:	cmp	r0, #10
   11892:	str	r3, [r1, #0]
   11894:	sub.w	r3, r6, #4
   11898:	bgt.n	118cc <__b2d+0x58>
   1189a:	cmp	r8, r3
   1189c:	rsb	r2, r0, #11
   118a0:	it	cc
   118a2:	ldrcc.w	r3, [r6, #-8]
   118a6:	lsr.w	r1, r7, r2
   118aa:	add.w	r0, r0, #21
   118ae:	orr.w	r5, r1, #1069547520	; 0x3fc00000
   118b2:	ite	cc
   118b4:	lsrcc	r3, r2
   118b6:	movcs	r3, #0
   118b8:	lsl.w	r0, r7, r0
   118bc:	orr.w	r5, r5, #3145728	; 0x300000
   118c0:	orr.w	r4, r0, r3
   118c4:	vmov	d0, r4, r5
   118c8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   118cc:	cmp	r8, r3
   118ce:	bcs.n	11912 <__b2d+0x9e>
   118d0:	subs.w	r3, r0, #11
   118d4:	ldr.w	r2, [r6, #-8]
   118d8:	beq.n	11918 <__b2d+0xa4>
   118da:	lsl.w	r0, r7, r3
   118de:	orr.w	r7, r0, #1069547520	; 0x3fc00000
   118e2:	rsb	lr, r3, #32
   118e6:	sub.w	r1, r6, #8
   118ea:	orr.w	r7, r7, #3145728	; 0x300000
   118ee:	lsr.w	r0, r2, lr
   118f2:	cmp	r8, r1
   118f4:	orr.w	r5, r7, r0
   118f8:	bcs.n	1193c <__b2d+0xc8>
   118fa:	ldr.w	r1, [r6, #-12]
   118fe:	lsl.w	r0, r2, r3
   11902:	lsr.w	r3, r1, lr
   11906:	orrs	r0, r3
   11908:	mov	r4, r0
   1190a:	vmov	d0, r4, r5
   1190e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11912:	subs	r0, #11
   11914:	bne.n	1192a <__b2d+0xb6>
   11916:	mov	r2, r0
   11918:	orr.w	r5, r7, #1069547520	; 0x3fc00000
   1191c:	orr.w	r5, r5, #3145728	; 0x300000
   11920:	mov	r4, r2
   11922:	vmov	d0, r4, r5
   11926:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1192a:	lsl.w	r0, r7, r0
   1192e:	orr.w	r5, r0, #1069547520	; 0x3fc00000
   11932:	movs	r0, #0
   11934:	orr.w	r5, r5, #3145728	; 0x300000
   11938:	mov	r4, r0
   1193a:	b.n	1190a <__b2d+0x96>
   1193c:	lsl.w	r0, r2, r3
   11940:	mov	r4, r0
   11942:	b.n	1190a <__b2d+0x96>

00011944 <__d2b>:
   11944:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11948:	vmov	r6, r7, d0
   1194c:	sub	sp, #12
   1194e:	mov	r8, r1
   11950:	movs	r1, #1
   11952:	mov	r4, r7
   11954:	ubfx	r5, r7, #20, #11
   11958:	mov	r7, r2
   1195a:	bl	11220 <_Balloc>
   1195e:	ubfx	r4, r4, #0, #20
   11962:	mov	r9, r0
   11964:	cbz	r5, 1196a <__d2b+0x26>
   11966:	orr.w	r4, r4, #1048576	; 0x100000
   1196a:	str	r4, [sp, #4]
   1196c:	cbz	r6, 119b6 <__d2b+0x72>
   1196e:	add	r0, sp, #8
   11970:	str.w	r6, [r0, #-8]!
   11974:	bl	113d8 <__lo0bits>
   11978:	cmp	r0, #0
   1197a:	bne.n	119e6 <__d2b+0xa2>
   1197c:	ldmia.w	sp, {r2, r3}
   11980:	str.w	r2, [r9, #20]
   11984:	cmp	r3, #0
   11986:	ite	eq
   11988:	moveq	r1, #1
   1198a:	movne	r1, #2
   1198c:	str.w	r3, [r9, #24]
   11990:	str.w	r1, [r9, #16]
   11994:	cbnz	r5, 119ce <__d2b+0x8a>
   11996:	add.w	r3, r9, r1, lsl #2
   1199a:	subw	r0, r0, #1074	; 0x432
   1199e:	str.w	r0, [r8]
   119a2:	ldr	r0, [r3, #16]
   119a4:	bl	11398 <__hi0bits>
   119a8:	rsb	r0, r0, r1, lsl #5
   119ac:	str	r0, [r7, #0]
   119ae:	mov	r0, r9
   119b0:	add	sp, #12
   119b2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   119b6:	add	r0, sp, #4
   119b8:	bl	113d8 <__lo0bits>
   119bc:	ldr	r3, [sp, #4]
   119be:	str.w	r3, [r9, #20]
   119c2:	movs	r1, #1
   119c4:	adds	r0, #32
   119c6:	str.w	r1, [r9, #16]
   119ca:	cmp	r5, #0
   119cc:	beq.n	11996 <__d2b+0x52>
   119ce:	subw	r5, r5, #1075	; 0x433
   119d2:	add	r5, r0
   119d4:	rsb	r0, r0, #53	; 0x35
   119d8:	str.w	r5, [r8]
   119dc:	str	r0, [r7, #0]
   119de:	mov	r0, r9
   119e0:	add	sp, #12
   119e2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   119e6:	ldmia.w	sp, {r2, r3}
   119ea:	rsb	r1, r0, #32
   119ee:	lsl.w	r1, r3, r1
   119f2:	orrs	r2, r1
   119f4:	lsrs	r3, r0
   119f6:	str	r3, [sp, #4]
   119f8:	str.w	r2, [r9, #20]
   119fc:	b.n	11984 <__d2b+0x40>
   119fe:	nop

00011a00 <__ratio>:
   11a00:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11a04:	sub	sp, #12
   11a06:	mov	r8, r1
   11a08:	mov	r1, sp
   11a0a:	mov	r9, r0
   11a0c:	bl	11874 <__b2d>
   11a10:	mov	r0, r8
   11a12:	add	r1, sp, #4
   11a14:	vmov	r4, r5, d0
   11a18:	bl	11874 <__b2d>
   11a1c:	ldmia.w	sp, {r1, r3}
   11a20:	ldr.w	r2, [r9, #16]
   11a24:	ldr.w	r0, [r8, #16]
   11a28:	subs	r1, r1, r3
   11a2a:	subs	r0, r2, r0
   11a2c:	add.w	r3, r1, r0, lsl #5
   11a30:	cmp	r3, #0
   11a32:	vmov	r6, r7, d0
   11a36:	ble.n	11a54 <__ratio+0x54>
   11a38:	add.w	r1, r5, r3, lsl #20
   11a3c:	mov	r5, r1
   11a3e:	mov	r2, r6
   11a40:	mov	r3, r7
   11a42:	mov	r0, r4
   11a44:	mov	r1, r5
   11a46:	bl	aac8 <__aeabi_ddiv>
   11a4a:	vmov	d0, r0, r1
   11a4e:	add	sp, #12
   11a50:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   11a54:	sub.w	r9, r7, r3, lsl #20
   11a58:	vmov	r6, s0
   11a5c:	mov	r7, r9
   11a5e:	b.n	11a3e <__ratio+0x3e>

00011a60 <__copybits>:
   11a60:	push	{r4, r5, r6}
   11a62:	ldr	r4, [r2, #16]
   11a64:	add.w	r3, r2, #20
   11a68:	subs	r1, #1
   11a6a:	asrs	r6, r1, #5
   11a6c:	add.w	r4, r3, r4, lsl #2
   11a70:	adds	r6, #1
   11a72:	cmp	r3, r4
   11a74:	add.w	r6, r0, r6, lsl #2
   11a78:	bcs.n	11a94 <__copybits+0x34>
   11a7a:	subs	r1, r0, #4
   11a7c:	ldr.w	r5, [r3], #4
   11a80:	str.w	r5, [r1, #4]!
   11a84:	cmp	r4, r3
   11a86:	bhi.n	11a7c <__copybits+0x1c>
   11a88:	subs	r3, r4, r2
   11a8a:	subs	r3, #21
   11a8c:	bic.w	r3, r3, #3
   11a90:	adds	r3, #4
   11a92:	add	r0, r3
   11a94:	cmp	r6, r0
   11a96:	bls.n	11aa2 <__copybits+0x42>
   11a98:	movs	r3, #0
   11a9a:	str.w	r3, [r0], #4
   11a9e:	cmp	r6, r0
   11aa0:	bhi.n	11a9a <__copybits+0x3a>
   11aa2:	pop	{r4, r5, r6}
   11aa4:	bx	lr
   11aa6:	nop

00011aa8 <__any_on>:
   11aa8:	ldr	r3, [r0, #16]
   11aaa:	asrs	r2, r1, #5
   11aac:	cmp	r3, r2
   11aae:	push	{r4}
   11ab0:	add.w	r4, r0, #20
   11ab4:	bge.n	11ad8 <__any_on+0x30>
   11ab6:	add.w	r3, r4, r3, lsl #2
   11aba:	cmp	r4, r3
   11abc:	bcs.n	11b02 <__any_on+0x5a>
   11abe:	ldr.w	r0, [r3, #-4]
   11ac2:	subs	r3, #4
   11ac4:	cbz	r0, 11ace <__any_on+0x26>
   11ac6:	b.n	11af4 <__any_on+0x4c>
   11ac8:	ldr.w	r2, [r3, #-4]!
   11acc:	cbnz	r2, 11af4 <__any_on+0x4c>
   11ace:	cmp	r4, r3
   11ad0:	bcc.n	11ac8 <__any_on+0x20>
   11ad2:	ldr.w	r4, [sp], #4
   11ad6:	bx	lr
   11ad8:	ble.n	11afc <__any_on+0x54>
   11ada:	ands.w	r1, r1, #31
   11ade:	beq.n	11afc <__any_on+0x54>
   11ae0:	ldr.w	r0, [r4, r2, lsl #2]
   11ae4:	lsr.w	r3, r0, r1
   11ae8:	lsl.w	r1, r3, r1
   11aec:	cmp	r0, r1
   11aee:	add.w	r3, r4, r2, lsl #2
   11af2:	beq.n	11aba <__any_on+0x12>
   11af4:	movs	r0, #1
   11af6:	ldr.w	r4, [sp], #4
   11afa:	bx	lr
   11afc:	add.w	r3, r4, r2, lsl #2
   11b00:	b.n	11aba <__any_on+0x12>
   11b02:	movs	r0, #0
   11b04:	b.n	11ad2 <__any_on+0x2a>
   11b06:	nop

00011b08 <__sccl>:
   11b08:	push	{r4, r5, r6}
   11b0a:	ldrb	r5, [r1, #0]
   11b0c:	cmp	r5, #94	; 0x5e
   11b0e:	beq.n	11b70 <__sccl+0x68>
   11b10:	movs	r2, #0
   11b12:	adds	r1, #1
   11b14:	mov	r6, r2
   11b16:	subs	r3, r0, #1
   11b18:	add.w	r4, r0, #255	; 0xff
   11b1c:	strb.w	r2, [r3, #1]!
   11b20:	cmp	r3, r4
   11b22:	bne.n	11b1c <__sccl+0x14>
   11b24:	cbz	r5, 11b48 <__sccl+0x40>
   11b26:	eor.w	r2, r6, #1
   11b2a:	strb	r2, [r0, r5]
   11b2c:	adds	r4, r1, #1
   11b2e:	ldrb.w	r3, [r4, #-1]
   11b32:	cmp	r3, #45	; 0x2d
   11b34:	beq.n	11b54 <__sccl+0x4c>
   11b36:	cmp	r3, #93	; 0x5d
   11b38:	beq.n	11b4e <__sccl+0x46>
   11b3a:	cbz	r3, 11b42 <__sccl+0x3a>
   11b3c:	mov	r5, r3
   11b3e:	mov	r1, r4
   11b40:	b.n	11b2a <__sccl+0x22>
   11b42:	mov	r0, r1
   11b44:	pop	{r4, r5, r6}
   11b46:	bx	lr
   11b48:	subs	r0, r1, #1
   11b4a:	pop	{r4, r5, r6}
   11b4c:	bx	lr
   11b4e:	mov	r0, r4
   11b50:	pop	{r4, r5, r6}
   11b52:	bx	lr
   11b54:	ldrb	r6, [r1, #1]
   11b56:	cmp	r6, #93	; 0x5d
   11b58:	beq.n	11b3c <__sccl+0x34>
   11b5a:	cmp	r5, r6
   11b5c:	bgt.n	11b3c <__sccl+0x34>
   11b5e:	adds	r1, #2
   11b60:	adds	r3, r0, r5
   11b62:	adds	r5, #1
   11b64:	cmp	r6, r5
   11b66:	strb.w	r2, [r3, #1]!
   11b6a:	bgt.n	11b62 <__sccl+0x5a>
   11b6c:	adds	r4, #2
   11b6e:	b.n	11b2e <__sccl+0x26>
   11b70:	movs	r2, #1
   11b72:	ldrb	r5, [r1, #1]
   11b74:	mov	r6, r2
   11b76:	adds	r1, #2
   11b78:	b.n	11b16 <__sccl+0xe>
   11b7a:	nop

00011b7c <nanf>:
   11b7c:	vldr	s0, [pc, #4]	; 11b84 <nanf+0x8>
   11b80:	bx	lr
   11b82:	nop
   11b84:	.word	0x7fc00000

00011b88 <_strtoll_l.isra.0>:
   11b88:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11b8c:	sub	sp, #20
   11b8e:	mov	sl, r3
   11b90:	str	r1, [sp, #8]
   11b92:	str	r0, [sp, #12]
   11b94:	str	r2, [sp, #4]
   11b96:	mov	r7, r1
   11b98:	ldr	r6, [sp, #56]	; 0x38
   11b9a:	b.n	11b9e <_strtoll_l.isra.0+0x16>
   11b9c:	mov	r7, r5
   11b9e:	mov	r5, r7
   11ba0:	mov	r0, r6
   11ba2:	ldrb.w	r4, [r5], #1
   11ba6:	bl	b2b8 <__locale_ctype_ptr_l>
   11baa:	add	r0, r4
   11bac:	ldrb	r3, [r0, #1]
   11bae:	and.w	r3, r3, #8
   11bb2:	and.w	r2, r3, #255	; 0xff
   11bb6:	cmp	r3, #0
   11bb8:	bne.n	11b9c <_strtoll_l.isra.0+0x14>
   11bba:	cmp	r4, #45	; 0x2d
   11bbc:	beq.w	11cc6 <_strtoll_l.isra.0+0x13e>
   11bc0:	cmp	r4, #43	; 0x2b
   11bc2:	it	eq
   11bc4:	ldrbeq	r4, [r7, #1]
   11bc6:	str	r2, [sp, #0]
   11bc8:	it	eq
   11bca:	addeq	r5, r7, #2
   11bcc:	cmp.w	sl, #0
   11bd0:	beq.n	11bec <_strtoll_l.isra.0+0x64>
   11bd2:	cmp.w	sl, #16
   11bd6:	beq.w	11d04 <_strtoll_l.isra.0+0x17c>
   11bda:	ldr	r3, [sp, #0]
   11bdc:	mov	r6, sl
   11bde:	asrs	r7, r6, #31
   11be0:	cbnz	r3, 11bfe <_strtoll_l.isra.0+0x76>
   11be2:	mov.w	r8, #4294967295
   11be6:	mvn.w	r9, #2147483648	; 0x80000000
   11bea:	b.n	11c06 <_strtoll_l.isra.0+0x7e>
   11bec:	cmp	r4, #48	; 0x30
   11bee:	beq.n	11cf0 <_strtoll_l.isra.0+0x168>
   11bf0:	movs	r6, #10
   11bf2:	movs	r7, #0
   11bf4:	mov.w	sl, #10
   11bf8:	ldr	r3, [sp, #0]
   11bfa:	cmp	r3, #0
   11bfc:	beq.n	11be2 <_strtoll_l.isra.0+0x5a>
   11bfe:	mov.w	r8, #0
   11c02:	mov.w	r9, #2147483648	; 0x80000000
   11c06:	mov	r2, r6
   11c08:	mov	r3, r7
   11c0a:	mov	r0, r8
   11c0c:	mov	r1, r9
   11c0e:	bl	af04 <__aeabi_uldivmod>
   11c12:	mov	r3, r7
   11c14:	mov	fp, r2
   11c16:	mov	r0, r8
   11c18:	mov	r2, r6
   11c1a:	mov	r1, r9
   11c1c:	bl	af04 <__aeabi_uldivmod>
   11c20:	mov.w	lr, #0
   11c24:	movs	r2, #0
   11c26:	movs	r3, #0
   11c28:	b.n	11c4a <_strtoll_l.isra.0+0xc2>
   11c2a:	beq.n	11cb8 <_strtoll_l.isra.0+0x130>
   11c2c:	mul.w	r4, r2, r7
   11c30:	mla	r4, r6, r3, r4
   11c34:	umull	r2, r3, r2, r6
   11c38:	add	r3, r4
   11c3a:	adds.w	r2, r2, ip
   11c3e:	adc.w	r3, r3, ip, asr #31
   11c42:	mov.w	lr, #1
   11c46:	ldrb.w	r4, [r5], #1
   11c4a:	sub.w	ip, r4, #48	; 0x30
   11c4e:	cmp.w	ip, #9
   11c52:	bls.n	11c62 <_strtoll_l.isra.0+0xda>
   11c54:	sub.w	ip, r4, #65	; 0x41
   11c58:	cmp.w	ip, #25
   11c5c:	bhi.n	11c7a <_strtoll_l.isra.0+0xf2>
   11c5e:	sub.w	ip, r4, #55	; 0x37
   11c62:	cmp	sl, ip
   11c64:	ble.n	11c8c <_strtoll_l.isra.0+0x104>
   11c66:	cmp.w	lr, #4294967295
   11c6a:	beq.n	11c46 <_strtoll_l.isra.0+0xbe>
   11c6c:	cmp	r1, r3
   11c6e:	it	eq
   11c70:	cmpeq	r0, r2
   11c72:	bcs.n	11c2a <_strtoll_l.isra.0+0xa2>
   11c74:	mov.w	lr, #4294967295
   11c78:	b.n	11c46 <_strtoll_l.isra.0+0xbe>
   11c7a:	sub.w	ip, r4, #97	; 0x61
   11c7e:	cmp.w	ip, #25
   11c82:	bhi.n	11c8c <_strtoll_l.isra.0+0x104>
   11c84:	sub.w	ip, r4, #87	; 0x57
   11c88:	cmp	sl, ip
   11c8a:	bgt.n	11c66 <_strtoll_l.isra.0+0xde>
   11c8c:	cmp.w	lr, #4294967295
   11c90:	beq.n	11cd0 <_strtoll_l.isra.0+0x148>
   11c92:	ldr	r1, [sp, #0]
   11c94:	cbz	r1, 11c9c <_strtoll_l.isra.0+0x114>
   11c96:	negs	r2, r2
   11c98:	sbc.w	r3, r3, r3, lsl #1
   11c9c:	ldr	r1, [sp, #4]
   11c9e:	cmp	r1, #0
   11ca0:	beq.n	11d28 <_strtoll_l.isra.0+0x1a0>
   11ca2:	cmp.w	lr, #0
   11ca6:	bne.n	11ce8 <_strtoll_l.isra.0+0x160>
   11ca8:	ldr	r5, [sp, #8]
   11caa:	mov	r0, r2
   11cac:	mov	r1, r3
   11cae:	ldr	r3, [sp, #4]
   11cb0:	str	r5, [r3, #0]
   11cb2:	add	sp, #20
   11cb4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11cb8:	cmp	fp, ip
   11cba:	bge.n	11c2c <_strtoll_l.isra.0+0xa4>
   11cbc:	mov	r2, r0
   11cbe:	mov	r3, r1
   11cc0:	mov.w	lr, #4294967295
   11cc4:	b.n	11c46 <_strtoll_l.isra.0+0xbe>
   11cc6:	movs	r3, #1
   11cc8:	adds	r5, r7, #2
   11cca:	ldrb	r4, [r7, #1]
   11ccc:	str	r3, [sp, #0]
   11cce:	b.n	11bcc <_strtoll_l.isra.0+0x44>
   11cd0:	ldr	r3, [sp, #0]
   11cd2:	cbnz	r3, 11d20 <_strtoll_l.isra.0+0x198>
   11cd4:	mov.w	r0, #4294967295
   11cd8:	mvn.w	r1, #2147483648	; 0x80000000
   11cdc:	ldr	r2, [sp, #12]
   11cde:	movs	r3, #34	; 0x22
   11ce0:	str	r3, [r2, #0]
   11ce2:	ldr	r3, [sp, #4]
   11ce4:	cbnz	r3, 11cec <_strtoll_l.isra.0+0x164>
   11ce6:	b.n	11cb2 <_strtoll_l.isra.0+0x12a>
   11ce8:	mov	r0, r2
   11cea:	mov	r1, r3
   11cec:	subs	r5, #1
   11cee:	b.n	11cae <_strtoll_l.isra.0+0x126>
   11cf0:	ldrb	r3, [r5, #0]
   11cf2:	and.w	r3, r3, #223	; 0xdf
   11cf6:	cmp	r3, #88	; 0x58
   11cf8:	beq.n	11d12 <_strtoll_l.isra.0+0x18a>
   11cfa:	movs	r6, #8
   11cfc:	movs	r7, #0
   11cfe:	mov.w	sl, #8
   11d02:	b.n	11bf8 <_strtoll_l.isra.0+0x70>
   11d04:	cmp	r4, #48	; 0x30
   11d06:	bne.n	11d2e <_strtoll_l.isra.0+0x1a6>
   11d08:	ldrb	r3, [r5, #0]
   11d0a:	and.w	r3, r3, #223	; 0xdf
   11d0e:	cmp	r3, #88	; 0x58
   11d10:	bne.n	11d2e <_strtoll_l.isra.0+0x1a6>
   11d12:	ldrb	r4, [r5, #1]
   11d14:	movs	r6, #16
   11d16:	movs	r7, #0
   11d18:	adds	r5, #2
   11d1a:	mov.w	sl, #16
   11d1e:	b.n	11bf8 <_strtoll_l.isra.0+0x70>
   11d20:	movs	r0, #0
   11d22:	mov.w	r1, #2147483648	; 0x80000000
   11d26:	b.n	11cdc <_strtoll_l.isra.0+0x154>
   11d28:	mov	r0, r2
   11d2a:	mov	r1, r3
   11d2c:	b.n	11cb2 <_strtoll_l.isra.0+0x12a>
   11d2e:	movs	r6, #16
   11d30:	movs	r7, #0
   11d32:	b.n	11bf8 <_strtoll_l.isra.0+0x70>

00011d34 <_strtoll_r>:
   11d34:	push	{r4, r5, lr}
   11d36:	ldr	r4, [pc, #24]	; (11d50 <_strtoll_r+0x1c>)
   11d38:	ldr	r5, [pc, #24]	; (11d54 <_strtoll_r+0x20>)
   11d3a:	ldr	r4, [r4, #0]
   11d3c:	ldr	r4, [r4, #52]	; 0x34
   11d3e:	sub	sp, #12
   11d40:	cmp	r4, #0
   11d42:	it	eq
   11d44:	moveq	r4, r5
   11d46:	str	r4, [sp, #0]
   11d48:	bl	11b88 <_strtoll_l.isra.0>
   11d4c:	add	sp, #12
   11d4e:	pop	{r4, r5, pc}
   11d50:	.word	0x1fff1848
   11d54:	.word	0x1fff184c

00011d58 <_strtoul_l.isra.0>:
   11d58:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11d5c:	ldr.w	r9, [sp, #40]	; 0x28
   11d60:	mov	r6, r1
   11d62:	mov	r7, r0
   11d64:	mov	r5, r2
   11d66:	mov	r8, r3
   11d68:	mov	fp, r1
   11d6a:	b.n	11d6e <_strtoul_l.isra.0+0x16>
   11d6c:	mov	fp, r4
   11d6e:	mov	r4, fp
   11d70:	mov	r0, r9
   11d72:	ldrb.w	sl, [r4], #1
   11d76:	bl	b2b8 <__locale_ctype_ptr_l>
   11d7a:	add	r0, sl
   11d7c:	ldrb	r0, [r0, #1]
   11d7e:	and.w	r0, r0, #8
   11d82:	and.w	ip, r0, #255	; 0xff
   11d86:	cmp	r0, #0
   11d88:	bne.n	11d6c <_strtoul_l.isra.0+0x14>
   11d8a:	mov	r1, sl
   11d8c:	cmp	r1, #45	; 0x2d
   11d8e:	beq.n	11e54 <_strtoul_l.isra.0+0xfc>
   11d90:	cmp	r1, #43	; 0x2b
   11d92:	itt	eq
   11d94:	ldrbeq.w	r1, [fp, #1]
   11d98:	addeq.w	r4, fp, #2
   11d9c:	cmp.w	r8, #0
   11da0:	beq.n	11dbc <_strtoul_l.isra.0+0x64>
   11da2:	cmp.w	r8, #16
   11da6:	beq.n	11e62 <_strtoul_l.isra.0+0x10a>
   11da8:	mov.w	r3, #4294967295
   11dac:	udiv	r3, r3, r8
   11db0:	mul.w	sl, r8, r3
   11db4:	mvn.w	sl, sl
   11db8:	mov	r9, r8
   11dba:	b.n	11dcc <_strtoul_l.isra.0+0x74>
   11dbc:	cmp	r1, #48	; 0x30
   11dbe:	beq.n	11e84 <_strtoul_l.isra.0+0x12c>
   11dc0:	mov.w	r8, #10
   11dc4:	ldr	r3, [pc, #244]	; (11ebc <_strtoul_l.isra.0+0x164>)
   11dc6:	mov	r9, r8
   11dc8:	mov.w	sl, #5
   11dcc:	mov.w	lr, #0
   11dd0:	mov	r0, lr
   11dd2:	b.n	11de2 <_strtoul_l.isra.0+0x8a>
   11dd4:	beq.n	11e36 <_strtoul_l.isra.0+0xde>
   11dd6:	mla	r0, r9, r0, r2
   11dda:	mov.w	lr, #1
   11dde:	ldrb.w	r1, [r4], #1
   11de2:	sub.w	r2, r1, #48	; 0x30
   11de6:	cmp	r2, #9
   11de8:	bls.n	11df6 <_strtoul_l.isra.0+0x9e>
   11dea:	sub.w	r2, r1, #65	; 0x41
   11dee:	cmp	r2, #25
   11df0:	bhi.n	11e0a <_strtoul_l.isra.0+0xb2>
   11df2:	sub.w	r2, r1, #55	; 0x37
   11df6:	cmp	r8, r2
   11df8:	ble.n	11e1a <_strtoul_l.isra.0+0xc2>
   11dfa:	cmp.w	lr, #4294967295
   11dfe:	beq.n	11dde <_strtoul_l.isra.0+0x86>
   11e00:	cmp	r0, r3
   11e02:	bls.n	11dd4 <_strtoul_l.isra.0+0x7c>
   11e04:	mov.w	lr, #4294967295
   11e08:	b.n	11dde <_strtoul_l.isra.0+0x86>
   11e0a:	sub.w	r2, r1, #97	; 0x61
   11e0e:	cmp	r2, #25
   11e10:	bhi.n	11e1a <_strtoul_l.isra.0+0xc2>
   11e12:	sub.w	r2, r1, #87	; 0x57
   11e16:	cmp	r8, r2
   11e18:	bgt.n	11dfa <_strtoul_l.isra.0+0xa2>
   11e1a:	cmp.w	lr, #4294967295
   11e1e:	beq.n	11e44 <_strtoul_l.isra.0+0xec>
   11e20:	cmp.w	ip, #0
   11e24:	beq.n	11e28 <_strtoul_l.isra.0+0xd0>
   11e26:	negs	r0, r0
   11e28:	cbz	r5, 11e40 <_strtoul_l.isra.0+0xe8>
   11e2a:	cmp.w	lr, #0
   11e2e:	bne.n	11e4c <_strtoul_l.isra.0+0xf4>
   11e30:	str	r6, [r5, #0]
   11e32:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11e36:	cmp	r2, sl
   11e38:	ble.n	11dd6 <_strtoul_l.isra.0+0x7e>
   11e3a:	mov.w	lr, #4294967295
   11e3e:	b.n	11dde <_strtoul_l.isra.0+0x86>
   11e40:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11e44:	movs	r3, #34	; 0x22
   11e46:	str	r3, [r7, #0]
   11e48:	mov	r0, lr
   11e4a:	cbz	r5, 11e9e <_strtoul_l.isra.0+0x146>
   11e4c:	subs	r6, r4, #1
   11e4e:	str	r6, [r5, #0]
   11e50:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11e54:	add.w	r4, fp, #2
   11e58:	ldrb.w	r1, [fp, #1]
   11e5c:	mov.w	ip, #1
   11e60:	b.n	11d9c <_strtoul_l.isra.0+0x44>
   11e62:	cmp	r1, #48	; 0x30
   11e64:	bne.n	11ea2 <_strtoul_l.isra.0+0x14a>
   11e66:	ldrb	r3, [r4, #0]
   11e68:	and.w	r3, r3, #223	; 0xdf
   11e6c:	cmp	r3, #88	; 0x58
   11e6e:	bne.n	11eae <_strtoul_l.isra.0+0x156>
   11e70:	mov.w	r9, #16
   11e74:	ldrb	r1, [r4, #1]
   11e76:	mov	r8, r9
   11e78:	mov.w	sl, #15
   11e7c:	adds	r4, #2
   11e7e:	mvn.w	r3, #4026531840	; 0xf0000000
   11e82:	b.n	11dcc <_strtoul_l.isra.0+0x74>
   11e84:	ldrb	r3, [r4, #0]
   11e86:	and.w	r3, r3, #223	; 0xdf
   11e8a:	cmp	r3, #88	; 0x58
   11e8c:	beq.n	11e70 <_strtoul_l.isra.0+0x118>
   11e8e:	mov.w	r8, #8
   11e92:	mov	r9, r8
   11e94:	mov.w	sl, #7
   11e98:	mvn.w	r3, #3758096384	; 0xe0000000
   11e9c:	b.n	11dcc <_strtoul_l.isra.0+0x74>
   11e9e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11ea2:	mov.w	sl, #15
   11ea6:	mvn.w	r3, #4026531840	; 0xf0000000
   11eaa:	mov	r9, r8
   11eac:	b.n	11dcc <_strtoul_l.isra.0+0x74>
   11eae:	mov	r9, r8
   11eb0:	mov.w	sl, #15
   11eb4:	mvn.w	r3, #4026531840	; 0xf0000000
   11eb8:	b.n	11dcc <_strtoul_l.isra.0+0x74>
   11eba:	nop
   11ebc:	.word	0x19999999

00011ec0 <_strtoul_r>:
   11ec0:	push	{r4, r5, lr}
   11ec2:	ldr	r4, [pc, #24]	; (11edc <_strtoul_r+0x1c>)
   11ec4:	ldr	r5, [pc, #24]	; (11ee0 <_strtoul_r+0x20>)
   11ec6:	ldr	r4, [r4, #0]
   11ec8:	ldr	r4, [r4, #52]	; 0x34
   11eca:	sub	sp, #12
   11ecc:	cmp	r4, #0
   11ece:	it	eq
   11ed0:	moveq	r4, r5
   11ed2:	str	r4, [sp, #0]
   11ed4:	bl	11d58 <_strtoul_l.isra.0>
   11ed8:	add	sp, #12
   11eda:	pop	{r4, r5, pc}
   11edc:	.word	0x1fff1848
   11ee0:	.word	0x1fff184c

00011ee4 <_strtoull_l.isra.0>:
   11ee4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11ee8:	sub	sp, #20
   11eea:	mov	fp, r1
   11eec:	str	r0, [sp, #8]
   11eee:	mov	r7, r2
   11ef0:	mov	r6, r3
   11ef2:	mov	r8, r1
   11ef4:	ldr	r4, [sp, #56]	; 0x38
   11ef6:	b.n	11efa <_strtoull_l.isra.0+0x16>
   11ef8:	mov	r8, r5
   11efa:	mov	r5, r8
   11efc:	mov	r0, r4
   11efe:	ldrb.w	r9, [r5], #1
   11f02:	bl	b2b8 <__locale_ctype_ptr_l>
   11f06:	add	r0, r9
   11f08:	ldrb	r3, [r0, #1]
   11f0a:	and.w	r3, r3, #8
   11f0e:	and.w	r2, r3, #255	; 0xff
   11f12:	cmp	r3, #0
   11f14:	bne.n	11ef8 <_strtoull_l.isra.0+0x14>
   11f16:	mov	r4, r9
   11f18:	cmp	r4, #45	; 0x2d
   11f1a:	beq.w	12036 <_strtoull_l.isra.0+0x152>
   11f1e:	cmp	r4, #43	; 0x2b
   11f20:	it	eq
   11f22:	ldrbeq.w	r4, [r8, #1]
   11f26:	str	r2, [sp, #4]
   11f28:	it	eq
   11f2a:	addeq.w	r5, r8, #2
   11f2e:	cbz	r6, 11f68 <_strtoull_l.isra.0+0x84>
   11f30:	cmp	r6, #16
   11f32:	beq.w	12044 <_strtoull_l.isra.0+0x160>
   11f36:	mov.w	r9, r6, asr #31
   11f3a:	mov	r2, r6
   11f3c:	mov	r3, r9
   11f3e:	mov.w	r0, #4294967295
   11f42:	mov.w	r1, #4294967295
   11f46:	bl	af04 <__aeabi_uldivmod>
   11f4a:	mov	r2, r6
   11f4c:	str	r0, [sp, #12]
   11f4e:	mov	sl, r1
   11f50:	mov	r3, r9
   11f52:	mov.w	r0, #4294967295
   11f56:	mov.w	r1, #4294967295
   11f5a:	bl	af04 <__aeabi_uldivmod>
   11f5e:	mov	r8, r6
   11f60:	mov	lr, r2
   11f62:	ldr	r2, [sp, #12]
   11f64:	mov	r3, sl
   11f66:	b.n	11f82 <_strtoull_l.isra.0+0x9e>
   11f68:	cmp	r4, #48	; 0x30
   11f6a:	beq.w	12070 <_strtoull_l.isra.0+0x18c>
   11f6e:	ldr	r3, [pc, #348]	; (120cc <_strtoull_l.isra.0+0x1e8>)
   11f70:	mov.w	lr, #5
   11f74:	mov.w	r2, #2576980377	; 0x99999999
   11f78:	mov.w	r8, #10
   11f7c:	mov.w	r9, #0
   11f80:	movs	r6, #10
   11f82:	mov.w	ip, #0
   11f86:	movs	r0, #0
   11f88:	movs	r1, #0
   11f8a:	b.n	11fb2 <_strtoull_l.isra.0+0xce>
   11f8c:	cmp	r1, r3
   11f8e:	it	eq
   11f90:	cmpeq	r0, r2
   11f92:	beq.n	12016 <_strtoull_l.isra.0+0x132>
   11f94:	mul.w	r4, r0, r9
   11f98:	mla	r4, r8, r1, r4
   11f9c:	umull	r0, r1, r0, r8
   11fa0:	add	r1, r4
   11fa2:	adds.w	r0, r0, sl
   11fa6:	adc.w	r1, r1, sl, asr #31
   11faa:	mov.w	ip, #1
   11fae:	ldrb.w	r4, [r5], #1
   11fb2:	sub.w	sl, r4, #48	; 0x30
   11fb6:	cmp.w	sl, #9
   11fba:	bls.n	11fca <_strtoull_l.isra.0+0xe6>
   11fbc:	sub.w	sl, r4, #65	; 0x41
   11fc0:	cmp.w	sl, #25
   11fc4:	bhi.n	11fe2 <_strtoull_l.isra.0+0xfe>
   11fc6:	sub.w	sl, r4, #55	; 0x37
   11fca:	cmp	r6, sl
   11fcc:	ble.n	11ff4 <_strtoull_l.isra.0+0x110>
   11fce:	cmp.w	ip, #4294967295
   11fd2:	beq.n	11fae <_strtoull_l.isra.0+0xca>
   11fd4:	cmp	r3, r1
   11fd6:	it	eq
   11fd8:	cmpeq	r2, r0
   11fda:	bcs.n	11f8c <_strtoull_l.isra.0+0xa8>
   11fdc:	mov.w	ip, #4294967295
   11fe0:	b.n	11fae <_strtoull_l.isra.0+0xca>
   11fe2:	sub.w	sl, r4, #97	; 0x61
   11fe6:	cmp.w	sl, #25
   11fea:	bhi.n	11ff4 <_strtoull_l.isra.0+0x110>
   11fec:	sub.w	sl, r4, #87	; 0x57
   11ff0:	cmp	r6, sl
   11ff2:	bgt.n	11fce <_strtoull_l.isra.0+0xea>
   11ff4:	cmp.w	ip, #4294967295
   11ff8:	beq.n	12020 <_strtoull_l.isra.0+0x13c>
   11ffa:	ldr	r3, [sp, #4]
   11ffc:	cbz	r3, 12004 <_strtoull_l.isra.0+0x120>
   11ffe:	negs	r0, r0
   12000:	sbc.w	r1, r1, r1, lsl #1
   12004:	cbz	r7, 12010 <_strtoull_l.isra.0+0x12c>
   12006:	cmp.w	ip, #0
   1200a:	bne.n	12032 <_strtoull_l.isra.0+0x14e>
   1200c:	mov	r5, fp
   1200e:	str	r5, [r7, #0]
   12010:	add	sp, #20
   12012:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12016:	cmp	sl, lr
   12018:	ble.n	11f94 <_strtoull_l.isra.0+0xb0>
   1201a:	mov.w	ip, #4294967295
   1201e:	b.n	11fae <_strtoull_l.isra.0+0xca>
   12020:	ldr	r2, [sp, #8]
   12022:	movs	r3, #34	; 0x22
   12024:	str	r3, [r2, #0]
   12026:	mov.w	r0, #4294967295
   1202a:	mov.w	r1, #4294967295
   1202e:	cmp	r7, #0
   12030:	beq.n	12010 <_strtoull_l.isra.0+0x12c>
   12032:	subs	r5, #1
   12034:	b.n	1200e <_strtoull_l.isra.0+0x12a>
   12036:	movs	r3, #1
   12038:	add.w	r5, r8, #2
   1203c:	ldrb.w	r4, [r8, #1]
   12040:	str	r3, [sp, #4]
   12042:	b.n	11f2e <_strtoull_l.isra.0+0x4a>
   12044:	cmp	r4, #48	; 0x30
   12046:	bne.n	12092 <_strtoull_l.isra.0+0x1ae>
   12048:	ldrb	r3, [r5, #0]
   1204a:	and.w	r3, r3, #223	; 0xdf
   1204e:	cmp	r3, #88	; 0x58
   12050:	bne.n	120a8 <_strtoull_l.isra.0+0x1c4>
   12052:	mov.w	r3, #4294967295
   12056:	ldrb	r4, [r5, #1]
   12058:	str	r3, [sp, #12]
   1205a:	mov.w	lr, #15
   1205e:	adds	r5, #2
   12060:	mvn.w	sl, #4026531840	; 0xf0000000
   12064:	mov.w	r8, #16
   12068:	mov.w	r9, #0
   1206c:	movs	r6, #16
   1206e:	b.n	11f62 <_strtoull_l.isra.0+0x7e>
   12070:	ldrb	r3, [r5, #0]
   12072:	and.w	r3, r3, #223	; 0xdf
   12076:	cmp	r3, #88	; 0x58
   12078:	beq.n	12052 <_strtoull_l.isra.0+0x16e>
   1207a:	mov.w	lr, #7
   1207e:	mov.w	r2, #4294967295
   12082:	mvn.w	r3, #3758096384	; 0xe0000000
   12086:	mov.w	r8, #8
   1208a:	mov.w	r9, #0
   1208e:	movs	r6, #8
   12090:	b.n	11f82 <_strtoull_l.isra.0+0x9e>
   12092:	mov.w	lr, #15
   12096:	mov.w	r2, #4294967295
   1209a:	mvn.w	r3, #4026531840	; 0xf0000000
   1209e:	mov.w	r8, #16
   120a2:	mov.w	r9, #0
   120a6:	b.n	11f82 <_strtoull_l.isra.0+0x9e>
   120a8:	mov.w	r8, #16
   120ac:	mov.w	r9, #0
   120b0:	mov	r2, r8
   120b2:	mov	r3, r9
   120b4:	mov.w	r0, #4294967295
   120b8:	mov.w	r1, #4294967295
   120bc:	bl	af04 <__aeabi_uldivmod>
   120c0:	mvn.w	r3, #4026531840	; 0xf0000000
   120c4:	mov	lr, r2
   120c6:	mov.w	r2, #4294967295
   120ca:	b.n	11f82 <_strtoull_l.isra.0+0x9e>
   120cc:	.word	0x19999999

000120d0 <_strtoull_r>:
   120d0:	push	{r4, r5, lr}
   120d2:	ldr	r4, [pc, #24]	; (120ec <_strtoull_r+0x1c>)
   120d4:	ldr	r5, [pc, #24]	; (120f0 <_strtoull_r+0x20>)
   120d6:	ldr	r4, [r4, #0]
   120d8:	ldr	r4, [r4, #52]	; 0x34
   120da:	sub	sp, #12
   120dc:	cmp	r4, #0
   120de:	it	eq
   120e0:	moveq	r4, r5
   120e2:	str	r4, [sp, #0]
   120e4:	bl	11ee4 <_strtoull_l.isra.0>
   120e8:	add	sp, #12
   120ea:	pop	{r4, r5, pc}
   120ec:	.word	0x1fff1848
   120f0:	.word	0x1fff184c

000120f4 <__ssprint_r>:
   120f4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   120f8:	ldr	r3, [r2, #8]
   120fa:	sub	sp, #12
   120fc:	mov	r8, r2
   120fe:	cmp	r3, #0
   12100:	beq.n	121e8 <__ssprint_r+0xf4>
   12102:	mov	fp, r0
   12104:	mov.w	r9, #0
   12108:	ldr	r6, [r2, #0]
   1210a:	ldr	r0, [r1, #0]
   1210c:	ldr	r3, [r1, #8]
   1210e:	mov	r5, r1
   12110:	mov	r4, r9
   12112:	cmp	r4, #0
   12114:	beq.n	121a2 <__ssprint_r+0xae>
   12116:	cmp	r4, r3
   12118:	mov	r7, r3
   1211a:	mov	sl, r3
   1211c:	bcc.n	121ac <__ssprint_r+0xb8>
   1211e:	ldrh	r3, [r5, #12]
   12120:	tst.w	r3, #1152	; 0x480
   12124:	beq.n	12182 <__ssprint_r+0x8e>
   12126:	ldr	r7, [r5, #20]
   12128:	ldr	r1, [r5, #16]
   1212a:	add.w	r7, r7, r7, lsl #1
   1212e:	rsb	sl, r1, r0
   12132:	add.w	r7, r7, r7, lsr #31
   12136:	adds	r0, r4, #1
   12138:	asrs	r7, r7, #1
   1213a:	add	r0, sl
   1213c:	cmp	r0, r7
   1213e:	mov	r2, r7
   12140:	itt	hi
   12142:	movhi	r7, r0
   12144:	movhi	r2, r7
   12146:	lsls	r3, r3, #21
   12148:	bpl.n	121b2 <__ssprint_r+0xbe>
   1214a:	mov	r1, r2
   1214c:	mov	r0, fp
   1214e:	bl	b2f4 <_malloc_r>
   12152:	cmp	r0, #0
   12154:	beq.n	121c6 <__ssprint_r+0xd2>
   12156:	mov	r2, sl
   12158:	ldr	r1, [r5, #16]
   1215a:	str	r0, [sp, #4]
   1215c:	bl	8ed0 <memcpy>
   12160:	ldrh	r2, [r5, #12]
   12162:	ldr	r3, [sp, #4]
   12164:	bic.w	r2, r2, #1152	; 0x480
   12168:	orr.w	r2, r2, #128	; 0x80
   1216c:	strh	r2, [r5, #12]
   1216e:	rsb	r2, sl, r7
   12172:	add.w	r0, r3, sl
   12176:	str	r7, [r5, #20]
   12178:	str	r3, [r5, #16]
   1217a:	str	r0, [r5, #0]
   1217c:	str	r2, [r5, #8]
   1217e:	mov	r7, r4
   12180:	mov	sl, r4
   12182:	mov	r2, sl
   12184:	mov	r1, r9
   12186:	bl	b994 <memmove>
   1218a:	ldr.w	r2, [r8, #8]
   1218e:	ldr	r3, [r5, #8]
   12190:	ldr	r0, [r5, #0]
   12192:	subs	r3, r3, r7
   12194:	add	r0, sl
   12196:	subs	r4, r2, r4
   12198:	str	r3, [r5, #8]
   1219a:	str	r0, [r5, #0]
   1219c:	str.w	r4, [r8, #8]
   121a0:	cbz	r4, 121e8 <__ssprint_r+0xf4>
   121a2:	ldr.w	r9, [r6]
   121a6:	ldr	r4, [r6, #4]
   121a8:	adds	r6, #8
   121aa:	b.n	12112 <__ssprint_r+0x1e>
   121ac:	mov	r7, r4
   121ae:	mov	sl, r4
   121b0:	b.n	12182 <__ssprint_r+0x8e>
   121b2:	mov	r0, fp
   121b4:	bl	ba64 <_realloc_r>
   121b8:	mov	r3, r0
   121ba:	cmp	r0, #0
   121bc:	bne.n	1216e <__ssprint_r+0x7a>
   121be:	ldr	r1, [r5, #16]
   121c0:	mov	r0, fp
   121c2:	bl	10850 <_free_r>
   121c6:	movs	r3, #12
   121c8:	str.w	r3, [fp]
   121cc:	ldrh	r3, [r5, #12]
   121ce:	movs	r2, #0
   121d0:	orr.w	r3, r3, #64	; 0x40
   121d4:	mov.w	r0, #4294967295
   121d8:	strh	r3, [r5, #12]
   121da:	str.w	r2, [r8, #8]
   121de:	str.w	r2, [r8, #4]
   121e2:	add	sp, #12
   121e4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   121e8:	movs	r0, #0
   121ea:	str.w	r0, [r8, #4]
   121ee:	add	sp, #12
   121f0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000121f4 <_sungetc_r>:
   121f4:	adds	r3, r1, #1
   121f6:	push	{r4, r5, r6, lr}
   121f8:	beq.n	12232 <_sungetc_r+0x3e>
   121fa:	ldrh	r3, [r2, #12]
   121fc:	ldr	r4, [r2, #48]	; 0x30
   121fe:	bic.w	r3, r3, #32
   12202:	strh	r3, [r2, #12]
   12204:	uxtb	r5, r1
   12206:	cbz	r4, 12238 <_sungetc_r+0x44>
   12208:	mov	r4, r2
   1220a:	ldr	r2, [r2, #4]
   1220c:	ldr	r3, [r4, #52]	; 0x34
   1220e:	cmp	r2, r3
   12210:	mov	r6, r1
   12212:	bge.n	12228 <_sungetc_r+0x34>
   12214:	ldr	r3, [r4, #0]
   12216:	subs	r2, r3, #1
   12218:	str	r2, [r4, #0]
   1221a:	strb.w	r6, [r3, #-1]
   1221e:	ldr	r3, [r4, #4]
   12220:	adds	r3, #1
   12222:	str	r3, [r4, #4]
   12224:	mov	r0, r5
   12226:	pop	{r4, r5, r6, pc}
   12228:	mov	r1, r4
   1222a:	bl	12338 <__submore>
   1222e:	cmp	r0, #0
   12230:	beq.n	12214 <_sungetc_r+0x20>
   12232:	mov.w	r5, #4294967295
   12236:	b.n	12224 <_sungetc_r+0x30>
   12238:	ldr	r0, [r2, #16]
   1223a:	ldr	r3, [r2, #0]
   1223c:	cbz	r0, 1224a <_sungetc_r+0x56>
   1223e:	cmp	r0, r3
   12240:	bcs.n	1224a <_sungetc_r+0x56>
   12242:	ldrb.w	r0, [r3, #-1]
   12246:	cmp	r5, r0
   12248:	beq.n	1226a <_sungetc_r+0x76>
   1224a:	str	r3, [r2, #56]	; 0x38
   1224c:	mov	r3, r2
   1224e:	ldr	r6, [r2, #4]
   12250:	str	r6, [r2, #60]	; 0x3c
   12252:	add.w	r4, r2, #64	; 0x40
   12256:	movs	r0, #3
   12258:	str	r0, [r2, #52]	; 0x34
   1225a:	str	r4, [r2, #48]	; 0x30
   1225c:	strb.w	r1, [r3, #66]!
   12260:	movs	r1, #1
   12262:	str	r3, [r2, #0]
   12264:	str	r1, [r2, #4]
   12266:	mov	r0, r5
   12268:	pop	{r4, r5, r6, pc}
   1226a:	ldr	r1, [r2, #4]
   1226c:	subs	r3, #1
   1226e:	adds	r1, #1
   12270:	str	r3, [r2, #0]
   12272:	str	r1, [r2, #4]
   12274:	b.n	12224 <_sungetc_r+0x30>
   12276:	nop

00012278 <__ssrefill_r>:
   12278:	push	{r4, lr}
   1227a:	mov	r4, r1
   1227c:	ldr	r1, [r1, #48]	; 0x30
   1227e:	cbz	r1, 1229c <__ssrefill_r+0x24>
   12280:	add.w	r3, r4, #64	; 0x40
   12284:	cmp	r1, r3
   12286:	beq.n	1228c <__ssrefill_r+0x14>
   12288:	bl	10850 <_free_r>
   1228c:	ldr	r3, [r4, #60]	; 0x3c
   1228e:	str	r3, [r4, #4]
   12290:	movs	r0, #0
   12292:	str	r0, [r4, #48]	; 0x30
   12294:	cbz	r3, 1229c <__ssrefill_r+0x24>
   12296:	ldr	r3, [r4, #56]	; 0x38
   12298:	str	r3, [r4, #0]
   1229a:	pop	{r4, pc}
   1229c:	ldrh	r3, [r4, #12]
   1229e:	ldr	r2, [r4, #16]
   122a0:	str	r2, [r4, #0]
   122a2:	orr.w	r3, r3, #32
   122a6:	movs	r2, #0
   122a8:	strh	r3, [r4, #12]
   122aa:	str	r2, [r4, #4]
   122ac:	mov.w	r0, #4294967295
   122b0:	pop	{r4, pc}
   122b2:	nop

000122b4 <_sfread_r>:
   122b4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   122b8:	sub	sp, #12
   122ba:	mul.w	r9, r2, r3
   122be:	str	r2, [sp, #4]
   122c0:	mov	sl, r3
   122c2:	ldr	r4, [sp, #48]	; 0x30
   122c4:	cmp.w	r9, #0
   122c8:	beq.n	1231e <_sfread_r+0x6a>
   122ca:	mov	r7, r0
   122cc:	mov	r6, r1
   122ce:	mov	r5, r9
   122d0:	mov.w	r8, #0
   122d4:	b.n	122f6 <_sfread_r+0x42>
   122d6:	ldr	r1, [r4, #0]
   122d8:	bl	8ed0 <memcpy>
   122dc:	ldr	r2, [r4, #0]
   122de:	str.w	r8, [r4, #4]
   122e2:	add	r2, fp
   122e4:	str	r2, [r4, #0]
   122e6:	mov	r1, r4
   122e8:	mov	r0, r7
   122ea:	add	r6, fp
   122ec:	rsb	r5, fp, r5
   122f0:	bl	12278 <__ssrefill_r>
   122f4:	cbnz	r0, 12326 <_sfread_r+0x72>
   122f6:	ldr.w	fp, [r4, #4]
   122fa:	cmp	r5, fp
   122fc:	mov	r0, r6
   122fe:	mov	r2, fp
   12300:	bhi.n	122d6 <_sfread_r+0x22>
   12302:	mov	r2, r5
   12304:	ldr	r1, [r4, #0]
   12306:	bl	8ed0 <memcpy>
   1230a:	ldr	r2, [r4, #4]
   1230c:	ldr	r3, [r4, #0]
   1230e:	subs	r2, r2, r5
   12310:	add	r3, r5
   12312:	mov	r0, sl
   12314:	str	r2, [r4, #4]
   12316:	str	r3, [r4, #0]
   12318:	add	sp, #12
   1231a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1231e:	mov	r0, r9
   12320:	add	sp, #12
   12322:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12326:	ldr	r3, [sp, #4]
   12328:	rsb	r9, r5, r9
   1232c:	udiv	r0, r9, r3
   12330:	add	sp, #12
   12332:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12336:	nop

00012338 <__submore>:
   12338:	add.w	r3, r1, #64	; 0x40
   1233c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12340:	mov	r4, r1
   12342:	ldr	r1, [r1, #48]	; 0x30
   12344:	cmp	r1, r3
   12346:	beq.n	12372 <__submore+0x3a>
   12348:	ldr	r6, [r4, #52]	; 0x34
   1234a:	lsls	r7, r6, #1
   1234c:	mov	r2, r7
   1234e:	bl	ba64 <_realloc_r>
   12352:	mov	r5, r0
   12354:	cbz	r0, 123a8 <__submore+0x70>
   12356:	add.w	r8, r0, r6
   1235a:	mov	r2, r6
   1235c:	mov	r0, r8
   1235e:	mov	r1, r5
   12360:	bl	8ed0 <memcpy>
   12364:	str.w	r8, [r4]
   12368:	str	r5, [r4, #48]	; 0x30
   1236a:	str	r7, [r4, #52]	; 0x34
   1236c:	movs	r0, #0
   1236e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12372:	mov.w	r1, #1024	; 0x400
   12376:	bl	b2f4 <_malloc_r>
   1237a:	cbz	r0, 123a8 <__submore+0x70>
   1237c:	ldrb.w	r3, [r4, #66]	; 0x42
   12380:	str	r0, [r4, #48]	; 0x30
   12382:	mov.w	r2, #1024	; 0x400
   12386:	str	r2, [r4, #52]	; 0x34
   12388:	strb.w	r3, [r0, #1023]	; 0x3ff
   1238c:	ldrb.w	r3, [r4, #65]	; 0x41
   12390:	strb.w	r3, [r0, #1022]	; 0x3fe
   12394:	ldrb.w	r3, [r4, #64]	; 0x40
   12398:	strb.w	r3, [r0, #1021]	; 0x3fd
   1239c:	addw	r0, r0, #1021	; 0x3fd
   123a0:	str	r0, [r4, #0]
   123a2:	movs	r0, #0
   123a4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   123a8:	mov.w	r0, #4294967295
   123ac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000123b0 <_vasnprintf_r>:
   123b0:	push	{r4, r5, r6, lr}
   123b2:	mov	r5, r2
   123b4:	sub	sp, #104	; 0x68
   123b6:	ldr	r4, [r2, #0]
   123b8:	cbz	r1, 123be <_vasnprintf_r+0xe>
   123ba:	cmp	r4, #0
   123bc:	bne.n	123f4 <_vasnprintf_r+0x44>
   123be:	movs	r4, #0
   123c0:	mov.w	r2, #648	; 0x288
   123c4:	strh.w	r2, [sp, #12]
   123c8:	str	r4, [sp, #0]
   123ca:	str	r4, [sp, #16]
   123cc:	mov	r2, r3
   123ce:	movw	r6, #65535	; 0xffff
   123d2:	ldr	r3, [sp, #120]	; 0x78
   123d4:	str	r4, [sp, #8]
   123d6:	mov	r1, sp
   123d8:	str	r4, [sp, #20]
   123da:	strh.w	r6, [sp, #14]
   123de:	bl	d150 <_svfprintf_r>
   123e2:	cmp	r0, #0
   123e4:	blt.n	1240a <_vasnprintf_r+0x5a>
   123e6:	ldr	r3, [sp, #0]
   123e8:	str	r0, [r5, #0]
   123ea:	movs	r2, #0
   123ec:	strb	r2, [r3, #0]
   123ee:	ldr	r0, [sp, #16]
   123f0:	add	sp, #104	; 0x68
   123f2:	pop	{r4, r5, r6, pc}
   123f4:	mov.w	r2, #1544	; 0x608
   123f8:	str	r1, [sp, #0]
   123fa:	str	r1, [sp, #16]
   123fc:	strh.w	r2, [sp, #12]
   12400:	bge.n	123cc <_vasnprintf_r+0x1c>
   12402:	movs	r3, #139	; 0x8b
   12404:	str	r3, [r0, #0]
   12406:	movs	r0, #0
   12408:	b.n	123f0 <_vasnprintf_r+0x40>
   1240a:	movs	r0, #0
   1240c:	b.n	123f0 <_vasnprintf_r+0x40>
   1240e:	nop

00012410 <_calloc_r>:
   12410:	push	{r4, lr}
   12412:	mul.w	r1, r2, r1
   12416:	bl	b2f4 <_malloc_r>
   1241a:	mov	r4, r0
   1241c:	cbz	r0, 12456 <_calloc_r+0x46>
   1241e:	ldr.w	r2, [r0, #-4]
   12422:	bic.w	r2, r2, #3
   12426:	subs	r2, #4
   12428:	cmp	r2, #36	; 0x24
   1242a:	bhi.n	1245e <_calloc_r+0x4e>
   1242c:	cmp	r2, #19
   1242e:	bls.n	1245a <_calloc_r+0x4a>
   12430:	movs	r3, #0
   12432:	cmp	r2, #27
   12434:	str	r3, [r0, #0]
   12436:	str	r3, [r0, #4]
   12438:	bls.n	12468 <_calloc_r+0x58>
   1243a:	cmp	r2, #36	; 0x24
   1243c:	str	r3, [r0, #8]
   1243e:	str	r3, [r0, #12]
   12440:	iteee	ne
   12442:	addne.w	r2, r0, #16
   12446:	streq	r3, [r0, #16]
   12448:	streq	r3, [r0, #20]
   1244a:	addeq.w	r2, r0, #24
   1244e:	movs	r3, #0
   12450:	str	r3, [r2, #0]
   12452:	str	r3, [r2, #4]
   12454:	str	r3, [r2, #8]
   12456:	mov	r0, r4
   12458:	pop	{r4, pc}
   1245a:	mov	r2, r0
   1245c:	b.n	1244e <_calloc_r+0x3e>
   1245e:	movs	r1, #0
   12460:	bl	9078 <memset>
   12464:	mov	r0, r4
   12466:	pop	{r4, pc}
   12468:	add.w	r2, r0, #8
   1246c:	b.n	1244e <_calloc_r+0x3e>
   1246e:	nop
   12470:	.word	0x25206425
   12474:	.word	0x64252064
   12478:	.short	0x000a
   1247a:	.short	0x6162
   1247c:	.word	0x20636973
   12480:	.word	0x6e756f53
   12484:	.word	0x65522064
   12488:	.word	0x64726f63
   1248c:	.word	0x56207265
   12490:	.word	0x69737265
   12494:	.word	0x203a6e6f
   12498:	.word	0x20626546
   1249c:	.word	0x32203920
   124a0:	.word	0x20323230
   124a4:	.word	0x313a3830
   124a8:	.word	0x39303a37
   124ac:	.word	0x646e4500
   124b0:	.word	0x20666f20
   124b4:	.word	0x75746553
   124b8:	.word	0x4c0a0070
   124bc:	.word	0x3a706f6f
   124c0:	.word	0x3a200020
   124c4:	.word	0xffff0020

000124c8 <vtable for Stream>:
	...
   124d0:	....O...........
   124e0:	............

000124ec <vtable for StreamFile<FsBaseFile, unsigned long long>>:
	...
   124f4:	3...).......Q...
   12504:	m.......g...

00012510 <vtable for FsFile>:
	...
   12518:	3...).......Q...
   12528:	m.......g...

00012534 <vtable for File>:
	...
   1253c:	1...............
   1254c:	................
   1255c:	....

00012560 <vtable for SDFile>:
	...
   12568:	....1.......K...
   12578:	w...q...[...Y...
   12588:	................
   12598:	E...............
   125a8:	....M...........
   125b8:	..../Config.txt.
   125c8:	%10d.... Menu. '
   125d8:	:h'  : print hel
   125e8:	p. ':s'  : start
   125f8:	 acquisition. ':
   12608:	e'  : stop acqui
   12618:	sition. ':w'  : 
   12628:	write parameters
   12638:	 to microSD card
   12648:	. ':l'  : list d
   12658:	isks. ':r'  : re
   12668:	set MTP. ':b'  :
   12678:	 reboot CPU. '?p
   12688:	'  : show all pa
   12698:	rameters. '?d'  
   126a8:	: get date. '?t'
   126b8:	  : get time. '?
   126c8:	a'  : get file d
   126d8:	uration (s). '!d
   126e8:	 yyyy/mm/dd<cr>'
   126f8:	  : set date. '!
   12708:	t hh:mm:ss<cr>' 
   12718:	   : set time. '
   12728:	!a val<cr>'  : s
   12738:	et file duration
   12748:	 (s).CVAS_V3 Ver
   12758:	sion: Feb  9 202
   12768:	2 08:17:09.Teens
   12778:	y: %d: %06x..Dat
   12788:	e d = %04d/%02d/
   12798:	%02d..Time t = %
   127a8:	02d:%02d:%02d..T
   127b8:	_acq a = %d..%d%
   127c8:	c%d%c%d.start.st
   127d8:	op.rebooting CPU
	...

000127e9 <monthDays>:
   127e9:	...............

000127f8 <vtable for MySpiClass>:
	...
   12800:	....}...........
   12810:	Y.......E.......
   12820:	No spi storage.S
   12830:	torage %d %d %s 
   12840:	.%d %d.D./%s%06x
   12850:	_%04d%02d%02d/%0
   12860:	2d/./%s%06x_%04d
   12870:	%02d%02d/%02d_%0
   12880:	2d/.F.%s_%02d%02
   12890:	d%02d.bin.Failin
   128a0:	g open file.WMXZ
   128b0:	.%s%04d%02d%02d_
   128c0:	%02d%02d%02d.sd1
   128d0:	.No I2C address 
   128e0:	found...

000128e8 <TwoWire::i2c0_hardware>:
   128e8:	4..@@.....".0...
   128f8:	....!./.........

00012908 <TwoWire::i2c1_hardware>:
   12908:	4..@....&:......
   12918:	..%;............

00012928 <TwoWire::i2c2_hardware>:
   12928:	(..@@...........
   12938:	............J...

00012948 <vtable for TwoWire>:
	...
   12950:	.%...%.......%..
   12960:	Q%..]%..{%..

0001296c <SPISettings::ctar_div_table>:
   1296c:	................
   1297c:	...... .(.8.@.`.
   1298c:	................

0001299c <SPIClass::spi0_hardware>:
   1299c:	<..@............
   129ac:	.....0....'.....
   129bc:	................
   129cc:	................
   129dc:	................
   129ec:	..........-.....
   129fc:	................
   12a0c:	................
   12a1c:	................
   12a2c:	.. .

00012a30 <SPISettings::ctar_clock_table>:
   12a30:	................
   12a40:	................
   12a50:	. ....... ...0..
   12a60:	. ... ...@...@..
   12a70:	.P...P...`...`..
   12a80:	.p...`...p..

00012a8c <vtable for SDClass>:
	...
   12a94:	5....0...1...1..
   12aa4:	;1...0..m2..G2..
   12ab4:	c3...3..

00012abc <FsGetPartitionInfo::mbdpGuid>:
   12abc:	......3D..h..&..
   12acc:	EFI PART..

00012ad6 <lookupTable>:
   12ad6:	..x...C.........
   12ae6:	..............=.
   12af6:	.. .............
   12b06:	................
   12b16:	................
   12b26:	....:.e,<.;.>.f,
   12b36:	B.A.S...T...V...
   12b46:	W...Y...[...`...
   12b56:	c...h...i...k.b,
   12b66:	o...r...u...}.d,
   12b76:	..............D.
   12b86:	..........E.....
   12b96:	{...|...}.......
   12ba6:	................
   12bb6:	................
   12bc6:	}.c,Q.Y.S.[.U.].
   12bd6:	W._.x...y.......
   12be6:	............N!2!
   12bf6:	.!.!a,`,v,u,

00012c02 <mapTable>:
   12c02:	a..............0
   12c12:	2...9...J...y...
   12c22:	................
   12c32:	.......("...F...
   12c42:	................
   12c52:	0.. P...`.."...6
   12c62:	.......Da..&....
   12c72:	...Z........ ...
   12c82:	0...@...`...p.J.
   12c92:	r.V.v.d.z.p.|.~.
   12ca2:	................
   12cb2:	........p!...$..
   12cc2:	0,./g,...,.d.-.&
   12cd2:	A...Device is to
   12ce2:	o small...Writin
   12cf2:	g FAT ...Writing
   12d02:	 upcase table...
   12d12:	Writing root...F
   12d22:	ormat done...For
   12d32:	mat failed...EXF
   12d42:	AT.Bad cluster c
   12d52:	ount...Card is t
   12d62:	oo small....Form
   12d72:	at Done...Format
   12d82:	 Failed...

00012d8c <vtable for SdSpiCard>:
	...
   12d94:	.v...v...w...v..
   12da4:	K|...|...v..M}..
   12db4:	....Gx...x...}..
   12dc4:	.v...v...|...|..
   12dd4:	.{.......v...~..
   12de4:	i}..+~..

00012dec <vtable for SdioCard>:
	...
   12df4:	....A...a...!...
   12e04:	}...........E...
   12e14:	....E...........
   12e24:	y...............
   12e34:	........Q...=...
   12e44:	........

00012e4c <digital_pin_to_info_PGM>:
   12e4c:	@..C@..@D..CD..@
   12e5c:	...C...@0..C0..@
   12e6c:	4..C4..@...C...@
   12e7c:	...C...@...C...@
   12e8c:	...C...@...C...@
   12e9c:	...C...@...C...@
   12eac:	...C...@...C...@
   12ebc:	...C...@...C...@
   12ecc:	...C...@...C...@
   12edc:	...C...@...C...@
   12eec:	...C...@...C...@
   12efc:	...C...@...C...@
   12f0c:	h .Ch..@...C...@
   12f1c:	8..C8..@<..C<..@
   12f2c:	@..C@..@H..CH..@
   12f3c:	L..CL..@(..C(..@
   12f4c:	,..C,..@` .C`..@
   12f5c:	d .Cd..@ ..C ..@
   12f6c:	$..C$..@(..C(..@
   12f7c:	,..C,..@D..CD..@
   12f8c:	p..Cp..@t..Ct..@
   12f9c:	h..Ch..@P..CP..@
   12fac:	X..CX..@\..C\..@
   12fbc:	T..CT..@ ..C ..@
   12fcc:	$..C$..@...C...@
   12fdc:	...C...@8..C8..@
   12fec:	4..C4..@0..C0..@
   12ffc:	<..C<..@,..C,..@
   1300c:	( .C(..@, .C,..@
   1301c:	. .C...@. .C...@
   1302c:	. .C...@. .C...@
   1303c:	. .C...@. .C...@

0001304c <vtable for usb_serial_class>:
	...
   13054:	I...A...=...9...
   13064:	5...1...-...)...
   13074:	..

00013076 <usb_endpoint_config_table>:
   13076:	......

0001307c <usb_descriptor_list>:
   1307c:	................
   1308c:	....C...........
   1309c:	................
   130ac:	................
   130bc:	................
   130cc:	....

000130d0 <_global_impure_ptr>:
   130d0:	 ...C...POSIX...
   130e0:	....

000130e4 <fpi.6173>:
   130e4:	5...............
   130f4:	....nf..inity...
   13104:	an..

00013108 <fpinan.6209>:
   13108:	4...............
   13118:	........

00013120 <tinytens>:
   13120:	.......<3...#.I9
   13130:	=..D...2......[%
   13140:	Co.d(.h.

00013148 <zeroes.7258>:
   13148:	0000000000000000
   13158:	INF.inf.NAN.nan.
   13168:	0123456789ABCDEF
   13178:	....0123456789ab
   13188:	cdef....(null)..
   13198:	0...

0001319c <blanks.7257>:
   1319c:	                

000131ac <basefix.7328>:
   131ac:	................
   131bc:	................
   131cc:	....e%ld....

000131d8 <_ctype_>:
   131d8:	.         ((((( 
   131e8:	                
   131f8:	 ...............
   13208:	................
   13218:	..AAAAAA........
   13228:	................
   13238:	..BBBBBB........
   13248:	................
   13258:	 ...............
	...
   132d8:	....Infinity....
   132e8:	NaN.

000132ec <__hexdig>:
	...
   1331c:	................
   1332c:	................
	...
   1334c:	................
	...
   133ec:	....

000133f0 <__mprec_tens>:
   133f0:	.......?......$@
   13400:	......Y@.....@.@
   13410:	.......@.....j.@
   13420:	.......A......cA
   13430:	.......A....e..A
   13440:	... _..B....vH7B
   13450:	......mB..@..0.B
   13460:	.......B..4&.k.C
   13470:	...7y.AC....W4vC
   13480:	..Ngm..C.=.`.X.C
   13490:	@..x...DP.....KD
   134a0:	..M....D.J...-.D
   134b0:	...yCx.D

000134b8 <__mprec_bigtens>:
   134b8:	...7y.AC.n.....F
   134c8:	..?..O8M2.0.Hw.Z
   134d8:	<.s..O.u

000134e0 <p05.6087>:
   134e0:	........}...

000134ec <_init>:
   134ec:	push	{r3, r4, r5, r6, r7, lr}
   134ee:	nop
   134f0:	pop	{r3, r4, r5, r6, r7}
   134f2:	pop	{r3}
   134f4:	mov	lr, r3
   134f6:	bx	lr

000134f8 <__init_array_start>:
   134f8:	.word	0x0000f80d

000134fc <__frame_dummy_init_array_entry>:
   134fc:	5...9...."..-%..
   1350c:	.4..

Disassembly of section .fini:

00013510 <_fini>:
   13510:	push	{r3, r4, r5, r6, r7, lr}
   13512:	nop
