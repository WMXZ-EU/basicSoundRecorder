
.vsteensy/build/basicSoundRecorder_T36.elf:     file format elf32-littlearm

SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
00013440 l    d  .fini	00000000 .fini
00013444 l    d  .ARM.exidx	00000000 .ARM.exidx
1fff0000 l    d  .usbdescriptortable	00000000 .usbdescriptortable
1fff0200 l    d  .dmabuffers	00000000 .dmabuffers
1fff0bd0 l    d  .usbbuffers	00000000 .usbbuffers
1fff0f30 l    d  .data	00000000 .data
1fff1dc8 l    d  .bss	00000000 .bss
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 mk20dx128.c
000092f4 l     F .text	0000000c startup_default_early_hook
00009300 l     F .text	00000002 startup_default_late_hook
00000000 l    df *ABS*	00000000 crtstuff.c
00000410 l     F .text	00000000 __do_global_dtors_aux
1fff1dc8 l       .bss	00000000 completed.8605
00000434 l     F .text	00000000 frame_dummy
1fff1dcc l       .bss	00000000 object.8610
0001342c l     O .text	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 acq.cpp
00000628 l     F .text	00000058 acq_isr()
00000680 l     F .text	00000028 _GLOBAL__sub_I_acq_count
1fff0200 l     O .dmabuffers	00000800 tdm_rx_buffer
1fff1dec l     O .bss	00000400 acq_rx_buffer
1fff21ec l     O .bss	00000008 dma
00000000 l    df *ABS*	00000000 main.cpp
1fff21f8 l     O .bss	00000004 checkToCloseFile(short, unsigned long)::to
1fff0f34 l     O .data	00000002 loop::status
1fff21fc l     O .bss	00000004 loop::t0
1fff2204 l     O .bss	00000004 loop::loop_count
00000000 l    df *ABS*	00000000 menu.cpp
00000adc l     F .text	00000024 File::dec_refcount() [clone .isra.15]
00000000 l    df *ABS*	00000000 utils.cpp
00000000 l    df *ABS*	00000000 mTime.cpp
0001271d l     O .text	0000000c monthDays
00000000 l    df *ABS*	00000000 filing.cpp
00001814 l     F .text	00000002 __tcf_0
000018d8 l     F .text	00000024 File::dec_refcount() [clone .isra.23]
000021c8 l     F .text	000000bc _GLOBAL__sub_I_data_buffer
1fff224c l     O .bss	00000004 isd
1fff0f40 l     O .data	00000004 checkDiskSpace()::isd_
2001a254 l     O .bss	00000200 saveData(short)::header
2001a920 l     O .bss	00000050 saveData(short)::fileName
2001a970 l     O .bss	00000004 saveData(short)::dirFlag
2001a980 l     O .bss	00000050 saveData(short)::dirName
2001a9d0 l     O .bss	00001000 dummy_buffer
00000000 l    df *ABS*	00000000 adc.cpp
00002474 l     F .text	00000024 _GLOBAL__sub_I_gain
00000000 l    df *ABS*	00000000 WireKinetis.cpp
0000276e l       .text	00000000 L_1161_delayMicroseconds
0000277c l       .text	00000000 L_1175_delayMicroseconds
000027c4 l       .text	00000000 L_1220_delayMicroseconds
00002a54 l       .text	00000000 L_2399_delayMicroseconds
2001c9e8 l     O .bss	00000001 TwoWire::isr()::receiving
00000000 l    df *ABS*	00000000 SPI.cpp
00002ac4 l     F .text	00000022 DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]
00000000 l    df *ABS*	00000000 SD.cpp
00003364 l     F .text	00000064 _GLOBAL__sub_I_SD
00000000 l    df *ABS*	00000000 FsUtf.cpp
00000000 l    df *ABS*	00000000 FsGetPartitionInfo.cpp
000129f0 l     O .text	00000010 FsGetPartitionInfo::mbdpGuid
00000000 l    df *ABS*	00000000 FsStructs.cpp
00000000 l    df *ABS*	00000000 FsCache.cpp
00000000 l    df *ABS*	00000000 upcase.cpp
00012a0a l     O .text	0000012c lookupTable
00012b36 l     O .text	000000d4 mapTable
00000000 l    df *ABS*	00000000 FsName.cpp
00000000 l    df *ABS*	00000000 ExFatFormatter.cpp
00000000 l    df *ABS*	00000000 ExFatName.cpp
00000000 l    df *ABS*	00000000 ExFatFile.cpp
00000000 l    df *ABS*	00000000 ExFatPartition.cpp
00000000 l    df *ABS*	00000000 ExFatVolume.cpp
00000000 l    df *ABS*	00000000 ExFatFileWrite.cpp
00004bc8 l     F .text	0000002e exFatDirChecksum(unsigned char const*, unsigned short)
00000000 l    df *ABS*	00000000 FatFormatter.cpp
00005510 l     F .text	00000028 initFatDirCallback(unsigned long, void*)
00000000 l    df *ABS*	00000000 FatName.cpp
00000000 l    df *ABS*	00000000 FatFile.cpp
00000000 l    df *ABS*	00000000 FatPartition.cpp
00000000 l    df *ABS*	00000000 FatVolume.cpp
00000000 l    df *ABS*	00000000 FatFileLFN.cpp
00006cb2 l     F .text	0000001e FatFile::lfnChecksum(unsigned char*) [clone .isra.14]
00000000 l    df *ABS*	00000000 FsFile.cpp
00000000 l    df *ABS*	00000000 FsVolume.cpp
00000000 l    df *ABS*	00000000 FsNew.cpp
00000000 l    df *ABS*	00000000 SdSpiCard.cpp
00007690 l     F .text	00000006 SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]
00007696 l     F .text	00000006 SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]
00000000 l    df *ABS*	00000000 SdioTeensy.cpp
00007e78 l     F .text	00000028 sdIrs()
00007ea0 l     F .text	00000018 isBusyCommandComplete()
00007eb8 l     F .text	00000010 isBusyCommandInhibit()
00007ec8 l     F .text	00000014 isBusyDat()
00007edc l     F .text	0000000c isBusyDMA()
00007ee8 l     F .text	00000014 isBusyFifoRead()
00007efc l     F .text	00000014 isBusyFifoWrite()
00007f10 l     F .text	00000018 isBusyTransferComplete()
00007f28 l     F .text	00000098 setSdclk(unsigned long)
00008024 l     F .text	00000024 waitTimeout(bool (*)())
00008048 l     F .text	00000040 yieldTimeout(bool (*)())
000080b8 l     F .text	00000054 cardCommand(unsigned long, unsigned long)
0000810c l     F .text	00000020 statusCMD13()
0000812c l     F .text	00000010 isBusyCMD13()
00008140 l     F .text	00000068 readReg16(unsigned long, void*)
000081a8 l     F .text	00000020 waitDmaStatus() [clone .part.4]
000081c8 l     F .text	0000009c rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)
000083a0 l     F .text	0000005c waitTransferComplete()
0000873c l     F .text	00000098 cardCMD6(unsigned long, unsigned char*)
2001cec4 l     O .bss	00000001 m_version2
2001cec5 l     O .bss	00000010 m_cid
2001ced8 l     O .bss	00000004 m_busyFcn
2001cedc l     O .bss	00000001 m_highCapacity
2001cee0 l     O .bss	00000004 m_ocr
2001cee4 l     O .bss	00000004 m_rca
2001cee8 l     O .bss	00000001 m_transferActive
2001ceec l     O .bss	00000004 m_irqstat
1fff135c l     O .data	00000001 m_errorCode
2001cef0 l     O .bss	00000001 m_initDone
2001cef1 l     O .bss	00000010 m_csd
2001cf01 l     O .bss	00000001 m_dmaBusy
2001cf04 l     O .bss	00000004 m_sdClkKhz
2001cf08 l     O .bss	00000004 m_errorLine
00000000 l    df *ABS*	00000000 memcpy-armv7m.o
00000000 l    df *ABS*	00000000 memset.o
00000000 l    df *ABS*	00000000 usb_serial.c
2001cf0d l     O .bss	00000001 tx_noautoflush
2001cf10 l     O .bss	00000004 tx_packet
2001cf14 l     O .bss	00000001 transmit_previous_timeout
2001cf18 l     O .bss	00000004 rx_packet
00000000 l    df *ABS*	00000000 pins_teensy.c
00009370 l     F .text	00000002 startup_default_middle_hook
00000000 l    df *ABS*	00000000 usb_mem.c
1fff1364 l     O .data	00000004 usb_buffer_available
00000000 l    df *ABS*	00000000 usb_dev.c
0000960c l     F .text	00000040 endpoint0_transmit
2001cf24 l     O .bss	00000004 ep0_tx_ptr
2001cf28 l     O .bss	00000010 rx_last
2001cf38 l     O .bss	00000004 tx_state
2001cf3c l     O .bss	00000040 ep0_rx0_buf
2001cf7c l     O .bss	00000010 rx_first
2001cf8c l     O .bss	00000001 ep0_tx_bdt_bank
2001cf90 l     O .bss	00000040 ep0_rx1_buf
2001cfd0 l     O .bss	00000010 tx_first
1fff0000 l     O .usbdescriptortable	000000a0 table
2001cfe0 l     O .bss	00000010 tx_last
2001cff0 l     O .bss	00000008 setup
2001cff8 l     O .bss	00000002 ep0_tx_len
2001cffb l     O .bss	00000008 reply_buffer
2001d004 l     O .bss	00000001 ep0_tx_data_toggle
00000000 l    df *ABS*	00000000 yield.cpp
2001d005 l     O .bss	00000001 yield::running
00000000 l    df *ABS*	00000000 DMAChannel.cpp
00000000 l    df *ABS*	00000000 EventResponder.cpp
00000000 l    df *ABS*	00000000 usb_inst.cpp
00000000 l    df *ABS*	00000000 Print.cpp
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 Stream.cpp
00000000 l    df *ABS*	00000000 serialEvent.cpp
00000000 l    df *ABS*	00000000 new.cpp
00000000 l    df *ABS*	00000000 analog.c
2001d035 l     O .bss	00000001 calibrating
1fff137d l     O .data	00000001 analog_config_bits
2001d036 l     O .bss	00000001 analog_reference_internal
1fff137e l     O .data	00000001 analog_num_average
00000000 l    df *ABS*	00000000 usb_desc.c
1fff137f l     O .data	00000012 device_descriptor
1fff13aa l     O .data	00000043 config_descriptor
00000000 l    df *ABS*	00000000 nonstd.c
00000000 l    df *ABS*	00000000 atexit_arm.cc
00000000 l    df *ABS*	00000000 _lshrdi3.o
00000000 l    df *ABS*	00000000 _arm_addsubdf3.o
00000000 l    df *ABS*	00000000 _arm_muldivdf3.o
00000000 l    df *ABS*	00000000 _arm_cmpdf2.o
00000000 l    df *ABS*	00000000 _arm_unorddf2.o
00000000 l    df *ABS*	00000000 _arm_fixdfsi.o
00000000 l    df *ABS*	00000000 _arm_fixunsdfsi.o
00000000 l    df *ABS*	00000000 _arm_truncdfsf2.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 cxa_atexit.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 locale.c
0000b1cc l     F .text	00000018 __get_current_locale
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 lib_a-memchr.o
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 sscanf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 lib_a-strlen.o
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strtod.c
0000bffc l     F .text	00000038 sulp
00013018 l     O .text	00000014 fpi.6173
0001303c l     O .text	00000014 fpinan.6209
00013050 l     O .text	00000028 tinytens
00000000 l    df *ABS*	00000000 strtol.c
0000cf30 l     F .text	00000136 _strtol_l.isra.0
00000000 l    df *ABS*	00000000 vfprintf.c
00013078 l     O .text	00000010 zeroes.7258
000130cc l     O .text	00000010 blanks.7257
00000000 l    df *ABS*	00000000 vfscanf.c
000130dc l     O .text	00000022 basefix.7328
00000000 l    df *ABS*	00000000 vdprintf.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0000f74c l     F .text	00000014 register_fini
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 dtoa.c
0000f76c l     F .text	00000128 quorem
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
00010960 l     F .text	000000a8 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 localeconv.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mprec.c
00013410 l     O .text	0000000c p05.6087
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strtoll.c
00011ac8 l     F .text	000001ac _strtoll_l.isra.0
00000000 l    df *ABS*	00000000 strtoul.c
00011c98 l     F .text	00000168 _strtoul_l.isra.0
00000000 l    df *ABS*	00000000 strtoull.c
00011e24 l     F .text	000001ec _strtoull_l.isra.0
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 vfscanf.c
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vasnprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 impure.c
1fff1420 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 ctype_.c
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.19/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crti.o
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.19/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crtn.o
00000000 l    df *ABS*	00000000 FsDateTime.cpp
00000000 l    df *ABS*	00000000 avr_emulation.cpp
00000000 l    df *ABS*	00000000 HardwareSerial.cpp
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 
1fff1dc8 l       .bss	00000000 __bss_start__
2001d084 l       .bss	00000000 __bss_end__
00000000 l       *UND*	00000000 software_init_hook
00000000 l       *UND*	00000000 hardware_init_hook
00000000 l       *UND*	00000000 __stack
00005ba4  w    F .text	00000026 FatPartition::cacheSync()
000092ec  w    F .text	00000006 adc0_isr
000009fa  w    F .text	00000066 SDFile::getModifyTime(DateTimeFields&)
000037b8 g     F .text	000000a4 toUpcase(unsigned short)
00001a78 g     F .text	00000034 pushData(unsigned long*)
0000acf0 g     F .text	0000002c .hidden __aeabi_dcmpun
00009088 g     F .text	0000001c usb_serial_available
00001280 g     F .text	000001b4 menu()
000119e8 g     F .text	0000005e __any_on
0000acb4 g     F .text	00000012 .hidden __aeabi_dcmple
1fff0f48 g     O .data	00000020 fsamps
0000228c  w    F .text	0000004a i2c_class::write16(unsigned char, unsigned short, unsigned short)
00006904 g     F .text	0000002e FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)
0000abf0 g     F .text	0000007a .hidden __cmpdf2
000086c4 g     F .text	00000078 SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)
00009e58  w    F .text	000000d8 yield
1fff1de8 g     O .bss	00000004 acq_miss
00006744 g     F .text	000001c0 FatFile::write(void const*, unsigned int)
0000abf0 g     F .text	0000007a .hidden __eqdf2
00007600  w    F .text	00000002 SdSpiCard::~SdSpiCard()
0000a180 g     F .text	000000a6 Print::printNumber64(unsigned long long, unsigned char, unsigned char)
1fff1392 g     O .data	00000018 usb_string_manufacturer_name_default
000066da g     F .text	00000068 FatFile::truncate()
1fff11e0 g     O .data	0000013c Wire1
000039bc g     F .text	00000458 ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)
2001a97c g     O .bss	00000004 clusterSize
0000a760 g     F .text	0000005a .hidden __floatdidf
000014a4 g     F .text	00000024 newHour()
000092b8  w    F .text	00000034 hard_fault_isr
000092ec  w    F .text	00000006 dma_ch6_isr
000018fc  w    F .text	00000054 MySpiClass::deactivate()
2001ceb4 g     O .bss	00000004 FsDateTime::callback
00002f00  w    F .text	000000d8 SPIClass::dma_rxisr()
0000325a  w    F .text	00000050 SdBase<FsVolume>::restart()
000055e0 g     F .text	0000005c FatFormatter::initPbs()
0000a0c0 g     F .text	00000020 Print::println()
000025f8 g     F .text	00000114 TwoWire::isr()
000092ec  w    F .text	00000006 uart0_lon_isr
00004250 g     F .text	000000d0 ExFatFile::seekSet(unsigned long long)
000096a8 g     F .text	00000078 usb_rx_memory
000075e4  w    F .text	00000004 SdSpiCard::errorCode() const
00000946  w    F .text	0000000c File::flush()
00000994  w    F .text	00000066 SDFile::getCreateTime(DateTimeFields&)
000092ec  w    F .text	00000006 dma_ch8_isr
0000b9b0 g     F .text	00000002 __malloc_unlock
000076b0 g     F .text	00000026 SdSpiCard::spiStart()
00000ef4  w    F .text	00000088 SDFile::openNextFile(unsigned char)
2001cec0 g     O .bss	00000004 FsVolume::m_cwv
000061c8 g     F .text	000000a8 FatFile::open(FatFile*, char const*, int)
1fff222c g     O .bss	00000004 SerNum
0000a2c0 g     F .text	000000b8 analog_init
000018c4  w    F .text	00000014 MySpiClass::begin(SdSpiConfig)
00009720 g     F .text	00000080 usb_tx
0000cf10 g     F .text	00000020 _strtod_r
000092ec  w    F .text	00000006 portcd_isr
00001a48  w    F .text	00000016 MySpiClass::setSckSpeed(unsigned long)
0000f5fc g     F .text	0000004a _vdprintf_r
000062b2 g     F .text	00000020 FatFile::getCreateDateTime(unsigned short*, unsigned short*)
00002c90 g     F .text	000000a4 SPIClass::setSCK(unsigned char)
00001d9c g     F .text	0000042c saveData(short)
0000a434 g     F .text	00000018 .hidden __aeabi_llsr
00012494  w    O .text	0000005c vtable for SDFile
000121f4 g     F .text	00000082 _sfread_r
0000b8e4 g     F .text	000000c6 memmove
0000b208 g     F .text	00000014 __locale_ctype_ptr
00008d2c g     F .text	00000060 SdioCard::stopTransmission(bool)
00011160 g     F .text	0000004c _Balloc
000092ec  w    F .text	00000006 can1_rx_warn_isr
0001344c g       .ARM.exidx	00000000 __exidx_end
000092ec  w    F .text	00000006 dma_error_isr
00003220  w    F .text	0000003a SdBase<FsVolume>::cardBegin(SdSpiConfig)
00006ac2 g     F .text	00000046 FatPartition::freeChain(unsigned long)
2001d018 g     O .bss	00000001 EventResponder::runningFromYield
00007896 g     F .text	0000007c SdSpiCard::cardCommand(unsigned char, unsigned long)
00002aa0 g     F .text	0000000c i2c0_isr
0000175c  w    F .text	0000009c MySpiClass::activate()
0000a096 g     F .text	00000028 Print::write(unsigned char const*, unsigned int)
0000abe0 g     F .text	0000008a .hidden __gtdf2
0000b170 g     F .text	0000000c __errno
00000be8  w    F .text	0000000a SDFile::isDirectory()
00005130 g     F .text	00000112 ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
0000091e  w    F .text	0000000c File::write(unsigned char const*, unsigned int)
000092ec  w    F .text	00000006 portd_isr
00001084 g     F .text	0000001c saveParameters()
000092ec  w    F .text	00000006 enet_error_isr
00007912  w    F .text	0000001e SdSpiCard::cardAcmd(unsigned char, unsigned long)
000022dc g     F .text	00000198 adc_enable()
0001285c g     O .text	00000020 TwoWire::i2c2_hardware
00000b00  w    F .text	0000001c File::~File()
2001d008 g     O .bss	00000004 EventResponder::firstInterrupt
000110e4 g     F .text	00000004 __localeconv_l
00007602  w    F .text	0000000e SdSpiCard::~SdSpiCard()
0000390e g     F .text	0000001c ExFatFormatter::writeUpcaseUnicode(unsigned short)
000004a0 g     F .text	00000028 acq_startClocks()
00007396 g     F .text	00000062 FsBaseFile::FsBaseFile(FsBaseFile const&)
000092ec  w    F .text	00000006 tpm1_isr
00004b5c g     F .text	00000018 ExFatPartition::rootLength()
00000e26  w    F .text	00000036 SDFile::setCreateTime(DateTimeFields const&)
000075e8  w    F .text	00000004 SdSpiCard::errorData() const
0000a088  w    F .text	00000008 usb_serial_class::write(unsigned char const*, unsigned int)
00012d80 g     O .text	00000200 digital_pin_to_info_PGM
00000478 g     F .text	00000028 acq_stopClocks()
2001d080 g     O .bss	00000004 errno
00007ae4 g     F .text	00000038 SdSpiCard::readOCR(unsigned long*)
000048e8 g     F .text	0000003e ExFatPartition::fatGet(unsigned long, unsigned long*)
0000be5c g     F .text	00000004 __seofread
0001344c g       .ARM.exidx	00000000 _etext
00002fd8 g     F .text	00000010 _spi_dma_rxISR0()
00001d38 g     F .text	0000005c listDisks()
1fff1dc8 g       .bss	00000000 _sbss
0000563c g     F .text	0000005c FatFormatter::writeMbr()
00001af0 g     F .text	0000001c sdCsInit(unsigned char)
0000330e g     F .text	00000054 SDClass::mediaPresent()
0000ac7c g     F .text	00000010 .hidden __aeabi_cdcmple
00007fcc g     F .text	0000000c SdioCard::errorData() const
00000c96  w    F .text	00000018 FsBaseFile::peek()
00008604 g     F .text	000000c0 SdioCard::writeSector(unsigned long, unsigned char const*)
000092ec  w    F .text	00000006 porte_isr
00000794 g     F .text	00000184 loop
000092ec  w    F .text	00000006 portb_isr
000092ec  w    F .text	00000006 spi1_isr
000092ec  w    F .text	00000006 uart3_status_isr
00004024 g     F .text	0000007c ExFatFile::parsePathName(char const*, ExName_t*, char const**)
000092ec  w    F .text	00000006 mcm_isr
00008b30 g     F .text	000000c4 SdioCard::readData(unsigned char*)
0000772e g     F .text	00000060 SdSpiCard::readData(unsigned char*, unsigned int)
000027ec g     F .text	000000f8 TwoWire::endTransmission(unsigned char)
2001d00c g     O .bss	00000004 EventResponder::lastInterrupt
000092ec  w    F .text	00000006 uart1_status_isr
000073f8 g     F .text	00000028 FsBaseFile::close()
00008e18 g     F .text	000001a6 memcpy
000092ec  w    F .text	00000006 randnum_isr
00010f48 g     F .text	00000180 __hexnan
0000ac6c g     F .text	00000020 .hidden __aeabi_cdrcmple
0000092a  w    F .text	0000000c File::available()
00001978  w    F .text	00000014 Print::println(unsigned long)
000033c8 g     F .text	00000094 FsUtf::cpToMb(unsigned long, char*, char*)
00000ff4 g     F .text	00000090 storeConfig(unsigned short*, int)
000049ce g     F .text	0000005e ExFatPartition::freeChain(unsigned long)
00005e80 g     F .text	00000028 FatFile::peek()
0000d090 g     F .text	000016e4 _svfprintf_r
0000a6f0 g     F .text	00000022 .hidden __floatsidf
1fff2208  w    O .bss	00000001 SDFile::name()::zeroterm
2001cf20 g     O .bss	00000004 systick_millis_count
0000abe8 g     F .text	00000082 .hidden __ltdf2
0000508a g     F .text	000000a6 ExFatFile::rename(ExFatFile*, char const*)
000092b8  w    F .text	00000034 bus_fault_isr
00000aa0  w    F .text	0000003c SDFile::truncate(unsigned long long)
0000270c g     F .text	000000e0 TwoWire::wait_idle()
000092ec  w    F .text	00000006 watchdog_isr
0000ae4c g     F .text	00000000 .hidden __aeabi_uldivmod
00002aac g     F .text	0000000c i2c1_isr
2001d003 g     O .bss	00000001 usb_configuration
000092ec  w    F .text	00000006 dma_ch11_isr
00001756  w    F .text	00000006 SdCardInterface::status()
00008d8c g     F .text	0000001c SdioCard::syncDevice()
00008484 g     F .text	00000094 SdioCard::writeData(unsigned char const*)
00000000  w      *UND*	00000000 __fini_array_end
2001d019 g     O .bss	00000001 SPCRemulation::pinout
00000bb4  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::available()
1fff220a g     O .bss	00000020 store
00005ea8 g     F .text	0000003a FatFile::readDirCache(bool)
00011940 g     F .text	00000060 __ratio
00002ab8 g     F .text	0000000c i2c2_isr
1fff1392  w    O .data	00000018 usb_string_manufacturer_name
2001d078 g     O .bss	00000008 usb_rx_byte_count_data
000092ec  w    F .text	00000006 pit1_isr
0000b21c g     F .text	00000010 malloc
000092ec  w    F .text	00000006 dma_ch4_isr
0001283c g     O .text	00000020 TwoWire::i2c1_hardware
000092ec  w    F .text	00000006 software_isr
0000769c  w    F .text	00000014 SysCall::curTimeMS()
000032aa g     F .text	00000064 SDClass::format(int, char, Print&)
00012444  w    O .text	00000024 vtable for FsFile
000110c8 g     F .text	0000001c iswspace
000092ec  w    F .text	00000006 dma_ch7_isr
000024a4  w    F .text	0000001e TwoWire::read()
00013320 g     O .text	000000c8 __mprec_tens
00009dc4 g     F .text	00000094 usb_init
000075fc  w    F .text	00000004 SdSpiCard::type() const
0000ad6c g     F .text	00000040 .hidden __fixunsdfsi
000092ec  w    F .text	00000006 lptmr_isr
00000d2c  w    F .text	00000058 SDFile::seek(unsigned long long, int)
2001d040 g     O .bss	00000004 __malloc_top_pad
00009350 g     F .text	00000020 rtc_set
000121b8 g     F .text	0000003a __ssrefill_r
0000778e g     F .text	0000006a SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
00005242 g     F .text	000000be ExFatFile::truncate()
1fff0f30 g     O .data	00000000 .hidden __dso_handle
0000a6d0 g     F .text	0000001e .hidden __aeabi_ui2d
000110e8 g     F .text	0000001c _localeconv_r
1fff0f44 g     O .data	00000004 sd_str
00012010 g     F .text	00000024 _strtoull_r
00009334 g     F .text	00000010 attachInterruptVector
00011374 g     F .text	00000012 __i2b
1fff0f30 g       .data	00000000 _sdata
0001281c g     O .text	00000020 TwoWire::i2c0_hardware
0000579c g     F .text	000001a8 FatFormatter::makeFat32()
0000ae7c g     F .text	000002e2 .hidden __udivmoddi4
0000a44c g     F .text	00000000 .hidden __aeabi_drsub
00005bca g     F .text	00000036 FatFile::addCluster()
0000bd94 g     F .text	00000024 _sbrk_r
00007b1c g     F .text	00000036 SdSpiCard::readRegister(unsigned char, void*)
00008098 g     F .text	00000020 SdioCard::type() const
000001d0 g     F .text	000001f0 ResetHandler
00009004 g     F .text	0000004c usb_serial_getchar
000092ec  w    F .text	00000006 can1_bus_off_isr
000019ac  w    F .text	00000018 FsVolume::clusterCount() const
000092ec  w    F .text	00000006 ftm2_isr
00000a60  w    F .text	00000040 SDFile::name()
2001d06c g     O .bss	00000008 usb_cdc_line_coding
00009374 g     F .text	00000040 digitalWrite
2001d010 g     O .bss	00000004 EventResponder::lastYield
000092ec  w    F .text	00000006 uart5_status_isr
000092ec  w    F .text	00000006 lpuart0_status_isr
00003ffe g     F .text	00000026 ExFatFile::openRoot(ExFatVolume*)
00012faa g     O .text	00000004 usb_endpoint_config_table
000092ec  w    F .text	00000006 dma_ch9_isr
000006a8  w    F .text	0000001c Print::write(char const*)
00000cda  w    F .text	00000020 StreamFile<FsBaseFile, unsigned long long>::read()
000092ec  w    F .text	00000006 pit2_isr
000038a4 g     F .text	00000028 ExFatFormatter::syncUpcase()
00000df0  w    F .text	00000036 SDFile::setModifyTime(DateTimeFields const&)
0000aca0 g     F .text	00000012 .hidden __aeabi_dcmplt
00012964 g     O .text	0000005c SPISettings::ctar_clock_table
2001d03c g     O .bss	00000004 __malloc_max_sbrked_mem
00000b30  w    F .text	00000018 SDFile::position()
000093b4 g     F .text	00000064 pinMode
00001434 g     F .text	00000034 getTeensySerial()
00007d72 g     F .text	00000028 SdSpiCard::writeStop()
000095c8 g     F .text	00000044 usb_free
000092ec  w    F .text	00000006 i2c3_isr
0000a714 g     F .text	0000003a .hidden __extendsfdf2
0000e774 g     F .text	00000e88 __ssvfscanf_r
0000aa10 g     F .text	000001d0 .hidden __aeabi_ddiv
00000cc2  w    F .text	00000018 FsBaseFile::read(void*, unsigned int)
0000a458 g     F .text	00000276 .hidden __adddf3
1fff0f68 g     O .data	0000013c Wire2
000006e0 g     F .text	00000030 checkToCloseFile(short, unsigned long)
00007de6 g     F .text	0000002c SdSpiCard::writeData(unsigned char const*)
00000936  w    F .text	00000010 File::peek()
00006b08 g     F .text	0000005c FatPartition::freeClusterCount()
00000f7c  w    F .text	00000078 SDClass::open(char const*, unsigned char)
000117b4 g     F .text	000000d0 __b2d
000022d6 g     F .text	00000002 adc_init()
00013444 g       .ARM.exidx	00000000 __exidx_start
0000a7bc g     F .text	00000254 .hidden __aeabi_dmul
0000046c  w    F .text	0000000c DMAChannel::~DMAChannel()
00007cb0 g     F .text	00000030 SdSpiCard::writeStart(unsigned long)
000092ec  w    F .text	00000006 pit0_isr
2001d014 g     O .bss	00000004 EventResponder::firstYield
00013004 g     O .text	00000004 _global_impure_ptr
000006c4  w    F .text	00000008 Print::print(unsigned long)
000092ec  w    F .text	00000006 can1_error_isr
0000345c g     F .text	00000084 FsUtf::mbToCp(char const*, char const*, unsigned long*)
00000e7a  w    F .text	00000018 StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)
00000eb8  w    F .text	0000003c SDFile::SDFile(FsFile const&)
0000b9b4 g     F .text	000003de _realloc_r
00000cfa  w    F .text	0000000a SDFile::read(void*, unsigned int)
0000b17c g     F .text	00000050 __libc_init_array
2001d084 g       .bss	00000000 __bss_end
00000bf2  w    F .text	00000028 SDFile::rewindDirectory()
00002498  w    F .text	0000000c TwoWire::available()
000092ec  w    F .text	00000006 can0_wakeup_isr
0000472a g     F .text	0000000e ExFatFile::open(ExFatVolume*, char const*, int)
00007fd8 g     F .text	0000001c SdioCard::readCID(CID*)
0001321c g     O .text	00000100 __hexdig
00004ea6 g     F .text	000000de ExFatFile::addDirCluster()
000092ec  w    F .text	00000006 flash_cmd_isr
00007bf8 g     F .text	00000076 SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)
00007d9a g     F .text	0000004c SdSpiCard::writeData(unsigned char, unsigned char const*)
000133e8 g     O .text	00000028 __mprec_bigtens
00011240 g     F .text	00000098 __s2b
000028e4 g     F .text	000001bc TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)
0000a070  w    F .text	00000004 usb_serial_class::clear()
0000a6d0 g     F .text	0000001e .hidden __floatunsidf
000092ec  w    F .text	00000006 uart2_status_isr
00009304 g     F .text	0000002c _sbrk
000017f8  w    F .text	0000001c MySpiClass::send(unsigned char)
00011608 g     F .text	00000042 __mcmp
000129c0 g     O .text	00000030 vtable for SDClass
1fff1360 g     O .data	00000004 __brkval
2001cf1c g     O .bss	00000001 usb_cdc_line_rtsdtr
00009270 g     F .text	00000048 usb_serial_flush_callback
0001341c g     F .text	00000000 _init
00005c8c g     F .text	0000001e FatFile::cacheDirEntry(unsigned char)
000092ec  w    F .text	00000006 svcall_isr
00003082  w    F .text	00000056 SDClass::remove(char const*)
00000c2c  w    F .text	00000026 SDFile::close()
000092ec  w    F .text	00000006 dma_ch15_isr
00000c54  w    F .text	00000024 SDFile::~SDFile()
0000adac g     F .text	0000009e .hidden __aeabi_d2f
0001287c g     O .text	00000024 vtable for TwoWire
000092ec  w    F .text	00000006 uart1_error_isr
000106cc g     F .text	00000028 __libc_fini_array
0000c038 g     F .text	00000ed8 _strtod_l
00010f18 g     F .text	00000030 __match
000092ec  w    F .text	00000006 usbhs_phy_isr
2001d084 g       .bss	00000000 _ebss
0000858c g     F .text	00000078 SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
1fff2230 g     O .bss	00000004 hour_
00000d98  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::flush()
00002284  w    F .text	00000008 TwoWire::write(int)
00001722  w    F .text	00000034 BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)
000112d8 g     F .text	00000040 __hi0bits
00003f72 g     F .text	00000038 ExFatFile::dirCache(unsigned char, unsigned char)
0000ad1c g     F .text	0000004e .hidden __fixdfsi
00004f84 g     F .text	00000048 ExFatFile::mkdir(ExFatFile*, ExName_t*)
000092ec g     F .text	00000006 unused_isr
00000eb8  w    F .text	0000003c SDFile::SDFile(FsFile const&)
000092ec  w    F .text	00000006 spi0_isr
000092ec  w    F .text	00000006 dma_ch3_isr
00002fe8  w    F .text	00000002 SDClass::~SDClass()
00004b74 g     F .text	00000054 ExFatVolume::chdir(char const*)
0000046c  w    F .text	0000000c DMAChannel::~DMAChannel()
2001b9e0 g     O .bss	00001000 diskBuffer
2001a458 g     O .bss	000004c8 sdx
00006f68 g     F .text	00000092 FatFile::makeUniqueSfn(FatName_t*)
00000b00  w    F .text	0000001c File::~File()
00001b28 g     F .text	00000210 storage_configure()
00005944 g     F .text	000000a0 FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)
000059fe g     F .text	00000028 FatFile::getLfnChar(DirLfn_t*, unsigned char)
0000a2bc g     F .text	00000004 operator delete(void*, unsigned int)
000092ec  w    F .text	00000006 flash_error_isr
0000a434 g     F .text	00000018 .hidden __lshrdi3
0000a458 g     F .text	00000276 .hidden __aeabi_dadd
1fff2234 g     O .bss	00000014 file
0000abe8 g     F .text	00000082 .hidden __ledf2
000092ec  w    F .text	00000006 uart5_error_isr
000092ec  w    F .text	00000006 rtc_seconds_isr
000128d0 g     O .text	00000094 SPIClass::spi0_hardware
000092ec  w    F .text	00000006 pdb_isr
000114b8 g     F .text	000000a0 __pow5mult
000060e8 g     F .text	0000004e FatFile::rmdir()
0000a750 g     F .text	0000006a .hidden __aeabi_ul2d
000092b8  w    F .text	00000034 usage_fault_isr
000092ec  w    F .text	00000006 dac1_isr
00000000 g     O .text	000001d0 _VectorsFlash
00006a42 g     F .text	00000080 FatPartition::allocateCluster(unsigned long, unsigned long*)
000092ec  w    F .text	00000006 dma_ch14_isr
0000a01a  w    F .text	00000006 MillisTimer::enableTimerInterrupt(bool)
00002fea  w    F .text	00000044 SDClass::exists(char const*)
00000000  w      *UND*	00000000 __deregister_frame_info
2001d074 g     O .bss	00000004 usb_cdc_line_rtsdtr_millis
000006cc  w    F .text	00000014 Print::println(char const*)
0000a060 g     F .text	00000010 systick_isr
00000608 g     F .text	0000001e extract(void*, void*)
00001234 g     F .text	0000004c menuGet3Int(int*, int*, int*)
000092ec  w    F .text	00000006 rtc_alarm_isr
2001b9d0 g     O .bss	0000000c mySpi
00007b92 g     F .text	00000066 SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)
000092ec  w    F .text	00000006 dma_ch2_isr
1fff136c g     O .data	00000010 Serial
000092ec  w    F .text	00000006 ftm1_isr
0000a090  w    F .text	00000006 usb_serial_class::write(unsigned char)
0000749e g     F .text	0000005e FsBaseFile::openNext(FsBaseFile*, int)
000092f4  w    F .text	0000000c startup_early_hook
00007e12 g     F .text	00000048 SdSpiCard::writeSingle(unsigned long, unsigned char const*)
000092ec  w    F .text	00000006 dma_ch13_isr
00004c1c g     F .text	00000092 ExFatFile::addCluster()
00012468  w    O .text	0000002c vtable for File
000092ec  w    F .text	00000006 uart2_error_isr
000031b4  w    F .text	00000036 SDClass::usedSize()
00009050 g     F .text	00000038 usb_serial_peekchar
0000acdc g     F .text	00000012 .hidden __aeabi_dcmpgt
000010a0 g     F .text	000000d4 printMenu()
0000b7e0 g     F .text	00000000 memchr
000069e6 g     F .text	0000005c FatPartition::fatPut(unsigned long, unsigned long)
1fff1408 g     O .data	00000016 usb_string_serial_number_default
000092b8 g     F .text	00000034 fault_isr
00010790 g     F .text	000001d0 _free_r
000083fc g     F .text	00000088 SdioCard::readStop()
0000376a g     F .text	0000004e FsCache::get(unsigned long, unsigned char)
0000b1e4 g     F .text	0000001c __locale_mb_cur_max
0000acc8 g     F .text	00000012 .hidden __aeabi_dcmpge
000092ec  w    F .text	00000006 usb_charge_isr
00006e40 g     F .text	00000128 FatFile::makeSFN(FatName_t*)
0000a080  w    F .text	00000004 usb_serial_class::flush()
0000392a g     F .text	00000090 ExFatFormatter::writeUpcase(unsigned long)
00012134 g     F .text	00000082 _sungetc_r
000092ec  w    F .text	00000006 cmt_isr
0000a454 g     F .text	0000027a .hidden __aeabi_dsub
00006b64 g     F .text	00000108 FatPartition::init(BlockDeviceInterface*, unsigned char)
000092ec  w    F .text	00000006 usbhs_isr
1fff1dc4 g     O .data	00000004 __malloc_sbrk_base
0000a078  w    F .text	00000004 usb_serial_class::read()
000092ec  w    F .text	00000006 ftm3_isr
00011c74 g     F .text	00000024 _strtoll_r
000092ec  w    F .text	00000006 tsi0_isr
000072e4 g     F .text	000000b2 FatFile::remove()
0000a750 g     F .text	0000006a .hidden __floatundidf
2001a454 g     O .bss	00000004 msd
00009330  w    F .text	00000002 __cxa_pure_virtual
000022d8 g     F .text	00000002 adcStatus()
00011558 g     F .text	000000ae __lshift
000063ec g     F .text	000000aa FatFile::mkdir(FatFile*, char const*, bool)
000004e0 g     F .text	00000014 acq_stop()
000092ec  w    F .text	00000006 spi2_isr
00012034 g     F .text	00000100 __ssprint_r
000122f0 g     F .text	0000005e _vasnprintf_r
0000a2b6  w    F .text	00000002 serialEvent()
2001cf8d g     O .bss	00000001 usb_reboot_timer
0000f6a8 g     F .text	000000a4 __register_exitproc
00004670 g     F .text	000000ba ExFatFile::open(ExFatFile*, char const*, int)
0000bf5c g     F .text	000000a0 strncmp
00000dac  w    F .text	00000044 FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
00004fcc g     F .text	000000be ExFatFile::mkdir(ExFatFile*, char const*, bool)
00005698 g     F .text	00000104 FatFormatter::makeFat16()
000090a4 g     F .text	00000030 usb_serial_flush_input
2001c9e0 g     O .bss	00000004 fsamp
00004a2c g     F .text	00000064 ExFatPartition::freeClusterCount()
00011388 g     F .text	00000130 __multiply
1fff1de4 g     O .bss	00000004 acq_count
000091b4 g     F .text	00000016 usb_serial_putchar
00000022 g       *ABS*	00000000 _teensy_model_identifier
2001d044 g     O .bss	00000028 __malloc_current_mallinfo
00011884 g     F .text	000000ba __d2b
2001d01c g     O .bss	00000018 HardwareSerial::s_serials_with_serial_events
000092ec  w    F .text	00000006 can0_bus_off_isr
00008088  w    F .text	0000000e SdioCard::~SdioCard()
00001a3c  w    F .text	0000000c SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)
2001cffa g     O .bss	00000001 usb_rx_memory_needed
00008518 g     F .text	00000074 SdioCard::writeStart(unsigned long)
00011e00 g     F .text	00000024 _strtoul_r
000097a0 g     F .text	00000624 usb_isr
0000b164 g     F .text	0000000c __cxa_atexit
000040a0 g     F .text	00000184 ExFatFile::read(void*, unsigned int)
2001c9e4 g     O .bss	00000004 i2c
0000a6f0 g     F .text	00000022 .hidden __aeabi_i2d
00000cb8  w    F .text	0000000a SDFile::peek()
0000371e g     F .text	0000004c FsCache::sync()
1fff131c g     O .data	00000040 SPI
0000b880 g     F .text	00000062 memcmp
00012f80  w    O .text	00000028 vtable for usb_serial_class
00006d6c g     F .text	000000d4 FatFile::createLFN(unsigned short, FatName_t*, unsigned char)
000092ec  w    F .text	00000006 uart3_error_isr
00001b0c g     F .text	0000001c sdCsWrite(unsigned char, bool)
0000be04 g     F .text	00000058 sscanf
0000b160  w    F .text	00000002 .hidden __aeabi_ldiv0
00004d34 g     F .text	00000052 ExFatFile::rmdir()
000011f8 g     F .text	0000003c menuGetInt(int*)
000092ec  w    F .text	00000006 porta_isr
0000198c  w    F .text	00000020 FsVolume::bytesPerCluster() const
0000aa10 g     F .text	000001d0 .hidden __divdf3
000119a0 g     F .text	00000046 __copybits
1fff0bd0 g     O .usbbuffers	00000360 usb_buffer_memory
00007610 g     F .text	00000080 SdSpiCard::sectorCount()
000092ec  w    F .text	00000006 low_voltage_isr
1fff19b8 g     O .data	00000408 __malloc_av_
000092ec  w    F .text	00000006 can0_error_isr
1fff21f4 g     O .bss	00000004 max_write
00009480 g     F .text	0000010c _init_Teensyduino_internal_
00000da2  w    F .text	0000000a SDFile::flush()
0000a7bc g     F .text	00000254 .hidden __muldf3
00009214 g     F .text	0000005c usb_serial_flush_output
000092ec  w    F .text	00000006 dma_ch12_isr
0000b9ac g     F .text	00000002 __malloc_lock
00003e60 g     F .text	000000b0 ExFatFile::getName8(char*, unsigned int)
00000000  w      *UND*	00000000 __fini_array_start
000092ec  w    F .text	00000006 can1_wakeup_isr
1fff0a00 g     O .dmabuffers	000001d0 _VectorsRam
00005538 g     F .text	000000a8 FatFormatter::initFatDir(unsigned char, unsigned long)
00012350 g     F .text	0000005e _calloc_r
000092ec  w    F .text	00000006 pit3_isr
00002ae8 g     F .text	00000078 SPIClass::begin()
1fff0f38 g     O .data	00000004 t_acq
1fff1368 g     O .data	00000001 yield_active_check_flags
000092ec  w    F .text	00000006 enet_rx_isr
00004e68 g     F .text	0000003e ExFatFile::sync()
00006496 g     F .text	00000196 FatFile::rename(FatFile*, char const*)
00008da8 g     F .text	00000070 SdioCard::isBusy()
000092ec  w    F .text	00000006 portc_isr
00007c6e g     F .text	00000026 SdSpiCard::readStop()
00008fc0 g     F .text	00000000 memset
00001a60 g     F .text	00000018 getCount()
0000a226 g     F .text	00000010 main
1fff2200 g     O .bss	00000004 max_count
2001a974 g     O .bss	00000008 rawData
2001d038 g     O .bss	00000004 __malloc_max_total_mem
00004766 g     F .text	000000a6 ExFatPartition::bitmapFind(unsigned long, unsigned long)
00001d94 g     F .text	00000006 checkReboot()
00005300 g     F .text	00000210 ExFatFile::write(void const*, unsigned int)
000092b8  w    F .text	00000034 memmanage_fault_isr
00003690 g     F .text	0000008e lbaToMbrChs(unsigned char*, unsigned long, unsigned long)
0000627e g     F .text	00000034 FatFile::dirEntry(DirFat_t*)
00000bbe  w    F .text	0000000a SDFile::available()
00000e9c  w    F .text	0000001c File::close()
0000a378 g     F .text	00000070 usb_init_serialnumber
000016b4 g     F .text	00000036 setRTCTime(int, int, int, int, int, int)
0000d068 g     F .text	00000024 _strtol_r
0000adac g     F .text	0000009e .hidden __truncdfsf2
00013440 g       .text	00000000 __init_array_end
0000f898 g     F .text	00000e34 _dtoa_r
0000b23c g     F .text	00000570 _malloc_r
2001d034 g     O .bss	00000001 HardwareSerial::s_count_serials_with_serial_events
000092ec  w    F .text	00000006 debugmonitor_isr
0000f660 g     F .text	0000001a __ascii_wctomb
00000c8c  w    F .text	0000000a SDFile::isOpen()
00007396 g     F .text	00000062 FsBaseFile::FsBaseFile(FsBaseFile const&)
0000a760 g     F .text	0000005a .hidden __aeabi_l2d
2001cebc g     O .bss	00000004 FatVolume::m_cwv
00001970  w    F .text	00000008 Print::print(char const*)
00012278 g     F .text	00000078 __submore
0000a270 g     F .text	00000046 Stream::readBytesUntil(char, char*, unsigned int)
00002d34 g     F .text	000001cc SPIClass::transfer(void const*, void*, unsigned int)
621a5eb1 g       *ABS*	00000000 __rtc_localtime
00009418 g     F .text	0000003c micros
00000000  w      *UND*	00000000 __libc_fini
000092ec  w    F .text	00000006 cmp1_isr
000092ec  w    F .text	00000006 ftm0_isr
00004d88 g     F .text	000000e0 ExFatFile::syncDir()
00002538 g     F .text	00000034 TwoWire::setClock(unsigned long)
000106f4 g     F .text	0000009c _malloc_trim_r
1fff1404 g     O .data	00000004 string0
000090d4 g     F .text	000000e0 usb_serial_write
00009300  w    F .text	00000002 startup_late_hook
00000b60  w    F .text	00000054 FsBaseFile::available() const
0000a07c  w    F .text	00000004 usb_serial_class::available()
1fff137c g     O .data	00000001 _serialEvent_default
00006138 g     F .text	00000080 FatFile::sync()
000004f4 g     F .text	00000114 acq_init(int)
00006cd0 g     F .text	0000009c FatFile::cmpName(unsigned short, FatName_t*, unsigned char)
000030d8  w    F .text	0000004e SDClass::mkdir(char const*)
00004bf6  w    F .text	00000026 ExFatPartition::cacheSync()
1fff13ee  w    O .data	00000016 usb_string_product_name
00009454 g     F .text	0000002a delay
0000abf0 g     F .text	0000007a .hidden __nedf2
000092ec  w    F .text	00000006 tpm0_isr
2001d006 g     O .bss	00000002 dma_channel_allocated_mask
00003fde g     F .text	00000020 ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)
00000d04  w    F .text	00000028 FsBaseFile::seekSet(unsigned long long)
00013440 g     F .fini	00000000 _fini
00000d84  w    F .text	00000014 FsBaseFile::sync()
000024da g     F .text	00000026 TwoWire::write(unsigned char)
000128a0 g     O .text	0000002e SPISettings::ctar_div_table
00007b62 g     F .text	00000030 SdSpiCard::readStart(unsigned long)
00004738 g     F .text	0000002e ExFatFile::openNext(ExFatFile*, int)
000077f8 g     F .text	00000076 SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)
0000a0e0 g     F .text	0000001a Print::printf(char const*, ...)
0000bdb8 g     F .text	0000004c sprintf
000092ec  w    F .text	00000006 i2s0_rx_isr
000092ec  w    F .text	00000006 uart4_error_isr
0000a170 g     F .text	00000010 Print::print(long)
000061b8 g     F .text	00000010 FatFile::close()
00000c78  w    F .text	00000014 SDFile::~SDFile()
0000f760 g     F .text	0000000c atexit
00008020  w    F .text	00000002 SdioCard::~SdioCard()
00000cae  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::peek()
00000978  w    F .text	0000001c File::write(unsigned char)
0000f67c g     F .text	0000002c _write_r
2001c9ec g     O .bss	000004c8 SD
000014c8 g     F .text	0000012c breakTime(unsigned long, tmElements_t&)
000082c8 g     F .text	000000d8 SdioCard::erase(unsigned long, unsigned long)
0000695c  w    F .text	00000020 FsCache::clear()
000092ec  w    F .text	00000006 can0_message_isr
00002b60 g     F .text	0000009c SPIClass::setMOSI(unsigned char)
00011abc g     F .text	0000000c nanf
1fff1848 g     O .data	00000004 _impure_ptr
000123fc  w    O .text	00000024 vtable for Stream
000092ec  w    F .text	00000006 can1_message_isr
00004224 g     F .text	0000002c ExFatFile::peek()
00012420  w    O .text	00000024 vtable for StreamFile<FsBaseFile, unsigned long long>
00011104 g     F .text	0000005c _mbrtowc_r
000092ec  w    F .text	00000006 nmi_isr
1fff10a4 g     O .data	0000013c Wire
000019dc  w    F .text	00000060 SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)
00000e92  w    F .text	0000000a SDFile::write(void const*, unsigned int)
000075b8 g     F .text	00000028 FsVolume::open(char const*, int)
00007fc0 g     F .text	0000000c SdioCard::errorCode() const
00006270 g     F .text	0000000e FatFile::open(FatVolume*, char const*, int)
00000e70  w    F .text	0000000a StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)
1fff2250 g     O .bss	00000004 diskSize
00013428 g       .text	00000000 __preinit_array_end
00001816 g     F .text	00000076 dateTime(unsigned short*, unsigned short*, unsigned char*)
00007600  w    F .text	00000002 SdSpiCard::~SdSpiCard()
000092ec  w    F .text	00000006 sdhc_isr
00004a90 g     F .text	000000cc ExFatPartition::init(BlockDeviceInterface*, unsigned char)
000048b2 g     F .text	00000036 ExFatPartition::dirCache(DirPos_t*, unsigned char)
00007ce0 g     F .text	00000092 SdSpiCard::erase(unsigned long, unsigned long)
0000b7ac g     F .text	0000002a __ascii_mbtowc
000076fc g     F .text	00000032 SdSpiCard::isBusy()
00011760 g     F .text	00000054 __ulp
00012cc0 g     O .text	00000060 vtable for SdSpiCard
00007b5a  w    F .text	00000008 SdSpiCard::readCID(CID*)
000024c2  w    F .text	00000016 TwoWire::peek()
000024d8  w    F .text	00000002 TwoWire::flush()
00000710 g     F .text	00000084 setup
00012fb0 g     O .text	00000054 usb_descriptor_list
0000964c g     F .text	00000038 usb_rx
0000813c g     F .text	00000004 SdioCard::status()
000092ec  w    F .text	00000006 dma_ch10_isr
0000188c  w    F .text	00000014 MySpiClass::send(unsigned char const*, unsigned int)
000062d2 g     F .text	00000020 FatFile::getModifyDateTime(unsigned short*, unsigned short*)
0000091c  w    F .text	00000002 Print::flush()
00000c1a  w    F .text	00000012 FsBaseFile::isOpen() const
0000ad6c g     F .text	00000040 .hidden __aeabi_d2uiz
000092ec  w    F .text	00000006 uart0_error_isr
00000bc8  w    F .text	00000020 FsBaseFile::isDir() const
0000302e  w    F .text	00000054 SDClass::rmdir(char const*)
0001272c  w    O .text	00000028 vtable for MySpiClass
0000958c g     F .text	0000003c usb_malloc
00005d08 g     F .text	00000178 FatFile::read(void*, unsigned int)
000092ec  w    F .text	00000006 i2s0_isr
00005caa g     F .text	00000030 FatFile::openRoot(FatVolume*)
2001ceb8 g     O .bss	00000004 ExFatVolume::m_cwv
000019c4  w    F .text	00000018 FsVolume::freeClusterCount() const
20030000 g       .bss	00000000 _estack
000075e0 g     F .text	00000004 operator new(unsigned int, unsigned long*)
00007b52  w    F .text	00000008 SdSpiCard::readCSD(csd_t*)
00009fd8 g     F .text	00000034 DMAChannel::release()
00000952  w    F .text	00000026 File::read()
000091cc g     F .text	00000048 usb_serial_write_buffer_free
0000786e g     F .text	00000028 SdSpiCard::waitNotBusy(unsigned short)
000076d6 g     F .text	00000026 SdSpiCard::spiStop()
000092ec  w    F .text	00000006 enet_timer_isr
00006ffc g     F .text	00000250 FatFile::open(FatFile*, FatName_t*, int)
0000ac8c g     F .text	00000012 .hidden __aeabi_dcmpeq
000015f4 g     F .text	000000c0 makeTime(tmElements_t const&)
00002500 g     F .text	00000038 TwoWire::write(unsigned char const*, unsigned int)
00000b1c  w    F .text	00000014 File::~File()
00001468 g     F .text	0000003c _write
1fff1dc8 g       .data	00000000 _edata
00004994 g     F .text	0000003a ExFatPartition::fatPut(unsigned long, unsigned long)
00008020  w    F .text	00000002 SdioCard::~SdioCard()
000092ec  w    F .text	00000006 i2s0_tx_isr
000092ec  w    F .text	00000006 adc1_isr
0000385c g     F .text	00000048 FsName::get16()
00007c94 g     F .text	0000001c SdSpiCard::syncDevice()
00003f10 g     F .text	00000062 ExFatFile::hashName(ExName_t*)
00005c00 g     F .text	0000008c FatFile::addDirCluster()
000062f2 g     F .text	000000fa FatFile::mkdir(FatFile*, FatName_t*)
0000a084  w    F .text	00000004 usb_serial_class::availableForWrite()
000092ec  w    F .text	00000006 cmp0_isr
00001950  w    F .text	00000020 MySpiClass::receive()
00006932 g     F .text	0000002a FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)
0000a3e8 g     F .text	00000040 ultoa
00002fe8  w    F .text	00000002 SDClass::~SDClass()
00007930 g     F .text	000001b4 SdSpiCard::begin(SdSpiConfig)
0000256c g     F .text	0000008c TwoWire::begin()
00007420 g     F .text	0000007e FsBaseFile::open(FsVolume*, char const*, int)
0000a00c  w    F .text	0000000e MillisTimer::disableTimerInterrupt()
0000a2b8 g     F .text	00000004 operator new(unsigned int)
0000a020 g     F .text	0000003c EventResponder::runFromInterrupt()
00001174 g     F .text	00000084 printMenuEntries()
1fff1dc0 g     O .data	00000004 __malloc_trim_threshold
0000a074  w    F .text	00000004 usb_serial_class::peek()
0001164c g     F .text	00000114 __mdiff
00008010 g     F .text	00000010 SdioCard::readOCR(unsigned long*)
0000ad1c g     F .text	0000004e .hidden __aeabi_d2iz
00004950 g     F .text	00000044 ExFatPartition::dirSeek(DirPos_t*, unsigned long)
2001cf0c g     O .bss	00000001 usb_cdc_transmit_flush_timer
00005ab0 g     F .text	000000f0 FatFile::getName8(char*, unsigned int)
00004320 g     F .text	00000350 ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)
000092ec  w    F .text	00000006 pit_isr
000083fc g     F .text	00000088 SdioCard::writeStop()
00007e5a  w    F .text	0000001c SdSpiCard::writeSector(unsigned long, unsigned char const*)
00011a48 g     F .text	00000072 __sccl
00003faa g     F .text	00000014 ExFatFile::close()
00013108 g     O .text	00000101 _ctype_
000092ec  w    F .text	00000006 dac0_isr
000075ec  w    F .text	00000010 SdSpiCard::readSector(unsigned long, unsigned char*)
00013428 g       .text	00000000 __init_array_start
0000b160  w    F .text	00000002 .hidden __aeabi_idiv0
000092ec  w    F .text	00000006 can1_tx_warn_isr
0000acf0 g     F .text	0000002c .hidden __unorddf2
2001b9dc g     O .bss	00000004 disk_count
000038cc g     F .text	00000042 ExFatFormatter::writeUpcaseByte(unsigned char)
000034e0 g     F .text	000001b0 FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)
00003126  w    F .text	00000068 SDClass::rename(char const*, char const*)
000092ec  w    F .text	00000006 uart0_status_isr
00006c6c g     F .text	00000046 FatVolume::chdir(char const*)
000004c8 g     F .text	00000018 acq_start()
000092ec  w    F .text	00000006 mcg_isr
0000a238 g     F .text	00000038 Stream::timedRead()
00000400 g     O .text	00000010 flashconfigbytes
00009f30 g     F .text	000000a8 DMAChannel::begin(bool)
0000be80 g     F .text	000000dc strlen
00005cda g     F .text	0000002e FatFile::openCluster(FatFile*)
0000b200 g     F .text	00000006 __locale_ctype_ptr_l
000031ea  w    F .text	00000036 SdBase<FsVolume>::begin(SdioConfig)
0000ac7c g     F .text	00000010 .hidden __aeabi_cdcmpeq
0000abe0 g     F .text	0000008a .hidden __gedf2
00005ee2 g     F .text	000000ac FatFile::seekSet(unsigned long)
0000724c g     F .text	00000098 FatFile::parsePathName(char const*, FatName_t*, char const**)
00010a08 g     F .text	00000510 __gethex
1fff13ee g     O .data	00000016 usb_string_product_name_default
0000f648 g     F .text	00000018 vdprintf
000092ec  w    F .text	00000006 dma_ch1_isr
00008264 g     F .text	00000064 SdioCard::sectorCount()
000074fc g     F .text	000000bc FsVolume::begin(BlockDeviceInterface*)
000018a0  w    F .text	00000024 MySpiClass::receive(unsigned char*, unsigned int)
00009684 g     F .text	00000024 usb_tx_packet_count
00006050 g     F .text	00000098 FatFile::openNext(FatFile*, int)
1fff2248 g     O .bss	00000004 diskSpace
00009370  w    F .text	00000002 startup_middle_hook
00012d20 g     O .text	00000060 vtable for SdioCard
0000a714 g     F .text	0000003a .hidden __aeabi_f2d
000092ec  w    F .text	00000006 dma_ch5_isr
00005ba0 g     F .text	00000004 FatFile::getName(char*, unsigned int)
000092ec  w    F .text	00000006 can0_rx_warn_isr
00001a3c  w    F .text	0000000c SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)
000092ec  w    F .text	00000006 can0_tx_warn_isr
000092ec  w    F .text	00000006 uart4_status_isr
00008bf4 g     F .text	00000074 SdioCard::readStart(unsigned long)
00000000  w      *UND*	00000000 _Jv_RegisterClasses
000059e4  w    F .text	0000001a FatFile::cacheDir(unsigned short)
0000a454 g     F .text	0000027a .hidden __subdf3
00001aac g     F .text	00000044 pullData(unsigned long*, unsigned long)
00013428 g       .text	00000000 __preinit_array_start
0000480c g     F .text	000000a6 ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)
00000e5c  w    F .text	00000014 FsBaseFile::write(void const*, unsigned int)
1fff2254 g     O .bss	00028000 data_buffer
00011318 g     F .text	0000005a __lo0bits
00004926 g     F .text	0000002a ExFatPartition::chainSize(unsigned long)
00005f8e g     F .text	000000c2 FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)
0000662c g     F .text	000000ae FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)
1fff0f3c g     O .data	00000004 stdPrint
000016ea  w    F .text	00000038 BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)
0000a428 g     F .text	0000000a __aeabi_atexit
00000000  w      *UND*	00000000 __register_frame_info
00009344 g     F .text	0000000c rtc_get
00004cae g     F .text	00000086 ExFatFile::remove()
000092ec  w    F .text	00000006 cmp2_isr
0000a05c g     F .text	00000004 pendablesrvreq_isr
0000318e  w    F .text	00000026 SDClass::totalSize()
00000918  w    F .text	00000004 Print::availableForWrite()
1fff184c g     O .data	0000016c __global_locale
000092ec  w    F .text	00000006 wakeup_isr
00002bfc g     F .text	00000094 SPIClass::setMISO(unsigned char)
000087d4 g     F .text	0000035c SdioCard::begin(SdioConfig)
00003fbe g     F .text	00000020 ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)
000092ec  w    F .text	00000006 cmp3_isr
0000a0fa g     F .text	00000076 Print::printNumber(unsigned long, unsigned char, unsigned char)
0000697c g     F .text	0000006a FatPartition::fatGet(unsigned long, unsigned long*)
0000b22c g     F .text	00000010 free
000092ec  w    F .text	00000006 tpm2_isr
00003e14 g     F .text	0000004c ExFatFile::cmpName(DirName_t const*, ExName_t*)
000111c0 g     F .text	00000080 __multadd
000111ac g     F .text	00000012 _Bfree
00000b48  w    F .text	00000018 SDFile::size()
00005a26 g     F .text	00000088 FatFile::getSFN(char*, unsigned int)
000092ec  w    F .text	00000006 dma_ch0_isr
00000c54  w    F .text	00000024 SDFile::~SDFile()
1fff1408  w    O .data	00000016 usb_string_serial_number
000092ec  w    F .text	00000006 enet_tx_isr
00008c68 g     F .text	000000c4 SdioCard::readSector(unsigned long, unsigned char*)
00007ff4 g     F .text	0000001c SdioCard::readCSD(csd_t*)



Disassembly of section .text:

00000000 <_VectorsFlash>:
  return fsFmtTime(str, time);
}
//------------------------------------------------------------------------------
char* fsFmtTimeZone(char* str, int8_t tz) {
  char sign;
  if (tz & 0X80) {
       0:	... ............
    if (tz & 0X40) {
      sign = '-';
      10:	................
    } else {
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      str = fsFmtField(str, 15*(tz%4), 0);
      20:	................
      30:	........]...a...
      str = fsFmtField(str, tz/4, ':');
      40:	................
      *--str = sign;
      50:	................
    }
    *--str = 'C';
    *--str = 'T';
    *--str = 'U';
      60:	................
      70:	................
      80:	................
      90:	................
      a0:	.*...*..........
      b0:	................
      c0:	................
      d0:	................
      e0:	................
      f0:	................
     100:	................
     110:	................
     120:	................
     130:	................
     140:	................
     150:	................
     160:	.........*......
     170:	................
     180:	................
     190:	................
     1a0:	................
     1b0:	................
     1c0:	................

000001d0 <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d0:	ldr	r3, [pc, #356]	; (338 <ResetHandler+0x168>)
     1d2:	movw	r2, #50464	; 0xc520
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
     1d6:	push	{r4, lr}
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d8:	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
     1da:	movw	r2, #55592	; 0xd928
     1de:	strh	r2, [r3, #0]
	__asm__ volatile ("nop");
     1e0:	nop
	__asm__ volatile ("nop");
     1e2:	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
     1e4:	bl	92f4 <startup_early_hook>
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1e8:	ldr	r3, [pc, #336]	; (33c <ResetHandler+0x16c>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     1ea:	ldr	r1, [pc, #340]	; (340 <ResetHandler+0x170>)
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1ec:	mov.w	r2, #184549376	; 0xb000000
     1f0:	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
     1f2:	ldr	r2, [pc, #336]	; (344 <ResetHandler+0x174>)
     1f4:	str	r2, [r3, #8]
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
     1f6:	ldr	r2, [pc, #336]	; (348 <ResetHandler+0x178>)
     1f8:	str	r2, [r3, #12]
	SIM_SCGC4 = SIM_SCGC4_USBOTG | 0xF0000030;
	SIM_SCGC5 = 0x00003F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_ADC0 | SIM_SCGC6_TPM0 | SIM_SCGC6_TPM1 | SIM_SCGC6_TPM2 | SIM_SCGC6_FTFL;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SCB_CPACR = 0x00F00000;
     1fa:	ldr	r3, [pc, #336]	; (34c <ResetHandler+0x17c>)
     1fc:	mov.w	r2, #15728640	; 0xf00000
     200:	str	r2, [r3, #0]
#endif
#if defined(__MK66FX1M0__)
	LMEM_PCCCR = 0x85000003;
     202:	ldr	r3, [pc, #332]	; (350 <ResetHandler+0x180>)
     204:	ldr	r2, [pc, #332]	; (354 <ResetHandler+0x184>)
     206:	str	r2, [r3, #0]
		RTC_SR = 0;
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     208:	ldr	r3, [pc, #332]	; (358 <ResetHandler+0x188>)
     20a:	ldrb	r2, [r3, #0]
     20c:	lsls	r0, r2, #28
     20e:	ittt	mi
     210:	ldrbmi	r2, [r3, #0]
     212:	orrmi.w	r2, r2, #8
     216:	strbmi	r2, [r3, #0]

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     218:	ldr	r3, [pc, #320]	; (35c <ResetHandler+0x18c>)
     21a:	movs	r2, #170	; 0xaa
     21c:	strb	r2, [r3, #0]
     21e:	ldr	r2, [pc, #320]	; (360 <ResetHandler+0x190>)
     220:	ldr	r3, [pc, #320]	; (364 <ResetHandler+0x194>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     222:	cmp	r3, r1
     224:	bcs.n	230 <ResetHandler+0x60>
     226:	ldr.w	r0, [r2, #4]!
     22a:	str.w	r0, [r3], #4
     22e:	b.n	222 <ResetHandler+0x52>
     230:	ldr	r3, [pc, #308]	; (368 <ResetHandler+0x198>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     232:	ldr	r2, [pc, #312]	; (36c <ResetHandler+0x19c>)
     234:	movs	r1, #0
     236:	cmp	r3, r2
     238:	bcs.n	240 <ResetHandler+0x70>
     23a:	str.w	r1, [r3], #4
     23e:	b.n	236 <ResetHandler+0x66>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     240:	ldr	r2, [pc, #300]	; (370 <ResetHandler+0x1a0>)
     242:	ldr	r0, [pc, #304]	; (374 <ResetHandler+0x1a4>)
     244:	movs	r3, #0
     246:	ldr.w	r1, [r0, r3, lsl #2]
     24a:	str.w	r1, [r2, r3, lsl #2]
     24e:	adds	r3, #1
     250:	cmp	r3, #116	; 0x74
     252:	bne.n	246 <ResetHandler+0x76>
     254:	ldr	r3, [pc, #288]	; (378 <ResetHandler+0x1a8>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     256:	ldr	r2, [pc, #292]	; (37c <ResetHandler+0x1ac>)
     258:	movs	r1, #128	; 0x80
     25a:	strb.w	r1, [r3], #1
     25e:	cmp	r3, r2
     260:	bne.n	25a <ResetHandler+0x8a>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     262:	ldr	r3, [pc, #284]	; (380 <ResetHandler+0x1b0>)
     264:	ldr	r2, [pc, #264]	; (370 <ResetHandler+0x1a0>)
     266:	str	r2, [r3, #0]
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     268:	ldr	r3, [pc, #280]	; (384 <ResetHandler+0x1b4>)
     26a:	movs	r2, #138	; 0x8a
     26c:	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     26e:	sub.w	r3, r3, #4096	; 0x1000
     272:	movs	r2, #36	; 0x24
     274:	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     276:	movs	r2, #160	; 0xa0
     278:	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     27a:	ldrb	r2, [r3, #6]
     27c:	lsls	r1, r2, #30
     27e:	bpl.n	27a <ResetHandler+0xaa>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     280:	ldrb	r2, [r3, #6]
     282:	lsls	r2, r2, #27
     284:	bmi.n	280 <ResetHandler+0xb0>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     286:	ldr	r2, [pc, #256]	; (388 <ResetHandler+0x1b8>)
     288:	ldrb	r3, [r2, #6]
     28a:	and.w	r3, r3, #12
     28e:	cmp	r3, #8
     290:	ldr	r3, [pc, #244]	; (388 <ResetHandler+0x1b8>)
     292:	bne.n	288 <ResetHandler+0xb8>
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(2);
    #elif F_CPU == 120000000
	MCG_C5 = MCG_C5_PRDIV0(1);
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(14);
    #elif F_CPU == 96000000 || F_CPU == 48000000 || F_CPU == 24000000
	MCG_C5 = MCG_C5_PRDIV0(1);
     294:	movs	r2, #1
     296:	strb	r2, [r3, #4]
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(8);
     298:	movs	r2, #72	; 0x48
     29a:	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     29c:	ldrb	r2, [r3, #6]
     29e:	lsls	r4, r2, #26
     2a0:	bpl.n	29c <ResetHandler+0xcc>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     2a2:	ldr	r1, [pc, #228]	; (388 <ResetHandler+0x1b8>)
     2a4:	ldrb	r2, [r1, #6]
     2a6:	ldr	r3, [pc, #224]	; (388 <ResetHandler+0x1b8>)
     2a8:	lsls	r0, r2, #25
     2aa:	bpl.n	2a4 <ResetHandler+0xd4>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC;
#elif F_CPU == 96000000
	// config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash, USB = 96 / 2
	#if F_BUS == 48000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(3);
     2ac:	ldr	r2, [pc, #220]	; (38c <ResetHandler+0x1bc>)
     2ae:	ldr	r1, [pc, #224]	; (390 <ResetHandler+0x1c0>)
     2b0:	str	r1, [r2, #0]
	#elif F_BUS == 96000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(0) | SIM_CLKDIV1_OUTDIV4(3);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1);
     2b2:	movs	r1, #2
     2b4:	str	r1, [r2, #4]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     2b6:	movs	r2, #32
     2b8:	strb	r2, [r3, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     2ba:	ldrb	r2, [r3, #6]
     2bc:	and.w	r2, r2, #12
     2c0:	cmp	r2, #12
     2c2:	bne.n	2ba <ResetHandler+0xea>
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#else
	// USB uses PLL clock
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     2c4:	ldr	r3, [pc, #204]	; (394 <ResetHandler+0x1c4>)
     2c6:	ldr	r2, [pc, #208]	; (398 <ResetHandler+0x1c8>)
     2c8:	str	r2, [r3, #0]
#endif

#if defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started.  For Teensy 3.6
	// we don't do this early.  See comment above about slow rising power.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     2ca:	ldr	r2, [pc, #208]	; (39c <ResetHandler+0x1cc>)
     2cc:	ldr	r4, [pc, #208]	; (3a0 <ResetHandler+0x1d0>)
     2ce:	ldr	r3, [r2, #0]
     2d0:	ands.w	r3, r3, #256	; 0x100
		RTC_SR = 0;
     2d4:	ittt	eq
     2d6:	streq	r3, [r4, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     2d8:	moveq.w	r3, #5376	; 0x1500
     2dc:	streq	r3, [r2, #0]
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2de:	ldr	r3, [pc, #196]	; (3a4 <ResetHandler+0x1d4>)
     2e0:	ldr	r2, [pc, #196]	; (3a8 <ResetHandler+0x1d8>)
     2e2:	str	r2, [r3, #0]
	SYST_CVR = 0;
     2e4:	movs	r2, #0
     2e6:	str	r2, [r3, #4]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2e8:	movs	r2, #7
     2ea:	str.w	r2, [r3, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2ee:	ldr	r2, [pc, #188]	; (3ac <ResetHandler+0x1dc>)
     2f0:	str.w	r2, [r3, #3340]	; 0xd0c

	//init_pins();
	__enable_irq();
     2f4:	cpsie	i

	_init_Teensyduino_internal_();
     2f6:	bl	9480 <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     2fa:	ldr	r3, [r4, #0]
     2fc:	lsls	r2, r3, #31
     2fe:	bpl.n	30c <ResetHandler+0x13c>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     300:	ldr	r0, [pc, #172]	; (3b0 <ResetHandler+0x1e0>)
     302:	bl	9350 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     306:	ldr	r3, [pc, #172]	; (3b4 <ResetHandler+0x1e4>)
     308:	ldr	r2, [pc, #172]	; (3b8 <ResetHandler+0x1e8>)
     30a:	str	r2, [r3, #0]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     30c:	ldr	r3, [pc, #172]	; (3bc <ResetHandler+0x1ec>)
     30e:	ldrb	r3, [r3, #0]
     310:	lsls	r3, r3, #25
     312:	bpl.n	328 <ResetHandler+0x158>
     314:	ldr	r4, [pc, #156]	; (3b4 <ResetHandler+0x1e4>)
     316:	ldr	r3, [pc, #160]	; (3b8 <ResetHandler+0x1e8>)
     318:	ldr	r2, [r4, #0]
     31a:	cmp	r2, r3
     31c:	bne.n	328 <ResetHandler+0x158>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     31e:	ldr	r0, [pc, #144]	; (3b0 <ResetHandler+0x1e0>)
     320:	bl	9350 <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     324:	movs	r3, #0
     326:	str	r3, [r4, #0]
	}
#endif

	startup_late_hook();
     328:	bl	9300 <startup_late_hook>
	__libc_init_array();
     32c:	bl	b17c <__libc_init_array>

	main();
     330:	bl	a226 <main>
     334:	b.n	334 <ResetHandler+0x164>
     336:	nop
     338:	.word	0x4005200e
     33c:	.word	0x40048030
     340:	.word	0x1fff1dc8
     344:	.word	0x00043f82
     348:	.word	0x2b000001
     34c:	.word	0xe000ed88
     350:	.word	0xe0082000
     354:	.word	0x85000003
     358:	.word	0x4007d002
     35c:	.word	0x4007e000
     360:	.word	0x00013448
     364:	.word	0x1fff0f30
     368:	.word	0x1fff1dc8
     36c:	.word	0x2001d084
     370:	.word	0x1fff0a00
     374:	.word	0x00000000
     378:	.word	0xe000e400
     37c:	.word	0xe000e464
     380:	.word	0xe000ed08
     384:	.word	0x40065000
     388:	.word	0x40064000
     38c:	.word	0x40048044
     390:	.word	0x01030000
     394:	.word	0x40048004
     398:	.word	0x000510c0
     39c:	.word	0x4003d010
     3a0:	.word	0x4003d014
     3a4:	.word	0xe000e014
     3a8:	.word	0x000176ff
     3ac:	.word	0x20200000
     3b0:	.word	0x621a5eb1
     3b4:	.word	0x4003e01c
     3b8:	.word	0x5a94c3a5
     3bc:	.word	0x4007f000
     3c0:	.word	0xffffffff
     3c4:	.word	0xffffffff
     3c8:	.word	0xffffffff
     3cc:	.word	0xffffffff
     3d0:	.word	0xffffffff
     3d4:	.word	0xffffffff
     3d8:	.word	0xffffffff
     3dc:	.word	0xffffffff
     3e0:	.word	0xffffffff
     3e4:	.word	0xffffffff
     3e8:	.word	0xffffffff
     3ec:	.word	0xffffffff
     3f0:	.word	0xffffffff
     3f4:	.word	0xffffffff
     3f8:	.word	0xffffffff
     3fc:	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	................

00000410 <__do_global_dtors_aux>:
     410:	push	{r4, lr}
     412:	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
     414:	ldrb	r3, [r4, #0]
     416:	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
     41a:	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
     41e:	nop.w
     422:	movs	r3, #1
     424:	strb	r3, [r4, #0]
     426:	pop	{r4, pc}
     428:	.word	0x1fff1dc8
     42c:	.word	0x00000000
     430:	.word	0x00013444

00000434 <frame_dummy>:
     434:	ldr	r3, [pc, #32]	; (458 <frame_dummy+0x24>)
     436:	push	{r4, lr}
     438:	cbz	r3, 442 <frame_dummy+0xe>
     43a:	ldr	r1, [pc, #32]	; (45c <frame_dummy+0x28>)
     43c:	ldr	r0, [pc, #32]	; (460 <frame_dummy+0x2c>)
     43e:	nop.w
     442:	ldr	r0, [pc, #32]	; (464 <frame_dummy+0x30>)
     444:	ldr	r3, [r0, #0]
     446:	cbnz	r3, 44a <frame_dummy+0x16>
     448:	pop	{r4, pc}
     44a:	ldr	r3, [pc, #28]	; (468 <frame_dummy+0x34>)
     44c:	cmp	r3, #0
     44e:	beq.n	448 <frame_dummy+0x14>
     450:	ldmia.w	sp!, {r4, lr}
     454:	bx	r3
     456:	nop
     458:	.word	0x00000000
     45c:	.word	0x1fff1dcc
     460:	.word	0x00013444
     464:	.word	0x1fff1dc8
     468:	.word	0x00000000

0000046c <DMAChannel::~DMAChannel()>:
	}
	DMAChannel & operator = (const DMASetting &rhs) {
		copy_tcd(TCD, rhs.TCD);
		return *this;
	}
	~DMAChannel() {
     46c:	push	{r4, lr}
     46e:	mov	r4, r0
		release();
     470:	bl	9fd8 <DMAChannel::release()>
	}
     474:	mov	r0, r4
     476:	pop	{r4, pc}

00000478 <acq_stopClocks()>:
            dma.enable();        
        }
    #else // I2S_SLAVE
        void acq_stopClocks(void)
        {
            SIM_SCGC6 &= ~SIM_SCGC6_DMAMUX;
     478:	ldr	r3, [pc, #28]	; (498 <acq_stopClocks()+0x20>)
            SIM_SCGC7 &= ~SIM_SCGC7_DMA;
     47a:	ldr	r1, [pc, #32]	; (49c <acq_stopClocks()+0x24>)
            dma.enable();        
        }
    #else // I2S_SLAVE
        void acq_stopClocks(void)
        {
            SIM_SCGC6 &= ~SIM_SCGC6_DMAMUX;
     47c:	ldr	r2, [r3, #0]
     47e:	bic.w	r2, r2, #2
     482:	str	r2, [r3, #0]
            SIM_SCGC7 &= ~SIM_SCGC7_DMA;
     484:	ldr	r2, [r1, #0]
     486:	bic.w	r2, r2, #2
     48a:	str	r2, [r1, #0]
            SIM_SCGC6 &= ~SIM_SCGC6_I2S;
     48c:	ldr	r2, [r3, #0]
     48e:	bic.w	r2, r2, #32768	; 0x8000
     492:	str	r2, [r3, #0]
     494:	bx	lr
     496:	nop
     498:	.word	0x4004803c
     49c:	.word	0x40048040

000004a0 <acq_startClocks()>:
        }

        void acq_startClocks(void)
        {
        SIM_SCGC6 |= SIM_SCGC6_I2S;
     4a0:	ldr	r3, [pc, #28]	; (4c0 <acq_startClocks()+0x20>)
        SIM_SCGC7 |= SIM_SCGC7_DMA;
     4a2:	ldr	r1, [pc, #32]	; (4c4 <acq_startClocks()+0x24>)
            SIM_SCGC6 &= ~SIM_SCGC6_I2S;
        }

        void acq_startClocks(void)
        {
        SIM_SCGC6 |= SIM_SCGC6_I2S;
     4a4:	ldr	r2, [r3, #0]
     4a6:	orr.w	r2, r2, #32768	; 0x8000
     4aa:	str	r2, [r3, #0]
        SIM_SCGC7 |= SIM_SCGC7_DMA;
     4ac:	ldr	r2, [r1, #0]
     4ae:	orr.w	r2, r2, #2
     4b2:	str	r2, [r1, #0]
        SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
     4b4:	ldr	r2, [r3, #0]
     4b6:	orr.w	r2, r2, #2
     4ba:	str	r2, [r3, #0]
     4bc:	bx	lr
     4be:	nop
     4c0:	.word	0x4004803c
     4c4:	.word	0x40048040

000004c8 <acq_start()>:
        }

        void acq_start(void)
        {
     4c8:	push	{r3, lr}
            acq_startClocks();
     4ca:	bl	4a0 <acq_startClocks()>
            I2S0_RCSR |= I2S_RCSR_RE;
     4ce:	ldr	r2, [pc, #12]	; (4dc <acq_start()+0x14>)
     4d0:	ldr	r3, [r2, #0]
     4d2:	orr.w	r3, r3, #2147483648	; 0x80000000
     4d6:	str	r3, [r2, #0]
     4d8:	pop	{r3, pc}
     4da:	nop
     4dc:	.word	0x4002f080

000004e0 <acq_stop()>:
        }

        void acq_stop(void)
        {
            I2S0_RCSR &= ~I2S_RCSR_RE;
     4e0:	ldr	r2, [pc, #12]	; (4f0 <acq_stop()+0x10>)
     4e2:	ldr	r3, [r2, #0]
     4e4:	bic.w	r3, r3, #2147483648	; 0x80000000
     4e8:	str	r3, [r2, #0]
            acq_stopClocks();
     4ea:	b.w	478 <acq_stopClocks()>
     4ee:	nop
     4f0:	.word	0x4002f080

000004f4 <acq_init(int)>:
        }

        void acq_init(int fsamp)
        {   
     4f4:	push	{r3, r4, r5, lr}
            acq_startClocks();
     4f6:	bl	4a0 <acq_startClocks()>

            #if I2S_CONFIG==0
                CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
     4fa:	ldr	r2, [pc, #216]	; (5d4 <acq_init(int)+0xe0>)
                CORE_PIN35_CONFIG = PORT_PCR_MUX(4) | PORT_PCR_SRE | PORT_PCR_DSE;  //pin35, PTC8,   I2S0_MCLK (SLEW rate (SRE)?)
                CORE_PIN36_CONFIG = PORT_PCR_MUX(4);  //pin36, PTC9,   I2S0_RX_BCLK
                CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
                CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
            #endif
            I2S0_RCSR=0;
     4fc:	ldr	r0, [pc, #216]	; (5d8 <acq_init(int)+0xe4>)
        I2S0_TCSR = I2S_TCSR_SR;
        I2S0_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;

    #endif
    // configuration of DMA
            dma.TCD->SADDR = &I2S0_RDR0;
     4fe:	ldr	r4, [pc, #220]	; (5dc <acq_init(int)+0xe8>)
            dma.TCD->SOFF = 0;
            dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
            dma.TCD->NBYTES_MLOFFNO = 4;
            dma.TCD->SLAST = 0;
            dma.TCD->DADDR = tdm_rx_buffer;
     500:	ldr	r5, [pc, #220]	; (5e0 <acq_init(int)+0xec>)
        void acq_init(int fsamp)
        {   
            acq_startClocks();

            #if I2S_CONFIG==0
                CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK
     502:	mov.w	r3, #1536	; 0x600
     506:	str	r3, [r2, #0]
                CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK
     508:	str.w	r3, [r2, #-12]
                CORE_PIN23_CONFIG = PORT_PCR_MUX(6); // pin 23, PTC2, I2S0_TX_FS (LRCLK)
     50c:	str.w	r3, [r2, #-16]
                CORE_PIN13_CONFIG = PORT_PCR_MUX(4);  //pin 13, PTC5,  I2S0_RXD0
     510:	ldr	r3, [pc, #208]	; (5e4 <acq_init(int)+0xf0>)
     512:	mov.w	r2, #1024	; 0x400
     516:	str	r2, [r3, #0]
                CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
            #endif
            I2S0_RCSR=0;

    #if 1 // I2S_SLAVE
            I2S0_RMR=0; // enable receiver mask
     518:	sub.w	r3, r3, #114176	; 0x1be00
     51c:	sub.w	r3, r3, #308	; 0x134
                CORE_PIN35_CONFIG = PORT_PCR_MUX(4) | PORT_PCR_SRE | PORT_PCR_DSE;  //pin35, PTC8,   I2S0_MCLK (SLEW rate (SRE)?)
                CORE_PIN36_CONFIG = PORT_PCR_MUX(4);  //pin36, PTC9,   I2S0_RX_BCLK
                CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
                CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
            #endif
            I2S0_RCSR=0;
     520:	movs	r1, #0

    #if 1 // I2S_SLAVE
            I2S0_RMR=0; // enable receiver mask
            I2S0_RCR1 = I2S_RCR1_RFW(3); 
     522:	movs	r2, #3
                CORE_PIN35_CONFIG = PORT_PCR_MUX(4) | PORT_PCR_SRE | PORT_PCR_DSE;  //pin35, PTC8,   I2S0_MCLK (SLEW rate (SRE)?)
                CORE_PIN36_CONFIG = PORT_PCR_MUX(4);  //pin36, PTC9,   I2S0_RX_BCLK
                CORE_PIN37_CONFIG = PORT_PCR_MUX(4);  //pin37, PTC10,  I2S0_RX_FS
                CORE_PIN27_CONFIG = PORT_PCR_MUX(6);  //pin27, PTA15,  I2S0_RXD0
            #endif
            I2S0_RCSR=0;
     524:	str	r1, [r0, #0]

    #if 1 // I2S_SLAVE
            I2S0_RMR=0; // enable receiver mask
     526:	str	r1, [r3, #0]
            I2S0_RCR1 = I2S_RCR1_RFW(3); 
     528:	str.w	r2, [r3, #-92]

            I2S0_RCR2 = I2S_RCR2_SYNC(0) 
                        | I2S_RCR2_BCP ;
     52c:	mov.w	r2, #33554432	; 0x2000000
     530:	str.w	r2, [r3, #-88]
                        
            I2S0_RCR3 = I2S_RCR3_RCE; // single rx channel
     534:	mov.w	r2, #65536	; 0x10000
     538:	str.w	r2, [r3, #-84]

            I2S0_RCR4 = I2S_RCR4_FRSZ((NCHAN_I2S-1)) 
                        | I2S_RCR4_FSE  // frame sync early
                        | I2S_RCR4_MF;
     53c:	adds	r2, #24
     53e:	str.w	r2, [r3, #-80]
            #if ADC_STEREO
                I2S0_RCR4 |=  I2S_RCR4_SYWD(31);
     542:	ldr.w	r2, [r3, #-80]
     546:	orr.w	r2, r2, #7936	; 0x1f00
     54a:	str.w	r2, [r3, #-80]
            #endif
            
            I2S0_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);
     54e:	ldr	r2, [pc, #152]	; (5e8 <acq_init(int)+0xf4>)
     550:	str.w	r2, [r3, #-76]
        I2S0_TCSR = I2S_TCSR_SR;
        I2S0_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;

    #endif
    // configuration of DMA
            dma.TCD->SADDR = &I2S0_RDR0;
     554:	ldr	r2, [pc, #148]	; (5ec <acq_init(int)+0xf8>)
     556:	ldr	r3, [r2, #0]
     558:	str	r4, [r3, #0]
            dma.TCD->SOFF = 0;
            dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
     55a:	movw	r4, #514	; 0x202
     55e:	strh	r4, [r3, #6]
            dma.TCD->NBYTES_MLOFFNO = 4;
     560:	movs	r4, #4
     562:	str	r4, [r3, #8]
            dma.TCD->SLAST = 0;
            dma.TCD->DADDR = tdm_rx_buffer;
            dma.TCD->DOFF = 4;
     564:	strh	r4, [r3, #20]
            dma.TCD->CITER_ELINKNO = 2*NBUF_I2S;
     566:	mov.w	r4, #512	; 0x200
            dma.TCD->SADDR = &I2S0_RDR0;
            dma.TCD->SOFF = 0;
            dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
            dma.TCD->NBYTES_MLOFFNO = 4;
            dma.TCD->SLAST = 0;
            dma.TCD->DADDR = tdm_rx_buffer;
     56a:	str	r5, [r3, #16]
        I2S0_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;

    #endif
    // configuration of DMA
            dma.TCD->SADDR = &I2S0_RDR0;
            dma.TCD->SOFF = 0;
     56c:	strh	r1, [r3, #4]
            dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
            dma.TCD->NBYTES_MLOFFNO = 4;
            dma.TCD->SLAST = 0;
            dma.TCD->DADDR = tdm_rx_buffer;
            dma.TCD->DOFF = 4;
            dma.TCD->CITER_ELINKNO = 2*NBUF_I2S;
     56e:	strh	r4, [r3, #22]
            dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
     570:	ldr	r5, [pc, #124]	; (5f0 <acq_init(int)+0xfc>)
            dma.TCD->BITER_ELINKNO = 2*NBUF_I2S;
     572:	strh	r4, [r3, #30]
            dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
     574:	movs	r4, #6
     576:	strh	r4, [r3, #28]
    // configuration of DMA
            dma.TCD->SADDR = &I2S0_RDR0;
            dma.TCD->SOFF = 0;
            dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(2) | DMA_TCD_ATTR_DSIZE(2);
            dma.TCD->NBYTES_MLOFFNO = 4;
            dma.TCD->SLAST = 0;
     578:	str	r1, [r3, #12]
            dma.TCD->DADDR = tdm_rx_buffer;
            dma.TCD->DOFF = 4;
            dma.TCD->CITER_ELINKNO = 2*NBUF_I2S;
            dma.TCD->DLASTSGA = -sizeof(tdm_rx_buffer);
     57a:	str	r5, [r3, #24]
	// 32 bits.  If a channel is configured for 200 transfers

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
     57c:	ldrb	r3, [r2, #4]
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void attachInterrupt(void (*isr)(void), uint8_t prio) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
     57e:	ldr	r4, [pc, #116]	; (5f4 <acq_init(int)+0x100>)
	// 32 bits.  If a channel is configured for 200 transfers

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint8_t *mux;
		mux = (volatile uint8_t *)&(DMAMUX0_CHCFG0) + channel;
     580:	add.w	r3, r3, #1073741824	; 0x40000000
     584:	add.w	r3, r3, #135168	; 0x21000
		*mux = 0;
     588:	strb	r1, [r3, #0]
		*mux = (source & 63) | DMAMUX_ENABLE;
     58a:	movs	r1, #140	; 0x8c
     58c:	strb	r1, [r3, #0]
            dma.TCD->BITER_ELINKNO = 2*NBUF_I2S;
            dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
            //
            dma.triggerAtHardwareEvent(DMAMUX_SOURCE_I2S0_RX);
            NVIC_SET_PRIORITY(DMAMUX_SOURCE_I2S0_RX,I2S_SAI_PRIO);
     58e:	ldr	r3, [pc, #104]	; (5f8 <acq_init(int)+0x104>)
     590:	movs	r1, #64	; 0x40
     592:	strb	r1, [r3, #0]
            //
            I2S0_RCSR =  I2S_RCSR_FRDE | I2S_RCSR_FR;
     594:	ldr	r3, [pc, #100]	; (5fc <acq_init(int)+0x108>)
     596:	str	r3, [r0, #0]
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void attachInterrupt(void (*isr)(void), uint8_t prio) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
     598:	ldrb	r1, [r2, #4]
     59a:	ldr	r3, [pc, #100]	; (600 <acq_init(int)+0x10c>)
     59c:	add.w	r0, r1, #16
     5a0:	str.w	r4, [r3, r0, lsl #2]
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
     5a4:	asrs	r3, r1, #5
     5a6:	lsls	r3, r3, #2
     5a8:	add.w	r3, r3, #3758096384	; 0xe0000000
     5ac:	add.w	r3, r3, #57600	; 0xe100
     5b0:	and.w	r1, r1, #31
     5b4:	movs	r0, #1
     5b6:	lsl.w	r1, r0, r1
     5ba:	str	r1, [r3, #0]
		NVIC_SET_PRIORITY(IRQ_DMA_CH0 + channel, prio);
     5bc:	ldrb	r3, [r2, #4]
     5be:	add.w	r3, r3, #3758096384	; 0xe0000000
     5c2:	add.w	r3, r3, #58368	; 0xe400
     5c6:	movs	r1, #80	; 0x50
     5c8:	strb	r1, [r3, #0]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
     5ca:	ldr	r3, [pc, #56]	; (604 <acq_init(int)+0x110>)
     5cc:	ldrb	r2, [r2, #4]
     5ce:	strb	r2, [r3, #0]
     5d0:	pop	{r3, r4, r5, pc}
     5d2:	nop
     5d4:	.word	0x4004b018
     5d8:	.word	0x4002f080
     5dc:	.word	0x4002f0a0
     5e0:	.word	0x1fff0200
     5e4:	.word	0x4004b014
     5e8:	.word	0x1f1f1f00
     5ec:	.word	0x1fff21ec
     5f0:	.word	0xfffff800
     5f4:	.word	0x00000629
     5f8:	.word	0xe000e40c
     5fc:	.word	0x02000001
     600:	.word	0x1fff0a00
     604:	.word	0x4000801b

00000608 <extract(void*, void*)>:


const int adc_shift=8;
#if ADC_STEREO // have stereo I2S
    void extract(void *out, void *inp)
    {   
     608:	push	{r4, lr}
     60a:	movs	r3, #0
        int32_t *dout = (int32_t *) out;
        int32_t *din  = (int32_t *) inp;
        for(int ii=0; ii < NSAMP; ii++)
        {   dout[0+ii*NCHAN_ACQ] = din[0+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     60c:	ldr	r2, [r1, r3]
     60e:	asrs	r2, r2, #8
     610:	str	r2, [r0, r3]
            dout[1+ii*NCHAN_ACQ] = din[1+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     612:	adds	r2, r1, r3
     614:	adds	r4, r0, r3
     616:	ldr	r2, [r2, #4]
     618:	adds	r3, #8
     61a:	asrs	r2, r2, #8
#if ADC_STEREO // have stereo I2S
    void extract(void *out, void *inp)
    {   
        int32_t *dout = (int32_t *) out;
        int32_t *din  = (int32_t *) inp;
        for(int ii=0; ii < NSAMP; ii++)
     61c:	cmp.w	r3, #1024	; 0x400
        {   dout[0+ii*NCHAN_ACQ] = din[0+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
            dout[1+ii*NCHAN_ACQ] = din[1+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
     620:	str	r2, [r4, #4]
#if ADC_STEREO // have stereo I2S
    void extract(void *out, void *inp)
    {   
        int32_t *dout = (int32_t *) out;
        int32_t *din  = (int32_t *) inp;
        for(int ii=0; ii < NSAMP; ii++)
     622:	bne.n	60c <extract(void*, void*)+0x4>
        {   dout[0+ii*NCHAN_ACQ] = din[0+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
            dout[1+ii*NCHAN_ACQ] = din[1+ii*NPORT_I2S*NCHAN_I2S]>>adc_shift;
        }
    }
     624:	pop	{r4, pc}
     626:	Address 0x00000626 is out of bounds.


00000628 <acq_isr()>:
        }
    }
#endif

    void acq_isr(void)
    {
     628:	push	{r3, lr}
     62a:	ldr	r3, [pc, #60]	; (668 <acq_isr()+0x40>)
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
     62c:	ldr	r2, [pc, #60]	; (66c <acq_isr()+0x44>)
     62e:	ldrb	r1, [r3, #4]
     630:	strb	r1, [r2, #0]
        uint32_t daddr;
        uint32_t *src;

        dma.clearInterrupt();
        asm volatile("dsb");
     632:	dsb	sy
     636:	ldr	r3, [r3, #0]

        #if IMXRT_CACHE_ENABLED >=1
            arm_dcache_delete((void*)src, sizeof(tdm_rx_buffer) / 2);
        #endif

        extract((void *) acq_rx_buffer, (void *) src);
     638:	ldr	r0, [pc, #52]	; (670 <acq_isr()+0x48>)
	}
	void * sourceAddress(void) {
		return (void *)(TCD->SADDR);
	}
	void * destinationAddress(void) {
		return (void *)(TCD->DADDR);
     63a:	ldr	r1, [r3, #16]

        dma.clearInterrupt();
        asm volatile("dsb");
        daddr = (uint32_t) dma.destinationAddress();

        if (daddr < (uint32_t) &tdm_rx_buffer[NBUF_I2S]) {
     63c:	ldr	r3, [pc, #52]	; (674 <acq_isr()+0x4c>)
            // need to remove data from the second half
            src = &tdm_rx_buffer[NBUF_I2S];
        } else {
            // DMA is receiving to the second half of the buffer
            // need to remove data from the first half
            src = &tdm_rx_buffer[0];
     63e:	sub.w	r2, r3, #1024	; 0x400

        #if IMXRT_CACHE_ENABLED >=1
            arm_dcache_delete((void*)src, sizeof(tdm_rx_buffer) / 2);
        #endif

        extract((void *) acq_rx_buffer, (void *) src);
     642:	cmp	r1, r3
     644:	ite	cc
     646:	movcc	r1, r3
     648:	movcs	r1, r2
     64a:	bl	608 <extract(void*, void*)>
        if(!pushData(acq_rx_buffer)) acq_miss++;
     64e:	ldr	r0, [pc, #32]	; (670 <acq_isr()+0x48>)
     650:	bl	1a78 <pushData(unsigned long*)>
     654:	cbnz	r0, 65e <acq_isr()+0x36>
     656:	ldr	r2, [pc, #32]	; (678 <acq_isr()+0x50>)
     658:	ldr	r3, [r2, #0]
     65a:	adds	r3, #1
     65c:	str	r3, [r2, #0]
        acq_count++;
     65e:	ldr	r2, [pc, #28]	; (67c <acq_isr()+0x54>)
     660:	ldr	r3, [r2, #0]
     662:	adds	r3, #1
     664:	str	r3, [r2, #0]
     666:	pop	{r3, pc}
     668:	.word	0x1fff21ec
     66c:	.word	0x4000801f
     670:	.word	0x1fff1dec
     674:	.word	0x1fff0600
     678:	.word	0x1fff1de8
     67c:	.word	0x1fff1de4

00000680 <_GLOBAL__sub_I_acq_count>:
    }
     680:	push	{r4, lr}
	/*************************************************/
	/**    Channel Allocation                       **/
	/*************************************************/

	DMAChannel() {
		begin();
     682:	ldr	r4, [pc, #24]	; (69c <_GLOBAL__sub_I_acq_count+0x1c>)
     684:	movs	r1, #0
     686:	mov	r0, r4
     688:	bl	9f30 <DMAChannel::begin(bool)>

#define I2S_MASTER 0

/********************************************************************************/
#include "DMAChannel.h"
static DMAChannel dma;
     68c:	mov	r0, r4
     68e:	ldr	r2, [pc, #16]	; (6a0 <_GLOBAL__sub_I_acq_count+0x20>)
     690:	ldr	r1, [pc, #16]	; (6a4 <_GLOBAL__sub_I_acq_count+0x24>)
        #endif

        extract((void *) acq_rx_buffer, (void *) src);
        if(!pushData(acq_rx_buffer)) acq_miss++;
        acq_count++;
    }
     692:	ldmia.w	sp!, {r4, lr}

#define I2S_MASTER 0

/********************************************************************************/
#include "DMAChannel.h"
static DMAChannel dma;
     696:	b.w	a428 <__aeabi_atexit>
     69a:	nop
     69c:	.word	0x1fff21ec
     6a0:	.word	0x1fff0f30
     6a4:	.word	0x0000046d

000006a8 <Print::write(char const*)>:
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     6a8:	push	{r4, r5, r6, lr}
     6aa:	mov	r4, r0
     6ac:	mov	r0, r1
     6ae:	mov	r5, r1
     6b0:	bl	be80 <strlen>
     6b4:	ldr	r3, [r4, #0]
     6b6:	mov	r2, r0
     6b8:	mov	r1, r5
     6ba:	mov	r0, r4
     6bc:	ldr	r3, [r3, #4]
     6be:	ldmia.w	sp!, {r4, r5, r6, lr}
     6c2:	bx	r3

000006c4 <Print::print(unsigned long)>:

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
     6c4:	movs	r3, #0
     6c6:	movs	r2, #10
     6c8:	b.w	a0fa <Print::printNumber(unsigned long, unsigned char, unsigned char)>

000006cc <Print::println(char const*)>:
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     6cc:	push	{r3, r4, r5, lr}
     6ce:	mov	r5, r0
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
     6d0:	bl	6a8 <Print::write(char const*)>
     6d4:	mov	r4, r0
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     6d6:	mov	r0, r5
     6d8:	bl	a0c0 <Print::println()>
     6dc:	add	r0, r4
     6de:	pop	{r3, r4, r5, pc}

000006e0 <checkToCloseFile(short, unsigned long)>:

/* check if we should close file */
int t_acq = 60; // close file on the minute

int16_t checkToCloseFile(int16_t status, uint32_t t_acq)
{ if((status == OPENED) || (status == RUNNING))
     6e0:	push	{r3, r4, r5, lr}
     6e2:	subs	r3, r0, #1
     6e4:	uxth	r3, r3
     6e6:	cmp	r3, #1
     6e8:	mov	r5, r0
     6ea:	mov	r4, r1
     6ec:	bhi.n	706 <checkToCloseFile(short, unsigned long)+0x26>
  { //
    static uint32_t to =0;
    uint32_t tx=rtc_get();
     6ee:	bl	9344 <rtc_get>
    tx %= t_acq;
    if(tx<to) status = DOCLOSE; // time wrapped, file must be closed
     6f2:	ldr	r3, [pc, #24]	; (70c <checkToCloseFile(short, unsigned long)+0x2c>)
int16_t checkToCloseFile(int16_t status, uint32_t t_acq)
{ if((status == OPENED) || (status == RUNNING))
  { //
    static uint32_t to =0;
    uint32_t tx=rtc_get();
    tx %= t_acq;
     6f4:	udiv	r1, r0, r4
    if(tx<to) status = DOCLOSE; // time wrapped, file must be closed
     6f8:	ldr	r2, [r3, #0]
int16_t checkToCloseFile(int16_t status, uint32_t t_acq)
{ if((status == OPENED) || (status == RUNNING))
  { //
    static uint32_t to =0;
    uint32_t tx=rtc_get();
    tx %= t_acq;
     6fa:	mls	r0, r1, r4, r0
    if(tx<to) status = DOCLOSE; // time wrapped, file must be closed
     6fe:	cmp	r0, r2
     700:	it	cc
     702:	movcc	r5, #3
    to=tx;
     704:	str	r0, [r3, #0]
  } 
  return status;
}
     706:	mov	r0, r5
     708:	pop	{r3, r4, r5, pc}
     70a:	nop
     70c:	.word	0x1fff21f8

00000710 <setup>:

void setup()
{
     710:	push	{r3, r4, r5, lr}
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     712:	ldr	r0, [pc, #92]	; (770 <setup+0x60>)
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     714:	ldr	r4, [pc, #92]	; (774 <setup+0x64>)
     716:	ldr	r5, [pc, #96]	; (778 <setup+0x68>)
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     718:	ldr	r1, [pc, #96]	; (77c <setup+0x6c>)
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     71a:	ldrb	r3, [r4, #0]
     71c:	cmp	r3, #0
     71e:	beq.n	71a <setup+0xa>
     720:	ldrb	r3, [r5, #0]
     722:	lsls	r3, r3, #31
     724:	bpl.n	71a <setup+0xa>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
     726:	ldr	r3, [r0, #0]
     728:	ldr	r2, [r1, #0]
        uint8_t stopbits(void) { uint8_t b = usb_cdc_line_coding[1]; if (!b) b = 1; return b; }
        uint8_t paritytype(void) { return usb_cdc_line_coding[1] >> 8; } // 0=none, 1=odd, 2=even
        uint8_t numbits(void) { return usb_cdc_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() { return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
     72a:	subs	r3, r3, r2
     72c:	cmp	r3, #14
     72e:	bls.n	71a <setup+0xa>
  while(!Serial) continue;
  Serial.println("basic Sound Recorder Version: " __DATE__  " " __TIME__ );
     730:	ldr	r1, [pc, #76]	; (780 <setup+0x70>)
     732:	ldr	r0, [pc, #80]	; (784 <setup+0x74>)
     734:	bl	6cc <Print::println(char const*)>
  SerNum = getTeensySerial();
     738:	bl	1434 <getTeensySerial()>
     73c:	ldr	r3, [pc, #72]	; (788 <setup+0x78>)
     73e:	mov	r1, r0
	size_t print(uint64_t n)			{ return printNumber64(n, 10, 0); }

	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
     740:	movs	r2, #16
     742:	str	r0, [r3, #0]
     744:	movs	r3, #0
     746:	ldr	r0, [pc, #60]	; (784 <setup+0x74>)
     748:	bl	a0fa <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	size_t println(uint64_t n)			{ return print(n) + println(); }

	size_t println(unsigned char n, int base)	{ return print(n, base) + println(); }
	size_t println(int n, int base)			{ return print(n, base) + println(); }
	size_t println(unsigned int n, int base)	{ return print(n, base) + println(); }
	size_t println(long n, int base)		{ return print(n, base) + println(); }
     74c:	ldr	r0, [pc, #52]	; (784 <setup+0x74>)
     74e:	bl	a0c0 <Print::println()>
  Serial.println((int32_t)SerNum,HEX);

  storage_configure();
     752:	bl	1b28 <storage_configure()>

  adc_init();
     756:	bl	22d6 <adc_init()>
  acq_init(fsamp);
     75a:	ldr	r3, [pc, #48]	; (78c <setup+0x7c>)
     75c:	ldr	r0, [r3, #0]
     75e:	bl	4f4 <acq_init(int)>
  adc_enable();
     762:	bl	22dc <adc_enable()>

  #if START_MODE==CLOSED
    acq_start(); 
  #endif

  Serial.println("End of Setup");
     766:	ldr	r1, [pc, #40]	; (790 <setup+0x80>)
     768:	ldr	r0, [pc, #24]	; (784 <setup+0x74>)
     76a:	bl	6cc <Print::println(char const*)>
     76e:	pop	{r3, r4, r5, pc}
     770:	.word	0x2001cf20
     774:	.word	0x2001d003
     778:	.word	0x2001cf1c
     77c:	.word	0x2001d074
     780:	.word	0x000123b0
     784:	.word	0x1fff136c
     788:	.word	0x1fff222c
     78c:	.word	0x2001c9e0
     790:	.word	0x000123e3

00000794 <loop>:
}

void loop()
{ static int16_t status=START_MODE; 
     794:	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}

  if(status==MUST_REBOOT) status=checkReboot(); // hapens only if microSD card write fails: reboot if space on disk
     798:	ldr	r4, [pc, #328]	; (8e4 <loop+0x150>)
     79a:	ldrsh.w	r3, [r4]
     79e:	adds	r3, #2
     7a0:	bne.n	7a8 <loop+0x14>
     7a2:	bl	1d94 <checkReboot()>
     7a6:	strh	r0, [r4, #0]

  // normal operation
  int16_t ch=menu();  // check if we have serial line command (0: no input; 1: start; -1: stop)
     7a8:	bl	1280 <menu()>

  if(ch>0 && status==STOPPED)  // was stopped, should run now 
     7ac:	cmp	r0, #0
     7ae:	ble.n	7c8 <loop+0x34>
     7b0:	ldrsh.w	r3, [r4]
     7b4:	adds	r3, #1
     7b6:	bne.n	7dc <loop+0x48>
  { 
    status=CLOSED; acq_start(); adcStatus();
     7b8:	ldr	r3, [pc, #296]	; (8e4 <loop+0x150>)
     7ba:	movs	r2, #0
     7bc:	strh	r2, [r3, #0]
     7be:	bl	4c8 <acq_start()>
     7c2:	bl	22d8 <adcStatus()>
     7c6:	b.n	7dc <loop+0x48>
  }  
  
  if(ch<0 && status>=CLOSED)  // was running, should stop now
     7c8:	beq.n	7dc <loop+0x48>
     7ca:	ldrsh.w	r3, [r4]
     7ce:	cmp	r3, #0
     7d0:	blt.n	7dc <loop+0x48>
  { 
    status=MUSTSTOP;  acq_stop();  
     7d2:	ldr	r3, [pc, #272]	; (8e4 <loop+0x150>)
     7d4:	movs	r2, #4
     7d6:	strh	r2, [r3, #0]
     7d8:	bl	4e0 <acq_stop()>
  } 

  if(status > CLOSED) // RUNNING
     7dc:	ldrsh.w	r0, [r4]
     7e0:	cmp	r0, #0
     7e2:	ble.n	7f0 <loop+0x5c>
  {
    status = checkToCloseFile(status, (uint32_t) t_acq); // check if we reached file size or aquisition time
     7e4:	ldr	r3, [pc, #256]	; (8e8 <loop+0x154>)
     7e6:	ldr	r1, [r3, #0]
     7e8:	bl	6e0 <checkToCloseFile(short, unsigned long)>
     7ec:	ldr	r3, [pc, #244]	; (8e4 <loop+0x150>)
     7ee:	strh	r0, [r3, #0]
  }

  if(status >= CLOSED) // NOT STOPPED
     7f0:	ldrsh.w	r3, [r4]
     7f4:	ldr	r6, [pc, #244]	; (8ec <loop+0x158>)
     7f6:	cmp	r3, #0
     7f8:	blt.n	82a <loop+0x96>
  {
    uint32_t mc = getCount();
     7fa:	bl	1a60 <getCount()>
    if(mc>max_count) max_count=mc;
     7fe:	ldr	r3, [pc, #240]	; (8f0 <loop+0x15c>)
     800:	ldr	r2, [r3, #0]
     802:	cmp	r0, r2
     804:	it	hi
     806:	strhi	r0, [r3, #0]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     808:	ldr	r3, [r6, #0]
     80a:	str	r3, [sp, #4]
    //
    uint32_t to=millis();
    status = saveData(status);  
     80c:	ldrsh.w	r0, [r4]
	return ret;
     810:	ldr	r5, [sp, #4]
     812:	bl	1d9c <saveData(short)>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     816:	ldr	r3, [r6, #0]
    uint32_t dt=millis()-to;
    if(max_write<dt) max_write=dt;
     818:	ldr	r2, [pc, #216]	; (8f4 <loop+0x160>)
     81a:	str	r3, [sp, #0]
	return ret;
     81c:	ldr	r3, [sp, #0]
     81e:	ldr	r1, [r2, #0]
  {
    uint32_t mc = getCount();
    if(mc>max_count) max_count=mc;
    //
    uint32_t to=millis();
    status = saveData(status);  
     820:	strh	r0, [r4, #0]
    uint32_t dt=millis()-to;
     822:	subs	r3, r3, r5
    if(max_write<dt) max_write=dt;
     824:	cmp	r3, r1
     826:	it	hi
     828:	strhi	r3, [r2, #0]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     82a:	ldr	r3, [r6, #0]
  }

  static uint32_t t0;
  static uint32_t loop_count=0;
  if(millis()-t0>1000)
     82c:	ldr	r2, [pc, #200]	; (8f8 <loop+0x164>)
     82e:	str	r3, [sp, #8]
	return ret;
     830:	ldr	r3, [sp, #8]
     832:	ldr	r1, [r2, #0]
     834:	ldr	r5, [pc, #196]	; (8fc <loop+0x168>)
     836:	subs	r3, r3, r1
     838:	cmp.w	r3, #1000	; 0x3e8
     83c:	mov	sl, r2
     83e:	bls.n	8d6 <loop+0x142>
  {
    if(status>=CLOSED)
     840:	ldrsh.w	r3, [r4]
     844:	ldr	r7, [pc, #168]	; (8f0 <loop+0x15c>)
     846:	ldr	r4, [pc, #172]	; (8f4 <loop+0x160>)
     848:	ldr.w	r9, [pc, #196]	; 910 <loop+0x17c>
     84c:	ldr.w	r8, [pc, #196]	; 914 <loop+0x180>
     850:	cmp	r3, #0
     852:	blt.n	8bc <loop+0x128>
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
     854:	ldr	r1, [pc, #168]	; (900 <loop+0x16c>)
     856:	ldr	r0, [pc, #172]	; (904 <loop+0x170>)
     858:	bl	6a8 <Print::write(char const*)>
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
     85c:	ldr	r3, [pc, #132]	; (8e4 <loop+0x150>)
     85e:	ldr	r0, [pc, #164]	; (904 <loop+0x170>)
     860:	ldrsh.w	r1, [r3]
     864:	bl	a170 <Print::print(long)>
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
     868:	ldr	r1, [pc, #156]	; (908 <loop+0x174>)
     86a:	ldr	r0, [pc, #152]	; (904 <loop+0x170>)
     86c:	bl	6a8 <Print::write(char const*)>
    {
      Serial.print("\nLoop: ");
        Serial.print(status);     Serial.print(" "); 
        Serial.print(loop_count); Serial.print(" : "); 
     870:	ldr	r1, [r5, #0]
     872:	ldr	r0, [pc, #144]	; (904 <loop+0x170>)
     874:	bl	6c4 <Print::print(unsigned long)>
     878:	ldr	r1, [pc, #144]	; (90c <loop+0x178>)
     87a:	ldr	r0, [pc, #136]	; (904 <loop+0x170>)
     87c:	bl	6a8 <Print::write(char const*)>
        Serial.print(acq_count);  Serial.print(" ");
     880:	ldr.w	r1, [r9]
     884:	ldr	r0, [pc, #124]	; (904 <loop+0x170>)
     886:	bl	6c4 <Print::print(unsigned long)>
     88a:	ldr	r1, [pc, #124]	; (908 <loop+0x174>)
     88c:	ldr	r0, [pc, #116]	; (904 <loop+0x170>)
     88e:	bl	6a8 <Print::write(char const*)>
        Serial.print(acq_miss);   Serial.print(" ");
     892:	ldr.w	r1, [r8]
     896:	ldr	r0, [pc, #108]	; (904 <loop+0x170>)
     898:	bl	6c4 <Print::print(unsigned long)>
     89c:	ldr	r1, [pc, #104]	; (908 <loop+0x174>)
     89e:	ldr	r0, [pc, #100]	; (904 <loop+0x170>)
     8a0:	bl	6a8 <Print::write(char const*)>
        Serial.print(max_count);  Serial.print(" ");
     8a4:	ldr	r1, [r7, #0]
     8a6:	ldr	r0, [pc, #92]	; (904 <loop+0x170>)
     8a8:	bl	6c4 <Print::print(unsigned long)>
     8ac:	ldr	r1, [pc, #88]	; (908 <loop+0x174>)
     8ae:	ldr	r0, [pc, #84]	; (904 <loop+0x170>)
     8b0:	bl	6a8 <Print::write(char const*)>
        Serial.print(max_write);
     8b4:	ldr	r1, [r4, #0]
     8b6:	ldr	r0, [pc, #76]	; (904 <loop+0x170>)
     8b8:	bl	6c4 <Print::print(unsigned long)>
    }
    loop_count=0;
     8bc:	movs	r3, #0
    acq_count=0;
     8be:	str.w	r3, [r9]
    acq_miss=0;
     8c2:	str.w	r3, [r8]
        Serial.print(acq_count);  Serial.print(" ");
        Serial.print(acq_miss);   Serial.print(" ");
        Serial.print(max_count);  Serial.print(" ");
        Serial.print(max_write);
    }
    loop_count=0;
     8c6:	str	r3, [r5, #0]
    acq_count=0;
    acq_miss=0;
    max_count=0;
     8c8:	str	r3, [r7, #0]
    max_write=0;
     8ca:	str	r3, [r4, #0]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     8cc:	ldr	r3, [r6, #0]
     8ce:	str	r3, [sp, #12]
	return ret;
     8d0:	ldr	r3, [sp, #12]
    t0=millis();
     8d2:	str.w	r3, [sl]
  }
  loop_count++;
     8d6:	ldr	r3, [r5, #0]
     8d8:	adds	r3, #1
     8da:	str	r3, [r5, #0]
     8dc:	add	sp, #16
     8de:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     8e2:	nop
     8e4:	.word	0x1fff0f34
     8e8:	.word	0x1fff0f38
     8ec:	.word	0x2001cf20
     8f0:	.word	0x1fff2200
     8f4:	.word	0x1fff21f4
     8f8:	.word	0x1fff21fc
     8fc:	.word	0x1fff2204
     900:	.word	0x000123f0
     904:	.word	0x1fff136c
     908:	.word	0x000123fa
     90c:	.word	0x000123f8
     910:	.word	0x1fff1de4
     914:	.word	0x1fff1de8

00000918 <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
     918:	movs	r0, #0
     91a:	bx	lr

0000091c <Print::flush()>:
	virtual void flush()				{ }
     91c:	bx	lr

0000091e <File::write(unsigned char const*, unsigned int)>:
		return (f) ? f->read(buf, nbyte) : 0;
	}
	
	// override print version
	virtual size_t write(const uint8_t *buf, size_t size) {
		return (f) ? f->write((void*)buf, size) : 0;
     91e:	ldr	r0, [r0, #16]
     920:	cbz	r0, 928 <File::write(unsigned char const*, unsigned int)+0xa>
     922:	ldr	r3, [r0, #0]
     924:	ldr	r3, [r3, #12]
     926:	bx	r3
	}
     928:	bx	lr

0000092a <File::available()>:

	size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
	}
	int available() {
		return (f) ? f->available() : 0;
     92a:	ldr	r0, [r0, #16]
     92c:	cbz	r0, 934 <File::available()+0xa>
     92e:	ldr	r3, [r0, #0]
     930:	ldr	r3, [r3, #16]
     932:	bx	r3
	}
     934:	bx	lr

00000936 <File::peek()>:
	int peek() {
		return (f) ? f->peek() : -1;
     936:	ldr	r0, [r0, #16]
     938:	cbz	r0, 940 <File::peek()+0xa>
     93a:	ldr	r3, [r0, #0]
     93c:	ldr	r3, [r3, #20]
     93e:	bx	r3
	}
     940:	mov.w	r0, #4294967295
     944:	bx	lr

00000946 <File::flush()>:
	void flush() {
		if (f) f->flush();
     946:	ldr	r0, [r0, #16]
     948:	cbz	r0, 950 <File::flush()+0xa>
     94a:	ldr	r3, [r0, #0]
     94c:	ldr	r3, [r3, #24]
     94e:	bx	r3
     950:	bx	lr

00000952 <File::read()>:
		return (f) ? f->setModifyTime(tm) : false;
	}
	bool seek(uint64_t pos) {
		return seek(pos, SeekSet);
	}
	int read() {
     952:	push	{r0, r1, r2, lr}
		if (!f) return -1;
     954:	ldr	r0, [r0, #16]
     956:	cbnz	r0, 95e <File::read()+0xc>
     958:	mov.w	r0, #4294967295
     95c:	b.n	972 <File::read()+0x20>
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
     95e:	ldr	r3, [r0, #0]
     960:	movs	r2, #1
     962:	ldr	r3, [r3, #8]
     964:	add.w	r1, sp, #7
     968:	blx	r3
     96a:	cmp	r0, #0
     96c:	beq.n	958 <File::read()+0x6>
		return b;
     96e:	ldrb.w	r0, [sp, #7]
	}
     972:	add	sp, #12
     974:	ldr.w	pc, [sp], #4

00000978 <File::write(unsigned char)>:
	size_t write(uint8_t b) {
     978:	push	{r0, r1, r2, lr}
		return (f) ? f->write(&b, 1) : 0;
     97a:	ldr	r0, [r0, #16]
		if (!f) return -1;
		unsigned char b;
		if (f->read(&b, 1) < 1) return -1;
		return b;
	}
	size_t write(uint8_t b) {
     97c:	strb.w	r1, [sp, #7]
		return (f) ? f->write(&b, 1) : 0;
     980:	cbz	r0, 98e <File::write(unsigned char)+0x16>
     982:	ldr	r3, [r0, #0]
     984:	movs	r2, #1
     986:	ldr	r3, [r3, #12]
     988:	add.w	r1, sp, #7
     98c:	blx	r3
	}
     98e:	add	sp, #12
     990:	ldr.w	pc, [sp], #4

00000994 <SDFile::getCreateTime(DateTimeFields&)>:
		return File();
	}
	virtual void rewindDirectory(void) {
		sdfatfile.rewindDirectory();
	}
	virtual bool getCreateTime(DateTimeFields &tm) {
     994:	push	{r0, r1, r4, lr}
     996:	mov	r3, r0
   * \param[out] ptime Packed time for directory entry.
   *
   * \return true for success or false for failure.
   */
  bool getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    return m_fFile ? m_fFile->getCreateDateTime(pdate, ptime) :
     998:	ldr	r0, [r0, #80]	; 0x50
     99a:	mov	r4, r1
           m_xFile ? m_xFile->getCreateDateTime(pdate, ptime) : false;
     99c:	cbz	r0, 9aa <SDFile::getCreateTime(DateTimeFields&)+0x16>
     99e:	add.w	r2, sp, #6
     9a2:	add	r1, sp, #4
     9a4:	bl	62b2 <FatFile::getCreateDateTime(unsigned short*, unsigned short*)>
     9a8:	b.n	9bc <SDFile::getCreateTime(DateTimeFields&)+0x28>
     9aa:	ldr	r0, [r3, #84]	; 0x54
     9ac:	cbnz	r0, 9b2 <SDFile::getCreateTime(DateTimeFields&)+0x1e>
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getCreateDateTime(&fat_date, &fat_time)) return false;
     9ae:	movs	r0, #0
     9b0:	b.n	9f6 <SDFile::getCreateTime(DateTimeFields&)+0x62>
     9b2:	add.w	r2, sp, #6
     9b6:	add	r1, sp, #4
     9b8:	bl	3fbe <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)>
     9bc:	cmp	r0, #0
     9be:	beq.n	9ae <SDFile::getCreateTime(DateTimeFields&)+0x1a>
		if ((fat_date == 0) && (fat_time == 0)) return false;
     9c0:	ldrh.w	r3, [sp, #4]
     9c4:	ldrh.w	r2, [sp, #6]
     9c8:	cbnz	r3, 9ce <SDFile::getCreateTime(DateTimeFields&)+0x3a>
     9ca:	cmp	r2, #0
     9cc:	beq.n	9ae <SDFile::getCreateTime(DateTimeFields&)+0x1a>
		tm.sec = FS_SECOND(fat_time);
     9ce:	and.w	r1, r2, #31
     9d2:	lsls	r1, r1, #1
     9d4:	strb	r1, [r4, #0]
		tm.min = FS_MINUTE(fat_time);
     9d6:	ubfx	r1, r2, #5, #6
		tm.hour = FS_HOUR(fat_time);
     9da:	asrs	r2, r2, #11
     9dc:	strb	r2, [r4, #2]
		tm.mday = FS_DAY(fat_date);
     9de:	and.w	r2, r3, #31
     9e2:	strb	r2, [r4, #4]
		tm.mon = FS_MONTH(fat_date) - 1;
     9e4:	ubfx	r2, r3, #5, #4
		tm.year = FS_YEAR(fat_date) - 1900;
     9e8:	asrs	r3, r3, #9
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     9ea:	subs	r2, #1
		tm.year = FS_YEAR(fat_date) - 1900;
     9ec:	add.w	r3, r3, #1872	; 0x750
	virtual bool getCreateTime(DateTimeFields &tm) {
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getCreateDateTime(&fat_date, &fat_time)) return false;
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
     9f0:	strb	r1, [r4, #1]
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     9f2:	strb	r2, [r4, #5]
		tm.year = FS_YEAR(fat_date) - 1900;
     9f4:	strb	r3, [r4, #6]
		return true;
	}
     9f6:	add	sp, #8
     9f8:	pop	{r4, pc}

000009fa <SDFile::getModifyTime(DateTimeFields&)>:
	virtual bool getModifyTime(DateTimeFields &tm) {
     9fa:	push	{r0, r1, r4, lr}
     9fc:	mov	r3, r0
   * \param[out] ptime Packed time for directory entry.
   *
   * \return true for success or false for failure.
   */
  bool getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    return m_fFile ? m_fFile->getModifyDateTime(pdate, ptime) :
     9fe:	ldr	r0, [r0, #80]	; 0x50
     a00:	mov	r4, r1
           m_xFile ? m_xFile->getModifyDateTime(pdate, ptime) : false;
     a02:	cbz	r0, a10 <SDFile::getModifyTime(DateTimeFields&)+0x16>
     a04:	add.w	r2, sp, #6
     a08:	add	r1, sp, #4
     a0a:	bl	62d2 <FatFile::getModifyDateTime(unsigned short*, unsigned short*)>
     a0e:	b.n	a22 <SDFile::getModifyTime(DateTimeFields&)+0x28>
     a10:	ldr	r0, [r3, #84]	; 0x54
     a12:	cbnz	r0, a18 <SDFile::getModifyTime(DateTimeFields&)+0x1e>
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getModifyDateTime(&fat_date, &fat_time)) return false;
     a14:	movs	r0, #0
     a16:	b.n	a5c <SDFile::getModifyTime(DateTimeFields&)+0x62>
     a18:	add.w	r2, sp, #6
     a1c:	add	r1, sp, #4
     a1e:	bl	3fde <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)>
     a22:	cmp	r0, #0
     a24:	beq.n	a14 <SDFile::getModifyTime(DateTimeFields&)+0x1a>
		if ((fat_date == 0) && (fat_time == 0)) return false;
     a26:	ldrh.w	r3, [sp, #4]
     a2a:	ldrh.w	r2, [sp, #6]
     a2e:	cbnz	r3, a34 <SDFile::getModifyTime(DateTimeFields&)+0x3a>
     a30:	cmp	r2, #0
     a32:	beq.n	a14 <SDFile::getModifyTime(DateTimeFields&)+0x1a>
		tm.sec = FS_SECOND(fat_time);
     a34:	and.w	r1, r2, #31
     a38:	lsls	r1, r1, #1
     a3a:	strb	r1, [r4, #0]
		tm.min = FS_MINUTE(fat_time);
     a3c:	ubfx	r1, r2, #5, #6
		tm.hour = FS_HOUR(fat_time);
     a40:	asrs	r2, r2, #11
     a42:	strb	r2, [r4, #2]
		tm.mday = FS_DAY(fat_date);
     a44:	and.w	r2, r3, #31
     a48:	strb	r2, [r4, #4]
		tm.mon = FS_MONTH(fat_date) - 1;
     a4a:	ubfx	r2, r3, #5, #4
		tm.year = FS_YEAR(fat_date) - 1900;
     a4e:	asrs	r3, r3, #9
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     a50:	subs	r2, #1
		tm.year = FS_YEAR(fat_date) - 1900;
     a52:	add.w	r3, r3, #1872	; 0x750
	virtual bool getModifyTime(DateTimeFields &tm) {
		uint16_t fat_date, fat_time;
		if (!sdfatfile.getModifyDateTime(&fat_date, &fat_time)) return false;
		if ((fat_date == 0) && (fat_time == 0)) return false;
		tm.sec = FS_SECOND(fat_time);
		tm.min = FS_MINUTE(fat_time);
     a56:	strb	r1, [r4, #1]
		tm.hour = FS_HOUR(fat_time);
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
     a58:	strb	r2, [r4, #5]
		tm.year = FS_YEAR(fat_date) - 1900;
     a5a:	strb	r3, [r4, #6]
		return true;
	}
     a5c:	add	sp, #8
     a5e:	pop	{r4, pc}

00000a60 <SDFile::name()>:
		}
	}
	virtual bool isOpen() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
     a60:	push	{r3, r4, r5, lr}
		if (!filename) {
     a62:	ldr	r5, [r0, #88]	; 0x58
		}
	}
	virtual bool isOpen() {
		return sdfatfile.isOpen();
	}
	virtual const char * name() {
     a64:	mov	r4, r0
		if (!filename) {
     a66:	cbnz	r5, a98 <SDFile::name()+0x38>
			filename = (char *)malloc(MAX_FILENAME_LEN);
     a68:	mov.w	r0, #256	; 0x100
     a6c:	bl	b21c <malloc>
     a70:	mov	r1, r0
     a72:	str	r0, [r4, #88]	; 0x58
			if (filename) {
     a74:	cbz	r0, a94 <SDFile::name()+0x34>
   *             must be at least 13 bytes long.  The file's name will be
   *             truncated if the file's name is too long.
   * \return The length of the returned string.
   */
  size_t getName(char* name, size_t len) {
    *name = 0;
     a76:	strb	r5, [r0, #0]
    return m_fFile ? m_fFile->getName(name, len) :
     a78:	ldr	r0, [r4, #80]	; 0x50
           m_xFile ? m_xFile->getName(name, len) : 0;
     a7a:	cbz	r0, a86 <SDFile::name()+0x26>
     a7c:	mov.w	r2, #256	; 0x100
     a80:	bl	5ba0 <FatFile::getName(char*, unsigned int)>
     a84:	b.n	a98 <SDFile::name()+0x38>
     a86:	ldr	r0, [r4, #84]	; 0x54
     a88:	cbz	r0, a98 <SDFile::name()+0x38>
   * \param[in] size The size of the array in characters.
   * \return the name length.
   */
  size_t getName(char* name, size_t size) {
#if USE_UTF8_LONG_NAMES
    return getName8(name, size);
     a8a:	mov.w	r2, #256	; 0x100
     a8e:	bl	3e60 <ExFatFile::getName8(char*, unsigned int)>
     a92:	b.n	a98 <SDFile::name()+0x38>
				sdfatfile.getName(filename, MAX_FILENAME_LEN);
			} else {
				static char zeroterm = 0;
				filename = &zeroterm;
     a94:	ldr	r3, [pc, #4]	; (a9c <SDFile::name()+0x3c>)
     a96:	str	r3, [r4, #88]	; 0x58
			}
		}
		return filename;
	}
     a98:	ldr	r0, [r4, #88]	; 0x58
     a9a:	pop	{r3, r4, r5, pc}
     a9c:	.word	0x1fff2208

00000aa0 <SDFile::truncate(unsigned long long)>:
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
		return sdfatfile.read(buf, nbyte);
	}
	virtual bool truncate(uint64_t size=0) {
     aa0:	push	{r4, r6, r7, lr}
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     aa2:	ldr	r4, [r0, #80]	; 0x50
           m_xFile ? m_xFile->truncate(length) : false;
     aa4:	cbz	r4, ac2 <SDFile::truncate(unsigned long long)+0x22>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     aa6:	cmp	r3, #1
     aa8:	it	eq
     aaa:	cmpeq	r2, #0
     aac:	bcs.n	ad8 <SDFile::truncate(unsigned long long)+0x38>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint32_t length) {
    return seekSet(length) && truncate();
     aae:	mov	r1, r2
     ab0:	mov	r0, r4
     ab2:	bl	5ee2 <FatFile::seekSet(unsigned long)>
     ab6:	cbz	r0, ad8 <SDFile::truncate(unsigned long long)+0x38>
     ab8:	mov	r0, r4
     aba:	bl	66da <FatFile::truncate()>
     abe:	cbz	r0, ad8 <SDFile::truncate(unsigned long long)+0x38>
     ac0:	pop	{r4, r6, r7, pc}
           m_xFile ? m_xFile->truncate(length) : false;
     ac2:	ldr	r4, [r0, #84]	; 0x54
     ac4:	cbz	r4, ad8 <SDFile::truncate(unsigned long long)+0x38>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
     ac6:	mov	r0, r4
     ac8:	bl	4250 <ExFatFile::seekSet(unsigned long long)>
     acc:	cbz	r0, ad8 <SDFile::truncate(unsigned long long)+0x38>
     ace:	mov	r0, r4
		return sdfatfile.truncate(size);
	}
     ad0:	ldmia.w	sp!, {r4, r6, r7, lr}
     ad4:	b.w	5242 <ExFatFile::truncate()>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return m_fFile ? length < (1ULL << 32) && m_fFile->truncate(length) :
     ad8:	movs	r0, #0
     ada:	pop	{r4, r6, r7, pc}

00000adc <File::dec_refcount() [clone .isra.15]>:
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	using Print::write;
private:
	void dec_refcount() {
     adc:	push	{r4, lr}
     ade:	mov	r4, r0
		if (--(f->refcount) == 0) {
     ae0:	ldr	r0, [r0, #0]
     ae2:	ldr	r3, [r0, #4]
     ae4:	subs	r3, #1
     ae6:	str	r3, [r0, #4]
     ae8:	cbnz	r3, afa <File::dec_refcount() [clone .isra.15]+0x1e>
			f->close();
     aea:	ldr	r3, [r0, #0]
     aec:	ldr	r3, [r3, #44]	; 0x2c
     aee:	blx	r3
			delete f;
     af0:	ldr	r0, [r4, #0]
     af2:	cbz	r0, afa <File::dec_refcount() [clone .isra.15]+0x1e>
     af4:	ldr	r3, [r0, #0]
     af6:	ldr	r3, [r3, #4]
     af8:	blx	r3
		}
		f = nullptr;
     afa:	movs	r3, #0
     afc:	str	r3, [r4, #0]
     afe:	pop	{r4, pc}

00000b00 <File::~File()>:
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
     b00:	ldr	r3, [pc, #20]	; (b18 <File::~File()+0x18>)
     b02:	push	{r4, lr}
     b04:	str	r3, [r0, #0]
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
     b06:	ldr	r3, [r0, #16]
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
     b08:	mov	r4, r0
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
     b0a:	cbz	r3, b12 <File::~File()+0x12>
     b0c:	adds	r0, #16
     b0e:	bl	adc <File::dec_refcount() [clone .isra.15]>
	}
     b12:	mov	r0, r4
     b14:	pop	{r4, pc}
     b16:	nop
     b18:	.word	0x00012470

00000b1c <File::~File()>:
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
		f = file.f;
		return *this;
	}
#endif
	virtual ~File() {
     b1c:	push	{r4, lr}
     b1e:	mov	r4, r0
		//Serial.printf("File dtor %x, refcount=%d\n", (int)f, get_refcount());
		if (f) dec_refcount();
	}
     b20:	bl	b00 <File::~File()>
     b24:	mov	r0, r4
     b26:	movs	r1, #20
     b28:	bl	a2bc <operator delete(void*, unsigned int)>
     b2c:	mov	r0, r4
     b2e:	pop	{r4, pc}

00000b30 <SDFile::position()>:
    return m_fFile ? m_fFile->contiguousRange(bgnSector, endSector) :
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
     b30:	ldr	r3, [r0, #80]	; 0x50
           m_xFile ? m_xFile->curPosition() : 0;
     b32:	cbz	r3, b3a <SDFile::position()+0xa>
     b34:	ldr	r0, [r3, #20]
     b36:	movs	r1, #0
     b38:	bx	lr
     b3a:	ldr	r3, [r0, #84]	; 0x54
     b3c:	cbz	r3, b44 <SDFile::position()+0x14>
   *
   * \return true for success or false for failure.
   */
  bool contiguousRange(uint32_t* bgnSector, uint32_t* endSector);
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {return m_curPosition;}
     b3e:	ldmia.w	r3, {r0, r1}
     b42:	bx	lr
     b44:	mov	r0, r3
     b46:	b.n	b36 <SDFile::position()+0x6>

00000b48 <SDFile::size()>:
    return m_fFile ? m_fFile->fgets(str, num, delim) :
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
     b48:	ldr	r3, [r0, #80]	; 0x50
           m_xFile ? m_xFile->fileSize() : 0;
     b4a:	cbz	r3, b52 <SDFile::size()+0xa>
     b4c:	ldr	r0, [r3, #28]
     b4e:	movs	r1, #0
     b50:	bx	lr
     b52:	ldr	r3, [r0, #84]	; 0x54
     b54:	cbz	r3, b5c <SDFile::size()+0x14>
   * If no data is read, fgets() returns zero for EOF or -1 if an error
   * occurred.
   */
  int fgets(char* str, int num, char* delim = nullptr);
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {return m_validLength;}
     b56:	ldr	r0, [r3, #16]
     b58:	ldr	r1, [r3, #20]
     b5a:	bx	lr
     b5c:	mov	r0, r3
     b5e:	b.n	b4e <SDFile::size()+0x6>

00000b60 <FsBaseFile::available() const>:
  operator bool() const {return isOpen();}
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
    return m_fFile ? m_fFile->available() :
     b60:	ldr	r2, [r0, #56]	; 0x38
    */
  operator bool() const {return isOpen();}
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() const {
     b62:	push	{r4, r5, lr}
    return m_fFile ? m_fFile->available() :
           m_xFile ? m_xFile->available() : 0;
     b64:	cbz	r2, b80 <FsBaseFile::available() const+0x20>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available32() const {
    return isFile() ? fileSize() - curPosition() : 0;
     b66:	ldrb	r3, [r2, #0]
     b68:	and.w	r3, r3, #8
     b6c:	and.w	r0, r3, #255	; 0xff
     b70:	cbz	r3, bb2 <FsBaseFile::available() const+0x52>
     b72:	ldr	r3, [r2, #28]
     b74:	ldr	r0, [r2, #20]
   * Zero is returned for directory files.
   *
   */
  int available() const {
    uint32_t n = available32();
    return n > INT_MAX ? INT_MAX : n;
     b76:	subs	r0, r3, r0
     b78:	bpl.n	bb2 <FsBaseFile::available() const+0x52>
     b7a:	mvn.w	r0, #2147483648	; 0x80000000
     b7e:	b.n	bb2 <FsBaseFile::available() const+0x52>
     b80:	ldr	r0, [r0, #60]	; 0x3c
     b82:	cbz	r0, bb2 <FsBaseFile::available() const+0x52>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint64_t available64() {
    return isFile() ? fileSize() - curPosition() : 0;
     b84:	ldrb.w	r3, [r0, #49]	; 0x31
     b88:	lsls	r3, r3, #28
     b8a:	bpl.n	b9c <FsBaseFile::available() const+0x3c>
     b8c:	ldrd	r4, r5, [r0, #16]
     b90:	ldrd	r2, r3, [r0]
     b94:	subs	r0, r4, r2
     b96:	sbc.w	r1, r5, r3
     b9a:	b.n	ba0 <FsBaseFile::available() const+0x40>
     b9c:	movs	r0, #0
     b9e:	movs	r1, #0
   * Zero is returned for directory files.
   *
   */
  int available() {
    uint64_t n = available64();
    return n > INT_MAX ? INT_MAX : n;
     ba0:	movs	r3, #0
     ba2:	mvn.w	r2, #2147483648	; 0x80000000
     ba6:	cmp	r3, r1
     ba8:	it	eq
     baa:	cmpeq	r2, r0
     bac:	bcs.n	bb2 <FsBaseFile::available() const+0x52>
     bae:	mov	r0, r2
     bb0:	pop	{r4, r5, pc}
  }
     bb2:	pop	{r4, r5, pc}

00000bb4 <StreamFile<FsBaseFile, unsigned long long>::available()>:
  StreamFile() {}

  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
     bb4:	push	{r3, lr}
    return BaseFile::available();
     bb6:	adds	r0, #16
     bb8:	bl	b60 <FsBaseFile::available() const>
  }
     bbc:	pop	{r3, pc}

00000bbe <SDFile::available()>:
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
		return sdfatfile.peek();
	}
	virtual int available() {
     bbe:	push	{r3, lr}

  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
    return BaseFile::available();
     bc0:	adds	r0, #24
     bc2:	bl	b60 <FsBaseFile::available() const>
		return sdfatfile.available();
	}
     bc6:	pop	{r3, pc}

00000bc8 <FsBaseFile::isDir() const>:
    return m_xFile ? m_xFile->isContiguous() : false;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  }
  /** \return True if this is a directory else false. */
  bool isDir() const {
    return m_fFile ? m_fFile->isDir() :
     bc8:	ldr	r3, [r0, #56]	; 0x38
           m_xFile ? m_xFile->isDir() : false;
     bca:	cbz	r3, bd4 <FsBaseFile::isDir() const+0xc>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
    /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  /** \return True if this is a directory. */
  bool isDir() const {return m_attributes & FILE_ATTR_DIR;}
     bcc:	ldrb	r3, [r3, #0]
     bce:	tst.w	r3, #112	; 0x70
     bd2:	b.n	be0 <FsBaseFile::isDir() const+0x18>
     bd4:	ldr	r0, [r0, #60]	; 0x3c
     bd6:	cbz	r0, be6 <FsBaseFile::isDir() const+0x1e>
   */
  bool isBusy();
  /** \return True if the file is contiguous. */
  bool isContiguous() const {return m_flags & FILE_FLAG_CONTIGUOUS;}
  /** \return True if this is a directory. */
  bool isDir() const  {return m_attributes & FILE_ATTR_DIR;}
     bd8:	ldrb.w	r3, [r0, #49]	; 0x31
     bdc:	tst.w	r3, #80	; 0x50
     be0:	ite	ne
     be2:	movne	r0, #1
     be4:	moveq	r0, #0
  }
     be6:	bx	lr

00000be8 <SDFile::isDirectory()>:
				filename = &zeroterm;
			}
		}
		return filename;
	}
	virtual boolean isDirectory(void) {
     be8:	push	{r3, lr}
  }
  /** This function reports if the current file is a directory or not.
  * \return true if the file is a directory.
  */
  bool isDirectory() {
    return BaseFile::isDir();
     bea:	adds	r0, #24
     bec:	bl	bc8 <FsBaseFile::isDir() const>
		return sdfatfile.isDirectory();
	}
     bf0:	pop	{r3, pc}

00000bf2 <SDFile::rewindDirectory()>:
	virtual File openNextFile(uint8_t mode=0) {
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
		return File();
	}
	virtual void rewindDirectory(void) {
     bf2:	push	{r4, lr}
     bf4:	mov	r4, r0
  int read() {
    return BaseFile::read();
  }
  /** Rewind a file if it is a directory */
  void rewindDirectory() {
    if (BaseFile::isDir()) {
     bf6:	adds	r0, #24
     bf8:	bl	bc8 <FsBaseFile::isDir() const>
     bfc:	cbz	r0, c18 <SDFile::rewindDirectory()+0x26>
    return m_fFile ? m_fFile->rename(dirFile->m_fFile, newPath) :
           m_xFile ? m_xFile->rename(dirFile->m_xFile, newPath) : false;
  }
  /** Set the file's current position to zero. */
  void rewind() {
    if (m_fFile) m_fFile->rewind();
     bfe:	ldr	r0, [r4, #80]	; 0x50
     c00:	cbz	r0, c08 <SDFile::rewindDirectory()+0x16>
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
     c02:	movs	r1, #0
     c04:	bl	5ee2 <FatFile::seekSet(unsigned long)>
    if (m_xFile) m_xFile->rewind();
     c08:	ldr	r0, [r4, #84]	; 0x54
     c0a:	cbz	r0, c18 <SDFile::rewindDirectory()+0x26>
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
     c0c:	movs	r2, #0
     c0e:	movs	r3, #0
		sdfatfile.rewindDirectory();
	}
     c10:	ldmia.w	sp!, {r4, lr}
     c14:	b.w	4250 <ExFatFile::seekSet(unsigned long long)>
     c18:	pop	{r4, pc}

00000c1a <FsBaseFile::isOpen() const>:
  bool isHidden() const {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() const {return m_fFile || m_xFile;}
     c1a:	ldr	r3, [r0, #56]	; 0x38
     c1c:	cbnz	r3, c28 <FsBaseFile::isOpen() const+0xe>
     c1e:	ldr	r0, [r0, #60]	; 0x3c
     c20:	adds	r0, #0
     c22:	it	ne
     c24:	movne	r0, #1
     c26:	bx	lr
     c28:	movs	r0, #1
     c2a:	bx	lr

00000c2c <SDFile::close()>:
		return sdfatfile.curPosition();
	}
	virtual uint64_t size() {
		return sdfatfile.size();
	}
	virtual void close() {
     c2c:	push	{r4, lr}
     c2e:	mov	r4, r0
		if (filename) {
     c30:	ldr	r0, [r0, #88]	; 0x58
     c32:	cbz	r0, c3c <SDFile::close()+0x10>
			free(filename);
     c34:	bl	b22c <free>
			filename = nullptr;
     c38:	movs	r3, #0
     c3a:	str	r3, [r4, #88]	; 0x58
		}
		if (sdfatfile.isOpen()) {
     c3c:	adds	r4, #24
     c3e:	mov	r0, r4
     c40:	bl	c1a <FsBaseFile::isOpen() const>
     c44:	cbz	r0, c50 <SDFile::close()+0x24>
			sdfatfile.close();
     c46:	mov	r0, r4
		}
	}
     c48:	ldmia.w	sp!, {r4, lr}
		if (filename) {
			free(filename);
			filename = nullptr;
		}
		if (sdfatfile.isOpen()) {
			sdfatfile.close();
     c4c:	b.w	73f8 <FsBaseFile::close()>
     c50:	pop	{r4, pc}
     c52:	Address 0x00000c52 is out of bounds.


00000c54 <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     c54:	push	{r4, lr}
     c56:	ldr	r3, [pc, #24]	; (c70 <SDFile::~SDFile()+0x1c>)
     c58:	str	r3, [r0, #0]
     c5a:	mov	r4, r0
		close();
     c5c:	bl	c2c <SDFile::close()>
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     c60:	ldr	r3, [pc, #16]	; (c74 <SDFile::~SDFile()+0x20>)
     c62:	str	r3, [r4, #8]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     c64:	add.w	r0, r4, #24
     c68:	bl	73f8 <FsBaseFile::close()>
	}
     c6c:	mov	r0, r4
     c6e:	pop	{r4, pc}
     c70:	.word	0x0001249c
     c74:	.word	0x00012428

00000c78 <SDFile::~SDFile()>:
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
	friend class SDClass;
public:
	virtual ~SDFile(void) {
     c78:	push	{r4, lr}
     c7a:	mov	r4, r0
		close();
	}
     c7c:	bl	c54 <SDFile::~SDFile()>
     c80:	mov	r0, r4
     c82:	movs	r1, #92	; 0x5c
     c84:	bl	a2bc <operator delete(void*, unsigned int)>
     c88:	mov	r0, r4
     c8a:	pop	{r4, pc}

00000c8c <SDFile::isOpen()>:
		}
		if (sdfatfile.isOpen()) {
			sdfatfile.close();
		}
	}
	virtual bool isOpen() {
     c8c:	push	{r3, lr}
		return sdfatfile.isOpen();
     c8e:	adds	r0, #24
     c90:	bl	c1a <FsBaseFile::isOpen() const>
	}
     c94:	pop	{r3, pc}

00000c96 <FsBaseFile::peek()>:
  uint64_t position() const {return curPosition();}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
     c96:	mov	r3, r0
    return m_fFile ? m_fFile->peek() :
     c98:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->peek() : -1;
     c9a:	cbz	r0, ca0 <FsBaseFile::peek()+0xa>
     c9c:	b.w	5e80 <FatFile::peek()>
     ca0:	ldr	r0, [r3, #60]	; 0x3c
     ca2:	cbz	r0, ca8 <FsBaseFile::peek()+0x12>
     ca4:	b.w	4224 <ExFatFile::peek()>
  }
     ca8:	mov.w	r0, #4294967295
     cac:	bx	lr

00000cae <StreamFile<FsBaseFile, unsigned long long>::peek()>:
  const char* name() const {return "use getName()";}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
     cae:	push	{r3, lr}
    return BaseFile::peek();
     cb0:	adds	r0, #16
     cb2:	bl	c96 <FsBaseFile::peek()>
  }
     cb6:	pop	{r3, pc}

00000cb8 <SDFile::peek()>:
		close();
	}
	virtual size_t write(const void *buf, size_t size) {
		return sdfatfile.write(buf, size);
	}
	virtual int peek() {
     cb8:	push	{r3, lr}
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    return BaseFile::peek();
     cba:	adds	r0, #24
     cbc:	bl	c96 <FsBaseFile::peek()>
		return sdfatfile.peek();
	}
     cc0:	pop	{r3, pc}

00000cc2 <FsBaseFile::read(void*, unsigned int)>:
   * if end of file is reached.
   * If an error occurs, read() returns -1.  Possible errors include
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
     cc2:	mov	r3, r0
    return m_fFile ? m_fFile->read(buf, count) :
     cc4:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->read(buf, count) : -1;
     cc6:	cbz	r0, ccc <FsBaseFile::read(void*, unsigned int)+0xa>
     cc8:	b.w	5d08 <FatFile::read(void*, unsigned int)>
     ccc:	ldr	r0, [r3, #60]	; 0x3c
     cce:	cbz	r0, cd4 <FsBaseFile::read(void*, unsigned int)+0x12>
     cd0:	b.w	40a0 <ExFatFile::read(void*, unsigned int)>
  }
     cd4:	mov.w	r0, #4294967295
     cd8:	bx	lr

00000cda <StreamFile<FsBaseFile, unsigned long long>::read()>:
  /** Read the next byte from a file.
   *
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
     cda:	push	{r0, r1, r2, lr}
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
     cdc:	movs	r2, #1
     cde:	add.w	r1, sp, #7
     ce2:	adds	r0, #16
     ce4:	bl	cc2 <FsBaseFile::read(void*, unsigned int)>
     ce8:	cmp	r0, #1
     cea:	ite	eq
     cec:	ldrbeq.w	r0, [sp, #7]
     cf0:	movne.w	r0, #4294967295
    return BaseFile::read();
  }
     cf4:	add	sp, #12
     cf6:	ldr.w	pc, [sp], #4

00000cfa <SDFile::read(void*, unsigned int)>:
		return sdfatfile.available();
	}
	virtual void flush() {
		sdfatfile.flush();
	}
	virtual size_t read(void *buf, size_t nbyte) {
     cfa:	push	{r3, lr}
		return sdfatfile.read(buf, nbyte);
     cfc:	adds	r0, #24
     cfe:	bl	cc2 <FsBaseFile::read(void*, unsigned int)>
	}
     d02:	pop	{r3, pc}

00000d04 <FsBaseFile::seekSet(unsigned long long)>:
   *
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
     d04:	push	{r4, r6, r7}
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     d06:	ldr	r4, [r0, #56]	; 0x38
           m_xFile ? m_xFile->seekSet(pos) : false;
     d08:	cbz	r4, d1c <FsBaseFile::seekSet(unsigned long long)+0x18>
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     d0a:	cmp	r3, #1
     d0c:	it	eq
     d0e:	cmpeq	r2, #0
     d10:	bcs.n	d26 <FsBaseFile::seekSet(unsigned long long)+0x22>
     d12:	mov	r0, r4
     d14:	mov	r1, r2
           m_xFile ? m_xFile->seekSet(pos) : false;
  }
     d16:	pop	{r4, r6, r7}
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
     d18:	b.w	5ee2 <FatFile::seekSet(unsigned long)>
           m_xFile ? m_xFile->seekSet(pos) : false;
     d1c:	ldr	r0, [r0, #60]	; 0x3c
     d1e:	cbz	r0, d26 <FsBaseFile::seekSet(unsigned long long)+0x22>
  }
     d20:	pop	{r4, r6, r7}
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
     d22:	b.w	4250 <ExFatFile::seekSet(unsigned long long)>
  }
     d26:	movs	r0, #0
     d28:	pop	{r4, r6, r7}
     d2a:	bx	lr

00000d2c <SDFile::seek(unsigned long long, int)>:
	virtual bool truncate(uint64_t size=0) {
		return sdfatfile.truncate(size);
	}
	virtual bool seek(uint64_t pos, int mode = SeekSet) {
     d2c:	push	{r3, r4, r5, lr}
     d2e:	mov	r1, r0
     d30:	ldr	r0, [sp, #16]
     d32:	mov	r4, r2
     d34:	mov	r5, r3
		if (mode == SeekSet) return sdfatfile.seekSet(pos);
     d36:	cbnz	r0, d3e <SDFile::seek(unsigned long long, int)+0x12>
     d38:	add.w	r0, r1, #24
     d3c:	b.n	d7a <SDFile::seek(unsigned long long, int)+0x4e>
		if (mode == SeekCur) return sdfatfile.seekCur(pos);
     d3e:	cmp	r0, #1
     d40:	bne.n	d58 <SDFile::seek(unsigned long long, int)+0x2c>
    return m_fFile ? m_fFile->contiguousRange(bgnSector, endSector) :
           m_xFile ? m_xFile->contiguousRange(bgnSector, endSector) : false;
  }
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {
    return m_fFile ? m_fFile->curPosition() :
     d42:	ldr	r3, [r1, #80]	; 0x50
     d44:	add.w	r0, r1, #24
           m_xFile ? m_xFile->curPosition() : 0;
     d48:	cbz	r3, d4e <SDFile::seek(unsigned long long, int)+0x22>
     d4a:	ldr	r2, [r3, #20]
     d4c:	b.n	d74 <SDFile::seek(unsigned long long, int)+0x48>
     d4e:	ldr	r3, [r1, #84]	; 0x54
     d50:	cbz	r3, d72 <SDFile::seek(unsigned long long, int)+0x46>
   *
   * \return true for success or false for failure.
   */
  bool contiguousRange(uint32_t* bgnSector, uint32_t* endSector);
  /** \return The current position for a file or directory. */
  uint64_t curPosition() const {return m_curPosition;}
     d52:	ldrd	r2, r3, [r3]
     d56:	b.n	d76 <SDFile::seek(unsigned long long, int)+0x4a>
		if (mode == SeekEnd) return sdfatfile.seekEnd(pos);
     d58:	cmp	r0, #2
     d5a:	bne.n	d80 <SDFile::seek(unsigned long long, int)+0x54>
    return m_fFile ? m_fFile->fgets(str, num, delim) :
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {
    return m_fFile ? m_fFile->fileSize() :
     d5c:	ldr	r3, [r1, #80]	; 0x50
     d5e:	add.w	r0, r1, #24
           m_xFile ? m_xFile->fileSize() : 0;
     d62:	cbz	r3, d68 <SDFile::seek(unsigned long long, int)+0x3c>
     d64:	ldr	r2, [r3, #28]
     d66:	b.n	d74 <SDFile::seek(unsigned long long, int)+0x48>
     d68:	ldr	r3, [r1, #84]	; 0x54
     d6a:	cbz	r3, d72 <SDFile::seek(unsigned long long, int)+0x46>
   * If no data is read, fgets() returns zero for EOF or -1 if an error
   * occurred.
   */
  int fgets(char* str, int num, char* delim = nullptr);
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() const {return m_validLength;}
     d6c:	ldrd	r2, r3, [r3, #16]
     d70:	b.n	d76 <SDFile::seek(unsigned long long, int)+0x4a>
     d72:	movs	r2, #0
     d74:	movs	r3, #0
   * Can't be used for directory files since file size is not defined.
   * \param[in] offset The new position in bytes from end-of-file.
   * \return true for success or false for failure.
   */
  bool seekEnd(int64_t offset = 0) {
    return seekSet(fileSize() + offset);
     d76:	adds	r2, r2, r4
     d78:	adcs	r3, r5
     d7a:	bl	d04 <FsBaseFile::seekSet(unsigned long long)>
     d7e:	pop	{r3, r4, r5, pc}
		return false;
     d80:	movs	r0, #0
	}
     d82:	pop	{r3, r4, r5, pc}

00000d84 <FsBaseFile::sync()>:
  /** The sync() call causes all modified data and directory fields
   * to be written to the storage device.
   *
   * \return true for success or false for failure.
   */
  bool sync() {
     d84:	mov	r3, r0
    return m_fFile ? m_fFile->sync() :
     d86:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->sync() : false;
     d88:	cbz	r0, d8e <FsBaseFile::sync()+0xa>
     d8a:	b.w	6138 <FatFile::sync()>
     d8e:	ldr	r0, [r3, #60]	; 0x3c
     d90:	cbz	r0, d96 <FsBaseFile::sync()+0x12>
     d92:	b.w	4e68 <ExFatFile::sync()>
  }
     d96:	bx	lr

00000d98 <StreamFile<FsBaseFile, unsigned long long>::flush()>:
   */
  int available() {
    return BaseFile::available();
  }
  /** Ensure that any bytes written to the file are saved to the SD card. */
  void flush() {
     d98:	push	{r3, lr}
    BaseFile::sync();
     d9a:	adds	r0, #16
     d9c:	bl	d84 <FsBaseFile::sync()>
     da0:	pop	{r3, pc}

00000da2 <SDFile::flush()>:
		return sdfatfile.peek();
	}
	virtual int available() {
		return sdfatfile.available();
	}
	virtual void flush() {
     da2:	push	{r3, lr}
     da4:	adds	r0, #24
     da6:	bl	d84 <FsBaseFile::sync()>
     daa:	pop	{r3, pc}

00000dac <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
   * Modify and access timestamps may be overwritten if a date time callback
   * function has been set by dateTimeCallback().
   *
   * \return true for success or false for failure.
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
     dac:	push	{r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
     dae:	ldr.w	lr, [r0, #56]	; 0x38
   * Modify and access timestamps may be overwritten if a date time callback
   * function has been set by dateTimeCallback().
   *
   * \return true for success or false for failure.
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
     db2:	ldrb.w	r4, [sp, #20]
     db6:	ldrb.w	r5, [sp, #24]
     dba:	ldrb.w	r6, [sp, #28]
     dbe:	ldrb.w	r7, [sp, #32]
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     dc2:	cmp.w	lr, #0
     dc6:	beq.n	dda <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x2e>
     dc8:	str	r7, [sp, #32]
     dca:	str	r6, [sp, #28]
     dcc:	str	r5, [sp, #24]
     dce:	str	r4, [sp, #20]
     dd0:	mov	r0, lr
  }
     dd2:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     dd6:	b.w	662c <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
   */
  bool timestamp(uint8_t flags, uint16_t year, uint8_t month, uint8_t day,
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
     dda:	ldr	r0, [r0, #60]	; 0x3c
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     ddc:	cbz	r0, dee <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x42>
     dde:	str	r7, [sp, #32]
     de0:	str	r6, [sp, #28]
     de2:	str	r5, [sp, #24]
     de4:	str	r4, [sp, #20]
  }
     de6:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
                 uint8_t hour, uint8_t minute, uint8_t second) {
    return m_fFile ?
           m_fFile->timestamp(flags, year, month, day, hour, minute, second) :
           m_xFile ?
           m_xFile->timestamp(flags, year, month, day, hour, minute, second) :
           false;
     dea:	b.w	5130 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
  }
     dee:	pop	{r4, r5, r6, r7, pc}

00000df0 <SDFile::setModifyTime(DateTimeFields const&)>:
	virtual bool setCreateTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
	virtual bool setModifyTime(const DateTimeFields &tm) {
     df0:	push	{r0, r1, r2, r3, r4, lr}
		if (tm.year < 80 || tm.year > 207) return false;
     df2:	ldrb	r2, [r1, #6]
     df4:	sub.w	r3, r2, #80	; 0x50
     df8:	lsls	r3, r3, #24
     dfa:	bmi.n	e20 <SDFile::setModifyTime(DateTimeFields const&)+0x30>
		return sdfatfile.timestamp(T_WRITE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
     dfc:	ldrb	r4, [r1, #0]
     dfe:	ldrb	r3, [r1, #5]
     e00:	str	r4, [sp, #12]
     e02:	ldrb	r4, [r1, #1]
     e04:	str	r4, [sp, #8]
     e06:	ldrb	r4, [r1, #2]
     e08:	str	r4, [sp, #4]
     e0a:	ldrb	r1, [r1, #4]
     e0c:	str	r1, [sp, #0]
     e0e:	adds	r3, #1
     e10:	uxtb	r3, r3
     e12:	addw	r2, r2, #1900	; 0x76c
     e16:	movs	r1, #4
     e18:	adds	r0, #24
     e1a:	bl	dac <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
     e1e:	b.n	e22 <SDFile::setModifyTime(DateTimeFields const&)+0x32>
		if (tm.year < 80 || tm.year > 207) return false;
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
	virtual bool setModifyTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
     e20:	movs	r0, #0
		return sdfatfile.timestamp(T_WRITE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
     e22:	add	sp, #16
     e24:	pop	{r4, pc}

00000e26 <SDFile::setCreateTime(DateTimeFields const&)>:
		tm.mday = FS_DAY(fat_date);
		tm.mon = FS_MONTH(fat_date) - 1;
		tm.year = FS_YEAR(fat_date) - 1900;
		return true;
	}
	virtual bool setCreateTime(const DateTimeFields &tm) {
     e26:	push	{r0, r1, r2, r3, r4, lr}
		if (tm.year < 80 || tm.year > 207) return false;
     e28:	ldrb	r2, [r1, #6]
     e2a:	sub.w	r3, r2, #80	; 0x50
     e2e:	lsls	r3, r3, #24
     e30:	bmi.n	e56 <SDFile::setCreateTime(DateTimeFields const&)+0x30>
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
     e32:	ldrb	r4, [r1, #0]
     e34:	ldrb	r3, [r1, #5]
     e36:	str	r4, [sp, #12]
     e38:	ldrb	r4, [r1, #1]
     e3a:	str	r4, [sp, #8]
     e3c:	ldrb	r4, [r1, #2]
     e3e:	str	r4, [sp, #4]
     e40:	ldrb	r1, [r1, #4]
     e42:	str	r1, [sp, #0]
     e44:	adds	r3, #1
     e46:	uxtb	r3, r3
     e48:	addw	r2, r2, #1900	; 0x76c
     e4c:	movs	r1, #2
     e4e:	adds	r0, #24
     e50:	bl	dac <FsBaseFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>
     e54:	b.n	e58 <SDFile::setCreateTime(DateTimeFields const&)+0x32>
		tm.mon = FS_MONTH(fat_date) - 1;
		tm.year = FS_YEAR(fat_date) - 1900;
		return true;
	}
	virtual bool setCreateTime(const DateTimeFields &tm) {
		if (tm.year < 80 || tm.year > 207) return false;
     e56:	movs	r0, #0
		return sdfatfile.timestamp(T_CREATE, tm.year + 1900, tm.mon + 1,
			tm.mday, tm.hour, tm.min, tm.sec);
	}
     e58:	add	sp, #16
     e5a:	pop	{r4, pc}

00000e5c <FsBaseFile::write(void const*, unsigned int)>:
   * \param[in] count Number of bytes to write.
   *
   * \return For success write() returns the number of bytes written, always
   * \a nbyte.  If an error occurs, write() returns zero and writeError is set.
   */
  size_t write(const void* buf, size_t count) {
     e5c:	mov	r3, r0
    return m_fFile ? m_fFile->write(buf, count) :
     e5e:	ldr	r0, [r0, #56]	; 0x38
           m_xFile ? m_xFile->write(buf, count) : 0;
     e60:	cbz	r0, e66 <FsBaseFile::write(void const*, unsigned int)+0xa>
     e62:	b.w	6744 <FatFile::write(void const*, unsigned int)>
     e66:	ldr	r0, [r3, #60]	; 0x3c
     e68:	cbz	r0, e6e <FsBaseFile::write(void const*, unsigned int)+0x12>
     e6a:	b.w	5300 <ExFatFile::write(void const*, unsigned int)>
  }
     e6e:	bx	lr

00000e70 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)>:
   * \param[in] size Number of bytes to write.
   *
   * \return For success write() returns the number of bytes written, always
   * \a size.
   */
  size_t write(const uint8_t* buffer, size_t size) {
     e70:	push	{r3, lr}
    return BaseFile::write(buffer, size);
     e72:	adds	r0, #16
     e74:	bl	e5c <FsBaseFile::write(void const*, unsigned int)>
  }
     e78:	pop	{r3, pc}

00000e7a <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)>:
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {
     e7a:	push	{r0, r1, r2, lr}
     e7c:	add	r3, sp, #8
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {return write(&b, 1);}
     e7e:	movs	r2, #1
     e80:	strb.w	r1, [r3, #-1]!
     e84:	adds	r0, #16
     e86:	mov	r1, r3
     e88:	bl	e5c <FsBaseFile::write(void const*, unsigned int)>
    return BaseFile::write(b);
  }
     e8c:	add	sp, #12
     e8e:	ldr.w	pc, [sp], #4

00000e92 <SDFile::write(void const*, unsigned int)>:
	friend class SDClass;
public:
	virtual ~SDFile(void) {
		close();
	}
	virtual size_t write(const void *buf, size_t size) {
     e92:	push	{r3, lr}
		return sdfatfile.write(buf, size);
     e94:	adds	r0, #24
     e96:	bl	e5c <FsBaseFile::write(void const*, unsigned int)>
	}
     e9a:	pop	{r3, pc}

00000e9c <File::close()>:
		return (f) ? f->position() : 0;
	}
	uint64_t size() {
		return (f) ? f->size() : 0;
	}
	void close() {
     e9c:	push	{r4, lr}
     e9e:	mov	r4, r0
		if (f) {
     ea0:	ldr	r0, [r0, #16]
     ea2:	cbz	r0, eb6 <File::close()+0x1a>
			f->close();
     ea4:	ldr	r3, [r0, #0]
     ea6:	ldr	r3, [r3, #44]	; 0x2c
     ea8:	blx	r3
			dec_refcount();
     eaa:	add.w	r0, r4, #16
		}
	}
     eae:	ldmia.w	sp!, {r4, lr}
		return (f) ? f->size() : 0;
	}
	void close() {
		if (f) {
			f->close();
			dec_refcount();
     eb2:	b.w	adc <File::dec_refcount() [clone .isra.15]>
     eb6:	pop	{r4, pc}

00000eb8 <SDFile::SDFile(FsFile const&)>:
	// Classes derived from File are never meant to be constructed
	// anywhere other than open() in the parent FS class and
	// openNextFile() while traversing a directory.
	// Only the abstract File class which references these derived
	// classes is meant to have a public constructor!
	SDFile(const SDFAT_FILE &file) : sdfatfile(file), filename(nullptr) { }
     eb8:	push	{r3, r4, r5, lr}
// FileImpl instances are automatically deleted when the last referencing
// File is closed or goes out of scope.  The refcount variable is meant to
// be maintained by File class instances, never access by FileImpl functions.
// The FileImpl functions are meant to be called only by use of File instances.
//
class FileImpl {
     eba:	movs	r5, #0
     ebc:	ldr	r3, [pc, #40]	; (ee8 <SDFile::SDFile(FsFile const&)+0x30>)
     ebe:	str	r5, [r0, #4]
     ec0:	str	r3, [r0, #0]
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
     ec2:	ldrb	r3, [r1, #4]
     ec4:	strb	r3, [r0, #12]
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
     ec6:	ldr	r3, [pc, #36]	; (eec <SDFile::SDFile(FsFile const&)+0x34>)
     ec8:	str	r3, [r0, #8]
     eca:	ldr	r3, [r1, #8]
     ecc:	str	r3, [r0, #16]
     ece:	ldrb	r3, [r1, #12]
     ed0:	strb	r3, [r0, #20]
     ed2:	mov	r4, r0
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     ed4:	adds	r1, #16
     ed6:	adds	r0, #24
     ed8:	bl	7396 <FsBaseFile::FsBaseFile(FsBaseFile const&)>
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     edc:	ldr	r3, [pc, #16]	; (ef0 <SDFile::SDFile(FsFile const&)+0x38>)
     ede:	str	r3, [r4, #8]
     ee0:	str	r5, [r4, #88]	; 0x58
     ee2:	mov	r0, r4
     ee4:	pop	{r3, r4, r5, pc}
     ee6:	nop
     ee8:	.word	0x0001249c
     eec:	.word	0x00012404
     ef0:	.word	0x0001244c

00000ef4 <SDFile::openNextFile(unsigned char)>:
		return filename;
	}
	virtual boolean isDirectory(void) {
		return sdfatfile.isDirectory();
	}
	virtual File openNextFile(uint8_t mode=0) {
     ef4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     ef8:	sub	sp, #84	; 0x54
{
  public:
	constexpr Print() : write_error(0) {}
     efa:	movs	r5, #0
     efc:	add.w	r8, sp, #80	; 0x50
     f00:	ldr	r3, [pc, #108]	; (f70 <SDFile::openNextFile(unsigned char)+0x7c>)
     f02:	str.w	r3, [r8, #-80]!
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
     f06:	mov	r2, r5
     f08:	adds	r1, #24
     f0a:	mov	r4, r0
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     f0c:	mov.w	r6, #1000	; 0x3e8
     f10:	add	r0, sp, #16
     f12:	strb.w	r5, [sp, #4]
     f16:	str	r6, [sp, #8]
     f18:	strb.w	r5, [sp, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
     f1c:	str	r5, [sp, #72]	; 0x48
     f1e:	str	r5, [sp, #76]	; 0x4c
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
     f20:	bl	749e <FsBaseFile::openNext(FsBaseFile*, int)>
  FsBaseFile& operator=(const FsBaseFile& from);
  /** The parenthesis operator.
    *
    * \return true if a file is open.
    */
  operator bool() const {return isOpen();}
     f24:	add	r0, sp, #16
     f26:	bl	c1a <FsBaseFile::isOpen() const>
     f2a:	ldr.w	r9, [pc, #76]	; f78 <SDFile::openNextFile(unsigned char)+0x84>
		SDFAT_FILE file = sdfatfile.openNextFile();
		if (file) return File(new SDFile(file));
     f2e:	cbz	r0, f52 <SDFile::openNextFile(unsigned char)+0x5e>
     f30:	movs	r0, #92	; 0x5c
     f32:	bl	a2b8 <operator new(unsigned int)>
     f36:	mov	r7, r0
     f38:	mov	r1, r8
     f3a:	bl	eb8 <SDFile::SDFile(FsFile const&)>
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
		if (f) f->refcount++;
     f3e:	ldr	r3, [r7, #4]
     f40:	strb	r5, [r4, #4]
     f42:	adds	r3, #1
     f44:	str	r6, [r4, #8]
     f46:	strb	r5, [r4, #12]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
     f48:	str.w	r9, [r4]
		f = file;
     f4c:	str	r7, [r4, #16]
		if (f) f->refcount++;
     f4e:	str	r3, [r7, #4]
     f50:	b.n	f5e <SDFile::openNextFile(unsigned char)+0x6a>
     f52:	strb	r0, [r4, #4]
     f54:	str	r6, [r4, #8]
     f56:	strb	r0, [r4, #12]
//
class File final : public Stream {
public:
	// Empty constructor, used when a program creates a File variable
	// but does not immediately assign or initialize it.
	constexpr File() : f(nullptr) { }
     f58:	str.w	r9, [r4]
     f5c:	str	r0, [r4, #16]
     f5e:	ldr	r3, [pc, #20]	; (f74 <SDFile::openNextFile(unsigned char)+0x80>)
     f60:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     f62:	add	r0, sp, #16
     f64:	bl	73f8 <FsBaseFile::close()>
		return File();
	}
     f68:	mov	r0, r4
     f6a:	add	sp, #84	; 0x54
     f6c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     f70:	.word	0x0001244c
     f74:	.word	0x00012428
     f78:	.word	0x00012470

00000f7c <SDClass::open(char const*, unsigned char)>:
class SDClass : public FS
{
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
     f7c:	push	{r4, r5, r6, lr}
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     f7e:	cmp	r3, #1
class SDClass : public FS
{
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
     f80:	sub	sp, #80	; 0x50
     f82:	mov	r4, r0
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     f84:	beq.n	f92 <SDClass::open(char const*, unsigned char)+0x16>
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
     f86:	cmp	r3, #2
     f88:	movw	r3, #514	; 0x202
     f8c:	it	ne
     f8e:	movne	r3, #0
     f90:	b.n	f96 <SDClass::open(char const*, unsigned char)+0x1a>
public:
	SDClass() { }
	bool begin(uint8_t csPin = 10);
	File open(const char *filepath, uint8_t mode = FILE_READ) {
		oflag_t flags = O_READ;
		if (mode == FILE_WRITE) flags = O_RDWR | O_CREAT | O_AT_END;
     f92:	movw	r3, #16898	; 0x4202
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
     f96:	adds	r1, #4
     f98:	mov	r0, sp
     f9a:	bl	75b8 <FsVolume::open(char const*, int)>
  FsBaseFile& operator=(const FsBaseFile& from);
  /** The parenthesis operator.
    *
    * \return true if a file is open.
    */
  operator bool() const {return isOpen();}
     f9e:	add	r0, sp, #16
     fa0:	bl	c1a <FsBaseFile::isOpen() const>
     fa4:	ldr	r6, [pc, #68]	; (fec <SDClass::open(char const*, unsigned char)+0x70>)
		if (file) return File(new SDFile(file));
     fa6:	cbz	r0, fce <SDClass::open(char const*, unsigned char)+0x52>
     fa8:	movs	r0, #92	; 0x5c
     faa:	bl	a2b8 <operator new(unsigned int)>
     fae:	mov	r1, sp
     fb0:	mov	r5, r0
     fb2:	bl	eb8 <SDFile::SDFile(FsFile const&)>
     fb6:	movs	r3, #0
     fb8:	strb	r3, [r4, #4]
     fba:	strb	r3, [r4, #12]
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
		if (f) f->refcount++;
     fbc:	ldr	r3, [r5, #4]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
     fbe:	str	r6, [r4, #0]
     fc0:	mov.w	r2, #1000	; 0x3e8
		f = file;
		if (f) f->refcount++;
     fc4:	adds	r3, #1
     fc6:	str	r2, [r4, #8]
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
		f = file;
     fc8:	str	r5, [r4, #16]
		if (f) f->refcount++;
     fca:	str	r3, [r5, #4]
     fcc:	b.n	fdc <SDClass::open(char const*, unsigned char)+0x60>
     fce:	mov.w	r3, #1000	; 0x3e8
     fd2:	strb	r0, [r4, #4]
     fd4:	str	r3, [r4, #8]
     fd6:	strb	r0, [r4, #12]
//
class File final : public Stream {
public:
	// Empty constructor, used when a program creates a File variable
	// but does not immediately assign or initialize it.
	constexpr File() : f(nullptr) { }
     fd8:	str	r6, [r4, #0]
     fda:	str	r0, [r4, #16]
     fdc:	ldr	r3, [pc, #16]	; (ff0 <SDClass::open(char const*, unsigned char)+0x74>)
     fde:	str	r3, [sp, #0]
   */
  FsBaseFile(const char* path, oflag_t oflag) {
    open(path, oflag);
  }

  ~FsBaseFile() {close();}
     fe0:	add	r0, sp, #16
     fe2:	bl	73f8 <FsBaseFile::close()>
		return File();
	}
     fe6:	mov	r0, r4
     fe8:	add	sp, #80	; 0x50
     fea:	pop	{r4, r5, r6, pc}
     fec:	.word	0x00012470
     ff0:	.word	0x00012428

00000ff4 <storeConfig(unsigned short*, int)>:
uint16_t store[16];

extern  int t_acq;

void storeConfig(uint16_t *store, int ns)
{ 
     ff4:	push	{r4, r5, r6, lr}
     ff6:	sub	sp, #56	; 0x38
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
     ff8:	ldr	r3, [pc, #120]	; (1074 <storeConfig(unsigned short*, int)+0x80>)
     ffa:	str	r3, [sp, #4]
     ffc:	mov.w	r2, #1000	; 0x3e8
    1000:	movs	r3, #0
    1002:	strb.w	r3, [sp, #8]
    1006:	str	r2, [sp, #12]
    1008:	strb.w	r3, [sp, #16]
    100c:	str	r3, [sp, #20]
uint16_t store[16];

extern  int t_acq;

void storeConfig(uint16_t *store, int ns)
{ 
    100e:	mov	r5, r0
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    char text[32];
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
    1010:	movs	r3, #2
uint16_t store[16];

extern  int t_acq;

void storeConfig(uint16_t *store, int ns)
{ 
    1012:	mov	r6, r1
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    char text[32];
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
    1014:	ldr	r2, [pc, #96]	; (1078 <storeConfig(unsigned short*, int)+0x84>)
    1016:	ldr	r1, [pc, #100]	; (107c <storeConfig(unsigned short*, int)+0x88>)
    1018:	add	r0, sp, #24
    101a:	bl	f7c <SDClass::open(char const*, unsigned char)>
	}
#ifdef FILE_USE_MOVE
	// Move assignment.
	File& operator = (const File&& file) {
		//Serial.println("File move assignment");
		if (file.f) file.f->refcount++;
    101e:	ldr	r3, [sp, #40]	; 0x28
    1020:	cbz	r3, 1028 <storeConfig(unsigned short*, int)+0x34>
    1022:	ldr	r2, [r3, #4]
    1024:	adds	r2, #1
    1026:	str	r2, [r3, #4]
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
    1028:	ldr	r3, [sp, #20]
    102a:	cbz	r3, 1032 <storeConfig(unsigned short*, int)+0x3e>
    102c:	add	r0, sp, #20
    102e:	bl	adc <File::dec_refcount() [clone .isra.15]>
		f = file.f;
    1032:	ldr	r3, [sp, #40]	; 0x28
    1034:	str	r3, [sp, #20]
    1036:	add	r0, sp, #24
    1038:	bl	b00 <File::~File()>
      for(int ii=0; ii<ns; ii++)
    103c:	movs	r4, #0
    103e:	cmp	r4, r6
    1040:	bge.n	1062 <storeConfig(unsigned short*, int)+0x6e>
      { sprintf(text,"%10d\r\n",(int) store[ii]); configFile.write((uint8_t*)text,strlen(text)); }
    1042:	ldrh.w	r2, [r5, r4, lsl #1]
    1046:	ldr	r1, [pc, #56]	; (1080 <storeConfig(unsigned short*, int)+0x8c>)
    1048:	add	r0, sp, #24
    104a:	bl	bdb8 <sprintf>
    104e:	add	r0, sp, #24
    1050:	bl	be80 <strlen>
    1054:	add	r1, sp, #24
    1056:	mov	r2, r0
    1058:	add	r0, sp, #4
    105a:	bl	91e <File::write(unsigned char const*, unsigned int)>
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    char text[32];
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
      for(int ii=0; ii<ns; ii++)
    105e:	adds	r4, #1
    1060:	b.n	103e <storeConfig(unsigned short*, int)+0x4a>
      { sprintf(text,"%10d\r\n",(int) store[ii]); configFile.write((uint8_t*)text,strlen(text)); }
    configFile.close();
    1062:	add	r0, sp, #4
    1064:	bl	e9c <File::close()>

void storeConfig(uint16_t *store, int ns)
{ 
  //  eeprom_write_block(store, 0, ns*sizeof(store[0]));  

    File configFile;
    1068:	add	r0, sp, #4
    106a:	bl	b00 <File::~File()>
    configFile=sdx[0].open(CONFIG_FILE,FILE_WRITE_BEGIN);
      for(int ii=0; ii<ns; ii++)
      { sprintf(text,"%10d\r\n",(int) store[ii]); configFile.write((uint8_t*)text,strlen(text)); }
    configFile.close();
  
}
    106e:	add	sp, #56	; 0x38
    1070:	pop	{r4, r5, r6, pc}
    1072:	nop
    1074:	.word	0x00012470
    1078:	.word	0x000124f0
    107c:	.word	0x2001a458
    1080:	.word	0x000124fc

00001084 <saveParameters()>:
    configFile.close();
}

void saveParameters(void)
{
  store[0]= 1;
    1084:	ldr	r0, [pc, #16]	; (1098 <saveParameters()+0x14>)
    1086:	movs	r3, #1
    1088:	strh	r3, [r0, #0]
  store[2]= t_acq;
    108a:	ldr	r3, [pc, #16]	; (109c <saveParameters()+0x18>)

  storeConfig(store, 16);
    108c:	movs	r1, #16
}

void saveParameters(void)
{
  store[0]= 1;
  store[2]= t_acq;
    108e:	ldr	r3, [r3, #0]
    1090:	strh	r3, [r0, #4]

  storeConfig(store, 16);
    1092:	b.w	ff4 <storeConfig(unsigned short*, int)>
    1096:	nop
    1098:	.word	0x1fff220a
    109c:	.word	0x1fff0f38

000010a0 <printMenu()>:
  }
}


void printMenu(void)
{
    10a0:	push	{r4, lr}
  Serial.println("\n Menu");
    10a2:	ldr	r4, [pc, #144]	; (1134 <printMenu()+0x94>)
    10a4:	ldr	r1, [pc, #144]	; (1138 <printMenu()+0x98>)
    10a6:	mov	r0, r4
    10a8:	bl	6cc <Print::println(char const*)>
  Serial.println(" ':h'  : print help");
    10ac:	ldr	r1, [pc, #140]	; (113c <printMenu()+0x9c>)
    10ae:	mov	r0, r4
    10b0:	bl	6cc <Print::println(char const*)>
  Serial.println(" ':s'  : start acquisition");
    10b4:	ldr	r1, [pc, #136]	; (1140 <printMenu()+0xa0>)
    10b6:	mov	r0, r4
    10b8:	bl	6cc <Print::println(char const*)>
  Serial.println(" ':e'  : stop acquisition");
    10bc:	ldr	r1, [pc, #132]	; (1144 <printMenu()+0xa4>)
    10be:	mov	r0, r4
    10c0:	bl	6cc <Print::println(char const*)>
  Serial.println(" ':w'  : write parameters to microSD card");
    10c4:	ldr	r1, [pc, #128]	; (1148 <printMenu()+0xa8>)
    10c6:	mov	r0, r4
    10c8:	bl	6cc <Print::println(char const*)>
  Serial.println(" ':l'  : list disks");
    10cc:	ldr	r1, [pc, #124]	; (114c <printMenu()+0xac>)
    10ce:	mov	r0, r4
    10d0:	bl	6cc <Print::println(char const*)>
  Serial.println(" ':r'  : reset MTP");
    10d4:	ldr	r1, [pc, #120]	; (1150 <printMenu()+0xb0>)
    10d6:	mov	r0, r4
    10d8:	bl	6cc <Print::println(char const*)>
  Serial.println(" ':b'  : reboot CPU");
    10dc:	ldr	r1, [pc, #116]	; (1154 <printMenu()+0xb4>)
    10de:	mov	r0, r4
    10e0:	bl	6cc <Print::println(char const*)>
//  Serial.println(" ':d'  : dump Index List (testing)");
  Serial.println();
    10e4:	mov	r0, r4
    10e6:	bl	a0c0 <Print::println()>
  Serial.println(" '?p'  : show all parameters");
    10ea:	ldr	r1, [pc, #108]	; (1158 <printMenu()+0xb8>)
    10ec:	mov	r0, r4
    10ee:	bl	6cc <Print::println(char const*)>
  Serial.println(" '?d'  : get date");
    10f2:	ldr	r1, [pc, #104]	; (115c <printMenu()+0xbc>)
    10f4:	mov	r0, r4
    10f6:	bl	6cc <Print::println(char const*)>
  Serial.println(" '?t'  : get time");
    10fa:	ldr	r1, [pc, #100]	; (1160 <printMenu()+0xc0>)
    10fc:	mov	r0, r4
    10fe:	bl	6cc <Print::println(char const*)>
  Serial.println(" '?a'  : get file duration (s)");
    1102:	ldr	r1, [pc, #96]	; (1164 <printMenu()+0xc4>)
    1104:	mov	r0, r4
    1106:	bl	6cc <Print::println(char const*)>
  Serial.println();
    110a:	mov	r0, r4
    110c:	bl	a0c0 <Print::println()>
  Serial.println(" '!d yyyy/mm/dd<cr>'  : set date");
    1110:	ldr	r1, [pc, #84]	; (1168 <printMenu()+0xc8>)
    1112:	mov	r0, r4
    1114:	bl	6cc <Print::println(char const*)>
  Serial.println(" '!t hh:mm:ss<cr>'    : set time");
    1118:	ldr	r1, [pc, #80]	; (116c <printMenu()+0xcc>)
    111a:	mov	r0, r4
    111c:	bl	6cc <Print::println(char const*)>
  Serial.println(" '!a val<cr>'  : set file duration (s)");
    1120:	mov	r0, r4
    1122:	ldr	r1, [pc, #76]	; (1170 <printMenu()+0xd0>)
    1124:	bl	6cc <Print::println(char const*)>
  Serial.println();
    1128:	mov	r0, r4
}
    112a:	ldmia.w	sp!, {r4, lr}
  Serial.println(" '?a'  : get file duration (s)");
  Serial.println();
  Serial.println(" '!d yyyy/mm/dd<cr>'  : set date");
  Serial.println(" '!t hh:mm:ss<cr>'    : set time");
  Serial.println(" '!a val<cr>'  : set file duration (s)");
  Serial.println();
    112e:	b.w	a0c0 <Print::println()>
    1132:	nop
    1134:	.word	0x1fff136c
    1138:	.word	0x00012503
    113c:	.word	0x0001250a
    1140:	.word	0x0001251e
    1144:	.word	0x00012539
    1148:	.word	0x00012553
    114c:	.word	0x0001257d
    1150:	.word	0x00012591
    1154:	.word	0x000125a4
    1158:	.word	0x000125b8
    115c:	.word	0x000125d5
    1160:	.word	0x000125e7
    1164:	.word	0x000125f9
    1168:	.word	0x00012618
    116c:	.word	0x00012639
    1170:	.word	0x0001265a

00001174 <printMenuEntries()>:
}

void printMenuEntries(void)
{
    1174:	push	{r0, r1, r2, r3, r4, lr}
    tmElements_t tm;
    breakTime(rtc_get(), tm);

  Serial.println("CVAS_V3 Version: " __DATE__  " " __TIME__ );
    1176:	ldr	r4, [pc, #96]	; (11d8 <printMenuEntries()+0x64>)
}

void printMenuEntries(void)
{
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    1178:	bl	9344 <rtc_get>
    117c:	add	r1, sp, #8
    117e:	bl	14c8 <breakTime(unsigned long, tmElements_t&)>

  Serial.println("CVAS_V3 Version: " __DATE__  " " __TIME__ );
    1182:	ldr	r1, [pc, #88]	; (11dc <printMenuEntries()+0x68>)
    1184:	mov	r0, r4
    1186:	bl	6cc <Print::println(char const*)>
  Serial.printf("Teensy: %d: %06x\n",teensy,SerNum);
    118a:	ldr	r3, [pc, #84]	; (11e0 <printMenuEntries()+0x6c>)
    118c:	ldr	r1, [pc, #84]	; (11e4 <printMenuEntries()+0x70>)
    118e:	ldr	r3, [r3, #0]
    1190:	movs	r2, #36	; 0x24
    1192:	mov	r0, r4
    1194:	bl	a0e0 <Print::printf(char const*, ...)>
  Serial.printf("Date d = %04d/%02d/%02d\n",tmYearToCalendar(tm.Year), tm.Month, tm.Day); 
    1198:	ldrb.w	r2, [sp, #14]
    119c:	ldrb.w	r1, [sp, #12]
    11a0:	ldrb.w	r3, [sp, #13]
    11a4:	str	r1, [sp, #0]
    11a6:	addw	r2, r2, #1970	; 0x7b2
    11aa:	ldr	r1, [pc, #60]	; (11e8 <printMenuEntries()+0x74>)
    11ac:	mov	r0, r4
    11ae:	bl	a0e0 <Print::printf(char const*, ...)>
  Serial.printf("Time t = %02d:%02d:%02d\n",tm.Hour, tm.Minute, tm.Second); 
    11b2:	ldrb.w	r1, [sp, #8]
    11b6:	ldrb.w	r3, [sp, #9]
    11ba:	ldrb.w	r2, [sp, #10]
    11be:	str	r1, [sp, #0]
    11c0:	mov	r0, r4
    11c2:	ldr	r1, [pc, #40]	; (11ec <printMenuEntries()+0x78>)
    11c4:	bl	a0e0 <Print::printf(char const*, ...)>
  Serial.printf("T_acq a = %d\n",t_acq); 
    11c8:	ldr	r3, [pc, #36]	; (11f0 <printMenuEntries()+0x7c>)
    11ca:	ldr	r1, [pc, #40]	; (11f4 <printMenuEntries()+0x80>)
    11cc:	ldr	r2, [r3, #0]
    11ce:	mov	r0, r4
    11d0:	bl	a0e0 <Print::printf(char const*, ...)>
}
    11d4:	add	sp, #16
    11d6:	pop	{r4, pc}
    11d8:	.word	0x1fff136c
    11dc:	.word	0x00012681
    11e0:	.word	0x1fff222c
    11e4:	.word	0x000126a7
    11e8:	.word	0x000126b9
    11ec:	.word	0x000126d2
    11f0:	.word	0x1fff0f38
    11f4:	.word	0x000126eb

000011f8 <menuGetInt(int*)>:

int menuGetInt(int *val)
{ char buffer[40];
    11f8:	push	{r4, lr}
    11fa:	mov	r4, r0
    11fc:	sub	sp, #40	; 0x28
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    11fe:	bl	9088 <usb_serial_available>
  while(!Serial.available());
    1202:	cmp	r0, #0
    1204:	beq.n	11fe <menuGetInt(int*)+0x6>
  int count = Serial.readBytesUntil('\r',buffer,40);
    1206:	mov	r2, sp
    1208:	movs	r3, #40	; 0x28
    120a:	movs	r1, #13
    120c:	ldr	r0, [pc, #28]	; (122c <menuGetInt(int*)+0x34>)
    120e:	bl	a270 <Stream::readBytesUntil(char, char*, unsigned int)>
  buffer[count]=0;
    1212:	add	r3, sp, #40	; 0x28
    1214:	add	r0, r3
    1216:	movs	r3, #0
    1218:	strb.w	r3, [r0, #-40]
//  Serial.println(buffer);
  return sscanf(buffer,"%d",val);
    121c:	mov	r2, r4
    121e:	ldr	r1, [pc, #16]	; (1230 <menuGetInt(int*)+0x38>)
    1220:	mov	r0, sp
    1222:	bl	be04 <sscanf>
}
    1226:	add	sp, #40	; 0x28
    1228:	pop	{r4, pc}
    122a:	nop
    122c:	.word	0x1fff136c
    1230:	.word	0x00012778

00001234 <menuGet3Int(int*, int*, int*)>:

int menuGet3Int(int *val1, int *val2, int *val3)
{ char buffer[40];
    1234:	push	{r4, r5, r6, lr}
    1236:	mov	r4, r0
    1238:	sub	sp, #64	; 0x40
    123a:	mov	r5, r1
    123c:	mov	r6, r2
    123e:	bl	9088 <usb_serial_available>
  while(!Serial.available());
    1242:	cmp	r0, #0
    1244:	beq.n	123e <menuGet3Int(int*, int*, int*)+0xa>
  int count = Serial.readBytesUntil('\r',buffer,40);
    1246:	add	r2, sp, #24
    1248:	movs	r3, #40	; 0x28
    124a:	movs	r1, #13
    124c:	ldr	r0, [pc, #40]	; (1278 <menuGet3Int(int*, int*, int*)+0x44>)
    124e:	bl	a270 <Stream::readBytesUntil(char, char*, unsigned int)>
  buffer[count]=0;
    1252:	add	r3, sp, #64	; 0x40
    1254:	add	r0, r3
    1256:	movs	r3, #0
    1258:	strb.w	r3, [r0, #-40]
//  Serial.println(buffer);
  char c1,c2;
  return sscanf(buffer,"%d%c%d%c%d",val1,&c1,val2,&c2,val3);
    125c:	add.w	r3, sp, #23
    1260:	str	r3, [sp, #4]
    1262:	str	r6, [sp, #8]
    1264:	str	r5, [sp, #0]
    1266:	add.w	r3, sp, #22
    126a:	mov	r2, r4
    126c:	ldr	r1, [pc, #12]	; (127c <menuGet3Int(int*, int*, int*)+0x48>)
    126e:	add	r0, sp, #24
    1270:	bl	be04 <sscanf>
}
    1274:	add	sp, #64	; 0x40
    1276:	pop	{r4, r5, r6, pc}
    1278:	.word	0x1fff136c
    127c:	.word	0x000126f9

00001280 <menu()>:
#if defined (KINETISK) 
#define CPU_RESTART 
#endif

int16_t menu(void)
{
    1280:	push	{r4, lr}
    1282:	sub	sp, #32
    1284:	bl	9088 <usb_serial_available>
  if(!Serial.available()) return 0;
    1288:	cmp	r0, #0
    128a:	beq.w	1408 <menu()+0x188>
        virtual int read() { return usb_serial_getchar(); }
    128e:	bl	9004 <usb_serial_getchar>

  char ch=Serial.read();
    1292:	uxtb	r0, r0
  if(ch==':')
    1294:	cmp	r0, #58	; 0x3a
    1296:	bne.n	1318 <menu()+0x98>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    1298:	bl	9088 <usb_serial_available>
  { while(!Serial.available()) ; ch=Serial.read();
    129c:	cmp	r0, #0
    129e:	beq.n	1298 <menu()+0x18>
        virtual int read() { return usb_serial_getchar(); }
    12a0:	bl	9004 <usb_serial_getchar>
    12a4:	uxtb	r0, r0

    if(ch=='s') { Serial.print("\n"); Serial.print("start"); return  +1;} // start acq
    12a6:	cmp	r0, #115	; 0x73
    12a8:	bne.n	12be <menu()+0x3e>
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
    12aa:	ldr	r1, [pc, #356]	; (1410 <menu()+0x190>)
    12ac:	ldr	r0, [pc, #356]	; (1414 <menu()+0x194>)
    12ae:	bl	6a8 <Print::write(char const*)>
    12b2:	ldr	r1, [pc, #356]	; (1418 <menu()+0x198>)
    12b4:	ldr	r0, [pc, #348]	; (1414 <menu()+0x194>)
    12b6:	bl	6a8 <Print::write(char const*)>
    12ba:	movs	r0, #1
    12bc:	b.n	140a <menu()+0x18a>
    else if(ch=='e') { Serial.print("\n"); Serial.print("stop");  return  -1;} // end acq
    12be:	cmp	r0, #101	; 0x65
    12c0:	bne.n	12d8 <menu()+0x58>
    12c2:	ldr	r1, [pc, #332]	; (1410 <menu()+0x190>)
    12c4:	ldr	r0, [pc, #332]	; (1414 <menu()+0x194>)
    12c6:	bl	6a8 <Print::write(char const*)>
    12ca:	ldr	r1, [pc, #336]	; (141c <menu()+0x19c>)
    12cc:	ldr	r0, [pc, #324]	; (1414 <menu()+0x194>)
    12ce:	bl	6a8 <Print::write(char const*)>
    12d2:	mov.w	r0, #4294967295
    12d6:	b.n	140a <menu()+0x18a>
    else if(ch=='h') { printMenu(); return 0;} 
    12d8:	cmp	r0, #104	; 0x68
    12da:	bne.n	12e2 <menu()+0x62>
    12dc:	bl	10a0 <printMenu()>
    12e0:	b.n	1408 <menu()+0x188>
    else if(ch=='w') { saveParameters(); return 0;} 
    12e2:	cmp	r0, #119	; 0x77
    12e4:	bne.n	12ec <menu()+0x6c>
    12e6:	bl	1084 <saveParameters()>
    12ea:	b.n	1408 <menu()+0x188>
    else if(ch=='l') { listDisks(); return 0;} 
    12ec:	cmp	r0, #108	; 0x6c
    12ee:	bne.n	12f6 <menu()+0x76>
    12f0:	bl	1d38 <listDisks()>
    12f4:	b.n	1408 <menu()+0x188>
    else if(ch=='b') { Serial.print("\n"); Serial.print("rebooting CPU"); Serial.flush(); delay(100); CPU_RESTART; return 0;} 
    12f6:	cmp	r0, #98	; 0x62
    12f8:	bne.w	1408 <menu()+0x188>
    12fc:	ldr	r1, [pc, #272]	; (1410 <menu()+0x190>)
    12fe:	ldr	r0, [pc, #276]	; (1414 <menu()+0x194>)
    1300:	bl	6a8 <Print::write(char const*)>
    1304:	ldr	r1, [pc, #280]	; (1420 <menu()+0x1a0>)
    1306:	ldr	r0, [pc, #268]	; (1414 <menu()+0x194>)
    1308:	bl	6a8 <Print::write(char const*)>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    130c:	bl	9214 <usb_serial_flush_output>
    1310:	movs	r0, #100	; 0x64
    1312:	bl	9454 <delay>
    1316:	b.n	1408 <menu()+0x188>
  }
  else if(ch=='?') // get info
    1318:	cmp	r0, #63	; 0x3f
    131a:	bne.n	1386 <menu()+0x106>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    131c:	bl	9088 <usb_serial_available>
  {
    while(!Serial.available()) ; ch=Serial.read();
    1320:	cmp	r0, #0
    1322:	beq.n	131c <menu()+0x9c>
        virtual int read() { return usb_serial_getchar(); }
    1324:	bl	9004 <usb_serial_getchar>
    1328:	uxtb	r4, r0

    tmElements_t tm;
    breakTime(rtc_get(), tm);
    132a:	bl	9344 <rtc_get>
    132e:	add	r1, sp, #24
    1330:	bl	14c8 <breakTime(unsigned long, tmElements_t&)>

    if(ch=='p') { printMenuEntries(); return 0;} 
    1334:	cmp	r4, #112	; 0x70
    1336:	bne.n	133e <menu()+0xbe>
    1338:	bl	1174 <printMenuEntries()>
    133c:	b.n	1408 <menu()+0x188>
    else if(ch=='d') { Serial.printf("%04d/%02d/%02d\n",tmYearToCalendar(tm.Year), tm.Month, tm.Day); return  0;} // display date
    133e:	cmp	r4, #100	; 0x64
    1340:	bne.n	1358 <menu()+0xd8>
    1342:	ldrb.w	r2, [sp, #30]
    1346:	ldrb.w	r1, [sp, #28]
    134a:	str	r1, [sp, #0]
    134c:	ldrb.w	r3, [sp, #29]
    1350:	ldr	r1, [pc, #208]	; (1424 <menu()+0x1a4>)
    1352:	addw	r2, r2, #1970	; 0x7b2
    1356:	b.n	136c <menu()+0xec>
    else if(ch=='t') { Serial.printf("%02d:%02d:%02d\n",tm.Hour, tm.Minute, tm.Second); return  0;} // display time
    1358:	cmp	r4, #116	; 0x74
    135a:	bne.n	1374 <menu()+0xf4>
    135c:	ldrb.w	r1, [sp, #24]
    1360:	str	r1, [sp, #0]
    1362:	ldrb.w	r3, [sp, #25]
    1366:	ldrb.w	r2, [sp, #26]
    136a:	ldr	r1, [pc, #188]	; (1428 <menu()+0x1a8>)
    136c:	ldr	r0, [pc, #164]	; (1414 <menu()+0x194>)
    136e:	bl	a0e0 <Print::printf(char const*, ...)>
    1372:	b.n	1408 <menu()+0x188>
    else if(ch=='a') { Serial.printf("%d\n",t_acq); return  0;} // file size
    1374:	cmp	r4, #97	; 0x61
    1376:	bne.n	1408 <menu()+0x188>
    1378:	ldr	r3, [pc, #176]	; (142c <menu()+0x1ac>)
    137a:	ldr	r1, [pc, #180]	; (1430 <menu()+0x1b0>)
    137c:	ldr	r2, [r3, #0]
    137e:	ldr	r0, [pc, #148]	; (1414 <menu()+0x194>)
    1380:	bl	a0e0 <Print::printf(char const*, ...)>
    1384:	b.n	1408 <menu()+0x188>
  }
  else if(ch=='!') // set 
    1386:	cmp	r0, #33	; 0x21
    1388:	bne.n	1408 <menu()+0x188>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    138a:	bl	9088 <usb_serial_available>
  { 
    while(!Serial.available()) ;
    138e:	cmp	r0, #0
    1390:	beq.n	138a <menu()+0x10a>
        virtual int read() { return usb_serial_getchar(); }
    1392:	bl	9004 <usb_serial_getchar>
    ch=Serial.read();
    1396:	uxtb	r0, r0
    if(ch=='d') // set date
    1398:	cmp	r0, #100	; 0x64
    139a:	bne.n	13c8 <menu()+0x148>
    { int year,month,day;
      menuGet3Int(&year,&month,&day);
    139c:	add	r2, sp, #20
    139e:	add	r1, sp, #16
    13a0:	add	r0, sp, #12
    13a2:	bl	1234 <menuGet3Int(int*, int*, int*)>
      tmElements_t tm;
      breakTime(rtc_get(), tm);
    13a6:	bl	9344 <rtc_get>
    13aa:	add	r1, sp, #24
    13ac:	bl	14c8 <breakTime(unsigned long, tmElements_t&)>

      setRTCTime(tm.Hour, tm.Minute, tm.Second, day, month, year);
    13b0:	ldr	r3, [sp, #12]
    13b2:	str	r3, [sp, #4]
    13b4:	ldr	r3, [sp, #16]
    13b6:	str	r3, [sp, #0]
    13b8:	ldrb.w	r2, [sp, #24]
    13bc:	ldrb.w	r1, [sp, #25]
    13c0:	ldrb.w	r0, [sp, #26]
    13c4:	ldr	r3, [sp, #20]
    13c6:	b.n	13f8 <menu()+0x178>
      return  0;
    } 
    else if(ch=='t') // set time
    13c8:	cmp	r0, #116	; 0x74
    13ca:	bne.n	13fe <menu()+0x17e>
    { int hour,minutes,seconds;
      menuGet3Int(&hour,&minutes,&seconds);
    13cc:	add	r2, sp, #20
    13ce:	add	r1, sp, #16
    13d0:	add	r0, sp, #12
    13d2:	bl	1234 <menuGet3Int(int*, int*, int*)>

      tmElements_t tm;
      breakTime(rtc_get(), tm);
    13d6:	bl	9344 <rtc_get>
    13da:	add	r1, sp, #24
    13dc:	bl	14c8 <breakTime(unsigned long, tmElements_t&)>
      setRTCTime(hour, minutes, seconds, tm.Day, tm.Month, tmYearToCalendar(tm.Year));
    13e0:	ldrb.w	r2, [sp, #30]
    13e4:	ldrb.w	r3, [sp, #28]
    13e8:	addw	r2, r2, #1970	; 0x7b2
    13ec:	str	r2, [sp, #4]
    13ee:	ldrb.w	r2, [sp, #29]
    13f2:	str	r2, [sp, #0]
    13f4:	add	r0, sp, #12
    13f6:	ldmia	r0, {r0, r1, r2}
    13f8:	bl	16b4 <setRTCTime(int, int, int, int, int, int)>
    13fc:	b.n	1408 <menu()+0x188>
      return  0;
    } 
    else if(ch=='a') { menuGetInt(&t_acq); return  0;} // file size
    13fe:	cmp	r0, #97	; 0x61
    1400:	bne.n	1408 <menu()+0x188>
    1402:	ldr	r0, [pc, #40]	; (142c <menu()+0x1ac>)
    1404:	bl	11f8 <menuGetInt(int*)>
    1408:	movs	r0, #0
  }
  return 0;
}
    140a:	add	sp, #32
    140c:	pop	{r4, pc}
    140e:	nop
    1410:	.word	0x00012ca0
    1414:	.word	0x1fff136c
    1418:	.word	0x00012704
    141c:	.word	0x0001270a
    1420:	.word	0x0001270f
    1424:	.word	0x000126c2
    1428:	.word	0x000126db
    142c:	.word	0x1fff0f38
    1430:	.word	0x000126f5

00001434 <getTeensySerial()>:

#else
  uint32_t getTeensySerial(void) 
  {
    uint32_t num = 0;
    __disable_irq();
    1434:	cpsid	i
      FTFL_FSTAT = FTFL_FSTAT_CCIF;
      while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
      num = *(uint32_t *)&FTFL_FCCOB7;
    #elif defined(HAS_KINETIS_FLASH_FTFE)
      kinetis_hsrun_disable();
      FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    1436:	ldr	r3, [pc, #32]	; (1458 <getTeensySerial()+0x24>)
      *(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    1438:	ldr	r1, [pc, #32]	; (145c <getTeensySerial()+0x28>)
      FTFL_FSTAT = FTFL_FSTAT_CCIF;
      while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
      num = *(uint32_t *)&FTFL_FCCOB7;
    #elif defined(HAS_KINETIS_FLASH_FTFE)
      kinetis_hsrun_disable();
      FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    143a:	movs	r2, #112	; 0x70
    143c:	strb	r2, [r3, #0]
      *(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    143e:	ldr	r2, [pc, #32]	; (1460 <getTeensySerial()+0x2c>)
    1440:	str	r1, [r2, #0]
      FTFL_FSTAT = FTFL_FSTAT_CCIF;
    1442:	movs	r2, #128	; 0x80
    1444:	strb	r2, [r3, #0]
      while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    1446:	ldrb	r2, [r3, #0]
    1448:	lsls	r2, r2, #24
    144a:	bpl.n	1446 <getTeensySerial()+0x12>
      num = *(uint32_t *)&FTFL_FCCOBB;
    144c:	ldr	r3, [pc, #20]	; (1464 <getTeensySerial()+0x30>)
    144e:	ldr	r0, [r3, #0]
      kinetis_hsrun_enable();
    #endif
    __enable_irq();
    1450:	cpsie	i
    return num & 0xFFFFFF;
  }
    1452:	bic.w	r0, r0, #4278190080	; 0xff000000
    1456:	bx	lr
    1458:	.word	0x40020000
    145c:	.word	0x41070000
    1460:	.word	0x40020004
    1464:	.word	0x4002000c

00001468 <_write>:
  int _write(int file, const void *buf, size_t len) {
    // https://forum.pjrc.com/threads/28473-Quick-Guide-Using-printf()-on-Teensy-ARM
    Print *out;
  
    // Send both stdout and stderr to stdPrint
    if (file == stdout->_file || file == stderr->_file) {
    1468:	ldr	r3, [pc, #48]	; (149c <_write+0x34>)
    146a:	ldr	r3, [r3, #0]
#include "usb_serial.h"
Print *stdPrint = &Serial;

extern "C"
{
  int _write(int file, const void *buf, size_t len) {
    146c:	push	{r4}
    // https://forum.pjrc.com/threads/28473-Quick-Guide-Using-printf()-on-Teensy-ARM
    Print *out;
  
    // Send both stdout and stderr to stdPrint
    if (file == stdout->_file || file == stderr->_file) {
    146e:	ldr	r4, [r3, #8]
    1470:	ldrsh.w	r4, [r4, #14]
    1474:	cmp	r4, r0
    1476:	beq.n	1482 <_write+0x1a>
    1478:	ldr	r3, [r3, #12]
    147a:	ldrsh.w	r3, [r3, #14]
    147e:	cmp	r0, r3
    1480:	bne.n	1486 <_write+0x1e>
      out = stdPrint;
    1482:	ldr	r3, [pc, #28]	; (14a0 <_write+0x38>)
    1484:	ldr	r0, [r3, #0]
    } else {
      out = (Print *)file;
    }
  
    if (out == nullptr) {
    1486:	cbz	r0, 1492 <_write+0x2a>
      return len;
    }
  
    // Don't check for len == 0 for returning early, in case there's side effects
    return out->write((const uint8_t *)buf, len);
    1488:	ldr	r3, [r0, #0]
  }
    148a:	ldr.w	r4, [sp], #4
    if (out == nullptr) {
      return len;
    }
  
    // Don't check for len == 0 for returning early, in case there's side effects
    return out->write((const uint8_t *)buf, len);
    148e:	ldr	r3, [r3, #4]
    1490:	bx	r3
  }
    1492:	mov	r0, r2
    1494:	ldr.w	r4, [sp], #4
    1498:	bx	lr
    149a:	nop
    149c:	.word	0x1fff1848
    14a0:	.word	0x1fff0f3c

000014a4 <newHour()>:
    return 1;
}

int32_t hour_ = 0;
int16_t newHour(void)
{   uint32_t tx=rtc_get();
    14a4:	push	{r3, lr}
    14a6:	bl	9344 <rtc_get>
    int32_t h_ = (int32_t) tx/SECS_PER_HOUR;  // use hours since 1970 as measures
    14aa:	mov.w	r3, #3600	; 0xe10
    14ae:	udiv	r0, r0, r3
    if(hour_== h_) return 0;
    14b2:	ldr	r3, [pc, #16]	; (14c4 <newHour()+0x20>)
    14b4:	ldr	r2, [r3, #0]
    14b6:	cmp	r0, r2
    hour_ = h_;
    14b8:	itte	ne
    14ba:	strne	r0, [r3, #0]
    return 1;
    14bc:	movne	r0, #1

int32_t hour_ = 0;
int16_t newHour(void)
{   uint32_t tx=rtc_get();
    int32_t h_ = (int32_t) tx/SECS_PER_HOUR;  // use hours since 1970 as measures
    if(hour_== h_) return 0;
    14be:	moveq	r0, #0
    hour_ = h_;
    return 1;
}
    14c0:	pop	{r3, pc}
    14c2:	nop
    14c4:	.word	0x1fff2230

000014c8 <breakTime(unsigned long, tmElements_t&)>:
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    14c8:	movs	r3, #60	; 0x3c
/* functions to convert to and from system time */
/* These are for interfacing with time services and are not normally needed in a sketch */

static  const uint8_t monthDays[]={31,28,31,30,31,30,31,31,30,31,30,31}; // API starts months from 1, this array starts from 0
 
void breakTime(uint32_t timeInput, tmElements_t &tm){
    14ca:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    14ce:	udiv	r4, r0, r3
    14d2:	mls	r2, r3, r4, r0
    14d6:	strb	r2, [r1, #0]
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    14d8:	udiv	r2, r4, r3
    14dc:	mls	r3, r3, r2, r4
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    14e0:	movs	r4, #24
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    14e2:	strb	r3, [r1, #1]
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    14e4:	mov.w	r3, #3600	; 0xe10
    14e8:	udiv	r3, r0, r3
    14ec:	udiv	r2, r3, r4
    14f0:	mls	r3, r4, r2, r3
    14f4:	strb	r3, [r1, #2]
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    14f6:	movs	r2, #7
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
    14f8:	ldr	r3, [pc, #240]	; (15ec <breakTime(unsigned long, tmElements_t&)+0x124>)
    14fa:	udiv	r0, r0, r3
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    14fe:	adds	r3, r0, #4
    1500:	udiv	r2, r3, r2
    1504:	rsb	r2, r2, r2, lsl #3
    1508:	subs	r3, r3, r2
    150a:	adds	r3, #1
    150c:	movs	r4, #0
    150e:	strb	r3, [r1, #3]
  
  year = 0;  
  days = 0;
    1510:	mov	r2, r4
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    1512:	movw	r8, #365	; 0x16d
    1516:	mov.w	lr, #100	; 0x64
    151a:	mov.w	ip, #400	; 0x190
    151e:	uxtb	r6, r4
    1520:	addw	r3, r6, #1970	; 0x7b2
    1524:	ands.w	r7, r3, #3
    1528:	bne.n	1548 <breakTime(unsigned long, tmElements_t&)+0x80>
    152a:	sdiv	r5, r3, lr
    152e:	mls	r5, lr, r5, r3
    1532:	cbnz	r5, 154e <breakTime(unsigned long, tmElements_t&)+0x86>
    1534:	sdiv	r5, r3, ip
    1538:	mls	r5, ip, r5, r3
    153c:	cmp	r5, #0
    153e:	ite	ne
    1540:	movne	r5, r8
    1542:	moveq.w	r5, #366	; 0x16e
    1546:	b.n	1552 <breakTime(unsigned long, tmElements_t&)+0x8a>
    1548:	movw	r5, #365	; 0x16d
    154c:	b.n	1552 <breakTime(unsigned long, tmElements_t&)+0x8a>
    154e:	mov.w	r5, #366	; 0x16e
    1552:	add	r2, r5
    1554:	cmp	r0, r2
    1556:	add.w	r4, r4, #1
    155a:	bcs.n	151e <breakTime(unsigned long, tmElements_t&)+0x56>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
    155c:	strb	r6, [r1, #6]
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    155e:	cbnz	r7, 1586 <breakTime(unsigned long, tmElements_t&)+0xbe>
    1560:	movs	r5, #100	; 0x64
    1562:	sdiv	r4, r3, r5
    1566:	mls	r4, r5, r4, r3
    156a:	cbnz	r4, 158c <breakTime(unsigned long, tmElements_t&)+0xc4>
    156c:	mov.w	r5, #400	; 0x190
    1570:	sdiv	r4, r3, r5
    1574:	mls	r4, r5, r4, r3
    1578:	cmp	r4, #0
    157a:	movw	r4, #365	; 0x16d
    157e:	it	eq
    1580:	moveq.w	r4, #366	; 0x16e
    1584:	b.n	1590 <breakTime(unsigned long, tmElements_t&)+0xc8>
    1586:	movw	r4, #365	; 0x16d
    158a:	b.n	1590 <breakTime(unsigned long, tmElements_t&)+0xc8>
    158c:	mov.w	r4, #366	; 0x16e
  time  -= days; // now it is days in this year, starting at 0
    1590:	subs	r2, r2, r4
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    1592:	movs	r6, #100	; 0x64
    1594:	mov.w	r4, #400	; 0x190
        monthLength=29;
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    1598:	ldr.w	lr, [pc, #84]	; 15f0 <breakTime(unsigned long, tmElements_t&)+0x128>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
  time  -= days; // now it is days in this year, starting at 0
    159c:	subs	r0, r0, r2
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    159e:	sdiv	r2, r3, r6
    15a2:	mls	r6, r6, r2, r3
    15a6:	sdiv	r2, r3, r4
    15aa:	mls	r3, r4, r2, r3
    15ae:	movs	r2, #0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
    15b0:	cmp	r2, #1
    15b2:	uxtb	r5, r2
    15b4:	bne.n	15c4 <breakTime(unsigned long, tmElements_t&)+0xfc>
      if (LEAP_YEAR(year)) {
    15b6:	cbnz	r7, 15ca <breakTime(unsigned long, tmElements_t&)+0x102>
    15b8:	cbnz	r6, 15ce <breakTime(unsigned long, tmElements_t&)+0x106>
        monthLength=29;
    15ba:	cmp	r3, #0
    15bc:	ite	ne
    15be:	movne	r4, #28
    15c0:	moveq	r4, #29
    15c2:	b.n	15d0 <breakTime(unsigned long, tmElements_t&)+0x108>
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    15c4:	ldrb.w	r4, [r2, lr]
    15c8:	b.n	15d0 <breakTime(unsigned long, tmElements_t&)+0x108>
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
        monthLength=29;
      } else {
        monthLength=28;
    15ca:	movs	r4, #28
    15cc:	b.n	15d0 <breakTime(unsigned long, tmElements_t&)+0x108>
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
        monthLength=29;
    15ce:	movs	r4, #29
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    15d0:	cmp	r4, r0
    15d2:	bhi.n	15e0 <breakTime(unsigned long, tmElements_t&)+0x118>
    15d4:	adds	r2, #1
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    15d6:	cmp	r2, #12
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
      time -= monthLength;
    15d8:	sub.w	r0, r0, r4
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    15dc:	bne.n	15b0 <breakTime(unsigned long, tmElements_t&)+0xe8>
    15de:	mov	r5, r2
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    15e0:	adds	r5, #1
  tm.Day = time + 1;     // day of month
    15e2:	adds	r0, #1
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    15e4:	strb	r5, [r1, #5]
  tm.Day = time + 1;     // day of month
    15e6:	strb	r0, [r1, #4]
    15e8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    15ec:	.word	0x00015180
    15f0:	.word	0x0001271d

000015f4 <makeTime(tmElements_t const&)>:
}

uint32_t makeTime(const tmElements_t &tm){   
    15f4:	push	{r4, r5, r6, r7, lr}
  
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
    15f6:	ldr	r3, [pc, #176]	; (16a8 <makeTime(tmElements_t const&)+0xb4>)
    15f8:	ldrb	r2, [r0, #6]
    15fa:	movw	r1, #1970	; 0x7b2
    15fe:	muls	r3, r2
  for (i = 0; i < tm.Year; i++) {
    if (LEAP_YEAR(i)) {
    1600:	movs	r5, #100	; 0x64
    1602:	mov.w	r6, #400	; 0x190
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
  for (i = 0; i < tm.Year; i++) {
    1606:	subw	r4, r1, #1970	; 0x7b2
    160a:	cmp	r2, r4
    160c:	ble.n	1632 <makeTime(tmElements_t const&)+0x3e>
    if (LEAP_YEAR(i)) {
    160e:	lsls	r4, r1, #30
    1610:	bne.n	162e <makeTime(tmElements_t const&)+0x3a>
    1612:	sdiv	r4, r1, r5
    1616:	mls	r4, r5, r4, r1
    161a:	cbnz	r4, 1626 <makeTime(tmElements_t const&)+0x32>
    161c:	sdiv	r4, r1, r6
    1620:	mls	r4, r6, r4, r1
    1624:	cbnz	r4, 162e <makeTime(tmElements_t const&)+0x3a>
      seconds += SECS_PER_DAY;   // add extra days for leap years
    1626:	add.w	r3, r3, #86016	; 0x15000
    162a:	add.w	r3, r3, #384	; 0x180
    162e:	adds	r1, #1
  int i;
  uint32_t seconds;

  // seconds from 1970 till 1 jan 00:00:00 of the given year
  seconds= tm.Year*(SECS_PER_DAY * 365);
  for (i = 0; i < tm.Year; i++) {
    1630:	b.n	1606 <makeTime(tmElements_t const&)+0x12>
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    1632:	addw	r2, r2, #1970	; 0x7b2
    1636:	movs	r4, #100	; 0x64
    1638:	mov.w	r5, #400	; 0x190
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    163c:	ldrb	r6, [r0, #5]
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
      seconds += SECS_PER_DAY * 29;
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    163e:	ldr	r7, [pc, #108]	; (16ac <makeTime(tmElements_t const&)+0xb8>)
    1640:	ldr.w	lr, [pc, #108]	; 16b0 <makeTime(tmElements_t const&)+0xbc>
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    1644:	sdiv	r1, r2, r4
    1648:	mls	r4, r4, r1, r2
    164c:	sdiv	r1, r2, r5
    1650:	mls	r5, r5, r1, r2
    1654:	movs	r1, #1
    1656:	and.w	r2, r2, #3
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    165a:	cmp	r6, r1
    165c:	ble.n	1682 <makeTime(tmElements_t const&)+0x8e>
    if ( (i == 2) && LEAP_YEAR(tm.Year)) { 
    165e:	cmp	r1, #2
    1660:	bne.n	1672 <makeTime(tmElements_t const&)+0x7e>
    1662:	cbnz	r2, 1672 <makeTime(tmElements_t const&)+0x7e>
    1664:	cbnz	r4, 1668 <makeTime(tmElements_t const&)+0x74>
    1666:	cbnz	r5, 1672 <makeTime(tmElements_t const&)+0x7e>
      seconds += SECS_PER_DAY * 29;
    1668:	add.w	r3, r3, #2490368	; 0x260000
    166c:	add.w	r3, r3, #15232	; 0x3b80
    1670:	b.n	167e <makeTime(tmElements_t const&)+0x8a>
    } else {
      seconds += SECS_PER_DAY * monthDays[i-1];  //monthDay array starts from 0
    1672:	add.w	ip, r7, r1
    1676:	ldrb.w	ip, [ip, #-1]
    167a:	mla	r3, lr, ip, r3
      seconds += SECS_PER_DAY;   // add extra days for leap years
    }
  }
  
  // add days for this year, months start from 1
  for (i = 1; i < tm.Month; i++) {
    167e:	adds	r1, #1
    1680:	b.n	165a <makeTime(tmElements_t const&)+0x66>
  }
  seconds+= (tm.Day-1) * SECS_PER_DAY;
  seconds+= tm.Hour * SECS_PER_HOUR;
  seconds+= tm.Minute * SECS_PER_MIN;
  seconds+= tm.Second;
  return seconds; 
    1682:	ldrb	r2, [r0, #1]
    1684:	ldrb	r1, [r0, #2]
    1686:	rsb	r2, r2, r2, lsl #4
    168a:	mov.w	r4, #3600	; 0xe10
    168e:	lsls	r2, r2, #2
    1690:	mla	r2, r4, r1, r2
    1694:	ldrb	r1, [r0, #0]
    1696:	add	r2, r1
    1698:	ldrb	r1, [r0, #4]
    169a:	ldr	r0, [pc, #20]	; (16b0 <makeTime(tmElements_t const&)+0xbc>)
    169c:	subs	r1, #1
    169e:	mla	r0, r0, r1, r2
}
    16a2:	add	r0, r3
    16a4:	pop	{r4, r5, r6, r7, pc}
    16a6:	nop
    16a8:	.word	0x01e13380
    16ac:	.word	0x0001271d
    16b0:	.word	0x00015180

000016b4 <setRTCTime(int, int, int, int, int, int)>:

extern "C" void rtc_set(uint32_t tt);

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
    16b4:	push	{r0, r1, r4, lr}
    16b6:	ldr	r4, [sp, #20]
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
    16b8:	strb.w	r0, [sp, #2]
extern "C" void rtc_set(uint32_t tt);

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
 // year can be given as full four digit year or two digts (2010 or 10 for 2010);  
 // it is converted to years since 1970
  if( yr > 99)
    16bc:	cmp	r4, #99	; 0x63
  tm.Year = yr;
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;
    16be:	add	r0, sp, #8

void setRTCTime(int hr,int min,int sec,int dy, int mnth, int yr){
 // year can be given as full four digit year or two digts (2010 or 10 for 2010);  
 // it is converted to years since 1970
  if( yr > 99)
      yr = yr - 1970;
    16c0:	ite	gt
    16c2:	subwgt	r4, r4, #1970	; 0x7b2
  else
      yr += 30;  
    16c6:	addle	r4, #30
  
  tmElements_t tm;
  tm.Year = yr;
    16c8:	strb.w	r4, [sp, #6]
  tm.Month = mnth;
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;
    16cc:	strb.w	r2, [r0, #-8]!
  else
      yr += 30;  
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
    16d0:	ldr	r4, [sp, #16]
  tm.Day = dy;
    16d2:	strb.w	r3, [sp, #4]
  tm.Hour = hr;
  tm.Minute = min;
    16d6:	strb.w	r1, [sp, #1]
  else
      yr += 30;  
  
  tmElements_t tm;
  tm.Year = yr;
  tm.Month = mnth;
    16da:	strb.w	r4, [sp, #5]
  tm.Day = dy;
  tm.Hour = hr;
  tm.Minute = min;
  tm.Second = sec;

  uint32_t tt = makeTime(tm);
    16de:	bl	15f4 <makeTime(tmElements_t const&)>
  rtc_set(tt); // for RTC
    16e2:	bl	9350 <rtc_set>
}
    16e6:	add	sp, #8
    16e8:	pop	{r4, pc}

000016ea <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)>:
   * \param[out] dst Pointer to the location that will receive the data.
   * \param[in] callback Function to be called with each sector's data
   * \param[in] context Pointer to be passed to the callback function
   * \return true for success or false for failure.
   */
  virtual bool readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
    16ea:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    16ee:	ldr	r5, [sp, #32]
    16f0:	mov	r7, r0
    16f2:	mov	r6, r2
    16f4:	add.w	r9, r3, r1
    16f8:	mov	r4, r1
   void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
    16fa:	cmp	r4, r9
    16fc:	beq.n	171c <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x32>
       if (!readSector(sector + i, dst)) return false;
    16fe:	ldr	r3, [r7, #0]
    1700:	mov	r2, r6
    1702:	ldr	r3, [r3, #12]
    1704:	mov	r1, r4
    1706:	mov	r0, r7
    1708:	blx	r3
    170a:	add.w	r8, r4, #1
    170e:	cbz	r0, 171e <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x34>
       callback(sector + i, dst, context);
    1710:	mov	r0, r4
    1712:	ldr	r2, [sp, #36]	; 0x24
    1714:	mov	r1, r6
    1716:	blx	r5
   * \param[in] context Pointer to be passed to the callback function
   * \return true for success or false for failure.
   */
  virtual bool readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
   void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
    1718:	mov	r4, r8
    171a:	b.n	16fa <BlockDeviceInterface::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x10>
       if (!readSector(sector + i, dst)) return false;
       callback(sector + i, dst, context);
     }
     return true;
    171c:	movs	r0, #1
  }
    171e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00001722 <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)>:
   * \param[in] ns Number of sectors to be written.
   * \param[in] callback Function to be called for each sector's data
   * \param[in] context Context to pass to callback function
   * \return true for success or false for failure.
   */
  virtual bool writeSectorsCallback(uint32_t sector, size_t ns,
    1722:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1726:	mov	r5, r0
    1728:	mov	r7, r3
    172a:	add.w	r8, r2, r1
    172e:	mov	r4, r1
   const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
     for (size_t i = 0; i < ns; i++) {
    1730:	cmp	r4, r8
    1732:	beq.n	1750 <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x2e>
       if (!writeSector(sector + i, callback(sector + i, context))) return false;
    1734:	ldr	r3, [r5, #0]
    1736:	ldr	r1, [sp, #24]
    1738:	ldr	r6, [r3, #32]
    173a:	mov	r0, r4
    173c:	blx	r7
    173e:	mov	r1, r4
    1740:	mov	r2, r0
    1742:	mov	r0, r5
    1744:	blx	r6
    1746:	adds	r4, #1
    1748:	cmp	r0, #0
    174a:	bne.n	1730 <BlockDeviceInterface::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0xe>
    174c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     }
    return true;
    1750:	movs	r0, #1
  }
    1752:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00001756 <SdCardInterface::status()>:
   * \return The number of 512 byte data sectors in the card
   *         or zero if an error occurs.
   */
  virtual uint32_t sectorCount() = 0;
  /** \return card status. */
  virtual uint32_t status() {return 0XFFFFFFFF;}
    1756:	mov.w	r0, #4294967295
    175a:	bx	lr

0000175c <MySpiClass::activate()>:
    public:
        // Initialize the SPI bus.
        void begin(SdSpiConfig config) {  (void) config; SPI.begin(); }

        // Activate SPI hardware with correct speed and mode.
        void activate() { if(doTransactions) SPI.beginTransaction(m_spiSettings); }
    175c:	ldrb	r3, [r0, #8]
    175e:	push	{r4, r5, lr}
    1760:	cmp	r3, #0
    1762:	beq.n	17d8 <MySpiClass::activate()+0x7c>

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    1764:	ldr	r3, [pc, #116]	; (17dc <MySpiClass::activate()+0x80>)
    1766:	ldr	r2, [r0, #4]
    1768:	ldrb	r1, [r3, #11]
    176a:	cmp	r1, #0
    176c:	beq.n	17c0 <MySpiClass::activate()+0x64>
			__disable_irq();
    176e:	cpsid	i
			if (interruptMasksUsed & 0x01) {
    1770:	ldrb	r1, [r3, #11]
    1772:	lsls	r1, r1, #31
    1774:	bpl.n	1782 <MySpiClass::activate()+0x26>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    1776:	ldr	r0, [pc, #104]	; (17e0 <MySpiClass::activate()+0x84>)
    1778:	ldr	r1, [r3, #12]
    177a:	ldr	r4, [r0, #0]
    177c:	ands	r1, r4
    177e:	str	r1, [r3, #28]
				NVIC_ICER0 = interruptSave[0];
    1780:	str	r1, [r0, #0]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    1782:	ldrb	r1, [r3, #11]
    1784:	ldr	r4, [pc, #84]	; (17dc <MySpiClass::activate()+0x80>)
    1786:	lsls	r5, r1, #30
    1788:	bpl.n	1796 <MySpiClass::activate()+0x3a>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    178a:	ldr	r0, [pc, #88]	; (17e4 <MySpiClass::activate()+0x88>)
    178c:	ldr	r1, [r4, #16]
    178e:	ldr	r5, [r0, #0]
    1790:	ands	r1, r5
    1792:	str	r1, [r4, #32]
				NVIC_ICER1 = interruptSave[1];
    1794:	str	r1, [r0, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    1796:	ldrb	r1, [r3, #11]
    1798:	ldr	r4, [pc, #64]	; (17dc <MySpiClass::activate()+0x80>)
    179a:	lsls	r0, r1, #29
    179c:	bpl.n	17aa <MySpiClass::activate()+0x4e>
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    179e:	ldr	r0, [pc, #72]	; (17e8 <MySpiClass::activate()+0x8c>)
    17a0:	ldr	r1, [r4, #20]
    17a2:	ldr	r5, [r0, #0]
    17a4:	ands	r1, r5
    17a6:	str	r1, [r4, #36]	; 0x24
				NVIC_ICER2 = interruptSave[2];
    17a8:	str	r1, [r0, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    17aa:	ldrb	r1, [r3, #11]
    17ac:	ldr	r4, [pc, #44]	; (17dc <MySpiClass::activate()+0x80>)
    17ae:	lsls	r1, r1, #28
    17b0:	bpl.n	17be <MySpiClass::activate()+0x62>
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
    17b2:	ldr	r0, [pc, #56]	; (17ec <MySpiClass::activate()+0x90>)
    17b4:	ldr	r1, [r4, #24]
    17b6:	ldr	r5, [r0, #0]
    17b8:	ands	r1, r5
    17ba:	str	r1, [r4, #40]	; 0x28
				NVIC_ICER3 = interruptSave[3];
    17bc:	str	r1, [r0, #0]
			}
			#endif
			__enable_irq();
    17be:	cpsie	i
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    17c0:	ldr	r3, [r3, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
    17c2:	ldr	r1, [r3, #12]
    17c4:	cmp	r1, r2
    17c6:	beq.n	17d8 <MySpiClass::activate()+0x7c>
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
    17c8:	ldr	r1, [pc, #36]	; (17f0 <MySpiClass::activate()+0x94>)
    17ca:	str	r1, [r3, #0]
			port().CTAR0 = settings.ctar;
    17cc:	str	r2, [r3, #12]
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
    17ce:	orr.w	r2, r2, #1073741824	; 0x40000000
    17d2:	str	r2, [r3, #16]
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    17d4:	ldr	r2, [pc, #28]	; (17f4 <MySpiClass::activate()+0x98>)
    17d6:	str	r2, [r3, #0]
    17d8:	pop	{r4, r5, pc}
    17da:	nop
    17dc:	.word	0x1fff131c
    17e0:	.word	0xe000e180
    17e4:	.word	0xe000e184
    17e8:	.word	0xe000e188
    17ec:	.word	0xe000e18c
    17f0:	.word	0x003f4001
    17f4:	.word	0x803f0000

000017f8 <MySpiClass::send(unsigned char)>:

        // Receive a byte.
        uint8_t receive() { return SPI.transfer(0XFF); }

        // Send a byte.
        void send(uint8_t data) { SPI.transfer(data); }
    17f8:	ldr	r3, [pc, #20]	; (1810 <MySpiClass::send(unsigned char)+0x18>)
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    17fa:	ldr	r3, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    17fc:	mov.w	r2, #2147483648	; 0x80000000
    1800:	str	r2, [r3, #44]	; 0x2c
		port().PUSHR = data;
    1802:	str	r1, [r3, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    1804:	ldr	r2, [r3, #44]	; 0x2c
    1806:	cmp	r2, #0
    1808:	bge.n	1804 <MySpiClass::send(unsigned char)+0xc>
		return port().POPR;
    180a:	ldr	r3, [r3, #56]	; 0x38
    180c:	bx	lr
    180e:	nop
    1810:	.word	0x1fff131c

00001814 <__tcf_0>:
    const char *sd_str[]={"sd1"};
    const int cs[] = {10 };

    const int nsd = sizeof(cs)/sizeof(int);

    SDClass sdx[nsd];
    1814:	bx	lr

00001816 <dateTime(unsigned short*, unsigned short*, unsigned char*)>:
    uint32_t diskSpace[nsd];
    uint32_t clusterSize[nsd];

// Call back for file timestamps.  Only called for file create and sync(). needed by SDFat-beta
void dateTime(uint16_t* date, uint16_t* time, uint8_t* ms10) 
{       
    1816:	push	{r0, r1, r4, r5, r6, lr}
    1818:	mov	r5, r2
    181a:	mov	r4, r1
    181c:	mov	r6, r0
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    181e:	bl	9344 <rtc_get>
    1822:	mov	r1, sp
    1824:	bl	14c8 <breakTime(unsigned long, tmElements_t&)>
 * \param[in] day [1,31]
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
    1828:	ldrb.w	r3, [sp, #6]

    *date = FS_DATE(tmYearToCalendar(tm.Year),tm.Month, tm.Day);
    182c:	ldrb.w	r2, [sp, #5]
    1830:	ldrb.w	r1, [sp, #4]
    1834:	subs	r3, #10
    1836:	uxth	r3, r3
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    1838:	cmp	r3, #127	; 0x7f
    183a:	bhi.n	1850 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3a>
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
    183c:	cmp	r2, #12
    183e:	bhi.n	1850 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3a>
    1840:	cmp	r1, #31
    1842:	bhi.n	1850 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3a>
         year << 9 | month << 5 | day;
    1844:	orr.w	r1, r1, r2, lsl #5
    1848:	orr.w	r3, r1, r3, lsl #9
    184c:	uxth	r3, r3
    184e:	b.n	1852 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x3c>
    1850:	movs	r3, #0
    1852:	strh	r3, [r6, #0]
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    1854:	ldrb.w	r3, [sp, #2]
    1858:	ldrb.w	r1, [sp, #1]
    185c:	ldrb.w	r2, [sp]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    1860:	cmp	r3, #23
    1862:	bhi.n	187a <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
 * \param[in] second [0,59]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
    1864:	cmp	r1, #59	; 0x3b
    1866:	bhi.n	187a <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
    1868:	cmp	r2, #59	; 0x3b
    186a:	bhi.n	187a <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
         hour << 11 | minute << 5 | second >> 1;
    186c:	lsls	r1, r1, #5
    186e:	orr.w	r3, r1, r3, lsl #11
    1872:	orr.w	r3, r3, r2, lsr #1
    1876:	uxth	r3, r3
    1878:	b.n	187c <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x66>
    187a:	movs	r3, #0
    *ms10 = tm.Second & 1 ? 100 : 0;
    187c:	ands.w	r2, r2, #1
    1880:	it	ne
    1882:	movne	r2, #100	; 0x64
{       
    tmElements_t tm;
    breakTime(rtc_get(), tm);

    *date = FS_DATE(tmYearToCalendar(tm.Year),tm.Month, tm.Day);
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    1884:	strh	r3, [r4, #0]
    *ms10 = tm.Second & 1 ? 100 : 0;
    1886:	strb	r2, [r5, #0]
}
    1888:	add	sp, #8
    188a:	pop	{r4, r5, r6, pc}

0000188c <MySpiClass::send(unsigned char const*, unsigned int)>:
        { memset(buf, 0XFF, count); SPI.transfer(buf, count); return 0; }

        // Send multiple bytes.
        // Replace this function if your board has multiple byte send.
        void send(const uint8_t* buf, size_t count) 
        {  SPI.transfer((void *)buf, (void *) dummy_buffer, count); }
    188c:	mov	r3, r2
    188e:	ldr	r0, [pc, #8]	; (1898 <MySpiClass::send(unsigned char const*, unsigned int)+0xc>)
    1890:	ldr	r2, [pc, #8]	; (189c <MySpiClass::send(unsigned char const*, unsigned int)+0x10>)
    1892:	b.w	2d34 <SPIClass::transfer(void const*, void*, unsigned int)>
    1896:	nop
    1898:	.word	0x1fff131c
    189c:	.word	0x2001a9d0

000018a0 <MySpiClass::receive(unsigned char*, unsigned int)>:
        // Send a byte.
        void send(uint8_t data) { SPI.transfer(data); }

        // Receive multiple bytes.  
        // Replace this function if your board has multiple byte receive.
        uint8_t receive(uint8_t* buf, size_t count) 
    18a0:	push	{r3, r4, r5, lr}
    18a2:	mov	r4, r1
    18a4:	mov	r5, r2
        { memset(buf, 0XFF, count); SPI.transfer(buf, count); return 0; }
    18a6:	movs	r1, #255	; 0xff
    18a8:	mov	r0, r4
    18aa:	bl	8fc0 <memset>
		port().PUSHR = data | SPI_PUSHR_CTAS(1);
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
	}

	void inline transfer(void *buf, size_t count) {transfer(buf, buf, count);}
    18ae:	mov	r3, r5
    18b0:	mov	r2, r4
    18b2:	mov	r1, r4
    18b4:	ldr	r0, [pc, #8]	; (18c0 <MySpiClass::receive(unsigned char*, unsigned int)+0x20>)
    18b6:	bl	2d34 <SPIClass::transfer(void const*, void*, unsigned int)>
    18ba:	movs	r0, #0
    18bc:	pop	{r3, r4, r5, pc}
    18be:	nop
    18c0:	.word	0x1fff131c

000018c4 <MySpiClass::begin(SdSpiConfig)>:
     * 
     */

    public:
        // Initialize the SPI bus.
        void begin(SdSpiConfig config) {  (void) config; SPI.begin(); }
    18c4:	sub	sp, #16
    18c6:	add	r0, sp, #16
    18c8:	stmdb	r0, {r1, r2, r3}
    18cc:	ldr	r0, [pc, #4]	; (18d4 <MySpiClass::begin(SdSpiConfig)+0x10>)
    18ce:	add	sp, #16
    18d0:	b.w	2ae8 <SPIClass::begin()>
    18d4:	.word	0x1fff131c

000018d8 <File::dec_refcount() [clone .isra.23]>:
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	using Print::write;
private:
	void dec_refcount() {
    18d8:	push	{r4, lr}
    18da:	mov	r4, r0
		if (--(f->refcount) == 0) {
    18dc:	ldr	r0, [r0, #0]
    18de:	ldr	r3, [r0, #4]
    18e0:	subs	r3, #1
    18e2:	str	r3, [r0, #4]
    18e4:	cbnz	r3, 18f6 <File::dec_refcount() [clone .isra.23]+0x1e>
			f->close();
    18e6:	ldr	r3, [r0, #0]
    18e8:	ldr	r3, [r3, #44]	; 0x2c
    18ea:	blx	r3
			delete f;
    18ec:	ldr	r0, [r4, #0]
    18ee:	cbz	r0, 18f6 <File::dec_refcount() [clone .isra.23]+0x1e>
    18f0:	ldr	r3, [r0, #0]
    18f2:	ldr	r3, [r3, #4]
    18f4:	blx	r3
		}
		f = nullptr;
    18f6:	movs	r3, #0
    18f8:	str	r3, [r4, #0]
    18fa:	pop	{r4, pc}

000018fc <MySpiClass::deactivate()>:

        // Activate SPI hardware with correct speed and mode.
        void activate() { if(doTransactions) SPI.beginTransaction(m_spiSettings); }
        // Deactivate SPI hardware.
        void deactivate() { if(doTransactions) SPI.endTransaction(); }
    18fc:	ldrb	r3, [r0, #8]
    18fe:	cbz	r3, 193a <MySpiClass::deactivate()+0x3e>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    1900:	ldr	r3, [pc, #56]	; (193c <MySpiClass::deactivate()+0x40>)
    1902:	ldrb	r2, [r3, #11]
    1904:	cbz	r2, 193a <MySpiClass::deactivate()+0x3e>
			if (interruptMasksUsed & 0x01) {
    1906:	lsls	r0, r2, #31
				NVIC_ISER0 = interruptSave[0];
    1908:	ittt	mi
    190a:	ldrmi	r2, [pc, #52]	; (1940 <MySpiClass::deactivate()+0x44>)
    190c:	ldrmi	r1, [r3, #28]
    190e:	strmi	r1, [r2, #0]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    1910:	ldrb	r2, [r3, #11]
    1912:	lsls	r1, r2, #30
				NVIC_ISER1 = interruptSave[1];
    1914:	itttt	mi
    1916:	ldrmi	r2, [pc, #36]	; (193c <MySpiClass::deactivate()+0x40>)
    1918:	ldrmi	r1, [r2, #32]
    191a:	ldrmi	r2, [pc, #40]	; (1944 <MySpiClass::deactivate()+0x48>)
    191c:	strmi	r1, [r2, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    191e:	ldrb	r2, [r3, #11]
    1920:	lsls	r2, r2, #29
				NVIC_ISER2 = interruptSave[2];
    1922:	itttt	mi
    1924:	ldrmi	r2, [pc, #20]	; (193c <MySpiClass::deactivate()+0x40>)
    1926:	ldrmi	r1, [r2, #36]	; 0x24
    1928:	ldrmi	r2, [pc, #28]	; (1948 <MySpiClass::deactivate()+0x4c>)
    192a:	strmi	r1, [r2, #0]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    192c:	ldrb	r3, [r3, #11]
    192e:	lsls	r3, r3, #28
				NVIC_ISER3 = interruptSave[3];
    1930:	itttt	mi
    1932:	ldrmi	r3, [pc, #8]	; (193c <MySpiClass::deactivate()+0x40>)
    1934:	ldrmi	r2, [r3, #40]	; 0x28
    1936:	ldrmi	r3, [pc, #20]	; (194c <MySpiClass::deactivate()+0x50>)
    1938:	strmi	r2, [r3, #0]
    193a:	bx	lr
    193c:	.word	0x1fff131c
    1940:	.word	0xe000e100
    1944:	.word	0xe000e104
    1948:	.word	0xe000e108
    194c:	.word	0xe000e10c

00001950 <MySpiClass::receive()>:

        // Receive a byte.
        uint8_t receive() { return SPI.transfer(0XFF); }
    1950:	ldr	r3, [pc, #24]	; (196c <MySpiClass::receive()+0x1c>)
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    1952:	ldr	r3, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    1954:	mov.w	r2, #2147483648	; 0x80000000
    1958:	str	r2, [r3, #44]	; 0x2c
		port().PUSHR = data;
    195a:	movs	r2, #255	; 0xff
    195c:	str	r2, [r3, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    195e:	ldr	r2, [r3, #44]	; 0x2c
    1960:	cmp	r2, #0
    1962:	bge.n	195e <MySpiClass::receive()+0xe>
		return port().POPR;
    1964:	ldr	r0, [r3, #56]	; 0x38
    1966:	uxtb	r0, r0
    1968:	bx	lr
    196a:	nop
    196c:	.word	0x1fff131c

00001970 <Print::print(char const*)>:
    1970:	push	{r3, lr}
    1972:	bl	6a8 <Print::write(char const*)>
    1976:	pop	{r3, pc}

00001978 <Print::println(unsigned long)>:

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
    1978:	push	{r3, r4, r5, lr}
    197a:	mov	r5, r0
    197c:	bl	6c4 <Print::print(unsigned long)>
    1980:	mov	r4, r0
    1982:	mov	r0, r5
    1984:	bl	a0c0 <Print::println()>
    1988:	add	r0, r4
    198a:	pop	{r3, r4, r5, pc}

0000198c <FsVolume::bytesPerCluster() const>:
#ifndef DOXYGEN_SHOULD_SKIP_THIS
  uint32_t __attribute__((error("use sectorsPerCluster()"))) blocksPerCluster();
#endif  // DOXYGEN_SHOULD_SKIP_THIS
  /** \return the number of bytes in a cluster. */
  uint32_t bytesPerCluster() const {
    return m_fVol ? m_fVol->bytesPerCluster() :
    198c:	ldr.w	r3, [r0, #1152]	; 0x480
           m_xVol ? m_xVol->bytesPerCluster() : 0;
    1990:	cbz	r3, 19a0 <FsVolume::bytesPerCluster() const+0x14>
    1992:	ldrb	r0, [r3, #6]
    1994:	mov.w	r3, #512	; 0x200
    1998:	lsl.w	r0, r3, r0
    199c:	uxth	r0, r0
    199e:	bx	lr
    19a0:	ldr.w	r0, [r0, #1156]	; 0x484
    19a4:	cbz	r0, 19aa <FsVolume::bytesPerCluster() const+0x1e>
    19a6:	ldr.w	r0, [r0, #1084]	; 0x43c
  }
    19aa:	bx	lr

000019ac <FsVolume::clusterCount() const>:
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    19ac:	ldr.w	r3, [r0, #1152]	; 0x480
           m_xVol ? m_xVol->clusterCount() : 0;
    19b0:	cbz	r3, 19b8 <FsVolume::clusterCount() const+0xc>
  uint8_t* cacheClear() {
    return m_cache.clear();
  }
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_lastCluster - 1;
    19b2:	ldr	r0, [r3, #28]
    19b4:	subs	r0, #1
    19b6:	bx	lr
    19b8:	ldr.w	r0, [r0, #1156]	; 0x484
    19bc:	cbz	r0, 19c2 <FsVolume::clusterCount() const+0x16>
    19be:	ldr.w	r0, [r0, #1072]	; 0x430
  }
    19c2:	bx	lr

000019c4 <FsVolume::freeClusterCount() const>:
  uint8_t fatType() const {
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    19c4:	mov	r3, r0
    return m_fVol ? m_fVol->freeClusterCount() :
    19c6:	ldr.w	r0, [r0, #1152]	; 0x480
           m_xVol ? m_xVol->freeClusterCount() : 0;
    19ca:	cbz	r0, 19d0 <FsVolume::freeClusterCount() const+0xc>
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
    19cc:	b.w	6b08 <FatPartition::freeClusterCount()>
           m_xVol ? m_xVol->freeClusterCount() : 0;
    19d0:	ldr.w	r0, [r3, #1156]	; 0x484
    19d4:	cbz	r0, 19da <FsVolume::freeClusterCount() const+0x16>
    19d6:	b.w	4a2c <ExFatPartition::freeClusterCount()>
  }
    19da:	bx	lr

000019dc <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)>:
	}
	SPISettings() {
		init_AlwaysInline(4000000, MSBFIRST, SPI_MODE0);
	}
private:
	void init_MightInline(uint32_t clock, uint8_t bitOrder, uint8_t dataMode) {
    19dc:	push	{r4, r5, r6, r7, lr}
		init_AlwaysInline(clock, bitOrder, dataMode);
	}
	void init_AlwaysInline(uint32_t clock, uint8_t bitOrder, uint8_t dataMode)
	  __attribute__((__always_inline__)) {
		uint32_t t, c = SPI_CTAR_FMSZ(7);
		if (bitOrder == LSBFIRST) c |= SPI_CTAR_LSBFE;
    19de:	cmp	r2, #0
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    19e0:	ldr	r6, [pc, #76]	; (1a30 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x54>)
    19e2:	ldr	r7, [pc, #80]	; (1a34 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x58>)
		init_AlwaysInline(clock, bitOrder, dataMode);
	}
	void init_AlwaysInline(uint32_t clock, uint8_t bitOrder, uint8_t dataMode)
	  __attribute__((__always_inline__)) {
		uint32_t t, c = SPI_CTAR_FMSZ(7);
		if (bitOrder == LSBFIRST) c |= SPI_CTAR_LSBFE;
    19e4:	ite	ne
    19e6:	movne.w	r4, #939524096	; 0x38000000
    19ea:	moveq.w	r4, #956301312	; 0x39000000
				t = SPI_CTAR_PBR(2) | SPI_CTAR_BR(7) | SPI_CTAR_CSSCK(6);
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
    19ee:	movs	r2, #0
				t = ctar_clock_table[i];
				if (clock >= F_BUS / ctar_div_table[i]) break;
    19f0:	ldrh.w	r5, [r6, r2, lsl #1]
    19f4:	sdiv	r5, r7, r5
    19f8:	cmp	r1, r5
    19fa:	bcc.n	1a06 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x2a>
			}
		}
		if (dataMode & 0x08) {
    19fc:	lsls	r1, r3, #28
    19fe:	bpl.n	1a10 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x34>
			c |= SPI_CTAR_CPOL;
    1a00:	orr.w	r4, r4, #67108864	; 0x4000000
    1a04:	b.n	1a10 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x34>
				t = SPI_CTAR_PBR(2) | SPI_CTAR_BR(7) | SPI_CTAR_CSSCK(6);
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
    1a06:	adds	r5, r2, #1
    1a08:	cmp	r5, #23
    1a0a:	beq.n	19fc <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x20>
    1a0c:	mov	r2, r5
    1a0e:	b.n	19f0 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x14>
				t = ctar_clock_table[i];
    1a10:	ldr	r1, [pc, #36]	; (1a38 <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x5c>)
			}
		}
		if (dataMode & 0x08) {
			c |= SPI_CTAR_CPOL;
		}
		if (dataMode & 0x04) {
    1a12:	lsls	r3, r3, #29
			} else {	 /* F_BUS / 768 */
				t = SPI_CTAR_PBR(1) | SPI_CTAR_BR(8) | SPI_CTAR_CSSCK(7);
			}
		} else {
			for (uint32_t i=0; i<23; i++) {
				t = ctar_clock_table[i];
    1a14:	ldr.w	r2, [r1, r2, lsl #2]
			}
		}
		if (dataMode & 0x08) {
			c |= SPI_CTAR_CPOL;
		}
		if (dataMode & 0x04) {
    1a18:	bpl.n	1a2a <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)+0x4e>
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
    1a1a:	bic.w	r3, r2, #61440	; 0xf000
    1a1e:	lsrs	r2, r2, #4
    1a20:	and.w	r2, r2, #3840	; 0xf00
		}
		if (dataMode & 0x08) {
			c |= SPI_CTAR_CPOL;
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
    1a24:	orr.w	r4, r4, #33554432	; 0x2000000
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
    1a28:	orrs	r2, r3
		}
		ctar = c | t;
    1a2a:	orrs	r2, r4
    1a2c:	str	r2, [r0, #0]
    1a2e:	pop	{r4, r5, r6, r7, pc}
    1a30:	.word	0x000128a0
    1a34:	.word	0x02dc6c00
    1a38:	.word	0x00012964

00001a3c <SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)>:
#define SPI_HAS_NOTUSINGINTERRUPT 1
#define SPI_ATOMIC_VERSION 1

class SPISettings {
public:
	SPISettings(uint32_t clock, uint8_t bitOrder, uint8_t dataMode) {
    1a3c:	push	{r4, lr}
    1a3e:	mov	r4, r0
		if (__builtin_constant_p(clock)) {
			init_AlwaysInline(clock, bitOrder, dataMode);
		} else {
			init_MightInline(clock, bitOrder, dataMode);
    1a40:	bl	19dc <SPISettings::init_MightInline(unsigned long, unsigned char, unsigned char)>
		}
	}
    1a44:	mov	r0, r4
    1a46:	pop	{r4, pc}

00001a48 <MySpiClass::setSckSpeed(unsigned long)>:
        // Replace this function if your board has multiple byte send.
        void send(const uint8_t* buf, size_t count) 
        {  SPI.transfer((void *)buf, (void *) dummy_buffer, count); }

        // Save SPISettings for new max SCK frequency
        void setSckSpeed(uint32_t maxSck) {  m_spiSettings = SPISettings(maxSck, MSBFIRST, SPI_MODE0); }
    1a48:	push	{r0, r1, r4, lr}
    1a4a:	movs	r3, #0
    1a4c:	mov	r4, r0
    1a4e:	movs	r2, #1
    1a50:	add	r0, sp, #4
    1a52:	bl	1a3c <SPISettings::SPISettings(unsigned long, unsigned char, unsigned char)>
    1a56:	ldr	r3, [sp, #4]
    1a58:	str	r3, [r4, #4]
    1a5a:	add	sp, #8
    1a5c:	pop	{r4, pc}
    1a5e:	Address 0x00001a5e is out of bounds.


00001a60 <getCount()>:

    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    1a60:	ldr	r2, [pc, #16]	; (1a74 <getCount()+0x14>)
    1a62:	ldrh	r3, [r2, #0]
    1a64:	ldrh	r0, [r2, #2]
            {  
                /**
                 * @brief get number of data blocks in storage
                 * 
                 */
                if(front_ >= rear_) return front_ - rear_; return front_+ MAXBUF -rear_; 
    1a66:	cmp	r3, r0
    1a68:	it	cc
    1a6a:	addcc	r3, #160	; 0xa0
    1a6c:	subs	r0, r3, r0
    1a6e:	uxth	r0, r0

    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    1a70:	bx	lr
    1a72:	nop
    1a74:	.word	0x2001a974

00001a78 <pushData(unsigned long*)>:
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    1a78:	push	{r3, r4, r5, lr}
            { 
                /** 
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
    1a7a:	ldr	r5, [pc, #44]	; (1aa8 <pushData(unsigned long*)+0x30>)
    1a7c:	ldrh	r4, [r5, #0]
                if(f >= MAXBUF) f=0;
                if(f == rear_) return 0;
    1a7e:	ldrh	r3, [r5, #2]
            { 
                /** 
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
    1a80:	adds	r4, #1
    1a82:	uxth	r4, r4
                if(f >= MAXBUF) f=0;
    1a84:	cmp	r4, #160	; 0xa0
    1a86:	it	cs
    1a88:	movcs	r4, #0
                if(f == rear_) return 0;
    1a8a:	cmp	r3, r4
    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    1a8c:	mov	r1, r0
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
                if(f >= MAXBUF) f=0;
                if(f == rear_) return 0;
    1a8e:	beq.n	1aa4 <pushData(unsigned long*)+0x2c>

                uint32_t *ptr= data_buffer+f*NBUF_ACQ;
                memcpy(ptr,src,NBUF_ACQ*4);
    1a90:	ldr	r0, [r5, #4]
    1a92:	mov.w	r2, #1024	; 0x400
    1a96:	add.w	r0, r0, r4, lsl #10
    1a9a:	bl	8e18 <memcpy>
                front_ = f;
    1a9e:	strh	r4, [r5, #0]
                return 1;
    1aa0:	movs	r0, #1
    1aa2:	pop	{r3, r4, r5, pc}
                 * @brief push data to storage
                 * @param src is pointer to data block
                 */
                uint16_t f =front_ + 1;
                if(f >= MAXBUF) f=0;
                if(f == rear_) return 0;
    1aa4:	movs	r0, #0
    };

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    1aa6:	pop	{r3, r4, r5, pc}
    1aa8:	.word	0x2001a974

00001aac <pullData(unsigned long*, unsigned long)>:
    uint16_t pullData(uint32_t * dst, uint32_t ndbl) {return rawData.pull(dst,ndbl);}
    1aac:	push	{r4, r5, r6, lr}
                /** 
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
    1aae:	ldr	r6, [pc, #60]	; (1aec <pullData(unsigned long*, unsigned long)+0x40>)
    1ab0:	ldrh	r4, [r6, #2]
                if(r == (front_/ndbl)) return 0;
    1ab2:	ldrh	r3, [r6, #0]
                /** 
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
    1ab4:	udiv	r4, r4, r1
                if(r == (front_/ndbl)) return 0;
    1ab8:	udiv	r3, r3, r1
    1abc:	cmp	r4, r3

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    uint16_t pullData(uint32_t * dst, uint32_t ndbl) {return rawData.pull(dst,ndbl);}
    1abe:	mov	r5, r1
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
                if(r == (front_/ndbl)) return 0;
    1ac0:	beq.n	1ae8 <pullData(unsigned long*, unsigned long)+0x3c>
    1ac2:	lsls	r2, r1, #10

                uint32_t *ptr= data_buffer + r*ndbl*NBUF_ACQ;
                memcpy(dst,ptr,ndbl*NBUF_ACQ*4);
    1ac4:	ldr	r1, [r6, #4]
    1ac6:	mla	r1, r2, r4, r1
    1aca:	bl	8e18 <memcpy>
                if(++r >= (MAXBUF/ndbl)) r=0;
    1ace:	adds	r1, r4, #1
    1ad0:	uxth	r1, r1
    1ad2:	movs	r3, #160	; 0xa0
    1ad4:	udiv	r3, r3, r5
    1ad8:	cmp	r1, r3
    1ada:	it	cs
    1adc:	movcs	r1, #0
                rear_ = r*ndbl;
    1ade:	smulbb	r1, r5, r1
    1ae2:	strh	r1, [r6, #2]
                return 1;
    1ae4:	movs	r0, #1
    1ae6:	pop	{r4, r5, r6, pc}
                 * @brief pull data from storage
                 * @param dst is pointer to data blocks
                 * @param ndbl is number of data blocks
                 */
                uint16_t r = (rear_/ndbl) ;
                if(r == (front_/ndbl)) return 0;
    1ae8:	movs	r0, #0

    Data rawData(data_buffer);

    uint16_t getCount () { return rawData.getCount(); }
    uint16_t pushData(uint32_t * src){ return rawData.push(src);}
    uint16_t pullData(uint32_t * dst, uint32_t ndbl) {return rawData.pull(dst,ndbl);}
    1aea:	pop	{r4, r5, r6, pc}
    1aec:	.word	0x2001a974

00001af0 <sdCsInit(unsigned char)>:
};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}

void sdCsInit(SdCsPin_t pin) { pinMode(pin, OUTPUT); digitalWriteFast(pin, HIGH);}
    1af0:	push	{r4, lr}
    1af2:	movs	r1, #1
    1af4:	mov	r4, r0
    1af6:	bl	93b4 <pinMode>
			}
			#endif
		}
	} else {
		if (val) {
			*portSetRegister(pin) = digitalPinToBitMask(pin);
    1afa:	ldr	r3, [pc, #12]	; (1b08 <sdCsInit(unsigned char)+0x18>)
    1afc:	ldr.w	r3, [r3, r4, lsl #3]
    1b00:	movs	r2, #1
    1b02:	strb.w	r2, [r3, #128]	; 0x80
    1b06:	pop	{r4, pc}
    1b08:	.word	0x00012d80

00001b0c <sdCsWrite(unsigned char, bool)>:
void sdCsWrite(SdCsPin_t pin, bool level) { digitalWriteFast(pin, level); }
    1b0c:	ldr	r2, [pc, #20]	; (1b24 <sdCsWrite(unsigned char, bool)+0x18>)
    1b0e:	movs	r3, #1
    1b10:	ldr.w	r2, [r2, r0, lsl #3]
				CORE_PIN63_PORTCLEAR = CORE_PIN63_BITMASK;
			}
			#endif
		}
	} else {
		if (val) {
    1b14:	cbz	r1, 1b1c <sdCsWrite(unsigned char, bool)+0x10>
			*portSetRegister(pin) = digitalPinToBitMask(pin);
    1b16:	strb.w	r3, [r2, #128]	; 0x80
    1b1a:	bx	lr
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
    1b1c:	strb.w	r3, [r2, #256]	; 0x100
    1b20:	bx	lr
    1b22:	nop
    1b24:	.word	0x00012d80

00001b28 <storage_configure()>:
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    *ms10 = tm.Second & 1 ? 100 : 0;
}

void storage_configure()
{
    1b28:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    #if defined SD_SCK
      SPI.setMOSI(SD_MOSI);
    1b2c:	movs	r1, #7
    *time = FS_TIME(tm.Hour, tm.Minute, tm.Second);
    *ms10 = tm.Second & 1 ? 100 : 0;
}

void storage_configure()
{
    1b2e:	sub	sp, #56	; 0x38
    #if defined SD_SCK
      SPI.setMOSI(SD_MOSI);
    1b30:	ldr	r0, [pc, #452]	; (1cf8 <storage_configure()+0x1d0>)
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    1b32:	ldr	r5, [pc, #456]	; (1cfc <storage_configure()+0x1d4>)
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    1b34:	ldr.w	r8, [pc, #508]	; 1d34 <storage_configure()+0x20c>
    1b38:	bl	2b60 <SPIClass::setMOSI(unsigned char)>
      SPI.setMISO(SD_MISO);
    1b3c:	movs	r1, #12
    1b3e:	ldr	r0, [pc, #440]	; (1cf8 <storage_configure()+0x1d0>)
    1b40:	bl	2bfc <SPIClass::setMISO(unsigned char)>
      SPI.setSCK(SD_SCK);
    1b44:	movs	r1, #14
    1b46:	ldr	r0, [pc, #432]	; (1cf8 <storage_configure()+0x1d0>)
    1b48:	bl	2c90 <SPIClass::setSCK(unsigned char)>
    #endif

    // Set Time callback
    FsDateTime::callback = dateTime;
    1b4c:	ldr	r3, [pc, #432]	; (1d00 <storage_configure()+0x1d8>)
    1b4e:	ldr	r2, [pc, #436]	; (1d04 <storage_configure()+0x1dc>)
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    1b50:	ldr	r0, [pc, #436]	; (1d08 <storage_configure()+0x1e0>)
    1b52:	str	r2, [r3, #0]
    1b54:	movs	r1, #0
    1b56:	bl	a170 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    1b5a:	ldr	r0, [pc, #428]	; (1d08 <storage_configure()+0x1e0>)
    1b5c:	bl	a0c0 <Print::println()>
                Serial.println("No sdio storage"); 
            }
      }
      else if(cs[ii]<BUILTIN_SDCARD)
      { 
            sdCsInit(cs[ii]);
    1b60:	movs	r0, #10
    1b62:	bl	1af0 <sdCsInit(unsigned char)>
            delay(100);
    1b66:	movs	r0, #100	; 0x64
    1b68:	bl	9454 <delay>
    1b6c:	movs	r6, #0
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    1b6e:	mov.w	ip, #10
    spiConfigBackupOptions = spiConfig.options;
    1b72:	mov.w	lr, #0
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    1b76:	ldr	r3, [pc, #404]	; (1d0c <storage_configure()+0x1e4>)
    1b78:	str	r3, [sp, #28]
    1b7a:	strb.w	ip, [sp, #20]
    1b7e:	strb.w	lr, [sp, #21]
    1b82:	str.w	r8, [sp, #24]
    1b86:	add	r2, sp, #20
    1b88:	ldmia	r2, {r0, r1, r2}
    1b8a:	add	r4, sp, #32
    1b8c:	stmia.w	r4, {r0, r1, r2}
    1b90:	str	r3, [sp, #40]	; 0x28
    1b92:	strb.w	ip, [sp, #32]
    1b96:	strb.w	lr, [sp, #33]	; 0x21
    1b9a:	str.w	r8, [sp, #36]	; 0x24
    1b9e:	ldmia.w	r4, {r0, r1, r2}
    1ba2:	str.w	r3, [r5, #1212]	; 0x4bc
    1ba6:	add	r3, sp, #44	; 0x2c
    1ba8:	stmia.w	r3, {r0, r1, r2}
   *
   * \param[in] config SPI configuration.
   * \return generic card pointer.
   */
  SdCard* newCard(SdSpiConfig config) {
    m_spiCard.begin(config);
    1bac:	ldr	r4, [pc, #352]	; (1d10 <storage_configure()+0x1e8>)
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    1bae:	strb.w	ip, [r5, #1204]	; 0x4b4
    spiConfigBackupOptions = spiConfig.options;
    1bb2:	strb.w	lr, [r5, #1205]	; 0x4b5
    spiConfigBackupClock = spiConfig.maxSck;
    1bb6:	str.w	r8, [r5, #1208]	; 0x4b8
    1bba:	ldmia	r3, {r1, r2, r3}
    1bbc:	mov	r0, r4
    1bbe:	bl	7930 <SdSpiCard::begin(SdSpiConfig)>
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    m_card = m_cardFactory.newCard(spiConfig);
    return m_card && !m_card->errorCode();
    1bc2:	ldrb.w	r9, [r5, #1199]	; 0x4af
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    m_card = m_cardFactory.newCard(spiConfig);
    1bc6:	str.w	r4, [r5, #1168]	; 0x490
    1bca:	uxth	r7, r6
    return m_card && !m_card->errorCode();
    1bcc:	cmp.w	r9, #0
    1bd0:	beq.n	1bdc <storage_configure()+0xb4>
            uint16_t tries=0;
            while(!sdx[ii].sdfs.begin(SdSpiConfig(cs[ii], SHARED_SPI, SPI_SPEED, &mySpi)) && tries<10)
    1bd2:	cmp	r7, #9
    1bd4:	ite	hi
    1bd6:	movhi	r4, #0
    1bd8:	movls	r4, #1
    1bda:	b.n	1bec <storage_configure()+0xc4>
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    1bdc:	mov	r1, r4
    1bde:	subw	r0, r4, #1180	; 0x49c
    1be2:	bl	74fc <FsVolume::begin(BlockDeviceInterface*)>
    1be6:	cmp	r0, #0
    1be8:	beq.n	1bd2 <storage_configure()+0xaa>
    1bea:	mov	r4, r9
    1bec:	adds	r6, #1
    1bee:	cbz	r4, 1c0a <storage_configure()+0xe2>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    1bf0:	mov	r1, r7
    1bf2:	ldr	r0, [pc, #276]	; (1d08 <storage_configure()+0x1e0>)
    1bf4:	bl	a170 <Print::print(long)>
            { Serial.print(tries); Serial.print(" "); tries++; delay(1000); } 
    1bf8:	ldr	r1, [pc, #280]	; (1d14 <storage_configure()+0x1ec>)
    1bfa:	ldr	r0, [pc, #268]	; (1d08 <storage_configure()+0x1e0>)
    1bfc:	bl	1970 <Print::print(char const*)>
    1c00:	mov.w	r0, #1000	; 0x3e8
    1c04:	bl	9454 <delay>
      else if(cs[ii]<BUILTIN_SDCARD)
      { 
            sdCsInit(cs[ii]);
            delay(100);
            uint16_t tries=0;
            while(!sdx[ii].sdfs.begin(SdSpiConfig(cs[ii], SHARED_SPI, SPI_SPEED, &mySpi)) && tries<10)
    1c08:	b.n	1b6e <storage_configure()+0x46>
            { Serial.print(tries); Serial.print(" "); tries++; delay(1000); } 

            if(tries<10) 
    1c0a:	cmp	r7, #9
    1c0c:	ldr	r6, [pc, #264]	; (1d18 <storage_configure()+0x1f0>)
    1c0e:	ldr	r5, [pc, #268]	; (1d1c <storage_configure()+0x1f4>)
    1c10:	ldr	r7, [pc, #268]	; (1d20 <storage_configure()+0x1f8>)
    1c12:	bls.n	1c26 <storage_configure()+0xfe>
            {
                status=1;
            }
            else
            {
                Serial.println("No spi storage");
    1c14:	ldr	r1, [pc, #268]	; (1d24 <storage_configure()+0x1fc>)
    1c16:	ldr	r0, [pc, #240]	; (1d08 <storage_configure()+0x1e0>)
    1c18:	bl	6cc <Print::println(char const*)>
      }
      else
      {
            diskSize[ii]=0;
            diskSpace[ii]=0;
            clusterSize[ii]=1;
    1c1c:	movs	r3, #1
            diskSpace[ii]=diskSize[ii]=sdx[ii].sdfs.freeClusterCount();
            Serial.println(diskSize[ii]) ;Serial.print(" ");
      }
      else
      {
            diskSize[ii]=0;
    1c1e:	str	r4, [r6, #0]
            diskSpace[ii]=0;
    1c20:	str	r4, [r5, #0]
            clusterSize[ii]=1;
    1c22:	str	r3, [r7, #0]
      }
    }
}
    1c24:	b.n	1cf2 <storage_configure()+0x1ca>
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
		  * (uint64_t)sdfs.bytesPerCluster();
	}
	uint64_t totalSize() {
		return (uint64_t)sdfs.clusterCount() * (uint64_t)sdfs.bytesPerCluster();
    1c26:	ldr	r0, [pc, #256]	; (1d28 <storage_configure()+0x200>)
    1c28:	bl	19ac <FsVolume::clusterCount() const>
    1c2c:	mov	sl, r0
    1c2e:	ldr	r0, [pc, #248]	; (1d28 <storage_configure()+0x200>)
    1c30:	bl	198c <FsVolume::bytesPerCluster() const>
    1c34:	umull	r8, r9, sl, r0
	}
	bool rmdir(const char *filepath) {
		return sdfs.rmdir(filepath);
	}
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
    1c38:	ldr	r0, [pc, #236]	; (1d28 <storage_configure()+0x200>)
    1c3a:	bl	19c4 <FsVolume::freeClusterCount() const>
    1c3e:	rsb	sl, r0, sl
		  * (uint64_t)sdfs.bytesPerCluster();
    1c42:	ldr	r0, [pc, #228]	; (1d28 <storage_configure()+0x200>)
    1c44:	bl	198c <FsVolume::bytesPerCluster() const>
    1c48:	umull	r2, r3, sl, r0
    1c4c:	strd	r2, r3, [sp, #8]
      if (status)
      {
            uint64_t totalSize = sdx[ii].totalSize();
            uint64_t usedSize  = sdx[ii].usedSize();

            Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]); 
    1c50:	ldr	r3, [pc, #216]	; (1d2c <storage_configure()+0x204>)
    1c52:	ldr	r1, [pc, #220]	; (1d30 <storage_configure()+0x208>)
    1c54:	ldr	r3, [r3, #0]
    1c56:	str	r3, [sp, #0]
    1c58:	mov	r2, r4
    1c5a:	movs	r3, #10
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
	size_t print(int64_t n);
	size_t print(uint64_t n)			{ return printNumber64(n, 10, 0); }
    1c5c:	mov.w	sl, #10
    1c60:	ldr	r0, [pc, #164]	; (1d08 <storage_configure()+0x1e0>)
    1c62:	bl	a0e0 <Print::printf(char const*, ...)>
    1c66:	mov	r2, r8
    1c68:	mov	r3, r9
    1c6a:	str	r4, [sp, #4]
    1c6c:	str.w	sl, [sp]
    1c70:	ldr	r0, [pc, #148]	; (1d08 <storage_configure()+0x1e0>)
    1c72:	bl	a180 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
            Serial.print(totalSize); Serial.print(" "); Serial.println(usedSize);
    1c76:	ldr	r1, [pc, #156]	; (1d14 <storage_configure()+0x1ec>)
    1c78:	ldr	r0, [pc, #140]	; (1d08 <storage_configure()+0x1e0>)
    1c7a:	bl	1970 <Print::print(char const*)>
    1c7e:	ldrd	r2, r3, [sp, #8]
    1c82:	str	r4, [sp, #4]
    1c84:	str.w	sl, [sp]
    1c88:	ldr	r0, [pc, #124]	; (1d08 <storage_configure()+0x1e0>)
    1c8a:	bl	a180 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }
	size_t println(int64_t n)			{ return print(n) + println(); }
	size_t println(uint64_t n)			{ return print(n) + println(); }
    1c8e:	ldr	r0, [pc, #120]	; (1d08 <storage_configure()+0x1e0>)
    1c90:	bl	a0c0 <Print::println()>

            Serial.print(sdx[ii].sdfs.clusterCount()); Serial.print(" "); 
    1c94:	ldr	r0, [pc, #144]	; (1d28 <storage_configure()+0x200>)
    1c96:	bl	19ac <FsVolume::clusterCount() const>
    1c9a:	mov	r1, r0
    1c9c:	ldr	r0, [pc, #104]	; (1d08 <storage_configure()+0x1e0>)
    1c9e:	bl	6c4 <Print::print(unsigned long)>
    1ca2:	ldr	r1, [pc, #112]	; (1d14 <storage_configure()+0x1ec>)
    1ca4:	ldr	r0, [pc, #96]	; (1d08 <storage_configure()+0x1e0>)
    1ca6:	bl	1970 <Print::print(char const*)>
            Serial.print(sdx[ii].sdfs.freeClusterCount()); Serial.print(" ");
    1caa:	ldr	r0, [pc, #124]	; (1d28 <storage_configure()+0x200>)
    1cac:	bl	19c4 <FsVolume::freeClusterCount() const>
    1cb0:	mov	r1, r0
    1cb2:	ldr	r0, [pc, #84]	; (1d08 <storage_configure()+0x1e0>)
    1cb4:	bl	6c4 <Print::print(unsigned long)>
    1cb8:	ldr	r1, [pc, #88]	; (1d14 <storage_configure()+0x1ec>)
    1cba:	ldr	r0, [pc, #76]	; (1d08 <storage_configure()+0x1e0>)
    1cbc:	bl	1970 <Print::print(char const*)>

            clusterSize[ii] = sdx[ii].sdfs.bytesPerCluster()/512; // count sectors
    1cc0:	ldr	r0, [pc, #100]	; (1d28 <storage_configure()+0x200>)
    1cc2:	bl	198c <FsVolume::bytesPerCluster() const>
    1cc6:	lsrs	r1, r0, #9
            Serial.println(clusterSize[ii]) ;Serial.print(" ");
    1cc8:	ldr	r0, [pc, #60]	; (1d08 <storage_configure()+0x1e0>)
            Serial.print(totalSize); Serial.print(" "); Serial.println(usedSize);

            Serial.print(sdx[ii].sdfs.clusterCount()); Serial.print(" "); 
            Serial.print(sdx[ii].sdfs.freeClusterCount()); Serial.print(" ");

            clusterSize[ii] = sdx[ii].sdfs.bytesPerCluster()/512; // count sectors
    1cca:	str	r1, [r7, #0]
            Serial.println(clusterSize[ii]) ;Serial.print(" ");
    1ccc:	bl	1978 <Print::println(unsigned long)>
    1cd0:	ldr	r1, [pc, #64]	; (1d14 <storage_configure()+0x1ec>)
    1cd2:	ldr	r0, [pc, #52]	; (1d08 <storage_configure()+0x1e0>)
    1cd4:	bl	1970 <Print::print(char const*)>

            diskSpace[ii]=diskSize[ii]=sdx[ii].sdfs.freeClusterCount();
    1cd8:	ldr	r0, [pc, #76]	; (1d28 <storage_configure()+0x200>)
    1cda:	bl	19c4 <FsVolume::freeClusterCount() const>
    1cde:	mov	r1, r0
    1ce0:	str	r0, [r6, #0]
    1ce2:	str	r0, [r5, #0]
            Serial.println(diskSize[ii]) ;Serial.print(" ");
    1ce4:	ldr	r0, [pc, #32]	; (1d08 <storage_configure()+0x1e0>)
    1ce6:	bl	1978 <Print::println(unsigned long)>
    1cea:	ldr	r1, [pc, #40]	; (1d14 <storage_configure()+0x1ec>)
    1cec:	ldr	r0, [pc, #24]	; (1d08 <storage_configure()+0x1e0>)
    1cee:	bl	1970 <Print::print(char const*)>
            diskSize[ii]=0;
            diskSpace[ii]=0;
            clusterSize[ii]=1;
      }
    }
}
    1cf2:	add	sp, #56	; 0x38
    1cf4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    1cf8:	.word	0x1fff131c
    1cfc:	.word	0x2001a458
    1d00:	.word	0x2001ceb4
    1d04:	.word	0x00001817
    1d08:	.word	0x1fff136c
    1d0c:	.word	0x2001b9d0
    1d10:	.word	0x2001a8f8
    1d14:	.word	0x000123fa
    1d18:	.word	0x1fff2250
    1d1c:	.word	0x1fff2248
    1d20:	.word	0x2001a97c
    1d24:	.word	0x00012754
    1d28:	.word	0x2001a45c
    1d2c:	.word	0x1fff0f44
    1d30:	.word	0x00012763
    1d34:	.word	0x01f78a40

00001d38 <listDisks()>:

void listDisks(void)
{
    1d38:	push	{r0, r1, r2, r4, r5, lr}
    for(int ii=0;ii<nsd;ii++)
    {
        Serial.print("\n"); 
    1d3a:	ldr	r4, [pc, #60]	; (1d78 <listDisks()+0x40>)
    1d3c:	ldr	r5, [pc, #60]	; (1d7c <listDisks()+0x44>)
    1d3e:	mov	r0, r4
    1d40:	mov	r1, r5
    1d42:	bl	1970 <Print::print(char const*)>
        Serial.printf("Storage %d %d %s ",ii,cs[ii],sd_str[ii]);
    1d46:	ldr	r3, [pc, #56]	; (1d80 <listDisks()+0x48>)
    1d48:	ldr	r1, [pc, #56]	; (1d84 <listDisks()+0x4c>)
    1d4a:	ldr	r3, [r3, #0]
    1d4c:	str	r3, [sp, #0]
    1d4e:	movs	r2, #0
    1d50:	movs	r3, #10
    1d52:	mov	r0, r4
    1d54:	bl	a0e0 <Print::printf(char const*, ...)>
        Serial.printf("%d %d",sdx[ii].sdfs.freeClusterCount(),diskSize[ii]);
    1d58:	ldr	r0, [pc, #44]	; (1d88 <listDisks()+0x50>)
    1d5a:	bl	19c4 <FsVolume::freeClusterCount() const>
    1d5e:	ldr	r3, [pc, #44]	; (1d8c <listDisks()+0x54>)
    1d60:	ldr	r1, [pc, #44]	; (1d90 <listDisks()+0x58>)
    1d62:	ldr	r3, [r3, #0]
    1d64:	mov	r2, r0
    1d66:	mov	r0, r4
    1d68:	bl	a0e0 <Print::printf(char const*, ...)>
    }
    Serial.print("\n"); 
    1d6c:	mov	r1, r5
    1d6e:	mov	r0, r4
    1d70:	bl	1970 <Print::print(char const*)>
}
    1d74:	add	sp, #12
    1d76:	pop	{r4, r5, pc}
    1d78:	.word	0x1fff136c
    1d7c:	.word	0x00012ca0
    1d80:	.word	0x1fff0f44
    1d84:	.word	0x00012763
    1d88:	.word	0x2001a45c
    1d8c:	.word	0x1fff2250
    1d90:	.word	0x00012775

00001d94 <checkReboot()>:
{
    int ii=0;
    while((ii<nsd) && (diskSpace[ii]<MIN_SPACE)) ii++;
    if(ii<nsd) CPU_RESTART;
    return -1;
}
    1d94:	mov.w	r0, #4294967295
    1d98:	bx	lr
    1d9a:	Address 0x00001d9a is out of bounds.


00001d9c <saveData(short)>:
    return 1;
}

/* main data filing routine */
int16_t saveData(int16_t status)
{   static char dirName[80];
    1d9c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    static char fileName[80];
    static char header[512];
    static int dirFlag=0;

    if(status<CLOSED) return status; // we are stopped: don't do anything
    1da0:	subs	r4, r0, #0
    return 1;
}

/* main data filing routine */
int16_t saveData(int16_t status)
{   static char dirName[80];
    1da2:	sub	sp, #84	; 0x54
    static char fileName[80];
    static char header[512];
    static int dirFlag=0;

    if(status<CLOSED) return status; // we are stopped: don't do anything
    1da4:	blt.w	1f72 <saveData(short)+0x1d6>

    //fetch data from circular buffer
    if(pullData(diskBuffer,NDBL))
    1da8:	movs	r1, #4
    1daa:	ldr	r0, [pc, #688]	; (205c <saveData(short)+0x2c0>)
    1dac:	bl	1aac <pullData(unsigned long*, unsigned long)>
    1db0:	cmp	r0, #0
    1db2:	beq.w	1ebe <saveData(short)+0x122>
    {   disk_count++;
    1db6:	ldr	r2, [pc, #680]	; (2060 <saveData(short)+0x2c4>)
    1db8:	ldr	r3, [r2, #0]
    1dba:	adds	r3, #1
    1dbc:	str	r3, [r2, #0]
        if(status==CLOSED) // file closed: should open
    1dbe:	cbnz	r4, 1e12 <saveData(short)+0x76>
        bool doTransactions=true;

};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}
    1dc0:	ldr	r4, [pc, #672]	; (2064 <saveData(short)+0x2c8>)

static SDClass *checkDiskSpace(void)
{   static int isd_ = nsd;

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
    1dc2:	ldr.w	r8, [pc, #676]	; 2068 <saveData(short)+0x2cc>
    1dc6:	ldr.w	r9, [pc, #760]	; 20c0 <saveData(short)+0x324>
        bool doTransactions=true;

};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}
    1dca:	movs	r3, #1
    1dcc:	strb	r3, [r4, #8]
    1dce:	mov	r7, r8

static SDClass *checkDiskSpace(void)
{   static int isd_ = nsd;

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
    1dd0:	ldr.w	r5, [r8]
    1dd4:	ldr	r6, [pc, #656]	; (2068 <saveData(short)+0x2cc>)
    1dd6:	cmp	r5, #0
    1dd8:	bgt.w	1ee6 <saveData(short)+0x14a>
    1ddc:	ldr.w	r3, [r9, r5, lsl #2]
    1de0:	cmp	r3, #0
    1de2:	beq.w	1f76 <saveData(short)+0x1da>
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    1de6:	ldr	r0, [pc, #644]	; (206c <saveData(short)+0x2d0>)
    1de8:	mov.w	r3, #1224	; 0x4c8
    1dec:	mla	r0, r3, r5, r0
    1df0:	adds	r0, #4
    1df2:	bl	19c4 <FsVolume::freeClusterCount() const>
    1df6:	ldr	r3, [pc, #632]	; (2070 <saveData(short)+0x2d4>)
    1df8:	str.w	r0, [r3, r5, lsl #2]
    1dfc:	ldr	r3, [pc, #628]	; (2074 <saveData(short)+0x2d8>)
    1dfe:	ldr	r3, [r3, #0]
    1e00:	lsrs	r2, r3, #9
    1e02:	mov.w	r3, #2400	; 0x960
    1e06:	muls	r3, r2
    1e08:	cmp.w	r0, r3, lsr #10
    1e0c:	bcc.w	1f76 <saveData(short)+0x1da>
    1e10:	b.n	1ee6 <saveData(short)+0x14a>
            {
               return MUST_REBOOT; // if file open fails: don't do anything
            }
        }
        //
        if(status==OPENED) // file is open: write first record (header)
    1e12:	cmp	r4, #1
    1e14:	bne.n	1ea4 <saveData(short)+0x108>
     * @param header is pointer to header
     * 
     */
    #define MAGIC "WMXZ"
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    1e16:	bl	9344 <rtc_get>
    1e1a:	add	r1, sp, #24
    1e1c:	bl	14c8 <breakTime(unsigned long, tmElements_t&)>

    int nd=sprintf(header,"%s%04d%02d%02d_%02d%02d%02d",
            MAGIC,tmYearToCalendar(tm.Year),tm.Month,tm.Day,tm.Hour,tm.Minute,tm.Second);
    1e20:	ldrb.w	r2, [sp, #24]
    1e24:	str	r2, [sp, #16]
    1e26:	ldrb.w	r2, [sp, #25]
    1e2a:	str	r2, [sp, #12]
    1e2c:	ldrb.w	r2, [sp, #26]
    1e30:	ldr	r5, [pc, #580]	; (2078 <saveData(short)+0x2dc>)
    1e32:	ldrb.w	r3, [sp, #30]
    1e36:	str	r2, [sp, #8]
    1e38:	ldrb.w	r2, [sp, #28]
    1e3c:	str	r2, [sp, #4]
    1e3e:	ldrb.w	r2, [sp, #29]
    1e42:	str	r2, [sp, #0]
    1e44:	addw	r3, r3, #1970	; 0x7b2
    1e48:	ldr	r2, [pc, #560]	; (207c <saveData(short)+0x2e0>)
    1e4a:	ldr	r1, [pc, #564]	; (2080 <saveData(short)+0x2e4>)
    1e4c:	mov	r0, r5
    1e4e:	bl	bdb8 <sprintf>
    char *ptr = header+(nd+1);
    1e52:	adds	r0, #1

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    1e54:	movs	r2, #4
    1e56:	str	r2, [r5, r0]
    iptr[1] = (int32_t)SerNum;      // serial number
    1e58:	ldr	r2, [pc, #552]	; (2084 <saveData(short)+0x2e8>)
    tmElements_t tm;
    breakTime(rtc_get(), tm);

    int nd=sprintf(header,"%s%04d%02d%02d_%02d%02d%02d",
            MAGIC,tmYearToCalendar(tm.Year),tm.Month,tm.Day,tm.Hour,tm.Minute,tm.Second);
    char *ptr = header+(nd+1);
    1e5a:	adds	r3, r5, r0

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    iptr[1] = (int32_t)SerNum;      // serial number
    1e5c:	ldr	r2, [r2, #0]
    1e5e:	str	r2, [r3, #4]
    iptr[2] = fsamp;
    1e60:	ldr	r2, [pc, #528]	; (2074 <saveData(short)+0x2d8>)
    1e62:	ldr	r2, [r2, #0]
    1e64:	str	r2, [r3, #8]
    iptr[3] = NCHAN_ACQ;
    iptr[4] = t_acq;
    1e66:	ldr	r2, [pc, #544]	; (2088 <saveData(short)+0x2ec>)
    1e68:	ldr	r2, [r2, #0]
    1e6a:	str	r2, [r3, #16]

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    iptr[1] = (int32_t)SerNum;      // serial number
    iptr[2] = fsamp;
    iptr[3] = NCHAN_ACQ;
    1e6c:	movs	r4, #2
    iptr[4] = t_acq;
    iptr[5] = 0;
    1e6e:	movs	r2, #0

    int32_t *iptr = (int32_t *) ptr;
    iptr[0] = 4;                    // SW version
    iptr[1] = (int32_t)SerNum;      // serial number
    iptr[2] = fsamp;
    iptr[3] = NCHAN_ACQ;
    1e70:	str	r4, [r3, #12]
    iptr[4] = t_acq;
    iptr[5] = 0;
    1e72:	str	r2, [r3, #20]

    uint32_t *uptr = (uint32_t*) header;
    uptr[127] = 0x55555555;
    1e74:	movs	r3, #85	; 0x55
    1e76:	strb.w	r3, [r5, #508]	; 0x1fc
    1e7a:	strb.w	r3, [r5, #509]	; 0x1fd
    1e7e:	strb.w	r3, [r5, #510]	; 0x1fe
    1e82:	strb.w	r3, [r5, #511]	; 0x1ff
    1e86:	ldr	r3, [pc, #516]	; (208c <saveData(short)+0x2f0>)
    1e88:	ldr	r0, [r3, #16]
	virtual size_t write(const uint8_t *buf, size_t size) {
		return (f) ? f->write((void*)buf, size) : 0;
	}

	size_t write(const void *buf, size_t size) {
		return (f) ? f->write(buf, size) : 0;
    1e8a:	cbnz	r0, 1e92 <saveData(short)+0xf6>
                file = msd->open(fileName, FILE_WRITE_BEGIN); 
                if(file) 
                    status = OPENED; 
                else 
                {   Serial.println("Failing open file");
                    return MUST_REBOOT; 
    1e8c:	mvn.w	r0, #1
    1e90:	b.n	219e <saveData(short)+0x402>
    1e92:	ldr	r3, [r0, #0]
    1e94:	mov.w	r2, #512	; 0x200
    1e98:	ldr	r3, [r3, #12]
    1e9a:	mov	r1, r5
    1e9c:	blx	r3
            }
        }
        //
        if(status==OPENED) // file is open: write first record (header)
        {   makeHeader(header);
            if(file.write((const void*)header,512) < 512) return MUST_REBOOT; else status=2;
    1e9e:	cmp.w	r0, #512	; 0x200
    1ea2:	bcc.n	1e8c <saveData(short)+0xf0>
    1ea4:	ldr	r3, [pc, #484]	; (208c <saveData(short)+0x2f0>)
    1ea6:	ldr	r0, [r3, #16]
    1ea8:	cmp	r0, #0
    1eaa:	beq.n	1e8c <saveData(short)+0xf0>
    1eac:	ldr	r3, [r0, #0]
    1eae:	ldr	r1, [pc, #428]	; (205c <saveData(short)+0x2c0>)
    1eb0:	ldr	r3, [r3, #12]
    1eb2:	mov.w	r2, #4096	; 0x1000
    1eb6:	blx	r3
        }
        //
        if(status>=RUNNING) // file is open, header written: store data records
        {   
            if(file.write((const void *)diskBuffer,4*MAX_DISK_BUFFER) < 4*MAX_DISK_BUFFER) return MUST_REBOOT;
    1eb8:	cmp.w	r0, #4096	; 0x1000
    1ebc:	bcc.n	1e8c <saveData(short)+0xf0>
        }
    }
    // following is done independent of data availability
    if(status==DOCLOSE) // should close file
    1ebe:	cmp	r4, #3
    1ec0:	bne.n	1ed0 <saveData(short)+0x134>
    {
        // writes are done, so enable again transaction activations
        file.flush();
    1ec2:	ldr	r0, [pc, #456]	; (208c <saveData(short)+0x2f0>)
    1ec4:	bl	946 <File::flush()>
        file.close();
    1ec8:	ldr	r0, [pc, #448]	; (208c <saveData(short)+0x2f0>)
    1eca:	bl	e9c <File::close()>
    1ece:	b.n	1f6e <saveData(short)+0x1d2>
        status = CLOSED;
    }
    if(status==MUSTSTOP) // should close file and stop
    1ed0:	cmp	r4, #4
    1ed2:	bne.n	1f72 <saveData(short)+0x1d6>
    {   
        file.flush();
    1ed4:	ldr	r0, [pc, #436]	; (208c <saveData(short)+0x2f0>)
    1ed6:	bl	946 <File::flush()>
        file.close();
    1eda:	ldr	r0, [pc, #432]	; (208c <saveData(short)+0x2f0>)
    1edc:	bl	e9c <File::close()>
        status = STOPPED;
    1ee0:	mov.w	r0, #4294967295
    1ee4:	b.n	219e <saveData(short)+0x402>
        bool doTransactions=true;

};
MySpiClass mySpi;

void doTransactions(bool val) {mySpi.doTransactions=val;}
    1ee6:	movs	r3, #0
    1ee8:	strb	r3, [r4, #8]

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    doTransactions(false);
    if(isd<nsd) 
    1eea:	ldr	r3, [r6, #0]
    1eec:	ldr	r4, [pc, #376]	; (2068 <saveData(short)+0x2cc>)
    1eee:	cmp	r3, #0
    1ef0:	bgt.n	1f2c <saveData(short)+0x190>
    {   sdx[isd].sdfs.chvol();
    1ef2:	ldr	r5, [pc, #376]	; (206c <saveData(short)+0x2d0>)
    bool chdir(const char* path) {
    return m_fVol ? m_fVol->chdir(path) :
           m_xVol ? m_xVol->chdir(path) : false;
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
    1ef4:	ldr	r2, [pc, #408]	; (2090 <saveData(short)+0x2f4>)
        Serial.println(); Serial.print(isd);
    1ef6:	ldr	r0, [pc, #412]	; (2094 <saveData(short)+0x2f8>)
    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    doTransactions(false);
    if(isd<nsd) 
    {   sdx[isd].sdfs.chvol();
    1ef8:	mov.w	r7, #1224	; 0x4c8
    1efc:	mla	r3, r7, r3, r5
    1f00:	adds	r3, #4
    1f02:	str	r3, [r2, #0]
        Serial.println(); Serial.print(isd);
    1f04:	bl	a0c0 <Print::println()>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    1f08:	ldr	r1, [r4, #0]
    1f0a:	ldr	r0, [pc, #392]	; (2094 <saveData(short)+0x2f8>)
    1f0c:	bl	a170 <Print::print(long)>
        Serial.print(": "); Serial.print(sdx[isd].sdfs.freeClusterCount());
    1f10:	ldr	r1, [pc, #388]	; (2098 <saveData(short)+0x2fc>)
    1f12:	ldr	r0, [pc, #384]	; (2094 <saveData(short)+0x2f8>)
    1f14:	bl	1970 <Print::print(char const*)>
    1f18:	ldr	r0, [r4, #0]
    1f1a:	mla	r0, r7, r0, r5
    1f1e:	adds	r0, #4
    1f20:	bl	19c4 <FsVolume::freeClusterCount() const>
    1f24:	mov	r1, r0
    1f26:	ldr	r0, [pc, #364]	; (2094 <saveData(short)+0x2f8>)
    1f28:	bl	6c4 <Print::print(unsigned long)>
    }
    //
    if(isd != isd_) hour_=0; // set hour_ to zero to trigger creation of directories in new disk
    1f2c:	ldr	r2, [pc, #364]	; (209c <saveData(short)+0x300>)
    1f2e:	ldr	r3, [r6, #0]
    1f30:	ldr	r1, [r2, #0]
    isd_=isd;
    1f32:	str	r3, [r2, #0]
    {   sdx[isd].sdfs.chvol();
        Serial.println(); Serial.print(isd);
        Serial.print(": "); Serial.print(sdx[isd].sdfs.freeClusterCount());
    }
    //
    if(isd != isd_) hour_=0; // set hour_ to zero to trigger creation of directories in new disk
    1f34:	cmp	r3, r1
    1f36:	it	ne
    1f38:	ldrne	r1, [pc, #356]	; (20a0 <saveData(short)+0x304>)
    //fetch data from circular buffer
    if(pullData(diskBuffer,NDBL))
    {   disk_count++;
        if(status==CLOSED) // file closed: should open
        {   //doTransactions(true);
            if(!(msd=checkDiskSpace())) return MUST_REBOOT;
    1f3a:	ldr	r5, [pc, #360]	; (20a4 <saveData(short)+0x308>)
    {   sdx[isd].sdfs.chvol();
        Serial.println(); Serial.print(isd);
        Serial.print(": "); Serial.print(sdx[isd].sdfs.freeClusterCount());
    }
    //
    if(isd != isd_) hour_=0; // set hour_ to zero to trigger creation of directories in new disk
    1f3c:	itt	ne
    1f3e:	movne	r0, #0
    1f40:	strne	r0, [r1, #0]
    isd_=isd;
    if(isd==nsd) return (SDClass *) 0; else return &sdx[isd];
    1f42:	cmp	r3, #1
    1f44:	ittte	ne
    1f46:	ldrne	r2, [pc, #292]	; (206c <saveData(short)+0x2d0>)
    1f48:	movne.w	r1, #1224	; 0x4c8
    1f4c:	mlane	r3, r1, r3, r2
    1f50:	moveq	r3, #0
    //fetch data from circular buffer
    if(pullData(diskBuffer,NDBL))
    {   disk_count++;
        if(status==CLOSED) // file closed: should open
        {   //doTransactions(true);
            if(!(msd=checkDiskSpace())) return MUST_REBOOT;
    1f52:	str	r3, [r5, #0]
    1f54:	cmp	r3, #0
    1f56:	beq.n	1e8c <saveData(short)+0xf0>
            //
            if(newDirectory(dirName,dirFlag)) 
    1f58:	ldr	r4, [pc, #332]	; (20a8 <saveData(short)+0x30c>)
    1f5a:	ldr	r7, [r4, #0]
    isd_=isd;
    if(isd==nsd) return (SDClass *) 0; else return &sdx[isd];
}

static int16_t newDirectory(char *dirName, int dirFlag)
{ if(newHour())
    1f5c:	bl	14a4 <newHour()>
    1f60:	cbnz	r0, 1f7e <saveData(short)+0x1e2>
            if(newDirectory(dirName,dirFlag)) 
            {   if(!msd->sdfs.exists(dirName) && !msd->sdfs.mkdir(dirName)) dirFlag++;          
                if(!msd->sdfs.chdir(dirName)) dirFlag++; else dirFlag=0;
            }
            //
            if(dirFlag>5) return MUST_REBOOT;   // too many directory errors
    1f62:	ldr	r3, [r4, #0]
    1f64:	cmp	r3, #5
    1f66:	bgt.n	1e8c <saveData(short)+0xf0>
            if(dirFlag>0) return CLOSED;        // create new directory with different name
    1f68:	cmp	r3, #0
    1f6a:	ble.w	210e <saveData(short)+0x372>
    1f6e:	movs	r0, #0
    1f70:	b.n	219e <saveData(short)+0x402>
    1f72:	mov	r0, r4
    1f74:	b.n	219e <saveData(short)+0x402>
static SDClass *checkDiskSpace(void)
{   static int isd_ = nsd;

    doTransactions(true);
    while((isd<nsd) && ((diskSize[isd]==0) 
            || ((diskSpace[isd]=sdx[isd].sdfs.freeClusterCount()) < MIN_SPACE) )) isd++;
    1f76:	ldr	r3, [r7, #0]
    1f78:	adds	r3, #1
    1f7a:	str	r3, [r7, #0]
    1f7c:	b.n	1dd0 <saveData(short)+0x34>

static int16_t newDirectory(char *dirName, int dirFlag)
{ if(newHour())
    {   
        tmElements_t tm;
        breakTime(rtc_get(), tm);
    1f7e:	bl	9344 <rtc_get>
    1f82:	add	r1, sp, #24
    1f84:	bl	14c8 <breakTime(unsigned long, tmElements_t&)>
    1f88:	ldr	r2, [pc, #248]	; (2084 <saveData(short)+0x2e8>)
    1f8a:	ldrb.w	lr, [sp, #26]
    1f8e:	ldrb.w	r0, [sp, #28]
    1f92:	ldrb.w	r1, [sp, #29]
    1f96:	ldrb.w	r3, [sp, #30]
        if(!dirFlag)
    1f9a:	cbnz	r7, 1fb8 <saveData(short)+0x21c>
        {
            sprintf(dirName, "/%s%06x_%04d%02d%02d/%02d/", 
                          DirPrefix,(unsigned int)SerNum,
                                  tmYearToCalendar(tm.Year),tm.Month, tm.Day, tm.Hour);
    1f9c:	addw	r3, r3, #1970	; 0x7b2
    1fa0:	str	r0, [sp, #8]
    1fa2:	str	r1, [sp, #4]
    1fa4:	str.w	lr, [sp, #12]
    1fa8:	str	r3, [sp, #0]
    1faa:	ldr	r3, [r2, #0]
    1fac:	ldr	r1, [pc, #252]	; (20ac <saveData(short)+0x310>)
    1fae:	ldr	r2, [pc, #256]	; (20b0 <saveData(short)+0x314>)
    1fb0:	ldr	r0, [pc, #256]	; (20b4 <saveData(short)+0x318>)
    1fb2:	bl	bdb8 <sprintf>
    1fb6:	b.n	1fd4 <saveData(short)+0x238>
        }
        else
        {
            sprintf(dirName, "/%s%06x_%04d%02d%02d/%02d_%02d/", 
                          DirPrefix,(unsigned int)SerNum,
                                  tmYearToCalendar(tm.Year),tm.Month, tm.Day, tm.Hour,dirFlag);
    1fb8:	addw	r3, r3, #1970	; 0x7b2
    1fbc:	str	r0, [sp, #8]
    1fbe:	str	r1, [sp, #4]
    1fc0:	str	r7, [sp, #16]
    1fc2:	str.w	lr, [sp, #12]
    1fc6:	str	r3, [sp, #0]
    1fc8:	ldr	r3, [r2, #0]
    1fca:	ldr	r1, [pc, #236]	; (20b8 <saveData(short)+0x31c>)
    1fcc:	ldr	r2, [pc, #224]	; (20b0 <saveData(short)+0x314>)
    1fce:	ldr	r0, [pc, #228]	; (20b4 <saveData(short)+0x318>)
    1fd0:	bl	bdb8 <sprintf>
        }

        //
        Serial.print("\n"); Serial.print(dirName);
    1fd4:	ldr	r1, [pc, #228]	; (20bc <saveData(short)+0x320>)
    1fd6:	ldr	r0, [pc, #188]	; (2094 <saveData(short)+0x2f8>)
    1fd8:	bl	1970 <Print::print(char const*)>
    1fdc:	ldr	r1, [pc, #212]	; (20b4 <saveData(short)+0x318>)
    1fde:	ldr	r0, [pc, #180]	; (2094 <saveData(short)+0x2f8>)
    1fe0:	bl	1970 <Print::print(char const*)>
        if(status==CLOSED) // file closed: should open
        {   //doTransactions(true);
            if(!(msd=checkDiskSpace())) return MUST_REBOOT;
            //
            if(newDirectory(dirName,dirFlag)) 
            {   if(!msd->sdfs.exists(dirName) && !msd->sdfs.mkdir(dirName)) dirFlag++;          
    1fe4:	ldr	r3, [r5, #0]
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
    1fe6:	ldr.w	r1, [r3, #1156]	; 0x484
           m_xVol ? m_xVol->exists(path) : false;
    1fea:	cbz	r1, 2004 <saveData(short)+0x268>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    1fec:	movs	r3, #0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    1fee:	ldr	r2, [pc, #196]	; (20b4 <saveData(short)+0x318>)
    1ff0:	strb.w	r3, [sp, #24]
    1ff4:	add	r0, sp, #24
    1ff6:	strb.w	r3, [sp, #25]
    1ffa:	strb.w	r3, [sp, #26]
    1ffe:	bl	6270 <FatFile::open(FatVolume*, char const*, int)>
    2002:	b.n	2048 <saveData(short)+0x2ac>
    2004:	ldr.w	r0, [r3, #1160]	; 0x488
    2008:	cbnz	r0, 2030 <saveData(short)+0x294>
    200a:	ldr	r3, [r5, #0]
   * \param[in] pFlag Create missing parent directories if true.
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
    200c:	ldr.w	r1, [r3, #1156]	; 0x484
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
    2010:	cbz	r1, 204e <saveData(short)+0x2b2>
    2012:	movs	r3, #0
    2014:	strb.w	r3, [sp, #24]
    2018:	strb.w	r3, [sp, #25]
    201c:	strb.w	r3, [sp, #26]
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    2020:	ldr	r2, [pc, #144]	; (20b4 <saveData(short)+0x318>)
    2022:	movs	r3, #1
    2024:	add.w	r1, r1, #1096	; 0x448
    2028:	add	r0, sp, #24
    202a:	bl	63ec <FatFile::mkdir(FatFile*, char const*, bool)>
    202e:	b.n	20de <saveData(short)+0x342>
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    2030:	strb.w	r1, [sp, #73]	; 0x49
    2034:	strb.w	r1, [sp, #74]	; 0x4a
    2038:	strb.w	r1, [sp, #75]	; 0x4b
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    203c:	mov	r3, r1
    203e:	ldr	r2, [pc, #116]	; (20b4 <saveData(short)+0x318>)
    2040:	mov	r1, r0
    2042:	add	r0, sp, #24
    2044:	bl	472a <ExFatFile::open(ExFatVolume*, char const*, int)>
    2048:	cmp	r0, #0
    204a:	bne.n	20e2 <saveData(short)+0x346>
    204c:	b.n	200a <saveData(short)+0x26e>
    204e:	ldr.w	r0, [r3, #1160]	; 0x488
    2052:	cbnz	r0, 20c4 <saveData(short)+0x328>
    2054:	ldr	r3, [r4, #0]
    2056:	adds	r3, #1
    2058:	str	r3, [r4, #0]
    205a:	b.n	20e2 <saveData(short)+0x346>
    205c:	.word	0x2001b9e0
    2060:	.word	0x2001b9dc
    2064:	.word	0x2001b9d0
    2068:	.word	0x1fff224c
    206c:	.word	0x2001a458
    2070:	.word	0x1fff2248
    2074:	.word	0x2001c9e0
    2078:	.word	0x2001a254
    207c:	.word	0x000127e0
    2080:	.word	0x000127e5
    2084:	.word	0x1fff222c
    2088:	.word	0x1fff0f38
    208c:	.word	0x1fff2234
    2090:	.word	0x2001cec0
    2094:	.word	0x1fff136c
    2098:	.word	0x000123f9
    209c:	.word	0x1fff0f40
    20a0:	.word	0x1fff2230
    20a4:	.word	0x2001a454
    20a8:	.word	0x2001a970
    20ac:	.word	0x0001277d
    20b0:	.word	0x0001277b
    20b4:	.word	0x2001a980
    20b8:	.word	0x00012798
    20bc:	.word	0x00012ca0
    20c0:	.word	0x1fff2250
    20c4:	strb.w	r1, [sp, #73]	; 0x49
    20c8:	strb.w	r1, [sp, #74]	; 0x4a
    20cc:	strb.w	r1, [sp, #75]	; 0x4b
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    20d0:	movs	r3, #1
    20d2:	add.w	r1, r0, #1096	; 0x448
    20d6:	ldr	r2, [pc, #204]	; (21a4 <saveData(short)+0x408>)
    20d8:	add	r0, sp, #24
    20da:	bl	4fcc <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
    20de:	cmp	r0, #0
    20e0:	beq.n	2054 <saveData(short)+0x2b8>
                if(!msd->sdfs.chdir(dirName)) dirFlag++; else dirFlag=0;
    20e2:	ldr	r3, [r5, #0]
   * Set volume working directory.
   * \param[in] path Path for volume working directory.
   * \return true for success or false for failure.
   */
    bool chdir(const char* path) {
    return m_fVol ? m_fVol->chdir(path) :
    20e4:	ldr.w	r0, [r3, #1156]	; 0x484
           m_xVol ? m_xVol->chdir(path) : false;
    20e8:	cbz	r0, 20f2 <saveData(short)+0x356>
    20ea:	ldr	r1, [pc, #184]	; (21a4 <saveData(short)+0x408>)
    20ec:	bl	6c6c <FatVolume::chdir(char const*)>
    20f0:	b.n	2104 <saveData(short)+0x368>
    20f2:	ldr.w	r0, [r3, #1160]	; 0x488
    20f6:	cbnz	r0, 20fe <saveData(short)+0x362>
    20f8:	ldr	r3, [r4, #0]
    20fa:	adds	r3, #1
    20fc:	b.n	210a <saveData(short)+0x36e>
    20fe:	ldr	r1, [pc, #164]	; (21a4 <saveData(short)+0x408>)
    2100:	bl	4b74 <ExFatVolume::chdir(char const*)>
    2104:	cmp	r0, #0
    2106:	beq.n	20f8 <saveData(short)+0x35c>
    2108:	movs	r3, #0
    210a:	str	r3, [r4, #0]
    210c:	b.n	1f62 <saveData(short)+0x1c6>

}
static int16_t newFileName(char *fileName)
{
    tmElements_t tm;
    breakTime(rtc_get(), tm);
    210e:	bl	9344 <rtc_get>
    2112:	add	r1, sp, #24
    2114:	bl	14c8 <breakTime(unsigned long, tmElements_t&)>
	sprintf(fileName, "%s_%02d%02d%02d.bin", FilePrefix, tm.Hour, tm.Minute, tm.Second);
    2118:	ldrb.w	r2, [sp, #24]
    211c:	str	r2, [sp, #4]
    211e:	ldrb.w	r2, [sp, #25]
    2122:	ldrb.w	r3, [sp, #26]
    2126:	str	r2, [sp, #0]
    2128:	ldr	r1, [pc, #124]	; (21a8 <saveData(short)+0x40c>)
    212a:	ldr	r2, [pc, #128]	; (21ac <saveData(short)+0x410>)
    212c:	ldr	r0, [pc, #128]	; (21b0 <saveData(short)+0x414>)
    212e:	bl	bdb8 <sprintf>
    //
    Serial.print("\n"); Serial.print(isd); Serial.print(": ");Serial.print(fileName);
    2132:	ldr	r1, [pc, #128]	; (21b4 <saveData(short)+0x418>)
    2134:	ldr	r0, [pc, #128]	; (21b8 <saveData(short)+0x41c>)
    2136:	bl	1970 <Print::print(char const*)>
    213a:	ldr	r1, [r6, #0]
    213c:	ldr	r0, [pc, #120]	; (21b8 <saveData(short)+0x41c>)
    213e:	bl	a170 <Print::print(long)>
    2142:	ldr	r1, [pc, #120]	; (21bc <saveData(short)+0x420>)
    2144:	ldr	r0, [pc, #112]	; (21b8 <saveData(short)+0x41c>)
    2146:	bl	1970 <Print::print(char const*)>
    214a:	ldr	r1, [pc, #100]	; (21b0 <saveData(short)+0x414>)
    214c:	ldr	r0, [pc, #104]	; (21b8 <saveData(short)+0x41c>)
    214e:	bl	1970 <Print::print(char const*)>
            if(dirFlag>5) return MUST_REBOOT;   // too many directory errors
            if(dirFlag>0) return CLOSED;        // create new directory with different name

            if(newFileName(fileName))
            {   
                file = msd->open(fileName, FILE_WRITE_BEGIN); 
    2152:	ldr	r1, [r5, #0]
    2154:	ldr	r2, [pc, #88]	; (21b0 <saveData(short)+0x414>)
    2156:	ldr	r3, [r1, #0]
    2158:	add	r0, sp, #24
    215a:	ldr	r4, [r3, #0]
    215c:	movs	r3, #2
    215e:	blx	r4
	}
#ifdef FILE_USE_MOVE
	// Move assignment.
	File& operator = (const File&& file) {
		//Serial.println("File move assignment");
		if (file.f) file.f->refcount++;
    2160:	ldr	r3, [sp, #40]	; 0x28
    2162:	cbz	r3, 216a <saveData(short)+0x3ce>
    2164:	ldr	r2, [r3, #4]
    2166:	adds	r2, #1
    2168:	str	r2, [r3, #4]
		if (f) { dec_refcount(); /*Serial.println("File move assignment autoclose");*/ }
    216a:	ldr	r4, [pc, #84]	; (21c0 <saveData(short)+0x424>)
    216c:	ldr	r3, [r4, #16]
    216e:	cbz	r3, 2178 <saveData(short)+0x3dc>
    2170:	add.w	r0, r4, #16
    2174:	bl	18d8 <File::dec_refcount() [clone .isra.23]>
		f = file.f;
    2178:	ldr	r3, [sp, #40]	; 0x28
    217a:	str	r3, [r4, #16]
    217c:	add	r0, sp, #24
    217e:	bl	b00 <File::~File()>
    2182:	ldr	r0, [r4, #16]
			f->close();
			dec_refcount();
		}
	}
	operator bool() {
		return (f) ? f->isOpen() : false;
    2184:	cbnz	r0, 2190 <saveData(short)+0x3f4>
                if(file) 
                    status = OPENED; 
                else 
                {   Serial.println("Failing open file");
    2186:	ldr	r1, [pc, #60]	; (21c4 <saveData(short)+0x428>)
    2188:	ldr	r0, [pc, #44]	; (21b8 <saveData(short)+0x41c>)
    218a:	bl	6cc <Print::println(char const*)>
    218e:	b.n	1e8c <saveData(short)+0xf0>
    2190:	ldr	r3, [r0, #0]
    2192:	ldr	r3, [r3, #48]	; 0x30
    2194:	blx	r3
            if(dirFlag>0) return CLOSED;        // create new directory with different name

            if(newFileName(fileName))
            {   
                file = msd->open(fileName, FILE_WRITE_BEGIN); 
                if(file) 
    2196:	cmp	r0, #0
    2198:	bne.w	1e16 <saveData(short)+0x7a>
    219c:	b.n	2186 <saveData(short)+0x3ea>
        file.flush();
        file.close();
        status = STOPPED;
    }
    return status;
}
    219e:	add	sp, #84	; 0x54
    21a0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    21a4:	.word	0x2001a980
    21a8:	.word	0x000127ba
    21ac:	.word	0x000127b8
    21b0:	.word	0x2001a920
    21b4:	.word	0x00012ca0
    21b8:	.word	0x1fff136c
    21bc:	.word	0x000123f9
    21c0:	.word	0x1fff2234
    21c4:	.word	0x000127ce

000021c8 <_GLOBAL__sub_I_data_buffer>:
    21c8:	push	{r3, r4, r5, lr}
            { /**
             * @brief Constructor
             * @param buffer is pointer to data store
             * 
             */
                data_buffer=buffer; front_=rear_=0;
    21ca:	ldr	r3, [pc, #128]	; (224c <_GLOBAL__sub_I_data_buffer+0x84>)
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    21cc:	ldr	r0, [pc, #128]	; (2250 <_GLOBAL__sub_I_data_buffer+0x88>)

/****************************** Filing Utility *******************************************/

extern int t_acq;

File file=NULL; // is used by saveData and saveNAD
    21ce:	ldr	r5, [pc, #132]	; (2254 <_GLOBAL__sub_I_data_buffer+0x8c>)
            { /**
             * @brief Constructor
             * @param buffer is pointer to data store
             * 
             */
                data_buffer=buffer; front_=rear_=0;
    21d0:	ldr	r2, [pc, #132]	; (2258 <_GLOBAL__sub_I_data_buffer+0x90>)
    21d2:	str	r2, [r3, #4]
    21d4:	movs	r4, #0
    21d6:	strh	r4, [r3, #2]
    21d8:	strh	r4, [r3, #0]
    21da:	mov.w	r3, #1000	; 0x3e8

/****************************** Filing Utility *******************************************/

extern int t_acq;

File file=NULL; // is used by saveData and saveNAD
    21de:	mov	r2, r5
    21e0:	strb	r4, [r0, #4]
    21e2:	str	r3, [r0, #8]
    21e4:	strb	r4, [r0, #12]
	// Explicit FileImpl constructor.  Used by libraries which provide
	// access to files stored on media.  Normally this is used within
	// functions derived from FS::open() and FileImpl::openNextFile().
	// Not normally called used from ordinary programs or libraries
	// which only access files.
	File(FileImpl *file) {
    21e6:	ldr	r3, [pc, #116]	; (225c <_GLOBAL__sub_I_data_buffer+0x94>)
    21e8:	ldr	r1, [pc, #116]	; (2260 <_GLOBAL__sub_I_data_buffer+0x98>)
    21ea:	str	r3, [r0, #0]
		f = file;
    21ec:	str	r4, [r0, #16]
    21ee:	bl	a428 <__aeabi_atexit>
// This is a simple driver based on the the standard SPI.h library.
// You can write a driver entirely independent of SPI.h.
// It can be optimized for your board or a different SPI port can be used.
// The driver must be derived from SdSpiBaseClass.
// See: SdFat/src/SpiDriver/SdSpiBaseClass.h
class MySpiClass : public SdSpiBaseClass {
    21f2:	ldr	r3, [pc, #112]	; (2264 <_GLOBAL__sub_I_data_buffer+0x9c>)
    21f4:	ldr	r2, [pc, #112]	; (2268 <_GLOBAL__sub_I_data_buffer+0xa0>)
    21f6:	str	r2, [r3, #0]
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
		}
		ctar = c | t;
    21f8:	ldr	r2, [pc, #112]	; (226c <_GLOBAL__sub_I_data_buffer+0xa4>)
    21fa:	str	r2, [r3, #4]
    21fc:	movs	r2, #1
    21fe:	strb	r2, [r3, #8]


class SDClass : public FS
{
public:
	SDClass() { }
    2200:	ldr	r3, [pc, #108]	; (2270 <_GLOBAL__sub_I_data_buffer+0xa8>)
    2202:	ldr	r1, [pc, #112]	; (2274 <_GLOBAL__sub_I_data_buffer+0xac>)
#else  // HAS_SDIO_CLASS
class SdSpiCard {
#endif  // HAS_SDIO_CLASS
 public:
  /** Construct an instance of SdSpiCard. */
  SdSpiCard() {}
    2204:	strb.w	r2, [r3, #1197]	; 0x4ad
    2208:	movs	r2, #41	; 0x29
    220a:	str	r1, [r3, #0]
    220c:	strb.w	r2, [r3, #1199]	; 0x4af
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    2210:	ldr	r1, [pc, #100]	; (2278 <_GLOBAL__sub_I_data_buffer+0xb0>)
    2212:	str.w	r1, [r3, #1172]	; 0x494
    2216:	movs	r2, #255	; 0xff
    2218:	ldr	r1, [pc, #96]	; (227c <_GLOBAL__sub_I_data_buffer+0xb4>)
    221a:	strb.w	r2, [r3, #1221]	; 0x4c5
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    221e:	strb.w	r4, [r3, #1180]	; 0x49c
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    2222:	strb.w	r4, [r3, #1181]	; 0x49d
    2226:	strb.w	r4, [r3, #1202]	; 0x4b2
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    222a:	strb.w	r4, [r3, #1216]	; 0x4c0
    222e:	str.w	r1, [r3, #1184]	; 0x4a0
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() {}
    2232:	str.w	r4, [r3, #1156]	; 0x484
    2236:	str.w	r4, [r3, #1160]	; 0x488
    223a:	strb.w	r4, [r3, #1220]	; 0x4c4
    const char *sd_str[]={"sd1"};
    const int cs[] = {10 };

    const int nsd = sizeof(cs)/sizeof(int);

    SDClass sdx[nsd];
    223e:	mov	r2, r5
    2240:	mov	r0, r4
    2242:	ldr	r1, [pc, #60]	; (2280 <_GLOBAL__sub_I_data_buffer+0xb8>)
        file.flush();
        file.close();
        status = STOPPED;
    }
    return status;
}
    2244:	ldmia.w	sp!, {r3, r4, r5, lr}
    const char *sd_str[]={"sd1"};
    const int cs[] = {10 };

    const int nsd = sizeof(cs)/sizeof(int);

    SDClass sdx[nsd];
    2248:	b.w	a428 <__aeabi_atexit>
    224c:	.word	0x2001a974
    2250:	.word	0x1fff2234
    2254:	.word	0x1fff0f30
    2258:	.word	0x1fff2254
    225c:	.word	0x00012470
    2260:	.word	0x00000b01
    2264:	.word	0x2001b9d0
    2268:	.word	0x00012734
    226c:	.word	0x38011001
    2270:	.word	0x2001a458
    2274:	.word	0x000129c8
    2278:	.word	0x00012d28
    227c:	.word	0x00012cc8
    2280:	.word	0x00001815

00002284 <TwoWire::write(int)>:
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
	}
	size_t write(int n) {
		return write((uint8_t)n);
    2284:	ldr	r3, [r0, #0]
    2286:	uxtb	r1, r1
    2288:	ldr	r3, [r3, #0]
    228a:	bx	r3

0000228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>:
        val = wire->read()<<8;
        val |= wire->read();
        return val;
    }
    
    uint8_t write16(uint8_t addr, uint16_t reg, uint16_t val) 
    228c:	push	{r3, r4, r5, r6, r7, lr}
    228e:	mov	r6, r3
    { 
        wire->beginTransmission(addr);
    2290:	ldr	r3, [r0, #0]
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
		transmitting = 1;
    2292:	movs	r5, #1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    2294:	lsls	r1, r1, #1
    2296:	strb.w	r1, [r3, #163]	; 0xa3
		transmitting = 1;
    229a:	strb.w	r5, [r3, #302]	; 0x12e
		txBufferLength = 1;
    229e:	strb.w	r5, [r3, #301]	; 0x12d
        val = wire->read()<<8;
        val |= wire->read();
        return val;
    }
    
    uint8_t write16(uint8_t addr, uint16_t reg, uint16_t val) 
    22a2:	mov	r4, r0
    22a4:	mov	r7, r2
    { 
        wire->beginTransmission(addr);
        wire->write(reg >> 8);
    22a6:	lsrs	r1, r2, #8
    22a8:	ldr	r0, [r0, #0]
    22aa:	bl	2284 <TwoWire::write(int)>
        wire->write(reg);
    22ae:	mov	r1, r7
    22b0:	ldr	r0, [r4, #0]
    22b2:	bl	2284 <TwoWire::write(int)>
        wire->write(val >> 8);
    22b6:	lsrs	r1, r6, #8
    22b8:	ldr	r0, [r4, #0]
    22ba:	bl	2284 <TwoWire::write(int)>
        wire->write(val);
    22be:	mov	r1, r6
    22c0:	ldr	r0, [r4, #0]
    22c2:	bl	2284 <TwoWire::write(int)>
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    22c6:	mov	r1, r5
    22c8:	ldr	r0, [r4, #0]
    22ca:	bl	27ec <TwoWire::endTransmission(unsigned char)>
        return (wire->endTransmission() == 0) ;
    }
    22ce:	clz	r0, r0
    22d2:	lsrs	r0, r0, #5
    22d4:	pop	{r3, r4, r5, r6, r7, pc}

000022d6 <adc_init()>:
    22d6:	bx	lr

000022d8 <adcStatus()>:
    static uint8_t addr = SGTL5000_I2C_ADDR_CS_LOW;
    i2c_class i2c(&Wire);
    
    void adc_init(void) {  }
    void setAGain(int8_t again) {  }
    void adcStatus(void) {  }
    22d8:	bx	lr
    22da:	Address 0x000022da is out of bounds.


000022dc <adc_enable()>:

    bool adc_enable(void) 
    {   const unsigned extMCLK=0;   // slave
    22dc:	push	{r4, r5, r6, lr}
        wire->setSDA(sda);
    }

    uint8_t exist(uint8_t addr)
    {
        wire->beginTransmission(addr);
    22de:	ldr	r4, [pc, #392]	; (2468 <adc_enable()+0x18c>)
    22e0:	ldr	r0, [r4, #0]
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
		transmitting = 1;
    22e2:	movs	r1, #1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    22e4:	movs	r5, #20
    22e6:	strb.w	r5, [r0, #163]	; 0xa3
		transmitting = 1;
    22ea:	strb.w	r1, [r0, #302]	; 0x12e
		txBufferLength = 1;
    22ee:	strb.w	r1, [r0, #301]	; 0x12d
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
    22f2:	bl	27ec <TwoWire::endTransmission(unsigned char)>
        const uint32_t pllFreq=1;   // pll
        if(!i2c.exist(addr)) Serial.println("No I2C address found");
    22f6:	cbz	r0, 2306 <adc_enable()+0x2a>
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    22f8:	mov	r1, r5
    22fa:	ldr	r0, [pc, #368]	; (246c <adc_enable()+0x190>)
    22fc:	bl	90d4 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    2300:	ldr	r0, [pc, #364]	; (2470 <adc_enable()+0x194>)
    2302:	bl	a0c0 <Print::println()>
    }

    uint16_t read16(uint8_t addr, uint16_t reg) 
    { 
        unsigned int val;
        wire->beginTransmission(addr);
    2306:	ldr	r0, [r4, #0]
    2308:	ldr	r5, [pc, #348]	; (2468 <adc_enable()+0x18c>)
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    230a:	movs	r3, #20
		transmitting = 1;
    230c:	movs	r6, #1
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin);
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
    230e:	strb.w	r3, [r0, #163]	; 0xa3
        wire->write(reg >> 8);
    2312:	movs	r1, #0
		transmitting = 1;
    2314:	strb.w	r6, [r0, #302]	; 0x12e
		txBufferLength = 1;
    2318:	strb.w	r6, [r0, #301]	; 0x12d
    231c:	bl	2284 <TwoWire::write(int)>
        wire->write(reg);
    2320:	movs	r1, #6
    2322:	ldr	r0, [r4, #0]
    2324:	bl	2284 <TwoWire::write(int)>
        if (wire->endTransmission(false) != 0) return 0;
    2328:	movs	r1, #0
    232a:	ldr	r0, [r4, #0]
    232c:	bl	27ec <TwoWire::endTransmission(unsigned char)>
    2330:	cbnz	r0, 2350 <adc_enable()+0x74>
	uint8_t requestFrom(int address, int quantity, int sendStop) {
		return requestFrom((uint8_t)address, (uint8_t)quantity,
			(uint8_t)(sendStop ? 1 : 0));
	}
	uint8_t requestFrom(int address, int quantity) {
		return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)1);
    2332:	mov	r3, r6
    2334:	mov	r2, r6
    2336:	movs	r1, #10
    2338:	ldr	r0, [r5, #0]
    233a:	bl	28e4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>
        if (wire->requestFrom((int)addr, 1) < 1) return 0;
    233e:	cbz	r0, 2350 <adc_enable()+0x74>
        val = wire->read()<<8;
    2340:	ldr	r0, [r5, #0]
    2342:	ldr	r3, [r0, #0]
    2344:	ldr	r3, [r3, #20]
    2346:	blx	r3
        val |= wire->read();
    2348:	ldr	r0, [r5, #0]
    234a:	ldr	r3, [r0, #0]
    234c:	ldr	r3, [r3, #20]
    234e:	blx	r3
        if ( (extMCLK > 0) && (n == (0x0030 | (1<<7))) ) 
        {   //Yes. Do not initialize.
            return true;
        }

        int r = i2c.write16(addr,CHIP_ANA_POWER, 0x4060);  // VDDD is externally driven with 1.8V
    2350:	movw	r3, #16480	; 0x4060
    2354:	movs	r2, #48	; 0x30
    2356:	movs	r1, #10
    2358:	ldr	r0, [pc, #268]	; (2468 <adc_enable()+0x18c>)
    235a:	bl	228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        if (!r) return false;
    235e:	cbnz	r0, 2364 <adc_enable()+0x88>
    2360:	movs	r0, #0
    2362:	pop	{r4, r5, r6, pc}
        i2c.write16(addr,CHIP_LINREG_CTRL, 0x006C);  // VDDA & VDDIO both over 3.1V
    2364:	movs	r3, #108	; 0x6c
    2366:	movs	r2, #38	; 0x26
    2368:	movs	r1, #10
    236a:	ldr	r0, [pc, #252]	; (2468 <adc_enable()+0x18c>)
    236c:	bl	228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_REF_CTRL, 0x01F2); // VAG=1.575, normal ramp, +12.5% bias current
    2370:	mov.w	r3, #498	; 0x1f2
    2374:	movs	r2, #40	; 0x28
    2376:	movs	r1, #10
    2378:	ldr	r0, [pc, #236]	; (2468 <adc_enable()+0x18c>)
    237a:	bl	228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_LINE_OUT_CTRL, 0x0F22); // LO_VAGCNTRL=1.65V, OUT_CURRENT=0.54mA
    237e:	movw	r3, #3874	; 0xf22
    2382:	movs	r2, #44	; 0x2c
    2384:	movs	r1, #10
    2386:	ldr	r0, [pc, #224]	; (2468 <adc_enable()+0x18c>)
    2388:	bl	228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_SHORT_CTRL, 0x4446);  // allow up to 125mA
    238c:	movw	r3, #17478	; 0x4446
    2390:	movs	r2, #60	; 0x3c
    2392:	movs	r1, #10
    2394:	ldr	r0, [pc, #208]	; (2468 <adc_enable()+0x18c>)
    2396:	bl	228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_ANA_CTRL, 0x0137);  // enable zero cross detectors
    239a:	movw	r3, #311	; 0x137
    239e:	movs	r2, #36	; 0x24
    23a0:	movs	r1, #10
    23a2:	ldr	r0, [pc, #196]	; (2468 <adc_enable()+0x18c>)
    23a4:	bl	228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
            i2c.write16(addr,CHIP_PLL_CTRL, (int_divisor << 11) | frac_divisor);		
            i2c.write16(addr,CHIP_ANA_POWER, 0x40FF | (1<<10) | (1<<8) ); // power up: lineout, hp, adc, dac, PLL_POWERUP, VCOAMP_POWERUP
        } 
        else 
        {   //SGTL is I2S Slave
            i2c.write16(addr,CHIP_ANA_POWER, 0x40FF); // power up: lineout, hp, adc, dac
    23a8:	movw	r3, #16639	; 0x40ff
    23ac:	movs	r2, #48	; 0x30
    23ae:	movs	r1, #10
    23b0:	ldr	r0, [pc, #180]	; (2468 <adc_enable()+0x18c>)
    23b2:	bl	228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        }

        i2c.write16(addr,CHIP_DIG_POWER, 0x0073); // power up all digital stuff
    23b6:	movs	r3, #115	; 0x73
    23b8:	movs	r2, #2
    23ba:	movs	r1, #10
    23bc:	ldr	r0, [pc, #168]	; (2468 <adc_enable()+0x18c>)
    23be:	bl	228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        delay(400);
    23c2:	mov.w	r0, #400	; 0x190
    23c6:	bl	9454 <delay>
        i2c.write16(addr,CHIP_LINE_OUT_VOL, 0x1D1D); // default approx 1.3 volts peak-to-peak
    23ca:	movw	r3, #7453	; 0x1d1d
    23ce:	movs	r2, #46	; 0x2e
    23d0:	movs	r1, #10
    23d2:	ldr	r0, [pc, #148]	; (2468 <adc_enable()+0x18c>)
    23d4:	bl	228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        }
        else 
        {   //SGTL is I2S Slave
            int fs_mode=IFR;
            if(fs_mode>3) fs_mode = 3;  // 256*Fs fs_mode = 0:32 kHz; 1:44.1 kHz; 2:48 kHz; 3:96 kHz 
            i2c.write16(addr,CHIP_CLK_CTRL, fs_mode<<2); 
    23d8:	movs	r3, #12
    23da:	movs	r2, #4
    23dc:	movs	r1, #10
    23de:	ldr	r0, [pc, #136]	; (2468 <adc_enable()+0x18c>)
    23e0:	bl	228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
            i2c.write16(addr,CHIP_I2S_CTRL,0); // SCLK=64*Fs, 32bit, I2S format
    23e4:	movs	r3, #0
    23e6:	movs	r2, #6
    23e8:	movs	r1, #10
    23ea:	ldr	r0, [pc, #124]	; (2468 <adc_enable()+0x18c>)
    23ec:	bl	228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        }

        // default signal routing is ok?
        i2c.write16(addr,CHIP_SSS_CTRL, 0x0010); // ADC->I2S, I2S->DAC
    23f0:	movs	r2, #10
    23f2:	mov	r1, r2
    23f4:	movs	r3, #16
    23f6:	ldr	r0, [pc, #112]	; (2468 <adc_enable()+0x18c>)
    23f8:	bl	228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_ADCDAC_CTRL, 0x0000); // disable dac mute
    23fc:	movs	r3, #0
    23fe:	movs	r2, #14
    2400:	movs	r1, #10
    2402:	ldr	r0, [pc, #100]	; (2468 <adc_enable()+0x18c>)
    2404:	bl	228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_DAC_VOL, 0x3C3C); // digital gain, 0dB
    2408:	movw	r3, #15420	; 0x3c3c
    240c:	movs	r2, #16
    240e:	movs	r1, #10
    2410:	ldr	r0, [pc, #84]	; (2468 <adc_enable()+0x18c>)
    2412:	bl	228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_ANA_HP_CTRL, 0x7F7F); // set volume (lowest level)
    2416:	movw	r3, #32639	; 0x7f7f
    241a:	movs	r2, #34	; 0x22
    241c:	movs	r1, #10
    241e:	ldr	r0, [pc, #72]	; (2468 <adc_enable()+0x18c>)
    2420:	bl	228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        i2c.write16(addr,CHIP_ANA_CTRL, 0x0036);  // enable zero cross detectors
    2424:	movs	r3, #54	; 0x36
    2426:	movs	r2, #36	; 0x24
    2428:	movs	r1, #10
    242a:	ldr	r0, [pc, #60]	; (2468 <adc_enable()+0x18c>)
    242c:	bl	228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
        uint16_t ana_ctrl=0x0036;

        return i2c.write16(addr,0x002A, 0x0173) // mic preamp gain = +40dB
    2430:	movw	r3, #371	; 0x173
    2434:	movs	r2, #42	; 0x2a
    2436:	movs	r1, #10
    2438:	ldr	r0, [pc, #44]	; (2468 <adc_enable()+0x18c>)
    243a:	bl	228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
                && i2c.write16(addr,0x0020, 0x088)     // input gain +12dB (is this enough?)
                && i2c.write16(addr,0x0024, ana_ctrl & ~(1<<2)); // enable mic
    243e:	cmp	r0, #0
    2440:	beq.n	2360 <adc_enable()+0x84>
        i2c.write16(addr,CHIP_ANA_HP_CTRL, 0x7F7F); // set volume (lowest level)
        i2c.write16(addr,CHIP_ANA_CTRL, 0x0036);  // enable zero cross detectors
        uint16_t ana_ctrl=0x0036;

        return i2c.write16(addr,0x002A, 0x0173) // mic preamp gain = +40dB
                && i2c.write16(addr,0x0020, 0x088)     // input gain +12dB (is this enough?)
    2442:	movs	r3, #136	; 0x88
    2444:	movs	r2, #32
    2446:	movs	r1, #10
    2448:	ldr	r0, [pc, #28]	; (2468 <adc_enable()+0x18c>)
    244a:	bl	228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
    244e:	cmp	r0, #0
    2450:	beq.n	2360 <adc_enable()+0x84>
                && i2c.write16(addr,0x0024, ana_ctrl & ~(1<<2)); // enable mic
    2452:	movs	r3, #50	; 0x32
    2454:	movs	r2, #36	; 0x24
    2456:	movs	r1, #10
    2458:	ldr	r0, [pc, #12]	; (2468 <adc_enable()+0x18c>)
    245a:	bl	228c <i2c_class::write16(unsigned char, unsigned short, unsigned short)>
    245e:	adds	r0, #0
    2460:	it	ne
    2462:	movne	r0, #1
    }
    2464:	pop	{r4, r5, r6, pc}
    2466:	nop
    2468:	.word	0x2001c9e4
    246c:	.word	0x00012805
    2470:	.word	0x1fff136c

00002474 <_GLOBAL__sub_I_gain>:
#include "config.h"
#include "adc.h"

int gain=0;
uint32_t fsamps[] = FREQS;
uint32_t fsamp = fsamps[IFR];
    2474:	ldr	r3, [pc, #16]	; (2488 <_GLOBAL__sub_I_gain+0x14>)
class i2c_class
{ TwoWire *wire;
    public:

    i2c_class(TwoWire *wire) 
    {   this->wire = wire;
    2476:	ldr	r0, [pc, #20]	; (248c <_GLOBAL__sub_I_gain+0x18>)
    2478:	ldr	r2, [r3, #12]
    247a:	ldr	r3, [pc, #20]	; (2490 <_GLOBAL__sub_I_gain+0x1c>)
    247c:	str	r2, [r3, #0]
    247e:	ldr	r3, [pc, #20]	; (2494 <_GLOBAL__sub_I_gain+0x20>)
    2480:	str	r0, [r3, #0]
        wire->begin();
    2482:	b.w	256c <TwoWire::begin()>
    2486:	nop
    2488:	.word	0x1fff0f48
    248c:	.word	0x1fff10a4
    2490:	.word	0x2001c9e0
    2494:	.word	0x2001c9e4

00002498 <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    2498:	ldrb.w	r2, [r0, #161]	; 0xa1
    249c:	ldrb.w	r0, [r0, #160]	; 0xa0
	}
    24a0:	subs	r0, r2, r0
    24a2:	bx	lr

000024a4 <TwoWire::read()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    24a4:	ldrb.w	r3, [r0, #160]	; 0xa0
    24a8:	ldrb.w	r2, [r0, #161]	; 0xa1
    24ac:	cmp	r2, r3
		return rxBuffer[rxBufferIndex++];
    24ae:	itttt	hi
    24b0:	addhi	r2, r3, #1
    24b2:	addhi	r3, r3, r0
    24b4:	strbhi.w	r2, [r0, #160]	; 0xa0
    24b8:	ldrbhi	r0, [r3, #24]
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    24ba:	it	ls
    24bc:	movls.w	r0, #4294967295
		return rxBuffer[rxBufferIndex++];
	}
    24c0:	bx	lr

000024c2 <TwoWire::peek()>:
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    24c2:	ldrb.w	r3, [r0, #160]	; 0xa0
    24c6:	ldrb.w	r2, [r0, #161]	; 0xa1
    24ca:	cmp	r2, r3
		return rxBuffer[rxBufferIndex];
    24cc:	itte	hi
    24ce:	addhi	r3, r3, r0
    24d0:	ldrbhi	r0, [r3, #24]
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    24d2:	movls.w	r0, #4294967295
		return rxBuffer[rxBufferIndex];
	}
    24d6:	bx	lr

000024d8 <TwoWire::flush()>:
	virtual void flush(void) {
    24d8:	bx	lr

000024da <TwoWire::write(unsigned char)>:
//  I2C0_C2      // I2C Control Register 2
//  I2C0_FLT     // I2C Programmable Input Glitch Filter register

size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
    24da:	ldrh.w	r3, [r0, #302]	; 0x12e
    24de:	cbz	r3, 24ec <TwoWire::write(unsigned char)+0x12>
		if (txBufferLength >= BUFFER_LENGTH+1) {
    24e0:	ldrb.w	r3, [r0, #301]	; 0x12d
    24e4:	cmp	r3, #136	; 0x88
    24e6:	bls.n	24f0 <TwoWire::write(unsigned char)+0x16>
	// format warnings are too pedantic - disable until newer toolchain offers better...
	// https://forum.pjrc.com/threads/62473?p=256873&viewfull=1#post256873
	int printf(const char *format, ...) /*__attribute__ ((format (printf, 2, 3)))*/;
	int printf(const __FlashStringHelper *format, ...);
  protected:
	void setWriteError(int err = 1) { write_error = err; }
    24e8:	movs	r3, #1
    24ea:	strb	r3, [r0, #4]
			setWriteError();
			return 0;
    24ec:	movs	r0, #0
    24ee:	bx	lr
		}
		txBuffer[txBufferLength++] = data;
    24f0:	adds	r2, r3, #1
    24f2:	add	r3, r0
    24f4:	strb.w	r2, [r0, #301]	; 0x12d
    24f8:	strb.w	r1, [r3, #163]	; 0xa3
		return 1;
    24fc:	movs	r0, #1
    24fe:	bx	lr

00002500 <TwoWire::write(unsigned char const*, unsigned int)>:
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    2500:	push	{r3, r4, r5, lr}
    2502:	mov	r4, r0
	if (transmitting || slave_mode) {
    2504:	ldrh.w	r0, [r0, #302]	; 0x12e
	}
	return 0;
}

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    2508:	mov	r5, r2
	if (transmitting || slave_mode) {
    250a:	cbz	r0, 2536 <TwoWire::write(unsigned char const*, unsigned int)+0x36>
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
    250c:	ldrb.w	r3, [r4, #301]	; 0x12d
    2510:	rsb	r2, r3, #137	; 0x89
		if (quantity > avail) {
    2514:	cmp	r5, r2
    2516:	ittt	hi
    2518:	movhi	r0, #1
    251a:	movhi	r5, r2
    251c:	strbhi	r0, [r4, #4]
			quantity = avail;
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
    251e:	add.w	r0, r4, #163	; 0xa3
    2522:	add	r0, r3
    2524:	mov	r2, r5
    2526:	bl	8e18 <memcpy>
		txBufferLength += quantity;
    252a:	ldrb.w	r3, [r4, #301]	; 0x12d
    252e:	add	r3, r5
    2530:	strb.w	r3, [r4, #301]	; 0x12d
    2534:	mov	r0, r5
		return quantity;
	}
	return 0;
}
    2536:	pop	{r3, r4, r5, pc}

00002538 <TwoWire::setClock(unsigned long)>:
	//pinMode(4, OUTPUT);
}

void TwoWire::setClock(uint32_t frequency)
{
	if (!(hardware.clock_gate_register & hardware.clock_gate_mask)) return;
    2538:	ldr	r3, [r0, #20]
    253a:	ldr	r2, [r3, #0]
    253c:	ldr	r3, [r3, #4]
    253e:	ldr	r2, [r2, #0]
    2540:	tst	r2, r3
    2542:	beq.n	2562 <TwoWire::setClock(unsigned long)+0x2a>
	} else {
		port().F = I2C_F_DIV56; // 0.96 MHz
	}
	port().FLT = 4;
#elif F_BUS == 48000000
	if (frequency < 400000) {
    2544:	ldr	r3, [pc, #28]	; (2564 <TwoWire::setClock(unsigned long)+0x2c>)
    2546:	cmp	r1, r3
    2548:	ldr	r3, [r0, #16]
    254a:	bhi.n	2550 <TwoWire::setClock(unsigned long)+0x18>
		port().F = 0x27;	// 100 kHz
    254c:	movs	r2, #39	; 0x27
    254e:	b.n	255a <TwoWire::setClock(unsigned long)+0x22>
	} else if (frequency < 1000000) {
    2550:	ldr	r2, [pc, #20]	; (2568 <TwoWire::setClock(unsigned long)+0x30>)
    2552:	cmp	r1, r2
		port().F = 0x1A; // 400 kHz
    2554:	ite	ls
    2556:	movls	r2, #26
	} else {
		port().F = 0x0D; // 1 MHz
    2558:	movhi	r2, #13
    255a:	strb	r2, [r3, #1]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    255c:	ldr	r3, [r0, #16]
	}
	port().FLT = 4;
    255e:	movs	r2, #4
    2560:	strb	r2, [r3, #6]
    2562:	bx	lr
    2564:	.word	0x00061a7f
    2568:	.word	0x000f423f

0000256c <TwoWire::begin()>:

void sda_rising_isr0(void);
void sda_rising_isr1(void);

void TwoWire::begin(void)
{
    256c:	push	{r4, r5, r6, lr}
	//serial_begin(BAUD2DIV(115200));
	//serial_print("\nWire Begin\n");

	rxBufferIndex = 0;
    256e:	movs	r3, #0
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    2570:	ldr	r5, [r0, #20]
void TwoWire::begin(void)
{
	//serial_begin(BAUD2DIV(115200));
	//serial_print("\nWire Begin\n");

	rxBufferIndex = 0;
    2572:	strb.w	r3, [r0, #160]	; 0xa0
	rxBufferLength = 0;
    2576:	strb.w	r3, [r0, #161]	; 0xa1
	txBufferIndex = 0;
    257a:	strb.w	r3, [r0, #300]	; 0x12c
	txBufferLength = 0;
    257e:	strb.w	r3, [r0, #301]	; 0x12d
	transmitting = 0;
    2582:	strb.w	r3, [r0, #302]	; 0x12e
	user_onRequest = NULL;
	user_onReceive = NULL;
	slave_mode = 0;
    2586:	strb.w	r3, [r0, #303]	; 0x12f
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    258a:	ldr	r1, [r5, #0]
    258c:	ldr	r2, [r5, #4]
    258e:	ldr	r6, [r1, #0]
	rxBufferIndex = 0;
	rxBufferLength = 0;
	txBufferIndex = 0;
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
    2590:	str.w	r3, [r0, #308]	; 0x134
	user_onReceive = NULL;
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    2594:	orrs	r2, r6
	rxBufferLength = 0;
	txBufferIndex = 0;
	txBufferLength = 0;
	transmitting = 0;
	user_onRequest = NULL;
	user_onReceive = NULL;
    2596:	str.w	r3, [r0, #312]	; 0x138
	slave_mode = 0;
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    259a:	str	r2, [r1, #0]
    259c:	ldr	r2, [r0, #16]
	port().C1 = 0;
    259e:	strb	r3, [r2, #2]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    25a0:	ldr	r6, [r0, #20]
    25a2:	ldrb.w	r1, [r0, #305]	; 0x131
    25a6:	ldr	r2, [pc, #72]	; (25f0 <TwoWire::begin()+0x84>)
    25a8:	add	r1, r6
    25aa:	ldrb	r5, [r1, #8]
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    25ac:	ldrb	r3, [r1, #13]
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    25ae:	add.w	r5, r2, r5, lsl #3
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    25b2:	lsls	r3, r3, #8
	// would enable pullup resistors.  However, there seems
	// to be a bug in chip while I2C is enabled, where setting
	// those causes the port to be driven strongly high.
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    25b4:	ldr	r5, [r5, #4]
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    25b6:	and.w	r3, r3, #1792	; 0x700
    25ba:	orr.w	r3, r3, #100	; 0x64
    25be:	str	r3, [r5, #0]
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    25c0:	ldrb.w	r3, [r0, #306]	; 0x132
    25c4:	add	r3, r6
    25c6:	ldrb	r1, [r3, #18]
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    25c8:	ldrb	r3, [r3, #23]
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    25ca:	add.w	r2, r2, r1, lsl #3
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    25ce:	lsls	r3, r3, #8
	uint32_t mux;
	volatile uint32_t *reg;
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    25d0:	ldr	r2, [r2, #4]
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	setClock(100000);
    25d2:	ldr	r1, [pc, #32]	; (25f4 <TwoWire::begin()+0x88>)
	reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
	mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
	reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
	mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
	*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    25d4:	and.w	r3, r3, #1792	; 0x700
    25d8:	orr.w	r3, r3, #100	; 0x64
    25dc:	str	r3, [r2, #0]
	setClock(100000);
    25de:	bl	2538 <TwoWire::setClock(unsigned long)>
    25e2:	ldr	r3, [r0, #16]
	port().C2 = I2C_C2_HDRS;
    25e4:	movs	r2, #32
    25e6:	strb	r2, [r3, #5]
    25e8:	ldr	r3, [r0, #16]
	port().C1 = I2C_C1_IICEN;
    25ea:	movs	r2, #128	; 0x80
    25ec:	strb	r2, [r3, #2]
    25ee:	pop	{r4, r5, r6, pc}
    25f0:	.word	0x00012d80
    25f4:	.word	0x000186a0

000025f8 <TwoWire::isr()>:
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    25f8:	push	{r3, r4, r5, lr}
    25fa:	ldr	r2, [r0, #16]
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
    25fc:	ldrb	r5, [r2, #3]
    25fe:	uxtb	r5, r5
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    2600:	tst.w	r5, #16
	hardware.clock_gate_register &= ~hardware.clock_gate_mask;
}


void TwoWire::isr(void)
{
    2604:	mov	r4, r0
    2606:	and.w	r3, r5, #64	; 0x40
	uint8_t status, c1, data;
	static uint8_t receiving=0;

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
    260a:	bne.n	2614 <TwoWire::isr()+0x1c>


		}
		if (!(status & I2C_S_IAAS)) return;
	}
	if (status & I2C_S_IAAS) {
    260c:	and.w	r1, r3, #255	; 0xff
    2610:	cbnz	r3, 261e <TwoWire::isr()+0x26>
    2612:	b.n	266c <TwoWire::isr()+0x74>

	status = port().S;
	//serial_print(".");
	if (status & I2C_S_ARBL) {
		// Arbitration Lost
		port().S = I2C_S_ARBL;
    2614:	movs	r1, #16
    2616:	strb	r1, [r2, #3]
		if (receiving && rxBufferLength > 0) {
			// TODO: does this detect the STOP condition in slave receive mode?


		}
		if (!(status & I2C_S_IAAS)) return;
    2618:	cmp	r3, #0
    261a:	bne.n	260c <TwoWire::isr()+0x14>
    261c:	pop	{r3, r4, r5, pc}
	}
	if (status & I2C_S_IAAS) {
		//serial_print("\n");
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
    261e:	and.w	r5, r5, #4
    2622:	and.w	r2, r5, #255	; 0xff
    2626:	ldr	r3, [pc, #224]	; (2708 <TwoWire::isr()+0x110>)
    2628:	cbz	r5, 2660 <TwoWire::isr()+0x68>
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
    262a:	movs	r2, #0
    262c:	strb	r2, [r3, #0]
			txBufferLength = 0;
			if (user_onRequest != NULL) {
    262e:	ldr.w	r3, [r4, #308]	; 0x134
		// Addressed As A Slave
		if (status & I2C_S_SRW) {
			//serial_print("T");
			// Begin Slave Transmit
			receiving = 0;
			txBufferLength = 0;
    2632:	strb.w	r2, [r4, #301]	; 0x12d
			if (user_onRequest != NULL) {
    2636:	cbz	r3, 263a <TwoWire::isr()+0x42>
				user_onRequest();
    2638:	blx	r3
			}
			if (txBufferLength == 0) {
    263a:	ldrb.w	r3, [r4, #301]	; 0x12d
    263e:	cbnz	r3, 264a <TwoWire::isr()+0x52>
				// is this correct, transmitting a single zero
				// when we should send nothing?  Arduino's AVR
				// implementation does this, but is it ok?
				txBufferLength = 1;
    2640:	movs	r2, #1
    2642:	strb.w	r2, [r4, #301]	; 0x12d
				txBuffer[0] = 0;
    2646:	strb.w	r3, [r4, #163]	; 0xa3
    264a:	ldr	r3, [r4, #16]
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    264c:	movs	r2, #208	; 0xd0
    264e:	strb	r2, [r3, #2]
    2650:	ldr	r3, [r4, #16]
			port().D = txBuffer[0];
    2652:	ldrb.w	r2, [r4, #163]	; 0xa3
    2656:	strb	r2, [r3, #4]
			txBufferIndex = 1;
    2658:	movs	r3, #1
    265a:	strb.w	r3, [r4, #300]	; 0x12c
    265e:	b.n	26fe <TwoWire::isr()+0x106>
		} else {
			// Begin Slave Receive
			//serial_print("R");
			receiving = 1;
    2660:	movs	r1, #1
    2662:	strb	r1, [r3, #0]
			rxBufferLength = 0;
    2664:	strb.w	r2, [r4, #161]	; 0xa1
    2668:	ldr	r3, [r4, #16]
    266a:	b.n	26ca <TwoWire::isr()+0xd2>
    266c:	ldr	r2, [r4, #16]
		}
		port().S = I2C_S_IICIF;
		return;
	}
	#if defined(WIRE_HAS_STOP_INTERRUPT)
	c1 = port().FLT;
    266e:	ldrb	r3, [r2, #6]
    2670:	uxtb	r3, r3
	if ((c1 & I2C_FLT_STOPF) && (c1 & I2C_FLT_STOPIE)) {
    2672:	and.w	r0, r3, #96	; 0x60
    2676:	cmp	r0, #96	; 0x60
    2678:	bne.n	2690 <TwoWire::isr()+0x98>
		port().FLT = c1 & ~I2C_FLT_STOPIE;
    267a:	and.w	r3, r3, #223	; 0xdf
    267e:	strb	r3, [r2, #6]
		if (user_onReceive != NULL) {
    2680:	ldr.w	r3, [r4, #312]	; 0x138
    2684:	cbz	r3, 2690 <TwoWire::isr()+0x98>
			rxBufferIndex = 0;
    2686:	strb.w	r1, [r4, #160]	; 0xa0
			user_onReceive(rxBufferLength);
    268a:	ldrb.w	r0, [r4, #161]	; 0xa1
    268e:	blx	r3
    2690:	ldr	r3, [r4, #16]
		}
	}
	#endif
	c1 = port().C1;
    2692:	ldrb	r2, [r3, #2]
	if (c1 & I2C_C1_TX) {
    2694:	and.w	r2, r2, #16
    2698:	and.w	r1, r2, #255	; 0xff
    269c:	cbz	r2, 26d4 <TwoWire::isr()+0xdc>
		// Continue Slave Transmit
		//serial_print("t");
		if ((status & I2C_S_RXAK) == 0) {
    269e:	ands.w	r5, r5, #1
    26a2:	bne.n	26ca <TwoWire::isr()+0xd2>
			//serial_print(".");
			// Master ACK'd previous byte
			if (txBufferIndex < txBufferLength) {
    26a4:	ldrb.w	r2, [r4, #300]	; 0x12c
    26a8:	ldrb.w	r1, [r4, #301]	; 0x12d
    26ac:	cmp	r1, r2
				port().D = txBuffer[txBufferIndex++];
    26ae:	itttt	hi
    26b0:	addhi	r1, r2, #1
    26b2:	addhi	r2, r2, r4
    26b4:	strbhi.w	r1, [r4, #300]	; 0x12c
    26b8:	ldrbhi.w	r2, [r2, #163]	; 0xa3
    26bc:	ite	hi
    26be:	strbhi	r2, [r3, #4]
			} else {
				port().D = 0;
    26c0:	strbls	r5, [r3, #4]
    26c2:	ldr	r3, [r4, #16]
			}
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE | I2C_C1_TX;
    26c4:	movs	r2, #208	; 0xd0
    26c6:	strb	r2, [r3, #2]
    26c8:	b.n	26fe <TwoWire::isr()+0x106>
		} else {
			//serial_print("*");
			// Master did not ACK previous byte
			port().C1 = I2C_C1_IICEN | I2C_C1_IICIE;
    26ca:	movs	r2, #192	; 0xc0
    26cc:	strb	r2, [r3, #2]
    26ce:	ldr	r3, [r4, #16]
			data = port().D;
    26d0:	ldrb	r3, [r3, #4]
    26d2:	b.n	26fe <TwoWire::isr()+0x106>
		}
	} else {
		// Continue Slave Receive
		irqcount = 0;
    26d4:	strb.w	r1, [r4, #304]	; 0x130
		#ifdef WIRE_HAS_STOP_INTERRUPT
		port().FLT |= I2C_FLT_STOPIE;
    26d8:	ldrb	r2, [r3, #6]
    26da:	orr.w	r2, r2, #32
    26de:	strb	r2, [r3, #6]
    26e0:	ldr	r3, [r4, #16]
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    26e2:	ldrb	r2, [r3, #4]
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    26e4:	ldrb.w	r3, [r4, #161]	; 0xa1
    26e8:	cmp	r3, #135	; 0x87
			attachInterrupt(hardware.sda_pin[sda_pin_index], sda_rising_isr1, RISING);
		}
		#endif
		#endif // WIRE_HAS_STOP_INTERRUPT
		//digitalWriteFast(4, HIGH);
		data = port().D;
    26ea:	uxtb	r2, r2
		//serial_phex(data);
		if (rxBufferLength < BUFFER_LENGTH && receiving) {
    26ec:	bhi.n	26fe <TwoWire::isr()+0x106>
    26ee:	ldr	r1, [pc, #24]	; (2708 <TwoWire::isr()+0x110>)
    26f0:	ldrb	r1, [r1, #0]
    26f2:	cbz	r1, 26fe <TwoWire::isr()+0x106>
			rxBuffer[rxBufferLength++] = data;
    26f4:	adds	r1, r3, #1
    26f6:	add	r3, r4
    26f8:	strb.w	r1, [r4, #161]	; 0xa1
    26fc:	strb	r2, [r3, #24]
    26fe:	ldr	r3, [r4, #16]
		}
		//digitalWriteFast(4, LOW);
	}
	port().S = I2C_S_IICIF;
    2700:	movs	r2, #2
    2702:	strb	r2, [r3, #3]
    2704:	pop	{r3, r4, r5, pc}
    2706:	nop
    2708:	.word	0x2001c9e8

0000270c <TwoWire::wait_idle()>:
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    270c:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2710:	ldr	r5, [pc, #208]	; (27e4 <L_1220_delayMicroseconds+0x20>)
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    2712:	ldr	r7, [pc, #212]	; (27e8 <L_1220_delayMicroseconds+0x24>)
    2714:	ldr	r3, [r5, #0]
    2716:	str	r3, [sp, #0]
	return ret;
    2718:	ldr.w	r8, [sp]
	}
	return 0;
}

bool TwoWire::wait_idle(void)
{
    271c:	mov	r4, r0
	bool reset=false;
    271e:	movs	r1, #0
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    2720:	movs	r6, #160	; 0xa0
    2722:	ldr	r2, [r4, #16]
	uint8_t i2c_status(void) {
		return port().S;
    2724:	ldrb	r3, [r2, #3]
	uint32_t wait_begin = millis();

	//Serial.print("busy:");
	while (i2c_status() & I2C_S_BUSY) {
    2726:	lsls	r3, r3, #26
    2728:	bpl.n	27dc <L_1220_delayMicroseconds+0x18>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    272a:	ldr	r3, [r5, #0]
    272c:	str	r3, [sp, #4]
	return ret;
    272e:	ldr	r3, [sp, #4]
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
    2730:	rsb	r3, r8, r3
#if 1
		if (waited > 15 && !reset) {
    2734:	cmp	r3, #15
    2736:	bls.n	2722 <TwoWire::wait_idle()+0x16>
    2738:	cmp	r1, #0
    273a:	bne.n	27cc <L_1220_delayMicroseconds+0x8>
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
    273c:	ldr	r2, [r4, #20]
    273e:	ldrb.w	r3, [r4, #305]	; 0x131
    2742:	add	r3, r2
			pinMode(sda_pin, INPUT_DISABLE);
    2744:	movs	r1, #5
    2746:	ldrb	r0, [r3, #8]
    2748:	bl	93b4 <pinMode>
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    274c:	ldr	r2, [r4, #20]
    274e:	ldrb.w	r3, [r4, #305]	; 0x131
    2752:	add	r3, r2
			pinMode(scl_pin, OUTPUT);
    2754:	movs	r1, #1
		if (waited > 15 && !reset) {
			reset = true;
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
    2756:	ldrb.w	sl, [r3, #18]
			pinMode(scl_pin, OUTPUT);
    275a:	mov	r0, sl
    275c:	bl	93b4 <pinMode>
    2760:	mov.w	r9, #9
			for (int i=0; i < 9; i++) {
				digitalWrite(scl_pin, LOW);
    2764:	movs	r1, #0
    2766:	mov	r0, sl
    2768:	bl	9374 <digitalWrite>
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    276c:	mov	r3, r6

0000276e <L_1161_delayMicroseconds>:
    276e:	subs	r3, #1
    2770:	bne.n	276e <L_1161_delayMicroseconds>
				delayMicroseconds(5);
				digitalWrite(scl_pin, HIGH);
    2772:	movs	r1, #1
    2774:	mov	r0, sl
    2776:	bl	9374 <digitalWrite>
    277a:	mov	r3, r6

0000277c <L_1175_delayMicroseconds>:
    277c:	subs	r3, #1
    277e:	bne.n	277c <L_1175_delayMicroseconds>
			//Serial.println("attempt forced reset");
			uint8_t sda_pin = hardware.sda_pin[sda_pin_index];
			pinMode(sda_pin, INPUT_DISABLE);
			uint8_t scl_pin = hardware.scl_pin[sda_pin_index];
			pinMode(scl_pin, OUTPUT);
			for (int i=0; i < 9; i++) {
    2780:	subs.w	r9, r9, #1
    2784:	bne.n	2764 <TwoWire::wait_idle()+0x58>
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    2786:	ldr	r0, [r4, #20]
    2788:	ldrb.w	r2, [r4, #305]	; 0x131
    278c:	add	r2, r0
    278e:	ldrb	r1, [r2, #8]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    2790:	ldrb	r3, [r2, #13]
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    2792:	add.w	r1, r7, r1, lsl #3
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    2796:	lsls	r3, r3, #8
				digitalWrite(scl_pin, HIGH);
				delayMicroseconds(5);
			}
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
    2798:	ldr	r1, [r1, #4]
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    279a:	and.w	r3, r3, #1792	; 0x700
    279e:	orr.w	r3, r3, #100	; 0x64
    27a2:	str	r3, [r1, #0]
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    27a4:	ldrb.w	r3, [r4, #306]	; 0x132
    27a8:	add	r3, r0
    27aa:	ldrb	r2, [r3, #18]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    27ac:	ldrb	r3, [r3, #23]
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    27ae:	add.w	r2, r7, r2, lsl #3
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    27b2:	lsls	r3, r3, #8
			uint32_t mux;
			volatile uint32_t *reg;
			reg = portConfigRegister(hardware.sda_pin[sda_pin_index]);
			mux = PORT_PCR_MUX(hardware.sda_mux[sda_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			reg = portConfigRegister(hardware.scl_pin[scl_pin_index]);
    27b4:	ldr	r2, [r2, #4]
			mux = PORT_PCR_MUX(hardware.scl_mux[scl_pin_index]);
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
    27b6:	and.w	r3, r3, #1792	; 0x700
    27ba:	orr.w	r3, r3, #100	; 0x64
    27be:	str	r3, [r2, #0]
    27c0:	mov.w	r3, #320	; 0x140

000027c4 <L_1220_delayMicroseconds>:
    27c4:	subs	r3, #1
    27c6:	bne.n	27c4 <L_1220_delayMicroseconds>
	while (i2c_status() & I2C_S_BUSY) {
		//Serial.write('.') ;
		uint32_t waited = millis() - wait_begin;
#if 1
		if (waited > 15 && !reset) {
			reset = true;
    27c8:	movs	r1, #1
    27ca:	b.n	2722 <TwoWire::wait_idle()+0x16>
			*reg = mux|PORT_PCR_ODE|PORT_PCR_SRE|PORT_PCR_DSE;
			delayMicroseconds(10);
			continue;
		}
#endif
		if (waited > 16) {
    27cc:	cmp	r3, #16
    27ce:	beq.n	2722 <TwoWire::wait_idle()+0x16>
			// bus stuck busy too long
			port().C1 = 0;
    27d0:	movs	r0, #0
    27d2:	strb	r0, [r2, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    27d4:	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    27d6:	movs	r2, #128	; 0x80
    27d8:	strb	r2, [r3, #2]
			//Serial.println("abort");
			//return 4; // timeout waiting for bus
			return false;
    27da:	b.n	27de <L_1220_delayMicroseconds+0x1a>
		}
	}
	return true;
    27dc:	movs	r0, #1
}
    27de:	add	sp, #8
    27e0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    27e4:	.word	0x2001cf20
    27e8:	.word	0x00012d80

000027ec <TwoWire::endTransmission(unsigned char)>:

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    27ec:	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    27f0:	ldr	r3, [r0, #16]
	uint8_t i, status, ret=0;
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    27f2:	movs	r2, #18
    27f4:	strb	r2, [r3, #3]
    27f6:	ldr	r2, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    27f8:	ldrb	r3, [r2, #2]
    27fa:	and.w	r3, r3, #32
	}
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    27fe:	mov	r4, r0
    2800:	mov	r5, r1
	uint32_t wait_begin;

	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    2802:	and.w	r6, r3, #255	; 0xff
    2806:	cbz	r3, 280e <TwoWire::endTransmission(unsigned char)+0x22>
		// we are already the bus master, so send a repeated start
		//Serial.print("rstart:");
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    2808:	movs	r3, #180	; 0xb4
    280a:	strb	r3, [r2, #2]
    280c:	b.n	2820 <TwoWire::endTransmission(unsigned char)+0x34>
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    280e:	bl	270c <TwoWire::wait_idle()>
    2812:	cmp	r0, #0
    2814:	beq.n	28d8 <TwoWire::endTransmission(unsigned char)+0xec>
    2816:	ldr	r3, [r4, #16]
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    2818:	strb.w	r6, [r4, #303]	; 0x12f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    281c:	movs	r2, #176	; 0xb0
    281e:	strb	r2, [r3, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2820:	ldr	r3, [pc, #188]	; (28e0 <TwoWire::endTransmission(unsigned char)+0xf4>)
    2822:	ldr	r1, [r4, #16]
    2824:	ldr	r2, [r3, #0]
    2826:	str	r2, [sp, #0]
	return ret;
    2828:	ldr	r6, [sp, #0]
	uint8_t i2c_status(void) {
		return port().S;
    282a:	ldrb	r2, [r1, #3]
	}
	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    282c:	and.w	r2, r2, #32
    2830:	and.w	r0, r2, #255	; 0xff
    2834:	cmp	r2, #0
    2836:	beq.n	28c4 <TwoWire::endTransmission(unsigned char)+0xd8>
    2838:	movs	r0, #0
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    283a:	movs	r7, #2
			//Serial.printf("endTransmission err2\n");
			return 4; // error generating start condition
		}
	}
	// transmit the address and data
	for (i=0; i < txBufferLength; i++) {
    283c:	ldrb.w	r2, [r4, #301]	; 0x12d
    2840:	uxtb	r1, r0
    2842:	cmp	r2, r1
    2844:	bls.n	28b2 <TwoWire::endTransmission(unsigned char)+0xc6>
		port().D = txBuffer[i];
    2846:	adds	r6, r4, r1
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    2848:	ldr	r2, [r4, #16]
    284a:	ldrb.w	r6, [r6, #163]	; 0xa3
    284e:	strb	r6, [r2, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2850:	ldr	r2, [r3, #0]
    2852:	str	r2, [sp, #12]
	return ret;
    2854:	ldr.w	r8, [sp, #12]
    2858:	ldr	r6, [r4, #16]
	uint8_t i2c_status(void) {
		return port().S;
    285a:	ldrb	r2, [r6, #3]
    285c:	uxtb	r2, r2
		//Serial.write('^');
		wait_begin = millis();
		while (1) {
			status = i2c_status();
			if ((status & I2C_S_IICIF)) break;
    285e:	and.w	lr, r2, #2
    2862:	and.w	ip, lr, #255	; 0xff
    2866:	cmp.w	lr, #0
    286a:	bne.n	2884 <TwoWire::endTransmission(unsigned char)+0x98>
			if (!(status & I2C_S_BUSY)) break;
    286c:	lsls	r2, r2, #26
    286e:	bpl.n	2884 <TwoWire::endTransmission(unsigned char)+0x98>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2870:	ldr	r2, [r3, #0]
    2872:	str	r2, [sp, #8]
	return ret;
    2874:	ldr	r2, [sp, #8]
			if (millis() - wait_begin > 5) {
    2876:	rsb	r2, r8, r2
    287a:	cmp	r2, #5
    287c:	bls.n	285a <TwoWire::endTransmission(unsigned char)+0x6e>
				port().C1 = 0;
    287e:	strb.w	ip, [r6, #2]
    2882:	b.n	28d2 <TwoWire::endTransmission(unsigned char)+0xe6>
				//Serial.println("abort3");
				//Serial.printf("endTransmission err3\n");
				return 4; // clock stretch too long
			}
		}
		port().S = I2C_S_IICIF;
    2884:	strb	r7, [r6, #3]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    2886:	ldr	r6, [r4, #16]
	uint8_t i2c_status(void) {
		return port().S;
    2888:	ldrb	r2, [r6, #3]
    288a:	uxtb	r2, r2
		//Serial.write('$');
		status = i2c_status();
		if ((status & I2C_S_ARBL)) {
    288c:	tst.w	r2, #16
    2890:	bne.n	2898 <TwoWire::endTransmission(unsigned char)+0xac>
			port().C1 = I2C_C1_IICEN;
			//Serial.printf("endTransmission err4\n");
			ret = 4; // 4:other error
			break;
		}
		if (!(status & I2C_S_BUSY)) {
    2892:	tst.w	r2, #32
    2896:	bne.n	28a0 <TwoWire::endTransmission(unsigned char)+0xb4>
			// suddenly lost control of the bus!
			port().C1 = I2C_C1_IICEN;
    2898:	movs	r3, #128	; 0x80
    289a:	strb	r3, [r6, #2]
			//Serial.printf("endTransmission err5\n");
			ret = 4; // 4:other error
    289c:	movs	r0, #4
    289e:	b.n	28b4 <TwoWire::endTransmission(unsigned char)+0xc8>
			break;
		}
		if (status & I2C_S_RXAK) {
    28a0:	lsls	r2, r2, #31
    28a2:	add.w	r0, r0, #1
    28a6:	bpl.n	283c <TwoWire::endTransmission(unsigned char)+0x50>
			if (i == 0) {
				//Serial.printf("endTransmission err6\n");
				ret = 2; // 2:received NACK on transmit of address
			} else {
				//Serial.printf("endTransmission err7\n");
				ret = 3; // 3:received NACK on transmit of data 
    28a8:	cmp	r1, #0
    28aa:	ite	eq
    28ac:	moveq	r0, #2
    28ae:	movne	r0, #3
    28b0:	b.n	28b6 <TwoWire::endTransmission(unsigned char)+0xca>
	return true;
}

uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
	uint8_t i, status, ret=0;
    28b2:	movs	r0, #0
			}
			sendStop = 1;
			break;
		}
	}
	if (sendStop) {
    28b4:	cbz	r5, 28bc <TwoWire::endTransmission(unsigned char)+0xd0>
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    28b6:	ldr	r3, [r4, #16]
		// send the stop condition
		port().C1 = I2C_C1_IICEN;
    28b8:	movs	r2, #128	; 0x80
    28ba:	strb	r2, [r3, #2]
		// TODO: do we wait for this somehow?
	}
	transmitting = 0;
    28bc:	movs	r3, #0
    28be:	strb.w	r3, [r4, #302]	; 0x12e
    28c2:	b.n	28da <TwoWire::endTransmission(unsigned char)+0xee>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    28c4:	ldr	r2, [r3, #0]
    28c6:	str	r2, [sp, #4]
	return ret;
    28c8:	ldr	r2, [sp, #4]
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
		//Serial.write('*') ;
		if (millis() - wait_begin > 4) {
    28ca:	subs	r2, r2, r6
    28cc:	cmp	r2, #4
    28ce:	bls.n	282a <TwoWire::endTransmission(unsigned char)+0x3e>
			port().C1 = 0;
    28d0:	strb	r0, [r1, #2]
    28d2:	ldr	r3, [r4, #16]
			port().C1 = I2C_C1_IICEN;
    28d4:	movs	r2, #128	; 0x80
    28d6:	strb	r2, [r3, #2]
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
			//Serial.printf("endTransmission err1\n");
			return 4; // timeout waiting for bus
    28d8:	movs	r0, #4
	}
	transmitting = 0;
	//Serial.print(" ret=");
	//Serial.println(ret);
	return ret;
}
    28da:	add	sp, #16
    28dc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    28e0:	.word	0x2001cf20

000028e4 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)>:


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    28e4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    28e8:	mov	r9, r3
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
	uint32_t wait_begin;

	rxBufferIndex = 0;
    28ea:	movs	r3, #0
    28ec:	strb.w	r3, [r0, #160]	; 0xa0
	rxBufferLength = 0;
    28f0:	strb.w	r3, [r0, #161]	; 0xa1
    28f4:	ldr	r3, [r0, #16]
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    28f6:	mov	r7, r2

	rxBufferIndex = 0;
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
    28f8:	movs	r2, #18
    28fa:	strb	r2, [r3, #3]
    28fc:	ldr	r2, [r0, #16]
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    28fe:	ldrb	r3, [r2, #2]
    2900:	and.w	r3, r3, #32
	return ret;
}


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
    2904:	sub	sp, #36	; 0x24
    2906:	mov	r5, r0
    2908:	mov	r8, r1
	rxBufferLength = 0;
	//serial_print("requestFrom\n");
	// clear the status flags
	port().S = I2C_S_IICIF | I2C_S_ARBL;
	// now take control of the bus...
	if (port().C1 & I2C_C1_MST) {
    290a:	and.w	r4, r3, #255	; 0xff
    290e:	cbz	r3, 2916 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x32>
		// we are already the bus master, so send a repeated start
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_RSTA | I2C_C1_TX;
    2910:	movs	r3, #180	; 0xb4
    2912:	strb	r3, [r2, #2]
    2914:	b.n	292a <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x46>
	} else {
		// we are not currently the bus master, so wait for bus ready
		if (!wait_idle()) {
    2916:	bl	270c <TwoWire::wait_idle()>
    291a:	cmp	r0, #0
    291c:	beq.w	2a92 <L_2399_delayMicroseconds+0x3e>
    2920:	ldr	r3, [r5, #16]
			//Serial.printf("requestFrom err1\n");
			return 0; // timeout waiting for bus
		}
		// become the bus master in transmit mode (send start)
		slave_mode = 0;
    2922:	strb.w	r4, [r5, #303]	; 0x12f
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    2926:	movs	r2, #176	; 0xb0
    2928:	strb	r2, [r3, #2]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    292a:	ldr	r6, [pc, #368]	; (2a9c <L_2399_delayMicroseconds+0x48>)
    292c:	ldr	r2, [r5, #16]
    292e:	ldr	r3, [r6, #0]
    2930:	str	r3, [sp, #0]
	return ret;
    2932:	ldr	r1, [sp, #0]
	uint8_t i2c_status(void) {
		return port().S;
    2934:	ldrb	r3, [r2, #3]
    2936:	and.w	r3, r3, #32

	// wait until start condition establishes control of the bus
	wait_begin = millis();
	while (1) {
		status = i2c_status();
		if ((status & I2C_S_BUSY)) break;
    293a:	and.w	r4, r3, #255	; 0xff
    293e:	cbnz	r3, 294e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x6a>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2940:	ldr	r3, [r6, #0]
    2942:	str	r3, [sp, #4]
	return ret;
    2944:	ldr	r3, [sp, #4]
		if (millis() - wait_begin > 4) {
    2946:	subs	r3, r3, r1
    2948:	cmp	r3, #4
    294a:	bls.n	2934 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x50>
    294c:	b.n	297e <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x9a>
			//Serial.printf("requestFrom err2\n");
			return 0; // error generating start condition
		}
	}
	// send the address
	port().D = (address << 1) | 1;
    294e:	mov.w	r8, r8, lsl #1
    2952:	orr.w	r8, r8, #1
    2956:	uxtb.w	r8, r8
    295a:	strb.w	r8, [r2, #4]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    295e:	ldr	r3, [r6, #0]
    2960:	str	r3, [sp, #8]
	return ret;
    2962:	ldr	r1, [sp, #8]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    2964:	ldr	r2, [r5, #16]
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    2966:	ldrb	r3, [r2, #3]
    2968:	and.w	r3, r3, #2
    296c:	and.w	r4, r3, #255	; 0xff
    2970:	cbnz	r3, 2986 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xa2>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2972:	ldr	r3, [r6, #0]
    2974:	str	r3, [sp, #12]
	return ret;
    2976:	ldr	r3, [sp, #12]
		if (millis() - wait_begin > 5) {
    2978:	subs	r3, r3, r1
    297a:	cmp	r3, #5
    297c:	bls.n	2966 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x82>
			port().C1 = 0;
    297e:	strb	r4, [r2, #2]
    2980:	ldr	r3, [r5, #16]
			port().C1 = I2C_C1_IICEN;
    2982:	movs	r2, #128	; 0x80
    2984:	b.n	29a8 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xc4>
			//Serial.printf("requestFrom err3\n");
			return 0; // clock stretch too long (during address)
		}
	}
	port().S = I2C_S_IICIF;
    2986:	movs	r3, #2
    2988:	strb	r3, [r2, #3]
    298a:	ldr	r3, [r5, #16]
	uint8_t i2c_status(void) {
		return port().S;
    298c:	ldrb	r0, [r3, #3]
	status = i2c_status();
	if ((status & I2C_S_RXAK) || (status & I2C_S_ARBL)) {
    298e:	ands.w	r4, r0, #17
    2992:	beq.n	299c <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xb8>
		// the slave device did not acknowledge
		// or we lost bus arbitration to another master
		port().C1 = I2C_C1_IICEN;
    2994:	movs	r2, #128	; 0x80
    2996:	strb	r2, [r3, #2]
		//Serial.printf("requestFrom err4\n");
		return 0;
    2998:	movs	r4, #0
    299a:	b.n	2a92 <L_2399_delayMicroseconds+0x3e>
	}
	if (length == 0) {
    299c:	cbnz	r7, 29ac <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xc8>
		// TODO: does anybody really do zero length reads?
		// if so, does this code really work?
		port().C1 = I2C_C1_IICEN | (sendStop ? 0 : I2C_C1_MST);
    299e:	cmp.w	r9, #0
    29a2:	ite	ne
    29a4:	movne	r2, #128	; 0x80
    29a6:	moveq	r2, #160	; 0xa0
    29a8:	strb	r2, [r3, #2]
		//Serial.printf("requestFrom err5\n");
		return 0;
    29aa:	b.n	2a92 <L_2399_delayMicroseconds+0x3e>
	} else if (length == 1) {
    29ac:	cmp	r7, #1
		port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    29ae:	ite	eq
    29b0:	moveq	r2, #168	; 0xa8
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
    29b2:	movne	r2, #160	; 0xa0
    29b4:	strb	r2, [r3, #2]
	size_t write(int n) {
		return write((uint8_t)n);
	}
	using Print::write;
private:
	KINETIS_I2C_t& port() { return (*(KINETIS_I2C_t *) port_addr); }
    29b6:	ldr	r3, [r5, #16]
	}
	tmp = port().D; // initiate the first receive
    29b8:	ldrb	r3, [r3, #4]


uint8_t TwoWire::requestFrom(uint8_t address, uint8_t length, uint8_t sendStop)
{
	uint8_t tmp __attribute__((unused));
	uint8_t status, count=0;
    29ba:	movs	r0, #0
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    29bc:	movs	r1, #2
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    29be:	movs	r4, #168	; 0xa8
	} else {
		port().C1 = I2C_C1_IICEN | I2C_C1_MST;
	}
	tmp = port().D; // initiate the first receive
	//delayMicroseconds(250);
	while (length > 1) {
    29c0:	cmp	r7, #1
    29c2:	ldr	r2, [r5, #16]
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    29c4:	ldr	r3, [r6, #0]
    29c6:	beq.n	2a20 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x13c>
    29c8:	str	r3, [sp, #16]
	return ret;
    29ca:	ldr.w	ip, [sp, #16]
		wait_begin = millis();
		while (!(port().S & I2C_S_IICIF)) {
    29ce:	ldrb	r3, [r2, #3]
    29d0:	and.w	r3, r3, #2
    29d4:	and.w	lr, r3, #255	; 0xff
    29d8:	cbnz	r3, 29ee <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x10a>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    29da:	ldr	r3, [r6, #0]
    29dc:	str	r3, [sp, #20]
	return ret;
    29de:	ldr	r3, [sp, #20]
			if (millis() - wait_begin > 5) {
    29e0:	rsb	r3, ip, r3
    29e4:	cmp	r3, #5
    29e6:	bls.n	29ce <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xea>
				port().C1 = 0;
    29e8:	strb.w	lr, [r2, #2]
    29ec:	b.n	2a86 <L_2399_delayMicroseconds+0x32>
				rxBufferLength = count;
				//Serial.printf("requestFrom err6\n");
				return count; // clock stretch too long (during data)
			}
		}
		port().S = I2C_S_IICIF;
    29ee:	strb	r1, [r2, #3]
    29f0:	ldr	r2, [r5, #16]
		status = port().S;
    29f2:	ldrb	r3, [r2, #3]
    29f4:	uxtb	r3, r3
		if ((status & I2C_S_ARBL)) {
    29f6:	tst.w	r3, #16
    29fa:	bne.n	2a90 <L_2399_delayMicroseconds+0x3c>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7a\n");
			return count;
		}
		if (!(status & I2C_S_BUSY)) {
    29fc:	lsls	r3, r3, #26
    29fe:	bpl.n	2a90 <L_2399_delayMicroseconds+0x3c>
			// or suddenly lost control of the bus!
			// TODO: what is the proper thing to do here??
			//Serial.printf("requestFrom err7b\n");
			return count;
		}
		length--;
    2a00:	subs	r7, #1
    2a02:	uxtb	r7, r7
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
    2a04:	cmp	r7, #1
    2a06:	it	eq
    2a08:	strbeq	r4, [r2, #2]
    2a0a:	ldr	r3, [r5, #16]
		if (count < BUFFER_LENGTH) {
    2a0c:	cmp	r0, #135	; 0x87
			rxBuffer[count++] = port().D;
    2a0e:	itttt	ls
    2a10:	addls	r2, r0, #1
    2a12:	addls	r0, r0, r5
    2a14:	ldrbls	r3, [r3, #4]
    2a16:	strbls	r3, [r0, #24]
		} else {
			tmp = port().D;
    2a18:	ite	hi
    2a1a:	ldrbhi	r3, [r3, #4]
			return count;
		}
		length--;
		if (length == 1) port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TXAK;
		if (count < BUFFER_LENGTH) {
			rxBuffer[count++] = port().D;
    2a1c:	uxtbls	r0, r2
    2a1e:	b.n	29c0 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0xdc>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2a20:	str	r3, [sp, #24]
	return ret;
    2a22:	ldr	r4, [sp, #24]
		} else {
			tmp = port().D;
		}
	}
	wait_begin = millis();
	while (!(port().S & I2C_S_IICIF)) {
    2a24:	ldrb	r3, [r2, #3]
    2a26:	and.w	r3, r3, #2
    2a2a:	and.w	r1, r3, #255	; 0xff
    2a2e:	cbnz	r3, 2a40 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x15c>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    2a30:	ldr	r3, [r6, #0]
    2a32:	str	r3, [sp, #28]
	return ret;
    2a34:	ldr	r3, [sp, #28]
		if (millis() - wait_begin > 5) {
    2a36:	subs	r3, r3, r4
    2a38:	cmp	r3, #5
    2a3a:	bls.n	2a24 <TwoWire::requestFrom(unsigned char, unsigned char, unsigned char)+0x140>
			port().C1 = 0;
    2a3c:	strb	r1, [r2, #2]
    2a3e:	b.n	2a86 <L_2399_delayMicroseconds+0x32>
			rxBufferLength = count;
			//Serial.printf("requestFrom err8\n");
			return count; // clock stretch too long (during data)
		}
	}
	port().S = I2C_S_IICIF;
    2a40:	movs	r3, #2
    2a42:	strb	r3, [r2, #3]
    2a44:	ldr	r2, [r5, #16]
	status = port().S;
    2a46:	ldrb	r3, [r2, #3]
    2a48:	uxtb	r3, r3
	if ((status & I2C_S_ARBL)) {
    2a4a:	lsls	r1, r3, #27
    2a4c:	bpl.n	2a64 <L_2399_delayMicroseconds+0x10>
		// we lost bus arbitration to another master
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//digitalWriteFast(13, HIGH);
		port().S = I2C_S_ARBL;
    2a4e:	movs	r3, #16
    2a50:	strb	r3, [r2, #3]
#else
		"subs   %0, #1"				"\n\t"
		"bne    L_%=_delayMicroseconds"		"\n"
		: "+r" (n) :
#endif
	);
    2a52:	movs	r3, #160	; 0xa0

00002a54 <L_2399_delayMicroseconds>:
    2a54:	subs	r3, #1
    2a56:	bne.n	2a54 <L_2399_delayMicroseconds>
    2a58:	ldr	r2, [r5, #16]
		delayMicroseconds(5);
		port().C1 &= ~I2C_C1_TXAK;
    2a5a:	ldrb	r3, [r2, #2]
    2a5c:	and.w	r3, r3, #247	; 0xf7
    2a60:	strb	r3, [r2, #2]
    2a62:	b.n	2a90 <L_2399_delayMicroseconds+0x3c>
		//Serial.printf("requestFrom err9a\n");
		return count;
	}
	if (!(status & I2C_S_BUSY)) {
    2a64:	lsls	r3, r3, #26
    2a66:	bpl.n	2a90 <L_2399_delayMicroseconds+0x3c>
		// or suddenly lost control of the bus!
		// TODO: what is the proper thing to do here??
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
    2a68:	movs	r3, #176	; 0xb0
    2a6a:	strb	r3, [r2, #2]
	if (count < BUFFER_LENGTH) {
    2a6c:	cmp	r0, #135	; 0x87
    2a6e:	ldr	r3, [r5, #16]
		rxBuffer[count++] = port().D;
    2a70:	itttt	ls
    2a72:	addls	r2, r0, #1
    2a74:	addls	r0, r0, r5
    2a76:	ldrbls	r3, [r3, #4]
    2a78:	strbls	r3, [r0, #24]
	} else {
		tmp = port().D;
    2a7a:	ite	hi
    2a7c:	ldrbhi	r3, [r3, #4]
		//Serial.printf("requestFrom err9b\n");
		return count;
	}
	port().C1 = I2C_C1_IICEN | I2C_C1_MST | I2C_C1_TX;
	if (count < BUFFER_LENGTH) {
		rxBuffer[count++] = port().D;
    2a7e:	uxtbls	r0, r2
#if F_CPU > 120000000
	__asm__("nop");
	__asm__("nop");
	__asm__("nop");
#endif
	if (sendStop) port().C1 = I2C_C1_IICEN;
    2a80:	cmp.w	r9, #0
    2a84:	beq.n	2a8c <L_2399_delayMicroseconds+0x38>
    2a86:	ldr	r3, [r5, #16]
    2a88:	movs	r2, #128	; 0x80
    2a8a:	strb	r2, [r3, #2]
	rxBufferLength = count;
    2a8c:	strb.w	r0, [r5, #161]	; 0xa1
    2a90:	mov	r4, r0
	return count;
}
    2a92:	mov	r0, r4
    2a94:	add	sp, #36	; 0x24
    2a96:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    2a9a:	nop
    2a9c:	.word	0x2001cf20

00002aa0 <i2c0_isr>:
#define MAKE_CONST(x) (__builtin_constant_p(x) ? (x) : (x))

#ifdef WIRE_IMPLEMENT_WIRE
constexpr uintptr_t i2c0_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C0));
TwoWire Wire(i2c0_addr, TwoWire::i2c0_hardware);
void i2c0_isr(void) { Wire.isr(); }
    2aa0:	ldr	r0, [pc, #4]	; (2aa8 <i2c0_isr+0x8>)
    2aa2:	b.w	25f8 <TwoWire::isr()>
    2aa6:	nop
    2aa8:	.word	0x1fff10a4

00002aac <i2c1_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE1
constexpr uintptr_t i2c1_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C1));
TwoWire Wire1(i2c1_addr, TwoWire::i2c1_hardware);
void i2c1_isr(void) { Wire1.isr(); }
    2aac:	ldr	r0, [pc, #4]	; (2ab4 <i2c1_isr+0x8>)
    2aae:	b.w	25f8 <TwoWire::isr()>
    2ab2:	nop
    2ab4:	.word	0x1fff11e0

00002ab8 <i2c2_isr>:
#endif
#ifdef WIRE_IMPLEMENT_WIRE2
constexpr uintptr_t i2c2_addr = uintptr_t(MAKE_CONST(&KINETIS_I2C2));
TwoWire Wire2(i2c2_addr, TwoWire::i2c2_hardware);
void i2c2_isr(void) { Wire2.isr(); }
    2ab8:	ldr	r0, [pc, #4]	; (2ac0 <i2c2_isr+0x8>)
    2aba:	b.w	25f8 <TwoWire::isr()>
    2abe:	nop
    2ac0:	.word	0x1fff0f68

00002ac4 <DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]>:

#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
    2ac4:	ldrh	r3, [r0, #30]
    2ac6:	lsls	r3, r3, #16
		tcd->BITER = len & 0x7fff;
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    2ac8:	itttt	mi
    2aca:	ldrhmi	r3, [r0, #30]
    2acc:	ubfxmi	r1, r1, #0, #9
    2ad0:	andmi.w	r3, r3, #65024	; 0xfe00
    2ad4:	orrmi	r1, r3
#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
		tcd->BITER = len & 0x7fff;
    2ad6:	it	pl
    2ad8:	ubfxpl	r1, r1, #0, #15
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
    2adc:	strh	r1, [r0, #30]
	}
	tcd->CITER = tcd->BITER; 
    2ade:	ldrh	r3, [r0, #30]
    2ae0:	uxth	r3, r3
    2ae2:	strh	r3, [r0, #22]
    2ae4:	bx	lr
    2ae6:	Address 0x00002ae6 is out of bounds.


00002ae8 <SPIClass::begin()>:
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
	const SPI_Hardware_t & hardware() { return *(const SPI_Hardware_t *)hardware_addr; }
    2ae8:	ldr	r3, [r0, #4]

void SPIClass::begin()
{
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    2aea:	ldr	r1, [r3, #0]
    2aec:	ldr	r2, [r3, #4]
SPIClass SPI2((uintptr_t)&KINETISK_SPI2, (uintptr_t)&SPIClass::spi2_hardware);
#endif


void SPIClass::begin()
{
    2aee:	push	{r4, lr}
	volatile uint32_t *reg;

	hardware().clock_gate_register |= hardware().clock_gate_mask;
    2af0:	ldr	r4, [r1, #0]
    2af2:	orrs	r2, r4
    2af4:	str	r2, [r1, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    2af6:	ldr	r2, [r0, #0]
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
    2af8:	ldr	r1, [pc, #84]	; (2b50 <SPIClass::begin()+0x68>)
    2afa:	str	r1, [r2, #0]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    2afc:	ldr	r1, [pc, #84]	; (2b54 <SPIClass::begin()+0x6c>)
    2afe:	str	r1, [r2, #12]
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
    2b00:	add.w	r1, r1, #1073741824	; 0x40000000
    2b04:	str	r1, [r2, #16]
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
    2b06:	ldr	r1, [pc, #80]	; (2b58 <SPIClass::begin()+0x70>)
    2b08:	str	r1, [r2, #0]
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2b0a:	ldrb	r1, [r0, #9]
    2b0c:	ldr	r2, [pc, #76]	; (2b5c <SPIClass::begin()+0x74>)
    2b0e:	adds	r4, r3, r1
	*reg = hardware().mosi_mux[mosi_pin_index];
    2b10:	adds	r1, #12
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2b12:	ldrb.w	r4, [r4, #44]	; 0x2c
	*reg = hardware().mosi_mux[mosi_pin_index];
    2b16:	ldr.w	r1, [r3, r1, lsl #2]
	hardware().clock_gate_register |= hardware().clock_gate_mask;
	port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x1F);
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2b1a:	add.w	r4, r2, r4, lsl #3
    2b1e:	ldr	r4, [r4, #4]
	*reg = hardware().mosi_mux[mosi_pin_index];
    2b20:	str	r1, [r4, #0]
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2b22:	ldrb	r1, [r0, #8]
    2b24:	adds	r4, r3, r1
	*reg= hardware().miso_mux[miso_pin_index];
    2b26:	add.w	r1, r3, r1, lsl #2
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2b2a:	ldrb	r4, [r4, #24]
	*reg= hardware().miso_mux[miso_pin_index];
    2b2c:	ldr	r1, [r1, #28]
	port().CTAR0 = SPI_CTAR_FMSZ(7) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().CTAR1 = SPI_CTAR_FMSZ(15) | SPI_CTAR_PBR(0) | SPI_CTAR_BR(1) | SPI_CTAR_CSSCK(1);
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2b2e:	add.w	r4, r2, r4, lsl #3
    2b32:	ldr	r4, [r4, #4]
	*reg= hardware().miso_mux[miso_pin_index];
    2b34:	str	r1, [r4, #0]
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2b36:	ldrb	r1, [r0, #10]
    2b38:	adds	r0, r3, r1
	*reg = hardware().sck_mux[sck_pin_index];
    2b3a:	add.w	r3, r3, r1, lsl #2
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2b3e:	ldrb.w	r0, [r0, #64]	; 0x40
	*reg = hardware().sck_mux[sck_pin_index];
    2b42:	ldr	r3, [r3, #68]	; 0x44
	port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x1F);
	reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
	*reg = hardware().mosi_mux[mosi_pin_index];
	reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
	*reg= hardware().miso_mux[miso_pin_index];
	reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2b44:	add.w	r2, r2, r0, lsl #3
    2b48:	ldr	r2, [r2, #4]
	*reg = hardware().sck_mux[sck_pin_index];
    2b4a:	str	r3, [r2, #0]
    2b4c:	pop	{r4, pc}
    2b4e:	nop
    2b50:	.word	0x001f4001
    2b54:	.word	0x38001001
    2b58:	.word	0x801f0000
    2b5c:	.word	0x00012d80

00002b60 <SPIClass::setMOSI(unsigned char)>:
	return 0;
}

void SPIClass::setMOSI(uint8_t pin)
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2b60:	ldr	r3, [r0, #4]
    2b62:	ldr	r2, [pc, #140]	; (2bf0 <SPIClass::setMOSI(unsigned char)+0x90>)
    2b64:	cmp	r2, r3
	}
	return 0;
}

void SPIClass::setMOSI(uint8_t pin)
{
    2b66:	push	{r4, r5, r6, lr}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2b68:	bne.n	2b9c <SPIClass::setMOSI(unsigned char)+0x3c>
		pinout = newpinout;
#endif
	}
	inline void setMOSI_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 11) pinout &= ~3;
    2b6a:	cmp	r1, #11
    2b6c:	bne.n	2b78 <SPIClass::setMOSI(unsigned char)+0x18>
    2b6e:	ldr	r4, [pc, #132]	; (2bf4 <SPIClass::setMOSI(unsigned char)+0x94>)
    2b70:	ldrb	r2, [r4, #0]
    2b72:	bic.w	r2, r2, #3
    2b76:	b.n	2b9a <SPIClass::setMOSI(unsigned char)+0x3a>
		if (pin == 7)  pinout = (pinout & ~0x3) | 1;
    2b78:	cmp	r1, #7
    2b7a:	bne.n	2b8a <SPIClass::setMOSI(unsigned char)+0x2a>
    2b7c:	ldr	r4, [pc, #116]	; (2bf4 <SPIClass::setMOSI(unsigned char)+0x94>)
    2b7e:	ldrb	r2, [r4, #0]
    2b80:	bic.w	r2, r2, #3
    2b84:	orr.w	r2, r2, #1
    2b88:	b.n	2b9a <SPIClass::setMOSI(unsigned char)+0x3a>
		if (pin == 28) pinout = (pinout & ~0x3) | 2;
    2b8a:	cmp	r1, #28
    2b8c:	bne.n	2b9c <SPIClass::setMOSI(unsigned char)+0x3c>
    2b8e:	ldr	r4, [pc, #100]	; (2bf4 <SPIClass::setMOSI(unsigned char)+0x94>)
    2b90:	ldrb	r2, [r4, #0]
    2b92:	bic.w	r2, r2, #3
    2b96:	orr.w	r2, r2, #2
    2b9a:	strb	r2, [r4, #0]
		SPCR.setMOSI_soft(pin);
	}
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
    2b9c:	ldrb	r2, [r0, #9]
    2b9e:	add	r2, r3
    2ba0:	ldrb.w	r4, [r2, #44]	; 0x2c
    2ba4:	cmp	r1, r4
    2ba6:	beq.n	2bec <SPIClass::setMOSI(unsigned char)+0x8c>
    2ba8:	add.w	r5, r3, #43	; 0x2b
    2bac:	movs	r2, #0
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
    2bae:	ldrb.w	r6, [r5, #1]!
    2bb2:	cmp	r6, r1
    2bb4:	bne.n	2be6 <SPIClass::setMOSI(unsigned char)+0x86>
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    2bb6:	ldr	r1, [r3, #0]
    2bb8:	ldr	r5, [r1, #0]
    2bba:	ldr	r1, [r3, #4]
    2bbc:	tst	r5, r1
    2bbe:	beq.n	2be2 <SPIClass::setMOSI(unsigned char)+0x82>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2bc0:	ldr	r1, [pc, #52]	; (2bf8 <SPIClass::setMOSI(unsigned char)+0x98>)
    2bc2:	add.w	r4, r1, r4, lsl #3
					*reg = 0;
    2bc6:	movs	r5, #0
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
			if  (pin == hardware().mosi_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
    2bc8:	ldr	r4, [r4, #4]
					*reg = 0;
    2bca:	str	r5, [r4, #0]
					reg = portConfigRegister(hardware().mosi_pin[i]);
    2bcc:	adds	r4, r3, r2
    2bce:	ldrb.w	r4, [r4, #44]	; 0x2c
    2bd2:	add.w	r1, r1, r4, lsl #3
					*reg = hardware().mosi_mux[i];
    2bd6:	add.w	r4, r2, #12
			if  (pin == hardware().mosi_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().mosi_pin[mosi_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().mosi_pin[i]);
    2bda:	ldr	r1, [r1, #4]
					*reg = hardware().mosi_mux[i];
    2bdc:	ldr.w	r3, [r3, r4, lsl #2]
    2be0:	str	r3, [r1, #0]
				}	
				mosi_pin_index = i;
    2be2:	strb	r2, [r0, #9]
				return;
    2be4:	pop	{r4, r5, r6, pc}
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setMOSI_soft(pin);
	}
	if (pin != hardware().mosi_pin[mosi_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().mosi_pin); i++) {
    2be6:	adds	r2, #1
    2be8:	cmp	r2, #4
    2bea:	bne.n	2bae <SPIClass::setMOSI(unsigned char)+0x4e>
    2bec:	pop	{r4, r5, r6, pc}
    2bee:	nop
    2bf0:	.word	0x000128d0
    2bf4:	.word	0x2001d019
    2bf8:	.word	0x00012d80

00002bfc <SPIClass::setMISO(unsigned char)>:
	}
}

void SPIClass::setMISO(uint8_t pin)
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2bfc:	ldr	r3, [r0, #4]
    2bfe:	ldr	r2, [pc, #132]	; (2c84 <SPIClass::setMISO(unsigned char)+0x88>)
    2c00:	cmp	r2, r3
		}
	}
}

void SPIClass::setMISO(uint8_t pin)
{
    2c02:	push	{r4, r5, r6, lr}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2c04:	bne.n	2c38 <SPIClass::setMISO(unsigned char)+0x3c>
		pinout = newpinout;
#endif
	}
	inline void setMISO_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 12) pinout &= ~0xc;
    2c06:	cmp	r1, #12
    2c08:	bne.n	2c14 <SPIClass::setMISO(unsigned char)+0x18>
    2c0a:	ldr	r4, [pc, #124]	; (2c88 <SPIClass::setMISO(unsigned char)+0x8c>)
    2c0c:	ldrb	r2, [r4, #0]
    2c0e:	bic.w	r2, r2, #12
    2c12:	b.n	2c36 <SPIClass::setMISO(unsigned char)+0x3a>
		if (pin == 8)  pinout = (pinout & ~0xc) | 4;
    2c14:	cmp	r1, #8
    2c16:	bne.n	2c26 <SPIClass::setMISO(unsigned char)+0x2a>
    2c18:	ldr	r4, [pc, #108]	; (2c88 <SPIClass::setMISO(unsigned char)+0x8c>)
    2c1a:	ldrb	r2, [r4, #0]
    2c1c:	bic.w	r2, r2, #12
    2c20:	orr.w	r2, r2, #4
    2c24:	b.n	2c36 <SPIClass::setMISO(unsigned char)+0x3a>
		if (pin == 39) pinout = (pinout & ~0xc) | 8;
    2c26:	cmp	r1, #39	; 0x27
    2c28:	bne.n	2c38 <SPIClass::setMISO(unsigned char)+0x3c>
    2c2a:	ldr	r4, [pc, #92]	; (2c88 <SPIClass::setMISO(unsigned char)+0x8c>)
    2c2c:	ldrb	r2, [r4, #0]
    2c2e:	bic.w	r2, r2, #12
    2c32:	orr.w	r2, r2, #8
    2c36:	strb	r2, [r4, #0]
		SPCR.setMISO_soft(pin);
	}
	if (pin != hardware().miso_pin[miso_pin_index]) {
    2c38:	ldrb	r2, [r0, #8]
    2c3a:	add	r2, r3
    2c3c:	ldrb	r4, [r2, #24]
    2c3e:	cmp	r1, r4
    2c40:	beq.n	2c82 <SPIClass::setMISO(unsigned char)+0x86>
    2c42:	add.w	r5, r3, #23
    2c46:	movs	r2, #0
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
			if  (pin == hardware().miso_pin[i]) {
    2c48:	ldrb.w	r6, [r5, #1]!
    2c4c:	cmp	r6, r1
    2c4e:	bne.n	2c7c <SPIClass::setMISO(unsigned char)+0x80>
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    2c50:	ldr	r1, [r3, #0]
    2c52:	ldr	r5, [r1, #0]
    2c54:	ldr	r1, [r3, #4]
    2c56:	tst	r5, r1
    2c58:	beq.n	2c78 <SPIClass::setMISO(unsigned char)+0x7c>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2c5a:	ldr	r1, [pc, #48]	; (2c8c <SPIClass::setMISO(unsigned char)+0x90>)
    2c5c:	add.w	r4, r1, r4, lsl #3
					*reg = 0;
    2c60:	movs	r5, #0
	if (pin != hardware().miso_pin[miso_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
    2c62:	ldr	r4, [r4, #4]
					*reg = 0;
    2c64:	str	r5, [r4, #0]
					reg = portConfigRegister(hardware().miso_pin[i]);
    2c66:	adds	r4, r3, r2
					*reg = hardware().miso_mux[i];
    2c68:	add.w	r3, r3, r2, lsl #2
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().miso_pin[i]);
    2c6c:	ldrb	r4, [r4, #24]
					*reg = hardware().miso_mux[i];
    2c6e:	ldr	r3, [r3, #28]
			if  (pin == hardware().miso_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().miso_pin[miso_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().miso_pin[i]);
    2c70:	add.w	r1, r1, r4, lsl #3
    2c74:	ldr	r1, [r1, #4]
					*reg = hardware().miso_mux[i];
    2c76:	str	r3, [r1, #0]
				}	
				miso_pin_index = i;
    2c78:	strb	r2, [r0, #8]
				return;
    2c7a:	pop	{r4, r5, r6, pc}
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setMISO_soft(pin);
	}
	if (pin != hardware().miso_pin[miso_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().miso_pin); i++) {
    2c7c:	adds	r2, #1
    2c7e:	cmp	r2, #4
    2c80:	bne.n	2c48 <SPIClass::setMISO(unsigned char)+0x4c>
    2c82:	pop	{r4, r5, r6, pc}
    2c84:	.word	0x000128d0
    2c88:	.word	0x2001d019
    2c8c:	.word	0x00012d80

00002c90 <SPIClass::setSCK(unsigned char)>:
	}
}

void SPIClass::setSCK(uint8_t pin)
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2c90:	ldr	r3, [r0, #4]
    2c92:	ldr	r2, [pc, #148]	; (2d28 <SPIClass::setSCK(unsigned char)+0x98>)
    2c94:	cmp	r2, r3
		}
	}
}

void SPIClass::setSCK(uint8_t pin)
{
    2c96:	push	{r4, r5, lr}
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
    2c98:	bne.n	2ccc <SPIClass::setSCK(unsigned char)+0x3c>
		pinout = newpinout;
#endif
	}
	inline void setSCK_soft(uint8_t pin) __attribute__((always_inline)) {
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		if (pin == 13) pinout &= ~0x30;
    2c9a:	cmp	r1, #13
    2c9c:	bne.n	2ca8 <SPIClass::setSCK(unsigned char)+0x18>
    2c9e:	ldr	r4, [pc, #140]	; (2d2c <SPIClass::setSCK(unsigned char)+0x9c>)
    2ca0:	ldrb	r2, [r4, #0]
    2ca2:	bic.w	r2, r2, #48	; 0x30
    2ca6:	b.n	2cca <SPIClass::setSCK(unsigned char)+0x3a>
		if (pin == 14) pinout = (pinout & ~0x30) | 0x10;
    2ca8:	cmp	r1, #14
    2caa:	bne.n	2cba <SPIClass::setSCK(unsigned char)+0x2a>
    2cac:	ldr	r4, [pc, #124]	; (2d2c <SPIClass::setSCK(unsigned char)+0x9c>)
    2cae:	ldrb	r2, [r4, #0]
    2cb0:	bic.w	r2, r2, #48	; 0x30
    2cb4:	orr.w	r2, r2, #16
    2cb8:	b.n	2cca <SPIClass::setSCK(unsigned char)+0x3a>
		if (pin == 27) pinout = (pinout & ~0x30) | 0x20;
    2cba:	cmp	r1, #27
    2cbc:	bne.n	2ccc <SPIClass::setSCK(unsigned char)+0x3c>
    2cbe:	ldr	r4, [pc, #108]	; (2d2c <SPIClass::setSCK(unsigned char)+0x9c>)
    2cc0:	ldrb	r2, [r4, #0]
    2cc2:	bic.w	r2, r2, #48	; 0x30
    2cc6:	orr.w	r2, r2, #32
    2cca:	strb	r2, [r4, #0]
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
    2ccc:	ldrb	r2, [r0, #10]
    2cce:	add	r2, r3
    2cd0:	ldrb.w	r4, [r2, #64]	; 0x40
    2cd4:	cmp	r1, r4
    2cd6:	beq.n	2d26 <SPIClass::setSCK(unsigned char)+0x96>
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
    2cd8:	ldrb.w	r2, [r3, #64]	; 0x40
    2cdc:	cmp	r2, r1
    2cde:	beq.n	2cf4 <SPIClass::setSCK(unsigned char)+0x64>
    2ce0:	ldrb.w	r2, [r3, #65]	; 0x41
    2ce4:	cmp	r2, r1
    2ce6:	beq.n	2cf8 <SPIClass::setSCK(unsigned char)+0x68>
    2ce8:	ldrb.w	r2, [r3, #66]	; 0x42
    2cec:	cmp	r2, r1
    2cee:	bne.n	2d26 <SPIClass::setSCK(unsigned char)+0x96>
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
    2cf0:	movs	r2, #2
    2cf2:	b.n	2cfa <SPIClass::setSCK(unsigned char)+0x6a>
			if  (pin == hardware().sck_pin[i]) {
    2cf4:	movs	r2, #0
    2cf6:	b.n	2cfa <SPIClass::setSCK(unsigned char)+0x6a>
{
	if (hardware_addr == (uintptr_t)&spi0_hardware) {
		SPCR.setSCK_soft(pin);
	}
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
    2cf8:	movs	r2, #1
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
    2cfa:	ldr	r1, [r3, #0]
    2cfc:	ldr	r5, [r1, #0]
    2cfe:	ldr	r1, [r3, #4]
    2d00:	tst	r5, r1
    2d02:	beq.n	2d24 <SPIClass::setSCK(unsigned char)+0x94>
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2d04:	ldr	r1, [pc, #40]	; (2d30 <SPIClass::setSCK(unsigned char)+0xa0>)
    2d06:	add.w	r4, r1, r4, lsl #3
					*reg = 0;
    2d0a:	movs	r5, #0
	if (pin != hardware().sck_pin[sck_pin_index]) {
		for (unsigned int i = 0; i < sizeof(hardware().sck_pin); i++) {
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
    2d0c:	ldr	r4, [r4, #4]
					*reg = 0;
    2d0e:	str	r5, [r4, #0]
					reg = portConfigRegister(hardware().sck_pin[i]);
    2d10:	adds	r4, r3, r2
					*reg = hardware().sck_mux[i];
    2d12:	add.w	r3, r3, r2, lsl #2
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().sck_pin[i]);
    2d16:	ldrb.w	r4, [r4, #64]	; 0x40
					*reg = hardware().sck_mux[i];
    2d1a:	ldr	r3, [r3, #68]	; 0x44
			if  (pin == hardware().sck_pin[i]) {
				if (hardware().clock_gate_register & hardware().clock_gate_mask) {
					volatile uint32_t *reg;
					reg = portConfigRegister(hardware().sck_pin[sck_pin_index]);
					*reg = 0;
					reg = portConfigRegister(hardware().sck_pin[i]);
    2d1c:	add.w	r1, r1, r4, lsl #3
    2d20:	ldr	r1, [r1, #4]
					*reg = hardware().sck_mux[i];
    2d22:	str	r3, [r1, #0]
				}	
				sck_pin_index = i;
    2d24:	strb	r2, [r0, #10]
    2d26:	pop	{r4, r5, pc}
    2d28:	.word	0x000128d0
    2d2c:	.word	0x2001d019
    2d30:	.word	0x00012d80

00002d34 <SPIClass::transfer(void const*, void*, unsigned int)>:
		}
	}
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{
    2d34:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	if (count == 0) return;
    2d38:	cmp	r3, #0
    2d3a:	beq.w	2ef6 <SPIClass::transfer(void const*, void*, unsigned int)+0x1c2>
    2d3e:	ldr	r4, [r0, #0]
    2d40:	ldr	r6, [pc, #440]	; (2efc <SPIClass::transfer(void const*, void*, unsigned int)+0x1c8>)
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    2d42:	ldr	r5, [r4, #12]
		const uint8_t *p_write = (const uint8_t *)buf;
		uint8_t *p_read = (uint8_t *)retbuf;
		size_t count_read = count;

		// Lets clear the reader queue
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);
    2d44:	str	r6, [r4, #0]

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
	if (!(port().CTAR0 & SPI_CTAR_LSBFE)) {
    2d46:	tst.w	r5, #16777216	; 0x1000000
    2d4a:	and.w	r5, r3, #1
    2d4e:	bne.n	2e2c <SPIClass::transfer(void const*, void*, unsigned int)+0xf8>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2d50:	cbz	r5, 2d78 <SPIClass::transfer(void const*, void*, unsigned int)+0x44>
		    if (p_write) {
    2d52:	cbz	r1, 2d66 <SPIClass::transfer(void const*, void*, unsigned int)+0x32>
    2d54:	adds	r5, r1, #1
    2d56:	ldrb	r1, [r1, #0]
				if (count > 1)
    2d58:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2d5a:	it	ne
    2d5c:	orrne.w	r1, r1, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    2d60:	str	r1, [r4, #52]	; 0x34
    2d62:	mov	r1, r5
    2d64:	b.n	2d74 <SPIClass::transfer(void const*, void*, unsigned int)+0x40>
    2d66:	ldrb.w	r5, [r0, #44]	; 0x2c
			} else {
				if (count > 1)
    2d6a:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2d6c:	it	ne
    2d6e:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    2d72:	str	r5, [r4, #52]	; 0x34
			}
			count--;
    2d74:	subs	r6, r3, #1
    2d76:	b.n	2d7a <SPIClass::transfer(void const*, void*, unsigned int)+0x46>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2d78:	mov	r6, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;
    2d7a:	ldrb.w	r4, [r0, #44]	; 0x2c
    2d7e:	orr.w	r4, r4, r4, lsl #8

		while (count > 0) {
    2d82:	cmp	r6, #0
    2d84:	beq.n	2e04 <SPIClass::transfer(void const*, void*, unsigned int)+0xd0>
			// Push out the next byte; 
		    if (p_write) {
    2d86:	cbz	r1, 2d96 <SPIClass::transfer(void const*, void*, unsigned int)+0x62>
		    	w = (*p_write++) << 8;
    2d88:	mov	r5, r1
				w |= *p_write++;
    2d8a:	ldrb	r1, [r1, #1]
	    uint16_t w =  (uint16_t)(_transferWriteFill << 8) | _transferWriteFill;

		while (count > 0) {
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
    2d8c:	ldrb.w	r4, [r5], #2
				w |= *p_write++;
    2d90:	orr.w	r4, r1, r4, lsl #8
    2d94:	mov	r1, r5
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2d96:	ldr	r5, [r0, #4]
    2d98:	ldr	r7, [r0, #0]
    2d9a:	ldrb	r5, [r5, #8]
			if (count == 2)
    2d9c:	cmp	r6, #2
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2d9e:	add.w	r5, r5, #4294967295
    2da2:	mov.w	r5, r5, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    2da6:	ite	eq
    2da8:	orreq.w	lr, r4, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2dac:	orrne.w	lr, r4, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
		    	w = (*p_write++) << 8;
				w |= *p_write++;
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2db0:	uxth	r5, r5
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2db2:	str.w	lr, [r7, #52]	; 0x34
			count -= 2; // how many bytes to output.
    2db6:	subs	r6, #2
    2db8:	ldr.w	lr, [r0]
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    2dbc:	ldr.w	r7, [lr, #44]	; 0x2c
				if (sr & 0xF0)  {
    2dc0:	tst.w	r7, #240	; 0xf0
    2dc4:	beq.n	2df0 <SPIClass::transfer(void const*, void*, unsigned int)+0xbc>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    2dc6:	tst.w	r3, #1
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    2dca:	ldr.w	ip, [lr, #56]	; 0x38
					if (count_read & 1) {
    2dce:	beq.n	2ddc <SPIClass::transfer(void const*, void*, unsigned int)+0xa8>
						if (p_read) {
    2dd0:	cbz	r2, 2dd8 <SPIClass::transfer(void const*, void*, unsigned int)+0xa4>
							*p_read++ = w;  // Read any pending RX bytes in
    2dd2:	strb.w	ip, [r2]
    2dd6:	adds	r2, #1
						} 
						count_read--;
    2dd8:	subs	r3, #1
    2dda:	b.n	2df0 <SPIClass::transfer(void const*, void*, unsigned int)+0xbc>
					} else {
						if (p_read) {
    2ddc:	cbz	r2, 2dee <SPIClass::transfer(void const*, void*, unsigned int)+0xba>
							*p_read++ = w >> 8;
    2dde:	mov	lr, r2
    2de0:	mov.w	r8, ip, asr #8
    2de4:	strb.w	r8, [lr], #2
							*p_read++ = (w & 0xff);
    2de8:	strb.w	ip, [r2, #1]
    2dec:	mov	r2, lr
						}
						count_read -= 2;
    2dee:	subs	r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    2df0:	and.w	r7, r7, #61440	; 0xf000
    2df4:	cmp	r7, r5
    2df6:	bhi.n	2db8 <SPIClass::transfer(void const*, void*, unsigned int)+0x84>
    2df8:	b.n	2d82 <SPIClass::transfer(void const*, void*, unsigned int)+0x4e>
    2dfa:	ldr	r1, [r0, #0]

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
    2dfc:	ldr	r4, [r1, #44]	; 0x2c
			if (sr & 0xF0)  {
    2dfe:	tst.w	r4, #240	; 0xf0
    2e02:	bne.n	2e0a <SPIClass::transfer(void const*, void*, unsigned int)+0xd6>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    2e04:	cmp	r3, #0
    2e06:	bne.n	2dfa <SPIClass::transfer(void const*, void*, unsigned int)+0xc6>
    2e08:	b.n	2ef6 <SPIClass::transfer(void const*, void*, unsigned int)+0x1c2>
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    2e0a:	ldr	r4, [r1, #56]	; 0x38
				if (count_read & 1) {
    2e0c:	lsls	r1, r3, #31
    2e0e:	bpl.n	2e1a <SPIClass::transfer(void const*, void*, unsigned int)+0xe6>
					if (p_read)
    2e10:	cbz	r2, 2e16 <SPIClass::transfer(void const*, void*, unsigned int)+0xe2>
						*p_read++ = w;  // Read any pending RX bytes in
    2e12:	strb	r4, [r2, #0]
    2e14:	adds	r2, #1
					count_read--;
    2e16:	subs	r3, #1
    2e18:	b.n	2e04 <SPIClass::transfer(void const*, void*, unsigned int)+0xd0>
				} else {
					if (p_read) {
    2e1a:	cbz	r2, 2e28 <SPIClass::transfer(void const*, void*, unsigned int)+0xf4>
						*p_read++ = w >> 8;
    2e1c:	mov	r1, r2
    2e1e:	asrs	r5, r4, #8
    2e20:	strb.w	r5, [r1], #2
						*p_read++ = (w & 0xff);
    2e24:	strb	r4, [r2, #1]
    2e26:	mov	r2, r1
					}
					count_read -= 2;
    2e28:	subs	r3, #2
    2e2a:	b.n	2e04 <SPIClass::transfer(void const*, void*, unsigned int)+0xd0>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2e2c:	cbz	r5, 2e54 <SPIClass::transfer(void const*, void*, unsigned int)+0x120>
		    if (p_write) {
    2e2e:	cbz	r1, 2e42 <SPIClass::transfer(void const*, void*, unsigned int)+0x10e>
    2e30:	adds	r5, r1, #1
    2e32:	ldrb	r1, [r1, #0]
				if (count > 1)
    2e34:	cmp	r3, #1
					port().PUSHR = *p_write++ | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2e36:	it	ne
    2e38:	orrne.w	r1, r1, #2147483648	; 0x80000000
				else
					port().PUSHR = *p_write++ | SPI_PUSHR_CTAS(0);
    2e3c:	str	r1, [r4, #52]	; 0x34
    2e3e:	mov	r1, r5
    2e40:	b.n	2e50 <SPIClass::transfer(void const*, void*, unsigned int)+0x11c>
    2e42:	ldrb.w	r5, [r0, #44]	; 0x2c
			} else {
				if (count > 1)
    2e46:	cmp	r3, #1
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(0);
    2e48:	it	ne
    2e4a:	orrne.w	r5, r5, #2147483648	; 0x80000000
				else
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
    2e4e:	str	r5, [r4, #52]	; 0x34
			}
			count--;
    2e50:	subs	r6, r3, #1
    2e52:	b.n	2e56 <SPIClass::transfer(void const*, void*, unsigned int)+0x122>
		port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);

		uint32_t sr;

		// Now lets loop while we still have data to output
		if (count & 1) {
    2e54:	mov	r6, r3
					port().PUSHR = _transferWriteFill | SPI_PUSHR_CTAS(0);
			}
			count--;
		}

	    uint16_t w = _transferWriteFill;
    2e56:	ldrb.w	r7, [r0, #44]	; 0x2c

		while (count > 0) {
    2e5a:	cmp	r6, #0
    2e5c:	beq.n	2ece <SPIClass::transfer(void const*, void*, unsigned int)+0x19a>
			// Push out the next byte; 
		    if (p_write) {
    2e5e:	cbz	r1, 2e6a <SPIClass::transfer(void const*, void*, unsigned int)+0x136>
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
    2e60:	ldrb	r7, [r1, #1]
    2e62:	ldrb	r4, [r1, #0]
    2e64:	adds	r1, #2
    2e66:	orr.w	r7, r4, r7, lsl #8
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2e6a:	ldr	r4, [r0, #4]
    2e6c:	ldr	r5, [r0, #0]
    2e6e:	ldrb	r4, [r4, #8]
			if (count == 2)
    2e70:	cmp	r6, #2
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2e72:	add.w	r4, r4, #4294967295
    2e76:	mov.w	r4, r4, lsl #12
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
    2e7a:	ite	eq
    2e7c:	orreq.w	lr, r7, #268435456	; 0x10000000
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2e80:	orrne.w	lr, r7, #2415919104	; 0x90000000
			// Push out the next byte; 
		    if (p_write) {
				w = *p_write++;
		    	w |= ((*p_write++) << 8);
		    }
		    uint16_t queue_full_status_mask = (hardware().queue_size-1) << 12;
    2e84:	uxth	r4, r4
			if (count == 2)
				port().PUSHR = w | SPI_PUSHR_CTAS(1);
			else	
				port().PUSHR = w | SPI_PUSHR_CONT | SPI_PUSHR_CTAS(1);
    2e86:	str.w	lr, [r5, #52]	; 0x34
			count -= 2; // how many bytes to output.
    2e8a:	subs	r6, #2
    2e8c:	ldr	r5, [r0, #0]
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
    2e8e:	ldr.w	lr, [r5, #44]	; 0x2c
				if (sr & 0xF0)  {
    2e92:	tst.w	lr, #240	; 0xf0
    2e96:	beq.n	2eba <SPIClass::transfer(void const*, void*, unsigned int)+0x186>
					uint16_t w = port().POPR;  // Read any pending RX bytes in
					if (count_read & 1) {
    2e98:	tst.w	r3, #1
			count -= 2; // how many bytes to output.
			// Make sure queue is not full before pushing next byte out
			do {
				sr = port().SR;
				if (sr & 0xF0)  {
					uint16_t w = port().POPR;  // Read any pending RX bytes in
    2e9c:	ldr	r5, [r5, #56]	; 0x38
					if (count_read & 1) {
    2e9e:	beq.n	2eaa <SPIClass::transfer(void const*, void*, unsigned int)+0x176>
						if (p_read) {
    2ea0:	cbz	r2, 2ea6 <SPIClass::transfer(void const*, void*, unsigned int)+0x172>
							*p_read++ = w;  // Read any pending RX bytes in
    2ea2:	strb	r5, [r2, #0]
    2ea4:	adds	r2, #1
						} 
						count_read--;
    2ea6:	subs	r3, #1
    2ea8:	b.n	2eba <SPIClass::transfer(void const*, void*, unsigned int)+0x186>
					} else {
						if (p_read) {
    2eaa:	cbz	r2, 2eb8 <SPIClass::transfer(void const*, void*, unsigned int)+0x184>
							*p_read++ = (w & 0xff);
    2eac:	mov	ip, r2
    2eae:	strb.w	r5, [ip], #2
							*p_read++ = w >> 8;
    2eb2:	asrs	r5, r5, #8
    2eb4:	strb	r5, [r2, #1]
    2eb6:	mov	r2, ip
						}
						count_read -= 2;
    2eb8:	subs	r3, #2
					}
				}
			} while ((sr & (15 << 12)) > queue_full_status_mask);
    2eba:	and.w	lr, lr, #61440	; 0xf000
    2ebe:	cmp	lr, r4
    2ec0:	bhi.n	2e8c <SPIClass::transfer(void const*, void*, unsigned int)+0x158>
    2ec2:	b.n	2e5a <SPIClass::transfer(void const*, void*, unsigned int)+0x126>
    2ec4:	ldr	r1, [r0, #0]

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
    2ec6:	ldr	r4, [r1, #44]	; 0x2c
			if (sr & 0xF0)  {
    2ec8:	tst.w	r4, #240	; 0xf0
    2ecc:	bne.n	2ed4 <SPIClass::transfer(void const*, void*, unsigned int)+0x1a0>
			} while ((sr & (15 << 12)) > queue_full_status_mask);

		}

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
    2ece:	cmp	r3, #0
    2ed0:	bne.n	2ec4 <SPIClass::transfer(void const*, void*, unsigned int)+0x190>
    2ed2:	b.n	2ef6 <SPIClass::transfer(void const*, void*, unsigned int)+0x1c2>
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
				if (count_read & 1) {
    2ed4:	lsls	r4, r3, #31

		// now lets wait for all of the read bytes to be returned...
		while (count_read) {
			sr = port().SR;
			if (sr & 0xF0)  {
				uint16_t w = port().POPR;  // Read any pending RX bytes in
    2ed6:	ldr	r1, [r1, #56]	; 0x38
				if (count_read & 1) {
    2ed8:	bpl.n	2ee4 <SPIClass::transfer(void const*, void*, unsigned int)+0x1b0>
					if (p_read)
    2eda:	cbz	r2, 2ee0 <SPIClass::transfer(void const*, void*, unsigned int)+0x1ac>
						*p_read++ = w;  // Read any pending RX bytes in
    2edc:	strb	r1, [r2, #0]
    2ede:	adds	r2, #1
					count_read--;
    2ee0:	subs	r3, #1
    2ee2:	b.n	2ece <SPIClass::transfer(void const*, void*, unsigned int)+0x19a>
				} else {
					if (p_read) {
    2ee4:	cbz	r2, 2ef2 <SPIClass::transfer(void const*, void*, unsigned int)+0x1be>
						*p_read++ = (w & 0xff);
    2ee6:	mov	r4, r2
    2ee8:	strb.w	r1, [r4], #2
						*p_read++ = w >> 8;
    2eec:	asrs	r1, r1, #8
    2eee:	strb	r1, [r2, #1]
    2ef0:	mov	r2, r4
					}
					count_read -= 2;
    2ef2:	subs	r3, #2
    2ef4:	b.n	2ece <SPIClass::transfer(void const*, void*, unsigned int)+0x19a>
    2ef6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2efa:	nop
    2efc:	.word	0x801f0400

00002f00 <SPIClass::dma_rxisr()>:


//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
    2f00:	push	{r4, r5, r6, lr}
    2f02:	ldr	r3, [r0, #56]	; 0x38
    2f04:	ldrb	r2, [r3, #4]
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    2f06:	ldr	r3, [pc, #192]	; (2fc8 <SPIClass::dma_rxisr()+0xc8>)
    2f08:	strb	r2, [r3, #0]
    2f0a:	ldr	r3, [r0, #52]	; 0x34
    2f0c:	ldrb	r2, [r3, #4]
	bool complete(void) {
		if (TCD->CSR & DMA_TCD_CSR_DONE) return true;
		return false;
	}
	void clearComplete(void) {
		DMA_CDNE = channel;
    2f0e:	ldr	r3, [pc, #188]	; (2fcc <SPIClass::dma_rxisr()+0xcc>)
    2f10:	strb	r2, [r3, #0]
    2f12:	ldr	r2, [r0, #56]	; 0x38
    2f14:	ldrb	r2, [r2, #4]
    2f16:	strb	r2, [r3, #0]
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
    2f18:	ldr	r2, [r0, #48]	; 0x30


//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
    2f1a:	mov	r4, r0
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
	if (_dma_count_remaining) {
    2f1c:	cmp	r2, #0
    2f1e:	beq.n	2fa0 <SPIClass::dma_rxisr()+0xa0>
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
    2f20:	ldr	r3, [r0, #4]
    2f22:	ldr	r1, [r3, #12]
    2f24:	cmp	r2, r1
    2f26:	bls.n	2f30 <SPIClass::dma_rxisr()+0x30>
			_dma_count_remaining -= hardware().max_dma_count;
    2f28:	subs	r2, r2, r1
    2f2a:	str	r2, [r0, #48]	; 0x30
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    2f2c:	movs	r1, #1
    2f2e:	b.n	2f52 <SPIClass::dma_rxisr()+0x52>
    2f30:	ldr	r3, [r0, #52]	; 0x34
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > hardware().max_dma_count) {
			_dma_count_remaining -= hardware().max_dma_count;
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
    2f32:	subs	r1, r2, #1
    2f34:	ldr	r0, [r3, #0]
    2f36:	bl	2ac4 <DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]>
    2f3a:	ldr	r3, [r4, #56]	; 0x38
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
    2f3c:	ldr	r1, [r4, #48]	; 0x30
    2f3e:	ldr	r0, [r3, #0]
    2f40:	bl	2ac4 <DMAChanneltransferCount(DMAChannel*, unsigned int) [clone .isra.9]>
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    2f44:	ldr	r1, [r4, #48]	; 0x30
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    2f46:	movs	r3, #0
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
	_dmaTX->clearComplete();
	_dmaRX->clearComplete();

	uint8_t should_reenable_tx = true;	// should we re-enable TX maybe not if count will be 0...
    2f48:	adds.w	r1, r1, #4294967295
    2f4c:	it	ne
    2f4e:	movne	r1, #1
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining-1);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
			if (_dma_count_remaining == 1) should_reenable_tx = false;

			_dma_count_remaining = 0;
    2f50:	str	r3, [r4, #48]	; 0x30
		}
		// In some cases we need to again start the TX manually to get it to work...
		if (_dmaTX->TCD->SADDR == &_transferWriteFill) {
    2f52:	ldr	r3, [r4, #52]	; 0x34
    2f54:	ldr	r3, [r3, #0]
    2f56:	ldr	r0, [r3, #0]
    2f58:	add.w	r2, r4, #44	; 0x2c
    2f5c:	cmp	r0, r2
    2f5e:	ldr	r2, [r4, #0]
    2f60:	bne.n	2f6e <SPIClass::dma_rxisr()+0x6e>
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    2f62:	ldr	r3, [r2, #12]
    2f64:	ldrb.w	r3, [r4, #44]	; 0x2c
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    2f68:	orr.w	r3, r3, #2147483648	; 0x80000000
    2f6c:	b.n	2f8c <SPIClass::dma_rxisr()+0x8c>
			} else  {
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
    2f6e:	ldr	r0, [r2, #12]
    2f70:	tst.w	r0, #1073741824	; 0x40000000
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    2f74:	ldr	r0, [r3, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    2f76:	itete	ne
    2f78:	ldrne	r5, [r3, #0]
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    2f7a:	ldreq	r5, [r3, #0]
				port().PUSHR = (_transferWriteFill | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
    2f7c:	ldrhne	r0, [r0, #0]
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
    2f7e:	ldrbeq	r0, [r0, #0]
			}
		} else {
			if (port().CTAR0  & SPI_CTAR_FMSZ(8)) {
				// 16 bit mode
				uint16_t w = *((uint16_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 2;
    2f80:	ite	ne
    2f82:	addne	r5, #2
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
			} else  {
				uint8_t w = *((uint8_t*)_dmaTX->TCD->SADDR);
				_dmaTX->TCD->SADDR = (volatile uint8_t*)(_dmaTX->TCD->SADDR) + 1;
    2f84:	addeq	r5, #1
    2f86:	str	r5, [r3, #0]
				port().PUSHR = (w | SPI_PUSHR_CTAS(0) | SPI_PUSHR_CONT);
    2f88:	orr.w	r3, r0, #2147483648	; 0x80000000
    2f8c:	str	r3, [r2, #52]	; 0x34
    2f8e:	ldr	r3, [r4, #56]	; 0x38
    2f90:	ldrb	r2, [r3, #4]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    2f92:	ldr	r3, [pc, #60]	; (2fd0 <SPIClass::dma_rxisr()+0xd0>)
    2f94:	strb	r2, [r3, #0]
			}
		}
		_dmaRX->enable();
		if (should_reenable_tx)
    2f96:	cbz	r1, 2fc4 <SPIClass::dma_rxisr()+0xc4>
    2f98:	ldr	r2, [r4, #52]	; 0x34
    2f9a:	ldrb	r2, [r2, #4]
    2f9c:	strb	r2, [r3, #0]
    2f9e:	pop	{r4, r5, r6, pc}
    2fa0:	ldr	r3, [r0, #0]
			_dmaTX->enable();
	} else {

		port().RSER = 0;
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    2fa2:	ldr	r1, [pc, #48]	; (2fd4 <SPIClass::dma_rxisr()+0xd4>)
		_dmaRX->enable();
		if (should_reenable_tx)
			_dmaTX->enable();
	} else {

		port().RSER = 0;
    2fa4:	str	r2, [r3, #48]	; 0x30
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
    2fa6:	str	r1, [r3, #44]	; 0x2c
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits
    2fa8:	ldr	r1, [r3, #12]
    2faa:	bic.w	r1, r1, #1073741824	; 0x40000000
    2fae:	str	r1, [r3, #12]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
    2fb0:	movs	r3, #3
    2fb2:	strb.w	r3, [r0, #45]	; 0x2d
		_dma_event_responder->triggerEvent();
    2fb6:	ldr	r0, [r0, #60]	; 0x3c
    2fb8:	ldr	r3, [r0, #0]
    2fba:	mov	r1, r2
    2fbc:	ldr	r3, [r3, #0]

	}
}
    2fbe:	ldmia.w	sp!, {r4, r5, r6, lr}
		//port().MCR = SPI_MCR_MSTR | SPI_MCR_CLR_RXF | SPI_MCR_PCSIS(0x1F);  // clear out the queue
		port().SR = 0xFF0F0000;
		port().CTAR0  &= ~(SPI_CTAR_FMSZ(8)); 	// Hack restore back to 8 bits

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
		_dma_event_responder->triggerEvent();
    2fc2:	bx	r3
    2fc4:	pop	{r4, r5, r6, pc}
    2fc6:	nop
    2fc8:	.word	0x4000801f
    2fcc:	.word	0x4000801c
    2fd0:	.word	0x4000801b
    2fd4:	.word	0xff0f0000

00002fd8 <_spi_dma_rxISR0()>:
};
SPIClass SPI((uintptr_t)&KINETISK_SPI0, (uintptr_t)&SPIClass::spi0_hardware);

#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
#ifdef SPI_HAS_TRANSFER_ASYNC
void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
    2fd8:	push	{r3, lr}
    2fda:	ldr	r0, [pc, #8]	; (2fe4 <_spi_dma_rxISR0()+0xc>)
    2fdc:	bl	2f00 <SPIClass::dma_rxisr()>
    2fe0:	pop	{r3, pc}
    2fe2:	nop
    2fe4:	.word	0x1fff131c

00002fe8 <SDClass::~SDClass()>:
	char *filename;
};



class SDClass : public FS
    2fe8:	bx	lr

00002fea <SDClass::exists(char const*)>:
		else if (mode == FILE_WRITE_BEGIN) flags = O_RDWR | O_CREAT;
		SDFAT_FILE file = sdfs.open(filepath, flags);
		if (file) return File(new SDFile(file));
		return File();
	}
	bool exists(const char *filepath) {
    2fea:	push	{lr}
    2fec:	mov	r2, r1
   * \param[in] path Path of the file to be tested for.
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
    2fee:	ldr.w	r1, [r0, #1156]	; 0x484
    2ff2:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->exists(path) : false;
    2ff4:	cbz	r1, 300c <SDClass::exists(char const*)+0x22>
    2ff6:	movs	r3, #0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    2ff8:	mov	r0, sp
    2ffa:	strb.w	r3, [sp]
    2ffe:	strb.w	r3, [sp, #1]
    3002:	strb.w	r3, [sp, #2]
    3006:	bl	6270 <FatFile::open(FatVolume*, char const*, int)>
    300a:	b.n	3028 <SDClass::exists(char const*)+0x3e>
    300c:	ldr.w	r0, [r0, #1160]	; 0x488
    3010:	cbz	r0, 3028 <SDClass::exists(char const*)+0x3e>
    3012:	strb.w	r1, [sp, #49]	; 0x31
    3016:	strb.w	r1, [sp, #50]	; 0x32
    301a:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    301e:	mov	r3, r1
    3020:	mov	r1, r0
    3022:	mov	r0, sp
    3024:	bl	472a <ExFatFile::open(ExFatVolume*, char const*, int)>
		return sdfs.exists(filepath);
	}
    3028:	add	sp, #60	; 0x3c
    302a:	ldr.w	pc, [sp], #4

0000302e <SDClass::rmdir(char const*)>:
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
    302e:	push	{lr}
    3030:	mov	r2, r1
   * The subdirectory file will be removed only if it is empty.
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char *path) {
    return m_fVol ? m_fVol->rmdir(path) :
    3032:	ldr.w	r1, [r0, #1156]	; 0x484
    3036:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->rmdir(path) : false;
    3038:	cbz	r1, 3058 <SDClass::rmdir(char const*)+0x2a>
    303a:	movs	r3, #0
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char* path) {
    FatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
    303c:	mov	r0, sp
    303e:	strb.w	r3, [sp]
    3042:	strb.w	r3, [sp, #1]
    3046:	strb.w	r3, [sp, #2]
    304a:	bl	6270 <FatFile::open(FatVolume*, char const*, int)>
    304e:	cbz	r0, 307c <SDClass::rmdir(char const*)+0x4e>
    3050:	mov	r0, sp
    3052:	bl	60e8 <FatFile::rmdir()>
    3056:	b.n	307c <SDClass::rmdir(char const*)+0x4e>
    3058:	ldr.w	r0, [r0, #1160]	; 0x488
    305c:	cbz	r0, 307c <SDClass::rmdir(char const*)+0x4e>
    305e:	strb.w	r1, [sp, #49]	; 0x31
    3062:	strb.w	r1, [sp, #50]	; 0x32
    3066:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char* path) {
    ExFatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
    306a:	mov	r3, r1
    306c:	mov	r1, r0
    306e:	mov	r0, sp
    3070:	bl	472a <ExFatFile::open(ExFatVolume*, char const*, int)>
    3074:	cbz	r0, 307c <SDClass::rmdir(char const*)+0x4e>
    3076:	mov	r0, sp
    3078:	bl	4d34 <ExFatFile::rmdir()>
		return sdfs.rmdir(filepath);
	}
    307c:	add	sp, #60	; 0x3c
    307e:	ldr.w	pc, [sp], #4

00003082 <SDClass::remove(char const*)>:
		return sdfs.mkdir(filepath);
	}
	bool rename(const char *oldfilepath, const char *newfilepath) {
		return sdfs.rename(oldfilepath, newfilepath);
	}
	bool remove(const char *filepath) {
    3082:	push	{lr}
    3084:	mov	r2, r1
  * \param[in] path A path with a valid 8.3 DOS name for the file.
  *
   * \return true for success or false for failure.
  */
  bool remove(const char *path) {
    return m_fVol ? m_fVol->remove(path) :
    3086:	ldr.w	r1, [r0, #1156]	; 0x484
    308a:	sub	sp, #60	; 0x3c
           m_xVol ? m_xVol->remove(path) : false;
    308c:	cbz	r1, 30ae <SDClass::remove(char const*)+0x2c>
    308e:	movs	r3, #0
    3090:	strb.w	r3, [sp]
    3094:	strb.w	r3, [sp, #1]
    3098:	strb.w	r3, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    309c:	mov	r0, sp
    309e:	movs	r3, #1
    30a0:	bl	6270 <FatFile::open(FatVolume*, char const*, int)>
    30a4:	cbz	r0, 30d2 <SDClass::remove(char const*)+0x50>
    30a6:	mov	r0, sp
    30a8:	bl	72e4 <FatFile::remove()>
    30ac:	b.n	30d2 <SDClass::remove(char const*)+0x50>
    30ae:	ldr.w	r0, [r0, #1160]	; 0x488
    30b2:	cbz	r0, 30d2 <SDClass::remove(char const*)+0x50>
    30b4:	strb.w	r1, [sp, #49]	; 0x31
    30b8:	strb.w	r1, [sp, #50]	; 0x32
    30bc:	strb.w	r1, [sp, #51]	; 0x33
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    30c0:	movs	r3, #1
    30c2:	mov	r1, r0
    30c4:	mov	r0, sp
    30c6:	bl	472a <ExFatFile::open(ExFatVolume*, char const*, int)>
    30ca:	cbz	r0, 30d2 <SDClass::remove(char const*)+0x50>
    30cc:	mov	r0, sp
    30ce:	bl	4cae <ExFatFile::remove()>
		return sdfs.remove(filepath);
	}
    30d2:	add	sp, #60	; 0x3c
    30d4:	ldr.w	pc, [sp], #4

000030d8 <SDClass::mkdir(char const*)>:
		return File();
	}
	bool exists(const char *filepath) {
		return sdfs.exists(filepath);
	}
	bool mkdir(const char *filepath) {
    30d8:	push	{r4, lr}
   * \param[in] pFlag Create missing parent directories if true.
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
    30da:	ldr.w	r4, [r0, #1156]	; 0x484
    30de:	sub	sp, #56	; 0x38
    30e0:	mov	r2, r1
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
    30e2:	cbz	r4, 3100 <SDClass::mkdir(char const*)+0x28>
    30e4:	movs	r3, #0
    30e6:	strb.w	r3, [sp]
    30ea:	strb.w	r3, [sp, #1]
    30ee:	strb.w	r3, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    30f2:	add.w	r1, r4, #1096	; 0x448
    30f6:	movs	r3, #1
    30f8:	mov	r0, sp
    30fa:	bl	63ec <FatFile::mkdir(FatFile*, char const*, bool)>
    30fe:	b.n	3122 <SDClass::mkdir(char const*)+0x4a>
    3100:	ldr.w	r1, [r0, #1160]	; 0x488
    3104:	cbz	r1, 3120 <SDClass::mkdir(char const*)+0x48>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    3106:	movs	r3, #1
    3108:	add.w	r1, r1, #1096	; 0x448
    310c:	mov	r0, sp
    310e:	strb.w	r4, [sp, #49]	; 0x31
    3112:	strb.w	r4, [sp, #50]	; 0x32
    3116:	strb.w	r4, [sp, #51]	; 0x33
    311a:	bl	4fcc <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
    311e:	b.n	3122 <SDClass::mkdir(char const*)+0x4a>
    3120:	mov	r0, r1
		return sdfs.mkdir(filepath);
	}
    3122:	add	sp, #56	; 0x38
    3124:	pop	{r4, pc}

00003126 <SDClass::rename(char const*, char const*)>:
	bool rename(const char *oldfilepath, const char *newfilepath) {
    3126:	push	{r4, r5, lr}
   * a file object that was opened before the rename() call.
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    return m_fVol ? m_fVol->rename(oldPath, newPath) :
    3128:	ldr.w	r3, [r0, #1156]	; 0x484
    312c:	sub	sp, #60	; 0x3c
    312e:	mov	r5, r2
           m_xVol ? m_xVol->rename(oldPath, newPath) : false;
    3130:	cbz	r3, 315e <SDClass::rename(char const*, char const*)+0x38>
    3132:	movs	r2, #0
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend FatFile;
  static FatVolume* cwv() {return m_cwv;}
  FatFile* vwd() {return &m_vwd;}
    3134:	add.w	r4, r3, #1096	; 0x448
    3138:	strb.w	r2, [sp]
    313c:	strb.w	r2, [sp, #1]
    3140:	strb.w	r2, [sp, #2]
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    FatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    3144:	mov	r3, r2
    3146:	mov	r0, sp
    3148:	mov	r2, r1
    314a:	mov	r1, r4
    314c:	bl	61c8 <FatFile::open(FatFile*, char const*, int)>
    3150:	cbz	r0, 318a <SDClass::rename(char const*, char const*)+0x64>
    3152:	mov	r2, r5
    3154:	mov	r1, r4
    3156:	mov	r0, sp
    3158:	bl	6496 <FatFile::rename(FatFile*, char const*)>
    315c:	b.n	318a <SDClass::rename(char const*, char const*)+0x64>
    315e:	ldr.w	r0, [r0, #1160]	; 0x488
    3162:	cbz	r0, 318a <SDClass::rename(char const*, char const*)+0x64>
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend ExFatFile;
  static ExFatVolume* cwv() {return m_cwv;}
  ExFatFile* vwd() {return &m_vwd;}
    3164:	add.w	r4, r0, #1096	; 0x448
   *
   * \return true for success or false for failure.
   */
  bool rename(const char* oldPath, const char* newPath) {
    ExFatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    3168:	mov	r2, r1
    316a:	mov	r0, sp
    316c:	mov	r1, r4
    316e:	strb.w	r3, [sp, #49]	; 0x31
    3172:	strb.w	r3, [sp, #50]	; 0x32
    3176:	strb.w	r3, [sp, #51]	; 0x33
    317a:	bl	4670 <ExFatFile::open(ExFatFile*, char const*, int)>
    317e:	cbz	r0, 318a <SDClass::rename(char const*, char const*)+0x64>
    3180:	mov	r2, r5
    3182:	mov	r1, r4
    3184:	mov	r0, sp
    3186:	bl	508a <ExFatFile::rename(ExFatFile*, char const*)>
		return sdfs.rename(oldfilepath, newfilepath);
	}
    318a:	add	sp, #60	; 0x3c
    318c:	pop	{r4, r5, pc}

0000318e <SDClass::totalSize()>:
	}
	uint64_t usedSize() {
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
		  * (uint64_t)sdfs.bytesPerCluster();
	}
	uint64_t totalSize() {
    318e:	mov	r3, r0
    3190:	push	{r4, lr}
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    3192:	ldr.w	r2, [r3, #1156]	; 0x484
		return (uint64_t)sdfs.clusterCount() * (uint64_t)sdfs.bytesPerCluster();
    3196:	adds	r0, #4
           m_xVol ? m_xVol->clusterCount() : 0;
    3198:	cbz	r2, 31a0 <SDClass::totalSize()+0x12>
    319a:	ldr	r4, [r2, #28]
    319c:	subs	r4, #1
    319e:	b.n	31aa <SDClass::totalSize()+0x1c>
    31a0:	ldr.w	r4, [r3, #1160]	; 0x488
    31a4:	cbz	r4, 31aa <SDClass::totalSize()+0x1c>
    31a6:	ldr.w	r4, [r4, #1072]	; 0x430
    31aa:	bl	198c <FsVolume::bytesPerCluster() const>
	}
    31ae:	umull	r0, r1, r4, r0
    31b2:	pop	{r4, pc}

000031b4 <SDClass::usedSize()>:
		return sdfs.remove(filepath);
	}
	bool rmdir(const char *filepath) {
		return sdfs.rmdir(filepath);
	}
	uint64_t usedSize() {
    31b4:	push	{r3, r4, r5, lr}
    31b6:	mov	r3, r0
		return (uint64_t)(sdfs.clusterCount() - sdfs.freeClusterCount())
    31b8:	adds	r5, r0, #4
  }
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
    31ba:	ldr.w	r0, [r0, #1156]	; 0x484
           m_xVol ? m_xVol->clusterCount() : 0;
    31be:	cbz	r0, 31ca <SDClass::usedSize()+0x16>
    31c0:	ldr	r4, [r0, #28]
    31c2:	subs	r4, #1
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
    31c4:	bl	6b08 <FatPartition::freeClusterCount()>
    31c8:	b.n	31dc <SDClass::usedSize()+0x28>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    31ca:	ldr.w	r0, [r3, #1160]	; 0x488
    31ce:	cbz	r0, 31da <SDClass::usedSize()+0x26>
    31d0:	ldr.w	r4, [r0, #1072]	; 0x430
           m_xVol ? m_xVol->fatType() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() const {
    return m_fVol ? m_fVol->freeClusterCount() :
           m_xVol ? m_xVol->freeClusterCount() : 0;
    31d4:	bl	4a2c <ExFatPartition::freeClusterCount()>
    31d8:	b.n	31dc <SDClass::usedSize()+0x28>
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    31da:	mov	r4, r0
    31dc:	subs	r4, r4, r0
		  * (uint64_t)sdfs.bytesPerCluster();
    31de:	mov	r0, r5
    31e0:	bl	198c <FsVolume::bytesPerCluster() const>
	}
    31e4:	umull	r0, r1, r4, r0
    31e8:	pop	{r3, r4, r5, pc}

000031ea <SdBase<FsVolume>::begin(SdioConfig)>:
  /** Initialize SD card and file system for SDIO mode.
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    31ea:	push	{r3, r4, r5, lr}
   * \param[in] config SDIO configuration.
   * \return generic card pointer or nullptr if SDIO is not supported.
   */
  SdCard* newCard(SdioConfig config) {
#if HAS_SDIO_CLASS
    m_sdioCard.begin(config);
    31ec:	add.w	r5, r0, #1168	; 0x490
    31f0:	mov	r4, r0
    spiConfigBackupPin = 255;
    31f2:	movs	r3, #255	; 0xff
    31f4:	strb.w	r3, [r0, #1200]	; 0x4b0
    sdioConfigBackup = sdioConfig;
    31f8:	strb.w	r1, [r0, #1212]	; 0x4bc
    31fc:	mov	r0, r5
    31fe:	bl	87d4 <SdioCard::begin(SdioConfig)>
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdioConfig sdioConfig) {
    m_card = m_cardFactory.newCard(sdioConfig);
    3202:	str.w	r5, [r4, #1164]	; 0x48c
    return m_card && !m_card->errorCode();
    3206:	mov	r0, r5
    3208:	bl	7fc0 <SdioCard::errorCode() const>
    320c:	cbnz	r0, 321c <SdBase<FsVolume>::begin(SdioConfig)+0x32>
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
    320e:	ldr.w	r1, [r4, #1164]	; 0x48c
    3212:	mov	r0, r4
  }
    3214:	ldmia.w	sp!, {r3, r4, r5, lr}
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    spiConfigBackupPin = 255;
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
    3218:	b.w	74fc <FsVolume::begin(BlockDeviceInterface*)>
  }
    321c:	movs	r0, #0
    321e:	pop	{r3, r4, r5, pc}

00003220 <SdBase<FsVolume>::cardBegin(SdSpiConfig)>:
  /** Initialize SD card in SPI mode.
   *
   * \param[in] spiConfig SPI configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdSpiConfig spiConfig) {
    3220:	push	{r4, r5, r6, lr}
    3222:	sub	sp, #32
    3224:	mov	r6, r0
    3226:	add	r0, sp, #4
    3228:	stmia.w	r0, {r1, r2, r3}
    322c:	ldmia	r0, {r0, r1, r2}
    322e:	add	r5, sp, #20
    3230:	stmia.w	r5, {r0, r1, r3}
   *
   * \param[in] config SPI configuration.
   * \return generic card pointer.
   */
  SdCard* newCard(SdSpiConfig config) {
    m_spiCard.begin(config);
    3234:	addw	r4, r6, #1180	; 0x49c
    3238:	ldmia.w	r5, {r1, r2, r3}
    323c:	mov	r0, r4
    323e:	bl	7930 <SdSpiCard::begin(SdSpiConfig)>
    m_card = m_cardFactory.newCard(spiConfig);
    3242:	str.w	r4, [r6, #1164]	; 0x48c
    return m_card && !m_card->errorCode();
    3246:	cbz	r4, 3254 <SdBase<FsVolume>::cardBegin(SdSpiConfig)+0x34>
    3248:	ldrb.w	r0, [r6, #1195]	; 0x4ab
    324c:	clz	r0, r0
    3250:	lsrs	r0, r0, #5
    3252:	b.n	3256 <SdBase<FsVolume>::cardBegin(SdSpiConfig)+0x36>
    3254:	mov	r0, r4
  }
    3256:	add	sp, #32
    3258:	pop	{r4, r5, r6, pc}

0000325a <SdBase<FsVolume>::restart()>:
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
  }
  //----------------------------------------------------------------------------
  /** Restart library with same config, used after media removed and replaced */
  bool restart() {
    325a:	push	{r4, r5, lr}
    if (spiConfigBackupPin == 255) {
    325c:	ldrb.w	r3, [r0, #1200]	; 0x4b0
    3260:	cmp	r3, #255	; 0xff
    sdioConfigBackup = sdioConfig;
    return cardBegin(sdioConfig) && Vol::begin(m_card);
  }
  //----------------------------------------------------------------------------
  /** Restart library with same config, used after media removed and replaced */
  bool restart() {
    3262:	sub	sp, #20
    3264:	mov	r4, r0
    if (spiConfigBackupPin == 255) {
    3266:	bne.n	3272 <SdBase<FsVolume>::restart()+0x18>
      return begin(sdioConfigBackup);
    3268:	ldrb.w	r1, [r0, #1212]	; 0x4bc
    326c:	bl	31ea <SdBase<FsVolume>::begin(SdioConfig)>
    3270:	b.n	32a6 <SdBase<FsVolume>::restart()+0x4c>
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
    3272:	ldr.w	r1, [r0, #1204]	; 0x4b4
    3276:	ldr.w	r2, [r0, #1208]	; 0x4b8
    327a:	ldrb.w	r5, [r0, #1201]	; 0x4b1
    327e:	strb.w	r3, [sp, #4]
    3282:	strb.w	r5, [sp, #5]
    3286:	str	r1, [sp, #8]
    3288:	str	r2, [sp, #12]
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    328a:	add	r3, sp, #16
    328c:	ldmdb	r3, {r1, r2, r3}
    3290:	bl	3220 <SdBase<FsVolume>::cardBegin(SdSpiConfig)>
    3294:	cbz	r0, 32a6 <SdBase<FsVolume>::restart()+0x4c>
    3296:	ldr.w	r1, [r4, #1164]	; 0x48c
    329a:	mov	r0, r4
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
      return begin(spiConfig);
    }
  }
    329c:	add	sp, #20
    329e:	ldmia.w	sp!, {r4, r5, lr}
  bool begin(SdSpiConfig spiConfig) {
    spiConfigBackupPin = spiConfig.csPin;
    spiConfigBackupOptions = spiConfig.options;
    spiConfigBackupClock = spiConfig.maxSck;
    spiConfigBackupPort = spiConfig.spiPort;
    return cardBegin(spiConfig) && Vol::begin(m_card);
    32a2:	b.w	74fc <FsVolume::begin(BlockDeviceInterface*)>
    } else {
      SdSpiConfig spiConfig(spiConfigBackupPin, spiConfigBackupOptions,
                            spiConfigBackupClock, spiConfigBackupPort);
      return begin(spiConfig);
    }
  }
    32a6:	add	sp, #20
    32a8:	pop	{r4, r5, pc}

000032aa <SDClass::format(int, char, Print&)>:
	}
}
#endif

bool SDClass::format(int type, char progressChar, Print& pr)
{
    32aa:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    32ae:	ldr.w	r4, [r0, #1168]	; 0x490
    32b2:	sub	sp, #48	; 0x30
    32b4:	mov	r6, r0
    32b6:	mov	r7, r3
	SdCard *card = sdfs.card();
	if (!card) return false; // no SD card
    32b8:	cbnz	r4, 32be <SDClass::format(int, char, Print&)+0x14>
    32ba:	movs	r0, #0
    32bc:	b.n	3308 <SDClass::format(int, char, Print&)+0x5e>
	uint32_t sectors = card->sectorCount();
    32be:	ldr	r3, [r4, #0]
    32c0:	mov	r0, r4
    32c2:	ldr	r3, [r3, #24]
    32c4:	blx	r3
	if (sectors <= 12288) return false; // card too small
    32c6:	cmp.w	r0, #12288	; 0x3000

bool SDClass::format(int type, char progressChar, Print& pr)
{
	SdCard *card = sdfs.card();
	if (!card) return false; // no SD card
	uint32_t sectors = card->sectorCount();
    32ca:	mov	r8, r0
	if (sectors <= 12288) return false; // card too small
    32cc:	bls.n	32ba <SDClass::format(int, char, Print&)+0x10>
	uint8_t *buf = (uint8_t *)malloc(512);
    32ce:	mov.w	r0, #512	; 0x200
    32d2:	bl	b21c <malloc>
	if (!buf) return false; // unable to allocate memory
    32d6:	mov	r5, r0
    32d8:	cmp	r0, #0
    32da:	beq.n	32ba <SDClass::format(int, char, Print&)+0x10>
	bool ret;
	if (sectors > 67108864) {
    32dc:	cmp.w	r8, #67108864	; 0x4000000
#ifdef __arm__
		ExFatFormatter exFatFormatter;
		ret = exFatFormatter.format(card, buf, &pr);
    32e0:	mov	r2, r0
    32e2:	mov	r3, r7
    32e4:	mov	r1, r4
    32e6:	add	r0, sp, #4
	uint32_t sectors = card->sectorCount();
	if (sectors <= 12288) return false; // card too small
	uint8_t *buf = (uint8_t *)malloc(512);
	if (!buf) return false; // unable to allocate memory
	bool ret;
	if (sectors > 67108864) {
    32e8:	bls.n	32f0 <SDClass::format(int, char, Print&)+0x46>
#ifdef __arm__
		ExFatFormatter exFatFormatter;
		ret = exFatFormatter.format(card, buf, &pr);
    32ea:	bl	39bc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>
    32ee:	b.n	32f4 <SDClass::format(int, char, Print&)+0x4a>
#else
		ret = false;
#endif
	} else {
		FatFormatter fatFormatter;
		ret = fatFormatter.format(card, buf, &pr);
    32f0:	bl	5944 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>
    32f4:	mov	r4, r0
	}
	free(buf);
    32f6:	mov	r0, r5
    32f8:	bl	b22c <free>
	if (ret) {
    32fc:	cmp	r4, #0
    32fe:	beq.n	32ba <SDClass::format(int, char, Print&)+0x10>
		// TODO: Is begin() really necessary?  Is a quicker way possible?
		sdfs.restart(); // TODO: is sdfs.volumeBegin() enough??
    3300:	adds	r0, r6, #4
    3302:	bl	325a <SdBase<FsVolume>::restart()>
    3306:	movs	r0, #1
	}
	return ret;
}
    3308:	add	sp, #48	; 0x30
    330a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000330e <SDClass::mediaPresent()>:
	}
	return false;
}

bool SDClass::mediaPresent()
{
    330e:	push	{r4, r5, lr}
    3310:	ldr.w	r4, [r0, #1168]	; 0x490
    3314:	sub	sp, #20
    3316:	mov	r5, r0
	//Serial.print("mediaPresent: ");
	bool ret;
	SdCard *card = sdfs.card();
	if (card) {
    3318:	cbz	r4, 3358 <SDClass::mediaPresent()+0x4a>
		if (cardPreviouslyPresent) {
    331a:	ldrb.w	r3, [r0, #1220]	; 0x4c4
    331e:	cbz	r3, 3350 <SDClass::mediaPresent()+0x42>
			#ifdef BUILTIN_SDCARD
			uint32_t s;
			if (csPin_ == BUILTIN_SDCARD) {
    3320:	ldrb.w	r3, [r0, #1221]	; 0x4c5
    3324:	cmp	r3, #254	; 0xfe
    3326:	beq.n	3334 <SDClass::mediaPresent()+0x26>
			const uint32_t s = 0xFFFFFFFF;
			#endif
			if (s == 0xFFFFFFFF) {
				// SPI doesn't have 32 bit status, read CID register
				cid_t cid;
				ret = card->readCID(&cid);
    3328:	ldr	r3, [r4, #0]
    332a:	mov	r1, sp
    332c:	ldr	r3, [r3, #56]	; 0x38
    332e:	mov	r0, r4
    3330:	blx	r3
    3332:	b.n	335a <SDClass::mediaPresent()+0x4c>
		if (cardPreviouslyPresent) {
			#ifdef BUILTIN_SDCARD
			uint32_t s;
			if (csPin_ == BUILTIN_SDCARD) {
				#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
				card->syncDevice();
    3334:	ldr	r3, [r4, #0]
    3336:	mov	r0, r4
    3338:	ldr	r3, [r3, #28]
    333a:	blx	r3
				#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
				s = card->status();
    333c:	ldr	r3, [r4, #0]
    333e:	mov	r0, r4
    3340:	ldr	r3, [r3, #68]	; 0x44
    3342:	blx	r3
			} else s = 0xFFFFFFFF;
			#else
			const uint32_t s = 0xFFFFFFFF;
			#endif
			if (s == 0xFFFFFFFF) {
    3344:	adds	r3, r0, #1
    3346:	beq.n	3328 <SDClass::mediaPresent()+0x1a>
				// SPI doesn't have 32 bit status, read CID register
				cid_t cid;
				ret = card->readCID(&cid);
				//Serial.print(ret ? "CID=ok" : "CID=unreadable");
			} else if (s == 0) {
    3348:	adds	r0, #0
    334a:	it	ne
    334c:	movne	r0, #1
    334e:	b.n	335a <SDClass::mediaPresent()+0x4c>
			if ((csPin_ == BUILTIN_SDCARD) && !digitalReadFast(_SD_DAT3))
				ret = false;
			else
			#endif
			{
				ret = sdfs.restart();
    3350:	adds	r0, #4
    3352:	bl	325a <SdBase<FsVolume>::restart()>
    3356:	b.n	335a <SDClass::mediaPresent()+0x4c>
			}
			//Serial.print(ret ? "begin ok" : "begin nope");
		}
	} else {
		//Serial.print("no card");
		ret = false;
    3358:	mov	r0, r4
	}
	//Serial.println();
	cardPreviouslyPresent = ret;
    335a:	strb.w	r0, [r5, #1220]	; 0x4c4
	return ret;
}
    335e:	add	sp, #20
    3360:	pop	{r4, r5, pc}
    3362:	Address 0x00003362 is out of bounds.


00003364 <_GLOBAL__sub_I_SD>:


class SDClass : public FS
{
public:
	SDClass() { }
    3364:	ldr	r0, [pc, #72]	; (33b0 <_GLOBAL__sub_I_SD+0x4c>)
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    3366:	ldr	r2, [pc, #76]	; (33b4 <_GLOBAL__sub_I_SD+0x50>)
    3368:	str.w	r2, [r0, #1172]	; 0x494
    336c:	ldr	r2, [pc, #72]	; (33b8 <_GLOBAL__sub_I_SD+0x54>)
    336e:	ldr	r3, [pc, #76]	; (33bc <_GLOBAL__sub_I_SD+0x58>)
    3370:	str.w	r2, [r0, #1184]	; 0x4a0
    3374:	movs	r2, #1
    3376:	str	r3, [r0, #0]
    3378:	strb.w	r2, [r0, #1197]	; 0x4ad
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() {}
    337c:	movs	r3, #0
    337e:	movs	r2, #41	; 0x29
    3380:	str.w	r3, [r0, #1156]	; 0x484
    3384:	str.w	r3, [r0, #1160]	; 0x488
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    3388:	strb.w	r3, [r0, #1180]	; 0x49c
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    338c:	strb.w	r3, [r0, #1181]	; 0x49d
    3390:	strb.w	r2, [r0, #1199]	; 0x4af
    3394:	strb.w	r3, [r0, #1202]	; 0x4b2
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() {}
    3398:	strb.w	r3, [r0, #1216]	; 0x4c0
    339c:	strb.w	r3, [r0, #1220]	; 0x4c4
 */

#include <Arduino.h>
#include <SD.h>

SDClass SD;
    33a0:	ldr	r2, [pc, #28]	; (33c0 <_GLOBAL__sub_I_SD+0x5c>)
    33a2:	ldr	r1, [pc, #32]	; (33c4 <_GLOBAL__sub_I_SD+0x60>)
    33a4:	movs	r3, #255	; 0xff
    33a6:	strb.w	r3, [r0, #1221]	; 0x4c5
    33aa:	b.w	a428 <__aeabi_atexit>
    33ae:	nop
    33b0:	.word	0x2001c9ec
    33b4:	.word	0x00012d28
    33b8:	.word	0x00012cc8
    33bc:	.word	0x000129c8
    33c0:	.word	0x1fff0f30
    33c4:	.word	0x00002fe9

000033c8 <FsUtf::cpToMb(unsigned long, char*, char*)>:
#include "FsUtf.h"
namespace FsUtf {
  //----------------------------------------------------------------------------
  char* cpToMb(uint32_t cp, char* str, char* end) {
    size_t n = end - str;
    if (cp < 0X80) {
    33c8:	cmp	r0, #127	; 0x7f
 */
#include "FsUtf.h"
namespace FsUtf {
  //----------------------------------------------------------------------------
  char* cpToMb(uint32_t cp, char* str, char* end) {
    size_t n = end - str;
    33ca:	sub.w	r2, r2, r1
    if (cp < 0X80) {
    33ce:	bhi.n	33da <FsUtf::cpToMb(unsigned long, char*, char*)+0x12>
      if (n < 1) goto fail;
    33d0:	cmp	r2, #0
    33d2:	beq.n	3454 <FsUtf::cpToMb(unsigned long, char*, char*)+0x8c>
      *(str++) = static_cast<uint8_t>(cp);
    33d4:	strb	r0, [r1, #0]
    33d6:	adds	r0, r1, #1
    33d8:	bx	lr
    } else if (cp < 0X800) {
    33da:	cmp.w	r0, #2048	; 0x800
    33de:	bcs.n	33fc <FsUtf::cpToMb(unsigned long, char*, char*)+0x34>
      if (n < 2) goto fail;
    33e0:	cmp	r2, #1
    33e2:	bls.n	3458 <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    33e4:	lsrs	r3, r0, #6
    33e6:	mov	r2, r1
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    33e8:	and.w	r0, r0, #63	; 0x3f
    if (cp < 0X80) {
      if (n < 1) goto fail;
      *(str++) = static_cast<uint8_t>(cp);
    } else if (cp < 0X800) {
      if (n < 2) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    33ec:	orn	r3, r3, #63	; 0x3f
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    33f0:	orn	r0, r0, #127	; 0x7f
    if (cp < 0X80) {
      if (n < 1) goto fail;
      *(str++) = static_cast<uint8_t>(cp);
    } else if (cp < 0X800) {
      if (n < 2) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
    33f4:	strb.w	r3, [r2], #2
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    33f8:	strb	r0, [r1, #1]
    33fa:	b.n	3454 <FsUtf::cpToMb(unsigned long, char*, char*)+0x8c>
    } else if (cp < 0X10000) {
    33fc:	cmp.w	r0, #65536	; 0x10000
    3400:	bcs.n	3426 <FsUtf::cpToMb(unsigned long, char*, char*)+0x5e>
      if (n < 3) goto fail;
    3402:	cmp	r2, #2
    3404:	bls.n	3458 <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 12)         | 0XE0);
    3406:	lsrs	r3, r0, #12
    3408:	orn	r3, r3, #31
    340c:	strb	r3, [r1, #0]
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    340e:	ubfx	r3, r0, #6, #6
    3412:	orn	r3, r3, #127	; 0x7f
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    3416:	and.w	r0, r0, #63	; 0x3f
      *(str++) = static_cast<uint8_t>((cp >> 6)          | 0XC0);
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    } else if (cp < 0X10000) {
      if (n < 3) goto fail;
      *(str++) = static_cast<uint8_t>((cp >> 12)         | 0XE0);
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    341a:	strb	r3, [r1, #1]
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    341c:	orn	r3, r0, #127	; 0x7f
    3420:	strb	r3, [r1, #2]
    3422:	adds	r0, r1, #3
    3424:	bx	lr
    } else {
       if (n < 4) goto fail;
    3426:	cmp	r2, #3
    3428:	bls.n	3458 <FsUtf::cpToMb(unsigned long, char*, char*)+0x90>
      *(str++) = static_cast<uint8_t>((cp >> 18)         | 0XF0);
    342a:	lsrs	r3, r0, #18
    342c:	orn	r3, r3, #15
    3430:	strb	r3, [r1, #0]
      *(str++) = static_cast<uint8_t>(((cp >> 12) & 0X3F)| 0X80);
    3432:	ubfx	r3, r0, #12, #6
    3436:	orn	r3, r3, #127	; 0x7f
    343a:	strb	r3, [r1, #1]
      *(str++) = static_cast<uint8_t>(((cp >> 6) & 0X3F) | 0X80);
    343c:	ubfx	r3, r0, #6, #6
    3440:	orn	r3, r3, #127	; 0x7f
    3444:	strb	r3, [r1, #2]
      *(str++) = static_cast<uint8_t>((cp & 0X3F)        | 0X80);
    3446:	and.w	r3, r0, #63	; 0x3f
    344a:	orn	r3, r3, #127	; 0x7f
    344e:	strb	r3, [r1, #3]
    3450:	adds	r0, r1, #4
    3452:	bx	lr
    }
    return str;

   fail:
    return nullptr;
    3454:	mov	r0, r2
    3456:	bx	lr
    3458:	movs	r0, #0
  }
    345a:	bx	lr

0000345c <FsUtf::mbToCp(char const*, char const*, unsigned long*)>:
  //----------------------------------------------------------------------------
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    size_t n;
    uint32_t cp;
    if (str >= end) {
    345c:	cmp	r0, r1
   fail:
    return nullptr;
  }
  //----------------------------------------------------------------------------
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    345e:	push	{r4, r5, lr}
    size_t n;
    uint32_t cp;
    if (str >= end) {
    3460:	bcs.n	34d0 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
      return nullptr;
    }
    uint8_t ch = str[0];
    3462:	ldrb	r3, [r0, #0]
    if ((ch & 0X80) == 0) {
    3464:	lsls	r4, r3, #24
    3466:	bmi.n	346e <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x12>
      *rtn = ch;
    3468:	str	r3, [r2, #0]
      return str + 1;
    346a:	adds	r4, r0, #1
    346c:	b.n	34d6 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x7a>
    }
    if ((ch & 0XE0) == 0XC0) {
    346e:	and.w	r4, r3, #224	; 0xe0
    3472:	cmp	r4, #192	; 0xc0
    3474:	bne.n	347e <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x22>
      cp = ch & 0X1F;
    3476:	and.w	r3, r3, #31
      n = 2;
    347a:	movs	r4, #2
    347c:	b.n	349c <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x40>
    } else if ((ch & 0XF0) == 0XE0) {
    347e:	and.w	r4, r3, #240	; 0xf0
    3482:	cmp	r4, #224	; 0xe0
    3484:	bne.n	348e <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x32>
      cp = ch & 0X0F;
    3486:	and.w	r3, r3, #15
      n = 3;
    348a:	movs	r4, #3
    348c:	b.n	349c <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x40>
    } else if ((ch & 0XF8) == 0XF0) {
    348e:	and.w	r4, r3, #248	; 0xf8
    3492:	cmp	r4, #240	; 0xf0
    3494:	bne.n	34d0 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
      cp = ch & 0X07;
    3496:	and.w	r3, r3, #7
      n = 4;
    349a:	movs	r4, #4
    } else {
      return nullptr;
    }
    if ((str + n) > end) {
    349c:	add	r4, r0
    349e:	cmp	r1, r4
    34a0:	bcc.n	34d0 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
    34a2:	adds	r0, #1
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
      ch = str[i];
    34a4:	ldrb.w	r1, [r0], #1
      if ((ch & 0XC0) != 0X80) {
    34a8:	and.w	r5, r1, #192	; 0xc0
    34ac:	cmp	r5, #128	; 0x80
    34ae:	bne.n	34d0 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
        return nullptr;
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    34b0:	and.w	r1, r1, #63	; 0x3f
      return nullptr;
    }
    if ((str + n) > end) {
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
    34b4:	cmp	r0, r4
      ch = str[i];
      if ((ch & 0XC0) != 0X80) {
        return nullptr;
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    34b6:	orr.w	r3, r1, r3, lsl #6
      return nullptr;
    }
    if ((str + n) > end) {
      return nullptr;
    }
    for (size_t i = 1; i < n; i++) {
    34ba:	bne.n	34a4 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x48>
      }
      cp <<= 6;
      cp |= ch & 0X3F;
    }
    // Don't allow over long as ASCII.
    if (cp < 0X80 || !isValidCp(cp)) {
    34bc:	ldr	r1, [pc, #28]	; (34dc <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x80>)
    34be:	sub.w	r0, r3, #128	; 0x80
    34c2:	cmp	r0, r1
    34c4:	bhi.n	34d0 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x74>
  /** Check for a valid code point.
   * \param[in] cp code point.
   * \return true if valid else false.
   */
  inline bool isValidCp(uint32_t cp) {
    return cp <= 0x10FFFF && (cp < 0XD800 || cp > 0XDFFF);
    34c6:	sub.w	r1, r3, #55296	; 0xd800
    34ca:	cmp.w	r1, #2048	; 0x800
    34ce:	bcs.n	34d4 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x78>
  // to do?  improve error check
  const char* mbToCp(const char* str, const char* end, uint32_t* rtn) {
    size_t n;
    uint32_t cp;
    if (str >= end) {
      return nullptr;
    34d0:	movs	r4, #0
    34d2:	b.n	34d6 <FsUtf::mbToCp(char const*, char const*, unsigned long*)+0x7a>
    }
    // Don't allow over long as ASCII.
    if (cp < 0X80 || !isValidCp(cp)) {
      return nullptr;
    }
    *rtn = cp;
    34d4:	str	r3, [r2, #0]
    return str + n;
  }
    34d6:	mov	r0, r4
    34d8:	pop	{r4, r5, pc}
    34da:	nop
    34dc:	.word	0x0010ff7f

000034e0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>:
#include "FsGetPartitionInfo.h"
namespace FsGetPartitionInfo {
  static const uint8_t mbdpGuid[16] PROGMEM = {0xA2, 0xA0, 0xD0, 0xEB, 0xE5, 0xB9, 0x33, 0x44, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7};

  voltype_t getPartitionInfo(BlockDeviceInterface *blockDev, uint8_t part, uint8_t *secBuf,
      uint32_t *pfirstLBA, uint32_t *psectorCount, uint32_t *pmbrLBA, uint8_t *pmbrPart) {
    34e0:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    34e4:	add	r6, sp, #48	; 0x30
    34e6:	mov	r5, r0
    34e8:	mov	r4, r2
    34ea:	mov	sl, r3
    34ec:	ldmia.w	r6, {r6, r7, r8}
    uint32_t firstLBA;
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    34f0:	str	r1, [sp, #4]
    34f2:	cbnz	r1, 34f8 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x18>
    34f4:	movs	r0, #0
    34f6:	b.n	3680 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    34f8:	cmp.w	sl, #0
    34fc:	beq.n	34f4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    part--; // zero base it.

    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    34fe:	ldr	r3, [r0, #0]
    3500:	movs	r1, #0
    3502:	ldr	r3, [r3, #12]
    3504:	blx	r3
    3506:	cmp	r0, #0
    3508:	beq.n	34f4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    part--; // zero base it.
    350a:	ldr	r3, [sp, #4]
    350c:	add.w	r9, r3, #4294967295
    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    mbr = reinterpret_cast<MbrSector_t*>(secBuf);

    // First check for GPT vs MBR
    mp = &mbr->part[0];
    if (mp->type == 0xee) {
    3510:	ldrb.w	r3, [r4, #450]	; 0x1c2
    3514:	cmp	r3, #238	; 0xee
    uint32_t sectorCount;
    MbrSector_t *mbr;
    MbrPart_t *mp;

    if (!part || !pfirstLBA) return INVALID_VOL; // won't handle this here.
    part--; // zero base it.
    3516:	uxtb.w	r9, r9
    if (!blockDev->readSector(0, secBuf)) return INVALID_VOL;
    mbr = reinterpret_cast<MbrSector_t*>(secBuf);

    // First check for GPT vs MBR
    mp = &mbr->part[0];
    if (mp->type == 0xee) {
    351a:	bne.n	359c <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xbc>
      // This is a GPT initialized Disk assume validation done earlier.
      if (!blockDev->readSector(1, secBuf)) return INVALID_VOL; 
    351c:	ldr	r3, [r5, #0]
    351e:	mov	r2, r4
    3520:	ldr	r3, [r3, #12]
    3522:	movs	r1, #1
    3524:	mov	r0, r5
    3526:	blx	r3
    3528:	cmp	r0, #0
    352a:	beq.n	34f4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      GPTPartitionHeader_t* gptph = reinterpret_cast<GPTPartitionHeader_t*>(secBuf);
      // Lets do a little validation of this data.
      if (!gptph || (memcmp(gptph->signature, F("EFI PART"), 8) != 0))  return INVALID_VOL;
    352c:	movs	r2, #8
    352e:	ldr	r1, [pc, #344]	; (3688 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a8>)
    3530:	mov	r0, r4
    3532:	bl	b880 <memcmp>
    3536:	cmp	r0, #0
    3538:	bne.n	34f4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      uint32_t numberPartitions = getLe32(gptph->numberPartitions);
      if (part > numberPartitions)  return INVALID_VOL;
    353a:	ldr	r3, [r4, #80]	; 0x50
    353c:	cmp	r9, r3
    353e:	bhi.n	34f4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>

      // We will overload the mbr part to give clue where GPT data is stored for this volume
      uint32_t mbrLBA = 2 + (part >> 2);
    3540:	mov.w	r1, r9, asr #2
    3544:	adds	r1, #2
      uint8_t mbrPart = part & 0x3;
    3546:	and.w	r9, r9, #3
      if (pmbrLBA) *pmbrLBA = mbrLBA;
    354a:	cbz	r7, 354e <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x6e>
    354c:	str	r1, [r7, #0]
      if (pmbrPart) *pmbrPart =mbrPart;
    354e:	cmp.w	r8, #0
    3552:	beq.n	3558 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x78>
    3554:	strb.w	r9, [r8]
      if (!blockDev->readSector(mbrLBA, secBuf)) return INVALID_VOL; 
    3558:	ldr	r3, [r5, #0]
    355a:	mov	r2, r4
    355c:	ldr	r3, [r3, #12]
    355e:	mov	r0, r5
    3560:	blx	r3
    3562:	cmp	r0, #0
    3564:	beq.n	34f4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      GPTPartitionEntrySector_t *gptes = reinterpret_cast<GPTPartitionEntrySector_t*>(secBuf);
      GPTPartitionEntryItem_t *gptei = &gptes->items[mbrPart];

      // Mow extract the data...
      firstLBA = getLe64(gptei->firstLBA);
    3566:	mov.w	r0, r9, lsl #7
    356a:	add.w	r3, r0, #32
    356e:	ldr	r2, [r4, r3]
      sectorCount = 1 + getLe64(gptei->lastLBA) - getLe64(gptei->firstLBA);
    3570:	add.w	r3, r0, #40	; 0x28
    3574:	ldr	r3, [r4, r3]
    3576:	adds	r3, #1
    3578:	subs	r3, r3, r2
      if ((firstLBA == 0) && (sectorCount == 1)) return INVALID_VOL;
    357a:	cbnz	r2, 3580 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xa0>
    357c:	cmp	r3, #1
    357e:	beq.n	34f4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      
      *pfirstLBA = firstLBA;
    3580:	str.w	r2, [sl]
      if (psectorCount) *psectorCount = sectorCount;
    3584:	cbz	r6, 3588 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xa8>
    3586:	str	r3, [r6, #0]

      if (memcmp((uint8_t *)gptei->partitionTypeGUID, mbdpGuid, 16) != 0) return OTHER_VOL;
    3588:	movs	r2, #16
    358a:	ldr	r1, [pc, #256]	; (368c <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1ac>)
    358c:	add	r0, r4
    358e:	bl	b880 <memcmp>
    3592:	cmp	r0, #0
    3594:	ite	eq
    3596:	moveq	r0, #3
    3598:	movne	r0, #4
    359a:	b.n	3680 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    }
    // So we are now looking a MBR type setups. 
    // Extended support we need to walk through the partitions to see if there is an extended partition
    // that we need to walk into. 
    // short cut:
    if (part < 4) {
    359c:	cmp.w	r9, #3
    35a0:	bhi.n	35e2 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
      // try quick way through
      mp = &mbr->part[part];
      if (((mp->boot == 0) || (mp->boot == 0X80)) && (mp->type != 0) && (mp->type != 0xf)) {
    35a2:	add.w	r3, r4, r9, lsl #4
    35a6:	ldrb.w	r2, [r3, #446]	; 0x1be
    35aa:	lsls	r2, r2, #25
    35ac:	bne.n	35e2 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
    35ae:	ldrb.w	r3, [r3, #450]	; 0x1c2
    35b2:	cbz	r3, 35e2 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
    35b4:	cmp	r3, #15
    35b6:	beq.n	35e2 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x102>
        *pfirstLBA = getLe32(mp->relativeSectors);
    35b8:	add.w	r3, r9, #28
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    35bc:	add.w	r4, r4, r3, lsl #4
    35c0:	ldr.w	r3, [r4, #6]
    35c4:	str.w	r3, [sl]
        if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
    35c8:	cbz	r6, 35d0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xf0>
    35ca:	ldr.w	r3, [r4, #10]
    35ce:	str	r3, [r6, #0]
        if (pmbrLBA) *pmbrLBA = 0;
    35d0:	cbz	r7, 35d6 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0xf6>
    35d2:	movs	r3, #0
    35d4:	str	r3, [r7, #0]
        if (pmbrPart) *pmbrPart = part; // zero based. 
    35d6:	cmp.w	r8, #0
    35da:	beq.n	3610 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x130>
    35dc:	strb.w	r9, [r8]
    35e0:	b.n	3610 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x130>
    35e2:	mov	r1, r4
#include "FsGetPartitionInfo.h"
namespace FsGetPartitionInfo {
  static const uint8_t mbdpGuid[16] PROGMEM = {0xA2, 0xA0, 0xD0, 0xEB, 0xE5, 0xB9, 0x33, 0x44, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7};

  voltype_t getPartitionInfo(BlockDeviceInterface *blockDev, uint8_t part, uint8_t *secBuf,
      uint32_t *pfirstLBA, uint32_t *psectorCount, uint32_t *pmbrLBA, uint8_t *pmbrPart) {
    35e4:	movs	r3, #0

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
      mp = &mbr->part[index_part];
      if ((mp->boot != 0 && mp->boot != 0X80) || mp->type == 0 || index_part > part) return INVALID_VOL;
    35e6:	ldrb.w	r0, [r1, #446]	; 0x1be
    35ea:	lsls	r0, r0, #25
    35ec:	uxtb	r2, r3
    35ee:	bne.n	34f4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    35f0:	ldrb.w	r0, [r1, #450]	; 0x1c2
    35f4:	cmp	r0, #0
    35f6:	beq.w	34f4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    35fa:	cmp	r9, r2
    35fc:	bcc.w	34f4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      if (mp->type == 0xf) break;
    3600:	cmp	r0, #15
    3602:	beq.n	3614 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x134>
    3604:	adds	r3, #1
      }
    }  

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
    3606:	cmp	r3, #4
    3608:	add.w	r1, r1, #16
    360c:	bne.n	35e6 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x106>
    360e:	b.n	34f4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      if (((mp->boot == 0) || (mp->boot == 0X80)) && (mp->type != 0) && (mp->type != 0xf)) {
        *pfirstLBA = getLe32(mp->relativeSectors);
        if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
        if (pmbrLBA) *pmbrLBA = 0;
        if (pmbrPart) *pmbrPart = part; // zero based. 
        return MBR_VOL;
    3610:	movs	r0, #1
    3612:	b.n	3680 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x1a0>
    }  

    // So must be extended or invalid.
    uint8_t index_part;
    for (index_part = 0; index_part < 4; index_part++) {
      mp = &mbr->part[index_part];
    3614:	add.w	r3, r4, r3, lsl #4
    3618:	adds	r2, #1
    361a:	ldr.w	r9, [r3, #454]	; 0x1c6
    361e:	uxtb.w	fp, r2
    if (index_part == 4) return INVALID_VOL; // no extended partition found. 

    // Our partition if it exists is in extended partition. 
    uint32_t next_mbr = getLe32(mp->relativeSectors);
    for(;;) {
      if (!blockDev->readSector(next_mbr, secBuf)) return INVALID_VOL;
    3622:	ldr	r3, [r5, #0]
    3624:	mov	r2, r4
    3626:	ldr	r3, [r3, #12]
    3628:	mov	r1, r9
    362a:	mov	r0, r5
    362c:	blx	r3
    362e:	cmp	r0, #0
    3630:	beq.w	34f4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
      mbr = reinterpret_cast<MbrSector_t*>(secBuf);

      if (index_part == part) break; // should be at that entry
    3634:	ldr	r3, [sp, #4]
    3636:	cmp	r3, fp
    3638:	beq.n	365a <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x17a>
      // else we need to see if it points to others...
      mp = &mbr->part[1];
      uint32_t  relSec = getLe32(mp->relativeSectors);
      //Serial.printf("    Check for next: type: %u start:%u\n ", mp->type, volumeStartSector);
      if ((mp->type == 5) && relSec) {
    363a:	ldrb.w	r2, [r4, #466]	; 0x1d2
    363e:	ldr.w	r3, [r4, #470]	; 0x1d6
    3642:	cmp	r2, #5
    3644:	bne.w	34f4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
    3648:	add.w	r2, fp, #1
    364c:	uxtb.w	fp, r2
    3650:	cmp	r3, #0
    3652:	beq.w	34f4 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x14>
        next_mbr = next_mbr + relSec;
    3656:	add	r9, r3

    if (index_part == 4) return INVALID_VOL; // no extended partition found. 

    // Our partition if it exists is in extended partition. 
    uint32_t next_mbr = getLe32(mp->relativeSectors);
    for(;;) {
    3658:	b.n	3622 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x142>
      } else return INVALID_VOL;
    }
   
    // If we are here than we should hopefully be at start of segment...
    mp = &mbr->part[0];
    *pfirstLBA = getLe32(mp->relativeSectors) + next_mbr;
    365a:	ldr.w	r3, [r4, #454]	; 0x1c6
    365e:	add	r3, r9
    3660:	str.w	r3, [sl]
    if (psectorCount) *psectorCount = getLe32(mp->totalSectors);
    3664:	cbz	r6, 366c <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x18c>
    3666:	ldr.w	r3, [r4, #458]	; 0x1ca
    366a:	str	r3, [r6, #0]
    if (pmbrLBA) *pmbrLBA = next_mbr;
    366c:	cbz	r7, 3672 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x192>
    366e:	str.w	r9, [r7]
    if (pmbrPart) *pmbrPart = 0; // zero based. 
    3672:	cmp.w	r8, #0
    3676:	beq.n	367e <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)+0x19e>
    3678:	movs	r3, #0
    367a:	strb.w	r3, [r8]
    return EXT_VOL;
    367e:	movs	r0, #2
  }
    3680:	add	sp, #12
    3682:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3686:	nop
    3688:	.word	0x00012a00
    368c:	.word	0x000129f0

00003690 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>:
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    3690:	cmp.w	r1, #256	; 0x100
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsStructs.h"
// bgnLba = relSector;
// endLba = relSector + partSize - 1;
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba) {
    3694:	push	{r4, r5, lr}
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    3696:	bhi.n	36a6 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x16>
  if (capacityMB <= 16) {
    3698:	cmp	r1, #16
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    369a:	mov.w	r4, #32
  if (capacityMB <= 16) {
    369e:	bls.n	36ca <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x3a>
    numberOfHeads = 2;
  } else if (capacityMB <= 32) {
    36a0:	cmp	r1, #32
    36a2:	bls.n	36ce <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x3e>
    36a4:	b.n	36a8 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x18>
  uint32_t c;
  uint8_t h;
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
    36a6:	movs	r4, #63	; 0x3f
  if (capacityMB <= 16) {
    numberOfHeads = 2;
  } else if (capacityMB <= 32) {
    numberOfHeads = 4;
  } else if (capacityMB <= 128) {
    36a8:	cmp	r1, #128	; 0x80
    36aa:	bls.n	36d2 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x42>
    numberOfHeads = 8;
  } else if (capacityMB <= 504) {
    36ac:	cmp.w	r1, #504	; 0x1f8
    36b0:	bls.n	36d6 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x46>
    numberOfHeads = 16;
  } else if (capacityMB <= 1008) {
    36b2:	cmp.w	r1, #1008	; 0x3f0
    36b6:	bls.n	36da <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x4a>
    numberOfHeads = 32;
  } else if (capacityMB <= 2016) {
    36b8:	cmp.w	r1, #2016	; 0x7e0
    36bc:	bls.n	36de <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x4e>
    numberOfHeads = 64;
  } else if (capacityMB <= 4032) {
    36be:	cmp.w	r1, #4032	; 0xfc0
    numberOfHeads = 128;
  } else {
    numberOfHeads = 255;
    36c2:	ite	ls
    36c4:	movls	r3, #128	; 0x80
    36c6:	movhi	r3, #255	; 0xff
    36c8:	b.n	36e0 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  uint8_t s;

  uint8_t numberOfHeads;
  uint8_t sectorsPerTrack = capacityMB <= 256 ? 32 : 63;
  if (capacityMB <= 16) {
    numberOfHeads = 2;
    36ca:	movs	r3, #2
    36cc:	b.n	36e0 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 32) {
    numberOfHeads = 4;
    36ce:	movs	r3, #4
    36d0:	b.n	36e0 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 128) {
    numberOfHeads = 8;
    36d2:	movs	r3, #8
    36d4:	b.n	36e0 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 504) {
    numberOfHeads = 16;
    36d6:	movs	r3, #16
    36d8:	b.n	36e0 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 1008) {
    numberOfHeads = 32;
    36da:	movs	r3, #32
    36dc:	b.n	36e0 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x50>
  } else if (capacityMB <= 2016) {
    numberOfHeads = 64;
    36de:	movs	r3, #64	; 0x40
  } else if (capacityMB <= 4032) {
    numberOfHeads = 128;
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
    36e0:	smulbb	r3, r3, r4
    36e4:	udiv	r5, r2, r3
  if (c <= 1023) {
    36e8:	cmp.w	r5, #1024	; 0x400
    36ec:	bcs.n	3706 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x76>
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
    36ee:	udiv	r1, r2, r4
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    36f2:	mls	r3, r3, r5, r2
    s = (lba % sectorsPerTrack) + 1;
    36f6:	mls	r2, r4, r1, r2
    36fa:	adds	r2, #1
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    36fc:	udiv	r3, r3, r4
    s = (lba % sectorsPerTrack) + 1;
    3700:	uxtb	r2, r2
  } else {
    numberOfHeads = 255;
  }
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    3702:	uxtb	r3, r3
    3704:	b.n	370e <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)+0x7e>
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    h = 254;
    s = 63;
    3706:	movs	r2, #63	; 0x3f
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    h = 254;
    3708:	movs	r3, #254	; 0xfe
  c = lba / (numberOfHeads * sectorsPerTrack);
  if (c <= 1023) {
    h = (lba % (numberOfHeads * sectorsPerTrack)) / sectorsPerTrack;
    s = (lba % sectorsPerTrack) + 1;
  } else {
    c = 1023;
    370a:	movw	r5, #1023	; 0x3ff
    h = 254;
    s = 63;
  }
  chs[0] = h;
    370e:	strb	r3, [r0, #0]
  chs[1] = ((c >> 2) & 0XC0) | s;
    3710:	lsrs	r3, r5, #2
    3712:	bic.w	r3, r3, #63	; 0x3f
    3716:	orrs	r2, r3
    3718:	strb	r2, [r0, #1]
  chs[2] = c;
    371a:	strb	r5, [r0, #2]
    371c:	pop	{r4, r5, pc}

0000371e <FsCache::sync()>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    371e:	push	{r3, r4, r5, r6, r7, lr}
  if (m_status & CACHE_STATUS_DIRTY) {
    3720:	ldrb	r3, [r0, #0]
    3722:	lsls	r2, r3, #31

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    3724:	mov	r4, r0
  if (m_status & CACHE_STATUS_DIRTY) {
    3726:	bpl.n	3764 <FsCache::sync()+0x46>
    if (!m_blockDev->writeSector(m_sector, m_buffer)) {
    3728:	ldr	r0, [r0, #4]
    372a:	ldr	r1, [r4, #12]
    372c:	ldr	r3, [r0, #0]
    372e:	add.w	r6, r4, #16
    3732:	ldr	r3, [r3, #32]
    3734:	mov	r2, r6
    3736:	blx	r3
    3738:	mov	r5, r0
    373a:	cbnz	r0, 3740 <FsCache::sync()+0x22>
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;

 fail:
  return false;
    373c:	movs	r5, #0
    373e:	b.n	3766 <FsCache::sync()+0x48>
    if (!m_blockDev->writeSector(m_sector, m_buffer)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
    3740:	ldrb	r3, [r4, #0]
    3742:	lsls	r3, r3, #30
    3744:	bmi.n	3750 <FsCache::sync()+0x32>
      if (!m_blockDev->writeSector(sector, m_buffer)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
    3746:	ldrb	r3, [r4, #0]
    3748:	bic.w	r3, r3, #1
    374c:	strb	r3, [r4, #0]
    374e:	b.n	3766 <FsCache::sync()+0x48>
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
      uint32_t sector = m_sector + m_mirrorOffset;
      if (!m_blockDev->writeSector(sector, m_buffer)) {
    3750:	adds	r0, r4, #4
    3752:	ldmia	r0, {r0, r1, r7}
    3754:	ldr	r3, [r0, #0]
    3756:	mov	r2, r6
    3758:	ldr	r3, [r3, #32]
    375a:	add	r1, r7
    375c:	blx	r3
    375e:	cmp	r0, #0
    3760:	bne.n	3746 <FsCache::sync()+0x28>
    3762:	b.n	373c <FsCache::sync()+0x1e>
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;
    3764:	movs	r5, #1

 fail:
  return false;
}
    3766:	mov	r0, r5
    3768:	pop	{r3, r4, r5, r6, r7, pc}

0000376a <FsCache::get(unsigned long, unsigned char)>:
#define DBG_FILE "FsCache.cpp"
#include "DebugMacros.h"
#include "FsCache.h"
//------------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
  if (!m_blockDev) {
    376a:	ldr	r3, [r0, #4]
 */
#define DBG_FILE "FsCache.cpp"
#include "DebugMacros.h"
#include "FsCache.h"
//------------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
    376c:	push	{r4, r5, r6, lr}
    376e:	mov	r4, r0
    3770:	mov	r6, r1
    3772:	mov	r5, r2
  if (!m_blockDev) {
    3774:	cbnz	r3, 377a <FsCache::get(unsigned long, unsigned char)+0x10>
  }
  m_status |= option & CACHE_STATUS_MASK;
  return m_buffer;

 fail:
  return nullptr;
    3776:	movs	r0, #0
    3778:	pop	{r4, r5, r6, pc}
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
  if (!m_blockDev) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_sector != sector) {
    377a:	ldr	r3, [r0, #12]
    377c:	cmp	r3, r1
    377e:	beq.n	37a8 <FsCache::get(unsigned long, unsigned char)+0x3e>
    if (!sync()) {
    3780:	bl	371e <FsCache::sync()>
    3784:	cmp	r0, #0
    3786:	beq.n	3776 <FsCache::get(unsigned long, unsigned char)+0xc>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
    3788:	lsls	r3, r5, #29
    378a:	bpl.n	3794 <FsCache::get(unsigned long, unsigned char)+0x2a>
      if (!m_blockDev->readSector(sector, m_buffer)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status = 0;
    378c:	movs	r3, #0
    378e:	strb	r3, [r4, #0]
    m_sector = sector;
    3790:	str	r6, [r4, #12]
    3792:	b.n	37a8 <FsCache::get(unsigned long, unsigned char)+0x3e>
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
      if (!m_blockDev->readSector(sector, m_buffer)) {
    3794:	ldr	r0, [r4, #4]
    3796:	ldr	r3, [r0, #0]
    3798:	add.w	r2, r4, #16
    379c:	ldr	r3, [r3, #12]
    379e:	mov	r1, r6
    37a0:	blx	r3
    37a2:	cmp	r0, #0
    37a4:	bne.n	378c <FsCache::get(unsigned long, unsigned char)+0x22>
    37a6:	b.n	3776 <FsCache::get(unsigned long, unsigned char)+0xc>
      }
    }
    m_status = 0;
    m_sector = sector;
  }
  m_status |= option & CACHE_STATUS_MASK;
    37a8:	ldrb	r3, [r4, #0]
    37aa:	mov	r0, r4
    37ac:	and.w	r5, r5, #3
    37b0:	orrs	r5, r3
    37b2:	strb.w	r5, [r0], #16
  return m_buffer;

 fail:
  return nullptr;
}
    37b6:	pop	{r4, r5, r6, pc}

000037b8 <toUpcase(unsigned short)>:
}
//------------------------------------------------------------------------------
uint16_t toUpcase(uint16_t chr) {
  uint16_t i, first;
  // Optimize for simple ASCII.
  if (chr < 127) {
    37b8:	cmp	r0, #126	; 0x7e
    }
  }
  return left;
}
//------------------------------------------------------------------------------
uint16_t toUpcase(uint16_t chr) {
    37ba:	push	{r4, r5, lr}
  uint16_t i, first;
  // Optimize for simple ASCII.
  if (chr < 127) {
    37bc:	bhi.n	37cc <toUpcase(unsigned short)+0x14>
    return chr - ('a' <= chr && chr <= 'z' ? 'a' - 'A' : 0);
    37be:	sub.w	r3, r0, #97	; 0x61
    37c2:	cmp	r3, #25
    37c4:	ite	hi
    37c6:	movhi	r3, #0
    37c8:	movls	r3, #32
    37ca:	b.n	380e <toUpcase(unsigned short)+0x56>
    37cc:	ldr	r5, [pc, #132]	; (3854 <toUpcase(unsigned short)+0x9c>)
    37ce:	movs	r4, #53	; 0x35
    37d0:	movs	r3, #0
//------------------------------------------------------------------------------
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    37d2:	subs	r2, r4, r3
    37d4:	cmp	r2, #1
    37d6:	ldr	r1, [pc, #124]	; (3854 <toUpcase(unsigned short)+0x9c>)
    37d8:	bls.n	37ec <toUpcase(unsigned short)+0x34>
    mid = left + (right - left)/2;
    37da:	add.w	r2, r3, r2, lsr #1
    if (readTable16(table[mid].key) <= key) {
    37de:	ldrh.w	r1, [r5, r2, lsl #2]
    37e2:	cmp	r1, r0
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    mid = left + (right - left)/2;
    37e4:	ite	hi
    37e6:	movhi	r4, r2
    37e8:	movls	r3, r2
    37ea:	b.n	37d2 <toUpcase(unsigned short)+0x1a>
  // Optimize for simple ASCII.
  if (chr < 127) {
    return chr - ('a' <= chr && chr <= 'z' ? 'a' - 'A' : 0);
  }
  i = searchPair16(reinterpret_cast<const pair16_t*>(mapTable), MAP_DIM, chr);
  first = readTable16(mapTable[i].base);
    37ec:	uxth	r2, r3
    37ee:	ldrh.w	r3, [r1, r2, lsl #2]
  if (first <= chr && (chr - first)  < readTable8(mapTable[i].count)) {
    37f2:	cmp	r0, r3
    37f4:	bcc.n	3822 <toUpcase(unsigned short)+0x6a>
    37f6:	add.w	r2, r1, r2, lsl #2
    37fa:	subs	r3, r0, r3
    37fc:	ldrb	r1, [r2, #3]
    37fe:	cmp	r3, r1
    3800:	bge.n	3822 <toUpcase(unsigned short)+0x6a>
    int8_t off = readTable8(mapTable[i].off);
    3802:	ldrsb.w	r2, [r2, #2]
    if (off == 1) {
    3806:	cmp	r2, #1
    3808:	bne.n	3812 <toUpcase(unsigned short)+0x5a>
      return chr - ((chr - first) & 1);
    380a:	and.w	r3, r3, #1
    380e:	subs	r0, r0, r3
    3810:	b.n	381e <toUpcase(unsigned short)+0x66>
    }
    return chr + (off ? off : -0x1C60);
    3812:	cbz	r2, 3818 <toUpcase(unsigned short)+0x60>
    3814:	uxth	r2, r2
    3816:	b.n	381c <toUpcase(unsigned short)+0x64>
    3818:	movw	r2, #58272	; 0xe3a0
    381c:	add	r0, r2
    381e:	uxth	r0, r0
    3820:	pop	{r4, r5, pc}
    3822:	ldr	r5, [pc, #52]	; (3858 <toUpcase(unsigned short)+0xa0>)
    3824:	movs	r4, #75	; 0x4b
    3826:	movs	r3, #0
//------------------------------------------------------------------------------
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    3828:	subs	r2, r4, r3
    382a:	cmp	r2, #1
    382c:	ldr	r1, [pc, #40]	; (3858 <toUpcase(unsigned short)+0xa0>)
    382e:	bls.n	3842 <toUpcase(unsigned short)+0x8a>
    mid = left + (right - left)/2;
    3830:	add.w	r2, r3, r2, lsr #1
    if (readTable16(table[mid].key) <= key) {
    3834:	ldrh.w	r1, [r5, r2, lsl #2]
    3838:	cmp	r1, r0
static size_t searchPair16(const pair16_t* table, size_t size, uint16_t key) {
  size_t left = 0;
  size_t right = size;
  size_t mid;
  while (right - left > 1) {
    mid = left + (right - left)/2;
    383a:	ite	hi
    383c:	movhi	r4, r2
    383e:	movls	r3, r2
    3840:	b.n	3828 <toUpcase(unsigned short)+0x70>
      return chr - ((chr - first) & 1);
    }
    return chr + (off ? off : -0x1C60);
  }
  i = searchPair16(lookupTable, LOOKUP_DIM, chr);
  if (readTable16(lookupTable[i].key) == chr) {
    3842:	uxth	r3, r3
    3844:	ldrh.w	r2, [r1, r3, lsl #2]
    3848:	cmp	r2, r0
    return readTable16(lookupTable[i].val);
    384a:	itt	eq
    384c:	addeq.w	r3, r1, r3, lsl #2
    3850:	ldrheq	r0, [r3, #2]
  }
  return chr;
}
    3852:	pop	{r4, r5, pc}
    3854:	.word	0x00012b36
    3858:	.word	0x00012a0a

0000385c <FsName::get16()>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsName.h"
#include "FsUtf.h"
#if USE_UTF8_LONG_NAMES
uint16_t FsName::get16() {
    385c:	push	{r0, r1, r4, lr}
    385e:	mov	r4, r0
  uint16_t rtn;
  if (ls) {
    3860:	ldrh	r0, [r0, #12]
    3862:	cbz	r0, 386a <FsName::get16()+0xe>
    rtn = ls;
    ls = 0;
    3864:	movs	r3, #0
    3866:	strh	r3, [r4, #12]
    3868:	b.n	38a0 <FsName::get16()+0x44>
  } else if (next >= end) {
    386a:	ldr	r3, [r4, #4]
    386c:	ldr	r1, [r4, #8]
    386e:	cmp	r3, r1
    3870:	bcs.n	38a0 <FsName::get16()+0x44>
    rtn = 0;
  } else {
    uint32_t cp;
    const char* ptr = FsUtf::mbToCp(next, end, &cp);
    3872:	add	r2, sp, #4
    3874:	mov	r0, r3
    3876:	bl	345c <FsUtf::mbToCp(char const*, char const*, unsigned long*)>
    if (!ptr) {
    387a:	cbz	r0, 389c <FsName::get16()+0x40>
      goto fail;
    }
    next = ptr;
    387c:	str	r0, [r4, #4]
    if (cp <= 0XFFFF) {
    387e:	ldr	r0, [sp, #4]
    3880:	cmp.w	r0, #65536	; 0x10000
      rtn = cp;
    } else {
      ls = FsUtf::lowSurrogate(cp);
    3884:	itttt	cs
    3886:	ubfxcs	r3, r0, #0, #10
  /** High surrogate for a code point.
   * \param{in} cp code point.
   * \return high surrogate.
   */
  inline uint16_t highSurrogate(uint32_t cp) {
    return (cp >> 10) + (0XD800 - (0X10000 >> 10));
    388a:	lsrcs	r0, r0, #10
    388c:	subcs.w	r3, r3, #9216	; 0x2400
    3890:	subcs.w	r0, r0, #10304	; 0x2840
    3894:	it	cs
    3896:	strhcs	r3, [r4, #12]
    3898:	uxth	r0, r0
    389a:	b.n	38a0 <FsName::get16()+0x44>
    }
  }
  return rtn;

 fail:
  return 0XFFFF;
    389c:	movw	r0, #65535	; 0xffff
}
    38a0:	add	sp, #8
    38a2:	pop	{r4, pc}

000038a4 <ExFatFormatter::syncUpcase()>:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::syncUpcase() {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    38a4:	ldr	r3, [r0, #8]
    38a6:	ubfx	r3, r3, #0, #9
 fail:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::syncUpcase() {
    38aa:	mov	r1, r0
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  if (!index) {
    38ac:	cbz	r3, 38c8 <ExFatFormatter::syncUpcase()+0x24>
    return true;
  }
  for (size_t i = index; i < BYTES_PER_SECTOR; i++) {
    m_secBuf[i] = 0;
    38ae:	movs	r0, #0
    38b0:	ldr	r2, [r1, #16]
    38b2:	strb	r0, [r2, r3]
bool ExFatFormatter::syncUpcase() {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  if (!index) {
    return true;
  }
  for (size_t i = index; i < BYTES_PER_SECTOR; i++) {
    38b4:	adds	r3, #1
    38b6:	cmp.w	r3, #512	; 0x200
    38ba:	bne.n	38b0 <ExFatFormatter::syncUpcase()+0xc>
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
    38bc:	ldr	r0, [r1, #12]
    38be:	ldr	r2, [r1, #16]
    38c0:	ldr	r3, [r0, #0]
    38c2:	ldr	r1, [r1, #0]
    38c4:	ldr	r3, [r3, #32]
    38c6:	bx	r3
}
    38c8:	movs	r0, #1
    38ca:	bx	lr

000038cc <ExFatFormatter::writeUpcaseByte(unsigned char)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    38cc:	ldr	r2, [r0, #8]
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
    38ce:	mov	r3, r0
  uint16_t index = m_upcaseSize & SECTOR_MASK;
    38d0:	ubfx	r2, r2, #0, #9
  m_secBuf[index] = b;
    38d4:	ldr	r0, [r0, #16]
    m_secBuf[i] = 0;
  }
  return m_dev->writeSector(m_upcaseSector, m_secBuf);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseByte(uint8_t b) {
    38d6:	push	{r4}
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  m_secBuf[index] = b;
    38d8:	strb	r1, [r0, r2]
  m_upcaseChecksum = exFatChecksum(m_upcaseChecksum, b);
    38da:	ldr	r0, [r3, #4]
    38dc:	add.w	r1, r1, r0, ror #1
    38e0:	str	r1, [r3, #4]
  m_upcaseSize++;
    38e2:	ldr	r1, [r3, #8]
    38e4:	adds	r1, #1
    38e6:	str	r1, [r3, #8]
  if (index == SECTOR_MASK) {
    38e8:	movw	r1, #511	; 0x1ff
    38ec:	cmp	r2, r1
    38ee:	bne.n	3906 <ExFatFormatter::writeUpcaseByte(unsigned char)+0x3a>
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
    38f0:	ldr	r0, [r3, #12]
    38f2:	ldr	r1, [r3, #0]
    38f4:	ldr	r2, [r0, #0]
    38f6:	ldr	r4, [r2, #32]
    38f8:	adds	r2, r1, #1
    38fa:	str	r2, [r3, #0]
    38fc:	ldr	r2, [r3, #16]
    38fe:	mov	r3, r4
  }
  return true;
}
    3900:	ldr.w	r4, [sp], #4
  uint16_t index = m_upcaseSize & SECTOR_MASK;
  m_secBuf[index] = b;
  m_upcaseChecksum = exFatChecksum(m_upcaseChecksum, b);
  m_upcaseSize++;
  if (index == SECTOR_MASK) {
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
    3904:	bx	r3
  }
  return true;
}
    3906:	movs	r0, #1
    3908:	ldr.w	r4, [sp], #4
    390c:	bx	lr

0000390e <ExFatFormatter::writeUpcaseUnicode(unsigned short)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
    390e:	push	{r3, r4, r5, lr}
    3910:	mov	r4, r1
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    3912:	uxtb	r1, r1
    return m_dev->writeSector(m_upcaseSector++, m_secBuf);
  }
  return true;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
    3914:	mov	r5, r0
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    3916:	bl	38cc <ExFatFormatter::writeUpcaseByte(unsigned char)>
    391a:	cbz	r0, 3928 <ExFatFormatter::writeUpcaseUnicode(unsigned short)+0x1a>
    391c:	lsrs	r1, r4, #8
    391e:	mov	r0, r5
}
    3920:	ldmia.w	sp!, {r3, r4, r5, lr}
  }
  return true;
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
    3924:	b.w	38cc <ExFatFormatter::writeUpcaseByte(unsigned char)>
}
    3928:	pop	{r3, r4, r5, pc}

0000392a <ExFatFormatter::writeUpcase(unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcase(uint32_t sector) {
    392a:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t n;
  uint32_t ns;
  uint32_t ch = 0;
  uint16_t uc;

  m_upcaseSize = 0;
    392c:	movs	r4, #0
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;
    392e:	stmia.w	r0, {r1, r4}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcaseUnicode(uint16_t unicode) {
  return writeUpcaseByte(unicode) && writeUpcaseByte(unicode >> 8);
}
//------------------------------------------------------------------------------
bool ExFatFormatter::writeUpcase(uint32_t sector) {
    3932:	mov	r7, r0
  uint32_t n;
  uint32_t ns;
  uint32_t ch = 0;
  uint16_t uc;

  m_upcaseSize = 0;
    3934:	str	r4, [r0, #8]
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    uc = toUpcase(ch);
    3936:	uxth	r0, r4
    3938:	bl	37b8 <toUpcase(unsigned short)>
    if (uc != ch) {
    393c:	cmp	r0, r4
  m_upcaseSize = 0;
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    uc = toUpcase(ch);
    393e:	mov	r6, r0
    if (uc != ch) {
    3940:	beq.n	3958 <ExFatFormatter::writeUpcase(unsigned long)+0x2e>
      if (!writeUpcaseUnicode(uc)) {
    3942:	mov	r1, r0
    3944:	mov	r0, r7
    3946:	bl	390e <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    394a:	cbz	r0, 39b6 <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    394c:	adds	r5, r4, #1

  m_upcaseSize = 0;
  m_upcaseChecksum = 0;
  m_upcaseSector = sector;

  while (ch < 0X10000) {
    394e:	cmp.w	r5, #65536	; 0x10000
    3952:	bcs.n	396c <ExFatFormatter::writeUpcase(unsigned long)+0x42>
    3954:	mov	r4, r5
    3956:	b.n	3936 <ExFatFormatter::writeUpcase(unsigned long)+0xc>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
    3958:	adds	r5, r4, #1
    395a:	cmp.w	r5, #65536	; 0x10000
    395e:	bcs.n	3976 <ExFatFormatter::writeUpcase(unsigned long)+0x4c>
    3960:	uxth	r0, r5
    3962:	bl	37b8 <toUpcase(unsigned short)>
    3966:	cmp	r5, r0
    3968:	bne.n	3976 <ExFatFormatter::writeUpcase(unsigned long)+0x4c>
    396a:	b.n	39b2 <ExFatFormatter::writeUpcase(unsigned long)+0x88>
          }
        }
      }
    }
  }
  if (!syncUpcase()) {
    396c:	mov	r0, r7
  }
  return true;

 fail:
  return false;
}
    396e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
          }
        }
      }
    }
  }
  if (!syncUpcase()) {
    3972:	b.w	38a4 <ExFatFormatter::syncUpcase()>
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
      ns = n - ch;
    3976:	subs	r4, r5, r4
      if (ns >= MINIMUM_UPCASE_SKIP) {
    3978:	cmp.w	r4, #512	; 0x200
    397c:	bcc.n	3998 <ExFatFormatter::writeUpcase(unsigned long)+0x6e>
        if (!writeUpcaseUnicode(0XFFFF) || !writeUpcaseUnicode(ns)) {
    397e:	movw	r1, #65535	; 0xffff
    3982:	mov	r0, r7
    3984:	bl	390e <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    3988:	cbz	r0, 39b6 <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
    398a:	uxth	r1, r4
    398c:	mov	r0, r7
    398e:	bl	390e <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    3992:	cmp	r0, #0
    3994:	bne.n	394e <ExFatFormatter::writeUpcase(unsigned long)+0x24>
    3996:	b.n	39b6 <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
      ns = n - ch;
      if (ns >= MINIMUM_UPCASE_SKIP) {
    3998:	mov	r4, r6
          DBG_FAIL_MACRO;
          goto fail;
        }
        ch = n;
      } else {
        while (ch < n) {
    399a:	cmp	r5, r4
    399c:	bhi.n	39a2 <ExFatFormatter::writeUpcase(unsigned long)+0x78>
    399e:	mov	r5, r4
    39a0:	b.n	394e <ExFatFormatter::writeUpcase(unsigned long)+0x24>
          if (!writeUpcaseUnicode(ch++)) {
    39a2:	uxth	r1, r4
    39a4:	mov	r0, r7
    39a6:	bl	390e <ExFatFormatter::writeUpcaseUnicode(unsigned short)>
    39aa:	adds	r4, #1
    39ac:	cmp	r0, #0
    39ae:	bne.n	399a <ExFatFormatter::writeUpcase(unsigned long)+0x70>
    39b0:	b.n	39b6 <ExFatFormatter::writeUpcase(unsigned long)+0x8c>
        DBG_FAIL_MACRO;
        goto fail;
      }
      ch++;
    } else {
      for (n = ch + 1; n < 0X10000 && n == toUpcase(n); n++) {}
    39b2:	adds	r5, #1
    39b4:	b.n	395a <ExFatFormatter::writeUpcase(unsigned long)+0x30>
  }
  return true;

 fail:
  return false;
}
    39b6:	movs	r0, #0
    39b8:	pop	{r3, r4, r5, r6, r7, pc}
    39ba:	Address 0x000039ba is out of bounds.


000039bc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>:
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    39bc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    39c0:	mov	r7, r3
  uint32_t volumeLength;
  uint32_t sectorCount;
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
    39c2:	mov	r3, r0
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    39c4:	sub	sp, #28
  uint32_t volumeLength;
  uint32_t sectorCount;
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
    39c6:	str	r1, [r3, #12]
  m_secBuf = secBuf;
    39c8:	str	r2, [r3, #16]
  sectorCount = dev->sectorCount();
    39ca:	ldr	r3, [r1, #0]
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    39cc:	str	r0, [sp, #4]
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    39ce:	ldr	r3, [r3, #24]
    39d0:	mov	r0, r1
#define writeMsg(pr, str) if (pr) pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(pr, str) if (pr) pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool ExFatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    39d2:	mov	r5, r1
    39d4:	mov	r4, r2
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    39d6:	blx	r3
  // Min size is 512 MB
  if (sectorCount < 0X100000) {
    39d8:	cmp.w	r0, #1048576	; 0x100000
  uint8_t sectorsPerClusterShift;
  uint8_t vs;

  m_dev = dev;
  m_secBuf = secBuf;
  sectorCount = dev->sectorCount();
    39dc:	mov	r9, r0
  // Min size is 512 MB
  if (sectorCount < 0X100000) {
    39de:	bcs.n	39f0 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x34>
    writeMsg(pr, "Device is too small\r\n");
    39e0:	cmp	r7, #0
    39e2:	beq.w	3c0a <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x24e>
    39e6:	ldr	r1, [pc, #584]	; (3c30 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x274>)
    39e8:	mov	r0, r7
    39ea:	bl	6a8 <Print::write(char const*)>
    39ee:	b.n	3c02 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x246>
    39f0:	movs	r6, #0
    39f2:	movs	r3, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
    39f4:	adds	r6, #1
    39f6:	uxtb	r6, r6
    39f8:	cmp	r6, #32
    39fa:	mov.w	r3, r3, lsl #1
    39fe:	beq.n	3a0c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x50>
    3a00:	cmp	r9, r3
    3a02:	bhi.n	39f4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x38>
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
    3a04:	cmp	r6, #28
    3a06:	bhi.n	3a0c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x50>
    3a08:	movs	r3, #8
    3a0a:	b.n	3a14 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x58>
    3a0c:	sub.w	r8, r6, #11
    3a10:	ubfx	r3, r8, #1, #8
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
    3a14:	cmp	r6, #26
    3a16:	it	hi
    3a18:	addhi	r6, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
    3a1a:	str	r3, [sp, #8]
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
    3a1c:	ittte	hi
    3a1e:	asrhi	r6, r6, #1
    3a20:	movhi	r3, #1
    3a22:	lslhi	r3, r6
    3a24:	movls.w	r3, #8192	; 0x2000
    3a28:	str	r3, [sp, #0]
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
    3a2a:	ldr	r3, [sp, #0]
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    3a2c:	ldr	r2, [sp, #8]
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
    3a2e:	lsls	r6, r3, #1
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
    3a30:	lsls	r3, r3, #2
    3a32:	rsb	sl, r3, r9
    3a36:	str	r3, [sp, #16]
    3a38:	ldr	r3, [sp, #8]
    3a3a:	lsr.w	r3, sl, r3
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    3a3e:	lsl.w	sl, r3, r2

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3a42:	movs	r1, #0
    3a44:	mov.w	r2, #512	; 0x200
    3a48:	mov	r0, r4
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
    3a4a:	str	r3, [sp, #12]
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3a4c:	bl	8fc0 <memset>
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
  mbr->part->type = 7;
    3a50:	movs	r3, #7
    3a52:	strb.w	r3, [r4, #450]	; 0x1c2
  mbr->part->endCHS[0] = 0XFE;
    3a56:	movs	r3, #254	; 0xfe
    3a58:	strb.w	r3, [r4, #451]	; 0x1c3
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
    3a5c:	mov.w	fp, #1
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
  mbr->part->type = 7;
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
    3a60:	movs	r3, #255	; 0xff
  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
  mbr->part->beginCHS[1] = 1;
  mbr->part->beginCHS[2] = 0;
    3a62:	mov.w	r8, #0
  mbr->part->type = 7;
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
    3a66:	strb.w	r3, [r4, #452]	; 0x1c4
  mbr->part->endCHS[2] = 0XFF;
    3a6a:	strb.w	r3, [r4, #453]	; 0x1c5
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);

  // make Master Boot Record.  Use fake CHS.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  mbr = reinterpret_cast<MbrSector_t*>(secBuf);
  mbr->part->beginCHS[0] = 1;
    3a6e:	strb.w	fp, [r4, #447]	; 0x1bf
  mbr->part->beginCHS[1] = 1;
    3a72:	strb.w	fp, [r4, #448]	; 0x1c0
  mbr->part->beginCHS[2] = 0;
    3a76:	strb.w	r8, [r4, #449]	; 0x1c1
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3a7a:	movw	r3, #43605	; 0xaa55
    3a7e:	strh.w	r3, [r4, #510]	; 0x1fe
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
  setLe32(mbr->part->relativeSectors, partitionOffset);
  setLe32(mbr->part->totalSectors, volumeLength);
  setLe16(mbr->signature, MBR_SIGNATURE);
  if (!dev->writeSector(0, secBuf)) {
    3a82:	ldr	r3, [r5, #0]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3a84:	str.w	r6, [r4, #454]	; 0x1c6
  fatLength = 1UL << (vs < 27 ? 13 : (vs + 1)/2);
  fatOffset = fatLength;
  partitionOffset = 2*fatLength;
  clusterHeapOffset = 2*fatLength;
  clusterCount = (sectorCount - 4*fatLength) >> sectorsPerClusterShift;
  volumeLength = clusterHeapOffset + (clusterCount << sectorsPerClusterShift);
    3a88:	add	sl, r6
    3a8a:	str.w	sl, [r4, #458]	; 0x1ca
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
  setLe32(mbr->part->relativeSectors, partitionOffset);
  setLe32(mbr->part->totalSectors, volumeLength);
  setLe16(mbr->signature, MBR_SIGNATURE);
  if (!dev->writeSector(0, secBuf)) {
    3a8e:	ldr	r3, [r3, #32]
    3a90:	mov	r2, r4
    3a92:	mov	r1, r8
    3a94:	mov	r0, r5
    3a96:	blx	r3
    3a98:	cmp	r0, #0
    3a9a:	beq.w	3c00 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Partition Boot sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3a9e:	mov.w	r2, #512	; 0x200
    3aa2:	mov	r1, r8
    3aa4:	mov	r0, r4
    3aa6:	bl	8fc0 <memset>
  pbs = reinterpret_cast<ExFatPbs_t*>(secBuf);
  pbs->jmpInstruction[0] = 0XEB;
    3aaa:	movs	r3, #235	; 0xeb
    3aac:	strb	r3, [r4, #0]
  pbs->jmpInstruction[1] = 0X76;
    3aae:	movs	r3, #118	; 0x76
    3ab0:	strb	r3, [r4, #1]
  pbs->jmpInstruction[2] = 0X90;
    3ab2:	movs	r3, #144	; 0x90
    3ab4:	strb	r3, [r4, #2]
  pbs->oemName[0] = 'E';
    3ab6:	movs	r3, #69	; 0x45
    3ab8:	strb	r3, [r4, #3]
  pbs->oemName[1] = 'X';
    3aba:	movs	r3, #88	; 0x58
    3abc:	strb	r3, [r4, #4]
  pbs->oemName[2] = 'F';
    3abe:	movs	r3, #70	; 0x46
    3ac0:	strb	r3, [r4, #5]
  pbs->oemName[3] = 'A';
    3ac2:	movs	r3, #65	; 0x41
    3ac4:	strb	r3, [r4, #6]
  pbs->oemName[4] = 'T';
    3ac6:	movs	r3, #84	; 0x54
    3ac8:	strb	r3, [r4, #7]
  pbs->oemName[5] = ' ';
    3aca:	movs	r3, #32
    3acc:	strb	r3, [r4, #8]
  pbs->oemName[6] = ' ';
    3ace:	strb	r3, [r4, #9]
  pbs->oemName[7] = ' ';
    3ad0:	strb	r3, [r4, #10]
    3ad2:	ldr	r3, [sp, #0]
    3ad4:	str	r3, [r4, #80]	; 0x50
    3ad6:	str	r3, [r4, #84]	; 0x54
    3ad8:	ldr	r3, [sp, #12]
    3ada:	str	r3, [r4, #92]	; 0x5c
    3adc:	movs	r3, #4
    3ade:	str	r3, [r4, #96]	; 0x60
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3ae0:	mov.w	r3, #256	; 0x100
    3ae4:	strh.w	r3, [r4, #104]	; 0x68
  setLe32(pbs->bpb.clusterCount, clusterCount);
  setLe32(pbs->bpb.rootDirectoryCluster, ROOT_CLUSTER);
  setLe32(pbs->bpb.volumeSerialNumber, sectorCount);
  setLe16(pbs->bpb.fileSystemRevision, 0X100);
  setLe16(pbs->bpb.volumeFlags, 0);
  pbs->bpb.bytesPerSectorShift = BYTES_PER_SECTOR_SHIFT;
    3ae8:	movs	r3, #9
    3aea:	strb.w	r3, [r4, #108]	; 0x6c
  pbs->bpb.sectorsPerClusterShift = sectorsPerClusterShift;
    3aee:	ldrb.w	r3, [sp, #8]
    3af2:	strb.w	r3, [r4, #109]	; 0x6d
  pbs->bpb.numberOfFats = 1;
  pbs->bpb.driveSelect = 0X80;
    3af6:	movs	r3, #128	; 0x80
    3af8:	strb.w	r3, [r4, #111]	; 0x6f

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    3afc:	str	r6, [r4, #64]	; 0x40
    3afe:	str.w	r8, [r4, #68]	; 0x44
    3b02:	str.w	sl, [r4, #72]	; 0x48
    3b06:	str.w	r8, [r4, #76]	; 0x4c
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3b0a:	str	r6, [r4, #88]	; 0x58
    3b0c:	str.w	r9, [r4, #100]	; 0x64
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3b10:	strh.w	r8, [r4, #106]	; 0x6a
  setLe32(pbs->bpb.volumeSerialNumber, sectorCount);
  setLe16(pbs->bpb.fileSystemRevision, 0X100);
  setLe16(pbs->bpb.volumeFlags, 0);
  pbs->bpb.bytesPerSectorShift = BYTES_PER_SECTOR_SHIFT;
  pbs->bpb.sectorsPerClusterShift = sectorsPerClusterShift;
  pbs->bpb.numberOfFats = 1;
    3b14:	strb.w	fp, [r4, #110]	; 0x6e
  pbs->bpb.driveSelect = 0X80;
  pbs->bpb.percentInUse = 0;
    3b18:	strb.w	r8, [r4, #112]	; 0x70
    3b1c:	add.w	r3, r4, #119	; 0x77
    3b20:	addw	r2, r4, #509	; 0x1fd

  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
    3b24:	movs	r1, #244	; 0xf4
    3b26:	strb.w	r1, [r3, #1]!
  pbs->bpb.numberOfFats = 1;
  pbs->bpb.driveSelect = 0X80;
  pbs->bpb.percentInUse = 0;

  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    3b2a:	cmp	r3, r2
    3b2c:	bne.n	3b26 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x16a>
    3b2e:	movw	r3, #43605	; 0xaa55
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    3b32:	mov.w	r9, #0
    3b36:	strh.w	r3, [r4, #510]	; 0x1fe
  ExFatPbs_t* pbs;
  DirUpcase_t* dup;
  DirBitmap_t* dbm;
  DirLabel_t* label;
  uint32_t bitmapSize;
  uint32_t checksum = 0;
    3b3a:	mov	r8, r9
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    if (i == offsetof(ExFatPbs_t, bpb.volumeFlags[0]) ||
    3b3c:	sub.w	r3, r9, #106	; 0x6a
    3b40:	cmp	r3, #1
    3b42:	bls.n	3b52 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x196>
        i == offsetof(ExFatPbs_t, bpb.volumeFlags[1]) ||
    3b44:	cmp.w	r9, #112	; 0x70
  uint8_t  mustBeZero2[2];
  uint8_t  unicode3[4];
} DirLfn_t;
//=============================================================================
inline uint32_t exFatChecksum(uint32_t sum, uint8_t data) {
  return (sum << 31) + (sum >> 1) + data;
    3b48:	itt	ne
    3b4a:	ldrbne.w	r3, [r4, r9]
    3b4e:	addne.w	r8, r3, r8, ror #1
  // Fill boot code like official SDFormatter.
  for (size_t i = 0; i < sizeof(pbs->bootCode); i++) {
    pbs->bootCode[i] = 0XF4;
  }
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    3b52:	add.w	r9, r9, #1
    3b56:	cmp.w	r9, #512	; 0x200
    3b5a:	bne.n	3b3c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x180>
      continue;
    }
    checksum = exFatChecksum(checksum, secBuf[i]);
  }
  sector = partitionOffset;
  if (!dev->writeSector(sector, secBuf)  ||
    3b5c:	ldr	r3, [r5, #0]
    3b5e:	mov	r2, r4
    3b60:	ldr	r3, [r3, #32]
    3b62:	mov	r1, r6
    3b64:	mov	r0, r5
    3b66:	blx	r3
    3b68:	cmp	r0, #0
    3b6a:	beq.n	3c00 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3b6c:	ldr	r3, [r5, #0]
    3b6e:	mov	r2, r4
    3b70:	ldr	r3, [r3, #32]
    3b72:	add.w	r1, r6, #12
    3b76:	mov	r0, r5
    3b78:	blx	r3
      continue;
    }
    checksum = exFatChecksum(checksum, secBuf[i]);
  }
  sector = partitionOffset;
  if (!dev->writeSector(sector, secBuf)  ||
    3b7a:	cmp	r0, #0
    3b7c:	beq.n	3c00 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3b7e:	mov	r2, r9
    3b80:	movs	r1, #0
    3b82:	mov	r0, r4
    3b84:	bl	8fc0 <memset>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    3b88:	movw	r3, #43605	; 0xaa55
    3b8c:	strh.w	r3, [r4, #510]	; 0x1fe
    3b90:	subs	r3, r4, #1
  if (!dev->writeSector(sector, secBuf)  ||
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector++;
    3b92:	add.w	sl, r6, #1
    3b96:	add.w	r9, r6, #9
    3b9a:	str	r3, [sp, #20]
    3b9c:	addw	fp, r4, #511	; 0x1ff
  ExFatPbs_t* pbs;
  DirUpcase_t* dup;
  DirBitmap_t* dbm;
  DirLabel_t* label;
  uint32_t bitmapSize;
  uint32_t checksum = 0;
    3ba0:	ldr	r3, [sp, #20]
  uint8_t  mustBeZero2[2];
  uint8_t  unicode3[4];
} DirLfn_t;
//=============================================================================
inline uint32_t exFatChecksum(uint32_t sum, uint8_t data) {
  return (sum << 31) + (sum >> 1) + data;
    3ba2:	ldrb.w	r2, [r3, #1]!
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    3ba6:	cmp	fp, r3
    3ba8:	add.w	r8, r2, r8, ror #1
    3bac:	bne.n	3ba2 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x1e6>
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    3bae:	ldr	r3, [r5, #0]
    3bb0:	mov	r2, r4
    3bb2:	ldr	r3, [r3, #32]
    3bb4:	mov	r1, sl
    3bb6:	mov	r0, r5
    3bb8:	blx	r3
    3bba:	cbz	r0, 3c00 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3bbc:	ldr	r3, [r5, #0]
    3bbe:	mov	r2, r4
    3bc0:	ldr	r3, [r3, #32]
    3bc2:	add.w	r1, sl, #12
    3bc6:	mov	r0, r5
    3bc8:	blx	r3
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    3bca:	cbz	r0, 3c00 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    sector++;
    3bcc:	add.w	sl, sl, #1
  }
  sector++;
  // Write eight Extended Boot Sectors.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  setLe16(pbs->signature, PBR_SIGNATURE);
  for (int j = 0; j < 8; j++) {
    3bd0:	cmp	sl, r9
    3bd2:	bne.n	3ba0 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x1e4>
      goto fail;
    }
    sector++;
  }
  // Write OEM Parameter Sector and reserved sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3bd4:	mov.w	r2, #512	; 0x200
    3bd8:	movs	r1, #0
    3bda:	mov	r0, r4
    3bdc:	bl	8fc0 <memset>
    3be0:	add.w	sl, r6, #11
    3be4:	ldr	r3, [sp, #20]
    3be6:	ldrb.w	r2, [r3, #1]!
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
    3bea:	cmp	fp, r3
    3bec:	add.w	r8, r2, r8, ror #1
    3bf0:	bne.n	3be6 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x22a>
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    3bf2:	ldr	r3, [r5, #0]
    3bf4:	mov	r2, r4
    3bf6:	ldr	r3, [r3, #32]
    3bf8:	mov	r1, r9
    3bfa:	mov	r0, r5
    3bfc:	blx	r3
    3bfe:	cbnz	r0, 3c10 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x254>
  }
  writeMsg(pr, "Format done\r\n");
  return true;

 fail:
  writeMsg(pr, "Format failed\r\n");
    3c00:	cbz	r7, 3c0a <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x24e>
    3c02:	ldr	r1, [pc, #48]	; (3c34 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x278>)
    3c04:	mov	r0, r7
    3c06:	bl	6a8 <Print::write(char const*)>
  return false;
    3c0a:	mov.w	sl, #0
    3c0e:	b.n	3df4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x438>
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3c10:	ldr	r3, [r5, #0]
    3c12:	mov	r2, r4
    3c14:	ldr	r3, [r3, #32]
    3c16:	add.w	r1, r9, #12
    3c1a:	mov	r0, r5
    3c1c:	blx	r3
  memset(secBuf, 0, BYTES_PER_SECTOR);
  for (int j = 0; j < 2; j++) {
    for (size_t i = 0; i < BYTES_PER_SECTOR; i++) {
      checksum = exFatChecksum(checksum, secBuf[i]);
    }
    if (!dev->writeSector(sector, secBuf)  ||
    3c1e:	cmp	r0, #0
    3c20:	beq.n	3c00 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
        !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    sector++;
    3c22:	add.w	r3, r9, #1
    }
    sector++;
  }
  // Write OEM Parameter Sector and reserved sector.
  memset(secBuf, 0, BYTES_PER_SECTOR);
  for (int j = 0; j < 2; j++) {
    3c26:	cmp	r3, sl
    3c28:	beq.n	3c38 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x27c>
    3c2a:	mov	r9, r3
    3c2c:	b.n	3be4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x228>
    3c2e:	nop
    3c30:	.word	0x00012c0a
    3c34:	.word	0x00012c63
    3c38:	subs	r3, r4, #4
    3c3a:	add.w	r2, r4, #508	; 0x1fc
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3c3e:	str.w	r8, [r3, #4]!
      goto fail;
    }
    sector++;
  }
  // Write Boot CheckSum Sector.
  for (size_t i = 0; i < BYTES_PER_SECTOR; i += 4) {
    3c42:	cmp	r2, r3
    3c44:	bne.n	3c3e <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x282>
    setLe32(secBuf + i, checksum);
  }
  if (!dev->writeSector(sector, secBuf)  ||
    3c46:	ldr	r3, [r5, #0]
    3c48:	mov	r2, r4
    3c4a:	ldr	r3, [r3, #32]
    3c4c:	mov	r1, sl
    3c4e:	mov	r0, r5
    3c50:	blx	r3
    3c52:	cmp	r0, #0
    3c54:	beq.n	3c00 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    3c56:	ldr	r3, [r5, #0]
    3c58:	mov	r2, r4
    3c5a:	ldr	r3, [r3, #32]
    3c5c:	add.w	r1, r9, #13
    3c60:	mov	r0, r5
    3c62:	blx	r3
  }
  // Write Boot CheckSum Sector.
  for (size_t i = 0; i < BYTES_PER_SECTOR; i += 4) {
    setLe32(secBuf + i, checksum);
  }
  if (!dev->writeSector(sector, secBuf)  ||
    3c64:	cmp	r0, #0
    3c66:	beq.n	3c00 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      !dev->writeSector(sector + BOOT_BACKUP_OFFSET , secBuf)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
    3c68:	cbz	r7, 3c72 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2b6>
    3c6a:	ldr	r1, [pc, #400]	; (3dfc <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x440>)
    3c6c:	mov	r0, r7
    3c6e:	bl	6a8 <Print::write(char const*)>
  sector = partitionOffset + fatOffset;
    3c72:	ldr	r3, [sp, #0]
    3c74:	add	r6, r3
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3c76:	ldr	r3, [sp, #12]

  memset(secBuf, 0, BYTES_PER_SECTOR);
    3c78:	mov.w	r2, #512	; 0x200
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3c7c:	mov.w	r9, r3, lsl #2

  memset(secBuf, 0, BYTES_PER_SECTOR);
    3c80:	movs	r1, #0
    3c82:	mov	r0, r4
    3c84:	bl	8fc0 <memset>
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3c88:	addw	r9, r9, #519	; 0x207

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
    3c8c:	movs	r3, #248	; 0xf8
    3c8e:	strb	r3, [r4, #0]
    goto fail;
  }
  // Initialize FAT.
  writeMsg(pr, "Writing FAT ");
  sector = partitionOffset + fatOffset;
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3c90:	mov.w	sl, r9, lsr #9
    3c94:	mov	r3, r4
    3c96:	add.w	r2, r4, #19

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    secBuf[i] = 0XFF;
    3c9a:	movs	r1, #255	; 0xff
    3c9c:	strb.w	r1, [r3, #1]!
  ns = ((clusterCount + 2)*4 + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;

  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    3ca0:	cmp	r2, r3
    3ca2:	bne.n	3c9c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2e0>
    secBuf[i] = 0XFF;
  }
  for (uint32_t i = 0; i < ns; i++) {
    if (i%(ns/32) == 0) {
    3ca4:	mov.w	r9, r9, lsr #14
    3ca8:	mov.w	r8, #0
    3cac:	udiv	r3, r8, r9
    3cb0:	mls	r3, r9, r3, r8
    3cb4:	cbnz	r3, 3cc0 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x304>
      writeMsg(pr, ".");
    3cb6:	cbz	r7, 3cc0 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x304>
    3cb8:	ldr	r1, [pc, #324]	; (3e00 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x444>)
    3cba:	mov	r0, r7
    3cbc:	bl	6a8 <Print::write(char const*)>
    }
    if (!dev->writeSector(sector + i, secBuf)) {
    3cc0:	ldr	r3, [r5, #0]
    3cc2:	mov	r2, r4
    3cc4:	ldr	r3, [r3, #32]
    3cc6:	add.w	r1, r6, r8
    3cca:	mov	r0, r5
    3ccc:	blx	r3
    3cce:	cmp	r0, #0
    3cd0:	beq.n	3c00 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    3cd2:	cmp.w	r8, #0
    3cd6:	bne.n	3ce4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x328>
      memset(secBuf, 0, BYTES_PER_SECTOR);
    3cd8:	mov.w	r2, #512	; 0x200
    3cdc:	mov	r1, r8
    3cde:	mov	r0, r4
    3ce0:	bl	8fc0 <memset>
  // Allocate two reserved clusters, bitmap, upcase, and root clusters.
  secBuf[0] = 0XF8;
  for (size_t i = 1; i < 20; i++) {
    secBuf[i] = 0XFF;
  }
  for (uint32_t i = 0; i < ns; i++) {
    3ce4:	add.w	r8, r8, #1
    3ce8:	cmp	sl, r8
    3cea:	bne.n	3cac <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2f0>
    }
    if (i == 0) {
      memset(secBuf, 0, BYTES_PER_SECTOR);
    }
  }
  writeMsg(pr, "\r\n");
    3cec:	cbz	r7, 3cf6 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x33a>
    3cee:	ldr	r1, [pc, #276]	; (3e04 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x448>)
    3cf0:	mov	r0, r7
    3cf2:	bl	6a8 <Print::write(char const*)>
    goto fail;
  }
  // Determine partition layout.
  for (m = 1, vs = 0; m && sectorCount > m; m <<= 1, vs++) {}
  sectorsPerClusterShift = vs < 29 ? 8 : (vs - 11)/2;
  sectorsPerCluster = 1UL << sectorsPerClusterShift;
    3cf6:	ldr	r3, [sp, #8]
    3cf8:	mov.w	r8, #1
    3cfc:	lsl.w	r8, r8, r3
    }
  }
  writeMsg(pr, "\r\n");
  // Write cluster two, bitmap.
  sector = partitionOffset + clusterHeapOffset;
  bitmapSize = (clusterCount + 7)/8;
    3d00:	ldr	r3, [sp, #12]
    3d02:	add.w	sl, r3, #7
    3d06:	mov.w	sl, sl, lsr #3
  ns = (bitmapSize + BYTES_PER_SECTOR - 1)/BYTES_PER_SECTOR;
    3d0a:	addw	fp, sl, #511	; 0x1ff
    3d0e:	mov.w	fp, fp, lsr #9
  if (ns > sectorsPerCluster) {
    3d12:	cmp	r8, fp
    3d14:	bcc.w	3c00 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3d18:	mov.w	r2, #512	; 0x200
    3d1c:	movs	r1, #0
    3d1e:	mov	r0, r4
    3d20:	bl	8fc0 <memset>
  // Allocate clusters for bitmap, upcase, and root.
  secBuf[0] = 0X7;
    3d24:	movs	r3, #7
    3d26:	strb	r3, [r4, #0]
  for (uint32_t i = 0; i < ns; i++) {
    3d28:	mov.w	r9, #0
    if (!dev->writeSector(sector + i, secBuf)) {
    3d2c:	ldr	r3, [r5, #0]
    3d2e:	ldr	r1, [sp, #16]
    3d30:	ldr	r3, [r3, #32]
    3d32:	mov	r2, r4
    3d34:	add	r1, r9
    3d36:	mov	r0, r5
    3d38:	blx	r3
    3d3a:	cmp	r0, #0
    3d3c:	beq.w	3c00 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    3d40:	cmp.w	r9, #0
    3d44:	bne.n	3d4a <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x38e>
      secBuf[0] = 0;
    3d46:	strb.w	r9, [r4]
    goto fail;
  }
  memset(secBuf, 0, BYTES_PER_SECTOR);
  // Allocate clusters for bitmap, upcase, and root.
  secBuf[0] = 0X7;
  for (uint32_t i = 0; i < ns; i++) {
    3d4a:	add.w	r9, r9, #1
    3d4e:	cmp	fp, r9
    3d50:	bne.n	3d2c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x370>
    if (i == 0) {
      secBuf[0] = 0;
    }
  }
  // Write cluster three, upcase table.
  writeMsg(pr, "Writing upcase table\r\n");
    3d52:	cbz	r7, 3d5c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3a0>
    3d54:	ldr	r1, [pc, #176]	; (3e08 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x44c>)
    3d56:	mov	r0, r7
    3d58:	bl	6a8 <Print::write(char const*)>
  if (!writeUpcase(partitionOffset + clusterHeapOffset + sectorsPerCluster)) {
    3d5c:	ldr	r3, [sp, #0]
    3d5e:	ldr	r0, [sp, #4]
    3d60:	add	r3, r6
    3d62:	add.w	r9, r3, r8
    3d66:	mov	r1, r9
    3d68:	bl	392a <ExFatFormatter::writeUpcase(unsigned long)>
    3d6c:	cmp	r0, #0
    3d6e:	beq.w	3c00 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_upcaseSize > BYTES_PER_SECTOR*sectorsPerCluster) {
    3d72:	ldr	r3, [sp, #4]
    3d74:	ldr	r3, [r3, #8]
    3d76:	cmp.w	r3, r8, lsl #9
    3d7a:	bhi.w	3c00 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Initialize first sector of root.
  writeMsg(pr, "Writing root\r\n");
    3d7e:	cbz	r7, 3d88 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3cc>
    3d80:	ldr	r1, [pc, #136]	; (3e0c <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x450>)
    3d82:	mov	r0, r7
    3d84:	bl	6a8 <Print::write(char const*)>
  ns = sectorsPerCluster;
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);
    3d88:	mov.w	r2, #512	; 0x200
    3d8c:	movs	r1, #0
    3d8e:	mov	r0, r4
    3d90:	bl	8fc0 <memset>
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;

  // bitmap directory entry.
  dbm = reinterpret_cast<DirBitmap_t*>(secBuf + 32);
  dbm->type = EXFAT_TYPE_BITMAP;
    3d94:	movs	r2, #129	; 0x81
    3d96:	strb.w	r2, [r4, #32]
    3d9a:	movs	r2, #2
    3d9c:	str	r2, [r4, #52]	; 0x34
  setLe32(dbm->firstCluster, BITMAP_CLUSTER);
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
    3d9e:	movs	r2, #130	; 0x82
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);

  // Unused Label entry.
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;
    3da0:	movs	r3, #3
  setLe32(dbm->firstCluster, BITMAP_CLUSTER);
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
    3da2:	strb.w	r2, [r4, #64]	; 0x40
  setLe32(dup->checksum, m_upcaseChecksum);
    3da6:	ldr	r2, [sp, #4]
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
  memset(secBuf, 0, BYTES_PER_SECTOR);

  // Unused Label entry.
  label = reinterpret_cast<DirLabel_t*>(secBuf);
  label->type = EXFAT_TYPE_LABEL & 0X7F;
    3da8:	strb	r3, [r4, #0]
  setLe64(dbm->size, bitmapSize);

  // upcase directory entry.
  dup = reinterpret_cast<DirUpcase_t*>(secBuf +64);
  dup->type = EXFAT_TYPE_UPCASE;
  setLe32(dup->checksum, m_upcaseChecksum);
    3daa:	ldr	r2, [r2, #4]
    3dac:	str	r3, [r4, #84]	; 0x54
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    3dae:	ldr	r3, [sp, #4]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    3db0:	str	r2, [r4, #68]	; 0x44
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    3db2:	ldr	r3, [r3, #8]
    3db4:	str.w	sl, [r4, #56]	; 0x38
    3db8:	movs	r6, #0
    goto fail;
  }
  // Initialize first sector of root.
  writeMsg(pr, "Writing root\r\n");
  ns = sectorsPerCluster;
  sector = partitionOffset + clusterHeapOffset + 2*sectorsPerCluster;
    3dba:	add	r9, r8
    3dbc:	str	r3, [r4, #88]	; 0x58
    3dbe:	str	r6, [r4, #92]	; 0x5c
  setLe32(dup->firstCluster, UPCASE_CLUSTER);
  setLe64(dup->size, m_upcaseSize);

  // Write root, cluster four.
  for (uint32_t i = 0; i < ns; i++) {
    if (!dev->writeSector(sector + i, secBuf)) {
    3dc0:	ldr	r3, [r5, #0]
    3dc2:	mov	r2, r4
    3dc4:	ldr	r3, [r3, #32]
    3dc6:	add.w	r1, r6, r9
    3dca:	mov	r0, r5
    3dcc:	blx	r3
    3dce:	mov	sl, r0
    3dd0:	cmp	r0, #0
    3dd2:	beq.w	3c00 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x244>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (i == 0) {
    3dd6:	cbnz	r6, 3de4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x428>
      memset(secBuf, 0, BYTES_PER_SECTOR);
    3dd8:	mov.w	r2, #512	; 0x200
    3ddc:	mov	r1, r6
    3dde:	mov	r0, r4
    3de0:	bl	8fc0 <memset>
  setLe32(dup->checksum, m_upcaseChecksum);
  setLe32(dup->firstCluster, UPCASE_CLUSTER);
  setLe64(dup->size, m_upcaseSize);

  // Write root, cluster four.
  for (uint32_t i = 0; i < ns; i++) {
    3de4:	adds	r6, #1
    3de6:	cmp	r8, r6
    3de8:	bne.n	3dc0 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x404>
    }
    if (i == 0) {
      memset(secBuf, 0, BYTES_PER_SECTOR);
    }
  }
  writeMsg(pr, "Format done\r\n");
    3dea:	cbz	r7, 3df4 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x438>
    3dec:	ldr	r1, [pc, #32]	; (3e10 <ExFatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x454>)
    3dee:	mov	r0, r7
    3df0:	bl	6a8 <Print::write(char const*)>
  return true;

 fail:
  writeMsg(pr, "Format failed\r\n");
  return false;
}
    3df4:	mov	r0, sl
    3df6:	add	sp, #28
    3df8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3dfc:	.word	0x00012c20
    3e00:	.word	0x00012c2d
    3e04:	.word	0x00012c9f
    3e08:	.word	0x00012c2f
    3e0c:	.word	0x00012c46
    3e10:	.word	0x00012c55

00003e14 <ExFatFile::cmpName(DirName_t const*, ExName_t*)>:
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
  return hash;
}
//------------------------------------------------------------------------------
bool ExFatFile::cmpName(const DirName_t* dirName, ExName_t* fname) {
    3e14:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3e18:	mov	r5, r2
    3e1a:	mov	r6, r1
    3e1c:	add.w	r8, r1, #30
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    3e20:	ldrh	r3, [r5, #12]
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    3e22:	ldrh.w	r4, [r6, #2]!
    3e26:	cbnz	r3, 3e3a <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x26>
    3e28:	ldr	r2, [r5, #4]
    3e2a:	ldr	r3, [r5, #8]
    3e2c:	cmp	r2, r3
    3e2e:	bne.n	3e3a <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x26>
  for (uint8_t i = 0; i < 15; i++) {
    uint16_t u = getLe16(dirName->unicode + 2*i);
    if (fname->atEnd()) {
      return u == 0;
    3e30:	clz	r0, r4
    3e34:	lsrs	r0, r0, #5
    3e36:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
#if USE_UTF8_LONG_NAMES
    uint16_t cp = fname->get16();
    3e3a:	mov	r0, r5
    3e3c:	bl	385c <FsName::get16()>
    if (toUpcase(cp) != toUpcase(u)) {
    3e40:	bl	37b8 <toUpcase(unsigned short)>
    3e44:	mov	r7, r0
    3e46:	mov	r0, r4
    3e48:	bl	37b8 <toUpcase(unsigned short)>
    3e4c:	cmp	r7, r0
    3e4e:	bne.n	3e5a <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0x46>
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
  return hash;
}
//------------------------------------------------------------------------------
bool ExFatFile::cmpName(const DirName_t* dirName, ExName_t* fname) {
  for (uint8_t i = 0; i < 15; i++) {
    3e50:	cmp	r6, r8
    3e52:	bne.n	3e20 <ExFatFile::cmpName(DirName_t const*, ExName_t*)+0xc>
    if (u >= 0x7F || toUpper(c) != toUpper(u)) {
      return false;
    }
#endif  // USE_UTF8_LONG_NAMES
  }
  return true;
    3e54:	movs	r0, #1
    3e56:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return u == 0;
    }
#if USE_UTF8_LONG_NAMES
    uint16_t cp = fname->get16();
    if (toUpcase(cp) != toUpcase(u)) {
       return false;
    3e5a:	movs	r0, #0
    3e5c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00003e60 <ExFatFile::getName8(char*, unsigned int)>:
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName8(char* name, size_t count) {
    3e60:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  char* str = name;
  char* ptr;
  DirName_t* dn;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    3e64:	ldrb.w	r3, [r0, #49]	; 0x31
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t ExFatFile::getName8(char* name, size_t count) {
    3e68:	mov	sl, r0
    3e6a:	mov	r9, r1
  char* str = name;
  char* ptr;
  DirName_t* dn;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    3e6c:	cmp	r3, #0
    3e6e:	beq.n	3f00 <ExFatFile::getName8(char*, unsigned int)+0xa0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    3e70:	add.w	r8, r2, #4294967295
    3e74:	mov	r5, r1
    3e76:	movs	r7, #2
    3e78:	movs	r4, #0
    3e7a:	add	r8, r1
  uint32_t cp;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 2; is <= m_setCount; is++) {
    3e7c:	ldrb.w	r3, [sl, #48]	; 0x30
    3e80:	cmp	r3, r7
    3e82:	bcc.n	3ef4 <ExFatFile::getName8(char*, unsigned int)+0x94>
    dn = reinterpret_cast<DirName_t*>
         (dirCache(is, FsCache::CACHE_FOR_READ));
    3e84:	movs	r2, #0
    3e86:	mov	r1, r7
    3e88:	mov	r0, sl
    3e8a:	bl	3f72 <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
    3e8e:	cbz	r0, 3f00 <ExFatFile::getName8(char*, unsigned int)+0xa0>
    3e90:	ldrb	r3, [r0, #0]
    3e92:	cmp	r3, #193	; 0xc1
    3e94:	bne.n	3f00 <ExFatFile::getName8(char*, unsigned int)+0xa0>
    3e96:	mov	r6, r0
    3e98:	add.w	fp, r0, #30
    3e9c:	mov	r3, r4
    3e9e:	ldrh.w	r4, [r6, #2]!
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
      uint16_t c = getLe16(dn->unicode + 2*in);
      if (hs) {
    3ea2:	cbz	r3, 3ec2 <ExFatFile::getName8(char*, unsigned int)+0x62>
        if (!FsUtf::isLowSurrogate(c)) {
    3ea4:	add.w	r2, r4, #9216	; 0x2400
    3ea8:	uxth	r2, r2
    3eaa:	cmp.w	r2, #1024	; 0x400
    3eae:	bcs.n	3f00 <ExFatFile::getName8(char*, unsigned int)+0xa0>
   * \param[in] hs high surrogate.
   * \param[in] ls low surrogate.
   * \return code point.
   */
  inline uint32_t u16ToCp(uint16_t hs, uint16_t ls) {
    return 0X10000 + (((hs & 0X3FF) << 10) | (ls & 0X3FF));
    3eb0:	ldr	r0, [pc, #88]	; (3f0c <ExFatFile::getName8(char*, unsigned int)+0xac>)
    3eb2:	lsls	r3, r3, #10
    3eb4:	ands	r0, r3
    3eb6:	ubfx	r4, r4, #0, #10
    3eba:	orrs	r4, r0
    3ebc:	add.w	r0, r4, #65536	; 0x10000
    3ec0:	b.n	3edc <ExFatFile::getName8(char*, unsigned int)+0x7c>
  /** Check for UTF-16 surrogate.
   * \param[in] c UTF-16 unit.
   * \return true if c is a surrogate else false.
   */
  inline bool isSurrogate(uint16_t c) {
    return 0XD800 <= c && c <= 0XDFFF;
    3ec2:	add.w	r3, r4, #10240	; 0x2800
    3ec6:	uxth	r3, r3
          DBG_FAIL_MACRO;
          goto fail;
        }
        cp = FsUtf::u16ToCp(hs, c);
        hs = 0;
      } else if (!FsUtf::isSurrogate(c)) {
    3ec8:	cmp.w	r3, #2048	; 0x800
    3ecc:	bcc.n	3ed4 <ExFatFile::getName8(char*, unsigned int)+0x74>
        if (c == 0) {
    3ece:	cbz	r4, 3ef4 <ExFatFile::getName8(char*, unsigned int)+0x94>
          goto done;
        }
        cp = c;
    3ed0:	mov	r0, r4
    3ed2:	b.n	3edc <ExFatFile::getName8(char*, unsigned int)+0x7c>
      } else if (FsUtf::isHighSurrogate(c)) {
    3ed4:	cmp.w	r3, #1024	; 0x400
    3ed8:	bcc.n	3eea <ExFatFile::getName8(char*, unsigned int)+0x8a>
    3eda:	b.n	3f00 <ExFatFile::getName8(char*, unsigned int)+0xa0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    3edc:	mov	r2, r8
    3ede:	mov	r1, r5
    3ee0:	bl	33c8 <FsUtf::cpToMb(unsigned long, char*, char*)>
      if (!ptr) {
    3ee4:	cbz	r0, 3ef4 <ExFatFile::getName8(char*, unsigned int)+0x94>
    3ee6:	mov	r5, r0
    3ee8:	movs	r4, #0
         (dirCache(is, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
    3eea:	cmp	fp, r6
    3eec:	bne.n	3e9c <ExFatFile::getName8(char*, unsigned int)+0x3c>
  uint32_t cp;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 2; is <= m_setCount; is++) {
    3eee:	adds	r7, #1
    3ef0:	uxtb	r7, r7
    3ef2:	b.n	3e7c <ExFatFile::getName8(char*, unsigned int)+0x1c>
      }
      str = ptr;
    }
  }
 done:
  *str = '\0';
    3ef4:	movs	r3, #0
    3ef6:	strb	r3, [r5, #0]
  return str - name;
    3ef8:	rsb	r0, r9, r5
    3efc:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

 fail:
  *name = 0;
    3f00:	movs	r0, #0
    3f02:	strb.w	r0, [r9]
  return 0;
}
    3f06:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    3f0a:	nop
    3f0c:	.word	0x000ffc00

00003f10 <ExFatFile::hashName(ExName_t*)>:
//------------------------------------------------------------------------------
bool ExFatFile::hashName(ExName_t* fname) {
    3f10:	push	{r4, r5, r6, lr}
  }
  void reset() {
    next = begin;
    3f12:	ldr	r3, [r1, #0]
    3f14:	str	r3, [r1, #4]
    ls = 0;
    3f16:	movs	r4, #0
    3f18:	mov	r5, r1
    3f1a:	strh	r4, [r1, #12]
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
    3f1c:	str	r4, [r1, #16]
  while (!fname->atEnd()) {
    uint16_t u = fname->get16();
    if (u == 0XFFFF) {
    3f1e:	movw	r6, #65535	; 0xffff
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    3f22:	ldrh	r3, [r5, #12]
    3f24:	cbnz	r3, 3f2e <ExFatFile::hashName(ExName_t*)+0x1e>
    3f26:	ldr	r2, [r5, #4]
    3f28:	ldr	r3, [r5, #8]
    3f2a:	cmp	r2, r3
    3f2c:	beq.n	3f62 <ExFatFile::hashName(ExName_t*)+0x52>
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
  while (!fname->atEnd()) {
    uint16_t u = fname->get16();
    3f2e:	mov	r0, r5
    3f30:	bl	385c <FsName::get16()>
    if (u == 0XFFFF) {
    3f34:	cmp	r0, r6
    3f36:	beq.n	3f5e <ExFatFile::hashName(ExName_t*)+0x4e>
  hash = ((hash << 15) | (hash >> 1));
  return hash;
}
//------------------------------------------------------------------------------
inline uint16_t exFatHash(uint16_t u, uint16_t hash) {
  uint16_t c = toUpcase(u);
    3f38:	bl	37b8 <toUpcase(unsigned short)>
    3f3c:	lsls	r3, r4, #15
    3f3e:	orr.w	r4, r3, r4, lsr #1
    3f42:	uxtab	r4, r4, r0
    3f46:	ubfx	r3, r4, #1, #15
    3f4a:	orr.w	r3, r3, r4, lsl #15
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
    3f4e:	asrs	r4, r0, #8
    3f50:	uxtah	r4, r4, r3
    if (u == 0XFFFF) {
    DBG_FAIL_MACRO;
      goto fail;
    }
    hash = exFatHash(u, hash);
    fname->nameLength++;
    3f54:	ldr	r3, [r5, #16]
    3f56:	adds	r3, #1
}
//------------------------------------------------------------------------------
inline uint16_t exFatHash(uint16_t u, uint16_t hash) {
  uint16_t c = toUpcase(u);
  hash = ((hash << 15) | (hash >> 1)) + (c & 0XFF);
  hash = ((hash << 15) | (hash >> 1)) + (c >> 8);
    3f58:	uxth	r4, r4
    if (u == 0XFFFF) {
    DBG_FAIL_MACRO;
      goto fail;
    }
    hash = exFatHash(u, hash);
    fname->nameLength++;
    3f5a:	str	r3, [r5, #16]
bool ExFatFile::hashName(ExName_t* fname) {
  uint16_t hash = 0;
  fname->reset();
#if USE_UTF8_LONG_NAMES
  fname->nameLength = 0;
  while (!fname->atEnd()) {
    3f5c:	b.n	3f22 <ExFatFile::hashName(ExName_t*)+0x12>
    goto fail;
  }
  return true;

 fail:
  return false;
    3f5e:	movs	r0, #0
    3f60:	pop	{r4, r5, r6, pc}
    hash = exFatHash(c, hash);
  }
  fname->nameLength = fname->end - fname->begin;
#endif  // USE_UTF8_LONG_NAMES
  fname->nameHash = hash;
  if (!fname->nameLength || fname->nameLength > EXFAT_MAX_NAME_LENGTH) {
    3f62:	ldr	r0, [r5, #16]
    char c = fname->getch();
    hash = exFatHash(c, hash);
  }
  fname->nameLength = fname->end - fname->begin;
#endif  // USE_UTF8_LONG_NAMES
  fname->nameHash = hash;
    3f64:	strh	r4, [r5, #20]
  if (!fname->nameLength || fname->nameLength > EXFAT_MAX_NAME_LENGTH) {
    3f66:	subs	r0, #1
    3f68:	cmp	r0, #254	; 0xfe
    3f6a:	ite	hi
    3f6c:	movhi	r0, #0
    3f6e:	movls	r0, #1
  }
  return true;

 fail:
  return false;
}
    3f70:	pop	{r4, r5, r6, pc}

00003f72 <ExFatFile::dirCache(unsigned char, unsigned char)>:
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    3f72:	push	{r4, r5, r6, r7, lr}
  DirPos_t pos = m_dirPos;
    3f74:	add.w	r3, r0, #36	; 0x24
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    3f78:	mov	r5, r0
    3f7a:	mov	r7, r1
    3f7c:	mov	r6, r2
  DirPos_t pos = m_dirPos;
    3f7e:	ldmia.w	r3, {r0, r1, r2}
#else  // USE_UTF8_LONG_NAMES
  return !(lfnReservedChar(c) || c & 0X80);
#endif  // USE_UTF8_LONG_NAMES
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
    3f82:	sub	sp, #20
  DirPos_t pos = m_dirPos;
    3f84:	add	r4, sp, #4
    3f86:	stmia.w	r4, {r0, r1, r2}
  if (m_vol->dirSeek(&pos, 32*set) != 1) {
    3f8a:	lsls	r2, r7, #5
    3f8c:	mov	r1, r4
    3f8e:	ldr	r0, [r5, #32]
    3f90:	bl	4950 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    3f94:	cmp	r0, #1
    3f96:	bne.n	3fa4 <ExFatFile::dirCache(unsigned char, unsigned char)+0x32>
    return nullptr;
  }
  return m_vol->dirCache(&pos, options);
    3f98:	mov	r2, r6
    3f9a:	mov	r1, r4
    3f9c:	ldr	r0, [r5, #32]
    3f9e:	bl	48b2 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    3fa2:	b.n	3fa6 <ExFatFile::dirCache(unsigned char, unsigned char)+0x34>
}
//------------------------------------------------------------------------------
uint8_t* ExFatFile::dirCache(uint8_t set, uint8_t options) {
  DirPos_t pos = m_dirPos;
  if (m_vol->dirSeek(&pos, 32*set) != 1) {
    return nullptr;
    3fa4:	movs	r0, #0
  }
  return m_vol->dirCache(&pos, options);
}
    3fa6:	add	sp, #20
    3fa8:	pop	{r4, r5, r6, r7, pc}

00003faa <ExFatFile::close()>:
//------------------------------------------------------------------------------
bool ExFatFile::close() {
    3faa:	push	{r4, lr}
    3fac:	mov	r4, r0
  bool rtn = sync();
    3fae:	bl	4e68 <ExFatFile::sync()>
  m_attributes = FILE_ATTR_CLOSED;
    3fb2:	movs	r3, #0
    3fb4:	strb.w	r3, [r4, #49]	; 0x31
  m_flags = 0;
    3fb8:	strb.w	r3, [r4, #51]	; 0x33
  return rtn;
}
    3fbc:	pop	{r4, pc}

00003fbe <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    3fbe:	push	{r3, r4, r5, lr}
    3fc0:	mov	r5, r1
    3fc2:	mov	r4, r2
  DirFile_t* df = reinterpret_cast<DirFile_t*>
                 (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_READ));
    3fc4:	add.w	r1, r0, #36	; 0x24
    3fc8:	movs	r2, #0
    3fca:	ldr	r0, [r0, #32]
    3fcc:	bl	48b2 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    3fd0:	cbz	r0, 3fdc <ExFatFile::getCreateDateTime(unsigned short*, unsigned short*)+0x1e>
    3fd2:	ldrh	r3, [r0, #10]
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(df->createDate);
    3fd4:	strh	r3, [r5, #0]
    3fd6:	ldrh	r3, [r0, #8]
  *ptime = getLe16(df->createTime);
    3fd8:	strh	r3, [r4, #0]
  return true;
    3fda:	movs	r0, #1

 fail:
  return false;
}
    3fdc:	pop	{r3, r4, r5, pc}

00003fde <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)>:
//------------------------------------------------------------------------------
bool ExFatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    3fde:	push	{r3, r4, r5, lr}
    3fe0:	mov	r5, r1
    3fe2:	mov	r4, r2
  DirFile_t* df = reinterpret_cast<DirFile_t*>
                 (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_READ));
    3fe4:	add.w	r1, r0, #36	; 0x24
    3fe8:	movs	r2, #0
    3fea:	ldr	r0, [r0, #32]
    3fec:	bl	48b2 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    3ff0:	cbz	r0, 3ffc <ExFatFile::getModifyDateTime(unsigned short*, unsigned short*)+0x1e>
    3ff2:	ldrh	r3, [r0, #14]
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(df->modifyDate);
    3ff4:	strh	r3, [r5, #0]
    3ff6:	ldrh	r3, [r0, #12]
  *ptime = getLe16(df->modifyTime);
    3ff8:	strh	r3, [r4, #0]
  return true;
    3ffa:	movs	r0, #1

 fail:
  return false;
}
    3ffc:	pop	{r3, r4, r5, pc}

00003ffe <ExFatFile::openRoot(ExFatVolume*)>:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
    3ffe:	push	{r3, r4, r5, lr}
    4000:	mov	r5, r1
  if (isOpen()) {
    4002:	ldrb.w	r1, [r0, #49]	; 0x31
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
    4006:	mov	r4, r0
  if (isOpen()) {
    4008:	cbnz	r1, 4020 <ExFatFile::openRoot(ExFatVolume*)+0x22>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
    400a:	movs	r2, #56	; 0x38
    400c:	bl	8fc0 <memset>
  m_attributes = FILE_ATTR_ROOT;
    4010:	movs	r3, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    4012:	movs	r0, #1
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
    4014:	strb.w	r3, [r4, #49]	; 0x31
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
    4018:	strb.w	r0, [r4, #51]	; 0x33
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
    401c:	str	r5, [r4, #32]
    401e:	pop	{r3, r4, r5, pc}
  m_flags = FILE_FLAG_READ;
  return true;

 fail:
  return false;
    4020:	movs	r0, #0
}
    4022:	pop	{r3, r4, r5, pc}

00004024 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>:
//------------------------------------------------------------------------------
bool ExFatFile::parsePathName(const char* path,
                            ExName_t* fname, const char** ptr) {
    4024:	push	{r4, r5, r6, r7}
  // Skip leading spaces.
  while (*path == ' ') {
    4026:	ldrb	r4, [r1, #0]
    4028:	cmp	r4, #32
    402a:	add.w	r5, r1, #1
    402e:	bne.n	4034 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x10>
    4030:	mov	r1, r5
    4032:	b.n	4026 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x2>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    4034:	ldr	r7, [pc, #100]	; (409c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x78>)
    path++;
  }
  fname->begin = path;
    4036:	str	r1, [r2, #0]
  fname->end = path;
    4038:	str	r1, [r2, #8]
  while (*path && !isDirSeparator(*path)) {
    403a:	mov	r5, r1
    403c:	mov	r6, r1
    403e:	ldrb.w	r4, [r5], #1
    4042:	cbz	r4, 407c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x58>
    4044:	cmp	r4, #47	; 0x2f
    4046:	beq.n	4070 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x4c>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    4048:	cmp	r4, #31
    404a:	bls.n	4096 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    404c:	sub.w	r1, r4, #34	; 0x22
    4050:	uxtb	r1, r1
    4052:	cmp	r1, #29
    4054:	bhi.n	405e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x3a>
    4056:	lsr.w	r1, r7, r1
    405a:	lsls	r1, r1, #31
    405c:	bmi.n	4096 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    405e:	and.w	r1, r4, #191	; 0xbf
    4062:	cmp	r1, #60	; 0x3c
    4064:	beq.n	4096 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
    4066:	cmp	r4, #92	; 0x5c
    4068:	bne.n	4086 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    406a:	b.n	4096 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x72>
      // Need to trim trailing dots spaces.
      fname->end = path;
    }
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
    406c:	cmp	r4, #47	; 0x2f
    406e:	bne.n	407c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x58>
    4070:	mov	r6, r1
    4072:	ldrb.w	r4, [r1], #1
    4076:	cmp	r4, #32
    4078:	bne.n	406c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x48>
    407a:	b.n	4070 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x4c>
  *ptr = path;
    407c:	str	r6, [r3, #0]
  return hashName(fname);
    407e:	mov	r1, r2

 fail:
  return false;
}
    4080:	pop	{r4, r5, r6, r7}
    }
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
  *ptr = path;
  return hashName(fname);
    4082:	b.w	3f10 <ExFatFile::hashName(ExName_t*)>
    uint8_t c = *path++;
    if (!lfnLegalChar(c)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (c != '.' && c != ' ') {
    4086:	cmp	r4, #46	; 0x2e
    4088:	bne.n	408e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x6a>
    408a:	mov	r1, r5
    408c:	b.n	403a <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x16>
    408e:	cmp	r4, #32
    4090:	beq.n	408a <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x66>
      // Need to trim trailing dots spaces.
      fname->end = path;
    4092:	str	r5, [r2, #8]
    4094:	b.n	408a <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x66>
  *ptr = path;
  return hashName(fname);

 fail:
  return false;
}
    4096:	movs	r0, #0
    4098:	pop	{r4, r5, r6, r7}
    409a:	bx	lr
    409c:	.word	0x31000101

000040a0 <ExFatFile::read(void*, unsigned int)>:
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    40a0:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    40a4:	ldrb.w	r3, [r0, #51]	; 0x33
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    40a8:	lsls	r7, r3, #31
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    40aa:	mov	r4, r0
    40ac:	mov	r6, r1
    40ae:	mov	r5, r2
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    40b0:	bpl.n	41a2 <ExFatFile::read(void*, unsigned int)+0x102>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isContiguous() || isFile()) {
    40b2:	lsls	r0, r3, #25
    40b4:	bmi.n	40be <ExFatFile::read(void*, unsigned int)+0x1e>
    40b6:	ldrb.w	r3, [r4, #49]	; 0x31
    40ba:	lsls	r1, r3, #28
    40bc:	bpl.n	40d8 <ExFatFile::read(void*, unsigned int)+0x38>
    if ((m_curPosition + count) > m_validLength) {
    40be:	ldrd	r0, r1, [r4]
    40c2:	ldrd	r2, r3, [r4, #16]
    40c6:	adds.w	r8, r0, r5
    40ca:	adc.w	r9, r1, #0
    40ce:	cmp	r3, r9
    40d0:	it	eq
    40d2:	cmpeq	r2, r8
    40d4:	bcs.n	40d8 <ExFatFile::read(void*, unsigned int)+0x38>
      count = toRead = m_validLength - m_curPosition;
    40d6:	subs	r5, r2, r0
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
    40d8:	mov	r9, r5
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
      } else if (isContiguous()) {
        m_curCluster++;
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    40da:	add.w	sl, r4, #24
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    40de:	cmp.w	r9, #0
    40e2:	beq.n	416c <ExFatFile::read(void*, unsigned int)+0xcc>
    clusterOffset = m_curPosition & m_vol->clusterMask();
    40e4:	ldr	r0, [r4, #32]
    40e6:	ldrd	r2, r3, [r4]
    40ea:	ldr.w	r1, [r0, #1080]	; 0x438
    40ee:	and.w	r8, r1, r2
    sectorOffset = clusterOffset & m_vol->sectorMask();
    40f2:	ubfx	fp, r8, #0, #9
    if (clusterOffset == 0) {
    40f6:	cmp.w	r8, #0
    40fa:	bne.n	413a <ExFatFile::read(void*, unsigned int)+0x9a>
      if (m_curPosition == 0) {
    40fc:	orrs	r3, r2
    40fe:	bne.n	4110 <ExFatFile::read(void*, unsigned int)+0x70>
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
    4100:	ldrb.w	r3, [r4, #49]	; 0x31
    4104:	lsls	r2, r3, #25
    4106:	ite	mi
    4108:	ldrmi.w	r3, [r0, #1076]	; 0x434
    410c:	ldrpl	r3, [r4, #28]
    410e:	b.n	411c <ExFatFile::read(void*, unsigned int)+0x7c>
      } else if (isContiguous()) {
    4110:	ldrb.w	r3, [r4, #51]	; 0x33
    4114:	lsls	r3, r3, #25
    4116:	bpl.n	4120 <ExFatFile::read(void*, unsigned int)+0x80>
        m_curCluster++;
    4118:	ldr	r3, [r4, #24]
    411a:	adds	r3, #1
    411c:	str	r3, [r4, #24]
    411e:	b.n	413a <ExFatFile::read(void*, unsigned int)+0x9a>
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    4120:	mov	r2, sl
    4122:	ldr	r1, [r4, #24]
    4124:	bl	48e8 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
        if (fg < 0) {
    4128:	cmp	r0, #0
    412a:	blt.n	41a2 <ExFatFile::read(void*, unsigned int)+0x102>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
    412c:	bne.n	413a <ExFatFile::read(void*, unsigned int)+0x9a>
          // EOF if directory.
          if (isDir()) {
    412e:	ldrb.w	r3, [r4, #49]	; 0x31
    4132:	tst.w	r3, #80	; 0x50
    4136:	bne.n	416c <ExFatFile::read(void*, unsigned int)+0xcc>
    4138:	b.n	41a2 <ExFatFile::read(void*, unsigned int)+0x102>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
    413a:	ldr	r7, [r4, #32]
             (clusterOffset >> m_vol->bytesPerSectorShift());
    413c:	ldr	r1, [r4, #24]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    413e:	ldrb.w	lr, [r7, #1093]	; 0x445
    4142:	ldr.w	r0, [r7, #1068]	; 0x42c
    4146:	subs	r1, #2
    4148:	lsl.w	r1, r1, lr
    414c:	mov.w	r2, r8, lsr #9
    4150:	add	r1, r0
    4152:	add.w	r8, r1, r2
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
    4156:	cmp.w	fp, #0
    415a:	bne.n	41fc <ExFatFile::read(void*, unsigned int)+0x15c>
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
    415c:	cmp.w	r9, #512	; 0x200
    4160:	bcc.n	41fc <ExFatFile::read(void*, unsigned int)+0x15c>
    4162:	ldr.w	r1, [r7, #540]	; 0x21c
                          || sector == m_vol->dataCacheSector()) {
    4166:	cmp	r8, r1
    4168:	bne.n	4174 <ExFatFile::read(void*, unsigned int)+0xd4>
    416a:	b.n	41fc <ExFatFile::read(void*, unsigned int)+0x15c>
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return count - toRead;
    416c:	rsb	r0, r9, r5
    4170:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    4174:	cmp.w	r9, #1024	; 0x400
    4178:	bcc.n	41d0 <ExFatFile::read(void*, unsigned int)+0x130>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      // Limit reads to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    417a:	movs	r3, #1
    417c:	lsl.w	r3, r3, lr
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    4180:	mov.w	fp, r9, lsr #9
      // Limit reads to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    4184:	subs	r2, r3, r2
    4186:	cmp	fp, r2
    4188:	it	cs
    418a:	movcs	fp, r2
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    418c:	cmp	r8, r1
    418e:	bhi.n	41b6 <ExFatFile::read(void*, unsigned int)+0x116>
    4190:	add.w	r3, fp, r8
    4194:	cmp	r1, r3
    4196:	bcs.n	41b6 <ExFatFile::read(void*, unsigned int)+0x116>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    4198:	add.w	r0, r7, #528	; 0x210
    419c:	bl	371e <FsCache::sync()>
    41a0:	cbnz	r0, 41b6 <ExFatFile::read(void*, unsigned int)+0x116>
    toRead -= n;
  }
  return count - toRead;

 fail:
  m_error |= READ_ERROR;
    41a2:	ldrb.w	r3, [r4, #50]	; 0x32
    41a6:	orr.w	r3, r3, #2
    41aa:	strb.w	r3, [r4, #50]	; 0x32
  return -1;
    41ae:	mov.w	r0, #4294967295
    41b2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    41b6:	ldr.w	r0, [r7, #532]	; 0x214
    41ba:	ldr	r3, [r0, #0]
    41bc:	mov	r2, r6
    41be:	ldr	r7, [r3, #16]
    41c0:	mov	r1, r8
    41c2:	mov	r3, fp
    41c4:	blx	r7
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
     if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    41c6:	cmp	r0, #0
    41c8:	beq.n	41a2 <ExFatFile::read(void*, unsigned int)+0x102>
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    41ca:	mov.w	r7, fp, lsl #9
    41ce:	b.n	41e6 <ExFatFile::read(void*, unsigned int)+0x146>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    41d0:	ldr.w	r0, [r7, #532]	; 0x214
    41d4:	ldr	r3, [r0, #0]
    41d6:	mov	r2, r6
    41d8:	ldr	r3, [r3, #12]
    41da:	mov	r1, r8
    41dc:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    41de:	cmp	r0, #0
    41e0:	beq.n	41a2 <ExFatFile::read(void*, unsigned int)+0x102>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    41e2:	mov.w	r7, #512	; 0x200
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    41e6:	ldrd	r2, r3, [r4]
    41ea:	adds	r2, r2, r7
    41ec:	adc.w	r3, r3, #0
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    41f0:	add	r6, r7
    m_curPosition += n;
    41f2:	strd	r2, r3, [r4]
    toRead -= n;
    41f6:	rsb	r9, r7, r9
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
    41fa:	b.n	40de <ExFatFile::read(void*, unsigned int)+0x3e>
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    41fc:	movs	r2, #0
    41fe:	mov	r1, r8
    4200:	add.w	r0, r7, #528	; 0x210
    4204:	bl	376a <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      cache = m_vol->dataCacheGet(sector, FsCache::CACHE_FOR_READ);
      if (!cache) {
    4208:	cmp	r0, #0
    420a:	beq.n	41a2 <ExFatFile::read(void*, unsigned int)+0x102>
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
      n = m_vol->bytesPerSector() - sectorOffset;
    420c:	rsb	r7, fp, #512	; 0x200
    4210:	cmp	r7, r9
    4212:	it	cs
    4214:	movcs	r7, r9
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
    4216:	add.w	r1, r0, fp
    421a:	mov	r2, r7
    421c:	mov	r0, r6
    421e:	bl	8e18 <memcpy>
    4222:	b.n	41e6 <ExFatFile::read(void*, unsigned int)+0x146>

00004224 <ExFatFile::peek()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int ExFatFile::peek() {
    4224:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    4226:	movs	r2, #1
    4228:	add.w	r1, sp, #7
    422c:	mov	r4, r0
  uint64_t curPosition = m_curPosition;
    422e:	ldrd	r6, r7, [r0]
  uint32_t curCluster = m_curCluster;
    4232:	ldr	r5, [r0, #24]
    4234:	bl	40a0 <ExFatFile::read(void*, unsigned int)>
    4238:	cmp	r0, #1
    423a:	it	eq
    423c:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
  m_curCluster = curCluster;
    4240:	str	r5, [r4, #24]
    4242:	it	ne
    4244:	movne.w	r0, #4294967295
//------------------------------------------------------------------------------
int ExFatFile::peek() {
  uint64_t curPosition = m_curPosition;
  uint32_t curCluster = m_curCluster;
  int c = read();
  m_curPosition = curPosition;
    4248:	strd	r6, r7, [r4]
  m_curCluster = curCluster;
  return c;
}
    424c:	add	sp, #12
    424e:	pop	{r4, r5, r6, r7, pc}

00004250 <ExFatFile::seekSet(unsigned long long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    4250:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4254:	ldrb.w	fp, [r0, #49]	; 0x31
    4258:	mov	r7, r3
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    425a:	ldr	r3, [r0, #24]
    425c:	str	r3, [sp, #4]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
    425e:	mov	r4, r0
    4260:	mov	r6, r2
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    4262:	cmp.w	fp, #0
    4266:	beq.n	4310 <ExFatFile::seekSet(unsigned long long)+0xc0>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    4268:	ldrd	r8, r9, [r0]
    426c:	cmp	r9, r7
    426e:	it	eq
    4270:	cmpeq	r8, r2
    4272:	beq.n	4318 <ExFatFile::seekSet(unsigned long long)+0xc8>
    return true;
  }
  if (pos == 0) {
    4274:	orrs.w	r3, r6, r7
    4278:	bne.n	4280 <ExFatFile::seekSet(unsigned long long)+0x30>
    // set position to start of file
    m_curCluster = 0;
    427a:	movs	r3, #0
    427c:	str	r3, [r0, #24]
    goto done;
    427e:	b.n	430a <ExFatFile::seekSet(unsigned long long)+0xba>
  }
  if (isFile()) {
    4280:	tst.w	fp, #8
    4284:	beq.n	4292 <ExFatFile::seekSet(unsigned long long)+0x42>
    if (pos > m_validLength) {
    4286:	ldrd	r0, r1, [r0, #16]
    428a:	cmp	r1, r7
    428c:	it	eq
    428e:	cmpeq	r0, r2
    4290:	bcc.n	4310 <ExFatFile::seekSet(unsigned long long)+0xc0>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    4292:	ldr	r3, [r4, #32]
    4294:	str	r3, [sp, #0]
    4296:	ldrb.w	sl, [r3, #1093]	; 0x445
    429a:	add.w	sl, sl, #9
    429e:	adds.w	r0, r6, #4294967295
    42a2:	uxtb.w	sl, sl
    42a6:	mov	r2, sl
    42a8:	adc.w	r1, r7, #4294967295
    42ac:	bl	a434 <__aeabi_llsr>
  if (isContiguous()) {
    42b0:	ldrb.w	r2, [r4, #51]	; 0x33
    42b4:	lsls	r3, r2, #25
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
    42b6:	mov	r5, r0
  if (isContiguous()) {
    42b8:	bpl.n	42c2 <ExFatFile::seekSet(unsigned long long)+0x72>
    m_curCluster = m_firstCluster + nNew;
    42ba:	ldr	r3, [r4, #28]
    42bc:	add	r5, r3
    42be:	str	r5, [r4, #24]
    goto done;
    42c0:	b.n	430a <ExFatFile::seekSet(unsigned long long)+0xba>
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
    42c2:	adds.w	r0, r8, #4294967295
    42c6:	adc.w	r1, r9, #4294967295
    42ca:	mov	r2, sl
    42cc:	bl	a434 <__aeabi_llsr>
  if (nNew < nCur || m_curPosition == 0) {
    42d0:	cmp	r5, r0
    42d2:	bcc.n	42da <ExFatFile::seekSet(unsigned long long)+0x8a>
    42d4:	orrs.w	r3, r8, r9
    42d8:	bne.n	42f0 <ExFatFile::seekSet(unsigned long long)+0xa0>
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
    42da:	tst.w	fp, #64	; 0x40
    42de:	itet	ne
    42e0:	ldrne	r3, [sp, #0]
    42e2:	ldreq	r3, [r4, #28]
    42e4:	ldrne.w	r3, [r3, #1076]	; 0x434
    42e8:	str	r3, [r4, #24]
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    42ea:	add.w	r8, r4, #24
    42ee:	b.n	4306 <ExFatFile::seekSet(unsigned long long)+0xb6>
  if (nNew < nCur || m_curPosition == 0) {
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    42f0:	subs	r5, r5, r0
    42f2:	b.n	42ea <ExFatFile::seekSet(unsigned long long)+0x9a>
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    42f4:	mov	r2, r8
    42f6:	ldr	r1, [r4, #24]
    42f8:	ldr	r0, [r4, #32]
    42fa:	bl	48e8 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    42fe:	cmp	r0, #0
    4300:	add.w	r5, r5, #4294967295
    4304:	ble.n	4310 <ExFatFile::seekSet(unsigned long long)+0xc0>
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    4306:	cmp	r5, #0
    4308:	bne.n	42f4 <ExFatFile::seekSet(unsigned long long)+0xa4>
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    430a:	strd	r6, r7, [r4]
    430e:	b.n	4318 <ExFatFile::seekSet(unsigned long long)+0xc8>
  return true;

 fail:
  m_curCluster = tmp;
    4310:	ldr	r3, [sp, #4]
    4312:	str	r3, [r4, #24]
  return false;
    4314:	movs	r0, #0
    4316:	b.n	431a <ExFatFile::seekSet(unsigned long long)+0xca>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    4318:	movs	r0, #1
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    431a:	add	sp, #12
    431c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00004320 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openPrivate(ExFatFile* dir, ExName_t* fname, oflag_t oflag) {
    4320:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4324:	mov	sl, r3
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
  bool inSet = false;

  // error if already open, no access mode, or no directory.
  if (isOpen() || !dir->isDir()) {
    4326:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openPrivate(ExFatFile* dir, ExName_t* fname, oflag_t oflag) {
    432a:	sub	sp, #52	; 0x34
    432c:	mov	r4, r0
    432e:	mov	r6, r1
    4330:	mov	r5, r2
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
  bool inSet = false;

  // error if already open, no access mode, or no directory.
  if (isOpen() || !dir->isDir()) {
    4332:	cbnz	r3, 4392 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    4334:	ldrb.w	r3, [r1, #49]	; 0x31
    4338:	tst.w	r3, #80	; 0x50
    433c:	beq.n	4392 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    DBG_FAIL_MACRO;
    goto fail;
  }

  switch (oflag & O_ACCMODE) {
    433e:	and.w	r3, sl, #3
    4342:	cmp	r3, #1
    4344:	beq.w	464c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x32c>
    4348:	cmp	r3, #2
    434a:	bne.w	4642 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x322>
      break;
    case O_WRONLY:
      modeFlags = FILE_FLAG_WRITE;
      break;
    case O_RDWR:
      modeFlags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    434e:	movs	r3, #3
      break;
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
    4350:	and.w	r9, sl, #8
    4354:	orr.w	r9, r9, r3

  if (fname) {
    4358:	cbz	r5, 439e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x7e>
    freeNeed = 2 + (fname->nameLength + 14)/15;
    435a:	ldr	r3, [r5, #16]
    435c:	mov.w	r8, #15
    4360:	adds	r3, #14
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    4362:	movs	r2, #0
    4364:	udiv	r8, r3, r8
    4368:	mov	r0, r6
    436a:	add.w	r8, r8, #2
    436e:	movs	r3, #0
    4370:	uxtb.w	r8, r8
    4374:	bl	4250 <ExFatFile::seekSet(unsigned long long)>
        }
        // Likely openNext call.
        DBG_WARN_MACRO;
        goto fail;
      }
      inSet = false;
    4378:	mov.w	fp, #0
    437c:	mov	r7, fp
    freeNeed = 2 + (fname->nameLength + 14)/15;
    dir->rewind();
  }

  while (1) {
    n = dir->read(buf, 32);
    437e:	movs	r2, #32
    4380:	add	r1, sp, #16
    4382:	mov	r0, r6
    4384:	bl	40a0 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    4388:	cmp	r0, #0
    438a:	beq.w	4506 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1e6>
      goto create;
    }
    if (n != 32) {
    438e:	cmp	r0, #32
    4390:	beq.n	43a4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x84>
  return sync();
#endif  // READ_ONLY

 fail:
  // close file
  m_attributes = FILE_ATTR_CLOSED;
    4392:	movs	r0, #0
    4394:	strb.w	r0, [r4, #49]	; 0x31
  m_flags = 0;
    4398:	strb.w	r0, [r4, #51]	; 0x33
  return false;
    439c:	b.n	4664 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
  DirFile_t*   dirFile;
  DirStream_t* dirStream;
  DirName_t*   dirName;
  uint8_t buf[32];
  uint8_t freeCount = 0;
  uint8_t freeNeed = 3;
    439e:	mov.w	r8, #3
    43a2:	b.n	4378 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x58>
    }
    if (n != 32) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(buf[0] & 0x80)) {
    43a4:	ldrb.w	r2, [sp, #16]
    43a8:	lsls	r1, r2, #24
    43aa:	bmi.n	43d0 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xb0>
      // Unused entry.
      if (freeCount == 0) {
    43ac:	cbnz	r7, 43b8 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x98>
        freePos.position = dir->curPosition() - 32;
    43ae:	ldr	r3, [r6, #0]
    43b0:	subs	r3, #32
    43b2:	str	r3, [sp, #4]
    43b4:	ldr	r3, [r6, #24]
    43b6:	str	r3, [sp, #0]
        freePos.cluster = dir->curCluster();
      }
      if (freeCount < freeNeed) {
    43b8:	cmp	r7, r8
        freeCount++;
    43ba:	itt	cc
    43bc:	addcc	r7, #1
    43be:	uxtbcc	r7, r7
      }
      if (!buf[0]) {
    43c0:	cbz	r2, 43c8 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa8>
      }
      if (fname->atEnd()) {
        goto found;
      }
    } else {
      inSet = false;
    43c2:	mov.w	fp, #0
    43c6:	b.n	437e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
      }
      if (freeCount < freeNeed) {
        freeCount++;
      }
      if (!buf[0]) {
        if (fname) {
    43c8:	cmp	r5, #0
    43ca:	bne.w	4506 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1e6>
    43ce:	b.n	4392 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
        // Likely openNext call.
        DBG_WARN_MACRO;
        goto fail;
      }
      inSet = false;
    } else if (!inSet) {
    43d0:	cmp.w	fp, #0
    43d4:	bne.n	4426 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x106>
      if (freeCount < freeNeed) {
        freeCount = 0;
    43d6:	cmp	r7, r8
    43d8:	it	cc
    43da:	movcc	r7, #0
      }
      if (buf[0] != EXFAT_TYPE_FILE) {
    43dc:	cmp	r2, #133	; 0x85
    43de:	bne.n	437e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
        continue;
      }
      inSet = true;
      memset(this, 0, sizeof(ExFatFile));
    43e0:	movs	r2, #56	; 0x38
    43e2:	mov	r1, fp
    43e4:	mov	r0, r4
    43e6:	bl	8fc0 <memset>
      dirFile = reinterpret_cast<DirFile_t*>(buf);
      m_setCount = dirFile->setCount;
      m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    43ea:	ldrb.w	r2, [sp, #20]
        continue;
      }
      inSet = true;
      memset(this, 0, sizeof(ExFatFile));
      dirFile = reinterpret_cast<DirFile_t*>(buf);
      m_setCount = dirFile->setCount;
    43ee:	ldrb.w	r3, [sp, #17]
    43f2:	strb.w	r3, [r4, #48]	; 0x30
      m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
    43f6:	and.w	r3, r2, #55	; 0x37
      if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
    43fa:	lsls	r2, r2, #27
        m_attributes |= FILE_ATTR_FILE;
    43fc:	it	pl
    43fe:	orrpl.w	r3, r3, #8
    4402:	strb.w	r3, [r4, #49]	; 0x31
    4406:	ldr	r3, [r6, #32]
      }
      m_vol = dir->volume();
    4408:	str	r3, [r4, #32]
    440a:	ldr	r3, [r6, #24]
      m_dirPos.cluster = dir->curCluster();
    440c:	str	r3, [r4, #36]	; 0x24
      m_dirPos.position = dir->curPosition() - 32;
    440e:	ldr	r3, [r6, #0]
    4410:	subs	r3, #32
    4412:	str	r3, [r4, #40]	; 0x28
      m_dirPos.isContiguous = dir->isContiguous();
    4414:	ldrb.w	r3, [r6, #51]	; 0x33
    4418:	ubfx	r3, r3, #6, #1
    441c:	strb.w	r3, [r4, #44]	; 0x2c
        freeCount = 0;
      }
      if (buf[0] != EXFAT_TYPE_FILE) {
        continue;
      }
      inSet = true;
    4420:	mov.w	fp, #1
    4424:	b.n	437e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
      }
      m_vol = dir->volume();
      m_dirPos.cluster = dir->curCluster();
      m_dirPos.position = dir->curPosition() - 32;
      m_dirPos.isContiguous = dir->isContiguous();
    } else if (buf[0] == EXFAT_TYPE_STREAM) {
    4426:	cmp	r2, #192	; 0xc0
    4428:	bne.n	4482 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x162>
      dirStream = reinterpret_cast<DirStream_t*>(buf);
      m_flags = modeFlags;
      if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    442a:	ldrb.w	r3, [sp, #17]
      m_dirPos.cluster = dir->curCluster();
      m_dirPos.position = dir->curPosition() - 32;
      m_dirPos.isContiguous = dir->isContiguous();
    } else if (buf[0] == EXFAT_TYPE_STREAM) {
      dirStream = reinterpret_cast<DirStream_t*>(buf);
      m_flags = modeFlags;
    442e:	strb.w	r9, [r4, #51]	; 0x33
      if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
    4432:	lsls	r0, r3, #30
        m_flags |= FILE_FLAG_CONTIGUOUS;
    4434:	itt	mi
    4436:	orrmi.w	r3, r9, #64	; 0x40
    443a:	strbmi.w	r3, [r4, #51]	; 0x33
      }
      m_validLength = getLe64(dirStream->validLength);
    443e:	ldrd	r2, r3, [sp, #24]
    4442:	strd	r2, r3, [r4, #16]
      m_firstCluster = getLe32(dirStream->firstCluster);
    4446:	ldr	r3, [sp, #36]	; 0x24
    4448:	str	r3, [r4, #28]
      m_dataLength = getLe64(dirStream->dataLength);
    444a:	ldrd	r2, r3, [sp, #40]	; 0x28
    444e:	strd	r2, r3, [r4, #8]
      if (!fname) {
    4452:	cbnz	r5, 445c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x13c>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    4454:	tst.w	sl, #2048	; 0x800
    4458:	bne.n	4392 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    445a:	b.n	44aa <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x18a>
  }
  void reset() {
    next = begin;
    445c:	ldr	r3, [r5, #0]
    445e:	str	r3, [r5, #4]
    ls = 0;
    4460:	mov.w	r3, #0
    4464:	strh	r3, [r5, #12]
      m_dataLength = getLe64(dirStream->dataLength);
      if (!fname) {
        goto found;
      }
      fname->reset();
      if (fname->nameLength != dirStream->nameLength ||
    4466:	ldr	r2, [r5, #16]
    4468:	ldrb.w	r3, [sp, #19]
    446c:	cmp	r2, r3
    446e:	bne.n	43c2 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa2>
    4470:	ldrh.w	r2, [sp, #20]
    4474:	ldrh	r3, [r5, #20]
    4476:	subs	r1, r2, r3
    4478:	rsbs	fp, r1, #0
    447c:	adc.w	fp, fp, r1
    4480:	b.n	437e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
          fname->nameHash != getLe16(dirStream->nameHash)) {
        inSet = false;
      }
    } else if (buf[0] == EXFAT_TYPE_NAME) {
    4482:	cmp	r2, #193	; 0xc1
    4484:	bne.n	43c2 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0xa2>
      dirName = reinterpret_cast<DirName_t*>(buf);
      if (!cmpName(dirName, fname)) {
    4486:	mov	r2, r5
    4488:	add	r1, sp, #16
    448a:	mov	r0, r4
    448c:	bl	3e14 <ExFatFile::cmpName(DirName_t const*, ExName_t*)>
    4490:	cbnz	r0, 4496 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x176>
        inSet = false;
    4492:	mov	fp, r0
    4494:	b.n	437e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    4496:	ldrh	r2, [r5, #12]
    4498:	cmp	r2, #0
    449a:	bne.w	437e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
    449e:	ldr	r1, [r5, #4]
    44a0:	ldr	r2, [r5, #8]
    44a2:	cmp	r1, r2
    44a4:	bne.w	437e <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x5e>
    44a8:	b.n	4454 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x134>
  if (oflag & O_EXCL) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Write, truncate, or at end is an error for a directory or read-only file.
  if ((oflag & (O_TRUNC | O_AT_END)) || (m_flags & FILE_FLAG_WRITE)) {
    44aa:	tst.w	sl, #17408	; 0x4400
    44ae:	bne.n	44b8 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x198>
    44b0:	ldrb.w	r3, [r4, #51]	; 0x33
    44b4:	lsls	r2, r3, #30
    44b6:	bpl.n	44c4 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1a4>
    if (isSubDir() || isReadOnly() || READ_ONLY) {
    44b8:	ldrb.w	r3, [r4, #49]	; 0x31
    44bc:	tst.w	r3, #17
    44c0:	bne.w	4392 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      goto fail;
    }
  }

#if !READ_ONLY
  if (oflag & O_TRUNC) {
    44c4:	tst.w	sl, #1024	; 0x400
    44c8:	beq.n	44ec <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1cc>
    if (!(m_flags & FILE_FLAG_WRITE)) {
    44ca:	ldrb.w	r3, [r4, #51]	; 0x33
    44ce:	lsls	r3, r3, #30
    44d0:	bpl.w	4392 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
    44d4:	movs	r2, #0
    44d6:	movs	r3, #0
    44d8:	mov	r0, r4
    44da:	bl	4250 <ExFatFile::seekSet(unsigned long long)>
    44de:	cmp	r0, #0
    44e0:	beq.w	4392 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    44e4:	mov	r0, r4
    44e6:	bl	5242 <ExFatFile::truncate()>
    44ea:	b.n	44fe <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1de>
    }
    if (!truncate(0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    44ec:	tst.w	sl, #16384	; 0x4000
    44f0:	beq.w	4650 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x330>
    44f4:	ldrd	r2, r3, [r4, #16]
    44f8:	mov	r0, r4
    44fa:	bl	4250 <ExFatFile::seekSet(unsigned long long)>
    44fe:	cmp	r0, #0
    4500:	beq.w	4392 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    4504:	b.n	4650 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x330>
#if READ_ONLY
  DBG_FAIL_MACRO;
  goto fail;
#else  // READ_ONLY
  // don't create unless O_CREAT and write
  if (!(oflag & O_CREAT) || !(modeFlags & FILE_FLAG_WRITE) || !fname) {
    4506:	tst.w	sl, #512	; 0x200
    450a:	beq.w	4392 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    450e:	tst.w	r9, #2
    4512:	beq.w	4392 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    4516:	cmp	r5, #0
    4518:	beq.w	4392 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    DBG_WARN_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    451c:	cmp	r7, r8
    451e:	bcs.n	455a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x23a>
    n = dir->read(buf, 32);
    4520:	movs	r2, #32
    4522:	add	r1, sp, #16
    4524:	mov	r0, r6
    4526:	bl	40a0 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    452a:	cbnz	r0, 4542 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x222>
      curCluster = dir->m_curCluster;
      if (!dir->addDirCluster()) {
    452c:	mov	r0, r6
    goto fail;
  }
  while (freeCount < freeNeed) {
    n = dir->read(buf, 32);
    if (n == 0) {
      curCluster = dir->m_curCluster;
    452e:	ldr.w	sl, [r6, #24]
      if (!dir->addDirCluster()) {
    4532:	bl	4ea6 <ExFatFile::addDirCluster()>
    4536:	cmp	r0, #0
    4538:	beq.w	4392 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
        DBG_FAIL_MACRO;
        goto fail;
      }
      dir->m_curCluster = curCluster;
    453c:	str.w	sl, [r6, #24]
      continue;
    4540:	b.n	451c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1fc>
    }
    if (n != 32) {
    4542:	cmp	r0, #32
    4544:	bne.w	4392 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (freeCount == 0) {
    4548:	cbnz	r7, 4554 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x234>
      freePos.position = dir->curPosition() - 32;
    454a:	ldr	r3, [r6, #0]
    454c:	subs	r3, #32
    454e:	str	r3, [sp, #4]
    4550:	ldr	r3, [r6, #24]
    4552:	str	r3, [sp, #0]
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
    4554:	adds	r7, #1
    4556:	uxtb	r7, r7
    4558:	b.n	451c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x1fc>
  }
  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
    455a:	movs	r2, #56	; 0x38
    455c:	movs	r1, #0
    455e:	mov	r0, r4
      freePos.position = dir->curPosition() - 32;
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }
  freePos.isContiguous = dir->isContiguous();
    4560:	ldrb.w	r7, [r6, #51]	; 0x33
  memset(this, 0, sizeof(ExFatFile));
    4564:	bl	8fc0 <memset>
    4568:	ldr	r3, [r6, #32]
  m_vol = dir->volume();
    456a:	str	r3, [r4, #32]
  m_attributes = FILE_ATTR_FILE;
    456c:	movs	r3, #8
    456e:	strb.w	r3, [r4, #49]	; 0x31
  m_dirPos = freePos;
    4572:	ldr	r3, [sp, #0]
    4574:	str	r3, [r4, #36]	; 0x24
      freePos.position = dir->curPosition() - 32;
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }
  freePos.isContiguous = dir->isContiguous();
    4576:	ubfx	r7, r7, #6, #1
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
    457a:	ldr	r3, [sp, #4]
    457c:	strb.w	r7, [r4, #44]	; 0x2c
    4580:	str	r3, [r4, #40]	; 0x28
  }
  void reset() {
    next = begin;
    4582:	ldr	r3, [r5, #0]
    4584:	str	r3, [r5, #4]
    ls = 0;
    4586:	movs	r7, #0
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    4588:	add.w	sl, r8, #4294967295
    458c:	strh	r7, [r5, #12]
    458e:	uxtb.w	sl, sl
    4592:	uxtb.w	fp, r7
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  fname->reset();
  for (uint8_t i = 0; i < freeNeed; i++) {
    4596:	cmp	fp, r8
    4598:	bcs.n	463a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x31a>
    cache = dirCache(i, FsCache::CACHE_FOR_WRITE);
    459a:	movs	r2, #1
    459c:	mov	r1, fp
    459e:	mov	r0, r4
    45a0:	bl	3f72 <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache || (cache[0] & 0x80)) {
    45a4:	mov	r6, r0
    45a6:	cmp	r0, #0
    45a8:	beq.w	4392 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    45ac:	ldrsb.w	r2, [r0]
    45b0:	cmp	r2, #0
    45b2:	blt.w	4392 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memset(cache, 0 , 32);
    45b6:	movs	r2, #32
    45b8:	movs	r1, #0
    45ba:	bl	8fc0 <memset>
    if (i == 0) {
    45be:	cmp.w	fp, #0
    45c2:	bne.n	4602 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x2e2>
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
    45c4:	movs	r3, #133	; 0x85
    45c6:	strb	r3, [r6, #0]
      m_setCount = freeNeed - 1;
      dirFile->setCount = m_setCount;

      if (FsDateTime::callback) {
    45c8:	ldr	r3, [pc, #160]	; (466c <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x34c>)
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
    45ca:	strb.w	sl, [r4, #48]	; 0x30
      dirFile->setCount = m_setCount;
    45ce:	strb.w	sl, [r6, #1]

      if (FsDateTime::callback) {
    45d2:	ldr	r3, [r3, #0]
    45d4:	cbz	r3, 45f6 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x2d6>
        uint16_t date, time;
        uint8_t ms10;
        FsDateTime::callback(&date, &time, &ms10);
    45d6:	add.w	r2, sp, #11
    45da:	add.w	r1, sp, #14
    45de:	add	r0, sp, #12
    45e0:	blx	r3
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    45e2:	ldrh.w	r3, [sp, #12]
    45e6:	strh	r3, [r6, #10]
    45e8:	ldrh.w	r3, [sp, #14]
    45ec:	strh	r3, [r6, #8]
        setLe16(dirFile->createDate, date);
        setLe16(dirFile->createTime, time);
        dirFile->createTimeMs = ms10;
    45ee:	ldrb.w	r3, [sp, #11]
    45f2:	strb	r3, [r6, #20]
    45f4:	b.n	4636 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
    45f6:	movw	r3, #21537	; 0x5421
    45fa:	strh	r3, [r6, #10]
    45fc:	strh	r3, [r6, #14]
    45fe:	strh	r3, [r6, #18]
    4600:	b.n	4636 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
         setLe16(dirFile->createTime, FS_DEFAULT_TIME);
         setLe16(dirFile->modifyTime, FS_DEFAULT_TIME);
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
    4602:	cmp.w	fp, #1
    4606:	bne.n	4622 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x302>
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
      dirStream->flags = EXFAT_FLAG_ALWAYS1;
      m_flags = modeFlags | FILE_FLAG_DIR_DIRTY;
    4608:	orn	r3, r9, #127	; 0x7f
         setLe16(dirFile->accessTime, FS_DEFAULT_TIME);
       }
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
    460c:	movs	r2, #192	; 0xc0
    460e:	strb	r2, [r6, #0]
      dirStream->flags = EXFAT_FLAG_ALWAYS1;
    4610:	strb.w	fp, [r6, #1]
      m_flags = modeFlags | FILE_FLAG_DIR_DIRTY;
    4614:	strb.w	r3, [r4, #51]	; 0x33
      dirStream->nameLength = fname->nameLength;
    4618:	ldr	r3, [r5, #16]
    461a:	strb	r3, [r6, #3]
      setLe16(dirStream->nameHash, fname->nameHash);
    461c:	ldrh	r3, [r5, #20]
    461e:	strh	r3, [r6, #4]
    4620:	b.n	4636 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
    } else {
      dirName = reinterpret_cast<DirName_t*>(cache);
      dirName->type = EXFAT_TYPE_NAME;
    4622:	movs	r3, #193	; 0xc1
    4624:	strb	r3, [r6, #0]
    4626:	add.w	fp, r6, #30
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    462a:	ldrh	r2, [r5, #12]
    462c:	cbnz	r2, 4654 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x334>
    462e:	ldr	r1, [r5, #4]
    4630:	ldr	r2, [r5, #8]
    4632:	cmp	r1, r2
    4634:	bne.n	4654 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x334>
    4636:	adds	r7, #1
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  fname->reset();
  for (uint8_t i = 0; i < freeNeed; i++) {
    4638:	b.n	4592 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x272>
        uint16_t u = fname->get16();
        setLe16(dirName->unicode + 2*k, u);
      }
    }
  }
  return sync();
    463a:	mov	r0, r4
    463c:	bl	4e68 <ExFatFile::sync()>
    4640:	b.n	4664 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
  if (isOpen() || !dir->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }

  switch (oflag & O_ACCMODE) {
    4642:	cmp	r3, #0
    4644:	bne.w	4392 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x72>
    case O_RDONLY:
      modeFlags = FILE_FLAG_READ;
    4648:	movs	r3, #1
    464a:	b.n	4350 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30>
      break;
    case O_WRONLY:
      modeFlags = FILE_FLAG_WRITE;
    464c:	movs	r3, #2
    464e:	b.n	4350 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30>
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
    DBG_FAIL_MACRO;
    goto fail;
  }
#endif  // !READ_ONLY
  return true;
    4650:	movs	r0, #1
    4652:	b.n	4664 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x344>
      dirName->type = EXFAT_TYPE_NAME;
      for (size_t k = 0; k < 15; k++) {
        if (fname->atEnd()) {
          break;
        }
        uint16_t u = fname->get16();
    4654:	mov	r0, r5
    4656:	bl	385c <FsName::get16()>
    465a:	strh.w	r0, [r6, #2]!
      dirStream->nameLength = fname->nameLength;
      setLe16(dirStream->nameHash, fname->nameHash);
    } else {
      dirName = reinterpret_cast<DirName_t*>(cache);
      dirName->type = EXFAT_TYPE_NAME;
      for (size_t k = 0; k < 15; k++) {
    465e:	cmp	r6, fp
    4660:	bne.n	462a <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x30a>
    4662:	b.n	4636 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)+0x316>
 fail:
  // close file
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
    4664:	add	sp, #52	; 0x34
    4666:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    466a:	nop
    466c:	.word	0x2001ceb4

00004670 <ExFatFile::open(ExFatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
    4670:	push	{r4, r5, r6, r7, lr}
    4672:	sub	sp, #92	; 0x5c
    4674:	mov	r7, r3
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    4676:	movs	r3, #0
    4678:	strb.w	r3, [sp, #81]	; 0x51
    467c:	strb.w	r3, [sp, #82]	; 0x52
    4680:	strb.w	r3, [sp, #83]	; 0x53
 */
/**
 * \class FsName
 * \brief Handle UTF-8 file names.
 */
class FsName {
    4684:	strh.w	r3, [sp, #20]
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    4688:	ldrb.w	r3, [r0, #49]	; 0x31
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
    468c:	str	r2, [sp, #4]
    468e:	mov	r5, r0
    4690:	mov	r4, r1
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    4692:	cbz	r3, 4698 <ExFatFile::open(ExFatFile*, char const*, int)+0x28>
    close();
  }
  return openPrivate(dirFile, &fname, oflag);

 fail:
  return false;
    4694:	movs	r0, #0
    4696:	b.n	4726 <ExFatFile::open(ExFatFile*, char const*, int)+0xb6>
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const char* path, oflag_t oflag) {
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    4698:	ldrb.w	r3, [r1, #49]	; 0x31
    469c:	tst.w	r3, #80	; 0x50
    46a0:	beq.n	4694 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    46a2:	ldrb	r3, [r2, #0]
    46a4:	cmp	r3, #47	; 0x2f
    46a6:	bne.n	46ce <ExFatFile::open(ExFatFile*, char const*, int)+0x5e>
    while (isDirSeparator(*path)) {
    46a8:	ldr	r3, [sp, #4]
    46aa:	ldrb	r2, [r3, #0]
    46ac:	cmp	r2, #47	; 0x2f
    46ae:	bne.n	46b6 <ExFatFile::open(ExFatFile*, char const*, int)+0x46>
      path++;
    46b0:	adds	r3, #1
    46b2:	str	r3, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    46b4:	b.n	46a8 <ExFatFile::open(ExFatFile*, char const*, int)+0x38>
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    46b6:	ldr	r1, [r4, #32]
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
    46b8:	cbnz	r2, 46c2 <ExFatFile::open(ExFatFile*, char const*, int)+0x52>
      return openRoot(dirFile->m_vol);
    46ba:	mov	r0, r5
    46bc:	bl	3ffe <ExFatFile::openRoot(ExFatVolume*)>
    46c0:	b.n	4726 <ExFatFile::open(ExFatFile*, char const*, int)+0xb6>
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    46c2:	add	r0, sp, #32
    46c4:	bl	3ffe <ExFatFile::openRoot(ExFatVolume*)>
    46c8:	cmp	r0, #0
    46ca:	beq.n	4694 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    46cc:	add	r4, sp, #32
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    46ce:	add	r3, sp, #4
    46d0:	add	r2, sp, #8
    46d2:	ldr	r1, [sp, #4]
    46d4:	mov	r0, r5
    46d6:	bl	4024 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    46da:	cmp	r0, #0
    46dc:	beq.n	4694 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    46de:	ldr	r3, [sp, #4]
    46e0:	ldrb	r3, [r3, #0]
    46e2:	cbz	r3, 471a <ExFatFile::open(ExFatFile*, char const*, int)+0xaa>
      break;
    }
    if (!openPrivate(dirFile, &fname, O_RDONLY)) {
    46e4:	movs	r3, #0
    46e6:	add	r2, sp, #8
    46e8:	mov	r1, r4
    46ea:	mov	r0, r5
    46ec:	bl	4320 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    46f0:	cmp	r0, #0
    46f2:	beq.n	4694 <ExFatFile::open(ExFatFile*, char const*, int)+0x24>
      DBG_WARN_MACRO;
      goto fail;
    }
    tmpDir = *this;
    46f4:	add	r2, sp, #32
    46f6:	mov	r3, r5
    46f8:	add.w	lr, r5, #48	; 0x30
    46fc:	mov	r4, r2
    46fe:	ldr	r0, [r3, #0]
    4700:	ldr	r1, [r3, #4]
    4702:	mov	r6, r2
    4704:	stmia	r6!, {r0, r1}
    4706:	adds	r3, #8
    4708:	cmp	r3, lr
    470a:	mov	r2, r6
    470c:	bne.n	46fe <ExFatFile::open(ExFatFile*, char const*, int)+0x8e>
    470e:	ldr	r0, [r3, #0]
    4710:	str	r0, [r6, #0]
    dirFile = &tmpDir;
    close();
    4712:	mov	r0, r5
    4714:	bl	3faa <ExFatFile::close()>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    4718:	b.n	46ce <ExFatFile::open(ExFatFile*, char const*, int)+0x5e>
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    close();
  }
  return openPrivate(dirFile, &fname, oflag);
    471a:	mov	r3, r7
    471c:	add	r2, sp, #8
    471e:	mov	r1, r4
    4720:	mov	r0, r5
    4722:	bl	4320 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>

 fail:
  return false;
}
    4726:	add	sp, #92	; 0x5c
    4728:	pop	{r4, r5, r6, r7, pc}

0000472a <ExFatFile::open(ExFatVolume*, char const*, int)>:
bool ExFatFile::open(const char* path, oflag_t oflag) {
  return open(ExFatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
    472a:	cbz	r1, 4734 <ExFatFile::open(ExFatVolume*, char const*, int)+0xa>
    472c:	add.w	r1, r1, #1096	; 0x448
    4730:	b.w	4670 <ExFatFile::open(ExFatFile*, char const*, int)>
}
    4734:	mov	r0, r1
    4736:	bx	lr

00004738 <ExFatFile::openNext(ExFatFile*, int)>:
    DBG_FAIL_MACRO;
  }
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
    4738:	push	{r4, r5}
    473a:	mov	r3, r2
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    473c:	ldrb.w	r2, [r0, #49]	; 0x31
    4740:	cbnz	r2, 4760 <ExFatFile::openNext(ExFatFile*, int)+0x28>
    4742:	ldrb.w	r5, [r1, #49]	; 0x31
    4746:	tst.w	r5, #80	; 0x50
    474a:	beq.n	4760 <ExFatFile::openNext(ExFatFile*, int)+0x28>
    474c:	ldrd	r4, r5, [r1]
    4750:	movs	r5, #0
    4752:	and.w	r4, r4, #31
    4756:	orrs	r4, r5
    4758:	bne.n	4760 <ExFatFile::openNext(ExFatFile*, int)+0x28>
  }
  return openPrivate(dir, nullptr, oflag);

 fail:
  return false;
}
    475a:	pop	{r4, r5}
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return openPrivate(dir, nullptr, oflag);
    475c:	b.w	4320 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>

 fail:
  return false;
}
    4760:	movs	r0, #0
    4762:	pop	{r4, r5}
    4764:	bx	lr

00004766 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>:
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"

//------------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
    4766:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    476a:	mov	r8, r0
    476c:	mov	sl, r2
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
    476e:	mov	r9, r1
    4770:	cbz	r1, 4776 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x10>
    4772:	subs	r4, r1, #2
    4774:	b.n	477a <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x14>
    4776:	ldr.w	r4, [r0, #1056]	; 0x420
  if (start >= m_clusterCount) {
    477a:	ldr.w	r3, [r8, #1072]	; 0x430
    start = 0;
    477e:	cmp	r4, r3
    4780:	it	cs
    4782:	movcs	r4, #0
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
  uint16_t sectorSize = 1 << m_bytesPerSectorShift;
  size_t i = (start >> 3) & (sectorSize - 1);
  uint8_t* cache;
  uint8_t mask = 1 << (start & 7);
    4784:	and.w	r7, r4, #7
    4788:	movs	r3, #1
    478a:	lsl.w	r7, r3, r7
    start = 0;
  }
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
  uint16_t sectorSize = 1 << m_bytesPerSectorShift;
  size_t i = (start >> 3) & (sectorSize - 1);
    478e:	ubfx	fp, r4, #3, #9
  uint8_t* cache;
  uint8_t mask = 1 << (start & 7);
    4792:	uxtb	r7, r7
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
  }
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
    4794:	mov	r6, r4
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
  }
  uint32_t endAlloc = start;
    4796:	mov	r5, r4
  bool bitmapModify(uint32_t cluster, uint32_t count, bool value);
  //----------------------------------------------------------------------------
  // Cache functions.
  uint8_t* bitmapCacheGet(uint32_t sector, uint8_t option) {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.get(sector, option);
    4798:	ldr.w	r1, [r8, #1068]	; 0x42c
    479c:	movs	r2, #0
    479e:	add.w	r1, r1, r5, lsr #12
    47a2:	mov	r0, r8
    47a4:	bl	376a <FsCache::get(unsigned long, unsigned char)>
  uint8_t mask = 1 << (start & 7);
  while (true) {
    uint32_t sector = m_clusterHeapStartSector +
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
    47a8:	cbz	r0, 4808 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0xa2>
    47aa:	mov	r3, r7
    47ac:	mov	r1, fp
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
    47ae:	ldrb	r7, [r0, r1]
    47b0:	tst	r7, r3
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
    47b2:	add.w	r5, r5, #1
        if (!(mask & cache[i])) {
    47b6:	bne.n	47d4 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x6e>
          if ((endAlloc - bgnAlloc) == count) {
    47b8:	subs	r2, r5, r6
    47ba:	cmp	r2, sl
    47bc:	bne.n	47d6 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x70>
            if (cluster == 0 && count == 1) {
    47be:	cmp.w	r9, #0
    47c2:	bne.n	47ce <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x68>
    47c4:	cmp.w	sl, #1
              // Start at found sector.  bitmapModify may increase this.
              m_bitmapStart = bgnAlloc;
    47c8:	it	eq
    47ca:	streq.w	r6, [r8, #1056]	; 0x420
            }
            return bgnAlloc + 2;
    47ce:	adds	r0, r6, #2
    47d0:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
    47d4:	mov	r6, r5
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    47d6:	cmp	r4, r5
    47d8:	beq.n	4806 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0xa0>
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
    47da:	ldr.w	r2, [r8, #1072]	; 0x430
    47de:	cmp	r5, r2
    47e0:	bcs.n	47ec <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x86>
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
    47e2:	lsls	r3, r3, #1
    47e4:	ands.w	r3, r3, #255	; 0xff
    47e8:	bne.n	47b0 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x4a>
    47ea:	b.n	47f4 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x8e>
        }
        if (endAlloc == start) {
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
          endAlloc = bgnAlloc = 0;
    47ec:	movs	r6, #0
          i = sectorSize;
    47ee:	mov.w	r1, #512	; 0x200
        }
        if (endAlloc == start) {
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
          endAlloc = bgnAlloc = 0;
    47f2:	mov	r5, r6
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    47f4:	adds	r1, #1
    47f6:	movs	r3, #1
    47f8:	cmp.w	r1, #512	; 0x200
          break;
        }
      }
      mask = 1;
    }
    i = 0;
    47fc:	mov.w	fp, #0
          endAlloc = bgnAlloc = 0;
          i = sectorSize;
          break;
        }
      }
      mask = 1;
    4800:	mov	r7, r3
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    4802:	bcc.n	47ae <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x48>
    4804:	b.n	4798 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x32>
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
          return 1;
    4806:	movs	r0, #1
      mask = 1;
    }
    i = 0;
  }
  return 0;
}
    4808:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000480c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>:
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    480c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4810:	mov	r7, r2
    4812:	mov	r6, r0
  uint32_t sector;
  uint32_t start = cluster - 2;
    4814:	subs	r2, r1, #2
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    4816:	ldr.w	r0, [r0, #1072]	; 0x430
    481a:	adds	r1, r2, r7
    481c:	cmp	r1, r0
  }
  return 0;
}
//------------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    481e:	mov	r8, r3
  uint32_t start = cluster - 2;
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    4820:	bhi.n	48a6 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
    4822:	ldr.w	r3, [r6, #1056]	; 0x420
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    4826:	cmp.w	r8, #0
    482a:	beq.n	4840 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x34>
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
    482c:	cmp	r2, r3
    482e:	bhi.n	4848 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
    4830:	cmp	r1, r3
    4832:	bls.n	4848 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
      m_bitmapStart = (start + count) < m_clusterCount ? start + count : 0;
    4834:	cmp	r1, r0
    4836:	it	cs
    4838:	movcs	r1, #0
    483a:	str.w	r1, [r6, #1056]	; 0x420
    483e:	b.n	4848 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x3c>
    }
  } else {
    if (start < m_bitmapStart) {
    4840:	cmp	r2, r3
      m_bitmapStart = start;
    4842:	it	cc
    4844:	strcc.w	r2, [r6, #1056]	; 0x420
    }
  }
  mask = 1 << (start & 7);
    4848:	and.w	r5, r2, #7
    484c:	movs	r3, #1
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    484e:	ldr.w	r1, [r6, #1068]	; 0x42c
  } else {
    if (start < m_bitmapStart) {
      m_bitmapStart = start;
    }
  }
  mask = 1 << (start & 7);
    4852:	lsl.w	r5, r3, r5
    4856:	uxtb	r5, r5
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    4858:	add.w	r1, r1, r2, lsr #12
  i = (start >> 3) & m_sectorMask;
    485c:	ubfx	r4, r2, #3, #9
    4860:	movs	r2, #1
    4862:	mov	r0, r6
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    4864:	add.w	r9, r1, #1
    4868:	bl	376a <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    486c:	cbz	r0, 48a6 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
    486e:	adds	r3, r0, r4
    4870:	mov	r2, r5
    4872:	add.w	r0, r0, #512	; 0x200
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
    4876:	ldrb	r1, [r3, #0]
    4878:	tst	r1, r2
    487a:	ite	ne
    487c:	movne	r4, #1
    487e:	moveq	r4, #0
    4880:	cmp	r4, r8
    4882:	beq.n	48a6 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9a>
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    4884:	eors	r1, r2
        if (--count == 0) {
    4886:	subs	r7, #1
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    4888:	strb	r1, [r3, #0]
        if (--count == 0) {
    488a:	beq.n	48ac <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0xa0>
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
    488c:	lsls	r2, r2, #1
    488e:	ands.w	r2, r2, #255	; 0xff
    4892:	bne.n	4876 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x6a>
    4894:	adds	r3, #1
          return true;
        }
      }
      mask = 1;
    }
    i = 0;
    4896:	mov	r4, r2
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    4898:	cmp	r0, r3
    489a:	mov.w	r2, #1
  mask = 1 << (start & 7);
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
  i = (start >> 3) & m_sectorMask;
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    489e:	mov	r1, r9
        cache[i] ^= mask;
        if (--count == 0) {
          return true;
        }
      }
      mask = 1;
    48a0:	mov	r5, r2
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    48a2:	bne.n	4876 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x6a>
    48a4:	b.n	4860 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x54>
    }
    i = 0;
  }

 fail:
  return false;
    48a6:	movs	r0, #0
    48a8:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
        if (--count == 0) {
          return true;
    48ac:	movs	r0, #1
    i = 0;
  }

 fail:
  return false;
}
    48ae:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000048b2 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>:
    n++;
  } while (status);
  return n;
}
//------------------------------------------------------------------------------
uint8_t* ExFatPartition::dirCache(DirPos_t* pos, uint8_t options) {
    48b2:	push	{r3, r4, r5, lr}
    48b4:	mov	r5, r1
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    48b6:	ldr.w	r1, [r0, #1080]	; 0x438
    48ba:	ldr	r3, [r5, #4]
    48bc:	ands	r1, r3
    48be:	ldr	r3, [r5, #0]
    48c0:	subs	r4, r3, #2
    48c2:	ldrb.w	r3, [r0, #1093]	; 0x445
    48c6:	lsl.w	r3, r4, r3
    48ca:	add.w	r3, r3, r1, lsr #9
    48ce:	ldr.w	r1, [r0, #1068]	; 0x42c
    48d2:	add.w	r0, r0, #528	; 0x210
    48d6:	add	r1, r3
    48d8:	bl	376a <FsCache::get(unsigned long, unsigned char)>
  uint32_t sector = clusterStartSector(pos->cluster);
  sector += (m_clusterMask & pos->position) >> m_bytesPerSectorShift;
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
    48dc:	cbz	r0, 48e6 <ExFatPartition::dirCache(DirPos_t*, unsigned char)+0x34>
    48de:	ldr	r3, [r5, #4]
    48e0:	ubfx	r3, r3, #0, #9
    48e4:	add	r0, r3
}
    48e6:	pop	{r3, r4, r5, pc}

000048e8 <ExFatPartition::fatGet(unsigned long, unsigned long*)>:
  }
  return 1;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    48e8:	push	{r3, r4, r5, lr}
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    48ea:	ldr.w	r3, [r0, #1072]	; 0x430
    48ee:	adds	r3, #1
    48f0:	cmp	r3, r1
  }
  return 1;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    48f2:	mov	r4, r1
    48f4:	mov	r5, r2
  uint8_t* cache;
  uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    48f6:	bcs.n	48fe <ExFatPartition::fatGet(unsigned long, unsigned long*)+0x16>
    DBG_FAIL_MACRO;
    return -1;
    48f8:	mov.w	r0, #4294967295
    48fc:	pop	{r3, r4, r5, pc}
    48fe:	ldr.w	r1, [r0, #1060]	; 0x424
    4902:	movs	r2, #0
    4904:	add.w	r1, r1, r4, lsr #7
    4908:	add.w	r0, r0, #528	; 0x210
    490c:	bl	376a <FsCache::get(unsigned long, unsigned char)>
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));

  cache = dataCacheGet(sector, FsCache::CACHE_FOR_READ);
  if (!cache) {
    4910:	cmp	r0, #0
    4912:	beq.n	48f8 <ExFatPartition::fatGet(unsigned long, unsigned long*)+0x10>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    4914:	lsls	r4, r4, #2
    4916:	ubfx	r4, r4, #0, #9
    491a:	ldr	r0, [r0, r4]
    return -1;
  }
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));
  *value = next;
    491c:	str	r0, [r5, #0]
  return next == EXFAT_EOC ? 0 : 1;
    491e:	adds	r0, #1
    4920:	it	ne
    4922:	movne	r0, #1
}
    4924:	pop	{r3, r4, r5, pc}

00004926 <ExFatPartition::chainSize(unsigned long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
    4926:	push	{r0, r1, r4, r5, r6, lr}
    4928:	add	r5, sp, #8
    492a:	mov	r6, r0
    492c:	str.w	r1, [r5, #-4]!
  uint32_t n = 0;
    4930:	movs	r4, #0
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    4932:	mov	r2, r5
    4934:	ldr	r1, [sp, #4]
    4936:	mov	r0, r6
    4938:	bl	48e8 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    if (status < 0) return 0;
    493c:	cmp	r0, #0
    493e:	blt.n	494a <ExFatPartition::chainSize(unsigned long)+0x24>
    n++;
    4940:	add.w	r4, r4, #1
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    4944:	bne.n	4932 <ExFatPartition::chainSize(unsigned long)+0xc>
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    n++;
    4946:	mov	r0, r4
    4948:	b.n	494c <ExFatPartition::chainSize(unsigned long)+0x26>
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    494a:	movs	r0, #0
    n++;
  } while (status);
  return n;
}
    494c:	add	sp, #8
    494e:	pop	{r4, r5, r6, pc}

00004950 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>:
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    4950:	push	{r4, r5, r6, lr}
    4952:	mov	r5, r1
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    4954:	ldr.w	r4, [r0, #1080]	; 0x438
    4958:	ldr	r1, [r1, #4]
    495a:	ands	r4, r1
    495c:	adds	r3, r4, r2
  pos->position += offset;
    495e:	add	r2, r1
    4960:	str	r2, [r5, #4]
  tmp >>= bytesPerClusterShift();
    4962:	ldrb.w	r4, [r0, #1093]	; 0x445
    4966:	adds	r4, #9
    4968:	uxtb	r4, r4
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//------------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    496a:	mov	r6, r0
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
    496c:	lsr.w	r4, r3, r4
  while (tmp--) {
    4970:	cbz	r4, 4990 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x40>
    if (pos->isContiguous) {
    4972:	ldrb	r3, [r5, #8]
    4974:	cbz	r3, 4980 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x30>
      pos->cluster++;
    4976:	ldr	r3, [r5, #0]
    4978:	adds	r3, #1
    497a:	str	r3, [r5, #0]
    497c:	subs	r4, #1
    497e:	b.n	4970 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x20>
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    4980:	mov	r2, r5
    4982:	ldr	r1, [r5, #0]
    4984:	mov	r0, r6
    4986:	bl	48e8 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
      if (status != 1) {
    498a:	cmp	r0, #1
    498c:	beq.n	497c <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x2c>
    498e:	pop	{r4, r5, r6, pc}
        return status;
      }
    }
  }
  return 1;
    4990:	movs	r0, #1
}
    4992:	pop	{r4, r5, r6, pc}

00004994 <ExFatPartition::fatPut(unsigned long, unsigned long)>:
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    4994:	cmp	r1, #1
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));
  *value = next;
  return next == EXFAT_EOC ? 0 : 1;
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
    4996:	push	{r3, r4, r5, lr}
    4998:	mov	r4, r1
    499a:	mov	r5, r2
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    499c:	bhi.n	49a2 <ExFatPartition::fatPut(unsigned long, unsigned long)+0xe>
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;

 fail:
  return false;
    499e:	movs	r0, #0
    49a0:	pop	{r3, r4, r5, pc}
}
//------------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    49a2:	ldr.w	r3, [r0, #1072]	; 0x430
    49a6:	adds	r3, #1
    49a8:	cmp	r1, r3
    49aa:	bhi.n	499e <ExFatPartition::fatPut(unsigned long, unsigned long)+0xa>
    49ac:	ldr.w	r1, [r0, #1060]	; 0x424
    49b0:	movs	r2, #1
    49b2:	add.w	r1, r1, r4, lsr #7
    49b6:	add.w	r0, r0, #528	; 0x210
    49ba:	bl	376a <FsCache::get(unsigned long, unsigned char)>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
  cache = dataCacheGet(sector, FsCache::CACHE_FOR_WRITE);
  if (!cache) {
    49be:	cmp	r0, #0
    49c0:	beq.n	499e <ExFatPartition::fatPut(unsigned long, unsigned long)+0xa>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    49c2:	lsls	r4, r4, #2
    49c4:	ubfx	r4, r4, #0, #9
    49c8:	str	r5, [r0, r4]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;
    49ca:	movs	r0, #1

 fail:
  return false;
}
    49cc:	pop	{r3, r4, r5, pc}

000049ce <ExFatPartition::freeChain(unsigned long)>:
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
    49ce:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    49d2:	mov	r7, r0
    49d4:	mov	r4, r1
  uint32_t next;
  uint32_t start = cluster;
    49d6:	mov	r6, r1
  int8_t status;
  do {
    status = fatGet(cluster, &next);
    49d8:	add	r2, sp, #4
    49da:	mov	r1, r4
    49dc:	mov	r0, r7
    49de:	bl	48e8 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    if (status < 0) {
    49e2:	subs.w	r8, r0, #0
    49e6:	bge.n	49ec <ExFatPartition::freeChain(unsigned long)+0x1e>
  } while (status);

  return true;

 fail:
  return false;
    49e8:	movs	r5, #0
    49ea:	b.n	4a24 <ExFatPartition::freeChain(unsigned long)+0x56>
    status = fatGet(cluster, &next);
    if (status < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!fatPut(cluster, 0)) {
    49ec:	movs	r2, #0
    49ee:	mov	r1, r4
    49f0:	mov	r0, r7
    49f2:	bl	4994 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    49f6:	mov	r5, r0
    49f8:	cmp	r0, #0
    49fa:	beq.n	49e8 <ExFatPartition::freeChain(unsigned long)+0x1a>
    49fc:	adds	r2, r4, #1
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (status == 0 || (cluster + 1) != next) {
    49fe:	cmp.w	r8, #0
    4a02:	beq.n	4a0a <ExFatPartition::freeChain(unsigned long)+0x3c>
    4a04:	ldr	r3, [sp, #4]
    4a06:	cmp	r2, r3
    4a08:	beq.n	4a1c <ExFatPartition::freeChain(unsigned long)+0x4e>
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    4a0a:	movs	r3, #0
    4a0c:	subs	r2, r2, r6
    4a0e:	mov	r1, r6
    4a10:	mov	r0, r7
    4a12:	bl	480c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4a16:	cmp	r0, #0
    4a18:	beq.n	49e8 <ExFatPartition::freeChain(unsigned long)+0x1a>
        DBG_FAIL_MACRO;
        goto fail;
      }
      start = next;
    4a1a:	ldr	r6, [sp, #4]
    }
    cluster = next;
    4a1c:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  uint32_t start = cluster;
  int8_t status;
  do {
    4a1e:	cmp.w	r8, #0
    4a22:	bne.n	49d8 <ExFatPartition::freeChain(unsigned long)+0xa>

  return true;

 fail:
  return false;
}
    4a24:	mov	r0, r5
    4a26:	add	sp, #8
    4a28:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00004a2c <ExFatPartition::freeClusterCount()>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    4a2c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t nc = 0;
  uint32_t sector = m_clusterHeapStartSector;
    4a30:	ldr.w	r1, [r0, #1068]	; 0x42c
  uint32_t usedCount = 0;
    4a34:	movs	r4, #0

 fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    4a36:	mov	r6, r0
  uint32_t nc = 0;
    4a38:	mov	r5, r4
    4a3a:	add.w	r7, r0, #528	; 0x210
    4a3e:	movs	r2, #0
    4a40:	mov	r0, r7
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
  uint8_t* cache;

  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    4a42:	add.w	r8, r1, #1
    4a46:	bl	376a <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    4a4a:	cbz	r0, 4a8c <ExFatPartition::freeClusterCount()+0x60>
    4a4c:	add.w	lr, r0, #4294967295
    4a50:	add.w	ip, r5, #4096	; 0x1000
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
    4a54:	ldrb.w	r1, [lr, #1]!
    4a58:	cmp	r1, #255	; 0xff
    4a5a:	bne.n	4a60 <ExFatPartition::freeClusterCount()+0x34>
        usedCount+= 8;
    4a5c:	adds	r4, #8
    4a5e:	b.n	4a74 <ExFatPartition::freeClusterCount()+0x48>
      } else if (cache[i]) {
    4a60:	cbz	r1, 4a74 <ExFatPartition::freeClusterCount()+0x48>
    4a62:	movs	r2, #8
    4a64:	movs	r3, #1
        for (uint8_t mask = 1; mask ; mask <<=1) {
          if ((mask & cache[i])) {
    4a66:	tst	r1, r3
            usedCount++;
    4a68:	it	ne
    4a6a:	addne	r4, #1
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
      } else if (cache[i]) {
        for (uint8_t mask = 1; mask ; mask <<=1) {
    4a6c:	lsls	r3, r3, #1
    4a6e:	subs	r2, #1
    4a70:	uxtb	r3, r3
    4a72:	bne.n	4a66 <ExFatPartition::freeClusterCount()+0x3a>
            usedCount++;
          }
        }
      }
      nc += 8;
      if (nc >= m_clusterCount) {
    4a74:	ldr.w	r0, [r6, #1072]	; 0x430
          if ((mask & cache[i])) {
            usedCount++;
          }
        }
      }
      nc += 8;
    4a78:	adds	r5, #8
      if (nc >= m_clusterCount) {
    4a7a:	cmp	r5, r0
    4a7c:	bcc.n	4a84 <ExFatPartition::freeClusterCount()+0x58>
        return m_clusterCount - usedCount;
    4a7e:	subs	r0, r0, r4
    4a80:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
    4a84:	cmp	r5, ip
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
  uint8_t* cache;

  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    4a86:	mov	r1, r8
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
    4a88:	bne.n	4a54 <ExFatPartition::freeClusterCount()+0x28>
    4a8a:	b.n	4a3e <ExFatPartition::freeClusterCount()+0x12>
      if (nc >= m_clusterCount) {
        return m_clusterCount - usedCount;
      }
    }
  }
}
    4a8c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00004a90 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>:
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    4a90:	push	{r4, r5, r6, r7, lr}
    4a92:	mov	r4, r0
    4a94:	sub	sp, #28
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif
  BpbExFat_t* bpb;

  m_fatType = 0;
    4a96:	movs	r5, #0
      }
    }
  }
}
//------------------------------------------------------------------------------
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    4a98:	mov	r0, r1
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    4a9a:	mov.w	r3, #4294967295
    4a9e:	mov	r1, r2
    4aa0:	str	r3, [r4, #12]
    4aa2:	str.w	r3, [r4, #540]	; 0x21c
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif
  BpbExFat_t* bpb;

  m_fatType = 0;
    4aa6:	strb.w	r5, [r4, #1092]	; 0x444
  m_blockDev = dev;
    4aaa:	str.w	r0, [r4, #1088]	; 0x440
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    4aae:	str	r0, [r4, #4]
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4ab0:	strb	r5, [r4, #0]
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    4ab2:	str.w	r0, [r4, #532]	; 0x214
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4ab6:	strb.w	r5, [r4, #528]	; 0x210
  cacheInit(m_blockDev);


  #if SUPPORT_GPT_AND_EXTENDED_PATITIONS 
  cache = cacheClear(); // get buffer to use. 
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part,cache, &firstLBA);
    4aba:	str	r5, [sp, #8]
    4abc:	str	r5, [sp, #4]
    4abe:	str	r5, [sp, #0]
    4ac0:	add	r3, sp, #20
    4ac2:	add.w	r2, r4, #544	; 0x220
    4ac6:	bl	34e0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    4aca:	tst.w	r0, #251	; 0xfb
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    4ace:	add.w	r7, r4, #528	; 0x210
    4ad2:	bne.n	4ad8 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x48>
  bitmapFind(0, 1);
  m_fatType = FAT_TYPE_EXFAT;
  return true;

 fail:
  return false;
    4ad4:	movs	r0, #0
    4ad6:	b.n	4b52 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xc2>
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part,cache, &firstLBA);
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    DBG_FAIL_MACRO;
    goto fail;    
  }
  volStart = firstLBA;
    4ad8:	ldr	r6, [sp, #20]
    4ada:	mov	r2, r5
    4adc:	mov	r1, r6
    4ade:	mov	r0, r7
    4ae0:	bl	376a <FsCache::get(unsigned long, unsigned char)>
  }
  volStart = getLe32(mp->relativeSectors);
  #endif

  cache = dataCacheGet(volStart, FsCache::CACHE_FOR_READ);
  if (!cache) {
    4ae4:	mov	r5, r0
    4ae6:	cmp	r0, #0
    4ae8:	beq.n	4ad4 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  pbs = reinterpret_cast<pbs_t*>(cache);
  if (strncmp(pbs->oemName, "EXFAT", 5)) {
    4aea:	ldr	r1, [pc, #108]	; (4b58 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xc8>)
    4aec:	movs	r2, #5
    4aee:	adds	r0, #3
    4af0:	bl	bf5c <strncmp>
    4af4:	mov	r1, r0
    4af6:	cmp	r0, #0
    4af8:	bne.n	4ad4 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  bpb = reinterpret_cast<BpbExFat_t*>(pbs->bpb);
  if (bpb->bytesPerSectorShift != m_bytesPerSectorShift) {
    4afa:	ldrb.w	r3, [r5, #108]	; 0x6c
    4afe:	cmp	r3, #9
    4b00:	bne.n	4ad4 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_fatStartSector = volStart + getLe32(bpb->fatOffset);
    4b02:	ldr	r3, [r5, #80]	; 0x50
    4b04:	add	r3, r6
    4b06:	str.w	r3, [r4, #1060]	; 0x424
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    4b0a:	ldr	r3, [r5, #84]	; 0x54
  m_fatLength = getLe32(bpb->fatLength);
    4b0c:	str.w	r3, [r4, #1064]	; 0x428
  m_clusterHeapStartSector = volStart + getLe32(bpb->clusterHeapOffset);
    4b10:	ldr	r3, [r5, #88]	; 0x58
    4b12:	add	r6, r3
    4b14:	str.w	r6, [r4, #1068]	; 0x42c
    4b18:	ldr	r3, [r5, #92]	; 0x5c
  m_clusterCount = getLe32(bpb->clusterCount);
    4b1a:	str.w	r3, [r4, #1072]	; 0x430
    4b1e:	ldr	r3, [r5, #96]	; 0x60
  m_rootDirectoryCluster = getLe32(bpb->rootDirectoryCluster);
    4b20:	str.w	r3, [r4, #1076]	; 0x434
  m_sectorsPerClusterShift = bpb->sectorsPerClusterShift;
    4b24:	ldrb.w	r3, [r5, #109]	; 0x6d
    4b28:	strb.w	r3, [r4, #1093]	; 0x445
  m_bytesPerCluster = 1UL << (m_bytesPerSectorShift + m_sectorsPerClusterShift);
    4b2c:	movs	r5, #1
    4b2e:	adds	r3, #9
    4b30:	lsl.w	r3, r5, r3
    4b34:	str.w	r3, [r4, #1084]	; 0x43c
  m_clusterMask = m_bytesPerCluster - 1;
    4b38:	subs	r3, #1
    4b3a:	str.w	r3, [r4, #1080]	; 0x438
  // Set m_bitmapStart to first free cluster.
  m_bitmapStart = 0;
    4b3e:	str.w	r0, [r4, #1056]	; 0x420
  bitmapFind(0, 1);
    4b42:	mov	r2, r5
    4b44:	mov	r0, r4
    4b46:	bl	4766 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  m_fatType = FAT_TYPE_EXFAT;
    4b4a:	movs	r3, #64	; 0x40
    4b4c:	strb.w	r3, [r4, #1092]	; 0x444
  return true;
    4b50:	mov	r0, r5

 fail:
  return false;
}
    4b52:	add	sp, #28
    4b54:	pop	{r4, r5, r6, r7, pc}
    4b56:	nop
    4b58:	.word	0x00012c73

00004b5c <ExFatPartition::rootLength()>:
//------------------------------------------------------------------------------
uint32_t ExFatPartition::rootLength() {
    4b5c:	push	{r4, lr}
    4b5e:	mov	r4, r0
  uint32_t nc = chainSize(m_rootDirectoryCluster);
    4b60:	ldr.w	r1, [r0, #1076]	; 0x434
    4b64:	bl	4926 <ExFatPartition::chainSize(unsigned long)>
  return nc << bytesPerClusterShift();
    4b68:	ldrb.w	r3, [r4, #1093]	; 0x445
    4b6c:	adds	r3, #9
    4b6e:	uxtb	r3, r3
}
    4b70:	lsls	r0, r3
    4b72:	pop	{r4, pc}

00004b74 <ExFatVolume::chdir(char const*)>:
#define DBG_FILE "ExFatVolume.cpp"
#include "../common/DebugMacros.h"
#include "ExFatVolume.h"
ExFatVolume* ExFatVolume::m_cwv = nullptr;
//-----------------------------------------------------------------------------
bool ExFatVolume::chdir(const char* path) {
    4b74:	push	{r4, r5, r6, lr}
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend ExFatFile;
  static ExFatVolume* cwv() {return m_cwv;}
  ExFatFile* vwd() {return &m_vwd;}
    4b76:	add.w	r4, r0, #1096	; 0x448
    4b7a:	sub	sp, #56	; 0x38
    4b7c:	movs	r3, #0
  ExFatFile dir;
  if (!dir.open(vwd(), path, O_RDONLY)) {
    4b7e:	mov	r2, r1
    4b80:	mov	r0, sp
    4b82:	mov	r1, r4
    4b84:	strb.w	r3, [sp, #49]	; 0x31
    4b88:	strb.w	r3, [sp, #50]	; 0x32
    4b8c:	strb.w	r3, [sp, #51]	; 0x33
    4b90:	bl	4670 <ExFatFile::open(ExFatFile*, char const*, int)>
    4b94:	mov	r5, r0
    4b96:	cbz	r0, 4bc2 <ExFatVolume::chdir(char const*)+0x4e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!dir.isDir()) {
    4b98:	ldrb.w	r3, [sp, #49]	; 0x31
    4b9c:	ands.w	r3, r3, #80	; 0x50
    4ba0:	beq.n	4bc0 <ExFatVolume::chdir(char const*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_vwd = dir;
    4ba2:	mov	r2, sp
    4ba4:	mov	r3, r4
    4ba6:	add	r6, sp, #48	; 0x30
    4ba8:	mov	r4, r2
    4baa:	ldmia	r4!, {r0, r1}
    4bac:	cmp	r4, r6
    4bae:	str	r0, [r3, #0]
    4bb0:	str	r1, [r3, #4]
    4bb2:	mov	r2, r4
    4bb4:	add.w	r3, r3, #8
    4bb8:	bne.n	4ba8 <ExFatVolume::chdir(char const*)+0x34>
    4bba:	ldr	r0, [r4, #0]
    4bbc:	str	r0, [r3, #0]
  return true;
    4bbe:	b.n	4bc2 <ExFatVolume::chdir(char const*)+0x4e>

 fail:
  return false;
    4bc0:	mov	r5, r3
}
    4bc2:	mov	r0, r5
    4bc4:	add	sp, #56	; 0x38
    4bc6:	pop	{r4, r5, r6, pc}

00004bc8 <exFatDirChecksum(unsigned char const*, unsigned short)>:
  return false;
}
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
    4bc8:	push	{r4, lr}
  bool skip = data[0] == EXFAT_TYPE_FILE;
    4bca:	ldrb	r4, [r0, #0]
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    4bcc:	movs	r3, #0
    4bce:	lsls	r2, r1, #15
    4bd0:	orr.w	r1, r2, r1, lsr #1
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    4bd4:	ldrb	r2, [r0, r3]
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    4bd6:	cmp	r3, #1
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    4bd8:	uxtah	r1, r2, r1
    4bdc:	uxth	r1, r1
//==============================================================================
#else  // READ_ONLY
//------------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    4bde:	bne.n	4bea <exFatDirChecksum(unsigned char const*, unsigned short)+0x22>
    4be0:	cmp	r4, #133	; 0x85
    4be2:	ite	ne
    4be4:	movne	r2, #1
    4be6:	moveq	r2, #3
    4be8:	b.n	4bec <exFatDirChecksum(unsigned char const*, unsigned short)+0x24>
    4bea:	movs	r2, #1
    4bec:	add	r3, r2
    4bee:	cmp	r3, #31
    4bf0:	bls.n	4bce <exFatDirChecksum(unsigned char const*, unsigned short)+0x6>
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
  }
  return checksum;
}
    4bf2:	mov	r0, r1
    4bf4:	pop	{r4, pc}

00004bf6 <ExFatPartition::cacheSync()>:
#if USE_EXFAT_BITMAP_CACHE
    m_bitmapCache.init(dev);
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
    4bf6:	push	{r4, lr}
    4bf8:	mov	r4, r0
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    4bfa:	bl	371e <FsCache::sync()>
    4bfe:	cbz	r0, 4c18 <ExFatPartition::cacheSync()+0x22>
    4c00:	add.w	r0, r4, #528	; 0x210
    4c04:	bl	371e <FsCache::sync()>
    4c08:	cbz	r0, 4c18 <ExFatPartition::cacheSync()+0x22>
    4c0a:	ldr.w	r0, [r4, #1088]	; 0x440
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    4c0e:	ldr	r3, [r0, #0]
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
#else  // USE_EXFAT_BITMAP_CACHE
    return m_dataCache.sync() && syncDevice();
#endif  // USE_EXFAT_BITMAP_CACHE
  }
    4c10:	ldmia.w	sp!, {r4, lr}
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() const {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    4c14:	ldr	r3, [r3, #28]
    4c16:	bx	r3
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
#else  // USE_EXFAT_BITMAP_CACHE
    return m_dataCache.sync() && syncDevice();
#endif  // USE_EXFAT_BITMAP_CACHE
  }
    4c18:	movs	r0, #0
    4c1a:	pop	{r4, pc}

00004c1c <ExFatFile::addCluster()>:
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
    4c1c:	push	{r3, r4, r5, r6, r7, lr}
    4c1e:	mov	r4, r0
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    4c20:	ldr	r0, [r0, #32]
    4c22:	ldr	r1, [r4, #24]
    4c24:	cbz	r1, 4c28 <ExFatFile::addCluster()+0xc>
    4c26:	adds	r1, #1
    4c28:	movs	r2, #1
    4c2a:	bl	4766 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  if (find < 2) {
    4c2e:	cmp	r0, #1
  }
  return checksum;
}
//------------------------------------------------------------------------------
bool ExFatFile::addCluster() {
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    4c30:	mov	r5, r0
  if (find < 2) {
    4c32:	bhi.n	4c38 <ExFatFile::addCluster()+0x1c>
 done:
  m_curCluster = find;
  return true;

 fail:
  return false;
    4c34:	movs	r6, #0
    4c36:	b.n	4caa <ExFatFile::addCluster()+0x8e>
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
  if (find < 2) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    4c38:	movs	r3, #1
    4c3a:	mov	r1, r0
    4c3c:	mov	r2, r3
    4c3e:	ldr	r0, [r4, #32]
    4c40:	bl	480c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4c44:	mov	r6, r0
    4c46:	cmp	r0, #0
    4c48:	beq.n	4c34 <ExFatFile::addCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    4c4a:	ldr	r2, [r4, #24]
    m_flags |= FILE_FLAG_CONTIGUOUS;
    4c4c:	ldrb.w	r3, [r4, #51]	; 0x33
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    4c50:	cbnz	r2, 4c5c <ExFatFile::addCluster()+0x40>
    m_flags |= FILE_FLAG_CONTIGUOUS;
    4c52:	orr.w	r3, r3, #64	; 0x40
    4c56:	strb.w	r3, [r4, #51]	; 0x33
    goto done;
    4c5a:	b.n	4ca8 <ExFatFile::addCluster()+0x8c>
  }
  if (isContiguous()) {
    4c5c:	lsls	r1, r3, #25
    4c5e:	bpl.n	4c88 <ExFatFile::addCluster()+0x6c>
    if (find == (m_curCluster + 1)) {
    4c60:	adds	r2, #1
    4c62:	cmp	r5, r2
    4c64:	beq.n	4ca8 <ExFatFile::addCluster()+0x8c>
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    4c66:	bic.w	r3, r3, #64	; 0x40

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    4c6a:	ldr	r1, [r4, #28]
  if (isContiguous()) {
    if (find == (m_curCluster + 1)) {
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    4c6c:	strb.w	r3, [r4, #51]	; 0x33

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    4c70:	ldr	r3, [r4, #24]
    4c72:	cmp	r1, r3
    4c74:	bcs.n	4c88 <ExFatFile::addCluster()+0x6c>
      if (!m_vol->fatPut(c, c + 1)) {
    4c76:	adds	r7, r1, #1
    4c78:	mov	r2, r7
    4c7a:	ldr	r0, [r4, #32]
    4c7c:	bl	4994 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4c80:	cmp	r0, #0
    4c82:	beq.n	4c34 <ExFatFile::addCluster()+0x18>
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    4c84:	mov	r1, r7
    4c86:	b.n	4c70 <ExFatFile::addCluster()+0x54>
        goto fail;
      }
    }
  }
  // New cluster is EOC.
  if (!m_vol->fatPut(find, EXFAT_EOC)) {
    4c88:	mov.w	r2, #4294967295
    4c8c:	mov	r1, r5
    4c8e:	ldr	r0, [r4, #32]
    4c90:	bl	4994 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4c94:	cmp	r0, #0
    4c96:	beq.n	4c34 <ExFatFile::addCluster()+0x18>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Connect new cluster to existing chain.
  if (m_curCluster) {
    4c98:	ldr	r1, [r4, #24]
    4c9a:	cbz	r1, 4ca8 <ExFatFile::addCluster()+0x8c>
    if (!m_vol->fatPut(m_curCluster, find)) {
    4c9c:	mov	r2, r5
    4c9e:	ldr	r0, [r4, #32]
    4ca0:	bl	4994 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    4ca4:	cmp	r0, #0
    4ca6:	beq.n	4c34 <ExFatFile::addCluster()+0x18>
      goto fail;
    }
  }

 done:
  m_curCluster = find;
    4ca8:	str	r5, [r4, #24]
  return true;

 fail:
  return false;
}
    4caa:	mov	r0, r6
    4cac:	pop	{r3, r4, r5, r6, r7, pc}

00004cae <ExFatFile::remove()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    4cae:	push	{r4, r5, r6, lr}
    4cb0:	ldrb.w	r3, [r0, #51]	; 0x33
  uint8_t* cache;
  if (!isWritable()) {
    4cb4:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    4cb6:	mov	r4, r0
  uint8_t* cache;
  if (!isWritable()) {
    4cb8:	bmi.n	4cbe <ExFatFile::remove()+0x10>

  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
    4cba:	movs	r0, #0
    4cbc:	pop	{r4, r5, r6, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    4cbe:	ldr	r5, [r0, #28]
    4cc0:	cbnz	r5, 4cc6 <ExFatFile::remove()+0x18>

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    4cc2:	movs	r5, #0
    4cc4:	b.n	4d18 <ExFatFile::remove()+0x6a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    if (isContiguous()) {
    4cc6:	lsls	r3, r3, #25
    4cc8:	bpl.n	4cf4 <ExFatFile::remove()+0x46>
      uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    4cca:	ldr	r6, [r0, #32]
      if (!m_vol->bitmapModify(m_firstCluster, nc, 0)) {
    4ccc:	ldrd	r0, r1, [r0, #8]
    4cd0:	ldrb.w	r2, [r6, #1093]	; 0x445
    4cd4:	adds.w	r0, r0, #4294967295
    4cd8:	add.w	r2, r2, #9
    4cdc:	uxtb	r2, r2
    4cde:	adc.w	r1, r1, #4294967295
    4ce2:	bl	a434 <__aeabi_llsr>
    4ce6:	movs	r3, #0
    4ce8:	adds	r2, r0, #1
    4cea:	mov	r1, r5
    4cec:	mov	r0, r6
    4cee:	bl	480c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    4cf2:	b.n	4cfc <ExFatFile::remove()+0x4e>
        DBG_FAIL_MACRO;
        goto fail;
      }
    } else {
      if (!m_vol->freeChain(m_firstCluster)) {
    4cf4:	mov	r1, r5
    4cf6:	ldr	r0, [r0, #32]
    4cf8:	bl	49ce <ExFatPartition::freeChain(unsigned long)>
    4cfc:	cmp	r0, #0
    4cfe:	bne.n	4cc2 <ExFatFile::remove()+0x14>
    4d00:	b.n	4cba <ExFatFile::remove()+0xc>
      }
    }
  }

  for (uint8_t is = 0; is <= m_setCount; is++) {
    cache = dirCache(is, FsCache::CACHE_FOR_WRITE);
    4d02:	movs	r2, #1
    4d04:	mov	r0, r4
    4d06:	bl	3f72 <ExFatFile::dirCache(unsigned char, unsigned char)>
    4d0a:	adds	r5, #1
    if (!cache) {
    4d0c:	cmp	r0, #0
    4d0e:	beq.n	4cba <ExFatFile::remove()+0xc>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
    4d10:	ldrb	r3, [r0, #0]
    4d12:	and.w	r3, r3, #127	; 0x7f
    4d16:	strb	r3, [r0, #0]
        goto fail;
      }
    }
  }

  for (uint8_t is = 0; is <= m_setCount; is++) {
    4d18:	ldrb.w	r3, [r4, #48]	; 0x30
    4d1c:	uxtb	r1, r5
    4d1e:	cmp	r3, r1
    4d20:	bcs.n	4d02 <ExFatFile::remove()+0x54>
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
  }
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    4d22:	movs	r3, #0
    4d24:	strb.w	r3, [r4, #49]	; 0x31
  m_flags = 0;
    4d28:	strb.w	r3, [r4, #51]	; 0x33

  // Write entry to device.
  return m_vol->cacheSync();
    4d2c:	ldr	r0, [r4, #32]
    4d2e:	bl	4bf6 <ExFatPartition::cacheSync()>

 fail:
  return false;
}
    4d32:	pop	{r4, r5, r6, pc}

00004d34 <ExFatFile::rmdir()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    4d34:	push	{r4, lr}
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    4d36:	ldrb.w	r3, [r0, #49]	; 0x31
    4d3a:	lsls	r1, r3, #27

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    4d3c:	sub	sp, #32
    4d3e:	mov	r4, r0
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    4d40:	bmi.n	4d46 <ExFatFile::rmdir()+0x12>
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();

 fail:
  return false;
    4d42:	movs	r0, #0
    4d44:	b.n	4d82 <ExFatFile::rmdir()+0x4e>
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    4d46:	movs	r2, #0
    4d48:	movs	r3, #0
    4d4a:	bl	4250 <ExFatFile::seekSet(unsigned long long)>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    n = read(dir, 32);
    4d4e:	movs	r2, #32
    4d50:	mov	r1, sp
    4d52:	mov	r0, r4
    4d54:	bl	40a0 <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    4d58:	cbz	r0, 4d6a <ExFatFile::rmdir()+0x36>
      break;
    }
    if (n != 32 || dir[0] & 0X80) {
    4d5a:	cmp	r0, #32
    4d5c:	bne.n	4d42 <ExFatFile::rmdir()+0xe>
    4d5e:	ldrb.w	r3, [sp]
    4d62:	lsls	r2, r3, #24
    4d64:	bmi.n	4d42 <ExFatFile::rmdir()+0xe>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (dir[0] == 0) {
    4d66:	cmp	r3, #0
    4d68:	bne.n	4d4e <ExFatFile::rmdir()+0x1a>
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    4d6a:	movs	r3, #8
    4d6c:	strb.w	r3, [r4, #49]	; 0x31
  m_flags |= FILE_FLAG_WRITE;
    4d70:	ldrb.w	r3, [r4, #51]	; 0x33
    4d74:	orr.w	r3, r3, #2
    4d78:	strb.w	r3, [r4, #51]	; 0x33
  return remove();
    4d7c:	mov	r0, r4
    4d7e:	bl	4cae <ExFatFile::remove()>

 fail:
  return false;
}
    4d82:	add	sp, #32
    4d84:	pop	{r4, pc}
    4d86:	Address 0x00004d86 is out of bounds.


00004d88 <ExFatFile::syncDir()>:
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    4d88:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    4d8c:	movs	r6, #0
    }
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    4d8e:	ldr.w	r8, [pc, #212]	; 4e64 <ExFatFile::syncDir()+0xdc>
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    4d92:	mov	r5, r0
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
    4d94:	mov	r7, r6

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    4d96:	ldrb.w	r3, [r5, #48]	; 0x30
    4d9a:	uxtb	r1, r6
    4d9c:	cmp	r3, r1
    4d9e:	bcc.n	4e36 <ExFatFile::syncDir()+0xae>
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    4da0:	movs	r2, #0
    4da2:	mov	r0, r5
    4da4:	bl	3f72 <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache) {
    4da8:	mov	r4, r0
    4daa:	cmp	r0, #0
    4dac:	beq.n	4e4e <ExFatFile::syncDir()+0xc6>
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    4dae:	ldrb	r3, [r0, #0]
    4db0:	cmp	r3, #192	; 0xc0
    4db2:	beq.n	4df0 <ExFatFile::syncDir()+0x68>
    4db4:	cmp	r3, #193	; 0xc1
    4db6:	beq.n	4e28 <ExFatFile::syncDir()+0xa0>
    4db8:	cmp	r3, #133	; 0x85
    4dba:	bne.n	4e4e <ExFatFile::syncDir()+0xc6>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    4dbc:	ldrb.w	r3, [r5, #49]	; 0x31
    4dc0:	and.w	r3, r3, #55	; 0x37
    4dc4:	strh	r3, [r0, #4]
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    4dc6:	ldr.w	r3, [r8]
    4dca:	cbz	r3, 4e1a <ExFatFile::syncDir()+0x92>
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
    4dcc:	add.w	r2, sp, #3
    4dd0:	add.w	r1, sp, #6
    4dd4:	add	r0, sp, #4
    4dd6:	blx	r3
          df->modifyTimeMs = ms10;
    4dd8:	ldrb.w	r3, [sp, #3]
          setLe16(df->modifyTime, time);
    4ddc:	ldrh.w	r2, [sp, #6]
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
          df->modifyTimeMs = ms10;
    4de0:	strb	r3, [r4, #21]
          setLe16(df->modifyTime, time);
          setLe16(df->modifyDate, date);
    4de2:	ldrh.w	r3, [sp, #4]
    4de6:	strh	r2, [r4, #12]
    4de8:	strh	r3, [r4, #14]
    4dea:	strh	r2, [r4, #16]
    4dec:	strh	r3, [r4, #18]
    4dee:	b.n	4e1a <ExFatFile::syncDir()+0x92>
        m_vol->dataCacheDirty();
        break;

      case EXFAT_TYPE_STREAM:
        ds = reinterpret_cast<DirStream_t*>(cache);
        if (isContiguous()) {
    4df0:	ldrb.w	r3, [r5, #51]	; 0x33
    4df4:	tst.w	r3, #64	; 0x40
    4df8:	ldrb	r3, [r0, #1]
          ds->flags |= EXFAT_FLAG_CONTIGUOUS;
    4dfa:	ite	ne
    4dfc:	orrne.w	r3, r3, #2
        } else {
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
    4e00:	biceq.w	r3, r3, #2
    4e04:	strb	r3, [r0, #1]
        }
        setLe64(ds->validLength, m_validLength);
    4e06:	ldrd	r2, r3, [r5, #16]

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    4e0a:	strd	r2, r3, [r0, #8]
        setLe32(ds->firstCluster, m_firstCluster);
    4e0e:	ldr	r3, [r5, #28]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    4e10:	str	r3, [r0, #20]
        setLe64(ds->dataLength, m_dataLength);
    4e12:	ldrd	r2, r3, [r5, #8]
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    4e16:	strd	r2, r3, [r0, #24]
        m_vol->dataCacheDirty();
    4e1a:	ldr	r2, [r5, #32]
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    4e1c:	ldrb.w	r3, [r2, #528]	; 0x210
    4e20:	orr.w	r3, r3, #1
    4e24:	strb.w	r3, [r2, #528]	; 0x210
      default:
        DBG_FAIL_MACRO;
        goto fail;
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
    4e28:	mov	r1, r7
    4e2a:	mov	r0, r4
    4e2c:	bl	4bc8 <exFatDirChecksum(unsigned char const*, unsigned short)>
    4e30:	adds	r6, #1
    4e32:	mov	r7, r0
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    4e34:	b.n	4d96 <ExFatFile::syncDir()+0xe>
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
  }
  df = reinterpret_cast<DirFile_t*>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
    4e36:	movs	r2, #1
    4e38:	add.w	r1, r5, #36	; 0x24
    4e3c:	ldr	r0, [r5, #32]
    4e3e:	bl	48b2 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    4e42:	cbz	r0, 4e4e <ExFatFile::syncDir()+0xc6>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    4e44:	strh	r7, [r0, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe16(df->setChecksum, checksum);
  if (!m_vol->cacheSync()) {
    4e46:	ldr	r0, [r5, #32]
    4e48:	bl	4bf6 <ExFatPartition::cacheSync()>
    4e4c:	cbnz	r0, 4e5c <ExFatFile::syncDir()+0xd4>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    4e4e:	ldrb.w	r3, [r5, #50]	; 0x32
    4e52:	orr.w	r3, r3, #1
    4e56:	strb.w	r3, [r5, #50]	; 0x32
  return false;
    4e5a:	movs	r0, #0
}
    4e5c:	add	sp, #8
    4e5e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4e62:	nop
    4e64:	.word	0x2001ceb4

00004e68 <ExFatFile::sync()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
    4e68:	push	{r4, lr}
  if (!isOpen()) {
    4e6a:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::sync() {
    4e6e:	mov	r4, r0
  if (!isOpen()) {
    4e70:	cbnz	r3, 4e76 <ExFatFile::sync()+0xe>
    return true;
    4e72:	movs	r0, #1
    4e74:	pop	{r4, pc}
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    4e76:	ldrb.w	r3, [r0, #51]	; 0x33
    4e7a:	lsls	r2, r3, #24
    4e7c:	bpl.n	4e8e <ExFatFile::sync()+0x26>
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    4e7e:	and.w	r3, r3, #127	; 0x7f
    4e82:	strb.w	r3, [r0, #51]	; 0x33
  return true;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    4e86:	ldmia.w	sp!, {r4, lr}
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    return syncDir();
    4e8a:	b.w	4d88 <ExFatFile::syncDir()>
  }
  if (!m_vol->cacheSync()) {
    4e8e:	ldr	r0, [r0, #32]
    4e90:	bl	4bf6 <ExFatPartition::cacheSync()>
    4e94:	cmp	r0, #0
    4e96:	bne.n	4e72 <ExFatFile::sync()+0xa>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    4e98:	ldrb.w	r3, [r4, #50]	; 0x32
    4e9c:	orr.w	r3, r3, #1
    4ea0:	strb.w	r3, [r4, #50]	; 0x32
  return false;
}
    4ea4:	pop	{r4, pc}

00004ea6 <ExFatFile::addDirCluster()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    4ea6:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    4eaa:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    4eae:	mov	r4, r0
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    4eb0:	lsls	r0, r3, #25
    4eb2:	bpl.n	4ebc <ExFatFile::addDirCluster()+0x16>
    4eb4:	ldr	r0, [r4, #32]
    4eb6:	bl	4b5c <ExFatPartition::rootLength()>
    4eba:	b.n	4ebe <ExFatFile::addDirCluster()+0x18>
    4ebc:	ldr	r0, [r4, #8]
    4ebe:	ldr	r3, [r4, #32]
  uint8_t* cache;
  dl += m_vol->bytesPerCluster();
  if (dl >= 0X4000000) {
    4ec0:	ldr.w	r3, [r3, #1084]	; 0x43c
    4ec4:	add	r0, r3
    4ec6:	cmp.w	r0, #67108864	; 0x4000000
    4eca:	bcs.n	4f7e <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    4ecc:	mov	r0, r4
    4ece:	bl	4c1c <ExFatFile::addCluster()>
    4ed2:	cmp	r0, #0
    4ed4:	beq.n	4f7e <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  cache =  m_vol->cacheClear();
    4ed6:	ldr	r5, [r4, #32]
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    if (isDirty() && !sync()) {
    4ed8:	ldrb.w	r3, [r5, #528]	; 0x210
    4edc:	lsls	r1, r3, #31
    4ede:	bpl.n	4eec <ExFatFile::addDirCluster()+0x46>
    4ee0:	add.w	r0, r5, #528	; 0x210
    4ee4:	bl	371e <FsCache::sync()>
    4ee8:	cmp	r0, #0
    4eea:	beq.n	4f7e <ExFatFile::addDirCluster()+0xd8>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    4eec:	mov.w	r3, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4ef0:	movs	r6, #0
    m_sector = 0XFFFFFFFF;
    4ef2:	str.w	r3, [r5, #540]	; 0x21c
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    4ef6:	strb.w	r6, [r5, #528]	; 0x210
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    4efa:	add.w	r5, r5, #544	; 0x220
  if (!cache) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
    4efe:	mov.w	r2, #512	; 0x200
    4f02:	mov	r1, r6
    4f04:	mov	r0, r5
    4f06:	bl	8fc0 <memset>
  sector = m_vol->clusterStartSector(m_curCluster);
    4f0a:	ldr	r2, [r4, #32]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    4f0c:	ldr	r3, [r4, #24]
    4f0e:	ldrb.w	r1, [r2, #1093]	; 0x445
    4f12:	ldr.w	r7, [r2, #1068]	; 0x42c
    4f16:	subs	r3, #2
    4f18:	lsls	r3, r1
    4f1a:	add	r7, r3
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    4f1c:	mov.w	r8, #1
    4f20:	ldr	r3, [r4, #32]
    4f22:	ldrb.w	r2, [r3, #1093]	; 0x445
    4f26:	lsl.w	r2, r8, r2
    4f2a:	cmp	r2, r6
    4f2c:	bls.n	4f42 <ExFatFile::addDirCluster()+0x9c>
    4f2e:	ldr.w	r0, [r3, #1088]	; 0x440
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    4f32:	ldr	r3, [r0, #0]
    4f34:	mov	r2, r5
    4f36:	ldr	r3, [r3, #32]
    4f38:	adds	r1, r7, r6
    4f3a:	blx	r3
    if (!m_vol->writeSector(sector + i, cache)) {
    4f3c:	cbz	r0, 4f7e <ExFatFile::addDirCluster()+0xd8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
  sector = m_vol->clusterStartSector(m_curCluster);
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    4f3e:	adds	r6, #1
    4f40:	b.n	4f20 <ExFatFile::addDirCluster()+0x7a>
    if (!m_vol->writeSector(sector + i, cache)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  if (!isRoot()) {
    4f42:	ldrb.w	r2, [r4, #49]	; 0x31
    4f46:	lsls	r2, r2, #25
    4f48:	bmi.n	4f74 <ExFatFile::addDirCluster()+0xce>
    m_flags |= FILE_FLAG_DIR_DIRTY;
    4f4a:	ldrb.w	r2, [r4, #51]	; 0x33
    4f4e:	orn	r2, r2, #127	; 0x7f
    m_dataLength  += m_vol->bytesPerCluster();
    4f52:	ldrd	r0, r1, [r4, #8]
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    4f56:	strb.w	r2, [r4, #51]	; 0x33
    m_dataLength  += m_vol->bytesPerCluster();
    4f5a:	ldr.w	r2, [r3, #1084]	; 0x43c
    4f5e:	movs	r3, #0
    4f60:	adds	r0, r0, r2
    4f62:	adcs	r1, r3
    4f64:	strd	r0, r1, [r4, #8]
    m_validLength += m_vol->bytesPerCluster();
    4f68:	ldrd	r0, r1, [r4, #16]
    4f6c:	adds	r2, r2, r0
    4f6e:	adcs	r3, r1
    4f70:	strd	r2, r3, [r4, #16]
  }
  return sync();
    4f74:	mov	r0, r4

 fail:
  return false;
}
    4f76:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    m_validLength += m_vol->bytesPerCluster();
  }
  return sync();
    4f7a:	b.w	4e68 <ExFatFile::sync()>

 fail:
  return false;
}
    4f7e:	movs	r0, #0
    4f80:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00004f84 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    4f84:	push	{r4, lr}
  if (!parent->isDir()) {
    4f86:	ldrb.w	r3, [r1, #49]	; 0x31
    4f8a:	tst.w	r3, #80	; 0x50

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    4f8e:	mov	r4, r0
  if (!parent->isDir()) {
    4f90:	beq.n	4fc8 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!openPrivate(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    4f92:	movw	r3, #2562	; 0xa02
    4f96:	bl	4320 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    4f9a:	cbz	r0, 4fc8 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_attributes = FILE_ATTR_SUBDIR;
    4f9c:	movs	r3, #16
    4f9e:	strb.w	r3, [r4, #49]	; 0x31

  // allocate and zero first cluster
  if (!addDirCluster()) {
    4fa2:	mov	r0, r4
    4fa4:	bl	4ea6 <ExFatFile::addDirCluster()>
    4fa8:	cbz	r0, 4fc8 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x44>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    4faa:	ldr	r3, [r4, #24]
    4fac:	str	r3, [r4, #28]
    4fae:	mov	r0, r4
    4fb0:	movs	r3, #0
    4fb2:	movs	r2, #0
    4fb4:	bl	4250 <ExFatFile::seekSet(unsigned long long)>

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    4fb8:	movs	r3, #193	; 0xc1
    4fba:	strb.w	r3, [r4, #51]	; 0x33
  return sync();
    4fbe:	mov	r0, r4

 fail:
  return false;
}
    4fc0:	ldmia.w	sp!, {r4, lr}
  m_firstCluster = m_curCluster;

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();
    4fc4:	b.w	4e68 <ExFatFile::sync()>

 fail:
  return false;
}
    4fc8:	movs	r0, #0
    4fca:	pop	{r4, pc}

00004fcc <ExFatFile::mkdir(ExFatFile*, char const*, bool)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const char* path, bool pFlag) {
    4fcc:	push	{r4, r5, r6, r7, lr}
    4fce:	sub	sp, #92	; 0x5c
    4fd0:	mov	r7, r3
    4fd2:	movs	r3, #0
    4fd4:	strh.w	r3, [sp, #20]
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() {}
    4fd8:	strb.w	r3, [sp, #81]	; 0x51
    4fdc:	strb.w	r3, [sp, #82]	; 0x52
    4fe0:	strb.w	r3, [sp, #83]	; 0x53
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    4fe4:	ldrb.w	r3, [r0, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const char* path, bool pFlag) {
    4fe8:	str	r2, [sp, #4]
    4fea:	mov	r5, r0
    4fec:	mov	r4, r1
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    4fee:	cmp	r3, #0
    4ff0:	bne.n	5084 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    4ff2:	ldrb.w	r3, [r1, #49]	; 0x31
    4ff6:	tst.w	r3, #80	; 0x50
    4ffa:	beq.n	5084 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    4ffc:	ldrb	r3, [r2, #0]
    4ffe:	cmp	r3, #47	; 0x2f
    5000:	bne.n	501e <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x52>
    while (isDirSeparator(*path)) {
    5002:	ldr	r3, [sp, #4]
    5004:	ldrb	r2, [r3, #0]
    5006:	cmp	r2, #47	; 0x2f
    5008:	bne.n	5010 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x44>
      path++;
    500a:	adds	r3, #1
    500c:	str	r3, [sp, #4]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    500e:	b.n	5002 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x36>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    5010:	ldr	r1, [r4, #32]
    5012:	add	r0, sp, #32
    5014:	bl	3ffe <ExFatFile::openRoot(ExFatVolume*)>
    5018:	cmp	r0, #0
    501a:	beq.n	5084 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    501c:	add	r4, sp, #32
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    501e:	add	r3, sp, #4
    5020:	add	r2, sp, #8
    5022:	ldr	r1, [sp, #4]
    5024:	mov	r0, r5
    5026:	bl	4024 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    502a:	cbz	r0, 5084 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    502c:	ldr	r3, [sp, #4]
    502e:	ldrb	r3, [r3, #0]
    5030:	cbz	r3, 5078 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xac>
      break;
    }
    if (!openPrivate(parent, &fname, O_RDONLY)) {
    5032:	movs	r3, #0
    5034:	add	r2, sp, #8
    5036:	mov	r1, r4
    5038:	mov	r0, r5
    503a:	bl	4320 <ExFatFile::openPrivate(ExFatFile*, ExName_t*, int)>
    503e:	cbz	r0, 5066 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x9a>
      if (!pFlag || !mkdir(parent, &fname)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    5040:	add	r2, sp, #32
    5042:	mov	r3, r5
    5044:	add.w	lr, r5, #48	; 0x30
    5048:	mov	r4, r2
    504a:	ldr	r0, [r3, #0]
    504c:	ldr	r1, [r3, #4]
    504e:	mov	r6, r2
    5050:	stmia	r6!, {r0, r1}
    5052:	adds	r3, #8
    5054:	cmp	r3, lr
    5056:	mov	r2, r6
    5058:	bne.n	504a <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x7e>
    505a:	ldr	r0, [r3, #0]
    505c:	str	r0, [r6, #0]
    parent = &tmpDir;
    close();
    505e:	mov	r0, r5
    5060:	bl	3faa <ExFatFile::close()>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    5064:	b.n	501e <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x52>
    }
    if (!*path) {
      break;
    }
    if (!openPrivate(parent, &fname, O_RDONLY)) {
      if (!pFlag || !mkdir(parent, &fname)) {
    5066:	cbz	r7, 5084 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    5068:	add	r2, sp, #8
    506a:	mov	r1, r4
    506c:	mov	r0, r5
    506e:	bl	4f84 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    5072:	cmp	r0, #0
    5074:	bne.n	5040 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x74>
    5076:	b.n	5084 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    5078:	add	r2, sp, #8
    507a:	mov	r1, r4
    507c:	mov	r0, r5
    507e:	bl	4f84 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    5082:	b.n	5086 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xba>

 fail:
  return false;
    5084:	movs	r0, #0
}
    5086:	add	sp, #92	; 0x5c
    5088:	pop	{r4, r5, r6, r7, pc}

0000508a <ExFatFile::rename(ExFatFile*, char const*)>:
//------------------------------------------------------------------------------
bool ExFatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const char* newPath) {
    508a:	push	{r4, r5, r6, r7, lr}
    508c:	sub	sp, #116	; 0x74
    508e:	movs	r3, #0
    5090:	strb.w	r3, [sp, #49]	; 0x31
    5094:	strb.w	r3, [sp, #50]	; 0x32
    5098:	strb.w	r3, [sp, #51]	; 0x33
    509c:	strb.w	r3, [sp, #105]	; 0x69
    50a0:	strb.w	r3, [sp, #106]	; 0x6a
    50a4:	strb.w	r3, [sp, #107]	; 0x6b
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    50a8:	ldrb.w	r3, [r0, #49]	; 0x31
    50ac:	tst.w	r3, #24
//------------------------------------------------------------------------------
bool ExFatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const char* newPath) {
    50b0:	mov	r4, r0
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    50b2:	bne.n	50b8 <ExFatFile::rename(ExFatFile*, char const*)+0x2e>
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();

 fail:
  return false;
    50b4:	movs	r0, #0
    50b6:	b.n	512c <ExFatFile::rename(ExFatFile*, char const*)+0xa2>
  if (!(isFile() || isSubDir())) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    50b8:	ldr	r0, [r0, #32]
    50ba:	ldr	r3, [r1, #32]
    50bc:	cmp	r0, r3
    50be:	bne.n	50b4 <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    50c0:	movw	r3, #2561	; 0xa01
    50c4:	mov	r0, sp
    50c6:	bl	4670 <ExFatFile::open(ExFatFile*, char const*, int)>
    50ca:	cmp	r0, #0
    50cc:	beq.n	50b4 <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  oldFile = *this;
    50ce:	add	r2, sp, #56	; 0x38
    50d0:	mov	r3, r4
    50d2:	add.w	r7, r4, #48	; 0x30
    50d6:	mov	r6, r2
    50d8:	ldr	r0, [r3, #0]
    50da:	ldr	r1, [r3, #4]
    50dc:	mov	r5, r2
    50de:	stmia	r5!, {r0, r1}
    50e0:	adds	r3, #8
    50e2:	cmp	r3, r7
    50e4:	mov	r2, r5
    50e6:	bne.n	50d8 <ExFatFile::rename(ExFatFile*, char const*)+0x4e>
    50e8:	ldr	r0, [r3, #0]
    50ea:	str	r0, [r5, #0]
  m_dirPos = file.m_dirPos;
    50ec:	add	r2, sp, #36	; 0x24
    50ee:	ldmia	r2, {r0, r1, r2}
    50f0:	add.w	r3, r4, #36	; 0x24
    50f4:	stmia.w	r3, {r0, r1, r2}
  m_setCount = file.m_setCount;
    50f8:	ldrb.w	r3, [sp, #48]	; 0x30
    50fc:	strb.w	r3, [r4, #48]	; 0x30
  m_flags |= FILE_FLAG_DIR_DIRTY;
    5100:	ldrb.w	r3, [r4, #51]	; 0x33
    5104:	orn	r3, r3, #127	; 0x7f
    5108:	strb.w	r3, [r4, #51]	; 0x33
  if (!sync()) {
    510c:	mov	r0, r4
    510e:	bl	4e68 <ExFatFile::sync()>
    5112:	cmp	r0, #0
    5114:	beq.n	50b4 <ExFatFile::rename(ExFatFile*, char const*)+0x2a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    5116:	movs	r3, #0
    5118:	str	r3, [sp, #84]	; 0x54
  oldFile.m_flags = FILE_FLAG_WRITE;
    511a:	movs	r3, #2
    511c:	strb.w	r3, [sp, #107]	; 0x6b
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();
    5120:	mov	r0, r6
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
    5122:	movs	r3, #8
    5124:	strb.w	r3, [sp, #105]	; 0x69
  return oldFile.remove();
    5128:	bl	4cae <ExFatFile::remove()>

 fail:
  return false;
}
    512c:	add	sp, #116	; 0x74
    512e:	pop	{r4, r5, r6, r7, pc}

00005130 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    5130:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5134:	mov	r4, r3
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    5136:	ldrb.w	r3, [r0, #49]	; 0x31
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    513a:	ldrb.w	fp, [sp, #40]	; 0x28
    513e:	ldrb.w	sl, [sp, #44]	; 0x2c
    5142:	ldrb.w	r5, [sp, #48]	; 0x30
    5146:	ldrb.w	r9, [sp, #52]	; 0x34
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    514a:	lsls	r3, r3, #28
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    514c:	mov	r6, r0
    514e:	mov	r8, r1
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    5150:	bpl.n	51c4 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
  uint16_t date;
  uint16_t time;
  uint8_t ms10;

  if (!isFile()
      || year < 1980
    5152:	subw	r2, r2, #1980	; 0x7bc
    5156:	uxth	r7, r2
    5158:	cmp	r7, #127	; 0x7f
    515a:	bhi.n	51c4 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || year > 2107
      || month < 1
    515c:	subs	r3, r4, #1
    515e:	cmp	r3, #11
    5160:	bhi.n	51c4 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || month > 12
      || day < 1
    5162:	add.w	r3, fp, #4294967295
    5166:	cmp	r3, #30
    5168:	bhi.n	51c4 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || day > 31
      || hour > 23
    516a:	cmp.w	sl, #23
    516e:	bhi.n	51c4 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || minute > 59
    5170:	cmp	r5, #59	; 0x3b
    5172:	bhi.n	51c4 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
      || second > 59) {
    5174:	cmp.w	r9, #59	; 0x3b
    5178:	bhi.n	51c4 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // update directory entry
  if (!sync()) {
    517a:	bl	4e68 <ExFatFile::sync()>
    517e:	cbz	r0, 51c4 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    5180:	mov.w	r3, r9, asr #1
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    5184:	orr.w	r4, fp, r4, lsl #5
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    5188:	orr.w	r5, r3, r5, lsl #5
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    518c:	orr.w	r4, r4, r7, lsl #9
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    5190:	orr.w	r5, r5, sl, lsl #11
    goto fail;
  }

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;
    5194:	tst.w	r9, #1
    5198:	mov.w	r7, #0
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    519c:	uxth	r4, r4
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    519e:	uxth	r5, r5
    51a0:	ite	eq
    51a2:	moveq.w	r9, #0
    51a6:	movne.w	r9, #100	; 0x64
//------------------------------------------------------------------------------
bool ExFatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
  DirFile_t* df;
  uint8_t* cache;
  uint16_t checksum = 0;
    51aa:	mov	fp, r7
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        m_vol->dataCacheDirty();
        if (flags & T_ACCESS) {
    51ac:	and.w	sl, r8, #1

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    51b0:	ldrb.w	r3, [r6, #48]	; 0x30
    51b4:	uxtb	r1, r7
    51b6:	cmp	r3, r1
    51b8:	bcc.n	5224 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xf4>
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    51ba:	movs	r2, #0
    51bc:	mov	r0, r6
    51be:	bl	3f72 <ExFatFile::dirCache(unsigned char, unsigned char)>
    if (!cache) {
    51c2:	cbnz	r0, 51ca <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x9a>
    goto fail;
  }
  return true;

 fail:
  return false;
    51c4:	movs	r0, #0
    51c6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cache = dirCache(is, FsCache::CACHE_FOR_READ);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    51ca:	ldrb	r3, [r0, #0]
    51cc:	cmp	r3, #133	; 0x85
    51ce:	beq.n	51da <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xaa>
    51d0:	bcc.n	51c4 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    51d2:	subs	r3, #192	; 0xc0
    51d4:	cmp	r3, #1
    51d6:	bls.n	5218 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xe8>
    51d8:	b.n	51c4 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    51da:	ldrb.w	r3, [r6, #49]	; 0x31
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        m_vol->dataCacheDirty();
    51de:	ldr	r2, [r6, #32]
    51e0:	and.w	r3, r3, #55	; 0x37
    51e4:	strh	r3, [r0, #4]
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    51e6:	ldrb.w	r3, [r2, #528]	; 0x210
    51ea:	orr.w	r3, r3, #1
    51ee:	strb.w	r3, [r2, #528]	; 0x210
        if (flags & T_ACCESS) {
    51f2:	cmp.w	sl, #0
    51f6:	beq.n	51fc <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0xcc>
    51f8:	strh	r5, [r0, #16]
    51fa:	strh	r4, [r0, #18]
          setLe16(df->accessTime, time);
          setLe16(df->accessDate, date);
        }
        if (flags & T_CREATE) {
    51fc:	tst.w	r8, #2
          df->createTimeMs = ms10;
    5200:	ittt	ne
    5202:	strbne.w	r9, [r0, #20]
    5206:	strhne	r5, [r0, #8]
    5208:	strhne	r4, [r0, #10]
          setLe16(df->createTime, time);
          setLe16(df->createDate, date);
        }
        if (flags & T_WRITE) {
    520a:	tst.w	r8, #4
          df->modifyTimeMs = ms10;
    520e:	ittt	ne
    5210:	strbne.w	r9, [r0, #21]
    5214:	strhne	r5, [r0, #12]
    5216:	strhne	r4, [r0, #14]
      default:
        DBG_FAIL_MACRO;
        goto fail;
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
    5218:	mov	r1, fp
    521a:	bl	4bc8 <exFatDirChecksum(unsigned char const*, unsigned short)>
    521e:	adds	r7, #1
    5220:	mov	fp, r0

  date = FS_DATE(year, month, day);
  time = FS_TIME(hour, minute, second);
  ms10 = second & 1 ? 100 : 0;

  for (uint8_t is = 0; is <= m_setCount ; is++) {
    5222:	b.n	51b0 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x80>
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
  }
  df = reinterpret_cast<DirFile_t*>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
    5224:	movs	r2, #1
    5226:	add.w	r1, r6, #36	; 0x24
    522a:	ldr	r0, [r6, #32]
    522c:	bl	48b2 <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    5230:	cmp	r0, #0
    5232:	beq.n	51c4 <ExFatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x94>
    5234:	strh.w	fp, [r0, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe16(df->setChecksum, checksum);
  if (!m_vol->cacheSync()) {
    5238:	ldr	r0, [r6, #32]
    523a:	bl	4bf6 <ExFatPartition::cacheSync()>
    523e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00005242 <ExFatFile::truncate()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    5242:	push	{r0, r1, r4, r5, r6, lr}
    5244:	ldrb.w	r3, [r0, #51]	; 0x33
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    5248:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    524a:	mov	r4, r0
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    524c:	bmi.n	5252 <ExFatFile::truncate()+0x10>
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    524e:	movs	r0, #0
    5250:	b.n	52fc <ExFatFile::truncate()+0xba>
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    5252:	ldr	r5, [r0, #28]
    5254:	cmp	r5, #0
    5256:	beq.n	52da <ExFatFile::truncate()+0x98>
      return true;
  }
  if (isContiguous()) {
    5258:	and.w	r3, r3, #64	; 0x40
    525c:	and.w	r1, r3, #255	; 0xff
    5260:	ldr	r6, [r0, #24]
    5262:	cbz	r3, 52a2 <ExFatFile::truncate()+0x60>
    5264:	ldr	r3, [r4, #32]
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    5266:	ldrd	r0, r1, [r0, #8]
    526a:	ldrb.w	r2, [r3, #1093]	; 0x445
    526e:	adds.w	r0, r0, #4294967295
    5272:	add.w	r2, r2, #9
    5276:	uxtb	r2, r2
    5278:	adc.w	r1, r1, #4294967295
    527c:	bl	a434 <__aeabi_llsr>
    5280:	adds	r2, r0, #1
    if (m_curCluster) {
    5282:	cbz	r6, 5290 <ExFatFile::truncate()+0x4e>
      toFree = m_curCluster + 1;
      nc -= 1 + m_curCluster - m_firstCluster;
    5284:	subs	r5, #1
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    5286:	adds	r3, r6, #1
      nc -= 1 + m_curCluster - m_firstCluster;
    5288:	subs	r5, r5, r6
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    528a:	str	r3, [sp, #4]
      nc -= 1 + m_curCluster - m_firstCluster;
    528c:	add	r2, r5
    528e:	b.n	5294 <ExFatFile::truncate()+0x52>
    } else {
      toFree = m_firstCluster;
    5290:	str	r5, [sp, #4]
      m_firstCluster = 0;
    5292:	str	r6, [r4, #28]
    }
    if (nc && !m_vol->bitmapModify(toFree, nc, 0)) {
    5294:	cbz	r2, 52de <ExFatFile::truncate()+0x9c>
    5296:	movs	r3, #0
    5298:	ldr	r1, [sp, #4]
    529a:	ldr	r0, [r4, #32]
    529c:	bl	480c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    52a0:	b.n	52d6 <ExFatFile::truncate()+0x94>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
    52a2:	cbz	r6, 52c8 <ExFatFile::truncate()+0x86>
      toFree = 0;
    52a4:	add	r2, sp, #8
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    52a6:	ldr	r0, [r0, #32]
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
      toFree = 0;
    52a8:	str.w	r1, [r2, #-4]!
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    52ac:	mov	r1, r6
    52ae:	bl	48e8 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
      if (fg < 0) {
    52b2:	cmp	r0, #0
    52b4:	blt.n	524e <ExFatFile::truncate()+0xc>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (fg) {
    52b6:	beq.n	52cc <ExFatFile::truncate()+0x8a>
        // current cluster is end of chain
        if (!m_vol->fatPut(m_curCluster, EXFAT_EOC)) {
    52b8:	mov.w	r2, #4294967295
    52bc:	ldr	r1, [r4, #24]
    52be:	ldr	r0, [r4, #32]
    52c0:	bl	4994 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    52c4:	cbnz	r0, 52cc <ExFatFile::truncate()+0x8a>
    52c6:	b.n	524e <ExFatFile::truncate()+0xc>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
    } else {
      toFree = m_firstCluster;
    52c8:	str	r5, [sp, #4]
      m_firstCluster = 0;
    52ca:	str	r6, [r0, #28]
    }
    if (toFree) {
    52cc:	ldr	r1, [sp, #4]
    52ce:	cbz	r1, 52de <ExFatFile::truncate()+0x9c>
      if (!m_vol->freeChain(toFree)) {
    52d0:	ldr	r0, [r4, #32]
    52d2:	bl	49ce <ExFatPartition::freeChain(unsigned long)>
    52d6:	cbnz	r0, 52de <ExFatFile::truncate()+0x9c>
    52d8:	b.n	524e <ExFatFile::truncate()+0xc>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    52da:	movs	r0, #1
    52dc:	b.n	52fc <ExFatFile::truncate()+0xba>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  }
  m_dataLength = m_curPosition;
    52de:	ldrd	r2, r3, [r4]
    52e2:	strd	r2, r3, [r4, #8]
  m_validLength = m_curPosition;
    52e6:	strd	r2, r3, [r4, #16]
  m_flags |= FILE_FLAG_DIR_DIRTY;
    52ea:	ldrb.w	r3, [r4, #51]	; 0x33
    52ee:	orn	r3, r3, #127	; 0x7f
    52f2:	strb.w	r3, [r4, #51]	; 0x33
  return sync();
    52f6:	mov	r0, r4
    52f8:	bl	4e68 <ExFatFile::sync()>

 fail:
  return false;
}
    52fc:	add	sp, #8
    52fe:	pop	{r4, r5, r6, pc}

00005300 <ExFatFile::write(void const*, unsigned int)>:
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    5300:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5304:	ldrb.w	r3, [r0, #51]	; 0x33
    5308:	mov	r9, r1

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    530a:	lsls	r1, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    530c:	mov	r4, r0
    530e:	mov	sl, r2

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    5310:	bpl.w	548a <ExFatFile::write(void const*, unsigned int)+0x18a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    5314:	lsls	r2, r3, #28
    5316:	bmi.n	5326 <ExFatFile::write(void const*, unsigned int)+0x26>
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    5318:	add.w	r3, r4, #24

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    531c:	mov	r8, sl
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    531e:	str	r3, [sp, #0]
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    5320:	mov.w	fp, #1
    5324:	b.n	53ec <ExFatFile::write(void const*, unsigned int)+0xec>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_validLength)) {
    5326:	ldrd	r2, r3, [r0, #16]
    532a:	bl	4250 <ExFatFile::seekSet(unsigned long long)>
    532e:	cmp	r0, #0
    5330:	bne.n	5318 <ExFatFile::write(void const*, unsigned int)+0x18>
    5332:	b.n	548a <ExFatFile::write(void const*, unsigned int)+0x18a>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    clusterOffset = m_curPosition & m_vol->clusterMask();
    5334:	ldr	r0, [r4, #32]
    5336:	ldr	r6, [r4, #0]
    5338:	ldr.w	r3, [r0, #1080]	; 0x438
    533c:	ands	r6, r3
    sectorOffset = clusterOffset & m_vol->sectorMask();
    533e:	ubfx	r5, r6, #0, #9
    if (clusterOffset == 0) {
    5342:	cmp	r6, #0
    5344:	beq.n	53f4 <ExFatFile::write(void const*, unsigned int)+0xf4>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    sector = m_vol->clusterStartSector(m_curCluster) +
    5346:	ldr.w	lr, [r4, #32]
             (clusterOffset >> m_vol->bytesPerSectorShift());
    534a:	ldr	r1, [r4, #24]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() const {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    534c:	ldrb.w	r2, [lr, #1093]	; 0x445
    5350:	ldr.w	r3, [lr, #1068]	; 0x42c
    5354:	subs	r1, #2
    5356:	lsls	r1, r2
    5358:	lsrs	r6, r6, #9
    535a:	add	r1, r3
    535c:	add	r1, r6

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
    535e:	cmp	r5, #0
    5360:	bne.n	545c <ExFatFile::write(void const*, unsigned int)+0x15c>
    5362:	cmp.w	r8, #512	; 0x200
    5366:	bcs.w	549e <ExFatFile::write(void const*, unsigned int)+0x19e>
      // lesser of space and amount to write
      if (n > toWrite) {
        n = toWrite;
      }

      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
    536a:	ldrd	r2, r3, [r4, #16]
    536e:	ldrd	r6, r7, [r4]
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    5372:	cmp	r7, r3
    5374:	it	eq
    5376:	cmpeq	r6, r2
    5378:	ite	cc
    537a:	movcc	r2, #1
    537c:	movcs	r2, #5
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    537e:	add.w	r0, lr, #528	; 0x210
    5382:	bl	376a <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      cache = m_vol->dataCacheGet(sector, cacheOption);
      if (!cache) {
    5386:	cmp	r0, #0
    5388:	beq.n	548a <ExFatFile::write(void const*, unsigned int)+0x18a>
             (clusterOffset >> m_vol->bytesPerSectorShift());

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    538a:	rsb	r6, r5, #512	; 0x200
    538e:	cmp	r6, r8
    5390:	it	cs
    5392:	movcs	r6, r8
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    5394:	add	r0, r5
    5396:	mov	r2, r6
    5398:	mov	r1, r9
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    539a:	add	r5, r6
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    539c:	bl	8e18 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    53a0:	cmp.w	r5, #512	; 0x200
    53a4:	bne.n	53b4 <ExFatFile::write(void const*, unsigned int)+0xb4>
  }
  uint32_t dataCacheSector() {return m_dataCache.sector();}
  bool dataCacheSync() {return m_dataCache.sync();}
    53a6:	ldr	r0, [r4, #32]
    53a8:	add.w	r0, r0, #528	; 0x210
    53ac:	bl	371e <FsCache::sync()>
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeWrite(sector, src, ns)) {
    53b0:	cmp	r0, #0
    53b2:	beq.n	548a <ExFatFile::write(void const*, unsigned int)+0x18a>
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    53b4:	ldrd	r0, r1, [r4]
    53b8:	adds	r2, r0, r6
    53ba:	adc.w	r3, r1, #0
    53be:	mov	r0, r2
    53c0:	mov	r1, r3
    53c2:	strd	r2, r3, [r4]
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    53c6:	ldrd	r2, r3, [r4, #16]
    53ca:	cmp	r3, r1
    53cc:	it	eq
    53ce:	cmpeq	r2, r0
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    src += n;
    53d0:	add	r9, r6
    toWrite -= n;
    53d2:	rsb	r8, r6, r8
    if (m_curPosition > m_validLength) {
    53d6:	bcs.n	53ec <ExFatFile::write(void const*, unsigned int)+0xec>
      m_flags |= FILE_FLAG_DIR_DIRTY;
    53d8:	ldrb.w	r3, [r4, #51]	; 0x33
    53dc:	orn	r3, r3, #127	; 0x7f
    53e0:	strb.w	r3, [r4, #51]	; 0x33
      m_validLength = m_curPosition;
    53e4:	mov	r2, r0
    53e6:	mov	r3, r1
    53e8:	strd	r2, r3, [r4, #16]
    if (!seekSet(m_validLength)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    53ec:	cmp.w	r8, #0
    53f0:	bne.n	5334 <ExFatFile::write(void const*, unsigned int)+0x34>
    53f2:	b.n	5460 <ExFatFile::write(void const*, unsigned int)+0x160>
    clusterOffset = m_curPosition & m_vol->clusterMask();
    sectorOffset = clusterOffset & m_vol->sectorMask();
    if (clusterOffset == 0) {
      // start of new cluster
      if (m_curCluster != 0) {
    53f4:	ldr	r7, [r4, #24]
    53f6:	cbz	r7, 5446 <ExFatFile::write(void const*, unsigned int)+0x146>
        int fg;

        if (isContiguous()) {
    53f8:	ldrb.w	r3, [r4, #51]	; 0x33
    53fc:	lsls	r3, r3, #25
    53fe:	bpl.n	5436 <ExFatFile::write(void const*, unsigned int)+0x136>
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    5400:	ldrb.w	r2, [r0, #1093]	; 0x445
      // start of new cluster
      if (m_curCluster != 0) {
        int fg;

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
    5404:	ldr	r3, [r4, #28]
    5406:	str	r3, [sp, #4]
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    5408:	ldrd	r0, r1, [r4, #8]
    540c:	adds	r2, #9
    540e:	adds.w	r0, r0, #4294967295
    5412:	adc.w	r1, r1, #4294967295
    5416:	uxtb	r2, r2
    5418:	bl	a434 <__aeabi_llsr>
    541c:	ldr	r3, [sp, #4]
    541e:	add	r0, r3
    5420:	cmp	r7, r0
    5422:	bcc.n	5430 <ExFatFile::write(void const*, unsigned int)+0x130>
            goto fail;
          }
        }
        if (fg == 0) {
          // add cluster if at end of chain
          if (!addCluster()) {
    5424:	mov	r0, r4
    5426:	bl	4c1c <ExFatFile::addCluster()>
    542a:	cmp	r0, #0
    542c:	bne.n	5346 <ExFatFile::write(void const*, unsigned int)+0x46>
    542e:	b.n	548a <ExFatFile::write(void const*, unsigned int)+0x18a>

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
            m_curCluster++;
    5430:	adds	r7, #1
    5432:	str	r7, [r4, #24]
    5434:	b.n	5346 <ExFatFile::write(void const*, unsigned int)+0x46>
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    5436:	ldr	r2, [sp, #0]
    5438:	mov	r1, r7
    543a:	bl	48e8 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    543e:	cmp	r0, #0
    5440:	blt.n	548a <ExFatFile::write(void const*, unsigned int)+0x18a>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
        if (fg == 0) {
    5442:	bne.n	5346 <ExFatFile::write(void const*, unsigned int)+0x46>
    5444:	b.n	5424 <ExFatFile::write(void const*, unsigned int)+0x124>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    5446:	ldr	r3, [r4, #28]
    5448:	cbnz	r3, 5458 <ExFatFile::write(void const*, unsigned int)+0x158>
          // allocate first cluster of file
          if (!addCluster()) {
    544a:	mov	r0, r4
    544c:	bl	4c1c <ExFatFile::addCluster()>
    5450:	cbz	r0, 548a <ExFatFile::write(void const*, unsigned int)+0x18a>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    5452:	ldr	r3, [r4, #24]
    5454:	str	r3, [r4, #28]
    5456:	b.n	5346 <ExFatFile::write(void const*, unsigned int)+0x46>
        } else {
          m_curCluster = m_firstCluster;
    5458:	str	r3, [r4, #24]
    545a:	b.n	5346 <ExFatFile::write(void const*, unsigned int)+0x46>
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    545c:	movs	r2, #1
    545e:	b.n	537e <ExFatFile::write(void const*, unsigned int)+0x7e>
    if (m_curPosition > m_validLength) {
      m_flags |= FILE_FLAG_DIR_DIRTY;
      m_validLength = m_curPosition;
    }
  }
  if (m_curPosition > m_dataLength) {
    5460:	ldrd	r0, r1, [r4]
    5464:	ldrd	r2, r3, [r4, #8]
    5468:	cmp	r3, r1
    546a:	it	eq
    546c:	cmpeq	r2, r0
    546e:	bcs.n	5476 <ExFatFile::write(void const*, unsigned int)+0x176>
    m_dataLength = m_curPosition;
    5470:	strd	r0, r1, [r4, #8]
    5474:	b.n	547c <ExFatFile::write(void const*, unsigned int)+0x17c>
    // update fileSize and insure sync will update dir entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    5476:	ldr	r3, [pc, #148]	; (550c <ExFatFile::write(void const*, unsigned int)+0x20c>)
    5478:	ldr	r3, [r3, #0]
    547a:	cbz	r3, 549a <ExFatFile::write(void const*, unsigned int)+0x19a>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    547c:	ldrb.w	r3, [r4, #51]	; 0x33
    5480:	orn	r3, r3, #127	; 0x7f
    5484:	strb.w	r3, [r4, #51]	; 0x33
    5488:	b.n	549a <ExFatFile::write(void const*, unsigned int)+0x19a>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    548a:	ldrb.w	r3, [r4, #50]	; 0x32
    548e:	orr.w	r3, r3, #1
    5492:	strb.w	r3, [r4, #50]	; 0x32
  return 0;
    5496:	movs	r0, #0
    5498:	b.n	5506 <ExFatFile::write(void const*, unsigned int)+0x206>
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
  }
  return nbyte;
    549a:	mov	r0, sl
    549c:	b.n	5506 <ExFatFile::write(void const*, unsigned int)+0x206>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
    549e:	cmp.w	r8, #1024	; 0x400
    54a2:	ldr.w	r7, [lr, #540]	; 0x21c
    54a6:	ldr.w	r0, [lr, #532]	; 0x214
    54aa:	bcc.n	54d6 <ExFatFile::write(void const*, unsigned int)+0x1d6>
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
      // Limit writes to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    54ac:	lsl.w	r3, fp, r2
    54b0:	subs	r6, r3, r6
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
    54b2:	mov.w	ip, r8, lsr #9
    54b6:	cmp	ip, r6
    54b8:	mov	r3, ip
    54ba:	it	cs
    54bc:	movcs	r3, r6
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    54be:	cmp	r1, r7
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    54c0:	mov.w	r6, r3, lsl #9
    54c4:	bhi.n	54cc <ExFatFile::write(void const*, unsigned int)+0x1cc>
    54c6:	adds	r2, r1, r3
    54c8:	cmp	r7, r2
    54ca:	bcc.n	54f8 <ExFatFile::write(void const*, unsigned int)+0x1f8>
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    54cc:	ldr	r2, [r0, #0]
    54ce:	ldr	r5, [r2, #36]	; 0x24
    54d0:	mov	r2, r9
    54d2:	blx	r5
    54d4:	b.n	53b0 <ExFatFile::write(void const*, unsigned int)+0xb0>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    54d6:	cmp	r1, r7
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    54d8:	ittt	eq
    54da:	strbeq.w	r5, [lr, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    54de:	moveq.w	r3, #4294967295
    54e2:	streq.w	r3, [lr, #540]	; 0x21c
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    54e6:	ldr	r3, [r0, #0]
    54e8:	mov	r2, r9
    54ea:	ldr	r3, [r3, #32]
    54ec:	blx	r3
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    54ee:	cmp	r0, #0
    54f0:	beq.n	548a <ExFatFile::write(void const*, unsigned int)+0x18a>
         DBG_FAIL_MACRO;
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      n = m_vol->bytesPerSector();
    54f2:	mov.w	r6, #512	; 0x200
    54f6:	b.n	53b4 <ExFatFile::write(void const*, unsigned int)+0xb4>
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    54f8:	mov.w	r2, #4294967295
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    54fc:	strb.w	r5, [lr, #528]	; 0x210
    m_sector = 0XFFFFFFFF;
    5500:	str.w	r2, [lr, #540]	; 0x21c
    5504:	b.n	54cc <ExFatFile::write(void const*, unsigned int)+0x1cc>

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
  return 0;
}
    5506:	add	sp, #12
    5508:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    550c:	.word	0x2001ceb4

00005510 <initFatDirCallback(unsigned long, void*)>:
  uint16_t count;
  uint16_t dotcount;
};
static const uint8_t * initFatDirCallback(uint32_t sector, void *context) {
  struct initFatDirState * state = (struct initFatDirState *)context;
  if (state->pr && ++state->count >= state->dotcount) {
    5510:	ldr	r0, [r1, #4]
  uint8_t * buffer;
  print_t * pr;
  uint16_t count;
  uint16_t dotcount;
};
static const uint8_t * initFatDirCallback(uint32_t sector, void *context) {
    5512:	push	{r4, lr}
    5514:	mov	r4, r1
  struct initFatDirState * state = (struct initFatDirState *)context;
  if (state->pr && ++state->count >= state->dotcount) {
    5516:	cbz	r0, 5530 <initFatDirCallback(unsigned long, void*)+0x20>
    5518:	ldrh	r3, [r1, #8]
    551a:	ldrh	r2, [r1, #10]
    551c:	adds	r3, #1
    551e:	uxth	r3, r3
    5520:	cmp	r2, r3
    5522:	strh	r3, [r1, #8]
    5524:	bhi.n	5530 <initFatDirCallback(unsigned long, void*)+0x20>
    state->pr->write(".");
    5526:	ldr	r1, [pc, #12]	; (5534 <initFatDirCallback(unsigned long, void*)+0x24>)
    5528:	bl	6a8 <Print::write(char const*)>
    state->count = 0;
    552c:	movs	r3, #0
    552e:	strh	r3, [r4, #8]
  }
  return state->buffer;
    5530:	ldr	r0, [r4, #0]
}
    5532:	pop	{r4, pc}
    5534:	.word	0x00012c2d

00005538 <FatFormatter::initFatDir(unsigned char, unsigned long)>:
bool FatFormatter::initFatDir(uint8_t fatType, uint32_t sectorCount) {
    5538:	push	{r4, r5, r6, r7, lr}
    553a:	mov	r4, r0
    553c:	sub	sp, #28
    553e:	mov	r6, r1
    5540:	mov	r5, r2
  size_t n;
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    5542:	movs	r1, #0
    5544:	mov.w	r2, #512	; 0x200
    5548:	ldr	r0, [r0, #36]	; 0x24
    554a:	bl	8fc0 <memset>
  writeMsg("Writing FAT ");
    554e:	ldr	r0, [r4, #32]
    5550:	cbz	r0, 5558 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x20>
    5552:	ldr	r1, [pc, #128]	; (55d4 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x9c>)
    5554:	bl	6a8 <Print::write(char const*)>
  struct initFatDirState state;
  state.buffer = m_secBuf;
    5558:	ldr	r3, [r4, #36]	; 0x24
    555a:	str	r3, [sp, #12]
  state.pr = m_pr;
    555c:	ldr	r3, [r4, #32]
    555e:	str	r3, [sp, #16]
  state.count = 0;
  state.dotcount = sectorCount/32;
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    5560:	ldr	r0, [r4, #28]
    5562:	ldr	r1, [r4, #12]
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
  writeMsg("Writing FAT ");
  struct initFatDirState state;
  state.buffer = m_secBuf;
  state.pr = m_pr;
  state.count = 0;
    5564:	movs	r3, #0
    5566:	strh.w	r3, [sp, #20]
  state.dotcount = sectorCount/32;
    556a:	lsrs	r3, r5, #5
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    556c:	add	r2, sp, #12
  writeMsg("Writing FAT ");
  struct initFatDirState state;
  state.buffer = m_secBuf;
  state.pr = m_pr;
  state.count = 0;
  state.dotcount = sectorCount/32;
    556e:	strh.w	r3, [sp, #22]
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
    5572:	ldr	r3, [r0, #0]
    5574:	str	r2, [sp, #0]
    5576:	ldr	r7, [r3, #40]	; 0x28
    5578:	ldr	r3, [pc, #92]	; (55d8 <FatFormatter::initFatDir(unsigned char, unsigned long)+0xa0>)
    557a:	subs	r2, r5, #1
    557c:	adds	r1, #1
    557e:	blx	r7
    5580:	cbnz	r0, 5586 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x4e>
     return false;
    5582:	movs	r0, #0
    5584:	b.n	55ce <FatFormatter::initFatDir(unsigned char, unsigned long)+0x96>
  }
  writeMsg("\r\n");
    5586:	ldr	r0, [r4, #32]
    5588:	cbz	r0, 5590 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x58>
    558a:	ldr	r1, [pc, #80]	; (55dc <FatFormatter::initFatDir(unsigned char, unsigned long)+0xa4>)
    558c:	bl	6a8 <Print::write(char const*)>
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
    5590:	ldr	r3, [r4, #36]	; 0x24
    5592:	movs	r2, #248	; 0xf8
  n = fatType == 16 ? 4 : 12;
    5594:	cmp	r6, #16
  if (!m_dev->writeSectorsCallback(m_fatStart + 1, sectorCount - 1, initFatDirCallback, &state)) {
     return false;
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
    5596:	strb	r2, [r3, #0]
  n = fatType == 16 ? 4 : 12;
  for (size_t i = 1; i < n; i++) {
    m_secBuf[i] = 0XFF;
    5598:	mov.w	r0, #255	; 0xff
     return false;
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
  n = fatType == 16 ? 4 : 12;
    559c:	ite	eq
    559e:	moveq	r2, #4
    55a0:	movne	r2, #12
  for (size_t i = 1; i < n; i++) {
    55a2:	movs	r3, #1
    m_secBuf[i] = 0XFF;
    55a4:	ldr	r1, [r4, #36]	; 0x24
    55a6:	strb	r0, [r1, r3]
  }
  writeMsg("\r\n");
  // Allocate reserved clusters and root for FAT32.
  m_secBuf[0] = 0XF8;
  n = fatType == 16 ? 4 : 12;
  for (size_t i = 1; i < n; i++) {
    55a8:	adds	r3, #1
    55aa:	cmp	r2, r3
    55ac:	bne.n	55a4 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x6c>
    m_secBuf[i] = 0XFF;
  }
  return m_dev->writeSector(m_fatStart, m_secBuf) &&
    55ae:	ldr	r0, [r4, #28]
    55b0:	ldr	r2, [r4, #36]	; 0x24
    55b2:	ldr	r3, [r0, #0]
    55b4:	ldr	r1, [r4, #12]
    55b6:	ldr	r3, [r3, #32]
    55b8:	blx	r3
    55ba:	cmp	r0, #0
    55bc:	beq.n	5582 <FatFormatter::initFatDir(unsigned char, unsigned long)+0x4a>
         m_dev->writeSector(m_fatStart + m_fatSize, m_secBuf);
    55be:	ldr	r0, [r4, #28]
    55c0:	ldr	r5, [r4, #12]
    55c2:	ldr	r1, [r4, #8]
    55c4:	ldr	r3, [r0, #0]
    55c6:	ldr	r2, [r4, #36]	; 0x24
    55c8:	ldr	r3, [r3, #32]
    55ca:	add	r1, r5
    55cc:	blx	r3
}
    55ce:	add	sp, #28
    55d0:	pop	{r4, r5, r6, r7, pc}
    55d2:	nop
    55d4:	.word	0x00012c20
    55d8:	.word	0x00005511
    55dc:	.word	0x00012c9f

000055e0 <FatFormatter::initPbs()>:
//------------------------------------------------------------------------------
void FatFormatter::initPbs() {
    55e0:	push	{r3, r4, r5, lr}
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    55e2:	ldr	r4, [r0, #36]	; 0x24
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    55e4:	mov.w	r2, #512	; 0x200
    55e8:	movs	r1, #0
  }
  return m_dev->writeSector(m_fatStart, m_secBuf) &&
         m_dev->writeSector(m_fatStart + m_fatSize, m_secBuf);
}
//------------------------------------------------------------------------------
void FatFormatter::initPbs() {
    55ea:	mov	r5, r0
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    55ec:	mov	r0, r4
    55ee:	bl	8fc0 <memset>
  pbs->jmpInstruction[0] = 0XEB;
    55f2:	movs	r3, #235	; 0xeb
    55f4:	strb	r3, [r4, #0]
  pbs->jmpInstruction[1] = 0X76;
    55f6:	movs	r3, #118	; 0x76
    55f8:	strb	r3, [r4, #1]
  pbs->jmpInstruction[2] = 0X90;
    55fa:	mov	r3, r4
    55fc:	movs	r2, #144	; 0x90
    55fe:	strb.w	r2, [r3, #2]!
  for (uint8_t i = 0; i < sizeof(pbs->oemName); i++) {
    pbs->oemName[i] = ' ';
    5602:	movs	r1, #32
    5604:	add.w	r2, r4, #10
    5608:	strb.w	r1, [r3, #1]!
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
  pbs->jmpInstruction[0] = 0XEB;
  pbs->jmpInstruction[1] = 0X76;
  pbs->jmpInstruction[2] = 0X90;
  for (uint8_t i = 0; i < sizeof(pbs->oemName); i++) {
    560c:	cmp	r3, r2
    560e:	bne.n	5608 <FatFormatter::initPbs()+0x28>
    5610:	mov.w	r3, #512	; 0x200
    5614:	strh.w	r3, [r4, #11]
    pbs->oemName[i] = ' ';
  }
  setLe16(pbs->bpb.bpb16.bytesPerSector, BYTES_PER_SECTOR);
  pbs->bpb.bpb16.sectorsPerCluster = m_sectorsPerCluster;
    5618:	ldrb.w	r3, [r5, #43]	; 0x2b
    561c:	strb	r3, [r4, #13]
  setLe16(pbs->bpb.bpb16.reservedSectorCount, m_reservedSectorCount);
    561e:	ldrh	r3, [r5, #40]	; 0x28
    5620:	strh	r3, [r4, #14]
  pbs->bpb.bpb16.fatCount = 2;
    5622:	movs	r3, #2
    5624:	strb	r3, [r4, #16]
  // skip rootDirEntryCount
  // skip totalSectors16
  pbs->bpb.bpb16.mediaType = 0XF8;
    5626:	movs	r3, #248	; 0xf8
    5628:	strb	r3, [r4, #21]
  // skip sectorsPerFat16
  // skip sectorsPerTrack
  // skip headCount
  setLe32(pbs->bpb.bpb16.hidddenSectors, m_relativeSectors);
    562a:	ldr	r3, [r5, #16]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    562c:	str	r3, [r4, #28]
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
    562e:	ldr	r3, [r5, #24]
    5630:	str	r3, [r4, #32]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    5632:	movw	r3, #43605	; 0xaa55
    5636:	strh.w	r3, [r4, #510]	; 0x1fe
    563a:	pop	{r3, r4, r5, pc}

0000563c <FatFormatter::writeMbr()>:
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
}
//------------------------------------------------------------------------------
bool FatFormatter::writeMbr() {
    563c:	push	{r4, r5, r6, lr}
    563e:	mov	r4, r0
  memset(m_secBuf, 0, BYTES_PER_SECTOR);
    5640:	mov.w	r2, #512	; 0x200
    5644:	movs	r1, #0
    5646:	ldr	r0, [r0, #36]	; 0x24
    5648:	bl	8fc0 <memset>
  MbrSector_t* mbr = reinterpret_cast<MbrSector_t*>(m_secBuf);
    564c:	ldr	r5, [r4, #36]	; 0x24

#if USE_LBA_TO_CHS
  lbaToMbrChs(mbr->part->beginCHS, m_capacityMB, m_relativeSectors);
    564e:	ldr	r2, [r4, #16]
    5650:	ldr	r1, [r4, #0]
    5652:	addw	r0, r5, #447	; 0x1bf
    5656:	bl	3690 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>
  lbaToMbrChs(mbr->part->endCHS, m_capacityMB,
              m_relativeSectors + m_totalSectors -1);
    565a:	ldr	r3, [r4, #24]
    565c:	ldr	r2, [r4, #16]
    565e:	ldr	r1, [r4, #0]
    5660:	add	r2, r3
    5662:	addw	r0, r5, #451	; 0x1c3
    5666:	subs	r2, #1
    5668:	bl	3690 <lbaToMbrChs(unsigned char*, unsigned long, unsigned long)>
  mbr->part->endCHS[0] = 0XFE;
  mbr->part->endCHS[1] = 0XFF;
  mbr->part->endCHS[2] = 0XFF;
#endif  // USE_LBA_TO_CHS

  mbr->part->type = m_partType;
    566c:	ldrb.w	r3, [r4, #42]	; 0x2a
    5670:	strb.w	r3, [r5, #450]	; 0x1c2
  setLe32(mbr->part->relativeSectors, m_relativeSectors);
    5674:	ldr	r3, [r4, #16]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    5676:	str.w	r3, [r5, #454]	; 0x1c6
  setLe32(mbr->part->totalSectors, m_totalSectors);
    567a:	ldr	r3, [r4, #24]
  setLe16(mbr->signature, MBR_SIGNATURE);
  return m_dev->writeSector(0, m_secBuf);
    567c:	ldr	r0, [r4, #28]
    567e:	str.w	r3, [r5, #458]	; 0x1ca
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    5682:	movw	r3, #43605	; 0xaa55
    5686:	strh.w	r3, [r5, #510]	; 0x1fe
    568a:	ldr	r3, [r0, #0]
    568c:	ldr	r2, [r4, #36]	; 0x24
    568e:	ldr	r3, [r3, #32]
    5690:	movs	r1, #0
}
    5692:	ldmia.w	sp!, {r4, r5, r6, lr}

  mbr->part->type = m_partType;
  setLe32(mbr->part->relativeSectors, m_relativeSectors);
  setLe32(mbr->part->totalSectors, m_totalSectors);
  setLe16(mbr->signature, MBR_SIGNATURE);
  return m_dev->writeSector(0, m_secBuf);
    5696:	bx	r3

00005698 <FatFormatter::makeFat16()>:
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
  // skip rest of bpb
  setLe16(pbs->signature, PBR_SIGNATURE);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
    5698:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    569a:	mov.w	r3, #256	; 0x100
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    569e:	ldr	r5, [r0, #36]	; 0x24

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    56a0:	ldr.w	lr, [r0, #20]
    56a4:	ldrb.w	r2, [r0, #43]	; 0x2b
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    56a8:	str	r3, [r0, #4]
  setLe32(pbs->bpb.bpb16.totalSectors32, m_totalSectors);
  // skip rest of bpb
  setLe16(pbs->signature, PBR_SIGNATURE);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat16() {
    56aa:	mov	r4, r0
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    56ac:	ldr	r3, [r4, #4]
    56ae:	rsb	r1, r3, lr
    56b2:	udiv	r1, r1, r2
    m_fatSize = (nc + 2 + (BYTES_PER_SECTOR/2) - 1)/(BYTES_PER_SECTOR/2);
    56b6:	addw	r6, r1, #257	; 0x101
    56ba:	lsrs	r6, r6, #8
    r = BU16 + 1 + 2*m_fatSize + FAT16_ROOT_SECTOR_COUNT;
    56bc:	lsls	r0, r6, #1
    56be:	add.w	r7, r0, #161	; 0xa1
    if (m_dataStart >= r) {
    56c2:	cmp	r3, r7
    56c4:	bcc.n	56dc <FatFormatter::makeFat16()+0x44>
      m_relativeSectors = m_dataStart - r + BU16;
    56c6:	subs	r3, r3, r7
    56c8:	str	r6, [r4, #8]
    56ca:	add.w	r6, r3, #128	; 0x80
    56ce:	str	r6, [r4, #16]
      break;
    }
  }
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    56d0:	subw	r6, r1, #4085	; 0xff5
    56d4:	cmp.w	r6, #61440	; 0xf000
    56d8:	bcs.n	56e2 <FatFormatter::makeFat16()+0x4a>
    56da:	b.n	56f0 <FatFormatter::makeFat16()+0x58>
bool FatFormatter::makeFat16() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);

  for (m_dataStart = 2*BU16; ; m_dataStart += BU16) {
    56dc:	adds	r3, #128	; 0x80
    56de:	str	r3, [r4, #4]
    56e0:	b.n	56ac <FatFormatter::makeFat16()+0x14>
      break;
    }
  }
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    56e2:	ldr	r0, [r4, #32]
    56e4:	cmp	r0, #0
    56e6:	beq.n	5790 <FatFormatter::makeFat16()+0xf8>
    56e8:	ldr	r1, [pc, #168]	; (5794 <FatFormatter::makeFat16()+0xfc>)
    56ea:	bl	6a8 <Print::write(char const*)>
    56ee:	b.n	5790 <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  m_reservedSectorCount = 1;
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
    56f0:	adds	r3, #129	; 0x81
    56f2:	str	r3, [r4, #12]
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
    56f4:	add.w	r3, r0, #33	; 0x21
    56f8:	mla	r3, r1, r2, r3
  if (m_totalSectors < 65536) {
    56fc:	cmp.w	r3, #65536	; 0x10000
    return false;
  }
  m_reservedSectorCount = 1;
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
    5700:	str	r3, [r4, #24]
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = 1;
    5702:	mov.w	r6, #1
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
  if (m_totalSectors < 65536) {
    m_partType = 0X04;
    5706:	ite	cc
    5708:	movcc	r3, #4
  } else {
    m_partType = 0X06;
    570a:	movcs	r3, #6
  // check valid cluster count for FAT16 volume
  if (nc < 4085 || nc >= 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = 1;
    570c:	strh	r6, [r4, #40]	; 0x28
  m_totalSectors = nc*m_sectorsPerCluster
                   + 2*m_fatSize + m_reservedSectorCount + 32;
  if (m_totalSectors < 65536) {
    m_partType = 0X04;
  } else {
    m_partType = 0X06;
    570e:	strb.w	r3, [r4, #42]	; 0x2a
  }
  // write MBR
  if (!writeMbr()) {
    5712:	mov	r0, r4
    5714:	bl	563c <FatFormatter::writeMbr()>
    5718:	cmp	r0, #0
    571a:	beq.n	5790 <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  initPbs();
    571c:	mov	r0, r4
    571e:	bl	55e0 <FatFormatter::initPbs()>
    5722:	mov.w	r3, #512	; 0x200
    5726:	strh.w	r3, [r5, #17]
    572a:	ldr	r3, [r4, #8]
    572c:	strh	r3, [r5, #22]
  setLe16(pbs->bpb.bpb16.rootDirEntryCount, FAT16_ROOT_ENTRY_COUNT);
  setLe16(pbs->bpb.bpb16.sectorsPerFat16, m_fatSize);
  pbs->bpb.bpb16.physicalDriveNumber = 0X80;
    572e:	movs	r3, #128	; 0x80
    5730:	strb.w	r3, [r5, #36]	; 0x24
  pbs->bpb.bpb16.extSignature = EXTENDED_BOOT_SIGNATURE;
    5734:	movs	r3, #41	; 0x29
    5736:	strb.w	r3, [r5, #38]	; 0x26
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    573a:	ldr	r3, [pc, #92]	; (5798 <FatFormatter::makeFat16()+0x100>)
    573c:	str.w	r3, [r5, #39]	; 0x27
    5740:	add.w	r2, r5, #53	; 0x35
    5744:	add.w	r3, r5, #42	; 0x2a
  setLe32(pbs->bpb.bpb16.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb16.volumeLabel); i++) {
    pbs->bpb.bpb16.volumeLabel[i] = ' ';
    5748:	movs	r1, #32
    574a:	strb.w	r1, [r3, #1]!
  setLe16(pbs->bpb.bpb16.rootDirEntryCount, FAT16_ROOT_ENTRY_COUNT);
  setLe16(pbs->bpb.bpb16.sectorsPerFat16, m_fatSize);
  pbs->bpb.bpb16.physicalDriveNumber = 0X80;
  pbs->bpb.bpb16.extSignature = EXTENDED_BOOT_SIGNATURE;
  setLe32(pbs->bpb.bpb16.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb16.volumeLabel); i++) {
    574e:	cmp	r3, r2
    5750:	bne.n	574a <FatFormatter::makeFat16()+0xb2>
    pbs->bpb.bpb16.volumeLabel[i] = ' ';
  }
  pbs->bpb.bpb16.volumeType[0] = 'F';
    5752:	movs	r3, #70	; 0x46
    5754:	strb.w	r3, [r5, #54]	; 0x36
  pbs->bpb.bpb16.volumeType[1] = 'A';
    5758:	movs	r3, #65	; 0x41
    575a:	strb.w	r3, [r5, #55]	; 0x37
  pbs->bpb.bpb16.volumeType[2] = 'T';
    575e:	movs	r3, #84	; 0x54
    5760:	strb.w	r3, [r5, #56]	; 0x38
  pbs->bpb.bpb16.volumeType[3] = '1';
    5764:	movs	r3, #49	; 0x31
    5766:	strb.w	r3, [r5, #57]	; 0x39
  pbs->bpb.bpb16.volumeType[4] = '6';
    576a:	movs	r3, #54	; 0x36
    576c:	strb.w	r3, [r5, #58]	; 0x3a
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)) {
    5770:	ldr	r0, [r4, #28]
    5772:	ldr	r2, [r4, #36]	; 0x24
    5774:	ldr	r3, [r0, #0]
    5776:	ldr	r1, [r4, #16]
    5778:	ldr	r3, [r3, #32]
    577a:	blx	r3
    577c:	cbz	r0, 5790 <FatFormatter::makeFat16()+0xf8>
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
    577e:	ldr	r2, [r4, #4]
    5780:	ldr	r3, [r4, #12]
    5782:	mov	r0, r4
    5784:	subs	r2, r2, r3
    5786:	movs	r1, #16
}
    5788:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  pbs->bpb.bpb16.volumeType[3] = '1';
  pbs->bpb.bpb16.volumeType[4] = '6';
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)) {
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
    578c:	b.w	5538 <FatFormatter::initFatDir(unsigned char, unsigned long)>
}
    5790:	movs	r0, #0
    5792:	pop	{r3, r4, r5, r6, r7, pc}
    5794:	.word	0x00012c79
    5798:	.word	0x0012d687

0000579c <FatFormatter::makeFat32()>:
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
    579c:	push	{r3, r4, r5, r6, r7, lr}
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
    579e:	mov.w	r3, #8192	; 0x2000
    57a2:	str	r3, [r0, #16]
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    57a4:	mov.w	r3, #16384	; 0x4000
    57a8:	str	r3, [r0, #4]
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
  uint32_t nc;
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
    57aa:	ldr	r5, [r0, #36]	; 0x24
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    57ac:	ldr	r3, [r0, #20]
    57ae:	ldrb.w	r1, [r0, #43]	; 0x2b
    return false;
  }
  return initFatDir(16, m_dataStart - m_fatStart);
}
//------------------------------------------------------------------------------
bool FatFormatter::makeFat32() {
    57b2:	mov	r4, r0
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    nc = (m_sectorCount - m_dataStart)/m_sectorsPerCluster;
    57b4:	ldr	r2, [r4, #4]
    57b6:	subs	r0, r3, r2
    57b8:	udiv	r0, r0, r1
    m_fatSize = (nc + 2 + (BYTES_PER_SECTOR/4) - 1)/(BYTES_PER_SECTOR/4);
    57bc:	add.w	r6, r0, #129	; 0x81
    57c0:	lsrs	r6, r6, #7
    r = m_relativeSectors + 9 + 2*m_fatSize;
    if (m_dataStart >= r) {
    57c2:	mov.w	lr, r6, lsl #1
    57c6:	add.w	r7, lr, #8192	; 0x2000
    57ca:	adds	r7, #9
    57cc:	cmp	r2, r7
    57ce:	bcs.n	57d8 <FatFormatter::makeFat32()+0x3c>
  uint32_t r;
  PbsFat_t* pbs = reinterpret_cast<PbsFat_t*>(m_secBuf);
  FsInfo_t* fsi = reinterpret_cast<FsInfo_t*>(m_secBuf);

  m_relativeSectors = BU32;
  for (m_dataStart = 2*BU32; ; m_dataStart += BU32) {
    57d0:	add.w	r2, r2, #8192	; 0x2000
    57d4:	str	r2, [r4, #4]
    57d6:	b.n	57b4 <FatFormatter::makeFat32()+0x18>
    if (m_dataStart >= r) {
      break;
    }
  }
  // error if too few clusters in FAT32 volume
  if (nc < 65525) {
    57d8:	movw	r3, #65524	; 0xfff4
    57dc:	cmp	r0, r3
    57de:	str	r6, [r4, #8]
    57e0:	bhi.n	57f2 <FatFormatter::makeFat32()+0x56>
    writeMsg("Bad cluster count\r\n");
    57e2:	ldr	r0, [r4, #32]
    57e4:	cmp	r0, #0
    57e6:	beq.w	592a <FatFormatter::makeFat32()+0x18e>
    57ea:	ldr	r1, [pc, #324]	; (5930 <FatFormatter::makeFat32()+0x194>)
    57ec:	bl	6a8 <Print::write(char const*)>
    57f0:	b.n	592a <FatFormatter::makeFat32()+0x18e>
    return false;
  }
  m_reservedSectorCount = m_dataStart - m_relativeSectors - 2*m_fatSize;
    57f2:	sub.w	r3, r2, #8192	; 0x2000
    57f6:	rsb	r3, lr, r3
    57fa:	uxth	r3, r3
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
  m_totalSectors = nc*m_sectorsPerCluster + m_dataStart - m_relativeSectors;
    57fc:	mla	r2, r0, r1, r2
  // error if too few clusters in FAT32 volume
  if (nc < 65525) {
    writeMsg("Bad cluster count\r\n");
    return false;
  }
  m_reservedSectorCount = m_dataStart - m_relativeSectors - 2*m_fatSize;
    5800:	strh	r3, [r4, #40]	; 0x28
  m_fatStart = m_relativeSectors + m_reservedSectorCount;
    5802:	add.w	r3, r3, #8192	; 0x2000
    5806:	str	r3, [r4, #12]
  m_totalSectors = nc*m_sectorsPerCluster + m_dataStart - m_relativeSectors;
    5808:	sub.w	r3, r2, #8192	; 0x2000
    580c:	str	r3, [r4, #24]
  // type depends on address of end sector
  // max CHS has lba = 16450560 = 1024*255*63
  if ((m_relativeSectors + m_totalSectors) <= 16450560) {
    580e:	ldr	r3, [pc, #292]	; (5934 <FatFormatter::makeFat32()+0x198>)
    5810:	cmp	r2, r3
    // FAT32 with CHS and LBA
    m_partType = 0X0B;
    5812:	ite	ls
    5814:	movls	r3, #11
  } else {
    // FAT32 with only LBA
    m_partType = 0X0C;
    5816:	movhi	r3, #12
    5818:	strb.w	r3, [r4, #42]	; 0x2a
  }
  if (!writeMbr()) {
    581c:	mov	r0, r4
    581e:	bl	563c <FatFormatter::writeMbr()>
    5822:	cmp	r0, #0
    5824:	beq.w	592a <FatFormatter::makeFat32()+0x18e>
    return false;
  }
  initPbs();
    5828:	mov	r0, r4
    582a:	bl	55e0 <FatFormatter::initPbs()>
  setLe32(pbs->bpb.bpb32.sectorsPerFat32, m_fatSize);
    582e:	ldr	r3, [r4, #8]
    5830:	str	r3, [r5, #36]	; 0x24
    5832:	movs	r3, #2
    5834:	str	r3, [r5, #44]	; 0x2c
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    5836:	movs	r3, #1
    5838:	strh	r3, [r5, #48]	; 0x30
    583a:	movs	r3, #6
    583c:	strh	r3, [r5, #50]	; 0x32
  setLe32(pbs->bpb.bpb32.fat32RootCluster, 2);
  setLe16(pbs->bpb.bpb32.fat32FSInfoSector, 1);
  setLe16(pbs->bpb.bpb32.fat32BackBootSector, 6);
  pbs->bpb.bpb32.physicalDriveNumber = 0X80;
    583e:	movs	r3, #128	; 0x80
    5840:	strb.w	r3, [r5, #64]	; 0x40
  pbs->bpb.bpb32.extSignature = EXTENDED_BOOT_SIGNATURE;
    5844:	movs	r3, #41	; 0x29
    5846:	strb.w	r3, [r5, #66]	; 0x42
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    584a:	ldr	r3, [pc, #236]	; (5938 <FatFormatter::makeFat32()+0x19c>)
    584c:	str.w	r3, [r5, #67]	; 0x43
    5850:	add.w	r2, r5, #81	; 0x51
    5854:	add.w	r3, r5, #70	; 0x46
  setLe32(pbs->bpb.bpb32.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb32.volumeLabel); i++) {
    pbs->bpb.bpb32.volumeLabel[i] = ' ';
    5858:	movs	r1, #32
    585a:	strb.w	r1, [r3, #1]!
  setLe16(pbs->bpb.bpb32.fat32FSInfoSector, 1);
  setLe16(pbs->bpb.bpb32.fat32BackBootSector, 6);
  pbs->bpb.bpb32.physicalDriveNumber = 0X80;
  pbs->bpb.bpb32.extSignature = EXTENDED_BOOT_SIGNATURE;
  setLe32(pbs->bpb.bpb32.volumeSerialNumber, 1234567);
  for (size_t i = 0; i < sizeof(pbs->bpb.bpb32.volumeLabel); i++) {
    585e:	cmp	r3, r2
    5860:	bne.n	585a <FatFormatter::makeFat32()+0xbe>
    pbs->bpb.bpb32.volumeLabel[i] = ' ';
  }
  pbs->bpb.bpb32.volumeType[0] = 'F';
    5862:	movs	r3, #70	; 0x46
    5864:	strb.w	r3, [r5, #82]	; 0x52
  pbs->bpb.bpb32.volumeType[1] = 'A';
    5868:	movs	r3, #65	; 0x41
    586a:	strb.w	r3, [r5, #83]	; 0x53
  pbs->bpb.bpb32.volumeType[2] = 'T';
    586e:	movs	r3, #84	; 0x54
    5870:	strb.w	r3, [r5, #84]	; 0x54
  pbs->bpb.bpb32.volumeType[3] = '3';
    5874:	movs	r3, #51	; 0x33
    5876:	strb.w	r3, [r5, #85]	; 0x55
  pbs->bpb.bpb32.volumeType[4] = '2';
    587a:	movs	r3, #50	; 0x32
    587c:	strb.w	r3, [r5, #86]	; 0x56
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)  ||
    5880:	ldr	r0, [r4, #28]
    5882:	ldr	r2, [r4, #36]	; 0x24
    5884:	ldr	r3, [r0, #0]
    5886:	ldr	r1, [r4, #16]
    5888:	ldr	r3, [r3, #32]
    588a:	blx	r3
    588c:	cmp	r0, #0
    588e:	beq.n	592a <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 6, m_secBuf)) {
    5890:	ldr	r0, [r4, #28]
    5892:	ldr	r1, [r4, #16]
    5894:	ldr	r3, [r0, #0]
    5896:	ldr	r2, [r4, #36]	; 0x24
    5898:	ldr	r3, [r3, #32]
    589a:	adds	r1, #6
    589c:	blx	r3
  pbs->bpb.bpb32.volumeType[0] = 'F';
  pbs->bpb.bpb32.volumeType[1] = 'A';
  pbs->bpb.bpb32.volumeType[2] = 'T';
  pbs->bpb.bpb32.volumeType[3] = '3';
  pbs->bpb.bpb32.volumeType[4] = '2';
  if (!m_dev->writeSector(m_relativeSectors, m_secBuf)  ||
    589e:	cmp	r0, #0
    58a0:	beq.n	592a <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 6, m_secBuf)) {
    return false;
  }
  // write extra boot area and backup
  memset(m_secBuf, 0 , BYTES_PER_SECTOR);
    58a2:	mov.w	r2, #512	; 0x200
    58a6:	movs	r1, #0
    58a8:	ldr	r0, [r4, #36]	; 0x24
    58aa:	bl	8fc0 <memset>
    58ae:	ldr	r3, [pc, #140]	; (593c <FatFormatter::makeFat32()+0x1a0>)
  setLe32(fsi->trailSignature, FSINFO_TRAIL_SIGNATURE);
  if (!m_dev->writeSector(m_relativeSectors + 2, m_secBuf)  ||
    58b0:	ldr	r0, [r4, #28]
    58b2:	str.w	r3, [r5, #508]	; 0x1fc
    58b6:	ldr	r1, [r4, #16]
    58b8:	ldr	r3, [r0, #0]
    58ba:	ldr	r2, [r4, #36]	; 0x24
    58bc:	ldr	r3, [r3, #32]
    58be:	adds	r1, #2
    58c0:	blx	r3
    58c2:	cmp	r0, #0
    58c4:	beq.n	592a <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 8, m_secBuf)) {
    58c6:	ldr	r0, [r4, #28]
    58c8:	ldr	r1, [r4, #16]
    58ca:	ldr	r3, [r0, #0]
    58cc:	ldr	r2, [r4, #36]	; 0x24
    58ce:	ldr	r3, [r3, #32]
    58d0:	adds	r1, #8
    58d2:	blx	r3
    return false;
  }
  // write extra boot area and backup
  memset(m_secBuf, 0 , BYTES_PER_SECTOR);
  setLe32(fsi->trailSignature, FSINFO_TRAIL_SIGNATURE);
  if (!m_dev->writeSector(m_relativeSectors + 2, m_secBuf)  ||
    58d4:	cbz	r0, 592a <FatFormatter::makeFat32()+0x18e>
    58d6:	ldr	r3, [pc, #104]	; (5940 <FatFormatter::makeFat32()+0x1a4>)
    58d8:	str	r3, [r5, #0]
    58da:	add.w	r3, r3, #534773760	; 0x1fe00000
    58de:	add.w	r3, r3, #8192	; 0x2000
    58e2:	adds	r3, #32
    58e4:	str.w	r3, [r5, #484]	; 0x1e4
  // write FSINFO sector and backup
  setLe32(fsi->leadSignature, FSINFO_LEAD_SIGNATURE);
  setLe32(fsi->structSignature, FSINFO_STRUCT_SIGNATURE);
  setLe32(fsi->freeCount, 0XFFFFFFFF);
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
    58e8:	ldr	r0, [r4, #28]
    58ea:	ldr	r2, [r4, #36]	; 0x24
    58ec:	mov.w	r3, #4294967295
    58f0:	str.w	r3, [r5, #488]	; 0x1e8
    58f4:	str.w	r3, [r5, #492]	; 0x1ec
    58f8:	ldr	r1, [r4, #16]
    58fa:	ldr	r3, [r0, #0]
    58fc:	adds	r1, #1
    58fe:	ldr	r3, [r3, #32]
    5900:	blx	r3
    5902:	cbz	r0, 592a <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    5904:	ldr	r0, [r4, #28]
    5906:	ldr	r1, [r4, #16]
    5908:	ldr	r3, [r0, #0]
    590a:	ldr	r2, [r4, #36]	; 0x24
    590c:	ldr	r3, [r3, #32]
    590e:	adds	r1, #7
    5910:	blx	r3
  // write FSINFO sector and backup
  setLe32(fsi->leadSignature, FSINFO_LEAD_SIGNATURE);
  setLe32(fsi->structSignature, FSINFO_STRUCT_SIGNATURE);
  setLe32(fsi->freeCount, 0XFFFFFFFF);
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
    5912:	cbz	r0, 592a <FatFormatter::makeFat32()+0x18e>
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
    5914:	ldr	r2, [r4, #8]
    5916:	ldrb.w	r3, [r4, #43]	; 0x2b
    591a:	mov	r0, r4
    591c:	add.w	r2, r3, r2, lsl #1
    5920:	movs	r1, #32
}
    5922:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  setLe32(fsi->nextFree, 0XFFFFFFFF);
  if (!m_dev->writeSector(m_relativeSectors + 1, m_secBuf)  ||
      !m_dev->writeSector(m_relativeSectors + 7, m_secBuf)) {
    return false;
  }
  return initFatDir(32, 2*m_fatSize + m_sectorsPerCluster);
    5926:	b.w	5538 <FatFormatter::initFatDir(unsigned char, unsigned long)>
}
    592a:	movs	r0, #0
    592c:	pop	{r3, r4, r5, r6, r7, pc}
    592e:	nop
    5930:	.word	0x00012c79
    5934:	.word	0x00fb0400
    5938:	.word	0x0012d687
    593c:	.word	0xaa550000
    5940:	.word	0x41615252

00005944 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)>:
#define writeMsg(str) if (m_pr) m_pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    5944:	push	{r3, r4, r5, lr}
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
    5946:	str	r3, [r0, #32]
  m_sectorCount = m_dev->sectorCount();
    5948:	ldr	r3, [r1, #0]
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
  bool rtn;
  m_dev = dev;
    594a:	str	r1, [r0, #28]
  m_secBuf = secBuf;
    594c:	str	r2, [r0, #36]	; 0x24
#define writeMsg(str) if (m_pr) m_pr->print(F(str))
#else  // PRINT_FORMAT_PROGRESS
#define writeMsg(str) if (m_pr) m_pr->write(str)
#endif  // PRINT_FORMAT_PROGRESS
//------------------------------------------------------------------------------
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
    594e:	mov	r4, r0
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
  m_sectorCount = m_dev->sectorCount();
    5950:	ldr	r3, [r3, #24]
    5952:	mov	r0, r1
    5954:	blx	r3
  m_capacityMB = (m_sectorCount + SECTORS_PER_MB - 1)/SECTORS_PER_MB;
    5956:	addw	r3, r0, #2047	; 0x7ff
    595a:	lsrs	r3, r3, #11

  if (m_capacityMB <= 6) {
    595c:	cmp	r3, #6
bool FatFormatter::format(BlockDevice* dev, uint8_t* secBuf, print_t* pr) {
  bool rtn;
  m_dev = dev;
  m_secBuf = secBuf;
  m_pr = pr;
  m_sectorCount = m_dev->sectorCount();
    595e:	str	r0, [r4, #20]
  m_capacityMB = (m_sectorCount + SECTORS_PER_MB - 1)/SECTORS_PER_MB;
    5960:	str	r3, [r4, #0]

  if (m_capacityMB <= 6) {
    5962:	bhi.n	5972 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2e>
    writeMsg("Card is too small.\r\n");
    5964:	ldr	r0, [r4, #32]
    5966:	cbz	r0, 596e <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2a>
    5968:	ldr	r1, [pc, #108]	; (59d8 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x94>)
    596a:	bl	6a8 <Print::write(char const*)>
    return false;
    596e:	movs	r0, #0
    5970:	pop	{r3, r4, r5, pc}
  } else if (m_capacityMB <= 16) {
    5972:	cmp	r3, #16
    5974:	bhi.n	597a <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x36>
    m_sectorsPerCluster = 2;
    5976:	movs	r3, #2
    5978:	b.n	59a6 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 32) {
    597a:	cmp	r3, #32
    597c:	bhi.n	5982 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x3e>
    m_sectorsPerCluster = 4;
    597e:	movs	r3, #4
    5980:	b.n	59a6 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 64) {
    5982:	cmp	r3, #64	; 0x40
    5984:	bhi.n	598a <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x46>
    m_sectorsPerCluster = 8;
    5986:	movs	r3, #8
    5988:	b.n	59a6 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 128) {
    598a:	cmp	r3, #128	; 0x80
    598c:	bhi.n	5992 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x4e>
    m_sectorsPerCluster = 16;
    598e:	movs	r3, #16
    5990:	b.n	59a6 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 1024) {
    5992:	cmp.w	r3, #1024	; 0x400
    5996:	bhi.n	599c <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x58>
    m_sectorsPerCluster = 32;
    5998:	movs	r3, #32
    599a:	b.n	59a6 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x62>
  } else if (m_capacityMB <= 32768) {
    599c:	cmp.w	r3, #32768	; 0x8000
    m_sectorsPerCluster = 64;
    59a0:	ite	ls
    59a2:	movls	r3, #64	; 0x40
  } else {
    // SDXC cards
    m_sectorsPerCluster = 128;
    59a4:	movhi	r3, #128	; 0x80
  }
  rtn = m_sectorCount < 0X400000 ? makeFat16() : makeFat32();
    59a6:	cmp.w	r0, #4194304	; 0x400000
    m_sectorsPerCluster = 32;
  } else if (m_capacityMB <= 32768) {
    m_sectorsPerCluster = 64;
  } else {
    // SDXC cards
    m_sectorsPerCluster = 128;
    59aa:	strb.w	r3, [r4, #43]	; 0x2b
  }
  rtn = m_sectorCount < 0X400000 ? makeFat16() : makeFat32();
    59ae:	mov	r0, r4
    59b0:	bcs.n	59b8 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x74>
    59b2:	bl	5698 <FatFormatter::makeFat16()>
    59b6:	b.n	59bc <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x78>
    59b8:	bl	579c <FatFormatter::makeFat32()>
    59bc:	mov	r5, r0
    59be:	ldr	r0, [r4, #32]
  if (rtn) {
    59c0:	cbz	r5, 59cc <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x88>
    writeMsg("Format Done\r\n");
    59c2:	cbz	r0, 59d4 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x90>
    59c4:	ldr	r1, [pc, #20]	; (59dc <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x98>)
    59c6:	bl	6a8 <Print::write(char const*)>
    59ca:	b.n	59d4 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x90>
  } else {
    writeMsg("Format Failed\r\n");
    59cc:	cmp	r0, #0
    59ce:	beq.n	596e <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x2a>
    59d0:	ldr	r1, [pc, #12]	; (59e0 <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x9c>)
    59d2:	b.n	596a <FatFormatter::format(BlockDeviceInterface*, unsigned char*, Print*)+0x26>
    59d4:	movs	r0, #1
  }
  return rtn;
}
    59d6:	pop	{r3, r4, r5, pc}
    59d8:	.word	0x00012c8d
    59dc:	.word	0x00012ca2
    59e0:	.word	0x00012cb0

000059e4 <FatFile::cacheDir(unsigned short)>:

  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    59e4:	push	{r4, lr}
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    59e6:	lsls	r1, r1, #5

  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    59e8:	mov	r4, r0
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    59ea:	bl	5ee2 <FatFile::seekSet(unsigned long)>
    59ee:	cbz	r0, 59fc <FatFile::cacheDir(unsigned short)+0x18>
    59f0:	mov	r0, r4
    59f2:	movs	r1, #0
  }
    59f4:	ldmia.w	sp!, {r4, lr}
  // private functions

  bool addCluster();
  bool addDirCluster();
  DirFat_t* cacheDir(uint16_t index) {
    return seekSet(32UL*index) ? readDirCache() : nullptr;
    59f8:	b.w	5ea8 <FatFile::readDirCache(bool)>
  }
    59fc:	pop	{r4, pc}

000059fe <FatFile::getLfnChar(DirLfn_t*, unsigned char)>:
#include "FatFile.h"
#include "FatVolume.h"

//------------------------------------------------------------------------------
uint16_t FatFile::getLfnChar(DirLfn_t* ldir, uint8_t i) {
  if (i < 5) {
    59fe:	cmp	r2, #4
    5a00:	bhi.n	5a0c <FatFile::getLfnChar(DirLfn_t*, unsigned char)+0xe>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    5a02:	add.w	r1, r1, r2, lsl #1
    5a06:	ldrh.w	r0, [r1, #1]
    return getLe16(ldir->unicode1 + 2*i);
    5a0a:	bx	lr
  } else if (i < 11) {
    5a0c:	cmp	r2, #10
    5a0e:	bhi.n	5a18 <FatFile::getLfnChar(DirLfn_t*, unsigned char)+0x1a>
    5a10:	add.w	r1, r1, r2, lsl #1
    5a14:	ldrh	r0, [r1, #4]
    return getLe16(ldir->unicode2 + 2*i - 10);
    5a16:	bx	lr
  } else if (i < 13) {
    5a18:	cmp	r2, #12
    5a1a:	itte	ls
    5a1c:	addls.w	r1, r1, r2, lsl #1
    5a20:	ldrhls	r0, [r1, #6]
    return getLe16(ldir->unicode3 + 2*i - 22);
  }
  DBG_HALT_IF(i >= 13);
  return 0;
    5a22:	movhi	r0, #0
}
    5a24:	bx	lr

00005a26 <FatFile::getSFN(char*, unsigned int)>:
 fail:
  *name = 0;
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
    5a26:	push	{r3, r4, r5, r6, r7, lr}
    5a28:	mov	r6, r1
    5a2a:	ldrb	r1, [r0, #0]
    5a2c:	mov	r7, r2
  char c;
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
  uint8_t* ptr;
  DirFat_t* dir;
  if (!isOpen()) {
    5a2e:	cbz	r1, 5aa8 <FatFile::getSFN(char*, unsigned int)+0x82>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isRoot()) {
    5a30:	ands.w	r4, r1, #96	; 0x60
    5a34:	beq.n	5a46 <FatFile::getSFN(char*, unsigned int)+0x20>
    if (size < 2) {
    5a36:	cmp	r2, #1
    5a38:	bls.n	5aa8 <FatFile::getSFN(char*, unsigned int)+0x82>
      DBG_FAIL_MACRO;
      goto fail;
    }
    name[0] = '/';
    5a3a:	movs	r3, #47	; 0x2f
    5a3c:	strb	r3, [r6, #0]
    name[1] = '\0';
    5a3e:	movs	r3, #0
    5a40:	strb	r3, [r6, #1]
    return 1;
    5a42:	movs	r0, #1
    5a44:	pop	{r3, r4, r5, r6, r7, pc}
  }
  // cache entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    5a46:	mov	r1, r4
    5a48:	bl	5c8c <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    5a4c:	cbz	r0, 5aa8 <FatFile::getSFN(char*, unsigned int)+0x82>
    DBG_FAIL_MACRO;
    goto fail;
  }
  ptr = dir->name;
    5a4e:	mov	r5, r0
    5a50:	mov	r1, r4
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
  char c;
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
    5a52:	movs	r2, #8
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getSFN(char* name, size_t size) {
  char c;
  uint8_t j = 0;
    5a54:	mov	r3, r4
    goto fail;
  }
  ptr = dir->name;
  // format name
  for (uint8_t i = 0; i < 12; i++) {
    if (i == 8) {
    5a56:	cmp	r1, #8
    5a58:	ldrb	r4, [r5, #0]
    5a5a:	bne.n	5a66 <FatFile::getSFN(char*, unsigned int)+0x40>
      if (*ptr == ' ') {
    5a5c:	cmp	r4, #32
    5a5e:	beq.n	5aa0 <FatFile::getSFN(char*, unsigned int)+0x7a>
        break;
      }
      lcBit = FAT_CASE_LC_EXT;
    5a60:	movs	r2, #16
      c = '.';
    5a62:	movs	r4, #46	; 0x2e
    5a64:	b.n	5a88 <FatFile::getSFN(char*, unsigned int)+0x62>
    } else {
      c = *ptr++;
      if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
    5a66:	sub.w	lr, r4, #65	; 0x41
    5a6a:	cmp.w	lr, #25
        break;
      }
      lcBit = FAT_CASE_LC_EXT;
      c = '.';
    } else {
      c = *ptr++;
    5a6e:	add.w	r5, r5, #1
      if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
    5a72:	bhi.n	5a84 <FatFile::getSFN(char*, unsigned int)+0x5e>
    5a74:	ldrb.w	lr, [r0, #12]
    5a78:	tst.w	r2, lr
    5a7c:	beq.n	5a88 <FatFile::getSFN(char*, unsigned int)+0x62>
        c += 'a' - 'A';
    5a7e:	adds	r4, #32
    5a80:	uxtb	r4, r4
    5a82:	b.n	5a88 <FatFile::getSFN(char*, unsigned int)+0x62>
      }
      if (c == ' ') {
    5a84:	cmp	r4, #32
    5a86:	beq.n	5a9a <FatFile::getSFN(char*, unsigned int)+0x74>
        continue;
      }
    }
    if ((j + 1u) == size) {
    5a88:	add.w	lr, r3, #1
    5a8c:	cmp	r7, lr
    5a8e:	mov	ip, r3
    5a90:	beq.n	5aa0 <FatFile::getSFN(char*, unsigned int)+0x7a>
      break;
    }
    name[j++] = c;
    5a92:	strb.w	r4, [r6, ip]
    5a96:	uxtb.w	r3, lr
    5a9a:	adds	r1, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  ptr = dir->name;
  // format name
  for (uint8_t i = 0; i < 12; i++) {
    5a9c:	cmp	r1, #12
    5a9e:	bne.n	5a56 <FatFile::getSFN(char*, unsigned int)+0x30>
    if ((j + 1u) == size) {
      break;
    }
    name[j++] = c;
  }
  name[j] = '\0';
    5aa0:	movs	r2, #0
    5aa2:	strb	r2, [r6, r3]
  return j;
    5aa4:	mov	r0, r3
    5aa6:	pop	{r3, r4, r5, r6, r7, pc}

 fail:
  name[0] = '\0';
    5aa8:	movs	r0, #0
    5aaa:	strb	r0, [r6, #0]
  return 0;
}
    5aac:	pop	{r3, r4, r5, r6, r7, pc}
    5aae:	Address 0x00005aae is out of bounds.


00005ab0 <FatFile::getName8(char*, unsigned int)>:
 fail:
  name[0] = '\0';
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getName8(char* name, size_t size) {
    5ab0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5ab4:	sub	sp, #44	; 0x2c
  char* ptr;
  FatFile dir;
  DirLfn_t* ldir;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    5ab6:	ldrb	r3, [r0, #0]
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    5ab8:	movs	r4, #0
 fail:
  name[0] = '\0';
  return 0;
}
//------------------------------------------------------------------------------
size_t FatFile::getName8(char* name, size_t size) {
    5aba:	mov	r7, r0
    5abc:	mov	r9, r1
    5abe:	mov	r8, r2
    5ac0:	strb.w	r4, [sp, #4]
    5ac4:	strb.w	r4, [sp, #5]
    5ac8:	strb.w	r4, [sp, #6]
  char* ptr;
  FatFile dir;
  DirLfn_t* ldir;
  uint16_t hs = 0;
  uint32_t cp;
  if (!isOpen()) {
    5acc:	cmp	r3, #0
    5ace:	beq.n	5b90 <FatFile::getName8(char*, unsigned int)+0xe0>
      DBG_FAIL_MACRO;
      goto fail;
  }
  if (!isLFN()) {
    5ad0:	ldrb	r3, [r0, #3]
    5ad2:	cbnz	r3, 5ada <FatFile::getName8(char*, unsigned int)+0x2a>
    return getSFN(name, size);
    5ad4:	bl	5a26 <FatFile::getSFN(char*, unsigned int)>
    5ad8:	b.n	5b96 <FatFile::getName8(char*, unsigned int)+0xe6>
  }
  if (!dir.openCluster(this)) {
    5ada:	mov	r1, r0
    5adc:	add	r0, sp, #4
    5ade:	bl	5cda <FatFile::openCluster(FatFile*)>
    5ae2:	cmp	r0, #0
    5ae4:	beq.n	5b90 <FatFile::getName8(char*, unsigned int)+0xe0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    5ae6:	add.w	r8, r8, #4294967295
    5aea:	mov	r5, r9
    5aec:	movs	r6, #1
    5aee:	add	r8, r9
  }
  if (!dir.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    5af0:	ldrb	r3, [r7, #3]
    5af2:	cmp	r3, r6
    5af4:	bcc.n	5b86 <FatFile::getName8(char*, unsigned int)+0xd6>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(m_dirIndex - order));
    5af6:	ldrh	r1, [r7, #4]
    5af8:	subs	r1, r1, r6
    5afa:	uxth	r1, r1
    5afc:	add	r0, sp, #4
    5afe:	bl	59e4 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    5b02:	mov	fp, r0
    5b04:	cmp	r0, #0
    5b06:	beq.n	5b90 <FatFile::getName8(char*, unsigned int)+0xe0>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    5b08:	ldrb	r3, [r0, #11]
    5b0a:	cmp	r3, #15
    5b0c:	bne.n	5b90 <FatFile::getName8(char*, unsigned int)+0xe0>
    5b0e:	ldrb	r3, [r0, #0]
    5b10:	and.w	r3, r3, #31
    5b14:	cmp	r6, r3
    5b16:	bne.n	5b90 <FatFile::getName8(char*, unsigned int)+0xe0>
    5b18:	mov	r3, r4
    5b1a:	mov.w	sl, #0
        order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t c = getLfnChar(ldir, i);
    5b1e:	uxtb.w	r2, sl
    5b22:	mov	r1, fp
    5b24:	mov	r0, r7
    5b26:	bl	59fe <FatFile::getLfnChar(DirLfn_t*, unsigned char)>
    5b2a:	mov	r4, r0
      if (hs) {
    5b2c:	cbz	r3, 5b4c <FatFile::getName8(char*, unsigned int)+0x9c>
        if (!FsUtf::isLowSurrogate(c)) {
    5b2e:	add.w	r2, r0, #9216	; 0x2400
    5b32:	uxth	r2, r2
    5b34:	cmp.w	r2, #1024	; 0x400
    5b38:	bcs.n	5b90 <FatFile::getName8(char*, unsigned int)+0xe0>
   * \param[in] hs high surrogate.
   * \param[in] ls low surrogate.
   * \return code point.
   */
  inline uint32_t u16ToCp(uint16_t hs, uint16_t ls) {
    return 0X10000 + (((hs & 0X3FF) << 10) | (ls & 0X3FF));
    5b3a:	ldr	r0, [pc, #96]	; (5b9c <FatFile::getName8(char*, unsigned int)+0xec>)
    5b3c:	lsls	r3, r3, #10
    5b3e:	ands	r0, r3
    5b40:	ubfx	r4, r4, #0, #10
    5b44:	orrs	r4, r0
    5b46:	add.w	r0, r4, #65536	; 0x10000
    5b4a:	b.n	5b64 <FatFile::getName8(char*, unsigned int)+0xb4>
  /** Check for UTF-16 surrogate.
   * \param[in] c UTF-16 unit.
   * \return true if c is a surrogate else false.
   */
  inline bool isSurrogate(uint16_t c) {
    return 0XD800 <= c && c <= 0XDFFF;
    5b4c:	add.w	r3, r0, #10240	; 0x2800
    5b50:	uxth	r3, r3
          DBG_FAIL_MACRO;
          goto fail;
        }
        cp = FsUtf::u16ToCp(hs, c);
        hs = 0;
      } else if (!FsUtf::isSurrogate(c)) {
    5b52:	cmp.w	r3, #2048	; 0x800
    5b56:	bcc.n	5b5c <FatFile::getName8(char*, unsigned int)+0xac>
        if (c == 0) {
    5b58:	cbnz	r0, 5b64 <FatFile::getName8(char*, unsigned int)+0xb4>
    5b5a:	b.n	5b86 <FatFile::getName8(char*, unsigned int)+0xd6>
          goto done;
        }
        cp = c;
      } else if (FsUtf::isHighSurrogate(c)) {
    5b5c:	cmp.w	r3, #1024	; 0x400
    5b60:	bcc.n	5b72 <FatFile::getName8(char*, unsigned int)+0xc2>
    5b62:	b.n	5b90 <FatFile::getName8(char*, unsigned int)+0xe0>
      } else {
        DBG_FAIL_MACRO;
        goto fail;
      }
      // Save space for zero byte.
      ptr = FsUtf::cpToMb(cp, str, end - 1);
    5b64:	mov	r2, r8
    5b66:	mov	r1, r5
    5b68:	bl	33c8 <FsUtf::cpToMb(unsigned long, char*, char*)>
      if (!ptr) {
    5b6c:	cbz	r0, 5b86 <FatFile::getName8(char*, unsigned int)+0xd6>
    5b6e:	mov	r5, r0
    5b70:	movs	r4, #0
    5b72:	add.w	sl, sl, #1
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
        order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t i = 0; i < 13; i++) {
    5b76:	cmp.w	sl, #13
    5b7a:	beq.n	5b80 <FatFile::getName8(char*, unsigned int)+0xd0>
    5b7c:	mov	r3, r4
    5b7e:	b.n	5b1e <FatFile::getName8(char*, unsigned int)+0x6e>
  }
  if (!dir.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    5b80:	adds	r6, #1
    5b82:	uxtb	r6, r6
    5b84:	b.n	5af0 <FatFile::getName8(char*, unsigned int)+0x40>
      }
      str = ptr;
    }
  }
 done:
  *str = '\0';
    5b86:	movs	r3, #0
    5b88:	strb	r3, [r5, #0]
  return str - name;
    5b8a:	rsb	r0, r9, r5
    5b8e:	b.n	5b96 <FatFile::getName8(char*, unsigned int)+0xe6>

 fail:
  *name = 0;
    5b90:	movs	r0, #0
    5b92:	strb.w	r0, [r9]
  return 0;
}
    5b96:	add	sp, #44	; 0x2c
    5b98:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5b9c:	.word	0x000ffc00

00005ba0 <FatFile::getName(char*, unsigned int)>:
//------------------------------------------------------------------------------
size_t FatFile::getName(char* name, size_t size) {
#if !USE_LONG_FILE_NAMES
  return getSFN(name, size);
#elif USE_UTF8_LONG_NAMES
  return getName8(name, size);
    5ba0:	b.w	5ab0 <FatFile::getName8(char*, unsigned int)>

00005ba4 <FatPartition::cacheSync()>:
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    5ba4:	push	{r4, lr}
    5ba6:	mov	r4, r0
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    5ba8:	adds	r0, #40	; 0x28
    5baa:	bl	371e <FsCache::sync()>
    5bae:	cbz	r0, 5bc6 <FatPartition::cacheSync()+0x22>
    5bb0:	add.w	r0, r4, #568	; 0x238
    5bb4:	bl	371e <FsCache::sync()>
    5bb8:	cbz	r0, 5bc6 <FatPartition::cacheSync()+0x22>
    5bba:	ldr	r0, [r4, #0]
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    5bbc:	ldr	r3, [r0, #0]
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
  }
    5bbe:	ldmia.w	sp!, {r4, lr}
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    5bc2:	ldr	r3, [r3, #28]
    5bc4:	bx	r3
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
  }
    5bc6:	movs	r0, #0
    5bc8:	pop	{r4, pc}

00005bca <FatFile::addCluster()>:
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    5bca:	mov	r2, r0
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    5bcc:	push	{r3, r4, r5, lr}
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    5bce:	ldr.w	r5, [r2, #16]!
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    5bd2:	mov	r4, r0
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
  if (!m_vol->allocateCluster(m_curCluster, &m_curCluster)) {
    5bd4:	mov	r1, r5
    5bd6:	ldr	r0, [r0, #8]
    5bd8:	bl	6a42 <FatPartition::allocateCluster(unsigned long, unsigned long*)>
    5bdc:	cbz	r0, 5bfe <FatFile::addCluster()+0x34>
    5bde:	ldrb	r3, [r4, #2]
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (cc == 0) {
    5be0:	cbnz	r5, 5be8 <FatFile::addCluster()+0x1e>
    m_flags |= FILE_FLAG_CONTIGUOUS;
    5be2:	orr.w	r3, r3, #64	; 0x40
    5be6:	b.n	5bf4 <FatFile::addCluster()+0x2a>
  } else if (m_curCluster != (cc + 1)) {
    5be8:	ldr	r2, [r4, #16]
    5bea:	adds	r5, #1
    5bec:	cmp	r2, r5
    5bee:	beq.n	5bf6 <FatFile::addCluster()+0x2c>
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    5bf0:	bic.w	r3, r3, #64	; 0x40
    5bf4:	strb	r3, [r4, #2]
  }
  m_flags |= FILE_FLAG_DIR_DIRTY;
    5bf6:	ldrb	r3, [r4, #2]
    5bf8:	orn	r3, r3, #127	; 0x7f
    5bfc:	strb	r3, [r4, #2]
  return false;
#else  // USE_FAT_FILE_FLAG_CONTIGUOUS
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
    5bfe:	pop	{r3, r4, r5, pc}

00005c00 <FatFile::addDirCluster()>:
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first sector of cluster in the cache.
bool FatFile::addDirCluster() {
    5c00:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    5c04:	ldrb	r3, [r0, #0]
    5c06:	and.w	r3, r3, #32
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first sector of cluster in the cache.
bool FatFile::addDirCluster() {
    5c0a:	mov	r4, r0
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    5c0c:	and.w	r5, r3, #255	; 0xff
    5c10:	cbz	r3, 5c16 <FatFile::addDirCluster()+0x16>
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
  return true;

 fail:
  return false;
    5c12:	movs	r6, #0
    5c14:	b.n	5c80 <FatFile::addDirCluster()+0x80>
  if (isRootFixed()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // max folder size
  if (m_curPosition >= 512UL*4095) {
    5c16:	ldr	r2, [r0, #20]
    5c18:	ldr	r3, [pc, #108]	; (5c88 <FatFile::addDirCluster()+0x88>)
    5c1a:	cmp	r2, r3
    5c1c:	bhi.n	5c12 <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    5c1e:	bl	5bca <FatFile::addCluster()>
    5c22:	mov	r6, r0
    5c24:	cmp	r0, #0
    5c26:	beq.n	5c12 <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_vol->clusterStartSector(m_curCluster);
    5c28:	ldr	r0, [r4, #8]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    5c2a:	ldr	r1, [r4, #16]
    5c2c:	ldrb	r3, [r0, #6]
    5c2e:	ldr	r7, [r0, #20]
    5c30:	subs	r1, #2
    5c32:	lsls	r1, r3
    5c34:	add	r7, r1
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    5c36:	movs	r2, #5
    5c38:	mov	r1, r7
    5c3a:	adds	r0, #40	; 0x28
    5c3c:	bl	376a <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_RESERVE_FOR_WRITE);
  if (!pc) {
    5c40:	mov	r8, r0
    5c42:	cmp	r0, #0
    5c44:	beq.n	5c12 <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
    5c46:	mov	r1, r5
    5c48:	mov.w	r2, #512	; 0x200
    5c4c:	bl	8fc0 <memset>
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    5c50:	movs	r5, #1
    5c52:	ldr	r3, [r4, #8]
    5c54:	ldrb	r2, [r3, #4]
    5c56:	cmp	r2, r5
    5c58:	bls.n	5c70 <FatFile::addDirCluster()+0x70>
    5c5a:	ldr	r0, [r3, #0]
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    5c5c:	ldr	r3, [r0, #0]
    5c5e:	mov	r2, r8
    5c60:	ldr	r3, [r3, #32]
    5c62:	adds	r1, r5, r7
    5c64:	blx	r3
    if (!m_vol->writeSector(sector + i, pc->data)) {
    5c66:	cmp	r0, #0
    5c68:	beq.n	5c12 <FatFile::addDirCluster()+0x12>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    5c6a:	adds	r5, #1
    5c6c:	uxtb	r5, r5
    5c6e:	b.n	5c52 <FatFile::addDirCluster()+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
    5c70:	ldrb	r2, [r3, #6]
    5c72:	mov.w	r3, #512	; 0x200
    5c76:	lsls	r3, r2
    5c78:	ldr	r2, [r4, #20]
    5c7a:	uxtah	r3, r2, r3
    5c7e:	str	r3, [r4, #20]
  return true;

 fail:
  return false;
}
    5c80:	mov	r0, r6
    5c82:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5c86:	nop
    5c88:	.word	0x001ffdff

00005c8c <FatFile::cacheDirEntry(unsigned char)>:
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
DirFat_t* FatFile::cacheDirEntry(uint8_t action) {
    5c8c:	push	{r4, lr}
    5c8e:	mov	r4, r0
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    5c90:	ldr	r0, [r0, #8]
    5c92:	mov	r2, r1
    5c94:	adds	r0, #40	; 0x28
    5c96:	ldr	r1, [r4, #24]
    5c98:	bl	376a <FsCache::get(unsigned long, unsigned char)>
  cache_t* pc;
  pc = m_vol->cacheFetchData(m_dirSector, action);
  if (!pc) {
    5c9c:	cbz	r0, 5ca8 <FatFile::cacheDirEntry(unsigned char)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return pc->dir + (m_dirIndex & 0XF);
    5c9e:	ldrh	r3, [r4, #4]
    5ca0:	and.w	r3, r3, #15
    5ca4:	add.w	r0, r0, r3, lsl #5

 fail:
  return nullptr;
}
    5ca8:	pop	{r4, pc}

00005caa <FatFile::openRoot(FatVolume*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    5caa:	push	{r4, r5, r6, lr}
  // error if file is already open
  if (isOpen()) {
    5cac:	ldrb	r4, [r0, #0]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    5cae:	mov	r5, r0
    5cb0:	mov	r6, r1
  // error if file is already open
  if (isOpen()) {
    5cb2:	cbnz	r4, 5cd6 <FatFile::openRoot(FatVolume*)+0x2c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(FatFile));
    5cb4:	movs	r2, #36	; 0x24
    5cb6:	mov	r1, r4
    5cb8:	bl	8fc0 <memset>

  m_vol = vol;
    5cbc:	str	r6, [r5, #8]
  switch (vol->fatType()) {
    5cbe:	ldrb	r3, [r6, #7]
    5cc0:	cmp	r3, #16
    5cc2:	beq.n	5ccc <FatFile::openRoot(FatVolume*)+0x22>
    5cc4:	cmp	r3, #32
    5cc6:	bne.n	5cd6 <FatFile::openRoot(FatVolume*)+0x2c>
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    5cc8:	movs	r3, #64	; 0x40
    5cca:	b.n	5cce <FatFile::openRoot(FatVolume*)+0x24>
  switch (vol->fatType()) {
#if FAT12_SUPPORT
  case 12:
#endif  // FAT12_SUPPORT
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    5ccc:	movs	r3, #32
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    5cce:	movs	r0, #1
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    5cd0:	strb	r3, [r5, #0]
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    5cd2:	strb	r0, [r5, #2]
    5cd4:	pop	{r4, r5, r6, pc}
  return true;

 fail:
  return false;
    5cd6:	movs	r0, #0
    5cd8:	pop	{r4, r5, r6, pc}

00005cda <FatFile::openCluster(FatFile*)>:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    5cda:	push	{r3, r4, r5, lr}
  if (file->m_dirCluster == 0) {
    5cdc:	ldr	r3, [r1, #12]
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    5cde:	mov	r4, r0
    5ce0:	mov	r5, r1
  if (file->m_dirCluster == 0) {
    5ce2:	cbnz	r3, 5cee <FatFile::openCluster(FatFile*)+0x14>
    return openRoot(file->m_vol);
    5ce4:	ldr	r1, [r1, #8]
  m_attributes = FILE_ATTR_SUBDIR;
  m_flags = FILE_FLAG_READ;
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
    5ce6:	ldmia.w	sp!, {r3, r4, r5, lr}
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
    5cea:	b.w	5caa <FatFile::openRoot(FatVolume*)>
  }
  memset(this, 0, sizeof(FatFile));
    5cee:	movs	r2, #36	; 0x24
    5cf0:	movs	r1, #0
    5cf2:	bl	8fc0 <memset>
  m_attributes = FILE_ATTR_SUBDIR;
    5cf6:	movs	r3, #16
  m_flags = FILE_FLAG_READ;
    5cf8:	movs	r0, #1
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
  m_attributes = FILE_ATTR_SUBDIR;
    5cfa:	strb	r3, [r4, #0]
  m_flags = FILE_FLAG_READ;
    5cfc:	strb	r0, [r4, #2]
  m_vol = file->m_vol;
    5cfe:	ldr	r3, [r5, #8]
    5d00:	str	r3, [r4, #8]
  m_firstCluster = file->m_dirCluster;
    5d02:	ldr	r3, [r5, #12]
    5d04:	str	r3, [r4, #32]
  return true;
}
    5d06:	pop	{r3, r4, r5, pc}

00005d08 <FatFile::read(void*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    5d08:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    5d0c:	ldrb	r3, [r0, #2]
    5d0e:	lsls	r5, r3, #31

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    5d10:	mov	r4, r0
    5d12:	mov	r9, r1
    5d14:	mov	r6, r2
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    5d16:	bpl.n	5e08 <FatFile::read(void*, unsigned int)+0x100>
    5d18:	ldrb	r3, [r0, #0]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
    5d1a:	lsls	r0, r3, #28
    5d1c:	bpl.n	5d26 <FatFile::read(void*, unsigned int)+0x1e>
    uint32_t tmp32 = m_fileSize - m_curPosition;
    5d1e:	ldr	r3, [r4, #28]
    5d20:	ldr	r2, [r4, #20]
    5d22:	subs	r3, r3, r2
    5d24:	b.n	5d36 <FatFile::read(void*, unsigned int)+0x2e>
    if (nbyte >= tmp32) {
      nbyte = tmp32;
    }
  } else if (isRootFixed()) {
    5d26:	lsls	r1, r3, #26
    5d28:	bpl.n	5d3c <FatFile::read(void*, unsigned int)+0x34>
    uint16_t tmp16 = 32*m_vol->m_rootDirEntryCount - (uint16_t)m_curPosition;
    5d2a:	ldr	r3, [r4, #8]
    if (nbyte > tmp16) {
    5d2c:	ldrh	r2, [r3, #8]
    5d2e:	ldr	r3, [r4, #20]
    5d30:	rsb	r3, r3, r2, lsl #5
    5d34:	uxth	r3, r3
    5d36:	cmp	r6, r3
    5d38:	it	cs
    5d3a:	movcs	r6, r3
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
    5d3c:	mov	r7, r6
  return false;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
  int8_t fg;
  uint8_t sectorOfCluster = 0;
    5d3e:	mov.w	r8, #0
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    5d42:	add.w	sl, r4, #16
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    5d46:	cmp	r7, #0
    5d48:	beq.n	5dce <FatFile::read(void*, unsigned int)+0xc6>
    5d4a:	ldrb	r3, [r4, #0]
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    5d4c:	ldr	r2, [r4, #20]
    5d4e:	ldr	r0, [r4, #8]
    if (isRootFixed()) {
    5d50:	tst.w	r3, #32
    }
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    5d54:	ubfx	r5, r2, #0, #9
    5d58:	mov.w	r1, r2, lsr #9
    if (isRootFixed()) {
    5d5c:	beq.n	5d64 <FatFile::read(void*, unsigned int)+0x5c>
      sector = m_vol->rootDirStart()
               + (m_curPosition >> m_vol->bytesPerSectorShift());
    5d5e:	ldr	r3, [r0, #32]
    5d60:	add	r1, r3
    5d62:	b.n	5dae <FatFile::read(void*, unsigned int)+0xa6>
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    5d64:	ldrb.w	r8, [r0, #5]
    5d68:	and.w	r8, r1, r8
    } else {
      sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
      if (offset == 0 && sectorOfCluster == 0) {
    5d6c:	cbnz	r5, 5d9e <FatFile::read(void*, unsigned int)+0x96>
    5d6e:	cmp.w	r8, #0
    5d72:	bne.n	5d9e <FatFile::read(void*, unsigned int)+0x96>
        // start of new cluster
        if (m_curPosition == 0) {
    5d74:	cbnz	r2, 5d80 <FatFile::read(void*, unsigned int)+0x78>
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    5d76:	lsls	r2, r3, #25
    5d78:	ite	mi
    5d7a:	ldrmi	r3, [r0, #32]
    5d7c:	ldrpl	r3, [r4, #32]
    5d7e:	b.n	5e16 <FatFile::read(void*, unsigned int)+0x10e>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
    5d80:	lsls	r3, r3, #28
    5d82:	bpl.n	5d90 <FatFile::read(void*, unsigned int)+0x88>
    5d84:	ldrb	r3, [r4, #2]
    5d86:	lsls	r1, r3, #25
    5d88:	bpl.n	5d90 <FatFile::read(void*, unsigned int)+0x88>
          m_curCluster++;
    5d8a:	ldr	r3, [r4, #16]
    5d8c:	adds	r3, #1
    5d8e:	b.n	5e16 <FatFile::read(void*, unsigned int)+0x10e>
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    5d90:	mov	r2, sl
    5d92:	ldr	r1, [r4, #16]
    5d94:	bl	697c <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    5d98:	cmp	r0, #0
    5d9a:	blt.n	5e08 <FatFile::read(void*, unsigned int)+0x100>
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
    5d9c:	beq.n	5dc6 <FatFile::read(void*, unsigned int)+0xbe>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    5d9e:	ldr	r3, [r4, #8]
    5da0:	ldr	r1, [r4, #16]
    5da2:	ldrb	r2, [r3, #6]
    5da4:	ldr	r3, [r3, #20]
    5da6:	subs	r1, #2
    5da8:	lsls	r1, r2
    5daa:	add	r1, r3
    5dac:	add	r1, r8
    5dae:	ldr.w	fp, [r4, #8]
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
    5db2:	cmp	r5, #0
    5db4:	bne.n	5e56 <FatFile::read(void*, unsigned int)+0x14e>
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
    5db6:	cmp.w	r7, #512	; 0x200
    5dba:	bcc.n	5e56 <FatFile::read(void*, unsigned int)+0x14e>
    5dbc:	ldr.w	r3, [fp, #52]	; 0x34
        || sector == m_vol->cacheSectorNumber()) {
    5dc0:	cmp	r1, r3
    5dc2:	bne.n	5dd2 <FatFile::read(void*, unsigned int)+0xca>
    5dc4:	b.n	5e56 <FatFile::read(void*, unsigned int)+0x14e>
          if (fg < 0) {
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
            if (isDir()) {
    5dc6:	ldrb	r3, [r4, #0]
    5dc8:	tst.w	r3, #112	; 0x70
    5dcc:	beq.n	5e08 <FatFile::read(void*, unsigned int)+0x100>
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return nbyte - toRead;
    5dce:	subs	r0, r6, r7
    5dd0:	b.n	5e7a <FatFile::read(void*, unsigned int)+0x172>
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    5dd2:	cmp.w	r7, #1024	; 0x400
    5dd6:	bcc.n	5e34 <FatFile::read(void*, unsigned int)+0x12c>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      if (!isRootFixed()) {
    5dd8:	ldrb	r2, [r4, #0]
    5dda:	lsls	r2, r2, #26
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    5ddc:	mov.w	r5, r7, lsr #9
      if (!isRootFixed()) {
    5de0:	bmi.n	5df0 <FatFile::read(void*, unsigned int)+0xe8>
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
    5de2:	ldrb.w	r2, [fp, #4]
    5de6:	rsb	r2, r8, r2
    5dea:	cmp	r5, r2
    5dec:	it	cs
    5dee:	movcs	r5, r2
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    5df0:	cmp	r1, r3
    5df2:	bhi.n	5e1a <FatFile::read(void*, unsigned int)+0x112>
    5df4:	adds	r2, r1, r5
    5df6:	cmp	r3, r2
    5df8:	bcs.n	5e1a <FatFile::read(void*, unsigned int)+0x112>
   * \param[in] count Number of sectors to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool cacheSafeRead(uint32_t sector, uint8_t* dst, size_t count) {
    if (isCached(sector, count) && !sync()) {
    5dfa:	add.w	r0, fp, #40	; 0x28
    5dfe:	str	r1, [sp, #4]
    5e00:	bl	371e <FsCache::sync()>
    5e04:	ldr	r1, [sp, #4]
    5e06:	cbnz	r0, 5e1a <FatFile::read(void*, unsigned int)+0x112>
    toRead -= n;
  }
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
    5e08:	ldrb	r3, [r4, #1]
    5e0a:	orr.w	r3, r3, #2
    5e0e:	strb	r3, [r4, #1]
  return -1;
    5e10:	mov.w	r0, #4294967295
    5e14:	b.n	5e7a <FatFile::read(void*, unsigned int)+0x172>
        if (m_curPosition == 0) {
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
    5e16:	str	r3, [r4, #16]
    5e18:	b.n	5d9e <FatFile::read(void*, unsigned int)+0x96>
      return false;
    }
    return m_blockDev->readSectors(sector, dst, count);
    5e1a:	ldr.w	r0, [fp, #44]	; 0x2c
    5e1e:	ldr	r3, [r0, #0]
    5e20:	mov	r2, r9
    5e22:	ldr.w	fp, [r3, #16]
    5e26:	mov	r3, r5
    5e28:	blx	fp
        if (mb < ns) {
          ns = mb;
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeRead(sector, dst, ns)) {
    5e2a:	cmp	r0, #0
    5e2c:	beq.n	5e08 <FatFile::read(void*, unsigned int)+0x100>
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
        if (mb < ns) {
          ns = mb;
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
    5e2e:	mov.w	fp, r5, lsl #9
    5e32:	b.n	5e48 <FatFile::read(void*, unsigned int)+0x140>
  bool cacheSafeRead(uint32_t sector, uint8_t* dst) {
    if (isCached(sector)) {
      memcpy(dst, m_buffer, 512);
      return true;
    }
    return m_blockDev->readSector(sector, dst);
    5e34:	ldr.w	r0, [fp, #44]	; 0x2c
    5e38:	ldr	r3, [r0, #0]
    5e3a:	mov	r2, r9
    5e3c:	ldr	r3, [r3, #12]
    5e3e:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeRead(sector, dst)) {
    5e40:	cmp	r0, #0
    5e42:	beq.n	5e08 <FatFile::read(void*, unsigned int)+0x100>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    5e44:	mov.w	fp, #512	; 0x200
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    5e48:	ldr	r3, [r4, #20]
    5e4a:	add	r3, fp
      if (!m_vol->cacheSafeRead(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    5e4c:	add	r9, fp
    m_curPosition += n;
    5e4e:	str	r3, [r4, #20]
    toRead -= n;
    5e50:	rsb	r7, fp, r7
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    5e54:	b.n	5d46 <FatFile::read(void*, unsigned int)+0x3e>
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    5e56:	movs	r2, #0
    5e58:	add.w	r0, fp, #40	; 0x28
    5e5c:	bl	376a <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
      if (!pc) {
    5e60:	cmp	r0, #0
    5e62:	beq.n	5e08 <FatFile::read(void*, unsigned int)+0x100>
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
      // amount to be read from current sector
      n = m_vol->bytesPerSector() - offset;
    5e64:	rsb	fp, r5, #512	; 0x200
    5e68:	cmp	fp, r7
    5e6a:	it	cs
    5e6c:	movcs	fp, r7
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
    5e6e:	adds	r1, r0, r5
    5e70:	mov	r2, fp
    5e72:	mov	r0, r9
    5e74:	bl	8e18 <memcpy>
    5e78:	b.n	5e48 <FatFile::read(void*, unsigned int)+0x140>
  return nbyte - toRead;

 fail:
  m_error |= READ_ERROR;
  return -1;
}
    5e7a:	add	sp, #12
    5e7c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00005e80 <FatFile::peek()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::peek() {
    5e80:	push	{r0, r1, r4, r5, r6, lr}
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    5e82:	movs	r2, #1
    5e84:	add.w	r1, sp, #7
    5e88:	mov	r4, r0
  uint32_t curPosition = m_curPosition;
    5e8a:	ldr	r6, [r0, #20]
  uint32_t curCluster = m_curCluster;
    5e8c:	ldr	r5, [r0, #16]
    5e8e:	bl	5d08 <FatFile::read(void*, unsigned int)>
    5e92:	cmp	r0, #1
    5e94:	it	eq
    5e96:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
    5e9a:	str	r6, [r4, #20]
    5e9c:	it	ne
    5e9e:	movne.w	r0, #4294967295
  m_curCluster = curCluster;
    5ea2:	str	r5, [r4, #16]
  return c;
}
    5ea4:	add	sp, #8
    5ea6:	pop	{r4, r5, r6, pc}

00005ea8 <FatFile::readDirCache(bool)>:
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;
    5ea8:	ldr	r3, [r0, #20]
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    5eaa:	push	{r0, r1, r2, r4, r5, lr}
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;
    5eac:	ubfx	r5, r3, #5, #4
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache.
// Assumes file is correctly positioned.
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    5eb0:	mov	r4, r0
  DBG_HALT_IF(m_curPosition & 0X1F);
  uint8_t i = (m_curPosition >> 5) & 0XF;

  if (i == 0 || !skipReadOk) {
    5eb2:	cbz	r5, 5eb6 <FatFile::readDirCache(bool)+0xe>
    5eb4:	cbnz	r1, 5ed2 <FatFile::readDirCache(bool)+0x2a>
    int8_t n = read(&n, 1);
    5eb6:	movs	r2, #1
    5eb8:	add.w	r1, sp, #7
    5ebc:	mov	r0, r4
    5ebe:	bl	5d08 <FatFile::read(void*, unsigned int)>
    5ec2:	sxtb	r0, r0
    if  (n != 1) {
    5ec4:	cmp	r0, #1
    5ec6:	beq.n	5ecc <FatFile::readDirCache(bool)+0x24>
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;

 fail:
  return nullptr;
    5ec8:	movs	r0, #0
    5eca:	b.n	5ede <FatFile::readDirCache(bool)+0x36>
      if (n != 0) {
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    m_curPosition += 31;
    5ecc:	ldr	r3, [r4, #20]
    5ece:	adds	r3, #31
    5ed0:	b.n	5ed4 <FatFile::readDirCache(bool)+0x2c>
  } else {
    m_curPosition += 32;
    5ed2:	adds	r3, #32
  static const uint8_t CACHE_RESERVE_FOR_WRITE =
    CACHE_STATUS_DIRTY | CACHE_OPTION_NO_READ;
  //----------------------------------------------------------------------------
  /** \return Cache buffer address. */
  uint8_t* cacheBuffer() {
    return m_buffer;
    5ed4:	ldr	r0, [r4, #8]
    5ed6:	str	r3, [r4, #20]
    5ed8:	adds	r0, #56	; 0x38
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;
    5eda:	add.w	r0, r0, r5, lsl #5

 fail:
  return nullptr;
}
    5ede:	add	sp, #12
    5ee0:	pop	{r4, r5, pc}

00005ee2 <FatFile::seekSet(unsigned long)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    5ee2:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5ee6:	mov	r4, r0
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    5ee8:	ldr	r7, [r0, #16]
    5eea:	ldrb	r0, [r0, #0]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    5eec:	mov	r6, r1
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    5eee:	cmp	r0, #0
    5ef0:	beq.n	5f80 <FatFile::seekSet(unsigned long)+0x9e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    5ef2:	ldr	r5, [r4, #20]
    5ef4:	cmp	r5, r1
    5ef6:	beq.n	5f88 <FatFile::seekSet(unsigned long)+0xa6>
    return true;
  }
  if (pos == 0) {
    5ef8:	cbnz	r1, 5efe <FatFile::seekSet(unsigned long)+0x1c>
    // set position to start of file
    m_curCluster = 0;
    5efa:	str	r1, [r4, #16]
    goto done;
    5efc:	b.n	5f74 <FatFile::seekSet(unsigned long)+0x92>
  }
  if (isFile()) {
    5efe:	lsls	r2, r0, #28
    5f00:	bpl.n	5f0a <FatFile::seekSet(unsigned long)+0x28>
    if (pos > m_fileSize) {
    5f02:	ldr	r3, [r4, #28]
    5f04:	cmp	r1, r3
    5f06:	bhi.n	5f80 <FatFile::seekSet(unsigned long)+0x9e>
    5f08:	b.n	5f1a <FatFile::seekSet(unsigned long)+0x38>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (isRootFixed()) {
    5f0a:	lsls	r3, r0, #26
    5f0c:	bpl.n	5f1a <FatFile::seekSet(unsigned long)+0x38>
    5f0e:	ldr	r3, [r4, #8]
    if (pos <= 32*m_vol->rootDirEntryCount()) {
    5f10:	ldrh	r3, [r3, #8]
    5f12:	cmp.w	r1, r3, lsl #5
    5f16:	bhi.n	5f80 <FatFile::seekSet(unsigned long)+0x9e>
    5f18:	b.n	5f74 <FatFile::seekSet(unsigned long)+0x92>
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    5f1a:	ldr.w	lr, [r4, #8]
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    5f1e:	ldrb	r1, [r4, #2]
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    5f20:	ldrb.w	r2, [lr, #6]
    5f24:	adds	r2, #9
    5f26:	uxtb	r2, r2
    5f28:	subs	r3, r6, #1
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    5f2a:	lsls	r1, r1, #25
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    5f2c:	lsr.w	r3, r3, r2
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  if (isContiguous()) {
    5f30:	bpl.n	5f3a <FatFile::seekSet(unsigned long)+0x58>
    m_curCluster = m_firstCluster + nNew;
    5f32:	ldr	r2, [r4, #32]
    5f34:	add	r3, r2
    5f36:	str	r3, [r4, #16]
    goto done;
    5f38:	b.n	5f74 <FatFile::seekSet(unsigned long)+0x92>
  }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> (m_vol->bytesPerClusterShift());
    5f3a:	subs	r1, r5, #1
    5f3c:	lsr.w	r2, r1, r2

  if (nNew < nCur || m_curPosition == 0) {
    5f40:	cmp	r3, r2
    5f42:	bcc.n	5f46 <FatFile::seekSet(unsigned long)+0x64>
    5f44:	cbnz	r5, 5f5a <FatFile::seekSet(unsigned long)+0x78>
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    5f46:	lsls	r2, r0, #25
    5f48:	ite	mi
    5f4a:	ldrmi.w	r2, [lr, #32]
    5f4e:	ldrpl	r2, [r4, #32]
    5f50:	str	r2, [r4, #16]
    5f52:	mov	r5, r3
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    5f54:	add.w	r8, r4, #16
    5f58:	b.n	5f70 <FatFile::seekSet(unsigned long)+0x8e>
  if (nNew < nCur || m_curPosition == 0) {
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    5f5a:	subs	r3, r3, r2
    5f5c:	b.n	5f52 <FatFile::seekSet(unsigned long)+0x70>
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    5f5e:	mov	r2, r8
    5f60:	ldr	r1, [r4, #16]
    5f62:	ldr	r0, [r4, #8]
    5f64:	bl	697c <FatPartition::fatGet(unsigned long, unsigned long*)>
    5f68:	cmp	r0, #0
    5f6a:	add.w	r5, r5, #4294967295
    5f6e:	ble.n	5f80 <FatFile::seekSet(unsigned long)+0x9e>
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    5f70:	cmp	r5, #0
    5f72:	bne.n	5f5e <FatFile::seekSet(unsigned long)+0x7c>
    }
  }

 done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    5f74:	ldrb	r3, [r4, #2]
      goto fail;
    }
  }

 done:
  m_curPosition = pos;
    5f76:	str	r6, [r4, #20]
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    5f78:	bic.w	r3, r3, #32
    5f7c:	strb	r3, [r4, #2]
    5f7e:	b.n	5f88 <FatFile::seekSet(unsigned long)+0xa6>
  return true;

 fail:
  m_curCluster = tmp;
    5f80:	str	r7, [r4, #16]
  return false;
    5f82:	movs	r0, #0
    5f84:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    5f88:	movs	r0, #1
  return true;

 fail:
  m_curCluster = tmp;
  return false;
}
    5f8a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00005f8e <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>:
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    5f8e:	push	{r3, r4, r5, r6, r7, lr}
    5f90:	mov	r7, r1
    5f92:	mov	r6, r2
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    5f94:	movs	r1, #0
    5f96:	movs	r2, #36	; 0x24
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    5f98:	mov	r4, r0
    5f9a:	mov	r5, r3
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    5f9c:	bl	8fc0 <memset>
  // location of entry in cache
  m_vol = dirFile->m_vol;
    5fa0:	ldr	r0, [r7, #8]
  m_dirIndex = dirIndex;
    5fa2:	strh	r6, [r4, #4]
    5fa4:	add.w	r2, r0, #56	; 0x38
  m_dirCluster = dirFile->m_firstCluster;
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;
    5fa8:	and.w	r6, r6, #15
    5fac:	add.w	r2, r2, r6, lsl #5
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    5fb0:	ldr	r3, [r7, #32]
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
    5fb2:	str	r0, [r4, #8]
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    5fb4:	str	r3, [r4, #12]
    5fb6:	ldrb	r1, [r2, #11]
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;

  // Must be file or subdirectory.
  if (!isFileOrSubdir(dir)) {
    5fb8:	lsls	r6, r1, #28
    5fba:	bmi.n	603a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
    5fbc:	and.w	r1, r1, #23
    5fc0:	strb	r1, [r4, #0]
  if (isFileDir(dir)) {
    5fc2:	ldrb	r3, [r2, #11]
    5fc4:	tst.w	r3, #24
    m_attributes |= FILE_ATTR_FILE;
  }
  m_lfnOrd = lfnOrd;
    5fc8:	ldrb.w	r3, [sp, #24]
    5fcc:	strb	r3, [r4, #3]
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    m_attributes |= FILE_ATTR_FILE;
    5fce:	it	eq
    5fd0:	orreq.w	r1, r1, #8
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    5fd4:	and.w	r3, r5, #3
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    m_attributes |= FILE_ATTR_FILE;
    5fd8:	it	eq
    5fda:	strbeq	r1, [r4, #0]
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    5fdc:	cmp	r3, #1
    5fde:	beq.n	5ff2 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x64>
    5fe0:	cmp	r3, #2
    5fe2:	beq.n	5fee <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x60>
    5fe4:	cbnz	r3, 603a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    case O_RDONLY:
      if (oflag & O_TRUNC) {
    5fe6:	lsls	r3, r5, #21
    5fe8:	bmi.n	603a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
        DBG_FAIL_MACRO;
        goto fail;
      }
      m_flags = FILE_FLAG_READ;
    5fea:	movs	r3, #1
    5fec:	b.n	5ff4 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
      break;

    case O_RDWR:
      m_flags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    5fee:	movs	r3, #3
    5ff0:	b.n	5ff4 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
      break;

    case O_WRONLY:
      m_flags = FILE_FLAG_WRITE;
    5ff2:	movs	r3, #2
    5ff4:	strb	r3, [r4, #2]
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }

  if (m_flags & FILE_FLAG_WRITE) {
    5ff6:	ldrb	r3, [r4, #2]
    5ff8:	lsls	r7, r3, #30
    5ffa:	bpl.n	6004 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x76>
    if (isSubDir() || isReadOnly()) {
    5ffc:	ldrb	r1, [r4, #0]
    5ffe:	tst.w	r1, #17
    6002:	bne.n	603a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_flags |= (oflag & O_APPEND ? FILE_FLAG_APPEND : 0);
    6004:	and.w	r1, r5, #8
    6008:	orrs	r3, r1
    600a:	strb	r3, [r4, #2]
    600c:	ldr	r3, [r0, #52]	; 0x34

  m_dirSector = m_vol->cacheSectorNumber();
    600e:	str	r3, [r4, #24]

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    6010:	ldrh	r1, [r2, #20]
    6012:	ldrh	r3, [r2, #26]

  if (oflag & O_TRUNC) {
    6014:	lsls	r6, r5, #21

  m_dirSector = m_vol->cacheSectorNumber();

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    6016:	orr.w	r1, r3, r1, lsl #16

  if (oflag & O_TRUNC) {
    601a:	bpl.n	6026 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x98>
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
    601c:	cbz	r1, 6042 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xb4>
    601e:	bl	6ac2 <FatPartition::freeChain(unsigned long)>
    6022:	cbnz	r0, 6042 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xb4>
    6024:	b.n	603a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xac>
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else {
    m_firstCluster = firstCluster;
    6026:	str	r1, [r4, #32]
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    6028:	ldr	r3, [r2, #28]
    m_fileSize = getLe32(dir->fileSize);
    602a:	str	r3, [r4, #28]
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    602c:	lsls	r3, r5, #17
    602e:	bpl.n	604c <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xbe>
    6030:	ldr	r1, [r4, #28]
    6032:	mov	r0, r4
    6034:	bl	5ee2 <FatFile::seekSet(unsigned long)>
    6038:	cbnz	r0, 604c <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xbe>
    goto fail;
  }
  return true;

 fail:
  m_attributes = FILE_ATTR_CLOSED;
    603a:	movs	r0, #0
    603c:	strb	r0, [r4, #0]
  m_flags = 0;
    603e:	strb	r0, [r4, #2]
  return false;
    6040:	pop	{r3, r4, r5, r6, r7, pc}
      DBG_FAIL_MACRO;
      goto fail;
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    6042:	ldrb	r3, [r4, #2]
    6044:	orn	r3, r3, #127	; 0x7f
    6048:	strb	r3, [r4, #2]
    604a:	b.n	602c <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x9e>
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  return true;
    604c:	movs	r0, #1

 fail:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
    604e:	pop	{r3, r4, r5, r6, r7, pc}

00006050 <FatFile::openNext(FatFile*, int)>:
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    6050:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    6054:	ldrb	r3, [r0, #0]
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    6056:	mov	r6, r0
    6058:	mov	r5, r1
    605a:	mov	r9, r2
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    605c:	cbnz	r3, 60ce <FatFile::openNext(FatFile*, int)+0x7e>
    605e:	ldrb	r3, [r1, #0]
    6060:	tst.w	r3, #112	; 0x70
    6064:	beq.n	60ce <FatFile::openNext(FatFile*, int)+0x7e>
    6066:	ldr	r4, [r1, #20]
    6068:	ands.w	r4, r4, #31
    606c:	bne.n	60ce <FatFile::openNext(FatFile*, int)+0x7e>
    606e:	mov	r7, r4
    goto fail;
  }
  while (1) {
    // read entry into cache
    index = dirFile->curPosition()/32;
    DirFat_t* dir = dirFile->readDirCache();
    6070:	movs	r1, #0
    6072:	mov	r0, r5
    6074:	ldr.w	r8, [r5, #20]
    6078:	bl	5ea8 <FatFile::readDirCache(bool)>
    if (!dir) {
    607c:	cbz	r0, 60ce <FatFile::openNext(FatFile*, int)+0x7e>
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    // done if last entry
    if (dir->name[0] == FAT_NAME_FREE) {
    607e:	ldrb	r3, [r0, #0]
    6080:	cbz	r3, 60ce <FatFile::openNext(FatFile*, int)+0x7e>
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
    6082:	cmp	r3, #46	; 0x2e
    6084:	bne.n	608a <FatFile::openNext(FatFile*, int)+0x3a>
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
        lfnOrd = ldir->order & 0X1F;
        checksum = ldir->checksum;
      }
    } else {
      lfnOrd = 0;
    6086:	movs	r4, #0
    6088:	b.n	6070 <FatFile::openNext(FatFile*, int)+0x20>
    // done if last entry
    if (dir->name[0] == FAT_NAME_FREE) {
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
    608a:	cmp	r3, #229	; 0xe5
    608c:	beq.n	6086 <FatFile::openNext(FatFile*, int)+0x36>
    608e:	ldrb	r2, [r0, #11]
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
    6090:	and.w	lr, r2, #8
    6094:	and.w	r1, lr, #255	; 0xff
    6098:	cmp.w	lr, #0
    609c:	bne.n	60be <FatFile::openNext(FatFile*, int)+0x6e>
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
    609e:	cbz	r4, 60d2 <FatFile::openNext(FatFile*, int)+0x82>
    60a0:	subs	r2, r0, #1
    60a2:	adds	r0, #10
    60a4:	lsls	r3, r1, #7
    60a6:	orr.w	r1, r3, r1, lsr #1
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    60aa:	ldrb.w	r3, [r2, #1]!
    60ae:	uxtab	r1, r3, r1
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    60b2:	cmp	r0, r2
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    60b4:	uxtb	r1, r1
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    60b6:	bne.n	60a4 <FatFile::openNext(FatFile*, int)+0x54>
    60b8:	cmp	r7, r1
    60ba:	bne.n	60ce <FatFile::openNext(FatFile*, int)+0x7e>
    60bc:	b.n	60d2 <FatFile::openNext(FatFile*, int)+0x82>
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      return true;
    } else if (isLongName(dir)) {
    60be:	cmp	r2, #15
    60c0:	bne.n	6086 <FatFile::openNext(FatFile*, int)+0x36>
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
    60c2:	lsls	r2, r3, #25
    60c4:	bpl.n	6070 <FatFile::openNext(FatFile*, int)+0x20>
        lfnOrd = ldir->order & 0X1F;
    60c6:	and.w	r4, r3, #31
        checksum = ldir->checksum;
    60ca:	ldrb	r7, [r0, #13]
    60cc:	b.n	6070 <FatFile::openNext(FatFile*, int)+0x20>
      lfnOrd = 0;
    }
  }

 fail:
  return false;
    60ce:	movs	r0, #0
    60d0:	b.n	60e2 <FatFile::openNext(FatFile*, int)+0x92>
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
    60d2:	str	r4, [sp, #0]
    60d4:	mov	r3, r9
    60d6:	ubfx	r2, r8, #5, #16
    60da:	mov	r1, r5
    60dc:	mov	r0, r6
    60de:	bl	5f8e <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    }
  }

 fail:
  return false;
}
    60e2:	add	sp, #12
    60e4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

000060e8 <FatFile::rmdir()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
    60e8:	push	{r4, lr}
  // must be open subdirectory
  if (!isSubDir() || (!USE_LONG_FILE_NAMES && isLFN())) {
    60ea:	ldrb	r3, [r0, #0]
    60ec:	lsls	r2, r3, #27

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
    60ee:	mov	r4, r0
  // must be open subdirectory
  if (!isSubDir() || (!USE_LONG_FILE_NAMES && isLFN())) {
    60f0:	bpl.n	6132 <FatFile::rmdir()+0x4a>
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    60f2:	movs	r1, #0
    60f4:	bl	5ee2 <FatFile::seekSet(unsigned long)>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    DirFat_t* dir = readDirCache(true);
    60f8:	movs	r1, #1
    60fa:	mov	r0, r4
    60fc:	bl	5ea8 <FatFile::readDirCache(bool)>
    if (!dir) {
    6100:	cbnz	r0, 6108 <FatFile::rmdir()+0x20>
      // EOF if no error.
      if (!getError()) {
    6102:	ldrb	r3, [r4, #1]
    6104:	cbz	r3, 611c <FatFile::rmdir()+0x34>
    6106:	b.n	6132 <FatFile::rmdir()+0x4a>
      }
      DBG_FAIL_MACRO;
      goto fail;
    }
    // done if past last used entry
    if (dir->name[0] == FAT_NAME_FREE) {
    6108:	ldrb	r3, [r0, #0]
    610a:	cbz	r3, 611c <FatFile::rmdir()+0x34>
      break;
    }
    // skip empty slot, '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    610c:	cmp	r3, #229	; 0xe5
    610e:	beq.n	60f8 <FatFile::rmdir()+0x10>
    6110:	cmp	r3, #46	; 0x2e
    6112:	beq.n	60f8 <FatFile::rmdir()+0x10>
      continue;
    }
    // error not empty
    if (isFileOrSubdir(dir)) {
    6114:	ldrb	r3, [r0, #11]
    6116:	lsls	r3, r3, #28
    6118:	bmi.n	60f8 <FatFile::rmdir()+0x10>
    611a:	b.n	6132 <FatFile::rmdir()+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    611c:	movs	r3, #8
    611e:	strb	r3, [r4, #0]
  m_flags |= FILE_FLAG_WRITE;
    6120:	ldrb	r3, [r4, #2]
    6122:	orr.w	r3, r3, #2
    6126:	strb	r3, [r4, #2]
  return remove();
    6128:	mov	r0, r4

 fail:
  return false;
}
    612a:	ldmia.w	sp!, {r4, lr}
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    612e:	b.w	72e4 <FatFile::remove()>

 fail:
  return false;
}
    6132:	movs	r0, #0
    6134:	pop	{r4, pc}
    6136:	Address 0x00006136 is out of bounds.


00006138 <FatFile::sync()>:
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    6138:	push	{r0, r1, r2, r4, r5, lr}
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    613a:	ldrb	r3, [r0, #0]
 fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    613c:	mov	r4, r0
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    613e:	cmp	r3, #0
    6140:	beq.n	61ac <FatFile::sync()+0x74>
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    6142:	ldrsb.w	r3, [r0, #2]
    6146:	cmp	r3, #0
    6148:	bge.n	61a0 <FatFile::sync()+0x68>
    DirFat_t* dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    614a:	movs	r1, #1
    614c:	bl	5c8c <FatFile::cacheDirEntry(unsigned char)>
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
    6150:	mov	r5, r0
    6152:	cbnz	r0, 6160 <FatFile::sync()+0x28>
    return true;
  }
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
    6154:	ldrb	r3, [r4, #1]
    6156:	orr.w	r3, r3, #1
    615a:	strb	r3, [r4, #1]
  return false;
    615c:	movs	r0, #0
    615e:	b.n	61ae <FatFile::sync()+0x76>
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    DirFat_t* dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
    6160:	ldrb	r3, [r0, #0]
    6162:	cmp	r3, #229	; 0xe5
    6164:	beq.n	6154 <FatFile::sync()+0x1c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // do not set filesize for dir files
    if (isFile()) {
    6166:	ldrb	r3, [r4, #0]
    6168:	lsls	r3, r3, #28
      setLe32(dir->fileSize, m_fileSize);
    616a:	itt	mi
    616c:	ldrmi	r3, [r4, #28]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    616e:	strmi	r3, [r0, #28]
    }
    // update first cluster fields
    setLe16(dir->firstClusterLow, m_firstCluster & 0XFFFF);
    6170:	ldr	r3, [r4, #32]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    6172:	strh	r3, [r0, #26]
    6174:	lsrs	r3, r3, #16
    6176:	strh	r3, [r0, #20]
    setLe16(dir->firstClusterHigh, m_firstCluster >> 16);

    // set modify time if user supplied a callback date/time function
    if (FsDateTime::callback) {
    6178:	ldr	r3, [pc, #56]	; (61b4 <FatFile::sync()+0x7c>)
    617a:	ldr	r3, [r3, #0]
    617c:	cbz	r3, 6198 <FatFile::sync()+0x60>
      FsDateTime::callback(&date, &time, &ms10);
    617e:	add.w	r2, sp, #3
    6182:	add.w	r1, sp, #6
    6186:	add	r0, sp, #4
    6188:	blx	r3
      setLe16(dir->modifyDate, date);
    618a:	ldrh.w	r3, [sp, #4]
    618e:	strh	r3, [r5, #24]
    6190:	strh	r3, [r5, #18]
    6192:	ldrh.w	r3, [sp, #6]
    6196:	strh	r3, [r5, #22]
      setLe16(dir->accessDate, date);
      setLe16(dir->modifyTime, time);
    }
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    6198:	ldrb	r3, [r4, #2]
    619a:	and.w	r3, r3, #127	; 0x7f
    619e:	strb	r3, [r4, #2]
  }
  if (m_vol->cacheSync()) {
    61a0:	ldr	r0, [r4, #8]
    61a2:	bl	5ba4 <FatPartition::cacheSync()>
    61a6:	cmp	r0, #0
    61a8:	beq.n	6154 <FatFile::sync()+0x1c>
    61aa:	b.n	61ae <FatFile::sync()+0x76>
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
    61ac:	movs	r0, #1
  DBG_FAIL_MACRO;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    61ae:	add	sp, #12
    61b0:	pop	{r4, r5, pc}
    61b2:	nop
    61b4:	.word	0x2001ceb4

000061b8 <FatFile::close()>:

 fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
    61b8:	push	{r4, lr}
    61ba:	mov	r4, r0
  bool rtn = sync();
    61bc:	bl	6138 <FatFile::sync()>
  m_attributes = FILE_ATTR_CLOSED;
    61c0:	movs	r3, #0
    61c2:	strb	r3, [r4, #0]
  m_flags = 0;
    61c4:	strb	r3, [r4, #2]
  return rtn;
}
    61c6:	pop	{r4, pc}

000061c8 <FatFile::open(FatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    61c8:	push	{r4, r5, r6, r7, lr}
    61ca:	sub	sp, #84	; 0x54
    61cc:	mov	r7, r3
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    61ce:	movs	r3, #0
    61d0:	strb.w	r3, [sp, #8]
    61d4:	strb.w	r3, [sp, #9]
    61d8:	strb.w	r3, [sp, #10]
    61dc:	strh.w	r3, [sp, #56]	; 0x38
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    61e0:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    61e2:	str	r2, [sp, #4]
    61e4:	mov	r6, r0
    61e6:	mov	r4, r1
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    61e8:	cbz	r3, 61ee <FatFile::open(FatFile*, char const*, int)+0x26>
    close();
  }
  return open(dirFile, &fname, oflag);

 fail:
  return false;
    61ea:	movs	r0, #0
    61ec:	b.n	626c <FatFile::open(FatFile*, char const*, int)+0xa4>
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
  FatFile tmpDir;
  FatName_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    61ee:	ldrb	r3, [r1, #0]
    61f0:	tst.w	r3, #112	; 0x70
    61f4:	beq.n	61ea <FatFile::open(FatFile*, char const*, int)+0x22>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    61f6:	ldrb	r3, [r2, #0]
    61f8:	cmp	r3, #47	; 0x2f
    61fa:	bne.n	6222 <FatFile::open(FatFile*, char const*, int)+0x5a>
    while (isDirSeparator(*path)) {
    61fc:	ldr	r3, [sp, #4]
    61fe:	ldrb	r2, [r3, #0]
    6200:	cmp	r2, #47	; 0x2f
    6202:	bne.n	620a <FatFile::open(FatFile*, char const*, int)+0x42>
      path++;
    6204:	adds	r3, #1
    6206:	str	r3, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    6208:	b.n	61fc <FatFile::open(FatFile*, char const*, int)+0x34>
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    620a:	ldr	r1, [r4, #8]
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
    620c:	cbnz	r2, 6216 <FatFile::open(FatFile*, char const*, int)+0x4e>
      return openRoot(dirFile->m_vol);
    620e:	mov	r0, r6
    6210:	bl	5caa <FatFile::openRoot(FatVolume*)>
    6214:	b.n	626c <FatFile::open(FatFile*, char const*, int)+0xa4>
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    6216:	add	r0, sp, #8
    6218:	bl	5caa <FatFile::openRoot(FatVolume*)>
    621c:	cmp	r0, #0
    621e:	beq.n	61ea <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    6220:	add	r4, sp, #8
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    6222:	add	r3, sp, #4
    6224:	add	r2, sp, #44	; 0x2c
    6226:	ldr	r1, [sp, #4]
    6228:	mov	r0, r6
    622a:	bl	724c <FatFile::parsePathName(char const*, FatName_t*, char const**)>
    622e:	cmp	r0, #0
    6230:	beq.n	61ea <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    6232:	ldr	r3, [sp, #4]
    6234:	ldrb	r3, [r3, #0]
    6236:	cbz	r3, 6260 <FatFile::open(FatFile*, char const*, int)+0x98>
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    6238:	movs	r3, #0
    623a:	add	r2, sp, #44	; 0x2c
    623c:	mov	r1, r4
    623e:	mov	r0, r6
    6240:	bl	6ffc <FatFile::open(FatFile*, FatName_t*, int)>
    6244:	cmp	r0, #0
    6246:	beq.n	61ea <FatFile::open(FatFile*, char const*, int)+0x22>
      DBG_WARN_MACRO;
      goto fail;
    }
    tmpDir = *this;
    6248:	mov	r5, r6
    624a:	ldmia	r5!, {r0, r1, r2, r3}
    624c:	add	r4, sp, #8
    624e:	stmia	r4!, {r0, r1, r2, r3}
    6250:	ldmia	r5!, {r0, r1, r2, r3}
    6252:	stmia	r4!, {r0, r1, r2, r3}
    6254:	ldr	r3, [r5, #0]
    6256:	str	r3, [r4, #0]
    dirFile = &tmpDir;
    close();
    6258:	mov	r0, r6
    625a:	bl	61b8 <FatFile::close()>
    625e:	b.n	6220 <FatFile::open(FatFile*, char const*, int)+0x58>
  }
  return open(dirFile, &fname, oflag);
    6260:	mov	r3, r7
    6262:	add	r2, sp, #44	; 0x2c
    6264:	mov	r1, r4
    6266:	mov	r0, r6
    6268:	bl	6ffc <FatFile::open(FatFile*, FatName_t*, int)>

 fail:
  return false;
}
    626c:	add	sp, #84	; 0x54
    626e:	pop	{r4, r5, r6, r7, pc}

00006270 <FatFile::open(FatVolume*, char const*, int)>:
bool FatFile::open(const char* path, oflag_t oflag) {
  return open(FatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
    6270:	cbz	r1, 627a <FatFile::open(FatVolume*, char const*, int)+0xa>
    6272:	add.w	r1, r1, #1096	; 0x448
    6276:	b.w	61c8 <FatFile::open(FatFile*, char const*, int)>
}
    627a:	mov	r0, r1
    627c:	bx	lr

0000627e <FatFile::dirEntry(DirFat_t*)>:
  close();
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::dirEntry(DirFat_t* dst) {
    627e:	push	{r4, r5, r6, lr}
    6280:	mov	r6, r0
    6282:	mov	r4, r1
  DirFat_t* dir;
  // Make sure fields on device are correct.
  if (!sync()) {
    6284:	bl	6138 <FatFile::sync()>
    6288:	mov	r5, r0
    628a:	cbnz	r0, 6290 <FatFile::dirEntry(DirFat_t*)+0x12>
  // copy to caller's struct
  memcpy(dst, dir, sizeof(DirFat_t));
  return true;

 fail:
  return false;
    628c:	movs	r5, #0
    628e:	b.n	62ae <FatFile::dirEntry(DirFat_t*)+0x30>
  if (!sync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    6290:	movs	r1, #0
    6292:	mov	r0, r6
    6294:	bl	5c8c <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    6298:	cmp	r0, #0
    629a:	beq.n	628c <FatFile::dirEntry(DirFat_t*)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy to caller's struct
  memcpy(dst, dir, sizeof(DirFat_t));
    629c:	mov	r1, r4
    629e:	add.w	r3, r0, #32
    62a2:	ldr.w	r2, [r0], #4
    62a6:	str.w	r2, [r1], #4
    62aa:	cmp	r0, r3
    62ac:	bne.n	62a2 <FatFile::dirEntry(DirFat_t*)+0x24>
  return true;

 fail:
  return false;
}
    62ae:	mov	r0, r5
    62b0:	pop	{r4, r5, r6, pc}

000062b2 <FatFile::getCreateDateTime(unsigned short*, unsigned short*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    62b2:	push	{r4, r5, lr}
    62b4:	sub	sp, #36	; 0x24
    62b6:	mov	r5, r1
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    62b8:	mov	r1, sp

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getCreateDateTime(uint16_t* pdate, uint16_t* ptime) {
    62ba:	mov	r4, r2
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    62bc:	bl	627e <FatFile::dirEntry(DirFat_t*)>
    62c0:	cbz	r0, 62ce <FatFile::getCreateDateTime(unsigned short*, unsigned short*)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(dir.createDate);
    62c2:	ldrh.w	r3, [sp, #16]
    62c6:	strh	r3, [r5, #0]
  *ptime = getLe16(dir.createTime);
    62c8:	ldrh.w	r3, [sp, #14]
    62cc:	strh	r3, [r4, #0]
  return true;

 fail:
  return false;
}
    62ce:	add	sp, #36	; 0x24
    62d0:	pop	{r4, r5, pc}

000062d2 <FatFile::getModifyDateTime(unsigned short*, unsigned short*)>:
//------------------------------------------------------------------------------
bool FatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    62d2:	push	{r4, r5, lr}
    62d4:	sub	sp, #36	; 0x24
    62d6:	mov	r5, r1
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    62d8:	mov	r1, sp

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::getModifyDateTime(uint16_t* pdate, uint16_t* ptime) {
    62da:	mov	r4, r2
  DirFat_t dir;
  if (!dirEntry(&dir)) {
    62dc:	bl	627e <FatFile::dirEntry(DirFat_t*)>
    62e0:	cbz	r0, 62ee <FatFile::getModifyDateTime(unsigned short*, unsigned short*)+0x1c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  *pdate = getLe16(dir.modifyDate);
    62e2:	ldrh.w	r3, [sp, #24]
    62e6:	strh	r3, [r5, #0]
  *ptime = getLe16(dir.modifyTime);
    62e8:	ldrh.w	r3, [sp, #22]
    62ec:	strh	r3, [r4, #0]
  return true;

 fail:
  return false;
}
    62ee:	add	sp, #36	; 0x24
    62f0:	pop	{r4, r5, pc}

000062f2 <FatFile::mkdir(FatFile*, FatName_t*)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, FatName_t* fname) {
    62f2:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    62f6:	ldrb	r3, [r1, #0]
    62f8:	tst.w	r3, #112	; 0x70

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, FatName_t* fname) {
    62fc:	sub	sp, #32
    62fe:	mov	r4, r0
    6300:	mov	r6, r1
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    6302:	beq.n	633e <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    6304:	movw	r3, #2562	; 0xa02
    6308:	bl	6ffc <FatFile::open(FatFile*, FatName_t*, int)>
    630c:	cbz	r0, 633e <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    630e:	movs	r7, #1
  m_attributes = FILE_ATTR_SUBDIR;
    6310:	movs	r5, #16
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    6312:	strb	r7, [r4, #2]
  m_attributes = FILE_ATTR_SUBDIR;
    6314:	strb	r5, [r4, #0]

  // allocate and zero first cluster
  if (!addDirCluster()) {
    6316:	mov	r0, r4
    6318:	bl	5c00 <FatFile::addDirCluster()>
    631c:	cbz	r0, 633e <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    631e:	ldr	r3, [r4, #16]
    6320:	str	r3, [r4, #32]
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    6322:	movs	r1, #0
    6324:	mov	r0, r4
    6326:	bl	5ee2 <FatFile::seekSet(unsigned long)>
  // Set to start of dir
  rewind();
  // force entry to device
  if (!sync()) {
    632a:	mov	r0, r4
    632c:	bl	6138 <FatFile::sync()>
    6330:	cbz	r0, 633e <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // cache entry - should already be in cache due to sync() call
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6332:	mov	r1, r7
    6334:	mov	r0, r4
    6336:	bl	5c8c <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    633a:	mov	r3, r0
    633c:	cbnz	r0, 6342 <FatFile::mkdir(FatFile*, FatName_t*)+0x50>
  memcpy(&pc->dir[1], &dot, sizeof(dot));
  // write first sector
  return m_vol->cacheSync();

 fail:
  return false;
    633e:	movs	r0, #0
    6340:	b.n	63e6 <FatFile::mkdir(FatFile*, FatName_t*)+0xf4>
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // change directory entry attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;
    6342:	strb	r5, [r0, #11]

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
    6344:	mov	r2, r0
    6346:	mov	r7, sp
    6348:	add.w	ip, r0, #32
    634c:	mov	r5, sp
    634e:	ldr	r0, [r2, #0]
    6350:	ldr	r1, [r2, #4]
    6352:	mov	lr, r7
    6354:	stmia.w	lr!, {r0, r1}
    6358:	adds	r2, #8
    635a:	cmp	r2, ip
    635c:	mov	r7, lr
    635e:	bne.n	634e <FatFile::mkdir(FatFile*, FatName_t*)+0x5c>
    6360:	ldrh	r7, [r3, #20]
    6362:	ldrh.w	r8, [r3, #26]
  dot.name[0] = '.';
    6366:	movs	r3, #46	; 0x2e
    6368:	strb.w	r3, [sp]
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    636c:	movs	r1, #32
  // change directory entry attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
    636e:	movs	r3, #0
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    6370:	adds	r2, r5, r3
    6372:	adds	r3, #1
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    6374:	cmp	r3, #10
    dot.name[i] = ' ';
    6376:	strb	r1, [r2, #1]
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    6378:	bne.n	6370 <FatFile::mkdir(FatFile*, FatName_t*)+0x7e>
    dot.name[i] = ' ';
  }

  // cache sector for '.'  and '..'
  sector = m_vol->clusterStartSector(m_firstCluster);
    637a:	ldr	r0, [r4, #8]
    637c:	ldr	r1, [r4, #32]
    637e:	ldrb	r3, [r0, #6]
    6380:	subs	r1, #2
    6382:	lsls	r1, r3
    6384:	ldr	r3, [r0, #20]
    6386:	movs	r2, #1
    6388:	add	r1, r3
    638a:	adds	r0, #40	; 0x28
    638c:	bl	376a <FsCache::get(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
  if (!pc) {
    6390:	mov	r3, r0
    6392:	cmp	r0, #0
    6394:	beq.n	633e <FatFile::mkdir(FatFile*, FatName_t*)+0x4c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
    6396:	strh.w	r7, [sp, #20]
    639a:	strh.w	r8, [sp, #26]
    639e:	mov	lr, r5
    63a0:	mov	r7, r0
    63a2:	add.w	ip, sp, #32
    63a6:	mov	r2, lr
    63a8:	ldmia	r2!, {r0, r1}
    63aa:	cmp	r2, ip
    63ac:	str	r0, [r7, #0]
    63ae:	str	r1, [r7, #4]
    63b0:	mov	lr, r2
    63b2:	add.w	r7, r7, #8
    63b6:	bne.n	63a6 <FatFile::mkdir(FatFile*, FatName_t*)+0xb4>
  // make entry for '..'
  dot.name[1] = '.';
    63b8:	movs	r2, #46	; 0x2e
    63ba:	strb.w	r2, [sp, #1]
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
    63be:	ldr	r2, [r6, #32]
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    63c0:	strh.w	r2, [sp, #26]
    63c4:	lsrs	r1, r2, #16
    63c6:	strh.w	r1, [sp, #20]
    63ca:	adds	r3, #32
    63cc:	add	r6, sp, #32
    63ce:	mov	r2, r5
    63d0:	ldmia	r2!, {r0, r1}
    63d2:	cmp	r2, r6
    63d4:	str	r0, [r3, #0]
    63d6:	str	r1, [r3, #4]
    63d8:	mov	r5, r2
    63da:	add.w	r3, r3, #8
    63de:	bne.n	63ce <FatFile::mkdir(FatFile*, FatName_t*)+0xdc>
  // write first sector
  return m_vol->cacheSync();
    63e0:	ldr	r0, [r4, #8]
    63e2:	bl	5ba4 <FatPartition::cacheSync()>

 fail:
  return false;
}
    63e6:	add	sp, #32
    63e8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000063ec <FatFile::mkdir(FatFile*, char const*, bool)>:
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    63ec:	push	{r4, r5, r6, r7, lr}
    63ee:	sub	sp, #84	; 0x54
    63f0:	mov	r7, r3
    63f2:	movs	r3, #0
    63f4:	strh.w	r3, [sp, #20]
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    63f8:	strb.w	r3, [sp, #44]	; 0x2c
    63fc:	strb.w	r3, [sp, #45]	; 0x2d
    6400:	strb.w	r3, [sp, #46]	; 0x2e
  FatName_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    6404:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::isBusy() {
  return m_vol->isBusy();
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    6406:	str	r2, [sp, #4]
    6408:	mov	r6, r0
    640a:	mov	r4, r1
  FatName_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    640c:	cmp	r3, #0
    640e:	bne.n	6490 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    6410:	ldrb	r3, [r1, #0]
    6412:	tst.w	r3, #112	; 0x70
    6416:	beq.n	6490 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    6418:	ldrb	r3, [r2, #0]
    641a:	cmp	r3, #47	; 0x2f
    641c:	bne.n	6438 <FatFile::mkdir(FatFile*, char const*, bool)+0x4c>
    while (isDirSeparator(*path)) {
    641e:	ldr	r3, [sp, #4]
    6420:	ldrb	r2, [r3, #0]
    6422:	cmp	r2, #47	; 0x2f
    6424:	bne.n	642c <FatFile::mkdir(FatFile*, char const*, bool)+0x40>
      path++;
    6426:	adds	r3, #1
    6428:	str	r3, [sp, #4]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    642a:	b.n	641e <FatFile::mkdir(FatFile*, char const*, bool)+0x32>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    642c:	ldr	r1, [r4, #8]
    642e:	add	r0, sp, #44	; 0x2c
    6430:	bl	5caa <FatFile::openRoot(FatVolume*)>
    6434:	cbz	r0, 6490 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    6436:	add	r4, sp, #44	; 0x2c
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    6438:	add	r3, sp, #4
    643a:	add	r2, sp, #8
    643c:	ldr	r1, [sp, #4]
    643e:	mov	r0, r6
    6440:	bl	724c <FatFile::parsePathName(char const*, FatName_t*, char const**)>
    6444:	cbz	r0, 6490 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    6446:	ldr	r3, [sp, #4]
    6448:	ldrb	r3, [r3, #0]
    644a:	cbz	r3, 6484 <FatFile::mkdir(FatFile*, char const*, bool)+0x98>
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    644c:	movs	r3, #0
    644e:	add	r2, sp, #8
    6450:	mov	r1, r4
    6452:	mov	r0, r6
    6454:	bl	6ffc <FatFile::open(FatFile*, FatName_t*, int)>
    6458:	cbz	r0, 6472 <FatFile::mkdir(FatFile*, char const*, bool)+0x86>
      if (!pFlag || !mkdir(parent, &fname)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    645a:	mov	r5, r6
    645c:	ldmia	r5!, {r0, r1, r2, r3}
    645e:	add	r4, sp, #44	; 0x2c
    6460:	stmia	r4!, {r0, r1, r2, r3}
    6462:	ldmia	r5!, {r0, r1, r2, r3}
    6464:	stmia	r4!, {r0, r1, r2, r3}
    6466:	ldr	r3, [r5, #0]
    6468:	str	r3, [r4, #0]
    parent = &tmpDir;
    close();
    646a:	mov	r0, r6
    646c:	bl	61b8 <FatFile::close()>
    6470:	b.n	6436 <FatFile::mkdir(FatFile*, char const*, bool)+0x4a>
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
      if (!pFlag || !mkdir(parent, &fname)) {
    6472:	cbz	r7, 6490 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    6474:	add	r2, sp, #8
    6476:	mov	r1, r4
    6478:	mov	r0, r6
    647a:	bl	62f2 <FatFile::mkdir(FatFile*, FatName_t*)>
    647e:	cmp	r0, #0
    6480:	bne.n	645a <FatFile::mkdir(FatFile*, char const*, bool)+0x6e>
    6482:	b.n	6490 <FatFile::mkdir(FatFile*, char const*, bool)+0xa4>
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    6484:	add	r2, sp, #8
    6486:	mov	r1, r4
    6488:	mov	r0, r6
    648a:	bl	62f2 <FatFile::mkdir(FatFile*, FatName_t*)>
    648e:	b.n	6492 <FatFile::mkdir(FatFile*, char const*, bool)+0xa6>

 fail:
  return false;
    6490:	movs	r0, #0
}
    6492:	add	sp, #84	; 0x54
    6494:	pop	{r4, r5, r6, r7, pc}

00006496 <FatFile::rename(FatFile*, char const*)>:
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    6496:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    649a:	ldrb	r3, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    649c:	sub	sp, #108	; 0x6c
    649e:	movs	r7, #0
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    64a0:	tst.w	r3, #24
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    64a4:	mov	r4, r0
    64a6:	mov	r8, r1
    64a8:	mov	r9, r2
    64aa:	strb.w	r7, [sp, #32]
    64ae:	strb.w	r7, [sp, #33]	; 0x21
    64b2:	strb.w	r7, [sp, #34]	; 0x22
    64b6:	strb.w	r7, [sp, #68]	; 0x44
    64ba:	strb.w	r7, [sp, #69]	; 0x45
    64be:	strb.w	r7, [sp, #70]	; 0x46
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    64c2:	bne.n	64c8 <FatFile::rename(FatFile*, char const*)+0x32>
    goto fail;
  }
  return m_vol->cacheSync();

 fail:
  return false;
    64c4:	movs	r0, #0
    64c6:	b.n	6626 <FatFile::rename(FatFile*, char const*)+0x190>
  if (!USE_LONG_FILE_NAMES && isLFN()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    64c8:	ldr	r2, [r0, #8]
    64ca:	ldr	r3, [r1, #8]
    64cc:	cmp	r2, r3
    64ce:	bne.n	64c4 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // sync() and cache directory entry
  sync();
  oldFile = *this;
    64d0:	mov	r6, r4
  if (m_vol != dirFile->m_vol) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // sync() and cache directory entry
  sync();
    64d2:	bl	6138 <FatFile::sync()>
  oldFile = *this;
    64d6:	ldmia	r6!, {r0, r1, r2, r3}
    64d8:	add	r5, sp, #68	; 0x44
    64da:	stmia	r5!, {r0, r1, r2, r3}
    64dc:	ldmia	r6!, {r0, r1, r2, r3}
    64de:	stmia	r5!, {r0, r1, r2, r3}
    64e0:	ldr	r3, [r6, #0]
    64e2:	str	r3, [r5, #0]
  dir = cacheDirEntry(FsCache::CACHE_FOR_READ);
    64e4:	mov	r1, r7
    64e6:	mov	r0, r4
    64e8:	bl	5c8c <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    64ec:	cmp	r0, #0
    64ee:	beq.n	64c4 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    64f0:	mov	r3, r0
    64f2:	mov	r2, sp
    64f4:	add.w	r7, r0, #32
    64f8:	mov	r5, sp
    64fa:	ldr	r0, [r3, #0]
    64fc:	ldr	r1, [r3, #4]
    64fe:	mov	r6, r2
    6500:	stmia	r6!, {r0, r1}
    6502:	adds	r3, #8
    6504:	cmp	r3, r7
    6506:	mov	r2, r6
    6508:	bne.n	64fa <FatFile::rename(FatFile*, char const*)+0x64>
  // make directory entry for new path
  if (isFile()) {
    650a:	ldrb	r2, [r4, #0]
    650c:	and.w	r2, r2, #8
    6510:	and.w	r3, r2, #255	; 0xff
    6514:	add	r6, sp, #32
    6516:	cbz	r2, 652e <FatFile::rename(FatFile*, char const*)+0x98>
    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    6518:	movw	r3, #2561	; 0xa01
    651c:	mov	r2, r9
    651e:	mov	r1, r8
    6520:	mov	r0, r6
    6522:	bl	61c8 <FatFile::open(FatFile*, char const*, int)>
    6526:	cmp	r0, #0
    6528:	beq.n	64c4 <FatFile::rename(FatFile*, char const*)+0x2e>
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
  DirFat_t entry;
  uint32_t dirCluster = 0;
    652a:	movs	r7, #0
    652c:	b.n	653e <FatFile::rename(FatFile*, char const*)+0xa8>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // don't create missing path prefix components
    if (!file.mkdir(dirFile, newPath, false)) {
    652e:	mov	r2, r9
    6530:	mov	r1, r8
    6532:	mov	r0, r6
    6534:	bl	63ec <FatFile::mkdir(FatFile*, char const*, bool)>
    6538:	cmp	r0, #0
    653a:	beq.n	64c4 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
    653c:	ldr	r7, [sp, #64]	; 0x40
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
    653e:	ldr	r3, [sp, #56]	; 0x38
    6540:	str	r3, [r4, #24]
  m_dirIndex = file.m_dirIndex;
    6542:	ldrh.w	r3, [sp, #36]	; 0x24
    6546:	strh	r3, [r4, #4]
  m_lfnOrd = file.m_lfnOrd;
    6548:	ldrb.w	r3, [sp, #35]	; 0x23
    654c:	strb	r3, [r4, #3]
  m_dirCluster = file.m_dirCluster;
    654e:	ldr	r3, [sp, #44]	; 0x2c
    6550:	str	r3, [r4, #12]
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6552:	movs	r1, #1
  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    6554:	movs	r3, #0
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6556:	mov	r0, r4
  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    6558:	strb.w	r3, [sp, #32]
  file.m_flags = 0;
    655c:	strb.w	r3, [sp, #34]	; 0x22

  // cache new directory entry
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6560:	bl	5c8c <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    6564:	cmp	r0, #0
    6566:	beq.n	64c4 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy all but name and name flags to new directory entry
  memcpy(&dir->createTimeMs, &entry.createTimeMs,
         sizeof(entry) - sizeof(dir->name) - 2);
    6568:	add.w	r3, sp, #13
    656c:	add.w	r2, r0, #13
    6570:	add.w	r1, sp, #29
    6574:	ldr.w	lr, [r3], #4
    6578:	str.w	lr, [r2], #4
    657c:	cmp	r3, r1
    657e:	bne.n	6574 <FatFile::rename(FatFile*, char const*)+0xde>
    6580:	ldrh	r1, [r3, #0]
    6582:	strh	r1, [r2, #0]
    6584:	ldrb	r3, [r3, #2]
    6586:	strb	r3, [r2, #2]
  dir->attributes = entry.attributes;
    6588:	ldrb.w	r3, [sp, #11]
    658c:	strb	r3, [r0, #11]

  // update dot dot if directory
  if (dirCluster) {
    658e:	cmp	r7, #0
    6590:	beq.n	6604 <FatFile::rename(FatFile*, char const*)+0x16e>
    // get new dot dot
    uint32_t sector = m_vol->clusterStartSector(dirCluster);
    6592:	ldr	r0, [r4, #8]
    6594:	ldrb	r1, [r0, #6]
    6596:	subs	r3, r7, #2
    6598:	lsls	r3, r1
    659a:	ldr	r1, [r0, #20]
    659c:	movs	r2, #0
    659e:	add	r1, r3
    65a0:	adds	r0, #40	; 0x28
    65a2:	bl	376a <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    65a6:	cmp	r0, #0
    65a8:	beq.n	64c4 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&entry, &pc->dir[1], sizeof(entry));
    65aa:	add.w	r3, r0, #32
    65ae:	mov	lr, r5
    65b0:	add.w	ip, r0, #64	; 0x40
    65b4:	ldr	r0, [r3, #0]
    65b6:	ldr	r1, [r3, #4]
    65b8:	mov	r2, lr
    65ba:	stmia	r2!, {r0, r1}
    65bc:	adds	r3, #8
    65be:	cmp	r3, ip
    65c0:	mov	lr, r2
    65c2:	bne.n	65b4 <FatFile::rename(FatFile*, char const*)+0x11e>

    // free unused cluster
    if (!m_vol->freeChain(dirCluster)) {
    65c4:	mov	r1, r7
    65c6:	ldr	r0, [r4, #8]
    65c8:	bl	6ac2 <FatPartition::freeChain(unsigned long)>
    65cc:	cmp	r0, #0
    65ce:	beq.w	64c4 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // store new dot dot
    sector = m_vol->clusterStartSector(m_firstCluster);
    65d2:	ldr	r0, [r4, #8]
    65d4:	ldr	r1, [r4, #32]
    65d6:	ldrb	r3, [r0, #6]
    65d8:	subs	r1, #2
    65da:	lsls	r1, r3
    65dc:	ldr	r3, [r0, #20]
    65de:	movs	r2, #1
    65e0:	add	r1, r3
    65e2:	adds	r0, #40	; 0x28
    65e4:	bl	376a <FsCache::get(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    65e8:	cmp	r0, #0
    65ea:	beq.w	64c4 <FatFile::rename(FatFile*, char const*)+0x2e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&pc->dir[1], &entry, sizeof(entry));
    65ee:	add.w	r3, r0, #32
    65f2:	mov	r2, r5
    65f4:	ldmia	r2!, {r0, r1}
    65f6:	cmp	r2, r6
    65f8:	str	r0, [r3, #0]
    65fa:	str	r1, [r3, #4]
    65fc:	mov	r5, r2
    65fe:	add.w	r3, r3, #8
    6602:	bne.n	65f2 <FatFile::rename(FatFile*, char const*)+0x15c>
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    6604:	movs	r3, #0
    6606:	str	r3, [sp, #100]	; 0x64
  oldFile.m_flags = FILE_FLAG_WRITE;
    6608:	movs	r3, #2
    660a:	strb.w	r3, [sp, #70]	; 0x46
  oldFile.m_attributes = FILE_ATTR_FILE;
  if (!oldFile.remove()) {
    660e:	add	r0, sp, #68	; 0x44
    memcpy(&pc->dir[1], &entry, sizeof(entry));
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
    6610:	movs	r3, #8
    6612:	strb.w	r3, [sp, #68]	; 0x44
  if (!oldFile.remove()) {
    6616:	bl	72e4 <FatFile::remove()>
    661a:	cmp	r0, #0
    661c:	beq.w	64c4 <FatFile::rename(FatFile*, char const*)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return m_vol->cacheSync();
    6620:	ldr	r0, [r4, #8]
    6622:	bl	5ba4 <FatPartition::cacheSync()>

 fail:
  return false;
}
    6626:	add	sp, #108	; 0x6c
    6628:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0000662c <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)>:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    662c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6630:	mov	r4, r3
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    6632:	ldrb	r3, [r0, #0]
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    6634:	ldrb.w	fp, [sp, #40]	; 0x28
    6638:	ldrb.w	r9, [sp, #44]	; 0x2c
    663c:	ldrb.w	sl, [sp, #48]	; 0x30
    6640:	ldrb.w	r5, [sp, #52]	; 0x34
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    6644:	lsls	r3, r3, #28
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                   uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
    6646:	mov	r6, r0
    6648:	mov	r7, r1
      || month > 12
      || day < 1
      || day > 31
      || hour > 23
      || minute > 59
      || second > 59) {
    664a:	bmi.n	6652 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x26>
    setLe16(dir->modifyTime, dirTime);
  }
  return m_vol->cacheSync();

 fail:
  return false;
    664c:	movs	r0, #0
    664e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint16_t dirDate;
  uint16_t dirTime;
  DirFat_t* dir;

  if (!isFile()
      || year < 1980
    6652:	subw	r2, r2, #1980	; 0x7bc
    6656:	uxth.w	r8, r2
    665a:	cmp.w	r8, #127	; 0x7f
    665e:	bhi.n	664c <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || year > 2107
      || month < 1
    6660:	subs	r3, r4, #1
    6662:	cmp	r3, #11
    6664:	bhi.n	664c <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || month > 12
      || day < 1
    6666:	add.w	r3, fp, #4294967295
    666a:	cmp	r3, #30
    666c:	bhi.n	664c <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || day > 31
      || hour > 23
    666e:	cmp.w	r9, #23
    6672:	bhi.n	664c <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || minute > 59
    6674:	cmp.w	sl, #59	; 0x3b
    6678:	bhi.n	664c <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
      || second > 59) {
    667a:	cmp	r5, #59	; 0x3b
    667c:	bhi.n	664c <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // update directory entry
  if (!sync()) {
    667e:	bl	6138 <FatFile::sync()>
    6682:	cmp	r0, #0
    6684:	beq.n	664c <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
    DBG_FAIL_MACRO;
    goto fail;
  }
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    6686:	movs	r1, #1
    6688:	mov	r0, r6
    668a:	bl	5c8c <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    668e:	cmp	r0, #0
    6690:	beq.n	664c <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x20>
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    6692:	orr.w	r4, fp, r4, lsl #5
    6696:	orr.w	r8, r4, r8, lsl #9
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    669a:	asrs	r3, r5, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  dirDate = FS_DATE(year, month, day);
  dirTime = FS_TIME(hour, minute, second);
  if (flags & T_ACCESS) {
    669c:	lsls	r4, r7, #31
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    669e:	uxth.w	r8, r8
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    66a2:	orr.w	r3, r3, sl, lsl #5
    66a6:	orr.w	r3, r3, r9, lsl #11
    66aa:	it	mi
    66ac:	strhmi.w	r8, [r0, #18]
    setLe16(dir->accessDate, dirDate);
  }
  if (flags & T_CREATE) {
    66b0:	lsls	r1, r7, #30
    66b2:	uxth	r3, r3
    66b4:	bpl.n	66c6 <FatFile::timestamp(unsigned char, unsigned short, unsigned char, unsigned char, unsigned char, unsigned char, unsigned char)+0x9a>
    setLe16(dir->createDate, dirDate);
    setLe16(dir->createTime, dirTime);
    // units of 10 ms
    dir->createTimeMs = second & 1 ? 100 : 0;
    66b6:	ands.w	r5, r5, #1
    66ba:	it	ne
    66bc:	movne	r5, #100	; 0x64
    66be:	strh.w	r8, [r0, #16]
    66c2:	strh	r3, [r0, #14]
    66c4:	strb	r5, [r0, #13]
  }
  if (flags & T_WRITE) {
    66c6:	lsls	r2, r7, #29
    66c8:	itt	mi
    66ca:	strhmi.w	r8, [r0, #24]
    66ce:	strhmi	r3, [r0, #22]
    setLe16(dir->modifyDate, dirDate);
    setLe16(dir->modifyTime, dirTime);
  }
  return m_vol->cacheSync();
    66d0:	ldr	r0, [r6, #8]
    66d2:	bl	5ba4 <FatPartition::cacheSync()>
    66d6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

000066da <FatFile::truncate()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    66da:	push	{r0, r1, r4, lr}
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    66dc:	ldrb	r3, [r0, #2]
    66de:	lsls	r3, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::truncate() {
    66e0:	mov	r4, r0
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    66e2:	bmi.n	66e8 <FatFile::truncate()+0xe>
  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
    66e4:	movs	r0, #0
    66e6:	b.n	673e <FatFile::truncate()+0x64>
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    66e8:	ldr	r3, [r0, #32]
    66ea:	cbz	r3, 673c <FatFile::truncate()+0x62>
      return true;
  }
  if (m_curCluster) {
    66ec:	ldr	r1, [r0, #16]
    66ee:	cbz	r1, 6714 <FatFile::truncate()+0x3a>
    toFree = 0;
    66f0:	add	r2, sp, #8
    66f2:	movs	r3, #0
    66f4:	str.w	r3, [r2, #-4]!
    int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    66f8:	ldr	r0, [r0, #8]
    66fa:	bl	697c <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    66fe:	cmp	r0, #0
    6700:	blt.n	66e4 <FatFile::truncate()+0xa>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg) {
    6702:	beq.n	6718 <FatFile::truncate()+0x3e>
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    6704:	mvn.w	r2, #4026531840	; 0xf0000000
    6708:	ldr	r1, [r4, #16]
    670a:	ldr	r0, [r4, #8]
    670c:	bl	69e6 <FatPartition::fatPut(unsigned long, unsigned long)>
      // current cluster is end of chain
      if (!m_vol->fatPutEOC(m_curCluster)) {
    6710:	cbnz	r0, 6718 <FatFile::truncate()+0x3e>
    6712:	b.n	66e4 <FatFile::truncate()+0xa>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  } else {
    toFree = m_firstCluster;
    6714:	str	r3, [sp, #4]
    m_firstCluster = 0;
    6716:	str	r1, [r0, #32]
  }
  if (toFree) {
    6718:	ldr	r1, [sp, #4]
    671a:	cbnz	r1, 6730 <FatFile::truncate()+0x56>
    if (!m_vol->freeChain(toFree)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_fileSize = m_curPosition;
    671c:	ldr	r3, [r4, #20]
    671e:	str	r3, [r4, #28]

  // need to update directory entry
  m_flags |= FILE_FLAG_DIR_DIRTY;
    6720:	ldrb	r3, [r4, #2]
    6722:	orn	r3, r3, #127	; 0x7f
    6726:	strb	r3, [r4, #2]
  return sync();
    6728:	mov	r0, r4
    672a:	bl	6138 <FatFile::sync()>
    672e:	b.n	673e <FatFile::truncate()+0x64>
  } else {
    toFree = m_firstCluster;
    m_firstCluster = 0;
  }
  if (toFree) {
    if (!m_vol->freeChain(toFree)) {
    6730:	ldr	r0, [r4, #8]
    6732:	bl	6ac2 <FatPartition::freeChain(unsigned long)>
    6736:	cmp	r0, #0
    6738:	bne.n	671c <FatFile::truncate()+0x42>
    673a:	b.n	66e4 <FatFile::truncate()+0xa>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    673c:	movs	r0, #1
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    673e:	add	sp, #8
    6740:	pop	{r4, pc}
    6742:	Address 0x00006742 is out of bounds.


00006744 <FatFile::write(void const*, unsigned int)>:
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    6744:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6748:	ldrb	r3, [r0, #2]
    674a:	mov	r9, r1
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    674c:	lsls	r1, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    674e:	mov	r4, r0
    6750:	mov	r5, r2
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    6752:	bpl.w	6872 <FatFile::write(void const*, unsigned int)+0x12e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    6756:	lsls	r2, r3, #28
    6758:	bmi.n	6770 <FatFile::write(void const*, unsigned int)+0x2c>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    675a:	ldr	r3, [r4, #20]
    675c:	mvns	r3, r3
    675e:	cmp	r5, r3
    6760:	bhi.w	6872 <FatFile::write(void const*, unsigned int)+0x12e>
    6764:	mov	r7, r5
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6766:	mov.w	sl, #0
    m_sector = 0XFFFFFFFF;
    676a:	mov.w	fp, #4294967295
    676e:	b.n	67fe <FatFile::write(void const*, unsigned int)+0xba>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_fileSize)) {
    6770:	ldr	r1, [r0, #28]
    6772:	bl	5ee2 <FatFile::seekSet(unsigned long)>
    6776:	cmp	r0, #0
    6778:	bne.n	675a <FatFile::write(void const*, unsigned int)+0x16>
    677a:	b.n	6872 <FatFile::write(void const*, unsigned int)+0x12e>
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    677c:	ldr	r0, [r4, #8]
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    677e:	ldrb	r6, [r0, #5]
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    6780:	ands.w	r6, r6, r2, lsr #9
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    6784:	ubfx	r8, r2, #0, #9
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    6788:	beq.n	6806 <FatFile::write(void const*, unsigned int)+0xc2>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
    678a:	ldr.w	lr, [r4, #8]
                      + sectorOfCluster;
    678e:	ldr	r1, [r4, #16]
    6790:	ldrb.w	r3, [lr, #6]
    6794:	subs	r1, #2
    6796:	lsls	r1, r3
    6798:	ldr.w	r3, [lr, #20]
    679c:	add	r1, r3
    679e:	add	r1, r6

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
    67a0:	cmp.w	r8, #0
    67a4:	bne.n	6838 <FatFile::write(void const*, unsigned int)+0xf4>
    67a6:	cmp.w	r7, #512	; 0x200
    67aa:	bcs.n	6886 <FatFile::write(void const*, unsigned int)+0x142>
      // lesser of space and amount to write
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (sectorOffset == 0 &&
    67ac:	ldr	r2, [r4, #20]
    67ae:	ldr	r3, [r4, #28]
    67b0:	cmp	r2, r3
    67b2:	bcs.n	683c <FatFile::write(void const*, unsigned int)+0xf8>
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
    67b4:	ldrb	r3, [r4, #2]
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    67b6:	tst.w	r3, #32
    67ba:	ite	eq
    67bc:	moveq	r2, #1
    67be:	movne	r2, #5
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    67c0:	add.w	r0, lr, #40	; 0x28
    67c4:	bl	376a <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      pc = m_vol->cacheFetchData(sector, cacheOption);
      if (!pc) {
    67c8:	cmp	r0, #0
    67ca:	beq.n	6872 <FatFile::write(void const*, unsigned int)+0x12e>
                      + sectorOfCluster;

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    67cc:	rsb	r6, r8, #512	; 0x200
    67d0:	cmp	r6, r7
    67d2:	it	cs
    67d4:	movcs	r6, r7
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    67d6:	add	r0, r8
    67d8:	mov	r2, r6
    67da:	mov	r1, r9
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    67dc:	add	r8, r6
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    67de:	bl	8e18 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    67e2:	cmp.w	r8, #512	; 0x200
    67e6:	bne.n	67f4 <FatFile::write(void const*, unsigned int)+0xb0>
  }
  void cacheInvalidate() {
    m_cache.invalidate();
  }
  bool cacheSyncData() {
    return m_cache.sync();
    67e8:	ldr	r0, [r4, #8]
    67ea:	adds	r0, #40	; 0x28
    67ec:	bl	371e <FsCache::sync()>
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
      if (nSector > maxSectors) {
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
      if (!m_vol->cacheSafeWrite(sector, src, nSector)) {
    67f0:	cmp	r0, #0
    67f2:	beq.n	6872 <FatFile::write(void const*, unsigned int)+0x12e>
      if (!m_vol->cacheSafeWrite(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    67f4:	ldr	r3, [r4, #20]
    67f6:	add	r3, r6
    67f8:	str	r3, [r4, #20]
    src += n;
    67fa:	add	r9, r6
    nToWrite -= n;
    67fc:	subs	r7, r7, r6
    67fe:	ldr	r2, [r4, #20]
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    6800:	cmp	r7, #0
    6802:	bne.n	677c <FatFile::write(void const*, unsigned int)+0x38>
    6804:	b.n	6840 <FatFile::write(void const*, unsigned int)+0xfc>
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    6806:	cmp.w	r8, #0
    680a:	bne.n	678a <FatFile::write(void const*, unsigned int)+0x46>
      // start of new cluster
      if (m_curCluster != 0) {
    680c:	ldr	r1, [r4, #16]
    680e:	cbz	r1, 6822 <FatFile::write(void const*, unsigned int)+0xde>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
    6810:	ldrb	r3, [r4, #2]
    6812:	lsls	r3, r3, #25
    6814:	bpl.n	685a <FatFile::write(void const*, unsigned int)+0x116>
    6816:	ldr	r3, [r4, #28]
    6818:	cmp	r2, r3
    681a:	bcs.n	685a <FatFile::write(void const*, unsigned int)+0x116>
          m_curCluster++;
    681c:	adds	r1, #1
    681e:	str	r1, [r4, #16]
    6820:	b.n	678a <FatFile::write(void const*, unsigned int)+0x46>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    6822:	ldr	r3, [r4, #32]
    6824:	cbnz	r3, 6834 <FatFile::write(void const*, unsigned int)+0xf0>
          // allocate first cluster of file
          if (!addCluster()) {
    6826:	mov	r0, r4
    6828:	bl	5bca <FatFile::addCluster()>
    682c:	cbz	r0, 6872 <FatFile::write(void const*, unsigned int)+0x12e>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    682e:	ldr	r3, [r4, #16]
    6830:	str	r3, [r4, #32]
    6832:	b.n	678a <FatFile::write(void const*, unsigned int)+0x46>
        } else {
          m_curCluster = m_firstCluster;
    6834:	str	r3, [r4, #16]
    6836:	b.n	678a <FatFile::write(void const*, unsigned int)+0x46>
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    6838:	movs	r2, #1
    683a:	b.n	67c0 <FatFile::write(void const*, unsigned int)+0x7c>
      }

      if (sectorOffset == 0 &&
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    683c:	movs	r2, #5
    683e:	b.n	67c0 <FatFile::write(void const*, unsigned int)+0x7c>
    }
    m_curPosition += n;
    src += n;
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    6840:	ldr	r3, [r4, #28]
    6842:	cmp	r2, r3
    6844:	bls.n	684a <FatFile::write(void const*, unsigned int)+0x106>
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    6846:	str	r2, [r4, #28]
    6848:	b.n	6850 <FatFile::write(void const*, unsigned int)+0x10c>
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    684a:	ldr	r3, [pc, #180]	; (6900 <FatFile::write(void const*, unsigned int)+0x1bc>)
    684c:	ldr	r3, [r3, #0]
    684e:	cbz	r3, 6880 <FatFile::write(void const*, unsigned int)+0x13c>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    6850:	ldrb	r3, [r4, #2]
    6852:	orn	r3, r3, #127	; 0x7f
    6856:	strb	r3, [r4, #2]
    6858:	b.n	6880 <FatFile::write(void const*, unsigned int)+0x13c>
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
          m_curCluster++;
          fg = 1;
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    685a:	add.w	r2, r4, #16
    685e:	bl	697c <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    6862:	cmp	r0, #0
    6864:	blt.n	6872 <FatFile::write(void const*, unsigned int)+0x12e>
        if (fg < 0) {
          DBG_FAIL_MACRO;
          goto fail;
        }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        if (fg == 0) {
    6866:	bne.n	68e8 <FatFile::write(void const*, unsigned int)+0x1a4>
          // add cluster if at end of chain
          if (!addCluster()) {
    6868:	mov	r0, r4
    686a:	bl	5bca <FatFile::addCluster()>
    686e:	cmp	r0, #0
    6870:	bne.n	68e8 <FatFile::write(void const*, unsigned int)+0x1a4>
  }
  return nbyte;

 fail:
  // return for write error
  m_error |= WRITE_ERROR;
    6872:	ldrb	r3, [r4, #1]
    6874:	orr.w	r3, r3, #1
    6878:	strb	r3, [r4, #1]
  return 0;
    687a:	movs	r0, #0
    687c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6880:	mov	r0, r5
    6882:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (nToWrite >= 2*m_vol->bytesPerSector()) {
    6886:	cmp.w	r7, #1024	; 0x400
    688a:	ldr.w	r2, [lr, #52]	; 0x34
    688e:	ldr.w	r0, [lr, #44]	; 0x2c
    6892:	bcc.n	68be <FatFile::write(void const*, unsigned int)+0x17a>
      // use multiple sector write command
      uint32_t maxSectors = m_vol->sectorsPerCluster() - sectorOfCluster;
    6894:	ldrb.w	r3, [lr, #4]
    6898:	subs	r6, r3, r6
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
    689a:	lsrs	r3, r7, #9
    689c:	cmp	r3, r6
    689e:	it	cs
    68a0:	movcs	r3, r6
   * \param[in] sector Start sector of the range.
   * \param[in] count Number of sectors in the range.
   * \return true if a sector in the range is cached.
   */
  bool isCached(uint32_t sector, size_t count) {
    return sector <= m_sector && m_sector < (sector + count);
    68a2:	cmp	r2, r1
      if (nSector > maxSectors) {
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
    68a4:	mov.w	r6, r3, lsl #9
    68a8:	bcc.n	68b2 <FatFile::write(void const*, unsigned int)+0x16e>
    68aa:	add.w	ip, r3, r1
    68ae:	cmp	r2, ip
    68b0:	bcc.n	68de <FatFile::write(void const*, unsigned int)+0x19a>
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src, size_t count) {
     if (isCached(sector, count)) {
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
    68b2:	ldr	r2, [r0, #0]
    68b4:	ldr.w	r8, [r2, #36]	; 0x24
    68b8:	mov	r2, r9
    68ba:	blx	r8
    68bc:	b.n	67f0 <FatFile::write(void const*, unsigned int)+0xac>
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
    68be:	cmp	r2, r1
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    68c0:	it	eq
    68c2:	strbeq.w	sl, [lr, #40]	; 0x28
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    68c6:	ldr	r3, [r0, #0]
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    68c8:	it	eq
    68ca:	streq.w	fp, [lr, #52]	; 0x34
   */
  bool cacheSafeWrite(uint32_t sector, const uint8_t* src) {
    if (isCached(sector)) {
      invalidate();
    }
    return m_blockDev->writeSector(sector, src);
    68ce:	ldr	r3, [r3, #32]
    68d0:	mov	r2, r9
    68d2:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
      if (!m_vol->cacheSafeWrite(sector, src)) {
    68d4:	cmp	r0, #0
    68d6:	beq.n	6872 <FatFile::write(void const*, unsigned int)+0x12e>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
    68d8:	mov.w	r6, #512	; 0x200
    68dc:	b.n	67f4 <FatFile::write(void const*, unsigned int)+0xb0>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    68de:	strb.w	sl, [lr, #40]	; 0x28
    m_sector = 0XFFFFFFFF;
    68e2:	str.w	fp, [lr, #52]	; 0x34
    68e6:	b.n	68b2 <FatFile::write(void const*, unsigned int)+0x16e>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
    68e8:	ldr.w	lr, [r4, #8]
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
  }
  uint32_t clusterStartSector(uint32_t cluster) const {
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    68ec:	ldr	r1, [r4, #16]
    68ee:	ldrb.w	r3, [lr, #6]
    68f2:	subs	r1, #2
    68f4:	lsls	r1, r3
    68f6:	ldr.w	r3, [lr, #20]
    68fa:	add	r1, r3
    68fc:	b.n	67a6 <FatFile::write(void const*, unsigned int)+0x62>
    68fe:	nop
    6900:	.word	0x2001ceb4

00006904 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)>:

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat16(uint32_t sector, uint8_t *buf, void *context) {
   struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint16_t *p = (uint16_t *)buf;
  unsigned int n = state->clusters_to_do;
    6904:	ldr	r3, [r2, #0]
    6906:	cmp.w	r3, #256	; 0x100
  uint32_t clusters_to_do;
  uint32_t free_count;
};

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat16(uint32_t sector, uint8_t *buf, void *context) {
    690a:	push	{r4, r5, lr}
    690c:	mov	r4, r3
    690e:	it	cs
    6910:	movcs.w	r4, #256	; 0x100
   struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint16_t *p = (uint16_t *)buf;
  unsigned int n = state->clusters_to_do;
  if (n > 256) n = 256;
  uint16_t *e = p + n;
    6914:	add.w	r5, r1, r4, lsl #1
  while (p < e) {
    6918:	cmp	r1, r5
    691a:	bcs.n	692c <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x28>
    if (*p++ == 0) state->free_count++;
    691c:	ldrh.w	r0, [r1], #2
    6920:	cmp	r0, #0
    6922:	bne.n	6918 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x14>
    6924:	ldr	r0, [r2, #4]
    6926:	adds	r0, #1
    6928:	str	r0, [r2, #4]
    692a:	b.n	6918 <FatPartition::freeClusterCount_cb_fat16(unsigned long, unsigned char*, void*)+0x14>
  }
  state->clusters_to_do -= n;
    692c:	subs	r3, r3, r4
    692e:	str	r3, [r2, #0]
    6930:	pop	{r4, r5, pc}

00006932 <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)>:

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat32(uint32_t sector, uint8_t *buf, void *context) {
  struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint32_t *p = (uint32_t *)buf;
  unsigned int n = state->clusters_to_do;
    6932:	ldr	r3, [r2, #0]
    6934:	cmp	r3, #128	; 0x80
  }
  state->clusters_to_do -= n;
}

//------------------------------------------------------------------------------
void FatPartition::freeClusterCount_cb_fat32(uint32_t sector, uint8_t *buf, void *context) {
    6936:	push	{r4, r5, lr}
    6938:	mov	r4, r3
    693a:	it	cs
    693c:	movcs	r4, #128	; 0x80
  struct FreeClusterCountStruct *state = (struct FreeClusterCountStruct *)context;
  uint32_t *p = (uint32_t *)buf;
  unsigned int n = state->clusters_to_do;
  if (n > 128) n = 128;
  uint32_t *e = p + n;
    693e:	add.w	r5, r1, r4, lsl #2
  while (p < e) {
    6942:	cmp	r1, r5
    6944:	bcs.n	6956 <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x24>
    if (*p++ == 0) state->free_count++;
    6946:	ldr.w	r0, [r1], #4
    694a:	cmp	r0, #0
    694c:	bne.n	6942 <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x10>
    694e:	ldr	r0, [r2, #4]
    6950:	adds	r0, #1
    6952:	str	r0, [r2, #4]
    6954:	b.n	6942 <FatPartition::freeClusterCount_cb_fat32(unsigned long, unsigned char*, void*)+0x10>
  }
  state->clusters_to_do -= n;
    6956:	subs	r3, r3, r4
    6958:	str	r3, [r2, #0]
    695a:	pop	{r4, r5, pc}

0000695c <FsCache::clear()>:
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    695c:	push	{r4, lr}
    if (isDirty() && !sync()) {
    695e:	ldrb	r3, [r0, #0]
    6960:	lsls	r3, r3, #31
      invalidate();
    }
    return m_blockDev->writeSectors(sector, src, count);
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    6962:	mov	r4, r0
    if (isDirty() && !sync()) {
    6964:	bpl.n	696c <FsCache::clear()+0x10>
    6966:	bl	371e <FsCache::sync()>
    696a:	cbz	r0, 697a <FsCache::clear()+0x1e>
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    696c:	movs	r3, #0
    696e:	strb	r3, [r4, #0]
    m_sector = 0XFFFFFFFF;
    6970:	mov.w	r3, #4294967295
    6974:	str	r3, [r4, #12]
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    return m_buffer;
    6976:	add.w	r0, r4, #16
  }
    697a:	pop	{r4, pc}

0000697c <FatPartition::fatGet(unsigned long, unsigned long*)>:
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    697c:	cmp	r1, #1
 fail:
  return false;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry - return -1 error, 0 EOC, else 1.
int8_t FatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    697e:	push	{r4, r5, r6, lr}
    6980:	mov	r5, r0
    6982:	mov	r4, r1
    6984:	mov	r6, r2
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    6986:	bhi.n	698e <FatPartition::fatGet(unsigned long, unsigned long*)+0x12>
  }
  *value = next;
  return 1;

 fail:
  return -1;
    6988:	mov.w	r0, #4294967295
    698c:	pop	{r4, r5, r6, pc}
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    698e:	ldr	r3, [r0, #28]
    6990:	cmp	r1, r3
    6992:	bhi.n	6988 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
    6994:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    6996:	cmp	r3, #32
    6998:	bne.n	69b8 <FatPartition::fatGet(unsigned long, unsigned long*)+0x3c>
  FsCache m_cache;
#if USE_SEPARATE_FAT_CACHE
  FsCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    options |= FsCache::CACHE_STATUS_MIRROR_FAT;
    return reinterpret_cast<cache_t*>(m_fatCache.get(sector, options));
    699a:	ldr	r1, [r0, #24]
    699c:	movs	r2, #2
    699e:	add.w	r1, r1, r4, lsr #7
    69a2:	add.w	r0, r0, #568	; 0x238
    69a6:	bl	376a <FsCache::get(unsigned long, unsigned char)>
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    69aa:	cmp	r0, #0
    69ac:	beq.n	6988 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    69ae:	and.w	r4, r4, #127	; 0x7f
    69b2:	ldr.w	r3, [r0, r4, lsl #2]
    69b6:	b.n	69d8 <FatPartition::fatGet(unsigned long, unsigned long*)+0x5c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe32(reinterpret_cast<uint8_t*>
                  (&pc->fat32[cluster & (m_sectorMask >> 2)]));
  } else if (fatType() == 16) {
    69b8:	cmp	r3, #16
    69ba:	bne.n	6988 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
    69bc:	ldr	r3, [r0, #24]
    69be:	ubfx	r1, r1, #8, #8
    69c2:	movs	r2, #2
    69c4:	add	r1, r3
    69c6:	add.w	r0, r0, #568	; 0x238
    69ca:	bl	376a <FsCache::get(unsigned long, unsigned char)>
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_READ);
    if (!pc) {
    69ce:	cmp	r0, #0
    69d0:	beq.n	6988 <FatPartition::fatGet(unsigned long, unsigned long*)+0xc>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    69d2:	uxtb	r4, r4
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe16(reinterpret_cast<uint8_t*>
                  (&pc->fat16[cluster & (m_sectorMask >> 1)]));
    69d4:	ldrh.w	r3, [r0, r4, lsl #1]
    next = cluster & 1 ? tmp >> 4 : tmp & 0XFFF;
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    69d8:	ldr	r2, [r5, #28]
    69da:	cmp	r3, r2
    return 0;
  }
  *value = next;
  return 1;
    69dc:	itte	ls
    69de:	movls	r0, #1
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
  }
  *value = next;
    69e0:	strls	r3, [r6, #0]
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
    69e2:	movhi	r0, #0
  *value = next;
  return 1;

 fail:
  return -1;
}
    69e4:	pop	{r4, r5, r6, pc}

000069e6 <FatPartition::fatPut(unsigned long, unsigned long)>:
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    69e6:	cmp	r1, #1
 fail:
  return -1;
}
//------------------------------------------------------------------------------
// Store a FAT entry
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
    69e8:	push	{r3, r4, r5, lr}
    69ea:	mov	r4, r1
    69ec:	mov	r5, r2
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    69ee:	bhi.n	69f4 <FatPartition::fatPut(unsigned long, unsigned long)+0xe>
    DBG_FAIL_MACRO;
    goto fail;
  }

 fail:
  return false;
    69f0:	movs	r0, #0
    69f2:	pop	{r3, r4, r5, pc}
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    69f4:	ldr	r3, [r0, #28]
    69f6:	cmp	r1, r3
    69f8:	bhi.n	69f0 <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
    69fa:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    69fc:	cmp	r3, #32
    69fe:	bne.n	6a1e <FatPartition::fatPut(unsigned long, unsigned long)+0x38>
    6a00:	ldr	r1, [r0, #24]
    6a02:	movs	r2, #3
    6a04:	add.w	r1, r1, r4, lsr #7
    6a08:	add.w	r0, r0, #568	; 0x238
    6a0c:	bl	376a <FsCache::get(unsigned long, unsigned char)>
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    6a10:	cmp	r0, #0
    6a12:	beq.n	69f0 <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    6a14:	and.w	r4, r4, #127	; 0x7f
    6a18:	str.w	r5, [r0, r4, lsl #2]
    6a1c:	b.n	6a3e <FatPartition::fatPut(unsigned long, unsigned long)+0x58>
    setLe32(reinterpret_cast<uint8_t*>
           (&pc->fat32[cluster & (m_sectorMask >> 2)]), value);
    return true;
  }

  if (fatType() == 16) {
    6a1e:	cmp	r3, #16
    6a20:	bne.n	69f0 <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
    6a22:	ldr	r3, [r0, #24]
    6a24:	ubfx	r1, r1, #8, #8
    6a28:	movs	r2, #3
    6a2a:	add	r1, r3
    6a2c:	add.w	r0, r0, #568	; 0x238
    6a30:	bl	376a <FsCache::get(unsigned long, unsigned char)>
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FsCache::CACHE_FOR_WRITE);
    if (!pc) {
    6a34:	cmp	r0, #0
    6a36:	beq.n	69f0 <FatPartition::fatPut(unsigned long, unsigned long)+0xa>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    6a38:	uxtb	r4, r4
    6a3a:	strh.w	r5, [r0, r4, lsl #1]
      DBG_FAIL_MACRO;
      goto fail;
    }
    setLe16(reinterpret_cast<uint8_t*>
           (&pc->fat16[cluster & (m_sectorMask >> 1)]), value);
    return true;
    6a3e:	movs	r0, #1
    goto fail;
  }

 fail:
  return false;
}
    6a40:	pop	{r3, r4, r5, pc}

00006a42 <FatPartition::allocateCluster(unsigned long, unsigned long*)>:
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"
#include "FatPartition.h"

//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    6a42:	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    6a46:	ldr	r4, [r0, #12]
    6a48:	cmp	r4, r1
#include "../common/FsStructs.h"
#include "../common/FsGetPartitionInfo.h"
#include "FatPartition.h"

//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    6a4a:	mov	r5, r0
    6a4c:	mov	r6, r1
    6a4e:	mov	r8, r2
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    6a50:	bcs.n	6a62 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x20>
    6a52:	mov	r4, r1
    // Try to keep file contiguous. Start just after current cluster.
    find = current;
    setStart = false;
    6a54:	movs	r7, #0
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    if (find > m_lastCluster) {
    6a56:	ldr	r3, [r5, #28]
  } else {
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    6a58:	adds	r4, #1
    if (find > m_lastCluster) {
    6a5a:	cmp	r4, r3
    6a5c:	bls.n	6a66 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x24>
      if (setStart) {
    6a5e:	cbnz	r7, 6a94 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
        // Can't find space, checked all clusters.
        DBG_FAIL_MACRO;
        goto fail;
      }
      find = m_allocSearchStart;
    6a60:	ldr	r4, [r5, #12]
      setStart = true;
    6a62:	movs	r7, #1
    6a64:	b.n	6a56 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
      continue;
    }
    if (find == current) {
    6a66:	cmp	r6, r4
    6a68:	beq.n	6a94 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    6a6a:	add	r2, sp, #4
    6a6c:	mov	r1, r4
    6a6e:	mov	r0, r5
    6a70:	bl	697c <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    6a74:	cmp	r0, #0
    6a76:	blt.n	6a94 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg && f == 0) {
    6a78:	beq.n	6a56 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
    6a7a:	ldr	r3, [sp, #4]
    6a7c:	cmp	r3, #0
    6a7e:	bne.n	6a56 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x14>
      break;
    }
  }
  if (setStart) {
    6a80:	cbz	r7, 6a84 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x42>
    m_allocSearchStart = find;
    6a82:	str	r4, [r5, #12]
    return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
  }
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    6a84:	mvn.w	r2, #4026531840	; 0xf0000000
    6a88:	mov	r1, r4
    6a8a:	mov	r0, r5
    6a8c:	bl	69e6 <FatPartition::fatPut(unsigned long, unsigned long)>
  }
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    6a90:	mov	r7, r0
    6a92:	cbnz	r0, 6a98 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x56>
  updateFreeClusterCount(-1);
  *next = find;
  return true;

 fail:
  return false;
    6a94:	movs	r7, #0
    6a96:	b.n	6aba <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
    6a98:	cbnz	r6, 6aa6 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x64>
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
  }
  void updateFreeClusterCount(int32_t change) {
    if (m_freeClusterCount >= 0) {
    6a9a:	ldr	r3, [r5, #36]	; 0x24
    6a9c:	cmp	r3, #0
    6a9e:	blt.n	6ab6 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x74>
      m_freeClusterCount += change;
    6aa0:	subs	r3, #1
    6aa2:	str	r3, [r5, #36]	; 0x24
    6aa4:	b.n	6ab6 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x74>
    // Link clusters.
    if (!fatPut(current, find)) {
    6aa6:	mov	r2, r4
    6aa8:	mov	r1, r6
    6aaa:	mov	r0, r5
    6aac:	bl	69e6 <FatPartition::fatPut(unsigned long, unsigned long)>
    6ab0:	cmp	r0, #0
    6ab2:	bne.n	6a9a <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x58>
    6ab4:	b.n	6a94 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  updateFreeClusterCount(-1);
  *next = find;
    6ab6:	str.w	r4, [r8]
  return true;

 fail:
  return false;
}
    6aba:	mov	r0, r7
    6abc:	add	sp, #8
    6abe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00006ac2 <FatPartition::freeChain(unsigned long)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
    6ac2:	push	{r0, r1, r4, r5, r6, lr}
    6ac4:	mov	r5, r0
    6ac6:	mov	r4, r1
  uint32_t next;
  int8_t fg;
  do {
    fg = fatGet(cluster, &next);
    6ac8:	add	r2, sp, #4
    6aca:	mov	r1, r4
    6acc:	mov	r0, r5
    6ace:	bl	697c <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    6ad2:	subs	r6, r0, #0
    6ad4:	bge.n	6ada <FatPartition::freeChain(unsigned long)+0x18>
  } while (fg);

  return true;

 fail:
  return false;
    6ad6:	movs	r0, #0
    6ad8:	b.n	6b04 <FatPartition::freeChain(unsigned long)+0x42>
    if (fg < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
    6ada:	movs	r2, #0
    6adc:	mov	r1, r4
    6ade:	mov	r0, r5
    6ae0:	bl	69e6 <FatPartition::fatPut(unsigned long, unsigned long)>
    6ae4:	cmp	r0, #0
    6ae6:	beq.n	6ad6 <FatPartition::freeChain(unsigned long)+0x14>
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
  }
  void updateFreeClusterCount(int32_t change) {
    if (m_freeClusterCount >= 0) {
    6ae8:	ldr	r3, [r5, #36]	; 0x24
    6aea:	cmp	r3, #0
      m_freeClusterCount += change;
    6aec:	itt	ge
    6aee:	addge	r3, #1
    6af0:	strge	r3, [r5, #36]	; 0x24
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Add one to count of free clusters.
    updateFreeClusterCount(1);
    if (cluster < m_allocSearchStart) {
    6af2:	ldr	r3, [r5, #12]
    6af4:	cmp	r4, r3
      m_allocSearchStart = cluster - 1;
    6af6:	itt	cc
    6af8:	addcc.w	r4, r4, #4294967295
    6afc:	strcc	r4, [r5, #12]
    }
    cluster = next;
    6afe:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  int8_t fg;
  do {
    6b00:	cmp	r6, #0
    6b02:	bne.n	6ac8 <FatPartition::freeChain(unsigned long)+0x6>

  return true;

 fail:
  return false;
}
    6b04:	add	sp, #8
    6b06:	pop	{r4, r5, r6, pc}

00006b08 <FatPartition::freeClusterCount()>:
  }
  state->clusters_to_do -= n;
}

//------------------------------------------------------------------------------
int32_t FatPartition::freeClusterCount() {
    6b08:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    6b0a:	mov	r4, r0
#if MAINTAIN_FREE_CLUSTER_COUNT
  if (m_freeClusterCount >= 0) {
    6b0c:	ldr	r0, [r0, #36]	; 0x24
    6b0e:	cmp	r0, #0
    6b10:	bge.n	6b56 <FatPartition::freeClusterCount()+0x4e>
    return free;
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
    6b12:	movs	r3, #0
    6b14:	str	r3, [sp, #12]
  state.clusters_to_do = m_lastCluster + 1;
    6b16:	ldr	r3, [r4, #28]
  uint32_t num_sectors;

  //num_sectors = SD.sdfs.m_fVol->sectorsPerFat(); // edit FsVolume.h for public
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
    6b18:	ldr	r5, [r4, #16]
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
  state.clusters_to_do = m_lastCluster + 1;
    6b1a:	adds	r3, #1
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
  //Serial.printf("  num_sectors = %u\n", num_sectors);
#if USE_SEPARATE_FAT_CACHE
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
    6b1c:	add.w	r0, r4, #568	; 0x238
  }

  struct FreeClusterCountStruct state;

  state.free_count = 0;
  state.clusters_to_do = m_lastCluster + 1;
    6b20:	str	r3, [sp, #8]
  //Serial.printf("  num_sectors = %u\n", num_sectors);

  num_sectors = m_sectorsPerFat;
  //Serial.printf("  num_sectors = %u\n", num_sectors);
#if USE_SEPARATE_FAT_CACHE
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
    6b22:	bl	695c <FsCache::clear()>
#else  
  uint8_t *buf = m_cache.clear();  // will clear out anything and return buffer 
#endif  // USE_SEPARATE_FAT_CACHE
  if (buf == nullptr) return -1;
    6b26:	mov	r2, r0
    6b28:	cbnz	r0, 6b30 <FatPartition::freeClusterCount()+0x28>
    6b2a:	mov.w	r0, #4294967295
    6b2e:	b.n	6b56 <FatPartition::freeClusterCount()+0x4e>
  if (fatType() == FAT_TYPE_FAT32) {
    6b30:	ldrb	r3, [r4, #7]
    6b32:	ldr	r0, [r4, #0]
    6b34:	cmp	r3, #32
    6b36:	add	r3, sp, #8
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat32, &state)) return -1;
    6b38:	ldr	r1, [r0, #0]
    6b3a:	str	r3, [sp, #4]
  uint8_t *buf = m_fatCache.clear();  // will clear out anything and return buffer 
#else  
  uint8_t *buf = m_cache.clear();  // will clear out anything and return buffer 
#endif  // USE_SEPARATE_FAT_CACHE
  if (buf == nullptr) return -1;
  if (fatType() == FAT_TYPE_FAT32) {
    6b3c:	bne.n	6b42 <FatPartition::freeClusterCount()+0x3a>
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat32, &state)) return -1;
    6b3e:	ldr	r3, [pc, #28]	; (6b5c <FatPartition::freeClusterCount()+0x54>)
    6b40:	b.n	6b44 <FatPartition::freeClusterCount()+0x3c>
  } else {
    if (!m_blockDev->readSectorsCallback(m_fatStartSector, buf, num_sectors, freeClusterCount_cb_fat16, &state)) return -1;
    6b42:	ldr	r3, [pc, #28]	; (6b60 <FatPartition::freeClusterCount()+0x58>)
    6b44:	str	r3, [sp, #0]
    6b46:	ldr	r6, [r1, #20]
    6b48:	ldr	r1, [r4, #24]
    6b4a:	mov	r3, r5
    6b4c:	blx	r6
    6b4e:	cmp	r0, #0
    6b50:	beq.n	6b2a <FatPartition::freeClusterCount()+0x22>
  }

  setFreeClusterCount(state.free_count);
    6b52:	ldr	r0, [sp, #12]
    return m_blockDev->writeSector(sector, src);
  }
#if MAINTAIN_FREE_CLUSTER_COUNT
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
    6b54:	str	r0, [r4, #36]	; 0x24
  return state.free_count;
}
    6b56:	add	sp, #16
    6b58:	pop	{r4, r5, r6, pc}
    6b5a:	nop
    6b5c:	.word	0x00006933
    6b60:	.word	0x00006905

00006b64 <FatPartition::init(BlockDeviceInterface*, unsigned char)>:


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    6b64:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6b68:	mov	r4, r0
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif

  uint8_t tmp;
  m_fatType = 0;
    6b6a:	movs	r7, #0
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    6b6c:	mov.w	r3, #4294967295
  m_allocSearchStart = 1;
    6b70:	movs	r6, #1
  }
  /** Clear the cache and returns a pointer to the cache.  Not for normal apps.
   * \return A pointer to the cache buffer or zero if an error occurs.
   */
  uint8_t* cacheClear() {
    return m_cache.clear();
    6b72:	add.w	r8, r0, #40	; 0x28
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
//  Serial.printf(" FatPartition::init(%x %u)\n", (uint32_t)dev, part);
  uint32_t clusterCount;
  uint32_t totalSectors;
  uint32_t volumeStartSector = 0;
  m_blockDev = dev;
    6b76:	str	r1, [r4, #0]
  return state.free_count;
}


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    6b78:	sub	sp, #28
  MbrSector_t* mbr;
  MbrPart_t* mp;
  #endif

  uint8_t tmp;
  m_fatType = 0;
    6b7a:	strb	r7, [r0, #7]
  m_allocSearchStart = 1;
    6b7c:	str	r6, [r0, #12]
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    6b7e:	str	r1, [r4, #44]	; 0x2c
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    6b80:	str	r3, [r0, #52]	; 0x34
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6b82:	strb.w	r7, [r0, #40]	; 0x28
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this cache.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    6b86:	str.w	r1, [r4, #572]	; 0x23c
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_sector = 0XFFFFFFFF;
    6b8a:	str.w	r3, [r0, #580]	; 0x244
    m_blockDev = blockDev;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    6b8e:	strb.w	r7, [r0, #568]	; 0x238
    6b92:	mov	r0, r8
  return state.free_count;
}


//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    6b94:	mov	r5, r1
    6b96:	mov	r9, r2
    6b98:	bl	695c <FsCache::clear()>
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.init(dev);
#endif  // USE_SEPARATE_FAT_CACHE

  #if SUPPORT_GPT_AND_EXTENDED_PATITIONS 
  FsGetPartitionInfo::voltype_t vt = FsGetPartitionInfo::getPartitionInfo(m_blockDev, part, cacheClear(), &firstLBA);
    6b9c:	str	r7, [sp, #8]
    6b9e:	mov	r2, r0
    6ba0:	str	r7, [sp, #4]
    6ba2:	str	r7, [sp, #0]
    6ba4:	add	r3, sp, #20
    6ba6:	mov	r1, r9
    6ba8:	mov	r0, r5
    6baa:	bl	34e0 <FsGetPartitionInfo::getPartitionInfo(BlockDeviceInterface*, unsigned char, unsigned char*, unsigned long*, unsigned long*, unsigned long*, unsigned char*)>
  if ((vt == FsGetPartitionInfo::INVALID_VOL) || (vt == FsGetPartitionInfo::OTHER_VOL)) {
    6bae:	tst.w	r0, #251	; 0xfb
    6bb2:	beq.n	6c38 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    DBG_FAIL_MACRO;
    goto fail;    
  }
  volumeStartSector = firstLBA;
    6bb4:	ldr	r5, [sp, #20]
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return reinterpret_cast<cache_t*>(m_cache.get(sector, options));
    6bb6:	mov	r2, r7
    6bb8:	mov	r1, r5
    6bba:	mov	r0, r8
    6bbc:	bl	376a <FsCache::get(unsigned long, unsigned char)>
  #endif

  pbs = reinterpret_cast<pbs_t*>
        (cacheFetchData(volumeStartSector, FsCache::CACHE_FOR_READ));
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    6bc0:	cmp	r0, #0
    6bc2:	beq.n	6c38 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    6bc4:	ldrb	r3, [r0, #16]
    6bc6:	cmp	r3, #2
    6bc8:	bne.n	6c38 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    6bca:	ldrh.w	r3, [r0, #11]
    6bce:	cmp.w	r3, #512	; 0x200
    6bd2:	bne.n	6c38 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    6bd4:	b.n	6c3c <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd8>
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    if (tmp == 0) {
    6bd6:	subs	r2, #1
    6bd8:	beq.n	6c38 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
    6bda:	ldrb	r6, [r4, #6]
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    6bdc:	lsls	r3, r3, #1
    if (tmp == 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
    6bde:	adds	r6, #1
    6be0:	strb	r6, [r4, #6]
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    6be2:	uxtb	r3, r3
    6be4:	cmp	r3, r1
    6be6:	bne.n	6bd6 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x72>
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_sectorsPerClusterShift++;
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
    6be8:	ldrh	r3, [r0, #22]
    6bea:	str	r3, [r4, #16]
  if (m_sectorsPerFat == 0) {
    6bec:	cbnz	r3, 6bf2 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x8e>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    6bee:	ldr	r3, [r0, #36]	; 0x24
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
    6bf0:	str	r3, [r4, #16]
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    6bf2:	ldrh	r1, [r0, #14]
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    6bf4:	ldrh.w	r2, [r0, #17]

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    6bf8:	ldr	r6, [r4, #16]
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);
    6bfa:	strh	r2, [r4, #8]
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    6bfc:	add	r1, r5

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    6bfe:	add.w	r3, r1, r6, lsl #1
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    6c02:	str	r1, [r4, #24]
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    6c04:	lsls	r1, r2, #5
    6c06:	addw	r1, r1, #511	; 0x1ff
    6c0a:	add.w	r1, r3, r1, asr #9

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    6c0e:	str	r3, [r4, #32]
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
    6c10:	ldrh.w	r3, [r0, #19]

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);
    6c14:	str	r1, [r4, #20]

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
  if (totalSectors == 0) {
    6c16:	cbnz	r3, 6c1a <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xb6>
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    6c18:	ldr	r3, [r0, #32]
    totalSectors = getLe32(bpb->totalSectors32);
  }
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);
    6c1a:	subs	r1, r5, r1
    6c1c:	add	r1, r3

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
    6c1e:	ldrb	r3, [r4, #6]
    6c20:	lsrs	r1, r3
  m_lastCluster = clusterCount + 1;
    6c22:	adds	r3, r1, #1
    6c24:	str	r3, [r4, #28]
    return m_blockDev->writeSector(sector, src);
  }
#if MAINTAIN_FREE_CLUSTER_COUNT
  int32_t  m_freeClusterCount;     // Count of free clusters in volume.
  void setFreeClusterCount(int32_t value) {
    m_freeClusterCount = value;
    6c26:	mov.w	r3, #4294967295
    6c2a:	str	r3, [r4, #36]	; 0x24

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    6c2c:	movw	r3, #4084	; 0xff4
    6c30:	cmp	r1, r3
    6c32:	bhi.n	6c4c <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xe8>
    m_fatType = 12;
    6c34:	movs	r3, #12
    6c36:	strb	r3, [r4, #7]
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;

 fail:
  return false;
    6c38:	movs	r0, #0
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    6c3a:	b.n	6c66 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x102>
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
    6c3c:	ldrb	r1, [r0, #13]
    6c3e:	strb	r1, [r4, #4]
  m_clusterSectorMask = m_sectorsPerCluster - 1;
    6c40:	subs	r3, r1, #1
    6c42:	strb	r3, [r4, #5]
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
    6c44:	strb	r7, [r4, #6]
    6c46:	movs	r2, #9
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    6c48:	mov	r3, r6
    6c4a:	b.n	6be4 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x80>
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    6c4c:	movw	r3, #65524	; 0xfff4
    6c50:	cmp	r1, r3
    6c52:	ittet	hi
    6c54:	ldrhi	r3, [r0, #44]	; 0x2c
    m_fatType = 16;
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    6c56:	strhi	r3, [r4, #32]
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    m_fatType = 16;
    6c58:	movls	r3, #16
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    m_fatType = 32;
    6c5a:	movhi	r3, #32
    6c5c:	strb	r3, [r4, #7]
  }
  /** Set the offset to the second FAT for mirroring.
   * \param[in] offset Sector offset to second FAT.
   */
  void setMirrorOffset(uint32_t offset) {
    m_mirrorOffset = offset;
    6c5e:	str	r6, [r4, #48]	; 0x30
    6c60:	str.w	r6, [r4, #576]	; 0x240
  }
  m_cache.setMirrorOffset(m_sectorsPerFat);
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.setMirrorOffset(m_sectorsPerFat);
#endif  // USE_SEPARATE_FAT_CACHE
  return true;
    6c64:	movs	r0, #1

 fail:
  return false;
}
    6c66:	add	sp, #28
    6c68:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00006c6c <FatVolume::chdir(char const*)>:
#define DBG_FILE "FatVolume.cpp"
#include "../common/DebugMacros.h"
#include "FatVolume.h"
FatVolume* FatVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FatVolume::chdir(const char *path) {
    6c6c:	push	{r4, r5, r6, lr}
#endif  // ENABLE_ARDUINO_STRING

 private:
  friend FatFile;
  static FatVolume* cwv() {return m_cwv;}
  FatFile* vwd() {return &m_vwd;}
    6c6e:	add.w	r4, r0, #1096	; 0x448
    6c72:	sub	sp, #40	; 0x28
    6c74:	movs	r3, #0
  FatFile dir;
  if (!dir.open(vwd(), path, O_RDONLY)) {
    6c76:	mov	r2, r1
    6c78:	add	r0, sp, #4
    6c7a:	mov	r1, r4
    6c7c:	strb.w	r3, [sp, #4]
    6c80:	strb.w	r3, [sp, #5]
    6c84:	strb.w	r3, [sp, #6]
    6c88:	bl	61c8 <FatFile::open(FatFile*, char const*, int)>
    6c8c:	mov	r6, r0
    6c8e:	cbz	r0, 6cac <FatVolume::chdir(char const*)+0x40>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!dir.isDir()) {
    6c90:	ldrb.w	r3, [sp, #4]
    6c94:	ands.w	r3, r3, #112	; 0x70
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_vwd = dir;
    6c98:	itttt	ne
    6c9a:	addne	r5, sp, #4
    6c9c:	ldmiane	r5!, {r0, r1, r2, r3}
    6c9e:	stmiane	r4!, {r0, r1, r2, r3}
    6ca0:	ldmiane	r5!, {r0, r1, r2, r3}
    6ca2:	ittte	ne
    6ca4:	stmiane	r4!, {r0, r1, r2, r3}
    6ca6:	ldrne	r3, [r5, #0]
    6ca8:	strne	r3, [r4, #0]
  return true;

 fail:
  return false;
    6caa:	moveq	r6, r3
}
    6cac:	mov	r0, r6
    6cae:	add	sp, #40	; 0x28
    6cb0:	pop	{r4, r5, r6, pc}

00006cb2 <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>:
  }
  DirFat_t* cacheDirEntry(uint8_t action);
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    6cb2:	subs	r1, r0, #1
    6cb4:	add.w	r2, r0, #10
    uint8_t sum = 0;
    6cb8:	movs	r0, #0
    6cba:	lsls	r3, r0, #7
    6cbc:	orr.w	r0, r3, r0, lsr #1
    for (uint8_t i = 0; i < 11; i++) {
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    6cc0:	ldrb.w	r3, [r1, #1]!
    6cc4:	uxtab	r0, r3, r0
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    6cc8:	cmp	r1, r2
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    6cca:	uxtb	r0, r0
  bool cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  bool createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd);
  uint16_t getLfnChar(DirLfn_t* ldir, uint8_t i);
  uint8_t lfnChecksum(uint8_t* name) {
    uint8_t sum = 0;
    for (uint8_t i = 0; i < 11; i++) {
    6ccc:	bne.n	6cba <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]+0x8>
        sum = (((sum & 1) << 7) | (sum >> 1)) + name[i];
    }
    return sum;
  }
    6cce:	bx	lr

00006cd0 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)>:
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6cd0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  FatFile dir = *this;
    6cd4:	mov	r5, r0
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6cd6:	mov	r6, r2
    6cd8:	mov	r7, r0
    6cda:	mov	r8, r1
    6cdc:	mov	r9, r3
  FatFile dir = *this;
    6cde:	ldmia	r5!, {r0, r1, r2, r3}
    hash = ((hash << 5) + hash) ^ (*bgn++);
  }
  return hash;
}
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6ce0:	sub	sp, #52	; 0x34
  FatFile dir = *this;
    6ce2:	add	r4, sp, #12
    6ce4:	stmia	r4!, {r0, r1, r2, r3}
    6ce6:	ldmia	r5!, {r0, r1, r2, r3}
    6ce8:	stmia	r4!, {r0, r1, r2, r3}
    6cea:	ldr	r3, [r5, #0]
    6cec:	str	r3, [r4, #0]
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
  }
  void reset() {
    next = begin;
    6cee:	ldr	r3, [r6, #0]
    6cf0:	str	r3, [r6, #4]
    ls = 0;
    6cf2:	movs	r3, #0
    6cf4:	strh	r3, [r6, #12]
  DirLfn_t* ldir;
  fname->reset();
  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6cf6:	movs	r5, #1
    6cf8:	cmp	r5, r9
    6cfa:	bhi.n	6d36 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x66>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(index - order));
    6cfc:	rsb	r1, r5, r8
    6d00:	uxth	r1, r1
    6d02:	add	r0, sp, #12
    6d04:	bl	59e4 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    6d08:	mov	fp, r0
    6d0a:	cbnz	r0, 6d10 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x40>
    }
  }
  return true;

 fail:
  return false;
    6d0c:	movs	r0, #0
    6d0e:	b.n	6d66 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
    6d10:	mov.w	sl, #0
    }
    // These should be checked in caller.
    DBG_HALT_IF(ldir->attributes != FAT_ATTRIB_LONG_NAME);
    DBG_HALT_IF(order != (ldir->order & 0X1F));
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t u = getLfnChar(ldir, i);
    6d14:	uxtb.w	r2, sl
    6d18:	mov	r1, fp
    6d1a:	mov	r0, r7
    6d1c:	bl	59fe <FatFile::getLfnChar(DirLfn_t*, unsigned char)>
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    6d20:	ldrh	r3, [r6, #12]
    6d22:	mov	r4, r0
    6d24:	cbnz	r3, 6d3a <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x6a>
    6d26:	ldr	r2, [r6, #4]
    6d28:	ldr	r3, [r6, #8]
    6d2a:	cmp	r2, r3
    6d2c:	bne.n	6d3a <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x6a>
      if (fname->atEnd()) {
        return u == 0;
    6d2e:	clz	r0, r0
    6d32:	lsrs	r0, r0, #5
    6d34:	b.n	6d66 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
        return false;
      }
#endif  // USE_UTF8_LONG_NAMES
    }
  }
  return true;
    6d36:	movs	r0, #1
    6d38:	b.n	6d66 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x96>
      uint16_t u = getLfnChar(ldir, i);
      if (fname->atEnd()) {
        return u == 0;
      }
#if USE_UTF8_LONG_NAMES
      uint16_t cp = fname->get16();
    6d3a:	mov	r0, r6
    6d3c:	bl	385c <FsName::get16()>
    6d40:	str	r0, [sp, #4]
      // Make sure caller checked for valid UTF-8.
      DBG_HALT_IF(cp == 0XFFFF);
      if (toUpcase(u) != toUpcase(cp)) {
    6d42:	mov	r0, r4
    6d44:	bl	37b8 <toUpcase(unsigned short)>
    6d48:	ldr	r3, [sp, #4]
    6d4a:	mov	r4, r0
    6d4c:	mov	r0, r3
    6d4e:	bl	37b8 <toUpcase(unsigned short)>
    6d52:	cmp	r4, r0
    6d54:	bne.n	6d0c <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x3c>
    6d56:	add.w	sl, sl, #1
      goto fail;
    }
    // These should be checked in caller.
    DBG_HALT_IF(ldir->attributes != FAT_ATTRIB_LONG_NAME);
    DBG_HALT_IF(order != (ldir->order & 0X1F));
    for (uint8_t i = 0; i < 13; i++) {
    6d5a:	cmp.w	sl, #13
    6d5e:	bne.n	6d14 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x44>
//==============================================================================
bool FatFile::cmpName(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
  FatFile dir = *this;
  DirLfn_t* ldir;
  fname->reset();
  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6d60:	adds	r5, #1
    6d62:	uxtb	r5, r5
    6d64:	b.n	6cf8 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)+0x28>
  }
  return true;

 fail:
  return false;
}
    6d66:	add	sp, #52	; 0x34
    6d68:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00006d6c <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)>:
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6d6c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  FatFile dir = *this;
    6d70:	mov	r5, r0

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6d72:	mov	r6, r2
    6d74:	mov	sl, r1
    6d76:	mov	r7, r3
  FatFile dir = *this;
    6d78:	ldmia	r5!, {r0, r1, r2, r3}

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::createLFN(uint16_t index, FatName_t* fname, uint8_t lfnOrd) {
    6d7a:	sub	sp, #52	; 0x34
  FatFile dir = *this;
    6d7c:	add	r4, sp, #12
    6d7e:	stmia	r4!, {r0, r1, r2, r3}
    6d80:	ldmia	r5!, {r0, r1, r2, r3}
    6d82:	stmia	r4!, {r0, r1, r2, r3}
    6d84:	ldr	r3, [r5, #0]
    6d86:	str	r3, [r4, #0]
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
    6d88:	add.w	r0, r6, #22
    6d8c:	bl	6cb2 <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>
  }
  void reset() {
    next = begin;
    ls = 0;
    6d90:	movs	r5, #0
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
  }
  void reset() {
    next = begin;
    6d92:	ldr	r3, [r6, #0]
    6d94:	str	r3, [r6, #4]
    6d96:	mov	r9, r0
    ls = 0;
    6d98:	strh	r5, [r6, #12]
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6d9a:	mov.w	fp, #1
      goto fail;
    }
    dir.m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    6d9e:	mov	r8, r5
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6da0:	cmp	fp, r7
    6da2:	bhi.n	6df2 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x86>
    ldir = reinterpret_cast<DirLfn_t*>(dir.cacheDir(index - order));
    6da4:	rsb	r1, fp, sl
    6da8:	uxth	r1, r1
    6daa:	add	r0, sp, #12
    6dac:	bl	59e4 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    6db0:	cmp	r0, #0
    6db2:	beq.n	6e3a <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xce>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dir.m_vol->cacheDirty();
    6db4:	ldr	r2, [sp, #20]
    invalidate();
    return m_buffer;
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    6db6:	ldrb.w	r3, [r2, #40]	; 0x28
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    6dba:	cmp	fp, r7
    6dbc:	orr.w	r3, r3, #1
    6dc0:	strb.w	r3, [r2, #40]	; 0x28
    6dc4:	ite	eq
    6dc6:	orreq.w	r3, fp, #64	; 0x40
    6dca:	movne	r3, fp
    6dcc:	strb	r3, [r0, #0]
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    6dce:	mov.w	r3, #15
    6dd2:	strb	r3, [r0, #11]
    ldir->mustBeZero1 = 0;
    6dd4:	strb.w	r8, [r0, #12]
    ldir->checksum = checksum;
    6dd8:	strb.w	r9, [r0, #13]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    6ddc:	strh.w	r8, [r0, #26]
    6de0:	adds	r4, r0, #4
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
    6de2:	movs	r1, #0
  /** \return next UTF-16 unit of LFN. */
  uint16_t get16() {return atEnd() ? 0 : *next++;}
#else  // !USE_UTF8_LONG_NAMES
  uint16_t ls = 0;
  bool atEnd() {
    return !ls && next == end;
    6de4:	ldrh	r3, [r6, #12]
    6de6:	cbnz	r3, 6df6 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x8a>
    6de8:	ldr	r2, [r6, #4]
    6dea:	ldr	r3, [r6, #8]
    6dec:	cmp	r2, r3
    6dee:	bne.n	6df6 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x8a>
    6df0:	b.n	6e28 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xbc>
        DBG_HALT_IF(cp == 0XFFFF);
      }
      putLfnChar(ldir, i, cp);
    }
  }
  return true;
    6df2:	movs	r0, #1
    6df4:	b.n	6e3a <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xce>
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t cp;
      if (fname->atEnd()) {
        cp = fc++ ? 0XFFFF : 0;
      } else {
        cp = fname->get16();
    6df6:	mov	r0, r6
    6df8:	str	r1, [sp, #4]
    6dfa:	bl	385c <FsName::get16()>
    6dfe:	ldr	r1, [sp, #4]
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c The 16-bit character.
 */
static void putLfnChar(DirLfn_t* ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    6e00:	cmp	r1, #4
    6e02:	bhi.n	6e0a <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x9e>
    6e04:	strh.w	r0, [r4, #-3]
    6e08:	b.n	6e12 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xa6>
    setLe16(ldir->unicode1 + 2*i, c);
  } else if (i < 11) {
    6e0a:	cmp	r1, #10
    6e0c:	ite	ls
    6e0e:	strhls	r0, [r4, #0]
    6e10:	strhhi	r0, [r4, #2]
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    ldir->checksum = checksum;
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
    6e12:	adds	r1, #1
    6e14:	uxtb	r1, r1
    6e16:	cmp	r1, #13
    6e18:	add.w	r4, r4, #2
    6e1c:	bne.n	6de4 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x78>
  DirLfn_t* ldir;
  uint8_t checksum = lfnChecksum(fname->sfn);
  uint8_t fc = 0;
  fname->reset();

  for (uint8_t order = 1; order <= lfnOrd; order++) {
    6e1e:	add.w	fp, fp, #1
    6e22:	uxtb.w	fp, fp
    6e26:	b.n	6da0 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x34>
    ldir->checksum = checksum;
    setLe16(ldir->mustBeZero2, 0);
    for (uint8_t i = 0; i < 13; i++) {
      uint16_t cp;
      if (fname->atEnd()) {
        cp = fc++ ? 0XFFFF : 0;
    6e28:	cbz	r5, 6e34 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0xc8>
    6e2a:	adds	r5, #1
    6e2c:	uxtb	r5, r5
    6e2e:	movw	r0, #65535	; 0xffff
    6e32:	b.n	6e00 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x94>
    6e34:	mov	r0, r5
    6e36:	movs	r5, #1
    6e38:	b.n	6e00 <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)+0x94>
  }
  return true;

 fail:
  return false;
}
    6e3a:	add	sp, #52	; 0x34
    6e3c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00006e40 <FatFile::makeSFN(FatName_t*)>:
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
  const char* ptr = fname->begin;
    6e40:	mov	r2, r0

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::makeSFN(FatName_t* fname) {
    6e42:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
  const char* ptr = fname->begin;
    6e46:	ldr.w	r3, [r2], #21
  uint8_t lc = 0;
  uint8_t uc = 0;
  uint8_t i = 0;
  uint8_t in = 7;
  const char* dot;
  const char* end = fname->end;
    6e4a:	ldr	r7, [r0, #8]
    6e4c:	add.w	r1, r0, #32
  // Assume blanks removed from start and end.
  DBG_HALT_IF(*ptr == ' ' || *(end - 1) == ' ' || *(end - 1) == '.');

  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    fname->sfn[k] = ' ';
    6e50:	movs	r4, #32
    6e52:	strb.w	r4, [r2, #1]!
  DBG_HALT_IF(end == ptr);
  // Assume blanks removed from start and end.
  DBG_HALT_IF(*ptr == ' ' || *(end - 1) == ' ' || *(end - 1) == '.');

  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    6e56:	cmp	r1, r2
    6e58:	bne.n	6e52 <FatFile::makeSFN(FatName_t*)+0x12>
    fname->sfn[k] = ' ';
  }
  // Not 8.3 if starts with dot.
  is83 = *ptr == '.' ? false : true;
    6e5a:	ldrb	r6, [r3, #0]
    6e5c:	subs	r6, #46	; 0x2e
    6e5e:	it	ne
    6e60:	movne	r6, #1
    6e62:	mov	r5, r3
    6e64:	adds	r3, #1
  // Skip leading dots.
  for (; *ptr == '.'; ptr++) {}
    6e66:	ldrb	r2, [r5, #0]
    6e68:	cmp	r2, #46	; 0x2e
    6e6a:	beq.n	6e62 <FatFile::makeSFN(FatName_t*)+0x22>
    6e6c:	subs	r3, r7, #1
  // Find last dot.
  for (dot = end - 1; dot > ptr && *dot != '.'; dot--) {}
    6e6e:	cmp	r3, r5
    6e70:	mov	lr, r3
    6e72:	bhi.n	6e84 <FatFile::makeSFN(FatName_t*)+0x44>
    6e74:	movs	r2, #0
    6e76:	mov.w	ip, #7
    6e7a:	mov	r1, r2
    6e7c:	mov	r8, r2
    6e7e:	mov.w	r9, #8
    6e82:	b.n	6ea8 <FatFile::makeSFN(FatName_t*)+0x68>
    6e84:	ldrb.w	r2, [lr]
    6e88:	cmp	r2, #46	; 0x2e
    6e8a:	add.w	r3, r3, #4294967295
    6e8e:	bne.n	6e6e <FatFile::makeSFN(FatName_t*)+0x2e>
    6e90:	b.n	6e74 <FatFile::makeSFN(FatName_t*)+0x34>

  for (; ptr < end; ptr++) {
    c = *ptr;
    6e92:	ldrb	r3, [r5, #0]
//  Could skip UTF-8 units where (0XC0 & c) == 0X80

    if (c == '.' && ptr == dot) {
    6e94:	cmp	r3, #46	; 0x2e
    6e96:	bne.n	6eae <FatFile::makeSFN(FatName_t*)+0x6e>
    6e98:	cmp	lr, r5
    6e9a:	bne.n	6eb6 <FatFile::makeSFN(FatName_t*)+0x76>
      in = 10;  // Max index for full 8.3 name.
    6e9c:	mov.w	ip, #10
      i = 8;    // Place for extension.
    6ea0:	movs	r1, #8
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    6ea2:	mov.w	r9, #16
  // Skip leading dots.
  for (; *ptr == '.'; ptr++) {}
  // Find last dot.
  for (dot = end - 1; dot > ptr && *dot != '.'; dot--) {}

  for (; ptr < end; ptr++) {
    6ea6:	adds	r5, #1
    6ea8:	cmp	r5, r7
    6eaa:	bcc.n	6e92 <FatFile::makeSFN(FatName_t*)+0x52>
    6eac:	b.n	6f38 <FatFile::makeSFN(FatName_t*)+0xf8>
  /** Check for a legal 8.3 character.
   * \param[in] c Character to be checked.
   * \return true for a legal 8.3 character.
   */
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
    6eae:	cmp	r3, #34	; 0x22
    6eb0:	beq.n	6eda <FatFile::makeSFN(FatName_t*)+0x9a>
    6eb2:	cmp	r3, #124	; 0x7c
    6eb4:	beq.n	6eda <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
    6eb6:	sub.w	r4, r3, #42	; 0x2a
    6eba:	cmp	r4, #5
    6ebc:	bhi.n	6ec2 <FatFile::makeSFN(FatName_t*)+0x82>
    6ebe:	cmp	r3, #45	; 0x2d
    6ec0:	bne.n	6eda <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // :;<=>?
    if (0X3A <= c && c <= 0X3F) {
    6ec2:	sub.w	r4, r3, #58	; 0x3a
    6ec6:	cmp	r4, #5
    6ec8:	bls.n	6eda <FatFile::makeSFN(FatName_t*)+0x9a>
      return false;
    }
    // [\]
    if (0X5B <= c && c <= 0X5D) {
    6eca:	sub.w	r4, r3, #91	; 0x5b
    6ece:	cmp	r4, #2
    6ed0:	bls.n	6eda <FatFile::makeSFN(FatName_t*)+0x9a>
    if (c == '.' && ptr == dot) {
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
    6ed2:	sub.w	r4, r3, #33	; 0x21
    6ed6:	cmp	r4, #93	; 0x5d
    6ed8:	bls.n	6ee4 <FatFile::makeSFN(FatName_t*)+0xa4>
        is83 = false;
        // Skip UTF-8 trailing characters.
        if ((c & 0XC0) == 0X80) {
    6eda:	and.w	r3, r3, #192	; 0xc0
    6ede:	cmp	r3, #128	; 0x80
    6ee0:	bne.n	6f0a <FatFile::makeSFN(FatName_t*)+0xca>
    6ee2:	b.n	6f2e <FatFile::makeSFN(FatName_t*)+0xee>
          continue;
        }
        c = '_';
      }
      if (i > in) {
    6ee4:	cmp	r1, ip
    6ee6:	bls.n	6ef8 <FatFile::makeSFN(FatName_t*)+0xb8>
        is83 = false;
        if (in == 10 || ptr > dot) {
    6ee8:	cmp.w	ip, #10
    6eec:	beq.n	6f36 <FatFile::makeSFN(FatName_t*)+0xf6>
    6eee:	cmp	lr, r5
    6ef0:	bcc.n	6f36 <FatFile::makeSFN(FatName_t*)+0xf6>
         // Done - extension longer than three characters or no extension.
          break;
        }
        // Skip to dot.
        ptr = dot - 1;
    6ef2:	add.w	r5, lr, #4294967295
    6ef6:	b.n	6f2e <FatFile::makeSFN(FatName_t*)+0xee>
        continue;
      }
      if (isLower(c)) {
    6ef8:	sub.w	r4, r3, #97	; 0x61
    6efc:	cmp	r4, #25
    6efe:	bhi.n	6f12 <FatFile::makeSFN(FatName_t*)+0xd2>
        c += 'A' - 'a';
    6f00:	subs	r3, #32
    6f02:	uxtb	r3, r3
        lc |= bit;
    6f04:	orr.w	r2, r9, r2
    6f08:	b.n	6f1e <FatFile::makeSFN(FatName_t*)+0xde>
        if ((c & 0XC0) == 0X80) {
          continue;
        }
        c = '_';
      }
      if (i > in) {
    6f0a:	cmp	r1, ip
    6f0c:	bhi.n	6ee8 <FatFile::makeSFN(FatName_t*)+0xa8>
        is83 = false;
        // Skip UTF-8 trailing characters.
        if ((c & 0XC0) == 0X80) {
          continue;
        }
        c = '_';
    6f0e:	movs	r3, #95	; 0x5f
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
        is83 = false;
    6f10:	movs	r6, #0
        continue;
      }
      if (isLower(c)) {
        c += 'A' - 'a';
        lc |= bit;
      } else if (isUpper(c)) {
    6f12:	sub.w	r4, r3, #65	; 0x41
    6f16:	cmp	r4, #25
        uc |= bit;
    6f18:	it	ls
    6f1a:	orrls.w	r8, r9, r8
      }
      fname->sfn[i++] = c;
    6f1e:	adds	r4, r1, #1
    6f20:	uxtb	r4, r4
    6f22:	add	r1, r0
      if (i < 7) {
    6f24:	cmp	r4, #6
        c += 'A' - 'a';
        lc |= bit;
      } else if (isUpper(c)) {
        uc |= bit;
      }
      fname->sfn[i++] = c;
    6f26:	strb	r3, [r1, #22]
      if (i < 7) {
    6f28:	bhi.n	6f32 <FatFile::makeSFN(FatName_t*)+0xf2>
        fname->seqPos = i;
    6f2a:	strb	r4, [r0, #20]
    6f2c:	b.n	6f32 <FatFile::makeSFN(FatName_t*)+0xf2>
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if (!legal83Char(c)) {
        is83 = false;
    6f2e:	movs	r6, #0
    6f30:	b.n	6ea6 <FatFile::makeSFN(FatName_t*)+0x66>
    6f32:	mov	r1, r4
    6f34:	b.n	6ea6 <FatFile::makeSFN(FatName_t*)+0x66>
          continue;
        }
        c = '_';
      }
      if (i > in) {
        is83 = false;
    6f36:	movs	r6, #0
      if (i < 7) {
        fname->seqPos = i;
      }
    }
  }
  if (fname->sfn[0] == ' ') {
    6f38:	ldrb	r3, [r0, #22]
    6f3a:	cmp	r3, #32
    6f3c:	beq.n	6f62 <FatFile::makeSFN(FatName_t*)+0x122>
    DBG_HALT_MACRO;
    goto fail;
  }
  if (is83) {
    6f3e:	cbz	r6, 6f50 <FatFile::makeSFN(FatName_t*)+0x110>
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
    6f40:	tst.w	r8, r2
    6f44:	it	ne
    6f46:	movne	r2, #2
    6f48:	strb	r2, [r0, #21]
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
    6f4a:	movs	r0, #1
    6f4c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  }
  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    6f50:	ldrb	r2, [r0, #20]
    goto fail;
  }
  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    6f52:	movs	r3, #1
    6f54:	strb	r3, [r0, #21]
    fname->sfn[fname->seqPos] = '~';
    6f56:	add	r0, r2
    6f58:	movs	r2, #126	; 0x7e
    6f5a:	strb	r2, [r0, #22]
    fname->sfn[fname->seqPos + 1] = '1';
    6f5c:	movs	r2, #49	; 0x31
    6f5e:	strb	r2, [r0, #23]
    6f60:	b.n	6f4a <FatFile::makeSFN(FatName_t*)+0x10a>
  }
  return true;

 fail:
  return false;
    6f62:	movs	r0, #0
    6f64:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00006f68 <FatFile::makeUniqueSfn(FatName_t*)>:
}
//------------------------------------------------------------------------------
bool FatFile::makeUniqueSfn(FatName_t* fname) {
    6f68:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;
    6f6c:	ldrb	r5, [r1, #20]

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::makeUniqueSfn(FatName_t* fname) {
    6f6e:	mov	r7, r0
    6f70:	mov	r6, r1
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;
    6f72:	movs	r4, #98	; 0x62
    for (uint8_t i = pos + 4 ; i > pos; i--) {
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
      hex >>= 4;
    }
    fname->sfn[pos] = '~';
    6f74:	mov.w	r8, #126	; 0x7e
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    6f78:	add.w	r9, r1, #22
  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
     DBG_WARN_IF(seq > FIRST_HASH_SEQ);
#ifdef USE_LFN_HASH
    hex = Bernstein(fname->begin, fname->end, seq);
#else
    hex = micros();
    6f7c:	bl	9418 <micros>
    6f80:	cmp	r5, #3
    6f82:	it	cs
    6f84:	movcs	r5, #3
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    6f86:	adds	r3, r5, #4
  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
     DBG_WARN_IF(seq > FIRST_HASH_SEQ);
#ifdef USE_LFN_HASH
    hex = Bernstein(fname->begin, fname->end, seq);
#else
    hex = micros();
    6f88:	uxth	r0, r0
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    6f8a:	uxtb	r3, r3
      uint8_t h = hex & 0XF;
    6f8c:	and.w	r2, r0, #15
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    6f90:	adds	r1, r6, r3
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    6f92:	subs	r3, #1
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    6f94:	cmp	r2, #9
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    6f96:	uxtb	r3, r3
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    6f98:	ite	ls
    6f9a:	addls	r2, #48	; 0x30
    6f9c:	addhi	r2, #55	; 0x37
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    6f9e:	cmp	r5, r3
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    6fa0:	strb	r2, [r1, #22]
      hex >>= 4;
    6fa2:	mov.w	r0, r0, lsr #4
#endif
    if (pos > 3) {
      // Make space in name for ~HHHH.
      pos = 3;
    }
    for (uint8_t i = pos + 4 ; i > pos; i--) {
    6fa6:	bcc.n	6f8c <FatFile::makeUniqueSfn(FatName_t*)+0x24>
      uint8_t h = hex & 0XF;
      fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
      hex >>= 4;
    }
    fname->sfn[pos] = '~';
    6fa8:	adds	r3, r6, r5
   * \return true for success or false for failure.
   */
  bool rename(FatFile* dirFile, const char* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    6faa:	movs	r1, #0
    6fac:	strb.w	r8, [r3, #22]
    6fb0:	mov	r0, r7
    6fb2:	bl	5ee2 <FatFile::seekSet(unsigned long)>
    rewind();
    while (1) {
      dir = readDirCache(true);
    6fb6:	movs	r1, #1
    6fb8:	mov	r0, r7
    6fba:	bl	5ea8 <FatFile::readDirCache(bool)>
      if (!dir) {
    6fbe:	mov	r1, r0
    6fc0:	cbnz	r0, 6fce <FatFile::makeUniqueSfn(FatName_t*)+0x66>
        if (!getError()) {
    6fc2:	ldrb	r0, [r7, #1]
    6fc4:	clz	r0, r0
    6fc8:	lsrs	r0, r0, #5
    6fca:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    6fce:	ldrb	r3, [r0, #0]
    6fd0:	cbz	r3, 6fe6 <FatFile::makeUniqueSfn(FatName_t*)+0x7e>
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    6fd2:	ldrb	r3, [r0, #11]
    6fd4:	lsls	r3, r3, #28
    6fd6:	bmi.n	6fb6 <FatFile::makeUniqueSfn(FatName_t*)+0x4e>
    6fd8:	movs	r2, #11
    6fda:	mov	r0, r9
    6fdc:	bl	b880 <memcmp>
    6fe0:	cmp	r0, #0
    6fe2:	bne.n	6fb6 <FatFile::makeUniqueSfn(FatName_t*)+0x4e>
    6fe4:	b.n	6fec <FatFile::makeUniqueSfn(FatName_t*)+0x84>

 fail:
  return false;

 done:
  return true;
    6fe6:	movs	r0, #1
    6fe8:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6fec:	subs	r0, r4, #1
  uint16_t hex;

  DBG_HALT_IF(!(fname->flags & FNAME_FLAG_LOST_CHARS));
  DBG_HALT_IF(fname->sfn[pos] != '~' && fname->sfn[pos + 1] != '1');

  for (uint8_t seq = FIRST_HASH_SEQ; seq < 100; seq++) {
    6fee:	ands.w	r4, r0, #255	; 0xff
    6ff2:	bne.n	6f7c <FatFile::makeUniqueSfn(FatName_t*)+0x14>
  }
  // fall inti fail - too many tries.
  DBG_FAIL_MACRO;

 fail:
  return false;
    6ff4:	mov	r0, r4
    6ff6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6ffa:	Address 0x00006ffa is out of bounds.


00006ffc <FatFile::open(FatFile*, FatName_t*, int)>:

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    6ffc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7000:	sub	sp, #44	; 0x2c
    7002:	mov	r6, r1
    7004:	str	r3, [sp, #12]
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    7006:	ldrb	r3, [r1, #0]

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    7008:	str	r0, [sp, #24]
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    700a:	tst.w	r3, #112	; 0x70

 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
    700e:	mov	sl, r2
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    7010:	bne.n	7016 <FatFile::open(FatFile*, FatName_t*, int)+0x1a>
    goto fail;
  }
  return true;

 fail:
  return false;
    7012:	movs	r0, #0
    7014:	b.n	7240 <FatFile::open(FatFile*, FatName_t*, int)+0x244>
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;

  if (!dirFile->isDir() || isOpen()) {
    7016:	ldr	r3, [sp, #24]
    7018:	ldrb	r3, [r3, #0]
    701a:	cmp	r3, #0
    701c:	bne.n	7012 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
    701e:	ldr	r3, [r2, #16]
    7020:	movs	r2, #13
    7022:	adds	r3, #12
    7024:	udiv	r3, r3, r2
    7028:	uxtb	r3, r3
    702a:	str	r3, [sp, #8]
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
    702c:	ldrb.w	r3, [sl, #21]
    7030:	lsls	r3, r3, #30
    7032:	beq.w	723a <FatFile::open(FatFile*, FatName_t*, int)+0x23e>
    7036:	ldr	r3, [sp, #8]
    7038:	add.w	fp, r3, #1
    703c:	uxtb.w	fp, fp
    7040:	movs	r1, #0
    7042:	mov	r0, r6
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
  uint8_t ms10;
  uint8_t nameOrd;
  uint16_t freeIndex = 0;
    7044:	mov.w	r9, #0
    7048:	bl	5ee2 <FatFile::seekSet(unsigned long)>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    704c:	add.w	r3, sl, #22
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
    7050:	str.w	r9, [sp, #16]
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
    7054:	mov	r8, r9
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
    7056:	mov	r4, r9
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
    7058:	mov	r5, r9
 done:
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, FatName_t* fname, oflag_t oflag) {
  bool fnameFound = false;
    705a:	str.w	r9, [sp, #20]
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    705e:	str	r3, [sp, #28]
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    7060:	ldr	r7, [r6, #20]
    dir = dirFile->readDirCache();
    7062:	movs	r1, #0
    7064:	mov	r0, r6
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    7066:	ubfx	r7, r7, #5, #16
    dir = dirFile->readDirCache();
    706a:	bl	5ea8 <FatFile::readDirCache(bool)>
    if (!dir) {
    706e:	cbnz	r0, 7078 <FatFile::open(FatFile*, FatName_t*, int)+0x7c>
      if (dirFile->getError()) {
    7070:	ldrb	r3, [r6, #1]
    7072:	cmp	r3, #0
    7074:	beq.n	7138 <FatFile::open(FatFile*, FatName_t*, int)+0x13c>
    7076:	b.n	7012 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
        goto fail;
      }
      // At EOF
      goto create;
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
    7078:	ldrb	r3, [r0, #0]
    707a:	cmp	r3, #229	; 0xe5
    707c:	beq.n	7080 <FatFile::open(FatFile*, FatName_t*, int)+0x84>
    707e:	cbnz	r3, 7092 <FatFile::open(FatFile*, FatName_t*, int)+0x96>
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    7080:	cmp	r4, #0
    7082:	it	eq
    7084:	moveq	r9, r7
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
      if (freeFound == 0) {
        freeIndex = curIndex;
      }
      if (freeFound < freeNeed) {
    7086:	cmp	r4, fp
        freeFound++;
    7088:	itt	cc
    708a:	addcc	r4, #1
    708c:	uxtbcc	r4, r4
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    708e:	cbnz	r3, 709a <FatFile::open(FatFile*, FatName_t*, int)+0x9e>
    7090:	b.n	7138 <FatFile::open(FatFile*, FatName_t*, int)+0x13c>
        goto create;
      }
    } else {
      if (freeFound < freeNeed) {
        freeFound = 0;
    7092:	cmp	r4, fp
    7094:	it	cc
    7096:	movcc	r4, #0
    7098:	b.n	70a2 <FatFile::open(FatFile*, FatName_t*, int)+0xa6>
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    709a:	cmp	r3, #229	; 0xe5
    709c:	bne.n	70a2 <FatFile::open(FatFile*, FatName_t*, int)+0xa6>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    709e:	movs	r5, #0
    70a0:	b.n	7060 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
      if (freeFound < freeNeed) {
        freeFound = 0;
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    70a2:	cmp	r3, #46	; 0x2e
    70a4:	beq.n	709e <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
    70a6:	ldrb	r2, [r0, #11]
      lfnOrd = 0;
    } else if (isLongName(dir)) {
    70a8:	cmp	r2, #15
    70aa:	bne.n	70fc <FatFile::open(FatFile*, FatName_t*, int)+0x100>
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
    70ac:	cbnz	r5, 70cc <FatFile::open(FatFile*, FatName_t*, int)+0xd0>
        order = ldir->order & 0X1F;
        if (order != nameOrd ||
    70ae:	ldr	r2, [sp, #8]
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
      lfnOrd = 0;
    } else if (isLongName(dir)) {
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
        order = ldir->order & 0X1F;
    70b0:	and.w	r8, r3, #31
        if (order != nameOrd ||
    70b4:	cmp	r2, r8
    70b6:	bne.n	7060 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
    70b8:	lsls	r1, r3, #25
    70ba:	bmi.n	70c2 <FatFile::open(FatFile*, FatName_t*, int)+0xc6>
    70bc:	ldr.w	r8, [sp, #8]
    70c0:	b.n	7060 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
          (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = nameOrd;
        checksum = ldir->checksum;
    70c2:	ldrb	r3, [r0, #13]
    70c4:	str	r3, [sp, #16]
    70c6:	mov	r8, r2
    70c8:	mov	r5, r2
    70ca:	b.n	70e0 <FatFile::open(FatFile*, FatName_t*, int)+0xe4>
      } else if (ldir->order != --order || checksum != ldir->checksum) {
    70cc:	add.w	r8, r8, #4294967295
    70d0:	uxtb.w	r8, r8
    70d4:	cmp	r3, r8
    70d6:	bne.n	709e <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
    70d8:	ldrb	r3, [r0, #13]
    70da:	ldr	r2, [sp, #16]
    70dc:	cmp	r2, r3
    70de:	bne.n	709e <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
        lfnOrd = 0;
        continue;
      }
      if (order == 1) {
    70e0:	cmp.w	r8, #1
    70e4:	bne.n	7060 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        if (!dirFile->cmpName(curIndex + 1, fname, lfnOrd)) {
    70e6:	adds	r1, r7, #1
    70e8:	mov	r3, r5
    70ea:	mov	r2, sl
    70ec:	uxth	r1, r1
    70ee:	mov	r0, r6
    70f0:	bl	6cd0 <FatFile::cmpName(unsigned short, FatName_t*, unsigned char)>
          lfnOrd = 0;
    70f4:	cmp	r0, #0
    70f6:	it	eq
    70f8:	moveq	r5, #0
    70fa:	b.n	7060 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        }
      }
    } else if (isFileOrSubdir(dir)) {
    70fc:	lsls	r3, r2, #28
    70fe:	bmi.n	709e <FatFile::open(FatFile*, FatName_t*, int)+0xa2>
      if (lfnOrd) {
    7100:	cbz	r5, 7116 <FatFile::open(FatFile*, FatName_t*, int)+0x11a>
        if (1 == order && lfnChecksum(dir->name) == checksum) {
    7102:	cmp.w	r8, #1
    7106:	bne.n	7012 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    7108:	bl	6cb2 <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>
    710c:	ldr	r3, [sp, #16]
    710e:	cmp	r3, r0
    7110:	bne.w	7012 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    7114:	b.n	7130 <FatFile::open(FatFile*, FatName_t*, int)+0x134>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    7116:	movs	r2, #11
    7118:	ldr	r1, [sp, #28]
    711a:	bl	b880 <memcmp>
    711e:	cmp	r0, #0
    7120:	bne.n	7060 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
        if (!(fname->flags & FNAME_FLAG_LOST_CHARS)) {
    7122:	ldrb.w	r3, [sl, #21]
    7126:	lsls	r0, r3, #31
    7128:	bpl.n	7130 <FatFile::open(FatFile*, FatName_t*, int)+0x134>
          goto found;
        }
        fnameFound = true;
    712a:	movs	r3, #1
    712c:	str	r3, [sp, #20]
    712e:	b.n	7060 <FatFile::open(FatFile*, FatName_t*, int)+0x64>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    7130:	ldr	r3, [sp, #12]
    7132:	lsls	r1, r3, #20
    7134:	bpl.n	722a <FatFile::open(FatFile*, FatName_t*, int)+0x22e>
    7136:	b.n	7012 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
  }
  goto open;

 create:
  // don't create unless O_CREAT and write mode
  if (!(oflag & O_CREAT) || !isWriteMode(oflag)) {
    7138:	ldr	r3, [sp, #12]
    713a:	lsls	r2, r3, #22
    713c:	bpl.w	7012 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    7140:	and.w	r3, r3, #3
    7144:	subs	r3, #1
    7146:	cmp	r3, #1
    7148:	bhi.w	7012 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_WARN_MACRO;
    goto fail;
  }
  // Keep found entries or start at current index if no free entries found.
  if (freeFound == 0) {
    714c:	cmp	r4, #0
    714e:	it	eq
    7150:	moveq	r9, r7
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    7152:	cmp	r4, fp
    7154:	bcc.n	715c <FatFile::open(FatFile*, FatName_t*, int)+0x160>
      DBG_FAIL_MACRO;
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
  }
  if (fnameFound) {
    7156:	ldr	r3, [sp, #20]
    7158:	cbnz	r3, 718a <FatFile::open(FatFile*, FatName_t*, int)+0x18e>
    715a:	b.n	7198 <FatFile::open(FatFile*, FatName_t*, int)+0x19c>
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    dir = dirFile->readDirCache();
    715c:	movs	r1, #0
    715e:	mov	r0, r6
    7160:	bl	5ea8 <FatFile::readDirCache(bool)>
    if (!dir) {
    7164:	cbnz	r0, 716c <FatFile::open(FatFile*, FatName_t*, int)+0x170>
      if (dirFile->getError()) {
    7166:	ldrb	r3, [r6, #1]
    7168:	cbz	r3, 717e <FatFile::open(FatFile*, FatName_t*, int)+0x182>
    716a:	b.n	7012 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
        goto fail;
      }
      // EOF if no error.
      break;
    }
    freeFound++;
    716c:	adds	r4, #1
    716e:	uxtb	r4, r4
  // Keep found entries or start at current index if no free entries found.
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    7170:	b.n	7152 <FatFile::open(FatFile*, FatName_t*, int)+0x156>
    7172:	ldr	r3, [r6, #8]
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
    7174:	ldrb	r3, [r3, #4]
    7176:	add	r4, r3
    7178:	uxtb	r4, r4
      // EOF if no error.
      break;
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
    717a:	cmp	fp, r4
    717c:	bls.n	7156 <FatFile::open(FatFile*, FatName_t*, int)+0x15a>
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
    717e:	mov	r0, r6
    7180:	bl	5c00 <FatFile::addDirCluster()>
    7184:	cmp	r0, #0
    7186:	bne.n	7172 <FatFile::open(FatFile*, FatName_t*, int)+0x176>
    7188:	b.n	7012 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
      goto fail;
    }
    freeFound += dirFile->m_vol->sectorsPerCluster();
  }
  if (fnameFound) {
    if (!dirFile->makeUniqueSfn(fname)) {
    718a:	mov	r1, sl
    718c:	mov	r0, r6
    718e:	bl	6f68 <FatFile::makeUniqueSfn(FatName_t*)>
    7192:	cmp	r0, #0
    7194:	beq.w	7012 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
      goto fail;
    }
  }
  lfnOrd = freeNeed - 1;
    7198:	add.w	r5, fp, #4294967295
    719c:	uxtb	r5, r5
  curIndex = freeIndex + lfnOrd;
    719e:	add.w	r7, r9, r5
    71a2:	uxth	r7, r7
  if (!dirFile->createLFN(curIndex, fname, lfnOrd)) {
    71a4:	mov	r3, r5
    71a6:	mov	r2, sl
    71a8:	mov	r1, r7
    71aa:	mov	r0, r6
    71ac:	bl	6d6c <FatFile::createLFN(unsigned short, FatName_t*, unsigned char)>
    71b0:	cmp	r0, #0
    71b2:	beq.w	7012 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    goto fail;
  }
  dir = dirFile->cacheDir(curIndex);
    71b6:	mov	r1, r7
    71b8:	mov	r0, r6
    71ba:	bl	59e4 <FatFile::cacheDir(unsigned short)>
  if (!dir) {
    71be:	mov	r4, r0
    71c0:	cmp	r0, #0
    71c2:	beq.w	7012 <FatFile::open(FatFile*, FatName_t*, int)+0x16>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
    71c6:	movs	r2, #32
    71c8:	movs	r1, #0
    71ca:	bl	8fc0 <memset>
  memcpy(dir->name, fname->sfn, 11);
    71ce:	mov	r3, sl
    71d0:	ldr.w	r2, [r3, #22]!
    71d4:	str	r2, [r4, #0]
    71d6:	ldr	r2, [r3, #4]
    71d8:	str	r2, [r4, #4]
    71da:	ldrh	r2, [r3, #8]
    71dc:	strh	r2, [r4, #8]
    71de:	ldrb	r3, [r3, #10]
    71e0:	strb	r3, [r4, #10]

  // Set base-name and extension lower case bits.
  dir->caseFlags = (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;
    71e2:	ldrb.w	r3, [sl, #21]
    71e6:	and.w	r3, r3, #24
    71ea:	strb	r3, [r4, #12]

  // Set timestamps.
  if (FsDateTime::callback) {
    71ec:	ldr	r3, [pc, #88]	; (7248 <FatFile::open(FatFile*, FatName_t*, int)+0x24c>)
    71ee:	ldr	r3, [r3, #0]
    71f0:	cbz	r3, 7212 <FatFile::open(FatFile*, FatName_t*, int)+0x216>
    // call user date/time function
    FsDateTime::callback(&date, &time, &ms10);
    71f2:	add.w	r2, sp, #35	; 0x23
    71f6:	add.w	r1, sp, #38	; 0x26
    71fa:	add	r0, sp, #36	; 0x24
    71fc:	blx	r3
    71fe:	ldrh.w	r3, [sp, #36]	; 0x24
    7202:	strh	r3, [r4, #16]
    7204:	ldrh.w	r3, [sp, #38]	; 0x26
    7208:	strh	r3, [r4, #14]
    setLe16(dir->createDate, date);
    setLe16(dir->createTime, time);
    dir->createTimeMs = ms10;
    720a:	ldrb.w	r3, [sp, #35]	; 0x23
    720e:	strb	r3, [r4, #13]
    7210:	b.n	721c <FatFile::open(FatFile*, FatName_t*, int)+0x220>
    7212:	movw	r3, #21537	; 0x5421
    7216:	strh	r3, [r4, #16]
    7218:	strh	r3, [r4, #24]
    721a:	strh	r3, [r4, #18]
      setLe16(dir->createTime, FS_DEFAULT_TIME);
      setLe16(dir->modifyTime, FS_DEFAULT_TIME);
    }
  }
  // Force write of entry to device.
  dirFile->m_vol->cacheDirty();
    721c:	ldr	r2, [r6, #8]
    721e:	ldrb.w	r3, [r2, #40]	; 0x28
    7222:	orr.w	r3, r3, #1
    7226:	strb.w	r3, [r2, #40]	; 0x28

 open:
  // open entry in cache.
  if (!openCachedEntry(dirFile, curIndex, oflag, lfnOrd)) {
    722a:	str	r5, [sp, #0]
    722c:	ldr	r3, [sp, #12]
    722e:	ldr	r0, [sp, #24]
    7230:	mov	r2, r7
    7232:	mov	r1, r6
    7234:	bl	5f8e <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    7238:	b.n	7240 <FatFile::open(FatFile*, FatName_t*, int)+0x244>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  nameOrd = (fname->len + 12)/13;
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + nameOrd : 1;
    723a:	mov.w	fp, #1
    723e:	b.n	7040 <FatFile::open(FatFile*, FatName_t*, int)+0x44>
  }
  return true;

 fail:
  return false;
}
    7240:	add	sp, #44	; 0x2c
    7242:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7246:	nop
    7248:	.word	0x2001ceb4

0000724c <FatFile::parsePathName(char const*, FatName_t*, char const**)>:
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            FatName_t* fname, const char** ptr) {
    724c:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    724e:	mov	r4, r2
    7250:	mov	r6, r3
    7252:	mov	r0, r1
    7254:	adds	r1, #1
  size_t len = 0;
  // Skip leading spaces.
  while (*path == ' ') {
    7256:	ldrb	r3, [r0, #0]
    7258:	cmp	r3, #32
    725a:	beq.n	7252 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6>
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    725c:	ldr	r7, [pc, #128]	; (72e0 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x94>)
    path++;
  }
  fname->begin = path;
    725e:	str	r0, [r4, #0]
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            FatName_t* fname, const char** ptr) {
  size_t len = 0;
    7260:	movs	r5, #0
  // Skip leading spaces.
  while (*path == ' ') {
    path++;
  }
  fname->begin = path;
  while (*path && !isDirSeparator(*path)) {
    7262:	ldrb	r3, [r0, #0]
    7264:	cbz	r3, 72b8 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6c>
    7266:	cmp	r3, #47	; 0x2f
    7268:	beq.n	72b8 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x6c>
#if USE_UTF8_LONG_NAMES
    uint32_t cp;
    // Allow end = path + 4 since path is zero terminated.
    path = FsUtf::mbToCp(path, path + 4, &cp);
    726a:	add	r2, sp, #4
    726c:	adds	r1, r0, #4
    726e:	bl	345c <FsUtf::mbToCp(char const*, char const*, unsigned long*)>
    if (!path) {
    7272:	cbz	r0, 72d8 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    len += cp <= 0XFFFF ? 1 : 2;
    7274:	ldr	r2, [sp, #4]
    7276:	cmp.w	r2, #65536	; 0x10000
    727a:	ite	cs
    727c:	movcs	r3, #2
    727e:	movcc	r3, #1
    if (cp < 0X80 && lfnReservedChar(cp)) {
    7280:	cmp	r2, #127	; 0x7f
    path = FsUtf::mbToCp(path, path + 4, &cp);
    if (!path) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    len += cp <= 0XFFFF ? 1 : 2;
    7282:	add	r5, r3
    if (cp < 0X80 && lfnReservedChar(cp)) {
    7284:	bhi.n	72ae <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x62>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    7286:	cmp	r2, #31
    7288:	bls.n	72d8 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    728a:	uxtb	r3, r2
}
#endif  // USE_SIMPLE_LITTLE_ENDIAN
//------------------------------------------------------------------------------
// Reserved characters for exFAT names and FAT LFN.
inline bool lfnReservedChar(uint8_t c) {
  return c < 0X20 || c == '"' || c == '*' || c == '/' || c == ':'
    728c:	sub.w	r1, r3, #34	; 0x22
    7290:	uxtb	r1, r1
    7292:	cmp	r1, #29
    7294:	bhi.n	729e <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x52>
    7296:	lsr.w	r1, r7, r1
    729a:	lsls	r1, r1, #31
    729c:	bmi.n	72d8 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      || c == '<' || c == '>' || c == '?' || c == '\\'|| c == '|';
    729e:	and.w	r3, r3, #191	; 0xbf
    72a2:	cmp	r3, #60	; 0x3c
    72a4:	beq.n	72d8 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    72a6:	cmp	r2, #92	; 0x5c
    72a8:	beq.n	72d8 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    len++;
#endif  // USE_UTF8_LONG_NAMES
    if (cp != '.' && cp != ' ') {
    72aa:	cmp	r2, #46	; 0x2e
    72ac:	beq.n	7262 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
    72ae:	cmp	r2, #32
    72b0:	beq.n	7262 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
      // Need to trim trailing dots spaces.
      fname->len = len;
    72b2:	str	r5, [r4, #16]
      fname->end = path;
    72b4:	str	r0, [r4, #8]
  // Skip leading spaces.
  while (*path == ' ') {
    path++;
  }
  fname->begin = path;
  while (*path && !isDirSeparator(*path)) {
    72b6:	b.n	7262 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x16>
      // Need to trim trailing dots spaces.
      fname->len = len;
      fname->end = path;
    }
  }
  if (!fname->len || fname->len > FAT_MAX_LFN_LENGTH) {
    72b8:	ldr	r3, [r4, #16]
    72ba:	subs	r3, #1
    72bc:	cmp	r3, #254	; 0xfe
    72be:	bhi.n	72d8 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8c>
    72c0:	mov	r2, r0
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Advance to next path component.
  for (; *path == ' ' || isDirSeparator(*path); path++) {}
    72c2:	ldrb.w	r3, [r0], #1
    72c6:	cmp	r3, #32
    72c8:	beq.n	72c0 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x74>
    72ca:	cmp	r3, #47	; 0x2f
    72cc:	beq.n	72c0 <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x74>
  *ptr = path;
    72ce:	str	r2, [r6, #0]
  return makeSFN(fname);
    72d0:	mov	r0, r4
    72d2:	bl	6e40 <FatFile::makeSFN(FatName_t*)>
    72d6:	b.n	72da <FatFile::parsePathName(char const*, FatName_t*, char const**)+0x8e>

 fail:
  return false;
    72d8:	movs	r0, #0
}
    72da:	add	sp, #12
    72dc:	pop	{r4, r5, r6, r7, pc}
    72de:	nop
    72e0:	.word	0x31002101

000072e4 <FatFile::remove()>:
//------------------------------------------------------------------------------
bool FatFile::remove() {
    72e4:	push	{r4, r5, r6, r7, lr}
    72e6:	sub	sp, #44	; 0x2c
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() {}
    72e8:	movs	r3, #0
    72ea:	strb.w	r3, [sp, #4]
    72ee:	strb.w	r3, [sp, #5]
    72f2:	strb.w	r3, [sp, #6]
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    72f6:	ldrb	r3, [r0, #2]
    72f8:	lsls	r2, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::remove() {
    72fa:	mov	r4, r0
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    72fc:	bpl.n	732e <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
    72fe:	ldr	r1, [r0, #32]
    7300:	cbz	r1, 730a <FatFile::remove()+0x26>
    7302:	ldr	r0, [r0, #8]
    7304:	bl	6ac2 <FatPartition::freeChain(unsigned long)>
    7308:	cbz	r0, 732e <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Cache directory entry.
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
    730a:	movs	r1, #1
    730c:	mov	r0, r4
    730e:	bl	5c8c <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    7312:	mov	r5, r0
    7314:	cbz	r0, 732e <FatFile::remove()+0x4a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  checksum = lfnChecksum(dir->name);
    7316:	bl	6cb2 <FatFile::lfnChecksum(unsigned char*) [clone .isra.14]>

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;
    731a:	movs	r6, #229	; 0xe5
    731c:	strb	r6, [r5, #0]

  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    731e:	movs	r3, #0
  dir = cacheDirEntry(FsCache::CACHE_FOR_WRITE);
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  checksum = lfnChecksum(dir->name);
    7320:	mov	r7, r0

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;

  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    7322:	strb	r3, [r4, #0]
  m_flags = 0;
    7324:	strb	r3, [r4, #2]

  // Write entry to device.
  if (!m_vol->cacheSync()) {
    7326:	ldr	r0, [r4, #8]
    7328:	bl	5ba4 <FatPartition::cacheSync()>
    732c:	cbnz	r0, 7332 <FatFile::remove()+0x4e>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  return false;
    732e:	movs	r0, #0
    7330:	b.n	7392 <FatFile::remove()+0xae>
  // Write entry to device.
  if (!m_vol->cacheSync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    7332:	ldrb	r3, [r4, #3]
    7334:	cbz	r3, 7392 <FatFile::remove()+0xae>
    // Done, no LFN entries.
    return true;
  }
  if (!dirFile.openCluster(this)) {
    7336:	mov	r1, r4
    7338:	add	r0, sp, #4
    733a:	bl	5cda <FatFile::openCluster(FatFile*)>
    733e:	cmp	r0, #0
    7340:	beq.n	732e <FatFile::remove()+0x4a>
    7342:	movs	r5, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    7344:	ldrb	r3, [r4, #3]
    7346:	cmp	r3, r5
    7348:	bcc.n	732e <FatFile::remove()+0x4a>
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.cacheDir(m_dirIndex - order));
    734a:	ldrh	r1, [r4, #4]
    734c:	subs	r1, r1, r5
    734e:	uxth	r1, r1
    7350:	add	r0, sp, #4
    7352:	bl	59e4 <FatFile::cacheDir(unsigned short)>
    if (!ldir) {
    7356:	cmp	r0, #0
    7358:	beq.n	732e <FatFile::remove()+0x4a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    735a:	ldrb	r3, [r0, #11]
    735c:	cmp	r3, #15
    735e:	bne.n	732e <FatFile::remove()+0x4a>
        order != (ldir->order & 0X1F) ||
    7360:	ldrb	r2, [r0, #0]
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.cacheDir(m_dirIndex - order));
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    7362:	and.w	r3, r2, #31
    7366:	cmp	r5, r3
    7368:	bne.n	732e <FatFile::remove()+0x4a>
        order != (ldir->order & 0X1F) ||
    736a:	ldrb	r3, [r0, #13]
    736c:	cmp	r3, r7
    736e:	bne.n	732e <FatFile::remove()+0x4a>
        checksum != ldir->checksum) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    last = ldir->order & FAT_ORDER_LAST_LONG_ENTRY;
    ldir->order = FAT_NAME_DELETED;
    7370:	strb	r6, [r0, #0]
    m_vol->cacheDirty();
    7372:	ldr	r1, [r4, #8]
    7374:	ldrb.w	r3, [r1, #40]	; 0x28
    7378:	orr.w	r3, r3, #1
    737c:	strb.w	r3, [r1, #40]	; 0x28
    if (last) {
    7380:	lsls	r3, r2, #25
    7382:	bpl.n	738c <FatFile::remove()+0xa8>
      if (!m_vol->cacheSync()) {
    7384:	ldr	r0, [r4, #8]
    7386:	bl	5ba4 <FatPartition::cacheSync()>
    738a:	b.n	7392 <FatFile::remove()+0xae>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    738c:	adds	r5, #1
    738e:	uxtb	r5, r5
    7390:	b.n	7344 <FatFile::remove()+0x60>
  // Fall into fail.
  DBG_FAIL_MACRO;

 fail:
  return false;
}
    7392:	add	sp, #44	; 0x2c
    7394:	pop	{r4, r5, r6, r7, pc}

00007396 <FsBaseFile::FsBaseFile(FsBaseFile const&)>:
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    7396:	push	{r3, r4, r5, r6, r7, lr}
    7398:	movs	r4, #0
    739a:	str	r4, [r0, #56]	; 0x38
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    739c:	ldr	r7, [r1, #56]	; 0x38
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
//------------------------------------------------------------------------------
FsBaseFile::FsBaseFile(const FsBaseFile& from) {
    739e:	str	r4, [r0, #60]	; 0x3c
    73a0:	mov	r6, r0
    73a2:	mov	r5, r1
  m_fFile = nullptr;
  m_xFile = nullptr;
  if (from.m_fFile) {
    73a4:	cbz	r7, 73c8 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x32>
    m_fFile = new (m_fileMem) FatFile;
    73a6:	mov	r1, r0
    73a8:	movs	r0, #36	; 0x24
    73aa:	bl	75e0 <operator new(unsigned int, unsigned long*)>
    73ae:	strb	r4, [r0, #0]
    73b0:	strb	r4, [r0, #1]
    73b2:	strb	r4, [r0, #2]
    73b4:	str	r0, [r6, #56]	; 0x38
    *m_fFile = *from.m_fFile;
    73b6:	ldr	r5, [r5, #56]	; 0x38
    73b8:	mov	r4, r0
    73ba:	ldmia	r5!, {r0, r1, r2, r3}
    73bc:	stmia	r4!, {r0, r1, r2, r3}
    73be:	ldmia	r5!, {r0, r1, r2, r3}
    73c0:	stmia	r4!, {r0, r1, r2, r3}
    73c2:	ldr	r3, [r5, #0]
    73c4:	str	r3, [r4, #0]
    73c6:	b.n	73f4 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x5e>
  } else if (from.m_xFile) {
    73c8:	ldr	r3, [r1, #60]	; 0x3c
    73ca:	cbz	r3, 73f4 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x5e>
    m_xFile = new (m_fileMem) ExFatFile;
    73cc:	mov	r1, r0
    73ce:	movs	r0, #56	; 0x38
    73d0:	bl	75e0 <operator new(unsigned int, unsigned long*)>
    73d4:	strb.w	r7, [r0, #49]	; 0x31
    73d8:	strb.w	r7, [r0, #50]	; 0x32
    73dc:	strb.w	r7, [r0, #51]	; 0x33
    73e0:	str	r0, [r6, #60]	; 0x3c
    *m_xFile = *from.m_xFile;
    73e2:	ldr	r3, [r5, #60]	; 0x3c
    73e4:	add.w	r2, r3, #52	; 0x34
    73e8:	ldr.w	r1, [r3], #4
    73ec:	str.w	r1, [r0], #4
    73f0:	cmp	r3, r2
    73f2:	bne.n	73e8 <FsBaseFile::FsBaseFile(FsBaseFile const&)+0x52>
  }
}
    73f4:	mov	r0, r6
    73f6:	pop	{r3, r4, r5, r6, r7, pc}

000073f8 <FsBaseFile::close()>:
    *m_xFile = *from.m_xFile;
  }
  return *this;
}
//------------------------------------------------------------------------------
bool FsBaseFile::close() {
    73f8:	push	{r4, lr}
    73fa:	mov	r4, r0
  if (m_fFile && m_fFile->close()) {
    73fc:	ldr	r0, [r0, #56]	; 0x38
    73fe:	cbz	r0, 7406 <FsBaseFile::close()+0xe>
    7400:	bl	61b8 <FatFile::close()>
    7404:	cbnz	r0, 7416 <FsBaseFile::close()+0x1e>
    m_fFile = nullptr;
    return true;
  }
  if (m_xFile && m_xFile->close()) {
    7406:	ldr	r0, [r4, #60]	; 0x3c
    7408:	cbz	r0, 741c <FsBaseFile::close()+0x24>
    740a:	bl	3faa <ExFatFile::close()>
    740e:	cbz	r0, 741c <FsBaseFile::close()+0x24>
    m_xFile = nullptr;
    7410:	movs	r3, #0
    7412:	str	r3, [r4, #60]	; 0x3c
    7414:	pop	{r4, pc}
  return *this;
}
//------------------------------------------------------------------------------
bool FsBaseFile::close() {
  if (m_fFile && m_fFile->close()) {
    m_fFile = nullptr;
    7416:	movs	r3, #0
    7418:	str	r3, [r4, #56]	; 0x38
    return true;
    741a:	pop	{r4, pc}
  }
  if (m_xFile && m_xFile->close()) {
    m_xFile = nullptr;
    return true;
  }
  return false;
    741c:	movs	r0, #0
}
    741e:	pop	{r4, pc}

00007420 <FsBaseFile::open(FsVolume*, char const*, int)>:
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
    7420:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7424:	mov	r4, r0
    7426:	mov	r7, r2
    7428:	mov	r8, r3
  if (!vol) {
    742a:	mov	r5, r1
    742c:	cbnz	r1, 7434 <FsBaseFile::open(FsVolume*, char const*, int)+0x14>
    return false;
    742e:	movs	r0, #0
    7430:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  close();
    7434:	bl	73f8 <FsBaseFile::close()>
  if (vol->m_fVol) {
    7438:	ldr.w	r6, [r5, #1152]	; 0x480
    743c:	cbz	r6, 7464 <FsBaseFile::open(FsVolume*, char const*, int)+0x44>
    m_fFile = new (m_fileMem) FatFile;
    743e:	mov	r1, r4
    7440:	movs	r0, #36	; 0x24
    7442:	bl	75e0 <operator new(unsigned int, unsigned long*)>
    7446:	movs	r2, #0
    7448:	strb	r2, [r0, #0]
    744a:	strb	r2, [r0, #1]
    744c:	strb	r2, [r0, #2]
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    744e:	mov	r3, r8
  if (!vol) {
    return false;
  }
  close();
  if (vol->m_fVol) {
    m_fFile = new (m_fileMem) FatFile;
    7450:	str	r0, [r4, #56]	; 0x38
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    7452:	mov	r2, r7
    7454:	ldr.w	r1, [r5, #1152]	; 0x480
    7458:	bl	6270 <FatFile::open(FatVolume*, char const*, int)>
    745c:	cbz	r0, 7498 <FsBaseFile::open(FsVolume*, char const*, int)+0x78>
      return true;
    745e:	movs	r0, #1
    7460:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    m_fFile = nullptr;
  } else if (vol->m_xVol) {
    7464:	ldr.w	r3, [r5, #1156]	; 0x484
    7468:	cmp	r3, #0
    746a:	beq.n	742e <FsBaseFile::open(FsVolume*, char const*, int)+0xe>
    m_xFile = new (m_fileMem) ExFatFile;
    746c:	mov	r1, r4
    746e:	movs	r0, #56	; 0x38
    7470:	bl	75e0 <operator new(unsigned int, unsigned long*)>
    7474:	strb.w	r6, [r0, #49]	; 0x31
    7478:	strb.w	r6, [r0, #50]	; 0x32
    747c:	strb.w	r6, [r0, #51]	; 0x33
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    7480:	mov	r3, r8
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
      return true;
    }
    m_fFile = nullptr;
  } else if (vol->m_xVol) {
    m_xFile = new (m_fileMem) ExFatFile;
    7482:	str	r0, [r4, #60]	; 0x3c
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    7484:	mov	r2, r7
    7486:	ldr.w	r1, [r5, #1156]	; 0x484
    748a:	bl	472a <ExFatFile::open(ExFatVolume*, char const*, int)>
    748e:	cmp	r0, #0
    7490:	bne.n	745e <FsBaseFile::open(FsVolume*, char const*, int)+0x3e>
      return true;
    }
    m_xFile = nullptr;
    7492:	str	r0, [r4, #60]	; 0x3c
  }
  return false;
}
    7494:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (vol->m_fVol) {
    m_fFile = new (m_fileMem) FatFile;
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
      return true;
    }
    m_fFile = nullptr;
    7498:	str	r0, [r4, #56]	; 0x38
    749a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000749e <FsBaseFile::openNext(FsBaseFile*, int)>:
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::openNext(FsBaseFile* dir, oflag_t oflag) {
    749e:	push	{r3, r4, r5, r6, r7, lr}
    74a0:	mov	r5, r1
    74a2:	mov	r4, r0
    74a4:	mov	r7, r2
  close();
    74a6:	bl	73f8 <FsBaseFile::close()>
  if (dir->m_fFile) {
    74aa:	ldr	r6, [r5, #56]	; 0x38
    74ac:	cbz	r6, 74d2 <FsBaseFile::openNext(FsBaseFile*, int)+0x34>
    m_fFile = new (m_fileMem) FatFile;
    74ae:	mov	r1, r4
    74b0:	movs	r0, #36	; 0x24
    74b2:	bl	75e0 <operator new(unsigned int, unsigned long*)>
    74b6:	movs	r2, #0
    74b8:	strb	r2, [r0, #0]
    74ba:	strb	r2, [r0, #1]
    74bc:	strb	r2, [r0, #2]
    74be:	str	r0, [r4, #56]	; 0x38
    if (m_fFile->openNext(dir->m_fFile, oflag)) {
    74c0:	mov	r2, r7
    74c2:	ldr	r1, [r5, #56]	; 0x38
    74c4:	bl	6050 <FatFile::openNext(FatFile*, int)>
    74c8:	cbz	r0, 74ce <FsBaseFile::openNext(FsBaseFile*, int)+0x30>
      return true;
    74ca:	movs	r0, #1
    74cc:	pop	{r3, r4, r5, r6, r7, pc}
    }
    m_fFile = nullptr;
    74ce:	str	r0, [r4, #56]	; 0x38
    74d0:	pop	{r3, r4, r5, r6, r7, pc}
  } else if (dir->m_xFile) {
    74d2:	ldr	r0, [r5, #60]	; 0x3c
    74d4:	cbz	r0, 74fa <FsBaseFile::openNext(FsBaseFile*, int)+0x5c>
    m_xFile = new (m_fileMem) ExFatFile;
    74d6:	mov	r1, r4
    74d8:	movs	r0, #56	; 0x38
    74da:	bl	75e0 <operator new(unsigned int, unsigned long*)>
    74de:	strb.w	r6, [r0, #49]	; 0x31
    74e2:	strb.w	r6, [r0, #50]	; 0x32
    74e6:	strb.w	r6, [r0, #51]	; 0x33
    74ea:	str	r0, [r4, #60]	; 0x3c
    if (m_xFile->openNext(dir->m_xFile, oflag)) {
    74ec:	mov	r2, r7
    74ee:	ldr	r1, [r5, #60]	; 0x3c
    74f0:	bl	4738 <ExFatFile::openNext(ExFatFile*, int)>
    74f4:	cmp	r0, #0
    74f6:	bne.n	74ca <FsBaseFile::openNext(FsBaseFile*, int)+0x2c>
      return true;
    }
    m_xFile = nullptr;
    74f8:	str	r0, [r4, #60]	; 0x3c
  }
  return false;
}
    74fa:	pop	{r3, r4, r5, r6, r7, pc}

000074fc <FsVolume::begin(BlockDeviceInterface*)>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    74fc:	push	{r3, r4, r5, r6, r7, lr}
  m_blockDev = blockDev;
  m_fVol = nullptr;
    74fe:	movs	r6, #0
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    7500:	mov	r4, r0
  m_blockDev = blockDev;
    7502:	str.w	r1, [r0, #1160]	; 0x488
  m_fVol = nullptr;
    7506:	str.w	r6, [r0, #1152]	; 0x480
  m_xVol = new (m_volMem) ExFatVolume;
    750a:	mov	r1, r0
    750c:	mov.w	r0, #1152	; 0x480
    7510:	bl	75e0 <operator new(unsigned int, unsigned long*)>
 * \class ExFatPartition
 * \brief Access exFat partitions on raw file devices.
 */
class ExFatPartition {
 public:
  ExFatPartition() {}
    7514:	strb.w	r6, [r0, #1092]	; 0x444
    7518:	strb.w	r6, [r0, #1145]	; 0x479
    751c:	strb.w	r6, [r0, #1146]	; 0x47a
    7520:	strb.w	r6, [r0, #1147]	; 0x47b
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    7524:	movs	r2, #1
    7526:	str.w	r0, [r4, #1156]	; 0x484
    752a:	ldr.w	r1, [r4, #1160]	; 0x488
    752e:	ldr	r7, [pc, #124]	; (75ac <FsVolume::begin(BlockDeviceInterface*)+0xb0>)
    7530:	mov	r5, r0
    7532:	bl	4a90 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>
    7536:	cbz	r0, 7550 <FsVolume::begin(BlockDeviceInterface*)+0x54>
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    7538:	add.w	r6, r5, #1096	; 0x448
    753c:	mov	r0, r6
    753e:	bl	3faa <ExFatFile::close()>
    return m_vwd.openRoot(this);
    7542:	mov	r1, r5
    7544:	mov	r0, r6
    7546:	bl	3ffe <ExFatFile::openRoot(ExFatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    754a:	cbz	r0, 7550 <FsVolume::begin(BlockDeviceInterface*)+0x54>
      return false;
    }
    if (setCwv || !m_cwv) {
    754c:	ldr	r3, [pc, #96]	; (75b0 <FsVolume::begin(BlockDeviceInterface*)+0xb4>)
    754e:	b.n	7596 <FsVolume::begin(BlockDeviceInterface*)+0x9a>
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    7550:	movs	r6, #0
  m_fVol = new (m_volMem) FatVolume;
    7552:	mov	r1, r4
  m_fVol = nullptr;
  m_xVol = new (m_volMem) ExFatVolume;
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    7554:	str.w	r6, [r4, #1156]	; 0x484
  m_fVol = new (m_volMem) FatVolume;
    7558:	movw	r0, #1132	; 0x46c
    755c:	bl	75e0 <operator new(unsigned int, unsigned long*)>
 */
class FatPartition {
 public:
  /** Create an instance of FatPartition
   */
  FatPartition() {}
    7560:	strb	r6, [r0, #7]
    7562:	strb.w	r6, [r0, #1096]	; 0x448
    7566:	strb.w	r6, [r0, #1097]	; 0x449
    756a:	strb.w	r6, [r0, #1098]	; 0x44a
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    756e:	movs	r2, #1
    7570:	str.w	r0, [r4, #1152]	; 0x480
    7574:	ldr.w	r1, [r4, #1160]	; 0x488
    7578:	mov	r5, r0
    757a:	bl	6b64 <FatPartition::init(BlockDeviceInterface*, unsigned char)>
    757e:	cbz	r0, 75a2 <FsVolume::begin(BlockDeviceInterface*)+0xa6>
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    7580:	add.w	r6, r5, #1096	; 0x448
    7584:	mov	r0, r6
    7586:	bl	61b8 <FatFile::close()>
    return m_vwd.openRoot(this);
    758a:	mov	r1, r5
    758c:	mov	r0, r6
    758e:	bl	5caa <FatFile::openRoot(FatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    7592:	cbz	r0, 75a2 <FsVolume::begin(BlockDeviceInterface*)+0xa6>
      return false;
    }
    if (setCwv || !m_cwv) {
    7594:	ldr	r3, [pc, #28]	; (75b4 <FsVolume::begin(BlockDeviceInterface*)+0xb8>)
    7596:	ldr	r2, [r3, #0]
    7598:	cbnz	r2, 759c <FsVolume::begin(BlockDeviceInterface*)+0xa0>
      m_cwv = this;
    759a:	str	r5, [r3, #0]
  m_cwv = nullptr;
  m_fVol = nullptr;
  return false;

 done:
  m_cwv = this;
    759c:	str	r4, [r7, #0]
  return true;
    759e:	movs	r0, #1
    75a0:	pop	{r3, r4, r5, r6, r7, pc}
  m_xVol = nullptr;
  m_fVol = new (m_volMem) FatVolume;
  if (m_fVol && m_fVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_cwv = nullptr;
    75a2:	movs	r0, #0
    75a4:	str	r0, [r7, #0]
  m_fVol = nullptr;
    75a6:	str.w	r0, [r4, #1152]	; 0x480
  return false;

 done:
  m_cwv = this;
  return true;
}
    75aa:	pop	{r3, r4, r5, r6, r7, pc}
    75ac:	.word	0x2001cec0
    75b0:	.word	0x2001ceb8
    75b4:	.word	0x2001cebc

000075b8 <FsVolume::open(char const*, int)>:
bool FsVolume::ls(print_t* pr, const char* path, uint8_t flags) {
  FsBaseFile dir;
  return dir.open(this, path, O_RDONLY) && dir.ls(pr, flags);
}
//------------------------------------------------------------------------------
FsFile FsVolume::open(const char *path, oflag_t oflag) {
    75b8:	push	{r3, r4, r5, lr}
    75ba:	mov	r4, r0
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    75bc:	movs	r0, #0
    75be:	strb	r0, [r4, #4]
    75c0:	strb	r0, [r4, #12]
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  /** Create an instance. */
  FsBaseFile() {}
    75c2:	str	r0, [r4, #72]	; 0x48
    75c4:	str	r0, [r4, #76]	; 0x4c
    75c6:	mov.w	r5, #1000	; 0x3e8
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    75ca:	mov	r0, r4
    75cc:	str	r5, [r4, #8]
    75ce:	ldr	r5, [pc, #12]	; (75dc <FsVolume::open(char const*, int)+0x24>)
    75d0:	str.w	r5, [r0], #16
  FsFile tmpFile;
  tmpFile.open(this, path, oflag);
    75d4:	bl	7420 <FsBaseFile::open(FsVolume*, char const*, int)>
  return tmpFile;
}
    75d8:	mov	r0, r4
    75da:	pop	{r3, r4, r5, pc}
    75dc:	.word	0x0001244c

000075e0 <operator new(unsigned int, unsigned long*)>:
 */
#include "FsNew.h"
void* operator new(size_t size, newalign_t* ptr) {
  (void)size;
  return ptr;
}
    75e0:	mov	r0, r1
    75e2:	bx	lr

000075e4 <SdSpiCard::errorCode() const>:
  /**
   * \return code for the last error. See SdCardInfo.h for a list of error codes.
   */
  uint8_t errorCode() const {
    return m_errorCode;
  }
    75e4:	ldrb	r0, [r0, #15]
    75e6:	bx	lr

000075e8 <SdSpiCard::errorData() const>:
  /** \return error data for last error. */
  uint32_t errorData() const {
    return m_status;
  }
    75e8:	ldrb	r0, [r0, #17]
    75ea:	bx	lr

000075ec <SdSpiCard::readSector(unsigned long, unsigned char*)>:
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    75ec:	ldr	r3, [r0, #0]
   *
   * \param[in] sector Logical sector to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
    75ee:	push	{r4}
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    75f0:	ldr	r4, [r3, #16]
    75f2:	movs	r3, #1
    75f4:	mov	ip, r4
#else  // ENABLE_DEDICATED_SPI
    return readSingle(sector, dst);
#endif  // ENABLE_DEDICATED_SPI
  }
    75f6:	ldr.w	r4, [sp], #4
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    75fa:	bx	ip

000075fc <SdSpiCard::type() const>:
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
  }
    75fc:	ldrb	r0, [r0, #18]
    75fe:	bx	lr

00007600 <SdSpiCard::~SdSpiCard()>:
/**
 * \class SdSpiCard
 * \brief Raw access to SD and SDHC flash memory cards via SPI protocol.
 */
#if HAS_SDIO_CLASS
class SdSpiCard : public SdCardInterface {
    7600:	bx	lr

00007602 <SdSpiCard::~SdSpiCard()>:
    7602:	push	{r4, lr}
    7604:	movs	r1, #20
    7606:	mov	r4, r0
    7608:	bl	a2bc <operator delete(void*, unsigned int)>
    760c:	mov	r0, r4
    760e:	pop	{r4, pc}

00007610 <SdSpiCard::sectorCount()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
uint32_t SdSpiCard::sectorCount() {
    7610:	push	{r0, r1, r2, r3, r4, lr}
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
    7612:	ldr	r3, [r0, #0]
    7614:	mov	r1, sp
    7616:	ldr	r3, [r3, #60]	; 0x3c
    7618:	blx	r3
    761a:	cbz	r0, 768a <SdSpiCard::sectorCount()+0x7a>
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    761c:	ldrb.w	r3, [sp]
    7620:	ands.w	r3, r3, #192	; 0xc0
    7624:	bne.n	7666 <SdSpiCard::sectorCount()+0x56>
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    7626:	ldrb.w	r0, [sp, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    762a:	ldrb.w	r3, [sp, #7]
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    762e:	ldrb.w	r2, [sp, #10]
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7632:	and.w	r0, r0, #3
    7636:	lsls	r3, r3, #2
    7638:	orr.w	r3, r3, r0, lsl #10
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    763c:	ldrb.w	r0, [sp, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7640:	orr.w	r0, r3, r0, lsr #6
    7644:	adds	r3, r0, #1
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    7646:	ldrb.w	r0, [sp, #9]
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    764a:	and.w	r0, r0, #3
    764e:	lsls	r0, r0, #1
    7650:	orr.w	r0, r0, r2, lsr #7
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    7654:	ldrb.w	r2, [sp, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    7658:	and.w	r2, r2, #15
    765c:	add	r0, r2
    765e:	subs	r0, #7
    7660:	lsl.w	r0, r3, r0
    7664:	b.n	768a <SdSpiCard::sectorCount()+0x7a>
  } else if (csd->v2.csd_ver == 1) {
    7666:	cmp	r3, #64	; 0x40
    7668:	bne.n	7688 <SdSpiCard::sectorCount()+0x78>
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    766a:	ldrb.w	r0, [sp, #9]
    766e:	adds	r3, r0, #1
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    7670:	ldrb.w	r0, [sp, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    7674:	and.w	r0, r0, #63	; 0x3f
    7678:	add.w	r0, r3, r0, lsl #16
    767c:	ldrb.w	r3, [sp, #8]
    7680:	add.w	r0, r0, r3, lsl #8
    7684:	lsls	r0, r0, #10
    7686:	b.n	768a <SdSpiCard::sectorCount()+0x7a>
    7688:	movs	r0, #0
}
    768a:	add	sp, #20
    768c:	ldr.w	pc, [sp], #4

00007690 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>:
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spiDriverPtr->receive(buf, n);
  }
  void spiSend(uint8_t data) {
    m_spiDriverPtr->send(data);
    7690:	ldr	r3, [r0, #0]
    7692:	ldr	r3, [r3, #20]
    7694:	bx	r3

00007696 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>:
  }
  void spiDeactivate() {
    m_spiDriverPtr->deactivate();
  }
  uint8_t spiReceive() {
    return m_spiDriverPtr->receive();
    7696:	ldr	r3, [r0, #0]
    7698:	ldr	r3, [r3, #12]
    769a:	bx	r3

0000769c <SysCall::curTimeMS()>:
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    769c:	ldr	r3, [pc, #12]	; (76ac <SysCall::curTimeMS()+0x10>)
/** Define macro for strings stored in flash. */
#define F(str) (str)
#endif  // F
//------------------------------------------------------------------------------
/** \return the time in milliseconds. */
inline SdMillis_t SysCall::curTimeMS() {
    769e:	sub	sp, #8
    76a0:	ldr	r3, [r3, #0]
    76a2:	str	r3, [sp, #4]
	return ret;
    76a4:	ldr	r0, [sp, #4]
  return millis();
}
    76a6:	uxth	r0, r0
    76a8:	add	sp, #8
    76aa:	bx	lr
    76ac:	.word	0x2001cf20

000076b0 <SdSpiCard::spiStart()>:
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
    76b0:	push	{r3, r4, r5, lr}
  if (!m_spiActive) {
    76b2:	ldrb	r5, [r0, #16]
uint32_t SdSpiCard::sectorCount() {
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
    76b4:	mov	r4, r0
  if (!m_spiActive) {
    76b6:	cbnz	r5, 76d4 <SdSpiCard::spiStart()+0x24>
    76b8:	ldr	r0, [r0, #4]
    m_spiDriver.setSckSpeed(maxSck);
  }
  SdSpiDriver m_spiDriver;
#else  // SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriverPtr->activate();
    76ba:	ldr	r3, [r0, #0]
    76bc:	ldr	r3, [r3, #0]
    76be:	blx	r3
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    76c0:	mov	r1, r5
    76c2:	ldrb	r0, [r4, #14]
    76c4:	bl	1b0c <sdCsWrite(unsigned char, bool)>
    spiActivate();
    spiSelect();
    // Dummy byte to drive MISO busy status.
    spiSend(0XFF);    
    76c8:	movs	r1, #255	; 0xff
    76ca:	ldr	r0, [r4, #4]
    76cc:	bl	7690 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    m_spiActive = true;
    76d0:	movs	r3, #1
    76d2:	strb	r3, [r4, #16]
    76d4:	pop	{r3, r4, r5, pc}

000076d6 <SdSpiCard::spiStop()>:
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    76d6:	ldrb	r3, [r0, #16]
    spiSend(0XFF);    
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
    76d8:	push	{r4, lr}
    76da:	mov	r4, r0
  if (m_spiActive) {
    76dc:	cbz	r3, 76fa <SdSpiCard::spiStop()+0x24>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    76de:	movs	r1, #1
    76e0:	ldrb	r0, [r0, #14]
    76e2:	bl	1b0c <sdCsWrite(unsigned char, bool)>
    spiUnselect();
    // Insure MISO goes to low Z.
    spiSend(0XFF);        
    76e6:	movs	r1, #255	; 0xff
    76e8:	ldr	r0, [r4, #4]
    76ea:	bl	7690 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    76ee:	ldr	r0, [r4, #4]
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriverPtr->begin(spiConfig);
  }
  void spiDeactivate() {
    m_spiDriverPtr->deactivate();
    76f0:	ldr	r3, [r0, #0]
    76f2:	ldr	r3, [r3, #8]
    76f4:	blx	r3
    spiDeactivate();
    m_spiActive = false;
    76f6:	movs	r3, #0
    76f8:	strb	r3, [r4, #16]
    76fa:	pop	{r4, pc}

000076fc <SdSpiCard::isBusy()>:
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    76fc:	push	{r4, r5, r6, lr}
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    76fe:	ldrb	r3, [r0, #12]
    7700:	cmp	r3, #1
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    7702:	mov	r5, r0
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    7704:	beq.n	7726 <SdSpiCard::isBusy()+0x2a>
    return false;
  }
#endif  // ENABLE_DEDICATED_SPI
  bool spiActive = m_spiActive;
    7706:	ldrb	r6, [r0, #16]
  if (!spiActive) {
    7708:	cbnz	r6, 770e <SdSpiCard::isBusy()+0x12>
    spiStart();
    770a:	bl	76b0 <SdSpiCard::spiStart()>
  }
  bool rtn = 0XFF != spiReceive();
    770e:	ldr	r0, [r5, #4]
    7710:	bl	7696 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7714:	subs.w	r4, r0, #255	; 0xff
    7718:	it	ne
    771a:	movne	r4, #1
  if (!spiActive) {
    771c:	cbnz	r6, 772a <SdSpiCard::isBusy()+0x2e>
    spiStop();
    771e:	mov	r0, r5
    7720:	bl	76d6 <SdSpiCard::spiStop()>
    7724:	b.n	772a <SdSpiCard::isBusy()+0x2e>
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    return false;
    7726:	movs	r0, #0
    7728:	pop	{r4, r5, r6, pc}
  }
  bool rtn = 0XFF != spiReceive();
  if (!spiActive) {
    spiStop();
  }
  return rtn;
    772a:	mov	r0, r4
}
    772c:	pop	{r4, r5, r6, pc}

0000772e <SdSpiCard::readData(unsigned char*, unsigned int)>:
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst) {
  return readData(dst, 512);
}
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst, size_t count) {
    772e:	push	{r3, r4, r5, r6, r7, lr}
    7730:	mov	r4, r0
    7732:	mov	r5, r1
    7734:	mov	r6, r2
  uint16_t crc;
#endif  // USE_SD_CRC

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
    7736:	bl	769c <SysCall::curTimeMS()>
    773a:	mov	r7, r0
  while ((m_status = spiReceive()) == 0XFF) {
    773c:	ldr	r0, [r4, #4]
    773e:	bl	7696 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7742:	cmp	r0, #255	; 0xff
    7744:	strb	r0, [r4, #17]
    7746:	bne.n	7758 <SdSpiCard::readData(unsigned char*, unsigned int)+0x2a>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    7748:	bl	769c <SysCall::curTimeMS()>

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  SdMillis_t t0 = SysCall::curTimeMS();
  while ((m_status = spiReceive()) == 0XFF) {
    if (isTimedOut(t0, SD_READ_TIMEOUT)) {
    774c:	subs	r0, r0, r7
    774e:	cmp.w	r0, #300	; 0x12c
    7752:	ble.n	773c <SdSpiCard::readData(unsigned char*, unsigned int)+0xe>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7754:	movs	r3, #29
    7756:	b.n	7772 <SdSpiCard::readData(unsigned char*, unsigned int)+0x44>
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
    }
  }
  DBG_END_TIME(DBG_WAIT_READ);
  if (m_status != DATA_START_SECTOR) {
    7758:	cmp	r0, #254	; 0xfe
    775a:	beq.n	7760 <SdSpiCard::readData(unsigned char*, unsigned int)+0x32>
    775c:	movs	r3, #24
    775e:	b.n	7772 <SdSpiCard::readData(unsigned char*, unsigned int)+0x44>
    7760:	ldr	r0, [r4, #4]
  }
  uint8_t spiReceive() {
    return m_spiDriverPtr->receive();
  }
  uint8_t spiReceive(uint8_t* buf, size_t n) {
    return m_spiDriverPtr->receive(buf, n);
    7762:	ldr	r3, [r0, #0]
    7764:	mov	r2, r6
    7766:	ldr	r3, [r3, #16]
    7768:	mov	r1, r5
    776a:	blx	r3
    error(SD_CARD_ERROR_READ_TOKEN);
    goto fail;
  }
  // transfer data
  if ((m_status = spiReceive(dst, count))) {
    776c:	strb	r0, [r4, #17]
    776e:	cbz	r0, 777e <SdSpiCard::readData(unsigned char*, unsigned int)+0x50>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7770:	movs	r3, #37	; 0x25
  spiReceive();
#endif  // USE_SD_CRC
  return true;

 fail:
  spiStop();
    7772:	mov	r0, r4
    7774:	strb	r3, [r4, #15]
    7776:	bl	76d6 <SdSpiCard::spiStop()>
  return false;
    777a:	movs	r0, #0
}
    777c:	pop	{r3, r4, r5, r6, r7, pc}
    error(SD_CARD_ERROR_READ_CRC);
    goto fail;
  }
#else  // USE_SD_CRC
  // discard crc
  spiReceive();
    777e:	ldr	r0, [r4, #4]
    7780:	bl	7696 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
  spiReceive();
    7784:	ldr	r0, [r4, #4]
    7786:	bl	7696 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    778a:	movs	r0, #1
    778c:	pop	{r3, r4, r5, r6, r7, pc}

0000778e <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    778e:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7792:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    7794:	ldrb	r3, [r0, #12]
    7796:	cmp	r3, #2
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    7798:	mov	r4, r0
    779a:	mov	r5, r1
    779c:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    779e:	bne.n	77a6 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x18>
    77a0:	ldr	r3, [r0, #8]
    77a2:	cmp	r3, r1
    77a4:	beq.n	77b8 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2a>
    if (!writeStart(sector)) {
    77a6:	ldr	r3, [r4, #0]
    77a8:	mov	r1, r5
    77aa:	ldr	r3, [r3, #80]	; 0x50
    77ac:	mov	r0, r4
    77ae:	blx	r3
    77b0:	cbz	r0, 77e6 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x58>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
    77b2:	movs	r3, #2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    if (!writeStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    77b4:	str	r5, [r4, #8]
    m_curState = WRITE_STATE;
    77b6:	strb	r3, [r4, #12]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    77b8:	movs	r5, #0
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    77ba:	cmp	r5, r7
    77bc:	add.w	r1, r6, r5, lsl #9
    77c0:	beq.n	77d0 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x42>
    if (!writeData(src)) {
    77c2:	ldr	r3, [r4, #0]
    77c4:	mov	r0, r4
    77c6:	ldr	r3, [r3, #76]	; 0x4c
    77c8:	blx	r3
    77ca:	cbz	r0, 77e6 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x58>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    77cc:	adds	r5, #1
    77ce:	b.n	77ba <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2c>
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    77d0:	ldr	r3, [r4, #8]
    77d2:	add	r5, r3
  return m_sharedSpi ? syncDevice() : true;
    77d4:	ldrb	r3, [r4, #13]
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    77d6:	str	r5, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    77d8:	cbz	r3, 77f2 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x64>
    77da:	ldr	r3, [r4, #0]
    77dc:	mov	r0, r4
    77de:	ldr	r3, [r3, #28]
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    77e0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    77e4:	bx	r3
  }
  return writeStop();
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
    77e6:	mov	r0, r4
    77e8:	bl	76d6 <SdSpiCard::spiStop()>
  return false;
    77ec:	movs	r0, #0
    77ee:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    77f2:	movs	r0, #1
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    77f4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000077f8 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)>:
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    77f8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    77fc:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    77fe:	ldrb	r3, [r0, #12]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    7800:	ldr.w	r8, [sp, #32]
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    7804:	cmp	r3, #2
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectorsCallback(uint32_t sector, size_t ns,
 const uint8_t * (*callback)(uint32_t sector, void *context), void *context) {
    7806:	mov	r4, r0
    7808:	mov	r5, r1
    780a:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    780c:	bne.n	7814 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x1c>
    780e:	ldr	r3, [r0, #8]
    7810:	cmp	r3, r1
    7812:	beq.n	7826 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x2e>
    if (!writeStart(sector)) {
    7814:	ldr	r3, [r4, #0]
    7816:	mov	r1, r5
    7818:	ldr	r3, [r3, #80]	; 0x50
    781a:	mov	r0, r4
    781c:	blx	r3
    781e:	cbz	r0, 785c <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x64>
      goto fail;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
    7820:	movs	r3, #2
#if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    if (!writeStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    7822:	str	r5, [r4, #8]
    m_curState = WRITE_STATE;
    7824:	strb	r3, [r4, #12]
    7826:	add.w	r9, r5, r6
  }
  for (size_t i = 0; i < ns; i++) {
    782a:	cmp	r5, r9
    782c:	beq.n	7846 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x4e>
    const uint8_t *src = callback(sector + i, context);
    782e:	mov	r1, r8
    7830:	mov	r0, r5
    7832:	blx	r7
    if (!writeData(src)) {
    7834:	ldr	r3, [r4, #0]
    7836:	mov	r1, r0
    7838:	ldr	r3, [r3, #76]	; 0x4c
    783a:	mov	r0, r4
    783c:	blx	r3
    783e:	adds	r5, #1
    7840:	cmp	r0, #0
    7842:	bne.n	782a <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x32>
    7844:	b.n	785c <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x64>
      goto fail;
    }
  }
  m_curSector += ns;
    7846:	ldr	r3, [r4, #8]
    7848:	add	r6, r3
  return m_sharedSpi ? syncDevice() : true;
    784a:	ldrb	r3, [r4, #13]
    const uint8_t *src = callback(sector + i, context);
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
    784c:	str	r6, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    784e:	cbz	r3, 7868 <SdSpiCard::writeSectorsCallback(unsigned long, unsigned int, unsigned char const* (*)(unsigned long, void*), void*)+0x70>
    7850:	ldr	r3, [r4, #0]
    7852:	mov	r0, r4
    7854:	ldr	r3, [r3, #28]
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    7856:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    785a:	bx	r3
  }
  return writeStop();
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
    785c:	mov	r0, r4
    785e:	bl	76d6 <SdSpiCard::spiStop()>
  return false;
    7862:	movs	r0, #0
    7864:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (!writeData(src)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7868:	movs	r0, #1
#endif  // ENABLE_DEDICATED_SPI

 fail:
  spiStop();
  return false;
}
    786a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000786e <SdSpiCard::waitNotBusy(unsigned short)>:
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
//------------------------------------------------------------------------------
// wait for card to go not busy
bool SdSpiCard::waitNotBusy(SdMillis_t timeoutMS) {
    786e:	push	{r4, r5, r6, lr}
    7870:	mov	r6, r0
    7872:	mov	r4, r1
  SdMillis_t t0 = SysCall::curTimeMS();
    7874:	bl	769c <SysCall::curTimeMS()>
    7878:	mov	r5, r0
    }
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    787a:	ldr	r0, [r6, #4]
    787c:	bl	7696 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7880:	cmp	r0, #255	; 0xff
    7882:	beq.n	7892 <SdSpiCard::waitNotBusy(unsigned short)+0x24>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    7884:	bl	769c <SysCall::curTimeMS()>
  }
  return false;
#else  // WDT_YIELD_TIME_MILLIS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    if (isTimedOut(t0, timeoutMS)) {
    7888:	subs	r0, r0, r5
    788a:	cmp	r0, r4
    788c:	ble.n	787a <SdSpiCard::waitNotBusy(unsigned short)+0xc>
      return false;
    788e:	movs	r0, #0
    7890:	pop	{r4, r5, r6, pc}
    }
  }
  return true;
    7892:	movs	r0, #1
#endif  // WDT_YIELD_TIME_MILLIS
}
    7894:	pop	{r4, r5, r6, pc}

00007896 <SdSpiCard::cardCommand(unsigned char, unsigned long)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    7896:	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    7898:	ldrb	r3, [r0, #12]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    789a:	str	r2, [sp, #4]
    789c:	mov	r4, r0
    789e:	mov	r5, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != IDLE_STATE && !syncDevice()) {
    78a0:	cbz	r3, 78ae <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x18>
    78a2:	ldr	r3, [r0, #0]
    78a4:	ldr	r3, [r3, #28]
    78a6:	blx	r3
    78a8:	cbnz	r0, 78ae <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x18>
    return 0XFF;
    78aa:	movs	r0, #255	; 0xff
    78ac:	b.n	790e <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x78>
  }
#endif  // ENABLE_DEDICATED_SPI
  // select card
  if (!m_spiActive) {
    78ae:	ldrb	r3, [r4, #16]
    78b0:	cbnz	r3, 78b8 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x22>
    spiStart();
    78b2:	mov	r0, r4
    78b4:	bl	76b0 <SdSpiCard::spiStart()>
  }
  // wait if busy unless CMD0
  if (cmd != CMD0) {
    78b8:	cbz	r5, 78c4 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x2e>
    DBG_BEGIN_TIME(DBG_CMD_BUSY);
    waitNotBusy(SD_CMD_TIMEOUT);
    78ba:	mov.w	r1, #300	; 0x12c
    78be:	mov	r0, r4
    78c0:	bl	786e <SdSpiCard::waitNotBusy(unsigned short)>

  // send message
  spiSend(buf, 6);
#else  // USE_SD_CRC
  // send command
  spiSend(cmd | 0x40);
    78c4:	orr.w	r1, r5, #64	; 0x40
    78c8:	ldr	r0, [r4, #4]
    78ca:	bl	7690 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    78ce:	add.w	r6, sp, #7
    78d2:	add.w	r7, sp, #3

  // send argument
  uint8_t* pa = reinterpret_cast<uint8_t*>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    spiSend(pa[i]);
    78d6:	ldrb.w	r1, [r6], #-1
    78da:	ldr	r0, [r4, #4]
    78dc:	bl	7690 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
  // send command
  spiSend(cmd | 0x40);

  // send argument
  uint8_t* pa = reinterpret_cast<uint8_t*>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    78e0:	cmp	r7, r6
    78e2:	bne.n	78d6 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x40>
    spiSend(pa[i]);
  }

  // send CRC - correct for CMD0 with arg zero or CMD8 with arg 0X1AA
  spiSend(cmd == CMD0 ? 0X95 : 0X87);
    78e4:	cmp	r5, #0
    78e6:	ite	eq
    78e8:	moveq	r1, #149	; 0x95
    78ea:	movne	r1, #135	; 0x87
    78ec:	ldr	r0, [r4, #4]
    78ee:	bl	7690 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
#endif  // USE_SD_CRC

  // discard first fill byte to avoid MISO pull-up problem.
  spiReceive();
    78f2:	ldr	r0, [r4, #4]
    78f4:	bl	7696 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    78f8:	movs	r5, #11

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
    78fa:	ldr	r0, [r4, #4]
    78fc:	bl	7696 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7900:	lsls	r3, r0, #24
    7902:	strb	r0, [r4, #17]
    7904:	bpl.n	790e <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x78>
    7906:	subs	r5, #1
    7908:	ands.w	r5, r5, #255	; 0xff
    790c:	bne.n	78fa <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x64>
  }
  return m_status;
}
    790e:	add	sp, #12
    7910:	pop	{r4, r5, r6, r7, pc}

00007912 <SdSpiCard::cardAcmd(unsigned char, unsigned long)>:
  /** Set CS high and deactivate the card. */
  void spiStop();

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    7912:	push	{r4, r5, r6, lr}
    7914:	mov	r4, r0
    7916:	mov	r5, r1
    7918:	mov	r6, r2
    cardCommand(CMD55, 0);
    791a:	movs	r1, #55	; 0x37
    791c:	movs	r2, #0
    791e:	bl	7896 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    return cardCommand(cmd, arg);
    7922:	mov	r2, r6
    7924:	mov	r1, r5
    7926:	mov	r0, r4
  }
    7928:	ldmia.w	sp!, {r4, r5, r6, lr}

 private:
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    cardCommand(CMD55, 0);
    return cardCommand(cmd, arg);
    792c:	b.w	7896 <SdSpiCard::cardCommand(unsigned char, unsigned long)>

00007930 <SdSpiCard::begin(SdSpiConfig)>:
#endif  // CRC_CCITT
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
    7930:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7934:	sub	sp, #36	; 0x24
    7936:	add	r5, sp, #4
    7938:	stmia.w	r5, {r1, r2, r3}
    793c:	mov	r4, r0
    793e:	ldrb.w	sl, [sp, #4]
    7942:	ldr.w	fp, [sp, #12]
    7946:	ldrb.w	r8, [sp, #5]
    794a:	ldr	r6, [sp, #8]
  SdMillis_t t0 = SysCall::curTimeMS();
    794c:	bl	769c <SysCall::curTimeMS()>
  m_spiActive = false;
    7950:	mov.w	r9, #0
#endif  // USE_SD_CRC
//==============================================================================
// SdSpiCard member functions
//------------------------------------------------------------------------------
bool SdSpiCard::begin(SdSpiConfig spiConfig) {
  SdMillis_t t0 = SysCall::curTimeMS();
    7954:	mov	r7, r0
  m_spiActive = false;
    7956:	strb.w	r9, [r4, #16]
  m_errorCode = SD_CARD_ERROR_NONE;
    795a:	strb.w	r9, [r4, #15]
  m_type = 0;
    795e:	strb.w	r9, [r4, #18]
  m_csPin = spiConfig.csPin;
    7962:	strb.w	sl, [r4, #14]
#if SPI_DRIVER_SELECT >= 2
  m_spiDriverPtr = spiConfig.spiPort;
    7966:	str.w	fp, [r4, #4]
  if (!m_spiDriverPtr) {
    796a:	cmp.w	fp, #0
    796e:	bne.n	7974 <SdSpiCard::begin(SdSpiConfig)+0x44>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7970:	movs	r3, #42	; 0x2a
    7972:	b.n	7aa8 <SdSpiCard::begin(SdSpiConfig)+0x178>
    error(SD_CARD_ERROR_INVALID_CARD_CONFIG);
    goto fail;
  }
#endif  // SPI_DRIVER_SELECT
  sdCsInit(m_csPin);
    7974:	mov	r0, sl
    7976:	bl	1af0 <sdCsInit(unsigned char)>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    797a:	movs	r1, #1
    797c:	ldrb	r0, [r4, #14]
    797e:	bl	1b0c <sdCsWrite(unsigned char, bool)>
    7982:	ldr	r0, [r4, #4]
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
  }
  void spiSetSckSpeed(uint32_t maxSck) {
    m_spiDriverPtr->setSckSpeed(maxSck);
    7984:	ldr	r1, [pc, #344]	; (7ae0 <SdSpiCard::begin(SdSpiConfig)+0x1b0>)
    7986:	ldr	r3, [r0, #0]
    7988:	ldr	r3, [r3, #28]
    798a:	blx	r3
    798c:	ldmia.w	r5, {r0, r1, r2}
    7990:	add	r3, sp, #20
    7992:	ldr.w	lr, [r4, #4]
    7996:	stmia.w	r3, {r0, r1, r2}
#else  // SPI_DRIVER_SELECT < 2
  void spiActivate() {
    m_spiDriverPtr->activate();
  }
  void spiBegin(SdSpiConfig spiConfig) {
    m_spiDriverPtr->begin(spiConfig);
    799a:	ldr.w	r2, [lr]
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
  m_sharedSpi = spiOptionShared(spiConfig.options);
    799e:	and.w	r8, r8, #1
    79a2:	mov	r0, lr
    79a4:	ldr	r5, [r2, #4]
    79a6:	eor.w	r8, r8, #1
    79aa:	ldmia	r3, {r1, r2, r3}
    79ac:	blx	r5
#else  // ENABLE_DEDICATED_SPI
  // m_sharedSpi is a static const bool in this case.
  static_assert(m_sharedSpi == true, "m_sharedSpi bug");
#endif  // ENABLE_DEDICATED_SPI
  spiStart();
    79ae:	mov	r0, r4
  spiUnselect();
  spiSetSckSpeed(1000UL*SD_MAX_INIT_RATE_KHZ);
  spiBegin(spiConfig);
  uint32_t arg;
#if ENABLE_DEDICATED_SPI
  m_curState = IDLE_STATE;
    79b0:	strb.w	r9, [r4, #12]
  m_sharedSpi = spiOptionShared(spiConfig.options);
    79b4:	strb.w	r8, [r4, #13]
#else  // ENABLE_DEDICATED_SPI
  // m_sharedSpi is a static const bool in this case.
  static_assert(m_sharedSpi == true, "m_sharedSpi bug");
#endif  // ENABLE_DEDICATED_SPI
  spiStart();
    79b8:	bl	76b0 <SdSpiCard::spiStart()>
  }
  void type(uint8_t value) {
    m_type = value;
  }
  void spiUnselect() {
    sdCsWrite(m_csPin, true);
    79bc:	movs	r1, #1
    79be:	ldrb	r0, [r4, #14]
    79c0:	bl	1b0c <sdCsWrite(unsigned char, bool)>
    79c4:	movs	r5, #10

  // must supply min of 74 clock cycles with CS high.
  spiUnselect();
  for (uint8_t i = 0; i < 10; i++) {
    spiSend(0XFF);
    79c6:	movs	r1, #255	; 0xff
    79c8:	ldr	r0, [r4, #4]
    79ca:	subs	r5, #1
    79cc:	bl	7690 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
#endif  // ENABLE_DEDICATED_SPI
  spiStart();

  // must supply min of 74 clock cycles with CS high.
  spiUnselect();
  for (uint8_t i = 0; i < 10; i++) {
    79d0:	ands.w	r5, r5, #255	; 0xff
    79d4:	bne.n	79c6 <SdSpiCard::begin(SdSpiConfig)+0x96>
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  bool isTimedOut(SdMillis_t startMS, SdMillis_t timeoutMS);
  bool readData(uint8_t* dst, size_t count);
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
    79d6:	mov	r1, r5
    79d8:	ldrb	r0, [r4, #14]
    79da:	bl	1b0c <sdCsWrite(unsigned char, bool)>
    79de:	movs	r5, #10
  spiSelect();
  DBG_BEGIN_TIME(DBG_CMD0_TIME);
  // command to go idle in SPI mode
  for (uint8_t i = 1;; i++) {
    DBG_EVENT_COUNT(DBG_CMD0_COUNT);
    if (cardCommand(CMD0, 0) == R1_IDLE_STATE) {
    79e0:	movs	r2, #0
    79e2:	mov	r1, r2
    79e4:	mov	r0, r4
    79e6:	bl	7896 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    79ea:	cmp	r0, #1
    79ec:	mov	r8, r0
    79ee:	beq.n	7a16 <SdSpiCard::begin(SdSpiConfig)+0xe6>
    79f0:	subs	r5, #1
      break;
    }
    if (i == SD_CMD0_RETRY) {
    79f2:	ands.w	r5, r5, #255	; 0xff
    79f6:	bne.n	79fc <SdSpiCard::begin(SdSpiConfig)+0xcc>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    79f8:	movs	r3, #1
    79fa:	b.n	7aa8 <SdSpiCard::begin(SdSpiConfig)+0x178>
      error(SD_CARD_ERROR_CMD0);
      goto fail;
    }
    // stop multi-block write
    spiSend(STOP_TRAN_TOKEN);
    79fc:	movs	r1, #253	; 0xfd
    79fe:	ldr	r0, [r4, #4]
    7a00:	bl	7690 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    7a04:	mov.w	r8, #520	; 0x208
    // finish block transfer
    for (int i = 0; i < 520; i++) {
      spiReceive();
    7a08:	ldr	r0, [r4, #4]
    7a0a:	bl	7696 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
      goto fail;
    }
    // stop multi-block write
    spiSend(STOP_TRAN_TOKEN);
    // finish block transfer
    for (int i = 0; i < 520; i++) {
    7a0e:	subs.w	r8, r8, #1
    7a12:	bne.n	7a08 <SdSpiCard::begin(SdSpiConfig)+0xd8>
    7a14:	b.n	79e0 <SdSpiCard::begin(SdSpiConfig)+0xb0>
    goto fail;
  }
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    7a16:	mov.w	r2, #426	; 0x1aa
    7a1a:	movs	r1, #8
    7a1c:	mov	r0, r4
    7a1e:	bl	7896 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7a22:	lsls	r3, r0, #29
    7a24:	bmi.n	7a44 <SdSpiCard::begin(SdSpiConfig)+0x114>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    7a26:	movs	r3, #2
    7a28:	strb	r3, [r4, #18]
    7a2a:	movs	r5, #4
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
      m_status = spiReceive();
    7a2c:	ldr	r0, [r4, #4]
    7a2e:	bl	7696 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7a32:	subs	r5, #1
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    7a34:	ands.w	r5, r5, #255	; 0xff
      m_status = spiReceive();
    7a38:	strb	r0, [r4, #17]
#endif  // USE_SD_CRC

  // check SD version
  if (!(cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
    type(SD_CARD_TYPE_SD2);
    for (uint8_t i = 0; i < 4; i++) {
    7a3a:	bne.n	7a2c <SdSpiCard::begin(SdSpiConfig)+0xfc>
      m_status = spiReceive();
    }
    if (m_status != 0XAA) {
    7a3c:	cmp	r0, #170	; 0xaa
    7a3e:	beq.n	7a48 <SdSpiCard::begin(SdSpiConfig)+0x118>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7a40:	movs	r3, #6
    7a42:	b.n	7aa8 <SdSpiCard::begin(SdSpiConfig)+0x178>
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    7a44:	strb.w	r8, [r4, #18]
    }
  } else {
    type(SD_CARD_TYPE_SD1);
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
    7a48:	ldr	r3, [r4, #0]
    7a4a:	mov	r0, r4
    7a4c:	ldr	r3, [r3, #72]	; 0x48
    7a4e:	blx	r3
    7a50:	cmp	r0, #2
    7a52:	ite	eq
    7a54:	moveq.w	r8, #1073741824	; 0x40000000
    7a58:	movne.w	r8, #0
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    7a5c:	mov	r2, r8
    7a5e:	movs	r1, #41	; 0x29
    7a60:	mov	r0, r4
    7a62:	bl	7912 <SdSpiCard::cardAcmd(unsigned char, unsigned long)>
    7a66:	mov	r5, r0
    7a68:	cbz	r0, 7a7a <SdSpiCard::begin(SdSpiConfig)+0x14a>
  if ((SysCall::curTimeMS() - last) > WDT_YIELD_TIME_MILLIS) {
    SysCall::yield();
    last = SysCall::curTimeMS();
  }
#endif  // WDT_YIELD_TIME_MILLIS
  return (SysCall::curTimeMS() - startMS) > timeoutMS;
    7a6a:	bl	769c <SysCall::curTimeMS()>
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
  DBG_BEGIN_TIME(DBG_ACMD41_TIME);
  while (cardAcmd(ACMD41, arg) != R1_READY_STATE) {
    DBG_EVENT_COUNT(DBG_ACMD41_COUNT);
    // check for timeout
    if (isTimedOut(t0, SD_INIT_TIMEOUT)) {
    7a6e:	subs	r0, r0, r7
    7a70:	cmp.w	r0, #2000	; 0x7d0
    7a74:	ble.n	7a5c <SdSpiCard::begin(SdSpiConfig)+0x12c>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7a76:	movs	r3, #23
    7a78:	b.n	7aa8 <SdSpiCard::begin(SdSpiConfig)+0x178>
    }
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    7a7a:	ldr	r3, [r4, #0]
    7a7c:	mov	r0, r4
    7a7e:	ldr	r3, [r3, #72]	; 0x48
    7a80:	blx	r3
    7a82:	cmp	r0, #2
    7a84:	beq.n	7a9a <SdSpiCard::begin(SdSpiConfig)+0x16a>
    // Discard rest of ocr - contains allowed voltage range.
    for (uint8_t i = 0; i < 3; i++) {
      spiReceive();
    }
  }
  spiStop();
    7a86:	mov	r0, r4
    7a88:	bl	76d6 <SdSpiCard::spiStop()>
    7a8c:	ldr	r0, [r4, #4]
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
  }
  void spiSetSckSpeed(uint32_t maxSck) {
    m_spiDriverPtr->setSckSpeed(maxSck);
    7a8e:	ldr	r3, [r0, #0]
    7a90:	mov	r1, r6
    7a92:	ldr	r3, [r3, #28]
    7a94:	blx	r3
  spiSetSckSpeed(spiConfig.maxSck);
  return true;
    7a96:	movs	r0, #1
    7a98:	b.n	7ada <SdSpiCard::begin(SdSpiConfig)+0x1aa>
  }
  DBG_END_TIME(DBG_ACMD41_TIME);

  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
    7a9a:	mov	r2, r5
    7a9c:	movs	r1, #58	; 0x3a
    7a9e:	mov	r0, r4
    7aa0:	bl	7896 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7aa4:	cbz	r0, 7ab4 <SdSpiCard::begin(SdSpiConfig)+0x184>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7aa6:	movs	r3, #18
  spiStop();
  spiSetSckSpeed(spiConfig.maxSck);
  return true;

 fail:
  spiStop();
    7aa8:	mov	r0, r4
    7aaa:	strb	r3, [r4, #15]
    7aac:	bl	76d6 <SdSpiCard::spiStop()>
  return false;
    7ab0:	movs	r0, #0
    7ab2:	b.n	7ada <SdSpiCard::begin(SdSpiConfig)+0x1aa>
  if (type() == SD_CARD_TYPE_SD2) {
    if (cardCommand(CMD58, 0)) {
      error(SD_CARD_ERROR_CMD58);
      goto fail;
    }
    if ((spiReceive() & 0XC0) == 0XC0) {
    7ab4:	ldr	r0, [r4, #4]
    7ab6:	bl	7696 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7aba:	and.w	r0, r0, #192	; 0xc0
    7abe:	cmp	r0, #192	; 0xc0
  bool readRegister(uint8_t cmd, void* buf);
  void spiSelect() {
    sdCsWrite(m_csPin, false);
  }
  void type(uint8_t value) {
    m_type = value;
    7ac0:	itt	eq
    7ac2:	moveq	r3, #3
    7ac4:	strbeq	r3, [r4, #18]
      type(SD_CARD_TYPE_SDHC);
    }
    // Discard rest of ocr - contains allowed voltage range.
    for (uint8_t i = 0; i < 3; i++) {
      spiReceive();
    7ac6:	ldr	r0, [r4, #4]
    7ac8:	bl	7696 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7acc:	ldr	r0, [r4, #4]
    7ace:	bl	7696 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7ad2:	ldr	r0, [r4, #4]
    7ad4:	bl	7696 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7ad8:	b.n	7a86 <SdSpiCard::begin(SdSpiConfig)+0x156>
  return true;

 fail:
  spiStop();
  return false;
}
    7ada:	add	sp, #36	; 0x24
    7adc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7ae0:	.word	0x00061a80

00007ae4 <SdSpiCard::readOCR(unsigned long*)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7ae4:	push	{r4, r5, r6, lr}
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    7ae6:	movs	r2, #0
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7ae8:	mov	r6, r1
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    7aea:	movs	r1, #58	; 0x3a
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    7aec:	mov	r4, r0
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    7aee:	bl	7896 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7af2:	cbz	r0, 7b02 <SdSpiCard::readOCR(unsigned long*)+0x1e>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7af4:	movs	r3, #18
  }
  spiStop();
  return true;

 fail:
  spiStop();
    7af6:	mov	r0, r4
    7af8:	strb	r3, [r4, #15]
    7afa:	bl	76d6 <SdSpiCard::spiStop()>
  return false;
    7afe:	movs	r0, #0
    7b00:	pop	{r4, r5, r6, pc}
    7b02:	adds	r5, r6, #4
  if (cardCommand(CMD58, 0)) {
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    p[3 - i] = spiReceive();
    7b04:	ldr	r0, [r4, #4]
    7b06:	bl	7696 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7b0a:	strb.w	r0, [r5, #-1]!
  uint8_t* p = reinterpret_cast<uint8_t*>(ocr);
  if (cardCommand(CMD58, 0)) {
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    7b0e:	cmp	r5, r6
    7b10:	bne.n	7b04 <SdSpiCard::readOCR(unsigned long*)+0x20>
    p[3 - i] = spiReceive();
  }
  spiStop();
    7b12:	mov	r0, r4
    7b14:	bl	76d6 <SdSpiCard::spiStop()>
  return true;
    7b18:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7b1a:	pop	{r4, r5, r6, pc}

00007b1c <SdSpiCard::readRegister(unsigned char, void*)>:
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    7b1c:	push	{r3, r4, r5, lr}
    7b1e:	mov	r5, r2
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    7b20:	movs	r2, #0
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    7b22:	mov	r4, r0
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  if (cardCommand(cmd, 0)) {
    7b24:	bl	7896 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7b28:	cbz	r0, 7b30 <SdSpiCard::readRegister(unsigned char, void*)+0x14>
    7b2a:	movs	r3, #27
    7b2c:	strb	r3, [r4, #15]
    7b2e:	b.n	7b46 <SdSpiCard::readRegister(unsigned char, void*)+0x2a>
    error(SD_CARD_ERROR_READ_REG);
    goto fail;
  }
  if (!readData(dst, 16)) {
    7b30:	mov	r1, r5
    7b32:	movs	r2, #16
    7b34:	mov	r0, r4
    7b36:	bl	772e <SdSpiCard::readData(unsigned char*, unsigned int)>
    7b3a:	mov	r5, r0
    7b3c:	cbz	r0, 7b46 <SdSpiCard::readRegister(unsigned char, void*)+0x2a>
    goto fail;
  }
  spiStop();
    7b3e:	mov	r0, r4
    7b40:	bl	76d6 <SdSpiCard::spiStop()>
  return true;
    7b44:	b.n	7b4e <SdSpiCard::readRegister(unsigned char, void*)+0x32>

 fail:
  spiStop();
    7b46:	mov	r0, r4
    7b48:	bl	76d6 <SdSpiCard::spiStop()>
  return false;
    7b4c:	movs	r5, #0
}
    7b4e:	mov	r0, r5
    7b50:	pop	{r3, r4, r5, pc}

00007b52 <SdSpiCard::readCSD(csd_t*)>:
   * \param[out] csd pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCSD(csd_t* csd) {
    return readRegister(CMD9, csd);
    7b52:	mov	r2, r1
    7b54:	movs	r1, #9
    7b56:	b.w	7b1c <SdSpiCard::readRegister(unsigned char, void*)>

00007b5a <SdSpiCard::readCID(CID*)>:
   * \param[out] cid pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCID(cid_t* cid) {
    return readRegister(CMD10, cid);
    7b5a:	mov	r2, r1
    7b5c:	movs	r1, #10
    7b5e:	b.w	7b1c <SdSpiCard::readRegister(unsigned char, void*)>

00007b62 <SdSpiCard::readStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    7b62:	push	{r3, r4, r5, lr}
  if (type() != SD_CARD_TYPE_SDHC) {
    7b64:	ldr	r3, [r0, #0]
    7b66:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    7b68:	mov	r5, r1
    7b6a:	mov	r4, r0
  if (type() != SD_CARD_TYPE_SDHC) {
    7b6c:	blx	r3
    7b6e:	cmp	r0, #3
    sector <<= 9;
    7b70:	it	ne
    7b72:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD18, sector)) {
    7b74:	mov	r2, r5
    7b76:	movs	r1, #18
    7b78:	mov	r0, r4
    7b7a:	bl	7896 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7b7e:	cbz	r0, 7b8e <SdSpiCard::readStart(unsigned long)+0x2c>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7b80:	movs	r3, #12
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7b82:	mov	r0, r4
    7b84:	strb	r3, [r4, #15]
    7b86:	bl	76d6 <SdSpiCard::spiStop()>
  return false;
    7b8a:	movs	r0, #0
    7b8c:	pop	{r3, r4, r5, pc}
  }
  if (cardCommand(CMD18, sector)) {
    error(SD_CARD_ERROR_CMD18);
    goto fail;
  }
  return true;
    7b8e:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7b90:	pop	{r3, r4, r5, pc}

00007b92 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    7b92:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7b96:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7b98:	ldrb	r3, [r0, #12]
    7b9a:	cmp	r3, #1
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    7b9c:	mov	r4, r0
    7b9e:	mov	r5, r1
    7ba0:	mov	r6, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7ba2:	bne.n	7baa <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x18>
    7ba4:	ldr	r3, [r0, #8]
    7ba6:	cmp	r3, r1
    7ba8:	beq.n	7bc0 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x2e>
    if (!readStart(sector)) {
    7baa:	mov	r1, r5
    7bac:	mov	r0, r4
    7bae:	bl	7b62 <SdSpiCard::readStart(unsigned long)>
    7bb2:	cbnz	r0, 7bba <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x28>
    }
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
    7bb4:	movs	r0, #0
    7bb6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
    7bba:	movs	r3, #1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    7bbc:	str	r5, [r4, #8]
    m_curState = READ_STATE;
    7bbe:	strb	r3, [r4, #12]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    7bc0:	movs	r5, #0
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    7bc2:	cmp	r5, r7
    7bc4:	add.w	r1, r6, r5, lsl #9
    7bc8:	beq.n	7bdc <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4a>
    if (!readData(dst, 512)) {
    7bca:	mov.w	r2, #512	; 0x200
    7bce:	mov	r0, r4
    7bd0:	bl	772e <SdSpiCard::readData(unsigned char*, unsigned int)>
    7bd4:	cmp	r0, #0
    7bd6:	beq.n	7bb4 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x22>
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    7bd8:	adds	r5, #1
    7bda:	b.n	7bc2 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x30>
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    7bdc:	ldr	r3, [r4, #8]
    7bde:	add	r5, r3
  return m_sharedSpi ? syncDevice() : true;
    7be0:	ldrb	r3, [r4, #13]
  for (size_t i = 0; i < ns; i++, dst += 512) {
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
    7be2:	str	r5, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    7be4:	cbz	r3, 7bf2 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x60>
    7be6:	ldr	r3, [r4, #0]
    7be8:	mov	r0, r4
    7bea:	ldr	r3, [r3, #28]
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7bec:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if (!readData(dst, 512)) {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7bf0:	bx	r3
    7bf2:	movs	r0, #1
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7bf4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00007bf8 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)>:
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7bf8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7bfc:	mov	r6, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7bfe:	ldrb	r3, [r0, #12]
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7c00:	ldr.w	r8, [sp, #32]
    7c04:	ldr.w	r9, [sp, #36]	; 0x24
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7c08:	cmp	r3, #1
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectorsCallback(uint32_t sector, uint8_t* dst, size_t ns,
 void (*callback)(uint32_t sector, uint8_t *buf, void *context), void *context) {
    7c0a:	mov	r4, r0
    7c0c:	mov	r5, r1
    7c0e:	mov	r7, r2
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    7c10:	bne.n	7c18 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x20>
    7c12:	ldr	r3, [r0, #8]
    7c14:	cmp	r3, r1
    7c16:	beq.n	7c2e <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x36>
    if (!readStart(sector)) {
    7c18:	mov	r1, r5
    7c1a:	mov	r0, r4
    7c1c:	bl	7b62 <SdSpiCard::readStart(unsigned long)>
    7c20:	cbnz	r0, 7c28 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x30>
    }
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
    7c22:	movs	r0, #0
    7c24:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
    7c28:	movs	r3, #1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!readStart(sector)) {
      goto fail;
    }
    m_curSector = sector;
    7c2a:	str	r5, [r4, #8]
    m_curState = READ_STATE;
    7c2c:	strb	r3, [r4, #12]
    7c2e:	add.w	sl, r5, r6
  }
  for (size_t i = 0; i < ns; i++) {
    7c32:	cmp	r5, sl
    7c34:	beq.n	7c52 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x5a>
    if (readData(dst, 512)) {
    7c36:	mov.w	r2, #512	; 0x200
    7c3a:	mov	r1, r7
    7c3c:	mov	r0, r4
    7c3e:	bl	772e <SdSpiCard::readData(unsigned char*, unsigned int)>
    7c42:	cmp	r0, #0
    7c44:	beq.n	7c22 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x2a>
      callback(sector + i, dst, context);
    7c46:	mov	r0, r5
    7c48:	mov	r2, r9
    7c4a:	mov	r1, r7
    7c4c:	blx	r8
    7c4e:	adds	r5, #1
      goto fail;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++) {
    7c50:	b.n	7c32 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x3a>
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    7c52:	ldr	r3, [r4, #8]
    7c54:	add	r6, r3
  return m_sharedSpi ? syncDevice() : true;
    7c56:	ldrb	r3, [r4, #13]
      callback(sector + i, dst, context);
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
    7c58:	str	r6, [r4, #8]
  return m_sharedSpi ? syncDevice() : true;
    7c5a:	cbz	r3, 7c68 <SdSpiCard::readSectorsCallback(unsigned long, unsigned char*, unsigned int, void (*)(unsigned long, unsigned char*, void*), void*)+0x70>
    7c5c:	ldr	r3, [r4, #0]
    7c5e:	mov	r0, r4
    7c60:	ldr	r3, [r3, #28]
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7c62:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    } else {
      goto fail;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    7c66:	bx	r3
    7c68:	movs	r0, #1
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
    7c6a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00007c6e <SdSpiCard::readStop()>:
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    7c6e:	push	{r4, lr}
  if (cardCommand(CMD12, 0)) {
    7c70:	movs	r2, #0
    7c72:	movs	r1, #12
#endif  // ENABLE_DEDICATED_SPI
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    7c74:	mov	r4, r0
  if (cardCommand(CMD12, 0)) {
    7c76:	bl	7896 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7c7a:	cbz	r0, 7c8a <SdSpiCard::readStop()+0x1c>
    7c7c:	movs	r3, #9
  }
  spiStop();
  return true;

 fail:
  spiStop();
    7c7e:	mov	r0, r4
    7c80:	strb	r3, [r4, #15]
    7c82:	bl	76d6 <SdSpiCard::spiStop()>
  return false;
    7c86:	movs	r0, #0
    7c88:	pop	{r4, pc}
bool SdSpiCard::readStop() {
  if (cardCommand(CMD12, 0)) {
    error(SD_CARD_ERROR_CMD12);
    goto fail;
  }
  spiStop();
    7c8a:	mov	r0, r4
    7c8c:	bl	76d6 <SdSpiCard::spiStop()>
  return true;
    7c90:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7c92:	pop	{r4, pc}

00007c94 <SdSpiCard::syncDevice()>:
}
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
    7c94:	ldrb	r2, [r0, #12]
  m_curState = IDLE_STATE;
    7c96:	movs	r1, #0
  if (state == WRITE_STATE) {
    7c98:	cmp	r2, #2
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  // Insure no recursive loop with cardCommand().
  uint8_t state = m_curState;
  m_curState = IDLE_STATE;
    7c9a:	strb	r1, [r0, #12]
  if (state == WRITE_STATE) {
    7c9c:	bne.n	7ca4 <SdSpiCard::syncDevice()+0x10>
    return writeStop();
    7c9e:	ldr	r3, [r0, #0]
    7ca0:	ldr	r3, [r3, #84]	; 0x54
    7ca2:	bx	r3
  }
  if (state == READ_STATE) {
    7ca4:	cmp	r2, #1
    7ca6:	bne.n	7cac <SdSpiCard::syncDevice()+0x18>
    return readStop();
    7ca8:	b.w	7c6e <SdSpiCard::readStop()>
  }
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
    7cac:	movs	r0, #1
    7cae:	bx	lr

00007cb0 <SdSpiCard::writeStart(unsigned long)>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    7cb0:	push	{r3, r4, r5, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7cb2:	ldr	r3, [r0, #0]
    7cb4:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    7cb6:	mov	r5, r1
    7cb8:	mov	r4, r0
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7cba:	blx	r3
    7cbc:	cmp	r0, #3
    sector <<= 9;
    7cbe:	it	ne
    7cc0:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD25, sector)) {
    7cc2:	mov	r2, r5
    7cc4:	movs	r1, #25
    7cc6:	mov	r0, r4
    7cc8:	bl	7896 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7ccc:	cbz	r0, 7cdc <SdSpiCard::writeStart(unsigned long)+0x2c>
    7cce:	movs	r3, #14
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7cd0:	mov	r0, r4
    7cd2:	strb	r3, [r4, #15]
    7cd4:	bl	76d6 <SdSpiCard::spiStop()>
  return false;
    7cd8:	movs	r0, #0
    7cda:	pop	{r3, r4, r5, pc}
  }
  if (cardCommand(CMD25, sector)) {
    error(SD_CARD_ERROR_CMD25);
    goto fail;
  }
  return true;
    7cdc:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7cde:	pop	{r3, r4, r5, pc}

00007ce0 <SdSpiCard::erase(unsigned long, unsigned long)>:
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7ce0:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  csd_t csd;
  if (!readCSD(&csd)) {
    7ce2:	ldr	r3, [r0, #0]
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7ce4:	mov	r6, r1
  csd_t csd;
  if (!readCSD(&csd)) {
    7ce6:	ldr	r3, [r3, #60]	; 0x3c
    7ce8:	mov	r1, sp
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    7cea:	mov	r4, r0
    7cec:	mov	r5, r2
  csd_t csd;
  if (!readCSD(&csd)) {
    7cee:	blx	r3
    7cf0:	cbz	r0, 7d58 <SdSpiCard::erase(unsigned long, unsigned long)+0x78>
    goto fail;
  }
  // check for single sector erase
  if (!csd.v1.erase_blk_en) {
    7cf2:	ldrb.w	r3, [sp, #10]
    7cf6:	lsls	r2, r3, #25
    7cf8:	bmi.n	7d14 <SdSpiCard::erase(unsigned long, unsigned long)+0x34>
    // erase size mask
    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
    7cfa:	ldrb.w	r2, [sp, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    7cfe:	and.w	r3, r3, #63	; 0x3f
    7d02:	lsls	r3, r3, #1
    7d04:	orr.w	r3, r3, r2, lsr #7
    7d08:	adds	r2, r5, #1
    7d0a:	orrs	r2, r6
    7d0c:	tst	r3, r2
    7d0e:	beq.n	7d14 <SdSpiCard::erase(unsigned long, unsigned long)+0x34>
    7d10:	movs	r3, #39	; 0x27
    7d12:	b.n	7d56 <SdSpiCard::erase(unsigned long, unsigned long)+0x76>
      // error card can't erase specified area
      error(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    7d14:	ldrb	r3, [r4, #18]
    7d16:	cmp	r3, #3
    firstSector <<= 9;
    7d18:	it	ne
    7d1a:	lslne	r6, r6, #9
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
    7d1c:	mov	r2, r6
    7d1e:	mov.w	r1, #32
    7d22:	mov	r0, r4
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
    7d24:	it	ne
    7d26:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD32, firstSector)
    7d28:	bl	7896 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
      || cardCommand(CMD33, lastSector)
      || cardCommand(CMD38, 0)) {
    7d2c:	cbnz	r0, 7d62 <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
      || cardCommand(CMD33, lastSector)
    7d2e:	mov	r2, r5
    7d30:	movs	r1, #33	; 0x21
    7d32:	mov	r0, r4
    7d34:	bl	7896 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7d38:	mov	r2, r0
    7d3a:	cbnz	r0, 7d62 <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
      || cardCommand(CMD38, 0)) {
    7d3c:	movs	r1, #38	; 0x26
    7d3e:	mov	r0, r4
    7d40:	bl	7896 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7d44:	cbnz	r0, 7d62 <SdSpiCard::erase(unsigned long, unsigned long)+0x82>
    error(SD_CARD_ERROR_ERASE);
    goto fail;
  }
  DBG_BEGIN_TIME(DBG_ERASE_BUSY);
  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    7d46:	movw	r1, #10000	; 0x2710
    7d4a:	mov	r0, r4
    7d4c:	bl	786e <SdSpiCard::waitNotBusy(unsigned short)>
    7d50:	mov	r5, r0
    7d52:	cbnz	r0, 7d66 <SdSpiCard::erase(unsigned long, unsigned long)+0x86>
    7d54:	movs	r3, #40	; 0x28
    7d56:	strb	r3, [r4, #15]
  DBG_END_TIME(DBG_ERASE_BUSY);
  spiStop();
  return true;

 fail:
  spiStop();
    7d58:	mov	r0, r4
    7d5a:	bl	76d6 <SdSpiCard::spiStop()>
  return false;
    7d5e:	movs	r5, #0
    7d60:	b.n	7d6c <SdSpiCard::erase(unsigned long, unsigned long)+0x8c>
    7d62:	movs	r3, #38	; 0x26
    7d64:	b.n	7d56 <SdSpiCard::erase(unsigned long, unsigned long)+0x76>
  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    error(SD_CARD_ERROR_ERASE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_ERASE_BUSY);
  spiStop();
    7d66:	mov	r0, r4
    7d68:	bl	76d6 <SdSpiCard::spiStop()>
  return true;

 fail:
  spiStop();
  return false;
}
    7d6c:	mov	r0, r5
    7d6e:	add	sp, #16
    7d70:	pop	{r4, r5, r6, pc}

00007d72 <SdSpiCard::writeStop()>:
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    7d72:	push	{r3, r4, r5, lr}
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7d74:	mov.w	r1, #600	; 0x258
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    7d78:	mov	r4, r0
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7d7a:	bl	786e <SdSpiCard::waitNotBusy(unsigned short)>
    7d7e:	mov	r5, r0
    7d80:	cbz	r0, 7d8c <SdSpiCard::writeStop()+0x1a>
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_STOP);
  spiSend(STOP_TRAN_TOKEN);
    7d82:	movs	r1, #253	; 0xfd
    7d84:	ldr	r0, [r4, #4]
    7d86:	bl	7690 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    7d8a:	b.n	7d90 <SdSpiCard::writeStop()+0x1e>
    7d8c:	movs	r3, #30
    7d8e:	strb	r3, [r4, #15]
  spiStop();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
    7d90:	mov	r0, r4
    7d92:	bl	76d6 <SdSpiCard::spiStop()>
  return false;
}
    7d96:	mov	r0, r5
    7d98:	pop	{r3, r4, r5, pc}

00007d9a <SdSpiCard::writeData(unsigned char, unsigned char const*)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one sector of data for write sector or write multiple sectors
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    7d9a:	push	{r3, r4, r5, lr}
    7d9c:	mov	r4, r0
#if USE_SD_CRC
  uint16_t crc = CRC_CCITT(src, 512);
#else  // USE_SD_CRC
  uint16_t crc = 0XFFFF;
#endif  // USE_SD_CRC
  spiSend(token);
    7d9e:	ldr	r0, [r0, #4]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one sector of data for write sector or write multiple sectors
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    7da0:	mov	r5, r2
#if USE_SD_CRC
  uint16_t crc = CRC_CCITT(src, 512);
#else  // USE_SD_CRC
  uint16_t crc = 0XFFFF;
#endif  // USE_SD_CRC
  spiSend(token);
    7da2:	bl	7690 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
    7da6:	ldr	r0, [r4, #4]
  }
  void spiSend(uint8_t data) {
    m_spiDriverPtr->send(data);
  }
  void spiSend(const uint8_t* buf, size_t n) {
    m_spiDriverPtr->send(buf, n);
    7da8:	ldr	r3, [r0, #0]
    7daa:	mov.w	r2, #512	; 0x200
    7dae:	ldr	r3, [r3, #24]
    7db0:	mov	r1, r5
    7db2:	blx	r3
  spiSend(src, 512);
  spiSend(crc >> 8);
    7db4:	movs	r1, #255	; 0xff
    7db6:	ldr	r0, [r4, #4]
    7db8:	bl	7690 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>
  spiSend(crc & 0XFF);
    7dbc:	movs	r1, #255	; 0xff
    7dbe:	ldr	r0, [r4, #4]
    7dc0:	bl	7690 <SdSpiCard::spiSend(unsigned char) [clone .isra.10] [clone .constprop.32]>

  m_status = spiReceive();
    7dc4:	ldr	r0, [r4, #4]
    7dc6:	bl	7696 <SdSpiCard::spiReceive() [clone .isra.8] [clone .constprop.34]>
    7dca:	strb	r0, [r4, #17]
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    7dcc:	and.w	r0, r0, #31
    7dd0:	cmp	r0, #5
    7dd2:	beq.n	7de2 <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x48>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    7dd4:	movs	r3, #32
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7dd6:	mov	r0, r4
    7dd8:	strb	r3, [r4, #15]
    7dda:	bl	76d6 <SdSpiCard::spiStop()>
  return false;
    7dde:	movs	r0, #0
    7de0:	pop	{r3, r4, r5, pc}
  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    error(SD_CARD_ERROR_WRITE_DATA);
    goto fail;
  }
  return true;
    7de2:	movs	r0, #1

 fail:
  spiStop();
  return false;
}
    7de4:	pop	{r3, r4, r5, pc}

00007de6 <SdSpiCard::writeData(unsigned char const*)>:
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    7de6:	push	{r3, r4, r5, lr}
    7de8:	mov	r5, r1
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7dea:	mov.w	r1, #600	; 0x258
  }
  return true;
#endif  // WDT_YIELD_TIME_MILLIS
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    7dee:	mov	r4, r0
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    7df0:	bl	786e <SdSpiCard::waitNotBusy(unsigned short)>
    7df4:	cbnz	r0, 7dfc <SdSpiCard::writeData(unsigned char const*)+0x16>
    7df6:	movs	r3, #36	; 0x24
    7df8:	strb	r3, [r4, #15]
    7dfa:	b.n	7e08 <SdSpiCard::writeData(unsigned char const*)+0x22>
    error(SD_CARD_ERROR_WRITE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_BUSY);
  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) {
    7dfc:	mov	r2, r5
    7dfe:	movs	r1, #252	; 0xfc
    7e00:	mov	r0, r4
    7e02:	bl	7d9a <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    7e06:	cbnz	r0, 7e10 <SdSpiCard::writeData(unsigned char const*)+0x2a>
    goto fail;
  }
  return true;

 fail:
  spiStop();
    7e08:	mov	r0, r4
    7e0a:	bl	76d6 <SdSpiCard::spiStop()>
  return false;
    7e0e:	movs	r0, #0
}
    7e10:	pop	{r3, r4, r5, pc}

00007e12 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7e12:	ldr	r3, [r0, #0]
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    7e14:	push	{r4, r5, r6, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7e16:	ldr	r3, [r3, #72]	; 0x48
 fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSingle(uint32_t sector, const uint8_t* src) {
    7e18:	mov	r5, r1
    7e1a:	mov	r4, r0
    7e1c:	mov	r6, r2
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    7e1e:	blx	r3
    7e20:	cmp	r0, #3
    sector <<= 9;
    7e22:	it	ne
    7e24:	lslne	r5, r5, #9
  }
  if (cardCommand(CMD24, sector)) {
    7e26:	mov	r2, r5
    7e28:	movs	r1, #24
    7e2a:	mov	r0, r4
    7e2c:	bl	7896 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    7e30:	cbz	r0, 7e38 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x26>
    7e32:	movs	r3, #13
    7e34:	strb	r3, [r4, #15]
    7e36:	b.n	7e4e <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x3c>
    error(SD_CARD_ERROR_CMD24);
    goto fail;
  }
  if (!writeData(DATA_START_SECTOR, src)) {
    7e38:	mov	r2, r6
    7e3a:	movs	r1, #254	; 0xfe
    7e3c:	mov	r0, r4
    7e3e:	bl	7d9a <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    7e42:	mov	r5, r0
    7e44:	cbz	r0, 7e4e <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x3c>
    error(SD_CARD_ERROR_CMD13);
    goto fail;
  }
#endif  // CHECK_FLASH_PROGRAMMING

  spiStop();
    7e46:	mov	r0, r4
    7e48:	bl	76d6 <SdSpiCard::spiStop()>
  return true;
    7e4c:	b.n	7e56 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)+0x44>

 fail:
  spiStop();
    7e4e:	mov	r0, r4
    7e50:	bl	76d6 <SdSpiCard::spiStop()>
  return false;
    7e54:	movs	r5, #0
}
    7e56:	mov	r0, r5
    7e58:	pop	{r4, r5, r6, pc}

00007e5a <SdSpiCard::writeSector(unsigned long, unsigned char const*)>:
   *
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    7e5a:	push	{r4}
    if (m_sharedSpi) {
    7e5c:	ldrb	r4, [r0, #13]
    7e5e:	cbz	r4, 7e68 <SdSpiCard::writeSector(unsigned long, unsigned char const*)+0xe>
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    }
  }
    7e60:	ldr.w	r4, [sp], #4
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    7e64:	b.w	7e12 <SdSpiCard::writeSingle(unsigned long, unsigned char const*)>
    } else {
      return writeSectors(sector, src, 1);
    7e68:	ldr	r3, [r0, #0]
    7e6a:	ldr	r4, [r3, #36]	; 0x24
    7e6c:	movs	r3, #1
    7e6e:	mov	ip, r4
    }
  }
    7e70:	ldr.w	r4, [sp], #4
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    if (m_sharedSpi) {
      return writeSingle(sector, src);
    } else {
      return writeSectors(sector, src, 1);
    7e74:	bx	ip
    7e76:	Address 0x00007e76 is out of bounds.


00007e78 <sdIrs()>:
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
  SDHC_IRQSIGEN = 0;
    7e78:	ldr	r2, [pc, #24]	; (7e94 <sdIrs()+0x1c>)
  m_irqstat = SDHC_IRQSTAT;
    7e7a:	ldr	r1, [pc, #28]	; (7e98 <sdIrs()+0x20>)
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
  SDHC_IRQSIGEN = 0;
    7e7c:	movs	r3, #0
    7e7e:	str	r3, [r2, #0]
  m_irqstat = SDHC_IRQSTAT;
    7e80:	ldr.w	r0, [r2, #-8]
    7e84:	str	r0, [r1, #0]
  SDHC_IRQSTAT = m_irqstat;
    7e86:	ldr	r1, [r1, #0]
    7e88:	str.w	r1, [r2, #-8]
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN);
#endif
  m_dmaBusy = false;
    7e8c:	ldr	r2, [pc, #12]	; (7e9c <sdIrs()+0x24>)
    7e8e:	strb	r3, [r2, #0]
    7e90:	bx	lr
    7e92:	nop
    7e94:	.word	0x400b1038
    7e98:	.word	0x2001ceec
    7e9c:	.word	0x2001cf01

00007ea0 <isBusyCommandComplete()>:
static bool isBusyCMD13() {
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
}
//------------------------------------------------------------------------------
static bool isBusyCommandComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_CC | SDHC_IRQSTAT_CMD_ERROR));
    7ea0:	ldr	r3, [pc, #12]	; (7eb0 <isBusyCommandComplete()+0x10>)
    7ea2:	ldr	r0, [pc, #16]	; (7eb4 <isBusyCommandComplete()+0x14>)
    7ea4:	ldr	r3, [r3, #0]
    7ea6:	ands	r0, r3
}
    7ea8:	clz	r0, r0
    7eac:	lsrs	r0, r0, #5
    7eae:	bx	lr
    7eb0:	.word	0x400b1030
    7eb4:	.word	0x000f0001

00007eb8 <isBusyCommandInhibit()>:
//------------------------------------------------------------------------------
static bool isBusyCommandInhibit() {
  return SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB;
    7eb8:	ldr	r3, [pc, #8]	; (7ec4 <isBusyCommandInhibit()+0xc>)
    7eba:	ldr	r0, [r3, #0]
}
    7ebc:	and.w	r0, r0, #1
    7ec0:	bx	lr
    7ec2:	nop
    7ec4:	.word	0x400b1024

00007ec8 <isBusyDat()>:
//------------------------------------------------------------------------------
static bool isBusyDat() {
  return SDHC_PRSSTAT & (1 << 24) ? false : true;
    7ec8:	ldr	r3, [pc, #12]	; (7ed8 <isBusyDat()+0x10>)
    7eca:	ldr	r0, [r3, #0]
    7ecc:	eor.w	r0, r0, #16777216	; 0x1000000
}
    7ed0:	ubfx	r0, r0, #24, #1
    7ed4:	bx	lr
    7ed6:	nop
    7ed8:	.word	0x400b1024

00007edc <isBusyDMA()>:
//------------------------------------------------------------------------------
static bool isBusyDMA() {
  return m_dmaBusy;
    7edc:	ldr	r3, [pc, #4]	; (7ee4 <isBusyDMA()+0x8>)
    7ede:	ldrb	r0, [r3, #0]
}
    7ee0:	bx	lr
    7ee2:	nop
    7ee4:	.word	0x2001cf01

00007ee8 <isBusyFifoRead()>:
//------------------------------------------------------------------------------
static bool isBusyFifoRead() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BREN);
    7ee8:	ldr	r3, [pc, #12]	; (7ef8 <isBusyFifoRead()+0x10>)
    7eea:	ldr	r0, [r3, #0]
    7eec:	eor.w	r0, r0, #2048	; 0x800
}
    7ef0:	ubfx	r0, r0, #11, #1
    7ef4:	bx	lr
    7ef6:	nop
    7ef8:	.word	0x400b1024

00007efc <isBusyFifoWrite()>:
//------------------------------------------------------------------------------
static bool isBusyFifoWrite() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN);
    7efc:	ldr	r3, [pc, #12]	; (7f0c <isBusyFifoWrite()+0x10>)
    7efe:	ldr	r0, [r3, #0]
    7f00:	eor.w	r0, r0, #1024	; 0x400
}
    7f04:	ubfx	r0, r0, #10, #1
    7f08:	bx	lr
    7f0a:	nop
    7f0c:	.word	0x400b1024

00007f10 <isBusyTransferComplete()>:
//------------------------------------------------------------------------------
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
    7f10:	ldr	r3, [pc, #12]	; (7f20 <isBusyTransferComplete()+0x10>)
    7f12:	ldr	r0, [pc, #16]	; (7f24 <isBusyTransferComplete()+0x14>)
    7f14:	ldr	r3, [r3, #0]
    7f16:	ands	r0, r3
}
    7f18:	clz	r0, r0
    7f1c:	lsrs	r0, r0, #5
    7f1e:	bx	lr
    7f20:	.word	0x400b1030
    7f24:	.word	0x117f0002

00007f28 <setSdclk(unsigned long)>:
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    7f28:	mov.w	r3, #1000	; 0x3e8
  }
  d[15] = 0;
  return true;
}
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
    7f2c:	push	{r4, r5, lr}
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    7f2e:	ldr	r4, [pc, #128]	; (7fb0 <setSdclk(unsigned long)+0x88>)
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    7f30:	muls	r0, r3
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
    7f32:	movs	r2, #1
  uint32_t maxSdclk = 1000*kHzMax;
    7f34:	movs	r3, #9
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    7f36:	lsls	r1, r2, #4
    7f38:	udiv	r1, r4, r1
    7f3c:	cmp	r0, r1
    7f3e:	bcc.n	7f48 <setSdclk(unsigned long)+0x20>
    7f40:	movs	r4, #1
    7f42:	mov	r3, r2
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    7f44:	ldr	r5, [pc, #104]	; (7fb0 <setSdclk(unsigned long)+0x88>)
    7f46:	b.n	7f5c <setSdclk(unsigned long)+0x34>
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    7f48:	subs	r3, #1
    7f4a:	beq.n	7f40 <setSdclk(unsigned long)+0x18>
    sdclkfs <<= 1;
    7f4c:	lsls	r2, r2, #1
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    7f4e:	b.n	7f36 <setSdclk(unsigned long)+0xe>
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    7f50:	cmp	r4, #16
    7f52:	add.w	r1, r3, r2
    7f56:	beq.n	7f64 <setSdclk(unsigned long)+0x3c>
    dvs++;
    7f58:	adds	r4, #1
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    7f5a:	mov	r3, r1
    7f5c:	udiv	r1, r5, r3
    7f60:	cmp	r0, r1
    7f62:	bcc.n	7f50 <setSdclk(unsigned long)+0x28>
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    7f64:	mov.w	r1, #1000	; 0x3e8
    7f68:	muls	r3, r1
    7f6a:	ldr	r1, [pc, #68]	; (7fb0 <setSdclk(unsigned long)+0x88>)
    7f6c:	udiv	r3, r1, r3
    7f70:	ldr	r1, [pc, #64]	; (7fb4 <setSdclk(unsigned long)+0x8c>)
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    7f72:	ldr	r0, [pc, #68]	; (7fb8 <setSdclk(unsigned long)+0x90>)
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    7f74:	str	r3, [r1, #0]
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    7f76:	ldr	r3, [r0, #0]
    7f78:	bic.w	r3, r3, #8
    7f7c:	str	r3, [r0, #0]
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)

  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
    7f7e:	ldr	r1, [r0, #0]
                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    7f80:	bic.w	r3, r1, #1044480	; 0xff000
    7f84:	lsls	r2, r2, #7
    7f86:	bic.w	r3, r3, #4080	; 0xff0
    7f8a:	orr.w	r3, r3, #917504	; 0xe0000
    7f8e:	and.w	r2, r2, #65280	; 0xff00
    7f92:	orrs	r2, r3
    7f94:	subs	r3, r4, #1
    7f96:	orr.w	r3, r2, r3, lsl #4

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    7f9a:	ldr	r2, [pc, #32]	; (7fbc <setSdclk(unsigned long)+0x94>)
  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    7f9c:	str	r3, [r0, #0]

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    7f9e:	ldr	r3, [r2, #0]
    7fa0:	lsls	r3, r3, #28
    7fa2:	bpl.n	7f9e <setSdclk(unsigned long)+0x76>
  }

#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Enable the SDHC clock.
  SDHC_SYSCTL |= SDHC_SYSCTL_SDCLKEN;
    7fa4:	ldr	r3, [r0, #0]
    7fa6:	orr.w	r3, r3, #8
    7faa:	str	r3, [r0, #0]
    7fac:	pop	{r4, r5, pc}
    7fae:	nop
    7fb0:	.word	0x05b8d800
    7fb4:	.word	0x2001cf04
    7fb8:	.word	0x400b102c
    7fbc:	.word	0x400b1024

00007fc0 <SdioCard::errorCode() const>:
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::errorCode() const {
  return m_errorCode;
}
    7fc0:	ldr	r3, [pc, #4]	; (7fc8 <SdioCard::errorCode() const+0x8>)
    7fc2:	ldrb	r0, [r3, #0]
    7fc4:	bx	lr
    7fc6:	nop
    7fc8:	.word	0x1fff135c

00007fcc <SdioCard::errorData() const>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorData() const {
  return m_irqstat;
    7fcc:	ldr	r3, [pc, #4]	; (7fd4 <SdioCard::errorData() const+0x8>)
    7fce:	ldr	r0, [r3, #0]
}
    7fd0:	bx	lr
    7fd2:	nop
    7fd4:	.word	0x2001ceec

00007fd8 <SdioCard::readCID(CID*)>:
uint32_t SdioCard::kHzSdClk() {
  return m_sdClkKhz;
}
//------------------------------------------------------------------------------
bool SdioCard::readCID(cid_t* cid) {
  memcpy(cid, &m_cid, 16);
    7fd8:	ldr	r3, [pc, #20]	; (7ff0 <SdioCard::readCID(CID*)+0x18>)
    7fda:	add.w	r2, r3, #16
    7fde:	ldr.w	r0, [r3], #4
    7fe2:	str.w	r0, [r1], #4
    7fe6:	cmp	r3, r2
    7fe8:	bne.n	7fde <SdioCard::readCID(CID*)+0x6>
  return true;
}
    7fea:	movs	r0, #1
    7fec:	bx	lr
    7fee:	nop
    7ff0:	.word	0x2001cec5

00007ff4 <SdioCard::readCSD(csd_t*)>:
//------------------------------------------------------------------------------
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
    7ff4:	ldr	r3, [pc, #20]	; (800c <SdioCard::readCSD(csd_t*)+0x18>)
    7ff6:	add.w	r2, r3, #16
    7ffa:	ldr.w	r0, [r3], #4
    7ffe:	str.w	r0, [r1], #4
    8002:	cmp	r3, r2
    8004:	bne.n	7ffa <SdioCard::readCSD(csd_t*)+0x6>
  return true;
}
    8006:	movs	r0, #1
    8008:	bx	lr
    800a:	nop
    800c:	.word	0x2001cef1

00008010 <SdioCard::readOCR(unsigned long*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
    8010:	ldr	r3, [pc, #8]	; (801c <SdioCard::readOCR(unsigned long*)+0xc>)
    8012:	ldr	r3, [r3, #0]
    8014:	str	r3, [r1, #0]
  return true;
}
    8016:	movs	r0, #1
    8018:	bx	lr
    801a:	nop
    801c:	.word	0x2001cee0

00008020 <SdioCard::~SdioCard()>:
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    8020:	bx	lr
    8022:	Address 0x00008022 is out of bounds.


00008024 <waitTimeout(bool (*)())>:
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
    8024:	push	{r3, r4, r5, r6, r7, lr}
    8026:	mov	r7, r0
  uint32_t m = micros();
    8028:	bl	9418 <micros>
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    802c:	ldr	r5, [pc, #20]	; (8044 <waitTimeout(bool (*)())+0x20>)
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
  uint32_t m = micros();
    802e:	mov	r6, r0
  while (fcn()) {
    8030:	blx	r7
    8032:	mov	r4, r0
    8034:	cbz	r0, 8040 <waitTimeout(bool (*)())+0x1c>
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    8036:	bl	9418 <micros>
    803a:	subs	r0, r0, r6
    803c:	cmp	r0, r5
    803e:	bls.n	8030 <waitTimeout(bool (*)())+0xc>
      return true;
    }
  }
  return false;  // Caller will set errorCode.
}
    8040:	mov	r0, r4
    8042:	pop	{r3, r4, r5, r6, r7, pc}
    8044:	.word	0x000f4240

00008048 <yieldTimeout(bool (*)())>:
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    8048:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  m_busyFcn = fcn;
    804c:	ldr	r4, [pc, #48]	; (8080 <yieldTimeout(bool (*)())+0x38>)
  uint32_t m = micros();
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    804e:	ldr.w	r8, [pc, #52]	; 8084 <yieldTimeout(bool (*)())+0x3c>
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
  m_busyFcn = fcn;
    8052:	str	r0, [r4, #0]
  }
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    8054:	mov	r6, r0
  m_busyFcn = fcn;
  uint32_t m = micros();
    8056:	bl	9418 <micros>
    805a:	mov	r7, r0
  while (fcn()) {
    805c:	blx	r6
    805e:	mov	r5, r0
    8060:	cbz	r0, 8078 <yieldTimeout(bool (*)())+0x30>
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    8062:	bl	9418 <micros>
    8066:	subs	r0, r0, r7
    8068:	cmp	r0, r8
    806a:	bls.n	8072 <yieldTimeout(bool (*)())+0x2a>
      m_busyFcn = 0;
    806c:	movs	r3, #0
    806e:	str	r3, [r4, #0]
      return true;
    8070:	b.n	807a <yieldTimeout(bool (*)())+0x32>
  }
}
#elif defined(ARDUINO)
inline void SysCall::yield() {
  // Use the external Arduino yield() function.
  ::yield();
    8072:	bl	9e58 <yield>
    8076:	b.n	805c <yieldTimeout(bool (*)())+0x14>
    }
    SysCall::yield();
  }
  m_busyFcn = 0;
    8078:	str	r0, [r4, #0]
  return false;  // Caller will set errorCode.
}
    807a:	mov	r0, r5
    807c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8080:	.word	0x2001ced8
    8084:	.word	0x000f4240

00008088 <SdioCard::~SdioCard()>:
    8088:	push	{r4, lr}
    808a:	movs	r1, #12
    808c:	mov	r4, r0
    808e:	bl	a2bc <operator delete(void*, unsigned int)>
    8092:	mov	r0, r4
    8094:	pop	{r4, pc}
    8096:	Address 0x00008096 is out of bounds.


00008098 <SdioCard::type() const>:
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
    8098:	ldr	r3, [pc, #20]	; (80b0 <SdioCard::type() const+0x18>)
    809a:	ldrb	r3, [r3, #0]
    809c:	cbz	r3, 80ac <SdioCard::type() const+0x14>
    809e:	ldr	r3, [pc, #20]	; (80b4 <SdioCard::type() const+0x1c>)
    80a0:	ldrb	r3, [r3, #0]
    80a2:	cmp	r3, #0
    80a4:	ite	ne
    80a6:	movne	r0, #3
    80a8:	moveq	r0, #2
    80aa:	bx	lr
    80ac:	movs	r0, #1
}
    80ae:	bx	lr
    80b0:	.word	0x2001cec4
    80b4:	.word	0x2001cedc

000080b8 <cardCommand(unsigned long, unsigned long)>:
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    80b8:	push	{r3, r4, r5, lr}
    80ba:	mov	r4, r0
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    80bc:	ldr	r0, [pc, #56]	; (80f8 <cardCommand(unsigned long, unsigned long)+0x40>)
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    80be:	mov	r5, r1
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    80c0:	bl	8024 <waitTimeout(bool (*)())>
    80c4:	cbnz	r0, 80ee <cardCommand(unsigned long, unsigned long)+0x36>
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    80c6:	ldr	r3, [pc, #52]	; (80fc <cardCommand(unsigned long, unsigned long)+0x44>)
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
  if (waitTimeout(isBusyCommandComplete)) {
    80c8:	ldr	r0, [pc, #52]	; (8100 <cardCommand(unsigned long, unsigned long)+0x48>)
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    80ca:	str	r5, [r3, #0]
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MASK;
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
    80cc:	str	r4, [r3, #4]
  if (waitTimeout(isBusyCommandComplete)) {
    80ce:	bl	8024 <waitTimeout(bool (*)())>
    80d2:	cbnz	r0, 80ee <cardCommand(unsigned long, unsigned long)+0x36>
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
    80d4:	ldr	r2, [pc, #44]	; (8104 <cardCommand(unsigned long, unsigned long)+0x4c>)
    80d6:	ldr	r3, [pc, #48]	; (8108 <cardCommand(unsigned long, unsigned long)+0x50>)
    80d8:	ldr	r1, [r2, #0]
    80da:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    80dc:	ldr	r1, [r3, #0]
    80de:	str	r1, [r2, #0]

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    80e0:	ldr	r2, [r3, #0]
    80e2:	lsls	r2, r2, #31
    80e4:	bpl.n	80ee <cardCommand(unsigned long, unsigned long)+0x36>
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
    80e6:	ldr	r3, [r3, #0]
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    80e8:	tst.w	r3, #983040	; 0xf0000
    80ec:	beq.n	80f2 <cardCommand(unsigned long, unsigned long)+0x3a>
    80ee:	movs	r0, #0
    80f0:	pop	{r3, r4, r5, pc}
    80f2:	movs	r0, #1
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
    80f4:	pop	{r3, r4, r5, pc}
    80f6:	nop
    80f8:	.word	0x00007eb9
    80fc:	.word	0x400b1008
    8100:	.word	0x00007ea1
    8104:	.word	0x400b1030
    8108:	.word	0x2001ceec

0000810c <statusCMD13()>:
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
  }
}
//------------------------------------------------------------------------------
static uint32_t statusCMD13() {
    810c:	push	{r3, lr}
  return cardCommand(CMD13_XFERTYP, m_rca) ? SDHC_CMDRSP0 : 0;
    810e:	ldr	r3, [pc, #16]	; (8120 <statusCMD13()+0x14>)
    8110:	ldr	r0, [pc, #16]	; (8124 <statusCMD13()+0x18>)
    8112:	ldr	r1, [r3, #0]
    8114:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    8118:	cbz	r0, 811e <statusCMD13()+0x12>
    811a:	ldr	r3, [pc, #12]	; (8128 <statusCMD13()+0x1c>)
    811c:	ldr	r0, [r3, #0]
}
    811e:	pop	{r3, pc}
    8120:	.word	0x2001cee4
    8124:	.word	0x0d1a0000
    8128:	.word	0x400b1010

0000812c <isBusyCMD13()>:
//------------------------------------------------------------------------------
static bool isBusyCMD13() {
    812c:	push	{r3, lr}
  return !(statusCMD13() & CARD_STATUS_READY_FOR_DATA);
    812e:	bl	810c <statusCMD13()>
    8132:	eor.w	r0, r0, #256	; 0x100
}
    8136:	ubfx	r0, r0, #8, #1
    813a:	pop	{r3, pc}

0000813c <SdioCard::status()>:
uint32_t SdioCard::sectorCount() {
  return sdCardCapacity(&m_csd);
}
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
    813c:	b.w	810c <statusCMD13()>

00008140 <readReg16(unsigned long, void*)>:
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    8140:	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    8142:	ldr	r3, [pc, #80]	; (8194 <readReg16(unsigned long, void*)+0x54>)
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    8144:	mov	r5, r1
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    8146:	ldr	r1, [r3, #0]
    8148:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    814c:	cbz	r0, 818e <readReg16(unsigned long, void*)+0x4e>
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
    814e:	ldr	r3, [pc, #72]	; (8198 <readReg16(unsigned long, void*)+0x58>)
    8150:	ldr	r3, [r3, #0]
    8152:	str	r3, [sp, #0]
    8154:	ldr	r3, [pc, #68]	; (819c <readReg16(unsigned long, void*)+0x5c>)
    8156:	ldr	r3, [r3, #0]
    8158:	str	r3, [sp, #4]
    815a:	ldr	r3, [pc, #68]	; (81a0 <readReg16(unsigned long, void*)+0x60>)
    815c:	ldr	r3, [r3, #0]
    815e:	str	r3, [sp, #8]
    8160:	ldr	r3, [pc, #64]	; (81a4 <readReg16(unsigned long, void*)+0x64>)
    8162:	ldr	r3, [r3, #0]
    8164:	str	r3, [sp, #12]
    8166:	add.w	r6, r5, #15
  for (int i = 0; i < 15; i++) {
    816a:	movs	r3, #0
    d[14 - i] = sr[i/4] >> 8*(i%4);
    816c:	bic.w	r4, r3, #3
    8170:	add	r2, sp, #16
    8172:	add	r4, r2
    8174:	and.w	r2, r3, #3
    8178:	lsls	r1, r2, #3
    817a:	ldr.w	r2, [r4, #-16]
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    817e:	adds	r3, #1
    d[14 - i] = sr[i/4] >> 8*(i%4);
    8180:	lsrs	r2, r1
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    8182:	cmp	r3, #15
    d[14 - i] = sr[i/4] >> 8*(i%4);
    8184:	strb.w	r2, [r6, #-1]!
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    8188:	bne.n	816c <readReg16(unsigned long, void*)+0x2c>
    d[14 - i] = sr[i/4] >> 8*(i%4);
  }
  d[15] = 0;
    818a:	movs	r3, #0
    818c:	strb	r3, [r5, #15]
  return true;
}
    818e:	add	sp, #16
    8190:	pop	{r4, r5, r6, pc}
    8192:	nop
    8194:	.word	0x2001cee4
    8198:	.word	0x400b1010
    819c:	.word	0x400b1014
    81a0:	.word	0x400b1018
    81a4:	.word	0x400b101c

000081a8 <waitDmaStatus() [clone .part.4]>:
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    return false;  // Caller will set errorCode.
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    81a8:	ldr	r3, [pc, #20]	; (81c0 <waitDmaStatus() [clone .part.4]+0x18>)
    81aa:	ldr	r0, [r3, #0]
    81ac:	ands.w	r0, r0, #2
    81b0:	beq.n	81be <waitDmaStatus() [clone .part.4]+0x16>
    81b2:	ldr	r3, [r3, #0]
    81b4:	ldr	r0, [pc, #12]	; (81c4 <waitDmaStatus() [clone .part.4]+0x1c>)
    81b6:	ands	r0, r3
    81b8:	clz	r0, r0
    81bc:	lsrs	r0, r0, #5
}
    81be:	bx	lr
    81c0:	.word	0x2001ceec
    81c4:	.word	0x117f0000

000081c8 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>:
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
}
//------------------------------------------------------------------------------
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
    81c8:	push	{r3, r4, r5, r6, r7, lr}
    81ca:	mov	r4, r3
  if ((3 & (uint32_t)buf) || n == 0) {
    81cc:	lsls	r3, r2, #30
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
}
//------------------------------------------------------------------------------
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
    81ce:	mov	r7, r0
    81d0:	mov	r5, r1
    81d2:	mov	r6, r2
  if ((3 & (uint32_t)buf) || n == 0) {
    81d4:	bne.n	81d8 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x10>
    81d6:	cbnz	r4, 81e4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x1c>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    81d8:	ldr	r3, [pc, #100]	; (8240 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x78>)
    81da:	movs	r2, #37	; 0x25
    81dc:	strb	r2, [r3, #0]
  m_errorLine = line;
    81de:	mov.w	r2, #506	; 0x1fa
    81e2:	b.n	81f6 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x2e>
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    81e4:	ldr	r0, [pc, #92]	; (8244 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x7c>)
    81e6:	bl	8048 <yieldTimeout(bool (*)())>
    81ea:	cbz	r0, 81fc <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x34>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    81ec:	ldr	r3, [pc, #80]	; (8240 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x78>)
    81ee:	movs	r2, #10
    81f0:	strb	r2, [r3, #0]
  m_errorLine = line;
    81f2:	movw	r2, #509	; 0x1fd
    81f6:	ldr	r3, [pc, #80]	; (8248 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x80>)
    81f8:	str	r2, [r3, #0]
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    81fa:	b.n	823a <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    81fc:	ldr	r3, [pc, #76]	; (824c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x84>)
    81fe:	movs	r2, #1
    8200:	strb	r2, [r3, #0]
  m_irqstat = 0;
    8202:	ldr	r3, [pc, #76]	; (8250 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x88>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    8204:	ldr	r2, [pc, #76]	; (8254 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x8c>)
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    8206:	str	r0, [r3, #0]
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    8208:	lsls	r4, r4, #16
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    820a:	ldr	r3, [pc, #76]	; (8258 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x90>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    820c:	orr.w	r4, r4, #512	; 0x200
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    8210:	str	r6, [r3, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    8212:	str	r4, [r3, #4]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    8214:	str	r2, [r3, #56]	; 0x38
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    8216:	ldr	r3, [pc, #68]	; (825c <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x94>)
    8218:	ldrb	r3, [r3, #0]
    821a:	cbnz	r3, 8220 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x58>
    821c:	lsls	r1, r5, #9
    821e:	b.n	8222 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x5a>
    8220:	mov	r1, r5
    8222:	mov	r0, r7
    8224:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    8228:	cbz	r0, 823a <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    822a:	ldr	r0, [pc, #52]	; (8260 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x98>)
    822c:	bl	8048 <yieldTimeout(bool (*)())>
    8230:	cbnz	r0, 823a <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    return false;
  }
  return waitDmaStatus();
}
    8232:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    8236:	b.w	81a8 <waitDmaStatus() [clone .part.4]>
    823a:	movs	r0, #0
    823c:	pop	{r3, r4, r5, r6, r7, pc}
    823e:	nop
    8240:	.word	0x1fff135c
    8244:	.word	0x0000812d
    8248:	.word	0x2001cf08
    824c:	.word	0x2001cf01
    8250:	.word	0x2001ceec
    8254:	.word	0x117f0002
    8258:	.word	0x400b1000
    825c:	.word	0x2001cedc
    8260:	.word	0x00007edd

00008264 <SdioCard::sectorCount()>:
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    8264:	ldr	r2, [pc, #92]	; (82c4 <SdioCard::sectorCount()+0x60>)
    8266:	ldrb	r3, [r2, #0]
    8268:	ands.w	r3, r3, #192	; 0xc0
    826c:	bne.n	82a2 <SdioCard::sectorCount()+0x3e>
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    826e:	ldrb	r0, [r2, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    8270:	ldrb	r3, [r2, #7]
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    8272:	ldrb	r1, [r2, #10]
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    8274:	and.w	r0, r0, #3
    8278:	lsls	r3, r3, #2
    827a:	orr.w	r3, r3, r0, lsl #10
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    827e:	ldrb	r0, [r2, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    8280:	orr.w	r0, r3, r0, lsr #6
    8284:	adds	r3, r0, #1
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    8286:	ldrb	r0, [r2, #9]
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    8288:	ldrb	r2, [r2, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    828a:	and.w	r0, r0, #3
    828e:	lsls	r0, r0, #1
    8290:	orr.w	r0, r0, r1, lsr #7
    8294:	and.w	r2, r2, #15
    8298:	add	r0, r2
    829a:	subs	r0, #7
    829c:	lsl.w	r0, r3, r0
    82a0:	bx	lr
  } else if (csd->v2.csd_ver == 1) {
    82a2:	cmp	r3, #64	; 0x40
    82a4:	bne.n	82be <SdioCard::sectorCount()+0x5a>
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    82a6:	ldrb	r0, [r2, #9]
    82a8:	adds	r3, r0, #1
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    82aa:	ldrb	r0, [r2, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    82ac:	and.w	r0, r0, #63	; 0x3f
    82b0:	add.w	r0, r3, r0, lsl #16
    82b4:	ldrb	r3, [r2, #8]
    82b6:	add.w	r0, r0, r3, lsl #8
    82ba:	lsls	r0, r0, #10
    82bc:	bx	lr
  } else {
    return 0;
    82be:	movs	r0, #0
  return transferStop();
}
//------------------------------------------------------------------------------
uint32_t SdioCard::sectorCount() {
  return sdCardCapacity(&m_csd);
}
    82c0:	bx	lr
    82c2:	nop
    82c4:	.word	0x2001cef1

000082c8 <SdioCard::erase(unsigned long, unsigned long)>:
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    82c8:	push	{r4, r5, r6, lr}
    82ca:	mov	r6, r2
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    82cc:	ldrb	r2, [r0, #9]
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    82ce:	mov	r5, r1
#if ENABLE_TEENSY_SDIO_MOD
  if (m_curState != IDLE_STATE && !syncDevice()) {
    82d0:	cbz	r2, 82de <SdioCard::erase(unsigned long, unsigned long)+0x16>
    82d2:	ldr	r3, [r0, #0]
    82d4:	ldr	r3, [r3, #28]
    82d6:	blx	r3
    82d8:	mov	r4, r0
    82da:	cmp	r0, #0
    82dc:	beq.n	837a <SdioCard::erase(unsigned long, unsigned long)+0xb2>
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  // check for single sector erase
  if (!m_csd.v1.erase_blk_en) {
    82de:	ldr	r1, [pc, #160]	; (8380 <SdioCard::erase(unsigned long, unsigned long)+0xb8>)
    82e0:	ldrb	r3, [r1, #10]
    82e2:	and.w	r2, r3, #64	; 0x40
    82e6:	and.w	r4, r2, #255	; 0xff
    82ea:	cbnz	r2, 830c <SdioCard::erase(unsigned long, unsigned long)+0x44>
    // erase size mask
    uint8_t m = (m_csd.v1.sector_size_high << 1) | m_csd.v1.sector_size_low;
    82ec:	ldrb	r2, [r1, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    82ee:	and.w	r3, r3, #63	; 0x3f
    82f2:	lsls	r3, r3, #1
    82f4:	orr.w	r3, r3, r2, lsr #7
    82f8:	adds	r2, r6, #1
    82fa:	orrs	r2, r5
    82fc:	tst	r3, r2
    82fe:	beq.n	830c <SdioCard::erase(unsigned long, unsigned long)+0x44>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8300:	ldr	r3, [pc, #128]	; (8384 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    8302:	movs	r2, #39	; 0x27
    8304:	strb	r2, [r3, #0]
  m_errorLine = line;
    8306:	movw	r2, #747	; 0x2eb
    830a:	b.n	835c <SdioCard::erase(unsigned long, unsigned long)+0x94>
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
      // error card can't erase specified area
      return sdError(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
    }
  }
  if (!m_highCapacity) {
    830c:	ldr	r3, [pc, #120]	; (8388 <SdioCard::erase(unsigned long, unsigned long)+0xc0>)
    830e:	ldrb	r3, [r3, #0]
    8310:	cbnz	r3, 8316 <SdioCard::erase(unsigned long, unsigned long)+0x4e>
    firstSector <<= 9;
    8312:	lsls	r5, r5, #9
    lastSector <<= 9;
    8314:	lsls	r6, r6, #9
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    8316:	mov	r1, r5
    8318:	ldr	r0, [pc, #112]	; (838c <SdioCard::erase(unsigned long, unsigned long)+0xc4>)
    831a:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    831e:	mov	r4, r0
    8320:	cbnz	r0, 832e <SdioCard::erase(unsigned long, unsigned long)+0x66>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8322:	ldr	r3, [pc, #96]	; (8384 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    8324:	movs	r2, #15
    8326:	strb	r2, [r3, #0]
  m_errorLine = line;
    8328:	movw	r2, #755	; 0x2f3
    832c:	b.n	835c <SdioCard::erase(unsigned long, unsigned long)+0x94>
    lastSector <<= 9;
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
    832e:	mov	r1, r6
    8330:	ldr	r0, [pc, #92]	; (8390 <SdioCard::erase(unsigned long, unsigned long)+0xc8>)
    8332:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    8336:	mov	r4, r0
    8338:	cbnz	r0, 8346 <SdioCard::erase(unsigned long, unsigned long)+0x7e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    833a:	ldr	r3, [pc, #72]	; (8384 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    833c:	movs	r2, #16
    833e:	strb	r2, [r3, #0]
  m_errorLine = line;
    8340:	movw	r2, #758	; 0x2f6
    8344:	b.n	835c <SdioCard::erase(unsigned long, unsigned long)+0x94>
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    8346:	movs	r1, #0
    8348:	ldr	r0, [pc, #72]	; (8394 <SdioCard::erase(unsigned long, unsigned long)+0xcc>)
    834a:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    834e:	mov	r4, r0
    8350:	cbnz	r0, 8362 <SdioCard::erase(unsigned long, unsigned long)+0x9a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8352:	ldr	r3, [pc, #48]	; (8384 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    8354:	movs	r2, #17
    8356:	strb	r2, [r3, #0]
  m_errorLine = line;
    8358:	movw	r2, #761	; 0x2f9
    835c:	ldr	r3, [pc, #56]	; (8398 <SdioCard::erase(unsigned long, unsigned long)+0xd0>)
    835e:	str	r2, [r3, #0]
    8360:	b.n	837a <SdioCard::erase(unsigned long, unsigned long)+0xb2>
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    8362:	ldr	r0, [pc, #56]	; (839c <SdioCard::erase(unsigned long, unsigned long)+0xd4>)
    8364:	bl	8024 <waitTimeout(bool (*)())>
    8368:	cbz	r0, 837a <SdioCard::erase(unsigned long, unsigned long)+0xb2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    836a:	ldr	r3, [pc, #24]	; (8384 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    836c:	movs	r2, #40	; 0x28
    836e:	strb	r2, [r3, #0]
  m_errorLine = line;
    8370:	ldr	r3, [pc, #36]	; (8398 <SdioCard::erase(unsigned long, unsigned long)+0xd0>)
    8372:	mov.w	r2, #764	; 0x2fc
    8376:	str	r2, [r3, #0]
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
    8378:	movs	r4, #0
  }
  return true;
}
    837a:	mov	r0, r4
    837c:	pop	{r4, r5, r6, pc}
    837e:	nop
    8380:	.word	0x2001cef1
    8384:	.word	0x1fff135c
    8388:	.word	0x2001cedc
    838c:	.word	0x201a0000
    8390:	.word	0x211a0000
    8394:	.word	0x261b0000
    8398:	.word	0x2001cf08
    839c:	.word	0x0000812d

000083a0 <waitTransferComplete()>:
  }
  return false;  // Caller will set errorCode.
}
#if ENABLE_TEENSY_SDIO_MOD
//------------------------------------------------------------------------------
static bool waitTransferComplete() {
    83a0:	push	{r4, lr}
  if (!m_transferActive) {
    83a2:	ldr	r4, [pc, #60]	; (83e0 <waitTransferComplete()+0x40>)
    83a4:	ldrb	r3, [r4, #0]
    83a6:	cbnz	r3, 83ac <waitTransferComplete()+0xc>
    return true;
    83a8:	movs	r0, #1
    83aa:	pop	{r4, pc}
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
    83ac:	ldr	r0, [pc, #52]	; (83e4 <waitTransferComplete()+0x44>)
    83ae:	bl	8024 <waitTimeout(bool (*)())>
  m_transferActive = false;
    83b2:	movs	r3, #0
  m_irqstat = SDHC_IRQSTAT;
    83b4:	ldr	r2, [pc, #48]	; (83e8 <waitTransferComplete()+0x48>)
static bool waitTransferComplete() {
  if (!m_transferActive) {
    return true;
  }
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
    83b6:	strb	r3, [r4, #0]
  m_irqstat = SDHC_IRQSTAT;
    83b8:	ldr	r3, [pc, #48]	; (83ec <waitTransferComplete()+0x4c>)
    83ba:	ldr	r1, [r2, #0]
    83bc:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    83be:	ldr	r1, [r3, #0]
    83c0:	str	r1, [r2, #0]
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    83c2:	cbnz	r0, 83ce <waitTransferComplete()+0x2e>
    83c4:	ldr	r2, [r3, #0]
    83c6:	ldr	r3, [pc, #40]	; (83f0 <waitTransferComplete()+0x50>)
    83c8:	ands	r3, r2
    83ca:	cmp	r3, #0
    83cc:	beq.n	83a8 <waitTransferComplete()+0x8>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    83ce:	ldr	r3, [pc, #36]	; (83f4 <waitTransferComplete()+0x54>)
    83d0:	movs	r2, #31
    83d2:	strb	r2, [r3, #0]
  m_errorLine = line;
    83d4:	ldr	r3, [pc, #32]	; (83f8 <waitTransferComplete()+0x58>)
    83d6:	movw	r2, #641	; 0x281
    83da:	str	r2, [r3, #0]
  bool timeOut = waitTimeout(isBusyTransferComplete);
  m_transferActive = false;
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  if (timeOut || (m_irqstat & SDHC_IRQSTAT_ERROR)) {
    return sdError(SD_CARD_ERROR_TRANSFER_COMPLETE);
    83dc:	movs	r0, #0
  }
  return true;
}
    83de:	pop	{r4, pc}
    83e0:	.word	0x2001cee8
    83e4:	.word	0x00007f11
    83e8:	.word	0x400b1030
    83ec:	.word	0x2001ceec
    83f0:	.word	0x117f0000
    83f4:	.word	0x1fff135c
    83f8:	.word	0x2001cf08

000083fc <SdioCard::readStop()>:
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
    83fc:	push	{r4, r5, r6, lr}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    83fe:	ldr	r4, [pc, #100]	; (8464 <SdioCard::readStop()+0x68>)
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    8400:	ldr	r0, [pc, #100]	; (8468 <SdioCard::readStop()+0x6c>)
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8402:	ldr	r3, [r4, #0]
    8404:	bic.w	r3, r3, #65536	; 0x10000
    8408:	str	r3, [r4, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    840a:	movs	r1, #0
    840c:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    8410:	mov	r5, r0
    8412:	cbnz	r0, 8424 <SdioCard::readStop()+0x28>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8414:	ldr	r3, [pc, #84]	; (846c <SdioCard::readStop()+0x70>)
    8416:	movs	r2, #9
    8418:	strb	r2, [r3, #0]
  m_errorLine = line;
    841a:	ldr	r3, [pc, #84]	; (8470 <SdioCard::readStop()+0x74>)
    841c:	movw	r2, #578	; 0x242
    8420:	str	r2, [r3, #0]
    8422:	b.n	845e <SdioCard::readStop()+0x62>
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    8424:	ldr	r0, [pc, #76]	; (8474 <SdioCard::readStop()+0x78>)
    8426:	bl	8048 <yieldTimeout(bool (*)())>
    842a:	cbz	r0, 843e <SdioCard::readStop()+0x42>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    842c:	ldr	r3, [pc, #60]	; (846c <SdioCard::readStop()+0x70>)
    842e:	movs	r2, #10
    8430:	strb	r2, [r3, #0]
  m_errorLine = line;
    8432:	ldr	r3, [pc, #60]	; (8470 <SdioCard::readStop()+0x74>)
    8434:	movw	r2, #582	; 0x246
    8438:	str	r2, [r3, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
//  if (yieldTimeout(isBusyCMD13)) {
  if (yieldTimeout(isBusyDat)) {
    return sdError(SD_CARD_ERROR_CMD13);
    843a:	movs	r5, #0
    843c:	b.n	845e <SdioCard::readStop()+0x62>
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    843e:	ldr	r3, [pc, #56]	; (8478 <SdioCard::readStop()+0x7c>)
    8440:	ldr	r3, [r3, #0]
    8442:	lsls	r3, r3, #30
    8444:	bpl.n	845e <SdioCard::readStop()+0x62>
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    8446:	ldr	r1, [pc, #52]	; (847c <SdioCard::readStop()+0x80>)
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    8448:	ldr	r0, [pc, #52]	; (8480 <SdioCard::readStop()+0x84>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    844a:	ldr	r6, [r1, #0]
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    844c:	ldr	r3, [r4, #0]
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    844e:	ldr	r2, [r0, #0]
  }
  if (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB) {
    // This should not happen after above fix.
    // Save registers before reset DAT lines.
    uint32_t irqsststen = SDHC_IRQSTATEN;
    uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    8450:	bic.w	r3, r3, #65536	; 0x10000
    // Do reset to clear CDIHB.  Should be a better way!
    SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    8454:	orr.w	r2, r2, #67108864	; 0x4000000
    8458:	str	r2, [r0, #0]
    // Restore registers.
    SDHC_IRQSTATEN = irqsststen;
    845a:	str	r6, [r1, #0]
    SDHC_PROCTL = proctl;
    845c:	str	r3, [r4, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
}
    845e:	mov	r0, r5
    8460:	pop	{r4, r5, r6, pc}
    8462:	nop
    8464:	.word	0x400b1028
    8468:	.word	0x0cdb0000
    846c:	.word	0x1fff135c
    8470:	.word	0x2001cf08
    8474:	.word	0x00007ec9
    8478:	.word	0x400b1024
    847c:	.word	0x400b1034
    8480:	.word	0x400b102c

00008484 <SdioCard::writeData(unsigned char const*)>:
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
}
//------------------------------------------------------------------------------
bool SdioCard::writeData(const uint8_t* src) {
    8484:	push	{r4, r5, r6, lr}
    8486:	mov	r4, r1
  DBG_IRQSTAT();
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    8488:	bl	83a0 <waitTransferComplete()>
    848c:	mov	r6, r0
    848e:	cmp	r0, #0
    8490:	beq.n	84f8 <SdioCard::writeData(unsigned char const*)+0x74>
    return false;
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    8492:	ldr	r5, [pc, #104]	; (84fc <SdioCard::writeData(unsigned char const*)+0x78>)
    8494:	ldr	r3, [r5, #0]
    8496:	tst.w	r3, #256	; 0x100
    849a:	ldr	r3, [pc, #100]	; (8500 <SdioCard::writeData(unsigned char const*)+0x7c>)
    849c:	bne.n	84ae <SdioCard::writeData(unsigned char const*)+0x2a>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    849e:	ldr	r2, [r3, #0]
    84a0:	bic.w	r2, r2, #65536	; 0x10000
    84a4:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    84a6:	ldr	r2, [r3, #0]
    84a8:	orr.w	r2, r2, #131072	; 0x20000
    84ac:	str	r2, [r3, #0]
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    84ae:	ldr	r2, [r3, #0]
  if (waitTimeout(isBusyFifoWrite)) {
    84b0:	ldr	r0, [pc, #80]	; (8504 <SdioCard::writeData(unsigned char const*)+0x80>)
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    84b2:	orr.w	r2, r2, #65536	; 0x10000
    84b6:	str	r2, [r3, #0]
  if (waitTimeout(isBusyFifoWrite)) {
    84b8:	bl	8024 <waitTimeout(bool (*)())>
    84bc:	cbnz	r0, 84e8 <SdioCard::writeData(unsigned char const*)+0x64>
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    84be:	ldr	r1, [pc, #72]	; (8508 <SdioCard::writeData(unsigned char const*)+0x84>)
    84c0:	subs	r3, r4, #4
    84c2:	add.w	r4, r4, #508	; 0x1fc
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    84c6:	ldr	r2, [r5, #0]
    84c8:	lsls	r2, r2, #21
    84ca:	bpl.n	84c6 <SdioCard::writeData(unsigned char const*)+0x42>
    84cc:	add.w	r2, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    84d0:	ldr.w	r0, [r3, #4]!
    84d4:	str	r0, [r1, #0]
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    84d6:	cmp	r2, r3
    84d8:	bne.n	84d0 <SdioCard::writeData(unsigned char const*)+0x4c>
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    84da:	cmp	r4, r2
    84dc:	mov	r3, r2
    84de:	bne.n	84c6 <SdioCard::writeData(unsigned char const*)+0x42>
      SDHC_DATPORT = p32[i];
    }
    p32 += FIFO_WML;
  }
#if ENABLE_TEENSY_SDIO_MOD
  m_transferActive = true;
    84e0:	ldr	r3, [pc, #40]	; (850c <SdioCard::writeData(unsigned char const*)+0x88>)
    84e2:	movs	r2, #1
    84e4:	strb	r2, [r3, #0]
    84e6:	b.n	84f8 <SdioCard::writeData(unsigned char const*)+0x74>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    84e8:	ldr	r3, [pc, #36]	; (8510 <SdioCard::writeData(unsigned char const*)+0x8c>)
    84ea:	movs	r2, #33	; 0x21
    84ec:	strb	r2, [r3, #0]
  m_errorLine = line;
    84ee:	ldr	r3, [pc, #36]	; (8514 <SdioCard::writeData(unsigned char const*)+0x90>)
    84f0:	movw	r2, #1015	; 0x3f7
    84f4:	str	r2, [r3, #0]
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
    84f6:	movs	r6, #0
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    84f8:	mov	r0, r6
    84fa:	pop	{r4, r5, r6, pc}
    84fc:	.word	0x400b1024
    8500:	.word	0x400b1028
    8504:	.word	0x00007efd
    8508:	.word	0x400b1020
    850c:	.word	0x2001cee8
    8510:	.word	0x1fff135c
    8514:	.word	0x2001cf08

00008518 <SdioCard::writeStart(unsigned long)>:
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    8518:	push	{r4, lr}
  if (yieldTimeout(isBusyCMD13)) {
    851a:	ldr	r0, [pc, #80]	; (856c <SdioCard::writeStart(unsigned long)+0x54>)
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    851c:	mov	r4, r1
  if (yieldTimeout(isBusyCMD13)) {
    851e:	bl	8048 <yieldTimeout(bool (*)())>
    8522:	cbz	r0, 8536 <SdioCard::writeStart(unsigned long)+0x1e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8524:	ldr	r3, [pc, #72]	; (8570 <SdioCard::writeStart(unsigned long)+0x58>)
    8526:	movs	r2, #10
    8528:	strb	r2, [r3, #0]
  m_errorLine = line;
    852a:	ldr	r3, [pc, #72]	; (8574 <SdioCard::writeStart(unsigned long)+0x5c>)
    852c:	movw	r2, #1119	; 0x45f
    8530:	str	r2, [r3, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    8532:	movs	r0, #0
    8534:	pop	{r4, pc}
  }
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8536:	ldr	r2, [pc, #64]	; (8578 <SdioCard::writeStart(unsigned long)+0x60>)
    8538:	ldr	r3, [r2, #0]
    853a:	bic.w	r3, r3, #65536	; 0x10000
    853e:	str	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    8540:	ldr	r3, [pc, #56]	; (857c <SdioCard::writeStart(unsigned long)+0x64>)
    8542:	ldr	r2, [pc, #60]	; (8580 <SdioCard::writeStart(unsigned long)+0x68>)
    8544:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    8546:	ldr	r3, [pc, #60]	; (8584 <SdioCard::writeStart(unsigned long)+0x6c>)
    8548:	ldrb	r3, [r3, #0]
    854a:	cbnz	r3, 8550 <SdioCard::writeStart(unsigned long)+0x38>
    854c:	lsls	r1, r4, #9
    854e:	b.n	8552 <SdioCard::writeStart(unsigned long)+0x3a>
    8550:	mov	r1, r4
    8552:	ldr	r0, [pc, #52]	; (8588 <SdioCard::writeStart(unsigned long)+0x70>)
    8554:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    8558:	cbnz	r0, 8568 <SdioCard::writeStart(unsigned long)+0x50>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    855a:	ldr	r3, [pc, #20]	; (8570 <SdioCard::writeStart(unsigned long)+0x58>)
    855c:	movs	r2, #14
    855e:	strb	r2, [r3, #0]
  m_errorLine = line;
    8560:	ldr	r3, [pc, #16]	; (8574 <SdioCard::writeStart(unsigned long)+0x5c>)
    8562:	movw	r2, #1131	; 0x46b
    8566:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
    8568:	pop	{r4, pc}
    856a:	nop
    856c:	.word	0x0000812d
    8570:	.word	0x1fff135c
    8574:	.word	0x2001cf08
    8578:	.word	0x400b1028
    857c:	.word	0x400b1004
    8580:	.word	0xffff0200
    8584:	.word	0x2001cedc
    8588:	.word	0x193a0022

0000858c <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    858c:	push	{r3, r4, r5, r6, r7, lr}
    858e:	mov	r7, r0
    8590:	mov	r4, r1
  if (m_sdioConfig.useDma()) {
    8592:	ldrb	r6, [r7, #8]
    8594:	lsls	r6, r6, #31
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    8596:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    8598:	bpl.n	85d6 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x4a>
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
    859a:	lsls	r6, r2, #30
    859c:	beq.n	85be <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x32>
    859e:	adds	r6, r1, r3
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    85a0:	cmp	r4, r6
    85a2:	beq.n	85f4 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
        if (!writeSector(sector, ptr)) {
    85a4:	ldr	r3, [r7, #0]
    85a6:	mov	r2, r5
    85a8:	ldr	r3, [r3, #32]
    85aa:	mov	r1, r4
    85ac:	mov	r0, r7
    85ae:	blx	r3
    85b0:	cbnz	r0, 85b6 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2a>
          return false;  // writeSector will set errorCode.
    85b2:	movs	r0, #0
    85b4:	pop	{r3, r4, r5, r6, r7, pc}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    85b6:	adds	r4, #1
    85b8:	add.w	r5, r5, #512	; 0x200
    85bc:	b.n	85a0 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x14>
          return false;  // writeSector will set errorCode.
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
    85be:	ldr	r0, [pc, #56]	; (85f8 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x6c>)
    85c0:	bl	81c8 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    85c4:	cbnz	r0, 85f4 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    85c6:	ldr	r3, [pc, #52]	; (85fc <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x70>)
    85c8:	movs	r2, #14
    85ca:	strb	r2, [r3, #0]
  m_errorLine = line;
    85cc:	ldr	r3, [pc, #48]	; (8600 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x74>)
    85ce:	movw	r2, #1105	; 0x451
    85d2:	str	r2, [r3, #0]
    85d4:	pop	{r3, r4, r5, r6, r7, pc}
    85d6:	adds	r6, r1, r3
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
      return sdError(SD_CARD_ERROR_CMD25);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    85d8:	cmp	r4, r6
    85da:	beq.n	85f4 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x68>
      if (!writeSector(sector + i, src + i*512UL)) {
    85dc:	ldr	r3, [r7, #0]
    85de:	mov	r2, r5
    85e0:	mov	r1, r4
    85e2:	ldr	r3, [r3, #32]
    85e4:	mov	r0, r7
    85e6:	blx	r3
    85e8:	adds	r4, #1
    85ea:	add.w	r5, r5, #512	; 0x200
    85ee:	cmp	r0, #0
    85f0:	bne.n	85d8 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x4c>
    85f2:	b.n	85b2 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x26>
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
        if (!writeSector(sector, ptr)) {
          return false;  // writeSector will set errorCode.
        }
      }
      return true;
    85f4:	movs	r0, #1
        return false;
      }
    }
  }
  return true;
}
    85f6:	pop	{r3, r4, r5, r6, r7, pc}
    85f8:	.word	0x193a0027
    85fc:	.word	0x1fff135c
    8600:	.word	0x2001cf08

00008604 <SdioCard::writeSector(unsigned long, unsigned char const*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    8604:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    8606:	ldrb	r3, [r0, #8]
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    8608:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    860a:	lsls	r2, r3, #31
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
#endif  // ENABLE_TEENSY_SDIO_MOD
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    860c:	sub.w	sp, sp, #512	; 0x200
    8610:	mov	r4, r0
    8612:	mov	r6, r1
  if (m_sdioConfig.useDma()) {
    8614:	bpl.n	8648 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x44>
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
    8616:	lsls	r3, r5, #30
    8618:	beq.n	8628 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x24>
      ptr = aligned;
      memcpy(aligned, src, 512);
    861a:	mov	r1, r5
    861c:	mov.w	r2, #512	; 0x200
    8620:	mov	r0, sp
    8622:	bl	8e18 <memcpy>
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
      ptr = aligned;
    8626:	mov	r5, sp
      memcpy(aligned, src, 512);
    } else {
      ptr = const_cast<uint8_t*>(src);
    }
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
    8628:	movs	r3, #1
    862a:	mov	r2, r5
    862c:	mov	r1, r6
    862e:	ldr	r0, [pc, #132]	; (86b4 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb0>)
    8630:	bl	81c8 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    8634:	cmp	r0, #0
    8636:	bne.n	86ac <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8638:	ldr	r3, [pc, #124]	; (86b8 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb4>)
    863a:	movs	r2, #13
    863c:	strb	r2, [r3, #0]
  m_errorLine = line;
    863e:	ldr	r3, [pc, #124]	; (86bc <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb8>)
    8640:	movw	r2, #1049	; 0x419
    8644:	str	r2, [r3, #0]
    8646:	b.n	86ac <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
    if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD24);
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    8648:	bl	83a0 <waitTransferComplete()>
    864c:	cbnz	r0, 8652 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4e>
      return false;
    864e:	movs	r0, #0
    8650:	b.n	86ac <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    8652:	ldr	r3, [pc, #108]	; (86c0 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xbc>)
    8654:	ldr	r3, [r3, #0]
    8656:	lsrs	r3, r3, #16
    8658:	lsls	r3, r3, #16
    865a:	cbz	r3, 8664 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x60>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    865c:	ldrb	r3, [r4, #9]
    865e:	cmp	r3, #2
    8660:	bne.n	8678 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x74>
    8662:	b.n	8672 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x6e>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    8664:	ldr	r3, [r4, #0]
    8666:	mov	r0, r4
    8668:	ldr	r3, [r3, #28]
    866a:	blx	r3
    866c:	cmp	r0, #0
    866e:	bne.n	865c <SdioCard::writeSector(unsigned long, unsigned char const*)+0x58>
    8670:	b.n	864e <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    8672:	ldr	r3, [r4, #4]
    8674:	cmp	r6, r3
    8676:	beq.n	8698 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x94>
      if (!syncDevice()) {
    8678:	ldr	r3, [r4, #0]
    867a:	mov	r0, r4
    867c:	ldr	r3, [r3, #28]
    867e:	blx	r3
    8680:	cmp	r0, #0
    8682:	beq.n	864e <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
      if (!writeStart(sector )) {
    8684:	ldr	r3, [r4, #0]
    8686:	mov	r1, r6
    8688:	ldr	r3, [r3, #80]	; 0x50
    868a:	mov	r0, r4
    868c:	blx	r3
    868e:	cmp	r0, #0
    8690:	beq.n	864e <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
        return false;
      }
      m_curSector = sector;
      m_curState = WRITE_STATE;
    8692:	movs	r3, #2
        return false;
      }
      if (!writeStart(sector )) {
        return false;
      }
      m_curSector = sector;
    8694:	str	r6, [r4, #4]
      m_curState = WRITE_STATE;
    8696:	strb	r3, [r4, #9]
    }
    if (!writeData(src)) {
    8698:	ldr	r3, [r4, #0]
    869a:	mov	r1, r5
    869c:	ldr	r3, [r3, #76]	; 0x4c
    869e:	mov	r0, r4
    86a0:	blx	r3
    86a2:	cmp	r0, #0
    86a4:	beq.n	864e <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4a>
      return false;
    }
    m_curSector++;
    86a6:	ldr	r3, [r4, #4]
    86a8:	adds	r3, #1
    86aa:	str	r3, [r4, #4]
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
#endif  // !ENABLE_TEENSY_SDIO_MOD
  }
  return true;
}
    86ac:	add.w	sp, sp, #512	; 0x200
    86b0:	pop	{r4, r5, r6, pc}
    86b2:	nop
    86b4:	.word	0x183a0001
    86b8:	.word	0x1fff135c
    86bc:	.word	0x2001cf08
    86c0:	.word	0x400b1004

000086c4 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    86c4:	push	{r3, r4, r5, r6, r7, lr}
    86c6:	mov	r7, r0
    86c8:	mov	r4, r1
  if (m_sdioConfig.useDma()) {
    86ca:	ldrb	r6, [r7, #8]
    86cc:	lsls	r6, r6, #31
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    86ce:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    86d0:	bpl.n	870e <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4a>
    if ((uint32_t)dst & 3) {
    86d2:	lsls	r6, r2, #30
    86d4:	beq.n	86f6 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x32>
    86d6:	adds	r6, r1, r3
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    86d8:	cmp	r4, r6
    86da:	beq.n	872c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
        if (!readSector(sector, dst)) {
    86dc:	ldr	r3, [r7, #0]
    86de:	mov	r2, r5
    86e0:	ldr	r3, [r3, #12]
    86e2:	mov	r1, r4
    86e4:	mov	r0, r7
    86e6:	blx	r3
    86e8:	cbnz	r0, 86ee <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x2a>
          return false;  // readSector will set errorCode.
    86ea:	movs	r0, #0
    86ec:	pop	{r3, r4, r5, r6, r7, pc}
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
  if (m_sdioConfig.useDma()) {
    if ((uint32_t)dst & 3) {
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    86ee:	adds	r4, #1
    86f0:	add.w	r5, r5, #512	; 0x200
    86f4:	b.n	86d8 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x14>
          return false;  // readSector will set errorCode.
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
    86f6:	ldr	r0, [pc, #56]	; (8730 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x6c>)
    86f8:	bl	81c8 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    86fc:	cbnz	r0, 872c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    86fe:	ldr	r3, [pc, #52]	; (8734 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x70>)
    8700:	movs	r2, #12
    8702:	strb	r2, [r3, #0]
  m_errorLine = line;
    8704:	ldr	r3, [pc, #48]	; (8738 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x74>)
    8706:	mov.w	r2, #912	; 0x390
    870a:	str	r2, [r3, #0]
    870c:	pop	{r3, r4, r5, r6, r7, pc}
    870e:	adds	r6, r1, r3
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
      return sdError(SD_CARD_ERROR_CMD18);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    8710:	cmp	r4, r6
    8712:	beq.n	872c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x68>
      if (!readSector(sector + i, dst + i*512UL)) {
    8714:	ldr	r3, [r7, #0]
    8716:	mov	r2, r5
    8718:	mov	r1, r4
    871a:	ldr	r3, [r3, #12]
    871c:	mov	r0, r7
    871e:	blx	r3
    8720:	adds	r4, #1
    8722:	add.w	r5, r5, #512	; 0x200
    8726:	cmp	r0, #0
    8728:	bne.n	8710 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x4c>
    872a:	b.n	86ea <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x26>
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
        if (!readSector(sector, dst)) {
          return false;  // readSector will set errorCode.
        }
      }
      return true;
    872c:	movs	r0, #1
        return false;
      }
    }
  }
  return true;
}
    872e:	pop	{r3, r4, r5, r6, r7, pc}
    8730:	.word	0x123a0037
    8734:	.word	0x1fff135c
    8738:	.word	0x2001cf08

0000873c <cardCMD6(unsigned long, unsigned char*)>:

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    873c:	push	{r3, r4, r5, lr}
    873e:	mov	r4, r0
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    8740:	ldr	r0, [pc, #104]	; (87ac <cardCMD6(unsigned long, unsigned char*)+0x70>)

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    8742:	mov	r5, r1
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    8744:	bl	8024 <waitTimeout(bool (*)())>
    8748:	cbz	r0, 8756 <cardCMD6(unsigned long, unsigned char*)+0x1a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    874a:	ldr	r3, [pc, #100]	; (87b0 <cardCMD6(unsigned long, unsigned char*)+0x74>)
    874c:	movs	r2, #10
    874e:	strb	r2, [r3, #0]
  m_errorLine = line;
    8750:	movw	r2, #413	; 0x19d
    8754:	b.n	8798 <cardCMD6(unsigned long, unsigned char*)+0x5c>
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    8756:	ldr	r3, [pc, #92]	; (87b4 <cardCMD6(unsigned long, unsigned char*)+0x78>)
    8758:	movs	r2, #1
    875a:	strb	r2, [r3, #0]
  m_irqstat = 0;
    875c:	ldr	r3, [pc, #88]	; (87b8 <cardCMD6(unsigned long, unsigned char*)+0x7c>)
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    875e:	ldr	r2, [pc, #92]	; (87bc <cardCMD6(unsigned long, unsigned char*)+0x80>)
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    8760:	str	r0, [r3, #0]
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    8762:	ldr	r3, [pc, #92]	; (87c0 <cardCMD6(unsigned long, unsigned char*)+0x84>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    8764:	ldr	r0, [pc, #92]	; (87c4 <cardCMD6(unsigned long, unsigned char*)+0x88>)
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    8766:	str	r5, [r3, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    8768:	str	r2, [r3, #4]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    876a:	ldr	r2, [pc, #92]	; (87c8 <cardCMD6(unsigned long, unsigned char*)+0x8c>)
    876c:	str	r2, [r3, #56]	; 0x38
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    876e:	mov	r1, r4
    8770:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    8774:	cbnz	r0, 8786 <cardCMD6(unsigned long, unsigned char*)+0x4a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8776:	ldr	r3, [pc, #56]	; (87b0 <cardCMD6(unsigned long, unsigned char*)+0x74>)
    8778:	movs	r2, #4
    877a:	strb	r2, [r3, #0]
  m_errorLine = line;
    877c:	ldr	r3, [pc, #76]	; (87cc <cardCMD6(unsigned long, unsigned char*)+0x90>)
    877e:	mov.w	r2, #420	; 0x1a4
    8782:	str	r2, [r3, #0]
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
    8784:	pop	{r3, r4, r5, pc}
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    8786:	ldr	r0, [pc, #72]	; (87d0 <cardCMD6(unsigned long, unsigned char*)+0x94>)
    8788:	bl	8048 <yieldTimeout(bool (*)())>
    878c:	cbz	r0, 87a0 <cardCMD6(unsigned long, unsigned char*)+0x64>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    878e:	ldr	r3, [pc, #32]	; (87b0 <cardCMD6(unsigned long, unsigned char*)+0x74>)
    8790:	movs	r2, #37	; 0x25
    8792:	strb	r2, [r3, #0]
  m_errorLine = line;
    8794:	movw	r2, #423	; 0x1a7
    8798:	ldr	r3, [pc, #48]	; (87cc <cardCMD6(unsigned long, unsigned char*)+0x90>)
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    return sdError(SD_CARD_ERROR_DMA);
    879a:	movs	r0, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    879c:	str	r2, [r3, #0]
    879e:	pop	{r3, r4, r5, pc}
    87a0:	bl	81a8 <waitDmaStatus() [clone .part.4]>
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    87a4:	cmp	r0, #0
    87a6:	beq.n	878e <cardCMD6(unsigned long, unsigned char*)+0x52>
    return sdError(SD_CARD_ERROR_DMA);
  }
  return true;
}
    87a8:	pop	{r3, r4, r5, pc}
    87aa:	nop
    87ac:	.word	0x0000812d
    87b0:	.word	0x1fff135c
    87b4:	.word	0x2001cf01
    87b8:	.word	0x2001ceec
    87bc:	.word	0x00010040
    87c0:	.word	0x400b1000
    87c4:	.word	0x063a0011
    87c8:	.word	0x117f0002
    87cc:	.word	0x2001cf08
    87d0:	.word	0x00007edd

000087d4 <SdioCard::begin(SdioConfig)>:
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    87d4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    87d8:	ldr	r4, [pc, #712]	; (8aa4 <SdioCard::begin(SdioConfig)+0x2d0>)
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    87da:	ldr	r2, [pc, #716]	; (8aa8 <SdioCard::begin(SdioConfig)+0x2d4>)
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
    87dc:	ldr.w	ip, [pc, #828]	; 8b1c <SdioCard::begin(SdioConfig)+0x348>
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    87e0:	ldr.w	lr, [pc, #828]	; 8b20 <SdioCard::begin(SdioConfig)+0x34c>
  m_version2 = false;
    87e4:	ldr.w	sl, [pc, #828]	; 8b24 <SdioCard::begin(SdioConfig)+0x350>
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
    87e8:	strb	r1, [r0, #8]
  m_curState = IDLE_STATE;
    87ea:	movs	r3, #0
    87ec:	strb	r3, [r0, #9]
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    87ee:	strb	r3, [r4, #0]
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
    87f0:	strb.w	r3, [ip]
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    87f4:	strb.w	r3, [lr]
  m_version2 = false;
    87f8:	strb.w	r3, [sl]
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    87fc:	ldr	r3, [r2, #0]
  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    87fe:	ldr	r0, [pc, #684]	; (8aac <SdioCard::begin(SdioConfig)+0x2d8>)
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8800:	ldr	r5, [pc, #684]	; (8ab0 <SdioCard::begin(SdioConfig)+0x2dc>)
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8802:	ldr	r6, [pc, #688]	; (8ab4 <SdioCard::begin(SdioConfig)+0x2e0>)
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8804:	ldr	r7, [pc, #688]	; (8ab8 <SdioCard::begin(SdioConfig)+0x2e4>)
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8806:	ldr.w	r8, [pc, #800]	; 8b28 <SdioCard::begin(SdioConfig)+0x354>
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    880a:	ldr	r1, [pc, #688]	; (8abc <SdioCard::begin(SdioConfig)+0x2e8>)
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    880c:	orr.w	r3, r3, #201326592	; 0xc000000
    8810:	str	r3, [r2, #0]
#endif  // HAS_KINETIS_MPU
  // Enable SDHC clock.
  SIM_SCGC3 |= SIM_SCGC3_SDHC;
    8812:	add.w	r2, r2, #239616	; 0x3a800
    8816:	adds	r2, #48	; 0x30
    8818:	ldr	r3, [r2, #0]
    881a:	orr.w	r3, r3, #131072	; 0x20000
    881e:	str	r3, [r2, #0]
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8820:	ldr	r2, [pc, #668]	; (8ac0 <SdioCard::begin(SdioConfig)+0x2ec>)
    8822:	movw	r3, #259	; 0x103
    8826:	str	r3, [r2, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8828:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    882a:	str	r3, [r6, #0]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    882c:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    882e:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8832:	str	r3, [r0, #0]
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    8834:	ldr	r3, [r1, #0]
}
#endif  // ENABLE_TEENSY_SDIO_MOD
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    8836:	sub	sp, #84	; 0x54
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif  //  (__IMXRT1062__)

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    8838:	orr.w	r3, r3, #16777216	; 0x1000000
    883c:	orr.w	r3, r3, #32768	; 0x8000
    8840:	str	r3, [r1, #0]
    8842:	mov	r9, r0
    8844:	str.w	ip, [sp, #4]
    8848:	str.w	lr, [sp, #8]
    884c:	mov	fp, r1

  while (SDHC_SYSCTL & SDHC_SYSCTL_RSTA) {
    884e:	ldr.w	r1, [fp]
    8852:	ldr	r3, [pc, #616]	; (8abc <SdioCard::begin(SdioConfig)+0x2e8>)
    8854:	lsls	r1, r1, #7
    8856:	bmi.n	884e <SdioCard::begin(SdioConfig)+0x7a>
  }

  // Set initial SCK rate.
  setSdclk(SD_MAX_INIT_RATE_KHZ);
    8858:	mov.w	r0, #400	; 0x190
    885c:	str	r3, [sp, #0]
    885e:	str	r2, [sp, #12]
    8860:	bl	7f28 <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8864:	ldr	r2, [sp, #12]
    8866:	movw	r1, #1091	; 0x443
    886a:	str	r1, [r2, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    886c:	mov.w	r2, #1088	; 0x440
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8870:	str	r1, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8872:	str	r2, [r6, #0]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    8874:	ldr	r2, [pc, #588]	; (8ac4 <SdioCard::begin(SdioConfig)+0x2f0>)
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8876:	str	r1, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8878:	str.w	r1, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    887c:	str.w	r1, [r9]
  setSdclk(SD_MAX_INIT_RATE_KHZ);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    8880:	ldr	r1, [pc, #580]	; (8ac8 <SdioCard::begin(SdioConfig)+0x2f4>)
    8882:	str	r1, [r2, #0]

  attachInterruptVector(IRQ_SDHC, sdIrs);
    8884:	movs	r0, #81	; 0x51
    8886:	ldr	r1, [pc, #580]	; (8acc <SdioCard::begin(SdioConfig)+0x2f8>)
    8888:	bl	9334 <attachInterruptVector>
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    888c:	ldr	r2, [pc, #576]	; (8ad0 <SdioCard::begin(SdioConfig)+0x2fc>)
    888e:	movs	r1, #96	; 0x60
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    8890:	mvn.w	r0, #840	; 0x348

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    8894:	strb	r1, [r2, #0]
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    8896:	add	r2, r0

  // Send 80 clocks to card.
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    8898:	ldr	r3, [sp, #0]
  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    889a:	mov.w	r1, #131072	; 0x20000
    889e:	str	r1, [r2, #0]

  // Send 80 clocks to card.
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    88a0:	ldr	r2, [r3, #0]
    88a2:	orr.w	r2, r2, #134217728	; 0x8000000
    88a6:	str	r2, [r3, #0]
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
    88a8:	ldr.w	r1, [fp]
    88ac:	ands.w	r1, r1, #134217728	; 0x8000000
    88b0:	bne.n	88a8 <SdioCard::begin(SdioConfig)+0xd4>
  m_highCapacity = false;
  m_version2 = false;

  // initialize controller.
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    88b2:	mov	r0, r1
    88b4:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    88b8:	mov	fp, r0
    88ba:	cbnz	r0, 88c6 <SdioCard::begin(SdioConfig)+0xf2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    88bc:	movs	r3, #1
    88be:	strb	r3, [r4, #0]
  m_errorLine = line;
    88c0:	movw	r2, #662	; 0x296
    88c4:	b.n	896e <SdioCard::begin(SdioConfig)+0x19a>
    88c6:	mov.w	fp, #3
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
    88ca:	mov.w	r1, #426	; 0x1aa
    88ce:	ldr	r0, [pc, #516]	; (8ad4 <SdioCard::begin(SdioConfig)+0x300>)
    88d0:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    88d4:	cbz	r0, 88f2 <SdioCard::begin(SdioConfig)+0x11e>
      if (SDHC_CMDRSP0 != 0X1AA) {
    88d6:	ldr	r3, [pc, #512]	; (8ad8 <SdioCard::begin(SdioConfig)+0x304>)
    88d8:	ldr	r3, [r3, #0]
    88da:	cmp.w	r3, #426	; 0x1aa
    88de:	beq.n	88ea <SdioCard::begin(SdioConfig)+0x116>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    88e0:	movs	r3, #6
    88e2:	strb	r3, [r4, #0]
  m_errorLine = line;
    88e4:	mov.w	r2, #668	; 0x29c
    88e8:	b.n	8a0a <SdioCard::begin(SdioConfig)+0x236>
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
      if (SDHC_CMDRSP0 != 0X1AA) {
        return sdError(SD_CARD_ERROR_CMD8);
      }
      m_version2 = true;
    88ea:	movs	r3, #1
    88ec:	strb.w	r3, [sl]
      break;
    88f0:	b.n	88f8 <SdioCard::begin(SdioConfig)+0x124>
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    88f2:	subs.w	fp, fp, #1
    88f6:	bne.n	88ca <SdioCard::begin(SdioConfig)+0xf6>
      }
      m_version2 = true;
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
    88f8:	ldrb.w	r3, [sl]
    88fc:	cmp	r3, #0
    88fe:	ldr	r3, [pc, #476]	; (8adc <SdioCard::begin(SdioConfig)+0x308>)
    8900:	ite	eq
    8902:	moveq.w	fp, #3145728	; 0x300000
    8906:	movne	fp, r3
  int m = micros();
    8908:	bl	9418 <micros>
    890c:	str	r0, [sp, #0]
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    890e:	movs	r1, #0
    8910:	ldr	r0, [pc, #460]	; (8ae0 <SdioCard::begin(SdioConfig)+0x30c>)
    8912:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    8916:	cmp	r0, #0
    8918:	beq.n	89f8 <SdioCard::begin(SdioConfig)+0x224>
    891a:	mov	r1, fp
    891c:	ldr	r0, [pc, #452]	; (8ae4 <SdioCard::begin(SdioConfig)+0x310>)
    891e:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    8922:	cmp	r0, #0
    8924:	beq.n	89f8 <SdioCard::begin(SdioConfig)+0x224>
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
    8926:	bl	9418 <micros>
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
    892a:	ldr	r3, [sp, #0]
    892c:	subs	r0, r0, r3
    892e:	ldr	r3, [pc, #440]	; (8ae8 <SdioCard::begin(SdioConfig)+0x314>)
    8930:	cmp	r0, r3
    8932:	bhi.n	89f8 <SdioCard::begin(SdioConfig)+0x224>
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
    8934:	ldr	r3, [pc, #416]	; (8ad8 <SdioCard::begin(SdioConfig)+0x304>)
    8936:	ldr.w	sl, [pc, #416]	; 8ad8 <SdioCard::begin(SdioConfig)+0x304>
    893a:	ldr	r3, [r3, #0]
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    893c:	cmp	r3, #0
    893e:	bge.n	890e <SdioCard::begin(SdioConfig)+0x13a>
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
    8940:	ldr	r2, [pc, #424]	; (8aec <SdioCard::begin(SdioConfig)+0x318>)
    8942:	ldr.w	r1, [sl]
    8946:	str	r1, [r2, #0]
  if (SDHC_CMDRSP0 & 0x40000000) {
    8948:	ldr.w	r2, [sl]
    // Is high capacity.
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    894c:	ldr	r0, [pc, #416]	; (8af0 <SdioCard::begin(SdioConfig)+0x31c>)
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    894e:	lsls	r2, r2, #1
    // Is high capacity.
    m_highCapacity = true;
    8950:	itt	mi
    8952:	ldrmi	r3, [sp, #8]
    8954:	movmi	r2, #1
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    8956:	mov.w	r1, #0
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    // Is high capacity.
    m_highCapacity = true;
    895a:	it	mi
    895c:	strbmi	r2, [r3, #0]
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    895e:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    8962:	mov	fp, r0
    8964:	cbnz	r0, 8974 <SdioCard::begin(SdioConfig)+0x1a0>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8966:	movs	r3, #2
    8968:	strb	r3, [r4, #0]
  m_errorLine = line;
    896a:	mov.w	r2, #688	; 0x2b0
    896e:	ldr	r3, [pc, #388]	; (8af4 <SdioCard::begin(SdioConfig)+0x320>)
    8970:	str	r2, [r3, #0]
  if (SDHC_CMDRSP0 & 0x40000000) {
    // Is high capacity.
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD2);
    8972:	b.n	8a9a <SdioCard::begin(SdioConfig)+0x2c6>
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    8974:	movs	r1, #0
    8976:	ldr	r0, [pc, #384]	; (8af8 <SdioCard::begin(SdioConfig)+0x324>)
    8978:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    897c:	mov	fp, r0
    897e:	cbnz	r0, 898a <SdioCard::begin(SdioConfig)+0x1b6>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8980:	movs	r3, #3
    8982:	strb	r3, [r4, #0]
  m_errorLine = line;
    8984:	movw	r2, #691	; 0x2b3
    8988:	b.n	896e <SdioCard::begin(SdioConfig)+0x19a>
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    898a:	ldr.w	r3, [sl]
    898e:	ldr.w	sl, [pc, #412]	; 8b2c <SdioCard::begin(SdioConfig)+0x358>

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    8992:	ldr	r1, [pc, #360]	; (8afc <SdioCard::begin(SdioConfig)+0x328>)
    8994:	ldr	r0, [pc, #360]	; (8b00 <SdioCard::begin(SdioConfig)+0x32c>)
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    8996:	lsrs	r3, r3, #16
    8998:	lsls	r3, r3, #16
    899a:	str.w	r3, [sl]

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    899e:	bl	8140 <readReg16(unsigned long, void*)>
    89a2:	mov	fp, r0
    89a4:	cbnz	r0, 89b0 <SdioCard::begin(SdioConfig)+0x1dc>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    89a6:	movs	r3, #7
    89a8:	strb	r3, [r4, #0]
  m_errorLine = line;
    89aa:	mov.w	r2, #696	; 0x2b8
    89ae:	b.n	896e <SdioCard::begin(SdioConfig)+0x19a>
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    return sdError(SD_CARD_ERROR_CMD9);
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    89b0:	ldr	r1, [pc, #336]	; (8b04 <SdioCard::begin(SdioConfig)+0x330>)
    89b2:	ldr	r0, [pc, #340]	; (8b08 <SdioCard::begin(SdioConfig)+0x334>)
    89b4:	bl	8140 <readReg16(unsigned long, void*)>
    89b8:	mov	fp, r0
    89ba:	cbnz	r0, 89c6 <SdioCard::begin(SdioConfig)+0x1f2>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    89bc:	movs	r3, #8
    89be:	strb	r3, [r4, #0]
  m_errorLine = line;
    89c0:	movw	r2, #699	; 0x2bb
    89c4:	b.n	896e <SdioCard::begin(SdioConfig)+0x19a>
    return sdError(SD_CARD_ERROR_CMD9);
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    return sdError(SD_CARD_ERROR_CMD10);
  }
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    89c6:	ldr.w	r1, [sl]
    89ca:	ldr	r0, [pc, #320]	; (8b0c <SdioCard::begin(SdioConfig)+0x338>)
    89cc:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    89d0:	mov	fp, r0
    89d2:	cbnz	r0, 89de <SdioCard::begin(SdioConfig)+0x20a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    89d4:	movs	r3, #5
    89d6:	strb	r3, [r4, #0]
  m_errorLine = line;
    89d8:	movw	r2, #702	; 0x2be
    89dc:	b.n	896e <SdioCard::begin(SdioConfig)+0x19a>
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    89de:	ldr.w	r1, [sl]
    89e2:	ldr	r0, [pc, #252]	; (8ae0 <SdioCard::begin(SdioConfig)+0x30c>)
    89e4:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    89e8:	cbz	r0, 8a02 <SdioCard::begin(SdioConfig)+0x22e>
    89ea:	movs	r1, #2
    89ec:	ldr	r0, [pc, #288]	; (8b10 <SdioCard::begin(SdioConfig)+0x33c>)
    89ee:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    89f2:	mov	fp, r0
    89f4:	cbz	r0, 8a02 <SdioCard::begin(SdioConfig)+0x22e>
    89f6:	b.n	8a14 <SdioCard::begin(SdioConfig)+0x240>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    89f8:	movs	r3, #23
    89fa:	strb	r3, [r4, #0]
  m_errorLine = line;
    89fc:	movw	r2, #679	; 0x2a7
    8a00:	b.n	8a0a <SdioCard::begin(SdioConfig)+0x236>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8a02:	movs	r3, #20
    8a04:	strb	r3, [r4, #0]
  m_errorLine = line;
    8a06:	movw	r2, #706	; 0x2c2
    8a0a:	ldr	r3, [pc, #232]	; (8af4 <SdioCard::begin(SdioConfig)+0x320>)
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
  }
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
    8a0c:	mov.w	fp, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8a10:	str	r2, [r3, #0]
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
  }
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
    8a12:	b.n	8a9a <SdioCard::begin(SdioConfig)+0x2c6>
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
    8a14:	ldr	r3, [pc, #252]	; (8b14 <SdioCard::begin(SdioConfig)+0x340>)
    8a16:	ldr	r2, [r3, #0]
    8a18:	bic.w	r2, r2, #6
    8a1c:	str	r2, [r3, #0]
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);
    8a1e:	ldr	r2, [r3, #0]
    8a20:	orr.w	r2, r2, #2
    8a24:	str	r2, [r3, #0]

  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);
    8a26:	mov.w	r2, #1048592	; 0x100010
    8a2a:	str	r2, [r3, #28]

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8a2c:	add	r1, sp, #16
    8a2e:	mvn.w	r0, #4278190080	; 0xff000000
    8a32:	bl	873c <cardCMD6(unsigned long, unsigned char*)>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    8a36:	cbz	r0, 8a40 <SdioCard::begin(SdioConfig)+0x26c>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8a38:	ldrb.w	r3, [sp, #29]
    8a3c:	lsls	r3, r3, #30
    8a3e:	bmi.n	8a46 <SdioCard::begin(SdioConfig)+0x272>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    kHzSdClk = 50000;
  } else {
    kHzSdClk = 25000;
    8a40:	movw	r0, #25000	; 0x61a8
    8a44:	b.n	8a62 <SdioCard::begin(SdioConfig)+0x28e>

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    8a46:	add	r1, sp, #16
    8a48:	ldr	r0, [pc, #204]	; (8b18 <SdioCard::begin(SdioConfig)+0x344>)
    8a4a:	bl	873c <cardCMD6(unsigned long, unsigned char*)>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    8a4e:	cmp	r0, #0
    8a50:	beq.n	8a40 <SdioCard::begin(SdioConfig)+0x26c>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    8a52:	ldrb.w	r3, [sp, #32]
    8a56:	and.w	r3, r3, #15
    8a5a:	cmp	r3, #1
    8a5c:	bne.n	8a40 <SdioCard::begin(SdioConfig)+0x26c>
    kHzSdClk = 50000;
    8a5e:	movw	r0, #50000	; 0xc350
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8a62:	ldr	r4, [pc, #92]	; (8ac0 <SdioCard::begin(SdioConfig)+0x2ec>)
    8a64:	movw	r3, #259	; 0x103
    8a68:	str	r3, [r4, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8a6a:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8a6c:	str	r3, [r6, #0]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8a6e:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8a70:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8a74:	str.w	r3, [r9]
  }
  // Disable GPIO.
  enableGPIO(false);

  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);
    8a78:	bl	7f28 <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8a7c:	movw	r3, #1091	; 0x443
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8a80:	mov.w	r2, #1088	; 0x440
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    8a84:	str	r3, [r4, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    8a86:	str	r3, [r5, #0]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    8a88:	str	r2, [r6, #0]
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    8a8a:	ldr	r2, [sp, #4]
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    8a8c:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    8a8e:	str.w	r3, [r8]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    8a92:	str.w	r3, [r9]
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    8a96:	movs	r3, #1
    8a98:	strb	r3, [r2, #0]
  return true;
}
    8a9a:	mov	r0, fp
    8a9c:	add	sp, #84	; 0x54
    8a9e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8aa2:	nop
    8aa4:	.word	0x1fff135c
    8aa8:	.word	0x4000d800
    8aac:	.word	0x4004d014
    8ab0:	.word	0x4004d004
    8ab4:	.word	0x4004d008
    8ab8:	.word	0x4004d00c
    8abc:	.word	0x400b102c
    8ac0:	.word	0x4004d000
    8ac4:	.word	0x400b1034
    8ac8:	.word	0x117f000b
    8acc:	.word	0x00007e79
    8ad0:	.word	0xe000e451
    8ad4:	.word	0x081a0000
    8ad8:	.word	0x400b1010
    8adc:	.word	0x40300000
    8ae0:	.word	0x371a0000
    8ae4:	.word	0x29020000
    8ae8:	.word	0x000f4240
    8aec:	.word	0x2001cee0
    8af0:	.word	0x02090000
    8af4:	.word	0x2001cf08
    8af8:	.word	0x031a0000
    8afc:	.word	0x2001cef1
    8b00:	.word	0x09090000
    8b04:	.word	0x2001cec5
    8b08:	.word	0x0a090000
    8b0c:	.word	0x071b0000
    8b10:	.word	0x061a0000
    8b14:	.word	0x400b1028
    8b18:	.word	0x80fffff1
    8b1c:	.word	0x2001cef0
    8b20:	.word	0x2001cedc
    8b24:	.word	0x2001cec4
    8b28:	.word	0x4004d010
    8b2c:	.word	0x2001cee4

00008b30 <SdioCard::readData(unsigned char*)>:
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    8b30:	push	{r3, r4, r5, lr}
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    8b32:	ldr	r5, [pc, #152]	; (8bcc <SdioCard::readData(unsigned char*)+0x9c>)
    8b34:	ldr	r3, [r5, #0]
    8b36:	lsls	r3, r3, #22
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t* dst) {
    8b38:	mov	r4, r1
  DBG_IRQSTAT();
  uint32_t* p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    8b3a:	bmi.n	8b5a <SdioCard::readData(unsigned char*)+0x2a>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8b3c:	ldr	r3, [pc, #144]	; (8bd0 <SdioCard::readData(unsigned char*)+0xa0>)
    8b3e:	ldr	r2, [r3, #0]
    8b40:	bic.w	r2, r2, #65536	; 0x10000
    8b44:	str	r2, [r3, #0]
    noInterrupts();
    8b46:	cpsid	i
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    8b48:	ldr	r2, [r3, #0]
    8b4a:	orr.w	r2, r2, #131072	; 0x20000
    8b4e:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    8b50:	ldr	r2, [r3, #0]
    8b52:	orr.w	r2, r2, #65536	; 0x10000
    8b56:	str	r2, [r3, #0]
    interrupts();
    8b58:	cpsie	i
  }
  if (waitTimeout(isBusyFifoRead)) {
    8b5a:	ldr	r0, [pc, #120]	; (8bd4 <SdioCard::readData(unsigned char*)+0xa4>)
    8b5c:	bl	8024 <waitTimeout(bool (*)())>
    8b60:	cbnz	r0, 8bb8 <SdioCard::readData(unsigned char*)+0x88>
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    8b62:	ldr	r1, [pc, #116]	; (8bd8 <SdioCard::readData(unsigned char*)+0xa8>)
    8b64:	subs	r3, r4, #4
    8b66:	add.w	r4, r4, #508	; 0x1fc
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    8b6a:	ldr	r2, [r5, #0]
    8b6c:	lsls	r0, r2, #20
    8b6e:	bpl.n	8b6a <SdioCard::readData(unsigned char*)+0x3a>
    8b70:	add.w	r2, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    8b74:	ldr	r0, [r1, #0]
    8b76:	str.w	r0, [r3, #4]!
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    8b7a:	cmp	r2, r3
    8b7c:	bne.n	8b74 <SdioCard::readData(unsigned char*)+0x44>
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    8b7e:	cmp	r4, r2
    8b80:	mov	r3, r2
    8b82:	bne.n	8b6a <SdioCard::readData(unsigned char*)+0x3a>
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    }
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    8b84:	ldr	r0, [pc, #84]	; (8bdc <SdioCard::readData(unsigned char*)+0xac>)
    8b86:	bl	8024 <waitTimeout(bool (*)())>
    8b8a:	cbz	r0, 8b98 <SdioCard::readData(unsigned char*)+0x68>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8b8c:	ldr	r3, [pc, #80]	; (8be0 <SdioCard::readData(unsigned char*)+0xb0>)
    8b8e:	movs	r2, #29
    8b90:	strb	r2, [r3, #0]
  m_errorLine = line;
    8b92:	movw	r2, #846	; 0x34e
    8b96:	b.n	8bc2 <SdioCard::readData(unsigned char*)+0x92>
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
    8b98:	ldr	r2, [pc, #72]	; (8be4 <SdioCard::readData(unsigned char*)+0xb4>)
    8b9a:	ldr	r3, [pc, #76]	; (8be8 <SdioCard::readData(unsigned char*)+0xb8>)
    8b9c:	ldr	r1, [r2, #0]
    8b9e:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    8ba0:	ldr	r1, [r3, #0]
    8ba2:	str	r1, [r2, #0]
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    8ba4:	ldr	r2, [r3, #0]
    8ba6:	lsls	r2, r2, #30
    8ba8:	bpl.n	8bc8 <SdioCard::readData(unsigned char*)+0x98>
    8baa:	ldr	r3, [r3, #0]
    8bac:	ldr	r0, [pc, #60]	; (8bec <SdioCard::readData(unsigned char*)+0xbc>)
    8bae:	ands	r0, r3
    8bb0:	clz	r0, r0
    8bb4:	lsrs	r0, r0, #5
    8bb6:	pop	{r3, r4, r5, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8bb8:	ldr	r3, [pc, #36]	; (8be0 <SdioCard::readData(unsigned char*)+0xb0>)
    8bba:	movs	r2, #26
    8bbc:	strb	r2, [r3, #0]
  m_errorLine = line;
    8bbe:	movw	r2, #835	; 0x343
    8bc2:	ldr	r3, [pc, #44]	; (8bf0 <SdioCard::readData(unsigned char*)+0xc0>)
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
    8bc4:	movs	r0, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    8bc6:	str	r2, [r3, #0]
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
    8bc8:	pop	{r3, r4, r5, pc}
    8bca:	nop
    8bcc:	.word	0x400b1024
    8bd0:	.word	0x400b1028
    8bd4:	.word	0x00007ee9
    8bd8:	.word	0x400b1020
    8bdc:	.word	0x00007f11
    8be0:	.word	0x1fff135c
    8be4:	.word	0x400b1030
    8be8:	.word	0x2001ceec
    8bec:	.word	0x117f0000
    8bf0:	.word	0x2001cf08

00008bf4 <SdioCard::readStart(unsigned long)>:
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    8bf4:	push	{r4, lr}
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    8bf6:	ldr	r0, [pc, #80]	; (8c48 <SdioCard::readStart(unsigned long)+0x54>)
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    8bf8:	mov	r4, r1
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    8bfa:	bl	8048 <yieldTimeout(bool (*)())>
    8bfe:	cbz	r0, 8c12 <SdioCard::readStart(unsigned long)+0x1e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8c00:	ldr	r3, [pc, #72]	; (8c4c <SdioCard::readStart(unsigned long)+0x58>)
    8c02:	movs	r2, #10
    8c04:	strb	r2, [r3, #0]
  m_errorLine = line;
    8c06:	ldr	r3, [pc, #72]	; (8c50 <SdioCard::readStart(unsigned long)+0x5c>)
    8c08:	mov.w	r2, #928	; 0x3a0
    8c0c:	str	r2, [r3, #0]
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    8c0e:	movs	r0, #0
    8c10:	pop	{r4, pc}
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    8c12:	ldr	r2, [pc, #64]	; (8c54 <SdioCard::readStart(unsigned long)+0x60>)
    8c14:	ldr	r3, [r2, #0]
    8c16:	orr.w	r3, r3, #65536	; 0x10000
    8c1a:	str	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(MAX_BLKCNT) | SDHC_BLKATTR_BLKSIZE(512);
    8c1c:	ldr	r3, [pc, #56]	; (8c58 <SdioCard::readStart(unsigned long)+0x64>)
    8c1e:	ldr	r2, [pc, #60]	; (8c5c <SdioCard::readStart(unsigned long)+0x68>)
    8c20:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    8c22:	ldr	r3, [pc, #60]	; (8c60 <SdioCard::readStart(unsigned long)+0x6c>)
    8c24:	ldrb	r3, [r3, #0]
    8c26:	cbnz	r3, 8c2c <SdioCard::readStart(unsigned long)+0x38>
    8c28:	lsls	r1, r4, #9
    8c2a:	b.n	8c2e <SdioCard::readStart(unsigned long)+0x3a>
    8c2c:	mov	r1, r4
    8c2e:	ldr	r0, [pc, #52]	; (8c64 <SdioCard::readStart(unsigned long)+0x70>)
    8c30:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    8c34:	cbnz	r0, 8c44 <SdioCard::readStart(unsigned long)+0x50>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8c36:	ldr	r3, [pc, #20]	; (8c4c <SdioCard::readStart(unsigned long)+0x58>)
    8c38:	movs	r2, #12
    8c3a:	strb	r2, [r3, #0]
  m_errorLine = line;
    8c3c:	ldr	r3, [pc, #16]	; (8c50 <SdioCard::readStart(unsigned long)+0x5c>)
    8c3e:	mov.w	r2, #940	; 0x3ac
    8c42:	str	r2, [r3, #0]

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD18);
  }
  return true;
}
    8c44:	pop	{r4, pc}
    8c46:	nop
    8c48:	.word	0x0000812d
    8c4c:	.word	0x1fff135c
    8c50:	.word	0x2001cf08
    8c54:	.word	0x400b1028
    8c58:	.word	0x400b1004
    8c5c:	.word	0xffff0200
    8c60:	.word	0x2001cedc
    8c64:	.word	0x123a0032

00008c68 <SdioCard::readSector(unsigned long, unsigned char*)>:
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8c68:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    8c6a:	ldrb	r3, [r0, #8]
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8c6c:	mov	r6, r2
  if (m_sdioConfig.useDma()) {
    8c6e:	lsls	r2, r3, #31
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    8c70:	sub.w	sp, sp, #512	; 0x200
    8c74:	mov	r4, r0
    8c76:	mov	r5, r1
  if (m_sdioConfig.useDma()) {
    8c78:	bpl.n	8cb2 <SdioCard::readSector(unsigned long, unsigned char*)+0x4a>
    uint8_t aligned[512];

    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;
    8c7a:	lsls	r3, r6, #30
    8c7c:	ite	eq
    8c7e:	moveq	r4, r6
    8c80:	movne	r4, sp

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
    8c82:	movs	r3, #1
    8c84:	mov	r2, r4
    8c86:	ldr	r0, [pc, #148]	; (8d1c <SdioCard::readSector(unsigned long, unsigned char*)+0xb4>)
    8c88:	bl	81c8 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    8c8c:	mov	r5, r0
    8c8e:	cbnz	r0, 8ca0 <SdioCard::readSector(unsigned long, unsigned char*)+0x38>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8c90:	ldr	r3, [pc, #140]	; (8d20 <SdioCard::readSector(unsigned long, unsigned char*)+0xb8>)
    8c92:	movs	r2, #11
    8c94:	strb	r2, [r3, #0]
  m_errorLine = line;
    8c96:	ldr	r3, [pc, #140]	; (8d24 <SdioCard::readSector(unsigned long, unsigned char*)+0xbc>)
    8c98:	movw	r2, #865	; 0x361
    8c9c:	str	r2, [r3, #0]
    8c9e:	b.n	8d14 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD17);
    }
    if (ptr != dst) {
    8ca0:	cmp	r4, r6
    8ca2:	beq.n	8d14 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
      memcpy(dst, aligned, 512);
    8ca4:	mov.w	r2, #512	; 0x200
    8ca8:	mov	r1, sp
    8caa:	mov	r0, r6
    8cac:	bl	8e18 <memcpy>
    8cb0:	b.n	8d14 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    }
  } else {
#if ENABLE_TEENSY_SDIO_MOD
    if (!waitTransferComplete()) {
    8cb2:	bl	83a0 <waitTransferComplete()>
    8cb6:	cbnz	r0, 8cbc <SdioCard::readSector(unsigned long, unsigned char*)+0x54>
      return false;
    8cb8:	movs	r5, #0
    8cba:	b.n	8d14 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    }
#endif  // ENABLE_TEENSY_SDIO_MOD
    if (m_curState != READ_STATE || sector != m_curSector) {
    8cbc:	ldrb	r3, [r4, #9]
    8cbe:	cmp	r3, #1
    8cc0:	bne.n	8cc8 <SdioCard::readSector(unsigned long, unsigned char*)+0x60>
    8cc2:	ldr	r3, [r4, #4]
    8cc4:	cmp	r5, r3
    8cc6:	beq.n	8ce6 <SdioCard::readSector(unsigned long, unsigned char*)+0x7e>
      if (!syncDevice()) {
    8cc8:	ldr	r3, [r4, #0]
    8cca:	mov	r0, r4
    8ccc:	ldr	r3, [r3, #28]
    8cce:	blx	r3
    8cd0:	cmp	r0, #0
    8cd2:	beq.n	8cb8 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
        return false;
      }
      if (!readStart(sector)) {
    8cd4:	mov	r1, r5
    8cd6:	mov	r0, r4
    8cd8:	bl	8bf4 <SdioCard::readStart(unsigned long)>
    8cdc:	cmp	r0, #0
    8cde:	beq.n	8cb8 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
        return false;
      }
      m_curSector = sector;
      m_curState = READ_STATE;
    8ce0:	movs	r3, #1
        return false;
      }
      if (!readStart(sector)) {
        return false;
      }
      m_curSector = sector;
    8ce2:	str	r5, [r4, #4]
      m_curState = READ_STATE;
    8ce4:	strb	r3, [r4, #9]
    }
    if (!readData(dst)) {
    8ce6:	mov	r1, r6
    8ce8:	mov	r0, r4
    8cea:	bl	8b30 <SdioCard::readData(unsigned char*)>
    8cee:	mov	r5, r0
    8cf0:	cmp	r0, #0
    8cf2:	beq.n	8cb8 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    8cf4:	ldr	r3, [pc, #48]	; (8d28 <SdioCard::readSector(unsigned long, unsigned char*)+0xc0>)
    8cf6:	ldr	r3, [r3, #0]
    8cf8:	lsrs	r3, r3, #16
    8cfa:	lsls	r3, r3, #16
    8cfc:	cbz	r3, 8d06 <SdioCard::readSector(unsigned long, unsigned char*)+0x9e>
      if (!syncDevice()) {
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
    8cfe:	ldr	r3, [r4, #4]
    8d00:	adds	r3, #1
    8d02:	str	r3, [r4, #4]
    8d04:	b.n	8d14 <SdioCard::readSector(unsigned long, unsigned char*)+0xac>
    if (!readData(dst)) {
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    8d06:	ldr	r3, [r4, #0]
    8d08:	mov	r0, r4
    8d0a:	ldr	r3, [r3, #28]
    8d0c:	blx	r3
    8d0e:	cmp	r0, #0
    8d10:	bne.n	8cfe <SdioCard::readSector(unsigned long, unsigned char*)+0x96>
    8d12:	b.n	8cb8 <SdioCard::readSector(unsigned long, unsigned char*)+0x50>
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
}
    8d14:	mov	r0, r5
    8d16:	add.w	sp, sp, #512	; 0x200
    8d1a:	pop	{r4, r5, r6, pc}
    8d1c:	.word	0x113a0011
    8d20:	.word	0x1fff135c
    8d24:	.word	0x2001cf08
    8d28:	.word	0x400b1004

00008d2c <SdioCard::stopTransmission(bool)>:
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    8d2c:	push	{r4, r5, r6, lr}
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8d2e:	ldr	r2, [pc, #72]	; (8d78 <SdioCard::stopTransmission(bool)+0x4c>)
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
    8d30:	movs	r5, #0
    8d32:	strb	r5, [r0, #9]
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8d34:	ldr	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    8d36:	ldr	r0, [pc, #68]	; (8d7c <SdioCard::stopTransmission(bool)+0x50>)
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8d38:	bic.w	r3, r3, #65536	; 0x10000
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::stopTransmission(bool blocking) {
    8d3c:	mov	r6, r1
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    8d3e:	str	r3, [r2, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    8d40:	mov	r1, r5
    8d42:	bl	80b8 <cardCommand(unsigned long, unsigned long)>
    8d46:	mov	r4, r0
    8d48:	cbnz	r0, 8d5a <SdioCard::stopTransmission(bool)+0x2e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8d4a:	ldr	r3, [pc, #52]	; (8d80 <SdioCard::stopTransmission(bool)+0x54>)
    8d4c:	movs	r2, #9
    8d4e:	strb	r2, [r3, #0]
  m_errorLine = line;
    8d50:	ldr	r3, [pc, #48]	; (8d84 <SdioCard::stopTransmission(bool)+0x58>)
    8d52:	movw	r2, #962	; 0x3c2
    8d56:	str	r2, [r3, #0]
bool SdioCard::stopTransmission(bool blocking) {
  m_curState = IDLE_STATE;
  // This fix allows CDIHB to be cleared in Tennsy 3.x without a reset.
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
    8d58:	b.n	8d74 <SdioCard::stopTransmission(bool)+0x48>
  }
  if (blocking) {
    8d5a:	cbz	r6, 8d74 <SdioCard::stopTransmission(bool)+0x48>
    if (yieldTimeout(isBusyDat)) {
    8d5c:	ldr	r0, [pc, #40]	; (8d88 <SdioCard::stopTransmission(bool)+0x5c>)
    8d5e:	bl	8048 <yieldTimeout(bool (*)())>
    8d62:	cbz	r0, 8d74 <SdioCard::stopTransmission(bool)+0x48>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    8d64:	ldr	r3, [pc, #24]	; (8d80 <SdioCard::stopTransmission(bool)+0x54>)
    8d66:	movs	r2, #10
    8d68:	strb	r2, [r3, #0]
  m_errorLine = line;
    8d6a:	ldr	r3, [pc, #24]	; (8d84 <SdioCard::stopTransmission(bool)+0x58>)
    8d6c:	movw	r2, #966	; 0x3c6
    8d70:	str	r2, [r3, #0]
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
  if (blocking) {
    if (yieldTimeout(isBusyDat)) {
      return sdError(SD_CARD_ERROR_CMD13);
    8d72:	mov	r4, r5
    }
  }
  return true;
}
    8d74:	mov	r0, r4
    8d76:	pop	{r4, r5, r6, pc}
    8d78:	.word	0x400b1028
    8d7c:	.word	0x0cdb0000
    8d80:	.word	0x1fff135c
    8d84:	.word	0x2001cf08
    8d88:	.word	0x00007ec9

00008d8c <SdioCard::syncDevice()>:
//------------------------------------------------------------------------------
bool SdioCard::syncDevice() {
    8d8c:	push	{r4, lr}
    8d8e:	mov	r4, r0
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    8d90:	bl	83a0 <waitTransferComplete()>
    8d94:	cbz	r0, 8da6 <SdioCard::syncDevice()+0x1a>
    return false;
  }
  if (m_curState != IDLE_STATE) {
    8d96:	ldrb	r3, [r4, #9]
    8d98:	cbz	r3, 8da6 <SdioCard::syncDevice()+0x1a>
    return stopTransmission(true);
    8d9a:	mov	r0, r4
    8d9c:	movs	r1, #1
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    8d9e:	ldmia.w	sp!, {r4, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (!waitTransferComplete()) {
    return false;
  }
  if (m_curState != IDLE_STATE) {
    return stopTransmission(true);
    8da2:	b.w	8d2c <SdioCard::stopTransmission(bool)>
      return false;
    }
  }
#endif  // ENABLE_TEENSY_SDIO_MOD
  return true;
}
    8da6:	pop	{r4, pc}

00008da8 <SdioCard::isBusy()>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorLine() const {
  return m_errorLine;
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
    8da8:	push	{r4, lr}
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    8daa:	ldrb	r3, [r0, #8]
    8dac:	lsls	r3, r3, #31
//------------------------------------------------------------------------------
uint32_t SdioCard::errorLine() const {
  return m_errorLine;
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
    8dae:	mov	r2, r0
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    8db0:	bpl.n	8dd0 <SdioCard::isBusy()+0x28>
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    8db2:	ldr	r3, [pc, #80]	; (8e04 <SdioCard::isBusy()+0x5c>)
    8db4:	ldr	r3, [r3, #0]
    8db6:	cbz	r3, 8dbe <SdioCard::isBusy()+0x16>
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    8db8:	ldmia.w	sp!, {r4, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    8dbc:	bx	r3
    8dbe:	ldr	r3, [pc, #72]	; (8e08 <SdioCard::isBusy()+0x60>)
    8dc0:	ldrb	r3, [r3, #0]
    8dc2:	cbnz	r3, 8dc8 <SdioCard::isBusy()+0x20>
    8dc4:	movs	r0, #0
    8dc6:	pop	{r4, pc}
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    8dc8:	ldmia.w	sp!, {r4, lr}
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
#if ENABLE_TEENSY_SDIO_MOD
  if (m_sdioConfig.useDma()) {
    return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    8dcc:	b.w	812c <isBusyCMD13()>
  } else {
    if (m_transferActive) {
    8dd0:	ldr	r1, [pc, #56]	; (8e0c <SdioCard::isBusy()+0x64>)
    8dd2:	ldrb	r4, [r1, #0]
    8dd4:	cbz	r4, 8df6 <SdioCard::isBusy()+0x4e>
      if (isBusyTransferComplete()) {
    8dd6:	bl	7f10 <isBusyTransferComplete()>
    8dda:	cbnz	r0, 8e02 <SdioCard::isBusy()+0x5a>
        return true;
      }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
      if ((SDHC_BLKATTR & 0XFFFF0000) != 0) {
    8ddc:	ldr	r3, [pc, #48]	; (8e10 <SdioCard::isBusy()+0x68>)
    8dde:	ldr	r3, [r3, #0]
    8de0:	lsrs	r3, r3, #16
    8de2:	lsls	r3, r3, #16
    8de4:	cmp	r3, #0
    8de6:	bne.n	8dc4 <SdioCard::isBusy()+0x1c>
        return false;
      }
      m_transferActive = false;
    8de8:	strb	r0, [r1, #0]
      stopTransmission(false);
    8dea:	mov	r1, r0
    8dec:	mov	r0, r2
    8dee:	bl	8d2c <SdioCard::stopTransmission(bool)>
    8df2:	mov	r0, r4
    8df4:	pop	{r4, pc}
#else  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
      return false;
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    }
    // Use DAT0 low as busy.
    return SDHC_PRSSTAT & (1 << 24) ? false : true;
    8df6:	ldr	r3, [pc, #28]	; (8e14 <SdioCard::isBusy()+0x6c>)
    8df8:	ldr	r0, [r3, #0]
    8dfa:	eor.w	r0, r0, #16777216	; 0x1000000
    8dfe:	ubfx	r0, r0, #24, #1
  }
#else  // ENABLE_TEENSY_SDIO_MOD
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
#endif  // ENABLE_TEENSY_SDIO_MOD
}
    8e02:	pop	{r4, pc}
    8e04:	.word	0x2001ced8
    8e08:	.word	0x2001cef0
    8e0c:	.word	0x2001cee8
    8e10:	.word	0x400b1004
    8e14:	.word	0x400b1024

00008e18 <memcpy>:
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
#else
	push	{r0}
    8e18:	push	{r0}
#endif
	orr	r3, r1, r0
    8e1a:	orr.w	r3, r1, r0
	ands	r3, r3, #3
    8e1e:	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    8e22:	bne.n	8f04 <memcpy+0xec>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    8e24:	subs	r2, #64	; 0x40
	blo	.Lmid_block
    8e26:	bcc.n	8eac <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    8e28:	ldr.w	r3, [r1], #4
    8e2c:	str.w	r3, [r0], #4
    8e30:	ldr.w	r3, [r1], #4
    8e34:	str.w	r3, [r0], #4
    8e38:	ldr.w	r3, [r1], #4
    8e3c:	str.w	r3, [r0], #4
    8e40:	ldr.w	r3, [r1], #4
    8e44:	str.w	r3, [r0], #4
    8e48:	ldr.w	r3, [r1], #4
    8e4c:	str.w	r3, [r0], #4
    8e50:	ldr.w	r3, [r1], #4
    8e54:	str.w	r3, [r0], #4
    8e58:	ldr.w	r3, [r1], #4
    8e5c:	str.w	r3, [r0], #4
    8e60:	ldr.w	r3, [r1], #4
    8e64:	str.w	r3, [r0], #4
    8e68:	ldr.w	r3, [r1], #4
    8e6c:	str.w	r3, [r0], #4
    8e70:	ldr.w	r3, [r1], #4
    8e74:	str.w	r3, [r0], #4
    8e78:	ldr.w	r3, [r1], #4
    8e7c:	str.w	r3, [r0], #4
    8e80:	ldr.w	r3, [r1], #4
    8e84:	str.w	r3, [r0], #4
    8e88:	ldr.w	r3, [r1], #4
    8e8c:	str.w	r3, [r0], #4
    8e90:	ldr.w	r3, [r1], #4
    8e94:	str.w	r3, [r0], #4
    8e98:	ldr.w	r3, [r1], #4
    8e9c:	str.w	r3, [r0], #4
    8ea0:	ldr.w	r3, [r1], #4
    8ea4:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    8ea8:	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    8eaa:	bcs.n	8e28 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    8eac:	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    8eae:	bcc.n	8ed4 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    8eb0:	ldr.w	r3, [r1], #4
    8eb4:	str.w	r3, [r0], #4
    8eb8:	ldr.w	r3, [r1], #4
    8ebc:	str.w	r3, [r0], #4
    8ec0:	ldr.w	r3, [r1], #4
    8ec4:	str.w	r3, [r0], #4
    8ec8:	ldr.w	r3, [r1], #4
    8ecc:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    8ed0:	subs	r2, #16
	bhs	.Lmid_block_loop
    8ed2:	bcs.n	8eb0 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    8ed4:	adds	r2, #12
	blo	.Lcopy_less_than_4
    8ed6:	bcc.n	8ee4 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    8ed8:	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    8edc:	str.w	r3, [r0], #4
	subs	r2, #4
    8ee0:	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    8ee2:	bcs.n	8ed8 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    8ee4:	adds	r2, #4
	beq	.Ldone
    8ee6:	beq.n	8efe <memcpy+0xe6>

	lsls	r2, r2, #31
    8ee8:	lsls	r2, r2, #31
	itt ne
    8eea:	itt	ne
	ldrbne  r3, [r1], #1
    8eec:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    8ef0:	strbne.w	r3, [r0], #1

	bcc	.Ldone
    8ef4:	bcc.n	8efe <memcpy+0xe6>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
	strh	r3, [r0]
#else
	ldrb	r3, [r1]
    8ef6:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    8ef8:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    8efa:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    8efc:	strb	r3, [r0, #1]

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    8efe:	pop	{r0}
#endif
	bx	lr
    8f00:	bx	lr
    8f02:	nop
	beq	.Ldst_aligned
#else
	/* if len < 12, misalignment adjustment has more overhead than
	just byte-to-byte copy.  Also, len must >=8 to guarantee code
	afterward work correctly.  */
	cmp	r2, #12
    8f04:	cmp	r2, #12
	blo	.Lbyte_copy
    8f06:	bcc.n	8f9e <memcpy+0x186>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    8f08:	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    8f0c:	beq.n	8f32 <memcpy+0x11a>

	rsb	r3, #4
    8f0e:	rsb	r3, r3, #4
	subs	r2, r3
    8f12:	subs	r2, r2, r3

	lsls    r3, r3, #31
    8f14:	lsls	r3, r3, #31
	itt ne
    8f16:	itt	ne
	ldrbne  r3, [r1], #1
    8f18:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    8f1c:	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    8f20:	bcc.n	8f32 <memcpy+0x11a>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
	strh    r3, [r0], #2
	b	.Ldst_aligned
#else
	ldrb    r3, [r1], #1
    8f22:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    8f26:	strb.w	r3, [r0], #1
	ldrb    r3, [r1], #1
    8f2a:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    8f2e:	strb.w	r3, [r0], #1
	/* Now that dst is aligned */
.Ldst_aligned:
	/* if r1 is aligned now, it means r0/r1 has the same misalignment,
	and they are both aligned now.  Go aligned copy.  */
	ands	r3, r1, #3
    8f32:	ands.w	r3, r1, #3
	beq	.Lbig_block
    8f36:	beq.w	8e24 <memcpy+0xc>

	/* dst is aligned, but src isn't.  Misaligned copy.  */

	push	{r4, r5}
    8f3a:	push	{r4, r5}
	subs	r2, #4
    8f3c:	subs	r2, #4

	/* Backward r1 by misaligned bytes, to make r1 aligned.
	Since we need to restore r1 to unaligned address after the loop,
	we need keep the offset bytes to ip and sub it from r1 afterward.  */
	subs	r1, r3
    8f3e:	subs	r1, r1, r3
	rsb	ip, r3, #4
    8f40:	rsb	ip, r3, #4

	/* Pre-load on word */
	ldr	r4, [r1], #4
    8f44:	ldr.w	r4, [r1], #4

	cmp	r3, #2
    8f48:	cmp	r3, #2
	beq	.Lmisaligned_copy_2_2
    8f4a:	beq.n	8f80 <memcpy+0x168>
	cmp	r3, #3
    8f4c:	cmp	r3, #3
	beq	.Lmisaligned_copy_3_1
    8f4e:	beq.n	8f68 <memcpy+0x150>
	subs	r2, #4
	bhs	1b
	.endm

.Lmisaligned_copy_1_3:
	mis_src_copy shift=8
    8f50:	lsrs	r4, r4, #8
    8f52:	ldr.w	r3, [r1], #4
    8f56:	lsls	r5, r3, #24
    8f58:	orr.w	r4, r4, r5
    8f5c:	str.w	r4, [r0], #4
    8f60:	mov	r4, r3
    8f62:	subs	r2, #4
    8f64:	bcs.n	8f50 <memcpy+0x138>
	b	.Lsrc_misaligned_tail
    8f66:	b.n	8f96 <memcpy+0x17e>

.Lmisaligned_copy_3_1:
	mis_src_copy shift=24
    8f68:	lsrs	r4, r4, #24
    8f6a:	ldr.w	r3, [r1], #4
    8f6e:	lsls	r5, r3, #8
    8f70:	orr.w	r4, r4, r5
    8f74:	str.w	r4, [r0], #4
    8f78:	mov	r4, r3
    8f7a:	subs	r2, #4
    8f7c:	bcs.n	8f68 <memcpy+0x150>
	b	.Lsrc_misaligned_tail
    8f7e:	b.n	8f96 <memcpy+0x17e>

.Lmisaligned_copy_2_2:
	/* For 2_2 misalignment, ldr is still faster than 2 x ldrh.  */
	mis_src_copy shift=16
    8f80:	lsrs	r4, r4, #16
    8f82:	ldr.w	r3, [r1], #4
    8f86:	lsls	r5, r3, #16
    8f88:	orr.w	r4, r4, r5
    8f8c:	str.w	r4, [r0], #4
    8f90:	mov	r4, r3
    8f92:	subs	r2, #4
    8f94:	bcs.n	8f80 <memcpy+0x168>

.Lsrc_misaligned_tail:
	adds	r2, #4
    8f96:	adds	r2, #4
	subs	r1, ip
    8f98:	subs.w	r1, r1, ip
	pop	{r4, r5}
    8f9c:	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    8f9e:	subs	r2, #4
	blo	.Lcopy_less_than_4
    8fa0:	bcc.n	8ee4 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    8fa2:	subs	r2, #1
	ldrb    r3, [r1], #1
    8fa4:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    8fa8:	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    8fac:	bcs.n	8fa2 <memcpy+0x18a>

	ldrb	r3, [r1]
    8fae:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    8fb0:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    8fb2:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    8fb4:	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    8fb6:	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    8fb8:	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
#else
	pop	{r0}
    8fba:	pop	{r0}
#endif
	bx	lr
    8fbc:	bx	lr
    8fbe:	nop

00008fc0 <memset>:
	.type	memset, %function
	.thumb_func
	memset:
//FUNCTION(memset)
    // save the original pointer
    push    { r0, lr }
    8fc0:	push	{r0, lr}

    // check for zero length
    cbz     r2, .L_done
    8fc2:	cbz	r2, 9000 <memset+0x40>

    // short memsets aren't worth optimizing and make sure we have
    // enough headroom to try to do dwordwise move optimization
    cmp     r2, #16
    8fc4:	cmp	r2, #16
    blt     .L_bytewise
    8fc6:	blt.n	8ff8 <memset+0x38>

    // see how many bytes we need to move to align to dword boundaries
    and     r3, r0, #7
    8fc8:	and.w	r3, r0, #7
    cbz     r3, .L_prepare_dwordwise
    8fcc:	cbz	r3, 8fdc <memset+0x1c>
    rsb     r3, #8
    8fce:	rsb	r3, r3, #8
    subs    r2, r3
    8fd2:	subs	r2, r2, r3

.L_bytewise_align:
    // bytewise to align memset
    subs    r3, r3, #1
    8fd4:	subs	r3, #1
    strb    r1, [r0], #1
    8fd6:	strb.w	r1, [r0], #1
    bgt     .L_bytewise_align
    8fda:	bgt.n	8fd4 <memset+0x14>

.L_prepare_dwordwise:
    // fill a pair of 32 bit registers with the 8 bit value
    uxtb    r1, r1
    8fdc:	uxtb	r1, r1
    orr     r1, r1, r1, lsl #8
    8fde:	orr.w	r1, r1, r1, lsl #8
    orr     r1, r1, r1, lsl #16
    8fe2:	orr.w	r1, r1, r1, lsl #16
    mov     r12, r1
    8fe6:	mov	ip, r1

    // load the number of dwords left
    lsrs    r3, r2, #3
    8fe8:	lsrs	r3, r2, #3

.L_dwordwise:
    // dwordwise memset
		
    subs    r3, r3, #1
    8fea:	subs	r3, #1
    strd    r1, r12, [r0], #8
    8fec:	strd	r1, ip, [r0], #8
    bgt     .L_dwordwise
    8ff0:	bgt.n	8fea <memset+0x2a>

    // remaining bytes
    ands     r2, #7
    8ff2:	ands.w	r2, r2, #7
    beq     .L_done
    8ff6:	beq.n	9000 <memset+0x40>

.L_bytewise:
    // bytewise memset
    subs    r2, r2, #1
    8ff8:	subs	r2, #1
    strb    r1, [r0], #1
    8ffa:	strb.w	r1, [r0], #1
    bgt     .L_bytewise
    8ffe:	bgt.n	8ff8 <memset+0x38>

.L_done:
    // restore the base pointer as return value
    pop     { r0, pc }
    9000:	pop	{r0, pc}
    9002:	nop

00009004 <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    9004:	push	{r4, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    9006:	ldr	r4, [pc, #64]	; (9048 <usb_serial_getchar+0x44>)
    9008:	ldr	r3, [r4, #0]
    900a:	cbz	r3, 9028 <usb_serial_getchar+0x24>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    900c:	ldr	r0, [r4, #0]
    900e:	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
    9010:	adds	r2, r3, #1
    9012:	add	r3, r0
    9014:	ldrb	r4, [r3, #8]
	if (i >= rx_packet->len) {
    9016:	ldrh	r3, [r0, #0]
    9018:	cmp	r2, r3
    901a:	bcc.n	9042 <usb_serial_getchar+0x3e>
		usb_free(rx_packet);
    901c:	bl	95c8 <usb_free>
		rx_packet = NULL;
    9020:	ldr	r3, [pc, #36]	; (9048 <usb_serial_getchar+0x44>)
    9022:	movs	r2, #0
    9024:	str	r2, [r3, #0]
    9026:	b.n	9044 <usb_serial_getchar+0x40>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    9028:	ldr	r3, [pc, #32]	; (904c <usb_serial_getchar+0x48>)
    902a:	ldrb	r3, [r3, #0]
    902c:	cbnz	r3, 9034 <usb_serial_getchar+0x30>
    902e:	mov.w	r0, #4294967295
    9032:	pop	{r4, pc}
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    9034:	movs	r0, #3
    9036:	bl	964c <usb_rx>
    903a:	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    903c:	cmp	r0, #0
    903e:	bne.n	900c <usb_serial_getchar+0x8>
    9040:	b.n	902e <usb_serial_getchar+0x2a>
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    9042:	strh	r2, [r0, #2]
	}
	return c;
    9044:	mov	r0, r4
}
    9046:	pop	{r4, pc}
    9048:	.word	0x2001cf18
    904c:	.word	0x2001d003

00009050 <usb_serial_peekchar>:

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    9050:	push	{r4, lr}
	if (!rx_packet) {
    9052:	ldr	r4, [pc, #44]	; (9080 <usb_serial_peekchar+0x30>)
    9054:	ldr	r3, [r4, #0]
    9056:	cbz	r3, 905e <usb_serial_peekchar+0xe>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
    9058:	ldr	r2, [r4, #0]
    905a:	cbnz	r2, 9078 <usb_serial_peekchar+0x28>
    905c:	b.n	9064 <usb_serial_peekchar+0x14>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    905e:	ldr	r3, [pc, #36]	; (9084 <usb_serial_peekchar+0x34>)
    9060:	ldrb	r3, [r3, #0]
    9062:	cbnz	r3, 906a <usb_serial_peekchar+0x1a>
    9064:	mov.w	r0, #4294967295
    9068:	pop	{r4, pc}
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    906a:	movs	r0, #3
    906c:	bl	964c <usb_rx>
    9070:	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    9072:	cmp	r0, #0
    9074:	bne.n	9058 <usb_serial_peekchar+0x8>
    9076:	b.n	9064 <usb_serial_peekchar+0x14>
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    9078:	ldrh	r3, [r2, #2]
    907a:	add	r3, r2
    907c:	ldrb	r0, [r3, #8]
}
    907e:	pop	{r4, pc}
    9080:	.word	0x2001cf18
    9084:	.word	0x2001d003

00009088 <usb_serial_available>:
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    9088:	ldr	r3, [pc, #16]	; (909c <usb_serial_available+0x14>)

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    908a:	ldrh	r0, [r3, #4]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    908c:	ldr	r3, [pc, #16]	; (90a0 <usb_serial_available+0x18>)
    908e:	ldr	r2, [r3, #0]
    9090:	cbz	r2, 909a <usb_serial_available+0x12>
    9092:	ldrh	r3, [r2, #0]
    9094:	ldrh	r2, [r2, #2]
    9096:	subs	r3, r3, r2
    9098:	add	r0, r3
	return count;
}
    909a:	bx	lr
    909c:	.word	0x2001d078
    90a0:	.word	0x2001cf18

000090a4 <usb_serial_flush_input>:
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    90a4:	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
    90a6:	ldr	r3, [pc, #36]	; (90cc <usb_serial_flush_input+0x28>)
    90a8:	ldrb	r3, [r3, #0]
    90aa:	cbz	r3, 90c8 <usb_serial_flush_input+0x24>
	if (rx_packet) {
    90ac:	ldr	r4, [pc, #32]	; (90d0 <usb_serial_flush_input+0x2c>)
    90ae:	ldr	r0, [r4, #0]
    90b0:	cbz	r0, 90ba <usb_serial_flush_input+0x16>
		usb_free(rx_packet);
    90b2:	bl	95c8 <usb_free>
		rx_packet = NULL;
    90b6:	movs	r3, #0
    90b8:	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    90ba:	movs	r0, #3
    90bc:	bl	964c <usb_rx>
		if (!rx) break;
    90c0:	cbz	r0, 90c8 <usb_serial_flush_input+0x24>
		usb_free(rx);
    90c2:	bl	95c8 <usb_free>
	}
    90c6:	b.n	90ba <usb_serial_flush_input+0x16>
    90c8:	pop	{r4, pc}
    90ca:	nop
    90cc:	.word	0x2001d003
    90d0:	.word	0x2001cf18

000090d4 <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    90d4:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    90d8:	ldr	r5, [pc, #196]	; (91a0 <usb_serial_write+0xcc>)
	while (size > 0) {
		if (!tx_packet) {
    90da:	ldr.w	r9, [pc, #212]	; 91b0 <usb_serial_write+0xdc>
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    90de:	movs	r3, #1
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    90e0:	mov	sl, r0
    90e2:	mov	r4, r1
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    90e4:	strb	r3, [r5, #0]
	while (size > 0) {
    90e6:	mov	r6, r1
    90e8:	mov	r7, r9
    90ea:	cmp	r6, #0
    90ec:	beq.n	9196 <usb_serial_write+0xc2>
		if (!tx_packet) {
    90ee:	ldr.w	r3, [r9]
    90f2:	cbnz	r3, 9144 <usb_serial_write+0x70>
    90f4:	ldr.w	fp, [pc, #176]	; 91a8 <usb_serial_write+0xd4>
    90f8:	movw	r8, #41721	; 0xa2f9
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    90fc:	ldr	r3, [pc, #164]	; (91a4 <usb_serial_write+0xd0>)
    90fe:	ldrb	r3, [r3, #0]
    9100:	and.w	r1, r3, #255	; 0xff
    9104:	cbnz	r3, 910a <usb_serial_write+0x36>
					tx_noautoflush = 0;
    9106:	strb	r1, [r5, #0]
    9108:	b.n	9136 <usb_serial_write+0x62>
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    910a:	movs	r0, #4
    910c:	bl	9684 <usb_tx_packet_count>
    9110:	cmp	r0, #7
    9112:	bhi.n	9124 <usb_serial_write+0x50>
					tx_noautoflush = 1;
    9114:	movs	r3, #1
    9116:	strb	r3, [r5, #0]
					tx_packet = usb_malloc();
    9118:	bl	958c <usb_malloc>
    911c:	str	r0, [r7, #0]
					if (tx_packet) break;
    911e:	cbnz	r0, 9144 <usb_serial_write+0x70>
					tx_noautoflush = 0;
    9120:	ldr	r3, [pc, #124]	; (91a0 <usb_serial_write+0xcc>)
    9122:	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    9124:	subs.w	r8, r8, #1
    9128:	beq.n	9130 <usb_serial_write+0x5c>
    912a:	ldrb.w	r3, [fp]
    912e:	cbz	r3, 913e <usb_serial_write+0x6a>
					transmit_previous_timeout = 1;
    9130:	ldr	r3, [pc, #116]	; (91a8 <usb_serial_write+0xd4>)
    9132:	movs	r2, #1
    9134:	strb	r2, [r3, #0]
					return -1;
    9136:	mov.w	r0, #4294967295
    913a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				}
				yield();
    913e:	bl	9e58 <yield>
			}
    9142:	b.n	90fc <usb_serial_write+0x28>
		}
		transmit_previous_timeout = 0;
    9144:	ldr	r3, [pc, #96]	; (91a8 <usb_serial_write+0xd4>)
    9146:	movs	r1, #0
    9148:	strb	r1, [r3, #0]
		len = CDC_TX_SIZE - tx_packet->index;
    914a:	ldr	r1, [r7, #0]
    914c:	ldrh	r3, [r1, #2]
    914e:	rsb	r0, r3, #64	; 0x40
    9152:	cmp	r0, r6
    9154:	it	cs
    9156:	movcs	r0, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    9158:	add.w	lr, r3, r0
    915c:	add	r3, r1
    915e:	strh.w	lr, [r1, #2]
		size -= len;
    9162:	subs	r6, r6, r0
    9164:	adds	r3, #7
    9166:	add.w	r8, sl, r0
		while (len-- > 0) *dest++ = *src++;
    916a:	cmp	sl, r8
    916c:	beq.n	9178 <usb_serial_write+0xa4>
    916e:	ldrb.w	r0, [sl], #1
    9172:	strb.w	r0, [r3, #1]!
    9176:	b.n	916a <usb_serial_write+0x96>
		if (tx_packet->index >= CDC_TX_SIZE) {
    9178:	ldrh	r3, [r1, #2]
    917a:	cmp	r3, #63	; 0x3f
    917c:	bls.n	918c <usb_serial_write+0xb8>
			tx_packet->len = CDC_TX_SIZE;
    917e:	movs	r3, #64	; 0x40
    9180:	strh	r3, [r1, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    9182:	movs	r0, #4
    9184:	bl	9720 <usb_tx>
			tx_packet = NULL;
    9188:	movs	r3, #0
    918a:	str	r3, [r7, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    918c:	ldr	r3, [pc, #28]	; (91ac <usb_serial_write+0xd8>)
    918e:	movs	r2, #5
    9190:	strb	r2, [r3, #0]
    9192:	mov	sl, r8
    9194:	b.n	90ea <usb_serial_write+0x16>
	}
	tx_noautoflush = 0;
    9196:	strb	r6, [r5, #0]
	return ret;
    9198:	mov	r0, r4
}
    919a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    919e:	nop
    91a0:	.word	0x2001cf0d
    91a4:	.word	0x2001d003
    91a8:	.word	0x2001cf14
    91ac:	.word	0x2001cf0c
    91b0:	.word	0x2001cf10

000091b4 <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    91b4:	push	{r0, r1, r2, lr}
    91b6:	add	r3, sp, #8
	return usb_serial_write(&c, 1);
    91b8:	movs	r1, #1
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    91ba:	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    91be:	mov	r0, r3
    91c0:	bl	90d4 <usb_serial_write>
}
    91c4:	add	sp, #12
    91c6:	ldr.w	pc, [sp], #4
    91ca:	Address 0x000091ca is out of bounds.


000091cc <usb_serial_write_buffer_free>:
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    91cc:	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
    91ce:	ldr	r4, [pc, #56]	; (9208 <usb_serial_write_buffer_free+0x3c>)
	if (!tx_packet) {
    91d0:	ldr	r5, [pc, #56]	; (920c <usb_serial_write_buffer_free+0x40>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    91d2:	movs	r3, #1
    91d4:	strb	r3, [r4, #0]
	if (!tx_packet) {
    91d6:	ldr	r3, [r5, #0]
    91d8:	cbnz	r3, 91fa <usb_serial_write_buffer_free+0x2e>
		if (!usb_configuration ||
    91da:	ldr	r3, [pc, #52]	; (9210 <usb_serial_write_buffer_free+0x44>)
    91dc:	ldrb	r3, [r3, #0]
    91de:	cbnz	r3, 91e6 <usb_serial_write_buffer_free+0x1a>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    91e0:	movs	r0, #0
    91e2:	strb	r0, [r4, #0]
			return 0;
    91e4:	pop	{r3, r4, r5, pc}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    91e6:	movs	r0, #4
    91e8:	bl	9684 <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    91ec:	cmp	r0, #7
    91ee:	bhi.n	91e0 <usb_serial_write_buffer_free+0x14>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    91f0:	bl	958c <usb_malloc>
    91f4:	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    91f6:	cmp	r0, #0
    91f8:	beq.n	91e0 <usb_serial_write_buffer_free+0x14>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    91fa:	ldr	r3, [r5, #0]
    91fc:	ldrh	r0, [r3, #2]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    91fe:	movs	r3, #0
    9200:	strb	r3, [r4, #0]
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    9202:	rsb	r0, r0, #64	; 0x40
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    9206:	pop	{r3, r4, r5, pc}
    9208:	.word	0x2001cf0d
    920c:	.word	0x2001cf10
    9210:	.word	0x2001d003

00009214 <usb_serial_flush_output>:

void usb_serial_flush_output(void)
{
    9214:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!usb_configuration) return;
    9218:	ldr	r3, [pc, #68]	; (9260 <usb_serial_flush_output+0x4c>)
    921a:	ldrb	r3, [r3, #0]
    921c:	cbz	r3, 925c <usb_serial_flush_output+0x48>
	tx_noautoflush = 1;
	if (tx_packet) {
    921e:	ldr	r7, [pc, #68]	; (9264 <usb_serial_flush_output+0x50>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    9220:	ldr	r3, [pc, #68]	; (9268 <usb_serial_flush_output+0x54>)
	if (tx_packet) {
    9222:	ldr	r4, [r7, #0]
    9224:	ldr	r5, [pc, #68]	; (926c <usb_serial_flush_output+0x58>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    9226:	movs	r6, #1
    9228:	strb	r6, [r3, #0]
    922a:	mov	r8, r3
	if (tx_packet) {
    922c:	cbz	r4, 9242 <usb_serial_flush_output+0x2e>
		usb_cdc_transmit_flush_timer = 0;
    922e:	movs	r6, #0
		tx_packet->len = tx_packet->index;
    9230:	ldrh	r3, [r4, #2]
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    9232:	strb	r6, [r5, #0]
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    9234:	mov	r1, r4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    9236:	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    9238:	movs	r0, #4
    923a:	bl	9720 <usb_tx>
		tx_packet = NULL;
    923e:	str	r6, [r7, #0]
    9240:	b.n	9256 <usb_serial_flush_output+0x42>
	} else {
		usb_packet_t *tx = usb_malloc();
    9242:	bl	958c <usb_malloc>
		if (tx) {
    9246:	mov	r1, r0
    9248:	cbz	r0, 9254 <usb_serial_flush_output+0x40>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    924a:	movs	r0, #4
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    924c:	strb	r4, [r5, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    924e:	bl	9720 <usb_tx>
    9252:	b.n	9256 <usb_serial_flush_output+0x42>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    9254:	strb	r6, [r5, #0]
		}
	}
	tx_noautoflush = 0;
    9256:	movs	r3, #0
    9258:	strb.w	r3, [r8]
    925c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    9260:	.word	0x2001d003
    9264:	.word	0x2001cf10
    9268:	.word	0x2001cf0d
    926c:	.word	0x2001cf0c

00009270 <usb_serial_flush_callback>:
}

void usb_serial_flush_callback(void)
{
    9270:	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
    9272:	ldr	r3, [pc, #56]	; (92ac <usb_serial_flush_callback+0x3c>)
    9274:	ldrb	r3, [r3, #0]
    9276:	and.w	r5, r3, #255	; 0xff
    927a:	cbnz	r3, 92a8 <usb_serial_flush_callback+0x38>
	if (tx_packet) {
    927c:	ldr	r4, [pc, #48]	; (92b0 <usb_serial_flush_callback+0x40>)
    927e:	ldr	r1, [r4, #0]
    9280:	cbz	r1, 9290 <usb_serial_flush_callback+0x20>
		tx_packet->len = tx_packet->index;
    9282:	ldrh	r3, [r1, #2]
    9284:	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    9286:	movs	r0, #4
    9288:	bl	9720 <usb_tx>
		tx_packet = NULL;
    928c:	str	r5, [r4, #0]
    928e:	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
    9290:	bl	958c <usb_malloc>
		if (tx) {
    9294:	mov	r1, r0
    9296:	cbz	r0, 92a2 <usb_serial_flush_callback+0x32>
			usb_tx(CDC_TX_ENDPOINT, tx);
    9298:	movs	r0, #4
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    929a:	ldmia.w	sp!, {r3, r4, r5, lr}
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
    929e:	b.w	9720 <usb_tx>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    92a2:	ldr	r3, [pc, #16]	; (92b4 <usb_serial_flush_callback+0x44>)
    92a4:	movs	r2, #1
    92a6:	strb	r2, [r3, #0]
    92a8:	pop	{r3, r4, r5, pc}
    92aa:	nop
    92ac:	.word	0x2001cf0d
    92b0:	.word	0x2001cf10
    92b4:	.word	0x2001cf0c

000092b8 <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
    92b8:	push	{r3, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    92ba:	ldr	r5, [pc, #44]	; (92e8 <fault_isr+0x30>)
    92bc:	mov	r4, r5
    92be:	ldr	r3, [r5, #0]
    92c0:	lsls	r0, r3, #13
    92c2:	bpl.n	92c8 <fault_isr+0x10>
    92c4:	bl	97a0 <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    92c8:	ldr	r3, [r4, #0]
    92ca:	lsls	r1, r3, #21
    92cc:	bpl.n	92d2 <fault_isr+0x1a>
    92ce:	bl	92ec <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    92d2:	ldr	r3, [r4, #0]
    92d4:	lsls	r2, r3, #20
    92d6:	bpl.n	92dc <fault_isr+0x24>
    92d8:	bl	92ec <unused_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    92dc:	ldr	r3, [r4, #0]
    92de:	lsls	r3, r3, #19
    92e0:	bpl.n	92be <fault_isr+0x6>
    92e2:	bl	92ec <unused_isr>
    92e6:	b.n	92be <fault_isr+0x6>
    92e8:	.word	0x40048034

000092ec <unused_isr>:
	}
}

void unused_isr(void)
{
    92ec:	push	{r3, lr}
	fault_isr();
    92ee:	bl	92b8 <fault_isr>
    92f2:	Address 0x000092f2 is out of bounds.


000092f4 <startup_early_hook>:
extern void rtc_set(unsigned long t);


static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    92f4:	ldr	r3, [pc, #4]	; (92fc <startup_early_hook+0x8>)
    92f6:	movs	r2, #16
    92f8:	strh	r2, [r3, #0]
    92fa:	bx	lr
    92fc:	.word	0x40052000

00009300 <startup_late_hook>:
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
#endif
}
static void startup_default_late_hook(void) {}
    9300:	bx	lr
    9302:	Address 0x00009302 is out of bounds.


00009304 <_sbrk>:

void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
    9304:	ldr	r1, [pc, #36]	; (932c <_sbrk+0x28>)

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
    9306:	push	{r3, lr}
	char *prev, *stack;

	prev = __brkval;
    9308:	ldr	r3, [r1, #0]
	if (incr != 0) {
    930a:	cbz	r0, 9328 <_sbrk+0x24>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    930c:	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
    930e:	add	r0, r3
    9310:	sub.w	r2, r2, #8192	; 0x2000
    9314:	cmp	r0, r2
    9316:	bcc.n	9326 <_sbrk+0x22>
			errno = ENOMEM;
    9318:	bl	b170 <__errno>
    931c:	movs	r3, #12
    931e:	str	r3, [r0, #0]
			return (void *)-1;
    9320:	mov.w	r0, #4294967295
    9324:	pop	{r3, pc}
		}
		__brkval = prev + incr;
    9326:	str	r0, [r1, #0]
	}
	return prev;
    9328:	mov	r0, r3
}
    932a:	pop	{r3, pc}
    932c:	.word	0x1fff1360

00009330 <__cxa_pure_virtual>:
	while (1);
}

__attribute__((weak)) 
void __cxa_pure_virtual()
{
    9330:	b.n	9330 <__cxa_pure_virtual>
    9332:	Address 0x00009332 is out of bounds.


00009334 <attachInterruptVector>:
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    9334:	adds	r0, #16
    9336:	ldr	r3, [pc, #8]	; (9340 <attachInterruptVector+0xc>)
    9338:	str.w	r1, [r3, r0, lsl #2]
    933c:	bx	lr
    933e:	nop
    9340:	.word	0x1fff0a00

00009344 <rtc_get>:

#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)

unsigned long rtc_get(void)
{
	return RTC_TSR;
    9344:	ldr	r3, [pc, #4]	; (934c <rtc_get+0x8>)
    9346:	ldr	r0, [r3, #0]
}
    9348:	bx	lr
    934a:	nop
    934c:	.word	0x4003d000

00009350 <rtc_set>:

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    9350:	ldr	r3, [pc, #16]	; (9364 <rtc_set+0x14>)
	RTC_TPR = 0;
    9352:	ldr	r1, [pc, #20]	; (9368 <rtc_set+0x18>)
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    9354:	movs	r2, #0
    9356:	str	r2, [r3, #0]
	RTC_TPR = 0;
    9358:	str	r2, [r1, #0]
	RTC_TSR = t;
    935a:	ldr	r2, [pc, #16]	; (936c <rtc_set+0x1c>)
    935c:	str	r0, [r2, #0]
	RTC_SR = RTC_SR_TCE;
    935e:	movs	r2, #16
    9360:	str	r2, [r3, #0]
    9362:	bx	lr
    9364:	.word	0x4003d014
    9368:	.word	0x4003d004
    936c:	.word	0x4003d000

00009370 <startup_middle_hook>:
}
#endif

extern void usb_init(void);

static void startup_default_middle_hook(void) {}
    9370:	bx	lr
    9372:	Address 0x00009372 is out of bounds.


00009374 <digitalWrite>:

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    9374:	cmp	r0, #63	; 0x3f


// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
    9376:	push	{r4, lr}
	if (pin >= CORE_NUM_DIGITAL) return;
    9378:	bhi.n	93ac <digitalWrite+0x38>
#ifdef KINETISK
	if (*portModeRegister(pin)) {
    937a:	ldr	r3, [pc, #52]	; (93b0 <digitalWrite+0x3c>)
    937c:	ldr.w	r2, [r3, r0, lsl #3]
    9380:	ldrb.w	r4, [r2, #640]	; 0x280
    9384:	cbz	r4, 9396 <digitalWrite+0x22>
    9386:	movs	r3, #1
		if (val) {
    9388:	cbz	r1, 9390 <digitalWrite+0x1c>
			*portSetRegister(pin) = 1;
    938a:	strb.w	r3, [r2, #128]	; 0x80
    938e:	pop	{r4, pc}
		} else {
			*portClearRegister(pin) = 1;
    9390:	strb.w	r3, [r2, #256]	; 0x100
    9394:	pop	{r4, pc}
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
    9396:	add.w	r3, r3, r0, lsl #3
    939a:	ldr	r3, [r3, #4]
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    939c:	ldr	r2, [r3, #0]
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
    939e:	cbz	r1, 93a6 <digitalWrite+0x32>
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    93a0:	orr.w	r2, r2, #3
    93a4:	b.n	93aa <digitalWrite+0x36>
			//*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else {
			// TODO use bitband for atomic read-mod-write
			*config &= ~(PORT_PCR_PE);
    93a6:	bic.w	r2, r2, #2
    93aa:	str	r2, [r3, #0]
    93ac:	pop	{r4, pc}
    93ae:	nop
    93b0:	.word	0x00012d80

000093b4 <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    93b4:	cmp	r0, #63	; 0x3f
}



void pinMode(uint8_t pin, uint8_t mode)
{
    93b6:	push	{r4, lr}
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    93b8:	bhi.n	9412 <pinMode+0x5e>
	config = portConfigRegister(pin);
    93ba:	ldr	r2, [pc, #88]	; (9414 <pinMode+0x60>)
    93bc:	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    93c0:	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    93c2:	ldr	r3, [r3, #4]
    93c4:	mov	r4, r2

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    93c6:	beq.n	93cc <pinMode+0x18>
    93c8:	cmp	r1, #4
    93ca:	bne.n	93ec <pinMode+0x38>
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    93cc:	ldr.w	r2, [r4, r0, lsl #3]
    93d0:	movs	r0, #1
    93d2:	strb.w	r0, [r2, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    93d6:	mov.w	r2, #324	; 0x144
    93da:	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    93dc:	ldr	r2, [r3, #0]
		*portModeRegister(pin) = 1;
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
		if (mode == OUTPUT_OPENDRAIN) {
    93de:	cmp	r1, #4
		    *config |= PORT_PCR_ODE;
    93e0:	ite	eq
    93e2:	orreq.w	r2, r2, #32
		} else {
		    *config &= ~PORT_PCR_ODE;
    93e6:	bicne.w	r2, r2, #32
    93ea:	b.n	9410 <pinMode+0x5c>
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    93ec:	ldr.w	r0, [r2, r0, lsl #3]
    93f0:	movs	r2, #0
    93f2:	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    93f6:	cbnz	r1, 93fe <pinMode+0x4a>
			*config = PORT_PCR_MUX(1);
    93f8:	mov.w	r2, #256	; 0x100
    93fc:	b.n	9410 <pinMode+0x5c>
		} else if (mode == INPUT_PULLUP) {
    93fe:	cmp	r1, #2
    9400:	bne.n	9408 <pinMode+0x54>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    9402:	movw	r2, #259	; 0x103
    9406:	b.n	9410 <pinMode+0x5c>
		} else if (mode == INPUT_PULLDOWN) {
    9408:	cmp	r1, #3
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    940a:	it	eq
    940c:	moveq.w	r2, #258	; 0x102
		} else { // INPUT_DISABLE
			*config = 0;
    9410:	str	r2, [r3, #0]
    9412:	pop	{r4, pc}
    9414:	.word	0x00012d80

00009418 <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    9418:	cpsid	i
	current = SYST_CVR;
    941a:	ldr	r3, [pc, #44]	; (9448 <micros+0x30>)
	count = systick_millis_count;
    941c:	ldr	r2, [pc, #44]	; (944c <micros+0x34>)
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    941e:	ldr	r1, [pc, #48]	; (9450 <micros+0x38>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    9420:	ldr	r3, [r3, #0]
	count = systick_millis_count;
    9422:	ldr	r2, [r2, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    9424:	ldr	r1, [r1, #0]
	__enable_irq();
    9426:	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    9428:	lsls	r1, r1, #5
    942a:	bpl.n	9432 <micros+0x1a>
    942c:	cmp	r3, #50	; 0x32
    942e:	it	hi
    9430:	addhi	r2, #1
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    9432:	rsb	r3, r3, #95744	; 0x17600
    9436:	movs	r0, #96	; 0x60
    9438:	adds	r3, #255	; 0xff
    943a:	udiv	r3, r3, r0
}
    943e:	mov.w	r0, #1000	; 0x3e8
    9442:	mla	r0, r0, r2, r3
    9446:	bx	lr
    9448:	.word	0xe000e018
    944c:	.word	0x2001cf20
    9450:	.word	0xe000ed04

00009454 <delay>:

void delay(uint32_t ms)
{
    9454:	push	{r3, r4, r5, lr}
    9456:	mov	r4, r0
	uint32_t start = micros();
    9458:	bl	9418 <micros>
    945c:	mov	r5, r0

	if (ms > 0) {
    945e:	cbnz	r4, 946a <delay+0x16>
    9460:	pop	{r3, r4, r5, pc}
		while (1) {
			while ((micros() - start) >= 1000) {
				ms--;
				if (ms == 0) return;
    9462:	subs	r4, #1
    9464:	beq.n	947c <delay+0x28>
				start += 1000;
    9466:	add.w	r5, r5, #1000	; 0x3e8
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    946a:	bl	9418 <micros>
    946e:	subs	r0, r0, r5
    9470:	cmp.w	r0, #1000	; 0x3e8
    9474:	bcs.n	9462 <delay+0xe>
				ms--;
				if (ms == 0) return;
				start += 1000;
			}
			yield();
    9476:	bl	9e58 <yield>
		}
    947a:	b.n	946a <delay+0x16>
    947c:	pop	{r3, r4, r5, pc}
    947e:	Address 0x0000947e is out of bounds.


00009480 <_init_Teensyduino_internal_>:
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    9480:	ldr	r3, [pc, #224]	; (9564 <_init_Teensyduino_internal_+0xe4>)
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    9482:	ldr	r1, [pc, #228]	; (9568 <_init_Teensyduino_internal_+0xe8>)
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    9484:	mov.w	r2, #134217728	; 0x8000000
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    9488:	push	{r4, r5, r6, lr}
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    948a:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    948c:	mov.w	r2, #268435456	; 0x10000000
    9490:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    9492:	mov.w	r2, #536870912	; 0x20000000
    9496:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    9498:	mov.w	r2, #1073741824	; 0x40000000
    949c:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    949e:	mov.w	r2, #2147483648	; 0x80000000
    94a2:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    94a4:	ldr	r3, [pc, #196]	; (956c <_init_Teensyduino_internal_+0xec>)
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    94a6:	ldr	r5, [pc, #200]	; (9570 <_init_Teensyduino_internal_+0xf0>)
	FTM3_C1SC = 0x28;
    94a8:	ldr	r4, [pc, #200]	; (9574 <_init_Teensyduino_internal_+0xf4>)
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    94aa:	ldr	r6, [pc, #204]	; (9578 <_init_Teensyduino_internal_+0xf8>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    94ac:	movs	r2, #0
	FTM0_MOD = DEFAULT_FTM_MOD;
    94ae:	movw	r0, #49151	; 0xbfff
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    94b2:	str	r2, [r3, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
    94b4:	str	r0, [r3, #4]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    94b6:	movs	r3, #40	; 0x28
    94b8:	str	r3, [r1, #0]
	FTM0_C1SC = 0x28;
    94ba:	str	r3, [r1, #8]
	FTM0_C2SC = 0x28;
    94bc:	str	r3, [r1, #16]
	FTM0_C3SC = 0x28;
    94be:	str	r3, [r1, #24]
	FTM0_C4SC = 0x28;
    94c0:	str	r3, [r1, #32]
	FTM0_C5SC = 0x28;
    94c2:	str	r3, [r1, #40]	; 0x28
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    94c4:	str	r3, [r1, #48]	; 0x30
	FTM0_C7SC = 0x28;
    94c6:	str	r3, [r1, #56]	; 0x38
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
    94c8:	adds	r1, #16
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    94ca:	add.w	r1, r1, #528384	; 0x81000
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    94ce:	str	r3, [r5, #0]
	FTM3_C1SC = 0x28;
    94d0:	str	r3, [r4, #0]
	FTM3_C2SC = 0x28;
    94d2:	str	r3, [r1, #0]
	FTM3_C3SC = 0x28;
    94d4:	str	r3, [r1, #8]
	FTM3_C4SC = 0x28;
    94d6:	str	r3, [r1, #16]
	FTM3_C5SC = 0x28;
    94d8:	str	r3, [r1, #24]
	FTM3_C6SC = 0x28;
    94da:	str	r3, [r1, #32]
	FTM3_C7SC = 0x28;
    94dc:	str	r3, [r1, #40]	; 0x28
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    94de:	movs	r1, #9
    94e0:	str	r1, [r6, #0]
	FTM1_CNT = 0;
    94e2:	add.w	r6, r6, #4096	; 0x1000
    94e6:	adds	r6, #4
    94e8:	str	r2, [r6, #0]
	FTM1_MOD = DEFAULT_FTM_MOD;
    94ea:	str	r0, [r6, #4]
	FTM1_C0SC = 0x28;
    94ec:	str	r3, [r6, #8]
	FTM1_C1SC = 0x28;
    94ee:	str	r3, [r6, #16]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    94f0:	str.w	r1, [r6, #-4]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    94f4:	add.w	r6, r6, #520192	; 0x7f000
    94f8:	str	r2, [r6, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    94fa:	str	r0, [r6, #4]
	FTM2_C0SC = 0x28;
    94fc:	str	r3, [r6, #8]
	FTM2_C1SC = 0x28;
    94fe:	str	r3, [r6, #16]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9500:	str.w	r1, [r6, #-4]
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
    9504:	add.w	r6, r6, #4096	; 0x1000
    9508:	str	r2, [r6, #0]
	FTM3_MOD = DEFAULT_FTM_MOD;
    950a:	str	r0, [r6, #4]
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    950c:	ldr	r0, [pc, #108]	; (957c <_init_Teensyduino_internal_+0xfc>)
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
	FTM3_C0SC = 0x28;
    950e:	str	r3, [r5, #0]
	FTM3_C1SC = 0x28;
    9510:	str	r3, [r4, #0]
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9512:	str	r1, [r0, #0]
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    9514:	sub.w	r0, r0, #460800	; 0x70800
    9518:	subw	r0, r0, #2004	; 0x7d4
    951c:	ldr	r1, [r0, #0]
    951e:	orr.w	r1, r1, #512	; 0x200
    9522:	str	r1, [r0, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    9524:	ldr.w	r1, [r0, #-40]
    9528:	orr.w	r1, r1, #33554432	; 0x2000000
    952c:	str.w	r1, [r0, #-40]
	TPM1_CNT = 0;
    9530:	ldr	r1, [pc, #76]	; (9580 <_init_Teensyduino_internal_+0x100>)
    9532:	str	r2, [r1, #0]
	TPM1_MOD = 32767;
    9534:	ldr	r2, [pc, #76]	; (9584 <_init_Teensyduino_internal_+0x104>)
    9536:	movw	r1, #32767	; 0x7fff
    953a:	str	r1, [r2, #0]
	TPM1_C0SC = 0x28;
    953c:	str	r3, [r2, #4]
	TPM1_C1SC = 0x28;
    953e:	str	r3, [r2, #12]
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    9540:	ldr	r3, [pc, #68]	; (9588 <_init_Teensyduino_internal_+0x108>)
    9542:	movs	r2, #8
    9544:	str	r2, [r3, #0]
#endif
	analog_init();
    9546:	bl	a2c0 <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	startup_middle_hook();
    954a:	bl	9370 <startup_middle_hook>
	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    954e:	movs	r0, #20
    9550:	bl	9454 <delay>
	usb_init();
    9554:	bl	9dc4 <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    9558:	mov.w	r0, #280	; 0x118
}
    955c:	ldmia.w	sp!, {r4, r5, r6, lr}
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	startup_middle_hook();
	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    9560:	b.w	9454 <delay>
    9564:	.word	0xe000e104
    9568:	.word	0x4003800c
    956c:	.word	0x40038004
    9570:	.word	0x400b900c
    9574:	.word	0x400b9014
    9578:	.word	0x40038000
    957c:	.word	0x400b9000
    9580:	.word	0x400c9004
    9584:	.word	0x400c9008
    9588:	.word	0x400c9000

0000958c <usb_malloc>:
// http://www.archivum.info/gnu.gcc.help/2006-08/00148/Re-GCC-Inline-Assembly.html
// http://gcc.gnu.org/ml/gcc/2012-06/msg00015.html
// __builtin_clz()

usb_packet_t * usb_malloc(void)
{
    958c:	push	{r4, lr}
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    958e:	cpsid	i
	avail = usb_buffer_available;
    9590:	ldr	r0, [pc, #44]	; (95c0 <usb_malloc+0x34>)
    9592:	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    9594:	clz	r1, r2
	if (n >= NUM_USB_BUFFERS) {
    9598:	cmp	r1, #11
    959a:	ble.n	95a2 <usb_malloc+0x16>
		__enable_irq();
    959c:	cpsie	i
		return NULL;
    959e:	movs	r0, #0
    95a0:	pop	{r4, pc}
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    95a2:	mov.w	r3, #2147483648	; 0x80000000
    95a6:	lsrs	r3, r1
    95a8:	bic.w	r2, r2, r3
    95ac:	str	r2, [r0, #0]
	__enable_irq();
    95ae:	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    95b0:	ldr	r4, [pc, #16]	; (95c4 <usb_malloc+0x38>)
    95b2:	movs	r3, #72	; 0x48
    95b4:	muls	r3, r1
    95b6:	adds	r0, r4, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    95b8:	movs	r2, #0
    95ba:	str	r2, [r4, r3]
	*(uint32_t *)(p + 4) = 0;
    95bc:	str	r2, [r0, #4]
	return (usb_packet_t *)p;
}
    95be:	pop	{r4, pc}
    95c0:	.word	0x1fff1364
    95c4:	.word	0x1fff0bd0

000095c8 <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    95c8:	ldr	r3, [pc, #48]	; (95fc <usb_free+0x34>)
    95ca:	movs	r2, #72	; 0x48
    95cc:	subs	r3, r0, r3
    95ce:	udiv	r3, r3, r2
	if (n >= NUM_USB_BUFFERS) return;
    95d2:	cmp	r3, #11
    95d4:	bhi.n	95fa <usb_free+0x32>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    95d6:	ldr	r2, [pc, #40]	; (9600 <usb_free+0x38>)
    95d8:	ldrb	r2, [r2, #0]
    95da:	cbz	r2, 95e6 <usb_free+0x1e>
    95dc:	ldr	r2, [pc, #36]	; (9604 <usb_free+0x3c>)
    95de:	ldrb	r2, [r2, #0]
    95e0:	cbz	r2, 95e6 <usb_free+0x1e>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    95e2:	b.w	96a8 <usb_rx_memory>
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    95e6:	cpsid	i
	usb_buffer_available |= mask;
    95e8:	ldr	r1, [pc, #28]	; (9608 <usb_free+0x40>)
    95ea:	mov.w	r2, #2147483648	; 0x80000000
    95ee:	lsr.w	r3, r2, r3
    95f2:	ldr	r2, [r1, #0]
    95f4:	orrs	r2, r3
    95f6:	str	r2, [r1, #0]
	__enable_irq();
    95f8:	cpsie	i
    95fa:	bx	lr
    95fc:	.word	0x1fff0bd0
    9600:	.word	0x2001cffa
    9604:	.word	0x2001d003
    9608:	.word	0x1fff1364

0000960c <endpoint0_transmit>:
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
}


static void endpoint0_transmit(const void *data, uint32_t len)
{
    960c:	push	{r4, r5, r6, r7, lr}
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    960e:	ldr	r4, [pc, #48]	; (9640 <endpoint0_transmit+0x34>)
    9610:	ldr	r6, [pc, #48]	; (9644 <endpoint0_transmit+0x38>)
    9612:	ldrb	r3, [r4, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9614:	ldr	r5, [pc, #48]	; (9648 <endpoint0_transmit+0x3c>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    9616:	orr.w	r7, r3, #2
    961a:	add.w	r2, r6, r7, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    961e:	eor.w	r3, r3, #1
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    9622:	str	r0, [r2, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9624:	ldrb	r2, [r5, #0]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    9626:	strb	r3, [r4, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9628:	cmp	r2, #0
    962a:	ite	ne
    962c:	movne	r0, #200	; 0xc8
    962e:	moveq	r0, #136	; 0x88
	ep0_tx_data_toggle ^= 1;
    9630:	eor.w	r2, r2, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    9634:	orr.w	r1, r0, r1, lsl #16
	ep0_tx_data_toggle ^= 1;
    9638:	strb	r2, [r5, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    963a:	str.w	r1, [r6, r7, lsl #3]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    963e:	pop	{r4, r5, r6, r7, pc}
    9640:	.word	0x2001cf8c
    9644:	.word	0x1fff0000
    9648:	.word	0x2001d004

0000964c <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    964c:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    964e:	cmp	r3, #3




usb_packet_t *usb_rx(uint32_t endpoint)
{
    9650:	push	{r4, lr}
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    9652:	bhi.n	9676 <usb_rx+0x2a>
	__disable_irq();
    9654:	cpsid	i
	ret = rx_first[endpoint];
    9656:	ldr	r2, [pc, #36]	; (967c <usb_rx+0x30>)
    9658:	ldr.w	r0, [r2, r3, lsl #2]
	if (ret) {
    965c:	cbz	r0, 9672 <usb_rx+0x26>
		rx_first[endpoint] = ret->next;
    965e:	ldr	r1, [r0, #4]
    9660:	str.w	r1, [r2, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    9664:	ldr	r1, [pc, #24]	; (9680 <usb_rx+0x34>)
    9666:	ldrh	r4, [r0, #0]
    9668:	ldrh.w	r2, [r1, r3, lsl #1]
    966c:	subs	r2, r2, r4
    966e:	strh.w	r2, [r1, r3, lsl #1]
	}
	__enable_irq();
    9672:	cpsie	i
	//serial_print("rx, epidx=");
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
    9674:	pop	{r4, pc}

usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    9676:	movs	r0, #0
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    9678:	pop	{r4, pc}
    967a:	nop
    967c:	.word	0x2001cf7c
    9680:	.word	0x2001d078

00009684 <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    9684:	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    9686:	cmp	r0, #3
    9688:	bhi.n	96a0 <usb_tx_packet_count+0x1c>
	__disable_irq();
    968a:	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    968c:	ldr	r3, [pc, #20]	; (96a4 <usb_tx_packet_count+0x20>)
    968e:	ldr.w	r3, [r3, r0, lsl #2]
// https://forum.pjrc.com/threads/58663?p=223513&viewfull=1#post223513
//
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;
    9692:	movs	r0, #0

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    9694:	cbz	r3, 969c <usb_tx_packet_count+0x18>
    9696:	adds	r0, #1
    9698:	ldr	r3, [r3, #4]
    969a:	b.n	9694 <usb_tx_packet_count+0x10>
	__enable_irq();
    969c:	cpsie	i
	return count;
    969e:	bx	lr
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
    96a0:	movs	r0, #0
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
	__enable_irq();
	return count;
}
    96a2:	bx	lr
    96a4:	.word	0x2001cfd0

000096a8 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    96a8:	push	{r4, r5, r6}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    96aa:	cpsid	i
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    96ac:	ldr	r5, [pc, #92]	; (970c <usb_rx_memory+0x64>)
			if (table[index(i, RX, EVEN)].desc == 0) {
    96ae:	ldr	r4, [pc, #96]	; (9710 <usb_rx_memory+0x68>)
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    96b0:	movs	r3, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    96b2:	adds	r2, r3, r5
    96b4:	ldrb.w	r2, [r2, #-1]
    96b8:	lsls	r2, r2, #28
    96ba:	bpl.n	96f8 <usb_rx_memory+0x50>
			if (table[index(i, RX, EVEN)].desc == 0) {
    96bc:	lsls	r2, r3, #2
    96be:	ldr	r1, [pc, #80]	; (9710 <usb_rx_memory+0x68>)
    96c0:	ldr.w	r6, [r4, r2, lsl #3]
    96c4:	cbnz	r6, 96d2 <usb_rx_memory+0x2a>
				table[index(i, RX, EVEN)].addr = packet->buf;
    96c6:	add.w	r3, r1, r3, lsl #5
    96ca:	adds	r0, #8
    96cc:	str	r0, [r3, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    96ce:	ldr	r3, [pc, #68]	; (9714 <usb_rx_memory+0x6c>)
    96d0:	b.n	96e6 <usb_rx_memory+0x3e>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    96d2:	orr.w	r2, r2, #1
    96d6:	ldr.w	r6, [r4, r2, lsl #3]
    96da:	cbnz	r6, 96f8 <usb_rx_memory+0x50>
				table[index(i, RX, ODD)].addr = packet->buf;
    96dc:	add.w	r3, r1, r2, lsl #3
    96e0:	adds	r0, #8
    96e2:	str	r0, [r3, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    96e4:	ldr	r3, [pc, #48]	; (9718 <usb_rx_memory+0x70>)
    96e6:	str.w	r3, [r1, r2, lsl #3]
				usb_rx_memory_needed--;
    96ea:	ldr	r2, [pc, #48]	; (971c <usb_rx_memory+0x74>)
    96ec:	ldrb	r3, [r2, #0]
    96ee:	subs	r3, #1
    96f0:	strb	r3, [r2, #0]
				__enable_irq();
    96f2:	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
    96f4:	pop	{r4, r5, r6}
    96f6:	bx	lr
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
    96f8:	adds	r3, #1
    96fa:	cmp	r3, #5
    96fc:	bne.n	96b2 <usb_rx_memory+0xa>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    96fe:	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    9700:	ldr	r3, [pc, #24]	; (971c <usb_rx_memory+0x74>)
    9702:	movs	r2, #0
    9704:	strb	r2, [r3, #0]
	usb_free(packet);
	return;
}
    9706:	pop	{r4, r5, r6}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
    9708:	b.w	95c8 <usb_free>
    970c:	.word	0x00012faa
    9710:	.word	0x1fff0000
    9714:	.word	0x00400088
    9718:	.word	0x004000c8
    971c:	.word	0x2001cffa

00009720 <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    9720:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    9722:	cmp	r3, #3

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    9724:	push	{r4, lr}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
    9726:	bhi.n	978e <usb_tx+0x6e>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    9728:	ldr	r2, [pc, #100]	; (9790 <usb_tx+0x70>)
    972a:	lsls	r0, r0, #5
    972c:	orr.w	r0, r0, #16
    9730:	add	r0, r2
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    9732:	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    9734:	ldr	r2, [pc, #92]	; (9794 <usb_tx+0x74>)
    9736:	ldrb	r4, [r2, r3]
    9738:	cmp	r4, #3
    973a:	bhi.n	9754 <usb_tx+0x34>
    973c:	tbb	[pc, r4]
    9740:	.word	0x07020418
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
		next = TX_STATE_EVEN_FREE;
		break;
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    9744:	movs	r4, #5
    9746:	b.n	9772 <usb_tx+0x52>
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    9748:	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    974a:	movs	r4, #2
		break;
    974c:	b.n	9772 <usb_tx+0x52>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    974e:	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    9750:	movs	r4, #4
		break;
    9752:	b.n	9772 <usb_tx+0x52>
	  default:
		if (tx_first[endpoint] == NULL) {
    9754:	ldr	r0, [pc, #64]	; (9798 <usb_tx+0x78>)
    9756:	ldr	r2, [pc, #68]	; (979c <usb_tx+0x7c>)
    9758:	ldr.w	r4, [r0, r3, lsl #2]
    975c:	cbnz	r4, 9764 <usb_tx+0x44>
			tx_first[endpoint] = packet;
    975e:	str.w	r1, [r0, r3, lsl #2]
    9762:	b.n	976a <usb_tx+0x4a>
		} else {
			tx_last[endpoint]->next = packet;
    9764:	ldr.w	r0, [r2, r3, lsl #2]
    9768:	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    976a:	str.w	r1, [r2, r3, lsl #2]
    976e:	b.n	978c <usb_tx+0x6c>
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    9770:	movs	r4, #3
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    9772:	strb	r4, [r2, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9774:	tst.w	r0, #8
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    9778:	add.w	r3, r1, #8
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    977c:	ldrh	r2, [r1, #0]
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    977e:	str	r3, [r0, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9780:	ite	ne
    9782:	movne	r3, #200	; 0xc8
    9784:	moveq	r3, #136	; 0x88
    9786:	orr.w	r3, r3, r2, lsl #16
    978a:	str	r3, [r0, #0]
	__enable_irq();
    978c:	cpsie	i
    978e:	pop	{r4, pc}
    9790:	.word	0x1fff0000
    9794:	.word	0x2001cf38
    9798:	.word	0x2001cfd0
    979c:	.word	0x2001cfe0

000097a0 <usb_isr>:
}



void usb_isr(void)
{
    97a0:	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    97a4:	ldr.w	r8, [pc, #680]	; 9a50 <usb_isr+0x2b0>
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    97a8:	ldr	r3, [pc, #676]	; (9a50 <usb_isr+0x2b0>)
    97aa:	ldrb	r4, [r3, #0]
    97ac:	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    97ae:	tst.w	r4, #4
    97b2:	mov	r5, r3
    97b4:	beq.n	97ec <usb_isr+0x4c>
		if (usb_configuration) {
    97b6:	ldr	r3, [pc, #668]	; (9a54 <usb_isr+0x2b4>)
    97b8:	ldrb	r3, [r3, #0]
    97ba:	cbz	r3, 97e6 <usb_isr+0x46>
			t = usb_reboot_timer;
    97bc:	ldr	r2, [pc, #664]	; (9a58 <usb_isr+0x2b8>)
    97be:	ldrb	r1, [r2, #0]
			if (t) {
    97c0:	and.w	r3, r1, #255	; 0xff
    97c4:	cbz	r1, 97d0 <usb_isr+0x30>
				usb_reboot_timer = --t;
    97c6:	subs	r3, #1
    97c8:	uxtb	r3, r3
    97ca:	strb	r3, [r2, #0]
				if (!t) _reboot_Teensyduino_();
    97cc:	cbnz	r3, 97d0 <usb_isr+0x30>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    97ce:	bkpt	0x0000
			if (t) {
				usb_reboot_timer = --t;
				if (!t) _reboot_Teensyduino_();
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    97d0:	ldr	r2, [pc, #648]	; (9a5c <usb_isr+0x2bc>)
    97d2:	ldrb	r1, [r2, #0]
			if (t) {
    97d4:	and.w	r3, r1, #255	; 0xff
    97d8:	cbz	r1, 97e6 <usb_isr+0x46>
				usb_cdc_transmit_flush_timer = --t;
    97da:	subs	r3, #1
    97dc:	uxtb	r3, r3
    97de:	strb	r3, [r2, #0]
				if (t == 0) usb_serial_flush_callback();
    97e0:	cbnz	r3, 97e6 <usb_isr+0x46>
    97e2:	bl	9270 <usb_serial_flush_callback>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    97e6:	movs	r3, #4
    97e8:	strb.w	r3, [r8]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    97ec:	and.w	r3, r4, #8
    97f0:	and.w	r2, r3, #255	; 0xff
    97f4:	cmp	r3, #0
    97f6:	beq.w	9ce0 <usb_isr+0x540>
		uint8_t endpoint;
		stat = USB0_STAT;
    97fa:	ldr	r3, [pc, #612]	; (9a60 <usb_isr+0x2c0>)
    97fc:	ldr	r4, [pc, #612]	; (9a64 <usb_isr+0x2c4>)
    97fe:	ldrb	r3, [r3, #0]
    9800:	uxtb	r3, r3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    9802:	lsrs	r7, r3, #4
    9804:	mov.w	r6, r3, lsr #2
    9808:	bne.w	9be8 <usb_isr+0x448>
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
    980c:	ldr.w	r3, [r4, r6, lsl #3]
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    9810:	add.w	r2, r4, r6, lsl #3
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    9814:	ubfx	r3, r3, #2, #4
    9818:	subs	r3, #1
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    981a:	ldr	r2, [r2, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    981c:	cmp	r3, #12
    981e:	bhi.w	9be0 <usb_isr+0x440>
    9822:	tbh	[pc, r3, lsl #1]
    9826:	.short	0x019e
    9828:	.word	0x01dd019e
    982c:	.word	0x01dd01dd
    9830:	.word	0x01dd01dd
    9834:	.word	0x01bb01dd
    9838:	.word	0x01dd01dd
    983c:	.word	0x000d01dd
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    9840:	ldr	r5, [pc, #548]	; (9a68 <usb_isr+0x2c8>)
		setup.word2 = *(uint32_t *)(buf + 4);
    9842:	ldr	r3, [r2, #4]
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    9844:	ldr	r1, [r2, #0]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    9846:	ldr	r0, [pc, #548]	; (9a6c <usb_isr+0x2cc>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    9848:	str	r3, [r5, #4]

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    984a:	ldr	r3, [pc, #548]	; (9a70 <usb_isr+0x2d0>)
    984c:	str.w	r3, [r4, r6, lsl #3]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    9850:	movs	r3, #1
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    9852:	str	r1, [r5, #0]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    9854:	ldr.w	sl, [pc, #584]	; 9aa0 <usb_isr+0x300>
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    9858:	strb	r3, [r0, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    985a:	uxth	r1, r1
    985c:	movw	r0, #1665	; 0x681
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    9860:	movs	r2, #0
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    9862:	cmp	r1, r0
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    9864:	str	r2, [r4, #16]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    9866:	str.w	r2, [sl]
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
    986a:	str	r2, [r4, #24]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    986c:	bhi.n	989e <usb_isr+0xfe>
    986e:	cmp.w	r1, #1664	; 0x680
    9872:	bcs.w	9ac6 <usb_isr+0x326>
    9876:	cmp.w	r1, #258	; 0x102
    987a:	beq.w	9a30 <usb_isr+0x290>
    987e:	bhi.n	988e <usb_isr+0xee>
    9880:	cmp	r1, #128	; 0x80
    9882:	beq.w	9a0a <usb_isr+0x26a>
    9886:	cmp	r1, #130	; 0x82
    9888:	beq.w	9a12 <usb_isr+0x272>
    988c:	b.n	9b00 <usb_isr+0x360>
    988e:	movw	r3, #770	; 0x302
    9892:	cmp	r1, r3
    9894:	beq.w	9aa8 <usb_isr+0x308>
    9898:	cmp.w	r1, #1280	; 0x500
    989c:	b.n	98d6 <usb_isr+0x136>
    989e:	movw	r0, #8225	; 0x2021
    98a2:	cmp	r1, r0
    98a4:	beq.w	9b5c <usb_isr+0x3bc>
    98a8:	bhi.n	98c6 <usb_isr+0x126>
    98aa:	cmp.w	r1, #2176	; 0x880
    98ae:	beq.w	9a00 <usb_isr+0x260>
    98b2:	cmp.w	r1, #2304	; 0x900
    98b6:	bne.w	9b00 <usb_isr+0x360>
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    98ba:	ldr	r3, [pc, #408]	; (9a54 <usb_isr+0x2b4>)
    98bc:	ldrb	r2, [r5, #2]
    98be:	strb	r2, [r3, #0]
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    98c0:	movs	r6, #4
			if (table[i].desc & BDT_OWN) {
    98c2:	ldr	r7, [pc, #416]	; (9a64 <usb_isr+0x2c4>)
    98c4:	b.n	98dc <usb_isr+0x13c>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    98c6:	movw	r3, #8737	; 0x2221
    98ca:	cmp	r1, r3
    98cc:	beq.w	9aec <usb_isr+0x34c>
    98d0:	movw	r3, #8993	; 0x2321
    98d4:	cmp	r1, r3
    98d6:	beq.w	9b08 <usb_isr+0x368>
    98da:	b.n	9b00 <usb_isr+0x360>
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
			if (table[i].desc & BDT_OWN) {
    98dc:	ldr.w	r3, [r4, r6, lsl #3]
    98e0:	lsls	r3, r3, #24
    98e2:	bpl.n	98f0 <usb_isr+0x150>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    98e4:	add.w	r3, r7, r6, lsl #3
    98e8:	ldr	r0, [r3, #4]
    98ea:	subs	r0, #8
    98ec:	bl	95c8 <usb_free>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    98f0:	adds	r6, #1
    98f2:	cmp	r6, #20
    98f4:	bne.n	98dc <usb_isr+0x13c>
    98f6:	ldr	r7, [pc, #380]	; (9a74 <usb_isr+0x2d4>)
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    98f8:	ldr.w	fp, [pc, #380]	; 9a78 <usb_isr+0x2d8>
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    98fc:	movs	r6, #0
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    98fe:	ldr.w	r0, [fp, r6, lsl #2]
    9902:	mov.w	r9, r6, lsl #2
			while (p) {
    9906:	cbz	r0, 9916 <usb_isr+0x176>
				n = p->next;
    9908:	ldr	r2, [r0, #4]
    990a:	str	r2, [sp, #0]
				usb_free(p);
    990c:	bl	95c8 <usb_free>
				p = n;
    9910:	ldr	r2, [sp, #0]
    9912:	mov	r0, r2
    9914:	b.n	9906 <usb_isr+0x166>
			}
			rx_first[i] = NULL;
    9916:	ldr	r3, [pc, #352]	; (9a78 <usb_isr+0x2d8>)
			rx_last[i] = NULL;
			p = tx_first[i];
    9918:	ldr	r2, [pc, #352]	; (9a7c <usb_isr+0x2dc>)
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
    991a:	str.w	r0, [r3, r9]
			rx_last[i] = NULL;
    991e:	ldr	r3, [pc, #352]	; (9a80 <usb_isr+0x2e0>)
    9920:	str.w	r0, [r9, r3]
			p = tx_first[i];
    9924:	ldr.w	r0, [r9, r2]
			while (p) {
    9928:	cbz	r0, 993c <usb_isr+0x19c>
				n = p->next;
    992a:	ldr	r1, [r0, #4]
    992c:	str	r2, [sp, #4]
    992e:	str	r1, [sp, #0]
				usb_free(p);
    9930:	bl	95c8 <usb_free>
				p = n;
    9934:	ldr	r1, [sp, #0]
    9936:	ldr	r2, [sp, #4]
    9938:	mov	r0, r1
    993a:	b.n	9928 <usb_isr+0x188>
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    993c:	ldr	r3, [pc, #324]	; (9a84 <usb_isr+0x2e4>)
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    993e:	str.w	r0, [r2, r9]
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    9942:	strh.w	r0, [r3, r6, lsl #1]
			switch (tx_state[i]) {
    9946:	ldrb	r3, [r7, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    9948:	ldr	r2, [pc, #316]	; (9a88 <usb_isr+0x2e8>)
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    994a:	subs	r3, #2
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
    994c:	str.w	r0, [r9, r2]
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    9950:	cmp	r3, #3
    9952:	bhi.n	9964 <usb_isr+0x1c4>
    9954:	tbb	[pc, r3]
    9958:	.word	0x04020402
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    995c:	movs	r3, #0
    995e:	b.n	9962 <usb_isr+0x1c2>
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    9960:	movs	r3, #1
    9962:	strb	r3, [r7, #0]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    9964:	adds	r6, #1
    9966:	cmp	r6, #4
    9968:	add.w	r7, r7, #1
    996c:	bne.n	98fe <usb_isr+0x15e>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    996e:	ldr	r1, [pc, #284]	; (9a8c <usb_isr+0x2ec>)
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
    9970:	ldr.w	r9, [pc, #304]	; 9aa4 <usb_isr+0x304>
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    9974:	movs	r3, #0
    9976:	strb	r3, [r1, #0]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    9978:	mov.w	fp, #1
    997c:	mov	r7, r1
    997e:	ldr	r3, [pc, #272]	; (9a90 <usb_isr+0x2f0>)
			epconf = *cfg++;
    9980:	add.w	r0, fp, r9
    9984:	add	r3, fp
    9986:	ldrb.w	r0, [r0, #-1]
    998a:	lsls	r3, r3, #2
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    998c:	tst.w	r0, #8
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
			*reg = epconf;
    9990:	strb	r0, [r3, #0]
    9992:	mov.w	r6, fp, lsl #2
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    9996:	beq.n	99e0 <usb_isr+0x240>
				usb_packet_t *p;
				p = usb_malloc();
    9998:	bl	958c <usb_malloc>
				if (p) {
    999c:	cbz	r0, 99b0 <usb_isr+0x210>
					table[index(i, RX, EVEN)].addr = p->buf;
    999e:	add.w	lr, r4, fp, lsl #5
    99a2:	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    99a4:	ldr	r3, [pc, #236]	; (9a94 <usb_isr+0x2f4>)
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
    99a6:	str.w	r0, [lr, #4]
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    99aa:	str.w	r3, [r4, r6, lsl #3]
    99ae:	b.n	99ba <usb_isr+0x21a>
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    99b0:	str.w	r0, [r4, r6, lsl #3]
					usb_rx_memory_needed++;
    99b4:	ldrb	r0, [r7, #0]
    99b6:	adds	r0, #1
    99b8:	strb	r0, [r7, #0]
				}
				p = usb_malloc();
    99ba:	bl	958c <usb_malloc>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    99be:	orr.w	lr, r6, #1
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
    99c2:	cbz	r0, 99d6 <usb_isr+0x236>
					table[index(i, RX, ODD)].addr = p->buf;
    99c4:	add.w	ip, r4, lr, lsl #3
    99c8:	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    99ca:	ldr	r3, [pc, #164]	; (9a70 <usb_isr+0x2d0>)
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    99cc:	str.w	r0, [ip, #4]
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    99d0:	str.w	r3, [r4, lr, lsl #3]
    99d4:	b.n	99e0 <usb_isr+0x240>
				} else {
					table[index(i, RX, ODD)].desc = 0;
    99d6:	str.w	r0, [r4, lr, lsl #3]
					usb_rx_memory_needed++;
    99da:	ldrb	r0, [r7, #0]
    99dc:	adds	r0, #1
    99de:	strb	r0, [r7, #0]
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    99e0:	orr.w	lr, r6, #2
			table[index(i, TX, ODD)].desc = 0;
    99e4:	orr.w	r3, r6, #3
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    99e8:	add.w	fp, fp, #1
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    99ec:	movs	r0, #0
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    99ee:	cmp.w	fp, #5
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    99f2:	str.w	r0, [r4, lr, lsl #3]
			table[index(i, TX, ODD)].desc = 0;
    99f6:	str.w	r0, [r4, r3, lsl #3]
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
    99fa:	bne.n	997e <usb_isr+0x1de>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    99fc:	mov	r3, r0
    99fe:	b.n	9b12 <usb_isr+0x372>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    9a00:	ldr	r2, [pc, #80]	; (9a54 <usb_isr+0x2b4>)
    9a02:	ldr	r6, [pc, #148]	; (9a98 <usb_isr+0x2f8>)
    9a04:	ldrb	r2, [r2, #0]
    9a06:	strb	r2, [r6, #0]
    9a08:	b.n	9b14 <usb_isr+0x374>
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    9a0a:	ldr	r6, [pc, #140]	; (9a98 <usb_isr+0x2f8>)
    9a0c:	strb	r2, [r6, #0]
		reply_buffer[1] = 0;
    9a0e:	strb	r2, [r6, #1]
    9a10:	b.n	9b0c <usb_isr+0x36c>
    9a12:	ldrh	r1, [r5, #4]
    9a14:	and.w	r1, r1, #127	; 0x7f
		datalen = 2;
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    9a18:	cmp	r1, #4
    9a1a:	bhi.n	9b00 <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    9a1c:	ldr	r6, [pc, #120]	; (9a98 <usb_isr+0x2f8>)
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    9a1e:	lsls	r1, r1, #2
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    9a20:	strb	r2, [r6, #0]
		reply_buffer[1] = 0;
    9a22:	strb	r2, [r6, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    9a24:	ldr	r2, [pc, #116]	; (9a9c <usb_isr+0x2fc>)
    9a26:	ldrb	r2, [r2, r1]
    9a28:	lsls	r4, r2, #30
    9a2a:	bpl.n	9b0c <usb_isr+0x36c>
    9a2c:	strb	r3, [r6, #0]
    9a2e:	b.n	9b0c <usb_isr+0x36c>
    9a30:	ldrh	r2, [r5, #4]
    9a32:	and.w	r2, r2, #127	; 0x7f
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    9a36:	cmp	r2, #4
    9a38:	bhi.n	9b00 <usb_isr+0x360>
    9a3a:	ldrh	r3, [r5, #2]
    9a3c:	cmp	r3, #0
    9a3e:	bne.n	9b00 <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    9a40:	ldr	r1, [pc, #88]	; (9a9c <usb_isr+0x2fc>)
    9a42:	lsls	r2, r2, #2
    9a44:	add	r1, r2
    9a46:	ldrb	r2, [r1, #0]
    9a48:	bic.w	r2, r2, #2
    9a4c:	b.n	9ac2 <usb_isr+0x322>
    9a4e:	nop
    9a50:	.word	0x40072080
    9a54:	.word	0x2001d003
    9a58:	.word	0x2001cf8d
    9a5c:	.word	0x2001cf0c
    9a60:	.word	0x40072090
    9a64:	.word	0x1fff0000
    9a68:	.word	0x2001cff0
    9a6c:	.word	0x2001d004
    9a70:	.word	0x004000c8
    9a74:	.word	0x2001cf38
    9a78:	.word	0x2001cf7c
    9a7c:	.word	0x2001cfd0
    9a80:	.word	0x2001cf28
    9a84:	.word	0x2001d078
    9a88:	.word	0x2001cfe0
    9a8c:	.word	0x2001cffa
    9a90:	.word	0x1001c830
    9a94:	.word	0x00400088
    9a98:	.word	0x2001cffb
    9a9c:	.word	0x400720c0
    9aa0:	.word	0x2001cf24
    9aa4:	.word	0x00012faa
    9aa8:	ldrh	r2, [r5, #4]
    9aaa:	and.w	r2, r2, #127	; 0x7f
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    9aae:	cmp	r2, #4
    9ab0:	bhi.n	9b00 <usb_isr+0x360>
    9ab2:	ldrh	r3, [r5, #2]
    9ab4:	cbnz	r3, 9b00 <usb_isr+0x360>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    9ab6:	ldr	r1, [pc, #620]	; (9d24 <usb_isr+0x584>)
    9ab8:	lsls	r2, r2, #2
    9aba:	add	r1, r2
    9abc:	ldrb	r2, [r1, #0]
    9abe:	orr.w	r2, r2, #2
    9ac2:	strb	r2, [r1, #0]
    9ac4:	b.n	9b12 <usb_isr+0x372>
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    9ac6:	ldrh	r2, [r5, #2]
    9ac8:	ldrh	r1, [r5, #4]
    9aca:	ldr	r3, [pc, #604]	; (9d28 <usb_isr+0x588>)
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    9acc:	ldr	r6, [r3, #4]
    9ace:	cbz	r6, 9b00 <usb_isr+0x360>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    9ad0:	ldrh	r0, [r3, #0]
    9ad2:	cmp	r0, r2
    9ad4:	bne.n	9ae8 <usb_isr+0x348>
    9ad6:	ldrh	r0, [r3, #2]
    9ad8:	cmp	r0, r1
    9ada:	bne.n	9ae8 <usb_isr+0x348>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    9adc:	lsrs	r2, r2, #8
    9ade:	cmp	r2, #3
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    9ae0:	ite	eq
    9ae2:	ldrbeq	r3, [r6, #0]
				} else {
					datalen = list->length;
    9ae4:	ldrhne	r3, [r3, #8]
    9ae6:	b.n	9b14 <usb_isr+0x374>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    9ae8:	adds	r3, #12
    9aea:	b.n	9acc <usb_isr+0x32c>
		}
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		switch (setup.wIndex) {
    9aec:	ldrh	r3, [r5, #4]
    9aee:	cbnz	r3, 9b10 <usb_isr+0x370>
#ifdef CDC_STATUS_INTERFACE
		  case CDC_STATUS_INTERFACE:
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    9af0:	ldr	r2, [pc, #568]	; (9d2c <usb_isr+0x58c>)
    9af2:	ldr	r1, [r2, #0]
    9af4:	ldr	r2, [pc, #568]	; (9d30 <usb_isr+0x590>)
    9af6:	str	r1, [r2, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    9af8:	ldr	r2, [pc, #568]	; (9d34 <usb_isr+0x594>)
    9afa:	ldrb	r1, [r5, #2]
    9afc:	strb	r1, [r2, #0]
    9afe:	b.n	9b12 <usb_isr+0x372>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9b00:	ldr	r3, [pc, #544]	; (9d24 <usb_isr+0x584>)
    9b02:	movs	r2, #15
    9b04:	strb	r2, [r3, #0]
    9b06:	b.n	9b5c <usb_isr+0x3bc>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    9b08:	movs	r3, #0
    9b0a:	b.n	9b12 <usb_isr+0x372>
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    9b0c:	movs	r3, #2
    9b0e:	b.n	9b14 <usb_isr+0x374>
static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
	uint32_t datalen = 0;
    9b10:	mov	r3, r2

static uint8_t reply_buffer[8];

static void usb_setup(void)
{
	const uint8_t *data = NULL;
    9b12:	mov	r6, r3
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    9b14:	ldrh	r4, [r5, #6]
    9b16:	cmp	r4, r3
    9b18:	it	cs
    9b1a:	movcs	r4, r3
    9b1c:	cmp	r4, #64	; 0x40
    9b1e:	mov	r5, r4
    9b20:	it	cs
    9b22:	movcs	r5, #64	; 0x40
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
    9b24:	mov	r0, r6
    9b26:	mov	r1, r5
    9b28:	bl	960c <endpoint0_transmit>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9b2c:	subs	r4, r4, r5

	if (datalen > setup.wLength) datalen = setup.wLength;
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    9b2e:	add	r6, r5
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9b30:	bne.n	9b3a <usb_isr+0x39a>
    9b32:	cmp	r5, #64	; 0x40
    9b34:	bne.n	9b5c <usb_isr+0x3bc>
    9b36:	mov	r5, r4
    9b38:	b.n	9b42 <usb_isr+0x3a2>
    9b3a:	cmp	r4, #64	; 0x40
    9b3c:	mov	r5, r4
    9b3e:	it	cs
    9b40:	movcs	r5, #64	; 0x40

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
    9b42:	mov	r0, r6
    9b44:	mov	r1, r5
    9b46:	bl	960c <endpoint0_transmit>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9b4a:	subs	r4, r4, r5
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    9b4c:	add	r6, r5
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    9b4e:	bne.n	9b54 <usb_isr+0x3b4>
    9b50:	cmp	r5, #64	; 0x40
    9b52:	bne.n	9b5c <usb_isr+0x3bc>

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    9b54:	ldr	r3, [pc, #480]	; (9d38 <usb_isr+0x598>)
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    9b56:	str.w	r6, [sl]
	ep0_tx_len = datalen;
    9b5a:	strh	r4, [r3, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    9b5c:	movs	r2, #1
    9b5e:	ldr	r3, [pc, #476]	; (9d3c <usb_isr+0x59c>)
    9b60:	b.n	9bde <usb_isr+0x43e>
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    9b62:	ldr	r3, [pc, #476]	; (9d40 <usb_isr+0x5a0>)
    9b64:	ldrh	r0, [r3, #0]
    9b66:	movw	r1, #8225	; 0x2021
    9b6a:	cmp	r0, r1
    9b6c:	bne.n	9b94 <usb_isr+0x3f4>
			int i;
			uint32_t *line_coding = NULL;
			switch (setup.wIndex) {
    9b6e:	ldrh	r3, [r3, #4]
    9b70:	cbnz	r3, 9b8c <usb_isr+0x3ec>
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
					//serial_phex(*buf);
					*dst++ = *buf++;
    9b72:	ldr	r1, [pc, #464]	; (9d44 <usb_isr+0x5a4>)
    9b74:	ldrb	r0, [r2, r3]
    9b76:	strb	r0, [r3, r1]
#endif
			}
			if (line_coding) {
				uint8_t *dst = (uint8_t *)line_coding;
				//serial_print("set line coding ");
				for (i=0; i<7; i++) {
    9b78:	adds	r3, #1
    9b7a:	cmp	r3, #7
    9b7c:	bne.n	9b74 <usb_isr+0x3d4>
					//serial_phex(*buf);
					*dst++ = *buf++;
				}
				//serial_phex32(line_coding[0]);
				//serial_print("\n");
				if (line_coding[0] == 134) usb_reboot_timer = 15;
    9b7e:	ldr	r3, [pc, #452]	; (9d44 <usb_isr+0x5a4>)
    9b80:	ldr	r3, [r3, #0]
    9b82:	cmp	r3, #134	; 0x86
    9b84:	ittt	eq
    9b86:	ldreq	r3, [pc, #448]	; (9d48 <usb_isr+0x5a8>)
    9b88:	moveq	r2, #15
    9b8a:	strbeq	r2, [r3, #0]
			}
			endpoint0_transmit(NULL, 0);
    9b8c:	movs	r1, #0
    9b8e:	mov	r0, r1
    9b90:	bl	960c <endpoint0_transmit>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    9b94:	ldr	r3, [pc, #436]	; (9d4c <usb_isr+0x5ac>)
    9b96:	str.w	r3, [r4, r6, lsl #3]
    9b9a:	b.n	9be0 <usb_isr+0x440>
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    9b9c:	ldr	r7, [pc, #432]	; (9d50 <usb_isr+0x5b0>)
    9b9e:	ldr	r6, [r7, #0]
		if (data) {
    9ba0:	cbz	r6, 9bcc <usb_isr+0x42c>
			size = ep0_tx_len;
    9ba2:	ldr.w	sl, [pc, #404]	; 9d38 <usb_isr+0x598>
    9ba6:	ldrh.w	r4, [sl]
    9baa:	cmp	r4, #64	; 0x40
    9bac:	mov	r5, r4
    9bae:	it	cs
    9bb0:	movcs	r5, #64	; 0x40
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
    9bb2:	mov	r0, r6
    9bb4:	mov	r1, r5
    9bb6:	bl	960c <endpoint0_transmit>
			data += size;
			ep0_tx_len -= size;
    9bba:	subs	r0, r4, r5
    9bbc:	uxth	r0, r0
    9bbe:	strh.w	r0, [sl]
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    9bc2:	cbnz	r0, 9bc8 <usb_isr+0x428>
    9bc4:	cmp	r5, #64	; 0x40
    9bc6:	bne.n	9bca <usb_isr+0x42a>
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    9bc8:	adds	r0, r6, r5
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    9bca:	str	r0, [r7, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    9bcc:	ldr	r3, [pc, #368]	; (9d40 <usb_isr+0x5a0>)
    9bce:	ldrh	r2, [r3, #0]
    9bd0:	cmp.w	r2, #1280	; 0x500
    9bd4:	bne.n	9be0 <usb_isr+0x440>
			setup.bRequest = 0;
    9bd6:	movs	r2, #0
    9bd8:	strb	r2, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    9bda:	ldrb	r2, [r3, #2]
    9bdc:	ldr	r3, [pc, #372]	; (9d54 <usb_isr+0x5b4>)
    9bde:	strb	r2, [r3, #0]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    9be0:	ldr	r3, [pc, #344]	; (9d3c <usb_isr+0x59c>)
    9be2:	movs	r2, #1
    9be4:	strb	r2, [r3, #0]
    9be6:	b.n	9cd8 <usb_isr+0x538>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    9be8:	add.w	r5, r4, r6, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    9bec:	subs	r7, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    9bee:	ldr	r2, [r5, #4]
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    9bf0:	and.w	r3, r3, #8
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    9bf4:	sub.w	r0, r2, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    9bf8:	uxtb	r7, r7
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    9bfa:	and.w	lr, r3, #255	; 0xff
    9bfe:	cmp	r3, #0
    9c00:	beq.n	9c70 <usb_isr+0x4d0>
				usb_free(packet);
    9c02:	bl	95c8 <usb_free>
				packet = tx_first[endpoint];
    9c06:	ldr	r0, [pc, #336]	; (9d58 <usb_isr+0x5b8>)
    9c08:	ldr	r3, [pc, #336]	; (9d5c <usb_isr+0x5bc>)
    9c0a:	ldr.w	r1, [r0, r7, lsl #2]
				if (packet) {
    9c0e:	cbz	r1, 9c4c <usb_isr+0x4ac>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    9c10:	ldr	r2, [r1, #4]
    9c12:	str.w	r2, [r0, r7, lsl #2]
					b->addr = packet->buf;
    9c16:	add.w	r2, r1, #8
    9c1a:	str	r2, [r5, #4]
					switch (tx_state[endpoint]) {
    9c1c:	ldrb	r2, [r3, r7]
    9c1e:	cmp	r2, #3
    9c20:	bhi.n	9c3a <usb_isr+0x49a>
    9c22:	tbb	[pc, r2]
    9c26:	.short	0x0402
    9c28:	.short	0x0806
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    9c2a:	movs	r2, #3
    9c2c:	b.n	9c38 <usb_isr+0x498>
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    9c2e:	movs	r2, #2
    9c30:	b.n	9c38 <usb_isr+0x498>
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    9c32:	movs	r2, #5
    9c34:	b.n	9c38 <usb_isr+0x498>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    9c36:	movs	r2, #4
    9c38:	strb	r2, [r3, r7]
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    9c3a:	tst.w	r5, #8
    9c3e:	ldrh	r2, [r1, #0]
    9c40:	ite	ne
    9c42:	movne	r3, #200	; 0xc8
    9c44:	moveq	r3, #136	; 0x88
    9c46:	orr.w	r3, r3, r2, lsl #16
    9c4a:	b.n	9cd4 <usb_isr+0x534>
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    9c4c:	ldrb	r2, [r3, r7]
    9c4e:	cmp	r2, #3
    9c50:	bhi.n	9c62 <usb_isr+0x4c2>
    9c52:	tbb	[pc, r2]
    9c56:	.short	0x4141
    9c58:	.short	0x0402
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    9c5a:	movs	r2, #0
    9c5c:	b.n	9c6c <usb_isr+0x4cc>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    9c5e:	movs	r2, #1
    9c60:	b.n	9c6c <usb_isr+0x4cc>
						break;
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    9c62:	tst.w	r5, #8
    9c66:	ite	ne
    9c68:	movne	r2, #3
    9c6a:	moveq	r2, #2
    9c6c:	strb	r2, [r3, r7]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    9c6e:	b.n	9cd8 <usb_isr+0x538>
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    9c70:	ldr.w	r3, [r4, r6, lsl #3]
    9c74:	lsrs	r3, r3, #16
    9c76:	uxth	r1, r3
    9c78:	strh.w	r1, [r2, #-8]
				if (packet->len > 0) {
    9c7c:	cbz	r3, 9cc8 <usb_isr+0x528>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    9c7e:	ldr	r3, [pc, #224]	; (9d60 <usb_isr+0x5c0>)
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    9c80:	strh.w	lr, [r2, #-6]
					packet->next = NULL;
    9c84:	str.w	lr, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    9c88:	ldr.w	r2, [r3, r7, lsl #2]
    9c8c:	ldr.w	lr, [pc, #252]	; 9d8c <usb_isr+0x5ec>
    9c90:	cbnz	r2, 9c98 <usb_isr+0x4f8>
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    9c92:	str.w	r0, [r3, r7, lsl #2]
    9c96:	b.n	9c9e <usb_isr+0x4fe>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    9c98:	ldr.w	r3, [lr, r7, lsl #2]
    9c9c:	str	r0, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    9c9e:	ldr	r2, [pc, #196]	; (9d64 <usb_isr+0x5c4>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
					}
					rx_last[endpoint] = packet;
    9ca0:	str.w	r0, [lr, r7, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    9ca4:	ldrh.w	r3, [r2, r7, lsl #1]
    9ca8:	add	r3, r1
    9caa:	strh.w	r3, [r2, r7, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    9cae:	bl	958c <usb_malloc>
					if (packet) {
    9cb2:	cbz	r0, 9cba <usb_isr+0x51a>
						b->addr = packet->buf;
    9cb4:	adds	r0, #8
    9cb6:	str	r0, [r5, #4]
    9cb8:	b.n	9cc8 <usb_isr+0x528>
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    9cba:	ldr	r2, [pc, #172]	; (9d68 <usb_isr+0x5c8>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    9cbc:	str.w	r0, [r4, r6, lsl #3]
						usb_rx_memory_needed++;
    9cc0:	ldrb	r3, [r2, #0]
    9cc2:	adds	r3, #1
    9cc4:	strb	r3, [r2, #0]
    9cc6:	b.n	9cd8 <usb_isr+0x538>
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9cc8:	ldr	r2, [pc, #160]	; (9d6c <usb_isr+0x5cc>)
    9cca:	ldr	r3, [pc, #128]	; (9d4c <usb_isr+0x5ac>)
    9ccc:	tst.w	r5, #8
    9cd0:	it	eq
    9cd2:	moveq	r3, r2
    9cd4:	str.w	r3, [r4, r6, lsl #3]
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    9cd8:	movs	r3, #8
    9cda:	strb.w	r3, [r8]
		goto restart;
    9cde:	b.n	97a8 <usb_isr+0x8>
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    9ce0:	lsls	r0, r4, #31
    9ce2:	bpl.n	9d90 <usb_isr+0x5f0>
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    9ce4:	ldr	r1, [pc, #84]	; (9d3c <usb_isr+0x59c>)
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    9ce6:	ldr	r0, [pc, #132]	; (9d6c <usb_isr+0x5cc>)
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    9ce8:	ldr	r4, [pc, #132]	; (9d70 <usb_isr+0x5d0>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    9cea:	movs	r3, #2
    9cec:	strb	r3, [r1, #0]
		ep0_tx_bdt_bank = 0;
    9cee:	ldr	r3, [pc, #132]	; (9d74 <usb_isr+0x5d4>)
    9cf0:	strb	r2, [r3, #0]

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    9cf2:	ldr	r3, [pc, #132]	; (9d78 <usb_isr+0x5d8>)
    9cf4:	str	r0, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    9cf6:	str	r4, [r3, #4]
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    9cf8:	str	r0, [r3, #8]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    9cfa:	ldr	r0, [pc, #128]	; (9d7c <usb_isr+0x5dc>)
    9cfc:	str	r0, [r3, #12]
		table[index(0, TX, EVEN)].desc = 0;
    9cfe:	str	r2, [r3, #16]
		table[index(0, TX, ODD)].desc = 0;
    9d00:	str	r2, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9d02:	ldr	r3, [pc, #32]	; (9d24 <usb_isr+0x584>)
    9d04:	movs	r0, #13
    9d06:	strb	r0, [r3, #0]

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    9d08:	ldr	r0, [pc, #116]	; (9d80 <usb_isr+0x5e0>)
    9d0a:	movs	r3, #255	; 0xff
    9d0c:	strb	r3, [r0, #0]
		USB0_ISTAT = 0xFF;
    9d0e:	strb	r3, [r5, #0]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    9d10:	strb	r2, [r0, #16]

		// enable other interrupts
		USB0_ERREN = 0xFF;
    9d12:	ldr	r2, [pc, #112]	; (9d84 <usb_isr+0x5e4>)
    9d14:	strb	r3, [r2, #0]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    9d16:	ldr	r3, [pc, #112]	; (9d88 <usb_isr+0x5e8>)
    9d18:	movs	r2, #159	; 0x9f
    9d1a:	strb	r2, [r3, #0]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    9d1c:	movs	r3, #1
    9d1e:	strb	r3, [r1, #0]
		return;
    9d20:	b.n	9db6 <usb_isr+0x616>
    9d22:	nop
    9d24:	.word	0x400720c0
    9d28:	.word	0x00012fb0
    9d2c:	.word	0x2001cf20
    9d30:	.word	0x2001d074
    9d34:	.word	0x2001cf1c
    9d38:	.word	0x2001cff8
    9d3c:	.word	0x40072094
    9d40:	.word	0x2001cff0
    9d44:	.word	0x2001d06c
    9d48:	.word	0x2001cf8d
    9d4c:	.word	0x004000c8
    9d50:	.word	0x2001cf24
    9d54:	.word	0x40072098
    9d58:	.word	0x2001cfd0
    9d5c:	.word	0x2001cf38
    9d60:	.word	0x2001cf7c
    9d64:	.word	0x2001d078
    9d68:	.word	0x2001cffa
    9d6c:	.word	0x00400088
    9d70:	.word	0x2001cf3c
    9d74:	.word	0x2001cf8c
    9d78:	.word	0x1fff0000
    9d7c:	.word	0x2001cf90
    9d80:	.word	0x40072088
    9d84:	.word	0x4007208c
    9d88:	.word	0x40072084
    9d8c:	.word	0x2001cf28
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    9d90:	lsls	r1, r4, #24
    9d92:	bpl.n	9d9e <usb_isr+0x5fe>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    9d94:	ldr	r3, [pc, #36]	; (9dbc <usb_isr+0x61c>)
    9d96:	movs	r2, #13
    9d98:	strb	r2, [r3, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    9d9a:	movs	r3, #128	; 0x80
    9d9c:	strb	r3, [r5, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    9d9e:	lsls	r2, r4, #30
    9da0:	bpl.n	9dae <usb_isr+0x60e>
		uint8_t err = USB0_ERRSTAT;
    9da2:	ldr	r2, [pc, #28]	; (9dc0 <usb_isr+0x620>)
    9da4:	ldrb	r3, [r2, #0]
    9da6:	uxtb	r3, r3
		USB0_ERRSTAT = err;
    9da8:	strb	r3, [r2, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    9daa:	movs	r3, #2
    9dac:	strb	r3, [r5, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    9dae:	lsls	r3, r4, #27
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    9db0:	itt	mi
    9db2:	movmi	r3, #16
    9db4:	strbmi	r3, [r5, #0]
	}

}
    9db6:	add	sp, #12
    9db8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9dbc:	.word	0x400720c0
    9dc0:	.word	0x40072088

00009dc4 <usb_init>:



void usb_init(void)
{
    9dc4:	push	{r4, lr}
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    9dc6:	bl	a378 <usb_init_serialnumber>

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    9dca:	movs	r3, #0
		table[i].desc = 0;
    9dcc:	ldr	r0, [pc, #108]	; (9e3c <usb_init+0x78>)
    9dce:	mov	r1, r3
    9dd0:	str.w	r1, [r0, r3, lsl #3]
		table[i].addr = 0;
    9dd4:	add.w	r4, r0, r3, lsl #3
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    9dd8:	adds	r3, #1
    9dda:	cmp	r3, #20
		table[i].desc = 0;
    9ddc:	ldr	r2, [pc, #92]	; (9e3c <usb_init+0x78>)
		table[i].addr = 0;
    9dde:	str	r1, [r4, #4]
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i < (NUM_ENDPOINTS+1)*4; i++) {
    9de0:	bne.n	9dd0 <usb_init+0xc>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    9de2:	ldr	r1, [pc, #92]	; (9e40 <usb_init+0x7c>)
    9de4:	ldr	r3, [r1, #0]
    9de6:	orr.w	r3, r3, #262144	; 0x40000
    9dea:	str	r3, [r1, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    9dec:	ldr	r1, [pc, #84]	; (9e44 <usb_init+0x80>)
    9dee:	ldr	r3, [r1, #0]
    9df0:	orr.w	r3, r3, #50331648	; 0x3000000
    9df4:	str	r3, [r1, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    9df6:	ldr	r3, [pc, #80]	; (9e48 <usb_init+0x84>)
    9df8:	ubfx	r1, r2, #8, #8
    9dfc:	strb	r1, [r3, #0]
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    9dfe:	ubfx	r1, r2, #16, #8
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    9e02:	lsrs	r2, r2, #24
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    9e04:	strb	r1, [r3, #20]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    9e06:	strb	r2, [r3, #24]

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    9e08:	ldr	r2, [pc, #64]	; (9e4c <usb_init+0x88>)
    9e0a:	movs	r3, #255	; 0xff
    9e0c:	strb	r3, [r2, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    9e0e:	movs	r1, #0
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    9e10:	strb	r3, [r2, #8]
	USB0_OTGISTAT = 0xFF;
    9e12:	strb.w	r3, [r2, #-112]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    9e16:	movs	r3, #1
    9e18:	strb	r3, [r2, #20]
	USB0_USBCTRL = 0;
    9e1a:	strb.w	r1, [r2, #128]	; 0x80

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    9e1e:	strb	r3, [r2, #4]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    9e20:	ldr	r3, [pc, #44]	; (9e50 <usb_init+0x8c>)
    9e22:	movs	r2, #112	; 0x70
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    9e24:	mvn.w	r1, #816	; 0x330

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    9e28:	strb	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    9e2a:	add	r3, r1
    9e2c:	mov.w	r2, #2097152	; 0x200000
    9e30:	str	r2, [r3, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    9e32:	ldr	r3, [pc, #32]	; (9e54 <usb_init+0x90>)
    9e34:	movs	r2, #16
    9e36:	strb	r2, [r3, #0]
    9e38:	pop	{r4, pc}
    9e3a:	nop
    9e3c:	.word	0x1fff0000
    9e40:	.word	0x40048034
    9e44:	.word	0x4000d800
    9e48:	.word	0x4007209c
    9e4c:	.word	0x40072080
    9e50:	.word	0xe000e435
    9e54:	.word	0x40072108

00009e58 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    9e58:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    9e5c:	ldr	r4, [pc, #176]	; (9f10 <yield+0xb8>)
    9e5e:	ldrb	r3, [r4, #0]
    9e60:	cmp	r3, #0
    9e62:	beq.n	9f0a <yield+0xb2>
	if (running) return; // TODO: does this need to be atomic?
    9e64:	ldr	r5, [pc, #172]	; (9f14 <yield+0xbc>)
    9e66:	ldrb	r2, [r5, #0]
    9e68:	cmp	r2, #0
    9e6a:	bne.n	9f0a <yield+0xb2>
	running = 1;
    9e6c:	movs	r2, #1


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    9e6e:	lsls	r1, r3, #31
void yield(void)
{
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
    9e70:	strb	r2, [r5, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    9e72:	bpl.n	9e8c <yield+0x34>
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    9e74:	bl	9088 <usb_serial_available>
		if (Serial.available()) serialEvent();
    9e78:	cbz	r0, 9e7e <yield+0x26>
    9e7a:	bl	a2b6 <serialEvent()>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    9e7e:	ldr	r3, [pc, #152]	; (9f18 <yield+0xc0>)
    9e80:	ldrb	r3, [r3, #0]
    9e82:	cbz	r3, 9e8c <yield+0x34>
    9e84:	ldrb	r3, [r4, #0]
    9e86:	bic.w	r3, r3, #1
    9e8a:	strb	r3, [r4, #0]
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIALUSB2) {
		if (SerialUSB2.available()) serialEventUSB2();
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) {
    9e8c:	ldrb	r3, [r4, #0]
    9e8e:	lsls	r2, r3, #30
    9e90:	bpl.n	9ebc <yield+0x64>
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    9e92:	ldr.w	r8, [pc, #148]	; 9f28 <yield+0xd0>
			s_serials_with_serial_events[i]->doYieldCode();
    9e96:	ldr.w	r9, [pc, #148]	; 9f2c <yield+0xd4>
    9e9a:	movs	r6, #0
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    9e9c:	ldrb.w	r2, [r8]
    9ea0:	uxtb	r3, r6
    9ea2:	cmp	r2, r3
    9ea4:	bls.n	9ebc <yield+0x64>
			s_serials_with_serial_events[i]->doYieldCode();
    9ea6:	ldr.w	r7, [r9, r3, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[CNT_HARDWARE_SERIAL];
	static uint8_t 			s_count_serials_with_serial_events;
	void 		(* const _serialEvent)(); 
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*_serialEvent)();
    9eaa:	ldr	r3, [r7, #0]
    9eac:	mov	r0, r7
    9eae:	ldr	r3, [r3, #16]
    9eb0:	blx	r3
    9eb2:	cbz	r0, 9eb8 <yield+0x60>
    9eb4:	ldr	r3, [r7, #16]
    9eb6:	blx	r3
    9eb8:	adds	r6, #1
    9eba:	b.n	9e9c <yield+0x44>
		HardwareSerial::processSerialEventsList();
	}
	running = 0;
    9ebc:	movs	r3, #0
    9ebe:	strb	r3, [r5, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    9ec0:	ldrb	r3, [r4, #0]
    9ec2:	lsls	r3, r3, #29
    9ec4:	bpl.n	9f0a <yield+0xb2>
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);

	static void runFromYield() {
		if (!firstYield) return;  
    9ec6:	ldr	r1, [pc, #84]	; (9f1c <yield+0xc4>)
    9ec8:	ldr	r3, [r1, #0]
    9eca:	cbz	r3, 9f0a <yield+0xb2>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    9ecc:	mrs	r3, IPSR
		if (ipsr != 0) return;
    9ed0:	cbnz	r3, 9f0a <yield+0xb2>
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    9ed2:	mrs	r2, PRIMASK
		__disable_irq();
    9ed6:	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    9ed8:	ldr	r0, [r1, #0]
		if (first == nullptr) {
    9eda:	cbz	r0, 9ee2 <yield+0x8a>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    9edc:	ldr	r4, [pc, #64]	; (9f20 <yield+0xc8>)
    9ede:	ldrb	r5, [r4, #0]
    9ee0:	cbz	r5, 9eea <yield+0x92>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    9ee2:	cbnz	r2, 9f0a <yield+0xb2>
    9ee4:	cpsie	i
    9ee6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    9eea:	movs	r3, #1
    9eec:	strb	r3, [r4, #0]
		firstYield = first->_next;
    9eee:	ldr	r3, [r0, #20]
    9ef0:	str	r3, [r1, #0]
		if (firstYield) {
    9ef2:	cbz	r3, 9ef8 <yield+0xa0>
			firstYield->_prev = nullptr;
    9ef4:	str	r5, [r3, #24]
    9ef6:	b.n	9efc <yield+0xa4>
		} else {
			lastYield = nullptr;
    9ef8:	ldr	r1, [pc, #40]	; (9f24 <yield+0xcc>)
    9efa:	str	r3, [r1, #0]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    9efc:	cbnz	r2, 9f00 <yield+0xa8>
    9efe:	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    9f00:	movs	r5, #0
    9f02:	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    9f04:	ldr	r3, [r0, #8]
    9f06:	blx	r3
		runningFromYield = false;
    9f08:	strb	r5, [r4, #0]
    9f0a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    9f0e:	nop
    9f10:	.word	0x1fff1368
    9f14:	.word	0x2001d005
    9f18:	.word	0x1fff137c
    9f1c:	.word	0x2001d014
    9f20:	.word	0x2001d018
    9f24:	.word	0x2001d010
    9f28:	.word	0x2001d034
    9f2c:	.word	0x2001d01c

00009f30 <DMAChannel::begin(bool)>:
/**                     Teensy 3.0 & 3.1                       **/
/****************************************************************/
#if defined(KINETISK)

void DMAChannel::begin(bool force_initialization)
{
    9f30:	push	{r4, r5, lr}
	uint32_t ch = 0;

	__disable_irq();
    9f32:	cpsid	i
    9f34:	ldr	r4, [pc, #148]	; (9fcc <DMAChannel::begin(bool)+0x9c>)
	if (!force_initialization && TCD && channel < DMA_MAX_CHANNELS
    9f36:	cbnz	r1, 9f5c <DMAChannel::begin(bool)+0x2c>
    9f38:	ldr	r1, [r0, #0]
    9f3a:	cbz	r1, 9f5c <DMAChannel::begin(bool)+0x2c>
    9f3c:	ldrb	r3, [r0, #4]
    9f3e:	cmp	r3, #15
    9f40:	bhi.n	9f5c <DMAChannel::begin(bool)+0x2c>
	  && (dma_channel_allocated_mask & (1 << channel))
    9f42:	ldrh	r2, [r4, #0]
    9f44:	asrs	r2, r3
    9f46:	lsls	r2, r2, #31
    9f48:	bpl.n	9f5c <DMAChannel::begin(bool)+0x2c>
	  && (uint32_t)TCD == (uint32_t)(0x40009000 + channel * 32)) {
    9f4a:	add.w	r3, r3, #33554432	; 0x2000000
    9f4e:	add.w	r3, r3, #1152	; 0x480
    9f52:	cmp.w	r1, r3, lsl #5
    9f56:	bne.n	9f5c <DMAChannel::begin(bool)+0x2c>
		// DMA channel already allocated
		__enable_irq();
    9f58:	cpsie	i
		return;
    9f5a:	pop	{r4, r5, pc}
	}
	while (1) {
		if (!(dma_channel_allocated_mask & (1 << ch))) {
    9f5c:	ldrh	r1, [r4, #0]
    9f5e:	movs	r3, #0
    9f60:	asr.w	r2, r1, r3
    9f64:	ands.w	r2, r2, #1
    9f68:	bne.n	9fbc <DMAChannel::begin(bool)+0x8c>
			dma_channel_allocated_mask |= (1 << ch);
    9f6a:	movs	r5, #1
    9f6c:	lsls	r5, r3
    9f6e:	orrs	r1, r5
    9f70:	strh	r1, [r4, #0]
			__enable_irq();
    9f72:	cpsie	i
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    9f74:	ldr	r5, [pc, #88]	; (9fd0 <DMAChannel::begin(bool)+0xa0>)
			channel = DMA_MAX_CHANNELS;
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
    9f76:	uxtb	r1, r3
    9f78:	strb	r1, [r0, #4]
	SIM_SCGC7 |= SIM_SCGC7_DMA;
    9f7a:	ldr	r4, [r5, #0]
    9f7c:	orr.w	r4, r4, #2
    9f80:	str	r4, [r5, #0]
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    9f82:	ldr.w	r4, [r5, #-4]
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    9f86:	add.w	r3, r3, #33554432	; 0x2000000
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
    9f8a:	orr.w	r4, r4, #2
    9f8e:	str.w	r4, [r5, #-4]
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    9f92:	add.w	r3, r3, #1152	; 0x480
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
    9f96:	ldr	r4, [pc, #60]	; (9fd4 <DMAChannel::begin(bool)+0xa4>)
#endif
	DMA_CERQ = ch;
	DMA_CERR = ch;
	DMA_CEEI = ch;
	DMA_CINT = ch;
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    9f98:	lsls	r3, r3, #5
	SIM_SCGC7 |= SIM_SCGC7_DMA;
	SIM_SCGC6 |= SIM_SCGC6_DMAMUX;
#if DMA_NUM_CHANNELS <= 16
	DMA_CR = DMA_CR_EMLM | DMA_CR_EDBG; // minor loop mapping is available
#else
	DMA_CR = DMA_CR_GRP1PRI| DMA_CR_EMLM | DMA_CR_EDBG;
    9f9a:	movw	r5, #1154	; 0x482
    9f9e:	str	r5, [r4, #0]
#endif
	DMA_CERQ = ch;
    9fa0:	strb	r1, [r4, #26]
	DMA_CERR = ch;
    9fa2:	strb	r1, [r4, #30]
	DMA_CEEI = ch;
    9fa4:	strb	r1, [r4, #24]
	DMA_CINT = ch;
    9fa6:	strb	r1, [r4, #31]
	TCD = (TCD_t *)(0x40009000 + ch * 32);
    9fa8:	str	r3, [r0, #0]
	uint32_t *p = (uint32_t *)TCD;
	*p++ = 0;
    9faa:	str	r2, [r3, #0]
	*p++ = 0;
    9fac:	str	r2, [r3, #4]
	*p++ = 0;
    9fae:	str	r2, [r3, #8]
	*p++ = 0;
    9fb0:	str	r2, [r3, #12]
	*p++ = 0;
    9fb2:	str	r2, [r3, #16]
	*p++ = 0;
    9fb4:	str	r2, [r3, #20]
	*p++ = 0;
    9fb6:	str	r2, [r3, #24]
	*p++ = 0;
    9fb8:	str	r2, [r3, #28]
    9fba:	pop	{r4, r5, pc}
		if (!(dma_channel_allocated_mask & (1 << ch))) {
			dma_channel_allocated_mask |= (1 << ch);
			__enable_irq();
			break;
		}
		if (++ch >= DMA_MAX_CHANNELS) {
    9fbc:	adds	r3, #1
    9fbe:	cmp	r3, #16
    9fc0:	bne.n	9f60 <DMAChannel::begin(bool)+0x30>
			__enable_irq();
    9fc2:	cpsie	i
			TCD = (TCD_t *)0;
    9fc4:	movs	r2, #0
    9fc6:	str	r2, [r0, #0]
			channel = DMA_MAX_CHANNELS;
    9fc8:	strb	r3, [r0, #4]
    9fca:	pop	{r4, r5, pc}
    9fcc:	.word	0x2001d006
    9fd0:	.word	0x40048040
    9fd4:	.word	0x40008000

00009fd8 <DMAChannel::release()>:
	*p++ = 0;
}

void DMAChannel::release(void)
{
	if (channel >= DMA_MAX_CHANNELS) return;
    9fd8:	ldrb	r3, [r0, #4]
    9fda:	cmp	r3, #15
    9fdc:	bhi.n	a000 <DMAChannel::release()+0x28>
	DMA_CERQ = channel;
    9fde:	ldr	r2, [pc, #36]	; (a004 <DMAChannel::release()+0x2c>)
    9fe0:	strb	r3, [r2, #0]
	__disable_irq();
    9fe2:	cpsid	i
	dma_channel_allocated_mask &= ~(1 << channel);
    9fe4:	ldr	r1, [pc, #32]	; (a008 <DMAChannel::release()+0x30>)
    9fe6:	ldrb	r2, [r0, #4]
    9fe8:	movs	r3, #1
    9fea:	lsl.w	r2, r3, r2
    9fee:	ldrh	r3, [r1, #0]
    9ff0:	bic.w	r3, r3, r2
    9ff4:	strh	r3, [r1, #0]
	__enable_irq();
    9ff6:	cpsie	i
	channel = DMA_MAX_CHANNELS;
    9ff8:	movs	r3, #16
    9ffa:	strb	r3, [r0, #4]
	TCD = (TCD_t *)0;
    9ffc:	movs	r3, #0
    9ffe:	str	r3, [r0, #0]
    a000:	bx	lr
    a002:	nop
    a004:	.word	0x4000801a
    a008:	.word	0x2001d006

0000a00c <MillisTimer::disableTimerInterrupt()>:
	volatile TimerStateType _state = TimerOff;
	static MillisTimer *listWaiting; // single linked list of waiting to start timers
	static MillisTimer *listActive;  // double linked list of running timers
	static bool disableTimerInterrupt() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    a00c:	mrs	r0, PRIMASK
		__disable_irq();
    a010:	cpsid	i
		return (primask == 0) ? true : false;
	}
    a012:	clz	r0, r0
    a016:	lsrs	r0, r0, #5
    a018:	bx	lr

0000a01a <MillisTimer::enableTimerInterrupt(bool)>:
	static void enableTimerInterrupt(bool doit) {
		if (doit) __enable_irq();
    a01a:	cbz	r0, a01e <MillisTimer::enableTimerInterrupt(bool)+0x4>
    a01c:	cpsie	i
    a01e:	bx	lr

0000a020 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    a020:	push	{r3, r4, r5, r6, r7, lr}
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    a022:	ldr	r6, [pc, #48]	; (a054 <EventResponder::runFromInterrupt()+0x34>)
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    a024:	ldr	r7, [pc, #48]	; (a058 <EventResponder::runFromInterrupt()+0x38>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    a026:	movs	r5, #0
}

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
    a028:	bl	a00c <MillisTimer::disableTimerInterrupt()>
		EventResponder *first = firstInterrupt;
    a02c:	ldr	r4, [r6, #0]
}

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
    a02e:	mov	r2, r0
		EventResponder *first = firstInterrupt;
		if (first) {
    a030:	cbz	r4, a04e <EventResponder::runFromInterrupt()+0x2e>
			firstInterrupt = first->_next;
    a032:	ldr	r3, [r4, #20]
    a034:	str	r3, [r6, #0]
			if (firstInterrupt) {
    a036:	cbz	r3, a03c <EventResponder::runFromInterrupt()+0x1c>
				firstInterrupt->_prev = nullptr;
    a038:	str	r5, [r3, #24]
    a03a:	b.n	a03e <EventResponder::runFromInterrupt()+0x1e>
			} else {
				lastInterrupt = nullptr;
    a03c:	str	r3, [r7, #0]
			}
			enableInterrupts(irq);
    a03e:	mov	r0, r2
    a040:	bl	a01a <MillisTimer::enableTimerInterrupt(bool)>
			first->_triggered = false;
    a044:	strb	r5, [r4, #29]
			(*(first->_function))(*first);
    a046:	ldr	r3, [r4, #8]
    a048:	mov	r0, r4
    a04a:	blx	r3
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
	while (1) {
    a04c:	b.n	a028 <EventResponder::runFromInterrupt()+0x8>
			}
			enableInterrupts(irq);
			first->_triggered = false;
			(*(first->_function))(*first);
		} else {
			enableInterrupts(irq);
    a04e:	bl	a01a <MillisTimer::enableTimerInterrupt(bool)>
    a052:	pop	{r3, r4, r5, r6, r7, pc}
    a054:	.word	0x2001d008
    a058:	.word	0x2001d00c

0000a05c <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    a05c:	b.w	a020 <EventResponder::runFromInterrupt()>

0000a060 <systick_isr>:

extern "C" volatile uint32_t systick_millis_count;

void systick_isr(void)
{
	systick_millis_count++;
    a060:	ldr	r2, [pc, #8]	; (a06c <systick_isr+0xc>)
    a062:	ldr	r3, [r2, #0]
    a064:	adds	r3, #1
    a066:	str	r3, [r2, #0]
    a068:	bx	lr
    a06a:	nop
    a06c:	.word	0x2001cf20

0000a070 <usb_serial_class::clear()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    a070:	b.w	90a4 <usb_serial_flush_input>

0000a074 <usb_serial_class::peek()>:
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    a074:	b.w	9050 <usb_serial_peekchar>

0000a078 <usb_serial_class::read()>:
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    a078:	b.w	9004 <usb_serial_getchar>

0000a07c <usb_serial_class::available()>:
				if (elapsed > 750) break;
			}
		}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    a07c:	b.w	9088 <usb_serial_available>

0000a080 <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    a080:	b.w	9214 <usb_serial_flush_output>

0000a084 <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    a084:	b.w	91cc <usb_serial_write_buffer_free>

0000a088 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    a088:	mov	r0, r1
    a08a:	mov	r1, r2
    a08c:	b.w	90d4 <usb_serial_write>

0000a090 <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    a090:	mov	r0, r1
    a092:	b.w	91b4 <usb_serial_putchar>

0000a096 <Print::write(unsigned char const*, unsigned int)>:

#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
    a096:	push	{r3, r4, r5, r6, r7, lr}
    a098:	mov	r7, r0
	if (buffer == nullptr) return 0;
    a09a:	mov	r5, r1
    a09c:	cbz	r1, a0b6 <Print::write(unsigned char const*, unsigned int)+0x20>
    a09e:	adds	r6, r1, r2
    a0a0:	movs	r4, #0
	size_t count = 0;
	while (size--) count += write(*buffer++);
    a0a2:	cmp	r5, r6
    a0a4:	beq.n	a0ba <Print::write(unsigned char const*, unsigned int)+0x24>
    a0a6:	ldr	r3, [r7, #0]
    a0a8:	ldrb.w	r1, [r5], #1
    a0ac:	ldr	r3, [r3, #0]
    a0ae:	mov	r0, r7
    a0b0:	blx	r3
    a0b2:	add	r4, r0
    a0b4:	b.n	a0a2 <Print::write(unsigned char const*, unsigned int)+0xc>
#include <Arduino.h>


size_t Print::write(const uint8_t *buffer, size_t size)
{
	if (buffer == nullptr) return 0;
    a0b6:	mov	r0, r1
    a0b8:	pop	{r3, r4, r5, r6, r7, pc}
    a0ba:	mov	r0, r4
	size_t count = 0;
	while (size--) count += write(*buffer++);
	return count;
}
    a0bc:	pop	{r3, r4, r5, r6, r7, pc}
    a0be:	Address 0x0000a0be is out of bounds.


0000a0c0 <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    a0c0:	push	{r0, r1, r2, lr}
	uint8_t buf[2]={'\r', '\n'};
    a0c2:	ldr	r3, [pc, #24]	; (a0dc <Print::println()+0x1c>)
    a0c4:	ldrh	r3, [r3, #0]
    a0c6:	strh.w	r3, [sp, #4]
	return write(buf, 2);
    a0ca:	ldr	r3, [r0, #0]
    a0cc:	movs	r2, #2
    a0ce:	ldr	r3, [r3, #4]
    a0d0:	add	r1, sp, #4
    a0d2:	blx	r3
}
    a0d4:	add	sp, #12
    a0d6:	ldr.w	pc, [sp], #4
    a0da:	nop
    a0dc:	.word	0x00012fa8

0000a0e0 <Print::printf(char const*, ...)>:
	return len;
}
}

int Print::printf(const char *format, ...)
{
    a0e0:	push	{r1, r2, r3}
    a0e2:	push	{r0, r1, lr}
    a0e4:	add	r2, sp, #12
    a0e6:	ldr.w	r1, [r2], #4
	va_list ap;
	va_start(ap, format);
    a0ea:	str	r2, [sp, #4]
#ifdef __STRICT_ANSI__
	va_end(ap);
	return 0;  // TODO: make this work with -std=c++0x
#else
	int retval = vdprintf((int)this, format, ap);
    a0ec:	bl	f648 <vdprintf>
	va_end(ap);
	return retval;
#endif
}
    a0f0:	add	sp, #8
    a0f2:	ldr.w	lr, [sp], #4
    a0f6:	add	sp, #12
    a0f8:	bx	lr

0000a0fa <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
}

#else

size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
{
    a0fa:	push	{r4, r5, r6, lr}
    a0fc:	mov	r5, r0
    a0fe:	sub	sp, #40	; 0x28
	uint8_t digit, i;

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
    a100:	cbnz	r2, a10c <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x12>
		return write((uint8_t)n);
    a102:	ldr	r3, [r0, #0]
    a104:	uxtb	r1, r1
    a106:	ldr	r3, [r3, #0]
    a108:	blx	r3
    a10a:	b.n	a16c <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x72>
	} else if (base == 1) {
		base = 10;
    a10c:	cmp	r2, #1
    a10e:	it	eq
    a110:	moveq	r2, #10
	}


	if (n == 0) {
    a112:	cbz	r1, a118 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x1e>
    a114:	movs	r0, #33	; 0x21
    a116:	b.n	a122 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x28>
		buf[sizeof(buf) - 1] = '0';
    a118:	movs	r2, #48	; 0x30
    a11a:	strb.w	r2, [sp, #37]	; 0x25
		i = sizeof(buf) - 1;
    a11e:	movs	r0, #33	; 0x21
    a120:	b.n	a14c <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x52>
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    a122:	udiv	r6, r1, r2
    a126:	mls	r1, r2, r6, r1
    a12a:	uxtb	r4, r1
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a12c:	cmp	r1, #9
    a12e:	ite	ls
    a130:	addls.w	r1, r4, #48	; 0x30
    a134:	addhi.w	r1, r4, #55	; 0x37
    a138:	add	r4, sp, #40	; 0x28
    a13a:	add	r4, r0
    a13c:	uxtb	r1, r1
    a13e:	strb.w	r1, [r4, #-36]
			n /= base;
			if (n == 0) break;
    a142:	mov	r1, r6
    a144:	cbz	r6, a14c <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x52>
			i--;
    a146:	subs	r0, #1
    a148:	uxtb	r0, r0
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
    a14a:	b.n	a122 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x28>
			n /= base;
			if (n == 0) break;
			i--;
		}
	}
	if (sign) {
    a14c:	cbz	r3, a15c <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x62>
		i--;
    a14e:	subs	r0, #1
    a150:	uxtb	r0, r0
		buf[i] = '-';
    a152:	add	r3, sp, #40	; 0x28
    a154:	add	r3, r0
    a156:	movs	r2, #45	; 0x2d
    a158:	strb.w	r2, [r3, #-36]
	}
	return write(buf + i, sizeof(buf) - i);
    a15c:	ldr	r3, [r5, #0]
    a15e:	add	r1, sp, #4
    a160:	rsb	r2, r0, #34	; 0x22
    a164:	add	r1, r0
    a166:	ldr	r3, [r3, #4]
    a168:	mov	r0, r5
    a16a:	blx	r3
}
    a16c:	add	sp, #40	; 0x28
    a16e:	pop	{r4, r5, r6, pc}

0000a170 <Print::print(long)>:

size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
    a170:	cmp	r1, #0
		sign = '-';
		n = -n;
    a172:	itte	lt
    a174:	neglt	r1, r1
size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
		sign = '-';
    a176:	movlt	r3, #45	; 0x2d
}


size_t Print::print(long n)
{
	uint8_t sign=0;
    a178:	movge	r3, #0

	if (n < 0) {
		sign = '-';
		n = -n;
	}
	return printNumber(n, 10, sign);
    a17a:	movs	r2, #10
    a17c:	b.w	a0fa <Print::printNumber(unsigned long, unsigned char, unsigned char)>

0000a180 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)>:
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
    a180:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    a184:	sub	sp, #72	; 0x48
    a186:	mov	r5, r0
    a188:	ldrb.w	r8, [sp, #104]	; 0x68
    a18c:	ldrb.w	sl, [sp, #108]	; 0x6c
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    a190:	cmp.w	r8, #1
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
    a194:	mov	r6, r2
    a196:	mov	r7, r3
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    a198:	bls.n	a21e <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x9e>
	if (n == 0) {
    a19a:	orrs.w	r3, r6, r7
    a19e:	beq.n	a1ac <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x2c>
    a1a0:	movs	r4, #65	; 0x41
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    a1a2:	uxtb.w	r8, r8
    a1a6:	mov.w	r9, #0
    a1aa:	b.n	a1b6 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x36>
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    a1ac:	movs	r3, #48	; 0x30
    a1ae:	strb.w	r3, [sp, #69]	; 0x45
		i = sizeof(buf) - 1;
    a1b2:	movs	r4, #65	; 0x41
    a1b4:	b.n	a1f8 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x78>
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    a1b6:	mov	r0, r6
    a1b8:	mov	r1, r7
    a1ba:	mov	r2, r8
    a1bc:	mov	r3, r9
    a1be:	bl	ae4c <__aeabi_uldivmod>
    a1c2:	mov	r1, r3
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a1c4:	cmp	r1, #0
    a1c6:	it	eq
    a1c8:	cmpeq	r2, #10
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    a1ca:	uxtb	r3, r2
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a1cc:	add	r2, sp, #72	; 0x48
    a1ce:	ite	cc
    a1d0:	addcc	r3, #48	; 0x30
    a1d2:	addcs	r3, #55	; 0x37
    a1d4:	add	r2, r4
    a1d6:	uxtb	r3, r3
    a1d8:	strb.w	r3, [r2, #-68]
			n /= base;
    a1dc:	mov	r0, r6
    a1de:	mov	r3, r9
    a1e0:	mov	r1, r7
    a1e2:	mov	r2, r8
    a1e4:	bl	ae4c <__aeabi_uldivmod>
    a1e8:	mov	r6, r0
    a1ea:	mov	r7, r1
			if (n == 0) break;
    a1ec:	orrs.w	r3, r6, r7
    a1f0:	beq.n	a1f8 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x78>
			i--;
    a1f2:	subs	r4, #1
    a1f4:	uxtb	r4, r4
	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
    a1f6:	b.n	a1b6 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x36>
			n /= base;
			if (n == 0) break;
			i--;
		}
	}
	if (sign) {
    a1f8:	cmp.w	sl, #0
    a1fc:	beq.n	a20c <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0x8c>
		i--;
    a1fe:	subs	r4, #1
    a200:	uxtb	r4, r4
		buf[i] = '-';
    a202:	add	r3, sp, #72	; 0x48
    a204:	add	r3, r4
    a206:	movs	r2, #45	; 0x2d
    a208:	strb.w	r2, [r3, #-68]
	}
	return write(buf + i, sizeof(buf) - i);
    a20c:	ldr	r3, [r5, #0]
    a20e:	add	r1, sp, #4
    a210:	ldr	r3, [r3, #4]
    a212:	rsb	r2, r4, #66	; 0x42
    a216:	add	r1, r4
    a218:	mov	r0, r5
    a21a:	blx	r3
    a21c:	b.n	a220 <Print::printNumber64(unsigned long long, unsigned char, unsigned char)+0xa0>
size_t Print::printNumber64(uint64_t n, uint8_t base, uint8_t sign)
{
	uint8_t buf[66];
	uint8_t digit, i;

	if (base < 2) return 0;
    a21e:	movs	r0, #0
	if (sign) {
		i--;
		buf[i] = '-';
	}
	return write(buf + i, sizeof(buf) - i);
}
    a220:	add	sp, #72	; 0x48
    a222:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000a226 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    a226:	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    a228:	bl	710 <setup>
	while (1) {
		loop();
    a22c:	bl	794 <loop>
		yield();
    a230:	bl	9e58 <yield>
    a234:	b.n	a22c <main+0x6>
    a236:	Address 0x0000a236 is out of bounds.


0000a238 <Stream::timedRead()>:
#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field

// private method to read stream with timeout
int Stream::timedRead()
{
    a238:	push	{r0, r1, r4, r5, r6, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    a23a:	ldr	r3, [pc, #48]	; (a26c <Stream::timedRead()+0x34>)
    a23c:	ldr	r2, [r3, #0]
    a23e:	str	r2, [sp, #0]
	return ret;
    a240:	ldr	r6, [sp, #0]
    a242:	mov	r4, r0
    a244:	mov	r5, r3
  int c;
  unsigned long startMillis = millis();
  do {
    c = read();
    a246:	ldr	r3, [r4, #0]
    a248:	mov	r0, r4
    a24a:	ldr	r3, [r3, #20]
    a24c:	blx	r3
    if (c >= 0) return c;
    a24e:	cmp	r0, #0
    a250:	bge.n	a268 <Stream::timedRead()+0x30>
    yield();
    a252:	bl	9e58 <yield>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    a256:	ldr	r3, [r5, #0]
    a258:	str	r3, [sp, #4]
	return ret;
    a25a:	ldr	r3, [sp, #4]
// private method to read stream with timeout
int Stream::timedRead()
{
  int c;
  unsigned long startMillis = millis();
  do {
    a25c:	ldr	r2, [r4, #8]
    a25e:	subs	r3, r3, r6
    a260:	cmp	r3, r2
    a262:	bcc.n	a246 <Stream::timedRead()+0xe>
    c = read();
    if (c >= 0) return c;
    yield();
  } while(millis() - startMillis < _timeout);
  return -1;     // -1 indicates timeout
    a264:	mov.w	r0, #4294967295
}
    a268:	add	sp, #8
    a26a:	pop	{r4, r5, r6, pc}
    a26c:	.word	0x2001cf20

0000a270 <Stream::readBytesUntil(char, char*, unsigned int)>:
// as readBytes with terminator character
// terminates if length characters have been read, timeout, or if the terminator character  detected
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
    a270:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    a274:	mov	r7, r0
    a276:	mov	r9, r1
	if (buffer == nullptr) return 0;
    a278:	mov	r5, r2
    a27a:	cbz	r2, a2aa <Stream::readBytesUntil(char, char*, unsigned int)+0x3a>
	if (length < 1) return 0;
    a27c:	cbz	r3, a2ae <Stream::readBytesUntil(char, char*, unsigned int)+0x3e>
	length--;
    a27e:	add.w	r8, r3, #4294967295
    a282:	mov	r6, r2
    a284:	subs	r4, r6, r5
	size_t index = 0;
	while (index < length) {
    a286:	cmp	r8, r4
    a288:	bls.n	a2a4 <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
		int c = timedRead();
    a28a:	mov	r0, r7
    a28c:	bl	a238 <Stream::timedRead()>
		if (c == terminator) break;
    a290:	cmp	r0, r9
    a292:	beq.n	a2a4 <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
		if (c < 0) {
    a294:	cmp	r0, #0
    a296:	bge.n	a29e <Stream::readBytesUntil(char, char*, unsigned int)+0x2e>
	String readString(size_t max = 120);
	String readStringUntil(char terminator, size_t max = 120);
	int getReadError() { return read_error; }
	void clearReadError() { setReadError(0); }
  protected:
	void setReadError(int err = 1) { read_error = err; }
    a298:	movs	r3, #1
    a29a:	strb	r3, [r7, #12]
    a29c:	b.n	a2a4 <Stream::readBytesUntil(char, char*, unsigned int)+0x34>
			setReadError();
			break;
		}
		*buffer++ = (char)c;
    a29e:	strb.w	r0, [r6], #1
{
	if (buffer == nullptr) return 0;
	if (length < 1) return 0;
	length--;
	size_t index = 0;
	while (index < length) {
    a2a2:	b.n	a284 <Stream::readBytesUntil(char, char*, unsigned int)+0x14>
			break;
		}
		*buffer++ = (char)c;
		index++;
	}
	*buffer = 0;
    a2a4:	movs	r3, #0
    a2a6:	strb	r3, [r6, #0]
	return index; // return number of characters, not including null terminator
    a2a8:	b.n	a2b0 <Stream::readBytesUntil(char, char*, unsigned int)+0x40>
// terminates if length characters have been read, timeout, or if the terminator character  detected
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
	if (buffer == nullptr) return 0;
    a2aa:	mov	r4, r2
    a2ac:	b.n	a2b0 <Stream::readBytesUntil(char, char*, unsigned int)+0x40>
    a2ae:	mov	r4, r3
		*buffer++ = (char)c;
		index++;
	}
	*buffer = 0;
	return index; // return number of characters, not including null terminator
}
    a2b0:	mov	r0, r4
    a2b2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0000a2b6 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    a2b6:	bx	lr

0000a2b8 <operator new(unsigned int)>:
    a2b8:	b.w	b21c <malloc>

0000a2bc <operator delete(void*, unsigned int)>:
    a2bc:	b.w	b22c <free>

0000a2c0 <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    a2c0:	push	{r4, lr}
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    a2c2:	ldr	r3, [pc, #128]	; (a344 <analog_init+0x84>)
    a2c4:	ldr	r0, [pc, #128]	; (a348 <analog_init+0x88>)
    a2c6:	ldr	r1, [pc, #132]	; (a34c <analog_init+0x8c>)
    a2c8:	movs	r2, #96	; 0x60
    a2ca:	strb	r2, [r3, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    a2cc:	movs	r2, #225	; 0xe1
    a2ce:	strb	r2, [r3, #1]
	#endif

	if (analog_config_bits == 8) {
    a2d0:	ldr	r3, [pc, #124]	; (a350 <analog_init+0x90>)
    a2d2:	ldr	r2, [pc, #128]	; (a354 <analog_init+0x94>)
    a2d4:	ldrb	r4, [r3, #0]
    a2d6:	ldr	r3, [pc, #128]	; (a358 <analog_init+0x98>)
    a2d8:	cmp	r4, #8
    a2da:	bne.n	a2e0 <analog_init+0x20>
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    a2dc:	movs	r4, #1
    a2de:	b.n	a2e6 <analog_init+0x26>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    a2e0:	cmp	r4, #10
    a2e2:	bne.n	a2ec <analog_init+0x2c>
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    a2e4:	movs	r4, #57	; 0x39
    a2e6:	str	r4, [r0, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    a2e8:	movs	r0, #19
    a2ea:	b.n	a2f8 <analog_init+0x38>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    a2ec:	cmp	r4, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    a2ee:	ite	eq
    a2f0:	moveq	r4, #53	; 0x35
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    a2f2:	movne	r4, #61	; 0x3d
    a2f4:	str	r4, [r0, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    a2f6:	movs	r0, #18
    a2f8:	str	r0, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    a2fa:	str	r4, [r2, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    a2fc:	str	r0, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    a2fe:	ldr	r3, [pc, #92]	; (a35c <analog_init+0x9c>)
    a300:	ldr	r1, [pc, #92]	; (a360 <analog_init+0xa0>)
    a302:	ldrb	r3, [r3, #0]
    a304:	ldr	r2, [pc, #92]	; (a364 <analog_init+0xa4>)
    a306:	cbz	r3, a30a <analog_init+0x4a>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    a308:	movs	r3, #1
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    a30a:	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    a30c:	str	r3, [r2, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    a30e:	ldr	r3, [pc, #88]	; (a368 <analog_init+0xa8>)
    a310:	ldr	r2, [pc, #88]	; (a36c <analog_init+0xac>)
    a312:	ldrb	r1, [r3, #0]
    a314:	ldr	r3, [pc, #88]	; (a370 <analog_init+0xb0>)
	if (num <= 1) {
    a316:	cmp	r1, #1
    a318:	bhi.n	a31e <analog_init+0x5e>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    a31a:	movs	r1, #128	; 0x80
    a31c:	b.n	a336 <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    a31e:	cmp	r1, #4
    a320:	bhi.n	a326 <analog_init+0x66>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    a322:	movs	r1, #132	; 0x84
    a324:	b.n	a336 <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    a326:	cmp	r1, #8
    a328:	bhi.n	a32e <analog_init+0x6e>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    a32a:	movs	r1, #133	; 0x85
    a32c:	b.n	a336 <analog_init+0x76>
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    a32e:	cmp	r1, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    a330:	ite	ls
    a332:	movls	r1, #134	; 0x86
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    a334:	movhi	r1, #135	; 0x87
    a336:	str	r1, [r2, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    a338:	str	r1, [r3, #0]
		#endif
	}
	calibrating = 1;
    a33a:	ldr	r3, [pc, #56]	; (a374 <analog_init+0xb4>)
    a33c:	movs	r2, #1
    a33e:	strb	r2, [r3, #0]
    a340:	pop	{r4, pc}
    a342:	nop
    a344:	.word	0x40074000
    a348:	.word	0x4003b008
    a34c:	.word	0x4003b00c
    a350:	.word	0x1fff137d
    a354:	.word	0x400bb008
    a358:	.word	0x400bb00c
    a35c:	.word	0x2001d036
    a360:	.word	0x4003b020
    a364:	.word	0x400bb020
    a368:	.word	0x1fff137e
    a36c:	.word	0x4003b024
    a370:	.word	0x400bb024
    a374:	.word	0x2001d035

0000a378 <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    a378:	push	{r0, r1, r2, r3, r4, lr}
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    a37a:	cpsid	i
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    a37c:	ldr	r3, [pc, #76]	; (a3cc <usb_init_serialnumber+0x54>)
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    a37e:	ldr	r1, [pc, #80]	; (a3d0 <usb_init_serialnumber+0x58>)
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    a380:	movs	r2, #112	; 0x70
    a382:	strb	r2, [r3, #0]
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    a384:	ldr	r2, [pc, #76]	; (a3d4 <usb_init_serialnumber+0x5c>)
    a386:	str	r1, [r2, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    a388:	movs	r2, #128	; 0x80
    a38a:	strb	r2, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    a38c:	ldrb	r2, [r3, #0]
    a38e:	lsls	r2, r2, #24
    a390:	bpl.n	a38c <usb_init_serialnumber+0x14>
	num = *(uint32_t *)&FTFL_FCCOBB;
    a392:	ldr	r3, [pc, #68]	; (a3d8 <usb_init_serialnumber+0x60>)
    a394:	ldr	r0, [r3, #0]
	kinetis_hsrun_enable();
#endif
	__enable_irq();
    a396:	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    a398:	ldr	r3, [pc, #64]	; (a3dc <usb_init_serialnumber+0x64>)
    a39a:	cmp	r0, r3
    a39c:	it	ls
    a39e:	movls	r3, #10
	ultoa(num, buf, 10);
    a3a0:	add	r4, sp, #4
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    a3a2:	it	ls
    a3a4:	mulls	r0, r3
	ultoa(num, buf, 10);
    a3a6:	movs	r2, #10
    a3a8:	mov	r1, r4
    a3aa:	bl	a3e8 <ultoa>
    a3ae:	ldr	r2, [pc, #48]	; (a3e0 <usb_init_serialnumber+0x68>)
	for (i=0; i<10; i++) {
    a3b0:	movs	r3, #0
		char c = buf[i];
    a3b2:	ldrb	r1, [r4, r3]
		if (!c) break;
    a3b4:	cbz	r1, a3c0 <usb_init_serialnumber+0x48>
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    a3b6:	adds	r3, #1
    a3b8:	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    a3ba:	strh.w	r1, [r2], #2
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    a3be:	bne.n	a3b2 <usb_init_serialnumber+0x3a>
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    a3c0:	ldr	r2, [pc, #32]	; (a3e4 <usb_init_serialnumber+0x6c>)
    a3c2:	adds	r3, #1
    a3c4:	lsls	r3, r3, #1
    a3c6:	strb	r3, [r2, #0]
}
    a3c8:	add	sp, #16
    a3ca:	pop	{r4, pc}
    a3cc:	.word	0x40020000
    a3d0:	.word	0x41070000
    a3d4:	.word	0x40020004
    a3d8:	.word	0x4002000c
    a3dc:	.word	0x0098967f
    a3e0:	.word	0x1fff140a
    a3e4:	.word	0x1fff1408

0000a3e8 <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    a3e8:	push	{r4, r5, lr}
    a3ea:	mov	r3, r0
	unsigned digit;
	int i=0, j;
    a3ec:	movs	r0, #0
	char t;

	while (1) {
		digit = val % radix;
    a3ee:	udiv	r4, r3, r2
    a3f2:	mls	r3, r2, r4, r3
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a3f6:	cmp	r3, #9
    a3f8:	ite	ls
    a3fa:	addls	r3, #48	; 0x30
    a3fc:	addhi	r3, #55	; 0x37
    a3fe:	uxtb	r3, r3
    a400:	strb	r3, [r1, r0]
		val /= radix;
		if (val == 0) break;
    a402:	mov	r3, r4
    a404:	cbz	r4, a40a <ultoa+0x22>
		i++;
    a406:	adds	r0, #1
	}
    a408:	b.n	a3ee <ultoa+0x6>
	buf[i + 1] = 0;
    a40a:	adds	r2, r1, r0
	for (j=0; j < i; j++, i--) {
    a40c:	mov	r3, r4
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
    a40e:	strb	r4, [r2, #1]
	for (j=0; j < i; j++, i--) {
    a410:	subs	r4, r0, r3
    a412:	cmp	r3, r4
    a414:	bge.n	a424 <ultoa+0x3c>
		t = buf[j];
    a416:	ldrb	r4, [r1, r3]
		buf[j] = buf[i];
    a418:	ldrb	r5, [r2, #0]
    a41a:	strb	r5, [r1, r3]
		buf[i] = t;
    a41c:	strb.w	r4, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    a420:	adds	r3, #1
    a422:	b.n	a410 <ultoa+0x28>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    a424:	mov	r0, r1
    a426:	pop	{r4, r5, pc}

0000a428 <__aeabi_atexit>:
    a428:	mov	r3, r1
    a42a:	mov	r1, r0
    a42c:	mov	r0, r3
    a42e:	b.w	b164 <__cxa_atexit>
    a432:	nop

0000a434 <__aeabi_llsr>:
    a434:	lsrs	r0, r2
    a436:	adds	r3, r1, #0
    a438:	lsrs	r1, r2
    a43a:	mov	ip, r3
    a43c:	subs	r2, #32
    a43e:	lsrs	r3, r2
    a440:	orrs	r0, r3
    a442:	negs	r2, r2
    a444:	mov	r3, ip
    a446:	lsls	r3, r2
    a448:	orrs	r0, r3
    a44a:	bx	lr

0000a44c <__aeabi_drsub>:
    a44c:	eor.w	r1, r1, #2147483648	; 0x80000000
    a450:	b.n	a458 <__adddf3>
    a452:	nop

0000a454 <__aeabi_dsub>:
    a454:	eor.w	r3, r3, #2147483648	; 0x80000000

0000a458 <__adddf3>:
    a458:	push	{r4, r5, lr}
    a45a:	mov.w	r4, r1, lsl #1
    a45e:	mov.w	r5, r3, lsl #1
    a462:	teq	r4, r5
    a466:	it	eq
    a468:	teqeq	r0, r2
    a46c:	itttt	ne
    a46e:	orrsne.w	ip, r4, r0
    a472:	orrsne.w	ip, r5, r2
    a476:	mvnsne.w	ip, r4, asr #21
    a47a:	mvnsne.w	ip, r5, asr #21
    a47e:	beq.w	a646 <__adddf3+0x1ee>
    a482:	mov.w	r4, r4, lsr #21
    a486:	rsbs	r5, r4, r5, lsr #21
    a48a:	it	lt
    a48c:	neglt	r5, r5
    a48e:	ble.n	a4aa <__adddf3+0x52>
    a490:	add	r4, r5
    a492:	eor.w	r2, r0, r2
    a496:	eor.w	r3, r1, r3
    a49a:	eor.w	r0, r2, r0
    a49e:	eor.w	r1, r3, r1
    a4a2:	eor.w	r2, r0, r2
    a4a6:	eor.w	r3, r1, r3
    a4aa:	cmp	r5, #54	; 0x36
    a4ac:	it	hi
    a4ae:	pophi	{r4, r5, pc}
    a4b0:	tst.w	r1, #2147483648	; 0x80000000
    a4b4:	mov.w	r1, r1, lsl #12
    a4b8:	mov.w	ip, #1048576	; 0x100000
    a4bc:	orr.w	r1, ip, r1, lsr #12
    a4c0:	beq.n	a4c8 <__adddf3+0x70>
    a4c2:	negs	r0, r0
    a4c4:	sbc.w	r1, r1, r1, lsl #1
    a4c8:	tst.w	r3, #2147483648	; 0x80000000
    a4cc:	mov.w	r3, r3, lsl #12
    a4d0:	orr.w	r3, ip, r3, lsr #12
    a4d4:	beq.n	a4dc <__adddf3+0x84>
    a4d6:	negs	r2, r2
    a4d8:	sbc.w	r3, r3, r3, lsl #1
    a4dc:	teq	r4, r5
    a4e0:	beq.w	a632 <__adddf3+0x1da>
    a4e4:	sub.w	r4, r4, #1
    a4e8:	rsbs	lr, r5, #32
    a4ec:	blt.n	a50a <__adddf3+0xb2>
    a4ee:	lsl.w	ip, r2, lr
    a4f2:	lsr.w	r2, r2, r5
    a4f6:	adds	r0, r0, r2
    a4f8:	adc.w	r1, r1, #0
    a4fc:	lsl.w	r2, r3, lr
    a500:	adds	r0, r0, r2
    a502:	asr.w	r3, r3, r5
    a506:	adcs	r1, r3
    a508:	b.n	a528 <__adddf3+0xd0>
    a50a:	sub.w	r5, r5, #32
    a50e:	add.w	lr, lr, #32
    a512:	cmp	r2, #1
    a514:	lsl.w	ip, r3, lr
    a518:	it	cs
    a51a:	orrcs.w	ip, ip, #2
    a51e:	asr.w	r3, r3, r5
    a522:	adds	r0, r0, r3
    a524:	adcs.w	r1, r1, r3, asr #31
    a528:	and.w	r5, r1, #2147483648	; 0x80000000
    a52c:	bpl.n	a53e <__adddf3+0xe6>
    a52e:	mov.w	lr, #0
    a532:	rsbs	ip, ip, #0
    a536:	sbcs.w	r0, lr, r0
    a53a:	sbc.w	r1, lr, r1
    a53e:	cmp.w	r1, #1048576	; 0x100000
    a542:	bcc.n	a57c <__adddf3+0x124>
    a544:	cmp.w	r1, #2097152	; 0x200000
    a548:	bcc.n	a564 <__adddf3+0x10c>
    a54a:	lsrs	r1, r1, #1
    a54c:	movs.w	r0, r0, rrx
    a550:	mov.w	ip, ip, rrx
    a554:	add.w	r4, r4, #1
    a558:	mov.w	r2, r4, lsl #21
    a55c:	cmn.w	r2, #4194304	; 0x400000
    a560:	bcs.w	a698 <__adddf3+0x240>
    a564:	cmp.w	ip, #2147483648	; 0x80000000
    a568:	it	eq
    a56a:	movseq.w	ip, r0, lsr #1
    a56e:	adcs.w	r0, r0, #0
    a572:	adc.w	r1, r1, r4, lsl #20
    a576:	orr.w	r1, r1, r5
    a57a:	pop	{r4, r5, pc}
    a57c:	movs.w	ip, ip, lsl #1
    a580:	adcs	r0, r0
    a582:	adc.w	r1, r1, r1
    a586:	tst.w	r1, #1048576	; 0x100000
    a58a:	sub.w	r4, r4, #1
    a58e:	bne.n	a564 <__adddf3+0x10c>
    a590:	teq	r1, #0
    a594:	itt	eq
    a596:	moveq	r1, r0
    a598:	moveq	r0, #0
    a59a:	clz	r3, r1
    a59e:	it	eq
    a5a0:	addeq	r3, #32
    a5a2:	sub.w	r3, r3, #11
    a5a6:	subs.w	r2, r3, #32
    a5aa:	bge.n	a5c6 <__adddf3+0x16e>
    a5ac:	adds	r2, #12
    a5ae:	ble.n	a5c2 <__adddf3+0x16a>
    a5b0:	add.w	ip, r2, #20
    a5b4:	rsb	r2, r2, #12
    a5b8:	lsl.w	r0, r1, ip
    a5bc:	lsr.w	r1, r1, r2
    a5c0:	b.n	a5dc <__adddf3+0x184>
    a5c2:	add.w	r2, r2, #20
    a5c6:	it	le
    a5c8:	rsble	ip, r2, #32
    a5cc:	lsl.w	r1, r1, r2
    a5d0:	lsr.w	ip, r0, ip
    a5d4:	itt	le
    a5d6:	orrle.w	r1, r1, ip
    a5da:	lslle	r0, r2
    a5dc:	subs	r4, r4, r3
    a5de:	ittt	ge
    a5e0:	addge.w	r1, r1, r4, lsl #20
    a5e4:	orrge	r1, r5
    a5e6:	popge	{r4, r5, pc}
    a5e8:	mvn.w	r4, r4
    a5ec:	subs	r4, #31
    a5ee:	bge.n	a62a <__adddf3+0x1d2>
    a5f0:	adds	r4, #12
    a5f2:	bgt.n	a612 <__adddf3+0x1ba>
    a5f4:	add.w	r4, r4, #20
    a5f8:	rsb	r2, r4, #32
    a5fc:	lsr.w	r0, r0, r4
    a600:	lsl.w	r3, r1, r2
    a604:	orr.w	r0, r0, r3
    a608:	lsr.w	r3, r1, r4
    a60c:	orr.w	r1, r5, r3
    a610:	pop	{r4, r5, pc}
    a612:	rsb	r4, r4, #12
    a616:	rsb	r2, r4, #32
    a61a:	lsr.w	r0, r0, r2
    a61e:	lsl.w	r3, r1, r4
    a622:	orr.w	r0, r0, r3
    a626:	mov	r1, r5
    a628:	pop	{r4, r5, pc}
    a62a:	lsr.w	r0, r1, r4
    a62e:	mov	r1, r5
    a630:	pop	{r4, r5, pc}
    a632:	teq	r4, #0
    a636:	eor.w	r3, r3, #1048576	; 0x100000
    a63a:	itte	eq
    a63c:	eoreq.w	r1, r1, #1048576	; 0x100000
    a640:	addeq	r4, #1
    a642:	subne	r5, #1
    a644:	b.n	a4e4 <__adddf3+0x8c>
    a646:	mvns.w	ip, r4, asr #21
    a64a:	it	ne
    a64c:	mvnsne.w	ip, r5, asr #21
    a650:	beq.n	a6a6 <__adddf3+0x24e>
    a652:	teq	r4, r5
    a656:	it	eq
    a658:	teqeq	r0, r2
    a65c:	beq.n	a66a <__adddf3+0x212>
    a65e:	orrs.w	ip, r4, r0
    a662:	itt	eq
    a664:	moveq	r1, r3
    a666:	moveq	r0, r2
    a668:	pop	{r4, r5, pc}
    a66a:	teq	r1, r3
    a66e:	ittt	ne
    a670:	movne	r1, #0
    a672:	movne	r0, #0
    a674:	popne	{r4, r5, pc}
    a676:	movs.w	ip, r4, lsr #21
    a67a:	bne.n	a688 <__adddf3+0x230>
    a67c:	lsls	r0, r0, #1
    a67e:	adcs	r1, r1
    a680:	it	cs
    a682:	orrcs.w	r1, r1, #2147483648	; 0x80000000
    a686:	pop	{r4, r5, pc}
    a688:	adds.w	r4, r4, #4194304	; 0x400000
    a68c:	itt	cc
    a68e:	addcc.w	r1, r1, #1048576	; 0x100000
    a692:	popcc	{r4, r5, pc}
    a694:	and.w	r5, r1, #2147483648	; 0x80000000
    a698:	orr.w	r1, r5, #2130706432	; 0x7f000000
    a69c:	orr.w	r1, r1, #15728640	; 0xf00000
    a6a0:	mov.w	r0, #0
    a6a4:	pop	{r4, r5, pc}
    a6a6:	mvns.w	ip, r4, asr #21
    a6aa:	itte	ne
    a6ac:	movne	r1, r3
    a6ae:	movne	r0, r2
    a6b0:	mvnseq.w	ip, r5, asr #21
    a6b4:	itt	ne
    a6b6:	movne	r3, r1
    a6b8:	movne	r2, r0
    a6ba:	orrs.w	r4, r0, r1, lsl #12
    a6be:	itte	eq
    a6c0:	orrseq.w	r5, r2, r3, lsl #12
    a6c4:	teqeq	r1, r3
    a6c8:	orrne.w	r1, r1, #524288	; 0x80000
    a6cc:	pop	{r4, r5, pc}
    a6ce:	nop

0000a6d0 <__aeabi_ui2d>:
    a6d0:	teq	r0, #0
    a6d4:	itt	eq
    a6d6:	moveq	r1, #0
    a6d8:	bxeq	lr
    a6da:	push	{r4, r5, lr}
    a6dc:	mov.w	r4, #1024	; 0x400
    a6e0:	add.w	r4, r4, #50	; 0x32
    a6e4:	mov.w	r5, #0
    a6e8:	mov.w	r1, #0
    a6ec:	b.n	a590 <__adddf3+0x138>
    a6ee:	nop

0000a6f0 <__aeabi_i2d>:
    a6f0:	teq	r0, #0
    a6f4:	itt	eq
    a6f6:	moveq	r1, #0
    a6f8:	bxeq	lr
    a6fa:	push	{r4, r5, lr}
    a6fc:	mov.w	r4, #1024	; 0x400
    a700:	add.w	r4, r4, #50	; 0x32
    a704:	ands.w	r5, r0, #2147483648	; 0x80000000
    a708:	it	mi
    a70a:	negmi	r0, r0
    a70c:	mov.w	r1, #0
    a710:	b.n	a590 <__adddf3+0x138>
    a712:	nop

0000a714 <__aeabi_f2d>:
    a714:	lsls	r2, r0, #1
    a716:	mov.w	r1, r2, asr #3
    a71a:	mov.w	r1, r1, rrx
    a71e:	mov.w	r0, r2, lsl #28
    a722:	itttt	ne
    a724:	andsne.w	r3, r2, #4278190080	; 0xff000000
    a728:	teqne	r3, #4278190080	; 0xff000000
    a72c:	eorne.w	r1, r1, #939524096	; 0x38000000
    a730:	bxne	lr
    a732:	teq	r2, #0
    a736:	ite	ne
    a738:	teqne	r3, #4278190080	; 0xff000000
    a73c:	bxeq	lr
    a73e:	push	{r4, r5, lr}
    a740:	mov.w	r4, #896	; 0x380
    a744:	and.w	r5, r1, #2147483648	; 0x80000000
    a748:	bic.w	r1, r1, #2147483648	; 0x80000000
    a74c:	b.n	a590 <__adddf3+0x138>
    a74e:	nop

0000a750 <__aeabi_ul2d>:
    a750:	orrs.w	r2, r0, r1
    a754:	it	eq
    a756:	bxeq	lr
    a758:	push	{r4, r5, lr}
    a75a:	mov.w	r5, #0
    a75e:	b.n	a776 <__aeabi_l2d+0x16>

0000a760 <__aeabi_l2d>:
    a760:	orrs.w	r2, r0, r1
    a764:	it	eq
    a766:	bxeq	lr
    a768:	push	{r4, r5, lr}
    a76a:	ands.w	r5, r1, #2147483648	; 0x80000000
    a76e:	bpl.n	a776 <__aeabi_l2d+0x16>
    a770:	negs	r0, r0
    a772:	sbc.w	r1, r1, r1, lsl #1
    a776:	mov.w	r4, #1024	; 0x400
    a77a:	add.w	r4, r4, #50	; 0x32
    a77e:	movs.w	ip, r1, lsr #22
    a782:	beq.w	a53e <__adddf3+0xe6>
    a786:	mov.w	r2, #3
    a78a:	movs.w	ip, ip, lsr #3
    a78e:	it	ne
    a790:	addne	r2, #3
    a792:	movs.w	ip, ip, lsr #3
    a796:	it	ne
    a798:	addne	r2, #3
    a79a:	add.w	r2, r2, ip, lsr #3
    a79e:	rsb	r3, r2, #32
    a7a2:	lsl.w	ip, r0, r3
    a7a6:	lsr.w	r0, r0, r2
    a7aa:	lsl.w	lr, r1, r3
    a7ae:	orr.w	r0, r0, lr
    a7b2:	lsr.w	r1, r1, r2
    a7b6:	add	r4, r2
    a7b8:	b.n	a53e <__adddf3+0xe6>
    a7ba:	nop

0000a7bc <__aeabi_dmul>:
    a7bc:	push	{r4, r5, r6, lr}
    a7be:	mov.w	ip, #255	; 0xff
    a7c2:	orr.w	ip, ip, #1792	; 0x700
    a7c6:	ands.w	r4, ip, r1, lsr #20
    a7ca:	ittte	ne
    a7cc:	andsne.w	r5, ip, r3, lsr #20
    a7d0:	teqne	r4, ip
    a7d4:	teqne	r5, ip
    a7d8:	bleq	a998 <__aeabi_dmul+0x1dc>
    a7dc:	add	r4, r5
    a7de:	eor.w	r6, r1, r3
    a7e2:	bic.w	r1, r1, ip, lsl #21
    a7e6:	bic.w	r3, r3, ip, lsl #21
    a7ea:	orrs.w	r5, r0, r1, lsl #12
    a7ee:	it	ne
    a7f0:	orrsne.w	r5, r2, r3, lsl #12
    a7f4:	orr.w	r1, r1, #1048576	; 0x100000
    a7f8:	orr.w	r3, r3, #1048576	; 0x100000
    a7fc:	beq.n	a870 <__aeabi_dmul+0xb4>
    a7fe:	umull	ip, lr, r0, r2
    a802:	mov.w	r5, #0
    a806:	umlal	lr, r5, r1, r2
    a80a:	and.w	r2, r6, #2147483648	; 0x80000000
    a80e:	umlal	lr, r5, r0, r3
    a812:	mov.w	r6, #0
    a816:	umlal	r5, r6, r1, r3
    a81a:	teq	ip, #0
    a81e:	it	ne
    a820:	orrne.w	lr, lr, #1
    a824:	sub.w	r4, r4, #255	; 0xff
    a828:	cmp.w	r6, #512	; 0x200
    a82c:	sbc.w	r4, r4, #768	; 0x300
    a830:	bcs.n	a83c <__aeabi_dmul+0x80>
    a832:	movs.w	lr, lr, lsl #1
    a836:	adcs	r5, r5
    a838:	adc.w	r6, r6, r6
    a83c:	orr.w	r1, r2, r6, lsl #11
    a840:	orr.w	r1, r1, r5, lsr #21
    a844:	mov.w	r0, r5, lsl #11
    a848:	orr.w	r0, r0, lr, lsr #21
    a84c:	mov.w	lr, lr, lsl #11
    a850:	subs.w	ip, r4, #253	; 0xfd
    a854:	it	hi
    a856:	cmphi.w	ip, #1792	; 0x700
    a85a:	bhi.n	a89a <__aeabi_dmul+0xde>
    a85c:	cmp.w	lr, #2147483648	; 0x80000000
    a860:	it	eq
    a862:	movseq.w	lr, r0, lsr #1
    a866:	adcs.w	r0, r0, #0
    a86a:	adc.w	r1, r1, r4, lsl #20
    a86e:	pop	{r4, r5, r6, pc}
    a870:	and.w	r6, r6, #2147483648	; 0x80000000
    a874:	orr.w	r1, r6, r1
    a878:	orr.w	r0, r0, r2
    a87c:	eor.w	r1, r1, r3
    a880:	subs.w	r4, r4, ip, lsr #1
    a884:	ittt	gt
    a886:	rsbsgt	r5, r4, ip
    a88a:	orrgt.w	r1, r1, r4, lsl #20
    a88e:	popgt	{r4, r5, r6, pc}
    a890:	orr.w	r1, r1, #1048576	; 0x100000
    a894:	mov.w	lr, #0
    a898:	subs	r4, #1
    a89a:	bgt.w	a9f4 <__aeabi_dmul+0x238>
    a89e:	cmn.w	r4, #54	; 0x36
    a8a2:	ittt	le
    a8a4:	movle	r0, #0
    a8a6:	andle.w	r1, r1, #2147483648	; 0x80000000
    a8aa:	pople	{r4, r5, r6, pc}
    a8ac:	rsb	r4, r4, #0
    a8b0:	subs	r4, #32
    a8b2:	bge.n	a920 <__aeabi_dmul+0x164>
    a8b4:	adds	r4, #12
    a8b6:	bgt.n	a8f0 <__aeabi_dmul+0x134>
    a8b8:	add.w	r4, r4, #20
    a8bc:	rsb	r5, r4, #32
    a8c0:	lsl.w	r3, r0, r5
    a8c4:	lsr.w	r0, r0, r4
    a8c8:	lsl.w	r2, r1, r5
    a8cc:	orr.w	r0, r0, r2
    a8d0:	and.w	r2, r1, #2147483648	; 0x80000000
    a8d4:	bic.w	r1, r1, #2147483648	; 0x80000000
    a8d8:	adds.w	r0, r0, r3, lsr #31
    a8dc:	lsr.w	r6, r1, r4
    a8e0:	adc.w	r1, r2, r6
    a8e4:	orrs.w	lr, lr, r3, lsl #1
    a8e8:	it	eq
    a8ea:	biceq.w	r0, r0, r3, lsr #31
    a8ee:	pop	{r4, r5, r6, pc}
    a8f0:	rsb	r4, r4, #12
    a8f4:	rsb	r5, r4, #32
    a8f8:	lsl.w	r3, r0, r4
    a8fc:	lsr.w	r0, r0, r5
    a900:	lsl.w	r2, r1, r4
    a904:	orr.w	r0, r0, r2
    a908:	and.w	r1, r1, #2147483648	; 0x80000000
    a90c:	adds.w	r0, r0, r3, lsr #31
    a910:	adc.w	r1, r1, #0
    a914:	orrs.w	lr, lr, r3, lsl #1
    a918:	it	eq
    a91a:	biceq.w	r0, r0, r3, lsr #31
    a91e:	pop	{r4, r5, r6, pc}
    a920:	rsb	r5, r4, #32
    a924:	lsl.w	r2, r0, r5
    a928:	orr.w	lr, lr, r2
    a92c:	lsr.w	r3, r0, r4
    a930:	lsl.w	r2, r1, r5
    a934:	orr.w	r3, r3, r2
    a938:	lsr.w	r0, r1, r4
    a93c:	and.w	r1, r1, #2147483648	; 0x80000000
    a940:	lsr.w	r2, r1, r4
    a944:	bic.w	r0, r0, r2
    a948:	add.w	r0, r0, r3, lsr #31
    a94c:	orrs.w	lr, lr, r3, lsl #1
    a950:	it	eq
    a952:	biceq.w	r0, r0, r3, lsr #31
    a956:	pop	{r4, r5, r6, pc}
    a958:	teq	r4, #0
    a95c:	bne.n	a97e <__aeabi_dmul+0x1c2>
    a95e:	and.w	r6, r1, #2147483648	; 0x80000000
    a962:	lsls	r0, r0, #1
    a964:	adc.w	r1, r1, r1
    a968:	tst.w	r1, #1048576	; 0x100000
    a96c:	it	eq
    a96e:	subeq	r4, #1
    a970:	beq.n	a962 <__aeabi_dmul+0x1a6>
    a972:	orr.w	r1, r1, r6
    a976:	teq	r5, #0
    a97a:	it	ne
    a97c:	bxne	lr
    a97e:	and.w	r6, r3, #2147483648	; 0x80000000
    a982:	lsls	r2, r2, #1
    a984:	adc.w	r3, r3, r3
    a988:	tst.w	r3, #1048576	; 0x100000
    a98c:	it	eq
    a98e:	subeq	r5, #1
    a990:	beq.n	a982 <__aeabi_dmul+0x1c6>
    a992:	orr.w	r3, r3, r6
    a996:	bx	lr
    a998:	teq	r4, ip
    a99c:	and.w	r5, ip, r3, lsr #20
    a9a0:	it	ne
    a9a2:	teqne	r5, ip
    a9a6:	beq.n	a9c2 <__aeabi_dmul+0x206>
    a9a8:	orrs.w	r6, r0, r1, lsl #1
    a9ac:	it	ne
    a9ae:	orrsne.w	r6, r2, r3, lsl #1
    a9b2:	bne.n	a958 <__aeabi_dmul+0x19c>
    a9b4:	eor.w	r1, r1, r3
    a9b8:	and.w	r1, r1, #2147483648	; 0x80000000
    a9bc:	mov.w	r0, #0
    a9c0:	pop	{r4, r5, r6, pc}
    a9c2:	orrs.w	r6, r0, r1, lsl #1
    a9c6:	itte	eq
    a9c8:	moveq	r0, r2
    a9ca:	moveq	r1, r3
    a9cc:	orrsne.w	r6, r2, r3, lsl #1
    a9d0:	beq.n	aa06 <__aeabi_dmul+0x24a>
    a9d2:	teq	r4, ip
    a9d6:	bne.n	a9de <__aeabi_dmul+0x222>
    a9d8:	orrs.w	r6, r0, r1, lsl #12
    a9dc:	bne.n	aa06 <__aeabi_dmul+0x24a>
    a9de:	teq	r5, ip
    a9e2:	bne.n	a9f0 <__aeabi_dmul+0x234>
    a9e4:	orrs.w	r6, r2, r3, lsl #12
    a9e8:	itt	ne
    a9ea:	movne	r0, r2
    a9ec:	movne	r1, r3
    a9ee:	bne.n	aa06 <__aeabi_dmul+0x24a>
    a9f0:	eor.w	r1, r1, r3
    a9f4:	and.w	r1, r1, #2147483648	; 0x80000000
    a9f8:	orr.w	r1, r1, #2130706432	; 0x7f000000
    a9fc:	orr.w	r1, r1, #15728640	; 0xf00000
    aa00:	mov.w	r0, #0
    aa04:	pop	{r4, r5, r6, pc}
    aa06:	orr.w	r1, r1, #2130706432	; 0x7f000000
    aa0a:	orr.w	r1, r1, #16252928	; 0xf80000
    aa0e:	pop	{r4, r5, r6, pc}

0000aa10 <__aeabi_ddiv>:
    aa10:	push	{r4, r5, r6, lr}
    aa12:	mov.w	ip, #255	; 0xff
    aa16:	orr.w	ip, ip, #1792	; 0x700
    aa1a:	ands.w	r4, ip, r1, lsr #20
    aa1e:	ittte	ne
    aa20:	andsne.w	r5, ip, r3, lsr #20
    aa24:	teqne	r4, ip
    aa28:	teqne	r5, ip
    aa2c:	bleq	ab7e <__aeabi_ddiv+0x16e>
    aa30:	sub.w	r4, r4, r5
    aa34:	eor.w	lr, r1, r3
    aa38:	orrs.w	r5, r2, r3, lsl #12
    aa3c:	mov.w	r1, r1, lsl #12
    aa40:	beq.w	ab54 <__aeabi_ddiv+0x144>
    aa44:	mov.w	r3, r3, lsl #12
    aa48:	mov.w	r5, #268435456	; 0x10000000
    aa4c:	orr.w	r3, r5, r3, lsr #4
    aa50:	orr.w	r3, r3, r2, lsr #24
    aa54:	mov.w	r2, r2, lsl #8
    aa58:	orr.w	r5, r5, r1, lsr #4
    aa5c:	orr.w	r5, r5, r0, lsr #24
    aa60:	mov.w	r6, r0, lsl #8
    aa64:	and.w	r1, lr, #2147483648	; 0x80000000
    aa68:	cmp	r5, r3
    aa6a:	it	eq
    aa6c:	cmpeq	r6, r2
    aa6e:	adc.w	r4, r4, #253	; 0xfd
    aa72:	add.w	r4, r4, #768	; 0x300
    aa76:	bcs.n	aa7e <__aeabi_ddiv+0x6e>
    aa78:	lsrs	r3, r3, #1
    aa7a:	mov.w	r2, r2, rrx
    aa7e:	subs	r6, r6, r2
    aa80:	sbc.w	r5, r5, r3
    aa84:	lsrs	r3, r3, #1
    aa86:	mov.w	r2, r2, rrx
    aa8a:	mov.w	r0, #1048576	; 0x100000
    aa8e:	mov.w	ip, #524288	; 0x80000
    aa92:	subs.w	lr, r6, r2
    aa96:	sbcs.w	lr, r5, r3
    aa9a:	ittt	cs
    aa9c:	subcs	r6, r6, r2
    aa9e:	movcs	r5, lr
    aaa0:	orrcs.w	r0, r0, ip
    aaa4:	lsrs	r3, r3, #1
    aaa6:	mov.w	r2, r2, rrx
    aaaa:	subs.w	lr, r6, r2
    aaae:	sbcs.w	lr, r5, r3
    aab2:	ittt	cs
    aab4:	subcs	r6, r6, r2
    aab6:	movcs	r5, lr
    aab8:	orrcs.w	r0, r0, ip, lsr #1
    aabc:	lsrs	r3, r3, #1
    aabe:	mov.w	r2, r2, rrx
    aac2:	subs.w	lr, r6, r2
    aac6:	sbcs.w	lr, r5, r3
    aaca:	ittt	cs
    aacc:	subcs	r6, r6, r2
    aace:	movcs	r5, lr
    aad0:	orrcs.w	r0, r0, ip, lsr #2
    aad4:	lsrs	r3, r3, #1
    aad6:	mov.w	r2, r2, rrx
    aada:	subs.w	lr, r6, r2
    aade:	sbcs.w	lr, r5, r3
    aae2:	ittt	cs
    aae4:	subcs	r6, r6, r2
    aae6:	movcs	r5, lr
    aae8:	orrcs.w	r0, r0, ip, lsr #3
    aaec:	orrs.w	lr, r5, r6
    aaf0:	beq.n	ab24 <__aeabi_ddiv+0x114>
    aaf2:	mov.w	r5, r5, lsl #4
    aaf6:	orr.w	r5, r5, r6, lsr #28
    aafa:	mov.w	r6, r6, lsl #4
    aafe:	mov.w	r3, r3, lsl #3
    ab02:	orr.w	r3, r3, r2, lsr #29
    ab06:	mov.w	r2, r2, lsl #3
    ab0a:	movs.w	ip, ip, lsr #4
    ab0e:	bne.n	aa92 <__aeabi_ddiv+0x82>
    ab10:	tst.w	r1, #1048576	; 0x100000
    ab14:	bne.n	ab2e <__aeabi_ddiv+0x11e>
    ab16:	orr.w	r1, r1, r0
    ab1a:	mov.w	r0, #0
    ab1e:	mov.w	ip, #2147483648	; 0x80000000
    ab22:	b.n	aa92 <__aeabi_ddiv+0x82>
    ab24:	tst.w	r1, #1048576	; 0x100000
    ab28:	itt	eq
    ab2a:	orreq	r1, r0
    ab2c:	moveq	r0, #0
    ab2e:	subs.w	ip, r4, #253	; 0xfd
    ab32:	it	hi
    ab34:	cmphi.w	ip, #1792	; 0x700
    ab38:	bhi.w	a89a <__aeabi_dmul+0xde>
    ab3c:	subs.w	ip, r5, r3
    ab40:	itt	eq
    ab42:	subseq.w	ip, r6, r2
    ab46:	movseq.w	ip, r0, lsr #1
    ab4a:	adcs.w	r0, r0, #0
    ab4e:	adc.w	r1, r1, r4, lsl #20
    ab52:	pop	{r4, r5, r6, pc}
    ab54:	and.w	lr, lr, #2147483648	; 0x80000000
    ab58:	orr.w	r1, lr, r1, lsr #12
    ab5c:	adds.w	r4, r4, ip, lsr #1
    ab60:	ittt	gt
    ab62:	rsbsgt	r5, r4, ip
    ab66:	orrgt.w	r1, r1, r4, lsl #20
    ab6a:	popgt	{r4, r5, r6, pc}
    ab6c:	orr.w	r1, r1, #1048576	; 0x100000
    ab70:	mov.w	lr, #0
    ab74:	subs	r4, #1
    ab76:	b.n	a89a <__aeabi_dmul+0xde>
    ab78:	orr.w	lr, r5, r6
    ab7c:	b.n	a89a <__aeabi_dmul+0xde>
    ab7e:	and.w	r5, ip, r3, lsr #20
    ab82:	teq	r4, ip
    ab86:	it	eq
    ab88:	teqeq	r5, ip
    ab8c:	beq.w	aa06 <__aeabi_dmul+0x24a>
    ab90:	teq	r4, ip
    ab94:	bne.n	abac <__aeabi_ddiv+0x19c>
    ab96:	orrs.w	r4, r0, r1, lsl #12
    ab9a:	bne.w	aa06 <__aeabi_dmul+0x24a>
    ab9e:	teq	r5, ip
    aba2:	bne.w	a9f0 <__aeabi_dmul+0x234>
    aba6:	mov	r0, r2
    aba8:	mov	r1, r3
    abaa:	b.n	aa06 <__aeabi_dmul+0x24a>
    abac:	teq	r5, ip
    abb0:	bne.n	abc0 <__aeabi_ddiv+0x1b0>
    abb2:	orrs.w	r5, r2, r3, lsl #12
    abb6:	beq.w	a9b4 <__aeabi_dmul+0x1f8>
    abba:	mov	r0, r2
    abbc:	mov	r1, r3
    abbe:	b.n	aa06 <__aeabi_dmul+0x24a>
    abc0:	orrs.w	r6, r0, r1, lsl #1
    abc4:	it	ne
    abc6:	orrsne.w	r6, r2, r3, lsl #1
    abca:	bne.w	a958 <__aeabi_dmul+0x19c>
    abce:	orrs.w	r4, r0, r1, lsl #1
    abd2:	bne.w	a9f0 <__aeabi_dmul+0x234>
    abd6:	orrs.w	r5, r2, r3, lsl #1
    abda:	bne.w	a9b4 <__aeabi_dmul+0x1f8>
    abde:	b.n	aa06 <__aeabi_dmul+0x24a>

0000abe0 <__gedf2>:
    abe0:	mov.w	ip, #4294967295
    abe4:	b.n	abf4 <__cmpdf2+0x4>
    abe6:	nop

0000abe8 <__ledf2>:
    abe8:	mov.w	ip, #1
    abec:	b.n	abf4 <__cmpdf2+0x4>
    abee:	nop

0000abf0 <__cmpdf2>:
    abf0:	mov.w	ip, #1
    abf4:	str.w	ip, [sp, #-4]!
    abf8:	mov.w	ip, r1, lsl #1
    abfc:	mvns.w	ip, ip, asr #21
    ac00:	mov.w	ip, r3, lsl #1
    ac04:	it	ne
    ac06:	mvnsne.w	ip, ip, asr #21
    ac0a:	beq.n	ac44 <__cmpdf2+0x54>
    ac0c:	add	sp, #4
    ac0e:	orrs.w	ip, r0, r1, lsl #1
    ac12:	ite	eq
    ac14:	orrseq.w	ip, r2, r3, lsl #1
    ac18:	teqne	r1, r3
    ac1c:	ittt	eq
    ac1e:	teqeq	r0, r2
    ac22:	moveq	r0, #0
    ac24:	bxeq	lr
    ac26:	cmn.w	r0, #0
    ac2a:	teq	r1, r3
    ac2e:	it	pl
    ac30:	cmppl	r1, r3
    ac32:	it	eq
    ac34:	cmpeq	r0, r2
    ac36:	ite	cs
    ac38:	asrcs	r0, r3, #31
    ac3a:	mvncc.w	r0, r3, asr #31
    ac3e:	orr.w	r0, r0, #1
    ac42:	bx	lr
    ac44:	mov.w	ip, r1, lsl #1
    ac48:	mvns.w	ip, ip, asr #21
    ac4c:	bne.n	ac54 <__cmpdf2+0x64>
    ac4e:	orrs.w	ip, r0, r1, lsl #12
    ac52:	bne.n	ac64 <__cmpdf2+0x74>
    ac54:	mov.w	ip, r3, lsl #1
    ac58:	mvns.w	ip, ip, asr #21
    ac5c:	bne.n	ac0c <__cmpdf2+0x1c>
    ac5e:	orrs.w	ip, r2, r3, lsl #12
    ac62:	beq.n	ac0c <__cmpdf2+0x1c>
    ac64:	ldr.w	r0, [sp], #4
    ac68:	bx	lr
    ac6a:	nop

0000ac6c <__aeabi_cdrcmple>:
    ac6c:	mov	ip, r0
    ac6e:	mov	r0, r2
    ac70:	mov	r2, ip
    ac72:	mov	ip, r1
    ac74:	mov	r1, r3
    ac76:	mov	r3, ip
    ac78:	b.n	ac7c <__aeabi_cdcmpeq>
    ac7a:	nop

0000ac7c <__aeabi_cdcmpeq>:
    ac7c:	push	{r0, lr}
    ac7e:	bl	abf0 <__cmpdf2>
    ac82:	cmp	r0, #0
    ac84:	it	mi
    ac86:	cmnmi.w	r0, #0
    ac8a:	pop	{r0, pc}

0000ac8c <__aeabi_dcmpeq>:
    ac8c:	str.w	lr, [sp, #-8]!
    ac90:	bl	ac7c <__aeabi_cdcmpeq>
    ac94:	ite	eq
    ac96:	moveq	r0, #1
    ac98:	movne	r0, #0
    ac9a:	ldr.w	pc, [sp], #8
    ac9e:	nop

0000aca0 <__aeabi_dcmplt>:
    aca0:	str.w	lr, [sp, #-8]!
    aca4:	bl	ac7c <__aeabi_cdcmpeq>
    aca8:	ite	cc
    acaa:	movcc	r0, #1
    acac:	movcs	r0, #0
    acae:	ldr.w	pc, [sp], #8
    acb2:	nop

0000acb4 <__aeabi_dcmple>:
    acb4:	str.w	lr, [sp, #-8]!
    acb8:	bl	ac7c <__aeabi_cdcmpeq>
    acbc:	ite	ls
    acbe:	movls	r0, #1
    acc0:	movhi	r0, #0
    acc2:	ldr.w	pc, [sp], #8
    acc6:	nop

0000acc8 <__aeabi_dcmpge>:
    acc8:	str.w	lr, [sp, #-8]!
    accc:	bl	ac6c <__aeabi_cdrcmple>
    acd0:	ite	ls
    acd2:	movls	r0, #1
    acd4:	movhi	r0, #0
    acd6:	ldr.w	pc, [sp], #8
    acda:	nop

0000acdc <__aeabi_dcmpgt>:
    acdc:	str.w	lr, [sp, #-8]!
    ace0:	bl	ac6c <__aeabi_cdrcmple>
    ace4:	ite	cc
    ace6:	movcc	r0, #1
    ace8:	movcs	r0, #0
    acea:	ldr.w	pc, [sp], #8
    acee:	nop

0000acf0 <__aeabi_dcmpun>:
    acf0:	mov.w	ip, r1, lsl #1
    acf4:	mvns.w	ip, ip, asr #21
    acf8:	bne.n	ad00 <__aeabi_dcmpun+0x10>
    acfa:	orrs.w	ip, r0, r1, lsl #12
    acfe:	bne.n	ad16 <__aeabi_dcmpun+0x26>
    ad00:	mov.w	ip, r3, lsl #1
    ad04:	mvns.w	ip, ip, asr #21
    ad08:	bne.n	ad10 <__aeabi_dcmpun+0x20>
    ad0a:	orrs.w	ip, r2, r3, lsl #12
    ad0e:	bne.n	ad16 <__aeabi_dcmpun+0x26>
    ad10:	mov.w	r0, #0
    ad14:	bx	lr
    ad16:	mov.w	r0, #1
    ad1a:	bx	lr

0000ad1c <__aeabi_d2iz>:
    ad1c:	mov.w	r2, r1, lsl #1
    ad20:	adds.w	r2, r2, #2097152	; 0x200000
    ad24:	bcs.n	ad52 <__aeabi_d2iz+0x36>
    ad26:	bpl.n	ad4c <__aeabi_d2iz+0x30>
    ad28:	mvn.w	r3, #992	; 0x3e0
    ad2c:	subs.w	r2, r3, r2, asr #21
    ad30:	bls.n	ad58 <__aeabi_d2iz+0x3c>
    ad32:	mov.w	r3, r1, lsl #11
    ad36:	orr.w	r3, r3, #2147483648	; 0x80000000
    ad3a:	orr.w	r3, r3, r0, lsr #21
    ad3e:	tst.w	r1, #2147483648	; 0x80000000
    ad42:	lsr.w	r0, r3, r2
    ad46:	it	ne
    ad48:	negne	r0, r0
    ad4a:	bx	lr
    ad4c:	mov.w	r0, #0
    ad50:	bx	lr
    ad52:	orrs.w	r0, r0, r1, lsl #12
    ad56:	bne.n	ad64 <__aeabi_d2iz+0x48>
    ad58:	ands.w	r0, r1, #2147483648	; 0x80000000
    ad5c:	it	eq
    ad5e:	mvneq.w	r0, #2147483648	; 0x80000000
    ad62:	bx	lr
    ad64:	mov.w	r0, #0
    ad68:	bx	lr
    ad6a:	nop

0000ad6c <__aeabi_d2uiz>:
    ad6c:	lsls	r2, r1, #1
    ad6e:	bcs.n	ad94 <__aeabi_d2uiz+0x28>
    ad70:	adds.w	r2, r2, #2097152	; 0x200000
    ad74:	bcs.n	ad9a <__aeabi_d2uiz+0x2e>
    ad76:	bpl.n	ad94 <__aeabi_d2uiz+0x28>
    ad78:	mvn.w	r3, #992	; 0x3e0
    ad7c:	subs.w	r2, r3, r2, asr #21
    ad80:	bmi.n	ada0 <__aeabi_d2uiz+0x34>
    ad82:	mov.w	r3, r1, lsl #11
    ad86:	orr.w	r3, r3, #2147483648	; 0x80000000
    ad8a:	orr.w	r3, r3, r0, lsr #21
    ad8e:	lsr.w	r0, r3, r2
    ad92:	bx	lr
    ad94:	mov.w	r0, #0
    ad98:	bx	lr
    ad9a:	orrs.w	r0, r0, r1, lsl #12
    ad9e:	bne.n	ada6 <__aeabi_d2uiz+0x3a>
    ada0:	mov.w	r0, #4294967295
    ada4:	bx	lr
    ada6:	mov.w	r0, #0
    adaa:	bx	lr

0000adac <__aeabi_d2f>:
    adac:	mov.w	r2, r1, lsl #1
    adb0:	subs.w	r3, r2, #1879048192	; 0x70000000
    adb4:	itt	cs
    adb6:	subscs.w	ip, r3, #2097152	; 0x200000
    adba:	rsbscs	ip, ip, #532676608	; 0x1fc00000
    adbe:	bls.n	addc <__aeabi_d2f+0x30>
    adc0:	and.w	ip, r1, #2147483648	; 0x80000000
    adc4:	mov.w	r2, r0, lsl #3
    adc8:	orr.w	r0, ip, r0, lsr #29
    adcc:	cmp.w	r2, #2147483648	; 0x80000000
    add0:	adc.w	r0, r0, r3, lsl #2
    add4:	it	eq
    add6:	biceq.w	r0, r0, #1
    adda:	bx	lr
    addc:	tst.w	r1, #1073741824	; 0x40000000
    ade0:	bne.n	ae26 <__aeabi_d2f+0x7a>
    ade2:	adds.w	r2, r3, #48234496	; 0x2e00000
    ade6:	itt	lt
    ade8:	andlt.w	r0, r1, #2147483648	; 0x80000000
    adec:	bxlt	lr
    adee:	orr.w	r1, r1, #1048576	; 0x100000
    adf2:	mov.w	r2, r2, lsr #21
    adf6:	rsb	r2, r2, #24
    adfa:	rsb	ip, r2, #32
    adfe:	lsls.w	r3, r0, ip
    ae02:	lsr.w	r0, r0, r2
    ae06:	it	ne
    ae08:	orrne.w	r0, r0, #1
    ae0c:	mov.w	r3, r1, lsl #11
    ae10:	mov.w	r3, r3, lsr #11
    ae14:	lsl.w	ip, r3, ip
    ae18:	orr.w	r0, r0, ip
    ae1c:	lsr.w	r3, r3, r2
    ae20:	mov.w	r3, r3, lsl #1
    ae24:	b.n	adc0 <__aeabi_d2f+0x14>
    ae26:	mvns.w	r3, r2, asr #21
    ae2a:	bne.n	ae3c <__aeabi_d2f+0x90>
    ae2c:	orrs.w	r3, r0, r1, lsl #12
    ae30:	ittt	ne
    ae32:	movne.w	r0, #2130706432	; 0x7f000000
    ae36:	orrne.w	r0, r0, #12582912	; 0xc00000
    ae3a:	bxne	lr
    ae3c:	and.w	r0, r1, #2147483648	; 0x80000000
    ae40:	orr.w	r0, r0, #2130706432	; 0x7f000000
    ae44:	orr.w	r0, r0, #8388608	; 0x800000
    ae48:	bx	lr
    ae4a:	nop

0000ae4c <__aeabi_uldivmod>:
    ae4c:	cbnz	r3, ae64 <__aeabi_uldivmod+0x18>
    ae4e:	cbnz	r2, ae64 <__aeabi_uldivmod+0x18>
    ae50:	cmp	r1, #0
    ae52:	it	eq
    ae54:	cmpeq	r0, #0
    ae56:	itt	ne
    ae58:	movne.w	r1, #4294967295
    ae5c:	movne.w	r0, #4294967295
    ae60:	b.w	b160 <__aeabi_idiv0>
    ae64:	sub.w	ip, sp, #8
    ae68:	strd	ip, lr, [sp, #-16]!
    ae6c:	bl	ae7c <__udivmoddi4>
    ae70:	ldr.w	lr, [sp, #4]
    ae74:	ldrd	r2, r3, [sp, #8]
    ae78:	add	sp, #16
    ae7a:	bx	lr

0000ae7c <__udivmoddi4>:
    ae7c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ae80:	mov	ip, r1
    ae82:	mov	r6, r1
    ae84:	mov	r4, r0
    ae86:	ldr	r5, [sp, #32]
    ae88:	cmp	r3, #0
    ae8a:	bne.n	af2e <__udivmoddi4+0xb2>
    ae8c:	cmp	r2, r1
    ae8e:	mov	r7, r2
    ae90:	bls.n	af6c <__udivmoddi4+0xf0>
    ae92:	clz	lr, r2
    ae96:	cmp.w	lr, #0
    ae9a:	beq.n	aeb4 <__udivmoddi4+0x38>
    ae9c:	rsb	r4, lr, #32
    aea0:	lsr.w	r4, r0, r4
    aea4:	lsl.w	r6, r1, lr
    aea8:	orr.w	ip, r4, r6
    aeac:	lsl.w	r7, r2, lr
    aeb0:	lsl.w	r4, r0, lr
    aeb4:	mov.w	r9, r7, lsr #16
    aeb8:	lsrs	r2, r4, #16
    aeba:	udiv	r0, ip, r9
    aebe:	uxth.w	r8, r7
    aec2:	mls	r6, r9, r0, ip
    aec6:	orr.w	r6, r2, r6, lsl #16
    aeca:	mul.w	r3, r0, r8
    aece:	cmp	r3, r6
    aed0:	bls.n	aee6 <__udivmoddi4+0x6a>
    aed2:	adds	r6, r6, r7
    aed4:	add.w	r2, r0, #4294967295
    aed8:	bcs.w	b120 <__udivmoddi4+0x2a4>
    aedc:	cmp	r3, r6
    aede:	bls.w	b120 <__udivmoddi4+0x2a4>
    aee2:	subs	r0, #2
    aee4:	add	r6, r7
    aee6:	subs	r6, r6, r3
    aee8:	uxth	r2, r4
    aeea:	udiv	r3, r6, r9
    aeee:	mls	r6, r9, r3, r6
    aef2:	orr.w	r4, r2, r6, lsl #16
    aef6:	mul.w	r8, r3, r8
    aefa:	cmp	r8, r4
    aefc:	bls.n	af12 <__udivmoddi4+0x96>
    aefe:	adds	r4, r4, r7
    af00:	add.w	r2, r3, #4294967295
    af04:	bcs.w	b11c <__udivmoddi4+0x2a0>
    af08:	cmp	r8, r4
    af0a:	bls.w	b11c <__udivmoddi4+0x2a0>
    af0e:	subs	r3, #2
    af10:	add	r4, r7
    af12:	rsb	r4, r8, r4
    af16:	orr.w	r0, r3, r0, lsl #16
    af1a:	movs	r1, #0
    af1c:	cmp	r5, #0
    af1e:	beq.n	afe6 <__udivmoddi4+0x16a>
    af20:	lsr.w	r4, r4, lr
    af24:	movs	r3, #0
    af26:	str	r4, [r5, #0]
    af28:	str	r3, [r5, #4]
    af2a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    af2e:	cmp	r3, r1
    af30:	bls.n	af42 <__udivmoddi4+0xc6>
    af32:	cmp	r5, #0
    af34:	beq.n	afe2 <__udivmoddi4+0x166>
    af36:	movs	r1, #0
    af38:	stmia.w	r5, {r0, r6}
    af3c:	mov	r0, r1
    af3e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    af42:	clz	r1, r3
    af46:	cmp	r1, #0
    af48:	bne.w	b06c <__udivmoddi4+0x1f0>
    af4c:	cmp	r3, r6
    af4e:	bcc.n	af56 <__udivmoddi4+0xda>
    af50:	cmp	r2, r0
    af52:	bhi.w	b146 <__udivmoddi4+0x2ca>
    af56:	subs	r4, r0, r2
    af58:	sbc.w	r6, r6, r3
    af5c:	movs	r0, #1
    af5e:	mov	ip, r6
    af60:	cmp	r5, #0
    af62:	beq.n	afe6 <__udivmoddi4+0x16a>
    af64:	stmia.w	r5, {r4, ip}
    af68:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    af6c:	cbnz	r2, af74 <__udivmoddi4+0xf8>
    af6e:	movs	r7, #1
    af70:	udiv	r7, r7, r2
    af74:	clz	lr, r7
    af78:	cmp.w	lr, #0
    af7c:	bne.n	afea <__udivmoddi4+0x16e>
    af7e:	subs	r3, r6, r7
    af80:	mov.w	r8, r7, lsr #16
    af84:	uxth.w	ip, r7
    af88:	movs	r1, #1
    af8a:	udiv	r0, r3, r8
    af8e:	lsrs	r2, r4, #16
    af90:	mls	r6, r8, r0, r3
    af94:	orr.w	r6, r2, r6, lsl #16
    af98:	mul.w	r3, ip, r0
    af9c:	cmp	r3, r6
    af9e:	bls.n	afb0 <__udivmoddi4+0x134>
    afa0:	adds	r6, r6, r7
    afa2:	add.w	r2, r0, #4294967295
    afa6:	bcs.n	afae <__udivmoddi4+0x132>
    afa8:	cmp	r3, r6
    afaa:	bhi.w	b14a <__udivmoddi4+0x2ce>
    afae:	mov	r0, r2
    afb0:	subs	r6, r6, r3
    afb2:	uxth	r2, r4
    afb4:	udiv	r3, r6, r8
    afb8:	mls	r6, r8, r3, r6
    afbc:	orr.w	r4, r2, r6, lsl #16
    afc0:	mul.w	ip, ip, r3
    afc4:	cmp	ip, r4
    afc6:	bls.n	afd8 <__udivmoddi4+0x15c>
    afc8:	adds	r4, r4, r7
    afca:	add.w	r2, r3, #4294967295
    afce:	bcs.n	afd6 <__udivmoddi4+0x15a>
    afd0:	cmp	ip, r4
    afd2:	bhi.w	b140 <__udivmoddi4+0x2c4>
    afd6:	mov	r3, r2
    afd8:	rsb	r4, ip, r4
    afdc:	orr.w	r0, r3, r0, lsl #16
    afe0:	b.n	af1c <__udivmoddi4+0xa0>
    afe2:	mov	r1, r5
    afe4:	mov	r0, r5
    afe6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    afea:	rsb	r1, lr, #32
    afee:	lsl.w	r3, r6, lr
    aff2:	lsl.w	r7, r7, lr
    aff6:	lsr.w	r9, r0, r1
    affa:	mov.w	r8, r7, lsr #16
    affe:	lsrs	r6, r1
    b000:	orr.w	r9, r9, r3
    b004:	udiv	sl, r6, r8
    b008:	mov.w	r4, r9, lsr #16
    b00c:	mls	r6, r8, sl, r6
    b010:	uxth.w	ip, r7
    b014:	orr.w	r3, r4, r6, lsl #16
    b018:	mul.w	r2, sl, ip
    b01c:	cmp	r2, r3
    b01e:	lsl.w	r4, r0, lr
    b022:	bls.n	b03a <__udivmoddi4+0x1be>
    b024:	adds	r3, r3, r7
    b026:	add.w	r1, sl, #4294967295
    b02a:	bcs.w	b13c <__udivmoddi4+0x2c0>
    b02e:	cmp	r2, r3
    b030:	bls.w	b13c <__udivmoddi4+0x2c0>
    b034:	sub.w	sl, sl, #2
    b038:	add	r3, r7
    b03a:	subs	r3, r3, r2
    b03c:	uxth.w	r9, r9
    b040:	udiv	r1, r3, r8
    b044:	mls	r3, r8, r1, r3
    b048:	orr.w	r3, r9, r3, lsl #16
    b04c:	mul.w	r6, r1, ip
    b050:	cmp	r6, r3
    b052:	bls.n	b064 <__udivmoddi4+0x1e8>
    b054:	adds	r3, r3, r7
    b056:	add.w	r2, r1, #4294967295
    b05a:	bcs.n	b134 <__udivmoddi4+0x2b8>
    b05c:	cmp	r6, r3
    b05e:	bls.n	b134 <__udivmoddi4+0x2b8>
    b060:	subs	r1, #2
    b062:	add	r3, r7
    b064:	subs	r3, r3, r6
    b066:	orr.w	r1, r1, sl, lsl #16
    b06a:	b.n	af8a <__udivmoddi4+0x10e>
    b06c:	rsb	lr, r1, #32
    b070:	lsr.w	r4, r2, lr
    b074:	lsls	r3, r1
    b076:	orrs	r3, r4
    b078:	lsr.w	r7, r0, lr
    b07c:	lsl.w	r4, r6, r1
    b080:	mov.w	ip, r3, lsr #16
    b084:	lsr.w	r6, r6, lr
    b088:	orrs	r4, r7
    b08a:	udiv	r9, r6, ip
    b08e:	lsrs	r7, r4, #16
    b090:	mls	r6, ip, r9, r6
    b094:	uxth.w	r8, r3
    b098:	orr.w	r6, r7, r6, lsl #16
    b09c:	mul.w	r7, r9, r8
    b0a0:	cmp	r7, r6
    b0a2:	lsl.w	r2, r2, r1
    b0a6:	lsl.w	sl, r0, r1
    b0aa:	bls.n	b0be <__udivmoddi4+0x242>
    b0ac:	adds	r6, r6, r3
    b0ae:	add.w	r0, r9, #4294967295
    b0b2:	bcs.n	b138 <__udivmoddi4+0x2bc>
    b0b4:	cmp	r7, r6
    b0b6:	bls.n	b138 <__udivmoddi4+0x2bc>
    b0b8:	sub.w	r9, r9, #2
    b0bc:	add	r6, r3
    b0be:	subs	r6, r6, r7
    b0c0:	uxth	r0, r4
    b0c2:	udiv	r4, r6, ip
    b0c6:	mls	r6, ip, r4, r6
    b0ca:	orr.w	r7, r0, r6, lsl #16
    b0ce:	mul.w	r8, r4, r8
    b0d2:	cmp	r8, r7
    b0d4:	bls.n	b0e6 <__udivmoddi4+0x26a>
    b0d6:	adds	r7, r7, r3
    b0d8:	add.w	r0, r4, #4294967295
    b0dc:	bcs.n	b130 <__udivmoddi4+0x2b4>
    b0de:	cmp	r8, r7
    b0e0:	bls.n	b130 <__udivmoddi4+0x2b4>
    b0e2:	subs	r4, #2
    b0e4:	add	r7, r3
    b0e6:	orr.w	r0, r4, r9, lsl #16
    b0ea:	rsb	r7, r8, r7
    b0ee:	umull	r8, r9, r0, r2
    b0f2:	cmp	r7, r9
    b0f4:	mov	r4, r8
    b0f6:	mov	r6, r9
    b0f8:	bcc.n	b124 <__udivmoddi4+0x2a8>
    b0fa:	beq.n	b150 <__udivmoddi4+0x2d4>
    b0fc:	cbz	r5, b158 <__udivmoddi4+0x2dc>
    b0fe:	subs.w	r3, sl, r4
    b102:	sbc.w	r7, r7, r6
    b106:	lsl.w	lr, r7, lr
    b10a:	lsrs	r3, r1
    b10c:	lsrs	r7, r1
    b10e:	orr.w	r3, lr, r3
    b112:	stmia.w	r5, {r3, r7}
    b116:	movs	r1, #0
    b118:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b11c:	mov	r3, r2
    b11e:	b.n	af12 <__udivmoddi4+0x96>
    b120:	mov	r0, r2
    b122:	b.n	aee6 <__udivmoddi4+0x6a>
    b124:	subs.w	r4, r8, r2
    b128:	sbc.w	r6, r9, r3
    b12c:	subs	r0, #1
    b12e:	b.n	b0fc <__udivmoddi4+0x280>
    b130:	mov	r4, r0
    b132:	b.n	b0e6 <__udivmoddi4+0x26a>
    b134:	mov	r1, r2
    b136:	b.n	b064 <__udivmoddi4+0x1e8>
    b138:	mov	r9, r0
    b13a:	b.n	b0be <__udivmoddi4+0x242>
    b13c:	mov	sl, r1
    b13e:	b.n	b03a <__udivmoddi4+0x1be>
    b140:	subs	r3, #2
    b142:	add	r4, r7
    b144:	b.n	afd8 <__udivmoddi4+0x15c>
    b146:	mov	r0, r1
    b148:	b.n	af60 <__udivmoddi4+0xe4>
    b14a:	subs	r0, #2
    b14c:	add	r6, r7
    b14e:	b.n	afb0 <__udivmoddi4+0x134>
    b150:	cmp	sl, r8
    b152:	bcc.n	b124 <__udivmoddi4+0x2a8>
    b154:	mov	r6, r7
    b156:	b.n	b0fc <__udivmoddi4+0x280>
    b158:	mov	r1, r5
    b15a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b15e:	nop

0000b160 <__aeabi_idiv0>:
    b160:	bx	lr
    b162:	nop

0000b164 <__cxa_atexit>:
    b164:	mov	r3, r2
    b166:	mov	r2, r1
    b168:	mov	r1, r0
    b16a:	movs	r0, #2
    b16c:	b.w	f6a8 <__register_exitproc>

0000b170 <__errno>:
    b170:	ldr	r3, [pc, #4]	; (b178 <__errno+0x8>)
    b172:	ldr	r0, [r3, #0]
    b174:	bx	lr
    b176:	nop
    b178:	.word	0x1fff1848

0000b17c <__libc_init_array>:
    b17c:	push	{r4, r5, r6, lr}
    b17e:	ldr	r6, [pc, #60]	; (b1bc <__libc_init_array+0x40>)
    b180:	ldr	r5, [pc, #60]	; (b1c0 <__libc_init_array+0x44>)
    b182:	subs	r6, r6, r5
    b184:	asrs	r6, r6, #2
    b186:	it	ne
    b188:	movne	r4, #0
    b18a:	beq.n	b198 <__libc_init_array+0x1c>
    b18c:	adds	r4, #1
    b18e:	ldr.w	r3, [r5], #4
    b192:	blx	r3
    b194:	cmp	r6, r4
    b196:	bne.n	b18c <__libc_init_array+0x10>
    b198:	ldr	r6, [pc, #40]	; (b1c4 <__libc_init_array+0x48>)
    b19a:	ldr	r5, [pc, #44]	; (b1c8 <__libc_init_array+0x4c>)
    b19c:	subs	r6, r6, r5
    b19e:	bl	1341c <_init>
    b1a2:	asrs	r6, r6, #2
    b1a4:	it	ne
    b1a6:	movne	r4, #0
    b1a8:	beq.n	b1b8 <__libc_init_array+0x3c>
    b1aa:	adds	r4, #1
    b1ac:	ldr.w	r3, [r5], #4
    b1b0:	blx	r3
    b1b2:	cmp	r6, r4
    b1b4:	bne.n	b1aa <__libc_init_array+0x2e>
    b1b6:	pop	{r4, r5, r6, pc}
    b1b8:	pop	{r4, r5, r6, pc}
    b1ba:	nop
    b1bc:	.word	0x00013428
    b1c0:	.word	0x00013428
    b1c4:	.word	0x00013440
    b1c8:	.word	0x00013428

0000b1cc <__get_current_locale>:
    b1cc:	ldr	r2, [pc, #12]	; (b1dc <__get_current_locale+0x10>)
    b1ce:	ldr	r3, [pc, #16]	; (b1e0 <__get_current_locale+0x14>)
    b1d0:	ldr	r2, [r2, #0]
    b1d2:	ldr	r0, [r2, #52]	; 0x34
    b1d4:	cmp	r0, #0
    b1d6:	it	eq
    b1d8:	moveq	r0, r3
    b1da:	bx	lr
    b1dc:	.word	0x1fff1848
    b1e0:	.word	0x1fff184c

0000b1e4 <__locale_mb_cur_max>:
    b1e4:	ldr	r3, [pc, #16]	; (b1f8 <__locale_mb_cur_max+0x14>)
    b1e6:	ldr	r2, [pc, #20]	; (b1fc <__locale_mb_cur_max+0x18>)
    b1e8:	ldr	r3, [r3, #0]
    b1ea:	ldr	r3, [r3, #52]	; 0x34
    b1ec:	cmp	r3, #0
    b1ee:	it	eq
    b1f0:	moveq	r3, r2
    b1f2:	ldrb.w	r0, [r3, #296]	; 0x128
    b1f6:	bx	lr
    b1f8:	.word	0x1fff1848
    b1fc:	.word	0x1fff184c

0000b200 <__locale_ctype_ptr_l>:
    b200:	ldr.w	r0, [r0, #236]	; 0xec
    b204:	bx	lr
    b206:	nop

0000b208 <__locale_ctype_ptr>:
    b208:	push	{r3, lr}
    b20a:	ldr	r3, [pc, #12]	; (b218 <__locale_ctype_ptr+0x10>)
    b20c:	ldr	r0, [r3, #0]
    b20e:	bl	b1cc <__get_current_locale>
    b212:	ldr.w	r0, [r0, #236]	; 0xec
    b216:	pop	{r3, pc}
    b218:	.word	0x1fff1848

0000b21c <malloc>:
    b21c:	ldr	r3, [pc, #8]	; (b228 <malloc+0xc>)
    b21e:	mov	r1, r0
    b220:	ldr	r0, [r3, #0]
    b222:	b.w	b23c <_malloc_r>
    b226:	nop
    b228:	.word	0x1fff1848

0000b22c <free>:
    b22c:	ldr	r3, [pc, #8]	; (b238 <free+0xc>)
    b22e:	mov	r1, r0
    b230:	ldr	r0, [r3, #0]
    b232:	b.w	10790 <_free_r>
    b236:	nop
    b238:	.word	0x1fff1848

0000b23c <_malloc_r>:
    b23c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b240:	add.w	r5, r1, #11
    b244:	cmp	r5, #22
    b246:	sub	sp, #12
    b248:	mov	r6, r0
    b24a:	bls.w	b38c <_malloc_r+0x150>
    b24e:	bics.w	r5, r5, #7
    b252:	bmi.w	b3d4 <_malloc_r+0x198>
    b256:	cmp	r1, r5
    b258:	bhi.w	b3d4 <_malloc_r+0x198>
    b25c:	bl	b9ac <__malloc_lock>
    b260:	cmp.w	r5, #504	; 0x1f8
    b264:	bcc.w	b7a0 <_malloc_r+0x564>
    b268:	lsrs	r3, r5, #9
    b26a:	beq.w	b3e2 <_malloc_r+0x1a6>
    b26e:	cmp	r3, #4
    b270:	bhi.w	b57a <_malloc_r+0x33e>
    b274:	lsrs	r0, r5, #6
    b276:	add.w	lr, r0, #57	; 0x39
    b27a:	mov.w	r3, lr, lsl #1
    b27e:	adds	r0, #56	; 0x38
    b280:	ldr	r7, [pc, #784]	; (b594 <_malloc_r+0x358>)
    b282:	add.w	r3, r7, r3, lsl #2
    b286:	sub.w	r1, r3, #8
    b28a:	ldr	r4, [r3, #4]
    b28c:	cmp	r1, r4
    b28e:	bne.n	b2a0 <_malloc_r+0x64>
    b290:	b.n	b3ec <_malloc_r+0x1b0>
    b292:	cmp	r2, #0
    b294:	bge.w	b3f0 <_malloc_r+0x1b4>
    b298:	ldr	r4, [r4, #12]
    b29a:	cmp	r1, r4
    b29c:	beq.w	b3ec <_malloc_r+0x1b0>
    b2a0:	ldr	r3, [r4, #4]
    b2a2:	bic.w	r3, r3, #3
    b2a6:	subs	r2, r3, r5
    b2a8:	cmp	r2, #15
    b2aa:	ble.n	b292 <_malloc_r+0x56>
    b2ac:	ldr	r1, [pc, #740]	; (b594 <_malloc_r+0x358>)
    b2ae:	ldr	r4, [r7, #16]
    b2b0:	add.w	lr, r1, #8
    b2b4:	cmp	r4, lr
    b2b6:	beq.w	b620 <_malloc_r+0x3e4>
    b2ba:	ldr	r3, [r4, #4]
    b2bc:	bic.w	r3, r3, #3
    b2c0:	subs	r2, r3, r5
    b2c2:	cmp	r2, #15
    b2c4:	bgt.w	b5fa <_malloc_r+0x3be>
    b2c8:	cmp	r2, #0
    b2ca:	str.w	lr, [r1, #20]
    b2ce:	str.w	lr, [r1, #16]
    b2d2:	bge.w	b412 <_malloc_r+0x1d6>
    b2d6:	cmp.w	r3, #512	; 0x200
    b2da:	bcs.w	b5ac <_malloc_r+0x370>
    b2de:	lsrs	r3, r3, #3
    b2e0:	add.w	ip, r3, #1
    b2e4:	movs	r2, #1
    b2e6:	asrs	r3, r3, #2
    b2e8:	lsl.w	r3, r2, r3
    b2ec:	ldr	r2, [r1, #4]
    b2ee:	ldr.w	r8, [r1, ip, lsl #3]
    b2f2:	str.w	r8, [r4, #8]
    b2f6:	add.w	r9, r1, ip, lsl #3
    b2fa:	orrs	r2, r3
    b2fc:	sub.w	r3, r9, #8
    b300:	str	r3, [r4, #12]
    b302:	str	r2, [r1, #4]
    b304:	str.w	r4, [r1, ip, lsl #3]
    b308:	str.w	r4, [r8, #12]
    b30c:	asrs	r3, r0, #2
    b30e:	movs	r4, #1
    b310:	lsls	r4, r3
    b312:	cmp	r4, r2
    b314:	bhi.w	b42c <_malloc_r+0x1f0>
    b318:	tst	r4, r2
    b31a:	bne.n	b32a <_malloc_r+0xee>
    b31c:	bic.w	r0, r0, #3
    b320:	lsls	r4, r4, #1
    b322:	tst	r4, r2
    b324:	add.w	r0, r0, #4
    b328:	beq.n	b320 <_malloc_r+0xe4>
    b32a:	add.w	r9, r7, r0, lsl #3
    b32e:	mov	ip, r9
    b330:	mov	r8, r0
    b332:	ldr.w	r1, [ip, #12]
    b336:	cmp	ip, r1
    b338:	bne.n	b34a <_malloc_r+0x10e>
    b33a:	b.n	b624 <_malloc_r+0x3e8>
    b33c:	cmp	r2, #0
    b33e:	bge.w	b644 <_malloc_r+0x408>
    b342:	ldr	r1, [r1, #12]
    b344:	cmp	ip, r1
    b346:	beq.w	b624 <_malloc_r+0x3e8>
    b34a:	ldr	r3, [r1, #4]
    b34c:	bic.w	r3, r3, #3
    b350:	subs	r2, r3, r5
    b352:	cmp	r2, #15
    b354:	ble.n	b33c <_malloc_r+0x100>
    b356:	mov	r4, r1
    b358:	ldr.w	ip, [r1, #12]
    b35c:	ldr.w	r8, [r4, #8]!
    b360:	adds	r3, r1, r5
    b362:	orr.w	r5, r5, #1
    b366:	str	r5, [r1, #4]
    b368:	orr.w	r1, r2, #1
    b36c:	str.w	ip, [r8, #12]
    b370:	mov	r0, r6
    b372:	str.w	r8, [ip, #8]
    b376:	str	r3, [r7, #20]
    b378:	str	r3, [r7, #16]
    b37a:	str.w	lr, [r3, #12]
    b37e:	str.w	lr, [r3, #8]
    b382:	str	r1, [r3, #4]
    b384:	str	r2, [r3, r2]
    b386:	bl	b9b0 <__malloc_unlock>
    b38a:	b.n	b3cc <_malloc_r+0x190>
    b38c:	cmp	r1, #16
    b38e:	bhi.n	b3d4 <_malloc_r+0x198>
    b390:	bl	b9ac <__malloc_lock>
    b394:	movs	r5, #16
    b396:	movs	r3, #6
    b398:	movs	r0, #2
    b39a:	ldr	r7, [pc, #504]	; (b594 <_malloc_r+0x358>)
    b39c:	add.w	r3, r7, r3, lsl #2
    b3a0:	sub.w	r2, r3, #8
    b3a4:	ldr	r4, [r3, #4]
    b3a6:	cmp	r4, r2
    b3a8:	beq.w	b636 <_malloc_r+0x3fa>
    b3ac:	ldr	r3, [r4, #4]
    b3ae:	ldr	r1, [r4, #12]
    b3b0:	ldr	r5, [r4, #8]
    b3b2:	bic.w	r3, r3, #3
    b3b6:	add	r3, r4
    b3b8:	mov	r0, r6
    b3ba:	ldr	r2, [r3, #4]
    b3bc:	str	r1, [r5, #12]
    b3be:	orr.w	r2, r2, #1
    b3c2:	str	r5, [r1, #8]
    b3c4:	str	r2, [r3, #4]
    b3c6:	bl	b9b0 <__malloc_unlock>
    b3ca:	adds	r4, #8
    b3cc:	mov	r0, r4
    b3ce:	add	sp, #12
    b3d0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b3d4:	movs	r4, #0
    b3d6:	movs	r3, #12
    b3d8:	mov	r0, r4
    b3da:	str	r3, [r6, #0]
    b3dc:	add	sp, #12
    b3de:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b3e2:	movs	r3, #128	; 0x80
    b3e4:	mov.w	lr, #64	; 0x40
    b3e8:	movs	r0, #63	; 0x3f
    b3ea:	b.n	b280 <_malloc_r+0x44>
    b3ec:	mov	r0, lr
    b3ee:	b.n	b2ac <_malloc_r+0x70>
    b3f0:	add	r3, r4
    b3f2:	ldr	r1, [r4, #12]
    b3f4:	ldr	r2, [r3, #4]
    b3f6:	ldr	r5, [r4, #8]
    b3f8:	orr.w	r2, r2, #1
    b3fc:	str	r1, [r5, #12]
    b3fe:	mov	r0, r6
    b400:	str	r5, [r1, #8]
    b402:	str	r2, [r3, #4]
    b404:	bl	b9b0 <__malloc_unlock>
    b408:	adds	r4, #8
    b40a:	mov	r0, r4
    b40c:	add	sp, #12
    b40e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b412:	add	r3, r4
    b414:	mov	r0, r6
    b416:	ldr	r2, [r3, #4]
    b418:	orr.w	r2, r2, #1
    b41c:	str	r2, [r3, #4]
    b41e:	bl	b9b0 <__malloc_unlock>
    b422:	adds	r4, #8
    b424:	mov	r0, r4
    b426:	add	sp, #12
    b428:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b42c:	ldr	r4, [r7, #8]
    b42e:	ldr	r3, [r4, #4]
    b430:	bic.w	r8, r3, #3
    b434:	cmp	r8, r5
    b436:	bcc.n	b442 <_malloc_r+0x206>
    b438:	rsb	r3, r5, r8
    b43c:	cmp	r3, #15
    b43e:	bgt.w	b55a <_malloc_r+0x31e>
    b442:	ldr	r3, [pc, #340]	; (b598 <_malloc_r+0x35c>)
    b444:	ldr.w	r9, [pc, #352]	; b5a8 <_malloc_r+0x36c>
    b448:	ldr	r2, [r3, #0]
    b44a:	ldr.w	r3, [r9]
    b44e:	adds	r3, #1
    b450:	add	r2, r5
    b452:	add.w	sl, r4, r8
    b456:	beq.w	b71a <_malloc_r+0x4de>
    b45a:	add.w	r2, r2, #4096	; 0x1000
    b45e:	adds	r2, #15
    b460:	bic.w	r2, r2, #4080	; 0xff0
    b464:	bic.w	r2, r2, #15
    b468:	mov	r1, r2
    b46a:	mov	r0, r6
    b46c:	str	r2, [sp, #4]
    b46e:	bl	bd94 <_sbrk_r>
    b472:	cmp.w	r0, #4294967295
    b476:	mov	fp, r0
    b478:	ldr	r2, [sp, #4]
    b47a:	beq.w	b72e <_malloc_r+0x4f2>
    b47e:	cmp	sl, r0
    b480:	bhi.w	b67c <_malloc_r+0x440>
    b484:	ldr	r3, [pc, #276]	; (b59c <_malloc_r+0x360>)
    b486:	ldr	r1, [r3, #0]
    b488:	cmp	sl, fp
    b48a:	add	r1, r2
    b48c:	str	r1, [r3, #0]
    b48e:	beq.w	b738 <_malloc_r+0x4fc>
    b492:	ldr.w	r0, [r9]
    b496:	ldr.w	lr, [pc, #272]	; b5a8 <_malloc_r+0x36c>
    b49a:	adds	r0, #1
    b49c:	ittet	ne
    b49e:	rsbne	sl, sl, fp
    b4a2:	addne	r1, sl
    b4a4:	streq.w	fp, [lr]
    b4a8:	strne	r1, [r3, #0]
    b4aa:	ands.w	r1, fp, #7
    b4ae:	beq.w	b6e0 <_malloc_r+0x4a4>
    b4b2:	rsb	r0, r1, #8
    b4b6:	rsb	r1, r1, #4096	; 0x1000
    b4ba:	add	fp, r0
    b4bc:	adds	r1, #8
    b4be:	add	r2, fp
    b4c0:	ubfx	r2, r2, #0, #12
    b4c4:	rsb	r9, r2, r1
    b4c8:	mov	r1, r9
    b4ca:	mov	r0, r6
    b4cc:	str	r3, [sp, #4]
    b4ce:	bl	bd94 <_sbrk_r>
    b4d2:	adds	r3, r0, #1
    b4d4:	ldr	r3, [sp, #4]
    b4d6:	beq.w	b758 <_malloc_r+0x51c>
    b4da:	rsb	r2, fp, r0
    b4de:	add	r2, r9
    b4e0:	orr.w	r2, r2, #1
    b4e4:	ldr	r1, [r3, #0]
    b4e6:	str.w	fp, [r7, #8]
    b4ea:	add	r1, r9
    b4ec:	cmp	r4, r7
    b4ee:	str.w	r2, [fp, #4]
    b4f2:	str	r1, [r3, #0]
    b4f4:	ldr.w	r9, [pc, #164]	; b59c <_malloc_r+0x360>
    b4f8:	beq.n	b528 <_malloc_r+0x2ec>
    b4fa:	cmp.w	r8, #15
    b4fe:	bls.w	b6fc <_malloc_r+0x4c0>
    b502:	ldr	r2, [r4, #4]
    b504:	sub.w	r3, r8, #12
    b508:	bic.w	r3, r3, #7
    b50c:	adds	r0, r4, r3
    b50e:	and.w	r2, r2, #1
    b512:	mov.w	lr, #5
    b516:	orrs	r2, r3
    b518:	cmp	r3, #15
    b51a:	str	r2, [r4, #4]
    b51c:	str.w	lr, [r0, #4]
    b520:	str.w	lr, [r0, #8]
    b524:	bhi.w	b760 <_malloc_r+0x524>
    b528:	ldr	r3, [pc, #116]	; (b5a0 <_malloc_r+0x364>)
    b52a:	ldr	r4, [r7, #8]
    b52c:	ldr	r2, [r3, #0]
    b52e:	cmp	r1, r2
    b530:	it	hi
    b532:	strhi	r1, [r3, #0]
    b534:	ldr	r3, [pc, #108]	; (b5a4 <_malloc_r+0x368>)
    b536:	ldr	r2, [r3, #0]
    b538:	cmp	r1, r2
    b53a:	ldr	r2, [r4, #4]
    b53c:	it	hi
    b53e:	strhi	r1, [r3, #0]
    b540:	bic.w	r2, r2, #3
    b544:	cmp	r5, r2
    b546:	sub.w	r3, r2, r5
    b54a:	bhi.n	b550 <_malloc_r+0x314>
    b54c:	cmp	r3, #15
    b54e:	bgt.n	b55a <_malloc_r+0x31e>
    b550:	mov	r0, r6
    b552:	bl	b9b0 <__malloc_unlock>
    b556:	movs	r4, #0
    b558:	b.n	b3cc <_malloc_r+0x190>
    b55a:	adds	r2, r4, r5
    b55c:	orr.w	r3, r3, #1
    b560:	orr.w	r5, r5, #1
    b564:	str	r5, [r4, #4]
    b566:	mov	r0, r6
    b568:	str	r2, [r7, #8]
    b56a:	str	r3, [r2, #4]
    b56c:	bl	b9b0 <__malloc_unlock>
    b570:	adds	r4, #8
    b572:	mov	r0, r4
    b574:	add	sp, #12
    b576:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b57a:	cmp	r3, #20
    b57c:	bls.n	b662 <_malloc_r+0x426>
    b57e:	cmp	r3, #84	; 0x54
    b580:	bhi.w	b6cc <_malloc_r+0x490>
    b584:	lsrs	r0, r5, #12
    b586:	add.w	lr, r0, #111	; 0x6f
    b58a:	mov.w	r3, lr, lsl #1
    b58e:	adds	r0, #110	; 0x6e
    b590:	b.n	b280 <_malloc_r+0x44>
    b592:	nop
    b594:	.word	0x1fff19b8
    b598:	.word	0x2001d040
    b59c:	.word	0x2001d044
    b5a0:	.word	0x2001d03c
    b5a4:	.word	0x2001d038
    b5a8:	.word	0x1fff1dc4
    b5ac:	lsrs	r2, r3, #9
    b5ae:	cmp	r2, #4
    b5b0:	bls.n	b670 <_malloc_r+0x434>
    b5b2:	cmp	r2, #20
    b5b4:	bhi.w	b71e <_malloc_r+0x4e2>
    b5b8:	add.w	r1, r2, #92	; 0x5c
    b5bc:	lsls	r1, r1, #1
    b5be:	adds	r2, #91	; 0x5b
    b5c0:	add.w	ip, r7, r1, lsl #2
    b5c4:	ldr.w	r1, [r7, r1, lsl #2]
    b5c8:	ldr.w	r8, [pc, #476]	; b7a8 <_malloc_r+0x56c>
    b5cc:	sub.w	ip, ip, #8
    b5d0:	cmp	ip, r1
    b5d2:	beq.w	b6e6 <_malloc_r+0x4aa>
    b5d6:	ldr	r2, [r1, #4]
    b5d8:	bic.w	r2, r2, #3
    b5dc:	cmp	r3, r2
    b5de:	bcs.n	b5e6 <_malloc_r+0x3aa>
    b5e0:	ldr	r1, [r1, #8]
    b5e2:	cmp	ip, r1
    b5e4:	bne.n	b5d6 <_malloc_r+0x39a>
    b5e6:	ldr.w	ip, [r1, #12]
    b5ea:	ldr	r2, [r7, #4]
    b5ec:	str.w	ip, [r4, #12]
    b5f0:	str	r1, [r4, #8]
    b5f2:	str.w	r4, [ip, #8]
    b5f6:	str	r4, [r1, #12]
    b5f8:	b.n	b30c <_malloc_r+0xd0>
    b5fa:	adds	r3, r4, r5
    b5fc:	orr.w	r7, r2, #1
    b600:	orr.w	r5, r5, #1
    b604:	str	r5, [r4, #4]
    b606:	mov	r0, r6
    b608:	str	r3, [r1, #20]
    b60a:	str	r3, [r1, #16]
    b60c:	str.w	lr, [r3, #12]
    b610:	str.w	lr, [r3, #8]
    b614:	str	r7, [r3, #4]
    b616:	str	r2, [r3, r2]
    b618:	adds	r4, #8
    b61a:	bl	b9b0 <__malloc_unlock>
    b61e:	b.n	b3cc <_malloc_r+0x190>
    b620:	ldr	r2, [r1, #4]
    b622:	b.n	b30c <_malloc_r+0xd0>
    b624:	add.w	r8, r8, #1
    b628:	tst.w	r8, #3
    b62c:	add.w	ip, ip, #8
    b630:	bne.w	b332 <_malloc_r+0xf6>
    b634:	b.n	b698 <_malloc_r+0x45c>
    b636:	ldr	r4, [r3, #12]
    b638:	cmp	r3, r4
    b63a:	it	eq
    b63c:	addeq	r0, #2
    b63e:	beq.w	b2ac <_malloc_r+0x70>
    b642:	b.n	b3ac <_malloc_r+0x170>
    b644:	add	r3, r1
    b646:	mov	r4, r1
    b648:	ldr	r2, [r3, #4]
    b64a:	ldr	r1, [r1, #12]
    b64c:	ldr.w	r5, [r4, #8]!
    b650:	orr.w	r2, r2, #1
    b654:	str	r2, [r3, #4]
    b656:	mov	r0, r6
    b658:	str	r1, [r5, #12]
    b65a:	str	r5, [r1, #8]
    b65c:	bl	b9b0 <__malloc_unlock>
    b660:	b.n	b3cc <_malloc_r+0x190>
    b662:	add.w	lr, r3, #92	; 0x5c
    b666:	add.w	r0, r3, #91	; 0x5b
    b66a:	mov.w	r3, lr, lsl #1
    b66e:	b.n	b280 <_malloc_r+0x44>
    b670:	lsrs	r2, r3, #6
    b672:	add.w	r1, r2, #57	; 0x39
    b676:	lsls	r1, r1, #1
    b678:	adds	r2, #56	; 0x38
    b67a:	b.n	b5c0 <_malloc_r+0x384>
    b67c:	cmp	r4, r7
    b67e:	ldr	r3, [pc, #296]	; (b7a8 <_malloc_r+0x56c>)
    b680:	beq.w	b484 <_malloc_r+0x248>
    b684:	ldr	r4, [r3, #8]
    b686:	ldr	r2, [r4, #4]
    b688:	bic.w	r2, r2, #3
    b68c:	b.n	b544 <_malloc_r+0x308>
    b68e:	ldr.w	r3, [r9], #-8
    b692:	cmp	r9, r3
    b694:	bne.w	b79c <_malloc_r+0x560>
    b698:	tst.w	r0, #3
    b69c:	add.w	r0, r0, #4294967295
    b6a0:	bne.n	b68e <_malloc_r+0x452>
    b6a2:	ldr	r3, [r7, #4]
    b6a4:	bic.w	r3, r3, r4
    b6a8:	str	r3, [r7, #4]
    b6aa:	lsls	r4, r4, #1
    b6ac:	cmp	r4, r3
    b6ae:	bhi.w	b42c <_malloc_r+0x1f0>
    b6b2:	cmp	r4, #0
    b6b4:	beq.w	b42c <_malloc_r+0x1f0>
    b6b8:	tst	r4, r3
    b6ba:	mov	r0, r8
    b6bc:	bne.w	b32a <_malloc_r+0xee>
    b6c0:	lsls	r4, r4, #1
    b6c2:	tst	r4, r3
    b6c4:	add.w	r0, r0, #4
    b6c8:	beq.n	b6c0 <_malloc_r+0x484>
    b6ca:	b.n	b32a <_malloc_r+0xee>
    b6cc:	cmp.w	r3, #340	; 0x154
    b6d0:	bhi.n	b704 <_malloc_r+0x4c8>
    b6d2:	lsrs	r0, r5, #15
    b6d4:	add.w	lr, r0, #120	; 0x78
    b6d8:	mov.w	r3, lr, lsl #1
    b6dc:	adds	r0, #119	; 0x77
    b6de:	b.n	b280 <_malloc_r+0x44>
    b6e0:	mov.w	r1, #4096	; 0x1000
    b6e4:	b.n	b4be <_malloc_r+0x282>
    b6e6:	movs	r1, #1
    b6e8:	ldr.w	r3, [r8, #4]
    b6ec:	asrs	r2, r2, #2
    b6ee:	lsl.w	r2, r1, r2
    b6f2:	orrs	r2, r3
    b6f4:	str.w	r2, [r8, #4]
    b6f8:	mov	r1, ip
    b6fa:	b.n	b5ec <_malloc_r+0x3b0>
    b6fc:	movs	r3, #1
    b6fe:	str.w	r3, [fp, #4]
    b702:	b.n	b550 <_malloc_r+0x314>
    b704:	movw	r2, #1364	; 0x554
    b708:	cmp	r3, r2
    b70a:	bhi.n	b74e <_malloc_r+0x512>
    b70c:	lsrs	r0, r5, #18
    b70e:	add.w	lr, r0, #125	; 0x7d
    b712:	mov.w	r3, lr, lsl #1
    b716:	adds	r0, #124	; 0x7c
    b718:	b.n	b280 <_malloc_r+0x44>
    b71a:	adds	r2, #16
    b71c:	b.n	b468 <_malloc_r+0x22c>
    b71e:	cmp	r2, #84	; 0x54
    b720:	bhi.n	b770 <_malloc_r+0x534>
    b722:	lsrs	r2, r3, #12
    b724:	add.w	r1, r2, #111	; 0x6f
    b728:	lsls	r1, r1, #1
    b72a:	adds	r2, #110	; 0x6e
    b72c:	b.n	b5c0 <_malloc_r+0x384>
    b72e:	ldr	r4, [r7, #8]
    b730:	ldr	r2, [r4, #4]
    b732:	bic.w	r2, r2, #3
    b736:	b.n	b544 <_malloc_r+0x308>
    b738:	ubfx	r0, sl, #0, #12
    b73c:	cmp	r0, #0
    b73e:	bne.w	b492 <_malloc_r+0x256>
    b742:	add	r2, r8
    b744:	ldr	r3, [r7, #8]
    b746:	orr.w	r2, r2, #1
    b74a:	str	r2, [r3, #4]
    b74c:	b.n	b528 <_malloc_r+0x2ec>
    b74e:	movs	r3, #254	; 0xfe
    b750:	mov.w	lr, #127	; 0x7f
    b754:	movs	r0, #126	; 0x7e
    b756:	b.n	b280 <_malloc_r+0x44>
    b758:	movs	r2, #1
    b75a:	mov.w	r9, #0
    b75e:	b.n	b4e4 <_malloc_r+0x2a8>
    b760:	add.w	r1, r4, #8
    b764:	mov	r0, r6
    b766:	bl	10790 <_free_r>
    b76a:	ldr.w	r1, [r9]
    b76e:	b.n	b528 <_malloc_r+0x2ec>
    b770:	cmp.w	r2, #340	; 0x154
    b774:	bhi.n	b782 <_malloc_r+0x546>
    b776:	lsrs	r2, r3, #15
    b778:	add.w	r1, r2, #120	; 0x78
    b77c:	lsls	r1, r1, #1
    b77e:	adds	r2, #119	; 0x77
    b780:	b.n	b5c0 <_malloc_r+0x384>
    b782:	movw	r1, #1364	; 0x554
    b786:	cmp	r2, r1
    b788:	bhi.n	b796 <_malloc_r+0x55a>
    b78a:	lsrs	r2, r3, #18
    b78c:	add.w	r1, r2, #125	; 0x7d
    b790:	lsls	r1, r1, #1
    b792:	adds	r2, #124	; 0x7c
    b794:	b.n	b5c0 <_malloc_r+0x384>
    b796:	movs	r1, #254	; 0xfe
    b798:	movs	r2, #126	; 0x7e
    b79a:	b.n	b5c0 <_malloc_r+0x384>
    b79c:	ldr	r3, [r7, #4]
    b79e:	b.n	b6aa <_malloc_r+0x46e>
    b7a0:	lsrs	r0, r5, #3
    b7a2:	adds	r3, r0, #1
    b7a4:	lsls	r3, r3, #1
    b7a6:	b.n	b39a <_malloc_r+0x15e>
    b7a8:	.word	0x1fff19b8

0000b7ac <__ascii_mbtowc>:
    b7ac:	sub	sp, #8
    b7ae:	cbz	r1, b7c4 <__ascii_mbtowc+0x18>
    b7b0:	cbz	r2, b7ca <__ascii_mbtowc+0x1e>
    b7b2:	cbz	r3, b7d0 <__ascii_mbtowc+0x24>
    b7b4:	ldrb	r3, [r2, #0]
    b7b6:	str	r3, [r1, #0]
    b7b8:	ldrb	r2, [r2, #0]
    b7ba:	adds	r0, r2, #0
    b7bc:	it	ne
    b7be:	movne	r0, #1
    b7c0:	add	sp, #8
    b7c2:	bx	lr
    b7c4:	add	r1, sp, #4
    b7c6:	cmp	r2, #0
    b7c8:	bne.n	b7b2 <__ascii_mbtowc+0x6>
    b7ca:	mov	r0, r2
    b7cc:	add	sp, #8
    b7ce:	bx	lr
    b7d0:	mvn.w	r0, #1
    b7d4:	b.n	b7c0 <__ascii_mbtowc+0x14>
    b7d6:	nop
    b7d8:			; <UNDEFINED> instruction: 0xffffffff
    b7dc:			; <UNDEFINED> instruction: 0xffffffff

0000b7e0 <memchr>:
    b7e0:	and.w	r1, r1, #255	; 0xff
    b7e4:	cmp	r2, #16
    b7e6:	blt.n	b840 <memchr+0x60>
    b7e8:	tst.w	r0, #7
    b7ec:	beq.n	b800 <memchr+0x20>
    b7ee:	ldrb.w	r3, [r0], #1
    b7f2:	subs	r2, #1
    b7f4:	cmp	r3, r1
    b7f6:	beq.n	b854 <memchr+0x74>
    b7f8:	tst.w	r0, #7
    b7fc:	cbz	r2, b850 <memchr+0x70>
    b7fe:	bne.n	b7ee <memchr+0xe>
    b800:	push	{r4, r5, r6, r7}
    b802:	orr.w	r1, r1, r1, lsl #8
    b806:	orr.w	r1, r1, r1, lsl #16
    b80a:	bic.w	r4, r2, #7
    b80e:	mvns.w	r7, #0
    b812:	movs	r3, #0
    b814:	ldrd	r5, r6, [r0], #8
    b818:	subs	r4, #8
    b81a:	eor.w	r5, r5, r1
    b81e:	eor.w	r6, r6, r1
    b822:	uadd8	r5, r5, r7
    b826:	sel	r5, r3, r7
    b82a:	uadd8	r6, r6, r7
    b82e:	sel	r6, r5, r7
    b832:	cbnz	r6, b858 <memchr+0x78>
    b834:	bne.n	b814 <memchr+0x34>
    b836:	pop	{r4, r5, r6, r7}
    b838:	and.w	r1, r1, #255	; 0xff
    b83c:	and.w	r2, r2, #7
    b840:	cbz	r2, b850 <memchr+0x70>
    b842:	ldrb.w	r3, [r0], #1
    b846:	subs	r2, #1
    b848:	eor.w	r3, r3, r1
    b84c:	cbz	r3, b854 <memchr+0x74>
    b84e:	bne.n	b842 <memchr+0x62>
    b850:	movs	r0, #0
    b852:	bx	lr
    b854:	subs	r0, #1
    b856:	bx	lr
    b858:	cmp	r5, #0
    b85a:	itte	eq
    b85c:	moveq	r5, r6
    b85e:	subeq	r0, #3
    b860:	subne	r0, #7
    b862:	tst.w	r5, #1
    b866:	bne.n	b878 <memchr+0x98>
    b868:	adds	r0, #1
    b86a:	tst.w	r5, #256	; 0x100
    b86e:	ittt	eq
    b870:	addeq	r0, #1
    b872:	tsteq.w	r5, #98304	; 0x18000
    b876:	addeq	r0, #1
    b878:	pop	{r4, r5, r6, r7}
    b87a:	subs	r0, #1
    b87c:	bx	lr
    b87e:	nop

0000b880 <memcmp>:
    b880:	cmp	r2, #3
    b882:	push	{r4, r5, r6}
    b884:	bls.n	b8d4 <memcmp+0x54>
    b886:	orr.w	r3, r0, r1
    b88a:	lsls	r3, r3, #30
    b88c:	beq.n	b8b2 <memcmp+0x32>
    b88e:	ldrb	r4, [r0, #0]
    b890:	ldrb	r5, [r1, #0]
    b892:	cmp	r4, r5
    b894:	bne.n	b8dc <memcmp+0x5c>
    b896:	add	r2, r0
    b898:	adds	r3, r0, #1
    b89a:	b.n	b8a8 <memcmp+0x28>
    b89c:	ldrb.w	r4, [r3], #1
    b8a0:	ldrb.w	r5, [r1, #1]!
    b8a4:	cmp	r4, r5
    b8a6:	bne.n	b8dc <memcmp+0x5c>
    b8a8:	cmp	r3, r2
    b8aa:	bne.n	b89c <memcmp+0x1c>
    b8ac:	movs	r0, #0
    b8ae:	pop	{r4, r5, r6}
    b8b0:	bx	lr
    b8b2:	mov	r4, r1
    b8b4:	mov	r3, r0
    b8b6:	ldr	r6, [r3, #0]
    b8b8:	ldr	r5, [r4, #0]
    b8ba:	cmp	r6, r5
    b8bc:	mov	r0, r3
    b8be:	mov	r1, r4
    b8c0:	add.w	r3, r3, #4
    b8c4:	add.w	r4, r4, #4
    b8c8:	bne.n	b88e <memcmp+0xe>
    b8ca:	subs	r2, #4
    b8cc:	cmp	r2, #3
    b8ce:	mov	r0, r3
    b8d0:	mov	r1, r4
    b8d2:	bhi.n	b8b6 <memcmp+0x36>
    b8d4:	cmp	r2, #0
    b8d6:	bne.n	b88e <memcmp+0xe>
    b8d8:	mov	r0, r2
    b8da:	b.n	b8ae <memcmp+0x2e>
    b8dc:	subs	r0, r4, r5
    b8de:	pop	{r4, r5, r6}
    b8e0:	bx	lr
    b8e2:	nop

0000b8e4 <memmove>:
    b8e4:	cmp	r0, r1
    b8e6:	push	{r4, r5, r6, r7, lr}
    b8e8:	bls.n	b906 <memmove+0x22>
    b8ea:	adds	r3, r1, r2
    b8ec:	cmp	r0, r3
    b8ee:	bcs.n	b906 <memmove+0x22>
    b8f0:	adds	r1, r0, r2
    b8f2:	cmp	r2, #0
    b8f4:	beq.n	b99a <memmove+0xb6>
    b8f6:	subs	r2, r3, r2
    b8f8:	ldrb.w	r4, [r3, #-1]!
    b8fc:	strb.w	r4, [r1, #-1]!
    b900:	cmp	r3, r2
    b902:	bne.n	b8f8 <memmove+0x14>
    b904:	pop	{r4, r5, r6, r7, pc}
    b906:	cmp	r2, #15
    b908:	bls.n	b99c <memmove+0xb8>
    b90a:	orr.w	r3, r1, r0
    b90e:	lsls	r3, r3, #30
    b910:	bne.n	b9a0 <memmove+0xbc>
    b912:	add.w	r4, r0, #16
    b916:	add.w	r3, r1, #16
    b91a:	mov	r5, r2
    b91c:	ldr.w	r6, [r3, #-16]
    b920:	str.w	r6, [r4, #-16]
    b924:	ldr.w	r6, [r3, #-12]
    b928:	str.w	r6, [r4, #-12]
    b92c:	ldr.w	r6, [r3, #-8]
    b930:	str.w	r6, [r4, #-8]
    b934:	subs	r5, #16
    b936:	ldr.w	r6, [r3, #-4]
    b93a:	str.w	r6, [r4, #-4]
    b93e:	cmp	r5, #15
    b940:	add.w	r3, r3, #16
    b944:	add.w	r4, r4, #16
    b948:	bhi.n	b91c <memmove+0x38>
    b94a:	sub.w	r3, r2, #16
    b94e:	bic.w	r3, r3, #15
    b952:	and.w	lr, r2, #15
    b956:	adds	r3, #16
    b958:	cmp.w	lr, #3
    b95c:	add	r1, r3
    b95e:	add	r3, r0
    b960:	bls.n	b9a6 <memmove+0xc2>
    b962:	subs	r6, r3, #4
    b964:	mov	r5, r1
    b966:	mov	r4, lr
    b968:	subs	r4, #4
    b96a:	ldr.w	r7, [r5], #4
    b96e:	str.w	r7, [r6, #4]!
    b972:	cmp	r4, #3
    b974:	bhi.n	b968 <memmove+0x84>
    b976:	sub.w	r4, lr, #4
    b97a:	bic.w	r4, r4, #3
    b97e:	adds	r4, #4
    b980:	add	r3, r4
    b982:	add	r1, r4
    b984:	and.w	r2, r2, #3
    b988:	cbz	r2, b9a4 <memmove+0xc0>
    b98a:	subs	r3, #1
    b98c:	add	r2, r1
    b98e:	ldrb.w	r4, [r1], #1
    b992:	strb.w	r4, [r3, #1]!
    b996:	cmp	r2, r1
    b998:	bne.n	b98e <memmove+0xaa>
    b99a:	pop	{r4, r5, r6, r7, pc}
    b99c:	mov	r3, r0
    b99e:	b.n	b988 <memmove+0xa4>
    b9a0:	mov	r3, r0
    b9a2:	b.n	b98a <memmove+0xa6>
    b9a4:	pop	{r4, r5, r6, r7, pc}
    b9a6:	mov	r2, lr
    b9a8:	b.n	b988 <memmove+0xa4>
    b9aa:	nop

0000b9ac <__malloc_lock>:
    b9ac:	bx	lr
    b9ae:	nop

0000b9b0 <__malloc_unlock>:
    b9b0:	bx	lr
    b9b2:	nop

0000b9b4 <_realloc_r>:
    b9b4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b9b8:	mov	r7, r2
    b9ba:	sub	sp, #12
    b9bc:	cmp	r1, #0
    b9be:	beq.w	bb44 <_realloc_r+0x190>
    b9c2:	mov	r6, r1
    b9c4:	mov	r9, r0
    b9c6:	add.w	r5, r7, #11
    b9ca:	bl	b9ac <__malloc_lock>
    b9ce:	ldr.w	lr, [r6, #-4]
    b9d2:	cmp	r5, #22
    b9d4:	bic.w	r4, lr, #3
    b9d8:	sub.w	r8, r6, #8
    b9dc:	bhi.n	ba60 <_realloc_r+0xac>
    b9de:	movs	r2, #16
    b9e0:	mov	r5, r2
    b9e2:	cmp	r7, r5
    b9e4:	bhi.n	ba6a <_realloc_r+0xb6>
    b9e6:	cmp	r4, r2
    b9e8:	bge.n	bad6 <_realloc_r+0x122>
    b9ea:	ldr	r3, [pc, #804]	; (bd10 <_realloc_r+0x35c>)
    b9ec:	ldr	r1, [r3, #8]
    b9ee:	add.w	r0, r8, r4
    b9f2:	cmp	r0, r1
    b9f4:	ldr	r1, [r0, #4]
    b9f6:	beq.w	bbac <_realloc_r+0x1f8>
    b9fa:	bic.w	r3, r1, #1
    b9fe:	add	r3, r0
    ba00:	ldr	r3, [r3, #4]
    ba02:	lsls	r3, r3, #31
    ba04:	bpl.n	bb02 <_realloc_r+0x14e>
    ba06:	tst.w	lr, #1
    ba0a:	beq.n	ba78 <_realloc_r+0xc4>
    ba0c:	mov	r1, r7
    ba0e:	mov	r0, r9
    ba10:	bl	b23c <_malloc_r>
    ba14:	mov	r7, r0
    ba16:	cbz	r0, ba52 <_realloc_r+0x9e>
    ba18:	ldr.w	r3, [r6, #-4]
    ba1c:	bic.w	r3, r3, #1
    ba20:	add	r3, r8
    ba22:	sub.w	r2, r0, #8
    ba26:	cmp	r2, r3
    ba28:	beq.w	bcb4 <_realloc_r+0x300>
    ba2c:	subs	r2, r4, #4
    ba2e:	cmp	r2, #36	; 0x24
    ba30:	bhi.w	bc96 <_realloc_r+0x2e2>
    ba34:	cmp	r2, #19
    ba36:	bhi.w	bc42 <_realloc_r+0x28e>
    ba3a:	mov	r3, r0
    ba3c:	mov	r2, r6
    ba3e:	ldr	r1, [r2, #0]
    ba40:	str	r1, [r3, #0]
    ba42:	ldr	r1, [r2, #4]
    ba44:	str	r1, [r3, #4]
    ba46:	ldr	r2, [r2, #8]
    ba48:	str	r2, [r3, #8]
    ba4a:	mov	r1, r6
    ba4c:	mov	r0, r9
    ba4e:	bl	10790 <_free_r>
    ba52:	mov	r0, r9
    ba54:	bl	b9b0 <__malloc_unlock>
    ba58:	mov	r0, r7
    ba5a:	add	sp, #12
    ba5c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ba60:	bic.w	r5, r5, #7
    ba64:	cmp	r5, #0
    ba66:	mov	r2, r5
    ba68:	bge.n	b9e2 <_realloc_r+0x2e>
    ba6a:	movs	r3, #12
    ba6c:	movs	r0, #0
    ba6e:	str.w	r3, [r9]
    ba72:	add	sp, #12
    ba74:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ba78:	ldr.w	r3, [r6, #-8]
    ba7c:	rsb	sl, r3, r8
    ba80:	ldr.w	r3, [sl, #4]
    ba84:	bic.w	ip, r3, #3
    ba88:	add.w	r3, r4, ip
    ba8c:	cmp	r3, r2
    ba8e:	blt.n	ba0c <_realloc_r+0x58>
    ba90:	mov	r7, sl
    ba92:	ldr.w	r1, [sl, #12]
    ba96:	ldr.w	r0, [r7, #8]!
    ba9a:	subs	r2, r4, #4
    ba9c:	cmp	r2, #36	; 0x24
    ba9e:	str	r1, [r0, #12]
    baa0:	str	r0, [r1, #8]
    baa2:	bhi.w	bcd4 <_realloc_r+0x320>
    baa6:	cmp	r2, #19
    baa8:	bls.w	bcd0 <_realloc_r+0x31c>
    baac:	ldr	r1, [r6, #0]
    baae:	str.w	r1, [sl, #8]
    bab2:	ldr	r1, [r6, #4]
    bab4:	str.w	r1, [sl, #12]
    bab8:	cmp	r2, #27
    baba:	bhi.w	bd14 <_realloc_r+0x360>
    babe:	adds	r6, #8
    bac0:	add.w	r2, sl, #16
    bac4:	ldr	r1, [r6, #0]
    bac6:	str	r1, [r2, #0]
    bac8:	ldr	r1, [r6, #4]
    baca:	str	r1, [r2, #4]
    bacc:	ldr	r1, [r6, #8]
    bace:	str	r1, [r2, #8]
    bad0:	mov	r6, r7
    bad2:	mov	r4, r3
    bad4:	mov	r8, sl
    bad6:	subs	r3, r4, r5
    bad8:	cmp	r3, #15
    bada:	bhi.n	bb18 <_realloc_r+0x164>
    badc:	ldr.w	r3, [r8, #4]
    bae0:	and.w	r3, r3, #1
    bae4:	orrs	r3, r4
    bae6:	add	r4, r8
    bae8:	str.w	r3, [r8, #4]
    baec:	ldr	r3, [r4, #4]
    baee:	orr.w	r3, r3, #1
    baf2:	str	r3, [r4, #4]
    baf4:	mov	r0, r9
    baf6:	bl	b9b0 <__malloc_unlock>
    bafa:	mov	r0, r6
    bafc:	add	sp, #12
    bafe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bb02:	bic.w	r1, r1, #3
    bb06:	add	r1, r4
    bb08:	cmp	r1, r2
    bb0a:	blt.n	bb50 <_realloc_r+0x19c>
    bb0c:	ldr	r3, [r0, #12]
    bb0e:	ldr	r2, [r0, #8]
    bb10:	mov	r4, r1
    bb12:	str	r3, [r2, #12]
    bb14:	str	r2, [r3, #8]
    bb16:	b.n	bad6 <_realloc_r+0x122>
    bb18:	ldr.w	r2, [r8, #4]
    bb1c:	add.w	r1, r8, r5
    bb20:	and.w	r2, r2, #1
    bb24:	orrs	r5, r2
    bb26:	orr.w	r2, r3, #1
    bb2a:	add	r3, r1
    bb2c:	str.w	r5, [r8, #4]
    bb30:	str	r2, [r1, #4]
    bb32:	ldr	r2, [r3, #4]
    bb34:	orr.w	r2, r2, #1
    bb38:	adds	r1, #8
    bb3a:	str	r2, [r3, #4]
    bb3c:	mov	r0, r9
    bb3e:	bl	10790 <_free_r>
    bb42:	b.n	baf4 <_realloc_r+0x140>
    bb44:	mov	r1, r2
    bb46:	add	sp, #12
    bb48:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bb4c:	b.w	b23c <_malloc_r>
    bb50:	tst.w	lr, #1
    bb54:	bne.w	ba0c <_realloc_r+0x58>
    bb58:	ldr.w	r3, [r6, #-8]
    bb5c:	rsb	sl, r3, r8
    bb60:	ldr.w	r3, [sl, #4]
    bb64:	bic.w	ip, r3, #3
    bb68:	add.w	lr, r1, ip
    bb6c:	cmp	lr, r2
    bb6e:	blt.n	ba88 <_realloc_r+0xd4>
    bb70:	ldr	r3, [r0, #12]
    bb72:	ldr	r2, [r0, #8]
    bb74:	mov	r7, sl
    bb76:	str	r3, [r2, #12]
    bb78:	str	r2, [r3, #8]
    bb7a:	ldr.w	r1, [r7, #8]!
    bb7e:	ldr.w	r3, [sl, #12]
    bb82:	str	r3, [r1, #12]
    bb84:	subs	r2, r4, #4
    bb86:	cmp	r2, #36	; 0x24
    bb88:	str	r1, [r3, #8]
    bb8a:	bhi.w	bcc0 <_realloc_r+0x30c>
    bb8e:	cmp	r2, #19
    bb90:	bls.n	bc58 <_realloc_r+0x2a4>
    bb92:	ldr	r3, [r6, #0]
    bb94:	str.w	r3, [sl, #8]
    bb98:	ldr	r3, [r6, #4]
    bb9a:	str.w	r3, [sl, #12]
    bb9e:	cmp	r2, #27
    bba0:	bhi.w	bce4 <_realloc_r+0x330>
    bba4:	adds	r6, #8
    bba6:	add.w	r3, sl, #16
    bbaa:	b.n	bc5a <_realloc_r+0x2a6>
    bbac:	bic.w	fp, r1, #3
    bbb0:	add	fp, r4
    bbb2:	add.w	r0, r5, #16
    bbb6:	cmp	fp, r0
    bbb8:	bge.n	bc6e <_realloc_r+0x2ba>
    bbba:	tst.w	lr, #1
    bbbe:	bne.w	ba0c <_realloc_r+0x58>
    bbc2:	ldr.w	r1, [r6, #-8]
    bbc6:	rsb	sl, r1, r8
    bbca:	ldr.w	r1, [sl, #4]
    bbce:	bic.w	ip, r1, #3
    bbd2:	add	fp, ip
    bbd4:	cmp	r0, fp
    bbd6:	bgt.w	ba88 <_realloc_r+0xd4>
    bbda:	mov	r7, sl
    bbdc:	ldr.w	r1, [sl, #12]
    bbe0:	ldr.w	r0, [r7, #8]!
    bbe4:	subs	r2, r4, #4
    bbe6:	cmp	r2, #36	; 0x24
    bbe8:	str	r1, [r0, #12]
    bbea:	str	r0, [r1, #8]
    bbec:	bhi.w	bd58 <_realloc_r+0x3a4>
    bbf0:	cmp	r2, #19
    bbf2:	bls.w	bd40 <_realloc_r+0x38c>
    bbf6:	ldr	r1, [r6, #0]
    bbf8:	str.w	r1, [sl, #8]
    bbfc:	ldr	r1, [r6, #4]
    bbfe:	str.w	r1, [sl, #12]
    bc02:	cmp	r2, #27
    bc04:	bhi.w	bd66 <_realloc_r+0x3b2>
    bc08:	adds	r6, #8
    bc0a:	add.w	r2, sl, #16
    bc0e:	ldr	r1, [r6, #0]
    bc10:	str	r1, [r2, #0]
    bc12:	ldr	r1, [r6, #4]
    bc14:	str	r1, [r2, #4]
    bc16:	ldr	r1, [r6, #8]
    bc18:	str	r1, [r2, #8]
    bc1a:	add.w	r1, sl, r5
    bc1e:	rsb	r2, r5, fp
    bc22:	orr.w	r2, r2, #1
    bc26:	str	r1, [r3, #8]
    bc28:	str	r2, [r1, #4]
    bc2a:	ldr.w	r3, [sl, #4]
    bc2e:	and.w	r3, r3, #1
    bc32:	orrs	r5, r3
    bc34:	mov	r0, r9
    bc36:	str.w	r5, [sl, #4]
    bc3a:	bl	b9b0 <__malloc_unlock>
    bc3e:	mov	r0, r7
    bc40:	b.n	bafc <_realloc_r+0x148>
    bc42:	ldr	r3, [r6, #0]
    bc44:	str	r3, [r0, #0]
    bc46:	ldr	r3, [r6, #4]
    bc48:	str	r3, [r0, #4]
    bc4a:	cmp	r2, #27
    bc4c:	bhi.n	bc9e <_realloc_r+0x2ea>
    bc4e:	add.w	r3, r0, #8
    bc52:	add.w	r2, r6, #8
    bc56:	b.n	ba3e <_realloc_r+0x8a>
    bc58:	mov	r3, r7
    bc5a:	ldr	r2, [r6, #0]
    bc5c:	str	r2, [r3, #0]
    bc5e:	ldr	r2, [r6, #4]
    bc60:	str	r2, [r3, #4]
    bc62:	ldr	r2, [r6, #8]
    bc64:	str	r2, [r3, #8]
    bc66:	mov	r6, r7
    bc68:	mov	r4, lr
    bc6a:	mov	r8, sl
    bc6c:	b.n	bad6 <_realloc_r+0x122>
    bc6e:	add.w	r1, r8, r5
    bc72:	rsb	fp, r5, fp
    bc76:	orr.w	r2, fp, #1
    bc7a:	str	r1, [r3, #8]
    bc7c:	str	r2, [r1, #4]
    bc7e:	ldr.w	r3, [r6, #-4]
    bc82:	and.w	r3, r3, #1
    bc86:	orrs	r5, r3
    bc88:	mov	r0, r9
    bc8a:	str.w	r5, [r6, #-4]
    bc8e:	bl	b9b0 <__malloc_unlock>
    bc92:	mov	r0, r6
    bc94:	b.n	bafc <_realloc_r+0x148>
    bc96:	mov	r1, r6
    bc98:	bl	b8e4 <memmove>
    bc9c:	b.n	ba4a <_realloc_r+0x96>
    bc9e:	ldr	r3, [r6, #8]
    bca0:	str	r3, [r0, #8]
    bca2:	ldr	r3, [r6, #12]
    bca4:	str	r3, [r0, #12]
    bca6:	cmp	r2, #36	; 0x24
    bca8:	beq.n	bcfc <_realloc_r+0x348>
    bcaa:	add.w	r3, r0, #16
    bcae:	add.w	r2, r6, #16
    bcb2:	b.n	ba3e <_realloc_r+0x8a>
    bcb4:	ldr.w	r3, [r0, #-4]
    bcb8:	bic.w	r3, r3, #3
    bcbc:	add	r4, r3
    bcbe:	b.n	bad6 <_realloc_r+0x122>
    bcc0:	mov	r1, r6
    bcc2:	mov	r0, r7
    bcc4:	mov	r4, lr
    bcc6:	mov	r8, sl
    bcc8:	bl	b8e4 <memmove>
    bccc:	mov	r6, r7
    bcce:	b.n	bad6 <_realloc_r+0x122>
    bcd0:	mov	r2, r7
    bcd2:	b.n	bac4 <_realloc_r+0x110>
    bcd4:	mov	r1, r6
    bcd6:	mov	r0, r7
    bcd8:	mov	r4, r3
    bcda:	mov	r8, sl
    bcdc:	bl	b8e4 <memmove>
    bce0:	mov	r6, r7
    bce2:	b.n	bad6 <_realloc_r+0x122>
    bce4:	ldr	r3, [r6, #8]
    bce6:	str.w	r3, [sl, #16]
    bcea:	ldr	r3, [r6, #12]
    bcec:	str.w	r3, [sl, #20]
    bcf0:	cmp	r2, #36	; 0x24
    bcf2:	beq.n	bd2c <_realloc_r+0x378>
    bcf4:	adds	r6, #16
    bcf6:	add.w	r3, sl, #24
    bcfa:	b.n	bc5a <_realloc_r+0x2a6>
    bcfc:	ldr	r3, [r6, #16]
    bcfe:	str	r3, [r0, #16]
    bd00:	ldr	r3, [r6, #20]
    bd02:	str	r3, [r0, #20]
    bd04:	add.w	r2, r6, #24
    bd08:	add.w	r3, r0, #24
    bd0c:	b.n	ba3e <_realloc_r+0x8a>
    bd0e:	nop
    bd10:	.word	0x1fff19b8
    bd14:	ldr	r1, [r6, #8]
    bd16:	str.w	r1, [sl, #16]
    bd1a:	ldr	r1, [r6, #12]
    bd1c:	str.w	r1, [sl, #20]
    bd20:	cmp	r2, #36	; 0x24
    bd22:	beq.n	bd44 <_realloc_r+0x390>
    bd24:	adds	r6, #16
    bd26:	add.w	r2, sl, #24
    bd2a:	b.n	bac4 <_realloc_r+0x110>
    bd2c:	ldr	r3, [r6, #16]
    bd2e:	str.w	r3, [sl, #24]
    bd32:	ldr	r3, [r6, #20]
    bd34:	str.w	r3, [sl, #28]
    bd38:	adds	r6, #24
    bd3a:	add.w	r3, sl, #32
    bd3e:	b.n	bc5a <_realloc_r+0x2a6>
    bd40:	mov	r2, r7
    bd42:	b.n	bc0e <_realloc_r+0x25a>
    bd44:	ldr	r2, [r6, #16]
    bd46:	str.w	r2, [sl, #24]
    bd4a:	ldr	r2, [r6, #20]
    bd4c:	str.w	r2, [sl, #28]
    bd50:	adds	r6, #24
    bd52:	add.w	r2, sl, #32
    bd56:	b.n	bac4 <_realloc_r+0x110>
    bd58:	mov	r1, r6
    bd5a:	mov	r0, r7
    bd5c:	str	r3, [sp, #4]
    bd5e:	bl	b8e4 <memmove>
    bd62:	ldr	r3, [sp, #4]
    bd64:	b.n	bc1a <_realloc_r+0x266>
    bd66:	ldr	r1, [r6, #8]
    bd68:	str.w	r1, [sl, #16]
    bd6c:	ldr	r1, [r6, #12]
    bd6e:	str.w	r1, [sl, #20]
    bd72:	cmp	r2, #36	; 0x24
    bd74:	beq.n	bd7e <_realloc_r+0x3ca>
    bd76:	adds	r6, #16
    bd78:	add.w	r2, sl, #24
    bd7c:	b.n	bc0e <_realloc_r+0x25a>
    bd7e:	ldr	r2, [r6, #16]
    bd80:	str.w	r2, [sl, #24]
    bd84:	ldr	r2, [r6, #20]
    bd86:	str.w	r2, [sl, #28]
    bd8a:	adds	r6, #24
    bd8c:	add.w	r2, sl, #32
    bd90:	b.n	bc0e <_realloc_r+0x25a>
    bd92:	nop

0000bd94 <_sbrk_r>:
    bd94:	push	{r3, r4, r5, lr}
    bd96:	ldr	r4, [pc, #28]	; (bdb4 <_sbrk_r+0x20>)
    bd98:	movs	r3, #0
    bd9a:	mov	r5, r0
    bd9c:	mov	r0, r1
    bd9e:	str	r3, [r4, #0]
    bda0:	bl	9304 <_sbrk>
    bda4:	adds	r3, r0, #1
    bda6:	beq.n	bdaa <_sbrk_r+0x16>
    bda8:	pop	{r3, r4, r5, pc}
    bdaa:	ldr	r3, [r4, #0]
    bdac:	cmp	r3, #0
    bdae:	beq.n	bda8 <_sbrk_r+0x14>
    bdb0:	str	r3, [r5, #0]
    bdb2:	pop	{r3, r4, r5, pc}
    bdb4:	.word	0x2001d080

0000bdb8 <sprintf>:
    bdb8:	push	{r1, r2, r3}
    bdba:	push	{r4, r5, r6, r7, lr}
    bdbc:	sub	sp, #112	; 0x70
    bdbe:	add	r3, sp, #132	; 0x84
    bdc0:	ldr	r1, [pc, #60]	; (be00 <sprintf+0x48>)
    bdc2:	ldr.w	r2, [r3], #4
    bdc6:	str	r3, [sp, #4]
    bdc8:	mov	r5, r0
    bdca:	mvn.w	r4, #2147483648	; 0x80000000
    bdce:	ldr	r0, [r1, #0]
    bdd0:	str	r5, [sp, #8]
    bdd2:	mov.w	r7, #520	; 0x208
    bdd6:	movw	r6, #65535	; 0xffff
    bdda:	add	r1, sp, #8
    bddc:	str	r5, [sp, #24]
    bdde:	strh.w	r7, [sp, #20]
    bde2:	str	r4, [sp, #16]
    bde4:	str	r4, [sp, #28]
    bde6:	strh.w	r6, [sp, #22]
    bdea:	bl	d090 <_svfprintf_r>
    bdee:	ldr	r3, [sp, #8]
    bdf0:	movs	r2, #0
    bdf2:	strb	r2, [r3, #0]
    bdf4:	add	sp, #112	; 0x70
    bdf6:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    bdfa:	add	sp, #12
    bdfc:	bx	lr
    bdfe:	nop
    be00:	.word	0x1fff1848

0000be04 <sscanf>:
    be04:	push	{r1, r2, r3}
    be06:	push	{r4, r5, r6, r7, lr}
    be08:	sub	sp, #112	; 0x70
    be0a:	add	r4, sp, #132	; 0x84
    be0c:	mov.w	r2, #516	; 0x204
    be10:	ldr.w	r6, [r4], #4
    be14:	strh.w	r2, [sp, #20]
    be18:	str	r0, [sp, #8]
    be1a:	str	r0, [sp, #24]
    be1c:	bl	be80 <strlen>
    be20:	ldr	r3, [pc, #48]	; (be54 <sscanf+0x50>)
    be22:	str	r4, [sp, #4]
    be24:	mov	r5, r0
    be26:	mov	r2, r6
    be28:	ldr	r7, [pc, #44]	; (be58 <sscanf+0x54>)
    be2a:	ldr	r0, [r3, #0]
    be2c:	str	r5, [sp, #12]
    be2e:	mov	r3, r4
    be30:	movw	r6, #65535	; 0xffff
    be34:	movs	r4, #0
    be36:	add	r1, sp, #8
    be38:	str	r5, [sp, #28]
    be3a:	str	r7, [sp, #40]	; 0x28
    be3c:	str	r4, [sp, #56]	; 0x38
    be3e:	str	r4, [sp, #76]	; 0x4c
    be40:	strh.w	r6, [sp, #22]
    be44:	bl	e774 <__ssvfscanf_r>
    be48:	add	sp, #112	; 0x70
    be4a:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    be4e:	add	sp, #12
    be50:	bx	lr
    be52:	nop
    be54:	.word	0x1fff1848
    be58:	.word	0x0000be5d

0000be5c <__seofread>:
    be5c:	movs	r0, #0
    be5e:	bx	lr
    be60:			; <UNDEFINED> instruction: 0xffffffff
    be64:			; <UNDEFINED> instruction: 0xffffffff
    be68:			; <UNDEFINED> instruction: 0xffffffff
    be6c:			; <UNDEFINED> instruction: 0xffffffff
    be70:			; <UNDEFINED> instruction: 0xffffffff
    be74:			; <UNDEFINED> instruction: 0xffffffff
    be78:			; <UNDEFINED> instruction: 0xffffffff
    be7c:			; <UNDEFINED> instruction: 0xffffffff

0000be80 <strlen>:
    be80:	pld	[r0]
    be84:	strd	r4, r5, [sp, #-8]!
    be88:	bic.w	r1, r0, #7
    be8c:	mvn.w	ip, #0
    be90:	ands.w	r4, r0, #7
    be94:	pld	[r1, #32]
    be98:	bne.w	bf2e <strlen+0xae>
    be9c:	mov.w	r4, #0
    bea0:	mvn.w	r0, #7
    bea4:	ldrd	r2, r3, [r1]
    bea8:	pld	[r1, #64]	; 0x40
    beac:	add.w	r0, r0, #8
    beb0:	uadd8	r2, r2, ip
    beb4:	sel	r2, r4, ip
    beb8:	uadd8	r3, r3, ip
    bebc:	sel	r3, r2, ip
    bec0:	cbnz	r3, bf16 <strlen+0x96>
    bec2:	ldrd	r2, r3, [r1, #8]
    bec6:	uadd8	r2, r2, ip
    beca:	add.w	r0, r0, #8
    bece:	sel	r2, r4, ip
    bed2:	uadd8	r3, r3, ip
    bed6:	sel	r3, r2, ip
    beda:	cbnz	r3, bf16 <strlen+0x96>
    bedc:	ldrd	r2, r3, [r1, #16]
    bee0:	uadd8	r2, r2, ip
    bee4:	add.w	r0, r0, #8
    bee8:	sel	r2, r4, ip
    beec:	uadd8	r3, r3, ip
    bef0:	sel	r3, r2, ip
    bef4:	cbnz	r3, bf16 <strlen+0x96>
    bef6:	ldrd	r2, r3, [r1, #24]
    befa:	add.w	r1, r1, #32
    befe:	uadd8	r2, r2, ip
    bf02:	add.w	r0, r0, #8
    bf06:	sel	r2, r4, ip
    bf0a:	uadd8	r3, r3, ip
    bf0e:	sel	r3, r2, ip
    bf12:	cmp	r3, #0
    bf14:	beq.n	bea4 <strlen+0x24>
    bf16:	cmp	r2, #0
    bf18:	itt	eq
    bf1a:	addeq	r0, #4
    bf1c:	moveq	r2, r3
    bf1e:	rev	r2, r2
    bf20:	clz	r2, r2
    bf24:	ldrd	r4, r5, [sp], #8
    bf28:	add.w	r0, r0, r2, lsr #3
    bf2c:	bx	lr
    bf2e:	ldrd	r2, r3, [r1]
    bf32:	and.w	r5, r4, #3
    bf36:	rsb	r0, r4, #0
    bf3a:	mov.w	r5, r5, lsl #3
    bf3e:	tst.w	r4, #4
    bf42:	pld	[r1, #64]	; 0x40
    bf46:	lsl.w	r5, ip, r5
    bf4a:	orn	r2, r2, r5
    bf4e:	itt	ne
    bf50:	ornne	r3, r3, r5
    bf54:	movne	r2, ip
    bf56:	mov.w	r4, #0
    bf5a:	b.n	beb0 <strlen+0x30>

0000bf5c <strncmp>:
    bf5c:	cmp	r2, #0
    bf5e:	beq.n	bfe4 <strncmp+0x88>
    bf60:	orr.w	r3, r0, r1
    bf64:	ands.w	r3, r3, #3
    bf68:	push	{r4, r5, r6, r7}
    bf6a:	bne.n	bfb8 <strncmp+0x5c>
    bf6c:	cmp	r2, #3
    bf6e:	bls.n	bfb8 <strncmp+0x5c>
    bf70:	ldr	r4, [r0, #0]
    bf72:	ldr	r5, [r1, #0]
    bf74:	cmp	r4, r5
    bf76:	bne.n	bfb8 <strncmp+0x5c>
    bf78:	subs	r2, #4
    bf7a:	beq.n	bfe8 <strncmp+0x8c>
    bf7c:	sub.w	r5, r4, #16843009	; 0x1010101
    bf80:	bic.w	r4, r5, r4
    bf84:	tst.w	r4, #2155905152	; 0x80808080
    bf88:	bne.n	bfee <strncmp+0x92>
    bf8a:	adds	r7, r0, #4
    bf8c:	adds	r5, r1, #4
    bf8e:	b.n	bfac <strncmp+0x50>
    bf90:	ldr.w	r3, [r7], #4
    bf94:	ldr	r6, [r1, #0]
    bf96:	sub.w	r4, r3, #16843009	; 0x1010101
    bf9a:	cmp	r3, r6
    bf9c:	bic.w	r4, r4, r3
    bfa0:	bne.n	bfb8 <strncmp+0x5c>
    bfa2:	subs	r2, #4
    bfa4:	beq.n	bfe8 <strncmp+0x8c>
    bfa6:	tst.w	r4, #2155905152	; 0x80808080
    bfaa:	bne.n	bff4 <strncmp+0x98>
    bfac:	cmp	r2, #3
    bfae:	mov	r1, r5
    bfb0:	mov	r0, r7
    bfb2:	add.w	r5, r5, #4
    bfb6:	bhi.n	bf90 <strncmp+0x34>
    bfb8:	ldrb	r3, [r0, #0]
    bfba:	ldrb	r4, [r1, #0]
    bfbc:	cmp	r4, r3
    bfbe:	add.w	r2, r2, #4294967295
    bfc2:	bne.n	bfde <strncmp+0x82>
    bfc4:	cbz	r2, bfe8 <strncmp+0x8c>
    bfc6:	cbnz	r4, bfce <strncmp+0x72>
    bfc8:	b.n	bff8 <strncmp+0x9c>
    bfca:	cbz	r2, bfe8 <strncmp+0x8c>
    bfcc:	cbz	r3, bfee <strncmp+0x92>
    bfce:	ldrb.w	r3, [r0, #1]!
    bfd2:	ldrb.w	r4, [r1, #1]!
    bfd6:	cmp	r3, r4
    bfd8:	add.w	r2, r2, #4294967295
    bfdc:	beq.n	bfca <strncmp+0x6e>
    bfde:	subs	r0, r3, r4
    bfe0:	pop	{r4, r5, r6, r7}
    bfe2:	bx	lr
    bfe4:	mov	r0, r2
    bfe6:	bx	lr
    bfe8:	mov	r0, r2
    bfea:	pop	{r4, r5, r6, r7}
    bfec:	bx	lr
    bfee:	mov	r0, r3
    bff0:	pop	{r4, r5, r6, r7}
    bff2:	bx	lr
    bff4:	movs	r0, #0
    bff6:	b.n	bfe0 <strncmp+0x84>
    bff8:	mov	r0, r4
    bffa:	b.n	bfe0 <strncmp+0x84>

0000bffc <sulp>:
    bffc:	push	{r4, r5, r6, lr}
    bffe:	mov	r4, r0
    c000:	mov	r5, r1
    c002:	vmov	d0, r4, r5
    c006:	mov	r6, r2
    c008:	bl	11760 <__ulp>
    c00c:	vmov	r0, r1, d0
    c010:	cbz	r6, c032 <sulp+0x36>
    c012:	ubfx	r3, r5, #20, #11
    c016:	rsb	r3, r3, #107	; 0x6b
    c01a:	cmp	r3, #0
    c01c:	ble.n	c032 <sulp+0x36>
    c01e:	lsls	r3, r3, #20
    c020:	add.w	r5, r3, #1069547520	; 0x3fc00000
    c024:	movs	r4, #0
    c026:	add.w	r5, r5, #3145728	; 0x300000
    c02a:	mov	r2, r4
    c02c:	mov	r3, r5
    c02e:	bl	a7bc <__aeabi_dmul>
    c032:	pop	{r4, r5, r6, pc}
    c034:			; <UNDEFINED> instruction: 0xffffffff

0000c038 <_strtod_l>:
    c038:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c03c:	mov	r5, r3
    c03e:	sub	sp, #132	; 0x84
    c040:	movs	r3, #0
    c042:	mov	fp, r0
    c044:	mov	r0, r5
    c046:	mov	r6, r1
    c048:	str	r2, [sp, #24]
    c04a:	str	r3, [sp, #112]	; 0x70
    c04c:	bl	110e4 <__localeconv_l>
    c050:	movs	r4, #0
    c052:	movs	r3, #0
    c054:	mov	sl, r0
    c056:	ldr	r0, [r0, #0]
    c058:	strd	r3, r4, [sp, #16]
    c05c:	bl	be80 <strlen>
    c060:	str	r6, [sp, #108]	; 0x6c
    c062:	mov	r9, r0
    c064:	mov	r2, r6
    c066:	mov	r4, r2
    c068:	ldrb.w	r7, [r2], #1
    c06c:	cmp	r7, #45	; 0x2d
    c06e:	bhi.w	c1d0 <_strtod_l+0x198>
    c072:	tbb	[pc, r7]
    c076:	.short	0xad17
    c078:	.word	0xadadadad
    c07c:	.word	0x81adadad
    c080:	.word	0x81818181
    c084:	.word	0xadadadad
    c088:	.word	0xadadadad
    c08c:	.word	0xadadadad
    c090:	.word	0xadadadad
    c094:	.word	0xad81adad
    c098:	.word	0xadadadad
    c09c:	.word	0xadadadad
    c0a0:	.word	0x7ead2bad
    c0a4:	ldr	r3, [sp, #24]
    c0a6:	mov.w	r8, #0
    c0aa:	mov.w	r9, #0
    c0ae:	cbz	r3, c0c2 <_strtod_l+0x8a>
    c0b0:	movs	r3, #0
    c0b2:	str	r3, [sp, #28]
    c0b4:	ldr	r3, [sp, #24]
    c0b6:	str	r6, [r3, #0]
    c0b8:	ldr	r3, [sp, #28]
    c0ba:	cbz	r3, c0c2 <_strtod_l+0x8a>
    c0bc:	add.w	r3, r9, #2147483648	; 0x80000000
    c0c0:	mov	r9, r3
    c0c2:	vmov	d0, r8, r9
    c0c6:	add	sp, #132	; 0x84
    c0c8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c0cc:	movs	r3, #0
    c0ce:	str	r3, [sp, #28]
    c0d0:	adds	r2, r4, #1
    c0d2:	str	r2, [sp, #108]	; 0x6c
    c0d4:	ldrb	r7, [r4, #1]
    c0d6:	cmp	r7, #0
    c0d8:	beq.n	c0a4 <_strtod_l+0x6c>
    c0da:	cmp	r7, #48	; 0x30
    c0dc:	mov	r4, r2
    c0de:	beq.n	c1d8 <_strtod_l+0x1a0>
    c0e0:	movs	r3, #0
    c0e2:	str	r4, [sp, #32]
    c0e4:	str	r3, [sp, #40]	; 0x28
    c0e6:	sub.w	r3, r7, #48	; 0x30
    c0ea:	cmp	r3, #9
    c0ec:	bhi.w	c8fe <_strtod_l+0x8c6>
    c0f0:	mov.w	r8, #0
    c0f4:	mov	r0, r4
    c0f6:	mov	r5, r8
    c0f8:	mov	r4, r8
    c0fa:	cmp	r4, #8
    c0fc:	it	gt
    c0fe:	addgt.w	r8, r8, r8, lsl #2
    c102:	add.w	r3, r5, r5, lsl #2
    c106:	add.w	r0, r0, #1
    c10a:	add.w	r3, r7, r3, lsl #1
    c10e:	str	r0, [sp, #108]	; 0x6c
    c110:	itt	gt
    c112:	addgt.w	r7, r7, r8, lsl #1
    c116:	subgt.w	r8, r7, #48	; 0x30
    c11a:	ldrb	r7, [r0, #0]
    c11c:	it	le
    c11e:	suble.w	r5, r3, #48	; 0x30
    c122:	sub.w	r3, r7, #48	; 0x30
    c126:	cmp	r3, #9
    c128:	add.w	r4, r4, #1
    c12c:	bls.n	c0fa <_strtod_l+0xc2>
    c12e:	ldr.w	r1, [sl]
    c132:	mov	r2, r9
    c134:	bl	bf5c <strncmp>
    c138:	cbz	r0, c17c <_strtod_l+0x144>
    c13a:	movs	r0, #0
    c13c:	mov	r3, r7
    c13e:	mov	r9, r0
    c140:	mov	r7, r0
    c142:	mov	sl, r4
    c144:	cmp	r3, #101	; 0x65
    c146:	beq.w	c2ae <_strtod_l+0x276>
    c14a:	cmp	r3, #69	; 0x45
    c14c:	beq.w	c2ae <_strtod_l+0x276>
    c150:	movs	r2, #0
    c152:	cmp	r4, #0
    c154:	bne.n	c1fc <_strtod_l+0x1c4>
    c156:	cbnz	r0, c160 <_strtod_l+0x128>
    c158:	ldr	r2, [sp, #40]	; 0x28
    c15a:	cmp	r2, #0
    c15c:	beq.w	c702 <_strtod_l+0x6ca>
    c160:	mov.w	r8, #0
    c164:	mov.w	r9, #0
    c168:	ldr	r3, [sp, #24]
    c16a:	cmp	r3, #0
    c16c:	beq.n	c0b8 <_strtod_l+0x80>
    c16e:	ldr	r6, [sp, #108]	; 0x6c
    c170:	b.n	c0b4 <_strtod_l+0x7c>
    c172:	movs	r3, #1
    c174:	str	r3, [sp, #28]
    c176:	b.n	c0d0 <_strtod_l+0x98>
    c178:	str	r2, [sp, #108]	; 0x6c
    c17a:	b.n	c066 <_strtod_l+0x2e>
    c17c:	ldr	r3, [sp, #108]	; 0x6c
    c17e:	add.w	r2, r3, r9
    c182:	str	r2, [sp, #108]	; 0x6c
    c184:	ldrb.w	r3, [r3, r9]
    c188:	mov	r7, r0
    c18a:	mov	sl, r4
    c18c:	sub.w	r2, r3, #48	; 0x30
    c190:	cmp	r2, #9
    c192:	bhi.w	c688 <_strtod_l+0x650>
    c196:	adds	r1, r0, #1
    c198:	mov	r3, r2
    c19a:	cmp	r2, #0
    c19c:	beq.w	cede <_strtod_l+0xea6>
    c1a0:	cmp	r1, #1
    c1a2:	add	r7, r1
    c1a4:	it	ne
    c1a6:	addne	r0, r0, r4
    c1a8:	bne.n	c1b6 <_strtod_l+0x17e>
    c1aa:	b.w	ced6 <_strtod_l+0xe9e>
    c1ae:	lsls	r5, r1, #1
    c1b0:	cmp	r4, r0
    c1b2:	beq.w	cb2c <_strtod_l+0xaf4>
    c1b6:	adds	r4, #1
    c1b8:	subs	r1, r4, #1
    c1ba:	cmp	r1, #8
    c1bc:	add.w	r1, r5, r5, lsl #2
    c1c0:	ble.n	c1ae <_strtod_l+0x176>
    c1c2:	cmp	r4, #16
    c1c4:	itt	le
    c1c6:	addle.w	r8, r8, r8, lsl #2
    c1ca:	movle.w	r8, r8, lsl #1
    c1ce:	b.n	c1b0 <_strtod_l+0x178>
    c1d0:	movs	r3, #0
    c1d2:	cmp	r7, #48	; 0x30
    c1d4:	str	r3, [sp, #28]
    c1d6:	bne.n	c0e0 <_strtod_l+0xa8>
    c1d8:	ldrb	r3, [r4, #1]
    c1da:	cmp	r3, #88	; 0x58
    c1dc:	beq.w	c8c6 <_strtod_l+0x88e>
    c1e0:	cmp	r3, #120	; 0x78
    c1e2:	beq.w	c8c6 <_strtod_l+0x88e>
    c1e6:	adds	r4, #1
    c1e8:	str	r4, [sp, #108]	; 0x6c
    c1ea:	ldrb	r7, [r4, #0]
    c1ec:	cmp	r7, #48	; 0x30
    c1ee:	beq.n	c1e6 <_strtod_l+0x1ae>
    c1f0:	cmp	r7, #0
    c1f2:	beq.n	c160 <_strtod_l+0x128>
    c1f4:	movs	r3, #1
    c1f6:	str	r4, [sp, #32]
    c1f8:	str	r3, [sp, #40]	; 0x28
    c1fa:	b.n	c0e6 <_strtod_l+0xae>
    c1fc:	cmp	r4, #16
    c1fe:	sub.w	r3, r2, r7
    c202:	mov	r0, r5
    c204:	mov	r9, r4
    c206:	str	r3, [sp, #44]	; 0x2c
    c208:	it	ge
    c20a:	movge.w	r9, #16
    c20e:	bl	a6d0 <__aeabi_ui2d>
    c212:	cmp.w	sl, #0
    c216:	it	eq
    c218:	moveq	sl, r4
    c21a:	cmp.w	r9, #9
    c21e:	strd	r0, r1, [sp, #16]
    c222:	ble.n	c24c <_strtod_l+0x214>
    c224:	ldr	r3, [pc, #292]	; (c34c <_strtod_l+0x314>)
    c226:	add.w	r3, r3, r9, lsl #3
    c22a:	ldrd	r2, r3, [r3, #-72]	; 0x48
    c22e:	bl	a7bc <__aeabi_dmul>
    c232:	mov	r6, r0
    c234:	mov	r0, r8
    c236:	mov	r7, r1
    c238:	bl	a6d0 <__aeabi_ui2d>
    c23c:	mov	r2, r0
    c23e:	mov	r3, r1
    c240:	mov	r0, r6
    c242:	mov	r1, r7
    c244:	bl	a458 <__adddf3>
    c248:	strd	r0, r1, [sp, #16]
    c24c:	cmp	r4, #15
    c24e:	bgt.w	c35c <_strtod_l+0x324>
    c252:	ldr	r3, [sp, #44]	; 0x2c
    c254:	cmp	r3, #0
    c256:	beq.n	c2a8 <_strtod_l+0x270>
    c258:	ble.w	cc94 <_strtod_l+0xc5c>
    c25c:	ldr	r3, [sp, #44]	; 0x2c
    c25e:	cmp	r3, #22
    c260:	bgt.w	cb60 <_strtod_l+0xb28>
    c264:	ldr	r7, [pc, #228]	; (c34c <_strtod_l+0x314>)
    c266:	add.w	r7, r7, r3, lsl #3
    c26a:	ldrd	r0, r1, [r7]
    c26e:	ldrd	r2, r3, [sp, #16]
    c272:	bl	a7bc <__aeabi_dmul>
    c276:	mov	r8, r0
    c278:	mov	r9, r1
    c27a:	b.n	c168 <_strtod_l+0x130>
    c27c:	add	r0, sp, #108	; 0x6c
    c27e:	ldr	r1, [pc, #208]	; (c350 <_strtod_l+0x318>)
    c280:	bl	10f18 <__match>
    c284:	cmp	r0, #0
    c286:	beq.w	c0a4 <_strtod_l+0x6c>
    c28a:	ldr	r3, [sp, #108]	; 0x6c
    c28c:	ldr	r1, [pc, #196]	; (c354 <_strtod_l+0x31c>)
    c28e:	subs	r3, #1
    c290:	add	r0, sp, #108	; 0x6c
    c292:	str	r3, [sp, #108]	; 0x6c
    c294:	bl	10f18 <__match>
    c298:	cbnz	r0, c2a0 <_strtod_l+0x268>
    c29a:	ldr	r3, [sp, #108]	; 0x6c
    c29c:	adds	r3, #1
    c29e:	str	r3, [sp, #108]	; 0x6c
    c2a0:	ldr	r3, [pc, #180]	; (c358 <_strtod_l+0x320>)
    c2a2:	str	r3, [sp, #20]
    c2a4:	movs	r3, #0
    c2a6:	str	r3, [sp, #16]
    c2a8:	ldrd	r8, r9, [sp, #16]
    c2ac:	b.n	c168 <_strtod_l+0x130>
    c2ae:	cmp	r4, #0
    c2b0:	beq.w	c648 <_strtod_l+0x610>
    c2b4:	ldr	r6, [sp, #108]	; 0x6c
    c2b6:	adds	r3, r6, #1
    c2b8:	str	r3, [sp, #108]	; 0x6c
    c2ba:	ldrb	r3, [r6, #1]
    c2bc:	cmp	r3, #43	; 0x2b
    c2be:	beq.w	c87c <_strtod_l+0x844>
    c2c2:	cmp	r3, #45	; 0x2d
    c2c4:	beq.w	c6f2 <_strtod_l+0x6ba>
    c2c8:	mov.w	ip, #0
    c2cc:	sub.w	r2, r3, #48	; 0x30
    c2d0:	cmp	r2, #9
    c2d2:	bhi.w	c876 <_strtod_l+0x83e>
    c2d6:	cmp	r3, #48	; 0x30
    c2d8:	bne.n	c2e6 <_strtod_l+0x2ae>
    c2da:	ldr	r2, [sp, #108]	; 0x6c
    c2dc:	adds	r2, #1
    c2de:	str	r2, [sp, #108]	; 0x6c
    c2e0:	ldrb	r3, [r2, #0]
    c2e2:	cmp	r3, #48	; 0x30
    c2e4:	beq.n	c2dc <_strtod_l+0x2a4>
    c2e6:	sub.w	r2, r3, #49	; 0x31
    c2ea:	cmp	r2, #8
    c2ec:	bhi.w	c150 <_strtod_l+0x118>
    c2f0:	ldr	r2, [sp, #108]	; 0x6c
    c2f2:	str	r2, [sp, #48]	; 0x30
    c2f4:	adds	r1, r2, #1
    c2f6:	subs	r3, #48	; 0x30
    c2f8:	str	r1, [sp, #108]	; 0x6c
    c2fa:	str	r3, [sp, #44]	; 0x2c
    c2fc:	ldrb	r3, [r2, #1]
    c2fe:	sub.w	lr, r3, #48	; 0x30
    c302:	cmp.w	lr, #9
    c306:	bhi.n	c328 <_strtod_l+0x2f0>
    c308:	ldr	r2, [sp, #44]	; 0x2c
    c30a:	adds	r1, #1
    c30c:	str	r1, [sp, #108]	; 0x6c
    c30e:	add.w	r2, r2, r2, lsl #2
    c312:	add.w	r2, r3, r2, lsl #1
    c316:	ldrb	r3, [r1, #0]
    c318:	sub.w	lr, r3, #48	; 0x30
    c31c:	cmp.w	lr, #9
    c320:	sub.w	r2, r2, #48	; 0x30
    c324:	bls.n	c30a <_strtod_l+0x2d2>
    c326:	str	r2, [sp, #44]	; 0x2c
    c328:	ldr	r2, [sp, #48]	; 0x30
    c32a:	subs	r1, r1, r2
    c32c:	cmp	r1, #8
    c32e:	bgt.w	cb4e <_strtod_l+0xb16>
    c332:	ldr	r2, [sp, #44]	; 0x2c
    c334:	movw	r1, #19999	; 0x4e1f
    c338:	cmp	r2, r1
    c33a:	it	ge
    c33c:	movge	r2, r1
    c33e:	cmp.w	ip, #0
    c342:	beq.w	c152 <_strtod_l+0x11a>
    c346:	negs	r2, r2
    c348:	b.n	c152 <_strtod_l+0x11a>
    c34a:	nop
    c34c:	.word	0x00013320
    c350:	.word	0x0001302c
    c354:	.word	0x00013030
    c358:	.word	0x7ff00000
    c35c:	ldr	r3, [sp, #44]	; 0x2c
    c35e:	rsb	r9, r9, r4
    c362:	add	r9, r3
    c364:	cmp.w	r9, #0
    c368:	ble.w	ca7a <_strtod_l+0xa42>
    c36c:	ands.w	r1, r9, #15
    c370:	beq.n	c388 <_strtod_l+0x350>
    c372:	ldr	r3, [pc, #756]	; (c668 <_strtod_l+0x630>)
    c374:	add.w	r1, r3, r1, lsl #3
    c378:	ldrd	r0, r1, [r1]
    c37c:	ldrd	r2, r3, [sp, #16]
    c380:	bl	a7bc <__aeabi_dmul>
    c384:	strd	r0, r1, [sp, #16]
    c388:	bics.w	r6, r9, #15
    c38c:	bne.w	c7b0 <_strtod_l+0x778>
    c390:	movs	r3, #0
    c392:	str	r3, [sp, #40]	; 0x28
    c394:	str	r5, [sp, #0]
    c396:	mov	r3, r4
    c398:	mov	r2, sl
    c39a:	ldr	r1, [sp, #32]
    c39c:	mov	r0, fp
    c39e:	bl	11240 <__s2b>
    c3a2:	str	r0, [sp, #72]	; 0x48
    c3a4:	cmp	r0, #0
    c3a6:	beq.w	c9f6 <_strtod_l+0x9be>
    c3aa:	ldr	r2, [sp, #44]	; 0x2c
    c3ac:	movs	r7, #0
    c3ae:	cmp	r2, #0
    c3b0:	rsb	r3, r2, #0
    c3b4:	it	ge
    c3b6:	movge	r3, r7
    c3b8:	str	r3, [sp, #48]	; 0x30
    c3ba:	bic.w	r3, r2, r2, asr #31
    c3be:	str	r3, [sp, #44]	; 0x2c
    c3c0:	mov	sl, r7
    c3c2:	ldr	r4, [sp, #72]	; 0x48
    c3c4:	mov	r0, fp
    c3c6:	ldr	r1, [r4, #4]
    c3c8:	bl	11160 <_Balloc>
    c3cc:	mov	r6, r0
    c3ce:	cmp	r0, #0
    c3d0:	beq.w	c888 <_strtod_l+0x850>
    c3d4:	ldr	r2, [r4, #16]
    c3d6:	vldr	d7, [sp, #16]
    c3da:	adds	r2, #2
    c3dc:	lsls	r2, r2, #2
    c3de:	add.w	r1, r4, #12
    c3e2:	adds	r0, #12
    c3e4:	vstr	d7, [sp, #32]
    c3e8:	bl	8e18 <memcpy>
    c3ec:	vldr	d0, [sp, #32]
    c3f0:	add	r2, sp, #120	; 0x78
    c3f2:	add	r1, sp, #116	; 0x74
    c3f4:	mov	r0, fp
    c3f6:	bl	11884 <__d2b>
    c3fa:	str	r0, [sp, #112]	; 0x70
    c3fc:	cmp	r0, #0
    c3fe:	beq.w	c88a <_strtod_l+0x852>
    c402:	movs	r1, #1
    c404:	mov	r0, fp
    c406:	bl	11374 <__i2b>
    c40a:	mov	sl, r0
    c40c:	cmp	r0, #0
    c40e:	beq.w	c888 <_strtod_l+0x850>
    c412:	ldr	r2, [sp, #116]	; 0x74
    c414:	cmp	r2, #0
    c416:	blt.w	c680 <_strtod_l+0x648>
    c41a:	ldr	r3, [sp, #48]	; 0x30
    c41c:	ldr	r4, [sp, #44]	; 0x2c
    c41e:	adds	r5, r3, r2
    c420:	ldr	r0, [sp, #40]	; 0x28
    c422:	ldr	r3, [sp, #120]	; 0x78
    c424:	ldr	r1, [pc, #580]	; (c66c <_strtod_l+0x634>)
    c426:	subs	r2, r2, r0
    c428:	add	r2, r3
    c42a:	subs	r2, #1
    c42c:	cmp	r2, r1
    c42e:	rsb	r3, r3, #54	; 0x36
    c432:	bge.w	c612 <_strtod_l+0x5da>
    c436:	subs	r1, r1, r2
    c438:	cmp	r1, #31
    c43a:	sub.w	r3, r3, r1
    c43e:	bgt.w	c68e <_strtod_l+0x656>
    c442:	movs	r2, #1
    c444:	lsls	r2, r1
    c446:	str	r2, [sp, #56]	; 0x38
    c448:	movs	r2, #0
    c44a:	str	r2, [sp, #76]	; 0x4c
    c44c:	add.w	r9, r5, r3
    c450:	add	r4, r3
    c452:	ldr	r3, [sp, #40]	; 0x28
    c454:	cmp	r5, r9
    c456:	mov	r2, r5
    c458:	add	r4, r3
    c45a:	it	ge
    c45c:	movge	r2, r9
    c45e:	cmp	r2, r4
    c460:	it	ge
    c462:	movge	r2, r4
    c464:	cmp	r2, #0
    c466:	ble.n	c470 <_strtod_l+0x438>
    c468:	rsb	r9, r2, r9
    c46c:	subs	r4, r4, r2
    c46e:	subs	r5, r5, r2
    c470:	ldr	r3, [sp, #48]	; 0x30
    c472:	cbz	r3, c4a4 <_strtod_l+0x46c>
    c474:	mov	r1, sl
    c476:	mov	r2, r3
    c478:	mov	r0, fp
    c47a:	bl	114b8 <__pow5mult>
    c47e:	mov	sl, r0
    c480:	cmp	r0, #0
    c482:	beq.w	c888 <_strtod_l+0x850>
    c486:	mov	r1, r0
    c488:	ldr	r2, [sp, #112]	; 0x70
    c48a:	mov	r0, fp
    c48c:	bl	11388 <__multiply>
    c490:	cmp	r0, #0
    c492:	beq.w	c888 <_strtod_l+0x850>
    c496:	str	r0, [sp, #52]	; 0x34
    c498:	ldr	r1, [sp, #112]	; 0x70
    c49a:	mov	r0, fp
    c49c:	bl	111ac <_Bfree>
    c4a0:	ldr	r2, [sp, #52]	; 0x34
    c4a2:	str	r2, [sp, #112]	; 0x70
    c4a4:	cmp.w	r9, #0
    c4a8:	ble.n	c4bc <_strtod_l+0x484>
    c4aa:	mov	r2, r9
    c4ac:	ldr	r1, [sp, #112]	; 0x70
    c4ae:	mov	r0, fp
    c4b0:	bl	11558 <__lshift>
    c4b4:	str	r0, [sp, #112]	; 0x70
    c4b6:	cmp	r0, #0
    c4b8:	beq.w	c88a <_strtod_l+0x852>
    c4bc:	ldr	r3, [sp, #44]	; 0x2c
    c4be:	cbz	r3, c4d2 <_strtod_l+0x49a>
    c4c0:	mov	r1, r6
    c4c2:	ldr	r2, [sp, #44]	; 0x2c
    c4c4:	mov	r0, fp
    c4c6:	bl	114b8 <__pow5mult>
    c4ca:	mov	r6, r0
    c4cc:	cmp	r0, #0
    c4ce:	beq.w	c888 <_strtod_l+0x850>
    c4d2:	cmp	r4, #0
    c4d4:	ble.n	c4e8 <_strtod_l+0x4b0>
    c4d6:	mov	r1, r6
    c4d8:	mov	r2, r4
    c4da:	mov	r0, fp
    c4dc:	bl	11558 <__lshift>
    c4e0:	mov	r6, r0
    c4e2:	cmp	r0, #0
    c4e4:	beq.w	c888 <_strtod_l+0x850>
    c4e8:	cmp	r5, #0
    c4ea:	ble.n	c4fe <_strtod_l+0x4c6>
    c4ec:	mov	r1, sl
    c4ee:	mov	r2, r5
    c4f0:	mov	r0, fp
    c4f2:	bl	11558 <__lshift>
    c4f6:	mov	sl, r0
    c4f8:	cmp	r0, #0
    c4fa:	beq.w	c888 <_strtod_l+0x850>
    c4fe:	mov	r2, r6
    c500:	ldr	r1, [sp, #112]	; 0x70
    c502:	mov	r0, fp
    c504:	bl	1164c <__mdiff>
    c508:	mov	r7, r0
    c50a:	cmp	r0, #0
    c50c:	beq.w	c888 <_strtod_l+0x850>
    c510:	movs	r3, #0
    c512:	ldr	r2, [r0, #12]
    c514:	str	r3, [r0, #12]
    c516:	mov	r1, sl
    c518:	str	r2, [sp, #52]	; 0x34
    c51a:	bl	11608 <__mcmp>
    c51e:	cmp	r0, #0
    c520:	blt.w	cd3e <_strtod_l+0xd06>
    c524:	beq.w	ccb8 <_strtod_l+0xc80>
    c528:	mov	r1, sl
    c52a:	mov	r0, r7
    c52c:	bl	11940 <__ratio>
    c530:	vmov	r4, r5, d0
    c534:	movs	r2, #0
    c536:	mov.w	r3, #1073741824	; 0x40000000
    c53a:	vmov	r0, s0
    c53e:	mov	r1, r5
    c540:	bl	acb4 <__aeabi_dcmple>
    c544:	cmp	r0, #0
    c546:	beq.n	c61c <_strtod_l+0x5e4>
    c548:	ldr	r3, [sp, #52]	; 0x34
    c54a:	cmp	r3, #0
    c54c:	beq.w	c69e <_strtod_l+0x666>
    c550:	vldr	d7, [pc, #260]	; c658 <_strtod_l+0x620>
    c554:	ldr	r3, [sp, #20]
    c556:	ldr	r5, [pc, #280]	; (c670 <_strtod_l+0x638>)
    c558:	vstr	d7, [sp, #56]	; 0x38
    c55c:	movs	r4, #0
    c55e:	mov	r8, r3
    c560:	ldr.w	r9, [pc, #276]	; c678 <_strtod_l+0x640>
    c564:	ldr	r3, [pc, #268]	; (c674 <_strtod_l+0x63c>)
    c566:	and.w	r9, r8, r9
    c56a:	cmp	r9, r3
    c56c:	beq.w	c99c <_strtod_l+0x964>
    c570:	ldr	r3, [sp, #40]	; 0x28
    c572:	cbz	r3, c5c0 <_strtod_l+0x588>
    c574:	cmp.w	r9, #111149056	; 0x6a00000
    c578:	bhi.n	c5c0 <_strtod_l+0x588>
    c57a:	add	r3, pc, #228	; (adr r3, c660 <_strtod_l+0x628>)
    c57c:	ldrd	r2, r3, [r3]
    c580:	ldrd	r0, r1, [sp, #56]	; 0x38
    c584:	bl	acb4 <__aeabi_dcmple>
    c588:	cbz	r0, c5b8 <_strtod_l+0x580>
    c58a:	ldrd	r0, r1, [sp, #56]	; 0x38
    c58e:	bl	ad6c <__aeabi_d2uiz>
    c592:	cmp	r0, #0
    c594:	beq.w	cc18 <_strtod_l+0xbe0>
    c598:	bl	a6d0 <__aeabi_ui2d>
    c59c:	strd	r0, r1, [sp, #56]	; 0x38
    c5a0:	ldr	r3, [sp, #52]	; 0x34
    c5a2:	cmp	r3, #0
    c5a4:	bne.w	cc0e <_strtod_l+0xbd6>
    c5a8:	ldrd	r1, r2, [sp, #56]	; 0x38
    c5ac:	add.w	r3, r2, #2147483648	; 0x80000000
    c5b0:	str	r1, [sp, #80]	; 0x50
    c5b2:	str	r3, [sp, #84]	; 0x54
    c5b4:	ldrd	r4, r5, [sp, #80]	; 0x50
    c5b8:	add.w	r3, r5, #112197632	; 0x6b00000
    c5bc:	rsb	r5, r9, r3
    c5c0:	vldr	d0, [sp, #32]
    c5c4:	bl	11760 <__ulp>
    c5c8:	mov	r0, r4
    c5ca:	vmov	r2, r3, d0
    c5ce:	mov	r1, r5
    c5d0:	bl	a7bc <__aeabi_dmul>
    c5d4:	ldrd	r2, r3, [sp, #32]
    c5d8:	bl	a458 <__adddf3>
    c5dc:	strd	r0, r1, [sp, #16]
    c5e0:	mov	r4, r1
    c5e2:	ldr	r3, [sp, #40]	; 0x28
    c5e4:	cbnz	r3, c5f0 <_strtod_l+0x5b8>
    c5e6:	ldr	r3, [pc, #144]	; (c678 <_strtod_l+0x640>)
    c5e8:	ands	r3, r4
    c5ea:	cmp	r9, r3
    c5ec:	beq.w	ca0c <_strtod_l+0x9d4>
    c5f0:	ldr	r1, [sp, #112]	; 0x70
    c5f2:	mov	r0, fp
    c5f4:	bl	111ac <_Bfree>
    c5f8:	mov	r1, r6
    c5fa:	mov	r0, fp
    c5fc:	bl	111ac <_Bfree>
    c600:	mov	r1, sl
    c602:	mov	r0, fp
    c604:	bl	111ac <_Bfree>
    c608:	mov	r1, r7
    c60a:	mov	r0, fp
    c60c:	bl	111ac <_Bfree>
    c610:	b.n	c3c2 <_strtod_l+0x38a>
    c612:	movs	r2, #0
    c614:	str	r2, [sp, #76]	; 0x4c
    c616:	movs	r2, #1
    c618:	str	r2, [sp, #56]	; 0x38
    c61a:	b.n	c44c <_strtod_l+0x414>
    c61c:	ldr	r3, [pc, #92]	; (c67c <_strtod_l+0x644>)
    c61e:	mov	r0, r4
    c620:	mov	r1, r5
    c622:	movs	r2, #0
    c624:	bl	a7bc <__aeabi_dmul>
    c628:	ldr	r3, [sp, #52]	; 0x34
    c62a:	strd	r0, r1, [sp, #56]	; 0x38
    c62e:	cmp	r3, #0
    c630:	bne.n	c6e8 <_strtod_l+0x6b0>
    c632:	add.w	r3, r1, #2147483648	; 0x80000000
    c636:	str	r0, [sp, #64]	; 0x40
    c638:	str	r3, [sp, #68]	; 0x44
    c63a:	ldr	r3, [sp, #20]
    c63c:	ldrd	r4, r5, [sp, #64]	; 0x40
    c640:	mov	r8, r3
    c642:	b.n	c560 <_strtod_l+0x528>
    c644:	mov.w	r9, #1
    c648:	cmp	r0, #0
    c64a:	bne.n	c6fe <_strtod_l+0x6c6>
    c64c:	ldr	r3, [sp, #40]	; 0x28
    c64e:	cmp	r3, #0
    c650:	beq.w	c0a4 <_strtod_l+0x6c>
    c654:	mov	r4, r0
    c656:	b.n	c2b4 <_strtod_l+0x27c>
    c658:	.word	0x00000000
    c65c:	.word	0x3ff00000
    c660:	.word	0xffc00000
    c664:	.word	0x41dfffff
    c668:	.word	0x00013320
    c66c:	.word	0xfffffc02
    c670:	.word	0x3ff00000
    c674:	.word	0x7fe00000
    c678:	.word	0x7ff00000
    c67c:	.word	0x3fe00000
    c680:	ldr	r3, [sp, #44]	; 0x2c
    c682:	ldr	r5, [sp, #48]	; 0x30
    c684:	subs	r4, r3, r2
    c686:	b.n	c420 <_strtod_l+0x3e8>
    c688:	mov.w	r9, #1
    c68c:	b.n	c144 <_strtod_l+0x10c>
    c68e:	ldr	r1, [pc, #736]	; (c970 <_strtod_l+0x938>)
    c690:	subs	r1, r1, r2
    c692:	movs	r2, #1
    c694:	lsl.w	r1, r2, r1
    c698:	str	r1, [sp, #76]	; 0x4c
    c69a:	str	r2, [sp, #56]	; 0x38
    c69c:	b.n	c44c <_strtod_l+0x414>
    c69e:	ldrd	r1, r2, [sp, #16]
    c6a2:	cmp	r1, #0
    c6a4:	bne.w	c83a <_strtod_l+0x802>
    c6a8:	ubfx	r3, r2, #0, #20
    c6ac:	mov	r8, r2
    c6ae:	cmp	r3, #0
    c6b0:	bne.w	c846 <_strtod_l+0x80e>
    c6b4:	movs	r2, #0
    c6b6:	ldr	r3, [pc, #700]	; (c974 <_strtod_l+0x93c>)
    c6b8:	mov	r0, r4
    c6ba:	mov	r1, r5
    c6bc:	bl	aca0 <__aeabi_dcmplt>
    c6c0:	cmp	r0, #0
    c6c2:	bne.w	cdc2 <_strtod_l+0xd8a>
    c6c6:	movs	r2, #0
    c6c8:	ldr	r3, [pc, #684]	; (c978 <_strtod_l+0x940>)
    c6ca:	mov	r0, r4
    c6cc:	mov	r1, r5
    c6ce:	bl	a7bc <__aeabi_dmul>
    c6d2:	mov	r2, r1
    c6d4:	mov	r1, r0
    c6d6:	strd	r1, r2, [sp, #56]	; 0x38
    c6da:	add.w	r3, r2, #2147483648	; 0x80000000
    c6de:	str	r0, [sp, #96]	; 0x60
    c6e0:	str	r3, [sp, #100]	; 0x64
    c6e2:	ldrd	r4, r5, [sp, #96]	; 0x60
    c6e6:	b.n	c560 <_strtod_l+0x528>
    c6e8:	vldr	d7, [sp, #56]	; 0x38
    c6ec:	vstr	d7, [sp, #64]	; 0x40
    c6f0:	b.n	c63a <_strtod_l+0x602>
    c6f2:	mov.w	ip, #1
    c6f6:	adds	r3, r6, #2
    c6f8:	str	r3, [sp, #108]	; 0x6c
    c6fa:	ldrb	r3, [r6, #2]
    c6fc:	b.n	c2cc <_strtod_l+0x294>
    c6fe:	movs	r4, #0
    c700:	b.n	c2b4 <_strtod_l+0x27c>
    c702:	cmp.w	r9, #0
    c706:	bne.w	c0a4 <_strtod_l+0x6c>
    c70a:	subs	r3, #73	; 0x49
    c70c:	cmp	r3, #37	; 0x25
    c70e:	bhi.w	c0a4 <_strtod_l+0x6c>
    c712:	add	r2, pc, #4	; (adr r2, c718 <_strtod_l+0x6e0>)
    c714:	ldr.w	pc, [r2, r3, lsl #2]
    c718:	.word	0x0000c27d
    c71c:	.word	0x0000c0a5
    c720:	.word	0x0000c0a5
    c724:	.word	0x0000c0a5
    c728:	.word	0x0000c0a5
    c72c:	.word	0x0000c855
    c730:	.word	0x0000c0a5
    c734:	.word	0x0000c0a5
    c738:	.word	0x0000c0a5
    c73c:	.word	0x0000c0a5
    c740:	.word	0x0000c0a5
    c744:	.word	0x0000c0a5
    c748:	.word	0x0000c0a5
    c74c:	.word	0x0000c0a5
    c750:	.word	0x0000c0a5
    c754:	.word	0x0000c0a5
    c758:	.word	0x0000c0a5
    c75c:	.word	0x0000c0a5
    c760:	.word	0x0000c0a5
    c764:	.word	0x0000c0a5
    c768:	.word	0x0000c0a5
    c76c:	.word	0x0000c0a5
    c770:	.word	0x0000c0a5
    c774:	.word	0x0000c0a5
    c778:	.word	0x0000c0a5
    c77c:	.word	0x0000c0a5
    c780:	.word	0x0000c0a5
    c784:	.word	0x0000c0a5
    c788:	.word	0x0000c0a5
    c78c:	.word	0x0000c0a5
    c790:	.word	0x0000c0a5
    c794:	.word	0x0000c0a5
    c798:	.word	0x0000c27d
    c79c:	.word	0x0000c0a5
    c7a0:	.word	0x0000c0a5
    c7a4:	.word	0x0000c0a5
    c7a8:	.word	0x0000c0a5
    c7ac:	.word	0x0000c855
    c7b0:	cmp.w	r6, #308	; 0x134
    c7b4:	bgt.w	c9f6 <_strtod_l+0x9be>
    c7b8:	asrs	r6, r6, #4
    c7ba:	cmp	r6, #1
    c7bc:	ldr.w	r9, [pc, #472]	; c998 <_strtod_l+0x960>
    c7c0:	ble.w	cdf6 <_strtod_l+0xdbe>
    c7c4:	ldrd	r0, r1, [sp, #16]
    c7c8:	movs	r3, #0
    c7ca:	mov	r7, r9
    c7cc:	mov	r8, r3
    c7ce:	tst.w	r6, #1
    c7d2:	add.w	r8, r8, #1
    c7d6:	mov.w	r6, r6, asr #1
    c7da:	beq.n	c7e6 <_strtod_l+0x7ae>
    c7dc:	ldrd	r2, r3, [r7]
    c7e0:	bl	a7bc <__aeabi_dmul>
    c7e4:	movs	r3, #1
    c7e6:	cmp	r6, #1
    c7e8:	add.w	r7, r7, #8
    c7ec:	bne.n	c7ce <_strtod_l+0x796>
    c7ee:	cmp	r3, #0
    c7f0:	bne.w	ceba <_strtod_l+0xe82>
    c7f4:	ldr	r3, [sp, #20]
    c7f6:	sub.w	r3, r3, #55574528	; 0x3500000
    c7fa:	str	r3, [sp, #20]
    c7fc:	add.w	r8, r9, r8, lsl #3
    c800:	ldrd	r2, r3, [sp, #16]
    c804:	ldrd	r0, r1, [r8]
    c808:	bl	a7bc <__aeabi_dmul>
    c80c:	bic.w	r3, r1, #2147483648	; 0x80000000
    c810:	lsrs	r3, r3, #20
    c812:	ldr	r2, [pc, #360]	; (c97c <_strtod_l+0x944>)
    c814:	lsls	r3, r3, #20
    c816:	cmp	r3, r2
    c818:	strd	r0, r1, [sp, #16]
    c81c:	bhi.w	c9f6 <_strtod_l+0x9be>
    c820:	sub.w	r2, r2, #1048576	; 0x100000
    c824:	cmp	r3, r2
    c826:	bls.w	cdb8 <_strtod_l+0xd80>
    c82a:	ldr	r3, [pc, #340]	; (c980 <_strtod_l+0x948>)
    c82c:	str	r3, [sp, #20]
    c82e:	movs	r3, #0
    c830:	str	r3, [sp, #40]	; 0x28
    c832:	mov.w	r3, #4294967295
    c836:	str	r3, [sp, #16]
    c838:	b.n	c394 <_strtod_l+0x35c>
    c83a:	ldrd	r1, r2, [sp, #16]
    c83e:	cmp	r1, #1
    c840:	beq.w	cc22 <_strtod_l+0xbea>
    c844:	mov	r8, r2
    c846:	vldr	d7, [pc, #288]	; c968 <_strtod_l+0x930>
    c84a:	movs	r4, #0
    c84c:	ldr	r5, [pc, #308]	; (c984 <_strtod_l+0x94c>)
    c84e:	vstr	d7, [sp, #56]	; 0x38
    c852:	b.n	c560 <_strtod_l+0x528>
    c854:	add	r0, sp, #108	; 0x6c
    c856:	ldr	r1, [pc, #304]	; (c988 <_strtod_l+0x950>)
    c858:	bl	10f18 <__match>
    c85c:	cmp	r0, #0
    c85e:	beq.w	c0a4 <_strtod_l+0x6c>
    c862:	ldr	r3, [sp, #108]	; 0x6c
    c864:	ldrb	r3, [r3, #0]
    c866:	cmp	r3, #40	; 0x28
    c868:	beq.w	ce70 <_strtod_l+0xe38>
    c86c:	ldr	r3, [pc, #284]	; (c98c <_strtod_l+0x954>)
    c86e:	str	r3, [sp, #20]
    c870:	movs	r3, #0
    c872:	str	r3, [sp, #16]
    c874:	b.n	c2a8 <_strtod_l+0x270>
    c876:	str	r6, [sp, #108]	; 0x6c
    c878:	movs	r2, #0
    c87a:	b.n	c152 <_strtod_l+0x11a>
    c87c:	mov.w	ip, #0
    c880:	b.n	c6f6 <_strtod_l+0x6be>
    c882:	adds	r3, #1
    c884:	bne.w	ce56 <_strtod_l+0xe1e>
    c888:	ldr	r0, [sp, #112]	; 0x70
    c88a:	ldr	r3, [pc, #260]	; (c990 <_strtod_l+0x958>)
    c88c:	str	r3, [sp, #20]
    c88e:	movs	r2, #0
    c890:	str	r2, [sp, #16]
    c892:	ldrd	r8, r9, [sp, #16]
    c896:	movs	r3, #34	; 0x22
    c898:	str.w	r3, [fp]
    c89c:	mov	r1, r0
    c89e:	mov	r0, fp
    c8a0:	bl	111ac <_Bfree>
    c8a4:	mov	r1, r6
    c8a6:	mov	r0, fp
    c8a8:	bl	111ac <_Bfree>
    c8ac:	mov	r1, sl
    c8ae:	mov	r0, fp
    c8b0:	bl	111ac <_Bfree>
    c8b4:	ldr	r1, [sp, #72]	; 0x48
    c8b6:	mov	r0, fp
    c8b8:	bl	111ac <_Bfree>
    c8bc:	mov	r1, r7
    c8be:	mov	r0, fp
    c8c0:	bl	111ac <_Bfree>
    c8c4:	b.n	c168 <_strtod_l+0x130>
    c8c6:	ldr	r2, [sp, #28]
    c8c8:	str	r5, [sp, #8]
    c8ca:	add	r3, sp, #112	; 0x70
    c8cc:	str	r2, [sp, #4]
    c8ce:	str	r3, [sp, #0]
    c8d0:	ldr	r2, [pc, #192]	; (c994 <_strtod_l+0x95c>)
    c8d2:	add	r3, sp, #116	; 0x74
    c8d4:	add	r1, sp, #108	; 0x6c
    c8d6:	mov	r0, fp
    c8d8:	bl	10a08 <__gethex>
    c8dc:	ands.w	r6, r0, #7
    c8e0:	mov	r5, r0
    c8e2:	beq.w	c160 <_strtod_l+0x128>
    c8e6:	cmp	r6, #6
    c8e8:	bne.w	cb98 <_strtod_l+0xb60>
    c8ec:	adds	r4, #1
    c8ee:	movs	r3, #0
    c8f0:	str	r4, [sp, #108]	; 0x6c
    c8f2:	mov.w	r8, #0
    c8f6:	mov.w	r9, #0
    c8fa:	str	r3, [sp, #28]
    c8fc:	b.n	c168 <_strtod_l+0x130>
    c8fe:	ldr.w	r1, [sl]
    c902:	mov	r0, r4
    c904:	mov	r2, r9
    c906:	bl	bf5c <strncmp>
    c90a:	cbz	r0, c920 <_strtod_l+0x8e8>
    c90c:	mov.w	sl, #0
    c910:	mov	r3, r7
    c912:	mov	r8, sl
    c914:	mov	r5, sl
    c916:	mov	r0, sl
    c918:	mov	r7, sl
    c91a:	mov	r4, sl
    c91c:	mov	r9, sl
    c91e:	b.n	c144 <_strtod_l+0x10c>
    c920:	ldr	r3, [sp, #108]	; 0x6c
    c922:	add.w	r2, r3, r9
    c926:	str	r2, [sp, #108]	; 0x6c
    c928:	ldrb.w	r3, [r3, r9]
    c92c:	cmp	r3, #48	; 0x30
    c92e:	bne.n	c93e <_strtod_l+0x906>
    c930:	adds	r2, #1
    c932:	str	r2, [sp, #108]	; 0x6c
    c934:	ldrb	r3, [r2, #0]
    c936:	cmp	r3, #48	; 0x30
    c938:	add.w	r0, r0, #1
    c93c:	beq.n	c930 <_strtod_l+0x8f8>
    c93e:	sub.w	r2, r3, #49	; 0x31
    c942:	cmp	r2, #8
    c944:	bls.w	cc40 <_strtod_l+0xc08>
    c948:	mov.w	sl, #0
    c94c:	cmp	r3, #101	; 0x65
    c94e:	mov	r8, sl
    c950:	mov	r5, sl
    c952:	mov	r7, sl
    c954:	beq.w	c644 <_strtod_l+0x60c>
    c958:	mov	r4, sl
    c95a:	mov.w	r9, #1
    c95e:	b.w	c14a <_strtod_l+0x112>
    c962:	nop
    c964:	nop.w
    c968:	.word	0x00000000
    c96c:	.word	0x3ff00000
    c970:	.word	0xfffffbe2
    c974:	.word	0x3ff00000
    c978:	.word	0x3fe00000
    c97c:	.word	0x7ca00000
    c980:	.word	0x7fefffff
    c984:	.word	0xbff00000
    c988:	.word	0x00013038
    c98c:	.word	0xfff80000
    c990:	.word	0x7ff00000
    c994:	.word	0x00013018
    c998:	.word	0x000133e8
    c99c:	sub.w	r3, r8, #55574528	; 0x3500000
    c9a0:	str	r3, [sp, #20]
    c9a2:	vldr	d7, [sp, #16]
    c9a6:	vmov.f32	s0, s14
    c9aa:	vmov.f32	s1, s15
    c9ae:	bl	11760 <__ulp>
    c9b2:	mov	r0, r4
    c9b4:	vmov	r2, r3, d0
    c9b8:	mov	r1, r5
    c9ba:	bl	a7bc <__aeabi_dmul>
    c9be:	ldrd	r2, r3, [sp, #16]
    c9c2:	bl	a458 <__adddf3>
    c9c6:	bic.w	r3, r1, #2147483648	; 0x80000000
    c9ca:	strd	r0, r1, [sp, #16]
    c9ce:	lsrs	r3, r3, #20
    c9d0:	ldr	r2, [pc, #684]	; (cc80 <_strtod_l+0xc48>)
    c9d2:	ldrd	r0, r1, [sp, #32]
    c9d6:	lsls	r3, r3, #20
    c9d8:	cmp	r3, r2
    c9da:	strd	r0, r1, [sp, #88]	; 0x58
    c9de:	bls.w	cb56 <_strtod_l+0xb1e>
    c9e2:	ldr	r3, [pc, #672]	; (cc84 <_strtod_l+0xc4c>)
    c9e4:	cmp	r1, r3
    c9e6:	beq.w	cdae <_strtod_l+0xd76>
    c9ea:	ldr	r3, [pc, #664]	; (cc84 <_strtod_l+0xc4c>)
    c9ec:	str	r3, [sp, #20]
    c9ee:	mov.w	r3, #4294967295
    c9f2:	str	r3, [sp, #16]
    c9f4:	b.n	c5f0 <_strtod_l+0x5b8>
    c9f6:	ldr	r3, [pc, #656]	; (cc88 <_strtod_l+0xc50>)
    c9f8:	str	r3, [sp, #20]
    c9fa:	movs	r2, #0
    c9fc:	movs	r3, #34	; 0x22
    c9fe:	str	r2, [sp, #16]
    ca00:	ldrd	r8, r9, [sp, #16]
    ca04:	str.w	r3, [fp]
    ca08:	b.w	c168 <_strtod_l+0x130>
    ca0c:	ldrd	r8, r9, [sp, #56]	; 0x38
    ca10:	mov	r1, r9
    ca12:	mov	r0, r8
    ca14:	bl	ad1c <__aeabi_d2iz>
    ca18:	bl	a6f0 <__aeabi_i2d>
    ca1c:	mov	r3, r1
    ca1e:	mov	r2, r0
    ca20:	mov	r1, r9
    ca22:	mov	r0, r8
    ca24:	bl	a454 <__aeabi_dsub>
    ca28:	ldr	r3, [sp, #52]	; 0x34
    ca2a:	mov	r8, r0
    ca2c:	mov	r9, r1
    ca2e:	cbnz	r3, ca52 <_strtod_l+0xa1a>
    ca30:	ldr	r3, [sp, #16]
    ca32:	cbnz	r3, ca52 <_strtod_l+0xa1a>
    ca34:	ubfx	r4, r4, #0, #20
    ca38:	cbnz	r4, ca52 <_strtod_l+0xa1a>
    ca3a:	add	r3, pc, #548	; (adr r3, cc60 <_strtod_l+0xc28>)
    ca3c:	ldrd	r2, r3, [r3]
    ca40:	bl	aca0 <__aeabi_dcmplt>
    ca44:	cmp	r0, #0
    ca46:	beq.w	c5f0 <_strtod_l+0x5b8>
    ca4a:	ldrd	r8, r9, [sp, #16]
    ca4e:	ldr	r0, [sp, #112]	; 0x70
    ca50:	b.n	c89c <_strtod_l+0x864>
    ca52:	add	r3, pc, #532	; (adr r3, cc68 <_strtod_l+0xc30>)
    ca54:	ldrd	r2, r3, [r3]
    ca58:	mov	r0, r8
    ca5a:	mov	r1, r9
    ca5c:	bl	aca0 <__aeabi_dcmplt>
    ca60:	cmp	r0, #0
    ca62:	bne.n	ca4a <_strtod_l+0xa12>
    ca64:	mov	r0, r8
    ca66:	mov	r1, r9
    ca68:	add	r3, pc, #516	; (adr r3, cc70 <_strtod_l+0xc38>)
    ca6a:	ldrd	r2, r3, [r3]
    ca6e:	bl	acdc <__aeabi_dcmpgt>
    ca72:	cmp	r0, #0
    ca74:	beq.w	c5f0 <_strtod_l+0x5b8>
    ca78:	b.n	ca4a <_strtod_l+0xa12>
    ca7a:	beq.w	c390 <_strtod_l+0x358>
    ca7e:	rsb	r6, r9, #0
    ca82:	ands.w	r2, r6, #15
    ca86:	beq.n	ca9e <_strtod_l+0xa66>
    ca88:	ldr	r3, [pc, #512]	; (cc8c <_strtod_l+0xc54>)
    ca8a:	add.w	r3, r3, r2, lsl #3
    ca8e:	ldrd	r0, r1, [sp, #16]
    ca92:	ldrd	r2, r3, [r3]
    ca96:	bl	aa10 <__aeabi_ddiv>
    ca9a:	strd	r0, r1, [sp, #16]
    ca9e:	asrs	r6, r6, #4
    caa0:	beq.w	c390 <_strtod_l+0x358>
    caa4:	cmp	r6, #31
    caa6:	bgt.n	cb1a <_strtod_l+0xae2>
    caa8:	ands.w	r3, r6, #16
    caac:	beq.w	ce20 <_strtod_l+0xde8>
    cab0:	movs	r3, #106	; 0x6a
    cab2:	cmp	r6, #0
    cab4:	str	r3, [sp, #40]	; 0x28
    cab6:	ble.n	cae0 <_strtod_l+0xaa8>
    cab8:	ldrd	r0, r1, [sp, #16]
    cabc:	ldr	r7, [pc, #464]	; (cc90 <_strtod_l+0xc58>)
    cabe:	movs	r3, #0
    cac0:	lsls	r2, r6, #31
    cac2:	bpl.n	cace <_strtod_l+0xa96>
    cac4:	ldrd	r2, r3, [r7]
    cac8:	bl	a7bc <__aeabi_dmul>
    cacc:	movs	r3, #1
    cace:	asrs	r6, r6, #1
    cad0:	add.w	r7, r7, #8
    cad4:	bne.n	cac0 <_strtod_l+0xa88>
    cad6:	cmp	r3, #0
    cad8:	bne.w	cec0 <_strtod_l+0xe88>
    cadc:	ldr	r3, [sp, #40]	; 0x28
    cade:	cbz	r3, cb08 <_strtod_l+0xad0>
    cae0:	ldrd	r1, r2, [sp, #16]
    cae4:	ubfx	r3, r2, #20, #11
    cae8:	rsb	r3, r3, #107	; 0x6b
    caec:	cmp	r3, #0
    caee:	mov	r1, r2
    caf0:	ble.n	cb08 <_strtod_l+0xad0>
    caf2:	cmp	r3, #31
    caf4:	ble.w	ceaa <_strtod_l+0xe72>
    caf8:	movs	r2, #0
    cafa:	cmp	r3, #52	; 0x34
    cafc:	str	r2, [sp, #16]
    cafe:	ble.w	cec6 <_strtod_l+0xe8e>
    cb02:	mov.w	r3, #57671680	; 0x3700000
    cb06:	str	r3, [sp, #20]
    cb08:	movs	r2, #0
    cb0a:	movs	r3, #0
    cb0c:	ldrd	r0, r1, [sp, #16]
    cb10:	bl	ac8c <__aeabi_dcmpeq>
    cb14:	cmp	r0, #0
    cb16:	beq.w	c394 <_strtod_l+0x35c>
    cb1a:	movs	r3, #34	; 0x22
    cb1c:	str.w	r3, [fp]
    cb20:	mov.w	r8, #0
    cb24:	mov.w	r9, #0
    cb28:	b.w	c168 <_strtod_l+0x130>
    cb2c:	ldr	r1, [sp, #108]	; 0x6c
    cb2e:	adds	r4, #1
    cb30:	cmp	r0, #8
    cb32:	ble.w	cc52 <_strtod_l+0xc1a>
    cb36:	cmp	r4, #16
    cb38:	itt	le
    cb3a:	addle.w	r8, r8, r8, lsl #2
    cb3e:	addle.w	r8, r2, r8, lsl #1
    cb42:	movs	r0, #0
    cb44:	adds	r3, r1, #1
    cb46:	str	r3, [sp, #108]	; 0x6c
    cb48:	ldrb	r3, [r1, #1]
    cb4a:	b.w	c18c <_strtod_l+0x154>
    cb4e:	movw	r2, #19999	; 0x4e1f
    cb52:	b.w	c33e <_strtod_l+0x306>
    cb56:	ldr	r3, [sp, #20]
    cb58:	add.w	r4, r3, #55574528	; 0x3500000
    cb5c:	str	r4, [sp, #20]
    cb5e:	b.n	c5e2 <_strtod_l+0x5aa>
    cb60:	ldr	r6, [sp, #44]	; 0x2c
    cb62:	rsb	r3, r4, #37	; 0x25
    cb66:	cmp	r6, r3
    cb68:	bgt.w	c35c <_strtod_l+0x324>
    cb6c:	ldr	r5, [pc, #284]	; (cc8c <_strtod_l+0xc54>)
    cb6e:	rsb	r4, r4, #15
    cb72:	add.w	r1, r5, r4, lsl #3
    cb76:	subs	r4, r6, r4
    cb78:	ldrd	r2, r3, [sp, #16]
    cb7c:	ldrd	r0, r1, [r1]
    cb80:	add.w	r5, r5, r4, lsl #3
    cb84:	bl	a7bc <__aeabi_dmul>
    cb88:	ldrd	r2, r3, [r5]
    cb8c:	bl	a7bc <__aeabi_dmul>
    cb90:	mov	r8, r0
    cb92:	mov	r9, r1
    cb94:	b.w	c168 <_strtod_l+0x130>
    cb98:	ldr	r2, [sp, #112]	; 0x70
    cb9a:	cbz	r2, cbac <_strtod_l+0xb74>
    cb9c:	movs	r1, #53	; 0x35
    cb9e:	add	r0, sp, #120	; 0x78
    cba0:	bl	119a0 <__copybits>
    cba4:	mov	r0, fp
    cba6:	ldr	r1, [sp, #112]	; 0x70
    cba8:	bl	111ac <_Bfree>
    cbac:	cmp	r6, #6
    cbae:	bhi.n	cbc8 <_strtod_l+0xb90>
    cbb0:	tbb	[pc, r6]
    cbb4:	.word	0x1318211d
    cbb8:	.short	0x2104
    cbba:	.byte	0x1d
    cbbb:	.byte	0x00
    cbbc:	mvn.w	r3, #2147483648	; 0x80000000
    cbc0:	str	r3, [sp, #20]
    cbc2:	mov.w	r3, #4294967295
    cbc6:	str	r3, [sp, #16]
    cbc8:	lsls	r1, r5, #28
    cbca:	bpl.w	c2a8 <_strtod_l+0x270>
    cbce:	ldr	r3, [sp, #20]
    cbd0:	orr.w	r3, r3, #2147483648	; 0x80000000
    cbd4:	str	r3, [sp, #20]
    cbd6:	b.w	c2a8 <_strtod_l+0x270>
    cbda:	ldr	r3, [pc, #172]	; (cc88 <_strtod_l+0xc50>)
    cbdc:	str	r3, [sp, #20]
    cbde:	movs	r3, #0
    cbe0:	str	r3, [sp, #16]
    cbe2:	b.n	cbc8 <_strtod_l+0xb90>
    cbe4:	ldr	r3, [sp, #120]	; 0x78
    cbe6:	str	r3, [sp, #16]
    cbe8:	ldr	r3, [sp, #124]	; 0x7c
    cbea:	str	r3, [sp, #20]
    cbec:	b.n	cbc8 <_strtod_l+0xb90>
    cbee:	movs	r3, #0
    cbf0:	str	r3, [sp, #20]
    cbf2:	str	r3, [sp, #16]
    cbf4:	b.n	cbc8 <_strtod_l+0xb90>
    cbf6:	ldr	r2, [sp, #116]	; 0x74
    cbf8:	ldr	r3, [sp, #124]	; 0x7c
    cbfa:	ldr	r1, [sp, #120]	; 0x78
    cbfc:	str	r1, [sp, #16]
    cbfe:	addw	r2, r2, #1075	; 0x433
    cc02:	bic.w	r3, r3, #1048576	; 0x100000
    cc06:	orr.w	r3, r3, r2, lsl #20
    cc0a:	str	r3, [sp, #20]
    cc0c:	b.n	cbc8 <_strtod_l+0xb90>
    cc0e:	vldr	d7, [sp, #56]	; 0x38
    cc12:	vstr	d7, [sp, #80]	; 0x50
    cc16:	b.n	c5b4 <_strtod_l+0x57c>
    cc18:	vldr	d7, [pc, #92]	; cc78 <_strtod_l+0xc40>
    cc1c:	vstr	d7, [sp, #56]	; 0x38
    cc20:	b.n	c5a0 <_strtod_l+0x568>
    cc22:	ldrd	r1, r2, [sp, #16]
    cc26:	mov	r8, r2
    cc28:	cmp	r2, #0
    cc2a:	bne.w	c846 <_strtod_l+0x80e>
    cc2e:	movs	r3, #34	; 0x22
    cc30:	str.w	r3, [fp]
    cc34:	ldr	r0, [sp, #112]	; 0x70
    cc36:	mov.w	r8, #0
    cc3a:	mov.w	r9, #0
    cc3e:	b.n	c89c <_strtod_l+0x864>
    cc40:	ldr	r2, [sp, #108]	; 0x6c
    cc42:	str	r2, [sp, #32]
    cc44:	movs	r5, #0
    cc46:	subs	r3, #48	; 0x30
    cc48:	adds	r7, r0, #1
    cc4a:	mov	r1, r2
    cc4c:	mov	sl, r5
    cc4e:	mov	r8, r5
    cc50:	movs	r4, #1
    cc52:	add.w	r5, r5, r5, lsl #2
    cc56:	add.w	r5, r3, r5, lsl #1
    cc5a:	movs	r0, #0
    cc5c:	b.n	cb44 <_strtod_l+0xb0c>
    cc5e:	nop
    cc60:	.word	0x94a03595
    cc64:	.word	0x3fcfffff
    cc68:	.word	0x94a03595
    cc6c:	.word	0x3fdfffff
    cc70:	.word	0x35afe535
    cc74:	.word	0x3fe00000
    cc78:	.word	0x00000000
    cc7c:	.word	0x3ff00000
    cc80:	.word	0x7c9fffff
    cc84:	.word	0x7fefffff
    cc88:	.word	0x7ff00000
    cc8c:	.word	0x00013320
    cc90:	.word	0x00013050
    cc94:	ldr	r1, [sp, #44]	; 0x2c
    cc96:	cmn.w	r1, #22
    cc9a:	blt.w	c35c <_strtod_l+0x324>
    cc9e:	ldr	r2, [pc, #600]	; (cef8 <_strtod_l+0xec0>)
    cca0:	sub.w	r2, r2, r1, lsl #3
    cca4:	ldrd	r2, r3, [r2]
    cca8:	ldrd	r0, r1, [sp, #16]
    ccac:	bl	aa10 <__aeabi_ddiv>
    ccb0:	mov	r8, r0
    ccb2:	mov	r9, r1
    ccb4:	b.w	c168 <_strtod_l+0x130>
    ccb8:	ldr	r3, [sp, #52]	; 0x34
    ccba:	ldrd	r8, r9, [sp, #32]
    ccbe:	cmp	r3, #0
    ccc0:	beq.w	cdd4 <_strtod_l+0xd9c>
    ccc4:	ldrd	r4, r5, [sp, #16]
    ccc8:	ldr	r3, [pc, #560]	; (cefc <_strtod_l+0xec4>)
    ccca:	ubfx	r1, r5, #0, #20
    ccce:	cmp	r1, r3
    ccd0:	mov	r2, r5
    ccd2:	beq.w	ce2a <_strtod_l+0xdf2>
    ccd6:	ldr	r3, [sp, #76]	; 0x4c
    ccd8:	cmp	r3, #0
    ccda:	beq.w	cdec <_strtod_l+0xdb4>
    ccde:	ldr	r2, [sp, #20]
    cce0:	tst	r3, r2
    cce2:	beq.n	cd06 <_strtod_l+0xcce>
    cce4:	ldr	r3, [sp, #52]	; 0x34
    cce6:	ldr	r2, [sp, #40]	; 0x28
    cce8:	ldrd	r0, r1, [sp, #16]
    ccec:	cmp	r3, #0
    ccee:	beq.w	cdfc <_strtod_l+0xdc4>
    ccf2:	bl	bffc <sulp>
    ccf6:	mov	r2, r0
    ccf8:	mov	r3, r1
    ccfa:	mov	r0, r8
    ccfc:	mov	r1, r9
    ccfe:	bl	a458 <__adddf3>
    cd02:	mov	r8, r0
    cd04:	mov	r9, r1
    cd06:	ldr	r3, [sp, #40]	; 0x28
    cd08:	cbz	r3, cd3a <_strtod_l+0xd02>
    cd0a:	ldr	r3, [pc, #500]	; (cf00 <_strtod_l+0xec8>)
    cd0c:	str	r3, [sp, #92]	; 0x5c
    cd0e:	movs	r3, #0
    cd10:	str	r3, [sp, #88]	; 0x58
    cd12:	ldrd	r2, r3, [sp, #88]	; 0x58
    cd16:	mov	r0, r8
    cd18:	mov	r1, r9
    cd1a:	bl	a7bc <__aeabi_dmul>
    cd1e:	mov	r3, r0
    cd20:	mov	r4, r1
    cd22:	mov	r8, r0
    cd24:	mov	r9, r1
    cd26:	strd	r3, r4, [sp, #16]
    cd2a:	cbnz	r1, cd3a <_strtod_l+0xd02>
    cd2c:	ldr	r3, [sp, #16]
    cd2e:	cbnz	r3, cd3a <_strtod_l+0xd02>
    cd30:	movs	r3, #34	; 0x22
    cd32:	ldr	r0, [sp, #112]	; 0x70
    cd34:	str.w	r3, [fp]
    cd38:	b.n	c89c <_strtod_l+0x864>
    cd3a:	ldr	r0, [sp, #112]	; 0x70
    cd3c:	b.n	c89c <_strtod_l+0x864>
    cd3e:	ldr	r3, [sp, #52]	; 0x34
    cd40:	ldrd	r8, r9, [sp, #32]
    cd44:	cmp	r3, #0
    cd46:	bne.n	cd06 <_strtod_l+0xcce>
    cd48:	ldrd	r1, r2, [sp, #16]
    cd4c:	cmp	r1, #0
    cd4e:	bne.n	cd06 <_strtod_l+0xcce>
    cd50:	ubfx	r3, r2, #0, #20
    cd54:	mov	r4, r2
    cd56:	cmp	r3, #0
    cd58:	bne.n	cd06 <_strtod_l+0xcce>
    cd5a:	bic.w	r3, r2, #2147483648	; 0x80000000
    cd5e:	lsrs	r3, r3, #20
    cd60:	lsls	r3, r3, #20
    cd62:	cmp.w	r3, #112197632	; 0x6b00000
    cd66:	bls.n	cd06 <_strtod_l+0xcce>
    cd68:	ldr	r3, [r7, #20]
    cd6a:	cbnz	r3, cd72 <_strtod_l+0xd3a>
    cd6c:	ldr	r3, [r7, #16]
    cd6e:	cmp	r3, #1
    cd70:	ble.n	cd06 <_strtod_l+0xcce>
    cd72:	mov	r1, r7
    cd74:	movs	r2, #1
    cd76:	mov	r0, fp
    cd78:	bl	11558 <__lshift>
    cd7c:	mov	r1, sl
    cd7e:	mov	r7, r0
    cd80:	bl	11608 <__mcmp>
    cd84:	cmp	r0, #0
    cd86:	ble.n	cd06 <_strtod_l+0xcce>
    cd88:	ldr	r3, [sp, #40]	; 0x28
    cd8a:	cmp	r3, #0
    cd8c:	bne.w	ce94 <_strtod_l+0xe5c>
    cd90:	ldr	r3, [pc, #368]	; (cf04 <_strtod_l+0xecc>)
    cd92:	ands	r3, r4
    cd94:	sub.w	r3, r3, #1048576	; 0x100000
    cd98:	mvn.w	r3, r3, lsr #20
    cd9c:	mvn.w	r3, r3, lsl #20
    cda0:	str	r3, [sp, #20]
    cda2:	mov.w	r3, #4294967295
    cda6:	str	r3, [sp, #16]
    cda8:	ldrd	r8, r9, [sp, #16]
    cdac:	b.n	cd06 <_strtod_l+0xcce>
    cdae:	ldr	r3, [sp, #88]	; 0x58
    cdb0:	adds	r3, #1
    cdb2:	bne.w	c9ea <_strtod_l+0x9b2>
    cdb6:	b.n	c888 <_strtod_l+0x850>
    cdb8:	add.w	r3, r1, #55574528	; 0x3500000
    cdbc:	str	r3, [sp, #20]
    cdbe:	b.w	c390 <_strtod_l+0x358>
    cdc2:	vldr	d7, [pc, #292]	; cee8 <_strtod_l+0xeb0>
    cdc6:	vstr	d7, [sp, #96]	; 0x60
    cdca:	vldr	d7, [pc, #292]	; cef0 <_strtod_l+0xeb8>
    cdce:	vstr	d7, [sp, #56]	; 0x38
    cdd2:	b.n	c6e2 <_strtod_l+0x6aa>
    cdd4:	ldrd	r1, r2, [sp, #16]
    cdd8:	ubfx	r3, r2, #0, #20
    cddc:	mov	r4, r2
    cdde:	cmp	r3, #0
    cde0:	bne.w	ccd6 <_strtod_l+0xc9e>
    cde4:	cmp	r1, #0
    cde6:	bne.w	ccd6 <_strtod_l+0xc9e>
    cdea:	b.n	cd88 <_strtod_l+0xd50>
    cdec:	ldr	r3, [sp, #56]	; 0x38
    cdee:	ldr	r2, [sp, #16]
    cdf0:	tst	r3, r2
    cdf2:	beq.n	cd06 <_strtod_l+0xcce>
    cdf4:	b.n	cce4 <_strtod_l+0xcac>
    cdf6:	mov.w	r8, #0
    cdfa:	b.n	c7f4 <_strtod_l+0x7bc>
    cdfc:	bl	bffc <sulp>
    ce00:	mov	r2, r0
    ce02:	mov	r3, r1
    ce04:	mov	r0, r8
    ce06:	mov	r1, r9
    ce08:	bl	a454 <__aeabi_dsub>
    ce0c:	movs	r2, #0
    ce0e:	movs	r3, #0
    ce10:	mov	r8, r0
    ce12:	mov	r9, r1
    ce14:	bl	ac8c <__aeabi_dcmpeq>
    ce18:	cmp	r0, #0
    ce1a:	bne.w	cc2e <_strtod_l+0xbf6>
    ce1e:	b.n	cd06 <_strtod_l+0xcce>
    ce20:	cmp	r6, #0
    ce22:	str	r3, [sp, #40]	; 0x28
    ce24:	bgt.w	cab8 <_strtod_l+0xa80>
    ce28:	b.n	cb08 <_strtod_l+0xad0>
    ce2a:	ldr	r3, [sp, #40]	; 0x28
    ce2c:	ldr	r1, [sp, #16]
    ce2e:	cbz	r3, ce6a <_strtod_l+0xe32>
    ce30:	ldr	r3, [pc, #208]	; (cf04 <_strtod_l+0xecc>)
    ce32:	ands	r3, r5
    ce34:	cmp.w	r3, #111149056	; 0x6a00000
    ce38:	bhi.n	ce6a <_strtod_l+0xe32>
    ce3a:	lsrs	r3, r3, #20
    ce3c:	rsb	r3, r3, #107	; 0x6b
    ce40:	mov.w	r0, #4294967295
    ce44:	lsl.w	r3, r0, r3
    ce48:	cmp	r3, r1
    ce4a:	bne.w	ccd6 <_strtod_l+0xc9e>
    ce4e:	ldr	r1, [pc, #184]	; (cf08 <_strtod_l+0xed0>)
    ce50:	cmp	r2, r1
    ce52:	beq.w	c882 <_strtod_l+0x84a>
    ce56:	ldr	r3, [pc, #172]	; (cf04 <_strtod_l+0xecc>)
    ce58:	ands	r3, r2
    ce5a:	add.w	r3, r3, #1048576	; 0x100000
    ce5e:	str	r3, [sp, #20]
    ce60:	movs	r3, #0
    ce62:	str	r3, [sp, #16]
    ce64:	ldrd	r8, r9, [sp, #16]
    ce68:	b.n	cd06 <_strtod_l+0xcce>
    ce6a:	mov.w	r3, #4294967295
    ce6e:	b.n	ce48 <_strtod_l+0xe10>
    ce70:	add	r0, sp, #108	; 0x6c
    ce72:	add	r2, sp, #120	; 0x78
    ce74:	ldr	r1, [pc, #148]	; (cf0c <_strtod_l+0xed4>)
    ce76:	bl	10f48 <__hexnan>
    ce7a:	cmp	r0, #5
    ce7c:	bne.w	c86c <_strtod_l+0x834>
    ce80:	ldr	r3, [sp, #124]	; 0x7c
    ce82:	orr.w	r3, r3, #2139095040	; 0x7f800000
    ce86:	orr.w	r3, r3, #7340032	; 0x700000
    ce8a:	str	r3, [sp, #20]
    ce8c:	ldr	r3, [sp, #120]	; 0x78
    ce8e:	str	r3, [sp, #16]
    ce90:	b.w	c2a8 <_strtod_l+0x270>
    ce94:	ldr	r3, [pc, #108]	; (cf04 <_strtod_l+0xecc>)
    ce96:	ands	r3, r4
    ce98:	cmp.w	r3, #112197632	; 0x6b00000
    ce9c:	bgt.w	cd94 <_strtod_l+0xd5c>
    cea0:	cmp.w	r3, #57671680	; 0x3700000
    cea4:	bgt.w	cd0a <_strtod_l+0xcd2>
    cea8:	b.n	cc2e <_strtod_l+0xbf6>
    ceaa:	mov.w	r2, #4294967295
    ceae:	lsl.w	r3, r2, r3
    ceb2:	ldr	r2, [sp, #16]
    ceb4:	ands	r2, r3
    ceb6:	str	r2, [sp, #16]
    ceb8:	b.n	cb08 <_strtod_l+0xad0>
    ceba:	strd	r0, r1, [sp, #16]
    cebe:	b.n	c7f4 <_strtod_l+0x7bc>
    cec0:	strd	r0, r1, [sp, #16]
    cec4:	b.n	cadc <_strtod_l+0xaa4>
    cec6:	subs	r3, #32
    cec8:	mov.w	r2, #4294967295
    cecc:	lsl.w	r3, r2, r3
    ced0:	ands	r3, r1
    ced2:	str	r3, [sp, #20]
    ced4:	b.n	cb08 <_strtod_l+0xad0>
    ced6:	mov	r0, r4
    ced8:	ldr	r1, [sp, #108]	; 0x6c
    ceda:	adds	r4, #1
    cedc:	b.n	cb30 <_strtod_l+0xaf8>
    cede:	mov	r0, r1
    cee0:	ldr	r1, [sp, #108]	; 0x6c
    cee2:	b.n	cb44 <_strtod_l+0xb0c>
    cee4:	nop.w
    cee8:	.word	0x00000000
    ceec:	.word	0xbfe00000
    cef0:	.word	0x00000000
    cef4:	.word	0x3fe00000
    cef8:	.word	0x00013320
    cefc:	.word	0x000fffff
    cf00:	.word	0x39500000
    cf04:	.word	0x7ff00000
    cf08:	.word	0x7fefffff
    cf0c:	.word	0x0001303c

0000cf10 <_strtod_r>:
    cf10:	ldr	r3, [pc, #20]	; (cf28 <_strtod_r+0x18>)
    cf12:	ldr	r3, [r3, #0]
    cf14:	push	{r4}
    cf16:	ldr	r3, [r3, #52]	; 0x34
    cf18:	ldr	r4, [pc, #16]	; (cf2c <_strtod_r+0x1c>)
    cf1a:	cmp	r3, #0
    cf1c:	it	eq
    cf1e:	moveq	r3, r4
    cf20:	ldr.w	r4, [sp], #4
    cf24:	b.w	c038 <_strtod_l>
    cf28:	.word	0x1fff1848
    cf2c:	.word	0x1fff184c

0000cf30 <_strtol_l.isra.0>:
    cf30:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cf34:	ldr.w	r9, [sp, #40]	; 0x28
    cf38:	mov	r7, r1
    cf3a:	mov	r8, r0
    cf3c:	mov	r6, r2
    cf3e:	mov	r5, r3
    cf40:	mov	fp, r1
    cf42:	b.n	cf46 <_strtol_l.isra.0+0x16>
    cf44:	mov	fp, r4
    cf46:	mov	r4, fp
    cf48:	mov	r0, r9
    cf4a:	ldrb.w	sl, [r4], #1
    cf4e:	bl	b200 <__locale_ctype_ptr_l>
    cf52:	add	r0, sl
    cf54:	ldrb	r1, [r0, #1]
    cf56:	and.w	r1, r1, #8
    cf5a:	and.w	ip, r1, #255	; 0xff
    cf5e:	cmp	r1, #0
    cf60:	bne.n	cf44 <_strtol_l.isra.0+0x14>
    cf62:	mov	r2, sl
    cf64:	cmp	r2, #45	; 0x2d
    cf66:	beq.n	d02c <_strtol_l.isra.0+0xfc>
    cf68:	cmp	r2, #43	; 0x2b
    cf6a:	itt	eq
    cf6c:	ldrbeq.w	r2, [fp, #1]
    cf70:	addeq.w	r4, fp, #2
    cf74:	cmp	r5, #0
    cf76:	beq.n	d000 <_strtol_l.isra.0+0xd0>
    cf78:	cmp	r5, #16
    cf7a:	beq.n	d048 <_strtol_l.isra.0+0x118>
    cf7c:	mov	r9, r5
    cf7e:	cmp.w	ip, #0
    cf82:	ite	eq
    cf84:	mvneq.w	sl, #2147483648	; 0x80000000
    cf88:	movne.w	sl, #2147483648	; 0x80000000
    cf8c:	movs	r1, #0
    cf8e:	udiv	lr, sl, r9
    cf92:	mov	r0, r1
    cf94:	mls	sl, r9, lr, sl
    cf98:	b.n	cfa6 <_strtol_l.isra.0+0x76>
    cf9a:	beq.n	cff0 <_strtol_l.isra.0+0xc0>
    cf9c:	mla	r0, r9, r0, r3
    cfa0:	movs	r1, #1
    cfa2:	ldrb.w	r2, [r4], #1
    cfa6:	sub.w	r3, r2, #48	; 0x30
    cfaa:	cmp	r3, #9
    cfac:	bls.n	cfba <_strtol_l.isra.0+0x8a>
    cfae:	sub.w	r3, r2, #65	; 0x41
    cfb2:	cmp	r3, #25
    cfb4:	bhi.n	cfcc <_strtol_l.isra.0+0x9c>
    cfb6:	sub.w	r3, r2, #55	; 0x37
    cfba:	cmp	r5, r3
    cfbc:	ble.n	cfdc <_strtol_l.isra.0+0xac>
    cfbe:	adds	r2, r1, #1
    cfc0:	beq.n	cfa2 <_strtol_l.isra.0+0x72>
    cfc2:	cmp	lr, r0
    cfc4:	bcs.n	cf9a <_strtol_l.isra.0+0x6a>
    cfc6:	mov.w	r1, #4294967295
    cfca:	b.n	cfa2 <_strtol_l.isra.0+0x72>
    cfcc:	sub.w	r3, r2, #97	; 0x61
    cfd0:	cmp	r3, #25
    cfd2:	bhi.n	cfdc <_strtol_l.isra.0+0xac>
    cfd4:	sub.w	r3, r2, #87	; 0x57
    cfd8:	cmp	r5, r3
    cfda:	bgt.n	cfbe <_strtol_l.isra.0+0x8e>
    cfdc:	adds	r3, r1, #1
    cfde:	beq.n	d00c <_strtol_l.isra.0+0xdc>
    cfe0:	cmp.w	ip, #0
    cfe4:	bne.n	d008 <_strtol_l.isra.0+0xd8>
    cfe6:	cbz	r6, cffc <_strtol_l.isra.0+0xcc>
    cfe8:	cbnz	r1, d024 <_strtol_l.isra.0+0xf4>
    cfea:	str	r7, [r6, #0]
    cfec:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cff0:	cmp	sl, r3
    cff2:	bge.n	cf9c <_strtol_l.isra.0+0x6c>
    cff4:	mov	r0, lr
    cff6:	mov.w	r1, #4294967295
    cffa:	b.n	cfa2 <_strtol_l.isra.0+0x72>
    cffc:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d000:	cmp	r2, #48	; 0x30
    d002:	beq.n	d03a <_strtol_l.isra.0+0x10a>
    d004:	movs	r5, #10
    d006:	b.n	cf7c <_strtol_l.isra.0+0x4c>
    d008:	negs	r0, r0
    d00a:	b.n	cfe6 <_strtol_l.isra.0+0xb6>
    d00c:	cmp.w	ip, #0
    d010:	mov.w	r3, #34	; 0x22
    d014:	ite	eq
    d016:	mvneq.w	r0, #2147483648	; 0x80000000
    d01a:	movne.w	r0, #2147483648	; 0x80000000
    d01e:	str.w	r3, [r8]
    d022:	cbz	r6, d062 <_strtol_l.isra.0+0x132>
    d024:	subs	r7, r4, #1
    d026:	str	r7, [r6, #0]
    d028:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d02c:	add.w	r4, fp, #2
    d030:	ldrb.w	r2, [fp, #1]
    d034:	mov.w	ip, #1
    d038:	b.n	cf74 <_strtol_l.isra.0+0x44>
    d03a:	ldrb	r3, [r4, #0]
    d03c:	and.w	r3, r3, #223	; 0xdf
    d040:	cmp	r3, #88	; 0x58
    d042:	beq.n	d056 <_strtol_l.isra.0+0x126>
    d044:	movs	r5, #8
    d046:	b.n	cf7c <_strtol_l.isra.0+0x4c>
    d048:	cmp	r2, #48	; 0x30
    d04a:	bne.n	cf7c <_strtol_l.isra.0+0x4c>
    d04c:	ldrb	r3, [r4, #0]
    d04e:	and.w	r3, r3, #223	; 0xdf
    d052:	cmp	r3, #88	; 0x58
    d054:	bne.n	cf7c <_strtol_l.isra.0+0x4c>
    d056:	mov.w	r9, #16
    d05a:	ldrb	r2, [r4, #1]
    d05c:	mov	r5, r9
    d05e:	adds	r4, #2
    d060:	b.n	cf7e <_strtol_l.isra.0+0x4e>
    d062:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d066:	nop

0000d068 <_strtol_r>:
    d068:	push	{r4, r5, lr}
    d06a:	ldr	r4, [pc, #24]	; (d084 <_strtol_r+0x1c>)
    d06c:	ldr	r5, [pc, #24]	; (d088 <_strtol_r+0x20>)
    d06e:	ldr	r4, [r4, #0]
    d070:	ldr	r4, [r4, #52]	; 0x34
    d072:	sub	sp, #12
    d074:	cmp	r4, #0
    d076:	it	eq
    d078:	moveq	r4, r5
    d07a:	str	r4, [sp, #0]
    d07c:	bl	cf30 <_strtol_l.isra.0>
    d080:	add	sp, #12
    d082:	pop	{r4, r5, pc}
    d084:	.word	0x1fff1848
    d088:	.word	0x1fff184c
    d08c:	.word	0xffffffff

0000d090 <_svfprintf_r>:
    d090:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d094:	sub	sp, #260	; 0x104
    d096:	mov	r4, r1
    d098:	str	r1, [sp, #20]
    d09a:	mov	r5, r2
    d09c:	str	r3, [sp, #40]	; 0x28
    d09e:	str	r0, [sp, #24]
    d0a0:	bl	110e8 <_localeconv_r>
    d0a4:	ldr	r3, [r0, #0]
    d0a6:	str	r3, [sp, #76]	; 0x4c
    d0a8:	mov	r0, r3
    d0aa:	bl	be80 <strlen>
    d0ae:	ldrh	r3, [r4, #12]
    d0b0:	str	r0, [sp, #72]	; 0x48
    d0b2:	lsls	r6, r3, #24
    d0b4:	bpl.n	d0be <_svfprintf_r+0x2e>
    d0b6:	ldr	r3, [r4, #16]
    d0b8:	cmp	r3, #0
    d0ba:	beq.w	e320 <_svfprintf_r+0x1290>
    d0be:	vldr	d7, [pc, #664]	; d358 <_svfprintf_r+0x2c8>
    d0c2:	movs	r3, #0
    d0c4:	vstr	d7, [sp, #64]	; 0x40
    d0c8:	str	r3, [sp, #56]	; 0x38
    d0ca:	str	r3, [sp, #148]	; 0x94
    d0cc:	str	r3, [sp, #144]	; 0x90
    d0ce:	str	r3, [sp, #84]	; 0x54
    d0d0:	str	r3, [sp, #28]
    d0d2:	ldr.w	sl, [pc, #656]	; d364 <_svfprintf_r+0x2d4>
    d0d6:	add	r3, sp, #192	; 0xc0
    d0d8:	str	r3, [sp, #140]	; 0x8c
    d0da:	mov	r9, r3
    d0dc:	mov	r8, r5
    d0de:	ldrb.w	r3, [r8]
    d0e2:	mov	r4, r8
    d0e4:	cbz	r3, d122 <_svfprintf_r+0x92>
    d0e6:	cmp	r3, #37	; 0x25
    d0e8:	bne.n	d0f0 <_svfprintf_r+0x60>
    d0ea:	b.n	d122 <_svfprintf_r+0x92>
    d0ec:	cmp	r3, #37	; 0x25
    d0ee:	beq.n	d0f8 <_svfprintf_r+0x68>
    d0f0:	ldrb.w	r3, [r4, #1]!
    d0f4:	cmp	r3, #0
    d0f6:	bne.n	d0ec <_svfprintf_r+0x5c>
    d0f8:	rsb	r5, r8, r4
    d0fc:	cbz	r5, d122 <_svfprintf_r+0x92>
    d0fe:	ldr	r3, [sp, #144]	; 0x90
    d100:	ldr	r2, [sp, #148]	; 0x94
    d102:	str.w	r8, [r9]
    d106:	adds	r3, #1
    d108:	add	r2, r5
    d10a:	cmp	r3, #7
    d10c:	str.w	r5, [r9, #4]
    d110:	str	r2, [sp, #148]	; 0x94
    d112:	str	r3, [sp, #144]	; 0x90
    d114:	bgt.w	d264 <_svfprintf_r+0x1d4>
    d118:	add.w	r9, r9, #8
    d11c:	ldr	r3, [sp, #28]
    d11e:	add	r3, r5
    d120:	str	r3, [sp, #28]
    d122:	ldrb	r3, [r4, #0]
    d124:	cmp	r3, #0
    d126:	beq.w	d276 <_svfprintf_r+0x1e6>
    d12a:	movs	r3, #0
    d12c:	mov	r2, r3
    d12e:	strb.w	r3, [sp, #111]	; 0x6f
    d132:	mov	r1, r3
    d134:	str	r3, [sp, #32]
    d136:	str	r3, [sp, #12]
    d138:	mov.w	fp, #4294967295
    d13c:	ldrb	r3, [r4, #1]
    d13e:	add.w	r8, r4, #1
    d142:	mov	r5, fp
    d144:	add.w	r8, r8, #1
    d148:	sub.w	r0, r3, #32
    d14c:	cmp	r0, #88	; 0x58
    d14e:	bhi.w	d9ba <_svfprintf_r+0x92a>
    d152:	tbh	[pc, r0, lsl #1]
    d156:	.short	0x03a0
    d158:	.word	0x04320432
    d15c:	.word	0x043203a8
    d160:	.word	0x04320432
    d164:	.word	0x04320432
    d168:	.word	0x03af0432
    d16c:	.word	0x043203bd
    d170:	.word	0x00e2005d
    d174:	.word	0x01090432
    d178:	.word	0x01100110
    d17c:	.word	0x01100110
    d180:	.word	0x01100110
    d184:	.word	0x01100110
    d188:	.word	0x04320110
    d18c:	.word	0x04320432
    d190:	.word	0x04320432
    d194:	.word	0x04320432
    d198:	.word	0x04320432
    d19c:	.word	0x01200432
    d1a0:	.word	0x04320286
    d1a4:	.word	0x04320286
    d1a8:	.word	0x04320432
    d1ac:	.word	0x02d40432
    d1b0:	.word	0x04320432
    d1b4:	.word	0x043202e5
    d1b8:	.word	0x04320432
    d1bc:	.word	0x04320432
    d1c0:	.word	0x0432030f
    d1c4:	.word	0x033d0432
    d1c8:	.word	0x04320432
    d1cc:	.word	0x04320432
    d1d0:	.word	0x04320432
    d1d4:	.word	0x04320432
    d1d8:	.word	0x04320432
    d1dc:	.word	0x0391037e
    d1e0:	.word	0x02860286
    d1e4:	.word	0x03990286
    d1e8:	.word	0x04320391
    d1ec:	.word	0x04070432
    d1f0:	.word	0x04120432
    d1f4:	.word	0x006400a3
    d1f8:	.word	0x043203c2
    d1fc:	.word	0x043203c9
    d200:	.word	0x043203ea
    d204:	.word	0x03f20432
    d208:	ldr	r0, [sp, #32]
    d20a:	str	r3, [sp, #40]	; 0x28
    d20c:	negs	r0, r0
    d20e:	str	r0, [sp, #32]
    d210:	ldr	r3, [sp, #12]
    d212:	orr.w	r3, r3, #4
    d216:	str	r3, [sp, #12]
    d218:	ldrb.w	r3, [r8]
    d21c:	b.n	d144 <_svfprintf_r+0xb4>
    d21e:	ldr	r0, [sp, #40]	; 0x28
    d220:	mov	fp, r5
    d222:	movs	r1, #0
    d224:	ldr	r4, [r0, #0]
    d226:	strb.w	r1, [sp, #111]	; 0x6f
    d22a:	adds	r7, r0, #4
    d22c:	ldr	r0, [sp, #12]
    d22e:	movs	r3, #48	; 0x30
    d230:	movs	r2, #120	; 0x78
    d232:	cmp	fp, r1
    d234:	strb.w	r3, [sp, #112]	; 0x70
    d238:	mov.w	r5, #0
    d23c:	strb.w	r2, [sp, #113]	; 0x71
    d240:	orr.w	r3, r0, #2
    d244:	blt.w	d9f4 <_svfprintf_r+0x964>
    d248:	bic.w	r3, r0, #128	; 0x80
    d24c:	orr.w	r3, r3, #2
    d250:	str	r3, [sp, #12]
    d252:	orrs.w	r3, r4, r5
    d256:	str	r7, [sp, #40]	; 0x28
    d258:	beq.w	d9a0 <_svfprintf_r+0x910>
    d25c:	mov	r7, r1
    d25e:	str	r2, [sp, #52]	; 0x34
    d260:	ldr	r0, [pc, #252]	; (d360 <_svfprintf_r+0x2d0>)
    d262:	b.n	d832 <_svfprintf_r+0x7a2>
    d264:	add	r2, sp, #140	; 0x8c
    d266:	ldr	r1, [sp, #20]
    d268:	ldr	r0, [sp, #24]
    d26a:	bl	12034 <__ssprint_r>
    d26e:	cbnz	r0, d284 <_svfprintf_r+0x1f4>
    d270:	add.w	r9, sp, #192	; 0xc0
    d274:	b.n	d11c <_svfprintf_r+0x8c>
    d276:	ldr	r3, [sp, #148]	; 0x94
    d278:	cbz	r3, d284 <_svfprintf_r+0x1f4>
    d27a:	ldr	r0, [sp, #24]
    d27c:	ldr	r1, [sp, #20]
    d27e:	add	r2, sp, #140	; 0x8c
    d280:	bl	12034 <__ssprint_r>
    d284:	ldr	r3, [sp, #20]
    d286:	ldrh	r3, [r3, #12]
    d288:	tst.w	r3, #64	; 0x40
    d28c:	ldr	r3, [sp, #28]
    d28e:	it	ne
    d290:	movne.w	r3, #4294967295
    d294:	mov	r0, r3
    d296:	add	sp, #260	; 0x104
    d298:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d29c:	str	r3, [sp, #52]	; 0x34
    d29e:	mov	fp, r5
    d2a0:	cmp	r2, #0
    d2a2:	bne.w	e70c <_svfprintf_r+0x167c>
    d2a6:	ldr	r2, [sp, #12]
    d2a8:	ands.w	r3, r2, #32
    d2ac:	beq.w	d73c <_svfprintf_r+0x6ac>
    d2b0:	ldr	r7, [sp, #40]	; 0x28
    d2b2:	adds	r7, #7
    d2b4:	bic.w	r3, r7, #7
    d2b8:	movs	r7, #0
    d2ba:	add.w	r1, r3, #8
    d2be:	cmp	fp, r7
    d2c0:	str	r1, [sp, #40]	; 0x28
    d2c2:	ldrd	r4, r5, [r3]
    d2c6:	strb.w	r7, [sp, #111]	; 0x6f
    d2ca:	blt.w	e192 <_svfprintf_r+0x1102>
    d2ce:	bic.w	r3, r2, #128	; 0x80
    d2d2:	str	r3, [sp, #12]
    d2d4:	orrs.w	r3, r4, r5
    d2d8:	beq.w	d9e4 <_svfprintf_r+0x954>
    d2dc:	add	r6, sp, #192	; 0xc0
    d2de:	lsrs	r2, r4, #3
    d2e0:	orr.w	r2, r2, r5, lsl #29
    d2e4:	lsrs	r1, r5, #3
    d2e6:	and.w	r3, r4, #7
    d2ea:	mov	r5, r1
    d2ec:	mov	r4, r2
    d2ee:	adds	r3, #48	; 0x30
    d2f0:	orrs.w	r2, r4, r5
    d2f4:	strb.w	r3, [r6, #-1]!
    d2f8:	bne.n	d2de <_svfprintf_r+0x24e>
    d2fa:	ldr	r2, [sp, #12]
    d2fc:	lsls	r1, r2, #31
    d2fe:	bpl.w	d420 <_svfprintf_r+0x390>
    d302:	cmp	r3, #48	; 0x30
    d304:	beq.w	d420 <_svfprintf_r+0x390>
    d308:	movs	r2, #48	; 0x30
    d30a:	subs	r3, r6, #1
    d30c:	strb.w	r2, [r6, #-1]
    d310:	add	r2, sp, #192	; 0xc0
    d312:	subs	r2, r2, r3
    d314:	str	r2, [sp, #36]	; 0x24
    d316:	mov	r6, r3
    d318:	b.n	d426 <_svfprintf_r+0x396>
    d31a:	ldrb.w	r3, [r8]
    d31e:	cmp	r3, #42	; 0x2a
    d320:	add.w	r4, r8, #1
    d324:	beq.w	e6f0 <_svfprintf_r+0x1660>
    d328:	sub.w	r0, r3, #48	; 0x30
    d32c:	cmp	r0, #9
    d32e:	it	ls
    d330:	movls	r5, #0
    d332:	bhi.w	e642 <_svfprintf_r+0x15b2>
    d336:	ldrb.w	r3, [r4], #1
    d33a:	add.w	r5, r5, r5, lsl #2
    d33e:	add.w	r5, r0, r5, lsl #1
    d342:	sub.w	r0, r3, #48	; 0x30
    d346:	cmp	r0, #9
    d348:	bls.n	d336 <_svfprintf_r+0x2a6>
    d34a:	orr.w	r5, r5, r5, asr #31
    d34e:	mov	r8, r4
    d350:	b.n	d148 <_svfprintf_r+0xb8>
    d352:	nop
    d354:	nop.w
	...
    d360:	.word	0x000130ac
    d364:	.word	0x00013078
    d368:	ldr	r3, [sp, #12]
    d36a:	orr.w	r3, r3, #128	; 0x80
    d36e:	str	r3, [sp, #12]
    d370:	ldrb.w	r3, [r8]
    d374:	b.n	d144 <_svfprintf_r+0xb4>
    d376:	sub.w	r0, r3, #48	; 0x30
    d37a:	movs	r3, #0
    d37c:	mov	r4, r3
    d37e:	ldrb.w	r3, [r8], #1
    d382:	add.w	r4, r4, r4, lsl #2
    d386:	add.w	r4, r0, r4, lsl #1
    d38a:	sub.w	r0, r3, #48	; 0x30
    d38e:	cmp	r0, #9
    d390:	bls.n	d37e <_svfprintf_r+0x2ee>
    d392:	str	r4, [sp, #32]
    d394:	b.n	d148 <_svfprintf_r+0xb8>
    d396:	str	r3, [sp, #52]	; 0x34
    d398:	mov	fp, r5
    d39a:	cmp	r2, #0
    d39c:	bne.w	e728 <_svfprintf_r+0x1698>
    d3a0:	ldr	r3, [sp, #12]
    d3a2:	orr.w	r3, r3, #16
    d3a6:	str	r3, [sp, #12]
    d3a8:	ldr	r3, [sp, #12]
    d3aa:	lsls	r4, r3, #26
    d3ac:	bpl.w	de1e <_svfprintf_r+0xd8e>
    d3b0:	ldr	r7, [sp, #40]	; 0x28
    d3b2:	adds	r7, #7
    d3b4:	bic.w	r7, r7, #7
    d3b8:	ldrd	r2, r3, [r7]
    d3bc:	add.w	r1, r7, #8
    d3c0:	str	r1, [sp, #40]	; 0x28
    d3c2:	mov	r4, r2
    d3c4:	mov	r5, r3
    d3c6:	cmp	r2, #0
    d3c8:	sbcs.w	r3, r3, #0
    d3cc:	blt.w	de94 <_svfprintf_r+0xe04>
    d3d0:	cmp.w	fp, #0
    d3d4:	ldrb.w	r7, [sp, #111]	; 0x6f
    d3d8:	blt.w	de5a <_svfprintf_r+0xdca>
    d3dc:	ldr	r3, [sp, #12]
    d3de:	bic.w	r3, r3, #128	; 0x80
    d3e2:	str	r3, [sp, #12]
    d3e4:	orrs.w	r3, r4, r5
    d3e8:	beq.w	d7bc <_svfprintf_r+0x72c>
    d3ec:	cmp	r5, #0
    d3ee:	it	eq
    d3f0:	cmpeq	r4, #10
    d3f2:	bcc.w	d7c6 <_svfprintf_r+0x736>
    d3f6:	add	r6, sp, #192	; 0xc0
    d3f8:	mov	r0, r4
    d3fa:	mov	r1, r5
    d3fc:	movs	r2, #10
    d3fe:	movs	r3, #0
    d400:	bl	ae4c <__aeabi_uldivmod>
    d404:	adds	r2, #48	; 0x30
    d406:	strb.w	r2, [r6, #-1]!
    d40a:	mov	r0, r4
    d40c:	mov	r1, r5
    d40e:	movs	r3, #0
    d410:	movs	r2, #10
    d412:	bl	ae4c <__aeabi_uldivmod>
    d416:	mov	r4, r0
    d418:	mov	r5, r1
    d41a:	orrs.w	r3, r4, r5
    d41e:	bne.n	d3f8 <_svfprintf_r+0x368>
    d420:	add	r3, sp, #192	; 0xc0
    d422:	subs	r3, r3, r6
    d424:	str	r3, [sp, #36]	; 0x24
    d426:	ldr	r3, [sp, #36]	; 0x24
    d428:	cmp	r3, fp
    d42a:	it	lt
    d42c:	movlt	r3, fp
    d42e:	str	r3, [sp, #16]
    d430:	movs	r3, #0
    d432:	str	r3, [sp, #60]	; 0x3c
    d434:	cbz	r7, d43c <_svfprintf_r+0x3ac>
    d436:	ldr	r3, [sp, #16]
    d438:	adds	r3, #1
    d43a:	str	r3, [sp, #16]
    d43c:	ldr	r3, [sp, #12]
    d43e:	ands.w	r3, r3, #2
    d442:	str	r3, [sp, #44]	; 0x2c
    d444:	beq.n	d44c <_svfprintf_r+0x3bc>
    d446:	ldr	r3, [sp, #16]
    d448:	adds	r3, #2
    d44a:	str	r3, [sp, #16]
    d44c:	ldr	r3, [sp, #12]
    d44e:	ands.w	r3, r3, #132	; 0x84
    d452:	str	r3, [sp, #48]	; 0x30
    d454:	bne.w	da0e <_svfprintf_r+0x97e>
    d458:	ldr	r3, [sp, #32]
    d45a:	ldr	r2, [sp, #16]
    d45c:	subs	r5, r3, r2
    d45e:	cmp	r5, #0
    d460:	ble.w	da0e <_svfprintf_r+0x97e>
    d464:	cmp	r5, #16
    d466:	ldr	r1, [sp, #148]	; 0x94
    d468:	ldr	r2, [sp, #144]	; 0x90
    d46a:	ldr	r7, [pc, #672]	; (d70c <_svfprintf_r+0x67c>)
    d46c:	ble.n	d4be <_svfprintf_r+0x42e>
    d46e:	str	r6, [sp, #80]	; 0x50
    d470:	mov	r0, r9
    d472:	movs	r4, #16
    d474:	mov	r9, r7
    d476:	ldr	r6, [sp, #20]
    d478:	mov	r7, r5
    d47a:	ldr	r5, [sp, #24]
    d47c:	b.n	d488 <_svfprintf_r+0x3f8>
    d47e:	subs	r7, #16
    d480:	cmp	r7, #16
    d482:	add.w	r0, r0, #8
    d486:	ble.n	d4b6 <_svfprintf_r+0x426>
    d488:	adds	r2, #1
    d48a:	ldr	r3, [pc, #640]	; (d70c <_svfprintf_r+0x67c>)
    d48c:	str	r2, [sp, #144]	; 0x90
    d48e:	adds	r1, #16
    d490:	cmp	r2, #7
    d492:	str	r1, [sp, #148]	; 0x94
    d494:	stmia.w	r0, {r3, r4}
    d498:	ble.n	d47e <_svfprintf_r+0x3ee>
    d49a:	add	r2, sp, #140	; 0x8c
    d49c:	mov	r1, r6
    d49e:	mov	r0, r5
    d4a0:	bl	12034 <__ssprint_r>
    d4a4:	cmp	r0, #0
    d4a6:	bne.w	d284 <_svfprintf_r+0x1f4>
    d4aa:	subs	r7, #16
    d4ac:	cmp	r7, #16
    d4ae:	ldr	r1, [sp, #148]	; 0x94
    d4b0:	ldr	r2, [sp, #144]	; 0x90
    d4b2:	add	r0, sp, #192	; 0xc0
    d4b4:	bgt.n	d488 <_svfprintf_r+0x3f8>
    d4b6:	ldr	r6, [sp, #80]	; 0x50
    d4b8:	mov	r5, r7
    d4ba:	mov	r7, r9
    d4bc:	mov	r9, r0
    d4be:	adds	r2, #1
    d4c0:	adds	r4, r5, r1
    d4c2:	cmp	r2, #7
    d4c4:	str	r4, [sp, #148]	; 0x94
    d4c6:	str	r2, [sp, #144]	; 0x90
    d4c8:	str.w	r7, [r9]
    d4cc:	str.w	r5, [r9, #4]
    d4d0:	bgt.w	dd2e <_svfprintf_r+0xc9e>
    d4d4:	ldrb.w	r7, [sp, #111]	; 0x6f
    d4d8:	add.w	r9, r9, #8
    d4dc:	cbz	r7, d4fc <_svfprintf_r+0x46c>
    d4de:	ldr	r3, [sp, #144]	; 0x90
    d4e0:	adds	r3, #1
    d4e2:	adds	r4, #1
    d4e4:	add.w	r1, sp, #111	; 0x6f
    d4e8:	movs	r2, #1
    d4ea:	cmp	r3, #7
    d4ec:	str	r4, [sp, #148]	; 0x94
    d4ee:	str	r3, [sp, #144]	; 0x90
    d4f0:	stmia.w	r9, {r1, r2}
    d4f4:	bgt.w	dc42 <_svfprintf_r+0xbb2>
    d4f8:	add.w	r9, r9, #8
    d4fc:	ldr	r3, [sp, #44]	; 0x2c
    d4fe:	cbz	r3, d51c <_svfprintf_r+0x48c>
    d500:	ldr	r3, [sp, #144]	; 0x90
    d502:	adds	r3, #1
    d504:	adds	r4, #2
    d506:	add	r1, sp, #112	; 0x70
    d508:	movs	r2, #2
    d50a:	cmp	r3, #7
    d50c:	str	r4, [sp, #148]	; 0x94
    d50e:	str	r3, [sp, #144]	; 0x90
    d510:	stmia.w	r9, {r1, r2}
    d514:	bgt.w	dc5a <_svfprintf_r+0xbca>
    d518:	add.w	r9, r9, #8
    d51c:	ldr	r3, [sp, #48]	; 0x30
    d51e:	cmp	r3, #128	; 0x80
    d520:	beq.w	dae6 <_svfprintf_r+0xa56>
    d524:	ldr	r3, [sp, #36]	; 0x24
    d526:	rsb	r7, r3, fp
    d52a:	cmp	r7, #0
    d52c:	ble.n	d596 <_svfprintf_r+0x506>
    d52e:	ldr	r2, [pc, #480]	; (d710 <_svfprintf_r+0x680>)
    d530:	ldr	r3, [sp, #144]	; 0x90
    d532:	str	r2, [sp, #44]	; 0x2c
    d534:	cmp	r7, #16
    d536:	ble.n	d57e <_svfprintf_r+0x4ee>
    d538:	mov	r2, r4
    d53a:	mov.w	fp, #16
    d53e:	ldr	r5, [sp, #24]
    d540:	ldr	r4, [sp, #20]
    d542:	b.n	d54e <_svfprintf_r+0x4be>
    d544:	subs	r7, #16
    d546:	cmp	r7, #16
    d548:	add.w	r9, r9, #8
    d54c:	ble.n	d57c <_svfprintf_r+0x4ec>
    d54e:	adds	r3, #1
    d550:	adds	r2, #16
    d552:	cmp	r3, #7
    d554:	str	r2, [sp, #148]	; 0x94
    d556:	str	r3, [sp, #144]	; 0x90
    d558:	stmia.w	r9, {sl, fp}
    d55c:	ble.n	d544 <_svfprintf_r+0x4b4>
    d55e:	add	r2, sp, #140	; 0x8c
    d560:	mov	r1, r4
    d562:	mov	r0, r5
    d564:	bl	12034 <__ssprint_r>
    d568:	cmp	r0, #0
    d56a:	bne.w	d284 <_svfprintf_r+0x1f4>
    d56e:	subs	r7, #16
    d570:	cmp	r7, #16
    d572:	ldr	r2, [sp, #148]	; 0x94
    d574:	ldr	r3, [sp, #144]	; 0x90
    d576:	add.w	r9, sp, #192	; 0xc0
    d57a:	bgt.n	d54e <_svfprintf_r+0x4be>
    d57c:	mov	r4, r2
    d57e:	adds	r3, #1
    d580:	ldr	r2, [sp, #44]	; 0x2c
    d582:	str	r3, [sp, #144]	; 0x90
    d584:	add	r4, r7
    d586:	cmp	r3, #7
    d588:	str	r4, [sp, #148]	; 0x94
    d58a:	stmia.w	r9, {r2, r7}
    d58e:	bgt.w	dc2a <_svfprintf_r+0xb9a>
    d592:	add.w	r9, r9, #8
    d596:	ldr	r3, [sp, #12]
    d598:	lsls	r2, r3, #23
    d59a:	bmi.w	da12 <_svfprintf_r+0x982>
    d59e:	ldr	r3, [sp, #144]	; 0x90
    d5a0:	ldr	r1, [sp, #36]	; 0x24
    d5a2:	str.w	r6, [r9]
    d5a6:	adds	r3, #1
    d5a8:	add	r4, r1
    d5aa:	cmp	r3, #7
    d5ac:	str	r4, [sp, #148]	; 0x94
    d5ae:	str.w	r1, [r9, #4]
    d5b2:	str	r3, [sp, #144]	; 0x90
    d5b4:	bgt.w	dbfe <_svfprintf_r+0xb6e>
    d5b8:	add.w	r9, r9, #8
    d5bc:	ldr	r3, [sp, #12]
    d5be:	lsls	r1, r3, #29
    d5c0:	bpl.n	d642 <_svfprintf_r+0x5b2>
    d5c2:	ldr	r3, [sp, #32]
    d5c4:	ldr	r2, [sp, #16]
    d5c6:	subs	r5, r3, r2
    d5c8:	cmp	r5, #0
    d5ca:	ble.n	d642 <_svfprintf_r+0x5b2>
    d5cc:	cmp	r5, #16
    d5ce:	ldr	r3, [sp, #144]	; 0x90
    d5d0:	ldr	r7, [pc, #312]	; (d70c <_svfprintf_r+0x67c>)
    d5d2:	ble.n	d61c <_svfprintf_r+0x58c>
    d5d4:	mov	r2, r4
    d5d6:	movs	r6, #16
    d5d8:	ldr.w	fp, [sp, #24]
    d5dc:	ldr	r4, [sp, #20]
    d5de:	b.n	d5ea <_svfprintf_r+0x55a>
    d5e0:	subs	r5, #16
    d5e2:	cmp	r5, #16
    d5e4:	add.w	r9, r9, #8
    d5e8:	ble.n	d61a <_svfprintf_r+0x58a>
    d5ea:	adds	r3, #1
    d5ec:	ldr	r1, [pc, #284]	; (d70c <_svfprintf_r+0x67c>)
    d5ee:	str	r3, [sp, #144]	; 0x90
    d5f0:	adds	r2, #16
    d5f2:	cmp	r3, #7
    d5f4:	str	r2, [sp, #148]	; 0x94
    d5f6:	stmia.w	r9, {r1, r6}
    d5fa:	ble.n	d5e0 <_svfprintf_r+0x550>
    d5fc:	add	r2, sp, #140	; 0x8c
    d5fe:	mov	r1, r4
    d600:	mov	r0, fp
    d602:	bl	12034 <__ssprint_r>
    d606:	cmp	r0, #0
    d608:	bne.w	d284 <_svfprintf_r+0x1f4>
    d60c:	subs	r5, #16
    d60e:	cmp	r5, #16
    d610:	ldr	r2, [sp, #148]	; 0x94
    d612:	ldr	r3, [sp, #144]	; 0x90
    d614:	add.w	r9, sp, #192	; 0xc0
    d618:	bgt.n	d5ea <_svfprintf_r+0x55a>
    d61a:	mov	r4, r2
    d61c:	adds	r3, #1
    d61e:	add	r4, r5
    d620:	cmp	r3, #7
    d622:	str	r4, [sp, #148]	; 0x94
    d624:	str	r3, [sp, #144]	; 0x90
    d626:	str.w	r7, [r9]
    d62a:	str.w	r5, [r9, #4]
    d62e:	ble.n	d642 <_svfprintf_r+0x5b2>
    d630:	add	r2, sp, #140	; 0x8c
    d632:	ldr	r1, [sp, #20]
    d634:	ldr	r0, [sp, #24]
    d636:	bl	12034 <__ssprint_r>
    d63a:	cmp	r0, #0
    d63c:	bne.w	d284 <_svfprintf_r+0x1f4>
    d640:	ldr	r4, [sp, #148]	; 0x94
    d642:	ldr	r3, [sp, #28]
    d644:	ldr	r2, [sp, #32]
    d646:	ldr	r1, [sp, #16]
    d648:	cmp	r2, r1
    d64a:	ite	ge
    d64c:	addge	r3, r3, r2
    d64e:	addlt	r3, r3, r1
    d650:	str	r3, [sp, #28]
    d652:	cmp	r4, #0
    d654:	bne.w	dc16 <_svfprintf_r+0xb86>
    d658:	movs	r3, #0
    d65a:	str	r3, [sp, #144]	; 0x90
    d65c:	add.w	r9, sp, #192	; 0xc0
    d660:	b.n	d0de <_svfprintf_r+0x4e>
    d662:	str	r3, [sp, #52]	; 0x34
    d664:	mov	fp, r5
    d666:	cmp	r2, #0
    d668:	bne.w	e730 <_svfprintf_r+0x16a0>
    d66c:	ldr	r3, [sp, #12]
    d66e:	ldr	r7, [sp, #40]	; 0x28
    d670:	lsls	r2, r3, #28
    d672:	add.w	r7, r7, #7
    d676:	bpl.w	e162 <_svfprintf_r+0x10d2>
    d67a:	bic.w	r3, r7, #7
    d67e:	vldr	d7, [r3]
    d682:	vstr	d7, [sp, #64]	; 0x40
    d686:	add.w	r2, r3, #8
    d68a:	str	r2, [sp, #40]	; 0x28
    d68c:	ldrd	r1, r2, [sp, #64]	; 0x40
    d690:	bic.w	r3, r2, #2147483648	; 0x80000000
    d694:	str	r1, [sp, #88]	; 0x58
    d696:	str	r3, [sp, #92]	; 0x5c
    d698:	ldrd	r4, r5, [sp, #88]	; 0x58
    d69c:	mov.w	r2, #4294967295
    d6a0:	mov	r0, r4
    d6a2:	mov	r1, r5
    d6a4:	ldr	r3, [pc, #108]	; (d714 <_svfprintf_r+0x684>)
    d6a6:	bl	acf0 <__aeabi_dcmpun>
    d6aa:	cmp	r0, #0
    d6ac:	bne.w	e064 <_svfprintf_r+0xfd4>
    d6b0:	mov.w	r2, #4294967295
    d6b4:	ldr	r3, [pc, #92]	; (d714 <_svfprintf_r+0x684>)
    d6b6:	mov	r0, r4
    d6b8:	mov	r1, r5
    d6ba:	bl	acb4 <__aeabi_dcmple>
    d6be:	cmp	r0, #0
    d6c0:	bne.w	e064 <_svfprintf_r+0xfd4>
    d6c4:	movs	r2, #0
    d6c6:	movs	r3, #0
    d6c8:	ldrd	r0, r1, [sp, #64]	; 0x40
    d6cc:	bl	aca0 <__aeabi_dcmplt>
    d6d0:	cmp	r0, #0
    d6d2:	bne.w	e57a <_svfprintf_r+0x14ea>
    d6d6:	ldrb.w	r7, [sp, #111]	; 0x6f
    d6da:	ldr	r6, [pc, #60]	; (d718 <_svfprintf_r+0x688>)
    d6dc:	ldr	r3, [pc, #60]	; (d71c <_svfprintf_r+0x68c>)
    d6de:	ldr	r1, [sp, #12]
    d6e0:	bic.w	r1, r1, #128	; 0x80
    d6e4:	str	r1, [sp, #12]
    d6e6:	ldr	r1, [sp, #52]	; 0x34
    d6e8:	movs	r2, #3
    d6ea:	mov.w	fp, #0
    d6ee:	str	r2, [sp, #16]
    d6f0:	cmp	r1, #71	; 0x47
    d6f2:	it	le
    d6f4:	movle	r6, r3
    d6f6:	str	r2, [sp, #36]	; 0x24
    d6f8:	str.w	fp, [sp, #60]	; 0x3c
    d6fc:	b.n	d434 <_svfprintf_r+0x3a4>
    d6fe:	ldr	r3, [sp, #12]
    d700:	orr.w	r3, r3, #8
    d704:	str	r3, [sp, #12]
    d706:	ldrb.w	r3, [r8]
    d70a:	b.n	d144 <_svfprintf_r+0xb4>
    d70c:	.word	0x000130cc
    d710:	.word	0x00013078
    d714:	.word	0x7fefffff
    d718:	.word	0x0001308c
    d71c:	.word	0x00013088
    d720:	str	r3, [sp, #52]	; 0x34
    d722:	mov	fp, r5
    d724:	cmp	r2, #0
    d726:	bne.w	e748 <_svfprintf_r+0x16b8>
    d72a:	ldr	r3, [sp, #12]
    d72c:	orr.w	r3, r3, #16
    d730:	str	r3, [sp, #12]
    d732:	ldr	r2, [sp, #12]
    d734:	ands.w	r3, r2, #32
    d738:	bne.w	d2b0 <_svfprintf_r+0x220>
    d73c:	ldr	r1, [sp, #12]
    d73e:	ands.w	r2, r1, #16
    d742:	beq.w	dffc <_svfprintf_r+0xf6c>
    d746:	ldr	r0, [sp, #40]	; 0x28
    d748:	strb.w	r3, [sp, #111]	; 0x6f
    d74c:	cmp.w	fp, #0
    d750:	ldr	r4, [r0, #0]
    d752:	add.w	r7, r0, #4
    d756:	mov.w	r5, #0
    d75a:	blt.w	e190 <_svfprintf_r+0x1100>
    d75e:	mov	r2, r1
    d760:	bic.w	r2, r2, #128	; 0x80
    d764:	str	r2, [sp, #12]
    d766:	orrs.w	r2, r4, r5
    d76a:	str	r7, [sp, #40]	; 0x28
    d76c:	beq.w	d9e4 <_svfprintf_r+0x954>
    d770:	mov	r7, r3
    d772:	b.n	d2dc <_svfprintf_r+0x24c>
    d774:	str	r3, [sp, #52]	; 0x34
    d776:	mov	fp, r5
    d778:	cmp	r2, #0
    d77a:	bne.w	e740 <_svfprintf_r+0x16b0>
    d77e:	ldr	r3, [sp, #12]
    d780:	orr.w	r3, r3, #16
    d784:	str	r3, [sp, #12]
    d786:	ldr	r2, [sp, #12]
    d788:	ands.w	r3, r2, #32
    d78c:	beq.w	dde8 <_svfprintf_r+0xd58>
    d790:	ldr	r7, [sp, #40]	; 0x28
    d792:	adds	r7, #7
    d794:	bic.w	r3, r7, #7
    d798:	movs	r7, #0
    d79a:	add.w	r1, r3, #8
    d79e:	cmp	fp, r7
    d7a0:	str	r1, [sp, #40]	; 0x28
    d7a2:	ldrd	r4, r5, [r3]
    d7a6:	strb.w	r7, [sp, #111]	; 0x6f
    d7aa:	blt.w	de5a <_svfprintf_r+0xdca>
    d7ae:	bic.w	r3, r2, #128	; 0x80
    d7b2:	str	r3, [sp, #12]
    d7b4:	orrs.w	r3, r4, r5
    d7b8:	bne.w	d3ec <_svfprintf_r+0x35c>
    d7bc:	cmp.w	fp, #0
    d7c0:	beq.w	d9ae <_svfprintf_r+0x91e>
    d7c4:	movs	r4, #0
    d7c6:	add	r6, sp, #256	; 0x100
    d7c8:	adds	r4, #48	; 0x30
    d7ca:	strb.w	r4, [r6, #-65]!
    d7ce:	b.n	d420 <_svfprintf_r+0x390>
    d7d0:	str	r3, [sp, #52]	; 0x34
    d7d2:	mov	fp, r5
    d7d4:	cmp	r2, #0
    d7d6:	bne.w	e738 <_svfprintf_r+0x16a8>
    d7da:	ldr	r3, [sp, #12]
    d7dc:	ldr	r0, [pc, #700]	; (da9c <_svfprintf_r+0xa0c>)
    d7de:	lsls	r5, r3, #26
    d7e0:	bpl.w	d94e <_svfprintf_r+0x8be>
    d7e4:	ldr	r7, [sp, #40]	; 0x28
    d7e6:	adds	r7, #7
    d7e8:	bic.w	r3, r7, #7
    d7ec:	ldrd	r4, r5, [r3]
    d7f0:	add.w	r2, r3, #8
    d7f4:	str	r2, [sp, #40]	; 0x28
    d7f6:	ldr	r2, [sp, #12]
    d7f8:	ands.w	r7, r2, #1
    d7fc:	beq.w	dc72 <_svfprintf_r+0xbe2>
    d800:	orrs.w	r3, r4, r5
    d804:	beq.w	e20c <_svfprintf_r+0x117c>
    d808:	ldrb.w	r2, [sp, #52]	; 0x34
    d80c:	strb.w	r2, [sp, #113]	; 0x71
    d810:	movs	r7, #0
    d812:	ldr	r2, [sp, #12]
    d814:	strb.w	r7, [sp, #111]	; 0x6f
    d818:	movs	r3, #48	; 0x30
    d81a:	cmp	fp, r7
    d81c:	strb.w	r3, [sp, #112]	; 0x70
    d820:	orr.w	r3, r2, #2
    d824:	blt.w	e584 <_svfprintf_r+0x14f4>
    d828:	bic.w	r3, r2, #128	; 0x80
    d82c:	orr.w	r3, r3, #2
    d830:	str	r3, [sp, #12]
    d832:	add	r6, sp, #192	; 0xc0
    d834:	lsrs	r3, r4, #4
    d836:	and.w	r1, r4, #15
    d83a:	orr.w	r3, r3, r5, lsl #28
    d83e:	lsrs	r2, r5, #4
    d840:	mov	r4, r3
    d842:	mov	r5, r2
    d844:	ldrb	r3, [r0, r1]
    d846:	strb.w	r3, [r6, #-1]!
    d84a:	orrs.w	r3, r4, r5
    d84e:	bne.n	d834 <_svfprintf_r+0x7a4>
    d850:	b.n	d420 <_svfprintf_r+0x390>
    d852:	ldr	r1, [sp, #40]	; 0x28
    d854:	str	r3, [sp, #52]	; 0x34
    d856:	ldr	r2, [r1, #0]
    d858:	strb.w	r2, [sp, #152]	; 0x98
    d85c:	movs	r3, #0
    d85e:	mov	r2, r1
    d860:	mov	r7, r3
    d862:	strb.w	r3, [sp, #111]	; 0x6f
    d866:	adds	r2, #4
    d868:	movs	r3, #1
    d86a:	str	r3, [sp, #16]
    d86c:	mov	fp, r7
    d86e:	str	r7, [sp, #60]	; 0x3c
    d870:	str	r2, [sp, #40]	; 0x28
    d872:	str	r3, [sp, #36]	; 0x24
    d874:	add	r6, sp, #152	; 0x98
    d876:	b.n	d43c <_svfprintf_r+0x3ac>
    d878:	str	r3, [sp, #52]	; 0x34
    d87a:	mov	fp, r5
    d87c:	cmp	r2, #0
    d87e:	beq.w	d3a8 <_svfprintf_r+0x318>
    d882:	strb.w	r1, [sp, #111]	; 0x6f
    d886:	b.n	d3a8 <_svfprintf_r+0x318>
    d888:	ldr	r3, [sp, #12]
    d88a:	orr.w	r3, r3, #64	; 0x40
    d88e:	str	r3, [sp, #12]
    d890:	ldrb.w	r3, [r8]
    d894:	b.n	d144 <_svfprintf_r+0xb4>
    d896:	ldrb.w	r3, [r8]
    d89a:	cmp	r1, #0
    d89c:	bne.w	d144 <_svfprintf_r+0xb4>
    d8a0:	movs	r2, #1
    d8a2:	movs	r1, #32
    d8a4:	b.n	d144 <_svfprintf_r+0xb4>
    d8a6:	ldr	r3, [sp, #12]
    d8a8:	orr.w	r3, r3, #1
    d8ac:	str	r3, [sp, #12]
    d8ae:	ldrb.w	r3, [r8]
    d8b2:	b.n	d144 <_svfprintf_r+0xb4>
    d8b4:	ldr	r4, [sp, #40]	; 0x28
    d8b6:	ldr	r3, [r4, #0]
    d8b8:	str	r3, [sp, #32]
    d8ba:	mov	r0, r3
    d8bc:	cmp	r0, #0
    d8be:	mov	r3, r4
    d8c0:	add.w	r3, r3, #4
    d8c4:	blt.w	d208 <_svfprintf_r+0x178>
    d8c8:	str	r3, [sp, #40]	; 0x28
    d8ca:	ldrb.w	r3, [r8]
    d8ce:	b.n	d144 <_svfprintf_r+0xb4>
    d8d0:	ldrb.w	r3, [r8]
    d8d4:	movs	r2, #1
    d8d6:	movs	r1, #43	; 0x2b
    d8d8:	b.n	d144 <_svfprintf_r+0xb4>
    d8da:	ldr	r3, [sp, #12]
    d8dc:	orr.w	r3, r3, #32
    d8e0:	str	r3, [sp, #12]
    d8e2:	ldrb.w	r3, [r8]
    d8e6:	b.n	d144 <_svfprintf_r+0xb4>
    d8e8:	ldr	r2, [sp, #40]	; 0x28
    d8ea:	str	r3, [sp, #52]	; 0x34
    d8ec:	ldr	r6, [r2, #0]
    d8ee:	movs	r4, #0
    d8f0:	strb.w	r4, [sp, #111]	; 0x6f
    d8f4:	adds	r7, r2, #4
    d8f6:	cmp	r6, #0
    d8f8:	beq.w	e534 <_svfprintf_r+0x14a4>
    d8fc:	cmp	r5, #0
    d8fe:	blt.w	e3c4 <_svfprintf_r+0x1334>
    d902:	mov	r2, r5
    d904:	mov	r1, r4
    d906:	mov	r0, r6
    d908:	bl	b7e0 <memchr>
    d90c:	cmp	r0, #0
    d90e:	beq.w	e5d8 <_svfprintf_r+0x1548>
    d912:	subs	r3, r0, r6
    d914:	str	r3, [sp, #36]	; 0x24
    d916:	mov	fp, r4
    d918:	bic.w	r3, r3, r3, asr #31
    d91c:	str	r7, [sp, #40]	; 0x28
    d91e:	str	r3, [sp, #16]
    d920:	str.w	fp, [sp, #60]	; 0x3c
    d924:	ldrb.w	r7, [sp, #111]	; 0x6f
    d928:	b.n	d434 <_svfprintf_r+0x3a4>
    d92a:	str	r3, [sp, #52]	; 0x34
    d92c:	mov	fp, r5
    d92e:	cmp	r2, #0
    d930:	beq.w	d786 <_svfprintf_r+0x6f6>
    d934:	strb.w	r1, [sp, #111]	; 0x6f
    d938:	b.n	d786 <_svfprintf_r+0x6f6>
    d93a:	str	r3, [sp, #52]	; 0x34
    d93c:	mov	fp, r5
    d93e:	cmp	r2, #0
    d940:	bne.w	e760 <_svfprintf_r+0x16d0>
    d944:	ldr	r3, [sp, #12]
    d946:	ldr	r0, [pc, #344]	; (daa0 <_svfprintf_r+0xa10>)
    d948:	lsls	r5, r3, #26
    d94a:	bmi.w	d7e4 <_svfprintf_r+0x754>
    d94e:	ldr	r3, [sp, #12]
    d950:	lsls	r4, r3, #27
    d952:	bpl.w	e1d2 <_svfprintf_r+0x1142>
    d956:	ldr	r2, [sp, #40]	; 0x28
    d958:	mov	r3, r2
    d95a:	adds	r3, #4
    d95c:	ldr	r4, [r2, #0]
    d95e:	str	r3, [sp, #40]	; 0x28
    d960:	movs	r5, #0
    d962:	b.n	d7f6 <_svfprintf_r+0x766>
    d964:	ldrb.w	r3, [r8]
    d968:	cmp	r3, #108	; 0x6c
    d96a:	beq.w	e2f2 <_svfprintf_r+0x1262>
    d96e:	ldr	r0, [sp, #12]
    d970:	orr.w	r0, r0, #16
    d974:	str	r0, [sp, #12]
    d976:	b.w	d144 <_svfprintf_r+0xb4>
    d97a:	cmp	r2, #0
    d97c:	bne.w	e758 <_svfprintf_r+0x16c8>
    d980:	ldr	r3, [sp, #12]
    d982:	lsls	r3, r3, #26
    d984:	bpl.w	e036 <_svfprintf_r+0xfa6>
    d988:	ldr	r2, [sp, #40]	; 0x28
    d98a:	ldr	r1, [sp, #28]
    d98c:	ldr	r3, [r2, #0]
    d98e:	asrs	r5, r1, #31
    d990:	mov	r0, r1
    d992:	adds	r2, #4
    d994:	mov	r1, r5
    d996:	str	r2, [sp, #40]	; 0x28
    d998:	strd	r0, r1, [r3]
    d99c:	b.w	d0de <_svfprintf_r+0x4e>
    d9a0:	ldr	r0, [pc, #252]	; (daa0 <_svfprintf_r+0xa10>)
    d9a2:	str	r2, [sp, #52]	; 0x34
    d9a4:	cmp.w	fp, #0
    d9a8:	bne.w	dc94 <_svfprintf_r+0xc04>
    d9ac:	mov	r7, fp
    d9ae:	mov.w	fp, #0
    d9b2:	str.w	fp, [sp, #36]	; 0x24
    d9b6:	add	r6, sp, #192	; 0xc0
    d9b8:	b.n	d426 <_svfprintf_r+0x396>
    d9ba:	str	r3, [sp, #52]	; 0x34
    d9bc:	cmp	r2, #0
    d9be:	bne.w	e750 <_svfprintf_r+0x16c0>
    d9c2:	ldr	r2, [sp, #52]	; 0x34
    d9c4:	cmp	r2, #0
    d9c6:	beq.w	d276 <_svfprintf_r+0x1e6>
    d9ca:	movs	r3, #0
    d9cc:	movs	r1, #1
    d9ce:	mov	r7, r3
    d9d0:	str	r1, [sp, #16]
    d9d2:	strb.w	r2, [sp, #152]	; 0x98
    d9d6:	strb.w	r3, [sp, #111]	; 0x6f
    d9da:	mov	fp, r3
    d9dc:	str	r3, [sp, #60]	; 0x3c
    d9de:	str	r1, [sp, #36]	; 0x24
    d9e0:	add	r6, sp, #152	; 0x98
    d9e2:	b.n	d43c <_svfprintf_r+0x3ac>
    d9e4:	cmp.w	fp, #0
    d9e8:	beq.w	e608 <_svfprintf_r+0x1578>
    d9ec:	movs	r7, #0
    d9ee:	movs	r4, #0
    d9f0:	movs	r5, #0
    d9f2:	b.n	d2dc <_svfprintf_r+0x24c>
    d9f4:	ldr	r0, [pc, #168]	; (daa0 <_svfprintf_r+0xa10>)
    d9f6:	str	r3, [sp, #12]
    d9f8:	str	r2, [sp, #52]	; 0x34
    d9fa:	orrs.w	r3, r4, r5
    d9fe:	str	r7, [sp, #40]	; 0x28
    da00:	mov.w	r7, #0
    da04:	bne.w	d832 <_svfprintf_r+0x7a2>
    da08:	movs	r4, #0
    da0a:	movs	r5, #0
    da0c:	b.n	d832 <_svfprintf_r+0x7a2>
    da0e:	ldr	r4, [sp, #148]	; 0x94
    da10:	b.n	d4dc <_svfprintf_r+0x44c>
    da12:	ldr	r3, [sp, #52]	; 0x34
    da14:	cmp	r3, #101	; 0x65
    da16:	ble.w	db6e <_svfprintf_r+0xade>
    da1a:	movs	r2, #0
    da1c:	movs	r3, #0
    da1e:	ldrd	r0, r1, [sp, #64]	; 0x40
    da22:	bl	ac8c <__aeabi_dcmpeq>
    da26:	cmp	r0, #0
    da28:	beq.w	dc98 <_svfprintf_r+0xc08>
    da2c:	ldr	r3, [sp, #144]	; 0x90
    da2e:	ldr	r2, [pc, #116]	; (daa4 <_svfprintf_r+0xa14>)
    da30:	str.w	r2, [r9]
    da34:	adds	r3, #1
    da36:	adds	r4, #1
    da38:	movs	r2, #1
    da3a:	cmp	r3, #7
    da3c:	str	r4, [sp, #148]	; 0x94
    da3e:	str	r3, [sp, #144]	; 0x90
    da40:	str.w	r2, [r9, #4]
    da44:	bgt.w	e224 <_svfprintf_r+0x1194>
    da48:	add.w	r9, r9, #8
    da4c:	ldr	r3, [sp, #116]	; 0x74
    da4e:	ldr	r2, [sp, #56]	; 0x38
    da50:	cmp	r3, r2
    da52:	blt.n	da5c <_svfprintf_r+0x9cc>
    da54:	ldr	r3, [sp, #12]
    da56:	lsls	r3, r3, #31
    da58:	bpl.w	d5bc <_svfprintf_r+0x52c>
    da5c:	ldr	r3, [sp, #144]	; 0x90
    da5e:	ldr	r1, [sp, #72]	; 0x48
    da60:	ldr	r2, [sp, #76]	; 0x4c
    da62:	str.w	r2, [r9]
    da66:	adds	r3, #1
    da68:	add	r4, r1
    da6a:	cmp	r3, #7
    da6c:	str	r4, [sp, #148]	; 0x94
    da6e:	str.w	r1, [r9, #4]
    da72:	str	r3, [sp, #144]	; 0x90
    da74:	bgt.w	e306 <_svfprintf_r+0x1276>
    da78:	add.w	r9, r9, #8
    da7c:	ldr	r3, [sp, #56]	; 0x38
    da7e:	subs	r5, r3, #1
    da80:	cmp	r5, #0
    da82:	ble.w	d5bc <_svfprintf_r+0x52c>
    da86:	ldr	r2, [pc, #32]	; (daa8 <_svfprintf_r+0xa18>)
    da88:	ldr	r3, [sp, #144]	; 0x90
    da8a:	str	r2, [sp, #44]	; 0x2c
    da8c:	cmp	r5, #16
    da8e:	ble.w	de64 <_svfprintf_r+0xdd4>
    da92:	movs	r6, #16
    da94:	ldr	r7, [sp, #24]
    da96:	ldr.w	fp, [sp, #20]
    da9a:	b.n	dab8 <_svfprintf_r+0xa28>
    da9c:	.word	0x00013098
    daa0:	.word	0x000130ac
    daa4:	.word	0x000130c8
    daa8:	.word	0x00013078
    daac:	add.w	r9, r9, #8
    dab0:	subs	r5, #16
    dab2:	cmp	r5, #16
    dab4:	ble.w	de64 <_svfprintf_r+0xdd4>
    dab8:	adds	r3, #1
    daba:	adds	r4, #16
    dabc:	cmp	r3, #7
    dabe:	str	r4, [sp, #148]	; 0x94
    dac0:	str	r3, [sp, #144]	; 0x90
    dac2:	str.w	sl, [r9]
    dac6:	str.w	r6, [r9, #4]
    daca:	ble.n	daac <_svfprintf_r+0xa1c>
    dacc:	add	r2, sp, #140	; 0x8c
    dace:	mov	r1, fp
    dad0:	mov	r0, r7
    dad2:	bl	12034 <__ssprint_r>
    dad6:	cmp	r0, #0
    dad8:	bne.w	d284 <_svfprintf_r+0x1f4>
    dadc:	ldr	r4, [sp, #148]	; 0x94
    dade:	ldr	r3, [sp, #144]	; 0x90
    dae0:	add.w	r9, sp, #192	; 0xc0
    dae4:	b.n	dab0 <_svfprintf_r+0xa20>
    dae6:	ldr	r3, [sp, #32]
    dae8:	ldr	r2, [sp, #16]
    daea:	subs	r7, r3, r2
    daec:	cmp	r7, #0
    daee:	ble.w	d524 <_svfprintf_r+0x494>
    daf2:	ldr	r2, [pc, #752]	; (dde4 <_svfprintf_r+0xd54>)
    daf4:	ldr	r3, [sp, #144]	; 0x90
    daf6:	str	r2, [sp, #44]	; 0x2c
    daf8:	cmp	r7, #16
    dafa:	ble.n	db54 <_svfprintf_r+0xac4>
    dafc:	mov	r2, r9
    dafe:	mov	r1, r4
    db00:	mov	r9, r7
    db02:	movs	r5, #16
    db04:	mov	r7, r6
    db06:	ldr	r4, [sp, #24]
    db08:	ldr	r6, [sp, #20]
    db0a:	b.n	db1a <_svfprintf_r+0xa8a>
    db0c:	sub.w	r9, r9, #16
    db10:	cmp.w	r9, #16
    db14:	add.w	r2, r2, #8
    db18:	ble.n	db4c <_svfprintf_r+0xabc>
    db1a:	adds	r3, #1
    db1c:	adds	r1, #16
    db1e:	cmp	r3, #7
    db20:	str	r1, [sp, #148]	; 0x94
    db22:	str	r3, [sp, #144]	; 0x90
    db24:	str.w	sl, [r2]
    db28:	str	r5, [r2, #4]
    db2a:	ble.n	db0c <_svfprintf_r+0xa7c>
    db2c:	add	r2, sp, #140	; 0x8c
    db2e:	mov	r1, r6
    db30:	mov	r0, r4
    db32:	bl	12034 <__ssprint_r>
    db36:	cmp	r0, #0
    db38:	bne.w	d284 <_svfprintf_r+0x1f4>
    db3c:	sub.w	r9, r9, #16
    db40:	cmp.w	r9, #16
    db44:	ldr	r1, [sp, #148]	; 0x94
    db46:	ldr	r3, [sp, #144]	; 0x90
    db48:	add	r2, sp, #192	; 0xc0
    db4a:	bgt.n	db1a <_svfprintf_r+0xa8a>
    db4c:	mov	r6, r7
    db4e:	mov	r4, r1
    db50:	mov	r7, r9
    db52:	mov	r9, r2
    db54:	adds	r3, #1
    db56:	ldr	r2, [sp, #44]	; 0x2c
    db58:	str	r3, [sp, #144]	; 0x90
    db5a:	add	r4, r7
    db5c:	cmp	r3, #7
    db5e:	str	r4, [sp, #148]	; 0x94
    db60:	stmia.w	r9, {r2, r7}
    db64:	bgt.w	dfe2 <_svfprintf_r+0xf52>
    db68:	add.w	r9, r9, #8
    db6c:	b.n	d524 <_svfprintf_r+0x494>
    db6e:	ldr	r3, [sp, #56]	; 0x38
    db70:	ldr	r5, [sp, #144]	; 0x90
    db72:	cmp	r3, #1
    db74:	ble.w	df8c <_svfprintf_r+0xefc>
    db78:	adds	r5, #1
    db7a:	adds	r4, #1
    db7c:	movs	r3, #1
    db7e:	cmp	r5, #7
    db80:	str	r4, [sp, #148]	; 0x94
    db82:	str	r5, [sp, #144]	; 0x90
    db84:	str.w	r6, [r9]
    db88:	str.w	r3, [r9, #4]
    db8c:	bgt.w	dfae <_svfprintf_r+0xf1e>
    db90:	add.w	r9, r9, #8
    db94:	ldr	r2, [sp, #72]	; 0x48
    db96:	ldr	r3, [sp, #76]	; 0x4c
    db98:	str.w	r3, [r9]
    db9c:	adds	r5, #1
    db9e:	add	r4, r2
    dba0:	cmp	r5, #7
    dba2:	str	r4, [sp, #148]	; 0x94
    dba4:	str	r5, [sp, #144]	; 0x90
    dba6:	str.w	r2, [r9, #4]
    dbaa:	bgt.w	dfc8 <_svfprintf_r+0xf38>
    dbae:	add.w	r9, r9, #8
    dbb2:	movs	r3, #0
    dbb4:	movs	r2, #0
    dbb6:	ldrd	r0, r1, [sp, #64]	; 0x40
    dbba:	bl	ac8c <__aeabi_dcmpeq>
    dbbe:	ldr	r3, [sp, #56]	; 0x38
    dbc0:	cmp	r0, #0
    dbc2:	bne.w	dd4c <_svfprintf_r+0xcbc>
    dbc6:	subs	r3, #1
    dbc8:	adds	r5, #1
    dbca:	adds	r6, #1
    dbcc:	add	r4, r3
    dbce:	cmp	r5, #7
    dbd0:	str	r5, [sp, #144]	; 0x90
    dbd2:	str	r4, [sp, #148]	; 0x94
    dbd4:	str.w	r6, [r9]
    dbd8:	str.w	r3, [r9, #4]
    dbdc:	bgt.w	ddca <_svfprintf_r+0xd3a>
    dbe0:	add.w	r9, r9, #8
    dbe4:	ldr	r2, [sp, #84]	; 0x54
    dbe6:	str.w	r2, [r9, #4]
    dbea:	adds	r5, #1
    dbec:	add	r4, r2
    dbee:	add	r3, sp, #124	; 0x7c
    dbf0:	cmp	r5, #7
    dbf2:	str	r4, [sp, #148]	; 0x94
    dbf4:	str	r5, [sp, #144]	; 0x90
    dbf6:	str.w	r3, [r9]
    dbfa:	ble.w	d5b8 <_svfprintf_r+0x528>
    dbfe:	add	r2, sp, #140	; 0x8c
    dc00:	ldr	r1, [sp, #20]
    dc02:	ldr	r0, [sp, #24]
    dc04:	bl	12034 <__ssprint_r>
    dc08:	cmp	r0, #0
    dc0a:	bne.w	d284 <_svfprintf_r+0x1f4>
    dc0e:	ldr	r4, [sp, #148]	; 0x94
    dc10:	add.w	r9, sp, #192	; 0xc0
    dc14:	b.n	d5bc <_svfprintf_r+0x52c>
    dc16:	add	r2, sp, #140	; 0x8c
    dc18:	ldr	r1, [sp, #20]
    dc1a:	ldr	r0, [sp, #24]
    dc1c:	bl	12034 <__ssprint_r>
    dc20:	cmp	r0, #0
    dc22:	beq.w	d658 <_svfprintf_r+0x5c8>
    dc26:	b.w	d284 <_svfprintf_r+0x1f4>
    dc2a:	add	r2, sp, #140	; 0x8c
    dc2c:	ldr	r1, [sp, #20]
    dc2e:	ldr	r0, [sp, #24]
    dc30:	bl	12034 <__ssprint_r>
    dc34:	cmp	r0, #0
    dc36:	bne.w	d284 <_svfprintf_r+0x1f4>
    dc3a:	ldr	r4, [sp, #148]	; 0x94
    dc3c:	add.w	r9, sp, #192	; 0xc0
    dc40:	b.n	d596 <_svfprintf_r+0x506>
    dc42:	add	r2, sp, #140	; 0x8c
    dc44:	ldr	r1, [sp, #20]
    dc46:	ldr	r0, [sp, #24]
    dc48:	bl	12034 <__ssprint_r>
    dc4c:	cmp	r0, #0
    dc4e:	bne.w	d284 <_svfprintf_r+0x1f4>
    dc52:	ldr	r4, [sp, #148]	; 0x94
    dc54:	add.w	r9, sp, #192	; 0xc0
    dc58:	b.n	d4fc <_svfprintf_r+0x46c>
    dc5a:	add	r2, sp, #140	; 0x8c
    dc5c:	ldr	r1, [sp, #20]
    dc5e:	ldr	r0, [sp, #24]
    dc60:	bl	12034 <__ssprint_r>
    dc64:	cmp	r0, #0
    dc66:	bne.w	d284 <_svfprintf_r+0x1f4>
    dc6a:	ldr	r4, [sp, #148]	; 0x94
    dc6c:	add.w	r9, sp, #192	; 0xc0
    dc70:	b.n	d51c <_svfprintf_r+0x48c>
    dc72:	cmp.w	fp, #0
    dc76:	strb.w	r7, [sp, #111]	; 0x6f
    dc7a:	blt.w	e23c <_svfprintf_r+0x11ac>
    dc7e:	bic.w	r3, r2, #128	; 0x80
    dc82:	str	r3, [sp, #12]
    dc84:	orrs.w	r3, r4, r5
    dc88:	bne.w	d832 <_svfprintf_r+0x7a2>
    dc8c:	cmp.w	fp, #0
    dc90:	beq.w	d9ac <_svfprintf_r+0x91c>
    dc94:	movs	r7, #0
    dc96:	b.n	da08 <_svfprintf_r+0x978>
    dc98:	ldr	r5, [sp, #116]	; 0x74
    dc9a:	cmp	r5, #0
    dc9c:	ble.w	e242 <_svfprintf_r+0x11b2>
    dca0:	ldr	r3, [sp, #60]	; 0x3c
    dca2:	ldr	r2, [sp, #56]	; 0x38
    dca4:	cmp	r3, r2
    dca6:	it	ge
    dca8:	movge	r3, r2
    dcaa:	cmp	r3, #0
    dcac:	mov	r5, r3
    dcae:	ble.n	dccc <_svfprintf_r+0xc3c>
    dcb0:	ldr	r3, [sp, #144]	; 0x90
    dcb2:	str.w	r6, [r9]
    dcb6:	adds	r3, #1
    dcb8:	add	r4, r5
    dcba:	cmp	r3, #7
    dcbc:	str	r4, [sp, #148]	; 0x94
    dcbe:	str.w	r5, [r9, #4]
    dcc2:	str	r3, [sp, #144]	; 0x90
    dcc4:	bgt.w	e41a <_svfprintf_r+0x138a>
    dcc8:	add.w	r9, r9, #8
    dccc:	ldr	r3, [sp, #60]	; 0x3c
    dcce:	cmp	r5, #0
    dcd0:	it	ge
    dcd2:	subge	r3, r3, r5
    dcd4:	cmp	r3, #0
    dcd6:	mov	r5, r3
    dcd8:	ble.w	decc <_svfprintf_r+0xe3c>
    dcdc:	ldr	r2, [pc, #260]	; (dde4 <_svfprintf_r+0xd54>)
    dcde:	ldr	r3, [sp, #144]	; 0x90
    dce0:	str	r2, [sp, #44]	; 0x2c
    dce2:	cmp	r5, #16
    dce4:	ble.w	e1ee <_svfprintf_r+0x115e>
    dce8:	mov	r2, r4
    dcea:	movs	r7, #16
    dcec:	ldr.w	fp, [sp, #24]
    dcf0:	ldr	r4, [sp, #20]
    dcf2:	b.n	dd00 <_svfprintf_r+0xc70>
    dcf4:	add.w	r9, r9, #8
    dcf8:	subs	r5, #16
    dcfa:	cmp	r5, #16
    dcfc:	ble.w	e1ec <_svfprintf_r+0x115c>
    dd00:	adds	r3, #1
    dd02:	adds	r2, #16
    dd04:	cmp	r3, #7
    dd06:	str	r2, [sp, #148]	; 0x94
    dd08:	str	r3, [sp, #144]	; 0x90
    dd0a:	str.w	sl, [r9]
    dd0e:	str.w	r7, [r9, #4]
    dd12:	ble.n	dcf4 <_svfprintf_r+0xc64>
    dd14:	add	r2, sp, #140	; 0x8c
    dd16:	mov	r1, r4
    dd18:	mov	r0, fp
    dd1a:	bl	12034 <__ssprint_r>
    dd1e:	cmp	r0, #0
    dd20:	bne.w	d284 <_svfprintf_r+0x1f4>
    dd24:	ldr	r2, [sp, #148]	; 0x94
    dd26:	ldr	r3, [sp, #144]	; 0x90
    dd28:	add.w	r9, sp, #192	; 0xc0
    dd2c:	b.n	dcf8 <_svfprintf_r+0xc68>
    dd2e:	add	r2, sp, #140	; 0x8c
    dd30:	ldr	r1, [sp, #20]
    dd32:	ldr	r0, [sp, #24]
    dd34:	bl	12034 <__ssprint_r>
    dd38:	cmp	r0, #0
    dd3a:	bne.w	d284 <_svfprintf_r+0x1f4>
    dd3e:	ldrb.w	r7, [sp, #111]	; 0x6f
    dd42:	ldr	r4, [sp, #148]	; 0x94
    dd44:	add.w	r9, sp, #192	; 0xc0
    dd48:	b.w	d4dc <_svfprintf_r+0x44c>
    dd4c:	subs	r6, r3, #1
    dd4e:	cmp	r6, #0
    dd50:	ble.w	dbe4 <_svfprintf_r+0xb54>
    dd54:	ldr	r3, [pc, #140]	; (dde4 <_svfprintf_r+0xd54>)
    dd56:	str	r3, [sp, #44]	; 0x2c
    dd58:	cmp	r6, #16
    dd5a:	ble.n	ddb6 <_svfprintf_r+0xd26>
    dd5c:	str.w	r8, [sp, #36]	; 0x24
    dd60:	movs	r7, #16
    dd62:	mov	r8, r6
    dd64:	ldr.w	fp, [sp, #24]
    dd68:	ldr	r6, [sp, #20]
    dd6a:	b.n	dd7a <_svfprintf_r+0xcea>
    dd6c:	sub.w	r8, r8, #16
    dd70:	cmp.w	r8, #16
    dd74:	add.w	r9, r9, #8
    dd78:	ble.n	ddb0 <_svfprintf_r+0xd20>
    dd7a:	adds	r5, #1
    dd7c:	adds	r4, #16
    dd7e:	cmp	r5, #7
    dd80:	str	r4, [sp, #148]	; 0x94
    dd82:	str	r5, [sp, #144]	; 0x90
    dd84:	str.w	sl, [r9]
    dd88:	str.w	r7, [r9, #4]
    dd8c:	ble.n	dd6c <_svfprintf_r+0xcdc>
    dd8e:	add	r2, sp, #140	; 0x8c
    dd90:	mov	r1, r6
    dd92:	mov	r0, fp
    dd94:	bl	12034 <__ssprint_r>
    dd98:	cmp	r0, #0
    dd9a:	bne.w	d284 <_svfprintf_r+0x1f4>
    dd9e:	sub.w	r8, r8, #16
    dda2:	cmp.w	r8, #16
    dda6:	ldr	r4, [sp, #148]	; 0x94
    dda8:	ldr	r5, [sp, #144]	; 0x90
    ddaa:	add.w	r9, sp, #192	; 0xc0
    ddae:	bgt.n	dd7a <_svfprintf_r+0xcea>
    ddb0:	mov	r6, r8
    ddb2:	ldr.w	r8, [sp, #36]	; 0x24
    ddb6:	ldr	r3, [sp, #44]	; 0x2c
    ddb8:	adds	r5, #1
    ddba:	add	r4, r6
    ddbc:	cmp	r5, #7
    ddbe:	str	r4, [sp, #148]	; 0x94
    ddc0:	str	r5, [sp, #144]	; 0x90
    ddc2:	stmia.w	r9, {r3, r6}
    ddc6:	ble.w	dbe0 <_svfprintf_r+0xb50>
    ddca:	add	r2, sp, #140	; 0x8c
    ddcc:	ldr	r1, [sp, #20]
    ddce:	ldr	r0, [sp, #24]
    ddd0:	bl	12034 <__ssprint_r>
    ddd4:	cmp	r0, #0
    ddd6:	bne.w	d284 <_svfprintf_r+0x1f4>
    ddda:	ldr	r4, [sp, #148]	; 0x94
    dddc:	ldr	r5, [sp, #144]	; 0x90
    ddde:	add.w	r9, sp, #192	; 0xc0
    dde2:	b.n	dbe4 <_svfprintf_r+0xb54>
    dde4:	.word	0x00013078
    dde8:	ldr	r1, [sp, #12]
    ddea:	ands.w	r2, r1, #16
    ddee:	beq.w	e198 <_svfprintf_r+0x1108>
    ddf2:	ldr	r0, [sp, #40]	; 0x28
    ddf4:	strb.w	r3, [sp, #111]	; 0x6f
    ddf8:	cmp.w	fp, #0
    ddfc:	ldr	r4, [r0, #0]
    ddfe:	add.w	r7, r0, #4
    de02:	mov.w	r5, #0
    de06:	blt.n	de56 <_svfprintf_r+0xdc6>
    de08:	mov	r2, r1
    de0a:	bic.w	r2, r2, #128	; 0x80
    de0e:	str	r2, [sp, #12]
    de10:	orrs.w	r2, r4, r5
    de14:	str	r7, [sp, #40]	; 0x28
    de16:	mov	r7, r3
    de18:	bne.w	d3ec <_svfprintf_r+0x35c>
    de1c:	b.n	d7bc <_svfprintf_r+0x72c>
    de1e:	ldr	r3, [sp, #12]
    de20:	lsls	r0, r3, #27
    de22:	bmi.n	de7a <_svfprintf_r+0xdea>
    de24:	ldr	r3, [sp, #12]
    de26:	lsls	r1, r3, #25
    de28:	bpl.n	de7a <_svfprintf_r+0xdea>
    de2a:	ldr	r1, [sp, #40]	; 0x28
    de2c:	ldrsh.w	r4, [r1]
    de30:	adds	r1, #4
    de32:	asrs	r5, r4, #31
    de34:	mov	r2, r4
    de36:	mov	r3, r5
    de38:	str	r1, [sp, #40]	; 0x28
    de3a:	b.w	d3c6 <_svfprintf_r+0x336>
    de3e:	ldr	r1, [sp, #40]	; 0x28
    de40:	strb.w	r3, [sp, #111]	; 0x6f
    de44:	cmp.w	fp, #0
    de48:	ldr	r4, [r1, #0]
    de4a:	add.w	r7, r1, #4
    de4e:	mov.w	r5, #0
    de52:	bge.w	e2ee <_svfprintf_r+0x125e>
    de56:	str	r7, [sp, #40]	; 0x28
    de58:	mov	r7, r3
    de5a:	orrs.w	r3, r4, r5
    de5e:	bne.w	d3ec <_svfprintf_r+0x35c>
    de62:	b.n	d7c6 <_svfprintf_r+0x736>
    de64:	adds	r3, #1
    de66:	ldr	r2, [sp, #44]	; 0x2c
    de68:	str	r3, [sp, #144]	; 0x90
    de6a:	add	r4, r5
    de6c:	cmp	r3, #7
    de6e:	str	r4, [sp, #148]	; 0x94
    de70:	stmia.w	r9, {r2, r5}
    de74:	ble.w	d5b8 <_svfprintf_r+0x528>
    de78:	b.n	dbfe <_svfprintf_r+0xb6e>
    de7a:	ldr	r2, [sp, #40]	; 0x28
    de7c:	ldr	r4, [r2, #0]
    de7e:	mov	r3, r2
    de80:	adds	r3, #4
    de82:	asrs	r5, r4, #31
    de84:	mov	r2, r4
    de86:	str	r3, [sp, #40]	; 0x28
    de88:	cmp	r2, #0
    de8a:	mov	r3, r5
    de8c:	sbcs.w	r3, r3, #0
    de90:	bge.w	d3d0 <_svfprintf_r+0x340>
    de94:	negs	r4, r4
    de96:	mov.w	r7, #45	; 0x2d
    de9a:	sbc.w	r5, r5, r5, lsl #1
    de9e:	cmp.w	fp, #0
    dea2:	strb.w	r7, [sp, #111]	; 0x6f
    dea6:	blt.w	d3ec <_svfprintf_r+0x35c>
    deaa:	ldr	r3, [sp, #12]
    deac:	bic.w	r3, r3, #128	; 0x80
    deb0:	str	r3, [sp, #12]
    deb2:	b.w	d3ec <_svfprintf_r+0x35c>
    deb6:	add	r2, sp, #140	; 0x8c
    deb8:	ldr	r1, [sp, #20]
    deba:	ldr	r0, [sp, #24]
    debc:	bl	12034 <__ssprint_r>
    dec0:	cmp	r0, #0
    dec2:	bne.w	d284 <_svfprintf_r+0x1f4>
    dec6:	ldr	r4, [sp, #148]	; 0x94
    dec8:	add.w	r9, sp, #192	; 0xc0
    decc:	ldr	r2, [sp, #60]	; 0x3c
    dece:	ldr	r3, [sp, #116]	; 0x74
    ded0:	add	r2, r6
    ded2:	mov	r7, r2
    ded4:	ldr	r2, [sp, #56]	; 0x38
    ded6:	cmp	r3, r2
    ded8:	blt.n	df6a <_svfprintf_r+0xeda>
    deda:	ldr	r2, [sp, #12]
    dedc:	lsls	r5, r2, #31
    dede:	bmi.n	df6a <_svfprintf_r+0xeda>
    dee0:	ldr	r1, [sp, #56]	; 0x38
    dee2:	add	r6, r1
    dee4:	subs	r5, r6, r7
    dee6:	subs	r3, r1, r3
    dee8:	cmp	r5, r3
    deea:	it	ge
    deec:	movge	r5, r3
    deee:	cmp	r5, #0
    def0:	mov	r6, r5
    def2:	ble.n	df10 <_svfprintf_r+0xe80>
    def4:	ldr	r2, [sp, #144]	; 0x90
    def6:	str.w	r7, [r9]
    defa:	adds	r2, #1
    defc:	add	r4, r5
    defe:	cmp	r2, #7
    df00:	str	r4, [sp, #148]	; 0x94
    df02:	str.w	r5, [r9, #4]
    df06:	str	r2, [sp, #144]	; 0x90
    df08:	bgt.w	e508 <_svfprintf_r+0x1478>
    df0c:	add.w	r9, r9, #8
    df10:	cmp	r6, #0
    df12:	ite	ge
    df14:	subge	r5, r3, r6
    df16:	movlt	r5, r3
    df18:	cmp	r5, #0
    df1a:	ble.w	d5bc <_svfprintf_r+0x52c>
    df1e:	ldr	r2, [pc, #744]	; (e208 <_svfprintf_r+0x1178>)
    df20:	ldr	r3, [sp, #144]	; 0x90
    df22:	str	r2, [sp, #44]	; 0x2c
    df24:	cmp	r5, #16
    df26:	ble.n	de64 <_svfprintf_r+0xdd4>
    df28:	movs	r6, #16
    df2a:	ldr	r7, [sp, #24]
    df2c:	ldr.w	fp, [sp, #20]
    df30:	b.n	df3c <_svfprintf_r+0xeac>
    df32:	add.w	r9, r9, #8
    df36:	subs	r5, #16
    df38:	cmp	r5, #16
    df3a:	ble.n	de64 <_svfprintf_r+0xdd4>
    df3c:	adds	r3, #1
    df3e:	adds	r4, #16
    df40:	cmp	r3, #7
    df42:	str	r4, [sp, #148]	; 0x94
    df44:	str	r3, [sp, #144]	; 0x90
    df46:	str.w	sl, [r9]
    df4a:	str.w	r6, [r9, #4]
    df4e:	ble.n	df32 <_svfprintf_r+0xea2>
    df50:	add	r2, sp, #140	; 0x8c
    df52:	mov	r1, fp
    df54:	mov	r0, r7
    df56:	bl	12034 <__ssprint_r>
    df5a:	cmp	r0, #0
    df5c:	bne.w	d284 <_svfprintf_r+0x1f4>
    df60:	ldr	r4, [sp, #148]	; 0x94
    df62:	ldr	r3, [sp, #144]	; 0x90
    df64:	add.w	r9, sp, #192	; 0xc0
    df68:	b.n	df36 <_svfprintf_r+0xea6>
    df6a:	ldr	r2, [sp, #144]	; 0x90
    df6c:	ldr	r0, [sp, #72]	; 0x48
    df6e:	ldr	r1, [sp, #76]	; 0x4c
    df70:	str.w	r1, [r9]
    df74:	adds	r2, #1
    df76:	add	r4, r0
    df78:	cmp	r2, #7
    df7a:	str	r4, [sp, #148]	; 0x94
    df7c:	str.w	r0, [r9, #4]
    df80:	str	r2, [sp, #144]	; 0x90
    df82:	bgt.w	e4ee <_svfprintf_r+0x145e>
    df86:	add.w	r9, r9, #8
    df8a:	b.n	dee0 <_svfprintf_r+0xe50>
    df8c:	ldr	r3, [sp, #12]
    df8e:	lsls	r0, r3, #31
    df90:	bmi.w	db78 <_svfprintf_r+0xae8>
    df94:	adds	r5, #1
    df96:	adds	r4, #1
    df98:	movs	r3, #1
    df9a:	cmp	r5, #7
    df9c:	str	r4, [sp, #148]	; 0x94
    df9e:	str	r5, [sp, #144]	; 0x90
    dfa0:	str.w	r6, [r9]
    dfa4:	str.w	r3, [r9, #4]
    dfa8:	ble.w	dbe0 <_svfprintf_r+0xb50>
    dfac:	b.n	ddca <_svfprintf_r+0xd3a>
    dfae:	add	r2, sp, #140	; 0x8c
    dfb0:	ldr	r1, [sp, #20]
    dfb2:	ldr	r0, [sp, #24]
    dfb4:	bl	12034 <__ssprint_r>
    dfb8:	cmp	r0, #0
    dfba:	bne.w	d284 <_svfprintf_r+0x1f4>
    dfbe:	ldr	r4, [sp, #148]	; 0x94
    dfc0:	ldr	r5, [sp, #144]	; 0x90
    dfc2:	add.w	r9, sp, #192	; 0xc0
    dfc6:	b.n	db94 <_svfprintf_r+0xb04>
    dfc8:	add	r2, sp, #140	; 0x8c
    dfca:	ldr	r1, [sp, #20]
    dfcc:	ldr	r0, [sp, #24]
    dfce:	bl	12034 <__ssprint_r>
    dfd2:	cmp	r0, #0
    dfd4:	bne.w	d284 <_svfprintf_r+0x1f4>
    dfd8:	ldr	r4, [sp, #148]	; 0x94
    dfda:	ldr	r5, [sp, #144]	; 0x90
    dfdc:	add.w	r9, sp, #192	; 0xc0
    dfe0:	b.n	dbb2 <_svfprintf_r+0xb22>
    dfe2:	add	r2, sp, #140	; 0x8c
    dfe4:	ldr	r1, [sp, #20]
    dfe6:	ldr	r0, [sp, #24]
    dfe8:	bl	12034 <__ssprint_r>
    dfec:	cmp	r0, #0
    dfee:	bne.w	d284 <_svfprintf_r+0x1f4>
    dff2:	ldr	r4, [sp, #148]	; 0x94
    dff4:	add.w	r9, sp, #192	; 0xc0
    dff8:	b.w	d524 <_svfprintf_r+0x494>
    dffc:	ldr	r1, [sp, #12]
    dffe:	ands.w	r3, r1, #64	; 0x40
    e002:	beq.w	e178 <_svfprintf_r+0x10e8>
    e006:	ldr	r0, [sp, #40]	; 0x28
    e008:	strb.w	r2, [sp, #111]	; 0x6f
    e00c:	mov	r3, r0
    e00e:	cmp.w	fp, #0
    e012:	add.w	r3, r3, #4
    e016:	ldrh	r4, [r0, #0]
    e018:	mov.w	r5, #0
    e01c:	blt.w	e3a0 <_svfprintf_r+0x1310>
    e020:	bic.w	r1, r1, #128	; 0x80
    e024:	str	r1, [sp, #12]
    e026:	orrs.w	r1, r4, r5
    e02a:	str	r3, [sp, #40]	; 0x28
    e02c:	beq.w	d9e4 <_svfprintf_r+0x954>
    e030:	mov	r7, r2
    e032:	b.w	d2dc <_svfprintf_r+0x24c>
    e036:	ldr	r3, [sp, #12]
    e038:	lsls	r7, r3, #27
    e03a:	bmi.n	e054 <_svfprintf_r+0xfc4>
    e03c:	ldr	r3, [sp, #12]
    e03e:	lsls	r6, r3, #25
    e040:	bpl.n	e054 <_svfprintf_r+0xfc4>
    e042:	ldr	r2, [sp, #40]	; 0x28
    e044:	ldr	r3, [r2, #0]
    e046:	adds	r2, #4
    e048:	str	r2, [sp, #40]	; 0x28
    e04a:	ldrh.w	r2, [sp, #28]
    e04e:	strh	r2, [r3, #0]
    e050:	b.w	d0de <_svfprintf_r+0x4e>
    e054:	ldr	r2, [sp, #40]	; 0x28
    e056:	ldr	r3, [r2, #0]
    e058:	adds	r2, #4
    e05a:	str	r2, [sp, #40]	; 0x28
    e05c:	ldr	r2, [sp, #28]
    e05e:	str	r2, [r3, #0]
    e060:	b.w	d0de <_svfprintf_r+0x4e>
    e064:	ldrd	r0, r1, [sp, #64]	; 0x40
    e068:	mov	r2, r0
    e06a:	mov	r3, r1
    e06c:	bl	acf0 <__aeabi_dcmpun>
    e070:	cmp	r0, #0
    e072:	bne.w	e670 <_svfprintf_r+0x15e0>
    e076:	ldr	r3, [sp, #52]	; 0x34
    e078:	cmp.w	fp, #4294967295
    e07c:	bic.w	r7, r3, #32
    e080:	beq.w	e552 <_svfprintf_r+0x14c2>
    e084:	cmp	r7, #71	; 0x47
    e086:	beq.w	e38e <_svfprintf_r+0x12fe>
    e08a:	ldr	r3, [sp, #68]	; 0x44
    e08c:	ldr	r2, [sp, #12]
    e08e:	cmp	r3, #0
    e090:	orr.w	r2, r2, #256	; 0x100
    e094:	str	r2, [sp, #44]	; 0x2c
    e096:	blt.w	e58a <_svfprintf_r+0x14fa>
    e09a:	vldr	d7, [sp, #64]	; 0x40
    e09e:	vstr	d7, [sp, #96]	; 0x60
    e0a2:	movs	r3, #0
    e0a4:	str	r3, [sp, #16]
    e0a6:	ldr	r3, [sp, #52]	; 0x34
    e0a8:	cmp	r3, #102	; 0x66
    e0aa:	beq.w	e558 <_svfprintf_r+0x14c8>
    e0ae:	cmp	r3, #70	; 0x46
    e0b0:	beq.w	e33e <_svfprintf_r+0x12ae>
    e0b4:	cmp	r7, #69	; 0x45
    e0b6:	ite	eq
    e0b8:	addeq.w	r5, fp, #1
    e0bc:	movne	r5, fp
    e0be:	add	r2, sp, #132	; 0x84
    e0c0:	add	r3, sp, #120	; 0x78
    e0c2:	str	r2, [sp, #4]
    e0c4:	str	r3, [sp, #0]
    e0c6:	mov	r2, r5
    e0c8:	add	r3, sp, #116	; 0x74
    e0ca:	movs	r1, #2
    e0cc:	vldr	d0, [sp, #96]	; 0x60
    e0d0:	ldr	r0, [sp, #24]
    e0d2:	bl	f898 <_dtoa_r>
    e0d6:	ldr	r3, [sp, #52]	; 0x34
    e0d8:	cmp	r3, #103	; 0x67
    e0da:	mov	r6, r0
    e0dc:	bne.w	e5b6 <_svfprintf_r+0x1526>
    e0e0:	ldr	r3, [sp, #12]
    e0e2:	lsls	r2, r3, #31
    e0e4:	bpl.w	e65a <_svfprintf_r+0x15ca>
    e0e8:	adds	r4, r6, r5
    e0ea:	movs	r2, #0
    e0ec:	movs	r3, #0
    e0ee:	ldrd	r0, r1, [sp, #96]	; 0x60
    e0f2:	bl	ac8c <__aeabi_dcmpeq>
    e0f6:	cmp	r0, #0
    e0f8:	bne.w	e416 <_svfprintf_r+0x1386>
    e0fc:	ldr	r3, [sp, #132]	; 0x84
    e0fe:	cmp	r4, r3
    e100:	bls.n	e110 <_svfprintf_r+0x1080>
    e102:	movs	r1, #48	; 0x30
    e104:	adds	r2, r3, #1
    e106:	str	r2, [sp, #132]	; 0x84
    e108:	strb	r1, [r3, #0]
    e10a:	ldr	r3, [sp, #132]	; 0x84
    e10c:	cmp	r4, r3
    e10e:	bhi.n	e104 <_svfprintf_r+0x1074>
    e110:	subs	r3, r3, r6
    e112:	cmp	r7, #71	; 0x47
    e114:	str	r3, [sp, #56]	; 0x38
    e116:	beq.w	e408 <_svfprintf_r+0x1378>
    e11a:	ldr	r3, [sp, #52]	; 0x34
    e11c:	cmp	r3, #101	; 0x65
    e11e:	ble.w	e5d4 <_svfprintf_r+0x1544>
    e122:	ldr	r3, [sp, #52]	; 0x34
    e124:	cmp	r3, #102	; 0x66
    e126:	ldr	r3, [sp, #116]	; 0x74
    e128:	str	r3, [sp, #60]	; 0x3c
    e12a:	beq.w	e5ee <_svfprintf_r+0x155e>
    e12e:	ldr	r2, [sp, #60]	; 0x3c
    e130:	ldr	r1, [sp, #56]	; 0x38
    e132:	cmp	r2, r1
    e134:	blt.w	e59c <_svfprintf_r+0x150c>
    e138:	ldr	r3, [sp, #12]
    e13a:	lsls	r1, r3, #31
    e13c:	bmi.w	e65e <_svfprintf_r+0x15ce>
    e140:	bic.w	r3, r2, r2, asr #31
    e144:	str	r2, [sp, #36]	; 0x24
    e146:	movs	r2, #103	; 0x67
    e148:	str	r2, [sp, #52]	; 0x34
    e14a:	ldr	r2, [sp, #16]
    e14c:	cmp	r2, #0
    e14e:	bne.w	e3b0 <_svfprintf_r+0x1320>
    e152:	str	r3, [sp, #16]
    e154:	ldr	r3, [sp, #44]	; 0x2c
    e156:	str	r3, [sp, #12]
    e158:	mov	fp, r2
    e15a:	ldrb.w	r7, [sp, #111]	; 0x6f
    e15e:	b.w	d434 <_svfprintf_r+0x3a4>
    e162:	bic.w	r7, r7, #7
    e166:	vldr	d7, [r7]
    e16a:	add.w	r3, r7, #8
    e16e:	vstr	d7, [sp, #64]	; 0x40
    e172:	str	r3, [sp, #40]	; 0x28
    e174:	b.w	d68c <_svfprintf_r+0x5fc>
    e178:	ldr	r1, [sp, #40]	; 0x28
    e17a:	strb.w	r3, [sp, #111]	; 0x6f
    e17e:	cmp.w	fp, #0
    e182:	ldr	r4, [r1, #0]
    e184:	add.w	r7, r1, #4
    e188:	mov.w	r5, #0
    e18c:	bge.w	e2e8 <_svfprintf_r+0x1258>
    e190:	str	r7, [sp, #40]	; 0x28
    e192:	movs	r7, #0
    e194:	b.w	d2dc <_svfprintf_r+0x24c>
    e198:	ldr	r1, [sp, #12]
    e19a:	ands.w	r3, r1, #64	; 0x40
    e19e:	beq.w	de3e <_svfprintf_r+0xdae>
    e1a2:	ldr	r0, [sp, #40]	; 0x28
    e1a4:	strb.w	r2, [sp, #111]	; 0x6f
    e1a8:	mov	r3, r0
    e1aa:	cmp.w	fp, #0
    e1ae:	add.w	r3, r3, #4
    e1b2:	ldrh	r4, [r0, #0]
    e1b4:	mov.w	r5, #0
    e1b8:	blt.w	e39a <_svfprintf_r+0x130a>
    e1bc:	bic.w	r1, r1, #128	; 0x80
    e1c0:	str	r1, [sp, #12]
    e1c2:	orrs.w	r1, r4, r5
    e1c6:	str	r3, [sp, #40]	; 0x28
    e1c8:	mov	r7, r2
    e1ca:	bne.w	d3ec <_svfprintf_r+0x35c>
    e1ce:	b.w	d7bc <_svfprintf_r+0x72c>
    e1d2:	ldr	r3, [sp, #12]
    e1d4:	ldr	r2, [sp, #40]	; 0x28
    e1d6:	tst.w	r3, #64	; 0x40
    e1da:	mov	r3, r2
    e1dc:	beq.w	e3a4 <_svfprintf_r+0x1314>
    e1e0:	adds	r3, #4
    e1e2:	ldrh	r4, [r2, #0]
    e1e4:	str	r3, [sp, #40]	; 0x28
    e1e6:	movs	r5, #0
    e1e8:	b.w	d7f6 <_svfprintf_r+0x766>
    e1ec:	mov	r4, r2
    e1ee:	adds	r3, #1
    e1f0:	ldr	r2, [sp, #44]	; 0x2c
    e1f2:	str	r3, [sp, #144]	; 0x90
    e1f4:	add	r4, r5
    e1f6:	cmp	r3, #7
    e1f8:	str	r4, [sp, #148]	; 0x94
    e1fa:	stmia.w	r9, {r2, r5}
    e1fe:	bgt.w	deb6 <_svfprintf_r+0xe26>
    e202:	add.w	r9, r9, #8
    e206:	b.n	decc <_svfprintf_r+0xe3c>
    e208:	.word	0x00013078
    e20c:	movs	r7, #0
    e20e:	cmp	fp, r7
    e210:	strb.w	r7, [sp, #111]	; 0x6f
    e214:	blt.w	da08 <_svfprintf_r+0x978>
    e218:	ldr	r3, [sp, #12]
    e21a:	bic.w	r3, r3, #128	; 0x80
    e21e:	str	r3, [sp, #12]
    e220:	b.w	d9a4 <_svfprintf_r+0x914>
    e224:	add	r2, sp, #140	; 0x8c
    e226:	ldr	r1, [sp, #20]
    e228:	ldr	r0, [sp, #24]
    e22a:	bl	12034 <__ssprint_r>
    e22e:	cmp	r0, #0
    e230:	bne.w	d284 <_svfprintf_r+0x1f4>
    e234:	ldr	r4, [sp, #148]	; 0x94
    e236:	add.w	r9, sp, #192	; 0xc0
    e23a:	b.n	da4c <_svfprintf_r+0x9bc>
    e23c:	ldr	r7, [sp, #40]	; 0x28
    e23e:	b.w	d9fa <_svfprintf_r+0x96a>
    e242:	ldr	r3, [sp, #144]	; 0x90
    e244:	ldr	r2, [pc, #736]	; (e528 <_svfprintf_r+0x1498>)
    e246:	str.w	r2, [r9]
    e24a:	adds	r3, #1
    e24c:	adds	r4, #1
    e24e:	movs	r2, #1
    e250:	cmp	r3, #7
    e252:	str	r4, [sp, #148]	; 0x94
    e254:	str	r3, [sp, #144]	; 0x90
    e256:	str.w	r2, [r9, #4]
    e25a:	bgt.w	e374 <_svfprintf_r+0x12e4>
    e25e:	add.w	r9, r9, #8
    e262:	cbnz	r5, e270 <_svfprintf_r+0x11e0>
    e264:	ldr	r3, [sp, #56]	; 0x38
    e266:	cbnz	r3, e270 <_svfprintf_r+0x11e0>
    e268:	ldr	r3, [sp, #12]
    e26a:	lsls	r7, r3, #31
    e26c:	bpl.w	d5bc <_svfprintf_r+0x52c>
    e270:	ldr	r3, [sp, #144]	; 0x90
    e272:	ldr	r1, [sp, #72]	; 0x48
    e274:	ldr	r2, [sp, #76]	; 0x4c
    e276:	str.w	r2, [r9]
    e27a:	adds	r3, #1
    e27c:	add	r4, r1
    e27e:	cmp	r3, #7
    e280:	str	r4, [sp, #148]	; 0x94
    e282:	str.w	r1, [r9, #4]
    e286:	str	r3, [sp, #144]	; 0x90
    e288:	bgt.w	e626 <_svfprintf_r+0x1596>
    e28c:	add.w	r9, r9, #8
    e290:	negs	r5, r5
    e292:	cmp	r5, #0
    e294:	ble.w	e3ec <_svfprintf_r+0x135c>
    e298:	ldr	r2, [pc, #656]	; (e52c <_svfprintf_r+0x149c>)
    e29a:	str	r2, [sp, #44]	; 0x2c
    e29c:	cmp	r5, #16
    e29e:	ble.w	e434 <_svfprintf_r+0x13a4>
    e2a2:	mov	r2, r4
    e2a4:	movs	r7, #16
    e2a6:	ldr.w	fp, [sp, #24]
    e2aa:	ldr	r4, [sp, #20]
    e2ac:	b.n	e2ba <_svfprintf_r+0x122a>
    e2ae:	add.w	r9, r9, #8
    e2b2:	subs	r5, #16
    e2b4:	cmp	r5, #16
    e2b6:	ble.w	e432 <_svfprintf_r+0x13a2>
    e2ba:	adds	r3, #1
    e2bc:	adds	r2, #16
    e2be:	cmp	r3, #7
    e2c0:	str	r2, [sp, #148]	; 0x94
    e2c2:	str	r3, [sp, #144]	; 0x90
    e2c4:	str.w	sl, [r9]
    e2c8:	str.w	r7, [r9, #4]
    e2cc:	ble.n	e2ae <_svfprintf_r+0x121e>
    e2ce:	add	r2, sp, #140	; 0x8c
    e2d0:	mov	r1, r4
    e2d2:	mov	r0, fp
    e2d4:	bl	12034 <__ssprint_r>
    e2d8:	cmp	r0, #0
    e2da:	bne.w	d284 <_svfprintf_r+0x1f4>
    e2de:	ldr	r2, [sp, #148]	; 0x94
    e2e0:	ldr	r3, [sp, #144]	; 0x90
    e2e2:	add.w	r9, sp, #192	; 0xc0
    e2e6:	b.n	e2b2 <_svfprintf_r+0x1222>
    e2e8:	ldr	r2, [sp, #12]
    e2ea:	b.w	d760 <_svfprintf_r+0x6d0>
    e2ee:	ldr	r2, [sp, #12]
    e2f0:	b.n	de0a <_svfprintf_r+0xd7a>
    e2f2:	ldr	r3, [sp, #12]
    e2f4:	orr.w	r3, r3, #32
    e2f8:	str	r3, [sp, #12]
    e2fa:	add.w	r8, r8, #1
    e2fe:	ldrb.w	r3, [r8]
    e302:	b.w	d144 <_svfprintf_r+0xb4>
    e306:	add	r2, sp, #140	; 0x8c
    e308:	ldr	r1, [sp, #20]
    e30a:	ldr	r0, [sp, #24]
    e30c:	bl	12034 <__ssprint_r>
    e310:	cmp	r0, #0
    e312:	bne.w	d284 <_svfprintf_r+0x1f4>
    e316:	ldr	r4, [sp, #148]	; 0x94
    e318:	add.w	r9, sp, #192	; 0xc0
    e31c:	b.w	da7c <_svfprintf_r+0x9ec>
    e320:	movs	r1, #64	; 0x40
    e322:	ldr	r0, [sp, #24]
    e324:	bl	b23c <_malloc_r>
    e328:	ldr	r2, [sp, #20]
    e32a:	str	r0, [r2, #0]
    e32c:	str	r0, [r2, #16]
    e32e:	cmp	r0, #0
    e330:	beq.w	e71a <_svfprintf_r+0x168a>
    e334:	ldr	r2, [sp, #20]
    e336:	movs	r3, #64	; 0x40
    e338:	str	r3, [r2, #20]
    e33a:	b.w	d0be <_svfprintf_r+0x2e>
    e33e:	add	r2, sp, #132	; 0x84
    e340:	add	r3, sp, #120	; 0x78
    e342:	str	r2, [sp, #4]
    e344:	str	r3, [sp, #0]
    e346:	mov	r2, fp
    e348:	add	r3, sp, #116	; 0x74
    e34a:	movs	r1, #3
    e34c:	vldr	d0, [sp, #96]	; 0x60
    e350:	ldr	r0, [sp, #24]
    e352:	bl	f898 <_dtoa_r>
    e356:	mov	r5, fp
    e358:	mov	r6, r0
    e35a:	ldr	r3, [sp, #52]	; 0x34
    e35c:	cmp	r3, #70	; 0x46
    e35e:	add.w	r4, r6, r5
    e362:	bne.w	e0ea <_svfprintf_r+0x105a>
    e366:	ldrb	r3, [r6, #0]
    e368:	cmp	r3, #48	; 0x30
    e36a:	beq.w	e67c <_svfprintf_r+0x15ec>
    e36e:	ldr	r5, [sp, #116]	; 0x74
    e370:	add	r4, r5
    e372:	b.n	e0ea <_svfprintf_r+0x105a>
    e374:	add	r2, sp, #140	; 0x8c
    e376:	ldr	r1, [sp, #20]
    e378:	ldr	r0, [sp, #24]
    e37a:	bl	12034 <__ssprint_r>
    e37e:	cmp	r0, #0
    e380:	bne.w	d284 <_svfprintf_r+0x1f4>
    e384:	ldr	r5, [sp, #116]	; 0x74
    e386:	ldr	r4, [sp, #148]	; 0x94
    e388:	add.w	r9, sp, #192	; 0xc0
    e38c:	b.n	e262 <_svfprintf_r+0x11d2>
    e38e:	cmp.w	fp, #0
    e392:	it	eq
    e394:	moveq.w	fp, #1
    e398:	b.n	e08a <_svfprintf_r+0xffa>
    e39a:	str	r3, [sp, #40]	; 0x28
    e39c:	mov	r7, r2
    e39e:	b.n	de5a <_svfprintf_r+0xdca>
    e3a0:	str	r3, [sp, #40]	; 0x28
    e3a2:	b.n	e192 <_svfprintf_r+0x1102>
    e3a4:	adds	r3, #4
    e3a6:	ldr	r4, [r2, #0]
    e3a8:	str	r3, [sp, #40]	; 0x28
    e3aa:	movs	r5, #0
    e3ac:	b.w	d7f6 <_svfprintf_r+0x766>
    e3b0:	movs	r7, #45	; 0x2d
    e3b2:	str	r3, [sp, #16]
    e3b4:	ldr	r3, [sp, #44]	; 0x2c
    e3b6:	str	r3, [sp, #12]
    e3b8:	strb.w	r7, [sp, #111]	; 0x6f
    e3bc:	mov.w	fp, #0
    e3c0:	b.w	d436 <_svfprintf_r+0x3a6>
    e3c4:	mov	r0, r6
    e3c6:	bl	be80 <strlen>
    e3ca:	mov	fp, r4
    e3cc:	mov	r3, r0
    e3ce:	str	r0, [sp, #36]	; 0x24
    e3d0:	b.w	d918 <_svfprintf_r+0x888>
    e3d4:	add	r2, sp, #140	; 0x8c
    e3d6:	ldr	r1, [sp, #20]
    e3d8:	ldr	r0, [sp, #24]
    e3da:	bl	12034 <__ssprint_r>
    e3de:	cmp	r0, #0
    e3e0:	bne.w	d284 <_svfprintf_r+0x1f4>
    e3e4:	ldr	r4, [sp, #148]	; 0x94
    e3e6:	ldr	r3, [sp, #144]	; 0x90
    e3e8:	add.w	r9, sp, #192	; 0xc0
    e3ec:	ldr	r1, [sp, #56]	; 0x38
    e3ee:	str.w	r6, [r9]
    e3f2:	adds	r3, #1
    e3f4:	add	r4, r1
    e3f6:	cmp	r3, #7
    e3f8:	str	r4, [sp, #148]	; 0x94
    e3fa:	str	r3, [sp, #144]	; 0x90
    e3fc:	str.w	r1, [r9, #4]
    e400:	ble.w	d5b8 <_svfprintf_r+0x528>
    e404:	b.w	dbfe <_svfprintf_r+0xb6e>
    e408:	ldr	r3, [sp, #116]	; 0x74
    e40a:	adds	r5, r3, #3
    e40c:	blt.n	e44c <_svfprintf_r+0x13bc>
    e40e:	cmp	fp, r3
    e410:	blt.n	e44c <_svfprintf_r+0x13bc>
    e412:	str	r3, [sp, #60]	; 0x3c
    e414:	b.n	e12e <_svfprintf_r+0x109e>
    e416:	mov	r3, r4
    e418:	b.n	e110 <_svfprintf_r+0x1080>
    e41a:	add	r2, sp, #140	; 0x8c
    e41c:	ldr	r1, [sp, #20]
    e41e:	ldr	r0, [sp, #24]
    e420:	bl	12034 <__ssprint_r>
    e424:	cmp	r0, #0
    e426:	bne.w	d284 <_svfprintf_r+0x1f4>
    e42a:	ldr	r4, [sp, #148]	; 0x94
    e42c:	add.w	r9, sp, #192	; 0xc0
    e430:	b.n	dccc <_svfprintf_r+0xc3c>
    e432:	mov	r4, r2
    e434:	adds	r3, #1
    e436:	ldr	r2, [sp, #44]	; 0x2c
    e438:	str	r3, [sp, #144]	; 0x90
    e43a:	add	r4, r5
    e43c:	cmp	r3, #7
    e43e:	str	r4, [sp, #148]	; 0x94
    e440:	stmia.w	r9, {r2, r5}
    e444:	bgt.n	e3d4 <_svfprintf_r+0x1344>
    e446:	add.w	r9, r9, #8
    e44a:	b.n	e3ec <_svfprintf_r+0x135c>
    e44c:	ldr	r2, [sp, #52]	; 0x34
    e44e:	subs	r2, #2
    e450:	str	r2, [sp, #52]	; 0x34
    e452:	subs	r3, #1
    e454:	cmp	r3, #0
    e456:	ldrb.w	r2, [sp, #52]	; 0x34
    e45a:	str	r3, [sp, #116]	; 0x74
    e45c:	it	lt
    e45e:	neglt	r3, r3
    e460:	strb.w	r2, [sp, #124]	; 0x7c
    e464:	ite	lt
    e466:	movlt	r2, #45	; 0x2d
    e468:	movge	r2, #43	; 0x2b
    e46a:	cmp	r3, #9
    e46c:	strb.w	r2, [sp, #125]	; 0x7d
    e470:	ble.w	e64a <_svfprintf_r+0x15ba>
    e474:	add.w	r0, sp, #139	; 0x8b
    e478:	mov	r4, r0
    e47a:	ldr	r2, [pc, #180]	; (e530 <_svfprintf_r+0x14a0>)
    e47c:	smull	r2, r1, r2, r3
    e480:	asrs	r2, r3, #31
    e482:	rsb	r2, r2, r1, asr #2
    e486:	add.w	r1, r2, r2, lsl #2
    e48a:	sub.w	r3, r3, r1, lsl #1
    e48e:	add.w	r1, r3, #48	; 0x30
    e492:	cmp	r2, #9
    e494:	mov	r3, r2
    e496:	strb.w	r1, [r4, #-1]!
    e49a:	bgt.n	e47a <_svfprintf_r+0x13ea>
    e49c:	mov	r1, r4
    e49e:	adds	r3, #48	; 0x30
    e4a0:	uxtb	r2, r3
    e4a2:	strb.w	r2, [r1, #-1]!
    e4a6:	cmp	r0, r1
    e4a8:	bls.w	e714 <_svfprintf_r+0x1684>
    e4ac:	add.w	r1, sp, #126	; 0x7e
    e4b0:	mov	r3, r4
    e4b2:	b.n	e4b8 <_svfprintf_r+0x1428>
    e4b4:	ldrb.w	r2, [r3], #1
    e4b8:	strb.w	r2, [r1], #1
    e4bc:	cmp	r0, r3
    e4be:	bne.n	e4b4 <_svfprintf_r+0x1424>
    e4c0:	adds	r3, r0, #1
    e4c2:	subs	r3, r3, r4
    e4c4:	add.w	r2, sp, #126	; 0x7e
    e4c8:	add	r3, r2
    e4ca:	add	r2, sp, #124	; 0x7c
    e4cc:	subs	r3, r3, r2
    e4ce:	ldr	r2, [sp, #56]	; 0x38
    e4d0:	str	r3, [sp, #84]	; 0x54
    e4d2:	cmp	r2, #1
    e4d4:	add	r3, r2
    e4d6:	str	r3, [sp, #36]	; 0x24
    e4d8:	ble.w	e6aa <_svfprintf_r+0x161a>
    e4dc:	ldr	r3, [sp, #36]	; 0x24
    e4de:	ldr	r2, [sp, #72]	; 0x48
    e4e0:	add	r3, r2
    e4e2:	movs	r2, #0
    e4e4:	str	r3, [sp, #36]	; 0x24
    e4e6:	str	r2, [sp, #60]	; 0x3c
    e4e8:	bic.w	r3, r3, r3, asr #31
    e4ec:	b.n	e14a <_svfprintf_r+0x10ba>
    e4ee:	add	r2, sp, #140	; 0x8c
    e4f0:	ldr	r1, [sp, #20]
    e4f2:	ldr	r0, [sp, #24]
    e4f4:	bl	12034 <__ssprint_r>
    e4f8:	cmp	r0, #0
    e4fa:	bne.w	d284 <_svfprintf_r+0x1f4>
    e4fe:	ldr	r3, [sp, #116]	; 0x74
    e500:	ldr	r4, [sp, #148]	; 0x94
    e502:	add.w	r9, sp, #192	; 0xc0
    e506:	b.n	dee0 <_svfprintf_r+0xe50>
    e508:	add	r2, sp, #140	; 0x8c
    e50a:	ldr	r1, [sp, #20]
    e50c:	ldr	r0, [sp, #24]
    e50e:	bl	12034 <__ssprint_r>
    e512:	cmp	r0, #0
    e514:	bne.w	d284 <_svfprintf_r+0x1f4>
    e518:	ldr	r3, [sp, #116]	; 0x74
    e51a:	ldr	r2, [sp, #56]	; 0x38
    e51c:	ldr	r4, [sp, #148]	; 0x94
    e51e:	subs	r3, r2, r3
    e520:	add.w	r9, sp, #192	; 0xc0
    e524:	b.n	df10 <_svfprintf_r+0xe80>
    e526:	nop
    e528:	.word	0x000130c8
    e52c:	.word	0x00013078
    e530:	.word	0x66666667
    e534:	cmp	r5, #6
    e536:	mov	r3, r5
    e538:	it	cs
    e53a:	movcs	r3, #6
    e53c:	str	r3, [sp, #36]	; 0x24
    e53e:	bic.w	r3, r3, r3, asr #31
    e542:	mov	fp, r6
    e544:	str	r7, [sp, #40]	; 0x28
    e546:	str	r6, [sp, #60]	; 0x3c
    e548:	mov	r7, r6
    e54a:	str	r3, [sp, #16]
    e54c:	ldr	r6, [pc, #536]	; (e768 <_svfprintf_r+0x16d8>)
    e54e:	b.w	d434 <_svfprintf_r+0x3a4>
    e552:	mov.w	fp, #6
    e556:	b.n	e08a <_svfprintf_r+0xffa>
    e558:	add	r2, sp, #132	; 0x84
    e55a:	add	r3, sp, #120	; 0x78
    e55c:	str	r2, [sp, #4]
    e55e:	str	r3, [sp, #0]
    e560:	mov	r2, fp
    e562:	add	r3, sp, #116	; 0x74
    e564:	movs	r1, #3
    e566:	vldr	d0, [sp, #96]	; 0x60
    e56a:	ldr	r0, [sp, #24]
    e56c:	bl	f898 <_dtoa_r>
    e570:	mov	r5, fp
    e572:	mov	r6, r0
    e574:	add.w	r4, r0, fp
    e578:	b.n	e366 <_svfprintf_r+0x12d6>
    e57a:	movs	r7, #45	; 0x2d
    e57c:	strb.w	r7, [sp, #111]	; 0x6f
    e580:	b.w	d6da <_svfprintf_r+0x64a>
    e584:	str	r3, [sp, #12]
    e586:	b.w	d832 <_svfprintf_r+0x7a2>
    e58a:	ldrd	r1, r2, [sp, #64]	; 0x40
    e58e:	add.w	r3, r2, #2147483648	; 0x80000000
    e592:	str	r3, [sp, #100]	; 0x64
    e594:	movs	r3, #45	; 0x2d
    e596:	str	r1, [sp, #96]	; 0x60
    e598:	str	r3, [sp, #16]
    e59a:	b.n	e0a6 <_svfprintf_r+0x1016>
    e59c:	ldr	r2, [sp, #72]	; 0x48
    e59e:	ldr	r3, [sp, #56]	; 0x38
    e5a0:	add	r3, r2
    e5a2:	ldr	r2, [sp, #60]	; 0x3c
    e5a4:	str	r3, [sp, #36]	; 0x24
    e5a6:	cmp	r2, #0
    e5a8:	ble.w	e6be <_svfprintf_r+0x162e>
    e5ac:	movs	r2, #103	; 0x67
    e5ae:	bic.w	r3, r3, r3, asr #31
    e5b2:	str	r2, [sp, #52]	; 0x34
    e5b4:	b.n	e14a <_svfprintf_r+0x10ba>
    e5b6:	ldr	r3, [sp, #52]	; 0x34
    e5b8:	cmp	r3, #71	; 0x47
    e5ba:	bne.w	e0e8 <_svfprintf_r+0x1058>
    e5be:	ldr	r3, [sp, #12]
    e5c0:	lsls	r3, r3, #31
    e5c2:	bmi.w	e35a <_svfprintf_r+0x12ca>
    e5c6:	ldr	r3, [sp, #132]	; 0x84
    e5c8:	cmp	r7, #71	; 0x47
    e5ca:	sub.w	r3, r3, r6
    e5ce:	str	r3, [sp, #56]	; 0x38
    e5d0:	beq.w	e408 <_svfprintf_r+0x1378>
    e5d4:	ldr	r3, [sp, #116]	; 0x74
    e5d6:	b.n	e452 <_svfprintf_r+0x13c2>
    e5d8:	bic.w	r3, r5, r5, asr #31
    e5dc:	str	r7, [sp, #40]	; 0x28
    e5de:	str	r3, [sp, #16]
    e5e0:	str	r5, [sp, #36]	; 0x24
    e5e2:	mov	fp, r0
    e5e4:	str	r0, [sp, #60]	; 0x3c
    e5e6:	ldrb.w	r7, [sp, #111]	; 0x6f
    e5ea:	b.w	d434 <_svfprintf_r+0x3a4>
    e5ee:	cmp	r3, #0
    e5f0:	ble.n	e6ce <_svfprintf_r+0x163e>
    e5f2:	cmp.w	fp, #0
    e5f6:	bne.n	e698 <_svfprintf_r+0x1608>
    e5f8:	ldr	r2, [sp, #12]
    e5fa:	lsls	r4, r2, #31
    e5fc:	bmi.n	e698 <_svfprintf_r+0x1608>
    e5fe:	mov	r2, r3
    e600:	str	r2, [sp, #36]	; 0x24
    e602:	bic.w	r3, r3, r3, asr #31
    e606:	b.n	e14a <_svfprintf_r+0x10ba>
    e608:	ldr	r3, [sp, #12]
    e60a:	lsls	r3, r3, #31
    e60c:	mov	r7, fp
    e60e:	bpl.n	e61c <_svfprintf_r+0x158c>
    e610:	add	r6, sp, #256	; 0x100
    e612:	movs	r3, #48	; 0x30
    e614:	strb.w	r3, [r6, #-65]!
    e618:	b.w	d420 <_svfprintf_r+0x390>
    e61c:	str.w	fp, [sp, #36]	; 0x24
    e620:	add	r6, sp, #192	; 0xc0
    e622:	b.w	d426 <_svfprintf_r+0x396>
    e626:	add	r2, sp, #140	; 0x8c
    e628:	ldr	r1, [sp, #20]
    e62a:	ldr	r0, [sp, #24]
    e62c:	bl	12034 <__ssprint_r>
    e630:	cmp	r0, #0
    e632:	bne.w	d284 <_svfprintf_r+0x1f4>
    e636:	ldr	r5, [sp, #116]	; 0x74
    e638:	ldr	r4, [sp, #148]	; 0x94
    e63a:	ldr	r3, [sp, #144]	; 0x90
    e63c:	add.w	r9, sp, #192	; 0xc0
    e640:	b.n	e290 <_svfprintf_r+0x1200>
    e642:	mov	r8, r4
    e644:	movs	r5, #0
    e646:	b.w	d148 <_svfprintf_r+0xb8>
    e64a:	adds	r3, #48	; 0x30
    e64c:	movs	r2, #48	; 0x30
    e64e:	strb.w	r3, [sp, #127]	; 0x7f
    e652:	strb.w	r2, [sp, #126]	; 0x7e
    e656:	add	r3, sp, #128	; 0x80
    e658:	b.n	e4ca <_svfprintf_r+0x143a>
    e65a:	ldr	r3, [sp, #132]	; 0x84
    e65c:	b.n	e110 <_svfprintf_r+0x1080>
    e65e:	ldr	r2, [sp, #72]	; 0x48
    e660:	ldr	r3, [sp, #60]	; 0x3c
    e662:	add	r3, r2
    e664:	movs	r2, #103	; 0x67
    e666:	str	r3, [sp, #36]	; 0x24
    e668:	str	r2, [sp, #52]	; 0x34
    e66a:	bic.w	r3, r3, r3, asr #31
    e66e:	b.n	e14a <_svfprintf_r+0x10ba>
    e670:	ldr	r6, [pc, #248]	; (e76c <_svfprintf_r+0x16dc>)
    e672:	ldr	r3, [pc, #252]	; (e770 <_svfprintf_r+0x16e0>)
    e674:	ldrb.w	r7, [sp, #111]	; 0x6f
    e678:	b.w	d6de <_svfprintf_r+0x64e>
    e67c:	movs	r2, #0
    e67e:	movs	r3, #0
    e680:	ldrd	r0, r1, [sp, #96]	; 0x60
    e684:	bl	ac8c <__aeabi_dcmpeq>
    e688:	cmp	r0, #0
    e68a:	bne.w	e36e <_svfprintf_r+0x12de>
    e68e:	rsb	r5, r5, #1
    e692:	str	r5, [sp, #116]	; 0x74
    e694:	add	r4, r5
    e696:	b.n	e0ea <_svfprintf_r+0x105a>
    e698:	ldr	r3, [sp, #60]	; 0x3c
    e69a:	ldr	r2, [sp, #72]	; 0x48
    e69c:	adds	r5, r3, r2
    e69e:	add.w	r3, r5, fp
    e6a2:	str	r3, [sp, #36]	; 0x24
    e6a4:	bic.w	r3, r3, r3, asr #31
    e6a8:	b.n	e14a <_svfprintf_r+0x10ba>
    e6aa:	ldr	r3, [sp, #12]
    e6ac:	ands.w	r3, r3, #1
    e6b0:	bne.w	e4dc <_svfprintf_r+0x144c>
    e6b4:	str	r3, [sp, #60]	; 0x3c
    e6b6:	ldr	r3, [sp, #36]	; 0x24
    e6b8:	bic.w	r3, r3, r3, asr #31
    e6bc:	b.n	e14a <_svfprintf_r+0x10ba>
    e6be:	ldr	r3, [sp, #60]	; 0x3c
    e6c0:	ldr	r2, [sp, #36]	; 0x24
    e6c2:	rsb	r3, r3, #1
    e6c6:	add	r2, r3
    e6c8:	mov	r3, r2
    e6ca:	str	r2, [sp, #36]	; 0x24
    e6cc:	b.n	e5ac <_svfprintf_r+0x151c>
    e6ce:	cmp.w	fp, #0
    e6d2:	bne.n	e6da <_svfprintf_r+0x164a>
    e6d4:	ldr	r3, [sp, #12]
    e6d6:	lsls	r0, r3, #31
    e6d8:	bpl.n	e6ea <_svfprintf_r+0x165a>
    e6da:	ldr	r3, [sp, #72]	; 0x48
    e6dc:	adds	r5, r3, #1
    e6de:	add.w	r3, r5, fp
    e6e2:	str	r3, [sp, #36]	; 0x24
    e6e4:	bic.w	r3, r3, r3, asr #31
    e6e8:	b.n	e14a <_svfprintf_r+0x10ba>
    e6ea:	movs	r3, #1
    e6ec:	str	r3, [sp, #36]	; 0x24
    e6ee:	b.n	e14a <_svfprintf_r+0x10ba>
    e6f0:	ldr	r0, [sp, #40]	; 0x28
    e6f2:	ldrb.w	r3, [r8, #1]
    e6f6:	ldr	r5, [r0, #0]
    e6f8:	adds	r0, #4
    e6fa:	cmp	r5, #0
    e6fc:	str	r0, [sp, #40]	; 0x28
    e6fe:	mov	r8, r4
    e700:	bge.w	d144 <_svfprintf_r+0xb4>
    e704:	mov.w	r5, #4294967295
    e708:	b.w	d144 <_svfprintf_r+0xb4>
    e70c:	strb.w	r1, [sp, #111]	; 0x6f
    e710:	b.w	d2a6 <_svfprintf_r+0x216>
    e714:	add.w	r3, sp, #126	; 0x7e
    e718:	b.n	e4ca <_svfprintf_r+0x143a>
    e71a:	ldr	r2, [sp, #24]
    e71c:	movs	r3, #12
    e71e:	str	r3, [r2, #0]
    e720:	mov.w	r0, #4294967295
    e724:	b.w	d296 <_svfprintf_r+0x206>
    e728:	strb.w	r1, [sp, #111]	; 0x6f
    e72c:	b.w	d3a0 <_svfprintf_r+0x310>
    e730:	strb.w	r1, [sp, #111]	; 0x6f
    e734:	b.w	d66c <_svfprintf_r+0x5dc>
    e738:	strb.w	r1, [sp, #111]	; 0x6f
    e73c:	b.w	d7da <_svfprintf_r+0x74a>
    e740:	strb.w	r1, [sp, #111]	; 0x6f
    e744:	b.w	d77e <_svfprintf_r+0x6ee>
    e748:	strb.w	r1, [sp, #111]	; 0x6f
    e74c:	b.w	d72a <_svfprintf_r+0x69a>
    e750:	strb.w	r1, [sp, #111]	; 0x6f
    e754:	b.w	d9c2 <_svfprintf_r+0x932>
    e758:	strb.w	r1, [sp, #111]	; 0x6f
    e75c:	b.w	d980 <_svfprintf_r+0x8f0>
    e760:	strb.w	r1, [sp, #111]	; 0x6f
    e764:	b.w	d944 <_svfprintf_r+0x8b4>
    e768:	.word	0x000130c0
    e76c:	.word	0x00013094
    e770:	.word	0x00013090

0000e774 <__ssvfscanf_r>:
    e774:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e778:	mov	fp, r1
    e77a:	ldrsh.w	r1, [r1, #12]
    e77e:	sub.w	sp, sp, #692	; 0x2b4
    e782:	mov	sl, r0
    e784:	lsls	r0, r1, #18
    e786:	mov	r4, r2
    e788:	str	r3, [sp, #20]
    e78a:	bmi.n	e7a0 <__ssvfscanf_r+0x2c>
    e78c:	ldr.w	r3, [fp, #100]	; 0x64
    e790:	orr.w	r1, r1, #8192	; 0x2000
    e794:	bic.w	r3, r3, #8192	; 0x2000
    e798:	strh.w	r1, [fp, #12]
    e79c:	str.w	r3, [fp, #100]	; 0x64
    e7a0:	mov	r6, r4
    e7a2:	movs	r3, #0
    e7a4:	str	r3, [sp, #28]
    e7a6:	str	r3, [sp, #16]
    e7a8:	mov	r7, r3
    e7aa:	str	r3, [sp, #24]
    e7ac:	ldrb.w	r3, [r6], #1
    e7b0:	str	r3, [sp, #68]	; 0x44
    e7b2:	cbz	r3, e810 <__ssvfscanf_r+0x9c>
    e7b4:	bl	b208 <__locale_ctype_ptr>
    e7b8:	ldr	r2, [sp, #68]	; 0x44
    e7ba:	add	r0, r2
    e7bc:	ldrb	r3, [r0, #1]
    e7be:	and.w	r3, r3, #8
    e7c2:	and.w	r5, r3, #255	; 0xff
    e7c6:	cbz	r3, e81a <__ssvfscanf_r+0xa6>
    e7c8:	ldr.w	r3, [fp, #4]
    e7cc:	b.n	e7f2 <__ssvfscanf_r+0x7e>
    e7ce:	bl	b208 <__locale_ctype_ptr>
    e7d2:	ldr.w	r3, [fp]
    e7d6:	ldrb	r2, [r3, #0]
    e7d8:	add	r0, r2
    e7da:	adds	r3, #1
    e7dc:	ldrb	r2, [r0, #1]
    e7de:	lsls	r1, r2, #28
    e7e0:	bpl.n	e802 <__ssvfscanf_r+0x8e>
    e7e2:	ldr.w	r2, [fp, #4]
    e7e6:	str.w	r3, [fp]
    e7ea:	subs	r3, r2, #1
    e7ec:	adds	r7, #1
    e7ee:	str.w	r3, [fp, #4]
    e7f2:	cmp	r3, #0
    e7f4:	bgt.n	e7ce <__ssvfscanf_r+0x5a>
    e7f6:	mov	r1, fp
    e7f8:	mov	r0, sl
    e7fa:	bl	121b8 <__ssrefill_r>
    e7fe:	cmp	r0, #0
    e800:	beq.n	e7ce <__ssvfscanf_r+0x5a>
    e802:	mov	r4, r6
    e804:	mov	r6, r4
    e806:	ldrb.w	r3, [r6], #1
    e80a:	str	r3, [sp, #68]	; 0x44
    e80c:	cmp	r3, #0
    e80e:	bne.n	e7b4 <__ssvfscanf_r+0x40>
    e810:	ldr	r0, [sp, #24]
    e812:	add.w	sp, sp, #692	; 0x2b4
    e816:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e81a:	cmp	r2, #37	; 0x25
    e81c:	bne.w	e928 <__ssvfscanf_r+0x1b4>
    e820:	ldrb.w	r8, [r4, #1]
    e824:	mov	r4, r5
    e826:	adds	r3, r6, #1
    e828:	cmp.w	r8, #120	; 0x78
    e82c:	bhi.w	ecb6 <__ssvfscanf_r+0x542>
    e830:	tbh	[pc, r8, lsl #1]
    e834:	.word	0x02410092
    e838:	.word	0x02410241
    e83c:	.word	0x02410241
    e840:	.word	0x02410241
    e844:	.word	0x02410241
    e848:	.word	0x02410241
    e84c:	.word	0x02410241
    e850:	.word	0x02410241
    e854:	.word	0x02410241
    e858:	.word	0x02410241
    e85c:	.word	0x02410241
    e860:	.word	0x02410241
    e864:	.word	0x02410241
    e868:	.word	0x02410241
    e86c:	.word	0x02410241
    e870:	.word	0x02410241
    e874:	.word	0x02410241
    e878:	.word	0x02410241
    e87c:	.word	0x00790241
    e880:	.word	0x02410241
    e884:	.word	0x02410241
    e888:	.word	0x024101d8
    e88c:	.word	0x02410241
    e890:	.word	0x02410241
    e894:	.word	0x01cf01cf
    e898:	.word	0x01cf01cf
    e89c:	.word	0x01cf01cf
    e8a0:	.word	0x01cf01cf
    e8a4:	.word	0x01cf01cf
    e8a8:	.word	0x02410241
    e8ac:	.word	0x02410241
    e8b0:	.word	0x02410241
    e8b4:	.word	0x02410241
    e8b8:	.word	0x02410241
    e8bc:	.word	0x01b901c1
    e8c0:	.word	0x01b90241
    e8c4:	.word	0x02410241
    e8c8:	.word	0x02410241
    e8cc:	.word	0x024101b3
    e8d0:	.word	0x01a30241
    e8d4:	.word	0x02410241
    e8d8:	.word	0x02410241
    e8dc:	.word	0x02410241
    e8e0:	.word	0x02410241
    e8e4:	.word	0x02410193
    e8e8:	.word	0x01510241
    e8ec:	.word	0x02410241
    e8f0:	.word	0x02410241
    e8f4:	.word	0x02410241
    e8f8:	.word	0x01220241
    e8fc:	.word	0x01b90188
    e900:	.word	0x01b901b9
    e904:	.word	0x0098011c
    e908:	.word	0x02410241
    e90c:	.word	0x024100d5
    e910:	.word	0x0101010d
    e914:	.word	0x024100f3
    e918:	.word	0x00eb0241
    e91c:	.word	0x00df0241
    e920:	.word	0x02410241
    e924:	.short	0x0193
    e926:	mov	r6, r3
    e928:	ldr.w	r3, [fp, #4]
    e92c:	cmp	r3, #0
    e92e:	ble.w	edd8 <__ssvfscanf_r+0x664>
    e932:	ldr.w	r3, [fp]
    e936:	ldrb.w	r2, [r6, #-1]
    e93a:	ldrb	r1, [r3, #0]
    e93c:	cmp	r1, r2
    e93e:	bne.w	e810 <__ssvfscanf_r+0x9c>
    e942:	ldr.w	r2, [fp, #4]
    e946:	adds	r3, #1
    e948:	subs	r2, #1
    e94a:	str.w	r3, [fp]
    e94e:	adds	r7, #1
    e950:	str.w	r2, [fp, #4]
    e954:	mov	r4, r6
    e956:	b.n	e804 <__ssvfscanf_r+0x90>
    e958:	mov.w	r0, #4294967295
    e95c:	add.w	sp, sp, #692	; 0x2b4
    e960:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e964:	str	r3, [sp, #12]
    e966:	ldr.w	r3, [fp, #4]
    e96a:	cmp	r3, #0
    e96c:	ble.w	ee36 <__ssvfscanf_r+0x6c2>
    e970:	ldr	r3, [pc, #736]	; (ec54 <__ssvfscanf_r+0x4e0>)
    e972:	str	r3, [sp, #28]
    e974:	movs	r3, #0
    e976:	str	r3, [sp, #16]
    e978:	movs	r6, #3
    e97a:	b.n	e980 <__ssvfscanf_r+0x20c>
    e97c:	str.w	lr, [fp]
    e980:	bl	b208 <__locale_ctype_ptr>
    e984:	ldr.w	r2, [fp]
    e988:	ldrb	r1, [r2, #0]
    e98a:	add	r0, r1
    e98c:	add.w	lr, r2, #1
    e990:	ldrb	r3, [r0, #1]
    e992:	and.w	r3, r3, #8
    e996:	and.w	r8, r3, #255	; 0xff
    e99a:	cmp	r3, #0
    e99c:	beq.w	ee9e <__ssvfscanf_r+0x72a>
    e9a0:	ldr.w	r3, [fp, #4]
    e9a4:	subs	r3, #1
    e9a6:	cmp	r3, #0
    e9a8:	add.w	r7, r7, #1
    e9ac:	str.w	r3, [fp, #4]
    e9b0:	bgt.n	e97c <__ssvfscanf_r+0x208>
    e9b2:	mov	r1, fp
    e9b4:	mov	r0, sl
    e9b6:	bl	121b8 <__ssrefill_r>
    e9ba:	cmp	r0, #0
    e9bc:	beq.n	e980 <__ssvfscanf_r+0x20c>
    e9be:	ldr	r2, [sp, #24]
    e9c0:	cmp	r2, #0
    e9c2:	beq.n	e958 <__ssvfscanf_r+0x1e4>
    e9c4:	ldrh.w	r3, [fp, #12]
    e9c8:	tst.w	r3, #64	; 0x40
    e9cc:	mov	r3, r2
    e9ce:	it	ne
    e9d0:	movne.w	r3, #4294967295
    e9d4:	mov	r0, r3
    e9d6:	add.w	sp, sp, #692	; 0x2b4
    e9da:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e9de:	ldrb.w	r8, [r6, #1]
    e9e2:	cmp.w	r8, #108	; 0x6c
    e9e6:	beq.w	edee <__ssvfscanf_r+0x67a>
    e9ea:	orr.w	r5, r5, #1
    e9ee:	mov	r6, r3
    e9f0:	b.n	e826 <__ssvfscanf_r+0xb2>
    e9f2:	str	r3, [sp, #12]
    e9f4:	ldr.w	r3, [fp, #4]
    e9f8:	cmp	r3, #0
    e9fa:	ble.w	ee8e <__ssvfscanf_r+0x71a>
    e9fe:	ldr	r3, [pc, #600]	; (ec58 <__ssvfscanf_r+0x4e4>)
    ea00:	str	r3, [sp, #28]
    ea02:	movs	r3, #10
    ea04:	str	r3, [sp, #16]
    ea06:	movs	r6, #3
    ea08:	b.n	e980 <__ssvfscanf_r+0x20c>
    ea0a:	str	r3, [sp, #12]
    ea0c:	ldr.w	r3, [fp, #4]
    ea10:	cmp	r3, #0
    ea12:	ble.w	ee7e <__ssvfscanf_r+0x70a>
    ea16:	movs	r6, #2
    ea18:	b.n	e980 <__ssvfscanf_r+0x20c>
    ea1a:	str	r3, [sp, #12]
    ea1c:	ldr.w	r3, [fp, #4]
    ea20:	cmp	r3, #0
    ea22:	orr.w	r5, r5, #544	; 0x220
    ea26:	ble.w	eb6a <__ssvfscanf_r+0x3f6>
    ea2a:	ldr	r3, [pc, #556]	; (ec58 <__ssvfscanf_r+0x4e4>)
    ea2c:	str	r3, [sp, #28]
    ea2e:	movs	r3, #16
    ea30:	str	r3, [sp, #16]
    ea32:	movs	r6, #3
    ea34:	b.n	e980 <__ssvfscanf_r+0x20c>
    ea36:	str	r3, [sp, #12]
    ea38:	ldr.w	r3, [fp, #4]
    ea3c:	cmp	r3, #0
    ea3e:	ble.w	eb8a <__ssvfscanf_r+0x416>
    ea42:	ldr	r3, [pc, #532]	; (ec58 <__ssvfscanf_r+0x4e4>)
    ea44:	str	r3, [sp, #28]
    ea46:	movs	r3, #8
    ea48:	str	r3, [sp, #16]
    ea4a:	movs	r6, #3
    ea4c:	b.n	e980 <__ssvfscanf_r+0x20c>
    ea4e:	lsls	r2, r5, #27
    ea50:	mov	r6, r3
    ea52:	str	r3, [sp, #12]
    ea54:	bmi.w	ec3c <__ssvfscanf_r+0x4c8>
    ea58:	lsls	r3, r5, #29
    ea5a:	bpl.w	ee06 <__ssvfscanf_r+0x692>
    ea5e:	ldr	r1, [sp, #20]
    ea60:	ldr	r3, [r1, #0]
    ea62:	strh	r7, [r3, #0]
    ea64:	adds	r3, r1, #4
    ea66:	str	r3, [sp, #20]
    ea68:	mov	r4, r6
    ea6a:	b.n	e804 <__ssvfscanf_r+0x90>
    ea6c:	ldrb.w	r8, [r6, #1]
    ea70:	orr.w	r5, r5, #4
    ea74:	mov	r6, r3
    ea76:	b.n	e826 <__ssvfscanf_r+0xb2>
    ea78:	str	r3, [sp, #12]
    ea7a:	ldr.w	r3, [fp, #4]
    ea7e:	cmp	r3, #0
    ea80:	ble.w	ee5e <__ssvfscanf_r+0x6ea>
    ea84:	cmp	r4, #0
    ea86:	it	eq
    ea88:	moveq	r4, #1
    ea8a:	ands.w	r3, r5, #1
    ea8e:	bne.w	ecd6 <__ssvfscanf_r+0x562>
    ea92:	lsls	r2, r5, #27
    ea94:	bpl.w	edae <__ssvfscanf_r+0x63a>
    ea98:	mov	r5, r3
    ea9a:	b.n	eab0 <__ssvfscanf_r+0x33c>
    ea9c:	add	r3, r2
    ea9e:	str.w	r3, [fp]
    eaa2:	add	r5, r2
    eaa4:	subs	r4, r4, r2
    eaa6:	bl	121b8 <__ssrefill_r>
    eaaa:	cmp	r0, #0
    eaac:	bne.w	eda6 <__ssvfscanf_r+0x632>
    eab0:	ldr.w	r2, [fp, #4]
    eab4:	ldr.w	r3, [fp]
    eab8:	cmp	r2, r4
    eaba:	mov	r1, fp
    eabc:	mov	r0, sl
    eabe:	blt.n	ea9c <__ssvfscanf_r+0x328>
    eac0:	subs	r2, r2, r4
    eac2:	add	r3, r4
    eac4:	str.w	r2, [fp, #4]
    eac8:	add	r5, r4
    eaca:	str.w	r3, [fp]
    eace:	ldr	r6, [sp, #12]
    ead0:	add	r7, r5
    ead2:	mov	r4, r6
    ead4:	b.n	e804 <__ssvfscanf_r+0x90>
    ead6:	add.w	r9, sp, #80	; 0x50
    eada:	mov	r1, r3
    eadc:	mov	r0, r9
    eade:	bl	11a48 <__sccl>
    eae2:	ldr.w	r3, [fp, #4]
    eae6:	cmp	r3, #0
    eae8:	mov	r6, r0
    eaea:	ble.w	ee4e <__ssvfscanf_r+0x6da>
    eaee:	cmp	r4, #0
    eaf0:	ldr.w	r2, [fp]
    eaf4:	it	eq
    eaf6:	moveq.w	r4, #4294967295
    eafa:	lsls	r3, r5, #27
    eafc:	ldrb	r1, [r2, #0]
    eafe:	bpl.w	ec42 <__ssvfscanf_r+0x4ce>
    eb02:	mov	r8, r4
    eb04:	movs	r5, #0
    eb06:	b.n	eb0a <__ssvfscanf_r+0x396>
    eb08:	ldrb	r1, [r2, #0]
    eb0a:	ldrb.w	r3, [r9, r1]
    eb0e:	adds	r2, #1
    eb10:	cmp	r3, #0
    eb12:	beq.w	ed9c <__ssvfscanf_r+0x628>
    eb16:	ldr.w	r3, [fp, #4]
    eb1a:	str.w	r2, [fp]
    eb1e:	adds	r5, #1
    eb20:	subs	r3, #1
    eb22:	cmp	r5, r4
    eb24:	str.w	r3, [fp, #4]
    eb28:	beq.w	ed96 <__ssvfscanf_r+0x622>
    eb2c:	cmp	r3, #0
    eb2e:	bgt.n	eb08 <__ssvfscanf_r+0x394>
    eb30:	mov	r1, fp
    eb32:	mov	r0, sl
    eb34:	bl	121b8 <__ssrefill_r>
    eb38:	cmp	r0, #0
    eb3a:	bne.w	ed94 <__ssvfscanf_r+0x620>
    eb3e:	ldr.w	r2, [fp]
    eb42:	b.n	eb08 <__ssvfscanf_r+0x394>
    eb44:	str	r3, [sp, #12]
    eb46:	ldr.w	r3, [fp, #4]
    eb4a:	cmp	r3, #0
    eb4c:	ble.n	ebc4 <__ssvfscanf_r+0x450>
    eb4e:	ldr	r3, [pc, #260]	; (ec54 <__ssvfscanf_r+0x4e0>)
    eb50:	str	r3, [sp, #28]
    eb52:	movs	r3, #10
    eb54:	str	r3, [sp, #16]
    eb56:	movs	r6, #3
    eb58:	b.n	e980 <__ssvfscanf_r+0x20c>
    eb5a:	str	r3, [sp, #12]
    eb5c:	ldr.w	r3, [fp, #4]
    eb60:	cmp	r3, #0
    eb62:	orr.w	r5, r5, #512	; 0x200
    eb66:	bgt.w	ea2a <__ssvfscanf_r+0x2b6>
    eb6a:	mov	r1, fp
    eb6c:	mov	r0, sl
    eb6e:	bl	121b8 <__ssrefill_r>
    eb72:	cmp	r0, #0
    eb74:	beq.w	ea2a <__ssvfscanf_r+0x2b6>
    eb78:	b.n	e9be <__ssvfscanf_r+0x24a>
    eb7a:	str	r3, [sp, #12]
    eb7c:	ldr.w	r3, [fp, #4]
    eb80:	cmp	r3, #0
    eb82:	orr.w	r5, r5, #1
    eb86:	bgt.w	ea42 <__ssvfscanf_r+0x2ce>
    eb8a:	mov	r1, fp
    eb8c:	mov	r0, sl
    eb8e:	bl	121b8 <__ssrefill_r>
    eb92:	cmp	r0, #0
    eb94:	beq.w	ea42 <__ssvfscanf_r+0x2ce>
    eb98:	b.n	e9be <__ssvfscanf_r+0x24a>
    eb9a:	ldrb.w	r8, [r6, #1]
    eb9e:	orr.w	r5, r5, #2
    eba2:	mov	r6, r3
    eba4:	b.n	e826 <__ssvfscanf_r+0xb2>
    eba6:	str	r3, [sp, #12]
    eba8:	ldr.w	r3, [fp, #4]
    ebac:	cmp	r3, #0
    ebae:	ble.w	ee6e <__ssvfscanf_r+0x6fa>
    ebb2:	movs	r6, #4
    ebb4:	b.n	e980 <__ssvfscanf_r+0x20c>
    ebb6:	str	r3, [sp, #12]
    ebb8:	ldr.w	r3, [fp, #4]
    ebbc:	cmp	r3, #0
    ebbe:	orr.w	r5, r5, #1
    ebc2:	bgt.n	eb4e <__ssvfscanf_r+0x3da>
    ebc4:	mov	r1, fp
    ebc6:	mov	r0, sl
    ebc8:	bl	121b8 <__ssrefill_r>
    ebcc:	cmp	r0, #0
    ebce:	beq.n	eb4e <__ssvfscanf_r+0x3da>
    ebd0:	b.n	e9be <__ssvfscanf_r+0x24a>
    ebd2:	add.w	r4, r4, r4, lsl #2
    ebd6:	add.w	r4, r8, r4, lsl #1
    ebda:	subs	r4, #48	; 0x30
    ebdc:	ldrb.w	r8, [r6, #1]
    ebe0:	mov	r6, r3
    ebe2:	b.n	e826 <__ssvfscanf_r+0xb2>
    ebe4:	ldrb.w	r8, [r6, #1]
    ebe8:	orr.w	r5, r5, #16
    ebec:	mov	r6, r3
    ebee:	b.n	e826 <__ssvfscanf_r+0xb2>
    ebf0:	add	r3, sp, #72	; 0x48
    ebf2:	mov	r1, r8
    ebf4:	mov	r0, r3
    ebf6:	movs	r2, #8
    ebf8:	str	r3, [sp, #32]
    ebfa:	bl	8fc0 <memset>
    ebfe:	ands.w	r9, r5, #16
    ec02:	bne.w	f4c8 <__ssvfscanf_r+0xd54>
    ec06:	ldr	r2, [sp, #20]
    ec08:	mov	r3, r2
    ec0a:	adds	r3, #4
    ec0c:	ldr.w	r8, [r2]
    ec10:	str	r3, [sp, #20]
    ec12:	movs	r6, #0
    ec14:	bl	b208 <__locale_ctype_ptr>
    ec18:	ldr.w	r3, [fp]
    ec1c:	ldrb	r3, [r3, #0]
    ec1e:	add	r0, r3
    ec20:	ldrb	r3, [r0, #1]
    ec22:	lsls	r0, r3, #28
    ec24:	bmi.n	ec2c <__ssvfscanf_r+0x4b8>
    ec26:	cmp	r4, #0
    ec28:	bne.w	f42c <__ssvfscanf_r+0xcb8>
    ec2c:	cmp.w	r9, #0
    ec30:	bne.n	ec3c <__ssvfscanf_r+0x4c8>
    ec32:	str.w	r9, [r8]
    ec36:	ldr	r3, [sp, #24]
    ec38:	adds	r3, #1
    ec3a:	str	r3, [sp, #24]
    ec3c:	ldr	r6, [sp, #12]
    ec3e:	mov	r4, r6
    ec40:	b.n	e804 <__ssvfscanf_r+0x90>
    ec42:	ldr	r0, [sp, #20]
    ec44:	ldr	r5, [r0, #0]
    ec46:	mov	r3, r0
    ec48:	adds	r3, #4
    ec4a:	add.w	r8, r5, r4
    ec4e:	str	r3, [sp, #12]
    ec50:	mov	r4, r5
    ec52:	b.n	ec62 <__ssvfscanf_r+0x4ee>
    ec54:	.word	0x0000d069
    ec58:	.word	0x00011e01
    ec5c:	ldr.w	r2, [fp]
    ec60:	ldrb	r1, [r2, #0]
    ec62:	ldrb.w	r3, [r9, r1]
    ec66:	adds	r0, r2, #1
    ec68:	cbz	r3, ec9c <__ssvfscanf_r+0x528>
    ec6a:	ldr.w	r3, [fp, #4]
    ec6e:	str.w	r0, [fp]
    ec72:	subs	r3, #1
    ec74:	str.w	r3, [fp, #4]
    ec78:	ldrb	r3, [r2, #0]
    ec7a:	strb.w	r3, [r4], #1
    ec7e:	cmp	r8, r4
    ec80:	beq.n	ec9c <__ssvfscanf_r+0x528>
    ec82:	ldr.w	r3, [fp, #4]
    ec86:	cmp	r3, #0
    ec88:	bgt.n	ec5c <__ssvfscanf_r+0x4e8>
    ec8a:	mov	r1, fp
    ec8c:	mov	r0, sl
    ec8e:	bl	121b8 <__ssrefill_r>
    ec92:	cmp	r0, #0
    ec94:	beq.n	ec5c <__ssvfscanf_r+0x4e8>
    ec96:	cmp	r5, r4
    ec98:	beq.w	e9be <__ssvfscanf_r+0x24a>
    ec9c:	subs	r5, r4, r5
    ec9e:	beq.w	e810 <__ssvfscanf_r+0x9c>
    eca2:	ldr	r2, [sp, #24]
    eca4:	adds	r2, #1
    eca6:	movs	r3, #0
    eca8:	str	r2, [sp, #24]
    ecaa:	ldr	r2, [sp, #12]
    ecac:	str	r2, [sp, #20]
    ecae:	strb	r3, [r4, #0]
    ecb0:	add	r7, r5
    ecb2:	mov	r4, r6
    ecb4:	b.n	e804 <__ssvfscanf_r+0x90>
    ecb6:	str	r3, [sp, #12]
    ecb8:	bl	b208 <__locale_ctype_ptr>
    ecbc:	add	r0, r8
    ecbe:	ldrb	r3, [r0, #1]
    ecc0:	and.w	r3, r3, #3
    ecc4:	cmp	r3, #1
    ecc6:	ldr.w	r3, [fp, #4]
    ecca:	beq.w	edfa <__ssvfscanf_r+0x686>
    ecce:	cmp	r3, #0
    ecd0:	bgt.w	eb4e <__ssvfscanf_r+0x3da>
    ecd4:	b.n	ebc4 <__ssvfscanf_r+0x450>
    ecd6:	add	r3, sp, #72	; 0x48
    ecd8:	mov	r0, r3
    ecda:	movs	r2, #8
    ecdc:	movs	r1, #0
    ecde:	str	r3, [sp, #32]
    ece0:	bl	8fc0 <memset>
    ece4:	ands.w	r3, r5, #16
    ece8:	str	r3, [sp, #40]	; 0x28
    ecea:	bne.n	ede8 <__ssvfscanf_r+0x674>
    ecec:	ldr	r2, [sp, #20]
    ecee:	mov	r3, r2
    ecf0:	adds	r3, #4
    ecf2:	ldr.w	r9, [r2]
    ecf6:	str	r3, [sp, #20]
    ecf8:	movs	r5, #0
    ecfa:	add.w	r8, sp, #336	; 0x150
    ecfe:	bl	b1e4 <__locale_mb_cur_max>
    ed02:	cmp	r0, r5
    ed04:	beq.w	e9be <__ssvfscanf_r+0x24a>
    ed08:	ldmia.w	fp, {r2, r3}
    ed0c:	ldrb.w	r0, [r2], #1
    ed10:	str.w	r2, [fp]
    ed14:	subs	r3, #1
    ed16:	ldr	r2, [sp, #32]
    ed18:	str	r2, [sp, #0]
    ed1a:	adds	r6, r5, #1
    ed1c:	str.w	r3, [fp, #4]
    ed20:	mov	r1, r9
    ed22:	strb.w	r0, [r8, r5]
    ed26:	mov	r3, r6
    ed28:	mov	r2, r8
    ed2a:	mov	r0, sl
    ed2c:	bl	11104 <_mbrtowc_r>
    ed30:	adds	r1, r0, #1
    ed32:	beq.w	e9be <__ssvfscanf_r+0x24a>
    ed36:	cbnz	r0, ed62 <__ssvfscanf_r+0x5ee>
    ed38:	ldr	r3, [sp, #40]	; 0x28
    ed3a:	cbnz	r3, ed82 <__ssvfscanf_r+0x60e>
    ed3c:	str.w	r3, [r9]
    ed40:	add	r7, r6
    ed42:	subs	r4, #1
    ed44:	add.w	r9, r9, #4
    ed48:	ldr.w	r3, [fp, #4]
    ed4c:	cmp	r3, #0
    ed4e:	mov.w	r5, #0
    ed52:	ble.n	ed70 <__ssvfscanf_r+0x5fc>
    ed54:	cmp	r4, #0
    ed56:	bne.n	ecfe <__ssvfscanf_r+0x58a>
    ed58:	ldr	r3, [sp, #40]	; 0x28
    ed5a:	cmp	r3, #0
    ed5c:	beq.w	ec36 <__ssvfscanf_r+0x4c2>
    ed60:	b.n	ec3c <__ssvfscanf_r+0x4c8>
    ed62:	adds	r0, #2
    ed64:	bne.n	ed88 <__ssvfscanf_r+0x614>
    ed66:	ldr.w	r3, [fp, #4]
    ed6a:	cmp	r3, #0
    ed6c:	mov	r5, r6
    ed6e:	bgt.n	ecfe <__ssvfscanf_r+0x58a>
    ed70:	mov	r1, fp
    ed72:	mov	r0, sl
    ed74:	bl	121b8 <__ssrefill_r>
    ed78:	cmp	r0, #0
    ed7a:	beq.n	ed54 <__ssvfscanf_r+0x5e0>
    ed7c:	cmp	r5, #0
    ed7e:	beq.n	ed58 <__ssvfscanf_r+0x5e4>
    ed80:	b.n	e9be <__ssvfscanf_r+0x24a>
    ed82:	add	r7, r6
    ed84:	subs	r4, #1
    ed86:	b.n	ed48 <__ssvfscanf_r+0x5d4>
    ed88:	ldr	r3, [sp, #40]	; 0x28
    ed8a:	add	r7, r6
    ed8c:	subs	r4, #1
    ed8e:	cmp	r3, #0
    ed90:	bne.n	ed48 <__ssvfscanf_r+0x5d4>
    ed92:	b.n	ed44 <__ssvfscanf_r+0x5d0>
    ed94:	mov	r8, r5
    ed96:	mov	r5, r8
    ed98:	add	r7, r5
    ed9a:	b.n	ecb2 <__ssvfscanf_r+0x53e>
    ed9c:	cmp	r5, #0
    ed9e:	beq.w	e810 <__ssvfscanf_r+0x9c>
    eda2:	add	r7, r5
    eda4:	b.n	ecb2 <__ssvfscanf_r+0x53e>
    eda6:	cmp	r5, #0
    eda8:	bne.w	eace <__ssvfscanf_r+0x35a>
    edac:	b.n	e9be <__ssvfscanf_r+0x24a>
    edae:	ldr	r5, [sp, #20]
    edb0:	mov	r3, r4
    edb2:	ldr	r1, [r5, #0]
    edb4:	str.w	fp, [sp]
    edb8:	movs	r2, #1
    edba:	mov	r0, sl
    edbc:	bl	121f4 <_sfread_r>
    edc0:	adds	r6, r5, #4
    edc2:	cmp	r0, #0
    edc4:	beq.w	e9be <__ssvfscanf_r+0x24a>
    edc8:	ldr	r3, [sp, #24]
    edca:	str	r6, [sp, #20]
    edcc:	ldr	r6, [sp, #12]
    edce:	adds	r3, #1
    edd0:	add	r7, r0
    edd2:	str	r3, [sp, #24]
    edd4:	mov	r4, r6
    edd6:	b.n	e804 <__ssvfscanf_r+0x90>
    edd8:	mov	r1, fp
    edda:	mov	r0, sl
    eddc:	bl	121b8 <__ssrefill_r>
    ede0:	cmp	r0, #0
    ede2:	beq.w	e932 <__ssvfscanf_r+0x1be>
    ede6:	b.n	e9be <__ssvfscanf_r+0x24a>
    ede8:	mov.w	r9, #0
    edec:	b.n	ecf8 <__ssvfscanf_r+0x584>
    edee:	ldrb.w	r8, [r6, #2]
    edf2:	orr.w	r5, r5, #2
    edf6:	adds	r6, #2
    edf8:	b.n	e826 <__ssvfscanf_r+0xb2>
    edfa:	cmp	r3, #0
    edfc:	orr.w	r5, r5, #1
    ee00:	bgt.w	eb4e <__ssvfscanf_r+0x3da>
    ee04:	b.n	ebc4 <__ssvfscanf_r+0x450>
    ee06:	lsls	r4, r5, #31
    ee08:	bmi.n	ee24 <__ssvfscanf_r+0x6b0>
    ee0a:	lsls	r0, r5, #30
    ee0c:	bpl.n	ee24 <__ssvfscanf_r+0x6b0>
    ee0e:	ldr	r2, [sp, #20]
    ee10:	ldr	r6, [sp, #12]
    ee12:	ldr	r3, [r2, #0]
    ee14:	mov	r0, r7
    ee16:	asrs	r1, r7, #31
    ee18:	adds	r2, #4
    ee1a:	str	r2, [sp, #20]
    ee1c:	strd	r0, r1, [r3]
    ee20:	mov	r4, r6
    ee22:	b.n	e804 <__ssvfscanf_r+0x90>
    ee24:	ldr	r2, [sp, #20]
    ee26:	ldr	r6, [sp, #12]
    ee28:	ldr	r3, [r2, #0]
    ee2a:	str	r7, [r3, #0]
    ee2c:	mov	r3, r2
    ee2e:	adds	r3, #4
    ee30:	str	r3, [sp, #20]
    ee32:	mov	r4, r6
    ee34:	b.n	e804 <__ssvfscanf_r+0x90>
    ee36:	mov	r1, fp
    ee38:	mov	r0, sl
    ee3a:	bl	121b8 <__ssrefill_r>
    ee3e:	cmp	r0, #0
    ee40:	bne.w	e9be <__ssvfscanf_r+0x24a>
    ee44:	ldr	r3, [pc, #504]	; (f040 <__ssvfscanf_r+0x8cc>)
    ee46:	str	r0, [sp, #16]
    ee48:	str	r3, [sp, #28]
    ee4a:	movs	r6, #3
    ee4c:	b.n	e980 <__ssvfscanf_r+0x20c>
    ee4e:	mov	r1, fp
    ee50:	mov	r0, sl
    ee52:	bl	121b8 <__ssrefill_r>
    ee56:	cmp	r0, #0
    ee58:	beq.w	eaee <__ssvfscanf_r+0x37a>
    ee5c:	b.n	e9be <__ssvfscanf_r+0x24a>
    ee5e:	mov	r1, fp
    ee60:	mov	r0, sl
    ee62:	bl	121b8 <__ssrefill_r>
    ee66:	cmp	r0, #0
    ee68:	beq.w	ea84 <__ssvfscanf_r+0x310>
    ee6c:	b.n	e9be <__ssvfscanf_r+0x24a>
    ee6e:	mov	r1, fp
    ee70:	mov	r0, sl
    ee72:	bl	121b8 <__ssrefill_r>
    ee76:	cmp	r0, #0
    ee78:	beq.w	ebb2 <__ssvfscanf_r+0x43e>
    ee7c:	b.n	e9be <__ssvfscanf_r+0x24a>
    ee7e:	mov	r1, fp
    ee80:	mov	r0, sl
    ee82:	bl	121b8 <__ssrefill_r>
    ee86:	cmp	r0, #0
    ee88:	beq.w	ea16 <__ssvfscanf_r+0x2a2>
    ee8c:	b.n	e9be <__ssvfscanf_r+0x24a>
    ee8e:	mov	r1, fp
    ee90:	mov	r0, sl
    ee92:	bl	121b8 <__ssrefill_r>
    ee96:	cmp	r0, #0
    ee98:	beq.w	e9fe <__ssvfscanf_r+0x28a>
    ee9c:	b.n	e9be <__ssvfscanf_r+0x24a>
    ee9e:	cmp	r6, #3
    eea0:	beq.w	f1e2 <__ssvfscanf_r+0xa6e>
    eea4:	cmp	r6, #4
    eea6:	bne.w	f324 <__ssvfscanf_r+0xbb0>
    eeaa:	mov	r0, sl
    eeac:	bl	110e8 <_localeconv_r>
    eeb0:	subs	r3, r4, #1
    eeb2:	ldr	r2, [r0, #0]
    eeb4:	str	r2, [sp, #48]	; 0x30
    eeb6:	cmp.w	r3, #348	; 0x15c
    eeba:	bls.w	f38c <__ssvfscanf_r+0xc18>
    eebe:	mvn.w	r1, #348	; 0x15c
    eec2:	adds	r3, r4, r1
    eec4:	str	r3, [sp, #56]	; 0x38
    eec6:	movw	r4, #349	; 0x15d
    eeca:	add	r3, sp, #336	; 0x150
    eecc:	mov.w	r8, #0
    eed0:	mov	r2, r3
    eed2:	str	r3, [sp, #40]	; 0x28
    eed4:	orr.w	r5, r5, #1920	; 0x780
    eed8:	mov	r3, r8
    eeda:	str.w	r8, [sp, #60]	; 0x3c
    eede:	str.w	r8, [sp, #52]	; 0x34
    eee2:	mov	r6, r8
    eee4:	str.w	r8, [sp, #44]	; 0x2c
    eee8:	mov	r9, r2
    eeea:	ldr.w	r0, [fp]
    eeee:	ldrb	r1, [r0, #0]
    eef0:	sub.w	lr, r1, #43	; 0x2b
    eef4:	cmp.w	lr, #78	; 0x4e
    eef8:	bhi.w	f192 <__ssvfscanf_r+0xa1e>
    eefc:	tbh	[pc, lr, lsl #1]
    ef00:	.word	0x0149007a
    ef04:	.word	0x0149007a
    ef08:	.word	0x006e0149
    ef0c:	.word	0x004f004f
    ef10:	.word	0x004f004f
    ef14:	.word	0x004f004f
    ef18:	.word	0x004f004f
    ef1c:	.word	0x0149004f
    ef20:	.word	0x01490149
    ef24:	.word	0x01490149
    ef28:	.word	0x01490149
    ef2c:	.word	0x01490144
    ef30:	.word	0x01490149
    ef34:	.word	0x0125012c
    ef38:	.word	0x01490149
    ef3c:	.word	0x014900a2
    ef40:	.word	0x01490149
    ef44:	.word	0x008b0149
    ef48:	.word	0x01490149
    ef4c:	.word	0x01490149
    ef50:	.word	0x00850149
    ef54:	.word	0x01490149
    ef58:	.word	0x01490149
    ef5c:	.word	0x0149007f
    ef60:	.word	0x01490149
    ef64:	.word	0x01490149
    ef68:	.word	0x01490149
    ef6c:	.word	0x01490144
    ef70:	.word	0x01490149
    ef74:	.word	0x0125012c
    ef78:	.word	0x01490149
    ef7c:	.word	0x014900a2
    ef80:	.word	0x01490149
    ef84:	.word	0x008b0149
    ef88:	.word	0x01490149
    ef8c:	.word	0x01490149
    ef90:	.word	0x00850149
    ef94:	.word	0x01490149
    ef98:	.word	0x01490149
    ef9c:	.short	0x007f
    ef9e:	cmn.w	r3, r8
    efa2:	bne.n	efd2 <__ssvfscanf_r+0x85e>
    efa4:	bic.w	r5, r5, #384	; 0x180
    efa8:	strb.w	r1, [r9]
    efac:	add.w	r9, r9, #1
    efb0:	ldr.w	r1, [fp, #4]
    efb4:	subs	r1, #1
    efb6:	cmp	r1, #0
    efb8:	add.w	r4, r4, #4294967295
    efbc:	add.w	r7, r7, #1
    efc0:	str.w	r1, [fp, #4]
    efc4:	ble.w	f1ac <__ssvfscanf_r+0xa38>
    efc8:	adds	r0, #1
    efca:	str.w	r0, [fp]
    efce:	cmp	r4, #0
    efd0:	bne.n	eeea <__ssvfscanf_r+0x776>
    efd2:	cmp	r6, #0
    efd4:	beq.n	f05c <__ssvfscanf_r+0x8e8>
    efd6:	bic.w	r5, r5, #256	; 0x100
    efda:	b.n	f05c <__ssvfscanf_r+0x8e8>
    efdc:	lsls	r2, r5, #23
    efde:	bpl.n	ef9e <__ssvfscanf_r+0x82a>
    efe0:	ldr	r2, [sp, #56]	; 0x38
    efe2:	bic.w	r5, r5, #128	; 0x80
    efe6:	adds	r6, #1
    efe8:	cmp	r2, #0
    efea:	beq.n	efb0 <__ssvfscanf_r+0x83c>
    efec:	subs	r2, #1
    efee:	str	r2, [sp, #56]	; 0x38
    eff0:	adds	r4, #1
    eff2:	b.n	efb0 <__ssvfscanf_r+0x83c>
    eff4:	lsls	r2, r5, #24
    eff6:	bpl.n	efd2 <__ssvfscanf_r+0x85e>
    eff8:	bic.w	r5, r5, #128	; 0x80
    effc:	b.n	efa8 <__ssvfscanf_r+0x834>
    effe:	cmp.w	r8, #7
    f002:	bne.n	efd2 <__ssvfscanf_r+0x85e>
    f004:	mov.w	r8, #8
    f008:	b.n	efa8 <__ssvfscanf_r+0x834>
    f00a:	cmp.w	r8, #6
    f00e:	bne.n	efd2 <__ssvfscanf_r+0x85e>
    f010:	mov.w	r8, #7
    f014:	b.n	efa8 <__ssvfscanf_r+0x834>
    f016:	cmp	r3, #0
    f018:	bne.w	f1d8 <__ssvfscanf_r+0xa64>
    f01c:	cbnz	r6, f02a <__ssvfscanf_r+0x8b6>
    f01e:	and.w	lr, r5, #1792	; 0x700
    f022:	cmp.w	lr, #1792	; 0x700
    f026:	beq.w	f4b0 <__ssvfscanf_r+0xd3c>
    f02a:	cmp.w	r8, #1
    f02e:	beq.n	f036 <__ssvfscanf_r+0x8c2>
    f030:	cmp.w	r8, #4
    f034:	bne.n	efd2 <__ssvfscanf_r+0x85e>
    f036:	add.w	r8, r8, #1
    f03a:	uxtb.w	r8, r8
    f03e:	b.n	efa8 <__ssvfscanf_r+0x834>
    f040:	.word	0x0000d069
    f044:	cmp.w	r8, #0
    f048:	bne.w	f1c6 <__ssvfscanf_r+0xa52>
    f04c:	cmp	r6, #0
    f04e:	bne.n	efd6 <__ssvfscanf_r+0x862>
    f050:	and.w	lr, r5, #1792	; 0x700
    f054:	cmp.w	lr, #1792	; 0x700
    f058:	beq.w	f4d0 <__ssvfscanf_r+0xd5c>
    f05c:	subs	r3, #1
    f05e:	cmp	r3, #1
    f060:	bls.w	f566 <__ssvfscanf_r+0xdf2>
    f064:	add.w	r3, r8, #4294967295
    f068:	cmp	r3, #6
    f06a:	bhi.n	f09a <__ssvfscanf_r+0x926>
    f06c:	cmp.w	r8, #2
    f070:	bls.w	f5b4 <__ssvfscanf_r+0xe40>
    f074:	cmp.w	r8, #3
    f078:	beq.n	f09a <__ssvfscanf_r+0x926>
    f07a:	sub.w	r4, r8, #4
    f07e:	uxtb	r4, r4
    f080:	mvn.w	r8, r4
    f084:	add	r8, r9
    f086:	ldrb.w	r1, [r9, #-1]!
    f08a:	mov	r2, fp
    f08c:	mov	r0, sl
    f08e:	bl	12134 <_sungetc_r>
    f092:	cmp	r8, r9
    f094:	bne.n	f086 <__ssvfscanf_r+0x912>
    f096:	subs	r7, #1
    f098:	subs	r7, r7, r4
    f09a:	lsls	r1, r5, #23
    f09c:	bpl.n	f0d8 <__ssvfscanf_r+0x964>
    f09e:	lsls	r2, r5, #21
    f0a0:	bmi.w	f58a <__ssvfscanf_r+0xe16>
    f0a4:	ldrb.w	r1, [r9, #-1]
    f0a8:	cmp	r1, #101	; 0x65
    f0aa:	add.w	r4, r9, #4294967295
    f0ae:	add.w	r8, r7, #4294967295
    f0b2:	beq.n	f0cc <__ssvfscanf_r+0x958>
    f0b4:	cmp	r1, #69	; 0x45
    f0b6:	beq.n	f0cc <__ssvfscanf_r+0x958>
    f0b8:	mov	r2, fp
    f0ba:	mov	r0, sl
    f0bc:	bl	12134 <_sungetc_r>
    f0c0:	ldrb.w	r1, [r9, #-2]
    f0c4:	sub.w	r8, r7, #2
    f0c8:	sub.w	r4, r9, #2
    f0cc:	mov	r2, fp
    f0ce:	mov	r0, sl
    f0d0:	bl	12134 <_sungetc_r>
    f0d4:	mov	r7, r8
    f0d6:	mov	r9, r4
    f0d8:	ands.w	r2, r5, #16
    f0dc:	bne.w	ec3c <__ssvfscanf_r+0x4c8>
    f0e0:	and.w	r3, r5, #1536	; 0x600
    f0e4:	cmp.w	r3, #1024	; 0x400
    f0e8:	strb.w	r2, [r9]
    f0ec:	beq.w	f4da <__ssvfscanf_r+0xd66>
    f0f0:	ldr	r3, [sp, #52]	; 0x34
    f0f2:	cmp	r3, #0
    f0f4:	bne.w	f4fc <__ssvfscanf_r+0xd88>
    f0f8:	ldr	r1, [sp, #40]	; 0x28
    f0fa:	movs	r2, #0
    f0fc:	mov	r0, sl
    f0fe:	bl	cf10 <_strtod_r>
    f102:	lsls	r3, r5, #31
    f104:	bmi.w	f392 <__ssvfscanf_r+0xc1e>
    f108:	ands.w	r5, r5, #2
    f10c:	bne.w	f392 <__ssvfscanf_r+0xc1e>
    f110:	vmov	r2, r3, d0
    f114:	vmov	r0, r1, d0
    f118:	vstr	d0, [sp, #32]
    f11c:	bl	acf0 <__aeabi_dcmpun>
    f120:	ldr	r4, [sp, #20]
    f122:	vldr	d0, [sp, #32]
    f126:	adds	r6, r4, #4
    f128:	ldr	r4, [r4, #0]
    f12a:	cmp	r0, #0
    f12c:	bne.w	f5e8 <__ssvfscanf_r+0xe74>
    f130:	vmov	r0, r1, d0
    f134:	bl	adac <__aeabi_d2f>
    f138:	str	r6, [sp, #20]
    f13a:	str	r0, [r4, #0]
    f13c:	ldr	r3, [sp, #24]
    f13e:	ldr	r6, [sp, #12]
    f140:	adds	r3, #1
    f142:	str	r3, [sp, #24]
    f144:	mov	r4, r6
    f146:	b.w	e804 <__ssvfscanf_r+0x90>
    f14a:	cmp.w	r8, #2
    f14e:	bne.w	efd2 <__ssvfscanf_r+0x85e>
    f152:	mov.w	r8, #3
    f156:	b.n	efa8 <__ssvfscanf_r+0x834>
    f158:	and.w	lr, r5, #1280	; 0x500
    f15c:	cmp.w	lr, #1024	; 0x400
    f160:	beq.n	f16e <__ssvfscanf_r+0x9fa>
    f162:	lsls	r2, r5, #21
    f164:	bpl.w	efd2 <__ssvfscanf_r+0x85e>
    f168:	cmp	r6, #0
    f16a:	beq.w	f05c <__ssvfscanf_r+0x8e8>
    f16e:	lsls	r2, r5, #22
    f170:	bmi.n	f17c <__ssvfscanf_r+0xa08>
    f172:	ldr	r2, [sp, #44]	; 0x2c
    f174:	str.w	r9, [sp, #60]	; 0x3c
    f178:	subs	r2, r6, r2
    f17a:	str	r2, [sp, #52]	; 0x34
    f17c:	bic.w	r5, r5, #1920	; 0x780
    f180:	orr.w	r5, r5, #384	; 0x180
    f184:	movs	r6, #0
    f186:	b.n	efa8 <__ssvfscanf_r+0x834>
    f188:	cmp	r3, #1
    f18a:	bne.w	efd2 <__ssvfscanf_r+0x85e>
    f18e:	movs	r3, #2
    f190:	b.n	efa8 <__ssvfscanf_r+0x834>
    f192:	ldr	r2, [sp, #48]	; 0x30
    f194:	ldrb.w	lr, [r2]
    f198:	cmp	lr, r1
    f19a:	bne.w	efd2 <__ssvfscanf_r+0x85e>
    f19e:	lsls	r2, r5, #22
    f1a0:	bpl.w	efd2 <__ssvfscanf_r+0x85e>
    f1a4:	bic.w	r5, r5, #640	; 0x280
    f1a8:	str	r6, [sp, #44]	; 0x2c
    f1aa:	b.n	efa8 <__ssvfscanf_r+0x834>
    f1ac:	mov	r1, fp
    f1ae:	mov	r0, sl
    f1b0:	str	r3, [sp, #32]
    f1b2:	bl	121b8 <__ssrefill_r>
    f1b6:	ldr	r3, [sp, #32]
    f1b8:	cmp	r0, #0
    f1ba:	bne.w	efd2 <__ssvfscanf_r+0x85e>
    f1be:	cmp	r4, #0
    f1c0:	bne.w	eeea <__ssvfscanf_r+0x776>
    f1c4:	b.n	efd2 <__ssvfscanf_r+0x85e>
    f1c6:	cmp.w	r8, #3
    f1ca:	beq.w	f036 <__ssvfscanf_r+0x8c2>
    f1ce:	cmp.w	r8, #5
    f1d2:	beq.w	f036 <__ssvfscanf_r+0x8c2>
    f1d6:	b.n	efd2 <__ssvfscanf_r+0x85e>
    f1d8:	cmp	r3, #2
    f1da:	bne.w	f02a <__ssvfscanf_r+0x8b6>
    f1de:	movs	r3, #3
    f1e0:	b.n	efa8 <__ssvfscanf_r+0x834>
    f1e2:	subs	r3, r4, #1
    f1e4:	cmp.w	r3, #348	; 0x15c
    f1e8:	itte	hi
    f1ea:	mvnhi.w	r0, #348	; 0x15c
    f1ee:	addhi.w	r9, r4, r0
    f1f2:	movls	r9, r8
    f1f4:	add	r3, sp, #336	; 0x150
    f1f6:	mov	r0, r2
    f1f8:	mov	r2, r7
    f1fa:	mov	r7, r9
    f1fc:	ldr.w	r9, [sp, #16]
    f200:	str	r3, [sp, #40]	; 0x28
    f202:	it	hi
    f204:	movwhi	r4, #349	; 0x15d
    f208:	orr.w	r5, r5, #3456	; 0xd80
    f20c:	mov	r6, r3
    f20e:	mov.w	r8, #0
    f212:	sub.w	r3, r1, #43	; 0x2b
    f216:	cmp	r3, #77	; 0x4d
    f218:	bhi.n	f2be <__ssvfscanf_r+0xb4a>
    f21a:	tbb	[pc, r3]
    f21e:	.short	0x507e
    f220:	.word	0x6f50507e
    f224:	.word	0x69696969
    f228:	.word	0x4a696969
    f22c:	.word	0x5050504a
    f230:	.word	0x50505050
    f234:	.word	0x44444444
    f238:	.word	0x50504444
    f23c:	.word	0x50505050
    f240:	.word	0x50505050
    f244:	.word	0x50505050
    f248:	.word	0x27505050
    f24c:	.word	0x50505050
    f250:	.word	0x50505050
    f254:	.word	0x44444444
    f258:	.word	0x50504444
    f25c:	.word	0x50505050
    f260:	.word	0x50505050
    f264:	.word	0x50505050
    f268:	.word	0x27505050
    f26c:	and.w	r3, r5, #1536	; 0x600
    f270:	cmp.w	r3, #512	; 0x200
    f274:	bne.n	f2be <__ssvfscanf_r+0xb4a>
    f276:	bic.w	r5, r5, #512	; 0x200
    f27a:	orr.w	r5, r5, #1280	; 0x500
    f27e:	mov.w	r9, #16
    f282:	strb	r1, [r6, #0]
    f284:	adds	r6, #1
    f286:	ldr.w	r3, [fp, #4]
    f28a:	subs	r3, #1
    f28c:	cmp	r3, #0
    f28e:	str.w	r3, [fp, #4]
    f292:	ble.n	f37a <__ssvfscanf_r+0xc06>
    f294:	adds	r0, #1
    f296:	str.w	r0, [fp]
    f29a:	subs	r4, #1
    f29c:	beq.n	f2be <__ssvfscanf_r+0xb4a>
    f29e:	ldr.w	r0, [fp]
    f2a2:	ldrb	r1, [r0, #0]
    f2a4:	b.n	f212 <__ssvfscanf_r+0xa9e>
    f2a6:	cmp.w	r9, #10
    f2aa:	ble.n	f2be <__ssvfscanf_r+0xb4a>
    f2ac:	bic.w	r5, r5, #2944	; 0xb80
    f2b0:	b.n	f282 <__ssvfscanf_r+0xb0e>
    f2b2:	ldr	r3, [pc, #756]	; (f5a8 <__ssvfscanf_r+0xe34>)
    f2b4:	ldrsh.w	r9, [r3, r9, lsl #1]
    f2b8:	cmp.w	r9, #8
    f2bc:	bgt.n	f2ac <__ssvfscanf_r+0xb38>
    f2be:	lsls	r1, r5, #23
    f2c0:	mov	r7, r2
    f2c2:	str.w	r9, [sp, #16]
    f2c6:	bpl.n	f2d8 <__ssvfscanf_r+0xb64>
    f2c8:	ldr	r3, [sp, #40]	; 0x28
    f2ca:	cmp	r6, r3
    f2cc:	bhi.w	f4b8 <__ssvfscanf_r+0xd44>
    f2d0:	ldr	r3, [sp, #40]	; 0x28
    f2d2:	cmp	r6, r3
    f2d4:	beq.w	e810 <__ssvfscanf_r+0x9c>
    f2d8:	ands.w	r4, r5, #16
    f2dc:	beq.w	f404 <__ssvfscanf_r+0xc90>
    f2e0:	ldr	r3, [sp, #40]	; 0x28
    f2e2:	subs	r6, r6, r3
    f2e4:	add	r6, r8
    f2e6:	add	r7, r6
    f2e8:	ldr	r6, [sp, #12]
    f2ea:	mov	r4, r6
    f2ec:	b.w	e804 <__ssvfscanf_r+0x90>
    f2f0:	ldr	r3, [pc, #692]	; (f5a8 <__ssvfscanf_r+0xe34>)
    f2f2:	bic.w	r5, r5, #2944	; 0xb80
    f2f6:	ldrsh.w	r9, [r3, r9, lsl #1]
    f2fa:	b.n	f282 <__ssvfscanf_r+0xb0e>
    f2fc:	lsls	r3, r5, #20
    f2fe:	bpl.n	f282 <__ssvfscanf_r+0xb0e>
    f300:	cmp.w	r9, #0
    f304:	bne.n	f30e <__ssvfscanf_r+0xb9a>
    f306:	orr.w	r5, r5, #512	; 0x200
    f30a:	mov.w	r9, #8
    f30e:	lsls	r3, r5, #21
    f310:	bpl.w	f494 <__ssvfscanf_r+0xd20>
    f314:	bic.w	r5, r5, #1408	; 0x580
    f318:	b.n	f282 <__ssvfscanf_r+0xb0e>
    f31a:	lsls	r3, r5, #24
    f31c:	bpl.n	f2be <__ssvfscanf_r+0xb4a>
    f31e:	bic.w	r5, r5, #128	; 0x80
    f322:	b.n	f282 <__ssvfscanf_r+0xb0e>
    f324:	cmp	r4, #0
    f326:	it	eq
    f328:	moveq.w	r4, #4294967295
    f32c:	ands.w	r3, r5, #1
    f330:	bne.w	ebf0 <__ssvfscanf_r+0x47c>
    f334:	lsls	r1, r5, #27
    f336:	bpl.n	f3a0 <__ssvfscanf_r+0xc2c>
    f338:	mov	r5, r3
    f33a:	bl	b208 <__locale_ctype_ptr>
    f33e:	ldr.w	r3, [fp]
    f342:	ldrb	r2, [r3, #0]
    f344:	add	r0, r2
    f346:	adds	r3, #1
    f348:	ldrb	r2, [r0, #1]
    f34a:	lsls	r2, r2, #28
    f34c:	bmi.w	eace <__ssvfscanf_r+0x35a>
    f350:	ldr.w	r2, [fp, #4]
    f354:	str.w	r3, [fp]
    f358:	adds	r5, #1
    f35a:	subs	r3, r2, #1
    f35c:	cmp	r4, r5
    f35e:	str.w	r3, [fp, #4]
    f362:	beq.w	eace <__ssvfscanf_r+0x35a>
    f366:	cmp	r3, #0
    f368:	bgt.n	f33a <__ssvfscanf_r+0xbc6>
    f36a:	mov	r1, fp
    f36c:	mov	r0, sl
    f36e:	bl	121b8 <__ssrefill_r>
    f372:	cmp	r0, #0
    f374:	beq.n	f33a <__ssvfscanf_r+0xbc6>
    f376:	b.w	eace <__ssvfscanf_r+0x35a>
    f37a:	mov	r1, fp
    f37c:	mov	r0, sl
    f37e:	str	r2, [sp, #16]
    f380:	bl	121b8 <__ssrefill_r>
    f384:	ldr	r2, [sp, #16]
    f386:	cmp	r0, #0
    f388:	beq.n	f29a <__ssvfscanf_r+0xb26>
    f38a:	b.n	f2be <__ssvfscanf_r+0xb4a>
    f38c:	str.w	r8, [sp, #56]	; 0x38
    f390:	b.n	eeca <__ssvfscanf_r+0x756>
    f392:	ldr	r2, [sp, #20]
    f394:	ldr	r3, [r2, #0]
    f396:	adds	r2, #4
    f398:	str	r2, [sp, #20]
    f39a:	vstr	d0, [r3]
    f39e:	b.n	f13c <__ssvfscanf_r+0x9c8>
    f3a0:	ldr	r2, [sp, #20]
    f3a2:	ldr	r5, [r2, #0]
    f3a4:	adds	r6, r2, #4
    f3a6:	add	r4, r5
    f3a8:	mov	r8, r5
    f3aa:	bl	b208 <__locale_ctype_ptr>
    f3ae:	ldr.w	r2, [fp]
    f3b2:	ldrb	r3, [r2, #0]
    f3b4:	add	r0, r3
    f3b6:	adds	r1, r2, #1
    f3b8:	ldrb	r3, [r0, #1]
    f3ba:	lsls	r3, r3, #28
    f3bc:	bmi.n	f3ea <__ssvfscanf_r+0xc76>
    f3be:	ldr.w	r3, [fp, #4]
    f3c2:	str.w	r1, [fp]
    f3c6:	subs	r3, #1
    f3c8:	str.w	r3, [fp, #4]
    f3cc:	ldrb	r3, [r2, #0]
    f3ce:	strb.w	r3, [r8], #1
    f3d2:	cmp	r4, r8
    f3d4:	beq.n	f3ec <__ssvfscanf_r+0xc78>
    f3d6:	ldr.w	r3, [fp, #4]
    f3da:	cmp	r3, #0
    f3dc:	bgt.n	f3aa <__ssvfscanf_r+0xc36>
    f3de:	mov	r1, fp
    f3e0:	mov	r0, sl
    f3e2:	bl	121b8 <__ssrefill_r>
    f3e6:	cmp	r0, #0
    f3e8:	beq.n	f3aa <__ssvfscanf_r+0xc36>
    f3ea:	mov	r4, r8
    f3ec:	ldr	r2, [sp, #24]
    f3ee:	str	r6, [sp, #20]
    f3f0:	ldr	r6, [sp, #12]
    f3f2:	subs	r5, r4, r5
    f3f4:	movs	r3, #0
    f3f6:	adds	r2, #1
    f3f8:	strb	r3, [r4, #0]
    f3fa:	add	r7, r5
    f3fc:	str	r2, [sp, #24]
    f3fe:	mov	r4, r6
    f400:	b.w	e804 <__ssvfscanf_r+0x90>
    f404:	mov	r2, r4
    f406:	strb	r4, [r6, #0]
    f408:	ldr	r3, [sp, #16]
    f40a:	ldr	r1, [sp, #40]	; 0x28
    f40c:	ldr	r4, [sp, #28]
    f40e:	mov	r0, sl
    f410:	blx	r4
    f412:	lsls	r2, r5, #26
    f414:	bmi.n	f4a4 <__ssvfscanf_r+0xd30>
    f416:	lsls	r3, r5, #29
    f418:	bpl.n	f512 <__ssvfscanf_r+0xd9e>
    f41a:	ldr	r2, [sp, #20]
    f41c:	ldr	r3, [r2, #0]
    f41e:	adds	r2, #4
    f420:	str	r2, [sp, #20]
    f422:	strh	r0, [r3, #0]
    f424:	ldr	r3, [sp, #24]
    f426:	adds	r3, #1
    f428:	str	r3, [sp, #24]
    f42a:	b.n	f2e0 <__ssvfscanf_r+0xb6c>
    f42c:	bl	b1e4 <__locale_mb_cur_max>
    f430:	cmp	r6, r0
    f432:	beq.w	e9be <__ssvfscanf_r+0x24a>
    f436:	ldmia.w	fp, {r2, r3}
    f43a:	ldrb.w	r0, [r2], #1
    f43e:	str.w	r2, [fp]
    f442:	ldr	r2, [sp, #32]
    f444:	str	r2, [sp, #0]
    f446:	add	r2, sp, #336	; 0x150
    f448:	adds	r5, r6, #1
    f44a:	subs	r3, #1
    f44c:	strb	r0, [r2, r6]
    f44e:	str.w	r3, [fp, #4]
    f452:	mov	r1, r8
    f454:	mov	r3, r5
    f456:	mov	r0, sl
    f458:	bl	11104 <_mbrtowc_r>
    f45c:	adds	r6, r0, #1
    f45e:	beq.w	e9be <__ssvfscanf_r+0x24a>
    f462:	cmp	r0, #0
    f464:	bne.n	f53e <__ssvfscanf_r+0xdca>
    f466:	str.w	r0, [r8]
    f46a:	bl	110c8 <iswspace>
    f46e:	cmp	r0, #0
    f470:	beq.w	f5d2 <__ssvfscanf_r+0xe5e>
    f474:	cmp	r5, #0
    f476:	beq.w	ec2c <__ssvfscanf_r+0x4b8>
    f47a:	add	r3, sp, #336	; 0x150
    f47c:	adds	r4, r3, r5
    f47e:	subs	r5, #1
    f480:	mov	r2, fp
    f482:	ldrb.w	r1, [r4, #-1]!
    f486:	mov	r0, sl
    f488:	bl	12134 <_sungetc_r>
    f48c:	cmp	r5, #0
    f48e:	bne.n	f47e <__ssvfscanf_r+0xd0a>
    f490:	b.w	ec2c <__ssvfscanf_r+0x4b8>
    f494:	bic.w	r5, r5, #896	; 0x380
    f498:	cbz	r7, f49e <__ssvfscanf_r+0xd2a>
    f49a:	subs	r7, #1
    f49c:	adds	r4, #1
    f49e:	add.w	r8, r8, #1
    f4a2:	b.n	f286 <__ssvfscanf_r+0xb12>
    f4a4:	ldr	r2, [sp, #20]
    f4a6:	ldr	r3, [r2, #0]
    f4a8:	adds	r2, #4
    f4aa:	str	r2, [sp, #20]
    f4ac:	str	r0, [r3, #0]
    f4ae:	b.n	f424 <__ssvfscanf_r+0xcb0>
    f4b0:	bic.w	r5, r5, #1920	; 0x780
    f4b4:	movs	r3, #1
    f4b6:	b.n	efa8 <__ssvfscanf_r+0x834>
    f4b8:	ldrb.w	r1, [r6, #-1]
    f4bc:	mov	r2, fp
    f4be:	mov	r0, sl
    f4c0:	bl	12134 <_sungetc_r>
    f4c4:	subs	r6, #1
    f4c6:	b.n	f2d0 <__ssvfscanf_r+0xb5c>
    f4c8:	add.w	r8, sp, #68	; 0x44
    f4cc:	b.w	ec12 <__ssvfscanf_r+0x49e>
    f4d0:	bic.w	r5, r5, #1920	; 0x780
    f4d4:	mov.w	r8, #1
    f4d8:	b.n	efa8 <__ssvfscanf_r+0x834>
    f4da:	ldr	r3, [sp, #44]	; 0x2c
    f4dc:	subs	r6, r6, r3
    f4de:	negs	r2, r6
    f4e0:	cmp	r6, #0
    f4e2:	beq.w	f0f8 <__ssvfscanf_r+0x984>
    f4e6:	addw	r3, sp, #675	; 0x2a3
    f4ea:	cmp	r9, r3
    f4ec:	it	cs
    f4ee:	addwcs	r9, sp, #674	; 0x2a2
    f4f2:	mov	r0, r9
    f4f4:	ldr	r1, [pc, #180]	; (f5ac <__ssvfscanf_r+0xe38>)
    f4f6:	bl	bdb8 <sprintf>
    f4fa:	b.n	f0f8 <__ssvfscanf_r+0x984>
    f4fc:	ldr	r4, [sp, #60]	; 0x3c
    f4fe:	mov	r1, r4
    f500:	movs	r3, #10
    f502:	adds	r1, #1
    f504:	mov	r0, sl
    f506:	bl	d068 <_strtol_r>
    f50a:	ldr	r3, [sp, #52]	; 0x34
    f50c:	mov	r9, r4
    f50e:	subs	r2, r0, r3
    f510:	b.n	f4e6 <__ssvfscanf_r+0xd72>
    f512:	ands.w	r2, r5, #1
    f516:	bne.n	f4a4 <__ssvfscanf_r+0xd30>
    f518:	lsls	r4, r5, #30
    f51a:	bpl.n	f4a4 <__ssvfscanf_r+0xd30>
    f51c:	ldr	r3, [sp, #28]
    f51e:	mov	r1, r3
    f520:	ldr	r3, [pc, #140]	; (f5b0 <__ssvfscanf_r+0xe3c>)
    f522:	cmp	r1, r3
    f524:	mov	r0, sl
    f526:	ldr	r3, [sp, #16]
    f528:	ldr	r1, [sp, #40]	; 0x28
    f52a:	beq.n	f5f6 <__ssvfscanf_r+0xe82>
    f52c:	bl	11c74 <_strtoll_r>
    f530:	ldr	r2, [sp, #20]
    f532:	ldr	r3, [r2, #0]
    f534:	adds	r2, #4
    f536:	str	r2, [sp, #20]
    f538:	strd	r0, r1, [r3]
    f53c:	b.n	f424 <__ssvfscanf_r+0xcb0>
    f53e:	adds	r0, #2
    f540:	bne.n	f584 <__ssvfscanf_r+0xe10>
    f542:	mov	r6, r5
    f544:	ldr.w	r3, [fp, #4]
    f548:	cmp	r3, #0
    f54a:	bgt.w	ec14 <__ssvfscanf_r+0x4a0>
    f54e:	mov	r1, fp
    f550:	mov	r0, sl
    f552:	bl	121b8 <__ssrefill_r>
    f556:	cmp	r0, #0
    f558:	beq.w	ec14 <__ssvfscanf_r+0x4a0>
    f55c:	cmp	r6, #0
    f55e:	bne.w	e9be <__ssvfscanf_r+0x24a>
    f562:	b.w	ec2c <__ssvfscanf_r+0x4b8>
    f566:	ldr	r3, [sp, #40]	; 0x28
    f568:	cmp	r9, r3
    f56a:	bls.w	e810 <__ssvfscanf_r+0x9c>
    f56e:	ldrb.w	r1, [r9, #-1]!
    f572:	mov	r2, fp
    f574:	mov	r0, sl
    f576:	bl	12134 <_sungetc_r>
    f57a:	ldr	r3, [sp, #40]	; 0x28
    f57c:	cmp	r9, r3
    f57e:	bne.n	f56e <__ssvfscanf_r+0xdfa>
    f580:	b.w	e810 <__ssvfscanf_r+0x9c>
    f584:	ldr.w	r0, [r8]
    f588:	b.n	f46a <__ssvfscanf_r+0xcf6>
    f58a:	ldr	r3, [sp, #40]	; 0x28
    f58c:	cmp	r9, r3
    f58e:	bls.w	e810 <__ssvfscanf_r+0x9c>
    f592:	ldrb.w	r1, [r9, #-1]!
    f596:	mov	r2, fp
    f598:	mov	r0, sl
    f59a:	bl	12134 <_sungetc_r>
    f59e:	ldr	r3, [sp, #40]	; 0x28
    f5a0:	cmp	r9, r3
    f5a2:	bne.n	f592 <__ssvfscanf_r+0xe1e>
    f5a4:	b.w	e810 <__ssvfscanf_r+0x9c>
    f5a8:	.word	0x000130dc
    f5ac:	.word	0x00013100
    f5b0:	.word	0x00011e01
    f5b4:	ldr	r3, [sp, #40]	; 0x28
    f5b6:	cmp	r9, r3
    f5b8:	bls.w	e810 <__ssvfscanf_r+0x9c>
    f5bc:	ldrb.w	r1, [r9, #-1]!
    f5c0:	mov	r2, fp
    f5c2:	mov	r0, sl
    f5c4:	bl	12134 <_sungetc_r>
    f5c8:	ldr	r3, [sp, #40]	; 0x28
    f5ca:	cmp	r9, r3
    f5cc:	bne.n	f5bc <__ssvfscanf_r+0xe48>
    f5ce:	b.w	e810 <__ssvfscanf_r+0x9c>
    f5d2:	add	r7, r5
    f5d4:	subs	r4, #1
    f5d6:	cmp.w	r9, #0
    f5da:	bne.n	f5e4 <__ssvfscanf_r+0xe70>
    f5dc:	add.w	r8, r8, #4
    f5e0:	mov	r6, r9
    f5e2:	b.n	f544 <__ssvfscanf_r+0xdd0>
    f5e4:	mov	r6, r0
    f5e6:	b.n	f544 <__ssvfscanf_r+0xdd0>
    f5e8:	mov	r0, r5
    f5ea:	bl	11abc <nanf>
    f5ee:	str	r6, [sp, #20]
    f5f0:	vstr	s0, [r4]
    f5f4:	b.n	f13c <__ssvfscanf_r+0x9c8>
    f5f6:	bl	12010 <_strtoull_r>
    f5fa:	b.n	f530 <__ssvfscanf_r+0xdbc>

0000f5fc <_vdprintf_r>:
    f5fc:	push	{r4, r5, r6, r7, lr}
    f5fe:	sub.w	sp, sp, #532	; 0x214
    f602:	add	r5, sp, #16
    f604:	str	r3, [sp, #0]
    f606:	mov	r7, r1
    f608:	mov	r3, r2
    f60a:	mov.w	r4, #512	; 0x200
    f60e:	add	r2, sp, #12
    f610:	mov	r1, r5
    f612:	str	r4, [sp, #12]
    f614:	mov	r6, r0
    f616:	bl	122f0 <_vasnprintf_r>
    f61a:	cbz	r0, f640 <_vdprintf_r+0x44>
    f61c:	mov	r4, r0
    f61e:	mov	r2, r0
    f620:	mov	r1, r7
    f622:	ldr	r3, [sp, #12]
    f624:	mov	r0, r6
    f626:	bl	f67c <_write_r>
    f62a:	cmp	r4, r5
    f62c:	str	r0, [sp, #12]
    f62e:	beq.n	f63a <_vdprintf_r+0x3e>
    f630:	mov	r0, r6
    f632:	mov	r1, r4
    f634:	bl	10790 <_free_r>
    f638:	ldr	r0, [sp, #12]
    f63a:	add.w	sp, sp, #532	; 0x214
    f63e:	pop	{r4, r5, r6, r7, pc}
    f640:	mov.w	r0, #4294967295
    f644:	b.n	f63a <_vdprintf_r+0x3e>
    f646:	nop

0000f648 <vdprintf>:
    f648:	push	{r4}
    f64a:	ldr	r4, [pc, #16]	; (f65c <vdprintf+0x14>)
    f64c:	mov	r3, r2
    f64e:	mov	r2, r1
    f650:	mov	r1, r0
    f652:	ldr	r0, [r4, #0]
    f654:	ldr.w	r4, [sp], #4
    f658:	b.w	f5fc <_vdprintf_r>
    f65c:	.word	0x1fff1848

0000f660 <__ascii_wctomb>:
    f660:	cbz	r1, f66c <__ascii_wctomb+0xc>
    f662:	cmp	r2, #255	; 0xff
    f664:	bhi.n	f670 <__ascii_wctomb+0x10>
    f666:	strb	r2, [r1, #0]
    f668:	movs	r0, #1
    f66a:	bx	lr
    f66c:	mov	r0, r1
    f66e:	bx	lr
    f670:	movs	r3, #138	; 0x8a
    f672:	str	r3, [r0, #0]
    f674:	mov.w	r0, #4294967295
    f678:	bx	lr
    f67a:	nop

0000f67c <_write_r>:
    f67c:	push	{r4, r5, r6, lr}
    f67e:	mov	r5, r1
    f680:	ldr	r4, [pc, #32]	; (f6a4 <_write_r+0x28>)
    f682:	mov	r1, r2
    f684:	mov	r6, r0
    f686:	mov	r2, r3
    f688:	mov	r0, r5
    f68a:	movs	r3, #0
    f68c:	str	r3, [r4, #0]
    f68e:	bl	1468 <_write>
    f692:	adds	r3, r0, #1
    f694:	beq.n	f698 <_write_r+0x1c>
    f696:	pop	{r4, r5, r6, pc}
    f698:	ldr	r3, [r4, #0]
    f69a:	cmp	r3, #0
    f69c:	beq.n	f696 <_write_r+0x1a>
    f69e:	str	r3, [r6, #0]
    f6a0:	pop	{r4, r5, r6, pc}
    f6a2:	nop
    f6a4:	.word	0x2001d080

0000f6a8 <__register_exitproc>:
    f6a8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    f6ac:	ldr	r4, [pc, #148]	; (f744 <__register_exitproc+0x9c>)
    f6ae:	ldr	r5, [r4, #0]
    f6b0:	ldr.w	r4, [r5, #328]	; 0x148
    f6b4:	mov	r6, r0
    f6b6:	mov	r8, r1
    f6b8:	mov	sl, r2
    f6ba:	mov	r9, r3
    f6bc:	cbz	r4, f730 <__register_exitproc+0x88>
    f6be:	ldr	r0, [r4, #4]
    f6c0:	cmp	r0, #31
    f6c2:	bgt.n	f6f4 <__register_exitproc+0x4c>
    f6c4:	adds	r3, r0, #1
    f6c6:	cbz	r6, f6e6 <__register_exitproc+0x3e>
    f6c8:	add.w	r5, r4, r0, lsl #2
    f6cc:	movs	r2, #1
    f6ce:	str.w	sl, [r5, #136]	; 0x88
    f6d2:	ldr.w	r1, [r4, #392]	; 0x188
    f6d6:	lsls	r2, r0
    f6d8:	orrs	r1, r2
    f6da:	cmp	r6, #2
    f6dc:	str.w	r1, [r4, #392]	; 0x188
    f6e0:	str.w	r9, [r5, #264]	; 0x108
    f6e4:	beq.n	f724 <__register_exitproc+0x7c>
    f6e6:	adds	r0, #2
    f6e8:	str	r3, [r4, #4]
    f6ea:	str.w	r8, [r4, r0, lsl #2]
    f6ee:	movs	r0, #0
    f6f0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f6f4:	ldr	r3, [pc, #80]	; (f748 <__register_exitproc+0xa0>)
    f6f6:	cbz	r3, f73a <__register_exitproc+0x92>
    f6f8:	mov.w	r0, #400	; 0x190
    f6fc:	bl	b21c <malloc>
    f700:	mov	r4, r0
    f702:	cbz	r0, f73a <__register_exitproc+0x92>
    f704:	ldr.w	r3, [r5, #328]	; 0x148
    f708:	movs	r7, #0
    f70a:	stmia.w	r0, {r3, r7}
    f70e:	str.w	r4, [r5, #328]	; 0x148
    f712:	mov	r0, r7
    f714:	movs	r3, #1
    f716:	str.w	r7, [r4, #392]	; 0x188
    f71a:	str.w	r7, [r4, #396]	; 0x18c
    f71e:	cmp	r6, #0
    f720:	beq.n	f6e6 <__register_exitproc+0x3e>
    f722:	b.n	f6c8 <__register_exitproc+0x20>
    f724:	ldr.w	r1, [r4, #396]	; 0x18c
    f728:	orrs	r2, r1
    f72a:	str.w	r2, [r4, #396]	; 0x18c
    f72e:	b.n	f6e6 <__register_exitproc+0x3e>
    f730:	add.w	r4, r5, #332	; 0x14c
    f734:	str.w	r4, [r5, #328]	; 0x148
    f738:	b.n	f6be <__register_exitproc+0x16>
    f73a:	mov.w	r0, #4294967295
    f73e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f742:	nop
    f744:	.word	0x00013004
    f748:	.word	0x0000b21d

0000f74c <register_fini>:
    f74c:	ldr	r3, [pc, #8]	; (f758 <register_fini+0xc>)
    f74e:	cbz	r3, f756 <register_fini+0xa>
    f750:	ldr	r0, [pc, #8]	; (f75c <register_fini+0x10>)
    f752:	b.w	f760 <atexit>
    f756:	bx	lr
    f758:	.word	0x00000000
    f75c:	.word	0x000106cd

0000f760 <atexit>:
    f760:	movs	r3, #0
    f762:	mov	r1, r0
    f764:	mov	r2, r3
    f766:	mov	r0, r3
    f768:	b.w	f6a8 <__register_exitproc>

0000f76c <quorem>:
    f76c:	ldr	r2, [r0, #16]
    f76e:	ldr	r3, [r1, #16]
    f770:	cmp	r3, r2
    f772:	bgt.w	f890 <quorem+0x124>
    f776:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f77a:	add.w	r8, r3, #4294967295
    f77e:	add.w	r7, r1, #20
    f782:	add.w	fp, r0, #20
    f786:	ldr.w	r2, [r7, r8, lsl #2]
    f78a:	ldr.w	r3, [fp, r8, lsl #2]
    f78e:	mov.w	r4, r8, lsl #2
    f792:	sub	sp, #12
    f794:	adds	r2, #1
    f796:	udiv	r9, r3, r2
    f79a:	add.w	r3, fp, r4
    f79e:	str	r4, [sp, #0]
    f7a0:	add.w	sl, r7, r4
    f7a4:	str	r3, [sp, #4]
    f7a6:	cmp.w	r9, #0
    f7aa:	beq.n	f820 <quorem+0xb4>
    f7ac:	movs	r5, #0
    f7ae:	mov	ip, r7
    f7b0:	mov	lr, fp
    f7b2:	mov	r3, r5
    f7b4:	ldr.w	r6, [ip], #4
    f7b8:	ldr.w	r2, [lr]
    f7bc:	uxth	r4, r6
    f7be:	mla	r5, r9, r4, r5
    f7c2:	lsrs	r6, r6, #16
    f7c4:	lsrs	r4, r5, #16
    f7c6:	mla	r4, r9, r6, r4
    f7ca:	uxth	r5, r5
    f7cc:	subs	r3, r3, r5
    f7ce:	uxth	r6, r4
    f7d0:	uxtah	r3, r3, r2
    f7d4:	rsb	r6, r6, r2, lsr #16
    f7d8:	add.w	r6, r6, r3, asr #16
    f7dc:	uxth	r3, r3
    f7de:	orr.w	r3, r3, r6, lsl #16
    f7e2:	cmp	sl, ip
    f7e4:	str.w	r3, [lr], #4
    f7e8:	mov.w	r5, r4, lsr #16
    f7ec:	mov.w	r3, r6, asr #16
    f7f0:	bcs.n	f7b4 <quorem+0x48>
    f7f2:	ldr	r3, [sp, #0]
    f7f4:	ldr.w	r3, [fp, r3]
    f7f8:	cbnz	r3, f820 <quorem+0xb4>
    f7fa:	ldr	r4, [sp, #4]
    f7fc:	subs	r3, r4, #4
    f7fe:	cmp	fp, r3
    f800:	bcs.n	f81c <quorem+0xb0>
    f802:	ldr.w	r3, [r4, #-4]
    f806:	cbnz	r3, f81c <quorem+0xb0>
    f808:	sub.w	r3, r4, #8
    f80c:	b.n	f814 <quorem+0xa8>
    f80e:	ldr	r2, [r3, #0]
    f810:	subs	r3, #4
    f812:	cbnz	r2, f81c <quorem+0xb0>
    f814:	cmp	fp, r3
    f816:	add.w	r8, r8, #4294967295
    f81a:	bcc.n	f80e <quorem+0xa2>
    f81c:	str.w	r8, [r0, #16]
    f820:	mov	r4, r0
    f822:	bl	11608 <__mcmp>
    f826:	cmp	r0, #0
    f828:	blt.n	f888 <quorem+0x11c>
    f82a:	add.w	r9, r9, #1
    f82e:	mov	r5, fp
    f830:	movs	r3, #0
    f832:	ldr.w	r1, [r7], #4
    f836:	ldr	r0, [r5, #0]
    f838:	uxth	r2, r1
    f83a:	subs	r2, r3, r2
    f83c:	lsrs	r1, r1, #16
    f83e:	uxtah	r2, r2, r0
    f842:	rsb	r3, r1, r0, lsr #16
    f846:	add.w	r3, r3, r2, asr #16
    f84a:	uxth	r1, r2
    f84c:	orr.w	r1, r1, r3, lsl #16
    f850:	cmp	sl, r7
    f852:	str.w	r1, [r5], #4
    f856:	mov.w	r3, r3, asr #16
    f85a:	bcs.n	f832 <quorem+0xc6>
    f85c:	ldr.w	r2, [fp, r8, lsl #2]
    f860:	add.w	r3, fp, r8, lsl #2
    f864:	cbnz	r2, f888 <quorem+0x11c>
    f866:	subs	r2, r3, #4
    f868:	cmp	fp, r2
    f86a:	bcs.n	f884 <quorem+0x118>
    f86c:	ldr.w	r2, [r3, #-4]
    f870:	cbnz	r2, f884 <quorem+0x118>
    f872:	subs	r3, #8
    f874:	b.n	f87c <quorem+0x110>
    f876:	ldr	r2, [r3, #0]
    f878:	subs	r3, #4
    f87a:	cbnz	r2, f884 <quorem+0x118>
    f87c:	cmp	fp, r3
    f87e:	add.w	r8, r8, #4294967295
    f882:	bcc.n	f876 <quorem+0x10a>
    f884:	str.w	r8, [r4, #16]
    f888:	mov	r0, r9
    f88a:	add	sp, #12
    f88c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f890:	movs	r0, #0
    f892:	bx	lr
    f894:			; <UNDEFINED> instruction: 0xffffffff

0000f898 <_dtoa_r>:
    f898:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f89c:	vmov	r6, r7, d0
    f8a0:	sub	sp, #108	; 0x6c
    f8a2:	ldr	r4, [r0, #64]	; 0x40
    f8a4:	ldr	r5, [sp, #144]	; 0x90
    f8a6:	str	r1, [sp, #0]
    f8a8:	mov	r9, r0
    f8aa:	str	r2, [sp, #20]
    f8ac:	str	r3, [sp, #12]
    f8ae:	vmov	sl, s0
    f8b2:	mov	fp, r7
    f8b4:	cbz	r4, f8cc <_dtoa_r+0x34>
    f8b6:	ldr	r2, [r0, #68]	; 0x44
    f8b8:	str	r2, [r4, #4]
    f8ba:	movs	r3, #1
    f8bc:	lsls	r3, r2
    f8be:	str	r3, [r4, #8]
    f8c0:	mov	r1, r4
    f8c2:	bl	111ac <_Bfree>
    f8c6:	movs	r3, #0
    f8c8:	str.w	r3, [r9, #64]	; 0x40
    f8cc:	cmp.w	fp, #0
    f8d0:	mov	r4, fp
    f8d2:	blt.n	f93e <_dtoa_r+0xa6>
    f8d4:	movs	r3, #0
    f8d6:	str	r3, [r5, #0]
    f8d8:	ldr	r3, [pc, #644]	; (fb60 <_dtoa_r+0x2c8>)
    f8da:	mov	r2, r3
    f8dc:	ands	r3, r4
    f8de:	cmp	r3, r2
    f8e0:	beq.n	f910 <_dtoa_r+0x78>
    f8e2:	movs	r2, #0
    f8e4:	movs	r3, #0
    f8e6:	mov	r0, sl
    f8e8:	mov	r1, fp
    f8ea:	bl	ac8c <__aeabi_dcmpeq>
    f8ee:	mov	r6, sl
    f8f0:	mov	r7, fp
    f8f2:	mov	r8, r0
    f8f4:	cbz	r0, f94a <_dtoa_r+0xb2>
    f8f6:	ldr	r2, [sp, #12]
    f8f8:	movs	r3, #1
    f8fa:	str	r3, [r2, #0]
    f8fc:	ldr	r3, [sp, #148]	; 0x94
    f8fe:	cmp	r3, #0
    f900:	beq.w	fa80 <_dtoa_r+0x1e8>
    f904:	ldr	r0, [pc, #604]	; (fb64 <_dtoa_r+0x2cc>)
    f906:	str	r0, [r3, #0]
    f908:	subs	r0, #1
    f90a:	add	sp, #108	; 0x6c
    f90c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f910:	ldr	r2, [sp, #12]
    f912:	movw	r3, #9999	; 0x270f
    f916:	str	r3, [r2, #0]
    f918:	cmp.w	sl, #0
    f91c:	beq.w	fa54 <_dtoa_r+0x1bc>
    f920:	ldr	r0, [pc, #580]	; (fb68 <_dtoa_r+0x2d0>)
    f922:	ldr	r3, [sp, #148]	; 0x94
    f924:	cmp	r3, #0
    f926:	beq.n	f90a <_dtoa_r+0x72>
    f928:	ldrb	r3, [r0, #3]
    f92a:	cmp	r3, #0
    f92c:	beq.w	fa84 <_dtoa_r+0x1ec>
    f930:	add.w	r3, r0, #8
    f934:	ldr	r2, [sp, #148]	; 0x94
    f936:	str	r3, [r2, #0]
    f938:	add	sp, #108	; 0x6c
    f93a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f93e:	movs	r3, #1
    f940:	bic.w	r4, fp, #2147483648	; 0x80000000
    f944:	str	r3, [r5, #0]
    f946:	mov	fp, r4
    f948:	b.n	f8d8 <_dtoa_r+0x40>
    f94a:	add	r2, sp, #96	; 0x60
    f94c:	add	r1, sp, #100	; 0x64
    f94e:	vmov	d0, r6, r7
    f952:	mov	r0, r9
    f954:	bl	11884 <__d2b>
    f958:	lsrs	r5, r4, #20
    f95a:	str	r0, [sp, #40]	; 0x28
    f95c:	bne.w	fa66 <_dtoa_r+0x1ce>
    f960:	ldr	r5, [sp, #96]	; 0x60
    f962:	ldr	r6, [sp, #100]	; 0x64
    f964:	add	r6, r5
    f966:	addw	r3, r6, #1074	; 0x432
    f96a:	cmp	r3, #32
    f96c:	ble.w	fe80 <_dtoa_r+0x5e8>
    f970:	rsb	r3, r3, #64	; 0x40
    f974:	addw	r0, r6, #1042	; 0x412
    f978:	lsls	r4, r3
    f97a:	lsr.w	r0, sl, r0
    f97e:	orrs	r0, r4
    f980:	bl	a6d0 <__aeabi_ui2d>
    f984:	movs	r3, #1
    f986:	subs	r4, r6, #1
    f988:	sub.w	r1, r1, #32505856	; 0x1f00000
    f98c:	str	r3, [sp, #60]	; 0x3c
    f98e:	movs	r2, #0
    f990:	ldr	r3, [pc, #472]	; (fb6c <_dtoa_r+0x2d4>)
    f992:	bl	a454 <__aeabi_dsub>
    f996:	add	r3, pc, #432	; (adr r3, fb48 <_dtoa_r+0x2b0>)
    f998:	ldrd	r2, r3, [r3]
    f99c:	bl	a7bc <__aeabi_dmul>
    f9a0:	add	r3, pc, #428	; (adr r3, fb50 <_dtoa_r+0x2b8>)
    f9a2:	ldrd	r2, r3, [r3]
    f9a6:	bl	a458 <__adddf3>
    f9aa:	mov	r6, r0
    f9ac:	mov	r0, r4
    f9ae:	mov	r7, r1
    f9b0:	bl	a6f0 <__aeabi_i2d>
    f9b4:	add	r3, pc, #416	; (adr r3, fb58 <_dtoa_r+0x2c0>)
    f9b6:	ldrd	r2, r3, [r3]
    f9ba:	bl	a7bc <__aeabi_dmul>
    f9be:	mov	r2, r0
    f9c0:	mov	r3, r1
    f9c2:	mov	r0, r6
    f9c4:	mov	r1, r7
    f9c6:	bl	a458 <__adddf3>
    f9ca:	mov	r6, r0
    f9cc:	mov	r7, r1
    f9ce:	bl	ad1c <__aeabi_d2iz>
    f9d2:	movs	r2, #0
    f9d4:	str	r0, [sp, #16]
    f9d6:	movs	r3, #0
    f9d8:	mov	r0, r6
    f9da:	mov	r1, r7
    f9dc:	bl	aca0 <__aeabi_dcmplt>
    f9e0:	cmp	r0, #0
    f9e2:	bne.w	fe36 <_dtoa_r+0x59e>
    f9e6:	ldr	r6, [sp, #16]
    f9e8:	cmp	r6, #22
    f9ea:	bhi.w	fe30 <_dtoa_r+0x598>
    f9ee:	ldr	r3, [pc, #384]	; (fb70 <_dtoa_r+0x2d8>)
    f9f0:	add.w	r3, r3, r6, lsl #3
    f9f4:	ldrd	r0, r1, [r3]
    f9f8:	mov	r2, sl
    f9fa:	mov	r3, fp
    f9fc:	bl	acdc <__aeabi_dcmpgt>
    fa00:	cmp	r0, #0
    fa02:	beq.w	fe8a <_dtoa_r+0x5f2>
    fa06:	subs	r3, r6, #1
    fa08:	str	r3, [sp, #16]
    fa0a:	movs	r3, #0
    fa0c:	str	r3, [sp, #52]	; 0x34
    fa0e:	subs	r5, r5, r4
    fa10:	subs.w	r8, r5, #1
    fa14:	bmi.w	fe6c <_dtoa_r+0x5d4>
    fa18:	movs	r3, #0
    fa1a:	str	r3, [sp, #28]
    fa1c:	ldr	r3, [sp, #16]
    fa1e:	cmp	r3, #0
    fa20:	blt.w	fe5a <_dtoa_r+0x5c2>
    fa24:	add	r8, r3
    fa26:	str	r3, [sp, #48]	; 0x30
    fa28:	movs	r3, #0
    fa2a:	str	r3, [sp, #24]
    fa2c:	ldr	r3, [sp, #0]
    fa2e:	cmp	r3, #9
    fa30:	bhi.n	fa88 <_dtoa_r+0x1f0>
    fa32:	cmp	r3, #5
    fa34:	ble.w	106c0 <_dtoa_r+0xe28>
    fa38:	subs	r3, #4
    fa3a:	str	r3, [sp, #0]
    fa3c:	movs	r6, #0
    fa3e:	ldr	r3, [sp, #0]
    fa40:	subs	r3, #2
    fa42:	cmp	r3, #3
    fa44:	bhi.w	1068e <_dtoa_r+0xdf6>
    fa48:	tbh	[pc, r3, lsl #1]
    fa4c:	.word	0x0224032b
    fa50:	.word	0x04500336
    fa54:	ldr	r3, [pc, #272]	; (fb68 <_dtoa_r+0x2d0>)
    fa56:	ldr	r2, [pc, #284]	; (fb74 <_dtoa_r+0x2dc>)
    fa58:	ubfx	r0, r4, #0, #20
    fa5c:	cmp	r0, #0
    fa5e:	ite	ne
    fa60:	movne	r0, r3
    fa62:	moveq	r0, r2
    fa64:	b.n	f922 <_dtoa_r+0x8a>
    fa66:	ubfx	r3, fp, #0, #20
    fa6a:	orr.w	r1, r3, #1069547520	; 0x3fc00000
    fa6e:	subw	r4, r5, #1023	; 0x3ff
    fa72:	mov	r0, sl
    fa74:	str.w	r8, [sp, #60]	; 0x3c
    fa78:	orr.w	r1, r1, #3145728	; 0x300000
    fa7c:	ldr	r5, [sp, #96]	; 0x60
    fa7e:	b.n	f98e <_dtoa_r+0xf6>
    fa80:	ldr	r0, [pc, #244]	; (fb78 <_dtoa_r+0x2e0>)
    fa82:	b.n	f90a <_dtoa_r+0x72>
    fa84:	adds	r3, r0, #3
    fa86:	b.n	f934 <_dtoa_r+0x9c>
    fa88:	movs	r1, #0
    fa8a:	str.w	r1, [r9, #68]	; 0x44
    fa8e:	mov	r0, r9
    fa90:	mov	r4, r1
    fa92:	str	r1, [sp, #0]
    fa94:	bl	11160 <_Balloc>
    fa98:	mov.w	r3, #4294967295
    fa9c:	str	r3, [sp, #32]
    fa9e:	str	r3, [sp, #56]	; 0x38
    faa0:	movs	r3, #1
    faa2:	str	r0, [sp, #36]	; 0x24
    faa4:	str.w	r0, [r9, #64]	; 0x40
    faa8:	str	r4, [sp, #20]
    faaa:	str	r3, [sp, #44]	; 0x2c
    faac:	ldr	r3, [sp, #100]	; 0x64
    faae:	cmp	r3, #0
    fab0:	blt.w	fc54 <_dtoa_r+0x3bc>
    fab4:	ldr	r2, [sp, #16]
    fab6:	cmp	r2, #14
    fab8:	bgt.w	fc54 <_dtoa_r+0x3bc>
    fabc:	ldr	r3, [pc, #176]	; (fb70 <_dtoa_r+0x2d8>)
    fabe:	add.w	r3, r3, r2, lsl #3
    fac2:	vldr	d7, [r3]
    fac6:	ldr	r3, [sp, #20]
    fac8:	cmp	r3, #0
    faca:	vstr	d7, [sp]
    face:	blt.w	100ce <_dtoa_r+0x836>
    fad2:	mov	r6, sl
    fad4:	mov	r7, fp
    fad6:	ldrd	sl, fp, [sp]
    fada:	mov	r0, r6
    fadc:	mov	r2, sl
    fade:	mov	r3, fp
    fae0:	mov	r1, r7
    fae2:	bl	aa10 <__aeabi_ddiv>
    fae6:	bl	ad1c <__aeabi_d2iz>
    faea:	mov	r4, r0
    faec:	bl	a6f0 <__aeabi_i2d>
    faf0:	mov	r2, sl
    faf2:	mov	r3, fp
    faf4:	bl	a7bc <__aeabi_dmul>
    faf8:	mov	r3, r1
    fafa:	mov	r2, r0
    fafc:	mov	r1, r7
    fafe:	mov	r0, r6
    fb00:	bl	a454 <__aeabi_dsub>
    fb04:	ldr	r5, [sp, #36]	; 0x24
    fb06:	add.w	r3, r4, #48	; 0x30
    fb0a:	strb	r3, [r5, #0]
    fb0c:	ldr	r3, [sp, #32]
    fb0e:	cmp	r3, #1
    fb10:	mov	r6, r0
    fb12:	mov	r7, r1
    fb14:	add.w	r5, r5, #1
    fb18:	beq.n	fbde <_dtoa_r+0x346>
    fb1a:	movs	r2, #0
    fb1c:	ldr	r3, [pc, #92]	; (fb7c <_dtoa_r+0x2e4>)
    fb1e:	bl	a7bc <__aeabi_dmul>
    fb22:	movs	r2, #0
    fb24:	movs	r3, #0
    fb26:	mov	r6, r0
    fb28:	mov	r7, r1
    fb2a:	bl	ac8c <__aeabi_dcmpeq>
    fb2e:	cmp	r0, #0
    fb30:	bne.n	fc2e <_dtoa_r+0x396>
    fb32:	str.w	r9, [sp, #20]
    fb36:	ldr.w	sl, [sp, #32]
    fb3a:	ldr.w	fp, [sp, #36]	; 0x24
    fb3e:	ldrd	r8, r9, [sp]
    fb42:	b.n	fb96 <_dtoa_r+0x2fe>
    fb44:	nop.w
    fb48:	.word	0x636f4361
    fb4c:	.word	0x3fd287a7
    fb50:	.word	0x8b60c8b3
    fb54:	.word	0x3fc68a28
    fb58:	.word	0x509f79fb
    fb5c:	.word	0x3fd34413
    fb60:	.word	0x7ff00000
    fb64:	.word	0x000130c9
    fb68:	.word	0x00013218
    fb6c:	.word	0x3ff80000
    fb70:	.word	0x00013320
    fb74:	.word	0x0001320c
    fb78:	.word	0x000130c8
    fb7c:	.word	0x40240000
    fb80:	bl	a7bc <__aeabi_dmul>
    fb84:	movs	r2, #0
    fb86:	movs	r3, #0
    fb88:	mov	r6, r0
    fb8a:	mov	r7, r1
    fb8c:	bl	ac8c <__aeabi_dcmpeq>
    fb90:	cmp	r0, #0
    fb92:	bne.w	102f2 <_dtoa_r+0xa5a>
    fb96:	mov	r2, r8
    fb98:	mov	r3, r9
    fb9a:	mov	r0, r6
    fb9c:	mov	r1, r7
    fb9e:	bl	aa10 <__aeabi_ddiv>
    fba2:	bl	ad1c <__aeabi_d2iz>
    fba6:	mov	r4, r0
    fba8:	bl	a6f0 <__aeabi_i2d>
    fbac:	mov	r2, r8
    fbae:	mov	r3, r9
    fbb0:	bl	a7bc <__aeabi_dmul>
    fbb4:	mov	r2, r0
    fbb6:	mov	r3, r1
    fbb8:	mov	r0, r6
    fbba:	mov	r1, r7
    fbbc:	bl	a454 <__aeabi_dsub>
    fbc0:	add.w	lr, r4, #48	; 0x30
    fbc4:	strb.w	lr, [r5], #1
    fbc8:	rsb	lr, fp, r5
    fbcc:	cmp	lr, sl
    fbce:	mov	r6, r0
    fbd0:	mov	r7, r1
    fbd2:	mov.w	r2, #0
    fbd6:	ldr	r3, [pc, #696]	; (fe90 <_dtoa_r+0x5f8>)
    fbd8:	bne.n	fb80 <_dtoa_r+0x2e8>
    fbda:	ldr.w	r9, [sp, #20]
    fbde:	mov	r2, r6
    fbe0:	mov	r3, r7
    fbe2:	mov	r0, r6
    fbe4:	mov	r1, r7
    fbe6:	bl	a458 <__adddf3>
    fbea:	mov	r6, r0
    fbec:	mov	r7, r1
    fbee:	mov	r2, r0
    fbf0:	mov	r3, r1
    fbf2:	ldrd	r0, r1, [sp]
    fbf6:	bl	aca0 <__aeabi_dcmplt>
    fbfa:	cbnz	r0, fc0e <_dtoa_r+0x376>
    fbfc:	mov	r2, r6
    fbfe:	mov	r3, r7
    fc00:	ldrd	r0, r1, [sp]
    fc04:	bl	ac8c <__aeabi_dcmpeq>
    fc08:	cbz	r0, fc2e <_dtoa_r+0x396>
    fc0a:	lsls	r3, r4, #31
    fc0c:	bpl.n	fc2e <_dtoa_r+0x396>
    fc0e:	ldrb.w	r4, [r5, #-1]
    fc12:	ldr	r2, [sp, #36]	; 0x24
    fc14:	subs	r3, r5, #1
    fc16:	b.n	fc22 <_dtoa_r+0x38a>
    fc18:	cmp	r2, r3
    fc1a:	beq.w	10416 <_dtoa_r+0xb7e>
    fc1e:	ldrb.w	r4, [r3, #-1]!
    fc22:	cmp	r4, #57	; 0x39
    fc24:	add.w	r5, r3, #1
    fc28:	beq.n	fc18 <_dtoa_r+0x380>
    fc2a:	adds	r4, #1
    fc2c:	strb	r4, [r3, #0]
    fc2e:	ldr	r1, [sp, #40]	; 0x28
    fc30:	mov	r0, r9
    fc32:	bl	111ac <_Bfree>
    fc36:	movs	r2, #0
    fc38:	ldr	r3, [sp, #16]
    fc3a:	strb	r2, [r5, #0]
    fc3c:	ldr	r2, [sp, #12]
    fc3e:	adds	r3, #1
    fc40:	str	r3, [r2, #0]
    fc42:	ldr	r3, [sp, #148]	; 0x94
    fc44:	cmp	r3, #0
    fc46:	beq.w	10380 <_dtoa_r+0xae8>
    fc4a:	ldr	r0, [sp, #36]	; 0x24
    fc4c:	str	r5, [r3, #0]
    fc4e:	add	sp, #108	; 0x6c
    fc50:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    fc54:	ldr	r2, [sp, #44]	; 0x2c
    fc56:	cmp	r2, #0
    fc58:	beq.w	fe78 <_dtoa_r+0x5e0>
    fc5c:	ldr	r2, [sp, #0]
    fc5e:	cmp	r2, #1
    fc60:	ble.w	10112 <_dtoa_r+0x87a>
    fc64:	ldr	r3, [sp, #32]
    fc66:	ldr	r2, [sp, #24]
    fc68:	subs	r7, r3, #1
    fc6a:	cmp	r2, r7
    fc6c:	blt.w	10386 <_dtoa_r+0xaee>
    fc70:	subs	r7, r2, r7
    fc72:	ldr	r3, [sp, #32]
    fc74:	cmp	r3, #0
    fc76:	blt.w	1057a <_dtoa_r+0xce2>
    fc7a:	ldr	r5, [sp, #28]
    fc7c:	ldr	r3, [sp, #32]
    fc7e:	ldr	r2, [sp, #28]
    fc80:	movs	r1, #1
    fc82:	add	r2, r3
    fc84:	mov	r0, r9
    fc86:	str	r2, [sp, #28]
    fc88:	add	r8, r3
    fc8a:	bl	11374 <__i2b>
    fc8e:	mov	r6, r0
    fc90:	cbz	r5, fcac <_dtoa_r+0x414>
    fc92:	cmp.w	r8, #0
    fc96:	ble.n	fcac <_dtoa_r+0x414>
    fc98:	cmp	r5, r8
    fc9a:	ldr	r2, [sp, #28]
    fc9c:	mov	r3, r5
    fc9e:	it	ge
    fca0:	movge	r3, r8
    fca2:	subs	r2, r2, r3
    fca4:	str	r2, [sp, #28]
    fca6:	subs	r5, r5, r3
    fca8:	rsb	r8, r3, r8
    fcac:	ldr	r3, [sp, #24]
    fcae:	cmp	r3, #0
    fcb0:	ble.w	1029e <_dtoa_r+0xa06>
    fcb4:	ldr	r2, [sp, #44]	; 0x2c
    fcb6:	cmp	r2, #0
    fcb8:	beq.w	100c0 <_dtoa_r+0x828>
    fcbc:	cmp	r7, #0
    fcbe:	beq.w	100c0 <_dtoa_r+0x828>
    fcc2:	mov	r1, r6
    fcc4:	mov	r2, r7
    fcc6:	mov	r0, r9
    fcc8:	bl	114b8 <__pow5mult>
    fccc:	ldr	r2, [sp, #40]	; 0x28
    fcce:	mov	r1, r0
    fcd0:	mov	r6, r0
    fcd2:	mov	r0, r9
    fcd4:	bl	11388 <__multiply>
    fcd8:	ldr	r1, [sp, #40]	; 0x28
    fcda:	mov	r4, r0
    fcdc:	mov	r0, r9
    fcde:	bl	111ac <_Bfree>
    fce2:	ldr	r3, [sp, #24]
    fce4:	subs	r3, r3, r7
    fce6:	str	r3, [sp, #24]
    fce8:	bne.w	100be <_dtoa_r+0x826>
    fcec:	movs	r1, #1
    fcee:	mov	r0, r9
    fcf0:	bl	11374 <__i2b>
    fcf4:	ldr	r3, [sp, #48]	; 0x30
    fcf6:	str	r0, [sp, #24]
    fcf8:	cmp	r3, #0
    fcfa:	beq.w	10128 <_dtoa_r+0x890>
    fcfe:	mov	r1, r0
    fd00:	mov	r2, r3
    fd02:	mov	r0, r9
    fd04:	bl	114b8 <__pow5mult>
    fd08:	ldr	r3, [sp, #0]
    fd0a:	str	r0, [sp, #24]
    fd0c:	cmp	r3, #1
    fd0e:	ble.w	102f8 <_dtoa_r+0xa60>
    fd12:	movs	r7, #0
    fd14:	ldr	r2, [sp, #24]
    fd16:	ldr	r3, [r2, #16]
    fd18:	add.w	r3, r2, r3, lsl #2
    fd1c:	ldr	r0, [r3, #16]
    fd1e:	bl	112d8 <__hi0bits>
    fd22:	rsb	r0, r0, #32
    fd26:	add	r0, r8
    fd28:	ands.w	r0, r0, #31
    fd2c:	beq.w	10124 <_dtoa_r+0x88c>
    fd30:	rsb	r3, r0, #32
    fd34:	cmp	r3, #4
    fd36:	ble.w	106b4 <_dtoa_r+0xe1c>
    fd3a:	rsb	r0, r0, #28
    fd3e:	ldr	r3, [sp, #28]
    fd40:	add	r3, r0
    fd42:	str	r3, [sp, #28]
    fd44:	add	r5, r0
    fd46:	add	r8, r0
    fd48:	ldr	r3, [sp, #28]
    fd4a:	cmp	r3, #0
    fd4c:	ble.n	fd5a <_dtoa_r+0x4c2>
    fd4e:	mov	r1, r4
    fd50:	mov	r2, r3
    fd52:	mov	r0, r9
    fd54:	bl	11558 <__lshift>
    fd58:	mov	r4, r0
    fd5a:	cmp.w	r8, #0
    fd5e:	ble.n	fd6c <_dtoa_r+0x4d4>
    fd60:	mov	r2, r8
    fd62:	ldr	r1, [sp, #24]
    fd64:	mov	r0, r9
    fd66:	bl	11558 <__lshift>
    fd6a:	str	r0, [sp, #24]
    fd6c:	ldr	r3, [sp, #52]	; 0x34
    fd6e:	cmp	r3, #0
    fd70:	bne.w	10268 <_dtoa_r+0x9d0>
    fd74:	ldr	r3, [sp, #32]
    fd76:	cmp	r3, #0
    fd78:	ble.w	102a2 <_dtoa_r+0xa0a>
    fd7c:	ldr	r3, [sp, #44]	; 0x2c
    fd7e:	cmp	r3, #0
    fd80:	bne.w	1016c <_dtoa_r+0x8d4>
    fd84:	ldr.w	fp, [sp, #36]	; 0x24
    fd88:	ldr	r7, [sp, #32]
    fd8a:	ldr.w	r8, [sp, #24]
    fd8e:	mov	r5, fp
    fd90:	b.n	fd98 <_dtoa_r+0x500>
    fd92:	bl	111c0 <__multadd>
    fd96:	mov	r4, r0
    fd98:	mov	r1, r8
    fd9a:	mov	r0, r4
    fd9c:	bl	f76c <quorem>
    fda0:	add.w	sl, r0, #48	; 0x30
    fda4:	strb.w	sl, [r5], #1
    fda8:	rsb	r3, fp, r5
    fdac:	cmp	r3, r7
    fdae:	mov.w	r2, #10
    fdb2:	mov.w	r3, #0
    fdb6:	mov	r1, r4
    fdb8:	mov	r0, r9
    fdba:	blt.n	fd92 <_dtoa_r+0x4fa>
    fdbc:	ldr	r3, [sp, #36]	; 0x24
    fdbe:	ldr	r2, [sp, #32]
    fdc0:	cmp	r2, #1
    fdc2:	ite	ge
    fdc4:	addge	r3, r3, r2
    fdc6:	addlt	r3, #1
    fdc8:	mov	r5, r3
    fdca:	mov.w	fp, #0
    fdce:	mov	r1, r4
    fdd0:	movs	r2, #1
    fdd2:	mov	r0, r9
    fdd4:	bl	11558 <__lshift>
    fdd8:	ldr	r1, [sp, #24]
    fdda:	str	r0, [sp, #40]	; 0x28
    fddc:	bl	11608 <__mcmp>
    fde0:	cmp	r0, #0
    fde2:	ble.w	103f0 <_dtoa_r+0xb58>
    fde6:	ldrb.w	r2, [r5, #-1]
    fdea:	ldr	r1, [sp, #36]	; 0x24
    fdec:	subs	r3, r5, #1
    fdee:	b.n	fdfa <_dtoa_r+0x562>
    fdf0:	cmp	r3, r1
    fdf2:	beq.w	102de <_dtoa_r+0xa46>
    fdf6:	ldrb.w	r2, [r3, #-1]!
    fdfa:	cmp	r2, #57	; 0x39
    fdfc:	add.w	r5, r3, #1
    fe00:	beq.n	fdf0 <_dtoa_r+0x558>
    fe02:	adds	r2, #1
    fe04:	strb	r2, [r3, #0]
    fe06:	ldr	r1, [sp, #24]
    fe08:	mov	r0, r9
    fe0a:	bl	111ac <_Bfree>
    fe0e:	cmp	r6, #0
    fe10:	beq.w	fc2e <_dtoa_r+0x396>
    fe14:	cmp.w	fp, #0
    fe18:	beq.n	fe26 <_dtoa_r+0x58e>
    fe1a:	cmp	fp, r6
    fe1c:	beq.n	fe26 <_dtoa_r+0x58e>
    fe1e:	mov	r1, fp
    fe20:	mov	r0, r9
    fe22:	bl	111ac <_Bfree>
    fe26:	mov	r1, r6
    fe28:	mov	r0, r9
    fe2a:	bl	111ac <_Bfree>
    fe2e:	b.n	fc2e <_dtoa_r+0x396>
    fe30:	movs	r3, #1
    fe32:	str	r3, [sp, #52]	; 0x34
    fe34:	b.n	fa0e <_dtoa_r+0x176>
    fe36:	ldr.w	r8, [sp, #16]
    fe3a:	mov	r0, r8
    fe3c:	bl	a6f0 <__aeabi_i2d>
    fe40:	mov	r2, r0
    fe42:	mov	r3, r1
    fe44:	mov	r0, r6
    fe46:	mov	r1, r7
    fe48:	bl	ac8c <__aeabi_dcmpeq>
    fe4c:	cmp	r0, #0
    fe4e:	bne.w	f9e6 <_dtoa_r+0x14e>
    fe52:	add.w	r3, r8, #4294967295
    fe56:	str	r3, [sp, #16]
    fe58:	b.n	f9e6 <_dtoa_r+0x14e>
    fe5a:	ldr	r2, [sp, #28]
    fe5c:	ldr	r3, [sp, #16]
    fe5e:	subs	r2, r2, r3
    fe60:	negs	r3, r3
    fe62:	str	r3, [sp, #24]
    fe64:	movs	r3, #0
    fe66:	str	r2, [sp, #28]
    fe68:	str	r3, [sp, #48]	; 0x30
    fe6a:	b.n	fa2c <_dtoa_r+0x194>
    fe6c:	rsb	r3, r8, #0
    fe70:	str	r3, [sp, #28]
    fe72:	mov.w	r8, #0
    fe76:	b.n	fa1c <_dtoa_r+0x184>
    fe78:	ldr	r7, [sp, #24]
    fe7a:	ldr	r5, [sp, #28]
    fe7c:	ldr	r6, [sp, #44]	; 0x2c
    fe7e:	b.n	fc90 <_dtoa_r+0x3f8>
    fe80:	rsb	r4, r3, #32
    fe84:	lsl.w	r0, sl, r4
    fe88:	b.n	f980 <_dtoa_r+0xe8>
    fe8a:	str	r0, [sp, #52]	; 0x34
    fe8c:	b.n	fa0e <_dtoa_r+0x176>
    fe8e:	nop
    fe90:	.word	0x40240000
    fe94:	movs	r3, #0
    fe96:	str	r3, [sp, #44]	; 0x2c
    fe98:	ldr	r3, [sp, #16]
    fe9a:	ldr	r2, [sp, #20]
    fe9c:	add	r3, r2
    fe9e:	str	r3, [sp, #56]	; 0x38
    fea0:	adds	r3, #1
    fea2:	cmp	r3, #0
    fea4:	str	r3, [sp, #32]
    fea6:	ble.w	103a4 <_dtoa_r+0xb0c>
    feaa:	ldr	r4, [sp, #32]
    feac:	mov	r5, r4
    feae:	movs	r1, #0
    feb0:	cmp	r5, #23
    feb2:	str.w	r1, [r9, #68]	; 0x44
    feb6:	bls.n	fed0 <_dtoa_r+0x638>
    feb8:	movs	r2, #1
    feba:	movs	r3, #4
    febc:	lsls	r3, r3, #1
    febe:	add.w	r0, r3, #20
    fec2:	cmp	r0, r5
    fec4:	mov	r1, r2
    fec6:	add.w	r2, r2, #1
    feca:	bls.n	febc <_dtoa_r+0x624>
    fecc:	str.w	r1, [r9, #68]	; 0x44
    fed0:	mov	r0, r9
    fed2:	bl	11160 <_Balloc>
    fed6:	cmp	r4, #14
    fed8:	str	r0, [sp, #36]	; 0x24
    feda:	str.w	r0, [r9, #64]	; 0x40
    fede:	bhi.w	faac <_dtoa_r+0x214>
    fee2:	cmp	r6, #0
    fee4:	beq.w	faac <_dtoa_r+0x214>
    fee8:	ldr	r1, [sp, #16]
    feea:	cmp	r1, #0
    feec:	strd	sl, fp, [sp, #64]	; 0x40
    fef0:	ble.w	10428 <_dtoa_r+0xb90>
    fef4:	ldr	r3, [pc, #576]	; (10138 <_dtoa_r+0x8a0>)
    fef6:	and.w	r2, r1, #15
    fefa:	asrs	r6, r1, #4
    fefc:	add.w	r3, r3, r2, lsl #3
    ff00:	lsls	r0, r6, #27
    ff02:	ldrd	r4, r5, [r3]
    ff06:	bpl.w	10396 <_dtoa_r+0xafe>
    ff0a:	ldr	r3, [pc, #560]	; (1013c <_dtoa_r+0x8a4>)
    ff0c:	mov	r0, sl
    ff0e:	mov	r1, fp
    ff10:	ldrd	r2, r3, [r3, #32]
    ff14:	bl	aa10 <__aeabi_ddiv>
    ff18:	strd	r0, r1, [sp, #72]	; 0x48
    ff1c:	and.w	r6, r6, #15
    ff20:	mov.w	sl, #3
    ff24:	cbz	r6, ff48 <_dtoa_r+0x6b0>
    ff26:	ldr	r7, [pc, #532]	; (1013c <_dtoa_r+0x8a4>)
    ff28:	lsls	r1, r6, #31
    ff2a:	bpl.n	ff40 <_dtoa_r+0x6a8>
    ff2c:	mov	r0, r4
    ff2e:	mov	r1, r5
    ff30:	ldrd	r2, r3, [r7]
    ff34:	bl	a7bc <__aeabi_dmul>
    ff38:	add.w	sl, sl, #1
    ff3c:	mov	r4, r0
    ff3e:	mov	r5, r1
    ff40:	asrs	r6, r6, #1
    ff42:	add.w	r7, r7, #8
    ff46:	bne.n	ff28 <_dtoa_r+0x690>
    ff48:	mov	r2, r4
    ff4a:	mov	r3, r5
    ff4c:	ldrd	r0, r1, [sp, #72]	; 0x48
    ff50:	bl	aa10 <__aeabi_ddiv>
    ff54:	mov	r6, r0
    ff56:	mov	r7, r1
    ff58:	ldr	r3, [sp, #52]	; 0x34
    ff5a:	cbz	r3, ff6e <_dtoa_r+0x6d6>
    ff5c:	movs	r2, #0
    ff5e:	ldr	r3, [pc, #480]	; (10140 <_dtoa_r+0x8a8>)
    ff60:	mov	r0, r6
    ff62:	mov	r1, r7
    ff64:	bl	aca0 <__aeabi_dcmplt>
    ff68:	cmp	r0, #0
    ff6a:	bne.w	105a2 <_dtoa_r+0xd0a>
    ff6e:	mov	r0, sl
    ff70:	bl	a6f0 <__aeabi_i2d>
    ff74:	mov	r2, r6
    ff76:	mov	r3, r7
    ff78:	bl	a7bc <__aeabi_dmul>
    ff7c:	ldr	r3, [pc, #452]	; (10144 <_dtoa_r+0x8ac>)
    ff7e:	movs	r2, #0
    ff80:	bl	a458 <__adddf3>
    ff84:	ldr	r3, [sp, #32]
    ff86:	mov	r4, r0
    ff88:	sub.w	r5, r1, #54525952	; 0x3400000
    ff8c:	cmp	r3, #0
    ff8e:	beq.w	10348 <_dtoa_r+0xab0>
    ff92:	ldr	r3, [sp, #16]
    ff94:	str	r3, [sp, #88]	; 0x58
    ff96:	ldr	r3, [sp, #32]
    ff98:	str	r3, [sp, #72]	; 0x48
    ff9a:	ldr	r3, [sp, #44]	; 0x2c
    ff9c:	cmp	r3, #0
    ff9e:	beq.w	104ca <_dtoa_r+0xc32>
    ffa2:	ldr	r2, [sp, #72]	; 0x48
    ffa4:	ldr	r3, [pc, #400]	; (10138 <_dtoa_r+0x8a0>)
    ffa6:	ldr	r1, [pc, #416]	; (10148 <_dtoa_r+0x8b0>)
    ffa8:	add.w	r3, r3, r2, lsl #3
    ffac:	ldrd	r2, r3, [r3, #-8]
    ffb0:	movs	r0, #0
    ffb2:	bl	aa10 <__aeabi_ddiv>
    ffb6:	mov	r2, r4
    ffb8:	mov	r3, r5
    ffba:	bl	a454 <__aeabi_dsub>
    ffbe:	mov	sl, r0
    ffc0:	mov	fp, r1
    ffc2:	mov	r0, r6
    ffc4:	mov	r1, r7
    ffc6:	bl	ad1c <__aeabi_d2iz>
    ffca:	mov	r4, r0
    ffcc:	bl	a6f0 <__aeabi_i2d>
    ffd0:	mov	r2, r0
    ffd2:	mov	r3, r1
    ffd4:	mov	r0, r6
    ffd6:	mov	r1, r7
    ffd8:	bl	a454 <__aeabi_dsub>
    ffdc:	adds	r4, #48	; 0x30
    ffde:	ldr	r5, [sp, #36]	; 0x24
    ffe0:	uxtb	r4, r4
    ffe2:	mov	r6, r0
    ffe4:	mov	r7, r1
    ffe6:	strb	r4, [r5, #0]
    ffe8:	mov	r2, r0
    ffea:	mov	r3, r1
    ffec:	mov	r0, sl
    ffee:	mov	r1, fp
    fff0:	adds	r5, #1
    fff2:	bl	acdc <__aeabi_dcmpgt>
    fff6:	cmp	r0, #0
    fff8:	bne.n	1009c <_dtoa_r+0x804>
    fffa:	mov	r2, r6
    fffc:	mov	r3, r7
    fffe:	movs	r0, #0
   10000:	ldr	r1, [pc, #316]	; (10140 <_dtoa_r+0x8a8>)
   10002:	bl	a454 <__aeabi_dsub>
   10006:	mov	r2, r0
   10008:	mov	r3, r1
   1000a:	mov	r0, sl
   1000c:	mov	r1, fp
   1000e:	bl	acdc <__aeabi_dcmpgt>
   10012:	cmp	r0, #0
   10014:	bne.w	10628 <_dtoa_r+0xd90>
   10018:	ldr	r2, [sp, #72]	; 0x48
   1001a:	cmp	r2, #1
   1001c:	ble.w	1040e <_dtoa_r+0xb76>
   10020:	ldr	r3, [sp, #72]	; 0x48
   10022:	ldr	r2, [sp, #36]	; 0x24
   10024:	str.w	r8, [sp, #72]	; 0x48
   10028:	add	r3, r2
   1002a:	mov	r8, r3
   1002c:	b.n	1004a <_dtoa_r+0x7b2>
   1002e:	movs	r0, #0
   10030:	ldr	r1, [pc, #268]	; (10140 <_dtoa_r+0x8a8>)
   10032:	bl	a454 <__aeabi_dsub>
   10036:	mov	r2, sl
   10038:	mov	r3, fp
   1003a:	bl	aca0 <__aeabi_dcmplt>
   1003e:	cmp	r0, #0
   10040:	bne.w	10628 <_dtoa_r+0xd90>
   10044:	cmp	r5, r8
   10046:	beq.w	1040a <_dtoa_r+0xb72>
   1004a:	mov	r0, sl
   1004c:	mov	r1, fp
   1004e:	movs	r2, #0
   10050:	ldr	r3, [pc, #248]	; (1014c <_dtoa_r+0x8b4>)
   10052:	bl	a7bc <__aeabi_dmul>
   10056:	movs	r2, #0
   10058:	ldr	r3, [pc, #240]	; (1014c <_dtoa_r+0x8b4>)
   1005a:	mov	sl, r0
   1005c:	mov	fp, r1
   1005e:	mov	r0, r6
   10060:	mov	r1, r7
   10062:	bl	a7bc <__aeabi_dmul>
   10066:	mov	r7, r1
   10068:	mov	r6, r0
   1006a:	bl	ad1c <__aeabi_d2iz>
   1006e:	mov	r4, r0
   10070:	bl	a6f0 <__aeabi_i2d>
   10074:	mov	r2, r0
   10076:	mov	r3, r1
   10078:	mov	r0, r6
   1007a:	mov	r1, r7
   1007c:	bl	a454 <__aeabi_dsub>
   10080:	adds	r4, #48	; 0x30
   10082:	uxtb	r4, r4
   10084:	mov	r2, sl
   10086:	mov	r3, fp
   10088:	strb.w	r4, [r5], #1
   1008c:	mov	r6, r0
   1008e:	mov	r7, r1
   10090:	bl	aca0 <__aeabi_dcmplt>
   10094:	mov	r2, r6
   10096:	mov	r3, r7
   10098:	cmp	r0, #0
   1009a:	beq.n	1002e <_dtoa_r+0x796>
   1009c:	ldr	r3, [sp, #88]	; 0x58
   1009e:	str	r3, [sp, #16]
   100a0:	b.n	fc2e <_dtoa_r+0x396>
   100a2:	movs	r3, #0
   100a4:	str	r3, [sp, #44]	; 0x2c
   100a6:	ldr	r3, [sp, #20]
   100a8:	cmp	r3, #0
   100aa:	ble.w	103ae <_dtoa_r+0xb16>
   100ae:	mov	r5, r3
   100b0:	mov	r4, r3
   100b2:	str	r3, [sp, #56]	; 0x38
   100b4:	str	r3, [sp, #32]
   100b6:	b.n	feae <_dtoa_r+0x616>
   100b8:	movs	r3, #1
   100ba:	str	r3, [sp, #44]	; 0x2c
   100bc:	b.n	100a6 <_dtoa_r+0x80e>
   100be:	str	r4, [sp, #40]	; 0x28
   100c0:	ldr	r2, [sp, #24]
   100c2:	ldr	r1, [sp, #40]	; 0x28
   100c4:	mov	r0, r9
   100c6:	bl	114b8 <__pow5mult>
   100ca:	mov	r4, r0
   100cc:	b.n	fcec <_dtoa_r+0x454>
   100ce:	ldr	r3, [sp, #32]
   100d0:	cmp	r3, #0
   100d2:	bgt.w	fad2 <_dtoa_r+0x23a>
   100d6:	bne.w	10378 <_dtoa_r+0xae0>
   100da:	movs	r2, #0
   100dc:	ldr	r3, [pc, #112]	; (10150 <_dtoa_r+0x8b8>)
   100de:	ldrd	r0, r1, [sp]
   100e2:	bl	a7bc <__aeabi_dmul>
   100e6:	mov	r3, fp
   100e8:	mov	r2, sl
   100ea:	bl	acc8 <__aeabi_dcmpge>
   100ee:	ldr	r3, [sp, #32]
   100f0:	str	r3, [sp, #24]
   100f2:	mov	r6, r3
   100f4:	cmp	r0, #0
   100f6:	beq.w	102ce <_dtoa_r+0xa36>
   100fa:	ldr	r3, [sp, #20]
   100fc:	ldr	r5, [sp, #36]	; 0x24
   100fe:	mvns	r3, r3
   10100:	str	r3, [sp, #16]
   10102:	ldr	r1, [sp, #24]
   10104:	mov	r0, r9
   10106:	bl	111ac <_Bfree>
   1010a:	cmp	r6, #0
   1010c:	beq.w	fc2e <_dtoa_r+0x396>
   10110:	b.n	fe26 <_dtoa_r+0x58e>
   10112:	ldr	r2, [sp, #60]	; 0x3c
   10114:	cmp	r2, #0
   10116:	beq.w	1058a <_dtoa_r+0xcf2>
   1011a:	addw	r3, r3, #1075	; 0x433
   1011e:	ldr	r7, [sp, #24]
   10120:	ldr	r5, [sp, #28]
   10122:	b.n	fc7e <_dtoa_r+0x3e6>
   10124:	movs	r0, #28
   10126:	b.n	fd3e <_dtoa_r+0x4a6>
   10128:	ldr	r3, [sp, #0]
   1012a:	cmp	r3, #1
   1012c:	ble.w	10630 <_dtoa_r+0xd98>
   10130:	ldr	r7, [sp, #48]	; 0x30
   10132:	movs	r0, #1
   10134:	b.n	fd26 <_dtoa_r+0x48e>
   10136:	nop
   10138:	.word	0x00013320
   1013c:	.word	0x000133e8
   10140:	.word	0x3ff00000
   10144:	.word	0x401c0000
   10148:	.word	0x3fe00000
   1014c:	.word	0x40240000
   10150:	.word	0x40140000
   10154:	mov	r1, r6
   10156:	movs	r3, #0
   10158:	movs	r2, #10
   1015a:	mov	r0, r9
   1015c:	bl	111c0 <__multadd>
   10160:	ldr	r3, [sp, #56]	; 0x38
   10162:	cmp	r3, #0
   10164:	mov	r6, r0
   10166:	ble.w	10684 <_dtoa_r+0xdec>
   1016a:	str	r3, [sp, #32]
   1016c:	cmp	r5, #0
   1016e:	ble.n	1017c <_dtoa_r+0x8e4>
   10170:	mov	r1, r6
   10172:	mov	r2, r5
   10174:	mov	r0, r9
   10176:	bl	11558 <__lshift>
   1017a:	mov	r6, r0
   1017c:	cmp	r7, #0
   1017e:	bne.w	1047a <_dtoa_r+0xbe2>
   10182:	mov	r8, r6
   10184:	ldr	r3, [sp, #32]
   10186:	ldr	r2, [sp, #36]	; 0x24
   10188:	subs	r3, #1
   1018a:	adds	r3, r2, r3
   1018c:	str	r3, [sp, #32]
   1018e:	and.w	r3, sl, #1
   10192:	str	r3, [sp, #40]	; 0x28
   10194:	mov	r7, r2
   10196:	ldr.w	fp, [sp, #24]
   1019a:	mov	r0, r4
   1019c:	mov	r1, fp
   1019e:	bl	f76c <quorem>
   101a2:	mov	r1, r6
   101a4:	mov	r5, r0
   101a6:	mov	r0, r4
   101a8:	bl	11608 <__mcmp>
   101ac:	mov	r2, r8
   101ae:	mov	r1, fp
   101b0:	mov	sl, r0
   101b2:	mov	r0, r9
   101b4:	bl	1164c <__mdiff>
   101b8:	ldr	r2, [r0, #12]
   101ba:	mov	fp, r0
   101bc:	add.w	r3, r5, #48	; 0x30
   101c0:	cmp	r2, #0
   101c2:	bne.n	10258 <_dtoa_r+0x9c0>
   101c4:	mov	r1, r0
   101c6:	mov	r0, r4
   101c8:	str	r3, [sp, #28]
   101ca:	bl	11608 <__mcmp>
   101ce:	mov	r1, fp
   101d0:	str	r0, [sp, #20]
   101d2:	mov	r0, r9
   101d4:	bl	111ac <_Bfree>
   101d8:	ldr	r2, [sp, #20]
   101da:	ldr	r3, [sp, #28]
   101dc:	cbnz	r2, 101ea <_dtoa_r+0x952>
   101de:	ldr	r1, [sp, #0]
   101e0:	cbnz	r1, 101ea <_dtoa_r+0x952>
   101e2:	ldr	r1, [sp, #40]	; 0x28
   101e4:	cmp	r1, #0
   101e6:	beq.w	10654 <_dtoa_r+0xdbc>
   101ea:	cmp.w	sl, #0
   101ee:	blt.w	103b8 <_dtoa_r+0xb20>
   101f2:	bne.n	10200 <_dtoa_r+0x968>
   101f4:	ldr	r1, [sp, #0]
   101f6:	cbnz	r1, 10200 <_dtoa_r+0x968>
   101f8:	ldr	r1, [sp, #40]	; 0x28
   101fa:	cmp	r1, #0
   101fc:	beq.w	103b8 <_dtoa_r+0xb20>
   10200:	cmp	r2, #0
   10202:	bgt.w	104a2 <_dtoa_r+0xc0a>
   10206:	ldr	r2, [sp, #32]
   10208:	strb	r3, [r7, #0]
   1020a:	add.w	sl, r7, #1
   1020e:	cmp	r7, r2
   10210:	mov	r5, sl
   10212:	beq.w	104ba <_dtoa_r+0xc22>
   10216:	mov	r1, r4
   10218:	movs	r3, #0
   1021a:	movs	r2, #10
   1021c:	mov	r0, r9
   1021e:	bl	111c0 <__multadd>
   10222:	cmp	r6, r8
   10224:	mov	r4, r0
   10226:	mov	r1, r6
   10228:	mov.w	r3, #0
   1022c:	mov.w	r2, #10
   10230:	mov	r0, r9
   10232:	beq.n	1024c <_dtoa_r+0x9b4>
   10234:	bl	111c0 <__multadd>
   10238:	mov	r1, r8
   1023a:	mov	r6, r0
   1023c:	movs	r3, #0
   1023e:	movs	r2, #10
   10240:	mov	r0, r9
   10242:	bl	111c0 <__multadd>
   10246:	mov	r7, sl
   10248:	mov	r8, r0
   1024a:	b.n	10196 <_dtoa_r+0x8fe>
   1024c:	bl	111c0 <__multadd>
   10250:	mov	r7, sl
   10252:	mov	r6, r0
   10254:	mov	r8, r0
   10256:	b.n	10196 <_dtoa_r+0x8fe>
   10258:	mov	r1, r0
   1025a:	mov	r0, r9
   1025c:	str	r3, [sp, #20]
   1025e:	bl	111ac <_Bfree>
   10262:	movs	r2, #1
   10264:	ldr	r3, [sp, #20]
   10266:	b.n	101ea <_dtoa_r+0x952>
   10268:	ldr	r1, [sp, #24]
   1026a:	mov	r0, r4
   1026c:	bl	11608 <__mcmp>
   10270:	cmp	r0, #0
   10272:	bge.w	fd74 <_dtoa_r+0x4dc>
   10276:	mov	r1, r4
   10278:	ldr	r4, [sp, #16]
   1027a:	movs	r3, #0
   1027c:	subs	r4, #1
   1027e:	movs	r2, #10
   10280:	mov	r0, r9
   10282:	str	r4, [sp, #16]
   10284:	bl	111c0 <__multadd>
   10288:	ldr	r3, [sp, #44]	; 0x2c
   1028a:	mov	r4, r0
   1028c:	cmp	r3, #0
   1028e:	bne.w	10154 <_dtoa_r+0x8bc>
   10292:	ldr	r3, [sp, #56]	; 0x38
   10294:	cmp	r3, #0
   10296:	ble.w	10674 <_dtoa_r+0xddc>
   1029a:	str	r3, [sp, #32]
   1029c:	b.n	fd84 <_dtoa_r+0x4ec>
   1029e:	ldr	r4, [sp, #40]	; 0x28
   102a0:	b.n	fcec <_dtoa_r+0x454>
   102a2:	ldr	r3, [sp, #0]
   102a4:	cmp	r3, #2
   102a6:	ble.w	fd7c <_dtoa_r+0x4e4>
   102aa:	ldr	r3, [sp, #32]
   102ac:	cmp	r3, #0
   102ae:	bne.w	105ec <_dtoa_r+0xd54>
   102b2:	ldr	r1, [sp, #24]
   102b4:	movs	r2, #5
   102b6:	mov	r0, r9
   102b8:	bl	111c0 <__multadd>
   102bc:	mov	r1, r0
   102be:	str	r0, [sp, #24]
   102c0:	mov	r0, r4
   102c2:	bl	11608 <__mcmp>
   102c6:	cmp	r0, #0
   102c8:	str	r4, [sp, #40]	; 0x28
   102ca:	ble.w	100fa <_dtoa_r+0x862>
   102ce:	ldr	r2, [sp, #16]
   102d0:	ldr	r1, [sp, #36]	; 0x24
   102d2:	movs	r3, #49	; 0x31
   102d4:	adds	r2, #1
   102d6:	str	r2, [sp, #16]
   102d8:	strb	r3, [r1, #0]
   102da:	adds	r5, r1, #1
   102dc:	b.n	10102 <_dtoa_r+0x86a>
   102de:	ldr	r2, [sp, #16]
   102e0:	adds	r2, #1
   102e2:	str	r2, [sp, #16]
   102e4:	ldr	r2, [sp, #36]	; 0x24
   102e6:	movs	r3, #49	; 0x31
   102e8:	strb	r3, [r2, #0]
   102ea:	b.n	fe06 <_dtoa_r+0x56e>
   102ec:	movs	r3, #1
   102ee:	str	r3, [sp, #44]	; 0x2c
   102f0:	b.n	fe98 <_dtoa_r+0x600>
   102f2:	ldr.w	r9, [sp, #20]
   102f6:	b.n	fc2e <_dtoa_r+0x396>
   102f8:	cmp.w	sl, #0
   102fc:	bne.w	fd12 <_dtoa_r+0x47a>
   10300:	ubfx	r3, fp, #0, #20
   10304:	cmp	r3, #0
   10306:	bne.w	10586 <_dtoa_r+0xcee>
   1030a:	bic.w	r7, fp, #2147483648	; 0x80000000
   1030e:	lsrs	r7, r7, #20
   10310:	lsls	r7, r7, #20
   10312:	cbz	r7, 10320 <_dtoa_r+0xa88>
   10314:	ldr	r3, [sp, #28]
   10316:	adds	r3, #1
   10318:	str	r3, [sp, #28]
   1031a:	add.w	r8, r8, #1
   1031e:	movs	r7, #1
   10320:	ldr	r3, [sp, #48]	; 0x30
   10322:	movs	r0, #1
   10324:	cmp	r3, #0
   10326:	beq.w	fd26 <_dtoa_r+0x48e>
   1032a:	b.n	fd14 <_dtoa_r+0x47c>
   1032c:	mov	r0, sl
   1032e:	bl	a6f0 <__aeabi_i2d>
   10332:	mov	r2, r6
   10334:	mov	r3, r7
   10336:	bl	a7bc <__aeabi_dmul>
   1033a:	movs	r2, #0
   1033c:	ldr	r3, [pc, #764]	; (1063c <_dtoa_r+0xda4>)
   1033e:	bl	a458 <__adddf3>
   10342:	mov	r4, r0
   10344:	sub.w	r5, r1, #54525952	; 0x3400000
   10348:	mov	r0, r6
   1034a:	mov	r1, r7
   1034c:	movs	r2, #0
   1034e:	ldr	r3, [pc, #752]	; (10640 <_dtoa_r+0xda8>)
   10350:	bl	a454 <__aeabi_dsub>
   10354:	mov	r2, r4
   10356:	mov	r3, r5
   10358:	mov	r6, r0
   1035a:	mov	r7, r1
   1035c:	bl	acdc <__aeabi_dcmpgt>
   10360:	cmp	r0, #0
   10362:	bne.w	104c2 <_dtoa_r+0xc2a>
   10366:	mov	r2, r4
   10368:	add.w	r3, r5, #2147483648	; 0x80000000
   1036c:	mov	r0, r6
   1036e:	mov	r1, r7
   10370:	bl	aca0 <__aeabi_dcmplt>
   10374:	cmp	r0, #0
   10376:	beq.n	1040e <_dtoa_r+0xb76>
   10378:	movs	r3, #0
   1037a:	str	r3, [sp, #24]
   1037c:	mov	r6, r3
   1037e:	b.n	100fa <_dtoa_r+0x862>
   10380:	ldr	r0, [sp, #36]	; 0x24
   10382:	b.w	f90a <_dtoa_r+0x72>
   10386:	ldr	r3, [sp, #24]
   10388:	ldr	r2, [sp, #48]	; 0x30
   1038a:	str	r7, [sp, #24]
   1038c:	subs	r3, r7, r3
   1038e:	add	r2, r3
   10390:	str	r2, [sp, #48]	; 0x30
   10392:	movs	r7, #0
   10394:	b.n	fc72 <_dtoa_r+0x3da>
   10396:	vldr	d7, [sp, #64]	; 0x40
   1039a:	mov.w	sl, #2
   1039e:	vstr	d7, [sp, #72]	; 0x48
   103a2:	b.n	ff24 <_dtoa_r+0x68c>
   103a4:	mov	r4, r3
   103a6:	movs	r1, #0
   103a8:	str.w	r1, [r9, #68]	; 0x44
   103ac:	b.n	fed0 <_dtoa_r+0x638>
   103ae:	movs	r4, #1
   103b0:	str	r4, [sp, #56]	; 0x38
   103b2:	str	r4, [sp, #32]
   103b4:	str	r4, [sp, #20]
   103b6:	b.n	103a6 <_dtoa_r+0xb0e>
   103b8:	cmp	r2, #0
   103ba:	mov	sl, r3
   103bc:	ble.n	103e2 <_dtoa_r+0xb4a>
   103be:	mov	r1, r4
   103c0:	movs	r2, #1
   103c2:	mov	r0, r9
   103c4:	bl	11558 <__lshift>
   103c8:	ldr	r1, [sp, #24]
   103ca:	mov	r4, r0
   103cc:	bl	11608 <__mcmp>
   103d0:	cmp	r0, #0
   103d2:	ble.w	10666 <_dtoa_r+0xdce>
   103d6:	cmp.w	sl, #57	; 0x39
   103da:	beq.w	105f0 <_dtoa_r+0xd58>
   103de:	add.w	sl, r5, #49	; 0x31
   103e2:	mov	fp, r6
   103e4:	strb.w	sl, [r7]
   103e8:	adds	r5, r7, #1
   103ea:	mov	r6, r8
   103ec:	str	r4, [sp, #40]	; 0x28
   103ee:	b.n	fe06 <_dtoa_r+0x56e>
   103f0:	bne.n	103fc <_dtoa_r+0xb64>
   103f2:	tst.w	sl, #1
   103f6:	beq.n	103fc <_dtoa_r+0xb64>
   103f8:	b.n	fde6 <_dtoa_r+0x54e>
   103fa:	mov	r5, r2
   103fc:	ldrb.w	r3, [r5, #-1]
   10400:	cmp	r3, #48	; 0x30
   10402:	add.w	r2, r5, #4294967295
   10406:	beq.n	103fa <_dtoa_r+0xb62>
   10408:	b.n	fe06 <_dtoa_r+0x56e>
   1040a:	ldr.w	r8, [sp, #72]	; 0x48
   1040e:	ldrd	sl, fp, [sp, #64]	; 0x40
   10412:	b.w	faac <_dtoa_r+0x214>
   10416:	ldr	r1, [sp, #36]	; 0x24
   10418:	movs	r2, #48	; 0x30
   1041a:	strb	r2, [r1, #0]
   1041c:	ldr	r2, [sp, #16]
   1041e:	ldrb.w	r4, [r5, #-1]
   10422:	adds	r2, #1
   10424:	str	r2, [sp, #16]
   10426:	b.n	fc2a <_dtoa_r+0x392>
   10428:	ldr	r3, [sp, #16]
   1042a:	negs	r4, r3
   1042c:	cmp	r4, #0
   1042e:	beq.w	10598 <_dtoa_r+0xd00>
   10432:	ldr	r3, [pc, #528]	; (10644 <_dtoa_r+0xdac>)
   10434:	and.w	r2, r4, #15
   10438:	add.w	r3, r3, r2, lsl #3
   1043c:	ldrd	r2, r3, [r3]
   10440:	ldrd	r0, r1, [sp, #64]	; 0x40
   10444:	bl	a7bc <__aeabi_dmul>
   10448:	asrs	r4, r4, #4
   1044a:	mov	r6, r0
   1044c:	mov	r7, r1
   1044e:	beq.w	1067e <_dtoa_r+0xde6>
   10452:	ldr	r5, [pc, #500]	; (10648 <_dtoa_r+0xdb0>)
   10454:	mov.w	sl, #2
   10458:	lsls	r2, r4, #31
   1045a:	bpl.n	10470 <_dtoa_r+0xbd8>
   1045c:	mov	r0, r6
   1045e:	mov	r1, r7
   10460:	ldrd	r2, r3, [r5]
   10464:	bl	a7bc <__aeabi_dmul>
   10468:	add.w	sl, sl, #1
   1046c:	mov	r6, r0
   1046e:	mov	r7, r1
   10470:	asrs	r4, r4, #1
   10472:	add.w	r5, r5, #8
   10476:	bne.n	10458 <_dtoa_r+0xbc0>
   10478:	b.n	ff58 <_dtoa_r+0x6c0>
   1047a:	ldr	r1, [r6, #4]
   1047c:	mov	r0, r9
   1047e:	bl	11160 <_Balloc>
   10482:	ldr	r3, [r6, #16]
   10484:	adds	r2, r3, #2
   10486:	mov	r5, r0
   10488:	lsls	r2, r2, #2
   1048a:	add.w	r1, r6, #12
   1048e:	adds	r0, #12
   10490:	bl	8e18 <memcpy>
   10494:	mov	r1, r5
   10496:	movs	r2, #1
   10498:	mov	r0, r9
   1049a:	bl	11558 <__lshift>
   1049e:	mov	r8, r0
   104a0:	b.n	10184 <_dtoa_r+0x8ec>
   104a2:	cmp	r3, #57	; 0x39
   104a4:	beq.w	105f0 <_dtoa_r+0xd58>
   104a8:	add.w	sl, r3, #1
   104ac:	mov	fp, r6
   104ae:	strb.w	sl, [r7]
   104b2:	adds	r5, r7, #1
   104b4:	mov	r6, r8
   104b6:	str	r4, [sp, #40]	; 0x28
   104b8:	b.n	fe06 <_dtoa_r+0x56e>
   104ba:	mov	fp, r6
   104bc:	mov	sl, r3
   104be:	mov	r6, r8
   104c0:	b.n	fdce <_dtoa_r+0x536>
   104c2:	movs	r3, #0
   104c4:	str	r3, [sp, #24]
   104c6:	mov	r6, r3
   104c8:	b.n	102ce <_dtoa_r+0xa36>
   104ca:	ldr	r3, [sp, #72]	; 0x48
   104cc:	ldr	r1, [pc, #372]	; (10644 <_dtoa_r+0xdac>)
   104ce:	subs	r2, r3, #1
   104d0:	add.w	r1, r1, r2, lsl #3
   104d4:	mov	r3, r5
   104d6:	str	r2, [sp, #92]	; 0x5c
   104d8:	ldrd	r0, r1, [r1]
   104dc:	mov	r2, r4
   104de:	bl	a7bc <__aeabi_dmul>
   104e2:	strd	r0, r1, [sp, #80]	; 0x50
   104e6:	mov	r1, r7
   104e8:	mov	r0, r6
   104ea:	bl	ad1c <__aeabi_d2iz>
   104ee:	mov	r4, r0
   104f0:	bl	a6f0 <__aeabi_i2d>
   104f4:	mov	r3, r1
   104f6:	mov	r2, r0
   104f8:	mov	r1, r7
   104fa:	mov	r0, r6
   104fc:	bl	a454 <__aeabi_dsub>
   10500:	ldr	r3, [sp, #72]	; 0x48
   10502:	mov	r7, r1
   10504:	ldr	r1, [sp, #36]	; 0x24
   10506:	adds	r4, #48	; 0x30
   10508:	cmp	r3, #1
   1050a:	mov	r6, r0
   1050c:	strb	r4, [r1, #0]
   1050e:	add.w	r5, r1, #1
   10512:	beq.n	10556 <_dtoa_r+0xcbe>
   10514:	ldr	r3, [sp, #72]	; 0x48
   10516:	ldr	r2, [sp, #36]	; 0x24
   10518:	add	r3, r2
   1051a:	mov	sl, r3
   1051c:	mov	fp, r5
   1051e:	movs	r2, #0
   10520:	ldr	r3, [pc, #296]	; (1064c <_dtoa_r+0xdb4>)
   10522:	mov	r0, r6
   10524:	mov	r1, r7
   10526:	bl	a7bc <__aeabi_dmul>
   1052a:	mov	r7, r1
   1052c:	mov	r6, r0
   1052e:	bl	ad1c <__aeabi_d2iz>
   10532:	mov	r4, r0
   10534:	bl	a6f0 <__aeabi_i2d>
   10538:	adds	r4, #48	; 0x30
   1053a:	mov	r2, r0
   1053c:	mov	r3, r1
   1053e:	mov	r0, r6
   10540:	mov	r1, r7
   10542:	bl	a454 <__aeabi_dsub>
   10546:	strb.w	r4, [fp], #1
   1054a:	cmp	sl, fp
   1054c:	mov	r6, r0
   1054e:	mov	r7, r1
   10550:	bne.n	1051e <_dtoa_r+0xc86>
   10552:	ldr	r3, [sp, #92]	; 0x5c
   10554:	add	r5, r3
   10556:	movs	r2, #0
   10558:	ldr	r3, [pc, #244]	; (10650 <_dtoa_r+0xdb8>)
   1055a:	ldrd	r0, r1, [sp, #80]	; 0x50
   1055e:	bl	a458 <__adddf3>
   10562:	mov	r2, r6
   10564:	mov	r3, r7
   10566:	bl	aca0 <__aeabi_dcmplt>
   1056a:	cmp	r0, #0
   1056c:	beq.n	10600 <_dtoa_r+0xd68>
   1056e:	ldr	r3, [sp, #88]	; 0x58
   10570:	str	r3, [sp, #16]
   10572:	ldrb.w	r4, [r5, #-1]
   10576:	b.w	fc12 <_dtoa_r+0x37a>
   1057a:	ldr	r3, [sp, #28]
   1057c:	ldr	r2, [sp, #32]
   1057e:	subs	r5, r3, r2
   10580:	movs	r3, #0
   10582:	b.w	fc7e <_dtoa_r+0x3e6>
   10586:	movs	r7, #0
   10588:	b.n	10320 <_dtoa_r+0xa88>
   1058a:	ldr	r3, [sp, #96]	; 0x60
   1058c:	ldr	r7, [sp, #24]
   1058e:	ldr	r5, [sp, #28]
   10590:	rsb	r3, r3, #54	; 0x36
   10594:	b.w	fc7e <_dtoa_r+0x3e6>
   10598:	ldrd	r6, r7, [sp, #64]	; 0x40
   1059c:	mov.w	sl, #2
   105a0:	b.n	ff58 <_dtoa_r+0x6c0>
   105a2:	ldr	r3, [sp, #32]
   105a4:	cmp	r3, #0
   105a6:	beq.w	1032c <_dtoa_r+0xa94>
   105aa:	ldr	r3, [sp, #56]	; 0x38
   105ac:	cmp	r3, #0
   105ae:	ble.w	1040e <_dtoa_r+0xb76>
   105b2:	movs	r2, #0
   105b4:	ldr	r3, [pc, #148]	; (1064c <_dtoa_r+0xdb4>)
   105b6:	mov	r0, r6
   105b8:	mov	r1, r7
   105ba:	bl	a7bc <__aeabi_dmul>
   105be:	mov	r6, r0
   105c0:	mov	r7, r1
   105c2:	add.w	r0, sl, #1
   105c6:	bl	a6f0 <__aeabi_i2d>
   105ca:	mov	r2, r6
   105cc:	mov	r3, r7
   105ce:	bl	a7bc <__aeabi_dmul>
   105d2:	movs	r2, #0
   105d4:	ldr	r3, [pc, #100]	; (1063c <_dtoa_r+0xda4>)
   105d6:	bl	a458 <__adddf3>
   105da:	ldr	r2, [sp, #16]
   105dc:	ldr	r3, [sp, #56]	; 0x38
   105de:	str	r3, [sp, #72]	; 0x48
   105e0:	subs	r2, #1
   105e2:	mov	r4, r0
   105e4:	sub.w	r5, r1, #54525952	; 0x3400000
   105e8:	str	r2, [sp, #88]	; 0x58
   105ea:	b.n	ff9a <_dtoa_r+0x702>
   105ec:	str	r4, [sp, #40]	; 0x28
   105ee:	b.n	100fa <_dtoa_r+0x862>
   105f0:	movs	r2, #57	; 0x39
   105f2:	mov	fp, r6
   105f4:	str	r4, [sp, #40]	; 0x28
   105f6:	mov	r6, r8
   105f8:	strb	r2, [r7, #0]
   105fa:	adds	r5, r7, #1
   105fc:	b.w	fdea <_dtoa_r+0x552>
   10600:	ldrd	r2, r3, [sp, #80]	; 0x50
   10604:	movs	r0, #0
   10606:	ldr	r1, [pc, #72]	; (10650 <_dtoa_r+0xdb8>)
   10608:	bl	a454 <__aeabi_dsub>
   1060c:	mov	r2, r6
   1060e:	mov	r3, r7
   10610:	bl	acdc <__aeabi_dcmpgt>
   10614:	cbnz	r0, 1061a <_dtoa_r+0xd82>
   10616:	b.n	1040e <_dtoa_r+0xb76>
   10618:	mov	r5, r2
   1061a:	ldrb.w	r3, [r5, #-1]
   1061e:	cmp	r3, #48	; 0x30
   10620:	add.w	r2, r5, #4294967295
   10624:	beq.n	10618 <_dtoa_r+0xd80>
   10626:	b.n	1009c <_dtoa_r+0x804>
   10628:	ldr	r3, [sp, #88]	; 0x58
   1062a:	str	r3, [sp, #16]
   1062c:	b.w	fc12 <_dtoa_r+0x37a>
   10630:	cmp.w	sl, #0
   10634:	bne.w	10130 <_dtoa_r+0x898>
   10638:	b.n	10300 <_dtoa_r+0xa68>
   1063a:	nop
   1063c:	.word	0x401c0000
   10640:	.word	0x40140000
   10644:	.word	0x00013320
   10648:	.word	0x000133e8
   1064c:	.word	0x40240000
   10650:	.word	0x3fe00000
   10654:	cmp	r3, #57	; 0x39
   10656:	mov	fp, sl
   10658:	mov	sl, r3
   1065a:	beq.n	105f0 <_dtoa_r+0xd58>
   1065c:	cmp.w	fp, #0
   10660:	bgt.w	103de <_dtoa_r+0xb46>
   10664:	b.n	103e2 <_dtoa_r+0xb4a>
   10666:	bne.w	103e2 <_dtoa_r+0xb4a>
   1066a:	tst.w	sl, #1
   1066e:	beq.w	103e2 <_dtoa_r+0xb4a>
   10672:	b.n	103d6 <_dtoa_r+0xb3e>
   10674:	ldr	r3, [sp, #0]
   10676:	cmp	r3, #2
   10678:	bgt.n	106c6 <_dtoa_r+0xe2e>
   1067a:	ldr	r3, [sp, #56]	; 0x38
   1067c:	b.n	1029a <_dtoa_r+0xa02>
   1067e:	mov.w	sl, #2
   10682:	b.n	ff58 <_dtoa_r+0x6c0>
   10684:	ldr	r3, [sp, #0]
   10686:	cmp	r3, #2
   10688:	bgt.n	106c6 <_dtoa_r+0xe2e>
   1068a:	ldr	r3, [sp, #56]	; 0x38
   1068c:	b.n	1016a <_dtoa_r+0x8d2>
   1068e:	movs	r4, #0
   10690:	str.w	r4, [r9, #68]	; 0x44
   10694:	mov	r1, r4
   10696:	mov	r0, r9
   10698:	bl	11160 <_Balloc>
   1069c:	mov.w	r3, #4294967295
   106a0:	str	r3, [sp, #32]
   106a2:	str	r3, [sp, #56]	; 0x38
   106a4:	movs	r3, #1
   106a6:	str	r0, [sp, #36]	; 0x24
   106a8:	str	r4, [sp, #20]
   106aa:	str.w	r0, [r9, #64]	; 0x40
   106ae:	str	r3, [sp, #44]	; 0x2c
   106b0:	b.w	faac <_dtoa_r+0x214>
   106b4:	beq.w	fd48 <_dtoa_r+0x4b0>
   106b8:	rsb	r0, r0, #60	; 0x3c
   106bc:	b.w	fd3e <_dtoa_r+0x4a6>
   106c0:	movs	r6, #1
   106c2:	b.w	fa3e <_dtoa_r+0x1a6>
   106c6:	ldr	r3, [sp, #56]	; 0x38
   106c8:	str	r3, [sp, #32]
   106ca:	b.n	102aa <_dtoa_r+0xa12>

000106cc <__libc_fini_array>:
   106cc:	push	{r3, r4, r5, lr}
   106ce:	ldr	r5, [pc, #28]	; (106ec <__libc_fini_array+0x20>)
   106d0:	ldr	r4, [pc, #28]	; (106f0 <__libc_fini_array+0x24>)
   106d2:	subs	r4, r5, r4
   106d4:	asrs	r4, r4, #2
   106d6:	beq.n	106e4 <__libc_fini_array+0x18>
   106d8:	subs	r4, #1
   106da:	ldr.w	r3, [r5, #-4]!
   106de:	blx	r3
   106e0:	cmp	r4, #0
   106e2:	bne.n	106d8 <__libc_fini_array+0xc>
   106e4:	ldmia.w	sp!, {r3, r4, r5, lr}
   106e8:	b.w	13440 <__init_array_end>
	...

000106f4 <_malloc_trim_r>:
   106f4:	push	{r3, r4, r5, r6, r7, lr}
   106f6:	ldr	r7, [pc, #140]	; (10784 <_malloc_trim_r+0x90>)
   106f8:	mov	r4, r1
   106fa:	mov	r6, r0
   106fc:	bl	b9ac <__malloc_lock>
   10700:	ldr	r3, [r7, #8]
   10702:	ldr	r5, [r3, #4]
   10704:	bic.w	r5, r5, #3
   10708:	subs	r1, r5, r4
   1070a:	addw	r1, r1, #4079	; 0xfef
   1070e:	bic.w	r1, r1, #4080	; 0xff0
   10712:	bic.w	r1, r1, #15
   10716:	sub.w	r4, r1, #4096	; 0x1000
   1071a:	cmp.w	r4, #4096	; 0x1000
   1071e:	blt.n	10730 <_malloc_trim_r+0x3c>
   10720:	movs	r1, #0
   10722:	mov	r0, r6
   10724:	bl	bd94 <_sbrk_r>
   10728:	ldr	r3, [r7, #8]
   1072a:	add	r3, r5
   1072c:	cmp	r0, r3
   1072e:	beq.n	1073a <_malloc_trim_r+0x46>
   10730:	mov	r0, r6
   10732:	bl	b9b0 <__malloc_unlock>
   10736:	movs	r0, #0
   10738:	pop	{r3, r4, r5, r6, r7, pc}
   1073a:	negs	r1, r4
   1073c:	mov	r0, r6
   1073e:	bl	bd94 <_sbrk_r>
   10742:	adds	r0, #1
   10744:	beq.n	10762 <_malloc_trim_r+0x6e>
   10746:	ldr	r3, [pc, #64]	; (10788 <_malloc_trim_r+0x94>)
   10748:	ldr	r2, [r7, #8]
   1074a:	ldr	r1, [r3, #0]
   1074c:	subs	r5, r5, r4
   1074e:	orr.w	r5, r5, #1
   10752:	mov	r0, r6
   10754:	subs	r1, r1, r4
   10756:	str	r5, [r2, #4]
   10758:	str	r1, [r3, #0]
   1075a:	bl	b9b0 <__malloc_unlock>
   1075e:	movs	r0, #1
   10760:	pop	{r3, r4, r5, r6, r7, pc}
   10762:	movs	r1, #0
   10764:	mov	r0, r6
   10766:	bl	bd94 <_sbrk_r>
   1076a:	ldr	r2, [r7, #8]
   1076c:	subs	r3, r0, r2
   1076e:	cmp	r3, #15
   10770:	ble.n	10730 <_malloc_trim_r+0x3c>
   10772:	ldr	r4, [pc, #24]	; (1078c <_malloc_trim_r+0x98>)
   10774:	ldr	r1, [pc, #16]	; (10788 <_malloc_trim_r+0x94>)
   10776:	ldr	r4, [r4, #0]
   10778:	orr.w	r3, r3, #1
   1077c:	subs	r0, r0, r4
   1077e:	str	r3, [r2, #4]
   10780:	str	r0, [r1, #0]
   10782:	b.n	10730 <_malloc_trim_r+0x3c>
   10784:	.word	0x1fff19b8
   10788:	.word	0x2001d044
   1078c:	.word	0x1fff1dc4

00010790 <_free_r>:
   10790:	cmp	r1, #0
   10792:	beq.n	10820 <_free_r+0x90>
   10794:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10798:	mov	r5, r1
   1079a:	mov	r8, r0
   1079c:	bl	b9ac <__malloc_lock>
   107a0:	ldr.w	r7, [r5, #-4]
   107a4:	ldr	r1, [pc, #424]	; (10950 <_free_r+0x1c0>)
   107a6:	bic.w	r3, r7, #1
   107aa:	sub.w	r4, r5, #8
   107ae:	adds	r2, r4, r3
   107b0:	ldr	r6, [r1, #8]
   107b2:	ldr	r0, [r2, #4]
   107b4:	cmp	r2, r6
   107b6:	bic.w	r0, r0, #3
   107ba:	beq.n	10882 <_free_r+0xf2>
   107bc:	lsls	r6, r7, #31
   107be:	str	r0, [r2, #4]
   107c0:	bmi.n	107da <_free_r+0x4a>
   107c2:	ldr.w	r7, [r5, #-8]
   107c6:	subs	r4, r4, r7
   107c8:	add.w	lr, r1, #8
   107cc:	ldr	r5, [r4, #8]
   107ce:	cmp	r5, lr
   107d0:	add	r3, r7
   107d2:	beq.n	108b4 <_free_r+0x124>
   107d4:	ldr	r7, [r4, #12]
   107d6:	str	r7, [r5, #12]
   107d8:	str	r5, [r7, #8]
   107da:	adds	r5, r2, r0
   107dc:	ldr	r5, [r5, #4]
   107de:	lsls	r5, r5, #31
   107e0:	bpl.n	10868 <_free_r+0xd8>
   107e2:	orr.w	r2, r3, #1
   107e6:	str	r2, [r4, #4]
   107e8:	str	r3, [r4, r3]
   107ea:	cmp.w	r3, #512	; 0x200
   107ee:	bcs.n	10822 <_free_r+0x92>
   107f0:	lsrs	r3, r3, #3
   107f2:	adds	r2, r3, #1
   107f4:	ldr	r5, [r1, #4]
   107f6:	ldr.w	r7, [r1, r2, lsl #3]
   107fa:	str	r7, [r4, #8]
   107fc:	movs	r0, #1
   107fe:	asrs	r3, r3, #2
   10800:	lsl.w	r3, r0, r3
   10804:	add.w	r0, r1, r2, lsl #3
   10808:	orrs	r5, r3
   1080a:	subs	r0, #8
   1080c:	str	r0, [r4, #12]
   1080e:	str	r5, [r1, #4]
   10810:	str.w	r4, [r1, r2, lsl #3]
   10814:	str	r4, [r7, #12]
   10816:	mov	r0, r8
   10818:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1081c:	b.w	b9b0 <__malloc_unlock>
   10820:	bx	lr
   10822:	lsrs	r2, r3, #9
   10824:	cmp	r2, #4
   10826:	bhi.n	108d0 <_free_r+0x140>
   10828:	lsrs	r2, r3, #6
   1082a:	add.w	r7, r2, #57	; 0x39
   1082e:	lsls	r7, r7, #1
   10830:	add.w	r5, r2, #56	; 0x38
   10834:	add.w	r0, r1, r7, lsl #2
   10838:	ldr.w	r2, [r1, r7, lsl #2]
   1083c:	ldr	r1, [pc, #272]	; (10950 <_free_r+0x1c0>)
   1083e:	subs	r0, #8
   10840:	cmp	r0, r2
   10842:	beq.n	108e0 <_free_r+0x150>
   10844:	ldr	r1, [r2, #4]
   10846:	bic.w	r1, r1, #3
   1084a:	cmp	r3, r1
   1084c:	bcs.n	10854 <_free_r+0xc4>
   1084e:	ldr	r2, [r2, #8]
   10850:	cmp	r0, r2
   10852:	bne.n	10844 <_free_r+0xb4>
   10854:	ldr	r0, [r2, #12]
   10856:	str	r0, [r4, #12]
   10858:	str	r2, [r4, #8]
   1085a:	str	r4, [r0, #8]
   1085c:	str	r4, [r2, #12]
   1085e:	mov	r0, r8
   10860:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   10864:	b.w	b9b0 <__malloc_unlock>
   10868:	ldr	r5, [r2, #8]
   1086a:	ldr	r7, [pc, #232]	; (10954 <_free_r+0x1c4>)
   1086c:	cmp	r5, r7
   1086e:	add	r3, r0
   10870:	beq.n	108f2 <_free_r+0x162>
   10872:	ldr	r0, [r2, #12]
   10874:	str	r0, [r5, #12]
   10876:	orr.w	r2, r3, #1
   1087a:	str	r5, [r0, #8]
   1087c:	str	r2, [r4, #4]
   1087e:	str	r3, [r4, r3]
   10880:	b.n	107ea <_free_r+0x5a>
   10882:	lsls	r7, r7, #31
   10884:	add	r3, r0
   10886:	bmi.n	10898 <_free_r+0x108>
   10888:	ldr.w	r2, [r5, #-8]
   1088c:	subs	r4, r4, r2
   1088e:	add	r3, r2
   10890:	ldr	r0, [r4, #8]
   10892:	ldr	r2, [r4, #12]
   10894:	str	r2, [r0, #12]
   10896:	str	r0, [r2, #8]
   10898:	ldr	r2, [pc, #188]	; (10958 <_free_r+0x1c8>)
   1089a:	ldr	r2, [r2, #0]
   1089c:	orr.w	r0, r3, #1
   108a0:	cmp	r3, r2
   108a2:	str	r0, [r4, #4]
   108a4:	str	r4, [r1, #8]
   108a6:	bcc.n	10816 <_free_r+0x86>
   108a8:	ldr	r3, [pc, #176]	; (1095c <_free_r+0x1cc>)
   108aa:	mov	r0, r8
   108ac:	ldr	r1, [r3, #0]
   108ae:	bl	106f4 <_malloc_trim_r>
   108b2:	b.n	10816 <_free_r+0x86>
   108b4:	adds	r1, r2, r0
   108b6:	ldr	r1, [r1, #4]
   108b8:	lsls	r1, r1, #31
   108ba:	bmi.n	10946 <_free_r+0x1b6>
   108bc:	ldr	r1, [r2, #8]
   108be:	ldr	r2, [r2, #12]
   108c0:	str	r2, [r1, #12]
   108c2:	add	r3, r0
   108c4:	orr.w	r0, r3, #1
   108c8:	str	r1, [r2, #8]
   108ca:	str	r0, [r4, #4]
   108cc:	str	r3, [r4, r3]
   108ce:	b.n	10816 <_free_r+0x86>
   108d0:	cmp	r2, #20
   108d2:	bhi.n	10904 <_free_r+0x174>
   108d4:	add.w	r7, r2, #92	; 0x5c
   108d8:	lsls	r7, r7, #1
   108da:	add.w	r5, r2, #91	; 0x5b
   108de:	b.n	10834 <_free_r+0xa4>
   108e0:	asrs	r2, r5, #2
   108e2:	ldr	r3, [r1, #4]
   108e4:	movs	r5, #1
   108e6:	lsl.w	r2, r5, r2
   108ea:	orrs	r3, r2
   108ec:	str	r3, [r1, #4]
   108ee:	mov	r2, r0
   108f0:	b.n	10856 <_free_r+0xc6>
   108f2:	orr.w	r2, r3, #1
   108f6:	str	r4, [r1, #20]
   108f8:	str	r4, [r1, #16]
   108fa:	str	r5, [r4, #12]
   108fc:	str	r5, [r4, #8]
   108fe:	str	r2, [r4, #4]
   10900:	str	r3, [r4, r3]
   10902:	b.n	10816 <_free_r+0x86>
   10904:	cmp	r2, #84	; 0x54
   10906:	bhi.n	10916 <_free_r+0x186>
   10908:	lsrs	r2, r3, #12
   1090a:	add.w	r7, r2, #111	; 0x6f
   1090e:	lsls	r7, r7, #1
   10910:	add.w	r5, r2, #110	; 0x6e
   10914:	b.n	10834 <_free_r+0xa4>
   10916:	cmp.w	r2, #340	; 0x154
   1091a:	bhi.n	1092a <_free_r+0x19a>
   1091c:	lsrs	r2, r3, #15
   1091e:	add.w	r7, r2, #120	; 0x78
   10922:	lsls	r7, r7, #1
   10924:	add.w	r5, r2, #119	; 0x77
   10928:	b.n	10834 <_free_r+0xa4>
   1092a:	movw	r0, #1364	; 0x554
   1092e:	cmp	r2, r0
   10930:	bhi.n	10940 <_free_r+0x1b0>
   10932:	lsrs	r2, r3, #18
   10934:	add.w	r7, r2, #125	; 0x7d
   10938:	lsls	r7, r7, #1
   1093a:	add.w	r5, r2, #124	; 0x7c
   1093e:	b.n	10834 <_free_r+0xa4>
   10940:	movs	r7, #254	; 0xfe
   10942:	movs	r5, #126	; 0x7e
   10944:	b.n	10834 <_free_r+0xa4>
   10946:	orr.w	r2, r3, #1
   1094a:	str	r2, [r4, #4]
   1094c:	str	r3, [r4, r3]
   1094e:	b.n	10816 <_free_r+0x86>
   10950:	.word	0x1fff19b8
   10954:	.word	0x1fff19c0
   10958:	.word	0x1fff1dc0
   1095c:	.word	0x2001d040

00010960 <rshift>:
   10960:	ldr	r2, [r0, #16]
   10962:	asrs	r3, r1, #5
   10964:	cmp	r3, r2
   10966:	bge.n	109c6 <rshift+0x66>
   10968:	push	{r4, r5, r6, r7, lr}
   1096a:	ands.w	r1, r1, #31
   1096e:	add.w	r6, r0, #20
   10972:	add.w	r2, r6, r2, lsl #2
   10976:	add.w	lr, r6, r3, lsl #2
   1097a:	beq.n	109d0 <rshift+0x70>
   1097c:	ldr.w	r3, [r6, r3, lsl #2]
   10980:	add.w	r5, lr, #4
   10984:	cmp	r2, r5
   10986:	lsr.w	r4, r3, r1
   1098a:	rsb	ip, r1, #32
   1098e:	bls.n	10a04 <rshift+0xa4>
   10990:	add.w	r7, r0, #16
   10994:	ldr	r3, [r5, #0]
   10996:	lsl.w	r3, r3, ip
   1099a:	orrs	r3, r4
   1099c:	str.w	r3, [r7, #4]!
   109a0:	ldr.w	r3, [r5], #4
   109a4:	cmp	r2, r5
   109a6:	lsr.w	r4, r3, r1
   109aa:	bhi.n	10994 <rshift+0x34>
   109ac:	rsb	r2, lr, r2
   109b0:	subs	r2, #5
   109b2:	bic.w	r2, r2, #3
   109b6:	adds	r2, #4
   109b8:	add	r2, r6
   109ba:	str	r4, [r2, #0]
   109bc:	cbz	r4, 109c0 <rshift+0x60>
   109be:	adds	r2, #4
   109c0:	subs	r3, r2, r6
   109c2:	asrs	r3, r3, #2
   109c4:	b.n	109f4 <rshift+0x94>
   109c6:	movs	r3, #0
   109c8:	str	r3, [r0, #16]
   109ca:	movs	r3, #0
   109cc:	str	r3, [r0, #20]
   109ce:	bx	lr
   109d0:	cmp	r2, lr
   109d2:	bls.n	109fa <rshift+0x9a>
   109d4:	add.w	r4, r0, #16
   109d8:	mov	r1, lr
   109da:	ldr.w	r5, [r1], #4
   109de:	str.w	r5, [r4, #4]!
   109e2:	cmp	r2, r1
   109e4:	bhi.n	109da <rshift+0x7a>
   109e6:	mvn.w	r3, lr
   109ea:	add	r3, r2
   109ec:	bic.w	r3, r3, #3
   109f0:	adds	r3, #4
   109f2:	asrs	r3, r3, #2
   109f4:	str	r3, [r0, #16]
   109f6:	cbz	r3, 109fe <rshift+0x9e>
   109f8:	pop	{r4, r5, r6, r7, pc}
   109fa:	movs	r3, #0
   109fc:	str	r3, [r0, #16]
   109fe:	movs	r3, #0
   10a00:	str	r3, [r0, #20]
   10a02:	pop	{r4, r5, r6, r7, pc}
   10a04:	mov	r2, r6
   10a06:	b.n	109ba <rshift+0x5a>

00010a08 <__gethex>:
   10a08:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10a0c:	sub	sp, #44	; 0x2c
   10a0e:	mov	r9, r1
   10a10:	str	r0, [sp, #20]
   10a12:	ldr	r0, [sp, #88]	; 0x58
   10a14:	str	r2, [sp, #12]
   10a16:	str	r3, [sp, #32]
   10a18:	bl	110e4 <__localeconv_l>
   10a1c:	ldr	r3, [r0, #0]
   10a1e:	str	r3, [sp, #8]
   10a20:	mov	r0, r3
   10a22:	mov	r4, r3
   10a24:	bl	be80 <strlen>
   10a28:	ldr.w	r3, [r9]
   10a2c:	str	r0, [sp, #0]
   10a2e:	ldrb	r2, [r3, #2]
   10a30:	adds	r1, r4, r0
   10a32:	cmp	r2, #48	; 0x30
   10a34:	ldrb.w	fp, [r1, #-1]
   10a38:	bne.w	10d8e <__gethex+0x386>
   10a3c:	adds	r3, #3
   10a3e:	mov.w	r8, #0
   10a42:	mov	r4, r3
   10a44:	ldrb.w	r2, [r3], #1
   10a48:	cmp	r2, #48	; 0x30
   10a4a:	add.w	r8, r8, #1
   10a4e:	beq.n	10a42 <__gethex+0x3a>
   10a50:	ldr	r6, [pc, #712]	; (10d1c <__gethex+0x314>)
   10a52:	ldrb	r3, [r6, r2]
   10a54:	cmp	r3, #0
   10a56:	beq.w	10c3a <__gethex+0x232>
   10a5a:	ldrb	r3, [r4, #0]
   10a5c:	mov.w	sl, #0
   10a60:	ldrb	r3, [r6, r3]
   10a62:	mov	r5, sl
   10a64:	mov	r7, r4
   10a66:	cbz	r3, 10a72 <__gethex+0x6a>
   10a68:	ldrb.w	r3, [r7, #1]!
   10a6c:	ldrb	r3, [r6, r3]
   10a6e:	cmp	r3, #0
   10a70:	bne.n	10a68 <__gethex+0x60>
   10a72:	ldr	r2, [sp, #0]
   10a74:	ldr	r1, [sp, #8]
   10a76:	mov	r0, r7
   10a78:	bl	bf5c <strncmp>
   10a7c:	cmp	r0, #0
   10a7e:	beq.w	10ba6 <__gethex+0x19e>
   10a82:	ldrb	r3, [r7, #0]
   10a84:	cmp	r5, #0
   10a86:	beq.w	10d6c <__gethex+0x364>
   10a8a:	subs	r5, r5, r7
   10a8c:	lsls	r2, r5, #2
   10a8e:	str	r2, [sp, #4]
   10a90:	cmp	r3, #80	; 0x50
   10a92:	beq.w	10bb8 <__gethex+0x1b0>
   10a96:	cmp	r3, #112	; 0x70
   10a98:	beq.w	10bb8 <__gethex+0x1b0>
   10a9c:	mov	r5, r7
   10a9e:	str.w	r7, [r9]
   10aa2:	cmp.w	sl, #0
   10aa6:	bne.w	10c18 <__gethex+0x210>
   10aaa:	subs	r3, r5, r4
   10aac:	subs	r3, #1
   10aae:	cmp	r3, #7
   10ab0:	mov	r1, sl
   10ab2:	ble.n	10abe <__gethex+0xb6>
   10ab4:	asrs	r3, r3, #1
   10ab6:	cmp	r3, #7
   10ab8:	add.w	r1, r1, #1
   10abc:	bgt.n	10ab4 <__gethex+0xac>
   10abe:	ldr	r0, [sp, #20]
   10ac0:	bl	11160 <_Balloc>
   10ac4:	mov	r3, r0
   10ac6:	adds	r3, #20
   10ac8:	cmp	r5, r4
   10aca:	str	r0, [sp, #16]
   10acc:	str	r3, [sp, #28]
   10ace:	bls.w	10e78 <__gethex+0x470>
   10ad2:	mov	r9, r3
   10ad4:	ldr	r3, [sp, #0]
   10ad6:	mov.w	r8, #0
   10ada:	rsb	r3, r3, #1
   10ade:	mov	r7, r8
   10ae0:	str	r3, [sp, #24]
   10ae2:	b.n	10b04 <__gethex+0xfc>
   10ae4:	cmp	r7, #32
   10ae6:	beq.w	10c28 <__gethex+0x220>
   10aea:	mov	r2, r7
   10aec:	adds	r7, #4
   10aee:	ldrb.w	r3, [r5, #-1]
   10af2:	ldrb	r3, [r6, r3]
   10af4:	mov	r5, sl
   10af6:	and.w	r3, r3, #15
   10afa:	lsls	r3, r2
   10afc:	cmp	r5, r4
   10afe:	orr.w	r8, r8, r3
   10b02:	bls.n	10b30 <__gethex+0x128>
   10b04:	ldrb.w	r3, [r5, #-1]
   10b08:	cmp	r3, fp
   10b0a:	add.w	sl, r5, #4294967295
   10b0e:	bne.n	10ae4 <__gethex+0xdc>
   10b10:	ldr	r3, [sp, #24]
   10b12:	add	r3, sl
   10b14:	cmp	r3, r4
   10b16:	bcc.n	10ae4 <__gethex+0xdc>
   10b18:	mov	r0, r3
   10b1a:	ldr	r2, [sp, #0]
   10b1c:	ldr	r1, [sp, #8]
   10b1e:	str	r3, [sp, #36]	; 0x24
   10b20:	bl	bf5c <strncmp>
   10b24:	ldr	r3, [sp, #36]	; 0x24
   10b26:	cmp	r0, #0
   10b28:	bne.n	10ae4 <__gethex+0xdc>
   10b2a:	mov	r5, r3
   10b2c:	cmp	r5, r4
   10b2e:	bhi.n	10b04 <__gethex+0xfc>
   10b30:	str.w	r8, [r9], #4
   10b34:	ldr	r3, [sp, #28]
   10b36:	ldr	r2, [sp, #16]
   10b38:	rsb	r9, r3, r9
   10b3c:	mov.w	r3, r9, asr #2
   10b40:	str	r3, [r2, #16]
   10b42:	mov	r0, r8
   10b44:	mov.w	r9, r3, lsl #5
   10b48:	bl	112d8 <__hi0bits>
   10b4c:	ldr	r3, [sp, #12]
   10b4e:	ldr	r6, [r3, #0]
   10b50:	rsb	r0, r0, r9
   10b54:	cmp	r0, r6
   10b56:	bgt.w	10d20 <__gethex+0x318>
   10b5a:	blt.w	10d70 <__gethex+0x368>
   10b5e:	movs	r7, #0
   10b60:	ldr	r3, [sp, #12]
   10b62:	ldr	r2, [sp, #4]
   10b64:	ldr	r3, [r3, #8]
   10b66:	cmp	r2, r3
   10b68:	bgt.w	10c9a <__gethex+0x292>
   10b6c:	ldr	r0, [sp, #12]
   10b6e:	ldr	r1, [sp, #4]
   10b70:	ldr	r3, [r0, #4]
   10b72:	cmp	r1, r3
   10b74:	bge.w	10ce2 <__gethex+0x2da>
   10b78:	subs	r5, r3, r1
   10b7a:	cmp	r6, r5
   10b7c:	bgt.w	10d9e <__gethex+0x396>
   10b80:	ldr	r2, [r0, #12]
   10b82:	cmp	r2, #2
   10b84:	beq.w	10e86 <__gethex+0x47e>
   10b88:	cmp	r2, #3
   10b8a:	beq.w	10e46 <__gethex+0x43e>
   10b8e:	cmp	r2, #1
   10b90:	beq.w	10e8e <__gethex+0x486>
   10b94:	ldr	r0, [sp, #20]
   10b96:	ldr	r1, [sp, #16]
   10b98:	bl	111ac <_Bfree>
   10b9c:	ldr	r2, [sp, #80]	; 0x50
   10b9e:	movs	r3, #0
   10ba0:	str	r3, [r2, #0]
   10ba2:	movs	r0, #80	; 0x50
   10ba4:	b.n	10c22 <__gethex+0x21a>
   10ba6:	cmp	r5, #0
   10ba8:	beq.w	10dde <__gethex+0x3d6>
   10bac:	ldrb	r3, [r7, #0]
   10bae:	b.n	10a8a <__gethex+0x82>
   10bb0:	movs	r3, #0
   10bb2:	str	r3, [sp, #4]
   10bb4:	mov.w	sl, #1
   10bb8:	ldrb	r3, [r7, #1]
   10bba:	cmp	r3, #43	; 0x2b
   10bbc:	beq.w	10d18 <__gethex+0x310>
   10bc0:	cmp	r3, #45	; 0x2d
   10bc2:	beq.n	10cb0 <__gethex+0x2a8>
   10bc4:	adds	r1, r7, #1
   10bc6:	movs	r5, #0
   10bc8:	ldrb	r3, [r6, r3]
   10bca:	ldr	r0, [pc, #336]	; (10d1c <__gethex+0x314>)
   10bcc:	subs	r2, r3, #1
   10bce:	cmp	r2, #24
   10bd0:	bhi.w	10a9c <__gethex+0x94>
   10bd4:	ldrb	r2, [r1, #1]
   10bd6:	ldrb	r2, [r0, r2]
   10bd8:	subs	r0, r2, #1
   10bda:	cmp	r0, #24
   10bdc:	sub.w	r3, r3, #16
   10be0:	add.w	r1, r1, #1
   10be4:	bhi.n	10bfe <__gethex+0x1f6>
   10be6:	ldrb.w	r0, [r1, #1]!
   10bea:	add.w	r3, r3, r3, lsl #2
   10bee:	add.w	r3, r2, r3, lsl #1
   10bf2:	ldrb	r2, [r6, r0]
   10bf4:	subs	r0, r2, #1
   10bf6:	cmp	r0, #24
   10bf8:	sub.w	r3, r3, #16
   10bfc:	bls.n	10be6 <__gethex+0x1de>
   10bfe:	cbz	r5, 10c02 <__gethex+0x1fa>
   10c00:	negs	r3, r3
   10c02:	ldr	r2, [sp, #4]
   10c04:	mov	r5, r7
   10c06:	add	r2, r3
   10c08:	mov	r7, r1
   10c0a:	str	r2, [sp, #4]
   10c0c:	str.w	r7, [r9]
   10c10:	cmp.w	sl, #0
   10c14:	beq.w	10aaa <__gethex+0xa2>
   10c18:	cmp.w	r8, #0
   10c1c:	ite	eq
   10c1e:	moveq	r0, #6
   10c20:	movne	r0, #0
   10c22:	add	sp, #44	; 0x2c
   10c24:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10c28:	str.w	r8, [r9]
   10c2c:	mov.w	r8, #0
   10c30:	add.w	r9, r9, #4
   10c34:	mov	r2, r8
   10c36:	movs	r7, #4
   10c38:	b.n	10aee <__gethex+0xe6>
   10c3a:	ldr	r5, [sp, #0]
   10c3c:	ldr	r1, [sp, #8]
   10c3e:	mov	r2, r5
   10c40:	mov	r0, r4
   10c42:	bl	bf5c <strncmp>
   10c46:	cmp	r0, #0
   10c48:	beq.n	10cb8 <__gethex+0x2b0>
   10c4a:	ldrb	r3, [r4, #0]
   10c4c:	mov	r7, r4
   10c4e:	cmp	r3, #80	; 0x50
   10c50:	beq.n	10bb0 <__gethex+0x1a8>
   10c52:	cmp	r3, #112	; 0x70
   10c54:	beq.n	10bb0 <__gethex+0x1a8>
   10c56:	str.w	r7, [r9]
   10c5a:	b.n	10c18 <__gethex+0x210>
   10c5c:	ldr	r3, [sp, #16]
   10c5e:	ldr	r3, [r3, #8]
   10c60:	cmp	r7, r3
   10c62:	bge.w	10ece <__gethex+0x4c6>
   10c66:	mov	r3, r7
   10c68:	ldr	r0, [sp, #16]
   10c6a:	add.w	r2, r0, r3, lsl #2
   10c6e:	movs	r1, #1
   10c70:	adds	r3, #1
   10c72:	cmp	r4, #2
   10c74:	str	r3, [r0, #16]
   10c76:	str	r1, [r2, #20]
   10c78:	beq.w	10eac <__gethex+0x4a4>
   10c7c:	cmp	r7, r3
   10c7e:	bge.w	10e38 <__gethex+0x430>
   10c82:	movs	r1, #1
   10c84:	ldr	r0, [sp, #16]
   10c86:	bl	10960 <rshift>
   10c8a:	ldr	r3, [sp, #12]
   10c8c:	ldr	r2, [sp, #4]
   10c8e:	ldr	r3, [r3, #8]
   10c90:	adds	r2, #1
   10c92:	cmp	r2, r3
   10c94:	str	r2, [sp, #4]
   10c96:	ble.w	10e3e <__gethex+0x436>
   10c9a:	ldr	r0, [sp, #20]
   10c9c:	ldr	r1, [sp, #16]
   10c9e:	bl	111ac <_Bfree>
   10ca2:	ldr	r2, [sp, #80]	; 0x50
   10ca4:	movs	r3, #0
   10ca6:	movs	r0, #163	; 0xa3
   10ca8:	str	r3, [r2, #0]
   10caa:	add	sp, #44	; 0x2c
   10cac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10cb0:	movs	r5, #1
   10cb2:	ldrb	r3, [r7, #2]
   10cb4:	adds	r1, r7, #2
   10cb6:	b.n	10bc8 <__gethex+0x1c0>
   10cb8:	ldrb	r2, [r4, r5]
   10cba:	ldrb	r3, [r6, r2]
   10cbc:	adds	r7, r4, r5
   10cbe:	cmp	r3, #0
   10cc0:	beq.n	10d96 <__gethex+0x38e>
   10cc2:	cmp	r2, #48	; 0x30
   10cc4:	mov	r4, r7
   10cc6:	bne.n	10cd2 <__gethex+0x2ca>
   10cc8:	ldrb.w	r3, [r4, #1]!
   10ccc:	cmp	r3, #48	; 0x30
   10cce:	beq.n	10cc8 <__gethex+0x2c0>
   10cd0:	ldrb	r3, [r6, r3]
   10cd2:	clz	sl, r3
   10cd6:	mov	r5, r7
   10cd8:	mov.w	sl, sl, lsr #5
   10cdc:	mov.w	r8, #1
   10ce0:	b.n	10a64 <__gethex+0x5c>
   10ce2:	movs	r4, #1
   10ce4:	cbz	r7, 10d00 <__gethex+0x2f8>
   10ce6:	ldr	r3, [sp, #12]
   10ce8:	ldr	r3, [r3, #12]
   10cea:	cmp	r3, #2
   10cec:	beq.w	10dfa <__gethex+0x3f2>
   10cf0:	cmp	r3, #3
   10cf2:	beq.w	10e02 <__gethex+0x3fa>
   10cf6:	cmp	r3, #1
   10cf8:	beq.w	10e66 <__gethex+0x45e>
   10cfc:	orr.w	r4, r4, #16
   10d00:	ldr	r3, [sp, #80]	; 0x50
   10d02:	mov	r2, r3
   10d04:	ldr	r3, [sp, #16]
   10d06:	str	r3, [r2, #0]
   10d08:	ldr	r3, [sp, #32]
   10d0a:	mov	r2, r3
   10d0c:	ldr	r3, [sp, #4]
   10d0e:	str	r3, [r2, #0]
   10d10:	mov	r0, r4
   10d12:	add	sp, #44	; 0x2c
   10d14:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10d18:	movs	r5, #0
   10d1a:	b.n	10cb2 <__gethex+0x2aa>
   10d1c:	.word	0x0001321c
   10d20:	subs	r4, r0, r6
   10d22:	mov	r1, r4
   10d24:	ldr	r0, [sp, #16]
   10d26:	bl	119e8 <__any_on>
   10d2a:	cmp	r0, #0
   10d2c:	beq.n	10d9a <__gethex+0x392>
   10d2e:	subs	r2, r4, #1
   10d30:	asrs	r1, r2, #5
   10d32:	ldr	r0, [sp, #28]
   10d34:	and.w	r3, r2, #31
   10d38:	ldr.w	r1, [r0, r1, lsl #2]
   10d3c:	movs	r7, #1
   10d3e:	lsl.w	r3, r7, r3
   10d42:	tst	r3, r1
   10d44:	beq.n	10d5c <__gethex+0x354>
   10d46:	cmp	r2, r7
   10d48:	ble.w	10e82 <__gethex+0x47a>
   10d4c:	subs	r1, r4, #2
   10d4e:	ldr	r0, [sp, #16]
   10d50:	bl	119e8 <__any_on>
   10d54:	cmp	r0, #0
   10d56:	beq.w	10e82 <__gethex+0x47a>
   10d5a:	movs	r7, #3
   10d5c:	ldr	r3, [sp, #4]
   10d5e:	ldr	r0, [sp, #16]
   10d60:	add	r3, r4
   10d62:	mov	r1, r4
   10d64:	str	r3, [sp, #4]
   10d66:	bl	10960 <rshift>
   10d6a:	b.n	10b60 <__gethex+0x158>
   10d6c:	str	r5, [sp, #4]
   10d6e:	b.n	10a90 <__gethex+0x88>
   10d70:	subs	r4, r6, r0
   10d72:	ldr	r1, [sp, #16]
   10d74:	ldr	r0, [sp, #20]
   10d76:	mov	r2, r4
   10d78:	bl	11558 <__lshift>
   10d7c:	ldr	r3, [sp, #4]
   10d7e:	str	r0, [sp, #16]
   10d80:	subs	r3, r3, r4
   10d82:	str	r3, [sp, #4]
   10d84:	mov	r3, r0
   10d86:	adds	r3, #20
   10d88:	str	r3, [sp, #28]
   10d8a:	movs	r7, #0
   10d8c:	b.n	10b60 <__gethex+0x158>
   10d8e:	adds	r4, r3, #2
   10d90:	mov.w	r8, #0
   10d94:	b.n	10a50 <__gethex+0x48>
   10d96:	mov	r3, r2
   10d98:	b.n	10c4e <__gethex+0x246>
   10d9a:	mov	r7, r0
   10d9c:	b.n	10d5c <__gethex+0x354>
   10d9e:	subs	r4, r5, #1
   10da0:	cmp	r7, #0
   10da2:	bne.n	10e42 <__gethex+0x43a>
   10da4:	cbz	r4, 10db0 <__gethex+0x3a8>
   10da6:	mov	r1, r4
   10da8:	ldr	r0, [sp, #16]
   10daa:	bl	119e8 <__any_on>
   10dae:	mov	r7, r0
   10db0:	asrs	r3, r4, #5
   10db2:	ldr	r2, [sp, #28]
   10db4:	ldr	r0, [sp, #16]
   10db6:	ldr.w	r2, [r2, r3, lsl #2]
   10dba:	and.w	r4, r4, #31
   10dbe:	movs	r3, #1
   10dc0:	lsl.w	r4, r3, r4
   10dc4:	tst	r4, r2
   10dc6:	mov	r1, r5
   10dc8:	it	ne
   10dca:	orrne.w	r7, r7, #2
   10dce:	bl	10960 <rshift>
   10dd2:	ldr	r3, [sp, #12]
   10dd4:	ldr	r3, [r3, #4]
   10dd6:	str	r3, [sp, #4]
   10dd8:	subs	r6, r6, r5
   10dda:	movs	r4, #2
   10ddc:	b.n	10ce4 <__gethex+0x2dc>
   10dde:	ldr	r1, [sp, #0]
   10de0:	ldrb	r3, [r7, r1]
   10de2:	ldrb	r2, [r6, r3]
   10de4:	adds	r5, r7, r1
   10de6:	mov	r7, r5
   10de8:	cmp	r2, #0
   10dea:	beq.w	10a8a <__gethex+0x82>
   10dee:	ldrb.w	r3, [r7, #1]!
   10df2:	ldrb	r2, [r6, r3]
   10df4:	cmp	r2, #0
   10df6:	bne.n	10dee <__gethex+0x3e6>
   10df8:	b.n	10a8a <__gethex+0x82>
   10dfa:	ldr	r3, [sp, #84]	; 0x54
   10dfc:	rsb	r3, r3, #1
   10e00:	str	r3, [sp, #84]	; 0x54
   10e02:	ldr	r3, [sp, #84]	; 0x54
   10e04:	cmp	r3, #0
   10e06:	beq.w	10cfc <__gethex+0x2f4>
   10e0a:	ldr	r3, [sp, #16]
   10e0c:	ldr	r5, [sp, #28]
   10e0e:	ldr	r7, [r3, #16]
   10e10:	mov.w	r8, r7, lsl #2
   10e14:	add.w	r0, r5, r8
   10e18:	mov	r3, r5
   10e1a:	movs	r1, #0
   10e1c:	b.n	10e28 <__gethex+0x420>
   10e1e:	str.w	r1, [r3], #4
   10e22:	cmp	r0, r3
   10e24:	bls.w	10c5c <__gethex+0x254>
   10e28:	ldr	r2, [r3, #0]
   10e2a:	cmp.w	r2, #4294967295
   10e2e:	beq.n	10e1e <__gethex+0x416>
   10e30:	adds	r2, #1
   10e32:	cmp	r4, #2
   10e34:	str	r2, [r3, #0]
   10e36:	beq.n	10eac <__gethex+0x4a4>
   10e38:	ands.w	r6, r6, #31
   10e3c:	bne.n	10eba <__gethex+0x4b2>
   10e3e:	movs	r4, #33	; 0x21
   10e40:	b.n	10d00 <__gethex+0x2f8>
   10e42:	movs	r7, #1
   10e44:	b.n	10db0 <__gethex+0x3a8>
   10e46:	ldr	r2, [sp, #84]	; 0x54
   10e48:	cmp	r2, #0
   10e4a:	beq.w	10b94 <__gethex+0x18c>
   10e4e:	ldr	r1, [sp, #32]
   10e50:	str	r3, [r1, #0]
   10e52:	ldr	r3, [sp, #28]
   10e54:	ldr	r1, [sp, #16]
   10e56:	movs	r2, #1
   10e58:	str	r2, [r1, #16]
   10e5a:	str	r2, [r3, #0]
   10e5c:	ldr	r3, [sp, #80]	; 0x50
   10e5e:	mov	r2, r3
   10e60:	movs	r0, #98	; 0x62
   10e62:	str	r1, [r2, #0]
   10e64:	b.n	10c22 <__gethex+0x21a>
   10e66:	lsls	r2, r7, #30
   10e68:	bpl.w	10cfc <__gethex+0x2f4>
   10e6c:	ldr	r3, [sp, #28]
   10e6e:	ldr	r3, [r3, #0]
   10e70:	orrs	r3, r7
   10e72:	lsls	r3, r3, #31
   10e74:	bmi.n	10e0a <__gethex+0x402>
   10e76:	b.n	10cfc <__gethex+0x2f4>
   10e78:	ldr.w	r9, [sp, #28]
   10e7c:	mov.w	r8, #0
   10e80:	b.n	10b30 <__gethex+0x128>
   10e82:	movs	r7, #2
   10e84:	b.n	10d5c <__gethex+0x354>
   10e86:	ldr	r2, [sp, #84]	; 0x54
   10e88:	cmp	r2, #0
   10e8a:	beq.n	10e4e <__gethex+0x446>
   10e8c:	b.n	10b94 <__gethex+0x18c>
   10e8e:	cmp	r6, r5
   10e90:	bne.w	10b94 <__gethex+0x18c>
   10e94:	cmp	r6, #1
   10e96:	ble.n	10e4e <__gethex+0x446>
   10e98:	subs	r1, r6, #1
   10e9a:	ldr	r0, [sp, #16]
   10e9c:	bl	119e8 <__any_on>
   10ea0:	cmp	r0, #0
   10ea2:	beq.w	10b94 <__gethex+0x18c>
   10ea6:	ldr	r3, [sp, #12]
   10ea8:	ldr	r3, [r3, #4]
   10eaa:	b.n	10e4e <__gethex+0x446>
   10eac:	ldr	r3, [sp, #12]
   10eae:	ldr	r3, [r3, #0]
   10eb0:	subs	r3, #1
   10eb2:	cmp	r6, r3
   10eb4:	beq.n	10f00 <__gethex+0x4f8>
   10eb6:	movs	r4, #34	; 0x22
   10eb8:	b.n	10d00 <__gethex+0x2f8>
   10eba:	add	r5, r8
   10ebc:	rsb	r6, r6, #32
   10ec0:	ldr.w	r0, [r5, #-4]
   10ec4:	bl	112d8 <__hi0bits>
   10ec8:	cmp	r0, r6
   10eca:	bge.n	10e3e <__gethex+0x436>
   10ecc:	b.n	10c82 <__gethex+0x27a>
   10ece:	ldr	r3, [sp, #16]
   10ed0:	ldr.w	r9, [sp, #20]
   10ed4:	ldr	r1, [r3, #4]
   10ed6:	mov	r0, r9
   10ed8:	adds	r1, #1
   10eda:	bl	11160 <_Balloc>
   10ede:	ldr	r1, [sp, #16]
   10ee0:	ldr	r3, [r1, #16]
   10ee2:	adds	r2, r3, #2
   10ee4:	mov	r5, r0
   10ee6:	lsls	r2, r2, #2
   10ee8:	adds	r1, #12
   10eea:	adds	r0, #12
   10eec:	bl	8e18 <memcpy>
   10ef0:	ldr	r1, [sp, #16]
   10ef2:	mov	r0, r9
   10ef4:	bl	111ac <_Bfree>
   10ef8:	str	r5, [sp, #16]
   10efa:	ldr	r3, [r5, #16]
   10efc:	adds	r5, #20
   10efe:	b.n	10c68 <__gethex+0x260>
   10f00:	asrs	r3, r6, #5
   10f02:	and.w	r6, r6, #31
   10f06:	ldr.w	r2, [r5, r3, lsl #2]
   10f0a:	movs	r3, #1
   10f0c:	lsls	r3, r6
   10f0e:	tst	r3, r2
   10f10:	ite	ne
   10f12:	movne	r4, #33	; 0x21
   10f14:	moveq	r4, #34	; 0x22
   10f16:	b.n	10d00 <__gethex+0x2f8>

00010f18 <__match>:
   10f18:	push	{r4, r5}
   10f1a:	ldr	r4, [r0, #0]
   10f1c:	b.n	10f30 <__match+0x18>
   10f1e:	ldrb.w	r3, [r4, #1]!
   10f22:	sub.w	r5, r3, #65	; 0x41
   10f26:	cmp	r5, #25
   10f28:	it	ls
   10f2a:	addls	r3, #32
   10f2c:	cmp	r3, r2
   10f2e:	bne.n	10f42 <__match+0x2a>
   10f30:	ldrb.w	r2, [r1], #1
   10f34:	cmp	r2, #0
   10f36:	bne.n	10f1e <__match+0x6>
   10f38:	adds	r4, #1
   10f3a:	str	r4, [r0, #0]
   10f3c:	movs	r0, #1
   10f3e:	pop	{r4, r5}
   10f40:	bx	lr
   10f42:	movs	r0, #0
   10f44:	pop	{r4, r5}
   10f46:	bx	lr

00010f48 <__hexnan>:
   10f48:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10f4c:	ldr	r3, [r1, #0]
   10f4e:	ldr.w	r9, [pc, #372]	; 110c4 <__hexnan+0x17c>
   10f52:	sub	sp, #20
   10f54:	asrs	r1, r3, #5
   10f56:	add.w	r1, r2, r1, lsl #2
   10f5a:	ands.w	r3, r3, #31
   10f5e:	str	r1, [sp, #4]
   10f60:	itt	ne
   10f62:	addne	r1, #4
   10f64:	strne	r1, [sp, #4]
   10f66:	ldr	r4, [sp, #4]
   10f68:	str	r0, [sp, #8]
   10f6a:	str	r3, [sp, #12]
   10f6c:	movs	r3, #0
   10f6e:	mov	r1, r3
   10f70:	str.w	r3, [r4, #-4]
   10f74:	mov	sl, r3
   10f76:	mov	lr, r3
   10f78:	ldr	r3, [sp, #8]
   10f7a:	sub.w	ip, r4, #4
   10f7e:	ldr	r5, [r3, #0]
   10f80:	mov	r8, ip
   10f82:	mov	r0, ip
   10f84:	ldrb.w	r3, [r5, #1]!
   10f88:	cbz	r3, 10fd4 <__hexnan+0x8c>
   10f8a:	ldrb.w	r4, [r9, r3]
   10f8e:	cmp	r4, #0
   10f90:	bne.n	1101a <__hexnan+0xd2>
   10f92:	cmp	r3, #32
   10f94:	bhi.n	11052 <__hexnan+0x10a>
   10f96:	cmp	lr, sl
   10f98:	ble.n	10f84 <__hexnan+0x3c>
   10f9a:	cmp	r0, r8
   10f9c:	bcs.n	10fc6 <__hexnan+0x7e>
   10f9e:	cmp	r1, #7
   10fa0:	bgt.n	10fc6 <__hexnan+0x7e>
   10fa2:	rsb	r1, r1, #8
   10fa6:	lsls	r1, r1, #2
   10fa8:	ldr	r6, [r0, #0]
   10faa:	rsb	fp, r1, #32
   10fae:	mov	r3, r0
   10fb0:	ldr	r7, [r3, #4]
   10fb2:	lsl.w	r4, r7, fp
   10fb6:	orrs	r4, r6
   10fb8:	lsr.w	r6, r7, r1
   10fbc:	str	r4, [r3, #0]
   10fbe:	str.w	r6, [r3, #4]!
   10fc2:	cmp	r8, r3
   10fc4:	bhi.n	10fb0 <__hexnan+0x68>
   10fc6:	cmp	r0, r2
   10fc8:	bhi.n	11040 <__hexnan+0xf8>
   10fca:	ldrb.w	r3, [r5, #1]!
   10fce:	movs	r1, #8
   10fd0:	cmp	r3, #0
   10fd2:	bne.n	10f8a <__hexnan+0x42>
   10fd4:	cmp.w	lr, #0
   10fd8:	beq.n	11056 <__hexnan+0x10e>
   10fda:	cmp	r0, r8
   10fdc:	bcs.n	10fe2 <__hexnan+0x9a>
   10fde:	cmp	r1, #7
   10fe0:	ble.n	1109c <__hexnan+0x154>
   10fe2:	cmp	r0, r2
   10fe4:	bls.n	1105e <__hexnan+0x116>
   10fe6:	mov	r3, r2
   10fe8:	ldr.w	r1, [r0], #4
   10fec:	str.w	r1, [r3], #4
   10ff0:	cmp	ip, r0
   10ff2:	bcs.n	10fe8 <__hexnan+0xa0>
   10ff4:	movs	r1, #0
   10ff6:	str.w	r1, [r3], #4
   10ffa:	cmp	ip, r3
   10ffc:	bcs.n	10ff6 <__hexnan+0xae>
   10ffe:	ldr	r3, [sp, #4]
   11000:	ldr.w	r3, [r3, #-4]
   11004:	cbnz	r3, 11012 <__hexnan+0xca>
   11006:	cmp	r2, ip
   11008:	beq.n	11080 <__hexnan+0x138>
   1100a:	ldr.w	r3, [ip, #-4]!
   1100e:	cmp	r3, #0
   11010:	beq.n	11006 <__hexnan+0xbe>
   11012:	movs	r0, #5
   11014:	add	sp, #20
   11016:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1101a:	adds	r1, #1
   1101c:	cmp	r1, #8
   1101e:	add.w	lr, lr, #1
   11022:	ble.n	11032 <__hexnan+0xea>
   11024:	cmp	r0, r2
   11026:	bls.n	10f84 <__hexnan+0x3c>
   11028:	movs	r3, #0
   1102a:	str.w	r3, [r0, #-4]
   1102e:	movs	r1, #1
   11030:	subs	r0, #4
   11032:	ldr	r3, [r0, #0]
   11034:	and.w	r4, r4, #15
   11038:	orr.w	r4, r4, r3, lsl #4
   1103c:	str	r4, [r0, #0]
   1103e:	b.n	10f84 <__hexnan+0x3c>
   11040:	movs	r3, #0
   11042:	sub.w	r8, r0, #4
   11046:	str.w	r3, [r0, #-4]
   1104a:	mov	sl, lr
   1104c:	mov	r0, r8
   1104e:	mov	r1, r3
   11050:	b.n	10f84 <__hexnan+0x3c>
   11052:	cmp	r3, #41	; 0x29
   11054:	beq.n	1108e <__hexnan+0x146>
   11056:	movs	r0, #4
   11058:	add	sp, #20
   1105a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1105e:	ldr	r3, [sp, #12]
   11060:	cmp	r3, #0
   11062:	beq.n	10ffe <__hexnan+0xb6>
   11064:	ldr	r4, [sp, #4]
   11066:	ldr	r3, [sp, #12]
   11068:	ldr.w	r1, [r4, #-4]
   1106c:	rsb	r3, r3, #32
   11070:	mov.w	r0, #4294967295
   11074:	lsr.w	r3, r0, r3
   11078:	ands	r3, r1
   1107a:	str.w	r3, [r4, #-4]
   1107e:	b.n	11004 <__hexnan+0xbc>
   11080:	movs	r3, #1
   11082:	movs	r0, #5
   11084:	str.w	r3, [ip]
   11088:	add	sp, #20
   1108a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1108e:	ldr	r3, [sp, #8]
   11090:	adds	r5, #1
   11092:	str	r5, [r3, #0]
   11094:	cmp.w	lr, #0
   11098:	bne.n	10fda <__hexnan+0x92>
   1109a:	b.n	11056 <__hexnan+0x10e>
   1109c:	rsb	r3, r1, #8
   110a0:	lsls	r3, r3, #2
   110a2:	ldr	r5, [r0, #0]
   110a4:	rsb	r7, r3, #32
   110a8:	mov	r1, r0
   110aa:	ldr	r6, [r1, #4]
   110ac:	lsl.w	r4, r6, r7
   110b0:	orrs	r4, r5
   110b2:	lsr.w	r5, r6, r3
   110b6:	str	r4, [r1, #0]
   110b8:	str.w	r5, [r1, #4]!
   110bc:	cmp	r8, r1
   110be:	bhi.n	110aa <__hexnan+0x162>
   110c0:	b.n	10fe2 <__hexnan+0x9a>
   110c2:	nop
   110c4:	.word	0x0001321c

000110c8 <iswspace>:
   110c8:	cmp	r0, #255	; 0xff
   110ca:	bls.n	110d0 <iswspace+0x8>
   110cc:	movs	r0, #0
   110ce:	bx	lr
   110d0:	push	{r4, lr}
   110d2:	mov	r4, r0
   110d4:	bl	b208 <__locale_ctype_ptr>
   110d8:	add	r0, r4
   110da:	ldrb	r0, [r0, #1]
   110dc:	and.w	r0, r0, #8
   110e0:	uxtb	r0, r0
   110e2:	pop	{r4, pc}

000110e4 <__localeconv_l>:
   110e4:	adds	r0, #240	; 0xf0
   110e6:	bx	lr

000110e8 <_localeconv_r>:
   110e8:	ldr	r2, [pc, #16]	; (110fc <_localeconv_r+0x14>)
   110ea:	ldr	r3, [pc, #20]	; (11100 <_localeconv_r+0x18>)
   110ec:	ldr	r2, [r2, #0]
   110ee:	ldr	r0, [r2, #52]	; 0x34
   110f0:	cmp	r0, #0
   110f2:	it	eq
   110f4:	moveq	r0, r3
   110f6:	adds	r0, #240	; 0xf0
   110f8:	bx	lr
   110fa:	nop
   110fc:	.word	0x1fff1848
   11100:	.word	0x1fff184c

00011104 <_mbrtowc_r>:
   11104:	push	{r4, r5, r6, r7, lr}
   11106:	sub	sp, #12
   11108:	mov	r7, r0
   1110a:	ldr	r5, [sp, #32]
   1110c:	cbz	r2, 11134 <_mbrtowc_r+0x30>
   1110e:	ldr	r4, [pc, #68]	; (11154 <_mbrtowc_r+0x50>)
   11110:	ldr	r6, [pc, #68]	; (11158 <_mbrtowc_r+0x54>)
   11112:	ldr	r4, [r4, #0]
   11114:	ldr	r4, [r4, #52]	; 0x34
   11116:	str	r5, [sp, #0]
   11118:	cmp	r4, #0
   1111a:	it	eq
   1111c:	moveq	r4, r6
   1111e:	ldr.w	r4, [r4, #228]	; 0xe4
   11122:	blx	r4
   11124:	adds	r3, r0, #1
   11126:	bne.n	11130 <_mbrtowc_r+0x2c>
   11128:	movs	r2, #0
   1112a:	movs	r3, #138	; 0x8a
   1112c:	str	r2, [r5, #0]
   1112e:	str	r3, [r7, #0]
   11130:	add	sp, #12
   11132:	pop	{r4, r5, r6, r7, pc}
   11134:	ldr	r3, [pc, #28]	; (11154 <_mbrtowc_r+0x50>)
   11136:	ldr	r1, [pc, #32]	; (11158 <_mbrtowc_r+0x54>)
   11138:	ldr	r3, [r3, #0]
   1113a:	ldr	r3, [r3, #52]	; 0x34
   1113c:	str	r5, [sp, #0]
   1113e:	cmp	r3, #0
   11140:	it	eq
   11142:	moveq	r3, r1
   11144:	mov	r4, r2
   11146:	mov	r1, r4
   11148:	ldr	r2, [pc, #16]	; (1115c <_mbrtowc_r+0x58>)
   1114a:	ldr.w	r4, [r3, #228]	; 0xe4
   1114e:	movs	r3, #1
   11150:	blx	r4
   11152:	b.n	11124 <_mbrtowc_r+0x20>
   11154:	.word	0x1fff1848
   11158:	.word	0x1fff184c
   1115c:	.word	0x000130a8

00011160 <_Balloc>:
   11160:	ldr	r3, [r0, #76]	; 0x4c
   11162:	push	{r4, r5, r6, lr}
   11164:	mov	r5, r0
   11166:	mov	r4, r1
   11168:	cbz	r3, 1117e <_Balloc+0x1e>
   1116a:	ldr.w	r0, [r3, r4, lsl #2]
   1116e:	cbz	r0, 11192 <_Balloc+0x32>
   11170:	ldr	r2, [r0, #0]
   11172:	str.w	r2, [r3, r4, lsl #2]
   11176:	movs	r3, #0
   11178:	str	r3, [r0, #16]
   1117a:	str	r3, [r0, #12]
   1117c:	pop	{r4, r5, r6, pc}
   1117e:	movs	r2, #33	; 0x21
   11180:	movs	r1, #4
   11182:	bl	12350 <_calloc_r>
   11186:	str	r0, [r5, #76]	; 0x4c
   11188:	mov	r3, r0
   1118a:	cmp	r0, #0
   1118c:	bne.n	1116a <_Balloc+0xa>
   1118e:	movs	r0, #0
   11190:	pop	{r4, r5, r6, pc}
   11192:	movs	r1, #1
   11194:	lsl.w	r6, r1, r4
   11198:	adds	r2, r6, #5
   1119a:	mov	r0, r5
   1119c:	lsls	r2, r2, #2
   1119e:	bl	12350 <_calloc_r>
   111a2:	cmp	r0, #0
   111a4:	beq.n	1118e <_Balloc+0x2e>
   111a6:	str	r4, [r0, #4]
   111a8:	str	r6, [r0, #8]
   111aa:	b.n	11176 <_Balloc+0x16>

000111ac <_Bfree>:
   111ac:	cbz	r1, 111bc <_Bfree+0x10>
   111ae:	ldr	r3, [r0, #76]	; 0x4c
   111b0:	ldr	r2, [r1, #4]
   111b2:	ldr.w	r0, [r3, r2, lsl #2]
   111b6:	str	r0, [r1, #0]
   111b8:	str.w	r1, [r3, r2, lsl #2]
   111bc:	bx	lr
   111be:	nop

000111c0 <__multadd>:
   111c0:	push	{r4, r5, r6, r7, lr}
   111c2:	ldr	r4, [r1, #16]
   111c4:	sub	sp, #12
   111c6:	mov	r5, r1
   111c8:	mov	r6, r0
   111ca:	add.w	lr, r1, #20
   111ce:	movs	r7, #0
   111d0:	ldr.w	r0, [lr]
   111d4:	uxth	r1, r0
   111d6:	mla	r1, r2, r1, r3
   111da:	lsrs	r3, r1, #16
   111dc:	lsrs	r0, r0, #16
   111de:	mla	r3, r2, r0, r3
   111e2:	uxth	r1, r1
   111e4:	adds	r7, #1
   111e6:	add.w	r1, r1, r3, lsl #16
   111ea:	cmp	r4, r7
   111ec:	str.w	r1, [lr], #4
   111f0:	mov.w	r3, r3, lsr #16
   111f4:	bgt.n	111d0 <__multadd+0x10>
   111f6:	cbz	r3, 11208 <__multadd+0x48>
   111f8:	ldr	r2, [r5, #8]
   111fa:	cmp	r4, r2
   111fc:	bge.n	1120e <__multadd+0x4e>
   111fe:	add.w	r2, r5, r4, lsl #2
   11202:	adds	r4, #1
   11204:	str	r3, [r2, #20]
   11206:	str	r4, [r5, #16]
   11208:	mov	r0, r5
   1120a:	add	sp, #12
   1120c:	pop	{r4, r5, r6, r7, pc}
   1120e:	ldr	r1, [r5, #4]
   11210:	str	r3, [sp, #4]
   11212:	adds	r1, #1
   11214:	mov	r0, r6
   11216:	bl	11160 <_Balloc>
   1121a:	ldr	r2, [r5, #16]
   1121c:	adds	r2, #2
   1121e:	add.w	r1, r5, #12
   11222:	mov	r7, r0
   11224:	lsls	r2, r2, #2
   11226:	adds	r0, #12
   11228:	bl	8e18 <memcpy>
   1122c:	ldr	r2, [r6, #76]	; 0x4c
   1122e:	ldr	r1, [r5, #4]
   11230:	ldr	r3, [sp, #4]
   11232:	ldr.w	r0, [r2, r1, lsl #2]
   11236:	str	r0, [r5, #0]
   11238:	str.w	r5, [r2, r1, lsl #2]
   1123c:	mov	r5, r7
   1123e:	b.n	111fe <__multadd+0x3e>

00011240 <__s2b>:
   11240:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   11244:	ldr	r4, [pc, #140]	; (112d4 <__s2b+0x94>)
   11246:	ldr	r5, [sp, #32]
   11248:	mov	r7, r3
   1124a:	adds	r3, #8
   1124c:	smull	r4, lr, r4, r3
   11250:	asrs	r3, r3, #31
   11252:	rsb	lr, r3, lr, asr #1
   11256:	cmp.w	lr, #1
   1125a:	mov	r6, r0
   1125c:	mov	r4, r1
   1125e:	mov	r8, r2
   11260:	ble.n	112ce <__s2b+0x8e>
   11262:	movs	r3, #1
   11264:	movs	r1, #0
   11266:	lsls	r3, r3, #1
   11268:	cmp	lr, r3
   1126a:	add.w	r1, r1, #1
   1126e:	bgt.n	11266 <__s2b+0x26>
   11270:	mov	r0, r6
   11272:	bl	11160 <_Balloc>
   11276:	movs	r3, #1
   11278:	cmp.w	r8, #9
   1127c:	str	r5, [r0, #20]
   1127e:	str	r3, [r0, #16]
   11280:	ble.n	112c6 <__s2b+0x86>
   11282:	add.w	r9, r4, #9
   11286:	mov	r5, r9
   11288:	add	r4, r8
   1128a:	ldrb.w	r3, [r5], #1
   1128e:	mov	r1, r0
   11290:	subs	r3, #48	; 0x30
   11292:	movs	r2, #10
   11294:	mov	r0, r6
   11296:	bl	111c0 <__multadd>
   1129a:	cmp	r5, r4
   1129c:	bne.n	1128a <__s2b+0x4a>
   1129e:	add.w	r4, r9, r8
   112a2:	subs	r4, #8
   112a4:	cmp	r7, r8
   112a6:	ble.n	112c2 <__s2b+0x82>
   112a8:	rsb	r7, r8, r7
   112ac:	add	r7, r4
   112ae:	ldrb.w	r3, [r4], #1
   112b2:	mov	r1, r0
   112b4:	subs	r3, #48	; 0x30
   112b6:	movs	r2, #10
   112b8:	mov	r0, r6
   112ba:	bl	111c0 <__multadd>
   112be:	cmp	r7, r4
   112c0:	bne.n	112ae <__s2b+0x6e>
   112c2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   112c6:	adds	r4, #10
   112c8:	mov.w	r8, #9
   112cc:	b.n	112a4 <__s2b+0x64>
   112ce:	movs	r1, #0
   112d0:	b.n	11270 <__s2b+0x30>
   112d2:	nop
   112d4:	.word	0x38e38e39

000112d8 <__hi0bits>:
   112d8:	lsrs	r3, r0, #16
   112da:	lsls	r3, r3, #16
   112dc:	cbnz	r3, 1130c <__hi0bits+0x34>
   112de:	lsls	r0, r0, #16
   112e0:	movs	r3, #16
   112e2:	tst.w	r0, #4278190080	; 0xff000000
   112e6:	itt	eq
   112e8:	lsleq	r0, r0, #8
   112ea:	addeq	r3, #8
   112ec:	tst.w	r0, #4026531840	; 0xf0000000
   112f0:	itt	eq
   112f2:	lsleq	r0, r0, #4
   112f4:	addeq	r3, #4
   112f6:	tst.w	r0, #3221225472	; 0xc0000000
   112fa:	itt	eq
   112fc:	lsleq	r0, r0, #2
   112fe:	addeq	r3, #2
   11300:	cmp	r0, #0
   11302:	blt.n	11314 <__hi0bits+0x3c>
   11304:	lsls	r2, r0, #1
   11306:	bmi.n	11310 <__hi0bits+0x38>
   11308:	movs	r0, #32
   1130a:	bx	lr
   1130c:	movs	r3, #0
   1130e:	b.n	112e2 <__hi0bits+0xa>
   11310:	adds	r0, r3, #1
   11312:	bx	lr
   11314:	mov	r0, r3
   11316:	bx	lr

00011318 <__lo0bits>:
   11318:	ldr	r3, [r0, #0]
   1131a:	ands.w	r2, r3, #7
   1131e:	beq.n	11330 <__lo0bits+0x18>
   11320:	lsls	r1, r3, #31
   11322:	bmi.n	11366 <__lo0bits+0x4e>
   11324:	lsls	r2, r3, #30
   11326:	bmi.n	1136a <__lo0bits+0x52>
   11328:	lsrs	r3, r3, #2
   1132a:	str	r3, [r0, #0]
   1132c:	movs	r0, #2
   1132e:	bx	lr
   11330:	uxth	r1, r3
   11332:	cbnz	r1, 11338 <__lo0bits+0x20>
   11334:	lsrs	r3, r3, #16
   11336:	movs	r2, #16
   11338:	tst.w	r3, #255	; 0xff
   1133c:	itt	eq
   1133e:	lsreq	r3, r3, #8
   11340:	addeq	r2, #8
   11342:	lsls	r1, r3, #28
   11344:	itt	eq
   11346:	lsreq	r3, r3, #4
   11348:	addeq	r2, #4
   1134a:	lsls	r1, r3, #30
   1134c:	itt	eq
   1134e:	lsreq	r3, r3, #2
   11350:	addeq	r2, #2
   11352:	lsls	r1, r3, #31
   11354:	bmi.n	11360 <__lo0bits+0x48>
   11356:	lsrs	r3, r3, #1
   11358:	bne.n	1135e <__lo0bits+0x46>
   1135a:	movs	r0, #32
   1135c:	bx	lr
   1135e:	adds	r2, #1
   11360:	str	r3, [r0, #0]
   11362:	mov	r0, r2
   11364:	bx	lr
   11366:	movs	r0, #0
   11368:	bx	lr
   1136a:	lsrs	r3, r3, #1
   1136c:	str	r3, [r0, #0]
   1136e:	movs	r0, #1
   11370:	bx	lr
   11372:	nop

00011374 <__i2b>:
   11374:	push	{r4, lr}
   11376:	mov	r4, r1
   11378:	movs	r1, #1
   1137a:	bl	11160 <_Balloc>
   1137e:	movs	r2, #1
   11380:	str	r4, [r0, #20]
   11382:	str	r2, [r0, #16]
   11384:	pop	{r4, pc}
   11386:	nop

00011388 <__multiply>:
   11388:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1138c:	ldr	r5, [r1, #16]
   1138e:	ldr	r7, [r2, #16]
   11390:	cmp	r5, r7
   11392:	sub	sp, #12
   11394:	mov	r4, r1
   11396:	mov	r6, r2
   11398:	bge.n	113a4 <__multiply+0x1c>
   1139a:	mov	r2, r5
   1139c:	mov	r4, r6
   1139e:	mov	r5, r7
   113a0:	mov	r6, r1
   113a2:	mov	r7, r2
   113a4:	ldr	r3, [r4, #8]
   113a6:	ldr	r1, [r4, #4]
   113a8:	add.w	r8, r5, r7
   113ac:	cmp	r8, r3
   113ae:	it	gt
   113b0:	addgt	r1, #1
   113b2:	bl	11160 <_Balloc>
   113b6:	add.w	ip, r0, #20
   113ba:	add.w	r9, ip, r8, lsl #2
   113be:	cmp	ip, r9
   113c0:	str	r0, [sp, #0]
   113c2:	bcs.n	113d0 <__multiply+0x48>
   113c4:	mov	r3, ip
   113c6:	movs	r1, #0
   113c8:	str.w	r1, [r3], #4
   113cc:	cmp	r9, r3
   113ce:	bhi.n	113c8 <__multiply+0x40>
   113d0:	add.w	r2, r6, #20
   113d4:	add.w	sl, r2, r7, lsl #2
   113d8:	add.w	r3, r4, #20
   113dc:	cmp	r2, sl
   113de:	add.w	lr, r3, r5, lsl #2
   113e2:	bcs.n	1148e <__multiply+0x106>
   113e4:	str.w	r9, [sp, #4]
   113e8:	mov	r9, r3
   113ea:	ldr.w	r3, [r2], #4
   113ee:	uxth.w	fp, r3
   113f2:	cmp.w	fp, #0
   113f6:	beq.n	1143a <__multiply+0xb2>
   113f8:	movs	r0, #0
   113fa:	mov	r7, r9
   113fc:	mov	r6, ip
   113fe:	mov	r5, r0
   11400:	b.n	11404 <__multiply+0x7c>
   11402:	mov	r6, r3
   11404:	ldr.w	r4, [r7], #4
   11408:	ldr	r0, [r6, #0]
   1140a:	uxth	r1, r4
   1140c:	uxth	r3, r0
   1140e:	mla	r1, fp, r1, r3
   11412:	lsrs	r4, r4, #16
   11414:	lsrs	r0, r0, #16
   11416:	adds	r3, r1, r5
   11418:	mla	r0, fp, r4, r0
   1141c:	add.w	r0, r0, r3, lsr #16
   11420:	uxth	r1, r3
   11422:	mov	r3, r6
   11424:	orr.w	r1, r1, r0, lsl #16
   11428:	cmp	lr, r7
   1142a:	mov.w	r5, r0, lsr #16
   1142e:	str.w	r1, [r3], #4
   11432:	bhi.n	11402 <__multiply+0x7a>
   11434:	str	r5, [r6, #4]
   11436:	ldr.w	r3, [r2, #-4]
   1143a:	movs.w	fp, r3, lsr #16
   1143e:	beq.n	11482 <__multiply+0xfa>
   11440:	ldr.w	r3, [ip]
   11444:	mov	r7, ip
   11446:	mov	r0, r3
   11448:	mov	r5, r9
   1144a:	movs	r1, #0
   1144c:	b.n	11450 <__multiply+0xc8>
   1144e:	mov	r7, r6
   11450:	ldrh	r4, [r5, #0]
   11452:	lsrs	r0, r0, #16
   11454:	mla	r0, fp, r4, r0
   11458:	add	r1, r0
   1145a:	uxth	r4, r3
   1145c:	mov	r6, r7
   1145e:	orr.w	r3, r4, r1, lsl #16
   11462:	str.w	r3, [r6], #4
   11466:	ldr	r0, [r7, #4]
   11468:	ldr.w	r4, [r5], #4
   1146c:	uxth	r3, r0
   1146e:	lsrs	r4, r4, #16
   11470:	mla	r4, fp, r4, r3
   11474:	add.w	r3, r4, r1, lsr #16
   11478:	cmp	lr, r5
   1147a:	mov.w	r1, r3, lsr #16
   1147e:	bhi.n	1144e <__multiply+0xc6>
   11480:	str	r3, [r7, #4]
   11482:	cmp	sl, r2
   11484:	add.w	ip, ip, #4
   11488:	bhi.n	113ea <__multiply+0x62>
   1148a:	ldr.w	r9, [sp, #4]
   1148e:	cmp.w	r8, #0
   11492:	ble.n	114ac <__multiply+0x124>
   11494:	ldr.w	r3, [r9, #-4]
   11498:	sub.w	r9, r9, #4
   1149c:	cbz	r3, 114a6 <__multiply+0x11e>
   1149e:	b.n	114ac <__multiply+0x124>
   114a0:	ldr.w	r3, [r9, #-4]!
   114a4:	cbnz	r3, 114ac <__multiply+0x124>
   114a6:	subs.w	r8, r8, #1
   114aa:	bne.n	114a0 <__multiply+0x118>
   114ac:	ldr	r0, [sp, #0]
   114ae:	str.w	r8, [r0, #16]
   114b2:	add	sp, #12
   114b4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

000114b8 <__pow5mult>:
   114b8:	ands.w	r3, r2, #3
   114bc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   114c0:	mov	r4, r2
   114c2:	mov	r7, r0
   114c4:	bne.n	11524 <__pow5mult+0x6c>
   114c6:	mov	r6, r1
   114c8:	asrs	r4, r4, #2
   114ca:	beq.n	11506 <__pow5mult+0x4e>
   114cc:	ldr	r5, [r7, #72]	; 0x48
   114ce:	cbz	r5, 11536 <__pow5mult+0x7e>
   114d0:	lsls	r3, r4, #31
   114d2:	mov.w	r8, #0
   114d6:	bmi.n	114e6 <__pow5mult+0x2e>
   114d8:	asrs	r4, r4, #1
   114da:	beq.n	11506 <__pow5mult+0x4e>
   114dc:	ldr	r0, [r5, #0]
   114de:	cbz	r0, 1150c <__pow5mult+0x54>
   114e0:	mov	r5, r0
   114e2:	lsls	r3, r4, #31
   114e4:	bpl.n	114d8 <__pow5mult+0x20>
   114e6:	mov	r2, r5
   114e8:	mov	r1, r6
   114ea:	mov	r0, r7
   114ec:	bl	11388 <__multiply>
   114f0:	cbz	r6, 11520 <__pow5mult+0x68>
   114f2:	ldr	r2, [r6, #4]
   114f4:	ldr	r3, [r7, #76]	; 0x4c
   114f6:	asrs	r4, r4, #1
   114f8:	ldr.w	r1, [r3, r2, lsl #2]
   114fc:	str	r1, [r6, #0]
   114fe:	str.w	r6, [r3, r2, lsl #2]
   11502:	mov	r6, r0
   11504:	bne.n	114dc <__pow5mult+0x24>
   11506:	mov	r0, r6
   11508:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1150c:	mov	r2, r5
   1150e:	mov	r1, r5
   11510:	mov	r0, r7
   11512:	bl	11388 <__multiply>
   11516:	str	r0, [r5, #0]
   11518:	str.w	r8, [r0]
   1151c:	mov	r5, r0
   1151e:	b.n	114e2 <__pow5mult+0x2a>
   11520:	mov	r6, r0
   11522:	b.n	114d8 <__pow5mult+0x20>
   11524:	subs	r2, r3, #1
   11526:	ldr	r5, [pc, #44]	; (11554 <__pow5mult+0x9c>)
   11528:	movs	r3, #0
   1152a:	ldr.w	r2, [r5, r2, lsl #2]
   1152e:	bl	111c0 <__multadd>
   11532:	mov	r6, r0
   11534:	b.n	114c8 <__pow5mult+0x10>
   11536:	movs	r1, #1
   11538:	mov	r0, r7
   1153a:	bl	11160 <_Balloc>
   1153e:	movw	r1, #625	; 0x271
   11542:	movs	r2, #1
   11544:	movs	r3, #0
   11546:	str	r1, [r0, #20]
   11548:	str	r2, [r0, #16]
   1154a:	mov	r5, r0
   1154c:	str	r0, [r7, #72]	; 0x48
   1154e:	str	r3, [r0, #0]
   11550:	b.n	114d0 <__pow5mult+0x18>
   11552:	nop
   11554:	.word	0x00013410

00011558 <__lshift>:
   11558:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1155c:	mov	r9, r2
   1155e:	ldr	r2, [r1, #16]
   11560:	ldr	r3, [r1, #8]
   11562:	mov.w	r4, r9, asr #5
   11566:	add.w	r8, r4, r2
   1156a:	add.w	r5, r8, #1
   1156e:	cmp	r5, r3
   11570:	mov	r6, r1
   11572:	mov	sl, r0
   11574:	ldr	r1, [r1, #4]
   11576:	ble.n	11582 <__lshift+0x2a>
   11578:	lsls	r3, r3, #1
   1157a:	cmp	r5, r3
   1157c:	add.w	r1, r1, #1
   11580:	bgt.n	11578 <__lshift+0x20>
   11582:	mov	r0, sl
   11584:	bl	11160 <_Balloc>
   11588:	cmp	r4, #0
   1158a:	add.w	r2, r0, #20
   1158e:	ble.n	11602 <__lshift+0xaa>
   11590:	add.w	r3, r2, r4, lsl #2
   11594:	movs	r1, #0
   11596:	str.w	r1, [r2], #4
   1159a:	cmp	r3, r2
   1159c:	bne.n	11596 <__lshift+0x3e>
   1159e:	ldr	r4, [r6, #16]
   115a0:	add.w	r1, r6, #20
   115a4:	ands.w	r9, r9, #31
   115a8:	add.w	lr, r1, r4, lsl #2
   115ac:	beq.n	115f2 <__lshift+0x9a>
   115ae:	rsb	r2, r9, #32
   115b2:	movs	r4, #0
   115b4:	ldr	r7, [r1, #0]
   115b6:	lsl.w	ip, r7, r9
   115ba:	orr.w	r4, ip, r4
   115be:	mov	ip, r3
   115c0:	str.w	r4, [r3], #4
   115c4:	ldr.w	r4, [r1], #4
   115c8:	cmp	lr, r1
   115ca:	lsr.w	r4, r4, r2
   115ce:	bhi.n	115b4 <__lshift+0x5c>
   115d0:	str.w	r4, [ip, #4]
   115d4:	cbz	r4, 115da <__lshift+0x82>
   115d6:	add.w	r5, r8, #2
   115da:	ldr.w	r3, [sl, #76]	; 0x4c
   115de:	ldr	r2, [r6, #4]
   115e0:	subs	r5, #1
   115e2:	ldr.w	r1, [r3, r2, lsl #2]
   115e6:	str	r5, [r0, #16]
   115e8:	str	r1, [r6, #0]
   115ea:	str.w	r6, [r3, r2, lsl #2]
   115ee:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   115f2:	subs	r3, #4
   115f4:	ldr.w	r2, [r1], #4
   115f8:	str.w	r2, [r3, #4]!
   115fc:	cmp	lr, r1
   115fe:	bhi.n	115f4 <__lshift+0x9c>
   11600:	b.n	115da <__lshift+0x82>
   11602:	mov	r3, r2
   11604:	b.n	1159e <__lshift+0x46>
   11606:	nop

00011608 <__mcmp>:
   11608:	ldr	r2, [r0, #16]
   1160a:	ldr	r3, [r1, #16]
   1160c:	subs	r2, r2, r3
   1160e:	bne.n	11638 <__mcmp+0x30>
   11610:	lsls	r3, r3, #2
   11612:	adds	r0, #20
   11614:	adds	r1, #20
   11616:	add	r1, r3
   11618:	push	{r4}
   1161a:	add	r3, r0
   1161c:	b.n	11622 <__mcmp+0x1a>
   1161e:	cmp	r0, r3
   11620:	bcs.n	1163c <__mcmp+0x34>
   11622:	ldr.w	r4, [r3, #-4]!
   11626:	ldr.w	r2, [r1, #-4]!
   1162a:	cmp	r4, r2
   1162c:	beq.n	1161e <__mcmp+0x16>
   1162e:	bcc.n	11644 <__mcmp+0x3c>
   11630:	movs	r0, #1
   11632:	ldr.w	r4, [sp], #4
   11636:	bx	lr
   11638:	mov	r0, r2
   1163a:	bx	lr
   1163c:	movs	r0, #0
   1163e:	ldr.w	r4, [sp], #4
   11642:	bx	lr
   11644:	mov.w	r0, #4294967295
   11648:	b.n	11632 <__mcmp+0x2a>
   1164a:	nop

0001164c <__mdiff>:
   1164c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   11650:	ldr	r3, [r1, #16]
   11652:	mov	r7, r1
   11654:	ldr	r1, [r2, #16]
   11656:	subs	r3, r3, r1
   11658:	cmp	r3, #0
   1165a:	mov	r8, r2
   1165c:	bne.n	1168e <__mdiff+0x42>
   1165e:	lsls	r1, r1, #2
   11660:	add.w	r2, r7, #20
   11664:	add.w	r5, r8, #20
   11668:	adds	r3, r2, r1
   1166a:	add	r1, r5
   1166c:	b.n	11672 <__mdiff+0x26>
   1166e:	cmp	r2, r3
   11670:	bcs.n	11730 <__mdiff+0xe4>
   11672:	ldr.w	r6, [r3, #-4]!
   11676:	ldr.w	r4, [r1, #-4]!
   1167a:	cmp	r6, r4
   1167c:	beq.n	1166e <__mdiff+0x22>
   1167e:	bcs.n	11742 <__mdiff+0xf6>
   11680:	mov	r3, r7
   11682:	mov	r4, r2
   11684:	mov	r7, r8
   11686:	mov.w	r9, #1
   1168a:	mov	r8, r3
   1168c:	b.n	1169c <__mdiff+0x50>
   1168e:	blt.n	1174c <__mdiff+0x100>
   11690:	add.w	r5, r7, #20
   11694:	add.w	r4, r2, #20
   11698:	mov.w	r9, #0
   1169c:	ldr	r1, [r7, #4]
   1169e:	bl	11160 <_Balloc>
   116a2:	ldr.w	r3, [r8, #16]
   116a6:	ldr	r6, [r7, #16]
   116a8:	str.w	r9, [r0, #12]
   116ac:	add.w	ip, r4, r3, lsl #2
   116b0:	mov	lr, r4
   116b2:	add.w	r7, r5, r6, lsl #2
   116b6:	add.w	r4, r0, #20
   116ba:	movs	r3, #0
   116bc:	ldr.w	r1, [lr], #4
   116c0:	ldr.w	r8, [r5], #4
   116c4:	uxth	r2, r1
   116c6:	uxtah	r3, r3, r8
   116ca:	lsrs	r1, r1, #16
   116cc:	subs	r2, r3, r2
   116ce:	rsb	r3, r1, r8, lsr #16
   116d2:	add.w	r3, r3, r2, asr #16
   116d6:	uxth	r2, r2
   116d8:	orr.w	r2, r2, r3, lsl #16
   116dc:	cmp	ip, lr
   116de:	str.w	r2, [r4], #4
   116e2:	mov.w	r3, r3, asr #16
   116e6:	bhi.n	116bc <__mdiff+0x70>
   116e8:	cmp	r7, r5
   116ea:	bls.n	1171c <__mdiff+0xd0>
   116ec:	mov	ip, r4
   116ee:	mov	r1, r5
   116f0:	ldr.w	lr, [r1], #4
   116f4:	uxtah	r2, r3, lr
   116f8:	asrs	r3, r2, #16
   116fa:	add.w	r3, r3, lr, lsr #16
   116fe:	uxth	r2, r2
   11700:	orr.w	r2, r2, r3, lsl #16
   11704:	cmp	r7, r1
   11706:	str.w	r2, [ip], #4
   1170a:	mov.w	r3, r3, asr #16
   1170e:	bhi.n	116f0 <__mdiff+0xa4>
   11710:	mvns	r5, r5
   11712:	add	r5, r7
   11714:	bic.w	r5, r5, #3
   11718:	adds	r5, #4
   1171a:	add	r4, r5
   1171c:	subs	r4, #4
   1171e:	cbnz	r2, 1172a <__mdiff+0xde>
   11720:	ldr.w	r3, [r4, #-4]!
   11724:	subs	r6, #1
   11726:	cmp	r3, #0
   11728:	beq.n	11720 <__mdiff+0xd4>
   1172a:	str	r6, [r0, #16]
   1172c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   11730:	movs	r1, #0
   11732:	bl	11160 <_Balloc>
   11736:	movs	r2, #1
   11738:	movs	r3, #0
   1173a:	str	r2, [r0, #16]
   1173c:	str	r3, [r0, #20]
   1173e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   11742:	mov	r4, r5
   11744:	mov.w	r9, #0
   11748:	mov	r5, r2
   1174a:	b.n	1169c <__mdiff+0x50>
   1174c:	mov	r3, r7
   1174e:	add.w	r4, r7, #20
   11752:	add.w	r5, r8, #20
   11756:	mov	r7, r8
   11758:	mov.w	r9, #1
   1175c:	mov	r8, r3
   1175e:	b.n	1169c <__mdiff+0x50>

00011760 <__ulp>:
   11760:	ldr	r3, [pc, #76]	; (117b0 <__ulp+0x50>)
   11762:	vmov	r2, s1
   11766:	ands	r2, r3
   11768:	sub.w	r3, r2, #54525952	; 0x3400000
   1176c:	cmp	r3, #0
   1176e:	ble.n	1177a <__ulp+0x1a>
   11770:	movs	r0, #0
   11772:	mov	r1, r3
   11774:	vmov	d0, r0, r1
   11778:	bx	lr
   1177a:	negs	r3, r3
   1177c:	asrs	r3, r3, #20
   1177e:	cmp	r3, #19
   11780:	ble.n	1179e <__ulp+0x3e>
   11782:	subs	r3, #20
   11784:	cmp	r3, #30
   11786:	ittte	le
   11788:	rsble	r3, r3, #31
   1178c:	movle	r2, #1
   1178e:	lslle.w	r3, r2, r3
   11792:	movgt	r3, #1
   11794:	movs	r1, #0
   11796:	mov	r0, r3
   11798:	vmov	d0, r0, r1
   1179c:	bx	lr
   1179e:	mov.w	r2, #524288	; 0x80000
   117a2:	movs	r0, #0
   117a4:	asr.w	r1, r2, r3
   117a8:	vmov	d0, r0, r1
   117ac:	bx	lr
   117ae:	nop
   117b0:	.word	0x7ff00000

000117b4 <__b2d>:
   117b4:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   117b8:	ldr	r6, [r0, #16]
   117ba:	add.w	r8, r0, #20
   117be:	add.w	r6, r8, r6, lsl #2
   117c2:	ldr.w	r7, [r6, #-4]
   117c6:	mov	r0, r7
   117c8:	bl	112d8 <__hi0bits>
   117cc:	rsb	r3, r0, #32
   117d0:	cmp	r0, #10
   117d2:	str	r3, [r1, #0]
   117d4:	sub.w	r3, r6, #4
   117d8:	bgt.n	1180c <__b2d+0x58>
   117da:	cmp	r8, r3
   117dc:	rsb	r2, r0, #11
   117e0:	it	cc
   117e2:	ldrcc.w	r3, [r6, #-8]
   117e6:	lsr.w	r1, r7, r2
   117ea:	add.w	r0, r0, #21
   117ee:	orr.w	r5, r1, #1069547520	; 0x3fc00000
   117f2:	ite	cc
   117f4:	lsrcc	r3, r2
   117f6:	movcs	r3, #0
   117f8:	lsl.w	r0, r7, r0
   117fc:	orr.w	r5, r5, #3145728	; 0x300000
   11800:	orr.w	r4, r0, r3
   11804:	vmov	d0, r4, r5
   11808:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1180c:	cmp	r8, r3
   1180e:	bcs.n	11852 <__b2d+0x9e>
   11810:	subs.w	r3, r0, #11
   11814:	ldr.w	r2, [r6, #-8]
   11818:	beq.n	11858 <__b2d+0xa4>
   1181a:	lsl.w	r0, r7, r3
   1181e:	orr.w	r7, r0, #1069547520	; 0x3fc00000
   11822:	rsb	lr, r3, #32
   11826:	sub.w	r1, r6, #8
   1182a:	orr.w	r7, r7, #3145728	; 0x300000
   1182e:	lsr.w	r0, r2, lr
   11832:	cmp	r8, r1
   11834:	orr.w	r5, r7, r0
   11838:	bcs.n	1187c <__b2d+0xc8>
   1183a:	ldr.w	r1, [r6, #-12]
   1183e:	lsl.w	r0, r2, r3
   11842:	lsr.w	r3, r1, lr
   11846:	orrs	r0, r3
   11848:	mov	r4, r0
   1184a:	vmov	d0, r4, r5
   1184e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11852:	subs	r0, #11
   11854:	bne.n	1186a <__b2d+0xb6>
   11856:	mov	r2, r0
   11858:	orr.w	r5, r7, #1069547520	; 0x3fc00000
   1185c:	orr.w	r5, r5, #3145728	; 0x300000
   11860:	mov	r4, r2
   11862:	vmov	d0, r4, r5
   11866:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1186a:	lsl.w	r0, r7, r0
   1186e:	orr.w	r5, r0, #1069547520	; 0x3fc00000
   11872:	movs	r0, #0
   11874:	orr.w	r5, r5, #3145728	; 0x300000
   11878:	mov	r4, r0
   1187a:	b.n	1184a <__b2d+0x96>
   1187c:	lsl.w	r0, r2, r3
   11880:	mov	r4, r0
   11882:	b.n	1184a <__b2d+0x96>

00011884 <__d2b>:
   11884:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11888:	vmov	r6, r7, d0
   1188c:	sub	sp, #12
   1188e:	mov	r8, r1
   11890:	movs	r1, #1
   11892:	mov	r4, r7
   11894:	ubfx	r5, r7, #20, #11
   11898:	mov	r7, r2
   1189a:	bl	11160 <_Balloc>
   1189e:	ubfx	r4, r4, #0, #20
   118a2:	mov	r9, r0
   118a4:	cbz	r5, 118aa <__d2b+0x26>
   118a6:	orr.w	r4, r4, #1048576	; 0x100000
   118aa:	str	r4, [sp, #4]
   118ac:	cbz	r6, 118f6 <__d2b+0x72>
   118ae:	add	r0, sp, #8
   118b0:	str.w	r6, [r0, #-8]!
   118b4:	bl	11318 <__lo0bits>
   118b8:	cmp	r0, #0
   118ba:	bne.n	11926 <__d2b+0xa2>
   118bc:	ldmia.w	sp, {r2, r3}
   118c0:	str.w	r2, [r9, #20]
   118c4:	cmp	r3, #0
   118c6:	ite	eq
   118c8:	moveq	r1, #1
   118ca:	movne	r1, #2
   118cc:	str.w	r3, [r9, #24]
   118d0:	str.w	r1, [r9, #16]
   118d4:	cbnz	r5, 1190e <__d2b+0x8a>
   118d6:	add.w	r3, r9, r1, lsl #2
   118da:	subw	r0, r0, #1074	; 0x432
   118de:	str.w	r0, [r8]
   118e2:	ldr	r0, [r3, #16]
   118e4:	bl	112d8 <__hi0bits>
   118e8:	rsb	r0, r0, r1, lsl #5
   118ec:	str	r0, [r7, #0]
   118ee:	mov	r0, r9
   118f0:	add	sp, #12
   118f2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   118f6:	add	r0, sp, #4
   118f8:	bl	11318 <__lo0bits>
   118fc:	ldr	r3, [sp, #4]
   118fe:	str.w	r3, [r9, #20]
   11902:	movs	r1, #1
   11904:	adds	r0, #32
   11906:	str.w	r1, [r9, #16]
   1190a:	cmp	r5, #0
   1190c:	beq.n	118d6 <__d2b+0x52>
   1190e:	subw	r5, r5, #1075	; 0x433
   11912:	add	r5, r0
   11914:	rsb	r0, r0, #53	; 0x35
   11918:	str.w	r5, [r8]
   1191c:	str	r0, [r7, #0]
   1191e:	mov	r0, r9
   11920:	add	sp, #12
   11922:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   11926:	ldmia.w	sp, {r2, r3}
   1192a:	rsb	r1, r0, #32
   1192e:	lsl.w	r1, r3, r1
   11932:	orrs	r2, r1
   11934:	lsrs	r3, r0
   11936:	str	r3, [sp, #4]
   11938:	str.w	r2, [r9, #20]
   1193c:	b.n	118c4 <__d2b+0x40>
   1193e:	nop

00011940 <__ratio>:
   11940:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   11944:	sub	sp, #12
   11946:	mov	r8, r1
   11948:	mov	r1, sp
   1194a:	mov	r9, r0
   1194c:	bl	117b4 <__b2d>
   11950:	mov	r0, r8
   11952:	add	r1, sp, #4
   11954:	vmov	r4, r5, d0
   11958:	bl	117b4 <__b2d>
   1195c:	ldmia.w	sp, {r1, r3}
   11960:	ldr.w	r2, [r9, #16]
   11964:	ldr.w	r0, [r8, #16]
   11968:	subs	r1, r1, r3
   1196a:	subs	r0, r2, r0
   1196c:	add.w	r3, r1, r0, lsl #5
   11970:	cmp	r3, #0
   11972:	vmov	r6, r7, d0
   11976:	ble.n	11994 <__ratio+0x54>
   11978:	add.w	r1, r5, r3, lsl #20
   1197c:	mov	r5, r1
   1197e:	mov	r2, r6
   11980:	mov	r3, r7
   11982:	mov	r0, r4
   11984:	mov	r1, r5
   11986:	bl	aa10 <__aeabi_ddiv>
   1198a:	vmov	d0, r0, r1
   1198e:	add	sp, #12
   11990:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   11994:	sub.w	r9, r7, r3, lsl #20
   11998:	vmov	r6, s0
   1199c:	mov	r7, r9
   1199e:	b.n	1197e <__ratio+0x3e>

000119a0 <__copybits>:
   119a0:	push	{r4, r5, r6}
   119a2:	ldr	r4, [r2, #16]
   119a4:	add.w	r3, r2, #20
   119a8:	subs	r1, #1
   119aa:	asrs	r6, r1, #5
   119ac:	add.w	r4, r3, r4, lsl #2
   119b0:	adds	r6, #1
   119b2:	cmp	r3, r4
   119b4:	add.w	r6, r0, r6, lsl #2
   119b8:	bcs.n	119d4 <__copybits+0x34>
   119ba:	subs	r1, r0, #4
   119bc:	ldr.w	r5, [r3], #4
   119c0:	str.w	r5, [r1, #4]!
   119c4:	cmp	r4, r3
   119c6:	bhi.n	119bc <__copybits+0x1c>
   119c8:	subs	r3, r4, r2
   119ca:	subs	r3, #21
   119cc:	bic.w	r3, r3, #3
   119d0:	adds	r3, #4
   119d2:	add	r0, r3
   119d4:	cmp	r6, r0
   119d6:	bls.n	119e2 <__copybits+0x42>
   119d8:	movs	r3, #0
   119da:	str.w	r3, [r0], #4
   119de:	cmp	r6, r0
   119e0:	bhi.n	119da <__copybits+0x3a>
   119e2:	pop	{r4, r5, r6}
   119e4:	bx	lr
   119e6:	nop

000119e8 <__any_on>:
   119e8:	ldr	r3, [r0, #16]
   119ea:	asrs	r2, r1, #5
   119ec:	cmp	r3, r2
   119ee:	push	{r4}
   119f0:	add.w	r4, r0, #20
   119f4:	bge.n	11a18 <__any_on+0x30>
   119f6:	add.w	r3, r4, r3, lsl #2
   119fa:	cmp	r4, r3
   119fc:	bcs.n	11a42 <__any_on+0x5a>
   119fe:	ldr.w	r0, [r3, #-4]
   11a02:	subs	r3, #4
   11a04:	cbz	r0, 11a0e <__any_on+0x26>
   11a06:	b.n	11a34 <__any_on+0x4c>
   11a08:	ldr.w	r2, [r3, #-4]!
   11a0c:	cbnz	r2, 11a34 <__any_on+0x4c>
   11a0e:	cmp	r4, r3
   11a10:	bcc.n	11a08 <__any_on+0x20>
   11a12:	ldr.w	r4, [sp], #4
   11a16:	bx	lr
   11a18:	ble.n	11a3c <__any_on+0x54>
   11a1a:	ands.w	r1, r1, #31
   11a1e:	beq.n	11a3c <__any_on+0x54>
   11a20:	ldr.w	r0, [r4, r2, lsl #2]
   11a24:	lsr.w	r3, r0, r1
   11a28:	lsl.w	r1, r3, r1
   11a2c:	cmp	r0, r1
   11a2e:	add.w	r3, r4, r2, lsl #2
   11a32:	beq.n	119fa <__any_on+0x12>
   11a34:	movs	r0, #1
   11a36:	ldr.w	r4, [sp], #4
   11a3a:	bx	lr
   11a3c:	add.w	r3, r4, r2, lsl #2
   11a40:	b.n	119fa <__any_on+0x12>
   11a42:	movs	r0, #0
   11a44:	b.n	11a12 <__any_on+0x2a>
   11a46:	nop

00011a48 <__sccl>:
   11a48:	push	{r4, r5, r6}
   11a4a:	ldrb	r5, [r1, #0]
   11a4c:	cmp	r5, #94	; 0x5e
   11a4e:	beq.n	11ab0 <__sccl+0x68>
   11a50:	movs	r2, #0
   11a52:	adds	r1, #1
   11a54:	mov	r6, r2
   11a56:	subs	r3, r0, #1
   11a58:	add.w	r4, r0, #255	; 0xff
   11a5c:	strb.w	r2, [r3, #1]!
   11a60:	cmp	r3, r4
   11a62:	bne.n	11a5c <__sccl+0x14>
   11a64:	cbz	r5, 11a88 <__sccl+0x40>
   11a66:	eor.w	r2, r6, #1
   11a6a:	strb	r2, [r0, r5]
   11a6c:	adds	r4, r1, #1
   11a6e:	ldrb.w	r3, [r4, #-1]
   11a72:	cmp	r3, #45	; 0x2d
   11a74:	beq.n	11a94 <__sccl+0x4c>
   11a76:	cmp	r3, #93	; 0x5d
   11a78:	beq.n	11a8e <__sccl+0x46>
   11a7a:	cbz	r3, 11a82 <__sccl+0x3a>
   11a7c:	mov	r5, r3
   11a7e:	mov	r1, r4
   11a80:	b.n	11a6a <__sccl+0x22>
   11a82:	mov	r0, r1
   11a84:	pop	{r4, r5, r6}
   11a86:	bx	lr
   11a88:	subs	r0, r1, #1
   11a8a:	pop	{r4, r5, r6}
   11a8c:	bx	lr
   11a8e:	mov	r0, r4
   11a90:	pop	{r4, r5, r6}
   11a92:	bx	lr
   11a94:	ldrb	r6, [r1, #1]
   11a96:	cmp	r6, #93	; 0x5d
   11a98:	beq.n	11a7c <__sccl+0x34>
   11a9a:	cmp	r5, r6
   11a9c:	bgt.n	11a7c <__sccl+0x34>
   11a9e:	adds	r1, #2
   11aa0:	adds	r3, r0, r5
   11aa2:	adds	r5, #1
   11aa4:	cmp	r6, r5
   11aa6:	strb.w	r2, [r3, #1]!
   11aaa:	bgt.n	11aa2 <__sccl+0x5a>
   11aac:	adds	r4, #2
   11aae:	b.n	11a6e <__sccl+0x26>
   11ab0:	movs	r2, #1
   11ab2:	ldrb	r5, [r1, #1]
   11ab4:	mov	r6, r2
   11ab6:	adds	r1, #2
   11ab8:	b.n	11a56 <__sccl+0xe>
   11aba:	nop

00011abc <nanf>:
   11abc:	vldr	s0, [pc, #4]	; 11ac4 <nanf+0x8>
   11ac0:	bx	lr
   11ac2:	nop
   11ac4:	.word	0x7fc00000

00011ac8 <_strtoll_l.isra.0>:
   11ac8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11acc:	sub	sp, #20
   11ace:	mov	sl, r3
   11ad0:	str	r1, [sp, #8]
   11ad2:	str	r0, [sp, #12]
   11ad4:	str	r2, [sp, #4]
   11ad6:	mov	r7, r1
   11ad8:	ldr	r6, [sp, #56]	; 0x38
   11ada:	b.n	11ade <_strtoll_l.isra.0+0x16>
   11adc:	mov	r7, r5
   11ade:	mov	r5, r7
   11ae0:	mov	r0, r6
   11ae2:	ldrb.w	r4, [r5], #1
   11ae6:	bl	b200 <__locale_ctype_ptr_l>
   11aea:	add	r0, r4
   11aec:	ldrb	r3, [r0, #1]
   11aee:	and.w	r3, r3, #8
   11af2:	and.w	r2, r3, #255	; 0xff
   11af6:	cmp	r3, #0
   11af8:	bne.n	11adc <_strtoll_l.isra.0+0x14>
   11afa:	cmp	r4, #45	; 0x2d
   11afc:	beq.w	11c06 <_strtoll_l.isra.0+0x13e>
   11b00:	cmp	r4, #43	; 0x2b
   11b02:	it	eq
   11b04:	ldrbeq	r4, [r7, #1]
   11b06:	str	r2, [sp, #0]
   11b08:	it	eq
   11b0a:	addeq	r5, r7, #2
   11b0c:	cmp.w	sl, #0
   11b10:	beq.n	11b2c <_strtoll_l.isra.0+0x64>
   11b12:	cmp.w	sl, #16
   11b16:	beq.w	11c44 <_strtoll_l.isra.0+0x17c>
   11b1a:	ldr	r3, [sp, #0]
   11b1c:	mov	r6, sl
   11b1e:	asrs	r7, r6, #31
   11b20:	cbnz	r3, 11b3e <_strtoll_l.isra.0+0x76>
   11b22:	mov.w	r8, #4294967295
   11b26:	mvn.w	r9, #2147483648	; 0x80000000
   11b2a:	b.n	11b46 <_strtoll_l.isra.0+0x7e>
   11b2c:	cmp	r4, #48	; 0x30
   11b2e:	beq.n	11c30 <_strtoll_l.isra.0+0x168>
   11b30:	movs	r6, #10
   11b32:	movs	r7, #0
   11b34:	mov.w	sl, #10
   11b38:	ldr	r3, [sp, #0]
   11b3a:	cmp	r3, #0
   11b3c:	beq.n	11b22 <_strtoll_l.isra.0+0x5a>
   11b3e:	mov.w	r8, #0
   11b42:	mov.w	r9, #2147483648	; 0x80000000
   11b46:	mov	r2, r6
   11b48:	mov	r3, r7
   11b4a:	mov	r0, r8
   11b4c:	mov	r1, r9
   11b4e:	bl	ae4c <__aeabi_uldivmod>
   11b52:	mov	r3, r7
   11b54:	mov	fp, r2
   11b56:	mov	r0, r8
   11b58:	mov	r2, r6
   11b5a:	mov	r1, r9
   11b5c:	bl	ae4c <__aeabi_uldivmod>
   11b60:	mov.w	lr, #0
   11b64:	movs	r2, #0
   11b66:	movs	r3, #0
   11b68:	b.n	11b8a <_strtoll_l.isra.0+0xc2>
   11b6a:	beq.n	11bf8 <_strtoll_l.isra.0+0x130>
   11b6c:	mul.w	r4, r2, r7
   11b70:	mla	r4, r6, r3, r4
   11b74:	umull	r2, r3, r2, r6
   11b78:	add	r3, r4
   11b7a:	adds.w	r2, r2, ip
   11b7e:	adc.w	r3, r3, ip, asr #31
   11b82:	mov.w	lr, #1
   11b86:	ldrb.w	r4, [r5], #1
   11b8a:	sub.w	ip, r4, #48	; 0x30
   11b8e:	cmp.w	ip, #9
   11b92:	bls.n	11ba2 <_strtoll_l.isra.0+0xda>
   11b94:	sub.w	ip, r4, #65	; 0x41
   11b98:	cmp.w	ip, #25
   11b9c:	bhi.n	11bba <_strtoll_l.isra.0+0xf2>
   11b9e:	sub.w	ip, r4, #55	; 0x37
   11ba2:	cmp	sl, ip
   11ba4:	ble.n	11bcc <_strtoll_l.isra.0+0x104>
   11ba6:	cmp.w	lr, #4294967295
   11baa:	beq.n	11b86 <_strtoll_l.isra.0+0xbe>
   11bac:	cmp	r1, r3
   11bae:	it	eq
   11bb0:	cmpeq	r0, r2
   11bb2:	bcs.n	11b6a <_strtoll_l.isra.0+0xa2>
   11bb4:	mov.w	lr, #4294967295
   11bb8:	b.n	11b86 <_strtoll_l.isra.0+0xbe>
   11bba:	sub.w	ip, r4, #97	; 0x61
   11bbe:	cmp.w	ip, #25
   11bc2:	bhi.n	11bcc <_strtoll_l.isra.0+0x104>
   11bc4:	sub.w	ip, r4, #87	; 0x57
   11bc8:	cmp	sl, ip
   11bca:	bgt.n	11ba6 <_strtoll_l.isra.0+0xde>
   11bcc:	cmp.w	lr, #4294967295
   11bd0:	beq.n	11c10 <_strtoll_l.isra.0+0x148>
   11bd2:	ldr	r1, [sp, #0]
   11bd4:	cbz	r1, 11bdc <_strtoll_l.isra.0+0x114>
   11bd6:	negs	r2, r2
   11bd8:	sbc.w	r3, r3, r3, lsl #1
   11bdc:	ldr	r1, [sp, #4]
   11bde:	cmp	r1, #0
   11be0:	beq.n	11c68 <_strtoll_l.isra.0+0x1a0>
   11be2:	cmp.w	lr, #0
   11be6:	bne.n	11c28 <_strtoll_l.isra.0+0x160>
   11be8:	ldr	r5, [sp, #8]
   11bea:	mov	r0, r2
   11bec:	mov	r1, r3
   11bee:	ldr	r3, [sp, #4]
   11bf0:	str	r5, [r3, #0]
   11bf2:	add	sp, #20
   11bf4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11bf8:	cmp	fp, ip
   11bfa:	bge.n	11b6c <_strtoll_l.isra.0+0xa4>
   11bfc:	mov	r2, r0
   11bfe:	mov	r3, r1
   11c00:	mov.w	lr, #4294967295
   11c04:	b.n	11b86 <_strtoll_l.isra.0+0xbe>
   11c06:	movs	r3, #1
   11c08:	adds	r5, r7, #2
   11c0a:	ldrb	r4, [r7, #1]
   11c0c:	str	r3, [sp, #0]
   11c0e:	b.n	11b0c <_strtoll_l.isra.0+0x44>
   11c10:	ldr	r3, [sp, #0]
   11c12:	cbnz	r3, 11c60 <_strtoll_l.isra.0+0x198>
   11c14:	mov.w	r0, #4294967295
   11c18:	mvn.w	r1, #2147483648	; 0x80000000
   11c1c:	ldr	r2, [sp, #12]
   11c1e:	movs	r3, #34	; 0x22
   11c20:	str	r3, [r2, #0]
   11c22:	ldr	r3, [sp, #4]
   11c24:	cbnz	r3, 11c2c <_strtoll_l.isra.0+0x164>
   11c26:	b.n	11bf2 <_strtoll_l.isra.0+0x12a>
   11c28:	mov	r0, r2
   11c2a:	mov	r1, r3
   11c2c:	subs	r5, #1
   11c2e:	b.n	11bee <_strtoll_l.isra.0+0x126>
   11c30:	ldrb	r3, [r5, #0]
   11c32:	and.w	r3, r3, #223	; 0xdf
   11c36:	cmp	r3, #88	; 0x58
   11c38:	beq.n	11c52 <_strtoll_l.isra.0+0x18a>
   11c3a:	movs	r6, #8
   11c3c:	movs	r7, #0
   11c3e:	mov.w	sl, #8
   11c42:	b.n	11b38 <_strtoll_l.isra.0+0x70>
   11c44:	cmp	r4, #48	; 0x30
   11c46:	bne.n	11c6e <_strtoll_l.isra.0+0x1a6>
   11c48:	ldrb	r3, [r5, #0]
   11c4a:	and.w	r3, r3, #223	; 0xdf
   11c4e:	cmp	r3, #88	; 0x58
   11c50:	bne.n	11c6e <_strtoll_l.isra.0+0x1a6>
   11c52:	ldrb	r4, [r5, #1]
   11c54:	movs	r6, #16
   11c56:	movs	r7, #0
   11c58:	adds	r5, #2
   11c5a:	mov.w	sl, #16
   11c5e:	b.n	11b38 <_strtoll_l.isra.0+0x70>
   11c60:	movs	r0, #0
   11c62:	mov.w	r1, #2147483648	; 0x80000000
   11c66:	b.n	11c1c <_strtoll_l.isra.0+0x154>
   11c68:	mov	r0, r2
   11c6a:	mov	r1, r3
   11c6c:	b.n	11bf2 <_strtoll_l.isra.0+0x12a>
   11c6e:	movs	r6, #16
   11c70:	movs	r7, #0
   11c72:	b.n	11b38 <_strtoll_l.isra.0+0x70>

00011c74 <_strtoll_r>:
   11c74:	push	{r4, r5, lr}
   11c76:	ldr	r4, [pc, #24]	; (11c90 <_strtoll_r+0x1c>)
   11c78:	ldr	r5, [pc, #24]	; (11c94 <_strtoll_r+0x20>)
   11c7a:	ldr	r4, [r4, #0]
   11c7c:	ldr	r4, [r4, #52]	; 0x34
   11c7e:	sub	sp, #12
   11c80:	cmp	r4, #0
   11c82:	it	eq
   11c84:	moveq	r4, r5
   11c86:	str	r4, [sp, #0]
   11c88:	bl	11ac8 <_strtoll_l.isra.0>
   11c8c:	add	sp, #12
   11c8e:	pop	{r4, r5, pc}
   11c90:	.word	0x1fff1848
   11c94:	.word	0x1fff184c

00011c98 <_strtoul_l.isra.0>:
   11c98:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11c9c:	ldr.w	r9, [sp, #40]	; 0x28
   11ca0:	mov	r6, r1
   11ca2:	mov	r7, r0
   11ca4:	mov	r5, r2
   11ca6:	mov	r8, r3
   11ca8:	mov	fp, r1
   11caa:	b.n	11cae <_strtoul_l.isra.0+0x16>
   11cac:	mov	fp, r4
   11cae:	mov	r4, fp
   11cb0:	mov	r0, r9
   11cb2:	ldrb.w	sl, [r4], #1
   11cb6:	bl	b200 <__locale_ctype_ptr_l>
   11cba:	add	r0, sl
   11cbc:	ldrb	r0, [r0, #1]
   11cbe:	and.w	r0, r0, #8
   11cc2:	and.w	ip, r0, #255	; 0xff
   11cc6:	cmp	r0, #0
   11cc8:	bne.n	11cac <_strtoul_l.isra.0+0x14>
   11cca:	mov	r1, sl
   11ccc:	cmp	r1, #45	; 0x2d
   11cce:	beq.n	11d94 <_strtoul_l.isra.0+0xfc>
   11cd0:	cmp	r1, #43	; 0x2b
   11cd2:	itt	eq
   11cd4:	ldrbeq.w	r1, [fp, #1]
   11cd8:	addeq.w	r4, fp, #2
   11cdc:	cmp.w	r8, #0
   11ce0:	beq.n	11cfc <_strtoul_l.isra.0+0x64>
   11ce2:	cmp.w	r8, #16
   11ce6:	beq.n	11da2 <_strtoul_l.isra.0+0x10a>
   11ce8:	mov.w	r3, #4294967295
   11cec:	udiv	r3, r3, r8
   11cf0:	mul.w	sl, r8, r3
   11cf4:	mvn.w	sl, sl
   11cf8:	mov	r9, r8
   11cfa:	b.n	11d0c <_strtoul_l.isra.0+0x74>
   11cfc:	cmp	r1, #48	; 0x30
   11cfe:	beq.n	11dc4 <_strtoul_l.isra.0+0x12c>
   11d00:	mov.w	r8, #10
   11d04:	ldr	r3, [pc, #244]	; (11dfc <_strtoul_l.isra.0+0x164>)
   11d06:	mov	r9, r8
   11d08:	mov.w	sl, #5
   11d0c:	mov.w	lr, #0
   11d10:	mov	r0, lr
   11d12:	b.n	11d22 <_strtoul_l.isra.0+0x8a>
   11d14:	beq.n	11d76 <_strtoul_l.isra.0+0xde>
   11d16:	mla	r0, r9, r0, r2
   11d1a:	mov.w	lr, #1
   11d1e:	ldrb.w	r1, [r4], #1
   11d22:	sub.w	r2, r1, #48	; 0x30
   11d26:	cmp	r2, #9
   11d28:	bls.n	11d36 <_strtoul_l.isra.0+0x9e>
   11d2a:	sub.w	r2, r1, #65	; 0x41
   11d2e:	cmp	r2, #25
   11d30:	bhi.n	11d4a <_strtoul_l.isra.0+0xb2>
   11d32:	sub.w	r2, r1, #55	; 0x37
   11d36:	cmp	r8, r2
   11d38:	ble.n	11d5a <_strtoul_l.isra.0+0xc2>
   11d3a:	cmp.w	lr, #4294967295
   11d3e:	beq.n	11d1e <_strtoul_l.isra.0+0x86>
   11d40:	cmp	r0, r3
   11d42:	bls.n	11d14 <_strtoul_l.isra.0+0x7c>
   11d44:	mov.w	lr, #4294967295
   11d48:	b.n	11d1e <_strtoul_l.isra.0+0x86>
   11d4a:	sub.w	r2, r1, #97	; 0x61
   11d4e:	cmp	r2, #25
   11d50:	bhi.n	11d5a <_strtoul_l.isra.0+0xc2>
   11d52:	sub.w	r2, r1, #87	; 0x57
   11d56:	cmp	r8, r2
   11d58:	bgt.n	11d3a <_strtoul_l.isra.0+0xa2>
   11d5a:	cmp.w	lr, #4294967295
   11d5e:	beq.n	11d84 <_strtoul_l.isra.0+0xec>
   11d60:	cmp.w	ip, #0
   11d64:	beq.n	11d68 <_strtoul_l.isra.0+0xd0>
   11d66:	negs	r0, r0
   11d68:	cbz	r5, 11d80 <_strtoul_l.isra.0+0xe8>
   11d6a:	cmp.w	lr, #0
   11d6e:	bne.n	11d8c <_strtoul_l.isra.0+0xf4>
   11d70:	str	r6, [r5, #0]
   11d72:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11d76:	cmp	r2, sl
   11d78:	ble.n	11d16 <_strtoul_l.isra.0+0x7e>
   11d7a:	mov.w	lr, #4294967295
   11d7e:	b.n	11d1e <_strtoul_l.isra.0+0x86>
   11d80:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11d84:	movs	r3, #34	; 0x22
   11d86:	str	r3, [r7, #0]
   11d88:	mov	r0, lr
   11d8a:	cbz	r5, 11dde <_strtoul_l.isra.0+0x146>
   11d8c:	subs	r6, r4, #1
   11d8e:	str	r6, [r5, #0]
   11d90:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11d94:	add.w	r4, fp, #2
   11d98:	ldrb.w	r1, [fp, #1]
   11d9c:	mov.w	ip, #1
   11da0:	b.n	11cdc <_strtoul_l.isra.0+0x44>
   11da2:	cmp	r1, #48	; 0x30
   11da4:	bne.n	11de2 <_strtoul_l.isra.0+0x14a>
   11da6:	ldrb	r3, [r4, #0]
   11da8:	and.w	r3, r3, #223	; 0xdf
   11dac:	cmp	r3, #88	; 0x58
   11dae:	bne.n	11dee <_strtoul_l.isra.0+0x156>
   11db0:	mov.w	r9, #16
   11db4:	ldrb	r1, [r4, #1]
   11db6:	mov	r8, r9
   11db8:	mov.w	sl, #15
   11dbc:	adds	r4, #2
   11dbe:	mvn.w	r3, #4026531840	; 0xf0000000
   11dc2:	b.n	11d0c <_strtoul_l.isra.0+0x74>
   11dc4:	ldrb	r3, [r4, #0]
   11dc6:	and.w	r3, r3, #223	; 0xdf
   11dca:	cmp	r3, #88	; 0x58
   11dcc:	beq.n	11db0 <_strtoul_l.isra.0+0x118>
   11dce:	mov.w	r8, #8
   11dd2:	mov	r9, r8
   11dd4:	mov.w	sl, #7
   11dd8:	mvn.w	r3, #3758096384	; 0xe0000000
   11ddc:	b.n	11d0c <_strtoul_l.isra.0+0x74>
   11dde:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11de2:	mov.w	sl, #15
   11de6:	mvn.w	r3, #4026531840	; 0xf0000000
   11dea:	mov	r9, r8
   11dec:	b.n	11d0c <_strtoul_l.isra.0+0x74>
   11dee:	mov	r9, r8
   11df0:	mov.w	sl, #15
   11df4:	mvn.w	r3, #4026531840	; 0xf0000000
   11df8:	b.n	11d0c <_strtoul_l.isra.0+0x74>
   11dfa:	nop
   11dfc:	.word	0x19999999

00011e00 <_strtoul_r>:
   11e00:	push	{r4, r5, lr}
   11e02:	ldr	r4, [pc, #24]	; (11e1c <_strtoul_r+0x1c>)
   11e04:	ldr	r5, [pc, #24]	; (11e20 <_strtoul_r+0x20>)
   11e06:	ldr	r4, [r4, #0]
   11e08:	ldr	r4, [r4, #52]	; 0x34
   11e0a:	sub	sp, #12
   11e0c:	cmp	r4, #0
   11e0e:	it	eq
   11e10:	moveq	r4, r5
   11e12:	str	r4, [sp, #0]
   11e14:	bl	11c98 <_strtoul_l.isra.0>
   11e18:	add	sp, #12
   11e1a:	pop	{r4, r5, pc}
   11e1c:	.word	0x1fff1848
   11e20:	.word	0x1fff184c

00011e24 <_strtoull_l.isra.0>:
   11e24:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11e28:	sub	sp, #20
   11e2a:	mov	fp, r1
   11e2c:	str	r0, [sp, #8]
   11e2e:	mov	r7, r2
   11e30:	mov	r6, r3
   11e32:	mov	r8, r1
   11e34:	ldr	r4, [sp, #56]	; 0x38
   11e36:	b.n	11e3a <_strtoull_l.isra.0+0x16>
   11e38:	mov	r8, r5
   11e3a:	mov	r5, r8
   11e3c:	mov	r0, r4
   11e3e:	ldrb.w	r9, [r5], #1
   11e42:	bl	b200 <__locale_ctype_ptr_l>
   11e46:	add	r0, r9
   11e48:	ldrb	r3, [r0, #1]
   11e4a:	and.w	r3, r3, #8
   11e4e:	and.w	r2, r3, #255	; 0xff
   11e52:	cmp	r3, #0
   11e54:	bne.n	11e38 <_strtoull_l.isra.0+0x14>
   11e56:	mov	r4, r9
   11e58:	cmp	r4, #45	; 0x2d
   11e5a:	beq.w	11f76 <_strtoull_l.isra.0+0x152>
   11e5e:	cmp	r4, #43	; 0x2b
   11e60:	it	eq
   11e62:	ldrbeq.w	r4, [r8, #1]
   11e66:	str	r2, [sp, #4]
   11e68:	it	eq
   11e6a:	addeq.w	r5, r8, #2
   11e6e:	cbz	r6, 11ea8 <_strtoull_l.isra.0+0x84>
   11e70:	cmp	r6, #16
   11e72:	beq.w	11f84 <_strtoull_l.isra.0+0x160>
   11e76:	mov.w	r9, r6, asr #31
   11e7a:	mov	r2, r6
   11e7c:	mov	r3, r9
   11e7e:	mov.w	r0, #4294967295
   11e82:	mov.w	r1, #4294967295
   11e86:	bl	ae4c <__aeabi_uldivmod>
   11e8a:	mov	r2, r6
   11e8c:	str	r0, [sp, #12]
   11e8e:	mov	sl, r1
   11e90:	mov	r3, r9
   11e92:	mov.w	r0, #4294967295
   11e96:	mov.w	r1, #4294967295
   11e9a:	bl	ae4c <__aeabi_uldivmod>
   11e9e:	mov	r8, r6
   11ea0:	mov	lr, r2
   11ea2:	ldr	r2, [sp, #12]
   11ea4:	mov	r3, sl
   11ea6:	b.n	11ec2 <_strtoull_l.isra.0+0x9e>
   11ea8:	cmp	r4, #48	; 0x30
   11eaa:	beq.w	11fb0 <_strtoull_l.isra.0+0x18c>
   11eae:	ldr	r3, [pc, #348]	; (1200c <_strtoull_l.isra.0+0x1e8>)
   11eb0:	mov.w	lr, #5
   11eb4:	mov.w	r2, #2576980377	; 0x99999999
   11eb8:	mov.w	r8, #10
   11ebc:	mov.w	r9, #0
   11ec0:	movs	r6, #10
   11ec2:	mov.w	ip, #0
   11ec6:	movs	r0, #0
   11ec8:	movs	r1, #0
   11eca:	b.n	11ef2 <_strtoull_l.isra.0+0xce>
   11ecc:	cmp	r1, r3
   11ece:	it	eq
   11ed0:	cmpeq	r0, r2
   11ed2:	beq.n	11f56 <_strtoull_l.isra.0+0x132>
   11ed4:	mul.w	r4, r0, r9
   11ed8:	mla	r4, r8, r1, r4
   11edc:	umull	r0, r1, r0, r8
   11ee0:	add	r1, r4
   11ee2:	adds.w	r0, r0, sl
   11ee6:	adc.w	r1, r1, sl, asr #31
   11eea:	mov.w	ip, #1
   11eee:	ldrb.w	r4, [r5], #1
   11ef2:	sub.w	sl, r4, #48	; 0x30
   11ef6:	cmp.w	sl, #9
   11efa:	bls.n	11f0a <_strtoull_l.isra.0+0xe6>
   11efc:	sub.w	sl, r4, #65	; 0x41
   11f00:	cmp.w	sl, #25
   11f04:	bhi.n	11f22 <_strtoull_l.isra.0+0xfe>
   11f06:	sub.w	sl, r4, #55	; 0x37
   11f0a:	cmp	r6, sl
   11f0c:	ble.n	11f34 <_strtoull_l.isra.0+0x110>
   11f0e:	cmp.w	ip, #4294967295
   11f12:	beq.n	11eee <_strtoull_l.isra.0+0xca>
   11f14:	cmp	r3, r1
   11f16:	it	eq
   11f18:	cmpeq	r2, r0
   11f1a:	bcs.n	11ecc <_strtoull_l.isra.0+0xa8>
   11f1c:	mov.w	ip, #4294967295
   11f20:	b.n	11eee <_strtoull_l.isra.0+0xca>
   11f22:	sub.w	sl, r4, #97	; 0x61
   11f26:	cmp.w	sl, #25
   11f2a:	bhi.n	11f34 <_strtoull_l.isra.0+0x110>
   11f2c:	sub.w	sl, r4, #87	; 0x57
   11f30:	cmp	r6, sl
   11f32:	bgt.n	11f0e <_strtoull_l.isra.0+0xea>
   11f34:	cmp.w	ip, #4294967295
   11f38:	beq.n	11f60 <_strtoull_l.isra.0+0x13c>
   11f3a:	ldr	r3, [sp, #4]
   11f3c:	cbz	r3, 11f44 <_strtoull_l.isra.0+0x120>
   11f3e:	negs	r0, r0
   11f40:	sbc.w	r1, r1, r1, lsl #1
   11f44:	cbz	r7, 11f50 <_strtoull_l.isra.0+0x12c>
   11f46:	cmp.w	ip, #0
   11f4a:	bne.n	11f72 <_strtoull_l.isra.0+0x14e>
   11f4c:	mov	r5, fp
   11f4e:	str	r5, [r7, #0]
   11f50:	add	sp, #20
   11f52:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11f56:	cmp	sl, lr
   11f58:	ble.n	11ed4 <_strtoull_l.isra.0+0xb0>
   11f5a:	mov.w	ip, #4294967295
   11f5e:	b.n	11eee <_strtoull_l.isra.0+0xca>
   11f60:	ldr	r2, [sp, #8]
   11f62:	movs	r3, #34	; 0x22
   11f64:	str	r3, [r2, #0]
   11f66:	mov.w	r0, #4294967295
   11f6a:	mov.w	r1, #4294967295
   11f6e:	cmp	r7, #0
   11f70:	beq.n	11f50 <_strtoull_l.isra.0+0x12c>
   11f72:	subs	r5, #1
   11f74:	b.n	11f4e <_strtoull_l.isra.0+0x12a>
   11f76:	movs	r3, #1
   11f78:	add.w	r5, r8, #2
   11f7c:	ldrb.w	r4, [r8, #1]
   11f80:	str	r3, [sp, #4]
   11f82:	b.n	11e6e <_strtoull_l.isra.0+0x4a>
   11f84:	cmp	r4, #48	; 0x30
   11f86:	bne.n	11fd2 <_strtoull_l.isra.0+0x1ae>
   11f88:	ldrb	r3, [r5, #0]
   11f8a:	and.w	r3, r3, #223	; 0xdf
   11f8e:	cmp	r3, #88	; 0x58
   11f90:	bne.n	11fe8 <_strtoull_l.isra.0+0x1c4>
   11f92:	mov.w	r3, #4294967295
   11f96:	ldrb	r4, [r5, #1]
   11f98:	str	r3, [sp, #12]
   11f9a:	mov.w	lr, #15
   11f9e:	adds	r5, #2
   11fa0:	mvn.w	sl, #4026531840	; 0xf0000000
   11fa4:	mov.w	r8, #16
   11fa8:	mov.w	r9, #0
   11fac:	movs	r6, #16
   11fae:	b.n	11ea2 <_strtoull_l.isra.0+0x7e>
   11fb0:	ldrb	r3, [r5, #0]
   11fb2:	and.w	r3, r3, #223	; 0xdf
   11fb6:	cmp	r3, #88	; 0x58
   11fb8:	beq.n	11f92 <_strtoull_l.isra.0+0x16e>
   11fba:	mov.w	lr, #7
   11fbe:	mov.w	r2, #4294967295
   11fc2:	mvn.w	r3, #3758096384	; 0xe0000000
   11fc6:	mov.w	r8, #8
   11fca:	mov.w	r9, #0
   11fce:	movs	r6, #8
   11fd0:	b.n	11ec2 <_strtoull_l.isra.0+0x9e>
   11fd2:	mov.w	lr, #15
   11fd6:	mov.w	r2, #4294967295
   11fda:	mvn.w	r3, #4026531840	; 0xf0000000
   11fde:	mov.w	r8, #16
   11fe2:	mov.w	r9, #0
   11fe6:	b.n	11ec2 <_strtoull_l.isra.0+0x9e>
   11fe8:	mov.w	r8, #16
   11fec:	mov.w	r9, #0
   11ff0:	mov	r2, r8
   11ff2:	mov	r3, r9
   11ff4:	mov.w	r0, #4294967295
   11ff8:	mov.w	r1, #4294967295
   11ffc:	bl	ae4c <__aeabi_uldivmod>
   12000:	mvn.w	r3, #4026531840	; 0xf0000000
   12004:	mov	lr, r2
   12006:	mov.w	r2, #4294967295
   1200a:	b.n	11ec2 <_strtoull_l.isra.0+0x9e>
   1200c:	.word	0x19999999

00012010 <_strtoull_r>:
   12010:	push	{r4, r5, lr}
   12012:	ldr	r4, [pc, #24]	; (1202c <_strtoull_r+0x1c>)
   12014:	ldr	r5, [pc, #24]	; (12030 <_strtoull_r+0x20>)
   12016:	ldr	r4, [r4, #0]
   12018:	ldr	r4, [r4, #52]	; 0x34
   1201a:	sub	sp, #12
   1201c:	cmp	r4, #0
   1201e:	it	eq
   12020:	moveq	r4, r5
   12022:	str	r4, [sp, #0]
   12024:	bl	11e24 <_strtoull_l.isra.0>
   12028:	add	sp, #12
   1202a:	pop	{r4, r5, pc}
   1202c:	.word	0x1fff1848
   12030:	.word	0x1fff184c

00012034 <__ssprint_r>:
   12034:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12038:	ldr	r3, [r2, #8]
   1203a:	sub	sp, #12
   1203c:	mov	r8, r2
   1203e:	cmp	r3, #0
   12040:	beq.n	12128 <__ssprint_r+0xf4>
   12042:	mov	fp, r0
   12044:	mov.w	r9, #0
   12048:	ldr	r6, [r2, #0]
   1204a:	ldr	r0, [r1, #0]
   1204c:	ldr	r3, [r1, #8]
   1204e:	mov	r5, r1
   12050:	mov	r4, r9
   12052:	cmp	r4, #0
   12054:	beq.n	120e2 <__ssprint_r+0xae>
   12056:	cmp	r4, r3
   12058:	mov	r7, r3
   1205a:	mov	sl, r3
   1205c:	bcc.n	120ec <__ssprint_r+0xb8>
   1205e:	ldrh	r3, [r5, #12]
   12060:	tst.w	r3, #1152	; 0x480
   12064:	beq.n	120c2 <__ssprint_r+0x8e>
   12066:	ldr	r7, [r5, #20]
   12068:	ldr	r1, [r5, #16]
   1206a:	add.w	r7, r7, r7, lsl #1
   1206e:	rsb	sl, r1, r0
   12072:	add.w	r7, r7, r7, lsr #31
   12076:	adds	r0, r4, #1
   12078:	asrs	r7, r7, #1
   1207a:	add	r0, sl
   1207c:	cmp	r0, r7
   1207e:	mov	r2, r7
   12080:	itt	hi
   12082:	movhi	r7, r0
   12084:	movhi	r2, r7
   12086:	lsls	r3, r3, #21
   12088:	bpl.n	120f2 <__ssprint_r+0xbe>
   1208a:	mov	r1, r2
   1208c:	mov	r0, fp
   1208e:	bl	b23c <_malloc_r>
   12092:	cmp	r0, #0
   12094:	beq.n	12106 <__ssprint_r+0xd2>
   12096:	mov	r2, sl
   12098:	ldr	r1, [r5, #16]
   1209a:	str	r0, [sp, #4]
   1209c:	bl	8e18 <memcpy>
   120a0:	ldrh	r2, [r5, #12]
   120a2:	ldr	r3, [sp, #4]
   120a4:	bic.w	r2, r2, #1152	; 0x480
   120a8:	orr.w	r2, r2, #128	; 0x80
   120ac:	strh	r2, [r5, #12]
   120ae:	rsb	r2, sl, r7
   120b2:	add.w	r0, r3, sl
   120b6:	str	r7, [r5, #20]
   120b8:	str	r3, [r5, #16]
   120ba:	str	r0, [r5, #0]
   120bc:	str	r2, [r5, #8]
   120be:	mov	r7, r4
   120c0:	mov	sl, r4
   120c2:	mov	r2, sl
   120c4:	mov	r1, r9
   120c6:	bl	b8e4 <memmove>
   120ca:	ldr.w	r2, [r8, #8]
   120ce:	ldr	r3, [r5, #8]
   120d0:	ldr	r0, [r5, #0]
   120d2:	subs	r3, r3, r7
   120d4:	add	r0, sl
   120d6:	subs	r4, r2, r4
   120d8:	str	r3, [r5, #8]
   120da:	str	r0, [r5, #0]
   120dc:	str.w	r4, [r8, #8]
   120e0:	cbz	r4, 12128 <__ssprint_r+0xf4>
   120e2:	ldr.w	r9, [r6]
   120e6:	ldr	r4, [r6, #4]
   120e8:	adds	r6, #8
   120ea:	b.n	12052 <__ssprint_r+0x1e>
   120ec:	mov	r7, r4
   120ee:	mov	sl, r4
   120f0:	b.n	120c2 <__ssprint_r+0x8e>
   120f2:	mov	r0, fp
   120f4:	bl	b9b4 <_realloc_r>
   120f8:	mov	r3, r0
   120fa:	cmp	r0, #0
   120fc:	bne.n	120ae <__ssprint_r+0x7a>
   120fe:	ldr	r1, [r5, #16]
   12100:	mov	r0, fp
   12102:	bl	10790 <_free_r>
   12106:	movs	r3, #12
   12108:	str.w	r3, [fp]
   1210c:	ldrh	r3, [r5, #12]
   1210e:	movs	r2, #0
   12110:	orr.w	r3, r3, #64	; 0x40
   12114:	mov.w	r0, #4294967295
   12118:	strh	r3, [r5, #12]
   1211a:	str.w	r2, [r8, #8]
   1211e:	str.w	r2, [r8, #4]
   12122:	add	sp, #12
   12124:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12128:	movs	r0, #0
   1212a:	str.w	r0, [r8, #4]
   1212e:	add	sp, #12
   12130:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00012134 <_sungetc_r>:
   12134:	adds	r3, r1, #1
   12136:	push	{r4, r5, r6, lr}
   12138:	beq.n	12172 <_sungetc_r+0x3e>
   1213a:	ldrh	r3, [r2, #12]
   1213c:	ldr	r4, [r2, #48]	; 0x30
   1213e:	bic.w	r3, r3, #32
   12142:	strh	r3, [r2, #12]
   12144:	uxtb	r5, r1
   12146:	cbz	r4, 12178 <_sungetc_r+0x44>
   12148:	mov	r4, r2
   1214a:	ldr	r2, [r2, #4]
   1214c:	ldr	r3, [r4, #52]	; 0x34
   1214e:	cmp	r2, r3
   12150:	mov	r6, r1
   12152:	bge.n	12168 <_sungetc_r+0x34>
   12154:	ldr	r3, [r4, #0]
   12156:	subs	r2, r3, #1
   12158:	str	r2, [r4, #0]
   1215a:	strb.w	r6, [r3, #-1]
   1215e:	ldr	r3, [r4, #4]
   12160:	adds	r3, #1
   12162:	str	r3, [r4, #4]
   12164:	mov	r0, r5
   12166:	pop	{r4, r5, r6, pc}
   12168:	mov	r1, r4
   1216a:	bl	12278 <__submore>
   1216e:	cmp	r0, #0
   12170:	beq.n	12154 <_sungetc_r+0x20>
   12172:	mov.w	r5, #4294967295
   12176:	b.n	12164 <_sungetc_r+0x30>
   12178:	ldr	r0, [r2, #16]
   1217a:	ldr	r3, [r2, #0]
   1217c:	cbz	r0, 1218a <_sungetc_r+0x56>
   1217e:	cmp	r0, r3
   12180:	bcs.n	1218a <_sungetc_r+0x56>
   12182:	ldrb.w	r0, [r3, #-1]
   12186:	cmp	r5, r0
   12188:	beq.n	121aa <_sungetc_r+0x76>
   1218a:	str	r3, [r2, #56]	; 0x38
   1218c:	mov	r3, r2
   1218e:	ldr	r6, [r2, #4]
   12190:	str	r6, [r2, #60]	; 0x3c
   12192:	add.w	r4, r2, #64	; 0x40
   12196:	movs	r0, #3
   12198:	str	r0, [r2, #52]	; 0x34
   1219a:	str	r4, [r2, #48]	; 0x30
   1219c:	strb.w	r1, [r3, #66]!
   121a0:	movs	r1, #1
   121a2:	str	r3, [r2, #0]
   121a4:	str	r1, [r2, #4]
   121a6:	mov	r0, r5
   121a8:	pop	{r4, r5, r6, pc}
   121aa:	ldr	r1, [r2, #4]
   121ac:	subs	r3, #1
   121ae:	adds	r1, #1
   121b0:	str	r3, [r2, #0]
   121b2:	str	r1, [r2, #4]
   121b4:	b.n	12164 <_sungetc_r+0x30>
   121b6:	nop

000121b8 <__ssrefill_r>:
   121b8:	push	{r4, lr}
   121ba:	mov	r4, r1
   121bc:	ldr	r1, [r1, #48]	; 0x30
   121be:	cbz	r1, 121dc <__ssrefill_r+0x24>
   121c0:	add.w	r3, r4, #64	; 0x40
   121c4:	cmp	r1, r3
   121c6:	beq.n	121cc <__ssrefill_r+0x14>
   121c8:	bl	10790 <_free_r>
   121cc:	ldr	r3, [r4, #60]	; 0x3c
   121ce:	str	r3, [r4, #4]
   121d0:	movs	r0, #0
   121d2:	str	r0, [r4, #48]	; 0x30
   121d4:	cbz	r3, 121dc <__ssrefill_r+0x24>
   121d6:	ldr	r3, [r4, #56]	; 0x38
   121d8:	str	r3, [r4, #0]
   121da:	pop	{r4, pc}
   121dc:	ldrh	r3, [r4, #12]
   121de:	ldr	r2, [r4, #16]
   121e0:	str	r2, [r4, #0]
   121e2:	orr.w	r3, r3, #32
   121e6:	movs	r2, #0
   121e8:	strh	r3, [r4, #12]
   121ea:	str	r2, [r4, #4]
   121ec:	mov.w	r0, #4294967295
   121f0:	pop	{r4, pc}
   121f2:	nop

000121f4 <_sfread_r>:
   121f4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   121f8:	sub	sp, #12
   121fa:	mul.w	r9, r2, r3
   121fe:	str	r2, [sp, #4]
   12200:	mov	sl, r3
   12202:	ldr	r4, [sp, #48]	; 0x30
   12204:	cmp.w	r9, #0
   12208:	beq.n	1225e <_sfread_r+0x6a>
   1220a:	mov	r7, r0
   1220c:	mov	r6, r1
   1220e:	mov	r5, r9
   12210:	mov.w	r8, #0
   12214:	b.n	12236 <_sfread_r+0x42>
   12216:	ldr	r1, [r4, #0]
   12218:	bl	8e18 <memcpy>
   1221c:	ldr	r2, [r4, #0]
   1221e:	str.w	r8, [r4, #4]
   12222:	add	r2, fp
   12224:	str	r2, [r4, #0]
   12226:	mov	r1, r4
   12228:	mov	r0, r7
   1222a:	add	r6, fp
   1222c:	rsb	r5, fp, r5
   12230:	bl	121b8 <__ssrefill_r>
   12234:	cbnz	r0, 12266 <_sfread_r+0x72>
   12236:	ldr.w	fp, [r4, #4]
   1223a:	cmp	r5, fp
   1223c:	mov	r0, r6
   1223e:	mov	r2, fp
   12240:	bhi.n	12216 <_sfread_r+0x22>
   12242:	mov	r2, r5
   12244:	ldr	r1, [r4, #0]
   12246:	bl	8e18 <memcpy>
   1224a:	ldr	r2, [r4, #4]
   1224c:	ldr	r3, [r4, #0]
   1224e:	subs	r2, r2, r5
   12250:	add	r3, r5
   12252:	mov	r0, sl
   12254:	str	r2, [r4, #4]
   12256:	str	r3, [r4, #0]
   12258:	add	sp, #12
   1225a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1225e:	mov	r0, r9
   12260:	add	sp, #12
   12262:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12266:	ldr	r3, [sp, #4]
   12268:	rsb	r9, r5, r9
   1226c:	udiv	r0, r9, r3
   12270:	add	sp, #12
   12272:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12276:	nop

00012278 <__submore>:
   12278:	add.w	r3, r1, #64	; 0x40
   1227c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   12280:	mov	r4, r1
   12282:	ldr	r1, [r1, #48]	; 0x30
   12284:	cmp	r1, r3
   12286:	beq.n	122b2 <__submore+0x3a>
   12288:	ldr	r6, [r4, #52]	; 0x34
   1228a:	lsls	r7, r6, #1
   1228c:	mov	r2, r7
   1228e:	bl	b9b4 <_realloc_r>
   12292:	mov	r5, r0
   12294:	cbz	r0, 122e8 <__submore+0x70>
   12296:	add.w	r8, r0, r6
   1229a:	mov	r2, r6
   1229c:	mov	r0, r8
   1229e:	mov	r1, r5
   122a0:	bl	8e18 <memcpy>
   122a4:	str.w	r8, [r4]
   122a8:	str	r5, [r4, #48]	; 0x30
   122aa:	str	r7, [r4, #52]	; 0x34
   122ac:	movs	r0, #0
   122ae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   122b2:	mov.w	r1, #1024	; 0x400
   122b6:	bl	b23c <_malloc_r>
   122ba:	cbz	r0, 122e8 <__submore+0x70>
   122bc:	ldrb.w	r3, [r4, #66]	; 0x42
   122c0:	str	r0, [r4, #48]	; 0x30
   122c2:	mov.w	r2, #1024	; 0x400
   122c6:	str	r2, [r4, #52]	; 0x34
   122c8:	strb.w	r3, [r0, #1023]	; 0x3ff
   122cc:	ldrb.w	r3, [r4, #65]	; 0x41
   122d0:	strb.w	r3, [r0, #1022]	; 0x3fe
   122d4:	ldrb.w	r3, [r4, #64]	; 0x40
   122d8:	strb.w	r3, [r0, #1021]	; 0x3fd
   122dc:	addw	r0, r0, #1021	; 0x3fd
   122e0:	str	r0, [r4, #0]
   122e2:	movs	r0, #0
   122e4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   122e8:	mov.w	r0, #4294967295
   122ec:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000122f0 <_vasnprintf_r>:
   122f0:	push	{r4, r5, r6, lr}
   122f2:	mov	r5, r2
   122f4:	sub	sp, #104	; 0x68
   122f6:	ldr	r4, [r2, #0]
   122f8:	cbz	r1, 122fe <_vasnprintf_r+0xe>
   122fa:	cmp	r4, #0
   122fc:	bne.n	12334 <_vasnprintf_r+0x44>
   122fe:	movs	r4, #0
   12300:	mov.w	r2, #648	; 0x288
   12304:	strh.w	r2, [sp, #12]
   12308:	str	r4, [sp, #0]
   1230a:	str	r4, [sp, #16]
   1230c:	mov	r2, r3
   1230e:	movw	r6, #65535	; 0xffff
   12312:	ldr	r3, [sp, #120]	; 0x78
   12314:	str	r4, [sp, #8]
   12316:	mov	r1, sp
   12318:	str	r4, [sp, #20]
   1231a:	strh.w	r6, [sp, #14]
   1231e:	bl	d090 <_svfprintf_r>
   12322:	cmp	r0, #0
   12324:	blt.n	1234a <_vasnprintf_r+0x5a>
   12326:	ldr	r3, [sp, #0]
   12328:	str	r0, [r5, #0]
   1232a:	movs	r2, #0
   1232c:	strb	r2, [r3, #0]
   1232e:	ldr	r0, [sp, #16]
   12330:	add	sp, #104	; 0x68
   12332:	pop	{r4, r5, r6, pc}
   12334:	mov.w	r2, #1544	; 0x608
   12338:	str	r1, [sp, #0]
   1233a:	str	r1, [sp, #16]
   1233c:	strh.w	r2, [sp, #12]
   12340:	bge.n	1230c <_vasnprintf_r+0x1c>
   12342:	movs	r3, #139	; 0x8b
   12344:	str	r3, [r0, #0]
   12346:	movs	r0, #0
   12348:	b.n	12330 <_vasnprintf_r+0x40>
   1234a:	movs	r0, #0
   1234c:	b.n	12330 <_vasnprintf_r+0x40>
   1234e:	nop

00012350 <_calloc_r>:
   12350:	push	{r4, lr}
   12352:	mul.w	r1, r2, r1
   12356:	bl	b23c <_malloc_r>
   1235a:	mov	r4, r0
   1235c:	cbz	r0, 12396 <_calloc_r+0x46>
   1235e:	ldr.w	r2, [r0, #-4]
   12362:	bic.w	r2, r2, #3
   12366:	subs	r2, #4
   12368:	cmp	r2, #36	; 0x24
   1236a:	bhi.n	1239e <_calloc_r+0x4e>
   1236c:	cmp	r2, #19
   1236e:	bls.n	1239a <_calloc_r+0x4a>
   12370:	movs	r3, #0
   12372:	cmp	r2, #27
   12374:	str	r3, [r0, #0]
   12376:	str	r3, [r0, #4]
   12378:	bls.n	123a8 <_calloc_r+0x58>
   1237a:	cmp	r2, #36	; 0x24
   1237c:	str	r3, [r0, #8]
   1237e:	str	r3, [r0, #12]
   12380:	iteee	ne
   12382:	addne.w	r2, r0, #16
   12386:	streq	r3, [r0, #16]
   12388:	streq	r3, [r0, #20]
   1238a:	addeq.w	r2, r0, #24
   1238e:	movs	r3, #0
   12390:	str	r3, [r2, #0]
   12392:	str	r3, [r2, #4]
   12394:	str	r3, [r2, #8]
   12396:	mov	r0, r4
   12398:	pop	{r4, pc}
   1239a:	mov	r2, r0
   1239c:	b.n	1238e <_calloc_r+0x3e>
   1239e:	movs	r1, #0
   123a0:	bl	8fc0 <memset>
   123a4:	mov	r0, r4
   123a6:	pop	{r4, pc}
   123a8:	add.w	r2, r0, #8
   123ac:	b.n	1238e <_calloc_r+0x3e>
   123ae:	nop
   123b0:	.word	0x69736162
   123b4:	.word	0x6f532063
   123b8:	.word	0x20646e75
   123bc:	.word	0x6f636552
   123c0:	.word	0x72656472
   123c4:	.word	0x72655620
   123c8:	.word	0x6e6f6973
   123cc:	.word	0x6546203a
   123d0:	.word	0x36322062
   123d4:	.word	0x32303220
   123d8:	.word	0x37312032
   123dc:	.word	0x3a37303a
   123e0:	.word	0x45003135
   123e4:	.word	0x6f20646e
   123e8:	.word	0x65532066
   123ec:	.word	0x00707574
   123f0:	.word	0x6f6f4c0a
   123f4:	.word	0x00203a70
   123f8:	.word	0x00203a20

000123fc <vtable for Stream>:
	...
   12404:	1...............
   12414:	1...1...1...

00012420 <vtable for StreamFile<FsBaseFile, unsigned long long>>:
	...
   12428:	{...q...........
   12438:	............

00012444 <vtable for FsFile>:
	...
   1244c:	{...q...........
   1245c:	............

00012468 <vtable for File>:
	...
   12470:	y...........G...
   12480:	+...S...7.......
   12490:	....

00012494 <vtable for SDFile>:
	...
   1249c:	U...y...........
   124ac:	................
   124bc:	-...1...I...-...
   124cc:	....a...........
   124dc:	............'...
   124ec:	..../Config.txt.
   124fc:	%10d.... Menu. '
   1250c:	:h'  : print hel
   1251c:	p. ':s'  : start
   1252c:	 acquisition. ':
   1253c:	e'  : stop acqui
   1254c:	sition. ':w'  : 
   1255c:	write parameters
   1256c:	 to microSD card
   1257c:	. ':l'  : list d
   1258c:	isks. ':r'  : re
   1259c:	set MTP. ':b'  :
   125ac:	 reboot CPU. '?p
   125bc:	'  : show all pa
   125cc:	rameters. '?d'  
   125dc:	: get date. '?t'
   125ec:	  : get time. '?
   125fc:	a'  : get file d
   1260c:	uration (s). '!d
   1261c:	 yyyy/mm/dd<cr>'
   1262c:	  : set date. '!
   1263c:	t hh:mm:ss<cr>' 
   1264c:	   : set time. '
   1265c:	!a val<cr>'  : s
   1266c:	et file duration
   1267c:	 (s).CVAS_V3 Ver
   1268c:	sion: Feb 26 202
   1269c:	2 17:07:51.Teens
   126ac:	y: %d: %06x..Dat
   126bc:	e d = %04d/%02d/
   126cc:	%02d..Time t = %
   126dc:	02d:%02d:%02d..T
   126ec:	_acq a = %d..%d%
   126fc:	c%d%c%d.start.st
   1270c:	op.rebooting CPU
	...

0001271d <monthDays>:
   1271d:	...............

0001272c <vtable for MySpiClass>:
	...
   12734:	]...........Q...
   12744:	............I...
   12754:	No spi storage.S
   12764:	torage %d %d %s 
   12774:	.%d %d.D./%s%06x
   12784:	_%04d%02d%02d/%0
   12794:	2d/./%s%06x_%04d
   127a4:	%02d%02d/%02d_%0
   127b4:	2d/.F.%s_%02d%02
   127c4:	d%02d.bin.Failin
   127d4:	g open file.WMXZ
   127e4:	.%s%04d%02d%02d_
   127f4:	%02d%02d%02d.sd1
   12804:	.No I2C address 
   12814:	found...

0001281c <TwoWire::i2c0_hardware>:
   1281c:	4..@@.....".0...
   1282c:	....!./.........

0001283c <TwoWire::i2c1_hardware>:
   1283c:	4..@....&:......
   1284c:	..%;............

0001285c <TwoWire::i2c2_hardware>:
   1285c:	(..@@...........
   1286c:	............J...

0001287c <vtable for TwoWire>:
	...
   12884:	.$...%.......$..
   12894:	.$...$...$..

000128a0 <SPISettings::ctar_div_table>:
   128a0:	................
   128b0:	...... .(.8.@.`.
   128c0:	................

000128d0 <SPIClass::spi0_hardware>:
   128d0:	<..@............
   128e0:	...../....'.....
   128f0:	................
   12900:	................
   12910:	................
   12920:	..........-.....
   12930:	................
   12940:	................
   12950:	................
   12960:	.. .

00012964 <SPISettings::ctar_clock_table>:
   12964:	................
   12974:	................
   12984:	. ....... ...0..
   12994:	. ... ...@...@..
   129a4:	.P...P...`...`..
   129b4:	.p...`...p..

000129c0 <vtable for SDClass>:
	...
   129c8:	}..../...0..'1..
   129d8:	.0../0...1...1..
   129e8:	.2...3..

000129f0 <FsGetPartitionInfo::mbdpGuid>:
   129f0:	......3D..h..&..
   12a00:	EFI PART..

00012a0a <lookupTable>:
   12a0a:	..x...C.........
   12a1a:	..............=.
   12a2a:	.. .............
   12a3a:	................
   12a4a:	................
   12a5a:	....:.e,<.;.>.f,
   12a6a:	B.A.S...T...V...
   12a7a:	W...Y...[...`...
   12a8a:	c...h...i...k.b,
   12a9a:	o...r...u...}.d,
   12aaa:	..............D.
   12aba:	..........E.....
   12aca:	{...|...}.......
   12ada:	................
   12aea:	................
   12afa:	}.c,Q.Y.S.[.U.].
   12b0a:	W._.x...y.......
   12b1a:	............N!2!
   12b2a:	.!.!a,`,v,u,

00012b36 <mapTable>:
   12b36:	a..............0
   12b46:	2...9...J...y...
   12b56:	................
   12b66:	.......("...F...
   12b76:	................
   12b86:	0.. P...`.."...6
   12b96:	.......Da..&....
   12ba6:	...Z........ ...
   12bb6:	0...@...`...p.J.
   12bc6:	r.V.v.d.z.p.|.~.
   12bd6:	................
   12be6:	........p!...$..
   12bf6:	0,./g,...,.d.-.&
   12c06:	A...Device is to
   12c16:	o small...Writin
   12c26:	g FAT ...Writing
   12c36:	 upcase table...
   12c46:	Writing root...F
   12c56:	ormat done...For
   12c66:	mat failed...EXF
   12c76:	AT.Bad cluster c
   12c86:	ount...Card is t
   12c96:	oo small....Form
   12ca6:	at Done...Format
   12cb6:	 Failed...

00012cc0 <vtable for SdSpiCard>:
	...
   12cc8:	.v...v...v...u..
   12cd8:	.{...{...v...|..
   12ce8:	[~...w...w...|..
   12cf8:	.u...u..[{..S{..
   12d08:	.z..W....u...}..
   12d18:	.|..s}..

00012d20 <vtable for SdioCard>:
	...
   12d28:	!...........i...
   12d38:	........e.......
   12d48:	........#.......
   12d58:	................
   12d68:	....=...........
   12d78:	........

00012d80 <digital_pin_to_info_PGM>:
   12d80:	@..C@..@D..CD..@
   12d90:	...C...@0..C0..@
   12da0:	4..C4..@...C...@
   12db0:	...C...@...C...@
   12dc0:	...C...@...C...@
   12dd0:	...C...@...C...@
   12de0:	...C...@...C...@
   12df0:	...C...@...C...@
   12e00:	...C...@...C...@
   12e10:	...C...@...C...@
   12e20:	...C...@...C...@
   12e30:	...C...@...C...@
   12e40:	h .Ch..@...C...@
   12e50:	8..C8..@<..C<..@
   12e60:	@..C@..@H..CH..@
   12e70:	L..CL..@(..C(..@
   12e80:	,..C,..@` .C`..@
   12e90:	d .Cd..@ ..C ..@
   12ea0:	$..C$..@(..C(..@
   12eb0:	,..C,..@D..CD..@
   12ec0:	p..Cp..@t..Ct..@
   12ed0:	h..Ch..@P..CP..@
   12ee0:	X..CX..@\..C\..@
   12ef0:	T..CT..@ ..C ..@
   12f00:	$..C$..@...C...@
   12f10:	...C...@8..C8..@
   12f20:	4..C4..@0..C0..@
   12f30:	<..C<..@,..C,..@
   12f40:	( .C(..@, .C,..@
   12f50:	. .C...@. .C...@
   12f60:	. .C...@. .C...@
   12f70:	. .C...@. .C...@

00012f80 <vtable for usb_serial_class>:
	...
   12f88:	................
   12f98:	}...y...u...q...
   12fa8:	..

00012faa <usb_endpoint_config_table>:
   12faa:	......

00012fb0 <usb_descriptor_list>:
   12fb0:	................
   12fc0:	....C...........
   12fd0:	................
   12fe0:	................
   12ff0:	................
   13000:	....

00013004 <_global_impure_ptr>:
   13004:	 ...C...POSIX...
   13014:	....

00013018 <fpi.6173>:
   13018:	5...............
   13028:	....nf..inity...
   13038:	an..

0001303c <fpinan.6209>:
   1303c:	4...............
   1304c:	....

00013050 <tinytens>:
   13050:	.......<3...#.I9
   13060:	=..D...2......[%
   13070:	Co.d(.h.

00013078 <zeroes.7258>:
   13078:	0000000000000000
   13088:	INF.inf.NAN.nan.
   13098:	0123456789ABCDEF
   130a8:	....0123456789ab
   130b8:	cdef....(null)..
   130c8:	0...

000130cc <blanks.7257>:
   130cc:	                

000130dc <basefix.7328>:
   130dc:	................
   130ec:	................
   130fc:	....e%ld....

00013108 <_ctype_>:
   13108:	.         ((((( 
   13118:	                
   13128:	 ...............
   13138:	................
   13148:	..AAAAAA........
   13158:	................
   13168:	..BBBBBB........
   13178:	................
   13188:	 ...............
	...
   13208:	....Infinity....
   13218:	NaN.

0001321c <__hexdig>:
	...
   1324c:	................
   1325c:	................
	...
   1327c:	................
	...
   1331c:	....

00013320 <__mprec_tens>:
   13320:	.......?......$@
   13330:	......Y@.....@.@
   13340:	.......@.....j.@
   13350:	.......A......cA
   13360:	.......A....e..A
   13370:	... _..B....vH7B
   13380:	......mB..@..0.B
   13390:	.......B..4&.k.C
   133a0:	...7y.AC....W4vC
   133b0:	..Ngm..C.=.`.X.C
   133c0:	@..x...DP.....KD
   133d0:	..M....D.J...-.D
   133e0:	...yCx.D

000133e8 <__mprec_bigtens>:
   133e8:	...7y.AC.n.....F
   133f8:	..?..O8M2.0.Hw.Z
   13408:	<.s..O.u

00013410 <p05.6087>:
   13410:	........}...

0001341c <_init>:
   1341c:	push	{r3, r4, r5, r6, r7, lr}
   1341e:	nop
   13420:	pop	{r3, r4, r5, r6, r7}
   13422:	pop	{r3}
   13424:	mov	lr, r3
   13426:	bx	lr

00013428 <__init_array_start>:
   13428:	.word	0x0000f74d

0001342c <__frame_dummy_init_array_entry>:
   1342c:	5........!..u$..
   1343c:	e3..

Disassembly of section .fini:

00013440 <_fini>:
   13440:	push	{r3, r4, r5, r6, r7, lr}
   13442:	nop
